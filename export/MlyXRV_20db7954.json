{"ver":"0.1","info":{"id":"MlyXRV","date":"1485084422","viewed":538,"name":"Pilot Waves","username":"kaswan","description":"Maze game for GGJ@Busan 2017.\n\nArrow keys: move\nSPACE: generate wave\nM, S: show maze \n\nBased on rory618's 2D wave sandbox https://www.shadertoy.com/view/MtdSR4\nand used code in 4rknova's Sprite Encoding Tutorial https://www.shadertoy.com/view/XtlGzN","likes":9,"published":1,"flags":112,"usePreview":0,"tags":["game","wave","maze","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pilot Waves by kaswan\n// I made this game for Global Game Jam @Busan 2017\n//\n// Based on rory618's 2D wave sandbox https://www.shadertoy.com/view/MtdSR4\n// and used sprite encoding code in 4rknova's Sprite Encoding Tutorial https://www.shadertoy.com/view/XtlGzN\n\nconst vec2 txSourcePos  = vec2(31.0,1.0);\nconst vec2 txSourceState \t= vec2(31.0,3.0);\nconst vec2 txShowWall     = vec2(31.0,5.0);\nconst vec2 txAmplitude  = vec2(31.0,7.0);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel2, (0.5+re) / iChannelResolution[2].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 sourcePos = loadValue(txSourcePos);    \n    vec4 showWall = loadValue(txShowWall);    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 t = texture(iChannel0, uv);\n\t\n    if (showWall.x > 0.5 || iTime < 2.0){\n    \tfragColor = texture(iChannel3, t.yx * vec2(.04,.004)) + texture(iChannel1, uv);\n    }\n    else {\n        \n\t\tfragColor = texture(iChannel3, t.yx * vec2(.04,.004));// + texture(iChannel1, uv);\n    }\n    \n    if (length(fragCoord - sourcePos.xy) < 5.0) {\n    \tfragColor = vec4(0.2, 0.5, 1.0, 1.0);\n    \n    }\n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 txSourcePos  \t= vec2(31.0,1.0);\nconst vec2 txSourceState \t= vec2(31.0,3.0);\nconst vec2 txShowWall     \t= vec2(31.0,5.0);\nconst vec2 txAmplitude  \t= vec2(31.0,7.0);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel2, (0.5+re) / iChannelResolution[2].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\n////////////////////////////////////////////////////////////\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel3, vec2(key,0.25) ).x > .5;\n}\n////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 sourcePos = loadValue(txSourcePos);    \n    vec4 sourceState = loadValue(txSourceState);    \n    vec4 amplitude = loadValue(txAmplitude);    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 l = texture(iChannel0, (fragCoord-vec2(1.,0))/iResolution.xy).xy;\n    vec2 r = texture(iChannel0, (fragCoord+vec2(1.,0))/iResolution.xy).xy;\n    vec2 u = texture(iChannel0, (fragCoord-vec2(0,1.))/iResolution.xy).xy;\n    vec2 d = texture(iChannel0, (fragCoord+vec2(0,1.))/iResolution.xy).xy;\n    \n    vec2 t = texture(iChannel0, uv).xy;\n        \n    t = mix(t,(l+r+u+d)/4.,.01);\n        \n\tfloat DL = l.x-t.x;\n\tfloat DR = r.x-t.x;\n\tfloat DU = u.x-t.x;\n\tfloat DD = d.x-t.x; \n    t.y += (DL+DR+DU+DD)/4.;\n    t.x += t.y;\n    \n    \n    float f = 4.0; // wave frequancy\n    //float decay = 0.2 - sourceState.x * 0.1;\n    //if (abs(amplitude.x) < 0.1) amplitude.x = 0.0;\n    t = mix(t, amplitude.x * vec2(sin(iTime*f), cos(iTime*f)), .5*exp(-.2*length(fragCoord-sourcePos.xy)));\n    \n    if(fragCoord.x<1. || fragCoord.y<1. || fragCoord.x>iResolution.x-1. || fragCoord.y>iResolution.y-1.){\n        t *= 0.;\n    }\n    \n    \n    // wave decay\n    if (t.x > 0.0) {\n    \t t.x *= 0.5;\n    \n    }\n    \n    // Reset wave fields\n    if ( keyIsDown(KEY_R)) {\n        t *= 0.0;\n    }\n    \n    \n    // maze wall\n    t *= 1.0 - texture(iChannel1, uv).x;\n    \n    fragColor = vec4(t.x,t.y,0,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DISPLAY_GRID 0\n#define BACKGROUND   vec3(.0)\n\n#define _ 0. // Color Palette Index 0\n#define B 1. // Color Palette Index 1\n#define D 2. // Color Palette Index 2\n#define O 3. // Color Palette Index 3\n#define Q(i,a,b,c,d,e,f,g,h) if(y==i)m=(a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g+h*4.)))))));\n\nvec2 grid(vec2 p, vec2 sz)\n{\n    return floor(p * sz);    \n}\n\n// Sprite\nvec3 MazeLeft(vec2 p, vec2 scale)\n{\n    vec3 res = BACKGROUND;\n\n    vec2 gv = grid(p, scale); // The grid guide\n    \n    if (gv.x >= 0. && gv.y >= 0. &&\n        gv.x <= 15. && gv.y <= 15.) {\n        \n        #if (DISPLAY_GRID == 1)\n        \tres = vec3(mod(gv.x + gv.y, 2.) * .05 + BACKGROUND);\n        #endif\n        \n        // Indexing is upside down.\n        int y = int(scale.y - gv.y - 5.);\n\n    \tfloat m = 0.;\n\t\tQ(0, B,B,B,B,B,B,B,B)\n\t\tQ(1, B,_,_,_,_,_,_,_)\n\t\tQ(2, B,_,B,B,B,_,B,_)\n\t\tQ(3, B,_,_,_,B,_,D,D)\n\t\tQ(4, B,_,B,B,B,_,B,_)\n\t\tQ(5, B,_,B,_,_,_,B,D)\n\t\tQ(6, B,_,_,_,B,_,B,_)\n\t\tQ(7, B,_,B,B,B,_,_,_)\n\t\tQ(8, B,_,B,_,_,_,_,_)\n\t\tQ(9, B,_,B,B,B,_,D,B)\n\t\tQ(10,B,_,B,_,D,_,D,_)\n        Q(11,B,B,B,_,D,_,D,_)\n\t\tQ(12,B,_,_,_,_,_,D,_)\n\t\tQ(13,B,_,B,B,B,B,B,_)\n\t\tQ(14,B,_,_,_,_,_,_,_) // some of pants and jacket\n\t\tQ(15,B,B,B,B,B,B,B,B)\n        \n    \tfloat ldx = 15. - gv.x; // Calculate the left  bit index\n        float rdx = gv.x;       // Calculate the right bit index\n        float bit = 0.;\n        \n        //if (gv.x >= 8.)\tbit = mod(m / pow(4., ldx), 4.); // Decode\n        //else            bit = mod(m / pow(4., rdx), 4.); // Mirror\n        bit = mod(m / pow(4., rdx), 4.); // Decode\n    \tbit = floor(bit);                                // Sharpen    \n    \t\n        // Colorize\n             if (bit > 2.) res = vec3(.6471,.6471,.6471);\n        else if (bit > 1.) res = vec3(1.,0.8941176471,0.6745098039);\n        else if (bit > 0.) res = vec3(0.8549019608,0.4980392157, 0.1568627451);\n    }\n    \n    return res;\n}\n\n// Sprite\nvec3 MazeRight(vec2 p, vec2 scale)\n{\n    vec3 res = BACKGROUND;\n\n    vec2 gv = grid(p, scale); // The grid guide\n    \n    if (gv.x >= 0. && gv.y >= 0. &&\n        gv.x <= 15. && gv.y <= 15.) {\n        \n        #if (DISPLAY_GRID == 1)\n        \tres = vec3(mod(gv.x + gv.y, 2.) * .05 + BACKGROUND);\n        #endif\n        \n        // Indexing is upside down.\n        int y = int(scale.y - gv.y - 5.);\n\n    \tfloat m = 0.;\n\t\tQ(0, B,B,B,B,B,B,B,B)\n\t\tQ(1, B,_,_,_,_,_,_,_)\n\t\tQ(2, B,_,B,_,B,_,_,_)\n\t\tQ(3, B,_,B,D,B,_,D,D)\n\t\tQ(4, B,_,_,B,_,_,B,_)\n\t\tQ(5, B,B,B,B,_,B,B,_)\n\t\tQ(6, B,_,_,_,_,B,_,_)\n\t\tQ(7, B,_,B,B,B,B,_,_)\n\t\tQ(8, B,_,B,_,_,_,_,_)\n\t\tQ(9, B,_,B,B,B,B,D,_)\n\t\tQ(10,B,_,_,_,_,_,D,_)\n        Q(11,B,B,B,D,D,_,D,_)\n\t\tQ(12,B,_,_,_,_,_,D,_)\n\t\tQ(13,B,B,B,_,B,B,B,B)\n\t\tQ(14,_,_,_,_,B,_,_,_) // some of pants and jacket\n\t\tQ(15,B,B,B,B,B,B,B,B)\n        \n    \tfloat ldx = 15. - gv.x; // Calculate the left  bit index\n        float rdx = gv.x;       // Calculate the right bit index\n        float bit = 0.;\n        \n        //if (gv.x >= 8.)\tbit = mod(m / pow(4., ldx), 4.); // Decode\n        //else            bit = mod(m / pow(4., rdx), 4.); // Mirror\n        bit = mod(m / pow(4., ldx), 4.); // Decode\n    \tbit = floor(bit);                                // Sharpen    \n    \t\n        // Colorize\n             if (bit > 2.) res = vec3(.6471,.6471,.6471);\n        else if (bit > 1.) res = vec3(1.,0.8941176471,0.6745098039);\n        else if (bit > 0.) res = vec3(0.8549019608,0.4980392157, 0.1568627451);\n    }\n    \n    return res;\n}\n\n\n#define _lineSegment(a, b, c, d) lineSegment(fragColor, fragCoord, a, b, c, d);\n\nvoid lineSegment(inout vec4 fragColor, vec2 z, vec2 a, vec2 b, vec4 c,  float w){\n    float d = dot(z-mix(a, b, 0.5), b-a);\n    \n    if(abs(d) < dot(a-b, a-b)/2.0){\n    \td = length(cross( normalize(vec3(a-b, 0.0)), vec3(z-b, 0.0)));\n    } else {\n        d = min(length(z-b), length(z-a));\n    }\n    fragColor.xyz = mix(fragColor.xyz, c.xyz, c.w * clamp(w-d, 0.0, 1.0));\n}\n\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_E  = 69.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel3, vec2(key, 0.25) ).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;\n    \n\tfragColor = texture(iChannel1, uv);\n    vec4 mo = texture(iChannel1, vec2(0));\n    if(iMouse.w > 0.0 && mo.w > 0.0 && length(mo.xy-iMouse.xy) > 3.0){\n    \tif ( keyIsDown(KEY_E)) {\n        \t_lineSegment(iMouse.xy, mo.xy, vec4(0,0,0,1), 5.0);\n        } else {\n        \t_lineSegment(iMouse.xy, mo.xy, vec4(1), 2.0);\n        }\n    }\n    \n    vec3 res = MazeLeft(uv - vec2(.52, .12), vec2(20.9));\n    res += MazeRight(uv - vec2(.52, .12), vec2(20.9));\n    \n    \n    fragColor = vec4(res, 1.0);\n    \n    if ( keyIsDown(KEY_W)) {\n        fragColor *= 0.;\n    }\n    \n    if (length(fragCoord) < 1.0){\n        if(length(mo.xy - iMouse.xy) > 3.0){\n        \tfragColor = iMouse;\n        } else {\n            fragColor = vec4(mo.xy, iMouse.zw);\n        }\n    }\n    \n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4d2Gzc","filepath":"https://soundcloud.com/lightningyellow/pilot-wave-bpm90ver","previewfilepath":"https://soundcloud.com/lightningyellow/pilot-wave-bpm90ver","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const vec2 txSourcePos  = vec2(31.0,1.0);\nconst vec2 txSourceState \t= vec2(31.0,3.0);\nconst vec2 txShowWall     = vec2(31.0,5.0);\nconst vec2 txAmplitude  = vec2(31.0,7.0);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel2, (0.5+re) / iChannelResolution[2].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nbool checkWall( in vec2 re )\n{\n    bool value = false;\n    \n    if (texture( iChannel1, (0.5+re) / iChannelResolution[1].xy ).x > 0.5) value = true;\n    \n    return value;\n}\n\n\n////////////////////////////////////////////////////////////\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_M  = 77.5/256.0;\nconst float KEY_R  = 82.5/256.0;\nconst float KEY_S  = 83.5/256.0;\n\nbool keyIsDown( float key ) {\n    return texture( iChannel3, vec2(key,0.25) ).x > .5;\n}\n\n//vec4 sourcePos = vec4(iResolution.xy/2.0,0,0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec4 sourcePos = loadValue(txSourcePos);    \n    vec4 sourceState = loadValue(txSourceState);    \n    vec4 showWall = loadValue(txShowWall);    \n    vec4 amplitude = loadValue(txAmplitude);  \n    \n    fragColor = vec4(0.0,0.0,1.0,1.0);\n\n    float speed = 0.5;\n    float amplitudeValue = 0.1;\n    if ( keyIsDown(KEY_LEFT)) {\n        sourcePos.x -= speed;\n        amplitude.x = amplitudeValue;\n        if (checkWall(sourcePos.xy)) sourcePos.x += speed;\n    }\n    if ( keyIsDown(KEY_RIGHT)) {\n        sourcePos.x += speed;\n        amplitude.x = amplitudeValue;\n        if (checkWall(sourcePos.xy)) sourcePos.x -= speed;\n    }\n    if ( keyIsDown(KEY_UP)) {\n        sourcePos.y += speed;\n        amplitude.x = amplitudeValue;\n        if (checkWall(sourcePos.xy)) sourcePos.y -= speed;\n    }\n    if ( keyIsDown(KEY_DOWN)) {\n        sourcePos.y -= speed;\n        amplitude.x = amplitudeValue;\n        if (checkWall(sourcePos.xy)) sourcePos.y += speed;\n    }\n\n    if ( keyIsDown(KEY_SPACE)) {\n        sourceState.x = 20.0;\n        amplitude.x = 3.0;\n    }\n    \n    if ( keyIsDown(KEY_M) || keyIsDown(KEY_S)) {\n    \tshowWall.x = 1.0;\n\t}\n    else {\n    \tshowWall.x = 0.0;\n    }\n\n    if (sourceState.x > 0.0){\n    \tsourceState.x -= 0.1; \n\t}\n\n    if (amplitude.x > 0.0){\n    \tamplitude.x *= 0.5;\n        if (amplitude.x < 0.0) amplitude.x = 0.0;\n\t}\n    \n    if (iFrame < 1) sourcePos.xy = iResolution.xy / 2.0;\n    //if (iFrame < 1) sourcePos.xy = vec2(20, 20);\n    \n    storeValue( txSourcePos, vec4(sourcePos), fragColor, fragCoord );\n    storeValue( txSourceState, vec4(sourceState), fragColor, fragCoord );\n    storeValue( txShowWall, vec4(showWall), fragColor, fragCoord );\n    storeValue( txAmplitude, vec4(amplitude), fragColor, fragCoord );\n}","name":"Buffer C","description":"","type":"buffer"}]}