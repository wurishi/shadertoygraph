{"ver":"0.1","info":{"id":"tdXSRn","date":"1550430035","viewed":807,"name":"Raymarch Mandelbox 2","username":"darkeclipz","description":"Variant of https://www.shadertoy.com/view/3dfXzr, with different folds.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define MaxSteps 32.\n#define MinDistance 0.0075\n#define eps 0.0001\n\n// more ideas for different Mandelboxes:\n// http://archive.bridgesmathart.org/2018/bridges2018-547.pdf\n\nmat3 rotateX(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(1, 0, 0, 0, c, -s, 0, s, c);\n}\n\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;    \n}\n\n// from iq\nfloat sdPlane(in vec3 p, in vec4 n)\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n// from iq\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0));\n        \n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 boxFold(vec3 z, vec3 r) {\n\treturn clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n// http://www.fractalforums.com/fragmentarium/fragmentarium-an-ide-for-exploring-3d-fractals-and-other-systems-on-the-gpu/15/\nvoid sphereFold(inout vec3 z, inout float dz) {\n    \n    float fixedRadius2 = .6 + 4.* cos(20./8.) + 4.;\n    float minRadius2 = 0.3;\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp;\n\t\tdz*=temp;\n\t} \n    else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp;\n\t\tdz*=temp;\n\t}\n}\n\n// https://github.com/HackerPoet/MarbleMarcher/blob/master/assets/frag.glsl\nvec3 mengerFold(vec3 z) {\n\tfloat a = min(z.x - z.y, 0.0);\n\tz.x -= a;\n\tz.y += a;\n\ta = min(z.x - z.z, 0.0);\n\tz.x -= a;\n\tz.z += a;\n\ta = min(z.y - z.z, 0.0);\n\tz.y -= a;\n\tz.z += a;\n    return z;\n}\n\n// http://blog.hvidtfeldts.net/index.php/2011/11/distance-estimated-3d-fractals-vi-the-mandelbox/\nvec2 DE(vec3 z)\n{\n    float Iterations = 20.;\n    float Scale = 3.6;\n\tvec3 offset = z;\n\tfloat dr = 1.0;\n    float trap = 1e10;\n\tfor (float n = 0.; n < Iterations; n++) {\n        \n\n        z = mengerFold(z);\n        z = boxFold(z, vec3(2.));       // Reflect\n        sphereFold(z, dr);    // Sphere Inversion\n        z.xz = -z.zx;\n\t\tz = boxFold(z, vec3(1.));       // Reflect\n        \n\t\tsphereFold(z, dr);    // Sphere Inversion\n        z=Scale*z + offset;  // Scale & Translate\n        dr = dr*abs(Scale)+1.0;\n        trap = min(trap, length(z));\n\t}\n\tfloat r = length(z);\n\treturn vec2(r/abs(dr), trap);\n}\n\nvec2 scene(vec3 p) {  \n    \n    vec2 box = DE(p);\n\treturn box;\n}\n\nfloat shadowScene(vec3 p){\n\treturn DE(p).x;\n}\n\n// from iq\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  k.yyx*scene( p + k.yyx*h ).x + \n                  k.yxy*scene( p + k.yxy*h ).x + \n                  k.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n\n// ro: ray origin, rd: ray direction\n// returns t and the occlusion as a vec2\nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, 1.-i/MaxSteps, hit.y);  \n        }\n    }\n    return vec3(0.);\n}\n\nfloat marchShadow(vec3 ro, vec3 rd) {\n\tfloat t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn t-MinDistance;    \n        }\n    }\n    return 0.;\n}\n\n\n\n// https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model\nvec3 shadeBlinnPhong(vec3 p, vec3 viewDir, vec3 normal, vec3 lightPos, float lightPower, vec3 lightColor) {\n    vec3 diffuseColor = vec3(0.5);\n    vec3 specColor = vec3(1);\n    float shininess = 16.;\n\n    vec3 lightDir = lightPos - p;\n    float dist = length(lightDir);\n    dist = dist*dist;\n    lightDir = normalize(lightDir);\n    \n    float lambertian = max(dot(lightDir, normal), 0.0);\n    float specular = .0;\n    \n    if(lambertian > 0.) {\n        viewDir = normalize(-viewDir);\n        \n        vec3 halfDir = normalize(viewDir + lightDir);\n        float specAngle = max(dot(halfDir, normal), .0);\n        specular = pow(specAngle, shininess);\n    }\n    \n    vec3 color = /*ambientColor +*/\n                 diffuseColor * lambertian * lightColor * lightPower / dist +\n        \t\t specColor * specular * lightColor * lightPower / dist;\n    \n   \treturn color;\n}\n\n// p: point, sn: surface normal, rd: ray direction (view dir/ray from cam)\nvec3 light(vec3 p, vec3 sn, vec3 rd) {\n    vec3 top = shadeBlinnPhong(p, rd, sn, vec3(0,1,0), 25., vec3(.2,.2,.4));\n    \n    mat3 rot = rotateZ(iTime / 10.) * rotateY(iTime / 10.) * rotateX(iTime / 10.);\n    \n    vec3 L1 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,5) * rot, 10., vec3(.4,.1,.1));\n    vec3 L2 = shadeBlinnPhong(p, rd, sn, vec3(5,-5,-5) * rot, 10., vec3(.4,.1,.1));\n    vec3 L3 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,5) * rot, 10., vec3(.4,.1,.1));\n    vec3 L4 = shadeBlinnPhong(p, rd, sn, vec3(-5,-5,-5) * rot, 10., vec3(.4,.1,.1));\n    \n\n    mat3 rot2 = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    vec3 camPos = (vec3(0,0,-3)- vec3(0,1,15)) * rot2 ;\n    vec3 cam = shadeBlinnPhong(p, rd, sn, camPos, 13., vec3(.9));\n    \n    vec3 ambient = vec3(.25);\n    return L1 + L2 + L3 + L4 + ambient + top + cam;\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos(6.28318 * (c*t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    vec3 col = vec3(.0);\n    vec3 ro = vec3(0,0,-3); // ray origin\n    vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro); // ray direction\n    \n    mat3 rot = rotateX(0.2) * rotateZ(-3.1415/2. - 0.2) * rotateY(iTime/16.);\n    \n    ro -= vec3(0,1,15);\n    ro *= rot;\n    rd *= rot;\n    \n    vec3 hit = march(ro, rd); // returns t and the occlusion value \n    float t = hit.x;\n    \n    if(t > eps) {\n        vec3 p = ro + t * rd;\n    \tvec3 n = calcNormal(p);\n        \n        col += light(p, n, rd);\n        col *= hit.y;   // occlusion \n        \n        col = mix(col, vec3(0), clamp(1.-10./t, 0., 1.));\n    }\n    else {\n        col = vec3(0);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}