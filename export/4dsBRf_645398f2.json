{"ver":"0.1","info":{"id":"4dsBRf","date":"1497285590","viewed":96,"name":"Threstle-raymarching-2","username":"Threstle","description":"Threstle-raymarching-2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["threstleraymarching2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// formules courtesy of https://iquilezles.org/articles/distfunctions\n\n\nfloat unite( float a, float b){return min(a, b);}\nfloat subtract( float a, float b ){ return max(-a, b); }\nfloat intersect( float a, float b ){ return max(a, b); }\nfloat sphere( vec3 p, float s ){return length(p)-s;}\n\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n#if 0\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n#else\n    float d1 = q.z-h.y;\n    float d2 = max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n#endif\n}\n\nfloat sdHexPrism( vec3 p, vec2 h)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\nfloat torus( vec3 p, vec2 t, float hole  )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  \n  return length(q)-(t.y/hole);\n}\n\nfloat displacement(vec3 p){\n    \n    return sin(10.0*p.x)*cos(10.0*p.y)*cos(10.0*p.z);\n}\n\nvec3 rotate(vec3 p,float angle, int axis){\n    mat3 rot;\n    \n    if(axis == 0)\n    {\n        rot[0] = vec3(1.0,0,0.0);\n        rot[1] = vec3(0.0,cos(angle),sin(angle));\n        rot[2] = vec3(0.0,-sin(angle),cos(angle));\n    }\n    else if(axis == 1)\n    {\n        rot[0] = vec3(cos(angle),0,-sin(angle));\n        rot[1] = vec3(0.0,1.0,0.0);\n        rot[2] = vec3(sin(angle),0.0,cos(angle));\n    }\n    else\n    {\n        rot[0] = vec3(cos(angle),sin(angle),0.0);\n        rot[1] = vec3(-sin(angle),cos(angle),0.0);\n        rot[2] = vec3(0.0,0.0,1.0);\n    }\n    \n    return p * rot;\n\n}\n\nfloat sdf(vec3 p){\n\n    \n    float angle = iTime*1.0;\n        \n    \n    \n    \n    \n    //pos = pos * rot;\n    \n    //float t = torus(vec3(p),vec2(1.0));\n    float t = torus(rotate(p,-iTime/10.0,0),vec2(1.5),8.0);\n    float t2 = torus(rotate(p,iTime*2.0,2),vec2(1.0),8.0);\n    float t3 = torus(rotate(p,-iTime*4.0,1),vec2(1.0),8.0);\n    float t4 = torus(rotate(p,iTime/4.0,2),vec2(2.0),20.0);\n    float t5 = torus(rotate(p,-iTime/1.0,2),vec2(2.5),20.0);\n    //float s = sphere(vec3(0.2),0.3);\n    \n    //float s = sphere(vec3(p),1.0);\n    //float d = displacement(vec3(t));\n    \n    //float d = subtract(t,s);\n    \n \n    return sin(t*t2*t3*t4*t5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //1 : retrieve the fragment's coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy *2.0 - 1.0; // center the scene\n    \n    uv.x *= iResolution.x / iResolution.y;\n    \n    //2 : camera position and ray direction\n\tvec3 pos = vec3( 0.,0.,-3.5);\n    \n    //pos.x = (pos.x*cos(iTime*0.1) - pos.y*sin(iTime*0.1));\n    //pos.y = (pos.x*sin(iTime*0.1) + pos.y*cos(iTime*0.1));\n    \n    float angle = iTime*1.0;\n        \n    \n    \n    // rotation sur soi mÃªme\n    mat3 rot;\n    rot[0] = vec3(cos(angle),0.0,-sin(angle));\n    rot[1] = vec3(0.0,1.0,0.0);\n    rot[2] = vec3(-sin(angle),0.0,cos(angle));\n    \n   \n    \n    \n   // pos = pos * rot;\n    \n\tvec3 dir = normalize( vec3( uv, 1. ) );\n    \n    //3 : ray march loop\n    //ip will store where the ray hits the surface\n    \n    vec3 ip;\n    \n    //variable step size\n    float t = 1.1;\n    \n    for(int i = 0; i < 32; i++){\n     \t\n        // update position along path\n        ip = pos + dir * t;\n        \n        // gets the shortest distance to the scene\n        float temp = sdf(ip);\n        \n\n        //break the loop if the distance was too small\n        // this means that we are close enough to the surface\n        if(temp < 0.01) break;\n            \n        // increment the step along the ray path\n         t+= temp;\n        \n    }\n    \n    // 4 : apply color to this fragment\n    //fragColor = vec4(ip,1.0);\n\tfragColor = vec4(vec3(ip.x*clamp(sin(iTime),0.5,1.0),ip.y*clamp(sin(iTime),0.5,1.0),ip.z*clamp(sin(iTime),0.5,1.0)),1.0);\n}","name":"Image","description":"","type":"image"}]}