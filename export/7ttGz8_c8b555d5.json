{"ver":"0.1","info":{"id":"7ttGz8","date":"1635729326","viewed":56,"name":"log cones","username":"do","description":"cone trace test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["conetracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//log cones\n//2021\n//do\n\n//logarithmic df + cone tracing\n\nconst int steps = 50;\nconst float eps = 0.0001;\nconst float far = 500.;\nconst float near = .1;\n\nfloat hash(float p) {\n\n    uvec2 n = uint(int(p)) *  \n    uvec2(1391674541U,2531151992.0 * float(1511.));\n    uint h = (n.x ^ n.y) * 1391674541U;\n    return float(h) * (1.0/float(0xffffffffU));\n\n}\n\nfloat ns(vec3 x) {\n\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n    float n = p.x + p.y * 157.0 + 113.0 * p.z;\n\n    return mix(mix(mix(hash(  n +   0.0) , hash(   n +   1.0)  ,f.x),\n    mix(hash(  n + 157.0) , hash(   n + 158.0)   ,f.x),f.y),\n    mix(mix(hash(  n + 113.0) , hash(   n + 114.0)   ,f.x),\n    mix(hash(  n + 270.0) , hash(   n + 271.0)   ,f.x),f.y),f.z);\n}\n\nfloat f(vec3 x,int octaves,float h) {\n\n    float t = 0.0;\n\n    float g = exp2(-h); \n\n    float a = 0.5;\n    float f = 1.0;\n\n    for(int i = 0; i < octaves; i++) {\n \n    t += a * ns(f * x); \n    f *= 2.0; \n    a *=  g;  \n    \n    }    \n\n    return t;\n}\n\nvec2 opu(vec2 d1,vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n} \n\nfloat roundCone(vec3 p,float r1,float r2,float h) {\n\n    vec2 q = vec2(length(vec2(p.x,p.y)),p.z);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0 - b*b);\n    float k = dot(q,vec2(-b,a));\n\n    if( k < 0.0) return length(q) - r1;\n    if( k > a*h) return length(q - vec2(0.0,h)) - r2;\n\n    return dot(q,vec2(a,b)) - r1;\n} \n\nvec2 scene(vec3 p) { \n\nvec2 res = vec2(1.0,0.0);\nfloat scale = float(45.) / radians(180.);\n\nvec2 h = p.xz; \nfloat r = length(h); \nh = vec2(log(r),atan(h.y,h.x));\nh *= scale;\nh = mod(h,2.) - 1.;\nfloat mul = r/scale;\n\np.y += ns(p * .5) + .5;\n\nfloat d = 0.;\nd = roundCone(vec3(h,p.y/mul),1.,.5,2.) * mul; \n//d = length(vec3(h,p.y/mul),1.)* mul;\n\nres = vec2(d,1.);\n\nreturn res;\n\n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * eps;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)).x +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)).x +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)).x + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x)).x\n\n    ));\n\n}\n\nvec3 rayCamDir(vec2 uv,vec3 camPosition,vec3 camTarget,float fPersp) {\n\n     vec3 camForward = normalize(camTarget - camPosition);\n     vec3 camRight = normalize(cross(vec3(0.0,1.0,0.0),camForward));\n     vec3 camUp = normalize(cross(camForward,camRight));\n\n     vec3 vDir = normalize(uv.x * \n     camRight + uv.y * camUp + camForward * fPersp);  \n\n     return vDir;\n}\n\nvec3 render(vec3 ro,vec3 rd,float dist) {\n\nvec3 col = vec3(.5);\nvec3 bgcol = vec3(1.) * max(0.,rd.y);\n\nro += rd * (dist*.98); \nvec3 p = ro;\n\nvec3 n = calcNormal(p);\nvec3 l = normalize(vec3(2.,10.,1.));\nvec3 h = normalize(l - rd);\nvec3 r = reflect(rd,n);\n\nfloat amb = sqrt(clamp(0.5 + 0.5 * n.y,0.0,1.0));\nfloat dif = clamp(dot(n,l),0.0,1.0);\nfloat spe = pow(clamp(dot(n,h),0.0,1.0),16.)\n* dif * (.04 + 0.9 * pow(clamp(1. + dot(h,rd),0.,1.),5.));\n\nvec3 linear = vec3(1.);\n\nlinear += dif * vec3(.15);\nlinear += amb * vec3(.03);\n\ncol = col * linear;\ncol += 5. * spe * vec3(.5);\ncol = mix(col,bgcol,1.-exp(.005*dist*dist));\n\nreturn col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\nvec3 ta = vec3(0.);\nvec3 ro = vec3(1.);\nro = ta + vec3(cos(iTime*.1)-4.,2.,sin(iTime*.25)+3.);\n\nvec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.y;\n\nfloat fov = 2.;\nfloat vfov = 1.;\n\nvec3 color = vec3(1.);\nfloat dist = eps; \nfloat d = near;\n\nfloat radius = 2. * tan(vfov/2.) / iResolution.y * 1.5;\nvec3 rd = rayCamDir(uv,ro,ta,fov);\n\nvec4 col_alpha = vec4(0.,0.,0.,1.);\n \nfor(int i = 0; i < steps; i++ ) {\n    float rad = d * radius;\n    dist = scene(ro + d * rd).x;\n \n    if(dist < rad) {\n        float alpha = smoothstep(rad,-rad,dist);\n        vec3 col = render(ro,rd,d);\n        col_alpha.rgb += col_alpha.a * (alpha * col.rgb);\n        col_alpha.a *= (1. - alpha);\n\n        if(col_alpha.a < eps) break;\n    \n    }\n\n    d += max(abs(dist * .75 ), .001);\n    if(d > far) break;\n}\n\ncolor = mix(col_alpha.rgb,color,col_alpha.a);\nfragColor = vec4(pow(color,vec3(.4545)),1.0);\n \n}\n","name":"Image","description":"","type":"image"}]}