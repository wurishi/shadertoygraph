{"ver":"0.1","info":{"id":"4dKBWW","date":"1528899181","viewed":125,"name":"Glyphs","username":"JabberSnatch","description":"Ancient civilisation writings sliding around","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["abstract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n)\n{\n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\n\nvec2 NDC(vec2 frag_coord)\n{\n\treturn (frag_coord / iResolution.xy) * 2.0 - 1.0;\n}\n\nvec2 VerticalAspectCoordinates(vec2 frag_coord)\n{\n\tvec2 ndc = NDC(frag_coord);\n\tvec2 aspect_factor = vec2(iResolution.x / iResolution.y, 1.0);\n\treturn ndc * aspect_factor;\n}\n\n\nfloat udRoundBox(vec3 p, vec3 b, float r)\n{\n\treturn length(max(abs(p)-b, 0.0))-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat udRoundSegment(vec3 p, vec3 start, vec3 end, float r)\n{\n\tvec3 extent = (end - start) * 0.5;\n\tvec3 center = (end + start) * 0.5;\n\treturn udRoundBox(p - center, extent, r);\n}\n\n\nfloat object(vec3 p, float r)\n{\n\tfloat distance = udRoundSegment(p, vec3(0.25, 0.25, 0.0), vec3(0.25, 0.75, 0.0), r);\n\tdistance = min(distance, udRoundSegment(p, vec3(0.75, 0.25, 0.0), vec3(0.75, 0.75, 0.0), r));\n\tdistance = min(distance, udRoundSegment(p, vec3(0.5, 0.25, 0.0), vec3(0.5, 0.5, 0.0), r));\n\tdistance = min(distance, udRoundSegment(p, vec3(0.5, 0.5, 0.0), vec3(0.75, 0.5, 0.0), r));\n\tdistance = min(distance, udRoundSegment(p, vec3(0.5, 0.75, 0.0), vec3(0.5, 0.75, 0.0), r));\n\treturn distance;\n}\n\nfloat rand_object(vec3 p, float rand_seed)\n{\n\tfloat points[3] = float[3](0.18, 0.5, 0.82);\n\tfloat radius = 0.11;\n\tfloat segment_p = 0.5;\n\n\tfloat rand_state = rand_seed;\n\tfloat distance = 1. / 0.;\n\tfor (int i = 0; i < 3; ++i)\n\t{\n\t\tfor (int j = 0; j < 3; ++j)\n\t\t{\n\t\t\tdistance = min(distance, sdSphere(p - vec3(points[i], points[j], 0.0), radius));\n\t\t}\n\t}\n\tfor (int i = 0; i < 6; ++i)\n\t{\n\t\tfloat constant_point = points[i/2];\n\t\tint start_index = int(mod(float(i), 2.0));\n\t\tvec2 start = vec2(points[start_index], constant_point);\n\t\tvec2 end = vec2(points[start_index + 1], constant_point);\n\t\tif (rand_state < segment_p)\n\t\t{\n\t\t\tdistance = min(distance, udRoundSegment(p, vec3(start, 0.0), vec3(end, 0.0), radius));\n\t\t}\n\t\telse if (rand_state > segment_p)\n\t\t{\n\t\t\tdistance = min(distance, udRoundSegment(p, vec3(start.yx, 0.0), vec3(end.yx, 0.0), radius));\n\t\t}\n\t\trand_state = rand(rand_state);\n\t}\n\treturn distance;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord)\n{\n\tfloat scale = 15.0;\n\tvec3 glyph_color = vec3(0.67, 0.65, 0.42);\n\tvec3 background_color = vec3(0.05, 0.04, 0.03);\n\n\tvec2 local_coord = VerticalAspectCoordinates(frag_coord);\n\tvec3 world_position = vec3(local_coord * scale + vec2(0.5), 0.0) + vec3(vec2(iTime), 0.0);\n\tvec3 floor_wp = floor(world_position);\n\n\tfloat distance = 1.0;\n\tdistance = rand_object(fract(world_position.xyz), rand(floor_wp.xy));\n\n\tfloat intensity = sin((iTime + rand(floor_wp.xy) * 4.0) * (rand(floor_wp.yx) + 0.5));\n#if 1\n\tintensity = max(0.0, -distance * 15.0) * intensity;\n#else\n\tif (distance > 0.0)\n\t{\n\t\tintensity = 0.0;\n\t}\n#endif\n\n\tintensity = clamp(intensity, 0.0, 1.0);\n\tfrag_color = vec4(mix(abs(distance) * background_color * 20.0, glyph_color, intensity), 1.0);\n}","name":"Image","description":"","type":"image"}]}