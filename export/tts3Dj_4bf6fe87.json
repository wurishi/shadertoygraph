{"ver":"0.1","info":{"id":"tts3Dj","date":"1557760751","viewed":549,"name":"Spherical Worley","username":"tpfto","description":"Worley (Voronoi) noise on the surface of a sphere.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","sphere","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// demonstration of Worley (Voronoi) noise on the sphere\n\n// sphere rendering forked from https://www.shadertoy.com/view/MssGRl by asalga\n\n// some constants\n\n#define PI 3.14159265359\n#define GA 2.39996322973 // golden angle, (3 - sqrt(5)) * PI\n\n// range of the display\n\n#define SCALE 8.0\n\n// utility function\n\n#define cis(a) vec2( cos(a), sin(a) )\n\n// angle between two vectors, Kahan's formula; https://people.eecs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n\nfloat vectorAngle(vec3 p1, vec3 p2)\n{\n      vec3 np1 = normalize(p1), np2 = normalize(p2);\n\n      return 2.0 * atan(length(np1 - np2), length(np1 + np2));\n}\n\n// number of points in sphere\n#define NPTS 50\n\n// return the two closest distances for Worley noise\n\nvec2 sphworley(vec3 p)\n{\n    vec2 dl = vec2(4.0);\n    \n\tfor (int m = 0; m < NPTS; m++)\n    {\n        // generate feature points within the cell, using phyllotactic sampling\n        float mf = float(m + 1), mr = mf/float(NPTS);\n        float rr = 2.0 * sqrt((1.0 - mr) * mr);\n        vec3 tp = vec3(rr * cos(mf * GA), rr * sin(mf * GA), 1.0 - 2.0 * mr);\n        \n        float c = vectorAngle(p, tp);\n                \n        float m1 = min(c, dl.x); // ranked distances\n        dl = vec2(min(m1, dl.y), max(m1, min(max(c, dl.x), dl.y)));\n    }\n        \n    return dl;\n}\n\n// rescaling functions\n\nfloat rescale(float x, vec2 range)\n{\n\t  float a = range.x, b = range.y;\n      return (x - a)/(b - a);\n}\n\nfloat rescale(float x, vec2 r1, vec2 r2)\n{\n      return mix(r2.x, r2.y, (x - r1.x)/(r1.y - r1.x));\n}\n\n// modified MATLAB bone colormap\n\nvec3 bone( float t )\n{\n\t return 0.875 * t + 0.125 * clamp(vec3(4.0, 3.0, 3.0) * t - vec3(3.0, 1.0, 0.0), 0.0, 1.0);\n}\n\n// modified MATLAB hot colormap\n\nvec3 hot( float t )\n{\n\t return clamp(vec3(3.0, 3.0, 4.0) * t - vec3(0.0, 1.0, 3.0), 0.0, 1.0);\n}\n\n// sphere normal\n\nvec3 getNormal(in vec2 c, in float r, in vec2 point)\n{\n\treturn mix(vec3(0.0, 0.0, 1.0), normalize(vec3(point - c, 0.0)), length(point - c)/r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = iResolution.xy / iResolution.y;\n    vec2 uv = ( fragCoord.xy / iResolution.y ) - 0.5 * aspect;\n    uv *= SCALE;\n    float r = 3.0; // sphere radius\n\t\n\tif( length(uv) < r)\n    {\n\t\tvec3 sphereNormal = vec3(getNormal(vec2(0.0), r, uv));\n\t\tvec3 dirLight = normalize(vec3(0.0, 0.0, 1.0));\n        \n\t\tvec3 col = normalize(vec3(1.0)) * dot(sphereNormal, dirLight);\n\n        float del = 0.1 * PI * iTime;\n        vec2 v = sphereNormal.xy;\n        \n        vec2 w = sphworley(vec3(vec2(v.x, sqrt(1.0 - dot(v, v))) * mat2(cos(del), -sin(del), sin(del), cos(del)), v.y));\n\n        vec3 c1 = bone(rescale((2.0 * w.y * w.x)/(w.y + w.x) - w.x, vec2(0.0, 0.0625 * PI)));\n        vec3 c2 = hot(rescale(length(w.xy)/(w.y + w.x) - w.x, vec2(0.0, 0.6 * PI)));\n\t\t\n\t\tfragColor = vec4(0.15 + 2.2 * col * mix(c2, c1, 0.5 + 0.5 * cos(0.2 * iTime)), 1.0);\n\n\t} else {\n\n\t\tfragColor = vec4(0.16, 0.14, 0.13, 1.0);\n\n\t}\n}","name":"Image","description":"","type":"image"}]}