{"ver":"0.1","info":{"id":"XslBWl","date":"1498820773","viewed":137,"name":"Blured Image","username":"c0de4","description":"シュッ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to: https://wgld.org/\n\n#define time iTime\n#define mouse iMouse\n#define resolution iResolution\n\nvec3 rotate(vec3 p, float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nfloat random (in vec2 st) { \n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233))) \n                * 43758.5453123);\n}\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( random( i + vec2(0.0,0.0) ), \n                     random( i + vec2(1.0,0.0) ), u.x),\n                mix( random( i + vec2(0.0,1.0) ), \n                     random( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nfloat sphere(vec3 p, float size) {\n  p += vec3(cos(time*.1*size+noise(vec2(time))), sin(time*size), cos(time*size));\n\n  vec3 q = vec3(noise(vec2(time)), noise(vec2(time)), noise(vec2(time)));\n  return length(mod(p, .4) - .2) - size;\n}\n\n\nfloat distanceFunc(vec3 p){\n  \n  p += vec3(cos(time*.1), sin(time*.1), cos(time*.1));\n  p = rotate(p, radians(time)*1., vec3(1., 0., 0.));\n\n  float obj1 = sphere(p, .1);\n  float obj2 = max(-obj1, sphere(p*p, .2));\n  float obj3 = min(obj2, sphere(p-obj1-obj2, .4));\n\n  \n  float dist = obj3;\n\n  return dist *max(-obj1, min(obj2, obj3) );\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.1;\n    return normalize(vec3(\n        distanceFunc(p + vec3(  d, 0.0, 0.0)) - distanceFunc(p + vec3( -d, 0.0, 0.0)),\n        distanceFunc(p + vec3(0.0,   d, 0.0)) - distanceFunc(p + vec3(0.0,  -d, 0.0)),\n        distanceFunc(p + vec3(0.0, 0.0,   d)) - distanceFunc(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // fragment position\n    vec2 p = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    \n    // camera\n    vec3 cPos = vec3(0.0,  0.0,  2.);\n    vec3 cDir = vec3(0.0,  0.0, -1.);\n    vec3 cUp  = vec3(0.0,  1.0,  0.0);\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.;\n    \n    // ray\n    vec3 ray = normalize(cSide * p.y - cUp * p.x + cDir * targetDepth);\n    \n    // marching loop\n    float distance = 0.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    for(int i = 0; i < 16; i++){\n        distance = distanceFunc(rPos);\n        rLen += distance;\n        rPos = rPos * .2 + max(-(cPos - ray * rLen * .75), (cPos + ray * rLen * .75));\n    }\n    \n    // hit check\n  vec3 normal = getNormal(length(rPos) - length(p)*.5 - rPos*2.);\n        float diff = clamp(dot(lightDir*lightDir+noise(vec2(lightDir)), normal), 0.1, 1.0);\n    if(abs(distance) < .1){\n\n        fragColor = vec4(vec3(diff*.1, diff, diff*3.), 1.);\n    }else{\n        fragColor = vec4(vec3(0.), 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}