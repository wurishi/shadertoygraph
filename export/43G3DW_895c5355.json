{"ver":"0.1","info":{"id":"43G3DW","date":"1717623512","viewed":32,"name":"Simple Mandelbrot implementation","username":"hunter_bryan","description":"Simple implementation of the Mandelbrot set with oscillating zoom","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","visualization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n#define MAX_ITER 500\n\n// Treat x as the real part and y as the imaginary part\nvec2 multiplyComplex(vec2 a, vec2 b) {\n  // could also do return mat2(a,-a.y,a.x) * b;\n  return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec4 computeColor(vec2 st) {\n  vec2 z = vec2(0.0);\n  int count = 0;\n\n  for(int i = 0; i < MAX_ITER; i++) {\n    z = multiplyComplex(z, z) + st;\n\n    // Escape condition. Any complex Zn that has a \"length\" >= 2 is not in the Mandelbrot set\n    if((z.x * z.x + z.y * z.y) > 4.0) {\n      break;\n    }\n\n    count += 1;\n  }\n\n  if (count == MAX_ITER) {\n    return vec4(vec3(0.0), 1.0);\n  }\n  \n  float n = float(count)/float(MAX_ITER);\n  \n  return vec4(\n    cos(n * 10.0) / 2.0 + 0.5,\n    sin(n * 15.0) / 2.0 + 0.5,\n    cos(n * 20.0) / 2.0 + 0.5,\n    1.0\n  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5* iResolution.xy) / iResolution.y * 5.;\n\n    float zoom = (.25 + .25 * sin(iTime/5.));\n    vec2 scaleCenter = vec2(-0.494, -0.61);\n    uv = (uv - scaleCenter) * zoom + scaleCenter;\n\n    fragColor = vec4(computeColor(uv));\n}","name":"Image","description":"","type":"image"}]}