{"ver":"0.1","info":{"id":"McVyD1","date":"1731833497","viewed":29,"name":"foldScene","username":"amenone","description":"fold","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define formuparam .744\n#define tile   .6\n\n//回転の関数\nmat2 rot(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    mat2 m = mat2(c, -s, s, c);\n    return m;\n}\n\n// 距離関数\nfloat sceneSDF(vec3 p) {\n\n    return length(p) - .1;\n}\n\nvec3 calculateNormal(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 n;\n    n.x = sceneSDF(p + vec3(epsilon, 0.0, 0.0)) - sceneSDF(p - vec3(epsilon, 0.0, 0.0));\n    n.y = sceneSDF(p + vec3(0.0, epsilon, 0.0)) - sceneSDF(p - vec3(0.0, epsilon, 0.0));\n    n.z = sceneSDF(p + vec3(0.0, 0.0, epsilon)) - sceneSDF(p - vec3(0.0, 0.0, epsilon));\n    return normalize(n);\n}\n\nvec3 lighting(vec3 p) {\n    vec3 lightDir = normalize(vec3(1.0 , 1.0  , -1.0)); // 光の方向\n    vec3 n = calculateNormal(p); // 法線\n    float diff = max(dot(n, lightDir), 0.0); // 拡散反射\n    return vec3(1.0) * diff; // 明るさを計算\n}\n\nfloat random ( float id )\n{\n    return fract(sin(dot(id ,12.9898))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // カメラの設定\n    vec2 p = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    // カメラの設定\n    vec3 target = vec3(0.0, 0.0, 0.0); // カメラが注目するターゲット位置\n    target.yz *= rot( sin( iTime ));\n    vec3 cp = vec3(3.1, -3.0 , -15.0  - iTime *.01);       // カメラの位置\n    vec3 cd = normalize(target - cp);       // カメラの視線方向\n    vec3 cs = normalize(cross(cd, vec3(0.0, 1.0, 0.0))); // 右方向\n    vec3 cu = normalize(cross(cd, cs));     // 上方向\n    \n    float fov = 2.5; // 視野角\n    vec3 rd = normalize(cs * p.x + cu * p.y + cd * fov); // レイの方向\n    \n    // レイマーチングのループ\n    float t = 0.0;\n    int maxSteps = 150;\n    bool hit = false;\n    float maxDistance = 100.0;\n    float epsilon = 0.01;\n    vec3 id = vec3(0.);\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 originalPos = cp + t * rd * .5;\n        id = floor( originalPos / vec3(tile*2.) );\n        \n        originalPos.xz *= rot(iTime * .0001);\n        originalPos.xy *= rot(iTime * .0023);\n        originalPos.yz *= rot(iTime * .0003);\n        \n        \n        vec3 currentPos = abs(vec3(tile)-mod(originalPos,vec3(tile*2.))); \n\n        currentPos = abs(currentPos)/dot(currentPos,currentPos)-formuparam;\n\n        \n        float distance = sceneSDF(currentPos); \n        if (distance < epsilon ) {\n            hit = true;\n            vec3 normal = calculateNormal(currentPos);\n            col = lighting(currentPos);\n            col = vec3(1.0, 0.2, 0.3); // 赤色\n            \n            float fog = min(1.0, (1.0 / float(maxSteps)) * float(i))*1.0;\n            col += fog *  vec3(.2, 0.98, 0.8);\n \n            col += normal * .1;\n            //col *= fog *800. *vec3(.97, 0.98, 0.99);\n            break;\n        }\n        t += distance;\n        if (t > maxDistance) break;\n    }\n    \n    // ヒットしたかどうかで色を決定\n    if (hit) {\n\n        \n    } else {\n        col = vec3(1.0); // 黒色\n    }\n    \n    // フラグメントカラーを設定\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}