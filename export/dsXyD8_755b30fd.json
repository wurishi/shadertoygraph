{"ver":"0.1","info":{"id":"dsXyD8","date":"1686757904","viewed":102,"name":"Glass Logo","username":"denosya","description":"Glass effect with two refractions vectors (air_to_glass, glass_to_air). \nLiquid effect = coloring according to m.y","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["glass","liquid"],"hasliked":0,"parentid":"dlVSzt","parentname":"AGPM Proto 2"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float THICKNESS = 1.5f;\nconst float LARGE_RADIUS = 15.f;\nconst float SMALL_RADIUS = 4.f;\nconst float GLASS = 1.13;\nconst float CAMERA_DIST = 35.f;\nconst float ZFAR = 30.0;\n\nmat3 rotZ_pi_3 = mat3(vec3(0.5, 0.866, 0.f), vec3(-0.866, 0.5, 0.), vec3(0.f, 0.f, 1.f));\n\n\n#define SUB(a,b) max(a,-b)\n#define ADD(a,b) min(a,b)\n#define INTER(a,b) max(a,b)\n\nconst float H = LARGE_RADIUS * 0.902;\nconst float GROVE_LENGTH = 4.f;\nconst float GROVE_WIDTH = H*0.2f;\n\nfloat sdCylinder( vec3 p, vec2 h) { // iq\n    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox(vec3 p, vec3 b) { // iq\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 angularSymmetry(vec3 m, float slice, float phase) {\n  float angle = atan(m.y, m.x);\n  angle = mod(angle-phase, slice) + phase;\n  return vec3(length(m.xy)*vec2(cos(angle), sin(angle)), m.z);\n}\n\nfloat sdRoundedHexagon(vec3 m, float scale) {\n\n    m /= scale;\n    m = angularSymmetry(m, 3.1415/3.0, -3.1415/6.0);\n\n    vec3 discPos = vec3(LARGE_RADIUS - SMALL_RADIUS, 0.f, 0.f);\n    float disc = sdCylinder(m - discPos, vec2(SMALL_RADIUS, THICKNESS));  \n \n    // Symmetry for flat sides\n    m.y = abs(m.y); \n \n    float w = (LARGE_RADIUS - SMALL_RADIUS) * 0.5;\n    vec3  p = rotZ_pi_3 * m;\n\n    float box = sdBox(p, vec3(w,H,THICKNESS));\n    \n    return min(box, disc) * scale;\n}\n\nfloat sdGrove(vec3 m, float scale) {\n\n    m /= scale;\n    m = angularSymmetry(m, 3.1415, 3.1415*2.0/3.0);\n\n    // box\n    vec3 shift = vec3(7.8f,  H*0.2f*2.0f, 0.f);\n    vec3 p = rotZ_pi_3 * m + shift;\n\n    float w = 10.f;\n    float h = GROVE_WIDTH;\n\n    float box = sdBox(p, vec3(w,h,THICKNESS*2.f));\n\n    // disc\n    vec3 discPos = vec3(-1.8f, GROVE_WIDTH, 0.f);\n    p = rotZ_pi_3 * m + discPos;\n    float radius = GROVE_WIDTH*2.f;\n    float disc = sdCylinder(p, vec2(radius, THICKNESS*2.f));  \n    \n    float pattern = min(box, disc);\n    \n    // negative box\n    p = rotZ_pi_3 * m;\n    float eraseBox = sdBox(p, vec3(w*1.1f,h,THICKNESS*3.f));\n     \n    return SUB(pattern, eraseBox) * scale;\n}\n\n\nfloat sdInnerLogo(vec3 m) {\n\n    float hexa = sdRoundedHexagon(m, 1.);\n    float grove = sdGrove(m, 0.8);\nreturn hexa;\n    return SUB(hexa, grove);\n}\n\n\nfloat sdLogo(vec3 m) {\n\n    float hexa = sdRoundedHexagon(m, 1.);\n    float grove = sdGrove(m, 1.);\n\n    return SUB(hexa, grove);\n}\n\n\nfloat map(in vec3 m) {\n    return sdLogo(m);\n}\n\nbool rayMarching(in vec3 ro, in vec3 rd, out vec3 m) {\n    \n    float\tmarchingDist = 0.0;\n    float \tnbIter \t\t = 0.0;\n\n    for(int i = 0; i<50; i++) {\n        \n        m = ro + rd * marchingDist;    \n        \n    \tfloat dist = map(m);\n        \n        if(dist < 0.05) {\n            return true;\n        }\n        else {\n            marchingDist += dist;\n            \n            if(marchingDist >= ZFAR) {\n                break;\n            }\n        }\n    }\n    \n\treturn false;    \n}\n\n\nvec3 computeNormal(in vec3 pos) { // iq\n\tvec3 eps = vec3( 0.5, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     map(pos+eps.xyy) - map(pos-eps.xyy),\n\t     map(pos+eps.yxy) - map(pos-eps.yxy),\n\t     map(pos+eps.yyx) - map(pos-eps.yyx));\n\treturn normalize(nor);\n}\n\nfloat smoothedSquare() {\n    return 4.f * atan(sin(iTime*0.5f)/0.2f);\n}\n\n\nvec4 liquidColor(vec3 m, vec3 m2, out bool surfaceHit) {\n\n    float y = min(m.y, m2.y);\n    \n    float baseHeight = -3.f + smoothedSquare();\n    float fluctuation = cos(m.x*0.25 + iTime*5.f) * 0.2;\n    float h = baseHeight + fluctuation;\n    \n    const vec4 lowColor = vec4(0,0,1,1);\n    const vec4 highColor = vec4(1,0,0,1);\n    \n    const float lowY = -LARGE_RADIUS;\n    const float highY = LARGE_RADIUS*0.5f;\n    \n    float blend = (y-lowY)/(highY-lowY);\n    vec4 color = mix(lowColor, highColor, blend);     \n \n     //hitting surface ?\n    surfaceHit = (m.y>h && m2.y<h);\n \n    float liquid = smoothstep(h-0.1f, h, y); \n  \n    return mix(color, vec4(1), liquid);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 m;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\n    float angleY = 3.1415*0.25*iTime * 0.25;\n    float cosa = cos(angleY);\n    float sina = sin(angleY);    \n\n    mat3 rotY = mat3(vec3(cosa, 0., sina), vec3(0., 1., 0.), vec3(-sina, 0., cosa));\n\n    float angleX = 0.;//iTime * 0.;\n    cosa = cos(angleX);\n    sina = sin(angleX);    \n\n    mat3 rotX = mat3(vec3(1., 0., 0.), vec3(0., cosa, sina), vec3(0., -sina, cosa));\n\n    mat3 transfo = rotY * rotX;\n\n    float camAnim = iTime*0.;\n    vec3 camera = vec3(0, 0, -CAMERA_DIST);\n    \n    vec3 ro = camera;\n    vec3 rd\t= normalize(vec3(uv.xy, 0.85));\n    vec3 frd = rd;\n\n    ro = transfo * ro;\n    rd = transfo * rd;\n    \n    ro += rd * (CAMERA_DIST - LARGE_RADIUS*1.05);\n\n    vec3 light = vec3(1,-1,1);\n    \n    if(rayMarching(ro, rd, m)) {\n        vec3 normal = computeNormal(m);\n        vec3 refr1 = refract(rd, normal, 1.0/GLASS);\n\n        vec3 ro2 = m + refr1 * LARGE_RADIUS*1.05;\n        vec3 rd2 = -refr1;\n        vec3 outPoint;    \n        \n        rayMarching(ro2, rd2, outPoint);\n        vec3 normal2 = computeNormal(outPoint);\n        vec3 refr2 = refract(-rd2, normal2, GLASS);\n\n        bool surfaceHit;\n        vec4 glassRender;\n        \n        vec4 liquidColor = liquidColor(m, outPoint, surfaceHit);\n        \n        if(surfaceHit) {        \n           // vec3 reflection = reflect(refr1, vec3(0,1,0));\n           // glassRender = texture(iChannel2, reflection) * liquidColor;\n            glassRender = texture(iChannel0, refr2) * liquidColor * 1.5;\n        }\n        else {\n            glassRender = texture(iChannel0, refr2) * liquidColor;\n        }\n        \n        vec4 envMap = texture(iChannel0, normal); \n        \n        float fresnel = -dot(rd, normal);\n\n        fragColor = mix(envMap, glassRender, fresnel);\n    }\n    else {\n        fragColor = texture(iChannel0, frd);\n    }\n}\n    \n    \n","name":"Image","description":"","type":"image"}]}