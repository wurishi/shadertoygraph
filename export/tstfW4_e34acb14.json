{"ver":"0.1","info":{"id":"tstfW4","date":"1605145384","viewed":187,"name":"chamber SDF 3D AA","username":"bradjamesgrant","description":"sdf","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define segments 6.\n#define PI 3.14195265359\n#define tau 6.2831853\n#define r .27\n#define lr .055\n#define percentC 1./4.5\n#define AA 2.\n#define height .17\n#define gunCol .25\n#define rounding 0.002\nvec2 rotate(vec2 p, float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    return p*mat2(c,s,-s,c);\n}\n\nfloat chamberSDF(vec3 p){\n\tvec3 col;\n    float angPerSegment = (tau)/segments;    \n    float ang = atan(p.z,p.x);//+pow(fract(iTime*.3),10.);\n    float ang0PI = (ang+PI);\n    ang0PI*=(segments/(tau));\n    ang0PI = fract(ang0PI);\n    ang0PI*=((tau)/segments);\n    p.xz = vec2(cos(PI+ang0PI),sin(PI+ang0PI))*length(p.xz);\n    float ang0SegN = ang0PI/angPerSegment;\n    float angN = ang0PI/(tau);\n    float angSegSigned = (ang0SegN-.5);\n    float angSeguSigned = abs(angSegSigned);\n\n    float hs = (angPerSegment)/2.;\n    float cs = hs+sign(angSegSigned)*(percentC)*angPerSegment;\n    \n    \n    vec2 cPos = vec2(cos(-PI+hs),sin(-PI+hs))*(r+(p.y+height)*.2);\n    \n    \n    \n    if(length(cPos)-lr>=r-rounding/3.5){\n    \treturn length(p.xz)-r;\n    }\n\t\n    float dC = length(p.xz)-r;\n    float dc = -(length(p.xz-cPos)-lr);\n    \n    vec2 offset = p.xz-cPos;\n    float offA = atan(offset.y,offset.x);\n    vec2 closestToOutside = vec2(cos(offA),sin(offA))*lr+cPos;\n    \n    \n    \n    \n    \n    if(length(closestToOutside)<r && length(p.xz-cPos)<lr){\n        \n    \treturn lr-length(p.xz-cPos);\n    }\n    \n    \n    //float d = r;\n    float d = r+fract(iTime*.5)*.05;\n    //x = (d^2-r^2+R^2)/(2*d)\n    float x =( d*d - lr*lr + r*r)/(2.*d); \n    float y = sqrt(r*r-x*x);\n\n    vec2 cornPos = vec2(x,y);\n    float angcornPos = atan(cornPos.y,cornPos.x);\n    vec2 cornPos2 = vec2(x,-y);\n    \n    if(angSeguSigned>=angcornPos-.2) {\n\t\t\n        return max(dc,dC);\n        \n    }\n\n    if(dC>0.){\n       \n        \n        float angC = atan(cPos.y,cPos.x);\n    \tp.xz = rotate(p.xz,PI+percentC*PI*.5);\n        \n        \n        dC = length(p.xz-cornPos); \n    \tfloat dCC= length(p.xz-cornPos2);\n        \n        return min(dC,dCC);\n        \n    }\n    return max(dc,dC);\n\n}\n\n\n\n//off makes unlit surfaces still show bit of colour\n//higher off2 ensures shading in unlit areas\nfloat diffuse(vec3 n, vec3 l){\n    l = normalize(l);\n    float off = 0.2;\n    float off2 = .6;\n\treturn max(0.,dot(n,l)*.9+off2)+off;\n}\n\n//higher s = larger effect area\n//higher e = more defined spec\n//higher m = scaled down overall lighting\nfloat spec(vec3 n, vec3 ro, vec3 rd, vec3 l,vec3 p){\n    l = normalize(l);\n    vec3 v = rd;\n    vec3 rf = reflect(l,n);\n    float s = 0.15;\n    float e = 10.;\n    float m = 1.;\n    \n    //clamp before exp or you get light on both sides..\n    return pow(clamp(dot(v,rf)-s,0.,1.),e)/m;\n}\n\n\nfloat map(vec3 p, float time){\n    p.xz = rotate(p.xz,time*2.);\n    p.xy = rotate(p.xy,time);\n    float xz = chamberSDF(p);\n\tfloat y = max(0.,abs(p.y)-height);\n    \n    float f = max(0.,xz);\n    return y>0.?sqrt(f*f+y*y)-rounding:xz-rounding;\n        \n    \n   \n}\n\nvec3 calcNormal(vec3 p, float time){\n\tvec2 e = vec2(0.001,0.);\n    return normalize(vec3(map(p+e.xyy,time)-map(p-e.xyy,time),\n                     map(p+e.yxy,time)-map(p-e.yxy,time),\n                     map(p+e.yyx,time)-map(p-e.yyx,time)));\n}\n\nvec3 castRay(vec3 ro, vec3 rd, vec3 l, float time){\n    float t = 0.;\n    float n = 1.;\n    float acclow = 10000.;\n    for(int i = 0; i<500; i++){\n    \tvec3 p = ro + t*rd;\n        float d = map(p,time)*.651;\n        acclow = min(acclow,d);\n        t+=d;\n        if(d>10.){\n            float ratio = p.y/p.z;\n            return acclow>.003?mix(vec3(.1,.2,.3),vec3(.8,.3,.8),ratio):vec3(1.);\n        }\n            \n        \n        if(d<0.002){\n\t\t\tvec3 amb = vec3(gunCol);\n            float ll = length(p-l);\n            float att=1.0/(1.0+0.1*ll+0.01*ll*ll);\n            vec3 n =calcNormal(ro + t*rd,time); \n        \treturn att*amb*vec3(diffuse(n, l)+spec(n,ro,rd,l, p) );\n            break;\n        }\n    }\n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    for(float m = 0.;m<AA;m++){\n    \tfor(float n = 0.;n<AA;n++){\n        vec2 uv = (fragCoord+(vec2(m,n)/AA)-(iResolution.xy*.5))/iResolution.x;\n\t\tfloat time = iTime;\n\n        vec3 ro = vec3(0.,-.4,-1.2);\n\n        vec3 cf = -normalize(ro);\n        vec3 cs = cross(cf,vec3(0.,1.,0.));\n        vec3 cu = cross(cf, cs);\n\n        vec3 uuv = cf*.1+uv.x*cs + uv.y*cu;\n\n        vec3 rd = uuv-ro;\n\n\n        vec3 p = vec3(0.);\n        float t = 0.;\n        float d = 0.;\n        vec3 l = vec3(sin(time),-1.,cos(time));\n        col += castRay(ro,rd, l, time);\n        col *= 1.0-0.7*dot(uv,uv);\n\n        }\n    }\n    \n    col/=AA*AA;\n    \n\n    fragColor = vec4(col,0.);\n}","name":"Image","description":"","type":"image"}]}