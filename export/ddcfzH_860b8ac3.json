{"ver":"0.1","info":{"id":"ddcfzH","date":"1696856441","viewed":43,"name":"Twisting Tube","username":"smlk0","description":"Learning ray marching.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","twist"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 center_uv(vec2 original_uv) {\n\t\n    original_uv /= iResolution.y;\n\treturn vec2((original_uv.x * 2.0 - iResolution.x/iResolution.y), (original_uv.y * 2.0 - 1.0));\n}\n\nvec2 rotation_2d(vec2 point, float angle) {\n\t\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn point * mat2(vec2(c, -s),\n\t\t\t\t\t\tvec2(s, c));\n}\n\nfloat tube_twist_multiplier = 0.07;\nfloat tube_rotation_speed = -0.25;\nfloat origin_twist_multiplier = -0.5;\nfloat origin_rotation_speed = 0.5;\nfloat tube_ridge_frequency = 10.0;\nfloat tube_ridge_intencity = 3.0;\nfloat distance_twist = 0.3;\n\nfloat sdf_tube(vec3 point, float offset_x, float offset_y, float radius) {\n\t\n\tpoint.xy = rotation_2d(point.xy, iTime *  origin_rotation_speed);\n\tpoint.xy = rotation_2d(point.xy, point.z * origin_twist_multiplier);\n\tpoint.xy = rotation_2d(point.xy, length(point.xy) * distance_twist);\n\tpoint.xy = vec2((point.x - offset_x), (point.y - offset_y));\n\tpoint.xy = rotation_2d(point.xy, iTime * tube_rotation_speed);\n\tpoint.xy = rotation_2d(point.xy, point.z * tube_twist_multiplier);\n\tfloat displacement = tube_ridge_intencity * sin(atan((point.x), (point.y)) * tube_ridge_frequency);\n\tpoint.xy = point.xy + normalize(point.xy) * displacement;\n\t\n\treturn length(vec2(point.x, point.y)) - radius;\n}\n\nfloat tube_x = 0.0;\nfloat tube_y = 25.0;\nfloat tube_radius = 20.0;\nfloat march_step_scale = 0.1;\n\nfloat distance_to_hit(vec3 point) {\n\t\n\tfloat final_distance = sdf_tube(point, tube_x, tube_y, tube_radius);\n\treturn final_distance * march_step_scale;\n}\n\nvec3 calculate_normal(vec3 point, float current_distance) {\n\n\tconst float epsilon = 0.001;\n\t\n\tfloat gradient_x =\n\tcurrent_distance - distance_to_hit(vec3(point.x - epsilon, point.y, point.z));\n\tfloat gradient_y =\n\tcurrent_distance - distance_to_hit(vec3(point.x, point.y - epsilon, point.z));\n\tfloat gradient_z =\n\tcurrent_distance - distance_to_hit(vec3(point.x, point.y, point.z - epsilon));\n\t\n\treturn normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nconst vec3 BLACK = vec3(0.0, 0.0, 0.0);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\n\nconst vec3 directional_light = vec3(0.0, 0.0, -0.7);\n\nint max_steps = 1000;\nfloat max_distance = 100.0;\nfloat tolerance = 0.0001;\nfloat fog_end = 100.0;\nfloat fog_start = 25.0;\n\nvec3 ray_march(vec3 origin, vec3 direction) {\n\t\n\tfloat total_distance = 0.0;\n\t\n\tfor (int i = 0; i < max_steps; ++i) {\n\t\t\n\t\tvec3 current_position = origin + total_distance * direction;\n\t\tfloat current_distance = distance_to_hit(current_position);\n\t\t\n\t\tif (current_distance < tolerance) {\n\t\t\t\n\t\t\tvec3 normal = calculate_normal(current_position, current_distance);\n\t\t\t\n\t\t\tvec3 color = RED * dot(normal, directional_light);\n\t\t\t\n\t\t\tfloat fog_factor = (1.0 - (fog_end - total_distance)/(fog_end - fog_start));\n\t\t\tcolor = mix(color, BLACK, fog_factor);\n\t\t\t\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tif (total_distance > max_distance) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotal_distance += current_distance;\n\t}\n\t\n\treturn BLACK;\n}\n\nfloat uv_plane_distance = 0.4;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n\tvec3 camera_position = vec3(0.0, 0.0, -5.0);\n\tvec2 uv = center_uv(fragCoord);\n\tvec3 camera_ray_direction = vec3(uv, uv_plane_distance);\n\t\n\tfragColor = vec4(ray_march(camera_position, camera_ray_direction), 1.0);\n}","name":"Image","description":"","type":"image"}]}