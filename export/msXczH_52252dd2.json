{"ver":"0.1","info":{"id":"msXczH","date":"1686584801","viewed":92,"name":"Shapes Dance - NatLab","username":"NatShadLab","description":"Shape creation and depth blending training","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["square","rectangle","depth","shape","dance","z"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\n//Setup Height to Normal Function\nvec3 HeightToNormal( vec2 uv){\n    vec2 uvX = uv;\n    vec2 uvY = uv;\n    \n    uvX.x -= 1. / iResolution.y;\n    uvY.y -= 1. / iResolution.y;\n\n    vec3 tex0 = texture(iChannel0, uv).xyz;\n    vec3 tex1 = texture(iChannel0, uvX).xyz;\n    vec3 tex2 = texture(iChannel0, uvY).xyz;\n    \n    vec3 nor;\n    nor.x = tex1.x - tex0.x;\n    nor.y = tex2.x - tex0.x;\n    nor.z = pow(1.-((nor.x * nor.x)+(nor.y * nor.y)),.5);\n    nor.xy *= 100.;\n    nor = normalize(nor);\n    return nor;\n}\n\nvec3 softlight( vec3 x, vec3 y){\n    vec3 result = 2.*x*y + x*x*(1.-2.*y);\n    return result;\n}\n\n//Setup Directionnal Light Function\nvec3 DirLigth( float x, float y, float z){\n    vec3 dirlight = -normalize(vec3(x,y,z));\n    return dirlight;\n}\n\n//Diffuse and Specular Function\nvec3 DiffLight( vec3 light, vec3 lightcol, vec3 col, vec3 nor, float gloss){\n    vec3 diff = vec3(pow(mix(.5,1.,-dot(-light, nor)), gloss));\n    diff = mix(diff * col , clamp(diff*col * lightcol,0.,1.), clamp(length(diff-1.),0.,1.));\n    return diff;\n}\nvec3 SpecLight( vec3 light, vec3 lightcol, vec3 cam, vec3 col,vec3 nor, float gloss){\n    vec3 spec =  vec3(pow(clamp(dot(nor, normalize(mix(-cam,-light,.5))),0.,1.), gloss)) * length(light);\n    spec = mix(col*spec * lightcol, clamp(spec*col,0.,1.), clamp(spec*spec*spec,0.,1.)) * ceil(clamp(length(col),0.,1.));\n    return spec;\n}\n\n\n//HSV Functions\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float noisx;\n    float noisy;\n    noisx = noise(vec2((iTime*.618)* .1));\n    noisy = noise(vec2((-iTime*1.618)* .1));\n    // Normalized pixel coordinates (from 0 to 1)\n    float pi = 3.14159265359;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz * 2.;\n    vec3 curv = texture(iChannel1, uv).xyz;\n    \n    col = clamp(mix(col, softlight(col, curv),.5),0.,4.);\n    \n    float depth = texture(iChannel0, uv).w;\n    vec3 nor = HeightToNormal(uv);\n    vec3 cam = vec3(0.,0.,-1.);\n    \n    float gloss = mix(.618, 4.618, rgb2hsv(col).y);\n    \n    //Setup Ligth\n    vec3 light = DirLigth(mix(-2.,1.,sin(iTime*1.618))*.618,mix(-2.,1.,cos(pi*.5 + iTime*2.618))*.618,2.5);\n    vec3 lightcol = hsv2rgb(vec3(fract(iTime * .1618),mix(.5,.8,sin(iTime*1.618)),1.));\n    \n    float lightstr = mix(.618,2.618, noisx);\n    float rad = mix(1.618,3.618, noisy);\n    \n    float atten = clamp(1.-length(abs(vec3(uv,light.z)-light))/rad,0.,1.);\n    light *= atten * lightstr;\n    light *= pow(depth,2.);\n    \n    //Setup Diffuse and Specular Surface\n    vec3 difcol = DiffLight(light, lightcol, col, nor, gloss);\n    vec3 speccol = SpecLight(light, lightcol, cam, col, nor, gloss);\n    col = difcol + speccol;\n    vec3 shades = difcol + speccol;\n\n    // Output to screen\n    fragColor = vec4(vec3(col),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 softligth( vec3 x, vec3 y){\n    vec3 result = 2.*x*y + x*x*(1.-2.*y);\n    return result;\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotateUV(vec2 uv, float rotation, vec2 mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid.x) + sin(rotation) * (uv.y - mid.y) + mid.x,\n      cos(rotation) * (uv.y - mid.y) - sin(rotation) * (uv.x - mid.x) + mid.y\n    );\n}\n\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\nfloat square( vec2 coord, vec2 size, float blend){\n    float shp = 1. - smoothstep(1. - blend, 1.,max(abs(coord.x / size.x), abs(coord.y / size.y)));\n    return shp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 1. - iResolution.xy*.5) / iResolution.y;\n    vec3 col = vec3(0.,0.,0.);\n    vec2 size = vec2(1., 1.);\n    float scale = .3618;\n    float blend = .9;\n    float pi = 3.14159265359;\n    \n    vec2 coord = uv;\n    float num = 128.;\n    float spread = .25;\n    float noiseamp = 1.618;\n    float shp;\n    float dfreq = .0618;\n    float d;\n    float newd;\n    float noisx;\n    float noisy;\n    vec2 newcoord = coord;\n    vec2 newsize = size;\n    \n    float time = iTime * .2618;\n    float timing;\n    \n    vec3 newcol;  \n    vec3 curcol = vec3(1., 0., 0.);\n    \n    size *= scale;\n    \n    for (float i =0.; i < num; i++){\n        \n        timing = time +  2. * pi * i/num  + i*1.618;\n        noisx = noise(vec2((timing*.618)* .1));\n        noisy = noise(vec2((-timing*1.618)* .1));\n        \n        curcol = hsv2rgb(vec3(fract(rgb2hsv(curcol).x + i*.1618),rgb2hsv(curcol).y * mix(.99,1.,noisx * noisy),rgb2hsv(curcol).z * mix(1.,.5,noisx * noisy)));\n        \n        size = vec2(mix(.618,1.618,noisx),mix(.618,1.618,noisy)) * scale;\n        spread *= mix(.1,1.,noisx);\n        blend = mix(.618,1., cos(timing * 6.18));\n        \n        coord.x = cos(time +  2. * pi * i/num) * spread + noisx * noiseamp;\n        coord.y = sin(time +  2. * pi * i/num) * spread +- noisy * noiseamp;\n                \n        newd = ceil(fract(i*dfreq )/dfreq) * dfreq + noisx * noisy;        \n        \n        \n        newcoord = uv + coord;        \n        newsize = size * newd;\n        \n        newcoord = rotateUV(newcoord, -(time + i) * noisx * noisy *.1, vec2(0.));        \n        \n        shp = square(newcoord, newsize, blend);\n        newcol = curcol* shp;\n        shp *= newd;        \n        //col = newcol;\n        if(i > 0.){\n            shp = mix(d, shp, ceil(clamp(shp-d,0.,1.)));\n            col = mix(col, newcol, ceil(clamp(shp-d,0.,1.)));            \n        }else{\n            col = newcol;\n        }\n        d = shp;\n        \n    \n    }\n\n    // Output to screen\n    fragColor = vec4(vec3(col),d);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float HeightMap( vec2 p ){\n\treturn texture(iChannel0, p).z;\n}\nfloat Curve( vec2 p, vec2 o ){\n\tfloat a = HeightMap(p+o);\n\tfloat b = HeightMap(p-o);\n\treturn -a - b;\n}\nfloat CurvatureMap( vec2 p, float r ){\n\tconst float q = 8.0; // sample quality\n\tfloat s = r/q;\n\tfloat H = HeightMap(p)*2.0;\n\tfloat v = 0.0;\n\tvec2 o;\n\tfor( o.x = -q; o.x < q; o.x++ )\n\tfor( o.y = -q; o.y < q; o.y++ ){\n\t\tfloat c = Curve(p, o*s);\n\t\tv += (H + c) * ((r-length(o*s)) / r);\n\t}\n\treturn v/(q*q);\n}\n\nvoid mainImage( out vec4 oFragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord / iResolution.xy;\n\tfloat c;\n    float s = 2.;\n\tc += CurvatureMap(uv, s/iResolution.y)*8.0; // sharp curvature\n\tc += CurvatureMap(uv, 2.*s/iResolution.y)*4.0; // sharp curvature\n\tc += CurvatureMap(uv, 4.*s/iResolution.y)*2.; // sharp curvature\n    oFragColor.rgb = vec3(.5 + c );\n\toFragColor.a = 1.0;\n}\n","name":"Buffer B","description":"","type":"buffer"}]}