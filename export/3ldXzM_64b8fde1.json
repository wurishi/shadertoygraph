{"ver":"0.1","info":{"id":"3ldXzM","date":"1580652651","viewed":377,"name":"Owen Scrambled Sobol Sequence","username":"Chrism","description":"Left: vanilla Sobol. Right: Owen scrambled Sobol.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["noise","random","sequence","hash","rand","lowdiscrepancy","scramble","owen","sobol"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// important stuff is in Buffer A ^\n\n// drawing code adapted from https://www.shadertoy.com/view/4dtBWH\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float m = smoothstep(0.0015, 0.003, abs(0.5 - fragCoord.x / iResolution.x));\n    \n    fragColor = clamp(texelFetch(iChannel0, ivec2(fragCoord), 0), 0., 1.) * 0.9 * m;\n    fragColor.rgb += (1. - m) * vec3(0.1, 0.2, 0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// a great explanation of Owen scrambling can be found here:\n// https://psychopath.io/post/2021_01_30_building_a_better_lk_hash\n// along with a more efficient method which has been implemented in this shader:\n// https://www.shadertoy.com/view/sd2Xzm\n\n#define SAMPS_PER_FRAME 4u\n\nuvec2 Sobol(uint n) {\n    uvec2 p = uvec2(0u);\n    uvec2 d = uvec2(0x80000000u);\n\n    for(; n != 0u; n >>= 1u) {\n        if((n & 1u) != 0u)\n            p ^= d;\n        \n        d.x >>= 1u; // 1st dimension Sobol matrix, is same as base 2 Van der Corput\n        d.y ^= d.y >> 1u; // 2nd dimension Sobol matrix\n    }\n    \n    return p;\n}\n\nuint LCG1(uint n) {\n    return (n * 1664525u) + 1013904223u; // from Numerical Recipes\n}\n\nuint LCG2(uint n) {\n    return (n * 1103515245u) + 12345u; // from glibc\n}\n\nuint OwenScramble(uint p, uint s) {\n    s = LCG2(s);\n    \n    for(uint i = 1u << 31u; i > 0u; i >>= 1u) {\n        if(s > 0x80000000u)\n            p ^= i;\n        \n        if((p & i) == 0u)\n            s = LCG1(s);\n        else\n            s = LCG2(s);\n    }\n    \n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = iFrame == 0 ? vec4(0) : texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 uv = fragCoord / iResolution.x;\n    float a = max(iResolution.y, iResolution.x / 2.) / iResolution.x;\n    \n    for (uint i = 0u; i < SAMPS_PER_FRAME; i++) {\n        uint iter = uint(iFrame) * SAMPS_PER_FRAME + i;\n        vec2 offset = vec2(0);\n        uvec2 ip = Sobol(iter);\n        \n        if(uv.x > 0.5) {\n            ip.x = OwenScramble(ip.x, 42u);\n            ip.y = OwenScramble(ip.y, 666u);\n            offset.x = 0.5;\n        }\n\n        vec2 p = vec2(ip) / float(0xffffffffu);        \n        vec2 screenPos = (p * a) + offset - uv;\n        \n        fragColor.rgb += 1. - smoothstep(0.0000015, 0.000006, dot(screenPos, screenPos));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}