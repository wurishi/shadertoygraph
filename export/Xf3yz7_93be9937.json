{"ver":"0.1","info":{"id":"Xf3yz7","date":"1730378841","viewed":379,"name":"Semi-regular Tri Quad Tiling","username":"Shane","description":"Semi-regular triangle and quad tiling -- based on a \"3,4,6,4\" semi-regular tiling.","likes":49,"published":3,"flags":32,"usePreview":0,"tags":["triangle","triangle","spiral","tile","quad","log","semiregular","demiregular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Semi-regular Tri Quad Tiling\n    ----------------------------\n\n    See the \"Buffer A\" tab for an explanation.\n \n*/\n\n\n// Texture samples.\nvec3 tx2D(vec2 p){ return texture(iChannel0, p).xyz; }\n\n// Texture height.\n//float getHeight(vec2 p){ return dot(tx2D(p), vec3(.299, .587, .114)); }\n\n// Texture height.\nfloat getHeight(vec2 p){ return texture(iChannel0, p).w/4.; }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Screen coordinates.\n    vec2 iR = iResolution.xy;\n    vec2 uv = fragCoord/iR;\n    \n    \n    // Texture samples.\n    vec3 col = tx2D(uv);\n    // Height value and offset sample for the colored lights.\n    float height = getHeight(uv);\n    \n\n    // High frequency blue noise sample offset that I took from Leon's curl example.\n    //vec3 nTx = texture(iChannel1, fragCoord/1024.).xyz;\n    //vec2 e = vec2((pow(dot(nTx, vec3(.299, .587, .114)), 3.)*.5 + .5)*.004, 0);\n    vec2 e = vec2(.004, 0); // Constant sample distance.\n\n    // Taking four nearby offset samples to use for gradient and curvature calculations.\n    vec4 t4 = vec4(getHeight(uv - e.xy),  getHeight(uv + e.xy), \n               getHeight(uv - e.yx), getHeight(uv + e.yx));\n\n    // Using the samples above and some vector math to obtain the surface normal. \n    // I did it this way just to show that there were other possibilities.\n    //vec3 vx = vec3(e.x, 0, -t4.y) - vec3(-e.x, 0, -t4.x);\n    //vec3 vy = vec3(0, -e.x, -t4.z) - vec3(0, e.x, -t4.w);\n    vec3 vx = vec3(e.x*2., 0, t4.x - t4.y);\n    vec3 vy = vec3(0, -e.x*2., t4.w - t4.z);\n    vec3 sn = normalize(cross(vx, vy));\n    \n    // One line approximation to the above, if you prefer.\n    //vec3 sn = normalize(vec3(t4.x - t4.y, t4.z - t4.w, -height*e.x*2.)); \n    \n    // Using the four samples above to calculate the surface curvature.\n    float amp = 1.;\n    float curv = clamp((height*4. - dot(t4, vec4(1)))/e.x/2.*amp + .5, 0., 1.);\n         \n     \n    // Directional light. \n    //vec3 ld = normalize(vec3(-.5, 1, -1));\n    // Point light, if preferred.\n    vec3 ld = normalize(vec3(.25, 1.25, -.5) - vec3(uv, 0));\n    \n    vec3 rd = normalize(vec3(uv, 1));\n    \n    float dif = max(dot(sn, ld), 0.);\n    float spe = pow(max(dot(reflect(ld, sn), rd), 0.), 16.);\n    float fre = clamp(1. + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n\n    \n    // Using the cube map for some fake specular reflections.\n    vec3 tx2 = texture(iChannel1, reflect(rd, sn)).xyz; tx2 *= tx2;\n    vec3 rCol = col*(height*8. + 1.)*mix(tx2.zyx, tx2.yyy, .3);\n    col = mix(col, rCol*1.5, fre);\n\n     \n    // Applying the directional light, colored highlights and a bit of \n    // ambient light to the surface.\n    col *= (dif + vec3(1, .7, .4)*spe*4. + .5);//vec3(.4, .2, 1)*\n    \n    // Debug lines.\n    //col = mix(col, col*vec3(fre*fre)*4., .75);\n    //col = vec3(fre);\n\n    // Applying the curvature.\n    col *= curv*.5 + .5;\n    \n    \n    \n    // Apply shadows.\n    //col *= texture(iChannel0, uv).w;\n    \n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}\n\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\n\tSemi-regular Tri Quad Tiling\n\t----------------------------\n    \n    This is a semi-regular, or demiregular, triangle and quad tiling.\n    It's based on a \"3,4,6,4\" semi-regular tiling. I like this particular\n    scheme because of its circular nature.\n    \n    There'd be a lot of ways to produce this. I started with a triangle\n    grid, then for each cell, I rendered squares at the edge mid-points,\n    triangles at the vertices and a triangle in the center. I was able\n    to lessen the rendering number by partitioning space into angular\n    segments, which allowed me to render one side per pass only. All \n    together, I was able to get away with one square and three triangles \n    per cell.\n    \n    There are probably faster techniques out there that capitalize on\n    reflective symmetry, and so forth, but this is pretty efficient, all \n    things considered. Although, I'd probably try a hexagon grid approach\n    next time.\n    \n    Anyway, I went out of my way to keep track of central shape position\n    in order to render a simple pattern, which you can see. I also got\n    bored and applied bump mapping, basic lighting and a log spherical\n    transformation. There are some interesting \"defines\" below to try\n    out, for anyone who's interested. In fact, I feel that some of the \n    \"define\" option combinations look better than the default.\n    \n    I wrote this off the top of my head, some time ago, just for the fun of \n    it, so the code definitely isn't production quality -- To be fair, a \n    lot of production code isn't production quality either. :D I'll post a \n    3D traversal at some stage as well.\n    \n\n\t\n    Other pattern examples:\n\n    // This is an awesome example for anyone who'd like to learn about \n    // the Wythoff approach, or just general tiling beyond the regular \n    // ones. The approach here is cleaner than the one I used. :)\n    Wythoff Uniform Tilings + Duals -- fizzer\n    https://www.shadertoy.com/view/3tyXWw\n    \n    // A well known and aesthetically pleasing regular tiling.\n    Hexagons - distance -- iq \n    https://www.shadertoy.com/view/Xd2GR3\n    \n\n*/\n\n\n// DEFINES //////////\n\n// Log spherical transform. Comment this out to see the regular\n// Euclidean pattern.\n#define LOG_SPHERICAL\n\n// Show the triangle grid that the pattern is based on.\n// Displaying the boundary lines is usually a utiliarian\n// effect, but this one kind of adds to the aesthetic appeal.\n//#define SHOW_GRID\n\n// Display the polygon vertices.\n//#define SHOW_VERTICES\n\n// Display the polygon sized circles.\n//#define SHOW_CIRCLES\n\n// Basic colors.\n// Gold: 0, Green: 1, Blue: 2, Greyscale: 3.\n#define COLOR 0\n\n// Bump mapping type.\n// Minimal bevel: 0, Normal: 1, Beveled round tops: 2, Beveled pointed tops: 3.\n#define BUMP 1\n\n/////////////////////\n\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    #ifdef LOG_SPHERICAL\n    // Wrapping factor of 5 in the log spherical function.\n    f = mod(f, 5.);\n    #endif\n    \n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n/*\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){ \n\n    #ifdef LOG_SPHERICAL\n    // Wrapping factor of 5 in the log spherical function.\n    p = mod(p, 4.);\n    #endif\n    return fract(sin(mod(dot(p, vec2(27.609, 57.583)), 6.2831853))*43758.5453); \n}\n*/\n\n\n// IQ's box formula, with rounding factor\nfloat sBoxS(in vec2 p, in vec2 b, float rf){\n\n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    \n    // Aspect correct screen coordinates.\n    float res = iResolution.y;\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/res;\n    \n\n    \n    // Global scale factor.\n    const float sc = 1.;\n    // Smoothing factor.\n    float sf = sc/res;\n    \n    // Scene rotation, scaling and translation.\n    #ifdef LOG_SPHERICAL\n    mat2 sRot = mat2(1, 0, 0, 1); // Scene rotation.\n    #else\n    mat2 sRot = rot2(3.14159/18.);\n    #endif\n    vec2 camDir = sRot*normalize(vec2(1.732, 1)); // Camera movement direction.\n    vec2 ld = sRot*normalize(vec2(1, -1)); // Light direction.\n    vec2 p = sRot*uv*sc;\n    #ifndef LOG_SPHERICAL\n    p += camDir*iTime*scale/3.;\n    #endif\n    \n    \n    \n    // Log spherical transformation. There is some ID wrapping that needs to \n    // be considered, but it's pretty standard.\n    float r = 1.;\n    #ifdef LOG_SPHERICAL\n    r = length(uv);\n    p = vec2(log2(1./r)/2. + iTime/3., fract(atan(p.y, p.x)/6.2831853)*5. + iTime/6.);\n    #endif\n\n    // Keeping a copy of the coordinates.\n    vec2 oP = p;\n    \n    // Triangle vertices and vertex IDs.\n    mat3x2 vID, v;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    vec4 p4 = getTriVerts(p, vID, v);\n    // Local cell coordinates\n    p = p4.xy;\n    // Unique triangle ID (cell position based).\n    vec2 ctrID = p4.zw; \n    \n\n\n    // Equilateral triangle cell side length.\n    float sL = length(v[0] - v[1]);\n    \n    // Boundary lines, vertices and mid edge vertices.\n    float ln = -1e5, vert = 1e5, mid = 1e5;\n    \n    // Edge width.\n    float ew = .004;\n    \n    // Precalculating the edge points and edge IDs. You could do this inside\n    // the triangle grid function, but here will be fine.\n    mat3x2 e, eID;\n    for(int i = 0; i<3; i++){\n        int ip1 = (i + 1)%3;\n        eID[i] = mix(vID[i], vID[ip1], .5);\n        e[i] = mix(v[i], v[ip1], .5);\n    }\n    \n    // Shape side length ratios: Tri, Square, Tri:\n    // (sqrt(3.)/2. : 1 : sqrt(3.)/2..\n    // Square portion of the side length times the side length.\n    float sz = 1./(1. + sqrt(3.))*sL; \n    float szTri = sz; // The triange has the same dimensions.\n\n    vec2 vertID;\n    \n    #ifdef SHOW_CIRCLES\n    float vertSz = sz/3.*.8660254;\n    float vertSz2 = sz/4.*.8660254;\n    #else\n    float vertSz = .06*scale;\n    float vertSz2 = .06*scale;\n    #endif\n    \n    // Circle, circle bump, and circle vertex bump variables... I think?\n    // I coded this a while ago and didn't bother commenting as I went. :)\n    float cir = 1e5, cirB = 1e5, cirBV = 1e5;\n    \n    \n    for(int i = 0; i<3; i++){\n    \n        int ip1 = (i + 1)%3;\n    \n        // Triangle vertex points, IDs, and bump samples.\n        float vI = length(p - v[i]) - vertSz;\n        if(vI<vert){\n            vert = vI;            \n            vertID = ctrID + vID[i];\n            \n            cirBV = min(cirBV, length(p - v[i])); \n        }\n        \n        // Boundary lines.\n        float lnI = distLineS(p, v[i], v[ip1]);\n        ln = max(ln, -lnI);\n        \n        // Mid edge vertices.\n        float sz2 = hash21(ctrID + eID[i]);\n        float eI = length(p - e[i]) - .05*scale;//*(sz2*.5 + .5);\n        mid = min(mid, eI);\n        \n    }\n    \n    \n    \n    \n    // Overall polygon ID.\n    vec2 polyID = ctrID;\n    \n    // The overall distance field.\n    float d = 1e5;\n    \n     // Smoothing factor.\n    float smF = .08*scale;\n    \n    \n    // Using the center to vertex lines to split the triangle into three \n    // extra triangle sections. That way, we can render a third of the\n    // polygons necessary.\n    /*\n    vec3 ln3;\n    for(int i = 0; i<3; i++){\n       ln3[i] = distLineS(p, vec2(0), v[(i + 1)%3]);\n    }\n   \n    ln3 = max(ln3, -ln3.zxy);\n    int i = ln3.x<0.? 0 : ln3.y<0.? 1 : 2;\n    */\n    \n    // Instead of looping through all three sides, determine which \n    // side index we need based on the angle partition.\n    vec2 a2 = gTri<0.? -p : p; // Extra alternate upside down (annoyance) factor. :)\n    float ang = floor(fract(atan(a2.x, a2.y)/6.2831853)*3.);\n    int i = ang==0.? 0 : ang==2.? 1 : 2; \n\n    \n    // I've kept this indented to show that it was once a loop iterating \n    // through three edges.\n    ///////\n        int ip1 = (i + 1)%3;\n        \n        // Mid edge quad.\n        vec2 q = p - e[i];\n        vec2 nrm = normalize(e[i]); // Edge normal.\n        float a = atan(nrm.y, nrm.x); // Rotaion angle for polygons.\n        q = rot2(a)*q;\n        float quad = sBoxS(q, vec2(sz/2.), smF);\n        \n        if(quad<d){\n           d = quad;\n           polyID = ctrID + eID[i];\n           \n           cirB = min(cir, length(q)); // No size for center based bumping. \n           cir = min(cir, length(q) - sz/2.);\n        }\n        \n        // Triangle center edge ratio.\n        float edf = sqrt(1./3.)/(1. + sqrt(3.));\n        #ifdef LOG_SPHERICAL\n        float edf2 = floor(edf*1024.)/1024.;\n        #else\n        float edf2 = edf;\n        #endif\n       \n        // Vertex triangle.\n        q = p - mix(v[i], v[ip1], edf);\n        q = rot2(-a)*q;\n        float tri = sdEqTri(q, szTri/2. - smF) - smF/2.;\n        if(tri<d){\n           d = tri;\n           // The flooring is due to accuracy problems with the spiral transform.\n           polyID = ctrID + mix(vID[i], vID[ip1], edf2);\n           \n           cirB = min(cir, length(q)); \n           cir = min(cir, length(q) - szTri/3.*.8660254);\n        } \n        \n        // Other edge vertex triangle.\n        q = p - mix(v[ip1], v[i], edf); // Other way.\n        q = rot2(a)*q;\n        tri = sdEqTri(q, szTri/2. - smF) - smF/2.;\n        if(tri<d){\n           d = tri;\n           polyID = ctrID + mix(vID[ip1], vID[i], edf2);\n           \n           cirB = min(cirB, length(q)); \n           cir = min(cir, length(q) - szTri/3.*.8660254);\n        } \n        \n        // Mid-center vertex points.\n        float mVL = 1./(1. + sqrt(3.));\n        float vI = length(p - v[i]*mVL) - vertSz2;\n        if(vI<vert){\n            vert = vI;\n            vertID = ctrID + vID[i]*mVL;\n            \n            cirBV = min(cirBV, length(p - v[i]*mVL)); \n        }\n        vI = length(p - v[ip1]*mVL) - vertSz2;\n        if(vI<vert){\n            vert = vI;\n            vertID = ctrID + vID[ip1]*mVL;\n            cirBV = min(cirBV, length(p - v[ip1]*mVL)); \n        }\n        \n    ///////////\n    \n    // The middle triangle distance and ID. There are also\n    // bump related samples taken.\n    q = gTri<0.? p*vec2(1, -1) : p;\n    tri = sdEqTri(q, szTri/2. - smF) - smF/2.;\n    if(tri<d){\n       d = tri;\n       polyID = ctrID;\n       \n       cirB = min(cir, length(q)); \n       cir = min(cir, length(q) - szTri/3.*.8660254);\n    } \n    \n   \n    // Coloring and texturing the background polygons. Most of it is based\n    // on positional ID. There is also some unskewing involved, which can\n    // be one of the annoying things about working with triangles, and skewed\n    // grids in general. I wrote this a while ago, so even I'm taking my own\n    // word for it. :D\n \n    // Texturing and pattern variables.   \n    vec2 tuv2 = unskewXY(polyID, vec2(.5, 0));\n    vec2 svTUV = tuv2;\n    \n    float mdTUV = mod(floor(tuv2.y/6. + .5*0.), 2.);    \n    if(mdTUV==0.) tuv2.x += 3.;\n    \n    tuv2 = mod(tuv2*vec2(1, 1) + 3. + vec2(iTime*0., 0), 6.) - 3.;\n    //tuv2 = mod(tuv2 + 0., 12.) - 6.;\n    //vec2 pID = mod(polyID*sc, 12.);\n    float rnd = hash21(polyID);\n    //float rnd2 = sin(6.2831853*mod(tuv2.y, 12.)/12. + iTime)*.5 + .5;\n    float rnd2 = sin(6.2831853*length(tuv2)/6.)*.5 + .5;\n    \n    // Coloring.\n    #if 1\n    vec3 sCol = .5 + .45*cos(6.2831853*rnd/6. + vec3(0, 1, 2)*1.25);\n    if(rnd2<.9) sCol = (.5 + .45*cos(6.2831853*rnd/12. + vec3(1.02, 1, .98)*3.14159));\n        \n    \n    #else\n    vec3 sCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(1, 2, 3)*3.14159/2.);\n    if(rnd2<.9) sCol = .5 + .45*cos(6.2831853*rnd/12. + vec3(1)*3.14159);\n    #endif\n    \n    // Cheap toning.\n    sCol /= (.65 + sCol)/(1. + .65);\n    //sCol /= (2. + sCol)/(2. + 1.5);\n     \n    ///////////////\n    // Oh, my! What is this mess? I decided to put in a shape-vertex and \n    // circle option, or something, which had to take the background pattern \n    // into account, so I'm guessing this is some last minute coloring.\n    tuv2 = unskewXY(vertID, vec2(.5, 0));\n    //\n    if(mod(floor(tuv2.y/6. + .5*0.), 2.)==0.) tuv2.x += 3.;\n    tuv2 = mod(tuv2*vec2(1, 1) + 3. + vec2(iTime*0., 0), 6.) - 3.;\n    rnd = hash21(vertID);\n    rnd2 = sin(6.2831853*length(tuv2)/6.)*.5 + .5;\n    //\n    #if 1\n    vec3 vCol = .5 + .45*cos(6.2831853*rnd/6. + vec3(0, 1, 2)*1.25);\n    if(rnd2<.75) vCol = (.5 + .45*cos(6.2831853*rnd/12. + vec3(1.02, 1, .98)*3.14159));\n    #else\n    vec3 vCol = .5 + .45*cos(6.2831853*rnd/1. + vec3(1, 2, 3)*3.14159/2.);\n    if(rnd2<.75) vCol = .5 + .45*cos(6.2831853*rnd/12. + vec3(1)*3.14159);\n    #endif    \n    //////////////\n    \n    #if COLOR == 1\n    sCol = sCol.yxz;\n    vCol = vCol.yxz;\n    #elif COLOR == 2\n    sCol = sCol.zyx;\n    vCol = vCol.zyx;\n    #endif\n    \n    // Stretched background texturing. I think it's stretched because I \n    // wanted to test the background positioning against the video textures.\n    //vec2 tuv = unskewXY(polyID, vec2(.5, 0));\n    //tuv *= vec2(iResolution.y/iResolution.x, 1);\n    //vec3 tx = texture(iChannel0, tuv*scale/4. + .5).xyz; tx *= tx;\n    \n    vec3 tx = texture(iChannel0, oP).xyz; tx *= tx;\n    //tx = smoothstep(0., .5, tx);\n    sCol *= tx*3. + .2;\n    \n    \n    // Distance field radial variable associated with the log transform.\n    // When no transform is applied, \"r\" has value \"1\".\n    cirB *= r;\n    cirBV *= r;\n    \n    // Initializing with the background color.\n    vec3 col = vec3(.03);\n    \n    \n\n    #ifdef SHOW_GRID\n    // Displaying the triangle cell boundary lines.\n    #ifdef SHOW_CIRCLES\n    cir = max(cir, ln);   \n    #else\n    d = max(d, ln);\n    #endif\n    #endif \n    \n    // Rendering the packed shapes, cirlces, vertices, etc, accoring\n    // to the defines chosen.\n    \n    #ifndef SHOW_CIRCLES\n    d *= r;\n    col = mix(col, sCol*.05, (1. - smoothstep(0., sf, d)));\n    col = mix(col, sCol, (1. - smoothstep(0., sf, d + ew)));\n    #else\n    d = 1e5;\n    #endif\n    \n    #ifdef SHOW_CIRCLES\n    cir *= r;\n    d = min(d, cir); \n    //cir = abs(cir + .01) - .01; // Annulus.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, cir)));\n    col = mix(col, sCol, (1. - smoothstep(0., sf, cir + ew)));\n    #endif\n   \n   \n    \n    // Annulus option.\n    //vert = abs(vert + .01) - .01;\n    #ifdef SHOW_VERTICES\n    vert *= r;\n    if(vert<d){\n       cirB = cirBV;\n       d = vert;\n    }\n    \n    // Rendering the vertices.\n    // Vertex stroke and centers.\n    vec3 svCol = col;\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, vert)));\n    col = mix(col, mix(vCol, vec3(1), .25), (1. - smoothstep(0., sf, vert + ew)));\n    #endif\n    \n    // Screen gradien coloring... Not for this example. :)\n    //col = mix(col, col.zyx, smoothstep(.3, .7, -uv.y + .5));\n    \n    #if COLOR == 3\n    col = vec3(1)*dot(col, vec3(.299, .587, .114));\n    #endif\n\n/*\n    // Rendering the mid edge points.\n    // Vertex stroke and centers.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, mid)));\n    col = mix(col, vec3(.8, 1, .3), (1. - smoothstep(0., sf, mid + .04*scale)));\n*/\n    \n    // Vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n\n    #if BUMP == 0\n    d = clamp(-d/(scale), 0., .03)/8.; // Very subtle edge bump.\n    col *= 1.25; // Lightening the color a little.\n    #elif BUMP == 1\n    // Storing the color and distance information in the buffer.\n    d = max(-d/(scale), .0);\n    #elif BUMP == 2\n    // Beveled with rounded top option.\n    d = clamp(-d/(scale), 0., .05) - max(cirB*cirB/(scale)/(scale), 0.);\n    #else\n    // Beveled with pointed top option.\n    d = clamp(-d/(scale), 0., .05) + clamp(-d/(scale), .0, 1.)/2.;\n    #endif\n    \n    // Storing the color information in the first three channels, and the\n    // bump information in the fourth channel.\n    fragColor = vec4((max(col, 0.)), d);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nconst float scale = 1./4.;\n \nfloat gTri;\n\nvec4 getTriVerts(in vec2 p, inout mat3x2 vID, inout mat3x2 v){\n\n    // Rectangle scale.\n    const vec2 rect = (vec2(1./.8660254, 1))*scale;\n\n    // Skewing half way along X, and not skewing in the Y direction.\n    const vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n    \n    // Vertex IDs for each partitioned triangle: The numbers are inflated\n    // by a factor of 3 to ensure vertex IDs are precisely the same. The\n    // reason behind it is that \"1. - 1./3.\" is not always the same as\n    // \"2./3\" on a GPU, which can mess up hash logic. However, \"3. - 2.\"\n    // is always the same as \"1.\". Yeah, incorporating hacks is annoying, \n    // but GPUs don't work as nicely as our brains do, unfortunately. :)\n    if(gTri<0.){\n        vID = mat3x2(vec2(-1.5, 1.5), vec2(1.5, -1.5), vec2(1.5));\n    }\n    else {\n        vID = mat3x2(vec2(1.5, -1.5), vec2(-1.5, 1.5), vec2(-1.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect/3., sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3;\n    p -= ctr;\n    v[0] -= ctr; v[1] -= ctr; v[2] -= ctr;\n    \n     // Centered ID, taking the inflation factor of three into account.\n    vec2 ctrID = vID[2]/3.; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.; //\n    id = id*3. + ctrID;   \n    // Since these are out by a factor of three, \"v = vertID*rect/3.\".\n    vID[0] -= ctrID; vID[1] -= ctrID; vID[2] -= ctrID;\n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n   \n    p.y = p.y + r/k; \n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n   \n    /*   \n    const float k = sqrt(3.0);\n    p.y = abs(p.y) - r; // This one has been reversed.\n    p.x = p.x + r/k;\n    if( p.y + k*p.x>0.) p = vec2(-k*p.y - p.x, p.y - k*p.x)/2.0;\n    p.y -= clamp( p.y, -2.0, 0.0 );\n    return -length(p)*sign(p.x);\n    */  \n}\n\n\n/////////\n/*  \n// Triangle's incenter: The center of the inscribed circle, which in essence is\n// the largest circle that you can fit into a triangle.\nvec2 inCircle(in vec2 v0, in vec2 v1, in vec2 v2){\n    \n    // Side lengths.\n    vec3 len = vec3(length(v2 - v1), length(v0 - v2), length(v1 - v0));\n    //return (bc*p0 + ac*p1 + ab*p2)/dot(len, vec3(1));\n    return mat3x2(v0, v1, v2)*len/dot(len, vec3(1));\n}\n\n// Unsigned distance to the segment joining \"a\" and \"b\".\nfloat distLine(vec2 p, vec2 a, vec2 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n*/\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}","name":"Common","description":"","type":"common"}]}