{"ver":"0.1","info":{"id":"4cSBDK","date":"1725489256","viewed":44,"name":"Normal Color Circle","username":"chronos","description":"Just messin' around with some color :)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["simple","color","circle","normal","colour"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Normal Color Circle by chronos\n    --------------------------------------------------\n    \n    Just messin' around with some color :)\n    \n    --------------------------------------------------\n    self link: https://www.shadertoy.com/view/4cSBDK\n*/\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2. * fragCoord-iResolution.xy) / iResolution.y; // centered and aspect corrected UV coordinates\n    float ps = 2. / iResolution.y;                             // pixel size in UV coordinates\n    mat3 M = mat3(normalize(vec3(1,-1,0)), normalize(vec3(1,1,-2)), normalize(vec3(1,1,1))); // Rotation matrix\n    vec3 N = normalize(vec3(uv, sqrt(max(1.-dot(uv,uv), 0.))));                                 // Normal vector\n    \n    #if 1\n    // Animate a bit\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy) / iResolution.y; // centered and aspect corrected UV coordinates\n    vec2 t = vec2(iTime) * vec2(1,.3);\n    if(length(iMouse.xy) > 10.) { t = mouse/max(1., length(mouse)) * 3.14159265/2.; }\n    float c1 = cos(t.x), s1 = sin(t.x);\n    float c2 = cos(t.y), s2 = sin(t.y);\n    mat2 R1 = mat2(c1, s1, -s1, c1);\n    mat2 R2 = mat2(c2, s2, -s2, c2);\n    N.xz = R1 * N.xz;\n    N.yz = R2 * N.yz;\n    #endif\n    \n    vec3 color = (M * N*.5+.5);                        // Rotate, scale, translate. To center sphere inside RGB cube\n    color = pow(color, vec3(3));                    // <--- wat. (._.)'    ( Just tried this based on CIE L*a*b*. Looks nice! :D )\n    color *= .05+.95*smoothstep(1.+ps, 1.-ps, length(uv));  // Antialiased mask\n    \n    // I saw some not very smooth gradient rings, meaning the pow3 probably pushed some vectors with length > 1 out f the RGB cube.\n    // So applying a tanh to calm them down and mellow them out :)\n    color = tanh(color); \n    color = sRGBencode(clamp(color, 0., 1.)); // sRGB encode. As is tradition.\n    color += 2.*(texelFetch(iChannel0, ivec2(fragCoord)%1024, 0).rgb-.5)/255.; // A little dithering, for your eyes only ;)\n    color = clamp(color, 0., 1.); // Can never clamp to much! \n    fragColor = vec4(color, 1);  // and output :)\n}","name":"Image","description":"","type":"image"}]}