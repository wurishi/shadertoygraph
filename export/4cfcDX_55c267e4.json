{"ver":"0.1","info":{"id":"4cfcDX","date":"1722431864","viewed":90,"name":"Procedural Nebula","username":"Mick","description":"nebula","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["star","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define period 15.\n#define fxrand seed+31.\n#define hash1 rnd(fxrand)\n#define hash2 rnd(fxrand+.111)\n#define hash3 rnd(fxrand+.222)\n#define hash4 rnd(fxrand+.333)\n#define hash5 rnd(fxrand+.444)\n#define hash6 rnd(fxrand+.555)\n#define hash7 rnd(fxrand+.666)\n#define hash8 rnd(fxrand+.777)\n#define hash9 rnd(fxrand+.877)\n#define hash10 rnd(fxrand+.997)\n#define hash11 rnd(fxrand+1.11777)\n#define hash12 rnd(fxrand+1.511777)\n#define hash13 rnd(fxrand+1.811777)\n#define hash14 rnd(fxrand+1.911777)\n#define hash15 rnd(fxrand+2.111777)\n#define hash16 rnd(fxrand+2.211777)\nconst float cloudscale = 1.1;\nconst float speed = 0.03;\nconst float clouddark = 0.5;\nconst float cloudlight = 0.3;\nconst float cloudcover = 0.2;\nconst float cloudalpha = 8.0;\nconst float skytint = 0.5;\nconst vec3 skycolour1 = vec3(0.2, 0.4, 0.6);\nconst vec3 skycolour2 = vec3(0.4, 0.7, 1.0);\n\n\nconst mat2 m = mat2( 1.6, .2, -1.2,  1.6 );\nfloat t = 0.;\n\nconst mat2 mcloud = mat2( 1.6,  1.2, -1.2,  1.6 );\n// #define GALAXY\n\nstruct PointLight {\n    vec2 pos;\n    vec3 col;\n    float intensity;\n};\n\n\nfloat hashh(vec2 p) {\n\treturn fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nfloat hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\nfloat noise(vec2 x) {\n\tvec2 i = floor(x);\n\tvec2 f = fract(x);\n\tfloat a = hash21(i);\n\tfloat b = hash21(i + vec2(1.0, 0.0));\n\tfloat c = hash21(i + vec2(0.0, 1.0));\n\tfloat d = hash21(i + vec2(1.0, 1.0));\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n\nvec2 hash22( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise21(  vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab, vec2 rot )\n{\n\n    \n  //  p = mat2(rot.x,-rot.y,rot.y,rot.x)*p;\n    \n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\nfloat fbm21(vec2 n, float amplitude, int octaves, float gain, vec2 shift) {\n\tfloat total = 0.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\ttotal += noise21(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= gain;\n        n *= shift;\n\t}\n\treturn total;\n}\n\nfloat fbm21Test(vec2 uv){\n\n //   uv += 0.5;\n\n    float time = t * speed;\n    float q = fbm21(uv * cloudscale * 0.5, 0.1, 7, 0.4, vec2(1.));\n    \n    t = 3.;\n    float r = 0.0;\n    vec2 uuv = uv;\n\tuuv *= cloudscale;\n    uuv -= q - t;\n    float weight = 0.8; \n    //ridged noise shape\n    for (int i=0; i<8; i++){\n\t\tr += abs(weight*noise( uuv ));\n        uuv = mcloud*uuv + t;\n\t\tweight *= 0.7;\n    }\n    \n    \n    //noise shape\n\tfloat f = 0.0;\n\tuuv = uv;\n\tuuv *= cloudscale;\n    uuv -= q - t;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tf += weight*noise21( uuv );\n        uuv = mcloud*uuv + t;\n\t\tweight *= 0.6;\n    }\n    \n    f *= r + f;\n   \n    \n    return f;\n    \n}\n\nfloat palette(  float a,  float b,  float c,  float d,  float x ) {\n    return a + b * cos(6.28318 * (c * x + d));\n}\n    \n// 2D Noise from IQ\nfloat Noise2D( vec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat ComputeFBM(  vec2 pos )\n{\n    float amplitude = 0.75;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < 6; ++i)\n    {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 0.5;\n        pos *= 2.2;\n    }\n    return sum / maxAmp;\n}\n\n// Same function but with a different, constant amount of octaves\nfloat ComputeFBMStars( vec2 pos )\n{\n    float amplitude = 0.75;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < 5; ++i)\n    {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 0.5;\n        pos *= 2.0;\n    }\n    return sum / maxAmp * 1.15;\n}\n\n\n\nvec3 BackgroundColor( vec2 uv ) {\n    \n    // Sample various noises and multiply them\n    float noise1 = ComputeFBMStars(uv * 5.0);\n  //  noise1 = 0.;\n    float noise2 = ComputeFBMStars(uv * vec2(15.125, 25.7));\n  //  noise2 = 0.;\n    float noise3 = ComputeFBMStars((uv + vec2(0.5, 0.1)) * 4.0 + iTime * 0.35);\n    \n    float starShape = noise1 * noise2 * noise3;\n    \n    // Compute star falloff - not really doing what i hoped it would, i wanted smooth falloff around each star\n    float falloffRadius = 0.2;\n    float baseThreshold = 0.6; // higher = less stars\n    \n    starShape = clamp(starShape - baseThreshold + falloffRadius, 0.0, 1.0);\n    \n    float weight = starShape / (2.0 * falloffRadius);\n    return weight * vec3(noise1 * 0.55, noise2 * 0.4, noise3 * 1.0) * 6.0; // artificial scale just makes the stars brighter\n}\n\nvec4 galaxy(vec2 uv) {\n\n    vec2 scrPt = uv * 2.0 - 1.0;\n    \n    vec4 finalColor;\n    \n    #ifdef GALAXY\n    \n    vec2 samplePt = scrPt;\n    \n    // Warp noise domain\n    float swirlStrength = 2.5;\n    float dist = length(samplePt);\n    float theta = dist * swirlStrength - iTime * 0.225;\n    mat2 rot;\n    \n    // cache calls to sin/cos\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    samplePt *= rot;\n    samplePt *= 3.0;\n    \n    float noiseVal = ComputeFBM(samplePt + sin(iTime * 0.03125));\n    float maxIntensity = 1.65; // kinda is the galaxy radius/size?\n    noiseVal *= clamp(pow(maxIntensity - dist, 5.0) * (1.0 / maxIntensity), 0.0, 1.0);\n    \n    // Lighting\n    PointLight l1;\n    l1.pos = vec2(0);\n    l1.col = mix(vec3(0.75, 0.5, 0.3), vec3(0.55, 0.4, 0.95), clamp(dist * 0.5, 0.0, 1.0) + (sin(iTime * 0.5) * 0.5 + 0.5) * 0.5);\n    l1.intensity = 4.0;\n    \n    vec3 l1Col = l1.col * l1.intensity * 1.0 / pow(length(l1.pos - samplePt), 0.5);\n    //vec4 finalColor = vec4(BackgroundColor(fragCoord.xy * 0.25), 1.0);\n    //vec4 finalColor = vec4(l1Col * noiseVal, 1.0);\n    finalColor = vec4(mix(BackgroundColor(fragCoord.xy * 0.125), l1Col * noiseVal, pow(noiseVal, 1.0)), 1.0);\n    \n    #else // Milky Way    \n    \n\t// Define density for some shape representing the milky way galaxy\n    \n    float milkywayShape;\n    \n    // Distort input screen pos slightly so the galaxy isnt perfectly axis aligned\n    float galaxyOffset = (cos(scrPt.x * 5.0) * sin(scrPt.x * 2.0) * 0.5 + 0.5) * 0.0;\n    \n    // Apply a slight rotation to the screen point, similar to the galaxy\n    float theta = length(scrPt) * 0.25; // Visualy tweaked until it looked natural\n    mat2 rot;\n    \n    // cache calls to sin/cos(theta)\n    float cosTheta = cos(theta);\n    float sinTheta = sin(theta);\n    \n    rot[0][0] = cosTheta;\n    rot[0][1] = -sinTheta;\n    rot[1][0] = sinTheta;\n    rot[1][1] = cosTheta;\n    \n    vec2 rotatedScrPt = scrPt * rot;\n    \n    float noiseVal = ComputeFBM(rotatedScrPt * 5.0 + 50.0 + iTime * 0.015625 * 1.5);\n    \n    rotatedScrPt += vec2(noiseVal) * 0.3;\n    \n    float centralFalloff = clamp(1.0 - length(scrPt.y + galaxyOffset), 0.0, 1.0);\n    float xDirFalloff = (cos(scrPt.x * 2.0) * 0.5 + 0.5);\n    \n    float centralFalloff_rot = 1.0 - length(rotatedScrPt.y + galaxyOffset);\n    float xDirFalloff_rot = (cos(rotatedScrPt.x * 2.0) * 0.5 + 0.5);\n    \n    // Falloff in y dir and x-dir fade\n  //  float lowFreqNoiseForFalloff = ComputeFBM(rotatedScrPt * 4.0 - iTime * 0.015625 * 1.5); // 1/64\n    float lowFreqNoiseForFalloff = fbm21(rotatedScrPt * 4.0 - iTime * 0.015625 * 1.5, 0.75, 6, 0.5, vec2(2.2)); // 1/64\n    \n   // lowFreqNoiseForFalloff = fbm21Test(rotatedScrPt * 0.5);\n   //return vec4(vec3(lowFreqNoiseForFalloff), 1.0);\n   //float lowFreqNoiseForFalloff_offset = ComputeFBM(rotatedScrPt * 1.5 + 0.005 * lowFreqNoiseForFalloff);\n    milkywayShape = clamp(pow(centralFalloff_rot, 3.0) - lowFreqNoiseForFalloff * 0.5, 0.0, 1.0) * xDirFalloff_rot;\n    \n    \n   // return vec4(vec3(lowFreqNoiseForFalloff), 1.);\n    // Lighting\n    vec3 color;\n    \n    // desired brown color\n    //vec3 brown = vec3(0.35, 0.175, 0.15) * 17.0;\n    //vec3 mainColor = vec3(0.925, 1.0, 0.8) * 10.0;\n    //color = mix(brown, mainColor, pow(milkywayShape, 1.0)) * 2.0 * milkywayShape;\n    \n    // Cosine-based pallette: http://dev.thi.ng/gradients/\n    // there is also a famous IQ article on this and a less famous shader on my profile\n    color.r = palette(0.5, -1.081592653589793, 0.798407346410207, 0.0, pow(milkywayShape, 1.0));\n    color.g = palette(0.5, 0.658407346410207, 0.908407346410207, 0.268407346410207, pow(milkywayShape, 1.0));\n    color.b = palette(0.5, -0.201592653589793, 0.318407346410207, -0.001592653589793, pow(milkywayShape, 1.0));\n    \n    /* dont do this\n    color.r += 0.5 * palette(0.5, -0.481592653589793, 0.798407346410207, 0.0, pow(noiseVal, 1.0));\n    color.g += 0.5 * palette(0.5, 0.428407346410207, 0.908407346410207, 0.268407346410207, pow(noiseVal, 0.5));\n    color.b += 0.5 * palette(0.5, -0.001592653589793, 0.318407346410207, -0.001592653589793, pow(noiseVal, 1.0));\n    */\n    \n    // Experimented with removing color, worked out decently\n    float removeColor = (pow(milkywayShape, 10.0) + lowFreqNoiseForFalloff * 0.1) * 5.0;\n    color -= vec3(removeColor);\n    \n    // Add some blue to the background\n    vec3 backgroundCol = BackgroundColor(uv * 300. * 0.125) * pow(centralFalloff, 0.5) * pow(xDirFalloff, 0.5);\n    vec3 blueish = vec3(0.2, 0.2, 0.4);\n    backgroundCol += blueish * (5.0 - milkywayShape) * pow(centralFalloff_rot, 2.0) * lowFreqNoiseForFalloff * pow(xDirFalloff, 0.75);\n    \n    vec3 whiteish = vec3(0.5, 1.0, 0.85);\n    backgroundCol += whiteish * 0.95 * pow(centralFalloff, 1.5) * lowFreqNoiseForFalloff * pow(xDirFalloff, 2.0);\n    \n    \n    finalColor = vec4(mix(backgroundCol, color, milkywayShape), 1);\n    \n    #endif\n    \n    return finalColor;\n    \n  }\n\n\nfloat seed;\nvec2 uvd;\nfloat zoom;\n\n// Converts an RGB color to HSV.\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Converts an HSV color to RGB.\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// Interpolates between two colors in the HSV color space.\nvec3 mixHue(vec3 color1, vec3 color2, float t) {\n    vec3 hsv1 = rgb2hsv(color1);\n    vec3 hsv2 = rgb2hsv(color2);\n\n    // Interpolate hue, saturation, and value separately.\n    float h = mix(hsv1.x, hsv2.x, t);\n    float s = mix(hsv1.y, hsv2.y, t);\n    float v = mix(hsv1.z, hsv2.z, t);\n\n    // Convert back to RGB.\n    return hsv2rgb(vec3(h, s, v));\n}\n\nfloat fbm (in vec2 p, int octaves, float amp, float gain, float freqGain) {\n\n    float value = 0.0;\n    float freq = 1.0;\n    for (int i = 0; i < octaves; i++) {\n        value += amp * (noise((p - vec2(1.0)) * freq));\n        freq *= freqGain;\n        amp *= gain;\n    }\n    return value;\n}\n\n\nmat2 rot(float a)\n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat rnd(float p)\n{\n    p*=1234.5678;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\n\nfloat rand(float r){\n\tvec2\tco=vec2(cos(r*428.7895),sin(r*722.564));\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nint nebulaKind(float time) {\n     float seed = hash4;\n     int centeredNebula = 0;\n     int discreteNebula = 1;\n     int galaxy = 2;\n\n     return 0;\n \n //return 2;\n int nothing = 3;\n \n \n //float total =  centeredNebula +  discreteNebula + galaxy + nothing;\n \n     if (seed <= 0.3) {\n         return centeredNebula;\n     } else if (seed < 0.6) {\n         return discreteNebula;\n     } else {\n         return 4;\n     }\n\n}\n\nvec3 getNebulaColor(float seed) {\n\n    int count = 8;\n\n    //return vec3(157, 84,   46     ) / 255.;\n\n    int id = int(int(seed * float(count)) % count);\n\n    if (id == 0) {\n    // return vec3(218, 32, 32  ) / 255.;\n  //  return vec3(1.);\n        //  return vec3(1.0);\n       return vec3(205., 0., 0.   ) / 255.;\n     //   return vec3(157, 84,   46     ) / 255.;\n    } else if (id == 1) {\n        // yellowish\n        //  return vec3(0.0, 0.0, 32  ) / 255.;\n       return 0.7 * vec3(218, 32, 32  ) / 255.;\n\n    } else if (id == 2) {\n\n      return vec3(85, 27, 16) / 255.;\n\n    } else if (id == 3) {\n       // blueish\n       return vec3(32, 71, 170) / 255.;\n\n    } else if (id == 4) {\n    \n        return 0.8 * vec3( 101, 54, 157) / 255.;\n    }\n     else if (id == 5) {\n     \n         // redish\n         \n   //  v = vec3( 182, 38, 25) / 255.;\n\n        return 0.8 * vec3( 243, 4, 70) / 255.;\n\n   }   else if (id == 6) {\n     \n         // pinky\n\n        return 0.8 * vec3(206, 106,105) / 255.;\n\n    }\n    \n      else if (id == 7) {\n     \n         // cyan\n\n        return 0.8 * vec3(2, 149, 171) / 255.;\n\n    }\n}\n\nvec3[3] getNebulaColorIds(float seed) {\n    vec3 colors[3] = vec3[3](vec3(0.0), vec3(0.0), vec3(0.0));\n\n    int t = 0;\n    while (t < 3) {\n        vec3 tmp = getNebulaColor(seed);\n        bool duplicate = false;\n        for (int i = 0; i < t; i++) { // 注意这里修改为 i < t\n            if (length(colors[i] - tmp) <= 0.6) {\n                duplicate = true;\n                break;\n            }\n        }\n        if (!duplicate) {\n           colors[t++] = tmp;\n        }\n        seed = seed * 1. + .232;\n    }\n    \n    return colors;\n}\n\nvec3 render(vec3 dir, float time, vec2 uvd) {\n    float s = 0.3, fade = 1., sd = 0.2;\n    vec3 v = vec3(0.);\n\n //   if (abs(uvd.x - (-0.9)) <= 0.03) {\n  //        return vec3(0.);\n  //    }\n\n\n  //    if (abs(uvd.x - (0.9)) <= 0.03) {\n //         return vec3(0.);\n  //    }\n\n  //    if (abs(uvd.y - (0.5)) <= 0.03) {\n //         return vec3(0.);\n //     }\n\n  //    if (abs(uvd.y - (-0.5)) <= 0.03) {\n  //        return vec3(0.);\n  //    }\n\n\n\n    dir.y += 4. * hash4;\n    dir.x += hash5;\n\n    float amplitude = 0.96;\n\n    for (float r = 0.; r < 5.; r++) {\n        vec3 p = s * dir * 2.;\n        mat2 rt = rot(r);\n        p.xz =  rt * p.xz;\n        p.xy = rt * p.xy;\n        p.yz =  rt * p.yz;\n\n        p = abs(1. - mod(p * (hash1 * 2. + 1.), 2.));\n\n        float pa, a = pa = 0.;\n\n        for (int i = 0; i < 18; i++) {\n        //    if (float(i)>mod(iTime,period)*10.) break;\n        p = 1. * abs(p) / dot(p, p) - .7 -  step(.5, hash10) * .1;\n\n        float l = length(p) * .5;\n\n        // increment: controls the star size\n\n        // a += 3. * length( abs(p)/dot(p,p)) ;\n\n        //    a+= 1. * abs(l-pa);\n\n        // a += 0.8 * length(1. * min(vec3(4.), abs(p)) / max(0.4,  dot(p,p))) * abs(l-pa) ;\n\n        // starting i from 8 will introduce some stars in the corner, which is un-desirable\n        if (11 <= i && i <= 14) {\n        //   a += 10. * l;\n            a += 1. * abs(l - pa);\n        }\n\n        //                if (9 <= i && i <= 9) {\n        //                    //   a += 10. * l;\n        //                    a += 1. * abs(l - pa);\n        //                }\n\n            pa = length(p);\n        }\n\n        // a += 3. * length( abs(p)/dot(p,p)) ;\n\n        fade *= amplitude;\n\n        // color shift\n        sd += .5;\n        float cv = abs(2. - mod(sd, 4.));\n        vec3 color = normalize(vec3(cv * 2., cv * cv, cv * cv * cv));\n        v += normalize(color) * pow(a * .02, 2.) * fade;\n        v += color * pow(a * .02, 2.5)  * fade;\n        v.rb =  rot(hash3 * 3.) * v.rb;\n        v = abs(v);\n        pa = a;\n        s += .05;\n    }\n\n    int nebula = nebulaKind(time);\n    float sta = v.x;\n\n    vec2 uv = uvd;\n\n    if (nebula == 0 || nebula == 1) {\n\n    // return vec3(f);\n        uvd.x *= sign(hash12 - .5);\n        uvd = rot(360. * hash8 / 180. * 3.1415) * uvd;\n        uvd.y *= 1. + (uvd.x + .5) * 0.1;\n\n        v = pow(v, 1. - .1 * vec3(smoothstep(.5, 0., abs(uvd.y))));\n\n        //            vec3 roj = 1.8 * normalize(vec3(1.5, 1. * hash1, .8 * hash2 * 4.));\n        // 在声明时初始化\n\n        int id = int(hash4 * 6.);\n              \n        vec3[3] colors = getNebulaColorIds(hash14);\n        \n        \n        vec3 color1 =  vec3(1.);\n        \n        color1 =  colors[0];\n        \n        //return color1;\n        \n        vec3 color2 = getNebulaColor(hash11 * 3. + 5.);\n       \n        color2 =  colors[1];\n        //   color2 = vec3(2, 149, 171) / 255.;\n        \n        \n        \n      //  return color1;\n\n        //    color2 =  vec3( 243, 83, 70) / 255.;\n        vec3 color3 = getNebulaColor(hash15 * 4.);\n\n        //  color3 = vec3(43,22, 14) / 255.;\n        //cyan\n\n\n        // atmosphere\n        v += .01 / (.1 + abs(uvd.y * uvd.y)) * vec3(1.);\n\n\n        /// Controls the density of the nebula\n        float neb = 1.1 * fbm(dir.xy * 9. + time * 0.2, 12, 0.41, 0.6, 1.6);\n\n        //  float neb = fbm(dir.xy * 9.) - .5;\n\n        // The outer shape of the nebula\n        float core = 1.08 * smoothstep(.5 - hash3 * 0.5 , 0.2, length(uvd * vec2(1. , max(1., 1.5 * hash14)))) ;\n\n        float f = fbm21Test(uvd);\n\n        float d = -sdEllipse(uv - vec2(0.),  vec2(0.63,0.25), vec2(1.));\n\n        if (nebula == 0) {\n            // centered\n            core = smoothstep(-0.2 ,0.1, d)* 1.2;\n        } else {\n            // discrete\n            core = clamp(f * 1.5, 0., 1.);\n        }\n\n        // core = 1.;\n\n\n      //  return color1;\n\n\n        vec3 color =  mix( 1.1 * color2, 1. * color1, neb);\n        \n      \n       // return color;\n\n        vec3 darkColor = color3;\n\n        darkColor =  vec3(80, 14, 94) / 255.;\n        \n        darkColor = colors[2] * 0.7;\n\n        float dark = hash7 * 3. *  fbm(dir.xy * 4., 10, 0.6, 0.5, 2.3) ;\n        \n        dark = hash7 * 1. *  fbm(dir.xy * 3. + 0.1 * iTime, 12, 0.4, 0.6, 2.3) ;\n        \n        \n        dark = 1.2 * smoothstep(0.1, 0.8, dark);\n       // return vec3(dark);\n        \n     //  return vec3(dark);\n     //   dark = 1.9;\n        \n  //     return darkColor;\n    //    dark = 0.4;\n     //    return vec3(abs(darkColor - color).g);\n     \n   //     color = clamp(color, vec3(0.0), vec3(1.0));\n        \n      //  return color;\n         \n      //  darkColor = color - 0.3 * vec3(0.0, 0.8 , 0.2);\n        \n //      darkColor = clamp(darkColor, vec3(0.0), vec3(1.0));\n        \n    //    return darkColor;\n       \n    //   return vec3(dark);\n      \n     // return darkColor;\n     \n         color = color - dark * darkColor;\n\n     //   color = mix(color, darkColor, dark);\n        \n     //   color = vec3(0.2);\n        \n      //  return color;\n        \n      //   color.g = 0.0;\n     //    color.b += 0.4;\n     //    color.r += 0.1;\n\n        //color.b  = 0.0;\n       // color.g += 200.;\n        //color.g = abs(color.g);\n       // color.r = 0.0;\n\n       // return color;\n        // color += 0.3 * dark * darkColor;\n\n\n        //  color = color1;\n        \n     //   return darkColor;\n\n\n        v += core *  1.8 * color;\n\n\n        v = mix(length(v) * vec3(.8), v, .55);\n\n        // v +=  vec3(55, 36, 27)/ 255. * dark;\n        uvd.y += neb * clamp(1.5 * hash5, 0.3, 0.45) * 0.8;\n\n        neb = pow(smoothstep(.8, .0, abs(uvd.y)), max(2., 4. * hash12)) * .9;\n\n        //   neb = pow(smoothstep(.2, .1, abs(uvd.x)), 2. * hash13) * .9;\n\n        v = mix(v * 1.2, vec3(0.), 1. * max(neb, .7 + hash3 * 0. - neb) + core * .03 - sta * .2);\n\n    } else if (nebula == 2) {\n        v += galaxy(uvd + 0.5).rgb;\n    } else {\n    // v = vec3(0.);\n    }\n\n    //        v += galaxy(uv + 0.5, iChannel0, time).rgb;\n\n    v =  pow(v, vec3(1.05)) * 1.2;\n\n    return v;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   // t = iTime;\n  //  t = 13095.36;\n    zoom=iMouse.z>0.?2.:0.;\n    seed = floor( t / 3.);\n  //  seed = 233231.;\n //   seed = 5.;\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x*=iResolution.x/iResolution.y;\n\tuvd=uv;\n    \n\tvec2 m=iMouse.xy/iResolution.xy-.5;\n    m.x*=iResolution.x/iResolution.y;\n\tfloat fade=.5;\n\tif (step(.3,length(uv-m))<.5&&zoom>0.1) {\n\t\tfloat zo=.4/zoom;\n\t\tuv-=m;\n\t\tuvd-=m;\n\t\tuv*=zo;\n\t\tuvd*=zo;\n\t\tuv+=m;\n\t\tuvd+=m;\n\t\tfade=1.;\n\t}\n    vec3 dir=normalize(vec3(uv,1.));\n    vec3 col = render(dir, iTime, uvd);\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n    \n    //\tfragColor = vec4(1.);\n    \n    \n   fragColor = vec4(col,1.0);\n    \n  //  fragColor = vec4(vec3(f),1.0);\n}","name":"Image","description":"","type":"image"}]}