{"ver":"0.1","info":{"id":"fdGyzc","date":"1655301747","viewed":149,"name":"Raymarching Study01","username":"alanza","description":"attempting to undestand raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"fsKczG","parentname":"RayMarcherInit"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float kMaxHeight = 600.;\n\n// generate pseudorandom floats from a vector\nfloat hash(in vec2 xz) {\n    vec2 p  = 50.0*fract( xz*0.4656895 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n// smoothly interpolates between 0. and 1. on the interval [a,b] and computes its derivative\nvec2 smoothStepD (in float a, in float b, in float x) {\n    if (x <= a) return vec2(0,0);\n    else if (x >= b) return vec2(1,0);\n    else {\n        float scale = 1./(b - a);\n        float y = (x - a) * scale; \n        return vec2( y * y * (3. - 2. * y), 6. * y * (1. - y) * scale);\n    }\n}\n\n// infinite noisy surface and partial derivatives\nvec3 noise (in vec2 xz) {\n    vec2 p = floor(xz);\n    vec2 f = fract(xz);\n    \n    float a = hash(p + vec2(0,0));\n    float b = hash(p + vec2(1,0));\n    float c = hash(p + vec2(0,1));\n    float d = hash(p + vec2(1,1));\n    \n    vec2 u = f*f * (3. - 2. * f);\n    vec2 uprime = 6. * f * (1. - f);\n    \n    return vec3( 2.* (a + (b - a) * u.x + (c - a) * u.y  + (a - b - c + d) * u.x * u.y) -  1.,\n        2. * (b - a) * uprime.x + 2.* (a - b - c + d) * uprime.x * u.y,\n        2. * (c - a) * uprime.y + 2.* (a - b - c + d) * u.x * uprime.y);\n}\n\nconst mat2 MAT = mat2(.8, -.6,\n                    .6, .8);\n\nconst mat2 MATI = mat2(.8, .6,\n                    -.6, .8);\n                    \nvec3 stackedNoise (vec2 xz) {\n    float f = 2.25;\n    float s = 0.48;\n    float a = 0.;\n    float b = 0.5;\n    vec2 der = vec2(0);\n    mat2 m = mat2(1, 0, 0, 1);\n    for (int i=0; i<8; i++)\n    {\n        vec3 n = noise(xz);\n        a += b*n.x; // accumulate value\n        der += b*m*n.yz; // accumulate normals\n        b *= s;\n        xz = f*MAT*xz;\n        m = f*MATI*m;\n    }\n    \n    return vec3(a, der);\n}\n\nvec4 mapTerrain (vec2 xz) {\n    vec3 n = stackedNoise(xz / 2000.);\n    n.x *= 600.;\n    vec2 stepD = 50.*smoothStepD( 182., 224., n.x);\n    n.x += stepD.x;\n    n.yz =  n.yz*(1. + stepD.y);\n    return vec4(n.x, normalize(vec3(-n.y,1,-n.z)));\n}\n\nfloat rayMarch (in vec3 ro, in vec3 rd, in float tmin, float tmax) {\n    float tp = (kMaxHeight-ro.y)/rd.y;\n    if( tp>0.0 ) tmax = min( tmax, tp );\n    \n    float dist, thousandth;\n    float t = tmin;\n    float ot = t;\n    float odist = 0.0;\n    \n    for (int i=0; i < 400; i++) {\n        thousandth = 0.001*t;\n        \n        vec3 pos = ro + t * rd;\n        float height = mapTerrain(pos.xz).x;\n        float flag = 1. - smoothStepD( .12, .13, abs(height  + .12)).x;\n        \n        dist = pos.y - height;\n        if (dist < thousandth) break;\n        \n        ot = t;\n        odist = dist;\n        t += dist * 0.8 * (1. - .75 * flag);\n        if (t > tmax) break;\n    }\n    if (t > tmax) t = -1.;\n    else t = ot + (thousandth - odist) * (t - ot) / (dist - odist);\n    \n    return t;\n}\n\n\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint )\n{\n    float res = 1.0;\n    float t = mint;\n    for (int i=0; i<128; i++)\n    {\n        vec3  pos = ro + t*rd;\n        float env = mapTerrain( pos.xz ).x;\n        float hei = pos.y - env;\n        res = min( res, 32.0*hei/t );\n        if( res<0.0001 || pos.y>kMaxHeight  ) break;\n        t += clamp( hei, 0.5+t*0.05, 25.0 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nconst vec3 light = vec3(55000,1000,00);\n\nvec3 renderSky( in vec3 ro, in vec3 rd )\n{\n    // background sky     \n    //vec3 col = vec3(0.45,0.6,0.85)/0.85 - rd.y*vec3(0.4,0.36,0.4);\n    //vec3 col = vec3(0.4,0.6,1.1) - rd.y*0.4;\n    vec3 col = vec3(0.42,0.42,.6) - rd.y*0.4;\n\n    // clouds\n    float t = (1500.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec2 uv = pos.xz;\n        float cl = stackedNoise( uv*0.00104 ).x;\n        float dl = smoothstep(-0.2,0.6,cl);\n        col = mix( col, vec3(1.0), 0.12*dl );\n        \n    \n        // sun glare    \n        float sun = clamp( dot(normalize(light - pos),rd), 0.0, 1.0 );\n        col += 0.2*vec3(1.0,0.6,0.3)*pow( sun, 32.0 );\n    }\n    \n\treturn col;\n}\n\n// returns a 3x3 matrix transforming the (u,v,fl) plane to the world\nmat3 makeCamera (in vec3 pinhole, in vec3 target, float tilt) {\n    vec3 camera_w = normalize( target - pinhole );\n    vec3 camera_p = vec3(sin(tilt), cos(tilt), 0.0);\n    vec3 camera_u = normalize(cross(camera_w, camera_p));\n    vec3 camera_v = normalize(cross(camera_u, camera_w));\n    return mat3(camera_u, camera_v, camera_w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 in the x direction)\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.x;\n    \n    // ray origin \n    vec3 ro =  vec3(4656895. + 250.*sin(iTime*.025),0,800);\n    // look-at point\n    const float theta = .7;\n    vec3 ta = ro + vec3(515. - 250. *sin(iTime*.025),75,611 );\n    // focal length\n    float fl = 3.5;\n    // ray direction\n    vec3 rd = makeCamera(ro, ta, 0.01) * normalize(vec3(uv,fl));\n    \n    \n    \n    \n    \n    const float MAXT = 80000.;\n    \n    float t = rayMarch(ro, rd, 1., MAXT);\n    \n    vec3 pos = ro + rd * t;\n    \n    vec3 col = vec3(0.59215, 0.41568, 0.522222);\n    \n    if (t < 0.) col = renderSky(ro,rd);\n    else {\n        vec3 lightdir = normalize(light - pos);\n        vec3 normal = mapTerrain(pos.xz).yzw;\n        float shade;\n        if (pos.y < 200.) shade = softShadow(pos + vec3(0,.1,0), lightdir, 0.1);\n        else {\n            shade = softShadow(pos + vec3(0,10.53,0), lightdir, 10.53);\n        }\n        col = (1. - smoothstep(.1,.4, normal.y))*col  +  smoothstep(.1,.4,normal.y)*vec3(.9);\n        vec3 scale = pow(0.99950012497, t)*vec3(1,1,1.5);\n        col = scale*col + (1. - scale)*vec3(.5);\n        col *= shade * max(0., dot(lightdir, normal))  \n            + (1. + normal.y) *.05 * vec3(.42,.42,.6) \n            + max(0., dot(-lightdir, normal)) * 0.1 * vec3(0.59215, 0.41568, 0.52222222);\n    } \n    col = smoothstep(0.,1.,col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}