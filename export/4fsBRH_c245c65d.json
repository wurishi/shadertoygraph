{"ver":"0.1","info":{"id":"4fsBRH","date":"1724347841","viewed":75,"name":"Titaniumballz 2","username":"Cotterzz","description":"Second attempt at this, from https://www.shadertoy.com/view/4fByD1\n\nSome improvements and a more realistic lighting model, with some gamma and contrast adjustments via the mouse.\n\nFeedback welcome, there's still room for improvement.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["game","lighting","spheres","shadows","ball","25d","orthographic","titaniumballz"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com\n// You may view and edit this code (with this message intact) only on Shadertoy.\n// Anything else requires my permission.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // GEOMETRY SETTINGS\n    // General\n    uv = fragCoord/iResolution.y;      // Normalised resolution\n    float height = 0.0;                     // This is the z value to go with our uv's x and y\n    ar = iResolution.x/iResolution.y; // Aspect ratio or normalised width\n    pixel = 1.4/iResolution.y;        // Size of pixel, for AA\n    // Zones. Not exclusive. We can be on more than one for purposes of AA mixing\n    bool ZoneRob = false;                  // Are we on the curved fg objects\n    bool ZoneGround = false;                // Are we on the ground\n    bool ZoneWall = false;                  // Are we on the walls\n    bool ZoneGoalWall = false;              // Are we on the goal walls\n    bool ZoneInsideWall = false;            // Are we inside wall of goal\n    // Background\n    border = 0.05;  // Edge border as fraction of screen\n    bar = 1.0; // vary border thickness, set to ar, or not, set to 1.0 \n    vec4 courtyard = vec4( border*bar, border, ar-(border*bar), 1.0-border); // Edge border limits\n    // Difference between current position and edge border limits\n    courtprox = vec4( courtyard.x - uv.x, courtyard.y - uv.y, uv.x - courtyard.z, uv.y - courtyard.w);\n    float goalwidth = 0.2;                   // width of goal\n    float goaltop = 0.5 + (goalwidth/2.0);   // position of goal top\n    float goalbottom = 0.5 - (goalwidth/2.0);// position of goal bottom\n    float goalprox = max((uv.y-goaltop), (goalbottom-uv.y)); // how far current position is from goal limits\n    float wallheightfactor = 1.0;  // multiplier to make up for the fake wall perspective\n    // Foreground\n    Rob Robs[numrobs];\n    float dist = ar; // distance to nearest foreground object\n    int rindex = -1; // index of object\n    vec2 centre = vec2(ar/2.0, 0.5); // centre of current object\n    float radius = 0.0; // radius of current object\n    float cradius = 0.34; // radius of circle\n    vec2 centreL = vec2((ar/2.0)-(cradius),0.5); // centre of left circle\n    vec2 centreR = vec2((ar/2.0)+(cradius),0.5); // centre of right circle\n    float segment = 1.256637; // ( 3.1415926 * 2.0 ) / 5.0;\n    float rightAng = 1.5708; // ( 3.1415926 * 2.0 ) / 4.0;\n    float dradius = 0.055; // default object radius\n    float bradius = 0.02; // ball radius\n    vec2 distv; // vector from current position to centre\n    vec3 normal = vec3(0.0,0.0,1.0); // normal of surface, default is normal of ground\n    vec3 bgnormal = vec3(0.0,0.0,1.0); // normal of walls or ground, default is normal of ground\n    bool flatTop = false;\n    float theight = 0.0;\n    float angle = 0.0;\n    float speed = iTime;\n    \n    for(int i=1;i<numrobs;i++){\n        Robs[i].radius = dradius;\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>5){\n            angle += speed;\n            Robs[i].rotation = angle + rightAng;\n            rcentre = centreR;} else {\n                \n                angle -= speed;\n                Robs[i].rotation = angle - rightAng;\n            }\n        Robs[i].position = vec3( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0);\n        \n    }\n    int hasball = 2;\n    float balldist = bradius*1.1 + dradius;\n    Robs[0].position = vec3( Robs[hasball].position.x + (balldist * cos(Robs[hasball].rotation)), Robs[hasball].position.y + (balldist * sin(Robs[hasball].rotation)), Robs[0].radius);\n    Robs[0].radius = bradius;\n    Robs[0].colourA = vec3(1.3,1.3,1.4);\n    Robs[1].colourA = pblue;\n    Robs[2].colourA = ppurple;\n    Robs[3].colourA = pink;\n    Robs[4].colourA = porange;\n    Robs[5].colourA = pyellow;\n    Robs[6].colourA = pblue;\n    Robs[7].colourA = pyellow;\n    Robs[8].colourA = porange;\n    Robs[9].colourA = pink;\n    Robs[10].colourA = ppurple;\n    \n    // COLOUR SETTINGS\n    vec3 bgcol; // final background colour\n    vec3 fgcol; // final foreground colour\n    vec3 col = white;   // final colour\n    vec2 robambient = vec2(1.0, 1.0); // the total Ambient effect of round objects. two vlaues for mixing foreground and bg\n    \n    light lights[numlights];\n    lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*0.5, 0.5 ,0.5),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.1);\n    lights[1] = light(vec3(1.0,0.4,0.4),vec3(ar*-0.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.04);\n    lights[2] = light(vec3(0.4,1.0,0.4),vec3(ar*1.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.04);\n    \n    // CASES\n    if(courtprox.w>0.0 && courtprox.w*bar>courtprox.z && courtprox.w*bar>courtprox.x){\n        // TOP WALL\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,-1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.w * wallheightfactor;\n    } else if(courtprox.y>0.0 && courtprox.y*bar>courtprox.z && courtprox.y*bar>courtprox.x){\n        // BOTTOM WALL\n        bgcol = pgrey;\n        bgnormal = vec3(0.0,1.0,0.0);\n        ZoneWall = true;\n        height = courtprox.y *  wallheightfactor;\n    } else if(goalprox>0.0 && courtprox.x>0.0 || courtprox.x>(border*bar)/2.0){\n        // LEFT WALL\n        bgcol = pgrey;\n        bgnormal = vec3(1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        float cph = courtprox.x/2.2;\n        if(goalprox<cph && courtprox.x<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);} \n        } else {\n            height = courtprox.x * wallheightfactor;      \n        }\n    } else if(goalprox>0.0 && courtprox.z>0.0 || courtprox.z>(border*bar)/2.0){\n        // RIGHT WALL\n        bgcol = pgrey;\n        bgnormal = vec3(-1.0,0.0,0.0);\n        ZoneWall = true; ZoneGoalWall = true;\n        if(goalprox<courtprox.z/2.2 && courtprox.z<(border*bar)/2.0 ){\n            ZoneInsideWall = true;\n            height = goalprox * wallheightfactor;\n            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);}\n        } else {\n            height = courtprox.z * wallheightfactor;\n          \n        }\n    } else {\n        ZoneGround = true;\n        bgcol = getGroundColour();\n        bgnormal = vec3(0.0,0.0,1.0);\n        //float testbox = sdBox(uv - vec2(0.1,0.5), vec2(0.1,0.1));height=min(testbox, 0.0);\n    }\n    \n    float lightATG = (goaltop-lights[1].position.y)/(lights[1].position.x-courtyard.x);\n    float lightATGdist = ( (lights[1].position.x - uv.x) * lightATG) -  (uv.y-lights[1].position.y);\n    float lightABG = (goalbottom-lights[1].position.y)/(lights[1].position.x-courtyard.x);\n    float lightABGdist =    (uv.y-lights[1].position.y)-( (lights[1].position.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n    \n    lights[1].shadow.x = 1.0;\n    if(goalprox<0.0||ZoneInsideWall){lights[1].shadow.x = 0.0;} else if(lightAdist>0.0){\n        lights[1].shadow.x = 0.0;\n        f = smoothstep(0.0, 0.2*-courtprox.x, lightAdist);\n        lights[1].shadow.x = mix(1.0, 0.0, f);\n    }\n    \n    lightATG = (goaltop-lights[2].position.y)/(lights[2].position.x-courtyard.z);\n    lightATGdist = ( (lights[2].position.x - uv.x) * lightATG) -  (uv.y-lights[2].position.y);\n    lightABG = (goalbottom-lights[2].position.y)/(lights[2].position.x-courtyard.z);\n    lightABGdist =    (uv.y-lights[2].position.y)-( (lights[2].position.x - uv.x) * lightABG);\n    lightAdist = lightABGdist*lightATGdist;\n    \n    lights[2].shadow.x = 1.0;\n    if(goalprox<0.0||ZoneInsideWall){lights[2].shadow.x = 0.0;} else if(lightAdist>0.0){\n        lights[2].shadow.x= 0.0;\n        f = smoothstep(0.0, 0.2*-courtprox.z, lightAdist);\n        lights[2].shadow.x = mix(1.0, 0.0, f);\n    }\n    lights[1].shadow.y = lights[1].shadow.x;\n    lights[2].shadow.y = lights[2].shadow.x;\n    \n    \n    for(int i=0;i<numrobs;i++){\n        float bdist = distance(uv, Robs[i].position.xy);\n        if(bdist<dist){dist=bdist;}\n        \n        if(bdist<Robs[i].radius&&!ZoneWall){\n            dist=bdist;\n            radius = Robs[i].radius;\n            height = sqrt((radius*radius)-(dist*dist));\n            ZoneRob = true;\n            rindex = i;\n            if(i>5){flatTop=true;}\n            if(bdist<Robs[i].radius-pixel){ZoneGround = false;}\n        } else {\n            float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);\n            robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0)); // ambient multiplier for outside of object\n        }\n        \n    }\n    \n    if(ZoneRob){\n        fgcol = Robs[rindex].colourA;\n        centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);\n        distv = uv - centre;\n        normal = vec3(distv.x, distv.y, height)/radius;\n        height+=Robs[rindex].position.z;\n        \n        if(flatTop){\n            float tradius = radius/2.5;\n            theight = sqrt((radius*radius)-(tradius*tradius));\n            if(height>theight){\n                height=theight;\n                normal = vec3(0.0, 1.0, 0.0);\n            }\n            f = smoothstep(theight-0.01, theight, height);\n            normal = mix(normal,vec3(0.0, 0.0, 1.0),  f);\n            height = mix(height,theight,  f);\n        }\n        \n        robambient *= (0.6 + normal.z/3.0);// ambient multiplier for inside of object\n        float rotation = Robs[rindex].rotation;\n        if(rindex>0){\n            // Spoiler flap - theres probably a simpler way of doing this\n            float SpFoffset = radius*2.0;// set distance from centre to front\n            float SpBoffset = radius/1.0;// set distance from centre to back\n            float SpFheight = radius*-1.0;// set front and back heights\n            float SpBheight = radius*1.4;\n            float SpWidth = radius/1.4;// set width, length, height of triangle\n            float SpLength = SpFoffset+SpBoffset;\n            float SpHeight = SpBheight-SpFheight;\n            vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation),  centre.y + SpFoffset * sin(rotation), 0.0);// get front point F\n            vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.y -= (SpWidth * cos(rotation));// get front points L and R\n            vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.y += (SpWidth * cos(rotation));\n            vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), centre.y - SpBoffset * sin(rotation), 0.0);// get back point B\n            vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.y -= (SpWidth * cos(rotation));// get back points L and R\n            vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.y += (SpWidth * cos(rotation));\n            float SpBD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpBl.x, SpBl.y, 0.0), vec3(SpBr.x, SpBr.y, 0.0) );// get distance from back\n            float SpFD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpFl.x, SpFl.y, 0.0), vec3(SpFr.x, SpFr.y, 0.0) );// get distance from front\n            float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point\n            float inTri = sdTriangle(uv, SpFc.xy, SpBr.xy, SpBl.xy);// is point in triangle\n            //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is\n    \n            float lineDist = linePointLength( vec3(uv.x, uv.y, 0.0) , vec3(SpBc.x, SpBc.y, 0.0)  , vec3(SpFc.x, SpFc.y, 0.0)  );\n\n            if(SpH>height){// is spoiler higher than dome\n                float face = 0.7; \n                if(inTri<0.0&&dist<radius*0.9){\n                    if(dist<radius*0.7){\n                        f = smoothstep(0.0, pixel*5.0, SpH-height);\n                        height=mix(height, SpH,  f);\n                        normal=mix(normal,vec3( face * cos(rotation) , face * sin(rotation), 0.7), f);\n                    } else {\n                        f = smoothstep(radius*0.75, radius*0.95, dist);\n                        height=mix( SpH, height, f);\n                        normal=mix(vec3( face * cos(rotation) , face * sin(rotation), 0.7),normal, f);\n                    }\n                } \n            }\n            \n        }\n        normal = normal/length(normal);\n        for(int i=0;i<numrobs;i++){\n        if(i!=rindex){\n            for(int j=0;j<numlights;j++){\n             if(distance(Robs[i].position, lights[j].position) < distance(Robs[rindex].position, lights[j].position)){\n                vec3 tempBall = Robs[i].position;\n                tempBall.z*=1.2;\n                float beam = linePointLength(tempBall, lights[j].position, vec3(uv.x, uv.y, height)); \n                float cradius = Robs[i].radius*1.2; // cheating and making the ball bigger so shadow seen more easily\n                float blur = distance(Robs[i].position, vec3(uv.x, uv.y, height))/5.0;\n                float shadow = 0.0;\n                if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                    f = smoothstep(cradius-blur, cradius, beam);\n                    shadow = mix(1.0,0.0, f);\n                }\n                lights[j].shadow.y = max(shadow, lights[j].shadow.y);\n                }\n                }\n            }\n        }\n    }\n    \n    if(ZoneGround||ZoneWall){\n        float shadowheight = 0.0;\n        if(ZoneWall){shadowheight = height;};\n        for(int i=0;i<numrobs;i++){\n            for(int j=0;j<numlights;j++){\n                float beam = linePointLength(Robs[i].position, lights[j].position, vec3(uv.x, uv.y, shadowheight)); \n                float cradius = Robs[i].radius;\n                float blur = distance(Robs[i].position, vec3(uv.x, uv.y, shadowheight))/5.0;\n                float shadow = 0.0;\n                if (beam<=(cradius-blur)){shadow = 1.0;} else {\n                    f = smoothstep(cradius-blur, cradius, beam);\n                    shadow = mix(1.0,0.0, f);\n                }\n                lights[j].shadow.x = max(shadow, lights[j].shadow.x);\n            }\n        }\n    }\n    \n    // calculate and multiply ambient\n\n    // these ambient calculations are an approximation based on proximity to walls, ground and objects\n    // it gives us a very rough but dynamic AO value\n    float ambientmulti = (min(0.5+(height*3.0), 1.0));// if you're on the ground, half of ambient light is removed\n    float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;\n    ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));\n    // and again for each wall\n    ambientmulti = robambient.x*ambientmulti;\n    \n    vec3 position = vec3(uv, height);\n    vec3 bgtot = vec3(0.0);\n    vec3 fgtot = vec3(0.0);\n    vec3 sptot = vec3(0.0);\n    for(int j=0;j<numlights;j++){\n        lights[j].difference = lights[j].position - position;\n        lights[j].dist = length(lights[j].difference);\n        lights[j].difference = lights[j].difference/lights[j].dist;\n        lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));\n        lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));\n        lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);\n        lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);\n        lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);\n        bgtot += lights[j].colour*lights[j].amount.y;\n        fgtot += lights[j].colour*lights[j].amount.x;\n    }\n\n    bgcol*=ambientmulti+bgtot;\n    \n    if(ZoneRob){\n        // calculate and add specular\n        vec3 incident = vec3(0.0, 0.0, -1.0);\n        vec3 reflection = reflect(incident, normal);\n        for(int j=0;j<numlights;j++){\n            lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),32.0);\n            lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);\n            lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);\n            sptot += lights[j].colour*lights[j].amount.z;\n        }\n    \n        fgcol *= ambientmulti+fgtot;\n        fgcol += sptot; // Add specuialr highlight\n    \n        // Assign forground or background colour or mix them if on AA border\n   \n        if(ZoneGround){\n            f = smoothstep(radius-pixel, radius, dist);\n            col = mix(fgcol,bgcol, f);\n        } else {\n            col = fgcol;\n        }\n    } else {\n        col = bgcol;\n    }\n    // Output to screen\n\n    f = smoothstep(0.0, iResolution.x, iMouse.x);\n    col = contrast(col, f+1.0);\n    if(iMouse.y!=0.0){\n        f = smoothstep(0.0, iResolution.y, iMouse.y);\n        col = gammaCorrection(col, 0.5 + f*2.0);\n    }\n    \n    if(outputMode){col = outputColour;}\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define numrobs 11\n#define numlights 3\n#define black vec3(0.0,0.0,0.0)\n#define white vec3(1.0,1.0,1.0)\n#define grey vec3(0.5,0.5,0.5)\n#define blue vec3(0.0,0.0,1.0)\n#define red vec3(1.0,0.0,0.0)\n#define lime vec3(0.0,1.0,0.0)\n#define green vec3(0.0,0.7,0.0)\n#define cyan vec3(0.0,1.0,1.0)\n#define purple vec3(1.0,0.0,1.0)\n#define yellow vec3(1.0,1.0,0.0)\n#define orange vec3(1.0,0.6,0.0)\n\n#define porange vec3(1.0,0.8,0.6)\n#define pyellow vec3(0.87,0.87,0.7)\n#define pblue vec3(0.8,0.85,1.0)\n#define pgreen vec3(0.7,0.9,0.7)\n#define pink vec3(0.95,0.75,0.75)\n#define ppurple vec3(1.0,0.7,1.0)\n#define pgrey vec3(0.85,0.85,0.85)\n\n// declared here for use in functions\nfloat pixel = 0.0;\nvec4 courtprox = vec4(0.0);\nvec2 uv = vec2(0.0);\nfloat ar = 0.0;\nfloat f = 0.0; // AA mixing number\nfloat border = 0.05;\nfloat bar = 1.0;\n\nstruct light\n{\n    vec3 colour;\n    vec3 position;\n    vec3 difference;\n    vec3 amount;\n    vec2 shadow;\n    float dist;\n    float intensity;\n};\n\nstruct Rob // Round Object. (Players and Ball)\n{\n    vec3 position;\n    vec3 colourA;\n    vec3 colourB;\n    float rotation;\n    float radius;\n};\n\nvec3 getGroundColour(){\n    float linewidth = 0.01;\n    float hlinewidth = linewidth/2.0;\n    float rhlinewidth = hlinewidth + pixel/2.0;\n    vec3 rcol = pgrey;\n    if(courtprox.x>-linewidth&&courtprox.x<=0.0||abs(courtprox.y)<linewidth||courtprox.z>-linewidth&&courtprox.z<=0.0||abs(courtprox.w)<linewidth){\n        rcol = white;\n    }\n    float crad = 0.2;\n    float dfc = distance(uv, vec2(ar/2.0, 0.5));\n    float crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, pgrey, f);\n    }\n\n    if(crdiff>=hlinewidth-pixel&&abs(uv.x - (ar/2.0))<=hlinewidth){\n        rcol = white;\n    }\n    dfc = distance(uv, vec2(border*bar, 0.5));\n    crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    dfc = distance(uv, vec2(ar-(border*bar), 0.5));\n    crdiff = dfc-crad;\n    if(crdiff<rhlinewidth ){\n        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));\n        rcol = mix(white, rcol, f);\n    }\n    return rcol;\n}\n\nbool outputMode = false; vec3 outputColour; // Easy way to throw a value at the output for debugging\nvoid outputValue (in float value){\n    outputMode = true;\n    if ( value >= 0.0 && value <= 1.0 )\n        { outputColour = vec3(value, value, value); }\n        else if ( value < 0.0 && value > -1.0 )\n        { outputColour = vec3(0.0, 0.0, -value ); }\n        else if ( value > 1.0 )\n        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }\n        else if ( value < -1.0 )\n        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }\n} // Call outputValue with a float and that value will override the pixel output\nvoid outputValue (in vec3 value){outputMode = true;outputColour = value;} // or directly with a vec3\n\nvec3 contrast(vec3 color, float value) {\n  return 0.5 + value * (color - 0.5);\n}\n\nvec3 gammaCorrection (vec3 colour, float gamma) {\n  return pow(colour, vec3(1. / gamma));\n}\n\nfloat linePointLength( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    if(X.z<0.0){return 10.0;} else {return length(X-P);}\n}\n\nvec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){\n    vec3 AB = B-A;\n    float lenAB = length(AB);\n    vec3 D = AB/lenAB;\n    vec3 AP = P-A;\n    float d = dot(D, AP);\n    vec3 X = A + D * dot(P-A, D);\n    return X;\n}\n\n// SD Functions from https://iquilezles.org/articles/distfunctions2d/\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n/* OLD SHADER\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 Tcolf;\n    vec3 Tcolb;\n    \n    float speed = iTime;\n    float dist = 20.0;\n    float angle;\n    vec3 bcol,col;\n    int currentBall = 10;\n    for(int i=0;i<numballs;i++){\n        angle = float(i) * segment;\n        vec2 rcentre = centreL;\n        if(i>4){\n            angle += speed;\n            rcentre = centreR;} else {\n                angle -= speed;\n            }\n        Balls[i]= vec4( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0, angle );\n\n        float bdist = distance(uv, Balls[i].xy);\n        if(bdist<radius){\n            dist=bdist;\n            if(bdist<(radius-pixel)){currentBall = i;}\n            centre = vec2(Balls[i].x, Balls[i].y);\n            vec3 TAbcol = vec3(0.9,1.0,0.9);\n            vec3 TAfcol = vec3(0.1,0.7,0.1);\n            vec3 TBbcol = vec3(0.1,0.0,0.0);\n            vec3 TBfcol = vec3(1.0,0.0,0.0);\n            \n            if(i<5){Tcolf=TAfcol;Tcolb=TAbcol;}else{Tcolf=TBfcol;Tcolb=TBbcol;}\n            float f;\n            float ringRadius=0.8;\n            float ringWidth = 0.1;\n            if(i>4){flatTop=true;ringRadius=0.45;}else{flatTop=false;ringRadius=0.8;}\n            if(bdist>radius*(ringRadius+ringWidth)){\n                f = smoothstep(radius*(ringRadius+ringWidth), (radius*(ringRadius+ringWidth))+pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else if (bdist<radius*ringRadius){\n                \n                f = smoothstep(radius*ringRadius, (radius*ringRadius)-pixel, bdist);\n                bcol = mix(Tcolf,Tcolb,  f);\n            } else {\n                bcol = Tcolf;\n            }\n\n            \n        } else if(bdist<dist){ dist=bdist;}\n           \n        \n\n    }\n\n    float rotation;\n\n    if(currentBall>4){\n        rotation = Balls[currentBall].w + rightAng;\n    } else {rotation = Balls[currentBall].w - rightAng;}\n\n     //vec2 ball = vec2(Balls[0].x + (radius*1.3 * cos(Balls[0].w- rightAng)), Balls[0].y + (radius*1.3 * sin(Balls[0].w- rightAng)));\n     //if( distance(uv, ball)<radius*0.2){ centre = vec2(ball.x, ball.y); bcol = purple; currentBall=-1;}\n    // Spoiler flap\n    float SpFoffset = radius*3.0;// set distance from centre to front\n    float SpBoffset = radius/1.8;// set distance from centre to back\n    float SpFheight = radius*-1.5;// set front and back heights\n    float SpBheight = radius*1.2;\n    float SpWidth = radius/1.6;// set width, length, height of triangle\n    float SpLength = SpFoffset+SpBoffset;\n    float SpHeight = SpBheight-SpFheight;\n    vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation), 0.0, centre.y + SpFoffset * sin(rotation));// get front point F\n    vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.z -= (SpWidth * cos(rotation));// get front points L and R\n    vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.z += (SpWidth * cos(rotation));\n    vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), 0.0, centre.y - SpBoffset * sin(rotation));// get back point B\n    vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.z -= (SpWidth * cos(rotation));// get back points L and R\n    vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.z += (SpWidth * cos(rotation));\n    float SpBD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpBl.x, 0.0, SpBl.z), vec3(SpBr.x, 0.0, SpBr.z) );// get distance from back\n    float SpFD = linePointLength( vec3(uv.x, 0.0, uv.y), vec3(SpFl.x, 0.0, SpFl.z), vec3(SpFr.x, 0.0, SpFr.z) );// get distance from front\n    float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point\n    float inTri = sdTriangle(uv, SpFc.xz, SpBr.xz, SpBl.xz);// is point in triangle\n    //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is\n    \n    float lineDist = linePointLength( vec3(uv.x, 0.0, uv.y) , vec3(SpBc.x, 0.0, SpBc.z)  , vec3(SpFc.x, 0.0, SpFc.z)  );\n    if(currentBall<5){\n        float gfline = 2.7;\n        float gflinew = 0.011;\n        if(lineDist>radius/gfline&&lineDist<(radius/gfline)+gflinew&&dist<radius*0.9)\n            {\n            if(lineDist<(radius/gfline)+(gflinew/5.0)){\n                float p = smoothstep(radius/gfline, radius/gfline + (gflinew/5.0), lineDist);\n                bcol = mix(Tcolb,Tcolf,  p);} else {\n                    float p = smoothstep((radius/gfline)+gflinew, (radius/gfline)+gflinew - (gflinew/5.0), lineDist);\n                    bcol = mix(bcol,Tcolf,  p);\n                }\n            } else if (lineDist<(radius/gfline)+gflinew ){bcol = Tcolb;}\n    }\n    \n    float power = 32.0;\n    float power2 = 32.0;\n\n    float height = sqrt((radius*radius)-(dist*dist));\n    vec2 distv = uv - centre;\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n        \n    if(flatTop){\n        if(height>theight){\n            height=theight;\n            normal = vec3(0.0, 1.0, 0.0);\n            power = power2;\n        }\n        float p = smoothstep(theight-0.01, theight, height);\n        normal = mix(normal,vec3(0.0, 1.0, 0.0),  p);\n        height = mix(height,theight,  p);\n    }\n    if(SpH>height&&currentBall<10){// is spoiler higher than dome\n        float face = 0.7;  \n        if(inTri<0.0){\n        power = power2;\n        float s = smoothstep(0.0, -0.002, inTri);\n        bcol=mix(Tcolb, Tcolf, s);\n        if(inTri<-0.005){\n            s = smoothstep(-0.01, -0.008, inTri);\n            bcol=mix(Tcolb, Tcolf, s);\n        }\n            s = smoothstep(0.0, pixel*6.0, SpH-height);\n            height=mix(height, SpH, s);\n            normal=mix(normal,vec3( face * cos(rotation), 0.9 , face * sin(rotation)), s);\n        } \n        if (inTri<radius/10.0&&inTri>0.0) {\n            power = power2;\n            bcol=Tcolb;\n            float s = smoothstep(0.0, radius/6.0, inTri);\n            height=mix(SpH,height,  s);\n            normal=mix(vec3( face * cos(rotation), 0.9 , face * sin(rotation)),normal, s);\n        }\n    }\n    \n    normal = normal/length(normal);\n\n    vec3 position = vec3(uv.x, height, uv.y);\n        \n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n\n    vec3 lcolA = vec3(0.0,0.4,0.0);\n    vec3 lcolB = vec3(0.5,0.0,0.0);\n    vec3 lcolC = vec3(0.4,0.4,0.5);\n\n    vec3 lcolAmbient = (lcolA+lcolB+lcolC+lcolC+lcolC)/(7.0);\n        \n    gcol *= lcolAmbient;\n\n    vec3 lightA = vec3(0.0-0.3, 0.1, 0.5);\n    vec3 lightB = vec3(ar+0.3, 0.1, 0.5);\n    vec3 lightC = vec3(0.5*ar,0.2, 0.5);\n        \n    float f;\n    \n    vec3 goalRT = vec3(ar-0.1, 0.2, 0.65);\n    vec3 goalRB = vec3(ar-0.1, 0.2, 0.35);\n\n    float lightBTG = (goalRT.z-lightB.z)/(lightB.x-goalRT.x);\n    float lightBTGdist = ( (lightB.x - uv.x) * lightBTG) -  (uv.y-lightB.z);\n    float lightBBG = (goalRB.z-lightB.z)/(lightB.x-goalRB.x);\n    float lightBBGdist =    (uv.y-lightB.z)-( (lightB.x - uv.x) * lightBBG);\n    float lightBdist = lightBBGdist*lightBTGdist;\n    \n    vec3 goalLT = vec3(0.1, 0.2, 0.65);\n    vec3 goalLB = vec3(0.1, 0.2, 0.35);\n\n    float lightATG = (goalLT.z-lightA.z)/(lightA.x-goalLT.x);\n    float lightATGdist = ( (lightA.x - uv.x) * lightATG) -  (uv.y-lightA.z);\n    float lightABG = (goalLB.z-lightA.z)/(lightA.x-goalLB.x);\n    float lightABGdist =    (uv.y-lightA.z)-( (lightA.x - uv.x) * lightABG);\n    float lightAdist = lightABGdist*lightATGdist;\n\n    vec3 tolightA = lightA - position;\n    vec3 tolightB = lightB - position;\n    vec3 tolightC = lightC - position;\n\n    float distlA = length(tolightA);\n    float distlB = length(tolightB);\n    float distlC = length(tolightC);\n\n    tolightA = tolightA/distlA;\n    tolightB = tolightB/distlB;\n    tolightC = tolightC/distlC;\n    \n    float lamntA = max(0.0, dot(tolightA, normal));\n    float lamntB = max(0.0, dot(tolightB, normal));\n    float lamntC = max(0.0, dot(tolightC, normal));\n\n    float specamntA = pow(max(0.0, dot(tolightA, reflection)), power);\n    float specamntB = pow(max(0.0, dot(tolightB, reflection)), power);\n    float specamntC = pow(max(0.0, dot(tolightC, reflection)), power);\n    if( dist > radius ){ height = 0.0;}\n    \n    vec3 tlightA = (lcolA*specamntA)+(lcolA*lamntA);\n    vec3 tlightB = (lcolB*specamntB)+(lcolB*lamntB);\n    vec3 tlightC = (lcolC*specamntC)+(lcolC*lamntC);\n    \n    tlightA*=2.0;\n    tlightB*=2.0;\n    tlightC*=3.0;\n    \n    int Btotal;\n    int Atotal;\n    int Ctotal;\n    float Bmost=0.0;\n    float Amost=0.0;\n    float Cmost=0.0;\n        \n    bool Bcast = false;\n    float BcastDepth;\n    bool Acast = false;\n    float AcastDepth;\n    for(int i=0;i<numballs;i++){\n        if(i!=currentBall){\n            vec3 ballcast = Balls[i].xzy;\n            float beamA = linePointLength(ballcast, lightA, vec3(uv.x, height, uv.y));\n            float beamB = linePointLength(ballcast, lightB, vec3(uv.x, height, uv.y));\n            float beamC = linePointLength(ballcast, lightC, vec3(uv.x, height, uv.y)); \n               \n            if (beamC>(radius)){Ctotal+=1;} else if ((radius-beamC) > Cmost) {Cmost = radius-beamC;}\n\n            if (beamA>(radius)){ Atotal+=1;} else {\n                if ((radius-beamA) > Amost) {Amost = radius-beamA;}\n                if (height>0.0  && (uv.x>Balls[i].x) ){ Acast = true; AcastDepth=radius-beamA;}\n            }\n\n            if (beamB>(radius)){\n                Btotal+=1;\n            } else {\n                if ((radius-beamB) > Bmost) {Bmost = radius-beamB;}\n                if(height>0.0  && (uv.x<Balls[i].x) ){Bcast = true;BcastDepth=radius-beamB;}\n            }\n\n            }\n        }\n        float lcolAinc = lightA.y/(lightA.x-uv.x);\n        f = smoothstep(0.0, uv.x/40.0, lightAdist);\n        vec3 gacol = mix(gcol,gcol+(lcolA*-lcolAinc*1.2),  f);\n        tlightA = mix(vec3(0.0,0.0,0.0),tlightA,  f);\n        if(Atotal==10){\n            \n            gcol = gacol;\n        }  else {\n            Amost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Amost);\n            gcol = mix(gcol,gacol,  f);\n            if(Acast){\n                f = smoothstep(0.0, 0.01, AcastDepth);\n                tlightA = mix(tlightA,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n        float lcolBinc = lightB.y/(lightB.x-uv.x);\n        f = smoothstep(0.0, (ar-uv.x)/40.0, lightBdist);\n        vec3 gbcol = mix(gcol,gcol+(lcolB*lcolBinc*1.2),  f);\n        tlightB = mix(vec3(0.0,0.0,0.0),tlightB,  f);\n        if(Btotal==10){\n            \n            gcol = gbcol;\n        }  else {\n            Bmost *=100.0;\n            f = smoothstep(0.2 + (dist-radius)*10.0, 0.0, Bmost);\n            gcol = mix(gcol,gbcol,  f);\n            if(Bcast){\n                f = smoothstep(0.0, 0.01, BcastDepth);\n                tlightB = mix(tlightB,vec3(0.0,0.0,0.0),  f);\n            }\n        }\n        \n    vec3 VA = vec3(lightC.x-uv.x, lightC.y, lightC.z-uv.y);\n    vec3 VB = vec3(0.0, 1.0, 0.0);\n    VA = VA/length(VA);\n    float lcolCinc = dot(VB,VA );\n    if(Ctotal==10 ||  dist < (radius-pixel)){    \n        gcol = gcol+(lcolC*lcolCinc*1.2);\n    }  else if(dist > (radius-pixel)) {\n        Cmost *=80.0;\n        f = smoothstep(0.4 + (dist-radius)*5.0, 0.0, Cmost);\n        gcol = mix(gcol, gcol+(lcolC*lcolCinc*1.2), f);\n    }\n\n}\n\n// OLDER SHADER\n\nvec3 colourGround = vec3(0.820,0.820,0.820);\nvec3 colourPaint  = vec3(0.420,0.420,0.420);\nvec3 colourTeamA  = vec3(0.839,0.000,0.000);\nvec3 colourTeamB  = vec3(0.212,0.800,0.000);\nvec3 colourLight = vec3(1.000,1.000,1.000);\nvec3 colourAmbient = vec3(0.188,0.188,0.188);\nvec2 centre;\nfloat radius;\nfloat pixel;\n\nvec2 tanLineDist( in vec2 C, in float r, in vec2 P, in vec2 F){\n    C.y = -C.y;\n    vec2 d = P-C;\n    vec2 dr = vec2(-d.y, d.x);\n    float dl = length(d);\n    //if(dl>=r){\n        float rho = r/dl;\n        float ad = rho*rho;\n        float bd = rho*sqrt(1.0-ad);//*(1.0-rho)); // (1-rho)*(1-rho) ?\n        vec2 T1 = vec2(C.x + ad*d.x + bd*dr.x, C.y + ad*d.y + bd*dr.y);\n        vec2 T2 = vec2(C.x + ad*d.x - bd*dr.x, C.y + ad*d.y - bd*dr.y);\n\n    //}\n    float ax = T1.x-P.x;\n    float by = P.y-T1.y;\n    float c = (T1.y*P.x)-(T1.x*P.y);\n\n    float ax2 = T2.x-P.x;\n    float by2 = P.y-T2.y;\n    float c2 = (T2.y*P.x)-(T2.x*P.y);\n\n    return  vec2((F.x*-ax)- (F.y*-by)-c, (F.x*-ax2)- (F.y*-by2)-c2);\n}\n\nvec3 getGroundTexture( in vec2 p, in float ar , in float pmult)\n{\n    float gpixel = pixel*pmult*1.2;\n    float lineWidth = 1.0/180.0;\n    float f ;\n    vec2 pn = vec2((p.x-(0.5*ar)), p.y-0.5);\n    vec3 gcol = colourGround;\n    \n    float lpn = length(pn);\n    float bdist = sdBox(pn, vec2(ar/2.0, 0.5));\n    if(bdist<=0.0-lineWidth){\n        if(bdist >= -lineWidth*2.0){\n            gcol = colourPaint;\n        }\n        \n        if(lpn>(0.2-gpixel)-lineWidth){\n            if(lpn<0.2){\n                f = smoothstep((0.2-gpixel), .2 , lpn);\n                gcol = mix(colourPaint,colourGround,  f);\n                f = smoothstep(0.2-lineWidth, (0.2-gpixel)-lineWidth , lpn);\n                gcol = mix(gcol,colourGround,  f);\n            }\n        if(abs(pn.x)<=lineWidth/2.0 && lpn>=0.19){\n                gcol = colourPaint;\n            }\n        }\n        \n    }\n    \n    gcol = gcol*colourAmbient;\n    float TAdist = sdBox(vec2(pn.x+(0.5*ar), pn.y), vec2(0.0, 0.15));\n    gcol = gcol*(1.0+(colourTeamA/sqrt(TAdist*50.0)));\n\n    float modRadius = radius;//*(1.0/pow((pn.x+(0.5*ar)), 2.0));\n\n    vec2 isInLight = tanLineDist(centre, modRadius, vec2(ar, -0.65), -p.yx);\n    vec2 isInLight2 = tanLineDist(centre, modRadius, vec2(ar, -0.35), -p.yx);\n    \n    float TBdist = sdBox(vec2(pn.x-(0.5*ar), pn.y), vec2(0.0, 0.15));\n    float inLight= 0.0;\n    \n    if(isInLight.y>=0.0 || isInLight2.y<=0.0){\n        inLight=1.0;} else {\n            inLight= 1.0/(abs(isInLight2.y)/abs(isInLight.y) +1.0);\n        }\n\n    float inLight2= 0.0;\n    \n    if(isInLight.x>=0.0 || isInLight2.x<=0.0){\n        inLight2=1.0;} else {\n            inLight2= 1.0/(abs(isInLight.x)/abs(isInLight2.x) +1.0);\n        } \n\n    if(isInLight.y>=0.0 && isInLight2.x<=0.0){ inLight=0.0;}\n    if(isInLight.y<=0.0 && isInLight2.x>=0.0){ \n        float inLightCross = (inLight+inLight2);\n        inLight=inLight2 = inLightCross;\n\n        \n\n    }\n\n    inLight = min(inLight, inLight2);\n    if(isInLight.y>0.0 && isInLight2.x<=0.0  && (isInLight.x>0.0 || isInLight2.y<0.0)){inLight=1.0;}\n    f = smoothstep(0.0, 1.0,inLight);\n    gcol = mix(gcol,gcol*( 1.0+(colourTeamB/sqrt(TBdist*50.0))),  f);\n\n\n    if(p.x<0.0||p.y<0.0||p.x>1.0*ar||p.y>1.0){gcol = vec3(0.0,0.0,0.0);}\n    gcol = gcol*(2.0+(colourLight/(sqrt(lpn+0.2)/1.2)));\n    //gcol.b *= pn.x*ar;\n    return gcol;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ar = iResolution.x/iResolution.y;\n    float border = 0.1;\n    vec2 guv = uv * (1.0 + border*2.0);\n    guv.x -= border*ar;\n    guv.y -= border;\n    vec3 col = vec3(0.0,0.0,0.0);\n    col = getGroundTexture(guv, ar, 1.0);\n    pixel = 1.0/iResolution.y;\n    \n    radius = 0.06;// + (iMouse.y/iResolution.y)/10.0;\n    \n    vec2 guv2 = guv + pixel;\n    centre = vec2((iMouse.x/iResolution.y),iMouse.y/iResolution.y);\n    centre = centre * (1.0 + border*2.0); centre.x -= border*ar; centre.y -= border;\n    vec2 distv = guv.xy - centre;\n    vec2 distv2 = guv2.xy - centre;\n    float dist = length(distv);\n    float dist2 = length(distv2);\n    float height = sqrt((radius*radius)-(dist*dist));\n    float height2 = sqrt((radius*radius)-(dist2*dist2));\n    vec3 position = vec3(guv.x, height, guv.y);\n    vec3 position2 = vec3(guv2.x, height2, guv2.y);\n    vec3 normal = vec3(distv.x, height, distv.y)/radius;\n    vec3 normal2 = vec3(distv2.x, height2, distv2.y)/radius;\n    vec3 incident = vec3(0.0, -1.0, 0.0);\n    vec3 reflection = reflect(incident, normal);\n    vec3 reflection2 = reflect(incident, normal2);\n    vec3 q = position + reflection * 100.0;\n    vec3 q2 = position2 + reflection2 * 100.0;\n\n    float a = 0.0;\n    float b = -1.0;\n    float c = 0.0;\n    float d = 0.0;\n    bool intersects;\n    bool intersects2;\n    vec3 intersection;\n    vec3 intersection2;\n    float t;\n    float f;\n    vec2 box;\n    vec2 boxposition;\n    float boxdist;\n    float bdist;\n    float tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    if (tDenom < 0.1) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n    }\n    if(dist<radius){\n    col = vec3(0.6,0.6,0.8);\n    box = vec2(0.5*ar,0.5);\n    boxposition = vec2(0.5*ar, 0.5);\n    boxdist = sdBox(boxposition-intersection.xz, box);\n    vec2 intersectionoffset = vec2(boxposition.x - box.x/2.0, boxposition.y - box.y/2.0);\n    bdist = distance(position, intersection);\n    float bdistpix = iResolution.y * bdist;\n    if(intersects){\n        f = smoothstep(-pixel*4.0*sqrt(bdistpix), pixel*4.0*sqrt(bdistpix) , boxdist);\n        \n        vec3 greflection = vec3(reflection.x, 0.0, reflection.z);\n        float gangle = dot(reflection, greflection);\n        vec3 groundcol = getGroundTexture(vec2(intersection.x,intersection.z), ar, 1.5*gangle*(5.0+bdist));//texture(iChannel1, vec2(intersection.x,intersection.z)).rgb;\n        \n        col = mix((groundcol+col)/2.0,col,  f);\n\n       \n    }\n}\n\n    a = 1.0;\n    b = 0.0;\n    c = 0.0;\n    d = ar;\n    tDenom = a*(q.x-position.x) + b*(q.y-position.y) + c*(q.z-position.z);\n    float tDenom2 = a*(q2.x-position2.x) + b*(q2.y-position2.y) + c*(q2.z-position2.z);\n\n    \n    if (tDenom < 0.01) {\n        intersects = false;\n    } else {\n        t = - ( a*position.x + b*position.y + c*position.z - d ) / tDenom;\n        intersects = true;\n        intersection = vec3((position.x+t*(q.x-position.x)),(position.y+t*(q.y-position.y)),(position.z+t*(q.z-position.z)));\n        if (tDenom2 < 0.01) {\n            intersects2 = false;\n        } else {\n            intersects2 = true;\n            t = - ( a*position2.x + b*position2.y + c*position2.z - d ) / tDenom2;\n            intersection2 = vec3((position2.x+t*(q2.x-position2.x)),(position2.y+t*(q2.y-position2.y)),(position2.z+t*(q2.z-position2.z)));\n        }\n    }\n    box = vec2(0.15,0.15);\n    boxposition = vec2(0.15, 0.5);\n    \n    boxdist = sdBox(boxposition-intersection.yz, box);\n    bdist = distance(intersection2, intersection);\n\n\n    if(intersects && boxdist<bdist){\n        f = smoothstep(0.0, bdist , boxdist);\n\n        col = mix((colourTeamB+col),col,  f);\n    }\n\n\n    vec3 ground = getGroundTexture(guv, ar, 1.0);\n\t//Smoothes the edge of the sphere\n\tfloat g = smoothstep(radius-pixel*3.0, radius-pixel, dist);\n\tvec3 fcol = mix( col,ground, g);\n\n    \n    fcol *= fcol;\nfcol = contrast(fcol);\n\n    \n    fragColor = vec4(fcol,1.0);\n}\n*/","name":"Common","description":"","type":"common"}]}