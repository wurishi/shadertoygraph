{"ver":"0.1","info":{"id":"dslyDH","date":"1686826457","viewed":225,"name":"Information Process","username":"altunenes","description":"nice neuron/glial cell view :) I made some basic implementations :)\nnext mission= adding some more robust rapid action potentials? (sequence of changes in the voltage across a branches)\n\nForked from guil","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["learning","neuron"],"hasliked":0,"parentid":"mlBXRK","parentname":"Wet neural network"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//added some fbm + random noise ty  iq for tricks\n\nvec2 random(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n               dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot(random(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot(random(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot(random(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot(random(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(in vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * noise(p);\n        p *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    \n    vec2 n = vec2(0),q;\n    vec2 N = vec2(0);\n    vec2 p = uv + t/20.;\n    float S = 15.;\n    mat2 m = rotate2D(0.5);\n    float branchFactor = 1.78;\n\n    for(float j=0.;j++<40.;){\n      p*=m;\n      n*=m;\n      q=p*S+j+n+t;\n      \n      n += branchFactor * sin(q);\n      N += branchFactor * cos(q)/S*0.8; //1.0 for further implementations\n      branchFactor *=1.3*atan(0.975);\n      \n      S*=1.7*atan(1.975);\n    }\n\n    float pulse = 2.6 * sin(0.5 * 3.14159 * t + fbm(vec2(iTime, length(p)))) + 0.7; // a pulse\n\n    vec3 colorOffset= vec3(3.5 * sin(n.x) + 2.2*fbm(vec2(iTime,n.x)), 0.5 * sin(n.y) + 3.2*fbm(vec2(iTime,n.y)), 2.1 * cos(n.x)); // color offset based on position of branches\n    \n    vec3 flowColorChange = vec3(1.5 * cos(3.0*t + N.x + fbm(vec2(iTime,N.x))), 0.5 * sin(3.0*t + N.y + fbm(vec2(iTime,N.y))), 1.5 * cos(3.0*t + N.y));\n    vec3 flowIntensity = vec3(0.003/length(0.04*N), 1, 1);\n\n    col = (vec3(1.5 * pulse, 1.0 * pulse, 0.1 * pulse) + colorOffset + flowColorChange + flowIntensity) * ((1.0*N.x +1.0*N.y + 0.01)+.001/length(1.0*N + fbm(vec2(iTime, length(N)))));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n/*\nfirst version:\n\nmat2 rotate2D(float r) {\n    return mat2(cos(r), -sin(r), sin(r), cos(r));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    float t = iTime;\n    \n    vec2 n = vec2(0),q;\n    vec2 N = vec2(0);\n    vec2 p = uv + t/20.;\n    float S = 15.;\n    mat2 m = rotate2D(0.5);\n    float branchFactor = 1.78;\n\n    for(float j=0.;j++<40.;){\n      p*=m;\n      n*=m;\n      q=p*S+j+n+t;\n      \n      // Instead of adding to the n and N vectors directly,add some branching factor (for neuron like shapes)\n      n += branchFactor * sin(q);\n      N += branchFactor * cos(q)/S*1.0; //1.0 for further implementations\n      \n      // Every iteration, decrease the branching factor, which is going to result in a more neuron like pattern.\n      branchFactor *=1.3*atan(0.975);\n      \n      S*=1.7*atan(1.975);\n    }\n\n    float pulse = 2.6 * sin(0.5 * 3.14159 * t) + 0.7; // a pulse\n    vec3 colorOffset = vec3(0.5 * sin(n.x), 0.5 * sin(n.y), 2.1 * cos(n.x)); // color offset based on position of branches\n    \n    // For creating synaptic flow colors\n    vec3 flowColorChange = vec3(1.5 * cos(3.0*t + N.x), 0.5 * sin(3.0*t + N.y), 1.5 * cos(3.0*t + N.y));\n    vec3 flowIntensity = vec3(0.003/length(0.04*N), 1, 1);\n\n    //I have to work more with N :)))\n    col = (vec3(1.5 * pulse, 1.0 * pulse, 0.1 * pulse) + colorOffset + flowColorChange + flowIntensity) * ((1.0*N.x +1.0*N.y + 0.01)+.001/length(1.0*N));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n} */","name":"Image","description":"","type":"image"}]}