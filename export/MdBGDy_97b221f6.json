{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float sdCylinder(vec3 p, vec2 h) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\nvec2 rot2(vec2 k, float t) {\n    return vec2(cos(t)*k.x-sin(t)*k.y,sin(t)*k.x+cos(t)*k.y);\n}\n\n/***********************************************/\nfloat smine(float a, float b, float k) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n/***********************************************/\nfloat body(vec3 p) {\n    p.y-=0.05;\n    vec3 q=p;\n    /* main */\n    p+=vec3( -sin(p.x*1.0)*0.4, sin(p.y*4.5)*0.3, 0.1);\n  float m=length(p)-0.55;\n    /* back */\n    q+=vec3( -sin(q.x*1.0)*0.4, 0.10, -0.4);\n    return smine(m,length(q)-0.18, 12.0);\n}\n\nfloat eyesticks(vec3 p) {\n    p+=vec3(-0.2, -0.2, 0.35+sin(p.y));\n  float l=sdCylinder(p, vec2(0.03,0.02));\n    p.x+=0.4;\n    return min(l,sdCylinder(p, vec2(0.03,0.02)));\n}\n\nfloat eyes(vec3 p) {\n    p+=vec3(-0.2, -0.22, 0.57);\n  float l=length(p)-0.03;\n    p.x+=0.4;\n    return min(l,length(p)-0.03);\n}\n\nfloat clamps(vec3 p) {\n    vec3 q=p;\n    p.x-=1.8 + sin(p.z*1.1);\n    p.z=p.z +0.7 + cos(p.z*1.5)*0.1 + sin(p.x)*0.2;\n    p.y=p.y +0.2 + sin(p.y*2.5)*0.2;\n  float b=length(p)-0.3;\n    q.x-=0.7 - sin(q.z*0.7);\n    q.z+=0.15 + sin(q.x)*0.2;\n    q.y+=0.1 + sin(q.y*1.0) - sin(q.z*0.5);\n  float t=length(q)-0.15;\n    q.x-=0.15;\n    q.z-=-0.2+ sin(q.z*0.5)*0.1;\n    q.y+=0.0;\n    return min(min(length(q)-0.2,b),t);\n}\n\nfloat scissors(vec3 p) {\n    p.x-=0.95;\n    p.y+=0.12;\n    p.z+=0.98;\n// p+=vec3(-0.95, 0.12, 0.98);\n\n p.xz=rot2(p.xz, -3.0 ); //rotate outer claw\n    vec3 q=p;\n    p.x+=-0.8+ sin(2.0+p.z*3.8)*0.8;\n    p.y+= sin(p.y*2.5)*0.6;\n    /* inner */\nq.xz=rot2(q.xz, sin(iTime*6.0)*0.25+0.1 );    // rotate inner claw\n    q.x-=0.5+ sin(q.z*5.8)*0.44;\n    q.z+=0.1;\n    q.y+=sin(q.y*3.5)*0.6;\n    return min(length(p)-0.22,length(q)-0.18);\n}\n/* chained leg...  \n  r.z=rotation on z axis,\n  and r.yzw rotate leg joints\n*/\nfloat leg(vec3 p, vec4 r) {\n    p.x+=0.7-r.x;\n    p.y+=0.05;\n    p.z-=r.x;\np.xz=rot2(p.xz, r.x );    \np.xy=rot2(p.xy, -1.57+r.y );\n    p.y-=0.2;\n    float b=sdCylinder(p, vec2(0.03,0.2));\n    p.y-=0.18;\np.xy=rot2(p.xy, -1.57+r.z ); \n    p.y-=0.13;\n    float m=sdCylinder(p, vec2(0.03,0.13));\n    p.y-=0.11;\np.xy=rot2(p.xy, -r.w ); \n    p.y-=0.1;\n    float l=sdCylinder(p, vec2(0.02,0.1)) + sin(p.y)*0.1;\n    return min(min(b,m),l);\n}\n/***********************************************/\nvec2 DE(vec3 p) {\n\n    float f1=sin((iTime)*6.0)*0.2+0.1;\n    float f2=sin((iTime+0.4)*6.0)*0.2+0.1;\n    float f3=sin((iTime)*6.0)*0.6+0.3;\n    float f4=sin((iTime+0.8)*6.0)*0.6+0.3;\n    \n    vec3 q=vec3(-p.x,p.y,p.z);\n\n    float b=min(body(p),eyesticks(p)); \n    float c=min(clamps(p), clamps(q));\n    float d=min( min(leg(p, vec4(0.0,f1+0.1,f2+0.2,f4+0.7)), leg(p, vec4(0.15,f2+0.1,f2+0.2,f3+0.7)) ), leg(p, vec4(0.3,f1+0.1,f2+0.2,f4+0.7)));\n    float g=min( min(leg(q, vec4(0.0,f2+0.1,f1+0.2,f4+0.7)), leg(q, vec4(0.15,f1+0.1,f1+0.2,f2+0.7)) ), leg(q, vec4(0.3,f2+0.1,f1+0.2,f4+0.7)));\n    vec2 m1=vec2(min(b,min(c,min(d,g))),1.0);\n    vec2 m2=vec2(min( eyes(p), min(scissors(p),scissors(q)) ), 2.0);\n     \n//    m1=opU(m1,m2);\n    m1=mix(m1, m2, step(m2.x, m1.x));\n\n    /* floor */\n    m2=vec2( p.y+0.5, 3.0);\n//    m2=vec2( p.y+0.5, 3.0);\n\n//    return opU(m1,m2);\n    return mix(m1, m2, step(m2.x, m1.x));\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n\n/***********************************************/\nvec3 tex3D(vec3 pos, vec3 nor, sampler2D s) {\n\treturn texture( s, pos.yz).xyz*abs(nor.x)+\n\t       texture( s, pos.xz).xyz*abs(nor.y)+\n\t       texture( s, pos.xy).xyz*abs(nor.z);\n}\n\n/***********************************************/\nfloat csh( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k ) {\n    float res = 1.0;\n    float dt = 0.02;\n    float t = mint;\n    for( int i=0; i<7; i++ ) {\n        float h = DE( ro + rd*t ).x;\n        res = min( res, k*h/t );\n        t += max( 0.05, dt );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 2.0, -3.0);\n\tvec3 lig=normalize(vec3(0.0, 3.0, 1.0));\n\n//    ro.xz=rot2(ro.xz, iMouse.x/iResolution.x);\n    ro.xz=rot2(ro.xz, iTime*0.2);\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 2.5*cf );\n\n\tvec3 col=vec3(0.5);\n\t/* march */\n\tvec2 r=vec2(0.0);\t\n\tfloat f=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<60; i++) {\n\t\tww=ro+rd*f;\n\t\tr=DE(ww);\t\t\n\t\tif( r.x<0.0 ) break;\n\t\tf+=r.x*0.5;\n\t}\n\t/* colors */\n\tif( f<30.0 ) {\n\t\tvec3 nor=normal(ww);\n\n\t\tif (r.y==1.0) col=vec3(1.0,0.6,0.3)*tex3D(ww,nor,iChannel0);\n\t\tif (r.y==2.0) col=vec3(0.2);\n\t\tif (r.y==3.0) {\n\t\t                vec3 tmp=vec3(ww.x+iTime*0.8,ww.yz)*0.1;\n\t\t                col=vec3(0.4,0.3,0.3)*tex3D(tmp,nor,iChannel1); \n\t\t              }\n\t\t\n\t\t\tfloat amb =0.2*ww.y;\n\t\t\tfloat dif =0.7*clamp(dot(lig, nor), 0.0,1.0);\n\t\t\tfloat bac =0.2*clamp(dot(nor,-lig), 0.0,1.0);\n\t\t\tfloat sh=csh(ww, lig, 0.05, 1.0, 4.0);\n\t\t\n\t\tcol*=(amb+dif+bac+sh);\n\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdBGDy","date":"1392916790","viewed":996,"name":"Crab II","username":"avix","description":"Version 2 of previous shader. Simplified floor, added shadow and quasi motion...\n","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","animal"],"hasliked":0,"parentid":"","parentname":""}}