{"ver":"0.1","info":{"id":"ssVfWy","date":"1658841968","viewed":126,"name":"Simple raymarching free camera","username":"maze_maze","description":"The controls are\nWASD\nSPACE to go up\nSHIFT to go down","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define read(O) texelFetch(iChannel0, ivec2(O, 0), 0)\nint readInt(int offset) {\n    return bytesToInt(read(offset));\n}\nfloat readFloat(int offset) {\n    return bytesToFloat(read(offset));\n}\n\n\nfloat minDist;\nvec3 nearestColor;\nvec3 nearestNormal;\nvoid sphere(vec3 pos, vec3 spherePos, float radius) {\n    float dist = distance(pos, spherePos) - radius;\n    if (dist < minDist) {\n        minDist = dist;\n    }\n}\nvoid plane(vec3 pos, float height) {\n    float dist = pos.y - height;\n    if (dist < minDist) {\n        minDist = dist;\n    }\n}\nvoid drawSphere(vec3 pos, vec3 spherePos, float radius, vec3 color) {\n    float dist = distance(pos, spherePos) - radius;\n    if (dist < minDist) {\n        minDist = dist;\n        nearestColor = color;\n        nearestNormal = normalize(pos - spherePos);\n    }\n}\nvoid drawPlane(vec3 pos, float height, vec3 color) {\n    float dist = pos.y - height;\n    if (dist < minDist) {\n        minDist = dist;\n        nearestColor = color;\n        nearestNormal = vec3(0, 1, 0);\n    }\n}\n\nconst vec3 sunPos = normalize(vec3(3, 4, 4));\n\nvec3 background(vec3 rayDir) {\n    float sun = pow(dot(rayDir, sunPos) * 0.5 + 0.5, 64.0);\n    if (sun > 0.94) {\n        sun = 1.0;\n    }\n    const vec3 sky = vec3(135.0 / 255.0, 206.0 / 255.0, 235.0 / 255.0);\n    const vec3 sunset = vec3(250.0 / 255.0, 214.0 / 255.0, 165.0 / 255.0);\n    vec3 base = mix(vec3(0), sky, dot(rayDir, sunPos) * 0.5 + 0.5);\n    return mix(mix(sunset, base, clamp(log(rayDir.y + 1.2) / log(1.7), 0.0, 1.0)), vec3(1), sun);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y) * 2.0;\n    \n    vec2 mousePos = vec2(readInt(0), readInt(1));\n\n    float rotX = mousePos.x / 360.0;\n    float rotY = -mousePos.y / 360.0;\n\n    vec3 cameraPos = vec3(readFloat(4), readFloat(5), readFloat(6));\n    vec3 rayDir = normalize(vec3(1.0, uv.y, uv.x)) * rotation3DZ(rotY) * rotation3DY(rotX);\n\n    vec3 rayOrigin = cameraPos;\n    bool hit = false;\n    float t = 0.0;\n    vec3 rayPos;\n    for (; t < 64.0;) {\n        rayPos = rayOrigin + rayDir * t;\n        \n        minDist = 1000000.0;\n        sphere(rayPos, vec3(0.0, 0.0, 2.0), 1.0);\n        plane(rayPos, -1.0);\n        \n        if (minDist < 0.001) {\n            hit = true;\n            break;\n        }\n        t += minDist;\n    }\n\t\n    if (hit) {\n        minDist = 1000000.0;\n        \n        drawSphere(rayPos, vec3(0.0, 0.0, 2.0), 1.0, vec3(0.8, 0.3, 0.1));\n        drawPlane(rayPos, -1.0, vec3(0.3, 0.8, 0.1));\n        \n        vec3 reflected = reflect(rayDir, nearestNormal);\n        \n        float specular = pow(dot(reflected, sunPos) * 0.5 + 0.5, 64.0);\n        \n        float t = 0.1;\n        rayOrigin = rayPos;\n        rayDir = sunPos;\n        \n        float res = 1.0;\n        float ph = 1e20;\n        float k = 4.0;\n        for(; t < 64.0;)\n        {\n            rayPos = rayOrigin + rayDir * t;\n\n            minDist = 1000000.0;\n            sphere(rayPos, vec3(0.0, 0.0, 2.0), 1.0);\n            plane(rayPos, -1.0);\n            \n            if (minDist < 0.001) {\n                res = 0.0;\n                break;\n            }\n            float y = minDist * minDist / (2.0 * ph);\n            float d = sqrt(minDist * minDist - y * y);\n            res = min(res, k * d / max(0.0, t - y));\n            ph = minDist;\n            t += minDist;\n        }\n        \n        float shadow = res * 0.5 + 0.5;\n        specular *= res;\n        \n        fragColor = vec4(mix(nearestColor * max(dot(nearestNormal, sunPos) * 0.8 + 0.2, 0.2), vec3(1), specular) * shadow, 1.0);\n    } else {\n        fragColor = vec4(background(rayDir), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define read(O) texelFetch(iChannel0, ivec2(O, 0), 0)\n#define key(K) texelFetch(iChannel1, ivec2(K, 0), 0).x > 0.5\n\nconst float PI_HALF = 1.57079632679;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_SPACE = 32;\nconst int KEY_SHIFT = 16;\n\nint readInt(int offset) {\n    return bytesToInt(read(offset));\n}\nfloat readFloat(int offset) {\n    return bytesToFloat(read(offset));\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 uv = ivec2(fragCoord);\n    fragColor = vec4(0.0);\n    \n    if (uv.y == 0) {\n        if (iFrame > 1) {\n            ivec2 click = ivec2(abs(iMouse.zw));\n            ivec2 mousePos = ivec2(iMouse.xy);\n            ivec2 lastPos = ivec2(readInt(2), readInt(3));\n\n            vec3 cameraPos = vec3(readFloat(4), readFloat(5), readFloat(6));\n            vec2 cameraRot = vec2(float(readInt(0)) / 360.0, -float(readInt(1)) / 360.0);\n\n            float cameraSpeed = 0.05;\n            if (key(KEY_SPACE)) {\n                cameraPos.y += cameraSpeed;\n            }\n            if (key(KEY_SHIFT)) {\n                cameraPos.y -= cameraSpeed;\n            }\n            if (key(KEY_W)) {\n                cameraPos.x += cos(cameraRot.x) * cameraSpeed;\n                cameraPos.z += sin(cameraRot.x) * cameraSpeed;\n            }\n            if (key(KEY_S)) {\n                cameraPos.x -= cos(cameraRot.x) * cameraSpeed;\n                cameraPos.z -= sin(cameraRot.x) * cameraSpeed;\n            }\n            if (key(KEY_D)) {\n                cameraPos.x += cos(cameraRot.x + PI_HALF) * cameraSpeed;\n                cameraPos.z += sin(cameraRot.x + PI_HALF) * cameraSpeed;\n            }\n            if (key(KEY_A)) {\n                cameraPos.x += cos(cameraRot.x - PI_HALF) * cameraSpeed;\n                cameraPos.z += sin(cameraRot.x - PI_HALF) * cameraSpeed;\n            }\n\n            switch (uv.x) {\n            case 0:\n                if (iMouse.w > 0.0) {\n                    fragColor = read(0);\n                } else {\n                    fragColor = intToBytes(lastPos.x + mousePos.x - click.x);\n                }\n                break;\n            case 1:\n                if (iMouse.w > 0.0) {\n                    fragColor = read(1);\n                } else {\n                    fragColor = intToBytes(lastPos.y + mousePos.y - click.y);\n                }\n                break;\n            case 2:\n                if (iMouse.w > 0.0) {\n                    fragColor = read(0);\n                } else {\n                    fragColor = read(2);\n                }\n                break;\n            case 3:\n                if (iMouse.w > 0.0) {\n                    fragColor = read(1);\n                } else {\n                    fragColor = read(3);\n                }\n                break;\n            case 4:\n                fragColor = floatToBytes(cameraPos.x);\n                break;\n            case 5:\n                fragColor = floatToBytes(cameraPos.y);\n                break;\n            case 6:\n                fragColor = floatToBytes(cameraPos.z);\n                break;\n            }\n        } else {\n            switch (uv.x) {\n            case 0:\n                fragColor = intToBytes(700);\n                break;\n            case 1:\n                fragColor = intToBytes(100);\n                break;\n            case 2:\n                fragColor = intToBytes(700);\n                break;\n            case 3:\n                fragColor = intToBytes(100);\n                break;\n            case 4:\n                fragColor = floatToBytes(2.0);\n                break;\n            case 5:\n                fragColor = floatToBytes(0.0);\n                break;\n            case 6:\n                fragColor = floatToBytes(-1.0);\n                break;\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"vec4 intToBytes(int value) {\n    int byte1 =  value & 0xff;\n    int byte2 = (value >> 8) & 0xff;\n    int byte3 = (value >> 16) & 0xff;\n    int byte4 = (value >> 24) & 0xff;\n    return vec4(float(byte1), float(byte2), float(byte3), float(byte4));\n}\nvec4 floatToBytes(float value) {\n    return intToBytes(floatBitsToInt(value));\n}\nint bytesToInt(vec4 bytes) {\n    int value = int(bytes.x) | int(bytes.y) << 8 | int(bytes.z) << 16 | int(bytes.w) << 24;\n    return value;\n}\nfloat bytesToFloat(vec4 bytes) {\n    return intBitsToFloat(bytesToInt(bytes));\n}\n\nmat3 rotation3DX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n}\nmat3 rotation3DY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\nmat3 rotation3DZ(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n\n    return mat3(\n        c, s, 0.0,\n        -s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}","name":"Common","description":"","type":"common"}]}