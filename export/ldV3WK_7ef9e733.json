{"ver":"0.1","info":{"id":"ldV3WK","date":"1456700790","viewed":163,"name":"bouncing ball shadows test","username":"Exactimum","description":"phyics test","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\n#define NSoftRays 10\n#define ShadowRad 0.02\n\nstruct Ray { \n    vec3 o; \n    vec3 d;\n};\n\nstruct Sphere {\n\tvec3 c;\n\tfloat r;\n};\n\nvec3 theEye = vec3(0., 0., -1);\n\nSphere theSphere = Sphere(vec3(2.0, 0.0, 3.0), 1.0);\n\nvec3 litePos = vec3(0., 0., 1.);\n\nvec4 diffuse(vec3 surface, vec3 center, vec4 color, vec3 litePos) {\n\tvec3 n = normalize(surface - center);\n\tvec3 l = normalize(litePos - surface);\n\treturn color * max(0.0, dot(n, l));\n}\n\nfloat intersectSphere(Ray ray, Sphere sphere) {\n\tvec3 co = ray.o - sphere.c;\n\tfloat discriminant = dot(co, ray.d) * dot(co, ray.d)\n\t\t\t- (dot(co, co) - sphere.r * sphere.r);\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.d, co) - sqrt(discriminant); //\n\telse\n\t\treturn -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = (iTime - floor(iTime))/1.;\n    theSphere.c.z = 5.9-16.*t*(1.-t);\n\tfloat widthInPixels = iResolution.x;\n\tfloat heightInPixel = iResolution.y;\n\tvec4 viewCoord = vec4(fragCoord,0.,1.);\n\tfloat x = viewCoord.x / widthInPixels;\n\tfloat y = viewCoord.y / heightInPixel;\n\tfloat z = viewCoord.z;\n\tfloat posPixelX = x * 2.0 - 1.0;\n\tfloat posPixelY = y * 2.0 - 1.0;\n\tfloat posPixelZ = z * 2.0 - 1.0;\n\tposPixelX *= (widthInPixels / heightInPixel);\n\tvec3 posPixel = vec3(posPixelX, posPixelY, 0);\n\tvec3 eye2Pixel = posPixel - theEye;\n\tvec3 theRay = normalize(eye2Pixel);\n\tfloat eyeToSphere = intersectSphere(Ray(theEye, theRay), theSphere);\n    litePos.xy = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    litePos.x *= (widthInPixels / heightInPixel);\n    float wallZ = 7.0;\n    float mirrorX = -0.5;\n\tif (eyeToSphere < 0.) {\n        float mirrorDist = mirrorX / theRay.x;\n        float wallDist = wallZ / theRay.z;\n        if (mirrorDist > wallDist) {\n            vec3 wallIntersect = theRay*wallZ;\n\n            vec4 texel = texture(iChannel0, 0.3*posPixel.xy);\n\n            vec3 wallLight = litePos - wallIntersect;\n\n\n            vec4 totColor = vec4(0.0);\n\n            //cast rays in a circle around the correct direction\n            //average the results to find the final color\n            for (int i = 0; i < NSoftRays; i++) {\n                float angle = float(i) * 2.0 * M_PI / float(NSoftRays);\n                wallLight.x += ShadowRad*cos(angle);\n                wallLight.y += ShadowRad*sin(angle);\n\n                float wallSphere = intersectSphere(Ray(wallIntersect, \n                                                       normalize(wallLight)), \n                                                   theSphere);\n\n                float brightness = (2.5-3.*length(wallLight)/10.);\n\n                if (wallSphere < 0.) {\n                    totColor += texel*brightness;\n                } else {\n                    totColor += texel*brightness*0.5;\n                }\n            }\n\n            fragColor = totColor / float(NSoftRays);\n        } else {\n            fragColor = vec4(1.);\n        }\n        \n    } else {\n\t\tvec4 diffuseColor =  vec4(1.,1.,1.,1);\n\t\tvec4 sShadeColor =\n\t\t\tfragColor = \n            diffuse(theEye + eyeToSphere * theRay, \n                    theSphere.c, diffuseColor, litePos);\n\n    }\n}","name":"Image","description":"","type":"image"}]}