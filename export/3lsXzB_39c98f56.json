{"ver":"0.1","info":{"id":"3lsXzB","date":"1563424681","viewed":820,"name":"3D Platformer Concept (playable)","username":"agordeevw","description":"Made 3D camera keyboard controls, added thing, added another thing, got this.\nUnfortunately, collisions are a bit wonky, be wary.\nWith PBR from another shader, hehe.\n\nControls:\nWASD or arrow keys - move\nIJKL - look around\nSpace or E - jump","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["notquiteagame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Player LoadPlayer()\n{\n\tvec3 position = texelFetch(iChannel0, globalOffset_Player, 0).xyz;\n    vec2 angles = texelFetch(iChannel0, globalOffset_Player + ivec2(1, 0), 0).xy;\n    vec3 velocity = texelFetch(iChannel0, globalOffset_Player + ivec2(2, 0), 0).xyz;\n    Player player;\n    player.position = position;\n    player.vAngle = angles.x;\n    player.hAngle = angles.y;\n    player.velocity = velocity;\n    return player;\n}\n    \nconst float CAMERA_FOV = PI * 0.333;\n\nstruct Camera\n{\n    vec3 position;\n    vec3 right;\n    vec3 up;\n};\n\nCamera CameraFromPlayer(Player player)\n{\n\tCamera ret;\n    ret.position = player.position + vec3(0.0, PLAYER_HEIGHT, 0.0);\n    ret.right = vec3(\n            cos(player.hAngle),\n            0.0,\n        \tsin(player.hAngle));\n    ret.up = vec3(\n    \t-sin(player.vAngle) * sin(player.hAngle),\n        cos(player.vAngle),\n        sin(player.vAngle) * cos(player.hAngle));\n    return ret;\n}\n\nRay CameraRay(vec2 fragCoord, Camera camera)\n{\n    vec2 fragPos = fragCoord / iResolution.xy;\n    fragPos = 2.0 * (fragPos - 0.5);\n    float aspectRatio = iResolution.x / iResolution.y;\n    float halfHeight = tan(CAMERA_FOV * 0.5f);\n    vec3 dir =\n        + camera.right * fragPos.x * halfHeight * aspectRatio\n        + camera.up * fragPos.y * halfHeight\n        + cross(camera.up, camera.right);\n\n    Ray ret;\n    ret.o = camera.position;\n    ret.d = normalize(dir);\n    return ret;\n}\n\nvec3 SamplePrefilteredEnvMap(float roughness, vec3 dir)\n{\n\tint level = int(floor(roughness * float(ROUGHNESS_LEVELS)));\n    level = (level == ROUGHNESS_LEVELS) ? ROUGHNESS_LEVELS - 1 : level;\n    int nextLevel = (level == ROUGHNESS_LEVELS - 1) ? level : level + 1;\n\tvec2 uv = SampleEquirectangular(dir);\n    float levelWidth = 1.0 / float(ROUGHNESS_LEVELS);\n    vec2 levelUV = vec2((uv.x + float(level)) * levelWidth, uv.y);\n    vec2 nextLevelUV = vec2(levelUV.x + levelWidth, uv.y);\n    float mixFactor = fract(roughness * float(ROUGHNESS_LEVELS));\n    return mix(textureLod(iChannel3, levelUV, 0.0).rgb,\n              textureLod(iChannel3, nextLevelUV, 0.0).rgb,\n              mixFactor);\n}\n\nvec3 ApproximateSpecularIBL(float roughness, vec3 f0, vec3 n, vec3 v)\n{\n\tfloat NoV = max(0.0, dot(n, v));\n    vec3 r = 2.0 * dot(v, n) * n - v;\n    \n    vec3 F = F_Schlick(NoV, f0, roughness);\n    vec2 envBRDF = textureLod(iChannel1, vec2(NoV, roughness), 0.0).xy;\n    return SamplePrefilteredEnvMap(roughness, r) * (F * envBRDF.x + envBRDF.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tfloat timeSinceSpawn = texelFetch(iChannel0, globalOffset_TimeSinceSpawn, 0).x;\n    \n    Player player = LoadPlayer();\n    Camera camera = CameraFromPlayer(player);\n    Ray ray = CameraRay(fragCoord, camera);\n    RaycastInfo raycast = Raycast(ray, timeSinceSpawn);\n    \n    // DEBUG: visualize intermediate buffers\n    //fragColor = texture(iChannel3, fragCoord / iResolution.xy);\n    //return;\n   \n    vec3 color = vec3(0.0);\n    if (raycast.hit)\n    {\n        vec3 p = raycast.point;\n        vec3 view = normalize(player.position + vec3(0.0, PLAYER_HEIGHT, 0.0) - p);\n        vec3 normal = Gradient(p, timeSinceSpawn);\n        float NoV = max(dot(normal, view), 0.0);\n        \n        float metallic;\n        float roughness;\n        vec3 albedo;\n        vec3 f0;\n        vec3 emissive;\n        switch (raycast.id)\n        {\n            case 0:\n            {\n                albedo = vec3(1.0, 0.7, 0.4);\n                metallic = 0.0;\n                roughness = 0.5;\n                f0 = vec3(0.04, 0.04, 0.04);\n                emissive = vec3(0.0);\n            }\n            break;\n            case 1:\n            {\n                albedo = vec3(0.8, 0.7, 0.7);\n                metallic = 1.0;\n                roughness = 0.0;\n                f0 = vec3(0.9, 0.9, 0.9);\n                emissive = vec3(0.675 + 0.125 * sin(4.0 * timeSinceSpawn));\n            }\n            break;\n        }\n        \n        vec3 F = F_Schlick(NoV, f0, roughness);\n        vec3 kSpecular = F;\n        vec3 kDiffuse = (1.0 - metallic) * (1.0 - kSpecular);\n        vec3 lightL0 = vec3(0.0);\n        {\n            RaycastInfo shadowRay = Raycast(Ray(p, lightDir), timeSinceSpawn);\n            if (!shadowRay.hit)\n            {\n                vec3 l = lightDir;\n                vec3 h = normalize(view + l);\n                vec3 radiance = vec3(1.0);\n                float NoL = max(dot(normal, l), 0.0);\n\n                float NDF = D_GGX(max(dot(normal, h), 0.0), roughness);\n                float G = G_SmithDirect(roughness, NoL, NoV);\n                vec3 nominator = NDF * F * G;\n                float denominator = 4.0 * NoV * NoL + 0.001;\n                vec3 specular = nominator / denominator;\n\n                lightL0 += (kDiffuse * albedo * INV_PI + specular) * radiance * NoL;\n            }\n        }\n        \n        vec3 irradiance = textureLod(iChannel2, SampleEquirectangular(normal), 0.0).rgb;\n        vec3 ambient = kDiffuse * albedo * irradiance\n            + ApproximateSpecularIBL(roughness, mix(f0, albedo, metallic), normal, view);\n        color = emissive + ambient + lightL0;\n    }\n    else\n    {\n        color = Skybox(ray.d);\n    }\n    \n    color = mix(vec3(1.0),\n                mix(vec3(0.0), color, clamp((player.position.y + 7.5) / 4.5, 0.0, 1.0)),\n                clamp((player.position.y + 10.0) / 2.5, 0.0, 1.0));\n    \n    fragColor = vec4(mix(vec3(1.0), color, clamp(0.75 * timeSinceSpawn, 0.0, 1.0)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\nconst float INV_PI = 0.31830988618;\nconst float INIT_TIME = 1.0;\n\nstruct Player\n{\n\tvec3 position;\n    float vAngle;\n    float hAngle;\n    vec3 velocity;\n};\n\n// Camera offset relative to player position + used for collisions\nconst float PLAYER_HEIGHT = 1.0;\nconst float AIR_MOVEMENT_FORCE_MULTIPLIER = 0.125;\nconst float MOVEMENT_FORCE = 50.0;\nconst float GRAVITY_FORCE = 9.8;\nconst float JUMP_VELOCITY = 10.0;\nconst float STATIC_FRICTION = 0.5;\nconst float MOVING_FRICTION = 0.0;\nconst float MAX_VELOCITY = 5.0;\n\n// Layout of variables in texture\nconst ivec2 globalOffset_Player = ivec2(16, 0);\nconst int sizeof_Player = 3; // number of vec4's needed\n\nconst ivec2 globalOffset_Time = ivec2(0, 0);\nconst ivec2 globalOffset_TimeSinceSpawn = ivec2(1, 0);\nconst ivec2 globalOffset_IsSpawningFlag = ivec2(0, 1);\n\n// Scene\nconst vec3 lightDir = normalize(vec3(0.7, 0.5, 1.0));\n\nstruct SDFOut\n{\n    float value;\n    int id;\n};\n\nfloat SphereSDF(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat CylinderSDF(vec3 p, float h, float r)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nSDFOut UnionSDF(SDFOut lhs, SDFOut rhs)\n{\n    if (lhs.value < rhs.value)\n        return lhs;\n    else\n        return rhs;\n}\n\nconst vec3 SpherePosition = vec3(0.0, 6.0, 0.0);\nconst float SphereRadius = 2.5;\n\nSDFOut SceneSDF(vec3 p, float time)\n{\n    SDFOut p1 = SDFOut(CylinderSDF(p - vec3(0.0, -2.0, 0.0), 1.5, 0.25), 0);\n    SDFOut p2 = SDFOut(CylinderSDF(p - vec3(4.0, -1.5, 0.0), 1.5, 0.25), 0);\n    SDFOut p3 = SDFOut(CylinderSDF(p - vec3(8.0, -1.0, 0.0), 1.5, 0.25), 0);\n    SDFOut p4 = SDFOut(CylinderSDF(p - vec3(10.0, -0.5, 4.0), 1.5, 0.25), 0);\n    SDFOut p5 = SDFOut(CylinderSDF(p - vec3(10.0, -0.5, -4.0), 1.5, 0.25), 0);\n    SDFOut p6 = SDFOut(CylinderSDF(p - vec3(14.0, 0.0, 5.0), 1.5, 0.25), 0);\n    SDFOut p7 = SDFOut(CylinderSDF(p - vec3(14.0, 0.0, -5.0), 1.5, 0.25), 0);\n    SDFOut p8 = SDFOut(CylinderSDF(p - vec3(18.0, 0.0, 3.0), 1.5, 0.25), 0);\n    SDFOut p9 = SDFOut(CylinderSDF(p - vec3(18.0, 0.0, -3.0), 1.5, 0.25), 0);\n    float p10y = 0.5 + 2.0 * 0.5 * (1.0 + sin(0.5 * time));\n    SDFOut p10 = SDFOut(CylinderSDF(p - vec3(21.0, p10y, 0.0), 1.5, 0.25), 0);\n    SDFOut p11 = SDFOut(CylinderSDF(p - vec3(18.0, 3.0, 0.0), 1.5, 0.25), 0);\n    float p12y = 3.25 + 0.25 * sin(time);\n    SDFOut p12 = SDFOut(CylinderSDF(p - vec3(14.0, p12y, 0.0), 1.5, 0.25), 0);\n    \n    vec3 rotatedP13 = p - vec3(10.0, 4.0, 0.0);\n    float angle = PI * 0.125 * 0.25;\n    vec3 c1 = vec3(cos(angle), sin(angle), 0.0);\n    vec3 c2 = vec3(-sin(angle), cos(angle), 0.0);\n    vec3 c3 = vec3(0.0, 0.0, 1.0);\n    rotatedP13 = c1 * rotatedP13.x + c2 * rotatedP13.y + c3 * rotatedP13.z;\n    SDFOut p13 = SDFOut(CylinderSDF(rotatedP13, 1.5, 0.25), 0);\n    \n    vec3 rotatedP14 = p - vec3(6.0, 5.0, 0.0);\n    angle = 2.0 * angle;\n    c1 = vec3(cos(angle), sin(angle), 0.0);\n    c2 = vec3(-sin(angle), cos(angle), 0.0);\n    c3 = vec3(0.0, 0.0, 1.0);\n    rotatedP14 = c1 * rotatedP14.x + c2 * rotatedP14.y + c3 * rotatedP14.z;\n\tSDFOut p14 = SDFOut(CylinderSDF(rotatedP14, 1.5, 0.25), 0);\n    \n    SDFOut s = SDFOut(SphereSDF(p - SpherePosition, SphereRadius), 1);\n    \n    // to test slopes\n    //return SDFOut(dot(p, normalize(vec3(0.0, 1.0, 2.0))), 0);\n    \n    return UnionSDF(UnionSDF(UnionSDF(UnionSDF(UnionSDF(UnionSDF(UnionSDF(UnionSDF(UnionSDF(\n        UnionSDF(UnionSDF(UnionSDF(UnionSDF(UnionSDF(\n        p1, p2), p3), p4), p5), p6), p7), p8), p9), p10), p11), p12), p13), p14), s);\n}\n\nvec3 Gradient(vec3 p, float time)\n{    \n  const float pr = 1.e-2;\n  const vec3 dx = vec3(pr, 0.0, 0.0);\n  const vec3 dy = vec3(0.0, pr, 0.0);\n  const vec3 dz = vec3(0.0, 0.0, pr);\n  return normalize(vec3(\n    SceneSDF(p + dx, time).value - SceneSDF(p - dx, time).value,\n    SceneSDF(p + dy, time).value - SceneSDF(p - dy, time).value,\n    SceneSDF(p + dz, time).value - SceneSDF(p - dz, time).value));\n}\n\n// Raymarching\n\nstruct Ray\n{\n    vec3 o, d;\n};\n\nstruct RaycastInfo\n{\n    bool hit;\n    vec3 point;\n    int id;\n};\n\nRaycastInfo Raycast(Ray ray, float time)\n{\n    const float minRayLength      = 0.01f;\n    const float maxRayLength      = 128.0f;\n    const uint  maxStep           = 128u;\n    const float raycastPrecision  = 0.5f * 1.e-3f;\n    const float stepSize = (maxRayLength - minRayLength) / float(maxStep);\n\n    float rayLength = minRayLength;\n    vec3 p = ray.o + ray.d * rayLength;\n\n    for (uint i = 0u; i < maxStep; ++i)\n    {\n        SDFOut sdfOut = SceneSDF(p, time);\n\n        if (sdfOut.value <= raycastPrecision)\n            return RaycastInfo(true, p, sdfOut.id);\n\n        // Fixed step\n        //p += stepSize * ray.d;\n        //rayLength += stepSize;\n        // SDF-dependent step\n        p += sdfOut.value * ray.d;\n        rayLength += sdfOut.value;\n\n        if (rayLength > maxRayLength)\n            return RaycastInfo(false, p, -1);\n    }\n}\n\n// Rendering\n\n#define ROUGHNESS_LEVELS 5\n\nvec2 SampleEquirectangular(vec3 dir)\n{\n    vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));\n    uv += vec2(PI, PI * 0.5);\n    uv *= vec2(0.5 * INV_PI, INV_PI);\n    return uv;\n}\n\nvec3 Skybox(vec3 dir)\n{    \n\treturn mix(vec3(0.0, 0.0, 0.0), vec3(0.6, 0.8, 1.0), 0.3 + 0.7 * dir.y)\n        \t+ vec3(1.0, 1.0, 1.0) * pow(max(dot(dir, lightDir), 0.0), 32.0);\n}\n\nvec3 F_Schlick(float NoV, vec3 F0, float roughness)\n{\n\treturn F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - NoV, 5.0);\n}\n\nfloat D_GGX(float NoH, float roughness)\n{\n\tfloat a = roughness * roughness;\n    float a2 = a * a;\n    float nom = a2;\n    float denom = (NoH * NoH * (a2 - 1.0) + 1.0);\n\tdenom = PI * denom * denom;\n    \n    return nom / denom;\n}\n\nfloat G_SmithIBL(float roughness, float NoL, float NoV)\n{\n\tfloat k = roughness * roughness * 0.5;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nfloat G_SmithDirect(float roughness, float NoL, float NoV)\n{\n\tfloat k = (roughness + 1.0) * (roughness + 1.0) * 0.125;\n    return (NoL * NoV) / ((k + NoV * (1.0 - k)) * (k + NoL * (1.0 - k)));\n}\n\nvec3 ImportanceSampleGGX(vec2 Xi, float roughness, vec3 n)\n{\n\tfloat a = roughness * roughness;\n    float phi = 2.0 * PI * Xi.x;\n\tfloat cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    \n    vec3 h;\n    h.x = sinTheta * cos(phi);\n    h.y = sinTheta * sin(phi);\n    h.z = cosTheta;\n    \n    vec3 up = abs(n.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);\n    vec3 tangentX = normalize(cross(up, n));\n    vec3 tangentY = cross(n, tangentX);\n    return tangentX * h.x + tangentY * h.y + n * h.z;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    uint bits = i;\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    float inv = float(bits) * 2.3283064365386963e-10;\n\treturn vec2(float(i)/float(N), inv);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KeyPressed(ascii) (texelFetch(iChannel3, ivec2(ascii, 0), 0).x != 0.0)\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_S = 83;\nconst int KEY_D = 68;\nconst int KEY_I = 73;\nconst int KEY_K = 75;\nconst int KEY_J = 74;\nconst int KEY_L = 76;\nconst int KEY_E = 69;\nconst int KEY_LEFT_ARROW = 37;\nconst int KEY_UP_ARROW = 38;\nconst int KEY_RIGHT_ARROW = 39;\nconst int KEY_DOWN_ARROW = 40;\nconst int KEY_SPACE = 32;\nconst int KEY_COMMA = 188;\n\nbool ButtonForward()\n{\n\treturn KeyPressed(KEY_W) || KeyPressed(KEY_UP_ARROW);\n}\n\nbool ButtonBackward()\n{\n\treturn KeyPressed(KEY_S) || KeyPressed(KEY_DOWN_ARROW);\n}\n\nbool ButtonStrafeLeft()\n{\n\treturn KeyPressed(KEY_A) || KeyPressed(KEY_LEFT_ARROW);\n}\n\nbool ButtonStrafeRight()\n{\n\treturn KeyPressed(KEY_D) || KeyPressed(KEY_RIGHT_ARROW);\n}\n\nbool ButtonLookUp()\n{\n\treturn KeyPressed(KEY_I);\n}\n\nbool ButtonLookDown()\n{\n\treturn KeyPressed(KEY_K);\n}\n\nbool ButtonLookLeft()\n{\n\treturn KeyPressed(KEY_J);\n}\n\nbool ButtonLookRight()\n{\n\treturn KeyPressed(KEY_L) || KeyPressed(KEY_COMMA);\n}\n\nbool ButtonJump()\n{\n\treturn KeyPressed(KEY_SPACE) || KeyPressed(KEY_E);\n}\n\n#define GetBufferData(offset) (texelFetch(iChannel0, offset, 0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Global time counter\n    if (ivec2(fragCoord) == globalOffset_Time)\n    {\n        fragColor = vec4(iTime);\n        return;\n    }\n    \n    // Timestep between frames\n    float dt = 0.0;\n    {\n        float prevTime = GetBufferData(globalOffset_Time).x;\n        dt = iTime - prevTime;\n    }\n    \n    // Time since spawn\n    if (ivec2(fragCoord) == globalOffset_TimeSinceSpawn)\n    {\n        float isSpawning = GetBufferData(globalOffset_IsSpawningFlag).x;\n        if (isSpawning > 0.0)\n        {\n        \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            return;\n        }\n        float prevTime = GetBufferData(globalOffset_TimeSinceSpawn).x;\n    \tfragColor = vec4(prevTime + dt, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    // Spawning flag\n    if (ivec2(fragCoord) == globalOffset_IsSpawningFlag)\n    {\n        vec3 position = GetBufferData(globalOffset_Player).xyz;\n        fragColor = vec4(\n            iTime < INIT_TIME // Starting game\n            || position.y < -10.0 // Fallen out of bounds\n            || length(position - SpherePosition) < SphereRadius + 0.25 // Close to sphere\n                         ? 1.0 : 0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    float timeSinceSpawn = GetBufferData(globalOffset_TimeSinceSpawn).x;\n    \n    // Player update\n    if (ivec2(fragCoord).y == globalOffset_Player.y\n        && ivec2(fragCoord).x >= globalOffset_Player.x\n        && ivec2(fragCoord).x < globalOffset_Player.x + sizeof_Player)\n    {\n        // Spawn\n        if (GetBufferData(globalOffset_IsSpawningFlag).x > 0.0)\n        {\n            vec3 position = vec3(0.0, 0.0, 0.0);\n            float vAngle = 0.0;\n            float hAngle = PI * 0.5;\n            vec3 velocity = vec3(0.0, 0.0, 0.0);\n            \n            if (ivec2(fragCoord).x == globalOffset_Player.x + 0)\n            {\n                fragColor = vec4(position, 0.0);\n            }\n            if (ivec2(fragCoord).x == globalOffset_Player.x + 1)\n            {\n                fragColor = vec4(vAngle, hAngle, 0.0, 0.0);\n            }\n            if (ivec2(fragCoord).x == globalOffset_Player.x + 2)\n            {\n                fragColor = vec4(velocity, 0.0);\n            }\n            return;\n        }\n        \n        // Load player data\n        vec3 position = GetBufferData(globalOffset_Player).xyz;\n        vec2 angles = GetBufferData(globalOffset_Player + ivec2(1, 0)).xy;\n        vec3 velocity = GetBufferData(globalOffset_Player + ivec2(2, 0)).xyz;\n        \n        // Rotate around right axis\n        bool lookingUp = ButtonLookUp();\n        bool lookingDown = ButtonLookDown();\n        if (lookingUp || lookingDown)\n        {\n            float angle = 0.5 * PI * dt;\n            angle = lookingUp ? angle : -angle;\n            angles.x = clamp(angles.x + angle, -PI * 0.4 + 0.01, PI * 0.4 - 0.01);\n        }\n        \n        // Rotate around up axis\n        bool lookingLeft = ButtonLookLeft();\n        bool lookingRight = ButtonLookRight();\n        if (lookingLeft || lookingRight)\n        {\n            float angle = PI * dt;\n            angle = lookingLeft ? -angle : angle;\n            angles.y = angles.y + angle;\n        }\n        \n        vec3 right = vec3(cos(angles.y), 0.0, sin(angles.y));\n        vec3 up = vec3(0.0, 1.0, 0.0);\n        vec3 forward = cross(up, right);\n        \n        // Distance to ground, used to check for ground collisions\n        Ray rayToGround = Ray(position, vec3(0.0, -1.0, 0.0));\n        RaycastInfo raycastToGround = Raycast(rayToGround, timeSinceSpawn);\n        float groundDistance = position.y - raycastToGround.point.y;\n        const float MIN_GROUND_DISTANCE = 1.e-1;\n        float forceMul = groundDistance < MIN_GROUND_DISTANCE\n            ? 1.0 : AIR_MOVEMENT_FORCE_MULTIPLIER;\n        \n        // Linear movement\n        bool isMoving = false;\n        {\n            vec3 movementForceDir = vec3(0.0);\n            if (ButtonForward())\n            {\n                movementForceDir += forward;\n            }\n            if (ButtonBackward())\n            {\n                movementForceDir -= forward;\n            }\n            if (ButtonStrafeLeft())\n            {\n                movementForceDir -= right;\n            }\n            if (ButtonStrafeRight())\n            {\n                movementForceDir += right;\n            }\n            if (length(movementForceDir) > 0.0)\n            {\n                velocity += normalize(movementForceDir) * MOVEMENT_FORCE * forceMul * dt;\n                isMoving = true;\n            }\n        }\n        \n        // Head bonk if jumping into ceiling\n        {\n            Ray rayToCeil = Ray(position + vec3(0.0, PLAYER_HEIGHT, 0.0), vec3(0.0, 1.0, 0.0));\n            RaycastInfo raycastToCeil = Raycast(rayToCeil, timeSinceSpawn);\n            float ceilDistance = raycastToCeil.point.y - position.y - PLAYER_HEIGHT;\n            \n\t\t\tif (ceilDistance < MIN_GROUND_DISTANCE)\n\t\t\t{\n                // BONK\n                velocity.y = 0.0;\n            }\n        }\n        \n        // Ground collision\n        if (groundDistance < MIN_GROUND_DISTANCE)\n        {\n            // Moving ground can push player up\n            RaycastInfo raycastToGroundPrevFrame = Raycast(rayToGround, max(timeSinceSpawn - dt, 0.0));\n            float groundDistancePrevFrame = position.y - raycastToGroundPrevFrame.point.y;\n            if (groundDistancePrevFrame > groundDistance)\n            {\n                position.y += groundDistancePrevFrame - groundDistance;\n            }\n\n            // Don't allow to fall through\n            velocity.y = 0.0;\n\n            // Allow to jump if close to ground\n            if (ButtonJump())\n            {\n                velocity.y += JUMP_VELOCITY;\n            }\n        }\n       \t\n        // Gravity when not touching ground\n        if (groundDistance >= MIN_GROUND_DISTANCE)\n        {\n            velocity.y -= GRAVITY_FORCE * dt;\n            isMoving = true;\n        }\n        \n        // Collision in xz-plane\n        // Probing several directions from player at several height levels.\n        // If scene is too close in some direction,\n        // velocity component parallel to direction is removed\n        // to prevent movement into surface.\n        // Code is a bit wonky...\n        {\n            const int numHeightLevels = 4;\n            const int numDirections = 16;\n            \n            const float MIN_COLLISION_DISTANCE = 1.e-1;\n            for (int h = 0; h < numHeightLevels; h++)\n            {\n                for (int i = 0; i < numDirections; i++)\n                {\n                    // Sample direction in circle around the player\n                    Ray ray;\n                    // Sampling lowest level from slightly above that player's feet\n                    // to handle slopes\n                    const float PLAYER_POSITION_OFFSET = 0.01;\n                    ray.o = position;\n                    ray.o.y += PLAYER_POSITION_OFFSET + (PLAYER_HEIGHT - PLAYER_POSITION_OFFSET)\n                        * float(h) / float(numHeightLevels - 1);\n                    float angle = 2.0 * PI * float(i) / float(numDirections);\n                    ray.d = vec3(cos(angle), 0.0, sin(angle));\n\n                    RaycastInfo raycast = Raycast(ray, timeSinceSpawn);\n                    float dist = length(raycast.point - ray.o);\n                    if (h != 0)\n                    {\n                        // Levels above player foot level\n                        if (raycast.hit && dist < MIN_COLLISION_DISTANCE)\n                        {\n                            velocity -= dot(velocity, ray.d) * ray.d;\n                            // Position offset adjustment works bad in some situations, investigate\n                            position -= ray.d * min(dist, 0.25 * MIN_COLLISION_DISTANCE);\n                        }\n                    }\n                    else\n                    {\n                        // Foot level, handle slopes\n                        // TODO: handle descending slopes\n                        if (raycast.hit && dist < MIN_COLLISION_DISTANCE)\n                        {\n                            /*\n                            // point at slope in probed direction\n                            float slopeHeight = PLAYER_POSITION_OFFSET;\n                            float slopeDist = dist;\n                            float slopeAngle = atan(slopeHeight, slopeDist);\n\n                            const float MAX_SLOPE_ANGLE = PI * 0.25;\n                            if (slopeAngle > MAX_SLOPE_ANGLE)\n                            {\n                            \tvelocity -= dot(velocity, ray.d) * ray.d;\n                            }\n                            else\n\t\t\t\t\t\t\t*/\n                            {\n                                // Prevent going into surface\n                                vec3 normal = Gradient(raycast.point, timeSinceSpawn);\n                                velocity += max(dot(velocity, -normal), 0.0) * normal;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Friction\n        {\n            float velocityLength = length(velocity);\n            if (velocityLength > 0.0)\n            {\n                float friction = isMoving ? MOVING_FRICTION : STATIC_FRICTION;\n                velocityLength = clamp(velocityLength - friction, 0.0, MAX_VELOCITY);\n                velocity = normalize(velocity) * velocityLength;\n            }\n        }\n        \n        // Update position\n        position += velocity * dt;\n        \n        // Store player data\n        if (ivec2(fragCoord).x - globalOffset_Player.x == 0)\n        {\n        \tfragColor = vec4(position, 0.0);\n        }\n        if (ivec2(fragCoord).x - globalOffset_Player.x == 1)\n        {\n        \tfragColor = vec4(angles.xy, 0.0, 0.0);\n        }\n        if (ivec2(fragCoord).x - globalOffset_Player.x == 2)\n        {\n        \tfragColor = vec4(velocity, 0.0);\n        }\n        return;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 IntegrateBRDF(float roughness, float NoV)\n{\n\tvec3 v;\n    v.x = sqrt(1.0 - NoV * NoV);\n    v.y = 0.0;\n    v.z = NoV;\n    \n    float A = 0.0;\n    float B = 0.0;\n    \n    vec3 n = vec3(0.0, 0.0, 1.0);\n    \n    const uint numSamples = 1024u;\n    for (uint i = 0u; i < numSamples; i++)\n    {\n    \tvec2 Xi = Hammersley(i, numSamples);\n        vec3 h = ImportanceSampleGGX(Xi, roughness, n);\n        vec3 l = 2.0 * dot(v, h) * h - v;\n        \n        float NoL = clamp(l.z, 0.0, 1.0);\n        float NoH = clamp(h.z, 0.0, 1.0);\n        float VoH = clamp(dot(v, h), 0.0, 1.0);\n        \n        if (NoL > 0.0)\n        {\n            float G = G_SmithIBL(roughness, NoL, NoV);\n            float G_Vis = G * VoH / (NoH * NoV);\n            float Fc = pow(1.0 - VoH, 5.0);\n            A += (1.0 - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    \n    return vec2(A, B) / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\tif (iTime > INIT_TIME)\n    {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \treturn;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    float NoV = uv.x;\n    float roughness = uv.y;\n    fragColor = vec4(IntegrateBRDF(roughness, NoV).xy, 0.0, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 IrradianceMap(vec3 normal)\n{\n    vec3 up = abs(normal.y) < 0.9999 ? vec3(0.0, 1.0, 0.0) : vec3(1.0, 0.0, 0.0);\n    //vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, normal);\n    up = cross(normal, right);\n    \n    uint numSamples = 0u;\n    vec3 irradiance = vec3(0.0, 0.0, 0.0);\n    const float stepD = 0.025;\n\tfor (float phi = 0.0; phi < 2.0 * PI; phi += stepD)\n    {\n    \tfor (float theta = 0.0; theta <= 0.5 * PI; theta += stepD)\n        {\n        \tvec3 tangentSpaceDir = vec3(\n                cos(theta) * sin(phi),\n                cos(theta) * cos(phi),\n                sin(theta)\n            );\n            vec3 inDir = tangentSpaceDir.x * right\n                + tangentSpaceDir.y * up\n                + tangentSpaceDir.z * normal;\n            \n            irradiance += Skybox(inDir) * cos(theta) * sin(theta);\n            numSamples++;\n        }\n    }\n    \n    return PI * irradiance / float(numSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime > INIT_TIME)\n    {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \treturn;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 angles = uv * vec2(2.0 * PI, PI) + vec2(-PI, -PI * 0.5);\n    vec3 dir = vec3(\n    \tcos(angles.y) * cos(angles.x),\n        sin(angles.y),\n        cos(angles.y) * sin(angles.x)\n    );\n\n    fragColor = vec4(IrradianceMap(dir), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec3 PrefilterEnvMap(float roughness, vec3 r)\n{\n\tvec3 n = r;\n    vec3 v = r;\n    \n    vec3 prefilteredColor = vec3(0.0, 0.0, 0.0);\n    float totalWeight = 0.0;\n    \n    const uint numSamples = 1024u;\n    for (uint i = 0u; i < numSamples; i++)\n    {\n    \tvec2 Xi = Hammersley(i, numSamples);\n        vec3 h = ImportanceSampleGGX(Xi, roughness, n);\n        vec3 l = 2.0 * dot(v, h) * h - v;\n        \n        float NoL = max(dot(n, l), 0.0);\n        if (NoL > 0.0)\n        {\n        \tprefilteredColor += Skybox(l) * NoL;\n            totalWeight += NoL;\n        }\n    }\n    \n    return prefilteredColor / totalWeight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iTime > INIT_TIME)\n    {\n    \tfragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \treturn;\n    }\n    \n    int level = int(floor((fragCoord.x / iResolution.x) * float(ROUGHNESS_LEVELS)));\n    float roughness = float(level) / float(ROUGHNESS_LEVELS - 1);\n    float levelWidth = 1.0 / float(ROUGHNESS_LEVELS);\n    \n    // Bounds for level n:\n    // [n * levelWidth, (n+1) * levelWidth)\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv.x *= float(ROUGHNESS_LEVELS);\n    vec2 angles = fract(uv) * vec2(2.0 * PI, PI) + vec2(-PI, -PI * 0.5);\n    vec3 dir = vec3(\n        cos(angles.y) * cos(angles.x),\n        sin(angles.y),\n        cos(angles.y) * sin(angles.x)\n    );\n    \n    fragColor = vec4(PrefilterEnvMap(roughness, dir), 1.0);\n}","name":"Buffer D","description":"","type":"buffer"}]}