{"ver":"0.1","info":{"id":"lscGzf","date":"1451310577","viewed":298,"name":"Square Spring","username":"gaz","description":"twisted the cylinder of the torus cross-section.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["spiral","de"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nmat3 lookat(in vec3 eye, in vec3 target)\n{\n\tvec3 w = normalize(target-eye);\n\tvec3 u = normalize(cross(w,vec3(0.0,1.0,0.0)));\n\tvec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nfloat lengthN(in vec2 p, in float n)\n{\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1.0/n);\n}\n\nfloat deSpiral(in vec3 p)\n{\n    // transform\n    p.y -= 1.8;\n    p.yz *= rotate(1.0);\n    // twist\n    p.xy *= rotate(p.z * 3.5);\n    // project\n    vec3 p2 = vec3(p.xy, 0.0).xzy;\n    p2.yz *= rotate(0.25);\n    // torus\n    vec2 t = vec2(1.0, 0.15);\n    vec2 q = vec2(length(p2.xz)-t.x, p2.y);\n  \tfloat de = lengthN(q,6.0) - t.y;\n    // cut\n    de = max(abs(p.z) - 1.2, de);\n    return de;\n}\n\nfloat deGroud(in vec3 p)\n{\n    return p.y;\n}\n\nfloat map(in vec3 p)\n{    \n    return min(deSpiral(p),deGroud(p));\n}\n\nvec3 doColor(in vec3 p)\n{\n\tfloat d1 = deSpiral(p);\n    float d2 = deGroud(p);\n    if (d1 < d2){\n        return vec3(0.9, 0.6, 0.2);\n    } else {   \t\n    \treturn mix(0.6*texture(iChannel0, p.xz*0.15).xxx,\n    \t\tvec3(0.4,0.6,0.2), 0.3);\n    }\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.05;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.1+0.5*p.y*p.y);\n    vec3 ro = vec3(0.0, 3.0, 4.5);\n    vec3 rd = normalize(vec3(p, 2.0));\n    ro.xz *= rotate(iTime * 0.1);\n    rd = lookat(ro, vec3(0.0,2.0,0.0)) * rd;\n    float maxd = 20.0;\n    float t = 0.0, h;\n    for(int i = 0; i < 64; i++)\n    {\n        t += h = map(ro+rd*t);\n        if(h<0.001 || t>maxd) break;\n    }\n    if(t<maxd)\n    {\n        vec3 pos = ro+t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tcol = doColor(pos);\n        vec3 li = normalize(vec3(2.0, 3.0, 3.0));\n        float dif = clamp(dot(nor, li), 0.0, 1.0);\n        dif *= softshadow(pos, li);\n        col *= max(dif, 0.3);\n        col *= max(0.5+0.5*nor.y, 0.0);\n        col += pow(clamp(dot(reflect(rd, nor), li), 0.0, 1.0), 60.0);\n        col = mix( col, vec3(0.0), 1.0-exp( -0.01*t*t ) );\n\t\tcol = pow(col, vec3(0.8));\n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}