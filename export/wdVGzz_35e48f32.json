{"ver":"0.1","info":{"id":"wdVGzz","date":"1595639015","viewed":61,"name":"Raytracer #2 -- TheRealJoe","username":"TheRealJoe24","description":"raytracer from scratch","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ray","fun","cool","photorealism"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere {\n\tvec3 c;\n    float r;\n    vec3 col;\n    int matType;\n};\n    \nstruct Light {\n\tvec3 p;\n    vec3 col;\n    float i;\n    float clight;\n    int type;\n};\n    \nstruct HitData {\n    bool hit;\n    float t;\n};\n\nHitData iSphere(vec3 ro, vec3 rd, Sphere sphere) {\n    HitData data;\n\tvec3 co = ro-sphere.c;\n    float a = dot(rd,rd);\n    float b = 2.*dot(rd,co);\n    float c = dot(co,co) - sphere.r*sphere.r;\n    float delta = b*b - 4.*a*c;\n    if (delta < 0.) data.hit = false;\n    else {\n        data.t = (-b-sqrt(delta)) / (2.*a);\n    }\n    data.hit = delta >= 0.;\n    return data;\n}\n\nfloat computeLight(vec3 p, vec3 n, Light light) {\n    float i = 0.;\n    \n    if (light.type == 0) {\n        vec3 l = normalize(light.p-p);\n        float dif = clamp(dot(n,l),0.,1.);\n        i += dif;\n    } else if (light.type == 1) {\n    \tfloat amb = light.i;\n        i += amb;\n    }\n    \n    return i;\n}\n\nvec3 traceSingleRay(vec3 ro, vec3 rd, out vec3 po, out vec3 no, out bool hit, out Sphere hitSphere) {\n    vec3 col = vec3(0.529,0.808,0.922);\n    //if (rd.y < -0.1) col = vec3(0,1,0)+rd;\n    hit = false;\n    Sphere spheres[2] = Sphere[2] (\n    \tSphere(vec3(0,-10,5),9.,vec3(1,0,0),0),\n       \tSphere(vec3(0,0,5),1.,vec3(1,1,0),1)\n\t);\n    float t = 1000.;\n    for (int i = 0; i < spheres.length(); i++) {\n        HitData hitData = iSphere(ro, rd, spheres[i]);\n        if (hitData.hit && hitData.t < t) {\n        \tcol = spheres[i].col;\n            t = hitData.t;\n            hitSphere = spheres[i];\n            hit = true;\n        }\n    }\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p-hitSphere.c);\n    po = p;\n    no = n;\n    if (hitSphere.matType == 1)\n    \tcol = vec3(0.529,0.808,0.922);\n    return col;\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    bool hit;\n    vec3 p;\n    vec3 n;\n    Sphere hitSphere;\n    col = traceSingleRay(ro,rd,p,n,hit,hitSphere);\n    \n    Light dif = Light(vec3(0,2,3),vec3(1),0.,0.,0);\n    Light amb = Light(vec3(0,2,3),vec3(1),0.,0.,1);\n    dif.clight = computeLight(p,n,dif);\n    amb.clight = computeLight(p,n,amb);\n\tfloat light = clamp(dif.clight+amb.clight,0.,1.);\n    \n    float lightr = 0.;\n    vec3 colr = col*0.1;\n    if (hitSphere.matType == 1) {\n        for (int i = 0; i < 1; i++) {\n            vec3 pr;\n            vec3 nr;\n            bool hitr;\n            Sphere hitSpherer;\n            colr += traceSingleRay(p,-reflect(rd,n),pr,nr,hitr,hitSpherer);\n            if (hitSpherer.matType != 1) colr *= light;\n            if (hitr) {\n                p = pr;\n                n = nr;\n            } //else {colr = vec3(0.529,0.808,0.922);}\n            if (hitSpherer.matType != 1) break;\n        }\n    }\n    if (hit) {\n        if (hitSphere.matType == 0)\n    \t\tcol = vec3(light)*col;\n        else if (hitSphere.matType == 1)\n            col = colr;\n    }\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,0,0);\n    vec3 rd = normalize(vec3(uv,1));\n    col = trace(ro,rd);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}