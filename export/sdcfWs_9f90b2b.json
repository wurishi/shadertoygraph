{"ver":"0.1","info":{"id":"sdcfWs","date":"1657436501","viewed":191,"name":"Inhomogeneous medium ","username":"VL","description":"Click to reset.\nref : pbrt-v3","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec3 col = tex.xyz/max(tex.w,1.);\n\n    col = pow(col, vec3(0.4545));;\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define int2 vec2\n#define float2 vec2\n#define int3 vec3\n#define float3 vec3\n#define int4 vec4\n#define float4 vec4\n#define frac fract\n#define float2x2 mat2\n#define float3x3 mat3\n#define float4x4 mat4\n#define saturate(x) clamp(x,0.,1.)\n#define lerp mix\n#define CurrentTime (iTime)\n#define sincos(x,s,c) s = sin(x),c = cos(x)\n#define mul(x,y) (x*y)\n#define atan2 atan\n#define fmod mod\n#define static\n\nconst float InvPI = 0.318309886f;\nconst float PId2 = 1.57079632f;\nconst float PI = 3.141592653f;\nconst float PI2 = 6.2831853f;\nconst float MaxDist = 100.f;\nconst float SurfaceDist = 0.0001f;\nconst float FloatMax = 3.402823466e+38F;\nconst float FloatEpsilon = 1.192092896e-07F;\n\nfloat3x3 viewMatrix(float3 look)\n{\n    float3 right = normalize(cross(float3(0.f, 1.f, 0.f), look));\n    float3 up = cross(look, right);\n    return transpose(float3x3(right, up, look));\n}\n\nfloat3x3 normalMatrix(float3 normal)\n{\n    float3 tz = normalize(cross(float3(1., 0., 0.), normal));\n    float3 tx = cross(normal, tz);\n    return transpose(float3x3(tx, normal, tz));\n}\n\n\nfloat2 hash(float2 p)\n{\n    float3 p3 = frac(float3(p.xyx) * float3(154.1031, 166.1030, 178.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return frac((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat3 hash(float3 p3)\n{\n    p3 = frac(p3 * float3(192.1031, 145.1030, 165.0973));\n    p3 += dot(p3, p3.yxz + 33.33);\n    return frac((p3.xxy + p3.yxx) * p3.zyx);\n}\n\n\nfloat simplexNoise(float3 p)\n{\n    float k1 = 0.333333f;\n    float k2 = 0.166667f;\n    \n    int3 idx = floor(p + (p.x + p.y + p.z) * k1);\n    float3 a = p - (float3(idx) - float(idx.x + idx.y + idx.z) * k2);\n    \n    int3 tb1Arr[8] = vec3[8]\n    ( int3(0, 0, 1), int3(0, 1, 0), int3( 0), int3(0, 1, 0), int3(0, 0, 1), int3( 0), int3(1, 0, 0), int3(1, 0, 0) );\n    int3 tb2Arr[8] = vec3[8]\n    ( int3(0, 1, 1), int3(0, 1, 1), int3( 0), int3(1, 1, 0), int3(1, 0, 1), int3( 0), int3(1, 0, 1), int3(1, 1, 0) );\n    \n    uint tbIdx = (uint(a.x > a.y) << 2) | (uint(a.x > a.z) << 1) | uint(a.y > a.z);\n    \n    int3 tb1 = tb1Arr[tbIdx], tb2 = tb2Arr[tbIdx];\n    \n    float3 b = a - tb1 + k2;\n    float3 c = a - tb2 + k2 * 2.f;\n    float3 d = a - 1.f + k2 * 3.f;\n    \n    float4 kernel = max(0.5f - float4(dot(a, a), dot(b, b), dot(c, c), dot(d, d)), 0.f);\n    kernel *= kernel;\n    kernel *= kernel;\n    float4 noise = kernel * float4(dot(a, hash(idx)*2.-1.), \n                                   dot(b, hash(idx + tb1)*2.-1.), \n                                   dot(c, hash(idx + tb2)*2.-1.), \n                                   dot(d, hash(idx + 1.f)*2.-1.));\n    \n    return dot(vec4(60.f), noise);\n}\n\nfloat max3(float a, float b, float c)\n{\n    return max(a, max(b, c));\n}\n\nfloat max4(float a, float b, float c, float d)\n{\n    return max(max3(a, b, c), d);\n}\n\nfloat min3(float a, float b, float c)\n{\n    return min(a, min(b, c));\n}\n\nfloat min4(float a, float b, float c, float d)\n{\n    return min(min3(a, b, c), d);\n}\n\nfloat2 minX(float2 a, float2 b)\n{\n    return a.x < b.x ? a : b;\n}\n\n\nfloat cornellBoxIntersect(float3 ro, float3 rd, float3 boxPos, float3 boxSize)\n{\n    ro = ro - boxPos;\n    float3 positive = (boxSize - ro) / rd;\n    float3 negative = (-boxSize - ro) / rd;\n    \n    float3 tMax = max(positive, negative);\n    float3 tMin = min(positive, negative);\n    \n    float tFar = min3(tMax.x, tMax.y, tMax.z);\n    float tClose = max3(tMin.x, tMin.y, tMin.z);\n    if (tFar > 0.f && tFar >= tClose && (tFar != negative.z || tClose != negative.z))\n    {\n        return tClose == negative.z ? tFar : tClose;\n    }\n    else\n        return -1.f;\n}\n\nfloat3 cornellBoxNormal(float3 p, float3 boxPos, float3 boxSize)\n{\n    float3 n = boxPos - p;\n    float3 absN = abs(n / boxSize);\n    float msN = max3(absN.x, absN.y, absN.z);\n    return float3(absN.x == msN ? sign(n.x) : 0., absN.y == msN ? sign(n.y) : 0., absN.z == msN ? sign(n.z) : 0.);\n}\n\nfloat boxIntersect(float3 ro, float3 rd, float3 boxPos, float3 boxSize)\n{\n    ro = ro - boxPos;\n    float3 positive = (boxSize - ro) / rd;\n    float3 negative = (-boxSize - ro) / rd;\n    \n    float3 tMax = max(positive, negative);\n    float3 tMin = min(positive, negative);\n    \n    float tFar = min3(tMax.x, tMax.y, tMax.z);\n    float tClose = max3(tMin.x, tMin.y, tMin.z);\n    if (tFar > 0.f && tFar >= tClose)\n        return tClose > 0.f ? tClose : tFar;\n    else\n        return -1.f;\n}\n\nfloat2 boxIntersectBoth(float3 ro, float3 rd, float3 boxPos, float3 boxSize)\n{\n    ro = ro - boxPos;\n    float3 positive = (boxSize - ro) / rd;\n    float3 negative = (-boxSize - ro) / rd;\n    \n    float3 tMax = max(positive, negative);\n    float3 tMin = min(positive, negative);\n    \n    float tFar = min3(tMax.x, tMax.y, tMax.z);\n    float tClose = max3(tMin.x, tMin.y, tMin.z);\n    if (tFar > 0.f && tFar >= tClose)\n        return float2(tClose, tFar);\n    else\n        return float2(-1.f);\n}\n\nfloat planeIntersect(float3 ro, float3 rd, float3 n, float3 plane)\n{\n    float nrd = dot(n, rd);\n\n    return dot(n, plane - ro) / nrd;\n}\n\nfloat diskIntersect(float3 ro, float3 rd, float3 n, float4 disk)\n{\n    float t = planeIntersect(ro, rd, n, disk.xyz);\n    if (length(disk.xyz - (ro + t * rd)) <= disk.w)\n        return t;\n    else \n        return -1.;\n}\n\nconst uint noIntersect = 0u;\nconst uint cornellboxIdx = 1u;\nconst uint lightIdx = 2u;\nconst uint volumeIdx = 3u;\n\nconst float3 CornellBoxPos = float3(0., 0., 0.);\nconst float3 CornellBoxSize = float3(1.5, 1.5, 1.5);\nconst float3 LightNormal = float3(0., -1., 0.);\nconst float4 LightPos = float4(0., 1.49, 0., 0.5);\nconst float3 VolumeSize = float3(1.48, 1.45, 1.48);\nconst float3 VolumePos = float3(0., 0., 0.);\nconst float3 LightColor = float3(4.3, 4.5, 4.5);\n\nfloat2 intersect(float3 ro, float3 rd)\n{\n    float2 tmin = float2(FloatMax, noIntersect);\n    \n    float2 t = float2(cornellBoxIntersect(ro, rd, CornellBoxPos, CornellBoxSize), cornellboxIdx);\n    if(t.x > 0.)\n        tmin = t;\n    \n    t = float2(diskIntersect(ro, rd, LightNormal, LightPos), lightIdx);\n    if(t.x > 0. && tmin.x > t.x)\n        tmin = t;\n    \n    t = float2(boxIntersect(ro, rd, VolumePos, VolumeSize), volumeIdx);\n    if (t.x > 0. && tmin.x > t.x)\n        tmin = t;\n    \n    return tmin;\n}\n\nfloat fbm(float3 p)\n{\n    float G = exp2(-0.5);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for (int i = 0; i < 5; i++)\n    {\n        t += a * simplexNoise(f * p * 0.5);\n        f *= 2.0;\n        a *= G;\n    }\n    float k = smoothstep(-1.5, 1.5, p.y);\n    return clamp(t * k, 0., 1.);\n}\n\nfloat2 diskSampling(float3 p)\n{\n    float3 rand = hash(p);    \n    float x = sqrt(rand.x) * cos(PI2 * rand.y);\n    float y = sqrt(rand.x) * sin(PI2 * rand.y);\n    return float2(x, y);\n}\n\nfloat diskArea(float r)\n{\n    return r * r * PI;\n}\n\nfloat3 cosHemisphereSampling(float3 p)\n{\n    float2 disk = diskSampling(p);\n    float x = disk.x;\n    float y = disk.y;\n    float z = sqrt(1. - x * x - y * y);    \n    return float3(x, y, z);\n}\n\n\n\nfloat henyeyGreensteinPhase(float cosTheta, float g)\n{\n    float denom = 1. + g * g + 2. * g * cosTheta;\n    return (1. - g * g) / (denom * sqrt(denom) * 4. * PI);\n}\n\nfloat3 henyeyGreensteinWi(float3 p, float g)\n{\n    float3 rand = hash(p);\n    float sqrTerm = (1. - g * g) / (1. + g - 2. * g * rand.x);\n    float cosTheta = -(1. + g * g - sqrTerm * sqrTerm) / (2. * g);\n    float sinTheta = sqrt(max(0., 1. - cosTheta * cosTheta));\n    float phi = PI2 * rand.y;\n    float cosPhi = cos(phi);\n    float sinPhi = sin(phi);\n    \n    return float3(sinTheta * cosPhi, cosTheta, sinTheta * sinPhi);\n}\n\n\nconst int volumeIter = 50;\nfloat4 volume(float2 uv)\n{\n    float3 ro = float3(0., 0., -3.);\n    float3 rt = float3(0.,0., 0.);\n    float3 rd = mul(transpose(viewMatrix(normalize(rt - ro))), normalize(float3(uv, 1.)));\n\n    float3 color = vec3(0.);\n    float3 beta = vec3(1.);\n    \n    float3 sigmaS = vec3(80.);\n    float3 sigmaA = vec3(10.);\n    float3 sigmaT = sigmaS + sigmaA;    \n    float3 seed = hash(vec3(iTime))*100.;\n    \n    float beforeDist = 0.;\n    for (int bounce = 0; bounce < 10; ++bounce)\n    {\n        float2 dist = intersect(ro, rd);\n        uint idx = uint(round(dist.y));\n\n        float3 normal = vec3(0.);\n        if(idx == noIntersect)\n        {\n            break;\n        }\n        else if(idx == volumeIdx)\n        {\n            float2 tBoth = boxIntersectBoth(ro, rd, VolumePos, VolumeSize);\n            float t = tBoth.x < 0. ? beforeDist : tBoth.x;\n            float tMax = tBoth.y;\n            bool medium = false;\n            for (int i = 0; i < volumeIter; ++i)\n            {\n                float3 rand = hash(ro + seed);\n                t -= log(rand.x) / sigmaT.x;\n                if(t >= tMax)\n                    break;\n                float density = fbm(ro + t * rd);\n                if (density > rand.y)\n                {\n                    medium = true;\n                    break;\n                }\n                seed.y += 0.01;\n            }\n            \n            if(medium == false)\n            {\n                ro = ro + (tMax + 0.0001) * rd;\n                --bounce;\n                continue;\n            }\n            else\n            {\n                beta *= sigmaS / sigmaT;\n                ro = ro + t * rd;\n                normal = -rd;\n            }\n                \n        }\n        else if (idx == lightIdx)\n        {\n            if (dot(LightNormal, -rd) > 0.)\n            {\n                color += bounce == 0 ? beta * LightColor : vec3(0.);\n                normal = LightNormal;\n            }\n            else\n            {\n                normal = -LightNormal;\n            }\n            ro += dist.x * rd;\n        }\n        else if(idx == cornellboxIdx)\n        {\n            ro += dist.x * rd;\n            normal = cornellBoxNormal(ro, CornellBoxPos, CornellBoxSize);\n            normal = dot(normal, -rd) > 0. ? normal : -normal; \n        }\n        \n        ro += normal * 0.0001;\n        seed.x += 0.01;\n        float2 disk = diskSampling(ro + seed) * LightPos.w;\n        float3 lightSample = float3(disk.x, LightPos.y, disk.y);\n        float3 lightWi = normalize(lightSample - ro);\n        float areaCos = dot(LightNormal, -lightWi) * diskArea(LightPos.w);\n        float lightPdf = areaCos > 0. ? dot(lightSample - ro, lightSample - ro) / areaCos : 0.;\n        \n        \n        float3x3 normTrans = normalMatrix(normal);\n        float3 f = vec3(0.);\n        float3 lightF = vec3(0.);\n        float pdf = 0.;\n        float3 wi = vec3(0.);\n        seed.z += 0.01;\n        if (idx == lightIdx)\n        {\n            lightF = vec3(0.5 * max(dot(normal, lightWi), 0.) / PI);\n            \n            wi = mul(transpose(normTrans), cosHemisphereSampling(ro + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            f = vec3(0.5 * max(dot(normal, wi), 0.) / PI);\n            pdf = max(dot(normal, wi), 0.) / PI;\n        }\n        else if (idx == cornellboxIdx)\n        {\n            if(abs(normal.x)>0.)\n                f = normal.x > 0. ? float3(0.8, 0.2, 0.2) : float3(0.2, 0.8, 0.2);\n            else \n                f = float3(0.5, 0.5, 0.5);\n            \n            lightF = f * max(dot(normal, lightWi), 0.) / PI;\n            \n            wi = mul(transpose(normTrans), cosHemisphereSampling(ro + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            f = f * max(dot(normal, wi), 0.) / PI;\n            pdf = max(dot(normal, wi), 0.) / PI;\n        }\n        else if (idx == volumeIdx)\n        {\n            lightF = vec3(henyeyGreensteinPhase(dot(-rd, lightWi), 0.67));\n            wi = mul(transpose(normTrans), henyeyGreensteinWi(ro + seed, 0.67));\n            f = vec3(henyeyGreensteinPhase(dot(-rd, wi), 0.67));\n            pdf = f.x;\n        }\n\n       \n        float pdfSquareSum = lightPdf * lightPdf + pdf * pdf;\n        if (pdfSquareSum > 0.)\n        {\n            float2 test = intersect(ro, lightWi);\n            float Tr = 1.;\n            if (uint(round(test.y)) == volumeIdx)\n            {\n                float2 tBoth = boxIntersectBoth(ro, lightWi, VolumePos, VolumeSize);\n                float t = tBoth.x < 0. ? 0. : tBoth.x;\n                float tMax = tBoth.y;\n                for (int i = 0; i < volumeIter; ++i)\n                {\n                    float3 rand = hash(ro + seed);\n                    t -= log(rand.x) / sigmaT.x;\n                    if (t >= tMax)\n                        break;\n                    float density = fbm(ro + t * lightWi);\n                    Tr *= 1. - density;\n                    \n                    if (Tr < 0.01)\n                    {\n                        float q = max(0.05, 1. - Tr);\n                        q = q > rand.y ? 0. : 1. / (1. - q);\n                        Tr *= q;\n                    }\n                    \n                    if(Tr < FloatEpsilon)\n                        break;\n                    \n                    seed.x += 0.01;\n                }\n            }\n            color += lightPdf > 0. ? beta * lightF * LightColor * lightPdf * Tr / pdfSquareSum : vec3(0.);\n            \n            test = intersect(ro, wi);\n            Tr = 1.;\n            if (uint(round(test.y)) == volumeIdx)\n            {\n                float2 tBoth = boxIntersectBoth(ro, wi, VolumePos, VolumeSize);\n                float t = tBoth.x < 0. ? 0. : tBoth.x;\n                float tMax = tBoth.y;\n                \n                float2 test2 = intersect(ro + (tMax + 0.0001) * wi, wi);\n                \n                if (uint(round(test2.y)) == lightIdx)\n                {\n                    for (int i = 0; i < volumeIter; ++i)\n                    {\n                        float3 rand = hash(ro + seed);\n                        t -= log(rand.x) / sigmaT.x;\n                        if (t >= tMax)\n                            break;\n                        float density = fbm(ro + t * wi  );\n                        Tr *= 1. - density;\n                    \n                        if (Tr < 0.01)\n                        {\n                            float q = max(0.05, 1. - Tr);\n                            q = q > rand.y ? 0. : 1. / (1. - q);\n                            Tr *= q;\n                        }\n                    \n                        if (Tr < FloatEpsilon)\n                            break;\n                    \n                        seed.z += 0.01;\n                    }\n                }\n                else\n                    Tr = 0.;\n            }\n            else if (uint(round(test.y)) != lightIdx)\n                Tr = 0.;\n            \n            color += pdf > 0. ? beta * f * LightColor * pdf * Tr / pdfSquareSum : vec3(0.);\n        }\n        \n        \n        seed.y += 0.01;\n        if (idx == lightIdx)\n        {\n            wi = mul(transpose(normTrans), cosHemisphereSampling(ro + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            f = vec3(0.5 / PI);\n            pdf = abs(dot(normal, wi)) / PI;\n        }\n        else if (idx == cornellboxIdx)\n        {\n            wi = mul(transpose(normTrans), cosHemisphereSampling(ro + seed));\n            if (dot(normal, wi) < 0.)\n                wi = -wi;\n            if (abs(normal.x)>0.)\n                f = normal.x > 0. ? float3(0.8, 0.2, 0.2) : float3(0.2, 0.8, 0.2);\n            else\n                f = float3(0.5, 0.5, 0.5);\n            pdf = abs(dot(normal, wi)) / PI;\n        }\n        else if (idx == volumeIdx)\n        {\n            f = vec3(1.);\n            wi = mul(transpose(normTrans), henyeyGreensteinWi(ro + seed, 0.67));\n            pdf = abs(dot(normal, wi));\n        }\n         \n        beta *= pdf > 0. ? f * abs(dot(normal, wi)) / pdf : vec3(0.);\n        \n        if (beta.r < FloatEpsilon && beta.g < FloatEpsilon && beta.b < FloatEpsilon)\n            break;\n        rd = wi;        \n        beforeDist = dist.x;\n    }\n    \n    return float4(color, 1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 offs = -0.5 + hash(fragCoord);\n    vec2 uv = (2.0*(fragCoord+offs)-iResolution.xy)/iResolution.y;\n    \n    float4 col = volume(uv);\n        if(iFrame == 0 || iMouse.z > 0.)\n        fragColor = col;\n    else\n        fragColor = texture( iChannel0, fragCoord/iResolution.xy) + col;\n}","name":"Buffer A","description":"","type":"buffer"}]}