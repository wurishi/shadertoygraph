{"ver":"0.1","info":{"id":"ltjXDG","date":"1446250912","viewed":329,"name":"inverse trochoids approximation","username":"jt","description":"Approximation function (positive values of A only) for FabriceNeyret2's inverse trochoids [url]https://www.shadertoy.com/view/MtSSDG[/url]\n","likes":4,"published":1,"flags":8,"usePreview":0,"tags":["approximation","parametriccurve","trochoid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Approximation function for FabriceNeyret2's Inverse Trochoid\n\n// Original Inverse Trochoid by FabriceNeyret2, approximation by Jakob Thomsen\n\n// Trochoid : ( x(), y() ) = ( x0+A.cos(x0-t) , A.sin(x0-t) )\n// problem: we want y(x).\n\nfloat A, t;\nvec2 R;\n\n#define C(x)   A*cos(x-t)    // indeed, x-t should be k.(x-c.t)\n#define S(x)   A*sin(x-t)\n#define X0(x,xx)  x-C(xx)\n\nfloat trochoid(float x, float t)\n{\n// solve x = x0 + A.cos(x0-t) for x0\n//  as  x = x_i+1 + A.cos(x_i-t) ; x_0 = x\n// then apply y = A.sin(x0-t)\n// see more here: https://www.desmos.com/calculator/r0uowdkejy\n    return S(X0(x,X0(x,X0(x,X0(x,X0(x,x))))));\n}\n\nfloat trochoids_approx(float x, float t)\n{\n    return -A + 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(x - t), A + 1.0), 1.0/(A + 1.0));\n}\n\n// via wolframalpha solve y = -A + 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(x), A + 1.0), 1.0/(A + 1.0)) for x\nfloat trochoids_approx_inverse(float y) // returns x - t UNTESTED\n{\n    return\n    -asin\n        (\n            1.0\n            -\n            2.0\n            *\n            pow\n            (\n                1.0\n                +\n                (\n                    pow\n                    (\n                        2.0\n                        ,\n                        -1.0 - A\n                    ) \n                    *\n                    (-A - y)\n                    *\n                    pow(-((-A - y)/A), A)\n                )\n                /\n                A\n                ,\n                pow(1.0 + A, -1.0)\n            )\n        );\n}\n\nfloat single_trochoid_approx(float x, float t)\n{\n    return 2.0 * exp(-sqrt(pow(x - t, 2.0) + 1.0 / A - 1.0)) - A;\n}\n\n#define plot(Y) o += smoothstep(40./R.y, 0., abs(Y-U.y))\n#define plot_r(Y) o.r += smoothstep(40./R.y, 0., abs(Y-U.y))\n#define plot_g(Y) o.g += smoothstep(40./R.y, 0., abs(Y-U.y))\n#define plot_y(Y) o.rg += smoothstep(40./R.y, 0., abs(Y-U.y))\n\n\n#define pi 3.1415926\n\nvoid mainImage( out vec4 o, in vec2 U )\n//void mainImage( inout vec4 o, vec2 U ) // ERROR: overloaded functions must have the same parameter qualifiers\n{\n    t = iTime;\n    R = iResolution.xy;\n\n    U = 10.* (2.*U-R)/R.y;\n    o -= o;\n    A = iMouse.y<=0. ? abs(sin(t)) : iMouse.y/R.y;\n    \n    \n\tplot(  trochoid(U.x, t) + 4.); // positive trochoid (gravity wave) \n\tplot( -trochoid(U.x, t) - 4.); // negative trochoid (capillary wave)\n    \n    // Approximation (only for positive values of A)\n    plot_r(  trochoids_approx(U.x, t) - 4.0);\n    // Approximation of SINGLE inverse trochoid (only for positive values of A)\n    plot_g(  single_trochoid_approx(U.x, -1.5 * pi + fract(t / (2.0 * pi)) * 2.0 * pi) + 4.0);\n    \n    // plot_y(  trochoids_approx_inverse(U.x - t) - 0.0); // XXX nothing visible?! XXX\n    \n \n    o.b += .2;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"float trochoid(float t, float A)\n{\n    return -A + 2.0 * A * pow(1.0 - pow(0.5 + 0.5 * sin(-t), A + 1.0), 1.0 / (A + 1.0));\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    float A = abs(sin(time));\n    //return vec2(trochoid(6.2831*440.0*time, A));\n    return vec2(trochoid(6.2831*440.0*time/8.0, A));\n}\n","name":"Sound","description":"","type":"sound"}]}