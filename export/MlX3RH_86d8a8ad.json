{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Constant state data\n\n#define NUM_SPHERES 6\n#define NUM_PLANES 5\n#define NUM_ITERATIONS 4\n#define SRO ((curr_iteration == 0) ? 4.0 : 1.0)\n#define SHADOW_RAYS (SRO*SRO*SRO)\n\nvec4 g_spheres[NUM_SPHERES];\nvec4 g_sphereColors[NUM_SPHERES];\nvec4 g_planes[NUM_PLANES];\nvec4 g_planeColors[NUM_PLANES];\n\n// Variable global state\nint curr_iteration;\nvec4 g_light;\n\nbool isect_sphere(vec3 o, vec3 d, vec3 c, float rsq, out float t)\n{\n    vec3 l = c-o;\n    float tca = dot(l,d);\n    if (tca < 0.0) return false;\n    float dsq = -tca*tca + dot(l,l);\n    if (dsq > rsq) return false;\n    float thc = sqrt(rsq - dsq);\n    t = tca - thc;\n    return true;    \n}\n\nfloat fmod(float x, float y)\n{\n  return x - y * floor(x/y);\n}\n\nbool shadowRayCast(vec3 r, vec3 light_pos)\n{\n    vec3 d = light_pos - r;\n    \n    float lowest_t = length( d );\n\n    d = normalize(d);\n    \n    bool hit = false;\n    \n    for( int j = 0; j < NUM_SPHERES - 1; ++j )\n    {\n\t\tfloat t;\n        if( isect_sphere( r, d, g_spheres[j].xyz, g_spheres[j].w, t ) )\n        {\n\t\t\tif( t < lowest_t )\n            {\n                lowest_t = t; hit = true;\n            }\n        }\n    }\n    \n    for( int j = 0; j < NUM_PLANES; ++j )\n    {\n\t\tvec3 np = g_planes[j].xyz;\n        float np_dot_d = dot(np, d);\n        if( abs(np_dot_d) > 0.001 )\n        {\n            float t = (g_planes[j].w - dot(np, r)) / np_dot_d;\n            if( t > 0.0 && t < lowest_t )\n            {\n\t\t\t\tlowest_t = t; hit = true;\n            }\n        }\n    }\n    \n    return hit;\n}\n\nfloat getShadowTerm(vec3 r)\n{\n\tfloat light_amount = 1.0;\n    \n    if( curr_iteration == 0 )\n    { \n        for( int i=0; i < 64; ++i )\n        {\n            vec3 light_pos = g_light.xyz;\n\t\t\tfloat ofsx = fmod(float(i), SRO);\n        \tfloat ofsy = (float(i)*SRO)/SRO;\n    \t\tfloat ofsz = fmod(float(i)*SRO*SRO, SRO);\n    \t\tvec3 offset = 1.0 * vec3(ofsx, ofsy, ofsz);\n    \t\tlight_pos += offset;\n        \n        \tif( shadowRayCast(r, light_pos) ) \n        \t{\n\t\t\t\tlight_amount -= 1.0 / 64.0;\n        \t}\n  \t  \t}\n    }\n    else\n    {\n        // LOLHAX!!!!\n        light_amount = 0.33;\n        if( shadowRayCast(r, g_light.xyz) )\n        {\n\t\t\tlight_amount = 0.0;\n        }\n    }\n   \n    return light_amount;\n}\n\nvec4 isect( inout vec3 r, inout vec3 d, inout float reflectance )\n{\n\tfloat lowest_t = 10000000.0;\n    bool hit = false;\n    vec3 n = vec3(0, 1, 0);\n    vec3 p = vec3(0, 0, 0);\n    vec3 c = vec3(0, 0, 0);\n    \n    for( int i = 0; i < NUM_SPHERES; ++i )\n    {\n\t\tfloat t;\n        if( isect_sphere( r, d, g_spheres[i].xyz, g_spheres[i].w, t ) )\n        {\n         \tif( t < lowest_t )\n            {\n\t\t\t\tp = r + d * t;\n                n = normalize(p - g_spheres[i].xyz);\n                c = g_sphereColors[i].rgb;\n                reflectance = g_sphereColors[i].w;\n                lowest_t = t;\n                hit = true;\n            }\n        }\n    }\n    \n    for( int i = 0; i < NUM_PLANES; ++i )\n    {\n\t\tvec3 np = g_planes[i].xyz;\n        float np_dot_d = dot(np, d);\n        \n        if( abs(np_dot_d) > 0.001 )\n        {\n\t\t\tfloat t = (g_planes[i].w - dot(np, r)) / np_dot_d;\n            if( t > 0.0 && t < lowest_t )\n            {\n\t\t\t\tp = r + (d * t);\n                n = np;\n                bool xeven = fract(p.x * 0.1) > 0.5;\n                bool zeven = fract(p.z * 0.1) > 0.5;\n                \n                c = g_planeColors[i].rgb;\n                reflectance = g_planeColors[i].w;\n                lowest_t = t; hit = true;\n            }\n        }\n    }\n\n    if( hit )\n    {\n\t\tvec3 l = (g_light.xyz - p);\n        float dist = length( l );\n        l = l / dist;\n        \n        float ndotl = dot(n, l) * clamp(1.0 / dist*dist, 0.0, 1.0);\n        vec3 ambient = clamp(c.rgb * 0.25, 0.0, 1.0);\n        vec3 diffuse = clamp(ndotl * c.rgb, 0.0, 1.0);\n        float fresnel = 1.0 - clamp( abs( dot( n, d ) ), 0.0, 0.5);\n        reflectance = fresnel*fresnel * reflectance;\n        \n        vec3 inc = normalize(p-r);\n        r = p + n;\n        d = normalize( reflect(inc, n) );\n        \n        vec3 rl = reflect( l, n );\n        float rdotv = pow( clamp( dot( rl, d ), 0.0, 1.0 ), 3.0 );\n        vec3 specular = vec3(rdotv, rdotv, rdotv);\n        vec3 result = ambient.rgb;\n        result += getShadowTerm( r ) * (diffuse.rgb + specular.rgb);\n        \n        return vec4( result.rgb, 1 );\n    }\n    \n    reflectance = 0.0;\n    return vec4( 0, 0, 0, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialize variables   \n    float time = 3.0;\n    float s0 = 0.5 * sin(iTime * time);\n    float s1 = 0.5 * cos(iTime * time);\n    \n    float bounce0 = abs( sin(iTime * time * 1.1) );\n    float bounce1 = abs( cos(iTime * time * 1.0) );\n    float bounce2 = abs( sin(iTime * time * 0.7) );\n    float bounce3 = abs( sin(iTime * time * 0.35) );\n    \n    float cx = sin(iTime);\n    float cz = cos(iTime);\n    g_light = vec4(cx * 40.0, bounce3 * 0.0 + 50.0, 100.0 + cz * 40.0, 1.0);\n    \n    g_spheres[0] = vec4(-50.0, bounce2 * 40.0 - 10.0, 100.0, 20.0*20.0);// + vec4(0.0, 0.0, s1 * 20.0, 0);\n\tg_spheres[1] = vec4(-15.0, bounce1 * 15.0 - 15.0, 100.0, 10.0*10.0);\n\tg_spheres[2] = vec4(0.0, bounce0 * 25.0 - 20.0, 100.0,  5.0*5.0);\n\tg_spheres[3] = vec4(15.0, bounce1 * 15.0 - 15.0, 100.0, 10.0*10.0);\n\tg_spheres[4] = vec4(50.0, bounce2 * 40.0 - 10.0, 100.0, 20.0*20.0);// + vec4(0.0, 0.0, s0 * 20.0, 0);\n    g_spheres[5] = vec4(g_light.x, g_light.y, g_light.z, 3.0);\n    \n    g_sphereColors[0] = vec4(1.0, 0.0, 0.0, 1.0);\n\tg_sphereColors[1] = vec4(0.0, 1.0, 0.0, 1.0);\n\tg_sphereColors[2] = vec4(0.0, 0.0, 1.0, 1.0);\n    g_sphereColors[3] = vec4(0.0, 1.0, 0.0, 1.0);\n\tg_sphereColors[4] = vec4(1.0, 0.0, 0.0, 1.0);\n    g_sphereColors[5] = vec4(10.0, 10.0, 10.0, 0.0);\n        \n    // bottom\n\tg_planes[0] = vec4(0.0, 1.0, 0.0, -25.0);\n\tg_planeColors[0] = vec4(0.77, 0.64, 0.3, 0.7);\n    // left\n    g_planes[1] = vec4(1.0, 0.0, 0.0, -100.0);\n    g_planeColors[1] = vec4(1.0, 0.15, 0.15, 0.1);\n\t// top\n\tg_planes[2] = vec4(0.0,-1.0, 0.0, -75.0);\n    g_planeColors[2] = vec4(0.77, 0.64, 0.38, 0.1);\n\t//right\n\tg_planes[3] = vec4(-1.0, 0.0, 0.0, -100.0);\n    g_planeColors[3] = vec4(0.15, 1.0, 0.15, 0.1);\n\t// back\n\tg_planes[4] = vec4(0.0, 0.0, -1.0, -200.0);\n    g_planeColors[4] = vec4(0.77, 0.64, 0.38, 0.1);\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Calc initial ray\n    vec3 o = vec3(0.0, 25.0, -50.0);\n    float rx = mix(-0.8, 0.8, uv.x);\n    float ry = mix(-0.45, 0.45, uv.y);\n    vec3 d = normalize( vec3(rx, ry, 1.0) );\n    \n    vec4 final_color = vec4(0.5, 0.0, 0.0, 0.0);\n    float reflectance = 1.0;\n    float this_refl = reflectance;\n    \n    for( int i = 0; i < NUM_ITERATIONS; ++i )\n    {\n\t\tcurr_iteration = i;\n        this_refl *= reflectance;\n        vec4 new_color = isect( o, d, reflectance );\n        final_color = mix( final_color, new_color, this_refl );\n        if( reflectance < 1e-3) break;\n    }\n        \n    fragColor = vec4(final_color.rgb, 1.0 );\n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MlX3RH","date":"1418434277","viewed":5534,"name":"4k raytracer","username":"TomSalter","description":"WebGL port of a raytracer I wrote a few years back for a 1 day coding contest.\n\nThere's currently a bug where the secondary bounces are brighter than the primary, but I've implemented a \"workaround\" ;)","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","4k"],"hasliked":0,"parentid":"","parentname":""}}