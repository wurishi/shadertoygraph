{"ver":"0.1","info":{"id":"MdcGzB","date":"1450425929","viewed":146,"name":"Cup","username":"gaz","description":"3d","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI\t3.14159265359\n\nmat2 rotate(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h);\n}\n\nfloat Cross(in vec2 a, in vec2 b ) \n{\n    return a.x * b.y - b.x * a.y;\n}\n\n// from https://www.shadertoy.com/view/XsX3zf\nfloat deBezier(in vec2 p, in vec2 b0, in vec2 b1, in vec2 b2) \n{\n  b0 -= p; b1 -= p; b2 -= p;\t\n  float a = Cross(b0, b2), b = 2.0 * Cross(b1, b0), d = 2.0 * Cross(b2, b1);\n  float f = b * d - a * a;\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\n  gf = vec2(gf.y, -gf.x);\n  vec2 pp = -f * gf / dot(gf, gf);\n  vec2 d0p = b0 - pp;\n  float ap = Cross(d0p, d20), bp = 2.0 * Cross(d10, d0p);\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0 ,1.0);\n  return length(mix(mix(b0, b1, t),mix(b1, b2, t), t));\n}\n\n// https://www.shadertoy.com/view/4sS3zz\nfloat deEllipse( vec2 p, in vec2 ab )\n{\n\tp = abs( p ); if( p.x > p.y ){ p=p.yx; ab=ab.yx; }\n\tfloat l = ab.y*ab.y - ab.x*ab.x;\t\n    float m = ab.x*p.x/l; \n\tfloat n = ab.y*p.y/l; \n\tfloat m2 = m*m;\n\tfloat n2 = n*n;\n    float c = (m2 + n2 - 1.0)/3.0; \n\tfloat c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float p = acos(q/c3)/3.0;\n        float s = cos(p);\n        float t = sin(p)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = ( ry + sign(l)*rx + abs(g)/(rx*ry) - m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow( abs(q+h), 1.0/3.0 );\n        float u = sign(q-h)*pow( abs(q-h), 1.0/3.0 );\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        float p = ry/sqrt(rm-rx);\n        co = (p + 2.0*g/rm - m)/2.0;\n    }\n    float si = sqrt( 1.0 - co*co ); \n    vec2 r = vec2( ab.x*co, ab.y*si );\n    return length(r - p ) * sign(p.y-r.y);\n}\n\nfloat map(in vec3 p)\n{    \n    p.zx *= rotate(iTime * 0.5);\n    p.yz *= rotate(iTime * 0.3);\n    vec2 q = vec2(deBezier(p.xy, vec2(1.0, -0.2), vec2(1.5, 0.3),vec2(1.0, 0.5)), p.z);\n\tfloat a = 0.5 * length(q) - 0.05;\n    q = vec2(deEllipse(p.xz ,vec2(0.3, 0.5)), p.y);     \n    float b = deBezier(q, vec2(0.4, -0.5), vec2(0.8, -0.2),vec2(0.6, 0.7)) - 0.04;\n    q = vec2(length(p.xz), p.y); \n    float c = sdSegment(q, vec2(0.0, -0.5), vec2(1.0, -0.6)) - 0.04;\n    return min(min(a, b),c);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0, -1.0) * 0.002;\n    return normalize(\n        e.xyy * map(pos + e.xyy) + \n        e.yyx * map(pos + e.yyx) + \n        e.yxy * map(pos + e.yxy) + \n        e.xxx * map(pos + e.xxx));\n}/*\nfloat udBox(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nfloat parallax(in vec3 p, in vec3 rd, in vec3 bb)\n{\n    float precis = 0.001;\n    if (any(greaterThan(abs(p), bb))) return udBox(p, bb) + precis;\n    const float steps = 200.0;\n    float t;\n    float len = length(bb) * 2.0;\n    for(float i = 0.0; i < steps; i++)\n    {\n        t = len * pow(i / steps, 2.0);\n        vec3 pos = p + rd * t;\n        if (udBox(pos, bb) > 0.0) break;\n        if (map(pos) < precis) break;\n    }   \n \treturn t;   \n}\n*/\nfloat intersect(in vec3 ro, in vec3 rd)\n{\n    const float maxd = 10.0;\n    const float precis = 0.001;\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis || t > maxd) break;\n      \t//h = parallax(ro + rd * t, rd, vec3(1.0));\n        h = map(ro + rd * t);\n        t += h;\n    }\n    if( t > maxd ) t = -1.0;\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 col = mix(vec3(0.05, 0.03, 0.0), vec3(0.8), smoothstep(0.3, 2.5, length(p)));\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(p, -2.0));\n    float t = intersect(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    \tcol = vec3(0.7, 0.6, 0.2);\n        col *= max(dot(li, nor), 0.2);\n        col += pow(max(dot(vec3(0.0, 0.0, 1.0), reflect(-li, nor)), 0.0), 30.0);\n        col = pow(col, vec3(0.8)); \n    }\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}