{"ver":"0.1","info":{"id":"M33XR7","date":"1732659090","viewed":96,"name":"Lumes","username":"WebSeed","description":"Adapted iq's smin tutorial [url]https://iquilezles.org/articles/smin/[/url]","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","materials","blending","smooth","smin","union"],"hasliked":0,"parentid":"l33SR7","parentname":"Fork Fork Fork  webseed 927"},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cubic Polynomial Smooth-minimum\nvec2 smin(float a, float b, float k) {\n  k *= 6.0;\n  float h = max(k - abs(a - b), 0.0) / k;\n  float m = h * h * h * 0.5;\n  float s = m * k * (1.0 / 3.0);\n  return (a < b) ? vec2(a - s, m) : vec2(b - s, 1.0 - m);\n}\n\nfloat hash1(float n) {\n  return fract(sin(n) * 43758.5453123);\n}\n\nvec4 map(vec3 q)\n{\n  vec3 p = vec3(q);\n  const float s = 2.;\n  vec2 id = round(q.xz / s);\n  q.xz = q.xz - s * id;\n\n  // plane\n  float floorDist = q.y + sin(p.x * s * sin(iTime * 0.125) * 0.1) * .1 + cos(p.z * s) * .1;\n  // sphere\n  float sphereDist = length(\n    q - vec3(\n      0.0,\n      (sin(iTime + id.x + id.y) * .5 + .1) * .5,\n      0.0\n    )\n  ) - 0.2;\n\n  // smooth union\n  return vec4(smin(floorDist, sphereDist, 0.1), id);\n}\n\nvec4 intersect(in vec3 ro, in vec3 rd)\n{\n  const float maxd = 300.0;\n\n  vec4 res = vec4(0.0);\n  float t = 0.0;\n  for (int i = 0; i < 512; i++)\n  {\n    vec4 h = map(ro + rd * t);\n    if ((h.x < 0.005) || (t > maxd)) {\n      break;\n    }\n    t += h.x;\n    res = vec4(t, h.y, h.z, h.w);\n  }\n\n  if (t > maxd)\n    res = vec4(-1.0);\n  return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.005;\n  return normalize(\n    e.xyy * map(pos + e.xyy).x +\n    e.yyx * map(pos + e.yyx).x +\n    e.yxy * map(pos + e.yxy).x +\n    e.xxx * map(pos + e.xxx).x\n  );\n}\n\nvec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\nvec3 rainbow(in float x) {\n  return palette(x, vec3(0.5,0.5,0.5), vec3(0.5,0.5,0.5), vec3(1.0,1.0,1.0), vec3(0.0,0.33,0.67));\n}\n\nvec3 render(in vec2 p, vec4 ran) {\n  //-----------------------------------------------------\n  // camera\n  //-----------------------------------------------------\n  float an = 0.1 * iTime;\n  vec3 ro = vec3(\n      0.4 * sin(an) - iTime * 0.5,\n      10., //1. * (sin(iTime) * 0.5 + 0.5) + 3.0,\n      0.4 * cos(an) - iTime\n  );\n  vec3 ta = vec3(0.0, 25.0, 0.);\n  // camera matrix\n  vec3 ww = -normalize(ta - ro);\n  vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n  vec3 vv = normalize(cross(uu, ww));\n  // create view ray\n  float aspect = 1.8;\n  vec3 rd = normalize(p.x * uu + p.y * vv + aspect * ww);\n\n  //-----------------------------------------------------\n  // render\n  //-----------------------------------------------------\n\n  vec3 col = vec3(0.0001, 0.0005, 0.01);// vec3(0.03, 0.0, 0.05);\n  //vec3 col = vec3(0.05, 0.05, 0.05);\n  vec3 amb = vec3(col);\n  //vec3 c1 = normalize(amb + vec3(0.3, 0.0, 0.7));\n  vec3 c1 = amb; //vec3(0.05, 0.0, 0.1);\n  //vec3 c2 = vec3(1.0, 0.0, 0.0);\n\n  // raymarch\n  vec3 uvw;\n  vec4 res = intersect(ro, rd);\n  float t = res.x;\n  if (t > 0.0) {\n    vec3 c2 = rainbow(fract(res.w / 10.) * fract(res.z / 10.)); // normalize(amb + vec3(1., 0.4, 0.15));\n  \n    c2 = c2 * res.y * res.y; // * res.y * res.y;\n  \n  \n    vec3 pos = ro + t * rd;\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor);\n    float fre = clamp(1.0 + dot(nor, rd), 0.0, 1.0);\n    //float occ = 1.0; // calcAO(pos, nor, ran.y); occ = occ * occ;\n    \n    // blend materials\n    col = mix(c1, c2, res.y);\n    \n    //return col;\n    \n    \n    float emissive = res.y;\n\n    //col = col * 0.72 + 0.05 * fre * vec3(1.0, 1.0, 1.0);\n\n    vec3 lin = 2. * vec3(0.7, 0.8, 1.0) * (0.5 + 0.5 * nor.y); // * occ;\n    //lin += 0.8 * vec3(1.0, 1.0, 1.0) * fre * (0.6 + 0.4 * .5);\n\n\n    //col = col * lin * emissive;// * emissive * emissive;\n    col += vec3(.1, .1, 1.) * (0.1 * smoothstep(0.0, .4, ref.y) * pow(fre, 2.0)); // * occ;\n    //col += 0.01 * smoothstep(0.0, .1, ref.y) * pow(fre, 6.0); // * occ;\n    \n    const float falloff = -0.002;\n    col = mix(col, amb, 1.0 - exp(falloff * t * t));\n    //return vec3(emissive);\n    //return col;\n  }\n\n  // gamma and postpro\n  col = pow(col, vec3(0.4545));\n  /*\n  col *= 0.9;\n  col = clamp(col, 0.0, 1.0);\n  col = col * col * (3.0 - 2.0 * col);\n  */\n\n  // dithering\n  col += (ran.x - 0.5) / 255.0;\n\n  return (1. * col * col) + col;\n}\n\n#define AA 1\n\nvec3 bg(in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy - 0.5;\n\n  vec4 k = vec4(0.0, 0.0, 0.0, 1.0);\n\n  float passes = 100.0;\n  float t = iTime * 0.012;\n\n  for (float i = 0.0; i < passes; ++i) {\n    float offset = i / passes;\n    vec2 s = uv * offset + vec2(sin(t), cos(t));\n\n    k += texture(iChannel1, s) / passes * (1.0 - offset) * 5.0;\n  }\n\n  vec3 c = vec3(\n    pow(k.x, 3.0) + 0.5,\n    /* pow(k.y, 2.0) */ pow(k.x, 2.0) * 0.5,\n    k.z\n  );\n  \n  return c * c;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 px = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  vec4 ran = texelFetch(iChannel0, ivec2(fragCoord) & 1023, 0);\n  vec3 col = render(px, ran);\n  \n  vec3 bg = vec3(0.); //(sin(iTime * 0.5) * 0.4 + 0.5) * 0.8 * bg(fragCoord);\n\n  fragColor = vec4(bg + col, 1.0);\n}","name":"Image","description":"","type":"image"}]}