{"ver":"0.1","info":{"id":"cl2XRD","date":"1675768253","viewed":50,"name":"Lambert - sphere","username":"amethyst","description":"my first ray marching.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","lambert"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    // camera ray\n\tvec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3(0.0, 1.0, 0.0 );\n\tvec3 rd = normalize(vec3(p, 1.0));\n\n    float scene_dist = ray_march(ro, rd);\n    vec3 scene_pos = ro + rd * scene_dist;\n    vec3 scene_normal = get_normal(scene_pos);\n    vec3 scene_to_light = normalize(LIGHT.xyz - scene_pos);\n    vec3 light = get_light(scene_to_light, scene_normal);\n    float shadow = get_shadow(scene_pos + scene_normal * EPSILON * 2.0, scene_to_light);\n    col = light * shadow;\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//const\n#define PI 3.1415926\n\n// ray marching properties\n#define MAX_STEPS 200\n#define MAX_DISTANCE 1000.0\n#define EPSILON 0.01\n\n// scene properties\n#define SPHERE0 vec4(0.0, 1.0, 3.0, 1.0)\n#define PLANE 0.0\n\n// light properties\n#define LIGHT vec4(2.0, 9.0, -4.0, 1.0)\n\nvec3 get_palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b * cos(2.0 * PI * (c + t * d));\n}\n\n//----------------------------ray marching---------------------------//\nfloat get_distance(in vec3 p)\n{\n    float dst_to_spehre = length(p - SPHERE0.xyz) - SPHERE0.w;\n    float dst_to_plane = p.y - PLANE;\n    return min(dst_to_spehre, dst_to_plane);\n}\n\nvec3 get_normal(in vec3 p)\n{\n    const vec2 h = vec2(EPSILON, 0.0);\n    return normalize( vec3(get_distance(p + h.xyy) - get_distance(p - h.xyy),\n                           get_distance(p + h.yxy) - get_distance(p - h.yxy),\n                           get_distance(p + h.yyx) - get_distance(p - h.yyx)) );\n}\n\nfloat ray_march(in vec3 ro, in vec3 rd)\n{\n    vec3 p = ro;\n    float d = 0.0;\n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float di = get_distance(p);\n        p += rd * di;\n        d += di;\n        if(d >= MAX_DISTANCE || di <= EPSILON) break;\n    }\n    return d;\n}\n//------------------------------------------------------------------//\n\n\n//--------------------------shading model---------------------------//\nfloat get_shadow(in vec3 ro, in vec3 rd)\n{\n    float d = ray_march(ro, rd);\n    return d < length(ro - LIGHT.xyz) ? 0.05 : 1.0;\n}\n\nvec3 get_light(in vec3 l, in vec3 n)\n{\n    vec3 L = normalize(l);\n    vec3 N = normalize(n);\n    float lambert = clamp(dot(N, L), 0.0, 1.0);\n    return vec3(lambert) * LIGHT.w;\n}\n//------------------------------------------------------------------//","name":"Common","description":"","type":"common"}]}