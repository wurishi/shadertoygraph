{"ver":"0.1","info":{"id":"ssd3RM","date":"1629732090","viewed":131,"name":"Kinkakuji (Golden Pavilion)","username":"ZenAn","description":"Kinkakuji","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SAMPLES 2\n#define EPSILON 1e-3\n#define opU(a, b) ( (a).x < (b).x ? (a) : (b) )\n#define match(a, b) ( abs(a-b) < EPSILON )\n\n\n#define SKY    0.0\n#define PLANE  1.0\n#define SURF   2.0\n#define ROOF   3.0\n#define STAGE  4.0\n\n\nfloat sdBaseRoof(vec3 p) {\n    const vec3 e = vec3(1,0,-1);\n    const float h = 0.4;\n    float d = 1e10;\n\n    p.xz = abs(p.xz);\n\n    float l = length(p.xz);\n    vec3 u = normalize(cross(p, e.yxy));\n    mat3 r = rotate3(u, pow(l, 6.)*0.5);\n    \n    p = r*p;\n\n    d = min(d, udTriangle(e.xyy * sqrt(2.), e.yyx * sqrt(2.), e.yxy*h, p));\n    d = min(d, udTriangle(e.xyy * sqrt(2.), e.yyx * sqrt(2.), e.yyy, p));\n\n    return d;\n}\n\nfloat sdRoof(vec3 p) {\n    mat3 r = rotate3(vec3(0,1,0), 45.);\n    return sdBaseRoof(r * p);\n}\n\nfloat sdBaseRailing(int n, float r, float h, vec3 p) {\n    // const vec3 e = vec3(1,0,-1);\n\n    float d = 1e10;\n    p.xz = abs(p.xz);\n    for (int i = 0; i <= n; ++i) {\n        float f = float(i)/float(n) * SQRT_2;\n        vec3 x = vec3(f, 0, SQRT_2-f);\n        d = min(d, sdCappedCylinder(x, x + vec3(0,h,0), r, p));\n    }\n    d = min(d, sdCapsule(vec3(SQRT_2,h,0), vec3(0,h,SQRT_2), r, p));\n    d = min(d, sdCapsule(vec3(SQRT_2,h*0.6,0), vec3(0,h*0.6,SQRT_2), r, p));\n    return d;\n}\n\nfloat sdRailing(int n, float r, float h, vec3 p) {\n    mat3 rm = rotate3(vec3(0,1,0), 45.);\n    return sdBaseRailing(n, r, h, rm * p);\n}\n\nvec2 map(in vec3 p) {\n    vec2 res = vec2(1e10, SKY);\n\n    res = opU(res, vec2(\n        sdPlane(p),\n        PLANE\n    ));\n\n    if (sdBox(vec3(0.8), p-vec3(0.0, 0.8, 0.0)) < res.x) {\n        // 上层栏杆\n        res = opU(res, vec2(\n            sdRailing(4, 0.014, 0.24, (p - vec3(0,0.89,0))/0.56)*0.56,\n            SURF\n        ));\n\n        // 下层栏杆\n        res = opU(res, vec2(\n            sdRailing(6, 0.01, 0.18, (p - vec3(0,0.4,0))/0.8)*0.8,\n            SURF\n        ));\n\n        // 屋顶装饰\n        res = opU(res, vec2(\n            sdSphere2(.06, vec3(p.x, (p.y-1.66)*0.7, p.z)),\n            SURF\n        ));\n\n        // 下层屋顶\n        res = opU(res, vec2(\n            sdRoof(p - vec3(0,0.66,0)),\n            ROOF\n        ));\n\n        // 上层屋顶\n        res = opU(res, vec2(\n            sdRoof((p - vec3(0,1.28,0)) / 0.8)*0.8,\n            ROOF\n        ));\n\n        // 底座\n        res = opU(res, vec2(\n            sdBox(vec3(0.8, 0.02, 0.8), p-vec3(0,0.02,0)),\n            STAGE\n        ));\n\n        // 下层隔层\n        res = opU(res, vec2(\n            sdBox(vec3(0.8, 0.012, 0.8), p-vec3(0,0.4,0)),\n            SURF\n        ));\n\n        // 下层\n        res = opU(res, vec2(\n            sdBox(vec3(0.56, 0.4, 0.56), p - vec3(0,0.3,0)),\n            SURF\n        ));\n\n        // 上层底座\n        res = opU(res, vec2(\n            sdBox(vec3(0.56, 0.03, 0.56), p-vec3(0,0.89,0)),\n            SURF\n        ));\n\n        // 上层\n        res = opU(res, vec2(\n            sdBox(vec3(0.4, 0.2, 0.4), p-vec3(0,1.1,0)),\n            SURF\n        ));\n    \n    }\n\n    return res;\n}\n\nvec3 normalMap(in vec3 pos) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvec2 rayCast(in vec3 ro, in vec3 rd) {\n    float tmin = 0.1, tmax = 20.0;\n    float t = tmin;\n    vec2 res = vec2(tmax, SKY);\n    \n    float testPlane = (0.0 - ro.y) / rd.y;\n    if (testPlane > 0.0) {\n        tmax = min(tmax, testPlane);\n        res = vec2(testPlane, PLANE);\n    }\n    \n    for (int i = 0; i < 256; ++i) {\n        vec2 r = map(ro + t * rd);\n        float dist = r.x;\n        \n        if (t > tmax) {\n            vec2 res = vec2(tmax, SKY);\n            break;\n        }\n        if (abs(dist) < EPSILON) {\n            res = vec2(min(tmax, t), r.y);\n            break;\n        }\n        t += dist;\n    }\n    return res;\n}\n\nfloat calcSoftshadow(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    // bounding volume\n    float tp = (0.0-ro.y)/rd.y;\n    if(tp > 0.0)\n        tmax = min(tmax, tp);\n\n    float res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 64; i++) {\n\t\tfloat h = map(ro + rd*t).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min(res, s*s*(3.0-2.0*s));\n        t += clamp(h, 0.02, 0.2);\n        if(res < 0.004 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec2 calcReflection(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    // bounding volume\n    float tp = (0.0-ro.y)/rd.y;\n    if(tp > 0.0)\n        tmax = min(tmax, tp);\n        \n    vec2 refRes = vec2(0,0);\n\n    float res = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 64; i++) {\n        vec2 mapRes = map(ro + rd*t);\n\t\tfloat h = mapRes.x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min(res, s*s*(3.0-2.0*s));\n        t += clamp(h, 0.02, 0.2);\n        \n        // refRes = vec2(t, mapRes.y);\n        \n        if(h < 0.004) {\n            refRes = vec2(t, mapRes.y);\n            break;\n        }\n    }\n    return refRes;\n}\n\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp(1.0 - 3.0*occ, 0.0, 1.0) * (0.5+0.5*nor.y);\n}\n\nvec3 getMaterialColor(float material, vec3 p, vec3 n, float dist) {\n    vec3 color = vec3(0.58, 0.67, 0.8); // SKY\n\n    if (match(material, PLANE)) {\n        color = vec3(0.28, 0.46, 0.63);\n    } else if (match(material, SURF)) {\n        if (p.y < 0.38) {\n            vec3 tex = texture(iChannel0, p.xy*2.0).rgb;\n            color = mix(\n                vec3(1.),\n                vec3(42,35,40)/256.,\n                float(\n                    abs(p.y - 0.3) < 0.016 ||\n                    mod(p.x-0.01, 0.56/2.) < 0.032 ||\n                    mod(p.z-0.01, 0.56/2.) < 0.032\n                )\n            );\n            color = mix(color, tex, 0.16);\n        } else {\n            color = vec3(250., 185, 60.0)/255.;\n        }\n        \n    } else if (match(material, ROOF)) {\n        if (n.y < 0.0)\n            color = vec3(250., 185, 60.0)/255.;\n        else if (abs(n.y) < 0.5)\n            color = vec3(0.1);\n        else\n            color = vec3(0.78, 0.87, 1.0);\n    }\n    \n    return color;\n}\n\nvec3 render(vec3 eye, vec3 dir) {\n    vec2 res = rayCast(eye, dir);\n    vec3 p = eye + res.x*dir;\n    vec3 n = normalMap(p);\n    \n    // vec3 color = vec3(0.4, 0.6, 1.0);\n    vec3 color = getMaterialColor(res.y, p, n, res.x);\n    \n    // ambient occlusion\n    {\n        float occ = calcAO(p, n);\n        // if (match(res.y, SKY))\n        //     occ = 1.0;\n        // occ = (1.0 - (1.0-occ)*0.96);\n        color *= occ;\n    }\n    \n    #if 1\n    // sun shadow\n    {\n        vec3 sunDir = normalize(vec3(-0.5, 0.2, -0.6));;\n        float shadow = calcSoftshadow(p, sunDir, 0.01, 8.);\n        \n        float diff = clamp( dot(sunDir, n), 0.0, 1.0 );\n        diff *= 0.5 * shadow;\n        // color *= (1.0-(1.0-shadow)*0.4);\n        // color = mix(color, vec3(shadow), 0.16);\n        // color += 0.16*shadow;\n        color += diff;\n    }\n    #endif\n    // color = mix(color, vec3(occ), (sin(iTime * 0.5)+1.0)*0.5);\n    \n    return color;\n}\n\nmat3 setCamera(in vec3 eye, in vec3 lookAt, float rotation) {\n    vec3 cw = normalize(lookAt-eye);\n\tvec3 cp = vec3(sin(rotation), cos(rotation),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // float time = iTime;\n    float time = 21.04;\n    // camera\n    vec3 eye = vec3(sin(time), 0.2, cos(time)) * 5.;\n    // vec3 eye = vec3(6.0, 2.0, 6.0);\n    // vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    vec3 lookAt = vec3(1.0, 0.0, 0.0);\n    mat3 camera = setCamera(eye, lookAt, 0.0);\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < SAMPLES; ++i)\n    for (int j = 0; j < SAMPLES; ++j) {\n\n        vec2 offset = vec2(float(i), float(j)) / float(SAMPLES) - 0.5;\n        // pixel\n        vec2 p = (2.0 * (fragCoord + offset) - iResolution.xy) / iResolution.y;\n\n        // ray direction\n        vec3 dir = camera * normalize(vec3(p.xy, 2.0));\n\n        // render\n        vec3 c = render(eye, dir);\n        c = pow(c, vec3(0.4545));\n\n        color += c;\n    }\n\n    color /= float(SAMPLES * SAMPLES);\n\n    // Output to screen\n    fragColor = vec4(color, .0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535897932384626\n#define SQRT_2 1.414\n\nfloat sdSphere(in vec3 p) {\n    return length(p) - 1.0;\n}\n\nfloat sdSphere2(float r, in vec3 p) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 b, vec3 p) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox(vec3 b, float r, vec3 p) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBoxFrame(vec3 b, float e, vec3 p) {\n  p = abs(p) - b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdTorus(vec2 t, vec3 p) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdCapsule(vec3 a, vec3 b, float r, vec3 p) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat sdCappedCylinder(vec3 a, vec3 b, float r, vec3 p) {\n  vec3  ba = b - a;\n  vec3  pa = p - a;\n  float baba = dot(ba,ba);\n  float paba = dot(pa,ba);\n  float x = length(pa*baba-ba*paba) - r*baba;\n  float y = abs(paba-baba*0.5)-baba*0.5;\n  float x2 = x*x;\n  float y2 = y*y*baba;\n  float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n  return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat udTriangle(vec3 a, vec3 b, vec3 c, vec3 p) {\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) ) - 0.02;\n}\n\nfloat sdRoundedCylinder(float ra, float rb, float h, vec3 p) {\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdPyramid(float h, vec3 p) {\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nmat3 rotate3(vec3 v, float theta) {\n    float c = cos(theta * PI/180.);\n    float s = sin(theta * PI/180.);\n    vec3 v2 = v*v;\n    \n    return mat3(\n        c + (1.-c)*v2.x, (1.-c)*v.x*v.y - s*v.z, (1.-c)*v.x*v.z + s*v.y,\n        (1.-c)*v.x*v.y + s*v.z, c + (1.-c)*v2.y, (1.-c)*v.y*v.z - s*v.x,\n        (1.-c)*v.z*v.x - s*v.y, (1.-c)*v.z*v.y + s*v.x, c + (1.-c)*v2.z\n    );\n}","name":"Common","description":"","type":"common"}]}