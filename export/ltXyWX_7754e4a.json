{"ver":"0.1","info":{"id":"ltXyWX","date":"1506611202","viewed":405,"name":"Shiny Pills","username":"isak","description":"Shadertoy is like a drug ;)","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["distancefield","buffer","trails","pills"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 32\n#define EPSILON 0.005\n#define N_EPSILON 1.0\n#define PI 3.14159265358979323846\n\n\nmat2 rot(float a) {\n    float c = cos(a); float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat d_line(vec3 p, vec3 a , vec3 b){\n\n    p.xy *= rot(iTime);\n    p.yz *= rot(iTime);\n    \n    vec3 ab = b - a;\n    vec3 ap = p - a;\n   \n    return length(ap - 1.0*ab*clamp(dot(ap, ab)/dot(ab, ab), -1.0, 1.0)) - 1.0;\n}\n\nfloat d_sphere(vec3 p, vec3 pos, float r){\n    return length(p - pos) - r;\n}\n\nfloat sceneSDF(vec3 p){\n    return d_line(p + vec3(0.0, 0.0, 4.0), vec3(0.0,-0.5, 0.0), vec3(0.0, 0.5, 0.0));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + N_EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - N_EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + N_EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - N_EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + N_EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - N_EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;\n    \n    uv *= 2.0;\n    \n        uv.x = mod(uv.x, 3.0) - 1.5;\n    \n    float fov = PI/4.0;\n    vec3 cam_pos = vec3(0.0, 0.0, 1.0*(1.0 + 1.0/tan(fov)));\n    \n    vec3 ray = cam_pos;\n    vec3 dir = normalize(vec3(uv.xy, 0.0) - cam_pos);\n    \n    vec3 light = normalize(vec3(0.5, 0.5, 1.0));\n    \n    float back_light = 0.0;\n    float shade = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++){\n        \n        float dist = sceneSDF(ray);\n        \n        if ( dist < EPSILON ) {\n            \n            vec3 n = estimateNormal(ray);\n            float soft = dot(light,n);\n            float soft_s = soft - 1.0;\n            shade = 0.8*soft;\n            back_light = clamp(exp(-soft*soft*10.0), 0.0, 1.0);\n            shade += clamp(exp(-soft_s*soft_s*10000.0), 0.0, 1.0);\n            \n            break;\n        }\n        else if ( length(ray) > 5.0 )\n            break;\n        \n        shade = clamp(shade, 0.0, 1.0);\n        ray += dir*dist;\n    }\n    \n    \n    fragColor = texture(iChannel0, fragCoord.xy/iResolution.xy);\n\tfragColor += (vec4(1.0)*shade - fragColor*step(0.1, shade));\n    fragColor += back_light*vec4(1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 32\n#define EPSILON 0.005\n#define N_EPSILON 1.0\n#define PI 3.14159265358979323846\n\n\nmat2 rot(float a) {\n    float c = cos(a); float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat d_line(vec3 p, vec3 a , vec3 b){\n\n    p.xy *= rot(iTime);\n    p.yz *= rot(iTime);\n    \n    p *= 1.0 + 0.0*0.5*(1.0 + 1.0*sin(32.0*iTime));\n    \n    vec3 ab = b - a;\n    vec3 ap = p - a;\n   \n    return length(ap - 1.0*ab*clamp(dot(ap, ab)/dot(ab, ab), -1.0, 1.0)) - 1.0;\n}\n\nfloat d_sphere(vec3 p, vec3 pos, float r){\n    return length(p - pos) - r;\n}\n\nfloat sceneSDF(vec3 p){\n    return d_line(p + vec3(0.0, 0.0, 4.0), vec3(0.0,-0.5, 0.0), vec3(0.0, 0.5, 0.0));\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + N_EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - N_EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + N_EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - N_EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + N_EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - N_EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\tvec2 uv = fragCoord.xy - 0.5*iResolution.xy;\n    uv *= 2.0/iResolution.y;\n    \n    uv *= 2.0;\n    \n    uv.x = mod(uv.x, 3.0) - 1.5;\n    \n    float fov = PI/4.0;\n    vec3 cam_pos = vec3(0.0, 0.0, 1.0*(1.0 + 1.0/tan(fov)));\n    \n    vec3 ray = cam_pos;\n    vec3 dir = normalize(vec3(uv.xy, 0.0) - cam_pos);\n    \n    vec3 light = normalize(vec3(0.5, 0.5, 1.0));\n    \n    float shade = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++){\n        \n        float dist = sceneSDF(ray);\n        \n        if ( dist < EPSILON ) {\n            \n            vec3 n = estimateNormal(ray);\n            float soft = dot(light,n);\n            shade = 0.8*soft;\n            \n            break;\n        }\n        else if ( length(ray) > 5.0 )\n            break;\n        ray += dir*dist;\n    }\n    \n    vec2 UV = fragCoord.xy/iResolution.xy;\n    \n    UV = (UV - 0.5);\n    UV.x -= 0.002+ 0.001*sin(iTime);\n    UV.y -= 0.004;\n    UV *= 1.01;\n    UV = UV + 0.5;\n    \n    \n    vec4 col = vec4(0.0, 1.0 ,1.0, 0.0);\n    fragColor = 0.99*col*texture(iChannel0, UV );\n    fragColor.rg *= rot(0.15);\n    \n\tfragColor += (1.0 + 1.2*sin(32.*iTime))*col*shade;\n    \n    fragColor = clamp(fragColor, 0.0, 1.4);\n\n}","name":"Buf A","description":"","type":"buffer"}]}