{"ver":"0.1","info":{"id":"lldSRl","date":"1481321887","viewed":161,"name":"Seaquence Rings","username":"notlion","description":"How we put the Sea in Seaquence","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["test","ruler","seaquence","divisions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 midColor = vec3(20, 25, 38) / 255.0 * 1.25;\nconst vec3 loColor = vec3(14, 18, 28) / 255.0 * 1.25;\nconst vec3 hiColor = vec3(34, 37, 56) / 255.0 * 1.25;\nconst vec3 loColorDt = loColor - midColor;\nconst vec3 hiColorDt = hiColor - midColor;\nconst vec3 ringColor = vec3(43, 48, 59) / 255.0 * 1.25;\nconst vec2 celOff = vec2(1.0 / 256.0, 0.0);\n\n#define SEAQ_RIPPLE_FX 1\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 coord = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n    coord.y *= iResolution.y / iResolution.x;\n    \n    float scale = 0.4 + smoothstep(-1.0, 1.0, cos(iTime * 0.413)) * 0.6;\n    coord *= scale;\n    \n    coord.x += cos(iTime * 0.377) * sin(iTime * 0.162) * 0.1;\n    coord.y += cos(iTime * 0.339) * sin(iTime * 0.213) * 0.1;\n    \n    float time = fract(iTime);\n    vec2 blip = vec2(time, 1.0 - time);\n    \n\tfloat ringFreq = 3.5;\n\tfloat px = scale / iResolution.x;\n    \n    vec2 tcScale = 256.0 / iResolution.xy;\n    vec2 texCoord = coord * 0.5 + 0.5;\n    float t = textureLod(iChannel0, tcScale * texCoord, 0.0).x;\n\n#if SEAQ_RIPPLE_FX\n    float tx = textureLod(iChannel0, tcScale * (texCoord + celOff.xy), 0.0).x;\n    float ty = textureLod(iChannel0, tcScale * (texCoord + celOff.yx), 0.0).x;\n\n    // Ripple Displacement\n    vec2 d = 4.0 * celOff.x * vec2(tx - t, ty - t);\n    float x = length(coord + d);\n#else\n    float x = length(coord);\n#endif\n\n    const float n = 8.0;\n\n    float f1 = ringFreq * n;\n    float x1 = x * f1 - 2.5;\n    float x2 = abs(2.0 * fract(x1) - 1.0);\n\n    float rpx = px * f1 * 2.0;\n\n    // Rings\n    float a = 1.0 - step(1.0, mod(x1 - 1.0, n)) * 0.85;\n    float r1 = lerpstep(3.0 * rpx, rpx, x2) * a;\n    float r2 = lerpstep(3.0 * rpx, rpx, abs(2.0 * x * f1 - blip.x * n)) * blip.y;\n    float r3 = lerpstep(5.0 * px, 3.0 * px, x) * blip.y;\n    vec3 c = mix(midColor, ringColor, max(r1, max(r2, r3)));\n\n    // Ripple Shading\n    c += t > 0.0 ? hiColorDt * lerpstep(0.3, 1.0, t) : loColorDt * lerpstep(0.3, 1.0, -t);\n\n    // Final Circle Mask\n    c = mix(loColor, c, smoothstep(0.0, px * 10.0, 1.0 - x));\n\n    fragColor = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float lerpstep(in float e0, in float e1, in float x) {\n    return clamp((x - e0) / (e1 - e0), 0.0, 1.0);\n}\n\n#define HASHSCALE4 vec4(1.1031, 1.1030, 1.0973, 1.1099)\n\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int EFFECTOR_COUNT = 2;\nconst float RESOLUTION = 256.0;\n\nconst float friction = 0.2;\nconst float gravity = 0.0175;\nconst float transmission = 0.025;\nconst float tightness = 0.04;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 fc = ivec2(fragCoord);\n    if (fc.x > 255 || fc.y > 255) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec2 texCoord = fragCoord / RESOLUTION;\n    vec4 state = texelFetch(iChannel0, fc, 0);\n\n    float vel = state.x - state.y;\n\n    vel *= 1.0 - friction;\n    vel -= state.x * gravity;\n\n    vec4 celState;\n\n#define SAMPLE(dir, strength)                                                                 \\\n    celState = texelFetch(iChannel0, clamp(fc + (dir), 0, 255), 0);                           \\\n    vel += (celState.x - state.x) * (strength) * tightness;                                   \\\n    vel += (celState.x - celState.y) * (strength) * transmission;\n\n    SAMPLE(ivec2( 0, -1), 1.0)\n    SAMPLE(ivec2( 1, -1), 1.0 / sqrt(2.0))\n    SAMPLE(ivec2( 1,  0), 1.0)\n    SAMPLE(ivec2( 1,  1), 1.0 / sqrt(2.0))\n    SAMPLE(ivec2( 0,  1), 1.0)\n    SAMPLE(ivec2(-1,  1), 1.0 / sqrt(2.0))\n    SAMPLE(ivec2(-1,  0), 1.0)\n    SAMPLE(ivec2(-1, -1), 1.0 / sqrt(2.0))\n\n#undef SAMPLE\n\n    state.y = state.x;\n    state.x += vel;\n    \n    for (int i = 0; i < EFFECTOR_COUNT; ++i) {\n        vec4 effector = hash41(float(i * 100) + floor(iTime * 10.0));\n        effector *= vec4(1.0, 1.0, 1.0, 0.02);\n        effector += vec4(0.0, 0.0, 0.0, 0.01);\n        float d = smoothstep(effector.w, 1.0 / RESOLUTION, distance(texCoord, effector.xy));\n        state.x += d * effector.z;\n    }\n\n   \tfragColor = state;\n}\n","name":"Buf A","description":"","type":"buffer"}]}