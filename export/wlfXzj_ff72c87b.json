{"ver":"0.1","info":{"id":"wlfXzj","date":"1563550624","viewed":875,"name":"Tumbling Squares","username":"104","description":"They tumblin'","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","aesthetic","hypnosis","chill"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// boilerplate ======================\nconst float PI = 3.14159;\nconst float PI2 = PI*2.;\n\nvec3 dtoa(float d, vec3 amount){\n    return vec3(1. / clamp(d*amount, vec3(1), amount));\n}\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\nfloat nsin(float x) {\n    return cos(x)*.5+.5;\n}\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nfloat opXor(float lhs, float rhs) {\n    return opUnion(opIntersection(lhs, -(rhs)), opIntersection(rhs, -(lhs)));\n}\n\nfloat sdSquare(vec2 p, vec2 center, float s) {\n\tvec2 d = abs(p-center) - s;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n// end boilerplate ======================\n\nconst float th = 1./3.;\nfloat hello(float sd, vec2 uv, float off, float a, vec2 sgn) {\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(.5,.5)+vec2(-off,0)) * rot2D(a), vec2(-th*.5), th*.5));\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(-.5,.5)+vec2(0,-off)) * rot2D(a+PI*.5), vec2(-th*.5), th*.5));\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(.5,-.5)+vec2(0,off)) * rot2D(a-PI*.5), vec2(-th*.5), th*.5));\n    sd = opXor(sd, sdSquare((uv + sgn*vec2(-.5,-.5)+vec2(off,0)) * rot2D(a-PI), vec2(-th*.5), th*.5));\n    return sd;\n}\n\nfloat scurve(float x, float p) {\n    x = x / p * PI2;\n    return (x + sin(x+PI)) / PI2;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    uv *= 2.8;\n    float tsteady = iTime*.25;\n    float t = scurve(tsteady, th);\n    float sd = 1e6;\n    float sdout = 1e6;\n    \n    uv *= rot2D(-tsteady*PI2*.25);\n    float r = .5+(sqrt(2.)*th);\n    uv -= r;\n    float padding = .1; // kinda important because blurriness doesn't cross cells\n    uv = mod(uv, r+r+padding)-r-padding*.5; // repetition\n\n    float seg = mod(t, 3.);\n    float aout = fract(seg)*PI*.5;\n    float ain = -(aout+PI*.5);\n    float offout = 0.;\n    float offin = th*2.;\n    if (seg >= 2.) {\n\t\taout = (fract(seg)-.5)*PI;\n        ain = PI;\n    } else if (seg >= 1.) {\n        offout = th*2.;\n    } else {\n        offout = th;\n        offin = th;\n    }\n\n    float tsel = mod(t/3., 3.);\n    bool A = false, B = false, C = false, D = false;\n    \n    if (tsel >= 2.) {\n    \t// (none)\n    } else if (tsel >= 1.) {\n    \t// (big plus)\n        A = B = true;\n    } else {\n    \t// (minimal + outline)\n        B = C = D = true;\n    }\n    \n    if (A) sd = sdSquare(uv, vec2(0),.5);\n   \tif (B) sd = opXor(sd, sdSquare(uv, vec2(0),r));\n   \tif (C) sd = opXor(sd, sdSquare(uv, vec2(0),r));\n    if (D) sd = hello(sd, uv, offout, aout, vec2(1));\n    \n    sdout = hello(sdout, uv, offout, aout, vec2(1));\n    sd = hello(sd, uv, offout, aout, vec2(1));\n    sd = hello(sd, uv, offin, ain, vec2(1));\n\n    o.rgb = dtoa(sd, 3.*vec3(50.,100.,200.)) * vec3(.9,.9,.8);\n    o.rgb += dtoa(sdout, 2.*vec3(100.,50.,50.)) * vec3(.1,-.8,.4);\n    \n    vec2 N = fragCoord / iResolution.xy-.5;\n\n    o.rgb += (hash32(fragCoord+t)-.5)*.1;\n    o.rgb += dot(N,N) * vec3(.2,.5,1);\n    o = clamp(o,o-o,o-o+1.);\n    o *= 1.-length(9.*pow(abs(N), vec2(3.)));// vingette\n    o.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"}]}