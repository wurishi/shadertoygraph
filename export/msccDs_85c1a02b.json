{"ver":"0.1","info":{"id":"msccDs","date":"1699109337","viewed":18,"name":"TP1_arnau_jutglar","username":"arnau_jutglar","description":"TP1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tol 0.001\n#define INFTY 1e6\n#define OCCLUSION_RADIUS 1.\n#define OCCLUSION_DISCRETIZATION 20\n#define PI 3.14\n#define MAX_REFLECTIONS 3\n#define LIGHT_ORIGIN_1 vec3(0.,-10.,20.)\n#define LIGHT_ORIGIN_2 vec3(0.,-10.,25.)\n#define DIRECTIONAL_LIGHT vec3(1.,-10.,20.)\n#define DIRECTIONAL_LIGHT_2 vec3(1.,10.,-20.)\n\n\n\n\nfloat abs(float x) {\n    if (x > 0.) {\n        return x;\n    } else {\n        return -x;\n    }\n}\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Ellipsoide {\n    vec3 c; // Center\n    vec3 a; // Deformation\n    int i; // Texture Id\n};\n\nstruct Boite {\n    float x1;\n    float x2;\n    float y1;\n    float y2;\n    float z1;\n    float z2;\n    int i;\n};\n\nstruct Cylindre {\n    vec3 c;\n    float r;\n    float l;\n    int i;\n};\n\nstruct Capsule {\n    vec3 c; // Center\n    float r; // Radius\n    float l; // Length\n    int i; // Texture Id\n};\n\nstruct Torus {\n    vec3 c; // Center\n    float r;  \n    float R; \n    int i; // Texture Id\n};\n\nstruct Ray {\n    vec3 o; // Origin\n    vec3 d; // Direction\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n/* Sets t1 < t2 the intersection moments.\n\nReturns \n1 if two positive intersections, \n0 if one positive and one negative, \n-1 if both negative,\n-2 if 1 or 0 intersections.\n\nSets t1 to the first solution and t2 to the second one.\n\nUsed only for internal computations. */\nint computeIntersectSphere(vec3 c, float r, Ray ray, out float t1, out float t2) {\n    float h;\n    \n    h = dot(c - ray.o, c - ray.o) - pow(dot(c - ray.o, ray.d),2.);\n    \n    if (pow(r,2.) > h) {\n    \n        // Two intersections with the sphere (ts1 < t)\n        t1 = dot(c - ray.o, ray.d) - sqrt(pow(r,2.) - h);\n        t2 = dot(c - ray.o, ray.d) + sqrt(pow(r,2.) - h);\n        \n        \n        // See if they are positive or negative\n        if (t2 < 0.) {\n        \n            // The object is behind\n            return -1;\n            \n        } else if (t1 < 0.) {\n        \n            // Then t1 happens behind and t2 in front. \n            return 0;\n            \n        } else {\n        \n            // Both positive\n            return 1;\n        }\n    }\n    \n    return -2;\n}\n        \n// cbrt and solveQuartic extracted from https://www.shadertoy.com/view/fsB3Wt . All credits to oneshade.\n\nfloat cbrt(in float x) { return sign(x) * pow(abs(x), 1.0 / 3.0); }\n\n\nint solveQuartic(in float a, in float b, in float c, in float d, in float e, inout vec4 roots) {\n    b /= a; c /= a; d /= a; e /= a; // Divide by leading coefficient to make it 1\n\n    // Depress the quartic to x^4 + px^2 + qx + r by substituting x-b/4a\n    // This can be found by substituting x+u and the solving for the value\n    // of u that makes the t^3 term go away\n    float bb = b * b;\n    float p = (8.0 * c - 3.0 * bb) / 8.0;\n    float q = (8.0 * d - 4.0 * c * b + bb * b) / 8.0;\n    float r = (256.0 * e - 64.0 * d * b + 16.0 * c * bb - 3.0 * bb * bb) / 256.0;\n    int n = 0; // Root counter\n\n    // Solve for a root to (t^2)^3 + 2p(t^2)^2 + (p^2 - 4r)(t^2) - q^2 which resolves the\n    // system of equations relating the product of two quadratics to the depressed quartic\n    float ra =  2.0 * p;\n    float rb =  p * p - 4.0 * r;\n    float rc = -q * q;\n\n    // Depress using the method above\n    float ru = ra / 3.0;\n    float rp = rb - ra * ru;\n    float rq = rc - (rb - 2.0 * ra * ra / 9.0) * ru;\n\n    float lambda;\n    float rh = 0.25 * rq * rq + rp * rp * rp / 27.0;\n    if (rh > 0.0) { // Use Cardano's formula in the case of one real root\n        rh = sqrt(rh);\n        float ro = -0.5 * rq;\n        lambda = cbrt(ro - rh) + cbrt(ro + rh) - ru;\n    }\n\n    else { // Use complex arithmetic in the case of three real roots\n        float rm = sqrt(-rp / 3.0);\n        lambda = -2.0 * rm * sin(asin(1.5 * rq / (rp * rm)) / 3.0) - ru;\n    }\n\n    // Newton iteration to fix numerical problems (using Horners method)\n    // Suggested by @NinjaKoala\n    for(int i=0; i < 2; i++) {\n        float a_2 = ra + lambda;\n        float a_1 = rb + lambda * a_2;\n        float b_2 = a_2 + lambda;\n\n        float f = rc + lambda * a_1; // Evaluation of 位^3 + ra * 位^2 + rb * 位 + rc\n        float f1 = a_1 + lambda * b_2; // Derivative\n\n        lambda -= f / f1; // Newton iteration step\n    }\n\n    // Solve two quadratics factored from the quartic using the cubic root\n    if (lambda < 0.0) return n;\n    float t = sqrt(lambda); // Because we solved for t^2 but want t\n    float alpha = 2.0 * q / t, beta = lambda + ra;\n\n    float u = 0.25 * b;\n    t *= 0.5;\n\n    float z = -alpha - beta;\n    if (z > 0.0) {\n        z = sqrt(z) * 0.5;\n        float h = +t - u;\n        roots.xy = vec2(h + z, h - z);\n        n += 2;\n    }\n\n    float w = +alpha - beta;\n    if (w > 0.0) {\n        w = sqrt(w) * 0.5;\n        float h = -t - u;\n        roots.zw = vec2(h + w, h - w);\n        if (n == 0) roots.xy = roots.zw;\n        n += 2;\n    }\n\n    return n;\n}\n\n// Gives two vectors generating the orthogonal plane to the input vector.\nvoid plane(vec3 n, out vec3 u, out vec3 v) {\n    if (abs(n.x) > tol) {\n        // First vector (1,0)\n        u.x = -n.y / n.x;\n        u.y = 1.;\n        u.z = 0.;\n        \n        // Second vector (0,1)\n        v.x = -n.z / n.x;\n        v.y = 0.;\n        v.z = 1.;\n\n    } else if (abs(n.y) > tol) {\n        // First vector (1,0)\n        u.x = 1.;\n        u.y = n.x / n.y;\n        u.z = 0.;\n        \n        // Second vector (0,1)\n        v.x = 0.;\n        v.y = n.z / n.y;\n        v.z = 1.;\n    } else {\n        // First vector (1,0)\n        u.x = 1.;\n        u.y = 0.;\n        u.z = n.x / n.z;\n        \n        // Second vector (0,1)\n        v.x = 0.;\n        v.y = 1.;\n        v.z = n.y / n.z;\n    }\n}\n\n\n// Random function\nfloat random(float x) {\n    return fract(sin(5493278.*cos(826471.*x)));\n}\n\nbool intersectionEllipsoide(Ray ray, Ellipsoide el, out Hit x) {\n    // Returns true if there is intersection and no if there isn't. If there is, it is stored in x, which I understand that is a variable passed by reference.\n    float a, b, c, d, t, t1, t2;\n    a = ray.d.x * ray.d.x/(el.a.x * el.a.x) + ray.d.y * ray.d.y/(el.a.y * el.a.y) + ray.d.z * ray.d.z/(el.a.z * el.a.z);\n    b = 2.* ((ray.o.x - el.c.x) * ray.d.x / (el.a.x * el.a.x) + (ray.o.y - el.c.y) * ray.d.y / (el.a.y * el.a.y) + (ray.o.z - el.c.z) * ray.d.z / (el.a.z * el.a.z));\n    c = (ray.o.x - el.c.x) * (ray.o.x - el.c.x) / (el.a.x * el.a.x) + (ray.o.y - el.c.y) * (ray.o.y - el.c.y) / (el.a.y * el.a.y) + (ray.o.z - el.c.z) * (ray.o.z - el.c.z) / (el.a.z * el.a.z) -1.;\n    \n    // We now check if there is an intersection:\n    d = b*b - 4.*a*c;\n    if (d <= 0.0) {\n        return false;\n    } else {\n        t1 = (-b + sqrt(d))/(2.*a);\n        t2 = (-b - sqrt(d))/(2.*a);\n        if (t1 <= 0.0 && t2 <= 0.0) {\n            return false;\n        } else if (t1*t2 < 0.0){\n            t = (t1 > 0.0) ? t1 : t2;\n            x = Hit(t, normalize((Point(ray,t)-el.c)/vec3(el.a.x * el.a.x, el.a.y * el.a.y, el.a.z * el.a.z)), el.i);\n            return true;\n        } else {\n            t = (t1 < t2) ? t1 : t2;\n            x = Hit(t, normalize((Point(ray,t)-el.c)/vec3(el.a.x * el.a.x, el.a.y * el.a.y, el.a.z * el.a.z)), el.i);\n            return true;\n        }\n    }\n}\n\nbool intersectBoite(Ray ray, Boite box, out Hit x) {\n    float tx1, tx2, ty1, ty2, tz1, tz2, t;\n    bool switchX = false, switchY = false, switchZ = false;\n    \n    // Check for tangencies:\n    if (abs(ray.d.x) < tol) {\n        return false;\n    } else if (abs(ray.d.y) < tol) {\n        return false;\n    } else if (abs(ray.d.z) < tol) {\n        return false;\n    }\n    \n    // Compute intersection time with each plane and sort it so t1 < t2.\n    tx1 = (box.x1 - ray.o.x) / ray.d.x;\n    tx2 = (box.x2 - ray.o.x) / ray.d.x;\n    if (tx2 < tx1) {t = tx1; tx1 = tx2; tx2 = t; switchX = true;}\n\n    ty1 = (box.y1 - ray.o.y) / ray.d.y;\n    ty2 = (box.y2 - ray.o.y) / ray.d.y;\n    if (ty2 < ty1) {t = ty1; ty1 = ty2; ty2 = t; switchY = true;}\n\n    tz1 = (box.z1 - ray.o.z) / ray.d.z;\n    tz2 = (box.z2 - ray.o.z) / ray.d.z;\n    if (tz2 < tz1) {t = tz1; tz1 = tz2; tz2 = t; switchZ = true;}\n    \n    // Check if at some time, the ray lies between the six planes.\n    t = max(max(tx1, ty1), tz1);\n    if (t < min(min(tx2, ty2), tz2) && t > 0.) {        \n        vec3 p = Point(ray, t);\n        \n        if (abs(p.x - box.x1) < tol) {\n            x = Hit(t, vec3(-1.,0.,0.), box.i);\n        } else if (abs(p.x - box.x2) < tol) {\n            x = Hit(t, vec3(1.,0.,0.), box.i);\n            \n        } else if (abs(p.y - box.y1) < tol) {\n            x = Hit(t, vec3(0.,-1.,0.), box.i);\n        } else if (abs(p.y - box.y2) < tol) {\n            x = Hit(t, vec3(0.,1.,0.), box.i);\n            \n        } else if (abs(p.z - box.z1) < tol) {\n            x = Hit(t, vec3(0.,0.,-1.), box.i);\n        } else if (abs(p.z - box.z2) < tol) {\n            x = Hit(t, vec3(0.,0.,1.), box.i);\n        }\n        \n        return true;\n    }\n    \n    return false;\n}\n\nbool intersectCylindre(Ray ray, Cylindre cyl, out Hit x) {\n    float t, ts1, ts2, tc1, tc2, a, b, c, d;\n    vec2 origin, direction, center;\n\n    // Check ray not parallel to the planes:\n    if (abs(dot(ray.d,vec3(0,0,1))) < tol) {\n        return false;\n    }\n    \n    // Compute intersection with the covers and sort them so ts1 <= ts2:\n    ts1 = dot(cyl.c - ray.o, vec3(0,0,1)) / dot(ray.d, vec3(0,0,1));\n    ts2 = dot(cyl.c + cyl.l*vec3(0,0,-1) - ray.o, vec3(0,0,1)) / dot(ray.d, vec3(0,0,1));\n    if (ts1 > ts2) {\n        t = ts1;\n        ts1 = ts2;\n        ts2 = t;\n    }\n    \n    // Compute intersection with cylinder:\n    origin = vec2(ray.o.x, ray.o.y);\n    direction = vec2(ray.d.x, ray.d.y);\n    center = vec2(cyl.c.x, cyl.c.y);\n    \n    a = dot(direction, direction);\n    b = 2.*dot(origin - center, direction);\n    c = dot(origin - center, origin - center) - cyl.r*cyl.r;\n    \n    // We now check for solutions:\n    d = b*b - 4.*a*c;\n    if (d <= 0.0) {\n        return false;\n    } else {\n        tc1 = (-b + sqrt(d))/(2.*a);\n        tc2 = (-b - sqrt(d))/(2.*a);\n        if (tc1 > tc2) {\n            t = tc1;\n            tc1 = tc2;\n            tc2 = t;\n        }\n        \n        // Check for intersection condition:\n        t = max(ts1,tc1);\n        if ((t < min(ts2, tc2)) && (t > 0.)) {\n            // Check if it is in one of the covers:\n            if (t == ts1) {\n                // Check if it is the top or the bottom cover:\n                if (Point(ray, ts1).z > Point(ray, ts2).z) {\n                    // Then it is in the top cover.\n                    x = Hit(t, vec3(0,0,1), cyl.i);\n                    return true;\n                } else {\n                    x = Hit(t, vec3(0,0,-1), cyl.i);\n                    return true;\n                }\n            } else {\n                // Then it is in the cylinder.\n                x = Hit(t, normalize(vec3(2.*(Point(ray, t).x - cyl.c.x), 2.*(Point(ray,t).y - cyl.c.y), 0.)), cyl.i);\n                return true;\n            }\n        }   \n    }\n        \n    return false;\n}\n\nbool intersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    float t, ts1, ts2, tc1, tc2, a, b, c, d, h;\n    int res;\n    vec2 origin, direction, center;\n    bool ret1 = false, ret2 = false; // To check for intersections of both semi-spheres\n    \n    res = computeIntersectSphere(cap.c, cap.r, ray, ts1, t);\n    switch (res) {\n        case 1:\n            // Both positive\n            \n            // Check if they happen in the upper half.\n            if ((Point(ray,ts1).z >= cap.c.z) && (Point(ray,t).z >= cap.c.z)) {\n                \n                x = Hit(ts1, normalize(Point(ray, ts1)-cap.c), cap.i);\n                return true;\n            }\n            \n            // Check if at least one happened in the upper half:\n            if (Point(ray,ts1).z >= cap.c.z) {\n                ret1 = true;\n            } else if (Point(ray,t).z >= cap.c.z) {\n                ret1 = true;\n                ts1 = t;\n            }\n\n            break;\n        case 0:\n            // Only one positive: t. Set ts1 to that value:\n            ts1 = t;\n            \n            // Check if it happened in the upper half:\n            if (Point(ray,ts1).z >= cap.c.z) {\n                ret1 = true;\n            }\n            \n            ret1 = true;\n            break;\n        case -1:\n            // Both negative\n            break;\n        case -2:\n            // 1 or 0 solutions\n            break;\n    }\n        // Here, we returned the hit if both happen in the upper half, or put the only one that matters to us in ts1. \n        // If there was a hit in the upper half, ret1 is set to true.\n            \n        res = computeIntersectSphere(cap.c + cap.l * vec3(0,0,-1), cap.r, ray, ts2, t);\n        switch (res) {\n        case 1:\n            // Both positive\n            \n            // Check if they happen in the bottom half.\n            if ((Point(ray,ts2).z <= (cap.c + cap.l * vec3(0,0,-1)).z) && (Point(ray,t).z <= (cap.c + cap.l * vec3(0,0,-1)).z)) {\n                \n                x = Hit(ts2, normalize(Point(ray, ts2)-(cap.c+cap.l*vec3(0,0,-1))), cap.i);\n                return true;\n            }\n            \n            // Check if at least one happened in the bottom half:\n            if (Point(ray,ts2).z <= (cap.c + cap.l * vec3(0,0,-1)).z) {\n                ret2 = true;\n            } else if (Point(ray,t).z <= (cap.c + cap.l * vec3(0,0,-1)).z) {\n                ret2 = true;\n                ts2 = t;\n            }\n            break;\n            \n        case 0:\n            // Only one positive: t\n            \n            \n            // Check if it happened in the bottom half:\n            if (Point(ray,t).z >= (cap.c + cap.l * vec3(0,0,-1)).z) {\n                ret2 = true;\n                ts2 = t;\n            }\n\n            \n            break;\n            \n        case -1:\n            // Both negative\n            \n            break;\n            \n        case -2:\n            // 1 or 0 solutions\n            \n            break;\n    }\n    \n    // Check for ray going through both semi-spheres:\n    if (ret1 && ret2) {\n        // Check which semi-sphere was hitted first\n        if (ts1 < ts2) {\n            // It was the one above\n            x = Hit(ts1, normalize(Point(ray, ts1)-cap.c), cap.i);\n            return true;\n        } else {\n            // It was the one below\n            x = Hit(ts2, normalize(Point(ray, ts2)-cap.c), cap.i);\n            return true;\n        }\n    }\n                    \n    // Compute intersection with cylinder:\n    origin = vec2(ray.o.x, ray.o.y);\n    direction = vec2(ray.d.x, ray.d.y);\n    center = vec2(cap.c.x, cap.c.y);\n    \n    a = dot(direction, direction);\n    b = 2.*dot(origin - center, direction);\n    c = dot(origin - center, origin - center) - cap.r*cap.r;\n    \n    // We now check for solutions:\n    d = b*b - 4.*a*c;\n    if (d <= 0.0) {\n        return false;\n    } else {\n        tc1 = (-b + sqrt(d))/(2.*a);\n        tc2 = (-b - sqrt(d))/(2.*a);\n        if (tc1 > tc2) {\n            t = tc1;\n            tc1 = tc2;\n            tc2 = t;\n        }\n    }\n        \n    // Check for intersection condition:\n    if (tc2 <= 0.) {\n        // Doesn't intersect in positive time with the cylinder. \n        // If we reached this point without any return, there is no hit.\n        return false;\n    } else if (tc1 <= 0.) {\n        // There is just one intersection in positive time. Assign tc2 to tc1.\n        tc1 = tc2;\n\n        // Check if it doesn't belong to the finite cylinder:\n        if ((Point(ray, tc1).z > cap.c.z) || (Point(ray,tc1).z < (cap.c + cap.l*vec3(0,0,-1)).z)) {\n            return false;\n        }\n\n        // If there is hit, it needs to enter/leave from one of the semi-spheres\n        if (ret1 || ret2) {\n            if (ret1) {\n                // Upper. Determinate which one happends first:\n                if (tc1 < ts1) {\n                    x = Hit(tc1, normalize(vec3(Point(ray, tc1).x - cap.c.x, Point(ray,tc1).y - cap.c.y,0)), cap.i);\n                    return true;\n                } else {\n                    x = Hit(ts1, normalize(vec3(Point(ray, ts1).x - cap.c.x, Point(ray,ts1).y - cap.c.y, 0.)), cap.i);\n                    return true;\n                }\n            } else {\n                // Lower. Determinate which one happends first:\n                if (tc1 < ts2) {\n                    x = Hit(tc1, normalize(vec3(Point(ray, tc1).x - cap.c.x, Point(ray,tc1).y - cap.c.y,0)), cap.i);\n                    return true;\n                } else {\n                    x = Hit(ts2, normalize(vec3((Point(ray, ts2).x - cap.c.x), (Point(ray,ts2).y - cap.c.y), 0.)), cap.i);\n                    return true;\n                }\n            }\n        } else {\n            return false;\n        }\n    } else {\n        // Both happen in positive time.\n\n        // Check if the first intersection point belongs to the finite cylinder:\n        if ((Point(ray, tc1).z < cap.c.z) && (Point(ray,tc1).z > (cap.c + cap.l*vec3(0,0,-1)).z)) {\n\n            // Check if the second one does also\n            if ((Point(ray, tc2).z < cap.c.z) && (Point(ray,tc2).z > (cap.c + cap.l*vec3(0,0,-1)).z)) {\n                // Goes through the cylinder\n                x = Hit(tc1, normalize(vec3((Point(ray, tc1).x - cap.c.x), (Point(ray,tc1).y - cap.c.y), 0.)), cap.i);\n                return true;\n\n            } else {\n\n                // It can only go through one of the spheres\n                if (ret1 || ret2) {\n\n                    if (ret1) {\n                        // Upper. Determinate which one happends first:\n                        if (tc1 < ts1) {\n                            x = Hit(tc1, normalize(vec3(2.*(Point(ray, tc1).x - cap.c.x), 2.*(Point(ray,tc1).y - cap.c.y),0)), cap.i);\n                            return true;\n                        } else {\n                            x = Hit(ts1, normalize(vec3((Point(ray, ts1).x - cap.c.x), (Point(ray,ts1).y - cap.c.y), 0.)), cap.i);\n                            return true;\n                        }\n                    } else {\n                        // Lower. Determinate which one happends first:\n                        if (tc1 < ts2) {\n                            x = Hit(tc1, normalize(vec3(2.*(Point(ray, tc1).x - cap.c.x), 2.*(Point(ray,tc1).y - cap.c.y),0)), cap.i);\n                            return true;\n                        } else {\n                            x = Hit(ts2, normalize(vec3((Point(ray, ts2).x - cap.c.x), (Point(ray,ts2).y - cap.c.y), 0.)), cap.i);\n                            return true;\n                        }\n                    }\n                } else {\n                    return false;\n                }\n            }\n        } else if ((Point(ray, tc2).z < cap.c.z) && (Point(ray,tc2).z > (cap.c + cap.l*vec3(0,0,-1)).z)) {\n            // Then the first point doesn't belong but the second one does. Set tc1 to tc2:\n            tc1 = tc2;\n\n            // It can only go through one of the spheres\n            if (ret1 || ret2) {\n\n                if (ret1) {\n                    // Upper. Determinate which one happends first:\n                    if (tc1 < ts1) {\n                        x = Hit(tc1, normalize(vec3(Point(ray, tc1).x - cap.c.x, Point(ray,tc1).y - cap.c.y,0.)), cap.i);\n                        return true;\n                    } else {\n                    \n                        x = Hit(ts1, normalize(vec3((Point(ray, ts1).x - cap.c.x), (Point(ray,ts1).y - cap.c.y), 0.)), cap.i);\n                        return true;\n                    }\n                } else {\n                    // Lower. Determinate which one happends first:\n                    if (tc1 < ts2) {\n                        x = Hit(tc1, normalize(vec3(Point(ray, tc1).x - cap.c.x, Point(ray,tc1).y - cap.c.y,0)), cap.i);\n                        return true;\n                    } else {\n                    \n                        x = Hit(ts2, normalize(vec3((Point(ray, ts2).x - cap.c.x), (Point(ray,ts2).y - cap.c.y), 0.)), cap.i);\n                        return true;\n                    }\n                }\n            } else {\n                return false;\n            }\n        }\n    }\n            \n        \n    return false;\n}\n\nbool intersectTorus(Ray ray, Torus tor, out Hit x) {\n    //float a, b, c, d, e, alpha, beta, gamma, delta, sigma, \n    float w, t = INFTY;\n    vec3 point;\n    int nroots;\n    vec4 roots;\n    \n    // Find the coefficients of the quartic equation on t. All credits to @oneshade .\n    float oo = dot(ray.o, ray.o);\n    float dd = dot(ray.d, ray.d);\n    float od = dot(ray.o, ray.d);\n\n    float tt = tor.r * tor.r, rr = tor.R * tor.R;\n    float oottrr = oo - tt - rr;\n        \n    float a = dd * dd;\n    float b = 4.0 * dd * od;\n    float c = 2.0 * dd * oottrr + 4.0 * (od * od + rr * ray.d.z * ray.d.z);\n    float d = 4.0 * od * oottrr + 8.0 * rr * ray.o.z * ray.d.z;\n    float e = oottrr * oottrr - 4.0 * rr * (tt - ray.o.z * ray.o.z);\n\n    roots = vec4(-1.,-1.,-1.,-1.);\n    solveQuartic(a,b,c,d,e,roots);\n    for (int i=0; i < 4; i++) {\n        if ((roots[i] > 0.) && (roots[i] < t)) {\n            t = roots[i];\n        }\n    }\n\n    if (t == INFTY) {\n        return false;\n    } else {\n        // Return the hit\n        point = Point(ray, t);\n        w = sqrt(point.x * point.x + point.y * point.y);\n        w = -2. * (tor.R - w) / w;\n        x = Hit(t, normalize(vec3(point.x * w, point.y * w, 2. * point.z)), tor.i);\n        return true;\n    }\n    \n    \n    return false;\n}\n\n/* Rays afine transformations */\n\n// Rotation\nRay rotateRay(Ray ray, float rotx, float roty, float rotz) {\n    Ray ray2;\n    \n    // Origin\n    \n    ray2.o.x = cos(roty)*cos(rotz)*ray.o.x - cos(roty)*sin(rotz)*ray.o.y + sin(roty)*ray.o.z;\n    ray2.o.y = (sin(rotx)*sin(roty)*cos(rotz) + cos(rotx)*sin(rotz))*ray.o.x + (cos(rotx)*cos(rotz) - sin(rotx)*sin(roty)*sin(rotz))*ray.o.y + (- sin(rotx)*cos(roty))*ray.o.z;\n    ray2.o.z = (sin(rotx)*sin(rotz) - cos(rotx)*sin(roty)*cos(rotz))*ray.o.x + (cos(rotx)*sin(roty)*sin(rotz) + sin(rotx)*cos(rotz))*ray.o.y + (cos(rotx)*cos(roty))*ray.o.z;\n    \n    \n    //ray2.o = ray.o;\n    \n    // Direction\n    ray2.d.x = cos(roty)*cos(rotz)*ray.d.x - cos(roty)*sin(rotz)*ray.d.y + sin(roty)*ray.d.z;\n    ray2.d.y = (sin(rotx)*sin(roty)*cos(rotz) + cos(rotx)*sin(rotz))*ray.d.x + (cos(rotx)*cos(rotz) - sin(rotx)*sin(roty)*sin(rotz))*ray.d.y + (- sin(rotx)*cos(roty))*ray.d.z;\n    ray2.d.z = (sin(rotx)*sin(rotz) - cos(rotx)*sin(roty)*cos(rotz))*ray.d.x + (cos(rotx)*sin(roty)*sin(rotz) + sin(rotx)*cos(rotz))*ray.d.y + (cos(rotx)*cos(roty))*ray.d.z;\n\n    return ray2;\n}\n\nvec3 rotateVector(vec3 v, float rotx, float roty, float rotz) {\n    vec3 u;\n    \n    u.x = cos(roty)*cos(rotz)*v.x - cos(roty)*sin(rotz)*v.y + sin(roty)*v.z;\n    u.y = (sin(rotx)*sin(roty)*cos(rotz) + cos(rotx)*sin(rotz))*v.x + (cos(rotx)*cos(rotz) - sin(rotx)*sin(roty)*sin(rotz))*v.y + (- sin(rotx)*cos(roty))*v.z;\n    u.z = (sin(rotx)*sin(rotz) - cos(rotx)*sin(roty)*cos(rotz))*v.x + (cos(rotx)*sin(roty)*sin(rotz) + sin(rotx)*cos(rotz))*v.y + (cos(rotx)*cos(roty))*v.z;\n    \n    return u;\n}\n\n// Translation\nRay translateRay(Ray ray, vec3 delta) {\n    Ray ray2;\n    \n    ray2.o = ray.o + delta;\n    ray2.d = ray.d;\n    \n    return ray2;\n}\n\nvec3 translateVector(vec3 v, vec3 delta) {\n    vec3 u;\n    \n    u = u + delta;\n    \n    return u;\n}\n\n// Homotecy\nRay homotecyRay(Ray ray, float hx, float hy, float hz) {\n    Ray ray2;\n    \n    // Origin\n    ray2.o.x = ray.o.x * hx;\n    ray2.o.y = ray.o.y * hy;\n    ray2.o.z = ray.o.z * hz;\n        \n    // Direction\n    ray2.d.x = ray.d.x * hx;\n    ray2.d.y = ray.d.y * hy;\n    ray2.d.z = ray.d.z * hz;\n    \n    ray2.d = normalize(ray2.d);\n\n    return ray2;\n}\n\nvec3 homotecyVector(vec3 v, float hx, float hy, float hz) {\n    vec3 u;\n    \n    u.x = v.x * hx;\n    u.y = v.y * hy;\n    u.z = v.z * hz;\n    \n    return u;\n}\n\n\nstruct Material\n{\n    vec3 a; // Ambient\n    vec3 d; // Diffuse\n    vec3 s; // Specular\n    bool reflecting; // If reflecting or not.\n};\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\nMaterial Damier(float x, vec3 p) {\n    int c = int(p.x / x) + int(p.y / x) + int(p.z / x);\n    c = c % 2;\n    Material mat = Material(vec3(0.1,0.1,0.1),vec3(c,c,c),vec3(0.,0.,0.), false);\n    \n    return mat;\n}\n\n// Returns damier alternating specular and diffuse materials.\nMaterial Damier2(vec3 p) {\n    int c = int(p.x) + int(p.y) + int(p.z);\n    c = c % 2;\n    \n    //return Material(vec3(0.),vec3(0.),vec3(0.),false);\n\n    \n    if (c == 0) {\n        // Diffuse\n        return Material(vec3(0.1,0.1,0.1), vec3(0.5,0.,0.), vec3(0.,0.,0.), false);\n    } else {\n        return Material(vec3(0.1,0.1,0.1), vec3(0.,0.,0.), vec3(0.,0.,0.8), false);\n    }\n}\n\n/*Material Damier2(vec3 p) {\n    int c = int(p.x) + int(p.y) + int(p.z);\n    c = c % 2;\n    \n    return Material(vec3(0.),vec3(0.),vec3(0.),false);\n}*/\n\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Material(vec3(0.1,0.1,0.1),vec3(.8,.5,.4),vec3(0.,0.,0.), false);\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(vec3(0.1,0.1,0.1),col,vec3(0.,0.,0.), false);\n        \n    } else if (i==2) {\n        // Radial with respect to the center (0,0,0)\n        float d = length(p);\n        return Material(vec3(0.1,0.1,0.1),vec3(sin(2.*d)*sin(2.*d), cos(2.*d)*cos(2.*d), sin(1.+2.*d) * sin(1.+2.*d)),vec3(0.1,0.1,0.1), false);\n        \n    } else if (i==3) {\n        // radial with respect to the z-axis.\n        return Material(vec3(0.1,0.1,0.1),vec3(sin(1.+3.*p.z) * sin(1.+3.*p.z), cos(3.*p.z) * cos(3.*p.z), sin(3.*p.z) * sin(3.*p.z)),vec3(0.1,0.1,0.1), false);\n        \n    } else if (i==4) {\n        return Material(vec3(0.1,0.1,0.1),vec3(random(p.x), random(p.y), random(p.z)),vec3(0.,0.,0.), false);\n        \n    } else if (i==5) {\n        // Fusta clara:\n        vec3 clara = vec3(1., .98, .5);\n        \n        // Fusta fosca:\n        vec3 fosca = vec3(.88, .76, .5);\n        \n        // Combinaci贸 entre les dues:\n        vec3 comb = sin(10.*p.z) * clara + (1.-sin(10.*p.z)) * fosca * random(p.x);\n        \n        return Material(vec3(0.1,0.1,0.1),comb,vec3(0.1,0.1,0.1), false);\n    } else if (i==6) {\n        // Damier\n        return Damier(0.8, p);\n    } else if (i==7) {\n        // Grey with specular\n        return Material(vec3(0.1,0.1,0.1),vec3(0.5,0.5,0.5), vec3(0.7,0.7,0.7), false);\n    } else if (i==8) {\n        // Damier alternating diffuse and speculare.\n        return Damier2(p);\n    } else if (i==9) {\n        // Pearl\n        return Material(vec3(0.1,0.1,0.1),vec3(0.7,0.7,0.7), vec3(fract(p.x),fract(p.y),fract(p.z)), false);\n    } else if (i==10) {\n        return Material(vec3(0.1,0.1,0.1),vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),true);\n    }\n    return Material(vec3(0.1,0.1,0.1),vec3(0),vec3(0.,0.,0.), false);\n}\n\n// Old IntersectSphere function\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        \n        x=Hit(t,vec3(0,0,1),0);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph=Sphere(vec3(10.,3.,1.),2.,9);\n    const Sphere sph1=Sphere(vec3(-11.,7.,3.),3.5,10);\n    const Sphere sph2=Sphere(vec3(-3.,-5.,1.),0.5,9);\n    const Ellipsoide el = Ellipsoide(vec3(5.,3.,1.), vec3(2.,1.,1.7),2);\n    const Boite box = Boite(0.,2., 2., 4., 0.2, 2., 6);\n    const Boite box1 = Boite(-4.,-2.,-4.,-2.,0.,2.,10);\n    const Boite box2 = Boite(-4.,-2.,-7.,-6.,0.,2.,10);\n    const Cylindre cyl = Cylindre(vec3(-2.5,3.,2.),1.3,1.8,3);\n    const Capsule cap = Capsule(vec3(-6.,3.,1.4),1.,1.,8);\n    const Torus tor = Torus(vec3(0.,0.,0.), 1.5, 3., 4);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),0);\n\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    /*if(IntersectSphere(homotecyRay(ray, .5, .5, .5), sph1,current)&&current.t * 2. <x.t){\n        current.t = current.t * 2.;\n        x=current;\n        ret=true;\n    }*/\n    \n    if(IntersectSphere(ray,sph,current) && current.t <x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(rotateRay(ray,sin(iTime),0.,0.),sph1,current) && current.t <x.t){\n        current.n = rotateVector(current.n,-sin(iTime),0.,0.);\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectSphere(ray,sph2,current) && current.t <x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if (intersectionEllipsoide(ray, el, current)&&current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if(intersectBoite(ray,box,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(intersectBoite(ray,box1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    if(intersectBoite(ray,box2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n\n    \n    if (intersectCylindre(ray,cyl,current)&&current.t < x.t) {\n        x=current;\n        ret=true;\n    }\n    \n    if (intersectCapsule(ray, cap, current)&&current.t < x.t) {\n        x=current;\n        ret=true;\n    }\n    \n    if (intersectTorus(rotateRay(translateRay(ray, vec3(0., -8., -6.)),-1.,0.,0.), tor, current)&&current.t < x.t) {\n        current.n = rotateVector(current.n,1.,0.,0.);\n        x=current;\n        ret=true;\n    }\n    \n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    \n    return ret;\n}\n\n// Shadow map\nbool IntersectShadow(Ray ray,out Hit x) {\n    return Intersect(ray, x);\n}\n\n// Returns 1 if shade and 0 otherwise.\nint PointShade(vec3 p, vec3 n, vec3 lightOrigin) {\n    vec3 lightDirection = normalize(lightOrigin - p); // Ray that should hit the intersection point.\n    Ray light = Ray(p + tol * n, lightDirection);\n    Hit xShadow;\n\n    // Is it in the shadow?\n    \n    if (IntersectShadow(light,xShadow) && xShadow.t > 0.) {\n        return 1;\n    }\n\n        \n    return 0;\n}\n\nint DirectionShade(vec3 p, vec3 n, vec3 lightDirection) {\n    lightDirection = normalize(-lightDirection);\n    Ray light = Ray(p + tol * n, lightDirection);\n    Hit xShadow;\n    \n    // Is it in the shadow?\n    \n    if (IntersectShadow(light,xShadow) && xShadow.t > 0.) {\n        return 1;\n    }\n\n        \n    return 0;\n}\n    \n\n// Returns the ambient occlusion factor\nfloat AmbientOcclusion(vec3 p, vec3 n) {\n    vec3 u, v; // The vectors generating the tangent plane to the point\n    plane(n, u, v);\n    vec3 w; // The vector we'll test to intersect or not with the scene\n    int total=0, intersect=0;\n    \n    float h = 2. / float(OCCLUSION_DISCRETIZATION);\n    \n    for (float i = -1. +h ; i <= 1. -h; i += h) {\n        for (float j = 0. +h; j <= 1. -h; j += h) {\n            w = normalize(cos(i * PI) * u + sin(i * PI) * v + sin(j * PI / 2.) * n);\n            Ray ray = Ray(p + tol * n, w);\n            Hit x;\n            total++;\n            if (Intersect(ray, x) && x.t > 0. && x.t < OCCLUSION_RADIUS) {\n                // Then a ray hitted some object inside the occlusion radius.\n                intersect++;\n            }\n        }\n    }\n                \n    return float(total - intersect) / float(total);\n}\n\n\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n, vec3 view)\n{    \n    vec3 light=normalize(DIRECTIONAL_LIGHT);\n    \n    // Reflected light\n    vec3 refl = normalize(light - 2.*dot(light,n)*n);\n    \n    // Diffuse factor\n    float diff=clamp(dot(n,light),0.,1.);\n    \n    // Specular factor\n    float spec= pow(clamp(dot(refl,view),0.,1.),2.);\n    \n    // Resulting color\n    vec3 col=m.a + m.d*diff + m.s*spec + vec3(0.1,0.1,0.1);\n        \n    return col;\n}\n\n// Rendering\nvec3 Shade(Ray ray, vec3 view)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx=Intersect(ray,x);\n    int shades=0; // Counts shades\n        \n    if(idx) {\n        vec3 p=Point(ray,x.t);\n        Material mat = Texture(p, x.i);\n                \n        if (mat.reflecting) {\n            // Relaunch ray tracer from the intersection point in the reflecting direction.\n            vec3 oldDirection = ray.d, oldNormal = x.n, oldPoint = p;\n            bool flag=false, newIsReflecting=true;\n            int iter=0;\n            \n            while (iter < MAX_REFLECTIONS && !flag && newIsReflecting) {\n                iter++;\n                \n                vec3 reflectingDirection = normalize(oldDirection - 2. * dot(oldDirection, oldNormal) * oldNormal);\n                Ray reflectingRay = Ray(oldPoint, reflectingDirection);\n                Hit reflectingHit;\n                \n                if (Intersect(reflectingRay, reflectingHit)) {\n                \n                    // Then the texture of the actual hit will be their average.\n                    vec3 reflectedPoint = Point(reflectingRay, reflectingHit.t);\n                    Material reflectedMaterial = Texture(reflectedPoint, reflectingHit.i);\n\n                    mat.a = (mat.a + reflectedMaterial.a) / 2.;\n                    mat.d = (mat.d + 3.*reflectedMaterial.d) / 4.;\n                    mat.s = (mat.s + 3.*reflectedMaterial.s) / 4.;\n                    \n                    oldDirection = reflectingDirection;\n                    oldNormal = reflectingHit.n;\n                    oldPoint = reflectedPoint;\n                    \n                    newIsReflecting = reflectedMaterial.reflecting;\n                    \n                } else {\n                \n                    // Then, the reflection goes to the sky.\n                    vec3 sky = Background(ray.d);\n                    mat.a = mat.a;\n                    mat.d = (mat.d + sky) / 2.;\n                    mat.s = mat.s;\n                    \n                    // To show that we won't have more reflections.\n                    flag = false;\n                } \n            }\n        }\n        \n\n        // Intersect for shadows\n        vec3 lightOrigin=LIGHT_ORIGIN_1; // Punctual light\n        vec3 lightOrigin2=LIGHT_ORIGIN_2; // Punctual light\n        vec3 lightDirection=DIRECTIONAL_LIGHT_2; // Directional light\n\n        shades += PointShade(p, x.n, lightOrigin);\n        shades += PointShade(p, x.n, lightOrigin2);\n        shades += DirectionShade(p, x.n, lightDirection);\n        \n        for (int i=0; i < shades; i++) {\n            mat.a /= 2.;\n            mat.d /= 2.;\n            mat.s /= 2.;\n        }\n        \n        // Ambient occlusion\n        float occlusionFactor = AmbientOcclusion(p, x.n);\n        \n        mat.a *= occlusionFactor;\n        mat.d *= occlusionFactor;\n        mat.s *= occlusionFactor;\n        \n        return Color(mat,x.n, view);\n    } else {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // View vector\n    vec3 view = normalize(ta - ro);\n\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd), view);\n    \n    fragColor=vec4(col,1.);\n    \n}","name":"Image","description":"","type":"image"}]}