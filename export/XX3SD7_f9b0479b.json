{"ver":"0.1","info":{"id":"XX3SD7","date":"1719343828","viewed":137,"name":"Geode BG","username":"croozington","description":"The background found on https://geode-sdk.org & the in-game modlist!\n\n(Also my first shader :D I know it's unoptimised and kinda scuffed but I'm too lazy to fix)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["geode","gd","geometrydash","geometrydash","geodesdk","gdmodding","menushaders","matcool","config","rooot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Table legs (sets up stuff for tables)\nconst int waveCount = 5; // Recommended: 5\nvec3 waveColour[waveCount];\nfloat waveOffset[waveCount];\nfloat sineWave[waveCount * 5];\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n\n{\n    // Big ol' table - All of the colours used, stored as RGB values\n    waveColour[0] = vec3(0.961, 0.682, 0.490); // Pastel light orange\n    waveColour[1] = vec3(0.925, 0.537, 0.486); // Pastel pinky orange\n    waveColour[2] = vec3(0.835, 0.412, 0.522); // Pastel pink\n    waveColour[3] = vec3(0.678, 0.329, 0.573); // Pastel purple\n    waveColour[4] = vec3(0.443, 0.290, 0.604); // Pastel bluey purple\n    \n    // Table 2: Electric Boogaloo - All of the heights of the waves\n    waveOffset[0] = 0.8; // Recommended: 0.8\n    waveOffset[1] = 0.64; // Recommended: 0.64\n    waveOffset[2] = 0.48; // Recommended: 0.48\n    waveOffset[3] = 0.32; // Recommended: 0.32\n    waveOffset[4] = 0.16; // Recommended: 0.16\n    \n    // Not a table wowie - Variables that affect the shape of all waves\n    float waveAmplitude = 0.05; // Recommended: 0.05\n    float waveLength = -10.0; // Recommended: -10.0\n    float waveSlowdown = 3.0; // Recommended: 3.0\n    float transitionSmoothness = 0.002; // Recommended: 0.002\n\n    // Normalise coordinates from 0 <> 1\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sets the background colour (used at the top)\n    vec3 finalColour = vec3(0.956, 0.831, 0.557);\n    \n    // Creates individual waves\n    for (float i = 0.0; i < float(waveCount); i++) {\n        \n        // Table 3: It's back and smellier than ever - Groups of 5 are averaged and used to make each wave you see\n        // Group 1\n        sineWave[0] = waveAmplitude * 1.0 * sin (waveLength * 1.0 * uv.x + (iTime / waveSlowdown));\n        sineWave[1] = waveAmplitude * 2.1 * sin (waveLength * 1.21 * uv.x + (iTime / waveSlowdown));\n        sineWave[2] = waveAmplitude * 1.2 * sin (waveLength * 1.337 * uv.x + (iTime / waveSlowdown));\n        sineWave[3] = waveAmplitude * 1.3 * sin (waveLength * 1.69 * uv.x + (iTime / waveSlowdown));\n        sineWave[4] = waveAmplitude * 1.9 * sin (waveLength * 0.6 * uv.x + (iTime / waveSlowdown));\n        // Group 2\n        sineWave[5] = waveAmplitude * 2.2 * sin (waveLength * 1.2 * uv.x + (iTime / waveSlowdown / 2.0));\n        sineWave[6] = waveAmplitude * 1.2 * sin (waveLength * 3.2 * uv.x + (iTime / waveSlowdown / 2.0));\n        sineWave[7] = waveAmplitude * 2.1 * sin (waveLength * 0.75 * uv.x + (iTime / waveSlowdown / 2.0));\n        sineWave[8] = waveAmplitude * 1.23 * sin (waveLength * 1.43 * uv.x + (iTime / waveSlowdown / 2.0));\n        sineWave[9] = waveAmplitude * 0.22 * sin (waveLength * 0.56 * uv.x + (iTime / waveSlowdown / 2.0));\n        // Group 3\n        sineWave[10] = waveAmplitude * 1.3 * cos (waveLength * 1.2 * uv.x + (iTime / waveSlowdown / 1.5));\n        sineWave[11] = waveAmplitude * 1.7 * cos (waveLength * 2.5 * uv.x + (iTime / waveSlowdown / 1.5));\n        sineWave[12] = waveAmplitude * 1.1 * cos (waveLength * 1.1 * uv.x + (iTime / waveSlowdown / 1.5));\n        sineWave[13] = waveAmplitude * 1.43 * cos (waveLength * 1.6 * uv.x + (iTime / waveSlowdown / 1.5));\n        sineWave[14] = waveAmplitude * 2.3 * cos (waveLength * 0.2 * uv.x + (iTime / waveSlowdown / 1.5));\n        // Group 4\n        sineWave[15] = waveAmplitude * 1.6 * cos (waveLength * 2.54 * uv.x + (iTime / waveSlowdown / 3.0));\n        sineWave[16] = waveAmplitude * 1.31 * cos (waveLength * 1.02 * uv.x + (iTime / waveSlowdown / 3.0));\n        sineWave[17] = waveAmplitude * 2.02 * cos (waveLength * 0.92 * uv.x + (iTime / waveSlowdown / 3.0));\n        sineWave[18] = waveAmplitude * 2.65 * cos (waveLength * 0.43 * uv.x + (iTime / waveSlowdown / 3.0));\n        sineWave[19] = waveAmplitude * 1.92 * cos (waveLength * 0.2 * uv.x + (iTime / waveSlowdown / 3.0));\n        // Group 5 (- iTime reverses direction)\n        sineWave[20] = waveAmplitude * 0.8 * sin (waveLength * 1.52 * uv.x + (- iTime / waveSlowdown));\n        sineWave[21] = waveAmplitude * 1.4 * cos (waveLength * 0.97 * uv.x + (- iTime / waveSlowdown));\n        sineWave[22] = waveAmplitude * 1.2 * sin (waveLength * 1.23 * uv.x + (- iTime / waveSlowdown));\n        sineWave[23] = waveAmplitude * 0.7 * cos (waveLength * 0.83 * uv.x + (- iTime / waveSlowdown));\n        sineWave[24] = waveAmplitude * 1.0 * sin (waveLength * 1.00 * uv.x + (- iTime / waveSlowdown));\n        \n        // Start drawing some waves :O\n        float sum = 0.0;\n        for (float j = 0.0; j < float(waveCount); j++) {\n            sum += sineWave[int(int(j) + int(5) * int(i))]; // Adds together group of waves\n        }\n        float finalWave = (sum / float(waveCount)) + waveOffset[int(i)]; // Averages waves\n        if (uv.y < (finalWave)) // Checks for area below averaged wave\n        {\n            // Makes the transitions between colours less sharp\n            finalColour = mix(finalColour, waveColour[int(i)], smoothstep(finalWave, finalWave - transitionSmoothness, uv.y));\n        }\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(finalColour, 1.0);\n}","name":"Image","description":"","type":"image"}]}