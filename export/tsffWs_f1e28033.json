{"ver":"0.1","info":{"id":"tsffWs","date":"1589363482","viewed":117,"name":"Grid of cross demo","username":"benpigchu","description":"My first SDF ray marching thing.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 quaternion(vec3 axis,float angle){\n\tfloat halfang=angle/2.;\n    return vec4(axis*sin(halfang),cos(halfang));\n}\n\nvec4 quaternionMultiply(vec4 q1,vec4 q2){\n\treturn vec4(q1.xyz*q2.w+q1.w*q2.xyz+cross(q1.xyz,q2.xyz),q1.w*q2.w-dot(q1.xyz,q2.xyz));\n}\n\nvec3 rotation(vec4 q,vec3 pos){\n\treturn pos+2.*cross(q.xyz,cross(q.xyz,pos)+q.w*pos);\n}\n\n//Note: we need dimension.x > dimension.y here\nfloat sdfCross(vec2 dimension,vec3 p){\n    vec3 xmaxP=abs(p);\n    xmaxP=xmaxP.x<xmaxP.y?xmaxP.yzx:xmaxP;\n    xmaxP=xmaxP.x<xmaxP.y?xmaxP.yzx:xmaxP;\n    xmaxP=xmaxP.x<xmaxP.z?xmaxP.zxy:xmaxP;\n    vec3 diff=xmaxP-dimension.xyy;\n    float maxdiff=max(max(diff.x,diff.y),diff.z);\n    vec3 connection=maxdiff>0.?diff:vec3(0.,-maxdiff,dimension.y-xmaxP.x);\n\treturn sign(maxdiff)*length(max(connection,0.));\n}\n\nfloat sdfcell(vec3 p,vec2 cell){\n    vec4 qUpDown=quaternion(vec3(1,0,0),radians(-cell.y*30.));\n    vec4 qLeftRight=quaternion(vec3(0,0,1),radians(iTime*10.+cell.x*30.));\n    vec4 q=quaternionMultiply(qLeftRight,qUpDown);\n\treturn sdfCross(vec2(0.9,0.3),rotation(q,p))+.1;\n}\n\nfloat sdf(vec3 p){\n    vec2 cell=floor((p.xz/2.0));\n    vec2 offset=fract((p.xz/2.0))*2.;\n\treturn min(min(sdfcell(vec3(offset.x,p.y,offset.y),cell+vec2(0.,0.)),\n              sdfcell(vec3(offset.x-2.,p.y,offset.y),cell+vec2(1.,0.))),min(\n              sdfcell(vec3(offset.x,p.y,offset.y-2.),cell+vec2(0.,1.)),\n              sdfcell(vec3(offset.x-2.,p.y,offset.y-2.),cell+vec2(1.,1.))));\n    //return length(p)-1.0;\n}\n\nvec3 rayDirection(in vec2 fragCoord){\n    float zoom=0.6;\n    vec2 offset=fragCoord/iResolution.xy-0.5;\n    offset.y/=iResolution.x/iResolution.y;\n    vec3 rawDir=vec3(offset/zoom,-1);\n    vec2 mouseAngles=iMouse.xy/iResolution.xy-0.5;\n    vec4 qUpDown=quaternion(vec3(1,0,0),radians(90.+mouseAngles.y*10.0));\n    vec4 qLeftRight=quaternion(vec3(0,0,1),radians(0.-mouseAngles.x*10.0));\n    vec4 q=quaternionMultiply(qLeftRight,qUpDown);\n    return normalize(rotation(q,rawDir));\n}\n\n#define delta 0.00025\nvec3 normal(vec3 pos){\n    vec2 e=vec2(1.,-1.);\n    vec3 rawNormal=e.xxx*sdf(pos+delta*e.xxx);\n    rawNormal+=e.xyy*sdf(pos+delta*e.xyy);\n    rawNormal+=e.yyx*sdf(pos+delta*e.yyx);\n    rawNormal+=e.xxx*sdf(pos+delta*e.xxx);\n    return normalize(rawNormal);\n}\n\n#define iteration 128\nvec3 rayMarching(vec3 start,vec3 dir){\n    float tmin=(-1.0-start.y)/dir.y;\n    vec3 pos=tmin*dir+start;\n    float t=tmin;\n    if(tmin<0.){\n        return pos;\n    }\n    for(int i=0;i<iteration;i++){\n        float step1=sdf(pos);\n        if(abs(step1)<.000001*t){\n        \treturn pos;\n        }\n        t+=step1;\n        pos=t*dir+start;\n    }\n    return pos;\n}\n\nfloat lighting(vec3 pos){\n    vec3 light=vec3(0.+sin(2.*iTime),-2.0,0.-cos(2.*iTime));\n    float diffuse=clamp(dot(normalize(light-pos),normal(pos)),0.,1.);\n\treturn diffuse*.5+.5;\n}\n\nvec3 color(vec3 pos){\n\treturn pos.y>1.?vec3(0,0,0):vec3(1.,.5,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPos=vec3(0.+.25*sin(iTime),-8.0,0.-.25*cos(iTime));\n    vec3 dir=rayDirection(fragCoord);\n    vec3 pos=rayMarching(cameraPos,dir);\n    fragColor =vec4(lighting(pos)*color(pos),1);\n}","name":"Image","description":"","type":"image"}]}