{"ver":"0.1","info":{"id":"3lyXW1","date":"1582653644","viewed":120,"name":"Sky Shader Test","username":"GhostHunter_713","description":"    A shader I did for a class Project. Wanted to generate a sun arcing across the sky with some clouds moving across\nthe screen. The project is a combination of a few tutorials and other shaders.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test","cycle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\n\n/*\n * Structure for a ray that will hold values for constructing a sun object for the shader\n */\nstruct ray{\n vec3 ori, dir;   \n};\n\n\n    /*\n\t * A function that constructs the ray structure to generate the sun piece\n\t *\n     * Takes in: uv = 2D coordinates of the viewer, camPos = camera psoition in 3D space, \n     *          viewDir = the direction of the camera, zoom = the perceived disstance from the camera to the ray\n     */\n\tray getRay(vec2 uv, vec3 camPos, vec3 viewDir, float zoom){\n        ray z;\t                                         // The ray we will return\n    \n        z.ori = camPos; \t                             // Set the origin at the camera position\n    \n        vec3 forwardv = normalize(viewDir-camPos);\n        vec3 right = cross(vec3(0.,1.,0.), forwardv);\t// world vector = vec3(0.,1.,0)\n   \t\tvec3 up = cross (forwardv, right);\t\t\t\t// camera up vector\n    \n    \tvec3 centre = z.ori + forwardv*zoom;\t\t\t\t// centre of the screen position\n    \tvec3 intersect = centre + uv.x*right + uv.y*up;\n    \n    \tz.dir = normalize(intersect-z.ori);\t\t\t\t// calculate direction\n    \n    \treturn z;       \n\t}\n\n\n/* Get the closest point from a point in space to the ray\n*\n* ray r = a ray with an origin and direction, vec3 p = a point in space\n*/\nvec3 closestPoint(ray r, vec3 p){\n\treturn r.ori + max(0., dot(p-r.ori, r.dir))*r.dir;\n}\n\n\n/*\n* Get the length between the ray and point p \n*\n* ray r = a ray with an origin and direction, vec3 p = a point in space\n*/\nfloat disRay(ray r, vec3 p){\n    return length(p-closestPoint(r,p));\t// Closestpoint calculates the closest point between r and p    \n}\n\n/*\nfloat Circle(vec2 uv, vec2 p, float r, float blur){\n \tfloat d = length(uv-p);\n    float c = smoothstep(r, r-blur, d);\n    \n    return c;\n}\n*/\n\n\n/* Creates a circle object that is brighter on the edge than the centre \n *\n * Takes: r = a ray, p = a position in space, size = float for the size of the circle, b = the amount of blur around the circle\n */\nfloat bokeh(ray r, vec3 p, float size, float blur){\n    float dist = disRay(r, p);\t\t// distance variable\n    \n    float c = smoothstep(size, size*(1.-blur), dist);\n    c *= mix(.6, 1., smoothstep(size*.8, size, dist));\n    \n    return c;\n}\n\n\n/* Make a sun object and return its value\n *\n * Takes: uv = 2D coords of the screen, camPos = the position of the camera, time = the time from iTime\n *      ti = fract(time), z = the position of the sun object in the z plane, blur = amount of blur around the sun object\n *      size = the size of the sun object to be generated\n */\nfloat sun(vec2 uv, vec3 camPos, vec3 viewDir, float time, float ti, float z, float blur, float size){\n    ray r;\n    \n    r = getRay(uv, camPos, viewDir, 2.); // Make the ray for the object\n    \n    vec3 sunPos = vec3(6.5-ti*15.,0.8*sin(4. *ti) - 0.5, z); // Positions the sun\n    \n    float c = bokeh(r, sunPos, size*abs(10. - time*.01)*.1, blur); // Make the Sun object\n    \n    return c;\n}\n\n\n/*\n * Generates the sky colour band around the sun object\n */\nfloat skyBand(float f, float start, float end, float blur){\n    float band = smoothstep(end+blur, end-blur, f);\n    \n    return band;\n}\n\n\n/*\n * Constructs all the indivdual sun components and add them together \n *\n * Takes in: uv = coordinates of the viewer, camPos = position of the camera in 3D Space,\n *           time = iTime, ti = fract(time)\n *\n * Also; Do you even Praise?\n */\nvec3 PRAISETHESUN(vec2 uv, vec3 camPos, vec3 viewDir, float time, float ti){\n    vec3 theSUN;\n    \n    float z = 15.;\n    float blur = .15;\n    \n    // Create the rays for all the sun objects\n    float c = sun(uv, camPos, viewDir, time, ti, z, blur, 1.);\n    float sunTwo = sun(uv, camPos, viewDir, time, ti, z, 8.*blur, 1.);\n    \n    // The bands outside the sun to add the light effect\n    float sBand = sun(uv, camPos, viewDir, time, ti, z + .1, blur +.5, 1.4+ti*0.6);\n    float sBand2 = sun(uv, camPos, viewDir, time, ti, z + .1, blur +.4, 1.*ti);\n    \n    // Yellow band that appears as the sun sets\n    float yBand = sun(uv, camPos, viewDir, time, ti, z + .15, blur +10., .5+ti);\n    \n    // Colour the parts of the sun\n    \n    vec3 bandcol = vec3(1.*ti, 1.*ti, 0)*sBand;\n    vec3 bandTwoCol = vec3(1., 1., 0)*sBand2;\n    \n    // The sky that turns from blue to orange when the sun sets\n    //vec3 skyCol = vec3(0.+ sin(ti),0.+sin(ti)*0.5,cos(1.3*ti));\n    \n    vec3 sunTwoCol = vec3(1.,1., 1.)*sunTwo;\n    \n    vec3 yDot = vec3(.2, .2, .1*cos(ti))*yBand;\n    \n    vec3 yBandCol = mix (yDot, vec3(.1+sin(ti), .1+sin(ti), 0)*yBand, 0.8);\n    \n    vec3 sun = vec3(1.,1., 1.)*c;\n        \n    theSUN = sun;\n    \n    theSUN += sBand;\n    \n    theSUN += sBand2;\n    \n    theSUN += sunTwoCol;\n    \n    theSUN += yBandCol;\n    \n    \n    return theSUN;\n}\n\n/*\n * Generate a vector 2 object from a point in 2D space based on the dot product of set values \n */\nvec2 hash( vec2 p ) {\n\tp = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n/*\n * Generate the noise of the clouds based on the viewer 2D coordinates\n */\nfloat noise( in vec2 p ) {\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor(p + (p.x+p.y)*K1);\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0); //vec2 of = 0.5 + 0.5*vec2(sign(a.x-a.y), sign(a.y-a.x));\n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max(0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot(n, vec3(70.0));\t\n}\n\n\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 0.1;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn = m * n;\n\t\tamplitude *= 0.4;\n\t}\n\treturn total;\n}\n\n/*\n * Generates the clouds for the shader based on the noise generated\n */\nvec3 happyLittleClouds(vec2 uv, float time, vec3 skyCol){\n    vec3 littleClouds;\n    \n    // --- Variables for modifying cloud shape, colour, speed ---\n    float cloudscale = .5;\n    float speed = 0.2;\n    float clouddark = 0.2;\n    float cloudlight = 0.8;\n    float cloudcover = 0.1;\n\tfloat cloudalpha = .5;\n    \n    // ---- the viwer coorid values squared that will be used for generating the clouds ----\n    vec2 p = uv*vec2(iResolution.x/iResolution.y,1.0); \n    \n    // Speed at which the clouds move\n    float cloudSpeed = time*speed;\t\n    \n    float q = fbm(uv * cloudscale * 0.2);\n    \n    //ridged noise shape\n\tfloat ridge = 0.0;\n\tp *= cloudscale;\n    p -= q - time;\n    float weight = 0.8;\n    for (int i=0; i<8; i++){\n\t\tridge += abs(weight*noise( uv ));\n        p = m*uv + time;\n\t\tweight *= 0.2;\n    }\n    \n    //noise shape\n\tfloat shape = 0.0;\n    p = uv*vec2(iResolution.x/iResolution.y,1.0);\n\tp *= cloudscale;\n    p -= q - time;\n    weight = 0.7;\n    for (int i=0; i<8; i++){\n\t\tshape += weight*noise( uv );\n        p = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    shape *= ridge + shape;\n    \n    //noise colour\n    float colour = 0.0;\n    time = iTime * speed * 2.0;\n    p = uv*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*2.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tcolour += weight*noise( uv );\n        p = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    //noise ridge colour\n    float colour2 = 0.0;\n    time = iTime * speed * 3.0;\n    uv = p*vec2(iResolution.x/iResolution.y,1.0);\n\tuv *= cloudscale*3.0;\n    uv -= q - time;\n    weight = 0.4;\n    for (int i=0; i<7; i++){\n\t\tcolour2 += abs(weight*noise( uv ));\n        uv = m*uv + time;\n\t\tweight *= 0.6;\n    }\n    \n    colour += colour2;\n    \n    shape = cloudcover + cloudalpha*shape*ridge;\n    \n    // Get the colour values for the clouds and store it in cloudcolour\n    vec3 cloudcolour = vec3(1.1, 1.1, 0.9) * clamp((clouddark + cloudlight*colour), 0.0, 1.0);\n    \n    // A bunch of happy little clouds\n    littleClouds = mix(skyCol, clamp(skyCol + cloudcolour, 0.0, 1.0), clamp(shape + colour, 0.0, 1.0));\n    \n    return littleClouds; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime*.1;\n    \n    float ti = fract(time);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 euv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5;\n    \n    vec2 cCoord;\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 camPos = vec3(0., 0.2, 0);\n    vec3 viewDir = vec3(0., 0.2, 1.0); \n\n    // Time varying pixel color\n   \t//vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //0.+ sin(.7*ti),0. + 0.8*sin(.5*ti)\tvec3(0., 0.,0.5+ .5*sin(2.5*ti)/(c+1.))\n    \n    ray r;\n    vec3 cloudPos;\n    float cloud;\n    \n    vec3 cloudCol;\n    \n    float size  =  .15 + ti*.01;\n    float blur = .6;\n    \n    for (float i = 0.; i < 20.; i+= 1.) {\n        r = getRay(uv, camPos, viewDir, 2.5);\n        \n        cloudPos = vec3(-1.+ ti*5.+ i/50., 1. - ti*2.5 + i/40., 5.- ti*.2 + i/100.);\n        \n        cloud = bokeh(r, cloudPos, size, blur);\n        \n        cloudCol += vec3(.2, .2, .2)*cloud;   \n        \n    }\n    \n    vec3 skyCol1 = vec3(0.2, 0.4, 0.6);\n    vec3 skyCol2 = vec3(0.4, 0.7, 1.0);\n    \n    vec3 skyCol = mix(skyCol2, skyCol1, uv.y);\n    \n    vec3 sun = PRAISETHESUN(uv, camPos, viewDir, time, ti); \n    \n    vec3 sky = mix(skyCol, clamp(.5 * skyCol, 0.0, 1.0), .2);\n   \n    \n \tvec3 clouds = happyLittleClouds(uv, time, skyCol);\n    \n    vec4 colour = vec4(clouds, .1) + vec4(sun, 1.0);\n   \n    // Output to screen\n    //fragColor = vec4(vec3(mask*col),1.0);\n    //fragColor = vec4(col, 1.);\n    fragColor = colour;\n    \n}","name":"Image","description":"","type":"image"}]}