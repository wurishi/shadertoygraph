{"ver":"0.1","info":{"id":"lcsXRM","date":"1705146011","viewed":149,"name":"Raymarching - Apollonian Fractal","username":"SardineMilk","description":"a stripped back version of my raymarcher, trying to get a fractal to render\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FOV = 1000.;\n\n\nvec3 palette( float t) {\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(0.263, 0.416, 0.557);\n\n    return a + b*cos( 6.28318*(c*t*d) );\n    }\n\n\nfloat apollonianSDF( vec3 p ) {\n    float width = 1.5f;  // 1.5f\n    float s = 3.0f, e;\n    for ( int i = 0; i++ < 12; ) {\n        p = mod(p - 1.0f, 2.0f ) - 1.0f;\n        s *= e = width / dot( p, p );\n        p *= e;\n    }\n    return length( p.yz ) / s;\n}\n\n\n// Calculate the Signed Distance Field for the scene\n\nvec2 map(vec3 point) {\n    return vec2(apollonianSDF(point), 1.);\n}\n\n\nvec4 rayMarch(vec3 point, vec3 direction, out int iter) {\n    vec2 signedDistance;\n    vec4 result;\n    \n    const int maxMarchingSteps = 2500;  // Maximum number of times ray is marched until loop breaks\n    const float maxDistance = 1000.0;  // Maximum distance to object for a miss\n    const float minDistance = 0.0001;  // Minimum distance to object for a hit\n    \n    vec3 rayPosition = point;\n    \n    for (int i = 0; i < maxMarchingSteps; i++)  // March the ray forwards  \n    {        \n        // Distance to nearest object\n        vec2 signedDistance = map(rayPosition);\n\n        rayPosition += direction * signedDistance.x;  // Move the ray\n        \n        result = vec4(rayPosition, 0.0);\n        if (signedDistance.x > maxDistance) break;  // If the ray misses\n        if (signedDistance.x < minDistance) {\n            result = vec4(rayPosition, signedDistance.y);\n            break;  // If the ray hits something\n            }\n        iter = i;\n    }\n    \n    \n    \n    return result;\n}\n\n\n// Default colour for a miss\nvec3 col = vec3(0., 0., 0.);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    // Shifted so (0, 0) is the centre rather than bottom-left\n    vec2 shiftedCoord = fragCoord - (iResolution.xy / 2.0);\n    vec2 uv = shiftedCoord / iResolution.y;   \n    \n    vec3 rayPosition = vec3(uv.x/100., uv.y/100., 0.0);\n    vec3 rayDirection = vec3(0.0, 0.0, 1.0);\n    rayDirection.xy = uv.xy * atan(radians(FOV));\n    rayDirection = normalize(rayDirection);\n    \n    rayPosition += vec3(1., 1., iTime+1.);\n    \n    int iterations;\n    vec4 hitPosID = rayMarch(rayPosition, rayDirection, iterations);\n    vec3 hitPosition = hitPosID.xyz;\n    float objectID = hitPosID.w;\n    \n    // If the ray hit, calculate lighting\n    if (objectID != 0.0) {\n        col = palette(length(hitPosition));\n        col /= vec3(float(iterations)*.5);\n        col *= 2.;\n        \n\n    }\n    \n    // Gamma correction\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0 / gamma));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}