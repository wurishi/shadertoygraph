{"ver":"0.1","info":{"id":"lttfWB","date":"1541000615","viewed":287,"name":"Comic book inkdots CYMK MSAA ","username":"scratch13764","description":"There could obviously be a shorter version of this, but right now I'm working on making the dots at an  angle. \n-CYMK added!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["ink","msaa","comic","antialaising"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hope my documentation is helpful for anyone trying to use this for something.\n\n#define PX round(iResolution.y/5.)\n#define SQ2  1. //1.41421\n// I was using that to correct the size of the dots so they could reach the corners of their \"pixel\"\n// But I realized that it got rid of almost all white, so I had to remove it to get truer colors.\n#define PI 3.141592653589\n#define SAMPLES 8.\n#define ANGLE radians(90.)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Variables that will remain constant are given values here, otherwise they are given values as needed\n    vec2    uv;\n    float   AR;\n    vec2    SUV;\n    vec2    SRUV;\n    vec2    RUV;\n    vec3    INCOL;\n    vec3    COL = vec3(1.); //The actual color that will be output\n    float   PXW = .5/PX; //Pixel width * 0.5, max radius of ink dot\n    float   AAR = .3/iResolution.y; //Antialaising sample radius\n    \n    \n    for (float I = 0.; I < 2.; I += 1./SAMPLES) // sample antialaising - uses \"SAMPLES\" # of samples.\n        //Not very well done AAing but it doesn't need to be perfect.\n    {\n        uv  = fragCoord/iResolution.xy + vec2(sin(PI*I)*AAR, cos(PI*I)*AAR);\n        AR = iResolution.x/iResolution.y; // Square pixels = good pixels\n        SUV = vec2(uv.x*AR,uv.y); // Scaled UV coords\n        SRUV = vec2(round(SUV.x*PX)/PX, // Scaled Rounded UV coords\n                    round(SUV.y*PX)/PX); // X and Y values seperated between lines\n        RUV = vec2(SRUV.x/AR, SRUV.y); //Rounded unscaled UV\n    \n        INCOL = vec3(texture(iChannel0,RUV)); // Gets a pixelated texture. \"Input Color\"\n\n    //CYAN\n        if (length(SRUV - SUV) < PXW*(1.-INCOL.x)*SQ2)\n            COL.x -= .5/SAMPLES;\n    //YELLOW\n        if (length(SRUV - SUV) < PXW*(1.-INCOL.y)*SQ2)\n            COL.y -= .5/SAMPLES;\n    //MAGENTA\n        if (length(SRUV - SUV) < PXW*(1.-INCOL.z)*SQ2)\n            COL.z -= .5/SAMPLES;\n    }\n    \n    \n    \n    \n\n    fragColor = vec4(COL,1.);\n}","name":"Image","description":"","type":"image"}]}