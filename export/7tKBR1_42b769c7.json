{"ver":"0.1","info":{"id":"7tKBR1","date":"1664093488","viewed":109,"name":"Tempest Shaders - base sky","username":"rinrin","description":"Tempest Shaders: \nhttps://github.com/Rinrin0413/Tempest-Shaders","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","clouds","cloud","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define CLOUDS_QUALITY 2 // [0 1 2]\n\n/**\n * Hash without Sine (1 out 2 in)\n * https://www.shadertoy.com/view/4djSRW\n *\n * Copyright (c) 2014 David Hoskins.\n * Distributed under the MIT License: https://opensource.org/licenses/mit-license.php\n */\nfloat hash12(const vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx)*.1031);\n    p3 += dot(p3, p3.yzx +33.33);\n    return fract((p3.x + p3.y)*p3.z);\n}\n\n/**\n * 1 out 2 in 2D Noise. \n * https://www.shadertoy.com/view/4dS3Wd\n *\n * By Morgan McGuire @morgan3d, http://graphicscodex.com\n * Reuse permitted under the BSD license: https://opensource.org/licenses/BSD-3-Clause\n */\nfloat noise12(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile.\n\tfloat a = hash12(i);\n    float b = hash12(i +vec2(1., 0.));\n    float c = hash12(i +vec2(0., 1.));\n    float d = hash12(i +vec2(1., 1.));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t/*return vec3(mix(\n        lerp(a, b, smoothstep(0., 1., f.x)),\n\t\tlerp(c, d, smoothstep(0., 1., f.x)),\n        smoothstep(0., 1., f.y)\n    ));*/\n\n    // Same code.\n    // with the clamps in smoothstep and common subexpressions optimized away.\n\t// Cubic Hermine Curve. Same as smoothstep().\n    vec2 u = f*f*(3. -2.*f);\n\treturn mix(a, b, u.x) +(c -a)*u.y*(1. -u.x) +(d -b)*u.x*u.y;\n}\n\n/**\n * 1 out 2 in 2D Fractal Brownian Motion. \n * https://www.shadertoy.com/view/4dS3Wd\n *\n * By Morgan McGuire @morgan3d, http://graphicscodex.com\n * Reuse permitted under the BSD license: https://opensource.org/licenses/BSD-3-Clause\n *\n * And modified by Rinrin.rs\n */\nfloat fbm12(vec2 x, int octaves) {\n    x += iTime;\n\tfloat v = 0.;\n\tfloat amplitude = .5;\n    float speed = .2;\n\tfor (int i = 0; i < octaves; ++i) {\n\t\tv += amplitude*noise12(x);\n\t\tx *= 2.;\n        x.xy -= iTime*speed*float(i +1);\n\t\tamplitude *= .5;\n\t}\n\treturn v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // Sky colors\n    const vec3 DAY_SKY_COL = vec3(0.20, 0.47, 0.74); // Day sky color\n    const vec3 NIGHT_SKY_COL = vec3(0.00, 0.04, 0.11); // Night sky color\n\n    // Cloud colors\n    const vec3 DAY_CLOUD_COL = vec3(0.80, 0.90, 1.00); // Day cloud color\n    const vec3 NIGHT_CLOUD_COL = vec3(0.17, 0.26, 0.39); // Night Ccoud color\n\n    vec2 uv = fragCoord/iResolution.xy*.33;\n    float is_day = smoothstep(-1., 1., sin(iTime/2.));\n\n    // Color calculation\n    vec3 sky_color = mix(NIGHT_SKY_COL, DAY_SKY_COL, is_day);\n    vec3 cloud_color = mix(NIGHT_CLOUD_COL, DAY_CLOUD_COL, is_day);\n\n    // Clouds\n    float cloud = fbm12(sin(uv)*10., 16);\n    #if 1 <= CLOUDS_QUALITY\n        // Cloud shadow I\n        if (0. < cloud) {\n            float cloud_shadow = fbm12(sin(uv)*9.5, 8);\n            cloud_color *= mix(1., .63, smoothstep(.54, .88, cloud_shadow));\n        }\n\n        #if CLOUDS_QUALITY <= 2\n            // Cloud shadow II\n            if (.7 < cloud) {\n                float cloud_shadow = fbm12(sin(uv)*9., 4);\n                cloud_color *= mix(1., .9, smoothstep(.6, .99, cloud_shadow));\n            }\n        #endif\n    #endif\n\n    vec3 albedo = mix(sky_color, cloud_color, smoothstep(.5, .68, cloud));\n\n    fragColor = vec4(albedo, 1.);\n}\n","name":"Image","description":"","type":"image"}]}