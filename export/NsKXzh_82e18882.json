{"ver":"0.1","info":{"id":"NsKXzh","date":"1634329117","viewed":148,"name":"psychedelic #1","username":"warpGooblin","description":"just an experiment... use your mouse as well...","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","psychedelic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n\n#define mouse iMouse\n#define time iTime\n\nuniform float zoom;\n\nvec3 ti;  // tile index\n\n#define BOXES_STEPS 0.45\n#define MAX_STEPS 300\n#define MAX_DIST 90.\n#define SURF_DIST .001\n\n#define EPSILON 0.0001\n\nfloat tw()\n{\n    return sin(time) * 0.5 + 0.5;\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nmat3 Rotation3d(vec3 axis, float angle)\n{\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat3(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  \n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  \n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c           \n    \n    );\n}\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat sdSphere(vec3 p, float s)\n{\n  return length(p)-s;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 opRep(in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    ti = floor((p + c*0.5)/c);  // tile index global variable\n    return q;\n}\n\nvec3 opRepLim(in vec3 p, in float c, in vec3 limita, in vec3 limitb)\n{\n    //p.y -= 0.75;\n    return p - c * clamp(floor(p / c + 0.5), limita, limitb);\n}\n\n// www.mercury.sexy/hg_sdf version\n/* vec3 pMod3(inout vec3 p, vec3 size) {\n    vec3 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return c;\n} */\n\n\n\nfloat GetDist(vec3 p) {\n    //float plane = p.y;\n    //float box = sdBox(p-vec3(0,1,0), vec3(1));\n\n    //vec3 r = opRepLim(p, 1.60, vec3(-2.00), vec3(2.00));\n    vec3 r = opRep(p, vec3(3.60));\n    float boxes = sdBox(r, vec3(0.40));\n    float spheres = sdSphere(r, 0.43);\n    float spheres2 = sdSphere(r, 0.35);\n    //float d; \n    //d = boxes;\n    //float d = min(plane, boxes);\n\n    float d = max(-spheres, boxes * BOXES_STEPS);\n    float d1 = min(spheres2, d);\n    //float d1 = smin(spheres2, d, 0.95);\n    d = mix(-d1, spheres2, 0.295);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n    float dO=0.0;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(3, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n   // if(p.y<.01 && d<length(lightPos-p)) dif *= .5;\n    \n    return dif;\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float tw = tw();\n\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy) / iResolution.x;\n    //vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy)  / resolution.y;\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv.y += 0.5;\n    \n    vec2 m = vec2(0.001, 0.005) * mouse.xy * vec2(- aspectRatio, -1.0);\n    //m += resolution.y / resolution.x;\n\n    vec3 col = vec3(0);\n\n    vec3 ro = vec3(0.0, 0.0, -3.0);   // i changed this ... this is flight through   \n    // ro vec3 (l..r, o..u, distance)\n    //vec3 ro = vec3(0.0);\n    \n    //ro.yz *= Rot(time);\n    \n    //ro *= Rotation3d(vec3(1.0, 0.0, 1.0), time);\n\n    ro.xz *= Rot(0.1*time);\n    \n    ro.yz *= Rot(-m.y*3.14+1.55);\n    ro.xz *= Rot(-m.x*8.);\n    //ro.z += 12.;\n    \n    vec3 rd = R(uv, ro, vec3(0.0, 0.0, 0.0), +1.0);  // i changed this from vec3(0,1,0)\n\n    float d = RayMarch(ro, rd);\n    \n    if(d < MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n    \n        float dif = GetLight(p);\n        //col = vec3(dif);   \n        col = GetNormal(p) * 0.5 + 0.5 - 0.5 * dif;\n        //col = 0.2 * col;\n        //float tpos = floor((sin(time*1.5)*0.5+0.5)*18.0);\n        /* if (length(ti) <= abs(tpos))                          // tile position\n        {\n            col *= 10.; \n        } */ \n        //float fog0 = smoothstep(6.0, MAX_DIST, d);   // fog\n        //col = mix(vec3(0.0), col, 90.1*fog0);\n    }\n    \n    col = pow(col, vec3(.4545));    // gamma correction\n    // fog #2\n    float fog = 0.005;\n    col *= 1.25 / (1.0  + pow(d, 3.0) * fog); // pow 2.0\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}