{"ver":"0.1","info":{"id":"wtsGRs","date":"1557369358","viewed":714,"name":"3d Fractal","username":"WillKillU","description":"little practice raymarching practice on 3d fractal visualization using raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","visualization","psychoraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat Power = 1.0;\n\nfloat rotationSpeed = 0.03;\n\nvec2 rotate(vec2 a, float b)\n{\n\tfloat c = cos(b);\n\tfloat s = sin(b);\n\treturn vec2(\n\t\ta.x * c - a.y * s,\n\t\ta.x * s + a.y * c\n\t\t);\n}\n\nfloat DE(vec3 pos) \n{\n    vec3 \tz \t= pos;\n    float \tdr \t= 1.0;\n    float \tr \t= 0.0;\n    \n    for (int i = 0; i < 15 ; i++) \n    {\n        r = length(z);\n        if (r>2.0) break;\n        \n        // convert to polar coordinates\n        float theta = acos(z.z/r);\n        float phi \t= atan(z.y,z.x);\n        dr \t\t\t=  pow( r, Power - 1.)*Power*dr + 1.0;\n        \n        // scale and rotate the point\n        float zr \t= pow( r,Power);\n        theta \t\t= theta*Power;\n        phi \t\t= phi*Power;\n        \n        // convert back to cartesian coordinates\n        z = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        z+=pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n//SDF\nfloat map(vec3 p)\n{\n    return DE(p);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(vec3(map(p + eps.xyy) - map(p-eps.xyy),\n                  map(p + eps.yxy) - map(p-eps.yxy),\n                  map(p + eps.yyx) - map(p-eps.yyx)\n                 )\n            );\n}\n\nfloat light(vec3 n, vec3 l)\n{\n    //return dot(n,normalize(l))*.5+.5;\n    return max(dot(n,normalize(l)),0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Power += mod(iTime*0.1 ,20.0);\n\n    vec2 position = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    position -= 0.5;\n    position /= vec2(iResolution.y/iResolution.x,1.);\n    \n    vec3 ro = vec3(0., 0., -4.);\n    vec3 p = ro;\n    vec3 rd = normalize(vec3(position, 1.5));\n\t\n\tro.xz = rotate(ro.xz, iTime * rotationSpeed);\n\tp.xz = rotate(p.xz, iTime * rotationSpeed);\n\trd.xz = rotate(rd.xz, iTime * rotationSpeed);\n    \n    bool hit = false;\n\n    \n\tvec3 fogColor = vec3(1.0,.1, 1.0);\n\t\n    for(float i = 0.0; i < 100.0; ++i)\n    {\n        float df = map(p);\n        \n        if(df < 0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += df * rd * 0.95;\n    }\n    float t = length(ro - p);\n    \n    vec3 finalColor = !hit ? vec3(0.1) : normal(p);\n    \n    if(hit)\n    {\n        vec3 n = normal(p);\n\t    \n\tfloat fresnel = pow(1.-dot(n, -rd), 0.5);\n\t    \n        vec3 l = vec3(1.0, 0.0, -0.1);\n\t    l.xz = rotate(l.xz, iTime * rotationSpeed);\n        \n        finalColor = mix(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.5, 0.5), vec3(light(n,l)));\n\tfinalColor = mix(finalColor, vec3(0.,0.5,0.1),fresnel);\n    }\n    else\n    {\n\tfinalColor = vec3(.0,0.1,0.2);\n     \tfogColor = vec3(0.2);\n    }\n    \n    finalColor = mix(finalColor, fogColor, 1.-exp(-0.01*t*t));\n    \n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}