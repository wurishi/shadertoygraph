{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/*\n * \"Spaceless\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\nstruct mat\n{\n    float depth;\n    vec3 col;\n    vec3 icol;\n    float ao;\n};\n\nfloat torus(in vec3 p, in vec2 r)\n{\n    vec3 c = vec3(0.);\n    c.xz = p.xz / length(p.xz) * r.x;\n    return length(p - c) - r.y;\n}\n\nfloat sphere(in vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat line(in vec3 p, in vec2 r)\n{\n    vec3 x = vec3(1., 0., 0.);\n    float t = clamp(dot(p, x) / dot(x, x), -r.x*.5, r.x*.5);\n    return length(p-x*t) - r.y;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    float s = max(a.depth, b.depth);\n    float ao = map(s, 1., 3.5, 9.);\n    s = map(s, 1., .7, 1.8);\n    return mat\n        (\n            min(a.depth, b.depth),\n            a.depth < b.depth ? a.col : b.col,\n            a.icol * mix(a.depth > b.depth ? a.col : b.col, vec3(1.), s),\n            a.ao * ao\n        );\n}\n\n#define op0 vec3(0, 1.5, 0)\n#define op1 vec3(sin(iTime) + 2., 0., 0.)\n#define op2 vec3(0, -1.5, 0)\n#define op3 vec3(-sin(iTime) - 2., 0., 0.)\n\n\nmat scene(in vec3 p)\n{    \n    mat o0 = mat(line(p - op0, vec2(2, .5)), vec3(1, .0, .5), vec3(1), 1.);\n    mat o1 = mat(sphere(p - op1, 1.), vec3(1), vec3(1), 1.);\n    mat o2 = mat(torus(p - op2, vec2(1.5, .5)), vec3(0, .5, 1), vec3(1), 1.);\n    mat o3 = mat(cube(p - op3, vec3(1.), .5), vec3(.5, 1, 0), vec3(1), 1.);\n    \n    mat o = uop(o1, o3);\n    o = uop(o, o2);\n    o = uop(o, o0);\n    \n    return o;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, .0);\n    float d = scene(p).depth;\n    vec3 n = d - vec3(scene(p - e.xyy).depth, scene(p - e.yxy).depth, scene(p - e.yyx).depth);\n    return normalize(n);\n}\n\n#define NUM_STEPS 99\n#define MIN_DIST .01\n#define MAX_DIST 64.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < NUM_STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.depth;\n        if (s.depth < MIN_DIST)\n            return mat(t, s.col, s.icol, s.ao);\n        if (t > MAX_DIST)\n            return mat(t, vec3(-1.), vec3(-1.), -1.);\n    }\n    return mat(t, vec3(-1.), vec3(-1.), -1.);\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\n#define AA 2.\n#define sk vec3(.5, .7, 1)\n#define gd vec3(1)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 f_col;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n    \t\tvec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n\t\t\tvec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n            \n            float sn = ms.x * 6.283184;\n            \n            vec3 o = vec3(3, 3, 6);\n            if (iMouse.z > 0.)\n            \to = vec3(sin(sn), ms.y, cos(sn)) * 8.;\n            vec3 t = vec3(0.);\n            vec3 d = camera(uv, o, t);\n            \n            vec3 back = mix(gd, sk, d.y * .5 + .5);\n            vec3 col = vec3(0.);\n            \n            mat m = marcher(o, d);\n            if (m.ao >= 0.)\n            {\n                vec3 p = o + d * m.depth;\n                vec3 n = normal(p);\n                back = mix(gd, sk, n.y);\n                col += m.col * m.icol * m.ao * back;\n            }\n            else\n                col += back;\n                        \n            f_col += col;\n        }\n    }\n    \n    f_col /= AA * AA;\n\n    fragColor = vec4(sqrt(f_col),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"WtSfzh","date":"1598651789","viewed":140,"name":"Spaceless","username":"JacobC","description":"Faking IL/GI with ray marching.\nYou can move the camera by clicking the canvas and drag with the mouse","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ao","il"],"hasliked":0,"parentid":"","parentname":""}}