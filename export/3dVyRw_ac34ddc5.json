{"ver":"0.1","info":{"id":"3dVyRw","date":"1602707710","viewed":125,"name":"Accidental Dragons","username":"Blake447","description":"Accidentally ended up with a dragon curve in a weird way while trying to make a dragon curve in a different weird way. Thought it looked cool so I transferred it over to GLSL and made it spin","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fractal","dragon","curve","dragoncurve","harter","heighway"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 T(vec2 v, int dir)\n{\n\tvec2 double_point = v;\n\n\tfloat index_0 = mod(((v.x + v.y) + 4096.0), 2.0);\n\n\n\tfloat x_proj = floor(( v.x + v.y) / 4.0 + 0.5*(float(dir) + 1.0));\n\tfloat y_proj = floor((-v.x + v.y) / 4.0 + 0.5*(float(dir) + 1.0));\n\n\n    vec2 coord_back = x_proj * vec2(1.0, 1.0)*2.0 + y_proj * vec2(-1.0, 1.0)*2.0;\n    vec2 half_point = coord_back;\n\n    float index = mod((x_proj + y_proj + 4096.0 + float(dir)), 2.0);\n    float direction = 1.0 - 2.0 * index;\n    vec2 offset = v - half_point;\n    vec2 rotated = half_point + vec2(offset.x + offset.y * direction, offset.y - offset.x * direction);\n\n    vec2 new_coord = vec2(floor(rotated.x + rotated.y)/2.0, floor(rotated.y - rotated.x) / 2.0);\n\n\n    return new_coord;\n}\n\n\nvec2 rotate45(vec2 p, vec2 c, float dir)\n{\n \tvec2 v = p-c;\n    return c + vec2(v.x + v.y*dir, v.y - v.x*dir);\n    \n}\n\nfloat DE(vec2 p)\n{\n    vec2 comparison = vec2(clamp(p.x, -1.0, 1.0), 0.0);\n    \n\treturn length(p-comparison);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_init = fragCoord/iResolution.xy;\n    \n    vec2 start = vec2(-0.5, -0.5);\n    vec2 end = vec2(0.5, 0.5);\n    \n    // Generate a p within our viewing window with corrected aspect ratio\n    vec2 uv = (start + (end-start)*uv_init) *vec2(iResolution.x/iResolution.y, 1.0);\n\n    float speed = -0.05;\n    float theta = iTime * speed;\n    uv = vec2(uv.x*cos(theta) - uv.y*sin(theta), uv.x*sin(theta) + uv.y*cos(theta));\n    \n    \n    float size = 4096.0;\n    vec2 mapping = vec2(float(floor(uv.x/2.0*size)) * 2.0, float(floor(uv.y / 2.0*size))*2.0);\n    \n    vec2 p0 = mapping + vec2(0.0, 1.0);\n    vec2 p1 = mapping + vec2(1.0, 0.0);\n    vec2 p2 = mapping + vec2(1.0, 2.0);\n    vec2 p3 = mapping + vec2(2.0, 1.0);\n\n    vec2 v0 = p0;\n    vec2 v1 = p1;\n    vec2 v2 = p2;\n    vec2 v3 = p3;\n    \n    const int ITERATIONS = 23;\n    \n    for (int j = 0; j < ITERATIONS; j++)\n    {\n        v0 = T(v0, 0);\n        v1 = T(v1, 0);\n        v2 = T(v2, 0);\n        v3 = T(v3, 0);\n\n        uv = (vec2(uv.x + uv.y, uv.y - uv.x) / 2.0);\n    }\n    \n    vec2 a = vec2(0.0, 1.0);\n\n    float d0 = length(v0 / float(size) - uv) * size;\n    float d1 = length(v1 / float(size) - uv) * size;\n    float d2 = length(v2 / float(size) - uv) * size;\n    float d3 = length(v3 / float(size) - uv) * size;\n\n\tfloat dist = min(min(d0, d1), min(d2, d3));\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n    float SCALE = 150.0;\n    // Output to screen\n    fragColor = vec4(vec3(1.0, 1.0 ,1.0)*dist / length(p0-v0)*SCALE,1.0);\n}","name":"Image","description":"","type":"image"}]}