{"ver":"0.1","info":{"id":"XfXcWl","date":"1721735555","viewed":55,"name":"Randomly spaced fract()'s","username":"Suslik","description":"Noise that looks like fract() ramps, but each ramp has a random length. Upper one produces wildly random lengths, bottom one is more tame.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["math","fract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    Interval interval;\n    bool is_below;\n    if(uv.y > 0.5f)\n    {\n        interval = GetRandomlySpacedInterval(uv.x, sin(iTime) * 0.5f + 0.5f, 4u);\n        float x = (uv.x - interval.minmax.x) / (interval.minmax.y - interval.minmax.x);\n        is_below = (uv.y - 0.5f) * 2.0f < x;\n    }else\n    {\n        float x = uv.x * 16.0f;\n        interval = GetRandomlySpacedInterval2(x, sin(iTime) * 0.5f + 0.5f);\n        float y = (x - interval.minmax.x) / (interval.minmax.y - interval.minmax.x);\n        is_below = (uv.y) * 2.0f < y;\n    }\n    vec3 col = hash3i3f(ivec3(interval.index, 0, 0));\n    fragColor = vec4(col * (is_below ? 1.0f : 0.0f), 1.0);    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//http://www.jcgt.org/published/0009/03/02/paper.pdf\nuvec3 hash33UintPcg(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n    v ^= v >> 16u;\n    v.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n    //v += v.yzx * v.zxy;\n    return v;\n}\n\nvec3 hash3i3f(ivec3 seed)\n{\n    uvec3 hash_uvec3 = hash33UintPcg(uvec3(seed));\n    return vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\nstruct Interval\n{\n    vec2 minmax;\n    int index;\n};\n\nInterval GetRandomlySpacedInterval(float x, float messiness, uint depth)\n{\n    Interval res;\n    res.minmax = vec2(0.0f, 1.0f);\n    res.index = 0;\n    for(uint i = 0u; i < depth; i++)\n    {\n        vec3 hash = hash3i3f(ivec3(res.index, i, 0));\n        float split = mix(0.5f, hash.x, messiness);\n        float p = mix(res.minmax.x, res.minmax.y, split);\n        if(x > p)\n        {\n            res.minmax.x = p;\n            res.index = res.index * 2 + 1;\n        }else\n        {\n            res.minmax.y = p;\n            res.index = res.index * 2 + 0;            \n        }\n    }\n    return res;\n}\n\nfloat GetRandomIntervalStart(int index, float messiness)\n{\n    return float(index) - hash3i3f(ivec3(index, 0, 0)).x * messiness;\n}\n\nInterval GetRandomlySpacedInterval2(float x, float messiness)\n{\n    int index0 = int(floor(x));\n    float split0 = GetRandomIntervalStart(index0 + 1, messiness);\n    \n    bool is_left = x < split0;\n    int index1 = index0 + (is_left ? 0 : 2);\n    float split1 = GetRandomIntervalStart(index1, messiness);\n\n    Interval res;\n    res.index = index0 + (is_left ? 0 : 1);\n    res.minmax = is_left ? vec2(split1, split0) : vec2(split0, split1);\n    return res;\n}","name":"Common","description":"","type":"common"}]}