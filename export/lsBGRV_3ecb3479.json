{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float volFunc(vec3 p)\n{\n\tfloat a = 0.0;\n\tfloat fp = 0.45;\n\tconst int n = 22;\n\tfloat pa = 0.0;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tp=abs(p)/dot(p,p)-fp;\n\t\ta+=abs(length(p)-pa);\n\t\tpa=length(p);\n\t}\n\t\n\ta /= float(n);\n\treturn a*a*a*0.625;\n}\n\nvec3 volumeIntegrate(vec3 start, vec3 dir, float s)\n{\n\tvec3 rad = vec3(0.0);\n\tconst int n = 12;\n\tconst float rn = 1.0 / float(n);\n\tfloat d = 0.0;\n\tvec3 p = start + dir * rn;\n\tfloat i = 0.0;\n\t\n\tfor(int k = 0; k < n; ++k)\n\t{\n\t\trad += vec3(i,i*i,i*i*i) * volFunc(p) * rn;\n\t\n\t\tfloat ds = rn * s;\n\t\tp += dir * ds;\n\t\td += ds;\n\t\ti += rn;\n\t}\n\t\n\trad.b += pow(0.5*(1.0-abs(rad.r - rad.g)),3.0);\n\treturn (rad*0.85);\n}\n\nfloat sceneFunc(vec3 p)\n{\n\tvec3 c = vec3(0.0,0.0,0.0);\n\tfloat r = 4.0 + 0.125*(sin(2.0*p.x*p.y+iTime*5.0));\n\treturn length(p-c) - r;\n}\n\nhighp vec3 sceneGrad(highp vec3 p)\n{\n    const highp float h = 0.001;\n    highp vec3 g;\n    g.x = sceneFunc(p+vec3(h,0.0,0.0)) - sceneFunc(p-vec3(h,0.0,0.0));\n    g.y = sceneFunc(p+vec3(0.0,h,0.0)) - sceneFunc(p-vec3(0.0,h,0.0));\n    g.z = sceneFunc(p+vec3(0.0,0.0,h)) - sceneFunc(p-vec3(0.0,0.0,h));\n    return g / (2.0*h);\n}\n\nhighp mat4 lookAtInv(highp vec3 eyePos, highp vec3 targetPos, highp vec3 upVector)\n{\n    highp vec3 forward = normalize(targetPos - eyePos);\n    highp vec3 right = normalize(cross(forward,upVector));\n    upVector = normalize(cross(right,forward));\n    \n    highp mat4 r;\n    r[0] = vec4(right,0.0);\n    r[1] = vec4(upVector,0.0);\n    r[2] = vec4(-forward,0.0);\n    r[3] = vec4(eyePos,1.0);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat k = -3.75 + 1.0*sin(iTime*0.1);\n\thighp vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n\thighp vec2 ndc = (uv-0.5)*2.0;\n\thighp float aspect = iResolution.x/iResolution.y;\n\thighp vec3 camPos = vec3(ndc.x,ndc.y/aspect,0.0);\n\thighp vec3 camDir = normalize(vec3(ndc.x,ndc.y/aspect,k)); //normalize(vec3(aspect*(uv.x-0.5),uv.y-0.5,-1.0));\n\t\n\tfloat phi = iTime*0.025;\n\thighp mat4 m = lookAtInv(vec3(15.0*cos(phi),sin(phi)*15.0,20.0),\n\t\t\t\t\t\t\t vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0));\n\t\n\tcamPos = ( m * vec4(camPos,1.0) ).xyz;\n    camDir = ( m * vec4(camDir,0.0) ).xyz;\n\t\n\tvec3 rad = vec3(0.0);\n\t\n\tfloat dist = 0.0;\n\tconst int n = 45;\n\tvec3 p = camPos;\n\tbool hit = false;\n\t\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tvec3 p = camPos + camDir * dist;\n\t\tfloat d = sceneFunc(p);\n\t\tif(d < 0.000065)\n\t\t{\n\t\t\tvec3 norm = normalize(sceneGrad(p));\n\n\t\t\tvec3 lpos = vec3(0.0,5.0,0.0);\n\t\t\tvec3 toL = normalize(lpos - p);\n\t\t\tvec3 hv = normalize(toL - camDir);\n\t\t\t\n\t\t\tfloat ndl = max(0.0,dot(norm,lpos));\n\t\t\tfloat ndhv = max(0.0,dot(norm,hv));\n\t\t\t\n\t\t\tvec3 ref = camDir - 2.0 * (dot(camDir,norm)*norm);\n\t\t\tref = normalize(ref);\n\t\t\trad = (0.06 +vec3(ndl)*0.75 + 0.5*pow(ndhv,8.0)) * volumeIntegrate(camPos,ref, dist);\n\t\t\t\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tdist += d;\n\t}\n\t\n\tif(!hit)\n\t{\n\t\tdist = 100.0;\n\t\trad += volumeIntegrate(camPos,camDir, dist);\n\t}\n\n\t\n\tfragColor = vec4(pow(rad,vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsBGRV","date":"1390852317","viewed":1231,"name":"Spacetime Anomaly ","username":"xwize","description":"Using some fractal stuff I nabbed from Star Nest.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fractal","stars"],"hasliked":0,"parentid":"","parentname":""}}