{"ver":"0.1","info":{"id":"ctjXzK","date":"1676324339","viewed":265,"name":"Alien shiny orb","username":"ianertson","description":"Some kind of weird shiny orb!\nUse the mouse to look around :)","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","raymarching","ray","raymarch","space","alien","orb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 100\n\nfloat noise(vec2 p) {\n    return textureLod(iChannel3, p/256.0, 0.0).r;\n}\n\nfloat noise3D(vec3 p) {\n    return textureLod(iChannel2, p/256.0, 0.0).r;\n}\n\nfloat noise4(vec2 p, float freq) {\n    float n = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    \n    #define ADVANCE n += amp * noise(p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    \n    ADVANCE;\n    ADVANCE;\n    ADVANCE;\n    ADVANCE;\n\n    #undef ADVANCE\n    \n    return n / div;\n}\n\nfloat noise6(vec2 p, float freq) {\n    float n = 0.0;\n    float div = 0.0;\n    float amp = 1.0;\n    \n    #define ADVANCE n += amp * noise(p*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    \n    ADVANCE;\n    ADVANCE;\n    ADVANCE;\n    ADVANCE;\n    ADVANCE;\n    ADVANCE;\n    \n    #undef ADVANCE\n    \n    return n / div;\n}\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_THING 2\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float dist;\n    int id;\n    int skip;\n};\n\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0)\n\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n\nstruct Light {\n    vec3 p;\n    vec3 c;\n    float s;\n    int type;\n};\n\n#define SAMPLE(var, id_) if (id_ != data.skip && var < dist) { data.id = id_; dist = var; }\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat thingSDF(inout Data data, vec3 p) {\n    vec2 uv = vec2(0.0);\n    uv.x = atan(p.x, p.y);\n    uv.y = atan(p.y, p.z);\n   \n    uv *= 6.;\n    \n    vec2 id = floor(uv);\n    vec2 lv = smoothstep(0.0, 1.0, fract(uv));\n    \n    float x = noise(id);\n    float y = noise(id+3.29151);\n    lv += (vec2(x, y) * 2.0 - 1.0) * 0.5;\n    \n    float g = max(0.0, 1.0 - ceil(min(lv.x, lv.y)-0.06));\n    \n    lv = lv * 2.0- 1.0;\n    float r = 0.5;\n    r = noise(id*16.);\n    r = max(0.01, r - ((noise4(lv*3., 0.5)*2.0-1.0)*0.2));\n    float f = r*0.02;\n    float ci = 1.0 - smoothstep(r-f, r+f, length(lv));\n    \n    float d = sphereSDF(p - vec3(0, 1, 0), 1.);\n    d += ci*0.5;\n    \n    float bumps1 = noise4(vec2(p.x*p.z, p.y), 2.);\n    float bumps2 = noise4(vec2(p.x, p.y*p.z), 2.);\n    float bumps = (bumps1+bumps2)/2.0;\n    bumps = bumps * 2.0 - 1.0;\n    \n    d += bumps*0.2;\n\n    d /= (1.0+ci*M_PI);\n    d /= (1.0+(abs(bumps)*0.22));\n    \n    return (abs(d)-0.03)/(1.0 + 0.2);\n\n}\n\nfloat groundSDF(vec3 p) {\n    float n = noise6(p.xz, 0.16);\n    \n\n    float d = p.y-n;\n    \n    return d / (1.0+(n*0.5));\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float dist = FAR;\n    float ground = groundSDF(p);\n    float thing = thingSDF(data, p-vec3(0, 0.3, 0));\n    SAMPLE(thing, ID_THING);\n    SAMPLE(ground, ID_GROUND);\n    return dist;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = data.id == ID_GROUND ? vec2(0.1, 0.0) : vec2(NEAR*8., 0.0);\n    return normalize(getDist(data, p) - vec3(\n        getDist(data, p - e.xyy),\n        getDist(data, p - e.yxy),\n        getDist(data, p - e.yyx)\n    ));\n}\n\nvec2 getUv(inout Data data, vec3 p) {\n    vec3 n = data.n;\n    vec2 uv = p.xz;\n    uv = mix(uv, p.xy, adot(n, vec3(0, 0, 1)));\n    uv = mix(uv, p.xz, adot(n, vec3(0, 1, 0)));\n    uv = mix(uv, p.yz, adot(n, vec3(1, 0, 0)));\n    return uv;\n}\n\nbool march(inout Data data, vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    \n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        \n        if (abs(dist) <= NEAR) break;\n        if (abs(dist) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*dist;\n    data.p = p;\n    data.dist = dist;\n    data.n = getNormal(data, p);\n    data.uv = getUv(data, p);\n    \n    return true;\n}\n\nfloat getShadow(int skip, vec3 ro, vec3 rd, float near, float far) {\n    float dist = 0.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (abs(next) <= NEAR || abs(dist) >= far) break;\n    }\n    dist = abs(dist);\n    if (dist >= far) return 1.0;\n    return (dist/max(0.001, near))/M_PI;\n}\n\n\n#define TEX_NORM(TEX, uv, var)\\\n    {\\\n    vec2 e = vec2(0.02, 0.0);\\\n    var = vec3(normalize(TEX(uv) - vec3(\\\n        luma(TEX(uv - e.xy)),\\\n        luma(TEX(uv - e.xx)),\\\n        luma(TEX(uv - e.yx))\\\n    )));\\\n    }\n\n\nvec3 gridTexture(vec2 uv, float thick) {\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    float g = max(0.0, 1.0 - ceil(min(lv.x, lv.y)-thick));\n    return vec3(g);\n}\n\nvec3 rockTexture(vec2 uv) { return vec3(noise4(uv*4., 4.)); }\n\nvec3 getAlbedoThing(inout Data data) {\n    vec3 p = data.p;\n    vec2 uv = vec2(0.0);\n    uv.x = atan(p.x, p.y);\n    uv.y = atan(p.y, p.z);\n    uv *= 6.;\n    return rockTexture(uv);\n}\n\nvec3 grassTexture(vec2 uv) {\n    float n = noise4(uv*2., 4.);\n    vec3 green = vec3(0.3, 0.6, 0.1);\n    return green * n;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 col = vec3(0.0);\n    vec2 uv = data.p.xz;\n    col = grassTexture(uv);\n    vec3 norm = vec3(0.0);\n    TEX_NORM(grassTexture, uv, norm);\n    data.n = normalize(mix(data.n, norm, 0.4*max(0.0, dot(data.n, norm))));\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_THING: return getAlbedoThing(data); break;\n        case ID_GROUND: return getAlbedoGround(data); break;\n    }\n    \n    return vec3(0.48);\n}\n\nvec3 forEachLight(inout Data data, vec3 ro, vec3 rd, in Light light) {\n    vec3 albedo = getAlbedo(data);\n    vec3 diffuse = albedo / M_PI;\n    \n    vec3 L = light.type == LIGHT_AMBIENT ? normalize(light.p) : normalize(light.p - data.p);\n    float NdotL = max(0.0, dot(data.n, L));\n    vec3 att = vec3(0.0);\n    \n    float distLight = FAR;\n    if (light.type == LIGHT_POINT) {\n        distLight = distance(data.p, light.p);\n        att = light.c*(NdotL * (pow(light.s, 2.0) / max(0.001, pow(distLight ,2.0))));\n    } else {\n        att = light.c * NdotL * light.s;\n    }\n    \n    vec3 ref = reflect(L, data.n);\n    float VdotR = max(0.0, dot(rd, ref));\n    float spec = pow(VdotR, 32.0);\n    \n    float shadow = 1.0;\n    if (NdotL > 0.00002 && data.id != ID_THING) {\n        shadow = getShadow(data.id, data.p, L, data.dist, distLight);\n    }\n    \n    return (diffuse + spec) * att * shadow;\n}\n\n\nvec3 moonTexture(vec2 uv) {\n    uv *= 4.;\n    vec3 col = vec3(0.);\n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    float r = 0.2;\n    vec2 spp = lv * 2.0 - 1.0;\n    float rand1 = textureLod(iChannel3, id/256., 0.).r;\n    float rand2 = fract(rand1*10.28371);\n    float rand3 = fract((rand1+rand2)*10.77625);\n    r = max(0.1, r * mix(2.0, 0.2, rand3));\n    float rand4 = textureLod(iChannel3, ((id+(lv*7.))+vec2(4.382, 9.28187))/256., 0.).r;\n    r += (rand4)*0.2;\n    r = max(0.2, r);\n    float f = r*0.9;\n    spp += (vec2(rand1, rand2) * 2.0 - 1.0) * r;\n    float sp = 1.0 - smoothstep(r-f, r+f, distance(uv, uv+(spp))); \n    float g = texture(iChannel3, uv*0.1).r;\n    g -= sp*0.6;\n    return vec3(max(0.0, g));\n}\n\nvec3 getSky(in Light light, vec3 ro, vec3 rd) {\n    vec3 L = normalize(light.p);\n    float VdotL = max(0.0, dot(rd, L));\n    vec3 col = vec3(0.0);\n    float stars = texture(iChannel2, rd*16.).r;\n    float t = T*0.02;\n    float stars2 = texture(iChannel2, ((rd+(0.5*vec3(cos(t), sin(t), sin(t+3.9871))))+vec3(-1.291, 1.972, 3.331))*4.).r;\n    stars *= (0.16+stars2);\n    stars = pow(stars, 16.0);\n    col += stars;\n    float r = 0.1;\n    float f = r*0.02;\n\n    vec3 lp = light.p;\n    \n    vec2 uv = vec2(0.0);\n    uv.y = acos(rd.y);\n    uv.x = atan(rd.x, rd.z);\n    uv = uv * 2.0 - 1.0;\n    uv.x = 0.5 + uv.x / (M_PI);\n    uv.y = 0.5 - uv.y / M_PI;\n    \n    vec2 cv = vec2(0.0);\n    cv.y = acos(L.y);\n    cv.x = atan(L.x, L.z);\n    cv = cv * 2.0 - 1.0;\n    cv.x = 0.5 + cv.x / (M_PI);\n    cv.y = 0.5 - cv.y / M_PI;\n   \n  \n    float a = 1.0 - smoothstep(r-f, r+f, distance(uv, cv));  \n    float b = 1.0 - smoothstep(r-f, r+f, distance(uv + vec2(-0.05, 0.0), cv));\n    \n    float circle = max(0.0, a-b);\n    float pattern = texture(iChannel3, uv*2.).r;\n    vec3 moonTex = moonTexture(uv*8.);\n    return col + circle*light.c*light.s*moonTex;\n}\n\n\nvec3 timeColor() {\n    vec3 red1 = vec3(0.97, 0.1, 0.1);\n    vec3 red2 = vec3(0.97, 0.3, 0.2);\n    vec3 red3 = vec3(0.82, 0.2, 0.3);\n    vec3 red4 = vec3(0.79, 0.3, 0.1);\n    float tk = textureLod(iChannel3, vec2(2.*cos(T*0.2))/256., 0.).r * 2.0 - 1.0;\n    float cycle = mod((T*0.9)+(tk*2.2), 4.5);\n    float f = 0.5;\n    vec3 col = red1;\n    col = mix(col, red2, smoothstep(1.0 - f, 1.0 + f, cycle));\n    col = mix(col, red3, smoothstep(2.0 - f, 2.0 + f, cycle));\n    col = mix(col, red4, smoothstep(3.0 - f, 3.0 + f, cycle));\n    col = mix(col, red1, smoothstep(4.0 - f, 4.0 + f, cycle));\n    return col;\n}\n\nvec3 render(inout Data data, vec2 uv, vec3 ro, vec3 rd) {\n    vec3 col = vec3(0.0);\n    \n    vec3 lightColor = rgb(50,101,142);\n    \n    Light lights[2];\n    \n    vec3 pointColor = timeColor();\n\n    lights[0] = Light(vec3(-1, 1, 3), lightColor, 2.0, LIGHT_AMBIENT);\n    lights[1] = Light(vec3(0, 1.7, 0), pointColor, 8.0, LIGHT_POINT);\n    \n    float hitDist = FAR;\n    \n    bool hitAny = false;\n    float hitDepth =1.;\n    \n    for (int i = 0; i < 2; i++) {\n        Light light = lights[i];\n        if (march(data, ro, rd)) {\n            hitAny = true;\n            col += forEachLight(data, ro, rd, light);\n            hitDist = data.dist;\n        }\n        \n       \n        hitDepth = hitDist / FAR;\n        float invD = (1.0 / max(0.001, hitDepth));\n        \n        if (light.type == LIGHT_AMBIENT) {\n            vec3 L = normalize(light.p);\n            float VdotL = pow(max(0.0, dot(rd, L)), 32.0);\n            float k = max(0.0, 1.0 - smoothstep(7., 10., hitDist));\n            float w = textureLod(iChannel2, normalize(rd-L), 0.).r * 2.0 - 1.0;\n            w *= (0.1+(hitDepth*2.));\n            k *= max(0.0, 1.0 - (w));\n            col += ((VdotL * light.s * light.c) * max(0.0, 1.0 - k)) / M_PI;\n        } else {\n            vec3 sd = normalize(light.p - ro);\n            float cone = dot(sd, rd);\n            float k = max(0.0, 1.0 - smoothstep(7., 8., hitDist));\n            float w = textureLod(iChannel2, normalize(tan(rd-sd)), 0.).r * 2.0 - 1.0;\n            cone += (0.1*w*smoothstep(0.2, 2.0, cone));\n            float f = pow(smoothstep(0.8, 1.0, cone), 5.0) * pow(abs(dot(rd, sd)), 64.0);\n            f *= max(0.0, 1.0 - k);\n            col += (light.c * f) / M_PI;\n        }\n    }\n    \n    if (!hitAny) {\n        col += getSky(lights[0], ro, rd);\n    }\n    \n    float dotup = max(0.0, dot(rd, vec3(0, 1, 0)));\n    col += (hitDepth * max(0.0, smoothstep(0.4, -1., dotup))) / M_PI;\n\n    return col;\n}\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -cross(camForward, vec3(0, 1, 0));\n    vec3 camUp = -cross(camRight, camForward);\n    vec3 screenCenter = ro + camForward;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\nvoid getPrimaryRay(vec2 uv, vec2 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 2.5, -8.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    rd.yz *= rot(radians(-1.));\n    \n    if (iMouse.z > 0.01) {\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n    } else {\n        float t = T*0.3;\n        ro.xz *= rot(radians(-16.0)+(cos(t)*0.25));\n        ro.y += 1.*(0.5+(0.5*sin(t-2.)));\n        rd = look(uv, vec3(0.0, 2., 0.0), ro);\n    }\n    \n    ro.y = max(1., ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec2 m = (iMouse.xy-0.5*R.xy)/R.y;\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getPrimaryRay(uv, m, ro, rd);\n    \n    Data data = NEW_DATA;\n    col += render(data, uv, ro, rd);\n    \n    col += pow(luma(col), 2.5)*20.;\n    col += (col*luma(col)) / M_PI;\n    \n    col /= vec3(1.0) + col;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution.xy\n#define T (iTime)\n#define ZERO (min(0, int(iTime)))\n#define M_PI (3.1416)\n#define TAU (M_PI * 2.0)\n#define adot(a, b) (abs(dot(a, b)))\n#define rgb(r,g,b) (vec3(r, g, b) / 255.0) \n\nmat2 rot(float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\n\nvec3 project(vec3 a, vec3 b) {\n  float deno = length(a);\n\n  if (abs(deno) < 0.000001)\n    return vec3(0.0);\n\n  float scalar = dot(b, a) / deno;\n\n  return a * scalar;\n}\n\nvec3 projectOnPlane(vec3 a, vec3 normal) {\n  return a - project(a, normal);\n}","name":"Common","description":"","type":"common"}]}