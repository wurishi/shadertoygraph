{"ver":"0.1","info":{"id":"ftjGRW","date":"1623437527","viewed":225,"name":"Class 5 BRDF - diffuse","username":"xarmalarma","description":"brdf diffuse","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"NlS3zh","parentname":"Class5: BRDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXX 10000000.0\n\nfloat seed = 0.0;\n\n\nvec3 bgColor(vec3 rayDir) {\n    float u =  0.5*(1.0 + rayDir[1]);\n    //return vec3(0.05, 0.05, 0.2);\n    return u*vec3(0.7, 0.8, 0.9) + (1.0-u)*vec3(0.05, 0.05, 0.2);\n}\n    \n// random number between 0 and 1\nfloat random() {\n    return fract(sin(seed++)*43758.5453123);\n}\n\n\nstruct Material {\nvec3 baseColor;      \nfloat metallic;      \nfloat subsurface;    \nfloat specular;      \nfloat roughness;     \nfloat specularTint;  \nfloat anisotropic;   \nfloat sheen;         \nfloat sheenTint;     \nfloat clearcoat;     \nfloat clearcoatGloss;\n};\n\n// all the brdf code is from \n// https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf\n// Thanks to Brent Burley and disneyanimation.com\nconst float PI = 3.14159265358979323846;\nconst float\tONE_OVER_PI = 1.0 / PI;\nfloat sqr(float x) { return x*x; }\n\nvec3 calc_diffuse_term(float dot_nl, float dot_nv, float dot_lh, vec3 base_color, float rough_s)\n{\n    float fd_90_minus_1 = 2.0 * dot_lh * dot_lh * rough_s - 0.5;\n    \n    return base_color * ONE_OVER_PI \n        * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nl, 5.0))\n        * (1.0 + fd_90_minus_1 * pow(1.0 - dot_nv, 5.0));\n}\n\n// anisotropic GGX / Trowbridge-Reitz\n//\nfloat calc_distribution_ggx(float dot_nh, float dot_ht, float dot_hb, vec2 linear_roughness)\n{\n    float rought_x \t= linear_roughness.x * linear_roughness.x;\n    float rought_y \t= linear_roughness.y * linear_roughness.y;\n    float rough_x_s = rought_x * rought_x;\n\tfloat rough_y_s = rought_y * rought_y;\n    \n\tfloat d = (dot_nh * dot_nh\n        + dot_ht * dot_ht * (1.0 / rough_x_s)\n    \t+ dot_hb * dot_hb * (1.0 / rough_y_s));\n\t\n    return ONE_OVER_PI * (1.0 / (rought_x * rought_y * d * d));\n}\n\nvec3 calc_fresnel_schlick(vec3 f0, float dot_vn)\n{\n\treturn f0 + (1.0 - f0) * pow(1.0 - dot_vn, 5.0);\n}\n\nfloat calc_smith_lambda(float a2, float cos_angle)\n{\n    if (cos_angle < 0.01) return 0.0;\n    \n    float sin_angle = sqrt(1.0 - cos_angle * cos_angle);\n\tfloat tan_angle = sin_angle * (1.0 * cos_angle);\n\n\treturn sqrt(1.0 + a2 * tan_angle * tan_angle) * 0.5 - 0.5;\n}\n\nfloat calc_masking_shadow_factor(float dot_nl, float dot_nv, float rought_s)\n{\n    // smith correlated\n\tfloat a2 \t\t= rought_s * 0.5;\n\tfloat lambda_l \t= calc_smith_lambda(a2, dot_nl);\n\tfloat lambda_v \t= calc_smith_lambda(a2, dot_nv);\n\treturn 1.0f / (1.0 + lambda_l + lambda_v);\n}\n\nvec3 calc_specular_term(vec3 fresnel, float dot_nl, float dot_nv, float dot_nh, float dot_lh, \n                        float dot_ht, float dot_hb, vec2 linear_roughness, float rough_s)\n{\n    float v_1_over_denom = 1.0 / (4.0 * dot_nl * dot_nv);\n\n\treturn fresnel\n        * calc_distribution_ggx(dot_nh, dot_ht, dot_hb, linear_roughness)\n        * calc_masking_shadow_factor(dot_nl, dot_nv, rough_s)\n        * v_1_over_denom;\n}\n\nvec3 mon2lin(vec3 x)\n{\n    return vec3(pow(x[0], 2.2), pow(x[1], 2.2), pow(x[2], 2.2));\n}\n\n\n// a Light is defined by a location and a color\nstruct Light {\n    vec3 location;\n    vec3 color;\n};\n\n// Sphere is defined by a center and radius and material: color\nstruct Sphere {\n\tfloat radius;\n\tvec3 center;\n    vec3 color;\n};\n\n// Ray is define by an origin point and a direction vector\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n \nstruct Intersection {\n    int obj;\n    float t;\n};\n\nconst int NUM_SPHERE = 1;\nSphere spheres[NUM_SPHERE];\nMaterial materials[NUM_SPHERE];\nLight  lights[1];\n\n// Intersection code for Ray-Sphere    \nfloat raySphereIntersect(in Ray ray, in Sphere sphere) {\n    \n    vec3 rayToSphere = ray.origin - sphere.center;\n    float b = dot(rayToSphere, ray.direction);\n    float c = dot(rayToSphere, rayToSphere) - (sphere.radius * sphere.radius);\n\tfloat disc = b*b - c;\n    float t;\n    if (disc > 0.0) {\n        t = -b - sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }\n        t = -b + sqrt(disc);\n        if (t > 0.00001) {\n            return t;\n        }  \n    }\n    return MAXX;\n}\n\n// Traverses the entire scene and \n// returns the objectID and the intersection point\nIntersection intersectAllObjects(Ray ray) {\n    float minT = MAXX;\n    int iSphere = -1;\n    \n    for (int i=0; i < NUM_SPHERE; i++) {\n       Sphere sphere = spheres[i];\n       \n       float t = raySphereIntersect(ray, sphere);\n         \n       if (t < minT && t >= 0.001) {\n           // keep track of the closest sphere and intersection\n           iSphere = i;\n           minT = t;\n       }\n   }\n   \n   return Intersection(iSphere, minT);\n}\n  \n\n// create 4 spheres at different locations in different colors\nvoid makeScene(int f) {\n    spheres[0] = Sphere(0.2, vec3(0.0, 0, -1.0), vec3(1, 1, 0));\n    lights[0] = Light(vec3(1.0, 0.8, -0.20), vec3(1, 1, 1));\n    materials[0].baseColor = vec3(0.8, 0.2, 0.2);\n    materials[0].roughness = 0.5;\n}\n\n// samples per pixel\nconst int numSamples=1;\n\n// convert directionToLight and directionToView to tangent space\n//\nvoid convertToTangentSpace(vec3 toLight, vec3 toView, vec3 hitPoint, out vec3 toLightTS, out vec3 toViewTS, out vec3 nTS)\n{\n    // use a matrix to convert\n    vec3 t = normalize(dFdx(hitPoint));\n    vec3 b = normalize(dFdy(hitPoint));\n    vec3 n = normalize(cross(t, b));\n    mat3 xformMatrix = transpose(mat3(t, b, n));\n    \n    toLightTS = xformMatrix * toLight;\n    toViewTS = xformMatrix * toView;\n    nTS = n;\n}\n\n/* The main entry point:\n   * This is called for every pixel on the screen \n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n   \n   // fragCoord ranges from \n   //   in x: 0.5 to iResolution.x-0.5\n   //   in y: 0.5 to iResolution.y-0.5\n   // pixel (0,0) is at the bottom left corner\n  \n   makeScene(iFrame);\n   \n   vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n   \n   float screenDepth = -2.0;\n   \n   float width = iResolution.x;\n   float height = iResolution.y; \n   \n   vec3 samp = vec3(0, 0, 0);\n   seed = 0.0;\n   for (int i=0; i<1*numSamples; i++) {\n       float x = fragCoord.x + random() - 0.5;\n       float y = fragCoord.y + random() - 0.5;\n       \n   \n       // map (0.5, w-0.5) to (-1, 1)\n       // and (0.5, h-0.5) to (-1, 1)\n       x = (x/width)*2.0 - 1.0;\n       y = (y/height)*2.0 - 1.0;\n       \n       // account for the non-square window\n       float aspectRatio = width/height;\n       y = y/aspectRatio;\n              \n       // normalized ray direction\n       vec3 rayDirection = normalize(vec3(x, y, screenDepth));\n       \n       Ray ray = Ray(rayOrigin, rayDirection);\n              \n       // traverse the scene (all spheres) and find the \n       // closest intersected object and intersection point\n       Intersection intersection = intersectAllObjects(ray);\n       \n       int iSphere = intersection.obj;\n       float minT = intersection.t;\n       \n       Sphere sphere;\n       \n       if (iSphere > -1) { // if there is an intersection\n       \n           // to get around iSphere not being constant\n           for (int i=0; i<NUM_SPHERE; i++) {\n               if (i==iSphere) {\n                   sphere = spheres[i];\n                   break;\n               }\n           }\n           \n           // hit coordinates\n           vec3 hit = ray.origin + minT*ray.direction;\n           // normal at the point of ray-sphere intersection\n           vec3 hitPointNormal = normalize(hit-sphere.center);         \n           // vector from intersection to light\n           vec3 hitPointToLight = normalize(lights[0].location-hit);\n           vec3 hitPointToView = ray.origin-hit;\n           \n           vec3 toViewTS;\n           vec3 toLightTS;\n           vec3 nTS;\n           convertToTangentSpace(hitPointToLight, hitPointToView, hit, toLightTS, toViewTS, nTS); \n           vec3 h_ts \t\t= normalize(toLightTS + toViewTS);\n           float dot_nl \t= clamp(toLightTS.z, 0.0, 1.0);\n           float dot_nv \t= clamp(toViewTS.z, 0.0, 1.0);\n           float dot_nh\t= clamp(h_ts.z, 0.0, 1.0);\n           float dot_lh \t= clamp(dot(toLightTS, h_ts), 0.0, 1.0); // same as dot(v_ts, h_ts)\n           float dot_ht\t= h_ts.x;\n           float dot_hb\t= h_ts.y;\n           Material m = materials[0];\n           // lighting\n           vec3 f0 = vec3(0.0, 0.0, 0.0); // TODO: Next Class\n           vec3 fresnel\t= calc_fresnel_schlick(f0, dot_nv);\n           float rough_s = dot_ht * dot_ht * m.roughness * m.roughness\n        \t\t\t\t+ dot_hb * dot_hb * m.roughness * m.roughness; \n   \n           vec3 diffuse_factor = (1.0 - fresnel) * (1.0 - m.metallic);\n            \n   \n           vec3 diffuse_term = diffuse_factor * calc_diffuse_term(dot_nl, dot_nv, dot_lh, m.baseColor, rough_s);\n   \t       vec3 specular_term = vec3(0.0, 0.0, 0.0); // TODO: Next Class\n           \n           vec3 col = diffuse_term*dot_nl;\n           vec3 toneMappedColor = col * (1.0 / (col + 1.0));\n           float gamma = 1.0/2.2;\n           vec3 finalColor = vec3(pow(toneMappedColor.x, gamma), \n                                  pow(toneMappedColor.y, gamma), \n                                  pow(toneMappedColor.z, gamma));\n           \n           samp = samp + finalColor; \n       } \n       else {\n           samp = samp + bgColor(ray.direction);\n\n       }\n   }\n   // average all the samples per pixel\n   fragColor = vec4(samp/float(numSamples), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}