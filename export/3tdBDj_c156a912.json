{"ver":"0.1","info":{"id":"3tdBDj","date":"1613564590","viewed":213,"name":"[RGR] Ray marching 2D (v3)","username":"deeplo","description":"ray marching","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-------------------------------------\n// DEFINITIONS\n//-------------------------------------\n#define S smoothstep\n\n#define EPSILON 0.000001\n\n#define BG_COLOR      vec3(0.01,0.01,0.01)\n\n#define MAX_DISTANCE  100.0\n#define MAX_RM_STEPS  256\n#define MIN_DISTANCE  0.00001\n\n#define SPHERE_CENTER vec2(0.3,0.35)\n#define SPHERE_RADIUS 0.2\n\n#define BOX_CENTER    vec2(-0.55,-0.0)\n#define BOX_SIZE      vec2(0.6,0.2)\n#define BOX_ANGLE     (3.14159/6.0)\n\n#define CAPS_CENTER   vec2(1.1,0.0)\n#define CAPS_RADIUS   0.12\n#define CAPS_IN_H     0.4\n#define CAPS_ANGLE    (0.2*3.14159)\n\n#define TRI_P0 vec2(0.1,-0.2)\n#define TRI_P1 (TRI_P0+vec2(0.4,-0.2))\n#define TRI_P2 (TRI_P1+vec2(-0.45,-0.1))\n\n#define LIGHT_POWER 2.0\n#define LIGHT_RADIUS 0.05\n\n\n\n//-------------------------------------\n// SHAPE TYPES\n//-------------------------------------\nstruct Sphere {\n    vec2 c;\n    float r;\n};\nstruct Box {\n    vec2 c;\n    vec2 s;\n    float a;\n};\nstruct Capsule {\n    vec2  c;\n    float r;\n    float h;\n    float a;\n};\nstruct Triangle {\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\n\n\n//-------------------------------------\n// SHAPE CONSTRUCTORS\n//-------------------------------------\nSphere NewSphere(vec2 pos, float rad) {\n    Sphere s;\n    s.c = pos;\n    s.r = rad;\n    return s;\n}\nBox NewBox(vec2 pos, vec2 size, float angle) {\n    Box bx;\n    bx.c = pos;\n    bx.s = size;\n    bx.a = angle;\n    return bx;\n}\nCapsule NewCapsule(vec2 pos, float radius, float innerH, float angle) {\n    Capsule cp;\n    cp.c = pos;\n    cp.r = radius;\n    cp.h = innerH;\n    cp.a = angle;\n    return cp;\n}\nTriangle NewTriangle(vec2 p0, vec2 p1, vec2 p2) {\n    Triangle t;\n    t.p0 = p0;\n    t.p1 = p1;\n    t.p2 = p2;\n    return t;\n}\n\n\n\n\n//-------------------------------------\n// MATH FUNCTIONS\n//-------------------------------------\nmat2 Rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\n\n\n//-------------------------------------\n// DISTANCE FUNCTIONS\n//-------------------------------------\nfloat GetDistSphere(vec2 position, Sphere sph){\n    // get parameters\n    vec2 center  = sph.c;\n    float radius = sph.r;\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the sphere center\n    position -= center;\n    // compute length\n    d = length(position) - radius;\n//    d = max(0.0, d);\n    // Return distance\n    return d;\n}\nfloat GetDistBox(vec2 position, Box box){\n    // get parameters\n    vec2  center = box.c;\n    vec2  size   = box.s;\n    float angle  = box.a;\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the box center\n    position -= center;\n    // Change origin according to box angle\n    position *= Rot(angle);\n    // compute lengths\n    vec2  dir = abs(position)-size*0.5;\n    float dOut = length(max(dir,vec2(0))); \n    float inner = S(-1.9, -2.0, sign(dir.x)+sign(dir.y) );\n    float dIn = inner*min(abs(dir.x),abs(dir.y));    \n    d = dOut-dIn;\n    // Return distance\n    return d;\n}\nfloat GetDistCapsule(vec2 position, Capsule caps){\n    // get parameters\n    vec2  center = caps.c;\n    float radius = caps.r;\n    float innerH = caps.h;\n    float angle  = caps.a;\n    // Init distance\n    float d = MAX_DISTANCE;\n    // Set origin on the capsule center\n    position -= center;\n    // Change origin according to capsue angle\n    position *= Rot(angle);\n    // compute length\n    vec2  A  = vec2(0.0, innerH*0.5);\n    vec2  B  = vec2(0.0,-innerH*0.5);    \n    vec2  AB = B-A;\n    vec2  AP = position - A;\n    float t  = clamp( dot(AB,AP)/dot(AB,AB), 0.0, 1.0 );\n    vec2  C  = A + t*AB;\n    d = length(position-C)-radius;\n    // Return distance\n    return d;\n}\nfloat GetDistTriangle(vec2 p, Triangle tri )\n{\n    vec2 p0 = tri.p0;\n    vec2 p1 = tri.p1;\n    vec2 p2 = tri.p2;\n    \n    // function retrieved from : https://www.shadertoy.com/view/XsXSz4\n    // Need to take knowledge from it ;)\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = e0.x*e2.y - e0.y*e2.x;\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\tfloat dist = -sqrt(d.x)*sign(d.y);\n//    dist = max(0.0, dist);\n    return dist;\n}\n\n\n\n\n//-------------------------------------\n// RAY MARCHING ALGORITHM\n//-------------------------------------\nfloat RayMarching(vec2 rayOrigin, vec2 rayDirection){\n    // Init algo\n    float dMin      = MAX_DISTANCE;\n    float marchDist = 0.0;\n    vec2  p         = rayOrigin;\n    vec2  normal    = vec2(0,0);\n    // Ray Marching Loop\n    for(int i=0; i<MAX_RM_STEPS && dMin>=MIN_DISTANCE && marchDist<=MAX_DISTANCE;i++){\n        // Get minimum distance to sphere\n        float dMin1 = GetDistSphere(p, NewSphere(SPHERE_CENTER, SPHERE_RADIUS) );\n        // Get minimum distance to box\n        float dMin2 = GetDistBox(p, NewBox(BOX_CENTER, BOX_SIZE, BOX_ANGLE) );\n        // Get minimum distance to capsule\n        float dMin3 = GetDistCapsule(p, NewCapsule(CAPS_CENTER, CAPS_RADIUS, CAPS_IN_H,CAPS_ANGLE) );\n        // Get minimum distance to triangle\n        float dMin4 = GetDistTriangle(p, NewTriangle(TRI_P0, TRI_P1, TRI_P2) );\n        // get minimum from all the minimum\n        dMin = dMin1;\n        dMin = min(dMin,dMin2);\n        dMin = min(dMin,dMin3);\n        dMin = min(dMin,dMin4);\n        // Increase total distance\n        marchDist += dMin;\n        // Set the next marching point (origin + direction * distance)\n        p = rayOrigin + normalize(rayDirection) * marchDist;                \n    }\n    // shadow modifier\n    float shadow = S(-0.0001,0.0001,length(p-rayOrigin)-length(rayDirection));    \n    return shadow;\n}\n\n\n\n//-------------------------------------\n// UTIL FUNCTIONS\n//-------------------------------------\nfloat shapeAlpha(float dist){\n    float cS = 0.0;\n    cS += S(0.1, 0.0, abs(dist));\n    cS *= S(0.0, -0.0000001, dist);\n    return cS;\n}\nvec2 moveLight(float t){  \n\n    float x = cos(t);\n    float y = sin(t);\n    \n    x += cos(4.0*t);\n    y += sin(4.0*t);\n    \n    x*= 1.5;\n    return vec2(x,y)*0.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Get coords normallized according to Y resolution. Screen displays uv between -1/+1  \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // Background color\n    vec3 bg = BG_COLOR*uv.x;\n    vec4 col = vec4(bg,1.0);\n\n    // Light source (mouse position)\n    vec2 lightPos = iMouse.xy;\n    bool autoAnim = (lightPos == vec2(0));\n    lightPos = (2.0*lightPos-iResolution.xy)/iResolution.y;\n    \n    // Auto anim\n    if(autoAnim){\n        lightPos = moveLight(iTime*0.3);\n    }\n    \n    // Set ray origin + direction\n    vec2 rayOrigin = lightPos;\n    vec2 targetDirection = uv-rayOrigin;\n\n    // Ray marching algorithm\n    float shadow = RayMarching(rayOrigin, targetDirection);\n\n    // Prepare light source (disc)\n    float lightDist  = length(uv-lightPos);\n    float lightAlpha = S(LIGHT_RADIUS ,0.0, lightDist); \n    float fading = length(targetDirection);\n    fading = S(LIGHT_POWER,0.0,fading);\n    \n    // Light field (using shadow) + light source\n    vec3 lightColor = vec3(abs(sin(iTime*0.1287))*0.5+0.5,\n                           abs(sin(iTime*0.5687))*0.5+0.5,\n                           abs(sin(iTime*0.3154))*0.5+0.5);\n    col.rgb += lightColor*fading*shadow;\n    col.rgb += lightColor * vec3(lightAlpha);\n\n\n    // Draw elements\n    float d0 = 0.0;\n    float cS = 0.0;\n    d0  = GetDistSphere(uv, NewSphere(SPHERE_CENTER, SPHERE_RADIUS) );\n    cS += shapeAlpha(d0);\n    d0  = GetDistBox(uv, NewBox(BOX_CENTER, BOX_SIZE, BOX_ANGLE) );\n    cS += shapeAlpha(d0);\n    d0  = GetDistCapsule(uv, NewCapsule(CAPS_CENTER, CAPS_RADIUS, CAPS_IN_H,CAPS_ANGLE) );\n    cS += shapeAlpha(d0);\n    d0  = GetDistTriangle(uv, NewTriangle(TRI_P0, TRI_P1, TRI_P2) );\n    cS += shapeAlpha(d0);\n    \n    // apply shadow on shapes\n    col.rgb += vec3(0.5*cS,0.5*cS,cS) * fading*fading;\n\n    // Final Output\n    fragColor = col;    \n}\n\n","name":"Image","description":"","type":"image"}]}