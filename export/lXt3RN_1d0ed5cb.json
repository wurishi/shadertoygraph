{"ver":"0.1","info":{"id":"lXt3RN","date":"1716821275","viewed":82,"name":"Running in the night city","username":"Aurore_B","description":"After watching the video of kishimisu on raymarching, I wanted to going back in raymarching stuff !\nHere is my attempt : a city by night ! \n\n++ there's still room for improvement like adding DOF for a better result!","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","night","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DISPLAY_GAMMA 1.8\n#define MOD3 vec3(.1031,.11369,.13787)\n\n\n//https://www.shadertoy.com/view/lsl3RH\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat smin(float a, float b, float k)\n{\n    float h = max(k - abs(a-b), 0.0)/k;\n    return min(a,b)- h*h*h*k*(1./6.);\n}\n\n//2d\nfloat sdCircle(vec2 uv, vec2 pos, float r){\n    \n    float c = distance(uv, pos);\n    return c;\n   \n}\n\n\n// 2D rotation function\nmat2 rot2D(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 palette( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 opU2(vec2 d1, vec2 d2){\n    return (d1.x < d2.x) ? d1 : d2;\n}\nvec2 opS2(vec2 d1, vec2 d2){\n    return (-d1.x > d2.x) ? d1 : d2;\n}\n\n\n//stars from https://www.shadertoy.com/view/4s33zf by BigWIngs\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat stars(vec2 uv, float t) {\n    t*=3.;\n    \n    float n1 = hash12(uv*10000.);\n    float n2 = hash12(uv*11234.);\n    float alpha1 = pow(n1, 20.);\n    float alpha2 = pow(n2, 20.);\n    \n    float twinkle = sin((uv.x-t+cos(uv.y*20.+t))*10.);\n    twinkle *= cos((uv.y*.234-t*3.24+sin(uv.x*12.3+t*.243))*7.34);\n    twinkle = (twinkle + 1.)/2.;\n    return alpha1 * alpha2 * twinkle;\n}\n//\n\nvec3 addColor(float id, float depth, vec2 uv){\n    vec3 col = vec3(0.0);\n    if (depth > 10.){\n        col = mix(vec3(0.2,0.34,0.50), vec3(0.0,0.0,0.21), uv.y);\n       \n        float t = iTime*0.08;\n        col += stars(uv, t);\n        \n        vec3 col_moon = mix(vec3(235.,209.,174.)/255., vec3(217.,164.,106.)/255., fbm4(uv*4.));\n        float moon = sdCircle(uv, vec2(0.65,.21), 0.38);\n        float glow = pow(0.4/moon,5.);        \n        moon =smoothstep(0.4,0.39,moon);\n        \n        glow = clamp(0.0,1.,glow);\n  \n        col = mix(col, vec3(235.,209.,174.)/255., glow);\n        col = mix(col, col_moon, moon); \n\n        \n    }\n    else {\n        if (id == 2.0){\n            col = palette(clamp(1.-depth*0.2,0.08,1.0), vec3(0.828, 0.348, 0.588), vec3(0.607, 0.154, 0.154), vec3(0.113, 0.157, 0.404), vec3(2.507, 3.167, 0.138));\n            float midpoint = pow(0.5, 2.2);\n            col = (col - midpoint) * 2.5 + midpoint;\n            col *= vec3(0.4);\n        }\n    }\n   return col;\n}\n\nvec2 map(vec3 p){\n    vec3 q = p;\n    q.xz= fract(p.xz)-.5;\n    \n    \n    //buildings\n    vec2 b1 =vec2(sdBox(q-vec3(-0.02,0.0,0.0), vec3(0.4,0.45,0.2)), 2.0);\n    vec2 b2 =vec2(sdBox(q-vec3(0.2,0.0,0.15), vec3(0.1,0.8,0.05)), 2.0);\n    vec2 b3 =vec2(sdBox(q-vec3(-.0,.0,-0.06), vec3(0.5,0.3,0.2)), 2.0);\n    vec2 b4 =vec2(sdBox(q-vec3(-0.15,0.0,0.2), vec3(0.1,0.68,0.15)), 2.0);\n    vec2 b5 =vec2(sdBox(q-vec3(-0.1,0.0,-0.1), vec3(0.2,0.54,0.05)), 2.0);\n\n\n    vec2 building = opU2(b1,b2);\n    building = opU2(building,b3);\n    building = opU2(building,b4);\n    building = opU2(building,b5);\n\n\n    return building;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, in float eps )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*eps;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord *2.0 - iResolution.xy)/iResolution.y;\n    \n    //ray origin / camera position\n    vec3 ro = vec3(0.1+sin(iTime*0.45)*0.4,0.72+sin(iTime*0.45*3.)*0.12,0.+(iTime*0.35));\n    //ray direction\n    vec3 rd = normalize(vec3(uv*0.6,1));\n    rd.xy *= rot2D(sin(iTime*0.45)*0.06);\n    //final pixel color\n    vec3 col = vec3(0.);\n    \n    //total distance travelled\n    float t = 0.;\n    vec2 d = vec2(0.);\n    int i =0;\n    \n    //Raymarching\n    for (; i<100; i++){\n        //pos along the ray\n        vec3 p = ro + rd * t;\n\n        //current distance to the scene \n        d = map(p);\n\n        t+=d.x;\n        \n        //early stop if close enough - too far\n        if(d.x<0.001 || t> 100.) break;\n    }\n    \n    //Coloring\n    col = addColor(d.y, t, uv);\n    \n    float height = ro.y + rd.y * t;\n    \n    if(t<8.){\n        vec3 p = ro + rd * t;\n        vec3 nor = calcNormal( p, 0.001 );\n        vec3 q = p;\n        q.xz= fract(p.xz);\n        \n        q.y = fract(q.y*2.5);\n        \n        //vec3 x = vec3(q.yz,.0);\n        //vec3 y = vec3(q.zx,.0);\n        //vec3 z = vec3(q.xy,.0);\n        \n        vec2 x = q.zy;\n        vec2 y = q.xz;\n        vec2 z = q.xy;\n        \n        \n        vec3 w = pow(abs(nor), vec3(0.8));\n        \n        vec3 colYZ = texture(iChannel0, x).rgb;\n        vec3 colXY = texture(iChannel0, z).rgb;\n        \n        \n        col +=  (colYZ*w.x  + colXY*w.z );\n \n    }\n     \n    if(t<14.0){\n        vec3 fogColor = vec3(0.05, 0.0, 0.1);\n        col = mix(col.rgb, fogColor, exp(-height*1.2));\n    }\n    \n    \n    // from https://www.shadertoy.com/view/lstBDl\n    //inverse gamma correction\n\tfragColor = vec4(pow(col.rgb, vec3(1.0 / DISPLAY_GAMMA)), 1.0);\n    \n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//https://iquilezles.org/articles/distfunctions2d/\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord *2.0 - iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0.);\n        \n    vec2 uv_window = uv;\n    \n    uv_window *= 1.9;\n    \n    uv_window.x= fract(uv_window.x*2.0)-0.5;\n    \n    // Aspect ratio\n    uv_window = vec2(uv_window.x, uv_window.y*1.8);\n    \n    uv_window= fract(uv_window*2.0)-0.5;\n    \n    float box = sdRoundedBox(uv_window, vec2(0.34,0.44), vec4(0.01,0.01,.01,.01));\n    box = smoothstep(0.05,0.01, box);\n    \n    float mask = sdBox(uv, vec2(200.0,.54));\n    mask = step(mask,0.3);\n\n    float windows = min(box, mask); \n\n    float line1 =sdBox(vec2(uv.x, uv.y-0.92), vec2(2.0,.001));\n    float line1_m = smoothstep(0.02,0.01, line1);\n    \n    float line2 =sdBox(vec2(uv.x, uv.y+0.92), vec2(2.0,.001));\n    float line2_m = smoothstep(0.02,0.01, line2);\n    \n    float lines = max(line1_m, line2_m);\n    \n    float light1 = pow(0.015/line1,1.8);\n    float light2 = pow(0.015/line2,2.0);\n    \n    float maskl1 = sin((uv.x+iTime*0.7) *8.0);\n    maskl1 = step(maskl1,.1);\n    float maskl2 = sin((uv.x+iTime) *2.0);\n    maskl2 = step(maskl2,.1);\n\n    light1 = min(maskl1, light1);\n    light2 = min(maskl2, light2);\n\n    \n    vec2 uv_placement = vec2(uv.x*2.51,uv.y*2.29);\n    //https://www.shadertoy.com/view/MsXSzM\n    vec4 noise = texture(iChannel0, floor(uv_placement * float(3.)) / float(9.));   \n\tfloat p =  mod(noise.r + noise.g + noise.b + iTime * float(0.02), 0.72);\n    p = min(max(p * 3.0 - 1.8, 0.02), 2.0);\n    p*= 1.6;\n    \n    //grading\n    col = mix(col, vec3(0.2), lines);\n    col = mix(col, vec3(0.9), light1);\n    col = mix(col, vec3(0.9), light2);\n    col = mix(col, vec3(p), windows);\n    \n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}