{"ver":"0.1","info":{"id":"MttyzB","date":"1533115161","viewed":1269,"name":"blackbody light blub","username":"archibate","description":"a light blub. blackbody() from [url]https://www.shadertoy.com/view/MslSDl[/url].","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["3d","ray","sdf","physics","blackbody"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI (atan(1.)*4.)\n#define TAU (atan(1.)*8.)\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n#define MAXT 1e1\n#define MINT 9e-4\n#define PRECIST (2.*MINT)\n\nfloat smoothmin(float w, float x, float y)\n{\n    return mix(x, y, smoothstep(-w,w,x-y));\n}\n\nfloat smoothmax(float w, float x, float y)\n{\n    return mix(y, x, smoothstep(-w,w,x-y));\n}\n\nfloat sdBlub(vec3 p)\n{\n    p *= vec3(1,.95,1);\n    return smoothmin(.06,\n                 sdSphere(p,.3),\n                 smoothmax(.04,\n                     -p.y-.3,\n                     max(p.y+.1,\n                         sdSphere(p*vec3(1,.6,1),.241)\n                        )\n                    )\n                );\n}\n\nfloat sdCylinder(vec3 p, float r)\n{\n    return length(p.xz) - r;\n}\n\nfloat sdLimCylinder(vec3 p, float r, float h1, float h2)\n{\n    return max(-p.y+h1,\n               max(p.y-h2,\n                   sdCylinder(p, r)\n                   )\n               );\n}\n\nfloat sdCoolCylinder(vec3 p, float r, float rd, float h1, float h2)\n{\n    return sdLimCylinder(p, r - rd*sin(100.*p.y), h1, h2);\n}\n\nvec2 Xmin(vec2 m, vec2 n)\n{\n    if (m.x < n.x)\n        return m;\n    else\n        return n;\n}\n\nvec2 Xmax(vec2 m, vec2 n)\n{\n    if (m.x > n.x)\n        return m;\n    else\n        return n;\n}\n\n#define MX(id,t) vec2(t,id)\n#define XY(m) int((m).y)\n#define Y_GLASS 1\n#define Y_COPPER 2\n#define Y_METAL 3\n\nvec2 map(vec3 p)\n{\n    vec2 m1 = MX(Y_GLASS,sdBlub(p));\n    vec2 m2 = MX(Y_COPPER,sdCoolCylinder(p,.16,.0094,-.5,-.3));\n    return Xmin(m1, m2);\n}\n\n#define STEPS 70\n\nvec2 trace(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro + t*rd;\n        vec2 m = map(p);\n        if (m.x < MINT)\n            return MX(XY(m), t);\n        t += m.x;\n    }\n    return MX(0, MAXT);\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float precis = PRECIST * t;\n\n    vec2 e = vec2(1,-1)*precis;\n    return normalize( e.xyy*map( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( p + e.yxy ).x + \n                      e.xxx*map( p + e.xxx ).x );\n}\n\n#define background(rd) texture(iChannel0, rd).rgb\n\n/*float exstep(float e1, float e2, float x)\n{\n    return exp((x-e2)/(e1-e2))-exp(1.);\n}*/\n#define exstep smoothstep\n\n#define wolfshape(x) .04*cos(TAU*(x)/.2)\n\nfloat liWolfram(vec3 ro, vec3 rd)\n{\n    float c = ro.z + normalize(rd).z;\n    c *= rd.z;\n    \n    vec2 p = ro.xy - (ro.z / rd.z) * rd.xy;\n    return smoothstep(.192,.168,abs(p.x))\n        * smoothstep(.03,.006,abs(p.y - wolfshape(p.x)));\n}\n\n// https://www.shadertoy.com/view/MslSDl\nvec3 blackbody(float _t)\n{\n    // See: http://en.wikipedia.org/wiki/Planckian_locus\n    //      under \"Approximation\"\n    \n    float u = (0.860117757 + 1.54118254e-4*_t + 1.28641212e-7*_t*_t)\n        / (1.0 + 8.42420235e-4*_t + 7.08145163e-7*_t*_t);\n    \n    float v = (0.317398726 + 4.22806245e-5*_t + 4.20481691e-8*_t*_t)\n        / (1.0 - 2.89741816e-5*_t + 1.61456053e-7*_t*_t);\n    \n    // http://en.wikipedia.org/wiki/CIE_1960_color_space\n    // -> http://en.wikipedia.org/wiki/XYZ_color_space\n    \n    float x = 3.0 * u / (2.0 * u - 8.0 * v + 4.0);\n    float y = 2.0 * v / (2.0 * u - 8.0 * v + 4.0);\n    float z = 1.0 - x - y;\n    \n    float Y = 1.0;\n    float X = (Y/y) * x;\n    float Z = (Y/y) * z;\n    \n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n    mat3 XYZtosRGB = mat3(\n         3.2404542,-1.5371385,-0.4985314,\n        -0.9692660, 1.8760108, 0.0415560,\n         0.0556434,-0.2040259, 1.0572252\n    );\n    \n    vec3 RGB = vec3(X,Y,Z) * XYZtosRGB;\n    return RGB * pow(0.0004*_t, 4.0);\n}\n\n#define bgm_glass(ro,rd) background(rd)//bgmwolf(ro, rd)\n#define bgm_copper(ro,rd) background(rd)\n#define bgm_metal(ro,rd) background(rd)\n#if 0\n#define bgm0(ro,rd) background(rd)\n#define bgm00 1\n#else\n#define bgm0(ro,rd) bgm00(rd, vec3(0))\nvec3 bgm00(vec3 rd, vec3 liclr)\n{\n    if (liclr.r == 0.)\n    \tliclr = blackbody(2800.+800.*sin(iTime));\n    return vec3(.1)+.3*liclr*smoothstep(0.,4.,pow(rd.z,5.));\n}\n#endif\n\nvec3 bgmw(vec3 ro, vec3 rd)\n{\n    vec3 liclr = blackbody(3400.+1000.*sin(iTime));\n#ifndef bgm00\n    vec3 clr = bgm00(rd, liclr);\n#else\n    vec3 clr = bgm0(ro, rd);\n#endif\n    float li = liWolfram(ro, rd);\n    return mix(clr, liclr, li);\n}\n\nint radar(in vec3 ro, in vec3 rd, out vec3 p, out vec3 n)\n{\n    vec2 m = trace(ro, rd);\n    float t = m.x;\n    if (t >= .98*MAXT)\n        return 0;\n    p = ro + t*rd;\n    n = normal(p, t);\n    return XY(m);\n}\n\n#define ETA (1./1.5)\n#define FP 5.\n\nvec3 radiance(vec3 ro, vec3 rd)\n{\n    vec3 p, n;\n    int y = radar(ro, rd, p, n);\n    if (y == 0)\n        return bgm0(ro, rd);\n    \n    vec3 rrd = reflect(rd, n);\n    if (y == Y_GLASS) {\n    \tvec3 rclr = bgm_glass(p, rrd);\n    \tvec3 tclr = bgmw(p, rd);\n        \n\t\tfloat F = (1.0 - ETA) / (1.0 + ETA); F*=F;\n        float c = dot(rd,n); c*=c;\n        float ratio = mix(pow(1.-c, FP), 1., F);\n        return mix(tclr, rclr, ratio);\n    } else if (y == Y_COPPER) {\n    \tvec3 rclr = bgm_copper(p, rrd);\n        return rclr * vec3(.98,.95,.6);\n    } /*else if (y == Y_METAL) {\n    \tvec3 rclr = bgm_metal(p, rrd);\n        return rclr;\n    }*/\n}\n\nmat3 rotateX(float a)\n{\n    return mat3(\n        1,0,0,\n        0,cos(a),-sin(a),\n        0,sin(a),cos(a));\n}\n\nmat3 rotateY(float a)\n{\n    return mat3(\n        cos(a),0,sin(a),\n        0,1,0,\n        -sin(a),0,cos(a));\n}\n\nmat3 rotateZ(float a)\n{\n    return mat3(\n        cos(a),-sin(a),0,\n        sin(a),cos(a),0,\n    \t0,0,1);\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{\n    vec2 u = (U - iResolution.xy/2.) / iResolution.y;\n    \n    mat3 mt = rotateY(iTime*0.);\n    vec2 mouse = iMouse.xyz==vec3(0)?vec2(0):(iMouse.xy-iResolution.xy/2.)/iResolution.y;\n    mat3 mm = rotateY(mouse.x) * rotateX(-mouse.y);\n    vec3 eye = mt*vec3(0,0,-1);\n    vec3 dir = mt*mm*normalize(vec3(u.x,u.y,1));\n    \n    vec3 c = radiance(eye, dir);\n    O = vec4(c,1.);\n}","name":"Image","description":"","type":"image"}]}