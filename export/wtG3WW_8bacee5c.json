{"ver":"0.1","info":{"id":"wtG3WW","date":"1578927113","viewed":77,"name":"Trace 2D","username":"spalmer","description":"testbed for testing raytracing stuffs in 2D.\nanalytical precise intersections.\nmostly useful for bounding shapes, skipping empty space quickly.\nfor 3d, mostly just change vec2 to vec3.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Trace 2D !\n\n// for debugging 3d-style ray tracing methods\n// in 2 dimensions where the problems\n// are simpler and easier to visualize\n\n// see Common tab for shape and trace and render functions\n\nvoid mainImage(out vec4 c, vec2 p)\n{\n    vec2 R = iResolution.xy\n      , q = StoQ(p, R)\n      , m = StoQ(iMouse.xy, R)\n      , o = iMouse.z < 0. ? m : StoQ(abs(iMouse.zw), R);\n    const float brad = .5; //.125; //.75; // main object scale\n    c.rgb = render(q, o, m, brad, R.y);\n    c.rgb = pow(c.rgb, vec3(1./2.2)); // to srgb gamut\n    c.a = 1.;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// copies of sdf functions from my Dist 2D\n// https://shadertoy.com/view/WtVGWm\n\nconst float pi = acos(-1.) //3.141592\n    , infinity = 3.4e38\n    , invalid = -3.4e38;\n\n// aspect-correct windowing\nvec2 StoQ(vec2 s, vec2 r)\n{\n\treturn (2. * s - r) / r.y;\n}\n\n// signed distance\n\nfloat dbox(float p)\n{\n    return abs(p) - 1.;\n}\n\n\nfloat dplaine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 r = p - a, d = normalize(b - a);\n    return dot(r, vec2(-d.y, d.x));\n} // watch for nan!\n\nfloat dline(vec2 p, vec2 a, vec2 b)\n{\n    return abs(dplaine(p, a, b));\n}\n\n\nfloat dball(vec2 p)\n{\n    return length(p) - 1.;\n}\n\nfloat dslab(vec2 q, vec2 n)\n{\n    return dbox(dot(q, n));\n}\n\nfloat dslabx(vec2 q)\n{\n    return dslab(q, vec2(1, 0));\n}\n\n// these shapes are all exceedingly sharp at the corners.\n// Meaning you can't poof them to make them round.\n// should replace distance in corner voronoi regions\n// but don't because this is a test for ray *tracing*.\n// Can't easily poof traces either, so... it's fine I guess.\n\n\nfloat dbox(vec2 q)\n{ // probably easier to just go ahead and fold space more, for distance calcs\n    // using similar mechanisms to the tracers is bound to be relatively inefficient.\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(1, 0)));\n    d = max(d, dslab(q, vec2(0, 1)));\n//    if (all(lessThan(vec2(1.), abs(q)))) d = distance(abs(q), vec2(1));\n    return d;\n}\n\n\nfloat ddiamond(vec2 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(1, 1)));\n    d = max(d, dslab(q, vec2(1,-1)));\n    return d;\n}\n\nfloat dhexagon(vec2 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(.8660254, .5)));\n    d = max(d, dslab(q, vec2(.8660254,-.5)));\n    d = max(d, dslab(q, vec2(     0, 1)));\n    return d;\n}\n\nfloat doctagon(vec2 q)\n{\n    float d = -3.4e38;\n    d = max(d, dslab(q, vec2(1   )*.707107));\n    d = max(d, dslab(q, vec2(1,-1)*.707107));\n    d = max(d, dslab(q, vec2(        1, 0)));\n    d = max(d, dslab(q, vec2(        0, 1)));\n    return d;\n}\n\nfloat ddisc(vec2 p, vec2 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat dlens(vec2 p) //, float r, float t)\n{\n    p.x = abs(p.x) + .5;\n    return length(p) - (1./.86607); //- sqrt(2.);\n}\n\n// ray tracing\n\n#if 0\n// TODO\nstruct Trace\n{ // info maintained by TraceObject\n    float d; // closest hit distance (init to 3.4e38 or infinity or sky or even like 10 for very small scenes)\n    int i;   // closest object index (material, etc., init to sky, maybe -1)\n};\n\nvoid Object(inout Trace t, float d, int i)\n{\n\tif (0. <= d && d < t.d)\t{\n        t.d = d; t.i = i; \n    }\n}\n#endif\n\n// flat stuff\n\n\n// at zero, doublesided, considers ray as a bidirectional line trace so rarely fails\nfloat tplaner(float ro, float rd)\n{\n\treturn abs(ro) < 1e-7 ? 0. : ro / -rd;\n}\n// at zero, doublesided\nfloat tplane(float ro, float rd)\n{\n\treturn ro * rd > 0. ? -1. : tplaner(ro, rd);\n}\n// at zero, onesided\nfloat thalfspace(float ro, float rd)\n{\n\treturn ro <= 0. ? 0. : tplane(ro, rd);\n}\n// trace intersections thru -1..1 unit slab and intersect the ranges incrementally\n// should initialize tmin to 0. and tmax to FLT_MAX or 3.4e38 or so\nvoid tslab(float no, float nd\n              , inout float tmin, inout float tmax)\n{\n    if (nd != 0.) {\n        float d0 = no / -nd; // d to central plane\n        nd = abs(1./nd); //nd *= sign(nd);\n        float d1 = d0 + nd;\n        d0 -= nd;\n        if (d0 > tmax\n           || d1 < tmin) {\n            tmin = tmax = -1.;\n        }\n        if (d0 > tmin) {\n            tmin = d0;\n        }\n        if (d1 < tmax) {\n            tmax = d1;\n        }\n        if (!(tmin < tmax)) {\n            tmin = tmax = -1.;\n        }\n    } else if (abs(no) <= 1.) {\n\t\t// leave unchanged\n    } else\n        tmin = tmax = -1.;\n}\n\n// trace 1d unit box -1..+1\nfloat tbox(float ro, float rd)\n{\n    float tmin = 3.4e38, tmax = .0;\n    tslab(ro, rd, tmin, tmax);\n    return tmin;\n}\n\nfloat tplaney(vec2 ro, vec2 rd) // themiy? thspacey? idk about name.  \n{\n    return thalfspace(ro.y, rd.y);\n}\n\n\nvoid tslabinc(vec2 ro, vec2 rd, vec2 pn\n              , inout float tmin, inout float tmax)\n{\n    tslab(dot(pn, ro), dot(pn, rd)\n          , tmin, tmax);\n}\n\nfloat tslabx(vec2 ro, vec2 rd)\n{\n    float tlo = 0., thi = 3.4e38;\n    tslabinc(ro, rd, vec2(1,0), tlo, thi);\n    return tlo;\n}\n\n\nfloat tbox(vec2 ro, vec2 rd)\n{\n    float tlo = 0., thi = 3.4e38;\n    tslabinc(ro, rd, vec2(1,0), tlo, thi);\n    tslabinc(ro, rd, vec2(0,1), tlo, thi);\n    return tlo;\n}\n\n\n// mainly so can extend to\n// 3d and make into toctahedron!\nfloat tdiamond(vec2 ro, vec2 rd)\n{\n    float tlo = 0., thi = 3.4e38;\n    tslabinc(ro, rd, vec2(1, 1), tlo, thi);\n    tslabinc(ro, rd, vec2(1,-1), tlo, thi);\n    return tlo;\n} // octa needs 4 slabs total\n\nfloat thexagon(vec2 ro, vec2 rd)\n{\n    float tlo = 0., thi = 3.4e38;\n    tslabinc(ro, rd, vec2(.8660254, .5), tlo, thi);\n    tslabinc(ro, rd, vec2(.8660254,-.5), tlo, thi);\n    tslabinc(ro, rd, vec2(        0, 1), tlo, thi);\n    return tlo;\n}\n\nfloat toctagon(vec2 ro, vec2 rd)\n{\n    float tlo = 0., thi = 3.4e38;\n    tslabinc(ro, rd, vec2(1   )*.707107, tlo, thi);\n    tslabinc(ro, rd, vec2(1,-1)*.707107, tlo, thi);\n    tslabinc(ro, rd, vec2(        1, 0), tlo, thi);\n    tslabinc(ro, rd, vec2(        0, 1), tlo, thi);\n    return tlo;\n}\n\n\n// round stuff\n\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{ // f(t) = dot(f, vec3(1.,vec2(1.,t)*t)) == 0\n\tfloat d = sqrt(.25 * f.y * f.y - f.x * f.z);\n\tif (f.y * f.z < 0.) d = -d;\n\treturn (d - .5 * f.y) / f.z;\n} // see also The Quadratic Equation\n// actually I don't believe it actually works in the general case anymore\n// it only handles the inputs that trace(Ray, vec2, float) gives it\n\n// my full quadratic equation solver, just in case\nvec2 Roots(vec3 f)\n{ // f(x) = (c * x + b) * x + a\n\tfloat c = f.z, b = f.y, a = f.x;\n\tvec2 ret = vec2(invalid);\n\tb *= .5; // optimization moved the divide by 2 up front instead of at end with a, versus standard quadratic formula\n\tfloat d = b * b - a * c; // discriminant\n\tif (d >= .0) { // any (real) solutions?\n\t\tfloat g = 1. / c;\n  \t\tif (d == .0) // abs(d) < 1e-7) //\n\t\t\tret = vec2(-b * g, invalid); // one solution and invalid\n\t\telse {\n\t\t\tfloat f = sqrt(d)\n\t\t\t, r = -b;\n\t\t\tret = vec2(r - f, r + f) * g; // two solutions\n\t\t}\n\t}\n\treturn ret; // avoiding multiple returns\n}\n// a good chunk of that awkwardness is due to the mismatch\n// between the vec3 argument monomial coefficients and the\n// alphabetic names used in the old-school quadratic equation solution.\n// while I certainly don't want to involve member access dots everywhere,\n// it may not be the best way to write what it's doing.\n// some more confusion was added by handling the tangent-grazing case by returning\n// one solution and invalid - could simply let it return the same solution twice.\n// b is mentioned several times.  a only once!  and c only twice, one to get a divisor\n// which is used in alternate execution paths.\n// I want to redo it without so much clutter TODO\nvec2 RootsB(vec3 f)\n{\n\tvec2 ret = vec2(invalid);\n\tfloat b = .5 * f.y, s = b * b - f.x * f.z; // discriminant\n\tif (s >= .0) { // any (real) solutions?\n\t\tfloat e = sqrt(s), r = -b;\n\t\tret = vec2(r - e, r + e) / f.z; // two solutions\n\t}\n\treturn ret; // avoiding multiple returns\n}\n// in fact if one wanted to rely a bit more on the optimizer,\n// could be redone as one big return ?: by moving the\n// e and r temporaries out of the if clause, like so:\nvec2 RootsC(vec3 f)\n{\n\tfloat b = -.5 * f.y, s = b * b - f.x * f.z, r = sqrt(s);\n\treturn s < .0 \n        ? vec2(invalid)\n        : vec2(b - r, b + r) / f.z;\n}\n// that's nice and elegant.  I even got rid of old r, now b is always negated\n// as part of the .5 constant factor, renamed e to r since it was free and\n// stands for \"root of s\", s is the discriminant.  Working well!  I may\n// just use it as the main solver.\n\n#if 1\n// I found a nice simple sphere tracer\n// at https://shadertoy.com/view/WtGSDK\n// idk if he wrote it or got from somewhere else\n// but I think I can simplify it and then maybe find a way to simplify mine!\n\n// sphere intersection test\n/*float tsphere(vec2 ray, vec2 dir, vec2 center, float radius)\n{\n    vec2 rc = ray - center;\n    float c = dot(rc, rc) - radius * radius;\n    if (c < 0.) return 0.;\n    float b = dot(dir, rc);\n    // solve quadratic equation?\n    float d = b * b - c;\n    float t = -b - sqrt(abs(d));\n    return d < 0. || t < 0. ? -1. : t;\n    //t = min(t, d); // simply a way to fold both negative tests together\n    float st = step(0.0,min(t,d)); // branchless miss handling\n    return mix(-1., t, st);\n    //return t >= 0. ? t : -1.; // is this really necessary?  try handle NaN\n    return t;\n}*/\n// I, uh, recombobulated it.  should handle negative radii, but that needs tested.  I think it needs another sign(r) somewhere\nfloat tsphere(vec2 o, vec2 d, float r)\n{\n    float c = dot(o, o) - r * r, b = dot(o, d), s = b * b - c, t = -b - sqrt(abs(s));\n    return c * sign(r) < 0. ? 0. : s < 0. || t < 0. ? -1. : t;\n}\n//    return tsphere(o, d, vec2(0), r);\n// could in fact express in terms of tball, by rescaling,\n// at expense of considerable accuracy.\n// Huge spheres don't like that approach!\n// anyway, one obtains these tight little solutions by\n// inlining the quadratic equation solver and simplifying\n// all the constant factors, in this case f.z = c == 1.0 \n// which eliminates a considerable amount of work.\n// The entire g divisor goes away, for instance.\n#endif\n\n// trace sphere at origin with radius 1\n// very simplified vs. full sphere case\nfloat tball(vec2 o, vec2 d)\n{\n//    return tsphere(o, d, 1.); // in terms of tsphere\n    float s = dot(o, o) - 1.; // discriminant must handle case where it's inside\n    if (s <= 0.) return 0.;\n    return RootsC(vec3(s, 2. * dot(o, d), 1.)).x; // trying different solvers\n    return RootsB(vec3(s, 2. * dot(o, d), 1.)).x;\n//    return Roots(vec3(s, 2. * dot(o, d), 1.)).x; // and .y is the far side, the exit\n\treturn Root(vec3(s, 2. * dot(o, d), 1.));\n}\n// usually returns nan when it misses, so be careful testing result.\n\n\nfloat tlens(vec2 ro, vec2 rd)\n{\n    float s = .86607; //sqrt(.5); //\n    float a = tball((ro + vec2(.5,0)) * s, rd) / s;\n    float b = tball((ro - vec2(.5,0)) * s, rd) / s;\n    return a >= 0. && b >= 0. ? max(a, b) : -1.;\n}\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x*b.y - a.y*b.x;\n}\n\n// the idea is that dot(ro, rd) should give\n// cos of angle between ro and rd, times length of ro times length of rd\n// then you solve SSA right triangle problem given \n// two sides (radius=1 and length(ro)) \n// where sin(a) = opposite/hypotenuse,\n// but we need cos(a) instead which is sqrt(1-s*s)\n// so after you muddle with that equation for a while\n// it all falls out and you're left with the above or below\n\n// cheaper than   tball(ro / radius, rd) >= 0.\n\n// query if ray intersects disc of given radius at origin as efficiently as possible\nbool idisc(vec2 ro, vec2 rd, float radius)\n{\n    float vc = dot(ro, rd), vr = dot(ro, ro) - radius*radius;\n    return (vc < 0. && vr * dot(rd, rd) <= vc * vc) || vr <= 0.;\n}\n// this works great even though I just worked it out from scratch lol\n// even though vr <= 0. is a trump condition, \n// it's not the best early out test.\n// Most rays would fail it.\n// vc < 0. is better because it quickly culls out\n// cases where vc >= 0 && vr > 0. \n// without needing to do the other dot product and\n// multiplies, due to short-circuit boolean eval.\n// unfortunately it means I do a dot product (vc) \n// that may never be truly needed (if ray starts inside disc)\n//, rr = radius * radius\n    // if you look carefully, you can see there's a common\n    // (vo - rr) in (vo <= rr) == (vo - rr) <= 0\n// now vr is a common condition, otherwise I would \n// do vr <= 0. test as vo <= rr, as I was before.\n// vo was dot(ro, ro) but since is now used only once to compute vr..\n\n#if 0 \n// with those names, mine would look like: (for comparison)\n    float b = dot(m, d), c = dot(m, m) - radius*radius;\n    return (b < 0. && b * b >= c * dot(d, d)) || c <= 0.;\n#endif // yup, they're actually very close, as it turns out.\n // he calls vc \"b\" and vo \"c\" and ro \"m\" and rd \"d\" and he uses a struct for the sphere with center\n#if 0 \n// I could try his way here and see what it cleans up to:  idk about his naming etc.\n// I should double-check what Ericson's book\n// \"Real-Time Collision Detection\" says.\n// no, he's doing something quite similar I guess but going about it\n// much like solving the quadratic, and does the early out the other way.\n// however he doesn't supply the necessary dot(d,d) normalization factor\nbool idisc_cericson(vec2 m, vec2 d, float radius)\n{\n    float c = dot(m, m) - radius * radius;\n    if (c <= 0.) return true;\n    float b = dot(m, d);\n    if (b > 0.) return false;\n    return b * b >= c * dot(d, d); // there, I completed his! //return b * b >= c; //b*b - c >= 0.; //\n} // basically Ericson's TestRaySphere without all the fluff, semi-optimized\n// BTW he handwaves over the \"d not unit length\" scenario referring back to the quadratic equation.\n// so his actually only handles d = normalize(d), length(d) == 1 case.\n// other than that it's not bad.  like I said I don't like his choice\n// of early out, and his seems a bit longwinded and branchy, \n// but that's just because mine uses short-circuit boolean eval\n// to do same thing in different order.\n#endif\n\n// the center-relative ro isn't too much of an imposition on the caller\n// so long as a full transformation is not required.\n\n// this isn't how I want to parameterize it,\n// as rescaling is expensive, and radius is usually not 1.0\n// idisc is now pretty optimal but wrap for unit shape like the others\n\n// query if ray intersects unit ball at origin as efficiently as possible\nbool iball(vec2 ro, vec2 rd)\n{\n    return idisc(ro, rd, 1.); \n}\n// in fact idisc is now so awesome there's no reason to repeat it here with radius==1.\n//    float vc = dot(ro, rd), vo = dot(ro, ro), rr = 1.;\n//    return (vc < 0. && (vo - rr) * dot(rd, rd) <= vc * vc) || vo <= rr;\n//    return (vc < 0. && vo <= vc * vc / dot(rd, rd) + rr) || vo <= rr;\n\n// if you know length(rd) == 1., can avoid dividing by dot(rd, rd) above\n//|| vo < 1. // with above eq comes for free,\n// could use vo <= max(vc*vc + 1., 1.) but since \n// there's no way vc^2 can be < 0 anyway, no difference.\n\n\n// an axis-aligned cylinder is just a box in 2d\n\n// a rounded box would be one of those\n// kaleidoscoped plus / cross / square jack shapes\n// with small spheres unioned into the corners\n// so far I don't need to trace those\n\n// before I go too much further I'd like to \n// come up with a system to do generalized\n// ray tracing of scenes, a better interface.\n// maintaining separate ro and rd, tmin and tmax \n// loose floats is a royal PITA and confusing as heck.\n// also I'd like to take a crack at rendering\n// a scene based only on the tracing info,\n// without needing some SDF to back it up.\n// Generally when doing ray tracing, making the \n// tracing functions is difficult enough that\n// folks don't want to be saddled with having\n// to maintain a separate parallel SDF just for normals etc.\n// I'm working on something in https://shadertoy.com/view/ttV3WG\n// which may turn into something worth using here.\n\n\nfloat dpyras(vec2 q)\n{\n    q.x = mod(q.x + 9., 4.) - 2.;\n    q.x = abs(q.x);\n    float dp = (q.y + q.x - 1.) * sqrt(.5);\n    if (q.y > q.x + 1.) dp = length(q-vec2(0,1));\n    float r = min(dp, q.y);\n    return r;\n} // this is a true proper sdf\n\nvoid tpyrun(vec2 ro, vec2 rd, inout float tlo, inout float thi)\n{\n    float t = tdiamond(ro, rd); // kludge - not optimal, just getting job done for now\n    if (!isnan(t) && t >= 0. && t < thi)\n        thi = tlo = t; //min(tlo, t);\n}\n\nfloat tpyras(vec2 ro, vec2 rd)\n{\n    float t = tplaney(ro, rd);\n    ro.x = mod(ro.x + 9., 4.) - 2.;\n    float tlo = 0., thi = t < 0. ? 3.4e38 : t;\n    // neighbor scan range\n    const int scan = 7; //5; //3; //1; //\n    for (int i = -scan; i <= scan; ++i)\n    \ttpyrun(ro + vec2(4. * float(i),0), rd, tlo, thi);\n    \n    if (thi < 3.4e38 && thi >= 0. && tlo <= thi) {\n        t = thi; // tlo? idk \n    }\n    return t;\n}\n\n\nfloat dshape(vec2 q)\n{\n//    return dball(q/2.)*2.; // HACK debugging\n    return\n    //    dball\n    //    dlens\n    //    dslabx\n    //    dbox\n        ddiamond\n    //    dhexagon\n    //    doctagon\n    //    dpyras\n        (q);\n}\n\nfloat tshape(vec2 ro, vec2 rd)\n{\n//    return tball(ro/2., rd)*2.; // HACK debugging\n//    return tsphere(ro, rd, vec2(0), 1.);\n    return \n    //    tball\n    //    tlens\n    //    tslabx\n    //    tbox\n        tdiamond\n    //    thexagon\n    //    toctagon\n    //    tpyras\n        (ro, rd);\n}\n// quick bounding shape intersection\nbool ishape(vec2 ro, vec2 rd)\n{\n//    return idisc(ro, rd*1., 1.); //2.); //.5); // HACK debugging //_cericson\n    return\n        iball\n    //    ibox TODO\n        (ro, rd);\n}\n\n// distance field color accumulator macro\n// basically keeps only the closest surface's color and distance.\n// beware dangling else issues; use {} just in case, requires do to allow trailing semicolon\n#define DR(od, oc, nd, nc) \\\ndo { float _nd = (nd); \\\n    if (_nd < 0. || _nd < od) od = _nd, oc = nc; \\\n    } while(false)\n// want most recent negative one, not \"most inside\",\n// for overpainting, just for this test!\n\n// TODO tracer macro TR so I can accumulate color/object/etc. among various ray traces\n\n\n\n// q is pixel signed uv (world space)\n// la is start of ray\n// lb is along the ray\n// s is scale of main object (otherwise it'd fill screen vertically)\n// ry is iResolution.y for antialiasing the debugging lines\nvec3 render(vec2 q, vec2 la, vec2 lb, float s, float ry)\n{\n    vec2 ld = normalize(lb - la); // good chance ld will be nans if mouse isn't down.\n    float sd; // signed distance to shape from q\n    sd = dshape(q / s) * s;\n    float lt; // result of raytrace along the l ray from la toward lb along dir ld\n    lt = tshape(la / s, ld) * s;\n    vec2 lh = lt * ld + la;\n    bool missed = !(lt >= 0.)\n        || isnan(lt); // apparently nan comparisons aren't IEEE\n    vec3 c = vec3(0.);\n    float d = 3.4e38;\n    DR(d, c.rgb, sd, vec3(.8,.4,0)); // draw actual shape by its sdf\n    vec3 chit = missed ? vec3(.5,.0,.0) : vec3(0.,.5,.0);\n    DR(d, c.rgb, dline(q, la, lb) - .002, .6*chit);\n    DR(d, c.rgb, dball((q - la) * 100.)/100., .9*chit);\n    if (missed) {\n        lt = -1.; \n    } else {\n        DR(d, c.rgb, dball((q - lh) * 50.)/50., vec3(.7,.9,.9));\n    }\n    float cov = clamp(.5 - .125 * ry * d, 0., 1.); // antialias edge linearly\n    vec3 cbg = vec3(0.,0.,.2); // btw coverage is important for bg blending\n\tif (missed) cbg = vec3(.2,.0,.0); // various condition indicators\n    if (lt == 0.) cbg = vec3(.1,.2,.1); // inside?\n  #if 0\n    // bounding shape test - TODO maybe I should inflate it to contain the unit square?\n    bool thit = ishape(la / s, ld);  // most shapes don't even have an ishape implementation; bounding only!\n    if (!thit) cbg = max(cbg, .1); // desaturation indicates bsphere failure, hue indicates why\n  #endif\n    c.rgb = mix(cbg, c.rgb, cov); // blend over bg\n    return c;\n}\n\n\n\n#if 0\n\tvec3 tdbgx, tdbgy; // color debug swatches so I can see what fns are returning\n    if (distance(vec2(-1.65,-.9), q) < .05)\n\t\tc.rgb = tdbgx;\n     if (distance(vec2(-1.45,-.9), q) < .05)\n\t\tc.rgb = tdbgy;\n#endif\n\n\n\n#if 0\n// trying something for box support: thickness of trace through unit slab -1..1\nfloat hslab(float ro, float rd)\n{\n    float t1 = thalfspace(ro - 1., rd);\n    float t2 = thalfspace(ro + 1., rd);\n    t1 = max(t1, 0.); t2 = max(t2, 0.);\n    return abs(t2 - t1);\n}\n#endif\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}