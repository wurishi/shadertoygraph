{"ver":"0.1","info":{"id":"MXsBWN","date":"1728420713","viewed":12,"name":"Dancing Blobs","username":"Duin","description":"Pulsating blobs. Everywhere.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec4 unionSDF(vec4 a, vec4 b) {\n    return a.w < b.w? a : b;\n}\n\nvec4 opSmoothUnion( vec4 d1, vec4 d2, float k )\n{\n    vec4 h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat noise(vec3 x) {\n    return (sin(x.x)+sin(x.z))*0.5;\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 map(vec3 p) {\n    vec3 col = vec3(0.1, 0.6, 0.8);\n    vec3 pos = vec3(0.);\n    p.x = -2.5 + mod(p.x, 5.);\n    p.y = -2.5 + mod(p.y, 5.);\n    p.z = -2.5 + mod(p.z, 5.);\n    // if (p.z < 25.) {\n    //     p.z = -2.5 + mod(p.z, 10.);\n    // }\n\n    vec3 offset1 = vec3(0.7 * sin(iTime*2.), 0.7 * sin(iTime*3.), 0.7 * sin(iTime*4.+0.3));\n    vec3 offset2 = vec3(0.7 * sin(iTime*2.5+1.6), 0.7 * sin(iTime*3.2), 0.7 * sin(iTime*1.5+0.3));\n    \n    vec4 sphere1 = vec4(col, sdSphere(p - pos, 1.));\n    vec4 sphere2 = vec4(col, sdSphere(p - pos - offset1, 0.5));\n    vec4 sphere3 = vec4(col, sdSphere(p - pos - offset2, 0.5));\n\n\n    \n    vec4 d = opSmoothUnion(sphere1, sphere2, 0.5);//+0.1*cos(a*1.+b*1.);//+0.1*cos(b*6.);//+0.1*cos(c*6.);\n    d = opSmoothUnion(d, sphere3, 0.5);//+0.1*cos(a*1.+b*1.);//+0.1*cos(b*6.);//+0.1*cos(c*6.);\n    return d;\n}\n\nvec3 calculate_normal(in vec3 p)\n{\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = map(p + small_step.xyy).w - map(p - small_step.xyy).w;\n    float gradient_y = map(p + small_step.yxy).w - map(p - small_step.yxy).w;\n    float gradient_z = map(p + small_step.yyx).w - map(p - small_step.yyx).w;\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nconst float MAX_DIST = 10000.;\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    // Ray Marching\n    for (int i; i < 800; i++){\n        vec3 p = ro + rd * t;\n        float d = map(p).w; \n\n        t += d;\n        // col = vec3(i) / 80.;\n        if (abs(d) < 0.001 || t > MAX_DIST) {\n            break;\n        }\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) /iResolution.y;    \n    uv *= rotate2d(sin(iTime)*0.5);\n    uv *= 0.5 * sin(iTime)-1.0;\n    uv.x += sin(iTime*0.5);\n    uv.y += sin(iTime*1.);\n\n    // uv = -vec2(0.5) +fract(uv*3.);\n\n    // Initialisation\n    vec3 ro = vec3(0.0,0.0, -4.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n\n    vec3 col = vec3(0.0);\n    vec3 light_pos1 = vec3(-3.0, -3.0, -2.0);\n\n    float t = rayMarch(ro, rd);\n\n    vec3 p = ro + rd * t;\n    vec3 light1_dir = normalize(light_pos1-p);\n    vec3 normal = calculate_normal(p);\n    float intensity1 = max(0.0,dot(normal, light1_dir));\n\n    // // Shadows\n    // float light_d = rayMarch(p+normal*0.002, light1_dir);\n    // if (light_d < length(light_pos1-p)) {\n    //     intensity1 *= 0.2;\n    // }\n\n    vec3 light_colour = vec3(0.8, 0.8, 1.0);// * intensity1;\n\n    if (t < MAX_DIST) {\n        col = map(p).rgb * light_colour * intensity1 / t*10.;\n    } else {\n        col = vec3(.2) * vec3(0.8, 0.8, 1.0);\n    }\n\n    // col = vec3(1.0) - vec3(t*.10); // Display depth map\n    // Output to screen\n    fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"}]}