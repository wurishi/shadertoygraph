{"ver":"0.1","info":{"id":"wdXSDn","date":"1551025320","viewed":237,"name":"Local lighting model","username":"darkeclipz","description":"Testing out various components of a local lightning model. Used the following book as a reference: \n\n - 3D Math Primer for Graphics and Game Development, Fletcher Dunn, page 398-411\n\n| 5 | 6 | 7 | 8 |\n| 1 | 2 | 3 | 4 |","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["phong","raymarch","lighting","shading","blinn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define MaxSteps 80.\n#define MinDistance 0.0075\n#define eps 0.001\n#define AA 4.\n#define AA2 (AA*AA)\n#define torus 0\n#define floor 1\n\nmat2 r2(float angle) { return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)); }\nmat3 rotateY(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c, 0, -s, 0, 1, 0, s, 0, c);\n}\n\nmat3 rotateZ(float angle) {\n\tfloat c = cos(angle), s = sin(angle);\n    return mat3(c,-s,0,s,c,0,0,0,1);\n}\n\n// from IQ\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// from IQ\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// from IQ\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\n\n// from IQ\nfloat sdBox(vec3 p, vec3 b) { \n\tvec3 d = abs(p) - b;\n    return length(max(d,0.0));\n}\n\nvec2 scene(vec3 p) {\n    \n    float plane = sdPlane(p, vec4(0., 1., 0., .9));\n    //float box = sdBox(p - vec3(0,.207,0), vec3(.5));\n    float box = sdTorus(p*rotateZ(iTime/2.) - vec3(0,0,0), vec2(.5,0.2));\n    int id = 0;\n    if(plane < box) id = 1;\n    plane = min(plane, box);\n    return vec2(plane, id);\n}\n\nfloat shadowScene(vec3 p) {\n    return sdTorus(p*rotateZ(iTime/2.) - vec3(0,0,0), vec2(.5,0.2));\n}\n\n// from IQ\nvec3 calcNormal(vec3 p) {\n    float h = 0.0001;\n    vec2 k = vec2(1,-1);\n    vec3 n = normalize( k.xyy*scene( p + k.xyy*h ).x + \n                  \t\tk.yyx*scene( p + k.yyx*h ).x + \n                  \t\tk.yxy*scene( p + k.yxy*h ).x + \n                  \t\tk.xxx*scene( p + k.xxx*h ).x );    \n    return n;\n}\n    \nvec3 march(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        vec2 hit = scene(p);\n        float dt = hit.x;\n        float id = hit.y;\n        t += dt;\n        if(dt < MinDistance) {\n        \treturn vec3(t-MinDistance, id, 1.-i/MaxSteps);  \n        }\n    }\n    return vec3(0.);\n}\n\nvec2 shadowMarch(vec3 ro, vec3 rd) {\n    float t = 0., i = 0.;\n    float min_dt = 1e10;\n    for(i=0.; i < MaxSteps; i++) {\n    \tvec3 p = ro + t * rd;\n        float dt = shadowScene(p);\n        t += dt;\n        min_dt = min(min_dt, dt);\n        if(dt < MinDistance) {\n        \treturn vec2(t, 0);  \n        }\n    }\n    return vec2(0, min_dt);\n}\n\n\nfloat checker(vec2 p, float scale) {\n    p = trunc(fract(p)*scale);\n    if(mod(p.x + p.y, 2.) == 0.) return 1.;\n    return 0.;\n}\n\n/* \tStandard Local Lighting Model \n\n\tThe *emissive* contribution, denoted c_emis, is the same as\n\tthe rendering equation. It tells the amount of radiance emitted\n\tdirectly from the surface in the given direction.\n\n\tThe *specular* contribution, denoted c_spec, accounts for light\n\tincident directly from a light source that is scattered preferentially\n\tin the direction of a perfect 'mirror bounce'.\n\n\tThe *diffuse* contribution, denoted c_diff, accounts for light\n\tincident directly from a light source that is scattered in every\n\tdirection evenly.\n\n\tThe *ambient* contribution, denoted c_amb, is a fudge factor\n\tto account for all indirect light.\n\t\n\tReference:\n\t\t-\t3D Math Primer for Graphics and Game Development, \n\t\t\tsecond ed., Fletcher Dunn, Ian Parberry, pages 398-411\n\n*/\nconst vec3 light = vec3(0,3,0);\n\n// simple shading by showing the normal of the object.\nvec3 shade01(vec3 p, vec3 n, vec3 v, int id) {\n    if(id == torus) return n*.5+.5; // remap the normal from [-1, 1] to [0, 1].\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//  Specular component with Phong model for specular reflection.\n// \n//\tThe *specular component* of the standard model accounts for the\n//  light that is reflected (mostly) in a \"perfect mirror bounce\" off\n//\tthe surface. The specular component is what gives a surface\n// \ta \"shiny\" appearance.\n//\n// \tn: a local outward pointing surface normal\n//\tv: points towards the viewer (symbol 'e' for eye is sometimes used)\n//\tl: points towards the light source\n//  r: reflection vector for reflecting l about n\n//  theta: angle between r and v\n//\n//  Phong model for specular reflection:\n//\tc_spec = (s_spec * m_spec)(cos theta)^m_gls = (s_spec * m_spec)(v . r)^m_gls\n\nvec3 shade02(vec3 p, vec3 n, vec3 v, int id) {\n\n    vec3 l = normalize(p - light);\n    \n    vec3 m_spec = vec3(.7); // controls the intensity and color of the specular\n    \t\t\t\t\t\t// highlight. A highly reflective surface will have a \n    \t\t\t\t\t\t// higher m_spec, and more matte surface will be lower.\n    \t\t\t\t\t\t// (m: material, _spec: specular)\n    \n    vec3 s_spec = vec3(.9); // light specular color; essentially the color of the light\n    \t\t\t\t\t\t// which contains both its color and intensity. In practice,\n    \t\t\t\t\t\t// s_spec is almostalways equal to the light color used\n    \t\t\t\t\t\t// for diffuse lightning. \n    \t\t\t\t\t\t// (s: source, _spec: specular)\n    \n    vec3 r = reflect(n, l);\t// Reflection vector can be computed by 2 * ( n . l ) n - l.\n    \n    float m_gls = 8.;\t\t// Glossiness of the material (or Phong exponent/specular exponent/shininess)\n    \t\t\t\t\t\t// controls how wide the hotspot is, a smaller m_gls produces a larger,\n    \t\t\t\t\t\t// more gradual falloff from the hotspot. This is a hotspot of reflection,\n    \t\t\t\t\t\t// not to be confused with the hotspot of a spot light.\n    \n    vec3 spec = s_spec * m_spec * pow(clamp(dot(-v, r), .0, 1.), m_gls); // (s_spec * m_spec) (v . r) ^ m_gls\n    \n    if(id == torus) return spec;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//  Specular component with Blinn model for specular reflection.\n// \n//  The formula for the Blinn model is quite similar to the\n// \toriginal Phong model. Only the dot product portion changed.\n//\n//\tThe half-angle h is calculated:   h = (v + l) / (|| v + l ||)\n//\n// \tBlinn model for specular reflection:\n//\tc_spec = (s_spec * m_spec) (cos theta)^m_gls = (s_spec * m_spec) (n . h) ^ m_gls\n\nvec3 shade03(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light);\n    vec3 m_spec = vec3(.7);\n    vec3 s_spec = vec3(.9);\n    vec3 h = normalize(v + l); // (v + l) / (|| v + l ||)\n    float m_gls = 8.;\n    \n    // (s_spec * m_spec) (v . r) ^ m_gls\n    vec3 spec = s_spec * m_spec * pow(max(clamp(-dot(n, h), 0., 1.), .0), m_gls); \n    \n    if(id == torus) return spec;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//\tDiffuse component with Lambert's Law\n//\t\n// \tDiffuse light models light that is reflected randomly in all \n//\tdirection due to the rough nature of the surface material. Surfaces\n// \tmore perpendicular to the light ray receive more light per unit area\n// \tthan a surface oriented at a more glancing angle.\n//\n//\tDiffuse light obeys Lambert's Law: the intensity of the reflected light\n//\tis proportional to the cosine of the angle between the surface normal\n//\tand the ray of light.\n//\n//\tDiffuse Component accordings to Lambert's Law:\n//\tc_diff = (s_diff * m_diff) (n . l)\n\nvec3 shade04(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light); // unit vector that points towards the light source.\n    \n    vec3 m_diff = vec3(.6);\t// Material's diffuse color, which is the value that\n    \t\t\t\t\t\t// most people think of when they think of the color of an object.\n    \t\t\t\t\t\t// The diffuse material color often comes from a texture map.\n    \n    vec3 s_diff = vec3(.9);\t// Diffuse color of the light source, s_diff, usually equal\n    \t\t\t\t\t\t// to the light's specular color, s_spec.\n    \n    vec3 c_diff = s_diff * m_diff * clamp(-dot(n, l), 0., 1.); // (s_diff * m_diff) (n . l)\n    \n    if(id == torus) return c_diff;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n//\tAmbient and emissive components\n//\n//\tTo model light that is reflected more than one time before it enters\n//\tthe eye, we use a very crude approximation known as 'ambient light'. The\n//\tambient portion of the lighting equation depends only on the properties of\n//\tthe material and an ambient lighting value, which is often a global value\n//\tused for the entire screen.\n//\n//\tAmbient contribution to lighting equation:  c_amb = g_amb * m_amb\n\nvec3 shade05(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light); // unit vector that points towards the light source.\n    \n    vec3 m_amb = vec3(.9);\t// Materials ambient color. This is almost always the\n    \t\t\t\t\t\t// same as the diffuse color.\n    \n    vec3 g_amb = vec3(.15);\t// Global ambient light factor, g_amb. Usually a global variable\n    \t\t\t\t\t\t// for the entire screen.\n    \n    vec3 c_amb = g_amb * m_amb;\n    \n    if(id == torus) return c_amb;\n    if(id == floor) return vec3(1) * checker(p.xz, 4.);\n}\n\n// Lighting Equation\n//\n// Standard lighting model for one light source:\n//\n//   \t       c_spec\t     (s_spec * m_spec) max(n . h, 0)^m_gls\n//\tc_lit =  + c_dif     = + (s_diff * m_diff) max(n . l, 0)\n//\t\t\t + c_amb\t   + g_amb * m_amb\n//\t\t\t + c_emis\t   + m_emis\n//\n// Standard lighting equation for multiple lights:\n//\n// c_lit = sum_{j=1}^n[(s_j * m_spec) max(n . h, 0) + (s_j * m_diff) max(n . l, 0)]\n//\t\t   + g_amb * m_amb + m_emis\n//\n// where s_j : color of the light source, including attenuation factor, and j=1 to n number of lights.\n\nvec3 shade06(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 l = normalize(p - light);\n    vec3 h = normalize(v + l);\n    \n    vec3 m_spec = vec3(.7);\n    vec3 s_spec = vec3(.9);\n    float m_gsl = 8.;\n    \n    vec3 c_spec = (m_spec * s_spec) * pow(max(-dot(n, h), 0.), m_gsl);\n    \n    vec3 m_diff = vec3(.6);\n    if(id == floor) m_diff = vec3(1) * checker(p.xz, 4.);\n    \n    vec3 s_diff = vec3(.9);\n    \n    vec3 c_diff = (s_diff * m_diff) * max(-dot(n, l), 0.);\n    \n    vec3 m_amb = vec3(.4);\n    vec3 g_amb = vec3(.15);\n    \n    vec3 c_amb = m_amb * g_amb;\n    \n    return c_spec + c_diff + c_amb;\n    \n    // Most surfaces don't emit light, so c_emis = 0. We are\n    // rendering self-illuminated surfaces but they don't interact\n    // with the objects around it. When using the lighting equation\n    // properly (global illumination?), the lighting equation does\n    // light up their surroundings.\n}\n\n// Light attenuation\n\nfloat attenuate(float d, float d_min, float d_max) {\n\tif(d <= d_min) return 1.;\n    if(d > d_min && d < d_max) return (d_max - d) / (d_max - d_min);\n    else return 0.;\n}\n\nfloat simpleLinearAttenuation(float d) { return attenuate(d, 10., 60.); }\nfloat realWorldAttenuation(float d) { return 100. / (d*d); } // shoots to infinity\n\nvec3 shade07(vec3 p, vec3 n, vec3 v, int id) {\n    \n    float d = length(p - light);\n    return shade06(p,n,v,id) * attenuate(d, 4., 6.);\n}\n\n// Hard shadow\n\nvec3 shade08(vec3 p, vec3 n, vec3 v, int id) {\n    \n    vec3 c_lit = shade07(p,n,v,id);\n    vec3 rd = normalize(light - p);\n    vec2 t = shadowMarch(p + 2.*MinDistance*n, rd);\n    if(t.x > eps) return 0.25 * c_lit;\n    return c_lit;\n    \n}\n\nvec2 shadeId = vec2(0);\nvec3 shadingSelector(vec3 p, vec3 n, vec3 v, int id) {\n    if(shadeId == vec2(0,0)) return shade01(p,n,v,id);\n    if(shadeId == vec2(1,0)) return shade02(p,n,v,id);\n    if(shadeId == vec2(2,0)) return shade03(p,n,v,id);\n    if(shadeId == vec2(3,0)) return shade04(p,n,v,id);\n    if(shadeId == vec2(0,1)) return shade05(p,n,v,id);\n    if(shadeId == vec2(1,1)) return shade06(p,n,v,id);\n    if(shadeId == vec2(2,1)) return shade07(p,n,v,id);\n    if(shadeId == vec2(3,1)) return shade08(p,n,v,id);\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec3 samples = vec3(0);\n    for(float aax=0.; aax < AA; aax++)\n    for(float aay=0.; aay < AA; aay++)\n    {\n    \tvec2 uv = (U + vec2(aax, aay) / AA)/R.y;\n        uv *= 2.25;\n        \n        shadeId = trunc(uv);\n        uv = fract(uv) - 0.5;\n        uv *= 2.;\n        \n        vec3 col = vec3(.0);\n        vec3 ro = vec3(0,1.7,-5.);\n        mat3 rot = rotateY(iTime/2.);\n        vec3 rd = normalize(vec3(uv.x, uv.y, 0) - ro);\n\n        ro *= rot;\n        rd *= rot;\n\n        vec3 hit = march(ro, rd);\n        float t = hit.x;\n        float id = hit.y;\n\n        if(t > 0.) {\n            vec3 p = ro + t * rd;\n            vec3 n = calcNormal(p);\n            col = shadingSelector(p, n, rd, int(id));\n            col = clamp(col, .0, 1.);\n        }\n    \n        samples += col;\n    }\n\n    O = vec4(samples/AA2,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}