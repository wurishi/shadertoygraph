{"ver":"0.1","info":{"id":"MXSXWK","date":"1711069597","viewed":255,"name":"Lode Style Voxel DDA Ray Caster","username":"chronos","description":" Following the naming conventions in \"Lode's Computer Graphics Tutorial\"\n https://lodev.org/cgtutor/raycasting.html\nClick and drag to reposition ray.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["ray","raycast","tutorial","visualization","voxel","dda","cast","diagram","lode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Lode Style Voxel DDA Ray Caster by chronos\n    \n\n     Following the naming conventions in \"Lode's Computer Graphics Tutorial\"\n     https://lodev.org/cgtutor/raycasting.html\n     \n     thanks to @jt for reminding me of that site! :)\n     \n     \n     Click and drag to reposition ray\n     \n     \n     Variables from Lode's tutorial:\n\n     posX, posY\n         starting position / camera position\n\n     mapX, mapY\n      the integer cell-coordinate of the position\n\n     stepX, stepY\n      the sign of the traversal direction, +/- 1\n\n     sideDistX, sideDistY          \n      \"Initially the ray distance (dt) the ray has to travel from start position to the first side\n      then incremented while steps are taken\"\n\n     deltaDistX, deltaDistY\n      the distance the ray has to travel to go from 1 x-side to the next x-side, (same for y-side)\n\n      for the usual notation ro + rd * t, \n      this would be dt_x such that (ro + rd * (t+dt_x)).x = (ro + rd * t).x +/- 1.\n      depending on view direction.\n\n      reordered we have\n          ro.x + rd.x * (t+dt_x) - ro.x - rd.x * t=  +/- 1.\n      simplifies to\n          abs(rd.x * dt_x) = 1.\n      meaning\n          rd.x * dt_x = sign(rd.x * dt_x) * 1.\n      then\n          dt_x = sign(rd.x * dt_x) / rd.x\n      giving\n          dt_x = sign(rd.x) * sign(dt_x) / rd.x\n          dt_x = sign(rd.x) * 1. / rd.x\n          dt_x = sign(rd.x) / rd.x\n          dt_x = 1. / abs(rd.x)\n  \n      \n      // Self link: https://www.shadertoy.com/view/MXSXWK\n\n*/\n\nfloat seg(vec2 a, vec2 b, vec2 p) // distance from p to line segment from a to b\n{\n    p-=a; b-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0., 1.) * b - p);\n}\n\nfloat map(vec2 p) // voxel map\n{\n    float result =\n    \n        min(\n        step( 4. ,length(floor(p) +0.5))\n        ,\n        step( 2. ,length(floor(p)-vec2(6., 2.) +0.5))\n        );\n        \n    result = min(result,\n        step( 3. ,length(floor(p)+vec2(6., 2.) +0.5))\n    );\n    result = min(result,\n        step( 2. ,length(floor(p)-vec2(6., -2.) +0.5))\n    );\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 5.;\n    vec2 uv = zoom * (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse_release = zoom * (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse_press = zoom * (2.*abs(iMouse.zw)-iResolution.xy)/iResolution.y;\n\n    vec2 mouse = mouse_release;\n    \n    if(length(iMouse.xy) < 10.)\n    {\n        mouse_release = vec2(cos(iTime*.5), sin(iTime*.5));\n        mouse_press = vec2(0);\n    }\n\n    float ps = zoom * 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n\n    vec2 grid_id = floor(uv);\n    vec2 grid_uv = fract(uv);\n\n    // Draw the map and some initial markers\n    \n    vec2 axis_borders = smoothstep(2.*ps, ps*.5, grid_uv) + smoothstep(2.*ps, ps*.5, 1.-grid_uv);\n\n    float cell_border = max(axis_borders.x, axis_borders.y);\n\n    // Draw floor and wall tiles\n    color += pow(texture(iChannel0, grid_uv.rg).rgb, vec3(2.2)) * (1.-map(uv)) * 0.2;\n    color += pow(texture(iChannel1, grid_uv.rg).rgb, vec3(2.2)) * map(uv) * 0.2;\n    \n    color = mix(color, vec3(1), 0.1*cell_border);\n\n    // Draw ray between mouse positions\n    float segdist = seg(mouse_press, mouse_release, uv);\n    float alpha = 0.3*smoothstep(2. * ps, 0.5*ps, segdist);\n    color = mix(color, vec3(0.5), alpha);\n    \n    // Draw unit length ray\n    segdist = seg(mouse_press, normalize(mouse_release - mouse_press) + mouse_press, uv);\n    alpha = smoothstep(2. * ps, 0.5*ps, segdist);\n    color = mix(color, vec3(0.5), alpha);\n\n    color = mix(color, vec3(0), 0.25 * smoothstep(1.5*ps, 0., length(mouse.xy-uv) - 0.02*zoom));\n    color = mix(color, vec3(1), 0.25*smoothstep(1.5*ps, 0., length(mouse.xy-uv) - 0.015*zoom));\n    \n    color = mix(color, vec3(0), smoothstep(1.5*ps, 0., length(mouse_press.xy-uv) - 0.02*zoom));\n    color = mix(color, vec3(1), smoothstep(1.5*ps, 0., length(mouse_press.xy-uv) - 0.015*zoom));\n\n\n    // DDA setup\n    vec2 posXY = mouse_press;                             // Start / camera position\n    vec2 rayDirXY = normalize(mouse_release-mouse_press); // Direction to cast ray\n\n    vec2 mapXY = floor(posXY);           // integer cell coordinate of initial / current cell\n\n    vec2 stepXY;                         // step sign +/- 1\n    vec2 sideDistXY;                     // initial distance to cell sides, then relative difference between traveled sides\n    vec2 deltaDistXY = 1./abs(rayDirXY); // ray length required to step from one cell border to the next in x and y directions\n    float side=0.;                       // vertical (0) or horiontal (1) wall?\n\n    if(rayDirXY.x < 0.)\n    {\n        stepXY.x = -1.; // left\n        sideDistXY.x = (posXY.x - mapXY.x) * deltaDistXY.x;\n    }\n    else\n    {\n        stepXY.x = 1.; // right\n        sideDistXY.x = (mapXY.x+1. - posXY.x) * deltaDistXY.x;\n    }\n    \n    if(rayDirXY.y < 0.)\n    {\n        stepXY.y = -1.; // down\n        sideDistXY.y = (posXY.y - mapXY.y) * deltaDistXY.y;\n    }\n    else\n    {\n        stepXY.y = 1.; // up\n        sideDistXY.y = (mapXY.y+1. - posXY.y) * deltaDistXY.y;\n    }\n\n    \n    // DDA marching \n    \n    for(int i = 0; i < 20; i++)\n    {\n    \n        color = mix(color, vec3(0), 0.75*smoothstep(1.5*ps, 0., length(mapXY-uv) -0.035));\n        color = mix(color, vec3(.0,0.8,0.3), 0.35*smoothstep(1.5*ps, 0., length(mapXY+.5-uv) -0.05));\n        // Highlight hit cell\n        color += float(grid_id == mapXY) * 0.02 * vec3(.0,0.8,0.3);\n    \n        // Decide which way to go!\n        if(sideDistXY.x < sideDistXY.y)\n        {\n            sideDistXY.x += deltaDistXY.x; // Add time until next hit in x direction (vertical wall hit)\n            mapXY.x += stepXY.x; // step right/left\n            side = 0.; // vertical wall\n        }\n        else\n        {\n            sideDistXY.y += deltaDistXY.y; // // Add time until next hit in y direction (horizontal wall hit)\n            mapXY.y += stepXY.y; // step up/down\n            side = 1.; // horizontal wall\n        }\n        \n        if(map(mapXY) > 0.) // Did we hit anything? if so, we are done!\n            break;\n    }\n    \n    // Draw corner ray \n    segdist = seg(mouse_press, (sideDistXY - deltaDistXY)*normalize(mouse_release - mouse_press) + mouse_press, uv);\n    alpha = 0.05*smoothstep(2. * ps, 0.5*ps, segdist);\n    color = mix(color, vec3(0.5), alpha);\n    \n    // Draw hit cell dots\n    color = mix(color, vec3(0,1,0), 0.5*smoothstep(1.5*ps, 0., length(mapXY-uv) -0.01*zoom));\n    color = mix(color, vec3(0), smoothstep(1.5*ps, 0., length(mapXY+.5-uv) -0.015 * zoom));\n    color = mix(color, vec3(1), smoothstep(1.5*ps, 0., length(mapXY+.5-uv) -0.01 * zoom));\n    \n    // Draw hit wall\n    // I just guessed these expressions myself, sorry for them being a bit ugly :P\n    vec2 corner0 = mapXY + (1.-(stepXY+1.)/2.)*vec2(1.-side, side);\n    vec2 corner1 = mapXY + (1.-(stepXY+1.)/2.)*vec2(1.-side, side) + vec2(side, 1.-side);\n    segdist = seg(corner0, corner1, uv);\n    alpha = smoothstep(3. * ps, 1.5*ps, segdist);\n    color = mix(color, vec3(0,0,0.5), alpha);\n    \n    // Highlight hit cell\n    color += float(grid_id == mapXY) * 0.04;\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}