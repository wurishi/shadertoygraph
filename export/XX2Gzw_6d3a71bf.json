{"ver":"0.1","info":{"id":"XX2Gzw","date":"1708491054","viewed":164,"name":"[zznewclear13] Python in Cave","username":"zznewclear13","description":"Inspired by [url=https://x.com/model_mechanic/status/1759068809867166129]\"pov footage of an ant navigating the inside of an ant nest\"[/url]\n\nI tried my best, but my best was not good enough to model an ant.","likes":17,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Ant in Cave\n// https://www.shadertoy.com/view/XX2Gzw\n\n// Inspired by \"pov footage of an ant navigating the inside of an ant nest\"\n// https://x.com/model_mechanic/status/1759068809867166129\n\n// I tried my best, but my best was not good enough to model an ant.\n// WARNING: Highly unoptimized code, confusing namings, magic numbers, and bad comments.\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 Tonemap_ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    color = Tonemap_ACES(color);\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer calculates the python's position.\n\nvoid saveToTexel(ivec2 iFragCoord, int x, int y, vec4 valueToSave, inout vec4 prevVal)\n{\n    if(iFragCoord.x == x && iFragCoord.y == y)\n    {\n        prevVal = valueToSave;\n    }\n}\n\nvec2 raycast(vec3 ro, vec3 rd)\n{\n    vec2 res = vec2(-1.0f);\n\n    float tmax = 100.0f;\n    float t = 0.1f;\n    for (int i=ZERO; i<32; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        vec2 h = cave(pos);\n        res = vec2(t, h.x);\n\n        if (h.x<0.001f) break;\n        t += h.x;\n        if (t>tmax) return vec2(-1.0f);\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevVal = vec4(0.0f);\n    float time = iTime;  \n    if (iMouse.z > 0.0f)\n    {\n        time = iMouse.y * 0.2f;\n    }\n    \n    ivec2 iFragCoord = ivec2(fragCoord);  \n    float timeOffset = float(iFragCoord.x);\n    vec3 ro = getTunnelCenter(time + timeOffset - 1.0f);\n    ro.x += 0.25f * sin((time - timeOffset - 1.0f) * 4.0f);\n    vec3 rd = vec3(0.0f, -1.0f, 0.0f);\n    vec2 t = raycast(ro, rd);\n    \n    if (t.x > 0.0f)\n    {\n        vec3 hitPoint = ro + rd * t.x;\n        saveToTexel(iFragCoord, iFragCoord.x, 0, vec4(1.0f, hitPoint), prevVal);\n    }\n\n    fragColor = prevVal;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// This buffer draws the scene.\n\n// Comment this if your frame rate is too low...\n// #define DOF_HIGH_QUALITY\n#define DOF_LOW_QUALITY\n\n// https://www.shadertoy.com/view/ws3Bzf\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdy[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = vec2(n[ma.x],n[me.x]);\n    // optional - add local support (prevents discontinuty)\n    m = clamp( (m-0.5773)/(1.0-0.5773), 0.0, 1.0 );\n    // transition control\n    m = pow( m, vec2(k/8.0) );\n    \n    x = pow(x, vec4(2.2f));\n    y = pow(y, vec4(2.2f));\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\n// From https://www.mvps.org/directx/articles/catmull/\nvec4 catmull_rom(vec4 p0, vec4 p1, vec4 p2, vec4 p3, float t)\n{\n    vec4 tVec = vec4(1.0f, t, t*t, t*t*t);\n    vec4 px = vec4(p0.x, p1.x, p2.x, p3.x);\n    vec4 py = vec4(p0.y, p1.y, p2.y, p3.y);\n    vec4 pz = vec4(p0.z, p1.z, p2.z, p3.z);\n    vec4 pw = vec4(p0.w, p1.w, p2.w, p3.w);\n    mat4 characterMat = mat4(0.0f, -1.0f, 2.0f, -1.0f,\n                            2.0f, 0.0f, -5.0f, 3.0f,\n                            0.0f, 1.0f, 4.0f, -3.0f,\n                            0.0f, 0.0f, -1.0f, 1.0f);\n    float xPos = 0.5f * dot(tVec, characterMat * px);\n    float yPos = 0.5f * dot(tVec, characterMat * py); \n    float zPos = 0.5f * dot(tVec, characterMat * pz);\n    float wPos = 0.5f * dot(tVec, characterMat * pw); \n    return vec4(xPos, yPos, zPos, wPos);    \n}\n\n#define PYTHON_LENGTH 6\nstruct PyData\n{\n    float time;\n    // vec4(position, size)\n    vec4 p[PYTHON_LENGTH];\n};\n\nvoid fillPyData(float time, out PyData pyData)\n{\n    pyData.time = time;\n    for (int i=0; i<PYTHON_LENGTH; ++i)\n    {\n        pyData.p[i] = vec4(texelFetch(iChannel2, ivec2(i, 0), 0).yzw, 0.35f);\n    }\n}\n\nvec4 getPyCenter(vec3 p, PyData pyData)\n{\n    float val = p.z - pyData.time + 1.0f;\n    int floorVal = int(floor(val));\n    float fracVal = fract(val);\n    if (floorVal >= PYTHON_LENGTH-2) return pyData.p[PYTHON_LENGTH-2];\n    if (floorVal < 1) return pyData.p[1];\n    \n    return catmull_rom(pyData.p[floorVal-1], pyData.p[floorVal], pyData.p[floorVal+1], pyData.p[floorVal+2], fracVal); \n}\n\nvec2 python(vec3 p, PyData pyData)\n{\n    vec4 pyCenter = getPyCenter(p, pyData);\n    pyCenter.y += 0.25f;\n    vec3 l = p - pyCenter.xyz;\n    l.y *= 1.3f;\n    float len = max(length(l), 1e-5);\n    float d = len - pyCenter.w;\n    return vec2(d, 1.0f);\n}\n\nvec3 caveNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( cave(pos+eps.xyy).x - cave(pos-eps.xyy).x,\n\t                 cave(pos+eps.yxy).x - cave(pos-eps.yxy).x,\n\t                 cave(pos+eps.yyx).x - cave(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec3 pythonNormal( in vec3 pos, in PyData pyData )\n{\n\tvec2 eps = vec2( 0.0001, 0.0 );\n\tvec3 nor = vec3( python(pos+eps.xyy, pyData).x - python(pos-eps.xyy, pyData).x,\n\t                 python(pos+eps.yxy, pyData).x - python(pos-eps.yxy, pyData).x,\n\t                 python(pos+eps.yyx, pyData).x - python(pos-eps.yyx, pyData).x );\n\treturn normalize(nor);\n}\n\nvec2 raycast(vec3 ro, vec3 rd, PyData pyData)\n{\n    vec2 res = vec2(-1.0f);\n\n    float tmax = 40.0f;\n    float t = 0.1f;\n#if defined(DOF_HIGH_QUALITY)\n    for (int i=ZERO; i<64; ++i)\n#else\n    for (int i=ZERO; i<128; ++i)\n#endif\n    {\n        vec3 pos = ro + t * rd;\n        vec2 h1 = cave(pos);\n        vec2 h2 = python(pos, pyData);\n        res = vec2(t, h1.x < h2.x ? h1.y : h2.y);\n        \n        float h = min(h1.x, h2.x);\n        if (h<0.001f) break;\n        t += h;\n        if (t>tmax) return vec2(-1.0f);\n    }\n    \n    return res;\n}\n\nfloat shadowRaycast(vec3 ro, vec3 rd, float tmax, PyData pyData)\n{\n    float t = 0.1f;\n    for (int i=ZERO; i<64; ++i)\n    {\n        vec3 pos = ro + t * rd;\n        vec2 h1 = cave(pos);\n        vec2 h2 = python(pos, pyData);\n        float h = min(h1.x, h2.x);\n        \n        if (h<0.001f) return 0.0f;\n        t += h;\n        if (t>tmax) return 1.0f;\n    }\n    return 1.0f;\n}\n\nfloat getWeight(float a, float b, float x)\n{\n    return clamp((x - a) / (b - a), 0.0f, 1.0f);\n}\n\nvec3 getLightColor(float s)\n{\n    vec3 col1 = vec3(1.5f, 1.8f, 1.7f);\n    vec3 col2 = vec3(0.3f, 0.6f, 0.8f);\n    vec3 col3 = vec3(0.2f, 0.2f, 0.15f);\n    float w1 = smoothstep(0.8f, 1.0f, s);\n    float w2 = smoothstep(0.8f, 0.85f, s);\n    return mix(col3, mix(col2, col1, w1), w2);\n}\n\nvoid getPythonSkin(vec3 p, inout vec3 n, PyData pyData, out vec3 diffuseColor, out vec3 specularColor, out float smoothness)\n{\n    vec3 u = vec3(0.0f, 0.0f, -1.0f);\n    vec3 v = normalize(cross(n, u));\n    u = normalize(cross(v, n));\n    \n    vec4 pyCenter = getPyCenter(p, pyData);\n    vec3 toP = p - vec3(pyCenter.xy, pyData.time);\n    float angle = atan(toP.y, toP.x);\n    vec2 skinUV = vec2(angle * pyCenter.w, toP.z);\n    // Shiny Diamond Shader by WillGordon\n    // https://www.shadertoy.com/view/XlVcRc\n    vec2 sdSkin = mod(vec2(skinUV.x - skinUV.y, -skinUV.x - skinUV.y) * 20.0f, vec2(1.5f));\n    float pattern = clamp(sdSkin.x * sdSkin.y * 0.8f, 0.0f, 1.0f);\n    \n    n = normalize(n + pattern * 0.8f * u);\n    \n    diffuseColor = vec3(0.5f, 0.8f, 0.7f) * pattern * pow(texture(iChannel1, skinUV).rgb, vec3(2.2f));\n    specularColor = vec3(1.0f, 2.0f, 1.0f);\n    smoothness = 0.5f;\n}\n\nvoid getCaveSkin(vec3 p, vec3 n, out vec3 diffuseColor, out vec3 specularColor, out float smoothness)\n{\n    diffuseColor = biplanar(iChannel0, p * 0.2f, n, 8.0f).rgb;\n    specularColor = diffuseColor;\n    smoothness = smoothstep(0.05f, 0.5f, diffuseColor.r) * 0.8f + 0.2f;\n}\n\nvec3 lighting(vec3 diffuseColor, vec3 specularColor, float smoothness, vec3 n, vec3 l, vec3 v, float w)\n{  \n    float NoL = max(dot(n, l), 1e-5);\n    vec3 diffuse = diffuseColor;\n    vec3 h = normalize(l + v);\n    float NoH = max(dot(n, h), 1e-5);\n    vec3 specular = smoothness * specularColor * pow(NoH, 50.0f * smoothness);\n\n    return (diffuse + specular) * NoL;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0f * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float time = iTime;  \n    if (iMouse.z > 0.0f)\n    {\n        time = iMouse.y * 0.2f;\n    }\n    \n    PyData pyData;\n    fillPyData(time, pyData);\n    vec3 lightPos = vec3(tunnel(time - 0.2f), time - 0.2f) + vec3(-0.0f, 0.2f, 0.0f);\n    vec3 ta = vec3(tunnel(time + 2.5f), time + 2.5f);\n    \n#if defined(DOF_HIGH_QUALITY)\n    vec3 dofCol = vec3(0.0f);\n    for (int i=0;i<4;++i)\n    {\n    vec2 rv = hash33(vec3(fragCoord, time+float(i))).xy + vec2(i/2, i%2) - 1.0f;\n    vec3 ro = vec3(tunnel(time) + 0.05f * rv, time);\n#elif defined(DOF_LOW_QUALITY)\n    vec2 rv = hash33(vec3(fragCoord, time)).xy * 1.0f - 0.5f;\n    vec3 ro = vec3(tunnel(time) + 0.05f * rv, time);\n#else\n    vec3 ro = vec3(tunnel(time), time);\n#endif\n    \n    vec3 cw = normalize( ta-ro );\n\tvec3 cu = normalize( cross(cw,vec3(0.0,1.0,0.0)) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 1.7*cw );\n    ro += vec3(0.0f, -0.5f, 0.0f) + vec3(0.3f * sin(time), 0.15f * cos(0.4f * time), 0.05f * sin(0.2f * time + 0.5f));\n\n    vec3 col = vec3(0.0f);\n    \n    vec2 t = raycast(ro, rd, pyData);\n    \n    if (t.x > 0.0f)\n    {\n        bool isPython = t.y == 1.0f;\n        \n        vec3 pos = ro + t.x * rd;\n        vec3 nor;\n        vec3 diffuseCol;\n        vec3 specularCol;\n        float smoothness;\n        if (isPython)\n        {\n            nor = pythonNormal(pos, pyData);\n            getPythonSkin(pos, nor, pyData, diffuseCol, specularCol, smoothness);\n        }\n        else\n        {\n            nor = caveNormal(pos);\n            getCaveSkin(pos, nor, diffuseCol, specularCol, smoothness);\n        }\n        \n        vec3 lightRay = lightPos - pos;\n        float lightRayLength = max(length(lightRay), 1e-5);\n        lightRay /= lightRayLength;\n        vec3 viewDir = -rd;\n        \n        float shadow = shadowRaycast(pos, lightRay, lightRayLength, pyData);\n        vec3 lightColor = getLightColor(dot(lightRay, normalize(lightPos - ta)) * shadow);\n        float distShadow = getWeight(25.0f, 5.0f, lightRayLength);\n\n        col = lighting(diffuseCol, specularCol, smoothness, nor, lightRay, viewDir, t.y) * lightColor * distShadow;\n    }\n    else\n    {\n        col = vec3(0.7f, 0.0f, 0.6f);\n    }\n#if defined(DOF_HIGH_QUALITY)\n    dofCol += col;\n    }\n    fragColor = vec4(dofCol/4.0f, 1.0f);\n#else\n    fragColor = vec4(col, 1.0f);\n#endif\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define ZERO min(0, iFrame)\n#define PI 3.1415926f\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// https://iquilezles.org/articles/smin/\nvec2 smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n// https://iquilezles.org/articles/morenoise/\nfloat noisedValue( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash11(n+  0.0);\n    float b = hash11(n+  1.0);\n    float c = hash11(n+157.0);\n    float d = hash11(n+158.0);\n    float e = hash11(n+113.0);\n\tfloat f = hash11(n+114.0);\n    float g = hash11(n+270.0);\n    float h = hash11(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z;\n}\n\nfloat fbmValue( in vec3 x )\n{\n    float a = 0.0;\n    float b = 1.0;\n\tfloat f = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float n = noisedValue(f*x);\n        a += b*n;             // accumulate values\t\t\n        b *= 0.4;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n\treturn a;\n}\n\n// Scene related\nvec2 tunnel(float t)\n{\n    return vec2(5.0f * sin(0.13f * t), 2.0f * sin(0.12f * t)); \n}\n\nvec3 getTunnelCenter(float t)\n{\n    return vec3(tunnel(t), t);\n}\n\nvec2 cave(vec3 p)\n{\n    // Suggested by dean_the_coder\n    float dn = fbmValue(p) * 0.6f;\n    vec2 tunnerlCenter = tunnel(p.z);\n    float dt = 2.0f - length(p.xy - tunnerlCenter);\n    vec2 d = smin(dn, dn + dt, 1.5f);\n    float dp = p.y - tunnerlCenter.y + 1.5f;\n    d = smin(d.x, dp, 1.0f);\n    \n    return vec2(d.x, 0.0f);\n}\n\n","name":"Common","description":"","type":"common"}]}