{"ver":"0.1","info":{"id":"tttBzf","date":"1613193244","viewed":200,"name":"Infinite Square Well","username":"KJK","description":"I created this for my Physics 223 final project. It's a Gaussian wave packet bouncing around in a 2D infinite square well. The wave function is complex valued. The wave's phase is shown as hue and its amplitude is shown as brightness.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["infinitesquarewell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 getCoefficient(int nx, int ny) {\n    vec2 texCoord = (vec2(nx, ny) + .5) / 100.;\n    \n    // The initial resolution is stored at (0,0) in Buffer A so that we can calculate the modified uv coords when we change viewport sizes.\n    // This is a pretty ugly hack. I really wish shadertoy would support fixed sized buffers.\n    vec2 initialResolution = texture(iChannel0, vec2(0, 0)).xy;\n    \n    texCoord *= initialResolution / iResolution.xy;\n    return texture(iChannel0, texCoord).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - vec2(iResolution.x * .25, 0))/iResolution.y;\n    float x = uv.x;\n    float y = uv.y;\n\n    if (x < 0. || x > 1.) {\n        fragColor = vec4(vec3(.1), 1.);\n        return;\n    }\n    \n    // Select only the most important range of frequencies.\n    // If you change the initial state function, you will have to\n    // update these values. The full range is 1-100, but this is very slow.\n    // TODO: Allow different ranges for nx and ny.\n    // TODO: Auto select the ranges of relevant frequencies when the coefficients are generated in BufferA.\n    int minN = 20;\n    int maxN = 50;\n    \n    vec2 v = vec2(0, 0);\n    // I made this loop ugly to prevent the compiler from recognizing and unrolling it since that was causing it to hang.\n    int nx = minN;\n    while (true) {\n        for (int ny = minN; ny <= maxN; ny++) {\n            vec2 c = getCoefficient(nx, ny);\n            vec2 s = solution(float(nx), float(ny), uv, iTime);\n            v += cmul(s, c);\n        }\n        nx++;\n        if (nx > maxN) break;\n    }\n    \n    float angle = atan(v.y, v.x);\n    float h = angle / (pi * 2.);\n    float s = 0.5;\n    float l = dot(v, v) * .00025;\n    vec3 col = hsl2rgb(vec3(h,s,l));\n    fragColor = vec4(col, 1.0);\n    \n    // v = initialCondition(uv);\n    //float col = dot(v, v) * .0005;\n    //fragColor = vec4(col, col, col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 hsl2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\n// Physics source:\n// https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Supplemental_Modules_(Physical_and_Theoretical_Chemistry)/Quantum_Mechanics/05.5%3A_Particle_in_Boxes/Particle_in_a_2-Dimensional_Box\n\nconst float groundEnergyOverHBar = .02; // = ( hBar^2 * pi^2 / (m * L^2) ) / hBar\nconst float L = 1.0;\nconst float pi = 3.14159;\nconst float normalizationConst = 2. / L;\n\n// Complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 harmonic( float nx, float ny, vec2 p ) {\n    return vec2(sin( nx * pi * p.x / L ) * sin( ny * pi * p.y / L ), 0) * normalizationConst;\n}\n\nvec2 compExp(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nfloat energyOverHBar( float nx, float ny ) {\n    return groundEnergyOverHBar / 2. * (nx * nx + ny * ny);\n}\n\nvec2 solution(float nx, float ny, vec2 p, float t) {\n    float s = energyOverHBar(nx, ny);\n    return cmul(harmonic(nx, ny, p), compExp(s * t));\n}\n\nvec2 initialState(vec2 p) {\n    // Maybe I should normalize this? It doesn't really matter because I need\n    // to scale solutions to adjust the brightness either way, but it would be \n    // more mathematically accurate to return a normalized function.\n    float r = length(p - vec2(.25, .8));\n    float s = dot(p, vec2(1., 1.));\n    vec2 phase = compExp(s * 100.);\n    float magnitude = exp(-50. *  r * r);\n    return phase * magnitude;\n}\n\nvec2 harmonicCoefficient(float nx, float ny, int resolution) {\n    float dx = 1. / float(resolution);\n    vec2 sum = vec2(0., 0.);\n    for (float x = 0.; x < 1.; x += dx) {\n        for (float y = 0.; y < 1.; y += dx) {\n            vec2 p = vec2(x, y);\n            vec2 is = initialState(p);\n            vec2 h = harmonic(nx, ny, p);\n            sum += cmul(is, h) * dx;\n        }\n    }\n    return sum;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// This buffer precomputes how much of each frequency is needed to reconstruct the initialState function.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 v = texture(iChannel0,uv).xy;\n    if (iFrame < 1) {\n        if (fragCoord.x < 1. && fragCoord.y < 1.) {\n            // Encode the initial resolution in the 0,0 corner so we know where to look when the viewport resizes.\n            v = iResolution.xy;\n        } else {\n            vec2 n = floor(uv * 100.);\n            v = harmonicCoefficient(n.x, n.y, 100);\n        }\n    }\n    fragColor = vec4(v, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}