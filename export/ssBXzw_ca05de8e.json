{"ver":"0.1","info":{"id":"ssBXzw","date":"1619907696","viewed":72,"name":"Ray_marching_timattt","username":"timattt","description":"Simple ray marching test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CONSTANTS\n//==========================================\n// Camera\nconst vec3 CAM_POS = vec3(0, 2, -8);\n\n// Ray marching\nconst float MAX_DIST = 30.0;\nconst int MAX_STEPS = 100;\nconst float EPSILON = 0.1;\nconst float LIGHT_EPSILON = 0.4;\nconst float SMOOTH_FACTOR = 0.1;\n//==========================================\n\n\n// STRUCTURES\n//==========================================\nstruct sphere {\n    vec3 center;\n    float rad;\n};\nstruct capsule {\n    vec3 center1;\n    vec3 center2;\n    float rad;\n};\nstruct box {\n    vec3 size;\n};\n//==========================================\n\n\n\n// OBJECTS IN SPACE\n//==========================================\n// sphere\nconst sphere sph = sphere(vec3(0, 2.0 + 0.28, 0), 1.0);\nconst vec3 sph_col = vec3(0.0, 1.0, 0.0);\n\n// capsule\nconst capsule cap = capsule(vec3(3.0, 3.0, 0.0), vec3(3.0, 4.0, 0.0), 0.2);\nconst vec3 cap_col = vec3(1.0, 0.0, 0.0);\nmat4 cap_model = mat4(1.0);\n\n// floor\nconst float FLOOR_Y = 1.0;\nconst vec3 floor_col = vec3(0.0, 0.0, 1.0);\n\n// light\nvec3 POINT_LIGHT = vec3(1.0, 6.0, 0.0);\n\n// Box\nconst box bx = box(vec3(0.5, 0.5, 0.5));\nconst vec3 box_col = vec3(1.0, 1.0, 0);\nmat4 box_model = mat4(1.0);\n//==========================================\n\n\n// MATH\n//==========================================\nmat4 rotationMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\nmat4 scaleMatrix(float sc) {\n    return mat4(sc, 0, 0, 0,\n                0, sc, 0, 0,\n                0, 0, sc, 0,\n                0, 0, 0, 1.0);\n}\n//==========================================\n\n\n// OBJECTS PARAMS\n//==========================================\nfloat MinShereDist(vec3 p, sphere sp) {\n    return length(p - sp.center) - sp.rad;\n}\nfloat MinCapsuleDist(vec3 p, capsule sp, mat4 model) {\n    p = (model * vec4(p.xyz, 1.0)).xyz;\n    \n    float t = dot(sp.center1 - p, sp.center1 - sp.center2) / dot(sp.center1 - sp.center2, sp.center1 - sp.center2);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 Y = sp.center1 + t * (sp.center2 - sp.center1);\n    \n    return length(Y - p) - sp.rad;\n    \n}\nfloat MinFloorDist(vec3 p) {\n    return p.y - FLOOR_Y;\n}\nfloat MinAABoxDist(vec3 p, box bx, mat4 model) {\n    p = (model * vec4(p.xyz, 1.0)).xyz;\n    return length(max(abs(p)-bx.size, 0.0));\n}\n//==========================================\n\n\n// Global functions\n//==========================================\nvec3 getColor(vec3 p) {\n    float d = MAX_DIST;\n    float tmp = 0.0;\n    vec3 result = vec3(0);\n    \n    if ((tmp = MinShereDist(p, sph)) < d) {\n        d = tmp;\n        result = sph_col;\n        \n    }\n    if ((tmp = MinCapsuleDist(p, cap, cap_model)) < d) {\n        d = tmp;\n        result = cap_col;\n    }\n    if ((tmp = MinFloorDist(p)) < d) {\n        d = tmp;\n        result = floor_col;\n    }\n    if ((tmp = MinAABoxDist(p, bx, box_model)) < d) {\n        d = tmp;\n        result = box_col;\n    }\n    \n    return result;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat GetMinDist(vec3 p) {\n    float d = MAX_DIST;\n    d = smin(d, MinShereDist(p, sph), SMOOTH_FACTOR);\n    d = smin(d, MinCapsuleDist(p, cap, cap_model), SMOOTH_FACTOR);\n    d = smin(d, MinFloorDist(p), SMOOTH_FACTOR);\n    d = smin(d, MinAABoxDist(p, bx, box_model),SMOOTH_FACTOR);\n    return d;\n}\n\nfloat rayMarch(vec3 start, vec3 dir) {\n    float res = 0.0;\n  \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = start + res * dir;\n        float d = GetMinDist(p);\n        \n        res += d;\n        \n        if (d < EPSILON) {\n            return res;\n        }\n    }\n  \n  \n    return res;\n}\n\nvec3 findNormal(vec3 p) {\n    float d = GetMinDist(p);\n    vec3 res = vec3\n    (\n        d - GetMinDist(p - vec3(EPSILON, 0.0, 0.0)),\n        d - GetMinDist(p - vec3(0.0, EPSILON, 0.0)),\n        d - GetMinDist(p - vec3(0.0, 0.0, EPSILON))\n    );\n    \n    return normalize(res);\n}\n\nfloat CalcLight(vec3 p) {\n    vec3 lightDir = normalize(POINT_LIGHT - p);\n    vec3 n = findNormal(p);\n    \n    float factor = dot(lightDir, n);\n    \n    // SHADOW\n    if (rayMarch(p + n * LIGHT_EPSILON, lightDir) < length(POINT_LIGHT - p)) {\n        factor = 0.0;\n    }\n    \n    return factor;\n}\n\nvoid update() {\n    float sina = sin(iTime);\n    float cosa = cos(iTime);\n\n    // UPDATE LIGHT\n    POINT_LIGHT = vec3(2.0 * cos(iTime), 6.0, -2.0);\n    \n    // UPDATE BOX\n    box_model[3][0] = sin(iTime);\n    box_model[3][1] = -3.0;\n    box_model = rotationMatrix(vec3(0, 1.0, 0), iTime) *  box_model;\n    \n    // UPDATE CAPSULE\n    cap_model = rotationMatrix(vec3(0.0, 1.0, 0.0), iTime);\n    \n}\n//==========================================\n\n\n// Main\n//==========================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    update();\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n \n    vec3 start = CAM_POS;\n    vec3 dir = normalize(vec3(uv.xy, 1.0));\n    \n    float distToObj = rayMarch(start, dir);\n    \n    vec3 p = start + dir * distToObj;\n \n    fragColor = vec4(getColor(p) * CalcLight(p), 1.0);\n}\n//==========================================","name":"Image","description":"","type":"image"}]}