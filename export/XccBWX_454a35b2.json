{"ver":"0.1","info":{"id":"XccBWX","date":"1733520096","viewed":67,"name":"eigenmodes Laplacian ","username":"kukovisuals","description":"eigenmodes, Laplacian","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["laplacian","eigenmodes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Convert HSB to RGB\nvec3 hsb2rgb(vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.z*1.0+vec3(2,4,5),6.0)-4.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb); \n    return c.x*mix(vec3(1.0),rgb,c.y);\n}\n\n// In a continuous domain, eigenmodes of the Laplacian on a rectangular domain \n// can be represented by sine and cosine patterns. Here we simulate \"graph eigenmodes\" \n// by summing various sine waves that serve as eigenvectors of a conceptual graph Laplacian.\n// We blend and animate these modes over time.\n//\n// We'll pick a few modes (n_x,n_y) and animate their amplitude or phase. \n\n// Parameters for pseudo eigenmodes\nconst int MODE_COUNT = 5;\nvec2 modes[MODE_COUNT] = vec2[](\n    vec2(10.0, 1.0),\n    vec2(2.0, 1.0),\n    vec2(3.0, 2.0),\n    vec2(1.0, 3.0),\n    vec2(4.0, 4.0)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalize coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Shift domain to [0,1]\n    // Think of the screen as a domain of a graph (like nodes arranged in a grid)\n    // Eigenmodes on a 2D domain often look like sin(nx*pi*x)*sin(ny*pi*y)\n    \n    // Time to blend modes and animate\n    float t = iTime;\n    float sumVal = 0.0;\n    \n    // Simulate that each mode corresponds to an eigenvector of a graph Laplacian:\n    // mode shape: sin(n_x * π * x)*sin(n_y * π * y)\n    // We vary their amplitude or phase over time\n    for (int i = 0; i < MODE_COUNT; i++) {\n        float nx = modes[i].x;\n        float ny = modes[i].y;\n        float phase = t * 0.13 * float(i+1);\n        // Simulate eigenvalue λ = (nx²+ny²)*π², and animate amplitude as a function of time\n        float lambda = (nx*nx + ny*ny)*3.14159*3.14159;\n        float amplitude = sin(t*0.2 + float(i)*1.1); // varying amplitude\n        float val = sin(nx*3.14159*uv.x + phase)*sin(ny*3.14159*uv.y + phase)*amplitude;\n        sumVal += val;\n    }\n    \n    // sumVal is the combined eigenmode pattern\n    // Map sumVal to a nice color pattern:\n    // Use sumVal to determine hue and brightness\n    float hue = fract(sumVal*1.4 + 0.5*sin(t*0.3));\n    float sat = 1.0;\n    float bri = 0.5 + 0.5*sin(sumVal*3.0 + t);\n    \n    vec3 color = hsb2rgb(vec3(hue, sat, bri));\n    \n    // Highlight positive/negative regions\n    // Add a slight line pattern to emphasize the structure:\n    float linePattern = sin((uv.x+uv.y)*50.0 + t*2.0)*0.5+0.5;\n    // Blend a bit more color when lines occur:\n    color = mix(color, vec3(0.8,0.9,1.0), linePattern*0.05);\n\n    // Slight temporal variation for a dynamic feel\n    color *= 0.9 + 0.1*sin(t*0.7 + uv.x*5.0 + uv.y*5.0);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}