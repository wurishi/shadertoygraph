{"ver":"0.1","info":{"id":"7lS3zd","date":"1625247110","viewed":119,"name":"Over The Open Fields","username":"andrew741","description":"Endless wheat fields... Let the clouds go by as the wheat sways in the wind and day turns to night. Also, sorry about the lag, the gradient noise function I'm using isn't as fast as i would like it to be (I'm using it for the wind, ground, and clouds).","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PERSITION 0.025\n#define MAX_DST 10.\n#define STEPS 115\n\n\n// the density at a given point in the atmosphere\nfloat GetDensity(float dstToPlannet)\n{\n    float density_fall_off = 6.5;  // the falloff speed for the atmospheric density\n    float h = dstToPlannet * 0.2;  // normalizeing the distance to the plannet based on the difference between the raidius of the atmosphere and the plannet\n    float density = exp(-h * density_fall_off) * (1. - h);\n    return density;\n}\n\n\n// uses ray marching to find the distance through the plannet (for a given position and direction)\nfloat raySphere(vec3 ro, vec3 rd)\n{\n    float lp;\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    // stepping and moving the ray closer and closer\n    for (int s = 0; s < 80; s++)\n    {\n        dst = -(p.y - 5.);\n        \n        // checking if its super close (to speed it up some sense its called so many times)\n        if (dst < 0.01) break;\n        dfs += dst;\n        p += rd * dst;\n    }\n    // returning the distance through the sphere\n    return dfs;\n}\n\n\n// gets the optical depth based on the ray direction, length, and position\nfloat opticalDepth(vec3 ro, vec3 rd, float rl)\n{\n    // the rays position\n    vec3 p = ro;\n    // the step size\n    float step_size = rl / 11.;\n    vec3 v3_step_size = rd * step_size;\n    // the optical depth\n    float odepth = 0.;\n    // the density\n    float ldense;\n    // stepping throught the atmosphere\n    for (int s = 0; s < 10; s++)\n    {\n        // moving the ray/point\n        p += v3_step_size;\n        // sampling the atmospheric density\n        ldense = GetDensity(p.y);\n        // adding up the optical depth\n        odepth += ldense * step_size;\n    }\n    // returning the optical depth\n    return odepth;\n}\n\n\n// gets the density of a cloud at a 3D point\nfloat CloudDensity(vec3 p)\n{\n    return max(noised1(p * 0.01) * 0.9 + 0.1, 0.);\n}\n\n\n// triplannar mapping https://www.youtube.com/watch?v=lctXaT9pxA0&t=1031s\nvec3 TriplannarStars(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 1.;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 5.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel1, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel1, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel1, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\nvec3 triplanarWheat(vec3 p, vec3 normal)\n{\n    // the scale of the texture\n    float scale = 1.;\n    // the sharpness of the blending between different axises\n    float blendSharpness = 5.;\n    // finding the different axise's color\n    vec3 colX = texture(iChannel0, p.zy * scale).rgb;\n    vec3 colY = texture(iChannel0, p.xz * scale).rgb;\n    vec3 colZ = texture(iChannel0, p.xy * scale).rgb;\n    \n    // finding the blending amount for each axis\n    vec3 bw = pow(abs(normal), vec3(blendSharpness));\n    // making it so the total (x + y + z) is 1\n    bw /= dot(bw, vec3(1.));\n    \n    // finding the final color\n    return colX * bw.x + colY * bw.y + colZ * bw.z;\n}\n\n\n// finding the scattering coefficents based on the wave lengths of different light colors\nvec3 scatteringCoefficents = pow(vec3(400.) / vec3(700, 530, 440), vec3(4.)) * 1.5;  // the coefficents for the scattering of different wave lengths/colors of light\n\n\nvec3 renderSky(vec3 ro, vec3 rd, float sceneDepth, vec3 sun_dir, vec3 sun_col, float time, vec3 col, bool sceneCollided)\n{\n    // rendering atmosphere\n    // finding the distance through the atmosphere\n    float dstThroughAtmosphere = min(5., sceneDepth);\n    // finding the step size going through the atmosphere\n    float step_size_f = dstThroughAtmosphere / 11.;\n    vec3 step_size = rd * step_size_f;\n    vec3 p = vec3(0.);\n    \n    // initizalizing some terms\n    float density;\n    float sun_length;\n    vec3 transmittance;\n    float sunRayOpticalDepth;\n    float veiwRayOpticalDepth;\n    vec3 inScatteredLight = vec3(0.);\n    // stepping through the atmosphere\n    for (int s = 0; s < 10; s++)\n    {\n        // moving the ray/point\n        p += step_size;\n        // fining the length through the atmosphere in the direction of the sun\n        sun_length = raySphere(p, sun_dir);\n        // finding the optical depth for the view ray and sun ray\n        sunRayOpticalDepth = opticalDepth(p, sun_dir, sun_length);\n        veiwRayOpticalDepth = opticalDepth(p, -rd, step_size_f * float(s));\n        // finding the transmittance\n        transmittance = exp(-(sunRayOpticalDepth + veiwRayOpticalDepth) * scatteringCoefficents);\n        // finding the atmospheric density at this point\n        density = GetDensity(p.y);\n        \n        // finding the amount of addition light\n        inScatteredLight += density * transmittance * scatteringCoefficents * step_size_f;\n    }\n    // applying the atmosphere\n    col = col * (exp(-veiwRayOpticalDepth) * length(col)) + inScatteredLight;\n    \n    // checking if the sky needs to be rendered\n    if (!sceneCollided)\n    {\n        // adding the stars\n        col += pow(TriplannarStars(rd + time * 0.1, rd), vec3(2.75)) * pow(1. - length(col), 5.) * 0.7;\n        // adding the sun\n        col = mix(col, sun_col, pow(max(dot(rd, sun_dir), 0.), 275.));\n        \n        // rendering clouds\n        // finding the distance to the cloud layer\n        float toClouds = (40. - ro.y) / rd.y;\n        // checking if the cloud layer is within a reasonable range\n        if (toClouds < 720. && rd.y > 0.)\n        {\n            // finding the distance throught the cloud layer\n            float throughClouds = 50. / rd.y;\n\n            // finding the step size going through the cloud layer\n            float step_size_f = min(throughClouds / 21., 15.);\n            vec3 step_size = rd * step_size_f;\n            \n            // finding where the point collides with the cloud layer (with some shifting so the cloud move)\n            vec3 p = vec3(-ro.x * 4. + iTime * 12., ro.y, -ro.z * 4. +  + iTime * 12.) + rd * toClouds;\n\n            // defining some terms\n            vec3 sun_p;\n            vec3 sunStep;\n            float sunStepF;\n\n            float inScattered = 0.;\n            float transmittion = 1.;\n            float totalLightDensity;\n\n            // stepping through the clouds\n            for (int s = 0; s < 20; s++)\n            {\n                // moving the point/ray\n                p += step_size;\n\n                // sampling the density\n                density = CloudDensity(p);  // replace with noise function\n                \n                // stepping twords the sun\n                if (density >= 0.)\n                {\n                    // reseting some terms\n                    sun_p = p;\n                    totalLightDensity = 0.;\n                    sunStepF = min((p.y - 40.) / sun_dir.y / 11., 10.);\n                    sunStep = sun_dir * sunStepF;\n                    // stepping through the cloud twords the sun\n                    for (int s = 0; s < 10; s++)\n                    {\n                        // sampling the density at the current point\n                        totalLightDensity += CloudDensity(sun_p) * sunStepF;\n                        // moving the ray/point\n                        sun_p += sunStep;\n                    }\n                    // finding the transmittance based on the amount of stuff (cloud) in the way e^-density\n                    transmittion *= exp(-density * step_size_f * 0.1);\n                    // finding the amount of inScatterd light\n                    inScattered += density * transmittion * exp(-totalLightDensity) * 1.5;\n                }\n\n                if (transmittion < 0.05) break;  // an optomization as the transmittion is so low that anything lower dosent vissually change much\n            }\n            // fading the clouds out at the edges so it looks like they are within the atmosphere\n            transmittion = mix(transmittion, 1., smoothstep(0., 1., toClouds / 720.));\n            // checking if the clouds are being shadowed by the planet (night time)\n            // add the clouds on top of the current color based on the transmittion\n            inScattered = inScattered * 0.8 + 0.2;\n            if (sun_dir.y > 0.) col = mix(col, vec3(inScattered, inScattered, inScattered + 0.1 * (1. - inScattered)), 1. - transmittion);\n            else col *= transmittion;\n        }\n    }\n    \n    return col;\n}\n\n\n// stores data on specualar refleciton and diffusion\nstruct SpecularLight\n{\n    float highlight;\n    float diffuse;\n};\n\n\n// calculates the speucalar reflection and diffusion\nSpecularLight Specular(float smoothness, vec3 normal, vec3 rd, vec3 sun_dir)\n{\n    float specularAngle = acos(dot(normalize(sun_dir - rd), normal));\n    float specularExponent = specularAngle / (1. - smoothness);\n    // finding the specular highlight\n    float specularHighlight = exp(-specularExponent * specularExponent);\n    // fidning the amount of diffused light\n    float diffseLighting = clamp(dot(normal, sun_dir), 0., 1.);\n    return SpecularLight(specularHighlight, diffseLighting);\n}\n\n\nstruct Ray\n{\n    vec3 rd, ro, cp, normal;\n    vec4 col;\n    bool collided;\n    float dst;\n    //SpecularLight spec;\n};\n\n\n// from https://www.shadertoy.com/view/WtGXDD\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n// the signed distance to a box\nfloat dstBox(vec3 p, vec3 size)\n{\n    float l = -(abs(p.x) - size.x);\n    float r = -(abs(p.z) - size.z);\n    float f = -(abs(p.y) - size.y);\n    return -min(f, min(l, r));\n}\n\n\nfloat hash21(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat dstGrass(vec3 p, float dst1)\n{\n    p.y += dst1;\n    vec3 wind = noised(p + 20. + vec3(0., iTime, 0.)).xyz;\n    p.xz -= wind.xy * 0.1;\n    p.xz -= clamp(hash(floor(p.xz * 24.)) * 200., -12.5, 12.5);\n    vec3 offset = vec3(fract(p.x * 10.) * 0.1 - 0.05, p.y, fract(p.z * 10.) * 0.1 - 0.05);\n    offset.y *= 0.1;\n    float dst = length(offset) - 0.015;\n    return dst;\n}\n\n\nfloat GetDst(vec3 p)\n{\n    float height = noised1(p * 0.25);\n    float dst1 = p.y + height;\n    float dst2 = dstGrass(p, height);\n    \n    return min(dst1, dst2);\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDst(p);\n    vec2 e = vec2(.00025, 0);\n    \n    vec3 normal = d - vec3(\n        GetDst(p - e.xyy),\n        GetDst(p - e.yxy),\n        GetDst(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nvec4 GetColAndMat(vec3 p)\n{\n    float height = noised1(p * 0.25);\n    float dst1 = p.y + height;\n    float dst2 = dstGrass(p, height);\n    \n    float dst = min(dst1, dst2);\n    \n    if (dst == dst1) return vec4(0.6, 0.8, 0.2, 0.);\n    if (dst == dst2) return vec4(0.7, 0.8, 0.2, 1.);\n    return vec4(-1.);\n}\n\n\nfloat GetSmoothness(vec3 p)\n{\n    float height = noised1(p * 0.25);\n    float dst1 = p.y + height;\n    float dst2 = dstGrass(p, height);\n    \n    float dst = min(dst1, dst2);\n    \n    if (dst == dst1) return 0.9;\n    if (dst == dst2) return 0.95;\n    return 0.;\n}\n\n\n\nRay MarchRay(vec3 rd, vec3 ro, vec3 sun_dir)\n{\n    float dst;\n    vec3 p = ro;\n    float dfs = 0.;\n    bool collided = false;\n    for (int s = 0; s < STEPS; s++)\n    {\n        dst = GetDst(p);\n        p += rd * dst;\n        dfs += dst;\n        \n        if (dst < PERSITION)\n        {\n            collided = true;\n            break;\n        }\n        else if (dfs > MAX_DST) break;\n    }\n    \n    \n    vec3 normal = GetNormal(p);\n    //SpecularLight spec = Specular(GetSmoothness(p), normal, rd, sun_dir);\n    Ray ray = Ray(rd, ro, p, normal, GetColAndMat(p), collided, dfs);\n    \n    return ray;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    if (m == vec2(0) || iMouse.z < 0.)\n    {\n        m = vec2(0.1, 0.5);\n    }\n    \n    float time = iTime * 0.25 + 0.1;\n    \n    vec3 sun_col = vec3(1., 0.9, 0.65);\n    vec3 sun_dir = normalize(vec3(0.2 + sin(time) * 0.2, sin(time), cos(time)));\n    \n    // from https://www.shadertoy.com/view/WtGXDD (getting ro and rd)\n    vec3 ro = vec3(0, 8, -8) * 0.1;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    vec3 rd = GetRayDir(uv, ro, vec3(0., 0., 0.), 1.);\n    ro.y = noised1(ro) + 1.5;\n    ro.xz += iTime;\n    \n    vec3 col = vec3(0.3, 0.3, rd.y * 0.5 + 0.5);\n    col = mix(col, sun_col, pow(max(dot(rd, sun_dir), 0.), 275.));\n    \n    Ray ray;\n    float dst = MAX_DST;\n    if ((ro.y > 1. && rd.y < 0.) || (ro.y <= 1.))\n    {\n        ray = MarchRay(rd, ro, sun_dir);\n        if (ray.collided) dst = ray.dst;\n        if (ray.collided)\n        {\n            vec3 objectCol;\n            if (ray.col.a == 1.)\n            {\n                vec3 wheatText = triplanarWheat(ray.cp, ray.normal);\n                objectCol = ray.col.rgb + wheatText;\n                objectCol = objectCol * max(dot(sun_dir, ray.normal) * 0.6 + 0.4, 0.);\n            }\n            else\n            {\n                objectCol = ray.col.rgb + texture(iChannel2, ray.cp.xz).rgb * 0.2;\n                objectCol = objectCol * max(dot(sun_dir, ray.normal), 0.);\n            }\n            objectCol *= (sun_dir.y <= 0.) ? 0. : 1.;\n\n            col = objectCol;\n        }\n    }\n    \n    col = renderSky(-ro * 15., rd, dst * 0.1, sun_dir, sun_col, time, col, ray.collided);\n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// from https://www.shadertoy.com/view/WtGXDD\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// from https://www.shadertoy.com/view/WtGXDD\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\n// from another shadertoy shader\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nvec2 hash(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\n// from another shadertoy shader\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i                   );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w                   );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                 du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n\nfloat noised1( in vec3 x )\n{\n    // grid\n    vec3 i = floor(x);\n    vec3 w = fract(x);\n    \n    // cubic interpolant\n    vec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    // gradients\n    vec3 ga = hash( i                   );\n    vec3 gb = hash( i+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( i+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( i+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( i+vec3(0.0,0.0,1.0) );\n\tvec3 gf = hash( i+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( i+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( i+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w                   );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolations\n    return va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z;\n}\n\n","name":"Common","description":"","type":"common"}]}