{"ver":"0.1","info":{"id":"NsfBz4","date":"1644528960","viewed":161,"name":"Window frames ","username":"kastorp","description":"inspired by [url=https://www.flickr.com/photos/44mlb/3619483807]this[/url]\nuncomment ANIMATE to show algorithm","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","frame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//window Frames by kastorp\n//-------------------------\n// a simple algorithm to get aligned boxes using voronoi\n\n#define R iResolution.xy\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n#define min3(f1,f2,f3) min(f1,min(f2,f3))\n#define max3(f1,f2,f3) max(f1,max(f2,f3))\n//#define GRID\n//#define ANIMATE\n//#define EXACT \n\n//select neighborhood size:\n#ifdef EXACT //exact but slow\n    #define getid x+y*5+23\n    #define SZ 46\n    #define HS 3\n#else  //works on 99.9% cases\n    #define getid x+y*5+18\n    #define SZ 36\n    #define HS 2\n#endif \n\n#ifdef ANIMATE \n    #define th fract(iTime/6.)*5.\n    #define ST0  clamp(th,0.,2.)/4.\n    #define ST1  (clamp(th,2.,3.)-2.)\n    #define ST2  (clamp(th,3.,4.)-3.)\n#else\n    #define ST0 .5\n    #define ST1 1.\n    #define ST2 1.\n#endif\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nvoid mainImage( out vec4 O, in vec2 U )\n{\n     U = (U/R.y - R/R.y*.5)*6. +iTime*.4;\n     O*=0.;\n     \n     vec2 c =floor(U+.5);\n     vec2 pc[SZ];\n     \n     //random voronoi centers\n     for(int x =-2;x<=2;x++) for(int y =-HS-1;y<=HS+1;y++){\n         vec2 p = c + vec2(x,y), r= hash22(p);\n         //float  a =  r.x*6.28 + iTime*.2;\n         pc[getid]=p+  + r*1.  -.5;  //+vec2(sin(a),cos(a))*.25      \n     }\n     \n     vec4 bc[SZ],bc2[SZ]; //x=left,y=bottom,z=right,w=top\n     \n     //up & down:  (PC--> BC)\n     for(int x =-2;x<=2;x++) for(int y =-HS;y<=HS;y++){\n         int id=getid;\n         bc[id] =(1.-ST0)*pc[id].xyxy + ST0*vec4(\n                  max3(pc[id-6].x,pc[id-1].x,pc[id+4].x), \n                  pc[id-5].y,\n                  min3(pc[id+6].x,pc[id+1].x,pc[id-4].x), \n                  pc[id+5].y\n              );        \n     }\n     \n     //left: (BC-->BC2)\n     for(int y =-2;y<=2;y++) for(int x =-2;x<=2;x++)  {\n        int id=getid;\n        bc2[id].yzw=bc[id].yzw;\n       \n        float l=bc[id-1].z ;\n        if(bc[id-6].z>l && bc[id-6].w> bc[id].y) l=bc[id-6].z;\n        if(bc[id+4].z>l && bc[id+4].y< bc[id].w) l=bc[id+4].z;\n        bc2[id].x = bc[id].x + ST1* (-bc[id].x+l);\n     }\n\n     //right: (BC2-->BC)\n     for(int y =-1;y<=1;y++) for(int x =-1;x<=1;x++)  {\n        int id=getid;\n        bc[id].xyw=bc2[id].xyw;       \n        float r =bc2[id+1].x;\n        if(bc2[id+6].x<r && bc2[id+6].y < bc2[id].w) r=bc2[id+6].x;\n        if(bc2[id-4].x<r && bc2[id-4].w > bc2[id].y) r=bc2[id-4].x;\n        bc[id].z = bc2[id].z - ST2* (bc2[id].z-r);\n     }\n\n     //draw:\n     for(int x =-1;x<=1;x++) for(int y =-1;y<=1;y++){\n         int id=getid; \n         vec2 c = pc[id];\n         vec4 col =hue(c.xyxy*1.5);\n#ifdef GRID\n         O+=vec4(1)*smoothstep(.01,0.,length(U-c)-.03);   //voronoi initial random point      \n         O+=smoothstep(.997,1.02, max(cos((U.x-.43)*6.28) ,cos((U.y-.43)*6.28))); //voronoi grid\n#endif\n        vec4 b= bc[id]; //from corner positions to center & size\n         b=vec4(b.z+b.x,b.w+b.y, b.z-b.x,b.w-b.y)*.5;\n         \n         float d = sdBox(U-b.xy,b.zw-.1);       \n         O+=col* smoothstep(.01,-.01, abs(d)-.05)  ;\n         O+=col*.5* smoothstep(.01,-.01, d+.05)  ;\n     }  \n}","name":"Image","description":"","type":"image"}]}