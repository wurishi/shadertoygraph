{"ver":"0.1","info":{"id":"mdGyWR","date":"1695961640","viewed":67,"name":"Mandelbrot Void Exploration","username":"shaderwho","description":"Mandelbrot Void Exploration","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// golfed version: vec3 lP=vec3(2.),lC=vec3(1.1,1.,1.);float aS=1.,sS=.5,s=32.;vec3 pL(vec3 c,vec3 n,vec3 fP,vec3 vP){vec3 a=aS*c,lD=normalize(lP-fP),vD=normalize(vP-fP),rD=reflect(-lD,n);float d=max(dot(n,lD),0.),sp=pow(max(dot(vD,rD),0.),s);vec3 df=d*c,spc=sS*sp*lC;return a+df+spc;}vec3 cN(vec2 c){const float e=0.001;float b=length(vec2(c.x*c.x-c.y*c.y+c.x,2.*c.x*c.y+c.y)),dx=length(vec2((c.x+e)*c.x-c.y*c.y+c.x,2.*(c.x+e)*c.y+c.y)),dy=length(vec2(c.x*c.x-(c.y+e)*c.y+c.x,2.*c.x*(c.y+e)+c.y));return normalize(vec3(dx-b,dy-b,e));}vec3 adjS(vec3 c,float a){float g=dot(c,vec3(.299,.587,.014));return mix(vec3(g),c,a);}vec3 bE(vec3 c,float sN,vec2 u,float t){u=abs(u);float b=fract(sN+sin(u.x+t)*42.);c=mix(c,vec3(.6,.1,.7),b);return c;}vec3 gC(vec2 u,vec2 cn,float z,int nS,float t){vec2 c=cn+u/z,zz=c;int n=0,mI=int(235.+65.*sin(t*1.14/6.));for(int i=1;i<mI;i++){if(dot(zz,zz)>50.)break;zz=vec2(zz.x*zz.x-zz.y*zz.y,2.*zz.x*zz.y)+c+vec2(.0,-1.);n++;}float sN=float(n)*.15+sin(t*.001)*10.1;if(float(n)<float(mI)){float nu=log(log(length(zz)))/log(15.),a=atan(zz.y,zz.x),iP=sin(a*2.+cos(sN*4.+t*2.)*9.+t*13.)*10.5+10.5,rE=sin(sN*3.+a*6.+t*.01+cos(a*29.+sN*2.)*1.+iP*1.)*.9+.6,cC=sin(a+t*2.)*cos(sN*2.+t)*.5+.5;vec3 bC=vec3(fract(sin(sN*cC)*43758.5453),fract(cos(sN*cC)*12345.6789),fract(sin(sN*cC)*78901.2345)),clr=mix(bC,vec3(.2,.1,0.),rE*iP)*(1.+sin(iP*20.)*.05);clr=bE(clr,sN,u,t);float fE=fract(sin(dot(u*(rE+.1),vec2(12.9898,78.233)))*43758.5453),wPE=step(.995,fE)*(1.+sin(iP*20.)*.05);clr=mix(clr,vec3(.5,.5,.6),wPE);float sA=sin(t*1.5+sN)*.3;clr=adjS(clr,sA);return clr;}else return vec3(0.);}vec3 gSSC(vec2 u,vec2 cn,float z,int nS,float t){vec3 clr=vec3(-1.);const int sS=2;for(int i=-sS;i<=sS;i++)for(int j=-sS;j<=sS;j++){vec2 o=vec2(float(i)/float(sS),float(j)/float(sS))/iResolution.xy;clr+=gC(u+o,cn,z,nS,t);}return clr/float((2*sS+1)*(2*sS+1));}vec3 gR(vec2 u,vec2 cn,float z,int nS,float t){vec3 rC=vec3(0.);float o=.06;rC+=gC(u+vec2(o,0.),cn,z,nS,t);rC+=gC(u+vec2(-o,0.),cn,z,nS,t);rC+=gC(u+vec2(0.,o),cn,z,nS,t);rC+=gC(u+vec2(0.,-o),cn,z,nS,t);return rC/1100.;}void mainImage(out vec4 fC,in vec2 fCrd){vec2 rs=iResolution.xy,u=(2.*fCrd.xy-rs)/min(rs.y,rs.x);float t=iTime,sZ=.00000001,eZ=90000.,zInD=22.,zOutD=zInD*16.,tD=zInD+zOutD,nT=mod(t,tD)/tD,e=nT<(zInD/tD)?nT*(tD/zInD):1.-((nT-(zInD/tD))*(tD/zOutD)),z=sZ*pow(eZ/sZ,e)*t;vec2 cn=vec2(.109754,.362283);float s=41.;if(iMouse.z>0.)cn+=s*(iMouse.xy-rs*.5)/(z*rs.y);int nS=int(mix(1.,1.5,smoothstep(1.,1.5,e)));vec3 clr=vec3(0.);for(int i=-nS;i<=nS;i++)clr+=gSSC(u+float(i)*.00*(u-cn),cn,z,nS,t);clr/=float(2*nS+1);vec3 fP=vec3(fCrd.xy,1.),vP=vec3(.0,300.,21.),n=cN(cn+u/z);vec3 r=gR(u,cn,z,nS,t),fClr=mix(clr,r,.0),lClr=pL(fClr,n,fP,vP);fC=vec4(lClr,1.);}\n\n\n// maxIter // Maximum iterations for the fractal loop; increasing this value will result in more details.\n// colorTransitionSpeed // Speed at which the colors transition; lower values will make the transition slower and vice versa.\n// scaledN // Smooth color transition based on time and speed; modify .15 to scale the number of iterations.\n\n// intricatePattern // Determines the complexity of patterns in the fractal.\n// rippleEffect // Determines the amplitude and frequency of ripples in the fractal.\n// colorComplexity // Determines the complexity of the color mix in the fractal.\n// saturationAdjustment // Adjusts the saturation of the color; change to adjust the saturation level of the fractal.\n// ethrealeffect // Adjusts fractal color theme by adding another complex math sequence that creates unique patterns.\n// WhitePointEffect // Adjustable effect which fragments individual iteration colors into chaotic patterns, giving a scattered effect.\n\n// startZoom // The initial zoom level of the fractal.\n// endZoom // The final zoom level of the fractal.\n// zoomInDuration // The duration of zooming in; modify this value to make the zoom-in effect slower or faster.\n// zoomOutDuration // The duration of zooming out; modify this value to make the zoom-out effect slower or faster.\n// sensitivity // The sensitivity of mouse interaction; modify this value to change the reaction of the fractal to the mouse movement.\n\n// frequency  // The frequency of the wave; modify this to change the frequency of the wave effect in the fractal.\n// amplitude  // The amplitude of the wave; modify this to change the amplitude of the wave effect in the fractal.\n// speed  // The speed of the wave; modify this to change the speed of the wave effect in the fractal.\n// numSamples // The number of samples for anti-aliasing; modify to change the quality of the fractal.\n\n// Light properties\nvec3 lightPos = vec3(2.0, 2.0, 1.0); // Position of the light source in world space\nvec3 lightColor = vec3(1.1, 1.0, 1.0);\nfloat ambientStrength = 1.0; // Adjust the ambient light strength\nfloat specularStrength = 0.5; // Adjust the specular light strength\nfloat shininess = 32.0; // Adjust the shininess factor\n\n\nvec3 phongLighting(vec3 color, vec3 normal, vec3 fragPos, vec3 viewPos) {\n    vec3 ambient = ambientStrength * color;\n    vec3 lightDir = normalize(lightPos - fragPos);\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * color;\n    vec3 viewDir = normalize(viewPos - fragPos);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);\n    vec3 specular = specularStrength * spec * lightColor;\n    return ambient + diffuse + specular;\n}\n\nvec3 computeNormal(vec2 c) {\n    // Approximate the normal using the gradient of the fractal function\n    const float eps = 0.001;\n    float base = length(vec2(c.x*c.x - c.y*c.y + c.x, 2.0 * c.x * c.y + c.y));\n    float dx = length(vec2(c.x+eps*c.x*c.x - c.y*c.y + c.x, 2.0 * (c.x+eps) * c.y + c.y));\n    float dy = length(vec2(c.x*c.x - (c.y+eps)*c.y + c.x, 2.0 * c.x * (c.y+eps) + c.y));\n    return normalize(vec3(dx - base, dy - base, eps));\n}\nvec3 adjustSaturation(vec3 color, float adjustment) {\n    float grey = dot(color, vec3(.299, 0.587, 0.014));\n    return mix(vec3(grey), color, adjustment);\n}\n\nvec3 butterflyEffect(vec3 color, float scaledN, vec2 uv, float time) {\n    uv = abs(uv);\n    float banding = fract(scaledN * 1.0 + sin(uv.x * 1.0 + time) * 42.0);\n    color = mix(color, vec3(0.6, 0.1, 0.7), banding);\n    return color;\n}\n\nvec3 getColor(vec2 uv, vec2 center, float zoom, int numSamples, float time) {\n    vec2 c = center + uv / zoom;\n    vec2 z = c;\n    int n = 0; // Changed the type of n to int\n    float colorTransitionSpeed = 0.001; \n\n    // Control Iteraction Activation / Deactivation length\n    int maxIter = int(235.0 + 65.0 * sin(time * 1.14 / 6.0)); // #1 maxHigh #2 maxLow // Dynamic maxIter modifier\n\n    for(int i = 1; i < maxIter; i++) { // Changed the loop variable to int\n        if(dot(z, z) > 50.0) break;\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c + vec2(.0, -1.0);\n        n++;\n    }\n\n    float scaledN = float(n) * .15 + sin(time * colorTransitionSpeed) * 10.1; \n    \n    if(float(n) < float(maxIter)) {\n        float nu = log(log(length(z))) / log(15.0); // iteration definition\n        scaledN = scaledN + 1.1 - 5.1 * nu;\n        float angle = atan(z.y, z.x);\n\n        float intricatePattern = sin(angle * 2.0 + cos(scaledN * 4.0 + time * 2.0) * 9.0 + time * 13.0) * 10.5 + 10.5;\n\n        float rippleEffect = sin(scaledN * 3.0 + angle * 6.0 + time * .01 + cos(angle * 29.0 + scaledN * 2.0) * 1.0 + intricatePattern * 1.0) * 0.9 + 0.6;\n\n        float colorComplexity = sin(angle * 1.0 + time * 2.0) * cos(scaledN * 2.0 + time) * 0.5 + 0.5;\n        vec3 baseColor = vec3(fract(sin(scaledN * colorComplexity) * 43758.5453), fract(cos(scaledN * colorComplexity) * 12345.6789), fract(sin(scaledN * colorComplexity) * 78901.2345));\n        vec3 color = mix(baseColor, vec3(0.2, 0.1, 0.0), rippleEffect * intricatePattern) * (1.0 + sin(intricatePattern * 20.0) * 0.05);\n        \n        color = butterflyEffect(color, scaledN, uv, time);\n\n        float fragmentedEffect = fract(sin(dot(uv * (rippleEffect + 0.1), vec2(12.9898, 78.233))) * 43758.5453);\n        float whitePointsEffect = step(0.995, fragmentedEffect) * (1.0 + sin(intricatePattern * 20.0) * 0.05);\n        color = mix(color, vec3(.5, 0.5, 0.6), whitePointsEffect);\n\n        float saturationAdjustment = sin(time * 1.5 + scaledN) * 0.3 + 0.0;\n        color = adjustSaturation(color, saturationAdjustment);\n\n        return color;\n    } else {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\n//super sampling\nvec3 getSuperSampledColor(vec2 uv, vec2 center, float zoom, int numSamples, float time) {\n    const int superSamples = 2; // Increase or decrease this value according to the quality you desire. past 2 is major fps loss\n    vec3 color = vec3(-1.0); // brightness / modify supersamps control over colors interaction with individual iteration / lower value = more fps since less color iterations being processed\n    for(int i = -superSamples; i <= superSamples; i++) {\n        for(int j = -superSamples; j <= superSamples; j++) {\n            vec2 offset = vec2(float(i) / float(superSamples), float(j) / float(superSamples)) / iResolution.xy;\n            color += getColor(uv + offset, center, zoom, numSamples, time);\n        }\n    }\n    //super samp render customization / #1 color rendering clarity #2\n    color /= float((2 * superSamples + 1) * (2 * superSamples + 1)); // Normalizing by the number of samples taken\n    return color;\n}\nvec3 getReflection(vec2 uv, vec2 center, float zoom, int numSamples, float time) {\n    vec3 reflectedColor = vec3(0.0);\n    float offset = .06; // \n    reflectedColor += getColor(uv + vec2(offset, 0.0), center, zoom, numSamples, time);\n    reflectedColor += getColor(uv + vec2(-offset, 0.0), center, zoom, numSamples, time);\n    reflectedColor += getColor(uv + vec2(0.0, offset), center, zoom, numSamples, time);\n    reflectedColor += getColor(uv + vec2(0.0, -offset), center, zoom, numSamples, time);\n    reflectedColor /= 1100.0; // averaging the colors / lower = more color noise and chaos / higher = more color and iteration HD\n    return reflectedColor;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 resolution = iResolution.xy;\n    float time = iTime; // Use iTime instead of iGlobalTime\n    \n    //sim controls\n    float startZoom = 0.00000001; // Declare startZoom\n    float endZoom = 90000.0;\n    float zoomInDuration = 22.0;\n    float zoomOutDuration = zoomInDuration * 16.0;\n    float totalDuration = zoomInDuration + zoomOutDuration;\n    float normalizedTime = mod(time, totalDuration) / totalDuration;\n    float elapsed = normalizedTime < (zoomInDuration / totalDuration) ? normalizedTime * (totalDuration / zoomInDuration) : 1.0 - ((normalizedTime - (zoomInDuration / totalDuration)) * (totalDuration / zoomOutDuration));\n    \n    float z = time; // Use time as a third dimension\n    float zoom = startZoom * pow(endZoom / startZoom, elapsed) * z; // Ensure no division by zero and use declared variables    \n    vec2 center = vec2(0.109754, 0.362283);\n    float sensitivity = 41.0;\n    \n    // mouseclick interaction base\n    if(iMouse.z > 0.0) {\n        vec2 mouseDelta = (iMouse.xy - resolution * 0.5);\n        center += sensitivity * mouseDelta / (zoom * resolution.y);\n    }\n    \n    //ripple effect base\n    vec2 uv = (2.0 * fragCoord.xy - resolution) / min(resolution.y, resolution.x);\n    float frequency = 3.0;\n    float amplitude = 0.09;\n    float speed = 1.6;\n    \n    uv.y += sin(uv.x * frequency + time * speed) * amplitude;\n    //2d plane rotation base\n    float angle = time * 0.09;\n    float s = sin(angle);\n    float c = cos(angle);\n    uv = vec2(c * uv.x - s * uv.y, s * uv.x + c * uv.y);\n    \n    //motionblur & variables\n    vec3 color = vec3(0.0);\n    int numSamples = int(mix(1.0, 1.5, smoothstep(1.0, 1.5, elapsed))); // motion blue multiplier\n\n    for(int i = -numSamples; i <= numSamples; i++) {\n        float offset = float(i) * .00; // motion blur threshold \n        vec2 sampleUv = uv + offset * (uv - center);\n        color += getSuperSampledColor(sampleUv, center, zoom, numSamples, time); // Changed to super sampled color\n    }\n    color /= float(2 * numSamples + 1);\n    // lightsource customization\n    vec3 fragPos = vec3(fragCoord.xy, 1.0);\n    vec3 viewPos = vec3(.0, 300.0, 21.0); \n    vec3 normal = computeNormal(center + uv / zoom); \n\n    vec3 reflection = getReflection(uv, center, zoom, numSamples, time);\n    vec3 finalColor = mix(color, reflection, .0); // 0 = default / mixes original color with reflection\n\n    vec3 lightingColor = phongLighting(finalColor, normal, fragPos, viewPos);\n    fragColor = vec4(lightingColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}