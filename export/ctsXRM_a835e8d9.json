{"ver":"0.1","info":{"id":"ctsXRM","date":"1674497206","viewed":131,"name":"Basic maze gen + rainbow path","username":"FliegendeWurst","description":"Just a fun experiment in maze exploration visualization.\n\nPress R for a new maze. Maze size can be set in Buf A.","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["2d","rainbow","maze"],"hasliked":0,"parentid":"XdKGWK","parentname":"basic maze generator"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//const vec2 MazeSize = 4. * vec2(16., 9.);\nconst float WThk = 0.35; // wall thickness\n\nfloat s, c;\n#define rotateTo(p, a) mat2(c=a.y, s=a.x, -s, c) * p\n\nfloat drawWall(in vec2 p, vec2 dir) {\n    p = fract(rotateTo(p, dir)) - .5;\n    \n    // square ends\n    //return 2. * max(-p.y, abs(p.x)) - WThk;\n    \n    // round ends\n    p.y = max(0., -p.y);\n    return 2. * length(p) - WThk;\n}\n\n//Hue to RGB (red, green, blue).\n//Source: https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// https://www.shadertoy.com/view/wt23Rt\n#ifndef saturate\n#define saturate(v) clamp(v,0.,1.)\n//      clamp(v,0.,1.)\n#endif\nvec3 hue2rgb(float hue){\n\thue=fract(hue);\n\treturn saturate(vec3(\n\t\tabs(hue*6.-3.)-1.,\n\t\t2.-abs(hue*6.-2.),\n\t\t2.-abs(hue*6.-4.)\n\t));\n}\n\n#define t2D(o) texture(iChannel0, (floor(p)+.5-o)/res)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 MazeSize = texture(iChannel0, vec2(.5)/res).ba;\n    vec2 p = (fragCoord + vec2(.001)) * MazeSize / res;\n    \n    // hide the mess outside the maze\n    p = clamp(p, vec2(.5), MazeSize-.5);\n    \n    // to save a few chars\n    vec3 o = vec3(1., -1., 0.);\n    \n    vec2 dirs[4];\n    dirs[0] = o.xz;\n    dirs[1] = o.yz;\n    dirs[2] = o.zx;\n    dirs[3] = o.zy;\n    \n    // initial wall\n    float wall = drawWall(p, t2D(o.zz).rg);\n    \n    // evaluate neighbors to fill in wall gaps\n    for(int i=0; i<4; i++)\n        if(all(equal(dirs[i], t2D(dirs[i]).rg)))\n            wall = min(wall, drawWall(p, -t2D(dirs[i]).rg));\n    \n    // aa\n    float ss = 2. / res.y * MazeSize.y;\n    wall = smoothstep(-ss, ss, wall);\n    \n    fragColor = vec4(vec3(wall), 1.);\n    float r = texelFetch(iChannel1, ivec2(floor(p + .5)), 0).r;\n    if (r > 0.0) {\n        fragColor -= .5 * vec4(hue2rgb(r / 80.0), 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const vec2 MazeSize = 16. * vec2(16., 9.);\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define t2D(o) texture(iChannel0, fract(uv+o/res))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 fg = floor(fragCoord);\n    \n    // saving a few chars\n    vec3 o = vec3(1., -1., 0.);\n    \n    // wall direction (will be stored)\n    vec2 wdir = o.zz;\n    \n    // initialize wall boundaries\n    if(iFrame==0 || texture(iChannel3, vec2(82.5/256., .5)).r>0.) {\n        if(fg.y==0.)\n            wdir = o.xz;\n        if(fg.y==MazeSize.y-1.)\n            wdir = o.yz;\n        if(fg.x==0.)\n            wdir = o.zx;\n        if(fg.x==MazeSize.x-1.)\n            wdir = o.zy;\n    }\n    // create maze walls\n    else {\n        // this cell's stored wall direction, if any\n        wdir = t2D(o.zz).rg;\n        \n        // is this cell empty?\n        if(length(wdir)==0.) {\n            \n            // a random, cardinal direction\n            float a = radians(90.*floor(4.*hash12(uv+mod(iTime/100., 100.))));\n            vec2 r = floor(.5+vec2(sin(a), cos(a)));\n            \n            /*\n            if (r.x < -1.0 || r.x > 1.0 || r.y < -1.0 || r.y > 1.0 || r.x * r.y != 0.0) {\n                // invalid direction\n            }\n            */\n\n\t\t\t// if wall exists in direction r, make a new wall using that direction\n            if(length(t2D(r).rg)>0.)\n            //if(dot(r, t2D(r).rg)>.5 || .975<hash12(-uv-mod(iTime/100., 100.)))\n            //if(.5>dot(r, t2D(r).rg))\n                wdir = r;\n        }\n    }\n    \n    // store wall direction\n    fragColor.rg = wdir;\n    \n    // store maze size (for Image shader)\n    if(all(equal(fg, o.zz)))\n       fragColor.ba = MazeSize;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define t2D(o) texture(iChannel0, fract(uv+o/res))\n#define color_at(o) texelFetch(iChannel1, ivec2(fg + o), 0)\n#define reached(o) texelFetch(iChannel1, ivec2(fg + o), 0).r > 0.\n\n//#define DEBUG_WDIRS\n\n#define START_CORNER\n//#define START_MIDDLE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 uv = fragCoord / res;\n    vec2 fg = floor(fragCoord);\n\n    vec2 MazeSize = texture(iChannel0, vec2(.5)/res).ba;\n    bool active_here = reached(vec2(0., 0.));\n    \n    #ifdef DEBUG_WDIRS\n    vec2 wdir = t2D(vec2(0., 0.)).rg;\n    if (wdir.r != 0.0 || wdir.g != 0.0) {\n        fragColor = vec4((1. + wdir) / 2.0, 0., 1.);\n    }\n    return;\n    #endif\n\n    fragColor *= 0.;\n    if (fg.x == 0. || fg.y == 0. || fg.x == MazeSize.x || fg.y == MazeSize.y) {\n        return;\n    }\n    #ifdef START_CORNER\n    if (fg.x == 1. && fg.y == 1.) {\n    #endif\n    #ifdef START_MIDDLE\n    if (fg.x == MazeSize.x / 2.0 && fg.y == MazeSize.y / 2.0) {\n    #endif\n        fragColor = vec4(1.0, 0., 0., 1.);\n    }\n    // wait for maze to initialize\n    bool maze_ready = length(t2D(MazeSize / 2.0)) > 0.;\n    if(!maze_ready || texture(iChannel3, vec2(82.5/256., .5)).r>0.) {\n        return;\n    }\n    if (active_here) {\n        fragColor = color_at(0.0);\n    }\n    if (!active_here) {\n        // wall directions around this point\n        /*\n         * wdir1   wdir2\n         *       P\n         * wdir3   wdir4\n         *\n         */\n        vec2 wdir1 = t2D(vec2(-1., 0.)).rg;\n        vec2 wdir2 = t2D(vec2(0., 0.)).rg;\n        vec2 wdir3 = t2D(vec2(-1., -1.)).rg;\n        vec2 wdir4 = t2D(vec2(0., -1.)).rg;\n        if (length(wdir1) == 0. || length(wdir2) == 0.\n            || length(wdir3) == 0. || length(wdir4) == 0.) {\n            return;\n        }\n        \n        // wdir    --- direction of wall\n        // (this is actually kind of obvious)\n        //\n        // (0, -1) --- down\n        // (0, 1)  --- up\n        // (-1, 0) --- left\n        // (1, 0)  --- right\n        \n        bool r_up = reached(vec2(0., 1.));\n        bool r_down = reached(vec2(0., -1.));\n        bool r_left = reached(vec2(-1., 0.));\n        bool r_right = reached(vec2(1., 0.));\n        bool other_active = false;\n        vec4 other_color = vec4(1000.0);\n        \n        // no wall on the left\n        if (wdir1.y != -1.0 && wdir3.y != 1.0) {\n            other_active = other_active || r_left;\n            if (r_left) {\n                other_color = min(other_color, color_at(vec2(-1.0, 0.0)));\n            }\n        }\n        // no wall on the right\n        if (wdir2.y != -1.0 && wdir4.y != 1.0) {\n            other_active = other_active || r_right;\n            if (r_right) {\n                other_color = min(other_color, color_at(vec2(1.0, 0.0)));\n            }\n        }\n        // no wall on the top\n        if (wdir1.x != 1.0 && wdir2.x != -1.0) {\n            other_active = other_active || r_up;\n            if (r_up) {\n                other_color = min(other_color, color_at(vec2(0.0, 1.0)));\n            }\n        }\n        // no wall on the bottom\n        if (wdir3.x != 1.0 && wdir4.x != -1.0) {\n            other_active = other_active || r_down;\n            if (r_down) {\n                other_color = min(other_color, color_at(vec2(0.0, -1.0)));\n            }\n        }\n        if (other_active) {\n            other_color.r += 1.0;\n            fragColor = other_color;\n        }\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"}]}