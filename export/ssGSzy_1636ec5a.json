{"ver":"0.1","info":{"id":"ssGSzy","date":"1634828484","viewed":364,"name":"Dolphins at sea","username":"sagieL","description":"A silly little shader of dolphins swimming at sea. I mostly wanted to play around with sculpting shapes with SDFs.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","waves","sea","sdf","dolphin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Road to Nowhere - by Sagie Levy, 2023.\n// Email: sagielevy21@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define dChance .15\n#define animSpeed 2.7\n#define scrollSpeed 0.1\n#define maxHeight .8\n#define maxAngle .7\n#define blur 0.03\n#define numLayers 5\n#define dolphinColor vec3(vec3(107, 107, 153) * 1./255.)\n#define seaColor vec3(vec3(128, 143, 255) * 1./255.)\n#define skyColor1 vec3(195, 209, 230) * 1./255.\n#define skyColor2 vec3(222, 244, 255) * 1./255.\n#define hazeColor vec3(1) * .8\n\nfloat ellipse(vec2 p, vec2 ab, float thickness)\n{\n    return smoothstep(-thickness, thickness, -sdEllipse(p, ab));\n}\n\nfloat dolphin(vec2 p, float angle) {\n    p = Rot(angle) * p;\n    \n    float d = 0.;\n    \n    // Body\n    d = max(ellipse(p, vec2(.4, .25), 0.01) - ellipse(p - vec2(0, -0.2), vec2(.5, .25), 0.01), 0.);\n    \n    // Mouth\n    mat2 rotMouth = Rot(0.7);\n    d = max(d, ellipse(rotMouth*(p - vec2(-.35, .025)), vec2(.15, .02), 0.01));\n    \n    // Fin\n    d = max(d, max(ellipse(p - vec2(0.05, .2), vec2(.14, .13), 0.01) - ellipse(p - vec2(0.13, 0.2), vec2(.1, .16), 0.01), 0.));\n    \n    // Flippers\n    d = max(d, max(ellipse(p - vec2(-0.1, .01), vec2(.14, .13), 0.01) - ellipse(p - vec2(-0.06, 0.), vec2(.1, .18), 0.01), 0.));\n\n    // Tail\n    d = max(d, max(ellipse(p - vec2(0.43, -.14), vec2(.1, .16), 0.01) - \n                    ellipse(p - vec2(0.5, -.24), vec2(.19, .18), 0.01) -\n                    ellipse(Rot(0.3)*(p - vec2(0.475, -.24)), vec2(.02, .2), 0.01), 0.));\n                    \n    return d;\n}\n\nfloat SeaHeight(float x, float t) {\n    return sin(x * .3) * .3 + sin(x * 2.145) * .1 + sin(x * .7 + t * 4.) * .06;\n}\n\nvec4 Layer(vec2 uv, float time, float i) {\n    float randLayer = Hash11(i * 13.3);\n    \n    float scale = mix(15., .8, i);\n    float scroll = mix(.3, 3., i);\n    float waves = mix(.1, .8, i);\n    float lower = mix(.13, .4, i);\n    float waveHeight = mix(.3, .8, i);\n    float waveSpeed = mix(.4, .8, i);\n    \n    uv.y += lower; // Decrease height from horizon\n    uv *= scale;\n    \n    float panOffs = time * scrollSpeed * scroll * scale + randLayer * 100.;\n    \n    vec2 dUV = vec2(uv.x + panOffs * .8, uv.y);\n    float id = floor(dUV.x); // Index value of the current box.\n    vec2 luv = vec2(fract(dUV.x) - 0.5, uv.y); // Origin is in the center of each box, in range of [-.5, .5] in x axis.\n    \n    float rand1 = Hash11(id + 14.67 + randLayer);\n    float rand2 = Hash11(rand1 * 4. + 532.54);\n    float rand3 = Hash11(rand2 * 12. + 92.54);\n\n    float t = time * animSpeed + rand1 * 1000.;\n    float heightFactor = sin(t) * maxHeight * mix(1.2, .5, rand3);\n    float angleFactor = cos(t) * maxAngle;\n    \n    vec2 dolphinOffs = vec2(0, .3 + heightFactor);\n    float dolphinScale = 1. + rand3;\n    float shouldAppear = step(1.-dChance, rand2);\n    vec4 dolphinVal = vec4(dolphinColor, dolphin((luv + dolphinOffs) * vec2(dolphinScale), angleFactor) * shouldAppear);\n    \n    vec4 seaVal = vec4(seaColor, smoothstep(blur, -blur, uv.y+SeaHeight(uv.x-panOffs, time * waveSpeed) * waveHeight));\n    vec4 col = mix(dolphinVal, seaVal, seaVal.a);\n    col.rgb = mix(hazeColor, col.rgb, i);\n    \n    return col;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = mix(skyColor2, skyColor1, 4.*uv.y);\n    \n    for (float i = 0.; i < 1.; i += 1. / float(numLayers)) {\n\n        \n        vec4 layer = Layer(uv, iTime, i);\n        col = mix(col, layer.rgb, layer.a);\n    }\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float Hash11(float value) {\n    value = mod(value, 500.); // Limit value to this range otherwise hash gives weird results.\n    return fract(384.545 * sin(value * 34.322 + 143.));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdEllipse(vec2 p, vec2 ab)\n{\n    p = abs(p); \n    if( p.x > p.y ) { p=p.yx;ab=ab.yx; }\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      \n    float m2 = m*m; \n    float n = ab.y*p.y/l;\n    float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0;\n    float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 ) {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    } else {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}","name":"Common","description":"","type":"common"}]}