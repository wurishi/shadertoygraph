{"ver":"0.1","info":{"id":"lljBzK","date":"1516834433","viewed":1479,"name":"Fake volumetric clouds","username":"vchizhov","description":"My first shader posted on here. Some fake (in the sense of not physically realistic in terms of the mathematics/physics) volumetric clouds. The sum = sum*(1-d)+d is from the paper Volume Rendering by Drebin.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fbm","volumetricclouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst vec3 sunDir = normalize(vec3(-0.6f, 0.4f, 0.6f));\n\n// hash and noise by iq\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return 2.0f*mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z)-1.0f;\n}\n\nfloat fbm(in vec3 pos, int layers, float AM, float FM)\n{\n    float sum = 0.0f;\n    float amplitude = 1.0f;\n    for(int i=0;i<layers;++i)\n    {\n        sum += amplitude*noise(pos);\n        amplitude *= AM;\n        pos *= FM;\n    }\n    return sum;\n}\n\nfloat cloud(in vec3 p)\n{\n \t//return 0.01f*noise(10.0f*p);  \n    return 0.01f*fbm(0.9f*vec3(0.2f, 0.2f, 0.3f)*(p+vec3(0.0f, 0.0f, 3.0f*iTime)), 7, 0.5f, 4.0f);\n}\n\nvec2 renderNoise(in vec3 ro, in vec3 rd)\n{\n    float tmin=10.0f;\n    float tmax = 20.0f;\n    float delta = 0.1f;\n    float sum = 0.0f;\n    float t = tmin;\n    for(;t<tmax;t+=delta)\n    {\n        vec3 pos = ro + t*rd;\n        //if(pos.y<-10.0f || pos.y>-1.0f || pos.x>5.0f || pos.x<-5.0f) return vec2(sum, -1.0f);\n        \n        float d = max(0.0f,cloud(pos));\n        sum = sum*(1.0-d)+d;\n        if(sum>0.99f) break;\n    }\n    return vec2(sum, t);\n}\n\nfloat shadeClouds(in vec3 ro, in vec3 rd)\n{\n    float sum =0.0f;\n    float t = 0.0f;\n    float delta = 0.1f;\n    for(int i=0;i<5;++i)\n    {\n        vec3 pos = ro + rd*t;\n        float d = max(0.0f,cloud(pos));\n        sum = sum*(1.0-d)+d;\n        if(sum>0.99f) break;\n        t += delta;\n    }\n    return sum;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    const vec3 sky = vec3(0.4, 0.6, 1.0);\n    vec3 att = vec3(0.2f, 0.5f, 0.9f);\n    vec2 ns = renderNoise(ro, rd);\n    vec3 pos = ro+rd*ns.y;\n    float shad = 1.0f;//0.9f*(1.0f-shadeClouds(pos+sunDir*0.1f, sunDir));\n    float density = ns.x;\n    float inv = (1.0f-density);\n    \n    float w = 1.8f*(0.5f*rd.y+0.5f);\n    vec3 cl = shad*w*1.0f*mix(vec3(1.0f), inv*att, sqrt(density));\n    if(density<0.1f) return mix(sky, cl, max(0.0f, density)*10.0f);\n    //vec3 col = mix(sky, cl, 1.0f-exp(-0.0003*ns.y*ns.y) );\n    //if(ns.y<0.0f) return sky;\n\treturn cl; \n}\n\n#define PI 3.14159265359f\nvec3 render(vec2 ndc, float aspectRatio)\n{\n\t// camera origin\n    vec3 o = vec3(0.0f, 0.0f, 0.0f);\n\t// camera horizontal field of view\n    const float fov = 2.0f*PI / 3.0f;\n    const float scaleX = tan(fov / 2.0f);\n\t// camera right vector\n    vec3 right = vec3(1.0f, 0.0f, 0.0f)*scaleX;\n\t// camera forward vector\n    vec3 forward = vec3(0.0f, 0.0f, 1.0f);\n\t// camera up vector\n    vec3 up = vec3(0.0f, 1.0f, 0.0f)*scaleX*aspectRatio;\n\t// ray direction\n    vec3 rd = normalize(forward + ndc.x*right + ndc.y*up);\n    return render(o, rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ndc = 2.0f*fragCoord.xy / iResolution.xy-1.0f;\n    vec3 col = render(ndc, iResolution.y/iResolution.x);\n    // approximate gamma correction\n    col = sqrt(col);\n\tfragColor = vec4(col,1.0f);\n}","name":"Image","description":"","type":"image"}]}