{"ver":"0.1","info":{"id":"4sKXzc","date":"1465833452","viewed":177,"name":"Quantized Wave","username":"akohdr","description":"Using fract() to quantize propagating planar waves.\nMouse.x provides timebase scrub/shuttle.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","waves"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Andrew Wild - akohdr/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage(out vec4 k,vec2 p){\n    vec2 q,R = iResolution.xy;\n    p = (vec2(.4,.5)-p/R)*sqrt(R);\n    q = max(length(p-fract(p)),\n            length(p+vec2(5,-.5)))\n             - iDate.w+192.*iMouse.xy/R;\n\tk = sin(q.x/vec4(2,3,5,q));\n}\n\n/*\n// just realised clicking char count gives minimal shader, after bit editing....\nvoid mainImage(out vec4 k,vec2 p){\n    vec2 iR = iResolution.xy,\n         uv = p/iR,\n         iM = iMouse.xy/iR;\n    float T = iTime+192.*iM.x;\n    p = (vec2(.4,.5)-uv)*sqrt(iR.x);\n    float q = max(length(p-fract(p)),length(p+vec2(5,-.5)))-T;\n\tk = vec4(sin(q/vec3(2,3,5)),1);\n}\n*/\n\n/*\n// What started off as straight quantization with fract() wandered....\n\nvoid mainImage( out vec4 k, vec2 p ) \n{\n    vec2 iR = iResolution.xy,\n         uv = p/iR,\n    \t iM = iMouse.xy/iR;\n   float T = iTime + 192.*iM.x;\t\t// mouse.x temporal scrubber\n       \n//\tsome of the more interesting moire patterns\n//\tp = iR/(p/iR - .5);\n//\tp *= iR;\n//\tp *= iM;\n//\tp = iR*(p-iR/2. - .5);\n//\tp = 5./(p/iR - .5);\n//\tp /= (p/iR-.5); p *= sqrt(iR.x);    \n\tp = uv;\t\t\t\t\t\t\t\t\t// comment when playing with moire patterns\n    \n\tp = (vec2(.4,.5)-p)*sqrt(iR.x);\n    \n    float q = \n\t\tmax\t\t\t\t\t\t\t\t\t// max/min effectively acts as switch\n//\t\tmin\n        (\n\t\t\tlength( p - fract(p))\t\t\t// produces quantization\n\t\t\t,\n\t\t\tlength( p + vec2(5,-.5))\n        );\n\n// select three periodic functions to apply to RGB fields\n//#define R sin\n//#define R cos\n//#define R tan\n#define R fract\n    \n//#define G sin\n//#define G cos\n//#define G tan\n#define G fract\n\n//#define B sin\n//#define B cos\n//#define B tan\n#define B fract\n\n// By phasing RGB fields with prime factors we guarantee full cycle of spectrum\n#define APPLY_RGB(o,x,r,g,b) vec4(vec3(r(x o 2.),g(x o 3.),b(x o 5.)),1)\n    \n// sign of temporal term dictates inward/outward motion    \n#define  INWARD +T\n#define OUTWARD -T\n    \n    k = APPLY_RGB(\n//\t\t\t+0.*,\t\t\t\t// no prime factors\n//\t\t\t*,\n\t\t\t/,\n                \n//\t         q OUTWARD,\t\t\t// mistake but arguably visually more interesting\n//\t         q INWARD,\n\t         (q OUTWARD),\t\t// brackets ensure op applied to both q and T\n//\t         (q INWARD),\n\n\t\t\tR,G,B\n        \n// alternatively we can use any combination of the three periodic RGB funcs        \n        \n//\t\t\tR,R,R\t// BLK/WHT\n//\t\t\tR,R,G\t// BLU/YEL\n//\t\t\tR,G,R\t// MAG/GRN\n//\t\t\tR,G,G\t// CYN/RED\n\n//\t\t\tR,G,B\n//\t\t\tG,B,R\n//\t\t\tB,R,G\n//\t\t\tR,B,G\n//\t\t\tB,G,R\n//\t\t\tG,R,B\n            \n//\t\t\tR,R,R\n//\t\t\tR,R,G\n//\t\t\tR,R,B\n//\t\t\tR,G,R\n//\t\t\tR,G,G\n//\t\t\tR,G,B\n//\t\t\tR,B,R\n//\t\t\tR,B,G\n//\t\t\tR,B,B\n\n//\t\t\tG,R,R\n//\t\t\tG,R,G\n//\t\t\tG,R,B\n//\t\t\tG,G,R\n//\t\t\tG,G,G\n//\t\t\tG,G,B\n//\t\t\tG,B,R\n//\t\t\tG,B,G\n//\t\t\tG,B,B\n\n//\t\t\tB,R,R\n//\t\t\tB,R,G\n//\t\t\tB,R,B\n//\t\t\tB,G,R\n//\t\t\tB,G,G\n//\t\t\tB,G,B\n//\t\t\tB,B,R\n//\t\t\tB,B,G\n//\t\t\tB,B,B\n\n);\t// APPLY_RGB\n}\n*/","name":"Image","description":"","type":"image"}]}