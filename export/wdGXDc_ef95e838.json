{"ver":"0.1","info":{"id":"wdGXDc","date":"1575287695","viewed":335,"name":"don - Circuit Sandbox","username":"koktszfung","description":"0-9 select component, shown in cell(0,0)\n0:empty 1:wire 2:power 3:oscillating power(click to change period) 4:bridge for overlapping circuit\n5:input for gate 6:output for gate 7:gate(=1) 8:gate(=2) 9:gate(â‰¥2)\nlogic gate detects \"in\" and react through\"out\"","likes":13,"published":1,"flags":48,"usePreview":0,"tags":["interactive","circuit","logicgate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/* display */\n\n#define SHOW_DIR\n#define SHOW_LOGO\n#define SHOW_GRID\n#define T true\n#define F false\nconst int LOGO_SIZE = 5;\n\nvec4 getColGrid(vec4 fragColor, vec2 fragCoord, float period) {\n    ivec2 iFragCoord = ivec2(fragCoord);\n    int iPeriod = int(period);\n    if (iFragCoord.x % iPeriod == 0 || iFragCoord.y % iPeriod == 0) {\n    \tfragColor.rgb = vec3(.4);\n    }\n    return fragColor;\n}\n\n// represent logo by bool grid\nbool[LOGO_SIZE*LOGO_SIZE] getLogo(vec3 rgb) {\n    if (rgb == RGB_WIRE) {\n        return bool[](\n        \tF,F,F,F,F,\n            F,F,F,F,F,\n            F,F,F,F,F,\n            F,F,F,F,F,\n            F,F,F,F,F\n        );\n    } else if (rgb == RGB_POWER) {\n    \treturn bool[](\n        \tF,F,F,F,F,\n            F,F,T,F,F,\n            F,T,T,T,F,\n            F,F,T,F,F,\n            F,F,F,F,F\n        );\n    } else if (rgb == RGB_POWER_OSC) {\n    \treturn bool[](\n        \tT,F,T,F,T,\n            F,F,T,F,F,\n            F,F,T,T,F,\n            F,F,F,F,F,\n            T,F,F,F,T\n        );\n    } else if (rgb == RGB_BRIDGE) {\n    \treturn bool[](\n        \tF,F,T,F,F,\n            F,F,T,F,F,\n            T,F,T,F,T,\n            F,F,T,F,F,\n            F,F,T,F,F\n        );\n    } else if (rgb == RGB_GATE_IN) {\n    \treturn bool[](\n        \tF,F,F,F,F,\n            F,T,T,T,F,\n            F,F,T,F,F,\n            F,T,T,T,F,\n            F,F,F,F,F\n        );\n    } else if (rgb == RGB_GATE_OUT) {\n    \treturn bool[](\n        \tF,F,F,F,F,\n            F,T,T,T,F,\n            F,T,F,T,F,\n            F,T,T,T,F,\n            F,F,F,F,F\n        );\n    } else if (rgb == RGB_GATE_E1) {\n    \treturn bool[](\n        \tF,F,F,F,T,\n            T,T,F,T,T,\n            F,F,F,F,T,\n            T,T,F,F,T,\n            F,F,F,T,T\n        );\n    } else if (rgb == RGB_GATE_E2) {\n    \treturn bool[](\n        \tF,F,F,T,T,\n            T,T,F,F,F,\n            F,F,F,T,T,\n            T,T,F,T,F,\n            F,F,F,T,T\n        );\n    } else if (rgb == RGB_GATE_GE2) {\n    \treturn bool[](\n        \tT,F,F,T,T,\n            F,T,F,F,F,\n            T,F,F,T,T,\n            F,F,F,T,F,\n            T,T,F,T,T\n        );\n    } else {\n    \treturn bool[](\n        \tF,F,F,F,F,\n            F,F,F,F,F,\n            F,F,F,F,F,\n            F,F,F,F,F,\n            F,F,F,F,F\n        );\n    }\n}\n\nbool getIsLogo(bool[LOGO_SIZE*LOGO_SIZE] logo, vec2 uv) {\n\tuv.y = 1. - uv.y;  // flip y\n    ivec2 ij = ivec2(uv * float(LOGO_SIZE));\n    return logo[ij.y*LOGO_SIZE+ij.x];\n}\n\nvec4 getColProcessed(vec4 col, vec2 uv) {\n    vec4 fragColor = col;\n    if (col.a != -1.) fragColor.rgb *= 1.5;\n    \n    #ifdef SHOW_DIR\n    if (col.a == 0. && uv.y > .7\n        || col.a == 1. && uv.x > .7\n        || col.a == 2. && uv.y < .3\n        || col.a == 3. && uv.x < .3) {\n        fragColor = vec4(1);\n    }\n    #endif\n\n    #ifdef SHOW_LOGO\n    if (getIsLogo(getLogo(col.rgb), uv)) {\n    \tfragColor = vec4(0);\n    }\n    #endif\n    \n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 ij = fragCoord/CELL_SIZE;  // index of the cell\n    vec2 uv = mod(ij, vec2(1));  // remainder in the cell\n    \n    if (ivec2(ij) == ivec2(0)) {\n        vec4 colPicked = vec4(texelFetch(iChannel1, ivec2(0), 0).rgb, -1.);  // component selected\n    \tfragColor = getColProcessed(colPicked, uv);\n        return;\n    }\n\n    vec4 col = vec4(texelFetch(iChannel0, ivec2(ij), 0));\n    fragColor = getColProcessed(col, uv);\n    \n    #ifdef SHOW_GRID\n    fragColor = getColGrid(fragColor, fragCoord, CELL_SIZE);\n\t#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n/* logic for current to flow */\n\nvec2 getAdjOffset(int i) {\n    vec2 offset;\n    switch (i) {\n        case 0: offset = vec2( 0,  1); break;\n        case 1: offset = vec2( 1,  0); break;\n        case 2: offset = vec2( 0, -1); break;\n        case 3: offset = vec2(-1,  0); break;\n        default: offset = vec2(0); break;\n    }\n    return offset;\n}\n\nbool getIsGate(vec3 rgb) {\n\treturn rgb == RGB_GATE_E1  || rgb == RGB_GATE_E2 || rgb == RGB_GATE_GE2;\n}\n\nbool getGateLogic(int x, vec3 rgbGate) {  // define logic gate\n\tif (rgbGate == RGB_GATE_E1) {\n    \treturn x == 1;\n    } else if (rgbGate == RGB_GATE_E2) {\n    \treturn x == 2;\n    } else if (rgbGate == RGB_GATE_GE2) {\n    \treturn x >= 2;\n    } else {\n    \treturn false;\n    }\n}\n\nvec4 getColThumbnail(vec2 fragCoord) {\n\tivec2 ij = ivec2(fragCoord);\n    if (ij.x > 10 || ij.y > 8) return vec4(0,0,0,-1);\n    ij.y = 7 - ij.y;\n    int[70] board = int[](\n    \t0,3,1,1,1,1,1,5,0,0,\n        0,0,0,0,0,1,0,8,6,1,\n        0,3,1,1,1,4,1,5,0,0,\n        0,0,0,1,0,1,0,0,0,0,\n        0,0,0,1,0,1,1,5,0,0,\n        0,0,0,1,0,0,0,7,6,1,\n        0,0,0,1,1,1,1,5,0,0\n    );\n    vec4 col = vec4(getRgb(board[ij.y*10+ij.x]), -1.);\n    if (ij == ivec2(1, 0)) {\n    \tcol.a = 3.;\n    } else if (ij == ivec2(1, 2)) {\n    \tcol.a = 1.;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n    \tfragColor = getColThumbnail(fragCoord);\n        return;\n    }\n    \n    vec4 colSave = texelFetch(iChannel0, ivec2(fragCoord), 0);  // color saved in previous frame\n\n    if (length(fragCoord - iMouse.xy / CELL_SIZE) < .5) {\n        if (iMouse.z > 0.){\n            fragColor = vec4(texelFetch(iChannel1, ivec2(0), 0).rgb, -1.);  // draw color chosen in buffer B\n            if (colSave.rgb == RGB_POWER_OSC) fragColor.a = mod(colSave.a + .25, 4.);\n            return;\n        } else {\n            fragColor = colSave;\n            if (fragColor.rgb == RGB_POWER_OSC) fragColor.a = floor(fragColor.a);\n            return;\n        }\n    }\n\n    if (iFrame % FRAME_PER_UPDATE != 0) {\n    \tfragColor = colSave;\n        return;\n    }\n    \n    fragColor = colSave;\n    fragColor.a = -1.;\n    \n    int iStart = (colSave.a == -1.) ? 0 : int(colSave.a);  // choose direction where power is found previously\n    if (colSave.rgb == RGB_WIRE || colSave.rgb == RGB_BRIDGE || colSave.rgb == RGB_GATE_IN) {\n    // Wire and Gate Input, search route to power\n        int iResult;  // index for adjacent direction\n        int dist = INT_MAX;\n        for (int i = iStart; i < iStart + 4; i++) {\n            vec2 dirSearch = getAdjOffset(i % 4), posSearch = fragCoord + dirSearch;\n            vec3 rgbPrev = colSave.rgb;\n            for (int j = 0; j < SIGNAL_LEN; j++) {\n                vec4 colSearch = texelFetch(iChannel0, ivec2(posSearch), 0);\n                if (colSearch.rgb == RGB_POWER\n                    || colSearch.rgb == RGB_POWER_OSC && mod(iTime, (colSearch.a+1.)) > (colSearch.a+1.)*.5) {\n                // Next to Power\n                    if (j < dist) {\n                        iResult = i % 4;\n                        dist = j;\n                        break;\n                    }\n                } else if (colSearch.a != -1.){\n                // Have route to power\n                    if ( colSearch.rgb == RGB_WIRE\n                        || colSearch.rgb == RGB_GATE_IN && (rgbPrev == RGB_GATE_OUT || getIsGate(rgbPrev))\n                        || getIsGate(colSearch.rgb) && rgbPrev == RGB_GATE_OUT\n                        || colSearch.rgb == RGB_GATE_OUT) {\n                        dirSearch = getAdjOffset(int(colSearch.a));\n                        posSearch += dirSearch;  // search in direction of current\n                    } else if (colSearch.rgb == RGB_BRIDGE) {\n                        posSearch += dirSearch;  // search in direction to bridge\n                    }\n                }\n                rgbPrev = colSearch.rgb;\n            }\n        }\n        fragColor.a = dist == INT_MAX ? -1. : float(iResult);\n    } else if (colSave.rgb == RGB_POWER_OSC) {\n    \tfragColor.a = colSave.a;\n    } else if (getIsGate(colSave.rgb)){\n    // Gate\n    \tint numOn = 0, iResult = -1;\n        for (int i = 3; i >= 0; i--) {\n            vec4 colAdj = texelFetch(iChannel0, ivec2(fragCoord + getAdjOffset(i % 4)), 0);\n            if (colAdj.rgb == RGB_GATE_IN && colAdj.a != -1.) {\n            // found Gate Input that is turned on\n                iResult = i;\n                numOn++;\n            }\n        }\n        if (getGateLogic(numOn, colSave.rgb)) {\n        // truth value of Gate is true\n            fragColor.a = float(iResult);\n        }\n    } else if (colSave.rgb == RGB_GATE_OUT){\n    // Gate Output\n    \tfor (int i = iStart; i < iStart + 4; i++) {\n            vec4 colAdj = texelFetch(iChannel0, ivec2(fragCoord + getAdjOffset(i % 4)), 0);\n            if (colAdj.a != -1.\n                && (colAdj.rgb == RGB_GATE_IN || getIsGate(colAdj.rgb))) {\n            // found Gate that is turned on\n                fragColor.a = float(i % 4);\n                break;\n            }\n        }\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n/* keyboard */\n\nbool getKeyPressed(int keyCode) {\n\treturn texelFetch(iChannel1, ivec2(keyCode, 1), 0).r > 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0)){\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        if (getKeyPressed(8)) fragColor = vec4(0,0,0,-1);  // backspace\n        for (int i = 0; i < 10; i++) {\n            if (getKeyPressed(i+48)) {\n            // pressed number\n                fragColor.rgb = getRgb(i);\n            \treturn;\n            }\n        }\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n/* global variable */\n\nconst float CELL_SIZE = 25.;\nconst int FRAME_PER_UPDATE = 1;\n\nconst int INT_MAX = 2147483647;\nconst int SIGNAL_LEN = 20;\nconst int POWER_OSC_PERIOD = 30;\n\nconst vec3 RGB_WIRE = vec3(.6, .2, .2);\nconst vec3 RGB_POWER = vec3(.2, .8, .2);\nconst vec3 RGB_POWER_OSC = vec3(.4, .7, .1);\nconst vec3 RGB_BRIDGE = vec3(1, 1, 1);\nconst vec3 RGB_GATE_IN = vec3(0, .3, .3);\nconst vec3 RGB_GATE_OUT = vec3(0, .65, .65);\nconst vec3 RGB_GATE_E1 = vec3(.1, .1, .7);\nconst vec3 RGB_GATE_E2 = vec3(.2, .2, .7);\nconst vec3 RGB_GATE_GE2 = vec3(.3, .3, .7);\n\nvec3 getRgb(int i) {\n    vec3 rgb;\n    switch (i) {\n        case 1: rgb = RGB_WIRE; break;\n        case 2: rgb = RGB_POWER; break;\n        case 3: rgb = RGB_POWER_OSC; break;\n        case 4: rgb = RGB_BRIDGE; break;\n        case 5: rgb = RGB_GATE_IN; break;\n        case 6: rgb = RGB_GATE_OUT; break;\n        case 7: rgb = RGB_GATE_E1; break;\n        case 8: rgb = RGB_GATE_E2; break;\n        case 9: rgb = RGB_GATE_GE2; break;\n        default: rgb = vec3(0); break;\n    }\n    return rgb;\n}\n","name":"Common","description":"","type":"common"}]}