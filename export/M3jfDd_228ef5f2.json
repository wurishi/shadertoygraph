{"ver":"0.1","info":{"id":"M3jfDd","date":"1730122010","viewed":26,"name":"Segmented/Demented JackO'Lantern","username":"MackFitz","description":"A pumpkin crudely carved with code by a novice that makes up with brutality what he lacks in knowledge. Happy Halloween!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["animation","halloween","pumpkin","spooktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define RES iResolution\n#define PT iMouse\n\nfloat sdSeg(in vec3 p, in vec3 a, in vec3 b) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n  return length(pa - ba * h);\n}\n\nfloat map(vec3 p, out int partID) {\n  float turn = radians(-45.0),\n        cosTurn = cos(turn + cos(iTime)/2.5),\n        sinTurn = sin(turn + cos(iTime)/2.5);\n\n  // pumpkin shakes its noggin\n  mat3 rotationMatrix = mat3(\n    cosTurn, 0.0, -sinTurn,\n    0.0, 1.0, 0.0,\n    sinTurn, 0.0, cosTurn\n  );\n\n  p = rotationMatrix * p;\n  \n  vec3 resetP = p;\n\n  vec3 pA = vec3(0.),\n       pB = pA;\n\n  float rAngle = atan(p.z, p.x), // Calculate the angle at the center in the xz-plane\n        rAdd = 0.02 * abs(cos(rAngle * 6.0)), // Modulate the radius based on the angle\n        rP = 1.0 + rAdd;\n  p.xz *= .85;\n  \n  float pumpkin = sdSeg(p, pA, pB) - rP;\n\n  partID = 1; // Default to pumpkin\n\n  vec3 iA = pA, iB = iA;\n  float inside = sdSeg(p, iA, iB) - 0.9;\n\n  p = resetP;\n\n  vec3 e1a = pA, e1b = vec3(-0.45, 0.75, -1);\n  float eye1 = sdSeg(p, e1a, e1b) - 0.25;\n\n  vec3 e2a = pA, e2b = vec3(0.45, 0.75, -1);\n  float eye2 = sdSeg(p, e2a, e2b) - 0.3;\n\n  p.xz *= .6;\n\n  vec3 fA = vec3(0.07 * (1.0 - cos(iTime)), 0.55, 0),\n       fB = vec3(0.07 * (1.0 - cos(iTime)), 1.0, -0.45);\n  float frown = sdSeg(p, fA, fB) - 0.4;\n\n  p = resetP;\n  \n  p.xz *= .5; // set/reset combo\n\n  vec3 l1a = pA, l1b = vec3(0, 0.1, -0.5);\n  float lip1 = sdSeg(p, l1a, l1b) - 0.45;\n\n  vec3 l2a = vec3(-0.1, 1, 0), l2b = vec3(-0.1, 0.75, -0.5);\n  float lip2 = sdSeg(p, l2a, l2b) - 0.65,\n        mouth = max(lip1, -lip2);\n\n  p = resetP; // reset\n\n  vec3 hA = vec3(0, 1, 0), hB = pB;\n  float topHole = sdSeg(p, hA, hB) - 0.33;\n\n  inside = min(inside, topHole);\n\n  p.yz /= 2.0;\n\n  vec3 t1a = vec3(-0.1, 0.1, 0), t1b = t1a;\n  t1b.z = -4.0;\n  float tooth1l = sdSeg(p, t1a, t1b) - 0.2;\n\n  vec3 t1c = t1a, t1d = t1b;\n  t1c.x = -t1a.x, t1d.x = -t1b.x;\n  float tooth1r = sdSeg(p, t1c, t1d) - 0.2;\n\n  vec3 t2a = vec3(0.45, 0.1, 0), t2b = t2a;\n  t2b.z = -4.0;\n  float tooth2l = sdSeg(p, t2a, t2b) - 0.2;\n\n  vec3 t2c = t2a, t2d = t2b;\n  t2c.x -= 0.15, t2d.x = -t2b.x;\n  float tooth2r = sdSeg(p, t2c, t2d) - 0.2;\n\n  vec3 t3a = t2a, t3b = t3a;\n  t3a.x = -t2c.x;\n  t3b.z = -4.0;\n  float tooth3l = sdSeg(p, t3a, t3b) - 0.2;\n\n  vec3 t3c = t3a, t3d = t3b;\n  t3c.x = -t2a.x, t3d.x = -t2b.x;\n  float tooth3r = sdSeg(p, t3c, t3d) - 0.2;\n\n  vec3 t4a = vec3(0.75, 0.1, 0), t4b = t4a;\n  t4b.z = -4.0;\n  float tooth4l = sdSeg(p, t4a, t4b) - 0.2;\n\n  vec3 t4c = t4a, t4d = t4b;\n  t4c.x -= 0.15, t4d.x = -t4b.x;\n  float tooth4r = sdSeg(p, t4c, t4d) - 0.2;\n\n  vec3 t5a = t4a, t5b = t4a;\n  t5a.x = -t4c.x;\n  t5b.z = -4.0;\n  float tooth5l = sdSeg(p, t5a, t5b) - 0.2;\n\n  vec3 t5c = t5a, t5d = t5b;\n  t5c.x = -t4a.x, t5d.x = -t4b.x;\n  float tooth5r = sdSeg(p, t5c, t5d) - 0.2;\n\n  float teeth = min(\n    max(tooth5l, tooth5r),\n    min(\n      min(max(tooth1l, tooth1r), max(tooth2l, tooth2r)),\n      min(max(tooth3l, tooth3r), max(tooth4l, tooth4r))\n    )\n  );\n\n  p = resetP; //reset\n\n  float result = max(\n    pumpkin, -min(\n      min(\n        max(mouth, -teeth), inside\n        ),\n      max(\n        min(eye1, eye2),\n        -frown)\n      )\n    );\n\n  if (result == pumpkin) {\n    partID = 1; // Outer pumpkin\n  } else {\n    partID = 2; // Carved parts\n  }\n\n  return result;\n}\n\nvec3 norm(vec3 p) {\n  float h = 1e-3;\n  vec2 k = vec2(-1, 1);\n  int dummyID; // Dummy variable to satisfy the out parameter requirement\n  return normalize(\n    k.xyy * map(p + k.xyy * h, dummyID) +\n    k.yxy * map(p + k.yxy * h, dummyID) +\n    k.yyx * map(p + k.yyx * h, dummyID) +\n    k.xxx * map(p + k.xxx * h, dummyID)\n  );\n}\n\nfloat raymarch(inout vec3 p, vec3 rd, out int partID) {\n  float dd = 0.0;\n  for (float i = 0.0; i < 100.0; i++) {\n    float d = map(p, partID);\n    if (d < 1e-3 || dd > 5.) break;\n    p += rd * d;\n    dd += d;\n  }\n  return dd;\n}\n\nvec3 render(vec3 p, vec3 rd) {\n  int partID;\n  float d = raymarch(p, rd, partID);\n  vec3 col = vec3(0);\n\n  if (d < 5.) {\n    vec3 n = norm(p),\n    lp1 = vec3(-3, 3, 0), // Original light position\n    lp2 = -lp1*10., // Opposite light position\n    l1 = normalize(lp1 - p),\n    l2 = normalize(lp2 - p);\n    float diffuse1 = clamp(dot(l1, n), 0., 1.),\n    diffuse2 = clamp(dot(l2, n), 0., 1.),\n    reflective1 = clamp(dot(reflect(rd, n), l1), .0, 1.0),\n    reflective2 = clamp(dot(reflect(rd, n), l2), .0, 1.0);\n    if (partID == 1) {\n      col += (diffuse1 + pow(reflective1, 12.)); // Original light\n      col += (diffuse2 + pow(reflective2, 32.))*vec3(.5,2.,2.); // Opposite light\n      col = mix(col, vec3(.5, -.5, -1.25), .5);\n    } else if (partID == 2) {\n      col += diffuse1; // Original light\n      col = mix(col, vec3(4.5, 2.5, 0), .2);\n    }\n  } else {\n    col += vec3(0);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy - .5 * RES.xy) / RES.y;\n\n  float angleY = PT.z > 0. ? (PT.y / RES.y * 2. - 1.)*PI*-.5 : .5*(1. + cos(iTime/5.)),\n        camR = -2.;  // Rotate around the x- and y-axis based on mouse position\n  vec3 target = vec3(0.0); // Center of the cube\n\n  vec3 ro = vec3(\n    cos(angleY/-3.),\n    sin(angleY/-3.),\n    cos(angleY/-3.)\n    )*camR;\n\n  vec3 fwd = normalize(target - ro),\n      right = normalize(cross(vec3(0., 1., 0.), fwd)),\n      up = cross(fwd, right),\n      rd = normalize(fwd + uv.x * right + uv.y * up);\n\n  float t = 0.0; // Total distance travelled\n  vec3 p = ro, col = render(ro, rd);\n  fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}