{"ver":"0.1","info":{"id":"dtVyzy","date":"1700380475","viewed":158,"name":" beautiful in space","username":"nayk","description":"stars, space, diamond, univese","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["space","diamond","stars","univese"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iterations 18\n#define formuparam 0.530\n#define time cos(time*.2)\n#define volsteps 18\n#define stepsize 0.2\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.01\n\n#define brightness 0.0015\n#define darkmatter 0.400\n#define distfading 0.760\n#define saturation 0.800\n#define rot(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n#define L(q) length(max(abs(q.zx), abs(q.y)) - .2) - .01\n\n#define DELTA\t\t\t\t0.001\n#define RAY_COUNT\t\t\t5\n#define RAY_LENGTH_MAX\t\t100.0\n#define RAY_STEP_MAX\t\t50\n#define LIGHT\t\t\t\tvec3 (1.0, 1.0, -1.0)\n#define REFRACT_FACTOR\t\t0.6\n#define REFRACT_INDEX\t\t1.2 // 2.417 for real diamonds... but it would require RAY_COUNT to be increased (because of total internal reflections)\n#define AMBIENT\t\t\t\t0.2\n#define SPECULAR_POWER\t\t3.0\n#define SPECULAR_INTENSITY\t0.5\n#define FADE_POWER\t\t\t1.0\n#define M_PI\t\t\t\t3.1415926535897932384626433832795\n#define GLOW_FACTOR\t\t\t0.5\n#define LUMINOSITY_FACTOR\t2.0\n\n//#define ATAN2 // Comment this to use the original atan function\n\nmat3 mRotate (in vec3 angle) {\n\tfloat c = cos (angle.x);\n\tfloat s = sin (angle.x);\n\tmat3 rx = mat3 (1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);\n\n\tc = cos (angle.y);\n\ts = sin (angle.y);\n\tmat3 ry = mat3 (c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);\n\n\tc = cos (angle.z);\n\ts = sin (angle.z);\n\tmat3 rz = mat3 (c, s, 0.0, -s, c, 0.0, 0.0, 0.0, 1.0);\n\n\treturn rz * ry * rx;\n}\n\nvec3 vRotateY (in vec3 p, in float angle) {\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn vec3 (c * p.x - s * p.z, p.y, c * p.z + s * p.x);\n}\n\n#ifndef ATAN2\n#define atan2 atan\n#else\nfloat atan2 (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tt3 = t1 > t2 ? M_PI / 2.0 - t3 : t3;\n\tt3 = x < 0.0 ? M_PI - t3 : t3;\n\tt3 = y < 0.0 ? -t3 : t3;\n\treturn t3;\n}\n\nfloat atan2_nobranch (in float y, in float x) {\n\n\t// From http://www.deepdyve.com/lp/institute-of-electrical-and-electronics-engineers/full-quadrant-approximations-for-the-arctangent-function-tips-and-V6yJDoI0iF\n\t// atan (x) = x / (1 + 0.28086 x^2)\n\n\tfloat t1 = abs (y);\n\tfloat t2 = abs (x);\n\tfloat t3 = min (t1, t2) / max (t1, t2);\n\tt3 = t3 / (1.0 + 0.28086 * t3 * t3);\n\tfloat t4 = M_PI / 2.0 - t3;\n\tt3 = step (0.0, t2 - t1) * (t3 - t4) + t4;\n\tt4 = M_PI - t3;\n\tt3 = step (0.0, x) * (t3 - t4) + t4;\n\tt3 = step (0.0, y) * (t3 + t3) - t3;\n\treturn t3;\n}\n#endif\n\nvec3 normalTopA = normalize (vec3 (0.0, 1.0, 1.4));\nvec3 normalTopB = normalize (vec3 (0.0, 1.0, 1.0));\nvec3 normalTopC = normalize (vec3 (0.0, 1.0, 0.8));\nvec3 normalBottomA = normalize (vec3 (0.0, -1.0, 1.6));\nvec3 normalBottomB = normalize (vec3 (0.0, -1.0, 2.0));\nvec3 k;\nfloat getDistance (in vec3 p) {\n\tfloat repeat = 20.0;\n\tvec3 q = p + repeat * 0.5;\n\tk = floor (q / repeat);\n\tq -= repeat * (k + 0.5);\n\tp = mRotate (k + iTime) * q;\n\n\tfloat topCut = p.y - 1.1;\n\tfloat angleStep = M_PI / max (1.0, abs (4.0 + k.x + 2.0 * k.y + 4.0 * k.z));\n\tfloat angle = angleStep * (0.5 + floor (atan2 (p.x, p.z) / angleStep));\n\tq = vRotateY (p, angle);\n\tfloat topA = dot (q, normalTopA) - 2.0;\n\tfloat bottomA = dot (q, normalBottomA) - 2.0;\n\tfloat topC = dot (q, normalTopC) - 1.8;\n\tq = vRotateY (p, -angleStep * 0.5);\n\tangle = angleStep * floor (atan2 (q.x, q.z) / angleStep);\n\tq = vRotateY (p, angle);\n\tfloat bottomB = dot (q, normalBottomB) - 1.95;\n\tfloat topB = dot (q, normalTopB) - 1.92;\n\n\treturn max (topCut, max (topA, max (topB, max (topC, max (bottomA, bottomB)))));\n}\n\nvec3 getFragmentColor (in vec3 origin, in vec3 direction) {\n\tvec3 lightDirection = normalize (LIGHT);\n\tvec2 delta = vec2 (DELTA, 0.0);\n\n\tvec3 fragColor = vec3 (0.0, 0.0, 0.0);\n\tfloat intensity = 1.0;\n\n\tfloat distanceFactor = 1.0;\n\tfloat refractionRatio = 1.0 / REFRACT_INDEX;\n\tfloat rayStepCount = 0.0;\n\tfor (int rayIndex = 0; rayIndex < RAY_COUNT; ++rayIndex) {\n\n\t\t// Ray marching\n\t\tfloat dist = RAY_LENGTH_MAX;\n\t\tfloat rayLength = 0.0;\n\t\tfor (int rayStep = 0; rayStep < RAY_STEP_MAX; ++rayStep) {\n\t\t\tdist = distanceFactor * getDistance (origin);\n\t\t\tfloat distMin = max (dist, DELTA);\n\t\t\trayLength += distMin;\n\t\t\tif (dist < 0.0 || rayLength > RAY_LENGTH_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\torigin += direction * distMin;\n\t\t\t++rayStepCount;\n\t\t}\n\n\t\t// Check whether we hit something\n\t\tvec3 backColor = vec3 (0.0, 0.0, 0.1 + 0.2 * max (0.0, dot (-direction, lightDirection)));\n\t\tif (dist >= 0.0) {\n\t\t\tfragColor = fragColor * (1.0 - intensity) + backColor * intensity;\n\t\t\tbreak;\n\t\t}\n\n\t\t// Get the normal\n\t\tvec3 normal = normalize (distanceFactor * vec3 (\n\t\t\tgetDistance (origin + delta.xyy) - getDistance (origin - delta.xyy),\n\t\t\tgetDistance (origin + delta.yxy) - getDistance (origin - delta.yxy),\n\t\t\tgetDistance (origin + delta.yyx) - getDistance (origin - delta.yyx)));\n\n\t\t// Basic lighting\n\t\tvec3 reflection = reflect (direction, normal);\n\t\tif (distanceFactor > 0.0) {\n\t\t\tfloat relfectionDiffuse = max (0.0, dot (normal, lightDirection));\n\t\t\tfloat relfectionSpecular = pow (max (0.0, dot (reflection, lightDirection)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n\t\t\tfloat fade = pow (1.0 - rayLength / RAY_LENGTH_MAX, FADE_POWER);\n\n\t\t\tvec3 localColor = max (sin (k * k), 0.2);\n\t\t\tlocalColor = (AMBIENT + relfectionDiffuse) * localColor + relfectionSpecular;\n\t\t\tlocalColor = mix (backColor, localColor, fade);\n\n\t\t\tfragColor = fragColor * (1.0 - intensity) + localColor * intensity;\n\t\t\tintensity *= REFRACT_FACTOR;\n\t\t}\n\n\t\t// Next ray...\n\t\tvec3 refraction = refract (direction, normal, refractionRatio);\n\t\tif (dot (refraction, refraction) < DELTA) {\n\t\t\tdirection = reflection;\n\t\t\torigin += direction * DELTA * 2.0;\n\t\t} else {\n\t\t\tdirection = refraction;\n\t\t\tdistanceFactor = -distanceFactor;\n\t\t\trefractionRatio = 1.0 / refractionRatio;\n\t\t}\n\t}\n\n\t// Return the fragment color\n\treturn fragColor * LUMINOSITY_FACTOR + GLOW_FACTOR * rayStepCount / float (RAY_STEP_MAX * RAY_COUNT);\n}\nfloat beautiful_and_generous_and_kind_and_affectionate_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoomFactor = 0.5 + iTime / iResolution.x;\n\n\t//get coords and direction\n\tvec2 uv=fragCoord.xy/iResolution.xy*zoomFactor-.5;\n\t\n\tvec3 dir=vec3(uv*zoom,tan(.3)*10.0);\n\t \n     uv *= 1.0 * ( cos(iTime * 2.0) -2.5);\n    // anim between 0.9 - 1.1\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;    \n\n\tfloat a2=speed+.5;\n\tfloat a1=0.0;\n\tmat2 rot1=mat2(cos(a1),tan(a1),-sin(a1),cos(a1));\n\tmat2 rot2=rot1;//mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n    vec4 o =fragColor;\n    vec2 u =fragCoord;\n\tvec3 R = iResolution, q, k;\n         u = (u - R.xy / 2.) / R.y;\n     vec2 frag = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 direction = normalize (vec3 (frag, 2.0));\n\t\n\t// Set the camera\n\tvec3 origin = vec3 ((15.0 * cos (iTime * 0.1)), 10.0 * sin (iTime * 0.2), 15.0 * sin (iTime * 0.1));\n\tvec3 forward = -origin;\n\tvec3 up = vec3 (sin (iTime * 0.3), 2.0, 0.0);\n\tmat3 rotation;\n\trotation [2] = normalize (forward);\n\trotation [0] = normalize (cross (up, forward));\n\trotation [1] = cross (rotation [2], rotation [0]);\n\tdirection = rotation * direction;    o *= 0.; \n    fragColor = vec4 (getFragmentColor (origin, direction), 1.0);\n\n    float d, ss, s2, f, i, j, \n          t = iTime * .2, e = 1e-2;\n    \n    while(i++ < 39.) {\n        q = vec3(d * u, d), \n        \n        q.xz *= rot(cos(t)); \n        q.yz *= rot(t); \n        q.z -= 2.*t;\n        \n        k = floor(q) + .5;\n        q = fract(q) - .5; \n         \n        q.yz *= rot(-t); \n        q.xz *= rot(-cos(t)); \n        q.xy *= rot(cos(k.x+k.y+k.z)); \n        \n        s2 = L(q) - .05;\n        \n        s2 = abs(s2);\n        \n        f = 1. - s2 / e, \n        \n        o += f > .01 \n            ? vec4(1) * f / d * i / 210. \n            : vec4(0);\n            \n        d += max(s2, e / 5.);\n    }\n\t\n\tvec3 from=vec3(0.,0.,0.)*d+direction*fragColor.xyz;\n\tfrom+=vec3((cos(.15),.152,-2.));\n\tuv.x+=0.5*cos(iTime*0.21);\nuv.y+=0.5*sin(iTime*0.21);\n\tfrom.x-=iTime / iResolution.x;\n\tfrom.y-=iTime / iResolution.y;\n\t\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t//volumetric rendering\n\tfloat s=.4,fade=.2;\n\tvec3 v=vec3(0.8);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam;\n             p.xy*=mat2(cos(iTime*0.005),sin(iTime*0.005),-sin(iTime*0.005),cos(iTime*0.005));// the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\n\t\ta*=a*a*2.; // add contrast\n\t\tif (r>3) fade*=0.1; // dark matter, don't render near\n\t\t//v+=vec3(dm,dm*.5,0.);\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n    \n\tfragColor = vec4(v*.03,1.);\n        fragColor*= vec4(beautiful_and_generous_and_kind_and_affectionate_star(uv,anim) * vec3(0.35,0.2,1.25), 1.0);\n}","name":"Image","description":"","type":"image"}]}