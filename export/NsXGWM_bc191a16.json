{"ver":"0.1","info":{"id":"NsXGWM","date":"1616006441","viewed":51,"name":"My first stupid raymarching demo","username":"Dubko","description":"Currently, I am tryin to put some things together for school's project. Well, hopefully it will become more interesting over time.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int g_maxIterations    = 64;\nconst float g_eps            = 0.001;\n\nconst int coloringMode       = 0;\n\nconst float roughness        = 0.7;\nconst float ambientRatio     = 0.0;\nconst float shininess        = 20.0;\nconst float specularity      = 0.3;\n\nconst vec3  albedoColor      = vec3(1.0,1.0,1.0);\nconst vec3  sunColor         = vec3(1.0,1.0,1.0);\n\n\nconst float floorElevation   = -2.0;\nconst float farPlane         = 100.0;\nconst float fogStartPlane    = 50.0;\nconst vec3  fogColor         = vec3(0.2,0.2,0.7);\n\nconst vec3  floorAColor      = vec3(1.0);\nconst vec3  floorBColor      = vec3(0.0);\nconst float floorThickness   = 0.99;\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos)-radius;\n}\n\nfloat sphereModulated(vec3 pos, float radius)\n{\n    pos.x += 0.1*(sin(iTime*pos.y*pos.x*3.0));\n    return length(pos)-radius;\n}\n\nfloat cube(vec3 pos, float radius)\n{\n    return max(abs(pos.x),max(abs(pos.y),abs(pos.z)))-radius;\n}\n\nfloat unite(float a, float b)\n{\n    return min(a, b);\n}\n\nfloat uniteSmooth(float a, float b)\n{\n    return smoothstep(a,b, min(0.0,max(1.0,a/(a+b))));\n}\n\nfloat intersect(float a, float b)\n{\n    return max(a, b);\n}\n\nfloat ground(vec3 position, float elevation)\n{\n    return position.y - elevation;\n}\n\nfloat object(vec3 pos)\n{\n    pos.y += sin(cos(tan(iTime*3.0)*pos.x)+pos.y*0.3*20.0)*0.3;\n    pos.x += sin(pos.y*pos.x*2.0);\n    pos.y += sin(iTime);\n    float b = sphere(pos+vec3(0.0,0.0,0.0), 1.0);\n    float c = sphere(pos+vec3(1.0,0.0,0.0), 1.0);\n    return intersect(b,c);\n}\n\nfloat df(vec3 pos)\n{\n    float gd = ground(pos, floorElevation);\n    //float a = sphere(pos, 1.0);\n    //float ab = sphere(pos+vec3(0.5+sin(iTime),0.0,sin(iTime)*-0.0), 1.0);\n    \n    //float d = unite(a,b);\n    return unite(gd,object(pos));\n    //return uniteSmooth(ab,a);\n}\n\nfloat threshold(float val, float thres)\n{\n    return float(val > thres);\n}\n\nvec3 colorize(vec3 pos)\n{\n    float distToFloor = max(0.0, min(1.0, 10.0*g_eps+pos.y-(floorElevation)));\n    float checkerColor = clamp(0.0,1.0,threshold(sin(6.0*pos.x),floorThickness)+\n                                       threshold(sin(6.0*pos.z),floorThickness));\n    return mix(mix(floorAColor, floorBColor, checkerColor),\n               vec3(1.0,0.8,0.5),\n               distToFloor);\n}\nvec2 rayMarchWithIterations(vec3 o, vec3 d)\n{\n    int currentIterations = 0;\n    float t = 0.0;\n    while((g_maxIterations-currentIterations) > 0)\n    {\n        float closestDistance = df(o+t*d);\n        if(closestDistance < g_eps)\n        {\n            return vec2(t+closestDistance, currentIterations);\n        }\n        t += closestDistance;\n        currentIterations = currentIterations + 1;\n    }\n    return vec2(t, currentIterations);\n}\n\nfloat rayMarch(vec3 o, vec3 d)\n{\n    int maximumIterations = g_maxIterations;\n    float t = 0.0;\n    while(maximumIterations > 0)\n    {\n        float closestDistance = df(o+t*d);\n        if(closestDistance < g_eps)\n        {\n            return t+closestDistance;\n        }\n        t += closestDistance*0.5;\n        maximumIterations = maximumIterations - 1;\n    }\n    return t;\n}\n\nvec3 normalVector(vec3 o, vec3 d)\n{\n    vec2 eps = vec2(g_eps, 0);\n    float t = rayMarch(o, d);\n    if(t < 0.0)\n    {\n        return vec3(0.0);\n    }\n    vec3 p = o+d*t;\n    vec3 ds = vec3(df(p));\n    vec3 dd = vec3(df(p-eps.xyy), df(p-eps.yxy), df(p-eps.yyx));\n    return ds-dd;\n}\n\nvec3 phongShading(vec3 o, vec3 d, vec3 l)\n{;\n \n    float dO = rayMarch(o, d);\n    if(dO < 0.0 || dO > farPlane)\n    {\n       return fogColor;\n    }\n    vec3 p = o+d*dO;\n    \n  \n    vec3  nlDir = normalize(l-p);\n    float lightDistance = length(l-p);\n    \n    bool visibility = (rayMarch(p+nlDir*g_eps*5.0, nlDir) >= lightDistance-2.0*g_eps);\n    \n    vec3 nd = normalize(o-p);\n \n    vec3 nv = normalize(normalVector(o, d));\n    vec3 nnv = nv;\n    \n    vec3 halfDir = normalize(nlDir + nd);\n    float specAngle = max(dot(halfDir, nnv), 0.0);\n    float specular = pow(specAngle, shininess);\n    \n    float specularRatio = specular*specularity;\n    float lambertianRatio = max(dot(nlDir, nnv),0.0);\n    if(length(nv) < g_eps)\n    {\n      lambertianRatio = 0.0;\n    }\n    float lightAttenuation = 0.1*(pow(lightDistance,2.0)+1.0);\n    float lightIntensity = 1.0/lightAttenuation;\n    float fogRatio = max(0.0,(1.0+dO)/farPlane);\n    \n    \n    vec3 albedoColor = colorize(p);\n    \n    vec3 ambientColorPart    = albedoColor*ambientRatio;\n    vec3 shadingColor = ambientColorPart;\n    if(visibility)\n    {\n        vec3 lambertianColorPart = albedoColor*lightIntensity*lambertianRatio*roughness;\n        vec3 specularColorPart   = sunColor*specularRatio*lightIntensity;\n    \n    \n        shadingColor += lambertianColorPart + specularColorPart;\n    }\n    \n    return mix(shadingColor, fogColor, fogRatio);\n}\n\n\nvec3 depthMap(vec3 o, vec3 d)\n{\n    \n    float dO = rayMarch(o, d);\n    if(dO < 0.0)\n    {\n        return vec3(0.0);\n    }\n    return vec3(1.0-(1.0/dO),0.0,0.0);\n    //return vec3(1.0-(exp(dO)/10.0));\n}\n\nvec3 iterationsMap(vec3 o, vec3 d)\n{\n    vec2 result = rayMarchWithIterations(o, d);\n    float dO = result.x;\n    if(dO < 0.0)\n    {\n        return vec3(0.0);\n    }\n    return vec3(result.y/float(g_maxIterations),0.0,0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sunPos = vec3(sin(iTime)*0.0,2.0,sin(iTime)*10.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv - vec2(0.5);\n    uv = uv * 2.0;\n    uv *= 0.5;\n    \n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    //vec3 cameraOrigin = vec3(0,0.0,-(sin(0.0)+5.0));\n    vec3  orbiterPoint = vec3(0.0);\n    float orbiterSpeed = 0.3;\n    vec3  orbiterDir = vec3(sin(orbiterSpeed*iTime),0.0, cos(orbiterSpeed*iTime));\n    float orbiterRadius = (3.0+2.0*sin(iTime*1.0))*3.0;\n    vec3 cameraOrigin = orbiterPoint+orbiterDir*orbiterRadius;\n    \n    vec3 cameraLookUp = vec3(sin(iTime)*0.1,1.0,cos(iTime)*0.1);\n    //vec3 cameraDir = normalize(vec3(sin(0.0), 0.0,abs(cos(0.0))));\n    vec3 cameraDir = -normalize(orbiterDir);\n    mat3 rotation = mat3( cross(cameraLookUp,cameraDir), cameraLookUp,cameraDir);\n    vec3 screenLookVector = normalize(vec3(uv, 1.0));\n    \n    screenLookVector = rotation*screenLookVector;\n    \n\n    \n    vec3 col = vec3(0.0);\n    switch(coloringMode)\n    {\n        case 0:\n            col = phongShading(cameraOrigin, screenLookVector, sunPos);\n            break;\n        case 1:\n            col = depthMap(cameraOrigin, screenLookVector);\n            break;\n        case 2:\n            col = abs(normalize(normalVector(cameraOrigin, screenLookVector)));\n            break;\n        case 3:\n            col = iterationsMap(cameraOrigin, screenLookVector);\n            break;\n            \n        default:\n            col = vec3(1.0,0.0,0.0);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}