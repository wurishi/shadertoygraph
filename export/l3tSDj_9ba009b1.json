{"ver":"0.1","info":{"id":"l3tSDj","date":"1719803337","viewed":81,"name":"Hamster Ballz","username":"starmole2","description":"space = reset to random pos\nmouse x = balls vs sim\n\ntrying out a basic physics to drive some metaballs! \ni probably could get the same effect with scrolling through some noise. \nbut so many really fun parameters to play with!  \nnext up decent rendering! ","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["metaballs","balls","physics","hamster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool intersectsphere(vec4 pos_r, vec3 org, vec3 dir, out vec2 t) {\n    vec3 d = org - pos_r.xyz; \n    float ddo = dot(dir,d);\n    float delta = ddo*ddo - dot(d,d) + pos_r.w*pos_r.w; \n    if ( delta <= 0.0 ) return false;\n    float ds = sqrt(delta);\n    t.x = -ddo - ds;\n    t.y = -ddo + ds;\n    return true;\n}\n\nfloat intersectplane(vec4 plane, vec3 org, vec3 dir) {\n    return -(dot(plane.xyz, org) + plane.w) / dot(plane.xyz, dir); \n}\n\nfloat checker(vec3 p) {\n    ivec3 pi = ivec3(ceil(p+.5));\n    return float((pi.x ^ pi.y ^ pi.z)&1);\n}\n\nvec3 simViz(vec3 org, vec3 dir) {\n    // visualize simulation by plain ray tracing\n    vec3 lightdir = normalize(vec3(0.4, -1.0, 2.0));\n    float tbest = 1000.0;\n    int ibest = -1;\n    // trace balls\n    for ( int i=0; i<nballs; i++ ) {\n        vec4 pos_r = texelFetch(iChannel0, ivec2(i,0), 0);\n        vec2 t; \n        if ( intersectsphere(pos_r, org, dir, t) ) {\n            if ( t.x > 0.0 && t.x < tbest) {\n                tbest = t.x; \n                ibest = i;\n            }\n        }\n    }\n    // trace box\n    float tbest2 = 1000.0;\n    int ibest2 = -1;\n    for ( int i=0; i<6; i++ ) {\n        if ( dot(boxplanes[i].xyz, dir) > 0.0 ) continue; // do not render back facing \n        float t = intersectplane(boxplanes[i], org, dir);\n        if ( t>0.0 && t<tbest2 ) {\n            tbest2 = t;\n            ibest2 = i;\n        }\n    }\n    // shade\n    if ( tbest2 < tbest ) {\n        vec3 n = boxplanes[ibest2].xyz;\n        vec3 hitp = org + dir * tbest2; \n        float cc = checker(hitp);\n        return cc * (n*.5+.5) * abs(dot(n,lightdir));\n    } else if ( ibest!=-1 ) {\n        vec4 pos_r = texelFetch(iChannel0, ivec2(ibest,0), 0);\n        vec4 force_mass = texelFetch(iChannel0, ivec2(ibest,2), 0);\n        vec3 hitp = org + dir * tbest; \n        vec3 n = normalize(pos_r.xyz - hitp);\n        float volume = (4.0/3.0)*pi*pos_r.w*pos_r.w*pos_r.w; \n        float density = force_mass.w / volume;\n        float baseb = float(ibest&1);\n        vec3 color = mix(vec3(1.0), vec3(1.0-baseb,baseb,0), min(density,1.0));\n        return color * vec3(max(dot(n,lightdir),0.0)); \n    }\n    // no hit\n    return vec3(0.0, 0.5, 1.0);\n}\n\nfloat rscale = 3.0;\n\nfloat smootherstep(float x) {\n    return x * x * x * (x * (6.0f * x - 15.0f) + 10.0f);\n}\n\nfloat smoothstep1(float x) {\n    return smoothstep(0.0,1.0,x);\n}\n\n\nint iballs[nballs];\nint nrayballs = 0;\n\nfloat sampleField(vec3 pos) {\n    float sum = 0.0;\n    for ( int i=0; i<nrayballs; i++ ) {\n        int iball = iballs[i];\n        vec4 pos_r = texelFetch(iChannel0, ivec2(iball,0), 0);\n        float rs = pos_r.w *= rscale;\n        vec3 delta = pos_r.xyz - pos;\n        float ds = length(delta);\n        if ( ds < rs ) {\n            float sig = float(iball & 1)*2.0-1.0;           \n            sum += sig*smootherstep(1.0 - ds/rs);\n        }\n    }\n    return sum;\n}\n\nvec3 metaBalls(vec3 org, vec3 dir) {\n    float tnear = 1000.0;\n    float tfar = 0.0;\n    // trace entry/exit point: collect balls that intersect ray\n    for ( int i=0; i<nballs; i++ ) {\n        vec4 pos_r = texelFetch(iChannel0, ivec2(i,0), 0);\n        pos_r.w *= rscale;\n        vec2 t; \n        if ( intersectsphere(pos_r, org, dir, t) ) {\n            iballs[nrayballs++] = i;\n            tnear = min(t.x, tnear);\n            tfar = max(t.y, tfar);\n        }\n    }\n    tnear = max(tnear, 0.0);\n    // sample \n    float iso = .5;\n    float dt = .1;\n    float neps = dt;\n    float sprev = sampleField(org + dir * tnear);\n    while ( tnear < tfar ) { \n        tnear += dt;\n        vec3 p = org + dir * tnear;\n        float s = sampleField(p);\n        if ( s>=iso ) {\n            float sub = (iso - sprev) / (s-sprev);\n            tnear -= dt*(1.0-sub);\n            p = org + dir * tnear;\n            vec3 n = vec3(\n                sampleField(p - vec3(neps,0,0)) - sampleField(p + vec3(neps,0,0)),\n                sampleField(p - vec3(0,neps,0)) - sampleField(p + vec3(0,neps,0)),\n                sampleField(p - vec3(0,0,neps)) - sampleField(p + vec3(0,0,neps))\n            );\n            n = normalize(n);\n            /*\n            vec3 col = n*.5+.5;\n            vec3 spec = pow(texture(iChannel2, reflect(dir,n)).xyz, vec3(2.4));\n            vec3 diff = pow(texture(iChannel3, n).xyz, vec3(2.4));\n            return diff*col + diff * spec;*/\n            return n*.5+.5;\n        }\n        sprev = s;\n    }\n    // no hit\n    return vec3(0.0, 0.5, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x; \n    \n    // camera\n    vec3 org = vec3(0.0, 0.0, -12.0);\n    vec3 dir = normalize(vec3(uv, .8));\n    \n    // run image\n    //vec3 c = simViz(org, dir);\n    vec3 c;\n    if ( fragCoord.x < iMouse.x ) \n        c = metaBalls(org,dir);\n    else \n        c = simViz(org,dir);\n\n    fragColor = vec4(pow(c, vec3(1.0/2.4)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// physics sim\n// r/w: ball[i][0].pos radius \n// r/w: ball[i][1].velocity materialid\n// r/w: ball[i][2].force mass\n\nuvec3 pcg3d(uvec3 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v ^= v >> 16u;\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return v;\n}\n\nvec3 pcg3df(int a, int b) { /// 0..1\n    uvec3 u = pcg3d(uvec3(uint(a),uint(b),iDate.w*1000.0));\n    return vec3(u & uvec3(0xffffff)) / float(0xffffff);\n}\n\nbool keyPressed(int code) { \n    return texelFetch(iChannel1, ivec2(code, 1), 0).x > 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int idx = int(fragCoord.x); \n    int iy = int(fragCoord.y);\n    if ( idx > nballs ) {\n        discard; \n    }\n    if ( iFrame == 0 || keyPressed(32) ) { // initialize (key = space)\n        if ( iy==0 ) {\n            vec4 pos_r;\n            pos_r.xyz = (pcg3df(idx,0)-.5)*5.0;\n            pos_r.w = 0.3 + pcg3df(idx,1).x *.6;\n            fragColor = pos_r;\n        } else if ( iy==1 ) {\n            vec4 vel_id;\n            vel_id.xyz = (pcg3df(idx,230)-.5)*8.0;\n            vel_id.y = abs(vel_id.y);\n            vel_id.w = floor(pcg3df(idx,2).x * 10.0);\n            fragColor = vel_id; \n        } else if ( iy==2 ) {\n            vec4 force_mass;\n            force_mass.xyz = vec3(0.0);\n            force_mass.w = 1.0 + pcg3df(idx,10).x;\n            fragColor = force_mass;\n        } else {\n            discard;\n        }\n        return; \n    }\n    float dt = min(iTimeDelta,1.0/20.0) * simspeed; \n    \n    vec3 gravity; // = vec3(0.0, -9.81, 0.0);\n    float gravr = iTime *.2; \n    gravity.z = sin(gravr)*.1;\n    gravity.x = cos(gravr) - sin(gravr); \n    gravity.y = sin(gravr) + cos(gravr); \n    gravity = normalize(gravity);\n    gravity *= 4.81;\n    \n    \n    float dampen = .5;\n    if ( iy==0 ) {\n        // add velocity to position\n        vec4 pos = texelFetch(iChannel0, ivec2(idx,0), 0);\n        vec4 vel = texelFetch(iChannel0, ivec2(idx,1), 0); \n        pos.xyz += vel.xyz * dt;\n        fragColor = pos;\n    } else if ( iy==1 ) {\n        // add force to velocity\n        vec4 vel = texelFetch(iChannel0, ivec2(idx,1), 0);\n        vec4 force_mass = texelFetch(iChannel0, ivec2(idx,2), 0);\n        vel.xyz += force_mass.xyz / force_mass.w * dt;\n        // collide with outer bounding box \n        vec4 pos_r = texelFetch(iChannel0, ivec2(idx,0), 0);\n        for ( int i=0; i<6; i++ ) {\n            vec4 p = boxplanes[i];\n            float dist = dot(p.xyz, pos_r.xyz) + p.w;\n            if ( dist < pos_r.w ) {\n                if ( dot(vel.xyz,p.xyz) < 0.0 ) {\n                    vel.xyz = reflect(vel.xyz, p.xyz) * dampen;\n                }\n            }\n        } \n        fragColor = vel;\n    } else if ( iy==2 ) {\n        // gravity \n        vec4 force_mass = texelFetch(iChannel0, ivec2(idx,2), 0);\n        force_mass.xyz = vec3(0.0);\n        force_mass.xyz += gravity * force_mass.w;\n        // collide with all other balls \n        vec4 pos_r = texelFetch(iChannel0, ivec2(idx,0), 0);\n        for ( int i=0; i<nballs; i++ ) {\n            if ( i==idx ) continue;\n            vec4 pos_r2 = texelFetch(iChannel0, ivec2(i,0), 0);\n            vec3 d = pos_r2.xyz - pos_r.xyz;\n            float dist = length(d) - pos_r.w - pos_r2.w; \n            if ( dist < 0.0 ) { \n                force_mass.xyz += -d*(dist*dist)*40.0;\n            }\n        }  \n        fragColor = force_mass;\n    } else {\n        discard;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define nballs 500\nvec4 boxplanes[6] = vec4[6](vec4(0,1,0,6), vec4(0,-1,0,6), vec4(1,0,0,6), vec4(-1,0,0,6), vec4(0,0,1,6), vec4(0,0,-1,6));\nfloat pi = 3.1415926;\nfloat simspeed = .8;","name":"Common","description":"","type":"common"}]}