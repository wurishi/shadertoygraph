{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define MaxSteps 30\r\n#define MinimumDistance 0.0009\r\n#define normalDistance     0.0002\r\n\r\n#define Iterations 7\r\n#define PI 3.141592\r\n#define Scale 3.0\r\n#define FieldOfView 1.0\r\n#define Jitter 0.05\r\n#define FudgeFactor 0.7\r\n#define NonLinearPerspective 2.0\r\n#define DebugNonlinearPerspective false\r\n\r\n#define Ambient 0.32184\r\n#define Diffuse 0.5\r\n#define LightDir vec3(1.0)\r\n#define LightColor vec3(1.0,1.0,0.858824)\r\n#define LightDir2 vec3(1.0,-1.0,1.0)\r\n#define LightColor2 vec3(0.0,0.333333,1.0)\r\n#define Offset vec3(0.92858,0.92858,0.32858)\r\n\r\nvec2 rotate(vec2 v, float a) {\r\n\treturn vec2(cos(a)*v.x + sin(a)*v.y, -sin(a)*v.x + cos(a)*v.y);\r\n}\r\n\r\n// Two light sources. No specular \r\nvec3 getLight(in vec3 color, in vec3 normal, in vec3 dir) {\r\n\tvec3 lightDir = normalize(LightDir);\r\n\tfloat diffuse = max(0.0,dot(-normal, lightDir)); // Lambertian\r\n\t\r\n\tvec3 lightDir2 = normalize(LightDir2);\r\n\tfloat diffuse2 = max(0.0,dot(-normal, lightDir2)); // Lambertian\r\n\t\r\n\treturn\r\n\t(diffuse*Diffuse)*(LightColor*color) +\r\n\t(diffuse2*Diffuse)*(LightColor2*color);\r\n}\r\n\r\n\r\n// DE: Infinitely tiled Menger IFS.\r\n//\r\n// For more info on KIFS, see:\r\n// http://www.fractalforums.com/3d-fractal-generation/kaleidoscopic-%28escape-time-ifs%29/\r\nfloat DE(in vec3 z)\r\n{\r\n\t// enable this to debug the non-linear perspective\r\n\tif (DebugNonlinearPerspective) {\r\n\t\tz = fract(z);\r\n\t\tfloat d=length(z.xy-vec2(0.5));\r\n\t\td = min(d, length(z.xz-vec2(0.5)));\r\n\t\td = min(d, length(z.yz-vec2(0.5)));\r\n\t\treturn d-0.01;\r\n\t}\r\n\t// Folding 'tiling' of 3D space;\r\n\tz  = abs(1.0-mod(z,2.0));\r\n\r\n\tfloat d = 1000.0;\r\n\tfor (int n = 0; n < Iterations; n++) {\r\n\t\tz.xy = rotate(z.xy,4.0+2.0*cos( iTime/8.0));\t\t\r\n\t\tz = abs(z);\r\n\t\tif (z.x<z.y){ z.xy = z.yx;}\r\n\t\tif (z.x< z.z){ z.xz = z.zx;}\r\n\t\tif (z.y<z.z){ z.yz = z.zy;}\r\n\t\tz = Scale*z-Offset*(Scale-1.0);\r\n\t\tif( z.z<-0.5*Offset.z*(Scale-1.0))  z.z+=Offset.z*(Scale-1.0);\r\n\t\td = min(d, length(z) * pow(Scale, float(-n)-1.0));\r\n\t}\r\n\t\r\n\treturn d-0.001;\r\n}\r\n\r\n// Finite difference normal\r\nvec3 getNormal(in vec3 pos) {\r\n\tvec3 e = vec3(0.0,normalDistance,0.0);\r\n\t\r\n\treturn normalize(vec3(\r\n\t\t\tDE(pos+e.yxx)-DE(pos-e.yxx),\r\n\t\t\tDE(pos+e.xyx)-DE(pos-e.xyx),\r\n\t\t\tDE(pos+e.xxy)-DE(pos-e.xxy)\r\n\t\t\t)\r\n\t\t);\r\n}\r\n\r\n// Solid color \r\nvec3 getColor(vec3 normal, vec3 pos) {\r\n\treturn vec3(1.0);\r\n}\r\n\r\n\r\n// Pseudo-random number\r\n// From: lumina.sourceforge.net/Tutorials/Noise.html\r\nfloat rand(vec2 co){\r\n\treturn fract(cos(dot(co,vec2(4.898,7.23))) * 23421.631);\r\n}\r\n\r\nvec4 rayMarch(in vec3 from, in vec3 dir, in vec2 fragCoord) {\r\n\t// Add some noise to prevent banding\r\n\tfloat totalDistance = Jitter*rand(fragCoord.xy+vec2(iTime));\r\n\tvec3 dir2 = dir;\r\n\tfloat distance;\r\n\tint steps = 0;\r\n\tvec3 pos;\r\n\tfor (int i=0; i < MaxSteps; i++) {\r\n\t\t// Non-linear perspective applied here.\r\n\t\tdir.zy = rotate(dir2.zy,totalDistance*cos( iTime/4.0)*NonLinearPerspective);\r\n\t\t\r\n\t\tpos = from + totalDistance * dir;\r\n\t\tdistance = DE(pos)*FudgeFactor;\r\n\t\ttotalDistance += distance;\r\n\t\tif (distance < MinimumDistance) break;\r\n\t\tsteps = i;\r\n\t}\r\n\t\r\n\t// 'AO' is based on number of steps.\r\n\t// Try to smooth the count, to combat banding.\r\n\tfloat smoothStep =   float(steps) + distance/MinimumDistance;\r\n\tfloat ao = 1.1-smoothStep/float(MaxSteps);\r\n\t\r\n\t// Since our distance field is not signed,\r\n\t// backstep when calc'ing normal\r\n\tvec3 normal = getNormal(pos-dir*normalDistance*3.0);\r\n\t\r\n\tvec3 color = getColor(normal, pos);\r\n\tvec3 light = getLight(color, normal, dir);\r\n\tcolor = (color*Ambient+light)*ao;\r\n\treturn vec4(color,1.0);\r\n}\r\n\r\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\r\n{\r\n\t// Camera position (eye), and camera target\r\n\tvec3 camPos = 0.5*iTime*vec3(1.0,0.0,0.0);\r\n\tvec3 target = camPos + vec3(1.0,0.0*cos(iTime),0.0*sin(0.4*iTime));\r\n\tvec3 camUp  = vec3(0.0,1.0,0.0);\r\n\t\r\n\t// Calculate orthonormal camera reference system\r\n\tvec3 camDir   = normalize(target-camPos); // direction for center ray\r\n\tcamUp = normalize(camUp-dot(camDir,camUp)*camDir); // orthogonalize\r\n\tvec3 camRight = normalize(cross(camDir,camUp));\r\n\t\r\n\tvec2 coord =-1.0+2.0*fragCoord.xy/iResolution.xy;\r\n\tcoord.x *= iResolution.x/iResolution.y;\r\n\t\r\n\t// Get direction for this pixel\r\n\tvec3 rayDir = normalize(camDir + (coord.x*camRight + coord.y*camUp)*FieldOfView);\r\n\t\r\n\tfragColor = rayMarch(camPos, rayDir, fragCoord );\r\n}\r\n\r\n\r\n\r\n\r\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mdf3z7","date":"1365854834","viewed":15714,"name":"Menger Journey","username":"Syntopia","description":"Another fly through, this time through a Menger system (with some perturbations). \n\nThe 'roto-perspective' may be adjusted using the 'NonLinearPerspective' define.","likes":312,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractals","menger"],"hasliked":0,"parentid":"","parentname":""}}