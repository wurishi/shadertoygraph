{"ver":"0.1","info":{"id":"lltfWS","date":"1540913128","viewed":86,"name":"raymarched heart","username":"Benstyle","description":"a small heart","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define maxStep 512\n#define epsilon 0.0001\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec2 rot2D(vec2 v, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c)*v;\n}\n\n\nfloat smoothAbs(float x)\n{\n    \n    return sqrt(x*x + 0.01);\n    \n}\n\n///// Fonctions de distance ///\n\nfloat forme( vec3 p, vec3 o, float r )\n{\n \tvec3 u = p - o;\n    \n    \n    u.y += -1.8*smoothAbs(u.x)*((23.+smoothAbs(u.x))/100.);\n    \n    u.z *= 1.5;\n    \n    \n    \n    float os = sin(2.*iTime + 0.9*p.y);\n    r = r+ os*os*os*os*.1;\n    \n    \n    return length( u) - r;\n}\n\nfloat sol(vec3 p, vec3 o)\n{\n return p.y - o.y;   \n}\n\nfloat sphere(vec3 p, float r)\n{\n return length(p)-r;   \n}\n\n\n///////\n\n\n\nfloat map(vec3 p) // ici on met en place la scène    \n{\n    \n    \n    \n    vec2 pRot = rot2D(p.xz, p.y/4. + iTime);\n    \n    \n    \n    float d1 = forme(vec3(pRot.x, p.y, pRot.y), vec3(0.), 1.);\n    \n    \n    \n    float d2 = sol(p, vec3(0.,-1.3,0.));\n    \n    \n    \n    \n    return min(d1,d2);\n}\n\n\n\n/// fonction de raymarching ( on recherche une intersection )\n\n\nvec3 intersection(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    \n    float d = 0.;\n    \n    for(int i = 0; i <= maxStep; i++)\n    {\n        \n        d = map(ro + t*rd);\n        \n        if (d < epsilon) /// si on est trop près, on s'arrête\n        {\n            break;\n        }\n        \n        t += d;\n        \n          \n        \n    }\n\n\n\n\treturn ro + t*rd; /// on renvoie l endroit ( approché ) d une intersection\n}\n\n\nvec3 normale(vec3 p )\n{\n    vec3 u = vec3(0.);\n    vec3 a = vec3(1.,0.,0.);\n    vec3 b = vec3(0.,1.,0.);\n    vec3 c = vec3(0.,0.,1.);\n    u.x += map(p + epsilon*a) - map(p - epsilon*a);\n    u.y += map(p + epsilon*b) - map(p - epsilon*b); ///on calcule la normale du point considéré\n    u.z += map(p + epsilon*c) - map(p - epsilon*c);\n    \n    \n    \n\treturn normalize(u);\n}\n\n\n\n\n //definition des lumieres\n\nvec3 l1Pos = vec3(2.,2.,3.);\nvec3 l1Int = vec3(0.8,0.,0.);\n\n/// ici on définit une fonction d ombre\n\nfloat smoothShadow(vec3 p, vec3 lPos, vec3 lInt)\n{\n    vec3 rd = normalize(lPos - p);\n    \n    \n    vec3 pImp = intersection(p + rd , rd); //on envoie un rayon jusqu'à la source de lumière et on regarde si il y arrive\n    \n    float d = length(lPos - p);\n    \n    if(map(pImp) > 10.*epsilon)\n       {\n           return 0.;\n       }\n     return 0.8/d; \n    \n}\n\n\n///on définit un matériau pour la scène\nvec3 BaseShading(vec3 p, vec3 ro)\n{\n    vec3 n = normale(p);\n    \n    vec3 col = vec3(0.);\n     \n    \n    \n    \n    if (map(p) < epsilon)\n    {\n        vec3 l1 = normalize(l1Pos - p); /// vecteur unitaire dirigé vers la source de lumière 1\n        vec3 rop = normalize(ro-p); /// vecteur unitaire dirigé vers la caméra\n        \n        float d = dot(l1, n) + 1.;\n        \n        d = (d+1.)/2.;\n        \n        col += max(0., d-.5) * l1Int; //diffuse simple\n        \n        ///spec\n        \n        vec3 reflet = (l1 - 2.*dot(l1,n)*n); //calcul du rayon réfléchi\n        \n        float a =  max(0.,dot(-reflet,rop));\n        //a = a*a;\n        a = a*a;\n        \n        col += a*.5;\n        \n        \n                    \n        col += (vec3(0.8,1.,1.) - dot(rop,n)) * .8; //bords blancs\n        \n        \n        \n        \n        col -= smoothShadow(p, l1Pos, l1Int);\n        \n        \n        \n        \n        return col;\n        \n    }\n    \n    \n    return vec3(0.);\n}\n\n\n\n    \n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy -.5;\n    \n    float ratio = iResolution.x/iResolution.y;\n    \n    uv.x *= ratio;\n\n    \n    vec3 ro = vec3(0.,0.,4.);\n    \n    vec3 rd = normalize(vec3(uv.xy, -1.));\n    \n    \n    \n    \n    vec3 inter = intersection(ro, rd);\n    \n    \n    \n    \n    \n    vec3 col = BaseShading(inter,ro);\n    \n    col *= smoothstep(1.,0.3, length(uv.xy ));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}