{"ver":"0.1","info":{"id":"lfXfR2","date":"1724053821","viewed":60,"name":"Heat-map based object search","username":"sh1boot","description":"WIP to demonstrate some position localisation ideas\n\nClick or drag on the texture to update the map with a new ping.  The target is near the centre of the screen and successive clicks refine the map to focus the search area there.","likes":2,"published":3,"flags":48,"usePreview":0,"tags":["interactive","heatmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Display buffer A (the heatmap and ping markers) using a palette and contour lines.\n// Use auto-scaling information from buffer B.\n// Show some debug information when shift is held down.\n// Show the target position when T is held down.\n\n#define SHIFT_KEY (texelFetch(iChannel3, ivec2(16,0),0).x > 0.5)\n#define T_KEY (texelFetch(iChannel3, ivec2(84,0),0).x > 0.5)\n\nvec3 heatmap(float v) {\n    v = v * 2.0 - 1.0;\n    vec3 rise = smoothstep(vec3(0.40, 0.00,-2.00),\n                           vec3(0.80, 0.40, 0.00), vec3(v));\n    vec3 fall = smoothstep(vec3(1.00, 0.80, 0.20),\n                           vec3(2.00, 1.00, 0.60), vec3(v));\n\n    vec3 c = rise * (1.0 - fall);\n    return c;\n}\n\nfloat contour(float v) {\n    v *= 16.0;\n    float del = fwidth(v) * 1.4;\n    v = fract(v) - 0.5;\n    return smoothstep(0.0, del, abs(v));\n}\n\nvec4 bar(float lo, float x, float hi, float cy) {\n    float xl = min(x, 0.);\n    float xh = max(0., x);\n\n    xl = cy - (xl - lo) * iResolution.y / (hi - lo);\n    xh = cy - (xh - lo) * iResolution.y / (hi - lo);\n    return vec4(smoothstep(-0.01, 0.01, xl)\n              * smoothstep(-0.01, 0.01, -xh));\n}\n\nvoid mainImage(out vec4 fragColour, in vec2 fragCoord) {\n    fragColour = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 range = texelFetch(iChannel1, ivec2(0), 0);\n    float overlay = fragColour.z;\n    float v = (fragColour.w - range.x) * range.w;\n    fragColour.rgb = heatmap(v);\n    fragColour = mix(fragColour, vec4(1.0), overlay);\n    fragColour *= contour(v);\n\n    if (T_KEY) {\n        vec2 uv = worldspace(fragCoord, iResolution.xy);\n        float t = smoothstep(-0.001, 0.001, 0.09 - distance(uv, target()));\n        fragColour = mix(fragColour, vec4(1,1,0,1), t);\n    }\n\n    if (SHIFT_KEY) {\n        float v = range[int(fragCoord.x / 16.0) & 3];\n        if (fragCoord.x < 64.0) {\n            int phase = int(fragCoord.x) & 15;\n            if (phase == 15) {\n               v = 0.0;\n            } else if (phase > 12) {\n                v = log2(v);\n            } else if (phase > 8) {\n                v *= 0.1;\n            }\n            fragColour = bar(-2.0, v, 2.0, fragCoord.y);\n            if (phase == 15) fragColour = vec4(0);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Update the values in buffer A with the latest reading if the mouse button is\n// currently down.  Or zero the buffer if space is pressed.\n// Apply some decay so old readings don't persist forever and swamp newer data.\n\n// channel z has markup showing the ping positions.\n// channel w has the heat map itself.\n\n#define SPACE_KEY (texelFetch(iChannel3, ivec2(32,0),0).x > 0.5)\n#define MOUSE_CLICK (iMouse.w > 0.0)\n#define MOUSE_DRAG (iMouse.z > 0.0)\n\nvoid mainImage(out vec4 fragData, in vec2 fragCoord) {\n    fragData = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    if (iFrame == 0 || SPACE_KEY) fragData = vec4(0);\n\n    if (MOUSE_DRAG /*&& (iFrame & 3) == 0*/) {\n        vec2 uv = worldspace(fragCoord, iResolution.xy);\n        vec2 origin = worldspace(iMouse.xy, iResolution.xy);\n\n        // update heat map:\n        float p = evaluate_point(origin, uv, iFrame);\n        fragData.w += max(-2.0, log2(p));\n\n        // mouse positions:\n        float d = distance(origin, uv);\n        float s = fwidth(d) * 1.4;\n        fragData.z = max(fragData.z, smoothstep(-s, s, 0.15 - d));\n    }\n\n    // Decay, because we want any bad readings, or any sensor\n    // drift, to eventually be cancelled out by later readings.\n    fragData *= 0.999;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Randomly sample buffer A to get an idea of the minimum and maximum values.\n// filter the result to hide most of the noise.\n\nivec2 ihash(int x) {\n    return x * ivec2(1337, 7331) + iFrame * ivec2(137, 731);\n}\n\nvoid mainImage(out vec4 fragData, in vec2 fragCoord) {\n    if (floor(fragCoord) != vec2(0.0)) discard;\n\n    fragData = texelFetch(iChannel0, ivec2(0), 0);\n    if (iFrame == 0) fragData = vec4(0.5);\n\n    // Get our initial values from the target position, because we have to\n    // start somewhere and that's probably the true maximum.\n    float hi = texture(iChannel1, world_to_texture(target())).w;\n    float lo = hi;\n\n    // Iterating 10k times per pixel looks terrible, but we only do it for a\n    // single pixel (and everyone else in its warp).\n    for (int i = 0; i < 10000; ++i) {\n        ivec2 i2 = ihash(i) % ivec2(iResolution.xy);\n        float w = texelFetch(iChannel1, i2, 0).w;\n        lo = min(lo, w);\n        hi = max(hi, w);\n    }\n    // Lowpass the stored result to gradually seek the calculated result.\n    fragData.x = mix(fragData.x, lo, 0.05);\n    fragData.y = mix(fragData.y, hi, 0.05);\n    fragData.z = (fragData.y - fragData.x) + 0.1;\n    fragData.w = 1.0 / fragData.z;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// All the functions representing measurements, noise, confidence,\n// mapping from screen space, etc...\n\nfloat scale = 25.0;\n\nvec2 target()\n{\n    return vec2(0.3);\n}\n\nvec2 worldspace(vec2 p, vec2 r) {\n    float s = scale / r.x;\n    return (p - 0.5 * r) * s;\n}\n\nvec2 world_to_texture(vec2 p) {\n  return p / scale + 0.5;\n}\n\n#if 1  // distance estimate\nfloat measure(vec2 origin, vec2 target) {\n    return log(distance(origin, target));\n}\n\nfloat compare(float a, float b) {\n    return abs(a - b);\n}\n\nfloat noise(float x, float d, int seed) {\n    float n = float((seed * 123) % 456) / 456.0;\n    return x + (n - 0.5) * 0.4;\n}\n\n#else  // direction estimate\nfloat measure(vec2 origin, vec2 target) {\n    return atan(origin.y - target.y, origin.x - target.x);\n}\n\nfloat compare(float a, float b) {\n    return mod(a - b + 3.14159, 6.283185) - 3.14159;\n}\n\nfloat noise(float x, float d, int seed) {\n    float n = float((seed * 123) % 456) / 456.0;\n    return x + (n - 0.5) * 0.08;\n}\n#endif\n\nfloat blur(float x, float d) {\n     const float sqrt2pi = sqrt(6.28);\n     float s = 0.35;\n     return exp(x * x / (s * s * -2.0)) / (s * sqrt2pi);\n}\n\n\nfloat evaluate_point(vec2 origin, vec2 uv, int seed) {\n    // how far is this pixel from our origin?  This may affect\n    // the estimate of the precision.\n    float d = distance(origin, uv);\n\n    // what reading do we get on the target?\n    float m = measure(origin, target());\n\n    // what reading would we expect if the target were here?\n    float n = measure(origin, uv);\n\n    // if these are similar then the target could be here, so\n    // far as we know from this reading.\n    float c = compare(m, n);\n\n    // but there's noise.\n    c = noise(c, distance(origin, target()), seed);\n\n    // but we expect noise.\n    float b = blur(c, d);\n    \n    return b;\n}\n","name":"Common","description":"","type":"common"}]}