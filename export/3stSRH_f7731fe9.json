{"ver":"0.1","info":{"id":"3stSRH","date":"1571457184","viewed":556,"name":"Shadertoy recursion","username":"morimea","description":"[b]Original shader[/b] [url]https://www.shadertoy.com/view/ld2fzh[/url]\nThis is only light modifications of original code.\n\nBufB/C/D and Image for blur+edges (effects)\n\nstatic version no random, loop time 23.5 sec","likes":41,"published":1,"flags":32,"usePreview":0,"tags":["fractal","zoom","shadertoy","alphabet","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Danil (2019+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// BufA base on this shader https://www.shadertoy.com/view/ld2fzh\n\n\n// Image shader edges from https://www.shadertoy.com/view/XtsSzr\n// Created by fatumR\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Color conversion related functions\nvec3 rgb2hsv(vec3 color) {\n    vec3 HSV = vec3(0.); // x -> H, y -> S, z -> V\n    float Max = max(color.r, max(color.g, color.b));\n    float Min = min(color.r, min(color.g, color.b));\n    float chroma = Max - Min;\n    \n    HSV.z = Max;\n    \n    if (chroma > 0.) {\n        vec3 components = vec3(0.);\n        if (Max == color.r) {\n            components.xy = color.gb;\n        } else if (Max == color.g) {\n            components.xy = color.br;\n            components.z = 2.;\n        } else {\n            components.xy = color.rg;\n            components.z = 4.;\n        }\n        \n        HSV.x = fract(((components.x - components.y)/chroma + components.z) / 6.);\n\n        // Saturation\n        if (Max > 0.) {\n        \tHSV.y = chroma / Max;\n        } else {\n            HSV.y = 0.;\n        }\n    }\n    \n    return HSV;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Edge detection related functions\nvec4 detectEdgesSimple(vec2 uv) {\n    // Simple central diff detector\n    vec4 offset = vec4(1./iResolution.xy, -1./iResolution.xy);\n    vec4 hill = texture(iChannel0, uv);\n    \n    vec4 acc = (hill - texture(iChannel0, uv + offset.x)) / offset.x;\n    acc += (hill - texture(iChannel0, uv - offset.x)) / offset.x;\n    acc += (hill - texture(iChannel0, uv + offset.y)) / offset.y;\n    acc += (hill - texture(iChannel0, uv - offset.y)) / offset.y;\n    acc += (hill - texture(iChannel0, uv + offset.xy)) / (.5 * (offset.x + offset.y));\n    acc += (hill - texture(iChannel0, uv - offset.xy)) / (.5 * (offset.x + offset.y));\n    acc += (hill - texture(iChannel0, uv + offset.zy)) / (.5 * (offset.x + offset.y));\n\tacc += (hill - texture(iChannel0, uv - offset.xw)) / (.5 * (offset.x + offset.y));\n\n\treturn abs(acc * .003); // Changing the multiplier we can control the number o edges\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 blurredClr;\n    float edge;\n    blurredClr = (texture(iChannel0,uv).rgb);\n    blurredClr*=1.*blurredClr;\n    edge = length(detectEdgesSimple(uv));\n    vec3 origClr = 0.5*texture(iChannel0, uv, 0.).rgb;\n    vec3 hsv = rgb2hsv(origClr.rgb);\n    hsv.y = min(hsv.y * 2., 1.);\n    hsv.z = min(hsv.z * 1.75, 1.);\n    \n    vec3 rgb;\n    rgb = hsv2rgb(hsv);\n    origClr = mix(blurredClr, rgb, clamp(edge, 0., 1.));\n    \n    vec3 col=sqrt(origClr)*0.32+origClr*1.21;\n    col=clamp(col,0.,1.);\n    float a=max(min(dot(col,vec3(1.))*.5,1.),clamp(edge, 0., 3.)*0.25);\n    a=clamp(a,0.,1.);\n    //col+=texture(iChannel1,uv).rgb*(1.-a);\n\tfragColor = vec4(col,a);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// base on this shader https://www.shadertoy.com/view/ld2fzh\n\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n//////////////////////////////////////////////////////////////////////////////////\n// Alphabet Soup - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 0.5;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.2;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 4;\t// how deep to recurse\nconst float recursionFadeDepth\t= 1.230;\t// how deep to fade out\nconst float recursionFadeDepth2\t= 1.120;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 6;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 10;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\n/*\nconst int glyphs[glyphSize*glyphCount] = int[]\n(// glyph sheet\n 0x01110, 0x11110, 0x01111, 0x11110, 0x11111, 0x11111, 0x01111, 0x11011, 0x11111, 0x01111, 0x11011, 0x11000, 0x01010, 0x11001, 0x01110, 0x11110, 0x01110, 0x11110, 0x01111, 0x11111, 0x11011, 0x11011, 0x10101, 0x10001, 0x10001, 0x11111,\n 0x11011, 0x11011, 0x11100, 0x11011, 0x11000, 0x11000, 0x11000, 0x11011, 0x01110, 0x00110, 0x11110, 0x11000, 0x11111, 0x11101, 0x11011, 0x11011, 0x11011, 0x11011, 0x11100, 0x01110, 0x11011, 0x11011, 0x10101, 0x11011, 0x11011, 0x00111,\n 0x11111, 0x11111, 0x11000, 0x11011, 0x11110, 0x11110, 0x11011, 0x11111, 0x01110, 0x10110, 0x11100, 0x11000, 0x11111, 0x11111, 0x11011, 0x11110, 0x11011, 0x11110, 0x11111, 0x01110, 0x11011, 0x11011, 0x11111, 0x01110, 0x01110, 0x01110,\n 0x11011, 0x11011, 0x11100, 0x11011, 0x11000, 0x11000, 0x11011, 0x11011, 0x01110, 0x11110, 0x11110, 0x11000, 0x10101, 0x10111, 0x11011, 0x11000, 0x11010, 0x11111, 0x00111, 0x01110, 0x11111, 0x01110, 0x11111, 0x11011, 0x01110, 0x11100,\n 0x11011, 0x11110, 0x01111, 0x11110, 0x11111, 0x11000, 0x01111, 0x11011, 0x11111, 0x01100, 0x11011, 0x11111, 0x10101, 0x10011, 0x01110, 0x11000, 0x01101, 0x11011, 0x11110, 0x01110, 0x01110, 0x00100, 0x01010, 0x10001, 0x01110, 0x11111\n);// A        \t\tB        \t\tC        \t\tD       \t\t E        \t\tF        \t\tG        \t\tH        \t\tI       \t\t J        \t\t\tK        \t\t\tL        \t\tM        \tN        \t\tO        \t\tP        \t\tQ        \t\tR       \t\t S       \t\t T        \t\tU       \t\t V       \t\t W        \t\tX        \t\tY    \t\t    Z\n\n*/\n\n\nconst int glyphs[glyphSize*glyphCount] = int[]\n(// s          h         a        d        e          r          t        o          y\n0x011111, 0x110011, 0x011110, 0x111110, 0x111111, 0x111110, 0x111111, 0x011110, 0x100001, 0x111111, \n0x111000, 0x110011, 0x110011, 0x110111, 0x110000, 0x110011, 0x011110, 0x110011, 0x110011, 0x111111, \n0x111111, 0x111111, 0x111111, 0x110111, 0x111100, 0x111110, 0x011110, 0x110011, 0x011110, 0x111111, \n0x111111, 0x111111, 0x111111, 0x110111, 0x111100, 0x111111, 0x011110, 0x110011, 0x011110, 0x111111, \n0x000111, 0x110011, 0x110011, 0x110111, 0x110000, 0x110011, 0x011110, 0x110011, 0x011110, 0x111111, \n0x111110, 0x110011, 0x110011, 0x111110, 0x111111, 0x110011, 0x011110, 0x011110, 0x011110, 0x111111\n\n);\n\nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos);\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 8;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\nint NRandInt(int i) { return i; }\n\nint GetFocusGlyph(int i) { return abs(NRandInt(i)) % glyphCount; }\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nfloat GetRecursionFade2(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth2, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth2;\n    return rt / rc;\n}\n\nint get_pos_id(int glyphLast,int posx,int posy){\n  if (glyphLast == 0) {\n    if ((posy == 2)) return posx;\n    if ((posy == 3) && (posx > 2)) return posx + 3;\n\n    return 9;\n  }\n  if (glyphLast == 1) {\n    if ((posx == 0) || (posx == 5)) return posy;\n    if (posx == (glyphSize - posy - 1)) return posy;\n\n    if ((posx == 1) && (posy < 3)) return posy + 6;\n    if ((posx == 4) && (posy > 2)) return posy + 3;\n\n    return 9;\n  }\n  if (glyphLast == 2) {\n    if ((posy == 0) && (posx > 1)) return posx + 4;\n\n    if (posx == 1) return posy;\n\n    return 9;\n  }\n  if (glyphLast == 3) {\n    if (posx == 1) return posy;\n    if ((posy == 5) && (posx > 1)) return posx + 4;\n\n    return 9;\n  }\n  if (glyphLast == 4) {\n    if ((posy == 0)) return posx;\n    if ((posx == 0)) return posy;\n    if ((posy == 5)) return 5 - posx;\n    if (((posy == 2) || (posy == 3)) && (posx > 0)) return posx + 5;\n\n    return 9;\n  }\n  if (glyphLast == 5) {\n    if (posx == 1) return posy;\n    if ((posx == 4) && (posy > 2)) return posy + 3;\n    return 9;\n  }\n  if (glyphLast == 6) {\n    if (posx == 1) return posy;\n    if ((posx > 1) && (posx < 5)) return posx + 4;\n\n    return 9;\n  }\n  if (glyphLast == 7) {\n    if ((posx == 1)) return posy;\n    if ((posx > 1) && (posy == 5)) return posx + 4;\n\n    return 9;\n  }\n  if (glyphLast == 8) {\n    return 9;\n  }\n  if (glyphLast == 9) {\n    if (posy == 2) return posx;\n    else\n    if ((posy > 2) && (posx == 5)) return posy + 3;\n\n    return 9;\n  }\n  return 9;\n}\n\n// [0]=shader [1]=toy\nbvec2 check_text_part_by_id(int glyphLast,int posx,int posy){\n    int idx=get_pos_id(glyphLast,posx,posy);\n    if(idx==9)return bvec2(false,false);\n    if(idx>5)return bvec2(false,true);\n    else return bvec2(true,false);\n}\n\nivec2 focusPosl;\nvec3 InitPixelColor() { return vec3(0); }\n\n//font\nconst vec3 col1=vec3(02.1,.02,.51);\nconst vec3 col2=0.5*vec3(01.01,1.2,8.1);\n\n//big static font\nconst vec3 col4=0.85*vec3(0.01,1.2,1.851);\n\n//all font\nconst vec3 col5=0.35*vec3(0.8,0.521,0.1);\n\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast, int glyphLast, ivec2 focusPos) {\n  vec3 myColor = vec3(0., 0., 0.);\n  int posx = (glyphPos.x);\n  int posy = (glyphSize - glyphPos.y - 1);\n\n  vec3 pyc = vec3(0., 0., 0.);\n  vec3 pyc2 = vec3(0., 0., 0.);\n\n  pyc = col5;\n\n  if ((r >= 2)) {\n    if (glyphPosLast == focusPosl) {\n      if ((r >= 2) && (r <= 3))pyc = col4;\n      if (r == 2) {\n      bvec2 idr=check_text_part_by_id((glyphLast-1)<0?glyphCount-1:glyphLast-1,posx,posy);\n      if(idr.x)pyc2 = col1;\n      if(idr.y)pyc2 = col2;\n      }\n\n    }\n  }\n  float ta2 = dot(clamp(pyc2, 0., 1.), vec3(1.)) / 3.;\n  float ta = dot(clamp(pyc, 0., 1.), vec3(1.)) / 3.;\n  pyc = pyc * (1. - ta2);\n  vec3 tc2 = vec3(0.);\n\n  float f = GetRecursionFade(r, timePercent);\n  float f2 = GetRecursionFade2(r, timePercent);\n  color.x += myColor.x * f;;\n  color.y = max(color.y, myColor.y * f);\n  color.z = max(color.z, myColor.z * pow(abs(f), 1.3));\n  vec3 retc = color + pyc * f + pyc2 * f2;\n  return retc + tc2;\n}\n\nvec2 InitUV(vec2 uv) {\n  vec2 tuv = uv * MD(0.2);\n  uv.x = tuv.x;\n  //uv.x+=-uv.y*0.2;\n  return uv;\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetGlyphPixelRow(int y, int g) {\n  return glyphs[g + (glyphSize - 1 - y) * glyphCount];\n}\nint GetGlyphPixel(ivec2 pos, int g) {\n  if (pos.x >= glyphSize || pos.y >= glyphSize)\n    return 0;\n\n  // pull glyph out of hex\n  int glyphRow = GetGlyphPixelRow(pos.y, g);\n  return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) {\n  return focusList[i + 2];\n}\n\n//static next position\nivec2 CalculateFocusPos(int iterations) {\n  // count valid pixels in glyph\n  int g = GetFocusGlyph(iterations - 1);\n  int c = 0;\n\n  if (g == 0) return ivec2(1, 3);\n  if (g == 1) return ivec2(3, 3);\n  if (g == 2) return ivec2(1, 2);\n  if (g == 3) return ivec2(1, 1);\n  if (g == 4) return ivec2(5, 5);\n  if (g == 5) return ivec2(4, 2);\n  if (g == 6) return ivec2(3, 3);\n  if (g == 7) return ivec2(4, 0);\n  if (g == 8) return ivec2(1, 2);\n  if (g == 9) return ivec2(0, 3);\n\n  return ivec2(0, 0);\n\n}\n\n// static position\nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos) {\n  if (glyphPos == focusPos)\n    return GetFocusGlyph(iterations); // inject correct glyph     \n\n  int posx = (glyphPos.x);\n  int posy = (glyphSize - glyphPos.y - 1);\n\n  return get_pos_id(glyphLast,posx,posy);\n}\n\n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    focusPosl=focusPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast,GetFocusGlyph(iterations+1),focusPos);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0*0.5; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPosl=focusPos;\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n}\n \n\n//full time loop(sec):\n// float(glyphCount)*(1./zoomSpeed)+3.5;\n// 3.5 its slow down time effect\n\n//////////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = (InitUV(uv)-vec2(0.,-0.05));\n    float full_time=float(glyphCount)*(1./zoomSpeed)+3.5;\n    float time=mod(iTime,full_time);\n    time=time-3.5*smoothstep(full_time-7.,full_time,time);\n\tfloat timePercent = (time)*zoomSpeed+float(glyphCount);\n    timePercent=floor(timePercent)+smoothstep(0.,1.,fract(timePercent));\n\tint iterations = int(timePercent);\n\ttimePercent -= floor(timePercent);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    //pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n    vec3 retc=clamp(pixelFractalColor,0.,10.);\n\tfragColor = vec4(retc*.75, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n// Horizontal bloom blur\n\n// Dedicated to the public domain under CC0 1.0 Universal\n//  https://creativecommons.org/publicdomain/zero/1.0/legalcode\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 acc = vec3(0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Manually expanded weights/iteration to please inferior shader compilers\n    const int steps = 7;\n    const float weights0 = 0.00598;\n    const float weights1 = 0.060626;\n    const float weights2 = 0.241843;\n    const float weights3 = 0.383103;\n    const float weights4 = 0.241843;\n    const float weights5 = 0.060626;\n    const float weights6 = 0.00598;\n    \n    vec2 direction = vec2(1.0, 0.0);\n    \n    vec2 offset0 = direction * float(0 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset0).xyz * weights0;\n    vec2 offset1 = direction * float(1 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset1).xyz * weights1;\n    vec2 offset2 = direction * float(2 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset2).xyz * weights2;\n    vec2 offset3 = direction * float(3 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset3).xyz * weights3;\n    vec2 offset4 = direction * float(4 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset4).xyz * weights4;\n    vec2 offset5 = direction * float(5 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset5).xyz * weights5;\n    vec2 offset6 = direction * float(6 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset6).xyz * weights6;\n    \n    fragColor = vec4(acc, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n// Vertical bloom blur\n\n// Dedicated to the public domain under CC0 1.0 Universal\n//  https://creativecommons.org/publicdomain/zero/1.0/legalcode\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 acc = vec3(0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Manually expanded weights/iteration to please inferior shader compilers\n    const int steps = 7;\n    const float weights0 = 0.00598;\n    const float weights1 = 0.060626;\n    const float weights2 = 0.241843;\n    const float weights3 = 0.383103;\n    const float weights4 = 0.241843;\n    const float weights5 = 0.060626;\n    const float weights6 = 0.00598;\n    \n    vec2 direction = vec2(0.0, 1.0);\n    \n    vec2 offset0 = direction * float(0 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset0).xyz * weights0;\n    vec2 offset1 = direction * float(1 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset1).xyz * weights1;\n    vec2 offset2 = direction * float(2 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset2).xyz * weights2;\n    vec2 offset3 = direction * float(3 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset3).xyz * weights3;\n    vec2 offset4 = direction * float(4 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset4).xyz * weights4;\n    vec2 offset5 = direction * float(5 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset5).xyz * weights5;\n    vec2 offset6 = direction * float(6 - steps / 2) / iResolution.xy;\n    acc += texture(iChannel0, uv + offset6).xyz * weights6;\n    \n    fragColor = vec4(acc, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n// Final composite/post pass\n\n// Dedicated to the public domain under CC0 1.0 Universal\n//  https://creativecommons.org/publicdomain/zero/1.0/legalcode\n\nvec3 hableTonemap(vec3 x)\n{\n    float a = .15;\n    float b = .5;\n    float c = .1;\n    float d = .2;\n    float e = .02;\n    float f = .3;\n\n    return ((x * (x * a + c * b) + d * e) / (x * (x * a + b) + d * f)) - e / f;\n}\n\nvec3 tonemap(vec3 rawColor, float exposure)\n{\n    float w = 1.2;\n\n    vec3 exposedColor = max(rawColor * exposure, 0.0);\n\n    vec3 linear = pow(exposedColor, vec3(1.0 / 2.2));\n\n    vec3 reinhard = pow(exposedColor / (exposedColor + 1.0), vec3(1.0 / 2.2));\n\n    vec3 x = max(exposedColor - .04, 0.0);\n    vec3 hejlBurgessDawson = (x * (x * 6.2 + .85)) / (x * (x * 6.2 +.07) + .56); //bright\n\n    float exposureBias = 2.0;\n    vec3 curr = hableTonemap(exposedColor * exposureBias);\n    float whiteScale = (vec3(1.0) / hableTonemap(vec3(w))).x;\n    vec3 color = curr * whiteScale;\n    vec3 hable = pow(color, vec3(1.0 / 2.2));\n\n    return\n        //linear\n        //reinhard\n        hejlBurgessDawson\n        //hable\n        ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    \n    float bloomAmount = 0.0;\n    vec3 original = texture(iChannel0, uv).xyz;\n    //vec3 bloom = texture(iChannel1, uv).xyz;\n    vec3 bloom = vec3(0.);\n    vec3 inputColor = original + bloom * bloomAmount;\n    \n    // Vignette\n    float vignetteStrength = 0.9;\n    float vignetteSizeBias = 0.5;\n    float vignettePower = 1.0;\n    float d = clamp(length(uv * 2.0 - 1.0) - vignetteSizeBias, 0.0, 1.0); //edges\n\tinputColor *= 1.0 - clamp(pow(d, vignettePower) * vignetteStrength, 0.0, 1.0);\n    \n    // Bring up lows a bit\n    inputColor = inputColor * .995 + .005;\n\n    // Some toy grading :)\n\tinputColor = pow(inputColor, vec3(1.175, 1.205, 1.80));\n    \n    // Tonemap\n    float exposure = 0.80;\n    vec3 tonemappedColor = clamp(tonemap(inputColor, pow(1.850, exposure)), 0.0, 1.0);\n    \n    // Output luma for fxaa\n    float luma = sqrt(dot(tonemappedColor, vec3(0.1299, 0.4587, 0.3114)));\n    \n    fragColor = vec4(tonemappedColor*luma, luma);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}