{"ver":"0.1","info":{"id":"7tSBDG","date":"1652682754","viewed":86,"name":"Simplified Hodgkin-Huxley model","username":"biogeo","description":"This models a slightly simplified version of the Hodgkin-Huxley model of the excitable neuronal membrane. The grayscale section shows voltage, and the color section shows ion channel subunit state.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["simulation","reactiondiffusion","biophysics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// Simplified Hodgkin-Huxley model of the neuronal cell membrane\n//\n// In 1954, Hodgkin and Huxley published one of the greatest achievements\n// in experimental biophysics, with their studies of the electrophysiology\n// of the squid (Loligo) lateral giant axon. In a series of papers focusing\n// on different aspects of the electrophysiology of this system, they were\n// able to identify that sodium and potassium (and to a lesser extent chloride)\n// are the major ions involved in the generation of action potentials, and\n// that the action potential was generated as a consequence of three different\n// unknown factors (which they called m, h, and n) altering the ion-specific\n// conductivity of the cell membrane in a voltage-dependent fashion. On the\n// basis of their experimental results, they were able to write down a system\n// of four coupled nonlinear differential equations that describe how an\n// action potential propagates. Although they did not yet known the mechanism\n// of ion channels and ion channel subunits, their equations accurately\n// predicted some key aspects of how sodium and potassium ion channels\n// respond to changes in voltage. The Hodgkin-Huxley equations are analytically\n// quite difficult to work with, and several simplified models have been\n// created over the years.\n//\n// In this model, I simplify the H&H equations to model the voltage-dependent\n// equilibrium for each ion channel subunit state using the GLSL smoothstep\n// function, and let the voltage-dependent state-change-rate term be\n// a constant. The nonlinearity of the power-law dependence of conductivity\n// on ion channel state is maintained.\n//\n// Simplified Hodgkin-Huxley equations:\n// dv/dt = A*Dv - G_Na*m^3*h*(v-V_Na) - G_K*n^4*(v-V_K) - G_L*(v-V_L)\n// dm/dt = (m0(v)-m)/Tm(v)\n// dh/dt = (h0(v)-h)/Th(v)\n// dn/dt = (n0(v)-n)/Tn(v)\n//\n// In this visualization, the left side of the output displays voltage in\n// greyscale, while the right side displays the state of the three ion\n// channel subunits as red, green, and blue. Red shows the activation\n// of sodium channel subunit \"h\", which is open at low voltages and closes\n// at medium and high voltages, and has slow kinetics; green shows sodium\n// channel subunit \"m\" which is closed a low voltages and open at medium and\n// high voltages, and has intermediate kinetics; and blue shows potassium\n// channel subunit \"n\", which opens only at (relatively) high voltages and\n// has fast kinetics.\n// \n// At low voltages (below the neuron's threshold potential)\n// only the h-type subunit is open, and since a sodium channel requires\n// 1 h-type and three m-type subunits to be open simultaneously, the sodium\n// channels do not conduct. Likewise, since the potassium channel's n-type\n// subunit is closed a low voltages, no potassium current flows either, and\n// the voltage is dominated by the membrane capacitance and the small leakage\n// current. This state appears as red in the visualization.\n//\n// Just above the threshold voltage, both h-type and m-type sodium channel\n// subunits are open, and the sodium channel begins to conduct. Because\n// sodium has a high reversal potential (established by the constant action\n// of the sodium-potassium pump in the cell membrane), this pulls the voltage\n// high, briefly reversing the polarity of the cell membrane. This is the\n// initiation of an action potential. This corresponds to the leading edge\n// of the green tinted waves in the visualization.\n// \n// As voltage increases as the sodium current flows, two things happen. The\n// h-type subunits begin to close; however, due to their slow kinetics, this\n// takes some time, during which the spike of the action potential can occur.\n// Meanwhile, the n-type subunits of the potassium channel open and allow the\n// potassium current to flow. Because the reversal potential of potassium is\n// low (again, due to the sodium-potassium pump), this pulls the voltage back\n// down towards, and ultimately past, its resting depolarized state. This\n// corresponds to the bluish tint in the wavefronts of the visualization.\n//\n// Finally, following the spike of the action potential, the h-type subunits\n// slowly reopen, preparing the cell for the next action potential. The\n// after-hyperpolarizaion period during which the h-type subunits are still\n// closed following the action potential despite the voltage being low again\n// can be seen as the black region in the visualization, with the increasing\n// red color corresponding to the reopening of the h-type subunits.\n//\n// Note that the terminology here of h-type, m-type, and n-type subunits does\n// not exactly correspond to H&H's original model (which was more agnostic\n// about the exact mechanism involved) nor to our more current understanding\n// of ion channels and their subunits. However the mathematics of the H&H\n// model, and in particular the exponents attached to the m, n, and h\n// variables, was remarkably prescient of the actual structure of\n// voltage-gated ion channels and their subunits.\n//\n// Copyright Geoffrey K. Adams 2022.\n// The text above is available for reuse under the CC-Attribution-ShareAlike\n// International 4.0 license. All code is available for reuse under the\n// MIT license.\n\nvoid mainImage(out vec4 O, in vec2 P)\n{\n    vec2 U = P / iResolution.xy;\n    if (U.x > 0.5) {\n        //vec3 hmn = texture(iChannel0, U).xyz;\n        //vec3 c1 = pow(vec3(0.4,0.2,0.0), vec3(1.-hmn.x));\n        //vec3 c2 = pow(vec3(0.1,0.4,0.2), vec3(1.-hmn.y));\n        //vec3 c3 = pow(vec3(0.3,0.0,0.5), vec3(1.-hmn.z));\n        //O.rgb = mix(mix(c1,c2,0.5),c3,0.3333);\n        O.rgb = texture(iChannel0, U).xyz;\n        O.b = pow(O.b, 0.4);\n        O.r = pow(O.r, 0.5);\n    } else {\n        O.rgb = vec3(texture(iChannel0, U).w);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define noise(x) value_noise(x)\n#define noise2(x) value_noise2(x)\n#define noise3(x) value_noise3(x)\n#define fractal_noise(q) ( \\\n    0.5000*noise(scale_for_fractal_noise(q)) + \\\n    0.2500*noise(scale_for_fractal_noise(q)) + \\\n    0.1250*noise(scale_for_fractal_noise(q)) + \\\n    0.0625*noise(scale_for_fractal_noise(q)) )\n#define fractal_noise2(q) ( \\\n    0.5000*noise2(scale_for_fractal_noise(q)) + \\\n    0.2500*noise2(scale_for_fractal_noise(q)) + \\\n    0.1250*noise2(scale_for_fractal_noise(q)) + \\\n    0.0625*noise2(scale_for_fractal_noise(q)) )\n#define fractal_noise3(q) ( \\\n    0.5000*noise3(scale_for_fractal_noise(q)) + \\\n    0.2500*noise3(scale_for_fractal_noise(q)) + \\\n    0.1250*noise3(scale_for_fractal_noise(q)) + \\\n    0.0625*noise3(scale_for_fractal_noise(q)) )\n\n/// Laplacian Operator ===============================================\n// Calculate the Laplacian of a field represented in a sampler2D\n// using periodic (toroidal) boundary conditions\n// Pass delta = 1.0 / iResolution.xy in most cases\nvec4 laplacian(in sampler2D field, in vec2 pos, in vec2 delta) {\n    vec3 deltaz = vec3(delta, 0.0);\n    return (\n        texture(field, mod(pos + deltaz.xz,1.0)) +\n        texture(field, mod(pos - deltaz.xz,1.0)) +\n        texture(field, mod(pos + deltaz.zy,1.0)) +\n        texture(field, mod(pos - deltaz.zy,1.0)) +\n        -4.0 * texture(field, pos)\n    ) / (deltaz.x*deltaz.y);\n}\n\n/// Wellons's Integer Hash ===========================================\n// from Chris Wellons https://nullprogram.com/blog/2018/07/31/\n// via https://www.shadertoy.com/view/WttXWX\n        // --- choose one:\n//#define HASHI(x)   lowbias32(x)\n  #define HASHI(x)   triple32(x)\n//bias: 0.17353355999581582 ( very probably the best of its kind )\nuint lowbias32(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x) {\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n// FKU macro trick credit to Blackle Mori\n// https://www.shadertoy.com/view/wd3XDN\n#define FKU(k) floatBitsToUint(cos(k))^floatBitsToUint(k)\nuint hashi(float f) {\n    return HASHI(FKU(f));\n}\nuint hashi(vec2 f) {\n    uint s = HASHI(FKU(f.x));\n    s = HASHI(s + HASHI(FKU(f.y)));\n    return s;\n}\nuint hashi(vec3 f) {\n    uint s = HASHI(FKU(f.x));\n    s = HASHI(s + HASHI(FKU(f.y)));\n    s = HASHI(s + HASHI(FKU(f.z)));\n    return s;\n}\nuint hashi(vec4 f) {\n    uint s = HASHI(FKU(f.x));\n    s = HASHI(s + HASHI(FKU(f.y)));\n    s = HASHI(s + HASHI(FKU(f.z)));\n    s = HASHI(s + HASHI(FKU(f.w)));\n    return s;\n}\nvec2 ihash2(uint i) {\n    uvec2 r;\n    r.x = i;\n    i = HASHI(i);\n    r.y = i;\n    return vec2(r) / float(0xffffffffU);\n}\nvec3 ihash3(uint i) {\n    uvec3 r;\n    r.x = i;\n    i = HASHI(i);\n    r.y = i;\n    i = HASHI(i);\n    r.z = i;\n    return vec3(r) / float(0xffffffffU);\n}\nvec4 ihash4(uint i) {\n    uvec4 r;\n    r.x = i;\n    i = HASHI(i);\n    r.y = i;\n    i = HASHI(i);\n    r.z = i;\n    i = HASHI(i);\n    r.w = i;\n    return vec4(r) / float(0xffffffffU);\n}\n#define hash(x) ( float(hashi(x)) / float(0xffffffffU) )\n#define hash2(x) ihash2(hashi(x))\n#define hash3(x) ihash3(hashi(x))\n#define hash4(x) ihash4(hashi(x))\n\n/// Inigo Quilez's Gradient Noise ==========================================\n// 2D and 3D noise functions by Inigo Quilez\n// The MIT License\n// Copyright Â© 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat gradient_noise(in vec2 p) {  // 2D noise\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( dot( hash2( i+vec2(0.,0.) ), f-vec2(0.,0.) ), \n                     dot( hash2( i+vec2(1.,0.) ), f-vec2(1.,0.) ), u.x),\n                mix( dot( hash2( i+vec2(0.,1.) ), f-vec2(0.,1.) ), \n                     dot( hash2( i+vec2(1.,1.) ), f-vec2(1.,1.) ), u.x), u.y);\n}\nfloat gradient_noise(in vec3 p) {  // 3D noise\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\tvec3 u = f*f*(3.0-2.0*f);\n    return mix( mix( mix( dot( hash3( i+vec3(0.0,0.0,0.0) ), f-vec3(0.0,0.0,0.0) ), \n                          dot( hash3( i+vec3(1.0,0.0,0.0) ), f-vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash3( i+vec3(0.0,1.0,0.0) ), f-vec3(0.0,1.0,0.0) ), \n                          dot( hash3( i+vec3(1.0,1.0,0.0) ), f-vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash3( i+vec3(0.0,0.0,1.0) ), f-vec3(0.0,0.0,1.0) ), \n                          dot( hash3( i+vec3(1.0,0.0,1.0) ), f-vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash3( i+vec3(0.0,1.0,1.0) ), f-vec3(0.0,1.0,1.0) ), \n                          dot( hash3( i+vec3(1.0,1.0,1.0) ), f-vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nfloat gradient_noise(in float p) { // 1D noise modifed from IQ's versions\n    float i = floor(p);\n    float f = fract(p);\n    float u = f*f*(3.0-2.0*f);\n    return mix( dot( hash( i+0. ), f-0. ),\n                dot( hash( i+1. ), f-1. ), u);\n}\nfloat value_noise(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n    return mix(mix(hash(i+vec2(0.,0.)), \n                   hash(i+vec2(1.,0.)), f.x),\n               mix(hash(i+vec2(0.,1.)), \n                   hash(i+vec2(1.,1.)), f.x), f.y);\n}\nfloat value_noise(in vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hash(i+vec3(0.,0.,0.)), \n                       hash(i+vec3(1.,0.,0.)),f.x),\n                   mix(hash(i+vec3(0.,1.,0.)), \n                       hash(i+vec3(1.,1.,0.)),f.x),f.y),\n               mix(mix(hash(i+vec3(0.,0.,1.)), \n                       hash(i+vec3(1.,0.,1.)),f.x),\n                   mix(hash(i+vec3(0.,1.,1.)), \n                       hash(i+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\nvec2 value_noise2(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n    return mix(mix(hash2(i+vec2(0.,0.)), \n                   hash2(i+vec2(1.,0.)), f.x),\n               mix(hash2(i+vec2(0.,1.)), \n                   hash2(i+vec2(1.,1.)), f.x), f.y);\n}\nvec2 value_noise2(in vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hash2(i+vec3(0.,0.,0.)), \n                       hash2(i+vec3(1.,0.,0.)),f.x),\n                   mix(hash2(i+vec3(0.,1.,0.)), \n                       hash2(i+vec3(1.,1.,0.)),f.x),f.y),\n               mix(mix(hash2(i+vec3(0.,0.,1.)), \n                       hash2(i+vec3(1.,0.,1.)),f.x),\n                   mix(hash2(i+vec3(0.,1.,1.)), \n                       hash2(i+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\nvec3 value_noise3(in vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\tf = f*f*(3.0-2.0*f);\n    return mix(mix(hash3(i+vec2(0.0,0.0)), \n                   hash3(i+vec2(1.0,0.0)), f.x),\n               mix(hash3(i+vec2(0.0,1.0)), \n                   hash3(i+vec2(1.0,1.0)), f.x), f.y);\n}\nvec3 value_noise3(in vec3 x) {\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(hash3(i+vec3(0.,0.,0.)), \n                       hash3(i+vec3(1.,0.,0.)),f.x),\n                   mix(hash3(i+vec3(0.,1.,0.)), \n                       hash3(i+vec3(1.,1.,0.)),f.x),f.y),\n               mix(mix(hash3(i+vec3(0.,0.,1.)), \n                       hash3(i+vec3(1.,0.,1.)),f.x),\n                   mix(hash3(i+vec3(0.,1.,1.)), \n                       hash3(i+vec3(1.,1.,1.)),f.x),f.y),f.z);\n}\n\n/// Fractal noise =======================================================\n// Simple 4-scale fractal noise function\n// Scale an input for fractal noise. Modifies its input so it can be used\n// repeatedly in a macro without needing to define additional state.\nvec2 scale_for_fractal_noise(inout vec2 q) {\n    const mat2 M =\n        1.8\n        * mat2( cos(1.0), sin(1.0),\n               -sin(1.0), cos(1.0) );\n    q = M * q;\n    return q;\n}\nvec3 scale_for_fractal_noise(inout vec3 q) {\n    const mat3 M =\n        1.8\n        * mat3( cos(1.0), sin(1.0),     0.0,\n               -sin(1.0), cos(1.0),     0.0,\n                    0.0,      0.0,      1.0)\n        * mat3( cos(2.0),     0.0,  sin(2.0),\n                    0.0,      1.0,      0.0,\n               -sin(2.0),     0.0,  cos(2.0))\n        * mat3(     1.0,      0.0,      0.0,\n                    0.0,  cos(3.0), sin(3.0),\n                    0.0, -sin(3.0), cos(3.0));\n    q = M * q;\n    return q;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simplified Hodgkin-Huxley model\n// dv/dt = A*Dv - G_Na*m^3*h*(v-V_Na) - G_K*n^4*(v-V_K) - G_L*(v-V_L)\n// dm/dt = (m0(v)-m)/Tm(v)\n// dh/dt = (h0(v)-h)/Th(v)\n// dn/dt = (n0(v)-n)/Tn(v)\nconst float A = 2.e-5;\nconst float G_Na = 500.;\nconst float G_K  = 5.;\nconst float G_L  = .5;\nconst float V_Na = 1.;\nconst float V_K  = 0.05;\nconst float V_L  = 0.15;\nfloat h_steady(float v) {\n    return 1. - smoothstep(0.15, 0.3, v);\n}\nfloat m_steady(float v) {\n    return smoothstep(0.2, 0.5, v);\n}\nfloat n_steady(float v) {\n    return smoothstep(0.65, 0.9, v);\n}\nfloat tau_h(float v) {\n    return 15.;\n}\nfloat tau_m(float v) {\n    return 0.5;\n}\nfloat tau_n(float v) {\n    return .5;\n}\n\nvoid mainImage(out vec4 O, in vec2 P)\n{\n    vec2 d = 1. / iResolution.xy;\n    vec2 U = d * P;\n    vec3 UT = vec3(10.*U, iTime);\n    O = texture(iChannel0, U);\n    O.w += 0.025*pow(fractal_noise(UT), 6.0);\n    //if (iFrame == 0) {\n    //    vec2 UU = 8. * U;\n    //    O.w = 2.*pow(fractal_noise(UU),4.0);\n    //    O.xyz = vec3(0.001);\n    //} else {\n    //    O = texture(iChannel0, U);\n    //}\n    vec4 dS;\n    dS.x = (h_steady(O.w) - O.w) / tau_h(O.w);\n    dS.y = (m_steady(O.w) - O.w) / tau_m(O.w);\n    dS.z = (n_steady(O.w) - O.w) / tau_n(O.w);\n    dS.w = (\n          A * laplacian(iChannel0, U, d).w\n        - G_Na * O.x * O.y * O.y * O.y * (O.w - V_Na)\n        - G_K  * O.z * O.z * O.z * O.z * (O.w - V_K)\n        - G_L                          * (O.w - V_L)\n    );\n    O += dS / 50.;\n    O = clamp(O, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}