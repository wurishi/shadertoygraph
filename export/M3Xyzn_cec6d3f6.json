{"ver":"0.1","info":{"id":"M3Xyzn","date":"1725719314","viewed":46,"name":"img_proc","username":"smileyenot983","description":"Image processing by applying sobel kernels or gaussian blur","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sobel","blur","switching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// sobel kernels\nconst float sobel_x[9] = float[](\n    1.0, 0.0, -1.0,\n    2.0, 0.0, -2.0,\n    1.0, 0.0, -1.0\n);\nconst float sobel_y[9] = float[](\n    1.0, 2.0, 1.0,\n    0.0, 0.0, 0.0,\n    -1.0, -2.0, -1.0\n);\n\n// gaussian kernel\nfloat gaussian[5] = float[](0.204164, 0.304005, 0.304005, 0.304005, 0.204164);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // show original picture first 2.5 seconds\n    if(iTime < 5.0 / 2.0)\n    {\n        fragColor = texture(iChannel1, uv);\n    }\n    \n    // then do a switch between sobel and gaussian\n    else\n    {\n        // switch between them every 2.5 secs\n        float timeInInterval = mod(iTime, 5.0);\n        bool toggleState = (timeInInterval < (5.0 / 2.0));\n\n        if(toggleState)\n        {\n            \n            vec2 texOffset = 1.0 / iResolution.xy; \n\n            // grad accumulation\n            vec4 grad_x = vec4(0.0);\n            vec4 grad_y = vec4(0.0);\n\n            // go over neighbors\n            for(int i = -1; i < 2; i++)\n            {\n                for(int j = -1; j < 2; j++)\n                {\n                    int sobel_index = (i + 1) * 3 + (j + 1);\n                    \n                    float neighbor_u = (fragCoord.x + float(i)) / iResolution.x;\n                    float neighbor_v = (fragCoord.y + float(j)) / iResolution.y;\n                    vec2 neighbor_coord = vec2(neighbor_u, neighbor_v);\n                    // convolve with sobelx and sobely\n                    grad_x += texture(iChannel1, neighbor_coord) * sobel_x[sobel_index]; \n                    grad_y += texture(iChannel1, neighbor_coord) * sobel_y[sobel_index]; \n                }\n            }\n\n            // l2 norm of gradient\n            vec3 grad_norm = sqrt(grad_x.rgb * grad_x.rgb + grad_y.rgb * grad_y.rgb);\n            fragColor = vec4(grad_norm, 1.0);\n        }\n\n        else\n        {\n            vec4 kernel_sum = vec4(0.0);\n            //go over neighbors\n            for(int i = -2; i <= 2; i++)\n            {\n                for(int j = -2; j <= 2; j++)\n                {\n                    // extract neighbor coords\n                    float neighbor_u = (fragCoord.x + float(i)) / iResolution.x;\n                    float neighbor_v = (fragCoord.y + float(j)) / iResolution.y;\n                    vec2 neighbor_coord = vec2(neighbor_u, neighbor_v);\n                    \n                    // convolve with gaussian\n                    kernel_sum += texture(iChannel1, neighbor_coord) * gaussian[i+2] * gaussian[j+2];\n                }\n            } \n\n\n            fragColor = kernel_sum;\n        }\n    \n    }\n    \n    \n        \n}\n","name":"Image","description":"","type":"image"}]}