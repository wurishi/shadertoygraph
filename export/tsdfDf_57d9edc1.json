{"ver":"0.1","info":{"id":"tsdfDf","date":"1606207118","viewed":9792,"name":"blood cells","username":"Carandiru","description":"carbon nanotubes of blood\n\nhttps://cineshader.com/view/tsdfDf","likes":6,"published":3,"flags":0,"usePreview":0,"tags":["wave","dimension","cineshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// - carandiru\n// http://bit.ly/supersinfulsilicon\n\n// shader is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/tsdfDf\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define PI (3.14159265358979323846)\n\n#define EPSILON 0.000000001f\n#define light rgb\n#define tran a\n#define MIN_STEP 0.00005f\t// absolute minimum before performance degradation or infinite loop, no artifacts or banding\n#define MAX_STEPS 199.0f\n#define CAMERA_SPEED 0.111f\n\n#define ZOOM 0.4f  \t\t// less = more zoom\n\n#define sq(a) (a*a)\n\nconst float k_sqrtMaxSteps = sqrt(MAX_STEPS);\nconst vec3  k_eyePos = vec3(-120.0f, -84.851589f, -120.0f).xzy * 0.1f * ZOOM;\nconst float k_VolumeDimensions = (MAX_STEPS);\nconst float k_InvVolumeDimensions = 1.0f / k_VolumeDimensions;\n\nvec2 intersect_box(in vec3 orig, in vec3 dir) {\n\n\tvec3 inv_dir = 1.0f / dir;\n\tvec3 tmin_tmp = (vec3(-1.0f) - orig) * inv_dir;\n\tvec3 tmax_tmp = (vec3(1.0f) - orig) * inv_dir;\n\tvec3 tmin = min(tmin_tmp, tmax_tmp);\n\tvec3 tmax = max(tmin_tmp, tmax_tmp);\n\n\treturn vec2(max(tmin.x, max(tmin.y, tmin.z)), min(tmax.x, min(tmax.y, tmax.z)));\n}\n\n#define fma(a,b,c) ((a) * (b) + (c))\n\nvec3 v3_rotate_azimuth(in vec3 p, in float angle)\n{\n    vec2 inOrient = vec2(cos(angle), sin(angle));\n    \n\treturn vec3(fma(p.x, inOrient.x, -p.y * inOrient.y),\n\t\t\t\tfma(p.x, inOrient.y, p.y * inOrient.x),\n\t\t\t\tp.z);\n}\n\nfloat tT;\nfloat fetch_distance(in vec3 uv)\n{   \n    float t0 = tT;\n    vec2 x0 = uv.xy * (0.25*PI)/(uv.z);\n    \n    vec2 c = (x0 - t0) - floor(x0 - t0);\n    \n    vec4 y0;\n    y0.xy = abs(c * 2.0f - 1.0f);\n    y0.zw = abs(c * 2.0f - 1.0f) * 1.0f / (0.5f + pow((2.0f*PI) - uv.x, 2.0f));\n    \n    vec2 j = abs(vec2(sin(t0), cos(t0)));\n    \n    vec4 a;\n    a.xy = j.y + y0.xy * j.x;\n    a.zw = -j.x + y0.xy * j.y;\n    \n    vec4 b;\n    b.xy = j.y + y0.zw * j.x;\n    b.zw = -j.x + y0.zw * j.y;\n     \n    a *= uv.z;\n    b *= uv.z; \n    \n    vec2 y1 = (b.xy - a.zw) + (b.zw - a.xy);\n    \n    return length(y1 - y0.xy) - length(y1 - y0.zw);\n}\n\nvec3 fetch_normal(in vec3 uvw, in vec3 rd, in float dt)\n{\n\tvec3 gradient;\n\n\tgradient.x = fetch_distance(uvw + (vec3(dt, 0.0f, 0.0f) * rd)) - fetch_distance(uvw - (vec3(dt, 0.0f, 0.0f) * rd));\n\tgradient.y = fetch_distance(uvw + (vec3(0.0f, dt, 0.0f) * rd)) - fetch_distance(uvw - (vec3(0.0f, dt, 0.0f) * rd));\n\tgradient.z = fetch_distance(uvw + (vec3(0.0f, 0.0f, dt) * rd)) - fetch_distance(uvw - (vec3(0.0f, 0.0f, dt) * rd));\n\n    // bugfix: nan, add epsilon\n\treturn( -normalize(gradient + EPSILON) ); // normal from central differences (gradient) \n}\n\nvec2 texHeight(float d)\n{\n    return vec2(d, 1.0f - d);\n}\n\nvec3 eye;\nvec3 camera(in vec3 v)\n{\n    v.y -= 3.0f * (2.0f/3.0f); // center offset\n        \n    // orthographic isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    iso = v3_rotate_azimuth(iso, tT * CAMERA_SPEED);\n    \n    // camera world position\n    eye = v3_rotate_azimuth(k_eyePos, tT * CAMERA_SPEED);\n    iso = iso * k_eyePos;\n\n    return iso;\n}\n\n// Cherenkov radiation\n// - a (almost) pure natural source of blue noise (reality)\n// emission is also blue light when observed\n// Cherenkov radiation is a particle emission that travels\n// faster than the speed of light inside a specific medium (like water)\n// but is still slower than the speed of light in a vacuum (space)\n\n// the hypothetical \"tachyon\" derives from this type of radiation\n// however has never been observed or proven that they exist\n// tachyon's would be particles that travel faster than the speed of light in a vacuum\n//\n// the blue noise rabbit hole seems to be even more interesting\n// than I originally thought with its applications in cg....\nfloat cherenkov_radiation(out float b, in float h, in float dt)\n{\n    const float c = 299792458.0f;  // universal constant for speed of light in a vacuum (m/s)\n    const float n = 1.33f; // refraction index of water\n    const float e = 10e5f; // total energy emitted\n    const float q = 24e3f; // energy in a particle\n    \n    // n = refraction index of medium\n    // c/n < v < c  : speed of particle is greater than speed of light\n    //\t\t\t\t  in the medium, but still less than the speed of light in a vacuum\n    // B = v/c\t\t: speed of particle in medium / speed of light\n    // cos = 1/(nB) : angle of emission\n    \n    // (modified) frank-tamm formula\n    // sq(d) * e      sq(q)                sq(c)\n    // ---------  =  -------  *  1 -  --------------- \n    //     d           4pi             sq(v) * sq(n)\n    \n    //                sq(q) * (sq(n)*sq(v) - sq(c))\n    //     d       = -------------------------------\n    //                  4 * e * pi * sq(n) * sq(v)\n    \n    float v = c/n;\n    v += (h) * v * dt;\n    v = min(v, c);\n    \n    b = (1.0f / (n * (v / c)));\n    \n    float d;\n    d = sq(q) * (sq(n)*sq(v) - sq(c));\n    d /= 4.0f * e * PI * sq(n) * sq(v);\n    \n    return (d);\n}\n\n// rgb(0.222f,0.222f,1.0f) (far depth color) - royal blue (cooler)\nconst vec3 royal_blue = vec3(0.222f,0.222f,1.0f).bgr; // components are maximized\n// rgb(0.80f,0.65f,1.0f) (near depth color) - royal purle (warmer) \nconst vec3 royal_purple = vec3(0.80f,0.65f,1.0f).bgr; // components are maximized\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tT = iTime;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n  \tvec2 v = uv*2.-1.;\n\t    \n    // init raymarch\n    vec3 ro = camera(vec3(v.xy, 1.0f));\n\n    vec3 rd = normalize(-ro);\n    \n    vec2 t_hit = intersect_box(ro, rd);\n\tif (t_hit.x > t_hit.y) {\n        discard;\n        //fragColor = vec4(0);\n        //return;\n\t}\n\n\tt_hit.x = max(t_hit.x, 0.0f);\n    \n\tfloat interval_length = (t_hit.y - t_hit.x);\n    \n    float inv_num_steps = 1.0f / length(k_VolumeDimensions * abs(rd)); // number of steps for full volume\n\tfloat dt = (interval_length) * inv_num_steps;\t// dt calculated @ what would be the full volume interval\n    dt = max(MIN_STEP, dt);\n    \n    vec3 p = eye + t_hit.x * rd + 0.5f /*textureLod(iChannel0, uv, 0.0f).r*/ * rd * dt * 0.5f; // start with bluenoise jitter offset (up to 1/2 dt)\n    \n    // begin volumetric raymarch\n    vec4 voxel = vec4(vec3(0.0f), 1.0f);\n\t\n    for( float interval_remaining = interval_length; \n         interval_remaining >= 0.0f ; interval_remaining -= dt ) \n    {       \n\n        vec3 n = fetch_normal(p, rd, dt);\n        float d = fetch_distance(p);\n\t\t        \n        vec2 height = texHeight(d);\n        float wave = (height.x + (1.0 - height.y)) * 0.5f + 0.5;\n       \n        float dot_emission = 0.0f;\n        float rad = cherenkov_radiation(dot_emission, -d, dt);\n        \n        float NdotV = max(0.0f, dot(rd, n));\n        float fresnel = pow(1.0f - NdotV, 5.0f);\n        vec3 wave_light = royal_purple * royal_blue * dot_emission;\n        wave_light += fresnel * dot_emission * royal_blue;\n                           \n        vec3 light_color = wave_light * rad;\n\n        // integration\n        float sigmaS = wave;\n\t\tfloat sigmaE = max(EPSILON, sigmaS); // to avoid division by zero extinction\n                \n        vec3 Li = light_color * sigmaS;// incoming light\n        float sigma_dt = exp2(sigmaE * k_sqrtMaxSteps * dt * -2.0f);\n        vec3 Sint = (Li - Li * sigma_dt) / sigmaE; // integrate along the current step segment\n\n        voxel.light += voxel.tran * Sint; // accumulate and also take into account the transmittance from previous steps\n\n        // Evaluate transmittance to view independentely (change in transmittance)\n        voxel.tran *= sigma_dt;\n\n        if (voxel.tran < 0.1f)\n            break;\n        \n        p += (dt) * rd;\n    }\n    \n    // Output to screen\n    fragColor = vec4(voxel.light * (1.0f - voxel.tran),pow(1.0f - voxel.tran, 2.0f));\n}","name":"Image","description":"","type":"image"}]}