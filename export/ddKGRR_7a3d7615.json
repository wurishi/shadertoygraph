{"ver":"0.1","info":{"id":"ddKGRR","date":"1680616619","viewed":25,"name":"Balls of steel","username":"Makineta","description":"Pretty balls","likes":0,"published":1,"flags":16,"usePreview":0,"tags":["dsad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// vec2 left = textelFetch(iChannel0, ivec2(KEY_LEFT,0),0).x * vec2 (-1,0);\n\n//Colors\nvec3 blue = vec3(0.6, 0.67, 0.9);\nvec3 green = vec3(0.7, 0.7, 0.7);\nvec3 red = vec3(0.0, 0.0, 0.0);\nvec3 fragBlue = vec3(0.);\nvec3 fresnel = vec3(0.);\n\nfloat TAU = 6.2832;    \n\nvec3 BS= vec3(0.5f);\nfloat power= 5.0f;\nvec2 uv;\n\n//lights \nvec3 light = vec3(1.,1.,1.);\nvec3 lightColor = vec3(1.);\n\n//Camera\nvec3 cameraOrigin = vec3(0, 0., 5);\n\nstruct Material\n{\n    vec3 ambient;\n    vec3 diffuse;\n    vec3 specular;\n    float shininess;\n    float fresnel;\n    bool reflection;\n};\n\nstruct GO //Idea de Raul, me ha gustado\n{\n    vec3 origin;\n    float radius;\n    Material material;\n    int objectId;\n};\n\n//Hit struct\nstruct Hit\n{\n    vec3 normals;\n    vec3 point;\n    GO gameObject;\n    \n};\n\n\n//Sphere centers buffer\nGO spheres[3];\n\nfloat rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\nvec3 Fresnel(vec3 direction, vec3 normal, vec3 BS, float power)\n{\n    float cosTheta = dot(-direction,normal);\n    return BS + (1.0 - BS) * pow(1.0 - cosTheta, power);\n}\n\n//Return true if a hit was detected with any sphere\nbool HitsSphere(in vec3 origin, in vec3 direction, inout Hit hit, int ballId, inout float dist )\n{\n    bool ret = false;\n\n    //Ball Vars\n    vec3 C = spheres[ballId].origin;\n    vec3 Oc = C - origin;\n    float r = spheres[ballId].radius;\n    \n    //Ball Formula\n    float proj = dot(Oc, normalize(direction));\n    vec3 K = origin + normalize(direction) * proj;\n    float L1 = length(C-K);\n    float L2 = sqrt(r*r - L1 * L1);\n    float tSphere = proj - L2;\n    vec3 P = origin + normalize(direction) * tSphere;\n    vec3 normals = normalize(P - C);\n    \n    float zDistance = length(Oc + normals);\n    \n    //Print Ball\n    if(L1 < r  &&  tSphere >= 0. && (dist >= zDistance || dist < 0.0))\n    {\n        hit.normals = normals;\n        hit.point = P;\n               \n        hit.gameObject = spheres[ballId];\n        hit.gameObject.objectId = ballId;\n\n        dist = zDistance;\n        ret = true;\n    }\n    \n    return ret;\n}\n\nvec3 GetFloorColor(in vec3 point)\n{\n    float gridZ = mod(floor(point.z),2.0);\n    float gridX = mod(floor(point.x) + gridZ, 2.0);\n    return vec3(gridX);\n}\n\nbool HitsPlane(in vec3 origin, in vec3 direction, inout float tPlane, inout Hit _hit)\n{\n    bool ret = false;\n    \n    //Plane formula\n    float Py = -0.5f;\n    \n    tPlane = (Py - origin.y)/(direction.y);\n    _hit.point = origin + (direction * tPlane);\n    \n    if(tPlane > 0.01)\n    {\n        _hit.gameObject.objectId = -1;\n        _hit.normals = vec3(0., 1.0, 0.);\n        _hit.gameObject.material = Material(GetFloorColor(_hit.point),vec3(0.6f),vec3(0.3f),32.0f,0.3f,true);\n        \n        ret = true;\n    }\n    \n    return ret;\n}\n\n\nbool HitsAnySphere(vec3 origin, vec3 direction, inout Hit _hit, inout float dist, in int ignoreId)\n{\n    bool ret = false;\n    for(int i = 0; i < spheres.length(); i++)\n    {\n        if(ignoreId != i && HitsSphere(origin, direction, _hit, i, dist))\n        {\n            ret = true;\n        }\n    }\n    return ret;\n}\n\nbool HitsAnything(in vec3 origin, in vec3 direction, inout Hit hit, in int ignoreId)\n{\n    bool ret = false;\n    float tempdist = -1.0f;\n    float tPlane = -1.0;\n   \n    if(HitsPlane(origin, direction, tPlane, hit))\n    {\n        ret = true;\n    }\n    \n    if(HitsAnySphere(origin, direction, hit, tempdist, ignoreId))\n    {\n        ret = true;\n    }\n       \n    return ret;\n}\nvec3 SkyColor(vec2 uv)\n{\n    int OCTAVES = 8;\n    float col = 0.0;\n    float asum = 0.0;\n    \n    float divisions = 20.0;\n    \n    float a = 3.0;//Brightness\n    float f = 0.09;//Size\n    \n    for(int i = 0;i < OCTAVES;i++)\n    {\n        vec2 fbmUV = uv * f;\n        \n        vec2 iPos = floor(fbmUV * divisions);\n        vec2 fPos = fract(fbmUV*divisions);\n        fPos = smoothstep(0.,1.0,fPos);\n        \n        float c00 = hash(iPos);\n        float c10 = hash(iPos + vec2(1.0,0.0));\n        float c01 = hash(iPos + vec2(0.0,1.0));\n        float c11 = hash(iPos + vec2(1.0,1.0));\n    \n        float l0 = mix(c00,c10,fPos.x);\n        float l1 = mix(c01,c11,fPos.x);\n        float c = mix(l0,l1,fPos.y); \n        \n        col += c;\n        \n        asum += a;\n        \n        a*=0.5;\n        \n        f *= 1.5;\n    }\n    return  mix(vec3(col/ asum), blue , 0.7);       \n    \n}\n\nvec3 CalculateMaterialColor(Material material, vec3 normal, vec3 direction)\n{\n    vec3 ambient = lightColor * material.ambient;\n    \n    float diff = max(dot(normal, light),0.0);\n    vec3 diffuse = lightColor * (diff * material.diffuse);\n    \n    vec3 reflection = reflect(light, normal);\n    float spec = pow(max(dot(direction,reflection),0.0f), float(material.shininess));\n    vec3 specular = lightColor * (spec * material.specular);\n    return ambient + diffuse + specular;\n}\n\nvec3 DirectPassColor(vec3 rayDirection)\n{\n    fragBlue = SkyColor(vec2(rayDirection));\n    vec3 finalColor = fragBlue;\n  \n    float tPlane = 0.0;\n    Hit planeHit;\n    \n    if(HitsPlane(cameraOrigin, rayDirection, tPlane, planeHit))\n    {\n        finalColor = GetFloorColor(planeHit.point);\n    }\n\n    //Hard Shadows\n    Hit hit;\n    float dist = -1.0f;\n    float tempdist = dist;\n    \n    if(HitsAnySphere(planeHit.point, light, hit, dist, -1))\n    {\n        //Color de las sombras\n        finalColor = mix(vec3(0.0f),planeHit.gameObject.material.ambient,0.5f);\n    }\n\n    dist = -1.0f;\n    if(HitsAnySphere(cameraOrigin, rayDirection, hit, dist, -1))\n    {\n        if(tempdist >= dist || tempdist < 0.0 )\n        {\n            //Color basico del peloto\n            tempdist = dist;\n            finalColor = CalculateMaterialColor(spheres[hit.gameObject.objectId].material,hit.normals,rayDirection);//spheres[hit.gameObject.objectId].material.ambient;//vec3(dot(hit.normals, light));\n\n            //Shadow projected between spheres\n            for(int j = 0; j < spheres.length(); j++)\n            {\n                if(HitsAnySphere(hit.point + hit.normals * 0.01, light, hit, dist, hit.gameObject.objectId))\n                {\n                    //Color de la sombra\n                    finalColor = mix(spheres[hit.gameObject.objectId].material.ambient * 0.5f, spheres[j].material.ambient,0.5f);\n                    \n                }\n            }\n        }\n    }\n    return finalColor;\n}\n\n//Reflejo de todo\nvec3 ReflectionPassColor(vec3 rayDirection)\n{\n    vec3 direction2 = vec3(1., 1. , 1.);\n    direction2 = normalize(direction2);  \n    vec3 color = vec3(0.);\n    Hit hit;\n    \n    rayDirection = normalize(rayDirection);\n    //1 raycast\n    if(HitsAnything(cameraOrigin, rayDirection, hit, -1))\n    {\n            \n        color = vec3(dot(hit.normals, light));\n        vec3 ref;\n        vec3 colorRef = color;\n        vec3 point = hit.point;\n        if(hit.gameObject.objectId < 0)\n        {\n            fresnel = Fresnel(rayDirection, hit.normals, vec3(hit.gameObject.material.fresnel),1000.0f);\n        }\n        else\n        {\n            fresnel = Fresnel(rayDirection, hit.normals,vec3(hit.gameObject.material.fresnel),5.0f);\n        }        \n           \n        if(hit.gameObject.material.reflection)\n        {\n            //reflections\n            ref = reflect(rayDirection,  hit.normals);\n            \n            colorRef = mix(vec3(0.9f),blue, ref.y) * SkyColor(vec2(ref));\n                  \n        }\n        else\n        {\n            ref = refract(rayDirection,  hit.normals,0.f);\n            \n            colorRef = mix(vec3(0.9f),blue, ref.y) * SkyColor(vec2(ref) * float(hit.gameObject.material.ambient));\n            \n        }\n        \n        if(HitsAnything(point + rayDirection * 0.001, ref, hit, -1))\n        {\n            if(hit.gameObject.objectId == -1)\n            {\n                colorRef = mix(GetFloorColor(hit.point),vec3(0.f),0.5f);\n            }\n            if(hit.gameObject.objectId >= 0 && hit.gameObject.objectId <=2)\n            {\n                colorRef = max(vec3((dot(hit.normals, light)* 1.2f) * hit.gameObject.material.ambient),vec3(0.0f));\n            }\n        }\n     \n        //Color\n        color = colorRef;\n   }\n   else\n   {\n      color = vec3(0.);\n   }\n  \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = fragCoord/iResolution.xy;\n \n    uv = uv * 2. - vec2(1., 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 nearCoord = vec3((2.0*fragCoord)/iResolution.xy-1.0,0);\n    nearCoord.x *= iResolution.x/iResolution.y;\n    \n    cameraOrigin = 3.0*vec3(cos(1.0-iMouse.y/iResolution.y)*cos(TAU*iMouse.x/iResolution.x),\n                            sin(1.0-iMouse.y/iResolution.y),\n                            cos(1.0-iMouse.y/iResolution.y)*sin(TAU*iMouse.x/iResolution.x));\n    \n    vec3 target = vec3(0.,0.,0.);\n    \n    vec3 Z = normalize(cameraOrigin - target);\n    vec3 X = normalize(cross(vec3(0.0,1.0,0.0), Z));\n    vec3 Y = normalize(cross(Z, X));\n    \n    vec3 direction = normalize(X*nearCoord.x + Y*nearCoord.y - Z * 1.8f);\n\n    \n    light = normalize(light);\n    Material materials[3];\n    materials[0] = Material(vec3(1.,0.,0.),vec3(0.6f),vec3(0.3f),32.0f,0.7f,false);\n    materials[1] = Material(vec3(0.,1.,0.),vec3(1.0f),vec3(0.5f),10.0,0.5f,true);\n    materials[2] = Material(vec3(0.,0.,1.),vec3(0.6f),vec3(0.6f),32.0f,0.5f, true);\n    \n    //Ball Positions + Shading\n    spheres[0] = GO(vec3(0.0f, 0.0f, 0.f),0.5f,materials[0],-2);\n    spheres[1] = GO(vec3(0.7f, 0.5f, -0.7f),0.5,materials[1],-2);\n    spheres[2] = GO(vec3(0.9f, 0.0f, 0.7f),0.5,materials[2],-2);\n   \n    //Anti antialiasing\n    float dx = dFdx(direction.x);    \n    float dy = dFdy(direction.y);  \n    \n    vec3 finalColor = vec3(0.0f);\n    for(int x = -1; x <= 1;++x)\n    {\n        for(int y= -1; y <= 1;++y)\n        {\n            vec3 aaDir = normalize(vec3(direction.x + dx * float(x), direction.y + dy * float(y),direction.z));\n            vec3 directPass = DirectPassColor(direction);\n            vec3 reflectionPass = ReflectionPassColor(direction);\n            finalColor += mix(directPass, reflectionPass, fresnel);\n        }        \n    }\n\n    finalColor /= 9.f;\n    \n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}