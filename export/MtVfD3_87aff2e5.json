{"ver":"0.1","info":{"id":"MtVfD3","date":"1544402189","viewed":172,"name":"Terra","username":"jpechevarria","description":"Terrain generator... first attempt","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 2000\n#define EPSILON 0.1\n#define EYE_DIST 10.0\n#define RAY_STEP 0.02\n#define MAX_ELEVATION 5.0\n#define MAX_DIST 100.0\n#define DETAIL 1.0\n\nfloat sphereSDF(vec3 p, float radio) {\n    // SPHERE\n    return length(p) - radio;\n}\n\nfloat terrainSDF(vec3 p) {\n\tfloat base = 0.0; \n   \t//base = 0.5 * sin(iTime);\n    vec2 uv = p.xy;\n    uv.x /= 256.0;\n    uv.y /= 256.0;\n    uv += 0.2;\n    //uv.x -= iTime*0.05;\n    //uv.x /= iChannelResolution[0].y/iChannelResolution[0].x;\n    //uv.x -= iTime/4.0; \n    /// 16.0;\n    //uv.x += 0.001;\n    //uv += iTime0.5;\n    vec4 tx = texture(iChannel0,uv);\n    \n    float elevation;\n\t//elevation = (tx.x + tx.y + tx.z) * 0.3333;\n    elevation = tx.r;\n    //elevation = trunc(elevation  * 4.0 ) / 4.0;\n\n    if ( DETAIL >= 1.0 )\n    {\n    \ttx = texture(iChannel0,p.xy/128.0);\n    \televation += (tx.r-0.1) * 0.5;\n\n        if ( DETAIL >= 2.0 )\n        {\n            tx = texture(iChannel0,p.xy/64.0);\n            elevation += (tx.r-0.1) * 0.25;\n            \n            if ( DETAIL >= 3.0 ) \n            {\n\t            tx = texture(iChannel1,p.xy/64.0);\n            \televation += ((tx.r-0.5) * 0.025);\n            }\n        }\n    }\n    //elevation = length(tx.rgb) / 1.73;\n    elevation *= MAX_ELEVATION;\n    //elevation = pow(1.0*elevation,1.5);\n    //elevation = 2.0 * elevation - smoothstep(0.0,1.0,elevation);\n\treturn p.z - (base + elevation);\n}\n\nfloat sceneSDF(vec3 p, out int mat) {\n      \n    return terrainSDF(p);\n    //return sphereSDF(p,2.0);\n    \n}\n\nfloat rayMarch(vec3 eye, vec3 viewRayDirection, out int mat, out float d) {\n    float start = 0.0;\n    float end = MAX_DIST;\n    float depth = start;\n    float dist;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        //vec3 col;\n        dist = sceneSDF(eye + depth * viewRayDirection, mat);\n        if (dist < EPSILON) {\n            // We're inside the scene surface!\n            d= dist;\n            return depth;\n        }\n        // Move along the view ray\n        //depth += dist;\n        // Move single Step\n        if ( dist > MAX_ELEVATION + EPSILON )\n            depth += dist - MAX_ELEVATION;\n        else\n            depth += RAY_STEP;\n\n        if (depth >= end) {\n            // Gone too far; give up\n            d = dist;\n            return end;\n        }\n    }\n    d = dist;\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    int col;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z),col) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z),col),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z),col) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z),col),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON),col) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON),col)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y/iResolution.x;\n\n    \n    vec3 eye, lookAt;\n    // ROTATING EYE - LOOKING AT THE ORIGIN\n\t/*eye = vec3(0.0,0.0,5.0);\n    eye.x = EYE_DIST * cos(0.5*iTime);\n    eye.y = EYE_DIST * sin(0.5*iTime);\n    lookAt = vec3 ( 0.0, 0.0, 0.0 );\n\t*/\n    \n    // MOVING FORWARD EYE\n    ///*\n\teye = vec3(0.0,0.0,7.0);\n    vec2 movingEyeDir = vec2(0.6,0.2);\n    eye.xy += 20.0 * iTime * movingEyeDir;\n    lookAt.xy = eye.xy + EYE_DIST * movingEyeDir;\n    lookAt.z = 4.0;// eye.z - 5.0;\n    //lookAt = vec3 ( eye.x + 0.9  * EYE_DIST, eye.y + 0.1 * EYE_DIST, eye.z - 5.0);\n\t//*/\n    \n        \n    \n    vec3 eyeDir = normalize(lookAt - eye);\n    vec3 up = vec3 ( 0.0, 0.0, 1.0 );\n    vec3 right = normalize(cross(eyeDir,up));\n    up = cross(right,eyeDir);\n    \n    vec3 screen = eye + eyeDir + uv.x * right + uv.y * up;\n    vec3 rayDir = normalize(screen - eye);\n    \n    int material;\n    float ds;\n    float dist = rayMarch(eye, rayDir, material, ds);\n    \n    vec3 p = eye + rayDir * dist;\n    \n    if ( dist < MAX_DIST*0.9)\n    {\n    \n        vec3 normal = estimateNormal(p);\n\n        /*dist = smoothstep(0.7,1.0,dist);\n        if ( dist > 0.5 )\n            dist = 1.0;\n        else\n            dist = 0.0;\n        */\n        //fragColor = vec4(dist);\n        fragColor = vec4(normal,1.0);\n        //float col = dot(normal,vec3(0.0,0.0,1.0));\n        //col = smoothstep(0.0,1.0,col);\n        //fragColor = vec4(col);\n\n        // AGUA\n        float elevation = p.z / MAX_ELEVATION;\n        if ( elevation < 0.3 )\n        {\n            fragColor = vec4(0.0,0.0,0.3,1.0) + vec4(0.0,0.0,0.7,1.0) * smoothstep(-0.3,0.4,elevation) ;\n        }\n        // VEGETACION\n        else if ( elevation < 0.6 )\n        {\n            fragColor = vec4(0.0,0.392,0.0,1.0);\n            fragColor *= dot(normal,vec3(0.0,0.0,1.0));\n        }\n        // TIERRA\n        else if ( elevation < 0.99 )\n        {\n            fragColor = vec4(0.545,0.271,0.075,1.0);\n            fragColor *= dot(normal,vec3(0.0,0.0,1.0));\n        }\n        else \n        {\n            fragColor = vec4(1.0);\n            fragColor *= dot(normal,vec3(0.0,0.0,1.0));\n        }\n        float eyeDist = length(p-eye);\n        fragColor *= (1.0-smoothstep(0.0,1.0,eyeDist/MAX_DIST));\n        \n        /*if ( ds < 0.0 )\n            fragColor = vec4(1.0);\n        fragColor = vec4(dist/(3.0*EYE_DIST));\n\n\t\t*/\n    }\n    else\n    {\n        fragColor = vec4(0.0,0.0,0.1,1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}