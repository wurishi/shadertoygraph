{"ver":"0.1","info":{"id":"fstXW2","date":"1633984524","viewed":78,"name":"Simon's Basic 1","username":"dan6282","description":"Inspired by some old C64 Simon's Basic code","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["c64","myfirstshader","30yearson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define shadertoy 1\n//#define GLSL 1\n\nuniform float u_time;\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\n\n#define M_PI 3.1415926535897932384626433832795\n\n#define MAX_POINTS 5\n#define NUM_POINTS 4\n\n#define MAX_ACT 5\n#define FLASH_TIME 0.3\n#define FRACTION_EFFECT 1.0/0.7\n#define SLOW_DOWN 2.0\n//#define SLOW_DOWN 0.1\n\nconst vec2 freq_shift = vec2(1,1.2);\nconst vec2 phase_shift = vec2(-0.5,0);\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 compute_color( in float t , int type) {\n    vec3 col;\n    if (type == 0) {\n        float val = floor(fract(t) * 2.0);\n        return (vec3(val,val,val));\n    }\n    if (type == 1) {\n        col=pal(t,vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    }\n    if (type > 1) {\n        col=pal(t,   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    }\n  \n    float f = t;\n    // shadowing\n    col *= 0.5 + 0.5*sqrt(4.0*f*(1.0-f));\n   // col *= smoothstep( 0.49, 0.47, abs(f-0.5) );\n    return(col);\n}\n\nfloat compute_height(\n        float animation_time,\n        vec2 coord, \n        vec2 points[MAX_POINTS], \n        float traj[MAX_POINTS]) {\n    vec2 pos[NUM_POINTS];\n    float prod_dist = 1.0;\n    for(int i=0;i<NUM_POINTS;i++) {\n        pos[i].xy = points[i].xy + traj[i] * sin(phase_shift.xy + freq_shift.xy * animation_time);\n        prod_dist *= distance(coord, pos[i]);\n    }\n    prod_dist = pow(prod_dist,1.0/float(NUM_POINTS));\n\n    float point = mod(prod_dist*100.0,10.0)/10.0;\n    //float point = ceil(prod_dist*100.0)/100.0;\n    \n    return (point);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n#ifdef GLSL\n    // glsl\n    float global_time = u_time;\n    vec2 global_resolution = u_resolution;\n#endif\n\n#ifdef shadertoy\n   // shadertoy\n    float global_time = iTime;\n    vec2 global_resolution = iResolution.xy;\n#endif\n\n    // choreography\n    float act_times[MAX_ACT]; \n    act_times[0] = 0.0 * SLOW_DOWN;\n    act_times[1] = 7.0 * SLOW_DOWN;\n    act_times[2] = 10.0 * SLOW_DOWN;\n    act_times[3] = 12.0 * SLOW_DOWN;\n    act_times[4] = 13.0 * SLOW_DOWN;\n\n    float animation_time = global_time;\n    float real_animation_time = global_time;\n    int current_act=MAX_ACT-1;\n    for (int act=0; act < (MAX_ACT-1); act++) {\n        if(global_time<act_times[act+1] && global_time>act_times[act]) {\n            current_act = act;\n            real_animation_time = \n                (global_time-act_times[act]);\n            animation_time = float(FRACTION_EFFECT) *\n                real_animation_time/(act_times[act+1]-act_times[act]);\n        }\n    }\n    \n    float coarsen_factor;\n    float pattern_time;\n    float fraction_shown;\n    int color_choice = 1;\n    if (current_act == 0) {\n        coarsen_factor = 70.0;\n        pattern_time = 4.0;\n        fraction_shown = fract(animation_time);\n        color_choice = 0;\n    }\n    if (current_act == 1) {\n        coarsen_factor = 100.0;\n        pattern_time = 4.0;\n        fraction_shown = fract(animation_time);\n        color_choice = 0;\n    }\n    if (current_act == 2) {\n        coarsen_factor = 1000.0;\n        pattern_time = 4.0;\n        fraction_shown = fract(animation_time);\n        color_choice = 0;\n    }\n    if (current_act == 3) {\n        coarsen_factor = 1000.0;\n        pattern_time = 4.0;\n        fraction_shown = fract(animation_time);\n        color_choice = 2;\n    }\n    if (current_act == MAX_ACT -1) {\n        coarsen_factor = 1000.0;\n        animation_time = global_time-act_times[MAX_ACT-1];\n        real_animation_time = global_time-act_times[MAX_ACT-1];\n        pattern_time = 4.0 + animation_time;\n        fraction_shown = 1.0;\n        color_choice = 2;\n    }\n\n\n    // init data\n\n    vec2 points[MAX_POINTS];\n    float traj[MAX_POINTS];\n    \n    points[0] = vec2(0.5,0.5);\n    points[1] = vec2(0.7,0.5);\n    points[2] = vec2(0.4,0.5);\n    points[3] = vec2(0.2,0.7);\n    points[4] = vec2(0.7,0.2);\n\n    traj[0] = 0.3;\n    traj[1] = -0.2;\n    traj[2] = -0.1;\n    traj[3] = -0.3;\n    traj[4] = 0.2;\n\n\n    // coordinate transform\n\tvec2 global_st = fragCoord.xy/global_resolution;\n    vec2 st = floor(global_st.xy * coarsen_factor)/coarsen_factor;\n \n   float current_fraction = \n        (st.y *  coarsen_factor + st.x )/ coarsen_factor;\n    if (animation_time > 1.0) fraction_shown = 1.0;\n\n    float point = compute_height(pattern_time, st, points, traj);\n\n    vec3 col = compute_color(point, color_choice);\n\n\tif (current_fraction<fraction_shown) {\n        fragColor = vec4(col,1.0);\n    } else {\n        fragColor = vec4(0,0,0,1.0);\n    }\n\n    if (real_animation_time < FLASH_TIME) {\n        fragColor.x = clamp(real_animation_time*2.0/FLASH_TIME,0.0,1.0);\n        fragColor.y = clamp(real_animation_time*2.0/FLASH_TIME,0.0,1.0);\n        fragColor.z = clamp(real_animation_time*2.0/FLASH_TIME,0.0,1.0);\n        fragColor.w = 1.0;\n    }\n}\n\n#ifdef GLSL\nvoid main() {\n    mainImage(gl_FragColor,gl_FragCoord.xy);\n}\n#endif\n\n","name":"Image","description":"","type":"image"}]}