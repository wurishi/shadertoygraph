{"ver":"0.1","info":{"id":"7d2SDd","date":"1621444793","viewed":56,"name":"[WIP]","username":"Langwedocjusz","description":"wip","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["wip"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define USE_BOKEH\n\n#ifdef USE_BOKEH\n\n#define GOLDEN_ANGLE 2.39996\n#define ITERATIONS 100\n#define MAX_BLUR 0.1\n\nmat2 rot = mat2(cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n\n//Single pass bokeh, pinched from https://www.shadertoy.com/view/Wt23Ww\nvec3 Bokeh(sampler2D tex, vec2 uv, float radius, float aspect)\n{\n\tvec3 acc = vec3(0), div = acc;\n    float r = 1.;\n    vec2 vangle = vec2(0.0,radius*.05 / sqrt(float(ITERATIONS)));\n    float l = length(vangle);\n    \n\tfor (int j = 0; j < ITERATIONS; j++)\n    {  \n        r += 1. / r;\n\t    vangle = rot * vangle;\n        \n        //The only thing I added is aspect ratio correction here:\n        vec2 coords = uv + (r-1.) * vangle;\n        coords.y *= aspect;\n        vec3 col = texture(tex, coords).xyz;\n\t\tvec3 bokeh = pow(col, vec3(5.));\n\t\tacc += col * bokeh;\n\t\tdiv += bokeh;\n\t}\n\treturn acc / div;\n}\n\nfloat mask(vec2 uv){\n   vec2 coords = 2.0 * uv - 1.0;\n   float r = sqrt(coords.x * coords.x + coords.y * coords.y);\n   r = 4.0 * r - 3.5;\n   return clamp(r, 0.0, 1.0);\n   //return clamp(7.0*uv.y - 1.0, 0.0, 1.0);\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    #ifdef USE_BOKEH\n    vec2 uv = fragCoord.xy / iResolution.x;\n    vec2 uv2 = fragCoord.xy/iResolution.xy;\n    //fragColor = vec4(mask(uv2) * vec3(1.0), 1.0);\n    fragColor = vec4(Bokeh(iChannel0, uv, MAX_BLUR*mask(uv2), iResolution.x / iResolution.y), 1.0);\n\n    #else\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    fragColor = vec4(color, 1.0);\n    #endif\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_MARCH_STEPS 64\n#define MAX_MARCH_DIST 25.0\n#define MIN_MARCH_DIST 0.01\n\n#define MAX_SHADOW_DIST 10.0\n#define MIN_SHADOW_DIST 0.01\n\n#define MAT_DEFAULT 0\n#define MAT_FLOOR   1\n#define MAT_SPHERE  2\n#define MAT_WINDOW  3\n\n\n//---Primitive SDFs:\n\nfloat SphereSDF(vec3 point, float radius ){\n    return length(point) - radius;\n}\n\nfloat BoxSDF(vec3 point, vec3 box_dims ){\n    vec3 d = abs(point) - box_dims;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#define THICCNESS 0.01\n\nfloat horizontal_bars(vec3 point){\n    vec3 box_dims = vec3(0.75, THICCNESS, THICCNESS);\n    float separation = 0.75;\n    vec3 repetitions = vec3(0.0, 4.0, 0.0);\n    vec3 translation = vec3(0.0, 2.0 * THICCNESS, 0.0);\n    vec3 q = (point - translation) - separation * clamp(round((point - translation)/separation), vec3(0.0), repetitions);\n    return BoxSDF(q, box_dims);\n}\n\nfloat vertical_bars(vec3 point){\n    vec3 box_dims = vec3(THICCNESS, 4.0*0.5*0.75 + 3.0*THICCNESS, THICCNESS);\n    float separation = 0.5;\n    vec3 repetitions = vec3(3.0, 0.0, 0.0);\n    vec3 translation = vec3(-0.75, 4.0*0.5*0.75, 0.0);\n    vec3 q = (point - translation) - separation * clamp(round((point - translation)/separation), vec3(0.0), repetitions);\n    return BoxSDF(q, box_dims);\n}\n\nfloat Windows(vec3 point){\n    float separation = 4.0 * 0.5 + 2.0 * THICCNESS;\n    vec3 repetitions = vec3(1.0, 0.0, 0.0);\n    vec3 q = point - separation * clamp(round(point/separation), -repetitions, repetitions);\n    return min(horizontal_bars(q), vertical_bars(q));\n}\n\n\n//---Final scene:\n\nfloat Map(vec3 point){\n    //floor:\n    vec3 floor_dims = vec3(5.0, 0.1, 5.0),\n         floor_trans = vec3(0.0, -floor_dims.y, 0.0);\n    float dfloor = BoxSDF(point - floor_trans, floor_dims);\n    //sphere:\n    float radius = 0.5;\n    vec3 sphere_trans = vec3(sin(iTime), radius + 1.0 + cos(iTime), 0.0);\n    float dsphere = SphereSDF(point - sphere_trans, radius);\n    //windows:\n    vec3 win_trans = vec3(0.0, 0.0, 1.0);\n    float dwin = Windows(point - win_trans);\n    \n    //union:\n    return min(dfloor, min(dsphere, dwin) );\n}\n\n\nint MapMaterial(vec3 point){\n    //floor:\n    vec3 floor_dims = vec3(5.0, 0.1, 5.0),\n         floor_trans = vec3(0.0, -floor_dims.y, 0.0);\n    float dfloor = BoxSDF(point - floor_trans, floor_dims);\n    //sphere:\n    float radius = 0.5;\n    vec3 sphere_trans = vec3(sin(iTime), radius + 1.0 + cos(iTime), 0.0);\n    float dsphere = SphereSDF(point - sphere_trans, radius);\n    //windows:\n    vec3 win_trans = vec3(0.0, 0.0, 1.0);\n    float dwin = Windows(point - win_trans);\n    \n    //union:\n    float dist = min(dfloor, min(dsphere, dwin) );\n    \n    int id = 0;\n    if(dist == dfloor) id = MAT_FLOOR;\n    if(dist == dsphere) id = MAT_SPHERE;\n    if(dist == dwin) id = MAT_WINDOW;\n    return id;\n}\n\n//---Raymarching and pre-rendering functions:\n\nfloat March(vec3 origin, vec3 direction){\n    float total_dist = 0.0;\n    float current_dist;\n    for (int i=0; i<MAX_MARCH_STEPS; i++){\n        current_dist = Map(origin + total_dist * direction);\n        if (current_dist < MIN_MARCH_DIST){\n            return total_dist;\n        }\n        total_dist += current_dist;\n        if (total_dist >= MAX_MARCH_DIST){\n            return MAX_MARCH_DIST;\n        }\n        \n    }\n    return total_dist;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 point ){\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*Map( point + k.xyy*h ) + \n                      k.yyx*Map( point + k.yyx*h ) + \n                      k.yxy*Map( point + k.yxy*h ) + \n                      k.xxx*Map( point + k.xxx*h ) );\n}\n\n//https://iquilezles.org/articles/rmshadows\nfloat SoftShadows(vec3 origin, vec3 direction)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    float sharpness = 16.0;\n    for (float t = MIN_SHADOW_DIST; t < MAX_SHADOW_DIST;){\n        float h = Map(origin + direction*t);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, sharpness*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n//---Procedural textures:\n\nfloat hash(vec2 p ){\n\tfloat h = dot(p,vec2(127.1,311.7));\n\n    return -1.0 + 2.0*fract(sin(h)*43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//Lifted from https://www.shadertoy.com/view/Xlffzs\nvec3 Marble(vec2 uv){\n    vec2 coord = 0.21 * uv;\n    float value = noise(coord / 64.) * 64.;\n    value += noise(coord / 32.) * 32.;\n    value += noise(coord / 16.) * 16.;\n    value += noise(coord / 8.) * 8.;\n    value += noise(coord / 4.) * 4.;\n    value += noise(coord / 2.) * 2.;\n    value += noise(coord);\n    value += noise(coord / .5) * .5;\n    value += noise(coord / .25) * .25;\n    float v=0.55+0.5*sin(coord.x+coord.y+value);\n\treturn vec3(v+.0,v+.0,v+.0);\n}\n\n//---Materials:\n\nstruct material{\n    vec3 albedo;\n    float roughness;\n    float metallic;\n};\n\nmaterial getMaterial(vec3 point){\n    //roughness = 0.0 completely kills specular component\n    material mat;\n    mat.roughness = 0.5;\n    mat.metallic = 0.0;\n    \n    int id = MapMaterial(point);\n    \n    switch(id){\n        case MAT_DEFAULT:\n         mat.albedo = vec3(1.0);\n         break;\n        case MAT_FLOOR:\n         mat.albedo = Marble(100.0 * point.xz);\n         break;\n        case MAT_SPHERE:\n         mat.albedo = vec3(0.95, 0.93, 0.88);\n         mat.roughness = 0.5;\n         mat.metallic = 1.0;\n         break;\n        case MAT_WINDOW:\n         mat.albedo = vec3(1.0);\n         break;\n    }   \n    \n    return mat;\n}\n\n//---Lighting:\nconst float PI = 3.14159265359;\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0){\n    return F0 + (1.0 - F0) * pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness){\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness){\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness){\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2 ;\n}\n\n//Based on https://learnopengl.com/PBR/Lighting\n//Changed from point to directional\nvec3 PBR_Directional(vec3 point, vec3 ray, vec3 normal, material mat, vec3 light_direction, vec3 light_color, bool shadow){\n    vec3 view = - normalize(ray);\n    \n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, mat.albedo, mat.metallic);\n    \n    vec3 Lo = vec3(0.0);\n    \n    vec3 L = normalize(light_direction);\n    vec3 H = normalize(view + L);\n\n    vec3 radiance = light_color;\n    \n    float NDF = DistributionGGX(normal, H, mat.roughness);        \n    float G   = GeometrySmith(normal, view, L, mat.roughness);      \n    vec3 F    = fresnelSchlick(max(dot(H, view), 0.0), F0);\n    \n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - mat.metallic;\n    \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(normal, view), 0.0) * max(dot(normal, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001);\n    \n    float NdotL = max(dot(normal, L), 0.0);\n    vec3 diffuse = kD * mat.albedo / PI;\n    Lo += ( diffuse + specular) * radiance * NdotL;\n    \n    if(shadow) Lo *= SoftShadows(point, light_direction);\n    \n    return Lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalize coordinates to (-1:1) with aspect ratio correction\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //Raymarching\n    vec3 ray = normalize(vec3(uv, 1.1));\n    vec3 origin = vec3(0.0, 1.0, -3.0);\n    \n    vec3 sun_dir = normalize(vec3(0.0, 1.0, -1.0));\n    vec3 sun_col = vec3(1.0, 0.9, 0.7);\n    vec3 sky_dir = vec3(-sun_dir.x, sun_dir.y, -sun_dir.z);\n    vec3 sky_col = vec3(0.0, 0.4, 1.0);\n    \n    float dist = March(origin, ray);\n    \n    vec3 point = origin + dist * ray;\n    vec3 normal = getNormal(point);\n    vec3 color;\n    \n    material mat = getMaterial(point);\n    \n    //Background gradient\n    if (dist == MAX_MARCH_DIST){\n        color = (1.0 - uv.y) * vec3(0.0, 0.3, 1.0) + uv.y * vec3(0.0, 0.1, 1.0);\n    }\n    //Actual rendering\n    else {\n        color = 4.0 * PBR_Directional(point, ray, normal, mat, sun_dir, sun_col, true) \n              + 1.0 * PBR_Directional(point, ray, normal, mat, sky_dir, sky_col, false)\n              + 0.05 * mat.albedo;\n    }\n    \n    //Output\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define BLOOM_THRESHOLD 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    float brightness = dot(color, vec3(0.2126, 0.7152, 0.0722));\n    if(brightness > BLOOM_THRESHOLD)\n        color = color;\n    else\n        color = vec3(0.0, 0.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n//Gaussian Bloom based on\n//https://learnopengl.com/Advanced-Lighting/Bloom\n//I couldn't figure out a way to replicate \"ping-pong buffers\" in Shadertoy,\n//so i added some cheap and ugly additional blurring by using a lower mip","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define GAMMA 2.2\n#define EXPOSURE 3.0\n#define BLOOM_AMOUNT 0.2\n\nconst float Gaussian[5] = float[] (0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    float mip = 3.0;\n    vec2 tex_offset = 1.0 / vec2(float(textureSize(iChannel1, int(mip)).x),\n                                 float(textureSize(iChannel1, int(mip)).y));\n                                 \n    vec3 bloom = texture(iChannel1, uv, 1.0).rgb * Gaussian[0];\n    \n    for(int i = 1; i < 5; ++i){\n        bloom += texture(iChannel1, uv + vec2(tex_offset.x * float(i)), mip).rgb * Gaussian[i];\n        bloom += texture(iChannel1, uv - vec2(tex_offset.x * float(i)), mip).rgb * Gaussian[i];\n    }\n    \n    for(int i = 1; i < 5; ++i){\n        bloom += texture(iChannel1, uv + vec2(0.0, tex_offset.y * float(i)), mip).rgb * Gaussian[i];\n        bloom += texture(iChannel1, uv - vec2(0.0, tex_offset.y * float(i)), mip).rgb * Gaussian[i];\n    }\n    \n    color += BLOOM_AMOUNT * bloom;\n    \n    //Exposure tone mapping\n    color = vec3(1.0) - exp(-color * EXPOSURE);\n    //Gamma correction\n    color = pow(color, vec3(1.0 / GAMMA));\n    //Hack to retrieve some saturation lost with tone mapping\n    color = pow(color, vec3(1.5));\n    \n    //Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}