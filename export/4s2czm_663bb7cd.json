{"ver":"0.1","info":{"id":"4s2czm","date":"1491414489","viewed":408,"name":"Fluffy clouds","username":"jasondecode","description":"Fluffy cloud shader based on fbm noise","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","fbm","cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Tim Gerritsen\n// Title: Fluffy clouds\n\n#define PI 3.1415926536\n#define MAX_CLOUD_DEPTH 12\n#define MAX_NOISE_ITERATION 5\n\nuniform vec2 u_resolution;\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nfloat rand(vec3 p)\n{\n    return fract(sin( dot(p,vec3(1210.3,303.9,909.234234))) *1337.127213);\n}\n\nmat3 rotX(float a) { return mat3(1,0,0,0,cos(a),-sin(a),0,sin(a),cos(a)); }\nmat3 rotY(float a) { return mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a)); }\nmat3 rotZ(float a) { return mat3(cos(a),-sin(a),0,sin(a),cos(a),0,0,0,1); }\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60, -0.80,  0.36, -0.48, -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,  0.80,  0.36, -0.48,  0.60, -0.48,  0.64 );\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    vec2 o = vec2(0.0,1.0);\n\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = rand( p+o.xxx );\n    float b = rand( p+o.yxx );\n    float c = rand( p+o.xyx );\n    float d = rand( p+o.yyx );\n    float e = rand( p+o.xxy );\n    float f = rand( p+o.yxy );\n    float g = rand( p+o.xyy );\n    float h = rand( p+o.yyy );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( (k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                    2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                    k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                    k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nvec4 fbm( in vec3 x, int octaves )\n{\n    float f = 2.;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    vec3 d = vec3(0.0);\n    vec2 o = vec2(0.0,1.0);\n    mat3 m = mat3(o.yxx,o.xyx,o.xxy);\n    for( int i=0; i < MAX_NOISE_ITERATION; i++ ) {\n        vec4 n = noised(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m3*x;\n        m = f*m3i*m;\n    }\n    return vec4( a, d );\n}\n\nvec3 camRay(float fov, vec2 screenSize, vec2 uv)\n{\n    vec2 xy = uv - screenSize / 2.0;\n    float z = screenSize.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nRay initCamera(vec2 uv, vec2 resolution)\n{\n    vec3 camPosition = vec3(0,0,0);\n    vec3 camRotation = vec3(0.45,0,0);\n    float camFov = 75.;\n\n    vec3 forward = vec3(0.0,0.0,1.0);\n    vec3 up = vec3(0.0,1.0,0.0);\n    forward = normalize((rotY(-camRotation.y) * rotX(camRotation.x)) * forward);\n\n    vec3 normal = normalize(cross(forward, up));\n    up = normalize(cross(normal, forward));\n    vec3 ray = camRay(camFov, resolution, uv*resolution);\n    vec3 rayDirection = normalize(mat3(normal, up, -forward) * ray);\n\n    return Ray(camPosition, rayDirection);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    Ray ray = initCamera(uv.xy, iResolution.xy);\n    \n\tvec3 up = vec3(0.0, 50. - ray.origin.y, 0.0);\n    float cosalpha = abs(dot(ray.direction, normalize(up)));\n    float lengthToCloud = up.y / cosalpha;\n    float cloudStep = 1.5 / cosalpha;\n    vec3 forward\t= ray.direction * lengthToCloud;\n    \n    vec4 colorSkyFront = vec4(0.243, 0.51, 0.804, 1);\n    vec4 colorSkyBack = vec4(0.667, 0.753, 0.812, 0.003);\n    vec4 colorGroundFront = vec4(0,0.3,0,1);\n    vec4 colorGroundBack = vec4( 0, 0.14, 0, 0.001);\n    vec3 skyColor = mix(colorSkyFront.rgb, colorSkyBack.rgb, clamp(lengthToCloud * colorSkyBack.w, 0.0, 1.0)).rgb;\n    vec3 groundColor = mix(colorGroundFront.rgb, colorGroundBack.rgb, clamp(lengthToCloud * colorGroundBack.w, 0.0, 1.0)).rgb;\n\n    float pointingToAir = step(0.0, ray.origin.y + forward.y);\n    vec3 color = groundColor * (1.0 - pointingToAir);\n    float cloudness = 0.0;\n    float invCloudSize = .1/5.;\n    if (pointingToAir > 0.0) {\n        float depth = lengthToCloud;\n        ray.origin.xz += vec2(0,iTime*10.);\n\n        int lod = 0;\n        float lodDistance = 5.;\n        for (int i = 0; i < MAX_CLOUD_DEPTH; i++) {\n            vec3 p = (ray.origin + ray.direction * depth);\n            lod = int(floor((depth-50.0)/lodDistance*10.0/lengthToCloud));\n            int noiseIteration = 5 - lod;\n            float noise = fbm(p.xzy * invCloudSize,noiseIteration).x;\n            \n            cloudness += noise;\n            color += mix(vec3(0.1), vec3(1), float(i) / 30.) * noise * 0.45;\n            depth += cloudStep;\n        }\n\n        cloudness *= smoothstep(3., 15., cloudness);\n        color = mix(color, skyColor, clamp(1.0 - cloudness, 0.0, 1.0));\n        color = mix(color, skyColor, clamp(lengthToCloud*.001*0.003, 0.0, 1.0));\n    }    \n    \n    fragColor = vec4(color,1.);\n}","name":"Image","description":"","type":"image"}]}