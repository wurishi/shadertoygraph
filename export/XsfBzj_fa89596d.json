{"ver":"0.1","info":{"id":"XsfBzj","date":"1496883742","viewed":355,"name":"20170608_Spincode","username":"FMS_Cat","description":"2d something...","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// == defines ==================================================================\n#define BITS 16.0\n#define THR 0.5\n#define LOOPFREQ 2.0\n#define SCALE (iResolution.y * 0.1)\n#define VIG 0.0\n\n#define PI 3.14159265\n#define saturate(x) clamp(x,0.,1.)\n#define linearstep(a,b,x) saturate((x-a)/(b-a))\n\n// == vec2 to float hash =======================================================\nfloat random2( vec2 co ) {\n  return fract( sin( dot( co.xy, vec2( 2.9898, 7.233 ) ) ) * 4838.5453 );\n}\n\n// == main procedure ===========================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 p = ( fragCoord.xy * 2.0 - iResolution.xy ) / iResolution.y;\n\n  float radius = length( p ) * SCALE;\n  float layerI = floor( radius );\n  \n  if ( layerI < 2.0 ) {\n    fragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    return; // fast return\n  }\n\n  float ssThr = 2.0 / iResolution.y; // threshold of smoothstep\n  float theta = ( atan( p.y, p.x ) + PI ) / 2.0 / PI;\n\n  // make \"ring\"s\n  float layerF = fract( radius );\n  float ring = linearstep( 0.0, ssThr * SCALE, layerF );\n  ring *= 1.0 - linearstep( 0.0, ssThr * SCALE, layerF - 0.3 );\n\n  // define spinning velocity\n  float vel = 0.05 * ( random2( vec2( layerI, 3.155 ) ) - 0.5 );\n\n  // define number of segments\n  float seg = 1.0 + floor( layerI * 4.0 * pow( random2( vec2( layerI, 2.456 ) ), 2.0 ) );\n\n  // define seeds\n  float phase = fract( ( theta + iTime * vel ) * LOOPFREQ ) * seg;\n  float seed = floor( phase ); // seed of current segment\n  float seedN = mod( seed + 1.0, seg ); // seed of next segment\n\n  // calcurate state by seed and random\n  float stateI = random2( vec2( layerI, seed ) ) < THR ? 0.0 : 1.0;\n  float stateIN = random2( vec2( layerI, seedN ) ) < THR ? 0.0 : 1.0;\n\n  // make gradient for next segment\n  float state = mix(\n    stateI,\n    stateIN,\n    linearstep( 0.0, ssThr / length( p ) * seg / PI, fract( phase ) )\n  );\n\n  // final destination\n  fragColor = vec4( vec3( state * ring ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}