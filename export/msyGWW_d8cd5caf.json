{"ver":"0.1","info":{"id":"msyGWW","date":"1678507161","viewed":117,"name":"Desert Chest","username":"ianertson","description":"Use the mouse to look around :)\nIf you go into \"Buffer A\", you can also enable the \"WALK\" define at the top,\nthen you can walk around using WASD, fly up with space and fly down with shift.\n","likes":7,"published":1,"flags":48,"usePreview":1,"tags":["procedural","3d","raymarching","raymarch","materials","textures","material","art","desert","chest","cacti"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = texture(iChannel0, uv).rgb;\n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AA_SAMPLES 0\n\n#define R (iResolution.xy)\n#define T ((iFrame <= 1 || iTime <= 0.00003) ? 2.84 : iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define ZEROF (min(0.0, iTime))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\n#define AMBIENT 0.09\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n        light.type == LIGHT_POINT ? normalize(light.p - p) :\n            normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(distance(\n            light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xz, p.zy, round(adot(n, vec3(1, 0, 0)))), p.xy, round(adot(n, vec3(0, 0, 1))));\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 normal = normalize(cross(vec3(dx, bumpScale), vec3(dy, bumpScale)));\n    normal += bumpScale * normalize(normal);\n    \n   \n    vec3 next = normalize(wn+normal);\n    float dp = max(0.001, dot(wn, next));\n   \n    \n    return (mix(wn, next, mx*dp*length(next)));\n    \n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nvec3 aces(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define WALK 0\n\n\n\n#define NEAR 0.003\n#define FAR 98.0\n#define STEPS 96\n#define SHADOW_STEPS 33\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_CACTI 3\n#define ID_CHEST 4\n#define ID_CHEST_LOCKET 5\n#define ID_COIN 6\n\n#define CHEST_POS vec3(-1., 0, 1.)\n\n#define NOISE(P, SEED, LOD) (textureLod(iChannel3, ((P) + ((SEED)*1.98277215))/256., LOD).rgb)\n\nfloat rand(in vec2 p, in float seed) {\n    vec2 p2 = fract((p-(seed*3.392814))*40.9238125);\n    float r1 = fract(dot(p, p2)*3.9281854);\n    return fract(cos((r1+seed)*6.938871) * dot(p-p2, vec2(24.9382815, 29.777278152)));\n}\n\nfloat hash11(in float v, in float seed) {\n    float v2 = fract(v*10.09288218915);\n    return fract(sin((v2+seed)*8.992817885) * (1.0+fract(seed*10.98238712)));\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, float freq, float warp, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n        p += (n.xz+n.y)*warp;\n    }\n    return n / div;\n}\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    }\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, b) / dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba * h)-r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat groundSDF(in vec3 p) {\n    float h = 0.0;\n    \n    float area = smoothstep(2.0, 16.0, distance(p.xz, vec2(0.0)));\n    \n    float w = wnoise(p.xz, 6, 1.0);\n    float sz = exp(sin(p.z*0.2)-1.);\n    float sx = exp(cos(p.x*0.2)-1.);\n    \n    h += (w*0.1) * smoothstep(0.0, 10.0, distance(p.xz, vec2(0.0)));\n    h += sz * area;\n    h += sx * area;\n    \n    \n\n    return (p.y - h) / (1.0 + (h*0.25));\n}\n\nfloat cactiSDF(in vec3 p, in float seed) {\n    float r1 = hash11(seed, seed);\n    float r2 = hash11(r1+seed, seed+r1+0.0283912);\n    float r3 = hash11(r1+r2+0.08828115, seed*r1+0.983883);\n    \n    float h = 2.5 + (r1*r2*r2*(r2+(r3*6.)));\n    float w = (h / 2.3)+(r3*r3);\n    float r = 0.14;\n    r = mix(r, 0.12, r3*r2);\n    \n    p.xz *= rot(r2*TAU);\n    \n    \n    float sy = exp(sin((p.y+2.3+(r1*10.*r2))*16.28)-1.0);\n    \n    r += (sy*2.0-1.0)*mix(0.013, 0.011, r3*r3*r2);\n    \n    float c1 = lineSDF(p, vec3(0, 0, 0), vec3(0, h, 0), r);\n    \n    float sx = smoothstep(0.7, 1.3, sabs(p.x, 3.9 + (r1*0.1)));\n    float sz = smoothstep(0.7, 1.3, sabs(p.z, 3.9 - (r1*0.1)));\n    \n    vec2 idx = floor(p.xx*0.1);\n    vec2 idz = floor(p.zz*0.1);\n    \n    float r4 = rand(idx*32., seed+r1);\n    float r5 = rand(idz*32., seed+r2);\n    float ryx = r4*r4;\n    float ryz = r5*r5;\n    \n    \n    vec3 end2 = mix(vec3(w, 0, 0), vec3(w*0.45, 1.0 + ryx, 0), sx);\n    vec3 end3 = mix(vec3(0, 0, w), vec3(0, 1.0 + ryz, w*0.45), sz);\n    \n    float c2 = lineSDF(vec3(abs(p.x), p.y, p.z) - vec3(0, h-(h/2.2), 0),\n        vec3(0, 0, 0), end2, r);\n        \n    float c3 = lineSDF(vec3(p.x, p.y, abs(p.z)) - vec3(0, h-(h/2.2), 0),\n        vec3(0, 0, 0), end3, r);\n\n    float d = smin(smin(c1, c2, 0.09), c3, 0.09);\n\n    \n    return d/(1.3 + max(ryx, ryz));\n}\n\nfloat chestSDF(in vec3 p, in int skip, inout int id) {\n    id = ID_CHEST;\n    float dist = FAR;\n    vec3 size = vec3(0.5, 0.3, 0.3);\n    float taper = smoothstep(0.0, 1.0, max(0.0, abs(p.z))) * smoothstep(0.0, 1.0, max(0.0, p.y-0.01));\n    float box = boxSDF(p - vec3(0, size.y, 0), size + vec3(0, -taper, 0))-0.009;\n    \n    vec3 locketSize = size*vec3(0.15, 0.2, 0.15);\n    float locket = boxSDF(p - vec3(0, locketSize.y + (size.y-0.01), -(size.z-0.02)), locketSize)-0.009;\n    float locketHole = sphereSDF(p - vec3(0, locketSize.y + (size.y-0.03), -(size.y+0.042)), 0.02)-0.009;\n    locket = max(locket, -locketHole);\n    \n    float locketBulge = boxSDF(p - vec3(0, locketSize.y + (size.y-0.01), -((size.z-0.004)+0.08)), locketSize*0.89)-0.009;\n    locket = smax(locket, -locketBulge, 0.001);\n    \n    box = (box / (1.3 + taper));\n    \n    SAMPLE(box, ID_CHEST);\n    SAMPLE(locket, ID_CHEST_LOCKET);\n    return dist;\n}\n\nfloat coinSDF(in vec3 p) {\n    return cylSDF(p, vec3(0, 0, 0), vec3(0, 0.02, 0), 0.02);\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n    \n    //float box = boxSDF(p - vec3(0, 1, 0), vec3(1.0));\n    //SAMPLE(box, ID_BOX);\n    \n    float cacti1 = cactiSDF(p, 0.0288213);\n    SAMPLE(cacti1, ID_CACTI);\n    \n    float cacti2 = cactiSDF(p - vec3(1.9, 0, 0), 1.8763624);\n    SAMPLE(cacti2, ID_CACTI);\n    \n    float cacti3 = cactiSDF(p - vec3(-1.9, 0, 2.), 4.4439982);\n    SAMPLE(cacti3, ID_CACTI);\n    \n    int chestId = 0;\n    float chest = chestSDF(p - CHEST_POS, skip, chestId);\n    SAMPLE(chest, chestId);\n    \n    float coin1 = coinSDF(vec3(p.x, p.y, abs(p.z)) - vec3(-1, 0.0, 0.2));\n    SAMPLE(coin1, ID_COIN);\n    \n    \n    float idx = floor(p.x/1.5);\n    float idz = floor(p.z/1.5);\n    float rid = hash11(idx*2.5, idx+0.003215);\n    float ridz = hash11(idz*2.5, idz+1.928931);\n    float coin2 = coinSDF(vec3(abs(p.x+1.2-(ridz*0.5)), p.y, abs(p.z+0.01-(rid*0.5))) - vec3(0.4, 0.0, 0.4));\n    SAMPLE(coin2, ID_COIN);\n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    data.d = FAR;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    data.d = abs(d);\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL < 0.000001) return 1.;\n    \n    Data data = NEW_DATA;\n    data.skip = skip;\n    \n    float d = 0.0;\n    float r = 1.0;\n    float j = 0.0;\n    float ag = 0.0;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        ag += next;\n        r = min(r, next/0.5);\n        d += next*0.19;\n        j += 1.0;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= far) break;\n    }\n    ag /= j;\n    return clamp((ag+(r*r))*1.39, AMBIENT, 1.0);\n}\n\n//#define DEBUG_TEXTURE goldTexture\n\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    uv += 0.302123;\n    vec3 col = vec3(0.0);\n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    vec3 grain1 = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 grain2 = textureLod(iChannel3, (uv.yx + 0.0029837215)*1.1, 0.0).xyz;\n    \n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    float tile = 4.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile); vec2 slv = smoothstep(0.0, 1.0, lv);\n    vec2 alv = abs(lv*2.0-1.0);\n\n    float x = 1.0+fract(uv.x/2.);\n    float y = 1.0+fract(uv.y/2.);\n    \n    \n    float seed = 0.9827812;\n    float r = mix(\n        mix(rand(id, seed), rand(id + vec2(1, 0), seed), slv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    float ang = radians(mix(0.0, 45.0,  r));\n    vec2 k = vec2(r, r) + vec2(cos(ang), sin(ang));\n    \n    float pat1 = exp(cos(((k.y*2.0-1.0)*TAU*TAU*(k.x*2.0-1.0))-sin((alv.y*3.932812+alv.x)*3.))-1.);\n    \n    float pat = pat1*lf1.z*(0.5+(r*0.5));\n    \n    col = mix(col, col*col, pat);\n    \n    vec3 grainCol = mix(mix(mix(mix(c1, c2, grain1.x), c3, grain1.y), c4, grain1.z), c5, grain2.x);\n    \n    col = mix(col, grainCol, max(0.0, 1.0-(pat1*(0.5+(0.5*lf1.z))))*grain2.z);\n    \n    float dk = lf1.x*lf1.z;\n    col = mix(col, col*col, dk);\n    \n    m.z = clamp((grain1.x*0.01)+dk, 0.0, 1.0);\n    m.spec = clamp(dk+pat*grain2.x, 0.0, 1.0);\n    \n    \n    return col;\n}\n\nvec3 goldTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 warp = snoiseWarp(uv, 0.0389281, 0.3, 16.0, 0.5, 6);\n    vec3 hf1 = snoise(uv, 3.392815, 0.4, 100.0, 6);\n    vec3 lf1 = snoise(uv, 5.5987381, 0.2, 10.0, 6);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 hf2 = abs(normalize(reflect(cross(hf1*2.0-1.0, lf1*2.0-1.0), warp*2.0-1.0))); \n     \n    float scratches = max(0.0, 1.0-smoothstep(0.00, 0.07, abs(lf1.y*2.0-1.0)));\n    float scratches2 = max(0.0, 1.0-smoothstep(0.00, 0.07, abs(lf1.z*2.0-1.0)));\n    \n    vec3 c1 = rgb(159, 92, 5);\n    vec3 c2 = rgb(250, 220, 75);\n    vec3 c3 = rgb(243, 186, 79);\n    vec3 c4 = rgb(120, 43, 1);\n    vec3 c5 = rgb(182, 137, 45);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, warp.x), c3, warp.y), c4, warp.z);\n    col += col1;\n    \n    vec3 col2 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c5, hf1.z);\n    \n    scratches =  scratches*grain.y*lf1.x*hf1.z*0.9;\n    scratches2 = scratches2*grain.z*0.5;\n    \n    col = mix(col, col2, smoothstep(0.7, 0.2, lf1.x));\n    col = mix(col, col*col*col, grain.x*grain.y*grain.z*0.97);\n    col = mix(col, col+col, scratches);\n    col = mix(col, mix(col*col, c1, warp.z*grain.y), scratches2);\n    \n    float wear = hf2.x*hf2.y*(0.5+(0.5*grain.x));\n    col = mix(col, clamp(vec3(c5+c1+c3+0.5), 0.0, 1.0), wear);\n    \n    float rough = (wear+scratches+scratches2)/3.;\n    \n    m.spec = clamp(max(0.0, 1.0 - wear)+scratches, 0.0, 1.0);\n    m.metallic = clamp(max(0.0, 1.0 - (scratches+scratches2+wear)), 0.02, 1.0);\n    m.rough = clamp(rough*8., 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    \n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    float tile = 2.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lines = mod(length(vec2(alv.x/2., alv.y)), 0.4*cos(alv.y*(TAU-(alv.x/2.+hf2.y)))*hf2.z);\n    lines = max(0.002, 1.0-max(0.0, 0.5-lines));\n    \n    col = mix(col, col*col*col, lines);\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x*tile)*10.*lf1.y, sin((uv.y*tile)*TAU)*2.));\n    col = mix(col, mix(c1, c5, hf1.z), w2*0.6);\n    \n    float t2 = fract(uv.y*tile*2.);\n    float gs = smoothstep(0.5-0.25, 0.5+0.25, abs(t2*2.0-1.0)-0.5);\n    col = mix(col, col*col, gs);\n    \n    m.z = clamp((w2*lf1.x)*max(0.0, 0.5-gs), 0.0, 1.0);\n   // m.zm = max(0.02, m.z);\n    m.spec = clamp(w2*lf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 cactiTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(200, 211, 155);\n    vec3 c2 = rgb(96, 103, 74);\n    vec3 c3 = rgb(81, 91, 18);\n    vec3 c4 = rgb(140, 117, 59);\n    \n    vec3 c5 = rgb(213, 150, 74);\n    vec3 c6 = rgb(182, 128, 46);\n    vec3 c7 = rgb(101, 84, 21);\n    vec3 c8 = rgb(223, 205, 149);\n    \n    vec3 hf1 = snoise(uv, 3.02981241, 0.09, 156.0, 6);\n    vec3 hf2 = snoise(uv, 9.98287187, 0.1, 167.0, 6);\n    vec3 lf1 = snoise(uv, 10.9288111, 0.3, 8.0, 6);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    vec3 col2 = mix(mix(mix(c5, c6, hf2.x), c7, hf2.y), c8, hf2.z);\n    \n    col += col1;\n    \n    float tile =  16.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float r1 = rand(id, 2.983872123);\n    float r2 = rand(id, 10.77662711);\n    float r3 = rand(id, 32.98771155);\n    \n    \n    vec2 offset = (vec2(r1*2.0-1.0, r3*2.0-1.0))*0.01;\n    \n    float rad = mix(0.1 + (r1*0.09), 0.9, lf1.y*r1);\n    float fe = rad*0.2;\n    float points = max(0.0, 1.0-smoothstep(rad-fe, rad+fe, distance(alv, vec2(0.0) + offset)));\n    points *= r2*grain.x;\n    points *= 0.5;\n    \n    \n    float stripes = smoothstep(0.5-(hf2.x*hf2.y), 1.0, alv.y+hf2.z)*exp(cos(alv.x*12.+hf1.x+hf1.y+hf1.z));\n    stripes *= (0.1+smoothstep(0.8, 0.1, lf1.x+(grain.x*0.3)));\n    \n    col = mix(col, col2, stripes);\n    \n    col = mix(col, col*col, clamp(grain.x*lf1.y*hf1.z*2., 0.0, 1.0));\n    col = mix(col, col*col, points);\n    \n    col += grain.y*lf1.y*hf1.y*grain.z;\n    col /= (1.0 + (lf1.z*hf2.y));\n    \n    m.spec = clamp((stripes*3.)+(grain.y*0.2), 0.0, 1.0);\n    \n    m.z = clamp((luma(col)*0.002)+lf1.x+points+(stripes*0.01), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 sandTexture(in vec2 uv, in vec3 p, in float depth, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 0.392214, 0.2, 64.0, 6);\n    vec3 hf2 = snoise(uv, 4.492815, 0.05, 120.0, 3);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).rgb;\n    vec3 grain2 = abs(normalize(cross(grain*2.0-1.0, hf2*2.0-1.0)));\n    \n    \n    float w = wnoise(uv*11., 6, 1.);\n    \n    vec3 c1 = rgb(177, 125, 62);\n    vec3 c2 = rgb(225, 189, 129);\n    vec3 c3 = rgb(231, 181, 111);\n    vec3 c4 = rgb(180, 152, 117);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    col += col1 * (0.8+(0.2*w));\n    \n    vec3 col2 = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    col = mix(col, col2*col2, grain2.y*w*w);\n    col = mix(col, col*col, 0.3*max(0.0, 1.0-smoothstep(0.2, 1., w)));\n    \n    m.z = (luma(col)*0.00001)+w;//(w*hf1.x);\n    m.spec = clamp((hf1.x*hf2.y*0.2)+(grain.y*0.8), 0.0, 0.2);\n    \n    col = mix(col, col*col, grain.y*max(0.0, 1.0-smoothstep(0.0, 0.1, depth)));\n    \n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    float depth = data.d / FAR;\n    vec3 col = sandTexture(uv, p, depth, data.m);\n\n    \n    \n     \n    data.n = makeNormal(n, data.m.z, 0.3, 0.9);\n\n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    return texture(iChannel3, uv).rgb;\n}\n\nvec3 getAlbedoCacti(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = cactiTexture(uv, p, data.m).rgb;\n    data.n = makeNormal(n, data.m.z, 0.7, 0.9);\n    return col;\n}\n\nvec3 getAlbedoChest(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n    \n    if (p.y > 0.49) {\n        col = woodTexture(uv, p, data.m).rgb;\n        data.n = makeNormal(n, data.m.z, 0.7, 0.9);\n    } else {\n        uv = uv * 2.;\n        col = plankTexture(uv, p, data.m).rgb;\n        data.n = makeNormal(n, data.m.z, 0.7, 0.9);\n    }\n    return col;\n}\n\nvec3 getAlbedoChestLocket(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv*2.;\n    \n    \n    \n    vec3 col = goldTexture(uv, p, data.m).rgb;\n    data.n = makeNormal(n, data.m.z, 0.7, 0.9);\n    return col;\n}\n\n\nvec3 getAlbedoCoin(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    vec3 col = goldTexture(uv, p, data.m).rgb;\n    data.n = makeNormal(n, data.m.z, 0.7, 0.9);\n    return col;\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_CACTI: return getAlbedoCacti(data); break;\n        case ID_CHEST: return getAlbedoChest(data); break;\n        case ID_CHEST_LOCKET: return getAlbedoChestLocket(data); break;\n        case ID_COIN: return getAlbedoCoin(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getClouds(in vec3 rd) {\n    if (rd.y < -0.00001) return vec3(0.);\n    vec2 uv = rd.xz / rd.y;\n    vec3 col = vec3(0.0);\n    \n    float time = T*0.1;\n    \n    vec2 shift = vec2(cos(time), sin(time));\n    \n    vec3 lf1 = snoise(uv + shift, 0.028811, 0.2, 2.0, 6);\n    vec3 lf2 = snoise(uv - shift, 1.987766, 0.1, 3.0, 6);\n    \n    vec3 hf1 = snoise(uv + shift, 3.333398, 0.0, 10.0, 6);\n    vec3 hf2 = snoise(uv - shift, 7.776261, 0.1, 24.0, 6);\n    \n    vec3 mixer1 = snoise(uv + shift, 23.987271, 0.3, 2.5, 4);\n    vec3 mixer2 = snoise(uv - shift, 34.676622, 0.3, 2.5, 4);\n    vec3 mixer3 = snoise(uv + shift, 73.777324, 0.3, 2.5, 4);\n    \n    float low1 = mix(mix(lf1.x, lf1.y, mixer1.x), lf1.z, mixer1.y);\n    float low2 = mix(mix(lf2.x, lf2.y, mixer2.x), lf2.z, mixer2.y);\n    \n    float high1 = mix(mix(hf1.x, hf1.y, mixer1.x), hf1.z, mixer1.y);\n    float high2 = mix(mix(hf2.x, hf2.y, mixer2.x), hf2.z, mixer2.y);\n\n    \n    float low = mix(low1, low2, mixer1.z);\n    float high = mix(high1, high2, mixer2.z);\n    \n    float clouds = mix(low, high, mixer3.x);\n    \n    clouds = pow(clouds, 2.0);\n    col += clouds;\n    \n    return col;\n}\n\nvec3 getSky(in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    col += pow(vec3(0.29, 0.59, 0.9), vec3(1.0 + dotup));\n    \n    float cloudFactor = smoothstep(0.0, 0.25, dotup);\n    \n    \n    if (cloudFactor > 0.00000001) {\n        vec3 clouds = getClouds(rd);\n        col += clouds * cloudFactor;\n    }\n    \n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.), L, n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 lightEffect(in Data data, in Light light, in vec3 ro, in vec3 rd, in float depth) {\n    vec3 col = vec3(0.0);\n    vec3 L = getLightDir(light, ro);\n    float VdotR = cdot(rd, L);\n\n    col += light.c * light.s * pow(VdotR, 16.0) * max(0.1, 1.0-smoothstep(1.0, 0.2, depth));\n    \n    return col;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.69), 2.0, LIGHT_AMBIENT);\n    \n    vec3 mixf = vec3(1.0);\n    \n    for (int j = ZERO; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            vec3 n = data.n;\n            vec3 p = data.p;\n            vec3 albedo = getAlbedo(data);\n            vec3 diffuse = albedo / M_PI;\n\n            for (int i = ZERO; i < NUM_LIGHTS; i++) {\n                Light light = lights[i];\n                col += forEachLight(data, light, ro, rd, diffuse) * mixf;\n                col += lightEffect(data, light, ro, rd, data.d / FAR) * mixf;\n            }\n            \n            float rough = clamp(data.m.rough, 0.0, 1.0); \n            if (rough >= 0.999) break;\n            \n            \n            float NdotV = dot(n, -rd);\n            float metallic = data.m.metallic;\n            \n            vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n            rd = reflect(rd, n);\n            ro = p+(n*NEAR*2.);\n            mixf = F;\n            data.skip = data.id;\n            //mixf *= max(0.00, 1.0-(rough*rough*rough));\n            //mixf /= (1.0 + float(j));\n        } else {\n            col += getSky(rd) * mixf;\n            break;\n        }\n    }\n    \n    depth = data.d / FAR;\n    \n    Light light = lights[0];\n    col += lightEffect(data, light, ro, rd, depth);\n    col += smoothstep(0.01, 1.5, depth) * light.c * light.c * max(0.0, 1.0 - smoothstep(0.0, 0.15, dotup));\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -2.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if WALK\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    ro += walk;\n    ro.y += fly.y;\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    #else\n    \n    if (length(m.xy) > 0.001 && m.z > 0.001 && iFrame > 1 && iTime > 0.00009) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        \n        ro += CHEST_POS;\n        float Y = 0.2;\n        ro.y += Y;\n        ro.y = max(Y, ro.y);\n    } else {\n        ro = vec3(0, 2.0, -5);\n        vec3 oro = ro;\n        \n        vec3 lookp = CHEST_POS + vec3(0, 1, 0);\n        vec3 ord = look(uv, lookp, ro);\n        rd = ord;\n        vec3 op = lookp;\n        \n        \n        float time = T*0.5;\n        float nrSteps = 9.0;\n        float transTime = 0.9;\n        float frame = 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(0, 0, -1.9), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(0, 0, -1.4), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS + vec3(0, -0.5, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(0, 0, -1.1), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(-2.5, 1.0, -0.5), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS + vec3(0, 0.2, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(-3.0, 2.0, 3.1), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS + vec3(0, 0.2, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(1.0, 2.0, 4.1), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS + vec3(0, 0.2, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(3.0, 4.0, 2.1), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, CHEST_POS + vec3(4.0, 6.0, -1.), time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, CHEST_POS + vec3(0, 0.5, 0), time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro = onCycle(ro, oro, time, nrSteps, transTime, frame);\n        lookp = onCycle(lookp, op, time, nrSteps, transTime, frame);\n        frame += 1.0;\n        \n        ro.y += 0.2;\n        rd = look(uv, lookp, ro);\n    }\n    \n    \n    \n    \n    #endif\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    float rt = 100.0;\n    float ft = 0.00001;\n    uv += vec2(sin(T*rt), cos(T*rt))*ft;\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    \n    ro.xz += vec2(cos(T*rt), sin(T*rt))*ft;\n    ro.y += sin(T*rt)*ft;\n    \n    rd.xz *= rot((mix(-ft, ft, 0.5+(0.5*cos(T*rt)))));\n    rd.xy *= rot((mix(-ft, ft, 0.5+(0.5*sin(T*rt)))));\n    \n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    \n    \n    #if AA_SAMPLES > 0 \n    for(float i=ZEROF; i < float(AA_SAMPLES); i++) {\n       for(float j=ZEROF; j < float(AA_SAMPLES); j++) {\n\t\t\n        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) - 0.5) / iResolution.y;\n        uv.xy += deltaUV / 2.0;\n        \n        \n        vec3 tmp = ro;\n        getRay(uv, m, tmp, rd);\n        \n        Data data = NEW_DATA;\n        col += render(data, ro, rd, depth);\n      }\n    }\n    \n    col /= float(AA_SAMPLES*AA_SAMPLES);\n    \n    #else\n    \n    \n    col += render(data, ro, rd, depth);\n    \n    #endif\n    col += (col*col*luma(col));\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    if (iFrame > 1) {\n        vec3 old = texture(iChannel1, fc.xy/R.xy).rgb;\n        col = mix(col, old, 0.49);\n    }\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    vec2 texel = 1.0 / vec2(textureSize(iChannel0, 0).xy);\n    \n    float depth = texture(iChannel0, uv).a;\n    vec3 center = texture(iChannel0, uv).rgb;\n    vec3 left = texture(iChannel0, uv + texel*vec2(-1., 0)).rgb;\n    vec3 right = texture(iChannel0, uv + texel*vec2(1., 0)).rgb;\n    vec3 up = texture(iChannel0, uv + texel*vec2(0, 1)).rgb;\n    vec3 down = texture(iChannel0, uv + texel*vec2(0., -1)).rgb;\n    \n    vec3 avg = (center+left+right+up+down)/5.;\n    col = avg;\n    \n    float ff = 0.2;\n    col = smax(col, smax(center, smax(left, smax(right, smax(up, down, ff), ff), ff), ff), ff);\n    col = mix(col, avg, 0.5);\n    col += luma(col)*col*col*col*col*0.91*max(0.0, 1.0 - depth);\n    \n    vec3 old = texture(iChannel1, uv).rgb;\n    \n    if (iFrame > 1) {\n        col = mix(col, old, clamp(luma(old)*0.6, 0.0, 0.61));\n    }\n    \n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/**\n\n    All stuff going on in this \"Buffer C\" tab is basically just some\n    amateur attempt at de-noising. (Plus some bloom and depth of field)\n\n    However, if you go into the \"Common\" tab and increase the \"AA_SAMPLES\" define,\n    less off this amateur de-noising stuff will be used.\n    (Be aware though, increasing AA_SAMPLES to a number above 2 makes my machine scream)\n\n*/\n\nvec4 getColor(in vec2 uv) { return texture(iChannel0, uv).rgba; }\n\nfloat cdiff(in vec3 a, in vec3 b) {\n    return distance(a, b);\n}\n\nfloat estNoise(in sampler2D samp, in vec2 uv) {\n    vec2 texel = 1.0 / vec2(textureSize(samp, 0).xy);\n    \n    vec3 a = texture(samp, uv).rgb;\n    vec3 b = texture(samp, uv + texel*vec2(-1., 0)).rgb;\n    vec3 c = texture(samp, uv + texel*vec2(1., 0)).rgb;\n    vec3 d = texture(samp, uv + texel*vec2(0, 1)).rgb;\n    vec3 e = texture(samp, uv + texel*vec2(0., -1)).rgb;\n\n    float ab = cdiff(a, b);\n    float ac = cdiff(a, c);\n    float ad = cdiff(a, d);\n    float ae = cdiff(a, e);\n    \n    float bc = cdiff(b, c)*0.9;\n    float bd = cdiff(b, d)*0.9;\n    float be = cdiff(b, e)*0.9;\n    \n    float cd = cdiff(c, d)*0.7;\n    float ce = cdiff(c, e)*0.7;\n    \n    float de = cdiff(d, e)*0.5;\n    \n    float n = ((ab + ac + ad + ae) +\n              (bc + bd + be) +\n              (cd + ce) +\n              (de)) / 10.;\n              \n    return clamp(pow(n, 2.0)*2.5, 0.0, 1.0);\n}\n\nvoid edgeKernel(inout vec4 n[9], sampler2D tex, vec2 coord, float width, float height)\n{\n  float w = 1.0/width;\n  float h = 1.0/height;\n\n  n[0] = texture(tex, coord + vec2( -w, -h));\n  n[1] = texture(tex, coord + vec2(0.0, -h));\n  n[2] = texture(tex, coord + vec2(  w, -h));\n  n[3] = texture(tex, coord + vec2( -w, 0.0));\n  n[4] = texture(tex, coord);\n  n[5] = texture(tex, coord + vec2(  w, 0.0));\n  n[6] = texture(tex, coord + vec2( -w, h));\n  n[7] = texture(tex, coord + vec2(0.0, h));\n  n[8] = texture(tex, coord + vec2(  w, h));\n}\n\nfloat edgeDetectSobel(sampler2D tex, vec2 coord) {\n\n  vec2 texSize = vec2(textureSize(tex, 0).xy);\n\n  vec4 n[9];\n  edgeKernel(n, tex, coord, texSize.x, texSize.y);\n\n  vec4 sobel_edge_h = n[2] + (2.0*n[5]) + n[8] - (n[0] + (2.0*n[3]) + n[6]);\n  vec4 sobel_edge_v = n[0] + (2.0*n[1]) + n[2] - (n[6] + (2.0*n[7]) + n[8]);\n  vec4 sobel = sqrt((sobel_edge_h * sobel_edge_h) + (sobel_edge_v * sobel_edge_v));\n\n  return clamp(max(max(sobel.r, sobel.g), sobel.b), 0.0, 1.0);\n}\n\nvec3 getAvg(in sampler2D samp, in vec2 uv) {\n    vec2 texel = 1.0 / vec2(textureSize(samp, 0).xy);\n    \n    vec3 a = texture(samp, uv).rgb;\n    vec3 b = texture(samp, uv + texel*vec2(-1., 0)).rgb;\n    vec3 c = texture(samp, uv + texel*vec2(1., 0)).rgb;\n    vec3 d = texture(samp, uv + texel*vec2(0, 1)).rgb;\n    vec3 e = texture(samp, uv + texel*vec2(0., -1)).rgb;\n\n    return (a + b + c + d + e) / 5.0;\n}\n\nvec3 boxBlur(vec2 uv, in float f) {\n  vec3 col = vec3(0.0);\n  const int filterSize = 8;\n  const int halfFilterSize = filterSize / 2;\n\n  const int start = -halfFilterSize;\n  const int end = -halfFilterSize + filterSize;\n\n  float shadow = 0.0;\n  vec2 texelSize = clamp(1.0+f, 1.0, 2.5) / vec2(textureSize(iChannel0, 0).xy);\n  int count = 0;\n  for(int x = start; x < end; ++x)\n  {\n      for(int y = start; y <= end; ++y)\n      {\n         vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n         vec3 bl = texture(iChannel1, uv + (vec2(x, y) * texelSize)).rgb;\n         next = mix(next, bl, 0.6*clamp(luma(bl)*10., 0.0, 1.0));\n         col += next;\n         count += 1;\n      }\n  }\n\n  col /= float(count);\n  return col;\n}\n\n\nvec3 getBloom(vec2 uv, float f) {\n    vec2 dx = dFdx(uv)*(2. + f);\n    vec2 dy = dFdy(uv)*(2. + f);\n    vec3 col = textureGrad(iChannel1, uv, dx, dy).rgb;\n    vec3 col2 = textureLod(iChannel1, uv, 2.2).rgb;\n    return max(col, col2);\n}\n\nvec3 processImage(in vec2 uv) {\n    vec4 rgba = getColor(uv);\n    float depth = rgba.a;\n    vec3 col = rgba.rgb;\n    vec3 old = iFrame <= 1 ? col : texture(iChannel2, uv).rgb;\n    \n    \n    float f = 1.0 / max(1.0, float(AA_SAMPLES));\n    \n    float no = estNoise(iChannel0, uv);\n    float edge = edgeDetectSobel(iChannel0, uv);\n    no += edge*0.45;\n    \n    vec3 boxBlurred = boxBlur(uv, depth);\n    vec3 bloomed = getBloom(uv, luma(col)*3.);\n    bloomed = max(bloomed, boxBlurred);\n    vec3 lodded = textureLod(iChannel0, uv, no*8.).rgb;\n    vec3 avg = getAvg(iChannel0, uv);\n    lodded = max(lodded, avg);\n    \n    float lum1 = luma(col);\n    float lum2 = luma(bloomed);\n    float lum = (lum1+lum2)/2.;\n    \n \n    col = mix(col, max(avg, textureLod(iChannel1, uv, edge*4.).rgb), f*f*0.5*edge*edge);\n    col = mix(col, bloomed, 0.6*lum*max(0.3, 1.0-(depth*depth)));    \n    vec3 mcol = max(old*0.89, max(col, max(avg, max(bloomed, lodded))));\n    col = mix(col, mcol, 0.77*clamp(pow(edge, 2.), 0.0, 1.0));\n    \n    \n    col = mix(col, max(col, old), 0.5*clamp(pow((edge+no)/1.5, 2.5)*2., 0.001, 0.65));\n    col = mix(col, boxBlurred, depth);\n    \n    \n    return clamp(col, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/R.xy;\n    \n    col = processImage(uv);\n    \n    O = vec4(col, 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}