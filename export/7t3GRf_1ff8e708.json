{"ver":"0.1","info":{"id":"7t3GRf","date":"1636433027","viewed":65,"name":"draw density of a cube","username":"mgjunior","description":"draw density of a cube","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["volumn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// #define multi\n\nfloat myShape(vec3 pos){\n    return 0.;  \n}\n\n// gradient is normal\nvec3 getNormal(vec3 pos){\n    float delta =0.01;\n    vec3 temp=vec3(myShape(pos+vec3(delta,0.,0.))-myShape(pos),\n                   myShape(pos+vec3(0.,delta,0.))-myShape(pos),\n                   myShape(pos+vec3(0.,0.,delta))-myShape(pos)\n                  );\n\treturn normalize(temp);\n}\n\nfloat density_f(vec3 p){\n    // return 1.;\n\n    // move path\n    float t =iTime;\n    // p=p+vec3(cos(t),0.,sin(t))+t*vec3(0.,1.,0.);\n    \n    //remap range\n    //p= 0.5*(p+vec3(1.));\n\n    //scale range\n    //p*=11.5;\n\n    float freq=8.;\n    float cube = abs(sin(freq*p.x)*sin(freq*p.y)*sin(freq*p.z));\n    float cube2 = max(0.,sin(freq*p.y)*sin(freq*p.x)*sin(freq*p.z));\n\n    freq=4.;\n    float ball=abs(sin(freq*p.x)+sin(freq*p.y)-sin(freq*p.z))/3.;\n    \n    //pillar\n    freq=4.5;\n    float pillar=max(0.,sin(freq*p.x)*sin(freq*p.z));\n    float pillar_solid =step(0.1,pillar);\n    //return pillar;\n\n    //return max(0.,ball);\n    return max(0.,ball-cube2-pillar+cube);\n    \n\n    //return max(0.,sin(2.*p.y+t));\n    //return dot(p,vec3(0.,1.,0.));\n}\n\nvec3 rainbowRamp(float v){\n    \n    v*=7.0;\n    v = min(7., v);\n\tvec3 color[7];\n    color[0]=vec3(1.,0.,0.);\n    color[1]=vec3(1.,0.27,0.);\n    color[2]=vec3(1.,1.,0.);\n    color[3]=vec3(0.,1.,0.);\n    color[4]=vec3(0.,1.,1.);\n    color[5]=vec3(0.,0.,1.);\n    color[6]=vec3(1.,0.,1.);\n    int index =int(floor(v));\n    return color[index];\n}\n\nvec3 shading(Ray ray,vec3 eye){\n    // box 3 axis and origin\n    vec3 box_origin=vec3(0.,0.,0.);\n    vec3 y_axis =vec3(0.,1.,0.);\n    float para_obj_rot=0.5*iTime;\n    vec3 z_axis = vec3(-sin(para_obj_rot),0.,cos(para_obj_rot));\n    vec3 x_axis =vec3(cos(para_obj_rot),0.,sin(para_obj_rot));\n\n    // to local space\n    Ray local_ray;\n    local_ray.from =toLocalPos(ray.from,x_axis,y_axis,z_axis,box_origin);\n    local_ray.dir=toLocalVec(ray.dir,x_axis,y_axis,z_axis);\n\n    vec3 local_eye = toLocalPos(eye,x_axis,y_axis,z_axis,box_origin);\n\n    // I got this method from here \"GPU编程与CG语言之阳春白雪下里巴人\" ch 15\n    // six side of box\n    vec3 n[6];\n    n[0]=vec3( 1.0, 0.0, 0.0 );\n    n[1]=vec3( -1.0, 0.0, 0.0 );\n    n[2]=vec3( 0.0, 1.0, 0.0 );\n    n[3]=vec3( 0.0, -1.0, 0.0 );\n    n[4]=vec3( 0.0, 0.0, 1.0 );\n    n[5]=vec3( 0.0, 0.0, -1.0 );\n\n    vec3 help_axis[6];\n    help_axis[0]=vec3( 0.0, 0.0, 1.0 );\n    help_axis[1]=vec3( 0.0, 0.0, 1.0 );\n    help_axis[2]=vec3( 0.0, 0.0, 1.0 );\n    help_axis[3]=vec3( 0.0, 0.0, 1.0 );\n    help_axis[4]=vec3( 1.0, 0.0, 0.0 );\n    help_axis[5]=vec3( 1.0, 0.0, 0.0 );\n   \n    vec3 color[6];\n    color[0]=vec3( 1.0, 0.0, 0.0 );\n    color[1]=vec3( 1.0, 0.0, 0.0 );\n    color[2]=vec3( 0.0, 1.0, 0.0 );\n    color[3]=vec3( 0.0, 1.0, 0.0 );\n    color[4]=vec3( 0.0, 0.0, 1.0 );\n    color[5]=vec3( 0.0, 0.0, 1.0 );\n\n    vec3 shadingColor =vec3(0.,0.,0.);\n\n    float near_hit=10000.;\n    float far_hit=0.;\n    vec3 near_p,far_p;\n    bool is_hit_box=false;\n    vec3 box_color;\n\n    // Find 2 endpoints that pass through the box\n    for(int i=0;i<6;++i){\n        vec3 plane_N=n[i];\n        vec3 plane_C=-plane_N;\n\n        vec3 hit_pos;\n        if(hitRect(local_ray,plane_N,plane_C,help_axis[i],1.0,1.0, hit_pos))\n        {\n            is_hit_box=true;\n\n            float d =length(hit_pos-local_eye);\n            if(d<near_hit){\n                near_hit =d;\n                near_p =hit_pos;\n            }\n\n            if(d>far_hit){\n                far_hit=d;\n                far_p=hit_pos;\n            }\n\n            if(dot(local_ray.dir,plane_N)>0.)\n                continue;\n                \n            box_color=color[i];\n        }\n    }\n\n    //test:check depth\n    // if(is_hit_box){\n    //     float depth=far_hit-near_hit; \n    //     float a =def_saturate(depth/2.82842712475);\n    //     vec3 fog=vec3(0.75,.55,0.25);\n    //     return vec3(a);\n    //     // return mix(box_color,fog,a);\n    // }\n\n    const int max_it=20;\n    if(is_hit_box){\n        float depth=far_hit-near_hit; \n        vec3 dir = normalize(near_p-far_p);\n        vec3 p=far_p;\n        float diff =depth/float(max_it);\n        vec3 value=vec3(0.);\n        float count=0.;\n        \n        for(int i=0;i<max_it;++i){\n            float d=density_f(p);\n            \n            //vec3 color =d*rainbowRamp(d);// use density to scale color\n            vec3 color=d*vec3(0.89,0.65,0.41);\n\n            float lower_opacity_factor=0.91;\n            value =mix(value,color,lower_opacity_factor*d);\n              \n            p+= diff*dir;\n        }\n\n        \n        return vec3(value);\n    }\n    \n    return shadingColor;\n}\n\nRay[4] createRayDiff(vec3 eye, vec3 xAxis,vec3 yAxis,vec3 p){\n    vec2[4] multisampleDiff;\n    float x = 0.5;\n    float y =0.5;\n    // offset from p\n    multisampleDiff[0]=vec2(x,y)/iResolution.y;   \n    multisampleDiff[1]=vec2(-y,x)/iResolution.y; \n    multisampleDiff[2]=vec2(-x,-y)/iResolution.y;\n    multisampleDiff[3]=vec2(y,-x)/iResolution.y;\n\n    Ray[4] rays;\n    for(int i=0;i<4;++i){\n        rays[i].from =p+( multisampleDiff[i].x*xAxis + multisampleDiff[i].y*yAxis );\n        rays[i].dir =normalize(rays[i].from-eye);\n    }\n\n    return rays;\n}\n\nRay createRay(vec3 eye, vec3 xAxis,vec3 yAxis,vec3 p){\n    Ray ray;\n    ray.from =p;\n    ray.dir =normalize(ray.from-eye);\n\n    return ray;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // weight (from -1 to 1)\n    vec2 weight = fragCoord/iResolution.xy;\n    weight= weight*2.0-1.0;\n   \n\n    vec3 lookAt =vec3(0.0,0.0,0.0);\n    //vec3 eye = vec3(0.0,10.0,10.0);\n    // vec3 eye = lookAt+ 7.0*vec3(cos(iTime),0.0,sin(iTime))+vec3(0.0,1.0,0.0);\n    vec3 eye = lookAt+ vec3(0.,0.0,3.0);\n\n    // camera 3 axis\n    vec3 z_axis = normalize(eye-lookAt);\n    vec3 y_axis = vec3(0.0,1.0,0.0);\n    vec3 x_axis = cross(y_axis,z_axis);\n    \n    //near plane of view frustum (z = -1)\n    float fovDegree =90.0;\n    float halfFov = radians(0.5*fovDegree);\n    float tanH = tan(halfFov);\n    float tanW = tanH*iResolution.x/iResolution.y;\n\n    // generate point from the plane\n    vec3 pointOnNearZ = eye -z_axis + x_axis*weight.x*tanW + y_axis*weight.y*tanH;\n    \n    // disturb ray dir\n    float A =0.025*sin(0.5*iTime);\n    pointOnNearZ+=vec3(A*sin(10.*weight.y+5.*iTime),A*cos(10.*weight.x+5.*iTime),0.);\n    \n\n    vec3 color= vec3(0.0,0.0,0.0);\n    #ifdef multi\n    \t// Antialiasing\n    \tRay[4] ray =createRayDiff(eye,x_axis,y_axis,pointOnNearZ);\n        for(int i=0;i<4;++i)\n            color += shading(ray[i],eye);\n        color *=0.25;\n    #else\n    \tRay ray =createRay(eye,x_axis,y_axis,pointOnNearZ);\n    \tcolor = shading(ray,eye);\n    #endif\n\n    fragColor = vec4(color,1.0);\n    // fragColor=texture(iChannel0,weight);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float PI=3.14;\nconst float epsilon = 0.001;  \n\nstruct Ray{\n    vec3 from;\n    vec3 dir;\n};\n\nvec3 toLocalPos(vec3 pos ,vec3 x,vec3 y, vec3 z,vec3 original){\n    vec3 diff =pos -original;\n    return vec3(dot(diff,x),dot(diff,y),dot(diff,z));\n}\n\nvec3 toLocalVec(vec3 dir ,vec3 x,vec3 y, vec3 z){\n    return vec3(dot(dir,x),dot(dir,y),dot(dir,z));\n}\n\nfloat degreeToRad(float degree){\n    return degree*PI/180.0;\n}\n\nfloat def_saturate(float v){\n    return v<0.?0.:(v>1.0?1.:v);\n}\n\nbool hitPlane(in Ray ray,in vec3 plane_N,in vec3 plane_C,inout vec3 hit_pos)\n{\n    // ray hit plane \n    vec3 from =ray.from;\n    vec3 dir = ray.dir;\n    //(F-C)。N + t (D。N) = 0\n    // t  = (C-F)。N / (D。N)\n    // t  = (A / (B)\n    float B = dot(dir, plane_N);\n    float A = dot(plane_C- from, plane_N);\n\n    // avoid divide by 0\n    if (abs(B) < epsilon)\n        return false;\n\n    float t = A / B;\n    hit_pos = from + t * dir;\n    \n    if(t>0.0)\n    \treturn true;\n}\n\nbool hitRect(in Ray ray,in vec3 plane_N,in vec3 plane_C,in vec3 plane_axis_x,float half_width,float half_height,inout vec3 hit_pos)\n{\n   \n    // ray hit plane \n    vec3 from =ray.from;\n    vec3 dir = ray.dir;\n    //(F-C)。N + t (D。N) = 0\n    // t  = (C-F)。N / (D。N)\n    // t  = (A / (B)\n    float B = dot(dir, plane_N);\n    float A = dot(plane_C- from, plane_N);\n\n    // avoid divide by 0\n    if (abs(B) < epsilon)\n        return false;\n\n    float t = A / B;\n    hit_pos = from + t * dir;\n\n    // 檢查範圍\n    vec3 planeAxisY = cross(plane_N,plane_axis_x);\n    vec3 diff =hit_pos - plane_C;\n    float x =dot(diff,plane_axis_x);\n    float y = dot(diff,planeAxisY);\n\n    if(t>0.0 && abs(x)<=half_width && abs(y)<=half_height){\n        return true;\n    }\n    else \n        return false;\n}\n","name":"Common","description":"","type":"common"}]}