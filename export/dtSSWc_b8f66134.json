{"ver":"0.1","info":{"id":"dtSSWc","date":"1676666287","viewed":38,"name":"Some graph plotter","username":"RayRayB","description":"This is a very simple graphic calculator I've put together.\n\nYou can adjust zoom by clicking and dragging horizontally on the screen\nLines 77 to 88 are different function to plot.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rectangle(vec2 uv, vec2 size)\n{\n    return step(.01, 1.-(step(size.x, abs(uv.x))+step(size.y, abs(uv.y))));\n}\n\nfloat grid(vec2 uv, float scale)\n{\n    float axes = step(.002*scale, abs(uv.y)) * step(.002*scale, abs(uv.x));\n    \n    vec2 of = uv;\n    \n    //kinda lacks elegance\n    //But before there where 4 while loop so... I've seen worse\n    for(int i=0; i<4; i++)\n    {\n        \n        float count = 0.;\n        float f = 0.;\n        vec2 of = uv;\n        vec2 stp = vec2(0.);\n        vec2 size = vec2(0.);\n        \n        switch(i)\n        {\n            case 0:\n                stp = vec2(1.0, 0.);\n                size=vec2(.003, 0.01);\n                break;\n                \n            case 1:\n                stp = vec2(-1.0, 0.);\n                size=vec2(.003, 0.01);\n                break;\n                \n            case 2:\n                stp = vec2(.0, 1.);\n                size=vec2(.01, 0.003);\n                break;\n                \n            case 3:\n                stp = vec2(.0, -1.);\n                size=vec2(.01, 0.003);\n                break;\n        }\n        \n        while(count < scale)\n        {\n            of += stp;\n            f = rectangle(of, size*scale);\n            axes -= f;\n            count++;\n        }\n    }\n    \n    float res = 1.-axes;\n    return res;\n}\n\nfloat plot(float value, vec2 uv, float scale)\n{\n    return smoothstep(value+0.01*scale, value, uv.y) * smoothstep(value-0.01*scale, value, uv.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    float ar =  iResolution.x/iResolution.y;\n    float mhr = iMouse.x / iResolution.x;\n    float mvr = iMouse.y / iResolution.y;\n    float gs = 10. + 20. * mhr;\n    \n    uv-=.5;\n    uv.x *= ar;\n    uv *= gs;\n    \n    //Uncomment lines below to change the plotted function\n    float v = uv.x;\n    //v = uv.x*uv.x;\n    //v = sin(uv.x);\n    //v*= sin(uv.x*3.);\n    //v*= sin(uv.x*1.5);\n    //v = cos(uv.x);\n    //v = atan(uv.x);\n    //v = 1./uv.x;\n    //v = log(uv.x);\n    //v = exp(uv.x);\n    //v = pow(uv.x, 5.)*.3 + pow(uv.x, 4.) + pow(uv.x, 3.)*0.;\n    \n    float func = plot(v, uv, gs);\n    \n    vec2 ae = fract(uv);\n    ae -= .5;\n    \n    vec3 col = vec3(1.);\n    col = mix(col, vec3(.9), vec3(1.-rectangle(ae, vec2(.48))));\n    col *= 1.-vec3(grid(uv, gs));\n    col = mix(col, vec3(.7, .3, 0.), func);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}