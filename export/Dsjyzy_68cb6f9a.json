{"ver":"0.1","info":{"id":"Dsjyzy","date":"1687853867","viewed":68,"name":"raymarching jump ball","username":"xuetaolu","description":"raymarching; 3D; animation;\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Helful Resources\n// ----------------\n// Ray Marching Blog Post by Michael Walczyk\n// https://michaelwalczyk.com/blog-ray-marching.html\n// Inigo Quilez SDF Functions\n// https://iquilezles.org/articles/distfunctions/\n// \n// JumpMotion function\n// https://graphtoy.com/?f1(x,t)=0.25&v1=true&f2(x,t)=1-pow(%20abs(2*fract((x-0.25)/0.25/2)-1),%202%20)%20&v2=true&f3(x,t)=&v3=true&f4(x,t)=&v4=true&f5(x,t)=&v5=false&f6(x,t)=1-4*pow(abs(x),2)&v6=true&grid=1&coords=-0.23240553285452256,0.9899943875016732,3.145144484193439\n\nprecision mediump float;\n\nconst float NUM_OF_STEPS = 128.0;\nconst float MIN_DIST_TO_SDF = 0.01;\nconst float MAX_DIST_TO_TRAVEL = 64.0;\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdfPlane(vec3 p, vec3 n, float h) {\n  // n must be normalized\n  return dot(p, n) + h;\n}\n\nfloat sdfSphere(vec3 p, vec3 c, float r) {\n  return length(p - c) - r;\n}\n\nfloat GetMoveHeight(float time, float dropXDistance) {\n    return 1.0-pow( abs(2.0*fract((time-dropXDistance)/dropXDistance*0.5)-1.0), 2.0 );\n}\n\nfloat GetMoveHeight(float time) {\n    float dropXDistance = 0.25;\n    return 1.0-pow( abs(2.0*fract((time-dropXDistance)/dropXDistance*0.5)-1.0), 2.0 );\n}\n\n\n// 主要内容，修改场景元素（目前仅雕刻，统一光照）\nfloat map(vec3 p) {\n\n    float h = 2.0;\n    vec3 normal = vec3(0.0, 1.0, 0.0);\n    \n    // plane\n    float d = sdfPlane(p, normal, h);\n    \n    \n\n  float radius = 1.0;\n  vec3 ball_center1 = vec3(0.0, GetMoveHeight(iTime)-1.0, 0.0);\n\n  float sphere1 = sdfSphere(p, ball_center1, radius);\n\n  d = opSmoothUnion(sphere1, d, 0.5);\n  \n  d = opSmoothUnion(sdfSphere(p, vec3(-3.0, GetMoveHeight(iTime*0.8, 0.25/0.8)-1.0, 0.0), radius), d, 0.5);\n  \n  d = opSmoothUnion(sdfSphere(p, vec3(-1.5, GetMoveHeight(iTime*1.2, 0.25/1.2)-1.0, 0.0), radius), d, 0.5);\n  \n  d = opSmoothUnion(sdfSphere(p, vec3(2, 1.0+GetMoveHeight(iTime*0.5, 0.25/0.5)-1.0, 0.0), radius*2.0), d, 0.5);\n\n  \n  return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float maxDistToTravel) {\n  float dist = 0.0;\n\n  for (float i = 0.0; i < NUM_OF_STEPS; i++) {\n    vec3 currentPos = ro + rd * dist;\n    float distToSdf = map(currentPos);\n\n    if (distToSdf < MIN_DIST_TO_SDF) {\n      break;\n    }\n\n    dist = dist + distToSdf;\n\n    if (dist > maxDistToTravel) {\n      break;\n    }\n  }\n\n  return dist;\n}\n\nvec3 getNormal(vec3 p) {\n  vec2 d = vec2(0.01, 0.0);\n  float gx = map(p + d.xyy) - map(p - d.xyy);\n  float gy = map(p + d.yxy) - map(p - d.yxy);\n  float gz = map(p + d.yyx) - map(p - d.yyx);\n  vec3 normal = vec3(gx, gy, gz);\n  return normalize(normal);\n}\n\nvec3 render(vec2 uv) {\n  vec3 color = vec3(0.0, 0.0, 0.0);\n\n  // note: ro -> ray origin, rd -> ray direction\n  vec3 ro = vec3(0.0, -0.7, -3);\n  vec3 rd = vec3(uv, 1.0);\n  rd = normalize(vec3(uv, 1.0));\n\n  float dist = rayMarch(ro, rd, MAX_DIST_TO_TRAVEL);\n\n  if (dist < MAX_DIST_TO_TRAVEL) {\n    // part 1 - display ray marching result\n    // color = vec3(1.0);\n\n    // part 2.1 - calculate normals\n    // calculate normals at the exact point where we hit SDF\n    vec3 p = ro + rd * dist;\n    vec3 normal = getNormal(p);\n    // color = normal;\n\n\n\n    // part 2.2 - add lighting\n\n    // part 2.2.1 - calculate diffuse lighting\n    vec3 lightColor = vec3(1.0);\n    float lightRotaSpeed = 3.0;\n    vec3 lightSource = vec3(2.5+cos(iTime*lightRotaSpeed), 2.5, -2.5+sin(iTime*lightRotaSpeed));\n    float diffuseStrength = max(0.0, dot(normalize(lightSource), normal));\n    vec3 diffuse = lightColor * diffuseStrength;\n\n    // part 2.2.2 - calculate specular lighting\n    vec3 viewSource = normalize(ro);\n    vec3 reflectSource = normalize(reflect(-lightSource, normal));\n    float specularStrength = max(0.0, dot(viewSource, reflectSource));\n    specularStrength = pow(specularStrength, 64.0);\n    vec3 specular = specularStrength * lightColor;\n\n    // part 2.2.3 - calculate lighting\n    vec3 lighting = diffuse * 0.75 + specular * 0.25;\n    color = lighting;\n\n\n\n    // part 3 - add shadows\n\n    // part 3.1 - update the ray origin and ray direction\n    vec3 lightDirection = normalize(lightSource);\n    float distToLightSource = length(lightSource - p);\n    ro = p + normal * 0.1;\n    rd = lightDirection;\n\n    // part 3.2 - ray march based on new ro + rd\n    float dist = rayMarch(ro, rd, distToLightSource);\n    if (dist < distToLightSource) {\n      color = color * vec3(0.25);\n    }\n\n\n\n    // note: add gamma correction\n    color = pow(color, vec3(1.0 / 2.2));\n  }\n\n  return color;\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv01 = fragCoord/iResolution.xy;\n    \n    vec2 uv_N1_1 = 2.0 * uv01 - 1.0;\n    \n    uv_N1_1.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    color = vec3(uv_N1_1, 0.0);\n    \n    color = render(uv_N1_1);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}