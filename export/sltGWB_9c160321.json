{"ver":"0.1","info":{"id":"sltGWB","date":"1636668239","viewed":231,"name":"Playing with a Soccer Ball","username":"sylvain69780","description":"You can play with a soccer ball on Shadertoy !\nJust change the code to play ! \n- Uncomment KICKOFF and compile.\n- Uncomment SURPRISE and compile.        \n","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["soccer","wythoff","buckyball"],"hasliked":0,"parentid":"WtGXDD","parentname":"RayMarching starting point"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n \n    Playing with a Soccer Ball\n    -----------------------------\n    \n    Uncomment the lines in the code to play !\n    - Uncomment KICKOFF and compile.\n    - Uncomment SURPRISE and compile.        \n\n    One can visualize many interesting polyhedra using the Mattz's shader and the Wythoff construction !\n    The Wythoff code used here is the classical 235 icosahedral symetry, \n    just find the appropriate point on the triangle for the vertex position.\n \n \n    Related references\n    \n    Truncated icosahedron\n    https://en.wikipedia.org/wiki/Truncated_icosahedron\n    \n    Wythoff explorer - mattz â™¥ \n    https://www.shadertoy.com/view/Md3yRB\n\n*/\n\n//#define KICKOFF\n//#define SURPRISE\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nfloat objID = 0.0;\n\nfloat GetDist(vec3 p) {\n    \n    if ( iMouse.x < 10.0 ) {\n    #ifdef KICKOFF \n        p.z -= 1.+sin(T);\n        p.y -= abs(sin(T*3.0))-.5;\n    #endif\n        float phi=T*.5,\n        th=.27*T*.5;\n        p.yz *= Rot(th);\n        p.xy *= Rot(phi);        \n    }\n\n    float d = 1e10;\n    \n    vec3 q = opIcosahedron(p);\n    // Wythoff construction\n    // https://en.wikipedia.org/wiki/Wythoff_construction\n    // Vertex position type 2 \n    vec3 bisect = normalize(P35-vec3(1,0,0));\n    vec3 vertex = normalize(cross(vec3(0,1,0),bisect));\n    vec3 pEdge = normalize(cross(P35,vertex));\n    float edge = dot(q-vertex,pEdge);   \n    objID = edge > -0.005 ? 1.0 : 2.0;\n    float sphere = length(q)-1.0;\n    #ifdef SURPRISE\n    d = smax(sphere-0.3*(S(.8,1.0,sin(T*2.0))),edge,.05);\n    #else\n    d = smax(sphere,edge,.05);\n    #endif\n    float d2 = smax(sphere,max(-q.y,-edge),.05);\n    d = min(d,d2);\n    float tube = length(q - vertex * dot(vertex,q))-.01;\n    d = smax(d,-tube,.04);\n    if ( d > sphere+.05 ) objID = 1.0;\n    d = min(d,sphere+.05);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n// IQ\n// https://www.shadertoy.com/view/tt2XzG\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = GetDist( pos+h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(0, 0.1, -2.4);\n    if ( iMouse.x > 0.0 ) {\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*6.2831);\n    }    \n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0.153,0.447,0.094)*(1.0-abs(rd.y));\n   \n    float d = RayMarch(ro, rd);\n    float sobjID = objID;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 nor = GetNormal(p);\n        vec3 c = sobjID == 1.0 ? vec3(1.000,0.851,0.102)*.2 : vec3(.01);\n        vec3 sun = normalize(vec3(0,1,-2));\n        vec3 hal = normalize( sun-rd );\n        float dif = max(0.0,dot(nor, sun));\n        // IQ's Blinn-Phong specular formula\n        // https://youtu.be/Cfe5UQ-1L9Q?t=14952\n        float spe = pow(clamp(dot(nor,hal),0.0,1.0),8.0)*dif*(0.04+0.96*pow(clamp(1.0+dot(hal,rd),0.0,1.0),5.0));\n        float occ = calcAO(p,nor);\n        vec3 sun_col = vec3(0.984,0.957,0.635)*5.;\n        col = c*dif * sun_col * occ;\n        col += spe * sun_col * occ;\n    }\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"      \n// Normal of a plan having a dihedral angle of PI/3 with the YZ plan and PI/5 with the XZ plane\nconst float CP = cos(3.1415/5.), SP=sqrt(0.75-CP*CP);\nconst vec3  P35 = vec3(-0.5, -CP, SP);\n\n// below are the directions from the origin limiting the coordniate's domain after folding space\nconst vec3 ICOMIDEDGE = vec3(0,0,1);\nconst vec3 ICOVERTEX  = normalize(vec3(SP,0.0,0.5)); // direction in the XZ plan, you will find the ICO vertex on this line\nconst vec3 ICOMIDFACE = normalize(vec3(0.0,SP,CP));  // direction in the YZ plan, you will find the DODE vertex on this line\n/*\n    Schema of how it works, the (spherical) triangles are arranged like this\n\n                          Y ICOMIDFACE\n                \n                         **      \n                      ********       \n                   ***   **    ***     P35\n                ***      **       ***         \n             ***         **          ***         \n          ***            **             ***        \n       ***               ** ICOMIDEDGE    ***          \n    ***                  ** (0,0)             ***         \n ***************************************************  X ICOVERTEX\n    ***                  **                   ***    \n       ***               **                ***\n          ***            **             ***\n             ***         **          ***\n                ***      **       ***\n                   ***   **    ***\n                      ********\n                         ** \n\n*/\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvec3 opIcosahedron( vec3 p )\n{\n    const float PI = 3.14159265359;\n    const float c = cos(PI/5.), s=sqrt(0.75-c*c);\n    const vec3  n = vec3(-0.5, -c, s);\n    p = abs(p);\n    p -= 2.*min(0., dot(p, n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    return p;\n}    \n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\n","name":"Common","description":"","type":"common"}]}