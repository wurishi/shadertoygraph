{"ver":"0.1","info":{"id":"wlGyzt","date":"1614098698","viewed":404,"name":"CAS Filter in 1 Tap","username":"iradicator","description":"Using the sharpening idea from hw derivatives to apply approximated CAS filtering for sharpening in 1 tap.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","filter","derivatives","image","sharpening","cas"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Developing a cheap (lower-quality) approaximation for Contrast Adaptive Sharpening (CAS)\n//\n// Comparing different approaches as follows:\n//\n// Left side (left to red delimiter) - bilinear filtering\n// Left middle (between red and green delimiters) - Quad 2x2 sharpening in 1 tap\n// Right middle (between green and blue delimiters) - Approximated CAS filtering in 1 tap\n// Right side (right to blue delimiter) - (adapted) CAS filtering\n//\n// Note image swimming with animation due to 2x2 quad \"point sampling\" nature of this technique.\n\n#define EPSILON (0.000001)\n\n#define max4(a,b,c,d) (max(max((a),(b)),max((c),(d))))\n#define min4(a,b,c,d) (min(min((a),(b)),min((c),(d))))\n\n#define max5(a,b,c,d,e) (max(max(max((a),(b)),max((c),(d))),(e)))\n#define min5(a,b,c,d,e) (min(min(min((a),(b)),min((c),(d))),(e)))\n\n// NOTE: I chose aggressive sharpening factors to highlight the effect\nconst float kCasFactor = 1.0;\nconst float kCasPlusBoxCoeff = 1.0;\nconst float kCasApproxPlusBoxCoeff = 0.5;\nconst float kDiagCasApprox = 0.05;\n\nfloat luminance(in vec3 col)\n{\n  // return dot(vec3(0.2126, 0.7152, 0.0722), col);\n  return col.g;\n}\n\n// NOTE: Based on AMD's CAS\n// REF: https://gpuopen.com/fidelityfx-cas\nvec3 CAS(in vec3 col, in vec2 uv)\n{\n    vec2 texelSize = vec2(1.0) / vec2(textureSize(iChannel0, 0).xy);\n    \n    float maxPlus3x3 = max5(\n        luminance(col),\n        luminance(texture(iChannel0, uv + vec2(-1.0, 0.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2(+1.0, 0.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2( 0.0,-1.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2( 0.0,+1.0) * texelSize).rgb)\n    );\n    float maxBox3x3 = max5(\n        maxPlus3x3,\n        luminance(texture(iChannel0, uv + vec2(-1.0,-1.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2(+1.0,-1.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2(-1.0,+1.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2(+1.0,+1.0) * texelSize).rgb)\n    );\n    float minPlus3x3 = min5(\n        luminance(col),\n        luminance(texture(iChannel0, uv + vec2(-1.0, 0.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2(+1.0, 0.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2( 0.0,-1.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2( 0.0,+1.0) * texelSize).rgb)\n    );\n    float minBox3x3 = min5(\n        minPlus3x3,\n        luminance(texture(iChannel0, uv + vec2(-1.0, 0.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2(+1.0, 0.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2( 0.0,-1.0) * texelSize).rgb), \n        luminance(texture(iChannel0, uv + vec2( 0.0,+1.0) * texelSize).rgb)\n    );\n    \n    float MAX_G = mix(maxPlus3x3, maxBox3x3, kCasPlusBoxCoeff);\n    float MIN_G = mix(minPlus3x3, minBox3x3, kCasPlusBoxCoeff);\n    float A = min(MIN_G, 1.0 + kCasPlusBoxCoeff - MAX_G + EPSILON) / (MAX_G + EPSILON);\n    A = sqrt(A);\n\n    float w = -mix(0.0, 1.0/5.0, kCasFactor) * A;\n  \n    return (col + w * (\n          texture(iChannel0, uv + vec2(-1.0, 0.0) * texelSize).rgb +\n        + texture(iChannel0, uv + vec2(+1.0, 0.0) * texelSize).rgb +\n        + texture(iChannel0, uv + vec2( 0.0,-1.0) * texelSize).rgb +\n        + texture(iChannel0, uv + vec2( 0.0,+1.0) * texelSize).rgb\n    )) / (1.0 + 4.0 * w);  \n}\n\n// NOTE: PQA\n// REF: GPU Pro 2 article \"Shader Amortization using Pixel Quad Message Passing\"\nvec4 quadVector = vec4(0.0);\nvec4 quadSelect = vec4(0.0);\nvoid InitQuad2x2(in vec2 iuv)\n{\n  quadSelect = vec4((uvec4(gl_FragCoord.xyxy) + uvec4(0,0,1,1)) & uvec4(1));\n  quadVector = 2.0 * quadSelect - vec4(1.0);\n}\nvoid GatherQuad2x2(in vec3 x, out vec3 h, out vec3 v, out vec3 d)\n{\n  h = x + dFdx(x) * quadVector.z; // horizontal\n  v = x + dFdy(x) * quadVector.w; // vertical\n  d = v + dFdx(v) * quadVector.z; // diagonal\n}\n\n// NOTE: 1 tap sharpening\n// REF: https://www.shadertoy.com/view/tlGcRt\nvec3 SharpenQuad2x2(in vec2 fragCoord, in vec3 v)\n{ \n    vec2 q = vec2(uvec2(fragCoord.xy) & uvec2(1));\n    q = 2.0 * q - vec2(1.0);    \n    v += 0.5 * dFdx(v) * q.x;\n    v += 0.5 * dFdy(v) * q.y;\n    return v;\n}\n\n// NOTE: (new approach) approximating CAS filter using 1 tap 2x2 quad gathering\nvec3 CASQuad2x2(in vec3 col, in vec2 uv)\n{\n    vec3 a = col;\n    vec3 b,c,d;\n    GatherQuad2x2(a,b,c,d);\n    \n    float MAX_G = max4(luminance(a),luminance(b),luminance(c),luminance(d));\n    float MIN_G = min4(luminance(a),luminance(b),luminance(c),luminance(d));\n    \n    float A = min(MIN_G, 1.0 + kCasApproxPlusBoxCoeff + kDiagCasApprox - MAX_G + EPSILON) / (MAX_G + EPSILON);\n    A = sqrt(max(0.0,A));\n    \n    float w = -mix(0.0, 1.0/5.0, kCasFactor) * A;\n    w *= 2.0; // fudge-factor\n    \n    return (col + w * (b + c + kDiagCasApprox * d))\n        / (1.0 + (2.0 + kDiagCasApprox) * w);        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitQuad2x2(vec2(gl_FragCoord.xy));\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = 0.0;\n#if 1 // Animated \n    t = iTime;\n#endif\n    float lb = uv.x - (0.5*sin(0.6*t)+0.5) - 0.4;\n    float lg = uv.x - (0.5*sin(0.6*t)+0.5)       ;\n    float lr = uv.x - (0.5*sin(0.6*t)+0.5) + 0.4;\n\n#if 1 // Animated\n    uv = 0.8 * uv + vec2(0.1) + vec2(0.05*sin(0.5*iTime),0.08*cos(0.3*iTime));\n#endif\n\n    vec3 col_bilinear = texture(iChannel0, uv).rgb;\n    vec3 col_sharpen = SharpenQuad2x2(fragCoord, col_bilinear);\n    vec3 col_cas_approx = CASQuad2x2(col_bilinear, uv);\n    vec3 col_cas = CAS(col_bilinear, uv);\n                           \n    float tshowd = smoothstep(0.6, 1.0, sin(0.4*iTime));\n    col_sharpen = mix(col_sharpen, abs(col_sharpen - col_bilinear), tshowd);\n    col_cas_approx = mix(col_cas_approx, abs(col_cas_approx - col_bilinear), tshowd);\n    col_cas = mix(col_cas, abs(col_cas - col_bilinear), tshowd);\n    col_bilinear = mix(col_bilinear, abs(col_bilinear - col_bilinear), tshowd);\n                           \n    vec3 col = mix(col_bilinear,col_sharpen,smoothstep(0.0,2.0/iResolution.x,lr));\n    col = mix(col,col_cas_approx,smoothstep(0.0,2.0/iResolution.x,lg));\n    col = mix(col,col_cas,smoothstep(0.0,2.0/iResolution.x,lb));\n\n    col = mix(vec3(0.6,0.2,0.15),col,smoothstep(0.0,2.0/iResolution.x,abs(lr)));\n    col = mix(vec3(0.2,0.6,0.15),col,smoothstep(0.0,2.0/iResolution.x,abs(lg)));\n    col = mix(vec3(0.2,0.2,0.55),col,smoothstep(0.0,2.0/iResolution.x,abs(lb)));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}