{"ver":"0.1","info":{"id":"4ff3Wn","date":"1702928319","viewed":88,"name":"Mandelbox Fun","username":"workingclasshacker","description":"Just experimenting, in preparation for a 3d version.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2dmandelboxsdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to calculate the Mandelbox distance\nfloat mandelboxDE(vec3 pos, float scale, float cx, float cy, float cz) {\n    float DEfactor = scale;\n    float fixedRadius = 1.0;\n    float fR2 = fixedRadius * fixedRadius;\n    float minRadius = 0.5;\n    float mR2 = minRadius * minRadius;\n    float x = pos.x, y = pos.y, z = pos.z;\n\n    // Inside iteration loop\n    for (int i = 0; i < 10; i++) { // 10 iterations, adjust as needed\n        // Mandelbox algorithm\n        if (x > 1.0) x = 2.0 - x;\n        else if (x < -1.0) x = -2.0 - x;\n        if (y > 1.0) y = 2.0 - y;\n        else if (y < -1.0) y = -2.0 - y;\n        if (z > 1.0) z = 2.0 - z;\n        else if (z < -1.0) z = -2.0 - z;\n\n        float r2 = x*x + y*y + z*z;\n\n        if (r2 < mR2) {\n            x = x * fR2 / mR2;\n            y = y * fR2 / mR2;\n            z = z * fR2 / mR2;\n            DEfactor = DEfactor * fR2 / mR2;\n        } else if (r2 < fR2) {\n            x = x * fR2 / r2;\n            y = y * fR2 / r2;\n            z = z * fR2 / r2;\n            DEfactor *= fR2 / r2;\n        }\n\n        x = x * scale + cx;\n        y = y * scale + cy;\n        z = z * scale + cz;\n        DEfactor *= scale;\n    }\n\n    // Resultant estimated distance\n    return sqrt(x*x + y*y + z*z) / abs(DEfactor);\n}\n\nmat2 rot2d(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    uv *= rot2d(mod(iTime/2., 6.28));\n    vec2 uv2 = uv;\n    float t = mod(iTime / 52.0, 6.28);\n    vec3 col = vec3(0);\n    uv = abs(uv)*sin(t);\n    col += .01/mandelboxDE(vec3(uv, -cos(t*10.)), 1.0, uv.y, uv.x, uv.y+uv.x*tan(t));\n    uv2 *= mat2(45. / (6.28));\n    col += .01/mandelboxDE(vec3(sin(uv2*0.2), -sin(t*11.)), 1.0, uv2.x, uv2.y, uv.x+uv.y/atan(t*11.));\n    col += .01/mandelboxDE(vec3(uv, -sin(t*11.)), 1.0, uv2.x, uv2.y, uv.x+uv.y*atan(t*11.));\n    col.g *= clamp(0.0, 1.0, 0.2/mandelboxDE(vec3(sin(uv2*0.2), -sin(t*11.)), 1.0, uv2.x, uv2.y, uv.x+uv.y*atan(t*11.)));\n    col.r *= sin(col.b);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}