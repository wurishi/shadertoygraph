{"ver":"0.1","info":{"id":"XsyBW3","date":"1530676738","viewed":393,"name":"Display TRC Graph","username":"Tynach","description":"This shader provides a visualization for the conversion from the transfer characteristics (TRC) of one display, to the TRC of another display. It defaults to converting linear light into sRGB.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gamma","22","srgb","transfer","trc","characteristics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a BT.1886 electro-optical transfer function\nstruct bt1886 {\n\t// Contrast ratio\n\tfloat cRatio;\n\n\t// Offset applied before gamma\n\tfloat gamOffset;\n\n\t// Multiplier applied before division but after gamma\n\tfloat coeff;\n};\n\n// Automatically calculate the slope and cutoffs for transfer characteristics\n#define Transfer(po, of)\\\ntransfer(\\\n\t(po),\\\n\t(of),\\\n\t(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))/(po),\\\n\t(of)/((po) - 1.0),\\\n\t(of)/((po) - 1.0)*(po)/(pow((po)*(of)/((po) - 1.0), 1.0 - (po))*pow(1.0 + (of), (po)))\\\n)\n\n// BT.1886 defines its functions using a black luminosity level, and a white\n// luminosity level. However, in the range of 0 to 1, there's no difference\n// between input values of the same ratio to each other. As long as the contrast\n// ratio (white/black) remains the same, the output function does too\n#define Bt1886(black, white)\\\nbt1886(\\\n\t(white)/(black),\\\n\t1.0/(pow((white)/(black), 1.0/2.4) - 1.0),\\\n\tpow(pow((white)/(black), 1.0/2.4) - 1.0, 2.4)\\\n)\n\n\n/*\n * Gamma curve parameters\n */\n\n// Gamma of 1.0; linear light\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; Approximately what old Apple computers used\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n// Gamma for the CIE L*a*b* Lightness scale\nconst transfer gamLab = transfer(3.0, 0.16, 243.89/27.0, 0.08, 216.0/24389.0);\n\n// Gamma for a 1000:1 contrast ratio display following BT.1886\nconst bt1886 gamThou = Bt1886(1.0, 1000.0);\n\n\n/*********************************************************\n * Settings - Change these to adjust the displayed curve *\n *********************************************************/\nconst transfer gamFrom = gam10;\nconst transfer gamTo = gamSrgb;\n\n// Display gamma (for gamma correct antialiasing)\nconst transfer gamDisp = gamSrgb;\n\n\n/*\n * Conversion Functions\n */\n\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\treturn mix(color, neg, negCutoff);\n}\n\nvec3 toLinear1886(vec3 color, const bt1886 trc)\n{\n\treturn (trc.coeff*pow(color + trc.gamOffset, vec3(2.4)) - 1.0)/(trc.cRatio - 1.0);\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, const transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\treturn mix(color, neg, negCutoff);\n}\n\nvec3 toGamma1886(vec3 color, const bt1886 trc)\n{\n\treturn pow((color*(trc.cRatio - 1.0) + 1.0)/trc.coeff, vec3(1.0/2.4)) - trc.gamOffset;\n}\n\n// Just use a texture\nvec3 hash(vec3 seed)\n{\n\tivec2 texRes = textureSize(iChannel0, 0);\n\tivec2 coord = ivec2(seed.xy + seed.z*vec2(157, 103)) % texRes;\n\n\treturn texelFetch(iChannel0, coord, 0).xxx;\n}\n\n// Dither between two colors by 'amount'\nvec3 dither(vec3 color1, vec3 color2, vec3 amount)\n{\n\tvec3 seed = hash(vec3(gl_FragCoord.xy, fract(iTime)*144.0));\n\tbvec3 cmix = bvec3(round(amount + seed - 0.5));\n\n\treturn mix(color1, color2, cmix);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 coord)\n{\n\tfloat offset = 1.0;\n\n\t// Center resulting value range to be evenly distributed when\n\t// flooring the resulting color values to the next lowest 8-bit int\n\tcoord = floor(coord);\n\n\tvec2 maxCoord = iResolution.xy - 1.0;\n\tvec2 uv = coord/maxCoord;\n\tvec3 color = vec3(uv.x);\n\n\tvec3 bef = vec3(uv.x - offset/maxCoord.x);\n\tvec3 aft = vec3(uv.x + offset/maxCoord.x);\n\n\tbef = toLinear(bef, gamFrom);\n\taft = toLinear(aft, gamFrom);\n\tbef = toGamma(bef, gamTo);\n\taft = toGamma(aft, gamTo);\n\n\t// Calculate distance from the line\n\tvec2 p1 = vec2(coord.x - offset, bef.x*maxCoord.y);\n\tvec2 p2 = vec2(coord.x + offset, aft.x*maxCoord.y);\n\tvec2 toUv = p2 - coord;\n\tvec2 unit = normalize(p2 - p1);\n\tfloat dist = length(toUv - dot(toUv, unit)*unit);\n\n\tcolor = toLinear(color, gamFrom);\n\tcolor = toGamma(color, gamTo);\n\n\t// Draw the actual line in linear light for better antialiasing\n\tcolor = toLinear(color, gamDisp);\n\n\tcolor = mix(vec3(0), color, clamp(dist - 1.5, 0.0, 1.0));\n\tcolor = mix(vec3(1), color, clamp(dist - 0.5, 0.0, 1.0));\n\n\t//vec3 cLin = color;\n\n\tcolor = toGamma(color, gamDisp);\n\n\t/*vec3 cLow = floor(color*255.0)/255.0;\n\tvec3 cHigh = ceil(color*255.0)/255.0;\n\tvec3 cLowLin = toLinear(cLow, gamDisp);\n\tvec3 cHighLin = toLinear(cHigh, gamDisp);\n\n\tvec3 blend = (cLin - cLowLin)/(cHighLin - cLowLin);\n\n\tfragColor = vec4(dither(cLow, cHigh, blend), 1);*/\n\tfragColor = vec4(round(color*255.0)/255.0, 1);\n}","name":"Image","description":"","type":"image"}]}