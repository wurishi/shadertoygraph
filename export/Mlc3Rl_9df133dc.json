{"ver":"0.1","info":{"id":"Mlc3Rl","date":"1470824827","viewed":2125,"name":"Boids","username":"aytekaman","description":"Reynolds' Boids. Each pixel is used to store at most one boid. Thus, when two of them gets too close to each other, one of them gets eaten. You can click and drag on the canvas to create additional swarm of boids. Change STYLIZED macro for different FX.","likes":41,"published":1,"flags":32,"usePreview":0,"tags":["simulation","swarm","flock","flocking","boids","agents"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define STYLIZED false\n\nvec4 angle2hue(float angle)\n{    \n    vec4 color = vec4(0, 0, 0, 0);\n    \n    vec4 red = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 yel = vec4(1.0, 1.0, 0.0, 1.0);\n    vec4 gre = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 cya = vec4(0.0, 1.0, 1.0, 1.0);\n    vec4 blu = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 mag = vec4(1.0, 0.0, 1.0, 1.0);\n    \n    int slice = int(angle / (PI / 3.0));\n    float rem = mod(angle, PI / 3.0);\n\n    color = slice == 0 ? mix(red, yel, rem) : color;\n    color = slice == 1 ? mix(yel, gre, rem) : color;\n    color = slice == 2 ? mix(gre, cya, rem) : color;\n    color = slice == 3 ? mix(cya, blu, rem) : color;\n    color = slice == 4 ? mix(blu, mag, rem) : color;\n\tcolor = slice == 5 ? mix(mag, red, rem) : color;\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if(STYLIZED)\n    {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);  \n    \n        float minDistSqr = 10000.0;\n        vec2 vel = vec2(0, 0);\n\n        for(int i = -4; i <= 4; i++)\n        {\n            for(int j = -4; j <= 4; j++)\n            {\n                vec2 coord = fragCoord + vec2(float(i), float(j));\n                vec2 uv = coord / iResolution.xy;\n                vec4 data = texture(iChannel0, uv);\n                vec2 pos = data.xy;\n\n                if(data.x > 0.001)\n                {\n                    vel += data.zw;\n                    \n                    vec2 delta = pos - fragCoord;\n                    float distSqr = dot(delta, delta);\n\n                    if(distSqr < minDistSqr)\n                    {\n                        minDistSqr = distSqr;\n\n                    }\n                }\n            }\n        }\n\n        if(minDistSqr < 9.0)\n        {\n            float angle = atan(vel.y, vel.x) + PI;\n            fragColor = angle2hue(angle);\n        }\n        else if(minDistSqr < 16.0)\n        {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);   \n        }\n    }\n    else \n    {  \n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n        vec4 data = vec4(texture(iChannel0, uv));\n\n        if(data.x > 0.001)\n        {\n            vec2 vel = data.zw;\n            float angle = atan(vel.y, vel.x) + PI;\n            fragColor = angle2hue(angle);\n        }\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// NEIGHBOR_DIST should be greater than DESIRED_SEPERATION, \n// otherwise you may not observe flocking behaviour.\n\n#define BOID_DENSITY 0.01\n#define NEIGHBOR_DIST 6\n#define DESIRED_SEPERATION 4\n#define MAX_SPEED 0.9\n#define MAX_FORCE 0.05\n\n#define PI 3.14159265359\n#define NEIGHBOR_DIST_SQR (NEIGHBOR_DIST * NEIGHBOR_DIST)\n#define DESIRED_SEPERATION_SQR (DESIRED_SEPERATION * DESIRED_SEPERATION)\n\nfloat rand(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 0);\n    \n\tvec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    if(iFrame == 0)\n    {\n        if(rand(uv) > 1.0 - BOID_DENSITY)\n        {\n            float angle = rand(vec2(1.0, 1.0) - uv) * PI * 2.0;\n            \n            vec2 rot = vec2(cos(angle), sin(angle));\n            \n            fragColor = vec4(fragCoord.xy, rot);\n        }\n    }\n    else\n    {\n     \tvec4 data = texture(iChannel0, uv);\n        \n        if(data.x > 0.001)\n        {\n            vec2 pos = data.xy;\n            vec2 vel = data.zw;\n            \n            int nCount = 0;\n            int sCount = 0;\n            \n            vec2 alignment = vec2(0, 0);\n            vec2 cohesion = vec2(0, 0);\n            vec2 seperation = vec2(0, 0);\n            \n            for(int i = -NEIGHBOR_DIST; i <= NEIGHBOR_DIST; i++)\n            {\n                for(int j = -NEIGHBOR_DIST; j <= NEIGHBOR_DIST; j++)\n                {\n                    if((i == 0 && j == 0) || (i * i + j * j > NEIGHBOR_DIST_SQR))\n                        continue;\n                    \n                    vec2 coord = fragCoord + vec2(float(i), float(j));\n\n                    coord = mod(coord, iResolution.xy);\n\n                    vec2 uv2 = coord / iResolution.xy;\n\n                    vec4 data2 = texture(iChannel0, uv2);\n\n                    if(data2.x > 0.001)\n                    {\n                        vec2 pos2 = data2.xy;\n            \t\t\tvec2 vel2 = data2.zw;\n                        \n                        vec2 toBoid = pos - pos2;\n                        \n                        float distSqr = dot(toBoid, toBoid); \n                        \n                        if(distSqr < float(DESIRED_SEPERATION_SQR))\n                        {\n                            toBoid /= distSqr;\n                            \n                            seperation += toBoid;\n                            sCount++;\n                        }\n                        \n                        if(distSqr < float(NEIGHBOR_DIST_SQR))\n                        {\n                            alignment += vel2;\n                            cohesion += pos2;\n                            nCount++;\n                        }\n                    }\n                }\n            }\n            \n            if(nCount > 0)\n            {\n            \tcohesion /= float(nCount);\n                \n              \tvec2 s = vec2(0, 0);\n                vec2 toTarget = cohesion - pos;\n                float dist = length(toTarget);\n                \n                if(dist > 0.0)\n                {\n                    toTarget *= MAX_SPEED / dist;\n                    \n                    s = toTarget - vel;\n                    \n                    float l = length(s);\n                    \n                    if(l > MAX_FORCE)\n                    \ts *= MAX_FORCE / l;\n                }\n                \n                cohesion = s;\n                \n                alignment = normalize(alignment);\n                alignment *= float(MAX_SPEED);\n                alignment -= vel;\n                \n                float l = length(alignment);\n                \n                if(l > MAX_FORCE)\n                    alignment *= MAX_FORCE / l;\n            }\n            \n            if(sCount > 0)\n            {\n                seperation = normalize(seperation);\n                seperation *= float(MAX_SPEED);\n                seperation -= vel;\n                \n                float l = length(seperation);\n                \n                if(l > MAX_FORCE)\n                    seperation *= MAX_FORCE / l;\n            }\n            \n            vec2 acc = alignment + seperation * 1.5 + cohesion;\n            \n            vel += acc;\n            \n            float l = length(vel);\n                \n            if(l > float(MAX_SPEED))\n                vel *= float(MAX_SPEED) / l;\n            \n            pos += vel;\n            \n            pos = mod(pos, iResolution.xy);\n            \n            fragColor = vec4(pos, vel);\n        }\n    }\n    \n    if(iMouse.z > 0.0)\n    {\n        float dist = distance(iMouse.xy, fragCoord);\n        \n        if(dist < 20.0)\n        {\n            if(rand(uv) > 0.5)\n            {                \n                vec2 vel = normalize(fragCoord - iMouse.zw);\n\n                fragColor = vec4(fragCoord.xy, vel);\n            }\n        }  \n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0, 0, 0, 0);\n    \n    for(int i = -1; i <= 1; i++)\n    {\n        for(int j = -1; j <= 1; j++)\n        {\n            vec2 coord = fragCoord + vec2(float(i), float(j));\n\n            coord = mod(coord, iResolution.xy);\n\n            vec2 uv = coord / iResolution.xy;\n\n            vec4 data = texture(iChannel0, uv);\n\n            vec2 pos = data.xy;\n\n            if(data.x > 0.001 && abs(pos.x - fragCoord.x) < 0.5 && abs(pos.y - fragCoord.y) < 0.5)\n            {\n                fragColor = data;\n            }\n        }\n    }\n}","name":"Buf B","description":"","type":"buffer"}]}