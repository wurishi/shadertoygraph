{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*\n  Andor Salga\n  June 2013\n*/\n\nvec3 getNormal(in vec2 sphereCenter, in float sphereRadius, in vec2 point){\n\t// Need to figure out how far the current point is from the center to lerp it\n\tfloat distFromCenter = distance(point, sphereCenter);\n\tfloat weight = distFromCenter/sphereRadius;\n\t\n\t// Z component is zero since at the edge the normal will be on the XY plane\n\tvec3 edgeNormal = vec3(point - sphereCenter, 0);\n\tedgeNormal = normalize(edgeNormal);\n\t\n\t// We know the normal at the center of the sphere points directly at the viewer,\n\t// so we can use that in our mix/lerp.\n\treturn mix(vec3(0,0,1), edgeNormal, weight); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 center = vec2(iResolution.xy)/2.0;\n\t\n\tvec2 spherePos = vec2( sin(iTime), cos(iTime)) * 30.0;\n\t\n\tif( distance(center + spherePos, vec2(fragCoord)) < 100.0){\n\t\tvec3 sphereNormal =  vec3(getNormal(center, 100.0, vec2(fragCoord)));\n\t\tvec3 dirLight = vec3(0,0,0.81);\n\t\tvec3 col =  normalize((vec3(1,1,1))) * dot(sphereNormal, dirLight);\n\t\tfragColor = vec4(0.1) + vec4(col, 1);\n\t}\n\telse{\n\t\tfragColor = vec4(0);\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MdXGWN","date":"1370183221","viewed":274,"name":"Lit Sphere","username":"asalga","description":"Procedurally generated sphere","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""}}