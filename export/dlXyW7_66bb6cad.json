{"ver":"0.1","info":{"id":"dlXyW7","date":"1690816080","viewed":55,"name":"Colored metaball blending","username":"aidanwyber","description":"Metaball blending","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","metaball","blend"],"hasliked":0,"parentid":"4dj3zh","parentname":"2D Color Metaballs"},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n * Use the mouse to control the positions of the metaballs. \n * Forked (and refactored) from Helpfully's \"2D Color Metaballs\": https://www.shadertoy.com/view/4dj3zh\n*/\n\n\n#define NORM_K 2.\n#define NORM(x) pow(x, NORM_K)\n\n#define N 3\n\nconst float rs[N] = float[] (0.2, 0.3, 0.15);\n\nvec3 getMbCol(int mbIndex) {\n\tvec3 mbCol = vec3(0.0);\n\tif(mbIndex == 0) mbCol = vec3(0.0, 1.0, 0.0);\n\telse if(mbIndex == 1) mbCol = vec3(0.0, 0.0, 1.0);\n\telse if(mbIndex == 2) mbCol = vec3(1.0, 0.0, 0.0);\n\treturn mbCol;\n}\n\nvec2 getMbPos(int mbIndex) {\n\tvec2 mbPos = vec2(0.);\n    \n    vec2 m = (iMouse.x < 20. && iMouse .y < 20.) ? vec2(0.83, 0.32) * iResolution.xy : iMouse.xy;\n\n\tif(mbIndex == 0) mbPos = vec2(0.5);\t\n\telse if(mbIndex == 1) mbPos = m.xy / iResolution.xy;\n\telse if(mbIndex == 2) mbPos = m.xy / iResolution.xy * 0.667;\n    \n    mbPos.x = mbPos.x * (iResolution.x / iResolution.y);\n\treturn mbPos;\n}\n\nfloat getMbR(int mbIndex) {\n\treturn rs[mbIndex];\n}\n\nfloat normDist(in vec2 pos, int mbIndex) {\n\tvec2 distanceVector = abs(pos - getMbPos(mbIndex));\n\treturn NORM(distanceVector.x) + NORM(distanceVector.y);\n}\n\nfloat getMbPow(in vec2 pos, int mbIndex) {\n\tfloat squareDistance = normDist(pos, mbIndex);\n\treturn NORM(getMbR(mbIndex)) / squareDistance;\n}\n\nvec3 compCol(in vec2 pos, float maxPower) {\n\tvec3 col = vec3(0.0);\t\t\n\tfor(int i = 0; i < N; i++) \t{\n\t\tcol += getMbCol(i) * (getMbPow(pos, i) / maxPower);\n\t}\n\treturn col;\n}\n\nvec4 metaballs(in vec2 pos) {\n\tconst float powerTreshold = 2.5;\n\tconst float lineSize = 1000.0;\n\tvec2 fragCoord;\n\n\tvec3 col;\n\tfloat pixPow = 0.0;\n\tint powerMeta = 0;\n\tfloat maxPower = 0.0;\n\tfor(int i = 0; i < N; i++) {\n\t\tfloat power = getMbPow(pos, i);\n\t\tpixPow \t+= power;\n\t\t\n\t\t// power = max(power, 1.);\n\n\t\tif(maxPower < power) {\n\t\t\tmaxPower = power;\n\t\t\tpowerMeta = i;\n\t\t}\n\t\t\n\t\t//power *= getMbR(i);\n\t\t//col += getMbCol(i) * power;\n\t}\n\t\n\tcol = compCol(pos, maxPower);\n\t\n\t// if( pixPow < powerTreshold) col = vec3(0.0);\n\t\n    float p = clamp(pixPow / powerTreshold, 0., 1.);\n    col *= pow(p, 1.);\n\t\n\treturn vec4(col, 1.0);\n}\n\nvec3 screen(in vec3 a, in vec3 b) {\n    return 1. - (1. - a) * (1. - b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 pos = fragCoord.xy / iResolution.xy;\n    pos.x = pos.x * iResolution.x / iResolution.y;\n\n\tvec4 mb = metaballs(pos);\n\n\tfragColor = mb;;\n}","name":"Image","description":"","type":"image"}]}