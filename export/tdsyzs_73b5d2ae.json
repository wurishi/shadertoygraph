{"ver":"0.1","info":{"id":"tdsyzs","date":"1585442142","viewed":271,"name":"Pickle (Shader) Rick","username":"LilBensson","description":"Funniest thing I've ever seen.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","rick","rickandmorty","pickle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_RAY_STEPS 100\n#define RAY_HIT_DIST 0.001\n\nvec3 lightDir = normalize(vec3(-1.0, -1.0, -0.6));\n\nvec3 greenBodyColor = vec3(0.0, 0.55, 0.0);\nvec3 brightGreenBodyColor = vec3(0.0, 0.65, 0.0);\nvec3 darkGreenSpotColor = vec3(0.0, 0.45, 0.0);\nvec3 yellowEyesColor = vec3(0.95, 0.95, 0.85);\nvec3 yellowTeethColor = vec3(0.95, 0.95, 0.85)*0.9;\nvec3 whiteBlueEyebrowColor = vec3(0.90, 0.99, 0.90);\nvec3 blackMouthColor = vec3(0.2, 0.2, 0.2);\n\n// valuateType = 0: min(d1, d2)\t\t\"normal\" sdf\n// valuateType = 1: max(-d1, d2)\t\"carve\" out shapes\nvoid ValuateSDF(inout vec4 currDist, float sdf, vec3 color, int valuateType)\n{\n\tfloat tempDist;\n    \n    if(valuateType == 0)\n    \ttempDist = min(sdf, currDist.x);\n    else if(valuateType == 1)\n        tempDist = max(-sdf, currDist.x);\n    \n    // TempDist is a better sdf\n    if(tempDist != currDist.x)\n    \tcurrDist = vec4(tempDist, color);\n}\n\nvoid SDFDeformedCapsule(inout vec4 currDist, vec3 p, vec3 p1, vec3 p2, float radius, vec3 color, int valuateType)\n{\n    // Curve the \"spine\" a bit\n    p.z += (0.6 - p.y*p.y)*0.1;\n    \n    vec3 line = p1 - p2;\n    vec3 pointDir = p - p2;\n    \n    // Project p onto the line\n    float t = dot(pointDir, line) / dot(line, line);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 tempPoint = p2 + line*t;\n    \n    // Distort the sdf, based on the current point's y-position\n    float sdf = (length(p - tempPoint) - radius) + \n        sin(p.y*7.0) * 0.005 + \n        cos(p.y*20.0 + 63.01) * 0.001;\n    \n    ValuateSDF(currDist, sdf, color, valuateType);\n}\n\nvoid SDFCapsule(inout vec4 currDist, vec3 p, vec3 p1, vec3 p2, float radius, vec3 color, int valuateType)\n{\n    vec3 line = p1 - p2;\n    vec3 pointDir = p - p2;\n    \n    // Project p onto the line\n    float t = dot(pointDir, line) / dot(line, line);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 tempPoint = p2 + line*t;\n    \n    float sdf = (length(p - tempPoint) - radius);\n    \n    ValuateSDF(currDist, sdf, color, valuateType);\n}\n\nvoid SDFSphere(inout vec4 currDist, vec3 p, vec3 pos, float radius, vec3 color, int valuateType)\n{\n\tfloat sdf = length(p - pos) - radius;\n    \n    ValuateSDF(currDist, sdf, color, valuateType);\n}\n\nvec4 Map(vec3 p)\n{\n    // currDist.x = sdf\n    // currDist.yzw = color\n    vec4 currDist = vec4(999.0, vec3(0.0));\n    \n    vec3 originalP = p;\n    \n    // Body\n    SDFDeformedCapsule(currDist, p, vec3(0.0, 0.45, 0.0), vec3(0.0, -0.65, 0.0), 0.3, greenBodyColor, 0);\n    \n    // Eyes\n    p.x = abs(p.x);\n    float r = 0.08;\n    SDFSphere(currDist, p, vec3(r+0.007, 0.4, 0.26), r, yellowEyesColor, 0);\n    \n    // Pupils\n    SDFSphere(currDist, p, vec3(r+0.02, 0.4, 0.34), 0.01, blackMouthColor, 0);\n    \n    // Eyebrow\n    p.y += p.x*p.x*1.5;\n    float partY = 0.55;\n    SDFCapsule(currDist, p, vec3(-0.12, partY, 0.27), vec3(0.12, partY, 0.27), 0.01, whiteBlueEyebrowColor, 0);\n    \n    // Mouth\n    p.y = originalP.y;\n    p.y -= p.x * p.x * 9.0 * p.y;\n    partY = 0.18;\n    SDFCapsule(currDist, p, vec3(-0.15, partY, 0.24), vec3(0.15, partY, 0.24), 0.06, blackMouthColor, 1);\n    \n    // Nose\n    p = originalP;\n    p.x = abs(p.x);\n    SDFCapsule(currDist, p, vec3(0.0, 0.4, 0.2), vec3(0.0, 0.3, 0.3), 0.02, greenBodyColor, 0);\n    \n    // Teeth\n    float allTeethZ = 0.23;\n    float teethX1 = 0.03;\n    float teethY1 = 0.01;\n    float teethZ1 = 0.01;\n    \n    // Upper teeth\n    for(float i = 0.0; i < 3.0; i += 1.0)\n    \tSDFCapsule(\n            currDist, \n            p, \n            vec3(teethX1*i, partY+0.06+teethY1*i, allTeethZ - teethZ1*i), \n            vec3(teethX1*i, partY+0.04+teethY1*i, allTeethZ - teethZ1*i), \n            0.01, \n            yellowTeethColor, \n            0\n        );\n    \n    // Lower teeth\n    for(float i = 0.0; i < 4.0; i += 1.0)\n    \tSDFCapsule(\n            currDist, \n            p, \n            vec3(teethX1*i, partY-0.04, allTeethZ - teethZ1*i*-0.8), \n            vec3(teethX1*i, partY-0.05, allTeethZ - teethZ1*i*-0.8), \n            0.01, \n            yellowTeethColor, \n            0\n        );\n    \n    // \"Weird pickle spots\"\n    // This can probably be done on a better way.\n    // Possibly by rounding the current point to a sector on the main body capsule and assigning\n    // each sector to a random point and sphere size on the capsule.\n    p = originalP;\n    SDFSphere(currDist, p, vec3(0.28, -0.3, 0.05), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(0.27, -0.35, 0.05), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(0.26, -0.6, 0.08), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(0.24, 0.1, 0.08), 0.03, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(-0.26, -0.4, 0.08), 0.027, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(-0.24, -0.5, 0.12), 0.027, darkGreenSpotColor, 0);\n    SDFSphere(currDist, p, vec3(-0.24, -0.1, 0.12), 0.027, darkGreenSpotColor, 0);\n    \n    return currDist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n\tvec2 offset = vec2(0.0, 0.0001);\n    \n    vec3 n = vec3(Map(p).x) - \n        vec3(\n            Map(p + offset.yxx).x,\n            Map(p + offset.xyx).x,\n            Map(p + offset.xxy).x\n        );\n\t\n    return normalize(n);\n}\n\nfloat GetSpecularLight(vec3 cameraPos, vec3 p, vec3 normal)\n{\n    vec3 reflectedLightDir = normalize(reflect(lightDir, normal));\n    vec3 pointToCam = normalize(cameraPos - p);\n    \n    float spec = clamp(dot(reflectedLightDir, pointToCam), 0.0, 1.0);\n    spec = pow(spec, 3.0);\n    \n    spec = smoothstep(0.35, 0.55, spec);\n    \n\treturn spec * 0.2;\n}\n\nvec3 RayMarch(vec2 uv)\n{\n    // Camera orientation\n    vec3 camLookAt = vec3(0.0);\n    vec3 camPos = vec3(1.0 * cos(iTime*0.5), 0.0, 2.3);\n    \n    vec3 camForward = normalize(camLookAt - camPos);\n    vec3 camRight = normalize(cross(camForward, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camForward));\n    \n    float zoom = 1.0;\n    \n    // Create point and direction\n    vec3 currentPos = camPos + zoom * camForward + uv.x * camRight + uv.y * camUp;\n    vec3 rayDir = normalize(currentPos - camPos);\n    \n    vec3 col = vec3(0.0);\n    \n    // Ray march loop\n    for(int i = 0; i < MAX_RAY_STEPS; i++)\n    {\n        vec4 currDist = Map(currentPos);\n        \n        // Hit!\n        if(currDist.x <= RAY_HIT_DIST)\n        {\n            vec3 normal = GetNormal(currentPos);\n            vec3 bodyNormal = normal;\n            bodyNormal.z += pow(sin(currentPos.y*abs(currentPos.x-0.5)*10.0)*0.5, 2.0) * 0.2;\n            \n            // Middle of the body\n            if(currDist.yzw == greenBodyColor)\n            {\n            \tcurrDist.yzw = mix(greenBodyColor, brightGreenBodyColor, smoothstep(0.90, 0.95, dot(bodyNormal, vec3(0.0, 0.0, -1.0))));\n            }\n            \n            // Ignore shading the teeth\n            if(currDist.yzw == yellowTeethColor)\n            {\n            \tcol = currDist.yzw;\n                \n                break;\n            }\n            \n            float diffuseShadow = smoothstep(\n                0.60, \n                0.40,\n                clamp( dot(normal, -lightDir), 0.0, 1.0 )\n            );\n            float specularLight = GetSpecularLight(camPos, currentPos, normal);\n            \n        \tcol = currDist.yzw * (max(0.7, diffuseShadow) + specularLight);\n            \n            break;\n        }\n        \n        currentPos += rayDir * currDist.x;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n   \tvec3 col = RayMarch(uv);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}