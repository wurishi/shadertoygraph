{"ver":"0.1","info":{"id":"X3SfDK","date":"1729933084","viewed":26,"name":"Example: SDF Scale ","username":"ElliotPadfield","description":"This shader renders a scaling equilateral triangle with SDFs and aspect ratio correction. UV Normalization: Adjusts UVs for aspect ratio. Scaling: Dynamically scales UVs over time. Triangle SDF: Calculates distance to triangle edge. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["example"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Reference: https://iquilezles.org/articles/distfunctions/\n\n// Scale function for SDF\nvec2 scale(vec2 p, float factor) {\n    return p / factor; // Scale `p` by the inverse of `factor`\n}\n\n// Equilateral Triangle SDF - exact (https://www.shadertoy.com/view/Xl2yDW)\nfloat sdEquilateralTriangle(in vec2 p, in float r) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r / k;\n    if (p.x + k * p.y > 0.0) p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0 * r, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Step 1: Normalize UV coordinates with aspect ratio correction\n    // https://www.shadertoy.com/view/lf2fWw\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.0 * fragCoord - R) / min(R.x, R.y); // Normalize to [-1, 1] along the shortest side\n\n    // Step 2: Define scale factor and triangle size\n    float scaleFactor = 1.5 + 0.5 * sin(iTime); // Dynamic scaling over time\n    float size = 0.2;    // Half-size of the triangle (controls triangle dimensions)\n\n    // Step 3: Apply scaling to `uv`\n    vec2 scaledUV = scale(uv, scaleFactor);\n\n    // Step 4: Compute SDF for the triangle\n    float dist = sdEquilateralTriangle(scaledUV, size);\n\n    // Step 5: Anti-aliasing for smooth edges\n    // https://www.shadertoy.com/view/MfjBDw\n    float pix = 1.5 / min(R.x, R.y); // Pixel width (Adjusted to use min(R.x, R.y) for consistent pixel scaling)\n    float aa = smoothstep(-pix / 2., pix / 2., dist); // Adjusted smoothstep for smoother anti-aliasing transition\n\n    // Step 6: Render the triangle with color\n    vec3 triangleColor = mix(vec3(0.0, 1.0, 0.0), vec3(0.0), aa); // Blue triangle\n    fragColor = vec4(triangleColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}