{"ver":"0.1","info":{"id":"MlyGDy","date":"1476465278","viewed":288,"name":"006 euler ui canvas","username":"ollj","description":"this is not quite right and i ai am pretty sure its more than euler issues\n\ninput:\nmove:     e,s,d,f,c,space,arrows,PgUp,PgDn\nrotate:      mouse, w,r,End,Home\nset fow:  1,2\n","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["shadow","ao","keyboard","rotation","euler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//merger of https://www.shadertoy.com/view/XtG3DG\n//and       https://www.shadertoy.com/view/XlyGDy\n\n// Inverse Perspective by HLorenzi\n// (Distance Functions by iquilezles.org)\n// modified by ollj (no globals; no shadow; no materials; no slider)\n\n#define kMaxIterations 256\n\n//#define dynamicEps\n//dynamicEps, higher detail close up and longer max distance.\n//but a lot more artefacts iverall\n//turns out setting epsilon=0 is better than dynamic epsilon!\n//dynamicEps can be better for VERY concave but open scenes (like a skyline)\n//dynamicEps converges faster on convex scenes (asteroid fields).\n\n//addrssing.start: this must be identical in each buffer\n//imagine a buffers xy coordinates as namespace, all buffers must use the same namespaces.\n//\n//get buffered data from iChannel0\n#define get2(a,b) texture(iChannel0,vec2(a,b+.5)/iResolution.xy,1.)\n#define get(a)    texture(iChannel0,vec2(a,  .5)/iResolution.xy,1.)\n#define getz(a) get(a).xyz\n//positions in nth derivatives\n//float pos1=1.5;\nfloat pos0=3.5;\n//rotations in nth derivatives\n//float rot1=5.5;\nfloat rot0=7.5;\n//a slider used to set fow.\nfloat fow=9.5;\n//\n//addrssing.End: this must be identical in each buffer\n\n#define v3p(b) a.xyz*a.b\nmat3 EulerToMat(vec3 p){vec3 s=sin(p),c=cos(p);\n return mat3(c.z*c.x,-c.z*s.x,c.z*s.x*s.y+s.z*c.y\n ,s.x ,c.x*c.y ,-c.x*s.y\n ,-s.z*c.x ,s.z*s.x*c.y+c.z*s.y ,-s.z*s.x*s.y+c.z*c.y);}\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/\n\n\nvoid opU(inout float a,float b){a=min(a,b);}\nfloat dfBox(vec3 p,vec3 s,float r){return length(max(abs(p)-s+vec3(r),0.0))-r;}\n\n//MaterialColor() is a placeholder reminder that\n//EVERY space in 3d is assigned a material\n//and this function does it.\n//by calling a simpler COPY of df();\n//because in the end df() can hit a \"surface\" anywhere.\n//because MaterialColor() is likely called in df();\n//vec3 MaterialColor(vec3 p){return vec3(.5);}\n\n#define pMod(x,d) (mod(x+d*.5,d)-d*.5)\n\nfloat df(vec3 p){\n float r=p.z-.06*sin(1.5*length(p.xy             )-iTime)\n            -.04*sin(1.5*length(p.xy*.61-vec2(55))-iTime);\n                 p.z+=.5;\n //p.z=pMod(p.z,100.);\n vec3 q=vec3(pMod(p.xy,vec2(20,10)),p.z);\n opU(r,length(q-vec3(0,0,5))-1.);\n q=vec3(pMod(p.xy,vec2(17,13)),p.z);\n opU(r,dfBox(q-vec3( 3, 1,1.05),vec3(2),1.5));\n q=vec3(pMod(p.xy,vec2(61,21)),p.z);\n opU(r,dfBox(p-vec3(-3, 1,1.05),vec3(2),1.2));\n opU(r,dfBox(p-vec3( 0,-3,1.05),vec3(2),.7));return r;}\n\nvec3 normal(vec3 p){const vec2 e=vec2(.01,0);\n vec3 n=vec3(df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx));\n if(length(n)<0.01)return vec3(0);//makes is easier to distinguish if the camera is far from any surface.\n return normalize(n);}\n\n//vec3 normal(vec3 p){const vec2 e=vec2(.01,0);return normalize(vec3(\n// df(p+e.xyy)-df(p-e.xyy),df(p+e.yxy)-df(p-e.yxy),df(p+e.yyx)-df(p-e.yyx)));}\n\n\nfloat raymarch(vec3 o,vec3 i){float e,d;for(int j=0;j<kMaxIterations;j++){float p=df(o+i*d);if(p<e)return d;d+=p;\n#ifdef dynamicEps                                 \n e=e+.000000001+e*1.0000000001;\n#endif\n }return d;}\n\n\n//float shadow(vec3 o,vec3 i){const float minDist=1.;float r=1.,t=.25;\n// for(int j=0;j<10;j++){r=min(r,4.*df(o+i*t)/t),t+=.25;}return r;}\n\nfloat ambientOclussion(in vec3 p, in vec3 n) {\n float s = 0.1;\n float r = 1.0;\n vec4 v = vec4( n*s,s);\n vec4 m = vec4(p,0.0) + v;\n for (int i=0; i < 5; i++){\n  r-=(m.w-df(m.xyz))*.25;\n  m+=v;\n }return max(r,0.0);}\n\nfloat softShadow( in vec3 o, in vec3 i, float n, float m){\n float r=1.,t=n,k=.05;const float s=100.,u=1.+.78/sqrt(s*.5);\n //not perfect, decent for s range[10.100]\n for(float j=0.;j<s;j++){\n  float h=df(o+i*t)/(s+1.);\n  if(h<0.)return 0.;\n  r=min(r,(k*h/t));\n  t=t*u+h;//mod by ollj allows for smaller [n]\n     if(t > m)break;}\n  return r*s*79./length(i);}\n//https://iquilezles.org/articles/rmshadows\n\nvoid camera(vec2 q,vec3 e,vec3 t,vec3 u,out vec3 o,out vec3 i,float v){\t\n vec3 z=normalize(t-e),x=normalize(cross(z,u)),y=normalize(cross(x,z))*q.y;x*=q.x;//vec3 x,y,z==vec3 u,v,w\n float f=acos(dot(z,normalize(x))),//fow.xy\n s=(10./(2.*tan(abs(f)/2.)));o=e+(x+y)*(.15+.5*v)*s;i=normalize((e+z*2.+(x+y)*s)-o);}\n\nvec3 pixel(vec2 q,float v,float h){float dist=4.; \n vec3 e=getz(pos0);\n     //t+vec3(cos(iTime/2.0)*dist,sin(iTime/2.)*dist,0.25+h*2.);//EyePos\n mat3 l=EulerToMat(getz(rot0).xyz);\n vec3 t=e+vec3(1,0,0)*l;\n     //vec3(0,0,1); //target\n vec3 u=vec3(0,0,1)*l;//e+vec3(e.xy,1.);//*l;;//*AxisAngle2Mat(vec4(g,length(g)));//up\n vec3 f,i;//fow,direction\n camera(q,e,t,u,f,i,v);//set f and i\n vec3 p=f+i*raymarch(f,i);\n vec3 light0p=vec3(21.,10.,20.);\n vec3 light0=normalize(light0p);//normalize(light0Dir*9.0-p);\n vec3 n=normal(p);\n //following branch catches a lot of perspective issues:                              \n //if (length(p-e)>600.)n=vec3(0);//set normal of p>\"zFar\" to -t.\n //else \n     if(n==vec3(0))n=vec3(0);//set normal of p<\"zNear\" to t.\n vec3 c=n*.5+.5;\n //float s=shadow(p+n*.1,vec3(1,2,3));\n vec3 tolight=light0p-p;\n float s=ambientOclussion(p,n)*softShadow(p,tolight,.005,length(tolight));\n //c*=s;\n c=c*.5+c*s*.5;//mix(c-vec3(.1),c,s);\n //c*=max(dot(n,normalize(vec3(1,2,3))),0.)*.5+.5;//diffuse light\n if(dot(n,light0)>0.){float s=min(1.,pow(max(0.,dot(reflect(-light0,n),normalize(f-p))),50.));\n  return mix(c,vec3(1),s*.75);}\n return c;}\n\n#define clampe(a) clamp(-.2+1.4*(iMouse.a/e.a*2.),0.,2.)\nvoid mainImage2(out vec4 r,in vec2 i){\n vec2 e=iResolution.xy,p=i/e;p=p*2.-vec2(1);p.x*=e.x/e.y;\n    float a=   clamp(9.*(-.5+(get(fow).x)),0.,2.);\n    float b=2.-clamp(-.2+1.4*(iMouse.y/e.y*2.),0.,2.);\n r=vec4(pixel(p,a,b),1);}\n\n#define clampe(a) clamp(-.2+1.4*(iMouse.a/e.a*2.),0.,2.)\nvoid mainImage(out vec4 r,in vec2 i){\n //r=get2(i.x*.1,r.y);//render only bufferA\n if(i.x<55.)r.xyz=texture(iChannel0,.3*i/iResolution.xy).xyz;else //splitscreen render bufferA\n mainImage2(r,i);\n \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//todo\n//i finally made some camera parameters, and the image can read these buffered values\n//and then set a camera with them\n\n//use for first person movement; uncomment for 3rd person movement, where the agent is at the camera target.\n#define FirstPerson\n\n//start: must be identical in each buffer\n//for cross-refferencig addresses:\n//\n//get buffered data from iChannel0\n#define get2(a,b) texture(iChannel0,vec2(a,b+.5)/iResolution.xy,1.)\n#define get(a)    texture(iChannel0,vec2(a,  .5)/iResolution.xy,1.)\n#define getz(a) get(a).xyz\n//positions in nth derivatives\nfloat pos1=1.5;\nfloat pos0=3.5;\n//rotations in nth derivatives\nfloat rot1=5.5;\nfloat rot0=7.5;\n//a slider used to set fow.\nfloat fow=9.5;\n//\n//end: must be identical in each buffer\n\n//get keyboard input from iChannel3\n//(y==.5) true while held down,\n//(y==1.5) true for 1 frame when toggled from unpressed to pressing\n//(y>1.5)  if(b==0) toggle between true and false \n#define ki0(a) texture(iChannel3,(vec2(a,0.5))/vec2(256.,3.)).x \n\n//how much of x1 gets added to x0; larger factor==more accelleration per frame.\n#define AccelP 9.*iTimeDelta\n#define AccelR 1.*iTimeDelta\n//maximum absolute speeds (directional and rotational), hard cap\n#define SpeedMaxP 100000.\n#define SpeedMaxR 10.\n//friction, positional and rotational\n#define FrictionP .9*iTimeDelta\n#define FrictionR .1*iTimeDelta\n\n//#define set(a,b) if(gl_FragCoord.x==a.x+0.5&&gl_FragCoord.y==a.y+0.5){b;return true;}\n//#define set(a,b) if(gl_FragCoord.xy==a.xy+0.5){b;return true;}\n//#define set(a,b) if(a.xy+0.5==gl_FragCoord.xy){b;return true;}\n//#define clampe(a) clamp(-.2+1.4*(iMouse.a/e.a*2.),0.,2.)\n\n//for now,the axisangle solution performs better than quaternions.\n//return matrix of normalized quternion\n//mat3 quatToMat(vec3 q){return mat3(0);}\n//vec3 RotPByQuaternion(vec3 p,vec4 q){return vec3(0);}\n\n#define v3p(b) a.xyz*a.b\n//return mat3 of a.xyz=<-axis a.z<-angle;\nmat3 AxisAngle2Mat(vec4 a){float c=cos(a.z);\nreturn c*mat3(1)+(1.-c)*mat3(v3p(x),v3p(y),v3p(z))\n      +sin(a.z)*mat3(0.,-a.z,a.y,a.z,0.,-a.x,-a.y,a.x,0.);}\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToMatrix/index.htm\n\n//vec2 sc(float p){return vec2(sin(p),cos(p)};}\n\n/*\nfloat mulC(vec3 p){return p.x*p.y*p.z);}                            \nvec4 Euler2AxisAngle(vec3 p){p*=.5;//.xyz=heading,altitude,bank\n vec3 s=sin(p),c=cos(p);\n vec4 r;\n r.w=2.*acos(mulC(c)-mulC(s));\n r.x=s.x*s.y*c.z+c.x*c.y*s.z\n// x=s1  s2  c3 +c1  c2  s3\n r.y=s.x*c.y*c.z+c.x*s.y*s.z\n// y=s1  c2  c3 +c1  s2  s3\n r.z=c.x*s.y*c.z-s.x*c.y*c.z\n// z=c1  s2  c3 -s1  c2  s3\n return r;}\n*/\n\nmat3 EulerToMat(vec3 p){vec3 s=sin(p),c=cos(p);\n return mat3(c.z*c.x,-c.z*s.x,c.z*s.x*s.y+s.z*c.y\n ,s.x ,c.x*c.y ,-c.x*s.y\n ,-s.z*c.x ,s.z*s.x*c.y+c.z*s.y ,-s.z*s.x*s.y+c.z*c.y);}\n//http://www.euclideanspace.com/maths/geometry/rotations/conversions/eulerToMatrix/\n\n//sets hard max absolute speed limits, does not do exponential friction.\n//maxcap sets a hard max speed, absolute length.\nvec3 maxCap(vec3 r,float m){return min(r/(1.+max(abs(length(r))-m,0.)),r);}\n //float a=max(abs(length(r))-m,0.);//a tells by how much r is too long:\n //0= max length, or shorter. //1=2x longer than allowed. to multiply by 1/2\n //2=3x as long as allowed.  to multiply by 1/3  //... to multiply by 1/(1+a), to divide by /(1+a)\n\n\n//to fix (too tricky within shadertoy):\n//does not care for mass or volume or surface effects.\n//AccelP|AccelR accellerate linearily over time. but accelleration should diminish with speed.\nvec4 setP(float a){\n if(a==pos1){vec3 p=getz(pos1)*FrictionP;\n  float y=max(ki0(83.5),ki0(37.0))-max(ki0(70.5),ki0(39.5));\n  float x=max(ki0(69.5),ki0(38.5))-max(ki0(68.5),ki0(40.0));\n  float z=max(ki0(32.5),ki0(33.5))-max(ki0(67.5),ki0(34.0));//jump/crouch\n  vec3 m=vec3(x,y,z);\n  m=maxCap(m,1.);//diagonal movement capped to length 1.\n  p+=m;\n  return vec4(p,1.);\n }if(a==pos0){vec3 p=getz(pos0);\n  #ifdef FirstPerson\n  p+=(getz(pos1)*EulerToMat(getz(rot0)))*AccelP;\n  #else\n  p+=getz(pos1)*AccelP;//this is old nonsense\n  #endif\n  return vec4(p,1.);\n }if(a==rot1){vec3 p=getz(rot1)*FrictionR;\n  float z=max(ki0(82.5),ki0(35.5))-max(ki0(87.5),ki0(36.0));//.z s rolling;\n  vec2 xy=(iMouse.xy/iResolution.xy)-.5;\n  vec3 m=vec3(-xy.x,z,-xy.y);\n  m=maxCap(m,1.);//diagonal rotation capped to length 1.\n  p+=m;\n  return vec4(p,1.);\n }if(a==rot0){\n  vec3 p=getz(rot0)+getz(rot1)*AccelR;\n  return vec4(p,1.);\n }if(a==fow){\n  vec3 p=getz(fow);\n  p.x+=(ki0(49.5)-ki0(50.5));\n  //p=clamp(vec3(0),vec3(1),p);\n  return vec4(p,1.);\n }return vec4(0);}\n\nvoid mainImage(out vec4 r,in vec2 i){\n if (i.y<=1.)r=setP(i.x);\n  else r=get2(i.x,i.y-.6);//optionaly copy to row with delay.\n}","name":"Buf A","description":"","type":"buffer"}]}