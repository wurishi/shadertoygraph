{"ver":"0.1","info":{"id":"ls2yWV","date":"1493921674","viewed":166,"name":"Julia Fractal Morph Smooth Color","username":"DonKarlssonSan","description":"Julia Fractal morphed by a point along a Lissajous curve.\nSmooth (continuous) colors by \"normalized iteration count\", see: \nhttps://linas.org/art-gallery/escape/smooth.html \nand\nhttps://en.wikipedia.org/wiki/Mandelbrot_set#Continuous_.28smooth.29_coloring","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nconst float a = 5.0;\nconst float b = 4.0;\nconst float w = PI / 2.0;\n\n// From Stackoveflow\n// http://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 lissajous() {\n    float t = iTime/10.0+219.17;\n    float x = sin(a * t + w);\n    float y = sin(b * t);\n\treturn vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float xmin = -2.0;\n    float ymin = -1.4;\n    float xmax = 2.0;\n    float ymax = 1.4;\n    float xDelta;\n    float yDelta;\n    xDelta = (xmax - xmin) / iResolution.x;\n    yDelta = (ymax - ymin) / iResolution.y;\n    int iteration = 0;\n    const int max_iteration = 100;\n    vec2 l = lissajous();\n    float x = xmin + fragCoord.x * xDelta;\n    float y = ymin + fragCoord.y * yDelta;\n    // while loop not supported on iPhone !!\n    // Using a for loop with break condition instead.\n    for (int i = 0; i < max_iteration; i++) {\n        // Multiplication of complex numbers:\n        // (a+bi) (c+di) = (ac-bd) + (bc+ad)i\n        // c^2 = (x+yi) (x+yi) = (xx-yy) + (yx+yx)i = (xx-yy) + (2xy)i\n        float xtemp = x * x - y * y + l.x;\n        y = 2.0 * x * y + l.y;\n        x = xtemp;\n        iteration = i;\n        if(x*x + y*y > 16.0) break;\n    }\n \n    float log_zn;\n    float nu;\n    float sm = float(iteration);\n    float s = 0.0;\n    float v = 0.0;\n    if (iteration < max_iteration ) {\n        // sqrt of inner term removed using log simplification rules.\n        log_zn = log( x*x + y*y ) / 2.0;\n        nu = log( log_zn / log(2.0) ) / log(2.0);\n        // Rearranging the potential function.\n        // Dividing log_zn by log(2) instead of log(N = 1<<8)\n        // because we want the entire palette to range from the\n        // center to radius 2, NOT our bailout radius.\n        sm=float(iteration) + 1.0 - nu;\n        s = 1.0;\n        v = 0.5;\n    }\n    \n    float c = sm / float(max_iteration)*50.0 + iTime/10.0;\n    vec3 hsv = hsv2rgb(vec3(c, s, v));\n    fragColor = vec4(hsv, 1.0);\n}","name":"Image","description":"","type":"image"}]}