{"ver":"0.1","info":{"id":"stSXzD","date":"1627247099","viewed":116,"name":"Auto-Diff sine | Dual Numbers","username":"Yusef28","description":"Just a quick exploration with lot's of comments:\n[url]http://blog.jliszka.org/2013/10/24/exact-numeric-nth-derivatives[/url]\nand here:\n[url]http://blog.sigfpe.com/2005/07/automatic-differentiation.html[/url]","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ad","autodiff","autodiff","automaticdifferentiation","dualnumbers","autodifferentiation","dn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////\n//\n// Author:Yusef28\n// Start Date: 24-07-2021\n// Status: On Going\n// Topic: Automatic Differentiation | Dual Numbers \n// Sources: \n// http://blog.jliszka.org/2013/10/24/exact-numeric-nth-derivatives\n// http://blog.sigfpe.com/2005/07/automatic-differentiation.html\n// iq: https://www.shadertoy.com/view/Mdl3Ws\n// paniq: https://www.shadertoy.com/view/4dVGzw\n// oneshade: https://www.shadertoy.com/view/stl3DS\n\n\n// Automatic Differentiation (auto-diff) is a technique that\n// allows one to compute operations on two vectors and end up\n// with the result of the calculation and the dervatives as well.\n// sometimes derivaties suck to calculate symbolically because you\n// could end up typing very large expressions by hand.\n// Here I describe a method that uses a type of number called a \n// \"Dual number\". It looks a lot like a complex number and follows a \n// similar rule.\n// here instead of i we call it e, so it will look like 3  + 1e\n// The thing we want to say about e is that e^2 is zero. \n// otherwise it's basically a 1?\n// we create a number system based on that principle. doing that means\n// expansion of any (3+1e)(3+1e) expression will result in the 3*4e^2 term\n// being zero and disappearing leaving just (9 + 6e) where 9 = 3^2\n// and 6 = 2*3 (the derivative of 3^2) \n \n// \"The most important equation in mathematics is x^2=0\"\n// ~ Sir Michael Atiyah\n// from: http://blog.sigfpe.com/2005/07/automatic-differentiation.html\n\n// This is our dual number structure, n is real part, e is dual part\n// I am not using matrixes here though. I'm going with a basic struct.\nstruct DN{\n    float n;\n    float e;\n};\n\n\n//we can add like this\nDN add(DN a, DN b){\n    \n    DN answer;\n    answer.n = a.n+b.n;\n    answer.e = a.e+b.e;\n    \n    return answer;\n}\n//we can mult like this\nDN mult(DN a, DN b){\n\n    DN answer;\n    answer.n = a.n*b.n;\n    //the derivative of x^2 is 2x which is x + x\n    //so the dervative of x*y is x + y\n    //which is what you get here assuming the e's are both\n    //basicallys 1's (1's that sqaure to zero)\n    //(a+1)(b+1) = a*b + a*1 + 1*b + 0\n    //a*b is the mult, a + b \n    answer.e = a.n*b.e + a.e*b.n;\n    \n    return answer;\n}\n\n//to understand trigonometric operations on dual numbers\n//it's helpful to know how the taylor series of sin(a + be) looks\n//https://math.stackexchange.com/questions/900541/implementing-trig-functions-for-dual-numbers\n//short for is you get a new identity\\\n//sin(a + be) = be*cos(a) \"sinabe\" = \" because ah\" or something.\n//\"sinna's be like 'because ah'\" just excuses. or something..\n\nDN sinous(DN z){\n\n    DN answer;\n    \n    answer.n = sin(z.n);\n    //ofcourse it shoud be the cos of z.n since that's \n    //the derivative of sine.\n    answer.e = z.e*cos(z.n);\n    \n    return answer;\n}\n\n//for inverse check out this article\n//https://www.euclideanspace.com/maths/algebra/realNormedAlgebra/other/doubleNumbers/functions/inverse/index.htm\n//we start with 1/(a + be) and multiply with the conjugate \n//(a+be)/(a-be) to get rid of the e on the bottom. It turns into\n//(a-be)/(a^2-b^2) -> a/(a^2-b^2) - be/(a^2-b^2)\n\nDN inv(DN z){\n\n    DN answer;\n    \n    answer.n = z.n/(z.n*z.n - z.e*z.e);\n    answer.e = -z.e/(z.n*z.n - z.e*z.e);\n    \n    return answer;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5,0.5)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n    vec2 st = uv;\n    //I'm only making an 8(*aspect)x8 grid, higher variables\n    //may end up with graphs completely outside it\n    uv*=8.;\n    //graph background\n    vec3 col = vec3(0.8);\n    col = mix(col,vec3(0.9),1.0-length(uv/8.));\n   // float specks = fract(sin(dot(uv,vec2(123.,16.)))*433413.);\n    \n    float tex = texture(iChannel0,st).x;\n    col = mix(col,vec3(0.7),tex);\n    \n    //small grid lines\n    vec2 lines = fract(uv*3.);\n    lines = smoothstep(0.45,0.5,abs(lines-0.5));\n    col = mix(col,vec3(0.7),lines.x);\n    col = mix(col,vec3(0.7),lines.y);\n    //larger grid lines\n    lines = fract(uv);\n    lines = smoothstep(0.45,0.5,abs(lines-0.5));\n    col = mix(col,vec3(0.3),lines.x);\n    col = mix(col,vec3(0.3),lines.y);\n    //axis lines\n    lines = smoothstep(0.02,0.025,abs(uv));\n    col = mix(col,vec3(0.,0.,0.0),1.0-lines.x);\n    col = mix(col,vec3(0.,0.,0.0),1.-lines.y);\n    \n    //a dual number\n    DN a;\n    a.n = uv.x;\n    a.e = 1.;\n    \n    //to test multiplication uncomment and mult with a,b\n    //DN b;\n    //b.n = 2.;\n    //b.e = 1.;\n    \n    //another dual number\n    DN answer;\n    answer = sinous(a);//mult(a,a);//mult(a,b);//inv(a);//add(a,a);//\n    //Time varying pixel color\n    \n    DN c;\n    c.n = answer.e;\n    c.e = 1.;\n    \n    //graph of: sin - y = 0\n    //float f = 1.0-smoothstep(0.02,0.06,abs(answer.n-uv.y));\n    //float f = 1.0-smoothstep(0.02,0.15,abs(answer.n-uv.y)/fwidth(answer.n-uv.y)/20.);\n     float f = 1.0-smoothstep(0.02,0.15,abs(answer.n-uv.y)/(abs(answer.e)+1.)*3.);\n    col = mix(col, vec3(1.,0.,0.), f);\n    \n    //graph of: (first derivative of sin) - y = 0\n    //f = 1.0-smoothstep(0.02,0.06,abs(answer.e-uv.y));\n    f = 1.0-smoothstep(0.02,0.15,abs(answer.e-uv.y)/fwidth(answer.e-uv.y)/20.);\n    col = mix(col, vec3(0.,0.,1.), f);\n    \n    //What I need to understand next is how to chain\n    //auto-diff operations together since we end up with\n    //an e that isn't 1 anymore.\n    //we can always reset every e to 1 at the start of a function\n    //since we do one operation at a time we just need to\n    //hold onto the last dervative which we would?\n    //answer = mult(answer,answer);\n\n    //vignette\n    uv = fragCoord/iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = uv.x*uv.y * 15.0; // multiply with sth for intensity\n    \n    vig = pow(vig, 0.15); // change pow for modifying the extend of the  vignette\n\n    // Output to screen\n    fragColor = vec4(col*vig,1.0);\n}","name":"Image","description":"","type":"image"}]}