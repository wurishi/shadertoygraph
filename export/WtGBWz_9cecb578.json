{"ver":"0.1","info":{"id":"WtGBWz","date":"1614141051","viewed":344,"name":"Procedural Warping","username":"ArenaGrenade","description":"Organic looking Procedural warping with colourful shading.","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["noisewarpingproceduralorganic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_OCTAVES 3\n#define SPEED_SCALE 0.5\n\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83 - one of the best gists to exist\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\n// Rotation matrix\nconst mat2 rot_mat = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nvoid rotate_point(inout vec2 p) {\n    // This line just generates a random value between 2.01 and 2.04\n    float factor = 2.01 + float(int(rand(p) * 100.0) % 4) * 0.01;\n    p *= (rot_mat * 2.04);\n}\nfloat calculate_iteration(inout float frequency, inout float amplitude, vec2 p, float addend) {\n    float f = amplitude * noise(frequency * p + addend);\n    amplitude *= 0.5;\n    frequency *= 2.0;\n    return f;\n}\nfloat fbm(vec2 p) {\n    float amplitude = 0.5;\n    float frequency = 0.5;\n    float f = 0.0;\n    \n    for (int i = 0 ; i < NUM_OCTAVES; i++) {\n        if (i == 0) {\n            f += calculate_iteration(frequency, amplitude, p, iTime * SPEED_SCALE);\n        } else {\n            f += calculate_iteration(frequency, amplitude, p, sin(iTime * SPEED_SCALE + noise(p)));\n        }\n        rotate_point(p);\n    }\n    \n    return f / 0.96975;\n}\n\n// A very simple warping\nfloat warp(vec2 p, int depth) {\n    float val = fbm(p);\n    for (int i = 0; i < depth; i++) val = fbm(p + val);\n    return val;\n}\n\nvec3 calculate_normal(vec2 p) {\n    float d = warp(p, 2);\n    vec2 e = vec2(0.01, 0);\n    \n    vec3 n = d - vec3(\n        warp(p - e.xy, 2),\n        2.0 * e.x,\n        warp(p - e.yx, 2)\n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float density = warp(uv, 2);\n    \n    vec3 col = vec3(0.0);\n    // Apply Density based color-gradient from a lagoon blue\n    col = mix(vec3(2.0, 83.0, 125.0) / 255.0, vec3(1.0, 132.0, 169.0) / 255.0, smoothstep(0.0, 0.05, density));\n    col = mix(col, vec3(1.0, 191.0, 196.0) / 255.0, smoothstep(0.05, 0.3, density));\n    col = mix(col, vec3(169.0, 232.0, 219.0) / 255.0, smoothstep(0.3, 0.5, density));\n    col = mix(col, vec3(224.0, 247.0, 230.0) / 255.0, smoothstep(0.5, 0.7, density));\n    \n    col = 1.0 - col;\n    \n    // Lighting\n    vec3 n = calculate_normal(uv);\n    vec3 l = vec3(0.9, -0.02, -0.4);\n    // vec3 lig = normalize(l - vec3(uv.xy, density));\n    vec3 lig = l;\n    \n    float diffuse_intensity = 0.3;\n    float diffuse = clamp(diffuse_intensity + (1.0 - diffuse_intensity) * dot(n, lig), 0.0, 1.0);\n\n    vec3 i = vec3(0.85,0.90,0.95);\n    vec3 bdrf = clamp(i * (n.y * 0.5 + 0.5) + (1.0 - i) * diffuse, 0.8, 1.0);\n    \n    col *= bdrf;\n    col = vec3(1.0)-col;\n    col = col*col;\n    col *= vec3(1.2,1.2,1.2);\n    col = clamp(col, 0.0, 1.0);\n    \n    fragColor = vec4(vec3(col), 1.0);\n}","name":"Image","description":"","type":"image"}]}