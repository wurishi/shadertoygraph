{"ver":"0.1","info":{"id":"tst3WS","date":"1569252112","viewed":1081,"name":"Resolution independent starfield","username":"AntoineC","description":"Stars are very small in respect to pixel size! This shader is an attempt to render a star field that looks the same under various resolutions by changing the brightness instead of changing the size of the stars.  ","likes":25,"published":1,"flags":0,"usePreview":0,"tags":["2d","star","starfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Goals:\n//  - Star sizes should not change when switching to fullscreen\n//  - Perceived brightness should not change with resolution (somewhat exclusive with goal one!)\n//  - Reduce flickering when scrolling\n\n\n\n// Dave Hoskins hash functions\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx) - 0.5;\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx+19.19);\n    return -1.0+2.0*fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// IQ's Gradient Noise\nfloat Gradient2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash22( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash22( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash22( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash22( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\nconst vec3 cold = vec3(255.0, 244.0, 189.0)/255.0;\nconst vec3 hot  = vec3(181.0, 236.0, 255.0)/255.0;\n\nvec3 StarFieldLayer(vec2 p, float du, float count, float brightness, float size)\n{\n    // Tiling:\n    vec2 pi;\n    du *= count;    p *= count;\n    pi  = floor(p); p  = fract(p)-0.5;\n  \n    // Randomize position, brightness and spectrum:\n    vec4 h = hash42(pi);\n\n    // Resolution independent radius:\n    float s = brightness*(0.7+0.6*h.z)*smoothstep(0.8*du, -0.2*du, length(p+0.9*h.xy) - size*du);\n\n    return s*mix(mix(vec3(1.), cold, min(1.,-2.*h.w)), hot, max(0.,2.*h.w));\n}\n\nvec3 StarField(vec2 p, float du)\n{\n    vec3 c;\n    c  = StarFieldLayer(p, du, 25.0, 0.18, 0.5); \n    c += StarFieldLayer(p, du, 15.0, 0.25, 0.5); \n    c += StarFieldLayer(p, du, 12.0, 0.50, 0.5); \n    c += StarFieldLayer(p, du,  5.0, 1.00, 0.5); \n    c += StarFieldLayer(p, du,  3.0, 1.00, 0.9); \n\n    // Cluster:\n    float s = 3.5*(max(0.2, Gradient2D(2.0*p*vec2(1.2,1.9)))-0.2)/(1.0-0.2);\n    c += s*StarFieldLayer(p, du, 160.0, 0.10, 0.5); \n    c += s*StarFieldLayer(p, du,  80.0, 0.15, 0.5); \n    c += s*StarFieldLayer(p, du,  40.0, 0.25, 0.5); \n    c += s*StarFieldLayer(p, du,  30.0, 0.50, 0.5); \n    c += s*StarFieldLayer(p, du,  20.0, 1.00, 0.5); \n    c += s*StarFieldLayer(p, du,  10.0, 1.00, 0.9); \n\n    c *= 1.3;\n    \n    // Resolution independent brightness:\n    float f = 1.0 / sqrt(660.0*du);\n\n    return f*min(c, 1.0);\n}\n\n\nvoid mainImage( out vec4 o, in vec2 v )\n{\n    float du = 1.0 / iResolution.y;\n    vec2  uv = du*(v-0.5*iResolution.xy) + 1.33 + iTime/30.0;\n    o = vec4(StarField(uv, du), 0.0);\n}","name":"Image","description":"","type":"image"}]}