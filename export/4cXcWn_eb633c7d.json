{"ver":"0.1","info":{"id":"4cXcWn","date":"1720973490","viewed":50,"name":"Fork PathTracin drainschol 485","username":"drainscholar","description":"pathtracer1","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["gpu"],"hasliked":0,"parentid":"43GSDc","parentname":"PathTracing1"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265358979323846\n#define HALF_PI (PI / 2.0f)\n#define TWO_PI (2.0f * PI)\n#define NUM_BOUNCES 8\n#define NORMAL_NUDGE 0.01f\nfloat minDistance = 0.001f;\nfloat maxDistance = 10000.0f;\nfloat fov = 135.0f;\n\nstruct HitInfo{\n    float distance;\n    vec3 normal;\n    vec3 albedo;\n    vec3 emissive;\n};\n\nstruct Quad{\n    vec3 A;\n    vec3 B;\n    vec3 C;\n    vec3 D;\n    vec3 albedo;\n    vec3 emissive;\n};\n\nstruct Sphere{\n    vec3 center;\n    float r;\n    vec3 albedo;\n    vec3 emissive;\n};\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n \nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n \nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * TWO_PI;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n// \nbool hitQuad(in vec3 rayOrigin, in vec3 rayDirection,inout HitInfo info, in vec3 S1, in vec3 S2, in vec3 S3, in vec3 S4){\n    vec3 dS2S1 = S2-S1;\n    vec3 dS3S1 = S3-S1;\n    //plane normal\n    vec3 normal = normalize(cross((dS2S1),(dS3S1)));\n    \n    vec3 dR = rayOrigin-rayDirection;\n    \n    float ndotdR = dot(normal,dR);\n    \n    if(ndotdR<minDistance){\n        return false;\n    }\n    \n    float t = - dot(normal,rayOrigin-S1)/ndotdR;\n    vec3 M = rayOrigin + t*dR;\n    \n    vec3 dMS1 = M-S1;\n    // S1S2S3\n    float u = dot(dMS1,dS2S1);\n    float v = dot(dMS1,dS3S1);\n    if(u>=0.0f && u <= dot(dS2S1,dS2S1) && v>=0.0f && v<dot(dS3S1,dS3S1)){\n        if (abs(t)>minDistance && t<= info.distance) {\n            info.normal = normal;\n            info.distance = t;\n            return true;\n        }\n    }\n    // Test against triangle S1S3S4\n    vec3 dS4S1 = S4 - S1;\n    vec3 dS3S4 = S3 - S4;\n    u = -dot(dMS1, dS4S1);\n    v = -dot(dMS1, dS3S4);\n    if (u >= 0.0f && u <= dot(dS4S1, dS4S1) && v >= 0.0f && v <= dot(dS3S4, dS3S4)) {\n        if (t > minDistance && t <=info.distance) {\n            info.normal = normal;\n            info.distance = t;\n            return true;\n        }\n    }\n    return false;\n}\n\nbool hitSphere(in vec3 rayOrigin, in vec3 rayDirection, inout HitInfo info, in vec4 sphere) {\n    float r = sphere.w;\n    vec3 oc = rayOrigin - sphere.xyz;\n    float a = dot(rayDirection, rayDirection);\n    float b = 2.0f * dot(oc, rayDirection);\n    float c = dot(oc, oc) - r * r;\n\n    float discriminant = b * b - 4.0f * a * c;\n    if (discriminant < 0.0f) {\n        // Miss\n        return false;\n    }\n\n    float rootDiscriminant = sqrt(discriminant);\n    float root0 = (-b - rootDiscriminant) / (2.0 * a);\n    float root1 = (-b + rootDiscriminant) / (2.0 * a);\n    float t;\n    if (discriminant > 0.0f) {\n        t = min(root0, root1);\n    } else if (root0 > 0.0f) {\n        t = root0;\n    } else {\n        t = root1;\n    }\n\n    if (t>minDistance && t <= info.distance) {\n        info.normal = normalize(rayOrigin + t * rayDirection - sphere.xyz);\n        info.distance = t;\n        return true;\n    }\n\n    return false;\n}\n\nvoid traceScene(in vec3 rayOrigin, in vec3 rayDirection, inout HitInfo info){\n    \n    Quad back;\n    back.A = vec3(-2.50f,  5.0f, 10.0f);\n    back.B = vec3( 2.5f,  5.0f, 10.0f);\n    back.C = vec3(-2.5f, -5.0f, 10.0f);\n    back.D = vec3( 2.5f, -5.0f, 10.0f);\n    back.albedo=vec3(0.7f, 0.7f, 0.7f);\n    back.emissive = vec3(0.0f, 0.0f, 0.0f);\n    if (hitQuad(rayOrigin, rayDirection, info, back.A, back.B, back.C, back.D)) {\n        info.albedo = back.albedo;\n        info.emissive = back.emissive;\n    }\n   \n   Quad left;\n   left.A = vec3(-2.5f,  5.0f, 5.0f);\n   left.B = vec3( -2.5f,  5.0f, 10.0f);\n   left.C = vec3(-2.5f, -5.0f, 5.0f);\n   left.D = vec3( -2.5f, -5.0f, 10.0f);\n   left.albedo = vec3(0.7f, 0.7f, 0.7f);\n   left.emissive = vec3(0.25f, 0.0f, 0.0f);\n    if (hitQuad(rayOrigin, rayDirection, info, left.A, left.B, left.C, left.D)) {\n        info.albedo = left.albedo;\n        info.emissive = left.emissive;\n    }\n    \n   Quad right;\n   right.A = vec3(2.5f,  5.0f, 5.0f);\n   right.B = vec3( 2.5f,  5.0f, 10.0f);\n   right.C = vec3(2.5f, -5.0f, 5.0f);\n   right.D = vec3( 2.5f, -5.0f, 10.0f);\n   right.albedo = vec3(0.7f, 0.7f, 0.7f);\n   right.emissive = vec3(0.0f, 0.25f, 0.0f);\n    if (hitQuad(rayOrigin, rayDirection, info, right.C, right.D, right.A, right.B)) {\n        info.albedo = right.albedo;\n        info.emissive = right.emissive;\n    }\n    \n   Quad bottom;\n   bottom.A = vec3(-2.5f,  -5.0f, 5.0f);\n   bottom.B = vec3(-2.5f,  -5.0f, 10.0f);\n   bottom.C = vec3(2.5f, -5.0f, 5.0f);\n   bottom.D = vec3(2.5f, -5.0f, 10.0f);\n   bottom.albedo = vec3(0.9f, 0.9f, 0.9f);\n   bottom.emissive = vec3(0.0f, 0.0f, 0.0f);\n    if (hitQuad(rayOrigin, rayDirection, info, bottom.A, bottom.B, bottom.C, bottom.D)) {\n        info.albedo = bottom.albedo;\n        info.emissive = bottom.emissive;\n    }\n    \n   Quad top;\n   top.A = vec3(-2.5f,  5.0f, 5.0f);\n   top.B = vec3(-2.5f,  5.0f, 10.0f);\n   top.C = vec3(2.5f, 5.0f, 5.0f);\n   top.D = vec3(2.5f, 5.0f, 10.0f);\n   top.albedo = vec3(0.7f, 0.7f, 0.7f);\n   top.emissive = vec3(0.0f, 0.0f, 0.0f);\n    if (hitQuad(rayOrigin, rayDirection, info, top.B, top.A, top.D, top.C)) {\n        info.albedo = top.albedo;\n        info.emissive = top.emissive;\n    }\n    \n   Quad lightSource;\n   lightSource.A = vec3(-1.0f,  5.0f, 6.0f);\n   lightSource.B = vec3(-1.0f,  5.0f, 7.75f);\n   lightSource.C = vec3(1.f, 5.0f, 6.0f);\n   lightSource.D = vec3(1.0f, 5.0f, 7.75f);\n   lightSource.albedo = vec3(0.7f);\n   lightSource.emissive = vec3(1.0f, 1.0f, 1.0f);\n    if (hitQuad(rayOrigin, rayDirection, info, lightSource.B, lightSource.A, lightSource.D, lightSource.C)) {\n        info.albedo = lightSource.albedo;\n        info.emissive = lightSource.emissive*10.0;\n    }\n    \n    Sphere sphere;\n    sphere.center = vec3(0.5f,0.0f,1.0f);\n    sphere.r = 0.25f;\n    sphere.albedo = vec3(0.988, 0.784, 1.0);\n    sphere.emissive = vec3(0.0f,0.0f,0.0f);\n    if(hitSphere(rayOrigin,rayDirection,info,vec4(sphere.center,sphere.r))) {\n        info.albedo=sphere.albedo;\n        info.emissive=sphere.emissive;\n    }\n\n}\n\nvec3 getColorForRay(in vec3 rayOrigin, in vec3 rayDirection,inout uint rng){  \n    vec3 color = vec3(0.0f);\n    vec3 throughput = vec3(1.0f);\n    vec3 rayPos = rayOrigin;\n    vec3 rayDir = rayDirection;\n    for( int i=0;i<NUM_BOUNCES;i++) {\n        HitInfo info;\n        info.distance = maxDistance;\n        traceScene(rayPos,rayDir,info);\n        \n        if(info.distance==maxDistance) {\n            color += texture(iChannel1, rayDir).rgb * throughput;\n            break;\n        }\n        \n        rayPos = (rayPos+rayDir*info.distance) + info.normal * NORMAL_NUDGE; \n        \n        rayDir = normalize(info.normal+RandomUnitVector(rng));\n        \n        color+= info.emissive*throughput;\n        \n        throughput *= info.albedo;\n        \n    }\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rng = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    //ray starting point\n    vec3 rayOrigin = vec3(0.0f,0.0f,0.0f);\n    \n    // coordinate of pixel scaled from [0,1] to [-1,1]\n    vec2 pixel = ((fragCoord/iResolution.xy)*2.0f)-1.0f;\n    \n    //fov\n    float cameraDistance = 1.0f/tan(fov*HALF_PI/180.0f);\n    \n    //ray ending point\n    vec3 rayTarget = vec3(pixel,cameraDistance);\n    \n    //float aspectRatio = iResolution.x/iResolution.y;\n    //rayTarget.y/=aspectRatio;\n    \n    vec3 rayDirection = normalize(rayTarget-rayOrigin);\n    \n    vec3 color = getColorForRay(rayOrigin,rayDirection,rng);\n    vec3 previousFrameColor = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    color = mix(previousFrameColor,color,1.0f/ float(iFrame+1));\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}