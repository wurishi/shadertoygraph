{"ver":"0.1","info":{"id":"DsScWD","date":"1687728384","viewed":50,"name":"june (lonely)","username":"Tygrak","description":"june","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 _cameraStartPos = vec3(0.0, 0.1, -17.0);\nconst int _maxIterations = 1024;\nconst float _maxDistance = 200.0;\nconst float EPS = 0.05;\nconst float GLOWY_MAT = -1.0;\n\n//start taken from template by Giraugh -- https://www.shadertoy.com/view/wlXBW8\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\nvec3 MouseCameraOrigin(vec3 rayOrigin) {\n\tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayOrigin.yz *= Rot(rotY);\n    rayOrigin.xz *= Rot(rotX);\n\treturn rayOrigin;\n}\n\nvec3 MouseCameraDirection(vec3 rayDirection) {\n \tfloat rotX = mix(-3.14, 3.14, 1. - iMouse.x / iResolution.x);\n    float rotY = mix(-3.14/2., 3.14/2., 1. - iMouse.y / iResolution.y);\n    rayDirection.yz *= Rot(rotY);\n    rayDirection.xz *= Rot(rotX);\n    rayDirection = normalize(rayDirection);\n\treturn rayDirection;\n}\n//end taken from template by Giraugh -- https://www.shadertoy.com/view/wlXBW8\n\nstruct RayHit {\n\tvec3 p;\n\tfloat t;\n    int it;\n\tvec4 col;\n};\n\nstruct SDFResult {\n\tfloat d;\n    vec4 col;\n};\n\nconst RayHit MissedRayHit = RayHit(vec3(10000000000.0), 10000000000.0, -1, vec4(0.0));\n\nfloat opSMin(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n\nvec2 opSMinColor(float a, float b, float k) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    if (a < b) {\n        return vec2(a-s, m);\n    } else {\n        return vec2(b-s, 1.0-m);\n    }\n}\n\nvec3 opRep(vec3 p, float interval) {\n    vec2 q = mod(p.xz, interval) - interval * 0.5;\n    return vec3(q.x, p.y, q.y);\n}\n\nfloat dSphere(vec3 p, vec3 center, float radius) {\n    return length(p-center)-radius;\n}\n\nfloat dBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n}\n\nfloat dConeSection(in vec3 p, in float h, in float r1, in float r2) {\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5*(r1-r2)/h;\n    float d2 = max( sqrt( dot(p.xz,p.xz)*(1.0-si*si)) + q*si - r2, q );\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dCylinder(vec3 p, in vec3 c) {\n    p = p+vec3(c.x, 0, c.z);\n    return length(p.xz-c.xy)-c.z;\n}\n\nfloat dEllipsoid(in vec3 p, in vec3 c, in vec3 r) {\n    return (length( (p-c)/r ) - 1.0) * min(min(r.x,r.y),r.z);  \n}\n\nbool isMissedHit(RayHit hit) {\n    return (MissedRayHit.p == hit.p) && (MissedRayHit.t == hit.t);\n}\n\nSDFResult dScene(vec3 p) {\n    p = p+vec3(0.0, 0.0, -5.0);\n    vec4 col = vec4(0.1, 0.1, 0.3, 2.0);\n    float d = 1000000.0;\n    d = p.y+5.0-sin(p.x+iTime)*0.025-sin(p.z*0.7+iTime)*0.025-sin(p.x+p.z*0.4+iTime)*0.0525;\n    float island = dSphere(vec3(p.x, p.y*4.0+25.0, p.z), vec3(0.0, 0.0, 0.0), 10.0)/4.0;\n    if (island < d) {\n        col = vec4(0.95, 0.95, 0.8, 0);\n        if (d < 0.3) {\n            col += clamp(0.0, 1.0, (0.3-d)*(cos(-iTime*2.0-0.8)*0.25+0.5))*vec4(0.95, 0.95, 0.8, 0);\n        }\n        d = island;\n    } else if (island < 0.6) {\n        col += vec4(0.9, 0.9, 0.9, 0.0)*(sin(island*30.0-iTime)*0.5+0.5)*0.5*pow(1.0-island/0.6, 2.0);\n    }\n    vec3 palmP = vec3(p.x+pow(p.y/mix(5.0, 4.8, p.y > 0.0 ? sin(iTime*0.895)*0.5+0.5 : 0.0), 2.0), p.y, p.z);\n    float palm = dConeSection(palmP+vec3(0.0, 2.0, 0.0), 2.0, 1.15, 1.5);\n    palm = min(palm, dConeSection(palmP+vec3(0.0, 0.0, 0.0), 2.0, 0.95, 1.475));\n    palm = min(palm, dConeSection(palmP+vec3(0.0, -2.0, 0.0), 2.0, 0.925, 1.465));\n    palm = min(palm, dConeSection(palmP+vec3(0.0, -4.0, 0.0), 2.0, 0.9, 1.442));\n    palm = min(palm, dConeSection(palmP+vec3(0.0, -6.0, 0.0), 2.0, 0.85, 1.215));\n    vec2 palmD = opSMinColor(d, palm, 0.5);\n    d = palmD.x;\n    col = mix(col, vec4(0.35, 0.35, 0.02, 0.0), palmD.y);\n    vec3 palmLeavesP = vec3(p.x+pow(p.y/5.0, 2.0), p.y+pow(p.x/5.0+p.z/5.0, 2.0), p.z);\n    float palmLeaves = dEllipsoid(palmLeavesP, vec3(4.5, 8.75, 0.0+sin(iTime*0.9)*(p.x+p.z)*0.05), vec3(5.0, 0.4, 1.0));\n    palmLeaves = opSMin(palmLeaves, dEllipsoid(palmLeavesP, vec3(-6.5, 8.825, 0.0+sin(iTime*0.9)*(p.x+p.z)*0.05), vec3(4.0, 0.5, 0.6)), 0.5);\n    palmLeaves = opSMin(palmLeaves, dEllipsoid(vec3(-palmLeavesP.z, palmLeavesP.y, palmLeavesP.x), vec3(-5.5, 8.775, 0.0-sin(iTime*0.87)*(p.x+p.z)*0.05), vec3(5.0, 0.67, 1.26)), 0.5);\n    palmLeaves = opSMin(palmLeaves, dEllipsoid(vec3(palmLeavesP.z, palmLeavesP.y, palmLeavesP.x), vec3(-5.5, 8.75, 0.0+sin(iTime*0.869)*(p.x+p.z)*0.05), vec3(5.0, 0.67, 1.26)), 0.5);\n    palmLeaves *= 0.5;\n    if (palmLeaves < d) {\n        d = palmLeaves;\n        col = vec4(0.5, 0.99, 0.3, 0.0);\n    }\n    return SDFResult(d, col);\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        dScene(p + vec3(EPS, 0.0, 0.0)).d - dScene(p + vec3(-EPS, 0.0, 0.0)).d,\n        dScene(p + vec3(0.0, EPS, 0.0)).d - dScene(p + vec3(0.0, -EPS, 0.0)).d,\n        dScene(p + vec3(0.0, 0.0, EPS)).d - dScene(p + vec3(0.0, 0.0, -EPS)).d\n    ));\n}\n\nRayHit rayMarch(vec3 from, vec3 direction, float maxt) {\n\tRayHit result = MissedRayHit;\n\tfloat t = 0.0;\n\tfor (int iteration = 0; iteration < _maxIterations; iteration++) {\n        result.it = iteration;\n\t\tif (t > maxt) {\n\t\t\treturn result;\n\t\t}\n\t    vec3 point = from+t*direction;\n        SDFResult res = dScene(point);\n        float d = res.d;\n\t\tif (d < 0.01+0.1*(float(iteration)/float(_maxIterations))) {\n            result.col = res.col;\n\t\t\tresult.p = point;\n\t\t\tresult.t = t;\n\t\t\treturn result;\n\t\t}\n\t\tt = t+d;\n\t}\n\treturn result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    vec3 rayOrigin = MouseCameraOrigin(_cameraStartPos);\n    vec3 rayDirection = normalize(MouseCameraDirection(vec3(uv.x, uv.y, 1)));\n    \n    vec3 col = vec3(0.0);\n    float iterationsAcc = 0.0;\n    float distanceAcc = 0.0;\n    for (int i = 0; i < 5; i++) {\n        RayHit result = rayMarch(rayOrigin, rayDirection, _maxDistance-distanceAcc);\n        iterationsAcc += float(result.it);\n        distanceAcc += result.t;\n        \n        if (isMissedHit(result)) {\n            col += mix(vec3(0.83, 0.82, 0.98), vec3(0.65, 0.68, 0.98), 0.5+0.5*rayDirection.y);\n            break;\n        } else {\n            col += result.col.xyz*(1.0-float(i)/5.0);\n            vec3 n = getNormal(result.p);\n            if (result.col.a < 1.0) {\n                if (result.col.a == GLOWY_MAT) {\n                    float fresnel = 1.0-clamp(pow(dot(normalize(n), -rayDirection), 0.5), 0.0, 1.0);\n                    col += col*fresnel;\n                }\n                break;\n            } else {\n                rayDirection = normalize(reflect(rayDirection, n));\n                rayOrigin = result.p+rayDirection*0.1;\n            }\n        }\n    }\n    \n    //AA?\n    //col += 1. * vec3(pow(smoothstep(0.0, float(_maxIterations), float(iterationsAcc)), 1.2));\n    \n    //iterations glow\n    //col -= vec3(iterationsAcc/100.0);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}