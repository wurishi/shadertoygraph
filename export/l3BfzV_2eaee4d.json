{"ver":"0.1","info":{"id":"l3BfzV","date":"1729692625","viewed":30,"name":"wave simulator 0.7","username":"Psyph","description":"Like a ripple on water. each pixel can have a \"height\" value, red is the top of the wave and blue the bottom. RGB channels in Buffer B allow for allow for adding things like, reflectors, refractors, walls, and damping. (lensing and diffraction work too)","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col2=texture(iChannel0,uv).xyz;\n    vec2 b=texture(iChannel1,uv).xy;\n    col2.yz=vec2(0.,0.);\n    col2.z=-col2.x;\n\n    fragColor = vec4(4.*col2*(1./b.x),1.0);\n\n    //vec3 col=texture(iChannel1,uv).xyz;\n    //fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//red stores position and blue stores velocity.\n#define fr fragCoord\nvec2 rand12(vec2 ij,float a,float s)\n{\n    \n    return 2.*a*vec2(mod(ij.x+s*sin(ij.x+1.),1.),mod(ij.x+s*sin(ij.x+1.+ij.y),1.))-a;\n}\nvec3 calcn(ivec2 p, float s)\n{\n    vec3 p1=texelFetch(iChannel0,p,0).xyz;\n    float f=0.;\n    int ney=6;\n    int i=-ney;\n    while(i<=ney)\n    {\n        int j=-ney;\n        while(j<=ney)\n        {\n            if(i==0&&j==0) j++;\n            vec2 p2=texelFetch(iChannel0,p+ivec2(i,j),0).xz;\n            f+=(p1.x-p2.x)/length(vec2(i,j));\n            j++;\n        }\n        i++;\n    }\n    p1.z-=s*f/10.;\n    p1.x+=p1.z;\n    return p1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col=texelFetch(iChannel0,ivec2(fr),0).xyz;\n    if(iFrame<10)\n    {\n        col=vec3(0.);\n    }\n    else\n    {\n        vec3 b=texelFetch(iChannel1,ivec2(fr),0).xyz;\n        col=calcn(ivec2(fr),b.y);\n        float g=iResolution.x/6.;\n        float h=iResolution.y/2.;\n        if(length(fr-vec2(g,h))<5.) //+rand12(vec2(i,10.),20.,20.)\n        {\n            col=vec3(0.);\n            float hfreq=72.;\n            float bfreq=1.;\n            col.x=sin(iTime*bfreq*hfreq)/2.;\n        }\n        /*\n        float i=0.;\n        while(i<1.)\n        {\n            if(length(fr-vec2(g,h))<5.) //+rand12(vec2(i,10.),20.,20.)\n            {\n                col=vec3(0.);\n                float hfreq=60.+2.*i;\n                float bfreq=1.;\n                col.x=sin(iTime*bfreq*hfreq)/2.;\n            }\n            i++;\n        }\n        */\n        \n        \n        col*=b.z;\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nred; only effects the visual output on the screen. multiplies by the inverse of amount.\n.2 = wave appears 5 times as bright\n\ngreen; is the physics strength constant for the interactivity between pixels\n.5 gets /10 in calc so force gets scaled by .05. this is default.\nlower values makes the wave propagate slower.\nthis can cause refraction and lensing\n\nblue; amount gets multiplied by the wave in calculation, causing damping. \n1 means wave uninhibited, 0 means pixel does not react to wave.\nthis causing damping at intermediate values, but reflections at 0.\n*/\n\n#define fr fragCoord\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //init all to default brightness, default speed, no damping.\n    vec3 col=vec3(1.,0.5,1.);\n    \n    //top and bottom dampers, min and max damping\n    float mi = .75;\n    float ma = 1.;\n    if(fr.y<20.)\n    {\n        col.z=mix(mi,ma,fr.y/20.);\n    }\n    if(fr.y>iResolution.y-20.)\n    {\n        col.z=mix(mi,ma,(iResolution.y-fr.y)/20.);\n    }\n    \n    float g=3.*iResolution.x/5.;\n    \n    /*\n    //slit wall\n    \n    if(fr.x>g&&fr.x<g+10.)\n    {\n        col.z=.38;\n    }\n    */\n    \n    \n    /*\n    //create multiple slits, prob doesnt work for now...\n    float ph=100.;\n    //float ph=iResolution.y/4.;\n    float n=2.;\n    float m=mod(fr.y-ph,iResolution.y/n);\n    float s=20./2.;\n    \n    if(m<s&&m>-s)\n    {\n        col.z=1.;\n    }\n    */\n    \n    \n    /*\n    //slits\n    float m=iResolution.y/2.;\n    float s=60.;\n    float w=20.;\n    if(fr.y>m-s-w/2.&&fr.y<m-s+w/2.)\n    {\n        col.z=1.;\n    }\n    if(fr.y>m+s-w/2.&&fr.y<m+s+w/2.)\n    {\n        col.z=1.;\n    }\n    */\n    \n    \n    \n    //lens 1\n    vec2 fr2=vec2(fr.x,fr.y/4.);\n    if(length(fr2-vec2(g,iResolution.y/8.))<30.)\n    {\n        col.y=.33;\n    }\n    \n    /*\n    //lens 2\n    float frx=fr.x-fr.y;\n    if(frx>g-200.&&frx<g)\n    {\n        col.y=.30;\n    }\n    */\n    \n    //emitter reflector cage\n    vec2 mu=fr-vec2(iResolution.x/6.,iResolution.y/2.);\n    if(length(mu)<80.)\n    {\n        col.z=0.;\n    }\n    //and outlet\n    if(.1*mu.y*mu.y<mu.x+45.)\n    {\n        col.z=1.;\n    }\n    \n    //side dampers\n    if(fr.x<20.)\n    {\n        col.z=mix(mi,ma,fr.x/20.);\n        //col.z=0.;\n    }\n    if(fr.x>iResolution.x-20.)\n    {\n        col.z=mix(mi,ma,(iResolution.x-fr.x)/20.);\n        //col.z=0.;\n    }\n    \n    /*\n    //brightness multiplier for waves past slit wall\n    if(fr.x>g)\n    {\n         col.x=.1;\n    }\n    */\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}