{"ver":"0.1","info":{"id":"MtcSD7","date":"1479955072","viewed":347,"name":"Bicubic gradiant noise","username":"stduhpf","description":"2D gradiant Perlin noise but instead of using a billinear or a bicosine interpolation, it uses a bicubic interpolation, which is useless in most cases, because the smoothstep (bicosine) interpolation is already smooth and faster.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlin","bicubic","tuto"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define BILINEAR //for comparaison\n//#define SMOOTH //bilinear using smoouthstep(looks the same as cosine interpolation)\nfloat seed = 0.;\nvec2 grad(vec2 p){\n        p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)));\n    return fract(seed+sin(p+seed)*43758.5453)-.5;\n        }\n#ifdef BILINEAR  //looks bad, exept with fbm\n//if you want to understand the bicubic version, study this before\nfloat perlin(vec2 uv)\n{\n    //splitting the plane into 1*1 cases\n    vec2 relco = fract(uv);\n    vec2 inco = floor(uv);\n\t\n    //get a 2D gradiant at each vertex of the current case\n    vec2 grad1 = grad(inco);\n    vec2 grad2 = grad(inco+vec2(1,0));\n    vec2 grad3 = grad(inco+vec2(1,1));\n    vec2 grad4 = grad(inco+vec2(0,1));\n    \n    //calculate how much each gradient is pointing towards the position of the pixel in the case\n    float s = dot(grad1,relco);\n    float t = dot(grad2, relco-vec2(1,0));\n    float u = dot(grad3, relco-1.);\n    float v = dot(grad4, relco-vec2(0,1));\n    \n     //linear interpolation on the x axis\n    float n1 = mix(s,t,relco.x);\n    float n2 = mix(v,u,relco.x);\n    \n\t//final interpolation on the y axis\n    return mix(n1,n2,relco.y);\n}\n\n#else\n#ifdef SMOOTH\nfloat perlin(vec2 uv)\n{\n    vec2 relco = fract(uv);\n    vec2 inco = floor(uv);\n    \n    vec2 grad1 = grad(inco);\n    vec2 grad2 = grad(inco+vec2(1,0));\n    vec2 grad3 = grad(inco+vec2(1,1));\n    vec2 grad4 = grad(inco+vec2(0,1));\n    \n    float s = dot(grad1,relco);\n    float t = dot(grad2, relco-vec2(1,0));\n    float u = dot(grad3, relco-1.);\n    float v = dot(grad4, relco-vec2(0,1));\n    \n    float n1 = mix(s,t,smoothstep(0.,1.,relco.x));\n    float n2 = mix(v,u,smoothstep(0.,1.,relco.x));\n\n    return mix(n1,n2,smoothstep(0.,1.,relco.y));\n}\n\n#else\nfloat cubic(float x,float a,float da,float b, float db)\n{\n    vec4 abcd = vec4(2.*a-2.*b+da+db,-3.*a+3.*b-2.*da-db,da,a);//get a 3degree polynom formula\n    //we have f(0),f(1),f'(0),f'(1)\n    //            (  a   ,   b,   da ,  db )\n    //and we use this value to get a formula like y=a*x^3+b*xÂ²+c*x+d \n    return x*x*x*abcd.x+x*x*abcd.y+x*abcd.z+abcd.w;\n}\n\nfloat perlin(vec2 uv)\n{\n    //we split the plane in cases\n    vec2 relco = fract(uv);\n    vec2 inco = floor(uv);\n //we set up a grid 4*4 of 2D gradiants., centered in the current case\n    vec2 grad1 = grad(inco+vec2(-1));\n    vec2 grad2 = grad(inco+vec2(0,-1));\n    vec2 grad3 = grad(inco+vec2(1,-1));\n    vec2 grad4 = grad(inco+vec2(2,-1));\n    vec2 grad5 = grad(inco+vec2(-1,0));\n    \n    vec2 grad6 = grad(inco+vec2(0)); //corner 1\n    vec2 grad7 = grad(inco+vec2(1,0));//corner 2\n    \n    vec2 grad8 = grad(inco+vec2(2,0));\n    vec2 grad9 = grad(inco+vec2(-1,1));\n    \n    vec2 gradA = grad(inco+vec2(0,1));//corner 3\n    vec2 gradB = grad(inco+vec2(1));//corner 4\n    \n    vec2 gradC = grad(inco+vec2(2,1));\n    vec2 gradD = grad(inco+vec2(-1,2));\n    vec2 gradE = grad(inco+vec2(0,2));\n    vec2 gradF = grad(inco+vec2(1,2));\n    vec2 gradG = grad(inco+vec2(2));\n    //the other gradiants are used for the derivatives\n    \n    //computes the effect of the corner gradients, in the x direction (how much the gradiant is pointing toward the current position)\n    float s = dot(grad6,relco);\n    float t = dot(grad7, relco-vec2(1,0));\n    \n     //compute the derivative of this effect, using the neigbours of the vertex of the case on the x axis\n    float ds= (t-dot(grad5,relco-vec2(-1,0)))*.5;\n    float dt= (dot(grad8,relco-vec2(2,0))-s)*.5;\n    \n    float u = dot(gradA, relco-vec2(0,1));\n    float v = dot(gradB, relco-1.);\n    \n    float du= (v-dot(grad9,relco-vec2(-1,1)))*.5;\n    float dv= (dot(gradC,relco-vec2(2,1))-u)*.5;\n     //cubic interpolation on x axis\n    float n1 = cubic(relco.x,s,ds,t,dt);\n    float n2 =cubic(relco.x,u,du,v,dv);\n    \n    \n    //preparing the derivative on the y axis\n    float ms = dot(grad2,relco-vec2(0,-1));\n    float mt = dot(grad3, relco-vec2(1,-1));\n    \n    float dms= (mt-dot(grad1,relco-vec2(-1)))*.5;\n    float dmt= (dot(grad4,relco-vec2(2,-1))-ms)*.5;\n    \n    float mu = dot(gradE, relco-vec2(0,2));\n    float mv = dot(gradF, relco-vec2(1.,2));\n    \n    float dmu= (mv-dot(gradD,relco-vec2(-1,2)))*.5;\n    float dmv= (dot(gradG,relco-vec2(2,2))-mu)*.5;\n    \n    //derivative on the y axis:\n    float dn1 = (n2-cubic(relco.x,ms,dms,mt,dmt))*.5;\n    float dn2 =(cubic(relco.x,mu,dmu,mv,dmv)-n1)/2.;\n    \n\t//final interpolation\n    return cubic(relco.y,n1,dn1,n2,dn2);\n}\n#endif\n#endif\nfloat fbm(vec2 uv)\n{\n    float n =1.;\n    float r =1.;\n    for (int i =0;i<8;i++)\n    {\n        uv+=100.;\n        n=mix(n,perlin(uv),r);\n        r*=.25;\n        uv*=2.05;\n    }\n    return n;\n}\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = tan(floor(iDate.w-iTime));\n\tvec2 uv =(2.*fragCoord.xy - iResolution.xy)/iResolution.x;\n    uv*=5.;\n\tfragColor = 1.-abs(vec4(sin(5.*uv.y+15.*perlin(uv)))); //replace perlin with fbm to see with multiple octaves\n}","name":"Image","description":"","type":"image"}]}