{"ver":"0.1","info":{"id":"tlScWy","date":"1595245607","viewed":116,"name":"Slicing 3D Voronoi","username":"bekorn","description":"The pattern is sampled with vec3(uv, time). So the image is a slice of the 3D voronoi pattern. This eliminates the predictability (if the grid method is used) of the 2D voronoi. ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\t3D Voronoi with Raymarching:\n//\thttps://www.shadertoy.com/view/wljcDW\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy / 2.) / iResolution.y;\n    vec2 normalized_mouse = iMouse.xy / iResolution.xy - 0.5;\n\n    vec3 voronoi_scale = vec3(cos(10. / 6.) * 5. + 9.);\n\n    vec3 uvz = vec3(uv, iTime / 4. / voronoi_scale.z);\n\n    vec3 voronoi_color;\n    float dist;\n\n    if (mod(uvz.y, 1.) < 0.5)\t// Top\n    {\n        if (mod(uvz.x, 2.) < 1.)\t// Right\n        {\n            dist = VoronoiEdgeDist(uvz * voronoi_scale, voronoi_color);\n\n            if (mod(uvz.x, 1.) > 0.5)\n                dist = float(dist < 0.1);\n        }\n        else\t// Left\n        {\n            dist = VoronoiDist(uvz * voronoi_scale, voronoi_color);\n\n            if (mod(uvz.x, 1.) < 0.5)\n                dist = float(dist < 0.5);\n        }\n    }\n    else\t// Bottom\n    {\n        vec2 iq_dist = VoronoiIqDist(uvz * voronoi_scale, voronoi_color);\n\n        if (mod(uvz.x, 2.) < 1.)\t// Right\n        {\n            dist = iq_dist.y - iq_dist.x;\n\n            if (mod(uvz.x, 1.) > 0.5)\n                dist = float(dist < 0.1);\n        }\n        else\t//\tLeft\n        {\n            dist = iq_dist.x;\n\n            if (mod(uvz.x, 1.) < 0.5)\n                dist = float(dist < 0.5);\n        }\n    }\n\n    fragColor = vec4(mix(voronoi_color, vec3(1), float(iMouse.z > 0.)) * dist, 1);\n\n    #define DEBUG_\n    #ifdef DEBUG\n    if (dist < 0.1)\n    {\n        fragColor = vec4(1, 0, 0, 1);\n    }\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define VERY_LARGE_FLOAT 10000000000.\n\nvec3 R33(vec3 p)\n{\n    vec4 a = fract(p.xzyx * vec4(123.34, 234.34, 345.65, 987.54));\n    a += dot(a, a + 34.45);\n    return fract(vec3(a.x * a.w, a.y * a.z, a.z * a.w));\n}\n\n// https://youtu.be/l-07BXzNdPw, Voronoi Explained! - The Art of Code\nfloat VoronoiDist(vec3 p, out vec3 color)\n{\n    float min_dist = VERY_LARGE_FLOAT;\n\n    vec3 local_p = fract(p); // range [0., +1.]\n\n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++)\n            for(int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n\n                vec3 point_to_center = center - p;\n                float dist = dot(point_to_center, point_to_center);\n\n                if (dist < min_dist)\n                {\n                    min_dist = dist;\n                    color = R33(id);\n                }\n            }\n\n    return sqrt(min_dist);\n}\n\n// https://github.com/blender/blender/blob/2d1cce8331f3ecdfb8cb0c651e111ffac5dc7153/intern/cycles/kernel/shaders/node_voronoi_texture.osl\nfloat VoronoiEdgeDist(vec3 p, out vec3 color)\n{\n    vec3 local_p = fract(p); // range [0., +1.]\n\n    vec3 vector_to_closest;\n    float min_dist = VERY_LARGE_FLOAT;\n\n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n\n                vec3 point_to_center = center - p;\n                float dist = dot(point_to_center, point_to_center);\n\n                if (dist < min_dist)\n                {\n                    min_dist = dist;\n                    color = R33(id);\n                    vector_to_closest = point_to_center;\n                }\n            }\n\n\n    min_dist = VERY_LARGE_FLOAT;\n\n    for (int x = -1; x <= 1; x++)\n        for (int y = -1; y <= 1; y++)\n            for (int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n\n                vec3 point_to_center = center - p;\n\n                vec3 perpendicularToEdge = point_to_center - vector_to_closest;\n\n                if (perpendicularToEdge == vector_to_closest)\n                    continue;\n\n                float distanceToEdge = dot(\n                    (vector_to_closest + point_to_center) / 2.0,\n                    normalize(perpendicularToEdge)\n                );\n\n                min_dist = min(min_dist, distanceToEdge);\n            }\n\n    return min_dist;\n}\n\n// https://www.shadertoy.com/view/MsXGzM\n// This returns the 2 smallest distances to centers,\n// the difference between them is an approximation of distance to edge\nvec2 VoronoiIqDist(vec3 p, out vec3 color)\n{\n    vec3 local_p = fract(p);\n\n    vec2 min_dists = vec2(VERY_LARGE_FLOAT);\n\n    for(int x = -1; x <= 1; x++)\n        for(int y = -1; y <= 1; y++)\n            for(int z = -1; z <= 1; z++)\n            {\n                vec3 offset = vec3(x, y, z);\n                vec3 id = floor(offset + p);\n\n                vec3 local_center = R33(id);\n                vec3 center = id + local_center;\n\n                vec3 point_to_center = center - p;\n                float dist = dot(point_to_center, point_to_center);\n\n                if(dist < min_dists.x)\n                {\n                    color = local_center;\n                    min_dists = vec2(dist, min_dists.x);\n                }\n                else if(dist < min_dists.y)\n                {\n                    min_dists.y = dist;\n                }\n            }\n\n    return sqrt(min_dists);\n}\n","name":"Common","description":"","type":"common"}]}