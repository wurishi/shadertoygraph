{"ver":"0.1","info":{"id":"DdBXR3","date":"1670596070","viewed":125,"name":"aliensito","username":"irnclemente","description":"cute alien I did for a school project","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sdf","alien"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pi = atan(-1.0);\n\nvec3 LLUM_AMB = vec3(0.4,0.4,0.4);\nvec3 LLUM_FOC = vec3(1.0,1.0,1.0);\nvec3 POS_FOC  = normalize(vec3(0.0,0.4,0.5));\nvec3 POS_FOC2 = normalize(vec3(-0.5,0.0,-0.5));\n\nfloat change(float time) {\n    float timeChange = clamp(iTime-time,0.0,1.0);\n    return smoothstep(0.0,1.0,timeChange);\n}\n\n\n////////////////////////////////////////////////////////\nfloat dist_sphere(vec3 p, float radi)\n{\n    return length(p)-radi;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 min_vec2_x(vec2 d1, vec2 d2) {\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n///////////////////////////////////////////////////////////////////////\n\nvec2 map(in vec3 pos)\n{   \n    \n    float angle_wawa = sin(2.0*pi*iTime)*(pos.y-0.5)*0.17*change(15.0);\n    mat3 rotate_wawa = mat3( vec3( cos(angle_wawa),-sin(angle_wawa),0.0),\n                             vec3( sin(angle_wawa),cos(angle_wawa),0.0),\n                             vec3( 0.0,0.0,1.0));\n    \n    vec3 p = (pos+vec3(-1.5,-1.5,0.0))*rotate_wawa;\n    \n    //BODY\n    float dist_body = dist_sphere(p+vec3(0.0,0.4,0.0),0.8*change(2.0));\n    float dist_head = dist_sphere(p+vec3(0.0,-0.4,0.0),0.6*change(3.0));\n    \n    float dist_alien = opSmoothUnion(dist_body,dist_head,0.2*change(4.0));\n    \n    //EYES: NO SYMETRY\n    vec3 p_eyes = p;\n    //p_eyes.x = abs(p_eyes.x);\n    p_eyes -= vec3(0.25,0.0,0.0);\n    p_eyes*=rotate_wawa;\n    \n    float dist_eyestalk = sdVerticalCapsule(p_eyes+vec3(0.25,-1.0,0.0),0.2*change(5.0),0.2*change(5.0));\n    float dist_alien1 = opSmoothUnion(dist_alien,dist_eyestalk,0.1*change(6.0));\n    \n    float angle = pi*2.0*change(8.0);\n    mat3 rotate = mat3( vec3( 1.0,0.0,0.0),\n                        vec3( 0.0,cos(angle),-sin(angle)),\n                        vec3( 0.0,sin(angle),cos(angle)));\n    float dist_eyelids = sdTorus((p_eyes+vec3(0.25,-1.3,-0.1))*rotate,vec2(change(7.0)*0.2,change(7.0)*0.1));\n    dist_alien1 = opSmoothUnion(dist_alien1,dist_eyelids,0.1*change(9.0));\n    float dist_eyes1 = dist_sphere(p_eyes+vec3(0.25,-1.3,-0.1),change(10.0)*0.23);\n    dist_alien1 = opSubtraction(dist_eyes1,dist_alien1);\n\n    \n    //EYES: SYMETRY\n    p_eyes = p;\n    p_eyes.x = abs(p_eyes.x);\n    p_eyes -= vec3(0.5,0.0,0.0);\n    \n    \n    dist_eyestalk = sdVerticalCapsule(p_eyes+vec3(0.25,-1.0,0.0),0.2,0.2);\n    float dist_alien2 = opSmoothUnion(dist_alien,dist_eyestalk,0.1);\n    dist_eyelids = sdTorus((p_eyes+vec3(0.2,-1.3,-0.1))*rotate,vec2(0.2,0.1));\n    dist_alien2 = opSmoothUnion(dist_alien2,dist_eyelids,0.1);\n    float dist_eyes2 = dist_sphere(p_eyes+vec3(0.2,-1.3,-0.1),0.23);\n    dist_alien2 = opSubtraction(dist_eyes2,dist_alien2);\n    \n    //EYES: TRANSITION\n    dist_alien = mix(dist_alien1,dist_alien2,change(11.0));\n    float dist_eyes = mix(dist_eyes1,dist_eyes2,change(11.0));\n    \n    //MOUTH\n    float dist_mouth = dist_sphere(p+vec3(0.0,-0.5,-0.5),0.2*change(12.0));\n    dist_mouth = opSubtraction(sdBox(p+vec3(0.0,-0.60,-0.5),vec3(10.0,change(13.0)*0.2,10.0)),dist_mouth);\n    dist_alien = opSmoothSubtraction(dist_mouth, dist_alien, change(14.0)*0.1);\n    \n    vec2 ret_alien = vec2(dist_alien, 1.0);\n    vec2 ret_eyes  = vec2(dist_eyes,2.0);\n    vec2 ret_mouth = vec2(dist_mouth,3.0);\n    \n    vec2 ret = ret_alien;\n    ret = min_vec2_x(ret, ret_eyes);\n    ret = min_vec2_x(ret, ret_mouth);\n    \n    return ret;\n}\n\nvec2 llencar_raig(in vec3 raig_origen, in vec3 raig_direccio)\n{\n    vec2 dist_origen = vec2(0.0,-1.0);\n\n    for(int i = 0; i < 100; ++i) \n    {    \n        vec3 pos = raig_origen + raig_direccio*dist_origen.s;\n        \n        vec2 dist_escena = map(pos);\n\n        if( dist_escena.s < 0.001 ) break;\n        dist_origen.s += dist_escena.s;\n        dist_origen.t  = dist_escena.t;\n        if( dist_escena.s > 50.0 ) break;\n    }\n\n    if( dist_origen.s > 20.0 ) dist_origen = vec2(-1.0);\n\n    return dist_origen;\n}\n\nvec3 calc_normal(vec3 pos)\n{ \n    float d0 = map(pos).s;\n    vec2 epsilon = vec2(0.0001,0.0);\n    vec3 d1 = vec3(\n        map(pos - epsilon.xyy).s,\n        map(pos - epsilon.yxy).s,\n        map(pos - epsilon.yyx).s);\n    return normalize(d0 - d1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n\n    float resmax = max(iResolution.x, iResolution.y);\n    vec2 st = fragCoord.xy/resmax;\n    vec3 color = vec3(0.6,0.9,0.8);\n\n    // Camera\n    vec3 raig_origen    = vec3(0.,0.,6.);\n    vec3 raig_direccio  = normalize(vec3(st.x, st.y, -1.));\n\n    // Ray-Marching\n    vec2 raigmarxar = llencar_raig(raig_origen, raig_direccio);\n    float dist_sprf = raigmarxar.s;\n    float idx_obj   = raigmarxar.t;\n\n    // Iluminacio\n    if (dist_sprf > 0.0) {\n    \n     vec3  dif = vec3(0.0);\n     vec3  spc = vec3(1.0);\n     float shn = 0.0;\n     \n     if (idx_obj < 1.5) {\n         dif = vec3(0.9,0.6,0.2);\n         spc = vec3(1.0,1.0,1.0);\n         shn = 0.0;\n     }\n     else if (idx_obj < 2.5) {\n         dif = vec3(0.0);\n         spc = vec3(1.0,1.0,1.0);\n         shn = 3.0;\n     }\n     else if (idx_obj < 3.5) {\n         dif = vec3(0.0,0.2,0.0);\n         spc = vec3(1.0,1.0,1.0);\n         shn = 0.0;\n     }\n     \n     vec3 punt_sprf = raig_origen + raig_direccio * dist_sprf;\n     vec3 normal_sprf = calc_normal(punt_sprf);\n     \n     color = LLUM_AMB*dif;\n     color += LLUM_FOC*dif*clamp( dot( normal_sprf, POS_FOC ), 0., 1.);\n     \n     vec3 R = -reflect(POS_FOC, normal_sprf);\n     vec3 V = -raig_direccio;\n     \n     if (shn > 0.0)\n        color += LLUM_FOC*spc*\n                 pow( clamp( dot( R,V ),0.0,1.0 ),shn );\n        \n    }\n\n    fragColor = vec4(color, 1);\n}\n\n","name":"Image","description":"","type":"image"}]}