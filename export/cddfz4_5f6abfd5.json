{"ver":"0.1","info":{"id":"cddfz4","date":"1697128921","viewed":36,"name":"Interactable custom fractal","username":"carlosroxo1","description":"Use the mouse to drag the fractal around or move with WASD\nZoom in n out using the keyboard keys or 'E' and 'Q'\nAlternate between fractals using number keys from 0 to 9\nSpacebar resets the zoom","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","mouse","mandelbrot","complex","keyboard","interactable"],"hasliked":0,"parentid":"DsyyRh","parentname":"Interactable Mandelbrot set"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Sourced the loadValue and storeValue functions from the Pac-Man game: https://www.shadertoy.com/view/Ms3XWN\n// Full credit to the original creator for these functions.\n//\n// The rest of the code was patched up by me, feel free to use any part of it as needed.\n// If you think a part of the code is inefficient, ugly or some other nuisance, I welcome feedback.\n// Enjoy!\n\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the coordinates for the current pixel\n    vec2 resolution = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y);\n    \n    \n    // Load saved values\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec2 offset      = loadValue( txOffset ).xy;\n    vec2 mouseLast   = loadValue( txMouseLast ).xy;\n    float zoom       = loadValue( txZoom ).x;\n    float state      = loadValue( txState ).x;\n    \n    \n    // Map pixel coordinates to the Mandelbrot set's complex plane\n    int MAX_ITER = 1024;\n    Complex c;\n    c.real = p.x/zoom - offset.x;\n    c.imag = p.y/zoom - offset.y;\n\n\n    // Check if the current complex number is inside the Mandelbrot set\n    int count = isInsideFractal(c, MAX_ITER, state);\n\n\n    // Map the number of iterations to a color gradient with a log scale\n    vec3 color;\n    if (count == MAX_ITER) {\n        color = vec3(0.0); // Inside the set (black)\n    } else {\n        // Apply a logarithm to the count for a log scale\n        float logCount = log(float(count) + 1.0) / log(float(MAX_ITER) + 1.0);\n        //color = vec3(logCount, logCount * logCount, 1.0 - logCount); // Color gradient (change this for different colors)\n        //color = vec3(logCount * logCount, 1.0 - logCount, logCount); // Color gradient (change this for different colors)\n        color = vec3(1.0 - logCount, logCount, logCount * logCount); // Color gradient (change this for different colors)\n    }\n\n\n    // Output the color\n    fragColor = vec4(color, 1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const ivec2 txOffset    = ivec2(31, 1);\nconst ivec2 txMouseLast = ivec2(31, 3);\nconst ivec2 txZoom      = ivec2(31, 5);\nconst ivec2 txState     = ivec2(31, 7);\n\n\nstruct Complex {\n    float real;\n    float imag;\n};\n\n\nComplex addC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real + b.real;\n    result.imag = a.imag + b.imag;\n    return result;\n}\n\nComplex subC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real - b.real;\n    result.imag = a.imag - b.imag;\n    return result;\n}\n\nComplex multC(Complex a, Complex b) {\n    Complex result;\n    result.real = a.real * b.real - a.imag * b.imag;\n    result.imag = a.real * b.imag + a.imag * b.real;\n    return result;\n}\nComplex multC(Complex a, Complex b, Complex c) {\n    Complex result;\n    result = multC(a, b);\n    result = multC(result, c);\n    return result;\n}\nComplex multC(float a, Complex b) {\n    Complex result;\n    result.real = a * b.real;\n    result.imag = a * b.imag;\n    return result;\n}\n\nComplex divideC(Complex a, Complex b) {\n    Complex result;\n    float denominator = b.real * b.real + b.imag * b.imag;\n    result.real = (a.real * b.real + a.imag * b.imag) / denominator;\n    result.imag = (a.imag * b.real - a.real * b.imag) / denominator;\n    return result;\n}\n\nfloat absC(Complex c) {\n    return length(vec2(c.real, c.imag));\n}\n\nComplex expC(Complex c) {\n    Complex result;\n    result.real = exp(c.real) * cos(c.imag);\n    result.imag = exp(c.real) * sin(c.imag);\n    return result;\n}\n\nComplex sinC(Complex c) {\n    Complex result;\n    result.real = sin(c.real) * cosh(c.imag);\n    result.imag = cos(c.real) * sinh(c.imag);\n    return result;\n}\n\nComplex cosC(Complex c) {\n    Complex result;\n    result.real = cos(c.real) * cosh(c.imag);\n    result.imag = -sin(c.real) * sinh(c.imag);\n    return result;\n}\n\nComplex powC(Complex c, float s) {\n    Complex result;\n    float r = absC(c);\n    float theta = atan(c.imag, c.real);\n    float newR = pow(r, s);\n    float newTheta = s * theta;\n    result.real = newR * cos(newTheta);\n    result.imag = newR * sin(newTheta);\n    return result;\n}\n\nComplex fractC(Complex c) {\n    Complex result;\n    result.real = fract(c.real);\n    result.imag = fract(c.imag);\n    return result;\n}\n\n\nint isInsideFractal(Complex c, int MAX_ITER, float state) {\n    Complex z = c;\n    for (int i = 0; i < MAX_ITER; i++) {\n        if (state == 0.0){\n            z = addC(multC(z,z), c); // Mandelbrot iteration formula\n        }\n        else if (state == 1.0){\n            z = addC(addC(multC(0.816,powC(expC(z), 0.557)), multC(-0.724,powC(expC(z),2.779))), c);\n        }\n        else if (state == 2.0){\n            z = addC(addC(addC(multC(1.77,z), multC(-0.85,multC(z,z))), multC(-0.84,multC(z,z,z))), c);\n        }\n        else if (state == 3.0){\n            z = addC(addC(addC(multC(0.78,z), multC(0.70,multC(z,z))), multC(-0.06,multC(z,z,z))), c);\n        }\n        else if (state == 4.0){\n            z = addC(addC(addC(addC(addC(addC(addC(multC(-1.10,z), multC(-1.42,multC(z,z))), multC(0.07,multC(z,z,z))), multC(-0.47,multC(multC(z,z,z),z))), multC(-1.12,multC(multC(z,z,z),z,z))), multC(-0.14,multC(multC(multC(z,z,z),z,z),z))), multC(-0.21,multC(multC(multC(z,z,z),z,z),z,z))), c);\n        }\n        else if (state == 5.0){\n            Complex z1;\n            z1.real = abs(z.real);\n            z1.imag = -abs(z.imag);\n            z = addC(multC(z1,z1), c); // Burning Ship iteration formula\n        }\n        else if (state == 6.0){\n            Complex z1;\n            z1.real = z.real;\n            z1.imag = -z.imag;\n            z = addC(multC(z1,z1), c); // Tricorn iteration formula\n        }\n        else if (state == 7.0){\n            z = addC(multC(sinC(z), cosC(z)), c);\n        }\n        else if (state == 8.0){\n            z = divideC(addC(multC(z, z), c), multC(2.0, fractC(multC(43758.5453, sinC(z)))));\n        }\n        if (absC(z) > 2.0) {\n            return i; // If |z| > 2, it's not in the Mandelbrot set\n        }\n    }\n    return MAX_ITER;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 fragCoord )\n{\n    fragColor = ( re.x==fragCoord.x && re.y==fragCoord.y ) ? va : fragColor;\n}\n\nconst int KEY_SPACE = 32;\nconst int KEY_UP    = 38;\nconst int KEY_DOWN  = 40;\nconst int KEY_W     = 87;\nconst int KEY_A     = 65;\nconst int KEY_S     = 83;\nconst int KEY_D     = 68;\nconst int KEY_Z     = 90;\nconst int KEY_X     = 88;\nconst int KEY_Q     = 81;\nconst int KEY_E     = 69;\nconst int KEY_0     = 48;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_6     = 54;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the coordinates for the current pixel\n    vec2 resolution = iResolution.xy;\n    vec2 p = (2.0 * fragCoord - resolution) / min(resolution.x, resolution.y);\n    vec4 m = iMouse / iResolution.x;\n        \n    // Load saved values\n    ivec2 ifragCoord = ivec2( fragCoord-0.5 );\n    vec2 offset      = loadValue( txOffset ).xy;\n    vec2 mouseLast   = loadValue( txMouseLast ).xy;\n    float zoom       = loadValue( txZoom ).x;\n    float state      = loadValue( txState ).x;\n    \n    // Initialize zoom value\n    if (zoom==0.0){\n        zoom = 1.0;\n    }\n    \n    // Capture mouse events\n    if( m.w>0.0 ) // button click\n\t{\n        mouseLast.x = m.x;\n        mouseLast.y = m.y;\n    }\n    else if( m.z>0.0 ) // button is down\n\t{\n        offset.x = offset.x + (m.x - mouseLast.x) * 2.0*resolution.x/resolution.y / zoom;\n        offset.y = offset.y + (m.y - mouseLast.y) * 2.0*resolution.x/resolution.y / zoom;\n        mouseLast.x = m.x;\n        mouseLast.y = m.y;\n\t}\n    \n    // move with keyboard\n    float zoomSpeed = 2.0;\n    float moveSpeed = 3.0;\n    if( texelFetch( iChannel1, ivec2(KEY_UP,0), 0 ).x>0.5 )    zoom = zoom*(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_DOWN, 0), 0 ).x>0.5 ) zoom = zoom/(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_E,0), 0 ).x>0.5 )     zoom = zoom*(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_Q, 0), 0 ).x>0.5 )    zoom = zoom/(1.0+iTimeDelta*2.0);\n    if( texelFetch( iChannel1, ivec2(KEY_W, 0), 0 ).x>0.5 ) offset.y -= moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_A, 0), 0 ).x>0.5 ) offset.x += moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_S, 0), 0 ).x>0.5 ) offset.y += moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_D, 0), 0 ).x>0.5 ) offset.x -= moveSpeed*iTimeDelta/zoom;\n    if( texelFetch( iChannel1, ivec2(KEY_SPACE,0), 0 ).x>0.5 ) zoom = 1.0;\n    if( texelFetch( iChannel1, ivec2(KEY_0, 0), 0 ).x>0.5 ) state = 0.0;\n    if( texelFetch( iChannel1, ivec2(KEY_1, 0), 0 ).x>0.5 ) state = 1.0;\n    if( texelFetch( iChannel1, ivec2(KEY_2, 0), 0 ).x>0.5 ) state = 2.0;\n    if( texelFetch( iChannel1, ivec2(KEY_3, 0), 0 ).x>0.5 ) state = 3.0;\n    if( texelFetch( iChannel1, ivec2(KEY_4, 0), 0 ).x>0.5 ) state = 4.0;\n    if( texelFetch( iChannel1, ivec2(KEY_5, 0), 0 ).x>0.5 ) state = 5.0;\n    if( texelFetch( iChannel1, ivec2(KEY_6, 0), 0 ).x>0.5 ) state = 6.0;\n    if( texelFetch( iChannel1, ivec2(KEY_7, 0), 0 ).x>0.5 ) state = 7.0;\n    if( texelFetch( iChannel1, ivec2(KEY_8, 0), 0 ).x>0.5 ) state = 8.0;\n    if( texelFetch( iChannel1, ivec2(KEY_9, 0), 0 ).x>0.5 ) state = 9.0;\n    \n    // Save loaded values\n    fragColor = vec4(0.0);\n    storeValue( txOffset,    vec4(offset, 0.0, 0.0),     fragColor, ifragCoord );\n    storeValue( txMouseLast, vec4(mouseLast, 0.0, 0.0),  fragColor, ifragCoord );\n    storeValue( txZoom,      vec4(zoom, 0.0, 0.0, 0.0),  fragColor, ifragCoord );\n    storeValue( txState,     vec4(state, 0.0, 0.0, 0.0), fragColor, ifragCoord );\n}","name":"Buffer A","description":"","type":"buffer"}]}