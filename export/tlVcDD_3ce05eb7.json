{"ver":"0.1","info":{"id":"tlVcDD","date":"1611168484","viewed":99,"name":"FS Physics Probe Panel Animation","username":"GabrieleGiuseppini","description":"Experiments for the animation when opening the Physics Probe panel in Floating Sandbox.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["floatingsandbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float GetNoise(float y, float seed, float time) // -> (0.0, 1.0)\n{\n    #define NOISE_RESOLUTION 0.25\n    float s1 = texture(iChannel1, vec2(NOISE_RESOLUTION * y + time, seed)).r;\n    float s2 = texture(iChannel1, vec2(NOISE_RESOLUTION * y - time, seed)).r;\n    \n    #define NOISE_THRESHOLD .65\n    s1 = (clamp(s1, NOISE_THRESHOLD, 1.) - NOISE_THRESHOLD) * 1. / (1. - NOISE_THRESHOLD);\n    s2 = (clamp(s2, NOISE_THRESHOLD, 1.) - NOISE_THRESHOLD) * 1. / (1. - NOISE_THRESHOLD);\n    \n    return max(s1, s2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates\n    vec2 _uv = fragCoord/iResolution.xy;\n    //uv.y /= (iResolution.x / iResolution.y); // obey aspect ratio\n    \n    // uv: 0. -> 1.\n    \n    //\n    // Here we simulate this shader running in OpenGL as follows:\n    // - The panel occupies only a part of the screen\n    // - The texture lives in an Atlas and thus the extent\n    //   of the texture coordinates are somewhere arbitrary in the\n    //   texture coordinates space\n    // - The non-underscored variables are vertex attributes\n    //\n    // NDC screen x,y: -1.0 -> 1.0\n    // Texture x,y: 0.0 -> 1.0 (in reality it will be from atlas coordinates)\n    // Panel size NDC: w=1.0 h=0.5 (width is half of the screen)\n    // Quad x: -0.5 -> 0.5 (twice as wide as texture)\n    // Quad y: -0.25 -> 0.25\n    \n    float paramWidthNdc = 1.0;\n    vec2 _quadTopLeft = vec2(-0.5, 0.25);\n    vec2 _quadBottomRight = vec2(0.5, -0.25);\n        \n    // Time: phases:\n    // 1) from 0 to  4: inside=1, opening\n    // 2) from 4 to  5: still\n    // 3) from 5 to  9: inside=0. closing\n    // 4) from 9 to 10: still\n    #define SPEED 1.2\n    float _tmpTime = mod((float(iTime) * SPEED), 10.); // 0 -> 10\n    float vertexIsOpening = 1. - step(5., _tmpTime);\n    _tmpTime = mod(_tmpTime, 5.) / 4.; // 0 -> 1.25\n    _tmpTime = min(_tmpTime, 1.); // Pause\n    \n    // tmpTime: 0. -> 1.\n        \n    vec2 vertexCoordinatesNdc = _uv * 2. - vec2(1.0); // -1.0 -> 1.0\n    \n    // Vertex texture coords are rescaled so that they are 0->1 inside the quad NDC\n    vec2 vertexTextureCoordinates = vec2(\n        vertexCoordinatesNdc.x + 0.5, // -0.5 -> 1.5\n        (vertexCoordinatesNdc.y + 0.25) * 2.); // -1.5 -> 2.5\n\n    // Opening/Closing xLimits\n    float _width = paramWidthNdc * _tmpTime; // 0.0 -> 1.0\n    vec2 xLimitsNdc = vec2(\n        vertexIsOpening * (0. - _width / 2.) + (1. - vertexIsOpening) * (-paramWidthNdc / 2. + _width / 2.), \n        vertexIsOpening * (0. + _width / 2.) + (1. - vertexIsOpening) * (paramWidthNdc / 2. - _width / 2.)); // -0.5 -> 0.5        \n    \n    // Simulate quad by clipping outside of it\n    vec2 _uvNdc = (_uv - vec2(.5)) *  2.; // -1.0 -> 1.0\n    if (_uvNdc.x < _quadTopLeft.x\n        || _uvNdc.x > _quadBottomRight.x\n        || _uvNdc.y < _quadBottomRight.y\n        || _uvNdc.y > _quadTopLeft.y)\n    {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    ///////////////////////////////////////////////////////////////////////////\n    \n    //\n    // Flanges\n    //\n    \n    float currentWidthNdc = xLimitsNdc.y - xLimitsNdc.x; // 0.0 -> 0.5\n    float midXNdc = xLimitsNdc.x + currentWidthNdc / 2.;\n    float widthFraction = currentWidthNdc / paramWidthNdc;\n    \n    float noise = GetNoise(\n        vertexCoordinatesNdc.y / (.4 * paramWidthNdc * .5), \n        .2 * step(midXNdc, vertexCoordinatesNdc.x), \n        widthFraction / 5.);\n    \n    float flangeLengthNdc = (0.25 + noise * .4) * paramWidthNdc / 2.;\n    \n    // Flatten flange when panel is too small or almost fully open\n    flangeLengthNdc *= (smoothstep(.0, .46, widthFraction) - smoothstep(.54, 1., widthFraction));\n    \n    // Make flanges close to x Limits, either external or internal\n    // depending on whether we're closing or opening\n    float leftFlange = \n        vertexIsOpening * smoothstep(0.0, flangeLengthNdc, vertexCoordinatesNdc.x - xLimitsNdc.x)\n        + (1. - vertexIsOpening) * (1. - smoothstep(0.0, flangeLengthNdc, xLimitsNdc.x - vertexCoordinatesNdc.x));\n    float rightFlange = \n        vertexIsOpening * smoothstep(0.0, flangeLengthNdc, xLimitsNdc.y - vertexCoordinatesNdc.x)\n        + (1. - vertexIsOpening) * (1. - smoothstep(0.0, flangeLengthNdc, vertexCoordinatesNdc.x - xLimitsNdc.y));\n        \n    float panelDepth = \n        step(vertexCoordinatesNdc.x, midXNdc) * leftFlange\n        + step(midXNdc, vertexCoordinatesNdc.x) * rightFlange;\n                \n    float inPanelQuad = step(xLimitsNdc.x, vertexCoordinatesNdc.x) * step(vertexCoordinatesNdc.x, xLimitsNdc.y);\n                     \n    //\n    // Texture\n    //\n    \n    vec4 cTexture = texture(iChannel0, vertexTextureCoordinates);\n    \n           \n    //\n    // Final color\n    //\n            \n    vec4 color = vec4(cTexture.xyz, panelDepth);\n    \n    // Add white contour\n    float panelBorderDepth = max(\n        abs(inPanelQuad - panelDepth),\n        1.0 - smoothstep(0.0, 0.005, min(abs(vertexCoordinatesNdc.x - xLimitsNdc.x), abs(vertexCoordinatesNdc.x - xLimitsNdc.y))));\n    color = mix(\n        color,\n        vec4(1.),\n        panelBorderDepth);\n           \n    /* TEST: visualize noise\n    color = vec4(GetNoise(\n        vertexCoordinatesNdc.y / paramWidthNdc * 2., \n        .2 * step(midXNdc, vertexCoordinatesNdc.x), \n        widthFraction / 4.));\n    */\n    \n    /////////////////////////////////////////////////////////////////////////////\n    \n    fragColor = mix(vec4(0.), color, color.w);\n}","name":"Image","description":"","type":"image"}]}