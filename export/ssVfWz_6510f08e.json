{"ver":"0.1","info":{"id":"ssVfWz","date":"1658527784","viewed":804,"name":"SSAA SuperSampling Anti-Aliasing","username":"GCScholar","description":"Exampel of supersampling anti-aliasing using a square grid patter to sample the pixel.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["aliasing","antialiasing","supersampling","ssaa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray traces scene that show SSAA Super Sampling Anti Alias\n\n// SSAA sub samples number\n#define SSAA_NX 25 \n\n#define PI 3.14 \n#define FOCAL_LENGTH 1.5\n\nvoid swap(inout float x0, inout float x1)\n{\n    float tmp = x0;\n    x0=x1;\n    x1=tmp;\n}\n\nbool solveQuadratic(float a, float b, float c, out float x0, out float x1) \n{ \n    float delta = b*b-4.*a*c; \n    if (delta < 0.) return false; \n    else if (delta == 0.) \n    {\n        x0 = x1 = -0.5*b/a; \n    }\n    else \n    { \n        float q = (b > 0.) ? -0.5 * (b + sqrt(delta)) : -0.5 * (b - sqrt(delta)); \n        x0 = q/a; \n        x1 = c/q; \n    } \n    \n    return true; \n} \n\nstruct Hit \n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    int objId;\n};\n\nstruct Material \n{\n\tfloat shininess;\n    vec3 fresnelR0;\n    vec3 diffuseAlbedo;\n};\n\n// Tnx IQ for patterns\nvec4 getTexture(in vec2 p, int id)\n{\n    const float N = 20.0;\n    \n    // coordinates\n    vec2 i = step( fract(p), vec2(1.0/N));\n    \n    // patterns\n    if(id==1) \n    {\n        vec2 q = floor(p);\n        return vec4(mod( q.x+q.y, 2.0 ));\n    }\n    else if(id==2) return vec4((1.0-i.x)*(1.0-i.y));\n    else if(id==3) return vec4(1.0-i.x*i.y);   \n    else if(id==4) return vec4(1.0-i.x-i.y+2.0*i.x*i.y); \n}\n\nMaterial getMaterial(Hit hit) \n{\n    Material mat;\n\n    // Plane texture coordinates\n    if(hit.objId==1)\n    {\n        mat.shininess = 0.9;\n    \tmat.fresnelR0 =\tvec3(0.1);\n        mat.diffuseAlbedo = vec3(getTexture(hit.point.xz,1));\n        return mat;\n    } \n    \n    // Sphere texture coordinates\n    float u = (1. + atan(hit.normal.z, hit.normal.x) / PI) * 0.5; \n    float v = acos(hit.normal.y) / PI; \n        \n    if(hit.objId==2)\n    {\n        mat.shininess = 0.1;\n    \tmat.fresnelR0 =\tvec3(0.3);    \n        mat.diffuseAlbedo = vec3(getTexture(vec2(u,v)*128.,1)); \n    } \n    else if(hit.objId==3)\n    {\n        mat.shininess = 0.1;\n    \tmat.fresnelR0 =\tvec3(0.3);\n        mat.diffuseAlbedo = vec3(getTexture(vec2(u,v)*64.,2)); \n    } \n    else if(hit.objId==4)\n    {\n        mat.shininess = 0.1;\n    \tmat.fresnelR0 =\tvec3(0.3);\n        mat.diffuseAlbedo = vec3(getTexture(vec2(u,v)*16.,1)); \n    } \n    else if(hit.objId==5)\n    {\n        mat.shininess = 0.1;\n    \tmat.fresnelR0 =\tvec3(0.3);\n        mat.diffuseAlbedo = vec3(getTexture(vec2(u,v)*16.,4)); \n    } \n\n    return mat;\n}\n\nbool tracePlane(vec3 l0, vec3 l, vec3 n, vec3 p0, out Hit hit) \n{\n    float nl = dot(n,l);\n    if(-nl < 0.000001) return false; // line and plane parallel\n    float t = dot(p0-l0,n)/nl;\n    \n    hit.t = t;\n    hit.point = l0+t*l;\n    hit.normal = n;\n    \n    return true;\n}\n\nbool traceSphere(vec3 eye, vec3 ray, vec3 center, float radius, out Hit hit)\n{ \n    float t0, t1;\n\n    vec3 L = eye-center;\n    float a = dot(ray,ray);\n    float b = 2. * dot(ray,L); \n    float c = dot(L,L) - (radius*radius);\n    if (!solveQuadratic(a, b, c, t0, t1)) return false; \n    \n    if (t0 > t1) swap(t0, t1); \n\n    if (t0 < 0.) \n    { \n        t0 = t1;  //if t0 is negative, let's use t1 instead \n        if (t0 < 0.) return false;  //both t0 and t1 are negative \n    } \n\n    hit.t = t0;\n    hit.point = eye + t0*ray;\n    hit.normal = normalize(hit.point - center);\n    \n    return true; \n} \n\n// ILLUMINATION MODEL\n\nvec3 toLight1Dir = normalize(vec3(-0.5, 0.5, 0.5));\n\nvec3 SchlickFresnel(vec3 R0, vec3 N, vec3 L)\n{\n\t\n\tfloat f0 = 1.0f - max(dot(N, L), 0.0);\n    return R0 + (1.0f - R0)*(f0*f0*f0*f0*f0);\n}\n\n// Blinn-Phong model\nvec3 BlinnPhong(vec3 lightStrength, vec3 L, vec3 N, vec3 V, Material mat)\n{\n    vec3 H = normalize(L+V);\t// Half vector between View and Light vector\n\t\n    float m = mat.shininess * 256.0;\n    float roughnessFactor = ((m + 8.0)*pow(max(dot(H,N),0.0), m))/8.0;\t// Controls how much smooth is the material, taking into account normalization for energy conservation    \n\tvec3 fresnelFactor = SchlickFresnel(mat.fresnelR0, H, L);\n    vec3 specAlbedo = fresnelFactor*roughnessFactor;\n    specAlbedo = specAlbedo / (specAlbedo + 1.0f);\t// the formula goes outside [0,1]\n    return (mat.diffuseAlbedo.rgb + specAlbedo) * lightStrength;\n}\n\nvec4 render(Hit hit, vec3 eye)\n{\n    // Material properties\n    Material mat = getMaterial(hit);\n   \t\n    vec3 V = normalize(eye - hit.point);\t// Vector from surface point to the camera\n\tvec3 N = hit.normal; \n    vec3 R = reflect(-V,N);\t\t// Reflected light vector respect to N\n    \n    // Light 1\n    vec3 light1Color = vec3(0.9);\n    \n    // Lambert-law attenuation\n    vec3 light1Strength = max(dot(toLight1Dir,N),0.0)*light1Color;\n    vec3 C_light1 = BlinnPhong(light1Strength, toLight1Dir, N, V, mat);\n\n    return vec4(C_light1,1.0);\n}\n\n\nvec4 sampleScene(vec3 ray, vec3 eye, out float t) \n{\n    Hit hit; \n    vec4 color;\n    float minT = 999999999.;\n    \n    // Left sphere\n    if(traceSphere(eye, ray, vec3(-2,1,-3),1., hit) && hit.t < minT)\n    {\n        minT = hit.t;\n        hit.objId = 2;\n        color = render(hit, eye);\n    }\n    // Central sphere\n    if(traceSphere(eye, ray, vec3(0,2,-5),2., hit) && hit.t < minT)\n    {\n        minT = hit.t;\n        hit.objId = 3;\n        color = render(hit, eye);\n    }\n    // Right sphere\n    if(traceSphere(eye, ray, vec3(1.5,0.7,-3),0.7, hit) && hit.t < minT)\n    {\n        minT = hit.t;\n        hit.objId = 4;\n        color = render(hit, eye);\n    }\n    if(tracePlane(eye, ray, vec3(0,1,0), vec3(0,0,0), hit) && hit.t < minT)\n    {\n       minT = hit.t;\n       hit.objId = 1;\n       color = render(hit, eye);\n    }\n    \n    if(minT == 999999999.) color = vec4(1);\n    \n    t = minT;\n    return color;\n}\n\n// The filter is a square grid of dimension (N+1)*(N+1)\nvec4 SuperSamplingNX(int filterSize, vec3 eye, vec3 target, vec3 ww, vec3 vv, vec3 uu, vec2 U)\n{\n    int nSteps = int(sqrt(float(filterSize))) - 1;\n    \n    vec4 color;\n    vec3 ray;\n\n    float pixelSize = 1./(0.5*iResolution.x);\n    float filterStep = pixelSize/float(nSteps);\n        \n            \n    // SUB SAMPLING THE PIXEL\n    for(int i=0; i<=nSteps; i++)\n    {\n        for(int j=0; j<=nSteps; j++)\n        {\n            Hit hit;\n            \n            vec3 xx = (U.x-float(pixelSize)/2.+filterStep*float(i)) * vv;\n            vec3 yy = (U.y-float(pixelSize)/2.+filterStep*float(j)) * uu;\n            vec3 zz = FOCAL_LENGTH * ww;\n            ray = normalize(xx + yy - zz);\n            \n            float t;\n            color += sampleScene(ray, eye, t);\n        }\n    }\n    \n    if(nSteps != 0) return color/float((nSteps+1)*(nSteps+1));\n    else return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 U = (2.*fragCoord-iResolution.xy)/(iResolution.x);\n    float camAngle = PI/32.*sin(iTime/4.);\n    vec3 eye = vec3(5.0*sin(camAngle),1.5,5.0*cos(camAngle));\n    vec3 target = vec3(0.,1.,0.);\n   \t\n    // Reference frame\n    vec3 ww = normalize(eye-target);\n    vec3 vv = normalize(cross(vec3(0.,1.,0.), ww));\n    vec3 uu = normalize(cross(ww, vv));\n    \n    float sepLine = abs(iResolution.x*abs(cos(iTime/2.)));\n    float center = step(2., abs(sepLine - fragCoord.x));\n    if(center == 0.)\n    {\n        fragColor = vec4(0);\n    }\n    else \n    {\n        if(fragCoord.x > sepLine)\n        {\n            fragColor = SuperSamplingNX(SSAA_NX, eye, target, ww, vv, uu, U);\n        }\n        else \n        {\n            Hit hit;\n            vec3 ray = normalize(U.x*vv + U.y*uu - FOCAL_LENGTH*ww);\n            float t;\n            fragColor = sampleScene(ray, eye, t);\n        }\n     }\n}","name":"Image","description":"","type":"image"}]}