{"ver":"0.1","info":{"id":"WsfXW2","date":"1552237918","viewed":310,"name":"Ray Tracing Parametric Patches","username":"blackle","description":"analytic intersection of a bicubic patch defined by 16 control points.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["bicubic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n// here be jragons (jort dragons)\n\n// Influential/helpful papers:\n// \"Ray Tracing Parametric Patches\" - James T. Kajiya\n// \"The Bernstein Basis and its Applications in Solving Geometric Constraint Systems\" - Sebti Foufou & Dominique Michelucci\n// \"On de Casteljau’s algorithm\" - Wolfgang Boehm & Andreas Müller\n\n//I solve using the bernstein basis & related techniques, unlike Kajiya's extremely computer algebra influenced approach\n\n#define ONLY_MIDDLE 0\n#define SPLIT_QUEUE_SIZE 16\n\nuniform int donttouch;\n\nstruct IntersectProblem\n{\n    mat4 cpX;\n    mat4 cpY;\n    mat4 cpZ;\n    vec3 plane1;\n    vec3 plane2;\n    vec3 cameraOrigin;\n    vec3 point;\n    vec3 normal;\n};\n\nstruct Split\n{\n    vec2 topleft;\n    vec2 size;\n    mat4 A;\n    mat4 B;\n};\n\nvoid deCasteljauSplit(in mat4 A, in int axis, out mat4 A1, out mat4 A2, float splitpos) {\n    if (axis == 1) { A = transpose(A); }\n\n    vec4 b11 = mix(A[0],A[1], splitpos);\n    vec4 b12 = mix(A[1],A[2], splitpos);\n    vec4 b13 = mix(A[2],A[3], splitpos);\n    vec4 c11 = mix(b11,b12, splitpos);\n    vec4 c12 = mix(b12,b13, splitpos);\n    vec4 d11 = mix(c11,c12, splitpos);\n\n    A1[0] = A[0];\n    A2[0] = d11;\n\n    A1[1] = b11;\n    A2[1] = c12;\n\n    A1[2] = c11;\n    A2[2] = b13;\n\n    A1[3] = d11;\n    A2[3] = A[3];\n\n    if (axis == 1) { A1 = transpose(A1); A2 = transpose(A2); }\n}\n\nmat4 middleHalf(mat4 A) {\n    mat4 A1; mat4 A2; mat4 A3;\n    deCasteljauSplit(A, 0, A1, A2, 1.0/4.0);\n    deCasteljauSplit(A2, 0, A1, A3, 2.0/3.0);\n\n    deCasteljauSplit(A1, 1, A3, A2, 1.0/4.0);\n    deCasteljauSplit(A2, 1, A1, A3, 2.0/3.0);\n    return A1;\n}\n\nbool isSystemFeasible(mat4 A, mat4 B) {\n    // does there exist an X and Y such that B*X + A*Y has components that are all positive?\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            //TODO: figure out a more numerically stable way to do this test\n            vec2 smplold = vec2(A[i][j], B[i][j]);\n            float lensmpl = length(smplold); //if length is too small, the value of test could be erroniously close to zero\n            smplold = normalize(smplold);\n            mat4 test = (A*smplold.y - B*smplold.x);\n            vec4 epsi = vec4(-0.000001);\n            if (all(greaterThanEqual(test[0], epsi)) &&\n                all(greaterThanEqual(test[1], epsi)) &&\n                all(greaterThanEqual(test[2], epsi)) &&\n                all(greaterThanEqual(test[3], epsi)) &&\n                lensmpl > 0.02) return true;\n        }\n    }\n    return false;\n}\n\nvec3 evalBernstein(mat4 cpX, mat4 cpY, mat4 cpZ, vec2 uv) {\n    vec4 uvec_d3 = vec4(pow(1.0-uv.x, 3.), 3.0*uv.x*pow(1.0-uv.x, 2.), 3.0*pow(uv.x,2.)*(1.0-uv.x), pow(uv.x, 3.)); \n    vec4 vvec_d3 = vec4(pow(1.0-uv.y, 3.), 3.0*uv.y*pow(1.0-uv.y, 2.), 3.0*pow(uv.y,2.)*(1.0-uv.y), pow(uv.y, 3.)); \n\n    return vec3(dot((uvec_d3 * cpX), vvec_d3), dot((uvec_d3 * cpY), vvec_d3), dot((uvec_d3 * cpZ), vvec_d3));\n}\n\nmat3 jacobian(mat4 A, mat4 B, mat4 C, vec2 uv) {\n    vec2 epsilon= vec2(0.00001,0.0);\n    vec3 uv000 = evalBernstein(A, B, C, uv);\n    return mat3(\n        (uv000-evalBernstein(A, B, C, uv - epsilon.xy))/epsilon.x,\n        (uv000-evalBernstein(A, B, C, uv - epsilon.yx))/epsilon.x,\n         uv000);//passing the calculated point back in this unused column so the callers can use it\n}\n\nvec2 newtonsMethod(mat4 A, mat4 B, vec2 uv) {\n    mat3 fjcb = jacobian(A, B, B, uv);\n\n    mat2 jcb = mat2(fjcb[0].xy, fjcb[1].xy);\n\n    return uv - inverse(jcb) * fjcb[2].xy;\n}\n\n// the crux of the intersection routine comes down to the fact that if the system of equations\n// A*X + B*Y > 0 has no solutions, then the patch must not contain an intersection with the ray\n// if the system is feasible, then we can split the patch into quarters using de Casteljau's method\n// and test each quarter. We can repeatedly do this until we've isolated one or more very small areas\n// of the patch that might have an intersection. Then, we refine the midpoint of those areas\n// using newton's method, and then finally we decide which one is closest to the camera, and if it actually\n// intersects with the ray at all. the point that we find after all of this is the intersection point.\nbool doesIntersect(inout IntersectProblem p) {\n    // plane1 and 2 are planes in 3d space (defined by their normal + intersection along that normal)\n    // the intersection of plane1 and plane2 gives you the camera ray\n    vec4 plane1 = vec4(p.plane1, -dot(p.plane1, p.cameraOrigin));\n    vec4 plane2 = vec4(p.plane2, -dot(p.plane2, p.cameraOrigin));\n\n    mat4 A = plane1.x * p.cpX + plane1.y * p.cpY + plane1.z * p.cpZ + plane1.w;\n    mat4 B = plane2.x * p.cpX + plane2.y * p.cpY + plane2.z * p.cpZ + plane2.w;\n    \n    int read = 0;\n    int write = 0;\n    Split splits[SPLIT_QUEUE_SIZE];\n\n    if(!isSystemFeasible(A, B)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(vec2(0.0), vec2(1.0), A, B);\n\n    // ugly hack to force this not to unroll, otherwise it can take minutes to compile\n    for (int i = 0; i < 12+donttouch && write != read; i++) {\n        Split s = splits[read++ % SPLIT_QUEUE_SIZE];\n        mat4 A1; mat4 A2;\n        deCasteljauSplit(s.A, 0, A1, A2, 0.5);\n        mat4 B1; mat4 B2;\n        deCasteljauSplit(s.B, 0, B1, B2, 0.5);\n\n        mat4 A11; mat4 A12;\n        deCasteljauSplit(A1, 1, A11, A12, 0.5);\n        mat4 B11; mat4 B12;\n        deCasteljauSplit(B1, 1, B11, B12, 0.5);\n        mat4 A21; mat4 A22;\n        deCasteljauSplit(A2, 1, A21, A22, 0.5);\n        mat4 B21; mat4 B22;\n        deCasteljauSplit(B2, 1, B21, B22, 0.5);\n\n        vec3 newsize = vec3(s.size/2.0, 0.0);\n        if (!isSystemFeasible(A11, B11)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.zz, newsize.xy, A11, B11);\n        if (!isSystemFeasible(A12, B12)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.xz, newsize.xy, A12, B12);\n        if (!isSystemFeasible(A21, B21)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.zy, newsize.xy, A21, B21);\n        if (!isSystemFeasible(A22, B22)) splits[write++ % SPLIT_QUEUE_SIZE] = Split(s.topleft + newsize.xy, newsize.xy, A22, B22);\n    }\n\n    if (write == read) return false;\n\n    float mindist = -1.0;\n    for (int i = read; i < write; i++) {\n\n        Split s = splits[i % SPLIT_QUEUE_SIZE];\n        vec2 uv = s.topleft + s.size/2.0;\n        for (int j = 0; j < 6; j++) {\n        \tuv = newtonsMethod(A, B, uv);\n        }\n        mat3 jcb = jacobian(p.cpX, p.cpY, p.cpZ, uv);\n        vec4 point = vec4(jcb[2], 1.0);\n        float dist = distance(point.xyz, p.cameraOrigin);\n        if ((mindist < 0.0 || dist < mindist) && all(lessThan(uv, vec2(1.0))) && all(greaterThan(uv, vec2(0.0))) && abs(dot(point, plane1)) < 0.001 && abs(dot(point, plane2)) < 0.001 ) {\n            mindist = dist;\n            p.point = point.xyz;\n            p.normal = normalize(cross(jcb[0], jcb[1]));\n        }\n    }\n    \n    return (mindist != -1.0);\n}\n\nvec3 srgb(float r, float g, float b) {\n    return vec3(r*r,g*g,b*b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)*2.0 - vec2(1.0,1.0);\n    uv.y *= iResolution.y/iResolution.x;\n    // Camera parameters\n    float orbitdist = -5.0;\n    vec3 cameraOrigin = vec3(orbitdist*cos(iTime*0.1), orbitdist*sin(iTime*0.1), 2.0);\n    vec3 cameraDirection = normalize(-cameraOrigin);\n\n    vec3 plateXAxis = normalize(cross(cameraDirection, vec3(0.0,0.0,-1.0)));\n    vec3 plateYAxis = normalize(cross(cameraDirection, plateXAxis));\n    \n    float fov = radians(50.0);\n    vec3 platePoint = (plateXAxis * uv.x + plateYAxis * uv.y) * tan(fov /2.0);\n    \n    vec3 rayDirection = normalize(platePoint + cameraDirection);\n    vec3 rayPlane1 = normalize(cross(rayDirection, vec3(0.0,0.0,-1.0)));\n    vec3 rayPlane2 = normalize(cross(rayDirection, rayPlane1));\n\n\t//these are the control points for the parametric patch, arranged like so:\n    \n    //  cp11 -- cp12 -- cp13 -- cp14\n    //    |       |       |       |\n    //    |       |       |       |\n    //  cp21 -- cp22 -- cp23 -- cp24\n    //    |       |       |       |\n    //    |       |       |       |\n    //  cp31 -- cp32 -- cp33 -- cp34\n    //    |       |       |       |\n    //    |       |       |       |\n    //  cp41 -- cp42 -- cp43 -- cp44\n\n    // currently the values have the x and y lie in a grid, but this can be changed\n    \n    vec3 cp11 = vec3(-1.00, -1.00,  cos(iTime));\n    vec3 cp12 = vec3(-1.00, -0.33, -cos(iTime));\n    vec3 cp13 = vec3(-1.00,  0.33,  cos(iTime));\n    vec3 cp14 = vec3(-1.00,  1.00, -cos(iTime));\n\n    vec3 cp21 = vec3(-0.33, -1.00,  sin(iTime));\n    vec3 cp22 = vec3(-0.33, -0.33, -sin(0.5*iTime)*2.0);\n    vec3 cp23 = vec3(-0.33,  0.33,  sin(0.5*iTime)*2.0);\n    vec3 cp24 = vec3(-0.33,  1.00, -sin(iTime));\n\n    vec3 cp31 = vec3( 0.33, -1.00, -cos(iTime));\n    vec3 cp32 = vec3( 0.33, -0.33,  cos(0.5*iTime)*2.0);\n    vec3 cp33 = vec3( 0.33,  0.33, -cos(0.5*iTime)*2.0);\n    vec3 cp34 = vec3( 0.33,  1.00,  cos(iTime));\n\n    vec3 cp41 = vec3( 1.00, -1.00, -sin(iTime));\n    vec3 cp42 = vec3( 1.00, -0.33,  sin(iTime));\n    vec3 cp43 = vec3( 1.00,  0.33, -sin(iTime));\n    vec3 cp44 = vec3( 1.00,  1.00,  sin(iTime));\n    \n    \n    mat4 cpX = mat4(cp11.x, cp12.x, cp13.x, cp14.x,\n                    cp21.x, cp22.x, cp23.x, cp24.x,\n                    cp31.x, cp32.x, cp33.x, cp34.x,\n                    cp41.x, cp42.x, cp43.x, cp44.x);\n\n    mat4 cpY = mat4(cp11.y, cp12.y, cp13.y, cp14.y,\n                    cp21.y, cp22.y, cp23.y, cp24.y,\n                    cp31.y, cp32.y, cp33.y, cp34.y,\n                    cp41.y, cp42.y, cp43.y, cp44.y);\n    \n    mat4 cpZ = mat4(cp11.z, cp12.z, cp13.z, cp14.z,\n                    cp21.z, cp22.z, cp23.z, cp24.z,\n                    cp31.z, cp32.z, cp33.z, cp34.z,\n                    cp41.z, cp42.z, cp43.z, cp44.z);\n\n    // if you are interested in subdivision modelling and the mathematics behind it,\n    // each quad face with no extraordinary verticies can be modelled as the middle portion\n    // of a bicubic patch. Change the ONLY_MIDDLE define to see\n#if ONLY_MIDDLE\n    cpX = middleHalf(cpX);\n    cpY = middleHalf(cpY);\n    cpZ = middleHalf(cpZ);\n#endif\n    \n    vec3 col = vec3(0);\n    IntersectProblem p = IntersectProblem(cpX, cpY, cpZ, rayPlane1, rayPlane2, cameraOrigin, vec3(0.0), vec3(0.0));\n    if (doesIntersect(p)) {\n        vec3 r = reflect(cameraDirection, p.normal);\n        float fac = length(sin(r*2.5)*0.5+0.5)/sqrt(3.);\n        col = mix(srgb(0.05,0.01,0.01), srgb(0.8,0.4,0.3), fac) + pow(fac, 9.);\n    }\n\n    fragColor = vec4(sqrt(col), 1.0);\n\n}","name":"Image","description":"","type":"image"}]}