{"ver":"0.1","info":{"id":"mdVyDc","date":"1696707381","viewed":119,"name":"Raymarched Spiral [Fork]","username":"nextrix","description":"fork of https://www.shadertoy.com/view/MsVyRh\nwith values and some documentation + better scaling","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","raymarch","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GREYSCALE 0.\n#define BRIGHTNESS 1.\n#define HUEPOWER 0.02   // power of hue applied to spiral  (lower = more hue)\n#define SPIRALWHITENESS 0.01\n#define GLOWPOWER 1.   // lower = more power  |  set to 2 for a wireframe-like effect\n\n#define ROTPOWX 0.11\n#define ROTPOWY 0.11\n#define ZOOMSPEED 3.0\n\n#define PARTICLESIZE 0.001  //   0 - 1\n#define PARTICLEPOWER 1.\n#define FOGDARKNESS 1.\n#define ENDPOINT 0.5\n#define THICKNESS 0.01 \n\nvec2 path(float t) {\n    float a = cos(t*ROTPOWX),b=sin(t*ROTPOWY);   // ( a = x axis, b = y axis)\n    return vec2(a, b);\n}\n\nmat2 r2d(float a) {\n    float c=cos(a),s=sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvoid mo(inout vec2 p, vec2 d) {\n    p.x = abs(p.x) - d.x;\n    p.y = abs(p.y) - d.y;\n    if(p.y>p.x)p=p.yx;  // flip the yx to xy for wider spiral (inverts scaling)  |  kinda looks like the game \"run\" from coolmathgames\n}\n\nfloat g=0.;\n\nfloat de(vec3 p) {\n   \n    vec3 q = p;\n    q.x += q.z*.1;\n    q.z += iTime*.2;\n    q = (mod(q-1., 2.))-1.;\n    float s = length(q) - PARTICLESIZE + sin(iTime*30.)*.005;\n    \n    p.xy -= path(p.z);\n    \n    p.xy *= r2d(p.z*0.7) ;   // spiral power\n    mo(p.xy, vec2(1.17, .23));  // spiral seed / dimensions idfk what to call it\n    mo(p.xy, vec2(1.05, .32));  // spiral seed / dimensions idfk what to call it\n    \n    p.xy *= r2d(p.z + iTime);  // make it spin\n    \n    mo(p.zy, vec2(iMouse.x / 50., iMouse.x / 100.));\n    p.x = abs(p.x) - .9;\n    float d = length(p.xy) - THICKNESS - (.3+.7*cos(p.z))*.0001;\n    \n    d = min(d, s*PARTICLEPOWER);\n    \n    \n    g+=SPIRALWHITENESS/(.01+d*d);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;   // spiral uv centered\n    vec2 uv0 = fragCoord/iResolution.xy;  // hue uv \n    uv.x*=iResolution.x/iResolution.y;  // fixed aspect ratio\n    \n    //uv.xy *= -3.5;    //uncomment for cool fract\n    \n    //uv = fract(abs(uv)) - 0.15;   //uncomment for cool fract\n    \n    float dt = iTime * ZOOMSPEED;    //   z axis speed (go thru spiral)\n    vec3 ro = vec3(0,0, -1. + dt);   // position of spiral xyz  \n    vec3 ta = vec3(0, 0, dt);    // position of spiral xyz\n    \n    ro.xy += path(ro.z);\n    ta.xy += path(ta.z);\n    \n    vec3 fwd = normalize(ta -ro);\n    vec3 left = cross(vec3(0,1,0),fwd);\n    vec3 up = cross(fwd, left);\n    \n    vec3 rd = normalize(fwd + left*uv.x+up*uv.y);\n\n    vec3 p;\n    float ri,t=ENDPOINT;\n    for(float i=0.;i<GLOWPOWER;i+=.01) {\n    \tri = i;\n        p=ro+rd*t;\n        float d = de(p);\n        if(d<.001) break;\n        t+=d*.2;\n    }\n\tvec3 bg =  vec3(0.0, 0.0, 0.0);\n    vec3 col = 0.5 + 0.5*cos(iTime+uv0.xyx+vec3(0,2,4));  //mix(vec3(.4, .5, .5), bg,ri);  // normal color replaced with default shadertoy hue\n    col += g * HUEPOWER;\n    \n    \n    col = mix(min(clamp(col*col,GREYSCALE,1.), BRIGHTNESS), bg*bg, FOGDARKNESS-exp(-.01*t*t));  // added clamp for greyscale and col*col gets better colors\n    //col = mix(col, bg, 1.-exp(-.01*t*t));  // old\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}