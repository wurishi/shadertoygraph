{"ver":"0.1","info":{"id":"3lSXRt","date":"1566691720","viewed":110,"name":"TornadeLattice","username":"Fogrex","description":"lattice tornade","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PI2 6.28318530718\n\nint STEP = 64;\nfloat NEAR = 2.0;\nfloat REPEAT_UNIT = 500.0;\n\n\n//transform function(inverse)\nvec3 transform(vec3 pos, vec3 move, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * m * p).xyz;\n}\n\nvec3 translate(vec3 pos, vec3 move)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 m = mat4(\n        1.0,    0.0,    0.0,    0.0,\n        0.0,    1.0,    0.0,    0.0,\n        0.0,    0.0,    1.0,    0.0,\n        -move.x,    -move.y,    -move.z,    1.0\n    );\n   \n    return (m * p).xyz;\n}\n\nvec3 rotate(vec3 pos, vec3 rot)\n{\n    vec4 p = vec4(pos.x, pos.y, pos.z, 1.0);\n    mat4 rx = mat4(\n        1.0,    0.0,        0.0,            0.0,\n        0.0,    cos(-rot.x), sin(-rot.x),    0.0,\n        0.0,    -sin(-rot.x), cos(-rot.x),     0.0,\n        0.0,    0.0,        0.0,            1.0\n    );\n    mat4 ry = mat4(\n        cos(-rot.y),     0.0,    -sin(-rot.y), 0.0,\n        0.0,            1.0,    0.0,        0.0,\n        sin(-rot.y),    0.0,    cos(-rot.y), 0.0,\n        0.0,            0.0,    0.0,        1.0\n    );\n    mat4 rz = mat4(\n        cos(-rot.z), sin(-rot.z),    0.0,    0.0,\n        -sin(-rot.z), cos(-rot.z),     0.0,    0.0,\n        0.0,        0.0,            1.0,    0.0,\n        0.0,        0.0,            0.0,    1.0\n    );\n\n    return (ry * rx * rz * p).xyz;\n}\n\n// distance functions\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    vec3 d = abs(pos) - size;\n    return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat cylinder(vec3 pos, float r)\n{\n    return length(pos.xz) - r;\n}\n\n// mixing shapes\nfloat nsUnion(float d1, float d2) {return min(d1, d2);}\n\nfloat nsSubtraction(float d1, float d2) {return max(-d1, d2);}\nfloat nsIntersection(float d1, float d2) {return max(d1, d2);}\nfloat sUnion(float d1, float d2, float k){\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k*h*(1.0-h);\n}\nfloat sSubtraction(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k*h*(1.0-h);\n}\nfloat sIntersection(float d1, float d2, float k){\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) + k*h*(1.0-h);\n}\n\n\n//mapping\nfloat map(vec3 pos)\n{\n    pos = rotate(pos, vec3(0.0,0.0,pos.z / REPEAT_UNIT * PI2));\n    \n    vec3 m = vec3(REPEAT_UNIT / 40.0,REPEAT_UNIT / 40.0,REPEAT_UNIT / 40.0);\n    pos = mod(pos,m) - m * 0.5;\n    float c1 = cylinder(pos, 1.0);\n    float c2 = cylinder(rotate(pos, vec3(PI/2.0,0.0,0.0)),1.0);\n    float c3 = cylinder(rotate(pos, vec3(0.0,0.0,PI/2.0)),1.0);\n    float s1 = sphere(pos,2.0);\n    float r = nsUnion(c2,c3);\n    r = nsUnion(c1, r);\n    r += sin(pos.x*3.0)*sin(pos.y*3.0)*sin(pos.z*3.0)*0.25;\n    \n    r = nsUnion(s1, r);\n    return r;\n    \n}\n\n// calculating normal\nvec3 calcNorm(vec3 pos)\n{\n    float d = 0.0001;\n    float center = map(pos);\n    vec3 grad = vec3(map(pos+vec3(d,0.0,0.0))-center, map(pos+vec3(0.0,d,0.0))-center, map(pos+vec3(0.0,0.0,d))-center);\n    return normalize(grad / d);\n}\n\n// lambert model\nvec4 lambert(vec3 pos, vec3 lightDir)\n{\n    vec3 n = calcNorm(pos);\n    float b = max(0.0, dot(n, -normalize(lightDir)))*0.9+0.1;\n    return vec4(b, b, b, 1.0);\n}\n\nvec4 visualizeNormal(vec3 pos)\n{\n    return vec4(calcNorm(pos),1.0)*0.8 + vec4(1.0,1.0,1.0,1.0)*0.2;\n}\n\n// raymarching\nvec4 raymarch(vec2 fc)\n{\n    fc = (fc * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 ray = normalize(vec3(fc, NEAR));\n    vec3 pos = vec3(fc, NEAR);\n    \n    //camera rotating\n    float rx = iMouse.x/iResolution.x*2.0 - 1.0;\n    float ry = iMouse.y/iResolution.y*2.0 - 1.0;\n    pos = rotate(pos, vec3(ry,-rx,0.0));\n    ray = rotate(ray, vec3(ry,-rx,0.0));\n    \n    // camera moving\n    pos = translate(pos, vec3(0.0,0.0,mod(-iTime*20.0, REPEAT_UNIT)));\n    \n    \n    float d = 0.0;\n    \n    for(int i=0;i<STEP;i++)\n    {\n        d = map(pos);\n        if(d < 0.0001){\n            return lambert(pos, vec3(1.0,-1.0,0.0));\n            //return visualizeNormal(pos);\n        }\n        pos = pos + ray * d;\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    fragColor = raymarch( fragCoord);\n}","name":"Image","description":"","type":"image"}]}