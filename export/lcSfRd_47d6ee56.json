{"ver":"0.1","info":{"id":"lcSfRd","date":"1725570218","viewed":104,"name":"Trippy SDF worm","username":"stevegamer","description":"Smooth colorful worm, made out of spheres united by \"smooth minimum\" function.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sdf","metaballs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nconst vec3 background_color = vec3(0.3, 0.7, 0.9);\nconst float shape_tolerance = 1.0; // (0; inf) how smooth will shape transition be\nconst float color_mix_sharpness = 10.0; // (1; inf) how sharp will color transition\nconst float trefoil_size = 6.0; // how big the whole thing is\nconst float radius = 0.5;\n\n\nstruct sphere {\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\n\nconst int n_spheres = 24;\nsphere spheres[n_spheres] = sphere[](\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(1.0, 0.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 1.0, 0.0)),\n    sphere(vec3(0, 0, 0), radius, vec3(0.0, 0.0, 1.0))\n);\n\nconst bool metal_reflection = false;\n\n\nstruct light{\n    vec3 position;\n    float strength;\n    vec3 color;\n};\n\nconst int n_lights = 1;\nlight lights[n_lights] = light[](\n    light(vec3(0, 0, -100.0), 10000.0, vec3(1, 1, 1))\n);\n\n\nfloat sphere_sdf(in vec3 point, in vec3 center, in float radius) {\n    return length(point - center) - radius;\n}\n\n// Color weight field - determines how much of a shape's color should be used.\nfloat sphere_cwf(in vec3 point, in vec3 center, in float radius) {\n    return pow(color_mix_sharpness, radius - (length(point - center)));\n}\n\nfloat sdf(in vec3 point) {\n    float sum = 0.0;\n    for (int i = 0; i < n_spheres; ++i) {\n        float dist = sphere_sdf(point, spheres[i].center, spheres[i].radius);\n        sum += exp2(-dist / shape_tolerance);\n    }\n    return -shape_tolerance * log2(sum);\n}\n\nvec3 base_color(in vec3 point) {\n    vec3 color_num = vec3(0, 0, 0);\n    vec3 color_denom = vec3(0, 0, 0);\n    for (int i = 0; i < n_spheres; ++i) {\n        float cwf = sphere_cwf(point, spheres[i].center, spheres[i].radius);\n        color_num += spheres[i].color * cwf;\n        color_denom += cwf;\n    }\n    return color_num / color_denom;\n}\n\nbool traceRay(in vec3 ray, in vec3 pos, out vec3 impact_point) {\n    while (true) {\n        float dist = abs(sdf(pos));\n    \n        if (dist < 0.01) {\n            impact_point = pos;\n            return true;\n        }\n        \n        if (dist > 100.0) {\n            return false;\n        }\n        \n        pos += ray * dist;\n    }\n}\n\nvec3 grad(in vec3 point, in float delta) {\n    vec3 dx = vec3(delta, 0, 0);\n    vec3 dy = vec3(0, delta, 0);\n    vec3 dz = vec3(0, 0, delta);\n    float y0 = sdf(point);\n    return (vec3(sdf(point+dx), sdf(point+dy), sdf(point+dz)) - vec3(y0, y0, y0)) / delta;\n}\n\n\nvec3 diffuse(in vec3 point, in vec3 base_color) {\n    vec3 normal = normalize(grad(point, 0.0001));\n    vec3 result = vec3(0, 0, 0);\n    \n    for (int i = 0; i < n_lights; ++i) {\n        vec3 lightray = lights[i].position - point;\n        float intensity = lights[i].strength / pow(length(lightray), 2.0);\n        result += max(dot(normal, normalize(lightray)), 0.0) * intensity * lights[i].color;\n    }\n    result *= base_color;\n    return result;\n}\n\nvec3 specular(in vec3 eye, in vec3 point, in vec3 base_color) {\n    vec3 normal = normalize(grad(point, 0.0001));\n    vec3 eye_ray = normalize(eye - point);\n    vec3 result = vec3(0, 0, 0);\n    \n    for (int i = 0; i < n_lights; ++i) {\n        vec3 lightray_refl = -reflect(lights[i].position - point, normal);\n        float intensity = lights[i].strength / pow(length(lightray_refl), 2.0);\n        float powered = pow(max(dot(eye_ray, normalize(lightray_refl)), 0.0), 20.0);\n        result += powered * intensity * lights[i].color;\n    }\n    \n    if (metal_reflection) {\n        result *= base_color;\n    }\n    return result;\n}\n\nvoid positionSpheres() {\n    for (int i = 0; i < n_spheres; ++i) {\n        float t = iTime + PI * float(i) / float(n_spheres);\n        spheres[i].center = vec3(trefoil_size * cos(3.0 * t) * sin(t) + sin(2.0 * t) * 0.2,\n                                 trefoil_size * cos(3.0 * t) * cos(t) + sin(t) * 0.2,\n                                 33.0 + 30.0 * sin(t * 0.5));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    positionSpheres();\n\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / min(iResolution.x, iResolution.y);\n\n    vec3 camera = vec3(0, 0, -1);\n    vec3 ray = normalize(vec3(uv, 0) - camera);\n    vec3 surface_point;\n    vec3 color;\n    if (traceRay(ray, camera, surface_point)) {\n        vec3 base = base_color(surface_point);\n        color = specular(camera, surface_point, base) + diffuse(surface_point, base) + background_color * base * 0.5;\n    } else {\n        color = background_color;\n    }\n    \n    fragColor = vec4(color ,1.0);\n}\n","name":"Image","description":"","type":"image"}]}