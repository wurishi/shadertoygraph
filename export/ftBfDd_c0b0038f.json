{"ver":"0.1","info":{"id":"ftBfDd","date":"1652959187","viewed":189,"name":"Fast quadratic bezier (matrix)","username":"mrboggieman","description":"Rendering a quadratic bezier using a transformation matrix, inspired by the Loop/Blinn paper (https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-25-rendering-vector-art-gpu), click and drag the mouse to move the middle point","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["bezier","matrix","quadratic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n* A new method of rendering a quadratic bezier, inspired by the Loop/Blinn paper\n* https://developer.nvidia.com/gpugems/gpugems3/part-iv-image-effects/chapter-25-rendering-vector-art-gpu\n*\n* Designed to be as fast as possible\n* The space is transformed with a matrix so that an aligned quadratic (y=x^2) is rendered\n*\n* MIT License\n*/\nfloat pointRadius = 3.0;\n\n#define AA //comment out for jaggies\n\n//transform from 0->1 into -1->1 with inverted y so the per-pixel operation is as simple as possible\nconst mat3 normalisedSpace = mat3(\n   2.0, 0.0, -1.0,\n   0.0, -2.0, 1.0,\n   0.0, 0.0, 1.0\n);\n\nbool sampleCurve(in vec2 pos, in mat3 transform) {\n    vec3 uv = vec3(pos, 1.0) * transform;\n    //uv.xy /= uv.z; //not needed since no z transform\n    \n    return uv.y <= 1.0 && uv.x*uv.x < uv.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pixSize = 1.0 / max(iResolution.x, iResolution.y);\n    float halfPixSize = pixSize / 2.0;\n    \n    vec2 fragPos = fragCoord * pixSize;\n    \n    //bezier curve\n    vec2 a = vec2(100.0, 100.0) * pixSize;\n    vec2 b = (length(iMouse.xy) > 0.0 ? iMouse.xy : vec2(200.0, 300.0)) * pixSize;\n    vec2 c = vec2(400.0 + sin(iTime) * 100.0, 200.0 + cos(iTime) * 100.0) * pixSize;\n    \n    //determine the matrix vectors (only need to do once per curve not per-pixel)\n    vec2 right = c - a;\n    vec2 up = b - mix(a, c, 0.5);\n    vec2 pos = a;\n\n    mat3 transform = inverse(mat3(\n        right.x, up.x, pos.x,\n        right.y, up.y, pos.y,\n        0.0, 0.0, 1.0\n    )) * normalisedSpace;\n    \n    //draw points\n    float distToPoint = min(min(length(fragPos - a), length(fragPos - b)), length(fragPos - c));\n    \n    if (distToPoint < pointRadius * pixSize) {\n        fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n        return;\n    }\n    \n    //draw our curve - per pixel\n    #ifdef AA\n        //antialiasing - prob cheaper to just take multiple samples than use a distance function\n        float colour = (\n            float(sampleCurve(fragPos, transform)) +\n            float(sampleCurve(fragPos + vec2(0.0, halfPixSize), transform)) +\n            float(sampleCurve(fragPos + vec2(halfPixSize, 0.0), transform)) +\n            float(sampleCurve(fragPos + halfPixSize, transform))\n        ) / 4.0;\n    #else\n        float colour = float(sampleCurve(fragPos, transform));\n    #endif\n    \n    fragColor = vec4(colour, 0.0, 0.0, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}