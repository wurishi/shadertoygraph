{"ver":"0.1","info":{"id":"wdjfRm","date":"1589809993","viewed":301,"name":"Interactive Monte Carlo Pt.3","username":"fluxatron","description":"Pt.4 here: https://www.shadertoy.com/view/WsjfDz\nClick and drag to move cam.\n\nDepth of field with focus on the green ball.\n\nBased on Ray Tracing books by Peter Shirley","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","interactive","montecarlo","unbiased"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \nconst mat3 ACESInputMat  = mat3(0.59719, 0.07600, 0.02840,    0.35458, 0.90834, 0.13383,    0.04823,  0.01566, 0.83777);\nconst mat3 ACESOutputMat = mat3(1.60475,-0.10208,-0.00327,   -0.53108, 1.10813,-0.07276,   -0.07367, -0.00605, 1.07602);\nvec3 RRTAndODTFit(vec3 v) { return (v * (v + 0.0245786) - 0.000090537) / (v * (0.983729 * v + 0.4329510) + 0.238081); }\nvec3 ACESFitted(vec3 color) { return clamp(ACESOutputMat * RRTAndODTFit(ACESInputMat * color), 0.0, 1.0); }\n\nfloat DecodeFrame()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    vec3 col = texture(iChannel0, uv).rgb / float(DecodeFrame()+1.); // Divide accumulation buffer by num frames\n    col = ACESFitted(col);\n    col = pow(col, vec3(0.4545)); // Gamma 1/2.2\n   \t//col = vec3(0.2126*col.r + 0.7152*col.g + 0.0722*col.g); // Luminance\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define APERTURE 0.85     /* diameter of the lens */\n#define VERTICAL_FOV 35.  /* degrees */\n\n#define MAX_BOUNCES 7\n#define SAMPLES_PER_PIXEL 8\n\n\nconst int _numSpheres = 5;\nSphere[_numSpheres] _spheres;\nvoid InitScene()\n{\n    vec3 v = vec3(.15,.5,.85);\n    \n    _spheres[0].Center = vec3(-5.,2.,0);\n    _spheres[0].Radius = 2.;\n    _spheres[0].Mat.BaseColor = v.brr;\n    _spheres[0].Mat.IsMetal = true;\n    _spheres[0].Mat.Roughness = 0.1;\n    _spheres[0].Mat.Emissive = 0.;\n    \n\t_spheres[1].Center = vec3(0,2.,0);\n    _spheres[1].Radius = 2.;\n    _spheres[1].Mat.BaseColor = v.rbr;\n    _spheres[1].Mat.IsMetal = false;\n    _spheres[1].Mat.Roughness = 0.;\n    _spheres[1].Mat.Emissive = 0.;\n    \n    _spheres[2].Center = vec3(5.,2.,0);\n    _spheres[2].Radius = 2.;\n    _spheres[2].Mat.BaseColor = v.rrb;\n    _spheres[2].Mat.IsMetal = true;\n    _spheres[2].Mat.Roughness = 0.1;\n    _spheres[2].Mat.Emissive = 0.;\n    \n    // Ground\n\t_spheres[3].Center = vec3(0,-1000,0);\n    _spheres[3].Radius = 1000.;\n    _spheres[3].Mat.BaseColor = v.ggg;\n    _spheres[3].Mat.IsMetal = false;\n    _spheres[3].Mat.Roughness = 0.1;\n    _spheres[3].Mat.Emissive = 0.;\n    \n    // Light    \n\t_spheres[4].Center = vec3(10);\n    _spheres[4].Radius = 4.;\n    _spheres[4].Mat.BaseColor = vec3(1);\n    _spheres[4].Mat.IsMetal = false;\n    _spheres[4].Mat.Roughness = 0.;\n    _spheres[4].Mat.Emissive = 20.;\n}\n\n\n// OTHER //////////////////////////////////////////////////////////////////////////////////\n    \nvec4 EncodeNumFramesAccumulated(float frame)\n{\n    return vec4(frame,0,0,0);\n}\n\nfloat DecodeNumFramesAccumulated()\n{\n    return texelFetch(iChannel0, ivec2(0,0), 0).r;\n}\n\nmat3 ViewLookAtMatrix(vec3 eye, vec3 target, float roll)\n{\n\tvec3 rollVec = vec3(sin(roll), cos(roll), 0.);\n\tvec3 w = normalize(eye-target); // right handed TODO Change all math to left handed? \n\tvec3 u = normalize(cross(rollVec,w));\n\tvec3 v = normalize(cross(w,u));\n    return mat3(u, v, w);\n}\n      \n\n// SCENE //////////////////////////////////////////////////////////////////////////////////\n           \nbool HitSphere(Sphere sph, Ray ray, float tMin, float tMax, inout Hit outHit)\n{\n    vec3 oc = ray.Origin - sph.Center;\n    \n    float a = dot(ray.Dir, ray.Dir);\n    float half_b = dot(oc, ray.Dir);\n    float c = length2(oc) - sph.Radius*sph.Radius;\n    float discriminant = half_b*half_b - a*c;\n    \n    \n    if (discriminant > 0.) \n    {\n        float root = sqrt(discriminant);\n        float temp = (-half_b - root)/a;\n       \n        if (temp > tMin && temp < tMax) \n        {\n            outHit.LengthAlongRay = temp;\n            outHit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            outHit.Normal = (outHit.Pos - sph.Center) / sph.Radius;\n            outHit.Mat = sph.Mat;\n        \treturn true;\n        }\n        \n        temp = (-half_b + root)/a;\n        if (temp > tMin && temp < tMax)\n        { \n            outHit.LengthAlongRay = temp;\n            outHit.Pos = ray.Origin + ray.Dir*temp;\n            \n            //vec3 outwardNormal = (hit.Pos - sph.Center) / sph.Radius;\n            //hit.IsFrontFace = dot(outwardNormal, ray.Dir) < 0.;\n            //hit.Normal = hit.IsFrontFace ? outwardNormal : -outwardNormal;\n            outHit.Normal = (outHit.Pos - sph.Center) / sph.Radius;\n            outHit.Mat = sph.Mat;\n        \treturn true;\n        }\n    }\n    \n    return false;\n}\n\nbool FindClosestHit(Ray ray, inout Hit outHit)\n{\n    float tMin = 0.0001;\n    float closestSoFar = BIG_FLOAT;\n    \n    bool hitAnything = false;\n\n    Hit tempHit;\n    for (int i = 0; i < _numSpheres; i++)\n    {\n        Sphere sph = _spheres[i];\n        if (HitSphere(sph, ray, tMin, closestSoFar, tempHit))\n        {\n\t\t\thitAnything = true;\n            closestSoFar = tempHit.LengthAlongRay;\n            outHit = tempHit;\n        }\n    }\n    \n    return hitAnything;\n}\n\nvec3 Color(Ray ray, vec2 uv, float seed)\n{\n    const float epsilon = 0.001;\n    \n\tvec3 attenuation = vec3(1);\n    Hit hit;\n    \n    \n    // Goals. \n    // 1. Irradiance (contribution of light from all directions multiplied by Albedo)\n    // 2. Specular BRDF (specular reflection.. revise)\n    \n    // Dielectrics = Irradiance + Specular\n    // Metals = Specular\n    \n    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++)\n    {\n        //float power = 1. / pow(2., float(bounce)); // 1, 0.5, 0.25, 0.125, etc...\n        \n\t\tif (FindClosestHit(ray, hit))\n        {\n            if (hit.Mat.Emissive > epsilon)\n            {\n                \n            \tattenuation *= vec3(hit.Mat.Emissive);\n                return attenuation;\n            }\n            \n            // Update the ray for next bounch\n        \tray.Origin = hit.Pos + hit.Normal * epsilon; // Slightly off the hit surface\n            float raySeed = seed + 7.1*float(iFrame) + 5681.123 + float(bounce)*92.13;\n        \t\n         \n           \t\n            float roughness = hit.Mat.Roughness;\n            bool isMetal = hit.Mat.IsMetal;\n            \n            if (isMetal)\n            {\n                ray.Dir = reflect(ray.Dir, hit.Normal) + roughness*RandomInUnitSphere(raySeed+17.1321);\n            }\n            else // lambertian\n            {\n                ray.Dir = hit.Normal + RandomUnitVector(raySeed);\n            }\n            \n            ray.Dir = normalize(ray.Dir); // not 100% if i need to normalize for correct results, but it gives me peace of mind for now.\n            \n            attenuation *= hit.Mat.BaseColor;\n        }\n        else\n        {\n            // Sky colour and leave\n            attenuation *= .02*mix(vec3(1.), vec3(.5,.7,1.), 0.5*uv.y + .5);\n            //attenuation *= vec3(0.0);\n            break;\n        }\n    }\n    \n    return attenuation;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    //vec2 uv = (2.*(fragCoord) - iResolution.xy) / iResolution.yy; // -(aspect,1) -> (aspect,1)\n    vec2 uvNorm = (fragCoord) / iResolution.xy;                     //       (0,0) -> (1,1)\n\tvec2 m = iMouse.xy == vec2(0) \n        ? vec2(0.25,0) // Put default cam somewhere perdy\n        : (2.*iMouse.xy - iResolution.xy) / iResolution.yy;         // -(aspect,1) -> (aspect,1)\n    \n    \n    vec3 oldCol = vec3(0);\n    \n    // HandleState\n    {\n        float numFramesAccumulated = DecodeNumFramesAccumulated();\n        oldCol = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;       \n        \n        if(iFrame == 0 || numFramesAccumulated < 1.) \n        {\n            oldCol = vec3(0,0,0);\n        }\n\n        // Track accumulated frames\n        if (ivec2(fragCoord) == ivec2(0,0))\n        {\n            numFramesAccumulated++;\n\n             // Get mouse state\n            bool mousePressed = iMouse.z > 0.0;\n            if (mousePressed)\n            {\n            \tnumFramesAccumulated = 0.;\n            }\n\n            fragColor = EncodeNumFramesAccumulated(numFramesAccumulated);\n            return;\n        }\n    }\n \n    \n    \n    InitScene();\n    \n    vec3 newCol = vec3(0);\n    for (int sampleId = 0; sampleId < SAMPLES_PER_PIXEL; sampleId++)\n    {\n    \tfloat seed = hash11( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*hash11(float(iFrame*sampleId)) );\n    \n        // Camera ray\n        Ray ray;\n        {\n            // Define controls\n            vec3 camPos = 16. * vec3(sin(-m.x*PI), smoothstep(0.,2.,clamp(2.*m.y + 1.,.2,2.)), cos(m.x*PI));\n            vec3 camTarget = vec3(0,1,0);\n\n            \n            // Computed bits\n            float focalDist = length(camTarget - camPos);\n          \n           \t\t\n            // Compute ray at origin from lens\n            vec3 rayStart = APERTURE * 0.5 * vec3(RandomInUnitCircle(seed + 84.123), 0.);\n            vec3 lensRay;\n            {\n                // Sub pixel offset\n                vec2 pixelOffset = hash21(seed+13.271) / iResolution.xy;\n                float s = uvNorm.x + pixelOffset.x;\n                float t = uvNorm.y + pixelOffset.y;\n\n                // calc Point in target image plane\n                float vertical = focalDist* 2.*tan(radians(VERTICAL_FOV/2.));\n                float horizontal = vertical*aspect;\n                vec3 lowerLeftCorner = -vec3(horizontal/2., vertical/2., focalDist);\n                vec3 rayEnd = lowerLeftCorner + vec3(s*horizontal, t*vertical, 0.);\n                \n                lensRay = normalize(rayEnd - rayStart);\n            }\n\n            // Aim the camera\n            mat3 viewMat = ViewLookAtMatrix(camPos, camTarget, 0.);\n            ray.Origin = camPos + viewMat * rayStart;\n            ray.Dir = viewMat * lensRay;\n        }\n\n    \tnewCol += Color(ray, uvNorm, seed);\n    }\n    newCol /= float(SAMPLES_PER_PIXEL);\n    \n    \n    fragColor = vec4(oldCol + newCol, 1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define BIG_FLOAT 9999999.\n#define PI 3.1415926\n#define TAU 6.2831853\n\n// TYPES //////////////////////////////////////////////////////////////////////////////////\n\nstruct Material\n{\n    vec3 BaseColor; // IsMetal ? Reflectance : Albedo\n\tbool IsMetal;\n    float Roughness;\n    float Emissive;\n};\nstruct Sphere\n{\n    vec3 Center;\n    float Radius;\n    Material Mat;\n};\nstruct Ray \n{\n    vec3 Origin;\n    vec3 Dir;\n};\nstruct Hit \n{\n    vec3 Pos; // point in space\n    vec3 Normal; // normal of hit surface\n    float LengthAlongRay; // length along ray of hit\n   //bool IsFrontFace; // whether we hit the outside or inside of the surface\n    //int MatId;\n    Material Mat;\n    //bool IsMetal;\n    //bool BaseColor; // IsMetal ? Reflectance : Albedo\n};\n    \n    \nfloat length2(vec2 v) { return dot(v,v); }\nfloat length2(vec3 v) { return dot(v,v); }\n    \n\n// RANDOM /////////////////////////////////////////////////////////////////////////////////\n\n// 1 out, 1 in... https://www.shadertoy.com/view/4djSRW\nfloat hash11(float seed)\n{\n    seed = fract(seed * .1031);\n    seed *= seed + 33.33;\n    seed *= seed + seed;\n    return fract(seed);\n}\n//  1 out, 2 in...  https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 seed)\n{\n\tvec3 p3  = fract(vec3(seed.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// 2 out, 1 in... https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float seed)\n{\n\tvec3 p3 = fract(vec3(seed) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 RandomUnitVector(float seed) \n{\n    vec2 rand = hash21(seed);\n    float a = rand.x*TAU;     //  0 to TAU\n    float z = rand.y*2. - 1.; // -1 to 1\n    float r = sqrt(1. - z*z);\n    return vec3(r*cos(a), r*sin(a), z);\n}\n\nvec3 RandomInUnitSphere(float seed)\n{\n    vec3 hash = hash31(seed);\n    \n    float theta = hash.x * TAU;\n    float v = hash.y;\n    float r = pow(hash.z, 0.333333);\n    \n    float phi = acos((2.*v)-1.);\n    float sinphi = sin(phi);\n    \n    vec3 p;\n    p.x = r * sinphi * cos(theta);\n    p.y = r * sinphi * sin(theta);\n    p.z = r * cos(phi); \n    \n    return p;\n}\n\nvec3 RandomInHemisphere(float seed, vec3 normal) \n{\n    vec3 p = RandomInUnitSphere(seed);\n    return (dot(p, normal) > 0.0) ? p : -p;\n}\n\nvec2 RandomInUnitCircle(float seed)\n{\n    // https://programming.guide/random-point-within-circle.html\n    vec2 rand = hash21(seed);\n    float angle = rand.x*TAU;\n    float radius = sqrt(rand.y);\n    return radius * vec2(cos(angle), sin(angle));\n}\n\n\n","name":"Common","description":"","type":"common"}]}