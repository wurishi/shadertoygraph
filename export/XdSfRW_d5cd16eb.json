{"ver":"0.1","info":{"id":"XdSfRW","date":"1667688138","viewed":163,"name":"Loading icon","username":"niaroyn","description":"Idea from https://www.reddit.com/r/oddlysatisfying/comments/6b1mro/a_loading_gif_animation_i_made/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["abstract","loading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 start[] = vec2[](\n    vec2(1, 1),\n    vec2(0, 1),\n    vec2(0, 0),\n    vec2(1, 0),\n    vec2(2, 0),\n    vec2(2, 1),\n    vec2(2, 2),\n    vec2(1, 2)\n);\n\n/*\nfloat smootherstep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n    return x*x*x*(x*(x*6.f - 15.f) + 10.f);\n}\n\nfloat ssmootherstep(float edge0, float edge1, float x)\n{\n    x = clamp((x - edge0)/(edge1 - edge0), 0.0, 1.0);\n    return x*x*x*x*(x*(x*(x* (-20.f) + 70.) - 84.f) + 35.f);\n}\n*/\n\nfloat msmoothstep(float a, float b, float x)\n{\n    float r = 40.f;\n    float c = (a + b)/2.f;\n  //  a = 0.f;\n  //  b = 1.f;\n    return ((0.f * exp(c * r)) + (1.f * exp(r * x))) / (exp(c * r) + exp(r * x));\n}\n\n\nfloat f(float t, float i, out int off)\n{\n    float diff = 1.5f;\n    \n    off = 1;\n    if(i == 0.f && t > ((7. - diff) / 8.f)) {\n        off = 2;\n        return msmoothstep((7. - diff) / 8.f, (7. + diff) / 8.f, t);\n    } else if(i == 1.f && t > ((8. - diff) / 8.f)) {\n        off = 2;\n        return msmoothstep((8. - diff) / 8.f, (8. + diff) / 8.f, t);\n    }\n\n    float low = (i - diff) / 8.f;\n    float high = (i + diff) / 8.f;\n    return msmoothstep(low, high, t);\n}\n\nfloat insideBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\n    vec2 s = step(bottomLeft, v) - step(topRight, v);\n    return s.x * s.y;\n}\n\nfloat roundedRectangle(vec2 uv, vec2 pos, vec2 size, float radius, float t)\n{\n  float d = length(max(abs(uv - pos),size) - size) - radius;\n  return smoothstep(0.66, 0.33, d / t * 5.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    float s = sin(-3.141 / 4.f);\n  \tfloat c = cos(-3.141 / 4.f);\n\n \tuv.x = uv.x * c - uv.y * s;\n\tuv.y = uv.x * s + uv.y * c;\n    uv.y = -uv.y;\n\n    uv *= 4.f;\n\n  \tfloat aspect = iResolution.x / iResolution.y;\n  \tvec2 ratio = vec2(aspect + .5, 1.0);\n  \tuv = (2.0 * uv - 1.0) * (1.f / ratio);\n\n    float v = 0.f;\n    float t = (mod(iTime, 1.5f)) / 1.5f;\n    for(int i = 0; i < 7; ++i) {\n        int off = 0;\n        float fac = f(t, float(i), off);\n        int next = (i + 8 - off) % 8;\n        int curr = (i + 8 - off + 1) % 8;\n        vec2 pos = ((1.f - fac) * start[curr] + fac * start[next]) / 3.f;\n        pos = 2.f * pos;\n        pos.y = pos.y - .45f;\n        pos.x = pos.x + 1.15f;\n    \tv += roundedRectangle(uv, pos, vec2(.285, .285), 0.01, 0.2);\n\n        if(v > 0.f)\n            break;\n\n    }\n    /*\n    float col2 = 0.3+0.6*cos(iTime) * cos(uv.y);\n    float col1 = 0.3+0.6*sin(iTime) * sin(uv.x);\n    float col3 = 0.6f;\n    float fac = v;\n    fragColor = vec4(fac * col1, fac * col2, fac * col3, 1.f);\n    fragColor += (1.f - fac) * vec4(1.f, 1.f, 1.f,1.f);\n*/\n\t// or\n\n\tfloat col2 = 0.5+0.3*cos(iTime * 0.3422f) * cos(uv.y);\n   float col1 = 0.5+0.5*sin(iTime) * sin(uv.x);\n   float col3 = 0.6f;\n   float fac = v;\n   fragColor = vec4(fac * col1, fac * col2, fac * col3, 1.f);\n   fragColor += (1.f - fac) * vec4(1.f, 1.f, 1.f,1.f);\n\n}\n","name":"Image","description":"","type":"image"}]}