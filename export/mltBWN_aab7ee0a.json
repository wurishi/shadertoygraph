{"ver":"0.1","info":{"id":"mltBWN","date":"1701629658","viewed":114,"name":"Comparing Curve AA ","username":"Seebone","description":"Difference ways of interpolating. Just experimenting, I have no idea what Iâ€™m doing so suggestions are welcome : )","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["aa","implicit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I'm a shader programming noob, so whatever I'm doing is probably wrong in some way.\n\n// Trying to interpolate the curve color in a way that makes the curve edge seem sharp without aliasing.\n// Making something that works for arbitrary curve widths is challenging (to me).\n// Thanks for the suggestions by Fabrice and spalmer!\n\n/* Viewport parameters */\n// The distance from the left to the right of the viewport\n#define WIDTH 4.\n// Animated width:\n// #define WIDTH (smp(iTime, 3., 8., 8., .1))\n// Coordinates at center of viewport\n#define CENTER vec2(0.)\n\n/* Curve parameters */\n// Curve color\n#define CURVE_COL (vec3(0.000,0.000,0.000))\n// Target curve width in pixels:\n#define CWP smp(iTime, 1., iResolution.y*.08, 20., .1)\n\n// Fade distance in pixels \n#define AA_DIST 1.5\n\n// Macro (assumes WIDTH is availible):\n#define LAA(dist, curveWidthP, aaWidthP) (clamp(.5 + (dist*iResolution.x/WIDTH - .5*curveWidthP)/aaWidthP, 0., 1.))\n\n// https://www.desmos.com/calculator/udnerpr09b\nfloat smp(float x, float yMin, float yMax, float period, float L) {\n    period = abs(period)*.5;\n    L = clamp(L, 0., 1.)*period;\n    // Function\n    x += .5*L;\n    bool a = mod(x,2.*period) >= period;\n    x = (a ? 1. : -1.)*smoothstep(L, period, mod(x, period)) + (a ? 0. : 1.);\n    \n    //shifting\n    return yMin + (yMax - yMin)*x;\n}\n\nfloat dist(vec2 p) {\n    //return abs( distance(vec2(0.), vec2(p)) - 1. );\n    \n    return abs( abs(mod(distance(vec2(0.), vec2(p)), .2) - .1) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalizes x-distance to 1 while keeping aspect ratio and shifting so that (0,0) is at center of viewport.\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.x;\n    \n    float PW = WIDTH/iResolution.x; // width of a pixel in viewport coordinates\n    float CW = CWP*PW; // curve width in viewport coordinates\n\n    // transforming to correct size and position\n    uv *= WIDTH;\n    uv += CENTER;\n\n    // Drawing background \n    vec3 col = vec3(1.);\n    \n    \n    if (fragCoord.x > iResolution.x*.5) {\n        /* Right Side */\n        \n        // By spalmer (adjusted linear):\n        // col = mix(CURVE_COL, col, clamp(.5 + (dist(uv) - .5*CW)/(AA_DIST*PW), 0., 1.));\n        // Equivalent:\n        // col = mix(CURVE_COL, col, clamp(.5 + (dist(uv)*iResolution.x/WIDTH - .5*CWP)/AA_DIST, 0., 1.));\n        // Using macro:\n        // col = mix(CURVE_COL, col, LAA(dist(uv), CWP, AA_DIST));\n        // To not have entire curve be faded for small widths:\n        col = mix(CURVE_COL, col, clamp(.5 + (dist(uv) - .5*CW)/min(AA_DIST*PW, .5*CW), 0., 1.));\n\n        // By FabriceNeyret2 (good) (same as spalmer but with smoothstep):\n        // col = mix(CURVE_COL, col, smoothstep( -.5*PW, .5*PW, dist(uv) - .5*CW));\n\n        // Below are methods that don't work (just as examples of why this is a 'problem')\n        \n        // Simple smoothstep (bad):\n        // col = mix(CURVE_COL, col, smoothstep(0.2*CW, .5*CW, dist(uv)));\n\n        // Linear (really bad):\n        // col = mix(CURVE_COL, col, clamp(dist(uv)/(.5*CW), 0., 1.));\n                \n        // Power (bad):\n        // col = mix(CURVE_COL, col, clamp( pow(dist(uv)/(.5*CW), 20.), 0., 1.));\n\n        // Boolean (not even AA, just for comparing):\n        // col = dist(uv) <= .5*CW ? CURVE_COL : col;\n    } else {\n        /* Left side */\n        col = dist(uv) <= .5*CW ? CURVE_COL : col;\n\n    }\n    \n    // Dividing line\n    col = abs(fragCoord.x - .5*iResolution.x) <= 1. ? vec3(1.,0.,0.) : col;\n    \n    // Gamma correction?\n    col = pow(col, vec3(0.4545));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}