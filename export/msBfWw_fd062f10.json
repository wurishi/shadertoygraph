{"ver":"0.1","info":{"id":"msBfWw","date":"1690054722","viewed":8,"name":"RayTracing Template v2","username":"alejoXD","description":"Second Template","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raycast"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.283185\n#define PI 3.141592\n\nfloat doModel( vec3 p ) //SDF Sphere\n{\n\n    float s = 1.;\n\n    p = abs(p);\n    return (p.x+p.y+p.z-s)*0.57735027;\n\n    return min( min( length(p.xyz)-1.0, length(p.xy)-0.2 ),\n                min( length(p.yz )-0.2, length(p.zx)-0.2 ) );\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 finalColor = vec3(.0,.0,.0);\n    if(nor.y >= 0.5){finalColor += vec3(1.000,0.439,0.722);}\n    \n    if(nor.y < 0.5){finalColor += vec3(0.302,0.663,0.996);}\n    \n    return finalColor;\n    \n    //return vec3(0.224,0.796,0.835); //Devuelve un color plano de momento\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // key light\n    //-----------------------------\n    vec3  lig = normalize(vec3(1.0,0.5,1.3)); //Dirección de la luz\n    float dif = max(dot(nor,lig),0.0);\n    lin += dif*vec3(0.910,0.910,0.910); //Color de la luz\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(0.30,0.30,0.30); //Color de la ambient light\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n    \n    // fog    \n    //-----------------------------\n\tcol *= exp(-0.01*dis*dis);\n\n    return col;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c); //Función de rotacíon de cámara\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar)\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float an = 0.3 *iTime;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n    \n    camPos.yz *= Rot(-m.y * PI+1.);\n    camPos.xz *= Rot(-m.x * TAU); //Rotación con el ratón hand-made\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0); //Color Background\n}\n\n//------------------------------------------------\n\nvec3 compute_normal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat intersect( in vec3 ro, in vec3 rd ) //Realiza el RayMarching\n{\n\tconst float maxd = 20.0; //Máxima distancia           \n    float t = 0.0; //Distancia\n    for( int i=0; i<128; i++ )          // max number of raymarching iterations is 90\n    {\n\t    float d = doModel( ro+rd*t );\n        if( d<0.001 || t>maxd ) break;  // precision 0.001, maximum distance 20\n        t += d;\n    }\n    return (t<maxd) ? t : -1.0;\n}\n\nvec3 color( in vec2 uv )\n{\n    // camera movement (ro is ray origin, ta is the target location we are looking at)\n    vec3 ro, ta; \n    doCamera( ro, ta);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    mat3 camMat = mat3( uu, vv, ww ); //Matriz de cámara\n    \n\t// create ray\n\tvec3 rd = normalize( camMat * vec3(uv,2.0) ); // 2.0 is the lens length\n\n    // compute background\n\tvec3 col = doBackground();\n\n\t// project/intersect through raymarching of SDFs\n    float t = intersect( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd; //Origen del rayo + distancia * dirección\n        vec3 nor = compute_normal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        // lighting\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n    // monitor gamma adjustnment\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    fragColor = vec4( color(uv), 1.0 );\n}","name":"Image","description":"","type":"image"}]}