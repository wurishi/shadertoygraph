{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// With the following it is the code ideas that were important to me, not the visual results\n\nconst vec2 corner = vec2(0.0, 0.0);\nconst float pi2 = 6.28318530718;\n\n// thanks stackoverflow for this function\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 get_uv()\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.y = 1.0 - uv.y;\n\treturn uv;\n}\n\nvec2 get_uv_mouse()\n{\n\treturn iMouse.xy / iResolution.xy;\n}\n\nfloat position()\n{\n\treturn distance(get_uv(),corner);\n}\n\n// mease angle of current fragment relative to specified point\nfloat theta(vec2 pt)\n{\n\tvec2 uv = get_uv() - pt;\n\treturn uv.x == 0.0 ? 0.0 : atan(uv.y, uv.x);\n}\n\n//rescales and translates one range of values to another\nfloat refit(float beg, float end, float minX, float maxX, float value)\n{\n\treturn beg + (end - beg) * ((value - minX) / (maxX - minX));\n}\n\nfloat sawwave(float hertz)\n{\n\treturn fract(iTime * hertz);\n}\n\nfloat trianglewave(float hertz)\n{\n\treturn abs(sawwave(hertz) * 2.0 - 1.0);\n}\n\nfloat sinwave(float hertz)\n{\n\treturn (sin(fract(iTime * hertz) * pi2) + 1.0) / 2.0;\n}\n\nfloat coswave(float hertz)\n{\n\treturn (cos(fract(iTime * hertz) * pi2) + 1.0) / 2.0;\n}\n\nfloat squarewave(float hertz)\n{\n\treturn floor(fract(iTime * hertz) + 0.5);\n}\n\nfloat noise()\n{\n\tvec2 uv = get_uv();\n\treturn rand(vec2(iTime + uv.x,uv.y));\n}\n\n\nvec4 red(float value)\n{\n\treturn vec4(value, 0.0, 0.0, 1.0);\n}\n\nvec4 green(float value)\n{\n\treturn vec4(0.0, value, 0.0, 1.0);\n}\n\nvec4 blue(float value)\n{\n\treturn vec4(0.0, 0.0, value, 1.0);\n}\n\nvec4 blend(vec4 a, vec4 b)\n{\n\treturn vec4((a.x + b.x) / 2.0, (a.y + b.y) / 2.0, (a.z + b.z) / 2.0, 1.0); \n}\n\n\nvec4 colorCircle(vec3 circle, vec4 exteriorColor, vec4 interiorColor)\n{\n\tvec2 uv = get_uv();\n\tvec4 color = distance(circle.xy,uv) < circle.z ? interiorColor : exteriorColor;\n\tfragColor = color;\n\treturn color; // returning the color lets you compose calls to colorCircle, hence the neat effects of \"nested circles\"\n}\n\nvec4 colorBox(vec2 a, vec2 b, vec4 exteriorColor, vec4 interiorColor)\n{\n\tvec2 uv = get_uv();\n\tbool inBox = max(a.x,b.x) >= uv.x && min(a.x,b.x) <= uv.x && max(a.y,b.y) >= uv.y && min(a.y,b.y) <= uv.y;\n\tvec4 color = inBox ? interiorColor : exteriorColor;\n\tfragColor = color;\n\treturn color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tcolorCircle(vec3(trianglewave(0.1), sawwave(0.1), trianglewave(0.1)), red(noise()), \n\t\t\t   colorCircle(vec3(trianglewave(0.2), sawwave(0.2), sinwave(0.2)), green(trianglewave(0.5)), \n\t\t\t\t\t\t  colorCircle(vec3(trianglewave(0.3), sawwave(0.3), sinwave(0.3)), blue(noise()), red(squarewave(1.0)))));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4d2Gz1","date":"1383804915","viewed":197,"name":"composable functions","username":"kp1197","description":"my beginner's attempt to see how different kinds of functions can fit together for interesting behavior, trying to build some kind of  a library up to increase the 'expressiveness' of the GLSL, in kind of a functional way.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["framework","functional"],"hasliked":0,"parentid":"","parentname":""}}