{"ver":"0.1","info":{"id":"XdyfR1","date":"1527556761","viewed":797,"name":"Undah Da Sea","username":"jgkling","description":"waow","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","terrain","water","ocean","godrays","underwater"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Various parameters\n#define GOD_RAY_LENGTH 1.1 // higher number = shorter rays\n#define GOD_RAY_FREQUENCY 28.0\n\n// Raymarching\n#define MAX_ITERS 220.0\n#define T_MAX 60.0\n\n#define NUM_OCTAVES 2 // for noise\n\nfloat GodRays(  in vec2 ndc, in vec2 uv) {\n    vec2 godRayOrigin = ndc + vec2(-1.15, -1.25);\n    float rayInputFunc = atan(godRayOrigin.y, godRayOrigin.x) * 0.63661977236; // that's 2/pi\n    float light = (sin(rayInputFunc * GOD_RAY_FREQUENCY + iTime * -2.25) * 0.5 + 0.5);\n    light = 0.5 * (light + (sin(rayInputFunc * 13.0 + iTime) * 0.5 + 0.5));\n    //light *= (sin(rayUVFunc * 8.0 + -iTime * 0.25) * 0.5 + 0.5);\n    light *= pow(clamp(dot(normalize(-godRayOrigin), normalize(ndc - godRayOrigin)), 0.0, 1.0), 2.5);\n    light *= pow(uv.y, GOD_RAY_LENGTH);\n    light = pow(light, 1.75);\n    return light;\n}\n\n// 2D Noise from IQ\nfloat Noise2D( in vec2 x ) {\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel0, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel0, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel0, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel0, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat ComputeFBM( in vec2 pos ) {\n    float amplitude = 1.0;\n    float sum = 0.0;\n    float maxAmp = 0.0;\n    for(int i = 0; i < NUM_OCTAVES; ++i) {\n        sum += Noise2D(pos) * amplitude;\n        maxAmp += amplitude;\n        amplitude *= 3.0;\n        pos *= 0.7;\n    }\n    return sum / maxAmp;\n}\n\nfloat SceneMap( in vec3 pos ) {\n    return pos.y - 3.0 * ComputeFBM(pos.xz * 0.2);\n}\n\nvec3 ComputeNormal( in vec3 pos ) {\n    vec2 epsilon = vec2(0.0, 0.001);\n    float mapVal = SceneMap(pos);\n    return normalize( vec3( SceneMap(pos + epsilon.yxx) - mapVal,\n                            epsilon.y,\n                            SceneMap(pos + epsilon.xxy) - mapVal));\n}\n\n// From: https://iquilezles.org/articles/terrainmarching\nvec3 RaymarchScene( in vec3 origin, in vec3 dir ) {\n    float distance, t, dt;\n    float hitSomething, numIters = 0.0;\n    float lastPosY, lastHeight;\n    vec3 pos;\n    \n    for(t = 0.01; t < T_MAX && numIters < MAX_ITERS; t += dt) {\n        pos = origin + t * dir;\n        distance = SceneMap(pos);\n        \n        if(distance < (0.0001 * t)) {\n            hitSomething = 1.0;\n            break;\n        }\n        \n        numIters += 1.0;\n        dt = 0.05 * t;\n        lastPosY = pos.y;\n        lastHeight = distance + lastPosY;\n    }\n    return vec3(t - dt + dt * (lastHeight - lastPosY) / (pos.y - lastPosY - (distance + pos.y) + lastHeight), hitSomething, numIters);\n}\n\nvec3 CastRay( in vec2 sp, in vec3 origin ) {\n    // Compute local camera vectors\n    vec3 refPoint = vec3(origin.x, 10.0, origin.z + 1.0);\n    vec3 camLook = normalize(refPoint - origin);\n    vec3 camRight = normalize(cross(camLook, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camLook));\n    \n    vec3 rayPoint = origin + camLook + sp.x * camRight + sp.y * camUp;\n    return normalize(rayPoint - origin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // God rays\n    float godRay = GodRays(ndc, uv);\n    \n    vec3 waterColor = mix(vec3(0.2, 1.5, 0.7), vec3(0.2, 0.4, 0.9) * 0.5, pow(clamp(0.25 * (ndc.x * ndc.x * 0.2 - ndc.y + 1.5), 0.0, 1.0), 0.15));\n    vec3 lightColor = mix(vec3(0.5, 1.0, 0.8), vec3(0.55, 0.55, 0.95) * 0.95, 1.0 - uv.y);\n    vec3 finalColor = waterColor;\n    \n    // Raymarching\n    vec3 rayOrigin = vec3(0.0, 10.0, -1.0);\n    rayOrigin += vec3(-iTime, 0.0, 0.0);\n    vec3 rayDirection = CastRay(ndc, rayOrigin);\n    vec3 result = RaymarchScene(rayOrigin, rayDirection);\n    \n    if(result.y > 0.0) {\n        vec3 isectPos = rayOrigin + result.x * rayDirection;\n        vec3 normal = ComputeNormal(isectPos);\n        finalColor = vec3(0.5, 0.5, 0.25) * 2.75 * dot(normal, normalize(vec3(1.0, 1.0, 1.0)));\n    }/* else {\n        finalColor = vec4(finalColor, 1.0);\n    }*/ // stuff if we miss\n    \n    // To add:\n    // bubbles? probably screen space aligned\n    // coral/algae/plants\n    // caustics on ground: https://developer.nvidia.com/gpugems/GPUGems/gpugems_ch02.html\n    // better sand texture\n    // try tonemapping again? http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    \n    // Simple distance fog\n    float fogAmount = 1.0 - exp(-result.x * 0.05);\n    finalColor = mix(finalColor, waterColor * 0.8, fogAmount);\n    \n    finalColor = mix(finalColor, lightColor, (godRay + 0.05)/1.05);\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}