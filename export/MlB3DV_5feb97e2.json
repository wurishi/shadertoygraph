{"ver":"0.1","info":{"id":"MlB3DV","date":"1432464840","viewed":2422,"name":"PBR_Test","username":"2v_S","description":"Physically Based Rendering Test\n","likes":56,"published":1,"flags":0,"usePreview":0,"tags":["pbr","ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/*\n* References : \n*\n* http://renderwonk.com/publications/s2010-shading-course/hoffman/s2010_physically_based_shading_hoffman_b_notes.pdf\n* \n* http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\n*\n* http://graphicrants.blogspot.fr/2013/08/specular-brdf-reference.html\n*\n* http://www.filmicworlds.com/2014/04/21/optimizing-ggx-shaders-with-dotlh/\n*\n* http://blog.selfshadow.com/publications/s2013-shading-course/#course_content\n*\n*\tRay marching code from iq\n*/\n\n\n#define NB_LIGHTS 3\n\n// Metals values in linear space\n#define GOLD vec3(1.0, 0.71, 0.29)\n#define COPPER vec3(0.95, 0.64, 0.54)\n#define IRON vec3(0.56, 0.57, 0.58)\n#define ALUMINIUM vec3(0.91, 0.92, 0.92)\n#define SILVER vec3(0.95, 0.93, 0.88)\n\n\n\nfloat fPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat fSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n// ---- Scene definition\nvec2 fScene(vec3 p) {\n    \n    vec3 pSphere = p/*opRep(p, vec3( 2.0, 0.0, 2.0))*/;\n    \n \tvec2 sphere0 = vec2(fSphere(p, 1.0), 0.5); \t\n    vec2 sphere1 = vec2(fSphere(p+vec3(2.1, 0.0, 2.0), 1.0), 2.5);\n\tvec2 sphere2 = vec2(fSphere(p+vec3(-2.1, 0.0, 2.0), 1.0), 3.5);\n    vec2 sphere3 = vec2(fSphere(p+vec3(2.1, 0.0, -2.0), 1.0), 4.5);\n    vec2 sphere4 = vec2(fSphere(p+vec3(-2.1, 0.0, -2.0), 1.0), 5.5);\n\t\n\n\n    vec2 plane = vec2(fPlane(p, vec4(0, 1, 0, 1.0)), 1.5);\n    \n    return opU(opU(opU(opU(opU(plane, sphere0), sphere1), sphere2), sphere3), sphere4);\n}\n// -----\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n    \n    \n\tfloat precis = 0.00001;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = fScene( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = fScene( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    fScene(pos+eps.xyy).x - fScene(pos-eps.xyy).x,\n\t    fScene(pos+eps.yxy).x - fScene(pos-eps.yxy).x,\n\t    fScene(pos+eps.yyx).x - fScene(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nstruct Light {\n \tvec3 pos;\n    vec3 color;\n};\nLight lights[NB_LIGHTS];\n\n\nfloat G1V ( float dotNV, float k ) {\n\treturn 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nvec3 computePBRLighting ( in Light light, in vec3 position, in vec3 N, in vec3 V, in vec3 albedo, in float roughness, in vec3 F0 ) {\n\n\tfloat alpha = roughness*roughness;\n\tvec3 L = normalize(light.pos.xyz - position);\n\tvec3 H = normalize (V + L);\n\n\tfloat dotNL = clamp (dot (N, L), 0.0, 1.0);\n\tfloat dotNV = clamp (dot (N, V), 0.0, 1.0);\n\tfloat dotNH = clamp (dot (N, H), 0.0, 1.0);\n\tfloat dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n\tfloat D, vis;\n\tvec3 F;\n\n\t// NDF : GGX\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.1415926535;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr / (pi * denom * denom);\n\n\t// Fresnel (Schlick)\n\tfloat dotLH5 = pow (1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\t// Visibility term (G) : Smith with Schlick's approximation\n\tfloat k = alpha / 2.0;\n\tvis = G1V (dotNL, k) * G1V (dotNV, k);\n\n\tvec3 specular = /*dotNL **/ D * F * vis;\n\n\tvec3 ambient = vec3(.01);\n\n\tfloat invPi = 0.31830988618;\n\tvec3 diffuse = (albedo * invPi);\n\n\n\treturn ambient + (diffuse + specular) * light.color.xyz * dotNL ;\n}\n\nvec3 addPBR( in vec3 position, in vec3 N, in vec3 V, in vec3 baseColor, in float metalMask, in float smoothness, in float reflectance) {\n\tvec3 color = vec3(0.0);\n\n    float roughness = 1.0 - smoothness*smoothness;\n    vec3 F0 = 0.16*reflectance*reflectance * (1.0-metalMask) + baseColor*metalMask;\n    vec3 albedo = baseColor;\n    \n    float s = 0.0;\n    \n    \n\tfor ( int i = 0; i < NB_LIGHTS; ++i ) {\n\t\tvec3 col = computePBRLighting ( lights[i], position, N, V, albedo, roughness, F0);\n\t\tcolor += col;\t\n        s += softshadow( position, normalize(lights[i].pos.xyz - position), 0.02, 2.5 );\n\t}\n\n\treturn color*s;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0)*8.0; // Sky color\n    \n    vec2 res = castRay( ro, rd );\n    float t = res.x;\n    float m = res.y;\n    vec3 p = ro + t*rd;\n    \n    if(m>-0.5) { // Intersection found\n        if( m < 1.0 ) {\n           // float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.6,sin(16.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*sur, sur.x, 0.3+0.6*sur.x, 0.5 );\n        } \n        else if( m < 2.0 ) {\n            float f = mod( floor( 5.0*p.z ) + floor( 5.0*p.x ), 2.0 );\n            col = addPBR(p, calcNormal( p ), -rd, vec3(0.5), 0.0, 0.3+0.6*f, 0.5 );\n        }\n        else if( m < 3.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, COPPER*sur, sur.x, 0.3+0.6*sur.x, 0.5 );\n        }\n        else if( m < 4.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.0995,sin(106.0*p.x))*smoothstep(-1.0,-0.9,sin(47.0*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, vec3(0.2), 1.0-sur.x, 0.9*sur.x, 0.5 );\n        }\n        else if( m < 5.0 ) {\n            vec3 sur = vec3(1.0)*smoothstep(-1.0,-0.765,sin(24.0*p.x))*smoothstep(-1.0,-0.4,sin(70.9*p.z));\n            col = addPBR( p, calcNormal( p ), -rd, GOLD*(1.0-sur), sur.x, 0.3+0.6*sur.x, 0.5 );\n        }\n        else if( m < 6.0 ) {\n            vec3 sur = vec3(1.0,1.0,1.0)*smoothstep(-1.0,-0.4,sin(18.0*p.x));\n            col = addPBR( p, calcNormal( p ), -rd, ALUMINIUM*sur, sur.x, 0.3+0.6*sur.x, 0.5 );\n        }\n    }\n    \n\treturn col;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec4 hejlToneMapping (in vec4 color) {\n \tvec4 x = max(vec4(0.0), color-vec4(0.004)); \n\treturn (x * ((6.2*x)+vec4(0.5))) / max(x * ((6.2*x)+vec4(1.7))+vec4(0.06), vec4(1e-8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = 0.25*iTime;\n    \n    lights[0] = Light(vec3(0.0, 5.0, .0), vec3(1.0));   \n\tlights[1] = Light(vec3(12.0*sin(iTime), 8.0, 12.0*cos(iTime)), vec3(1.0));   \t\n    lights[2] = Light(vec3(-12.0*cos(-iTime), 8.0, 12.0*sin(-iTime)), vec3(.05));   \n\n   \n\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\t\n\n\t// camera\t\n\tvec3 ro = vec3( 7.0*sin(time), 3.6 , -7.0*cos(time) );\n\tvec3 ta = vec3( 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    #if 0\n        col = pow( col, vec3(0.4545) );\n        fragColor=vec4( col, 1.0 );\n    #else \n    \tfloat exposure = 0.032 + 0.023*sin(time-3.14);\n   \t\tfragColor = hejlToneMapping(vec4(col, 1.0) * exposure) ;\n    #endif\n}","name":"Image","description":"","type":"image"}]}