{"ver":"0.1","info":{"id":"Ws2cDK","date":"1587351969","viewed":48,"name":"gettin' learnt on ray marching","username":"Nicholas_Cowge","description":"a very well commented ray marching demo.  best if you watch some videos on the subject beforehand.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rays"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// lower these numbers if it lags\n#define MAX_STEPS 300 \n#define MAX_DIST 100.\n\n//dont touch this or bad things happen\n#define SURF_DIST .001\n\n// pixels in shadow have thier brightness multiplied by this number\n#define AMBIENT_LIGHT 0.1\n\nfloat GetDist(vec3 p) { //this function is called whenever the shader needs the distance to something, so the contents of the scene are placed here.\n    vec4 s = vec4(0, 2, 6, 0.8); //defines the size of the sphere, and the center of its motions\n    s.xz += vec2(sin(iTime*1.5), cos(iTime*1.5))*(cos(iTime*0.5)*2.); // moves the sphere around in a circle\n    s.y += (sin(iTime))*0.6; //moves the sphere up and down\n    \n    \n    \n    float sphereDist = length(p-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist); //defines the ground plane\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) { //this function works in tandem with the \"GetDist\" function to calculate collisions of rays.\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) { // it does this by esssentially by asking \"are we there yet?\" up to 300 times per pixel.\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p); //its question gets answered with a distance to \"there\", or the length of thr shortest path to the scene.\n        dO += dS; // it moves up (or marches, hence the name) along the ray by the distance it was given, and asks the question again, but this time it gets the distance from the point on the ray that it previously moved up to.\n        if(dO>MAX_DIST || dS<SURF_DIST) break; // at this point the distance is small enough that it considers itself \"there\", and reports the final distance.\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) { // this function is responsible for figuring out how much light there is at a given surface.\n    float d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3( // calculates how directly the light rays are hitting the surface\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n); // less direct rays will be get a lower brightness, and light rays that hit head-on will get a higher brightness.\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 6, 6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*3.; // moves the light around in a circle.\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = max(dot(n, l), 0.); // calculates shadows by marching a ray from each point that is illuminated to the light.\n    float d = RayMarch(p+n*SURF_DIST*2., vec3(l));\n    if(d<length(lightPos-p)) dif *= AMBIENT_LIGHT; // if the ray does not reach the light source, then it is in shadow, and it's brightnes value is multplied by the ambient light variable.\n    \t\t\t\t\t\t// multiplying the brightness value by the ambient light rather than making it completley black simulates ambient lighting. (go figure.) kinda lazy, but works well enough.\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) // \"Oh yeah, it's all coming together.\"\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -2);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d; \n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    col = sqrt(col);\n\n    fragColor = vec4(col,1.0); // brings everything together to calculate the color of a single pixel.\n}\t\t\t\t\t\t\t   // repeat for every pixel on the screen, and you have an image.","name":"Image","description":"","type":"image"}]}