{"ver":"0.1","info":{"id":"4l2XW1","date":"1443364240","viewed":2424,"name":"CaveStructure","username":"dila","description":"Raymarched carved structure.","likes":35,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","carve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const float pi = 3.14159;\n\nmat3 xrot(float t)\n{\n    return mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrot(float t)\n{\n    return mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nfloat sdBoxXY( vec3 p, float b )\n{\n  vec2 d = abs(p.xy) - b;\n  return min(max(d.x,d.y),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r)\n{\n \treturn length(p) - r;\n}\n\nfloat map(vec3 p)\n{\n    p.xy += vec2(sin(p.z), cos(p.z)) * 0.25;\n    \n\tvec3 q = fract(p) * 2.0 - 1.0;\n    \n    vec3 f = floor(p + 0.5);\n    \n    vec3 k = abs(normalize(q));\n    \n    float a = -sdBox(q, k+0.1);\n    \n    float b = -sphere(q, 1.3);\n    \n    float d = max(-b, a);\n    \n    float tt = 0.5+0.5*sin(p.z);\n    float tr = mix(0.125, 1.0, tt);\n    \n    float c = sdBoxXY(p - 0.5, tr);\n    \n    return max(-c, d);\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n \tfloat t = 0.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.3;\n    }\n    return t;\n}\n\nvec3 times(float n)\n{\n    float k = fract(iTime*n) * 3.0;\n    vec3 t = vec3(clamp(k, 0.0, 1.0),\n                clamp(k-1.0, 0.0, 1.0),\n                clamp(k-2.0, 0.0, 1.0));\n    return floor(iTime*n) + smoothstep(0.0, 1.0, t);\n}\n\nvec3 textex(vec3 p)\n{\n \tvec3 ta = texture(iChannel0, p.yz).xyz;\n    vec3 tb = texture(iChannel0, p.xz).xyz;\n    vec3 tc = texture(iChannel0, p.xy).xyz;\n    return (ta + tb + tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv,uv) * 0.33));\n    vec3 o = vec3(0.5, 0.5, iTime);\n    o.xy -= vec2(sin(o.z), cos(o.z)) * 0.25;\n    \n    vec3 ts = times(0.213);\n    r *= xrot(ts.y+ts.z) * yrot(ts.x+ts.z) * zrot(ts.x+ts.y);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n    float fd = map(w);\n    \n    float prod = clamp(dot(r, -sn), 0.0, 1.0);\n    \n    vec3 colfar = vec3(1.0, 0.0, 0.0);\n    vec3 colnear = vec3(1.0, 1.0, 1.0);\n    \n    float colk = 1.0 / (1.0 + t * t * 0.1);\n    vec3 col = mix(colfar, colnear, colk);\n\n    col *= textex(w * 0.1) * colk;\n    \n    float aoc = 1.0 / (1.0 + fd * 100.0);\n\n    vec3 fc = sqrt(col) * aoc * prod;\n    \n\tfragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}