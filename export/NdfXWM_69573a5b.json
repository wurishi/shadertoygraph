{"ver":"0.1","info":{"id":"NdfXWM","date":"1618687969","viewed":146,"name":"Gradient Overlap Demo","username":"AnsonRutherford","description":"Shader example demonstrating effects that can be achieved by overlaying gradients","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","gradient","overlay"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// At its simplest, this shader overlays three gradients in a triangular fashion.\n// By displacing this gradient by different amounts, and bending the gradient, we can get interesting visuals\n// We also have a parameter which controls the extent to which we discretize our color gradient (introducing banding)\n\n\n// Function for easily setting a parameter to vary across a range over time at a particular speed\nfloat osc(float rate, float min, float max) {\n    return min + (max - min) * (sin(rate * iTime) / 2.0 + 0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //PARAMETERS\n\n    // Overall speed of shader\n    float _Rate = 5.0;\n\n    // How far into the image to push each line of gradient\n    float _Dist = osc(_Rate / 7.0, 0.5, 1.5);\n    \n    // How much to bend each gradient (negative or positive bend)\n    float _Bend = osc(_Rate / 11.0, -2.0, 2.0);\n    \n    // Color resolution, lower numbers produce more pronounced bands\n    float _Res = pow(2.0, osc(_Rate / 13.0, 0.0, 10.0));\n    \n    // Colors to use for each gradient. Each gradient goes from the provided color to transparency\n    vec3 _Color1 = vec3(osc(_Rate / 2.0, 0.0, 1.0), 0, 1.0 - osc(_Rate / 2.0, 0.0, 1.0));\n    vec3 _Color2 = vec3(1.0 - osc(_Rate / 3.0, 0.0, 1.0), osc(_Rate / 3.0, 0.0, 1.0), 0);\n    vec3 _Color3 = vec3(0, 1.0 - osc(_Rate / 5.0, 0.0, 1.0), osc(_Rate / 5.0, 0.0, 1.0));\n    \n    // Background color\n    vec3 _BackColor = vec3(0, 0, 0);\n    \n    //END OF PARAMETERS\n    \n    \n\n    // Modify pixel coordinates (from -1 to 1 on the y axis)\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - vec2(1, 1);\n    uv.x *= iResolution.x/iResolution.y;\n\n    // Generate the primary vector for each gradient\n    float thirdRot = 3.1415926 * 2.0 / 3.0;\n    vec2 dir1 = vec2(cos(0.0 * thirdRot), sin(0.0 * thirdRot));\n    vec2 dir2 = vec2(cos(1.0 * thirdRot), sin(1.0 * thirdRot));\n    vec2 dir3 = vec2(cos(2.0 * thirdRot), sin(2.0 * thirdRot));\n\n    // Determine how impacted our point is by each gradient\n    float count1 = _Dist - ((uv.y * dir1.y + uv.x * dir1.x) - _Bend * pow(uv.x * dir1.y - uv.y * dir1.x, 2.0));\n    float count2 = _Dist - ((uv.y * dir2.y + uv.x * dir2.x) - _Bend * pow(uv.x * dir2.y - uv.y * dir2.x, 2.0));\n    float count3 = _Dist - ((uv.y * dir3.y + uv.x * dir3.x) - _Bend * pow(uv.x * dir3.y - uv.y * dir3.x, 2.0));\n\n    // Discretize and clamp\n    count1 = clamp(floor(count1 * _Res) / (1.0 * _Res), 0.0, 1.0);\n    count2 = clamp(floor(count2 * _Res) / (1.0 * _Res), 0.0, 1.0);\n    count3 = clamp(floor(count3 * _Res) / (1.0 * _Res), 0.0, 1.0);\n\n    // Sum colors\n    vec3 col = count1 * _Color1 + count2 * _Color2 + count3 * _Color3 + _BackColor;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}