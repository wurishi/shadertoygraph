{"ver":"0.1","info":{"id":"lcKXDt","date":"1715940543","viewed":102,"name":"Pretty mandelbrot (golf)","username":"xld3","description":"A smooth mandelbrot zoom with scaled iterations and escape radius","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","smooth","golf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// These should be used as uniforms for controls\nconst vec2 C = vec2(-.8119, .175); // Init center point\nconst int J = 90, // Min iterations\n    I = 400; // Max iterations\n\nconst float N = float(I-J),\n    F = 6., // Min escape\n    E = 9e3, // Max escape\n    S = .05, // Zoom speed\n    D = 10., // Max depth\n    L = E-F;\n\nvoid mainImage(out vec4 o, in vec2 f) {\n    float g = abs(sin(iTime * S)), // Zoom between 0 and 1\n        m = exp(g*D),\n        W = 1./(m*iResolution.y),\n        e = L * W + F; // Scale escape radius\n        \n    int h = int(N * pow(g, 2.)) + J, // Scale max iter\n        i = 0;\n        \n    f = (f+f - iResolution.xy)*W + C;\n    vec2 p = f,\n        z = f*f;\n    \n    while (i < h && z.x < e) {\n        f = vec2(z.x - z.y + p.x, 2.*f.x*f.y + p.y),\n        z = f*f,\n        ++i;\n    }\n                                                                                                     // palette\n    o = (i < h) ? \n        vec4(\n        .5 + .5*cos(\n        (float(i) + 1.-log2(log2(dot(f,f))/log2(e))) \n        * .1 + vec3(3, 4, 5)), 1)\n        // .1 is \"thickness\", vec3() is hue\n    : vec4(0);\n}\n\n/* 597 chars\n    + mouse panning\n    + better scaling on escape & iterations\n    + some optimizations\n#define R iResolution.xy\n\n// These don't need to be computed every pixel\n\nconst int J = 70, // Min iterations\n    I = 300, // Max iterations\n    A = 1; // Anti-aliasing\n\nconst float B = float(A),\n    b = 1./B,\n    K = 1./(B * B),\n    N = float(I-J),\n    F = 6., // Min escape\n    E = 9e3, // Max escape\n    S = .05, // Zoom speed\n    T = 6e-5, // Pan region increases with resolution, cross the gap at 1080p\n    D = 10., // Max depth\n    L = E-F;\n\nconst vec2 C = vec2(-0.832, 0.2); // Init center point\n\nvoid mainImage(out vec4 o, in vec2 f) {\n    float g = abs(sin(iTime * S)), // Zoom between 0 and 1\n        m = exp(g*D),\n        W = 1./m * 1./R.y,\n        e = L * W + F; // Scale escape radius\n        \n    int h = int(N * pow(g, 2.)) + J, // Scale max iter\n        i,\n        j;\n        \n    // Compromising on mouse panning since it inits with 0,0\n    f = (2.*f - R)*W + iMouse.xy*T + C;\n    \n    vec2 z,p,n;\n    \n    vec3 c = vec3(0.);\n        \n    for (i = 0; i < A*A; ++i) { // AA loop\n        n = p = f + (vec2(mod(float(i), B), float(i) * b) * b) * W;\n        \n        for (j = 0; j < h; ++j) { // Iteration loop\n            z = n*n;\n            \n            if (z.x + z.y > e)\n                break;\n                \n            n = vec2(z.x - z.y + p.x, 2. * n.x * n.y + p.y);\n        }\n        if (j < h) c += (.5 + .5 * cos(4. + (float(j) + 1. - log2(log2(dot(n, n)) / log2(e))) * .1 + vec3(-1., .5, 1.5))) * K;\n    }\n    o = vec4(c, 1.);\n}\n/*\n\n/* 591 chars\n    + reverse zoom after reaching max depth\n    + more defines for convenience and pre-calc\n    + scale up max iterations as zoom increases\n    + scale down escape radius as zoom increases\n#define R iResolution.xy\n\n// Const has smaller output size for expressions\n// These don't need to be computed every pixel\n\nconst int J = 50, // Min iterations\n    I = 500, // Max iterations\n    A = 2; // Anti-aliasing\n\nconst float B = float(A), // Cast seems to be same output size as define\n    b = 1./B,\n    K = 1./(B * B),\n    N = float(I-J),\n    F = 4., // Min escape\n    E = 8., // Max escape\n    S = .01, // Zoom speed\n    D = 10., // Max depth\n    L = E-F;\nconst vec2 C = vec2(-0.743, 0.1318), // Center point\n    k = 2.* vec2(B);\n\nvoid mainImage(out vec4 o, in vec2 f) {\n    float m = exp(abs(sin(iTime * S)) * D),\n        g = log(m)/D,\n        e = L * (1. - g) + F; // Scale escape radius\n        \n    int h = int(N * g) + J, // Scale max iter\n        i,\n        j;\n    \n    vec2 u = (2.*f - R) / R.y / m + C, // Center screen on 'C'\n        z,\n        p,\n        n;\n    \n    vec3 c = vec3(0.);\n        \n    for (i = 0; i < A*A; ++i) { // AA loop\n        n = p = u + (vec2(mod(float(i), B), float(i) * b) * b) / R.y / m;\n        \n        for (j = 0; j < h; ++j) { // Iteration loop\n            z = n*n;\n            \n            if (z.x + z.y > e) \n                break;\n                \n            n = vec2(z.x - z.y + p.x, 2. * n.x * n.y + p.y);\n        }\n        if (j < h) c += (.5 + .5 * cos(4. + (float(j) + 1. - log2(log2(dot(n, n)) / log2(e))) * .1 + vec3(-1., .5, 1.5))) * K;\n    }\n    o = vec4(c, 1.);\n}\n/*\n\n/* (original) 496 chars +- taste\n    there's some overhead without AA, but we won't optimize that\n    keeping the defines here for convenience\n\n#define I 300 // Max iterations\n#define E 9. // Escape radius\n#define A 2 // Anti-aliasing\n#define R iResolution.xy\n\nvoid mainImage(out vec4 o, in vec2 f) {\n    float B = float(A),\n        m = exp(iTime * .1); // Zoom\n    //                                      Center\n    vec2 u = (2.*f - R) / R.y / m + vec2(-.745, .186),\n         k = .5 / vec2(B);\n    \n    vec3 p = vec3(0.),\n        q = vec3(1. / (B * B));\n    \n    for (int i = 0; i < A * A; ++i) { // AA loop\n        vec2 e = vec2(mod(float(i), B), float(i) / B) / B - k,\n            t = u + e / R.y / m,\n            r = t;\n        \n        int n = 0;\n        for (; n < I; ++n) { // Iteration loop\n            vec2 z = r*r;\n            \n            if (z.x + z.y > E) \n                break;\n                \n            r = vec2(z.x - z.y + t.x, 2. * r.x * r.y + t.y);\n        }\n        if (n < I) p += (.5 + .5 * cos(4. + (float(n) + 1. - log2(log2(dot(r, r)) / log2(E))) * .1 + vec3(-1., .5, 1.5))) * q;\n    }\n    o = vec4(p, 1.);\n}\n*/","name":"Image","description":"","type":"image"}]}