{"ver":"0.1","info":{"id":"wdG3D3","date":"1571074254","viewed":279,"name":"ShaderTober - Dragon","username":"Flopine","description":"A small doodle with inktober's theme \"Dragon\"","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","terrain","dragon","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n#define PI 3.141592\n#define ITER 100.\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n// taken from YX here : https://www.shadertoy.com/view/tdlXW4\n// rough shadertoy approximation of the bonzomatic noise texture\nvec4 texNoise(vec2 uv)\n{\n    float f = 0.;\n    f += texture(iChannel0, uv*.125).r*.5;\n    f += texture(iChannel0, uv*.25).r*.25;\n    f += texture(iChannel0, uv*.5).r*.125;\n    f += texture(iChannel0, uv*1.).r*.125;\n    f=pow(f,1.2);\n    return vec4(f*.45+.05);\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat ground(vec3 p)\n{\n    p.y += texNoise(p.xz*.03).r*3.;\n    return abs(p.y)-0.8;\n}\n\nfloat g1 = 0.;\nfloat lava (vec3 p)\n{\n    p.y += 0.55;\n    p.y += sin(length(p.xz)-iTime)*0.1;\n    float d = abs(p.y)-0.5;\n    g1 += 0.1/(0.1+d*d);\n    return d;\n}\n\nfloat SDF (vec3 p)\n{\n    return min(lava(p),ground(p));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p) - vec3(SDF(p-eps.xyy), SDF(p-eps.yxy), SDF(p-eps.yyx)));\n}\n\nfloat dir_light (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\nvec3 getcam (vec3 ro, vec3 tar, vec2 uv)\n{\n    vec3 f = normalize(tar-ro);\n    vec3 l = normalize(cross(vec3(0.,1.,0.),f));\n    vec3 u = normalize(cross(f,l));\n    return normalize(f + l*uv.x + u*uv.y);\n}\n\nvec3 background (vec2 uv)\n{\n    uv.y -= 0.25+sin(iTime)*0.05;\n    vec2 uu = abs(uv) - 0.5;\n    return clamp(\n        smoothstep(0.18,0.13, length(uu))*vec3(0.,1.-length(uv),0.)\n        - smoothstep(0.08,0.05, length(uu)) * vec3(1.-length(uu))\n        + step(length(uu),0.04)*vec3(2.),\n    0.,\n    1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro = vec3(0.001,1.5,-3.),\n        p = ro,\n        rd = getcam(ro,vec3(0.), uv),\n        l = vec3(1.,2.,-3.),\n        col = vec3(0.);\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER;i++)\n    {\n        float d = SDF(p);\n        if (d<0.01)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p+=d*rd*0.8;\n    }\n    \n    float t = length(ro-p);\n    \n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = mix(vec3(0.1,0.,0.),vec3(0.5,0.2,0.2),dir_light(n,l));\n        col *= 1.-shad;\n    }\n    col += g1*vec3(texNoise(p.xz*0.1).r*4.,0.2,0.)*0.08;\n    col = mix(col, vec3(0.2)+background(uv)*0.2, 1.- exp(-0.1*t*t*texNoise(uv-vec2(0.,iTime*0.2)).r));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}