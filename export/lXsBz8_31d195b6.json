{"ver":"0.1","info":{"id":"lXsBz8","date":"1728166410","viewed":33,"name":"Fork 04 Középha adamtanacs answe","username":"adamtanacs2002","description":"harmadik és negyedik óra","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["cg","class"],"hasliked":0,"parentid":"M3SyRK","parentname":"03 Középhaladó grafika 2024 ősz"},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2(fragCoord);\n    vec3 col = vec3(0);\n    \n    float d = texelFetch(iChannel0,px,0).w;\n    \n    int k = int(dof(d));\n    \n    for(int y = -k; y <= k; ++y)\n    {\n        col += texelFetch(iChannel0,px+ivec2(0,y),0).rgb;\n    }\n    col /= float( (2*k+1));\n    //col += texelFetch(iChannel0,px+ivec2(20,0),0).rgb;\n    \n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A common shader included (as is) in all Buffers\n\nstruct Ray {\n\tvec3 p0; float tmin;\n\tvec3 v;\t float tmax;\n};\n\nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n};\n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n};\n\nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;     // normal\n};\n\nstruct Triangle {\n    vec3 a,b,c;\n};\n\nconst float pi = 3.1415926535897932384626433832795;\n\nconst vec3 EyeStartPosition = vec3(2);\n\nconst float d_f = 10.0;\nconst float k_max = 40.0;\n//\\left(d-x\\right)k\\cdot\\frac{1}{d}\n//\\arctan\\left(l\\cdot\\frac{\\pi}{2\\cdot k}\\left(x-d\\right)\\right)\\cdot\\frac{2}{\\pi}\\cdot k\n\nfloat dof(float d)\n{\n    if(d < d_f)\n        return (d_f-d)*k_max/d_f;\n    else\n        return atan((d-d_f))*2./pi*k_max;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Handles camera only\n\nconst int KeyLeft  = 65; //'A'\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\nconst int KeyE     = 69;\nconst int KeyQ     = 81;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nvec4 UpdateCamera(vec2 fragCoord)\n{\n    /*  We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (cameraX, cameraY, cameraZ, U)\n            pixel1 = (wX, wY, wZ, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n            wX, wY, wZ is the forward vector\n\t*/\n    \n    vec4 data1 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data2 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec3 eye = data1.xyz+EyeStartPosition;\n    vec2 uv\t= abs(vec2(data1.w,data2.w));\n    \n   \tif(iMouse.z>0. || data1.w >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 10.*iTimeDelta;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    if (isKeyHeld(KeyE    )) eye.y += speed;\n    if (isKeyHeld(KeyQ    )) eye.y -= speed;\n    \n    vec2 outdata = vec2(data1.w,data2.w);\n    if(iMouse.z>=0.)        outdata = abs(vec2(outdata)); //mouse held\n\telse if(data1.w >= 0.)  outdata = -mod(uv,2.*pi); //mouse released\n        \n    vec4 fragColor;\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor = vec4(eye-EyeStartPosition,outdata.x);\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor = vec4(w,outdata.y);\n\n    return fragColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray from pixel\n    if(fragCoord.x > 1.5 || fragCoord.y > 0.5)\n        discard;\n    fragColor = UpdateCamera(fragCoord);   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer A handels camera movement. Here we only read it\nRay ReadCamera(vec2 fragCoord)\n{\n    vec4 data1 = texelFetch(iChannel0, ivec2(0,0), 0);\n    vec4 data2 = texelFetch(iChannel0, ivec2(1,0), 0);\n    vec3 eye = data1.xyz+EyeStartPosition;\n        \n    vec3 w = data2.xyz;\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    return Ray(eye,\t0.0, normalize(w+px.x*u+px.y*v), 10000.);\n}\n\nconst int spheresNo = 2;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nTraceResult intersectSphere(Ray ray, Sphere s)\n{\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane)\n{\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n,t);\n}\n\nTraceResult raycast(Ray ray)\n{\n    TraceResult res = TraceResult(vec3(0), ray.tmax);\n    for(int i = 0; i < spheresNo; ++i)\n    {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    for(int i = 0; i < planeNo; ++i)\n    {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    return res;\n}\n\nvec3 shade(vec3 p, vec3 v, vec3 n) // v points from p to cam eye\n{\n    vec3 ka = 0.2*mix(vec3(0.3,0.1,0.1),vec3(0.1,0.1,0.7),n.y*0.5+0.5);\n\n    vec3 light_pos = vec3(3,2,0);\n    vec3 l = normalize(light_pos-p);\n    vec3 kd = vec3(0,1,1);\n    float di = dot(l,n);\n    if (0.>di)\n        return ka;\n    \n    Ray ray = Ray(light_pos,0.0,-l, distance(light_pos,p)-0.01); // Generate ray from pixel\n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax > result.t)\n        return ka;\n    \n    vec3 h = normalize(l + v);\n    float si = pow(max(dot(h,n),0.),100.);\n    vec3 ks = vec3(1,1,0);\n    return ka+kd*di + si*ks;\n}\n\nvec4 missColor(Ray ray)\n{\n    // 3\n    return texture(iChannel1, ray.v);\n}\nvec4 hitColor(Ray ray, TraceResult tr)\n{\n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n, v = -ray.v;\n    vec3 col = shade(p,v,n);\n    return vec4(col,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Description of 2 spheres\n    spheres[0] = Sphere(vec3(3.f*sin(iTime*3.f),0, 2), 1.f);\n    spheres[1] = Sphere(vec3(9,4,10), 1.f);\n    planes[0] = Plane(vec3(0), normalize(vec3(0,1,0)));\n\n    Ray ray = ReadCamera(fragCoord); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax <= result.t)\n        fragColor = missColor(ray);    \n    else\n        fragColor = hitColor(ray, result);\n    vec4 oldcol = texelFetch(iChannel2,ivec2(fragCoord),0);\n    fragColor = mix(fragColor, oldcol, 0.1);\n    fragColor.w = result.t;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2(fragCoord);\n    vec3 col = vec3(0);\n    \n    float d = texelFetch(iChannel0,px,0).w;\n    \n    int k = int(dof(d));\n    \n    for(int x = -k; x <= k; ++x)\n    {\n        col += texelFetch(iChannel0,px+ivec2(x,0),0).rgb;\n    }\n    col /= float( (2*k+1) );\n    //col += texelFetch(iChannel0,px+ivec2(20,0),0).rgb;\n    \n    fragColor = vec4(col,d);\n}","name":"Buffer C","description":"","type":"buffer"}]}