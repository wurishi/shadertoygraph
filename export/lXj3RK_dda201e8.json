{"ver":"0.1","info":{"id":"lXj3RK","date":"1708632656","viewed":75,"name":"Kubische Ruimteverdeling","username":"matigekunstintelligentie","description":"Kubische Ruimteverdeling by Escher with raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","escher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float a = -0.14; // value=-0.14, min=-1.0, max=1.0, step=0.01\nfloat b = 0.02; // value=0.02, min=-0.0, max=1.0, step=0.01\nfloat c = -0.02 ; // value=-0.02, min=-1.0, max=1.0, step=0.01\nfloat d = -0.08; // value=-0.08, min=-1.0, max=1.0, step=0.01\nfloat mobius = 1.; // value=1.0, min=0.0, max=1.0, step=0.01\nfloat colour = 1.; // value=1, min=0, max=1, step=1 (No, Yes)\n\n\n// Complex operators from Roy Wiggins\nvec2 cMul(vec2 a, vec2 b) {\n    return vec2( a.x*b.x -  a.y*b.y,a.x*b.y + a.y * b.x);\n}\n\nvec2 cInverse(vec2 a) {\n    return  vec2(a.x,-a.y)/dot(a,a);\n}\nvec2 cDiv(vec2 a, vec2 b) {\n    return cMul( a,cInverse(b));\n}\nvec2 cExp(in vec2 z){\n    return vec2(exp(z.x)*cos(z.y),exp(z.x)*sin(z.y));\n}\n\n\n\n// Raymarching code from Kishimisu\n\nfloat fov = 1.1;\n\nvec3 axis = vec3(1,0,0);\n\nfloat  sdSphere(vec3 p, float s){\n\treturn length(p) - s;\n}\n\nfloat max3 (vec3 v) {\n  return max (max (v.x, v.y), v.z);\n}\n\nfloat sdBox(vec3 p, vec3 b){\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat opUnion(float d1, float d2){\n\treturn min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2){\n\treturn max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2){\n\treturn max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n\tfloat h = clamp(0.5 + 0.5 * (d2-d1)/k, 0.0, 1.0);\n\treturn mix(d2, d1, h) - k*h*(1.0-h);\n}\n\nmat2 rot2D(float angle){\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn mat2(c, -s, s, c);\n}\n\nmat3 rot3D(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\t\n\treturn mat3(\n\toc*axis.x*axis.x+c,\n\toc*axis.x*axis.y-axis.z*s,\n\toc*axis.z*axis.x+axis.y*s,\n\toc*axis.x*axis.y+axis.z*s,\n\toc*axis.y*axis.y+c,\n\toc*axis.y*axis.z-axis.x*s,\n\toc*axis.z*axis.x-axis.y*s,\n\toc*axis.y*axis.z+axis.x*s,\n\toc*axis.z*axis.z+c\n\t);\n}\n\nvec3 rot3D(vec3 p, vec3 axis, float angle){\n\treturn mix(dot(axis,p)*axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\nfloat map(vec3 p){\n\tp = mod(p, 1.) - 0.5;\n\t\n\tfloat rightbox = sdBox(p, vec3(0.5,0.05 ,0.05));\n\tfloat topbox = sdBox(p, vec3(0.05,0.5 ,0.05));\n\tfloat backbox = sdBox(p, vec3(0.05,0.05 ,0.5));\n\t\n\n\tfloat movebox = mix(iTime, sin(iTime), 0.5 + 0.5*cos(iTime*0.01));\n\tfloat mainbox = sdBox(vec3((mod(p.x-movebox,1.)-0.5),p.y,p.z), vec3(0.15,0.15 ,0.15));\n\n\n\treturn opSmoothUnion(min(min(rightbox, topbox),backbox),mainbox, 0.05);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    a = vec3(0.5);\n    b = vec3(0.5);\n    c = vec3(1.);\n    d = vec3(0.263,0.416,0.557);\n    return a + b*cos( 6.28318*(c*t+iTime*0.1+d) );\n}\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 final_col = vec3(0.);\n    int AA = 4;\n    for( int m=0; m<AA; m++ ){\n        for( int n=0; n<AA; n++ ){\n            // Screen coordinate (from [-aspect, -1] to [aspect, 1])\n\n            vec2 uv   = (2.0*(gl_FragCoord.xy+vec2(float(m),float(n))/float(AA))-iResolution.xy) / iResolution.y;\n\n\n\n            uv = mix(uv,cDiv(a*uv + b, c*uv + d),mobius);\n\n\n            // Initialisation\n            vec3 ro = vec3(0, 0,-7. * (0.5 + 0.5*cos(iTime*0.4)));\n            vec3 rd = normalize(vec3(uv * fov, 1));\n\n\n            ro.xyz *= rot3D(vec3(10.*cos(iTime*0.14),10.*cos(iTime*0.15),10.*cos(iTime*0.16)),iTime*0.5); \n            rd.xyz *= rot3D(vec3(10.*cos(iTime*0.13),10.*cos(iTime*0.12),10.*cos(iTime*0.11)),iTime*0.5);\n\n            float t = 0.05;\n\n            vec3 col = vec3(0.);\n\n            int i ;\n            // Raymarching\n            for(i = 0; i<150; i++){\n                vec3 p = ro + rd*t; // position along the ray\n\n\n                p.y += (cos(t + iTime*0.7)*0.2)*(0.5+0.5*cos(iTime*0.13));\n                p.x += (sin(t + iTime*0.6)*0.2)*(0.5+0.5*cos(iTime*0.11));\n\n                float d = map(p);\n\n                t += d;\n\n                if (d<.0001 || t>100.){\n                    col = vec3(t*1.);\n                    if(colour>0.){\n                        col = palette((t*0.2 + float(i)*0.005)*(0.7 + 0.4*cos(iTime)), vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.00, 0.25, 0.25));\n                    }\n                    break;\n                }\n            }\n            final_col += col;\n        }\n\t}\n    \n    \n    final_col/=float(AA*AA);\n\n\t\t\n\tfragColor = vec4(final_col,1.);\n}\n","name":"Image","description":"","type":"image"}]}