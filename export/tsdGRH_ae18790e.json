{"ver":"0.1","info":{"id":"tsdGRH","date":"1567825125","viewed":917,"name":"Raymarch Testing","username":"guspash","description":"Testing some raymarching","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchtest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat lengthN(vec3 v, float p)\n{\n  vec3 tmp = pow(abs(v), vec3(p));\n  return pow(tmp.x+tmp.y+tmp.z, 1.0/p);\n}\n\nvec3 replicate(vec3 p, float c){\n\treturn mod(p, c) - (c/2.);\n}\n\nfloat torus(vec3 p, vec3 t){\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n  \treturn length(q)-t.y;\n}\n\nfloat roundCube(vec3 p){\n\treturn lengthN(p, 4.);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n        vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    } \n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n        vec3 pa = p - a, ba = b - a;\n        float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h ) - r;\n    }\n\t\nfloat cubeSDF(vec3 p, vec3 s) {\n\t// If d.x < 0, then -1 < p.x < 1, and same logic applies to p.y, p.z\n\t// So if all components of d are negative, then p is inside the unit cube\n\tvec3 d = abs(p) - s;\n\n\t// Assuming p is inside the cube, how far is it from the surface?\n\t// Result will be negative or zero.\n\tfloat insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n\n\t// Assuming p is outside the cube, how far is it from the surface?\n\t// Result will be positive or zero.\n\tfloat outsideDistance = length(max(d, 0.0));\n\n\treturn insideDistance + outsideDistance;\n}\n\nfloat distanceFunction(vec3 p)\n{\n\tp = replicate(p, 5.0);\n\t\n\tfloat tim = (iTime * 2.);\n\tif (mod(tim, 40.) < 10.) {\n\t\treturn sdCapsule(p, vec3(.1), vec3(.1),1.);\n\t} else if (mod(tim, 40.) < 20.) {\n\t\treturn sdCappedCylinder(p, vec2(.8,.8));\n\t} else if (mod(tim, 40.) < 30.) {\n\t\treturn torus(p, vec3(.8));\n\t}else if (mod(tim, 40.) < 40.) {\n\t\treturn cubeSDF(p, vec3(0.8));\n\t}\t\n}\n\n\nvec3 getNormal(vec3 p){\n\tconst float d = .001;\n\treturn normalize(vec3(\n\t\tdistanceFunction(p+vec3(d,0.,0.)) - distanceFunction(p+vec3(-d,0.,0.)),\n\t\tdistanceFunction(p+vec3(0.,d,0.)) - distanceFunction(p+vec3(0.,-d,0.)),\n\t\tdistanceFunction(p+vec3(0.,0.,d)) - distanceFunction(p+vec3(0.,0.,-d))\n\t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat tim = (iTime / 1000.);\n\t\n\tvec2 pos = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n \n\tvec3 camPos = vec3(0.0, 0.0, tim * 1000.0);\n \tvec3 camDir = vec3(0.0, 0.0, -1.0);\n\tvec3 camUp = vec3(0.0, 1.0, 0.0);\n\tvec3 camSide = cross(camDir, camUp);\n\tfloat focus = 1.8;\n\t\n\tvec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*focus);\n\t\n\tfloat \tt = 0.0, \n\t\td;\n\tvec3 posOnRay = camPos;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = distanceFunction(posOnRay);\n\t\tt += d;\n\t\tposOnRay = camPos + t*rayDir;\n\t}\n\t\n\t\n\tvec3 normal = getNormal(posOnRay);\n\tif(abs(d) < 0.001)\n\t{\n\t\tfragColor = vec4(normal, 1.);\n\t}else\n\t{\n\t\tfragColor = vec4(vec3(0.0), 1.0);\n\t}\n}\n\n","name":"Image","description":"","type":"image"}]}