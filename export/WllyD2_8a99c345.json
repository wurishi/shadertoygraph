{"ver":"0.1","info":{"id":"WllyD2","date":"1593128411","viewed":128,"name":"DixImac teapot card","username":"Kaeylos","description":"teaPot card generated in rayMarching for the IMAC game DixImac created by JulesFouchy.\n","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265358979323846264338327\n#define SURF_DIST 0.00001\n#define MAX_DIST 100.\n// utils\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nvec3 vRotateX(vec3 v, float a) {\n    float c = cos(a), s = sin(a);\n    return vec3(v.x, c*v.y + s*v.z, -s*v.y + c*v.z);\n}\n// 3D utils\nvec2 sdBezier( vec3 p, vec3 b0, vec3 b1, vec3 b2 ) {\n    b0 -= p;\n    b1 -= p;\n    b2 -= p;\n    vec3 b01 = cross(b0,b1), b12 = cross(b1,b2), b20 = cross(b2,b0), n =  b01+b12+b20;\n    float a = -dot(b20,n), b = -dot(b01,n), d = -dot(b12,n);\n\n    float m = -dot(n,n);\n    vec3  g =  (d-b)*b1 + (b+a*0.5)*b2 + (-d-a*0.5)*b0;\n    float f = a*a*0.25-b*d;\n    vec3  k = b0-2.0*b1+b2;\n    float t = clamp((a*0.5+b-0.5*f*dot(g,k)/dot(g,g))/m, 0.0, 1.0 );\n    return vec2(length(mix(mix(b0,b1,t), mix(b1,b2,t),t)),t) ;\n}\nfloat sminCubic( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\nfloat onionOp(float d,float h) { return abs(d)-h; }\nfloat sSubOp( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\nfloat planeSDF(vec3 p, vec4 plane) { return dot(p - plane.w, plane.xyz); }\nfloat capsuleSDF( vec3 p, vec3 a, vec3 b, float radius ) {\n  vec3 pa = p - a, ba = b - a;\n  return length(pa - ba*clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 ))- radius;\n}\n// 2D utils\nvec2 simX(vec2 p) { return vec2(abs(p.x), p.y); }\nvec2 revolutionOp(vec3 p, float w) { return vec2( length(p.xz) - w, p.y );}\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb ) {\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    q.x = abs(q.x);\n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    float k = cro(c,q), m = dot(c,q),n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat teaPotBody2D_SDF(in vec2 p) {\n    float d = 1e10;\n    d = min (d, sdUnevenCapsule( simX(p), vec2(0.7, -0.3), vec2(0.6, 0.35), 0.3, 0.26 ));\n    d = min(d, sdBox(p, vec2(0.6, 0.5) ) - 0.1);\n    d = min(d, sdSegment(p, vec2(-0.5,0.55), vec2(0.5, 0.55)) - 0.08);\n    d = sminCubic(d, sdUnevenCapsule( p, vec2(-0.12, 0.72), vec2(0.12, 0.70), 0.10, 0.10 ), 0.01);\n    return d; \n}\n\nfloat teaPotSDF(vec3 p) {\n    vec2 handleB = sdBezier(p - vec3(1.4, -0.3, 0.0)/ 1.2, vec3(0.0), vec3(1.2, 0.9, 0.0), vec3(-0.2, 0.8, 0.0));\n    float radiusHandle = 0.1 * ( cos(PI * (handleB.y + 0.5)) / 2.0 + 1.0);\n    float handle = handleB.x - radiusHandle;\n    float body = teaPotBody2D_SDF(revolutionOp(p/1.5, 0.0));\n    vec2 frontB = sdBezier( p - vec3(-1.3, 0.0, 0.0), vec3(0.0), vec3(-0.5, 0.0, 0.0), vec3(-0.5, 0.6, 0.0));\n    float radiusFront = 0.3 - 0.2*frontB.y;\n    float frontbezier = frontB.x - radiusFront;\n    float frontCaps = capsuleSDF(p, vec3(-1.8, 0.5, 0.0), vec3(-2.0, 0.65, 0.0), 0.11);\n    vec3 planeN = normalize(vec3(-0.2, -1.0, 0.0));\n    float frontPlane = planeSDF(p, vec4(planeN, 0.25));\n    float front = sminCubic(frontbezier, frontCaps, 0.4);\n    front = onionOp(front, 0.02);\n    front = sSubOp(frontPlane, front, 0.01);\n    return sminCubic(sminCubic(handle, body, 0.01), front, 0.4) /1.5;\n}\n\nfloat getDistance(vec3 p) {\n    return min(planeSDF(p, vec4(0., 1., 0., - 1.)), teaPotSDF(p - vec3(0., 0., 3.)));\n}\n\nfloat rayMarching(vec3 ro, vec3 rd) {\n    float d = 0.;\n    for(int i = 0; i < 50; i++) {\n        float dScene = getDistance(ro + rd * d);\n        if( d > MAX_DIST || dScene < SURF_DIST*0.99) break;\n        d += dScene;\n    }\n    return d;\n}\n\nvec3 getNormal(vec3 p) {\n    const float h = 0.001;\n    vec2 e = vec2(h, 0);\t\n\tconst vec2 k = vec2(1., -1.);\n    return normalize(k.xyy * getDistance( p + k.xyy*h ) + k.yyx * getDistance( p + k.yyx*h ) + \n                     k.yxy * getDistance( p + k.yxy*h ) + k.xxx * getDistance( p + k.xxx*h ) );\n}\nvec3 getLight(vec3 lookPos, vec3 dir) {\n    \n    vec3 col = vec3(0.0);\n    float d = rayMarching(lookPos, dir);\n    vec3 p = lookPos + dir * d, normal = getNormal(p), ref = normalize(reflect(dir, normal));\n\n        if( d < MAX_DIST) {\n\n            // ----- sun ----- //\n            vec3 sunDir = normalize(vec3(0.8, 0.4, 0.2));\n            vec3 sunColor = normalize(vec3(0.7, 0.7, 0.5));\n            float sunIntensity = 6.; \n\n            // ----- sky ----- //\n            vec3 skyDir = vec3(0., 1., 0.);\n            vec3 skyColor = normalize(vec3(0., .1, .3));\n            float skyIntensity = 1.;\n\n            float sunDiffuse = clamp(dot(normal, sunDir), 0., 1.);\n            float skyDiffuse = clamp( 0.5 + 0.5*dot(normal, skyDir), 0., 1.);\n\n            // ----- compute specular ----- //\n            float sunSpecular = 0.;\n            float skySpecular = 0.;\n\n            sunSpecular = pow(max(0., dot(normal, normalize(sunDir - dir))), 16.);\n            skySpecular = pow(max(0., dot(normal, normalize(skyDir - dir))), 16.);\n\n            col += sunIntensity*sunColor*sunDiffuse + 0.6*sunSpecular*sunColor;\n            col += skyIntensity*skyColor*skyDiffuse + 0.6*skySpecular*skyColor;\n\n            col *= 0.2;\n        }else {\n            // sky\n            col += (vec3(.4, .7, 1.) - 0.35 * dir.y)*0.9;\n            col = mix(col, 1.-(1.-col)*(1.-col), exp(-8.*dir.y)); // lighten horizon using quadratic cuve 1-(1-x)^2\n        }\n        \n    return col;\n}\n\nvec2 computeUV(vec2 fragCoord) {\n    // Normalized and centered coordinates (from -0.5 to 0.5) using same unit on both axis\n\tvec2 uv = (fragCoord-.5 - 0.5*(iResolution.xy-1.))/(iResolution.y-1.);  \n\tuv *= 2.; // scale to have 1 radius (from -1 to 1)\n    uv *= 1.5; // scale to have 1.5 unit for the y axes\n    return uv;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = computeUV(fragCoord);\n    // uv = (fragCoord-.5 * iResolution.xy)/iResolution.y; // get centered & normalized \n    // vec3 col = 0.5 + 0.5*cos(iTime+vec3(uv, 1.)+vec3(0,2,4)); // Time varying pixel color\n    \n    vec3 col =  pow(getLight(vec3(0., 2., -1.), vRotateX(normalize(vec3(uv.xy*0.6, 1.)), -0.5)) * vec3(1.0 ,0.9, 1.0), vec3(0.4545));\n    if( abs(uv.y) > 1.5 || abs(uv.x) > 1.) { col = vec3(0.);} // uv coordinate mask\n    fragColor = vec4(col,1.0); // Output color to screen\n}","name":"Image","description":"","type":"image"}]}