{"ver":"0.1","info":{"id":"4ldfRH","date":"1538658250","viewed":243,"name":"Repulsive springs","username":"Ultraviolet","description":"Click on a particle to move it.\nSpace en/dis-ables edges.\nChange parameters (like the number of particles) in the common tab.\nGame : If you go fast enough, you can capture multiple particles under your mouse cursor. Can you catch them all ?\nTODO : 3D !","likes":20,"published":1,"flags":48,"usePreview":0,"tags":["optimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2018-09-27\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader uses a hook force field (i.e. simple springs) and a gradient descent \n// algorithm for finding the optimal positions of N particles.\n\n\n\n\n// The following 2 functions come from https://www.shadertoy.com/view/lt3GRj\n// Thank you TimoKinnunen !\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 X = SCREEN2WORLD(fragCoord);\n\n    vec3 col = vec3(1.);\n    \n    \n    DRAW_C(Grid(1.), X, vec3(.1), .5, col);\n    DRAW_C(Ray(vec2(0.), vec2(1.,0.)), X, vec3(.0), 1., col);\n    DRAW_C(Ray(vec2(0.), vec2(0.,1.)), X, vec3(.0), 1., col);\n    \n    \n    \n    vec2 xx[NB_PARTICLES];\n    for(int i=0;i<NB_PARTICLES;++i)\n    {\n        vec2 x = texelFetch(iChannel0, ivec2(i,0), 0).xy;\n        xx[i] = x;\n        \n        if(texelFetch(iChannel1, ivec2(32, 2), 0).x < .5)\n        for(int j=i+1;j<NB_PARTICLES;++j)\n        {\n            vec2 y = texelFetch(iChannel0, ivec2(j,0), 0).xy;\n            vec3 col_seg = vec3(.5);\n            if(length(x-y) > rest_length)\n                col_seg = mix(col_seg, vec3(1., 0., 0.), (length(x-y)-rest_length)/rest_length);\n            else\n                col_seg = mix(col_seg, vec3(0., 0., 1.), (rest_length-length(x-y))/rest_length);\n            \n            vec2 offset = normalize(y-x)*radius;\n            DRAW_CA(Segment(x+offset, y-offset), X, vec4(col_seg, .7), 2., col);\n        }\n        \n        vec3 col_cir = hsv2rgb_smooth(vec3(float(i)/float(NB_PARTICLES), 1., 1.));\n        DRAW_A(Circle(x, radius), X, vec4(col_cir, .2), col);\n        DRAW_C(Circle(x, radius), X, col_cir, 2., col);\n    }\n    \n\t//vec2 fontSize = vec2(4,5) * vec2(5,3);\n\tvec2 fontSize = vec2(4,5) * vec2(5,3) * iResolution.x/800.;\n    vec2 vPixelCoord = vec2(-5.0, 5.0);\n\tfloat fDigits = 2.0;\n\tfloat fDecimalPlaces = 5.0;\n\tfloat fIsDigit = PrintValue(fragCoord, vPixelCoord, fontSize, functionToOptimize(xx), fDigits, fDecimalPlaces);\n\tcol = mix( col, vec3(0.0), fIsDigit);\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This tab implements the Newton method for optimizing the arm angles.\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // represents the current state in the 1st pixel of the buffer, the rest is discarded\n    \n    ivec2 coord = ivec2(floor(fragCoord));\n    if(coord.x > NB_PARTICLES || coord.y > 0)\n        discard;\n    \n    \n    vec2 x[NB_PARTICLES];\n    for(int i=0;i<NB_PARTICLES;++i)\n    {\n        float alpha = float(i)*2.*PI/float(NB_PARTICLES);\n        x[i] = iFrame==0? vec2(cos(alpha), sin(alpha))*(.5+sin(alpha)*sin(alpha)*2.) : texelFetch(iChannel0, ivec2(i,0), 0).xy;\n    }\n    \n    vec2 x_dy[NB_PARTICLES]=x, x_dx[NB_PARTICLES]=x;\n    x_dx[coord.x] += vec2(epsilon,0.);\n    x_dy[coord.x] += vec2(0.,epsilon);\n    \n    float E    = functionToOptimize(x);\n    float E_px = functionToOptimize(x_dx);\n    float E_py = functionToOptimize(x_dy);\n    \n    vec2 grad = vec2(E_px-E, E_py-E)/epsilon;\n    x[coord.x] -= grad * dt;\n    \n    if(x[coord.x].y-radius < -1.5)\n        x[coord.x].y = radius-1.5;\n    \n    vec2 m = SCREEN2WORLD(iMouse.xy);\n    \n    vec2 m_prec = texelFetch(iChannel0, ivec2(coord.x,0), 0).zw;\n    if(length(m_prec) > epsilon && iMouse.z > .5)\n    {\n//        x[coord.x] += m-m_prec;\n        x[coord.x] = m;\n    }\n    \n    if(length(m-x[coord.x]) > radius || iMouse.z < 0.5)\n        m *= 0.;\n    \n    if(coord.x == 0 && length(iMouse.xy) < 20. && iMouse.z <.5)\n        x[coord.x] = vec2(cos(iTime*2.)*1.5, sin(iTime*4.));\n    \n    fragColor = vec4(x[coord.x], m);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// 2018-09-25\n// Created by Ulysse Vimont - Ultraviolet\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define PI\t3.1415926535\n\n/// Tweak those parameters to see what it does !\n#define NB_PARTICLES\t9\nfloat rest_length = 1.5;\nfloat radius = 0.1;\nfloat dt = 0.05;\nfloat epsilon = 1e-3;\nfloat gravity = .1;\n\n\n#define SCREEN2WORLD(X)  ((X -iResolution.xy*.5)/iResolution.y*3.)\n\n\n\nfloat functionToOptimize(vec2 x[NB_PARTICLES])\n{\n    float e = 0.;\n    \n    for(int i=0; i<x.length()-1; ++i)\n    \tfor(int j=i+1; j<x.length(); ++j)\n            e += (length(x[i]-x[j])-rest_length)*(length(x[i]-x[j])-rest_length);\n        \n    for(int i=0; i<x.length(); ++i)\n        e += x[i].y*gravity;\n        \n    return e;\n}\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////\n//      ___  ____  __   _  _  ____  ____  ____  _  _      __    __  ____ \n//     / __)(  __)/  \\ ( \\/ )(  __)(_  _)(  _ \\( \\/ )    (  )  (  )(  _ \\\n//    ( (_ \\ ) _)(  O )/ \\/ \\ ) _)   )(   )   / )  /     / (_/\\ )(  ) _ (\n//     \\___/(____)\\__/ \\_)(_/(____) (__) (__\\_)(__/      \\____/(__)(____/\n//\n////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n//---------------------------------------\n// Point\n\nfloat dist(vec2 p0, vec2 p1)\n{\n    return length(p1-p0);\n}\n\n\n\n\n//---------------------------------------\n// Circle\n\nstruct Circle\n{\n    vec2 ctr;\n    float rad;\n};\n\nvec2 getPt(Circle c, float t)\n{\n    return c.ctr + c.rad*vec2(cos(t*PI*2.), sin(t*PI*2.));\n}\n    \nfloat dist(Circle c, vec2 p)\n{\n    return (length(c.ctr-p)-c.rad);\n}\n\n    \n    \n//---------------------------------------\n// Ray\n\nstruct Ray\n{\n    vec2 org;\n    vec2 dir;\n};\n    \nvec2 getPt(Ray r, float t)\n{\n    return r.org + t*r.dir;\n}\n\nfloat dist(Ray r, vec2 p)\n{\n    return abs(dot(r.dir.yx*vec2(-1., 1.), p-r.org)/dot(r.dir, r.dir));\n    \n    \n    float t = dot(r.dir, p-r.org);\n    t = max(t, 0.);\n    return length(getPt(r, t) - p);\n}\n\n\n\n\n//---------------------------------------\n// Segment\n\nstruct Segment\n{\n    vec2 A;\n    vec2 B;\n};\n\nvec2 getPt(Segment c, float t)\n{\n    return mix(c.A, c.B, t);\n}\n\nfloat dist(Segment s, vec2 p)\n{\n\tvec2 pa = p-s.A, ba = s.B-s.A;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\n\n\n\n\n//---------------------------------------\n// Triangle\n\nstruct Triangle\n{\n    vec2 p0;\n    vec2 p1;\n    vec2 p2;\n};\n\n\nfloat dist(Triangle t, in vec2 p )\n{\n\tvec2 e0 = t.p1 - t.p0;\n\tvec2 e1 = t.p2 - t.p1;\n\tvec2 e2 = t.p0 - t.p2;\n\n\tvec2 v0 = p - t.p0;\n\tvec2 v1 = p - t.p1;\n\tvec2 v2 = p - t.p2;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n//---------------------------------------\n// Grid\n\nstruct Grid\n{\n    float inter;\n}; \n\nfloat dist(Grid g, vec2 p)\n{\n    vec2 d = abs(mod(p+g.inter*.5,g.inter*2.)-g.inter)-g.inter*.5;\n    return max(min(d.x, d.y), min(-d.x, -d.y));\n}\n\n\n\n\n//---------------------------------------\n// Drawing Macros\n\n// draw the inside of the shape\n// O = object, P = point, C = drawing color, CC = original color\n#define DRAW(O,P,C,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))\n\n// draw the inside of the shape, with alpha\n#define DRAW_A(O,P,C,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(dist(O,P)*iResolution.y/2., -1., 1.)*.5+.5))*C.a)\n\n// draw the contour of the shape \n#define DRAW_C(O,P,C,W,CC)\tCC=mix(CC,C,mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2.-W, -1., 1.)*.5+.5))\n\n// draw the contour of the shape with alpha\n#define DRAW_CA(O,P,C,W,CC)\tCC=mix(CC,C.rgb,(mix(1.,0.,clamp(abs(dist(O,P))*iResolution.y/2. -  W, -1., 1.)*.5+.5))*C.a)\n\n\n\n","name":"Common","description":"","type":"common"}]}