{"ver":"0.1","info":{"id":"X3V3WR","date":"1717785295","viewed":88,"name":"Bevelled Voxel Terrain","username":"EisernSchild","description":"In this example I have beveled the respective top voxel blocks. The voxel stepping technique (invented by Xor) that I use here is extremely fast. And the top \"sliced\" block is simply intersected using the normal given for the slant.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","voxel","intersect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bevelled Voxel Terrain\n// Copyright (c) 2024 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    In this example I have beveled the respective top voxel blocks. \n    \n    The voxel stepping technique (invented by Xor) that I use here is \n    extremely fast. And the top \"sliced\" block is simply intersected \n    using the normal given for the slant.\n    \n    Use the mouse to move the camera.\n    \n    References:\n    GM Shaders: Voxels by Xor - https://www.shadertoy.com/view/XctSz8\n*/\n\n#define MAX_INTERSECT 255.f\n#define LIGHTING\n#define FREECAM\n#define CHECKERS .01f\n\n// ray hit attribute\nstruct PosNormT\n{\n\tvec3 vPos;\n\tvec3 vNor;\n    float fT;\n};\n\n#define M_PI 3.1415926535897932384626433832795f\n\n// simple terrain by texture\nfloat terrain( vec2 vP ) \n{\n    return texture(iChannel0, vP * .0005f).x * 10.f;\n}\n\n// normal (xy) + height (y)\nvec3 heightmap(vec2 vP)\n{\n    float fNX = (terrain(vP - vec2(1.f, 0.f)) - terrain(vP + vec2(1.f, 0.f))) * .25f;\n    fNX = (fNX < 0.f) ? max(fNX, -.5f) : min(fNX, .5f);\n    float fNZ = (terrain(vP - vec2(0.f, 1.f)) - terrain(vP + vec2(0.f, 1.f))) * .25f;\n    fNZ = (fNZ < 0.f) ? max(fNZ, -.5f) : min(fNZ, .5f);\n    return vec3(fNX, terrain(vP), fNZ);\n}\n\nvoid mainImage(out vec4 cOut, in vec2 vXY )\n{\n    /// ------- CAMERA\n    \n    // get current camera position and lookat matrix\n    float fCamDist = 14.6f;\n#ifdef FREECAM\n    mat3 mView = mat3(1., 0., 0., 0., .0, .6, 0., -.6, .8);\n    vec2 vMs = (iMouse.z > 0.f) ? iMouse.xy : vec2(sin(iTime * .3f) + 1.f, sin(iTime * .1f) + 1.f) * .5f * iResolution.xy;\n    vec4 vCamPos = vec4(vec3(vMs.yx - iResolution.xy * .5f, .0f) / iResolution.y * mView * 32.f, 0.f);\n    vCamPos.y = max(10.f, vCamPos.y);\n    vCamPos.x += iTime * 5.f;\n#else    \n    vec4 vCamPos = vec4(sin(iTime * .2f) * fCamDist, 14.5f + sin(iTime * .3f) * .5f, cos(iTime * .2f) * fCamDist, 0.f);\n#endif\n    vec3 vCamLAt = vec3(vCamPos.x + 10.f * (cos(iTime * .5f) + 2.f), 1.f, vCamPos.z + 5. * sin(iTime));\n    mat4x4 avLookAt = LookAtLH(vCamPos.xyz, vCamLAt, vec3(0.f, 1.f, 0.f));\n    \n    // get projection matrix\n    mat4x4 avProj = PerspectiveLH(vec2(radians(90.), radians(60.)), vec2(1., 1000.));\n    \n    /// ------- RAYTRACING\n    \n    // get ray\n    vec3 vOri, vDir;\n    TransformRay(uvec2(vXY), iResolution.xy, \n        vCamPos, inverse(avLookAt * avProj), vOri, vDir);\n        \n    /// ------- VOXEL SPACE MARCH\n    \n    // signed direction + step size \n    vec3 vSgn = sign(vDir);\n    vec3 vStp = vSgn / vDir;\n    \n    // initial voxel position + axis faces\n    vec3 vVox = floor(vOri);\n    vec3 vVFc = ((vVox - vOri + 0.5) * vSgn + 0.5) * vStp;\n\n    // set far hit pos for sky if no hit\n    PosNormT sAtt;\n    bool bHit = false;\n\n    // march through voxel face intersections\n    vec3 vAxi = vec3(0.f, 1.f, 0.f), vNor = vec3(0.f, 1.f, 0.f);\n    for(float fIsc = .0f; fIsc < MAX_INTERSECT; fIsc++)\n    {\n        // check map \n        vec3 vH = heightmap(vVox.xz);\n        \n        // full blocks fix (y == floor(y), so minus 1)\n        if (fract(vH.y) == 0.f) vH.y -= 1.f;\n        \n        // voxel is in/beneath terrain\n        if (floor(vH.y) >= vVox.y)\n        {\n            // set full blockhit attribute, round normal axis\n            sAtt.fT = dot(vVFc - vStp, vAxi);\n            sAtt.vPos = vOri + vDir * sAtt.fT;\n            sAtt.vPos = vec3(bool(vNor.x) ? round(sAtt.vPos.x) : sAtt.vPos.x,\n                            bool(vNor.y) ? round(sAtt.vPos.y) : sAtt.vPos.y,\n                            bool(vNor.z) ? round(sAtt.vPos.z) : sAtt.vPos.z);\n            sAtt.vNor = vNor * vec3(1.f, -1.f, 1.f);\n    \n            // full block ?\n            if ((floor(vH.y) > vVox.y) || ((vH.y == vVox.y) && (vH.x == 0.f) && (vH.z == 0.f)))\n            {\n                bHit = true;\n                break;\n            }\n            else\n            {\n                // intersect plane, first get plane normal\n                vec3 vPNor = normalize(vec3(vH.x, 1.f - abs(vH.x) - abs(vH.z), vH.z));\n                vec3 vO = vOri - (vVox + vec3(0.f, fract(vH.y), 0.f));\n                float fDPN = dot(vDir, vPNor);\n                float fT = -dot(vPNor, vO) / fDPN;\n                \n                // face hit ?\n                if (((fDPN <= 0.f) && (sAtt.fT >= fT)) || \n                    ((fDPN > 0.f) && (sAtt.fT < fT))) \n                {\n                    bHit = true;\n                    break;\n                }\n                \n                // get plane hit pos\n                vec3 vHPPos = vOri + vDir * fT;\n                if (floor(vHPPos) == vVox)\n                {\n                    sAtt.vPos = vHPPos;\n                    sAtt.vNor = vPNor;\n                    bHit = true;\n                    break;\n                }\n            }\n        }\n        \n        // closest voxel face axis\n        vAxi = vVFc.x < vVFc.z ? \n             ( vVFc.x < vVFc.y ? vec3(1.f, 0.f, 0.f) : vec3(0.f, 1.f, 0.f) ):\n             ( vVFc.z < vVFc.y ? vec3(0.f, 0.f, 1.f) : vec3(0.f, 1.f, 0.f) );\n        \n        // step to next voxel by normal\n        vNor = vSgn * vAxi;\n        vVox += vNor;\n        vVFc += vStp * vAxi;\n    }\n    \n    /// ------- TEXTURE\n    \n    // set color by voxel position\n    cOut.xyz = pal( floor(sAtt.vPos.y) * .06f, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    cOut.xyz = sAtt.vNor.y > .5f ? \n        mix(cOut.xyz, texture(iChannel0, sAtt.vPos.xz * .04f).xyz, .3f) :\n        (abs(sAtt.vNor.x) > abs(sAtt.vNor.z)) ?\n                 mix(cOut.xyz, texture(iChannel0, sAtt.vPos.zy * .04f).xyz, .3f) :\n                 mix(cOut.xyz, texture(iChannel0, sAtt.vPos.xy * .04f).xyz, .3f) ;\n                 \n#ifdef CHECKERS\n    // set colored checker lines\n    cOut.xyz = mix(cOut.xyz, \n                  pal( sAtt.vPos.y + iTime, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) )\n                  ,max(checkers_AA(sAtt.vPos.xz, CHECKERS),  \n                       max(checkers_AA(sAtt.vPos.xy, CHECKERS),\n                       checkers_AA(sAtt.vPos.zy, CHECKERS))));\n#endif\n    \n    /// ------- LIGHTING\n\n#ifdef LIGHTING\n    // phong lighting\n    vec3 cLit = Phong_PointLight(sAtt.vPos, vCamLAt + vec3(1.f, 13.f, .5f), \n        vOri, cOut.xyz, vDir, sAtt.vNor);\n    \n    cOut = vec4(clamp(cLit, 0.f, 1.f), 1.f);\n#else\n    // simple shade\n    cOut.xyz *= mix(vec3(0.2,0.2,0.4), vec3(1), dot(vAxi, vec3(0,1,.5)));\n#endif\n\n    // sky + fog\n    vec3 cSky = 1.f + (vDir.y - 1.f) * vec3(.3f, .2f, .1f);\n    float fFog = min(sAtt.fT / 128.f, 1.f);\n    cOut.xyz = bHit ? mix(cOut.xyz, cSky, fFog * fFog) : cSky;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Bevelled Voxel Terrain\n// Copyright (c) 2024 by Denis Reischl\n//\n// SPDX-License-Identifier: MIT\n\n/*\n    In this example I have beveled the respective top voxel blocks. \n    \n    The voxel stepping technique (invented by Xor) that I use here is \n    extremely fast. And the top \"sliced\" block is simply intersected \n    using the normal given for the slant.\n    \n    Use the se mouse to move the camera.\n    \n    References:\n    GM Shaders: Voxels by Xor - https://www.shadertoy.com/view/XctSz8\n*/\n\n// ############################ Noise / Palette / Checkers\n\n// See https://iquilezles.org/articles/palettes for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) { return a + b*cos( 6.28318*(c*t+d) ); }\nvec3 pal1( in float t ) { return pal(t, vec3(.8,.8,.8),vec3(.5,.5,.5),vec3(1.,.5,.5),vec3(.3,.4,.3)); }\n\n// checkers anti-aliased\nfloat checkers_AA(vec2 vUv, float fW)\n{\n    vec2 vAA = fwidth(vUv);\n    vec2 vGUv = 1.0 - abs(fract(vUv) * 2.0 - 1.0);\n    vec2 vGrid = smoothstep(fW + vAA, fW - vAA, vGUv);\n    return clamp(mix(vGrid.x, 1.0, vGrid.y), 0.f, 1.f);\n}\n\n// ############################ Lighting\n\n// phong pointlight.. in Position Texel, Light, Camera, Material Color, Ray Direction, Normal\n// inspired by Shane's lighting model\nvec3 Phong_PointLight(vec3 vPosTex, vec3 vPosLig, vec3 vPosCam, vec3 cMat, vec3 vDir, vec3 vNor)\n{\n    const float fAmbient = .6f;\n    const float fAttenuation = .03f;\n        \n    // light direction, distance\n\tvec3 vLDir = vPosTex - vPosLig;\n\tfloat fLDist = max(length(vLDir), .001f);\n\tvLDir /= fLDist;\n\n\t// ambient, diffuse, attenuation, specular\n\tfloat fDif = max(dot(-vLDir, vNor), 0.f);\n\tfDif = pow(fDif, 2.f) * .6f + pow(fDif, 4.f) * .2f + pow(fDif, 8.f) * .2f;\n\tfloat fAtt = 1. / (1. + fLDist * fAttenuation);\n\tvec3 vRef = reflect(vLDir, vNor);\n\tfloat fSpec = pow(max(dot(-vDir, vRef), 0.0), 32.f);\n\n\treturn clamp(((cMat * max(fDif, fAmbient)) + fSpec * .5f) * fAtt, 0.f, 1.f);\n}\n\n// ############################ Transform\n\n// provide a lookat matrix\nmat4x4 LookAtLH(vec3 vCam, vec3 vTar, vec3 vUp)\n{\n    mat4x4 avLookAt;\n    vec3 vZ = normalize(vTar - vCam);\n    vec3 vX = normalize(cross(vUp, vZ));\n    vec3 vY = cross(vZ, vX);\n       \n    avLookAt = \n    mat4x4(\n        vec4(1., 0., 0., -vCam.x),\n        vec4(0., 1., 0., -vCam.y),\n        vec4(0., 0., 1., -vCam.z),\n        vec4(0., 0., 0., 1.)\n    ) *\n    mat4x4(\n        vec4(vX.x, vX.y, vX.z, 0.),\n        vec4(vY.x, vY.y, vY.z, 0.),\n        vec4(vZ.x, vZ.y, vZ.z, 0.),\n        vec4(0., 0., 0., 1.)\n    );\n    \n    return avLookAt;\n}\n\n// provide a perspective projection matrix\nmat4x4 PerspectiveLH(vec2 vFov, vec2 vZnf)\n{\n    float fW = tan(vFov.x*0.5),\n          fH = tan(vFov.y*0.5);\n    \n    mat4x4 avProj = mat4x4( 0.0 );\n    avProj[0][0] = 2. * vZnf.x / fW;\n    avProj[1][1] = 2. * vZnf.x / fH;\n    avProj[2][2] = vZnf.y / (vZnf.y - vZnf.x);\n    avProj[3][2] = 1.;\n    avProj[2][3] = vZnf.x*vZnf.y/(vZnf.x - vZnf.y);\n    \n    return avProj;  \n}\n\n// transform a ray based on screen position, camera position and inverse wvp matrix - Microsoft method\nvoid TransformRay(in uvec2 sIndex, in vec2 sScreenSz, in vec4 vCamPos, in mat4x4 sWVPrInv,\n\tout vec3 vOrigin, out vec3 vDirection)\n{\n\t// center in the middle of the pixel, get screen position\n\tvec2 vXy = vec2(sIndex.xy) + 0.5f;\n\tvec2 vUv = vXy / sScreenSz.xy * 2.0 - 1.0;\n\t\n\t// unproject by inverse wvp\n\tvec4 vWorld = vec4(vUv, 0, 1) * sWVPrInv;\n\n\tvWorld.xyz /= vWorld.w;\n\tvOrigin = vCamPos.xyz;\n\tvDirection = normalize(vWorld.xyz - vOrigin);\n    vDirection += vec3(vDirection.x==0.0, vDirection.y==0.0, vDirection.z==0.0) * 1e-5;\n}","name":"Common","description":"","type":"common"}]}