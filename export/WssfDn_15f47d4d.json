{"ver":"0.1","info":{"id":"WssfDn","date":"1588206205","viewed":671,"name":"Fast 2D BVH","username":"rory618","description":"Implementing this paper: https://devblogs.nvidia.com/wp-content/uploads/2012/11/karras2012hpg_paper.pdf","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["volume","hierarchy","bounded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Draw 16 thousand line segments along a parametric curve\n//See:\n//https://www.shadertoy.com/view/WssfDn\n//https://www.shadertoy.com/view/Wdlfz7\n//https://www.shadertoy.com/view/tdlBz7\n//https://www.shadertoy.com/view/wdsBRn\n//for all the utilities and algorithm leading up to this,\n//and the paper: https://devblogs.nvidia.com/wp-content/uploads/2012/11/karras2012hpg_paper.pdf\n\ngetters}\n\nbool inBBox(vec4 BBox, vec2 p){\n    return (p.x>BBox.x&&p.y>BBox.y&&p.x<BBox.z&&p.y<BBox.w);\n}\n\nvec4 DFS(vec2 I){\n    float d = 1e8;\n    int count = 0;\n    vec2 coord = (floor(I/R.xy*1024.)+.5)/1024.;\n    int[] stack_data = int[] (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    int stack_pos = -1;\n    int v = 0;\n    \n    #define pop() stack_data[stack_pos--]\n    #define push(data)  stack_data[++stack_pos] = data\n    \n    int node = 0;\n    vec4 bbox = sampleIndexStage(node, BBoxStageFinal);\n    if (!inBBox(bbox,coord)){\n        return vec4(d,0,0,0);\n    }  \n    count++;\n    for(int k = 0; k < 100; k++){\n        vec4 node_data = sampleIndexStage(node, BBoxStageFinal-BBoxStages+1);\n        int childLeft = int(node_data.x) + int(node_data.y)*128;\n        int childRight = int(node_data.z) + int(node_data.w)*128;\n        bool leafLeft = childLeft >= 16384;\n        bool leafRight = childRight >= 16384;\n        \n        \n        vec4 pDataLeft = sampleIndexStage(childLeft % 16384, sortedStage+BBoxStages-1);\n        vec4 pDataRight = sampleIndexStage(childRight % 16384, sortedStage+BBoxStages-1);\n        \n        vec4 bboxLeft = leafLeft?leafToBBox(pDataLeft):sampleIndexStage(childLeft % 16384, BBoxStageFinal);\n        vec4 bboxRight = leafRight?leafToBBox(pDataRight):sampleIndexStage(childRight % 16384, BBoxStageFinal);\n        bool validLeft = inBBox(bboxLeft,coord);\n        bool validRight = inBBox(bboxRight,coord);\n        v += int(validLeft&&validRight);\n        count += int(validLeft);\n        count += int(validRight);\n        validLeft = validLeft && (!leafLeft);\n        validRight = validRight && (!leafRight);\n        \n        \n        \n        \n        \n        if(validRight){\n            if(validLeft){\n                //Push right, go left\n                push(childRight);\n                node = childLeft;\n                //v++;\n            } else {\n                //Go right\n                node = childRight;\n            }\n        } else {\n            if(validLeft){\n                //Go left\n                node = childLeft;\n            } else {\n                //Go up stack\n                if(stack_pos >= 0){\n                    node = pop();\n                } else {\n                    return vec4(d,count,v,0);\n                }\n            }\n        }\n    }\n        \n    return vec4(d,count,v,1);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 I )\n{   \n    //Dot Dot Dot while pipeline fills up\n    if(iFrame<BVHStage0){\n        float fracDone = float(iFrame) / float(BVHStage0);\n        vec2 c = mod(I,R.xy/vec2(3,1));\n        O = vec4(min(1.,R.x/30.-length(c-R.xy/vec2(6,2))));\n        O *= .25+.75*vec4(I.x/R.x<floor(fracDone*4.)/3.);\n    } else {\n        I = (I-R.xy/2.) * vec2(R.x/R.y,1) + R.xy/2.;\n        O = DFS(I);\n        \tO = O.yzwx / vec4(30, 1, 1,1);\n            O = O.xxxx;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"getters}\n\n//Generate random particles each frame, and use a pipelined bitonic sorting network to arrange them in a list\n//so that they are in ascending order along a z curve covering uv space, saving the xy coordinate at each step.\n\n//Get the partner to be compared with for a bitonic sort at a given stage\n//See https://en.wikipedia.org/wiki/Bitonic_sorter#Alternative_representation\nint getPartner(int x, int s){\n    float j = floor(sqrt(float(2*s)+1.25)-0.5);\t\t//Major stage\n    float n = floor(float(s) - 0.5*(j*j+j) + 0.5);\t//Minor stage\n    float b = floor(exp2(j-n+1.)+0.5);\t\t\t\t//Block size\n    float bot = floor(float(x)/b)*b;\t\t\t\t//Bottom index in block \n    float top = bot + b - 1.;\t\t\t\t\t\t//Top index in block\n    if(n<0.5){\t\t\t\t\t\t\t\t\t\t//Swap with opposite index in block\n        return int(top - (float(x)-bot) + 0.5);\n    }else{\t\t\t\t\t\t\t\t\t\t\t//Swap with index a constant distance away in block\n        if(float(x)-bot < b/2.-0.5){\n            return int(float(x) + b/2. + 0.5);\n        }else{\n            return int(float(x) - b/2. + 0.5);\n        }\n    }\n}\n\n\n\n//Combine two bounding boxes, return null bbox if one of the bboxes is also null\nvec4 mergeBBox(vec4 A, vec4 B){\n    if(A==vec4(-1) || B==vec4(-1)){\n        return vec4(-1);\n    }\n    return vec4( min(A.xy,B.xy), max(A.zw,B.zw) );\n}\n\nvoid mainCubemap( out vec4 O, in vec2 I, in vec3 rayOri, in vec3 rayDir )\n{\n    \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n    ivec2 XYTall = ivec2(XYFace.x, XYFace.y + 1024*XYFace.z);\n    if(XYTall.y < 16){\n        //Spawn particles along a wibbly wobbly curve\n        int seed = XYFace.x + XYFace.y*2000 + iFrame*2000*2000;\n        seed = IHash(seed);\n        vec2 r0 = normalize(randn(rand2(seed)));\n        vec2 coord = .5+r0/4.;\n        seed = 0;\n        for(int k = 0; k < 10; k++){\n        \tseed = IHash(seed);\n            coord += .005*float(k+1)*cos(vec2(0,1.5)+iTime*rand2(seed) + rand2(seed)*6.282 +float(k+1)*2.*dot(r0, randn(rand2(seed))))*randn(rand2(seed));\n        }\n        coord = clamp(coord,vec2(0),vec2(1));\n        O.xy = coord;\n    } else  {\n        int stage = XYTall.y/16;\n        int sortStage = stage - 1;\n        int index = XYTall.x*16 + (XYTall.y%16);\n        if(stage<106){\n        \t//Execute the sorting network swaps\n            int partner = getPartner(index,sortStage);\n            vec4 A = sampleIndexStage(index, stage-1);\n            vec4 B = sampleIndexStage(partner, stage-1);\n            int zA = ZOrder(A.xy);\n            int zB = ZOrder(B.xy);\n            if(index > partner){\n                if(zA>zB){\n                    O=A;\n                } else {\n                    O=B;\n                }\n            } else {\n                if(zA>zB){\n                    O=B;\n                } else {\n                    O=A;\n                }\n            }\n        } else if(stage==BVHStage0){\n            //Fetch the BVH graph from buf A\n            vec4 A = texelFetch(iChannel1, ivec2(index%128, index/128), 0);\n            int childLeft = int(A.z);\n            int childRight = int(A.w);\n            //Pack a 15 bit integer into a pair of cubemap channels\n            O = vec4(childLeft%128,childLeft/128,childRight%128,childRight/128);\n        } else if(stage>=BBoxStage0){\n            //Compute the bounding boxes from leaf nodes upwards towards the root node\n            vec4 BBox = sampleIndexStage(index, stage-1);\n            if(BBox == vec4(-1) || stage==BBoxStage0){\n                vec4 node = sampleIndexStage(index, stage-BBoxStages);\n\n                int childLeft = int(node.x) + int(node.y)*128;\n                int childRight = int(node.z) + int(node.w)*128;\n\n                vec4 bboxLeft = stage==BBoxStage0?vec4(-1):sampleIndexStage(childLeft, stage-1);\n                vec4 bboxRight = stage==BBoxStage0?vec4(-1):sampleIndexStage(childRight, stage-1);\n\n                //Particle 'nodes' are indexed starting from 16384. Make a 1x1 bounding box if its a particle\n                if(childLeft>=16384){\n                    childLeft -= 16384;\n                    vec2 point = sampleIndexStage(childLeft, sortedStage+stage-BBoxStage0+1).xy;\n                    bboxLeft = vec4(floor(point*1024.)/1024.,(floor(point*1024.)+1.)/1024.);\n                }\n                if(childRight>=16384){\n                    childRight -= 16384;\n                    vec2 point = sampleIndexStage(childRight, sortedStage+stage-BBoxStage0+1).xy;\n                    bboxRight = vec4(floor(point*1024.)/1024.,(floor(point*1024.)+1.)/1024.);\n                }\n                O = mergeBBox(bboxLeft, bboxRight);\n            } else {\n                O = BBox;\n            }\n            \n        } else {\n            //Keep shifting the result down so that JFA pipeline always can find the particles\n            O = sampleIndexStage(index, stage-1);\n        }\n        \n    }\n    \n    \n}\n    \n","name":"Cube A","description":"","type":"cubemap"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n\nconst int sortedStage = 106;\nconst int BBoxStages = 30;\nconst int BVHStage0 = sortedStage+BBoxStages;\nconst int BBoxStage0 = BVHStage0+BBoxStages;\nconst int BBoxStageFinal = BBoxStage0 + BBoxStages - 3;\n\nvec4 leafToBBox(vec4 data){\n    vec2 point = data.xy;\n    return vec4(floor(point*1024.)/1024.,(floor(point*1024.)+1.)/1024.);\n}\n\n//Line segment sdf\nfloat dLine(vec2 p, vec2 a, vec2 b){\n    p-=a;\n    b-=a;\n    float l2 = dot(b,b);\n    p -= b*clamp(dot(p,b/l2),0.,1.);\n    return length(p);\n}\n\n\n//Magic to convert a binary number 0xbbbb into 0x0b0b0b0b\nint spreadBits(int word){\n    word = (word ^ (word << 8 )) & 0x00ff00ff;\n    word = (word ^ (word << 4 )) & 0x0f0f0f0f;\n    word = (word ^ (word << 2 )) & 0x33333333;\n    word = (word ^ (word << 1 )) & 0x55555555;\n    return word;\n}\n\n//Convert a 0-1 xy coordinate to a 20 bit morton/z order code\nint ZOrder(vec2 coord){\n    int x = int(coord.x*1024.);\n    int y = int(coord.y*1024.);\n    return spreadBits(x) | (spreadBits(y)<<1);\n}\n    \n//Random number functions\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n   \n//Cubemap utils to convert between a 1024 x 1024 x 6 buffer coordinate to a cubemap ray direction\nvec3 XYFaceToRayDir(ivec3 p){\n    vec2 x = vec2(p-512) + 0.5;\n           if (p.z==0){     return vec3( 512,-x.y,-x.x);\n    } else if (p.z==1){     return vec3( x.x, 512, x.y);\n    } else if (p.z==2){     return vec3( x.x,-x.y, 512);\n    } else if (p.z==3){     return vec3(-512,-x.y, x.x);\n    } else if (p.z==4){     return vec3( x.x,-512,-x.y);\n    } else if (p.z==5){     return vec3(-x.x,-x.y,-512);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512.0, -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n\n//Functions to sample a particle coordinate from the cubemap as a 1024 x 6144 buffer and a 16384 x 384 buffer\n#define getters \\\nvec4 sampleXYTall(ivec2 XYTall){\\\n    ivec3 XYFace = ivec3(XYTall.x, XYTall.y%1024, XYTall.y/1024);\\\n\treturn texture(iChannel0, XYFaceToRayDir(XYFace));\\\n}\\\nvec4 sampleIndexStage(int index, int stage){\\\n    ivec2 XYTall = ivec2(index/16, index%16+stage*16);\\\n    return sampleXYTall(XYTall);","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"getters}\n\n//Length of the shared prefix of the morton codes of a pair of particles.\n//If the codes are the same, then also count shared bits of the list index which will never be the same.\n//Return -1 if the j particle is outside the range of all particles\nint plen(int i, int j){\n    if(j<0||j>=16384) return -1;\n    int mi = ZOrder(sampleIndexStage(i, sortedStage).xy);\n    int mj = ZOrder(sampleIndexStage(j, sortedStage).xy);\n    if(mi!=mj){\n        int x = mi^mj;\n        float f = log2(float(x)+0.5);\n        return 30 - int(f);\n    } else {\n        int x = i^j;\n        float f = log2(float(x)+0.5);\n        return 60 - int(f);\n    }\n}\n        \nvoid mainImage( out vec4 O, in vec2 I )\n{\n    //index always indicates either the left or right end of the range of particle indecies it contains\n    int i = int(I.x) + int(I.y)*128;\n    \n    //Check direction if this node\n    int d = sign(plen(i,i+1)-plen(i,i-1));\n    \n    //Scan to find the other end of this node, so that all the nodes share a prefix at least \n    //as long as the shared prefix between the first two elements\n    //Scan away to find an upper bound\n    int dmin = plen(i,i-d);\n    int lmax = 2;\n    for(int k = 0; k<16; k++){\n        if (plen(i, i + lmax*d) <= dmin)\n            break;\n        lmax *= 2;\n    }\n    \n    //Scan back with a binary search\n    int l = 0;\n    int t = lmax/2;\n    for(int k = 0; k<16; k++){\n        if (plen(i, i + (l+t)*d) > dmin){\n            l = l+t;\n        }\n        if(t==1) break;\n        t /= 2;\n        \n    }\n    //Compute the other end of the range of particle indecies this node contains\n    int j = i + l * d;\n\n    //Find the split index where the nodes on one side share a different longes prefix from the other\n    int dnode = plen(i, j);\n    int s = 0;\n    float ft = float(l)/2.;\n    for(int k = 0; k<16; k++){\n        t = int(max(1.,ceil(ft)));\n        if(plen(i, i + (s + t) * d ) > dnode){\n            s += t;\n        }\n        ft /= 2.;\n    }\n    //Compute split index\n    int y = i + s * d + min(d,0);\n    \n    //Compute the child node indecies using the split index y and two ends i and j\n    int childLeft;\n    int childRight;\n    if (min(i,j) == y) {\n        childLeft = y + 16384;\n    } else {\n        childLeft = y;\n    }\n    if (max(i,j) == y+1){\n        childRight = (y+1) + 16384;\n    } else {\n        childRight = y+1;\n    }\n    \n    //Safe the left index and right index (just for testing), as well as left and right child nodes\n    O = vec4(min(i,j),max(i,j),childLeft,childRight);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}