{"ver":"0.1","info":{"id":"lcXXzX","date":"1705511294","viewed":89,"name":"Three Elements","username":"parti","description":"Tiling the plane by inversions in 5 circles dividing the plane into 3 regions, based on work of Fricke, Klein, and Cheritat","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","tiling","iis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis limit set of inversion in 5 circles divides the plane into 1 copy of the totally \nconnected purple region and infinitely many disjoint copies of the yellow circular\nregion and green region bounded by a fractal curve.\n\nColors are applied using some polygonal approximations of the green and yellow regions.\n*/\n\nconst vec2[5] cens = vec2[](\n    vec2(2., 0.),\n    vec2(1., 2.),\n    vec2(3., 2.),\n    vec2(-1., 0.),\n    vec2(-1., 3.));\nconst float[5] rads = float[](\n    1.2360679775,\n    1., 1.,\n    1.7639320225,\n    1.2360679775);\nvec2 perp(vec2 v) { return vec2(v.y, -v.x); }\n\nvec2[6] normals;\n    \nvoid doInv(inout vec2 v, inout float i, inout bool fund, int j) {\n    // Invert in 1 circle if appropriate\n    vec2 cen = cens[j];\n    float rad = rads[j];\n    rad *= rad;\n    \n    vec2 diff = v - cen;\n    float dis = dot(diff, diff);\n    if (dis < rad) {\n        v = cen + diff * (rad / dis);\n        fund = false;\n        i ++;\n    }\n}\n\n#define SCL 1.8\n\nvec3 getCol(vec2 p) {\n    // Perform iterated inversion in the 5 circles\n    p = SCL * (2. * p - iResolution.xy) / iResolution.y;\n    p += vec2(.5, 1.25);\n    \n    float i = 0.;\n    bool fund;\n    for (int j = 0; j < 50; j ++) {\n        fund = true;\n        doInv(p, i, fund, 0);\n        doInv(p, i, fund, 1);\n        doInv(p, i, fund, 2);\n        doInv(p, i, fund, 3);\n        doInv(p, i, fund, 4);\n        if (fund) break;\n    }\n    i = .6 + .4 * mod(i, 2.);\n    \n    // Get color based on which region of the invariant set we lie in\n    bool inP0 = (dot(p - cens[0], normals[0]) > 0.);\n    bool inP1 = (dot(p - cens[1], normals[1]) > 0.);\n    bool inP2 = (dot(p - cens[2], normals[2]) > 0.);\n    bool inP3 = (dot(p - cens[0], normals[3]) > 0.);\n    bool inP4 = (dot(p - cens[1], normals[4]) < 0.);\n    bool inP5 = (dot(p - cens[3], normals[5]) < 0.);\n    \n    vec3 col = vec3(0.659,0.420,0.902);\n    if (inP0 && inP1 && inP2) {\n        col = vec3(1.000,0.867,0.000);\n    } else if (inP3 && inP4 && inP5 && !inP0) {\n        col = vec3(0.357,0.765,0.275);\n    }\n    \n    return col * i;\n}\n\nvoid mainImage(out vec4 col, vec2 p) {\n    // Computing normals to the polygonal regions\n    normals[0] = perp(cens[1] - cens[0]);\n    normals[1] = perp(cens[2] - cens[1]);\n    normals[2] = perp(cens[0] - cens[2]);\n    \n    normals[3] = perp(cens[3] - cens[0]);\n    normals[4] = perp(cens[4] - cens[1]);\n    normals[5] = perp(cens[3] - cens[4]);\n\n    // Multisampling\n    vec3 k = getCol(p);\n    k += getCol(p + vec2(.25)); \n    k += getCol(p + vec2(.25, -.25));\n    k += getCol(p + vec2(-.25, .25));\n    k += getCol(p + vec2(-.25));\n    col = vec4(k * .2, 1.);\n}","name":"Image","description":"","type":"image"}]}