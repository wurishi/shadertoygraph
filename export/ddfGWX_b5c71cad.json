{"ver":"0.1","info":{"id":"ddfGWX","date":"1666959473","viewed":144,"name":"Nowhere to land","username":"Alpaga","description":"Perlin noise for both the lava and the mountains.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","perlin","lava"],"hasliked":0,"parentid":"tt2fR1","parentname":"Experiment with Perlin"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Bloom calculated by multi-pass Gaussian blur, explained here:\n// https://learnopengl.com/Advanced-Lighting/Bloom\n\nvec3 blur(vec2 co) {\n    vec3 col = vec3(0);\n    int k=0,l;\n    for(float i=-4.0; i<4.1; i++) {\n        l=0;\n        for(float j=-4.0; j<4.1; j++) {\n            vec2 p = co+blurSize*vec2(i,j);\n            p += hash22(p);\n            vec2 uv = p/iResolution.xy;\n            vec4 tex = texture(iChannel0, uv);\n\n            col += gaussianWeight[k] * gaussianWeight[l] * tex.rgb;\n            l++;\n        }\n        k++;\n    }\n    return col;\n}\n\nvec3 verticalBlur(vec2 co) {\n    vec3 col = vec3(0);\n    int k=0;\n    for(float i=-4.0; i<4.1; i++) {\n        vec2 p = co+blurSize*vec2(0,i);\n        p += hash22(p);\n        vec2 uv = p/iResolution.xy;\n        vec4 tex = texture(iChannel0, uv);\n        \n        col += gaussianWeight[k] * tex.rgb;\n        k++;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel1, uv).rgb;\n    \n    #ifdef TWOPASSBLUR\n    col += verticalBlur(fragCoord);\n    #else\n    col += blur(fragCoord);\n    #endif\n    \n    const float exposure = 2.0;\n\n    col = 1.0 - exp(-col * exposure);\n    col = pow(col, vec3(0.45));\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define TWOPASSBLUR\nconst float blurSize = 2.3;\n\nconst float gaussianWeight[9] = float[] (0.016216, 0.054054, 0.1216216, 0.1945946, 0.227027, 0.1945946, 0.1216216, 0.054054, 0.016216);\n\nfloat brightness(vec3 col) {\n    return dot(col, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// Dave_K=Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPS 1000\n#define FAR 100.0\n\nconst float fov = 35.;\n\nconst vec3 rock = vec3(.6,.01,.02);\nconst vec3 lava = 2.*vec3(1,.5,0);\nconst vec3 fog = vec3(1,0,1);\nfloat maxHeight = 0.8;\nconst float stillLava = .67;\n\nvec2 grad(vec2 p, float t) {\n    float g = floor(t);\n    float f = t-g;\n    return 2.*mix(hash22(p+123.84*g),hash22(p+123.84*(g+1.)),f)-1.;\n}\n\nfloat perlin(vec2 p, float t) {\n \tvec2 g00 = floor(p);\n    vec2 g10 = g00+vec2(1,0), g01 = g00+vec2(0,1), g11 = g00+vec2(1,1);\n    \n    vec2 f = p-g00;\n    f = f*f*(3.-2.*f);\n    \n    return mix(\n            mix(dot(p-g00,grad(g00,t)),\n                dot(p-g10,grad(g10,t)), f.x),\n            mix(dot(p-g01,grad(g01,t)),\n                dot(p-g11,grad(g11,t)), f.x), f.y);\n}\n\n\nfloat fbm(vec2 p, float t) {\n \tfloat h = 0.0;\n    float a = 1.0;\n    float f = 1.0;\n    \n    for(int i=0; i<3; i++) {\n        h += a * perlin(f*p,t);\n        f *= 1.99;\n        a *= 0.8;\n        p = mat2(0.8,0.6,-0.6,0.8)*p;\n    }\n    h += a * perlin(f*p,t);\n    \n    return h;    \n}\n\nfloat terrainHeight(vec2 p) {\n    float h = 1.0-0.5*pow(fbm(p,0.0*iTime),0.8);\n\treturn min(maxHeight,min(h,2.0*maxHeight+0.02-h));\n}\n\nfloat lavaHeight(vec2 p) {\n    return stillLava+.02*(perlin(50.*p,3.*iTime));\n}\n\nfloat sdLava(vec3 p) {\n \treturn 0.5*(p.y-lavaHeight(p.xz));   \n}\nfloat sdTerrain(vec3 p) {\n    if(p.y>2.0)\n        return p.y;\n    return 0.1*(p.y-terrainHeight(p.xz));\n}\nfloat de(vec3 p, out int id) {\n    float minD = 1e6;\n    float d;\n    \n    d = sdTerrain(p);\n    if(d<minD) {\n        minD = d;\n        id = 0;\n    }\n\n    d = sdLava(p);\n    if(d<minD) {\n        minD = d;\n        id = 1;\n    }\n    return minD;\n}\n\n// Returns (distance, object id, nubmer of steps)\nfloat march(vec3 start, vec3 dir, out int id) {\n\tfloat total = 0., d;\n    vec3 p;\n    float epsilon = 0.5/iResolution.y;\n    \n    int i=0;\n    for(; i<STEPS; i++) {\n        p = start + total * dir;\n        d = de(p,id);\n        if(d<epsilon*total || total>FAR) break;\n        total += d;\n    }\n    if(total>FAR || i==STEPS) id = -1;\n    return total;\n}\n\n\nvec3 pixelColor(vec3 start, vec3 dir) {\n \tvec3 col;\n    int id;\n    float d = march(start, dir, id);\n    vec3 p = start + d * dir;\n    switch(id) {\n        case -1:// No intersection\n            return fog;\n        case 0:// Terrain\n            col = rock*(lava*exp(-50.*(p.y-stillLava-.02)));\n            break;\n        case 1:// Lava\n            col = mix(lava,vec3(1,0,0),100.*(p.y-stillLava));\n            break;\n    }\n    \n    return mix(fog,col,exp(-.03*d));\n}\n\n\nmat3 viewMatrix(vec3 forward, vec3 up) {\n \tvec3 w = -normalize(forward);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    \n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    float t = .2*iTime;\n    vec3 cam = vec3(sin(t),1.,33.-t);\n    vec3 forward = vec3(-.3*sin(t),-.55+.2*cos(2.3*t),-1);\n    \n    mat3 m = viewMatrix(forward, vec3(0,1,0));\n\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    col = pixelColor(cam, dir);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec3 selectAndHorizontalBlur(vec2 co) {\n    vec3 col = vec3(0);\n    int k=0;\n    for(float i=-4.0; i<4.1; i++) {\n        vec2 p = co+blurSize*vec2(i,0);\n        p += hash22(p);\n        vec2 uv = p/iResolution.xy;\n        vec4 tex = texture(iChannel0, uv);\n        \n        float bright = brightness(tex.rgb);\n\n        if(bright > 1.)\n            col += gaussianWeight[k] * tex.rgb;\n        k++;\n    }\n    return col;\n}\n\nvec3 selectAndBlur(vec2 co) {\n    vec3 col = vec3(0);\n    int k=0,l;\n    for(float i=-4.0; i<4.1; i++) {\n        l=0;\n        for(float j=-4.0; j<4.1; j++) {\n            vec2 p = co+blurSize*vec2(i,j);\n            p += hash22(p);\n            vec2 uv = p/iResolution.xy;\n            vec4 tex = texture(iChannel0, uv);\n\n            float bright = brightness(tex.rgb);\n\n            if(bright > 1.)\n                col += gaussianWeight[k] * gaussianWeight[l] * tex.rgb;\n            l++;\n        }\n        k++;\n    }\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    #ifdef TWOPASSBLUR\n    vec3 col = selectAndHorizontalBlur(fragCoord);\n    #else\n    vec3 col = selectAndBlur(fragCoord);\n    #endif\n    fragColor = vec4(col,1);\n}","name":"Buffer B","description":"","type":"buffer"}]}