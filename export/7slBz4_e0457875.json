{"ver":"0.1","info":{"id":"7slBz4","date":"1644592940","viewed":75,"name":"Test nonlinear texture sampling","username":"fxslava","description":"Test nonlinear texture sampling","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["nonlinearsampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 1E-2;\n\nvec3 hitABCD(vec2 A, vec2 B, vec2 C, vec2 D, vec2 uv)\n{\n    vec2 P = uv - A;\n    vec2 BA = B - A;\n    vec2 CA = C - A;\n    vec2 DC = D - C;\n    \n    vec2 tmp0 = DC - BA;\n    float a = BA.y * tmp0.x - BA.x * tmp0.y;\n    \n    if (abs(a) < EPSILON) {\n        float t0 = dot(P,CA);\n        float t1 = dot(C-uv,CA);\n        \n        if (abs(t0 + t1) < EPSILON)\n            return vec3(0.0f, 0.0f, 0.0f);\n            \n        float v = t0 / (t0 + t1);\n        \n        if (v < 0.0f || v > 1.0f)\n            return vec3(0.0f, 0.0f, 0.0f);\n        \n        vec2 tmp1 = BA + tmp0 * v;\n        \n        float u;\n        if (abs(tmp1.x) > abs(tmp1.y))\n            u = (P.x - CA.x * v) / tmp1.x;\n        else\n            u = (P.y - CA.y * v) / tmp1.y;\n            \n        if (u < 0.0f || u > 1.0f)\n            return vec3(0.0f, 0.0f, 0.0f);\n            \n        return texture(iChannel0, vec2(u, v)).rgb;\n    }\n    \n    float b = P.x * tmp0.y - BA.x * CA.y - P.y * tmp0.x + BA.y * CA.x;\n    float c = P.x * CA.y - P.y * CA.x;\n    \n    float Disc = b * b - 4.0f * a * c;\n    if (Disc < EPSILON) {\n        return vec3(0.0f, 0.0f, 0.0f);\n    }\n    \n    Disc = sqrt(Disc);\n    \n    float u0 = (-b + Disc) / (2.0f * a);\n    float u1 = (-b - Disc) / (2.0f * a);\n    \n    float u = -1.0;\n    if (u0 >= 0.0f && u0 <= 1.0f)\n        u = u0;\n    if (u1 >= 0.0f && u1 <= 1.0f)\n        u = u1;\n    if (u < 0.0f || u > 1.0f)\n        return vec3(0.0f, 0.0f, 0.0f);\n      \n    vec2 tmp1 = CA + tmp0 * u;   \n    \n    float v;\n    if (abs(tmp1.x) < abs(tmp1.y))\n        v = (P.x - BA.x * u) / tmp1.x;\n    else\n        v = (P.y - BA.y * u) / tmp1.y;\n    \n    if (v < 0.0f || v > 1.0f)\n        return vec3(0.0f, 0.0f, 0.0f);\n    \n    return texture(iChannel0, vec2(u, v)).rgb;\n}\n\nvec3 sampleMSAA_ABCD(vec2 A, vec2 B, vec2 C, vec2 D, vec2 uv)\n{\n    vec3 sum = vec3(0.0f, 0.0f, 0.0f);\n    \n    sum += hitABCD(A,B,C,D,uv + vec2(0.375, 0.125));\n    sum += hitABCD(A,B,C,D,uv + vec2(0.875, 0.375));\n    sum += hitABCD(A,B,C,D,uv + vec2(0.625, 0.875));\n    sum += hitABCD(A,B,C,D,uv + vec2(0.125, 0.625));\n    \n    return sum * 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 A = vec2(0.15f, 0.25f) * iResolution.xy;\n    vec2 B = vec2(0.15f, 0.65f) * iResolution.xy;\n    vec2 C = vec2(0.65f, 0.25f) * iResolution.xy;\n    vec2 D = iMouse.xy; //vec2(0.65f, 0.55f) * iResolution.xy;\n\n    vec3 col = sampleMSAA_ABCD(A,B,C,D,fragCoord);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}