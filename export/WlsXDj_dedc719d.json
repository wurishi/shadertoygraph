{"ver":"0.1","info":{"id":"WlsXDj","date":"1564407255","viewed":197,"name":"Learning rgb to spectral mapping","username":"MoltenQwartz","description":"Wanted to see if we could learn the inverse of the cie color matching functions with a neural network.\nDoing this for albedo, so all values are normalized in 0 and 1.\nSee shader comment for details","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rgb","spectral","neuralnetwork","decoder","deepfeed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COMPARE_WITH_RGB_ALBDEO\n//#define ABSOLUTE_VALUE\n#define PLOT_SPECTRUM\n\n\n// Learning inverse CIE color matching functions:\n// Decided to see if we could learn the following function with a neural network:\n// * given a rgb albedo, find it's corresponding spectrall albedo.\n// database: 8 spectral samples with each 5 albedo samples (so 5^9 = â€­1,953,125 data points)\n// * for each spectral data point I compute its rgb albedo (https://fr.wikipedia.org/wiki/CIE_XYZ)\n// * feed that in a deep-feed 3x16x8 neural network and train it for 25 epochs\n// => see how good it is:\n// given a rgb color, reconstruct it's spectrum and then convert back to rgb to see how far we match\n\n// error term in the top left, numerical value bottom left, color ramp on the right\n// left: rgb albedo\n// right: rgb -> spectral via the NN -> rgb\n// middle reconstructed historgram\n\n\n// https://solarianprogrammer.com/2013/02/28/mandelbrot-set-cpp-11/\nvec3 colorRamp(float t)\n{\n    t = mix(0.0,0.85,t);\n\tfloat r = (9.0  * (1.0-t)*t*t*t);\n  \tfloat g = (15.0 * (1.0-t)*(1.0-t)*t*t);\n  \tfloat b = (8.5  * (1.0-t)*(1.0-t)*(1.0-t)*t);\n    \n    return vec3(r,g,b);\n}\n\n\nfloat BlackBoddyRadiation(float lambda, float T)\n{\n    // lambda in nm\n    return 1.19104f*pow(10.0f, 19.0f) / pow(lambda, 5.0f) * 1.0f / (exp(1.4387769599838158*pow(10.0,7.0) / (lambda*T)) - 1.0f);\n}\n\n\n// Spectrum to xyz approx function from \"Simple Analytic Approximations to the CIE XYZ Color Matching Functions\"\n// http://jcgt.org/published/0002/02/01/paper.pdf\n//Inputs:  Wavelength in nanometers\nfloat xFit_1931(float wave)\n{\n    float t1 = (wave - 442.0f)*((wave < 442.0f) ? 0.0624f : 0.0374f);\n    float t2 = (wave - 599.8f)*((wave < 599.8f) ? 0.0264f : 0.0323f);\n    float t3 = (wave - 501.1f)*((wave < 501.1f) ? 0.0490f : 0.0382f);\n    return 0.362f*exp(-0.5f*t1*t1) + 1.056f*exp(-0.5f*t2*t2) - 0.065f*exp(-0.5f*t3*t3);\n}\nfloat yFit_1931(float wave)\n{\n    float t1 = (wave - 568.8f)*((wave < 568.8f) ? 0.0213f : 0.0247f);\n    float t2 = (wave - 530.9f)*((wave < 530.9f) ? 0.0613f : 0.0322f);\n    return 0.821f*exp(-0.5f*t1*t1) + 0.286f*exp(-0.5f*t2*t2);\n}\nfloat zFit_1931(float wave)\n{\n    float t1 = (wave - 437.0f)*((wave < 437.0f) ? 0.0845f : 0.0278f);\n    float t2 = (wave - 459.0f)*((wave < 459.0f) ? 0.0385f : 0.0725f);\n\n    return 1.217f*exp(-0.5f*t1*t1) + 0.681f*exp(-0.5f*t2*t2);\n}\n\n// RGB-XYZ Matrix Calculator\n// http://www.russellcottrell.com/photo/matrixCalculator.htm\n// Based on equations found here:\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// And Rec. 2020 values found here:\n// https://en.wikipedia.org/wiki/Rec._2020\n// https://en.wikipedia.org/wiki/Rec._709\n// https://en.wikipedia.org/wiki/SRGB\nvec3 XYZtosRGB(vec3 XYZ)\n{\n    vec3 rgb;\n    rgb.x = XYZ.x *  3.2409699f + XYZ.y * -1.5373832f + XYZ.z * -0.4986108f;\n    rgb.y = XYZ.x * -0.9692436f + XYZ.y *  1.8759675f + XYZ.z *  0.0415551f;\n    rgb.z = XYZ.x *  0.0556301f + XYZ.y * -0.2039770f + XYZ.z *  1.0569715f;\n    \n    return rgb;\n}\n\n\n// Data:\n// 8 spectral samples with each 4 albedo samples\n\n\n// Neural Net used:\n//\n// DeepFeed Decoder:\n// Net(\n//  (l1): Linear(in_features=3, out_features=16, bias=True)\n//  (l2): Linear(in_features=16, out_features=8, bias=True)\n//  (drop): Dropout(p=0.16)\n//  (relu): ReLU()\n// )\n// Optimizer \n// Adam (\n// \tParameter Group 0\n//    amsgrad: False\n//    betas: (0.9, 0.999)\n//    eps: 1e-08\n//    lr: 0.01\n//    weight_decay: 0\n//  )\n// Loss function:\n// MSELoss\n// 100 epochs and training set of 8 batches\n\n\nconst int SPECTRAL_SAMPLES = 8;\n\nfloat ReLU(float x)\n{\n    return max(x,0.0f);\n}\n\n\n\nconst float w00 = 4.3595e-02,   w10  = -3.1476e-02, w20 = -5.8107e-01;\nconst float w01 = -1.4793e+03,  w11  = -6.7962e-01, w21 = -2.3335e-01;\nconst float w02 = -3.3149e-02,  w12  = -2.5060e-01, w22 = 3.9968e-02;\nconst float w03 = 8.1560e-02,   w13  = 7.7192e-01,  w23 = 7.5947e-02;\nconst float w04 = -4.6421e+01,  w14  = -5.0259e+00, w24 = -2.1791e+00;\nconst float w05 = -9.7993e-03,  w15  = 3.6363e-02,  w25 = 3.9807e-01;\nconst float w06 = 7.0393e-01,   w16  = -9.3157e-02, w26 =  4.5423e-02;\nconst float w07 = -1.5945e-01,  w17  = -4.5677e-01, w27 = -1.0775e+03;\nconst float w08 = -5.5718e-01,  w18  = -8.7693e-02, w28 = 7.0821e-02;\nconst float w09 = -1.7925e-01,  w19  = -3.0595e+00, w29 = -2.0702e-01;\nconst float w010 = -4.2311e-01, w110 =  6.6745e-02, w210 =-5.1617e-02;\nconst float w011 = -2.3776e-02, w111 = -5.8520e-03, w211 = 4.4278e-01;\nconst float w012 = -4.0716e-02, w112 = -7.3727e-01, w212 =-9.9710e-02;\nconst float w013 = -5.8836e+00, w113 = -5.0884e+00, w213 = -1.4280e-01;\nconst float w014 = 1.0151e+01,  w114 = -1.7810e-01, w214 =-3.7304e-02;\nconst float w015 = -1.2830e-01, w115 = -2.3409e-01, w215 =-2.2982e+00;\n\n\nconst float b00 = 2.6832e-01, b01 = -1.2836e-04, b02 = -5.3636e-01, b03 = -5.0085e-01, b04 = -5.2574e-02, b05 = -1.8373e-01, b06 = -4.5462e-01, b07 =  6.9781e-01, b08 = -3.8113e-01, b09 =  9.0615e-01, b010 = 2.3434e-01, b011 = -4.4263e-01, b012 =  5.0721e-01, b013 =  7.1794e-01, b014 = -1.0161e+01, b015 = -6.9314e-04;\n\n\n\nconst float w1_0_0 = 1.4869e-01, w1_0_1 = -8.1650e-02, w1_0_2 =  3.4458e-02, w1_0_3 =  1.1598e-01, w1_0_4 = -4.3683e-01, w1_0_5 =\n          2.7049e-01, w1_0_6 = -1.0841e-02, w1_0_7 = -4.2027e-01, w1_0_8 = -9.9157e-02, w1_0_9 =  1.8453e-02, w1_0_10 =\n         -2.4080e-01, w1_0_11 =  1.4795e-01, w1_0_12 =  8.8743e-02, w1_0_13 = -3.5347e-02, w1_0_14 =  2.2526e-02, w1_0_15 =\n          1.4963e-01;\nconst float w1_1_0 =-2.0604e+00, w1_1_1 = -1.7345e-01, w1_1_2 =  2.4242e-01, w1_1_3 =  5.0022e-02, w1_1_4 = -5.3752e-01, w1_1_5 =\n          2.4176e+00, w1_1_6 =  1.5159e-01, w1_1_7 = -5.3657e+02, w1_1_8 =  5.1819e-02, w1_1_9 =  5.8423e-02, w1_1_10 =\n         -1.5722e-01, w1_1_11 =  1.0787e+00, w1_1_12 = -5.0543e-02, w1_1_13 =  4.2137e-02, w1_1_14 =  1.8683e-01, w1_1_15 =\n         -7.2699e+00;\nconst float w1_2_0 = 6.8076e-02, w1_2_1 =  6.0177e-01, w1_2_2 =  2.7833e-02, w1_2_3 =  1.0711e+00, w1_2_4 = -1.4527e+00, w1_2_5 =\n          4.7527e-01, w1_2_6 = -3.9057e-01, w1_2_7 = -7.4254e-01, w1_2_8 =  2.7527e-02, w1_2_9 = -4.2859e-01, w1_2_10 =\n          6.4248e-01, w1_2_11 = -5.5684e-02, w1_2_12 = -2.1725e-01, w1_2_13 = -7.3958e-01, w1_2_14 = -4.1862e-01, w1_2_15 =\n          2.4326e-01;\n        const float w1_3_0 =-4.6008e-02, w1_3_1 = -3.6472e-01, w1_3_2 =  6.1471e-03, w1_3_3 =  1.2667e+00, w1_3_4 = -3.3843e+00, w1_3_5 =\n         -2.8041e-01, w1_3_6 = -2.7613e-02, w1_3_7 =  3.5503e-01, w1_3_8 = -4.2553e-03, w1_3_9 = -1.0422e+01, w1_3_10 =\n         -6.2291e-02, w1_3_11 =  1.2074e-01, w1_3_12 = -1.6526e+00, w1_3_13 = -1.2541e+02, w1_3_14 =  2.0627e-01, w1_3_15 =\n         -1.9074e-01;\nconst float w1_4_0 = 2.1955e-01, w1_4_1 = -6.1627e+02, w1_4_2 =  1.1362e-01, w1_4_3 =  3.1972e-01, w1_4_4 = -9.4067e+01, w1_4_5 =\n         -2.2732e-01, w1_4_6 =  1.3655e+00, w1_4_7 = -9.4482e-02, w1_4_8 =  2.8363e-02, w1_4_9 = -1.6398e-01, w1_4_10 =\n         -2.0135e+00, w1_4_11 =  1.5074e-01, w1_4_12 = -8.4839e-02, w1_4_13 = -2.6666e+02, w1_4_14 =  7.7444e-01, w1_4_15 =\n          1.1598e-01;\n        const float w1_5_0 =-3.4385e-02, w1_5_1 = -5.6555e-01, w1_5_2 =  5.9938e-02, w1_5_3 =  8.1368e-02, w1_5_4 = -5.5645e+00, w1_5_5 =\n         -2.3706e-02, w1_5_6 =  3.7818e-01, w1_5_7 =  8.6533e-02, w1_5_8 = -1.8806e-01, w1_5_9 =  5.9824e-02, w1_5_10 =\n         -3.4071e-01, w1_5_11 = -1.1723e-01, w1_5_12 =  2.7788e-02, w1_5_13 = -1.5640e+00, w1_5_14 =  2.8584e-01, w1_5_15 =\n          4.2574e-02;\nconst float w1_6_0 = 4.3056e-03, w1_6_1 =  5.1210e-02, w1_6_2 = -2.0775e-02, w1_6_3 =  5.8269e-03, w1_6_4 = -4.6516e-01, w1_6_5 =\n         -1.3251e-01, w1_6_6 =  7.8069e-02, w1_6_7 = -7.6247e-02, w1_6_8 =  3.3633e-02, w1_6_9 = -2.1423e-02, w1_6_10 =\n         -1.2306e-02, w1_6_11 = -2.0884e-02, w1_6_12 = -1.1336e-02, w1_6_13 = -1.1804e-02, w1_6_14 = -5.9156e-02, w1_6_15 =\n         -6.1297e-02;\nconst float w1_7_0 = 2.5623e-02, w1_7_1 =  1.3244e-02, w1_7_2 =  1.7861e-01, w1_7_3 =  9.8431e-02, w1_7_4 =  3.2644e-01, w1_7_5 =\n         -1.2543e-01, w1_7_6 =  5.3880e-02, w1_7_7 =  7.2826e-02, w1_7_8 = -3.2922e-02, w1_7_9 =  1.8254e-02, w1_7_10 =\n         -1.1550e-01, w1_7_11 =  7.9355e-03, w1_7_12 = -6.9534e-03, w1_7_13 = -2.9768e-02, w1_7_14 = -8.5569e-02, w1_7_15 =\n          9.8824e-02;\n\n\nconst float b10 = 0.5065, b11 = 0.5755, b12 = 0.4570, b13 = 0.6533, b14 = 0.4798, b15 = 0.5000, b16 = 0.4904, b17 = 0.5295;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \tvec3 rgbAlebdoBase = 0.5 + 0.5*cos(iTime*0.5+vec3(0,2,4));\n\n    \n    float x0 = rgbAlebdoBase.r, x1 = rgbAlebdoBase.g, x2 = rgbAlebdoBase.b;\n   \n    \n    float x00  = ReLU(w00  * x0 + w10 * x1 + w20 * x2 + b00);\n    float x01  = ReLU(w01  * x0 + w11 * x1 + w21 * x2 + b01);\n    float x02  = ReLU(w02  * x0 + w12 * x1 + w22 * x2 + b02);\n    float x03  = ReLU(w03  * x0 + w13 * x1 + w23 * x2 + b03);\n    float x04  = ReLU(w04  * x0 + w14 * x1 + w24 * x2 + b04);\n    float x05  = ReLU(w05  * x0 + w15 * x1 + w25 * x2 + b05);\n    float x06  = ReLU(w06  * x0 + w16 * x1 + w26 * x2 + b06);\n    float x07  = ReLU(w07  * x0 + w17 * x1 + w27 * x2 + b07);\n    float x08  = ReLU(w08  * x0 + w18 * x1 + w28 * x2 + b08);\n    float x09  = ReLU(w09  * x0 + w19 * x1 + w29 * x2 + b09);\n    float x010 = ReLU(w010 * x0 + w110 * x1 + w210 * x2 + b010);\n    float x011 = ReLU(w011 * x0 + w111 * x1 + w211 * x2 + b011);\n    float x012 = ReLU(w012 * x0 + w112 * x1 + w212 * x2 + b012);\n    float x013 = ReLU(w013 * x0 + w113 * x1 + w213 * x2 + b013);\n    float x014 = ReLU(w014 * x0 + w114 * x1 + w214 * x2 + b014);\n    float x015 = ReLU(w015 * x0 + w115 * x1 + w215 * x2 + b015);\n\n    float albedoSpectrum[SPECTRAL_SAMPLES];\n    albedoSpectrum[0] = ReLU(x00 * w1_0_0 + x01 * w1_0_1 + x02 * w1_0_2 + x03 * w1_0_3 + x04 * w1_0_4 + x05 * w1_0_5 + x06 * w1_0_6 + x07 * w1_0_7 + x08 * w1_0_8 + x09 * w1_0_9 + x010 * w1_0_10 + x011 * w1_0_11 + x012 * w1_0_12 + x013 * w1_0_13 + x014 * w1_0_14 + x014 * w1_0_15 + b10);\n    albedoSpectrum[1] = ReLU(x00 * w1_1_0 + x01 * w1_1_1 + x02 * w1_1_2 + x03 * w1_1_3 + x04 * w1_1_4 + x05 * w1_1_5 + x06 * w1_1_6 + x07 * w1_1_7 + x08 * w1_1_8 + x09 * w1_1_9 + x010 * w1_1_10 + x011 * w1_1_11 + x012 * w1_1_12 + x013 * w1_1_13 + x014 * w1_1_14 + x014 * w1_1_15 + b11);\n    albedoSpectrum[2] = ReLU(x00 * w1_2_0 + x01 * w1_2_1 + x02 * w1_2_2 + x03 * w1_2_3 + x04 * w1_2_4 + x05 * w1_2_5 + x06 * w1_2_6 + x07 * w1_2_7 + x08 * w1_2_8 + x09 * w1_2_9 + x010 * w1_2_10 + x011 * w1_2_11 + x012 * w1_2_12 + x013 * w1_2_13 + x014 * w1_2_14 + x014 * w1_2_15 + b12);\n    albedoSpectrum[3] = ReLU(x00 * w1_3_0 + x01 * w1_3_1 + x02 * w1_3_2 + x03 * w1_3_3 + x04 * w1_3_4 + x05 * w1_3_5 + x06 * w1_3_6 + x07 * w1_3_7 + x08 * w1_3_8 + x09 * w1_3_9 + x010 * w1_3_10 + x011 * w1_3_11 + x012 * w1_3_12 + x013 * w1_3_13 + x014 * w1_3_14 + x014 * w1_3_15 + b13);\n    albedoSpectrum[4] = ReLU(x00 * w1_4_0 + x01 * w1_4_1 + x02 * w1_4_2 + x03 * w1_4_3 + x04 * w1_4_4 + x05 * w1_4_5 + x06 * w1_4_6 + x07 * w1_4_7 + x08 * w1_4_8 + x09 * w1_4_9 + x010 * w1_4_10 + x011 * w1_4_11 + x012 * w1_4_12 + x013 * w1_4_13 + x014 * w1_4_14 + x014 * w1_4_15 + b14);\n    albedoSpectrum[5] = ReLU(x00 * w1_5_0 + x01 * w1_5_1 + x02 * w1_5_2 + x03 * w1_5_3 + x04 * w1_5_4 + x05 * w1_5_5 + x06 * w1_5_6 + x07 * w1_5_7 + x08 * w1_5_8 + x09 * w1_5_9 + x010 * w1_5_10 + x011 * w1_5_11 + x012 * w1_5_12 + x013 * w1_5_13 + x014 * w1_5_14 + x014 * w1_5_15 + b15);\n    albedoSpectrum[6] = ReLU(x00 * w1_6_0 + x01 * w1_6_1 + x02 * w1_6_2 + x03 * w1_6_3 + x04 * w1_6_4 + x05 * w1_6_5 + x06 * w1_6_6 + x07 * w1_6_7 + x08 * w1_6_8 + x09 * w1_6_9 + x010 * w1_6_10 + x011 * w1_6_11 + x012 * w1_6_12 + x013 * w1_6_13 + x014 * w1_6_14 + x014 * w1_6_15 + b16);\n    albedoSpectrum[7] = ReLU(x00 * w1_7_0 + x01 * w1_7_1 + x02 * w1_7_2 + x03 * w1_7_3 + x04 * w1_7_4 + x05 * w1_7_5 + x06 * w1_7_6 + x07 * w1_7_7 + x08 * w1_7_8 + x09 * w1_7_9 + x010 * w1_7_10 + x011 * w1_7_11 + x012 * w1_7_12 + x013 * w1_7_13 + x014 * w1_7_14 + x014 * w1_7_15 + b17);\n\n    \n\tfloat lamdaStart = 380.0f;\n    float lamdaEnd = 780.0f;\n    \n\n    float dw = (lamdaEnd - lamdaStart) / float(SPECTRAL_SAMPLES);\n\n\n    // https://en.wikipedia.org/wiki/CIE_1931_color_space\n    // integrating Illuminant\n    float N = 0.0;\n\n    vec3 XYZAlbedo = vec3(0.0);\n\n    for (int k = 0; k < SPECTRAL_SAMPLES; k++)\n    {\n        float w = lamdaStart + (float(k) + 0.5f)*dw;\n        \n\n        float illuminant = BlackBoddyRadiation(w,5500.0);\n        \n        \n\n\n        float albedo =  albedoSpectrum[k];\n\n\n        N += illuminant * yFit_1931(w) * dw;\n        XYZAlbedo.x += albedo * illuminant * xFit_1931(w) * dw;\n        XYZAlbedo.y += albedo * illuminant * yFit_1931(w) * dw;\n        XYZAlbedo.z += albedo * illuminant * zFit_1931(w) * dw;\n    }\n\tXYZAlbedo /= N;\n\n    // XYZ to sRGB\n    vec3 RGBAlbedo = XYZtosRGB(XYZAlbedo);\n\n    vec3 outputColor = RGBAlbedo;\n    #ifdef COMPARE_WITH_RGB_ALBDEO\n    if(uv.x > 0.5)\n    \toutputColor = rgbAlebdoBase;\n    else if(abs(uv.x-0.5) < 0.001)\n        outputColor = vec3(0,0,0);\n    else\n        outputColor = RGBAlbedo;\n    #endif\n        \n    float d = length(RGBAlbedo - rgbAlebdoBase);\n    if(abs(uv.x-1.0) < 0.02)\n        outputColor = colorRamp(uv.y);\n    else if ((abs(uv.y-1.0) < 0.08) && (abs(uv.x-0.0) < 0.05))\n        outputColor = colorRamp(d);\n        \n        if(abs(uv.x-0.0) < 0.02)\n        {\n            if(abs(uv.y-0.0) < 0.2)\n            \toutputColor = vec3(1,1,1);\n            if(abs(uv.y-0.0) < 0.2*d)\n                outputColor = 0.8*vec3(1,1,1);\n        }\n    \n    #ifdef ABSOLUTE_VALUE\n    \toutputColor = colorRamp(d);\n    #endif\n    \n    #ifdef PLOT_SPECTRUM\n    for(int k = 0; k < SPECTRAL_SAMPLES; k++)\n    {\n        if(abs(uv.x-0.4) < 0.02*(float(k)+1.0))\n        {\n            \n           \tif(abs(uv.y-0.0) < 0.2*albedoSpectrum[k])\n        \t\toutputColor = 0.5*vec3(1,1,1);\n        }\n    }\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(outputColor,1.0);\n\n}","name":"Image","description":"","type":"image"}]}