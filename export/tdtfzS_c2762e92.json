{"ver":"0.1","info":{"id":"tdtfzS","date":"1605556429","viewed":168,"name":"Diffraction simulation.","username":"Pr0fed","description":"Diffraction simulation from ['GPU Gems' 2003]. Hopefully i've done it right lol.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["diffraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = pow(texture(iChannel0, uv), vec4(0.4545));\n    \n\tfragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MAX_WEIGHT 1\n\n#define MAX_DISTANCE 50.0\n\n#define SAMPLES 1\n#define MAX_BOUNCES 2\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\n// Materials\n#define DIFFR 0\n\nconst float GAMMA = 2.2;\n\n///-- Scene Objects -------------------------------------------------------\n\nstruct Material\n{\n\tint type;\n    vec3 albedo;\n};\n    \nstruct Disc\n{\n\tvec3 pos;\n    vec3 normal;\n    float r;\n    Material mat;\n};\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nDisc scene[1];\n\n///-------------------------------------------------------------------------\n\n///-- Helper Functions -----------------------------------------------------\n    \nvec2 UV = vec2(0.0);\n\nvec3 blend3(vec3 x)\n{\n    vec3 y = 1.0 - x * x;\n    y = max(y, vec3(0.0));\n    return vec3(y);\n}\n\n///--------------------------------------------------------------------------\n\n///-- MAIN FUNCTIONS --------------------------------------------------------\n\nbool intersectPlane(vec3 p0, vec3 n, vec3 l0, vec3 l, out float t) \n{ \n    // assuming vectors are all normalized\n    float denom = dot(normalize(n), normalize(l)); \n    if (denom > 1e-6) \n    { \n        vec3 p0l0 = p0 - l0; \n        t = dot(p0l0, n) / denom; \n        return (t >= 0.0); \n    }\n \n    return false; \n}\n\n// Ray tracing function.\nbool hitScene(Ray ray, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out Material material, out Disc disc)\n{\n    float closestSoFar = tMax;\n    bool isHit = false;\n    \n    for (int i = 0; i < 1; i++) \n    {\n        if (intersectPlane(scene[i].pos, scene[i].normal, ray.origin, ray.direction, closestSoFar)) \n        {\n            vec3 p = ray.origin + ray.direction * closestSoFar; \n            vec3 v = p - scene[i].pos; \n            float d2 = dot(v, v);\n            float innerRad = 0.05;\n            if (d2 <= scene[i].r * scene[i].r && d2 > innerRad)\n            {\n                disc = scene[i];\n                position = p;\n                normal = scene[i].normal;\n                material = scene[i].mat;\n                isHit = true;\n            }\n        }\n    }\n\n    \n    return isHit;\n}\n\nvec3 GetDiffractionColor(vec3 l0, vec3 p, vec3 normal, Disc disc)\n{\n    vec3 P = disc.pos + (disc.pos - p);\n    vec3 L = normalize(vec3(0.0, 5000.0, -5000.0) - P);\n    vec3 V = normalize(l0 - P);\n    vec3 H = L + V;\n    vec3 B = normalize(p - disc.pos);\n    vec3 T = normalize(cross(B, normal));\n    float u = dot(T, H) * 2.0;\n    float w = dot(normal, H);\n    float e = 0.5 * u / w;\n    float c = exp(-e * e);\n    if(u < 0.0)\n    {\n        u = u * -1.0;\n    }\n    \n    vec3 cDiff = vec3(0.0);\n    \n    for(int n = 0; n < 16; n++)\n    {\n        float y = 2.0 * u / float(n) - 1.0;\n        cDiff += blend3(vec3( 4.0 * (y-0.75), 4.0 * (y-0.5), 4.0 * (y-0.25)));\n    }\n    \n    vec3 anis = vec3(0.85, 0.64, 0.12) * c;\n    \n    return cDiff + anis;\n}\n\n// Main tracing function.\nvec3 trace(Ray ray) \n{\n    vec3 normal, position;\n    Material material;\n    Disc disc;\n    \n    vec3 color = vec3(0.0);\n    vec3 attenuation = vec3(1.0);\n    \n    for (int b = 0; b < MAX_BOUNCES; b++) \n    {\n        if (hitScene(ray, 0.01, MAX_DISTANCE, position, normal, material, disc)) \n        {\n            if (material.type == DIFFR) \n            {\n                vec3 reflected = reflect(ray.direction, normal);\n                vec3 direction = reflected;\n                \n                if (dot(direction, -normal) > 0.0) \n                {\n               \t\tray = Ray(position, direction);\n               \t \tvec3 diffrColor = GetDiffractionColor(ray.origin, position, normal, disc);\n                \tattenuation *= diffrColor;\n                }\n            }\n        }\n        \n        else \n        {\n            vec3 skyColor = texture(iChannel1, ray.direction).rgb;\n            skyColor = pow(skyColor, vec3(GAMMA));\n            attenuation *= skyColor;\n            break;\n        }\n    }\n    \n    return attenuation;\n}\n\n///-------------------------------------------------------------------------\n\nvoid SceneFill() \n{\n    scene[0]= Disc(vec3(4.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.5, Material(DIFFR, vec3(1.0, 1.0, 1.0)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialization and seed.\n    SceneFill();\n\n    // Basic normalization.\n    UV = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    // Camera stuff taken from https://www.shadertoy.com/view/ldtSR2.\n    const float fov = 90.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / aspect;\n    \n    const float dist = 7.5;\n    vec2 mousePos = iMouse.xy / iResolution.xy;  \n    \n    if (all(equal(mousePos, vec2(0.0)))) \n    {\n        mousePos = vec2(0.83, 0.14); // Default position.\n    }\n    \n    scene[0].normal.x = sin(mousePos.x * 10.0);\n    scene[0].normal.y = cos(mousePos.x * 10.0);\n\n    vec3 origin = vec3(0, 0, 0);\n    vec3 lookAt = vec3(3.0, 0.0, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n    \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    \n    vec3 color = vec3(0.0);\n\n    vec3 direction = lowerLeft - origin;\n    direction += horizontal * ( UV.x);\n    direction += vertical * ( UV.y);\n    color += trace(Ray(origin, normalize(direction)));\n    \n    color /= float(SAMPLES);\n    \n    vec3 previousColor = texture(iChannel0, UV).rgb;\n    \n    float weight = min(float(iFrame + 1), float(MAX_WEIGHT));\n    \n    // Resetting weight on mouse change.\n    if (!all(lessThanEqual(iMouse.zw, vec2(0.0)))) \n    {\n        weight = 1.0;\n    }\n    \n    vec3 newColor = mix(previousColor, color, 1.0 / weight);\n    \n    fragColor = vec4(newColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}