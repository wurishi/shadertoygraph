{"ver":"0.1","info":{"id":"fscSDr","date":"1632920681","viewed":44,"name":"Breathing Map","username":"Davion","description":"testing toyshader with a school projet","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["procedural","animated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define spec 3.0\n#define power 7.0\n#define diff 8.5\n\n#define PI 3.1415926535897932384626433832795\n\n\nvec3 compute_normal(in vec2 pos) {\n    const vec2 size = vec2(1.0, 0.0);\n    const ivec3 off = ivec3(-1, 0, 1);\n\n    vec4 texel = texture(iChannel0, pos);\n    float center = texel.x;\n    float west = textureOffset(iChannel0, pos, off.xy).x;\n    float east = textureOffset(iChannel0, pos, off.zy).x;\n    float south = textureOffset(iChannel0, pos, off.yx).x;\n    float north = textureOffset(iChannel0, pos, off.yz).x;\n    vec3 w2e = normalize(vec3(size.xy, east - west));\n    vec3 s2n = normalize(vec3(size.yx, north - south));\n\n    vec3 normal = cross(w2e, s2n);\n\n    return normal;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x/iResolution.x, fragCoord.y/iResolution.y);\n\n    float cloud = texture(iChannel1, uv).x * 3.0;\n    float height = texture(iChannel0, uv).x;\n    vec3 normal = compute_normal(uv);\n    \n    vec3 lightDir = normalize(vec3(-1000.0, 0.5, 30.0)-vec3(uv, height));\n    vec3 viewDir = normalize(vec3(0.5,0.5,100.0)-vec3(uv, height));\n    vec3 halfDir = normalize(lightDir+viewDir);\n\n    float specTerm = pow(dot(normal, halfDir), power) * spec;\n    float diffTerm = sin(dot(lightDir, normal)) * diff;\n    \n    \n    fragColor = vec4(choose_color(height).xyz*(specTerm+diffTerm), 1.0-cloud ) + vec4(cloud);\n    //fragColor = vec4(vec3(texture(iChannel0, uv).x), 1.0);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float noise(in vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(42.9898000, 78.2330000))) * 43758.5453123);\n}\n\nvec3 permute(in vec3 x) {\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\n/**\n * Simplex noise used to generate a value from a 2d vector\n */\nfloat simplex(in vec2 v, in float time){\n    vec4 C = vec4(0.211324865405187, 0.366025403784439,\n    -0.577350269189626, time);\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    \n    i = mod(i, 216.0);\n    \n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n    + i.x + vec3(0.0, i1.x, 1.0));\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy),\n    dot(x12.zw, x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    \n    return 120.0*dot(m, g);\n}\n\nvec4 choose_color(in float h){\n    if (h < 0.0)// UNDER THE SEA\n    return vec4(1.0, 0.0, 0.0, 1.0);\n    else if (h < 0.2)// SEA\n    return mix(vec4(0.0, 0.0, 0.5, 1.0), vec4(0.0,0.5,1.0,1.0), log(h/0.2+1.0));\n    else if (h < 0.25)// BEACH\n    return vec4(1.0, 1.0, 0.0, 1.0);\n    else if (h < 0.65)// PLAIN\n    return mix(vec4(0.5, 1.0, 0.075, 1.0), vec4(0.2, 0.2, 0.075, 1.0), ((h-0.25)/0.4)*((h-0.25)/0.4)*((h-0.25)/0.4));\n    else if (h < 0.85)// MOUNTAIN\n    return vec4(0.2, 0.2, 0.075, 1.0);\n    else if (h < 1.0)// SNOW\n    return vec4(1.0);\n    else//OOB\n    return vec4(1.0, 0.0, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define zoom 1.0\n#define tSpeed 0.1\n#define bSpeed 0.3\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord/minRes);\n    \n    float seed = (iDate.z+100.0*iDate.y+10000.0*iDate.x)*0.00001;\n    \n    float s = 0.0;\n    float j;\n    for (float i = 0.5; i < 9.5; i += 1.5){\n        j = exp2(i);\n        s += 1.0/j * min(1.0,simplex((uv+vec2(iTime*tSpeed, 0.0)) * j * zoom, seed));\n    }\n\n    float h = mix(0.0, 1.0, pow(s, sin(iTime*bSpeed-1.5)*2.3+3.0));\n  \n    \n    vec3 col = vec3(h);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define zoom 1.0\n#define tSpeed 0.03\n#define bSpeed 0.0\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float minRes = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord/minRes);\n    \n    float seed = (iDate.z+100.0*iDate.y+10000.0*iDate.x)*0.00001;\n    \n    float s = 0.0;\n    float j;\n    for (float i = 0.5; i < 6.5; i += 1.5){\n        j = exp2(i);\n        s += 1.0/j * min(1.0,simplex((uv.yx+vec2(0.0, iTime*tSpeed)) * j * zoom, seed));\n    }\n\n    float h = mix(0.0, 1.0, pow(s, 0.6));\n  \n        \n    vec3 col = clamp(vec3(h-0.5), 0.0, 1.0);\n    fragColor = vec4(col, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}