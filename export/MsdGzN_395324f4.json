{"ver":"0.1","info":{"id":"MsdGzN","date":"1450061703","viewed":168,"name":"U.G.L.Y","username":"sixstring982","description":"Demo shader for one of our old recordings","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["ugly","music","robot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define MARCH_ITERS 100\n#define MAX_RAY_DIST 100.0\n#define SPIN_SPEED 0.5\n#define MOUSE_SPEED 0.02\n\n#define SHADE_MAX 1.0\n#define SHADE_MIN 0.25\n\n#define PI 3.1415926535\n#define STOT 0.70710678118\n\n#define XROT90 mat3(1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0)\n#define ZROT45 mat3(STOT, -STOT, 0.0, STOT, STOT, 0.0, 0.0, 0.0, 1.0)\n#define XROT45 mat3(1.0, 0.0, 0.0, 0.0, STOT, -STOT, 0.0, STOT, STOT)\n\n#define RED vec3(1.0, 0.0, 0.0)\n#define GREEN vec3(0.0, 1.0, 0.0)\n#define BLUE vec3(0.0, 0.0, 1.0)\n#define YELLOW vec3(1.0, 1.0, 0.0)\n#define CYAN vec3(0.0, 1.0, 1.0)\n#define MAGENTA vec3(1.0, 0.0, 1.0)\n#define WHITE vec3(1.0)\n#define BLACK vec3(0.0)\n\n\n#define DIFFUSE\n#define SPECULAR\n#define SHADOWS\n\n#define PLASMA_STACK_DEPTH 8\n#define PERFORMANCE\n#define ROBOT\n#define POV_PLASMA\n#define MOVE_PLASMA\n\nvec3 invertRGB(in vec3 rgb) {\n    return vec3(1.0 - rgb.r, 1.0 - rgb.g, 1.0 - rgb.b);\n}\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat floatRand(float seed) {\n  return rand(vec2(sin(seed + 0.1)));\n}\n\nfloat sphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat box(in vec3 p, in vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n               length(max(d,0.0));\n}\n\nfloat repRotZBox(in vec3 p, in vec3 c, in vec3 b) {\n    vec3 q = mod(p,c)-0.5*c;\n    return box(ZROT45 * q, b);\n}\n\nfloat repRotXBox(in vec3 p, in vec3 c, in vec3 b) {\n    vec3 q = mod(p,c)-0.5*c;\n    return box(XROT45 * q, b);\n}\n\nfloat plane(in vec3 p, in vec4 n) {\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat cylinder(in vec3 p, in vec3 c) {\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r ) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat opS(in float d1, in float d2) {\n    return max(d1, -d2);\n}\n\nfloat opU(in float d1, in float d2) {\n    return min(d1, d2);\n}\n\nfloat map(in vec3 p) {\n    // Eyes \n    vec3 ep = p + vec3(0.0, -0.25, 0.0);\n    float eyes = cylinder(XROT90 * ep, vec3(0.4, 0.0, 0.3));\n    eyes = opU(eyes, cylinder(XROT90 * ep, vec3(-0.4, 0.0, 0.3)));\n    eyes = opS(eyes, plane(ep, -vec4(0.0, 1.0, 0.0, 0.0)));\n    \n    // Patch hole in back caused by eyes\n    float patch = box(p - vec3(0.0, 0.0, 0.9), vec3(1.0, 1.0, 0.1));\n    \n    // Interior\n    float it = box(p - vec3(0.0, -0.3, 0.0), vec3(0.8));\n    \n    // Ragged edge along x and z axes\n    float rx = repRotZBox(p + vec3(0.0, 2.5, 0.0), \n                         vec3(0.2, 3.0, 1.0), vec3(0.1, 0.1, 2.0));\n    float rz = repRotXBox(p + vec3(0.0, 2.5, 0.0), \n                         vec3(1.0, 3.0, 0.2), vec3(2.0, 0.1, 0.1));\n        \n    \n    // Add the rest of the head\n    float d = box(p, vec3(1.0));\n    d = opS(d, eyes);\n    d = opS(d, it);\n    d = opU(d, patch);\n    d = opS(d, rx);\n    d = opS(d, rz);\n    \n    // Add antenna\n    d = opU(d, sphere(p + vec3(1.0, -0.6, -0.6), 0.2));\n    d = opU(d, capsule(p + vec3(1.1, -0.7, -0.6),\n                       vec3(-0.2, 0.2, 0.0), vec3(0.0), 0.05));\n    d = opU(d, capsule(p + vec3(1.1, -0.9, -0.6),\n                       vec3(-0.2, 0.0, 0.0), vec3(0.0, 0.2, 0.0), 0.05));\n    d = opU(d, capsule(p + vec3(1.1, -1.1, -0.6),\n                       vec3(-0.0, 0.0, 0.0), vec3(-0.2, 0.2, 0.0), 0.05));\n    return d;\n}\n\nvec3 mapNormal(in vec3 p) {\n    const vec2 ev = vec2(EPSILON, 0.0);\n    return normalize(vec3(map(p + ev.xyy) - map(p - ev.xyy),\n                          map(p + ev.yxy) - map(p - ev.yxy),\n                          map(p + ev.yyx) - map(p - ev.yyx)));\n}\n\nbool march(in vec3 ro, in vec3 rd, out vec3 rp, out float td) {\n    float d = EPSILON;\n    td = 0.0;\n    rp = ro;\n    \n    for (int i = 0; i < MARCH_ITERS; i++) {\n        if (abs(d) < EPSILON ||\n            td > MAX_RAY_DIST) {\n            break;\n        }\n        \n        d = map(rp);\n        rp += rd * d;\n        td += d;\n    }\n    \n    return abs(d) < EPSILON;\n}\n\nvec3 plasmaMap(in float idx) {\n    float f = fract(idx);\n    float i = mod(idx, 7.0);\n    \n    if (i < 1.0) {\n        return mix(RED, YELLOW, f);\n    } else if (i < 2.0) {\n        return mix(YELLOW, GREEN, f);\n    } else if (i < 3.0) {\n        return mix(GREEN, CYAN, f);\n    } else if (i < 4.0) {\n        return mix(CYAN, BLUE, f);\n    } else if (i < 5.0) {\n        return mix(BLUE, MAGENTA, f);\n    } else if (i < 6.0) {\n        return mix(MAGENTA, BLACK, f);\n    } else {\n        return mix(BLACK, RED, f);\n    }\n}\n\nfloat gridMod(in vec2 p, float i) {\n    return (mod(p.x, 0.5) + mod(p.y, 0.5)) + i;\n}\n\nfloat sincos(in vec2 p, float i) {\n    return sin(p.x * 2.0 * PI) + cos(p.y * 2.0 * PI) + i;\n}\n\nfloat dragonScale(in vec2 p, in float i) {\n    return (sin(mod(p.x, 0.5) + cos(mod(p.y, 0.5)))) * 2.0 + i;\n}\n\nvec2 rotation(vec2 inVec, float index) {\n  index *= 0.2;\n  return mat2(cos(index), sin(index),\n             -sin(index), cos(index)) * inVec;\n}\n\nvec2 deform1(vec2 inVec, float index) {\n  float twoR = length(inVec) * 2.0;\n  return inVec * vec2(cos(twoR), sin(twoR));\n}\n\nvec2 deform2(vec2 inVec, float index) {\n  float r = length(inVec);\n  float a = atan(inVec.x, inVec.y);\n  return vec2(1.0 / (r + 0.5 + 0.5 * sin(5.0 * a)),\n              a * 3.0 / PI);\n}\n\nvec2 deform3(vec2 inVec, float index) {\n  return vec2(inVec.x / abs(inVec.y),\n              1.0 / abs(inVec.y));\n}\n\nvec2 deform4(vec2 inVec, float index) {\n  float r = length(inVec);\n  float a = atan(inVec.x, inVec.y);\n  return vec2((0.5 * a) / PI,\n              sin(7.0 * r));\n}\n\nvec2 deform5(vec2 inVec, float index) {\n  float r = length(inVec);\n  float a = atan(inVec.x, inVec.y);\n  return vec2(0.02 * inVec.y + 0.03 + cos(a * 3.0) / r,\n              0.02 * inVec.x + 0.03 + sin(a * 3.0) / r);\n}\n\nvec2 deform6(vec2 inVec, float index) {\n  float r = length(inVec);\n  float a = atan(inVec.x, inVec.y);\n  return vec2(r * cos(a + r),\n              r * sin(a + r));\n}\n\nvec2 deform7(vec2 inVec, float index) {\n  float r = length(inVec);\n  float a = atan(inVec.x, inVec.y);\n  return vec2(0.3 / (r + 0.5 * inVec.x),\n              3.0 * a / PI);\n}\n\nvec2 deform8(vec2 inVec, float index) {\n  float r = length(inVec);\n  float a = atan(inVec.x, inVec.y);\n  return vec2(0.1 * inVec.x / (0.11 + r * 0.5),\n              0.1 * inVec.y / (0.11 + r * 0.5));\n}\n\nfloat pickPlasma(in vec2 uv) {\n    float seed = ceil(iTime / 5.0);\n    float i = iTime;\n    \n    for (int idx = 0; idx < PLASMA_STACK_DEPTH; idx++) {\n        seed = floatRand(seed) * 12.0;\n        if (seed < 1.0) {\n            i = gridMod(uv, i);\n        } else if (seed < 2.0) {\n            i = sincos(uv, i);\n        } else if (seed < 3.0) {\n            i = dragonScale(uv, i);\n        } else if (seed < 4.0) {\n            uv = rotation(uv, i);\n        } else if (seed < 5.0) {\n            uv = deform1(uv, i);\n        } else if (seed < 6.0) {\n            uv = deform2(uv, i);\n        } else if (seed < 7.0) {\n            uv = deform3(uv, i);\n        } else if (seed < 8.0) {\n            uv = deform4(uv, i);\n        } else if (seed < 9.0) {\n            uv = deform5(uv, i);\n        } else if (seed < 10.0) {\n            uv = deform6(uv, i);\n        } else if (seed < 11.0) {\n            uv = deform7(uv, i);\n        } else if (seed < 12.0) {\n            uv = deform8(uv, i);\n        }\n    }\n    \n    return i;\n}\n\nvec3 plasma(in vec3 rp) {\n    #ifdef MOVE_PLASMA\n    vec2 movement =  vec2(2.0 + 2.0 * sin(iTime * 1.5), \n                          2.0 + 2.0 * cos(iTime / 1.5));\n    #else\n    vec2 movement = vec2(0.0, -1.0);\n    #endif\n    vec2 uv = vec2(rp.x + rp.y + 2.0 * \n                   texture(iChannel0, \n                             vec2(2.0 * rp.x * movement.x + \n                                  2.0 * rp.y * movement.y, 0.0)).r * 0.0625, \n                   rp.y + rp.z) + movement;\n    return vec3(plasmaMap(pickPlasma(uv)));\n}\n\nbool isAntenna(in vec3 rp) {\n    return rp.x < -1.001;\n}\n\nbool insideHead(in vec3 rp) {\n    return rp.x < 0.85 && rp.x > -0.85 &&\n           rp.y < 0.85 && rp.y > -0.85 &&\n           rp.z < 0.85 && rp.z > -0.85;\n}\n\nvec3 mapColor(in vec3 rp, in vec3 V, in vec3 N) {\n    if (insideHead(rp)) {\n        return invertRGB(plasma(rp));\n    } else if (isAntenna(rp)) {\n        return mix(vec3(0.5), plasma(reflect(V, N)), 0.5);\n    } else {\n        return mix(vec3(0.75, 0.25, 0.0), plasma(reflect(V, N)), 0.125);\n    }\n}\n\n#define LIGHT_COUNT 3\nbool lights(in int idx, out vec3 lightPos) {\n    if (idx == 0) {\n        lightPos = vec3(3.0 * sin(iTime),\n                        3.0,\n                        3.0 * cos(iTime));\n        return true;\n    } else if (idx == 1) {\n        lightPos = vec3(-3.0);\n        return true;\n    } else if (idx == 2) {\n        \n        lightPos = vec3(0.2 * sin(iTime), 0.2,\n                        0.2 * cos(iTime));\n        return true;\n    } else {\n        return false;\n    }\n}\n\nvec3 lightColor(in int idx) {\n    if (idx == 0) {\n        return vec3(1.0);\n    } else if (idx == 1) {\n        return vec3(0.5);\n    } else if (idx == 2) {\n        return vec3(0.0, 0.75 + 0.25 * sin(iTime), 1.0);\n    } else {\n        return vec3(1.0);\n    }\n}\n\nfloat shininessAt(in vec3 rp) {\n    if (insideHead(rp)) {\n        return 32.0;\n    } else if (isAntenna(rp)) {\n        return 20.0;\n    } else {\n        return 1e20;\n    }\n}\n\nvec3 bumpAt(in vec3 rp) {\n    if (insideHead(rp)) {\n        return vec3(0.0);\n    } else {\n        return texture(iChannel1, (rp.xy + rp.yz) / 2.0).rgb;\n    }\n}\n\nvec3 lighting(in vec3 rp, in vec3 rd, in float dist) {\n    vec3 N = mapNormal(rp);\n    vec3 L = normalize(-rd * dist);\n    vec3 V;\n    vec3 R;\n    \n    N = normalize(N + bumpAt(rp));\n    \n    vec3 diff = vec3(0.0);\n    vec3 spec = vec3(0.0);\n    float shade = 0.25;\n    vec3 shadeDest;\n    float shadeDist;\n   \n    vec3 lightPos;\n    \n    for (int i = 0; i < LIGHT_COUNT; i++) {\n        if (!lights(i, lightPos)) {\n            break;\n        }\n        \n        V = normalize(rp - lightPos);\n        R = normalize(reflect(-L, N));\n        \n        diff += max(0.0, dot(-V, N)) * lightColor(i);\n        spec += pow(max(0.0, dot(-V, R)), shininessAt(rp)) * lightColor(i);\n        \n        if (march(lightPos, V, shadeDest, shadeDist)) {\n            if (abs(length(shadeDest - rp)) < 0.007) {\n                shade = 1.0;\n            }\n        }\n    }\n    diff = clamp(diff, vec3(0.0), vec3(1.0));\n    spec = clamp(spec, vec3(0.0), vec3(1.0));\n    \n    vec3 color = mapColor(rp, L, N);\n    vec3 intensity = vec3(0.5);\n    #ifdef SPECULAR\n    intensity += spec;\n    #endif\n    #ifdef DIFFUSE\n    intensity += diff;\n    #endif\n    #ifdef SHADOWS\n    intensity *= shade;\n    #endif\n    \n    return color * intensity;\n}\n\nfloat cameraDistance() {\n    return 3.0 + 0.5 * sin(iTime);\n}\n\nvoid setupCamera(in vec2 uv, out vec3 ro, out vec3 rd) {\n    float camTheta = iTime * SPIN_SPEED + iMouse.x * MOUSE_SPEED;\n    float camPhi = (PI / 2.0) + (PI / 4.0) * ((iMouse.y / iResolution.y) - 0.5);\n    ro = vec3(cameraDistance() * sin(camPhi) * cos(camTheta),\n              cameraDistance() * cos(camPhi),\n              cameraDistance() * sin(camPhi) * sin(camTheta));\n    vec3 target = vec3(0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    \n    vec3 cdir = normalize(target - ro);\n    vec3 cright = normalize(cross(cdir, up));\n    vec3 cup = cross(cright, cdir);\n    \n    rd = uv.x * cright + uv.y * cup + cdir;\n}\n\nbool renderRobot() {\n    #ifdef ROBOT\n    float gt = mod(iTime, 300.0);\n    if ((gt > 295.0) || ((gt >= 30.0) && (gt <= 35.0))) {\n        return mod(gt, 0.1) > 0.05;\n    } else if (gt < 30.0) {\n        return true;\n    } else {\n        return false;\n    }\n    #else\n    return false;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro, rd, rp;\n    float dist;\n    setupCamera(uv, ro, rd);\n    \n    #ifdef POV_PLASMA\n    vec3 plasma_rd = rd;\n    #else\n    vec3 plasma_rd = vec3(uv, 1.0);\n    #endif\n    \n    #ifdef PERFORMANCE\n    if (renderRobot()) {\n    \tif (march(ro, rd, rp, dist)) {\n    \t    fragColor = vec4(lighting(rp, rd, dist), 1.0);\n    \t} else {\n\t        fragColor = vec4(plasma(rd), 1.0);\n\t    }\n    } else {\n        fragColor = vec4(plasma(plasma_rd), 1.0);\n    }\n    #else\n    if (march(ro, rd, rp, dist)) {\n        fragColor = vec4(lighting(rp, rd, dist), 1.0);\n    } else {\n        fragColor = vec4(plasma(plasma_rd), 1.0);\n    }\n    #endif\n}","name":"Image","description":"","type":"image"}]}