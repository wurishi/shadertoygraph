{"ver":"0.1","info":{"id":"Ws33WH","date":"1710662897","viewed":52,"name":"Rolling Balls","username":"lewdoo","description":"This was done following an art of code tutorial, as my first step into raymarching. my version of the code is commented more properly and has more readable variable names. Altered the project to include multiple spheres and light sources","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxSteps 100\n#define maxDist 100.\n#define surfDist 0.1\n\n//point is the the position to check against the sphere\nfloat GetDist(vec3 point){\n    //x = x position, y = position, z = dist from camera origin, w = sphere radius\n    \n    float roler = (fract(iTime * 0.12) - 0.5) * 8.;\n    float rolerTwo = (fract(iTime * 0.1) - 0.5) * 6.5;\n    float rolerThree = (fract(iTime * 0.2 + 0.1) - 0.5) * 10.;\n    \n\tvec4 sphere = vec4(rolerTwo * 3., 1.2, 6. - rolerTwo * 0.8, 1);\n\tvec4 sphereTwo = vec4(roler, .4, 3. - roler * 0.1, 0.2);\n    vec4 sphereThree = vec4(rolerThree * 1.5, .34, 6. + rolerThree * 0.05, 0.15);\n \n    float sphereDist = length(point - sphere.xyz) - sphere.w;\n    float sphereDistTwo = length(point - sphereTwo.xyz) - sphereTwo.w;\n    float sphereDistThree = length(point - sphereThree.xyz) - sphereThree.w;\n    \n    float planeDist = point.y;\n\t\n    //returning the minimum dist between the plane and the sphere, this allows for intersections and theoretical collisions\n    float dist = min(sphereDist, planeDist);\n    dist = min(dist, sphereDistTwo);\n    dist = min(dist, sphereDistThree);\n    return dist;\n        \n}\n\n\n//getting the distence between each ring and the scene\nfloat RayMarch (vec3 rayOrigin, vec3 rayDist){\n\t//distance from the origin\n    float doo = 0.;\n    \n        for (int i = 0; i < maxSteps; i++){\n        \tvec3 point = rayOrigin + rayDist * doo;\n            float dist = GetDist(point);\n            //increamenting the distance of the hit point until the circle is small enough to be called a hit\n            doo += dist;\n            if(doo > maxDist || dist <surfDist) break;\n        }\n    \n    return doo;\n        \n}\n\n\nvec3 GetNormal (vec3 point){\n\tfloat dist = GetDist(point);\n    //this is made to xreat a swizzle, whiich is used simply to make writing out numbers quicker in different orders\n    vec2 e = vec2(.01, 0);\n    //creating a lighting matrix\n    vec3 normal = dist - vec3(GetDist(point-e.xyy), GetDist(point-e.yxy), GetDist(point-e.yyx));\n    \n    return normalize(normal);\n}\n\nfloat GetLight(vec3 lightPos, vec3 point){\n    \n    //moving the light position\n    // lightPos.xz += vec2(sin(iTime), cos(iTime)) * 2.;\n    \n    vec3 lightVec = normalize(lightPos - point);\n    vec3 norm = GetNormal(point);\n    \n    //because dot product returns valuyes between 1 and -1, the value needs clamping\n    float diff = clamp(dot(norm, lightVec), 0., 1.);\n    \n    //adding shadows to the lighting\n    float dist = RayMarch(point + norm * surfDist * 1.5, lightVec);\n    if(dist<length(lightPos-point)) diff *= 0.1;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //moving the 0 uv to middle of screen\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) /iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    //arteficial camera position\n    vec3 camPoint = vec3(0, 1.4, 0);\n    \n \t//direction of the ray\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(camPoint, rayDir);\n    \n    //lighting ----------------------------------------------------------\n    vec3 point = camPoint + rayDir * d;\n    \n    float diff = GetLight(vec3(0, 5, 6), point) * 0.3;\n    float diffTwo = GetLight(vec3(-5, 3.5, 10), point) * 0.2;\n    \n    col = vec3(diff, diffTwo, diff);\n    //-------------------------------------------------------------------\n    \n    //used to debug the normals of the sphere\n    // col = GetNormal(point);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}