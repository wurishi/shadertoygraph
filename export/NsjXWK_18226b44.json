{"ver":"0.1","info":{"id":"NsjXWK","date":"1621033910","viewed":305,"name":"VideoSphereMapper","username":"SleepyRon","description":"how to map a feed onto a sphere with depth","likes":6,"published":1,"flags":2,"usePreview":0,"tags":["raymarching","uv","sphere","webcam","hypno","sleepy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PHI 1.6180339887\n#define INV_PHI 0.6180339887\n\n#define MAX_ITER 256\n#define MAX_DIST 100.\n#define MIN_DIST .01\n\n#define SHAPE 0\n// monitor input texture\n#define CAMERA_ON 1\n#define MONITOR 0\n#define DEPTH_ON 1\n\nconst vec3 GROUND_COLOR = vec3(0.,0.,0.);\n\nconst vec3 SHAPE_COLOR = vec3( 1., 0., 0.);\n\nvec2 getTexturePosition(vec2 uv){\n    if(SHAPE == 1){\n        //uv = acos(uv.xy)/3.14159;\n        uv = uv.xy / 3. + vec2(.5);\n        uv.x /= iResolution.x/iResolution.y;\n        uv.x += .22;\n    }\n    else{\n    \tuv = acos(uv.xy)/3.14159 ;\n        uv = 1.-uv;\n    }\n    vec2 ret = vec2(uv.x,uv.y);\n    return ret;\n}\n    \nvec4 getRotationMatrix( vec3 axis, float angle){\n    vec4 q = vec4(0.0);\n    float half_angle = angle/2.;\n    q.x = axis.x * sin(half_angle);\n    q.y = axis.y * sin(half_angle);\n    q.z = axis.z * sin(half_angle);\n    q.w = cos(half_angle);\n    return q;\n}\n\nfloat luma(vec3 v) {\n    return .2126*v.x + .7152*v.y + .0722*v.z;\n}\n\nfloat brightness(vec3 v){\n\treturn v.x + v.y + v.z;\n}\n\nvec3 rotx(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\nvec3 roty(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\nvec3 rotz(vec3 p, float a) {\n\tfloat s = sin(a), c = cos(a);\n\treturn vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\n\nfloat  plane(vec3 p, vec3 origin, vec3 normal){ \n   return dot(p - origin,normal);   \n}\nfloat  doubleplane(vec3 p, vec3 origin, vec3 normal){ \n   return max(dot(p - origin,normal),dot(-p - origin,normal));   \n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCube( vec3 p, float d)\n{\n  return length(max(abs(p) -d,0.0));\n}\n\n\n\nfloat dstFace(vec3 p, float r) {\n    float d;\n    \n    if(SHAPE != 1 ){\n        //INTIAL ROTATION OF SHAPE\n        //p = rotx(p, INITIAL_ROTATION.x );\n        //p = roty(p, INITIAL_ROTATION.y );\n        //p = rotz(p, INITIAL_ROTATION.z );\n    \n        //ROTATION SPEED/MODULATION\n        //p = rotx(p, iTime/2.* ROTATION_SPEED.x );\n        //p = roty(p, iTime/2.* ROTATION_SPEED.y );\n        //p = rotz(p, iTime/2.* ROTATION_SPEED.z );\n    }\n    \n    \n    if(SHAPE == 1){\n        d = sdPlane(p, vec3(0.0,0.0,-1.0), 0.0);\n    }\n    else{\n    \td = length(p)-r; //sphere\n    }\n    if(DEPTH_ON == 1){\n    \t//d -= luma(texture(iChannel0, getTexturePosition(uv)).xyz) * .2;\n    \td -= brightness(texture(iChannel0, getTexturePosition(p.xy) ).xyz) * .1;\n    }\n    \n    return d;\n}\n\nfloat dstScene(vec3 p) {\n    //float ret = min(dstFace(p, 1.), p.y + 1.4); // ground plane\n    float ret = dstFace(p, 1.); // no ground plane\n    return ret;\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for(int i = 0; i < MAX_ITER; i++) {\n        float d = dstScene(ro+rd*t);\n        if(d < MIN_DIST || t > MAX_DIST) {\n            break;\n        }\n        t += d * .75;\n    }\n    return t;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n    vec2 e = vec2(MIN_DIST*t,0.);\n    vec3 n = vec3(dstScene(p+e.xyy)-dstScene(p-e.xyy),\n                  dstScene(p+e.yxy)-dstScene(p-e.yxy),\n                  dstScene(p+e.yyx)-dstScene(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 pixel(vec3 ro, vec3 rd) {\n    float t = raymarch(ro, rd);\n    if(t < MAX_DIST) {\n        vec3 p = ro+rd*t;\n        vec3 n = calcNormal(p,t);\n        vec3 r = normalize(reflect(rd,n));\n        //light_pos\n        vec3  l = normalize(vec3( 80. * (iMouse.x/iResolution.x ) - 40. ,40. * (iMouse.y/iResolution.y ) - 20.,-45.));\n        float d = max(dot(l,n),.2);\n        float specular_amt = 100.;\n        float s = pow(max(dot(l,r),0.),specular_amt); //specular term\n        \n        float a = 1.;\n        if(raymarch(p+l*.05,l) < MAX_DIST) {\n            a = 0.;\n        }\n        d *= a; s *= a;\n        \n        vec3 albedo = vec3(0.0); // ground color\n        if(SHAPE >= 1  || p.y > -1.3) { // otherwise selsct a sampled color\n            if(CAMERA_ON == 1){\n                albedo = texture(iChannel0,getTexturePosition(p.xy)).xyz;\n            }\n            else{\n                albedo = SHAPE_COLOR;\n            }\n        }\n        return albedo*d+s;\n    }\n    \n    //use for smooth glow background\n    //return vec3(pow(max(dot(rd,vec3(0.,0.,1.)),0.),5.));\n    \n    return GROUND_COLOR;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    //float mouse_y_offset = -1. * iMouse.y/4.; // mouse camera positioning\n    vec3 camera_origin = vec3(0., 0.,  -3.0);\n    vec3 rd = vec3(uv, 1.);\n    \n    vec2 nuv = fragCoord/iResolution.xy;\n    if(MONITOR == 1 && (nuv.x < .2 && nuv.y < .2) ) {\n        nuv /= .2;\n        fragColor = texture(iChannel0, nuv);\n        if(nuv.x < .0 || nuv.x > 1.) {\n         \tfragColor.xyz *= vec3(.5,.2,.2);   \n        }\n    } else {\n    \tfragColor = vec4(pixel(camera_origin, normalize(rd)), 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}