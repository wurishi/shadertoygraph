{"ver":"0.1","info":{"id":"XclBRN","date":"1723464438","viewed":37,"name":"Raymarching_Learning_20240812","username":"Haru86_","description":"Raymarching_Learning_20240812\n\nReference\nhttps://qiita.com/kaneta1992/items/21149c78159bd27e0860\nhttps://qiita.com/edo_m18/items/8c20c9c80d44e8b1dfe4","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define resolution iResolution\n\n// 久しぶりにRaymarchingを書いて何もかも忘れていたのでその思い出しがてらいろいろメモしてます\n// It's been a while since I wrote Raymarching and forgot everything, so I'm taking notes to remind myself of that.\n\n// Reference ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// https://qiita.com/kaneta1992/items/21149c78159bd27e0860\n// https://qiita.com/edo_m18/items/8c20c9c80d44e8b1dfe4\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n#define pi acos(-1.0)\n#define pi2 2.0 * pi\n\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// modはこの書き方だと便利らしい\n#define repeat(p,w) mod(p, w) - (w * 0.5)\n\n// sphereDist\nfloat sd(vec3 p, float r)\n{\n  return length(p) - r;\n}\n\n// cube distance\nfloat cd(vec3 p, vec3 s)\n{\n  return length(max(vec3(0.0), abs(p) - s));\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n  p = abs(p) - s;\n\n  return max(p.x, max(p.y, p.z));\n}\n\n// 回転Fold\nvec2 pmod(vec2 p, float s)\n{\n  // sは分割数(segment)\n  float n = pi2 / s;\n\n  // 分割角度の半分をオフセットとして渡す\n  float a = atan(p.x, p.y) + n * 0.5;\n\n  a = floor(a / n) * n;\n\n  return p * rot(-a);\n}\n\nfloat map(vec3 p)\n{\n  // Fold。折り畳み\n  // p.y = abs(p.y);\n\n  // float d1 = sd(p - vec3(0.0, 0.5, 0.0), 0.5);\n  // float d2 = cd(p, vec3(0.5));\n\n  // float d = min(d1, d2); // 和集合。\n  // float d = max(d1, d2); // 積集合\n  // float d = max(-d1, d2); // 差集合\n  // float d = max(d1, -d2); // 差集合\n\n  // 繰り返すやつ\n  //p.z += time;\n  // p = repeat(p, 10.0);\n  // float d = sdBox(p, vec3(0.5));\n\n  // fmod。rotateFold\n  // p.xy = pmod(p.xy, 6.0);\n  // float d = sdBox(p, vec3(0.5));\n\n  // IFS\n  // IFSとはループによって自身を拡大縮小・回転・平行移動させながら複製するフラクタルシステムのこと\n  vec3 z = p;\n  float scale = 2.0;\n  float sum = scale;\n  float d = 1e5; // たぶん大きい数字のこと\n\n  for(float i = 0.0; i < 4.0; i++)\n  {\n    float td = sdBox(z, vec3(0.5)) / sum;\n\n    // 平行移動\n    z = abs(z) - vec3(0.0, 2.0, 0.0);\n\n    // 回転\n    // ここではループのたびに45度ずつ回転している\n    z.xy *= rot(pi * 0.25);\n\n    // 拡大縮小\n    z *= scale;\n\n    // ループごとのスケールの合計で距離関数の値を正規化する必要がある\n    /*\n    ifsの最中でscaleを欠けていくと、どんどん距離場のスケールが大きくなって、最短距離からかけ離れていきます。\n    イテレーションごとに距離を正規化させてやることできれいに表示されます！(@kanetaaaaa)\n    */\n    sum *= scale;\n\n    // デバッグ表示用\n    d = min(td, d);\n  }\n\n  return d;\n}\n\nvec3 gn(vec3 p)\n{\n  vec2 e = vec2(0.001, 0.0);\n\n  return normalize(vec3(\n      map(p + e.xyy) - map(p - e.xyy),\n      map(p + e.yxy) - map(p - e.yxy),\n      map(p + e.yyx) - map(p - e.yyx)\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 st = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\n  vec3 col = vec3(0.0);\n\n  // col = vec3(st, 0.0);\n\n  // 数学的にはscreenZで横方向への広がり具合を調整している\n  // 小さいほどベクトルが横に広がるので広い範囲が見えて、近くのものは遠く見える\n  // 焦点位置と捉えることもできる\n  float screenZ = 2.5;\n\n  vec3 ro = vec3(0.0, 0.0, -10.0);\n  vec3 rd = normalize(vec3(st, screenZ));\n\n  // 意味合い的に今後、ここでにはtよりもdepthを使った方が理解が深まるかも\n  float depth = 0.0;\n  for(int i = 0; i < 64; i++)\n  {\n    float d= map(ro + rd * depth);\n\n    if(d < 0.001){\n      vec3 n = gn(ro + rd * depth);\n\n      col = vec3(n * 0.5 + 0.5);\n      break;\n    }\n\n    depth += d;\n  }\n\n  fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}