{"ver":"0.1","info":{"id":"4lsSDl","date":"1442020404","viewed":244,"name":"Duckling","username":"jimmi","description":"Just a duckling.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["duck"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float sphere(vec3 p, float s)\n{\n    float k = length(p)-s;\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBody(vec3 p) {\n    float k = 6.0;\n    float a = 0.;\n    \n    a += exp(-k * sphere(p + vec3(0.11, 0, 0.1), 0.06));\n    a += exp(-k * sphere(p + vec3(-0.11, 0, 0.1), 0.06));\n    a += exp(-k * sphere(p + vec3(0.2, 0, 0.3), 0.1));\n    a += exp(-k * sphere(p + vec3(-0.2, 0, 0.3), 0.1));\n    a += exp(-k * sphere(p + vec3(0.2, 0, 0.55), 0.07));\n    a += exp(-k * sphere(p + vec3(-0.2, 0, 0.55), 0.07));\n    a += exp(-k * sphere(p + vec3(-0.00, 0, 0.72), 0.1));\n    \n    a += exp(-k * sphere(p + vec3(0, -0.39, 0.8), 0.01));\n\n    a += exp(-k * sphere(p + vec3(0, -0.7, 0.1), 0.15));\n    a += exp(-k * sphere(p + vec3(0, -0.65, -0.05), 0.07));\n\n    return -log(a) / k;\n}\n\nfloat beak(vec3 p, float s)\n{\n    float k = max(length(p)-s, -(length(p+vec3(-0.15,-0.2,-0.1))-0.25));\n    k = max(k, -(length(p+vec3(0.12,-0.2,-0.1))-0.25));\n    return k < 0.0 ? 0.0 : k;\n}\n\nfloat duckBeak(vec3 p) {\n    float k = 12.0;\n    float a = 0.;\n    \n    a += exp(-k * beak(p + vec3(0, -0.55, -0.1), 0.15));\n\n    return -log(a) / k;\n}\n\nvec4 nearest(vec4 d1, vec4 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 rotate(vec3 p, float angle)\n{\n    float  c = cos(angle);\n    float  s = sin(angle);\n    return vec3(c*p.x-s*p.z, p.y, s*p.x+c*p.z);\n}\n\nvec4 map(vec3 pos)\n{\n    vec3 offset = vec3(0, 0.4, -0.3);\n    vec4 res = vec4(duckBody(pos-vec3(-0.0, 0.25, 0.0)+offset), vec3(1, 1, 0));\n    res = nearest(res, vec4(duckBeak(pos-vec3(-0.0, 0.25, 0.0)+offset), vec3(1, 0, 0)));\n    res = nearest(res, vec4(sphere(pos-vec3(0.09, 0.87, 0.14)+offset, 0.06), vec3(0.0, 0, 0.3)));\n    res = nearest(res, vec4(sphere(pos-vec3(-0.09, 0.87, 0.14)+offset, 0.06), vec3(0.0, 0, 0.3)));\n \n    return res;\n}\n\nvec4 castRay(in vec3 ro, in vec3 rd)\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n    float precis = 0.002;\n    float t = tmin;\n    vec3 color = vec3(1, 0, 1);\n    for(int i=0; i<50; i++)\n    {\n        vec4 res = map(ro+rd*t);\n        if(res.x<precis || t>tmax) break;\n        t += res.x;\n        color = res.yzw;\n    }\n\n    if(t>tmax) t=-1.0;\n    return vec4(t, color);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x);\n    return normalize(nor);\n}\n\nvec4 render(in vec3 ro, in vec3 rd, float angle)\n{ \n    vec4 res = castRay(ro,rd);\n\n    float t = res.x;\n    vec3 col = res.yzw;\n    if(t>-0.5)\n    {\n        // Light calculations by iq\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        \n        vec3  lig = normalize(vec3(0.6*cos(angle), 0.3, -0.6*sin(angle)));\n        float amb = clamp(0.5+0.5*nor.y, 0.0, 1.0);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0)*clamp(1.0-pos.y,0.0,1.0);\n        float dom = smoothstep(-0.1, 0.1, ref.y);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.0,1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0),6.0);\n\n        vec3 brdf = vec3(0.0);\n        brdf += 0.50*dif*vec3(1.00,0.90,0.60);\n        brdf += 0.30*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.70*amb*vec3(0.50,0.70,1.00);\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00);\n        brdf += 0.02;\n        col = col*brdf;\n\n        return vec4(clamp(col, 0.0, 1.0), 1.0);\n    }\n   return vec4(0, 0, 0, 0);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta-ro);\n    vec3 cp = vec3(sin(cr), cos(cr),0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec4 mixc(vec4 c1, vec4 c2) {\n  float newa = mix(c2.a, c2.a, c1.a);\n  return vec4(mix(c1.rgb, c2.rgb, newa), 1.0-(1.0-c1.a)*(1.0-c2.a));\n}\n\nvec4 background(vec2 p, float time)\n{\n  float rat = 1.0 + 0.4 * sin(time*0.744);\n  vec3 C1 = vec3(0.7, 0.7, 0.5);\n  vec3 C2 = vec3(0.7, 0.7, 0.4);\n  vec3 C3 = vec3(sin(time)*0.4+0.5, 0.22, 0.712);\n    \n  float dist = length(p);\n  float angle = atan(p.x, p.y);\n  vec4 color = vec4(C3.x, C3.y, C3.z, clamp(1.0 - dist*0.4, 0.0, 1.0)*rat);  \n\n  float ray1 = clamp((sin(angle*6.0 - dist*sin(time)*5.0 + time*2.0) + 0.0) * 2.0, 0.0, 0.7) - dist*0.3;\n  color = mixc(color, vec4(C1.x, C1.y, C1.z, ray1*rat));\n\n  float ray2 = clamp((sin(angle*17.0 -dist * 8.0 + time*3.43) + 0.0) * 2.0, 0.0, 0.4) - dist*0.1;\n  color = mixc(color, vec4(C2.x, C2.y, C2.z, ray2*rat));\n\n  float circ = clamp((2.25-dist*2.0)*0.47, 0.0, 1.0);\n  color = mixc(color, vec4(1, 1, 1, circ*rat));\n    \n  color *= clamp(1.0-pow(p.x*p.x+p.y*p.y, 0.95)*0.2, 0.0, 1.0);\n\n  return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n    float time = iTime;\n    float Dist = 3.0;\n\n    // camera\t\n    float angle = 1.0*time + 6.0*mo.x;\n    vec3 ro = vec3(Dist*cos(angle), 0.0 , Dist*sin(angle));\n    vec3 ta = vec3(-0.0, 0.0, 0.0);\n    mat3 ca = setCamera(ro, ta, 0.0);\n    vec3 rd = ca * normalize(vec3(p.xy,2.5));\n\n    vec4 duckColor = render(ro, rd, -0.8-angle);\n    vec4 backgroundColor = background(p, time);\n    fragColor = mix(backgroundColor, duckColor, duckColor.a);\n}\n","name":"","description":"","type":"image"}]}