{"ver":"0.1","info":{"id":"Xf2cDm","date":"1722436869","viewed":57,"name":"Glow Orb Sphere","username":"artyomspace","description":"A glowing sphere, similar to Siri.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sphere","glow","orb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = acos(-1.0);\nfloat square(float x) { return sign(sin(x * PI)) * 0.5 + 0.5; }\nfloat ramps(float x) { return mod(x,1.0)*square(x); }\nfloat smoothed_ramps(float x) { return smoothstep(0.0,1.0,ramps(x)); }\nfloat steps(float x) { return floor(x / 2.0 + 0.5); }\nfloat ramps_step(float x) { return ramps(x) + steps(x); }\nfloat smoothed_ramps_step(float x) { return smoothed_ramps(x) + steps(x); }\nfloat sphere(vec3 o, float r) { return length(o) - r; }\nfloat cylinder(vec3 o, float r) { return length(o.xz) - r; }\nmat2 rotate(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\nvec3 fetch(vec3 o) {\n    float deform = iTime * 0.22 / 0.35;\n    o.yz *= rotate(smoothed_ramps_step(iTime * 0.22 + 1.0) * PI / 4.0);\n    o.xy *= rotate(smoothed_ramps_step(iTime * 0.22 + 0.5) * PI / 4.0);\n    o.zx *= rotate(smoothed_ramps_step(iTime * 0.22) * PI / 4.0);\n    o.z += 0.1 * sin(o.y * 10.0 + deform);\n    o.x += 0.1 * sin(o.z * 10.0 + deform);\n    o.y += 0.1 * sin(o.x * 10.0 + deform);\n    \n    float object = sphere(o, 0.5);\n    if (object < 0.0) {\n        vec3 color = vec3(\n            (sin(o.x * 10.0 + iTime * 0.22) + 1.0) * 0.012 + 0.02,\n            (sin(o.y * 10.0 + iTime * 0.22) + 1.0) * 0.013 + 0.015,\n            (sin(o.z * 10.0 + iTime * 0.22) + 1.0) * 0.032 + 0.02\n        );\n        color /= 4.0;\n        return color;\n    } else {\n        return vec3(0.0);\n    }\n}\n\n// Circular mask function with diameter equal to height * 0.75\nfloat circularMask(vec2 uv, vec2 center, float radius) {\n    float dist = length(uv - center);\n    return smoothstep(radius, radius - 0.01, dist);\n}\n\n// Ellipse function for the glow effect\nfloat Ellipse(vec2 UV, float Width, float Height) {\n    float d = length(((UV * 2.0) - vec2(1.0)) / vec2(Width, Height)); \n    return clamp((1.0 - d) / d, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec3 light = vec3(0.0);\n\n    vec3 o = vec3(0.0, 0.0, -1.0);\n    vec3 d = normalize(vec3(p.xy, 2.0));\n    \n    float t = 0.0;\n    for (int i = 0; i < 200; i++) {\n        t += 0.01;\n        light += fetch(d * t + o);\n    }\n\n    // Define the center and radius for the circular mask\n    vec2 center = vec2(iResolution.x / 2.0, iResolution.y / 2.0);\n    float radius = (iResolution.y * 0.75) / 2.0;\n\n    // Apply circular mask\n    float mask = circularMask(fragCoord.xy, center, radius);\n    light *= mask;\n\n    // Glow effect logic\n    vec2 uv = (fragCoord - center) / iResolution.y * 2.49;\n    float vol1 = 0.0; // Static volume for simplicity\n    uv.y += vol1;\n\n    float ssc = vol1 * 0.4 + 0.9;\n    uv *= ssc;\n    float le = length(uv * 1.2); \n    float as; \n    float le2 = le < 1.0 ? le : 0.0;\n    as = tan(asin(le2)); \n    vec2 n = normalize(uv * 1.2); \n    as *= 0.196; \n    n *= as;\n    vec4 color1 = vec4(1.0, 0.6, 0.0, 1.0); \n    vec4 color2 = vec4(0.30, 0.6, 0.0, 1.0) * 1.8; \n    vec4 color3 = vec4(0.130, 0.36, 0.80, 1.0) * 2.5; \n    vec4 color4 = vec4(0.630, 0.16, 0.80, 1.0) * 1.4; \n    vec4 color5 = vec4(0.730, 0.56, 0.80, 1.0) * 1.1; \n    vec2 fnR = vec2(fract(n.x + cos(iTime * 0.3) * 1.1), fract(n.y + 0.325 + iTime * 0.3 * 0.21));\n\n    float c1 = Ellipse(fnR, 0.645 * ssc, 0.85); \n    float c1b = Ellipse(vec2(fract((n.x * -1.0 + 0.5) + cos(iTime * 0.3) * 1.1), fnR.y), 0.645, 0.85); \n    c1 = max(c1, 0.9 * c1b); \n    vec2 fnG = vec2(fract(n.x + iTime * 0.3 * 0.521), fract(n.y + 0.125 + sin(iTime * 0.3) * 1.421)); \n    float c2 = Ellipse(fnG, 0.6145, 0.95); \n    vec2 fnB = vec2(fract(n.x + iTime * 0.3 * 0.1521), fract(n.y + 0.125 + cos(iTime * 0.3) * 2.421)); \n    float c3 = Ellipse(fnB, 0.6145 * ssc, 0.795); \n    vec2 fnY = vec2(fract(n.x + iTime * 0.3 * 0.3521), fract(n.y + 0.125 + sin(cos(iTime * 0.3) * 2.421))); \n    float c4 = Ellipse(fnY, 0.6145, 0.795); \n    vec2 fnY2 = vec2(fract(n.x + iTime * 0.3 * 0.7521), fract(n.y + 0.125 + iTime * 0.3 * 1.421)); \n    float c5 = Ellipse(fnY, 0.2145, 0.895);\n    color1 *= c1; color2 *= c2; color3 *= c3; color4 *= c4; color5 *= c5; \n    vec4 glowColor = color1 + color2 + color3 + color4 + color5; \n    glowColor = mix(glowColor, vec4(as, as, as, as), 0.55); \n    glowColor = glowColor + vec4(as, as, as, as); \n    le = (le < 1.0) ? 1.0 : 0.0;\n\n    // Blend the original light with the glow\n    vec3 finalColor = mix(light, glowColor.rgb * 1.2 * le, 0.3);\n    \n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}