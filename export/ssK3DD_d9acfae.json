{"ver":"0.1","info":{"id":"ssK3DD","date":"1631870758","viewed":529,"name":"Midnight Flight through Clouds","username":"sunhokim","description":"This shader features procedural volumetric clouds with a simple single scattering. Use mouse to move camera around.\n\n\nI got a lot of help from alro. Thank you alro!","likes":21,"published":1,"flags":32,"usePreview":0,"tags":["clouds"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec4 col = textureLod(iChannel0, fragCoord / iResolution.xy, 0.0);\n  fragColor = col;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float hash(float x) {\n    uint v = floatBitsToUint(x);\n\tuint state = v * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float((word >> 22u) ^ word)*(1.0/float(0xffffffffu));\n}\n\nvec2 hash2(vec2 x) {\n    uvec2 v = uvec2(x);\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return vec2(v)*(1.0/float(0xffffffffu));\n}\n\nvec3 hash3(vec3 x) {\n    uvec3 v = uvec3(x);\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return vec3(v)*(1.0/float(0xffffffffu));\n}\n\nvec3 ihash3(vec3 v){\n    return hash3(v) * 2.0 - 1.0;\n}\n\nivec2 resolution;\n\nivec3 volumeCordFrom2D(ivec2 uv) {\n    int gridSize = resolution.x / 34;\n    int xoff = uv.x / 34;\n    int yoff = uv.y / 34;\n    int z = xoff + yoff * gridSize;\n    uv = ((uv % 34) - 1 ) % 32;\n    return ivec3(uv.x, uv.y, z);\n}\n\nivec2 volumeCordFrom3D(ivec3 p) {\n    int gridSize = resolution.x / 34;\n    \n    int yoff = p.z / gridSize;\n    int xoff = p.z % gridSize; \n    return ivec2(p.x + xoff*34, p.y + yoff*34)+1;\n}\n\nfloat remap(float x, float a, float b, float c, float d) {\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//******************\n//* noise creation *\n//******************\n\nvec4 perlinNoise(in vec3 x, vec3 bias, float period) {\n  vec3 i = floor(x);\n  vec3 w = fract(x);\n\n  vec3 u = w * w * (3.0 - 2.0 * w);\n  vec3 du = 6.0 * w * (1.0 - w);\n\n  vec3 ga = ihash3(mod(i + vec3(0.0, 0.0, 0.0), period) + bias);\n  vec3 gb = ihash3(mod(i + vec3(1.0, 0.0, 0.0), period) + bias);\n  vec3 gc = ihash3(mod(i + vec3(0.0, 1.0, 0.0), period) + bias);\n  vec3 gd = ihash3(mod(i + vec3(1.0, 1.0, 0.0), period) + bias);\n  vec3 ge = ihash3(mod(i + vec3(0.0, 0.0, 1.0), period) + bias);\n  vec3 gf = ihash3(mod(i + vec3(1.0, 0.0, 1.0), period) + bias);\n  vec3 gg = ihash3(mod(i + vec3(0.0, 1.0, 1.0), period) + bias);\n  vec3 gh = ihash3(mod(i + vec3(1.0, 1.0, 1.0), period) + bias);\n\n  float va = dot(ga, w - vec3(0.0, 0.0, 0.0));\n  float vb = dot(gb, w - vec3(1.0, 0.0, 0.0));\n  float vc = dot(gc, w - vec3(0.0, 1.0, 0.0));\n  float vd = dot(gd, w - vec3(1.0, 1.0, 0.0));\n  float ve = dot(ge, w - vec3(0.0, 0.0, 1.0));\n  float vf = dot(gf, w - vec3(1.0, 0.0, 1.0));\n  float vg = dot(gg, w - vec3(0.0, 1.0, 1.0));\n  float vh = dot(gh, w - vec3(1.0, 1.0, 1.0));\n\n  return vec4(va + u.x * (vb - va) + u.y * (vc - va) + u.z * (ve - va) + u.x * u.y * (va - vb - vc + vd) + u.y * u.z * (va - vc - ve + vg) + u.z * u.x * (va - vb - ve + vf) + (-va + vb + vc - vd + ve - vf - vg + vh) * u.x * u.y * u.z, // value\n    ga + u.x * (gb - ga) + u.y * (gc - ga) + u.z * (ge - ga) + u.x * u.y * (ga - gb - gc + gd) + u.y * u.z * (ga - gc - ge + gg) + u.z * u.x * (ga - gb - ge + gf) + (-ga + gb + gc - gd + ge - gf - gg + gh) * u.x * u.y * u.z + // derivatives\n    du * (vec3(vb, vc, ve) - va + u.yzx * vec3(va - vb - vc + vd, va - vc - ve + vg, va - vb - ve + vf) + u.zxy * vec3(va - vb - ve + vf, va - vb - vc + vd, va - vc - ve + vg) + u.yzx * u.zxy * (-va + vb + vc - vd + ve - vf - vg + vh)));\n}\n\nfloat worleyNoise(vec3 x, float prob, vec3 bias, float period) {\n  vec3 ii = floor(x);\n  vec3 w = fract(x);\n\n  float dist = 1.0;\n  for (int i = -1; i <= 1; ++i) {\n    for (int j = -1; j <= 1; ++j) {\n      for (int k = -1; k <= 1; ++k) {\n        vec3 n = vec3(i, j, k);\n        vec3 l = mod(ii + n, period) + bias;\n        vec3 nn = ihash3(l) * 0.5 + 0.5 + n;\n        vec3 d = w - nn;\n        float u = hash(l.x + 12.0 * l.y + 53.0 * l.z);\n        dist = min(dist, u < prob ? dot(d, d) : 1.0);\n      }\n    }\n  }\n\n  return 1.0 - dist;\n}\n\nfloat perlinFbm(vec3 p, vec3 bias, float freq) {\n  float a = 1.0;\n  float t = 0.;\n  for (int i = 0; i < 8; ++i) {\n    t += a * perlinNoise(p * freq, bias, freq).x;\n    freq *= 2.;\n    a *= 0.5;\n  }\n\n  return t;\n}\n\nfloat worleyFbm(vec3 p, vec3 bias, float prob, float freq, int octaves) {\n  float a = 0.625;\n  float t = 0.0;\n  for (int i = 0; i < octaves; ++i) {\n    t += a * worleyNoise(p * freq, prob, bias, freq);\n    freq *= 2.0;\n    a *= 0.4;\n  }\n\n  return t;\n}\n\nfloat multiLevelWorley(vec3 p, vec3 bias, float prob, float fr) {\n  float a = clamp(worleyFbm(p, bias, prob, fr, 8), 0.0, 1.0);\n  float b = clamp(worleyFbm(p, bias, prob, fr * 2.0, 8), 0.0, 1.0);\n  float c = clamp(worleyFbm(p, bias, prob, fr * 4.0, 8), 0.0, 1.0);\n  return .625 * a + .25 * b + .125 * c;\n}\n\nbool resolutionChanged() {\n  return abs(texelFetch(iChannel1, ivec2(0), 0).r - clamp(iResolution.x / 2000.0, 0.0, 1.0)) > 0.005;\n}\n\nvec2 noise(vec3 p) {\n  float pfbm = clamp(perlinFbm(p, vec3(0.0), 6.0), 0.0, 1.0);\n  float wfbm = multiLevelWorley(p, vec3(56.0), 0.8, 4.0);\n  float pf = remap(pfbm, -wfbm, 1.0, 0.0, 1.0);\n  float w = multiLevelWorley(p, vec3(14.0), 0.8, 8.0);\n  return vec2(pf, w);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  if (resolutionChanged()) {\n    resolution = ivec2(iResolution.xy);\n    vec3 p = vec3(volumeCordFrom2D(ivec2(fragCoord))) / 32.0;\n    vec4 col = vec4(noise(p), noise(vec3(p.x, p.y, mod(p.z + 1.0, 32.0))));\n    fragColor = col;\n  } else {\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n  }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define M_PI (3.1415926535897932384626433832795)\n#define ZERO (min(int(iTime), 0))\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst vec3 SIGMA = (1.0 - vec3(0.08, 0.01, 0.16)) * 0.3;\nconst vec3 AMBIENT = vec3(0.08, 0.09, 0.25) * 5.0;\nconst vec3 MOON_POS = vec3(400.0, 20.0, -1000.0);\n\n#ifdef HW_PERFORMANCE\nconst int SAMPLE_COUNT = 64;\n#else\nconst int SAMPLE_COUNT = 16;\n#endif\n\nconst float SAMPLE_MAX_DIST = 800.0;\n\nconst vec3 CONE_KERNEL[6] = vec3[6](\n  vec3(-0.053, -0.3427, 0.938),\n  vec3(0.495, 0.765, -0.410),\n  vec3(0.933, 0.195, 0.302),\n  vec3(-0.796, 0.189, 0.573),\n  vec3(0.546, 0.575, 0.608),\n  vec3(-0.425, 0.400, 0.811)\n);\n\n//*********\n//* utils *\n//*********\n\nmat2 rotmat(float th) {\n  return mat2(cos(th), -sin(th), sin(th), cos(th));\n}\n\nfloat smoothrange(float value, float min1, float max1, float pad) {\n  return smoothstep(min1, min1 + pad, value) * smoothstep(max1 + pad, max1, value);\n}\n\nfloat perlinNoise(in vec2 x) {\n  return texture(iChannel1, x / 256.0).x;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\nmat3 viewMat(in vec3 eye, in vec3 look) {\n  vec3 w = normalize(eye - look);\n  vec3 u = normalize(cross(w, vec3(0, 1.0, 0)));\n  vec3 v = cross(u, w);\n  return mat3(u, v, w);\n}\n\n//*******\n//* sky *\n//*******\n\nfloat randu(vec2 p) {\n  return fract(sin(dot(p, vec2(123.1, 311.7))) * 43953.5453);\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb) {\n  p.y = abs(p.y);\n  float a = (ra * ra - rb * rb + d * d) / (2.0 * d);\n  float b = sqrt(max(ra * ra - a * a, 0.0));\n  if (d * (p.x * b - p.y * a) > d * d * max(b - p.y, 0.0))\n    return length(p - vec2(a, b));\n  return max((length(p) - ra),\n    -(length(p - vec2(d, 0)) - rb));\n}\n\nfloat distribution(vec2 x) {\n  return pow(perlinNoise(0.05 * x) * 0.5, 3.5);\n}\n\nvec3 star(in vec2 p) {\n    float sc = 50.0;\n    vec2 x = sc*p;\n    vec2 i_st = floor(x);\n    vec2 f_st = fract(x);\n\n    vec3 col = vec3(0.0);\n    \n    vec2 point = hash2(i_st*60.0);\n    vec2 diff = 0.5+(0.2*point-0.2) - f_st;\n    float dist = length(diff);\n    float u = hash(i_st.x + i_st.y*53.0);\n    float twinkle = pow(0.04/dist,2.4);\n    col += twinkle*vec3(0.5)*step(u, distribution((i_st+point)/sc));\n\n    return col;\n}\n\nvec3 starfbm(vec2 p) {\n     float G = 0.4;\n    float f = 1.0;\n    float a = 1.0;\n    vec3 t = vec3(0.0);\n    for( int i=0; i<2; i++ )\n    {\n        t += a* star(f*p);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\nfloat gasFbm(in vec2 x) {\n  float G = 0.4;\n  float f = 1.0;\n  float a = 1.0;\n  float t = 0.0;\n  x *= 10.0;\n  for (int i = 0; i < 8; i++)\n  {\n    t += a * perlinNoise(f * x);\n    f *= 3.0;\n    a *= G;\n    x.xy *= rotmat(1.3);\n  }\n  return t;\n}\n\nvec3 moon(vec2 p) {\n  float dis = sdMoon(50.0 * ((p * rot(0.65)) - vec2(0.3, -0.2)), 0.3, 1.51, 1.5);\n  return vec3(1.0) * pow((0.05 / max(dis, 0.01)), 0.85);\n}\n\nvec3 skyColor(vec3 rd) {\n  float k = 1.0 - clamp((rd.y - 0.4) / 1.8, 0.0, 1.0);\n  float d = smoothstep(0.3, 0.0, rd.y) * 0.05;\n  vec3 sky = vec3(0.0 + 0.04 * k, 0.0 + 0.02 * k, 0.01 + 0.14 * k );\n\n  float gas = perlinNoise(vec2(5.0, 4.0) * rd.xy) + 0.25 * perlinNoise(2.0 * vec2(5.0, 4.0) * rd.xy);\n  float gas2 = gasFbm(1.15 * rd.xy);\n  vec3 gasCol = vec3(0.0);\n  gasCol += 0.1 * (pow(gas2, 2.1)) * vec3(0.2, 0.2, 0.6);\n  gasCol = mix(gasCol, 0.2 * (pow(gas, 3.0)) * vec3(0.1, 0.43, 0.6 + 0.3 * k), 0.3);\n  vec3 starCol = starfbm(rd.xy);\n  starCol *= smoothstep(-0.07, -0.04, rd.y);\n  starCol *= smoothstep(0.08, 0.1, length(rd.xy - vec2(0.38,0.05)));\n  return sky + gasCol + starCol + moon(rd.xy);\n}\n\n//**************\n//* volumetric *\n//**************\n\nvec2 sampleCloudNoise(vec3 p) {\n  p *= 32.0;\n  p = mod(p, 32.0);\n  vec3 f = fract(p);\n  vec4 tex = textureLod(iChannel0, (vec2(volumeCordFrom3D(ivec3(p))) + f.xy) / iResolution.xy, 0.0);\n  return tex.rg * (1.0 - f.z) + tex.ba * f.z;\n}\n\nfloat hg(float cosTh, float g) {\n  float D = (1.0 + g * g - 2.0 * g * cosTh);\n  return (1.0 / (4.0 * M_PI)) * (1.0 - g * g) / (D * sqrt(D));\n}\n\nfloat scatter(float cosTh) {\n  return mix(hg(cosTh, 0.3), hg(cosTh, -0.1), 0.5);\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(k - abs(a - b), 0.0);\n  return min(a, b) - h * h * 0.25 / k;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdCloud(vec3 p, float r) {\n  float h = 1e10;\n  vec3 q = r * p;\n  h = min(sdSphere(q - vec3(1.0, 0.0, 0.0), 1.0), h);\n  h = min(sdSphere(q - vec3(0.0, 0.6, 0.5), 0.5), h);\n  h = min(sdSphere(q - vec3(0.2, 0.0, 0.0), 0.5), h);\n  h = min(sdSphere(q - vec3(0.0, 0.0, 0.0), 1.0), h);\n  h = min(sdSphere(q - vec3(0.5, 0.3, 0.7), 1.0), h);\n  return h / r;\n}\n\nfloat sdCloud2(vec3 p, float r) {\n  float h = 1e10;\n  vec3 q = r * p;\n  h = min(sdSphere(q - vec3(1.0, 0.0, 1.0), 2.1), h);\n  h = min(sdSphere(q - vec3(0.2, 1.2, 1.0), 0.8), h);\n  h = min(sdSphere(q - vec3(0.4, -0.5, 0.7), 0.8), h);\n  h = min(sdSphere(q - vec3(-0.6, 0.0, 0.0), 1.6), h);\n  h = min(sdSphere(q - vec3(0.5, 0.3, 0.7), 1.0), h);\n  return h / r;\n}\n\nfloat mapCloud(vec3 p, vec3 o, float dd, float s, float prob) {\n  vec3 q = p * s;\n  //q.x += exp(q.z);\n  vec2 n = floor(q.xz);\n  float nid = floor(o.z * s);\n  vec2 f = fract(q.xz);\n  float id = n.x * 30.0 + n.y * 12.0;\n  float id2 = n.x + n.y * 22.0;\n  float ra2 = hash(id);\n  float ra = hash(id2);\n  vec3 pp = vec3(0);\n  pp.y = q.y;\n  pp.xz = -f + 0.5;\n  //pp.xz*=rot(ra*M_PI*2.0);\n  float n2 = sdCloud(pp, 3.5 + 1.0 * ra) / s;\n  dd = min(n2 + step(prob, ra2) * 1e5, dd);\n  return dd;\n}\n\nfloat cloudFbm(vec2 p) {\n  float a = 1.0;\n  float f = 1.0;\n  float t = 0.0;\n  for (int i = 0; i < 3; i++) {\n    t += a * cos(9.0 * 0.5 * (2.0 * perlinNoise(f * p.xy) - 1.0));\n    f *= 2.0;\n    p.xy *= rot(1.1);\n    a *= 0.5;\n  }\n  return t;\n}\n\nfloat map(vec3 p, vec3 o) {\n  float t = 0.0;\n  float h = 1e10;\n  h = min(h, sdBox(o - vec3(0.0, -15.0, 0.0), vec3(1000.0, 15.0, 1000.0)));\n  float k = 13.0 * (cloudFbm(vec2(0.017, 0.012) * p.xz));\n  h -= k;\n  /* h = mapCloud(q-vec3(21.3,6.0,1040.0), o, h, 0.02, 0.8);\n  h = mapCloud(q-vec3(110.0,6.0,3070.8), o, h, 0.02, 0.6);\n  h = mapCloud(q-vec3(325.0,6.0,7552.8), o, h, 0.02, 0.6);\n  h = mapCloud(q-vec3(395.0,6.0,2903.8), o, h, 0.02, 0.8);\n  h = mapCloud(q-vec3(420.0,6.0,263.8), o, h, 0.02, 0.9);*/\n  return h;\n}\n\nfloat density(vec3 p) {\n  vec3 q = 1.0*p + vec3(5270.0+ 2.0 * iTime, -3.0, 0.0);\n  vec2 no = sampleCloudNoise(0.075 * 0.25 * q);\n  float dd = -map(q, p);\n  //.x = clamp(no.x, 0.0, 0.5);\n  dd = dd * 0.021 ;\n  dd = remap(dd, -1.2 * no.x, 1.0, 0.0, 1.0);\n  dd = remap(dd, 0.2 * (1.0 - no.y), 1.0, 0.0, 1.0);\n  return clamp(dd, 0.0, 1.0);\n}\n\nvec3 shadow(in vec3 ro, in vec3 rd) {\n  const float STEP = 8.0;\n  vec3 moonDir = normalize(MOON_POS - ro);\n  float dd = 0.0;\n  for (int i = ZERO; i < 6; ++i) {\n    vec3 jitter = CONE_KERNEL[i] * 0.75 * STEP * float(i);\n    vec3 p = ro + (float(i) * STEP + 0.5) * moonDir + jitter;\n    float d = density(p);\n    dd += d;\n  }\n  return exp(-dd * SIGMA * STEP * 1.0);\n}\n\nvec3 raymarch(in vec3 ro, in vec3 rd, vec2 pixelPos) {\n  const float STEP = SAMPLE_MAX_DIST / float(SAMPLE_COUNT);\n\n  vec3 accumulated = vec3(0.0);\n  vec3 tr = vec3(1.0);\n  float u = hash2(abs(pixelPos + 4000.0*sin(1.0*iTime))).y;\n  float time = u * STEP;\n  float dd = 0.0;\n  for (int i = ZERO; length(tr) > 0.01; ++i) {\n    vec3 pos = ro + time * rd;\n    float d = density(pos);\n    if (i > SAMPLE_COUNT) {\n      return skyColor(rd);\n    }\n    vec3 moonDir = normalize(MOON_POS - pos);\n    float cosTh = -dot(moonDir, rd);\n    vec3 li = 1.0 * 2.0 * shadow(pos, rd);\n    dd += d * STEP;\n    accumulated += li * scatter(cosTh) * tr * d * STEP;\n    tr *= exp(-d * SIGMA * STEP);\n    time += STEP;\n  }\n  return accumulated + AMBIENT * (vec3(1.0) - tr);\n}\n\n// From https://www.shadertoy.com/view/WdjSW3\nfloat tonemapUchimura(float x, float P, float a, float m, float l, float c, float b) {\n  float l0 = ((P - m) * l) / a;\n  float L0 = m - m / a;\n  float L1 = m + (1.0 - m) / a;\n  float S0 = m + l0;\n  float S1 = m + a * l0;\n  float C2 = (a * P) / (P - S1);\n  float CP = -C2 / P;\n\n  float w0 = 1.0 - smoothstep(0.0, m, x);\n  float w2 = step(m + l0, x);\n  float w1 = 1.0 - w0 - w2;\n\n  float T = m * pow(x / m, c) + b;\n  float S = P - (P - S1) * exp(CP * (x - S0));\n  float L = m + a * (x - m);\n\n  return T * w0 + L * w1 + S * w2;\n}\n\nfloat tonemapUchimura(float x) {\n  const float P = 1.0;\n  const float a = 1.0;\n  const float m = 0.22;\n  const float l = 0.4;\n  const float c = 1.33;\n  const float b = 0.0;\n  return tonemapUchimura(x, P, a, m, l, c, b);\n}\n\nbool resolutionChanged() {\n  return abs(texelFetch(iChannel3, ivec2(0), 0).r - clamp(iResolution.x / 2000.0, 0.0, 1.0)) > 0.005;\n}\n\n\n//********\n//* main *\n//********\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //\n  // Camera\n  //\n  resolution = ivec2(iResolution.xy);\n  const float R = 60.0;\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  if (mouse == vec2(0.0)) {\n    mouse = vec2(0.83, 0.35);\n  }\n  vec2 spr = vec2((mouse.x - 0.5) * M_PI * 0.4 - 0.2 * M_PI, (mouse.y - 0.5) * M_PI * 0.35 - 0.3 * M_PI);\n  vec3 eye = vec3(-R * sin(spr.x) * sin(spr.y), R * cos(spr.y), -R * sin(spr.y) * cos(spr.x)) + vec3(0.0, 40.0, 20.0);\n  vec3 look = vec3(0.0, 60.0, 0.0);\n  mat3 view = viewMat(eye, look);\n  vec3 dir = view * rayDirection(45.0, iResolution.xy, fragCoord);\n\n  vec3 col = raymarch(eye, dir, fragCoord).rgb;\n  col = mix(col, vec3(col.x + col.y + col.z) * 0.33, 0.1);\n  col = vec3(tonemapUchimura(col.r), tonemapUchimura(col.g), tonemapUchimura(col.b));\n  col = pow(col, vec3(1.0 / 2.2));\n\n  if (fragCoord.x < 1. && fragCoord.y < 1.) {\n    fragColor = vec4(clamp(iResolution.x / 2000.0, 0.0, 1.0), vec3(0.));\n  } else if (fragCoord.x < 2. && fragCoord.y < 1.) {\n    fragColor = vec4(mouse, 0.0, 0.0);\n  } else {\n    vec4 oldMouse = texelFetch(iChannel3, ivec2(1, 0), 0);\n    vec4 oldCol = textureLod(iChannel3, fragCoord.xy / iResolution.xy, 0.0);\n    if (length(mouse - oldMouse.xy) < 0.001 && iFrame > 5 && !resolutionChanged()) {\n      col = mix(oldCol.rgb, col, 0.1);\n      fragColor = vec4(col, 1.0);\n    } else {\n      fragColor = vec4(col, 1.0);\n    }\n  }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}