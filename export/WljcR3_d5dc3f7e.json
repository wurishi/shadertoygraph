{"ver":"0.1","info":{"id":"WljcR3","date":"1594972880","viewed":724,"name":"Infinite Ocean (By Criyson)","username":"Criyson","description":"Continuously updating","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float k_screenshotTime = 13.0;\nconst int k_raymarchSteps = 96;\nconst int k_fmbSteps = 3;\nconst int k_superSampleCount = 10;\nconst int k_fmbWaterSteps = 4;\n#define OBJ_ID_SKY 0.0\n#define OBJ_ID_GROUND 1.0\nfloat g_fTime;\nconst vec3 g_vSunDir = vec3( -100.0, 70., 25. );\nvec3 GetSunDir() { return normalize( g_vSunDir ); }\n\nconst vec3 g_sunColour = vec3( 1.0, 0.85, 0.5 ) * 5.0;\nconst vec3 g_skyColour = vec3( 0.1, 0.5, 1.0 ) * 1.0;\nconst vec3 k_bgSkyColourUp = g_skyColour * 4.0;\nconst vec3 k_bgSkyColourDown = g_skyColour * 6.0;\nconst vec3 k_envFloorColor = vec3(0.3, 0.2, 0.2);\nconst vec3 k_vFogExt = vec3(0.01, 0.015, 0.015) * 3.0;\nconst vec3 k_vFogIn = vec3(1.0, 0.9, 0.8) * 0.015;\n\n#define MOD2 vec2(4.438975,3.972973)\n\n// 哈希算法, 提供随机噪声的高度\nfloat Hash( float p ) {\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);    \n}\n\nvec2 Hash2( float p ) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Perlin噪声 + 线性过度处理\nfloat SmoothNoise(in vec2 o) {\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\tfloat n = p.x + p.y*57.0;\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n    return res;\n}\n\n// FBM算法, 对perlin噪声进行迭代\nfloat FBM( vec2 p, float ps ) {\n\tfloat f = 0.0;\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i < k_fmbSteps; i++) {\n        f += SmoothNoise( p ) * a;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n// 对SmoothNoise求导\nvec3 SmoothNoise_DXY(in vec2 o) {\n\tvec2 p = floor(o);\n\tvec2 f = fract(o);\n\tfloat n = p.x + p.y*57.0;\n\tfloat a = Hash(n+  0.0);\n\tfloat b = Hash(n+  1.0);\n\tfloat c = Hash(n+ 57.0);\n\tfloat d = Hash(n+ 58.0);\n\tvec2 f2 = f * f;\n\tvec2 f3 = f2 * f;\n\tvec2 t = 3.0 * f2 - 2.0 * f3;\n\tvec2 dt = 6.0 * f - 6.0 * f2;\n\tfloat u = t.x;\n\tfloat v = t.y;\n\tfloat du = dt.x;\t\n\tfloat dv = dt.y;\n\tfloat res = a + (b-a)*u +(c-a)*v + (a-b+d-c)*u*v;\n\tfloat dx = (b-a)*du + (a-b+d-c)*du*v;\n\tfloat dy = (c-a)*dv + (a-b+d-c)*u*dv; \n    return vec3(dx, dy, res);\n}\n\n// 对FBM求导\nvec3 FBM_DXY( vec2 p, vec2 flow, float ps, float df ) {\n\tvec3 f = vec3(0.0);\n    float tot = 0.0;\n    float a = 1.0;\n    for( int i=0; i<k_fmbWaterSteps; i++) {\n        p += flow;\n        flow *= -0.75; // modify flow for each octave - negating this is fun\n        vec3 v = SmoothNoise_DXY( p );\n        f += v * a;\n        p += v.xy * df;\n        p *= 2.0;\n        tot += a;\n        a *= ps;\n    }\n    return f / tot;\n}\n\n// 地形高度采样, 利用fbm迭代算出地形\nfloat GetTerrainHeight( const vec3 vPos ) {    \n    float fbm = FBM( vPos.xz * vec2(0.5, 1.0), 0.5 );\n    float fTerrainHeight = fbm * fbm * 0.05;\n    fTerrainHeight -= 0.3 + (0.5 + 0.5 * sin( vPos.z * 0.001 + 3.0)) * 0.4;\n    return fTerrainHeight;\n}\n\n// 距离场函数\nfloat GetSceneDistance( const vec3 vPos ) {\n    return vPos.y - GetTerrainHeight( vPos );\n}\n\nfloat GetFlowDistance( const vec2 vPos ) {\n    return -GetTerrainHeight( vec3( vPos.x, 0.0, vPos.y ) );\n}\n\nvec2 GetBaseFlow( const vec2 vPos ) {\n    return vec2( 1.0, 0.);\n}\n\nvec2 GetGradient( const vec2 vPos ) {\n    vec2 vDelta = vec2(0.01, 0.00);\n    float dx = GetFlowDistance( vPos + vDelta.xy ) - GetFlowDistance( vPos - vDelta.xy );\n    float dy = GetFlowDistance( vPos + vDelta.yx ) - GetFlowDistance( vPos - vDelta.yx );\n    return vec2( dx, dy );\n}\n\nvec4 SampleWaterNormal( vec2 vUV, vec2 vFlowOffset, float fMag ) {    \n    vec2 vFilterWidth = max(abs(dFdx(vUV)), abs(dFdy(vUV)));\n  \tfloat fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    float fScale = (1.0 / (1.0 + fFilterWidth * fFilterWidth * 2000.0));\n    float fGradientAscent = 0.25 ;\n    vec3 dxy = FBM_DXY(vUV * 20.0, vFlowOffset * 20.0, 0.75, fGradientAscent);\n    vec3 vBlended = mix( vec3(0.0, 1.0, 0.0), normalize( vec3(dxy.x, fMag, dxy.y) ), fScale );\n    return vec4( normalize( vBlended ), dxy.z * fScale );\n}\n\nvec4 SampleFlowingNormal( const vec2 vUV, const vec2 vFlowRate, const float time ) {\n    float fMag = 2.5 / (1.0 + dot( vFlowRate, vFlowRate ) * 5.0);\n    float t0 = fract( time );\n    float t1 = fract( time + 0.5 );\n    \n    float i0 = floor( time );\n    float i1 = floor( time + 0.5 );\n    \n    float o0 = t0 - 0.5;\n    float o1 = t1 - 0.5;\n    \n    vec2 vUV0 = vUV + Hash2(i0);\n    vec2 vUV1 = vUV + Hash2(i1);\n    \n    vec4 sample0 = SampleWaterNormal( vUV0, vFlowRate * o0, fMag );\n    vec4 sample1 = SampleWaterNormal( vUV1, vFlowRate * o1, fMag );\n\n    float weight = abs( t0 - 0.5 ) * 2.0;\n    vec4 result=  mix( sample0, sample1, weight );\n    result.xyz = normalize(result.xyz);\n\n    return result;\n}\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput ){\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\tfloat fDist = dot(vOffset, vOffset);\n\tconst float kStrength = 0.8;\n\tfloat fShade = mix( 1.0, 1.0 - kStrength, fDist );\t\n\treturn vInput * fShade;\n}\n\nvec3 Tonemap( vec3 x ) {\n    float a = 0.010;\n    float b = 0.132;\n    float c = 0.010;\n    float d = 0.163;\n    float e = 0.101;\n    return ( x * ( a * x + b ) ) / ( x * ( c * x + d ) + e );\n}\n\nstruct Intersection {\n    float m_dist;\n    float m_objId;\n    vec3 m_pos;\n};\n    \nvoid RaymarchScene( vec3 vRayOrigin, vec3 vRayDir, float near, float far, out Intersection intersection ) {\n    float stepScale = 1.0;\n    intersection.m_dist = near;\n    intersection.m_objId = OBJ_ID_SKY;\n    float sceneDist = 0.0;\n    // k_raymarchSteps 作为步进次数上限, 在次数限制内查找物体\n    for( int iter = 0; iter < k_raymarchSteps; iter++ ) {\n        vec3 vPos = vRayOrigin + vRayDir * intersection.m_dist;\n        sceneDist = GetSceneDistance( vPos );\n        intersection.m_dist += sceneDist * stepScale;\n        intersection.m_objId = OBJ_ID_GROUND;\n        if ( sceneDist <= 0.01 ) {\n            break;\n        }\n        if ( intersection.m_dist > far ) {\n            intersection.m_objId = OBJ_ID_SKY;\n            intersection.m_dist = far;\n            break;\n        }\n    }\n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\nvec3 GetSceneNormal(const in vec3 vPos) {\n    const float fDelta = 0.001;\n\n    vec3 vDir1 = vec3( 1.0, 0.0, -1.0);\n    vec3 vDir2 = vec3(-1.0, 0.0,  1.0);\n    vec3 vDir3 = vec3(-1.0, 0.0, -1.0);\n\t\n    vec3 vOffset1 = vDir1 * fDelta;\n    vec3 vOffset2 = vDir2 * fDelta;\n    vec3 vOffset3 = vDir3 * fDelta;\n\n    vec3 vPos1 = vPos + vOffset1;\n    vec3 vPos2 = vPos + vOffset2;\n    vec3 vPos3 = vPos + vOffset3;\n \n    float f1 = GetSceneDistance( vPos1 );\n    float f2 = GetSceneDistance( vPos2 );\n    float f3 = GetSceneDistance( vPos3 );\n    \n    vPos1.y -= f1;\n    vPos2.y -= f2;\n    vPos3.y -= f3;\n    \n    vec3 vNormal = cross( vPos1 - vPos2, vPos3 - vPos2 );\n    \n    return normalize( vNormal );\n}\n\n\n// 追踪水面场景算法\nvoid TraceWater( vec3 vRayOrigin, vec3 vRayDir, float near, float far, out Intersection intersection ) {\n \tintersection.m_dist = far;\n    // 求出相机在y轴分量上, 与是方向距离的倍数\n    // 所得倍数与RayDir的乘积, 结合相机位置, 可求出水面的具体坐标\n    float t = -vRayOrigin.y / vRayDir.y;\n    if ( t > 0.0 )  {\n        intersection.m_dist = t;\n    }\n    intersection.m_pos = vRayOrigin + vRayDir * intersection.m_dist;\n}\n\n\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y)), tri(p.z+tri(p.x)), tri(p.y+tri(p.x)));}\nfloat triNoise(in vec3 p) {\n    float z = 1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=4.; i++ ) {\n        p += tri3(bp*2.);\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n} \n\nstruct Surface {\n    vec3 m_pos;\n    vec3 m_normal;\n    vec3 m_albedo;\n    vec3 m_specR0;\n    float m_gloss;\n    float m_specScale;\n};\n\nvoid GetSurfaceInfo( Intersection intersection, out Surface surface ) {\n    surface.m_pos = intersection.m_pos;\n    surface.m_normal = GetSceneNormal(intersection.m_pos);\n    vec3 vNoisePos = surface.m_pos * vec3(0.4, 0.3, 1.0);\n\tsurface.m_normal = normalize(surface.m_normal + (vNoisePos));\n    float fNoise = triNoise(vNoisePos);\n    fNoise = pow( fNoise, 0.15);\n    surface.m_albedo = mix(vec3(.7,.8,.95), vec3(.1, .1,.05), fNoise );\n    surface.m_specR0 = vec3(0.001);\n    surface.m_gloss = 0.0;\n    surface.m_specScale = 1.0;\n}\n   \nfloat GIV( float dotNV, float k) {\n\treturn 1.0 / ((dotNV + 0.0001) * (1.0 - k)+k);\n}\n\nvoid AddSunLight( Surface surf, const vec3 vViewDir, const float fShadowFactor, inout vec3 vDiffuse, inout vec3 vSpecular ) {\n    vec3 vSunDir = GetSunDir();\n\tvec3 vH = normalize( vViewDir + vSunDir );\n\tfloat fNdotL = clamp(dot(GetSunDir(), surf.m_normal), 0.0, 1.0);\n\tfloat fNdotV = clamp(dot(vViewDir, surf.m_normal), 0.0, 1.0);\n\tfloat fNdotH = clamp(dot(surf.m_normal, vH), 0.0, 1.0);\n    float diffuseIntensity = fNdotL;\n    vDiffuse += g_sunColour * diffuseIntensity * fShadowFactor;\n\tfloat alpha = 1.0 - surf.m_gloss;\n\tfloat alphaSqr = alpha * alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = fNdotH * fNdotH * (alphaSqr - 1.0) + 1.0;\n\tfloat d = alphaSqr / (pi * denom * denom);\n\tfloat k = alpha / 2.0;\n\tfloat vis = GIV(fNdotL, k) * GIV(fNdotV, k);\n\tfloat fSpecularIntensity = d * vis * fNdotL;\n\tvSpecular += g_sunColour * fSpecularIntensity * fShadowFactor;\n}\n    \nvoid AddSkyLight( Surface surf, inout vec3 vDiffuse, inout vec3 vSpecular ) {\n    float skyIntensity = max( 0.0, surf.m_normal.y * 0.3 + 0.7 );\n    vDiffuse += g_skyColour * skyIntensity;       \n}\n\nvec3 GetFresnel( vec3 vView, vec3 vNormal, vec3 vR0, float fGloss ) {\n    float NdotV = max( 0.0, dot( vView, vNormal ) );\n    return vR0 + (vec3(1.0) - vR0) * pow( 1.0 - NdotV, 5.0 ) * pow( fGloss, 20.0 );\n}\n\nvec3 GetWaterExtinction( float dist ) {\n    float fOpticalDepth = dist * 6.0;\n    vec3 vExtinctCol = 1.0 - vec3(0.5, 0.4, 0.1);           \n    vec3 vExtinction = exp2( -fOpticalDepth * vExtinctCol );\n    return vExtinction;\n}\n\nvec3 GetSkyColour( vec3 vRayDir ) {    \n\tvec3 vSkyColour = mix( k_bgSkyColourDown, k_bgSkyColourUp, clamp( vRayDir.y, 0.0, 1.0 ) );\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    float fDirDot = clamp(fSunDotV * 0.5 + 0.5, 0.0, 1.0);\n    vSkyColour += g_sunColour * (1.0 - exp2(fDirDot * -0.5)) * 2.0;\n    \n    return vSkyColour;\n}\n\nvec3 GetEnvColour( vec3 vRayDir, float fGloss ) {\n\treturn mix( k_envFloorColor, k_bgSkyColourUp, clamp( vRayDir.y * (1.0 - fGloss * 0.5) * 0.5 + 0.5, 0.0, 1.0 ) );\n}\n\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir,const in float near, const in float far, out Intersection intersection ){\n    RaymarchScene( vRayOrigin, vRayDir, near, far, intersection );        \n    if ( intersection.m_objId == OBJ_ID_SKY ){\n        return GetSkyColour( vRayDir );\n    }\n    \n    Surface surface;\n    GetSurfaceInfo( intersection, surface );\n\n    vec3 vIgnore = vec3(0.0);\n    vec3 vResult = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( surface, -vRayDir, fSunShadow, vResult, vIgnore );\n    AddSkyLight( surface, vResult, vIgnore);\n    return vResult * surface.m_albedo;\n}\n\nvec3 GetRayColour( const in vec3 vRayOrigin, const in vec3 vRayDir, const in float near, const in float far) {\n\tIntersection intersection;\n    return GetRayColour( vRayOrigin, vRayDir, near, far, intersection );\n}\n\nvec3 GetScene( const in vec3 vRayOrigin,  const in vec3 vRayDir, const in float near, const in float far) {\n    float fSunDotV = dot(GetSunDir(), vRayDir);    \n    Intersection waterInt;\n    TraceWater( vRayOrigin, vRayDir, near, far, waterInt );\n    vec3 vReflectRayOrigin;\n    vec3 vResult;\n    vec3 vTransmitLight;\n    Surface specSurface;\n    vec3 vSpecularLight = vec3(0.0);\n    vec2 vFlowRate = GetBaseFlow( waterInt.m_pos.xz ) * 0.3;\n    vec4 vWaterNormalAndHeight = SampleFlowingNormal( waterInt.m_pos.xz, vFlowRate, g_fTime / 5.0 );\n    float fFogDistance = waterInt.m_dist;\n    vec3 vWaterNormal = vWaterNormalAndHeight.xyz;\n    vReflectRayOrigin = waterInt.m_pos;\n    vec3 vRefractRayOrigin = waterInt.m_pos;\n    vec3 vRefractRayDir = refract( vRayDir, vWaterNormal, 1.0 / 1.3333 );\n    Intersection refractInt;\n    vec3 vRefractLight = GetRayColour( vRefractRayOrigin, vRefractRayDir, near, far, refractInt ); // note : dont need sky\n\n    // add extra extinction for the light travelling to the point underwater\n    vec3 vExtinction = GetWaterExtinction( refractInt.m_dist + abs( refractInt.m_pos.y ) );\n    specSurface.m_pos = waterInt.m_pos;\n    specSurface.m_normal = normalize( vWaterNormal );\n    specSurface.m_albedo = vec3(1.0);\n    specSurface.m_specR0 = vec3( 0.01, 0.01, 0.01 );\n    vec2 vFilterWidth = max(abs(dFdx(waterInt.m_pos.xz)), abs(dFdy(waterInt.m_pos.xz)));\n    float fFilterWidth= max(vFilterWidth.x, vFilterWidth.y);\n    float fGlossFactor = exp2( -fFilterWidth * 0.3 );\n    specSurface.m_gloss = 0.99 * fGlossFactor;            \n    specSurface.m_specScale = 1.0;\n    vec3 vSurfaceDiffuse = vec3(0.0);\n    float fSunShadow = 1.0;\n    AddSunLight( specSurface, -vRayDir, fSunShadow, vSurfaceDiffuse, vSpecularLight);\n    AddSkyLight( specSurface, vSurfaceDiffuse, vSpecularLight);\n    vec3 vInscatter = vSurfaceDiffuse * (1.0 - exp( -refractInt.m_dist * 0.1 )) * (1.0 + fSunDotV);\n    vTransmitLight = vRefractLight.rgb;\n    vTransmitLight += vInscatter;\n    vTransmitLight *= vExtinction; \n    vec3 vReflectRayDir = reflect( vRayDir, vWaterNormal );\n    vec3 vReflectLight = GetRayColour( vReflectRayOrigin, vReflectRayDir, near, far );\n    vReflectLight = mix( GetEnvColour(vReflectRayDir, specSurface.m_gloss), vReflectLight, pow( specSurface.m_gloss, 40.0) );\n    vec3 vFresnel = GetFresnel( -vRayDir, vWaterNormal, specSurface.m_specR0, specSurface.m_gloss );\n    vSpecularLight += vReflectLight;\n    vResult = mix(vTransmitLight, vSpecularLight, vFresnel * specSurface.m_specScale );\n    vec3 vFogColour = GetSkyColour(vRayDir);\n    vec3 vFogExtCol = exp2( k_vFogExt * -fFogDistance );\n    vec3 vFogInCol = exp2( k_vFogIn * -fFogDistance );\n    vResult = vResult*(vFogExtCol) + vFogColour*(1.0-vFogInCol);\n    return vResult;\n}\n\n\nvoid initCamera(out vec3 ro, out vec3 rd,out float near, out float far) {\n    // 相机参数\n    vec3 lookAt = vec3(0.,0.,0.);\n    vec3 cameraPosition = vec3(1.5, 1.5, -1.5); \n    \n    // 相机控制\n    if( iMouse.z > 0.0 )  {\n        float fHeading = iMouse.x * 10.0 / iResolution.x;\n        float fDist = 5.0 - iMouse.y * 5.0 / iResolution.y;\n        cameraPosition.y += 1.0 + fDist * fDist * 0.05;\n        cameraPosition.x += sin( fHeading ) * fDist;\n        cameraPosition.z += cos( fHeading ) * fDist;\n    }\n    \n    // 相机三轴\n    vec3 forward = normalize(lookAt-cameraPosition);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n \tvec3 up = normalize(cross(forward,right));\n    float FOV = 0.5;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n    near = 0.01;\n\tfar = 200.0;\n    vec2 screenCoords = (2.0*gl_FragCoord.xy/iResolution.xy - 1.0)*aspect;\n    ro = cameraPosition;\n    rd = normalize(forward + FOV*screenCoords.x*right + FOV*screenCoords.y*up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro,rd; // Rar Origin , Ray Direction \n    float near, far;\n    g_fTime = iTime;\n    initCamera(ro, rd, near, far);\n\tvec3 vResult = GetScene(ro, rd, near, far);\n\tvResult = ApplyVignetting( fragCoord.xy / iResolution.xy, vResult );\t\n\tvec3 vFinal = Tonemap(vResult * 3.0);\n    vFinal = vFinal * 1.1 - 0.1;\n\tfragColor = vec4(vFinal, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}