{"ver":"0.1","info":{"id":"wdB3RK","date":"1549325594","viewed":143,"name":"Baobabs","username":"cbrpnk","description":"everyday","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotate(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c) * p;\n}\n\nfloat random(vec2 p) {\n    return fract(sin(dot(p, vec2(123.3345, 876.654))) * 984594.2343);\n}\n\nfloat perlin(vec2 p){\n    p *= 10.;\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float bl = random(i);\n    float br = random(i + vec2(1, 0));\n    float tl = random(i + vec2(0, 1));\n    float tr = random(i + vec2(1, 1));\n    \n    float x = mix(bl, br, smoothstep(0., 1., f.x));\n    float y = mix(tl, tr, smoothstep(0., 1., f.x));\n    return mix(x, y, smoothstep(0., 1., f.y));\n}\n\nfloat voronoi(vec2 p)\n{   \n    p *= 3.;\n    p = mod(p+vec2(1.), 2.)-vec2(1.);\n    p = abs(p);\n    \n    float d = 1000000.;\n    float alpha = .25;\n    \n    for(int i=0; i<2; ++i) {\n        for(int j=0; j<2; ++j) {\n            float x = float(i);\n            float y = float(j)+.5*x; \n            d = min(d, length(p-vec2(x, y)));\n        }\n    }\n    \n    return d;\n}\n\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat caps(vec3 p)\n{\n    return .1;\n}\n\nfloat torus(vec3 p)\n{\n    return sqrt(pow(length(p.xz) - .8, 2.) + pow(p.y, 2.)) - .5 + voronoi(p.xz)*.2;\n}\n\nfloat map(vec3 p)\n{\n    p.x += iTime*.3;\n    p.z -= iTime*.3;\n    \n    p.xz = mod(p.xz+vec2(2.), 5.3)-vec2(2.);\n    \n    vec2 proj;\n    proj.x = dot(vec3(1., 0., 0.), vec3(p.x, 0., p.z));\n    proj.y = dot(vec3(0., 1., 0.), vec3(0., p.y, p.z));\n    float s = sphere(p-vec3(0., .3, 0.), 1.) - voronoi(proj+perlin(-proj)*.9)*.1;\n    float t = torus(p-vec3(0., .3, 0.));\n    \n    float d = max(s, -t);\n    \n    // Floor\n    d = min(d, p.y + voronoi(vec2(perlin(p.xz*.2)*.01)) + perlin(p.xz)*.01);\n    \n    return d;\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float t = 0.;\n    for(int i=0; i<328; ++i) {\n    \tfloat d = map(ro+rd*t);\n        if(d < .01) break;\n        if(t > 40.) return -1.;\n        t += d*.4;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(\n    \tmap(p+vec3(0.001, 0., 0.)) - map(p-vec3(0.001, 0., 0.)),\n        map(p+vec3(0., 0.001, 0.)) - map(p-vec3(0., 0.001, 0.)),\n        map(p+vec3(0., 0., 0.001)) - map(p-vec3(0., 0., 0.001))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 eye = vec3(0., .02, 3.);\n    vec3 lookat = normalize(vec3(uv.x, uv.y, -1.));\n    lookat.yz = rotate(lookat.yz, .35);\n    lookat.xz = rotate(lookat.xz, iTime*.3);\n\t\n    \n    float d = march(eye, lookat);\n    \n    vec3 col;\n    if(d < 0.) {\n        col = mix(vec3(.5, .4, 1.), vec3(.5, .5, 1.), uv.y*5.);\n    } else {\n        vec3 p = eye+lookat*d;\n    \tvec3 normal = getNormal(p);\n    \tcol = .5*vec3(.1) + .5*vec3(.2) * dot(normal, vec3(0., 1., 0.));\n        col += vec3(.1);\n        col *= .1*vec3(.4, 1., .2);\n        col += .3* vec3(1., .5, .5) * clamp(dot(vec3(0., 0. ,1.), normal), 0., 1.);\n        col.r += p.y*.1*d/20.;\n        col *= p.y;\n        col = mix(col, vec3(.5, .4, 1.), d/67.);\n\t}\n\t\n    col = sqrt(col);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}