{"ver":"0.1","info":{"id":"Ndc3DN","date":"1629824630","viewed":981,"name":"sunbeam diffraction","username":"mdb","description":"2D visualisation of a laser with realistic like physics","likes":38,"published":3,"flags":32,"usePreview":0,"tags":["glass","pathtracing","laser","diffraction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;   \n        \n    \n    col += 0.01;\n    col = 1.0 - exp(-0.7*col);\n    //col *= 1.0 - exp(-dot(col, vec3(0.213, 0.715, 0.072)));\n    \n    // add triangle in the center\n    uv = uv*2.0 - 1.0;\n    uv.x = abs(uv.x);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    col *= mix(1.0, 0.7, clamp(length(uv)*4.0 - 0.4, -0.5, 1.0)*smoothstep(-0.01, 0.01, uv.y + 0.25)*smoothstep(-0.01, 0.01, dot(uv - vec2(0.0, 0.5), vec2(-sqrt(3.0)*0.5, -0.5))));\n    \n    // Output to screen\n    col = pow(col, vec3(1.0/2.2)); // sRGB encoding\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define laserBounces 6\n#define SPP 30\n//////////////////////////////////////////////////////////////////////\nuint seed = 0u;\nvoid hash(){\n    seed ^= 2747636419u;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n    seed ^= seed >> 16;\n    seed *= 2654435769u;\n}\nvoid initRandomGenerator(vec2 uv){\n    seed = uint(uv.y*iResolution.x + uv.x)+uint(iFrame)*uint(iResolution.x)*uint(iResolution.y);\n}\n\nfloat random(){\n    hash();\n    return float(seed)/4294967295.0;\n}\n/////////////////////////////////////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initRandomGenerator(fragCoord);\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    for(int j = 0; j < SPP; j++){\n    \n    //laser color\n    float w = mix(380.0, 780.0, random());\n    const float A = 1.2280;\n    const float B = 0.09;\n    float n2 =  A + B/(w*w*1e-6);\n    vec3 color = waveLenghtToRGB(w);\n    \n    float n1 = 1.0;\n    // float n2 = 1.333;\n    float R0 = pow((n1 - n2)/(n1 + n2), 2.0);\n    \n    \n    //laser setup\n    vec2 p0 = vec2(-2.0, 0.0);\n    float k = 0.04+ 0.2*sin(iTime*0.2);\n    //k = 0.04 - 0.17;\n    vec2 rd = vec2(cos(k), sin(k));\n    float inside = -1.0;\n    for(int b = 0; b < laserBounces; b++){\n        //intesect\n        vec2 normal;\n        float tmin = map(p0, rd, normal);\n        \n       \n        float t = tmin;\n        if(t < 0.0) t = 1e7;\n        \n        // color\n        vec2 nrd = vec2(-rd.y, rd.x);\n        float d2 = dot(rd, uv - p0);\n        if( d2 > 0.0 && d2 < t) col += 10.0*color * exp(-50.0*abs(dot(nrd, uv - p0)));\n        vec2 p2 = p0 + rd * t;\n        \n        vec2 uvp2 = p2 - uv;\n        float l = length(uvp2);\n        if(dot(normal, -uvp2) > -0.1) col += 2.0*color * 0.01*smoothstep(-0.05, 0.05, dot(normal, -uvp2/l)) / (l*l + 0.07);\n        if(dot(normal, -uvp2) < 0.1) col += 1.0*color * 0.01*smoothstep(0.05, -0.05, dot(normal, -uvp2/l)) / (l*l + 0.07);\n        \n        //next ray setup\n        float R = R0 + (1.0 - R0)*dot(normal, -rd);\n        if(random() < 1.0 - R){\n            rd = reflect(rd, normal);\n        }else{\n            rd = refract(rd, normal, pow(n2, inside));\n            inside = -inside;\n        }\n        \n        p0 = p2 + rd*0.00001;\n        \n        if(tmin < 0.0) break;\n    \n    }\n    \n    }\n    col /= float(SPP);\n    vec3 last = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    col = mix(col, last, 0.95);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct triangle {vec2 a, b, c;};\n\ntriangle[] scene = triangle[](triangle(0.5*vec2(0.0, 1.0),\n                                       0.5*vec2(sqrt(3.0)*0.5, -0.5),\n                                       0.5*vec2(-sqrt(3.0)*0.5, -0.5)));\n\n\nfloat Isegment(vec2 ro, vec2 rd, vec2 p0, vec2 p1, out vec2 n)\n{\n    vec2 v1 = ro - p0;\n    vec2 v2 = p1 - p0;\n    vec2 v3 = vec2(-rd.y, rd.x);\n\n\n    float d =  dot(v2, v3);\n    float t1 = -((v1.x*v2.y) - (v1.y*v2.x)) / d;\n    float t2 = dot(v1, v3) / d;\n\n    if (t1 >= 0.0 && (t2 >= 0.0 && t2 <= 1.0)){\n        n = normalize(vec2(-v2.y, v2.x));\n        n *= -sign(dot(n, rd));\n        return t1;\n    }\n\n    return -1.0;\n}\n\nfloat Itriangle(vec2 ro, vec2 rd, triangle tri, out vec2 n){\n    float t, tmin;\n    vec2 n2;\n    tmin = Isegment(ro, rd, tri.a, tri.b, n);\n    \n    t = Isegment(ro, rd, tri.a, tri.c, n2);\n    if(t >= 0.0 && (t < tmin || tmin < 0.0)) {tmin = t; n = n2;}\n    \n    t = Isegment(ro, rd, tri.b, tri.c, n2);\n    if(t >= 0.0 && (t < tmin || tmin < 0.0)) {tmin = t; n = n2;}\n    return tmin; \n\n}\n\nfloat map(vec2 ro, vec2 rd, out vec2 normal){\n    float tmin = -1.0;\n    for(int i = 0; i < 1; i++){ // scene.length()\n        triangle tri = scene[i];\n        vec2 n;\n        float t = Itriangle(ro, rd, tri, n);\n        if(t >= 0.0 && (t < tmin || tmin < 0.0)) {tmin = t; normal = n;}\n    }\n    return tmin;\n}\n\n//wavelength stuff\n\n// from https://www.shadertoy.com/view/7tjSDh\n// http://www.cie.co.at/technical-work/technical-resources\nvec3 standardObserver1931[81] =\n    vec3[81] (\n    vec3( 0.001368, 0.000039, 0.006450 ), // 380 nm\n    vec3( 0.002236, 0.000064, 0.010550 ), // 385 nm\n    vec3( 0.004243, 0.000120, 0.020050 ), // 390 nm\n    vec3( 0.007650, 0.000217, 0.036210 ), // 395 nm\n    vec3( 0.014310, 0.000396, 0.067850 ), // 400 nm\n    vec3( 0.023190, 0.000640, 0.110200 ), // 405 nm\n    vec3( 0.043510, 0.001210, 0.207400 ), // 410 nm\n    vec3( 0.077630, 0.002180, 0.371300 ), // 415 nm\n    vec3( 0.134380, 0.004000, 0.645600 ), // 420 nm\n    vec3( 0.214770, 0.007300, 1.039050 ), // 425 nm\n    vec3( 0.283900, 0.011600, 1.385600 ), // 430 nm\n    vec3( 0.328500, 0.016840, 1.622960 ), // 435 nm\n    vec3( 0.348280, 0.023000, 1.747060 ), // 440 nm\n    vec3( 0.348060, 0.029800, 1.782600 ), // 445 nm\n    vec3( 0.336200, 0.038000, 1.772110 ), // 450 nm\n    vec3( 0.318700, 0.048000, 1.744100 ), // 455 nm\n    vec3( 0.290800, 0.060000, 1.669200 ), // 460 nm\n    vec3( 0.251100, 0.073900, 1.528100 ), // 465 nm\n    vec3( 0.195360, 0.090980, 1.287640 ), // 470 nm\n    vec3( 0.142100, 0.112600, 1.041900 ), // 475 nm\n    vec3( 0.095640, 0.139020, 0.812950 ), // 480 nm\n    vec3( 0.057950, 0.169300, 0.616200 ), // 485 nm\n    vec3( 0.032010, 0.208020, 0.465180 ), // 490 nm\n    vec3( 0.014700, 0.258600, 0.353300 ), // 495 nm\n    vec3( 0.004900, 0.323000, 0.272000 ), // 500 nm\n    vec3( 0.002400, 0.407300, 0.212300 ), // 505 nm\n    vec3( 0.009300, 0.503000, 0.158200 ), // 510 nm\n    vec3( 0.029100, 0.608200, 0.111700 ), // 515 nm\n    vec3( 0.063270, 0.710000, 0.078250 ), // 520 nm\n    vec3( 0.109600, 0.793200, 0.057250 ), // 525 nm\n    vec3( 0.165500, 0.862000, 0.042160 ), // 530 nm\n    vec3( 0.225750, 0.914850, 0.029840 ), // 535 nm\n    vec3( 0.290400, 0.954000, 0.020300 ), // 540 nm\n    vec3( 0.359700, 0.980300, 0.013400 ), // 545 nm\n    vec3( 0.433450, 0.994950, 0.008750 ), // 550 nm\n    vec3( 0.512050, 1.000000, 0.005750 ), // 555 nm\n    vec3( 0.594500, 0.995000, 0.003900 ), // 560 nm\n    vec3( 0.678400, 0.978600, 0.002750 ), // 565 nm\n    vec3( 0.762100, 0.952000, 0.002100 ), // 570 nm\n    vec3( 0.842500, 0.915400, 0.001800 ), // 575 nm\n    vec3( 0.916300, 0.870000, 0.001650 ), // 580 nm\n    vec3( 0.978600, 0.816300, 0.001400 ), // 585 nm\n    vec3( 1.026300, 0.757000, 0.001100 ), // 590 nm\n    vec3( 1.056700, 0.694900, 0.001000 ), // 595 nm\n    vec3( 1.062200, 0.631000, 0.000800 ), // 600 nm\n    vec3( 1.045600, 0.566800, 0.000600 ), // 605 nm\n    vec3( 1.002600, 0.503000, 0.000340 ), // 610 nm\n    vec3( 0.938400, 0.441200, 0.000240 ), // 615 nm\n    vec3( 0.854450, 0.381000, 0.000190 ), // 620 nm\n    vec3( 0.751400, 0.321000, 0.000100 ), // 625 nm\n    vec3( 0.642400, 0.265000, 0.000050 ), // 630 nm\n    vec3( 0.541900, 0.217000, 0.000030 ), // 635 nm\n    vec3( 0.447900, 0.175000, 0.000020 ), // 640 nm\n    vec3( 0.360800, 0.138200, 0.000010 ), // 645 nm\n    vec3( 0.283500, 0.107000, 0.000000 ), // 650 nm\n    vec3( 0.218700, 0.081600, 0.000000 ), // 655 nm\n    vec3( 0.164900, 0.061000, 0.000000 ), // 660 nm\n    vec3( 0.121200, 0.044580, 0.000000 ), // 665 nm\n    vec3( 0.087400, 0.032000, 0.000000 ), // 670 nm\n    vec3( 0.063600, 0.023200, 0.000000 ), // 675 nm\n    vec3( 0.046770, 0.017000, 0.000000 ), // 680 nm\n    vec3( 0.032900, 0.011920, 0.000000 ), // 685 nm\n    vec3( 0.022700, 0.008210, 0.000000 ), // 690 nm\n    vec3( 0.015840, 0.005723, 0.000000 ), // 695 nm\n    vec3( 0.011359, 0.004102, 0.000000 ), // 700 nm\n    vec3( 0.008111, 0.002929, 0.000000 ), // 705 nm\n    vec3( 0.005790, 0.002091, 0.000000 ), // 710 nm\n    vec3( 0.004109, 0.001484, 0.000000 ), // 715 nm\n    vec3( 0.002899, 0.001047, 0.000000 ), // 720 nm\n    vec3( 0.002049, 0.000740, 0.000000 ), // 725 nm\n    vec3( 0.001440, 0.000520, 0.000000 ), // 730 nm\n    vec3( 0.001000, 0.000361, 0.000000 ), // 735 nm\n    vec3( 0.000690, 0.000249, 0.000000 ), // 740 nm\n    vec3( 0.000476, 0.000172, 0.000000 ), // 745 nm\n    vec3( 0.000332, 0.000120, 0.000000 ), // 750 nm\n    vec3( 0.000235, 0.000085, 0.000000 ), // 755 nm\n    vec3( 0.000166, 0.000060, 0.000000 ), // 760 nm\n    vec3( 0.000117, 0.000042, 0.000000 ), // 765 nm\n    vec3( 0.000083, 0.000030, 0.000000 ), // 770 nm\n    vec3( 0.000059, 0.000021, 0.000000 ), // 775 nm\n    vec3( 0.000042, 0.000015, 0.000000 )  // 780 nm\n);\nfloat standardObserver1931_w_min = 380.0f;\nfloat standardObserver1931_w_max = 780.0f;\nint standardObserver1931_length = 81;\n\nvec3 WavelengthToXYZLinear( float fWavelength )\n{\n    float fPos = ( fWavelength - standardObserver1931_w_min ) / (standardObserver1931_w_max - standardObserver1931_w_min);\n    float fIndex = fPos * float(standardObserver1931_length);\n    float fFloorIndex = floor(fIndex);\n    float fBlend = clamp( fIndex - fFloorIndex, 0.0, 1.0 );\n    int iIndex0 = int(fFloorIndex);\n    int iIndex1 = iIndex0 + 1;\n    iIndex1 = min( iIndex1, standardObserver1931_length - 1);\n\n    return mix( standardObserver1931[iIndex0], standardObserver1931[iIndex1], fBlend );\n}\n\nvec3 XYZtosRGB( vec3 XYZ )\n{\n    // XYZ to sRGB\n    // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n   mat3 m = mat3 (\n        3.2404542, -1.5371385, -0.4985314,\n\t\t-0.9692660,  1.8760108,  0.0415560,\n \t\t0.0556434, -0.2040259,  1.0572252 );\n    \n    return XYZ * m;\n}\n\nfloat BlackBody( float t, float w_nm )\n{\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}\n\nvec3 waveLenghtToRGB(float w){\n    float bb = 1e-13 * BlackBody(6000.0, w);\n    vec3 XYZ = bb*WavelengthToXYZLinear(w);\n    return XYZtosRGB(XYZ);\n\n}\n","name":"Common","description":"","type":"common"}]}