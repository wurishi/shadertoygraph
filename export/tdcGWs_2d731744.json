{"ver":"0.1","info":{"id":"tdcGWs","date":"1569777151","viewed":244,"name":"Tic Tac Toe Game","username":"BrandonE","description":"A playable Tic Tac Toe game made as a simple experiment in using the buffer's own pixels as a form of memory.\n\nClick the grid to place the markers. A reset button will appear at the end of the game.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["game","buffer","tictactoe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, uv, 0.0).rgb;\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* 2019 Brandon Edgren\nLicense CC BY 4.0\n\nA playable Tic Tac Toe game made as a simple experiment in using the buffer's\nown pixels as a form of memory.\n\nClick the grid to place the markers. A reset button will appear at the end of\nthe game.\n*/\n\nconst float TAU = 6.283185307179586476925286766559;\n\n// Memory locations.\nconst ivec2 MEM_0 = ivec2(0.0, 0.0); // Game and mouse state.\nconst ivec2 MEM_1 = ivec2(1.0, 0.0); // Cells 0-3\nconst ivec2 MEM_2 = ivec2(2.0, 0.0); // Cells 4-7\nconst ivec2 MEM_3 = ivec2(3.0, 0.0); // Cell 8\n\n// Game states.\nconst float PLAY = 0.0;\nconst float END = 0.1;\n\nconst float X_TURN = 0.0;\nconst float O_TURN = 0.1;\nconst float XO_TURN = 0.2; // Special case for tie-game.\n\n// Cell states.\nconst float CELL_EMPTY = 0.0;\nconst float CELL_X = 0.1;\nconst float CELL_O = 0.2;\n\n// Mouse constants.\nconst float MOUSE_RELEASED = 0.0;\nconst float MOUSE_PRESSED = 0.1;\n\n// Board position.\nconst float X1 = -0.3;\nconst float X2 = -0.1;\nconst float X3 = 0.1;\nconst float X4 = 0.3;\nconst float Y1 = 0.3;\nconst float Y2 = 0.1;\nconst float Y3 = -0.1;\nconst float Y4 = -0.3;\n\nconst float[3] colPos = float[3]((X1+X2) / 2.0, (X2+X3) / 2.0, (X3+X4) / 2.0);\nconst float[3] rowPos = float[3]((Y1+Y2) / 2.0, (Y2+Y3) / 2.0, (Y3+Y4) / 2.0);\n\nconst float GRID_HALF_WIDTH = 0.008;\n\n// Rest button.\nconst vec2 BUTTON_CENTER = vec2(0.0, 0.385);\nconst vec2 BUTTON_SIZE = vec2(0.2, 0.13) / 2.0;\n\nvec2 rotate(vec2 v, float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c) * v;\n}\n\nfloat band(float t, float start, float end, float blur) {\n    float step1 = smoothstep(start-blur, start+blur, t);\n    float step2 = smoothstep(end+blur, end-blur, t);\n    return step1 * step2;\n}\n\nfloat rect(vec2 uv, vec4 sides, float blur) {\n    float horiz = band(uv.x, sides.x, sides.z, blur);\n    float vert = band(uv.y, sides.y, sides.w, blur);\n    return horiz * vert;\n}\n\nfloat circle(vec2 uv, vec2 pos, float r, float blur) {\n    return smoothstep(r, r-blur, length(uv - pos));\n}\n\nfloat xShape(vec2 uv, vec2 pos, float size) {\n    uv -= pos;\n    uv /= size;\n    \n    float mask = 0.0;\n    \n    float hight = 1.0;\n    float width = 0.2;\n    float blur = 0.12;\n    \n    uv.x += uv.y;\n    mask += rect(uv, vec4(-width, -hight, width, hight), blur);\n    uv.x -= uv.y * 2.0;\n    mask += rect(uv, vec4(-width, -hight, width, hight), blur);\n    \n    return clamp(mask, 0.0, 1.0);\n}\n\nfloat oShape(vec2 uv, vec2 pos, float r) {\n    float mask = 0.0;\n    \n    float blur = 0.01;\n    \n    mask += circle(uv, pos, r, blur);\n    mask -= circle(uv, pos, r*0.75, blur);\n    \n    return clamp(mask, 0.0, 1.0);\n}\n\nfloat board(vec2 uv) {\n    float mask = 0.0;\n    \n    float blur = 0.005;\n    \n    float hw = GRID_HALF_WIDTH;\n    \n    mask += rect(uv, vec4(X2-hw, Y4, X2+hw, Y1), blur); // Left vertical\n    mask += rect(uv, vec4(X3-hw, Y4, X3+hw, Y1), blur); // Right vertical\n    mask += rect(uv, vec4(X1, Y2-hw, X4, Y2+hw), blur); // Top horizontal\n    mask += rect(uv, vec4(X1, Y3-hw, X4, Y3+hw), blur); // Bottom horizontal\n    \n    return clamp(mask, 0.0, 1.0);\n}\n\nfloat drawBoardState(vec2 uv, mat3 cells) {\n    float mask = 0.0;\n    \n    for (int col = 0; col < 3; col++) {\n        for (int row = 0; row < 3; row++) {\n            vec2 pos = vec2(colPos[col], rowPos[row]);\n        \tif (cells[col][row] == CELL_X) {\n    \t\t\tmask += xShape(uv, pos, 0.05);\n    \t\t} else if (cells[col][row] == CELL_O) {\n    \t\t\tmask += oShape(uv, pos, 0.06);\n    \t\t}\n        }\n    }\n    \n    return mask;\n}\n\nfloat drawBackground(vec2 uv, float turn) {\n    // Animate translationally.\n    uv += vec2(sin(iTime * 0.2), cos(iTime * 0.3));\n    \n    // Animate rotationally.\n    float c = cos(iTime*0.01);\n    float s = sin(iTime*0.01);\n    uv = mat2(c, s, -s, c) * uv;\n    \n    uv *= 11.0; // Zoom out.\n    uv = mod(uv, 2.0) - 1.0; // Create grid.\n        \n    float mask;\n    \n    if (turn == X_TURN) {\n    \tmask = xShape(uv, vec2(0.0), 0.3);\n    } else if (turn == O_TURN) {\n        mask = oShape(uv, vec2(0.0), 0.3);\n    } else {\n        mask = xShape(uv, vec2(0.0), sin(iTime)*0.2+0.4);\n        mask += oShape(uv, vec2(0.0), cos(iTime)*0.2+0.4);\n    }\n    \n    return mask;\n}\n\nivec2 mouseCell(vec2 mousePos) {\n    int x = -1;\n    int y = -1;\n    \n    if (mousePos.x > X1 && mousePos.x < X2) {\n        x = 0;\n    } else if (mousePos.x > X2 && mousePos.x < X3) {\n        x = 1;\n    } else if (mousePos.x > X3 && mousePos.x < X4) {\n        x = 2;\n    }\n    \n    if (mousePos.y < Y1 && mousePos.y > Y2) {\n        y = 0;\n    } else if (mousePos.y < Y2 && mousePos.y > Y3) {\n    \ty = 1;\n    } else if (mousePos.y < Y3 && mousePos.y > Y4) {\n    \ty = 2;\n    }\n    \n    return ivec2(x, y);\n}\n\nbool checkCells(float a, float b, float c) {\n    return (a != CELL_EMPTY && b != CELL_EMPTY && c != CELL_EMPTY\n            && a == b && a == c);\n}\n\nivec2[3] winnerCells(mat3 cells) {\n    // win[0|1|2] < 0 = game is not over\n    // win[0] == win[1] == win[2] = draw\n    // win[0] != win[1] != win[2] = game over and there is a winner\n    ivec2[3] win = ivec2[3](ivec2(-1), ivec2(-2), ivec2(-3));\n    \n    // Not going to try to come up with anything fancy, just check all 8 cases.\n    \n    // Case 1: top left to top right\n    if (checkCells(cells[0][0], cells[1][0], cells[2][0])) {\n        win = ivec2[3](ivec2(0, 0), ivec2(1, 0), ivec2(2, 0));\n\t\t\n    // Case 2: top left to bottom right\n    } else if (checkCells(cells[0][0], cells[1][1], cells[2][2])) {\n        win = ivec2[3](ivec2(0, 0), ivec2(1, 1), ivec2(2, 2));\n\t\t\n    // Case 3: top left to bottom left\n    } else if (checkCells(cells[0][0], cells[0][1], cells[0][2])) {\n        win = ivec2[3](ivec2(0, 0), ivec2(0, 1), ivec2(0, 2));\n \t\t\n    // Case 4: mid left to mid right\n    } else if (checkCells(cells[0][1], cells[1][1], cells[2][1])) {\n        win = ivec2[3](ivec2(0, 1), ivec2(1, 1), ivec2(2, 1));\n        \n    // Case 5: bottom left to top right\n    } else if (checkCells(cells[0][2], cells[1][1], cells[2][0])) {\n        win = ivec2[3](ivec2(0, 2), ivec2(1, 1), ivec2(2, 0));\n        \n    // Case 6: bottom left to bottom right\n    } else if (checkCells(cells[0][2], cells[1][2], cells[2][2])) {\n        win = ivec2[3](ivec2(0, 2), ivec2(1, 2), ivec2(2, 2));\n        \n    // Case 7: top mid to bottom mid\n    } else if (checkCells(cells[1][0], cells[1][1], cells[1][2])) {\n        win = ivec2[3](ivec2(1, 0), ivec2(1, 1), ivec2(1, 2));\n        \n    // Case 8: top right to bottom right\n    } else if (checkCells(cells[2][0], cells[2][1], cells[2][2])) {\n        win = ivec2[3](ivec2(2, 0), ivec2(2, 1), ivec2(2, 2));\n    \t\n    // Tie\n    } else {\n        bool foundEmpty = false;\n        for (int col = 0; col < 3; col++) {\n            for (int row = 0; row < 3; row++) {\n                if (cells[col][row] == CELL_EMPTY) {\n                    foundEmpty = true;\n                    break;\n                }\n            }\n            if (foundEmpty) break;\n        }\n        if (!foundEmpty) {\n       \t\twin = ivec2[3](ivec2(0), ivec2(0), ivec2(0));\n        }\n    }\n    \n    return win;\n}\n\nfloat winnerHightlight(vec2 uv, ivec2[3]cells) {\n    float mask = 0.0;\n    \n    // Just assume all cells are equal squares for simplicity.\n    float size = (X2 - X1) / 2.0 - GRID_HALF_WIDTH;\n    \n    for (int i = 0; i < 3; i++) {\n        vec2 pos = vec2(colPos[cells[i].x], rowPos[cells[i].y]);\n        mask += rect(uv, vec4(pos.x-size, pos.y-size, pos.x+size, pos.y+size), 0.01);\n    }\n\n    return mask;\n}\n\nfloat resetButton(vec2 uv) {\n\tfloat mask = 0.0;\n    \n    vec2 center = BUTTON_CENTER;\n    vec2 size = BUTTON_SIZE;\n    float width = 0.02;\n    \n    vec2 bottomLeft = center - size;\n    vec2 topRight = center + size;\n    \n    // Box.\n    mask += rect(uv, vec4(bottomLeft.xy, topRight.xy), 0.0025);\n    mask -= rect(uv, vec4((bottomLeft+width).xy, (topRight-width).xy), 0.005);\n    \n    // Arrow.\n    float len = size.x / 2.0;\n    float w = width / 3.0;\n    mask += rect(uv, vec4(center.x-len, center.y-w, center.x+len, center.y+w), 0.001);\n     \n    vec4 head = vec4(-0.0055, -w, len/2.0, w);\n    \n    vec2 newUv = rotate(uv - vec2(center.x-len, center.y), -TAU/8.0);\n    mask += rect(newUv, head, 0.001);\n    \n    newUv = rotate(uv - vec2(center.x-len, center.y), TAU/8.0);\n    mask += rect(newUv, head, 0.001);\n    \n    return clamp(mask, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    ivec2 xy = ivec2(fragCoord);\n    \n    vec2 mouseUv = iMouse.xy / iResolution.xy - 0.5;\n    mouseUv.x *= iResolution.x / iResolution.y;\n    \n    mat3 cells;\n    \n    // Read MEM_0.\n    vec4 mem0 = texelFetch(iChannel0, MEM_0, 0);\n    float gameState = mem0.r;\n    float lastMouseState = mem0.g;\n    float turn = mem0.b;\n    \n    float mouseState = iMouse.z > 0.0 ? MOUSE_PRESSED : MOUSE_RELEASED;\n    bool mouseJustPressed = mouseState == MOUSE_PRESSED && lastMouseState == MOUSE_RELEASED;\n    \n    // Read MEM_1.\n    vec4 mem1 = texelFetch(iChannel0, MEM_1, 0);\n    cells[0][0] = mem1.r;\n    cells[0][1] = mem1.g;\n    cells[0][2] = mem1.b;\n    cells[1][0] = mem1.a;\n    \n    // Read MEM_2.\n    vec4 mem2 = texelFetch(iChannel0, MEM_2, 0);\n    cells[1][1] = mem2.r;\n    cells[1][2] = mem2.g;\n    cells[2][0] = mem2.b;\n    cells[2][1] = mem2.a;\n    \n    // Read MEM_3.\n    vec4 mem3 = texelFetch(iChannel0, MEM_3, 0);\n    cells[2][2] = mem3.r;\n        \n    // Handle input.\n    if (mouseJustPressed) {\n        if (gameState == PLAY) {\n            ivec2 selectedCell = mouseCell(mouseUv);\n            int col = selectedCell.x;\n            int row = selectedCell.y;\n            if (col >= 0 && row >= 0 && cells[col][row] == CELL_EMPTY) {\n                cells[col][row] = turn == X_TURN ? CELL_X : CELL_O;\n                turn = turn == X_TURN ? O_TURN : X_TURN;\n            }\n        } else if (gameState == END) {\n            vec2 bottomLeft = BUTTON_CENTER - BUTTON_SIZE;\n            vec2 topRight = BUTTON_CENTER + BUTTON_SIZE;\n            if (mouseUv.x > bottomLeft.x && mouseUv.x < topRight.x\n               && mouseUv.y > bottomLeft.y && mouseUv.y < topRight.y) {\n                cells = mat3(CELL_EMPTY);\n                gameState = PLAY;\n                turn = turn == X_TURN ? O_TURN : X_TURN; // Loser starts next round.\n            }\n        }\n    }\n    \n    ivec2[3] winCells = winnerCells(cells);\n    if (winCells[0] != winCells[1] && winCells[0].x >= 0 && gameState != END) {\n        // Valid winner, undo the change to turn so that it is equal to the winner.\n        turn = turn == X_TURN ? O_TURN : X_TURN;\n        gameState = END;\n    } else if (winCells[0] == winCells[1]) {\n        turn = XO_TURN; // Tie-game\n        gameState = END;\n    }\n\n    // Draw.\n    vec4 color = vec4(0.0);\n    \n    vec4 shapeCol = vec4(0.3, 0.9, 0.3, 1.0);\n\n    vec4 background = shapeCol * 0.5 * drawBackground(uv, turn);\n    color = mix(color, background, background.a);\n\n    vec4 board = shapeCol * board(uv);\n    color = mix(color, board, board.a);\n\n    vec4 state = shapeCol * drawBoardState(uv, cells);\n    color = mix(color, state, state.a);\n    \n    // Hightlight winning cells.\n    if (gameState == END && turn != XO_TURN) {\n        vec4 highlightColor = shapeCol;\n        highlightColor.a = 0.5;\n        vec4 hightlight = highlightColor * winnerHightlight(uv, winCells);\n    \tcolor = mix(color, hightlight, hightlight.a);\n    }\n    \n    if (gameState == END) {\n        vec4 button = shapeCol * resetButton(uv);\n    \tcolor = mix(color, button, button.a);\n    }\n    \n    // Update memory.\n    if (xy == MEM_0) {\n        color = vec4(gameState, mouseState, turn, 0.0);\n    } else if (xy == MEM_1) {\n        color = vec4(cells[0][0], cells[0][1], cells[0][2], cells[1][0]);\n    } else if (xy == MEM_2) {\n        color = vec4(cells[1][1], cells[1][2], cells[2][0], cells[2][1]);\n    } else if (xy == MEM_3) {\n        color = vec4(cells[2][2], 0.0, 0.0, 0.0);\n    }\n       \n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}