{"ver":"0.1","info":{"id":"llXfRn","date":"1510937421","viewed":409,"name":"Fluid Fireworks","username":"Action","description":"Nice effect based on computational errors. Based on my previous shader https://www.shadertoy.com/view/ll2cWd.","likes":16,"published":1,"flags":48,"usePreview":0,"tags":["fluid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Robert Schuetze - trirop/2017\n// Modified by Ulysse Vimont - Ultraviolet/2017\n// Modified by Action/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Note: Buffers are used for the following purposes:\n//  - Buf A performs advection (U*, C)\n//  - Buf B computes the divergence of the velocity field ( D = ∇.U*)\n//  - Buf C solves the Poisson equation ( ∇²P = ∇.U* )\n//  - Buf D substracts the pressure gradient ( U = U* - ∇.P )\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = (C-r*0.5)/r.y;\n    vec2 m = (iMouse.xy-r*0.5)/r.y;\n    if(length(iMouse)<0.01){\n        m = vec2(-0.5,0.);\n    }\n    \n    float concentration = texture(iChannel0,C/r).z;\n    float temperature = texture(iChannel1,C/r).w;\n    float pressure = texture(iChannel3,C/r).x;\n //   temperature = unpackUnorm2x16(floatBitsToUint (temperature)).x;\n    bool solid = temperature < 0. ? true: false;\n    temperature = abs(temperature);\n    \n    vec3 col;\n    \n    vec3 bkg = vec3(0.23, 0.24, 0.44);\n    vec3 con = bkg - vec3(concentration*0.3);\n    //----------------------------\n    col = con+vec3(temperature,temperature,temperature);\n\n    if (solid)\n        col = vec3(1,1,1);\n    /*\n    //----------------------------\n    // visualize pressure\n    //col = 0.1*vec3(pressure,-pressure, 0.0);\n\n    float pl = texture(iChannel3,(C-vec2(-1, 0))/r).x;\n    float pr = texture(iChannel3,(C-vec2( 1, 0))/r).x;\n    float pt = texture(iChannel3,(C-vec2( 0,-1))/r).x;\n    float pb = texture(iChannel3,(C-vec2( 0, 1))/r).x;\n    vec2 grad = vec2(pr-pl,pb-pt);\n    //grad = vec2(dFdx(pressure), dFdy(pressure));\n    col = vec3(0.2+0.8*max(dot(normalize(vec3(0.0, 1.0, 1.0)), normalize(vec3(grad.x, .4, grad.y))), 0.0));\n    */\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Runge-Kutta 4 backward advection\n\n// Note: Components are attributed as follow:\n//   - x : velocity field (X)\n//   - y : velocity field (Y)\n//   - z : concentration field\n//   - w : temp\n// The advection of the velocity field makes it non divergent-free, hence the next steps.\n\n#define h 2.\n\nvec2 RK4(vec2 p){\n    vec2 r = iResolution.xy;\n    vec2 k1 = texture(iChannel0,p/r).xy;\n    vec2 k2 = texture(iChannel0,(p-0.5*h*k1)/r).xy;\n    vec2 k3 = texture(iChannel0,(p-0.5*h*k2)/r).xy;\n    vec2 k4 = texture(iChannel0,(p-h*k3)/r).xy;\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    vec2 r = iResolution.xy;\n    vec2 uv = ((C-r*0.5)/r.y);\n    \n    // advection\n    vec4 buf = texture(iChannel0,(C-RK4(C))/r);\n    vec2 v = buf.xy;\n    float d = buf.z;\n    float t = buf.w;\n    bool solid = t < 0. ? true: false;\n    if (solid)\n    {\n        fragColor = buf;\n        return;\n    }\n//    float t = unpackUnorm2x16(floatBitsToUint(buf.w)).x;\n    \n    // set boundary velocity\n    if(C.x<2.||C.x>r.x-2.){\n    \tv.x = .0;\n    \tv.y *= .5;\n    }\n    if(r.y-2.<C.y||C.y<2.){\n    \tv.y = .0;\n    \tv.x *= .5;\n    }\n    \n    // mouse interaction\n    vec2 m = (iMouse.xy-r*0.5)/r.y;\n    \n    // The smoke cools over time and starts to fall\n    t -= 0.002;\n    t = max(0.,abs(t));\n    \n    /*\n    if(length(uv-m)<0.02 && (iMouse.z > 0.5 || length(iMouse.xy) < 10.0)){\n        \n        float r = length(uv-m)/0.02;\n        r = sqrt(1.0 - r*r);\n        {\n        \td = texelFetch( iChannel2, ivec2(69,0), 0 ).x>0.5 ? d*(1.0-r) : d+r;\n            t = texelFetch( iChannel2, ivec2(70,0), 0 ).x>0.5 ? t*(1.0-r) : t+r;\n            solid = texelFetch( iChannel2, ivec2(65,0), 0 ).x>0.5 ? true : false;\n        }\n\n    }\n\t*/\n    \n    if ((iFrame/100) % 2 == 0){\n        int pos = ((iFrame/100)+1)%10;\n        vec2 mm = (vec2(float(pos)*50.0, 10.0)-r*0.5)/r.y;\n        if(length(uv-mm)<0.02) {\n            float r = length(uv-mm)/0.02;\n            r = sqrt(1.0 - r*r);\n            {\n                d = texelFetch( iChannel2, ivec2(69,0), 0 ).x>0.5 ? d*(1.0-r) : d+r;\n                t = texelFetch( iChannel2, ivec2(70,0), 0 ).x>0.5 ? t*(1.0-r) : t+r;\n                solid = texelFetch( iChannel2, ivec2(65,0), 0 ).x>0.5 ? true : false;\n            }\n        }\n    }\n    \n    // Open sides\n    if(C.x<2.||C.x>r.x-2.){\n    \td = 0.;\n        t = 0.;\n    }\n    // Open top\n    if(r.y-20.<C.y){\n        d = 0.;\n        t = 0.;\n    }\n    \n    t = solid ? -abs(t) : abs(t);\n    \n//    t = uintBitsToFloat (packUnorm2x16(vec2(t, 0)));\n    fragColor = vec4(v,d,t);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Created by Robert Schuetze - trirop/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Compute divergence\n\n// Note : Divergence is the right hand side of the Poisson equation:\n//   ∇²P = ∇.U*\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    vec2 r = iResolution.xy;\n    float vxl = texture(iChannel0,(C-vec2(-1, 0))/r).x;\n    float vxr = texture(iChannel0,(C-vec2( 1, 0))/r).x;\n    float vyt = texture(iChannel0,(C-vec2( 0,-1))/r).y;\n    float vyb = texture(iChannel0,(C-vec2( 0, 1))/r).y;\n    float div = (vxl-vxr+vyt-vyb)/2.;\n    fragColor = vec4(div,0,0,1);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Created by Robert Schuetze - trirop/2017\n// Modified a lot by Action/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Pressure solver\n\n// Note: Pressure is the left hand side of the Poisson equation:\n//   ∇²P = ∇.U*\n// The initial guess for P is the result of the previous pass.\n//\n// Note: Not divergence free.\n\nfloat rhs(int x,int y){\n    vec2 p = gl_FragCoord.xy+vec2(x,y);\n\treturn texture(iChannel0,p/iResolution.xy).x;\n}\n\n// 10 step function, from SuperCurve (Microsoft Store)\nfloat F(float x) {\n\tfloat y = 0.;\n    x *= 2.;\n\tint s = int(x);\n\tint b = 0x01 << s;\n\tint k = 0;\n\tfloat xx = 0.;\n\tk = b & 0x01;\n\txx = (x - 0.)*2.*float(k);\n\ty += 0.446031937273809*float(k);\n\ty += -1.27552880277327*xx;\n\ty += 1.37099695297507*xx*xx;\n\ty += -0.523534854299739*xx*xx*xx;\n\tk = (b >> 1) & 0x01;\n\txx = (x - 0.5)*2.*float(k);\n\ty += 0.0170784407363422*float(k);\n\ty += -0.0407170277242438*xx;\n\ty += 0.0239719618400746*xx*xx;\n\treturn y;\n}\n\nfloat Fd(float x) {\n\tfloat y = 0.;\n\tint s = int(x*1.0);\n\tint b = 0x01 << s;\n\tint k = 0;\n\tfloat xx = 0.;\n\tk = b & 0x01;\n\txx = (x)*float(k);\n\ty += 0.418135684624304*float(k);\n\ty += -2.29087448355795*xx;\n\ty += 3.32573842094314*xx*xx;\n\ty += 1.47135128995074*xx*xx*xx;\n\ty += -6.23550360127392*xx*xx*xx*xx;\n\ty += 3.31876074597447*xx*xx*xx*xx*xx;\n\treturn y;\n}\n\n// 1/|x| - like distribution (RHS = right hand side = div(v))\nfloat RHS( void ){\n    float p = 0.;\n    \n    for (int j=-9; j<10; ++j)\n    {\n        for (int i=-9; i<10; ++i)\n        {\n            float r = sqrt(float(i*i)+float(j*j));\n            p+= F(r)*rhs(i,j);\n        }\n    }\n    return p;\n}\n\n\n// 10 step\nfloat Fp(float x) {\n\tfloat y = 0.;\n\tint s = int(x*1.0);\n\tint b = 0x01 << s;\n\tint k = 0;\n\tfloat xx = 0.;\n\tk = b & 0x01;\n\txx = (x - 0.)*1.*float(k);\n\ty += 0.031045401134179*float(k);\n\ty += -0.0322653154799368*xx;\n\ty += -0.00425682993711293*xx*xx;\n\treturn y;\n}\n\nfloat p0c(int x,int y){\n    vec2 p = gl_FragCoord.xy+vec2(x,y);\n\treturn texture(iChannel1,p/iResolution.xy).x;\n}\n\n// Gaussian - like redistribution of the previously calculated pressure p0c\nfloat Pressure( void ){\n    float p = 0.;\n    for (int j=-20; j<20; ++j)\n    {\n        for (int i=-20; i<20; ++i)\n        {\n            int k = i+j;\n            if (k%2 == 0)\n            {\n\t            float r = sqrt(float(i*i)+float(j*j));\n    \t        p+= Fp(r)*p0c(i,j)*25.;\n            }\n        }\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{ \n\tvec2 r = iResolution.xy;\n    \n\n    \n    float p = RHS()+Pressure();\n    \n    // Open sides\n    if(C.x<2.||C.x>r.x-2.){\n    \tp = .0;\n    }\n    // Open top\n    if(r.y-20.<C.y){\n        p = 0.;\n    }\n    \n    fragColor = vec4(p,0,0,1);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Created by Robert Schuetze - trirop/2017\n// Modified by Action/2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Gradient subtraction\n\n// Note: This allows the velocity field to be divergence-free\n\n#define tamb 0.\n#define a 0.3\n#define b 0.5\n#define gravity 1.\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    vec2 r = iResolution.xy;   \n    float pl = texture(iChannel0,(C-vec2(-1, 0))/r).x;\n    float pr = texture(iChannel0,(C-vec2( 1, 0))/r).x;\n    float pt = texture(iChannel0,(C-vec2( 0,-1))/r).x;\n    float pb = texture(iChannel0,(C-vec2( 0, 1))/r).x;\n    vec2 grad = vec2(pr-pl,pb-pt)/2.;\n    float pres = texture(iChannel0,C/r).x;\n    //grad = vec2(dFdx(pres), dFdy(pres));\n    vec4 bufOld = texture(iChannel1,C/r);\n    \n    // Temperature causes buoyancy against gravity. Ambient temperature is tamp.\n    // Try to find good settings.\n    float s = bufOld.z;\n    float t = bufOld.w;\n    if (t < 0.)\n    {\n\t    fragColor = vec4(0,0, 0,t);;\n        return;\n    }\n //   float t = unpackUnorm2x16(floatBitsToUint(bufOld.w)).x;\n    float buoyancy = (a*s-b*(abs(t)-tamb))*gravity;\n    vec2 g = vec2(0.0, buoyancy)*0.1;\n    \n    vec2 f = bufOld.xy-grad - g;\n    // Open sides\n    if(C.x<2.||C.x>r.x-2.){\n    \ts = 0.;\n        t = 0.;\n    }\n    // Open top\n    if(r.y-20.<C.y){\n        s = 0.;\n        t = 0.;\n    }\n //   t = uintBitsToFloat (packUnorm2x16(vec2(t, 0)));\n    fragColor = vec4(f, s,t);\n}","name":"Buf D","description":"","type":"buffer"}]}