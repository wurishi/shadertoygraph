{"ver":"0.1","info":{"id":"4tGfDD","date":"1542555672","viewed":132,"name":"Architecture Project-East Door","username":"cake7914","description":"Entrance by East dining hall at night. ","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["architecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define repeat(v, r) (mod(v, r)-r/2.)\n\nstruct Shape{\n  float dist;\n  vec4 color;\n};\n    \nconst float EPSILON = 0.001;\nconst vec3 deltax = vec3(EPSILON, 0., 0.);\nconst vec3 deltay = vec3(0., EPSILON, 0.);\nconst vec3 deltaz = vec3(0., 0., EPSILON);\n\n//=======================\n// Utility Functions\n//=======================\n\n//========== Maximum/minumum elements of a vector ==========\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}    \n    \n//=========== Shape Functions ===============================\n\nfloat pole(vec2 v, float r){\n  return length(v)-r;\n}\n\nfloat sphere(vec3 v, float r){\n  return length(v)-r;\n}\n\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n//============== Intersection/Union/Difference Functions =======\n\n// http://mercury.sexy/hg_sdf/\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\n//============= Color functions =====================\n\nfloat mixColors(float r, float v, float z){\n  return clamp(0.5+0.5*(v-r)/z, 0., 1.);\n}\n\nfloat mixShapes(float v, float f, float r){\n  float z = mixColors(v, f, r);\n  return mix(f,v,z)-r*z*(1.-z);\n}\n\n//========= Other Functions ============================\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}    \n\nfloat random(vec2 v) {\n  return fract(sin(dot(v*0.1, vec2(324.654, 156.546)))*46556.2);\n}\n\nmat2 rot(float a){\n  float r = cos(a);\n  float f = sin(a);\n  return mat2(r, f, -f, r);\n}\n\n//======================= Architecture ====================\n\nShape Architecture(vec3 c){\n  Shape shape;\n  shape.dist = 1000.;\n  shape.color = vec4(0.15);\n    \n  // Domains\n    \n     vec3 v = c; // Vases\n     vec3 f = c; // Flowers\n     vec3 d = c; // Doors\n     vec3 w = c; // Windows\n     vec3 a = c; // Arches\n  \t vec3 aw = c; // Arch Windows\n     vec3 wa = c; // Slanted Wall\n     vec3 l = c; // Lamps\n     vec3 b = c; // Bricks\n\n  //============ Vase & Flowers ===========================\n  \n  v.x = abs(v.x); // Mirror\n  vec4 vColor = vec4(0., .36, .61, 1.); // Vase Color\n\n  float vaseBottom = fBox(v-vec3(35., -20., -10.), vec3(3., 1., 3.));             \n  float vaseMiddle = sdTorus(v-vec3(35.25, -18.5, -10.), vec2(1.8, .65));\n  float vaseMiddle2 = sdRoundedCylinder(v-vec3(35.25, -18., -10.), .45, .75, 3.);\n  float vaseMiddle3 = sphere(v-vec3(35.25, -11.5, -10.), 3.5);\n  float vaseMiddle4 = sdRoundedCylinder(v-vec3(35.25, -7., -10.), 1.15, 2., 1.25);\n  float vaseTop = sdRoundedCylinder(v-vec3(35.25, -5., -10.), 2., .5, .1);\n  \n  f.x = abs(f.x); // Mirror\n  vec4 fColor = vec4(2., 2., 0., 1.); // Flower Color\n  vec4 sColor = vec4(0., .5, 0., 1.); // Stems Color\n    \n  float flowers = sphere(v-vec3(35.25, -3., -10.), 2.75);\n  float stems = sphere(v-vec3(35.25, -4., -10.), 2.75);\n    \n  //=========== Doors =============\n    \n  d.x = abs(d.x); // Mirror\n  vec4 dColor = vec4(.87, .38, 0., 1.); // Door Color\n \n  float door = fBox(d-vec3(9., 0., 5.), vec3(9., 20., 1.));\n  float lowerPanels = fBox(d-vec3(10., -8., 4.95), vec3(6., 7., 1.));\n  float panelSeperator = fBox(d-vec3(10., 2., 4.), vec3(.65, 16., 1.));\n  float handle = fBox(d-vec3(2., -2., 3.), vec3(.5, 4., 1.));\n  float idThing = fBox(d-vec3(2., 5., 3.), vec3(.5, 1., 1.));\n  float upperPanels = fBox(d-vec3(10., 9., 4.95), vec3(6., 9., 1.5));\n  float panelSeperator2 = fBox(d-vec3(10., 9., 4.5), vec3(6., .65, 1.));\n  float beam = fBox(d-vec3(0., 21.125, 5.), vec3(18., 1., 1.));\n    \n    //------- Windows on Doors ------------\n    \n    w.x = abs(w.x);// Mirror \n    vec4 diColor = vec4(0.); // Dividers Color\n\n    float divider1 = fBox(d-vec3(14.5, 9., 6.), vec3(.25, 9., 1.));\n    float divider2 = fBox(d-vec3(12.5, 9., 6.), vec3(.25, 9., 1.));\n    float divider3 = fBox(d-vec3(6., 9., 6.), vec3(.25, 9., 1.));\n    float divider4 = fBox(d-vec3(8., 9., 6.), vec3(.25, 9., 1.));\n\t\n    float divider5 = fBox(w-vec3(10., 15., 6.), vec3(9., .25, 1.));\n    float divider6 = fBox(w-vec3(10., 12., 6.), vec3(9., .25, 1.));\n\tfloat divider7 = fBox(d-vec3(10., 3., 6.), vec3(9., .25, 1.));\n    float divider8 = fBox(d-vec3(10., 6., 6.), vec3(9., .25, 1.));  \n \n  // ========= Arches & Walls ===============\n  \n  \ta.x = abs(a.x); // Mirror\n  \n  \tfloat arch = sdTriPrism(a-vec3(0., 32., 5.), vec2(20., 1.));\n  \tfloat bend = fBox(a-vec3(14., 36., 6.), vec3(14., 17., .25));\n    float block = fBox(a-vec3(30.5, 13., -5.), vec3(3., 3., .25));\n                       \n  \t// --------- Windows in Arches ----------\n  \t\n    aw.x = abs(aw.x);\n  \n    float panel1 = fBox(aw-vec3(10., 27., 4.), vec3(1.75, 4., 2.5));\n    float panel2 = fBox(aw-vec3(5., 30., 4.), vec3(1.75, 7., 2.5));\n    float panel3 = fBox(aw-vec3(0., 32., 4.), vec3(1.75, 9., 2.5));\n\t\n    float divider9 = fBox(aw-vec3(0., 27., 6.), vec3(12., .25, .25));\n    float divider10 = fBox(aw-vec3(0., 30., 6.), vec3(12., .25, .25));\n    float divider11 = fBox(aw-vec3(0., 33., 6.), vec3(10., .25, .25));\n    float divider12 = fBox(aw-vec3(0., 36., 6.), vec3(8., .25, .25));\n\t\n    float divider13 = fBox(aw-vec3(10., 27., 6.), vec3(.25, 4., .25));\n    float divider14 = fBox(aw-vec3(5., 30., 6.), vec3(.25, 7., .25));\n    float divider15 = fBox(aw-vec3(0., 32., 6.), vec3(.25, 9., .25));\n    \n  \t// Slanted Wall & Pillars\n    \n  \twa.x = abs(wa.x); // Mirror\n  \twa.zx *= rot(radians(25.)); // Rotate\n  \tvec4 wColor = vec4(.96, .96, .87, 1.); // Wall Color\n  \n  \tfloat walls = fBox(wa-vec3(20., 0., 10.), vec3(5., 21., 1.));\n  \tfloat pillars = fBox(wa-vec3(25., 10., 8.), vec3(2., 40., 1.));\n \t \n  \t// Brick Walls\n    \n  \tfloat brickWall = fBox(d-vec3(75., 10., -2.), vec3(50., 40., 1.));\n  \n  \tvec3 wb = c; // Horizontal Lines \n  \twb.x = abs(wb.x); // Mirror\n  \twb.y = repeat(wb.y, 2.); // Repeat\n\n  \tfloat horizontalLines2 = fBox(wb-vec3(48., 0., -4.), vec3(20., .15, 1.));\n\n  \tvec3 wq = c; // Vertical Lines\n  \twq.x = abs(wq.x); // Mirror\n  \twq.x = repeat(wq.x, 4.); // Repeat\n  \n  \tfloat verticalLines2 = fBox(wq-vec3(0., 0., -4.), vec3(.15, 40., 1.)); \n  \n  // ========== Lamps ================  \n    \n    l.x = abs(l.x); // Mirror\n    l.zy*= rot(radians(90.)); // Rotate\n    vec4 lightColor = vec4(8., 8., 2., 1.);\n    \n    float lampSide = fBox(d-vec3(25.25, 25., -8.), vec3(.05, 2.5, .25));\n    float lampSide2 = fBox(d-vec3(26.5, 25., -6.), vec3(.05, 2.5, .25));\n    float lampSide3 = fBox(d-vec3(24., 25., -6.), vec3(.05, 2.5, .25));\n    float lampTop = sdTriPrism(l-vec3(25., 4., 28.), vec2(3., .15));\n    float lampBottom = sdTriPrism(l-vec3(25., 4., 22.), vec2(3., .15));\n\tfloat lamp = fBox(d-vec3(25., 25., -4.), vec3(1., 3., 1.));\n    \n  //=========== Bricks =============\n      \n  b.x = repeat(b.x, 2.); // Repeat\n  b.z = repeat(b.z, 4.); // Repeat\n  vec4 bColor = vec4(.73, 0., 0., 1.); // Brick Color\n  vec4 lColor = vec4(.8); // Lines Color\n\n  float bricks = fBox(c-vec3(0., -23., 0.), vec3(70., 1., 30.));\n  float verticalLines = fBox(b-vec3(0., -22., 0.), vec3(.15, .5, 30.));\n  float horLines = fBox(b-vec3(0., -22., 0.), vec3(100., .5, .15)); \n  \n  //===== Adding in the Shapes ======\n  \n  \t// Vase & Flowers\n  \tshape.dist = vaseBottom;\n  \tshape.dist = min(shape.dist, vaseMiddle);\n  \tshape.dist = fOpUnionRound(shape.dist, vaseMiddle2, 1.);\n  \tshape.dist = fOpUnionRound(shape.dist, vaseMiddle3, .5);\n  \tshape.dist = fOpUnionRound(shape.dist, vaseMiddle4, .5);\n  \tshape.dist = min(shape.dist, vaseTop);\n  \tshape.dist = min(shape.dist, flowers);\n  \tshape.dist = min(shape.dist, stems);\n  \n  \t// Doors\n  \tshape.dist = min(shape.dist, door);\n  \tshape.dist = max(shape.dist, -lowerPanels);\n  \tshape.dist = min(shape.dist, panelSeperator);\n  \tshape.dist = min(shape.dist, handle);\n  \tshape.dist = min(shape.dist, idThing);\n  \tshape.dist = max(shape.dist, -upperPanels);\n  \tshape.dist = min(shape.dist, panelSeperator2);\n  \tshape.dist = min(shape.dist, beam);\n  \tshape.dist = min(shape.dist, divider1);\n  \tshape.dist = min(shape.dist, divider2);\n  \tshape.dist = min(shape.dist, divider3);\n  \tshape.dist = min(shape.dist, divider4);\n  \tshape.dist = min(shape.dist, divider5);\n  \tshape.dist = min(shape.dist, divider6);\n  \tshape.dist = min(shape.dist, divider7);\n  \tshape.dist = min(shape.dist, divider8);\n  \n  \t// Bricks\n  \tshape.dist = min(shape.dist, bricks);\n  \tshape.dist = max(shape.dist, -verticalLines);\n  \tshape.dist = max(shape.dist, -horLines);\n                      \n  \t// Walls & Arches\n  \tshape.dist = min(shape.dist, walls);\n  \tshape.dist = min(shape.dist, pillars);\n  \tshape.dist = min(shape.dist, brickWall);\n  \tshape.dist = max(shape.dist, -verticalLines2);\n  \tshape.dist = max(shape.dist, -horizontalLines2);\n  \tshape.dist = min(shape.dist, arch);\n  \tshape.dist = min(shape.dist, bend);\n  \tshape.dist = max(shape.dist, -panel1);\n  \tshape.dist = max(shape.dist, -panel2);\n  \tshape.dist = max(shape.dist, -panel3);\n  \tshape.dist = min(shape.dist, divider9);\n  \tshape.dist = min(shape.dist, divider10);\n  \tshape.dist = min(shape.dist, divider11);\n  \tshape.dist = min(shape.dist, divider12);\n  \tshape.dist = min(shape.dist, divider13);\n  \tshape.dist = min(shape.dist, divider14);\n  \tshape.dist = min(shape.dist, divider15);\n  \tshape.dist = min(shape.dist, block);\n\n  \t// Lamps\n  \tshape.dist = min(shape.dist, lampSide);\n  \tshape.dist = min(shape.dist, lampBottom);\n  \tshape.dist = min(shape.dist, lampSide2);\n  \tshape.dist = min(shape.dist, lampSide3);\n  \tshape.dist = min(shape.dist, lampTop);\n  \tshape.dist = min(shape.dist, lamp);\n         \n    \n  //===== Mixing in the colors =======\n    \n    // Vases & Flowers\n    shape.color = mix(shape.color, vColor, mixColors(vaseBottom, shape.dist, .5));\n    shape.color = mix(shape.color, vColor, mixColors(vaseMiddle, shape.dist, .5));\n    shape.color = mix(shape.color, vColor, mixColors(vaseMiddle2, shape.dist, .5));\n    shape.color = mix(shape.color, vColor, mixColors(vaseMiddle3, shape.dist, .5));\n    shape.color = mix(shape.color, vColor, mixColors(vaseMiddle4, shape.dist, .5));\n    shape.color = mix(shape.color, vColor, mixColors(vaseTop, shape.dist, 0.5));\n    shape.color = mix(shape.color, fColor, mixColors(flowers, shape.dist, .25));\n    shape.color = mix(shape.color, sColor, mixColors(stems, shape.dist, .25));\n    \n    // Door\n    shape.color = mix(shape.color, dColor, mixColors(door, shape.dist, .25));\n    shape.color = mix(shape.color, dColor, mixColors(lowerPanels, shape.dist, .25));\n\tshape.color = mix(shape.color, dColor, mixColors(panelSeperator, shape.dist, .25));\n\tshape.color = mix(shape.color, dColor, mixColors(panelSeperator2, shape.dist, .25));\n\tshape.color = mix(shape.color, dColor, mixColors(beam, shape.dist, .25));\n    shape.color = mix(shape.color, diColor, mixColors(divider1, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider2, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider3, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider4, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider5, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider6, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider7, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider8, shape.dist, 1.));\n    \n    // Walls and Arches\n    shape.color = mix(shape.color, dColor, mixColors(arch, shape.dist, 0.025));\n    shape.color = mix(shape.color, wColor, mixColors(walls, shape.dist, .025));\n    shape.color = mix(shape.color, wColor, mixColors(pillars, shape.dist, .0025));\n    shape.color = mix(shape.color, bColor, mixColors(brickWall, shape.dist, .0025));\n    shape.color = mix(shape.color, lColor, mixColors(verticalLines2, shape.dist, .00025));\n    shape.color = mix(shape.color, lColor, mixColors(horizontalLines2, shape.dist, .00025));\n    shape.color = mix(shape.color, wColor, mixColors(bend, shape.dist, .025));\n    shape.color = mix(shape.color, wColor, mixColors(block, shape.dist, .025));    \n    shape.color = mix(shape.color, diColor, mixColors(divider9, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider10, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider11, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider12, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider13, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider14, shape.dist, 1.));\n    shape.color = mix(shape.color, diColor, mixColors(divider15, shape.dist, 1.));\n\n    // Lamps\n    shape.color = mix(shape.color, vColor, mixColors(lampSide, shape.dist, .0025));\n    shape.color = mix(shape.color, vColor, mixColors(lampBottom, shape.dist, .0025));\n    shape.color = mix(shape.color, vColor, mixColors(lampSide2, shape.dist, .0025));\n    shape.color = mix(shape.color, vColor, mixColors(lampTop, shape.dist, .0025));\n    shape.color = mix(shape.color, vColor, mixColors(lampSide3, shape.dist, .0025));\n    shape.color = mix(shape.color, lightColor, mixColors(lamp, shape.dist, .25));\n\n    // Bricks\n    shape.color = mix(shape.color, bColor, mixColors(bricks, shape.dist, .25));\n    shape.color = mix(shape.color, lColor, mixColors(verticalLines, shape.dist, .0025));\n    shape.color = mix(shape.color, lColor, mixColors(horLines, shape.dist, .00025));\n   \n  return shape;\n}\n\n// =========== Constructors ============\n\nShape map(vec3 c){\n  Shape architecture = Architecture(c);\n  return architecture;\n}\n\nfloat mapDist(vec3 c){\n  Shape architecture = Architecture(c);\n  return architecture.dist;\n}\n\nvec4 mapColor(vec3 c){\n  Shape architecture = Architecture(c);\n  return architecture.color;\n}\n\n// ======== Lighting & Mapping ===============\n\nfloat trace(vec3 origin, vec3 r) \n{\n  float t = 0.0;\n  float farPlane = 10000.;\n    for (int i = 0; i < 640; ++i) {\n        float dist = mapDist(origin + r * t);\n        if(dist < EPSILON || t > farPlane) {\n          break;\n      }\n        t += dist;\n    }\n    return t;\n}\n\n// Function calculates the normals for a given point\n// Finds the nearest surface vector in x, y, and z\nvec3 computeSurfaceNormal(vec3 p){\n    float d = mapDist(p);\n    return normalize(vec3(\n            mapDist(vec3(p.x + EPSILON, p.y, p.z)) - d ,\n            mapDist(vec3(p.x, p.y + EPSILON, p.z)) - d ,\n            mapDist(vec3(p.x, p.y, p.z + EPSILON)) - d\n            ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l) {\n\n    return vec3(dot(normalize(l-p), n));\n}\n\n\n// Compute an ambient occlusion factor\n// p: point on surface\n// n: normal of the surface at p\n// returns: a value clamped to [0, 1], where 0 means there were no other surfaces around the point,\n// and 1 means that the point is occluded by other surfaces.\nfloat ambientOcclusion(vec3 p, vec3 n)\n{\n  float stepSize = 0.00001;\n  float t = stepSize;\n  float oc = 0.0;\n  for(int i = 0; i < 1000; ++i)\n  {\n    float d = mapDist(p + n * t);\n    oc += t - d; // Actual distance to surface - distance field value\n    t += stepSize;\n  }\n\n  return clamp(oc, 0., 1.);\n}\n\nvec3 computeColor(vec3 origin, vec3 ray){\n  \n  float t = trace(origin, ray); \n  vec3 p = origin + ray * t; \n  float d = mapDist(p); \n  vec3 normal = computeSurfaceNormal(p);\n    \n  vec3 light = vec3(25., 25., -10.);\n  vec3 light2 = vec3(-25., 25., -10.);\n  vec3 mat = computeLambert(p, normal, light);\n  vec3 mat_2 = computeLambert(p, normal, light2);\n\n  float ao = ambientOcclusion(p, normal);\n  mat = mat * (2. - ao);\n  mat_2 = mat_2*(2. - ao);\n  return mat + mat_2;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 v = (fragCoord.xy-0.5 * iResolution.xy) / iResolution.y;\n\n  //vec3 cam = vec3(28., 25., -20);\n    vec3 cam = vec3(0., 0., -70.);\n    vec3 f = normalize(vec3(v, 1.));\n    \n    vec3 scene = cam;\n    fragColor = vec4(0.);\n    \n    Shape c = map(scene); // Calc SDF\n    \n    vec3 fc = computeColor(cam, f);\n    fc *= vec3(mapColor(fc));\n    \n    // Output to screen\n    fragColor = c.color*vec4(vec3(fc), 1.);\n  // Ray Marcher\n  for(float z = 0.1 ; z <= 1.; z += 0.03){\n    Shape c = map(scene); // Calc SDF\n    if(c.dist < 0.00001){\n      fragColor = c.color*(1.-z); // Hit  - invert pixels\n      break;\n    }\n    scene += f * c.dist;\n  }\n}","name":"Image","description":"","type":"image"}]}