{"ver":"0.1","info":{"id":"wsKyDW","date":"1602876759","viewed":290,"name":"Quadratic bezier curve","username":"sadiuk","description":"Really simple implementation of a quadratic bezier curve.","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["beziercurve"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//*****Adjustable parameters****/////\n#define CONTROL_POINTS_COUNT 2\n#define POINT_SIZE 5\n#define EPS 1e-8\n#define LINE_SIZE 0.02\n\nconst vec2 cp1 = vec2(0.2, 0.5);\nconst vec2 cp2 = vec2(0.8, 0.5);\n    \nconst vec4 control_point_color = vec4(0.2, 0.3, 0.8, 1.);\nconst vec4 mouse_point_color = vec4(0.9, 0.8, 0.2, 1.);\nconst vec4 bezier_color = vec4(0.3, 0.95, 0.2, 1.);\n//******************************/////\n\n\nbool point(vec2 coord, vec2 center, vec2 resolution)\n{\n \treturn int(length(coord * resolution - center * resolution)) < POINT_SIZE;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n    vec2 result;\n    float D = b * b - 4. * a * c;\n    result[0] = D >= 0. ? (-b + sqrt(D)) / (2. * a) : -1.;\n    result[1] = D >= 0. ? (-b - sqrt(D)) / (2. * a) : -1.;\n    return result;\n}\n\nbool is_on_bezier_curve(vec2 point, vec2 p0, vec2 p1, vec2 p2)\n{\n \tvec2 x_solutions, y_solutions;\n    x_solutions = solve_quadratic(p0.x - 2. * p1.x + p2.x,\n                                  2. * (p1.x - p0.x),\n                                  p0.x - point.x);\n    \n    y_solutions = solve_quadratic(p0.y - 2. * p1.y + p2.y,\n                                  2. * (p1.y - p0.y),\n                                  p0.y - point.y);\n    bool cond_1 = abs(x_solutions[0] - y_solutions[0]) < LINE_SIZE && \n        abs(y_solutions[0] + 1.) > EPS && abs(x_solutions[0] + 1.) > EPS;\n    bool cond_2 = abs(x_solutions[0] - y_solutions[1]) < LINE_SIZE && \n        abs(y_solutions[1] + 1.) > EPS && abs(x_solutions[0] + 1.) > EPS;\n    bool cond_3 = abs(x_solutions[1] - y_solutions[0]) < LINE_SIZE && \n        abs(y_solutions[0] + 1.) > EPS && abs(x_solutions[1] + 1.) > EPS;\n    bool cond_4 = abs(x_solutions[1] - y_solutions[1]) < LINE_SIZE && \n        abs(y_solutions[0] + 1.) > EPS && abs(x_solutions[0] + 1.) > EPS;\n    return cond_1 || cond_2 || cond_3 || cond_4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 res = iResolution.xy;\n    vec2 point_size = vec2(POINT_SIZE, POINT_SIZE) / iResolution.xy;\n    vec2 mouse_pos = iMouse.xy / iResolution.xy; \n//\tvec2 line_size = vec2(LINE_WIDTH, LINE_WIDTH) / iResolution.xy;\n\n    \n\t\n    \n    fragColor = point(uv, mouse_pos, iResolution.xy) ? mouse_point_color : vec4(1, 1, 1, 1);\n    \n    fragColor = is_on_bezier_curve(uv, cp1, mouse_pos, cp2) ? bezier_color : fragColor;\n    \n    fragColor = point(uv, cp1, res) || point(uv, cp2, res) ?\n        control_point_color : fragColor;  \n    \n}","name":"Image","description":"","type":"image"}]}