{"ver":"0.1","info":{"id":"ldSfWG","date":"1501878220","viewed":641,"name":"Deep Mandelbrot Zoom","username":"rory618","description":"High precision using a fixed point number with 8 16 bit digits, for 128 bits of precision total, hitting over 10^25 times zoom. Move mouse y up to keep lag down at the cost of quality.","likes":9,"published":1,"flags":96,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"lsfSWj","filepath":"https://soundcloud.com/lced/space-gazer","previewfilepath":"https://soundcloud.com/lced/space-gazer","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel1, ivec2(fragCoord*(iResolution.y-iMouse.y)/iResolution.y),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Loop\n    float time = mod(iTime, 216.);\n    \n    // Max value of each digit\n    int i = 32768;\n    \n    //zoom in and out\n    float dec = 4.0-2.8*cos(time  / 30.)-.9/(1.+.005*(time-173.)*(time-173.))+exp(((time-180.)*(time+100.)*.00027));\n    \n    float e;\n    //use more iterations when zoomed in more\n    \n    int iter =max(50,min(1500, (int(iMouse.x+iResolution.x*float(iMouse.x!=0.))*(100+int(4.2*exp(dec*1.5)))/int(iResolution.x)    )));\n    \n    vec2 r = iResolution.xy*(1.-iMouse.y/iResolution.y);\n    if(fragCoord.x> r.x ||  fragCoord.y > r.y ) return;\n    \n    //if(fragCoord.x < r.x && fragCoord.y < r.y){\n        \n\n\n        vec2 uv = 50.*(fragCoord.xy - r.xy*.5)/r.y/pow(float(i),fract(dec));\n\n\n        //initialize z\n        ivec2[] z = ivec2[](ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0));\n\n\n        //initialize center\n        ivec2[] c = ivec2[](\n            ivec2(0,0),\n            ivec2(12112,10024),\n            ivec2(11385,21592),\n            ivec2(31156,30705),\n            ivec2(10714,15737),\n            ivec2(8163,19413),\n            ivec2(12208,18948),\n            ivec2(10013,5925));\n        //shift c based on uv, converting uv into base 8196 digits\n        c[0+int(dec)] += ivec2(floor(float(i)*uv));\n        c[1+int(dec)] += ivec2(floor(float(i)*fract(float(i)*uv)));\n        c[2+int(dec)] += ivec2(floor(float(i)*fract(float(i)*fract(float(i)*uv))));\n\n\n        float a = 0.;\n        float aa = 0.;\n    \n        int j;\n        for(j = 0; j < iter; j++){\n\n\n            ivec2[] z2 = ivec2[](ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0),ivec2(0));\n            ivec2 sum = ivec2(0);\n\n            //for each digit position, there will be a few digits that will produce a product that lies in that range.\n            //since we are squaring z, we don't have to do some of the partial products twice\n\n            /*\n              1 2 3 4 5 6 7 8\n            1 a . . . . . . . \n            2 b c . . . . .\n            3 c d e . . .\n            4 d e f g .\n            5 e f g h\n            6 f g h\n            7 g h\n            8 h\n\n            */\n            \n            for(int h = 7; h >= 0; h--){\n                ivec2 carry = ivec2(0);\n                \n                //loop along the diagonal and sum the partial products\n                ivec2 ts = sum;\n                for(int t = 0; t < (h+1)/2; t++){\n                    ivec2 a = z[t];\n                    ivec2 b = z[h-t];\n                    sum += ivec2(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n\n                    //compute overflow and carry\n                    carry += sum/i;\n                    sum %= i;\n                }\n                \n                carry *= 2;\n                sum = 2*sum-ts;\n                \n                \n                sum += ((h+1)%2)*ivec2(z[h/2].x*z[h/2].x-z[h/2].y*z[h/2].y,z[h/2].x*z[h/2].y*2);\n                \n                \n                carry += sum/i;\n                sum %= i;\n                \n                \n                z2[h] = sum+c[h];\n                sum = carry;\n            }\n            \n            \n            \n            ivec2 carry = ivec2(0);\n            for(int h = 7; h >= 0; h--){\n                z2[h]+=carry;\n                carry = z2[h]/i;\n                z[h]=z2[h]%i;\n            }\n            //bailout\n            vec2 z_ = vec2(z[0])+vec2(z[1])/float(i)+vec2(z[2])/float(i)/float(i);\n            if(length( z_ )>24.){\n                e = length(z_);\n                break;\n            }\n            aa = a;\n            a += (sqrt(float(i+15)/120.)*(1.+sin(log(float(i+1)/220.)*abs(atan(z_.y,z_.x)))));\n        }\n\n  \n        //coloring\n        if(j+1<iter){\n            float mu = 1.+log(log(24.))/log(2.) - log(log(e))/log(2.);\n            float S = .4*sqrt(mix(aa,a,mu));\n            fragColor = .5*vec4(.5+.5*cos(S *vec3(2.3,2.2,2.1) ),1);\n            fragColor /= vec4(.5+.5*sin(mix(aa,a,mu)/(float(j)+mu)  *vec3(2.0,2.1,2.2) ),1);\n            fragColor = exp(-fragColor*2.);\n        }\n    //}\n}","name":"Buf A","description":"","type":"buffer"}]}