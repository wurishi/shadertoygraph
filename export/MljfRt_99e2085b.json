{"ver":"0.1","info":{"id":"MljfRt","date":"1516899578","viewed":182,"name":"Psychedelic Skyscrapers","username":"nr4","description":"Where do those wavey artifacts come from? Ideas welcome. Raymarching beginner here :)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","perlin","buggy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Buggy Psychedelic Skyscraper Shader\n    Copyright (C) 2017  Alexander Kraus <nr4@z10.info>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#define AA 1\n\n#define T .5\n\nconst vec2 c = vec2(1.,0.);\nconst float pi = 3.14159;\n\n#define rand(a0) fract(sin(dot(a0.xy ,vec2(12.9898,78.233)))*43758.5453)\n#define blend(a) ((6.*a-15.)*a+10.)*a*a*a\n#define interpolate(d,w00,w10,w01,w11) mix(mix(w00,w10,blend(d.x)),mix(w01,w11,blend(d.x)),blend(d.y))\n\nvec2 g2d(vec2 x, float seed)\n{\n    return vec2(-1.)+2.*vec2(rand(x+vec2(seed+2., seed+1.)), rand(x+vec2(seed+3.,seed+4.)));\n}\n\nfloat perlin2d(vec2 x, float seed)\n{\n    return interpolate(fract(x),\n                       dot(g2d(floor(x), seed), fract(x)), \n                       dot(g2d(floor(x).xy+c.xy, seed), fract(x).xy-c.xy), \n                       dot(g2d(floor(x).xy+c.yx, seed), fract(x).xy-c.yx), \n                       dot(g2d(floor(x).xy+c.xx, seed), fract(x).xy-c.xx));\n}\n\nfloat mfperlin2d(vec2 x, float seed, float fmin, float fmax, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = fmin; f<fmax; f = f*2.)\n    {\n        sum = a*perlin2d(f*x, seed) + sum;\n        a = a*phi;\n    }\n    \n    return sum;\n}\n\n#define Rx(x) mat3(c.xyyy, cos(x), sin(x), 0., -sin(x), cos(x))\n#define Ry(x) mat3(cos(x), 0., -sin(x), c.yxy, sin(x), 0., cos(x))\n#define Rz(x) mat3(cos(x), sin(x), 0., -sin(x), cos(x), c.yyyx)\n#define rotate(a,a0) Rz(-(a0).z)*Ry(-(a0).y)*Rx(-(a0).x)*(a)\n\n#define sphere(a,a0,a1) vec2(length(a)-(a0),a1)\n#define box(a,a0,a1) vec2(length(max(abs(a)-(a0),0.)),a1)\n#define plane(a,a0,a1) vec2((a).z-(a0),a1)\n\n#define repeat(a,a0) mod(a,a0)-.5*a0\n#define add(a,a0) mix(a0,a,step((a).x,(a0).x))\n#define sub(a,a0) mix(a0,a,step((a).x,-(a0).x))\n\nvec2 scene(vec3 x)\n{\n    vec2 sdf = c.xy;\n    x+=c.yxy*iTime;\n    \n    sdf = add(sdf, plane(x,-.0,1.));\n    vec3 y  = vec3(mod(x.xy,vec2(.5,.5)),x.z)-.25*c.xxy;\n    vec3 index = x-y;\n    \n    float color = 1.+ceil(3.*rand(index.xy));\n    \n    float height = 1.+.8*sin(length(index.xy))+abs(mfperlin2d(index.xy, 0., 1.e0, 1.e2, .3));\n    height -= mod(height, .1);\n    float width = .1+.06*rand(index.xy);\n\tsdf = add(sdf, box(y, vec3(width, width, height), color));\n    \n    float guard = -box(y, vec3(.25,.25,10.), -1.).x;\n    guard = abs(guard)+.5*0.1;\n    sdf.x = min(sdf.x, guard);\n    \n    return sdf;\n}\n\nconst float tmax = 100.;\nconst int nmax = 364;\nconst float epsilon = 5.e-4;\nvec2 intersect(in vec3 origin, in vec3 direction, out vec3 intersection)\n{\n    float t = 0.;\n    for(int i=0; i<nmax; ++i)\n    {\n        intersection = origin+t*direction;\n        vec2 sc = scene(intersection);\n        if(sc.x<epsilon*t)return vec2(t,sc.y);\n        t+=sc.x;\n        if(t>tmax)return vec2(tmax, -1.);\n    }\n    return vec2(tmax,-1.);\n}\n\nconst float dx = 5.e-4;\nvec3 normal(vec3 x)\n{\n    float sc = scene(x).x;\n    return normalize(vec3(scene(x+dx*c.xyy).x-sc, scene(x+dx*c.yxy).x-sc, scene(x+dx*c.yyx).x-sc));\n}\n\nvec3 colorize(vec3 origin, vec3 intersection, float material)\n{\n    if(material < 0.) return c.yyy;\n    vec3 color = c.yyy;\n    vec3 n = normal(intersection);\n    \n    vec3 light = 5.*c.yyx;\n    vec3 l = normalize(light-intersection);\n    \n    float height = .4;//1.+.4*sin(2.*pi*iTime/T-2.*pi*length(intersection.xy)/10.);\n    \n    if(material <= 1.)//mountain color\n    {\n        color += .2*c.xxx;\n        color += vec3(0.,0., 60./255.)*dot(l,n);\n        if(intersection.z>.1)\n        {\n        \tvec3 r = normalize(reflect(-l,n));\n        \tvec3 v = normalize(origin-intersection);\n            vec3 glow = mix(vec3(.6,.2,0.),.4*c.yxy, .5+.5*sin(3.*iTime));\n            color += 2.e0*glow*pow(dot(r,v),6.);\n        }\n    }\n    else if(material <= 2.)//skyscraper color I\n    {\n        vec3 lower = vec3(66.,242.,143.)/255., upper = vec3(49., 1., 1.)/255.;\n       \n        color += 1.5*mix(lower, upper, 1.-intersection.z/height+ceil(sin(pi*100.*intersection.z)))*dot(l,n);\n    }\n    else if(material <=3.)//skyscraper color II\n    {\n        vec3 lower = vec3(235.,177.,78.)/255., upper = vec3(195., 22., 104.)/255.;\n        color += 1.5*mix(lower, upper, 1.-intersection.z/height+ceil(sin(pi*100.*intersection.z)))*dot(l,n);\n    }\n    else if(material <=4.)//skyscraper color III\n    {\n        vec3 lower = vec3(201.,177.,95.)/255., upper = c.yyx;\n        color += 1.5*mix(lower, upper, 1.-.6*intersection.z/height+ceil(sin(pi*100.*intersection.z)))*dot(l,n);\n    }\n    \n    //fog colors\n    vec3 fog_color1 = .4*c.xxx;\n    vec3 fog_color2 = .4*c.xxx; \n    //color = mix(color, fog_color2, clamp(2.-15.*intersection.z,0.,1.));\n    //color = mix(color, fog_color1,  clamp(.2-1.*intersection.z,0.,1.));\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ray_origin = 2.5*c.yyx;\n    vec3 ray_target =vec3(0.,2.5,.5);\n    vec3 camera_right = c.xyy;\n    vec3 camera_up = normalize(cross(ray_target-ray_origin, -camera_right));\n    \n    vec3 color=c.yyy;\n    \n#if AA!=1\n    for(int i=0; i<AA; ++i)\n    \tfor(int j=0; j<AA; ++j)\n        {\n            vec2 o = vec2(float(i),float(j)) / float(AA) - 0.5;\n        \tvec2 p = (-iResolution.xy + 2.*(fragCoord+o))/iResolution.y;\n#else \n            vec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n    \n#endif\n    \t\tvec3 ray_direction = normalize(ray_target+p.x*camera_right+p.y*camera_up-ray_origin);        \n            \n            vec3 intersection;\n            vec2 mat_t = intersect(ray_origin, ray_direction, intersection);\n            \n            color +=colorize(ray_origin, intersection, mat_t.y);\n#if AA!=1\n        }\n    color/=float(AA*AA);\n#else\n#endif\n    \n    fragColor = vec4(color, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}