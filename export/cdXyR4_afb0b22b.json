{"ver":"0.1","info":{"id":"cdXyR4","date":"1686600192","viewed":90,"name":"2D square rotation","username":"sclexz","description":"you can click to change directions","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","square","rotating"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 rotateSquare(vec2 uv, float angle, bool ccw) //use the rotation matrix to rotate the cune\n{\n    vec2 rotPoint = vec2(0.0, 0.0);\n\n    if(ccw) //allows from counterclockwise and clockwise rotations\n    {\n        rotPoint = mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * uv;\n    }\n    else\n    {\n        rotPoint = mat2(cos(angle), sin(angle), -sin(angle), cos(angle)) * uv;\n    }\n    return rotPoint;\n}\n\nvec3 sdfSquare(vec2 uv, float size, bool ccw) //draws the square with the given formula\n{\n  float x = uv.x;\n  float y = uv.y;\n  vec2 rotatedPoints = rotateSquare(vec2(x,y), iTime, ccw); //calculate each points position\n  float squareVec = max(abs(rotatedPoints.x), abs(rotatedPoints.y)) - size; //calculate the square\n  \n  return squareVec > 0. ? vec3(1.) : vec3(1., 0., 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;//normalized pixel coordinates (from 0 to 1)\n    uv -= 0.5; //centers the cube\n    uv.x *= iResolution.x/iResolution.y; //fixes strechting issues\n    \n    bool ccw = true;\n    \n    if(iMouse.z > 0.0) { ccw = false; } else { ccw = true; } //changes rotation on click\n\n    //draw square\n    vec3 col = sdfSquare(uv, 0.2, ccw);\n    \n\n    //output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}