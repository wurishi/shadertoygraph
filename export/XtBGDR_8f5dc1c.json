{"ver":"0.1","info":{"id":"XtBGDR","date":"1428227956","viewed":365,"name":"A Simple Bezier Camera","username":"Hamneggs","description":"Gosh darn it I should have learned this way long ago.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["bezier","camera","curves","animation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/**\n * A simple bezier camera system.\n * Author: Gerard Geer\n * License Creative Commons CC0 1.0 Universal (CC-0)\n */\n// The plane height.\n#define PHEIGHT -.9\n// Radius of the sphere.\n#define SRAD .33\n\nconst vec3 SPOS = vec3(1.1, -.6, -0.2); \t// Sphere position.\nconst vec3 OBSIZE = vec3(.6125, 1, .2);\t\t// Outside door box size.\nconst vec3 IBSIZE = vec3(.5250, .95, .73);\t// Inner door box size.\nconst vec3 IBOFFSET = vec3(.0, -.1, .0);\t// The offset of the inner door box.\n\n// Main marching steps.\n#define V_STEPS 100\n// Shadow marching steps.\n#define S_STEPS 20\n// Maximum successful marching distance.\n#define EPSILON .00025\n// Max ray depth.\n#define MAX_DEPTH 30.0\n\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\t\t// An Up vector.\nconst vec3 LDIR = vec3(0.408248, 0.816497, -0.408248); // Light direction.\nconst vec3 LCOLOR = vec3(1.0, .875, 0.5);\t// Light color.\nconst vec3 ACOLOR = vec3(.02, .006, .017);\t// Ambient light color.\nconst vec3 TILEA = vec3(.4, .4, .366);\t\t// The fist tile color.\nconst vec3 TILEB = vec3(0.32, 0.32, 0.2928);\t\t// ... and the second as well.\nconst vec3 OTHER = vec3(.33); \t\t\t\t// The other object color.\n\n// Occlusion samples.\n#define OCC_SAMPLES 4.0\n// Occlusion attenuation samples.\n#define OCC_FACTOR 1.5\n// Light and reflection penumbra factors.\n#define LPFACTOR 30.0\n#define RPFACTOR 15.0\n// Oren-Nayar material reflectance coefficient.\n#define MAT_REFLECTANCE 3.0\n\n/*\n\tA linear Bezier function.\n*/\nvec3 lb(vec3 a, vec3 b, float t)\n{\n    return mix(a, b, t);\n}\n\n/*\n\tThe first derivative of a linear Bezier function.\n*/\nvec3 dlb(vec3 a, vec3 b, float t)\n{\n    return normalize( b - a );\n}\n\n/*\n\tA quadratic Bezier function.\n*/\nvec3 qb(vec3 a, vec3 b, vec3 c, float t)\n{\n\treturn mix( mix(a,b,t), mix(b,c,t), t);\n}\n\n/*\n\tThe first derivative of a quadratic Bezier function.\n*/\nvec3 dqb(vec3 a, vec3 b, vec3 c, float t)\n{\n    return normalize( (2.0-2.0*t)*(b-a) + 2.0*t*(c-b) );\n}\n\n/*\n\tA cubic Bezier function.\n*/\nvec3 cb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn mix(mix(mix(a,b,t), mix(b,c,t),t),mix(mix(b,c,t), mix(c,d,t),t), t);\n}\n\n/*\n\tAgain, a derivative. This time of cubic Bezier function.\n*/\nvec3 dcb(vec3 a, vec3 b, vec3 c, vec3 d, float t)\n{\n\treturn normalize( 3.0*pow(1.0-t, 2.0)*(b-a) + 6.0*(1.0-t)*t*(c-b)+3.0*pow(t, 2.0)*(d-c) );\n}\n\n/*\n\tCreates and orientates ray origin and direction vectors based on a\n\tcamera position and direction, with direction and position encoded as\n\tthe camera's basis coordinates.\n*/\nvoid camera(in vec2 uv, in vec3 cp, in vec3 cd, in float f, out vec3 ro, out vec3 rd)\n{\n\tro = cp;\n\trd = normalize((cp + cd*f + cross(cd, UP)*uv.x + UP*uv.y)-ro);\n}\n\n/*\n\tReturns a coefficient for a shutter fade.\n*/\nfloat shutterfade(in float s, in float e, in float t, in float duration)\n{\n    return min( smoothstep(s, s+duration, t), smoothstep(e, e-duration, t) );\n}\n/*\n\tSets up camera direction and position along a linear Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid l_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = lb(a, b, smoothstep(s, e, t));\n\tcd = dlb(a, b, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a quadratic Bezier curve, based\n\ton start and end times, and start and end positions.\n*/\nvoid q_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = qb(a, b, c, smoothstep(s, e, t));\n\tcd = -cross(dqb(a, b, c, smoothstep(s, e, t)), UP);\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tSets up camera direction and position along a cubic Bezier curve, based on\n\tstart and end times, and start and end positions.\n*/\nvoid c_cam_path(in float s, in float e, in float f, \n\t\t\t\tin vec3 a, in vec3 b, in vec3 c, in vec3 d, float t,\n\t\t\t\tout vec3 cp, out vec3 cd, out float shutter)\n{\n\tcp = cb(a, b, c, d, smoothstep(s, e, t));\n\tcd = dcb(a, b, c, d, smoothstep(s, e, t));\n\tshutter = shutterfade(s, e, t, f);\n}\n\n/*\n\tAnimates the camera, choosing a path based on the current time. Also\n\tperforms camera shuttering.\n*/\nvoid animate_cam(in vec2 uv, in float t, out vec3 ro, out vec3 rd, out float shutter)\n{\n\t// \"Yeah I'm not gonna const-out all of those positions.\"\n\tvec3 cp, cd;\n\tt = mod(t, 15.0);\n\tif(t > 1.0 && t < 5.0)\n\t{\n\t\tl_cam_path(\t1.0, 5.0, .5, \n\t\t\t\t\tvec3(0.0, .33, -5.0), vec3(0.0, .33, 2.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\telse if(t > 5.0 && t < 8.0)\n\t{\n\t\tq_cam_path(\t5.0, 8.0, .5, \n\t\t\t\t\tvec3(-7.0, .125, 0.1), vec3(0.0, 0.175, 7.0), vec3(7.0, 0.125, 0.1), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\telse if(t > 8.0 && t < 15.0)\n\t{\n\t\tc_cam_path(\t8.0, 15.0, .5, \n\t\t\t\t\tvec3(5.0, .33, 5.0), vec3(-1.0, .33, 5.0), vec3(1.0, .33, -5.0), vec3(-5.0, .33, -5.0), t,\n\t\t\t\t\tcp, cd, shutter);\n\t}\n\t\n\tcamera(uv, cp, cd, 1.0, ro, rd);\n}\n\n/*\n\tIQ's signed box distance function.\n*/\nfloat box(in vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) +\n\t\tlength(max(d,0.0));\n}\n \n/*\n\tA subtraction of two boxes to make a door frame.\n*/   \nfloat door(vec3 p)\n{\n\treturn max(-box(p, IBSIZE), box(p+IBOFFSET, OBSIZE));\n}\n\n/*\n\tIQ's plane distance function.\n*/\nfloat plane(vec3 p)\n{\n\treturn p.y-PHEIGHT;\n}\n\n/*\n\tIQ's sphere distance function.\n*/\nfloat sphere(vec3 p)\n{\n    return length((p-SPOS))-SRAD;\n}\n\n/*\n\tReturns a \"texel\" in a tile texture, whose contrast is reduced by distance.\n*/\nvec3 tile_tex(vec3 p, vec3 e)\n{\n    p *= 2.0;\n    \n    // The tile is absolute value of the difference in the modulo of the x and z terms of the position.\n    float tile = abs(floor(mod(p.x, 2.0)) - floor(mod(p.z, 2.0)));\n    // We add a term to soften the edge with distance for psuedo anisotropic filtering.\n    tile += (length(p-e)/MAX_DEPTH);\n    \n    // Finally we return the mix of the two tile colors, based on the tile difference.\n    return mix( TILEA, TILEB, smoothstep(0.0, 1.0, tile));\n}\n\n/*\n\tA pretty simple distance function combining my door, a plane, and\n\ta sphere.\n*/\nfloat dist(vec3 p)\n{\n\treturn min(min(door(p), plane(p)), sphere(p));\n}\n\n/*\n\tReturns a texture color given a point in space (and an eye coordinate\n\tfor filtering).\n*/\nvec3 tex(vec3 p, vec3 e)\n{\n\t// Only texture the plane.\n    if(plane(p) == dist(p))\n    \treturn tile_tex(p, e);\n\t// If it's not the plane return the other object color.\n    else return OTHER;\n        \n}\n\n/*\n\tReturns the surface normal of the distance field at the given\n\tpoint p.\n*/\nvec3 norm(vec3 p)\n{\n\treturn normalize(vec3(dist(vec3(p.x+EPSILON,p.y,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y+EPSILON,p.z)),\n\t\t\t\t\t\t  dist(vec3(p.x,p.y,p.z+EPSILON)))-dist(p));\n}\n\n/*\n\tThe ray-marching function. Marches a point p along a direction dir\n\tuntil it reaches a point within a minimum distance of the distance\n\tfield.\n*/\nvoid march(inout vec3 p, vec3 dir)\n{\n\tfloat r = dist(p+dir*EPSILON);\n\tfor(int i = 0; i < V_STEPS; i++)\n\t{\n\t\tif(r < EPSILON || r > MAX_DEPTH)\n\t\t\treturn;\n\t\tp += dir*r;\n        r = dist(p);\n\t}\n\treturn;\n}\n\n/*\n\tMarch-from-surface-to-light shadowing, with IQ's glancing penumbras.\n*/\nfloat shadow( in vec3 start, in vec3 ldir, in vec3 n, in float p)\n{    \n\tfloat t = EPSILON;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float d = dist( start + ldir * t );\n        if ( d < EPSILON*.1 )\n            return 0.0;\n\t\t\n\t\tres = min( res, p * d / t );\n        t += d;\n\t\t\n\t\tif ( t > MAX_DEPTH )\n\t\t\tbreak;\n    }\n    return res;\n}\n\n/*\n\tOren-Nayar reflectance modeling, since I may no longer use Phong after\n\tthe incident with the Mummy's Tiara.\n*/\nfloat orenNayar(in vec3 n, in vec3 v, in vec3 ldir)\n{\n    float r2 = pow(MAT_REFLECTANCE, 2.0);\n    float a = 1.0 - 0.5*(r2/(r2+0.57));\n    float b = 0.45*(r2/(r2+0.09));\n\n    float nl = dot(n, ldir);\n    float nv = dot(n, v);\n\n    float ga = dot(v-n*nv,n-n*nl);\n\n\treturn max(0.0,nl) * (a + b*max(0.0,ga) * sqrt((1.0-nv*nv)*(1.0-nl*nl)) / max(nl, nv));\n}\n\n/*\n\tCalculates the ambient occlusion factor at a given point in space.\n\tUses IQ's marched normal distance comparison technique.\n*/\nfloat occlusion(vec3 pos, vec3 norm)\n{\n\tfloat result = .0;\n    float s = -OCC_SAMPLES;\n    const float unit = 1.0/OCC_SAMPLES;\n\tfor(float i = unit; i < 1.0; i+=unit)\n\t{\n\t\tresult += pow(2.0,i*s)*(i-dist(pos+i*norm));\n\t}\n\treturn 1.0-result*OCC_FACTOR;\n}\n\n/*\n\tTakes in a surface and eye position, and calculates an ambient and diffuse\n\tlighting term.\n*/\nvoid light(in vec3 p, in vec3 d, in vec3 e, in vec3 n, out float amb, out float dif)\n{\n\tamb = occlusion(p, n);\n    float prim = shadow(p, LDIR, n, LPFACTOR);\n    float refl = shadow(p, reflect(d, n), n, RPFACTOR);\n    \n    // Go ahead and lambert it up if we're working with the plane.\n    if(dist(p) == plane(p))  dif = clamp(0.0, 1.0, dot(n, LDIR))*mix(prim, refl, .175);\n    // Otherwise stick with O.N.\n    else dif = orenNayar(n, d, normalize(LDIR))*mix(prim, refl, .1);\n}\n\n/*\n\tShades a point, giving it lighting and taking into account distance.\n*/\nvec3 shade(vec3 p, vec3 d, vec3 e)\n{\n    float l = length(p-e);\n    vec3 n = norm(p);\n\tif(l >= MAX_DEPTH) return vec3(0.0);\n\telse\n\t{\n\t\tfloat amb, dif;\n\t\tlight(p, d, e, n, amb, dif);\n\t\treturn tex(p, e)*(LCOLOR*dif + ACOLOR*amb) *(1.0- pow(l/MAX_DEPTH, 2.0));\n\t}\n}\n\n/*\n\tFinalizes each pixel, performing tonemapping and other post-processing \n\teffects.\n*/\nvec3 render(vec2 uv, vec3 c)\n{\n\tc = pow(clamp(c, 0., 1.), vec3(.4545));\n    return c;\n}\n\n/*\n\tShaderToy's proprietary Main Image 2000 v2.0 A Realistic Other World & \n\tKnuckles II HD Turbo Remix Last Round The Pre-Sequel Tactical Shading \n\tAction function.\n*/\t\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n    \n\tvec3 pos, dir, eye;\n\tfloat shutter = 0.0;\n    \n    animate_cam(uv, iTime, pos, dir, shutter);\n    \n\teye = vec3(pos);\n    \n\tmarch(pos, dir);\n   \tvec3 c = shade(pos, dir, eye);\n\tcolor = vec4(render(uv, c)*shutter, 1.0);\n}","name":"","description":"","type":"image"}]}