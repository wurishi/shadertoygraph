{"ver":"0.1","info":{"id":"fstXWn","date":"1632939557","viewed":361,"name":"GPU hacks #14 - C# OpenGL","username":"PrzemyslawZaworski","description":"Comment contains simple OpenGL framework for C# language (Windows) - with working example, visually equivalent to visible shader. ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["framework","tutorial","c","opengl","csharp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n// C# OpenGL simple framework for Windows\n// Compile with Visual Studio C# command-line: csc OpenGL.cs\n\nusing System;\nusing System.Runtime.InteropServices;\n\nclass Program\n{\n\t[DllImport(\"user32.dll\")]\n\tstatic extern bool PeekMessage(out MSG lpMsg, uint hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);\n\t\n\t[DllImport(\"user32.dll\")]\n\tstatic extern short GetAsyncKeyState(System.Int32 vKey);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern IntPtr GetDC( IntPtr hWnd);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern bool DestroyWindow(IntPtr hWnd);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern IntPtr CreateWindowEx(int dwExStyle, UInt16 regResult, string lpWindowName, UInt32 dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern System.UInt16 RegisterClassEx([In] ref WNDCLASSEX lpWndClass);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern IntPtr DefWindowProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern void PostQuitMessage(int nExitCode);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern bool TranslateMessage([In] ref MSG lpMsg);\n\n\t[DllImport(\"user32.dll\")]\n\tstatic extern IntPtr DispatchMessage([In] ref MSG lpmsg);\t\n\t\n\t[DllImport(\"gdi32.dll\")]\n\tstatic extern int ChoosePixelFormat(IntPtr hdc, [In] ref PIXELFORMATDESCRIPTOR ppfd);\n\n\t[DllImport(\"gdi32.dll\")]\n\tstatic extern bool SetPixelFormat(IntPtr hdc, int iPixelFormat, ref PIXELFORMATDESCRIPTOR ppfd);\t\n\t   \n\t[DllImport(\"opengl32.dll\")]\n\tstatic extern bool wglSwapLayerBuffers(IntPtr param0, uint param1);   \n\t   \n\t[DllImport(\"opengl32.dll\")]\n\tstatic extern void glRects(short x1, short y1, short x2, short y2 );\n\n\t[DllImport(\"opengl32.dll\")]\n\tpublic static extern IntPtr wglGetProcAddress(string name);\n\n\t[DllImport(\"opengl32.dll\")]\n\tstatic extern IntPtr wglCreateContext(IntPtr hDC);\n\n\t[DllImport(\"opengl32.dll\")]\n\tstatic extern bool wglMakeCurrent(IntPtr hDC, IntPtr hglrc);\n\n\t[DllImport(\"opengl32.dll\")]\n\tstatic extern bool wglDeleteContext(IntPtr hglrc);\n\t\n\t[DllImport(\"opengl32.dll\")]\n\tstatic extern IntPtr glGetString(uint name);\n\n\tdelegate void PFNWGLSWAPINTERVALEXTPROC (int interval);\n\tstatic PFNWGLSWAPINTERVALEXTPROC wglSwapIntervalEXT;\n\t\n\tdelegate uint PFNGLCREATEPROGRAMPROC ();\n\tstatic PFNGLCREATEPROGRAMPROC glCreateProgram;\n\t\n\tdelegate uint PFNGLCREATESHADERPROC(int type);\n\tstatic PFNGLCREATESHADERPROC glCreateShader;\n\t\n\tdelegate void PFNGLSHADERSOURCEPROC(uint shader, int count, string[] source, int[] length);\n\tstatic PFNGLSHADERSOURCEPROC glShaderSource;\t\n\n\tdelegate void PFNGLCOMPILESHADERPROC(uint shader);\n\tstatic PFNGLCOMPILESHADERPROC glCompileShader;\n\n\tdelegate void PFNGLATTACHSHADERPROC(uint program, uint shader);\n\tstatic PFNGLATTACHSHADERPROC glAttachShader;\n\n\tdelegate void PFNGLLINKPROGRAMPROC(uint program);\n\tstatic PFNGLLINKPROGRAMPROC glLinkProgram;\n\n\tdelegate void PFNGLUSEPROGRAMPROC(uint program);\n\tstatic PFNGLUSEPROGRAMPROC glUseProgram;\n\n\tdelegate int PFNGLGETUNIFORMLOCATIONPROC(uint program, string name);\n\tstatic PFNGLGETUNIFORMLOCATIONPROC glGetUniformLocation;\n\n\tdelegate void PFNGLUNIFORM1FPROC(int location, float v0);\n\tstatic PFNGLUNIFORM1FPROC glUniform1f;\n\t\n\tdelegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);\n\tstatic WndProc WindowProcPointer = WindowProc;\n\n\tstruct PIXELFORMATDESCRIPTOR { public ushort nSize; public ushort nVersion; public uint dwFlags; }\n\t \n\tstruct MSG { public IntPtr hwnd; public UInt32 message; public UIntPtr wParam; public UIntPtr lParam; public UInt32 time; public POINT pt;}  \n\n\tstruct POINT { public Int32 x; public Int32 Y; } \n\t\n\tstruct WNDCLASSEX\n\t{\n\t\tpublic int cbSize;\n\t\tpublic int style;\n\t\tpublic IntPtr lpfnWndProc; \n\t\tpublic int cbClsExtra;\n\t\tpublic int cbWndExtra;\n\t\tpublic IntPtr hInstance;\n\t\tpublic IntPtr hIcon;\n\t\tpublic IntPtr hCursor;\n\t\tpublic IntPtr hbrBackground;\n\t\tpublic string lpszMenuName;\n\t\tpublic string lpszClassName;\n\t\tpublic IntPtr hIconSm;\n\t}\n\n\tstatic void glInit ()\n\t{\n\t\tglCreateProgram = Marshal.GetDelegateForFunctionPointer<PFNGLCREATEPROGRAMPROC>(wglGetProcAddress(\"glCreateProgram\"));\t\n\t\twglSwapIntervalEXT = Marshal.GetDelegateForFunctionPointer<PFNWGLSWAPINTERVALEXTPROC>(wglGetProcAddress(\"wglSwapIntervalEXT\"));\n\t\tglCreateShader = Marshal.GetDelegateForFunctionPointer<PFNGLCREATESHADERPROC>(wglGetProcAddress(\"glCreateShader\"));\n\t\tglShaderSource = Marshal.GetDelegateForFunctionPointer<PFNGLSHADERSOURCEPROC>(wglGetProcAddress(\"glShaderSource\"));\n\t\tglCompileShader = Marshal.GetDelegateForFunctionPointer<PFNGLCOMPILESHADERPROC>(wglGetProcAddress(\"glCompileShader\"));\t\n\t\tglAttachShader = Marshal.GetDelegateForFunctionPointer<PFNGLATTACHSHADERPROC>(wglGetProcAddress(\"glAttachShader\"));\n\t\tglLinkProgram = Marshal.GetDelegateForFunctionPointer<PFNGLLINKPROGRAMPROC>(wglGetProcAddress(\"glLinkProgram\"));\t\n\t\tglUseProgram = Marshal.GetDelegateForFunctionPointer<PFNGLUSEPROGRAMPROC>(wglGetProcAddress(\"glUseProgram\"));\t\n\t\tglGetUniformLocation = Marshal.GetDelegateForFunctionPointer<PFNGLGETUNIFORMLOCATIONPROC>(wglGetProcAddress(\"glGetUniformLocation\"));\t\t\n\t\tglUniform1f = Marshal.GetDelegateForFunctionPointer<PFNGLUNIFORM1FPROC>(wglGetProcAddress(\"glUniform1f\"));\t\t\n\t}\n\n\tstatic string FragmentShader = \n\t\t@\"\n\t\t#version 450 \n\t\tlayout (location=0)\n\t\tout vec4 fragColor;\n\t\tuniform float iTime;\n\n\t\tfloat Arc( vec2 p, vec2 sca, vec2 scb, float ra, float rb )\n\t\t{\n\t\t\tp *= mat2(sca.x,sca.y,-sca.y,sca.x);\n\t\t\tp.x = abs(p.x);\n\t\t\tfloat k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n\t\t\treturn sqrt(max(0.0, dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n\t\t}\n\n\t\tfloat Line( vec2 p, vec2 a, vec2 b )\n\t\t{\n\t\t\tvec2 pa = p-a, ba = b-a;\n\t\t\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\t\treturn length( pa - ba*h );\n\t\t}\n\n\t\tvoid main ()\n\t\t{\n\t\t\tvec2 iResolution = vec2(800, 480);\n\t\t\tvec2 uv = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.y;\n\t\t\tfloat d = Arc(uv+vec2(0.3,0.0), vec2(sin(0.0),cos(0.0)), vec2(sin(2.2),cos(2.2)), 0.4, 0.08);\n\t\t\td = min(d, Line( uv, vec2(0.1,  0.1), vec2(0.6,  0.1) ) - 0.05);\n\t\t\td = min(d, Line( uv, vec2(0.1, -0.1), vec2(0.6, -0.1) ) - 0.05);\n\t\t\td = min(d, Line( uv, vec2(0.2,-0.25), vec2(0.3, 0.25) ) - 0.05);\n\t\t\td = min(d, Line( uv, vec2(0.4,-0.25), vec2(0.5, 0.25) ) - 0.05);\n\t\t\td = 1.0 - smoothstep(0.,3./iResolution.y, d);\n\t\t\tfragColor = vec4(d, d, d, 1.0);\n\t\t}\n\t\t\";\n\n\tstatic IntPtr WindowProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam)\n\t{\n\t\tif (msg==0x0010 || msg==0x0002 || (msg==0x0100 && wParam.ToInt32()==0x1B))\n\t\t{\n\t\t\tPostQuitMessage(0); return IntPtr.Zero;\n\t\t}\n\t\treturn DefWindowProc(hWnd, msg, wParam, lParam);\n\t}\t\n\t\n\tstatic void Main()\n\t{\n\t\tbool exit = false;\n\t\tMSG msg;\n\t\tWNDCLASSEX win = new WNDCLASSEX();\n\t\twin.cbSize = Marshal.SizeOf(typeof(WNDCLASSEX));\n\t\twin.style = (int) (1 | 2 ); \n\t\twin.hbrBackground = (IntPtr) 1 +1 ;\n\t\twin.cbClsExtra = 0;\n\t\twin.cbWndExtra = 0;\n\t\twin.hInstance = System.Diagnostics.Process.GetCurrentProcess().Handle;\n\t\twin.hIcon = IntPtr.Zero;\n\t\twin.hCursor = LoadCursor(IntPtr.Zero, (int)32515);\n\t\twin.lpszMenuName = null;\n\t\twin.lpszClassName = \"Demo\";\n\t\twin.lpfnWndProc = Marshal.GetFunctionPointerForDelegate(WindowProcPointer);\n\t\twin.hIconSm = IntPtr.Zero;\n\t\tIntPtr hwnd = CreateWindowEx(0, RegisterClassEx(ref win), \"Demo\", 0xcf0000 | 0x10000000, 0, 0, 800, 480, IntPtr.Zero, IntPtr.Zero, win.hInstance, IntPtr.Zero);\t\n\t\tIntPtr hdc = GetDC(hwnd);\n\t\tPIXELFORMATDESCRIPTOR pfd = new PIXELFORMATDESCRIPTOR();\n\t\tpfd.dwFlags = 0x00000001u;\n\t\tSetPixelFormat(hdc, ChoosePixelFormat(hdc, ref pfd), ref pfd);\n\t\twglMakeCurrent(hdc, wglCreateContext(hdc));\n\t\tConsole.WriteLine(\"Graphics Processing Unit: \" + Marshal.PtrToStringAnsi(glGetString(0x1F01)));\n\t\tglInit();\n\t\twglSwapIntervalEXT(0);\n\t\tuint p = glCreateProgram();\n\t\tuint s = glCreateShader(0x8B30);\n\t\tglShaderSource(s, 1, new[]{ FragmentShader }, new[]{ FragmentShader.Length });\n\t\tglCompileShader(s);\n\t\tglAttachShader(p, s);\n\t\tglLinkProgram(p);\n\t\tglUseProgram(p);\n\t\tint time = glGetUniformLocation(p, \"iTime\");\n\t\tfloat start = Environment.TickCount * 0.001f;\n\t\twhile (!exit)\n\t\t{\n\t\t\twhile(PeekMessage(out msg, 0, 0, 0, 0x0001))\n\t\t\t{\n\t\t\t\tif( msg.message == 0x0012 ) exit = true;\n\t\t\t\tTranslateMessage( ref msg );\n\t\t\t\tDispatchMessage( ref msg );\n\t\t\t}\n\t\t\tglUniform1f(time, (Environment.TickCount * 0.001f) - start);\n\t\t\tglRects(-1, -1, 1, 1); \n\t\t\twglSwapLayerBuffers(hdc, 0x00000001);\n\t\t}\n\t\tDestroyWindow(hwnd);\n\t}\n}\n*/\n\nfloat Arc( vec2 p, vec2 sca, vec2 scb, float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p,scb) : length(p);\n    return sqrt(max(0.0, dot(p,p) + ra*ra - 2.0*ra*k)) - rb;\n}\n\nfloat Line( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float d = Arc(uv+vec2(0.3,0.0), vec2(sin(0.0),cos(0.0)), vec2(sin(2.2),cos(2.2)), 0.4, 0.08);\n    d = min(d, Line( uv, vec2(0.1,  0.1), vec2(0.6,  0.1) ) - 0.05);\n    d = min(d, Line( uv, vec2(0.1, -0.1), vec2(0.6, -0.1) ) - 0.05);\n    d = min(d, Line( uv, vec2(0.2,-0.25), vec2(0.3, 0.25) ) - 0.05);\n    d = min(d, Line( uv, vec2(0.4,-0.25), vec2(0.5, 0.25) ) - 0.05);\n    d = 1.0 - smoothstep(0.,3./iResolution.y, d);\n    fragColor = vec4(d,d,d,1.0);\n}","name":"Image","description":"","type":"image"}]}