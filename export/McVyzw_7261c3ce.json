{"ver":"0.1","info":{"id":"McVyzw","date":"1731651750","viewed":199,"name":"Palette Generation Visualization","username":"mrange","description":"CC0: Palette Generation Visualization Shader\nThis shader visualizes how the classic palette generation function works\nby showing both the resulting colors and the underlying cosine waves that create them.\nhttps://github.com/mrange/shader-advent-2024\n","likes":13,"published":3,"flags":0,"usePreview":0,"tags":["2d","palette"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CC0: Palette Generation Visualization Shader\n// This shader visualizes how the classic palette generation function works\n// by showing both the resulting colors and the underlying cosine waves that create them.\n\n// Shader Advent 2024: https://github.com/mrange/shader-advent-2024\n\n// Color phase offsets for RGB channels (in radians)\nconst vec3 phase = vec3(0., 1., 2.);\n\n// Common constants\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// Classic palette generation function\n// Generates smooth, periodic color transitions using cosine waves\n// Parameters:\n//   a: Phase offset for the cosine waves\n// Returns: RGB color with components in [0,1] range\nvec3 palette(float a) {\n  return 0.5 + 0.5*cos(phase + a);\n}\n\n// Signed distance function approximation for a cosine curve\n// Parameters:\n//   x: Input value\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(float x) {\n  return sqrt(x*x + 1.0)*0.8 - 1.8;\n}\n\n// License: Unknown, author: Unknown, found: shadertoy somewhere, don't remember where\nfloat dfcos(vec2 p, float freq) {\n  float x = p.x * freq;\n  float y = p.y;\n  \n  float x1 = abs(mod(x + PI, TAU) - PI);\n  float x2 = abs(mod(x, TAU) - PI);\n  \n  float a = 0.18*freq;\n  \n  x1 /= max(y*a + 1.0 - a, 1.0);\n  x2 /= max(-y*a + 1.0 - a, 1.0);\n  \n  return (mix(-dfcos(x2) - 1.0, \n              dfcos(x1) + 1.0, \n              clamp(y*0.5 + 0.5, 0.0, 1.0)))/max(freq*0.8, 1.0) \n         + max(abs(y) - 1.0, 0.0)*sign(y);\n}\n\n// Calculate distance field for a specific color channel\n// Parameters:\n//   p: 2D point\n//   phase: Phase offset for this channel\n// Returns: Distance to the cosine curve with thickness\nfloat df(vec2 p, float phase) {\n  float d = dfcos(p + vec2(phase, 0.0), 1.);\n  d = abs(d);\n  d -= 0.0125; // Curve thickness\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalize coordinates to [-1, 1] range\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y; // Aspect ratio correction\n  \n  // Anti-aliasing factor\n  float aa = sqrt(2.)/RESOLUTION.y;\n  \n  // Scaling factor for better visualization\n  const float zz = sqrt(0.5);\n  \n  // Transform coordinates for animation\n  vec2 pp = p/zz;\n  pp.x += 0.5*TIME; // Horizontal scrolling\n  \n  // Get base palette color for current x-coordinate\n  vec3 pcol = palette(pp.x);   \n  vec3 col = vec3(0.0);\n  \n  // Render either the palette preview or the wave visualization\n  if (abs(p.y) > 0.75) {\n    // Upper/lower bands: show direct palette colors\n    col = pcol;\n  } else {\n    // Middle section: visualize individual RGB cosine waves\n    float dr = df(pp, phase.x)*zz; // Red channel\n    float dg = df(pp, phase.y)*zz; // Green channel\n    float db = df(pp, phase.z)*zz; // Blue channel\n    \n    // Blend the waves with their respective colors\n    col += vec3(pcol.x + 0.1, 0., 0.)*smoothstep(aa, -aa, dr);\n    col += vec3(0., pcol.y + 0.1, 0.)*smoothstep(aa, -aa, dg);\n    col += vec3(0., 0., pcol.z + 0.1)*smoothstep(aa, -aa, db);\n  }\n  \n  // Approximate RGB => sRGB conversion\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}