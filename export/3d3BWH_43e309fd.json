{"ver":"0.1","info":{"id":"3d3BWH","date":"1604933378","viewed":76,"name":"Mandelbrot experiment","username":"Atchafalaya","description":"playing with fractals for the first time on Shadertoy","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATION 500\n#define PI 3.1415\n#define PERIOD 15.\n\nconst vec2 CENTERS[5] = vec2[5](vec2(1.155713, -0.27765),\n                                vec2(-0.42884, 0.231345),\n                                vec2(0.761574, 0.0847596),\n                                vec2(1.62917, 0.0203968),\n                                vec2(0.812223315621338, 0.185453926110785));\nmat2 rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nstruct Complex{\n    float r;\n    float i;\n};\n\nfloat norm(Complex c){\n    return length(vec2(c.r, c.i));\n}\n\nComplex square(Complex c){\n    return Complex(c.r * c.r - c.i * c.i, 2. * c.r * c.i);\n}\n\nComplex sum_complex(Complex a, Complex b){\n    return Complex(a.r + b.r, a.i + b.i);\n}\n\nComplex mul_complex(Complex c, float m){\n\treturn Complex(c.r * m, c.i * m);\n}\n\nfloat getZoom(float time){\n    return pow(abs(cos(PI / PERIOD * iTime)), 2.3) + 0.01; //periodic zoom\n}\n\nvec3 mandelbrot(vec2 uv){\n    int i = 0;\n    float zoom = getZoom(iTime);\n    float maxValue = 4. * (1. / pow(zoom, 2.)) ;\n    float sum = 0.;\n    Complex z = Complex(0., 0.);\n    Complex c = Complex(uv.x, uv.y);\n    while (sum < maxValue && i < MAX_ITERATION){\n        z = sum_complex(square(mul_complex(z, zoom)), c);\n        sum = norm(z);\n        i++;\n    }\n    if (sum < maxValue){\n        return vec3(0.);\n    } else {\n        float r = pow(float(i) / float(MAX_ITERATION), 0.16);\n        float r0 = clamp(0., 1., 4. * r);\n        float r1 = clamp(0., 1., 4. * (r - 0.25));\n        float r2 = clamp(0., 1., 4. * (r - 0.5));\n        float r3 = clamp(0., 1., 4. * (r - 0.75));\n        vec3 col0 = vec3(27., 64., 121.) / 255.;\n        vec3 col1 = vec3(85., 147., 206.) / 255.;\n        vec3 col2 = vec3(134., 110., 216.) / 255.;\n        vec3 col3 = vec3(246., 150., 45.) / 255.;\n        vec3 col4 = vec3(255., 30., 24.) / 255.;\n        vec3 col = mix(col0, col1, r0);\n        col = mix(col, col2, r1);\n        col = mix(col, col3, r2);\n        col = mix(col, col4, r3);\n        return col;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2. * uv - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    uv = rot(0.1 * iTime) * uv;\n    \n    int i = int(floor((iTime + PERIOD / 2.) / PERIOD)) % 5;\n    vec2 center = CENTERS[i];\n    vec2 previousCenter = vec2(0.);\n    float timeOffset = 0.;\n    if (iTime > PERIOD / 2.)\n    {\n        if (i == 0){\n            previousCenter = CENTERS[CENTERS.length() - 1];\n        } else {\n            previousCenter = CENTERS[i - 1];\n        }\n        timeOffset = PERIOD / 2.;\n\t}\n\n    float nTime = iTime / PERIOD; \n    float t = nTime > 0.5 ? fract(nTime + 0.5) : fract(2. * nTime);\n    float u = nTime > 0.5 ? smoothstep(0.3, 0.7, t) : smoothstep(0., 0.4, t);\n    vec2 transitionCenter = mix(previousCenter, center, u);\n    \n    uv -= transitionCenter / pow(getZoom(iTime), 2. ); \n    \n    vec3 col = mandelbrot(uv);\n\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}