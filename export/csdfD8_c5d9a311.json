{"ver":"0.1","info":{"id":"csdfD8","date":"1697832925","viewed":100,"name":"pathtracetest102","username":"quadrortx8000","description":"asadasdasd","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["adsf","banadn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define BLUR\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float tau = 6.28318530718;\n    \n    float dirs = 16.0;\n    float qual = 10.0;\n    float size = 0.25;\n    \n    vec2 rad = size / iResolution.xy;\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 col = texture(iChannel0, uv);\n#ifdef BLUR\n    for (float d = 0.0; d < tau; d += tau / dirs) {\n        for (float i = 1.0 / qual; i <= 1.0; i += 1.0 / qual) {\n            col += texture(iChannel0, uv + vec2(cos(d), sin(d)) * rad * i);\n        }\n    }\n    col /= qual * dirs - dirs + 1.0;\n#endif\n    col.rgb = aces(col.rgb);\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float minHitTime = 0.01;\n\nconst float normNudge = 0.01;\n\nconst float far = 10000.0;\n\nconst float fov = 90.0;\n\nconst int bounces = 4;\n\nconst int samples = 10;\n \nstruct hit {\n    float dist;\n    vec3 norm;\n    vec3 emissive;\n    vec3 albedo;\n    float rough;\n    float spec;\n    vec3 speccol;\n};\n\nuint hash(inout uint seed) {\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nvec2 hash2(inout uint seed) {\n    float hasha = float(hash(seed));\n    float hashb = float(hash(seed));\n    return vec2(hasha, hashb);\n}\n \nfloat randFloat(inout uint state) {\n    return float(hash(state)) / 4294967296.0;\n}\n \nvec3 randUnitVector(inout uint state) {\n    float z = randFloat(state) * 2.0 - 1.0;\n    float a = randFloat(state) * PI * 2.0;\n    float r = sqrt(1.0 - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec2 randState;\n\nfloat rand2D() {\n    randState.x = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);\n    randState.y = fract(sin(dot(randState.xy + iTime, vec2(12.9898, 78.233))) * 43758.5453);\n\n    return randState.x;\n}\n\nvec3 randVecTest() {\n    // Returns a random direction in unit sphere (used in the BRDF)\n    float phi = 2.0 * PI * rand2D();\n    float cosTheta = 2.0 * rand2D() - 1.0;\n    float u = rand2D();\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    // Change of variables \n    // Spherical Coordinates -> Carthesian Coordinates, to get (x, y, z) values \n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n \nbool iQuad(in vec3 ro, in vec3 rd, inout hit info, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    vec3 norm = normalize(cross(c-a, c-b));\n    if (dot(norm, rd) > 0.0) {\n        norm *= -1.0;\n        \n\t\tvec3 temp = d;\n        d = a;\n        a = temp;\n        \n        temp = b;\n        b = c;\n        c = temp;\n    }\n    \n    vec3 p = ro;\n    vec3 q = ro + rd;\n    vec3 pq = q - p;\n    vec3 pa = a - p;\n    vec3 pb = b - p;\n    vec3 pc = c - p;\n\n    vec3 m = cross(pc, pq);\n    float v = dot(pa, m);\n    vec3 intersectPos;\n    if (v >= 0.0) {\n        float u = -dot(pb, m);\n        if (u < 0.0) return false;\n        float w = dot(cross(pq, pb), pa);\n        if (w < 0.0) return false;\n        float denom = 1.0 / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*b+w*c;\n    }\n    else {\n        vec3 pd = d - p;\n        float u = dot(pd, m);\n        if (u < 0.0) return false;\n        float w = dot(cross(pq, pa), pd);\n        if (w < 0.0) return false;\n        v = -v;\n        float denom = 1.0 / (u+v+w);\n        u*=denom;\n        v*=denom;\n        w*=denom;\n        intersectPos = u*a+v*d+w*c;\n    }\n    \n    float dist;\n    if (abs(rd.x) > 0.1) {\n        dist = (intersectPos.x - ro.x) / rd.x;\n    }\n    else if (abs(rd.y) > 0.1) {\n        dist = (intersectPos.y - ro.y) / rd.y;\n    }\n    else {\n        dist = (intersectPos.z - ro.z) / rd.z;\n    }\n    \n\tif (dist > minHitTime && dist < info.dist) {\n        info.dist = dist;        \n        info.norm = norm;        \n        return true;\n    }    \n    \n    return false;\n}\n\nbool iSphere(in vec3 ro, in vec3 rd, inout hit info, in vec4 sphere) {\n\tvec3 m = ro - sphere.xyz;\n\n\tfloat b = dot(m, rd);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\tfloat discr = b * b - c;\n\n\tif(discr < 0.0)\n\t\treturn false;\n    \n    bool fromInside = false;\n\tfloat dist = -b - sqrt(discr);\n    if (dist < 0.0) {\n        fromInside = true;\n        dist = -b + sqrt(discr);\n    }\n    \n\tif (dist > minHitTime && dist < info.dist) {\n        info.dist = dist;        \n        info.norm = normalize((ro+rd*dist) - sphere.xyz) * (fromInside ? -1.0 : 1.0);\n        return true;\n    }\n    \n    return false;\n}\n/*\nvoid sceneTrace(in vec3 ro, in vec3 rd, inout hit hitInfo) {\n    vec3 A = vec3(-15.0, -15.0, 21.0);\n    vec3 B = vec3( 15.0, -15.0, 21.0);\n    vec3 C = vec3( 15.0,  15.0, 21.0);\n    vec3 D = vec3(-15.0,  15.0, 21.0);\n    \n    vec3 E = vec3(-15.0, -15.0, 21.0);\n    vec3 F = vec3(-15.0, -15.0, 11.0);\n    vec3 G = vec3(-15.0,  15.0, 11.0);\n    vec3 H = vec3(-15.0,  15.0, 21.0);\n    \n    hitInfo.spec = 0.0;\n    hitInfo.rough = 0.25;\n    hitInfo.speccol = vec3(1.0);\n    \n    if (iQuad(ro, rd, hitInfo, A, B, C, D)) {\n        hitInfo.albedo = vec3(0.7, 0.7, 0.7);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (iQuad(ro, rd, hitInfo, E, F, G, H)) {\n        hitInfo.albedo = vec3(0.7, 0.7, 0.7);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n        hitInfo.spec = 1.0;\n        hitInfo.rough = 0.1;\n        hitInfo.speccol = vec3(1.0, 1.0, 1.0);\n    }\n\n    if (iSphere(ro, rd, hitInfo, vec4(-10.0, 0.0, 20.0, 1.0))) {\n        hitInfo.albedo = vec3(1.0, 0.1, 0.1);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n    } \n     \n    if (iSphere(ro, rd, hitInfo, vec4(0.0, 0.0, 20.0, 1.0))) {\n        hitInfo.albedo = vec3(0.1, 1.0, 0.1);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n        hitInfo.spec = 1.0;\n        hitInfo.rough = 0.1;\n        hitInfo.speccol = vec3(0.1, 1.0, 0.1);\n    }    \n     \n    if (iSphere(ro, rd, hitInfo, vec4(10.0, 0.0, 20.0, 1.0))) {\n        hitInfo.albedo = vec3(0.1, 0.1, 1.0);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n    }           \n     \n     \n    if (iSphere(ro, rd, hitInfo, vec4(10.0, 10.0, 20.0, 3.0))) {\n        hitInfo.albedo = vec3(1.0, 1.0, 1.0);\n        hitInfo.emissive = vec3(1.0, 1.0, 1.0) * 100.0;\n    }         \n}\n*/\n\nvoid sceneTrace(in vec3 ro, in vec3 rd, inout hit hitInfo) {\n    vec3 A = vec3(-15.0, -15.0, 21.0);\n    vec3 B = vec3( 15.0, -15.0, 21.0);\n    vec3 C = vec3( 15.0,  15.0, 21.0);\n    vec3 D = vec3(-15.0,  15.0, 21.0);\n    \n    vec3 E = vec3(-15.0, -15.0, 21.0);\n    vec3 F = vec3(-15.0, -15.0, 11.0);\n    vec3 G = vec3(-15.0,  15.0, 11.0);\n    vec3 H = vec3(-15.0,  15.0, 21.0);\n    \n    vec3 I = vec3(15.0, -15.0, 21.0);\n    vec3 J = vec3(15.0, -15.0, 11.0);\n    vec3 K = vec3(15.0,  15.0, 11.0);\n    vec3 L = vec3(15.0,  15.0, 21.0);\n    \n    vec3 w1 = vec3(-10.0, 0.0, 21.0);\n    vec3 w2 = vec3(15.0, 0.0, 21.0);\n    vec3 w3 = vec3(15.0, 0.0, 11.0);\n    vec3 w4 = vec3(-10.0, 0.0, 11.0);\n    \n    hitInfo.spec = 0.0;\n    hitInfo.rough = 0.25;\n    hitInfo.speccol = vec3(1.0);\n    \n    if (iQuad(ro, rd, hitInfo, A, B, C, D)) {\n        hitInfo.albedo = vec3(0.7, 0.7, 0.7);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (iQuad(ro, rd, hitInfo, I, J, K, L)) {\n        hitInfo.albedo = vec3(0.7, 0.7, 0.7);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (iQuad(ro, rd, hitInfo, w1, w2, w3, w4)) {\n        hitInfo.albedo = vec3(0.7, 0.7, 0.7);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n    }\n    \n    if (iQuad(ro, rd, hitInfo, E, F, G, H)) {\n        hitInfo.albedo = vec3(0.0, 1.0, 0.0);\n        hitInfo.emissive = vec3(0.0, 0.0, 0.0);\n        hitInfo.spec = 0.9;\n        hitInfo.rough = 0.0;\n        hitInfo.speccol = vec3(1.0, 0.0, 1.0);\n    }\n\n    if (iSphere(ro, rd, hitInfo, vec4(10.0, 10.0, 15.0, 3.0))) {\n        hitInfo.albedo = vec3(1.0, 1.0, 1.0);\n        hitInfo.emissive = vec3(1.0, 1.0, 1.0) * 100.0;\n    }         \n}\n\nvec3 brdf(vec3 N, vec3 V, vec3 L, float rough, float metal, vec3 alb) {\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, alb, metal);\n    \n    vec3 H = normalize(V + L);\n    \n    float NDF = distributionGGX(N, H, rough);\n    float G = geometrySmith(N, V, L, rough);\n    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n    \n    vec3 kd = vec3(1.0) - F;\n    kd *= 1.0 - metal;\n    vec3 num = NDF * G * F;\n    float denom = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n    vec3 spec = num / denom;\n    \n    float ndotl = max(dot(N, L), 0.0);\n    return ndotl * alb;\n}\n \nvec3 path(in vec3 ro, in vec3 rd, inout uint rngState) {\n    vec3 ret = vec3(0.0, 0.0, 0.0);\n    vec3 through = vec3(1.0, 1.0, 1.0);\n    vec3 norm;\n     \n    for (int bounce = 0; bounce <= bounces; ++bounce) {\n        hit hit;\n        hit.dist = far;\n        sceneTrace(ro, rd, hit);\n         \n        if (hit.dist == far) {\n            ret += texture(iChannel1, rd).rgb * through * 2.5;\n            break;\n        }\n         \n        ro = (ro + rd * hit.dist) + hit.norm * normNudge;\n        \n        vec3 prd = rd;\n        \n        float specularChance = hit.spec;\n        /*if (specularChance > 0.0) {\n            specularChance = fresnelSchlick(max(dot(normalize(-prd + rd), -prd), 0.0), vec3(hit.spec)).r;\n        }*/\n        \n        float doSpecular = (randFloat(rngState) < specularChance) ? 1.0 : 0.0;\n         \n        //vec3 lrd = normalize(hit.norm + randUnitVector(rngState));\n        vec3 lrd = randUnitVector(rngState);\n        //vec3 lrd = randVecTest();\n        vec3 rrd = reflect(rd, hit.norm);\n        \n        rrd = normalize(mix(rrd, lrd, hit.rough * hit.rough));\n        \n        rd = mix(lrd, rrd, doSpecular);\n        vec3 alb = mix(hit.albedo, hit.speccol, doSpecular);\n         \n        ret += hit.emissive * through;\n\n        through *= brdf(hit.norm, -prd, rd, hit.rough, hit.spec, alb);\n        //through *= alb;\n    }\n  \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    \n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n    randState = fragCoord / iResolution.xy;\n\n    float cameraDistance = 1.0 / tan(fov * 0.5 * PI / 180.0); \n    \n    vec3 rt = vec3((fragCoord/iResolution.xy) * 2.0 - 1.0, cameraDistance);\n     \n    float aspectRatio = iResolution.x / iResolution.y;\n    rt.y /= aspectRatio;\n     \n    vec3 rd = normalize(rt - ro);\n     \n    vec3 col;\n    for (int i = 0; i < samples; ++i)\n        col += path(ro, rd, rngState) / float(samples);\n    //col = randUnitVector(rngState);\n    \n    \n    vec3 lastcol = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    col = mix(lastcol, col, 1.0 / float(iFrame+1));\n \n    fragColor = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323;\n\nvec3 aces(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat distributionGGX (vec3 N, vec3 H, float roughness){\n    float a2    = roughness * roughness * roughness * roughness;\n    float NdotH = max (dot (N, H), 0.0);\n    float denom = (NdotH * NdotH * (a2 - 1.0) + 1.0);\n    return a2 / (PI * denom * denom);\n}\n\nfloat geometrySchlickGGX (float NdotV, float roughness){\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\nfloat geometrySmith (vec3 N, vec3 V, vec3 L, float roughness){\n    return geometrySchlickGGX (max (dot (N, L), 0.0), roughness) * \n           geometrySchlickGGX (max (dot (N, V), 0.0), roughness);\n}\n\nvec3 fresnelSchlick (float cosTheta, vec3 F0){\n    return F0 + (1.0 - F0) * pow (1.0 - cosTheta, 5.0);\n}","name":"Common","description":"","type":"common"}]}