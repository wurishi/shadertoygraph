{"ver":"0.1","info":{"id":"WtVyDw","date":"1624904939","viewed":82,"name":"Wachspress Coordinates","username":"Reynolds","description":"Wachspress are generalised barycentric coordinates which are valid for convex polygons. The functions allow you to interpolate over multisided faces. Shows isolines of the coordinate of one vertex.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["gbc","generalisedbarycentriccoordinates","parametrisation"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define N 6\n\nfloat signedTriangleArea(vec2 v1, vec2 v2, vec2 v3) {\n    float det = v2.x*v3.y + v3.x*v1.y + v1.x*v2.y - v2.x*v1.y - v1.x*v3.y - v3.x*v2.y;\n    return det;\n}\n\n\nfloat[N] wachspress(vec2 p, vec2[N] poly) {\n    float[N] weights;\n    float sumweights = 0.0;\n    float A_i, A_iplus1, B;\n    \n    \n    A_iplus1 = signedTriangleArea(poly[N - 1], poly[0], p);\n    for(int i = 0; i < N; i++) {\n        A_i = A_iplus1;\n        A_iplus1 = signedTriangleArea(poly[i], poly[(i+1) % N], p);     \n        \n        //if the polygon is regular this could be kept constant\n        B = signedTriangleArea(poly[(i - 1 + N) % N], poly[i], poly[(i+1) % N]);\n        \n        \n        weights[i] = B / (A_i*A_iplus1);\n        sumweights += weights[i];\n    }\n    \n    //normalize\n    float recp = 1.0/sumweights;\n    for(int i = 0; i < N; i++) {\n        weights[i] *= recp;\n    }\n    return weights;\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a, ba = b-a;\n    float A = dot(pa,ba)/dot(ba,ba);\n    float h = clamp( A, 0.0, 1.0 );\n\n    return length( pa - ba*h);\n}\n\nfloat sdScene(vec2 p,     vec2[N] poly) {\n    float d = sdSegment(p, poly[0], poly[1]);\n    \n    for(int i = 0; i < N; ++i) {\n       d = min(d, sdSegment(p, poly[i], poly[(i+1) % N])); \n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y - vec2(0.25, 0.0);\n\n    vec3 col = vec3(1.0);\n\n\n    //create a polygon\n    vec2[N] poly;\n    float R = 0.5;\n    float tpi = 2.0*3.14159;\n    \n    float incr = 1.0/float(N);\n    float phi = 0.0;\n    for(int i = 0; i < N; ++i) {\n        poly[i] = vec2(0.5, 0.5) + R * vec2(cos(tpi * phi), sin(tpi * phi));\n        \n        phi += incr;\n    }\n\n    //perturb right most vertex\n    poly[0] += 0.25*vec2(sin(iTime), 0.0);\n    \n   \n    float[N] weights = wachspress(uv, poly);\n    float d = sdScene(uv, poly);\n    \n    \n    \n    //change v to [0,..,N-1] to show the other coordinate functions    \n    int v = 0;\n\n    \n    //render isolines\n    float linewidth = 0.005;\n    float z = 0.001;\n    if(weights[0] > 0.0 && weights[1] > 0.0 && weights[2] > 0.0 && weights[3] > 0.0) {\n        //to change number of isolines    \n        float w = 0.1;\n        for(int i = 0; i < 9; ++i) {\n            if(weights[v] > (w - linewidth) && weights[v] < (w + linewidth) ) {\n                float f = weights[v] - (w - linewidth);\n                f /= 2.0 * linewidth;\n                \n                if(f < 0.5) {\n                    col = vec3(smoothstep(1.0, 0.0, f/0.5));\n                }  else {\n                    col = vec3(smoothstep(0.0, 1.0, (f - 0.5)/0.5));\n                }\n            }\n            w += 0.1;\n            linewidth += z;\n        }\n    }\n    \n    \n\n    //draw polygon through segments\n    linewidth = 0.005;\n    float e = smoothstep(0.0, 1.0, d / linewidth);\n    if(e < 1.) {\n        fragColor = vec4(vec3(e), 1.0);\n    } else {\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}