{"ver":"0.1","info":{"id":"DtSSWm","date":"1676135479","viewed":159,"name":"Pathtraced DoF","username":"RubberDuck55","description":"Depth of field using a method described here: https://stackoverflow.com/questions/10012219/how-to-implement-depth-of-field-in-ray-tracer\n\nI don't believe this method has Bokeh","likes":2,"published":3,"flags":32,"usePreview":1,"tags":["pathtracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Editable values in Buffer A\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    fragColor = vec4(data.rgb/data.a, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEP 250\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n#define BOUNCES 3\n\n#define num_obj 7\n\nfloat seed;\n\nstruct sphere {\n    vec3   pos;\n    float  r;\n    vec3   col;\n};\n\nstruct hit {\n    float  dist;\n    vec3   pos, n, ro, rd;\n    bool   sky;\n    sphere s;\n};\n\nsphere obj[num_obj];\n\nvoid init_obj () {\n    obj[0] = sphere(vec3(0.,-1001.,0.), 1000., vec3(1.)); // Floor\n    obj[1] = sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.));  // Main\n    obj[2] = sphere(vec3(2.0, -.6, 0.0), 0.4, vec3(1., 1., 0.5));\n    obj[3] = sphere(vec3(-2., -.6, -2.), 0.4, vec3(1.,0.5, 1.));\n    obj[4] = sphere(vec3(-2., -.6, 2.0), 0.4, vec3(0.5,1., 0.5));\n    obj[5] = sphere(vec3(1.5, -.6, 3.0), 0.4, vec3(1.,0.5,0.5));\n    obj[6] = sphere(vec3(2., -.6, -3.0), 0.4, vec3(0.5,0.5,1.));\n}\n\nmat2 rot (float a) {\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nvoid init_rand (vec2 p) {\n    p = vec2(mod(p.x, 32.321), mod(p.y, 526.834));\n    float s = sin(p.x * 453.432) * 342.324 - cos(p.y * 345.468) * 732.345;\n    seed = s;\n}\n\nfloat rand () {\n    seed += fract(sin(seed * 0.523454) * 5773.7327);\n    return fract(sin(seed * 0.493732) * 3427.6872);\n}\n\nvec3 rand_hemisphere (vec3 n) {\n    float phi = (rand()-0.5) * 3.1416 * 4.;\n    float theta = (rand()-0.5) * 3.1416 * 4.;\n    \n    vec3 vec = vec3(sin(phi) * cos(theta), sin(phi) * sin(theta), cos(phi));\n    return dot(vec, n) < 0. ? vec*-1. : vec;\n}\n\nvec2 rand_disk () {\n    float theta = (rand()-0.5) * 3.1416 * 2.;\n    float mag   = rand();\n    \n    return vec2(sin(theta), cos(theta)) * mag;\n}\n\nfloat dist_sphere (vec3 p, out sphere s) {\n    float minDist = MAX_DIST;\n    \n    for(int i = 0; i < num_obj; i++) {\n        float td = length(p-obj[i].pos)-obj[i].r;\n        \n        if(td < minDist) {\n            minDist = td;\n            s = obj[i];\n        }\n    }\n    \n    return minDist;\n}\n\nfloat dist (vec3 p) {\n    sphere s;\n    return dist_sphere(p, s);\n}\n\nvec3 normal(vec3 p){\n  float d = dist(p);\n  vec2 e = vec2(.001, 0);\n  \n  vec3 n = d - vec3(\n    dist(p-e.xyy),\n    dist(p-e.yxy),\n    dist(p-e.yyx));\n  \n  return normalize(n);\n}\n\nhit raymarch (vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    \n    bool sky = true;\n    \n    for(int i = 0; i < MAX_STEP; i++) {\n        vec3 p = ro + rd * dO;\n        \n        float d = dist(p);\n        \n        if(d <= SURF_DIST) {\n            sky = false;\n            break;\n        }\n        if(dO >= MAX_DIST) {\n            sky = true;\n        }\n        dO += d;\n    }\n    \n    vec3 p = ro + rd * dO;\n    \n    sphere s;\n    dist_sphere(p, s);\n    \n    return hit(dO, p, normal(p), ro, rd, sky, s);\n}\n\nvec3 montecarlo (vec3 ro, vec3 rd) {\n    vec3 mask  =  vec3(1.0);\n    vec3 color =  vec3(0.0);\n    \n    for (int i = 0; i < BOUNCES; i++) {\n        vec3 col = vec3(0.0);\n        hit h = raymarch(ro, rd);\n        \n        ro = h.pos + h.n *  SURF_DIST;\n        \n        if(h.sky) {\n            col = texture(iChannel1, h.pos).rgb*1.4;\n            mask  *=  col;\n            color +=  mask;\n            break;\n        }\n        else {\n            col = h.s.col;\n            rd  = rand_hemisphere(h.n); \n        }\n        \n        mask  *=  col;//  \\/ This is the throughput\n        color +=  mask * 0.01;\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(ivec2(fragCoord) == ivec2(0)) {\n        fragColor = vec4(iResolution.xyxy);\n        return;\n    }\n    \n    init_obj();\n    \n    init_rand(fragCoord * iTime + 1.0);\n    \n    vec2 uv = ((fragCoord+vec2(rand()-.5,rand()-.5)) / iResolution.xy-.5)/vec2(1.,iResolution.x/iResolution.y);\n    \n    vec3 ro = vec3(0.,0.,-8.);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    // Random Rotation For DoF\n    //                     \\/ This is the amount of blur\n    vec2 ra = rand_disk()*0.1;\n    \n    ro.xz *= rot(ra.x);\n    ro.yz *= rot(ra.y);\n    rd.xz *= rot(ra.x);\n    rd.yz *= rot(ra.y);\n    //\n    //\n    \n    vec3 col = vec3(montecarlo(ro, rd));\n    \n    if(texelFetch(iChannel0, ivec2(0), 0) == vec4(iResolution.xyxy)){\n        fragColor = vec4(col,1.0) + texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else {\n        fragColor = vec4(col,1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}