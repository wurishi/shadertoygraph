{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"webcam","id":"4sf3zn","filepath":"/presets/webcam.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"music","id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Qiong Wang, https://github.com/GabriellaQiong\n// Guanyu He, https://github.com/heguanyu\n// GPU Programming and Architecture Hackathon, University of Pennsylvania\n// http://www.seas.upenn.edu/~cis565/\n\n\n\n// constants for the camera tunnel\nconst vec2 cama=vec2(-2.5,3.);\nconst vec2 camb=vec2(0.25,0.20);\nconst vec2 camc=vec2(-4.0,2.5);\nconst vec2 camd=vec2(0.1,-0.15);\n\nconst vec2 lighta=vec2(1.5,4.0);\nconst vec2 lightb=vec2(-0.15,0.25);\nconst vec2 lightc=vec2(-2.5,1.5);\nconst vec2 lightd=vec2(-0.15,0.10);\n\n// calculates the position of a single tunnel\nvec2 Position(float z, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\treturn sin(z*a)*b+sin(z*c)*d;\n}\n\n// calculates 3D positon of a tunnel for a given time\nvec3 Position3D(float time, vec2 a, vec2 b, vec2 c, vec2 d)\n{\n\treturn vec3(Position(time,a,b,c,d),time);\n}\n\n// 2d distance field for a slice of a single tunnel\nfloat Distance(vec3 p, vec2 a, vec2 b, vec2 c, vec2 d, vec2 e, float r)\n{\n\tvec2 pos=Position(p.z,a,b,c,d);\t\n\tfloat radius=max(10.0,r+sin(p.z*e.x)*e.y)/5000.0;\n\treturn radius / dot(p.xy-pos,p.xy-pos);\n}\n\n// 2d distance field for a slice of the tunnel network\nfloat Dist2D(vec3 pos)\n{\n\tfloat d=0.0;\t\n\td+=Distance(pos,cama,camb,camc,camd,vec2(2.1913,15.4634),50.0000);\n\t//d-=Distance(pos,lighta,lightb,lightc,lightd,vec2(0.3814,12.7206),17.0590)*0.8;\n\treturn d;\n}\n\nvec3 nmap(vec2 t, sampler2D tx, float str)\n{\n\tfloat d=1.0/1024.0;\n\n\tfloat xy=texture(tx,t).x;\n\tfloat x2=texture(tx,t+vec2(d,0)).x;\n\tfloat y2=texture(tx,t+vec2(0,d)).x;\n\t\n\tfloat s=(1.0-str)*1.2;\n\ts*=s;\n\ts*=s;\n\t\n\treturn normalize(vec3(x2-xy,y2-xy,s/8.0));///2.0+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time=iTime/3.0+291.0;//+43.63/3.0;\n\n\t//calculate camera by looking ahead in the tunnel\n\tvec2 mo = iMouse.xy / iResolution.xy / 10.0 ;\n    if( iMouse.z<=0.00001) mo=vec2(0.0);\n\tvec2 p1=Position(time+0.05,cama,camb,camc,camd) + mo; //position ahead\n\tvec3 Pos=Position3D(time,cama,camb,camc,camd); //current position\n\tvec3 oPos=Pos + vec3(mo, 0.0);\n\t\n\tvec3 CamDir=normalize(vec3(p1.x-Pos.x,-p1.y+Pos.y,0.1));\n\tvec3 CamRight=normalize(cross(CamDir,vec3(0,1,0)));\n\tvec3 CamUp=normalize(cross(CamRight,CamDir));\t\n\tmat3 cam=mat3(CamRight,CamUp,CamDir);\n\n\t//ray calculation\t\n\tvec2 uv=2.0*fragCoord.xy/iResolution.xy-1.0;\n\tfloat aspect=iResolution.x/iResolution.y;\n\t\n\tvec3 Dir=normalize(vec3(uv*vec2(aspect,1.0),1.0))*cam;\n\t\n\t//raymarching\n\tfloat fade=0.0;\n\t\n\tconst float numit=75.0; //raymarch precision\n\tconst float threshold=1.20; //defines the thickness of tunnels\n\tconst float scale=1.5; //tunnel z depth\n\t\n\tvec3 Posm1=Pos;\n\t\n\t//calculate first hit\n\tfor (float x=0.0; x<numit; x++)\n\t{\n\t\tif (Dist2D(Pos)<threshold)\n\t\t{\n\t\t\tfade=1.0-x/numit;\n\t\t\tbreak;\n\t\t}\n\t\tPosm1=Pos;\n\t\tPos+=Dir/numit*scale;//*(1.0+x/numit);\n\t}\n\n\t//track back to get better resolution\n\tfor (int x=0; x<8; x++)\n\t{\n\t\tvec3 p2=(Posm1+Pos)/2.0;\n\t\tif (Dist2D(p2)<threshold) \n\t\t\tPos=p2;\n\t\telse\n\t\t\tPosm1=p2;\n\t}\t\n\n\t//lighting\t\n\tvec3 n=normalize(vec3(Dist2D(Pos+vec3(0.01,0,0))-Dist2D(Pos+vec3(-0.01,0,0)),\n\t\t\t\t\t\t  Dist2D(Pos+vec3(0,0.01,0))-Dist2D(Pos+vec3(0,-0.01,0)),\n\t\t\t\t\t\t  Dist2D(Pos+vec3(0,0,0.01))-Dist2D(Pos+vec3(0,0,-0.01))));\n\t\n\t//triplanar blend vector\n\tvec3 tpn=normalize(max(vec3(0.0),(abs(n.xyz)-vec3(0.2))*7.0))*0.5;\n\t\n\t//position of the light - uncomment the second line to get a more interesting path\n\tvec3 lp=Position3D(time+0.2,cama,camb,camc,camd); //current light position\n\tvec3 lp1=Position3D(time+0.3,cama + vec2(2.0),camb ,camc,camd); //current light position\n\tvec3 lp2=Position3D(time+0.1,cama ,camb ,camc + vec2(2.0),camd); //current light position\n\tvec3 lp3=Position3D(time+0.15,cama + vec2(2.0),camb ,camc + vec2(2.0),camd); //current light position\n\t\n\t//lp=Position3D(time+0.3,lighta,lightb,lightc,lightd);\n\t\n\tvec3 ld=lp-Pos;\t//light direction\n\tfloat lv=1.0;\n\t\n\tconst float ShadowIT=15.0; //shadow precision\n\t\n\t//shadow calc\n\tfor (float x=1.0; x<ShadowIT; x++)\n\t\tif (Dist2D(Pos+ld*(x/ShadowIT))<threshold) \n\t\t{\n\t\t\tlv=0.0;\n\t\t\tbreak;\n\t\t}\n\n\tvec3 tuv=Pos*vec3(3.0,3.0,1.5);\t//texture coordinates\n\t\n\t//normal mapping\n\tfloat nms=0.1;\n\tvec3 nmx=nmap(tuv.yz,iChannel0,nms)+nmap(-tuv.yz,iChannel0,nms);\n\tvec3 nmy=nmap(tuv.xz,iChannel1,nms)+nmap(-tuv.xz,iChannel1,nms);\n\tvec3 nmz=nmap(tuv.xy,iChannel2,nms)+nmap(-tuv.xy,iChannel2,nms);\n\t\n\tvec3 nn=normalize(nmx*tpn.x+nmy*tpn.y+nmz*tpn.z);\n\t\n\tfloat dd;\n\t//normalmapped version:\n\tdd=max(0.0,dot(nn,normalize(ld*mat3(vec3(1,0,0),vec3(0,0,1),n))));\n\t//standard version:\n\t//dd=max(0.0,dot(n,normalize(ld)));\n\t\n\tvec4 diff=vec4(dd*1.2*lv)+vec4(0.2);\n\n\t//wisp\n\t\n\tfloat dot1=dot(normalize(Pos-oPos),normalize(lp-oPos));\n\tfloat w=pow(dot1,300.0);\n\tvec4 wispcolor=vec4(10.0);\n\twispcolor=vec4(texture(iChannel3,vec2(0.1)).x,texture(iChannel3,vec2(0.3)).x,\n\t\t\t\t   texture(iChannel3,vec2(0.8)).x,1.0)\n\t\t*pow(texture(iChannel3,vec2(0.5)).x,5.0)\n\t\t*110.0;\n\n\tif (length(Pos-oPos)<length(lp-oPos)) w=0.0;\n\t\n\t\n\tvec3 oPos1 = oPos + vec3(Dist2D(Pos));\n\n\tfloat w1=pow(dot(normalize(Pos-oPos1),normalize(lp-oPos1)),10000.0);\n\n\t\n\t//float w1=pow(abs(sin(time * 100.0)),1000.0);\n\t//float w1=pow(min(length(lp-oPos)/5.0,1.0),1.0);\t\t\n\tif (length(Pos-oPos1)<length(lp-oPos1)) w1=0.0;\n\t//vec3 oPos2 = oPos + vec3(Dist2D(Pos));\n\tfloat w2=pow(dot(normalize(Pos-oPos1),normalize(lp1-oPos1)),5000.0);\t\n\t//if (length(Pos-oPos1)<length(lp1-oPos1)) w2=0.0;\n\tfloat w3=pow(dot(normalize(Pos-oPos1),normalize(lp2-oPos1)),4000.0);\t\n\t//if (length(Pos-oPos1)<length(lp2-oPos1)) w3=0.0;\t\n\tfloat w4=pow(dot(normalize(Pos-oPos1),normalize(lp3-oPos1)),7000.0);\t\n\t\n\t//texturing\n\t//double sampling to fix seams on texture edges\n\tvec4 tx=texture(iChannel0,tuv.yz)+texture(iChannel0,-tuv.yz);\n\tvec4 ty=texture(iChannel1,tuv.xz)+texture(iChannel1,-tuv.xz);\n\tvec4 tz=texture(iChannel2,tuv.xy)+texture(iChannel2,-tuv.xy);\n\tvec4 tt=texture(iChannel0,tuv.yz)+texture(iChannel0,-tuv.yz);\n\t\n\tfloat tpnn;\n\tif(sin(time * 100.0) > 0.0)\n\t\ttpnn = 1.0;\n\telse\n\t\ttpnn = 0.0;\n\t\n\tvec4 col=tx*tpn.x / 1.3 +ty*tpn.y +tz*tpn.z + tt * tpnn / 10.0;\n\t\n\tfragColor = col*diff*min(1.0,fade*10.0) \n\t\t+w*wispcolor\n\t\t+ w1 * vec4(0.2, 0.2, 0.8, 0.0)\n\t\t+ w2 * vec4(0.8, 0.2, 0.2, 0.0) \n\t\t+ w3 * vec4(0.2, 0.8, 0.2, 0.0) \n\t\t+ w4 * vec4(0.8, 0.8, 0.2, 0.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":true,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s23zD","date":"1384663924","viewed":344,"name":"Chrome Tunnel","username":"Guanyu","description":"4 Colors racing in the tunnel, Chrome Color!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["byqiongandguanyu"],"hasliked":0,"parentid":"","parentname":""}}