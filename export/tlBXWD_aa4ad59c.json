{"ver":"0.1","info":{"id":"tlBXWD","date":"1565924851","viewed":174,"name":"The jail","username":"Albeforia","description":".","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float GAMMA_FACTOR = 2.2;\n\n/**\n * Gamma correction.\n */\nvec3 linearToGamma(vec3 value, float gammaFactor) {\n\treturn pow(value, vec3(1.0 / gammaFactor));\n}\n\n/**\n * Reinhard tonemapping.\n */\nvec3 tonemapReinhard(vec3 x) {\n\treturn x / (x + vec3(1.0));\n}\n\n/**\n * ACES tonemapping.\n */\nvec3 tonemapACES(vec3 x) {\n\tconst float a = 2.51;\n\tconst float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).xyz;\n        \n    //col = tonemapACES(col);\n    \n    fragColor = vec4(linearToGamma(col, GAMMA_FACTOR), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//=======================================================================================\n// Constants\n//=======================================================================================\n\nconst float PI = 3.14159265359;\nconst float\tEPSILON = 0.001;\n\nconst int\tMSAA_COUNT = 1;\n\nconst int\tVIEW_RAY_MAX_STEPS = 120;\nconst float VIEW_RAY_MAX_LENGTH = 20.0;\n\nconst int\tSHADOW_RAY_MAX_STEPS = 30;\nconst float SHADOW_RAY_MAX_LENGTH = 10.0;\n\nconst float VOL_RAY_MARCHING_STEP = 0.1;\n\nconst float\tMIN_REFLECTIVITY = 0.04;\n\n//=======================================================================================\n// Math\n//=======================================================================================\n\nfloat pow2(float x) {\n\treturn x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n\treturn x2 * x2;\n}\n\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(0.1031, 0.1030, 0.0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n//=======================================================================================\n// Transformations\n// Matrices are column-major and already inverted.\n//=======================================================================================\n\nmat4 rotateX(float a) {\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat4(1, 0, 0, 0,\n                0, c,-s, 0,\n                0, s, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateY(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c, 0, s, 0,\n                0, 1, 0, 0,\n                -s,0, c, 0,\n                0, 0, 0, 1);\n}\n\nmat4 rotateZ(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat4(c,-s, 0, 0,\n                s, c, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n}\n\nmat4 translate(vec3 p) {\n\treturn mat4(1,    0,    0,    0,\n                0,    1,    0,    0,\n                0,    0,    1,    0,\n                -p.x, -p.y, -p.z, 1);\n}\n\n//=======================================================================================\n// Struct Definitions\n//=======================================================================================\n\nstruct sRay {\n    vec3\to;\n    vec3\tdir;\n    float\ttMin;\n    float\ttMax;\n};\n\nstruct sHit {\n    vec3\tp;\n    float\tt;\n    int\t\tmid;\n};\n\nstruct sSceneRec {\n\tfloat\td;\n    int\t\tmid;\n};\n\nstruct sMaterial {\n    vec3\tbaseColor;\n    float\troughness;\n    float\tmetalness;\n};\n\nstruct sPointLight {\n    vec3    color;\n    vec3    position;\n    float   range;\n    float   decay;\n};\n\n//=======================================================================================\n// Material Definitions\n//=======================================================================================\n\n#define MATERIAL_DEFAULT\t\t0\n#define MATERIAL_1\t\t\t\t1\n#define MATERIAL_2\t\t\t\t2\n#define MATERIAL_3\t\t\t\t3\n#define MATERIAL_4\t\t\t\t4\n\nconst int MAX_MATERIALS_NUM = 3;\n\nsMaterial gMaterials[MAX_MATERIALS_NUM] = sMaterial[MAX_MATERIALS_NUM] (\n    // #0 default\n\tsMaterial(\n    \tvec3(0.1, 0.1, 0.1),\n        0.99,\n        0.0\n    ),\n    // #1\n\tsMaterial(\n    \tvec3(1.000, 0.782, 0.344),  // gold\n        0.2,\n        1.0\n    ),\n    // #2\n\tsMaterial(\n    \tvec3(0.913, 0.922, 0.924),\t// aluminum\n        0.15,\n        1.0\n    )\n);\n\n//=======================================================================================\n// Light Definitions\n//=======================================================================================\n\nsPointLight gPointLight0 = sPointLight(\n    vec3(2.0),\n    vec3(0.0, 1.5, 0.5),\n    6.0, 2.0\n);\n\n//=======================================================================================\n// SDF Definitions\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdBox(vec3 p, vec3 b, float r) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) - r + length(max(d, 0.0));\n}\n\n//=======================================================================================\n// Distance Operations\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\n/**\n * Return a if cond is true, otherwise b.\n */\nsSceneRec select(sSceneRec a, sSceneRec b, bool cond) {\n    int s = int(cond);\n\treturn sSceneRec(\n        a.d * float(s) + b.d * float(1 - s),\n        a.mid * s + b.mid * (1 - s)\n    );\n}\n\nsSceneRec opU(sSceneRec r1, sSceneRec r2) {\n    return select(r1, r2, r1.d < r2.d);\n}\n\nsSceneRec opI(sSceneRec r1, sSceneRec r2) {\n\treturn select(r1, r2, r1.d > r2.d);\n}\n\nsSceneRec opS(sSceneRec r1, sSceneRec r2) {\n    r2.d = -r2.d;\n\treturn select(r1, r2, r1.d > r2.d);\n}\n\n//=======================================================================================\n// Domain Operations\n// ref: https://iquilezles.org/articles/distfunctions\n//=======================================================================================\n\nvec3 opRep(vec3 p, vec3 spacing) {\n\treturn mod(p, spacing) - 0.5 * spacing;\n}\n\n//=======================================================================================\n// Scene\n//=======================================================================================\n\nsSceneRec sdScene(vec3 p) {\n\tsSceneRec p1 = sSceneRec(sdPlane(p), MATERIAL_DEFAULT);\n    vec3 pr = (rotateX(PI/2.0) * vec4(p, 1.0)).xyz;\n    sSceneRec p2 = sSceneRec(sdPlane(pr), MATERIAL_DEFAULT);\n    \n    vec3 q = opRep(p - vec3(0.0, 0.0, 1.6), vec3(0.4, 0.0, 0.0));\n    sSceneRec b1 = sSceneRec(sdBox(q, vec3(0.05, 5.0, 0.05), 0.0),\n                             MATERIAL_2);\n    \n    q = opRep(p - vec3(0.0, 0.0, 1.6), vec3(0.0, 0.35, 0.0));\n    sSceneRec b2 = sSceneRec(sdBox(q, vec3(10.0, 0.05, 0.05), 0.0),\n                             MATERIAL_2);\n\n    return opU(opU(p1, p2), opU(b1, b2));\n}\n\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)).d - sdScene(vec3(p.x - EPSILON, p.y, p.z)).d,\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)).d - sdScene(vec3(p.x, p.y - EPSILON, p.z)).d,\n        sdScene(vec3(p.x, p.y, p.z + EPSILON)).d - sdScene(vec3(p.x, p.y, p.z - EPSILON)).d\n    ));\n}\n\n//=======================================================================================\n// BSDFs\n//=======================================================================================\n\n/**\n * Schlick's fresnel approximation.\n *\n * specularColor: reflectance at normal incidence i.e. F0\n */\nvec3 fresnelSchlick(vec3 specularColor, float dotLH) {\n\tfloat fresnel = pow(1.0 - dotLH, 5.0);\n\treturn specularColor + (1.0 - specularColor) * fresnel;\n}\n\n/**\n * GGX microfacet distribution. [Walter 07]\n */\nfloat distrGGX(float alpha, float dotNH) {\n    if (dotNH == 0.0) return 0.0;\n\tfloat a2 = pow2(alpha);\n\tfloat denom = pow2(dotNH) * (a2 - 1.0) + 1.0;\n\treturn a2 / (PI * pow2(denom));\n}\n\n/**\n * Smith (monodirectional) shadowing-masking approximation for GGX.\n */\nfloat smithG1_GGX(float alpha, float cosTheta) {\n    float a2 = pow2(alpha);\n    float cosTheta2 = pow2(cosTheta);\n    float tanTheta2 = abs(1.0 / cosTheta2 - 1.0);\n    if (isinf(tanTheta2)) return 0.0;\n    return 2.0f / (1.0f + sqrt(1.0 + a2 * tanTheta2));\n}\n\n/**\n * Smith shadowing-masking approximation for GGX.\n */\nfloat smithG_GGX(float alpha, float dotNL, float dotNV) {\n\treturn smithG1_GGX(alpha, dotNL) * smithG1_GGX(alpha, dotNV);\n}\n\n/**\n * BRDF for microfacet model.\n *\n * mid:\t\t\tmaterial index\n * normal:\t\tsurface normal\n * viewDir:\t\tview direction\n * lightDir:\tlight direction\n */\nvec3 brdfSpecular(int mid, vec3 normal, vec3 viewDir, vec3 lightDir) {\n    sMaterial mat = gMaterials[mid];\n    vec3 specularColor = mix(vec3(MIN_REFLECTIVITY), mat.baseColor, mat.metalness);\n\n    float alpha = max(0.01, pow2(mat.roughness));\t// prevent alpha being too small\n\n    vec3 halfDir = normalize(viewDir + lightDir);\n\tfloat dotNL = saturate(dot(normal, lightDir));\n\tfloat dotNV = saturate(dot(normal, viewDir));\n\tfloat dotNH = saturate(dot(normal, halfDir));\n\tfloat dotLH = saturate(dot(lightDir, halfDir));\n\n    if (dotNV == 0.0 || dotNL == 0.0) return vec3(0.0);\n\n\tvec3  F = fresnelSchlick(specularColor, dotLH);\n\tfloat G = smithG_GGX(alpha, dotNL, dotNV);\n\tfloat D = distrGGX(alpha, dotNH);\n\n\treturn F * (G * D) / (4.0 * dotNL * dotNV);\n}\n\n/**\n * BRDF for Lambert diffuse model.\n *\n * mid:\t\t\tmaterial index\n */\nvec3 brdfDiffuse(int mid) {\n    sMaterial mat = gMaterials[mid];\n    vec3 diffuseColor = mat.baseColor * (1.0 - mat.metalness);\n\treturn diffuseColor / PI;\n}\n\n//=======================================================================================\n// Lighting\n//=======================================================================================\n\n/**\n * Calculate the shadow factor of a surface point.\n * ref: https://iquilezles.org/articles/rmshadows\n *\n * p:\t\t\ta surface point in world space\n * lightDir:\tlight direction\n * normal:\t\tsurface normal\n * rayLength:\tlength of the shadow ray\n * k:\t\t\tlager k produces sharper shadows, penumbras are disabled when k is 0\n */\nfloat shadow(vec3 p, vec3 lightDir, vec3 normal, float rayLength, float k) {\n\tsRay ray;\n    ray.o = p;\n    ray.dir = lightDir;\n    ray.tMin = 0.01 / max(abs(dot(lightDir, normal)), 0.05);  // avoid self-shadowing\n    ray.tMax = rayLength;\n\n    float factor = 1.0;\n\n    // ray marching\n    float t = ray.tMin;\n    for (int i = 0; i < SHADOW_RAY_MAX_STEPS; i++) {\n        sSceneRec rec = sdScene(ray.o + t * ray.dir);\n        factor = min(factor, k * rec.d / t);\n        if (rec.d < EPSILON) {\t// in shadow\n            return 0.0;\n        }\n        t += rec.d;\n        if (t >= ray.tMax) {\n            break;\n        }\n    }\n\n    return mix(1.0, factor, float(k > 0.0));\n}\n\n/**\n * Calculate the decay factor of a punctual light.\n * ref: three.js - bsdfs.glsl::punctualLightIntensityToIrradianceFactor\n */\nfloat punctualLightDecay(float dist, float cutoff, float decay, float r0) {\n\tif(decay > 0.0) {\n\t\tfloat distanceFalloff = r0 / max(pow(dist, decay), 0.01);\n\t\tfloat maxDistanceCutoffFactor = pow2(saturate(1.0 - pow4(dist / cutoff)));\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n\t}\n\treturn 1.0;\n}\n\n/**\n * Calculate the irradiance(E) of a point light.\n *\n * p:\t\t\ta surface point in world space\n * normal:\t\tsurface normal\n * lightDir:    output direction from p to light position\n */\nvec3 pointLightIrradiance(vec3 p, vec3 normal, sPointLight light,\n                          out vec3 lightDir) {\n    vec3 l = light.position - p;\n\tfloat dist = length(l);\n\tlightDir = l / dist;\n    float dotNL = saturate(dot(normal, lightDir));\n    vec3 lightColor = light.color * punctualLightDecay(dist, light.range, light.decay, 1.0);\n    float shadowFactor = shadow(p, lightDir, normal, min(dist, SHADOW_RAY_MAX_LENGTH), 16.0);\n\treturn shadowFactor * PI * dotNL * lightColor;\n}\n\n//=======================================================================================\n// Participating Media\n//=======================================================================================\n\n#define SCATTERING\t0.5\n#define EXTINCTION\t0.5\n\n/**\n * Isotropic phase function.\n */\nfloat phaseIsotropic(float cosTheta) {\n\treturn 1.0 / (4.0 * PI);\n}\n\n/**\n * HG phase function.\n */\nfloat phaseHG(float cosTheta, float g) {\n\tfloat tmp = 1.0 + pow2(g) - 2.0 * g * cosTheta;\n\treturn (1.0 - pow2(g)) / (4.0 * PI * tmp * sqrt(tmp));\n}\n\n/**\n * Calculate the transmittance.\n */\nfloat Tr(vec3 a, vec3 dir, float dist) {    \n\t// assuming homogeneous media\n    return exp(-EXTINCTION*dist);\n}\n\n/**\n * Calculate the inscattering from point light.\n */\nvec3 inscatterPointLight(const in sRay ray, vec3 p, float ds,\n                         sPointLight light, out float segmentTr) {\n\tfloat distToLight = length(light.position - p);\n    vec3 lightDir = (light.position - p) / distToLight;\n    \n    float trLight = Tr(p, lightDir, distToLight);\n    float decay = trLight *\n        punctualLightDecay(distToLight, light.range, light.decay, 1.0);\n    \n    segmentTr = exp(-EXTINCTION * ds);\n    \n    // early terminate\n    if (decay < 1e-2)\n        return vec3(0.0);\n    \n    float shadowFactor = shadow(p, lightDir, vec3(0.0), distToLight, 32.0);\n    float phase = phaseHG(dot(-lightDir, -ray.dir), 0.8);\n    vec3 lightColor = light.color * decay;\n    \n    vec3 S = phase * SCATTERING * shadowFactor * lightColor;\n    \n    // should take the Tr inside the segment into account\n    // ref slide 29: http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n    return (S - S * segmentTr) / EXTINCTION;\n}\n\n/**\n * Medium-aware ray marching.\n *\n * inscatter:\taccumulated inscattering along the ray\n */\nbool rayMarchVol(const in sRay ray, out sHit hit, out vec3 inscatter,\n                 out float totalTr,\n                 int maxSteps) {\n    float t = ray.tMin;\n    float ds = VOL_RAY_MARCHING_STEP;\n\n    totalTr = 1.0;\n    \n    for (int i = 0; i < maxSteps; i++) {\n        vec3 p = ray.o + t * ray.dir;\n        sSceneRec rec = sdScene(p);\n        if (rec.d < EPSILON) {\t// hit something\n            hit.p = p;\n            hit.t = t;\n            hit.mid = rec.mid;\n\t\t\treturn true;\n        }\n        \n        // accumulate inscattering\n        float segmentTr;\n        inscatter += totalTr * inscatterPointLight(ray, p, ds, gPointLight0, segmentTr);\n        \n        // accumulate transmittance\n        totalTr *= segmentTr;\n        if (totalTr < 1e-2)\n            return false;\n        \n        // adjust step size if we are close to surface\n        ds = min(rec.d, VOL_RAY_MARCHING_STEP);\n        \n        t += ds;\n        if (t >= ray.tMax) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\n//=======================================================================================\n\n/**\n * Calculate the color of a surface point from some point of view.\n *\n * hp:\t\t\tsurface point to shade\n * viewDir:\t\tview direction i.e. -viewRay.dir\n */\nvec3 lit(sHit hp, vec3 viewDir) {\n    vec3 specular = vec3(0.0);\n    vec3 totalIrradiance = vec3(0.0);\n    vec3 normal = getNormal(hp.p);\n\n    vec3 irradiance = vec3(0.0);\n\n    /* point lights */\n\n    vec3 pointLightDir;\n    irradiance = pointLightIrradiance(hp.p, normal, gPointLight0, pointLightDir);\n    specular += irradiance * brdfSpecular(hp.mid, normal, viewDir, pointLightDir);\n\t\n    totalIrradiance += irradiance;\n    \n    //------------------------------------------------------------------------------------\n\n    vec3 diffuse = totalIrradiance * brdfDiffuse(hp.mid);\n    vec3 surface = diffuse + specular;\n    \n    return surface;\n}\n\n//=======================================================================================\n// Camera\n//=======================================================================================\n\nmat3 viewMatrix(vec3 eye, vec3 target, vec3 up) {\n    vec3 f = normalize(target - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 cameraRay(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = (size.y / 2.0) / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n//=======================================================================================\n\nvoid updateScene() {\n\tgPointLight0.position.x = 4.0 * sin(iTime);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fov = 60.0;\n    vec3 eye = vec3(0.0, 1.0, 5.0);\n    \n    updateScene();\n\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0), vec3(0.0, 1.0, 0.0));\n\n    sRay viewRay;\n    viewRay.o = eye;\n    viewRay.tMax = VIEW_RAY_MAX_LENGTH;\n\n    vec3 finalColor;\n    for (int i = 1; i <= MSAA_COUNT; ++i) {\n        float x = mod(float(i) - 1.0, 4.0);\n        float y = mod(floor(float(i) / 4.0), 4.0);\n        vec2 jitter = hash21(float(i)) / 4.0;\n        jitter.x += x / 4.0;\n        jitter.y += y / 4.0;\n\n        viewRay.dir = viewToWorld * cameraRay(fov, iResolution.xy, fragCoord + jitter);\n\t\tvec3 col, inscatter;\n    \tsHit hit;\n        float totalTr;\n    \tif (rayMarchVol(viewRay, hit, inscatter, totalTr, VIEW_RAY_MAX_STEPS)) {\n\t\t\tvec3 surface = lit(hit, -viewRay.dir);\n            // when in homogeneous media, Tr(eye, hit.p) == totalTr\n            col = inscatter + totalTr * surface;\n    \t}\n        finalColor = mix(finalColor, col, 1.0 / float(i));\n    }\n\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}