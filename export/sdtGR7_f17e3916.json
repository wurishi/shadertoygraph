{"ver":"0.1","info":{"id":"sdtGR7","date":"1629451171","viewed":357,"name":"mushroom field","username":"hikiko","description":"WIP upside down :)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mushrooms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEP 0.08\n#define T (STEP / 2.0)\n#define FOV 45.0\n#define M_PI 3.14159\n#define MAX_DIST 25.0\n#define MAX_STEPS int(MAX_DIST / STEP)\n#define GRAD_DELTA (STEP / 2.0)\n\n#define OBJ_NULL 0\n#define\tOBJ_MUSHROOM_TOP 1\n#define OBJ_MUSHROOM_BOTTOM 2\n#define OBJ_MUSHROOM_STEM 3\n#define OBJ_GROUND 4\n\nvec3 eye_pos = vec3(-5.14, -3.88, -10.46); //cam pos\n\nfloat pnoise(vec2 P, vec2 rep);\nfloat cnoise(vec2 P);\nfloat noised(vec2 P);\nfloat noised3(in vec3 x);\n\nfloat ground_height(vec2 point)\n{\n\treturn noised(point * 0.1) * 3.0;\n//\treturn cnoise(point * 0.1) * 3.0;\n}\n\n/* dist from nearest object */\nfloat calc_dist_mushroom(in vec3 point, out int obj_id)\n{\n\tconst float sph_radius = 1.0;\n\tconst float bigsph_radius = 50.0;\n\n\tconst float sep = 5.6; //dist between 2 mushrooms\n\tconst float hsep = sep / 2.0;\n\tvec2 cell_pt = floor((point.xz + vec2(hsep, hsep)) / sep) * sep;\n\n\tvec2 cell_pt2 = cell_pt * 7.32;\n\tvec2 cell_noise = vec2(noised(cell_pt2 + 3.48),\n\t\t\tnoised(cell_pt2 + 25.72));\n//\tvec2 cell_noise = vec2(cnoise(cell_pt2 + 3.48),\n//\t\t\tcnoise(cell_pt2 + 25.72));\n\tvec3 scale = vec3(1.0, 1.0, 1.0);//vec3(cell_noise.x, cell_noise.y, cell_noise.x) *\n\t//\tvec3(0.4, 0.6, 0.4) + vec3(1.0, 1.0, 1.0);\n\tvec2 xzoffs = cell_noise * (hsep - sph_radius * max(scale.x, scale.z));\n\n\tvec3 p = vec3(mod(point.x + hsep, sep) - hsep, point.y,\n\t\t\tmod(point.z + hsep, sep) - hsep) * scale;\n\tp.x += xzoffs.x;\n\tp.z += xzoffs.y;\n\tp.y -= ground_height(cell_pt - xzoffs);\n\n\tvec3 cap_pt = p * vec3(1.0, 1.5, 1.0);\n\n\tfloat dsph_small = sqrt(dot(cap_pt, cap_pt)) - sph_radius;\n\tvec3 bigsph_center = vec3(0.0, bigsph_radius - 0.2, 0.0);\n\tvec3 dvec = bigsph_center - cap_pt;\n\tfloat dsph_big = sqrt(dot(dvec, dvec)) - bigsph_radius;\n\n\tfloat stem_radius = 0.7;\n\tvec3 stem_center = vec3(0.0, -0.3, 0.0);\n\tfloat stem_scale = clamp((p.y - stem_center.y) / stem_radius + 2.0, 1.0, 3.0) * 1.1;\n\tvec3 stem_pt = p * vec3(stem_scale, 1.0, stem_scale);\n\tdvec = stem_center - stem_pt;\n\tfloat dist_stem = sqrt(dot(dvec, dvec)) - stem_radius;\n\n\tfloat dist;\n\n\tif(dsph_small > dsph_big) {\n\t\tobj_id = OBJ_MUSHROOM_TOP;\n\t\tdist = dsph_small;\n\t} else {\n\t\tobj_id = OBJ_MUSHROOM_BOTTOM;\n\t\tdist = dsph_big;\n\t}\n\n\tif(dist_stem < dist) {\n\t\tobj_id = OBJ_MUSHROOM_STEM;\n\t\tdist = dist_stem;\n\t}\n\n\treturn dist;\n}\n\nfloat calc_dist_ground(in vec3 point, out int obj_id)\n{ \n    obj_id = OBJ_GROUND;\n    float ground_height = -0.9 + ground_height(point.xz); \n\treturn point.y - ground_height;\n}\n\nfloat calc_dist(in vec3 point, out int obj_id)\n{\n\tint mush_id;\n\tfloat mush_dist = calc_dist_mushroom(point, mush_id);\n\n\tint ground_id;\n\tfloat ground_dist = calc_dist_ground(point, ground_id);\n\n\tfloat dist = ground_dist;\n\tobj_id = ground_id;\n\n\tif (mush_dist < dist) {\n\t\tobj_id = mush_id;\n\t\tdist = mush_dist;\n\t}\n\n\treturn dist;\n}\n\nvec3 bg_color(in vec2 uv)\n{\n\t//return vec3(1.0, 0.8, 0.05);\n    return vec3(0.1, 0.45, 0.99);\n}\n\nvec3 mtop_color(in vec3 pos, in vec3 normal)\n{\n\tconst float thres = -0.1;\n\tconst float delta = 0.2;\n\tconst vec3 c = vec3(0.9, 0.0, 0.0);\n\tconst vec3 spotc = vec3(1.0, 1.0, 1.0);\n\tfloat n = noised3(pos * 3.0);\n\n\treturn mix(c, spotc, smoothstep(thres - delta, thres + delta, n));\n}\n\nvec3 obj_color(in vec3 pos, in vec3 normal, in int obj_id)\n{\n\tswitch(obj_id) {\n\tcase OBJ_MUSHROOM_TOP:\n\t\treturn mtop_color(pos, normal);\n\tcase OBJ_MUSHROOM_BOTTOM:\n\t\treturn vec3(0.15, 0.15, 0.3);\n\tcase OBJ_MUSHROOM_STEM:\n\t\treturn vec3(0.0, 0.6, 0.1);\n\tcase OBJ_GROUND:\n\t\treturn vec3(0.5, 0.25, 0.0);\n\tdefault:\n\t\treturn vec3(0.1, 0.1, 0.1);\n\t}\n}\n\nconst vec3 light_pos = vec3(2.0, 1.0, 0.0);\n\nfloat calc_shadow(in vec3 pos, in vec3 rdir, in float max_dist)\n{\n\tvec3 p = pos + rdir * 2.0 * T;\n\tfloat d = 0.0;\n\tfloat dist = max_dist;\n\tint oid;\n\n\twhile(d < max_dist && dist > T) {\n\t\td += STEP;\n\t\tp = p + rdir * STEP;\n\t\tdist = calc_dist(p, oid);\n\t}\n\n\treturn dist <= T ? 0.0 : 1.0;\n}\n\nfloat calc_fog(float dist, float density)\n{\n\tfloat e = density * dist;\n\treturn exp(-(e * e));\n}\n\nvec3 shade(in vec3 pos, in vec3 normal, in int obj_id)\n{\n\tvec3 light_dir = light_pos - pos;\n\tfloat ldist = length(light_dir);\n\tlight_dir = normalize(light_dir);\n\n\tfloat ndotl = max(dot(light_dir, normal), 0.0);\n\n\tfloat s = calc_shadow(pos, light_dir, ldist);\n\n\tfloat fog = calc_fog(length(pos - eye_pos), 0.056);\n\n\tvec3 color = s * ndotl * obj_color(pos, normal, obj_id);\n    vec3 fog_color = bg_color(vec2(0.0, 0.0));\n\treturn mix(fog_color, color, fog);\n}\n\nvec3 calc_normal(in vec3 pos, in float dist)\n{\n\tint tmp;\n\n\tfloat dfdx = calc_dist(pos + vec3(GRAD_DELTA, 0.0, 0.0), tmp) - dist;\n\tfloat dfdy = calc_dist(pos + vec3(0.0, GRAD_DELTA, 0.0), tmp) - dist;\n\tfloat dfdz = calc_dist(pos + vec3(0.0, 0.0, GRAD_DELTA), tmp) - dist;\n\n\treturn normalize(vec3(dfdx, dfdy, dfdz));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\tfloat half_fov = (FOV / 180.0 * M_PI) / 2.0;\n\tfloat viewplane_dist = 1.0 / tan(half_fov); \n\n\tvec3 dir;\n\tdir.x = aspect * (uv.x * 2.0 - 1.0);\n\tdir.y = uv.y * 2.0 - 1.0;\n\tdir.z = viewplane_dist;\n\tdir = normalize(dir);\n\n    float theta;\n    float phi;\n\n    if (iMouse.xy != vec2(0.0)) {\n        theta = -(iMouse.x / iResolution.x) * 8.0;\n        phi = ((iMouse.y / iResolution.y) * 2.0 - 1.0) * M_PI;\n    } else {\n        theta = -8.0;\n        phi = M_PI;\n    }\n\n    mat3 rot_x = mat3(cos(theta), 0.0, sin(theta),\n                      0.0, 1.0, 0.0,\n                      -sin(theta), 0.0, cos(theta));\n    mat3 rot_y = mat3(1.0, 0.0, 0.0,\n                      0.0, cos(phi), -sin(phi),\n                      0.0, sin(phi), cos(phi));\n    mat3 cam_xform = rot_x * rot_y;\n   \n    \n\tdir = mat3(cam_xform) * dir;\n\teye_pos = (cam_xform * vec3(5.0, -1.0, -20.0));\n\n\tvec3 pos = eye_pos;\n\tint obj_id = OBJ_NULL;\n\tfloat dist;\n\n\tfor(int i=0; i<MAX_STEPS; i++) {\n\t\tint id;\n\t\tdist = calc_dist(pos, id);\n\t\tif(dist <= T) {\n\t\t\tobj_id = id;\n\t\t\tbreak;\n\t\t}\n\n\t\tpos += dir * STEP;\n\t}\n\n\tif(obj_id == OBJ_NULL) {\n\t\tfragColor = vec4(bg_color(uv), 1.0);\n\t} else {\n\t\tvec3 normal = calc_normal(pos, dist);\n\t\tfragColor = vec4(shade(pos, normal, obj_id), 1.0);\n\t}\n}\n\n// These noise functions are modifications of these ones\n// from Inigo Quilez: https://www.shadertoy.com/view/XsXfRH\n\nfloat hash(in vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract(p.x*p.y*(p.x+p.y));\n}\n\nfloat noised(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    \n#if 0\n    // quintic interpolation\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec2 du = 30.0*w*w*(w*(w-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = w*w*(3.0-2.0*w);\n    vec2 du = 6.0*w*(1.0-w);\n#endif    \n    \n    \n    float a = hash(p+vec2(0.0,0.0));\n    float b = hash(p+vec2(1.0,0.0));\n    float c = hash(p+vec2(0.0,1.0));\n    float d = hash(p+vec2(1.0,1.0));\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   a - b - c + d;\n\n    return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat hash3(vec3 p)\n{\n    p  = 50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noised3(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n\n    float a = hash3( p+vec3(0,0,0) );\n    float b = hash3( p+vec3(1,0,0) );\n    float c = hash3( p+vec3(0,1,0) );\n    float d = hash3( p+vec3(1,1,0) );\n    float e = hash3( p+vec3(0,0,1) );\n    float f = hash3( p+vec3(1,0,1) );\n    float g = hash3( p+vec3(0,1,1) );\n    float h = hash3( p+vec3(1,1,1) );\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return (-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y\n\t\t\t+ k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z)) / 3.0;\n }\n","name":"Image","description":"","type":"image"}]}