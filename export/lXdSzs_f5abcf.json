{"ver":"0.1","info":{"id":"lXdSzs","date":"1719503635","viewed":181,"name":"nested octahedrons","username":"pb","description":"using log in place of abs in the fractal formula","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","octahedron","log"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Gaussian blur effect\n    vec2 texel = 1.0 / iResolution.xy;\n    vec4 total_color = vec4(0.0);\n\n    // Gaussian kernel from common tab\n    float[] gk1s = float[](\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.023792, 0.094907, 0.150342, 0.094907, 0.023792,\n        0.015019, 0.059912, 0.094907, 0.059912, 0.015019,\n        0.003765, 0.015019, 0.023792, 0.015019, 0.003765\n    );\n\n    // Apply Gaussian blur to the texture from channel 0\n    for (int i = 0; i < 5; i++) {\n        float fi = float(i) - 2.0;\n        for (int j = 0; j < 5; j++) {\n            float fj = float(j) - 2.0;\n            vec4 color = texture(iChannel0, uv + vec2(texel.x * fi, texel.y * fj));\n            total_color += color * gk1s[i * 5 + j];\n        }\n    }\n\n\n    // Output the final color\n    fragColor = total_color;\n}\n\n\n\n   ","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//logic taken from gaz: https://www.shadertoy.com/view/ftKBzt\n//and made more verbose and tweaked\n\n#define rot(x) mat2(cos(x+vec4(0,11,33,0)))\n\n//Rodrigues-Euler axis angle rotation\n#define ROT(p,axis,t) mix(axis*dot(p,axis),p,cos(t))+sin(t)*cross(p,axis)\n\n//formula for creating colors;\n#define H(h)  (  cos( h/2. * vec3(1,2,4) )*.7 + .2 )\n\n//formula for mapping scale factor \n#define M(c)  log(c)\n\n#define R iResolution\n\n\nvoid mainImage( out vec4 O, vec2 U) {\n  \n    O = vec4(0);\n    \n    vec3 c=vec3(0), rd = normalize( vec3(U-.5*R.xy, R.y))*10.;\n    \n    float sc,dotp,totdist=0., t=iTime/2.;\n    \n    for (float i=0.; i<150.; i++) {\n        \n        vec4 p = vec4( rd*totdist, 0.);\n        \n        \n        p.xyz += vec3(0,0,min(-3.,max(-25.,-30.+35.*sin(iTime/2.))));\n        \n        p.xyz = ROT( p.xyz, normalize( vec3(sin(t/5.),cos(t/3.),0)  ),t);\n        sc = 1.;  //scale factor\n           \n        float dd = 6.;\n        //p = mod(p-dd,2.*dd) - dd;  //try this if you like\n        \n        for (float j=0.; j<8.; j++) {\n        \n            p =  log(1.+abs(p)) ;\n            \n            dotp = max(1./dot(p,p),.1);\n            sc *= dotp  ; \n            \n            p *= dotp - .9;\n           \n        }\n         \n        float dist =  abs( length(p)-.6)/sc ;  //funky distance estimate\n        float stepsize = dist/2. + 1e-4;     //distance plus a little extra\n        totdist += stepsize;              //move the distance along rd\n        \n       \n        //accumulate color, fading with distance and iteration count\n        c += mix( vec3(1), H(M(sc)),.7) *.015*  exp(-i*i*stepsize*stepsize*100.);\n    }\n    \n    c = clamp(c,0.,1.);\n    c *= c;\n    \n    O = ( vec4(c,0) );\n    //this one needs some gaussian blur \n               \n}        \n  \n  ","name":"Buffer A","description":"","type":"buffer"}]}