{"ver":"0.1","info":{"id":"Mcd3Dl","date":"1712335296","viewed":126,"name":"Radiant Tiles","username":"incre_ment","description":"First attempt at making a tiling based shader.  Based on a processing sketch I made about 1.5 years ago.  There are three tile types.  Each tile's type and rotation is chosen \"randomly\".  Neighbor checking to get rid of the \"boundary artifacts\".","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tiling","tiles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat PI = 3.14159;\nfloat TAU = 2.*3.14159;\n\n// Simplified line function, thanks FN!\nfloat lineSeg( in vec2 p, in vec2 a, in vec2 b )\n{\n    b -= a; p -= a;\n    return length(p - b* clamp( dot(p,b)/dot(b,b), 0., 1.) );\n}\n\n// Depending on ct and r, draw the appropriate lines\nfloat drawCell(vec2 p, float ctype, float r){\n  if (ctype == 1.){\n    p *= rotation(r);\n    float line1 = lineSeg(p, vec2(-1.,.5), vec2(-.5,1.));\n    float line2 = lineSeg(p, vec2(-1.,-.5), vec2(.5,1.));\n    float line3 = lineSeg(p, vec2(-.5, -1.), vec2(1.,.5));\n    float line4 = lineSeg(p, vec2(.5,-1.), vec2(1.,-.5));\n    return min(min(min(line1,line2),line3),line4);\n  }\n\n\n  if (ctype == 2.){  \n    p *= rotation(r);\n    float line1 = lineSeg(p, vec2(-.5,1.), vec2(.5,1.));\n    float line2 = lineSeg(p, vec2(.5,-1.), vec2(-.5,-1.));\n    float line3 = lineSeg(p, vec2(-1.,.5), vec2(-1.,-.5));\n    float line4 = lineSeg(p, vec2(1.,.5), vec2(1.,-.5));\n    return min(min(min(line1,line2),line3),line4);\n  }\n\n  if (ctype == 3.){\n    p *= rotation(r);\n    float line1 = lineSeg(p, vec2(-1.,.5), vec2(-.5,.5));  \n    float line2 = lineSeg(p, vec2(-.5,.5), vec2(-.5,1.));  \n    float line3 = lineSeg(p, vec2(1.,.5), vec2(.5,.5));\n    float line4 = lineSeg(p, vec2(.5,.5), vec2(.5,1.));\n    float line5 = lineSeg(p, vec2(-1.,-.5), vec2(-.5,-.5));\n    float line6 = lineSeg(p, vec2(-.5,-.5), vec2(-.5,-1));  \n    float line7 = lineSeg(p, vec2(.5,-1.), vec2(.5,-.5));\n    float line8 = lineSeg(p, vec2(.5,-.5), vec2(1.,-.5)); \n    \n    // There's got to be a better way to do this, right?\n    return min(min(min(min(min(min(min(line1, line2),line3),line4),line5),line6),line7),line8);\n  }\n}\n\nfloat rando1(vec2 cid){\n  return fract(342.5*sin(25.+32.322*cid.x)+91.34*sin(5.+81.498*cid.y));\n}\n\nfloat rando2(vec2 cid){\n  return fract(23.3*sin(2.+4.3*cid.x)+19.34+sin(32.+7.243*cid.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.);\n   \n   float tt = fract(.5*iTime);\n   \n   // Maintain the original uv coordinate for line thickness dynamics\n   vec2 uv_0 = uv;\n   \n   // Scale the uv coordinates\n   float scale = 8.;\n   uv *= scale;\n   \n   // Generate cell IDs\n   vec2 cellID = floor(uv);\n   \n   // Shift the coordinates in each cell, -1 to 1 in each direction\n   uv = fract(uv) * 2. - 1.;\n\n   // Line thicknes dynamics\n   float thick = .11 + .06*sin(TAU* (tt - 2.*length(uv_0 - vec2(-1.,1.))));\n   \n   // Neighbor checking\n   float minCell = 1E20;\n   for(float i = -1.; i <= 1.; i++)\n   for(float j = -1.; j <= 1.; j++){\n     float cellType = 1. + floor(3. * rando1(cellID + vec2(i,j)));\n     float rType = (PI/2.) * floor(4.* rando2(cellID + vec2(i,j)));\n     \n     float cellVal = drawCell(uv - 2.*vec2(i,j),cellType,rType);\n     minCell = min(minCell, cellVal);\n   }\n   \n   // Color the coordinate\n   col += thick/pow(minCell,.75);\n \n   fragColor = vec4(col,1.0);\n} ","name":"Image","description":"","type":"image"}]}