{"ver":"0.1","info":{"id":"7lGfDm","date":"1664681030","viewed":205,"name":"MULTIPLE IMPORTANCE SAMPLING","username":"yys_c","description":"将多重重要性采样用于直接光照分量\nThis shader is related to a StackOverflow question I currently asked, so I have to keep it public... \nhttps://computergraphics.stackexchange.com/q/13009/18816\nSorry for the buggy look on some machines and I will try to debug it...","likes":4,"published":1,"flags":32,"usePreview":1,"tags":["v2portpurefloatarray"],"hasliked":0,"parentid":"slGfDh","parentname":"EXPLICIT LIGHT SAMPLING"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord), 0).xyz;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\nconst float TWO_PI = 2.0 * PI;\nconst float INV_PI = 1.0 / PI;\nconst float INV_TWO_PI = 0.5 * INV_PI;\nconst vec3 background = vec3(0.0);\nconst vec3 X = vec3(1, 0, 0);\nconst vec3 Y = vec3(0, 1, 0);\nconst vec3 Z = vec3(0, 0, 1);\n// obj\n#define TRI 0\n#define SPH 1\n#define RECT 2\n#define OBJ_TYPE(x) objectives[x * 2]\n#define OBJ_ID(x) objectives[x * 2 + 1]\n\n// texture\n#define COL 0\n#define IMG 1\n#define TEX_TYPE(x) textures[x * 2]\n#define TEX_ID(x) textures[x * 2 + 1]\n\n// material\n#define LAMBERTIAN 0\n#define GGX_MICROFACET 1\n#define EMISSIVE 2\n#define MAT_TYPE(x) materials[x * 2]\n#define MAT_ID(x) materials[x * 2 + 1]\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// counts\nconst int obj_cnt = 9;\nconst int texture_cnt = 2;\nconst int material_cnt = 8;\n\nstruct ray{\n    vec3 A;\n    vec3 B;\n};\n\nstruct record{\n    float t; \n    vec3 normal;\n    vec3 out_normal; // same side with hit ray\n    bool is_back_face;\n    vec3 pos;\n    int mat_id;\n    int obj_id;\n};\n\nstruct triangle{\n    vec3 p0, p1, p2; // right hand\n    vec3 normal; // flat shading\n    //vec3 n0, n1, n2; \n    //vec2 t0, t1, t2\n    int mat_id;\n};\n\nstruct sphere{\n    vec3 o;\n    float r;\n    int mat_id;\n};\n\nstruct rectangle{\n    vec3 p0, p1, p2, p3;\n    vec3 normal;\n    int mat_id;\n};\n\nstruct lambertian{\n    int diffuse_reflectance_id;\n};\n\nstruct microfacet_ggx{\n    int specular_reflectance_id; // F0\n    float roughness;\n};\n\nstruct emissive{\n    int emit_color_id;\n    float strength;\n};\n\n// objects\ntriangle triangles[1];\nsphere spheres[] = sphere[6](\n    sphere(\n        vec3(-1.25, 0.2, 0.0), 0.2, 2\n    ),\n    sphere(\n        vec3(-.75, 0.2, 0.0), 0.2, 3\n    ),\n    sphere(\n        vec3(-.25, 0.2, 0.0), 0.2, 4\n    ),\n    sphere(\n        vec3(.25, 0.2, 0.0), 0.2, 5\n    ),\n    sphere(\n        vec3(.75, 0.2, 0.0), 0.2, 6\n    ),\n    sphere(\n        vec3(1.25, 0.2, 0.0), 0.2, 7\n    )\n);\n\nrectangle rectangles[] = rectangle[3](\n    rectangle(\n        vec3(0.5, 1.2, -0.5),\n        vec3(0.5, 1.2, 0.5),\n        vec3(-0.5, 1.2, 0.5),\n        vec3(-0.5, 1.2, -0.5),\n        vec3(0, -1, 0),\n        0\n    ),\n    rectangle(\n        vec3(-5, 5, -1.5),\n        vec3(-5, -0.1, -1.5),\n        vec3(5, -0.1, -1.5),\n        vec3(5, 5, -1.5),\n        vec3(0, 0, 1),\n        1\n    ),\n    rectangle(\n        vec3(-5, -0.1, -1.5),\n        vec3(-5, -0.1, 5),\n        vec3(5, -0.1, 5),\n        vec3(5, -0.1, -1.5),\n        vec3(0, 1, 0),\n        1\n    )\n    \n);\n\nint objectives[] = int[obj_cnt * 2](\n    RECT, 0,\n    RECT, 1,\n    RECT, 2,\n    SPH, 0,\n    SPH, 1,\n    SPH, 2,\n    SPH, 3,\n    SPH, 4,\n    SPH, 5\n);\n\nconst int light_cnts = 1;\nint lights[] = int[light_cnts](0);\n\n// textures\nvec3 constant_colors[] = vec3[2](\n    vec3(.8, .8, .8), // light color\n    vec3(0.9, 0.4, 0.3) // object color\n);\n\nint textures[] = int[texture_cnt * 2](\n    COL, 0,\n    COL, 1\n);\n\n// materials\nlambertian lambertian_array[] = lambertian[1](\n    lambertian(0)\n);\n\nemissive emissive_array[] = emissive[1](\n    emissive(0, 3.)\n);\n\nmicrofacet_ggx microfacet_ggx_array[] = microfacet_ggx[6](\n    microfacet_ggx(1, 0.01),\n    microfacet_ggx(1, 0.02),\n    microfacet_ggx(1, 0.04),\n    microfacet_ggx(1, 0.08),\n    microfacet_ggx(1, 0.16),\n    microfacet_ggx(1, 0.32)\n);\n\nint materials[] = int[material_cnt * 2](\n    EMISSIVE, 0,\n    LAMBERTIAN, 0,\n    GGX_MICROFACET, 0,\n    GGX_MICROFACET, 1,\n    GGX_MICROFACET, 2,\n    GGX_MICROFACET, 3,\n    GGX_MICROFACET, 4,\n    GGX_MICROFACET, 5\n);\n\nfloat seed;\n\nfloat rnd() { \n    return fract(sin(seed++)*43758.5453123); \n}\n\nvec3 uniform_hemi(vec2 uv){\n    float z = uv.x;\n    float r = sqrt(max(0.0, 1.0 - z * z));\n    float phi = 2.0 * PI * uv.y;\n    return vec3(r * cos(phi), r * sin(phi), z);\n}\n\nvec2 uniform_disk(vec2 uv){\n    float r = sqrt(uv.x);\n    float theta = 2.0 * PI * uv.y;\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec3 cosine_hemi(vec2 uv){\n    vec2 uv1 = uniform_disk(uv);\n    float z = sqrt(max(0.0, 1.0 - uv1.x * uv1.x - uv1.y * uv1.y));\n    return vec3(uv1, z);\n}\n\nvec4 qmul(vec4 r, vec4 s){\n    vec4 res;\n    res.x=(r[0]*s[0]-r[1]*s[1]-r[2]*s[2]-r[3]*s[3]);\n    res.y=(r[0]*s[1]+r[1]*s[0]-r[2]*s[3]+r[3]*s[2]);\n    res.z=(r[0]*s[2]+r[1]*s[3]+r[2]*s[0]-r[3]*s[1]);\n    res.w=(r[0]*s[3]-r[1]*s[2]+r[2]*s[1]+r[3]*s[0]);\n    return res;\n}\n\nvec3 rotate_vec(vec3 v, vec3 axis, float theta){\n    vec4 q = vec4(cos(theta * 0.5), sin(theta * 0.5) * axis);\n    vec4 q_inv = vec4(q.x, -q.yzw);\n    vec4 p = vec4(0, v);\n    vec4 res = qmul(qmul(q_inv, p),q);\n    return res.yzw;    \n}\n\nvec3 reoriant(vec3 n1, vec3 n2, vec3 x){\n    float dotv = clamp(dot(n1, n2), -1.0, 1.0);\n    float dotv_abs = abs(dotv);\n    if(dotv_abs == 1.0) return dotv * x;\n    vec3 axis = normalize(cross(n1, n2));\n    float theta = acos(dotv);\n    return rotate_vec(x, axis, theta);\n}\n\nvec3 to_gamma(vec3 c){\n    return pow(c, vec3(1.0 / 2.2));\n}\n\nvec3 to_linear(vec3 c){\n    return pow(c, vec3(2.2));\n}\n\nvec3 at(ray r, float t){\n    return r.A + t * r.B;\n}\n\nfloat sqr(float a){\n    return a * a;\n}\n\nvec3 pick_texture(int x){\n    if(TEX_TYPE(x) == COL) return constant_colors[TEX_ID(x)];\n}\n\nfloat ggx_ndf(float a2, float NoH) {\n\tfloat b = ((a2 - 1.0) * NoH * NoH + 1.0);\n\treturn a2 * INV_PI / (b * b);\n}\n\nfloat smith_shadowing_g1(float a2, float NoX) {\n    NoX = max(NoX, 0.0001);\n    float NoX2 = max(NoX * NoX, 0.0001);\n\treturn 2.0 * NoX / (sqrt(a2 * (1.0 - NoX2) + NoX2) + NoX);\n}\n\nfloat fresnel_schlick(float VoH){\n    float t = 1.0 - VoH;\n    float p5 = t * t;\n    p5 *= p5 * t;\n\treturn p5;\n}\n\nvec3 sample_ggx_importance(vec2 uv, float a2){ // sample isotropic H\n    float cosine_theta = sqrt(max(\n        (1. - uv.x) /\n        (uv.x * (a2 - 1.) + 1.)\n    , 0.0001));\n    float sine_theta = sqrt(max(1. - cosine_theta * cosine_theta, 0.0001));\n    float phi = TWO_PI * uv.y;\n    return vec3(sine_theta * cos(phi), sine_theta * sin(phi), cosine_theta);\n}\n\n// ray tracing\nvoid intersect_triangle(ray r, triangle tri, out bool valid, out record rec){\n    const float EPS = 0.000001;\n    vec3 p0 = tri.p0, p1 = tri.p1, p2 = tri.p2;\n    vec3 B = r.B;\n    vec3 A = r.A;\n    vec3 E1 = p1 - p0;\n    vec3 E2 = p2 - p0;\n    vec3 S = A - p0;\n    vec3 S1 = cross(B,E2);\n    vec3 S2 = cross(S,E1);\n    float t = dot(S2,E2) / dot(S1,E1);\n    float b1 = dot(S1,S) / dot(S1,E1);\n    float b2 = dot(S2,B) / dot(S1, E1);\n    if (t < EPS || b1 < EPS || b2 < EPS || b1 + b2 - 1.0 > EPS) return;\n    valid = true;\n    rec.t = t;\n    rec.pos = at(r, rec.t);\n    rec.normal = tri.normal;\n    rec.out_normal = rec.normal;\n    rec.is_back_face = false;\n    if(dot(-r.B, rec.normal) < 0.){\n        rec.out_normal *= -1.;\n        rec.is_back_face = true;\n    }\n    rec.mat_id = tri.mat_id;\n}\n\nbool solve_quadratic(float A, float B, float C, out float t0, out float t1){\n    float discrim = B*B-4.0*A*C;\n    if ( discrim < 0.0 )\n            return false;\n    float rootDiscrim = sqrt(discrim);\n    float Q = (B > 0.0) ? -0.5 * (B + rootDiscrim) : -0.5 * (B - rootDiscrim); \n    float t_0 = Q / A; \n    float t_1 = C / Q;\n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    return true;\n}\n\nvoid intersect_sphere(ray r, sphere sph, out bool valid, out record rec){\n    const float EPS = 0.0001;\n\tfloat t0, t1, t = -1.0;\n\tvec3 L = r.A - sph.o;\n\tfloat a = dot(r.B, r.B);\n\tfloat b = 2.0 * dot(r.B, L);\n\tfloat c = dot(L, L) - (sph.r * sph.r);\n\tif (!solve_quadratic(a, b, c, t0, t1)) return;\n\tif (t1 > EPS)\n        t = t1;\n\tif (t0 >= EPS)\n\t\tt = t0;\n    if(t != -1.){\n        valid = true;\n        rec.t = t;\n        rec.pos = at(r, rec.t);\n        rec.normal = normalize(rec.pos - sph.o);\n        rec.out_normal = rec.normal;\n        rec.is_back_face = false;\n        if(dot(-r.B, rec.normal) < 0.){\n            rec.out_normal *= -1.;\n            rec.is_back_face = true;\n        }\n        rec.mat_id = sph.mat_id;\n    }\n}\n\nvoid intersect_rectangle(ray r, rectangle rect, out bool valid, out record rec){\n    triangle tri1 = triangle(\n        rect.p0, rect.p1, rect.p2,\n        rect.normal,\n        rect.mat_id\n    );\n    triangle tri2 = triangle(\n        rect.p0, rect.p2, rect.p3,\n        rect.normal,\n        rect.mat_id\n    );\n    intersect_triangle(r, tri1, valid, rec);\n    if(valid) return;\n    intersect_triangle(r, tri2, valid, rec);\n}\n\nvoid intersect(ray r, int i, out bool valid, out record rec){\n    int type = OBJ_TYPE(i);\n    int id = OBJ_ID(i);\n    if(type == TRI)\n        intersect_triangle(r, triangles[id], valid, rec);\n    else if(type == SPH)\n        intersect_sphere(r, spheres[id], valid, rec);\n    else if(type == RECT)\n        intersect_rectangle(r, rectangles[id], valid, rec);\n}\n\nvoid hit(ray r, out record rec, out bool valid){\n    float minv = 0.0001, maxv = 1e18;\n    valid = false;\n    for(int i = 0; i < obj_cnt; i ++){\n        bool flag = false;\n        record temp;\n        intersect(r, i, flag, temp);\n        if(flag && temp.t >= minv && temp.t <= maxv){\n            temp.obj_id = i;\n            rec = temp;\n            maxv = rec.t;\n            valid = true;\n        }\n    }\n}\n\nbool same_hemi(const in vec3 a, const in vec3 b){\n    return a.z > 0. && b.z > 0.;\n}\n\nvec3 eval(const in vec3 wi, const in vec3 wo, const in record rec){\n    int type = MAT_TYPE(rec.mat_id);\n    int id = MAT_ID(rec.mat_id);\n    vec3 n = rec.out_normal;\n    vec3 wo_local = reoriant(n, Z, wo);\n    vec3 wi_local = reoriant(n, Z, wi);\n    if(type == LAMBERTIAN){ // cosine weighed sample\n        if(!same_hemi(wi_local, wo_local)) return vec3(0);\n        return pick_texture(lambertian_array[id].diffuse_reflectance_id) * INV_PI;\n    }else if(type == GGX_MICROFACET){\n        float a = microfacet_ggx_array[id].roughness;\n        vec3 specular_reflectance = pick_texture(microfacet_ggx_array[id].specular_reflectance_id);\n        float a2 = a * a;\n        vec3 h_local = normalize(wi_local + wo_local);\n        if(!same_hemi(wi_local, wo_local)) return vec3(0);\n        float VoH = saturate(dot(wo_local, h_local));\n        float NoH = saturate(h_local.z);\n        float NoL = saturate(wi_local.z);\n        float NoV = saturate(wo_local.z);\n        float D = ggx_ndf(a2, NoH);\n        vec3 F = mix(specular_reflectance, vec3(1.0), fresnel_schlick(VoH));\n        float G2 = smith_shadowing_g1(a2, NoL) * smith_shadowing_g1(a2, NoV);\n        return G2 * F * D / max(4. * NoV * NoL, 0.0001);\n    }\n}\n\nfloat get_pdf(const in vec3 wi, const in vec3 wo, const in record rec){\n    int type = MAT_TYPE(rec.mat_id);\n    int id = MAT_ID(rec.mat_id);\n    vec3 n = rec.out_normal;\n    vec3 wo_local = reoriant(n, Z, wo);\n    vec3 wi_local = reoriant(n, Z, wi);\n    if(type == LAMBERTIAN){ // cosine weighed sample\n        if(!same_hemi(wi_local, wo_local)) return 0.0001;\n        return max(saturate(wi_local.z) * INV_PI, 0.0001);\n    }else if(type == GGX_MICROFACET){\n        float a = microfacet_ggx_array[id].roughness;\n        vec3 specular_reflectance = pick_texture(microfacet_ggx_array[id].specular_reflectance_id);\n        float a2 = a * a;\n        vec3 h_local = normalize(wi_local + wo_local);\n        if(!same_hemi(wi_local, wo_local)) return 0.0001;\n        float VoH = saturate(dot(wo_local, h_local));\n        float NoH = saturate(h_local.z);\n        float NoL = saturate(wi_local.z);\n        float NoV = saturate(wo_local.z);\n        float D = ggx_ndf(a2, NoH);\n        return max(D * NoH / max(4. * VoH, 0.0001), 0.0001);\n    }\n}\n\nbool sample_brdf(out vec3 wi, out vec3 weight, const in vec3 wo, const in record rec){\n    int type = MAT_TYPE(rec.mat_id);\n    int id = MAT_ID(rec.mat_id);\n    vec3 n = rec.out_normal;\n    vec3 wo_local = reoriant(n, Z, wo);\n    if(type == LAMBERTIAN){ // cosine weighed sample\n        vec3 wi_local = cosine_hemi(vec2(rnd(), rnd()));\n        if(!same_hemi(wi_local, wo_local)) return false;\n        weight = pick_texture(lambertian_array[id].diffuse_reflectance_id);\n        wi = reoriant(Z, n, wi_local);\n    }else if(type == GGX_MICROFACET){\n        float a = microfacet_ggx_array[id].roughness;\n        vec3 specular_reflectance = pick_texture(microfacet_ggx_array[id].specular_reflectance_id);\n        float a2 = a * a;\n        vec3 h_local = sample_ggx_importance(vec2(rnd(), rnd()), a2);\n        vec3 wi_local = reflect(-wo_local, h_local);\n        if(!same_hemi(wi_local, wo_local)) return false;\n        float VoH = saturate(dot(wo_local, h_local));\n        float NoH = saturate(h_local.z);\n        float NoL = saturate(wi_local.z);\n        float NoV = saturate(wo_local.z);\n        vec3 F = mix(specular_reflectance, vec3(1.0), fresnel_schlick(VoH));\n        float G2 = smith_shadowing_g1(a2, NoL) * smith_shadowing_g1(a2, NoV);\n        if(NoH == 0.0 || NoV == 0.0) weight = vec3(0); \n        weight = G2 * F * VoH / (NoV * NoH);\n        wi = reoriant(Z, n, wi_local);\n    }\n    return true;\n}\n\nbool is_visible(const in vec3 start_pos, const in vec3 dir, const in vec3 n){\n    ray r = ray(start_pos, dir);\n    record rec;\n    bool valid;\n    hit(r, rec, valid);\n    if(valid && (abs(rec.t - 1.) < 0.0001) && !rec.is_back_face && dot(dir, n) > 0.)\n        return true;\n    return false;\n}\n\nvec3 light_intensity(int mat_id){\n    int texture_id = emissive_array[MAT_ID(mat_id)].emit_color_id;\n    float strength = emissive_array[MAT_ID(mat_id)].strength;\n    return pick_texture(texture_id) * strength;\n}\n\nfloat light_pdf(int light_id){\n    if(OBJ_TYPE(light_id) == RECT){\n        rectangle rect = rectangles[OBJ_ID(light_id)];\n        vec3 u = rect.p1 - rect.p0;\n        vec3 v = rect.p3 - rect.p0;\n        return 1. / (length(u) * length(v)) / float(light_cnts);\n    }\n    return 0.;\n}\n\nvoid sample_from_light(out vec3 p, out vec3 n, out float pdf, out vec3 Li){\n    int idx = int(rnd() * float(light_cnts - 1));\n    int light_id = lights[idx];\n    if(OBJ_TYPE(light_id) == RECT){\n        rectangle rect = rectangles[OBJ_ID(light_id)];\n        vec3 u = rect.p1 - rect.p0;\n        vec3 v = rect.p3 - rect.p0;\n        p = rnd() * u + rnd() * v + rect.p0;\n        pdf = 1. / (length(u) * length(v)) / float(light_cnts);\n        n = rect.normal;\n        Li = light_intensity(rect.mat_id);\n    }\n}\n\nfloat BalanceHeuristic(float nf, float fPdf, float ng, float gPdf) {\n    return (nf * fPdf) / (nf * fPdf + ng * gPdf);\n}\n\nfloat PowerHeuristic(float nf, float fPdf, float ng, float gPdf) {\n    float f = nf * fPdf, g = ng * gPdf;\n    return (f * f) / (f * f + g * g);\n}\n\nbool direct_lighting_MIS(out vec3 wi, out vec3 weight, out vec3 L, const in vec3 wo, const in record rec){\n    vec3 n = rec.out_normal;\n    vec3 pt_on_obj = rec.pos;\n    vec3 pt_on_lit;\n    vec3 lit_normal;\n    float lit_pdf;\n    vec3 Li;\n    sample_from_light(pt_on_lit, lit_normal, lit_pdf, Li);\n    vec3 dir = pt_on_lit - pt_on_obj;\n    float dist = length(dir);\n    wi = normalize(dir);\n    L = vec3(0);\n    if(is_visible(pt_on_obj, dir, n) && lit_pdf > 0.){\n        float brdf_pdf = get_pdf(wi, wo, rec);\n        float lit_pdf_sa = lit_pdf * dist * dist / dot(lit_normal, -wi);\n        L += eval(wi, wo, rec) * Li * dot(n, wi) / lit_pdf_sa * \n             PowerHeuristic(1., lit_pdf_sa, 1., brdf_pdf);\n    }\n    \n    if(sample_brdf(wi, weight, wo, rec)){\n        float brdf_pdf = get_pdf(wi, wo, rec);\n        ray r_t = ray(rec.pos, wi);\n        record rec_t;\n        bool valid;\n        hit(r_t, rec_t, valid);\n        float dist = length(at(r_t, rec_t.t) - r_t.A);\n        if(valid){\n            for(int i = 0; i < light_cnts; i ++){\n                if(rec_t.obj_id == lights[i] && !rec_t.is_back_face){\n                    lit_pdf = light_pdf(lights[i]);\n                    Li = light_intensity(rec_t.mat_id);\n                    float lit_pdf_sa = lit_pdf * dist * dist / dot(rec_t.normal, -wi);\n                    //float brdf_pdf_area = brdf_pdf * dot(rec_t.normal, -wi) / (dist * dist);\n                    L += eval(wi, wo, rec) * Li * dot(n, wi) / brdf_pdf *\n                         PowerHeuristic(1., brdf_pdf, 1., lit_pdf_sa);\n                }\n            }\n        }\n        return true;\n    }\n    return false;\n}\n\nvec3 trace(ray r, int max_depth){\n    vec3 Lo = vec3(0), Ld;\n    vec3 throughput = vec3(1);\n    record rec;\n    bool valid = false;\n    vec3 weight = vec3(0);\n    int depth = 0;\n    vec3 wi, wo;\n    \n    while(depth < max_depth){\n        hit(r, rec, valid);\n        if(!valid){\n            Lo += throughput * background;\n            break;\n        }\n        if(MAT_TYPE(rec.mat_id) == EMISSIVE){\n            if(rec.is_back_face || depth > 0) break;\n            int texture_id = emissive_array[MAT_ID(rec.mat_id)].emit_color_id;\n            float strength = emissive_array[MAT_ID(rec.mat_id)].strength;\n            Lo += throughput * pick_texture(texture_id) * strength;\n            break;\n        }\n        wo = -normalize(r.B);\n        bool flag = direct_lighting_MIS(wi, weight, Ld, wo, rec);\n        Lo += Ld * throughput;\n        if(flag){\n            throughput *= weight;\n            r = ray(rec.pos, wi);\n            depth ++;\n        }else{\n            break;\n        }\n    }\n    return Lo;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int spp = 8;\n// camera\nvec3 cam_pos = vec3(0, 0.5, 2.5); // CPU->GPU\nvec3 right = vec3(1, 0, 0), up = vec3(0, 1, 0); // CPU->GPU\nvec3 dir = normalize(vec3(0, 0, 1)); // CPU\nvec3 left_lower_corner; // CPU->GPU\nfloat aspect_ratio;\nfloat fov = radians(45.); // CPU\nfloat plane_width, plane_height; // CPU\nray get_ray(vec2 uv){ \n    vec3 target;\n    target = left_lower_corner + \n             plane_width * uv.x * right + \n             plane_height * uv.y * up;\n    return ray(cam_pos, target - cam_pos);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    seed = iTime + fragCoord.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    aspect_ratio = iResolution.x / iResolution.y; \n    plane_height = 2.0*tan(fov / 2.0); \n    plane_width = aspect_ratio * plane_height; \n    left_lower_corner = -plane_width / 2.0 * right + (-plane_height / 2.0) * up - dir + cam_pos;\n\n    vec3 color = vec3(0, 0 ,0);\n    for(int i = 0; i < spp; i ++){\n        vec2 uv = (fragCoord + vec2(rnd(), rnd()) - 0.5f)/iResolution.xy;\n        ray r = get_ray(uv);\n        color += trace(r, 20);\n    }\n    if(isnan(color.x) || isnan(color.y) || isnan(color.z)) color = vec3(0, 1000, 1000);\n    if(isinf(color.x) || isinf(color.y) || isinf(color.z)) color = vec3(0, 1000, 1000);\n    color /= float(spp);\n    //if(color[0] == color[1] && color[1] == color[2] && color[0] == 0.0) color[0] = 1.0;\n    //if(isnan(color.x) || isnan(color.y) || isnan(color.z)) color = vec3(10000, 1000, 1000);\n    //if(isinf(color.x) || isinf(color.y) || isinf(color.z)) color = vec3(1000, 0, 1000);\n    //if(color.x < 0. || color.y < 0. || color.z < 0.) color = vec3(0, 1000, 1000);\n    //if(color.x == color.y && color.y == color.z && color.z == 0.) color = vec3(1, 1, 0);\n    //color = clamp(color, 0.0, 1.0);\n    // https://www.shadertoy.com/view/tddSz4\n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float w = prev.w + 1.0;\n    color = color + to_linear(prev.xyz) * prev.w;\n    color /= w;\n    fragColor = vec4(to_gamma(color), w);\n    //fragColor = vec4(color, 1.0);\n    //fragColor = vec4(fragCoord / iResolution.xy, 0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}