{"ver":"0.1","info":{"id":"Md2fRR","date":"1499206116","viewed":3375,"name":"Infinity Matrix","username":"KilledByAPixel","description":"Endless non repeating pixel fractal zoom made to feel like flying through binary code.","likes":76,"published":1,"flags":32,"usePreview":0,"tags":["fractal","zoom","pixel","matrix","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Infinity Matrix - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float blurSize = 1.0/512.0;\nconst float blurIntensity = 0.2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = fragCoord.xy/iResolution.xy;\n   vec4 sum = vec4(0);\n   sum += texture(iChannel0, vec2(uv.x - blurSize, uv.y)) * 0.5;\n   sum += texture(iChannel0, vec2(uv.x + blurSize, uv.y)) * 0.5;\n   sum += texture(iChannel0, vec2(uv.x, uv.y - blurSize)) * 0.5;\n   sum += texture(iChannel0, vec2(uv.x, uv.y + blurSize)) * 0.5;\n   sum += texture(iChannel0, vec2(uv.x - blurSize, uv.y - blurSize)) * 0.3;\n   sum += texture(iChannel0, vec2(uv.x + blurSize, uv.y - blurSize)) * 0.3;\n   sum += texture(iChannel0, vec2(uv.x - blurSize, uv.y + blurSize)) * 0.3;\n   sum += texture(iChannel0, vec2(uv.x + blurSize, uv.y + blurSize)) * 0.3;    \n\n   fragColor = blurIntensity*sum + texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////////////////////////////////////\n// Infinity Matrix - Copyright 2017 Frank Force\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////\n\nconst float zoomSpeed\t\t\t= 1.0;\t// how fast to zoom (negative to zoom out)\nconst float zoomScale\t\t\t= 0.1;\t// how much to multiply overall zoom (closer to zero zooms in)\nconst int recursionCount\t\t= 5;\t// how deep to recurse\nconst float recursionFadeDepth\t= 3.0;\t// how deep to fade out\nconst int glyphSize\t\t\t\t= 5;\t// width & height of glyph in pixels\nconst int glyphCount\t\t\t= 2;\t// how many glyphs total\nconst float glyphMargin\t\t\t= 0.5;\t// how much to center the glyph in each pixel\nconst int glyphs[glyphSize*glyphCount] = int[]\n(\t// glyph sheet\n\t0x01110, 0x01110, \n\t0x11011, 0x11110,\n\t0x11011, 0x01110, \n\t0x11011, 0x01110,\n\t0x01110, 0x11111\n);\t//  0        1\n\n//////////////////////////////////////////////////////////////////////////////////\n// Precached values and math\n\nconst float glyphSizeF = float(glyphSize) + 2.0*glyphMargin;\nconst float glyphSizeLog = log(glyphSizeF);\nconst int powTableCount = 10;\nconst float gsfi = 1.0 / glyphSizeF;\nconst float powTable[powTableCount] = float[]( 1.0, gsfi, pow(gsfi,2.0), pow(gsfi,3.0), pow(gsfi,4.0), pow(gsfi,5.0), pow(gsfi,6.0), pow(gsfi,7.0), pow(gsfi,8.0), pow(gsfi,9.0));\nconst float e = 2.718281828459;\nconst float pi = 3.14159265359;\n\nfloat RandFloat(int i) { return (fract(sin(float(i)) * 43758.5453)); }\nint RandInt(int i) { return int(100000.0*RandFloat(i)); }\n\nvec3 HsvToRgb(vec3 c) \n{\n    float s = c.y * c.z;\n    float s_n = c.z - s * .5;\n    return vec3(s_n) + vec3(s) * cos(2.0 * pi * (c.x + vec3(1.0, 0.6666, .3333)));\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n// Color and image manipulation\n\nfloat GetRecursionFade(int r, float timePercent)\n{\n    if (r > recursionCount)\n        return timePercent;\n    \n    // fade in and out recusion\n    float rt = max(float(r) - timePercent - recursionFadeDepth, 0.0);\n    float rc = float(recursionCount) - recursionFadeDepth;\n    return rt / rc;\n}\n\nvec3 InitPixelColor() { return vec3(0); }\nvec3 CombinePixelColor(vec3 color, float timePercent, int i, int r, vec2 pos, ivec2 glyphPos, ivec2 glyphPosLast)\n{\n    vec3 myColor = vec3(0.6);\n        \n    myColor.r *= mix(0.0, 0.7, RandFloat(i + r + 11*glyphPosLast.x + 13*glyphPosLast.y));\n    myColor.b *= mix(0.0, 0.7, RandFloat(i + r + 17*glyphPosLast.x + 19*glyphPosLast.y));\n    myColor *= mix(0.3, 1.0, RandFloat(i + r + 31*glyphPosLast.x + 37*glyphPosLast.y));\n\n    // combine with my color\n    float f = GetRecursionFade(r, timePercent);\n    color += myColor*f;\n    return color;\n}\n\nvec3 FinishPixel(vec3 color, vec2 uv)\n{\n    // brighten\n    color += vec3(0.07);\n    \n    // noise\n\tvec3 noise = vec3(1.0);\t\n    noise += mix( -0.2, 0.4, texture(iChannel0, 0.00111*uv*iResolution.y + vec2(-23.3*iTime, 37.5*iTime)).x);\n    noise += mix( -0.2, 0.4, texture(iChannel0, 0.00182*uv*iResolution.y + vec2(13.1*iTime, -20.1*iTime)).x);\n\tcolor *= noise;\n    \n    // make green\n    color *= vec3(0.8, 1.0, 0.8);\n    return color;\n}\n\nvec2 InitUV(vec2 uv)\n{\n\t// wave\n\tuv.x += 0.1*sin(2.0*uv.y + 1.0*iTime);\n\tuv.y += 0.1*sin(2.0*uv.x + 0.8*iTime);\n    return uv;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////\n// Fractal functions\n\nint GetFocusGlyph(int i) { return RandInt(i) % glyphCount; }\nint GetGlyphPixelRow(int y, int g) { return glyphs[g + (glyphSize - 1 - y)*glyphCount]; }\nint GetGlyphPixel(ivec2 pos, int g)\n{\n\tif (pos.x >= glyphSize || pos.y >= glyphSize)\n\t\treturn 0;\n\n    // pull glyph out of hex\n\tint glyphRow = GetGlyphPixelRow(pos.y, g);\n    return 1 & (glyphRow >> (glyphSize - 1 - pos.x) * 4);\n}\n\nivec2 focusList[max(powTableCount, recursionCount) + 2];\nivec2 GetFocusPos(int i) { return focusList[i+2]; }\n\nivec2 CalculateFocusPos(int iterations)\n{\n    // count valid pixels in glyph\n    int g = GetFocusGlyph(iterations-1);\n    int c = 18;\t// OPT - 1 and 0 glyps both have 18 pixels\n    /*int c = 0;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n            c += (1 & (glyphRow >> 4*x));\n    }*/\n\n    // find a random valid pixel in glyph\n    c -= RandInt(iterations) % c;\n    for (int y = glyphCount*(glyphSize - 1); y >= 0; y -= glyphCount)\n    {\n\t\tint glyphRow = glyphs[g + y];\n        for (int x = 0; x < glyphSize; ++x)\n        {\n            c -= (1 & (glyphRow >> 4*x));\n            if (c == 0)\n                return ivec2(glyphSize - 1 - x, glyphSize - 1 - y/glyphCount);\n        }\n    }\n}\n  \nint GetGlyph(int iterations, ivec2 glyphPos, int glyphLast, ivec2 glyphPosLast, ivec2 focusPos)\n{ \n    if (glyphPos == focusPos)\n        return GetFocusGlyph(iterations); // inject correct glyph     \n            \n    int seed = iterations + glyphPos.x * 313 + glyphPos.y * 411 + glyphPosLast.x * 557 + glyphPosLast.y * 121;\n    return RandInt(seed) % glyphCount; \n}\n      \n// get color of pos, where pos is 0-1 point in the glyph\nvec3 GetPixelFractal(vec2 pos, int iterations, float timePercent)\n{\n    int glyphLast = GetFocusGlyph(iterations-1);\n\tivec2 glyphPosLast = GetFocusPos(-2);\n\tivec2 glyphPos =     GetFocusPos(-1);\n    \n\tbool isFocus = true;\n    ivec2 focusPos = glyphPos;\n    \n\tvec3 color = InitPixelColor();\n\tfor (int r = 0; r <= recursionCount + 1; ++r)\n\t{\n        color = CombinePixelColor(color, timePercent, iterations, r, pos, glyphPos, glyphPosLast);\n        \n        //if (r == 1 && glyphPos == GetFocusPos(r-1))\n\t    //    color.z = 1.0; // debug - show focus\n        \n        if (r > recursionCount)\n\t\t\treturn color;\n           \n        // update pos\n        pos -= vec2(glyphMargin*gsfi);\n        pos *= glyphSizeF;\n\n        // get glyph and pos within that glyph\n        glyphPosLast = glyphPos;\n        glyphPos = ivec2(pos);\n\n        // check pixel\n        int glyphValue = GetGlyphPixel(glyphPos, glyphLast);\n\t\tif (glyphValue == 0 || pos.x < 0.0 || pos.y < 0.0)\n\t\t\treturn color;\n        \n        // next glyph\n\t\tpos -= vec2(floor(pos));\n        focusPos = isFocus? GetFocusPos(r) : ivec2(-10);\n        glyphLast = GetGlyph(iterations + r, glyphPos, glyphLast, glyphPosLast, focusPos);\n        isFocus = isFocus && (glyphPos == focusPos);\n\t}\n}\n \n//////////////////////////////////////////////////////////////////////////////////\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// use square aspect ratio\n\tvec2 uv = fragCoord;\n\tuv = fragCoord / iResolution.y;\n\tuv -= vec2(0.5*iResolution.x / iResolution.y, 0.5);\n    uv = InitUV(uv);\n\t\n\t// get time \n\tfloat timePercent = iTime*zoomSpeed;\n\tint iterations = int(floor(timePercent));\n\ttimePercent -= float(iterations);\n\t\n\t// update zoom, apply pow to make rate constant\n\tfloat zoom = pow(e, -glyphSizeLog*timePercent);\n\tzoom *= zoomScale;\n    \n    // cache focus positions\n    for(int i = 0; i  < powTableCount + 2; ++i)\n      focusList[i] = CalculateFocusPos(iterations+i-2);\n    \n\t// get offset\n\tvec2 offset = vec2(0);\n\tfor (int i = 0; i < powTableCount; ++i)\n\t\toffset += ((vec2(GetFocusPos(i)) + vec2(glyphMargin)) * gsfi) * powTable[i];\n    \n\t// apply zoom & offset\n    vec2 uvFractal = uv * zoom + offset;\n\t\n\t// check pixel recursion depth\n\tvec3 pixelFractalColor = GetPixelFractal(uvFractal, iterations, timePercent);\n    pixelFractalColor = FinishPixel(pixelFractalColor, uv);\n    \n\t// apply final color\n\tfragColor = vec4(pixelFractalColor, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}