{"ver":"0.1","info":{"id":"clSyDw","date":"1691851134","viewed":45,"name":"Sketch #5: Morphing Tiles","username":"MOONtyzoo","description":"Recreation of a pattern from here: https://thebookofshaders.com/09/\n\nI was recreating this pattern when I noticed that there was a really cool effect/symmetry involving the size of the diamond, so I turned that into the basis of the animation.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"I created this morphing effect by utilizing a pattern involving the size of the diamonds when tiled.\n    You can more easily see it by toggling the 'SIMPLE' macro below. As the diamond\n    expands past the boundary of the tile, it connects with the edges of diamonds from adjacent tiles\n    and creates another diamond in between them.\n    \n    The main issue I had with this is that the borders between the diamonds don't have the same effect\n    so I kind of had to force them in.\"\n*/\n\n//#define SIMPLE\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   /*\n       Divide space into tiles\n   */\n   vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n   uv = fract(uv*3.0) - 0.5;\n   uv = abs(uv);\n   \n   // Diagonal distance?\n   float d = uv.x + uv.y;\n   \n   /*\n       Draw the borders\n      \n       \"I feel like I didn't create the gaps in the best way possible since I had to add them on \n       in a piecemeal fashion (see how the 'border' variable is just an addition of the squares and gaps).\n       and additionally I had to account for two different scenarios (size < 0.5 and size > 0.5) so\n       the functions became pretty complicated.\n      \n       If anybody knows how to achieve the same effect in a more simple way, I would appreciate some advice.\"\n   */\n   float size = 0.3*cos(0.8*iTime)+0.5;\n   float gapLength = abs(size-0.5);\n   \n   float diamond = smoothstep(0.04, 0.0, abs(size-d));\n   float gapH = step(0.5, size)*step(uv.y, gapLength)*smoothstep(0.03, 0.0, abs(0.5-uv.x))\n                + step(size, 0.5)*step(0.5-gapLength, uv.x)*smoothstep(0.03, 0.0, abs(uv.y));       \n   float gapV = step(0.5, size)*step(uv.x, gapLength)*smoothstep(0.03, 0.0, abs(0.5-uv.y))\n                + step(size, 0.5)*step(0.5-gapLength, uv.y)*smoothstep(0.03, 0.0, abs(uv.x));\n   \n   float border = diamond + gapH + gapV;\n   \n   /*\n       Coloring\n   */\n   vec3 HSV;\n   HSV[0] = 0.0;\n   HSV[1] = 0.0;\n   HSV[2] = border;\n   \n   #ifdef SIMPLE\n   HSV[2] = smoothstep(size, size + 0.02, d);\n   #endif\n   \n   fragColor = vec4(hsv2rgb(HSV), 1.0);\n}","name":"Image","description":"","type":"image"}]}