{"ver":"0.1","info":{"id":"XcVcRy","date":"1732035767","viewed":84,"name":"莫比乌斯变换","username":"YB","description":"从蓝紫示例程序 [url]https://ddzeb.com/lands#demo-109[/url] 转译过来，我们在研究莫比乌斯变换的逆变换时发现的一种简单情况。关于莫比乌斯变换及其渲染，参见博客：[url]https://ddzeb.com/blog/post#65/mobius-transformation[/url]","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","mobius","pattern","inversemobius"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n  DDZEB 原创作品，版权所有\n\n  Copyright (C) 2024, DDZEB.COM\n  \n\n  ported from https://ddzeb.com/lands#demo-109\n  \n  i was playing with the inverse mobius transformation of:\n  \n           f(z) = (z + b) / (z + d)\n  \n  and got a special case of mobius transformation:\n  \n           f(z) = k / z + m\n  \n  where k and m are complex number parameters.\n  the formula is quite simple. with a little math, we can\n  find the two singularity points, zero and -(k / m).\n\n*/\n\nconst float PI = 3.14159265358979323846;\n\nvec2 cmpxInv(vec2 z) {\n  return vec2(z.x, -z.y) / max(1e-20, dot(z, z));\n}\n\nfloat patCheckboard(vec2 p) { // smoothchecker, suggested by Fabrice\n  vec2 s = sin(PI * p); \n  float m = s.x * s.y;\n  return clamp(.5 - m / fwidth(m), 0., 1.);\n}\n\nfloat patStrip(vec2 p) {\n  return abs(fract(p.x) * 2.0 - 1.0);\n}\n\nfloat render(vec2 p) {\n  p *= 12.0;\n\n  // transform parameters\n  // and min distance to singularity points\n  float k = 8.0;\n  float m = 2.0 * cos(iTime * 0.2);\n  float d = min(length(p), length(p - vec2(-(k / m), 0.0)));\n\n  // mobius transform\n  p = cmpxInv(p) * k + vec2(m, 0.0);\n\n  // log-polar transform\n  p = vec2(atan(p.y, p.x), log(length(p))) / PI;\n\n  // phasing\n  p += vec2(0.1,  0.04) * iTime;\n  \n  // skew in polar space to make a spiral\n  p *= mat2(1.0, 1.5, -1.5, 1.0);\n\n  // render the pattern\n  float v = patStrip(p * 8.0) * patCheckboard(p * 32.0);\n  \n  // darken the singularity points, cheap extra anti-aliasing\n  return mix(v, 0.0, 1.0 / (1.0 + d * 0.1 + d * d * 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // uvx2\n  vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.x;\n\n  // anti-aliasing\n  #define SIZE 2\n  float col = 0.0;\n  float sub = 2.0 / iResolution.x / float(SIZE);\n  for (int i = 0; i < SIZE; i++) {\n  for (int j = 0; j < SIZE; j++) {\n    col += render(uv + vec2(i, j) * sub);\n  }}\n  col /= float((SIZE) * (SIZE));\n\n\n  // output to screen\n  fragColor = vec4(col, col, col, 1.0);\n}","name":"Image","description":"","type":"image"}]}