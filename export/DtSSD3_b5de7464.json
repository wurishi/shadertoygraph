{"ver":"0.1","info":{"id":"DtSSD3","date":"1676652031","viewed":202,"name":"Forks Sake","username":"Calgon","description":"Forked this from https://www.shadertoy.com/view/4s3fDH but wanted to replace the Cubemap with a non-buffered one.  Pretty sure that my call to \"myCubemap\" is incorrect but I haven't got my head around it just yet","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["triangles","reflections"],"hasliked":0,"parentid":"4s3fDH","parentname":"I Have a Question!"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Forked from https://www.shadertoy.com/view/4s3fDH by Wyatt\n// ...to make a non-buffered version.\n\n\n\n#define pi 3.1415927\n#define phi 1.61803398875\nconst float PI = 3.14159265359;\n\n\n////////////////////////////////////////////\n// Simple Cube Map with some pulsing colours\nfloat max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\nvec4 myCubemap(vec2 uv,vec3 rayOri,vec3 rayDir )\n{\n    vec3 rd = abs(rayDir);\n    \n    float pulse = sin(iTime)*.5 + .5;\n    float copulse = cos(iTime)*.5 + .5;\n    \n    vec3 col = vec3(0);\n    if (max3(rd) == rd.x) col = vec3(1, .25, pulse);\n    if (max3(rd) == rd.y) col = vec3(.25, 1, 0);\n    if (max3(rd) == rd.z) col = vec3(copulse*.4, pulse*.5, 1);\n    \n    vec4 OutColor = vec4(col,1.0); // \n    return OutColor;\n}\n////////////////////////////////////////////\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n//////////////////////////////////////\n\n\nmat3 rot (vec3 u) {\n\t\tvec3 s = sin(u), c = cos(u);\n\t\tmat3 x = mat3(1,0,0, \t\t0,c.x,s.x, \t\t0,-s.x,c.x);\n\t\tmat3 y = mat3(c.y,0,s.y, \t0,1,0, \t\t\t-s.y,0,c.y);\n\t\tmat3 z = mat3(s.z,c.z,0,\t-c.z,s.z,0,\t\t0,0,1);\n\t\treturn x*y*z;}\nvoid tri (vec3 p, vec3 d, mat3 tr, inout vec4 col, inout float depth, inout vec3 norm) {\n    vec3 n = normalize(cross(tr[1]-tr[0],tr[2]-tr[0]));\n    \n    \n    \n    \n    \n    if (dot(n,-d)<0.) n *= -1.;\n    mat3 nn = mat3(\n    \tnormalize(cross(n,tr[2]-tr[1])),\n    \tnormalize(cross(n,tr[0]-tr[2])),\n    \tnormalize(cross(n,tr[1]-tr[0]))\n    );\n    vec3 w = p - tr[0];\n    float x = -dot(w,n)/dot(d,n);\n    if (x < 0.) return;\n    vec3 i = p + d*x;\n    vec3 ipol = vec3(dot(nn[0],i-tr[1]),dot(nn[1],i-tr[2]),dot(nn[2],i-tr[0]))/vec3(dot(nn[0],tr[0]-tr[1]),dot(nn[1],tr[1]-tr[2]),dot(nn[2],tr[2]-tr[0]));\n    vec4 c = vec4(1);\n    c.w *= step(0.,ipol.x);\n    c.w *= step(0.,ipol.y);\n    c.w *= step(0.,ipol.z);\n    if (c.w==0.) return;\n    if (x < depth) {\n        vec3 u = normalize(reflect(p-i,n));\n      \n      // Break next line down into easier morcels...\n      //  c.xyz = texture(iChannel0,u).xyz*abs(u)-1.+smoothstep(0.02,0.025,ipol.x)*smoothstep(0.02,0.025,ipol.y)*smoothstep(0.02,0.025,ipol.z);\n      // becomes....\n      \n          //c.xyz = texture(iChannel0,u).xyz\n          //c.xyz*=abs(u)-1.+smoothstep(0.02,0.025,ipol.x)*smoothstep(0.02,0.025,ipol.y)*smoothstep(0.02,0.025,ipol.z);\n      \n      \n      // Get uv uequiv back...\n        vec2 notuv = d.xy;\n      // Send to cubemap...\n      vec4 fullcol = myCubemap(notuv,p,d);\n      \n      \n      // Replace the original Cubemap with ours...\n      c.xyz = fullcol.xyz;\n      c.xyz*=abs(u)-1.+smoothstep(0.02,0.025,ipol.x)*smoothstep(0.02,0.025,ipol.y)*smoothstep(0.02,0.025,ipol.z);\n      ///// End of hacking about\n      \n      col=c;\n        depth = x;\n        norm = n;\n    }\n}\nvoid sph (vec3 p, vec3 d, vec4 cr, inout vec4 col, inout float depth, inout vec3 norm) {\n\tvec3 w = p-cr.xyz;\n    float B = 2.*dot(w,d);\n    float C = dot(w,w)-cr.w*cr.w;\n    float dl = B*B-4.*C;\n    if (dl < 0.) return;\n    float x = 0.5*(-B-sqrt(dl));\n    if (x < 0.) return;\n    vec3 i = p + d*x;\n    vec4 c = vec4(1);\n    if (x < depth) {\n        norm = normalize(i-cr.xyz);\n        vec3 r = normalize(reflect(p-i,norm));\n    \n    // replace cubemap...\n    // Get uv uequiv back...\n    vec2 notuv = d.xy;\n    vec4 fullcol = myCubemap(notuv,p,d);\n    \n     // Break next line down...   \n    //\tc.xyz = abs(r)*texture(iChannel0,r).xyz;\n    \n     // Now try....\n    c.xyz = fullcol.xyz;\n     //   c.xyz = texture(iChannel0,r).xyz;\n    c.xyz *= abs(r);\n    /////////// End of hacking about\n    \n    \tcol = c;\n        depth = x;\n        \n    }\t\n}\nvoid scene (inout vec3 p, inout vec3 d, inout vec4 col, float i) {\n\tfloat depth = 1e3;\n    vec3 norm=vec3(0);\n    vec4 c = vec4(0);\n    float t = iTime/pi;\n    for (int i = 0; i < 4; i++) {\n        tri(p,d,\n            rot(pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               \t4,0,0,\n                0,4,0,\n                0,0,4\n            )\n        ,c,depth,norm);\n    \ttri(p,d,\n            rot(pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               \t-4,0,0,\n                0,-4,0,\n                0,0,-4\n            )\n        ,c,depth,norm);\n        tri(p,d,\n            rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               \t1,0,0,\n                0,1,0,\n                0,0,1\n            )\n        ,c,depth,norm);\n        tri(p,d,\n            rot(vec3(t,0,0)+pi*float(i)*vec3(1,0,0)*2./4.)*mat3(\n               \t-1,0,0,\n                0,-1,0,\n                0,0,-1\n            )\n        ,c,depth,norm);\n        \n        sph (p,d,vec4(sin(t+float(i)),cos(t+float(i)),sin(phi*t+float(i*i)),.2), c, depth, norm);\n    } \n    p = p + d*depth;\n    d = reflect(d,norm);\n    p += 0.0001*d;\n    col += 0.6*c/(1.+0.3*i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n // vec3 lp = vec3(0);\n // vec3 ro = vec3(0, 0, 3);\n // ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n//  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n\n\n\n\n\n\n\n\n    vec2 uv = ((fragCoord)/iResolution.xy*2.-1.)*iResolution.xy/iResolution.yy;\n\tmat3 m = rot(vec3(1,2,3)*0.1*iTime);\n    vec3 p = m*vec3(0,0,-2);\n    \n    // CL Now with added mousey stuff\n    p.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n    p.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n    \n    \n    vec3 d = m*normalize(vec3(uv,2));\n    \n    vec4 col = vec4(0,0,0,0);\n    \n    for (int i = 0; i < 10; i++) scene (p,d,col,float(i));\n    \n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}