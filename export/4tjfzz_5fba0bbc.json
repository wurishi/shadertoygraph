{"ver":"0.1","info":{"id":"4tjfzz","date":"1515842828","viewed":311,"name":"Lava Floor (flooded)","username":"domvalles","description":"Lava floor with some parallax mapping and whatnot. Put some water on top of it.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","parallax","filtering","lava"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 1.e-3\n#define ROCK_1 vec4(.33, .2, .2, 1.)\n#define ROCK_2 vec4(.2, .2, .2, 1.)\n#define LAVA_1 vec4(1., .145, 0., 1.)\n#define LAVA_2 vec4(1., .4, 0., 1.)\n#define LAVA_3 vec4(.949, .949, .09, 1.)\n#define BLUE   vec4(0., 0., 1., 1.)\nconst vec4 HELL_RED = vec4(241./255.,21./255.,20./255.,1.);\nconst vec4 HELL_HORIZON = HELL_RED * 5.;\n\nconst int iterations = 128;\nconst int MaxSamples = 10;\nconst float detail = .1;\n\nvec3 camOrigin;\nconst float PI = 3.1415927;\nconst float FOV = PI/4.;\n\nvec4 colors[3];\nvec3 lightDir = normalize(vec3(.5, -.5, .5));\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 direction;\n};\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nvec2 random2f(in vec2 vec)\n{\n //dot each part against random vec\n float dot1 = dot(vec, vec2(291.29, 9483.99));\n float dot2 = dot(vec, vec2(947.92, 5713.91));\n vec2 newVec = vec2(dot1, dot2);\n return fract(sin(newVec)*381932.293);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    float value = mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n    return value;\n}\n\n#define NUM_ITERATIONS 8\n\nfloat fbm(in vec2 uv){\n \n float amplitude = .5;\n float gain = .5;\n float lacunarity = 2.;\n float frequency = 1.;\n    \n float res = 0.;\n for (int x = 0; x < NUM_ITERATIONS; x++){\n\tres += amplitude * noise(frequency*uv);\n\tfrequency *= lacunarity;\n\tamplitude *= gain;\n }\n return res;\n}\n\nfloat warpedFbm(in vec2 uv){\n    float scale = 2.5;\n    float timeScale = 12.;\n    vec2 first = uv*scale + fbm(uv*1.) + iTime/timeScale;\n    vec2 second = uv*scale + fbm(first);\n    return fbm(second);\n}\n\nfloat warpedNoise(in vec2 uv){\n    float scale = .5;\n    float timeScale = 4.;\n    return noise(uv*scale + noise(uv*scale + noise(uv*1.) +iTime/timeScale ));\n} \n\nfloat f2f1Voronoi(in vec2 uv)\n    {\n\tvec2 f = fract(uv);\n    vec2 i = floor(uv);\n\n    float res = 8.0;\n    float res2 = 8.0;\n    for (int u = -1; u <= 1; u++)\n    {\n        for (int v = -1; v <= 1; v++)\n        {\n        vec2 base = vec2(u,v);\n        vec2 point = base - f + random2f(i + base);\n        //float d = dot(point, point);\n        float d = length(point);\n        //d += .4*noise(uv*4.);\n        //float n = 1. + .4*noise(uv*4.);\n            \n      //  if (d < res)\n        ///{\n           // res2 = res;\n            //r/es = d;\n        //}\n \n        /* If arr[i] is in between first and second \n           then update second  */\n          //  else if (d < res2 && d != res){\n            //res2 = d;    \n            //}\n            \n        (d < res) ? res2 = res, res = d : (d < res2 && d != res) ? res2 = d : res2 = res2;    \n        \n        //float resTemp = res;\n        //res = min(res, d);\n        //res2 = min(res2, d);\n        }        \n    }\n    res2 = (res2 == 8.0) ? res : res2;\n      \n    //res = pow(res, 1.);\n    //return res2 - res;\n    res = res2 - res;\n    return res;\n}\n\nfloat voronoi(in vec2 uv)\n{\n\tvec2 f = fract(uv);\n    vec2 i = floor(uv);\n\n    float res = 8.0;\n    for (int u = -1; u <= 1; u++)\n    {\n        for (int v = -1; v <= 1; v++)\n        {\n        vec2 base = vec2(u,v);\n        vec2 point = base - f + random2f(i + base);\n        float d = dot(point, point);\n        res = min(res, d);\n        }        \n    }\n    return res;\n}\n\nfloat voronoiFbm(in vec2 uv)\n{\n \n    float dist = 80.;\n    for (int i = 1; i <= 3; i++)\n    {\n        float newDist = f2f1Voronoi(uv * float(i));\n        dist = min(dist, newDist * float(i));\n    }\n    return dist;\n}\n\nRay setupRay(in vec2 uv, in vec3 origin)\n{\n \tvec2 sPosition = 2.*uv - 1.;\n    float aspect = iResolution.y/iResolution.x;\n    \n    float width = tan(FOV);\n    float height = width*aspect;\n    \n    vec3 forward = normalize(vec3(0, 0, 1));\n    vec3 up = normalize(vec3(0,1, 0));\n    vec3 right = normalize(cross(up, forward));\n    \n    Ray rayT;\n    rayT.direction = normalize(forward+sPosition.x*width * right+sPosition.y*height*up);\n    rayT.origin = origin;\n    return rayT;\n    //vec4 color = shade(camOrigin, direction, lightPos);   \n}\n\n//helper function for shaping lava rocks\nfloat rockVoronoi(in vec2 uv)\n{\n   \t return sqrt(f2f1Voronoi(uv)/4.);\n    // return sqrt(voronoiFbm(uv)/12.);\n\n}\n\nvec3 getNormal(in vec2 uv)\n{\n    //This could probably be more efficient\n    //dx\n    vec2 dx = vec2(EPS,0.);\n    vec3 t = vec3(EPS,rockVoronoi(uv+dx),0.);\n    vec3 s = vec3(-EPS,rockVoronoi(uv-dx),0.);\n    vec3 uv_dx = normalize((t - s));\n    \n    //dy\n    vec2 dz = vec2(0.,EPS);\n    t = vec3(0.,rockVoronoi(uv+dz),EPS);\n    s = vec3(0.,rockVoronoi(uv-dz),-EPS);\n    vec3 uv_dz = normalize((t - s));\n    return cross(uv_dx, uv_dz);\n}\n       \n\n\nvec4 lavaFloorAlbedo(in vec3 pos)\n{\n    vec2 uv = pos.xz;\n    \n    float res = 0.;\n\tfloat step = .01 * sqrt(length(pos-camOrigin));\n    //float step = .02;\n    //PARALAX MAPPING\n    vec3 dir = normalize(pos - camOrigin);\n    float startY = pos.y - sqrt(.25);\n    for (int i = 0; i < 100; i++)\n    {\n        //plane sits 1 down, clamp the voronoi value and check if under plane\n        float f2f1 = rockVoronoi(pos.xz);\n        float planeY = startY + f2f1; \n    \tfloat dist = pos.y - planeY;\n        if (dist <= 1e-3)\n            break;\n        else\n            pos += dir*step;\n    }\n    uv = pos.xz;\n    vec3 normal = getNormal(uv);\n    float nl = clamp(dot(normal, lightDir), 0., 1.);\n    //return vec4(nl);\n    //return vec4(normal,1.);\n  \t//uv *= 8.0;\n    \n    //POST DISTANCE\n    float dist = f2f1Voronoi(uv); //voronoi\n    //return vec4(dist);\n    dist += .15*noise(uv*30.); //warble the edges\n    float distDisp = -.125 + .25*warpedNoise(uv + vec2(1.,1.)*iTime/3.); //animate\n    dist += distDisp; //animate\n    \n    //LAVA COLOR\n    colors[0] = LAVA_1;\n    colors[1] = LAVA_2;\n    colors[2] = LAVA_3;\n    float lavaFbm = warpedFbm(uv);\n    \n    int lavaVal2 = int(floor(lavaFbm * 2.99));\n    vec4 lavaColor = colors[lavaVal2];\n    \n    //GROUND COLOR\n    float groundNoise = noise((uv + vec2(6.29,95.24))*4.);\n    vec4 rockColor = nl*mix(ROCK_1, ROCK_2, groundNoise);\n    \n    //FINAL\n    float color = smoothstep(.2, .15, dist);\n    return mix(rockColor, lavaColor, color); \n}\n\nfloat sdPlane( vec3 p)\n{\n  return p.y;\n}\n\nvec3 blue = vec3(40.,134.,150.)/255.*.8;\nvec3 getWaterAlbedo(in vec3 uvT)\n{\n    vec2 uv = uvT.xz;\n    uv /= 4.;\n    float fbm = abs(-.5 + fbm(uv + .12*fbm(uv + vec2(1., 1.)*iTime)));\n    float st = step(fbm, .02);\n    vec3 col;\n    vec3 white = vec3(1., 1., 1.);\n    col = mix(blue, vec3(1.), vec3(st));\n    return col;\n}\n\nvec3 sampleTextureWithFilter( in vec3 uvw, in vec3 ddx_uvw, in vec3 ddy_uvw, in float detail)\n{\n    int sx = 1 + int( clamp( detail*length(ddx_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n    int sy = 1 + int( clamp( detail*length(ddy_uvw-uvw), 0.0, float(MaxSamples-1) ) );\n\n\tvec3 no = vec3(0.0);\n\n    for( int j=0; j<sy; j++ )\n    for( int i=0; i<sx; i++ )\n    {\n        vec2 st = vec2( float(i), float(j) )/vec2(float(sx),float(sy));\n        //filtering something using a step() function is a real problem. To be addressed later\n        no += getWaterAlbedo( uvw + st.x * (ddx_uvw-uvw) + st.y*(ddy_uvw-uvw)).xyz;\n        no += lavaFloorAlbedo( uvw + st.x * (ddx_uvw-uvw) + st.y*(ddy_uvw-uvw)).xyz;\n    }\n\n\treturn no / pow(float(sx*sy),2.);\n}\n\n//Trig to raycast plane more efficiently\nvec3 findIntersection(vec3 origin, vec3 dir)\n{\n vec3 pos = origin;\n float dist = 8.;\n for (int i = 0; i < 2; i++)\n {\n     float dist = sdPlane(pos);\n     //if (dist <= 1e-3)\n     //{\n       //  return pos;\n         //return lavaFloorAlbedo(pos.xyz);\n     //}\n     //else\n     //{\n         //some trig to optimize raycast for plane\n         float y = dir.y;\n         float x = sqrt(pow(dir.x,2.) + pow(dir.z, 2.));\n         float angle = atan(x/y) - PI*6./4.;\n         float realD = dist/sin(angle);\n         pos += dir*realD;\n     //}\n }\n return pos;\n}\n\nvec3 getFilterFootprint(vec3 camOrigin, vec2 fragCoord, vec2 iResolution, out vec3 c, out vec3 x, out vec3 y)\n{\n    //UVs\n    vec2 uv = fragCoord / iResolution;\n   \tvec2 uvX = (fragCoord + vec2(1.,0.)) / iResolution; //\n   \tvec2 uvY = (fragCoord + vec2(0.,1.)) / iResolution;\n    \n    //RAYS\n   \tRay rayCenter, rayX, rayY;\n    rayCenter = setupRay(uv, camOrigin);\n    rayX = setupRay(uvX, camOrigin);\n    rayY = setupRay(uvY, camOrigin);\n    \n    //intersectionPositions\n    c = findIntersection(camOrigin, rayCenter.direction);\n    x = findIntersection(camOrigin, rayX.direction);\n    y = findIntersection(camOrigin, rayY.direction);\n    \n    return rayCenter.direction;\n}\n\nvec3 getSkyColor(vec3 dir)\n{\n    vec4 sunColor = vec4(0.,0.,0.,1.);\n    vec3 sunDir = normalize(vec3(0.,.2,1.));\n    float sd = 1. - clamp(dot(dir, sunDir),0.,1.);\n    //sd = 1. - step(sd, .1);\n    float y = dir.y;\n    float x = sqrt(pow(dir.x,2.) + pow(dir.z, 2.));\n    float angleG = atan(y/x);// - PI*6./4.;\n    angleG = angleG/PI/2.;\n    vec4 atm = mix(HELL_HORIZON, HELL_RED, pow(angleG,.2));\n    //return mix(sunColor, atm, pow(sd,.2)).xyz;\n    return atm.xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //UV and Camera\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    camOrigin = vec3(0., 3. + sin(iTime), -5. + cos(iTime));\n\t\n    \n    //FILTER\n    vec3 intersectPos, intersectPosX, intersectPosY;\n    vec3 direction = getFilterFootprint(camOrigin, fragCoord.xy, iResolution.xy, intersectPos, intersectPosX, intersectPosY);\n    \n    vec3 color = vec3(1.);\n  \tif (intersectPos.y <= 1e-3)\n   \t\tcolor = sampleTextureWithFilter(intersectPos, intersectPosX, intersectPosY, detail);\n    //if (intersectPos.y <= 1e-3)\n\t//\tcolor = getWaterAlbedo(intersectPos).xyz;\n        //color = lavaFloorAlbedo(intersectPos).xyz;\n    else\n        color = getSkyColor(direction);\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}