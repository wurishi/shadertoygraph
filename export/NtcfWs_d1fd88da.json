{"ver":"0.1","info":{"id":"NtcfWs","date":"1663788015","viewed":160,"name":"antique forest","username":"jt","description":"Just for fun.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","forest","stairs","columns","antique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/NtcfWs antique forest by jt\n\n// Comment by msm01 describes this shader perfectly:\n// \"When your sculpting robot went juuuuuust a little mad in your absence...\" :-)\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n#define ITER_MAX 500u\n\nfloat vmax(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\nvoid pR45(inout vec2 p)\n{\n    p = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\nfloat pMod1(inout float p, float size)\n{\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n\n// https://www.shadertoy.com/view/Xs3GRB HG SDF in WebGL by tomkh,\n// implementation of http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n)\n{\n    float d = min(a, b);\n    vec2 p = vec2(a, b);\n    pR45(p);\n    p = p.yx - vec2((r-r/n)*0.5*sqrt(2.));\n    p.x += 0.5*sqrt(2.)*r/n;\n    float x = r*sqrt(2.)/n;\n    pMod1(p.x, x);\n    d = min(d, p.y);\n    pR45(p);\n    return min(d, vmax(p -vec2(0.5*r/n)));\n}\n\n\nvec2 hash2(vec2 p)\n{\n    // Dave Hoskin's hash as in https://www.shadertoy.com/view/4djSRW\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+19.19);\n    vec2 o = fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n\n    return o;\n}\n\n//---------------------------------------------------------------\n// 4x4 scan in both passes = most accurate\n//---------------------------------------------------------------\n// https://www.shadertoy.com/view/llG3zy Faster Voronoi Edge Distance by tomkh\n/*\nvec3 voronoi( in vec2 x )\n{\n#if 1\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n#else\n    vec2 n = floor(x - 1.5);\n    vec2 f = x - n;\n#endif\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mr;\n\n    float md = 8.0;\n    for(int j = 0; j <= 3; j++)\n        for(int i=0; i <= 3; i++)\n        {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(n + g);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n            }\n        }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for(int j = 0; j <= 3; j++)\n        for(int i = 0; i <= 3; i++)\n        {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(n + g);\n            vec2 r = g + o - f;\n\n            if(dot(mr - r, mr - r) > EPSILON) // skip the same cell\n                md = min(md, dot(0.5 * (mr + r), normalize(r - mr)));\n        }\n\n    return vec3(mr, md);\n}\n*/\nvec2 voronoi( in vec2 x ) // adapted from https://www.shadertoy.com/view/llG3zy Faster Voronoi Edge Distance by tomkh NOTE: removed here not needed 2nd pass\n{\n#if 1\n    // slower, but better handles big numbers\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 h = step(.5,f) - 2.;\n    n += h; f -= h;\n#else\n    vec2 n = floor(x - 1.5);\n    vec2 f = x - n;\n#endif\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mr;\n\n    float md = 8.0;\n    for(int j = 0; j <= 3; j++)\n        for(int i=0; i <= 3; i++)\n        {\n            vec2 g = vec2(i, j);\n            vec2 o = hash2(n + g);\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n            }\n        }\n\n    return mr;\n}\n\nfloat extrude_voronoi(vec3 p)\n{\n    float dp = p.z; // distance to plane\n    //float df = voronoi(p.xy).z; // distance to 2d SDF\n    float df = length(voronoi(p.xy).xy)-0.1; // distance to 2d SDF\n    //return max(df, dp); // 3dify - not an exact distance field\n\n    // Correct SDF, as suggested by iq - thanks!\n    vec2 w = vec2(df, dp);\n    return min(max(w.x, w.y), 0.0) + length(max(w, 0.0));\n\n    //return min(max(df, dp), 0.0) + length(max(vec2(df, dp), 0.0)); // rewritten to compare to incorrect approach\n}\n\nfloat halfspace(vec3 p, float d)\n{\n    return p.z - d;\n}\n\nfloat map(vec3 p)\n{\n    float d = mix(0.01, 0.1, 0.5 + 0.5 * cos(iTime));\n    return\n        /*\n        min\n        (\n            //extrude_voronoi(p),\n            extrude_voronoi(p) - 0.01, // TEST: With offset incorrect SDF retains sharp edges while correct SDF aquires rounded edges.\n            halfspace(p, -1.2)\n        );\n        */\n        fOpUnionStairs\n        (\n            extrude_voronoi(p) - 0.01,\n            halfspace(p, -1.2),\n            0.25,\n            5.0\n        );\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return\n        normalize\n        (\n            k.xyy * map(p + k.xyy*h)\n            +\n            k.yyx * map(p + k.yyx*h)\n            +\n            k.yxy * map(p + k.yxy*h)\n            +\n            k.xxx * map(p + k.xxx*h)\n        );\n}\n\nfloat trace(vec3 ro, vec3 rd) // iteration count limited to avoid stalling if ray passes very close to surface\n{\n    float t;\n    uint i;\n    for(i = 0u, t = 0.0; i < ITER_MAX && t < DIST_MAX; i++)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return DIST_MAX;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    float t;\n    uint i;\n    for(i = 0u, t = mint; i < ITER_MAX && t<maxt; i++)\n    {\n        float h = map(ro + rd*t);\n        if( h<EPSILON )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\n#define pi 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n    float my = pi / 2.0 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.01);\n    my = (iMouse.y > 10.0) ? my : pi * 2.5 / 4.0;;\n\n    mat2 R = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    vec3 ro = vec3(0.0, 0.0, -5.0 );//vec3(0.0, -10.0 * my, 0.0);\n    //mat2 S = mat2(vec2(0.0, 1.0), vec2(-1.0, 0.0));\n    mat2 S = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    ro.yz=S*ro.yz;\n    ro.xy = R * ro.xy;\n\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz=S*rd.yz;\n    rd.xy = R * rd.xy;\n\n    float dist = trace(ro, rd);\n    vec3 dst = ro + rd * dist;\n    vec3 n = normal(dst);\n\n    vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 ambient = vec3(0.1);\n    float brightness = max(dot(lightdir, n), 0.0);\n    brightness *= shadow(ro+rd*dist,lightdir, 0.01, DIST_MAX); // XXX artifacts on cylinder XXX\n    vec3 color = vec3(1.0);\n    //color *= (n * 0.5 + 0.5);\n    color = (ambient * calcAO(dst, n) + brightness) * color;\n\n    fragColor = mix(vec4(color, 1.0), vec4(0.0), step(DIST_MAX, dist));\n    fragColor = sqrt(fragColor); // approximate gamma\n}\n","name":"Image","description":"","type":"image"}]}