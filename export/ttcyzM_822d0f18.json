{"ver":"0.1","info":{"id":"ttcyzM","date":"1608657658","viewed":89,"name":"Möller-Trumbore algorithm","username":"newtaki168","description":"A triangle in 3d space using the Möller-Trumbore triangle ray intersection algorithm.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat tri(vec3 rd, vec3 ro, vec3 v1, vec3 v2, vec3 v3) {\n    vec3 a = -normalize(rd);\n    vec3 b = v2-v1;\n    vec3 c = v3-v1;\n    vec3 k = ro-v1;\n    \n    float m1 = dot(a,cross(b,c));\n    float m2 = dot(k,cross(b,c));\n    float m3 = dot(a,cross(k,c));\n    float m4 = dot(a,cross(b,k));\n    \n    float t = m2/m1;\n    float u = m3/m1;\n    float v = m4/m1;\n    float w = u+v;\n    \n    if(u >= 0.) u = 1.; else u = 0.;\n    if(v >= 0.) v = 1.; else v = 0.;\n    if(w <= 1.) w = 1.; else w = 0.;\n    \n    return min(min(u,v),w);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n        \n    vec3 ro = vec3(0, 0, -5);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = R(uv, ro, vec3(0,1,0), 1.);\n    \n    vec3 v1 = vec3(0,0,0);\n    vec3 v2 = vec3(1,0,0);\n    vec3 v3 = vec3(0,0,1);\n    \n    float triangle = tri(rd,ro,v1,v2,v3);\n    \n    vec3 col = vec3(triangle);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}