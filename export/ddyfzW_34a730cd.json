{"ver":"0.1","info":{"id":"ddyfzW","date":"1697975171","viewed":47,"name":"Another ray casting engine","username":"HanoRobelthon","description":"An engine to render stuff..\nUsing surface rendering in combination with SDF for the best of the two world.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raycasting","refraction","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// return the camera position and 3 vectors \n// describing camera's space from mouse's data\nvec3 cameraSpace(in vec3 center, in float dist, out vec3 front, out vec3 up, out vec3 right)\n{\n    //                                             vvvv sensibility\n    vec2 rotation = (abs(iMouse.zw) - iMouse.xy) * 10.f / iResolution.xy;\n    rotation.y += 0.5;\n    rotation.x += 3.64;\n    if(abs(rotation.y) > 1.5)\n        rotation.y = sign(rotation.y) * 1.5;\n\n    vec3 position;\n\n    // Spherical coordinates\n    float cosD = cos(rotation.y);\n    position.x = cosD * cos(rotation.x);\n    position.z = cosD * sin(rotation.x);\n    position.y = sin(rotation.y);\n    position = center + position * dist;\n\n    front = -normalize(position - center);\n    right = normalize(cross(vec3(0, 1, 0), front));\n    up = normalize(cross(front, right));\n\n    return position;\n}\n\nvoid camera(in vec2 frag_coord, out Ray cam)\n{\n    float SCREEN_WIDTH = 1.f;\n    \n    // Compute uv coordinates in camera's plan\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = frag_coord / iResolution.xy;\n    uv -= vec2(0.5);\n\n    vec3 front, right, up;\n    cam.o = cameraSpace(CAM_CENTER, CAM_DIST, front, up, right);\n\n    // Compute actual pixel coordinate in camera's plan\n    vec3 pixel_pos = cam.o + front \n        +         SCREEN_WIDTH * uv.x * right \n        + ratio * SCREEN_WIDTH * uv.y * up;\n\n    cam.d = normalize(pixel_pos - cam.o);\n}\n\n//\n//  Scène\n//\n\nHit table(Ray cam, bool sdf)\n{\n    return unionE(\n        unionE(\n            unionE(\n                unionE(\n                    interCylindre(cam, Cylindre(vec3(0, -0.5, 0), vec3(0, 0.0, 0), 30.0, TRANSLUCIDE), sdf), // plateau 1\n                    interCylindre(cam, Cylindre(vec3(30, -2.5, 0), vec3(30, -2, 0), 20.0, VERRE), sdf)  // plateau 2\n                ),\n                unionE(\n                    interCylindre(cam, Cylindre(vec3(0, -0.5, 0), vec3(0, -1.0, 0), 3.0, METALBROSSE), sdf), // support haut 1\n                    interCylindre(cam, Cylindre(vec3(30, -2.5, 0), vec3(30, -3.0, 0), 3.0, METALBROSSE), sdf)  // support haut 2\n                )\n            ),\n            unionE(\n                interCylindre(cam, Cylindre(vec3(0, -1.0, 0), vec3(0, -30.0, 0), 1.5, METALBROSSE), sdf), // poteau 1\n                interCylindre(cam, Cylindre(vec3(30, -3.0, 0), vec3(30, -30.0, 0), 1.5, METALBROSSE), sdf)  // poteau 2\n            )\n        ),\n        unionE(\n            unionE(\n                interCylindre(cam, Cylindre(vec3(0, -30.0, 0), vec3(0, -30.5, 0), 3.0, METALBROSSE), sdf), // support bas 1\n                interCylindre(cam, Cylindre(vec3(30, -30.0, 0), vec3(30, -30.5, 0), 3.0, METALBROSSE), sdf)  // support bas 2\n            ),\n            interCylindre(cam, Cylindre(vec3(15, -30.5, 0), vec3(15, -31.5, 0), 20.0, METALBROSSE), sdf) // pied\n        )\n    );\n}\n\nHit billes(Ray cam, bool sdf)\n{\n    return unionE(\n        interSphere(cam, Sphere(vec3(7, 3.01, 10), 3., VERRE), sdf),\n        interCube(cam, Cube(vec3(35, 1, 0), vec3(3.), DAMIER), sdf)\n    );\n}\n\nHit World(Ray cam, bool sdf)\n{\n    /* Démo primitive*/\n    // return unionE(\n    //     interCube(cam, Cube(vec3(0), vec3(10.1), DAMIER), sdf),\n    //     // interCapsule(cam, Capsule(vec3(5, -5, 0), vec3(-5, 5, 0), 10.0, VERT), sdf),\n    //     // interCylindre(cam, Cylindre(vec3(2, -5, -5), vec3(0, 5, 5), 10.f, VERT), sdf),\n    //     // interTore(cam, Tore(vec3(0), normalize(vec3(0, 1, 0)), 20., 7., VERT), sdf),\n    //     // interSphere(cam, Sphere(vec3(0), 10.f, VERT), sdf),\n    //     interPlan(cam, Plan(vec3(0, -100, 0), vec3(0, 1, 0), ROUGE), sdf)\n    // );\n\n    // return \n\n    /*Test de perf*/\n    // vec3 basePos = vec3(-10, -10, -10);\n    // float spacing = 3.f;\n    // Hit hit = HITMISS;\n    // for(int k = 0; k < 10; k++)\n    //    for(int i = 0; i < 10; i++)\n    //        for(int j = 0; j < 10; j++)\n    //        {\n    //            hit = unionE(hit, interSphere(cam, Sphere(basePos + vec3(i,j, k) * spacing, 1.f, ROUGE), sdf));\n    //            // hit = unionE(hit, interCube(cam, Cube(basePos + vec3(i, j, k) * spacing, vec3(1.f), ROUGE), sdf));\n    //            // hit = unionE(hit, interCapsule(cam, Capsule(basePos + vec3(i, j, k) * spacing, basePos + vec3(i, j, k)*spacing + vec3(0, 1, 0), 1.0, ROUGE), sdf));\n    //            // hit = unionE(hit, interTore(cam, Tore(basePos + vec3(i, j, k) * spacing, vec3(0, 1, 0), 1.0, 0.3, ROUGE), sdf));\n    //        }\n    //return hit;\n\n    /* Scène sympa*/\n    return unionE(\n        interPlan(cam, Plan(vec3(0, -31.5, 0), vec3(0, 1, 0), BLEU), sdf),\n        unionE(\n            table(cam, sdf),\n            billes(cam, sdf)\n        )\n    );\n}\n\n//\n//   Structure FIFO pour la gestion des rayons\n//          ( Réfraction & Réflexion )\n//\nstruct FIFO_Item\n{\n    Ray ray;\n    bool sdf;\n    bool inside;\n    float col_coeff;\n};\n\nstruct RayFIFO\n{\n    FIFO_Item fifo[MAX_FIFO_SIZE];\n    int next;\n    int size;\n};\n\nbool next_item(inout RayFIFO rf, out FIFO_Item item)\n{\n    if(rf.next >= rf.size)\n        return false;\n    item = rf.fifo[rf.next++];\n    return true;\n}\n\nvoid add_ray(inout RayFIFO rf, in FIFO_Item item)\n{\n    if(rf.size < MAX_FIFO_SIZE)\n        rf.fifo[rf.size++] = item;\n}\n\n\n//\n//  Fonctions de calculs de couleur\n//\nHit findHit(Ray ray, bool sdf, bool inside);\nfloat shadow(vec3 light, vec3 point)\n{\n#if COMPUTE_SHADOW\n    float total_dist = 0.0;\n    float max_dist = distance(light, point);\n    vec3 dir = normalize(light - point);\n\n    ObjectInfo oi;\n    do {\n        Hit impact = findHit(Ray(point, dir), false, false);\n        total_dist += impact.dist;\n        oi = getTexture(impact.texID, point);\n        point = point + dir * (impact.dist + 0.01);\n\n    } while(oi.refractionCoeff != 0.0 && total_dist <= max_dist);\n\n    if (total_dist > 0.f && total_dist < max_dist && !oi.transparent)\n        return 0.f;\n#endif\n    return 1.0;\n}\n\nvec3 diffus(vec3 light, Hit impact, ObjectInfo info)\n{\n#if COMPUTE_DIFFUSE\n    if(info.transparent)\n        impact.n *= -1.f;\n    return info.diffusColor * max(dot(impact.n, light), 0.f);\n#else\n    return vec3(0.0);\n#endif\n}\n\nvec3 speculaire(vec3 light, vec3 view, Hit impact, ObjectInfo info)\n{\n#if COMPUTE_SPECULAR\n    if(info.transparent)\n        impact.n *= -1.f;\n    vec3 h = normalize(light + view);\n    return info.speculaireColor * pow(max(dot(h, impact.n), 0.f), info.speculaireCoeff);\n#else\n    return vec3(0.0);\n#endif\n}\n\nvec3 color(vec3 light_pos, vec3 view_dir, vec3 impact_point, Hit impact, ObjectInfo info)\n{\n    vec3 col = vec3(0);\n    vec3 light_dir = normalize(light_pos - impact_point);\n\n    if(shadow(light_pos, impact_point + impact.n * 0.02) == 0.0)\n        return col;\n\n    col += diffus(light_dir, impact, info);\n    col += speculaire(light_dir, view_dir, impact, info);\n\n    return col;\n}\n\n\n//\n//  Moteurs de rendu\n//\n\nHit findHit(Ray ray, bool sdf, bool inside)\n{\n    if(!sdf)\n    {\n        return World(ray, false);\n    }\n    \n    Hit impact;\n    \n    float dist = 0.0;\n    int iter = 0;\n    do \n    {\n        impact = World(ray, true);\n\n        if(inside)\n            impact.dist *= -1.0;\n\n        if(impact.dist < 0.0)\n        {\n            impact = World(Ray(ray.o + ray.d * impact.dist * (-0.5), ray.d), true);\n            impact.dist = -impact.dist + dist;\n            return impact;\n        }\n        dist += impact.dist;\n        \n        ray.o = ray.o + ray.d * max(impact.dist, 0.01);\n        iter++;\n    } while(iter < MAX_SPHERE_MARCHING_ITERATIONS && dist < RENDER_DISTANCE);\n\n    return HITMISS;\n}\n\nvec3 render(Ray cam, bool force_sdf)\n{\n    RayFIFO fifo;\n    fifo.next = fifo.size = 0;\n\n    // Lumière\n    int nb_lights = 1;\n    vec3 light_pos[3];\n\n    light_pos[0] = vec3(0, 4, 0);\n    light_pos[1] = vec3(-15, 4, -13);\n    light_pos[2] = vec3(-10, 4, 20);\n\n    light_pos[0] = vec3(100, 100, 50);\n\n    vec3 col = vec3(0);\n    ObjectInfo info;\n\n    Ray ray;\n    FIFO_Item item;\n    add_ray(fifo, FIFO_Item(cam, force_sdf, false, 1.0));\n\n    while(next_item(fifo, item))\n    {\n        // Récupérer les infos du point touché\n        ray = item.ray;\n        Hit impact = findHit(ray, item.sdf, item.inside);\n\n        vec3 impact_point = ray.o + ray.d * impact.dist;\n        info = getTexture(impact.texID, impact_point);\n\n        // Calcul des coefficients pour la quantité de lumière réfléchie et réfracté\n        info.refractionCoeff = (item.inside ? 1.0 : info.refractionCoeff);\n        float object_col_coeff = item.col_coeff * (1.0 - info.reflexionCoeff - info.transparenceCoeff);\n\n        // Réctification de la normale selon la texture             vvvvvvvvvv  On s'assure que le displacement ne retourne pas la normale\n        impact.n = normalize(impact.n + info.normalDisplacement);// * dot(impact.n, info.normalDisplacement));\n        \n#if SHOW_DEPTH\n        return vec3(1.0 - impact.dist / (RENDER_DISTANCE * 0.25));\n#elif SHOW_DIRECT_NORMAL\n        return impact.n;\n#elif SHOW_FINAL_NORMAL\n        col = impact.n;\n#else\n        // Calculer la couleur de ce point\n        if(!item.inside)\n        {\n            vec3 newcol = info.ambiantColor;\n            vec3 view_dir = normalize(ray.o - impact_point);\n            for(int i = 0; i < nb_lights; i++)\n            {\n                // vec3 light_dir = normalize(light_pos[i] - impact_point);\n                newcol += color(light_pos[i], view_dir, impact_point, impact, info);\n            }\n            col += object_col_coeff * newcol;\n        }\n#endif\n\n        // Dévier les rayons si besoin\n        if(!item.inside)\n        {\n            if(info.reflexionCoeff > 0.0) // Réflexion\n            {\n                ray.o = impact_point + impact.n * 0.02;\n                ray.d = normalize(reflect(ray.d, impact.n));\n                add_ray(fifo, FIFO_Item(ray, force_sdf, false, item.col_coeff * info.reflexionCoeff));\n            }\n            if( info.transparenceCoeff > 0.0) // Réfraction\n            {\n                ray.o = impact_point - impact.n * 0.01;\n                ray.d = normalize(refract(ray.d, impact.n, 1.0 / info.refractionCoeff));\n                add_ray(fifo, FIFO_Item(ray, true, true, item.col_coeff));\n            }\n        }\n        else\n        {\n            ray.o = impact_point + impact.n * 0.02;\n            ray.d = normalize(refract(ray.d, -impact.n, info.refractionCoeff));\n            add_ray(fifo, FIFO_Item(ray, force_sdf, false, item.col_coeff * info.transparenceCoeff));\n        }\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray cam;\n    camera(fragCoord, cam);\n\n\n#if FORCE_SDF\n    fragColor = vec4(render(cam, true), 1);\n#else\n    #if SPLIT_RENDERING\n        if(fragCoord.x > iResolution.x * 0.4994 && fragCoord.x < iResolution.x * 0.5006) \n            fragColor = vec4(1., 1., 1., 1.);\n        else if(fragCoord.x < iResolution.x * 0.5)\n            fragColor = vec4(render(cam, true), 1);\n        else\n    #endif\n            fragColor = vec4(render(cam, false), 1);\n#endif\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Split the window : Leftside is rendered using SDF, rightside using surface rendering\n#define SPLIT_RENDERING 0\n// Render everything with SDF\n#define FORCE_SDF 1\n// Show object's normal without computing refraction and reflexion\n#define SHOW_DIRECT_NORMAL 0\n// Show object's normal after computing refraction and reflexion\n#define SHOW_FINAL_NORMAL 0\n// Show object's depth\n#define SHOW_DEPTH 0\n\n#define COMPUTE_DIFFUSE 1\n#define COMPUTE_SPECULAR 1\n#define COMPUTE_SHADOW 1\n\n// Define the maximum size of the FIFO struct. This internally define how many rays can be launch for each pixel.\n#define MAX_FIFO_SIZE 15\n// Define a maximum number of steps that sphere marching can do before returning\n#define MAX_SPHERE_MARCHING_ITERATIONS 1000\n// Define a maximum distance that sphere marching can travel before returning\n#define RENDER_DISTANCE 1000.0\n\n#define CAM_DIST 125.0\n#define CAM_CENTER vec3(15, -15, 0)\n// Utiliy constant used to return a missed ray\n#define HITMISS Hit(RENDER_DISTANCE, vec3(0), 0)\n\n\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nstruct Hit\n{\n    float dist;\n    vec3 n;\n    int texID;\n};\n\nHit unionE(in Hit A, in Hit B)\n{\n    if(A.dist < B.dist)\n        return A;\n    return B;\n}\n\n\n//\n//      Primitives de forme\n//\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    int texID;\n};\n\nHit interSphere(Ray ray, Sphere s, bool SDF)\n{\n    float dist;\n    if(!SDF)\n    {\n        vec3 OC = s.center - ray.o;\n        float OC_dot_dir = dot(ray.d, OC);\n        float h_sqr = pow(length(OC), 2.0f) - pow(OC_dot_dir, 2.0f);\n\n        if (h_sqr > s.radius * s.radius)\n            return HITMISS;\n\n        dist = OC_dot_dir - sqrt(s.radius * s.radius - h_sqr);\n        if(dist < 0.0)\n            return HITMISS;\n    }\n    else\n    {\n        dist = distance(ray.o, s.center) - s.radius;\n    }\n\n    return Hit(\n        dist, \n        normalize(ray.o + ray.d * dist - s.center),\n        s.texID\n    );\n    \n}\n\nstruct Plan\n{\n    vec3 point;\n    vec3 normal;\n    int texID;\n};\n\nHit interPlan(Ray ray, Plan p, bool SDF)\n{\n    float dist;\n    if(!SDF)\n    {\n        // Récupéré d'un projet de l'an dernier\n        dist = dot(-p.normal, ray.o - p.point) / dot(p.normal, ray.d);\n        \n        if(dist < 0.0f)\n            return HITMISS;\n    }\n    else\n    {\n        dist = dot(p.normal, ray.o - p.point);\n    }\n\n    return Hit(dist, p.normal, p.texID);\n}\n\n\nstruct Cylindre\n{\n    vec3 A;\n    vec3 B;\n    float radius;\n    int texID;\n};\n\nHit interCylindre(Ray ray, Cylindre c, bool sdf)\n{\n    float dist = 0.0;\n    vec3 norm = vec3(0);\n\n    if(!sdf)\n    {\n        vec3 AB = normalize(c.B - c.A);\n        vec3 AO = ray.o - c.A;\n        vec3 p = ray.o;\n\n        if(dot(normalize(cross(cross(AB, AO), AB)), AO) > c.radius)\n        {\n            float abd = dot(AB, ray.d);\n            float abao = dot(AB, AO); \n\n            float A = dot(ray.d, ray.d) - abd * abd;\n            float B = 2.f * (dot(AO, ray.d) - abao * abd);\n            float C = dot(AO, AO) - abao * abao - c.radius * c.radius;\n\n            float det = B * B - 4.f * A * C;\n\n            if(det < 0.0)\n                return HITMISS;\n            if(det == 0.0)\n                dist = -B / (2.f * A);\n            else\n            {\n                float t1 = (-B - sqrt(det)) / (2.f * A);\n                float t2 = (-B + sqrt(det)) / (2.f * A);\n\n                dist = t1 < t2 && t1 > 0.0 ? t1 : t2;\n            }\n            if(dist < 0.0)\n                return HITMISS;\n\n            p = ray.o + ray.d * dist;\n            vec3 AP = p - c.A;\n            norm = normalize(AP - AB * dot(AP, AB));\n        }\n        if(dot(p - c.A, AB) < 0.0) \n        {\n            norm = -AB;\n            Hit impact = interPlan(ray, Plan(c.A, norm, c.texID), false);\n            p = ray.o + ray.d * impact.dist;\n            if(distance(c.A, p) > c.radius)\n                return HITMISS;\n            dist = impact.dist;\n        }\n        else if(dot(p - c.B, -AB) < 0.0)\n        {\n            norm = AB;\n            Hit impact = interPlan(ray, Plan(c.B, norm, c.texID), false);\n            p = ray.o + ray.d * impact.dist;\n            if(distance(c.B, p) > c.radius)\n                return HITMISS;\n            dist = impact.dist;\n        }\n    }\n    else\n    {\n        vec3 AB = normalize(c.B - c.A);\n        vec3 AP = ray.o - c.A;\n\n        float distTop = dot(AB, ray.o - c.B) - 0.02;\n        float distBot = dot(-AB, AP) - 0.02;\n        float distSide = dot(normalize(cross(cross(AB, AP), AB)), AP) - c.radius;\n\n        dist = max(max(distTop, distBot), distSide);\n\n        if(dist == distTop)\n            norm = AB;\n        else if(dist == distBot)\n            norm = -AB;\n        else\n            norm = normalize(AP - AB * dot(AP, AB));\n    }\n\n    return Hit(\n        dist,\n        norm,\n        c.texID\n    );\n}\n\nstruct Capsule\n{\n    vec3 A;\n    vec3 B;\n    float radius;\n    int texID;\n};\n\nHit interCapsule(Ray ray, Capsule c, bool sdf)\n{\n    float dist = 0.0;\n    vec3 norm = vec3(0);\n\n    if(!sdf)\n    {\n        vec3 AB = normalize(c.B - c.A);\n        vec3 AO = ray.o - c.A;\n        vec3 p = ray.o;\n\n        if(dot(normalize(cross(cross(AB, AO), AB)), AO) > c.radius)\n        {\n            float abd = dot(AB, ray.d);\n            float abao = dot(AB, AO); \n\n            float A = dot(ray.d, ray.d) - abd * abd;\n            float B = 2.f * (dot(AO, ray.d) - abao * abd);\n            float C = dot(AO, AO) - abao * abao - c.radius * c.radius;\n\n            float det = B * B - 4.f * A * C;\n\n            if(det < 0.0)\n                return HITMISS;\n            if(det == 0.0)\n                dist = -B / (2.f * A);\n            else\n            {\n                float t1 = (-B - sqrt(det)) / (2.f * A);\n                float t2 = (-B + sqrt(det)) / (2.f * A);\n\n                dist = t1 < t2 && t1 > 0.0 ? t1 : t2;\n            }\n            if(dist < 0.0)\n                return HITMISS;\n\n            p = ray.o + ray.d * dist;\n            vec3 AP = p - c.A;\n            norm = normalize(AP - AB * dot(AP, AB));\n        }\n\n        if(dot(p - c.A, AB) < 0.0) \n        {\n            Hit impact = interSphere(ray, Sphere(c.A, c.radius, c.texID), false);\n            \n            norm = impact.n;            \n            dist = impact.dist;\n        }\n        else if(dot(p - c.B, -AB) < 0.0)\n        {\n            Hit impact = interSphere(ray, Sphere(c.B, c.radius, c.texID), false);\n\n            norm = impact.n;\n            dist = impact.dist;\n        }\n        if(dist == RENDER_DISTANCE)\n            return HITMISS;\n    }\n    else\n    {    \n        vec3 AB = normalize(c.B - c.A);\n        vec3 AP = ray.o - c.A;\n\n        float distTop = distance(ray.o, c.B) - c.radius;\n        float distBot = distance(ray.o, c.A) - c.radius;\n        float distSide = dot(normalize(cross(cross(AB, AP), AB)), AP) - c.radius;\n\n        dist = max(max(distTop, distBot), distSide);\n\n        if(dot(ray.o - c.A, AB) < 0.0) {\n            dist = distBot;\n            norm = normalize(ray.o - c.A);\n        }\n        else if(dot(ray.o - c.B, -AB) < 0.0) {\n            dist = distTop;\n            norm = normalize(ray.o - c.B);\n        }\n        else {\n            dist = distSide;\n            norm = normalize(AP - AB * dot(AP, AB));\n        }\n    }\n\n    return Hit(\n        dist,\n        norm,\n        c.texID\n    );\n}\n\nstruct Cube\n{\n    vec3 center;\n    vec3 width;\n    int texID;\n};\n\nHit interCube(Ray ray, Cube c, bool sdf)\n{\n    float dist;\n    vec3 norm;\n    if(!sdf)\n    {\n        \n\n        // Normalise le cube au centre de notre repère, permet de réduire le nombre de test à faire\n        ray.o -= c.center;\n\n#if 1\n        // Permet de remettre dans le huitième positif du repère l'origine ET la direction\n        // On aurait pu se contenter d'un abs pour l'origine, mais la direction ne suivrait pas\n        vec3 divider = abs(ray.o);\n        if(ray.o.x == 0.0) divider.x = 1.0;\n        if(ray.o.y == 0.0) divider.y = 1.0;\n        if(ray.o.z == 0.0) divider.z = 1.0;\n\n        vec3 coeff = ray.o / divider;\n        ray.o *= coeff;\n        ray.d *= coeff;\n\n\n        vec3 p;\n\n        Hit hX = interPlan(ray, Plan(vec3(c.width.x, 0, 0), vec3(1, 0, 0), c.texID), false);\n        p = ray.o + hX.dist * ray.d;\n        if(abs(dot(p, vec3(0, 1, 0))) > c.width.y || abs(dot(p, vec3(0, 0, 1))) > c.width.z)\n            hX = HITMISS;\n\n        Hit hY = interPlan(ray, Plan(vec3(0, c.width.y, 0), vec3(0, 1, 0), c.texID), false);\n        p = ray.o + hY.dist * ray.d;\n        if(abs(dot(p, vec3(1, 0, 0))) > c.width.x || abs(dot(p, vec3(0, 0, 1))) > c.width.z)\n            hY = HITMISS;\n        \n        Hit hZ = interPlan(ray, Plan(vec3(0, 0, c.width.z), vec3(0, 0, 1), c.texID), false);\n        p = ray.o + hZ.dist * ray.d;\n        if(abs(dot(p, vec3(1, 0, 0))) > c.width.x || abs(dot(p, vec3(0, 1, 0))) > c.width.y)\n            hZ = HITMISS;\n\n\n        Hit final = unionE(unionE(hX, hY), hZ);\n        final.n *= coeff;\n        return final;\n\n#else\n        vec3 p;\n        vec3 CP;\n\n        Hit hX = interPlan(ray, Plan(vec3(c.width.x, 0, 0), vec3(1, 0, 0), c.texID), false);\n        p = ray.o + hX.dist * ray.d;\n        CP = p - c.center;\n        if(abs(dot(CP, vec3(0, 1, 0))) > c.width.y || abs(dot(CP, vec3(0, 0, 1))) > c.width.z)\n            hX = HITMISS;\n\n        Hit hY = interPlan(ray, Plan(vec3(0, c.width.y, 0), vec3(0, 1, 0), c.texID), false);\n        p = ray.o + hY.dist * ray.d;\n        CP = p - c.center;\n        if(abs(dot(CP, vec3(1, 0, 0))) > c.width.x || abs(dot(CP, vec3(0, 0, 1))) > c.width.z)\n            hY = HITMISS;\n        \n        Hit hZ = interPlan(ray, Plan(vec3(0, 0, c.width.z), vec3(0, 0, 1), c.texID), false);\n        p = ray.o + hZ.dist * ray.d;\n        CP = p - c.center;\n        if(abs(dot(CP, vec3(1, 0, 0))) > c.width.x || abs(dot(CP, vec3(0, 1, 0))) > c.width.y)\n            hZ = HITMISS;\n\n        Hit hnX = interPlan(ray, Plan(vec3(-c.width.x, 0, 0), vec3(-1, 0, 0), c.texID), false);\n        p = ray.o + hnX.dist * ray.d;\n        CP = p - c.center;\n        if(abs(dot(CP, vec3(0, 1, 0))) > c.width.y || abs(dot(CP, vec3(0, 0, 1))) > c.width.z)\n            hnX = HITMISS;\n\n        Hit hnY = interPlan(ray, Plan(vec3(0, -c.width.y, 0), vec3(0, -1, 0), c.texID), false);\n        p = ray.o + hnY.dist * ray.d;\n        CP = p - c.center;\n        if(abs(dot(CP, vec3(1, 0, 0))) > c.width.x || abs(dot(CP, vec3(0, 0, 1))) > c.width.z)\n            hnY = HITMISS;\n        \n        Hit hnZ = interPlan(ray, Plan(vec3(0, 0, -c.width.z), vec3(0, 0, -1), c.texID), false);\n        p = ray.o + hnZ.dist * ray.d;\n        CP = p - c.center;\n        if(abs(dot(CP, vec3(1, 0, 0))) > c.width.x || abs(dot(CP, vec3(0, 1, 0))) > c.width.y)\n            hnZ = HITMISS;\n\n        return unionE(unionE(unionE(hX, hnX), unionE(hY, hnY)), unionE(hZ, hnZ));\n#endif\n    }\n    else\n    {\n        ray.o -= c.center;\n\n        vec3 divider = abs(ray.o);\n        if(ray.o.x == 0.0) divider.x = 1.0;\n        if(ray.o.y == 0.0) divider.y = 1.0;\n        if(ray.o.z == 0.0) divider.z = 1.0;\n        vec3 coeff = ray.o / divider;\n\n        ray.o *= coeff;\n\n        vec3 distXYZ = ray.o - c.width;\n        dist = max(distXYZ.x, max(distXYZ.y, distXYZ.z));\n\n        if(dist == distXYZ.x) norm = vec3(1, 0, 0);\n        if(dist == distXYZ.y) norm = vec3(0, 1, 0);\n        if(dist == distXYZ.z) norm = vec3(0, 0, 1);\n        \n        norm *= coeff;\n    }\n    return Hit(\n        dist,\n        norm,\n        c.texID\n    );\n}\n\nstruct Tore\n{\n    vec3 A;\n    vec3 vec_perp;\n    float outter_radius;\n    float inner_radius;\n    int texID;\n};\n\n// Return the number of result\n// results are stored in the x array\nint resolvDeg2(float a, float b, float c, out float x[2])\n{\n    float det = b * b - 4.0 * a * c;\n    if(det < 0.0) \n        return 0;\n    if(det == 0.0) \n    {\n        x[0] = -b / 2.0 * a;\n        return 1;\n    }\n    else\n    {\n        x[0] = (-b - sqrt(det)) / 2.0 * a;\n        x[1] = (-b + sqrt(det)) / 2.0 * a;\n        return 2;\n    }\n}\n\n// Return the number of result\n// results are stored in the x array\nint resolvDeg3(float a, float b, float c, float d, out float x[3])\n{\n    // source : http://jp.spriet.free.fr/hkbl/complexes/Cardan_TS.pdf\n    //          https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Cardan\n    float p = -(b * b) / (3.0 * a * a) + c / a;\n    float q = (b / (27.0 * a)) * ((2.0 * b * b) / a * a - 9.0 * c / a) + d / a;\n\n    float det = q * q + (4.0 / 27.0) * p * p * p;\n\n    if(det < 0.0)\n    {\n        float u = pow((-q + sqrt(-det)) / 2.0, 1.0 / 3.0);\n        float v = pow((-q - sqrt(-det)) / 2.0, 1.0 / 3.0);\n        x[0] = u + v;\n        return 1;\n    }\n    else if(det == 0.0)\n    {\n        if(p == 0.0)\n        {\n            x[0] = 0.0;\n            return 1;\n        }\n        else \n        {\n            x[0] = (3.0 * q) / p;\n            x[1] = (-3.0 * q) / 2.0 * p;\n            return 2;\n        }\n    }\n    else\n    {\n        for(int k = 0; k < 3; k++)\n            x[k] = 2.0 * sqrt(-p / 3.0) * cos(1.0 / 3.0 * acos(3.0 * q / 2.0 * p * sqrt(3.0 / -p) + 6.283 * float(k) / 3.0));   \n        \n        return 3;\n    }\n}\n\n// Return the number of result\n// results are stored in the x array\nint resolvDeg4(float a, float b, float c, float d, float e, out float x[12])\n{\n    // source : https://fr.wikipedia.org/wiki/%C3%89quation_quartique#%C3%89limination_du_terme_de_degr%C3%A9_3\n    float p = c / a - (3. * b * b) / (8. * a * a);\n    float q = d / a - (b * c) / (2. * a * a) + (b * b * b) / (8. * a * a * a);\n    float r = e / a - (b * d) / (4. * a * a) + (c * b * b) / (16. * a * a * a) - (3. * b * b * b * b) / (256. * a * a * a * a);\n\n    // source : https://fr.wikipedia.org/wiki/M%C3%A9thode_de_Descartes\n    float A[3];\n    int sol0 = resolvDeg3(\n        1.0,\n        2.0 * p,\n        1.0 - 4.0 * r,\n        p * p - q * q,\n        A\n    );\n\n    int total_sol = 0;\n    for(int i = 0; i < sol0; i++)\n    {\n        a = sqrt(A[i]);\n        b = (p + a * a - q / a) / 2.0;\n        c = (p + a * a + q / a) / 2.0;\n\n        float z0[2], z1[2];\n        int sol1 = resolvDeg2(1.0, a, b, z0);\n        int sol2 = resolvDeg2(1.0, -a, c, z1);\n\n        for(int j = 0; j < sol1; j++)\n            x[total_sol++] = z0[j];\n        for(int j = 0; j < sol2; j++)\n            x[total_sol++] = z1[j];\n    }\n    return total_sol;\n}\n\nfloat smallestPositiveValue(float val[12], int array_size)\n{\n    float ret = -1.0;\n    bool initialized = false;\n    for(int i = 0; i < array_size; i++)\n    {\n        if(val[i] >= 0.0 && (val[i] < ret || !initialized))\n        {\n            ret = val[i];\n            initialized = true;\n        }\n    }\n    return ret;\n}\n\nHit interTore(Ray ray, Tore tore, bool sdf)\n{\n    if(!sdf)\n    {\n    // Coefficient du tore\n        // source : http://heigeas.free.fr/laure/ray_tracing/tore.html\n        // d0 : ray.d.x   |   p0 : ray.o.x\n        // d1 : ray.d.z   |   p1 : ray.o.z\n        // d2 : ray.d.y   |   p2 : ray.o.y\n\n        float rayd_rayd = dot(ray.d, ray.d);\n        float rayd_rayo = dot(ray.d, ray.o);\n        float rayo_rayo = dot(ray.o, ray.o);\n        float Rsqr = tore.outter_radius * tore.outter_radius;\n        float rsqr = tore.inner_radius * tore.inner_radius;\n\n        // a = (d0² + d1² + d2²)²\n        float a = rayd_rayd * rayd_rayd; \n        // b = 4 (d0² + d1² + d2²)(d0 p0 + d1 p1 + d2 p2)\n        float b = 4. * rayd_rayd * rayd_rayo; \n        // c = 2 (d0² + d1² + d2²)(p0² + p1² + p2² + R² - r²) + (d0 p0 + d1 p1 + d2 p2)² - 4 R² (d0² + d2²)\n        float c = 2. * rayd_rayd * (rayo_rayo + Rsqr - rsqr) + rayd_rayo * rayd_rayo - 4. * Rsqr * (ray.d.x * ray.d.x + ray.d.y * ray.d.y); \n        // d = 4 (d0 p0 + d1 p1 + d2 p2) (p0² + p1² + p2² + R² - r²) - 8 R² (d0 p0 + d2 p2)\n        float d = 4. * rayd_rayo * (rayo_rayo + Rsqr - rsqr) - 8. * Rsqr * (ray.d.x * ray.o.x + ray.d.y * ray.o.y);\n        // e = (p0² + p1² + p2² + R² - r²)² - 4 R² (p0² + p2²)\n        float e = (rayo_rayo + Rsqr - rsqr); e = e * e - 4. * Rsqr * (ray.o.x * ray.o.x + ray.o.y * ray.o.y);\n        \n\n    // Résolution équation\n        float dist[12];\n        int nbSol = resolvDeg4(a, b, c, d, e, dist);\n        float finalDist = smallestPositiveValue(dist, nbSol);\n        if(finalDist < 0.0)\n            return HITMISS;\n\n        return Hit(\n            finalDist,\n            vec3(0, 1, 0),\n            tore.texID\n        );\n    }\n    else\n    {\n        vec3 AP = ray.o - tore.A;\n        float side_tri = dot(AP, tore.vec_perp);\n        float base_tri = sqrt(length(AP) * length(AP) - side_tri * side_tri) - tore.outter_radius;\n        float dist = sqrt(side_tri * side_tri + base_tri * base_tri) - tore.inner_radius;\n        \n        vec3 center = tore.A + normalize(cross(cross(tore.vec_perp, AP), tore.vec_perp)) * tore.outter_radius;\n        \n        return Hit(\n            dist,\n            normalize(ray.o - center),\n            tore.texID\n        );\n    }\n}\n\n\n//\n//      Bruits et turbulance\n//\n\n\n// source: https://www.shadertoy.com/view/4djSRW (hash13)\nfloat fHash(vec3 p)\n{\n    p  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);\n}\n\n// source: https://www.shadertoy.com/view/4djSRW (hash33)\nvec3 vHash(vec3 p)\n{\n    p = fract(p * vec3(.1031, .1030, .0973));\n    p += dot(p, p.yxz+33.33);\n    return fract((p.xxy + p.yxx)*p.zyx);\n}\n\n// Récupérés des anciens shader de L2\n// https://www.shadertoy.com/view/stjcRc\nfloat fNoise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( fHash(i+vec3(0,0,0)), \n                        fHash(i+vec3(1,0,0)),f.x),\n                   mix( fHash(i+vec3(0,1,0)), \n                        fHash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( fHash(i+vec3(0,0,1)), \n                        fHash(i+vec3(1,0,1)),f.x),\n                   mix( fHash(i+vec3(0,1,1)), \n                        fHash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nvec3 vNoise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n\n    return normalize(mix(mix(mix( vHash(i+vec3(0,0,0)), \n                        vHash(i+vec3(1,0,0)),f.x),\n                   mix( vHash(i+vec3(0,1,0)), \n                        vHash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( vHash(i+vec3(0,0,1)), \n                        vHash(i+vec3(1,0,1)),f.x),\n                   mix( vHash(i+vec3(0,1,1)), \n                        vHash(i+vec3(1,1,1)),f.x),f.y),f.z));\n}\n\nfloat fTurbulence(vec3 p, int count, float amplitude, float frequence)\n{\n    float res = 0.0;\n\n    for(int i = 0; i < count; i++)\n    {\n        res += amplitude * fNoise(p * frequence);\n        amplitude *= 0.5;\n        frequence *= 2.0;\n    }\n    return res;\n}\n\nvec3 vTurbulence(vec3 p, int count, float frequence)\n{\n    vec3 res = vec3(0.0);\n    float amplitude = 1.0;\n\n    for(int i = 0; i < count; i++)\n    {\n        res += amplitude * vNoise(p * frequence);\n        amplitude *= 0.5;\n        frequence *= 2.0;\n    }\n    return normalize(res);\n}\n\nstruct ObjectInfo\n{\n    vec3 ambiantColor;\n    vec3 diffusColor;\n    vec3 speculaireColor;\n    float speculaireCoeff;\n    float reflexionCoeff;\n    float refractionCoeff;\n    float transparenceCoeff;\n    bool transparent;\n    vec3 normalDisplacement;\n};\n\n/*\nTemplate\n\nreturn ObjectInfo(\n    vec3(0.0), // ambiantColor\n    vec3(0.0), // // diffusColo\n    vec3(0.0), // speculaireColor\n    1.0, // speculaireCoeff\n    0.0, // reflexionCoeff\n    0.0, // refractionCoeff\n    0.0, // transparenceCoeff\n    false, // transparent\n    vec3(0.0) // normalDisplacement\n);\n*/\n\n#define AIR 0\n#define ROUGE 1\n#define VERT 2\n#define BLEU 3\n#define MIROIR 4\n#define SEMI_MIROIR 5\n#define LIGHT 6\n#define DAMIER 7\n#define VERRE 8\n#define TRANSLUCIDE 9\n#define METALBROSSE 10\n\nObjectInfo Air(vec3 p)\n{\n    float coeff = clamp(0.0, 1000.0, p.y) / 1000.0;\n    vec3 ambiant = (1.0 - coeff) * vec3(0.886, 0.753, 0.576) * 0.5 + coeff * vec3(0.886, 0.596, 0.576) * 0.5;\n\n    return ObjectInfo(\n        ambiant,\n        vec3(0),\n        vec3(0),\n        1.0,\n        0.0,\n        0.0,\n        0.0,\n        false,\n        vec3(0.0)\n    );\n}\n\nObjectInfo Damier(vec3 p)\n{\n    p *= 0.2;\n    vec3 pp = fract(p);\n    p = floor(p);\n\n    vec3 ambiant = vec3(0.05, 0.02, 0.0);\n    vec3 diffus = vec3(0.588, 0.408, 0.345);\n    float refl = 0.0;\n    vec3 normDiff = vec3(0.0);\n    \n    // damier\n    if((int(p.x) + int(p.y) + int(p.z)) % 2 == 0)\n    {\n        ambiant = vec3(0.01, 0.01, 0.01);\n        diffus = vec3(0.918, 0.807, 0.678);\n        refl = 0.0;\n    }\n\n    // côté biseauté\n    float edgeWidth = 0.025;\n    if(pp.x > 1. - edgeWidth)\n        normDiff += vec3(1., 0., 0.);\n    else if(pp.x < edgeWidth)\n        normDiff += vec3(-1., 0., 0.);\n\n    if(pp.y > 1. - edgeWidth)\n        normDiff += vec3(0., 1., 0.);\n    else if(pp.y < edgeWidth)\n        normDiff += vec3(0., -1., 0.);\n\n    if(pp.z > 1. - edgeWidth)\n        normDiff += vec3(0., 0., 1.);\n    else if(pp.z < edgeWidth)\n        normDiff += vec3(0., 0., -1.);\n\n    return ObjectInfo(\n        ambiant,\n        diffus,\n        vec3(0.5, 0.5, 0.5),\n        100.0,\n        refl,\n        1.252,\n        0.0,\n        false,\n        normDiff\n    );\n}\n\nObjectInfo MetalBrosse(vec3 p)\n{\n    // vec3 diff1 = vec3(0.749);\n    // vec3 diff2 = vec3(0.588);\n\n    float delta = fNoise(vec3(p.y + 0.1) * 10.) - fNoise(vec3(p.y - 0.1) * 20.);\n    vec3 normDisp = vec3(0.);\n\n    if(delta < 0.0)\n        normDisp = vec3(0., 1., 0.);\n    else\n        normDisp = vec3(0., -1., 0.);\n    normDisp *= 0.1;\n\n    return ObjectInfo(\n        vec3(0.066), // ambiantColor\n        vec3(0.666), // // diffusColo\n        vec3(0.0), // speculaireColor\n        1000.0, // speculaireCoeff\n        0.0, // reflexionCoeff\n        0.0, // refractionCoeff\n        0.0, // transparenceCoeff\n        false, // transparent\n        normDisp // normalDisplacement\n    );\n}\n\n\nObjectInfo getTexture(int index, vec3 p)\n{\n    switch(index)\n    {\n    case AIR:\n        return Air(p);\n    case ROUGE:\n        return ObjectInfo(\n            vec3(0.1, 0, 0),\n            vec3(0.819, 0.27, 0.368),\n            vec3(0.5, 0.5, 0.5),\n            100.f,\n            0.f,\n            0.f,\n            0.f,\n            false,\n            vec3(0.0)\n        );\n    case VERT:\n        return ObjectInfo(\n            vec3(0, 0.1, 0),\n            vec3(0.298, 0.909, 0.533),\n            vec3(0.5, 0.5, 0.5),\n            // vec3(50.0, 50.0, 50.0),\n            100.f,\n            0.f,\n            0.f,\n            0.f,\n            false,\n            vec3(0.0)\n        );\n    case BLEU:\n        return ObjectInfo(\n            vec3(0, 0, 0.1),\n            vec3(0.321, 0.384, 0.847),\n            vec3(0.5, 0.5, 0.5),\n            100.f,\n            0.f,\n            0.f,\n            0.f,\n            false,\n            vec3(0.0)\n        );\n    case MIROIR:\n        return ObjectInfo(\n            vec3(0),\n            vec3(0),\n            vec3(0),\n            1.f,\n            1.f,\n            0.f,\n            0.f,\n            false,\n            vec3(0.0)\n        );\n    case SEMI_MIROIR:\n        return ObjectInfo(\n            vec3(0, 0.1, 0),\n            vec3(0.298, 0.909, 0.533),\n            vec3(0.5, 0.5, 0.5),\n            100.f,\n            0.5f,\n            0.f,\n            0.f,\n            false,\n            vec3(0.0)\n        );\n    case LIGHT:\n        return ObjectInfo(\n            vec3(0.0878, 0.0843, 0.0588),\n            vec3(0.878, 0.843, 0.588),\n            vec3(1.0, 0.5, 0.5),\n            1.f,\n            0.f,\n            0.f,\n            0.f,\n            true,\n            vec3(0.0)\n        );\n    case DAMIER:\n        return Damier(p);\n    case VERRE:\n        return ObjectInfo(\n            vec3(0.0, 0.5, 0.3),\n            vec3(0.0, 0.01, 0.005),\n            vec3(0.0),\n            1.0,\n            0.1,\n            1.52, // 1.52 normalement\n            1.0,\n            false,\n            vec3(0.0)\n        );\n    case TRANSLUCIDE:\n        return ObjectInfo(\n            vec3(0.5), // ambiantColor\n            vec3(0.0), // // diffusColo\n            vec3(0.0), // speculaireColor\n            1.0, // speculaireCoeff\n            0.0, // reflexionCoeff\n            1.252, // refractionCoeff\n            0.5, // transparenceCoeff\n            false, // transparent\n            0.5 * vTurbulence(p, 3, 1.) // normalDisplacement\n        );\n    case METALBROSSE:\n        return MetalBrosse(p);\n    }\n}\n","name":"Common","description":"","type":"common"}]}