{"ver":"0.1","info":{"id":"XcG3Wc","date":"1713662706","viewed":168,"name":"Argon Argyle Visualizer","username":"FatLenny","description":"Playing with rotation, tiling and colors","likes":9,"published":1,"flags":4,"usePreview":0,"tags":["fractal","fractal","basic","interactive","tutorial","music","music","abstract","visualizer","rainbow","trippy","kaliedoscops"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGRr","filepath":"/presets/mic.png","previewfilepath":"/presets/mic.png","type":"mic","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Neon River Visualizer\" by FatLenny. https://shadertoy.com/view/Xfy3D3\n// 2024-04-17 04:50:23\n\nfloat fractHash(vec2 p) {\n  p = fract(p * vec2(123.34, 456.21));\n  p += dot(p, p+45.32);\n  \n  return fract(p.x*p.y);\n}\n\nvec3 hash( vec3 p )      // this hash is not production ready, please\n{                        // replace this by something better\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nmat2 Rot(float a) {\n  float c = cos(a), s = sin(a);\n  return mat2(c, -s, s, c);\n}\n\n// NOISE\n// returns 3D value noise (in .x)  and its derivatives (in .yzw)\nvec4 noised( in vec3 x )\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du = 30.0*w*w*(w*(w-2.0)+1.0);\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    float v = va + \n              u.x*(vb-va) + \n              u.y*(vc-va) + \n              u.z*(ve-va) + \n              u.x*u.y*(va-vb-vc+vd) + \n              u.y*u.z*(va-vc-ve+vg) + \n              u.z*u.x*(va-vb-ve+vf) + \n              u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n              \n    vec3 d = ga + \n             u.x*(gb-ga) + \n             u.y*(gc-ga) + \n             u.z*(ge-ga) + \n             u.x*u.y*(ga-gb-gc+gd) + \n             u.y*u.z*(ga-gc-ge+gg) + \n             u.z*u.x*(ga-gb-ge+gf) + \n             u.x*u.y*u.z*(-ga+gb+gc-gd+ge-gf-gg+gh) +   \n             \n             du * (vec3(vb-va,vc-va,ve-va) + \n                   u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + \n                   u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + \n                   u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) );\n                   \n    return vec4( v, d );                   \n}\n\n\n// GRADIENTS    \nvec3 palette( float t, float change ) {\n\n    vec4 sound = texture(iChannel0,vec2(.6,.2));\n    vec3 a = vec3(0.5, 0.5, 0.5);\n    vec3 b = vec3(1.000,0.949,0.5);\n    vec3 c = vec3(1.0, 0.5, 1.0);\n    vec3 d = vec3(0.8,0.0,0.0);\n    \n    //a.x *= iTime*0.001;1\n    a.x += smoothstep(0.0, 0.8,sound.x*0.5);\n    a.y += smoothstep(0.0, 0.8,sound.x*0.5);\n    a.z += smoothstep(0.0, 0.8,sound.x*0.5);\n    \n    //b.x += sound.x;\n    b.y += smoothstep(0.0, 1.0,sound.x*3.0);\n    b.z += sound.x*0.5;\n    \n    c.x += smoothstep(0.0, 1.0, sound.x*0.002);\n    c.y += sound.x*0.002;\n    //c.z += sound.x*0.002;\n    \n    //d.x += smoothstep(0.0, 1.2, sound.x*0.5);\n    d.y += smoothstep(0.0, 1.2, sound.x);\n    d.z += smoothstep(0.0, 1.2, sound.x);\n    \n    //a.x += iTime;\n    return a + b*cos( 6.28318*(c*t+d) );\n\n}\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    //p = p * Rot(iTime*0.1);\n    vec2 d = abs(p)-b * Rot(5.01);\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdfCoolS( in vec2 p )\n{\n    float six = (p.y<0.0) ? -p.x : p.x;\n    p.x = abs(p.x);\n    p.y = abs(p.y) - 0.2;\n    p = abs(p * Rot(iTime*0.1));\n    float rex = p.x - min(round(p.x/0.4),0.4);\n    float aby = abs(p.y-0.2)-0.6;\n    \n    float d = dot2(vec2(six,-p.y)-clamp(0.5*(six-p.y),0.0,0.2));\n    d = min(d,dot2(vec2(p.x,-aby)-clamp(0.5*(p.x-aby),0.0,0.4)));\n    d = min(d,dot2(vec2(rex,p.y  -clamp(p.y          ,0.0,0.4))));\n    \n    float s = 2.0*p.x + aby + abs(aby+0.4) - 0.4;\n    return sqrt(d) * sign(s);\n}\n\nfloat sdCircleWave( in vec2 p, in float tb, in float ra )\n{\n    tb = 3.1415927*4.5/6.0*max(tb,0.0001);\n    vec2 co = ra*vec2(sin(tb),cos(tb));\n    p.x = abs(mod(p.x,co.x*4.0)-co.x*2.0);\n    vec2  p1 = p;\n    vec2  p2 = vec2(abs(p.x-2.0*co.x),-p.y+2.0*co.y);\n    float d1 = ((co.y*p1.x>co.x*p1.y) ? length(p1-co) : abs(length(p1)-ra));\n    float d2 = ((co.y*p2.x>co.x*p2.y) ? length(p2-co) : abs(length(p2)-ra));\n    return min(d1, d2); \n}\n\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.86602540378,0.57735026919,1.73205080757);\n    \n    p = abs(p * Rot(iTime*0.1));\n    //*****p *= Rot(iTime*0.1)// rotates something in here\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    \n    return length(p)*sign(p.y);\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec4 sound = texture(iChannel0,vec2(.6,.2));\n    float smoothSound = smoothstep(0.0, 1.0, sound.x);\n        \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 M = (iMouse.xy - iResolution.xy*.5)/iResolution.y;   \n        \n    vec2 uv0 = uv; // *uv0* is the GLOBAL center of the canvas\n      \n    vec3 finalColor = vec3(0.0);\n\n    //uv = fract(uv * 0.8) - 0.5;\n    uv = uv + abs(3.0);\n    uv *= Rot(iTime*0.1);//Rotates the whole canvas\n\nfor(float i = 0.0; i< 4.2*abs(cos(iTime*0.05)*2.5); i++){ \n    vec2 fRot = fract(uv * Rot(iTime*0.1));\n    vec2 uvRot = uv * Rot(iTime*0.1);\n    vec2 uv0Rot = uv0 * Rot(iTime*0.1);\n    \n    uv += M;\n    uv = fract(uv * 0.8) - 0.5;\n    \n    \n    //uv = (uv * 1.5) - 0.5 ;\n    uv = abs((uv * 2.0)) - (0.8 *iTime/20000.0) ; //adding abs here undoes some transform to make it a fractal in the centyer again\n    //uv = abs(fract(uv * 1.4) - 0.5) ; // addingt abs here makes it tile seamlessly \n    uv =  abs(uv * Rot(iTime*0.1));//rotates each individual uvm the multiplication iterates\n    //uv = fract(uv * 0.8) - 0.5;\n    //uv0 *= fRot;\n    \n    float d = length(uv) * exp(-length(uv0 *2.0 )); // THIS CHANGES THINGS BASED ON THE DISTANCE TO THE CENTER OF THE CANVAS         \n\n    vec3 col = palette(length(uv) + i*5.6 + iTime*0.2, iTime);\n    //col.x = col.x + iTime;\n\n    \n    d = sin(d *0.8 + iTime*0.1)/8.0;\n    \n    d += sdArc(uv,uv, 0.7, iTime*0.0002);\n    \n    d += sdBox(uv, uv) - smoothstep(0.0, 1.5, sound.x*1.5);//WOAH\n    \n    d += sdHexagram( uv, 1.25 );\n    //d += sdHexagram( uv, 1.35 )+ smoothstep(0.0, 1.5, sound.x*1.5);\n    \n    d += sdfCoolS(uv0);\n    \n    d += sdfCoolS(uv0)*iTime*0.0002;\n    \n    //d += sdArc(uv,uv, 0.7, iTime*0.00002);\n    //d += sdCircleWave(uv, 1.0, 1.0);\n        \n    d = abs(d);\n       \n    //d = pow(0.001 / d, 0.5 + smoothstep(0.0, 1.3, sound.x*0.1));   \n    //d = pow(0.001 / d, 0.5 + smoothstep(0.0, 1.0, sound.x*0.5));\n    //d = pow(0.001 / d, 0.5);\n    \n    d = pow(0.01 / d, 0.7 + smoothstep(0.0, 1.3, sound.x*.0095));//THESE TOGETHER LOOK AMAZING\n    \n    //d = pow(0.000001 / d, 0.08);//BRIGHT SOFT VERSION \n    //d = pow(0.1 / d, 1.0);//ADD THIS TO SOFT FOR INVERTED VERSION\n    //d = pow(0.01 / d, 0.8);//EDGES VERSION\n     \n    //d = pow(0.01 / d, 0.8); // POWER FUNCTION\n        \n    //col.x = col.x + iTime*0.006;\n    finalColor += col * d;\n    \n}           \n    vec4 noise = noised(finalColor);\n          \n    fragColor = vec4(finalColor, 1.0);//NOT FOR TESTING\n      \n}   \n","name":"Image","description":"","type":"image"}]}