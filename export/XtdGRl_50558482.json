{"ver":"0.1","info":{"id":"XtdGRl","date":"1488682168","viewed":1268,"name":"raymarched fog volume","username":"chadmiral","description":"raymarch experiment bed\ncurrently only takes into account light absorption (not scatter)\nmove the light with the mouse!","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","fog","absorption"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_DIST      2.5\n#define MARCH_COUNT     20\n#define SCATTER_DEPTH   10\n#define SCATTER_DIST    2.5\n#define SPHERE_RADIUS   2.4\n#define SPHERE_DENSITY  3.0\n//#define LIGHT_POS vec3(1.0 * cos(iTime), 10.0, 15.0)\n#define LIGHT_COLOR 1.2 * vec3(0.5, 0.5, 1.0)\n#define ABSORPTION_COLOR 0.0028 * vec3(1.0, 0.85, 0.7)\n#define VOLUME_COLOR 0.045 * vec3(1.0, 0.75, 0.3)\n#define NOISE_SCALE 1.2\n#define BG_COLOR 1.3 * vec3(0.15, 0.25, 0.25)\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f * f * (3.0 - 2.0 * f);\n \n    float n = p.x + p.y * 57.0 + 113.0 * p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat get_density_at_pos(vec3 p)\n{\n    float d = (SPHERE_RADIUS - length(p)) / SPHERE_RADIUS;\n    float noise_mult = fbm(NOISE_SCALE * (p + vec3(0.0, 0.0, iTime)));\n    return clamp(noise_mult * SPHERE_DENSITY * d, 0.0, 1.0);\n}\n\n//TODO: actual Rayleigh scattering\nvec3 get_scatter_color(vec3 p)\n{\n    float absorption = 0.0;\n    vec2 m = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    vec3 light_pos = vec3(20.0 * m, 10.0);\n    vec3 light_dir = normalize(light_pos - p);\n    \n    float t = 0.0;\n    float rd = SCATTER_DIST / float(SCATTER_DEPTH);\n    \n    for(int i = 0; i < SCATTER_DEPTH; i++)\n    {\n    \tvec3 sp = p + t * light_dir;\n        float d = get_density_at_pos(sp);\n        absorption += d;\n    \tt+= rd;\n    }\n    \n   \n    return clamp(LIGHT_COLOR * VOLUME_COLOR - absorption * ABSORPTION_COLOR, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//1 : retrieve the fragment's coordinates\n\tvec2 uv = ( fragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n\t//preserve aspect ratio\n\tuv.x *= iResolution.x / iResolution.y;\n\n\n\t//2 : camera position and ray direction\n\tvec3 pos = vec3( 0.,0.,-3.);\n\tvec3 dir = normalize( vec3( uv, 1. ) );\n\n\tvec3 ip;\n    float t = 0.0;\n    float density = 0.0;\n    vec3 march_color = BG_COLOR;\n    float rd = MARCH_DIST / float(MARCH_COUNT);\n    for(int i = 0; i < MARCH_COUNT; i++)\n    {\n        ip = pos + dir * t;\n        float d = get_density_at_pos(ip);\n\n        density += d;\n        vec3 c = get_scatter_color(ip);\n        march_color += density * c;\n        t += rd;\n    }\n    \n\n\t//4 : apply color to this fragment\n\tfragColor = vec4(march_color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}