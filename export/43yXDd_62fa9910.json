{"ver":"0.1","info":{"id":"43yXDd","date":"1720614150","viewed":113,"name":"rotating knitting","username":"zhangrm","description":"A knitting masterpiece looks like a galaxy.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","sdf","spiral","random","galaxy","hubble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ref: https://shadertoy.com/view/ct2yDd\n\n#define PI 3.1415926\n#define PI2 6.283186\n#define e 2.71828\n\nfloat hashwithoutsine11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat noise1d(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    \n    return mix(hashwithoutsine11(i), hashwithoutsine11(i+1.0), smoothstep(0.0, 1.0, f));\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,711.7)),\n              dot(st,vec2(619.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*23758.545123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvec3 rotZ(vec3 p, float angle) {\n    \n    mat3 m = mat3(cos(angle), -sin(angle), 0.0,\n                  sin(angle), cos(angle), 0.0,\n                  0.0, 0.0, 1.0);\n                  \n    return m * p;\n}\n\n/*\nFractal brownian motion\nIs about adding noise together. From book of shaders:\nBy adding different iterations of noise (octaves), where we successively \nincrement the frequencies in regular steps (lacunarity) and decrease the amplitude (gain) \nof the noise we can obtain a finer granularity in the noise and get more fine detail. \nThis technique is called \"fractal Brownian Motion\" (fBM), or simply \"fractal noise\".\n\nFor each octave(iteration): Increase the frequency of the wave(by 2.0) -> Called the lacunarity value.\n                            Decrease the amplitude of the wave(by 0.5) -> Called the gain.\n*/\nfloat fbm(vec2 uv, float seed, int o, float l, float g, float a, float f, bool rot, bool absolute) {\n    float fbm = 0.0;\n    \n\n    int octaves = o;//16;\n    float lacunarity = l;//8.0;\n    float gain = g;//0.85;\n \n    float amplitude = a;//0.5;\n    float frequency = f;//10.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        float newVal = amplitude * noise(uv * frequency + seed);\n        \n        if (absolute) newVal = abs(newVal);\n        \n        fbm += newVal;\n        \n        if (rot) uv = rotZ(vec3(uv.x, uv.y, 0.0), float(i)).xy;\n        \n        frequency *= lacunarity;\n        amplitude *= gain;\n    \n    }\n    \n    return fbm;\n}\n\nfloat dwPattern(vec2 p) {\n    \n    float n = 0.0;\n\n    \n    vec2 q = vec2(fbm(p + vec2(20.0, 0.0), 549.0, 8, 1.3, 0.75, 0.85, 0.45, true, true), fbm(p + vec2(3.6, 4.2), 339.0, 8, 1.3, 0.75, 0.85, 0.45, true, false));\n    \n    n = fbm(p + q, 784.0, 6, 2.5, 0.35, 0.003, 2.75, true, false);\n\n    \n    return n*1.0;\n\n}\n\nvec3 galaxy(vec2 uv, vec2 polarUV, vec3 col) {\n    \n    float size = 25.0;\n    float len = polarUV.x * size;\n    float angle = polarUV.y;\n\n    float d = abs(mod(len - angle * 4.0, PI2) - PI);\n    float spiralD = d;\n\n    float spiralAngle = angle + (PI2 * floor(len / PI2));\n\n    float spiralArmRadius = 3.0;\n    spiralD = 1.0 - smoothstep(0.0, spiralArmRadius, spiralD);\n\n    spiralD *= smoothstep(1.0, 0.0, length(uv)) * 150.0;\n    \n    float starN = fbm(uv, 239.0, 8, 1.8, 0.85, 0.5, 10.0, true, false);\n    \n    float starN2 = fbm(uv, 69.0, 8, 1.8, 0.85, 0.5, 10.0, true, false);\n    \n    starN = starN * starN * starN * starN * starN;\n    starN2 = starN2;\n\n    float cloudN = dwPattern(uv);\n\n    float galaxyColorInput = len * 0.1 + 169.0 + noise1d(angle * 1.0 + 55.0);\n    vec3 galaxyCol = hash31(ceil(galaxyColorInput));\n    vec3 nextGalaxyCol = hash31(ceil(galaxyColorInput + 1.0));\n    \n    galaxyCol = mix(galaxyCol, nextGalaxyCol, smoothstep(0.5, 1.0, fract(galaxyColorInput)));\n    \n    galaxyCol *= vec3(1.0, 0.2, 1.74);\n    \n    vec3 cloudCol = cloudN * galaxyCol;\n    \n    vec3 starCol = mix(vec3(0.0), galaxyCol, 1.0 - exp(starN * 50.0));\n    \n    vec3 starCol2 = mix(vec3(0.0), vec3(1.0, 1.0, 1.0), 1.0 - exp(starN2 * 10.0));\n    \n    vec3 combinedStarCol = max(starCol / starCol2, 0.0);\n    \n    vec3 finalCol = mix(vec3(0.0), combinedStarCol, spiralD);\n    \n    finalCol += mix(vec3(0.0), cloudCol * 10.0, spiralD * 0.25 + smoothstep(1.25, 0.0, length(uv)) * 20.0);\n    \n    return finalCol;\n}\n\nvec3 getNormal(vec2 uv, float eps) {\n    vec3 h = galaxy(uv, vec2(0.0), vec3(0.0));\n    vec3 n;\n    n.x = galaxy(uv + vec2(eps, 0.0), vec2(0.0), vec3(0.0)).r - h.r;\n    n.y = galaxy(uv + vec2(0.0, eps), vec2(0.0), vec3(0.0)).r - h.r;\n    n.z = eps;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    uv = (uv * 2.0) - 1.0;\n    \n    vec3 col = vec3(0.0);\n    \n    float ar = iResolution.x / iResolution.y;\n    \n    uv.x *= ar;\n    \n\n    uv = (rotZ(vec3(uv.x, uv.y, 0.0), iTime * 0.1)).xy;\n    \n    vec2 polarUV = vec2(length(uv), atan(uv.y, uv.x) + PI);\n    \n    col = galaxy(uv, polarUV, col);\n    vec3 lightPos = vec3(0.5 * sin(iTime), 0.5 * cos(iTime), 0.5); \n    vec3 normal = getNormal(uv, 0.001);\n    vec3 lightDir = normalize(lightPos - vec3(uv, 0.0));\n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = diff * vec3(1.0, 0.9, 0.7); \n\n    vec3 viewDir = normalize(-vec3(uv, 0.0));\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specular = spec * vec3(1.0, 1.0, 1.0);\n    \n    col = col * 0.3 + diffuse + specular;\n    \n    col = pow(col, vec3(.4545)); \n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}