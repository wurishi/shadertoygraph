{"ver":"0.1","info":{"id":"X3SBDD","date":"1729534873","viewed":141,"name":"UFFFD raymarch starter 2024","username":"ufffd","description":"raymarcher with my opinionated set of starter functions and format","likes":3,"published":3,"flags":16,"usePreview":0,"tags":["template"],"hasliked":0,"parentid":"DdVBR3","parentname":"UFFFD barebones starter 2023"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Docs for Common tab content\n-- CONSTANTS\nPI & TAU: π and τ (2π)\nDEBUG (0|1): Toggle debug mode. Usage: `#if DEBUG ... #endif`\nSPEED: Adjusts the speed of T, sT, mT:\nT:  Time variable scaled by `SPEED`\nsT: Sinusoidal time, ranges smoothly from 0 to 1 and back\nmT: Modulo time, cycles from 0 to 1 repeatedly\n-- SMOOTHSTEP\nS: Alias for `smoothstep`\nSS(a, b, c): Symmetric smoothstep around `a` with width `b`. Use negative b to flip\n-- UTILITY\nrot(a): 2D rotation matrix for angle `a`. Usage: `myangle *= rot(0.5);`\nnearly(a, b, k*): Checks if `a` is approximately equal to `b` (within k, default 0.001)\nluminance(c): Calculates the luminance (brightness) of color `c`\n-- COLOR\nhsv2rgb_smooth(c): Converts HSV color `c` to RGB\nrgb2hsv(c): Converts RGB color `c` to HSV\n-- NORMALIZED\nnmod(x): Modulo operation, result between 0 and 1\nnsin(x): Normalized sine function\nnclamp(x): Clamps scalar or vector `x` between 0 and 1\n-- RANDOM & NOISE\nrand(n): Generates a pseudo-random float based on `n`\nnoise(p): 2D noise function at position `p`\npermute(x): Permutation function for noise algorithms\nhash11(p): Hash function producing a float between 0 and 1. See Hoskins page for more hashes\n-- KEYBOARD\nkey(k, mode): Checks if key `k` is in `mode` (requires `iChannel3` set to keyboard)\nkeyDown(k): Checks if key `k` is currently pressed\nKEY_SPACEBAR: Keycode for the spacebar (32)\n*/// Have fun!\n\n#define R (iResolution.xy)\n#define EPSILON 0.0001\n#define STEP_MAX 160.\n// RAY_MAX > 1 is pretty busted currently\n#define RAY_MAX 1.\n#define SPECULAR_POWER 100.\n#define SPECULAR_INTENSITY .5\n\n\n// raymarch setup & utils\n\n// define textures\nstruct Tex {\n    vec3  c; // color\n    float m; // mirror\n    // add more material data:\n    float r; // rough\n    // metal - maybe replace mirror\n    // specular\n    // anisotropic - does this one really matter\n    // opacity - complicated\n    // emission/glow - maybe less complicated\n    // ior\n};\n// tex setup. takes object and global position as inputs\nTex T1(in vec3 p, in vec3 gp) {\n    // green, nonreflective\n    Tex Tx;\n    Tx.c = vec3(0.,1.,0.);\n    Tx.m = 0.;\n    return Tx;\n}\nTex T2(in vec3 p, in vec3 gp) {\n    // black and white stripes\n    // the black part is reflective\n    Tex Tx;\n    float tt = iTime * 0.1;\n    float stripes = sin(40.*(p.x + sin(p.z*-.5)));\n    stripes = SS(0.,0.01,stripes);\n    Tx.c = vec3(stripes);\n    Tx.m = 1.-stripes;\n    return Tx;\n}\nTex T3(in vec3 p, in vec3 gp) {\n    // show position\n    Tex Tx;\n    Tx.c = normalize(p);\n    Tx.m = 0.;\n    return Tx;\n}\nTex T4(in vec3 p, in vec3 gp) {\n    // black mirror\n    Tex Tx;\n    Tx.c = vec3(.001);\n    Tx.m = .8;\n    return Tx;\n}\nTex T5(in vec3 p, in vec3 gp) {\n    // white mattte\n    Tex Tx;\n    Tx.c = vec3(1.);\n    Tx.m = .0;\n    return Tx;\n}\nTex T6(in vec3 p, in vec3 gp) {\n    // voronoi\n    Tex Tx;\n    Tx.c = voronoi(gp*.5 - iTime).rrr * voronoi(gp*3. - iTime) * voronoi(gp*8. - iTime);\n    Tx.c = mix(Tx.c, vec3(0.,1.8,1.),gp.y/3.);\n    Tx.c = clamp(vec3(0.),vec3(1.),Tx.c);\n    // Tx.c = hueShift(Tx.c, Tx.c.g*8.);\n    Tx.c.g -= 0.5;\n    // Tx.c = hueShift(Tx.c, noise(gp*2. + iTime*0.1)*3.);\n    Tx.m = 0.;\n    return Tx;\n}\nTex T7(in vec3 p, in vec3 gp) {\n    // horiz stripes\n    Tex Tx;\n    Tx.c = vec3(smoothstep(0.,0.01,sin(p.y*40.)));\n    Tx.m = 0.;\n    return Tx;\n}\n// structs for abstracting march process\nstruct MapData {\n    vec4  c; // color\n    float d; // distance\n    float m; // mirror\n    bool  h; // hit\n};\nstruct MarchData {\n    vec4  c; // color\n    vec3  p; // intersection point\n    float d; // distance\n    float s; // steps\n    bool  h; // hit\n    // bounces\n    // attenuation\n    // steps in this bounce\n};\nvoid drawTex(in vec3 p, in vec3 gp, inout MapData m, int tx) {\n    Tex Tx;\n    if (tx==1) Tx = T1(p,gp);\n    if (tx==2) Tx = T2(p,gp);\n    if (tx==3) Tx = T3(p,gp);\n    if (tx==4) Tx = T4(p,gp);\n    if (tx==5) Tx = T5(p,gp);\n    if (tx==6) Tx = T6(p,gp);\n    if (tx==7) Tx = T7(p,gp);\n    float color_mix = 1.; // this should be set based on material & incidence angle\n    m.c = vec4(Tx.c,color_mix);\n    m.m = Tx.m;\n}\n// 3d scene\nvoid addObject(in float sdf, in int tx, in vec3 p, in vec3 gp, inout MapData m) {\n    m.h = m.h || sdf < EPSILON; // register hit\n    if (sdf < m.d) { // this is the closest object so far\n        m.d = sdf;\n        if (m.h) drawTex(p,gp,m,tx);\n    }\n}\n//////// HERE IS WHERE THE SCENE IS DEFINED\nMapData map(in vec3 p) {\n    // returns distance to nearest surface from a given point in 3d space\n    MapData m;\n    m.d = 9999.; // start high, use min(d,x) to add geometry to scene\n    m.m = 0.; // no reflective surfaces yet\n    m.h = false; // no surfaces at all yet really\n    m.c = vec4(0.); // sure is dark in here...\n    \n    // ground/floor plane\n    float ground = p.y;\n    \n    int ground_mat = 2;\n    addObject(ground, ground_mat, p, p, m);\n    \n    vec3 orbonoi = voronoi(p/2.);\n    float orbs = orbonoi.x - .3*pow(hash11(orbonoi.z),3.);\n    int orbs_mat = 7;\n    addObject(orbs, orbs_mat, p, p, m);\n        \n    return m;\n}\n/// These can be mostly left alone, they just have to be below map()\nvec3 getNorm(vec3 p, float spread) { \n    float d = map(p).d; // Distance\n    vec2 e = vec2(.02*spread,0); // Epsilon\n    vec3 n = d - vec3(\n        map(p-e.xyy).d,  \n        map(p-e.yxy).d,\n        map(p-e.yyx).d);   \n    return normalize(n);\n}\nvec3 getNorm(vec3 p) { return getNorm(p, 0.005); /*default spread*/ }\n\n// raymarch function\nMarchData raymarch(in vec3 ro, in vec3 rd) {\n    MarchData d;\n    d.h = false;\n    d.d = 0.;\n    d.c = vec4(0.);\n    float atten = 1.;\n    for (d.s=0.;d.s<STEP_MAX;d.s++) {\n        vec3 p = ro + rd*d.d;\n        MapData m = map(p);\n        if (m.h) { // hit\n            d.h = true; // record hit\n            d.p = p; // hit location\n            d.c.rgb += m.c.rgb*m.c.a*atten; // lol. adds hit color to return color\n            if (m.m<0.01) break; // if not a mirror, we're done\n            // else, we hit a mirror. reflect and keep steppin\n            atten *= m.m;\n            vec3 n = getNorm(p);\n            rd = reflect(rd, n);\n            d.d = 0.;\n            // d.c = vec4(n,1.); break; // debug\n            ro = p + rd*EPSILON; // step away from surface\n        } else\n            d.d += m.d*0.8; // * .5; // halfstep riddim\n    }\n    return d;\n}\n//// MAIN RENDER LOOP\nvoid mainImage( out vec4 color, in vec2 xy ) {\n    // setup\n    vec2 uv = xy/R;\n    vec2 uvc = (xy-R/2.)/R.y;\n    vec3 col = vec3(0.);\n    float carloop = mod(iTime*2.-2.2,101.);\n    vec3 carpos = vec3(sin(iTime*0.3)+2.,.5,iTime*0.5);\n    carpos.y -= smoothstep(32.,40.,carloop) - smoothstep(70.,80.,carloop);\n    vec3 sideview = vec3(iMouse.xy/R,-1.);\n    // vec3 ro = iMouse.z>0.?sideview:carpos;\n    vec3 ro = carpos;\n    float fov = 0.6;\n    vec3 rd = normalize(vec3(uvc,fov));\n    \n    if (iMouse.z>0.) {\n        vec2 muv = (iMouse.xy - R/2.) / R.y;\n        rd.yz *= rot(muv.y);\n        rd.xz *= rot(muv.x);\n    } else {\n        // rd.yz = rotate(rd.yz,-0.5);\n        float lookdown = smoothstep(29.,33.,carloop) - smoothstep(36.,41.,carloop);\n        lookdown += smoothstep(70.,73.,carloop) - smoothstep(71.,81.,carloop);\n        rd.yz *= rot(-lookdown);\n        float twist = smoothstep(35.,45.,carloop) + smoothstep(75.,85.,carloop);\n        rd.xy *= rot(twist*PI);\n        if (ro.y<0.) {\n            rd.y *= -1.;\n            ro.y *= -1.;\n        }\n    }\n    \n    // raymarch\n    for (float M=0.;M<RAY_MAX;M++) { // multiple rays per pixel\n        ro += hash31(M)/100000000.; // randomize\n        MarchData d = raymarch(ro,rd);\n        vec3 raycol = d.c.rgb;\n        // col = vec3(1./d.d, d.s/STEP_MAX, float(d.h)); // debug march data\n        // col = vec3(d.d);\n        // lighting - should all of this happen within raymarch for each intersection? probably\n        vec3 n = d.h?getNorm(d.p):vec3(0,0,1);\n        n += hash33(d.p*100.)*.005; // scatter - ought to be based on material roughness\n        vec3 bounceAngle = reflect(rd,n); \n\n        float amb = d.h?0.001:0.; // add ambient light for all hit pixels\n\n        vec3 light1pos = vec3(d.p+1.);\n        vec3 light1dir = normalize(light1pos-d.p);\n        vec3 light2pos = vec3(d.p-vec3(.5,.9,1.));\n        vec3 light2dir = normalize(light2pos-d.p);\n        \n        float diff1 = max(0.0, dot(n, light1dir)) * 1.;\n        float spec1 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light1result = diff1 + spec1;\n        \n        float diff2 = max(0.0, dot(n, light2dir)) * 1.;\n        float spec2 = pow(max(0.0, dot(bounceAngle, light1dir)), SPECULAR_POWER) * SPECULAR_INTENSITY;\n        // float fade = pow (1.0 - d / RAY_LENGTH_MAX, FADE_POWER);\n        float light2result = diff2 + spec2;\n\n        raycol *= vec3(amb + light1result + light2result); // apply lighting\n        col += raycol;\n    }\n    col /= RAY_MAX;\n    // post fx\n    float gamma = 2.2;\n    col = pow(col, vec3(1.0/gamma));\n    if (keyDown(KEY_SPACEBAR))\n        col = vec3(1.);\n    #if DEBUG\n        col.b = 1.;\n    #endif\n    // Output to screen\n    color = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-- dev controls --//\n#define DEBUG 0\n#define SPEED 1.\n\n//-- constants --//\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n//-- time defines--//\n// T is time controlled by SPEED\n#define T (iTime*SPEED)\n// sT is sinusoidal time - ranges from 0 to 1 and back over time\n#define sT (tanh(fract(T)*PI*2.-PI)/2.+0.5 + floor(T))\n// mT is modulo time - from 0 to 1 cyclically over time\n#define mT (fract(T))\n\n//--smoothsteps--//\n#define S smoothstep\n#define SS(a,b,c) S(a-b,a+b,c)\n\n//--misc utility--//\n#define rot(a)      mat2( cos(a), -sin(a), sin(a), cos(a) )\nbool nearly(in float a, in float b) {return abs(a - b) < 0.001;}\nbool nearly(in float a, in float b, in float k) {return abs(a - b) < k;}\nfloat luminance(vec3 c) {return dot(c, vec3(.2126, .7152, .0722));}\n\n//--fabrice's hsv2rgb--//\nvec3 hsv2rgb_smooth( in vec3 c ){vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );rgb = rgb*rgb*(3.0-2.0*rgb);return c.z * mix( vec3(1.0), rgb, c.y);}\nvec3 rgb2hsv(vec3 c){vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));float d = q.x - min(q.w, q.y);float e = 1.0e-10;return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);}\n\n// normalized functions - return 0 to 1\nfloat nmod(in float x){return mod(x,1.);}\nfloat nsin(in float x){return sin(x)*0.5+0.5;}\nfloat nclamp(in float x){return clamp(x,0.,1.);}\nvec2 nclamp(in vec2 x){return clamp(x,0.,1.);}\nvec3 nclamp(in vec3 x){return clamp(x,0.,1.);}\nvec4 nclamp(in vec4 x){return clamp(x,0.,1.);}\n\n//--random & noise--//\n//--hoskins hash--//// Hash without Sine\n// MIT License... Copyright (c)2014 David Hoskins.[license copy below]*/\n// 1 out, 1 in\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n//  1 out, 3 in...\nfloat hash13(vec3 p3){\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n///  3 out, 3 in...\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat rand(vec2 n) {return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);}\nfloat noise(in vec2 p){vec2 ip = floor(p);vec2 u = fract(p);u = u*u*(3.0-2.0*u);float res = mix(mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);return res*res;}\nvec4 permute(vec4 x) {return mod((34.0 * x + 1.0) * x, 289.0);}\nvec3 voronoi( in vec3 x ) {\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n     for( int j=-1; j<=1; j++ )\n      for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash33( p + b );\n        float d = dot( r, r );\n        if( d < res.x ) {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        } else if( d < res.y ) {\n            res.y = d;\n        }\n    }\n    return vec3( sqrt( res ), abs(id) );\n}\n\n//--Keyboard Controls *NOTE: requires iChannel3 be set to keyboard*--//\n#define key(k,mode) ( texelFetch( iChannel3, ivec2(k,mode), 0 ).x > .5 )\n#define keyDown(k) key(k,0)\n#define KEY_SPACEBAR 32\n\n\n//--sdfs & ops--//\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdOrb(vec3 p, float b) {\n  return length(p) - b;\n}\nfloat sdGyroid(vec3 p, float b) {\n    float g = dot(sin(p),cos(p.yzx));\n    return g - b;\n}\n// ops\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\n\n\n\n\n\n\n\n/* MIT License Copy:\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/","name":"Common","description":"","type":"common"}]}