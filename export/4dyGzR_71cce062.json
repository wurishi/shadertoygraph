{"ver":"0.1","info":{"id":"4dyGzR","date":"1452867036","viewed":615,"name":"(SSS) Super Simple Sphere","username":"Emil","description":"This fabulous SSSâ„¢ shader is mostly for human consumption... It's also a great learning and reference experience for those with boots.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","simple","tutorial","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float map(vec3 p){\n    return length(p) - 1.0; // kinda simplistic for a map.., don't you think?\n}\n\nfloat trace(vec3 o, vec3 r){ // so just blindly 'look' for anything solid? ok!\n    float t = 0.0; // ok, starting at t we can only go FORWARD! CHARGE!\n    const int maxSteps = 32; // HAHA! you only get 'maxSteps' tries? looser!\n    for (int i = 0; i < maxSteps; i++){ \n        vec3 p = o + r * t; // k, so you got where you are now? Great I guess...\n        float d = map(p); // can't you find anything without relying on a map?\n        t += d * 0.5; // these boots were made for., taking a moderately small step.\n    }\n    return t; // hope it's close enough T_T\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // screen position stuff.., >_o *wink\n\tvec2 uv = fragCoord.xy / iResolution.xy; // nice screenpositions :D\n    uv = uv*2.0 -1.0; // center the uvs on screen.., you dummy\n    uv.x *= iResolution.x / iResolution.y; // comment this line out and you will be stretched with enthusiasm, kinda like this long text thingy.... Unless you have a weirdly wide monitor you weirdo!.. T_T\n    ////////////////////////////////\n    \n    \n    // What??.., is this my camera? how splendid!\n    vec3 r = normalize(vec3(uv, 1.0)); // is actually a ray from camera\n    vec3 o = vec3(0.0,0.0,-3.0); // position of camera.., so where's my camera???\n    // All I wanted was a camera and all you've given me is a pos and ray T_T\n    ////////////////////////////////\n    \n    \n    // catch my ball, will ya!?\n    float t = trace(o,r); // this is so deep\n    float fog = 1.0 / (1.0 + t * t * 0.1); // is fog\n    ////////////////////////////////\n    \n\tfragColor = vec4(vec3(fog), 1.0); // 'tis just like print command ok?\n}\n\n// filled with comments as to look more inviting to eat.\n\n\n\n\n\n\n\n// bonus below!!!\n\n\n// All the code without commenting!\n/*\nfloat map(vec3 p){\n    return length(p) - 1.0;\n}\n\nfloat trace(vec3 o, vec3 r){\n    float t = 0.0;\n    const int maxSteps = 32;\n    for (int i = 0; i < maxSteps; i++){ \n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0 -1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    vec3 o = vec3(0.0,0.0,-3.0);\n    \n    \n    float t = trace(o,r);\n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    vec3 fc = vec3(fog);\n    \n\tfragColor = vec4(fc,1.0);\n}\n*/","name":"","description":"","type":"image"}]}