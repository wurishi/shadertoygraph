{"ver":"0.1","info":{"id":"NsS3Dc","date":"1618035578","viewed":63,"name":"SDFLife","username":"jbelling","description":"First SDF renderer","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","previewfilepath":"/media/ap/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdf_sphere( vec3 p, vec3 origin, float radius )\n{\n    return length( p+origin ) - radius;\n}\n\n// sdfs from iq\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n// render code\n\nmat2 r2(float r) \n{ \n    return mat2( cos(r), sin(r), -sin(r), cos(r) ); \n}\n\nvec2 calc_dist_to_scene( vec3 p )\n{\n    vec2 new_hit, closest_hit=vec2(999.0,0.0);\n    vec3 np;\n    \n    float geom_dist, geom_scale;\n    \n    //\n    /*\n    np = p;\n    np.yz *= r2(3.14159/2.0);\n    \n    //geom_dist = sdBox( np, vec3(10.0,10.0, 10.0) );\n    //np.x += 20.0;\n    geom_dist = sdSphere( abs(np) + vec3(-20.0,0.0,0.0), 20.0 );    \n    new_hit = vec2( geom_dist, 3.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n\n    return closest_hit;\n    */\n    //\n    np = p;\n    np.yz *= r2(3.14159/2.0);\n    \n    geom_dist = sdTorus( np, vec2(10.0,0.5) );\n    new_hit = vec2( geom_dist, 1.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n\n    //\n\n    //geom_dist = sdCapsule( vec3(p.x+cos(p.y+iTime/1.0), p.y, p.z+sin(p.y+iTime/1.0)), vec3(0.0,-20.0,0.0), vec3(0.0,20.0,0.0), 0.2 );\n    geom_dist = sdCapsule( p , vec3(0.0,-20.0,0.0), vec3(0.0,20.0,0.0), 0.2 );\n    new_hit = vec2( geom_dist, 2.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n    \n    //\n\n    geom_dist = sdCapsule( p, vec3(-10.0,0.0,0.0), vec3(10.0,0.0,0.0), 0.3 );\n    new_hit = vec2( geom_dist, 5.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n    \n    //\n    \n    np = p;\n    geom_dist = sdCapsule( np, vec3(3.0+geom_scale*3.0,2.0,0.0), vec3(3.0+geom_scale*3.0,-2.0,0.0), 1.5 );\n    geom_dist = max(geom_dist,np.y);\n    new_hit = vec2( geom_dist, 4.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n        \n    //\n    \n    np = p;\n    geom_dist = sdCapsule( np, vec3(3.0+geom_scale*3.0,2.0,0.0), vec3(3.0+geom_scale*3.0,-2.0,0.0), 1.5 );\n    geom_dist = max(geom_dist,-np.y);\n    new_hit = vec2( geom_dist, 3.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n        \n    //\n    \n    np = p;\n    np.yz *= r2(3.14159/2.0);\n    \n    geom_dist = sdRoundedCylinder( np + vec3( 10.0, 0.0, 0.0), 4.0+geom_scale, 0.1, 0.5 );\n    new_hit = vec2( geom_dist, 4.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n            \n    \n    return closest_hit;\n}\n\nvec2 calc_dist_to_scene_b( vec3 p )\n{\n    vec2 new_hit, closest_hit=vec2(999.0,0.0);\n    vec3 np;\n    \n    float geom_dist, geom_scale;\n    \n    //\n    np = p;\n    np.yz *= r2(3.14159/2.0);\n    \n    np += vec3(5.0,0.0,0.0);\n    geom_dist = sdTorus( np, vec2(10.0,0.2) );\n    new_hit = vec2( geom_dist, 1.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n\n    //\n    \n    np = p;\n        np += vec3(-5.0,0.0,0.0);\n\n        //np.yx *= r2(3.14159/2.0);\n\n    //np.yz *= r2(3.14159/2.0);    \n\n    \n    geom_dist = sdTorus( np, vec2(10.0,0.2) );\n    new_hit = vec2( geom_dist, 1.0 );\n    \n    if( new_hit.x < closest_hit.x )\n        closest_hit = new_hit;\n\n    //\n    \n    return closest_hit;\n}\n\nvec3 np;\nvec2 calc_dist_to_scene_fract( vec3 p )\n{\n\n    p.xz *= r2( iTime/20.0 );\n\n    //return calc_dist_to_scene(p);\n\n    float rot1 = texture(iChannel1,vec2(0.0)).x;\n    float rot2 = texture(iChannel1,vec2(0.0)).y;\n    \n    float trans1 = texture(iChannel1,vec2(0.0)).z;\n    float trans2 = texture(iChannel1,vec2(0.0)).w;\n    \n    np = p;\n    //np.xz*=r2(sin(p.y*0.05+(iTime/3.0))*0.3);\n    \n    //int divs = int(iMouse.y/100.0)-1;\n    int folds = 9;\n    int fold_change0 = 5, fold_change1 = 8;\n    for( int i=0; i<folds; i++ ) {        \n        //if( i > divs ) break;\n#if 0\n        np = abs(np) - vec3( 0.0f, 0.0, 0.0 );\n        np = np - vec3( 0.0f, 1.0, 0.0 );\n        np.xz *= r2(3.14159/20.0);\n#endif        \n#if 1\n        np = abs(np) - vec3( 0.2+trans1, 1.7+trans2, 0.0 );\n        np.xz *= r2(rot1);\n        np.xy *= r2(rot1*1.4+cos(p.y*0.01)*0.5);\n\n        if( i > fold_change1 )\n        {\n            np.xy *= r2(3.14159/8.0);\n\n        }\n        \n        if( i > fold_change0 )\n        {\n            np.xz *= r2(3.14159/2.0);\n                    np = abs(np) - vec3( 0.2, 1.7, 1.0 );\n        }\n#endif\n        \n    }\n    \n    vec2 fract_hit = calc_dist_to_scene( np );\n    \n    float dist_to_plane = p.y-(14.0/* +2.0*fract_hit.y*/);\n    \n    //if( fract_hit.y < 4.0 )\n        //if( dist_to_plane > fract_hit.x )\n            //return vec2( dist_to_plane, 1.0 );\n\n    return fract_hit;\n}\n\n#define ZERO (min(iFrame,0))\n\nvec3 calc_normal_from_scene( vec3 p )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*calc_dist_to_scene_fract( p + e.xyy ).x + \n\t\t\t\t\t  e.yyx*calc_dist_to_scene_fract( p + e.yyx ).x + \n\t\t\t\t\t  e.yxy*calc_dist_to_scene_fract( p + e.yxy ).x + \n\t\t\t\t\t  e.xxx*calc_dist_to_scene_fract( p + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*calc_dist_to_scene_fract(p+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec4 march_ray( vec3 ray_pos, vec3 ray_dir ) \n{\n    float start_dist = 0.1;\n    float stop_dist = 200.0;\n    float closest_miss = 999.0;\n    float closest_miss_dist = 0.0;\n    \n    float dist_marched = start_dist;\n    float hit_material_idx = 0.0;\n    while( dist_marched < stop_dist )\n    {\n        vec3 marched_p = ray_pos + ray_dir * dist_marched;\n        vec2 intersect_vals = calc_dist_to_scene_fract( marched_p );\n        hit_material_idx = intersect_vals.y;\n        float dist_to_geom = intersect_vals.x;\n\n        if( hit_material_idx == 4.0 && dist_to_geom < closest_miss ) \n        {\n            closest_miss = dist_to_geom;\n            closest_miss_dist = dist_marched;\n        }\n\n        if( dist_to_geom < 0.001 ) {\n            break;\n        }\n        dist_marched += dist_to_geom;\n    }\n    \n    return vec4( dist_marched, hit_material_idx, closest_miss, closest_miss_dist );\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp( min2 + (value - min1) * (max2 - min2) / (max1 - min1), 0.0, 1.0);\n}\n\n\nconst int num_color_palettes = 6;\nvec3 colors[num_color_palettes*6] = vec3[](\n\nvec3( 5,17,242 )/255.0,\nvec3( 4,96,217 )/255.0,\nvec3( 3,74,166 )/255.0,\nvec3( 5,151,242 )/255.0,\nvec3( 217,164,4 )/255.0,\nvec3( 5,151,242 )/255.0,\n\nvec3( 2, 62, 115 )/255.0,\nvec3( 20, 181, 217 )/255.0,\nvec3( 217, 61, 26 )/255.0,\nvec3(  40, 3, 3 )/255.0,\nvec3( 89, 2, 2 )/255.0,\nvec3(  40, 3, 3 )/255.0,\n\nvec3( 242, 213, 219 )/255.0,\nvec3(  204, 118, 141 )/255.0,\nvec3( 242, 182, 198 )/255.0,\nvec3(  128, 181, 191 )/255.0,\nvec3( 209, 226, 232 )/255.0,\nvec3(  128, 181, 191 )/255.0,\n\nvec3( 62, 181, 149 )/255.0,\nvec3( 255, 244, 71 )/255.0,\nvec3( 201, 201, 201 )/255.0,\nvec3( 105, 105, 105 )/255.0,\nvec3( 26, 26, 26 )/255.0,\nvec3( 105, 105, 105 )/255.0,\n\nvec3( 254, 5, 134 )/255.0,\nvec3( 227, 5, 230 )/255.0,\nvec3( 187, 18, 253 )/255.0,\nvec3( 104, 5, 230 )/255.0,\nvec3( 48, 5, 254 )/255.0,\nvec3( 104, 5, 230 )/255.0,\n\nvec3( 217, 54, 54 )/255.0,\nvec3( 242, 234, 208 )/255.0,\nvec3( 242, 162, 12 )/255.0,\nvec3( 1, 40, 64 )/255.0,\nvec3( 242, 134, 39 )/255.0,\nvec3( 1, 40, 64 )/255.0\n);\n\nvec2 gFragCoord;\nvec3 light_pos;\nvec3 render_scene( vec3 ray_pos, vec3 ray_dir, float depth )\n{\n    vec4 hit = march_ray( ray_pos, ray_dir );\n    \n    float hit_dist = hit.x;\n    float material_idx = hit.y;\n    \n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n    \n    vec3 light_color = vec3( 0.8 );\n    vec3 material_color = vec3( 0.0 );\n     \n    float seconds_per_color_scheme = 30.0;\n    int color_idx =int( mod( iTime/seconds_per_color_scheme+(-gFragCoord.x+gFragCoord.y)*0.00001, float(num_color_palettes))) *6;\n    \n    if( material_idx == 1.0 )\n    {\n        material_color = colors[color_idx];\n    }\n    else if( material_idx == 2.0 )\n    {\n        material_color = colors[color_idx+1];\n    }\n    else if( material_idx == 3.0 )\n    {\n        material_color = colors[color_idx+2];\n    }\n    else if( material_idx == 4.0 )\n    {\n        material_color = colors[color_idx+3];\n    }\n    else if( material_idx == 5.0 )\n    {\n        material_color = colors[color_idx+4];\n    }\n    vec3 bg_color = colors[color_idx+5];\n    \n    vec3 hit_pos = ray_pos + ray_dir * hit_dist;\n    vec3 light_dir = normalize( light_pos - hit_pos );\n    float light_dist = length( light_pos - hit_pos );\n    vec3 light_half = normalize( light_dir - ray_dir );    \n    \n    if( hit_dist < 200.0 )\n    {\n\n        vec3 normal = calc_normal_from_scene( hit_pos );\n        float specular_light_intensity = 0.0f;\n        float ambient_light_intensity = 0.5;\n        vec3 reflect_color = vec3(0.0);\n        \n\n        vec4 shadow_test = march_ray( hit_pos, light_dir );\n        float light_dot = dot( normal, light_dir );\n        \n        float rim_dot = dot( normalize(normal), normalize(ray_dir) );\n        float rim_shade = map( pow(abs(rim_dot),5.0), 0.0, 0.2, 0.6, 1.0);\n        \n        float diffuse_light_intensity = map( clamp( light_dot, 0.0, 1.0 ), 0.0, 1.0, 0.0, 1.0-ambient_light_intensity );\n        specular_light_intensity = pow( clamp( dot( normal, light_half ), 0.0, 1.0 ), 150.0);\n        \n        float aor = hit_dist/50.0;\n        float ao = exp2( -2.0 * pow( max( 0.0, 1.0-march_ray(hit_pos,normal*aor).x/aor), 2.0));\n        \n        vec3 sss = vec3(1.5) * smoothstep( 0.0, 1.0, march_ray(hit_pos,light_dir*0.4).x/0.4);\n        \n        float is_shadowed = 1.0;\n        float shadow_pct = 0.5;\n        if( shadow_test.x > light_dist ) {\n            if( light_dot > 0.0 ) {\n                is_shadowed = 0.0;\n                shadow_pct = 1.0;\n                rim_shade = 1.0/rim_shade;\n            }\n        }\n        \n        if( depth < 3.0 )\n        {\n            vec3 reflect_dir = reflect( ray_dir, normal );\n            //reflect_color = render_scene( hit_pos, reflect_dir, depth+1.0 );\n            reflect_color = texture( iChannel0, reflect_dir ).rgb;\n        }\n        color = \n            (ao*ambient_light_intensity + (diffuse_light_intensity)* (1.0-is_shadowed) ) * 0.5*sss * material_color + \n            specular_light_intensity * light_color * (1.0-is_shadowed) + \n            0.05 * reflect_color * shadow_pct;\n        \n        color *= rim_shade;\n\n        //color = vec3(abs(rim_shade));\n\n        //fog\n        vec3 fog_color = vec3( bg_color );\n\n        //color = mix( color, fog_color, 1.0-exp( -0.0001*hit_dist*hit_dist ) );\n    }\n    else \n    {\n        color = texture( iChannel0, ray_dir ).rgb;\n        color = bg_color;\n        \n        vec3 back_wall_intersection_pos = ray_pos + ray_dir * 250.0;\n\n        vec3 wall_to_light_dir = normalize( light_pos - back_wall_intersection_pos );\n        vec4 shadow_test = march_ray( back_wall_intersection_pos, wall_to_light_dir );\n        if( shadow_test.x < 200.0 ) {\n            color *= 0.9;\n        }\n    }\n    \n    //float z_glow_thresh = 0.2;\n    //if( hit.z < z_glow_thresh )\n    //    color = mix( color4, color, hit.z/z_glow_thresh );\n     return color;\n}\n\nmat3 make_camera_rot_mat( vec3 camera_pos, vec3 camera_dir )\n{\n    vec3 cam_forwards = normalize( camera_dir );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    vec3 cam_right = cross( cam_forwards, up );\n    vec3 cam_up = cross( cam_right, cam_forwards );\n    return mat3( cam_right, cam_up, cam_forwards );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    gFragCoord = fragCoord;\n    vec3 camera_pos = vec3( 0.0, 40.0, -90.0 );//texture( iChannel2, vec2(2.0,0.0) ).xyz;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    float focus_dist = 1.6;\n    vec2 uv_pos = (fragCoord-iResolution.xy/2.0)*2.0/iResolution.x;\n    vec3 frag_dir = normalize( vec3( uv_pos, focus_dist) ); \n\n    float camera_dist = 2.0;\n    vec3 look_at = vec3( 0.0, 0.0, 0.0 );\n    vec3 camera_dir = normalize( look_at - camera_pos );\n    mat3 camera_rot_mat = make_camera_rot_mat( camera_pos, camera_dir );\n    \n    vec3 ray_dir = camera_rot_mat * frag_dir;\n    vec3 ray_pos = camera_pos;\n    \n    light_pos = camera_pos + vec3(50.0, 0.0, 20.0);\n    \n    vec3 rendered_color = render_scene( ray_pos, ray_dir, 0.0 );\n\n    \n    // gamma\n    //rendered_color = pow( rendered_color, vec3(0.6545) );\n    \n    // color grading and vigneting\n    //rendered_color = pow( rendered_color, vec3(0.8,0.85,0.9) );\n\n    fragColor = vec4(rendered_color,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float mouse = 0.0;//iMouse.x/iResolution.x;\n    \n    vec4 prev = texture(iChannel0,fragCoord);\n    \n    if( prev.x == 0.0 && prev.y == 0.0 )\n    {\n        prev.x = iDate.w;\n        prev.y = iDate.w*9.32;        \n        prev.z = iDate.w*19.32;\n        prev.w = iDate.w*29.32;\n\n    }\n    \n    float modTime = mod( iTime, 3.1415926 * 2.0 );\n    \n    prev.x += max( 0.0, sin(modTime*0.6)-0.95 )/15.0;\n    prev.x += max( 0.0, sin(modTime*0.6+0.8)-0.85 )/10.0;\n    \n    prev.y += max( 0.0, sin(modTime*0.6)-0.85 )/10.0;\n    prev.y += max( 0.0, sin(modTime*0.6+0.8)-0.85 )/10.0;\n\n    prev.z = (sin(modTime*0.2)+1.0) * 0.13;\n    prev.z += (sin(modTime*0.2+0.8)+1.0) * 0.14;\n\n    prev.w = (sin(modTime*0.2)+1.0) * 0.135;\n    prev.w += (sin(modTime*0.2+0.8)+1.0) * 0.18;\n\n    fragColor = prev;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if( fragCoord.x == 0.0 && fragCoord.y == 0.0 ) \n    {\n        vec2 delta = iMouse.xy - texture( iChannel0,fragCoord ).xy;\n        fragColor = vec4(iMouse.xy, delta);\n    }\n    else if( fragCoord.x == 2.0 && fragCoord.y == 0.0 ) \n    {\n        vec3 cam_pos = texture( iChannel0,fragCoord ).xyz;\n        if( cam_pos.x == 0.0 && cam_pos.y == 0.0 ) \n        {\n            fragColor = vec4( vec3( 0.0, 3.0, -100.0 ), 0.0 );\n        }\n        cam_pos.z += -0.01;\n        fragColor = vec4( cam_pos, 0.0 );\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"}]}