{"ver":"0.1","info":{"id":"3sBSzw","date":"1553178324","viewed":147,"name":"Epilepsy No 1","username":"PhiWei","description":"Click in the image and have fun trying out different samplings rate.\n#define NB_SAMPLES 256000\n#define NB_PER_RUN 256\nWarning the result is completely dependent on your FPS rate!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["epilepsy","nonsense","fpsdependent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265358979323846\n#define INV_PI 0.31830988618\n#define u_Gamma 1.0\n#define u_Scale 1.0\n\n#define sqr(a) ( (a)*(a) )\n\n#define NB_SAMPLES 25600\n#define NB_PER_RUN 256\n\n\n\nfloat CosTheta(vec3 w) { return w.z; }\nfloat Cos2Theta(vec3 w) { return w.z * w.z; }\n\nfloat Sin2Theta(vec3 w) {\n    return max(0.0, 1.0 - Cos2Theta(w));\n}\n\nfloat SinTheta(vec3 w){\n    return sqrt(Sin2Theta(w));\n}\n\nfloat Tan2Theta(vec3 w) {\n    return Sin2Theta(w) / Cos2Theta(w);\n}\n\nfloat CosPhi(vec3 w) {\n    float sinTheta = SinTheta(w);\n    return ((sinTheta == 0.0) ? 1.0 : clamp(w.x / sinTheta, -1.0, 1.0));\n}\n\nfloat SinPhi(vec3 w) {\n    float sinTheta = SinTheta(w);\n    return ((sinTheta == 0.0) ? 0.0 : clamp(w.y / sinTheta, -1.0, 1.0));\n}\n\nfloat Cos2Phi(vec3 w) {\n    return CosPhi(w) * CosPhi(w);\n}\nfloat Sin2Phi(vec3 w) {\n    return SinPhi(w) * SinPhi(w);\n}\n\n/* Compute the effective roughness projected on direction v */\nfloat projectRoughness(vec3 v,float alpha_x,float alpha_y) {\n    float invSinTheta2 = 1.0 / Sin2Theta(v);\n\n    if (invSinTheta2 <= 0.0)\n        return alpha_x;\n\n    float cosPhi2 = v.x * v.x * invSinTheta2;\n    float sinPhi2 = v.y * v.y * invSinTheta2;\n\n    return sqrt(cosPhi2 * alpha_x * alpha_x + sinPhi2 * alpha_y * alpha_y);\n}\n\nfloat GGX_G1(float NdotV, float a) {\n    float a2 = sqr(a);\n    return 2.0/(1.0 + sqrt(1.0 + a2 * (1.0-sqr(NdotV)) / sqr(NdotV) ));\n}\n\nfloat GGX_G(vec3 wi, vec3 wo,float alpha_x,float alpha_y) {\n    float a_wi = projectRoughness(wi,alpha_x, alpha_y);\n    float a_wo = projectRoughness(wo,alpha_x, alpha_y);\n\n    vec3 n = vec3(0.0,0.0,1.0);\n    return GGX_G1(dot(n, wi), a_wi) * GGX_G1(dot(n, wo), a_wo);\n}\n\nfloat GGX_D(vec3 wi, vec3 wo, vec3 n, float a_x,float a_y) {\n    vec3  wh     = normalize(wi+wo);\n    \n    float tan2Theta = Tan2Theta(wh);\n    float cos4Theta = Cos2Theta(wh) * Cos2Theta(wh);\n    float e = (Cos2Phi(wh) / (a_x * a_x) +\n               Sin2Phi(wh) / (a_y * a_y)) * tan2Theta;\n    return 1.0 / (PI * a_x * a_y * cos4Theta * (1.0 + e) * (1.0 + e));\n}\n\nvec3 sampleGGXVNDF(vec3 wi, float alpha_x, float alpha_y, vec2 uv){\n    // Section 3.2: transforming the view direction to the hemisphere configuration\n    vec3 Vh = normalize(vec3(alpha_x * wi.x, alpha_y * wi.y, wi.z));\n    // Section 4.1: orthonormal basis\n    vec3 T1 = (Vh.z < 0.9999) ? normalize(cross(vec3(0, 0, 1), Vh)) : vec3(1, 0, 0);\n    vec3 T2 = cross(Vh, T1);\n    // Section 4.2: parameterization of the projected area\n    float r = sqrt(uv.x);\n    float phi = 2.0 * PI * uv.y;\n    float t1 = r * cos(phi);\n    float t2 = r * sin(phi);\n    float s = 0.5 * (1.0 + Vh.z);\n    t2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n    // reprojection onto hemisphere\n    vec3 Nh = t1*T1 + t2*T2 + sqrt(max(0.0, 1.0 - t1*t1 - t2*t2))*Vh;\n    // transforming the normal back to the ellipsoid configuration\n    vec3 Ne = normalize(vec3(alpha_x * Nh.x, alpha_y * Nh.y, max(0.0, Nh.z)));\n    return Ne;\n}\n\nfloat Eval_Rough_Conductor(vec3 wi, vec3 wo, vec3 n, float a_x,float a_y){\n    vec3  wh     = normalize(wi+wo);\n    float cosThetaWh = dot(n, wh);\n    float cosThetaWi = dot(n, wi);\n    float cosThetaWo = dot(n, wo);\n\n    float G = GGX_G(wi, wo, a_x,a_y);\n    float D = GGX_D(wi, wo, vec3(0.0, 0.0, 1.0),a_x,a_y);\n\n    return G*D/(abs(4.0*cosThetaWi*cosThetaWo));\n}\n\n\n/* Gamma transformation\n */\nvec3 Gamma(vec3 R) {\n    return exp(u_Gamma * log(u_Scale * R));\n}\n\n\nvec3 Emission(vec3 wi,vec3 wo, float a_x, float a_y) {\n    return Eval_Rough_Conductor(wi, wo, vec3(0.0, 0.0, 1.0),a_x,a_y) * vec3(0.1,0.2,0.3);\n}\n\nvec2 QMC_Additive_2D(int n) {\n    return mod(vec2(0.5545497, 0.308517) * float(n), vec2(1.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 thetaPhi = (2.* iMouse.xy - iResolution.xy ) / iResolution.y;\n\tvec2 uv = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n\n    vec3 wi = vec3(thetaPhi,0);\n    wi.z = sqrt(1.0 - length(wi.xy));\n\n    float alpha_x_1 = 0.1;\n    float alpha_y_1 = 0.3;\n    float alpha_x_2 = 0.001;\n    float alpha_y_2 = 0.001;\n\n    vec3 wo = vec3(uv,0);\n    float sinTo = length(wo.xy);\n\n    int u_PassNumber = iFrame;\n\n    wo.z = sqrt(1.0 - sqr(sinTo));\n\n    for(int i=0; i<NB_PER_RUN; ++i) {\n\n        int  idx = (u_PassNumber*NB_PER_RUN+i) % NB_SAMPLES;     \n        vec2 rnd = QMC_Additive_2D(idx);\n\n\n        vec3 m = sampleGGXVNDF(wo, alpha_x_1,alpha_y_1, rnd.xy);\n        vec3 ws = reflect(-wo, m); \n        ws.xy = -ws.xy;\n\n\n        vec3 value = vec3(0,0,0);\n        if(ws.z > 0.0) {\n            value = Emission(wi, ws, alpha_x_2,alpha_y_2);\n        }\n\n\n        fragColor.xyz += value;\n    }\n\n    fragColor.xyz = Gamma(fragColor.xyz / float(NB_PER_RUN));\n    fragColor.w = 1.0;\n\n}\n\n\n","name":"Image","description":"","type":"image"}]}