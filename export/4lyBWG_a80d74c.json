{"ver":"0.1","info":{"id":"4lyBWG","date":"1543731079","viewed":161,"name":"Object Hierarchy","username":"gest","description":"Experiment. The mouse wheel does not work. It's a pity!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sphere","intersection","lights","hierarchy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Адаптер\nfloat u_time;\nvec2  u_canvas;\nvec3  u_mouse;\n\nconst float PI = radians(180.);\nconst float Infinity = 1e6;\n\n//Камера\nstruct Camera {\n\t//Задаваемые параметры\n\tfloat fov;\n\tfloat aspect;\n\tvec3  origin;\n\tvec3  target;\n\tvec3  up;\n\t//Расчетные параметры\n\tfloat factor;\n\tvec3  forward;\n\tvec3  right;\n\tvec3  position;\n\tvec3  coord;\n};\n\nstruct Material {\n\tvec3  colorAmbient;\n\tvec3  colorDiffuse;\n    vec3  colorSpecular;\n    float reflectance;\n    float shininess;\n};\n\n//Результат пересечения луча с элементами карты\nstruct Hit {\n    float\t distance;\t\t// дистанция до эленента\n\tvec3\t position;\t\t// позиция элемемента\n\tvec3\t normal;\t\t// нормаль в точке пересечения\n    int\t\t id;\t\t\t// id элемента сцены\n\tMaterial material;\t\t// материал элемента\n};\n\n//Луч\nstruct Ray {\n\t//Задаваемые параметры\n\tvec3  origin;\t\t//Начало луча\n\tvec3  direction;\t//Направление луча\n\tfloat near;\t\t\t//Минимальное расстояние до элемента\n\tfloat far;\t\t\t//Предельное расстояние до элемента\n\tfloat epsilon;\t\t//Точность\n\tint\t  steps;\t\t//Максимальное число итераций\n\t//Возвращаемые параметры\n\tbool  HIT;\t\t\t//Успех нахождения точки пересечения\n\tHit   hit;\t\t\t//Параметры элемента сцены, возвращаемые картой расстояний\n};\n//Формирование луча камеры\nRay lookAt (in vec2 uv, inout Camera cam) {\n\t//Расчетные характеристики камеры\n\tcam.factor \t\t= 1.0/tan(radians(cam.fov/2.));\n\tcam.forward \t= normalize(cam.target-cam.origin); \n\tcam.right \t\t= normalize(cross(cam.up, cam.forward));\n\tcam.up \t\t\t= cross(cam.forward, cam.right);\n\tcam.position \t= cam.origin + cam.factor * cam.forward;\n\tcam.coord \t\t= cam.position + uv.x * cam.right * cam.aspect + uv.y * cam.up;\n\t//Формирование луча\n\tRay ray;\n\t{\n\t\tray.origin \t\t= cam.origin;\n\t\tray.direction \t= normalize(cam.coord - cam.origin);\n\t}\n\treturn ray;\n}\n\nstruct Light {\n    vec3  position;\n    vec3  color;\n\tfloat radius;\n};\n   \nstruct Sphere {\n\tvec3 \t center;\n    float \t radius;\n};\n\n//Матрица вида\t(матрица преобразования мировой системы координат)\nmat4 vMatrix;\t\t\n//Матрица модели (матрица преобразования в локальной системе координат)\nmat4 mMatrix;\n//Матрица модель-вид (матрица преобразования локальной системы координат в мировую)\t\t\nmat4 vmMatrix;\t\t\n\n//-------------Вспомогательные функции------------------------------\nvoid translate (inout mat4 m, vec3 v) {\n\tmat4 tMat = mat4( 1,0,0,0,  0,1,0,0,  0,0,1,0,  v.x,v.y,v.z,1 );\n\tm = tMat * m;\n}\nvoid rotateX (inout mat4 m, float rad) {\n\tfloat c = cos(rad), s = sin(rad);\n\tmat4 tMat = mat4( 1,0,0,0,  0,c,s,0,  0,-s,c,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid rotateY (inout mat4 m, float rad) {\n\tfloat c = cos(rad), s = sin(rad);\n\tmat4 tMat = mat4( c,0,-s,0,  0,1,0,0,  s,0,c,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid rotateZ (inout mat4 m, float rad) {\n\tfloat c = cos(rad), s = sin(rad);\n\tmat4 tMat = mat4( c,s,0,0,  -s,c,0,0,  0,0,1,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid rotate (inout mat4 m, vec3 axis, float rad) {\n\tvec3 c = cos(axis*rad), s = sin(axis*rad);\n\tmat4 tMatX = mat4( 1,0,0,0,  0,c.x,s.x,0,  0,-s.x,c.x,0,  0,0,0,1 );\n\tmat4 tMatY = mat4( c.y,0,-s.y,0,  0,1,0,0,  s.y,0,c.y,0,  0,0,0,1 );\n\tmat4 tMatZ = mat4( c.z,s.z,0,0,  -s.z,c.z,0,0,  0,0,1,0,  0,0,0,1 );\n\tm = tMatX * tMatY * tMatZ * m;\n}\nvoid scale (inout mat4 m, vec3 s) {\n    mat4 tMat = mat4( s.x,0,0,0,  0,s.y,0,0,  0,0,s.z,0,  0,0,0,1 );\n\tm = tMat * m;\n}\nvoid transform(inout vec3 v, mat4 m) {\n\tv = (m * vec4(v, 1.0)).xyz;\n}\n//-------------------------------------------------------\n//Пересечение луча со сферой\nfloat intersectSphere(Ray ray, Sphere sphere){\n    vec3 d = ray.origin - sphere.center;\n    float A = dot(ray.direction, ray.direction);\n    float B = 2. * dot(ray.direction, d);\n    float C = dot(d, d) - sphere.radius * sphere.radius;\n    float D = B*B - 4.*A*C;\n    if (D < 0.0) return ray.far;\n    float t = -B - sqrt(D);\n\t// Closest intersection behind the ray\n\tfloat dist = (-B - sqrt(D)) / (2.0 * A);\n\tif (dist < 0.) dist = (-B + sqrt(D)) / (2.0 * A);\n\tif (dist < ray.near) return ray.far;\n \treturn dist;   \n}\n//Карта элементов сцены\nHit map (Ray ray) {\n\t//Умолчание (нет пересечения луча с элементами)\n\tHit hit;\n\t{\n\t\thit.distance = ray.far;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n//\t\thit.normal \t = vec3(0.0);\n//\t\thit.id \t\t = 0;\n//\t\thit.material = Material(vec3(0), vec3(0), vec3(0), 0.0, 0.0);\n\t}\n\t\n\tfloat d;\n\tSphere sphere;\n\t\n\t//Центральный шар\n\tsphere = Sphere(vec3(0), 20.0);\n\t//Матрица вида\n\tvMatrix = mat4(1);\t//Мировая система координат\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\t//Матрица модель-вид\n\tmat4 vmMatrix_1 = vMatrix * mMatrix; //система координат шара 1\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_1);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 1;\n\t\thit.material = Material(vec3(0.1), vec3(0.8, 0.8, 0.8), vec3(1.00), 1.0, 100.);\n\t}\n\n\n\t//Шар большой\n\tsphere = Sphere(vec3(0), 5.0);\n\t//Матрица вида\n\tvMatrix = mat4(1);\t//Мировая система координат\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix,vec3(40,0,0));\n\trotateY(mMatrix, u_time/6.);\n\t//Матрица модель-вид\n\tmat4 vmMatrix_2 = vMatrix * mMatrix; //система координат шара 2\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_2);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 2;\n\t\thit.material = Material(vec3(0.1), vec3(0.3, 0.6, 0.4), vec3(0.20), 0.5, 14.);\n\t}\n\n\t//Шар средний\n\tsphere = Sphere(vec3(0),  2.0);\n\t//Матрица вида\n\tvMatrix = vmMatrix_2; //Система координат шара 2\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(15,0,0));\n\trotateY(mMatrix, u_time);\n\t//Матрица модель-вид\n\tmat4 vmMatrix_3 = vMatrix * mMatrix; //система координат шара 3\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_3);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 3;\n\t\thit.material = Material(vec3(0.1), vec3(0.2, 0.2, 0.8), vec3(0.30), 0.5, 14.);\n\t}\n\n\t//Шар малый\n\tsphere = Sphere(vec3(0), 1.0);\n\t//Матрица вида\n\tvMatrix = vmMatrix_3;\t//Система координат шара 3\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(4,0,0));\n\trotateZ(mMatrix, u_time*2.);\n\t//Матрица модель-вид \n\tmat4 vmMatrix_4 = vMatrix * mMatrix; //система координат шара 4\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_4);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 4;\n\t\thit.material = Material(vec3(0.1), vec3(0.4, 0.2, 0.4), vec3(0.80), 0.0, 14.);\n\t}\n\n\t//Шар большой\n\tsphere = Sphere(vec3(0), 6.0);\n\t//Матрица вида\n\tvMatrix = mat4(1); //Мировая система координат\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix,vec3(30,10,0));\n\trotateY(mMatrix, u_time/3. + PI);\n\t//Матрица модель-вид\n\tmat4 vmMatrix_5 = vMatrix * mMatrix; //система координат шара 5\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_5);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 5;\n\t\thit.material = Material(vec3(0.1), vec3(0.2, 0.2, 0.8), vec3(0.30), 1.0, 14.);\n\t}\n\n\t//Шар средний\n\tsphere = Sphere(vec3(0),  2.0);\n\t//Матрица вида\n\tvMatrix = vmMatrix_5; //Система координат шара 5\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(0,10,0));\n\trotateX(mMatrix, u_time);\n\t//Матрица модель-вид \n\tmat4 vmMatrix_6 = vMatrix * mMatrix; //система координат шара 6\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_6);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 6;\n\t\thit.material = Material(vec3(0.1), vec3(0.4, 0.2, 0.4), vec3(0.80), 0.0, 14.);\n\t}\n\n\t//Шар большой\n\tsphere = Sphere(vec3(0), 6.0);\n\t//Матрица вида\n\tvMatrix = mat4(1);\t//Мировая система координат\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix,vec3(30,-10,0));\n\trotateY(mMatrix, u_time + PI);\n\tscale(mMatrix, vec3(2,1,1));\n\t//Матрица модель-вид \n\tmat4 vmMatrix_7 = vMatrix * mMatrix;//система координат шара 7\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_7);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 7;\n\t\thit.material = Material(vec3(0.1), vec3(0.4, 0.2, 0.4), vec3(0.80), 0.0, 14.);\n\t}\n\n\t//Шар средний\n\tsphere = Sphere(vec3(0,0,0),  2.0);\n\t//Матрица вида\n\tvMatrix = vmMatrix_7; //Система координат шара 7\n\t//Матрица модели (локальной трансформации)\n\tmMatrix = mat4(1);\n\ttranslate(mMatrix, vec3(0,10,0));\n\trotateX(mMatrix, u_time*2.);\n\tscale(mMatrix, vec3(1,2,1));\n\t//Матрица модель-вид \n\tmat4 vmMatrix_8 = vMatrix * mMatrix;//система координат шара 8\n\t//Координаты шара с учетом трансформации\n\ttransform (sphere.center, vmMatrix_8);\n\t//Расстояние до шара\n\td = intersectSphere(ray, sphere);\n\tif (hit.distance > d){\n\t\thit.distance = d;\n\t\thit.position = ray.origin + hit.distance * ray.direction;\n\t\thit.normal   = normalize(hit.position - sphere.center);\n\t\thit.id \t\t = 8;\n\t\thit.material = Material(vec3(0.1), vec3(0.8, 0.8, 0.8), vec3(1.00), 1.0, 14.);\n\t}\n\n\treturn hit;\n}\n//Поиск пересечения луча с элементами сцены\nvoid rayMarch(inout Ray ray) {\n\t//Флаг пересечения\n\tray.HIT = false;\n\t//Учитываем минимальную дистанцию\n\tRay ray1 = ray;\n\tray1.origin = ray.origin + ray.near * ray.direction;\n\t//Рассстояние до ближайшего элемента сцены\n\tray.hit = map(ray1);\n\t\n\tif (ray.hit.distance >= ray.near && ray.hit.distance < ray.far) {\n\t\tray.HIT = true;\n\t}\n}\n//Тень\nfloat hardShadow(vec3 p, Light light){\n\tfloat shadow = 0.0; //Тени нет\n\t//Формируем луч из точки элемента сцены в сторону источника света\n\tRay ray;\n\t{\n\t\tray.origin \t\t= p;\n\t\tray.direction \t= normalize(light.position - p);\n\t\tray.near \t\t= 0.001; //Смещение от точки элемента сцены\n\t\tray.far\t\t\t= Infinity;\n\t}\n\trayMarch(ray);\n\t\n\tif (ray.HIT) shadow = 1.0; //Если луч пересек элемент сцены\n\n    return shadow;\n}\n//Освещение точки (метод Фонга)\nvec3 lighting(vec3 p, vec3 normal, vec3 camPos, Light light, Material material, float shadow) {\n\tvec3 color = vec3(0);\n\t\n\tvec3 rayDirection = normalize(p - camPos); \t\t\t//Направление луча (эквивалентно ray.direction)\n\tvec3 lightDir = normalize(light.position - p);  \t//Направение из точки элемента сцены в позицию точечного света\n\tvec3 lightDir_reflect = reflect(lightDir, normal);\t//Направление отраженного луча\n\t//Интенсивность диффузной составляющей света\n\tfloat diffuse = max(0.0, dot(normal, lightDir));\t\n\t//Интенсивность составляющей блеска\n\tfloat specular = pow(max(dot(rayDirection, lightDir_reflect), 0.0), material.shininess);\n\t//Цвет окружающего света\n\tcolor += material.colorAmbient;\n\t//Цвет поглощаемого света\n\tcolor += light.color * diffuse * material.colorDiffuse * (1. - shadow);\n\t//Цвет блеска\n\tcolor += light.color * specular * material.colorSpecular * (1. - shadow);\n\t//Итоговый цвет точки\n\treturn color;\n}\n//Цвет источника света\nvec3  drawLight(vec3 color, Ray ray, Light light){\n    vec3 v = ray.origin - light.position;\n\tvec3 v_proj = dot(v, ray.direction) * ray.direction;\n    float d = length(v - v_proj);\n    \n    if (d < light.radius){\n       \tfloat a = 1.0 - d/light.radius;\n       \tcolor =  mix(color, light.color, pow(a, 4.0));\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 GL_FragColor, in vec2 GL_FragCoord ) {\n    //Адаптер\n    u_time = iTime;\n    u_canvas = iResolution.xy;\n    u_mouse = iMouse.xyz;\n    \n    float aspect = u_canvas.x/u_canvas.y;\n    vec2 uv = GL_FragCoord.xy / u_canvas.xy;\n    uv = uv - 0.5;\n\n    vec3 mouse = u_mouse / vec3(u_canvas, 1.0);\n    mouse.xy = (mouse.xy==vec2(0)) ? (vec2(0)) : (mouse.xy-0.5);\n\n    const int numLights = 5;\n    //Источники освещения\n    Light lights[5];\n    lights[0] = Light(vec3(0), vec3(0.9, 0.9, 0.9), 10.0);\n    lights[1] = Light(vec3(0), vec3(0.3, 0.3, 0.3),  5.0);\n    lights[2] = Light(vec3(0), vec3(0.9, 0.1, 0.1), 10.0);\n    lights[3] = Light(vec3(0), vec3(0.1, 0.9, 0.1), 10.0);\n    lights[4] = Light(vec3(0), vec3(0.1, 0.1, 0.9), 10.0);\n\n    //Формируем матрицу вида (систему координат освещения)\n    vMatrix = mat4(1);\n    rotateY(vMatrix, PI/2.);\n    translate(vMatrix, vec3(0,0,100));\n\n    //Формируем матрицу модели\n    mMatrix = mat4(1);\n    //Формируем матрицу вид-модель (преобразование в систему координат освещения)\n    vmMatrix = vMatrix * mMatrix;\n    //Формируем позицию света 0\n    transform(lights[0].position, vmMatrix);\n\n    //Формируем матрицу модели\n    mMatrix = mat4(1);\n    translate(mMatrix, vec3(0,7,0));\n    rotateX(mMatrix, u_time);\n    //Формируем матрицу вид-модель (преобразование в систему координат освещения)\n    vmMatrix = vMatrix * mMatrix;\n    //Формируем позицию света 2\n    transform(lights[1].position, vmMatrix);\n\n    rotateY(vMatrix, PI/2.);\n\n    //Формируем матрицу модели\n    mMatrix = mat4(1);\n    //Формируем матрицу вид-модель (преобразование в систему координат освещения)\n    vmMatrix = vMatrix * mMatrix;\n    //Формируем позицию света 1\n    transform(lights[2].position, vmMatrix);\n\n    rotateY(vMatrix, PI/2.);\n\n    //Формируем матрицу модели\n    mMatrix = mat4(1);\n    //Формируем матрицу вид-модель (преобразование в систему координат освещения)\n    vmMatrix = vMatrix * mMatrix;\n    //Формируем позицию света 1\n    transform(lights[3].position, vmMatrix);\n\n    rotateY(vMatrix, PI/2.);\n\n    //Формируем матрицу модели\n    mMatrix = mat4(1);\n    //Формируем матрицу вид-модель (преобразование в систему координат освещения)\n    vmMatrix = vMatrix * mMatrix;\n    //Формируем позицию света 1\n    transform(lights[4].position, vmMatrix);\n\n    Camera cam;\n    {\n        cam.fov     = 70.;\n        cam.aspect  = aspect;\n        /*\t\t\t\t\n        //Расчет орбитальных координат\n        float theta \t= mouse.x*2.*PI;\n        float phi\t\t= mouse.y*PI;\n        float radius  \t= 50. + mouse.z;\n        cam.origin  = vec3(\n            radius * sin(theta) * cos(phi), \n            radius * sin(theta) * sin(phi), \n            radius * cos(theta) \n        );\n\t\t*/\t\n\n        cam.origin  = vec3(0, 0, 110.);\n\n        vMatrix = mat4(1);\n        rotateY(vMatrix, mouse.x*2.*PI - u_time/10.);\n\n        mat4 mMatrix = mat4(1);\n        rotateX(mMatrix, mouse.y*PI);\n        //translate(mMatrix, vec3(0, 0, mouse.z)); //Shadertoy does not support mouse wheel\n\n        transform(cam.origin, vMatrix * mMatrix);\n\n        cam.target  = vec3(0,0,0);\n        cam.up \t\t= vec3(0,1,0);\n    }\n\n    Ray ray = lookAt(uv, cam);\n    {\n        ray.near \t= 0.001;\n        ray.far  \t= Infinity;\n    }\n\n    //Итоговый цвет\n    vec3 color = vec3(0);\n\n    vec3 colorTotal = vec3(0.0);\n    vec3 colorReflect = vec3(1.0);\n    vec3 colorLighting = vec3(0.0);\n\n    //Коэффициент отражения\n    float ref = 1.0;\n\n\n    //Глубина отражений\n    for (int j = 0; j < 3; j++) {\n\n        rayMarch(ray);\n\n\n        //Цвет точки\n        vec3 colorLighting = vec3(0.0);\n\n        if ( !ray.HIT) {\n            //Луч не достигает поверхности элемента (позиция в пространстве)\n            if ( j==0 ) {\n                for (int i = 0; i < numLights; i++){\n                    if (dot(ray.direction, normalize(ray.origin - lights[i].position))<=0.) {\n                        color = drawLight(color, ray, lights[i]);\n                    }\n                }\n            }\n            break;\n        }\n\n\n        for (int i = 0; i < numLights; i++){\n            //Расчет тени\n            float shadow = hardShadow(ray.hit.position, lights[i]);\n            //Расчет освещения\n            colorLighting += lighting(ray.hit.position, ray.hit.normal, ray.origin, lights[i], ray.hit.material, shadow);\n\n            //Проверка что между источником света и глазом нет объектов\n            Ray ray2;\n            {\n                ray2.origin \t= lights[i].position;\n                ray2.direction \t= normalize(ray.origin - lights[i].position);\n                ray2.near \t\t= 0.0;\n                ray2.far  \t\t= Infinity;\n            }\n            rayMarch (ray2);\n\n            if ( !ray2.HIT ) { //Нет объекта сцены\n                //Рисуем источник света\n                color = drawLight(color, ray, lights[i]);\n            }\n        }\n        colorLighting /= float(numLights);\n\n\n        colorReflect *= pow(ray.hit.material.colorDiffuse, vec3(1. - ray.hit.material.reflectance));\n        colorTotal += colorReflect * colorLighting;\n\n        ref *= ray.hit.material.reflectance;\n        if (ref<0.1) break;\n\n        //Следующий луч - отраженный\n        ray.origin \t\t= ray.hit.position;\n        ray.direction \t= reflect(ray.direction, ray.hit.normal);\n    }\n    color += colorTotal;\n    //Гамма-коррекция\n    color = pow( color, vec3(0.4545) );\n\n\n    GL_FragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}