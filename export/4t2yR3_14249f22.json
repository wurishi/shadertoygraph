{"ver":"0.1","info":{"id":"4t2yR3","date":"1509547168","viewed":115,"name":"Colored Sphere and Cube","username":"nhoughto","description":"Using the distance function of a sphere and a cube to display overlap.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","cube","sphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Referencing the tutorial here: http://fabricecastel.github.io/blog/2016-02-11/main.html\n\n// ray computation vars\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst float fovx = PI * fov / 360.0;\nconst float S = 0.01;\nconst vec3 deltax = vec3(S ,0, 0);\nconst vec3 deltay = vec3(0 ,S, 0);\nconst vec3 deltaz = vec3(0 ,0, S);\n\nfloat cube(vec3 p){\n    float s = 1.0;\n    vec3 d = abs(p) - vec3(s);\n    return min(max(d.x, max(d.y,d.z)), 0.0)\n        + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, vec3 center){\n    return length(center - p) - 1.0;\n}\n\nfloat distanceToNearestSurface(vec3 p){\n  float amp = 2.0;\n  return min(cube(p), sphere(p, vec3(amp * cos(iTime), amp * sin(iTime), 0.0)));\n}\n\nvec3 computeSurfaceNormal(vec3 p){\n    float d = distanceToNearestSurface(p);\n    return normalize(vec3(\n    \tdistanceToNearestSurface(p + deltax)-d,\n        distanceToNearestSurface(p + deltay)-d,\n        distanceToNearestSurface(p + deltaz)-d\n    ));\n}\n\nvec3 computeLambert(vec3 p, vec3 n, vec3 l){\n    return vec3(dot(normalize(l-p), n));\n}\n                \nvec3 intersectsWithWorld(vec3 p, vec3 dir){\n  \tfloat dist = 0.0;\n    float nearest = 0.0;\n    bool hit = false;\n    for(int i = 0; i < 20; i++){\n        float nearest = distanceToNearestSurface(p + dir*dist);\n        if(nearest < 0.01){\n            vec3 hit = p + dir * dist;\n            vec3 light = vec3(100.0*sin(iTime),\n                             \t30.0 * cos(iTime),\n                              \t30.0 * cos(iTime));\n            return computeLambert(hit, computeSurfaceNormal(hit), light);\n        }\n        dist += nearest;\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n  \t// camera attributes\n    // cameraDirection and cameraUp MUST be normalized\n    // (ie. their length must be equal to 1)\n    float cameraDistance = 10.0;\n    vec3 cameraPosition = vec3(cameraDistance * sin(iTime), 0, cameraDistance * cos(iTime));\n    vec3 cameraDirection = vec3(-1.0*sin(iTime), 0.0, -1.0 * cos(iTime));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    \n    // generate the ray for this pixel\n    float fovy = fovx * iResolution.y/iResolution.x;\n    float ulen = tan(fovx);\n\tfloat vlen = tan(fovy);\n    vec2 camUV = uv*2.0 - vec2(1.0, 1.0);\n    vec3 nright = normalize(cross(cameraUp, cameraDirection));\n    vec3 pixel = cameraPosition + cameraDirection + nright*camUV.x*ulen + cameraUp*camUV.y*vlen;\n    vec3 rayDirection = normalize(pixel - cameraPosition);\n    \n\tvec3 pixelColor = intersectsWithWorld(cameraPosition, rayDirection);\n    pixelColor.r *= cos(iTime);\n    pixelColor.g *= 2.0 * sin(1.0 * iTime);\n    fragColor = vec4(pixelColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}