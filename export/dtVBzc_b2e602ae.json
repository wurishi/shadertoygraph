{"ver":"0.1","info":{"id":"dtVBzc","date":"1702360122","viewed":17,"name":"jneen quaternion test","username":"jneen","description":"quaternions how do they work","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["quaternions"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define E .001\n#define nsin(X) (.5+.5*sin(X))\n#define mksmin(T) T smin(T a, T b, float k){T h=max(k-abs(b-a),0.)/k; return min(a,b)-h*h*h*k/6.;}T smax(T a,T b,float k){return -smin(-a,-b,k);}\n\nmksmin(float)\nmksmin(vec3)\n\nvec3 traceBadness = vec3(0);\n\nvec3 hit;\nvec3 qdir;\nvec3 qdirUL;\nvec3 qdirDL;\nvec3 qdirUR;\nvec3 qdirDR;\nvec3 qdirTop;\n\n#define DEBUG 1\n\nvec4 qid = vec4(1,0,0,0);\nfloat T;\nvec4 qmul(vec4 a, vec4 b) {\n  vec3 aa=a.yzw,bb=b.yzw;\n  return vec4(a.x*b.x - dot(aa,bb), a.x * bb + b.x * aa + cross(aa, bb));\n}\n\nvec4 look(vec3 forward, vec3 up) {\n  // assume forward/up are orthonorm\n  vec3 right = cross(up, forward);\n\n  float r0 = right.x + up.y + forward.z;\n  vec4 result;\n  \n  traceBadness = -vec3(r0);\n  \n  if (r0 <= -.99) {\n    traceBadness = vec3(1,0,0);\n  }\n\n  float r1 = sqrt(max(0., 1. + r0));\n  return vec4(\n    r1*.5,\n    .5/r1*vec3(\n      up.z - forward.y,\n      forward.x - right.z,\n      right.y - up.x\n    )\n  );\n}\n\n// [jneen] alternate version of look that i found.\n// doesn't seem to work? also complicated as heck\nvec4 look2(vec3 f, vec3 up)\n{\n  // forward and size vectors of the coordinate frame \n  vec3 side = normalize(cross(up, f));\n\n  // cross product of bisection and [0, 0, -1] gives you the \n  // half-sine values required to orientate [0, 0, -1] to f\n  // the dot product gives you half the cosine\n  vec3 b = normalize(f + vec3(0, -1, 0));\n  vec4 p = vec4(dot(b, f), cross(b, f));\n\n  // now we need an additional rotation around the f vector\n  // to orientate the side vector.\n  vec3 r = vec3(\n    p.x*p.x + p.y*p.y - p.z*p.z - p.w*p.w,\n\n    2.*p.y * p.z - 2.*p.x * p.w,\n\n    2.*p.y * p.w + 2.*p.x * p.z\n  );\n\n  b = normalize(side+r);\n  vec4 q = vec4(dot(b, side), cross(side, b));\n  // now we can take the product of q and p\n\n  return qmul(p, q);\n}\n\nvec4 qinv(vec4 q) { return vec4(q.x, -q.yzw);}///length(q); }\n\nvec3 qrot(vec3 p, vec4 q) {\n  return qmul(qmul(q, vec4(0.,p)), qinv(q)).yzw;\n}\n\nvec4 conj(vec4 p, vec4 q) {\n  return qmul(qmul(qinv(q), p), q);\n}\n\n\nvec4 axis(vec3 ax, float ro) {\n  ax = normalize(ax);\n  return vec4(cos(ro/2.), ax*sin(ro/2.));\n}\n\nvec4 between(vec3 u, vec3 v) {\n  return normalize(vec4(1.+dot(u,v), cross(u,v)));\n}\n\nfloat hollow_cyl(vec2 p, float r1, float r2) {\n  return max(length(p)-r2,r1-length(p));\n}\n\nfloat box(vec3 p,vec3 a) {\n  vec3 q=abs(p)-a;\n  return length(max(q,0.)) + min(0.,max(q.x,max(q.y,q.z)));\n}\nvec3 start,P,N,dir;float D;\n\nfloat G;\nfloat w(vec3 p) {\n  G+=1.;\n  float O = length(p)-1.2;\n  \n  O = smax(O, -box(p,vec3(.9)),.3);\n  \n  O = smax(O, .2-length(p.xy),.3); \n  O = smax(O, .2-length(p.xz),.3);\n  O = smax(O, .2-length(p.yz),.3);\n  \n  O = max(O, -hollow_cyl(p.xy, .4, .5));\n  O = max(O, -hollow_cyl(p.xz, .4, .5));\n  O = max(O, -hollow_cyl(p.yz, .4, .5));\n  \n  O = max(O, -box(p, vec3(.1, 10., 10.)));\n  O = max(O, -box(p, vec3(10., .1, 10.)));\n  O = max(O, -box(p, vec3(10., 10., .1)));\n\n  \n#ifdef DEBUG\n  float refdist = .09;\n  O = min(O, length(p-start)-.02);\n  //O = min(O, length(p-(start+refdist*qdir))-.01);\n  O = min(O, length(p-(start+refdist*qdirUL))-.01);\n  O = min(O, length(p-(start+refdist*qdirUR))-.01);\n  O = min(O, length(p-(start+refdist*qdirDL))-.01);\n  O = min(O, length(p-(start+refdist*qdirDR))-.01);\n  O = min(O, length(p-(start+refdist*qdirTop))-.01);\n#else\n  // avoid cam\n  O = max(O, .1-length(p-start));\n#endif\n  return O;\n}\n#define M 200.\nvoid march(){D=0.;P+=.2*dir;for(int i=0;i<200;i++){float d=w(P);if(d<E||D>M)break;D+=d;P+=dir*d;}}\n\nvoid norm(){mat3 k=mat3(P,P,P)+mat3(E);N= normalize(w(P)-vec3(w(k[0]),w(k[1]),w(k[2])));}\nfloat studio(){return length(nsin(N))/sqrt(3.);}\nfloat point(vec3 l){return max(0.,dot(N,P-l));}\n\nfloat ao() {\n  float O = 1.;\n  for (float i=20.;i>0.;i-=1.) {\n    float e = i * E * 3.;\n    O-=pow(e - w(P+N*e), 2.) / i;\n  }\n  \n  return O;\n}\n\nvec3 render() {\nif (D>M) return vec3(0.);\n  norm();\n  float diff = studio();\n  \n  float spec = pow(clamp(dot(dir, reflect(-P,N)), 0., 1.), 32.);\n  //return vec3(1)*studio() + spec;\n  vec3 c= spec * vec3(.3,.5,1.) + vec3(.5,.7,.9)*studio();\n  //c/=D*D*3.;\n  c *= ao();\n  return c;\n}\n\nvec3 liss(float t) {\nreturn .4*vec3(cos(t), .2*sin(t), sin(2.*t));\n}\nvec3 path(float t) {\n  t *=.5; \n  return mix(liss(t), liss(.8753*t).yzx, .5);\n  //return .4*vec3(cos(t), -pow(2.*fract(t)-1., 2.)+.5,sin(t));\n}\n\nfloat spread = .1;\nvec3 tangent(float t) {\n  return normalize(path(t+spread/2.) - path(T-spread/2.));\n}\n\nvec3 mkqdir(vec2 uv) {\n// idk why it's rotated 90deg\n//uv = vec2(uv.y, -uv.x);\n\n    vec3 tang = tangent(T);\n    vec3 tang2 = tangent(T-.3);\n    //vec3 up = normalize(cross(tang, tang2));\n    vec3 up = cross(tang,cross(tang, normalize(cross(vec3(0,-1,0), tang))));\n    \n    vec4 l = look(tang, up);\n    \n    vec4 pixel = between(vec3(0,0,1),normalize(vec3(-uv,2.)));\n    \n    return qrot(vec3(0,0,1), qmul(l,pixel));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord-iResolution.xy*.5)/iResolution.x;    \n    \n    T = iTime;// + sin(2.*uv.y + 1.*iTime);\n    start = path(T);\n    \n    \n#ifdef DEBUG\n    P = -vec3(.3,.3,1);\n#else\n    P = start;\n#endif\n    qdir = mkqdir(vec2(0,0));\n    qdirUL = mkqdir(vec2(-1,-1));\n    qdirUR = mkqdir(vec2(1,-1));\n    qdirDL = mkqdir(vec2(-1,1));\n    qdirDR = mkqdir(vec2(1,1));\n    qdirTop = mkqdir(vec2(-1,0));\n    \n#ifdef DEBUG    \n    dir = qrot(normalize(vec3(-uv,1.)), axis(vec3(-1.,0,0), .3+.0*nsin(iTime)));\n#else\n    dir = mkqdir(uv);\n#endif  \n    march();\n\n\n    \n    \n    \n    float glow=G;\n    \n    vec3 col = render();\n    \n#if DEBUG\n    if (uv.x + uv.y < -1.45) {\n      fragColor = vec4(traceBadness,1.);\n      return;\n    }\n#endif\n    // Output to screen\n    // col += .009*G*vec3(1.,.6,.7);\n    fragColor = vec4(col,1);\n}","name":"Image","description":"","type":"image"}]}