{"ver":"0.1","info":{"id":"l3jBDw","date":"1729725826","viewed":53,"name":"Mandelbrot Set (basic render)","username":"zubetto","description":"Basic visualization of The Mandelbrot set (colors are calculated based on the magnitude and argument of complex numbers). You can zoom using the mouse (zooming is controlled by horizontal mouse movement while holding down the left mouse button).\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["math","mandelbrot","complex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initial region of the complex plane : free parameters\n    vec2 regionMin = vec2(-2.5, -1.0);\n    float rangeRe = 3.5;\n    \n    // Initial region of the complex plane : derived parameters\n    float rangeIm = rangeRe * (iResolution.y / iResolution.x);\n    vec2 uvScale = vec2(rangeRe, rangeIm);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Normalized pixel coordinates after zooming\n    ZoomData currentZoom;\n    fetchZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom);\n    uv = zoomUV(currentZoom, uv);\n    \n    // Complex number corresponding to normalized pixel coordinates\n    vec2 fragComplex = uv * uvScale + regionMin;\n\n    // Mandelbrot set basic renderer : free parameters\n    float maxMagnitude = 2.0;\n    int numIteration = 200;\n    \n    // Mandelbrot set basic renderer\n    int stopIteration;\n    vec2 zStop = MandelbrotIterator(fragComplex, vec2(0,0), maxMagnitude, numIteration, stopIteration);\n    vec3 color = complex2rgb(zStop, maxMagnitude);\n\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// CONSTANTS ///////////////////////////////////\nconst float pi = acos(-1.0);\n\n// PURE FUNCTIONS : COMPLEX NUMBERS //////////\n\nvec2 complexMul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\nvec2 complexConj(vec2 a)\n{\n    return vec2(a.x, -a.y);\n}\n\nfloat complexArgDeg(vec2 a)\n{\n    return (180.0 / pi) * atan(a.y, a.x);\n}\n\nfloat complexAbsSq(vec2 a)\n{\n    return complexMul(a, complexConj(a)).x;\n}\n\nvec2 MandelbrotIterator(vec2 c, vec2 z, float threshold, int n, out int i)\n{\n    float h = threshold * threshold;\n    \n    for (i = 0; i < n; ++i)\n    {\n        if (complexAbsSq(z) >= h)\n            break;\n        \n        z = complexMul(z, z) + c;\n    }\n    \n    return z;\n}\n\n// PURE FUNCTIONS : COLOR //////////////////////////////////////////\n\n// source: https://web.archive.org/web/20200207113336/http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 complex2rgb(vec2 z, float maxAbs)\n{\n    float h = complexArgDeg(z) / 360.0;\n    float v = clamp(sqrt(complexAbsSq(z)) / maxAbs, 0.0, 1.0);\n    \n    return hsv2rgb(vec3(h, 1.0, v));\n}\n\n////////////////////////////////////////////////////////////\n// ZOOMING WITH MOUSE //////////////////////////////////////\n// STRUCTURES //////////////////////////////////////////////\n// Zooming is controlled by horizontal mouse movement while holding down the left mouse button (LMB);\n// Zoom center is determined by the mouse position at the moment the LMB is pressed;\n// ZoomOptions:\n//\n// zoomOutToClampedUV : if true, then the current zoom center may be adjusted\n//                      to keep the UV coordinates of the zoomed area in the range [0, 1]\n//                      (for this adjustment to have a meaningful effect, zoomMin should be set to 1.0);\n//\n// zoomBase           : the zoom level multiplier is defined as zoomBase raised to the power\n//                      corresponding to the mouse movement (actual or by inertia),\n//                      for example, a zoomBase value of 4 means that the zoom level changes\n//                      by a factor of 2 when the mouse moves half the length of the viewport\n//\n// inertiaThreshold   : the minimum horizontal mouse speed (in normalized coordinates per second)\n//                      that causes the zoom level to change by inertia after the LMB is released\n//\n// inertiaDamping     : determines how quickly the speed of the mouse moving by inertia decreases over time\n//                      (0 - speed remains constant; \n//                      the larger the absolute value, the faster the speed decreases)\nstruct ZoomOptions\n{\n    bool zoomOutToClampedUV;\n    float zoomBase;\n    float zoomMin;\n    float zoomMax;\n    float inertiaThreshold;\n    float inertiaDamping;\n};\n\nstruct ZoomData\n{\n    vec2 offset;\n    float scale;\n    float controlInputRate;\n    float controlInputPrev;\n};\n\n// CONSTANTS ///////////////////////////////////////////////////\nconst ZoomOptions DFLT_ZOOM_OPTIONS = ZoomOptions(true, 8.0, 1.0, exp2(20.0), 0.1, 0.1);\nconst ZoomData    INI_ZOOM_DATA = ZoomData(vec2(0,0), 1.0, 0.0, 0.0);\n\nconst ivec4 ZOOM_DATA_TEXELS = ivec4(0,0,0,1);\n\n// COMMON VARIABLES ///////////////////////////////////////////\nZoomOptions zoomOptions = DFLT_ZOOM_OPTIONS;\n\n// PURE FUNCTIONS ///////////////////////////////////////////\nvoid fetchZoomData(sampler2D buf, ivec4 dataTexels, inout ZoomData target)\n{\n    vec4 dataSet1 = texelFetch(buf, dataTexels.xy, 0);\n    vec4 dataSet2 = texelFetch(buf, dataTexels.zw, 0);\n    \n    target.offset = dataSet1.xy;\n    target.scale = dataSet1.z;\n    target.controlInputRate = dataSet1.w;\n    \n    target.controlInputPrev = dataSet2.x;\n}\n\nvoid writeZoomData(sampler2D buf, ivec4 dataTexels, ZoomData source, ivec2 fragTexel, inout vec4 fragColor)\n{\n    if (fragTexel == dataTexels.xy)\n    {\n        fragColor.xy = source.offset;\n        fragColor.z = source.scale;\n        fragColor.w = source.controlInputRate;\n    }\n    \n    if (fragTexel == dataTexels.zw)\n    {\n        fragColor.x = source.controlInputPrev;\n    }\n}\n\nvec2 zoomUV(ZoomData zData, vec2 uv)\n{\n    return uv * zData.scale + zData.offset;\n}\n\nvoid updateZoomData(inout ZoomData zData, ZoomOptions zOptions, vec4 mouseUV, float dt)\n{\n    vec2 scaleCenter = zoomUV(zData, abs(mouseUV.zw));\n    float scaleFactor = 1.0;\n    \n    if (mouseUV.z > 0.0)\n    {\n        float ciCurr = mouseUV.x - mouseUV.z;\n        float ciDelta = ciCurr - zData.controlInputPrev;\n        float ciRate = ciDelta / dt;\n        \n        scaleFactor = pow(zOptions.zoomBase, -ciDelta);\n        zData.controlInputRate = abs(ciRate) < zOptions.inertiaThreshold ? 0.0 : ciRate;\n        zData.controlInputPrev = ciCurr;\n    }\n    else\n    { \n        zData.controlInputRate *= max(0.0, 1.0 - abs(zOptions.inertiaDamping) * dt);\n        zData.controlInputPrev = 0.0;\n        scaleFactor = pow(zOptions.zoomBase, -zData.controlInputRate * dt);\n    }\n    \n    float sfMin = 1.0 / (zData.scale * zOptions.zoomMax);\n    float sfMax = 1.0 / (zData.scale * zOptions.zoomMin);\n    scaleFactor = clamp(scaleFactor, sfMin, sfMax);\n    \n    zData.scale *= scaleFactor;\n    zData.offset = (zData.offset - scaleCenter) * scaleFactor + scaleCenter;\n    \n    zData.offset = zOptions.zoomOutToClampedUV ? clamp(zData.offset, vec2(0,0), vec2(1.0 - zData.scale)) : zData.offset;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    ZoomData currentZoom;\n    \n    if (iFrame == 0)\n        currentZoom = INI_ZOOM_DATA;\n    else\n        fetchZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom);\n    \n    updateZoomData(currentZoom, zoomOptions, iMouse/iResolution.xyxy, iTimeDelta);\n    \n    writeZoomData(iChannel0, ZOOM_DATA_TEXELS, currentZoom, ivec2(fragCoord), fragColor);\n}","name":"Buffer A","description":"","type":"buffer"}]}