{"ver":"0.1","info":{"id":"dldBzr","date":"1700925536","viewed":55,"name":"Gaussian Parameter Derivatives","username":"chronos","description":"Because of the properties of the exponential function, the derivatives of all the parameters are all proportional to the original normal distribution,\nin the sense that they are gaussians multiplied by some polynomial (hermite) / rational function.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["normal","derivative","gaussian","distribution","parameters","probability"],"hasliked":0,"parentid":"DtGyz1","parentname":"Random Distribution Testing"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Gaussian Parameter Derivatives by chronos\n\n    Because of the properties of the exponential function, the derivatives of all the parameters are\n    all proportional to the original normal distribution, in the sense that they are gaussians\n    multiplied by some (hermite-) polynomial / rational function.\n    \n    This means that one can use the original normal distribution for importance sampling\n    the functions of the derivatives, like in optimization for function approximation with gaussians,\n    when using monte carlo estimators of the integrals.\n\n    Green: The normal distribution\n    \n    Pink: Derivative wrt x\n    \n    Purple: Derivative wrt the mean\n    \n    Blue: Derivative wrt the variance\n    \n    Yellow: Derivative wrt the standard deviation\n\n*/\n\nconst float PI = 3.14159265;\n\nfloat normal_dist(float x, float mean, float variance)\n{\n    return exp(-.5 * pow(x-mean, 2.)/variance) / sqrt(variance * 2. * PI);\n}\n\nfloat normal_dist_dx(float x, float mean, float variance)\n{\n    return \n    \n    (-(x-mean)/variance)\n    * exp(-.5 * pow(x-mean, 2.)/variance) / sqrt(variance * 2. * PI);\n}\n\nfloat normal_dist_dmu(float x, float mean, float variance)\n{\n    return \n    \n    (-(mean-x)/variance)\n    * exp(-.5 * pow(x-mean, 2.)/variance) / sqrt(variance * 2. * PI);\n}\n\nfloat normal_dist_dvar(float x, float mean, float variance)\n{\n#if 1\n    float num = exp(-.5 * pow(x-mean, 2.)/variance);\n    float den = sqrt(variance * 2. * PI);\n    \n    float num_dvar = (.5 * pow(x-mean, 2.)/pow(variance, 2.)) * exp(-.5 * pow(x-mean, 2.)/variance);\n    \n    float den_dvar = PI / sqrt(variance * 2. * PI);\n    \n    return (den*num_dvar - num*den_dvar)/pow(den,2.);\n#else\n    return\n    (exp(-pow(x-mean, 2.)/(2.* variance)) * (pow(x-mean, 2.) - variance))\n    /\n    (2.* sqrt(2.* PI) *pow(variance,(5./2.)));\n#endif\n}\n\nfloat normal_dist_dsig(float x, float mean, float std_dev)\n{\n    return\n    (exp(-pow(x-mean, 2.)/(2.* pow(std_dev,2.))) * (pow(x-mean, 2.) - pow(std_dev, 2.)))\n    /\n    (sqrt(2.* PI) * pow(std_dev,4.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.25*(2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    // Target variance for the distribution\n    float variance = 1.3/PI;\n\n    float pix_size = 2./iResolution.y; // Size of a pixel in centered UV coordinates\n    \n    // Draw target distribution:\n    float g = normal_dist(uv.x, 0., variance);\n    color = mix(color, vec3(0.05,.675,.3), smoothstep(2.*pix_size, pix_size, abs(uv.y - g)));\n    \n    float g_dx = normal_dist_dx(uv.x, 0., variance);\n    color = mix(color, vec3(.675, 0.05, .3), smoothstep(2.*pix_size, pix_size, abs(uv.y - g_dx)));\n    \n    float g_dmu = normal_dist_dmu(uv.x, 0., variance);\n    color = mix(color, vec3(.3, 0.05, .675), smoothstep(2.*pix_size, pix_size, abs(uv.y - g_dmu)));\n    \n    float g_dvar = normal_dist_dvar(uv.x, 0., variance);\n    color = mix(color, vec3(0.05, .3, .675), smoothstep(2.*pix_size, pix_size, abs(uv.y - g_dvar)));\n    \n    float g_dsig = normal_dist_dsig(uv.x, 0., sqrt(variance));\n    color = mix(color, vec3(0.95, .7, .325), smoothstep(2.*pix_size, pix_size, abs(uv.y - g_dsig)));\n\n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}