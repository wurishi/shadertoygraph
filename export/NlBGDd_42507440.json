{"ver":"0.1","info":{"id":"NlBGDd","date":"1624948739","viewed":144,"name":"Bicomplex Mandelbrot 2","username":"kibitz9","description":"A bicomplex mandelbrot sliced in half to reveal the 2 dimensional mandelbrot set hidden inside.\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","distanceestimation","bicomplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//***************************************************************//\n// Bicomplex Mandelbrot by CMiller (kibitz9)\n// A bicomplex mandelbrot sliced in half to show the set inside.\n// The interior distance estimate is not accurate hence the banding.\n//***************************************************************// \n\nvec4 square(vec4 B){\n    //Bicomplex square\n    float a=B.x;\n    float b=B.y;\n    float c=B.z;\n    float d=B.w;\n    return vec4(\n         a* a- b* b- c* c+ d* d\n        ,2.* a* b-2.* c* d\n        ,2.* a* c-2.* b* d\n        ,2.* a* d+2.* b* c\n     );\n}\nvec4 mult(vec4 A, vec4 B){\n    //Bicomplex multiplication\n    float a=A.x;\n    float b=A.y;\n    float c=A.z;\n    float d=A.w;\n    float e=B.x;\n    float f=B.y;\n    float g=B.z;\n    float h=B.w;\n    \n    return vec4(\n        a*e-b*f-c*g+d*h,\n        b*e+a*f-d*g-c*h,\n        c*e-d*f+a*g-b*h,\n        d*e+c*f+b*g+a*h\n    );\n        \n}\n\nvec4 zero = vec4(0,0,0,0);\nvec4 two = vec4(2,0,0,0);\nvec4 one = vec4(1,0,0,0);\n\nfloat mb(in vec4 c, in int itr){\n\n    vec4 z=zero;\n    vec4 dz=one;\n    int a=0; \n    for (;a<itr;a++){\n\n        dz=mult(2.0*z,dz)+1.;\n        z=square(z)+c;\n      \n        float sqrd = dot(z,z);\n        if (sqrd>10000.){\n            break;\n        }\n    }\n    if (a==itr-1){\n        return 0.;\n    }\n    float lz = length(z);\n    float ldz = length(dz);\n    float dist = (log(lz)*lz)/ldz;\n    \n    return dist/2.;\n  \n\n}\n\n\nfloat map(in vec3 q){\n\n    //return 1.0;\n    vec3 p=q;\n\n    float lookDown=.2;\n    p=vec3(p.x,p.y*cos(lookDown)+p.z*-sin(lookDown),p.z*cos(lookDown)+p.y*sin(lookDown));\n\n    float rot = 4.25;\n\n    p =vec3(\n        p.x*cos(iTime/rot)+p.z*-sin(iTime/rot),\n        p.y\n        ,p.z*cos(iTime/rot)+p.x*sin(iTime/rot)\n        );\n\n    p=p+vec3(0.,-2.,0.);\n    \n\n    \n    float m= mb(vec4(p.x-.1,p.y,p.z,0.),100);\n    \n    //float m2= mb(vec4(-q.y+1.1,q.x-2.5,q.z,0.),20);\n    \n    \n    m=abs(m)-.0001;\n    m=max(m,-p.z-0.);\n    m=min(m,q.y-.1);\n    m=min(m,-q.z+3.);\n    //m=min(m,m2);\n    \n    \n    return m;\n }\n    \n    \n    \n \n    \n\n\nvec3 getSurfaceNormal( in vec3 p, float epsilon ) // for function f(p)\n{\n  \n    return normalize(\n        GLOBAL_PN_XYY*map(p+GLOBAL_PN_XYY_EPS) +\n        GLOBAL_PN_YYX*map(p+GLOBAL_PN_YYX_EPS) +\n        GLOBAL_PN_YXY*map(p+GLOBAL_PN_YXY_EPS) +\n        GLOBAL_PN_XXX*map(p+GLOBAL_PN_XXX_EPS) \n    \n    );\n}\n\n\nvoid rayMarch(\n    in vec3 origin, \n    in vec3 ray, \n    in float epsilon,\n    in float maxSteps,\n   \n    out vec3 marchPoint,\n    out float marchPointDist,\n    out float stepsTaken\n\n\n){\n    \n  \n    \n    stepsTaken = 0.0;\n    marchPoint=origin;\n    float h = map(marchPoint);\n    while (h>epsilon&&stepsTaken++<maxSteps&&h<MAX_DIST){\n        marchPoint+=ray*h;       \n        h=map(marchPoint);\n    }   \n    marchPointDist=h;\n}\n\nfloat softShadowBalanced(vec3 surface, vec3 light, float radius, float maxDist){\n   \n    \n      \n    vec3 surfaceToLight = light-surface;\n    float distanceToLight=length(surfaceToLight);\n    float maxDist2 = min(maxDist,distanceToLight);\n    vec3 ray =normalize(surfaceToLight);\n    float artifactCompensation = 2.0;\n    float minDist = .001;//think about this.\n    \n    float travelled = minDist;\n    float xx=1.0;\n    while (travelled < maxDist2){\n    \n        float ratioTravelled=travelled/distanceToLight;\n        \n       \n        float relativeRadius=ratioTravelled*radius;\n        \n        float dist=map(surface+ray*travelled);\n         \n        if (dist<-relativeRadius){\n            return 0.0;\n        }\n        float relativeDiameter=relativeRadius*2.0;\n        \n        float dist2=dist+relativeRadius;\n        xx = min(xx,dist2/relativeDiameter);\n        \n       \n        float artifatCompensation2 = artifactCompensation*clamp(relativeRadius/dist,0.,1.);\n        travelled +=max(abs(dist/artifactCompensation),minDist);\n        \n        \n    }\n       \n   return xx;\n    \n\n    \n}\n\nvec3 power(vec3 vec, float power){\n    return vec3(pow(vec.x,power),pow(vec.y,power),pow(vec.z,power));\n}\n\n\n\nvoid calcLight(\n    in vec3 surfacePoint, \n    in float shineAtPosition,\n    in vec3 lightPosition,\n    in vec3 observationPosition,\n    in vec3 lightColor,\n    in float lightBrightness,\n    in vec3 surfaceNormal,\n    in float epsilon,\n    out vec3 diffuse, \n    out vec3 specular){\n    \n \n     \n    vec3 col0 = lightColor;\n    \n    \n    vec3 surfaceToLight=lightPosition-surfacePoint;\n    vec3 normalToLight=normalize(surfaceToLight);\n    \n    float oneOverDistToLightSquared = lightBrightness/dot(surfaceToLight,surfaceToLight);\n    \n    \n    \n    float dp = dot(normalToLight,surfaceNormal);\n \n    dp=max(dp,0.0);\n\n    \n    diffuse=dp*lightColor*oneOverDistToLightSquared;\n    \n    \n    vec3 rayToObs=normalize(observationPosition-surfacePoint);\n    vec3 avg = normalize(normalToLight+rayToObs);\n    float spec = dot(avg,surfaceNormal);\n    spec = max(spec,0.0);\n    \n    spec = pow(spec,shineAtPosition);\n\n    specular=lightColor*spec*oneOverDistToLightSquared;\n    \n    float shadowAdjust = 1.0;\n    \n\n    if (true){\n        float s = softShadowBalanced(surfacePoint,lightPosition,5.0, 500.); \n        diffuse*=s*shadowAdjust;\n        specular*=s*shadowAdjust;\n    }\n \n}\n\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec3 eye = vec3(0.0,0.0,-.5);\n    vec3 lense = vec3(0.0,0.0,.5);\n    float xxx = 0.;\n    vec3 cameraPosition = vec3(0.,2.,-(6.+xxx)+sin(iTime/10.)*xxx);\n    float specAmt = 0.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float epsilon1 = .002;\n    \n   \n    vec3 objColor=vec3(1,1,1);\n  \n    vec2 ar = (fragCoord/iResolution.x)\n        -vec2(.5,iResolution.y/(2.0*iResolution.x));\n    vec3 lenseIntersection = vec3(ar,lense.z);\n    \n    vec3 ray = normalize(lenseIntersection-eye);\n   \n    \n    float stepsTaken;\n    vec3 finalPosition;\n    float finalDistance;\n\n    float maxSteps = 4000.0;\n    \n    rayMarch(eye+cameraPosition,ray,epsilon1,maxSteps,finalPosition,finalDistance,stepsTaken);\n    \n  \n    \n    float objectShine=7.;\n    \n    \n    vec3 diffuse1;\n    vec3 specular1;\n\n    vec3 diffuse2;\n    vec3 specular2;\n\n    vec3 diffuse3;\n    vec3 specular3;\n\n    vec3 diffuse4;\n    vec3 specular4;\n    if (finalDistance<epsilon1){\n    \n\n        finalPosition = finalPosition+(ray*epsilon1*-2.0);\n        vec3 normal = getSurfaceNormal(finalPosition,epsilon1);\n        \n       \n        \n        float lightBrightness = 1400.;\n        float specMult = 2.0;\n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(60.0,80.0,-80.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.5,.5,1)*.5,//light color\n            lightBrightness*20.,//light bright\n            normal,\n            epsilon1,\n            diffuse1,\n            specular1\n        );\n        \n        /*\n         calcLight(\n            finalPosition,\n            objectShine,\n            vec3(-60.0,80.0,-80.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.6,.5,0.)*.5,//light color\n            lightBrightness*4.,//light bright\n            normal,\n            epsilon1,\n            diffuse2,\n            specular2\n        );\n        */\n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(-60.0,30.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.5,1.,.1)*.5,//light color\n            lightBrightness*1.,//light bright\n            normal,\n            epsilon1,\n            diffuse2,\n            specular2\n        );\n        */\n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(130.0,30.0,-480.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.9,.3)*.5,//light color\n            lightBrightness*5.,//light bright\n            normal,\n            epsilon1,\n            diffuse3,\n            specular3\n        );\n        */\n        \n        \n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,10.0,-5.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.8,.5)*.5,//light color\n            lightBrightness/20000.,//light bright\n            normal,\n            epsilon1,\n            diffuse4,\n            specular4\n        );\n    */\n    \n    \n        vec3 col1=objColor*max(diffuse1,0.0);\n        col1+=specular1*specMult;\n        \n        //vec3 col2=objColor*max(diffuse2,0.0);\n       // col2+=specular2*specMult;\n        \n        //vec3 col3=objColor*max(diffuse3,0.0);\n        //col3+=specular3*specMult;\n        \n        //vec3 col4=objColor*max(diffuse4,0.0);\n        //col4+=specular4*specMult;\n        \n        \n      \n        \n        //vec3 colFinal = min(col1+col2,1.0);\n        //vec3 colFinal = min(col1+col2+col3+col4,1.);\n        vec3 colFinal = min(col1,1.);\n        colFinal=power(colFinal,.9);\n        fragColor = vec4(colFinal,1.0);\n        \n    }\n    else{\n        fragColor = vec4(.2,0,0,1.0);\n\n    }\n    \n    \n    \n    \n    \n}\n\nvoid AntiAlias3( out vec4 fragColor, in vec2 fragCoord, float aaLevel){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float subPixel = 1.0/aaLevel;\n    vec4 result = vec4(0,0,0,1);\n    for (float x=fragCoord.x;x<fragCoord.x+1.0;x+=subPixel){\n        for (float y=fragCoord.y;y<fragCoord.y+1.0;y+=subPixel){\n            vec4 temp;\n            mainImage1(temp,vec2(x,y));\n            result+=temp;\n        }\n    }\n    \n   \n    \n    \n    fragColor = result/(aaLevel*aaLevel);\n   \n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord){\n    \n    //AntiAlias3(fragColor, fragCoord,2.);\n    vec4 result = vec4(0,0,0,1);\n    mainImage1(result,fragCoord);\n    fragColor=result;\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float GLOBAL_EPSILON = .0005;\nconst vec2 GLOBAL_PN = vec2(1,-1);\nconst vec3 GLOBAL_PN_XYY=GLOBAL_PN.xyy;\nconst vec3 GLOBAL_PN_YYX=GLOBAL_PN.yyx;\nconst vec3 GLOBAL_PN_YXY=GLOBAL_PN.yxy;\nconst vec3 GLOBAL_PN_XXX=GLOBAL_PN.xxx;\n\nconst vec3 GLOBAL_PN_XYY_EPS=GLOBAL_PN_XYY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YYX_EPS=GLOBAL_PN_YYX*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YXY_EPS=GLOBAL_PN_YXY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_XXX_EPS=GLOBAL_PN_XXX*GLOBAL_EPSILON;\nconst float MAX_DIST = 10.0;","name":"Common","description":"","type":"common"}]}