{"ver":"0.1","info":{"id":"XfSfWR","date":"1724781569","viewed":33,"name":"slow fog","username":"minddome","description":"slow fog","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["slowfog"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define maxDist 10.\n#define nStep 10  // Reduziere die Anzahl der Schritte weiter\n#define nStepLight 2  // Reduziere die Anzahl der Lichtsteps\n\nfloat saturate(float i)\n{\n    return clamp(i, 0., 1.);\n}\n\nfloat hash(float n)\n{\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat hashi(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float(n & 0x7fffffffU) / float(0x7fffffff);\n}\n\nfloat noise(float p)\n{\n    float fl = floor(p);\n    float fc = fract(p);\n    return mix(hash(fl), hash(fl + 1.0), fc);\n}\n\nfloat noise(vec3 x)\n{\n    x *= 8.; // Weiter reduzieren\n    x += 0.5;\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    x = f + i;\n    x -= 0.5;\n\n    return texture(iChannel0, x / 8.0).x; // Weiter reduzieren\n}\n\nconst mat3 m = mat3(\n    0.00,  0.80,  0.60,\n   -0.80,  0.36, -0.48,\n   -0.60, -0.48,  0.64\n);\n\nfloat fbm(vec3 p)\n{\n    float f;\n    f = 0.5000 * noise(p);\n    p = m * p * 2.02;\n    f += 0.2500 * noise(p);\n    return f; // Noch weiter reduzieren\n}\n\nvec3 camera(vec2 ndc, vec3 camPos, float f, vec3 lookAt)\n{\n    vec3 forward = normalize(lookAt - camPos);\n    vec3 right = cross(vec3(0., 1., 0.), forward);\n    vec3 up = normalize(cross(forward, right));\n    right = normalize(cross(up, forward));\n\n    vec3 rd = up * ndc.y + right * ndc.x + f * forward;\n\n    return rd;\n}\n\nfloat map(vec3 p)\n{\n    float v;\n    vec3 location = p;\n\n    p = p * 0.009;\n    v = fbm(p);\n    v = noise(iTime * 0.005 + p + 0.15 * vec3(v, v, v)); // Weiter reduzieren\n\n    float d = saturate((1. - (length(location) / 9.)));\n    v = v * d - 0.1;\n\n    return 1.3 * saturate(v);\n}\n\nfloat lightMarch(vec3 ro, vec3 lightPos)\n{\n    vec3 rd = lightPos - ro;\n    float d = length(rd);\n    rd = rd / d;\n    float t = 0.;\n    float stepLength = d / float(nStepLight);\n    float densitySum = 0.;\n    float sampleNoise;\n    for (int i = 0; i < nStepLight; i++)\n    {\n        sampleNoise = map(ro + t * rd);\n        densitySum += sampleNoise;\n        t += stepLength;\n    }\n\n    return exp(-d * (densitySum / float(nStepLight)));\n}\n\nvec3 calculateLight(vec3 samplePos, vec3 lightPos, vec3 lightColor, float lightStr)\n{\n    float sampleLight = lightMarch(samplePos, lightPos);\n    float distToLight = length(lightPos - samplePos) + 1.;\n    vec3 light = lightColor * lightStr * (1. / (distToLight * distToLight)) * sampleLight;\n    return light;\n}\n\nvec3 march(vec3 ro, vec3 rd, float dither, float var)\n{\n    float value = 0.;\n    float t = dither;\n    float densitySum = 0.;\n\n    float stepLength = maxDist / float(nStep);\n    vec3 color = vec3(0.02, 0.04, 0.02) * 1.; // Grundfarbe\n\n    for (int i = 0; i < nStep; i++)\n    {\n        vec3 samplePos = ro + t * rd;\n        float sampleNoise = map(samplePos);\n        densitySum += sampleNoise;\n\n        // Eine einzige Lichtquelle\n        vec3 lightPos1 = vec3(-18, 1.8, 0);\n        vec3 light1 = calculateLight(samplePos, lightPos1, vec3(0.1, 0.1, 0.5), 20.);\n\n        vec3 ambientColor = vec3(0.2, 0.2, 0.25); // Umgebungslicht\n\n        color += exp(-t * (densitySum / float(i + 1))) * sampleNoise * (ambientColor + light1);\n\n        t += stepLength * var;\n    }\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ndc = uv * 2. - 1.;\n    ndc.x *= iResolution.x / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 lookAt = vec3(0.);\n\n    float distanceToCenter = (sin(0.1 * iTime) * 0.5 + 1.) * 3. + 3.;\n    vec3 cameraPos = vec3(distanceToCenter * cos(0.05 * iTime), 0., distanceToCenter * sin(0.05 * iTime)); // Verlangsamt die Kamerabewegung\n\n    vec3 rd = camera(ndc, cameraPos, 1.0, lookAt);\n    float var = length(rd) / 1.0; // to get constant z in samples\n    rd = normalize(rd);\n\n    float dither = 0.5 * hashi(uint(fragCoord.x + iResolution.x * fragCoord.y) + uint(iResolution.x * iResolution.y) * uint(iFrame)); // Updated with iFrame dimension\n\n    vec3 col = march(cameraPos, rd, dither, var);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}