{"ver":"0.1","info":{"id":"XcKXW3","date":"1719944130","viewed":193,"name":"day-night cycle","username":"FyKru","description":"Day-night cycle on a lake\nAll parameters can be modified. Some optimization could have been done in places, but I chose to have something customizable instead.","likes":27,"published":1,"flags":0,"usePreview":0,"tags":["sun","clouds","cycle","landscape","moon","mountains","lake"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define Speed 0.06\n\n//-----------PARAMETERS-----------\n\n//-------SKY-------\nconst vec3 dayColT = vec3(0.04, 0.61, 0.76);\nconst vec3 dayColB = vec3(0.70, 0.87, 0.86);\n\nconst vec3 nightColT = vec3(0.02, 0.25, 0.56);\nconst vec3 nightColB = vec3(0.60, 0.51, 0.82);\n\n//-----CLOUDS-----\nconst float cloudSeed = 2.0;\nconst int nbrOfClouds = 5;\nconst float cloudsSize = 0.2;\nconst int cloudsRes = 30; \nconst float cloudsIterationSize = 0.1;\nconst float cloudsColor = 0.5; //[0.0;1.0]\nconst float cloudSpeed = 0.1;\n\n\n//-----MOUNTAINS-----\nconst float mtnSeed = 1.;\nconst vec3 mtnBCol = vec3(0.50, 0.46, 0.33);\nconst float mtnLightInt = 0.5; //[0.0;1.0]\n\n\n//-----WATER-----\nconst float waterHeight = 0.1;\nconst vec3 waterCol = vec3(0.51, 0.74, 0.77);\nconst float waterColFactor = 0.5;\n\n//-------MOON-------\nconst vec3 mCol = vec3(1.,1.,1.);\nconst float mRadOut = 0.1;\nconst float mRadIn = 0.09;\nconst vec2 mInOffset = vec2(0.025,0.03);\n\n//-------SUN-------\nconst vec3 sCol = vec3(1.,1.,1.);\nconst float sRad = 0.1;\n\n\n\nvec3 Sky(vec2 p, float ToD)\n{\n    vec3 day = mix(dayColB, dayColT, p.y);\n    vec3 night = mix(nightColB, nightColT, p.y);\n    \n    return mix(day, night, abs(ToD * 2.0 - 1.0));\n}\n\nvec4 Moon(vec2 p)\n{\n    float m = length(p) - mRadOut;\n    float cut = length(p - mInOffset) - mRadIn;\n    return vec4(mCol, smoothstep(0.01,0.0,max(m, -cut)));\n}\n\nvec4 Sun(vec2 p)\n{\n    return vec4(sCol, smoothstep(0.01,0.0,length(p) - sRad));\n}\n\nvec3 Cloud(vec2 p,vec2 ctr, float rad, int d, vec2 seed)\n{\n    p -= ctr;\n    p.y = min(p.y, p.y *10.0);\n    \n    \n    float c = 100.0;\n    vec2 dir = vec2(0.0);\n    for(int i = 0; i<d; ++i)\n    {\n        vec2 rand = Rand(seed + float(i));\n        float theta = rand.x * 2.0* PI;\n        float r = rand.y * rad;\n        vec2 circlePos = vec2(r* sin(theta)*2., r*cos(theta));\n        circlePos.y -= clamp(abs(circlePos.x),0.,r/2.);\n        float circle = Circle(p-circlePos, cloudsIterationSize);\n        if(circle < c)\n            dir = normalize(p - circlePos);\n        c = min(c, circle);\n    }\n    return vec3(dir,c);\n}\n\nvec4 Clouds(vec2 p, vec2 sunPos, vec2 moonPos, float ToD)\n{\n    vec2 seed = Rand(vec2(0.0 + cloudSeed));\n    vec2 cPos = seed;\n    cPos.x = fract(cPos.x + iTime*cloudSpeed * Speed*10.);\n    cPos = cPos * vec2(5.0,1.0) - vec2(2.5,0.0);\n    \n    vec3 cloudDF = Cloud(p, cPos, cloudsSize, cloudsRes,seed);\n      \n    for(int i = 1; i<nbrOfClouds; ++i)\n    {\n          seed = Rand(vec2(0.0 + cloudSeed + float(i)) + float(i));\n          cPos = seed;\n          cPos.x = fract(seed.x + iTime*cloudSpeed*seed.x * Speed*10.);\n          cPos = cPos * vec2(5.0,1.0) - vec2(2.5,0.0);\n          vec3 nc = Cloud(p, cPos, cloudsSize, cloudsRes, seed);\n          float factor = clamp(sign(nc.z - cloudDF.z),0.0,1.0);\n          cloudDF = mix(nc, cloudDF, factor);\n    }\n      \n      \n    float light = clamp(dot(normalize(sunPos), cloudDF.xy),0.0,1.0);\n     \n    float cloudSides = step(cloudDF.z,0.001);\n    cloudSides -= step(cloudDF.z,- light/20.0);\n    \n    vec3 mainCol = mix(vec3(1.0),Sky(sunPos,ToD),cloudsColor);\n    vec3 shadowCol = mix(vec3(0.7),Sky(moonPos,ToD),cloudsColor);\n    \n    vec3 cloud = shadowCol * smoothstep(0.01,0.0,cloudDF.z);\n    cloud = mix(cloud, mainCol, smoothstep(0.1,0.2,cloudSides * light));\n    \n    \n    return vec4(cloud, smoothstep(0.01,0.0, cloudDF.z));\n}\n\nvec4 Mountain(vec2 p, float ToD, vec2 sunP, float seed)\n{\n    float h = noise(p.x*5. + 10. + mtnSeed + seed)/5.0;\n    float m = smoothstep(h,h-0.01,p.y);\n    float dir = sign((noise((p.x+.01)*5. + 10. - p.y + mtnSeed + seed)) - (noise((p.x)*5. + 10. - p.y + mtnSeed + seed)));\n    \n    \n    dir = dir * sunP.x;\n    \n    vec3 mDLight = mix(dayColB, dayColT, dir);\n    vec3 mNLight = mix(nightColB, nightColT, dir);\n    \n    vec3 mLight =  mix(mDLight, mNLight, abs(ToD *2.0 -1.0));\n    mLight *= m;\n    //return vec4(vec3(m), 1.);\n    \n    \n    return vec4(mix(mtnBCol, mLight - 0.1, mtnLightInt),m*clamp(sign(m),0.0,1.0));\n}\n\nvec2 Water(vec2 p)\n{\n    vec2 water = vec2(p.x,-p.y-waterHeight*2.);\n    water.y += sin(p.y*100.+iTime*2.)/50.;\n    //water.x += sin(p.x*100.+iTime*2.)/80.;\n    \n    \n    p = mix(water, p, clamp(sign(p.y+waterHeight),0.,1.));\n    //p.x += sin(p.y*100.)/30.;\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec2 pb = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec2 p = Water(pb);\n    \n    float ToD = fract(iTime * Speed);\n    \n    vec3 sky = Sky(p,ToD);\n    \n    vec2 moonP = vec2(sin(ToD * 2.0 * PI), cos(ToD * 2.0 * PI) * 0.75);\n    vec2 sunP = moonP * vec2(-1.0,-1.0);\n    \n    vec4 moon = Moon(p - moonP);\n    vec4 sun  = Sun(p - sunP);\n    \n    vec4 clouds = Clouds(p, sunP, moonP, ToD);\n    \n    vec4 mountainA = Mountain(p, ToD, sunP, 1.);\n    vec4 mountainB = Mountain(p+0.1, ToD, sunP, 10.);\n    \n    vec3 r = sky;\n    r = mix(r, moon.xyz, moon.w);\n    r = mix(r, sun.xyz, sun.w);\n    r = mix(r, mountainA.xyz, mountainA.w);\n    r = mix(r, mountainB.xyz, mountainB.w);\n    r = mix(r, clouds.xyz, clouds.w);\n    \n    //water color\n    vec3 waterCol = mix(r, waterCol, waterColFactor);\n    r = mix(waterCol, r, clamp(sign(pb.y + waterHeight),0.,1.));\n    \n    fragColor = vec4(r,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Precision-adjusted variations of https://www.shadertoy.com/view/4djSRW\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\n\nvec2 Rand(vec2 seed)\n{\n    return vec2(fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453),fract(sin(dot(seed, vec2(35.1675, 58.753))) * 76149.2864));\n}\n\nfloat Circle(vec2 p, float r)\n{\n    return length(p) -r;\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}","name":"Common","description":"","type":"common"}]}