{"ver":"0.1","info":{"id":"NtlBWr","date":"1650734085","viewed":86,"name":"L2, L1, L-inf, Lp metrics","username":"Envy24","description":"L2, L1, L_infinity metrics (distance functions) for 2-dimensions.\nSource: Gonzalez & Woods, Digital Image Processing","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["distance","function","l1","linfinity","metrics","l2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                        iResolution\n#define TO_CENTERED_NDC(SC)    ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat discrete_metric(vec2 b, vec2 e)\n{\n    vec2 be = e - b;\n    return \n        be.x == be.y ?\n        //abs(be.x - be.y) <= 1e-1 ?\n            0.0 :\n            1.0;\n}\n\n/* Euclid distance (L2 metric) */\nfloat L2(vec2 b, vec2 e)                            // same as Lp(b, e, L2).\n{\n    vec2 be = e - b;\n    return sqrt(be.x * be.x + be.y * be.y);         // L2-norm of be.\n}\n\n/* 4-neighbor connection distance (L1 metric) */\nfloat L1(vec2 b, vec2 e)                            // same as L1(b, e, 1.).\n{\n    vec2 be = e - b;\n    return abs(be.x) + abs(be.y);                   // L1-norm of be.\n}\n\n/* 8-neighbor connection distance (L_infinity metric) */\nfloat L_infinity(vec2 b, vec2 e)                    // same as Lp(b, e, inf).\n{\n    vec2 be = e - b;\n    return max(abs(be.x), abs(be.y));               // Linf-norm of be.\n}\n\n/* https://en.wikipedia.org/wiki/Lp_space */\nfloat L_in_power_P(vec2 b, vec2 e, float p)\n{\n    vec2 be = e - b;\n    return pow(                                     // Lp-norm of be.\n            pow(abs(be.x), p) + pow(abs(be.y), p),\n            1.0 / p);\n}\n\n/* All metrics can be generalized to higher dimensions. */\n\n/* https://www.shadertoy.com/view/ddfGz2 */\nvec3 colorize_field(float dist, vec3 color)\n{    \n    float F = 30., freq = F*dist, aa = 1./F, C = 0.7, amp = 0.2, width = 0.3,\n          waves_sdf = C + amp*smoothstep(8./R.y, 0., (width+cos(freq)) * aa),\n          exp_raise = 1. - exp(-4.*abs(dist));\n        \n    color = 1.0 - sign(dist) * color; // Change color if dist is negative. \n    color *= exp_raise;               // Attenuate color around edges.     \n    color *= waves_sdf;               // Add waves.\n    \n    return mix(color, vec3(1), smoothstep(8./R.y, 0., abs(dist)) );\n}\n\nvec3 add_metric(\n    vec2 NDC,\n    vec3 color)\n{\n    float unit = 7.0 / R.y;\n\n    vec2 M = \n        LMB_IS_HOLD ?\n            TO_CENTERED_NDC(iMouse.xy) :\n            rotateAroundZ(vec2(1, 0), iTime * 0.5);\n            //vec2(0);\n            \n    // Add point\n    color = mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, length(NDC - M) - 0.008));\n\n    float t = sinOSC(1.0, 25.0, iTime * 0.5);\n    float dist_form_point_to_box_edge = L_in_power_P(NDC, M, t) - abs(L_in_power_P(vec2(0), M, t) - 0.25);\n    float outline = abs(dist_form_point_to_box_edge);\n    \n    // Add metric\n    return mix(color, vec3(1.0, 1.0, 0.0), smoothstep(unit, 0.0, outline));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = TO_CENTERED_NDC(SC);\n    vec2 origin = vec2(0.0, 0.0);\n\n    /**\n    float distance =                               // Distance from circle center to edge.\n        mix(\n            L2(NDC, origin),  \n            mix(\n                L1(NDC, origin),\n                L_infinity(NDC, origin),\n                sinOSC(0.0, 1.0, iTime * 0.5)),\n            sinOSC(0.0, 1.0, iTime)) - 0.25;\n    /**/\n            \n    float distance = L_in_power_P(NDC, origin, sinOSC(1.0, 25.0, iTime * 0.5)) - 0.25;\n     \n    vec3 color = colorize_field(distance, vec3(0.2, 0.5, 0.7));\n    color = add_metric(NDC, color);\n     \n    O = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}","name":"Common","description":"","type":"common"}]}