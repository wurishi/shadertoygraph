{"ver":"0.1","info":{"id":"Nts3W2","date":"1622885588","viewed":141,"name":"Magnetic-core memory","username":"shyuriken","description":"Magnetic-core memory","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Processed by 'GLSL Shader Shrinker' (Shrunk by 2,520 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n#define LIGHT\tnormalize(vec3(1, 1, 0))\n\nfloat pCylinder(float r, float h, vec3 p) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nvec3 mTranslation(vec3 inv_translation, vec3 p) { return p + inv_translation; }\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nvec3 mRepInf(vec3 cell_size, vec3 p) { return p - cell_size * round(p * vec3(greaterThan(cell_size, vec3(0))) / cell_size); }\n\nfloat oUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat oSubtraction(float d1, float d2) { return max(d1, -d2); }\n\nfloat sdf(vec3 p0) {\n\tfloat d1, d2, d3, d4, d5, d6, d7, d8, d9, d10, d11, d12, d13, d14;\n\t{\n\t\tvec3 p1 = mRepInf(vec3(4.77, -1.31, 4.75), p0);\n\t\t{\n\t\t\tvec3 p2 = mTranslation(vec3(0), p1);\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(1, -.13, 0), p2);\n\t\t\t\t{ d1 = pCylinder(.06, 4., mRotation(mat3(0, -0, -1, 1, 0, -0, 0, -1, 0), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(0, .11, 0), p2);\n\t\t\t\t{ d2 = pCylinder(.06, 4., mRotation(mat3(0, -.707107, .707107, 1, 0, -0, -0, .707107, .707107), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(0, .25, -.01), p2);\n\t\t\t\t{ d3 = pCylinder(.06, 4., mRotation(mat3(0, -.707107, -.707107, 1, 0, -0, 0, -.707107, .707107), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(0), p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-1, 0, -1), p3);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mRotation(mat3(0, -.707107, -.707107, 1, 0, -0, 0, -.707107, .707107), p4);\n\t\t\t\t\t\td4 = pCylinder(1., .2, p5);\n\t\t\t\t\t\td5 = pCylinder(.6, .25, p5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(-1, 0, 1), p3);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mRotation(mat3(0, -.707107, .707107, 1, 0, -0, -0, .707107, .707107), p4);\n\t\t\t\t\t\td6 = pCylinder(1., .2, p5);\n\t\t\t\t\t\td7 = pCylinder(.6, .25, p5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(0), p2);\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(1, 0, 1), p3);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mRotation(mat3(0, -.707107, -.707107, 1, 0, -0, 0, -.707107, .707107), p4);\n\t\t\t\t\t\td8 = pCylinder(.6, .25, p5);\n\t\t\t\t\t\td9 = pCylinder(1., .2, p5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tvec3 p4 = mTranslation(vec3(1, 0, -1), p3);\n\t\t\t\t\t{\n\t\t\t\t\t\tvec3 p5 = mRotation(mat3(0, -.707107, .707107, 1, 0, -0, -0, .707107, .707107), p4);\n\t\t\t\t\t\td10 = pCylinder(.6, .25, p5);\n\t\t\t\t\t\td11 = pCylinder(1., .2, p5);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(-1, -.12, 0), p2);\n\t\t\t\t{ d12 = pCylinder(.06, 4., mRotation(mat3(1, -0, 0, 0, 0, -1, 0, 1, 0), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(0, -.01, -1), p2);\n\t\t\t\t{ d13 = pCylinder(.06, 4., mRotation(mat3(0, -1, 0, 1, 0, -0, 0, 0, 1), p3)); }\n\t\t\t}\n\t\t\t{\n\t\t\t\tvec3 p3 = mTranslation(vec3(0, .01, 1), p2);\n\t\t\t\t{ d14 = pCylinder(.06, 4., mRotation(mat3(0, -1, 0, 1, 0, -0, 0, 0, 1), p3)); }\n\t\t\t}\n\t\t}\n\t}\n\treturn oUnion(oSubtraction(d9, d8), oUnion(oSubtraction(d11, d10), oUnion(d2, oUnion(d3, oUnion(d1, oUnion(oSubtraction(d6, d7), oUnion(oSubtraction(d4, d5), oUnion(d12, oUnion(d13, d14)))))))));\n}\n\nvec3 RayMarch(vec3 rayDir, vec3 cameraOrigin) {\n\tfloat dist = .01,\n\t      totalDist = 0.,\n\t      itter = 0.;\n\tvec3 pos = cameraOrigin;\n\tfor (int i = 0; i < 128; i++) {\n\t\tdist = sdf(pos);\n\t\titter++;\n\t\ttotalDist += dist;\n\t\tpos += dist * rayDir;\n\t\tif (dist < .01 || totalDist > 130.) break;\n\t}\n\n\treturn vec3(dist, totalDist, itter / 128.);\n}\n\nfloat AO(vec3 pos, vec3 n) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 3; i++) {\n\t\taopos = pos + n * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro),\n\t     cu = normalize(cross(cw, vec3(sin(cr), cos(cr), 0)));\n\treturn mat3(cu, normalize(cross(cu, cw)), cw);\n}\n\nvec4 NorCurv(vec3 p) {\n\tconst vec2 e = vec2(-.01, .01);\n\tfloat t1 = sdf(p + e.yxx),\n\t      t2 = sdf(p + e.xxy),\n\t      t3 = sdf(p + e.xyx),\n\t      t4 = sdf(p + e.yyy);\n\treturn vec4(normalize(e.yxx * t1 + e.xxy * t2 + e.xyx * t3 + e.yyy * t4), .25 / e.y * (t1 + t2 + t3 + t4 - 4. * sdf(p)));\n}\n\nvec3 Lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos) { return vec3(max(0., dot(LIGHT, n)), pow(max(0., dot(reflectDir, LIGHT)), 10.), 1. - max(0., dot(-n, rayDir))) * .5; }\n\nfloat TriplanarTexture(vec3 pos, vec3 n) { return 0.; }\n\nfloat BackGround(vec3 rayDir) { return smoothstep(1., 0., clamp(length(rayDir - LIGHT), 0., 1.)) * .5; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 cameraOrigin = vec3(0);\n\tif (iMouse.z > 0.) {\n\t\tcameraOrigin.x = sin(iMouse.x * .01) * 5.;\n\t\tcameraOrigin.y = iMouse.y * .05 - 10.;\n\t\tcameraOrigin.z = cos(iMouse.x * .01) * 5.;\n\t}\n\telse {\n\t\tcameraOrigin.x = sin(iTime * .25 + 2.) * (6. + sin(iTime * .1));\n\t\tcameraOrigin.y = sin(iTime * .3) + 12.5;\n\t\tcameraOrigin.z = cos(iTime * .25 + 2.) * (6. + sin(iTime * .15)) - 10.;\n\t}\n\n\tvec2 screenPos = uv * 2. - 1.;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tmat3 cam = SetCamera(cameraOrigin, vec3(0, .25, -1), sin(iTime * .15) * .5);\n\tvec3 rayDir = cam * normalize(vec3(screenPos, 2)),\n\t     dist = RayMarch(rayDir, cameraOrigin);\n\tfloat res,\n\t      backGround = BackGround(rayDir);\n\tif (dist.x < .01) {\n\t\tvec3 l,\n\t\t     pos = cameraOrigin + dist.y * rayDir;\n\t\tvec4 n = NorCurv(pos);\n\t\tfloat col,\n\t\t      ao = AO(pos, n.xyz);\n\t\tl = Lighting(-n.xyz, rayDir, reflect(rayDir, n.xyz), pos);\n\t\tcol = TriplanarTexture(pos, n.xyz);\n\t\tcol *= n.w * .5 + .5;\n\t\tcol *= ao;\n\t\tcol += ao * (l.x + l.y);\n\t\tcol += l.z * .35;\n\t\tcol += BackGround(n.xyz) * .25;\n\t\tres = col;\n\t}\n\telse res = backGround;\n\n\tfragColor = vec4(vec3(res), 1);\n}","name":"Image","description":"","type":"image"}]}