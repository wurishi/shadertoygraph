{"ver":"0.1","info":{"id":"NttBD8","date":"1663026473","viewed":100,"name":"Planet with Rings","username":"RangerDanger550","description":"Its a planet with rings around it","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere(vec3 p, float r)\n{\n  return length(p) - r; // p is the test point and r is the radius of the sphere\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nbool testScenePos(vec3 eye, vec3 direction, out vec3 outPos)\n{\n    float t = 0.0;\n    \n    for( int i = 0; i < 30; i++){\n        //calc positions from view rays\n        vec3 pos = eye + direction * t;\n          \n        \n        //get distance from positions to spheres\n        //float dist = min(sdSphere(pos - vec3(0,0,0), 5.0f), sdTorus(pos, vec2(10.0, 1.0)));\n                                \n                                \n        //dist = opSmoothUnion(sdTorus(rotateY(iTime)*pos, vec2(120.0f, 0.25f)), sdSphere(pos- vec3(0,0,0), 4.0f), 10.0);\n    \n        float dist = min(sdSphere(pos- vec3(0,0,0), 5.0f), min(sdTorus(pos, vec2(100.0, 00.1)), sdTorus(pos, vec2(50.0, 0.1))));\n                                \n                                \n   \n    \n        if(dist < 0.001){\n        \n           outPos = pos;\n           return true;\n        }\n        t += dist;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float temp = 10.0*sin(fragCoord.x/90.0 + iTime*abs(sin(fragCoord.y)));\n    //background pattern\n    vec4 col = vec4(1.0, 0.5, 1.0, 0.0)/(temp*25.0);\n    \n    vec3 pos, posdy, posdx;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.01, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.01, 5));\n    vec3 eye = vec3(cos(iTime), sin(iTime) + 0.1, 60.0*cos(iTime)-100.0);\n\n    if(testScenePos(eye, dir, pos) && (testScenePos(eye, dirdx, posdx)) && (testScenePos(eye, dirdy, posdy)))\n    {\n        //find vector direction slightly downward on surface\n            vec3 CA = normalize(posdy - pos);\n            \n            //find vector direction slightly to the right on the surface\n            vec3 BA = normalize(posdx - pos);\n            \n            vec3 normal = cross(CA, BA);\n            \n            //a fixed light from the direction of the camera\n            vec3 lightDir = vec3(cos(iTime), 1.0, sin(iTime));\n            //abs(sin(0.5*iTime+1.0))+0.25);\n            \n           // vec3 lightDir = normalize(vec3(-(iMouse.xy/iResolution.xy- vec2(1.0)),1.0));\n            \n            col = vec4(0.90, 0.70, 0.45, 0.0)*dot(-lightDir,normal);\n    }\n    \n    //noise pattern\n    col *= vec4(cos(texture(iChannel0, uv +0.5*iTime)).rgb, 1.0);\n    // Output to screen\n    fragColor = vec4(col);\n    \n}\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}