{"ver":"0.1","info":{"id":"3lSBWh","date":"1598771971","viewed":165,"name":"Fast Marching #4","username":"dust","description":"Another raymarching optimization shader, now with colors and another change where rays approaching the surface are encouraged to intersect earlier than rays diverging from it.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","spheretracing","rendering","optimization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Switch between standard and optimized marching\n//#define BASELINE_MARCHING\n// Note the generally darker shading (indicating fewer steps)\n// when standard marching is disabled\n// See [Common] to change the testing surface\n\n// Project primary ray direction from the camera plane\nvec3 rDir(vec2 pixPos,\n          vec2 viewSizes)\n{\n    vec3 dir = vec3(pixPos - (viewSizes / 2.0),\n                \tviewSizes.y / tan(1.62 / 2.0));\n    return normalize(dir);\n}\n\n// Quick palette lookup for better step visualization\n#define PALLETIZED_SHADING\n#ifdef PALLETIZED_SHADING\n#define MIN_STEPS 4.0f\nvec4 c(float numSteps)\n{\n    \n    return (numSteps < MIN_STEPS) ? vec4(1.0f, 0.0f, 0.0f, 1.0f) :\n    \t   (numSteps < MIN_STEPS * 2.0f) ? vec4(0.0f, 1.0f, 0.0f, 1.0f) : \n    \t   (numSteps < MIN_STEPS * 3.0f) ? vec4(0.0f, 0.0f, 1.0f, 1.0f) : \n    \t   (numSteps < MIN_STEPS * 4.0f) ? vec4(1.0f, 1.0f, 0.0f, 1.0f) :\n    \t   (numSteps < MIN_STEPS * 5.0f) ? vec4(1.0f, 0.0f, 1.0f, 1.0f) :\n    \t\t\t\t\t   \t   vec4(0.0f, 1.0f, 1.0f, 1.0f);\n}\n#endif\n\n// Small mapping function to bundle transforms with SDF evaluations\n#define SDF_SCALE 2.0f\nfloat map(vec3 p)\n{ return sdf(rotate(p, iTime) / SDF_SCALE) * SDF_SCALE; }\n\n// Four-tap tetrahedral normals from nimitz\n// (https://www.shadertoy.com/view/Xts3WM)\n#define EPS 0.0001f\nvec3 norml(vec3 coord)\n{\n    vec2 e = vec2(-1.0, 1.0) * EPS;\n    return normalize(map(coord + e.yxx) * e.yxx +\n                     map(coord + e.xxy) * e.xxy +\n                     map(coord + e.xyx) * e.xyx +\n                     map(coord + e.yyy) * e.yyy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Generate ray-direction, also cache ray origin\n    vec3 rd = rDir(fragCoord,\n                   iResolution.xy);\n    vec3 ro = vec3(0.0f, 0.0f, -5.0f);\n  \n    // March scene isosurface\n    float eps = EPS;\n    const float maxDist = 16.0f;\n    float t = map(ro);\n    float dt = 0.0f;\n    vec3 rgb = vec3(0.25f, 0.25f, 0.25f);\n    float stepCtr = 0.0f; // Iteration counter for benchmarking\n    #ifdef BASELINE_MARCHING\n    \twhile (max(eps - t, t - maxDist) < 0.0f)\n    \t{\n        \tvec3 p = ro + rd * t;\n        \tdt = map(p);\n    \t\tif (dt < eps)\n       \t\t{\n            \trgb = vec3(stepCtr * dRGB);\n            \tbreak; \n        \t}\n        \telse\n        \t{ t += dt; }\n        \tstepCtr += 1.0f;\n    \t}\n    #else\n    \t// Techniques used:\n    \t// Over-relaxation sphere tracing (Keinert et al.), \n    \t// http://erleuchtet.org/~cupe/permanent/enhanced_sphere_tracing.pdf\n    \t// Dynamic epsilon (linear eps),\n    \t// https://www.shadertoy.com/view/4tXyDH\n    \t// (thanks ollj!)\n    \t// Tracked surface variance (original afaik, similar to gradient optimizations from J.C. Hart)\n    \t// Direct field gradient tracking (possibly related to J.C Hart's gradient optimizations as well, measures\n    \t// the facing ratio of ray directions to the field gradient over several steps and penalizes rays passing\n    \t// towards the gradient direction (i.e. away from scene surfaces))\n    \tfloat fSamples[4] = float[](0.0f,0.0f,0.0f,0.0f);\n    \tfloat ndlSamples[4] = float[](0.0f,0.0f,0.0f,0.0f);\n    \tfloat ndlAverages[4] = float[](0.0f,0.0f,0.0f,0.0f);\n    \tfloat w = 1.0f;\n        while (max(eps - t, t - maxDist) < 0.0f)\n    \t{\n        \tvec3 p = ro + rd * t;\n            float f = map(p);\n    \t\tif (f < eps)\n       \t\t{\n            \trgb = vec3(stepCtr * dRGB);\n            \tbreak; \n        \t}\n        \telse\n        \t{ \n                // Track variance, average gradient\n                // Lots more possibility for research here - feel like the fastest step function will benefit equally from\n                // analysing scalar distances and local gradients at each step\n                int sampleNdx = int(stepCtr) % 4;\n                fSamples[sampleNdx] = f;\n                ndlSamples[sampleNdx] = 1.0f - dot(norml(p), rd);                \n                vec2 s = vec2(fSamples[0] + fSamples[1] +\n                    \t \t  fSamples[2] + fSamples[3],\n                              ndlSamples[0] + ndlSamples[1] +\n                    \t\t  ndlSamples[2] + ndlSamples[3]);\n                vec2 m = s * 0.25;\n                float deltas = 0.0;\n                for (uint i = 0u; i < 4u; i += 1u)\n                {\n                    float d = (fSamples[i] - m.x / m.y) * ndlSamples[i]; // Weigh distance samples by facing ratio (areas with constant facing ratios will be smoother than others)\n                    deltas += d * d;\n                }\n                float vari = min((deltas / 4.0), 1.0f); // Restrict variance to (0...1) (I'd prefer to use something smoother than \n                \t\t\t\t\t\t\t\t\t\t// [min], but it works for now)\n                                \n                // Simulate lower variance for rays passing obliquely to the surface (not really necessary when we're \n                // directly changing variance above, but it improves convergence anyways)\n                vari *= min(m.y * m.y, 1.0f);\n                \n                // Scale change in step-size inversely to variance (smoother areas have larger steps than \n        \t\t// rougher ones)\n                float dw = 1.0 - vari; \n                \n                // Add variance changes into [w] (instead of scaling) to help ensure it never gets above [2.0f] \n       \t\t\t// (the overstepping threshold given by Keinert et al. in their paper)\n                t += f * (w + dw);\n                \n                // Fit [w] to the per-ray distance curve (accounting for gradient)\n                w = mix(1.0f, 2.0f, pow(0.9f, f * m.y * (t / maxDist)));\n                \n                // Rays facing the surface intersect earlier\n                eps *= (1.125f + m.y);\n                \n                // Update average gradient\n                ndlAverages[sampleNdx] = m.y;                \n        \t}\n        \tstepCtr += 1.0f;\n    \t}\n    #endif\n    \n    // Output to screen\n    #ifndef PALLETIZED_SHADING\n    fragColor = vec4(rgb,1.0);\n    #else\n    fragColor = vec4(rgb,1.0) * c(stepCtr) * 2.0f;\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Possible test surfaces\n// Surface + gradient functions assume shapes lying at the origin\n//#define SPHER_SDF\n#define JULIA_SDF\n//#define TORUS_SDF\n\n// Conditional undefines (only one surface available at a time)\n#ifdef SPHER_SDF\n\t#ifdef JULIA_SDF\n\t\t#undef JULIA_SDF\n\t#endif\n\t#ifdef TORUS_SDF\n\t\t#undef TORUS_SDF\n\t#endif\n#endif\n#ifdef JULIA_SDF\n\t#ifdef SPHER_SDF\n\t\t#undef SPHER_SDF\n\t#endif\n\t#ifdef TORUS_SDF\n\t\t#undef TORUS_SDF\n\t#endif\n#endif\n#ifdef TORUS_SDF\n\t#ifdef JULIA_SDF\n\t\t#undef JULIA_SDF\n\t#endif\n\t#ifdef SPHER_SDF\n\t\t#undef SPHER_SDF\n\t#endif\n#endif\n\n// Actual surface to test\n#ifdef SPHER_SDF\n\t#define sdf SPHER\n\t//#define \n#else\n\t#ifdef JULIA_SDF\n\t\t#define sdf JULIA\n\t#else\n\t\t#ifdef TORUS_SDF\n\t\t\t#define sdf TORUS\n\t\t#endif\n\t#endif\n#endif\n\n// Expected baseline steps for different surfaces\n// (un-optimized raymarching)\n#ifdef SPHER_SDF\n\t#define BASE_STEPS 12\n#else\n\t#ifdef JULIA_SDF\n\t\t#define BASE_STEPS 256\n\t#else\n\t\t#ifdef TORUS_SDF\n\t\t\t#define BASE_STEPS 92\n\t\t#endif\n\t#endif\n#endif\n\n// Rotations for different types of geometry\n// Designed to show hidden surface as effectively as possible\n#ifdef SPHER_SDF\n\t#define rotate SPHERE_ROTATE\n#else\n\t#ifdef JULIA_SDF\n\t\t#define rotate JULIA_ROTATE\n\t#else\n\t\t#ifdef TORUS_SDF\n\t\t\t#define rotate TORUS_ROTATE\n\t\t#endif\n\t#endif\n#endif\n\n// Shading deltas for different surfaces\n#define dRGB 0.1f\n/*#ifdef JULIA_SDF\n\t#undef dRGB\n\t#define dRGB 0.01f\n#endif*/\n\n// Computes the inverse of a given quaternion\nvec4 QtnInverse(vec4 qtn)\n{\n    return vec4(qtn.xyz, qtn.w * -1.0);\n}\n\n// Compute the product of two unit quaternions\n// (for three-dimensional rotation)\nvec4 QtnUnitProduct(vec4 qtnA, vec4 qtnB)\n{\n    vec3 vecA = qtnA.w * qtnB.xyz;\n    vec3 vecB = qtnB.w * qtnA.xyz;\n    vec3 orthoVec = cross(qtnA.xyz, qtnB.xyz);\n\n    return vec4(vecA + vecB + orthoVec,\n                 (qtnA.w * qtnB.w) - dot(qtnA.xyz, qtnB.xyz));\n}\n\n// Perform rotation by applying the given quaternion to\n// the given vector\nvec3 QtnRotate(vec3 vec, vec4 qtn)\n{\n    vec4 qv = QtnUnitProduct(qtn, vec4(vec, 0.0));\n    return QtnUnitProduct(qv, QtnInverse(qtn)).xyz;\n}\n\n// Compute rotation for spheres\nvec3 SPHERE_ROTATE(vec3 ro, float t)\n{\n    // Spheres are uniform in every direction + contain no hidden\n    // surfaces\n    return ro;\n}\n\n// Compute rotation for Julia fractals\nvec3 JULIA_ROTATE(vec3 ro, float t)\n{\n\treturn QtnRotate(ro,\n                  \t  vec4(vec3(0.0f, 1.0f, 0.0f) * sin(t), cos(t)));\n}\n\n// Compute rotation for tori\nvec3 TORUS_ROTATE(vec3 ro, float t)\n{\n\treturn QtnRotate(ro,\n                  \t vec4(vec3(1.0f, 0.0f, 0.0f) * sin(t), cos(t)));\n}\n\n// Spherical SDF\nfloat SPHER(vec3 p)\n{ return length(p) - 1.0f; }\n\n// Small quaternion multiplier for Julia fractals\n// Adapted from MacSlow's \"qMult\" function, viewable\n// over here:\n// https://www.shadertoy.com/view/lttSzX\nvec4 QtnProduct(vec4 qtnA, vec4 qtnB)\n{\n    float x = qtnA.x * qtnB.x - dot(qtnA.yzw, qtnB.yzw);\n    vec3 yzw = (qtnA.x * qtnB.yzw) +\n               (qtnB.x * qtnA.yzw) +\n               cross(qtnA.yzw, qtnB.yzw);\n    return vec4(x, yzw);\n}\n\n// Julia SDF\n#define JULIA_C vec4(vec3(-0.46f, 0.5f, 0.4f), 0.0f)\n#define JULIA_BAILOUT 256.0f\n#define JULIA_ITER 8\nfloat JULIA(vec3 p)\n{\n    // Initialise iteration point (z), escape-time derivative (dz),\n    // and Julia constant (c)\n    // Also apply uniform scaling\n    vec4 c = JULIA_C;\n    vec4 z = vec4(p, c.w);\n    vec4 dz = vec4(1.0f, 0.0f, 0.0f, 0.0f);\n\n    // Iterate the fractal\n    int i = 0;\n    float sqrBailout = JULIA_BAILOUT;\n    while (i < JULIA_ITER &&\n           dot(z, z) < sqrBailout)\n    {\n        // Update the Julia differential [dz]\n        dz = 2.0f * QtnProduct(z, dz);\n\n        // Displace the Julia coordinate [z]\n        z = QtnProduct(z, z) + c;\n\n        // Update the iteration count\n        i += 1;\n    }\n\n    // Compute, return distance\n    float r = length(z);\n    return (0.5 * log(r) * r / length(dz));\n}\n\n// Torus SDF\n// SDF from iq,\n// https://iquilezles.org/articles/distfunctions\nfloat TORUS(vec3 p)\n{\n    vec2 t = vec2(1.0, 0.4);\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\n","name":"Common","description":"","type":"common"}]}