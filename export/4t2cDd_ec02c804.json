{"ver":"0.1","info":{"id":"4t2cDd","date":"1510642413","viewed":169,"name":"arrays fulfilled with joy","username":"nabr","description":"experimenting","likes":5,"published":1,"flags":8,"usePreview":0,"tags":["sound","synth","toogoodtobetrue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//nabr\n//License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    \n    float t = iTime;\n    \n    vec2 p =\tvec2(fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    \n    \n    \n    // sun :)\n    \n    float sun = (length(vec2(-0.5,0.5)-p.xy)-.25)/12.;\n\n    // init color and add some transparency (white) at top of the waves\n    \n    vec4 col = vec4(0.051);\n    \n \n    if(floor(t)>21.){\n       \n    // raymarch \n        \n    vec3 ro = vec3(.0, .0, -8.);\n    vec3 rd = normalize( vec3(p, 1.));\n\n    // ---- rotation \n\n    float  s = sin(t), c = cos(t);\n\n\n    mat3 r = mat3(\n        1., 0, 0,\n        0, c, -s,\n        0, s, c\n    ) * mat3(\n        cos(t), 0, sin(t),\n        0, 1, 0,\n        -sin(t), 0, cos(t)\n    );\n\n    \n    // ---- positions \n\n    vec3 a = vec3(0.001, 0.001, 3.5),\n        b = vec3(1.35);\n\n    // ---- cube length (max(abs(x) - y, 1.) )\n\n    for (int i = 0; i < 64; i++) \n        \n    \tro += min(\n        \tmax(length(abs((ro + a) * r) - b) - .9995,\n            \t\t\t\t\t\t\t\t\t\t 0.), -ro.z) * rd;\n\t\n    // ----- shading \n        \n    if( mod(t,3.8)<= 1. )    \n    fragColor.rgb = floor(tan(t*2.-ro.z)/10.) * (vec3(0.1, 0.5, 0.7) * sin(- ro.z * 12.));\n   else fragColor.rgb = vec3(1.) * (.05-ro.z*.25);\n\n}\n      \n    \n    \n    \n    else\n           // some waves && more waves \n    fragColor = mix(col+ceil(fract( ( cos(p.x*2.+t)+(p.x-p.y*4.) )*2. )\n            \t \t\t*ceil( sin(p.x*13.-t)+((p.y-sin(t*3.))+2.+p.y*13. )))+.85\n                    ,vec4(0.,0.,1.,1.)*-(fract(cos(p.y+p.y+t)+sin(p.x-p.y)*12. ) )*2./sun \n                    ,(p.y*.3));\n\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// thx to iq\n// https://www.shadertoy.com/view/XdfXWS\n// https://www.shadertoy.com/view/XsjSzc\n\n\n\nvec2 bell( float time ){\n    // the basic sound when you add a new sound tab \n    \n    float gain = .82;\n    \n    return vec2( gain*sin(6.2831*440.0*time)*exp(-3.0*time) );\n}\n\n\nfloat saw( float x ) { return -1.0 + 2.0*fract(x); }\n\n\nvoid playthat(in float t,out vec2 g){\n    \n    \n    float arr[5]=float[](220.,440.,660.,110.,980.);\n    int at = int(mod(t*13.,5.)/3.);\n    \n    \n    float arr1[5]=float[](720.,140.,160.,760.,180.);\n    int at1 = int(mod(t*2.,5.));\n   \n    // we will add to x later, the idea was to add some recursion\n    \n    float y,x;\n    \n    \n    y += 0.5*fract( t*arr[at]*1.00 )*exp( -0.0010*t );\n    \n    //  this will be played once for few sec, just changed the gain value 0.5\n    \n    if(t>15.&&t<19. ) y = 0.25*fract( t*arr[at]*1.00 )*exp( -0.0010*t );\n    \n    \n    x=saw(y*6.)+(saw(arr1[at1]/2.*3.1*t))*exp( -0.0010*y*t );\n    \n    //@ overwrite\n    if(t>20.) \n        x=saw(y*6.13)+(saw(arr1[at1]/(10.1011+(tan( t*.71)/1100.))*2.*3.1*t))*exp( -0.0010*y*t );\n    \n    // output\n    \n    float gain = .45;\n    \n    \n    g = gain*vec2(/*left right channel mix*/\n        \t\t  dot(x*-1.+y,sin(t*12.) ) ,  y+x )\n        \t\t\t\t\t\t\t  +bell(mod(t,2.) );\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    vec2 m=vec2(0.);\n    \n    float t = time;\n    \n\t\t// its a bit out of sync makes it more interessting\n    \t\n        if (sign(sin(t))> 0. ) playthat(t, m) ; \n    \telse playthat(t+2.2101, m); \n   \n  // overwrite\n    \n  if(t>35.) playthat(t+.2101, m); \n    \n    return m;\n}","name":"Sound","description":"","type":"sound"}]}