{"ver":"0.1","info":{"id":"MXX3Rl","date":"1707823809","viewed":97,"name":"workgrid datagoop","username":"jyn","description":"not optimized, just drawing. click around to pan. press pause then play on iChannel1. :)\na friend said it looked like goop earlier so I have embraced the lava lamp approximation.","likes":2,"published":1,"flags":96,"usePreview":0,"tags":["grid","sdf","audio","visualizer","code","art"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4stGWS","filepath":"https://soundcloud.com/jynell/river-of-light-pt-i","previewfilepath":"https://soundcloud.com/jynell/river-of-light-pt-i","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* workgrid datagoop\n** =================\n** Buffer A creates an SDF.\n** Buffer B renders the scene.\n** This stage does post-processing on buffer B for extra lighting.\n** The audio reactivity is not interesting, but I did make that song.\n*/\n\n#define PI 3.14159\n\nconst int NumSamples = 64;\nconst float Density = 0.85f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    //delta between current pixel and light position\n    vec2 delta = uv - vec2(0.5);\n    \n    //define sampling step\n    delta *= 1.0f / float(NumSamples) * Density;\n    \n    //initial color\n    vec3 color = texture(iChannel0, uv).rgb;\n    \n    float illuminationDecay = 0.99f;\n    \n    float audio1 = texture(iChannel0, vec2(0.0, 0.2)).x;\n    float audio2 = texture(iChannel0, vec2(0.0, 0.8)).x;\n    float time = iTime + audio2 * 0.5;\n    float audio3 = abs(sin(time * 2.0)) * 0.5 + 1.0;\n    float sm = smoothstep(audio1 + audio2, 1.0, audio3) * 1.0;\n\n    // postprocessing stage based on simpler god rays\n    // https://www.shadertoy.com/view/ss3fW7\n    vec3 glow = vec3(0.0);\n    float weight = 0.002 * sm + 0.01;\n    for(int i = 0; i < NumSamples; i++)\n    {\n        //peform sampling step\n        uv -= delta;\n        \n        //decay the ray\n        vec3 color_sample = texture(\n          iChannel0,\n          uv + 0.2 * vec2(\n            sin(time + audio2) * 0.2,\n            cos(-time + audio1 * 0.5) * sm)).rgb;\n        \n        color_sample *= illuminationDecay * weight;\n        \n        // accumulate ray sample\n        glow += color_sample;\n    }\n    float accum = texture(iChannel2, fragCoord / iResolution.xy).r;\n    float subjects = smoothstep(0.7, 0.8, smoothstep(0.7, 1.0, accum));\n    color += glow\n      * (1.0 - 0.3 * accum)\n      + smoothstep(0.4, 1.0, accum) * glow\n      - smoothstep(0.9, 1.0, accum) * glow;\n\n    // Output to screen\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Creates distance field of the bubbles.\n\n#define NUM_BUBBLES 7\n\nfloat sdfCircle(vec2 p, vec2 o, float r)\n{\n    // made oblongish\n\treturn distance(\n      o * vec2(1.1 + abs(sin(iTime * 0.6)) * 0., 1.0),\n      p * vec2(0.9 + abs(sin(iTime * 0.8)) * 0.4, 1.1)) - r;\n}\n\n//from iq : https://iquilezles.org/articles/distfunctions\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    float time = iTime * 0.2;\n    float zoomrate = sin(time) * 0.5 + 1.0;\n    zoomrate *= 2.0;\n    //zoomrate = 1.0;\n    vec2 grid_uv = uv * zoomrate;\n    float rot_a = time * 0.25;\n    grid_uv = rotate(grid_uv, rot_a);\n    grid_uv -= rotate(vec2(zoomrate, zoomrate * 0.5), rot_a);\n    grid_uv += rotate(m + vec2(-0.25, -0.5), rot_a);\n    \n    float accum = 1.0;\n    vec2[NUM_BUBBLES] bubbles_xy;\n    for( int i = 0; i < NUM_BUBBLES; i++ ) {\n        float x = sin(time * 4.0 - m.x + float(i)) * 2.0;\n        float y = cos(time - m.y + (float(i)/4.) + sin(time * 8.0));\n        bubbles_xy[i] = vec2(x, y);\n        for ( int j = i - 1; j < NUM_BUBBLES; j++ ) {\n            // partial magnetism or something\n            bubbles_xy[i] += bubbles_xy[j % NUM_BUBBLES].yx * 0.1;\n        }\n        float s = sdfCircle(\n            grid_uv * 3.0,\n            bubbles_xy[i] * 1.0,\n            (x + sin(y) * 2.0) * 0.1\n        );\n        accum = opSmoothUnion(s, accum, abs(sin(time))*2.0) * 1.3;\n    }\n    \n    // Output to screen\n    fragColor = vec4(vec3(accum), 1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Creates the shaded image, referencing the SDF made in A.\n\n#define NUM_BUBBLES 7\n\n// pristine grid\n// https://www.shadertoy.com/view/mdVfWw\nfloat pristineGrid( in vec2 uv, vec2 lineWidth)\n{\n    vec2 ddx = dFdx(uv);\n    vec2 ddy = dFdy(uv);\n    vec2 uvDeriv = vec2(length(vec2(ddx.x, ddy.x)), length(vec2(ddx.y, ddy.y)));\n    bvec2 invertLine = bvec2(lineWidth.x > 0.5, lineWidth.y > 0.5);\n    vec2 targetWidth = vec2(\n      invertLine.x ? 1.0 - lineWidth.x : lineWidth.x,\n      invertLine.y ? 1.0 - lineWidth.y : lineWidth.y\n      );\n    vec2 drawWidth = clamp(targetWidth, uvDeriv, vec2(0.5));\n    vec2 lineAA = uvDeriv * 1.5;\n    vec2 gridUV = abs(fract(uv) * 2.0 - 1.0);\n    gridUV.x = invertLine.x ? gridUV.x : 1.0 - gridUV.x;\n    gridUV.y = invertLine.y ? gridUV.y : 1.0 - gridUV.y;\n    vec2 grid2 = smoothstep(drawWidth + lineAA, drawWidth - lineAA, gridUV);\n\n    grid2 *= clamp(targetWidth / drawWidth, 0.0, 1.0);\n    grid2 = mix(grid2, targetWidth, clamp(uvDeriv * 2.0 - 1.0, 0.0, 1.0));\n    grid2.x = invertLine.x ? 1.0 - grid2.x : grid2.x;\n    grid2.y = invertLine.y ? 1.0 - grid2.y : grid2.y;\n    \n    return mix(grid2.x, 1.0, grid2.y);\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\n// https://www.shadertoy.com/view/4lfSWl\nconst float e = 2.7182818284590452353602874713527;\nvec4 noise(vec2 texCoord)\n{\n    float G = e + (iTime * 0.1);\n    vec2 r = (G * sin(G * texCoord.xy));\n    return vec4(fract(r.x * r.y * (1.0 + texCoord.x)));\n}\n\n\n// get random value\nfloat rand(vec2 co) { \n    return fract(sin(dot(co.xy , vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.y;\n    vec2 uv = fragCoord / iResolution.xy;\n    float time = iTime * 0.2;\n    float zoomrate = sin(time) * 0.5 + 1.0;\n    zoomrate *= 2.0;\n    //zoomrate = 1.0;\n    vec2 grid_uv = uv * zoomrate;\n    float rot_a = time * 0.25;\n    grid_uv = rotate(grid_uv, rot_a);\n    grid_uv -= rotate(vec2(zoomrate, zoomrate * 0.5), rot_a);\n    grid_uv += rotate(m + vec2(-0.25, -0.5), rot_a);\n    \n    float grid1 = pristineGrid(grid_uv * 4., vec2(0.01));\n    float grid2 = pristineGrid(grid_uv / 1., vec2(0.005));\n    float grid = grid1 + grid2;\n    float dot_c = 4.0;\n    vec2 dot_uv = grid_uv + vec2(0.05);\n    float dotted = max(0.2, min(0.8, fract(dot_uv.x * dot_c) + fract(dot_uv.y * dot_c)));\n    dotted = smoothstep(0.5, 0.6, dotted);\n    grid *= dotted;\n    \n    float vignette = 0.5;\n    vignette *= 0.8 - distance(uv, m) * 0.25;\n    vignette = clamp(pow(vignette, 0.4), 0.0, 1.0);\n    vec3 background = vec3(vignette) * vec3(0.1, 0.2, 0.3);\n    vec3 grid_color = vec3(0.9, 1.0, 1.0);\n    vec3 color = mix(background, grid_color, grid * pow(vignette, 4.0) * 4.0);\n    \n    /*float accum = 1.0;\n    vec2[NUM_BUBBLES] bubbles_xy;\n    for( int i = 0; i < NUM_BUBBLES; i++ ) {\n        float x = sin(time * 4.0 - m.x + float(i)) * 2.0;\n        float y = cos(time - m.y + (float(i)/4.) + sin(time * 8.0));\n        bubbles_xy[i] = vec2(x, y);\n        for ( int j = i - 1; j < NUM_BUBBLES; j++ ) {\n            // partial magnetism or something\n            bubbles_xy[i] += bubbles_xy[j % NUM_BUBBLES].yx * 0.1;\n        }\n        float s = sdfCircle(\n            grid_uv * 3.0,\n            bubbles_xy[i] * 1.0,\n            (x + sin(y) * 2.0) * 0.1\n        );\n        accum = opSmoothUnion(s, accum, abs(sin(time))*2.0) * 1.3;\n    }\n    float subjects = smoothstep(0.7, 0.8, smoothstep(0.7, 1.0, accum));*/\n    float accum = texture(iChannel1, uv).r;\n    float subjects = smoothstep(0.7, 0.8, smoothstep(0.7, 1.0, accum));\n    \n    vec2 ruv = uv * 8.0 * zoomrate;\n    vec2 id = ceil(ruv);\n    ruv.y += time * (rand(vec2(id.x)) * 0.6);\n    ruv.y += ceil( mod( id.x, 8.0 * zoomrate ) ) * 1.0 * time;\n    ruv *= ceil((fract(uv.x + rand(uv)) / iChannelResolution[0].x)) / 5.0;\n    \n    float n = noise(grid_uv * (1.0 - zoomrate) * 0.5).r;\n    //ruv = ruv * ( floor((ruv * iChannelResolution[0].x) / 140.0) / iChannelResolution[0].x );\n    vec2 tuv = vec2(\n        fract((round((ruv.x * iChannelResolution[0].x / 6.0)) * 8.0) / iChannelResolution[0].x),\n        fract((round((ruv.y * iChannelResolution[0].y / 8.0)) * 8.0) / iChannelResolution[0].y)\n    );\n    tuv *= pow(accum * 0.6, 0.4);\n    vec3 text = texture(iChannel0, tuv + 0.1 * vec2(-time, time * 0.1)).rgb;\n    \n    text *= noise(vec2(fract(uv.x * 2.0), fract(uv.y * 8.0))).rgb;\n    subjects -= text.r;\n    \n    vec3 bc_inner = (smoothstep(0.8, .8001, subjects) * vec3(0.2, 0.4, 0.3)) * 0.2 - 0.4;\n    vec3 bc_variance = vec3(\n        clamp(0.1 + abs(cos(time)) * 0.2, 0.0, 1.0),\n        clamp(0.2 + abs(sin(time)) * 0.8, 0.0, 1.0),\n        clamp(0.1 + abs(sin(time)) * 0.2, 0.0, 1.0)\n    );\n    vec3 bubbles_color =\n      mix(\n          vec3(0.0, 0.3, 0.0), vec3(0.0, 0.0, 0.2),\n          smoothstep(0.9, 1.3, accum) - smoothstep(0.6, 1.8, accum)\n          + smoothstep(0.4, 0.8, 1.0 - accum) * abs(cos(time)) * 0.3\n      )\n      * bc_variance\n      - bc_inner;\n    color = mix(color, bubbles_color, 1.0 - subjects);\n    //color = vec3(tuv.x, tuv.y, 0.0) * 1.0;\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer B","description":"","type":"buffer"}]}