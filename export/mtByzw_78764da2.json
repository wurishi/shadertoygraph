{"ver":"0.1","info":{"id":"mtByzw","date":"1691582463","viewed":71,"name":"bezier arc length computation","username":"Przemog","description":"asdf","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// based on https://www.shadertoy.com/view/lsyfWc\n\nvec2 udBezier(in vec2 p0, in vec2 p1, in vec2 p2, in vec2 pos)\n{    \n    // p(t)    = (1-t)^2*p0 + 2(1-t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0-2*p1+p2) + 2*(p1-p0)\n    // p'(0)   = 2(p1-p0)\n    // p'(1)   = 2(p2-p1)\n    // p'(1/2) = 2(p2-p0)\n    vec2 a = p1 - p0;\n    vec2 b = p0 - 2.0*p1 + p2;\n    vec2 c = p0 - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(c,b)) / 3.0;\n    float kz = kk * dot(c,a);      \n\n    vec2 res;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = c + (2.0*a + b*t)*t;\n        res = vec2( length(qos),t);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = c + (2.0*a + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = vec2(dis,t.x);\n\n        qos = c + (2.0*a + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.y );\n\n        qos = c + (2.0*a + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        if( dis<res.x ) res = vec2(dis,t.z );\n\n        res.x = sqrt( res.x );\n    }\n    \n    return res;\n}\n\nvec2 getPosAtBezierCurve(in float t, in vec2 p0, in vec2 p1, in vec2 p2)\n{\n    float oneMinusT = 1.0-t;\n\treturn oneMinusT*oneMinusT*p0 + 2.0*t*oneMinusT*p1 + t*t*p2; \n}\n\nfloat calcArcLength_Numeric(in float tA, in vec2 p0, in vec2 p1, in vec2 p2)\n{\n    const float stp = 0.00001;\n    \n    float len = 0.0;\n    for(float t = 0.0; t < tA; t += stp)\n    {\n        vec2 dl = getPosAtBezierCurve(t + stp, p0, p1, p2) - getPosAtBezierCurve(t, p0, p1, p2);\n        len += length(dl);\n    }\n    \n    return len;\n}\n\nfloat calcArcLength_Analytic(in float t, in vec2 p0, in vec2 p1, in vec2 p2)\n{\n    vec2 A = p0 - 2.0*p1 + p2;\n    vec2 B = 2.0*(p1 - p0);\n    vec2 C = p0;\n    float lenA2 = dot(A,A);\n    float AdotB = dot(A,B);\n        \n    float a = 4.0 * lenA2;\n    float b = 4.0 * AdotB;\n    float c = dot(B,B);\n    \n    float b_over_4a = AdotB/a;\n    \n    float lenTan = sqrt(t*(a*t+b)+c);\n    float retval = 0.5f*t*lenTan;\n    // we skip this because when |a| -> we have += 0/0 * 0 here resulting in NaN\n    if (lenA2>=exp2(-23.f))\n        retval += b_over_4a*(lenTan-sqrt(c));\n    \n    // sin2 multiplied by length of A and B\n    float det_over_16 = AdotB*AdotB-lenA2*c;\n    // because `b` is linearly dependent on `a` this will also ensure `b_over_4a` is not NaN, ergo `a` has a minimum value\n    if (det_over_16>=exp2(-23.f))\n    {\n    // TODO: finish by @Przemog\n        //retval += det_over_16*...;\n    }\n    return retval;\n}\n\nfloat getParameterTFromArcLen(in float arcLen, in float accuracyThreshold, in vec2 p0, in vec2 p1, in vec2 p2, in float hint)\n{\n            // for now first root guess (x0) is 0.9, in this implementation rootGuess should be a function parameter of fixed value?\n    float xn = hint;\n\n    if (arcLen <= accuracyThreshold)\n        return arcLen;\n    \n    vec2 B = 2.0*(p1 - p0);\n    vec2 twoA = 2.0*(p2 - p1) - B;\n    \n    const int iterationThreshold = 32;\n    for(int n = 0; n < iterationThreshold; n++)\n    {\n        float arcLenDiffAtParamGuess = arcLen - calcArcLength_Analytic(xn, p0, p1, p2);\n        \n        if (abs(arcLenDiffAtParamGuess) < accuracyThreshold)\n            return xn;\n        \n        float differentialAtGuess = length(twoA * xn + B);\n            // x_n+1 = x_n - f(x_n)/f'(x_n)\n        xn -= (calcArcLength_Analytic(xn, p0, p1, p2) - arcLen) / differentialAtGuess;\n    }\n    \n    return xn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //--------\n    // animate\n    //--------\n    float time = iTime*0.5 + 20.0;\n    vec2 p0 = 0.8*sin( time*0.7 + vec2(3.0,1.0) );\n    vec2 p1 = 0.8*sin( time*1.1 + vec2(0.0,6.0) );\n    vec2 p2 = 0.8*sin( time*1.3 + vec2(4.0,2.0) );\n    \n    //------------------------\n    // calculate bezier curve\n    //------------------------\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    vec2 udBezierOutput = udBezier(p0, p1, p2, p);\n    float be = udBezierOutput.x;\n    float closestT = udBezierOutput.y;\n    \n    //--------\n    // render\n    //--------\n\n    // background\n    vec3 col = vec3(0.15);\n    col += 0.03*sin(be*150.0);\n    col *= 1.0 - 0.3*length(p);\n\n    // bezier\n        //numeric aproach\n    float bezierCurveLength_Numeric = calcArcLength_Numeric(1.0, p0, p1, p2);\n    float resultColor_Numeric = calcArcLength_Numeric(closestT, p0, p1, p2) / bezierCurveLength_Numeric;\n        //analytic aproach\n    float bezierCurveLength = calcArcLength_Analytic(1.0, p0, p1, p2);\n    float arcLength = calcArcLength_Analytic(closestT, p0, p1, p2);\n    float resultColor = arcLength / bezierCurveLength;\n    \n    float d = be;\n        // color bezier curve based on its arc length for t\n    //col = mix( col, vec3(0.0, resultColor, 0.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n    \n        // color bezier curve based on difference between numerical and analytical result (red = bad)\n    //float diffColor = abs(resultColor_Numeric - resultColor) * 1000.0;\n    //col = mix( col, vec3(diffColor, 0.0, 0.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n    \n        // color bezier curve based on parameter t\n    col = mix( col, vec3(0.0, getParameterTFromArcLen(arcLength, 0.0001, p0, p1, p2, resultColor), 0.0), 1.0-smoothstep(0.003,0.003+px*1.5,d) );\n         \n    // control points\n    d = length(p0-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p1-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    d = length(p2-p); col = mix( col, vec3(1.0), 1.0-smoothstep(0.04,0.04+px,d) );\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}