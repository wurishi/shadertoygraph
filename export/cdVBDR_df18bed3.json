{"ver":"0.1","info":{"id":"cdVBDR","date":"1698128055","viewed":37,"name":"a stationary mandelbulb","username":"staircasehall","description":"a mandelbulb, but currently still stationary","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MaximumRaySteps 250\n#define MaximumDistance 200.\n#define MinimumDistance .0001\n#define PI 3.141592653589793238\nvec3 R (vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize (l - p),\n    r = normalize (cross (vec3 (0, 1, 0), f)),\n    u = cross (f, r),\n    c = p + f * z,\n    i = c + uv.x * r + uv.y * u,\n    d = normalize (i - p);\n  return d;\n}\n\nvec3 hsv2rgb (vec3 c) {\n  vec4 K = vec4 (1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs (fract (c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix (K.xxx, clamp (p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n\nfloat map (float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n// TRANSFORM FUNCTIONS //\nfloat mandelbulb (vec3 position) {\n  vec3 z = position;\n  float dr = 1.0;\n  float r = 0.0;\n  int iterations = 0;\n  float power = 8.0 + (5.0 * map (sin ( PI / 10.0 + PI), -1.0, 1.0, 0.0, 1.0));\n\n  for (int i = 0; i < 10; i++) {\n    iterations = i;\n    r = length (z);\n\n    if (r > 2.0) {\n      break;\n    }\n\n    // convert to polar coordinates\n    float theta = acos (z.z / r);\n    float phi = atan (z.y, z.x);\n    dr = pow (r, power - 1.0) * power * dr + 1.0;\n\n    // scale and rotate the point\n    float zr = pow (r, power);\n    theta = theta * power;\n    phi = phi * power;\n\n    // convert back to cartesian coordinates\n    z = zr * vec3 (sin (theta) * cos (phi), sin (phi) * sin (theta), cos (theta));\n    z += position;\n  }\n  float dst = 0.5 * log (r) * r / dr;\n  return dst;\n}\nmat2 Rotate (float angle) {\n  float s = sin (angle);\n  float c = cos (angle);\n\n  return mat2 (c, -s, s, c);\n}\n\n// Calculates de distance from a position p to the scene\nfloat DistanceEstimator (vec3 p) {\n  p.yz *= Rotate (-0.3 * PI);\n  float mandelbulb = mandelbulb (p);\n  return mandelbulb;\n}\n\n// Marches the ray in the scene\nvec4 RayMarcher (vec3 ro, vec3 rd) {\n  float steps = 0.0;\n  float totalDistance = 0.0;\n  float minDistToScene = 100.0;\n  vec3 minDistToScenePos = ro;\n  float minDistToOrigin = 100.0;\n  vec3 minDistToOriginPos = ro;\n  vec4 col = vec4 (0.0, 0.0, 0.0, 1.0);\n  vec3 curPos = ro;\n  bool hit = false;\n\n  for (steps = 0.0; steps < float (MaximumRaySteps); steps++) {\n    vec3 p = ro + totalDistance * rd; // Current position of the ray\n    float distance = DistanceEstimator (p); // Distance from the current position to the scene\n    curPos = ro + rd * totalDistance;\n    if (minDistToScene > distance) {\n      minDistToScene = distance;\n      minDistToScenePos = curPos;\n    }\n    if (minDistToOrigin > length (curPos)) {\n      minDistToOrigin = length (curPos);\n      minDistToOriginPos = curPos;\n    }\n    totalDistance += distance; // Increases the total distance armched\n    if (distance < MinimumDistance) {\n      hit = true;\n      break; // If the ray marched more than the max steps or the max distance, breake out\n    }\n    else if (distance > MaximumDistance) {\n      break;\n    }\n  }\n\n  float iterations = float (steps) + log (log (MaximumDistance)) / log (2.0) - log (log (dot (curPos, curPos))) / log (2.0);\n\n  if (hit) {\n    col.rgb = vec3 (0.8 + (length (curPos) / 0.5), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n  }\n  else {\n    col.rgb = vec3 (0.8 + (length (minDistToScenePos) / 0.5), 1.0, 0.8);\n    col.rgb = hsv2rgb (col.rgb);\n    col.rgb *= 1.0 / (minDistToScene * minDistToScene);\n    col.rgb /= map (sin (3.0), -1.0, 1.0, 3000.0, 50000.0);\n  }\n\n  col.rgb /= steps * 0.08; // Ambeint occlusion\n  col.rgb /= pow (distance (ro, minDistToScenePos), 2.0);\n  col.rgb *= 3.0;\n\n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0); // Transform from [0,1] to [-1,1]\n    uv.x *= iResolution.x / iResolution.y; // Correct for aspect ratio\n\n    // ... [Rest of the functions]\n\n    #define MaximumRaySteps 250\n    #define MaximumDistance 200.\n    #define MinimumDistance .0001\n    #define PI 3.141592653589793238\n\n    // ... [Rest of the code unchanged from your original shader, just remove the functions main() and the outputs]\n\n    vec3 ro = vec3(0, 0, -2.0); // Ray origin\n    vec3 rd = R(uv, ro, vec3(0, 0, 1), 1.); // Ray direction (could be adapted based on mouse or other inputs)\n    vec4 col = RayMarcher(ro, rd);\n\n    fragColor = col;\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}