{"ver":"0.1","info":{"id":"MdtXWj","date":"1461616155","viewed":2979,"name":"Pi Train","username":"mzadami","description":"WARNING! You may not see the correct digits of pi. Your WebGL implementation must support 32-bit ints.\n\nhttps://www.youtube.com/watch?v=QSf4aiTXnk8\n","likes":111,"published":1,"flags":8,"usePreview":1,"tags":["2d","pi","font","train"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ============================================================================================\n// Base-10 digit extraction of Pi using a lovely formula I discovered which\n// has a nice base-10 feel to it!\n//\n// pi/4 = 7/10 + 22/200 - 52/3000 - 312/40000 + 2/5000000 + 2852/6000000 + ...\n//\n// The nth term is given by ImaginaryPart[3(3i+1)^n - (2i-1)^n] / n10^n\n\n// The code represents each part of the imaginary number in the spiral terms\n// using a BIGNUM encoded in a vec4 - i.e. each float uses numbers less than\n// 2^24. This works in C++ with IEEE! But it depends on the vagaries of your\n// GPU and WebGL translation if you see the correct digits of pi. Sorry!\n\n// Thanks to Fabrice for spotting that the 56th digit was wrong. Fixed now!\n\n// Derivation of the formula:\n//\n// Using the logarithmic form of ArcTan(x), find the Taylor series of ArcTan(x) about 1/a\n//\n// ArcTan(x) = ArcTan(1/a) + SumOverN of [Q(n) * a^n * (x-1/a)^n / n(1+a^2)]\n//\n// The 1+a^2 on the bottom is interesting! It suggests values of a of 2, 3 or 7.\n//\n// Q(n) = i * ((-ia - 1)^n - (ia-1)^n)/2\n//\n// Which, for our purposes, we can simplify to just ImaginaryPart[ (ia - 1)^n ]\n//\n// This gives us the final formula.\n//\n// ArcTan(x) - ArcTan(1/a) = 1/n(1+a^2) * (x-1/a)^n * a^n * ImaginaryPart[ (ia - 1)^n ]\n//\n// For judicious choices of x and a we can get useful formulae. For instance:\n//\n// ArcTan(3/4) - ArcTan(1/2) = SumOverN of 1/n10^n * ImaginaryPart[( 2i-1)^n]\n// ArcTan(2/3) - ArcTan(1/3) = SumOverN of 1/n10^n * ImaginaryPart[( 3i-1)^n]\n// ArcTan(0/3) - ArcTan(1/3) = SumOverN of 1/n10^n * ImaginaryPart[(-3i+1)^n]\n//\n// Using the well known ArcTan addition formula\n//\n// ArcTan(3/4) - ArcTan(1/2) =  ArcTan(2/11)\n// ArcTan(2/3) - ArcTan(1/3) =  ArcTan(3/11)\n// ArcTan(0/3) - ArcTan(1/3) = -ArcTan(1/3)\t... this is easy :)\n//\n// Then all we need to get pi is the Machin type formula, pi/4 = 3 ArcTan[1/3] - ArcTan[2/11]\n//\n// QED\n//\n// https://www.wolframalpha.com/input/?i=Sum+for+n+%3D+1+to+100+of+4+Im%5B3(3i%2B1)%5En-(2i-1)%5En%5D%2F(n+10%5En)\n//\n\n// Feeling brave? Try using ivecs for an extra 20 digits. Only works if you\n// have full 32-precision ints... and your WebGL implementation may crash!\n#define USE_INTEGERS 1\n\n#if USE_INTEGERS\n\nconst int POW10_PER_COMPONENT\t= 7;\nconst int BASE_FOR_NUMBER\t\t= 10000000;\nconst int MAX_DIGIT\t\t\t\t= 60;\nconst int MAX_1OVER3_TERMS\t\t= 122;\nconst int MAX_2OVER11_TERMS\t\t= 93;\n\nbool IsZero(ivec4 lo)\n{\n\treturn lo.x == 0 && lo.y == 0 && lo.z == 0 && lo.w == 0;\n}\n\n// Returns +1(a>b), 0, -1(a<b)\nint CompareAbsValues(ivec4 a, ivec4 b)\n{\n\tif (a.w > b.w) {return +1;}\n\tif (a.w < b.w) {return -1;}\n\t\t\n\tif (a.z > b.z) {return +1;}\n\tif (a.z < b.z) {return -1;}\n\n\tif (a.y > b.y) {return +1;}\n\tif (a.y < b.y) {return -1;}\n\n\tif (a.x > b.x) {return +1;}\n\tif (a.x < b.x) {return -1;}\n\n\treturn 0;\n}\n\nvoid DivMod(int a, int b, out int out_div, out int out_mod)\n{\n\tif (a == 0)\n\t{\n\t\tout_div = 0;\n\t\tout_mod = 0;\n\n\t\treturn;\n\t}\n\n\tout_div = a / b;\n\tout_mod = a - out_div * b;\n}\n\nint Mod(int a, int b)\n{\n\tint div = a / b;\n\tint mod = a - b * div;\n\n\treturn mod;\n}\n\nivec4 Div(ivec4 a, int divisor, out int out_mod)\n{\n\tivec4 ans = a;\n\n\tif (ans.w != 0)\n\t{\n\t\tint div_w;\n\t\tint mod_w;\n\n\t\tDivMod(ans.w, divisor, div_w, mod_w);\n\n\t\tans.w  = div_w;\n\t\tans.z += mod_w * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.z != 0)\n\t{\n\t\tint div_z;\n\t\tint mod_z;\n\n\t\tDivMod(ans.z, divisor, div_z, mod_z);\n\n\t\tans.z  = div_z;\n\t\tans.y += mod_z * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.y != 0)\n\t{\n\t\tint div_y;\n\t\tint mod_y;\n\n\t\tDivMod(ans.y, divisor, div_y, mod_y);\n\n\t\tans.y  = div_y;\n\t\tans.x += mod_y * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.x != 0)\n\t{\n\t\tint div_x;\n\t\tint mod_x;\n\n\t\tDivMod(ans.x, divisor, div_x, mod_x);\n\n\t\tans.x = div_x;\n\n\t\tout_mod =  mod_x;\n\t}\n\telse\n\t{\n\t\tout_mod = 0;\n\t}\n\n\treturn ans;\n}\n\nivec4 Double(ivec4 a)\n{\n\tivec4 ans = a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\t}\n\n\treturn ans;\n}\n\nivec4 Treble(ivec4 a)\n{\n\tivec4 ans = a + a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\n\t\tif (ans.x >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.x -= BASE_FOR_NUMBER;\n\t\t\tans.y += 1;\n\t\t}\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\n\t\tif (ans.y >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.y -= BASE_FOR_NUMBER;\n\t\t\tans.z += 1;\n\t\t}\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\n\t\tif (ans.z >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.z -= BASE_FOR_NUMBER;\n\t\t\tans.w += 1;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nivec4 Add(ivec4 a, ivec4 b)\n{\n\tivec4 ans = a + b;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1;\n\t}\n\n\treturn ans;\n}\n\n// a must be > b\nivec4 Sub(ivec4 a, ivec4 b)\n{\n\tivec4 ans = a - b;\n\n\tif (ans.x < 0)\n\t{\n\t\tans.x += BASE_FOR_NUMBER;\n\t\tans.y -= 1;\n\t}\n\n\tif (ans.y < 0)\n\t{\n\t\tans.y += BASE_FOR_NUMBER;\n\t\tans.z -= 1;\n\t}\n\n\tif (ans.z < 0)\n\t{\n\t\tans.z += BASE_FOR_NUMBER;\n\t\tans.w -= 1;\n\t}\n\n\treturn ans;\n}\n\nivec4 Add(ivec4 a, bool aneg, ivec4 b, bool bneg, out bool out_a_plus_b_neg)\n{\n\tif (aneg == bneg)\n\t{\n\t\tout_a_plus_b_neg = aneg;\n\n\t\treturn Add(a,b);\n\t}\n\n\t// Signs are different.\n\tint sign = CompareAbsValues(a,b);\n\n\tif (sign == 0)\n\t{\n\t\tout_a_plus_b_neg = false;\n\n\t\treturn ivec4(0,0,0,0);\n\t}\n\n\tif (sign < 0)\n\t{\n\t\tout_a_plus_b_neg = bneg;\n\t\t\t\n\t\treturn Sub(b,a);\n\t}\n\n\tout_a_plus_b_neg = aneg;\n\n\treturn Sub(a,b);\n}\n\n// Divides by BASE_FOR_NUMBER.\nvoid ApplyShift(out ivec4 a)\n{\n\ta.x = a.y;\n\ta.y = a.z;\n\ta.z = a.w;\n\ta.w = 0;\n}\n\t\n// Return Frac(10^power * Abs(num)/denom)\nfloat GetFractionalPart(ivec4 numerator, int denominator, int power_of_ten)\n{\n\tif (power_of_ten >= 0)\n\t{\n\t\tint m;\n\t\tDiv(numerator, denominator, m);\n\n\t\tconst int MAX_ITERS = MAX_DIGIT / POW10_PER_COMPONENT;\n\n\t\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t\t{\n\t\t\tif (power_of_ten < POW10_PER_COMPONENT)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tm *= BASE_FOR_NUMBER;\n\t\t\tm  = Mod(m, denominator);\n\n\t\t\tpower_of_ten -= POW10_PER_COMPONENT;\n\n\t\t\tif (m == 0)\n\t\t\t{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\n\t\tif (power_of_ten >= 4) {m = Mod(10000 * m, denominator); power_of_ten -= 4;}\n\t\tif (power_of_ten >= 2) {m = Mod(100   * m, denominator); power_of_ten -= 2;}\n\t\tif (power_of_ten >= 1) {m = Mod(10    * m, denominator); power_of_ten -= 1;}\n\t\t\t\n\t\treturn float(m) / float(denominator);\n\t}\n\n\tconst int NUM_POWERS_OF_10_TO_KEEP = 4;\n\n\t// Throw away terms we don't need.\n\tconst int MAX_ITERS = MAX_DIGIT / POW10_PER_COMPONENT;\n\n\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t{\n\t\tif (power_of_ten + POW10_PER_COMPONENT > -NUM_POWERS_OF_10_TO_KEEP)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tApplyShift(numerator);\n\n\t\tif (IsZero(numerator))\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tpower_of_ten += POW10_PER_COMPONENT;\n\t}\n\n\t// Divide by the denominator to get the fractional part in the wrong place...\n\tint the_mod;\n\n\tnumerator = Div(numerator, denominator, the_mod);\n\t\t\n\tfloat ans = float(the_mod) / float(denominator);\n\n\t// We can't divide by more than 100 at a time.\n\tconst int MAX_DIV100_ITERS = (NUM_POWERS_OF_10_TO_KEEP + POW10_PER_COMPONENT) / 2;\n\n\tfor (int iter = 0; iter < MAX_DIV100_ITERS; iter++)\n\t{\n\t\tif (power_of_ten > -2)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tnumerator = Div(numerator, 100, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.01;\n\n\t\tpower_of_ten += 2;\n\t}\n\n\t// And one more if required.\n\tif (power_of_ten == -1)\n\t{\n\t\tnumerator = Div(numerator, 100, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.1;\n\t}\n\n\treturn ans - floor(ans);\n}\n\n// Im((2i - 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral2(int nth_digit)\n{\n\tint\t\tnum_terms\t= 8 + (MAX_2OVER11_TERMS-8) * nth_digit / (MAX_DIGIT-1);\n\tint\t\tshift\t\t= 0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tivec4 re = ivec4(1,0,0,0); bool re_neg = true;\n\tivec4 im = ivec4(2,0,0,0); bool im_neg = false;\n\n\tfor (int term = 1; term < MAX_2OVER11_TERMS; term++)\n\t{\n\t\tint shifted_digit = nth_digit - term + shift;\n\n\t\tfloat f = GetFractionalPart(im, term, shifted_digit);\n        \n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w*3 < 0 ||\n\t\t\tre.w*3 < 0)\n\t\t{\n\t\t\tint mod;\n\n\t\t\tim = Div(im,10,mod);\n\t\t\tre = Div(re,10,mod);\n\n\t\t\tshift += 1;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tivec4 new_re = Add(Double(im), !im_neg, re, !re_neg, new_re_neg);\n\t\tivec4 new_im = Add(Double(re),  re_neg, im, !im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\n// Im((3i + 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral3(int nth_digit)\n{\n\tint\t\tnum_terms\t= 8 + (MAX_1OVER3_TERMS-8) * nth_digit / (MAX_DIGIT-1);\n\tint\t\tshift\t\t= 0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tivec4 re = ivec4(1,0,0,0); bool re_neg = false;\n\tivec4 im = ivec4(3,0,0,0); bool im_neg = false;\n\n\tfor (int term = 1; term < MAX_1OVER3_TERMS; term++)\n\t{\n\t\tint shifted_digit = nth_digit - term + shift;\n\n\t\tfloat f = GetFractionalPart(im, term, shifted_digit);\n\n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w*3 < 0 ||\n\t\t\tre.w*3 < 0)\n\t\t{\n\t\t\tint mod;\n\n\t\t\tim = Div(im,10,mod);\n\t\t\tre = Div(re,10,mod);\n\n\t\t\tshift += 1;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tivec4 new_re = Add(Treble(im), !im_neg, re, re_neg, new_re_neg);\n\t\tivec4 new_im = Add(Treble(re),  re_neg, im, im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\nint GetNthDigitOfPi(int nth_digit)\n{\n\tfloat a = GetNthDigitOfSpiral3(nth_digit);\n\tfloat b = GetNthDigitOfSpiral2(nth_digit);\n\n\tfloat s = 4.0 * (a*3.0-b);\n\n\ts -= floor(s);\n\n\tint digit = int(floor(10.0 * s));\n\n\treturn digit;\n}\n\n#else\n\nconst float\tPOW10_PER_COMPONENT\t= 5.0;\nconst float\tBASE_FOR_NUMBER\t\t= 100000.0;\nconst float\tMAX_DIGIT\t\t\t= 40.0;\nconst float\tMAX_1OVER3_TERMS\t= 80.0;\nconst float\tMAX_2OVER11_TERMS\t= 60.0;\n\nbool IsZero(vec4 a)\n{\n\treturn a.x == 0.0 && a.y == 0.0 && a.z == 0.0 && a.w == 0.0;\n}\n\n// Returns +1(a>b), 0, -1(a<b)\nfloat CompareAbsValues(vec4 a, vec4 b)\n{\n\tif (a.w > b.w) {return +1.0;}\n\tif (a.w < b.w) {return -1.0;}\n\t\t\n\tif (a.z > b.z) {return +1.0;}\n\tif (a.z < b.z) {return -1.0;}\n\n\tif (a.y > b.y) {return +1.0;}\n\tif (a.y < b.y) {return -1.0;}\n\n\tif (a.x > b.x) {return +1.0;}\n\tif (a.x < b.x) {return -1.0;}\n\n\treturn 0.0;\n}\n\nvoid DivMod(float a, float b, out float out_div, out float out_mod)\n{\n\tif (a == 0.0)\n\t{\n\t\tout_div = 0.0;\n\t\tout_mod = 0.0;\n\n\t\treturn;\n\t}\n\t\n\tfloat d = floor(a / b);\n\n\tout_div = d;\n\tout_mod = a - d * b;\n}\n\nfloat Mod(float a, float b)\n{\n\tfloat d\t\t= floor(a / b);\n\tfloat mod\t= a - d * b;\n\n\treturn mod;\n}\n\nvec4 Div(vec4 a, float divisor, out float out_mod)\n{\n\tvec4 ans = a;\n\n\tif (ans.w != 0.0)\n\t{\n\t\tfloat div_w;\n\t\tfloat mod_w;\n\n\t\tDivMod(ans.w, divisor, div_w, mod_w);\n\n\t\tans.w  = div_w;\n\t\tans.z += mod_w * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.z != 0.0)\n\t{\n\t\tfloat div_z;\n\t\tfloat mod_z;\n\n\t\tDivMod(ans.z, divisor, div_z, mod_z);\n\n\t\tans.z  = div_z;\n\t\tans.y += mod_z * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.y != 0.0)\n\t{\n\t\tfloat div_y;\n\t\tfloat mod_y;\n\n\t\tDivMod(ans.y, divisor, div_y, mod_y);\n\n\t\tans.y  = div_y;\n\t\tans.x += mod_y * BASE_FOR_NUMBER;\n\t}\n\n\tif (ans.x != 0.0)\n\t{\n\t\tfloat div_x;\n\t\tfloat mod_x;\n\n\t\tDivMod(ans.x, divisor, div_x, mod_x);\n\n\t\tans.x = div_x;\n\n\t\tout_mod =  mod_x;\n\t}\n\telse\n\t{\n\t\tout_mod = 0.0;\n\t}\n\n\treturn ans;\n}\n\nvec4 Double(vec4 a)\n{\n\tvec4 ans = a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1.0;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1.0;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1.0;\n\t}\n\n\treturn ans;\n}\n\nvec4 Treble(vec4 a)\n{\n\tvec4 ans = a + a + a;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1.0;\n\n\t\tif (ans.x >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.x -= BASE_FOR_NUMBER;\n\t\t\tans.y += 1.0;\n\t\t}\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1.0;\n\n\t\tif (ans.y >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.y -= BASE_FOR_NUMBER;\n\t\t\tans.z += 1.0;\n\t\t}\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1.0;\n\n\t\tif (ans.z >= BASE_FOR_NUMBER)\n\t\t{\n\t\t\tans.z -= BASE_FOR_NUMBER;\n\t\t\tans.w += 1.0;\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nvec4 Add(vec4 a, vec4 b)\n{\n\tvec4 ans = a + b;\n\n\tif (ans.x >= BASE_FOR_NUMBER)\n\t{\n\t\tans.x -= BASE_FOR_NUMBER;\n\t\tans.y += 1.0;\n\t}\n\n\tif (ans.y >= BASE_FOR_NUMBER)\n\t{\n\t\tans.y -= BASE_FOR_NUMBER;\n\t\tans.z += 1.0;\n\t}\n\n\tif (ans.z >= BASE_FOR_NUMBER)\n\t{\n\t\tans.z -= BASE_FOR_NUMBER;\n\t\tans.w += 1.0;\n\t}\n\n\treturn ans;\n}\n\n// a must be > b\nvec4 Sub(vec4 a, vec4 b)\n{\n\tvec4 ans = a - b;\n\n\tif (ans.x < 0.0)\n\t{\n\t\tans.x += BASE_FOR_NUMBER;\n\t\tans.y -= 1.0;\n\t}\n\n\tif (ans.y < 0.0)\n\t{\n\t\tans.y += BASE_FOR_NUMBER;\n\t\tans.z -= 1.0;\n\t}\n\n\tif (ans.z < 0.0)\n\t{\n\t\tans.z += BASE_FOR_NUMBER;\n\t\tans.w -= 1.0;\n\t}\n\n\treturn ans;\n}\n\nvec4 Add(vec4 a, bool aneg, vec4 b, bool bneg, out bool out_a_plus_b_neg)\n{\n\tif (aneg == bneg)\n\t{\n\t\tout_a_plus_b_neg = aneg;\n\n\t\treturn Add(a,b);\n\t}\n\n\t// Signs are different.\n\tfloat sign = CompareAbsValues(a,b);\n\n\tif (sign == 0.0)\n\t{\n\t\tout_a_plus_b_neg = false;\n\n\t\treturn vec4(0.0,0.0,0.0,0.0);\n\t}\n\n\tif (sign < 0.0)\n\t{\n\t\tout_a_plus_b_neg = bneg;\n\t\t\t\n\t\treturn Sub(b,a);\n\t}\n\n\tout_a_plus_b_neg = aneg;\n\n\treturn Sub(a,b);\n}\n\n// Divides by BASE_FOR_NUMBER.\nvoid ApplyShift(out vec4 a)\n{\n\ta.x = a.y;\n\ta.y = a.z;\n\ta.z = a.w;\n\ta.w = 0.0;\n}\n\t\n// Return Frac(10^power * Abs(num)/denom)\nfloat GetFractionalPart(vec4 numerator, float denominator, float power_of_ten)\n{\n\tif (power_of_ten >= 0.0)\n\t{\n\t\tfloat m;\n\t\tDiv(numerator, denominator, m);\n\n\t\tconst int MAX_ITERS = int(MAX_DIGIT / POW10_PER_COMPONENT);\n\n\t\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t\t{\n\t\t\tif (power_of_ten < POW10_PER_COMPONENT)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tm *= BASE_FOR_NUMBER;\n\t\t\tm  = Mod(m, denominator);\n\n\t\t\tpower_of_ten -= POW10_PER_COMPONENT;\n\n\t\t\tif (m == 0.0)\n\t\t\t{\n\t\t\t\treturn 0.0;\n\t\t\t}\n\t\t}\n\n\t\tif (power_of_ten >= 4.0) {m = Mod(10000.0 * m, denominator); power_of_ten -= 4.0;}\n\t\tif (power_of_ten >= 2.0) {m = Mod(100.0   * m, denominator); power_of_ten -= 2.0;}\n\t\tif (power_of_ten >= 1.0) {m = Mod(10.0    * m, denominator); power_of_ten -= 1.0;}\n\t\t\t\n\t\treturn float(m) / float(denominator);\n\t}\n\n\tconst float NUM_POWERS_OF_10_TO_KEEP = 4.0;\n\n\t// Throw away terms we don't need.\n\tconst int MAX_ITERS = int(MAX_DIGIT / POW10_PER_COMPONENT);\n\n\tfor (int iter = 0; iter < MAX_ITERS; iter++)\n\t{\n\t\tif (power_of_ten + POW10_PER_COMPONENT > -NUM_POWERS_OF_10_TO_KEEP)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tApplyShift(numerator);\n\n\t\tif (IsZero(numerator))\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\n\t\tpower_of_ten += POW10_PER_COMPONENT;\n\t}\n\n\t// Divide by the denominator to get the fractional part in the wrong place...\n\tfloat the_mod;\n\n\tnumerator = Div(numerator, denominator, the_mod);\n\t\t\n\tfloat ans = float(the_mod) / float(denominator);\n\n\t// We can't divide by more than 100 at a time.\n\tconst int MAX_DIV100_ITERS = int(NUM_POWERS_OF_10_TO_KEEP + POW10_PER_COMPONENT) / 2;\n\n\tfor (int iter = 0; iter < MAX_DIV100_ITERS; iter++)\n\t{\n\t\tif (power_of_ten > -2.0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tnumerator = Div(numerator, 100.0, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.01;\n\n\t\tpower_of_ten += 2.0;\n\t}\n\n\t// And one more if required.\n\tif (power_of_ten == -1.0)\n\t{\n\t\tnumerator = Div(numerator, 10.0, the_mod);\n\n\t\tans += float(the_mod);\n\t\tans *= 0.1;\n\t}\n\n\treturn ans - floor(ans);\n}\n\n// Im((2i - 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral2(float nth_digit)\n{\n    int\t\tnum_terms\t= int(8.0 + (MAX_2OVER11_TERMS - 8.0) * nth_digit / (MAX_DIGIT-1.0));\n\tfloat\tshift\t\t= 0.0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tvec4 re = vec4(1.0, 0.0, 0.0, 0.0); bool re_neg = true;\n\tvec4 im = vec4(2.0, 0.0, 0.0, 0.0); bool im_neg = false;\n\n\tfor (int term = 1; term < int(MAX_2OVER11_TERMS); term++)\n\t{\n\t\tfloat shifted_digit = nth_digit - float(term) + shift;\n\n\t\tfloat f = GetFractionalPart(im, float(term), shifted_digit);\n        \n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w * 2.0 > BASE_FOR_NUMBER ||\n\t\t\tre.w * 2.0 > BASE_FOR_NUMBER)\n\t\t{\n\t\t\tfloat mod;\n\n\t\t\tim = Div(im,10.0,mod);\n\t\t\tre = Div(re,10.0,mod);\n\n\t\t\tshift += 1.0;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tvec4 new_re = Add(Double(im), !im_neg, re, !re_neg, new_re_neg);\n\t\tvec4 new_im = Add(Double(re),  re_neg, im, !im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\n// Im((3i + 1)^n) / (10^n n)\nfloat GetNthDigitOfSpiral3(float nth_digit)\n{\n\tint\t\tnum_terms\t= int(8.0 + (MAX_1OVER3_TERMS - 8.0) * nth_digit / (MAX_DIGIT-1.0));\n\tfloat\tshift\t\t= 0.0;\n\tfloat\tsum\t\t\t= 0.0;\n\n\tvec4 re = vec4(1.0, 0.0, 0.0, 0.0); bool re_neg = false;\n\tvec4 im = vec4(3.0, 0.0, 0.0, 0.0); bool im_neg = false;\n\n\tfor (int term = 1; term < int(MAX_1OVER3_TERMS); term++)\n\t{\n\t\tfloat shifted_digit = nth_digit - float(term) + shift;\n\n\t\tfloat f = GetFractionalPart(im, float(term), shifted_digit);\n\n\t\tif (im_neg)\n\t\t{\n\t\t\tsum -= f;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum += f;\n\t\t}\n\n\t\tif (im.w * 3.0 > BASE_FOR_NUMBER ||\n\t\t\tre.w * 3.0 > BASE_FOR_NUMBER)\n\t\t{\n\t\t\tfloat mod;\n\n\t\t\tim = Div(im,10.0,mod);\n\t\t\tre = Div(re,10.0,mod);\n\n\t\t\tshift += 1.0;\n\t\t}\n\n\t\tbool new_re_neg;\n\t\tbool new_im_neg;\n\n\t\tvec4 new_re = Add(Treble(im), !im_neg, re, re_neg, new_re_neg);\n\t\tvec4 new_im = Add(Treble(re),  re_neg, im, im_neg, new_im_neg);\n\n\t\tre = new_re; re_neg = new_re_neg;\n\t\tim = new_im; im_neg = new_im_neg;\n\n\t\tif (term == num_terms)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tsum = sum - floor(sum);\n\n\treturn sum;\n}\n\nint GetNthDigitOfPi(float nth_digit)\n{\n\tfloat a = GetNthDigitOfSpiral3(nth_digit);\n\tfloat b = GetNthDigitOfSpiral2(nth_digit);\n\n\tfloat s = 4.0 * (a*3.0-b);\n\n\ts -= floor(s);\n\n\tint digit = int(floor(10.0 * s));\n\n\treturn digit;\n}\n\n\n#endif\n\n\n\n\n// ============================================================================================\n\nbool Is0To1(float x)\n{\n\treturn x >= 0.0 && x < 1.0;\n}\n\nbool Is0To1(vec2 uv)\n{\n\treturn\n\t\tuv.x >= 0.0 && uv.x < 1.0 &&\n\t\tuv.y >= 0.0 && uv.y < 1.0;\n}\n\n// ============================================================================================\n\nfloat GetPositionAlongLineSegmentNearestToPoint(vec2 line_segment_a, vec2 line_segment_b, vec2 point)\n{\n\tvec2 p = point\t\t\t- line_segment_a;\n\tvec2 l = line_segment_b\t- line_segment_a;\n\n\tfloat dprod = dot(p,l);\n\tfloat len2  = dot(l,l);\n\n\treturn clamp(dprod / len2, 0.0, 1.0);\n}\n\nfloat GetPositionAlongLineNearestToPoint(vec2 line_segment_a, vec2 line_segment_b, vec2 point)\n{\n\tvec2 p = point\t\t\t- line_segment_a;\n\tvec2 l = line_segment_b\t- line_segment_a;\n\n\tfloat dprod = dot(p,l);\n\tfloat len2  = dot(l,l);\n\n\treturn dprod / len2;\n}\n\nfloat GetDistSqFromLineSegmentToPoint(vec2 line_segment_a, vec2 line_segment_b, vec2 point)\n{\n\tfloat t = GetPositionAlongLineSegmentNearestToPoint(line_segment_a, line_segment_b, point);\n\n\tvec2 to_nearest = point - mix(line_segment_a, line_segment_b, t);\n\n\treturn dot(to_nearest, to_nearest);\n}\n\nvec3 GetPointOnCubicSpline(vec3 cp0, vec3 cp1, vec3 cp2, vec3 cp3, float t)\n{\n\tfloat p = t;\n\tfloat n = 1.0 - t;\n        \n\tvec3 ans;\n       \n\tans  = cp0 * (n*n*n);\n\tans += cp1 * (n*n*p*3.0);\n\tans += cp2 * (n*p*p*3.0);\n\tans += cp3 * (p*p*p);\n    \n    return ans;\n}\n\nvec2 GetPointOnCubicSpline(vec2 cp0, vec2 cp1, vec2 cp2, vec2 cp3, float t)\n{\n\tfloat p = t;\n\tfloat n = 1.0 - t;\n        \n\tvec2 ans;\n       \n\tans  = cp0 * (n*n*n);\n\tans += cp1 * (n*n*p*3.0);\n\tans += cp2 * (n*p*p*3.0);\n\tans += cp3 * (p*p*p);\n    \n    return ans;\n}\n\nfloat GetNearestPointAlongCubicSpline(vec2 cp0, vec2 cp1, vec2 cp2, vec2 cp3, vec2 uv)\n{\n\tfloat t = GetPositionAlongLineSegmentNearestToPoint(cp0,cp3, uv);\n\n\t// Now refine once.\n\t{\n\t\tfloat t0 = max(0.0, t - 0.1);\n\t\tfloat t1 = min(1.0, t + 0.1);\n\n\t\tvec2 p0 = GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t0);\n\t\tvec2 p1 = GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t1);\n\n\t\tt = clamp(mix(t0,t1,GetPositionAlongLineNearestToPoint(p0,p1, uv)), 0.0, 1.0);\n\t}\n\n\treturn t;\n}\n\n// ============================================================================================\n\nfloat GetColourForLineSegment(vec3 cp0, vec3 cp1, vec2 uv, float pixel_uv_size)\n{\n\tfloat t = GetPositionAlongLineSegmentNearestToPoint(cp0.xy,cp1.xy, uv);\n\n\tvec2\tbest_point\t\t= mix(cp0.xy,cp1.xy,t);\n\tfloat\tbest_thickness\t= mix(cp0.z, cp1.z, t*t);\t// Non-linear for thickness...\n    float\tbest_dist \t\t= length(uv - best_point.xy);\n    float\tbest_surface\t= best_thickness - best_dist;\n    \n    float aa = smoothstep(0.0, pixel_uv_size, best_surface);\n    \n    return aa;\n}\n\nfloat GetColourForCubicSpline(vec3 cp0, vec3 cp1, vec3 cp2, vec3 cp3, vec2 uv, float pixel_uv_size)\n{\n\tfloat\tt\t\t\t\t= GetNearestPointAlongCubicSpline(cp0.xy,cp1.xy,cp2.xy,cp3.xy, uv);\n    vec3\tbest_point\t\t= GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t);\n    float\tbest_dist \t\t= length(uv - best_point.xy);\n    float\tbest_surface\t= best_point.z - best_dist;\n    \n    float aa = smoothstep(0.0, pixel_uv_size, best_surface);\n    \n    return aa;\n}\n\nfloat GetColourForEllispse(vec2 origin, vec2 scale, float thickness, vec2 uv, float pixel_uv_size)\n{\n    vec2 r = (uv - origin) / scale;\n    vec2 n = normalize(r) * scale + origin;\n    \n    // Stylish!\n    thickness *= 1.0+r.x*r.y*0.5;\n    \n    float d = distance(n, uv);\n    float s = thickness - d;\n\n    float aa = smoothstep(0.0, pixel_uv_size, s);\n    \n    return aa;\n}\n\n// ============================================================================================\n// THE FONT\n\n// Control over the aspect ratio.\n#define CHAR_ASPECT 0.75\n#define CHAR_HEIGHT 0.95\n#define AR(x) (((x)-0.5)*CHAR_ASPECT+0.5)\n#define H(y) ((y)*CHAR_HEIGHT)\n\nbool IsDigitUV(vec2 uv)\n{\n\treturn uv.x > AR(0.0) && uv.x < AR(1.0) && uv.y > 0.01 * CHAR_HEIGHT && uv.y < 0.99 * CHAR_HEIGHT;\n}\n\nfloat Char0(vec2 uv, float pixel_uv_size)\n{\n    return GetColourForEllispse(vec2(0.5,0.5*CHAR_HEIGHT),vec2(0.35 * CHAR_ASPECT,0.35),0.09,uv,pixel_uv_size);\n}\n\nfloat Char1(vec2 uv, float pixel_uv_size)\n{\n\tfloat s0 = GetColourForLineSegment(vec3(0.52,0.9*CHAR_HEIGHT,0.09),vec3(0.50,0.15*CHAR_HEIGHT,0.13), uv, pixel_uv_size);\n    float s1 = GetColourForLineSegment(vec3(0.52,0.9*CHAR_HEIGHT,0.09),vec3(0.30,0.75*CHAR_HEIGHT,0.06), uv, pixel_uv_size);\n    \n    return max(s0,s1);   \n}\n\nfloat Char2(vec2 uv, float pixel_uv_size)\n{\n    float s0 = GetColourForCubicSpline(vec3(AR(0.4),H(0.80),0.16), vec3(AR(0.8),H(0.6),0.06), vec3(AR(0.6),H(0.4),0.03), vec3(AR(0.2),H(0.15),0.13), uv, pixel_uv_size);\n    float s1 = GetColourForCubicSpline(vec3(AR(0.2),H(0.15),0.13), vec3(AR(0.4),H(0.3),0.08), vec3(AR(0.6),H(0.2),0.08), vec3(AR(0.8),H(0.20),0.16), uv, pixel_uv_size);\n    \n    return max(s0,s1);\n}\n\nfloat Char3(vec2 uv, float pixel_uv_size)\n{\n\tfloat s0 = GetColourForCubicSpline(vec3(AR(0.5),H(0.6),0.09), vec3(AR(0.7),H(0.7),0.08), vec3(AR(0.6),H(0.9),0.07), vec3(AR(0.4),H(0.87),0.11), uv, pixel_uv_size);\n    float s1 = GetColourForCubicSpline(vec3(AR(0.5),H(0.6),0.09), vec3(AR(1.0),H(0.4),0.05), vec3(AR(0.5),H(0.1),0.06), vec3(AR(0.2),H(0.20),0.16), uv, pixel_uv_size);\n    \n    return max(s0,s1);\n}\n\nfloat Char4(vec2 uv, float pixel_uv_size)\n{\n\tfloat s0 = GetColourForCubicSpline(vec3(AR(0.15),H(0.4),0.11), vec3(AR(0.3),H(0.5),0.06), vec3(AR(0.3),H(0.7),0.06), vec3(AR(0.2),H(0.80),0.11), uv, pixel_uv_size);\n    float s1 = GetColourForCubicSpline(vec3(AR(0.18),H(0.4),0.10), vec3(AR(0.4),H(0.5),0.06), vec3(AR(0.6),H(0.3),0.06), vec3(AR(0.8),H(0.40),0.13), uv, pixel_uv_size);\n    float s2 = GetColourForCubicSpline(vec3(AR(0.60),H(0.6),0.09), vec3(AR(0.5),H(0.4),0.06), vec3(AR(0.6),H(0.3),0.06), vec3(AR(0.5),H(0.15),0.09), uv, pixel_uv_size);\n    \n    return max(s0,max(s1,s2));\n}\n\nfloat Char5(vec2 uv, float pixel_uv_size)\n{\n    float s0 = GetColourForCubicSpline(vec3(AR(0.3),H(0.80),0.10), vec3(AR(0.5),H(0.70),0.07), vec3(AR(0.6),H(0.80),0.07), vec3(AR(0.8),H(0.80),0.11), uv, pixel_uv_size);\n    float s2 = GetColourForCubicSpline(vec3(AR(0.3),H(0.55),0.09), vec3(AR(0.8),H(0.55),0.03), vec3(AR(0.9),H(0.25),0.09), vec3(AR(0.5),H(0.15),0.11), uv, pixel_uv_size);\n    \n    float s1 = GetColourForLineSegment(vec3(AR(0.3),H(0.55),0.09), vec3(AR(0.3),H(0.8),0.10), uv, pixel_uv_size);\n    \n\treturn max(s0,max(s1,s2));\n}\n\nfloat Char6(vec2 uv, float pixel_uv_size)\n{\n\tfloat s0 = GetColourForEllispse(vec2(0.5,0.35*CHAR_HEIGHT),vec2(0.3*CHAR_ASPECT,0.25*CHAR_HEIGHT),0.08,uv,pixel_uv_size);\n    float s1 = GetColourForCubicSpline(vec3(AR(0.2),H(0.23),0.08), vec3(AR(0.1),H(0.6),0.09), vec3(AR(0.2),H(0.9),0.02), vec3(AR(0.6),H(0.85),0.13), uv, pixel_uv_size);\n\n    return max(s0,s1);\n}\n\nfloat Char7(vec2 uv, float pixel_uv_size)\n{\n    float s0 = GetColourForCubicSpline(vec3(AR(0.2),H(0.8),0.11), vec3(AR(0.4),H(0.7),0.06), vec3(AR(0.6),H(0.8),0.06), vec3(AR(0.8),H(0.8),0.13), uv, pixel_uv_size);\n    float s1 = GetColourForCubicSpline(vec3(AR(0.8),H(0.8),0.13), vec3(AR(0.5),H(0.6),0.02), vec3(AR(0.4),H(0.4),0.06), vec3(AR(0.5),H(0.2),0.16), uv, pixel_uv_size);\n    \n    return max(s0,s1);\n}\n\nfloat Char8(vec2 uv, float pixel_uv_size)\n{\n\tfloat s0 = GetColourForEllispse(vec2(0.5,0.35*CHAR_HEIGHT),vec2(0.3 * CHAR_ASPECT,0.25*CHAR_HEIGHT),0.08,uv,pixel_uv_size);\n\tfloat s1 = GetColourForEllispse(vec2(0.5,0.76*CHAR_HEIGHT),vec2(0.2 * CHAR_ASPECT,0.14*CHAR_HEIGHT),0.07,uv,pixel_uv_size);\n    \n    return max(s0,s1);\n}\n\nfloat Char9(vec2 uv, float pixel_uv_size)\n{\n\treturn Char6(vec2(1.0-uv.x, CHAR_HEIGHT-uv.y),pixel_uv_size);\n}\n\n#undef AR\n#undef H\n\n\nfloat CharDot(vec2 uv, float pixel_uv_size)\n{\n    float thickness = 0.1;\n    \n    float d = distance(uv, vec2(0.8,0.2));\n    float s = thickness - d;\n\n    float aa = smoothstep(0.0, pixel_uv_size, s);\n    \n    return aa;\n}\n\nfloat CharPi(vec2 uv, float pixel_uv_size)\n{\n    float s0 = GetColourForCubicSpline(vec3(0.20,0.85,0.13), vec3(0.4,0.8,0.10), vec3(0.70,0.8,0.075), vec3(0.8,0.9,0.09), uv, pixel_uv_size);\n    float s1 = GetColourForCubicSpline(vec3(0.35,0.80,0.10), vec3(0.4,0.6,0.08), vec3(0.40,0.3,0.010), vec3(0.2,0.2,0.08), uv, pixel_uv_size);\n    float s2 = GetColourForCubicSpline(vec3(0.70,0.80,0.08), vec3(0.7,0.7,0.08), vec3(0.73,0.4,0.050), vec3(0.9,0.2,0.04), uv, pixel_uv_size);\n    \n    return (min(s0+s1+s2,1.0) + max(s0,max(s1,s2))) * 0.5;\n}\n\nfloat CharDigit(int digit, vec2 uv, float pixel_uv_size)\n{\n\tif (digit < 5)\n\t{\n\t\tif (digit == 0) {return Char0(uv,pixel_uv_size);}\n\t\tif (digit == 1) {return Char1(uv,pixel_uv_size);}\n\t\tif (digit == 2) {return Char2(uv,pixel_uv_size);}\n\t\tif (digit == 3) {return Char3(uv,pixel_uv_size);}\n\t\t\n\t\treturn Char4(uv,pixel_uv_size);\n\t}\n\telse\n\t{\n\t\tif (digit == 5) {return Char5(uv,pixel_uv_size);}\n\t\tif (digit == 6) {return Char6(uv,pixel_uv_size);}\n\t\tif (digit == 7) {return Char7(uv,pixel_uv_size);}\n\t\tif (digit == 8) {return Char8(uv,pixel_uv_size);}\n\t\t\n\t\treturn Char9(uv,pixel_uv_size);\n\t}\n}\n\n// ============================================================================================\n// GRAPHICS PRIMS\n\nvec2 ApplyWarp(vec2 uv, float seed)\n{\n\tuv += cos(4.0 * uv.x - seed*67.0) * vec2(0.007, 0.009);\n\tuv += sin(5.0 * uv.y - seed*89.0) * vec2(0.009,-0.008);\n\n\treturn uv;\n}\n\nvec2 ApplyBulge(vec2 uv)\n{\n    //return uv - normalize(uv - vec2(0,5)) * smoothstep(3.0, 12.0, distance(uv, vec2(0,7))) + sin( cos(uv.x * uv.x * 0.05) + iTime) * 0.04;\n    return uv + normalize(uv - vec2(0,20.0)) * 2.0 + sin( cos(uv.x * uv.x * 0.06) + iTime) * 0.05;\n}\n\n// box_dx/dy normalised please. Returns colour/alpha.\nvec2 Box(vec2 box_origin, vec2 box_dx, vec2 box_dy, vec2 box_dims, float thickness, float roundness, vec2 uv, float pixel_uv_size)\n{\n\tvec2 r = uv - box_origin;\n\n\t{\n\t\tfloat x = dot(r, box_dx);\n\t\tfloat y = dot(r, box_dy);\n\n\t\tr = ApplyWarp(vec2(x,y), 1.2);\n\t}\n\n\tvec2 r_in_box = clamp(r, vec2(0.0,0.0), box_dims);\n\n\tfloat dist_from_box = distance(r, r_in_box);\n\tfloat surface\t\t= dist_from_box - thickness;\n\n\tfloat\tcolour\t= smoothstep(pixel_uv_size, 0.0, surface);\n\tfloat\talpha\t= colour;\n    \n    if (r == r_in_box)\n    {\n\t\tvec2 box_half_size\t= box_dims * 0.5;\n\t\tvec2 from_mid\t\t= r - box_half_size;\n\t\tvec2 to_corner\t\t= sign(from_mid);\n\t\tvec2 nearest_corner = box_half_size + to_corner * box_half_size;\n\t\tvec2 corner_sphere\t= nearest_corner - to_corner * roundness;\n\t\tvec2 to_edge\t\t= abs(box_half_size) - abs(from_mid);\n\n\t\tfloat dist_from_edge = min(to_edge.x, to_edge.y);\n\n\t\tcolour = smoothstep(pixel_uv_size, 0.0, dist_from_edge);\n\n\t\tif (sign(r - corner_sphere) == to_corner)\n\t\t{\n\t\t\tfloat dist_from_corner = roundness - distance(corner_sphere, r);\n\n\t\t\tcolour = max(colour, smoothstep(pixel_uv_size, 0.0, dist_from_corner));\n\t\t}\n    }\n\n\treturn vec2(colour, alpha);\n}\n\nvec2 Circle(vec2 circle_origin, float circle_radius, float thickness, vec2 uv, float pixel_uv_size)\n{\n\tfloat d = distance(uv, circle_origin);\n\n\tfloat surface\t= abs(d - circle_radius) - thickness * 0.5;\n\tfloat colour\t= smoothstep(pixel_uv_size, 0.0, surface);\n\tfloat alpha\t\t= (d < circle_radius) ? 1.0 : colour;\n\n\treturn vec2(colour, alpha);\n}\n\n// Circle with a sprial in the middle!\nvec2 Wheel(vec2 wheel_origin, float wheel_radius, float wheel_angle, float thickness, vec2 uv, float pixel_uv_size)\n{\n\tvec2 r = uv - wheel_origin;\n\n\t// We need wheel space, w.\n\tfloat sa = sin(wheel_angle);\n\tfloat ca = cos(wheel_angle);\n\n\tvec2 w = vec2(\n\t\t\t\tdot(r, vec2( sa,ca)),\n\t\t\t\tdot(r, vec2(-ca,sa)));\n\n\t// Wonky please!\n\tw = ApplyWarp(w, 0.11);\n\n\tfloat d = length(w);\n\n\tfloat surface\t= abs(d - wheel_radius) - thickness * 0.5;\n\tfloat colour\t= smoothstep(pixel_uv_size, 0.0, surface);\n\tfloat alpha\t\t= (d < wheel_radius) ? 1.0 : colour;\n\n\tif (d < wheel_radius)\n\t{\n        if (d < thickness * 2.0)\n        {\n            colour = smoothstep(pixel_uv_size, 0.0, d - thickness * 1.0);\n        }\n\t\n\t\t// So the point on the spiral, s.\n\t\tfloat a = atan(w.y,w.x);\n\t\tfloat d = a + 3.1;\n\t\td *= d;\n\t\td *= 0.027;\n\t\td *= wheel_radius;\n\n\t\tvec2 s = normalize(w) * d;\n\n\t\tfloat spiral_surface\t= distance(s, w) - thickness * 0.5;\n\t\tfloat spiral_colour\t\t= smoothstep(pixel_uv_size, 0.0, spiral_surface);\n\n\t\tcolour = max(colour, spiral_colour);\n\t}\n\n\treturn vec2(colour, alpha);\n}\n\n// chimney_dims = width bot, height, width top.\nvec2 Chimney(vec2 chimney_origin, vec2 chimney_dx, vec2 chimney_dy, vec3 chimney_dims, float anim, float thickness, vec2 uv, float pixel_uv_size)\n{\n\tvec2 r = vec2(\n\t\t\t\tdot(uv - chimney_origin, chimney_dx),\n\t\t\t\tdot(uv - chimney_origin, chimney_dy));\n\n\tif (r.y < 0.0 || r.y > chimney_dims.y + thickness)\n\t{\n\t\treturn vec2(0.0, 0.0);\n\t}\n\n\tr.x = abs(r.x);\n\n\tif (r.x > chimney_dims.x + thickness + chimney_dims.y * 0.4)\n\t{\n\t\treturn vec2(0.0, 0.0);\n\t}\n\n    float b = 1.0 - anim;\n\tfloat q = 1.0-b*b*b*b;\n\tfloat a = 2.0*(1.0-q)*q;\n\n    float down\t= 1.0 - a * 0.5;\n    float push\t= a;\n    \n    chimney_dims.z *= 1.0 + a * 0.2;\n    \n\tvec2 cp0 = vec2(chimney_dims.x, 0.0);\n\tvec2 cp1 = vec2(chimney_dims.x - chimney_dims.y * 0.33 * push, chimney_dims.y * 0.33);\n\tvec2 cp2 = vec2(chimney_dims.z, chimney_dims.y * 0.66 * down);\n\tvec2 cp3 = vec2(chimney_dims.z, chimney_dims.y * down);\n\n\tfloat t = GetNearestPointAlongCubicSpline(cp0,cp1,cp2,cp3, r);\n\n\tvec2 pt = GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t);\n\n\tfloat dist_from_edge\t= distance(pt, r);\n\tfloat surface\t\t\t= dist_from_edge  - thickness * 0.5;\n\tfloat colour\t\t\t= smoothstep(pixel_uv_size, 0.0, surface);\n\tfloat alpha\t\t\t\t= (r.x < pt.x) ? 1.0 : colour;\n\n\t// Top?\n    float bend = 1.0 - a * 0.3;\n    \n\t//if (alpha > 0.0 && r.y > chimney_dims.y * bend - thickness)\n\t{\n\t\tcp0 = vec2(chimney_dims.z * -1.0, chimney_dims.y * down);\n\t\tcp1 = vec2(chimney_dims.z * -0.3, chimney_dims.y * down * bend);\n\t\tcp2 = vec2(chimney_dims.z * +0.3, chimney_dims.y * down * bend);\n\t\tcp3 = vec2(chimney_dims.z * +1.0, chimney_dims.y * down);\n\n\t\tt = GetNearestPointAlongCubicSpline(cp0,cp1,cp2,cp3, r);\n\n\t\tpt = GetPointOnCubicSpline(cp0,cp1,cp2,cp3, t);\n\n\t\tdist_from_edge\t= distance(pt, r);\n\t\tsurface\t\t\t= dist_from_edge  - thickness * 0.5;\n\t\tcolour\t\t\t= max(colour, smoothstep(pixel_uv_size, 0.0, surface));\n\t\talpha\t\t\t= (r.y > pt.y) ? colour : alpha;\n\t}\n\n\treturn vec2(colour, alpha);\n}\n\nfloat Puff(float puff, float seed, vec2 uv, float pixel_uv_size)\n{\n\tif (!Is0To1(uv))\n    {\n        return 0.0;\n    }\n    \n    const float GRID_SIZE = 4.0;\n\n\tvec2 grid\t\t= uv * vec2(GRID_SIZE, GRID_SIZE);\n\tvec2 gsquare\t= floor(grid);\n\n\tseed *= gsquare.x + 7.8;\n\tseed *= gsquare.y + 9.8;\n\tseed  = sin(seed);\n\n\tfloat\trandom_colour\t= mix( 1.0, 2.0, fract(seed * 15.67));\n\tfloat\trandom_time\t\t= mix(-0.3, 0.3, fract(seed * 27.89));\n\tvec2\trandom_middle\t= vec2(\n\t\t\t\t\t\t\t\tmix(0.35, 0.65, fract(seed * 37.22)),\n\t\t\t\t\t\t\t\tmix(0.35, 0.65, fract(seed * 47.89)));\n\n\tfloat dist_from_middle_of_puff\t\t= distance(gsquare + vec2(0.5,0.5), vec2(GRID_SIZE,GRID_SIZE) * 0.5);\n\tfloat dist_from_middle_of_square\t= distance(grid, gsquare + random_middle);\n\n\tfloat shape\t\t\t= max(0.0, 1.25 - dist_from_middle_of_puff / (GRID_SIZE*0.5-0.5));\n\tfloat start_time\t= mix(0.5, 0.0, dist_from_middle_of_puff / (GRID_SIZE * 0.5));\n\tfloat s\t\t\t\t= clamp(puff + start_time + random_time, 0.0, 1.0);\n\tfloat fade\t\t\t= random_colour * shape * smoothstep(1.0,0.9,s);\n\tfloat size\t\t\t= (1.0-s)*s * 1.2;\n\n\tfloat colour = smoothstep(pixel_uv_size * GRID_SIZE, 0.0, abs(dist_from_middle_of_square - size)-0.01);\n\n\treturn colour * fade;\n}\n\nfloat PrintNumber(float n, vec2 digit_uv, vec2 uv, float pixel_uv_size)\n{\n\tvec2 rel_uv = uv - digit_uv;\n\n\tif (rel_uv.y < 0.0 || rel_uv.y > 1.0)\n\t{\n\t\treturn 0.0;\n\t}\n\n\tfloat digit_place = floor(rel_uv.x - 3.0);\n\n\tif (digit_place >= 1.0 || digit_place <= -3.0)\n\t{\n\t\treturn 0.0;\n\t}\n\n\tint digit = int(10.0 * fract(n * pow(10.0, digit_place)));\n\t\n\treturn CharDigit(digit, fract(rel_uv), pixel_uv_size);\n}\n\n\n// ============================================================================================\n\n#define SPEED_SCALE 3.0\n\nfloat GetTrainXAtTime(float time)\n{\n    if (time < 2.0)\n    {\n        return SPEED_SCALE * (time*time / 4.0 - 3.5);\n    }\n    \n\treturn SPEED_SCALE * (time - 4.5);\n}\n\nvec2 GetCameraPosAtTime(float time)\n{\n    if (time < 12.0)\n    {\n        return vec2(time*time / 24.0, 0.0) * SPEED_SCALE;\n    }\n \n\tfloat t = time - 12.0;\n\n\tif (t > 60.0)\n\t{\n\t\treturn vec2(61.0, 0.0) * SPEED_SCALE;\n\t}\n\n\tif (t > 50.0)\n\t{\n\t\tfloat x = (t - 50.0) / 20.0;\n\n\t\treturn vec2(56.0 + 20.0*x - 20.0*x*x, 0.0) * SPEED_SCALE;\n\t}\n\n\treturn vec2(6.0+t, 0.0) * SPEED_SCALE;\n}\n\nfloat GetTrackHeight(float world_x)\n{\n\treturn 2.5 + sin(world_x * 0.29) + sin(world_x * 0.47) * 0.43;\n}\n\nvoid GetTrainWheelPositions(float time, out vec2 out_wheel_0, out vec2 out_wheel_1)\n{\n\tconst float TRAIN_WHEELBASE = 3.0;\n\n\tfloat train_x0 = GetTrainXAtTime(time);\n\tfloat train_x1 = train_x0 + TRAIN_WHEELBASE;\n\n\tvec2 train_wheel_0 = vec2(train_x0, GetTrackHeight(train_x0));\n\tvec2 train_wheel_1 = vec2(train_x1, GetTrackHeight(train_x1));\n\n\ttrain_wheel_1\t= train_wheel_0 + normalize(train_wheel_1 - train_wheel_0) * TRAIN_WHEELBASE;\n\ttrain_wheel_1.y\t= GetTrackHeight(train_wheel_1.x);\n\ttrain_wheel_1\t= train_wheel_0 + normalize(train_wheel_1 - train_wheel_0) * TRAIN_WHEELBASE;\n\ttrain_wheel_1.y\t= GetTrackHeight(train_wheel_1.x);\n\t\n\tout_wheel_0 = train_wheel_0;\n\tout_wheel_1 = train_wheel_1;\n}\n\nvoid GetTrainChimneyPosition(float time, out vec2 out_chimney_top, out vec2 out_chimney_dir)\n{\n\tvec2 wheel_0;\n\tvec2 wheel_1;\n\n\tGetTrainWheelPositions(time, wheel_0, wheel_1);\n\n\tvec2 dx = normalize(wheel_1 - wheel_0);\n\tvec2 dy = vec2(-dx.y,dx.x);\n\n\tout_chimney_top = wheel_0 + dx * 2.25 + dy * 3.8;\n\tout_chimney_dir = dy;\n}\n\n// ============================================================================================\n\n#define SCREEN_HEIGHT 15.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Our sequence takes one minute.\n    float time = min(max(0.0, iTime - 2.0) * (1.0 / 60.0),1.0) * 80.0;\n \n\t// Our screen_uv space has (0,0) at the middle, bottom of the screen and is SCREEN_HEIGHT high and +/- 12*aspect/2 wide.\n\tvec2\tuv\t\t= fragCoord.xy / iResolution.xy;\n    float\taspect\t= float(iResolution.x) / float(iResolution.y);\n\n\tuv.x -= 0.5;\n    uv.x *= aspect;\n\tuv   *= SCREEN_HEIGHT;\n\n\t// Size of a pixel in uv space for antialiasing. Enlarge to get extra creamy AA!\n\tfloat pixel_uv_size = 2.0 * SCREEN_HEIGHT / iResolution.y;\n\n    // Accumulate final colour into here.\n\tvec2 final_colour = vec2(0.0, 0.0);\n\n    // Do this now so we can blur the screen edges.\n    float vignette;\n\t{\n        float fade_out = smoothstep(65.0, 79.0, time);\n        \n        uv *= 1.0 - fade_out * 0.15;\n        uv.y += fade_out * 4.0;\n        \n        vec2 vignette_uv = abs(vec2(2.04,2.0) * (fragCoord.xy / iResolution.xy) - vec2(1.02,1.0));\n        vignette_uv += fade_out * 0.5;\n        vignette_uv *= vignette_uv;\n        vignette_uv *= vignette_uv;\n        vignette = mix(0.2 * (1.0 - fade_out), 1.0 - fade_out * fade_out * fade_out, 1.0 - vignette_uv.x - vignette_uv.y);\n\n        pixel_uv_size /= vignette + 0.1;\n\t}\n\n\t// World space is in the same scale as uv space.\n\tvec2 camera_pos = GetCameraPosAtTime(time);\n\n\t// The track first.\n\tvec2 world_pos = camera_pos + uv;\n\t\n\t{\n\t\tfloat track_y\t\t= GetTrackHeight(world_pos.x);\n\t\tfloat dist_to_track\t= abs(track_y - world_pos.y - 0.1);\n\t\tfloat surface\t\t= dist_to_track - 0.05;\n\t\tfloat colour\t\t= smoothstep(pixel_uv_size, 0.0, surface);\n\n\t\tfinal_colour.xy += colour;\n\t}\n    \n\t#if USE_INTEGERS\n\tconst float\tDIGITS_PER_LINE\t\t\t= 15.0;\n\tconst float\tLINES_OF_PI\t\t\t\t= (float(MAX_DIGIT) + DIGITS_PER_LINE - 1.0) / DIGITS_PER_LINE;\n\t#else\n\tconst float\tDIGITS_PER_LINE\t\t\t= 10.0;\n\tconst float\tLINES_OF_PI\t\t\t\t= ceil((MAX_DIGIT + DIGITS_PER_LINE - 1.0) / DIGITS_PER_LINE);\n\t#endif\n\n\tconst int\tNUM_DIGITS_IN_FLIGHT\t= 4;\n\tconst float\tTIME_FOR_FLIGHT\t\t\t= 4.0;\n\tconst float TIME_PER_PUFF\t\t\t= TIME_FOR_FLIGHT / float(NUM_DIGITS_IN_FLIGHT);\n\tconst vec2\tDEST_DIGIT_UV\t\t\t= vec2(DIGITS_PER_LINE * -0.5, SCREEN_HEIGHT * 0.65);\n\tconst float\tKERNING\t\t\t\t\t= 0.9;\n\tconst float\tTIME_TO_START_PUFFING\t= 3.0;\n\n    \n    float train_x = GetTrainXAtTime(time);\n\n    if (world_pos.x > train_x - 3.0 && world_pos.x < train_x + 5.0 && world_pos.y > SCREEN_HEIGHT * 0.05 && world_pos.y < SCREEN_HEIGHT * 0.6)\n    {\n        // Where is the train now?\n        vec2 train_wheel_0;\n        vec2 train_wheel_1;\n\n        GetTrainWheelPositions(time, train_wheel_0, train_wheel_1);\n\n        vec2 train_dx = normalize(train_wheel_1 - train_wheel_0);\n        vec2 train_dy = vec2(-train_dx.y,train_dx.x);\n\n        // Big wheel.\n        {\n            float\twheel_angle\t\t= time * 3.0;\n            float\twheel_wonky\t\t= sin(wheel_angle) * 0.05;\n\n            train_wheel_0 += train_dy * wheel_wonky;\n\n            vec2\twheel_uv\t\t= train_wheel_0 + train_dy * 1.0;\n            float\twheel_radius\t= 1.0;\n\n            vec2 wheel_colour = Wheel(wheel_uv, wheel_radius, wheel_angle, 0.1, world_pos, pixel_uv_size);\n\n            final_colour += wheel_colour * (1.0 - final_colour.y);\n        }\n\n        // Little wheel.\n        {\n            float\twheel_angle\t\t= time * 5.1;\n            float\twheel_wonky\t\t= sin(wheel_angle) * 0.04;\n\n            train_wheel_1 += train_dy * wheel_wonky;\n\n            vec2\twheel_uv\t\t= train_wheel_1 + train_dy * 0.6;\n            float\twheel_radius\t= 0.6;\n\n            vec2 wheel_colour = Wheel(wheel_uv, wheel_radius, wheel_angle, 0.1, world_pos, pixel_uv_size);\n\n            final_colour += wheel_colour * (1.0 - final_colour.y);\n        }\n\n        // Recalculate train basis due to wonky wheels!\n        train_dx = normalize(train_wheel_1 - train_wheel_0);\n        train_dy = vec2(-train_dx.y,train_dx.x);\n\n        // ------------------------------------------------------------------------\n        // Train\n\n        {\n            vec2 box_uv\t\t= train_wheel_0 - train_dx * 0.2 + train_dy * 0.6;\n            vec2 box_dims\t= vec2(3.0, 2.0);\n            vec2 box_colour\t= Box(box_uv, train_dx, train_dy, box_dims, 0.1, 0.1, world_pos, pixel_uv_size);\n\n            final_colour += box_colour * (1.0 - final_colour.y);\n\n            {\n                vec2 cab_uv\t\t= box_uv + train_dx * 0.2 + train_dy * 2.1;\n                vec2 cab_dx\t\t= train_dx;\n                vec2 cab_dy\t\t= train_dy;\n                vec2 cab_dims\t= vec2(1.0, 1.6);\n\n                vec2 cab_colour\t= Box(cab_uv, cab_dx, cab_dy, cab_dims, 0.1, 0.1, world_pos, pixel_uv_size);\n\n                if (dot(uv - cab_uv, cab_dx) < 1.0)\n                {\n                    vec2 window_uv = cab_uv + cab_dx * 0.9 + cab_dy * 0.9;\n                    vec2 window_colour\t= Circle(window_uv, 0.4, 0.1, world_pos, pixel_uv_size);\n\n                    cab_colour.x += window_colour.x * cab_colour.y;\n                }\n\n                final_colour += cab_colour * (1.0 - final_colour.y);\n            }\n\n            {\n                vec2\tchimney_uv\t\t= box_uv + train_dx * box_dims.x * 0.8 + train_dy * box_dims.y;\n                vec2\tchimney_dx\t\t= train_dx;\n                vec2\tchimney_dy\t\t= train_dy;\n                vec3\tchimney_dims\t= vec3(0.3, 1.1, 0.4);\n                float\tchimney_anim\t= fract(time * TIME_PER_PUFF);\n\n                if (time < TIME_TO_START_PUFFING || time + TIME_PER_PUFF >= TIME_TO_START_PUFFING + float(MAX_DIGIT) * TIME_PER_PUFF)\n                {\n                    chimney_anim = 0.0;\n                }\n\n                vec2\tchimney_colour\t= Chimney(chimney_uv, chimney_dx, chimney_dy, chimney_dims, chimney_anim, 0.1, world_pos, pixel_uv_size);\n\n                final_colour += chimney_colour * (1.0 - final_colour.y);\n            }\n\n            {\n                vec2 circle_uv\t\t= box_uv + train_dx * 3.0 + train_dy * 1.1;\n                vec2 circle_colour\t= Circle(circle_uv, 0.6, 0.1, world_pos, pixel_uv_size);\n\n                final_colour += circle_colour * (1.0 - final_colour.y);\n            }\n        }\n    }\n\n\t// ------------------------------------------------------------------------\n\t// The digits we've already found.\n\n    if (time < 79.0)\n\t{\n        \n        vec2 found_uv \t= (ApplyBulge(uv) - DEST_DIGIT_UV) / vec2(KERNING,1.0);\n\t\tvec2 found_base\t= floor(found_uv);\n\n\t\t// Which digit of pi?\n\t\tfloat line\t\t= -floor(found_base.y);\n\t\tfloat column\t=  floor(found_base.x);\n\n\t\tif (line >= 0.0 && column >= 0.0)\n\t\t{\n\t\t\tfloat nth_digit = float(MAX_DIGIT);\t// MAX_DIGIT -> Invalid.\n\n\t\t\tif (column == 0.0)\n\t\t\t{\n\t\t\t\t// First column only has the first digit.\n\t\t\t\tif (line == 0.0)\n\t\t\t\t{\n\t\t\t\t\tnth_digit = -1.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n            if (column <= DIGITS_PER_LINE)\n\t\t\t{\n\t\t\t\tnth_digit = line * DIGITS_PER_LINE + (column - 1.0);\n\t\t\t}\n\n\t\t\tif (nth_digit < float(MAX_DIGIT))\n\t\t\t{\n\t\t\t\t// How many digits have arrived already?\n\t\t\t\tfloat num_arrived = floor(time - TIME_FOR_FLIGHT - TIME_TO_START_PUFFING);\n\n\t\t\t\tif (nth_digit < num_arrived)\n\t\t\t\t{\n\t\t\t\t\tvec2 digit_uv = (found_uv - found_base) * vec2(KERNING,1.0) + vec2((1.0 - KERNING)*0.5, 0.0);\n                \n\t\t\t\t\tif (IsDigitUV(digit_uv))\n\t\t\t\t\t{\n                        #if USE_INTEGERS\n\t\t\t\t\t\tint pi_digit = GetNthDigitOfPi(int(nth_digit));\n                        #else\n\t\t\t\t\t\tint pi_digit = GetNthDigitOfPi(nth_digit);\n                        #endif\n\t\t\t\t\t\tfinal_colour.x += CharDigit(pi_digit, digit_uv, pixel_uv_size);\t\n                    }\n                        \n                    if (nth_digit == -1.0)\n                    {\n                        final_colour.x += CharDot(digit_uv, pixel_uv_size);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ------------------------------------------------------------------------\n\t// Digit puffs.\n\n    if (uv.x > SCREEN_HEIGHT * -0.7 && uv.y > SCREEN_HEIGHT * 0.3 && uv.y < SCREEN_HEIGHT * 0.9)\n    {\n        for (int i = 0; i < NUM_DIGITS_IN_FLIGHT; i++)\n        {\n            float offset_i\t= float(i) * (TIME_FOR_FLIGHT / float(NUM_DIGITS_IN_FLIGHT));\n            float puff_time\t= (time - offset_i - TIME_TO_START_PUFFING) / TIME_FOR_FLIGHT;\n\n            if (puff_time < 0.0)\n            {\n                continue;\n            }\n\n            float puff_digit = floor(puff_time) * float(NUM_DIGITS_IN_FLIGHT) + float(i) - 1.0;\n\n            if (puff_digit >= 60.0)\t// Always puff even if no more digits... .to keep in sync with sound\n            {\n                continue;\n            }\n\n            float\tpuff_start_time\t\t\t\t= floor(puff_time) * TIME_FOR_FLIGHT + offset_i + TIME_TO_START_PUFFING;\n            float\tpuff_t\t\t\t\t\t\t= pow(fract(puff_time), 0.75);\n            float\tpuff_size\t\t\t\t\t= 1.0 + puff_t * 3.0;\n            float\tdigit_size\t\t\t\t\t= min(0.3 + puff_t, 1.0);\n            vec2\tcamera_pos_at_start_time\t= GetCameraPosAtTime(puff_start_time);\n\n            vec2 chimney_pos_at_start_time;\n            vec2 chimney_dir_at_start_time;\n\n            GetTrainChimneyPosition(puff_start_time, chimney_pos_at_start_time, chimney_dir_at_start_time);\n\n            vec2 puff_cp0 = chimney_pos_at_start_time;\n            vec2 puff_cp1 = chimney_pos_at_start_time + chimney_dir_at_start_time * 5.0;\n            vec2 puff_cp2 = puff_cp1 + vec2(0.0, -1.0);\n            vec2 puff_cp3 = puff_cp1 + vec2(0.0, -2.0);\n\n            vec2 puff_pos\t= GetPointOnCubicSpline(puff_cp0, puff_cp1, puff_cp2, puff_cp3, puff_t);\n            vec2 puff_uv\t= (world_pos - puff_pos)/puff_size+0.5;\n\n            {\n                final_colour.x += Puff(puff_t * 1.5, puff_start_time + 5.6, puff_uv - 0.05, pixel_uv_size / puff_size) * (1.0 - final_colour.y);\n                final_colour.x += Puff(puff_t * 1.5, puff_start_time + 7.9, puff_uv + 0.05, pixel_uv_size / puff_size) * (1.0 - final_colour.y);\n            }\n\n            if (puff_digit >= float(MAX_DIGIT))\n            {\n                continue;\n            }\n            \n            vec2 digit_dest_uv;\n\n            if (puff_digit == -1.0)\n            {\n                // This is the first digit of pi.\n                digit_dest_uv = DEST_DIGIT_UV - (1.0 - KERNING) * 0.5;\n            }\n            else\n            {\n\t\t\t\t#if USE_INTEGERS\n                int line;\n                int column;\n                DivMod(int(puff_digit), int(DIGITS_PER_LINE), line, column);\n\t\t\t\t#else\n                float line;\n                float column;\n                DivMod(puff_digit, DIGITS_PER_LINE, line, column);\n\t\t\t\t#endif\n\n                digit_dest_uv = DEST_DIGIT_UV + vec2((float(column) + 1.0) * KERNING - (1.0 - KERNING) * 0.5, -float(line));\n            }\n\n            // The digit of pi are we puffing out of the train.\n            vec2 digit_cp0 = chimney_pos_at_start_time;\n            vec2 digit_cp1 = chimney_pos_at_start_time + chimney_dir_at_start_time * 5.0;\n            vec2 digit_cp3 = digit_dest_uv + camera_pos;\n            vec2 digit_cp2 = digit_cp3 + vec2(2.0, -8.0);\n\n            float\tbulge_amount\t= smoothstep(0.0, 0.9, puff_t);\n            vec2\tbulged_uv\t\t= mix(uv, ApplyBulge(uv), bulge_amount);\n\n            vec2 digit_pos\t= GetPointOnCubicSpline(digit_cp0, digit_cp1, digit_cp2, digit_cp3, puff_t);\n            vec2 digit_uv\t= (bulged_uv + camera_pos - digit_pos)/digit_size;\n\n            if (IsDigitUV(digit_uv))\n            {\n\t\t\t\t#if USE_INTEGERS\n                int pi_digit = GetNthDigitOfPi(int(puff_digit));\n                #else\n                int pi_digit = GetNthDigitOfPi(puff_digit);\n                #endif\n\n                final_colour += CharDigit(pi_digit, digit_uv, pixel_uv_size) * (1.0 - final_colour.y);\n            }\n        }\n    }\n    \n\t// Apply vignette\n    final_colour.x = sqrt(clamp(final_colour.x,0.0,1.0)) * vignette;\n   \n    if (time >= 75.0)\n    {\n        vec2 original_uv = fragCoord.xy / iResolution.xy;\n        original_uv.x -= 0.5;\n        original_uv.x *= aspect;\n        original_uv   *= SCREEN_HEIGHT;\n        float original_pixel_uv_size = 2.0 * SCREEN_HEIGHT / iResolution.y;\n        \n        vec2 pi_uv = (original_uv - vec2(0.0, SCREEN_HEIGHT * 0.62)) * 0.4 + 0.5;\n        float pi = CharPi(pi_uv, original_pixel_uv_size) * 4.0 * smoothstep(75.0,80.0,time);\n        final_colour.x += sqrt(pi);\n    }\n    \n    fragColor = vec4(final_colour.xxx,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"float Puff(float seed, float time)\n{\n    float t = time / 0.2;\n    \n    if (t <= 0.0 || t >= 1.0)\n    {\n        return 0.0;\n\t}\n    \n    float p = t;\n    float n = 1.0 - t;\n    \n    float amp = 6.0 * n * p * p;\n    \n    seed *= 123.456;\n    seed  = fract(sin(seed) * 100.0);\n\n    float overall_vol = mix(0.05, 0.25, seed);\n\n    seed += 7.0;\n    seed *= 11.0;\n    seed  = fract(sin(seed) * 100.0);\n\n    float buzz = seed;\n    \n    seed *= time;\n    seed += 2.39687843;\n    seed *= time;\n    seed  = fract(seed * 100.0);\n    seed  = sin(seed);\n    \n    return pow(fract(seed * 100.0), mix(1.0, fract(seed), buzz)) * amp * overall_vol;\n}\n\nfloat Click(float seed, float time)\n{\n    return Puff(seed, time * 5.0);\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    float total = 0.0;\n    \n    // Mimic time calc in image\n    time = (max(0.0, time - 2.0) / 60.0) * 80.0;\n\n    // Extra clicks as we accelerate.\n    total += Click(51.6, time - 0.00);\n    total += Click(61.5, time - 0.01);\n    total += Click(71.4, time - 0.03);\n\ttotal += Click(81.3, time - 0.06);\n\n    total += Click(75.6, time - 1.00);\n    total += Click(85.5, time - 1.01);\n    total += Click(95.4, time - 1.03);\n\n    total += Click(3.9, time - 1.50) * 0.8;\n    total += Click(4.8, time - 2.00);\n    total += Click(5.7, time - 2.33) * 0.9;\n    total += Click(6.6, time - 2.67) * 0.8;\n    total += Click(7.5, time - 3.00) * 0.9;\n    total += Click(8.4, time - 3.25) * 0.8;\n    total += Click(9.2, time - 3.50) * 0.7;\n    total += Click(9.1, time - 3.75) * 0.6;\n    \n    // Engine running...\n    float engine_amp = smoothstep(0.0, 2.0, time);\n    \n    total += Click(1.1 + fract(time), fract(time - 0.0)) * 0.50 * engine_amp;\n    total += Click(3.2 + fract(time), fract(time - 0.2)) * 0.45 * engine_amp;\n    total += Click(5.3 + fract(time), fract(time - 0.4)) * 0.42 * engine_amp;\n    total += Click(7.4 + fract(time), fract(time - 0.6)) * 0.41 * engine_amp;\n    total += Click(9.5 + fract(time), fract(time - 0.8)) * 0.40 * engine_amp;\n    \n\t// TIME_TO_START_PUFFING... with a bit of extra anticipation\n\tfloat puff_time = time - 2.9;\n\n    if (puff_time > 0.0 && puff_time < 60.0)\n    {\n        total += Puff(ceil(puff_time) * 1.234, fract(puff_time));\n    }\n\n    float final_vol = smoothstep(69.0,65.0,time);\n    \n\treturn vec2(total * final_vol);\n}\n\n","name":"Sound","description":"","type":"sound"}]}