{"ver":"0.1","info":{"id":"NtcyWM","date":"1660407746","viewed":257,"name":"Text - Truetype (scanline)","username":"mrboggieman","description":"Simple rendering of text by tracing a scanline for all lines and curves within range. Drag the mouse in the x axis to zoom in. See postscript shader here: https://www.shadertoy.com/view/ftcyWB","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["text","scanline","ttf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//MIT Licence\nstruct Quadratic {\n   vec2 a;\n   vec2 b;\n   vec2 c;\n   vec2 aabbMin;\n   vec2 aabbMax;\n};\n\nstruct Line {\n   vec2 a;\n   vec2 b;\n   vec2 aabbMin;\n   vec2 aabbMax;\n};\n\nstruct Closest {\n    float x;\n    bool inside;\n};\n\n//utils\nconst float almost_zero = 0.0001;\nconst float almost_one = 0.9999;\nconst float bit_over_one = 1.0001;\nconst float bit_under_zero = -0.0001;\n\nint linear(in float a, in float b, out float[2] roots) {\n    if (abs(a) < almost_zero) {\n        return 0;\n    }\n    \n    roots[0] = -b/a;\n    return 1;\n}\n\nint quadratic(in float a, in float b, in float c, out float[2] roots) {\n    if (abs(a) < almost_zero) {\n        return linear(b, c, roots);\n    }\n    \n    float nom = sqrt(b*b - 4.0*a*c);\n    float denom = 2.0 * a;\n\n    roots[0] = (-b + nom) / denom;\n    roots[1] = (-b - nom) / denom;\n    return 2;\n}\n\nvoid testLine(in Line test, in vec2 p, inout Closest closest) {\n    float a = test.b.y - test.a.y;\n    float b = test.a.y - p.y;\n    \n    float[2] ts;\n    int numRoots = linear(a, b, ts);\n    \n    float derivative = sign(a);\n\n    for (int i=0; i<numRoots; i++) {\n        if (ts[i] > bit_under_zero && ts[i] < bit_over_one) {\n            float t = ts[i];            \n            float x = mix(test.a.x, test.b.x, t);\n\n            if (p.x > x && x > closest.x) {\n                closest.inside = derivative < 0.0;\n                closest.x = x;\n            }\n        }\n    }\n}\n\nvoid testQuadraticBezier(in Quadratic test, in vec2 p, inout Closest closest) {\n    float a = test.a.y - 2.0 * test.b.y + test.c.y;\n    float b = 2.0 * (test.b.y - test.a.y);\n    float c = test.a.y - p.y;\n\n    float[2] ts;\n    int numRoots = quadratic(a, b, c, ts);\n\n    float derivativeA = 2.0 * a;\n    float derivativeB = b;\n\n    for (int i=0; i<numRoots; i++) {\n        if (ts[i] >= bit_under_zero && ts[i] <= bit_over_one) {\n            float t = ts[i];\n            float x = mix(mix(test.a.x, test.b.x, t), mix(test.b.x, test.c.x, t), t);\n            \n            if (p.x > x && x > closest.x) {\n                closest.inside = sign(derivativeA * t + derivativeB) < 0.0;\n                closest.x = x;\n            }\n        }\n    }\n}\n\n//demo\nconst Line[] lines = Line[](\n    Line(vec2(0.74120,-0.01030),vec2(0.71340,0.05570),vec2(0.71340,-0.01030),vec2(0.74120,0.05570)),\n    Line(vec2(0.38820,-0.12890),vec2(0.41110,-0.19780),vec2(0.38820,-0.19780),vec2(0.41110,-0.12890)),\n    Line(vec2(1.40040,-0.28080),vec2(1.18990,-0.28080),vec2(1.18990,-0.28080),vec2(1.40040,-0.28080)),\n    Line(vec2(1.18990,-0.28080),vec2(1.18990,-0.36470),vec2(1.18990,-0.36470),vec2(1.18990,-0.28080)),\n    Line(vec2(1.18990,-0.36470),vec2(1.49320,-0.36520),vec2(1.18990,-0.36520),vec2(1.49320,-0.36470)),\n    Line(vec2(1.49320,-0.36520),vec2(1.49320,-0.09960),vec2(1.49320,-0.36520),vec2(1.49320,-0.09960)),\n    Line(vec2(1.48240,-0.51560),vec2(1.39700,-0.49220),vec2(1.39700,-0.51560),vec2(1.48240,-0.49220)),\n    Line(vec2(1.40040,-0.14750),vec2(1.40040,-0.28080),vec2(1.40040,-0.28080),vec2(1.40040,-0.14750))\n);\n\nconst Quadratic[] quadratics = Quadratic[](\n    Quadratic(vec2(0.61960,-0.07670),vec2(0.68550,-0.03130),vec2(0.74120,-0.01030),vec2(0.61960,-0.07670),vec2(0.74120,-0.01030)),\n    Quadratic(vec2(0.71340,0.05570),vec2(0.63620,0.02780),vec2(0.55960,-0.03220),vec2(0.55960,-0.03220),vec2(0.71340,0.05570)),\n    Quadratic(vec2(0.55960,-0.03220),vec2(0.48000,0.01220),vec2(0.38380,0.01220),vec2(0.38380,-0.03220),vec2(0.55960,0.01220)),\n    Quadratic(vec2(0.38380,0.01220),vec2(0.28660,0.01220),vec2(0.20750,-0.03470),vec2(0.20750,-0.03470),vec2(0.38380,0.01220)),\n    Quadratic(vec2(0.20750,-0.03470),vec2(0.12840,-0.08150),vec2(0.08570,-0.16650),vec2(0.08570,-0.16650),vec2(0.20750,-0.03470)),\n    Quadratic(vec2(0.08570,-0.16650),vec2(0.04300,-0.25150),vec2(0.04300,-0.35790),vec2(0.04300,-0.35790),vec2(0.08570,-0.16650)),\n    Quadratic(vec2(0.04300,-0.35790),vec2(0.04300,-0.46390),vec2(0.08590,-0.55080),vec2(0.04300,-0.55080),vec2(0.08590,-0.35790)),\n    Quadratic(vec2(0.08590,-0.55080),vec2(0.12890,-0.63770),vec2(0.20830,-0.68310),vec2(0.08590,-0.68310),vec2(0.20830,-0.55080)),\n    Quadratic(vec2(0.20830,-0.68310),vec2(0.28760,-0.72850),vec2(0.38570,-0.72850),vec2(0.20830,-0.72850),vec2(0.38570,-0.68310)),\n    Quadratic(vec2(0.38570,-0.72850),vec2(0.48490,-0.72850),vec2(0.56450,-0.68140),vec2(0.38570,-0.72850),vec2(0.56450,-0.68140)),\n    Quadratic(vec2(0.56450,-0.68140),vec2(0.64400,-0.63430),vec2(0.68580,-0.54960),vec2(0.56450,-0.68140),vec2(0.68580,-0.54960)),\n    Quadratic(vec2(0.68580,-0.54960),vec2(0.72750,-0.46480),vec2(0.72750,-0.35840),vec2(0.68580,-0.54960),vec2(0.72750,-0.35840)),\n    Quadratic(vec2(0.72750,-0.35840),vec2(0.72750,-0.27000),vec2(0.70070,-0.19950),vec2(0.70070,-0.35840),vec2(0.72750,-0.19950)),\n    Quadratic(vec2(0.70070,-0.19950),vec2(0.67380,-0.12890),vec2(0.61960,-0.07670),vec2(0.61960,-0.19950),vec2(0.70070,-0.07670)),\n    Quadratic(vec2(0.41110,-0.19780),vec2(0.49320,-0.17480),vec2(0.54640,-0.12940),vec2(0.41110,-0.19780),vec2(0.54640,-0.12940)),\n    Quadratic(vec2(0.54640,-0.12940),vec2(0.62990,-0.20560),vec2(0.62990,-0.35840),vec2(0.54640,-0.35840),vec2(0.62990,-0.12940)),\n    Quadratic(vec2(0.62990,-0.35840),vec2(0.62990,-0.44530),vec2(0.60030,-0.51030),vec2(0.60030,-0.51030),vec2(0.62990,-0.35840)),\n    Quadratic(vec2(0.60030,-0.51030),vec2(0.57080,-0.57520),vec2(0.51390,-0.61110),vec2(0.51390,-0.61110),vec2(0.60030,-0.51030)),\n    Quadratic(vec2(0.51390,-0.61110),vec2(0.45700,-0.64700),vec2(0.38620,-0.64700),vec2(0.38620,-0.64700),vec2(0.51390,-0.61110)),\n    Quadratic(vec2(0.38620,-0.64700),vec2(0.28030,-0.64700),vec2(0.21040,-0.57450),vec2(0.21040,-0.64700),vec2(0.38620,-0.57450)),\n    Quadratic(vec2(0.21040,-0.57450),vec2(0.14060,-0.50200),vec2(0.14060,-0.35790),vec2(0.14060,-0.57450),vec2(0.21040,-0.35790)),\n    Quadratic(vec2(0.14060,-0.35790),vec2(0.14060,-0.21830),vec2(0.20970,-0.14360),vec2(0.14060,-0.35790),vec2(0.20970,-0.14360)),\n    Quadratic(vec2(0.20970,-0.14360),vec2(0.27880,-0.06880),vec2(0.38620,-0.06880),vec2(0.20970,-0.14360),vec2(0.38620,-0.06880)),\n    Quadratic(vec2(0.38620,-0.06880),vec2(0.43700,-0.06880),vec2(0.48190,-0.08790),vec2(0.38620,-0.08790),vec2(0.48190,-0.06880)),\n    Quadratic(vec2(0.48190,-0.08790),vec2(0.43750,-0.11670),vec2(0.38820,-0.12890),vec2(0.38820,-0.12890),vec2(0.48190,-0.08790)),\n    Quadratic(vec2(1.49320,-0.09960),vec2(1.42330,-0.04390),vec2(1.34910,-0.01590),vec2(1.34910,-0.09960),vec2(1.49320,-0.01590)),\n    Quadratic(vec2(1.34910,-0.01590),vec2(1.27490,0.01220),vec2(1.19680,0.01220),vec2(1.19680,-0.01590),vec2(1.34910,0.01220)),\n    Quadratic(vec2(1.19680,0.01220),vec2(1.09130,0.01220),vec2(1.00510,-0.03300),vec2(1.00510,-0.03300),vec2(1.19680,0.01220)),\n    Quadratic(vec2(1.00510,-0.03300),vec2(0.91890,-0.07810),vec2(0.87500,-0.16360),vec2(0.87500,-0.16360),vec2(1.00510,-0.03300)),\n    Quadratic(vec2(0.87500,-0.16360),vec2(0.83110,-0.24900),vec2(0.83110,-0.35450),vec2(0.83110,-0.35450),vec2(0.87500,-0.16360)),\n    Quadratic(vec2(0.83110,-0.35450),vec2(0.83110,-0.45900),vec2(0.87480,-0.54960),vec2(0.83110,-0.54960),vec2(0.87480,-0.35450)),\n    Quadratic(vec2(0.87480,-0.54960),vec2(0.91850,-0.64010),vec2(1.00050,-0.68410),vec2(0.87480,-0.68410),vec2(1.00050,-0.54960)),\n    Quadratic(vec2(1.00050,-0.68410),vec2(1.08250,-0.72800),vec2(1.18950,-0.72800),vec2(1.00050,-0.72800),vec2(1.18950,-0.68410)),\n    Quadratic(vec2(1.18950,-0.72800),vec2(1.26710,-0.72800),vec2(1.32980,-0.70290),vec2(1.18950,-0.72800),vec2(1.32980,-0.70290)),\n    Quadratic(vec2(1.32980,-0.70290),vec2(1.39260,-0.67770),vec2(1.42820,-0.63280),vec2(1.32980,-0.70290),vec2(1.42820,-0.63280)),\n    Quadratic(vec2(1.42820,-0.63280),vec2(1.46390,-0.58790),vec2(1.48240,-0.51560),vec2(1.42820,-0.63280),vec2(1.48240,-0.51560)),\n    Quadratic(vec2(1.39700,-0.49220),vec2(1.38090,-0.54690),vec2(1.35690,-0.57810),vec2(1.35690,-0.57810),vec2(1.39700,-0.49220)),\n    Quadratic(vec2(1.35690,-0.57810),vec2(1.33300,-0.60940),vec2(1.28860,-0.62820),vec2(1.28860,-0.62820),vec2(1.35690,-0.57810)),\n    Quadratic(vec2(1.28860,-0.62820),vec2(1.24410,-0.64700),vec2(1.18990,-0.64700),vec2(1.18990,-0.64700),vec2(1.28860,-0.62820)),\n    Quadratic(vec2(1.18990,-0.64700),vec2(1.12500,-0.64700),vec2(1.07760,-0.62720),vec2(1.07760,-0.64700),vec2(1.18990,-0.62720)),\n    Quadratic(vec2(1.07760,-0.62720),vec2(1.03030,-0.60740),vec2(1.00120,-0.57520),vec2(1.00120,-0.62720),vec2(1.07760,-0.57520)),\n    Quadratic(vec2(1.00120,-0.57520),vec2(0.97220,-0.54300),vec2(0.95610,-0.50440),vec2(0.95610,-0.57520),vec2(1.00120,-0.50440)),\n    Quadratic(vec2(0.95610,-0.50440),vec2(0.92870,-0.43800),vec2(0.92870,-0.36040),vec2(0.92870,-0.50440),vec2(0.95610,-0.36040)),\n    Quadratic(vec2(0.92870,-0.36040),vec2(0.92870,-0.26460),vec2(0.96170,-0.20020),vec2(0.92870,-0.36040),vec2(0.96170,-0.20020)),\n    Quadratic(vec2(0.96170,-0.20020),vec2(0.99460,-0.13570),vec2(1.05760,-0.10450),vec2(0.96170,-0.20020),vec2(1.05760,-0.10450)),\n    Quadratic(vec2(1.05760,-0.10450),vec2(1.12060,-0.07320),vec2(1.19140,-0.07320),vec2(1.05760,-0.10450),vec2(1.19140,-0.07320)),\n    Quadratic(vec2(1.19140,-0.07320),vec2(1.25290,-0.07320),vec2(1.31150,-0.09690),vec2(1.19140,-0.09690),vec2(1.31150,-0.07320)),\n    Quadratic(vec2(1.31150,-0.09690),vec2(1.37010,-0.12060),vec2(1.40040,-0.14750),vec2(1.31150,-0.14750),vec2(1.40040,-0.09690))\n);\n\nfloat circ(in float t) {\n    return sqrt(1.0 - (t - 1.0)*(t - 1.0));\n}\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 20.0 * (iMouse.x > 10.0 ? 1.0 - circ(iMouse.x / iResolution.x) : 0.05);\n    \n    vec2 p = ((fragCoord.xy / iResolution.y)) * scale;\n    p.y = -p.y + 0.1;\n    \n    //for a simple point in shape test we will go through all of the lines and quadratics and determine which side of the shape we are on\n    Closest closest = Closest(0.0, false);\n\n    for (int i=0; i<quadratics.length(); i++) {\n        Quadratic test = quadratics[i];\n\n        if (p.y <= test.aabbMax.y && p.y >= test.aabbMin.y && p.x >= test.aabbMin.x) {\n            testQuadraticBezier(test, p, closest);\n        }\n    }\n    \n    for (int i=0; i<lines.length(); i++) {\n        Line test = lines[i];\n\n        if (p.y <= test.aabbMax.y && p.y >= test.aabbMin.y && p.x > test.aabbMin.x) {\n            testLine(test, p, closest);\n        }\n    }\n    \n    //check if we are inside or outside\n    if (closest.inside) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    fragColor = vec4(vec3(0.0), 1.0);\n}\n\n// some aa from https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    vec4 o;\n    for (int k=0; k < 9; k+= k==3?2:1 )\n      { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n    O /= 9.;\n}","name":"Image","description":"","type":"image"}]}