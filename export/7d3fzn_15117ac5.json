{"ver":"0.1","info":{"id":"7d3fzn","date":"1655910042","viewed":86,"name":"Meatball Space","username":"PieHunter29","description":"ray marching space","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float pitchRad(vec3 v) {\n    return atan(v.y, v.x);\n}\n\nfloat distFromSphere(vec3 pos, vec3 s) {\n    float radius = 0.25;\n    vec3 normal = normalize(pos-s);\n    //radius += .2 * (1.0 + sin(8.0 * pitchRad(normal))) * (1.0 - normal.z);\n    vec3 p=(pos-s)*3.0;\n    radius += .25*(1.0+sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z))/8.0;\n    return distance(pos, s) - radius;\n}\n\nvec3 calculateNormal(vec3 p, vec3 s) {\n\n    vec3 small_stepx = vec3(0.001, 0.0, 0.0);\n    vec3 small_stepy = vec3(0.0, 0.001, 0.0);\n    vec3 small_stepz = vec3(0.0, 0.0, 0.001);\n\n    float gradient_x = distFromSphere(p+small_stepx, s)-distFromSphere(p-small_stepx, s);\n    float gradient_y = distFromSphere(p+small_stepy, s)-distFromSphere(p-small_stepy, s);\n    float gradient_z = distFromSphere(p+small_stepz, s)-distFromSphere(p-small_stepz, s);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n\n}\n\nvec3 rand3 (vec3 st) {\n    return vec3(fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123),\n                fract(sin(dot(st.xy, vec2(32.9843,93.289)))*93769.4386302),\n                fract(sin(dot(st.xy, vec2(48.5720,37.961)))*20450.7535901));\n}\n\nvec3 sphere(vec3 pos) {\n    vec3 cell = floor(pos/1.0)*1.0;\n    return cell+vec3(0.5);//+(rand3(cell)-vec3(0.5))/2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n\tuv -= iResolution.xy/iResolution.y/2.-.5;\n    vec2 mouse = iMouse.xy/iResolution.y;\n\tmouse -= iResolution.xy/iResolution.y/2.-.5;\n    \n    vec3 light = vec3(0, 2, 2);\n    vec3 sphere1 = vec3(0, 4, 0);\n    vec3 sphere2 = vec3(-2, 2.5, 0);\n    sphere2.xz = vec2(mouse)*2.5;\n    \n    float focalLength = 0.5;\n    float z = 1.-mouse.x*2.;\n    float x = 1.-mouse.y*2.;\n    mat3 rotZ = mat3(0);\n    rotZ[0]=vec3(cos(z),-sin(z),0);\n    rotZ[1]=vec3(sin(z),cos(z),0);\n    rotZ[2][2]=1.0;\n    mat3 rotX = mat3(0);\n    rotX[0][0]=1.0;\n    rotX[1]=vec3(0,cos(x),sin(x));\n    rotX[2]=vec3(0,-sin(x),cos(x));\n    vec3 cameraRay = vec3(uv.x-0.5, focalLength, uv.y-0.5);\n    cameraRay*=rotZ;\n    cameraRay*=rotX;\n    vec3 color = vec3(0.749,0.192,0.051);\n    \n    vec3 pos = vec3(0);\n    vec3 ray = normalize(cameraRay);\n    float distTraveled = 0.0;\n    int closest = 0;\n    for (int m = 0; m < 80; m++) {\n        float dist = 999.0;\n        //for (int s = 0; s < 1; s++) {\n            dist = min(dist, distFromSphere(pos, sphere(pos)));\n        //}\n        pos += ray*dist;\n        distTraveled += dist;\n        /*if (distTraveled > 6.0) {\n            color = vec3(-1);\n            break;\n        }*/\n    }\n    vec3 closestS = sphere(pos);\n    if (color != vec3(-1)) {\n        //color.r = closest == 0 ? 1.0:0.0;\n        //color.g = closest == 1 ? 1.0:0.0;\n        //closestS = closest == 0 ? sphere1:sphere2;\n        vec3 normal = calculateNormal(pos, closestS);\n        vec3 lightDir = normalize(light-pos);\n        float dp = 0.5+(1.0-0.5)*dot(normal, lightDir);\n        color *= max(dp, 0.0);\n    }\n    if (color == vec3(-1)) {\n        color = vec3(0);\n    }\n\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}