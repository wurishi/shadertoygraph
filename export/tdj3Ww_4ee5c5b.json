{"ver":"0.1","info":{"id":"tdj3Ww","date":"1550587800","viewed":308,"name":"Almost a Sun","username":"martinsh","description":" a work in progress sun surface shader","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["sun","star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//attempts to simulate Sun`s limb darkening \n//https://en.wikipedia.org/wiki/Limb_darkening\n//https://hesperia.gsfc.nasa.gov/ssw/gen/idl/solar/darklimb_correct.pro\n\n//https://hesperia.gsfc.nasa.gov/ssw/gen/idl/solar/darklimb_u.pro\n//https://hesperia.gsfc.nasa.gov/ssw/gen/idl/solar/darklimb_v.pro\n//not really giving me the results I`d like to see :/\n//i`m surely doing something wrong here\n\n//i have to revisit this one\n//http://www.physics.hmc.edu/faculty/esin/a101/limbdarkening.pdf\n#define time iTime*2.0\n\nfloat gamma = 2.2;\nfloat scale = 1.0;\nfloat exposure = 40.2;\n\nvec3 sunColor = vec3(1.0,0.14,0.01); //artistic value\n\nvec2 darklimbUlVl(float wavelength)\n{\n    float ll = wavelength; //wavelength in Angstroms (lambda)\n\n    float au = -8.9829751;\n    float bu = 0.0069093916;\n    float cu = -1.8144591e-6;\n    float du = 2.2540875e-10;\n    float eu = -1.3389747e-14;\n    float fu = 3.0453572e-19;\n\n    float av = 9.2891180;\n    float bv = -0.0062212632;\n    float cv = 1.5788029e-6;\n    float dv = -1.9359644e-10;\n    float ev = 1.1444469e-14;\n    float fv = -2.599494e-19;\n\n    float ul = au+(bu*ll)+(cu*pow(ll,2.0))+(du*pow(ll,3.0))+(eu*pow(ll,4.0))+(fu*pow(ll,5.0));\n    float vl = av+(bv*ll)+(cv*pow(ll,2.0))+(dv*pow(ll,3.0))+(ev*pow(ll,4.0))+(fv*pow(ll,5.0));\n    return vec2(ul,vl);\n}\n\nfloat limbDarkening(in float cosTheta)\n{\n    //values from somewhere in internet..\n\tfloat ul = 0.85;\n\tfloat vl = 0.65;\n    \n\tfloat sundisk = cosTheta;\n\tfloat limbfilt = 1.0 - ul - vl + ul*cos(asin(sundisk)) + vl*pow(cos(asin(sundisk)),2.0);\n    return limbfilt;\n}\n\nvec3 limbDarkening3(in float cosTheta)\n{\n\tfloat sundisk = cosTheta;\n    vec2 ulvlR = darklimbUlVl(6700.0); //red wavelength in Angstroms\n\tvec2 ulvlG = darklimbUlVl(5200.0); //green wavelength in Angstroms\n    vec2 ulvlB = darklimbUlVl(4500.0); //blue wavelength in Angstroms\n        \n\tfloat limbR = 1.0 - ulvlR.x - ulvlR.y + ulvlR.x*cos(asin(sundisk)) + ulvlR.y*pow(cos(asin(sundisk)),2.0);\n    float limbG = 1.0 - ulvlG.x - ulvlG.y + ulvlG.x*cos(asin(sundisk)) + ulvlG.y*pow(cos(asin(sundisk)),2.0);\n    float limbB = 1.0 - ulvlB.x - ulvlB.y + ulvlB.x*cos(asin(sundisk)) + ulvlB.y*pow(cos(asin(sundisk)),2.0);\n    return vec3(limbR,limbG,limbB);\n}\n\n\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\n\nfloat simplex3D(vec3 p)\n{\n\t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\nfloat fbm(vec3 p, vec3 n)\n{\n\tfloat f;\n    f  = 0.60000*pow((simplex3D( p*0.9 )),3.0)*0.4+0.6; p = p*2.01;\n    f += 0.35000*pow(abs(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(3.0))*3.0)),0.8 ); p = p*2.02; //from iq\n    //* 1.0 / pow(f*0.0002+0.9998,3.0)\n    f += 0.12500*pow(simplex3D( p*0.9 + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*3.0),2.0 ); p = p*2.03;\n    f += 0.1250*(simplex3D( p*0.6 + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(2.0))*2.0) ); p = p*2.04;\n    f += 0.03125*(simplex3D( p + pow(vec3(f*n.x,f*n.y,f*n.z),vec3(3.0))*3.0) );\n\treturn f;\n}\n\n#define ONE vec2(1.0, 0.0)\n#define EPS vec2(1e-3, 0.0)\n\nconst float pi = 3.1415926;\n\nfloat N(vec2 p)\n{\n   p = mod(p, 4.0);\n   return fract(sin(p.x * 41784.0) + sin(p.y * 32424.0));\n}\n\nfloat smN2(vec2 p)\n{\n\tvec2 fp = floor(p);\n\tvec2 pf = smoothstep(0.0, 1.0, fract(p));\n\treturn mix( mix(N(fp), N(fp + ONE), pf.x), \n\t\t\t   mix(N(fp + ONE.yx), N(fp + ONE.xx), pf.x), pf.y);\n}\n\n\nfloat fbm2(vec2 p)\n{\n\tfloat f = 0.0, x;\n\tfor(int i = 1; i <= 9; ++i)\n\t{\n\t\tx = exp2(float(i));\n\t\tf += smN2(p * x) / x;\n\t}\n\treturn f;\n}\n\n// Scalar field for the surface undulations.\n\nfloat spots(vec2 p)\n{\n\tp *= 2.5;\n\treturn smN2(p + EPS.xy * 2.0);\n}\n\nfloat field(vec2 p)\n{\n\tp *= 1.5;\n\treturn mix(smN2(p * 3.0), smN2(p * 4.0), 0.5 + 0.5 * cos(time * 0.02 + p.x*3.8 + 2.531)+ sin(time * 0.01 + p.y*4.2 + 1.536));\n}\n\nfloat field2(vec2 p)\n{\n\tp *= 6.5;\n\treturn mix(smN2(p * 2.0), smN2(p * 5.0), 0.5 + 0.5 * sin(time * 0.6 + p.x*2.0 + 83.123)+ cos(time * 0.5 + p.y*4.0 + 2.323));\n}\n\n// Vector field extracted from the scalar field.\nvec2 flow(vec2 p)\n{\n    vec2 flowout = vec2(0.0,0.0);\n\tfloat f0 = field(p);\n\tfloat f1 = field(p + EPS.xy);\n\tfloat f2 = field(p + EPS.yx);\n    flowout += (vec2(f1 - f0, f2 - f0)).yx * vec2(-1, 1) * 0.13;\n    float f20 = field2(p);\n\tfloat f21 = field2(p + EPS.xy);\n\tfloat f22 = field2(p + EPS.yx);\n    flowout += (vec2(f21 - f20, f22 - f20)).yx * vec2(-1, 1) * 0.005;\n\treturn flowout;\n}\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    \n    scale *= (1.0-(iMouse.y / iResolution.y))+0.05;\n    exposure *= ((iMouse.x / iResolution.x))*0.5+0.01;\n    \n    vec2 R = iResolution.xy, \n         M = iMouse.xy/R;\n         U = (( U + U - R ) / R.y)*scale; \n    O -= O;\n    \n    \n    \n    float l = length(U),\n      dotNL = sqrt(1.-l*l),                // N = ( U.x, U.y, sqrt(1.-l*l) )\n          a = iTime;\n    //if ( M != vec2(0) ) wrap = M.x, shape = 4.*M.y;\n    \n    vec3 N = vec3( U.x, U.y, sqrt(1.-l*l) );\n    \n\tfloat sky = max(0.0,dot(U, U));\n    \n    float dotVL = dot(vec3(U,dotNL), vec3(sin(a),0,cos(a)) );    \n    vec3 sunpos = vec3(U,dotNL);\n\n\t\n\tvec2 uv = vec2(atan(sunpos.z, sunpos.x) / pi * 2.0, acos(sunpos.y) / pi * 2.0 - 1.0);\n    \n\tconst int count = 32;\n    float csum = 0.0;\n    float wsum = 0.0;\n    \n\tfor(int i = 0; i < count; ++i)\n\t{\n\t\tfloat w = 1.0;\n        uv += flow(uv);\n\t\tcsum += fbm(vec3(uv + vec2(csum*N.x*(1.0-N.z),csum*N.y*(1.0-N.z))*0.01,dotNL+time*0.002)*40.0, N) * 0.5 * (0.5 + 0.5 * cos(float(i) / float(count) * 3.1415926 * 4.0 + time * 4.0)) * w;\n\t\twsum += w;\n\t\t\n\t\t\n\t}\n\n    float sunspot = pow(smoothstep(0.00,0.002,spots(uv)),3.0)*0.9+0.1;\n    float sunspot1 = pow(smoothstep(0.005,0.01,spots(uv)),3.0)*0.5+0.5;\n    \n \tO = vec4(1.0);\n\n    O.rgb = vec3(pow((csum/wsum)*1.0,1.2)*1.6);\n    O.rgb *= sunspot1;\n    O.rgb *= sunspot;\n    O.rgb /= pow(fbm(vec3(uv,dotNL+iTime*0.001)*80.0, N)*1.0,1.6)*0.9+0.1;\n\n    O.rgb *= limbDarkening3(sky)*sunColor*exposure;  \n\n    \n\n    O *= smoothstep(0.,3./R.y,1.-l); \n    O.rgb = pow(O.rgb,vec3(1.0/gamma));\n}\n","name":"Image","description":"","type":"image"}]}