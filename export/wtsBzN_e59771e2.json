{"ver":"0.1","info":{"id":"wtsBzN","date":"1596349214","viewed":83,"name":"Signed Distance Fun","username":"yungdaveboi","description":"Book of Shaders, Inigo Quilez","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fbm","practice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec2 squareImaginary(vec2 number){\n\treturn vec2(\n\t\tpow(number.x,2.)-pow(number.y,2.),\n\t\t2.*number.x*number.y\n\t);\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec3 gencolor() {\n    float t1 = sin(iTime) / 2. + 1.;\n    float a = t1*t1;\n    float b = (t1 + t1) / 2.;\n    float c = a * b;\n    return vec3(a * .5, b * .5, c);\n}\n\nfloat distanceSquared(in vec2 x, in vec2 y) {\n    return dot(x-y, x-y);\n}\n\nfloat iterate(vec2 c, vec2 trap)\n{\n    int maxIterations = 50;\n    float dist = 1e20;\n    vec2 z = vec2( 0.0 );\n    for( int i=0; i< 50; i++ )\n    {\n        z = squareImaginary(squareImaginary(z)) + c;\n        if( length(z) > 2.0 ) return 0.0;\n        dist = min(dist, distanceSquared(z, trap));\n    }\n    \n    return (sqrt(dist) * 2.);\n}\n\nvec2 rot2d(vec2 pt, float r) {\n    return mat2(cos(r), sin(r), -sin(r), cos(r)) * pt;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n    // Remap the space to -1. to 1.\n    st = st *4.-1.;\n    vec2 st2 = rot2d(st, cos(iTime * .05) * 5.);\n    st = rot2d(st, sin(iTime * .05) * 5.);\n    // Make the distance field\n  \td = length( abs(st)-.3 + sin(iTime * .05) + 1. );\n    float alpha = fbm(st * 3.0);\n    d = mix(alpha, d, abs(sin(iTime / 5.)));\n    vec2 itp = vec2(sin(iTime / 1.75));\n    itp.y = abs(itp.y);\n    itp.x = abs(cos(itp.y));\n    itp = itp / 2.;\n    vec3 c = gencolor();\n    vec2 fbm_trap = vec2(.5, 2.)*(sin(1.5*iTime));\n    float d_field = fract(d*6.0);\n    float st2x = st2.x / 4.;\n    float st2y = st2.y / 4.;\n    st2 = vec2(st2x, st2y);\n    float frac_d = iterate(st2, vec2(d));\n    vec3 t_c = vec3((d_field * frac_d * c) + (1.-frac_d) * d_field * c * .75);\n    fragColor = vec4(t_c, 1.0);\n}","name":"Image","description":"","type":"image"}]}