{"ver":"0.1","info":{"id":"msGcDh","date":"1696053611","viewed":39,"name":"2D OBB of Ellipse from quadratic","username":"Kosmokleaner2","description":"Given a rotated ellipse in quadratic form\nthis computes a unrotated ellipse and angle\nOBB: oriented bounding box\n\nleft: angle based\nright: vector based\n\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","ellipse","boundingbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * vec2(0.25f, 0.5f)) / iResolution.y;\n    vec2 p = (uv) * 5.0f;\n    bool right = fragCoord.x > iResolution.x * 0.5f;\n    if(right)\n        p.x -= 4.5f;\n    \n    float a=3.0f, c=1.0f, b = 1.5f * sin(iTime* 2.1);\n    \n    // rotation angle\n    float angle = 0.5f * atan((b * 2.0f) / (a - c));\n    \n    // page 381 in Stoecker 3rd edition (Deutsch)\n    // implicit (rotated) ellipse defined as \n    // a * x*x + 2 * b * x*y + c * y * y = 1\n\n    // unrotated\n    // r0 * x*x + r1 * y * y = 1\n    \n    // optimized\n    // (a + c +/- sqrt((a-c)*(a-c) + 4.0f * b*b)) * 0.5f;\n    float baseHalf  = (a + c) * 0.5f;\n    float rootHalf = 0.5f * sqrt((a-c)*(a-c) + 4.0f * b*b);\n    float rx = inversesqrt(baseHalf + rootHalf);\n    float ry = inversesqrt(baseHalf - rootHalf);\n        \n    // left: from angle\n    vec2 axis0 = normalize(vec2(cos(angle), sin(angle)));\n\n    // not from angle\n    if(right)\n    {\n        vec2 k = vec2(a - c, 2.0f * b);\n\n        // half vector, should be faster than atan()\n//        axis0 = normalize(k + vec2(length(k), 0));\n        axis0 = normalize(k + vec2(length(k), 0));\n    }\n\n    vec2 axis1 = normalize(vec2(axis0.y, -axis0.x));\n\n\n    float d = 1.0f - sqrt(a * p.x * p.x + 2.0f * b * p.x * p.y + c * p.y * p.y);\n    d = clamp(d, 0.0, 1.0);\n    \n    fragColor = vec4(d,d,d,1.0);\n\n    if(length(p - axis0 * rx) < 0.1f)\n      fragColor = vec4(0.0,0.7,0.0,0.0);\n    if(length(p - axis1 * ry) < 0.1f)\n      fragColor = vec4(0.7,0.0,0.0,0.0);\n      \n    vec2 rotP = vec2(dot(axis0, p), dot(axis1, p));\n\n    if(abs(rotP.x) > rx || abs(rotP.y) > ry)\n      fragColor += vec4(0.0,0.2,0.0,0.0);\n}\n","name":"Image","description":"","type":"image"}]}