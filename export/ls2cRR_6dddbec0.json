{"ver":"0.1","info":{"id":"ls2cRR","date":"1490693042","viewed":118,"name":"Smoke sphere ivpodvi","username":"ivpodvi","description":"perspective smoke sphere","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perspectivesmokesphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Projection mx params\n#define fovY 1.5\n#define near 0.01\n#define far 10.0\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n// Projection mx\nmat4 getProjection(float asp)\n{\n\tconst float tanHalfFovy = tan(fovY * 0.5);\n\tmat4 projMx = mat4(1.0 / (tanHalfFovy * asp), 0.0, 0.0, 0.0,\n                \t 0.0, 1.0 / tanHalfFovy, 0.0, 0.0,\n                \t 0.0, 0.0, -(far + near) / (far - near), -1.0,\n                \t 0.0, 0.0, -2.0 * far * near / (far - near), 0.0);\n\n    return projMx;\n}\n// View mx\nmat4 viewMx = mat4(1.0, 0.0, 0.0,0.,\n                  0.0, 1.0, 0.0, 0.0,\n                  0.0, 0.0, 1.0, 0.0,\n                  0.0, 0.0, 0.0, 1.0);\n\n// sphere\n#define sphPos vec3(0.0, 0.0, -3.0)\n#define sphR 0.5\n#define PI 3.1415\n#define TwoPI 2.0 * PI\n\nconst float maxDepth = 4.7;\nconst int stepsNum = 200;\n\nfloat getFog(vec3 coord)\n{\n    float value = 0.0;\n    vec4 tex = 1.0 - texture(iChannel0, coord.xy);\n\n    value = tex.r + sin(((2.0 * tex.r - 1.0) + iTime * 0.3) * TwoPI) * 0.5;\n\n    return value * 0.5;\n}\n\nfloat intersectSphere(Ray ray, float angle)\n{\n    vec3 sPos = sphPos;\n    sPos.x += sin(iTime * 0.3 + angle);\n    sPos.y += cos(iTime * 0.3 + angle);\n    sPos.z += sin(iTime + angle);\n\n    float stepVal = maxDepth / float(stepsNum);\n    vec3 cur = ray.origin;\n    float value = 0.0;\n    for (int i = 0; i < stepsNum; ++i)\n    {\n        cur += ray.direction * stepVal;\n\t\tfloat d = distance(cur, sPos);\n\n        if (d > sphR)\n            continue;\n\n        float localValue = (stepVal * float(stepsNum - i) / maxDepth) * 0.1;\n        float ft = getFog(cur - sPos);\n        value += localValue * ft;\n    }\n\n    return clamp(1.0 - value, 0.0, 1.0);\n}\n\nvec3 getPixelForBox(Ray ray)\n{\n    float r = 1.0 - intersectSphere(ray, 0.0);\n    float g = 1.0 - intersectSphere(ray, TwoPI * 0.33); // Not optimal\n    float b = 1.0 - intersectSphere(ray, TwoPI * 0.66); // Not optimal\n\n    return vec3(r, g, b);\n}\n\nvec4 getPixelColor(Ray ray)\n{\n    vec4 baseColor = vec4(0.0, 0.0, 0.0, 0.0);\n    baseColor += vec4(getPixelForBox(ray), 0.0);\n\n    return baseColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    mat4 projMx = getProjection(iResolution.y / iResolution.x);\n    mat4 projInv = inverse(projMx);\n    mat4 viewInv = inverse(viewMx);\n\n    Ray ray;\n    ray.origin = (vec4(0.0, 0.0, 0.0, 1.0) * viewInv).xyz;\n    ray.direction = (vec4(uv, 1.0, 0.0) * projMx).xyz;\n\n    vec4 color = getPixelColor(ray);\n//    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}