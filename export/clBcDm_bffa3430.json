{"ver":"0.1","info":{"id":"clBcDm","date":"1691838491","viewed":37,"name":"Bicubic interpolation noise","username":"bailesdtd","description":"Good learning experience for me, I tried optimizing by only computing the values and derivatives once but not sure what else can be done.\nFeedback welcome.\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float i2f(uint i){\n    return float(i) * (1.0/float(0xffffffffu));\n}\n\nfloat hash(uvec2 v) {\n    v = v * 1664525u + 1013904223u;\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n    v = v ^ (v>>16u);\n    v.x += v.y * 1664525u;\n    return i2f(v.x);\n}\n\nfloat getNoise(float[36] noiseValues, ivec2 i){\n    return noiseValues[6*i.x+i.y+14];\n}\n\nvec2 getSobel(vec2[16] sobelValues, ivec2 i){\n    return sobelValues[4*i.x+i.y+5];\n}\n\nfloat getMpd(float[4] mpdValues, ivec2 i){\n    return mpdValues[2*i.x+i.y];\n}\n\nfloat bicubic(vec2 v){\n    uvec2 p = uvec2(ivec2(floor(v)));\n    vec2 f = fract(v);\n    \n    float noise[36];\n    for(int i=-2;i<4;i++){\n        for(int j=-2;j<4;j++){\n            int index = 6*i+j+14;\n            noise[index] = hash(p+uvec2(i,j));\n        }\n    }\n    \n    mat3 kernel = mat3(\n        1,2,1,\n        0,0,0,\n        -1,-2,-1\n    );\n    \n    vec2 sobel[16];\n    for(int i=-1;i<3;i++){\n        for(int j=-1;j<3;j++){\n            int index = 4*i+j+5;\n            vec2 s = vec2(0,0);\n            for(int k=-1;k<2;k++){\n                for(int l=-1;l<2;l++){\n                    float n = getNoise(noise,ivec2(i+k,j+l));\n                    s += vec2(kernel[k+1][l+1] * n,\n                              kernel[l+1][k+1] * n);\n                }\n            }\n            sobel[index] = s;\n        }\n    }\n    \n    float mpd[4];\n    for(int i=0;i<2;i++){\n        for(int j=0;j<2;j++){\n            int index = 2 * i + j;\n            float m = 0.0;\n            for(int k=-1;k<2;k++){\n                for(int l=-1;l<2;l++){\n                    float dx = getSobel(sobel, ivec2(i+k,j+l)).x;\n                    m += kernel[l+1][k+1] * dx;\n                }\n            }\n            mpd[index] = m;\n        }\n    }\n    \n    mat4 C = mat4(\n            1,  0, -3,  2,\n            0,  0,  3, -2,\n            0,  1, -2,  1,\n            0,  0, -1,  1\n       );\n       \n    mat4x4 M = mat4(\n        getNoise(noise, ivec2(0,0)),   getNoise(noise, ivec2(1,0)),   getSobel(sobel, ivec2(0,0)).x, getSobel(sobel, ivec2(1,0)).x,\n        getNoise(noise, ivec2(0,1)),   getNoise(noise, ivec2(1,1)),   getSobel(sobel, ivec2(0,1)).x, getSobel(sobel, ivec2(1,1)).x,\n        getSobel(sobel, ivec2(0,0)).y, getSobel(sobel, ivec2(1,0)).y, getMpd(mpd,     ivec2(0,0)),   getMpd(mpd,     ivec2(1,0)),\n        getSobel(sobel, ivec2(0,1)).y, getSobel(sobel, ivec2(1,1)).y, getMpd(mpd,     ivec2(0,1)),   getMpd(mpd,     ivec2(1,1))\n    );\n    \n    mat4 a = C * M * transpose(C);\n    \n    float P = 0.0;\n    \n    for(int i=0; i<4;i++){  \n        for(int j=0; j<4;j++){\n            P += a[j][i] * pow(f.x, float(i))*pow(f.y,float(j));\n        } \n    }\n    \n    return P;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    float r = 0.0;\n    float s = 0.0;\n    float r2 = hash(uvec2(ivec2(floor((uv+iTime*0.1)*4.0))));\n    for(int i=1;i<2;i++){\n        float scale = pow(2.0, float(i+1));\n        s += 1.0/scale;\n        r += bicubic((uv+iTime*0.1)*scale)*(1.0/scale);\n    }\n    r*= 1.0/s;\n    float t = smoothstep(0.0,0.01,-uv.x);\n    float R = mix(r,r2,t);\n    vec3 col = mix(vec3(0,0,0), vec3(0.706,0.976,0.996), R);\n    fragColor = vec4(col,1.0);\n    \n}","name":"Image","description":"","type":"image"}]}