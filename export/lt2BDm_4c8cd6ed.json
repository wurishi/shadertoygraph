{"ver":"0.1","info":{"id":"lt2BDm","date":"1516137557","viewed":290,"name":"Spectrumizer","username":"AntoineC","description":"Spectrumize your latest creation! Enjoy the ZX Spectrum fantastic 8 color palette, state of the art 1-bit ordered dithering and wonderful color block artefacts!","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["spectrum","effect","zx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----------------------------------------------------------------------------------------\n//\t\"Spectrumizer\" by Antoine Clappier - January 2018\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n\n// Copy your shader in Buf A!\n\n// Works pretty well with: \"Fractal Land\" (https://www.shadertoy.com/view/XsBXWt)\n\n\n\n\n#define bitmapLoad 4.0\n#define colorLoad  1.0\n#define hold       2.0\n\n\n#define ZxToRgb(c) vec3(floor(mod((c),4.0)/2.0), floor((c)/4.0), mod((c),2.))\n#define Tresh(a,b) bayer = mix(bayer, float(b), step(float(a), nn))\n\n\nfloat Bayer44(vec2 fragCoord)\n{\n    // Pixel matrix index:\n    vec2 pix = mod(floor(fragCoord), 4.0);\n    float nn = pix.x + 4.0*pix.y;\n      \n    // Bayer Threshold Matrix:\n    float bayer;\n    bayer = 1.;   Tresh( 1, 9); Tresh( 2, 3); Tresh( 3,11);\n    Tresh( 4,13); Tresh( 5, 5); Tresh( 6,15); Tresh( 7, 7);\n    Tresh( 8, 4); Tresh( 9,12); Tresh(10, 2); Tresh(11,10);\n    Tresh(12,16); Tresh(13, 8); Tresh(14,14); Tresh(15, 6);\n    bayer /= 17.0;\n    \n    return bayer;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pix = floor(fragCoord);\n    vec2 block = 8.0*floor(pix/8.0);\n    \n    \n    // Get 8x8 block mean color:\n    vec3 mean = texture(iChannel0, uv).rgb;\n    \n    \n    // Get the two ZX Spectrum Colors closest to the mean color:\n    vec3 paper = vec3(0.0);\n    vec3 ink   = vec3(0.0);\n\n    float minDistance = 1000.0;\n    for(float i=0.0; i<8.0; i++)\n    {\n        for(float j=0.0; j<8.0; j++)\n        {\n            if(j > i)\n            {\n                // Distance between mean color and the Paper/Ink\n                // line in RGB cube:\n                vec3 a = ZxToRgb(i);\n                vec3 b = ZxToRgb(j);\n                vec3 ab = b-a;\n                float dist = length(cross(mean-a, ab)) / length(ab);\n                \n                if(dist < minDistance)\n                {\n                    minDistance = dist;\n                    paper = b;\n                    ink   = a;\n                }\n            }\n        }\n    }\n\n    \n    // Project original color on Paper/Ink segment:\n    vec3 source = texture(iChannel1, uv).rgb;\n    vec3 ip = paper  - ink;\n    vec3 ic = source - ink;\n    float s = dot(ic, ip) / dot(ip, ip);\n    s = clamp(s, 0.0, 1.0);\n    \n    \n    // Dithering:\n    float threshold = Bayer44(fragCoord);\n    vec3 color  = mix(    paper,       ink, vec3(step(s, threshold)));\n    vec3 bitmap = mix(vec3(1.0), vec3(0.0), vec3(step(s, threshold)));\n    \n    \n    // Progressive rendering:\n    float t = mod(exp(iTime/3.8)+iTime-1.0, bitmapLoad + colorLoad + hold);\n\n    vec3 final;\n    if(t < bitmapLoad)\n    {\n        // Bitmap progressive \"load\":\n        float y = 192.0*(1.0-uv.y);\n        y = 64.0*floor(y/64.0) + 8.0*mod(mod(y, 64.0), 8.0);\n        final = mix(bitmap, vec3(1.0), step(mod(192.0*t/bitmapLoad, 192.0), y));\n    }\n    else if(t < bitmapLoad + colorLoad)\n    {\n        // Color block progressive \"load\":\n        vec2 res8 = floor(iResolution.xy/8.0);\n        block /= 8.0;\n\t    float blockCount = res8.x * res8.y;\n        float bxy = res8.x*(res8.y-1.0) + block.x - res8.x*block.y;\n    \tfinal = mix(color, bitmap, step(mod(blockCount*t/colorLoad, blockCount), bxy));\n    }\n    else\n    {\n        final = color;\n    }\n\n    // After some time, disable progressive rendering: \n    fragColor = vec4(mix(final, color, 0.3*(iTime-15.0)), 0.0);\n    \n    \n    // Show original:\n    if(iMouse.z > 1.0)\n    {\n    \tfragColor = texture(iChannel1, uv);\n    }\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Copy your shader here!\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\tfragColor = texture(iChannel0, uv); \n}\n\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define bitmapLoad 4.0\n#define colorLoad  1.0\n#define hold       2.0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec4 buffer  = texture(iChannel1, uv);\n    vec4 current = pow(texture(iChannel0, uv), vec4(1.4));\n    \n    // Hold image in buffer:\n    float t = mod(exp(iTime/3.8)+iTime-1.0, bitmapLoad + colorLoad + hold);\n    fragColor = (t < buffer.a) || (iTime < 0.1) || (iTime > 24.0) ? current : buffer;\n    fragColor.a = t;\n}\n\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mean color across a block row:\n    vec2 pix = fragCoord;\n    float x8 = 8.0*floor(pix.x/8.0);\n\n    vec4 sum;\n    sum =  texture(iChannel0, vec2(   x8, pix.y)/iResolution.xy);\n    sum += texture(iChannel0, vec2(1.+x8, pix.y)/iResolution.xy);\n    sum += texture(iChannel0, vec2(2.+x8, pix.y)/iResolution.xy);\n    sum += texture(iChannel0, vec2(3.+x8, pix.y)/iResolution.xy);\n    sum += texture(iChannel0, vec2(4.+x8, pix.y)/iResolution.xy);\n    sum += texture(iChannel0, vec2(5.+x8, pix.y)/iResolution.xy);\n    sum += texture(iChannel0, vec2(6.+x8, pix.y)/iResolution.xy);\n    sum += texture(iChannel0, vec2(7.+x8, pix.y)/iResolution.xy);\n  \n    fragColor = sum/8.0;\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mean color across a block column:\n    vec2 pix = fragCoord;\n    float y8 = 8.0*floor(pix.y/8.0);\n    \n    vec4 sum;\n    sum =  texture(iChannel0, vec2(pix.x,    y8)/iResolution.xy);\n    sum += texture(iChannel0, vec2(pix.x, 1.+y8)/iResolution.xy);\n    sum += texture(iChannel0, vec2(pix.x, 2.+y8)/iResolution.xy);\n    sum += texture(iChannel0, vec2(pix.x, 3.+y8)/iResolution.xy);\n    sum += texture(iChannel0, vec2(pix.x, 4.+y8)/iResolution.xy);\n    sum += texture(iChannel0, vec2(pix.x, 5.+y8)/iResolution.xy);\n    sum += texture(iChannel0, vec2(pix.x, 6.+y8)/iResolution.xy);\n    sum += texture(iChannel0, vec2(pix.x, 7.+y8)/iResolution.xy);\n    \n    fragColor = sum/8.0;\n}\n","name":"Buf D","description":"","type":"buffer"}]}