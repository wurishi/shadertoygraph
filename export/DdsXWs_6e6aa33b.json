{"ver":"0.1","info":{"id":"DdsXWs","date":"1669844454","viewed":48,"name":"Alix mountains","username":"Jaqui","description":"super","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["educ"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int Steps = 1000;\nconst float Epsilon = 0.01; // Marching epsilon\nconst float T=0.5;\n\nconst float hauteurEau = 1.95;\n\nconst float rA=1.0; // Minimum ray marching distance from origin\nconst float rB=50.0; // Maximum\n\n// Changement de coordonn√©es\n\nfloat atan2(float x, float y){\n    return 2.*atan(y/(sqrt(x*x+y*y)+x));\n}\n\nvec3 toPolarCoordinates(vec3 v){\n    // vec3(x, y, z) to vec3 (r, theta, phi)\n    float r = length(v);\n    float theta = acos(v.y/r);\n    float phi = atan2(v.x, v.z);\n    return vec3(r, phi, theta);\n}\n\n// Transforms\nvec3 rotateY(vec3 p, float a)\n{\n   return vec3(cos(a)*p.x+sin(a)*p.z, p.y, cos(a)*p.z-sin(a)*p.x); \n}\n\n// Noise functions\n\nvec2 hash( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n}\n\nfloat ridgedNoise(in vec2 p){\n    return 2.*(0.5-abs(0.5-noise(p)));\n}\n\nfloat turbulence(in vec2 p, in float amplitude, in float fbase, in float attenuation, in int noctave) {\n    int i;\n    float res = .0;\n    float f = fbase;\n    for (i=0;i<noctave;i++) {\n        res = res+amplitude*ridgedNoise(f*p);\n        amplitude = amplitude*attenuation;\n        f = f*2.;\n    }\n    return res;\n}\n\n// End noise functions\n\n// Smooth falloff function\n// r : small radius\n// R : Large radius\nfloat falloff( float r, float R )\n{\n   float x = clamp(r/R,0.0,1.0);\n   float y = (1.0-x*x);\n   return y*y*y;\n}\n\n// Primitive functions\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : large radius\nfloat point(vec3 p, vec3 c, float e,float R)\n{\n   return e*falloff(length(p-c),R);\n}\n\nfloat clouds(vec3 p, float h){\n    return -(abs(p.y-h)+turbulence(p.xz+iTime, 5., 0.01, 0.5, 10));\n}\n\nfloat mountainHeight(vec3 p){\n    return turbulence(p.xz, 1., 0.07, 0.5, 10)+1.5;\n}\n\nfloat posMod(float a, float b){\n    // Always positive modulo\n    return mod(mod(a, b)+b, b);\n}\n\nvec3 toTreeCoordinates(vec3 p, float period){\n    return vec3(posMod(p.x, period), 0.4*(p.y+mountainHeight(floor(p/period)*period+0.5*period))+.5, posMod(p.z, period));\n}\n\nfloat tree(vec3 p){\n    float period = 1.;\n    p = toTreeCoordinates(p, period);\n    float radius = .08;\n    return radius-distance(vec3(period/2.), p)+turbulence(toPolarCoordinates(vec3(0.5)-p).yz, 0.02,2., 0.5, 1);\n}\n\n\n// Blending\n// a : field function of left sub-tree\n// b : field function of right sub-tree\nfloat Blend(float a,float b)\n{\n   return a+b;\n}\n\n// Potential field of the object\n// p : point\nfloat object(vec3 p)\n{\n   //return max(-p.y-turbulence(p.xz, 1., 0.07, 0.5, 10)-1.5, -p.y-turbulence(p.xz, 0.01, 2., 0.5, 3)-hauteurEau-0.02); // Version avec vagues sur l'eau\n   return max(max(-p.y-mountainHeight(p), -p.y-hauteurEau),tree(p));\n   //return max(-p.y-mountainHeight(p), -p.y-hauteurEau);\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p )\n{\n   float eps = 0.0001;\n   vec3 n;\n   float v = object(p);\n   n.x = object( vec3(p.x+eps, p.y, p.z) ) - v;\n   n.y = object( vec3(p.x, p.y+eps, p.z) ) - v;\n   n.z = object( vec3(p.x, p.y, p.z+eps) ) - v;\n   return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o, vec3 u, out bool h,out int s)\n{\n   h = false;\n\n   // Don't start at the origin\n   // instead move a little bit forward\n   float t=rA;\n\n   for(int i=0; i<Steps; i++)\n   {\n      s=i;\n      vec3 p = o+t*u;\n      float v = object(p);\n      // Hit object (1) \n      if (v > 0.0)\n      {\n         s=i;\n         h = true;\n         break;\n      }\n      // Move along ray\n      t += max(Epsilon, -v/5.);  \n\n      // Escape marched far away\n      if (t>rB)\n      {\n         break;\n      }\n   }\n   return t;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n    vec3 skyPos = toPolarCoordinates(rd);\n   // Day\n   vec3 daySky = mix(vec3(0.8, 0.8, 0.9), vec3(0.6, 0.9, 1.0), rd.y*1.0+0.25);\n   vec3 dayClouds = vec3(.95, .95, .95);\n   daySky = mix(daySky, dayClouds, clamp(turbulence(rd.xy+iTime/100., 0.5, 3., 0.5, 5), 0., 1.)); // Clouds\n   \n   // Night\n   vec3 stars = vec3(1., 1., 1.);\n   vec3 nightClouds = vec3(.15, .15, .25);\n   vec3 nightSky = mix(vec3(0.1, 0.1, 0.3), vec3(0., 0., 0.), rd.y*1.0+0.25);\n   nightSky = mix(vec3(0.5, 0.2, .2), nightSky, (rd.y+.3*cos((iTime+2.5)/5.)*rd.x)*10.0+0.5); //  DayLight (start/end)\n   nightSky = mix(nightSky, stars, step(noise(skyPos.yz*50.+(iTime*vec2(1., -1.))), -0.80)); // Stars\n   nightSky = mix(nightSky, nightClouds, clamp(turbulence(skyPos.yz/2.+iTime/100., 0.5, 3., 0.5, 5), 0., 1.)); // Clouds\n   \n   \n   return mix(daySky, nightSky, 0.5+0.5*sin(iTime/5.));\n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 ShadeNoReflexion(vec3 p, vec3 n, int s)\n{\n   // point light (day)\n   vec3 lightPos = vec3(100.*cos(iTime/5.),100.*sin(iTime/5.),0.);\n   //const vec3 dayLightColor = vec3(0.8, 0.8, 0.7);\n   vec3 dayLightColor = vec3(0.8, 0.8, 0.7);\n   \n   // Night\n   const vec3 nightLightColor = vec3(.1, .1, .25);\n   \n   const vec3 morningEveningLightColor = vec3(.8, .2, .2);\n   \n   vec3 normalLightColor = mix(dayLightColor, nightLightColor, 0.5+0.5*sin(iTime/5.));\n   \n   vec3 lightColor = mix(normalLightColor, morningEveningLightColor, smoothstep(0., 1., 1.2*cos(iTime/5.)-0.2)+smoothstep(0., 1., -1.2*cos(iTime/5.)-0.2));\n   \n   vec3 l = normalize(lightPos - p);\n\n   // Not even Phong shading, use weighted cosine instead for smooth transitions\n   float diff = 0.5*(1.0+dot(n, l));\n    \n   // Snow and grass \n   float ny = (p.y+0.5)/0.5;\n   ny = clamp(ny+turbulence(p.xz, 0.2, 3., 0.5, 5), 0., 1.);\n   vec3 color = mix(vec3(0.1, 0.3, 0.1), vec3(1., 1., 1.), ny);\n   \n   // Rocks\n   if(p.y<=15.){\n       color = mix(vec3(.3, .3, .3), color, clamp(turbulence(p.xz, 3., .75, 0.2, 3)+4., 0., 1.));\n   }\n   \n   // Sand\n   ny = (p.y+hauteurEau)/0.2;\n   ny = clamp(ny+turbulence(p.xz, 0.3, 5., 0.5, 5), 0., 1.);\n   color = mix(vec3(0.7, 0.6, 0.2), color, ny);\n   \n   //color *= vec3(clamp(turbulence(p.xz+iTime, 0.5, 0.1, 0.5, 3)+0.5, 0., 1.));\n   \n   //color *= vec3((sin(iTime/5.)+2.)/3.);\n   \n   // Altitude\n   if (mod(p.y, 0.5) >= 0. && mod(p.y, 0.5) <= 0.05){\n       //color -= vec3(.25, 0.5, 0.5);\n   }\n   \n   // Tree\n   \n   if(tree(p)>=-0.001){\n      color = vec3(.3, .5, .1);\n   }\n\n   vec3 c =  0.5*color+0.5*diff*lightColor;\n   float fog = 0.4*float(s)/(float(Steps-1));\n   c = (1.0-fog)*c+fog*vec3(1.0,1.0,1.0);\n   \n   return c;\n}\n\nvec3 reflexionColor(vec3 ro, vec3 rd){\n    // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n\n   float t = Trace(ro, rd, hit,s);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = ShadeNoReflexion(pos, n, s);\n   }\n   return rgb;\n}\n\nvec3 ShadeReflexion(vec3 p, vec3 n, vec3 rd, int s){\n    vec3 c = ShadeNoReflexion(p, n, s);\n    \n    if(p.y<=-hauteurEau){\n       vec3 reflectedRay = reflect(rd, n);\n       vec3 waterNoise = mix(turbulence(p.xz, 0.05, 3., 0.3, 5)*vec3(1., 1., 1.), turbulence(p.xz+vec2(1, 1), 0.05, 3., 0.3, 5)*vec3(1., 1., 1.),sin(2.*iTime)*0.5+0.5);\n       reflectedRay += waterNoise;\n       c = (vec3(0.7, 0.7, 0.9)+waterNoise)*reflexionColor(p, reflectedRay);\n       // c = texture(iChannel0, vec2(mod(p.x/10., 1.), mod(p.z/10.*(iChannelResolution[0].x/iChannelResolution[0].y), 1.))).xyz;\n    }\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 pixel = (gl_FragCoord.xy / iResolution.xy)*2.0-1.0;\n\n   // compute ray origin and direction\n   float asp = iResolution.x / iResolution.y;\n   vec3 rd = vec3(asp*pixel.x, pixel.y, -4.0);\n   vec3 ro = vec3(0.0, 0.0, 15.0);\n\n   vec2 mouse = iMouse.xy / iResolution.xy;\n   float a=-iTime*0.25;\n   rd.z = rd.z+2.0*mouse.y;\n   rd = normalize(rd);\n   //ro = rotateY(ro, a);\n   //rd = rotateY(rd, a);\n   rd = rotateY(rd, -91.43*0.25);\n\n   // Trace ray\n   bool hit;\n\n   // Number of steps\n   int s;\n\n   float t = Trace(ro, rd, hit,s);\n   vec3 pos=ro+t*rd;\n   // Shade background\n   vec3 rgb = background(rd);\n\n   if (hit)\n   {\n      // Compute normal\n      vec3 n = ObjectNormal(pos);\n\n      // Shade object with light\n      rgb = ShadeReflexion(pos, n, rd, s);\n      \n   }\n\n   fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}