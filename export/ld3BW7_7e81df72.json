{"ver":"0.1","info":{"id":"ld3BW7","date":"1539367295","viewed":458,"name":"3D Voronoi","username":"Crow","description":"references: https://www.shadertoy.com/view/MscSWj\nhttps://www.shadertoy.com/view/MdtXDs\n《UnityShader入门精要》","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 0.2\n#define FARCLIP 20.0\n\nfloat CheckEdge(vec4 norz1, vec4 norz2)\n{\n    vec2 diffNor = abs(norz1.xy - norz2.xy);\n    return step(diffNor.x + diffNor.y, 0.1) * step(abs(norz1.z - norz2.z) * FARCLIP, 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 norz = texture(iChannel0, uv);\n    vec3 col = vec3(1.0);\n    if(norz.a < 2.0)\n    {\n        vec2 offset = vec2(1.0, -1.0) * RADIUS / iResolution.xy;\n    \tfloat edge = 1.0;\n    \tedge *= CheckEdge(texture(iChannel0, uv + offset.xx), texture(iChannel0, uv + offset.yy));\n    \tedge *= CheckEdge(texture(iChannel0, uv + offset.xy), texture(iChannel0, uv + offset.yx));\n\n        col = vec3(0.0);\n        if(edge > 0.5)\n        {\n            float shadow = floor(norz.a);\n\t\t\tfloat mat = norz.a - shadow;\n            \n            col = vec3(0.6, 0.7, 0.9);\n            if(mat > 0.0)\n            {\n                mat = max(1.0 - mat, 0.0) * 1.2;\n                col = mix(mix(vec3(0.3, 0.3, 0.8), vec3(0.3, 0.8, 0.3), (mat - 0.333) * 3.0), vec3(0.8, 0.3, 0.3), (mat - 0.667) * 3.0) ;\n            }\n            col *= mix(1.0, 0.5, shadow);\n        }\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1416\n#define HALFHEIGHT 4.5\n#define FARCLIP 20.0\n#define SCALE 1.5\n#define LIGHTPOINT vec3(4.5, 0.0, 1.0)\n\n//---rotate-------------------------------------------------\nmat3 RotX(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, ca, -sa,\n                0.0, sa, ca);\n}\n\nmat3 RotY(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n\treturn mat3(ca, 0.0, -sa,\n                0.0, 1.0, 0.0,\n                sa, 0.0, ca);\n}\n\nmat3 RotZ(float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return mat3(ca, -sa, 0.0,\n                sa, ca, 0.0,\n                0.0, 0.0, 1.0);\n}\n//----------------------------------------------------\n\nstruct Ray \n{\n    vec3 ori;\n\tvec3 dir;\n};\n\nstruct Hit \n{\n\tfloat dis;\n    vec3 nor;\n\tfloat mat;\n};\n    \nHit CreateHit(Ray ray)\n{\n    Hit hit;\n    hit.dis = FARCLIP;\n    hit.nor = ray.dir;\n    hit.mat = -1.0;\n    return hit;\n}\n\nvoid SetHit(inout Hit hit, float dis, vec3 nor, float mat)\n{\n    hit.dis = dis;\n    hit.nor = nor;\n    hit.mat = mat;\n}\n\nHit IntersectPlane(Ray ray, vec3 pos, vec3 nor, float mat)\n{\n    Hit hit = CreateHit(ray);\n    float dn= dot(ray.dir, nor);\n    if (dn > 0.0)\n    \treturn hit;\n    \n    float t = dot(pos - ray.ori, nor) / dn;\n    if(t > 0.0)\n        SetHit(hit, t, nor, mat);\n\treturn hit;\n}\n\nHit IntersectCube(Ray ray, vec3 minPos, vec3 maxPos, float mat, out float hitFar)\n{\n    Hit hit = CreateHit(ray);\n    vec3 tMin = (minPos - ray.ori) / ray.dir;\n    vec3 tMax = (maxPos - ray.ori) / ray.dir;\n    vec3 t1 = min(tMin, tMax);      \n    vec3 t2 = max(tMin, tMax);\n    float hitNear = max(max(t1.x, t1.y), t1.z);\n    hitFar = min(min(t2.x, t2.y), t2.z);\n    if (hitFar < hitNear || hitFar < 0.0)\n        return hit;\n    \n    float hitDis = mix(hitFar, hitNear, step(0.0, hitNear));\n    vec3 hitPos = ray.ori + ray.dir * hitDis;\n    vec3 hitNor = mix(vec3(-1.0), vec3(0.0), step(vec3(0.0001), abs(hitPos - minPos)));\n    hitNor = mix(vec3(1.0), hitNor, step(vec3(0.0001), abs(hitPos - maxPos)));    \n    SetHit(hit, hitDis, hitNor, mat);\n    return hit;\n}\n\nHit IntersectSphere(Ray ray, vec3 pos, float radius, float mat)\n{\n    Hit hit = CreateHit(ray);\n    vec3 oc = pos - ray.ori;\n    float proj = dot(oc, ray.dir);\n    float disSqu = radius * radius - (dot(oc, oc) - proj * proj);\n    if (disSqu < 0.0)\n        return hit;\n\n    float dis = sqrt(disSqu);\n    float hitFar = proj + dis;\n    if (hitFar < 0.0)\n        return hit;\n    \n    float hitNear = proj - dis;\n    float hitDis = mix(hitFar, hitNear, step(0.0, hitNear));\n    SetHit(hit, hitDis, normalize(ray.ori + ray.dir * hitDis - pos), mat);\n    return hit;    \n}\n\n//---voronoi-------------------------------------------------\nvec3 Rand3(vec3 v3)\n{\n \treturn texture(iChannel0, v3.xy * 42.51 + v3.yz * 25.31 + v3.zx * 92.96).xyz;\n}\n\nvec2 Voronoi(vec3 pos)\n{\n    pos /= SCALE;\n    vec3 p = floor(pos);\n    vec3 f = pos - p;\n    \n    vec2 dis = vec2(FARCLIP);\n    float mat = 0.0;\n    for(float x = -1.0; x <= 1.0; x++)\n    for(float y = -1.0; y <= 1.0; y++)\n    for(float z = -1.0; z <= 1.0; z++)\n    {\n        vec3 cell = vec3(x, y, z);\n        vec3 offset = Rand3(p + cell);\n        \n        vec3 r = cell - f + offset;\n        float l = dot(r, r);\n        \n        if(l < dis.x)\n        {\n            dis = vec2(l, dis.x);\n            mat = offset.x;\n        }\n        else if(l < dis.y)\n            dis.y = l;\n    }\n    \n    return vec2((dis.x - dis.y + mix(0.1, 0.5, texture(iChannel1, vec2(mat, 0.0)).r * 2.0)) * 0.25 * SCALE, mat);\n}\n\nvec3 GetVoronoiNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.001, 0.0);\n\tvec3 nor = vec3(Voronoi(pos + eps.xyy).x - Voronoi(pos - eps.xyy).x,\n                    Voronoi(pos + eps.yxy).x - Voronoi(pos - eps.yxy).x,\n                    Voronoi(pos + eps.yyx).x - Voronoi(pos - eps.yyx).x );\n    \n    return normalize(nor);\n}\n\nvec2 IntersectVoronoi(vec3 pos, vec3 dir, float maxDis)\n{\n    float mat = 0.0;\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = pos + dir * t;\n        vec2 dm = Voronoi(p);\n        t += dm.x;\n        if(dm.x < 0.0001)\n        {\n            mat = dm.y;\n            break;\n        } \n        else if(t > maxDis) \n            break;\n    }\n    return vec2(t, mat);\n}\n//----------------------------------------------------\n\nHit IntersectScene(Ray ray, float maxDis, float isShadow)\n{\n    float halfWidth = HALFHEIGHT * (iResolution.x / iResolution.y);\n    \n    Hit hit = IntersectPlane(ray, vec3(0.0, HALFHEIGHT, 0.0), vec3(0.0, -1.0, 0.0), 0.0);\n    Hit hit2 = IntersectPlane(ray, vec3(0.0, -HALFHEIGHT, 0.0), vec3(0.0, 1.0, 0.0), 0.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    hit2 = IntersectPlane(ray, vec3(halfWidth, 0.0, 0.0), vec3(-1.0, 0.0, 0.0), 0.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    hit2 = IntersectPlane(ray, vec3(-halfWidth, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 0.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    hit2 = IntersectPlane(ray, vec3(0.0, 0.0, 7.0), vec3(0.0, 0.0, -1.0), 0.0);\n    if (hit2.dis < hit.dis) hit = hit2;\n    \n    float hitFar;\n    vec3 boxPos = vec3(0.0, 0.0, 3.0);\n    mat3 rotMat = RotY(iTime) * RotX(PI * 0.25) * RotZ(PI * 0.25);\n    Ray rotRay;\n    rotRay.ori = (ray.ori - boxPos) * rotMat + boxPos;\n    rotRay.dir = ray.dir * rotMat;\n    hit2 = IntersectCube(rotRay, boxPos - vec3(2.5), boxPos + vec3(2.5), 0.0, hitFar);\n    if (hit2.dis < hit.dis)\n    {\n        vec3 rotPos = rotRay.ori + rotRay.dir * hit2.dis;\n        vec2 dm = IntersectVoronoi(rotPos, rotRay.dir, min(hitFar, maxDis) - hit2.dis);\n        if(dm.y > 0.0)\n        {\n            hit = hit2;\n            if(dm.x > 0.0)\n            {\n            \thit.dis += dm.x;\n                if(isShadow < 0.5)\n                    hit.nor = GetVoronoiNormal(rotPos + rotRay.dir * dm.x);\n            }\n            hit.nor *= inverse(rotMat);\n            hit.mat = dm.y;\n        }\n    }\n    \n    if(isShadow < 0.5)\n    {\n        hit2 = IntersectSphere(ray, LIGHTPOINT, 0.5, 3.0);\n        if (hit2.dis < hit.dis) hit = hit2;\n    }\n    \n    return hit;\n}\n\n//---render-------------------------------------------------\nfloat GetShadow(vec3 pos, vec3 nor)\n{\n    vec3 lightDir = LIGHTPOINT - pos;\n\tRay ray;\n    ray.dir =  normalize(lightDir);\n    ray.ori = pos + ray.dir * 0.001;\n    if(dot(nor, ray.dir) <= 0.0)\n        return 1.0;\n    \n    float maxDis = length(lightDir);\n    Hit hit = IntersectScene(ray, maxDis, 1.0);\n    if(hit.mat >= 0.0 && hit.dis <= maxDis)\n        return 1.0;\n    else\n        return 0.0;\n}\n\nvec4 Render(vec3 camPos, vec3 localViewDir, mat3 cam2worldMatrix)\n{\n    vec4 col;\n    Ray ray;\n    ray.ori = camPos;\n    ray.dir = cam2worldMatrix * localViewDir;\n    \n    Hit hit = IntersectScene(ray, FARCLIP, 0.0);\n\t\n    vec3 nor = inverse(cam2worldMatrix) * hit.nor;\n    nor.z *= -1.0;\n\n    float zDelta = localViewDir.z;\n    zDelta *= hit.dis / FARCLIP;\n    \n    float shadow = GetShadow(ray.ori + ray.dir * hit.dis, hit.nor);\n    \n    return vec4(nor.xy, zDelta, shadow + hit.mat);\n}\n//--------------------------------------------------------\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n    float ratio = iResolution.x / iResolution.y;\n\tp.x *= ratio;\n    \n    vec3 camPos = vec3(0.0, 0.0, -HALFHEIGHT * ratio);\n    vec3 camLookAt = vec3(0.0);\n    \n    mat3 cam2worldMatrix = SetCamera(camPos, camLookAt, 0.0);\n    \n    vec3 localViewDir = normalize(vec3(p.xy, 1.4143));\n    \n    fragColor = Render(camPos, localViewDir, cam2worldMatrix);\n}","name":"Buffer A","description":"","type":"buffer"}]}