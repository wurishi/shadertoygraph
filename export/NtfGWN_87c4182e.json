{"ver":"0.1","info":{"id":"NtfGWN","date":"1622057162","viewed":618,"name":"Sky raymarching","username":"lisyarus","description":"Single-scattering visualization of sky including Rayleigh & Mie scattering and ozone absorbtion","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sky","scattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// View settings\n\nconst float CAMERA_HEIGHT = 10000.0; // meters\nconst int INTEGRATION_STEPS = 8;\n\n// Constants\n\nconst float PI = 3.141592653589793;\nconst float INF = 1e10;//1.0 / 0.0;\n\nconst vec2 EMPTY_INTERVAL = vec2(INF, -INF); // interval [a,b] represented as vec2(a, b)\n\nconst float EARTH_RADIUS = 6400000.0; // meters\nconst float ATMOSPHERE_HEIGHT = 100000.0; // meters\n\nconst vec3 SUN_EMISSION = vec3(1.0);\nconst vec3 EARTH_COLOR = vec3(0.15, 0.025, 0.0);\n\n// Scattering & absorption settings (try to set some to zero to see how important each of them is)\n\nconst vec3 RAYLEIGH_SCATTERING = vec3(5.802, 13.558, 33.1) * 1e-6;\nconst vec3 RAYLEIGH_EXTINSION = RAYLEIGH_SCATTERING;\n\nconst vec3 MIE_ABSOPTION = vec3(4.4) * 1e-6;\nconst vec3 MIE_SCATTERING = vec3(2.1) * 1e-6;\nconst vec3 MIE_EXTINSION = MIE_ABSOPTION + MIE_SCATTERING;\n\nconst vec3 OZONE_ABSORPTION = vec3(0.650, 1.881, 0.085) * 1e-6;\nconst vec3 OZONE_EXTINSION = OZONE_ABSORPTION;\n\nfloat rayleigh_density(float height)\n{\n    return exp(- height / 7994.0);\n}\n\nfloat mie_density(float height)\n{\n    return exp(- height / 1200.0);\n}\n\nfloat ozone_density(float height)\n{\n    return max(0.0, 1.0 - abs(height - 25000.0) / 15000.0);\n}\n\nfloat rayleigh_phase(float c)\n{\n    return (1.0 + c * c) * (3.0 / 16.0 / PI);\n}\n\nfloat mie_phase(float c)\n{\n    float g = 0.76;\n    return (3.0 / 8.0 / PI) * (1.0 - g * g) * (1.0 + c * c) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * c, 1.5);\n}\n\n// Math helpers\n\nvec2 interval_intersection(vec2 i1, vec2 i2)\n{\n    return vec2(max(i1.x, i2.x), min(i1.y, i2.y));\n}\n\nbool empty(vec2 i)\n{\n    return i.x > i.y;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n    float D = b * b - 4.0 * a * c;\n    if (D < 0.0)\n        return vec2(INF, INF);\n    D = sqrt(D);\n        \n    float x1, x2;\n    if (b >= 0.0)\n    {\n        x1 = (- b - D) / 2.0 / a;\n        x2 = 2.0 * c / (- b - D);\n    }\n    else\n    {\n        x1 = 2.0 * c / (- b + D);\n        x2 = (- b + D) / 2.0 / a;\n    }\n    \n    if (x1 < x2)\n        return vec2(x1, x2);\n    return vec2(x2, x1);\n}\n\n// Raycast\n \nvec2 sphere_raycast(vec3 ray_origin, vec3 ray_direction, float radius)\n{\n//    |o + td| = r\n//    o^2 + 2t do + t^2 d^2 = r^2\n    float a = 1.0;\n    float b = dot(ray_direction, ray_origin) * 2.0;\n    float c = dot(ray_origin, ray_origin) - radius * radius;\n        \n    vec2 t = solve_quadratic(a, b, c);        \n    if (t == vec2(INF, INF))\n        return EMPTY_INTERVAL;\n    return interval_intersection(t, vec2(0.0, INF));\n}\n\nvec2 atmosphere_raycast(vec3 ray_origin, vec3 ray_direction)\n{\n    vec2 i = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 ip = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n    if (!empty(ip))\n        i = interval_intersection(i, vec2(-INF, ip.x));\n    return i;\n}\n\n// Main raymarching\n\nvec3 transmittance(vec3 origin, vec3 direction, float tmax, int steps)\n{\n    vec3 log_result = vec3(0.0);\n    float dt = tmax / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt;\n        vec3 p = origin + t * direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        log_result += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        log_result += MIE_EXTINSION * mie_density(h) * dt;\n        log_result += OZONE_EXTINSION * ozone_density(h) * dt;\n    }\n    return exp(- log_result);\n}\n\nvec3 sky_color(vec3 ray_origin, vec3 ray_direction, vec3 sun_direction, int steps)\n{\n    vec3 background = vec3(0.0);\n    \n    vec2 interval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    \n    vec2 pinterval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n    \n    if (!empty(pinterval))\n    {\n        vec3 n = normalize(ray_origin + ray_direction * pinterval.x);\n    \n        background = EARTH_COLOR * max(0.0, dot(n, sun_direction));\n        interval = interval_intersection(interval, vec2(-INF, pinterval.x));\n    }\n    \n    if (empty(interval))\n        return background;\n        \n    vec3 result = vec3(0.0);\n\n    vec3 tcoeff = vec3(0.0);\n    \n    float dt = (interval.y - interval.x) / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt + interval.x;\n        vec3 p = ray_origin + t * ray_direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        // Instead of calling transmittance(p, -ray_direction, t, steps) to\n        // compute how much scattered light actually reachs the camera (as opposed\n        // to being absorbed or scattered again), we make use of the raymarching\n        // and compute transmittance on the go. The actuall transmittance factor\n        // is exp(-tcoeff) * dt\n        \n        tcoeff += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        tcoeff += MIE_EXTINSION * mie_density(h) * dt;\n        tcoeff += OZONE_EXTINSION * ozone_density(h) * dt;\n        \n        vec2 it = sphere_raycast(p, sun_direction, EARTH_RADIUS);\n        \n        vec3 emitter = vec3(0.0);\n        if (!empty(it))\n            emitter = EARTH_COLOR;\n        else\n        {\n            it = sphere_raycast(p, sun_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n        \n            if (!empty(it))\n                emitter = SUN_EMISSION;\n        }\n            \n        vec3 incoming = transmittance(p + it.x * sun_direction, sun_direction, it.y - it.x, steps) * SUN_EMISSION;\n        \n        float c = dot(-sun_direction, -ray_direction);\n        \n        vec3 scatter = vec3(0.0);\n        scatter += RAYLEIGH_SCATTERING * rayleigh_phase(c);\n        scatter += MIE_SCATTERING * mie_phase(c);\n        \n        result += incoming * scatter * exp(-tcoeff) * dt;\n    }\n    \n    result += background * exp(-tcoeff);\n\n    return result;\n}\n\n\nvec3 reinhard(vec3 color)\n{\n    return color / (vec3(1.0) + color);\n}\n\nvec3 uncharted2_impl(vec3 x)\n{\n    float A = 0.15;\n    float B = 0.50;\n    float C = 0.10;\n    float D = 0.20;\n    float E = 0.02;\n    float F = 0.30;\n\n    return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\n\nvec3 uncharted2(vec3 x)\n{\n    //float W = 11.2;\n    float W = 2.5;\n    return uncharted2_impl(x) / uncharted2_impl(vec3(W));\n}\n\nvec3 tone_map(vec3 x)\n{\n    return uncharted2(x);\n}\n\nvec3 gamma_correct(vec3 x)\n{\n    return pow(x, vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    float time = 12.0 + iTime / 1.8; // in hours\n\n    vec3 sun_direction = vec3(sin(time / 12.0 * PI), 0.0, -cos(time / 12.0 * PI));\n    \n    vec3 camera_position = vec3(0.0, 0.0, EARTH_RADIUS + CAMERA_HEIGHT);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec2 m = iMouse.xy / iResolution.xy - vec2(0.5);    \n    m *= PI;\n    \n    vec3 view_direction;\n    \n    uv.x = uv.x * 2.0 * PI;\n    uv.y = (uv.y - 0.5) * PI;\n\n    //uv -= m * vec2(2.0 * PI, PI);\n\n    vec3 x = vec3(1.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 1.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 1.0);\n    \n    if (iMouse.xy != vec2(0.0, 0.0))\n    {\n        x = x * cos(m.y) + z * sin(m.y);\n        z = cross(x, y);\n\n        x = x * cos(m.x) - y * sin(m.x);\n        y = cross(z, x);\n    }\n\n    // uv.y = max(-PI/2.0, min(PI/2.0, uv.y));\n\n    view_direction =\n        x * cos(uv.x) * cos(uv.y) +\n        y * sin(uv.x) * cos(uv.y) +\n        z * sin(uv.y);\n            \n    vec3 color = sky_color(camera_position, view_direction, sun_direction, INTEGRATION_STEPS);\n        \n    fragColor = vec4(gamma_correct(tone_map(color)), 1.0);\n}","name":"Image","description":"","type":"image"}]}