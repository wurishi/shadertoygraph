{"ver":"0.1","info":{"id":"Ndl3Rr","date":"1615660823","viewed":81,"name":"DB SPHERE","username":"Sergeindamix","description":"Techno inspired. Put fullscreen, make sure sure you have sound and stare at it until the end!","likes":0,"published":1,"flags":64,"usePreview":0,"tags":["universe","brain","trip","techno","flythrough","neurons","network","blockchain","consciousness","spiritual","mystic","multiverse"],"hasliked":0,"parentid":"lscczl","parentname":"The Universe Within"},"renderpass":[{"inputs":[{"id":"XlfSWN","filepath":"https://soundcloud.com/believer/sesion-09-03-19-205429-1","previewfilepath":"https://soundcloud.com/believer/sesion-09-03-19-205429-1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define t iTime\n#define re iResolution.xy\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define NUM_LAYERS 4.\n\n//#define SIMPLE\n\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 GetPos(vec2 id, vec2 offs, float t) {\n    float n = N21(id+offs);\n    float n1 = fract(n*10.);\n    float n2 = fract(n*100.);\n    float a = t+n;\n    return offs + vec2(sin(a*n1), cos(a*n2))*.4;\n}\n\nfloat GetT(vec2 ro, vec2 rd, vec2 p) {\n\treturn dot(p-ro, rd); \n}\n\nfloat LineDist(vec3 a, vec3 b, vec3 p) {\n\treturn length(cross(b-a, p-a))/length(p-a);\n}\n\nfloat df_line( in vec2 a, in vec2 b, in vec2 p)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat line(vec2 a, vec2 b, vec2 uv) {\n    float r1 = .04;\n    float r2 = .01;\n    \n    float d = df_line(a, b, uv);\n    float d2 = length(a-b);\n    float fade = S(1.5, .5, d2);\n    \n    fade += S(.05, .02, abs(d2-.75));\n    return S(r1, r2, d)*fade;\n}\n\nfloat NetLayer(vec2 st, float n, float t) {\n    vec2 id = floor(st)+n;\n\n    st = fract(st)-.5;\n   \n    vec2 p[9];\n    int i=0;\n    for(float y=-1.; y<=1.; y++) {\n    \tfor(float x=-1.; x<=1.; x++) {\n            p[i++] = GetPos(id, vec2(x,y), t);\n    \t}\n    }\n    \n    float m = 0.;\n    float sparkle = 0.;\n    \n    for(int i=0; i<9; i++) {\n        m += line(p[4], p[i], st);\n\n        float d = length(st-p[i]);\n\n        float s = (.005/(d*d));\n        s *= S(1., .7, d);\n        float pulse = sin((fract(p[i].x)+fract(p[i].y)+t)*5.)*.4+.6;\n        pulse = pow(pulse, 20.);\n\n        s *= pulse;\n        sparkle += s;\n    }\n    \n    m += line(p[1], p[3], st);\n\tm += line(p[1], p[5], st);\n    m += line(p[7], p[5], st);\n    m += line(p[7], p[3], st);\n    \n    float sPhase = (sin(t+n)+sin(t*.1))*.25+.5;\n    sPhase += pow(sin(t*.1)*.5+.5, 50.)*5.;\n    m += sparkle*sPhase;//(*.5+.5);\n    \n    return m;\n}\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define colorRange 24.0\nvec4 fragColor;\n\nfloat Band(float t, float start, float end, float blur) {\n\n\t\t\t\tfloat step1 = smoothstep(start - blur, start + blur, t);\n\t\t\t\tfloat step2 = smoothstep(end + blur, end - blur, t);\n\n\t\t\t\treturn step1 * step2;//overlap edges\n\n}\n\nfloat Rect(vec2 uv, float left, float right, float bottom, float top, float blur) {\n\t\t\t\tfloat band1 = Band(uv.x, left, right, blur);\n\t\t\t\tfloat band2 = Band(uv.y, bottom, top, blur);\n\n\t\t\t\treturn band1 * band2;//overlap horizontal and vertical bands\n\n}\nvoid getTriangle(vec2 uv, vec2 t0, vec2 t1, vec2 t2 ) {\n\t\t\t\t//Colors\n\t\t\t\tvec3 fgColor = vec3(0.741, 0.635, 0.471);\n\t\t\t\tvec3 bgColor = vec3(0.192, 0.329, 0.439);\n\n\t\t\t\t//Triangle barycentric coordinates defined on screen space\n\t\t\t\t/*vec2 t0 = vec2(0.5, 0.375);//base izq\n\t\t\t\tvec2 t1 = vec2(0.75, 0.25);//base der\n\t\t\t\tvec2 t2 = vec2(0.75, 0.50);//punta*/\n\t\t\t\tvec2 tCentroid = (t0 + t1 + t2) / 3.0;\n\t\t\t\t//Compute UV coordinates\n\t\t\t\t\n\n\t\t\t\tvec2 v0 = t2 - t0;\n\t\t\t\tvec2 v1 = t1 - t0;\n\t\t\t\tvec2 v2 = uv - t0;\n\n\t\t\t\t//Compute barycentric coordinates \n\t\t\t\tfloat dot00 = dot(v0, v0);\n\t\t\t\tfloat dot01 = dot(v0, v1);\n\t\t\t\tfloat dot02 = dot(v0, v2);\n\t\t\t\tfloat dot11 = dot(v1, v1);\n\t\t\t\tfloat dot12 = dot(v1, v2);\n\n\t\t\t\tfloat invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n\t\t\t\tfloat baryX = (dot11 * dot02 - dot01 * dot12) * invDenom;\n\t\t\t\tfloat baryY = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n\t\t\t\tif ((baryX >= 0.0) && (baryY >= 0.0) && (baryX + baryY <= 1.0)) {\n\t\t\t\t\tfragColor = vec4(fgColor, 1.0);\n\t\t\t\t}\n\t\t\t\t//else discard;\n\t\t\t\t/*{\n\t\t\t\t\tfragColor = vec4(bgColor, 1.0);\n\t\t\t\t}*/\n\t\t\t\t\n}\n\nfloat triangle( in vec2 uv, in vec2 n ) {\n    vec2 uuv = vec2(abs(uv.x), uv.y);\n    return max(-uv.y, dot(n, uuv));\n}\nmat2 rot( in float a ) {\n    float c = cos(a);\n    float s = sin(a);\n\treturn mat2(c,s,-s,c);\t\n}\n\nfloat CircleShape(vec2 pos, float radius){    \n    \n    return step(radius, length(pos));\n}\n\nfloat polygon(vec2 pos, float rad, float sides){\n    pos = pos * 2. - 1.;\n    float angle = atan(pos.x, pos.y);\n    float slice = PI * 2.0/ sides;\n    \n    return step(rad, cos(floor(0.5 + angle/ slice) * slice - angle) * length(pos));\n\n}\n\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.50000*noise( p ); p = m*p*2.02;\n    f += 0.25000*noise( p ); p = m*p*2.03;\n    f += 0.12500*noise( p ); p = m*p*2.01;\n    f += 0.06250*noise( p ); p = m*p*2.04;\n    f += 0.03125*noise( p );\n\n    return f/0.984375;\n}\n\nfloat length2( vec2 p )\n{\n    vec2 q = p*p*p*p;\n    return pow( q.x + q.y, 1.0/4.0 );\n}\n\n\n#define BPM 140.0\n#define STROBEPREVENTION\n#define PI_2 6.28\nfloat rand (vec2 n)\n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noisex(vec2 n)\n{\n\tconst vec2 d = vec2(0.0, 1.0);\n  \tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat getPoly (vec2 uv, float gonSide, float gonAngle, float thickness, float percent)\n{\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gonSlice = 6.28319 / gonSide;\n    float gonSize = percent;\n    float gonWidth = thickness;\n  \t\n    vec2 deltaUV = vec2(0.5) - uv;\n    float deltaAngle = atan(deltaUV.x,deltaUV.y) + (gonAngle / PI);\n    float dist = cos(floor(.5 + deltaAngle / gonSlice) * gonSlice - deltaAngle) * length(deltaUV.xy) * 2.0;\n    return min(smoothstep(gonSize - gonWidth - 0.001, gonSize - gonWidth, dist), smoothstep(gonSize + gonWidth, gonSize + gonWidth - 0.001, dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord/iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    //p*=rot(t);\n\n    float r = length( p );\n    float a = atan( p.y, p.x );\n\n    float dd = 0.2*sin(4.0*iTime);\n    float ss = 1.0 + clamp(1.0-r,0.0,1.0)*dd;\n\n    r *= ss;\n\n    vec3 col = vec3( 0.0, 0.3, 0.4 );\n\n    float f = fbm( 5.0*p );\n    col = mix( col, vec3(0.2,0.5,0.4), f );\n\n    col = mix( col, vec3(0.9,0.6,0.2), 1.0-smoothstep(0.2,0.6,r) );\n\n    a += 0.05*fbm( 20.0*p );\n\n    f = smoothstep( 0.3, 1.0, fbm( vec2(20.0*a,6.0*r) ) );\n    col = mix( col, vec3(1.0,1.0,1.0), f );\n\n    f = smoothstep( 0.4, 0.9, fbm( vec2(15.0*a,10.0*r) ) );\n    col *= 1.0-0.5*f;\n\n    col *= 1.0-0.25*smoothstep( 0.6,0.8,r );\n\n    f = 1.0-smoothstep( 0.0, 0.6, length2( mat2(0.6,0.8,-0.8,0.6)*(p-vec2(0.3,0.5) )*vec2(1.0,2.0)) );\n\n    col += vec3(1.0,0.9,0.9)*f*0.985;\n\n    col *= vec3(0.8+0.2*cos(r*a));\n\n    f = 1.0-smoothstep( 0.2, 0.25, r );\n    col = mix( col, vec3(0.0), f );\n\n    f = smoothstep( 0.79, 0.82, r );\n    col = mix( col, vec3(1.0), f );\n\n    col *= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n    \n    /////////////\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy-.5;\n    \n    float t = iTime*.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    mat2 rot = mat2(c, -s, s, c);\n    vec2 st = uv*rot;  \n\tM *= rot*2.;\n    \n    float m = 0.;\n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float z = fract(t+i);\n        float size = mix(15., 1., z);\n        float fade = S(0., .6, z)*S(1., .8, z);\n        \n        m += fade * NetLayer(st*size-M*z, i, iTime);\n    }\n    \n\tfloat fft  = texelFetch( iChannel0, ivec2(.7,0), 0 ).x;\n    float glow = -uv.y*fft*2.;\n   \n    vec3 baseCol = vec3(s, cos(t*.4), -sin(t*.24))*.4+.6;\n    col *= mix(col, baseCol*m, 0.10);\n    col += baseCol*glow;\n    \n    #ifdef SIMPLE\n    uv *= 10.;\n    col = vec3(1)*NetLayer(uv, 0., iTime);\n    uv = fract(uv);\n    //if(uv.x>.98 || uv.y>.98) col += 1.;\n    #else\n    col *= 1.-dot(uv,uv);\n    t = mod(iTime, 230.);\n    col *= S(0., 20., t)*S(224., 200., t);\n    #endif\n    \n    //pulse star\n\n    vec3 star;\n    float l,z=t;\n    for(int i=0;i<3;i++) {\n        vec2 uv,p=fragCoord.xy/r;\n        p-=.5;\n        //p.x*=r.x/r.y;\n        uv=p;\n\t\tz+=.07;\n        l=length(p);\n        uv+=p*abs(sin(l*7.-z*1.35));\n        uv *= smoothstep(0.0005, 0.0006, l);\n        //uv+= vec2(0.0,0.4);\n        star[i]=0.05/length(uv);\n        \n        }\n        \n    //tube    \n    float x=uv.x;\n    float y=uv.y;\n    //y=x;//vertical\n    float d= smoothstep(.1,.2,length(y));\n    x=y;//horiz\n    float d2= fract(smoothstep(.1,.2,length(x+y)));//wide + or *\n    d2+= mix(d2,fract(smoothstep(.1,.2,length(x+y))),1.0);//wide + or *\n    \n    //cones\n    //move position\n    p = vec2(.0, .0);\n\t\t\t\t\n    x += .0;//move horizontal\n    y += .0;//move vertical\n\n    m = -(x - .5)*(x + .5);//distortion parabola\n    y = uv.y - m;//distortion x\n    //circle mask\n    float mask = smoothstep(.03,.003,length(uv) - .4);//esfera Circle(uv, p, .5, .01);\n    //mask += max(mask,  p.y-0.35);//cortar altura del circulo\n    col += vec3(1.3, 0.75, 0.5)*mask;\n    mask += smoothstep(.02,.01,length(uv) - .2);\n    //cut another circle or add with symbol + or overlap multipling *\n    //mask -= Circle(uv, p - vec2(.0, .0), .49, .01);\n    mask += length(uv) + .1;//esferaCircle(uv, vec2(.0, .0), .3, .01);\n    //col += vec3(0., 0., 1.)*mask;\n    //cut another circle or add with symbol + or overlap multipling *\n    mask -= CircleShape(uv,  .1);\n    mask += length(uv) - .1;//esferaCircle(uv, vec2(.0, .0), .1, .01);\n    //col += vec3(0.7, 0.8, 1.0)*mask;\n    mask -= CircleShape(uv,  .1);\n    p = uv - vec2(.0, .125);\n    //getTriangle(p, vec2(0.5, 0.375), vec2(0.75, 0.25), vec2(0.75, 0.50));\n    mask -= Rect(uv, .5, .9, -.08, .09, .001);\n    //getTriangle(p, vec2(0.5, 0.375), vec2(0.25, 0.25), vec2(0.25, 0.5));\n    mask -= Rect(uv, -.9, -.5, -.08, .09, .001);\n    mask += smoothstep(.001,.001,triangle( abs(st*rot)-vec2(.0,0.22), vec2(.008,.006) ));\n\t\t\t\n\n    //set color of circle and background\n    if(d<.3) c = 0.0; else c= 1.0;\n\n    //colorize circle\n    //col /= vec3(1., 1., 1.)*mask;\n    \n    \n    //polygon\n    uv*=6.0;\n    float polygon = polygon(rot* -uv+vec2(.5,.5), .6,3.0) * polygon(rot* uv+vec2(.5,.5), .6,3.0);\n    \n    col += polygon*star;\n    \n    //bpm\n    uv*=.2;\n    t = fract(iTime*(BPM/60.));\n    float h = fract( 0.25 + 0.5*iChannelTime[0]*BPM/60.0 );\n\tf = 1.0-smoothstep( 0.0, 1.0, h );\n\tf *= smoothstep( 4.5, 4.51, iChannelTime[0] );\n\tr = length(uv-0.0) + 0.2*cos(25.0*h)*exp(-4.0*h);\n\tf = pow(f,0.5)*(1.0-smoothstep( 0.5, 0.55, r) );\n\tfloat rn = r/0.55;\n\tcol = mix( col, vec3(0.4+1.5*rn,0.1+rn*rn,0.50)*rn, f );\n\t\n\n\tcol = mix( col, vec3(1.0), smoothstep(  0.0,  3.0, iChannelTime[0] )*exp( -1.00*max(0.0,iChannelTime[0]- 2.5)) );\n\tcol = mix( col, vec3(1.0), smoothstep( 16.0, 18.0, iChannelTime[0] )*exp( -0.75*max(0.0,iChannelTime[0]-19.0)) );\n\t\n    ////drums\n    float beattime = 1.0-fract(iTime/60.*BPM)/(BPM/60.0);\n    float claptime = 1.0-fract((iTime-0.5)/120.*BPM)/(BPM/120.0);\n    float hatintime = 1.0-fract((iTime-0.25)/60.*BPM)/(BPM/120.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv /= fract(uv);\n    float kick = smoothstep(0.333,0.33,uv.x);\n    float hat = smoothstep(0.66,0.662,uv.x);\n    float clap = 1.0-max(kick,hat);\n    \n    col += vec3(kick*beattime,\n                    hat*hatintime,\n                    clap*claptime);\n    #ifdef STROBEPREVENTION\n    // desaturate to possibly reduce strobing?\n    //col = ( col * 0.3 ) + 0.7;\n    #endif\n    \n    ////bpmstuff\n    vec2 pixelSz = vec2(1.0) / iResolution.xy;\n    \n\tuv = fragCoord / iResolution.xy;\n    vec4 final = texture(iChannel0, uv);\n    \n    const float stepsize = 0.1;\n    const float stepmult = stepsize * 0.5;\n    float samplescale = pixelSz.x * 64.0;\n    \n    for (float i=0.0; i<= 1.0; i+= stepsize)\n    {\n        float bias = i - 0.5;\n        float samplerand = rand(uv) - 0.5;\n        vec2 sampleuv = vec2(bias * samplescale + samplerand * samplescale, 0.0);\n        \n        final += texture(iChannel0, uv + sampleuv) * stepmult * (1.0 - abs(samplerand));\n        final += texture(iChannel0, uv - sampleuv) * stepmult * (1.0 - abs(samplerand));\n    }\n    \n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    final.a = 1.0;\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uvOrig = fragCoord / iResolution.xy;\n    vec2 ctDelta = uvOrig - vec2(0.5);\n    float ctLen = length(ctDelta);\n    vec2 ctDir = normalize(ctDelta);\n    \n    // Aspect ratio corrected uv\n    uv = uvOrig;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\tuv += 0.5;\n    \n    // Beat?\n    //const float BPM = 120.0;\n    const float BPS = 60.0 / BPM;\n    const float BPS2 = BPS * 2.0;\n    float beatDelta = mod(iTime, BPS) / BPS;\n    float beatDelta2 = mod(iTime, BPS2) / BPS2;\n    float beatIncr = 3.0 + mod(floor(iTime / BPS), 4.0);\n    float beatIncr2 = 3.0 + mod(floor(iTime / BPS2), 4.0);\n    \n    float beatTime = iTime / BPS;\n    float powerBeat = pow(1.0 - beatDelta, 1.4);\n    \n    // Flashy background\n    float bgr = mod(beatIncr, 6.0) / 6.0;\n    vec3 flash = vec3(sin(iTime * 2.0 + 60.0) * 0.5 + 0.5, cos(iTime * 4.0 + 0.5) * 0.5 + 0.5, abs(sin(iTime))) * 0.4 * pow(1.0 - beatDelta, 3.0);\n    final.xyz = flash * (uv.y + sin(uv.x * 10.0) * 0.05);\n    // Rad BG\n    float radRand = rand(vec2(floor(uv.x * 8.0) / 8.0, beatIncr));\n    vec2 raduv = vec2(uv.x, min(uv.y + radRand * 0.5, 1.0));\n    \n    float radIntensity = pow(min(powerBeat + radRand * 0.3, 1.0), 2.0) * 0.52 + abs(sin(beatTime * 10.0 + radRand * 42.0)) * 0.1;\n    float radDelta = 1.0 - abs(radIntensity - raduv.y) * 2.0;\n    float radPercent = max(round(sin(raduv.y * 128.0) * pow(radDelta, 2.0)) * pow(max(radDelta, 0.0), 6.0), smoothstep(radIntensity, radIntensity - 0.001, raduv.y));\n    // radPercent *= pow(radDelta, 3.0);\n    \n    vec3 radColour = mix(vec3(0.0), vec3(0.9, 0.55, 0.15) * (1.0 + radRand * 0.1), radPercent);\n    final.xyz += radColour * (1.0 + noise(uv * 5.0 + iTime) * 0.4 + noise(uv * 100.0 + iTime) * 0.9);\n    \n    // BG with stars?\n    float ctAngle = atan(ctDir.y, ctDir.x) / PI_2 + 0.5;\n    float starSamp = smoothstep(0.98, 1.0, noise(vec2(ctAngle * 2.0, ctLen * 0.05 - beatTime * 0.05) * 100.0));\n    final.xyz += starSamp;\n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    // rotato potato\n    // N-Gon from : https://thndl.com/square-shaped-shaders.html\n    float gon1Side = beatIncr; // sides\n    float gon1Angle = beatDelta * 4.0 - 2.0;\n    float gon2Angle = beatDelta2 * 4.0 - 2.0;\n    float gon1Width = 0.01 + pow(beatDelta, 3.0) * 0.1;\n    \n    float t1 = (beatDelta + abs(sin(beatDelta * 5.0)) * 0.2) / 1.2;\n    float gon1Size = pow(1.0 - pow(1.0 - t1, 1.0), 3.0) * 2.0;\n    float gon2Size = pow(1.0 - pow(1.0 - beatDelta2, 0.5), 2.5) * 2.0;\n    \n    float gon1 = getPoly(uv, gon1Side, gon1Angle, gon1Width, gon1Size);\n    float gon2 = getPoly(uv, gon1Side + 1.0, gon2Angle, 0.01, gon2Size);\n    \n    final.xyz = mix(final.xyz, vec3(1.0), gon1);\n    final.xyz += vec3(fract(0.5 - bgr), bgr, 0.5) * 0.25 * gon2; //mix(final.xyz, vec3(fract(0.5 - bgr), bgr, 0.5), gon2 * 0.2);\n    for (float i=0.1; i<=1.0; i+=0.1)\n    {\n        float disp = 1.0 - pow(1.0 - i, 3.0);\n        \n        float gon3Size = pow(1.0 - pow(1.0 - t1 - 0.1 * disp, 1.0), 3.0) * 2.0;\n        float gon3 = getPoly(uv, gon1Side, gon1Angle, gon1Width * 0.3 * i, gon3Size - 0.2);\n    \tfinal.xyz += vec3(sin(iTime * 2.0 + 60.0), tan(iTime * 4.0 + 0.5), abs(sin(iTime))) * gon3 * disp;\n        // final.xyz = mix(final.xyz, vec3(sin(iTime * 2.0 + 60.0), tan(iTime * 4.0 + 0.5), abs(sin(iTime))), gon3);\n    }\n    \n    // Output to screen\n    final.xyz = clamp(final.xyz, 0.0, 1.0);\n    final.a = 1.0;\n    \n    \n    col += final.xyz;\n    \n    fragColor = vec4(col-polygon,final.a);\n}","name":"Image","description":"","type":"image"}]}