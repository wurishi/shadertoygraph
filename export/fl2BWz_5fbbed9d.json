{"ver":"0.1","info":{"id":"fl2BWz","date":"1652045020","viewed":260,"name":"Alt. 2.5D RGB Color Picker","username":"hero_dev","description":"needed a color picker, thought i would think of something less traditional and with limitations.\nthe animation is mostly the bottleneck with all the 'sin' calls (mostly ANIM_WAVE), but will be optimized in the application by pre-calculating on the CPU.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cube","color","rgb","25d","isometric","orthographic","picker"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_ITER = 1000;\nconst float MAX_DIST = 9.0;\nconst float EPSILON = 0.001;\n\nconst float pi = 3.14159;\nconst float inf = 1.f / 0.f;\n\n#define CUBE_AXIS_COUNT       4\n#define CUBE_HALF_SIZE        (CUBE_SIZE / 2.f)\n#define CUBE_BORDER_HALF_SIZE (0.1f / float(CUBE_AXIS_COUNT * CUBE_AXIS_COUNT + 1))\n#define CUBE_SIZE             ((2.f - CUBE_BORDER_HALF_SIZE) / float(CUBE_AXIS_COUNT * CUBE_AXIS_COUNT + 1))\n#define CUBE_AXIS_OFFSET      (CUBE_SIZE * float(CUBE_AXIS_COUNT) + CUBE_BORDER_HALF_SIZE)\n#define SELECTED_SPEED        4.0\n#define SELECTED_MAX_OFFSET   (CUBE_HALF_SIZE * 2.f)\n\n//\n// these sin functions (mostly ANIM_WAVE) is slowing down the shader.\n// in a real application these will be passed in to the shader.\n#define ANIM_ROTATION_Y       (is_at_timeline_range(TIMELINE_SPIN_START, TIMELINE_SPIN_END) ? sin(iTime * 1.5) * pi * 2.f : 0.f)\n#define ANIM_AXIS             (is_at_timeline_range(TIMELINE_OPEN_START, TIMELINE_OPEN_END) ? (sin(iTime * 2.0 - pi / 2.f) * 0.5 + 0.5) : 1.f)\n#define ANIM_WAVE             (is_at_timeline_range(TIMELINE_WAVE_START, TIMELINE_WAVE_END) ? sin(iTime * 8.f + float(color_idx.r + color_idx.b)) * (sin(smoothstep(TIMELINE_WAVE_START, TIMELINE_WAVE_END, iTime) * (pi * 1.5f)) * 0.5 + 0.5) * 0.045 : 0.f)\n#define ANIM_SELECTED         (is_at_timeline_range(TIMELINE_SELECT_START, TIMELINE_SELECT_END) ? 1.f : 0.f)\n\n#define TIMELINE_SPIN_START   0.f\n#define TIMELINE_SPIN_END     1.1f\n#define TIMELINE_OPEN_START   0.f\n#define TIMELINE_OPEN_END     1.5f\n#define TIMELINE_WAVE_START   0.75f\n#define TIMELINE_WAVE_END     1.6f\n#define TIMELINE_SELECT_START 1.3f\n#define TIMELINE_SELECT_END   inf\n\nconst float cube_half_size = CUBE_HALF_SIZE;\nconst float cube_size = CUBE_SIZE;\nconst float cube_border_half_size = CUBE_BORDER_HALF_SIZE;\nconst float cube_axis_offset = CUBE_AXIS_OFFSET;\nconst float selected_max_offset = SELECTED_MAX_OFFSET;\n\nfloat length_sq(vec3 v) { return dot(v, v); }\nfloat sum(vec3 v) { return v.x + v.y + v.z; }\n\nfloat distance_sq_cube(vec3 pos, float size) {\n    return length_sq(max(abs(pos) - size, 0.0));\n}\n\nfloat distance_sq_cube_frame(vec3 pos, float size, float width) {\n    pos = abs(pos) - size;\n    vec3 q = abs(pos + width) - width;\n\n    return min(\n        min(\n            length_sq(max(vec3(q.x, q.y, pos.z), 0.0)),\n            length_sq(max(vec3(q.x, pos.y, q.z), 0.0))\n        ),\n        length_sq(max(vec3(pos.x, q.y, q.z), 0.0))\n    );   \n}\n\nmat2 mat2_identity_rotation(float angle)\n{\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle),  cos(angle)\n    );\n}\n\nbool is_at_timeline_range(float start, float end) {\n    float time = iTime;\n    return start <= time && time <= end;\n}\n\nfloat scale = 1.0;\nvec4 distance_cubes(\n    vec3 ray_sample_pos,\n    vec3 is_split_axis_v3,\n    vec3 split_axis_offset,\n    ivec3 selected_color_idx,\n    float offset_ratio\n) {\n    //\n    // rotate the sample position towards local space of the cube\n    ray_sample_pos.yz *= mat2_identity_rotation(pi / 5.0);\n    ray_sample_pos.xz *= mat2_identity_rotation(pi / 4.f + ANIM_ROTATION_Y);\n    \n    //\n    // if CUBE_AXIS_COUNT == 3 then start_pos = -1.0, end_pos = 2.0\n    // if CUBE_AXIS_COUNT == 4 then start_pos = -1.5, end_pos = 2.5\n    vec3 start_pos = vec3(-(float(CUBE_AXIS_COUNT) - 1.f) / 2.f);\n    vec3 end_pos = start_pos + float(CUBE_AXIS_COUNT);\n    \n    vec3 pos;\n    vec4 last_dist_sq = vec4(vec3(0.f), 99999.f);\n    ivec3 color_idx = ivec3(0);\n    \n    //\n    // loop over all cubes\n    for (pos.x = start_pos.x; pos.x < end_pos.x; pos.x += 1.0, color_idx.r += 1) {\n    \n        pos.y = start_pos.y;\n        color_idx.g = 0;\n        for (; pos.y < end_pos.y; pos.y += 1.0, color_idx.g += 1) {\n        \n            pos.z = start_pos.z;\n            color_idx.b = 0;\n            for (; pos.z < end_pos.z; pos.z += 1.0, color_idx.b += 1) {\n                \n                //\n                // 0.f or 1.f if this cube is selected\n                float is_selected_f = float(all(equal(selected_color_idx, color_idx)));\n                \n                //\n                // calculate the selected offset if the cube is selected\n                vec3 selected_offset = is_selected_f * is_split_axis_v3 * selected_max_offset * offset_ratio * ANIM_SELECTED;\n                \n                //\n                // the offset of the cube on the split axis\n                vec3 cube_split_axis_offset = pos * split_axis_offset;\n                \n                //\n                // apply the wave and slow the demo down :/\n                cube_split_axis_offset.y += ANIM_WAVE;\n                \n                //\n                // bring the sample position in to local space of this cube\n                vec3 local_sample_pos = ray_sample_pos + cube_split_axis_offset + selected_offset;\n        \t\t\n                float next_dist_sq = distance_sq_cube(local_sample_pos, cube_half_size) * scale;\n                if (next_dist_sq < last_dist_sq.w) {\n                    vec3 color = vec3(color_idx) / float(CUBE_AXIS_COUNT - 1);\n                    float frame_dist_sq = distance_sq_cube_frame(local_sample_pos, cube_half_size, cube_border_half_size) * scale;\n                    if (frame_dist_sq < next_dist_sq) {\n                        //\n                        // we hit the frame of the cube\n                        float grey = sum((1.f - color) / 3.f);\n                        grey += is_selected_f * sin(iTime * SELECTED_SPEED) * ANIM_SELECTED;\n                        last_dist_sq = vec4(vec3(grey), next_dist_sq);\n                     } else {\n                        //\n                        // we hit the cube\n                        last_dist_sq = vec4(color, next_dist_sq);\n                    }\n                }\n            }\n        }\n    }\n    \n    last_dist_sq.w = sqrt(last_dist_sq.w);\n    return last_dist_sq;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // a value from -1.f to 1.f\n    vec2 screen_pos = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 world_up = vec3(0.0, -1.0, 0.0);\n    \n\tvec3 camera_pos = vec3(0.0, 0.0, 1.0);\n    vec3 camera_target = vec3(0.0, 0.0, 0.0);\n    vec3 camera_dir = normalize(camera_target - camera_pos);\n    vec3 camera_right = cross(camera_dir, world_up);\n    vec3 camera_up = cross(camera_right, camera_dir);\n    \n    vec3 ray_sample_pos\n        = camera_pos\n        + (screen_pos.x * camera_right)\n        + (screen_pos.y * camera_up)\n        ;\n    vec3 ray_dir = normalize(camera_dir);\n    \n    float total_dist = 0.0;\n    vec4 dist = vec4(0.0, 0.0, 0.0, EPSILON);  \n    \n    ivec3 selected_color_idx = ivec3(2, 2, 1);\n    \n    vec3 axis = vec3(0.0, 1.0, 0.0) * ANIM_AXIS;\n    vec3 axis_offset = axis * cube_axis_offset + cube_size;\n    \n    float offset_ratio = sin(iTime * SELECTED_SPEED) * 0.5 + 0.5;\n    \n    for (int i = 0; i < MAX_ITER; i += 1) {\n        if (dist.w < EPSILON || total_dist > MAX_DIST) {\n            break;\n        }\n        \n        dist = distance_cubes(\n            ray_sample_pos,\n            axis,\n            axis_offset,\n            selected_color_idx,\n            offset_ratio\n        );\n        total_dist += dist.w;\n        ray_sample_pos += dist.w * ray_dir;\n    }\n \n    vec3 color = vec3(0.f);\n    if (dist.w < EPSILON) {   \n        color = dist.rgb;\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}