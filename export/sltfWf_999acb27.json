{"ver":"0.1","info":{"id":"sltfWf","date":"1663782562","viewed":79,"name":"SDF Mushrooom CIS 566","username":"nmoon","description":"base code for ray marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","learning"],"hasliked":0,"parentid":"sstSz2","parentname":"SDF mushroom puzzle"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// If precisions matters to you, the mushrooms are 2.5 units apart.\n// All constants used are [0.0, 0.25, 1.0]\n\n// There was one instance of iTime and one use of cos\n// Everything else is a call to the methods in common,\n// or very basic vector construction / operation\n//\n// My solution was ~20 lines total, including one helper function\n\n#define NUM_MUSHROOMS 3\n\nfloat createMushroom(vec3 queryPos, float plane, vec3 mushroom_bottom, vec3 mushroom_base_top, vec3 mushroom_cap_top) {\n    float base = capsuleSDF(queryPos, mushroom_bottom, mushroom_base_top + vec3(0,0.5,0), 0.25);\n    \n    float top = capsuleSDF(queryPos, mushroom_base_top, mushroom_cap_top, 0.75);\n    \n    float sphere = sphereSDF(queryPos, mushroom_cap_top, 1.0);\n    \n    float top_minus_sphere = smoothSubtraction( top, sphere, 0.5 );\n    \n    float mushroom = smoothUnion( base, top_minus_sphere, 0.025 );\n    \n    return mushroom;\n}\n\nfloat createClouds(vec3 queryPos) {\n    float cloud = 0.0;\n\n    float cloud_structure[9];\n    \n    // move clouds to right over time but also loop with mod\n    vec3 time_offset = vec3(mod(iTime, 10.0) - 5.0, 0.15 - sin((queryPos.y * 5.0) + (iTime * 10.0)) / 10.0,0);\n    \n    cloud = sphereSDF(queryPos, vec3(0,2.75,0)- time_offset, 0.15);\n    cloud_structure[0] = sphereSDF(queryPos, vec3(0.5,2.75,-0.64) - time_offset, 0.35);\n    cloud_structure[1] = sphereSDF(queryPos, vec3(-0.25,2.5,0.26) - time_offset, 0.35);\n    cloud_structure[2] = sphereSDF(queryPos, vec3(1.5,2.75,0.52) - time_offset, 0.25);\n    cloud_structure[3] = sphereSDF(queryPos, vec3(0.75,2.45,0.12) - time_offset, 0.15);\n    cloud_structure[4] = sphereSDF(queryPos, vec3(0.5,2.5,0.45) - time_offset, 0.35);\n    cloud_structure[5] = sphereSDF(queryPos, vec3(-1.5,2.75,0.75) - time_offset, 0.35);\n    cloud_structure[6] = sphereSDF(queryPos, vec3(-0.5,2.75,0.3) - time_offset, 0.35);\n    cloud_structure[7] = sphereSDF(queryPos, vec3(-1.0,2.5,0.4) - time_offset, 0.35);\n    cloud_structure[8] = sphereSDF(queryPos, vec3(1.0,2.75,0.2) - time_offset, 0.35);\n\n    for (int i = 0; i < 9; ++i) {\n        cloud = smoothUnion( cloud, cloud_structure[i], 0.25 );\n    }\n    \n    return cloud;\n    \n}\n\nvec3 bendMushroomComponent(vec3 position, float bend_value) {\n    vec3 orig_pos = position;\n        \n    position = bendPoint(vec3(0,orig_pos.y,0), bend_value);\n\n    position += vec3(orig_pos.x, 0, orig_pos.z);\n \n    return position;\n}\n\n\n\nfloat sceneSDF(vec3 queryPos, out bool mush_or_cloud) \n{\n    \n\n    float mushrooms[NUM_MUSHROOMS];\n\n    float plane = planeSDF(queryPos, 0.0);\n    \n    float return_val = plane;\n\n    for (int i = 0; i < NUM_MUSHROOMS; ++i) {\n        float bend_value = (sin(iTime) * queryPos.y) / 2.0;\n        if (i % 2 == 0) {\n            bend_value *= -1.0;\n        }\n    \n        vec3 mushroom_base_top = vec3(2.5 * float(i) - 2.5, 0.85, 0);\n        \n        mushroom_base_top = bendMushroomComponent(mushroom_base_top, bend_value);\n        \n        \n        vec3 mushroom_cap_top = vec3(2.5 * float(i) - 2.5, 0.85f + 0.25f, 0.0);\n        \n        mushroom_cap_top = bendMushroomComponent(mushroom_cap_top, bend_value * 0.75);\n        \n    \n        float mushroom = createMushroom( queryPos, \n                                         plane, \n                                         vec3(2.5 * float(i) - 2.5, 0.0, 0.0), \n                                         mushroom_base_top,\n                                         mushroom_cap_top\n                                         );\n        \n        \n        return_val = smoothUnion( return_val, mushroom, 0.25 );\n    }\n    \n    float clouds = createClouds(queryPos);\n    \n    // for coloring\n    if (clouds < return_val) {\n        mush_or_cloud = true;\n    }\n    else {\n        mush_or_cloud = false;\n    }\n    \n    return min(clouds, return_val);\n}\n\n\nRay getRay(vec2 uv) {\n    Ray ray;\n    \n    float len = tan(3.14159 * 0.125) * distance(EYE, REF);\n    vec3 H = normalize(cross(vec3(0.0, 1.0, 0.0), REF - EYE));\n    vec3 V = normalize(cross(H, EYE - REF));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = REF + uv.x * H + uv.y * V;\n    vec3 dir = normalize(p - EYE);\n    \n    ray.origin = EYE;\n    ray.direction = dir;\n    return ray;\n}\n\nIntersection getRaymarchedIntersection(vec2 uv, out bool mush_or_cloud)\n{\n    Ray ray = getRay(uv);\n    Intersection intersection;\n    \n    vec3 queryPoint = ray.origin;\n    for (int i=0; i < MAX_RAY_STEPS; ++i)\n    {\n        float distanceToSurface = sceneSDF(queryPoint, mush_or_cloud);\n        \n        if (distanceToSurface < EPSILON)\n        {\n            \n            intersection.position = queryPoint;\n            intersection.normal = vec3(0.0, 0.0, 1.0);\n            intersection.distance = length(queryPoint - ray.origin);\n            \n            return intersection;\n        }\n        \n        queryPoint = queryPoint + ray.direction * distanceToSurface;\n    }\n    \n    intersection.distance = -1.0;\n    return intersection;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    bool dummy_var = false;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), dummy_var) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), dummy_var),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), dummy_var) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), dummy_var),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), dummy_var) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), dummy_var)\n    ));\n}\n\nvec3 getSceneColor(vec2 uv)\n{\n    bool mush_or_cloud = false;\n    Intersection intersection = getRaymarchedIntersection(uv, mush_or_cloud);\n    \n    DirectionalLight lights[3];\n    vec3 backgroundColor = vec3(0.);\n    lights[0] = DirectionalLight(normalize(vec3(15.0, 15.0, 10.0)),\n                                 SUN_KEY_LIGHT);\n    lights[1] = DirectionalLight(vec3(0., 1., 0.),\n                                 SKY_FILL_LIGHT);\n    lights[2] = DirectionalLight(normalize(-vec3(15.0, 0.0, 10.0)),\n                                 SUN_AMBIENT_LIGHT);\n    \n    lights[0] = DirectionalLight(normalize(vec3(15.0, 15.0, 10.0)),\n                                 SUN_KEY_LIGHT);\n    lights[1] = DirectionalLight(vec3(0., 1., 0.),\n                                 SKY_FILL_LIGHT);\n    lights[2] = DirectionalLight(normalize(-vec3(15.0, 0.0, 10.0)),\n                                 SUN_AMBIENT_LIGHT);\n    backgroundColor = SUN_KEY_LIGHT;\n    \n    vec3 albedo = vec3(0.5);\n    if (mush_or_cloud) {\n        albedo = vec3(1.0,0.5,1.0);\n    }\n    vec3 n = estimateNormal(intersection.position);\n        \n    vec3 color = albedo *\n                 lights[0].color *\n                 max(0.0, dot(n, lights[0].dir));\n    \n    if (intersection.distance > 0.0)\n    { \n        for(int i = 1; i < 3; ++i) {\n            color += albedo *\n                     lights[i].color *\n                     max(0.0, dot(n, lights[i].dir));\n        }\n    }\n    else\n    {\n        color = vec3(0.5, 0.7, 0.9);\n    }\n        color = pow(color, vec3(1. / 2.2));\n        return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Make symmetric [-1, 1]\n    uv = uv * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = getSceneColor(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Smooth combination and SDF geometry operators attributed to Inigo Quilez\n// https://iquilezles.org/ @iquilezles\n\nconst int MAX_RAY_STEPS = 128;\nconst float FOV = 45.0;\nconst float EPSILON = 1e-2;\n\nconst vec3 EYE = vec3(0.0, 2.5, 5.0);\nconst vec3 REF = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_UP = vec3(0.0, 1.0, 0.0);\nconst vec3 WORLD_RIGHT = vec3(-1.0, 0.0, 0.0);\nconst vec3 WORLD_FORWARD = vec3(0.0, 0.0, 1.0);\nconst vec3 LIGHT_DIR = vec3(0.6, 1.0, 0.4) * 1.5;\n\n// Want sunlight to be brighter than 100% to emulate\n// High Dynamic Range\n#define SUN_KEY_LIGHT vec3(0.6, 1.0, 0.4) * 1.5\n// Fill light is sky color, fills in shadows to not be black\n#define SKY_FILL_LIGHT vec3(0.7, 0.2, 0.7) * 0.2\n// Faking global illumination by having sunlight\n// bounce horizontally only, at a lower intensity\n#define SUN_AMBIENT_LIGHT vec3(0.6, 1.0, 0.4) * 0.2\n\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Intersection \n{\n    vec3 position;\n    vec3 normal;\n    float distance;\n    int material_id;\n};\n\nstruct DirectionalLight\n{\n    vec3 dir;\n    vec3 color;\n};\n\n\nfloat sphereSDF(vec3 query_position, vec3 position, float radius)\n{\n    return length(query_position - position) - radius;\n}\n\nfloat planeSDF(vec3 queryPos, float height)\n{\n    return queryPos.y - height;\n}\n\nfloat capsuleSDF( vec3 queryPos, vec3 a, vec3 b, float r )\n{\n  vec3 pa = queryPos - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nfloat smoothSubtraction( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\nvec3 bendPoint(vec3 p, float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}","name":"Common","description":"","type":"common"}]}