{"ver":"0.1","info":{"id":"Ds2cRK","date":"1689209420","viewed":48,"name":"[steve] Towards Light","username":"import_shader_steve","description":"Mouse click to move the light ball. Inspired by: https://www.instagram.com/p/Ct1WIMkIEVb/?hl=en. ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["light","motion","extrusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define blur 0.01\n#define S(a, b, n) smoothstep(a, b, n)\n\nvec2 Rot(vec2 uv, float r) {\n    return mat2(cos(r), -sin(r), sin(r), cos(r)) * uv;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 offset, in float angle, in vec2 b, in vec4 r )\n{\n    // vec2 xy = vec2(sin(iTime * 0.8), cos(iTime * 0.8));\n    // float angle = atan(xy.y, xy.x);\n    // p -= vec2(2., 1.);\n    // p = Rot(p, angle);\n    // above works with vertical 90 deg angle, but why does my method not compatible with 90 deg angle? Find out why later\n    \n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat Rect_old(vec2 uv, vec2 start, vec2 end, float h, float radius) {\n    uv -= (start + end) / 2.;\n    float r = atan(end.y - start.y, end.x - start.x);\n    uv = Rot(uv, r);\n    \n    float w = length(start - end);\n    //float vertical = length(uv.x) - w / 2.;\n    //float horizontal = length(uv.y) - h / 2.;\n    float vertical = S(blur, -blur, length(uv.x) - w / 2.);\n    float horizontal = S(blur, -blur, length(uv.y) - h / 2.);\n    float d = vertical * horizontal - radius; // somehow this rounding radius doesn't work. Find out why later\n    \n    return d;\n}\n\nfloat Grid(vec2 uv, float thickness) {\n    float d = 0.;\n    uv = fract(uv);\n    if (uv.x < thickness / 2. || uv.x > 1. - thickness / 2. || uv.y < thickness / 2. || uv.y > 1. - thickness / 2.) {\n        d = 1.;\n    }\n    return d;\n}\n\nfloat Remap01(float x, float low, float high) {\n    return clamp((x-low)/(high-low), 0., 1.);\n}\n\nfloat Remap(float x, float lowIn, float highIn, float lowOut, float highOut) {\n    float p = Remap01(x, lowIn, highIn);\n    return mix(lowOut, highOut, p);\n}\n\nfloat Remap01(vec2 x, vec2 low, vec2 high) {\n    return clamp(length(x - low)/length(high - low), 0., 1.);\n}\n\n// rounding - [0., 1.], the rounding radius, expressed by the percentage of float t (the thickness of the rectangle)\n// ts - start thickness, te - end thickness\n// bs - start brightness, be - end brightness\nvec2 Rect(vec2 uv, vec2 start, vec2 end, float ts, float te, float rounding, float bs, float be) {\n    // thickness dynamically change from start to end\n    float percentage = Remap01(uv, start, end);\n    float t = mix(ts, te, percentage); // dynamic thickness\n    float b = mix(bs, be, percentage); // dynamic brightness\n    b = pow(b, 2.5);\n\n    uv -= (start + end) / 2.;\n    float r = atan(end.y - start.y, end.x - start.x);\n    uv = Rot(uv, r);\n    \n    vec2 dimension = vec2(length(start - end), t) / 2.;\n    vec4 radii = vec4(t / 2. * rounding);\n    vec2 offset = (start + end) / 2.;\n    float d = sdRoundedBox(uv, offset, r, dimension, radii);\n    \n    float mask = smoothstep(blur, -blur, d); // output a fully opaque mask, for mixing color in the main loop\n    float color = mask * b; // the real gradient d value, used to put on top of the above mask\n    \n    return vec2(color, mask);\n}\n\nfloat Spark(vec2 uv, float r, float brightness) {\n    float d = length(uv) - r;\n    d = brightness * (1. / d);\n    d = pow(d, 2.);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    uv *= 2.;\n    \n    vec2 m = iMouse.xy / iResolution.xy;\n    m = vec2( Remap(m.x, 0., 1., -2., 2.), Remap(m.y, 0., 1., -2., 2.) ); // remap from [0., 1.] to [-2., 2.]\n    \n    vec3 col = vec3(0);\n    \n    // col += Grid(uv, 0.03) * vec3(0., 1., 0.);\n    \n    vec2 start = vec2(1., -1.);\n    start = m;\n    vec2 end = vec2(1., -1.);\n    \n    //float d = Rect(uv, start, end, .1, .4, 1., .01, 1.);\n    //col += d;\n    \n    // float d = sdRoundedBox(uv, vec2(1., 0.3), vec4(.3));\n    // d = S(blur, -blur, d);\n    // col += d;\n    \n    // draw 1, 2, 3, 5 rows, and the draw row 4 at last, b/c it overlaps everything else\n    for (float i = -2.; i <= 2.; i++) {\n        for (float j = -2.; j <= 2.; j++) {\n            // if (i == 1.) continue;\n            end = vec2(i, j);\n            vec2 result = Rect(uv, start, end, .1, .4, 1., .3, 1.);\n            col = mix(col, vec3(1.) * result.x, result.y);\n        }\n    }\n    \n    col += Spark(uv - m, .0, .3);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}