{"ver":"0.1","info":{"id":"Xs3cDj","date":"1520160644","viewed":407,"name":"sky and sun 2d","username":"lz","description":"simple 2d sky and sun. Mouse x value switches between 2d and 3d look.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","fbm","sky","warp"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n#define PI 3.14\n\nvec2 hash2(in vec2 uv)\n{\n  return fract(vec2(sin(uv.x*1834538.331),\n               sin(uv.y*617678.44)));\n}\n\nfloat hash(in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat hash(in vec3 p)\n{\n  return fract(sin(dot(p,\n    vec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nfloat noise3(in vec3 p)\n{\n  vec3 pi = floor(p);\n  vec3 pf = fract(p);\n\n  pf = pf*pf*(3.-2.*pf);\n\n  float a = hash(pi + vec3(0., 0., 0.));\n  float b = hash(pi + vec3(1., 0., 0.));\n  float c = hash(pi + vec3(0., 1., 0.));\n  float d = hash(pi + vec3(1., 1., 0.));\n\n  float e = hash(pi + vec3(0., 0., 1.));\n  float f = hash(pi + vec3(1., 0., 1.));\n  float g = hash(pi + vec3(0., 1., 1.));\n  float h = hash(pi + vec3(1., 1., 1.));\n\n  return mix(mix(mix(a,b,pf.x),mix(c,d,pf.x),pf.y),\n  mix(mix(e,f,pf.x),mix(g,h,pf.x),pf.y), pf.z);\n}\n\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 uv) {\n  float f = .5*noise(uv);\n  vec2 off = vec2(0.01, 0.01);\n  f += .25*noise(uv*2.02 + off);\n  f += .125*noise(uv*4.01 + off);\n  f += .065*noise(uv*8.03 + off);\n  f += .0325*noise(uv*16.012 + off);\n\n  return f;\n}\n\n#define red vec3(1.,0.,0.)\n#define yellow vec3(1.,1.,0.)\n#define blue vec3(0.,0.,1.)\n#define white vec3(1.,1.,1.)\n#define ocean vec3(0.,0.6,0.93)\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 tuv = iMouse.xy/iResolution.xy;\n\n  uv.x *= iResolution.x/iResolution.y;\n  vec2 sc = uv-vec2(0.7,0.7);\n  float sr = dot(sc,sc);\n  float af = atan(sc.y, sc.x);\n  \n  vec3 sun = vec3(1.,1.,1.)*(1.-smoothstep(sr, 0.00,0.01));\n// sun = clamp(sun, 0.,1.);\n\n  vec2 duv = uv;\n    if (tuv.x > .5 && iMouse.z > 0.5) {\n        duv = vec2(uv.x*2. - 1., 1.)/(uv.y+0.1*(1.-uv.y));\n    }\n  float f = fbm(duv+tuv*4.);\n  float tt = 0.1*iTime;\n  float anf = noise(vec2(af*10. + tt*5., tt*4.));\n  float f2 = fbm(duv+2.*vec2(cos(f) + cos(tt), sin(f)+sin(tt)) );\n  vec3 sky = vec3(0.,0.,max(blue.b*(1.-sr), 0.));\n  vec3 col1 = mix(yellow, red, f);\n  vec3 col2 = mix(sky, white,\n    f2);\n  vec3 col = mix(col2, col1, f*f2);\n\n  //col = mix(vec3(0.,0.,0.), col, 2.*(  col.r*col.g));\n  col += sun*(4.*(1.-col.g)*exp(-col.g*4.));\n  //col = mix(col, sun, clamp(4.*(1.-col.g-col.r)*exp((-col.g-col.r)*4.), 0.,1.));\n  fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}