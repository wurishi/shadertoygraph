{"ver":"0.1","info":{"id":"3ttyWS","date":"1609826498","viewed":284,"name":"speakergif","username":"Carandiru","description":"effect for gif.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["gif","speakers"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WscfRl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0);\n\n    color = textureLod(iChannel0, uv, 0.0f).rgb;\n    \n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/WscfRl\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define SMOOOTHING (GOLDEN_RATIO * 10.0f * 2.0f)\n#define ZOOM 3.0f\n#define RADII GOLDEN_RATIO * 0.5f\n#define OFFSET RADII * 2.0f\n#define SEPERATION GOLDEN_RATIO\n\nconst vec3 gui_green = vec3(266.666e-3f, 913.725e-3f, 537.254e-3f);\nconst vec3 gui_bleed = vec3(619.607e-3f, 1.0f, 792.156e-3f);\n\nfloat ease_inout_quadratic(float A, float B, float tNorm)\n{\n#define Delta ((B-A)*0.5f)\n    tNorm *= 2.0f;\n    if (tNorm < 1.0f)\n        return(Delta * tNorm * tNorm + A);\n    --tNorm;\n    return(-Delta * (tNorm * (tNorm - 2.0f) - 1.0f) + A);\n#undef Delta\n}\n\n\nfloat sphere(vec2 uv, float radius)\n{\n    return(length(uv)-radius);\n}\nfloat speaker(vec2 uv, float radius)\n{    \n    return(length(uv)-(radius - ease_inout_quadratic(0.0f, 1.0f, radius)));\n}\nfloat speakers(vec2 uv, float radius)\n{\n    float hrad = radius * SEPERATION;\n    \n    float spk;\n    spk = speaker(uv, radius);\n    spk = min(spk, speaker(vec2(uv.x,uv.y-hrad), radius));\n    spk = min(spk, speaker(vec2(uv.x,uv.y+hrad), radius));\n    \n    return spk;\n}\n\n//Distance to a line segment,\nfloat line(vec2 start, vec2 end, float scale, vec2 uv)\n{\n\tstart *= scale;\n\tend *= scale;\n    \n\tvec2 line = end - start;\n\tfloat frac = dot(uv - start,line) / dot(line,line);\n\treturn distance(start + line * clamp(frac, 0.0, 1.0), uv);\n}\nfloat lines(vec2 start, vec2 end, float scale, vec2 uv, float radius)\n{\n    float hrad = radius * SEPERATION;\n    \n    float ln;\n    ln = line(start, end, scale, uv);\n    ln = min(ln, line(vec2(start.x, start.y-hrad),\n                      vec2(end.x, end.y-hrad), scale, uv));\n    ln = min(ln, line(vec2(start.x, start.y+hrad),\n                      vec2(end.x, end.y+hrad), scale, uv));\n                      \n    return ln;\n}\n\nfloat toGray(float dist)\n{\n    float fH = 0.5f * fwidth(dist);\n    \n    return( smoothstep(fH, -fH, dist) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 sampling = textureLod(iChannel0, uv, 0.0f); // prev-frame\n    float ln0 = sampling.w;\n    vec3 color = sampling.rgb * SMOOOTHING * iTimeDelta;\n    \n    float fT = fract(iTime);\n    \n    uv = 2.0f * uv - 1.0f;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= ZOOM * (max(0.0f, fT + 0.5f*fT) * 1.5f);\n    \n    float tT = ease_inout_quadratic(0.0f, 1.0f, fT);\n    \n    vec2 result = uv;\n    \n    vec2 p0 = vec2(uv.x-OFFSET,uv.y);\n    vec2 p1 = vec2(uv.x+OFFSET,uv.y);\n    \n    float rT = RADII*tT;\n    color += gui_green * toGray(speakers(p0, rT));\n    color += gui_green * toGray(speakers(p1, rT));\n    \n    float ln1 = 0.004f/(lines(p0, p1, 1.0f/6.0f * ZOOM, uv, rT));\n    \n    float ln = mix(ln0, ln1, 0.5f);\n    \n    //ln = pow(ln, 5.0f);\n    color += gui_bleed * ln;\n    \n    \n    fragColor = vec4(color, ln1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define GOLDEN_RATIO (1.61803398874989484820)","name":"Common","description":"","type":"common"}]}