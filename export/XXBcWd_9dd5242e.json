{"ver":"0.1","info":{"id":"XXBcWd","date":"1727853716","viewed":11,"name":"Océan simple (non optimisé)","username":"Aiskal","description":"Océan simulation (FR)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sinusoid","eau"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Variables globales\nfloat MOUSE_SENSI = 3.14;\nfloat MAX_DIST = 100.0; //Render distance (warning fps)\nfloat Y_CAM = 2.5; //Hauteur caméra\n\nint RAY_MAX = 1000;\nint MAX_WAVES = 100;\nfloat MAX_AMP = 0.06;  // Amplitude de l'onde\nfloat MAX_FREQ = 0.8;  // Fréquence de l'onde\nfloat MAX_OFFSET = 1.0;\nfloat MAX_SPEED = 1.5;      // Vitesse de l'animation\n\nfloat NOISE_FREQ = 1.9;\n\nvec3 BG_COLOR = vec3(0.53, 0.81, 0.99);  //Bleu jour\n//vec3 BG_COLOR = vec3(0.1,0.1,0.2); // Bleu nuit\n//vec3 BG_COLOR = vec3(0.1, 0.3, 0.15); //Vert\nvec3 SEA_COLOR = vec3(0.15, 0.15, 0.17);\nvec3 FOAM_COLOR = vec3(0.9, 0.9, 1.0);\nfloat FOAM_THRESHOLD = 0.15;\nfloat FOAM_BLUR = 2.0;\nvec3 LIGHT_DIR = normalize(vec3(0.5, 0.5, 0.5));\n\n\n// Normalisation des coordonnées d'écran\nvec2 normalizeCoords(vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    return uv;\n}\n\n\n//Fonction de random grâce à la fonction de bruit\nfloat random(float x) {\n    return fract(sin(x * 1.5) * 43758.5453) * 2.0 - 1.0;\n}\nfloat randomMax(float x, float maxValue) {\n    return random(x) * maxValue;\n}\nfloat noise(vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n// Fonction sinusoidale\nfloat waveFunction(vec3 p) {\n    float totalWave = 0.0;\n    \n    for (int i = 0; i < MAX_WAVES; i++) {\n        float uniqueSeed = float(i);\n    \n        float amplitude = randomMax(uniqueSeed, MAX_AMP); // Amplitude pour chaque vague\n        float frequency = randomMax(uniqueSeed * 2.0, MAX_FREQ); // Fréquence\n        float speed = randomMax(uniqueSeed * 3.0, MAX_SPEED); // Vitesse\n        float offset = randomMax(uniqueSeed * 4.0, MAX_OFFSET); // Décalage\n        \n        float angle = random(uniqueSeed * float(i)) * 3.14159; // Angle en radians\n        vec2 direction = vec2(cos(angle), sin(angle)); // Vecteur directionnel\n        \n        float noiseFactor = p.x + p.z + iTime;\n\n        //totalWave += amplitude * sin(frequency * (p.x * direction.x + p.z * direction.y) + iTime * speed + offset + noiseFactor);\n        totalWave += amplitude * exp(sin(frequency * (p.x * direction.x + p.z * direction.y) + iTime * speed + offset + noiseFactor)-1.0);\n    }\n\n    return totalWave;\n}\n\n\n// Distance au plan déformé\nfloat sceneSDF(vec3 p) {\n    return p.y - (waveFunction(p) - Y_CAM);\n}\n\n\n// Calcul de la normale à la surface (pour la lumière)\nvec3 getNormal(vec3 p) {\n    float epsilon = 0.01;\n    float d = sceneSDF(p);\n    vec3 normal = vec3(\n        sceneSDF(p + vec3(epsilon, 0.0, 0.0)) - d,\n        sceneSDF(p + vec3(0.0, epsilon, 0.0)) - d,\n        sceneSDF(p + vec3(0.0, 0.0, epsilon)) - d\n    );\n    return normalize(normal);\n}\n\n\n// Couleur et éclairage\nvec3 calculateColor(vec3 hitPoint) {\n    vec3 color = SEA_COLOR;  // Couleur de base\n\n    // Calcul de l'éclairage diffus\n    vec3 normal = getNormal(hitPoint);\n    float lighting = max(dot(normal, LIGHT_DIR), 0.0); // Intensité de la lumière\n    color *= lighting; // Appliquer l'éclairage à la couleur\n\n    // Calcul de la réflexion spéculaire\n    vec3 viewDir = normalize(-hitPoint); // Direction de la caméra\n    vec3 reflectDir = reflect(-LIGHT_DIR, normal); // Direction de la réflexion\n    float specularStrength = 1.5; // Force de la réflexion spéculaire\n    float shininess = 20.0; // Détermine la douceur de la réflexion\n    float spec = pow(max(dot(reflectDir, viewDir), 0.0), shininess); // Calcul de la composante spéculaire\n    color += specularStrength * spec; // Ajouter la réflexion spéculaire à la couleur\n\n    // Effet de damier si souhaité\n    if (mod(floor(hitPoint.x) + floor(hitPoint.z), 2.0) < 1.0) {\n        color *= 0.9;\n    }\n    \n    float waveHeight = waveFunction(hitPoint);\n\n    float depth = -sceneSDF(hitPoint);\n    float depthFactor = clamp(depth / 10.0, 0.0, 3.0);\n    color = mix(color, SEA_COLOR, depthFactor); // Remettre de la couleur d'eau en fonction de la profondeur\n    color = mix(color, BG_COLOR, (1.0 - depthFactor) * 0.3);\n\n    // Appliquer l'écume\n    if (waveHeight > FOAM_THRESHOLD) {\n        float foamFactor = clamp((waveHeight - FOAM_THRESHOLD) / FOAM_BLUR, 0.0, 1.0);\n        color = mix(color, FOAM_COLOR, foamFactor);\n    }\n\n    return color;\n}\n\n\n\n// Flou en distance\nvec3 applyBlurEffect(float t, vec3 color) {\n    if (t > MAX_DIST) {\n        float blurFactor = clamp((t - MAX_DIST) / (MAX_DIST * 2.5), 0.0, 1.0);  // Normaliser et limiter\n        color = mix(BG_COLOR, color, 1.0 - blurFactor);  // Interpolation vers le noir\n    }\n    return color;\n}\n\n\n// Gestion de la Camera\nvec3 getCameraRay(vec2 uv) {\n    vec3 camPos = vec3(0.0, 10.0, 0.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n\n    float yaw = mouse.x * MOUSE_SENSI; // Rotation horizontale (yaw)\n    float pitch = clamp(mouse.y, -0.5, 0.5) * 1.57; // Rotation verticale\n\n    vec3 forward = normalize(vec3(sin(yaw), pitch, cos(yaw)));  // Vecteur de direction de la caméra\n    vec3 right = normalize(vec3(cos(yaw), 0.0, -sin(yaw)));     // Axe X pour la caméra\n    vec3 up = vec3(0.0, 1.0, 0.0);  // Axe Y fixe\n    return normalize(forward + uv.x * right + uv.y * up); // Retourne la direction du rayon\n}\n\n\n// Ray Marching\nvec3 rayMarch(vec3 camPos, vec3 rayDir) {\n    float t = 0.0;\n    \n    for (int i = 0; i < RAY_MAX; i++) {\n        vec3 p = camPos + rayDir * t;  // Point sur la direction du rayon\n        float d = sceneSDF(p);          // Distance à la surface\n\n        if (d < 0.01) { // Si proche de la surface\n            vec3 color = calculateColor(p);\n            return applyBlurEffect(t, color);\n        }\n\n        t += d; // Avancer le long du rayon\n        if (t > MAX_DIST) break; // Limite de distance\n    }\n    \n    return BG_COLOR; // Retour à la couleur d'arrière-plan si pas de contact\n}\n\n\n// Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.3;\n    vec2 uv = normalizeCoords(fragCoord);\n    \n    ////////////// - CAMERA - ////////////\n    vec3 rayDir = getCameraRay(uv);\n    \n    // Ray Marching\n    vec3 color = rayMarch(vec3(0.0, 4.0, 0.0), rayDir);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}