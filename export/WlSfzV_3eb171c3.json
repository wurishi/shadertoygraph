{"ver":"0.1","info":{"id":"WlSfzV","date":"1612130702","viewed":83,"name":"sphere_merging23","username":"edwardbraed","description":"Raymarch smooth union tests","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","smooth","union"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS_MARCH 32\n#define SPHERE_RADIUS 0.6\n#define LIGHT_COLOR vec3(0.6, 0.5, 1.0)\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\n//thanks iq :)\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat raymarch(vec3 ro, vec3 rd1, vec3 rd2, vec3 lv, float g)\n{\n    float t = 0.0;\n    for(int x = 0; x < MAX_STEPS_MARCH; x++)\n    {\n        vec3 pos1 = ro + rd1 * t;\n        vec3 pos2 = ro + rd2 * t;\n        float d1 = length(pos1) - SPHERE_RADIUS;\n        float d2 = length(pos2) - SPHERE_RADIUS;\n        float d = opSmoothUnion(d1, d2, 0.6);\n        \n        if(d < 0.001)\n        {   \n            float l1 = max(dot(normalize(lv - pos1), normalize(pos1)), 0.0);\n            float l2 = max(dot(normalize(lv - pos2), normalize(pos2)), 0.0);\n            \n            return max(max(l1, l2), 0.2);\n        }\n        \n        t += d;\n    }\n    \n    return g;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // aspect ratio for correction rays..\n    vec2 aspect = calcAspect(iResolution.xy);\n    \n    // pseudo perspective pyramid (directions rays)\n    vec2 dTr = vec2(1.0, 1.0);\n    vec2 dTl = vec2(-1.0, 1.0);\n    vec2 dBr = vec2(1.0, -1.0);\n    vec2 dBl = vec2(-1.0, -1.0);\n    \n    // common uv ray direction\n    vec2 uvrd = mix(mix(dBl, dBr, uv.x),\n                    mix(dTl, dTr, uv.x), uv.y) * aspect;\n    \n    // position spheres 1 and 2\n    vec3 p1 = vec3(sin(iTime * 0.7) * 0.9, 0.0, 1.0);\n    vec3 p2 = vec3(-p1.x, p1.y, p1.z);\n    \n    // rays direction for positions sphere 1 and 2\n    vec3 rd1 = vec3(uvrd + p1.xy, p1.z);\n    vec3 rd2 = vec3(uvrd + p2.xy, p2.z);\n    \n    // origin direction (or pseudo camera position)\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    // light direction\n    vec3 lv = vec3(0.0, 2.0, -2.0);\n    \n    float g = 1.1 - abs(uv.y - 0.4);\n    g = g*g*g*g;\n    \n    vec3 rgb = LIGHT_COLOR * raymarch(ro, rd1, rd2, lv, g);\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}