{"ver":"0.1","info":{"id":"X3BBDh","date":"1729359918","viewed":66,"name":"PORT-AI-LS","username":"Sergeindamix","description":"AI GEN WITH FREE MODELS LIKE CLAUDE, CHATGPT AND VERCEL","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["claude","ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define PORTAL_COUNT 4\n#define PORTAL_SPACING 5.0  // Aumentado para mayor separación\n#define PORTAL_POS vec3(0.0, 2.5, -10.0)  // Movido más cerca de la cámara\n#define PORTAL_SIZE vec3(3.0, 2.0, 0.1)  // Aumentado el tamaño\n#define SCROLL_SENSITIVITY 0.005  // Reducido para un movimiento más suave\n#define WALL_OFFSET 4.0  // Desplazamiento horizontal para las \"paredes\"\n\n\n#define START_OFFSET vec3(0.,0.4,1.2)\n#define PORTAL_BORDER vec3(0.15,0.15, 0.)\n#define PILLAR_WIDTH_HALF .15\n#define PILLAR_SPACING 2.1\n\n#define CIRCLE_RADIUS 10.0\n#define ROTATION_SPEED 0.2\n\n\n\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat hash12( vec2 p ) {\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x ) {\n    vec2 f = fract(x);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 p = vec2(floor(x));\n    float a = hash12( (p+vec2(0,0)) );\n    float b = hash12( (p+vec2(1,0)) );\n    float c = hash12( (p+vec2(0,1)) );\n    float d = hash12( (p+vec2(1,1)) );\n\n    return a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y;\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat fbm( in vec2 p, const int OCTAVES ) {\n    float a = 0.;\n    float b = .5;\n    for( int i=0; i<OCTAVES; i++ ) {\n        a += noise(p) * b;\n        b *= 0.5;\n        p = m2*p;\n    }\n    return a;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\nmat2 Rotate2D(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat GetDist(vec3 p) {            \n    float room = -sdBox(p, vec3(10, 5, 20));\n    float spheres = sdSphere(mod(p + 1.0, 2.0) - 1.0, 0.5);\n    float ground = p.y;\n    float d = min(min(room, spheres), ground);\n\n\n    // Rotación automática\n    float rotationAngle = iTime * ROTATION_SPEED;\n    p.xz *= Rotate2D(rotationAngle);\n\n    for (int i = 0; i < PORTAL_COUNT; i++) {\n        float angle = float(i) * (2.0 * 3.14159 / float(PORTAL_COUNT));\n        vec3 portalPos = vec3(CIRCLE_RADIUS * cos(angle), 0, CIRCLE_RADIUS * sin(angle));\n\n        // Rotamos el portal para que siempre mire hacia el centro\n        vec3 localP = p - portalPos;\n        localP.xz *= Rotate2D(-angle);\n\n        float portal = sdBox(localP, PORTAL_SIZE)/0.0;\n        d = min(d, portal);\n        d=portal;\n    }\n\n    return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n\n    return normalize(n);\n}\n\nfloat SoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        if(t < maxt) {\n            float h = GetDist(ro + rd*t);\n            if(h < 0.001)\n                return 0.0;\n            res = min(res, k*h/t);\n            t += h;\n        }\n    }\n    return res;\n}\n\nvec3 GetLight(vec3 p, vec3 rd) {\n    vec3 lightPos = vec3(0, 5, 0);\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n\n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = SoftShadow(p, l, 0.02, 2.5, 32.0);\n    dif *= d;\n\n    vec3 r = reflect(-l, n);\n    float spec = pow(clamp(dot(r, -rd), 0., 1.), 32.);\n    spec *= d;\n\n    return vec3(dif) + vec3(spec);\n}\n\nvec3 RayMarch(in vec3 ro, in vec3 rd, in vec2 uv, bool inside) {\n    float portalAlpha = 0.;\n    vec3 fogColor = vec3(0.1,0.3,.5) + rd * .1;\n    float tmin = 0.01;\n    const float tmax = 21.;\n\n    float closestPortalDist = 1e5;\n    int closestPortalIndex = -1;\n\n    // Rotación automática\n    float rotationAngle = iTime * ROTATION_SPEED;\n    mat2 rotMat = Rotate2D(rotationAngle);\n\n    for (int i = 0; i < PORTAL_COUNT; i++) {\n        float angle = float(i) * (2.0 * 3.14159 / float(PORTAL_COUNT));\n        vec3 portalPos = vec3(CIRCLE_RADIUS * cos(angle), 0, CIRCLE_RADIUS * sin(angle));\n        portalPos.xz = rotMat * portalPos.xz;  // Aplicar rotación\n        vec3 portalNormal = normalize(-portalPos);\n        float portalDist = dot(portalPos - ro, portalNormal) / dot(rd, portalNormal);\n\n        if (portalDist > 0. && portalDist < closestPortalDist) {\n            closestPortalDist = portalDist;\n            closestPortalIndex = i;\n        }\n    }\n\n    vec3 portalColor = vec3(0.1, 0.5, 1.0);\n    if (closestPortalIndex >= 0) {\n        vec3 portalPos = PORTAL_POS + vec3(0, 0, float(closestPortalIndex) * PORTAL_SPACING);\n        vec3 p = ro + rd * closestPortalDist;\n\n        // Calcular la posición local del portal\n        float angle = float(closestPortalIndex) * (2.0 * 3.14159 / float(PORTAL_COUNT));\n        portalPos = vec3(CIRCLE_RADIUS * cos(angle), 0.0, CIRCLE_RADIUS * sin(angle));\n        portalPos.xz = rotMat * portalPos.xz;  // Aplicar rotación\n\n        vec3 localP = p - portalPos;\n        localP.xz *= Rotate2D(-angle - rotationAngle);\n        float time = T * .15;\n        float scale = 6.;\n        vec2 offset = vec2(fbm(p.xy * scale + time, 4), fbm(p.yx * scale - time, 4)) -.5;\n        p.xy += (fbm(offset * scale + time, 4) - .5) * .2;\n        if(all(lessThan(abs(p.xy-portalPos.xy),PORTAL_SIZE.xy))) {\n            vec2 bd = abs(p.xy-portalPos.xy) - (PORTAL_SIZE.xy -PORTAL_BORDER.xy);\n            bd = max(bd, vec2(0))/PORTAL_BORDER.xy;\n\n            portalAlpha = 1.-smoothstep(0.5, 1., length(bd));\n\n            // Use different channel for each portal\n            if (closestPortalIndex == 0) portalColor = texture(iChannel0, uv).rgb;\n            else if (closestPortalIndex == 1) portalColor = texture(iChannel1, uv).rgb;\n            else if (closestPortalIndex == 2) portalColor = texture(iChannel2, uv).rgb;\n            else if (closestPortalIndex == 3) portalColor = texture(iChannel3, uv).rgb;\n\n            portalColor *= 1.25; // Increase brightness\n        }\n        if(inside) {\n            tmin = closestPortalDist;\n        }\n    }\n\n    float dO=0.;\n    vec3 col = vec3(0);\n\n    for(int i=0; i<MAX_STEPS; i++) {\n        vec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n\n    if(dO<MAX_DIST) {\n        vec3 p = ro + rd * dO;\n        vec3 n = GetNormal(p);\n        vec3 light = GetLight(p, rd);\n        col = light;\n\n        float fresnel = pow(1. + dot(rd, n), 5.);\n        col = mix(col, fogColor, fresnel);\n    } else {\n        col = fogColor;\n    }\n\n    portalAlpha = inside ? 1. - portalAlpha : portalAlpha;\n\n    if (!inside && dO < closestPortalDist) {\n        portalAlpha = 0.;\n    }\n\n    const float C = .075;\n    const float B = 1.1;\n    float fogAmount = clamp(C * exp(-ro.y*B) * (1.-exp( -dO*rd.y*B))/rd.y, 0., 4.);\n    col = mix(col, fogColor, fogAmount);\n\n    col = mix(col, sqrt(clamp(col,vec3(0),vec3(1))), .95);\n\n    col = mix(col, portalColor, portalAlpha);\n\n    return clamp(col,vec3(0),vec3(1));\n}\n\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r =   normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    // Ajustamos la posición inicial de la cámara\n    vec3 ro = vec3(0, 0, -CIRCLE_RADIUS);\n\n    // Permitimos rotación con el mouse\n    ro.yz *= Rot(-m.y * 3.14 + 0.5);\n    ro.xz *= Rot(-m.x * 6.2831);\n\n    vec3 rd = GetRayDir(uv, ro, vec3(0, 0, 0), 1.);\n    vec3 col = RayMarch(ro, rd, gl_FragCoord.xy/iResolution.xy, false);\n\n\n\n\n    //col = pow(col, vec3(.4545));\t// gamma correction\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float PI = 3.1415926535;\nconst float EPSILON = 0.0005;\n\n\n// ======================= some linear algebra =======================\n\nmat3 rotateX(float angle){\n\treturn mat3(\n\t\t1., 0., 0.,\n\t\t0., cos(angle),  sin(angle),\n\t\t0., -sin(angle), cos(angle)\n\t);\n}\n\nmat3 rotateY(float angle){\n\treturn mat3(\n\t\tcos(angle), 0., sin(angle),\n\t\t0., 1.,  0.,\n\t\t-sin(angle), 0., cos(angle)\n\t);\n}\n\nmat3 rotateZ(float angle){\n\treturn mat3(\n\t\tcos(angle),  sin(angle), 0., \n\t\t-sin(angle), cos(angle), 0., \n\t\t0., 0., 1.\n\t);\n}\n\nstruct AffineMap {\n\tmat3 linear;\n\tvec3 translation;\n};\n\nvec3 apply(AffineMap map, vec3 p){\n\treturn map.linear*(p-map.translation);\n}\n\n// ============================== Material ==============================\n\nstruct Material {\n\tvec3 color;\n\tfloat reflectionFactor;\n    int world;\n};\n\nconst Material RedMaterial = Material(vec3(1.,0.,0.), 0.03, 1);\nconst Material GreenMaterial = Material(vec3(0.,1.,0.), 0.3, 1);\nconst Material BlueMaterial = Material(vec3(0.,0.,1.), 0.3, 1);\nconst Material GrayMaterial = Material(vec3(0.3), 0.3, 1);\nconst Material BlackMaterial = Material(vec3(0.0), 0., 1);\n\n// ============================== Objects ==============================\n\nconst float MAX_DIST = 1000000.;\n\nstruct RayInfo {\n\tfloat d;\n\tMaterial material;\n};\n\nRayInfo minDistance(RayInfo info1, RayInfo info2){\n\tif (info1.d<info2.d)\n\t\treturn info1;\n\treturn info2;\n}\n\n// ------------------------------- sphere -------------------------------\n\n// A sphere of radius r centered around the origin\nstruct Sphere {\n\tfloat r;\n\tMaterial material;\n};\n\nRayInfo distSphere(vec3 p, Sphere sphere){\n\treturn RayInfo(length(p) - sphere.r, sphere.material);\n}\n\n// ------------------------------- torus -------------------------------\n\n// A torus center around the origin in the XY plane with big radius R and small radius r.\nstruct Torus {\n\tfloat R;\n\tfloat r;\n\tMaterial material;\n};\n\nRayInfo distTorus(vec3 p, Torus torus){\n\tfloat xyRadius = torus.R - length(p.xy);\n\treturn RayInfo(sqrt(xyRadius*xyRadius+p.z*p.z) - torus.r, torus.material);\n}\n\n// ------------------------------- cylinder -------------------------------\n\n// A cylinder on the X axis, centered at x0.\nstruct Cylinder {\n\tfloat x0;\n\tfloat r;\n\tfloat len;\n\tMaterial material;\n};\n\nRayInfo distCylinder(vec3 p, Cylinder cylinder){\n\tfloat radial = length(p.yz)-cylinder.r;\n\tfloat x = abs(p.x-cylinder.x0)-cylinder.len/2.;\n\t// At this point, we can think of the distnace from the cylinder as the distance of the nonnegative\n\t// point (abs(p.x), length(p.yz)) from the rectangle [0,cylinder.len/2]x[0,cylinder.r].\n\t// If the point is right off, above or indise the rectangle, then the distance is just the minimum distance from \n\t// the edges. Otherwise, it is the distance from the vertex (cylinder.len/2, cylinder.r).\n\t\t\n\t// outside \"corner\" points\n\tif (x>=0. && radial>=0.)\n\t\treturn RayInfo(length(vec2(x, radial)), cylinder.material);\n\t\t\n\treturn RayInfo(max(x, radial), cylinder.material);\n}\n\n// ------------------------------- Rotating torus -------------------------------\n\nstruct RotatingTorus {\n\tTorus torus;\n\tCylinder cylinder1;\n\tCylinder cylinder2;\n};\n\nRayInfo distRotatingTorus(vec3 p, RotatingTorus rotTorus){\n\tRayInfo info = RayInfo(MAX_DIST, RedMaterial);\n\tinfo = minDistance(info, distTorus(p, rotTorus.torus));\n\tinfo = minDistance(info, distCylinder(p, rotTorus.cylinder1));\n\tinfo = minDistance(info, distCylinder(p, rotTorus.cylinder2));\n\treturn info;\n}\n\n// ------------------------------- Card -------------------------------\n\n// A card centered on the origin with width in the X direction and height in the Y direction.\nstruct Card {\n\tfloat width;\n    float height;\n};\n\nRayInfo distCard(vec3 p, Card card){\n    if (abs(p.x) <= card.width/2. && abs(p.y) <= card.height/2.){\n        // in front or in the back of the card.\n        vec2 uv = p.xy + vec2(card.width/2., card.height/2.);\n        uv *= (4./card.width);\n        uv -= floor(uv) + 0.5; // in [-0.5,0.5]x[-0.5,0.5]\n        \n        vec3 color = vec3(step(abs(uv.x)+abs(uv.y),0.5),0.0,0.);\n        int world = 0;\n        if (p.z>0.){\n            // front of card\n            if (abs(p.x)*2./card.width>0.9 || abs(p.y)*2./card.height>0.9){\n                // edge of card\n                color = vec3(0.3);\n            } else {\n                // middle of card - move to the other world\n                world = 1;\n            }\n        }\n        return RayInfo(abs(p.z+2.*EPSILON)-2.*EPSILON, Material(color, 0., world));\n    }\n    \n\tp = abs(p);\n    p -= vec3(card.width/2., card.height/2., 0.);\n    p = max(vec3(0),p);\n    return RayInfo(length(p), Material(vec3(0), 0., 0));\n}\n\n\n\n// ============================== Scene ==============================\n\nconst float torusR = 0.3;\nconst float outerR = 3.;\nconst float innerR = 1.5;\nconst float sphereR = innerR - torusR*2.;\nconst float midR = (outerR+innerR)/2.;\nconst float cylinderLength = (outerR-midR);\n\nconst Sphere sphere = Sphere(\n\tsphereR, Material(vec3(1), 0.8, 1)\n);\n\nconst RotatingTorus part1 = RotatingTorus(\n\t Torus(outerR, torusR, RedMaterial),                   \t\t\t\t\n\t Cylinder(outerR*21., 0.1, outerR*40., GrayMaterial),\t\t\t\t\t\t \n\t Cylinder(-outerR*21., 0.1, outerR*40., GrayMaterial)\n);\n\nAffineMap map1 = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nconst RotatingTorus part2 = RotatingTorus(\n\t Torus(midR, torusR, GreenMaterial),                 \n\t Cylinder((midR+outerR)/2., 0.1, outerR-midR, GrayMaterial),          \n\t Cylinder(-(midR+outerR)/2., 0.1, outerR-midR, GrayMaterial)\n);\n\nAffineMap map2 = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nconst RotatingTorus part3 = RotatingTorus(\n\t Torus(innerR, torusR, BlueMaterial),                 \n\t Cylinder((midR+innerR)/2., 0.1, midR-innerR, GrayMaterial),          \n\t Cylinder(-(midR+innerR)/2., 0.1, midR-innerR, GrayMaterial)\n);\n\nAffineMap map3 = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nCard card = Card(4.,4.);\nAffineMap cardMap = AffineMap(\n\t mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),\n\t vec3(0.)\n);\n\nRayInfo distScene(vec3 p){\n\tRayInfo info = RayInfo(MAX_DIST, BlackMaterial);\n    \n\tp = apply(cardMap, p);\n\tinfo = minDistance(info, distCard(p, card));\n\treturn info;\n}\n\nRayInfo distSceneInCard(vec3 p){\n\tRayInfo info = RayInfo(MAX_DIST, BlackMaterial);\n\tp = apply(cardMap, p);\n    p += vec3(0.,0.,5.);\n\tinfo = minDistance(info, distSphere(p, sphere));\n\tp = apply(map1, p);\n\tinfo = minDistance(info, distRotatingTorus(p, part1));\n\tp = apply(map2, p);\n\tinfo = minDistance(info, distRotatingTorus(p, part2));\n\tp = apply(map3, p);\n\tinfo = minDistance(info, distRotatingTorus(p, part3));\n\treturn info;\n}\n\nvoid sceneUpdate(){\n\tmap1.linear = rotateX(iTime)*rotateZ(PI/4.);\n\tmap2.linear = rotateZ(PI/2.)*rotateY(iTime*2./3.);\n\tmap3.linear = rotateZ(PI/2.)*rotateY(iTime/2.);\n    \n    if (iMouse.xy == vec2(0.))\n        return;\n    \n    vec2 mouseDir = iMouse.xy - iResolution.xy/2.;\n    if (mouseDir.x == 0. && mouseDir.y == 0.) // value when program starts\n        return;\n        \n    vec3 axis = normalize(vec3(-mouseDir.y, mouseDir.x, 0.));\n    vec3 u = vec3(axis.y, -axis.x, 0.);\n    vec3 v = vec3(0.,0.,1.);\n    mat3 basis = mat3(axis.xyz, u.xyz, v.xyz);\n    \n    float tt = PI*length(mouseDir)/iResolution.y;\n    mat3 newBasis = mat3(axis.xyz, (cos(tt)*u+sin(tt)*v).xyz, (cos(tt)*v-sin(tt)*u).xyz);\n    \n\tcardMap.linear = rotateY(PI+2.*PI*iMouse.x/iResolution.x)*rotateZ(PI+2.*PI*iMouse.y/iResolution.y);\n\tcardMap.linear = newBasis*inverse(basis);\n}\n\n// ============================ Ray March ============================\n\nconst float MIN_DEPTH = 0.001;\n\nRayInfo simpleRayMarch(vec3 origin, vec3 direction, float start, float end, int world) {\n\tRayInfo info;\n    float depth = start;\n\n    for (int i = 0; i < 255; i++) {\n        vec3 p = origin + depth * direction;\n        if (world==1)\n            info = distSceneInCard(p);\n        else \n            info = distScene(p);\n        depth += info.d;\n        if (info.d < MIN_DEPTH || depth > end) break;\n    }\n\tif (depth > end)\n        if (world==0)\n            return RayInfo(MAX_DIST, Material(texture(iChannel0, direction).rgb,0.,0));\n        else\n            return RayInfo(MAX_DIST, Material(texture(iChannel1, direction).rgb,0.,0));\n\n  return RayInfo(depth, info.material);\n}\n\nvec3 calcNormal(vec3 p, int world) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON; // epsilon\n  float r = 1.; // radius of sphere\n  if (world==1)\n      return normalize(\n        e.xyy * distSceneInCard(p + e.xyy).d +\n        e.yyx * distSceneInCard(p + e.yyx).d +\n        e.yxy * distSceneInCard(p + e.yxy).d +\n        e.xxx * distSceneInCard(p + e.xxx).d);\n  else\n      return normalize(\n        e.xyy * distScene(p + e.xyy).d +\n        e.yyx * distScene(p + e.yyx).d +\n        e.yxy * distScene(p + e.yxy).d +\n        e.xxx * distScene(p + e.xxx).d);\n}\n\n\n// ============================ Light ============================\n\nstruct Light {\n\tvec3 position;\n\t\n\tfloat ambientFactor;\n\tvec3 ambientColor;\n\t\n\tfloat diffuseFactor;\n\tvec3 diffuseColor;\n\t\n\tfloat specularFactor;\n\tfloat specularAlpha;\n\tvec3 specularColor;\n};\n\nvec3 phong(vec3 p, vec3 normal, vec3 rayDirection, Light light) {\n\t\n\tvec3 lightDir = normalize(p-light.position);\n\n  // ambient\n  vec3 ambient = light.ambientFactor * light.ambientColor;\n\n  // diffuse\n  float dotLN = clamp(-dot(lightDir, normal), 0., 1.);\n  vec3 diffuse = light.diffuseFactor * dotLN * light.diffuseColor;\n\n  // specular\n  float dotRV = clamp(dot(reflect(lightDir, normal), -rayDirection), 0., 1.);\n  vec3 specular = light.specularFactor * pow(dotRV, light.specularAlpha) * light.specularColor;\n\n  return ambient + diffuse + specular;\n}\n\nconst Light light = Light(\n\tvec3(5., 0., 4.),\n\t0.0, vec3(0.7, 0.7, 0),\n\t1., vec3(1),\n\t0.6, 10., vec3(1)\n);\n\n// ============================ Main ============================\n\nconst int reflectionSteps = 4;\n\nvec4 rayMarch(vec3 origin, vec3 direction, float start, float end, int world) {\n\tRayInfo info;\n\tvec3 p = origin;\n\tfloat factor = 1.;\n\tvec3 color = vec3(0.);\n\tfloat depth = start;\n\tfor (int i=0; i<reflectionSteps; i++){\n\t\tinfo = simpleRayMarch(p, direction, start, end, world);\n\t\tdepth += (info.d-start);\n\t\t\n\t\tif (info.d == MAX_DIST){\n\t\t\tbreak;\n\t\t}\n\t\t\t\n\t\tp = p + direction * info.d; \n        \n        if (info.material.world!=world){\n            // portal to another world!\n            world = info.material.world;\n            start = 0.;\n            end = end - info.d;\t  // depth?\n            continue;\n        }\n        \n\t\tvec3 normal = calcNormal(p, world);\n\t\t// light\n        vec3 lightColor = phong(p, normal, direction, light);\n\t\tcolor += factor*(1.-info.material.reflectionFactor)*(info.material.color + lightColor)/2.;\n\t\tfactor *= info.material.reflectionFactor;\n\t\t\n\t\tif (end-info.d < MIN_DEPTH || info.material.reflectionFactor==0.){\n\t\t\t// no more reflections\n\t\t\tbreak;\n\t\t}\n\t\tdirection = normalize(reflect(direction, normal));\n\t\tp += 2.*MIN_DEPTH*direction;\n\t\t\n\t\t\n\n\t\tstart = 0.;\n\t\tend = end - info.d;\t\t\t\n\t}\n\t\n\tcolor += factor*info.material.color;\n\t\n\treturn vec4(color, depth);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-iResolution.xy/2.)/iResolution.y;\n\n\tsceneUpdate();\n\t\n    vec3 origin = vec3(0., 0., 5.); \n    vec3 direction = normalize(vec3(uv, -1));\n  \n\tvec4 result = rayMarch(origin, direction, 0., 100., 0); \n\tfloat depth = result.w;\n\tvec3 color = result.rgb;\n\n\t\n\tfragColor = vec4(color,1.0);  \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define EPSILON pow(10., -4.)\nfloat align (float diff, float dim){\n    if(diff>=dim){\n        return diff-dim;\n    } else {\n        return 0.;\n    }\n}\nfloat box3D (vec3 boxPos, vec3 boxSize, vec3 pos){\n    float n = align(abs(pos.x-boxPos.x), boxSize.x)+align(abs(pos.y-boxPos.y), boxSize.y);\n    n+=align(abs(pos.z-boxPos.z), boxSize.z);//just to keep the lines short\n    return n;\n}\nvec2 rotate2D (vec2 p, float angle){\n    return vec2(p.x*cos(angle)-p.y*sin(angle), p.y*cos(angle)+p.x*sin(angle));\\\n}\nvec4 SDF (vec3 p){\n    vec3 matCol = vec3(-1.);\n    float total = abs(box3D(vec3(0.), vec3(0.1), p))-.025;\n    total=max(abs(total)-.01,-p.y);\n    return vec4(total, matCol);\n}\nvec4 trace (vec3 o, vec3 r) {\n    float t = 0.;\n    vec3 p = o;\n    for(int i = 0; i<64; i++){\n        p = o+r*t;\n        float d = SDF(p).x;\n        t+=d*0.5;\n    }\n    return vec4(p, t);\n}\n//Credit to Jamie Wong http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/#surface-normals-and-lighting\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)).x - SDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n        SDF(vec3(p.x, p.y + EPSILON, p.z)).x - SDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)).x - SDF(vec3(p.x, p.y, p.z - EPSILON)).x\n    ));\n}\n\n//made this one myself with some tutorials I found out there on the \nfloat diffuseLight (vec3 n, vec3 r){\n    return dot(n, -r);\n}\nfloat specularLight (vec3 n, vec3 r){\n    vec3 nr = reflect(r, n);\n    float d = dot(nr, -r);\n    return pow(max(dot(nr, -r), 0.), 8.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //setup coordinates\n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5, 0.);\n    if(iMouse.xy == vec2(0.))mouse = vec2(0.5, 0.2);\n    mouse.x*=5.;\n    mouse.y*=2.;\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    //setup camera + rays\n    float angle = mouse.x;\n    float fov = 0.5;\n    float camDist = 1.;\n    vec3 camera = vec3(cos(mouse.x)*camDist, 0., sin(mouse.x)*camDist);\n    vec3 ray = vec3(-cos(mouse.x+uv.x*fov)*2., uv.y, -sin(mouse.x+uv.x*fov)*2.);\n    ray = normalize(ray);\n    mouse.y-=0.5;\n    mouse.y*=-2.5;\n    camera = vec3(rotate2D(camera.xy, mouse.y), camera.z);\n    ray = vec3(rotate2D(ray.xy, mouse.y), ray.z);\n    \n    vec4 v = trace(camera, ray);\n    vec3 norm = v.xyz;\n    vec3 normal = estimateNormal(v.xyz);\n    // Time varying pixel color\n    vec3 col = texture(iChannel0, norm).rgb;\n    vec3 slightReflection = texture(iChannel0, reflect(ray, normal)).rgb;\n    col+=slightReflection*0.5;\n    col+=specularLight(normal, ray)*0.8;\n    col+=diffuseLight(normal, ray)*0.1;\n    float fog = 1./(1.+pow(v.w*2., 2.)*0.01);//distance shading\n\tvec3 back = texture(iChannel0, ray).rgb;\n    col = (1.-fog)*back+max(fog*col, 0.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}