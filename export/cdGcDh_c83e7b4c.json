{"ver":"0.1","info":{"id":"cdGcDh","date":"1696017308","viewed":134,"name":"Inverse Bayer Matrix","username":"MartyMcFly","description":"Bayer Matrix is XY pos -> value. This is the inverse version =)","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["matrix","bayer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define VISUALIZE_MATRIX 0 //switches the blobs for 3D line drawings WARNING can be much slower!\n\n\n#define NUM_BLOBS 37 //pick a prime\n#define BLOB_SIZE 0.06\n\n//COPYPASTE FROM HERE\n#define LEVELS 3 //for visualization, increase slowly!\n\nivec2 bayer_inv(int i)\n{\n    ivec2 b = ivec2(0);\n    for(int j = 0; j < LEVELS; j++)\n    {\n        b += ivec2(i, i ^ (i >> 1)) & 1;\n        b += b;\n        i /= 4;\n    }\n    return b;\n}\n//STOP COPYPASTING HERE\n\n#define ZOOM 0.55\n\n#define PI 3.1415927\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rot_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nvec3 bayer_to_pos(int i)\n{\n    int N = (1<<LEVELS)*(1<<LEVELS);\n    ivec2 b = bayer_inv(i);\n    \n    vec3 p;\n    p.xy = (vec2(b) + 1.0) / vec2((2 << LEVELS));\n    p.z = (float(i) + 0.5) / float(N);\n    return p * 2.0 - 1.0;    \n}\n\nfloat sdsphere(vec3 p, vec3 center, float r)\n{\n    return length(p - center) - r;\n}\n\nmat3 basis(in vec3 n)\n{\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a; \n    \n  vec3 xp = vec3(n.z+sz*b, sz*c, -n.x);\n  vec3 yp = vec3(c, 1.0-b, -sz*n.y);\n  \n  return mat3(n, xp, yp);\n\n}\n\nfloat map(vec3 p, out int id)\n{\n    float d = 10000.0; \n   \n   vec3 dir = vec3(1,-1,-1);\n   \n   for(int j = 0; j < 3; j++)\n   {\n       d = min(d, sdCapsule(p, vec3(-1.0), dir, 0.02));\n       d = min(d, sdCapsule(p, vec3(1.0), -dir, 0.02));\n       d = min(d, sdCapsule(p, -dir, dir.yzx, 0.02));\n       d = min(d, sdCapsule(p, -dir, dir.zxy, 0.02));\n       dir = dir.yzx;\n   }\n   \n#if VISUALIZE_MATRIX == 0\n   float time = iTime * 0.05 * float(NUM_BLOBS);\n   int N = (1<<LEVELS)*(1<<LEVELS);   \n   id = -1;\n   \n   for(int j = 0; j < NUM_BLOBS; j++)\n   {\n       float relative_t = fract((float(j) + time) / float(NUM_BLOBS));\n       int timestep = int(relative_t * float(N));       \n       float x = fract(relative_t * float(N));\n       \n       vec3 p0 = bayer_to_pos(timestep);\n       vec3 p1 = bayer_to_pos((timestep + 1) % N);  \n       \n       float speed = 6.*x - 6.*x*x; \n   \n       x = smoothstep(0.0, 1.0, x);\n       vec3 lerpp = mix(p0, p1, x);    \n       float speedfact = speed;   \n\n       vec3 axis = normalize(p0 - p1);   \n       mat3 tbn = basis(axis);   \n       vec3 deltap = p - lerpp;\n       deltap *= tbn;   \n       deltap.x /= 1.0 + speedfact * 0.4;    \n       float r = BLOB_SIZE * (1.0 - speedfact * 0.1);  \n       float this_d = length(deltap) - r;  \n       \n       if(this_d < d) id = j;\n       d = min(this_d, d);   \n   }\n   \n   return d;  \n\n\n#else \n    \n    int N = (1<<LEVELS)*(1<<LEVELS);\n    \n    vec3 pcurr = bayer_to_pos(0);\n    \n    for(int j = 1; j < N; j++)\n    {\n        vec3 pnext = bayer_to_pos(j);\n        d = min(d, sdCapsule(p, pcurr, pnext, 0.05));\n        pcurr = pnext;\n    }\n    \n    return d;\n#endif\n}\n\nfloat rm(vec3 ro, vec3 rd, out int id)\n{\n    vec3 p = ro;\n    float t = 0.0;\n    \n    int j = 0; \n    \n    for(; j < 50; j++)\n    { \n        float d = map(ro + t * rd, id);\n        t += d;\n        if(d < 0.001) break;\n    }\n\n    return t * (j < 50 ? 1.0 : -1.0);\n}\n\nvec3 getn(vec3 p)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    int dummy;\n    return normalize(e.xyy*map(p + e.xyy , dummy) + \n\t\t\t\t\t e.yyx*map(p + e.yyx , dummy) + \n\t\t\t\t\t e.yxy*map(p + e.yxy , dummy) + \n\t\t\t\t\t e.xxx*map(p + e.xxx , dummy));\n}\n\n\nfloat somestep(float t) {\n    return pow(t,4.0);\n}\n\n//ripped from another shadertoy, I don't know which one. Search for PBR\nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 shade(vec3 R, vec3 p, int hit_id)\n{\n    vec3 huemask = hsv2rgb_smooth(vec3(float(hit_id)/float(NUM_BLOBS), 1.0, 1.0));\n    if(hit_id == -1) huemask = vec3(0);\n    float roughness = 0.1;\n    vec3 light_color = textureBlured(iChannel1, normalize(R * 0.8)).xyz;\n        \n    // NL\n    vec3 N = getn(p);\n    vec3 L = normalize(vec3(-0.5, 1.0, 0.0));\n        \n    // dots\n    float NdotV = clamp(dot(N, -R), 0.0, 1.0);\n    float NdotL = clamp(dot(L,  N), 0.0, 1.0);\n    vec3  RrefN = reflect(R, N);\n        \n    // specular power\n    float specular_mod   = 1.0 - roughness;\n    float specular_power = clamp(pow(clamp(dot(L, RrefN), 0.0, 1.0), 1.0 / specular_mod) * specular_mod, 0.0, 1.0);\n\n    // IBL\n    vec3 ibl_diffuse    = textureBlured(iChannel1, N) * huemask;\n    vec3 ibl_reflection = textureBlured(iChannel1, RrefN);\n        \n    // fresnel\n    float fresnel_pow  = 35.0;\n    float fresnel_base = NdotV;\n    float fresnel_exp  = pow(fresnel_base, fresnel_pow);\n    float fresnel_term = specular_power + fresnel_exp;\n    \n    #define PI_MODIFIER 4.0\n        \n    // specular\n    float normalization_term = ((specular_power + PI_MODIFIER) / PI_MODIFIER * PI);\n    float specular_term      = normalization_term * specular_power;\n    float vis_alpha          = 1.0 / (sqrt((PI / 4.0) * specular_power + (PI / 2.0)));\n    float vis_term           = clamp((NdotL * (1.0 - vis_alpha) + vis_alpha) * (NdotV * (1.0 - vis_alpha) + vis_alpha), 0.0, 1.0);\n\n    // reflection        \n    vec3 refl = texture(iChannel1, RrefN).xyz;\n    refl = mix(refl, ibl_reflection, 1.0 - vis_term);\n    refl = mix(refl, ibl_reflection, roughness);\n        \n    // final colors\n    vec3 specular_color = specular_term * fresnel_term * vis_term * light_color;\n    vec3 diffuse_color  = mix(ibl_diffuse, refl, vis_term);\n\n    vec3 final_color = diffuse_color + specular_color;        \n    return final_color * 4.0;  \n}\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n    vec2 uv = p/iResolution.xy; \n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;   \n    \n    vec3 rd = normalize(vec3(uv, -3.2 * ZOOM));  \n    vec3 ro = vec3(0.0,0.0, 3.0);\n    \n    float ry = (-iMouse.x / iResolution.x * 2.0 - 1.0)*PI;\n    float rx = (-iMouse.y / iResolution.y+0.5)*2.0*iResolution.x/iResolution.y;    \n    \n    if(dot(iMouse.zw, vec2(1.0)) < 1.0)\n    {\n        ry = (-0.5 * 2.0 - 1.0)*PI;\n        rx =(-0.5+0.5)*2.0*iResolution.x/iResolution.y;    \n    }\n\n    \n    mat3 cam = rot_x(rx)*rot_y(ry); \n   \tro *= cam;\n\trd *= cam;\n    \n    int hit_id;\n    \n    float t = rm(ro, rd, hit_id);\n    \n    vec3 hit = ro + rd * t;\n    vec3 n = getn(hit);\n    \n    vec3 outcol = textureBlured(iChannel1, rd) * 12.0;\n    \n    if(t > 0.0)\n    {\n        outcol = shade(rd, hit, hit_id);        \n    }\n    \n    outcol /= 1.0 + outcol;\n    outcol *= outcol;\n    \n    o = vec4(outcol, 1);  \n}","name":"Image","description":"","type":"image"}]}