{"ver":"0.1","info":{"id":"43G3zt","date":"1718041743","viewed":63,"name":"Smooth follow","username":"twixuss","description":"Follow a target value with smooth acceleration and deceleration, without overshoots, converging in finite time.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["mix","bezier","lerp","target","smooth","follow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// Click to set target (blue bar),\n// orange bar will smoothly follow without overshooting,\n// and converge in finite amount of time.\n\n// Config in common tab\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.1);\n    if (fragCoord.y > iResolution.y*0.51) {\n        if (fragCoord.x < L(L_VALUE).x) {\n            fragColor = vec4(.9,.6,.3,1);\n        }\n    }\n    if (fragCoord.y < iResolution.y*0.49) {\n        if (fragCoord.x < L(L_TARGET).x) {\n            fragColor = vec4(.3,.6,.9,1);\n        }\n    }\n    // debug stuff\n    #if 0\n    State s;\n    s.value = L(L_VALUE).x;\n    s.prev_value = L(L_PREV_VALUE).x;\n    s.prev_velocity = L(L_PREV_VELOCITY).x;\n    s.overshooting = L(L_OVERSHOOTING).x;\n    s.changed_at = L(L_CHANGED_AT).x;\n    s.target = L(L_TARGET).x;\n    if (length(fragCoord.xy) < 32.) {\n        if (norm_b(s) > 1.0) {\n            fragColor = vec4(1,0,0,1);\n        } else {\n            fragColor = vec4(0,1,0,1);\n        }\n    }\n    if (length(fragCoord.xy) < 16.) {\n        if (s.overshooting > 0.5) {\n            fragColor = vec4(1,0,0,1);\n        } else {\n            fragColor = vec4(0,1,0,1);\n        }\n    }\n    if (fragCoord.y > iResolution.y*0.99) {\n        if (fragCoord.x < s.prev_value) {\n            fragColor = vec4(0,1,1,1);\n        }\n    }\n    if (iResolution.y*0.98 < fragCoord.y && fragCoord.y < iResolution.y*0.99) {\n        if (fragCoord.x < s.prev_velocity + iResolution.x*0.5) {\n            fragColor = vec4(1,1,0,1);\n        }\n    }\n    if (iResolution.y*0.97 < fragCoord.y && fragCoord.y < iResolution.y*0.98) {\n        float velocity = sample_derivative(s) * 0.5;\n        if (fragCoord.x < velocity + iResolution.x*0.5) {\n            fragColor = vec4(0,1,0,1);\n        }\n    }\n    if (iResolution.y*0.96 < fragCoord.y && fragCoord.y < iResolution.y*0.97) {\n        float velocity = norm_b(s) * 100.;\n        if (fragCoord.x < velocity + iResolution.x*0.5) {\n            fragColor = vec4(1,0,0,1);\n        }\n    }\n    if (iResolution.x*0.499 < fragCoord.x && fragCoord.x < iResolution.x*0.501) {\n        fragColor *= 0.5;\n    }\n    if (iResolution.x*0.499 < fragCoord.x - 100. && fragCoord.x - 100. < iResolution.x*0.501) {\n        fragColor *= 0.5;\n    }\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Use 4 point bezier curve for smooth acceleration and deceleration.\n// If target changes mid interpolation and the value would overshoot, use power function\n// to decelerate faster and avoid overshoot.\n\nstruct State {\n    float target;\n    float value;\n    float prev_value;\n    float prev_velocity;\n    float overshooting;\n    float changed_at;\n};\nfloat get_t(State s) {\n    return clamp((iTime - s.changed_at) / PERIOD, 0.0f, 1.0f);\n}\nfloat norm_b(State s) {\n    return s.prev_velocity / 3. / (s.target - s.prev_value);\n}\nfloat sampl(State s) {\n    if (s.overshooting > 0.5) {\n        return mix(s.prev_value, s.target, 1. - pow(1. - get_t(s), norm_b(s) * 3.));\n    } else {\n        return bezier(s.prev_value, s.prev_value + s.prev_velocity/3., s.target, s.target, get_t(s));\n    }\n}\nfloat sample_derivative(State s) {\n    if (s.overshooting > 0.5) {\n        float b3 = norm_b(s) * 3.;\n        return b3 * pow(1. - get_t(s), b3 - 1.) * (s.target - s.prev_value);\n    } else {\n        return bezier_derivative(s.prev_value, s.prev_value + s.prev_velocity/3., s.target, s.target, get_t(s));\n    }\n}\nvoid update(inout State s) {\n    s.value = sampl(s);\n}\nvoid set_target(inout State s, float new_target) {\n\tfloat velocity = sample_derivative(s);\n\ts.target = new_target;\n\ts.prev_velocity = velocity;\n\ts.prev_value = s.value;\n    s.overshooting = norm_b(s) > 1. ? 1.0 : 0.0;\n\ts.changed_at = iTime - iTimeDelta;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 C = ivec2(fragCoord);\n    fragColor = L(C);\n    \n    State s;\n    s.value = L(L_VALUE).x;\n    s.prev_value = L(L_PREV_VALUE).x;\n    s.prev_velocity = L(L_PREV_VELOCITY).x;\n    s.overshooting = L(L_OVERSHOOTING).x;\n    s.changed_at = L(L_CHANGED_AT).x;\n    s.target = L(L_TARGET).x;\n    \n    //if (iMouse.w > 0.5)\n    {\n        float newTarget = iMouse.x;\n        if (length(iMouse.xy) < 8.) {\n            float f = 8.;\n            newTarget = round((pow(sin(iTime),3.0)*0.4+0.5)*f)/f * iResolution.x;\n        }\n        if (abs(s.target - newTarget) > 1.0f) {\n            set_target(s, newTarget);\n        }\n    }\n    update(s);\n    \n    if (C == L_VALUE) { fragColor = vec4(s.value,0,0,0); }\n    if (C == L_PREV_VALUE) { fragColor = vec4(s.prev_value,0,0,0); }\n    if (C == L_PREV_VELOCITY) { fragColor = vec4(s.prev_velocity,0,0,0); }\n    if (C == L_OVERSHOOTING) { fragColor = vec4(s.overshooting,0,0,0); }\n    if (C == L_CHANGED_AT) { fragColor = vec4(s.changed_at,0,0,0); }\n    if (C == L_TARGET) { fragColor = vec4(s.target,0,0,0); }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Max time it takes to converge\n#define PERIOD 0.5\n\n\n\n\n\n\n\n\n\n#define L_VALUE         ivec2(0, 0)\n#define L_PREV_VALUE    ivec2(1, 0)\n#define L_PREV_VELOCITY ivec2(2, 0)\n#define L_OVERSHOOTING  ivec2(3, 0)\n#define L_CHANGED_AT    ivec2(4, 0)\n#define L_TARGET        ivec2(5, 0)\n\n#define L(x) texelFetch(iChannel0, x, 0)\n\nfloat bezier(float a, float b, float c, float d, float t) {\n\treturn a + t * (-3.*a + 3.*b + t * (3.*a - 6.*b + 3.*c + t * (-a + 3.*b - 3.*c + d)));\n}\nfloat bezier_derivative(float a, float b, float c, float d, float t) {\n\treturn -3.*a + 3.*b + t * (6.*a - 12.*b + 6.*c + 3. * t * (-a + 3.*b - 3.*c + d));\n}\n\n","name":"Common","description":"","type":"common"}]}