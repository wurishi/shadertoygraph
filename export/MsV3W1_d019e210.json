{"ver":"0.1","info":{"id":"MsV3W1","date":"1454424176","viewed":133,"name":"ellipse_and_arrows_2d","username":"samuelotherion","description":"ellipse 2d with arrows","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","ellipse","arrows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define pi            3.1415926535\n#define _t_           .5 * iTime\n#define ID_ARROW      0\n#define ID_ELLIPSE    1\n#define NUM_OF_ARROWS 6\n\nstruct Object { int id; vec2 pos; mat2 loc; vec4 col; };\nstruct Scene { vec2 xy; Object ellipse, arrows[ NUM_OF_ARROWS ]; };\n\nScene\n    scene;\n\nmat2\n    rotMat( in float p_angle ) {\n        \n        float\n            c = cos( p_angle ),\n            s = sin( p_angle );\n        \n        return mat2( c, s, -s, c );\n    }\n\n\nmat2\n    invMat( in mat2 p_mat ) {\n        \n        float\n            det = p_mat[ 0 ][ 0 ] * p_mat[ 1 ][ 1 ] - p_mat[ 1 ][ 0 ] * p_mat[ 0 ][ 1 ];\n        \n        return mat2( p_mat[ 1 ][ 1 ], -p_mat[ 1 ][ 0 ], -p_mat[ 0 ][ 1 ], p_mat[ 0 ][ 0 ] ) / det;\n    }\n\nvoid\n    init( vec2 p_xy ) {\n        \n        scene.xy = vec2( p_xy / iResolution.xy - .5 ) * vec2( iResolution.x / iResolution.y, 1. );\n        scene.ellipse =     Object( ID_ELLIPSE, vec2( +.25, +0. ), mat2( +.3, +0., +0., +.2 ), vec4( .7, .7, .7, 1. ) );\n        scene.arrows[ 0 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +.04, +0., +0., +.01 ), vec4( 1., .0, 0., 1. ) );\n        scene.arrows[ 1 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +0., +.04, -.01, +0. ), vec4( 0., 0., 1., 1. ) );\n        scene.arrows[ 2 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +0., +.4, -.01, +0. ), vec4(  .125, .25, .125, 1. ) );\n        scene.arrows[ 3 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +.8, +0., +0., +.02 ), vec4( .25, .125, .125, 1. ) );\n        scene.arrows[ 4 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +0., +.4, -.01, +0. ), vec4( 0., 1., 0., 1. ) );\n        scene.arrows[ 5 ] = Object( ID_ARROW,   vec2( +0., +0. ), mat2( +.25, +0., +0., +.01 ), vec4( .9, .9, .9, 1. ) );\n    }\n\nvec4\n    intersectArrow( in Object p_obj ) {\n        \n        float\n            border = .5 + .4 * sin( _t_ );\n        \n        vec2\n            d  = ( scene.xy - p_obj.pos ) * p_obj.loc;\n\n        d.x /= dot( p_obj.loc[ 0 ], p_obj.loc[ 0 ] );\n        d.y /= dot( p_obj.loc[ 1 ], p_obj.loc[ 1 ] );\n        \n        if( 0. <= d.x && d.x < border ) {\n         \n            if( abs( d.y ) < .3 ) return p_obj.col;\n            else if( abs( d.y ) < 1. ) return vec4( .3 * p_obj.col.rgb, 1. );\n        }\n        \n        d.x -= border;\n        border = 1. - border;\n        \n        if( 0. <= d.x && d.x < border ) {\n        \n            if( abs( d.y ) < ( 1. - d.x / border ) ) return p_obj.col;\n            else  if( abs( d.y ) < 1. ) return vec4( .3 * p_obj.col.rgb, 1. );\n        }\n        \n        return vec4( .0 );\n    }\n\nvec4\n    intersectEllipse( in Object p_obj ) {\n        \n        vec2\n            d  = ( scene.xy - p_obj.pos ) * p_obj.loc;\n        \n        d.x /= dot( p_obj.loc[ 0 ], p_obj.loc[ 0 ] );\n        d.y /= dot( p_obj.loc[ 1 ], p_obj.loc[ 1 ] );\n\n                \n        if( abs( d.x ) <= 1. && abs( d.y ) < 1. ) {\n        \n\t        if( dot( d, d ) < 1. ) return p_obj.col;\n    \n            return vec4( .3 * p_obj.col.rgb, 1. );\n        }\n        \n        return vec4( 0. );\n    }\n\nvec4\n    intersect( in Object p_obj ) {\n    \n        if( p_obj.id == ID_ARROW ) {\n            \n            return intersectArrow( p_obj );\n        }\n        \n        if( p_obj.id == ID_ELLIPSE ) {\n            \n            return intersectEllipse( p_obj );\n        }\n        \n        return vec4( 0. );\n    }\n\nvec4\n    render( ) {\n    \n        vec4\n            col = vec4( 0., 0., 0., 1. );\n        \n        col += intersect( scene.ellipse );\n        \n        for( int i = 0; i < NUM_OF_ARROWS; i++ ) {\n        \n            col += intersect( scene.arrows[ i ] );\n        }\n        //col /= col.a;\n        return vec4( .5 * col.rgb, 1. );\n    }\n\nvoid\n    animate( ) {\n        \n        mat2\n            rot1 = rotMat( _t_ * pi / 180. ),\n            rot90 = rotMat( pi / 2. ),\n            rot270 = rotMat( 3. * pi / 2. );\n        \n        mat2\n            rotT0 = rotMat( 1.3 * _t_ ),\n            rotT1 = rotMat( _t_ ),\n            rotT2 = rotMat( .1 * pi * sin( _t_ ) ),\n            rotT3 = rotMat( pi * sin( 5. / 3. * _t_ ) );\n        \n        scene.ellipse.loc = rotT3 * scene.ellipse.loc;\n\t\tscene.ellipse.pos = rotT0 * scene.ellipse.pos;\n        \n        scene.arrows[ 0 ].loc = scene.ellipse.loc;\n        scene.arrows[ 0 ].pos = scene.ellipse.pos;\n        \n        scene.arrows[ 1 ].loc = rot90 * rotT1 *  scene.arrows[ 0 ].loc;\n        scene.arrows[ 1 ].pos = scene.ellipse.pos;\n        \n        scene.arrows[ 2 ].loc = rotT2 * scene.arrows[ 2 ].loc;\n        \n        scene.arrows[ 3 ].loc = rotT2 * scene.arrows[ 3 ].loc;\n        \n        scene.arrows[ 4 ].pos = scene.ellipse.pos;\n        scene.arrows[ 4 ].loc = scene.ellipse.loc * rotT1;\n\n        scene.arrows[ 5 ].loc = rotT0 * scene.arrows[ 5 ].loc;\n    }\n\nvoid\n    mainImage( out vec4 p_c, in vec2 p_xy ) {\n        \n        init( p_xy );\n        \n        animate( );\n\t\n        p_c = render( );\n    }","name":"","description":"","type":"image"}]}