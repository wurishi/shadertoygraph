{"ver":"0.1","info":{"id":"43VGWw","date":"1717720914","viewed":91,"name":"Plastic Hemisphere sampling","username":"chronos","description":"hemisphere sampling","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["random","sampling","hemisphere","uniform","quasimontecarlo","quasimontecarlso"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Plastic Ratio Hemisphere sampling\n    ------------------------------------------\n    \n    Using the Plastic ratio 2D quasirandom sequence to sample the hemisphere.\n    Not sure if the plastic ratio is the best for this, but it seems to work ok,\n    except it takes a while to sample straight up, and is maybe a bit less dense in that direction.\n    This is probably in part because of the sqrt function shooting straigt up near zero, \n    so maybe adding a small bias there could correct it.\n    \n    Seems like it's approximately uniform? Not quite sure, would have to test.\n    This is a pretty quick hack on top of the 3D LDR sequence shader, so the code is a bit crappy.\n    Sorry about that :)\n    \n    Got the UniformSampleHemisphere function from the PBR book, page 664 (i think).\n    \n\n\n    Forked shader description:\n    ------------------------------------------\n\n        Roberts Low Discrepancy Sequence by chronos\n        --------------------------------------------\n\n        Low discrepancy sequence based on reciprocal powers of so-called \"harmonious number\" for 3D.\n\n        The harmonious numbers are the solutions to x^(d+1) = x + 1, for dimension d.\n\n        It doesn't seem to have a name as far as I can tell, \n        so I named it after the author of the post this is based on for now :)\n        Also considered calling it the \"Harmonious sequence\".\n\n        In 3D this is approximately PHI = 1.2207....\n\n        The sequence is:\n            vec3 R_i = fract( i / vec3(PHI, PHI^2, PHI^3));\n\n        Based on:\n            https://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/#GeneralizingGoldenRatio\n            by Martin Roberts\n\n        self link: \n\n            https://www.shadertoy.com/view/4XtGW8\n\n        see also:\n            https://www.shadertoy.com/view/MXdGR7\n\n*/\n\n#define SHOW_WALLS 1\n#define USE_SRGB 1\n\nconst float num_samples = 1000.; // for numerical integration\n\nconst int max_num_points = 500;\n\n#define COLOR_SCHEME 0\n\nconst float PI = 3.14159265;\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\nvec3 UniformSampleHemisphere(float u1, float u2)\n{\n    float z = u1;\n    float r = sqrt(max(0., 1.-z*z));\n    float phi = 2. * PI  * u2;\n    float x = r * cos(phi);\n    float y = r * sin(phi);\n    return vec3(x,y,z);\n}\n\nfloat ray_plane(vec3 ro, vec3 rd, vec3 n, vec3 p)\n{\n    // solve dot((ro-p) + rd * t, n) = 0\n    float denom = dot(rd, n);\n    if(denom == 0.) return -1.;\n    float t = dot(p-ro, n) / denom;\n    return t;\n}\n\nvec3 rot(vec3 p, vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    vec3 projected = dot(p, axis) * axis;\n    vec3 rejected  = p - projected;\n    return projected + rejected * cos(angle) + sin(angle) * cross(axis, rejected);\n}\n\nvec2 ray_sphere(vec3 ro, vec3 rd, vec3 pos, float r)\n{\n    pos -= ro;\n    \n    float scalar_proj = dot(pos, rd);\n    vec3 reject = scalar_proj * rd - pos;\n    \n    float x2 = dot(reject, reject);\n    float r2 = r*r;\n    \n    if(x2 > r2) return vec2(-1);\n    \n    float y = sqrt(r2 - x2);\n    \n    return scalar_proj + vec2(-y, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv    = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n\n    if(length(iMouse.xy) < 10.)\n        mouse = vec2(fract(iTime / 8.), 0);\n\n    vec3 color = vec3(0);\n\n    float focal = 2.;\n    vec3 rd = normalize(vec3(uv, -focal));\n\n    rd = rot(rd, vec3(1,0,0), -0.4);\n\n    float  angle_y = mouse.y * PI * 1.;\n    rd = rot(rd, vec3(1,0,0), angle_y);\n\n    \n    float angle = mouse.x * PI * 2.;\n    rd = rot(rd, vec3(0,1,0), angle);\n    \n    \n    vec3 ro = rot(vec3(0,0,1.), vec3(1,0,0), angle_y);\n    \n    ro = rot(ro, vec3(0,1,0), angle) + vec3(0., 1., 0.);\n    \n\n    vec3 n = vec3(0, 1, 0);\n    vec3 P = vec3(0);\n    float t = ray_plane(ro, rd, n, P);\n\n    // center points of the walls\n    vec3 pos[4] = vec3[4](vec3(.5, 0.5, 0.), vec3(-.5, 0.5, 0.), vec3(0.0, 0.5, .5), vec3(0.0, 0.5, -.5));\n    \n\n    float visibility = 0.;\n\n    if(t > 0.) // if we hit the plane\n    {\n        vec3 p = rd * t + ro; // compute hit position\n\n        if(abs(p.x)< .5 && abs(p.z)<.5) // if we hit the voxel surface\n        {\n            vec3 RO = p; // new ray origin from where we hit\n            \n            color += .125;\n        }\n    }\n    \n#if SHOW_WALLS\n    float nearest_hit = 9e9;\n    float farthest_hit = 0.;\n    for(int i = 0; i < 4; i++)\n    {\n        n = normalize(pos[i] - vec3(0.,0.5,0.));\n        t = ray_plane(ro, rd, n, pos[i]);\n\n        if(t > 0.)\n        {\n            vec3 p = rd * t + ro;\n\n            vec3 diff = abs(p - pos[i]);\n            float d = max(max(diff.x, diff.y), diff.z);\n            color = mix(color, vec3(1), 0.0125 * float(d < .5));\n            \n            nearest_hit = min(nearest_hit, t);\n            farthest_hit = max(farthest_hit, t);\n        }\n    }\n#endif\n\n    // At 60 fps, the duration is about 12.5 seconds\n    // the number of frames = 3 * num_points = 3 * 250 = 750\n    float duration = 12.5; // 750f / (60 f/s) = 12.5s;\n    float time = mod(iTime, duration); \n    \n    float speed = 1./(4.+1./6.); // At 60 fps, 250 points are reached at 250/60 = 25/6 = 4 + 1/6\n    float animation = min( min((duration-time)*speed, time*speed), 1.);\n    \n    int N = int(animation * float(max_num_points));\n\n    float PHI = 1.2207440846057594754; //solve PHI^4 - PHI - 1 = 0\n    \n    float iPHI1 = 0.81917251339616;   // 1./PHI;\n    float iPHI2 = 0.671043606703789;  // iPHI1*iPHI1;\n    float iPHI3 = 0.54970047790197;   // iPHI2*iPHI1;\n    \n    vec3 iPHI = vec3(iPHI1, iPHI2, iPHI3);\n    \n    const float p1 = 0.7548776662466927; // reciprocal of plastic number\n    const float p2 = 0.5698402909980532; // reciprocal of squared plastic number\n    vec2 plastic = vec2(p1, p2);\n    \n    #if 0\n    float r = 0.5 * pow(3. / (float(N+1) * 4.* PI), 1./3.);\n    #else\n    float r = 0.01;\n    #endif\n    \n    float min_t = 9e9;\n    for(int i = 0; i < N; i++)\n    {\n        vec3 pos = fract(vec3(i) * iPHI + 0.5);\n        \n        vec2 U = fract(plastic * (vec2(i)+0.)+0.);\n        \n        #if 0\n        pos = UniformSampleHemisphere(pos.z, pos.y)*.5;\n        #else\n        pos = UniformSampleHemisphere(U.x, U.y)*.5;\n        #endif\n        \n        pos = rot(pos, vec3(1,0,0), -PI/2.);\n        \n        vec2 t = ray_sphere(ro, rd, pos, r);\n        if(t.x <= 0. || t.x > min_t) continue;\n        \n        min_t = t.x;\n        \n        vec3 p = ro + t.x * rd;\n        vec3 n = normalize(p - pos);\n        \n        float f = float(i)/float(max_num_points-1);\n\n        #if COLOR_SCHEME\n            vec3 point_color = vec3((1.-f)*(1.-f), 2.*(1.-f)*f , f*f);\n        #else\n            vec3 point_color = vec3(\n                step(f, 1./3.), \n                step(1./3., f) * step(f, 2./3.),\n                step(2./3., f)\n                );\n        #endif\n        \n        color = point_color * max(0.01, dot(n, normalize(vec3(1,1,1))) );\n        \n    }\n\n    #if USE_SRGB\n    color = sRGBencode(color);\n    #endif\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}