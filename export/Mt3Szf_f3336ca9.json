{"ver":"0.1","info":{"id":"Mt3Szf","date":"1480979199","viewed":273,"name":"Cauldron","username":"zackpudil","description":"fractal bump mapping on a simple cylinder.  Geometry is not so interesting.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","kali"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float time() { return iTime; }\n\nvec3 material(vec2 p) {\n\tvec3 col = vec3(100);\n\t\n\tfor(int i = 0; i < 15; i++) {\n\t\tp = abs(p)/dot(p, p) - vec2(0.5, 0.3);\n\t\tcol = min(col, vec3(abs(p.x), length(p), abs(2.0*p.y)));\n\t}\n\t\n\treturn col;\n}\n\nvec3 matcube(vec3 p, vec3 n) {\n\tvec3 m = pow(abs(n), vec3(10.0));\n\t\n\tvec3 x = material(p.yz);\n\tvec3 y = material(p.xz);\n\tvec3 z = material(p.xy);\n\t\n\treturn (m.x*x + m.y*y + m.z*z)/(m.x + m.y + m.z);\n}\n\nvec3 matbump(vec3 p, vec3 n) {\n\tvec3 gs = vec3(0.21, 0.72, 0.07);\n\tvec2 h = vec2(0.015, 0.0);\n\t\n\tfloat res = dot(gs, matcube(p, n));\n\tmat3 m = mat3(\n\t\tmatcube(p - h.xyy, n),\n\t\tmatcube(p - h.yxy, n),\n\t\tmatcube(p - h.yyx, n)\n\t);\n\t\n\tvec3 g = (gs*m - res)/h.x;\n\tg -= n*dot(g, n);\n\t\n\treturn g;\n}\n\nfloat de(vec3 p) {\n\treturn min(length(p.xz) - 1.0 + 0.8*sin(p.y), p.y + 1.0);\n}\n\nfloat trace(vec3 ro, vec3 rd, float mx) {\n\tfloat t = 0.0;\n\tfor(int i = 0; i < 100; i++) {\n\t\tfloat d = de(ro + rd*t);\n\t\tif(d < 0.001 || t >= mx) break;\n\t\tt += d*0.5;\n\t}\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.001, 0.0);\n\tvec3 n = normalize(vec3(\n\t\tde(p + h.xyy) - de(p - h.xyy),\n\t\tde(p + h.yxy) - de(p - h.yxy),\n\t\tde(p + h.yyx) - de(p - h.yyx)\n\t));\n\treturn n;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 col = vec3(0);\n\t\n\tfloat t = trace(ro, rd, 10.0);\n\tif(t < 10.0) {\n\t\tvec3 key = normalize(vec3(0.8, 0.7, -0.6));\n\t\t\n\t\tvec3 pos = ro + rd*t;\n\t\tvec3 nor = normal(pos);\n\t\tvec3 sn = normalize(nor + 0.04*matbump(pos, nor));\n\t\tvec3 sn2 = normalize(nor + 0.4*matbump(pos, nor));\n\t\tvec3 ref = normalize(reflect(rd, sn));\n\t\t\n\t\tcol += pow(clamp(dot(-rd, ref), 0.0, 1.0), 10.0);\n\t\tcol += pow(clamp(1.0 + dot(rd, sn2), 0.0, 1.0), 2.0);\n\t\t\n\t\tcol *= 2.0*matcube(pos, nor);\n\t}\n\t\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\n\tfloat at = time()*0.4;\n\tvec3 ro = vec3(1.0*sin(at), 1, -2.0*cos(at));\n\tvec3 ww = normalize(-ro);\n\tvec3 uu = normalize(cross(vec3(0, 1, 0), ww));\n\tvec3 vv = normalize(cross(ww, uu));\n\tvec3 rd = normalize(uv.x*uu + uv.y*vv + 1.97*ww);\n\t\n\tvec3 col = render(ro, rd);\n\t\n\tfragColor = vec4(col, 1);\n\n}","name":"Image","description":"","type":"image"}]}