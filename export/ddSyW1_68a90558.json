{"ver":"0.1","info":{"id":"ddSyW1","date":"1687642908","viewed":125,"name":"Math Zoo [BigWings] - Lava Lamp","username":"twenkid","description":"Original: https://www.shadertoy.com/view/tlcXWX\nI just changed Rot function (c=... Rot(float a) {\n    float s = sin(a);\n    float c = cos(a)*sin(a)+cos(a/2.);\n    return mat2(c, -s, s, c);\n}\n","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sss","volumetric","gyroid","artofcode","mathzoo"],"hasliked":0,"parentid":"tlcXWX","parentname":"Math Zoo - Alien Orb"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Math Zoo - Alien Orb\" \n// by Martijn Steinrucken aka BigWings/The Art of Code - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n//\n// This started out with me playing with Gyroids and it ended up with\n// me discovering an alien lifeform that rolls through the vast deserts\n// of some far-flung planet in a different galaxy.\n//\n// Don't let its beauty fool you. Any unsuspecting creature entering the cage\n// attracted by the light show will meet an untimely death. When it gets\n// zapped by the plasma at the center, the tumbler collapses and suffocates\n// its stunned prey. \n// Its like one of those fly zappers, only much cooler!\n// To date, the plasma tumbler is the only creature we know of that uses \n// a plasma as part of its survival strategy.\n//\n// .. and I discovered all of that while playing with ShaderToy ;)\n\n//--> Math Zoo [BigWings] - Lava Lamp\n//Twenkid: changed the Rot function, for now just c=cos(a); to a more complex one to make it move \"living\", #25.6.2023\n\n#define S smoothstep\n#define AA 2\n#define T iTime*.1\n#define TAU 6.283185\n\n#define MAX_STEPS 300\n#define MAX_DIST 30.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a)*sin(a)+cos(a/2.); //CHANGED by twenkid\n    return mat2(c, -s, s, c);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,234.34));\n    p += dot(p, p+23.43);\n    return fract(p.x*p.y);\n}\n\nfloat Gyroid(vec3 p) {\n    float scale = 10.;\n    vec3 p2 = p*scale;\n    p2.xy *= Rot(T);\n    return (abs(dot(sin(p2), cos(p2.zxy)))-.4)/scale;\n}\n\nfloat sabs(float x, float k) {\n    return sqrt(x*x+k);\n}\n\nfloat GetDist(vec3 p) {\n    \n    float sphere = abs(length(p)-1.)-.03;\n\n    float d=smin(sphere, Gyroid(p)*.7, -.03);\n    float ground = p.y+1.+S(.01, -.01, d)*.1;\n   \n    float x = p.x;\n    p.x += T*1.3;\n   \n    vec3 p2 = p*5.;\n    \n    float wake = S(.4, .0, abs(p.z));\n    wake *= S(0., -1., x);\n\tfloat gyroid = (sabs(dot(sin(p2), cos(p2.zxy)),wake)-.4)/10.;\n    \n    ground += gyroid;\n    d = min(d, ground*.5);\n    \n    return d;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dM=MAX_DIST;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if(dS<dM) dM = dS;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, dM);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nfloat GlitterLayer(vec2 p, float seed) {\n    float t = iTime*3.+seed;\n    vec2 id = floor(p);\n    vec2 gv = fract(p)-.5;\n    \n    float n = Hash21(id);\n    float x = fract(n*12.32);\n    float y = fract(n*123.32);\n    vec2 offs = vec2(x,y)-.5;\n    \n    float d = length(gv-offs*.8);\n    float m = S(.2, .0, d);\n    \n    m *= pow(sin(t+n*6.2832)*.5+.5, 3.);\n    return m;\n}\n\nvec3 RayPlane(vec3 ro, vec3 rd, vec3 p, vec3 n) {\n    float t = max(0., dot(p-ro,n)/dot(rd, n));\n    return ro + rd*t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    float t = iTime*.1;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, -1)*2.;\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831+iTime*.05);\n    ro.y = max(ro.y, -.9);\n    \n    for(int x=0; x<AA; x++) {\n        for(int y=0; y<AA; y++) {\n            vec2 offs = vec2(x, y)/float(AA) -.5;\n\n            vec2 uv = (fragCoord+offs-.5*iResolution.xy)/iResolution.y;\n            vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n\n            float dist = RayMarch(ro, rd).x;\n            \n            vec3 lightPos = vec3(0);\n            vec3 shadowPos = lightPos+normalize(ro-lightPos);\n            vec3 p = ro + rd * dist;\n            if(dist<MAX_DIST) {\n                \n                vec3 l = normalize(lightPos-p);\n                vec3 n = GetNormal(p);\n\n                float dif = clamp(dot(n, l)*.5+.5, 0., 1.);\n\n                vec2 d = RayMarch(lightPos, l);\n\n                float shadow = length(p)<1.03 ? 1. : S(SURF_DIST, SURF_DIST*20., d.y)*.6+.4;\n                float falloff = min(1., 1./length(p.xz));               \n\n                dif *= shadow*falloff*falloff;\n                \n                col += dif;\n                \n                // ground glitter\n                if(p.y<-.9) {\n                    vec2 st = p.xz;\n                    float offs = dot(rd, vec3(10));\n\n                    st.x += t*1.3;\n                    float glitter = GlitterLayer(st*10., offs);\n                    glitter += GlitterLayer(st*17.+3.1, offs);\n                    glitter += GlitterLayer(st*23.+23.1, offs);\n                    col += pow(glitter,5.)*falloff*shadow*shadow;\n                }\n            }\n            // center light\n            float centerDist = length(uv);\n            float g = Gyroid(shadowPos);\n            float light = S(0., .03, g);\n            col += min(10., light*.02/max(centerDist,1e-3))*vec3(1.,.8,.9);\n            \n            // volumetric starburst\n            float sb = max(0., Gyroid(normalize(RayPlane(ro, rd, vec3(0), normalize(ro)))));\n            sb *= 3.*S(-.2,.1, centerDist-.4);\n            col += sb;\n            \n            // SSS\n            float sss = max(0., 1.-dot(uv, uv)*25.);\n            sss *= sss;\n            sss *= S(2.5,2., dist); // only on the front\n            sss *= 1.-light*.5;\n            vec3 P = p;\n            \n            float vein = S(-.01,.02, Gyroid(P+sin(P*30.+iTime)*.01)+.03);\n            sss *= vein;\n            col += sss*vec3(1,.1,.1);\n            col += vec3(1,0,0)*(1.-vein)*sss;\n        }\n    }\n    \n    col /= float(AA*AA);\n    \n    float pulse = pow(sin(iTime)*.5+.5, 150.);\n    t = iTime;\n    float k = sin(t)+sin(t*5.)*.5+sin(t*17.)*.25+sin(t*37.)*.1;\n    col *= 1.+k*.2;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    col *= 1.-dot(uv,uv);\n    \n    col /= col+3.; col *= 3.; // tone mapping \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}