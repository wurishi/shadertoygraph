{"ver":"0.1","info":{"id":"clGBzy","date":"1702190028","viewed":20,"name":"melding glass bulb","username":"naitry","description":"a shifting tinted glass bulb","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["refraction","glass","translucent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec3 p)\n{\n    // Implement or use a 3D noise function\n    // Placeholder for noise implementation\n    return sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0);\n}\n\nfloat sdFluctuatingSphere(vec3 p, float baseRadius, float time)\n{\n    float slowTime = time * 0.1; // Further slowing down the time factor\n    float radiusVariation = 0.2 * noise(p * 2.0 + vec3(slowTime));\n    return length(p) - (baseRadius + radiusVariation);\n}\n\nvec3 getNormal(vec3 p, float time)\n{\n    const float eps = 0.01;\n    float d = sdFluctuatingSphere(p, 0.5, time);\n    vec2 e = vec2(eps, 0.0);\n\n    vec3 n = d - vec3(\n        sdFluctuatingSphere(p - e.xyy, 0.5, time),\n        sdFluctuatingSphere(p - e.yxy, 0.5, time),\n        sdFluctuatingSphere(p - e.yyx, 0.5, time));\n    \n    return normalize(n);\n}\n\nvec3 naitryBlue = vec3(110.0 / 255.0, 200.0 / 255.0, 248.0 / 255.0);\n\nvec3 renderGrid(vec3 ro, vec3 rd)\n{\n    float gridSize = 0.5; // Adjust for desired grid size\n    vec3 gridColor = vec3(1.0); // White color\n    float lineThickness = 0.22; // Adjust for line thickness\n\n    // Find the intersection with the grid plane\n    float t = -(ro.z / rd.z);\n    vec3 p = ro + t * rd;\n\n    // Create grid pattern for both X and Y lines\n    vec2 gridX = abs(mod(p.xz, gridSize) - 0.5 * gridSize);\n    vec2 gridY = abs(mod(p.yz, gridSize) - 0.5 * gridSize);\n    float maskX = step(lineThickness, min(gridX.x, gridX.y));\n    float maskY = step(lineThickness, min(gridY.x, gridY.y));\n\n    // Combine X and Y masks\n    float mask = max(maskX, maskY);\n\n    return mix(vec3(0.0), gridColor, mask);\n}\n\nvec3 refractRay(vec3 rd, vec3 normal, float eta)\n{\n    // Calculate refracted ray direction\n    float cosi = dot(-rd, normal);\n    float cost2 = 1.0 - eta * eta * (1.0 - cosi * cosi);\n    return cost2 > 0.0 ? eta * rd + (eta * cosi - sqrt(abs(cost2))) * normal : vec3(0.0);\n}\n\nvec3 render(vec3 ro, vec3 rd, float time)\n{\n    // Render scene with sphere and refracted grid\n    vec3 tintCol = naitryBlue; // Tint color\n    for (float t = 0.0; t < 10.0; t += 0.1)\n    {\n        vec3 p = ro + t * rd;\n        if (sdFluctuatingSphere(p, 0.5, time) < 0.01)\n        {\n            vec3 normal = getNormal(p, time);\n            vec3 refractedRay = refractRay(rd, normal, 1.0 / 1.5); // Glass refraction\n            vec3 gridCol = renderGrid(ro + t * refractedRay, refractedRay);\n            return mix(gridCol, tintCol, 0.5); // Blend grid color with tint\n        }\n    }\n    return renderGrid(ro, rd); // Background grid\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Main image rendering setup\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    fragColor = vec4(render(ro, rd, iTime), 0.8);\n}\n","name":"Image","description":"","type":"image"}]}