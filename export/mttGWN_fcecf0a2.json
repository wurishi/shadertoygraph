{"ver":"0.1","info":{"id":"mttGWN","date":"1682516523","viewed":181,"name":"[zznewclear13] Polarization","username":"zznewclear13","description":"A demostration of polarization.\nInteract with mouse.\niMouse.x controls the relative amplitude of horizontal and vertical wave.\niMouse.y controls the phase difference between those two waves.","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["polarization","stokesvector","poincaresphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Polarization\n// A demostration of polarization.\n// Interact with mouse.\n// I like the way they get blurred and fade out.\n//\n// iMouse.x controls the relative amplitude of horizontal and vertical wave.\n// iMouse.x = 0.0 or 1.0: horizontally linearly polarized wave.\n// iMouse.x = 0.5: vertically linearly polarized wave.\n\n// iMouse.y controls the phase difference between those two waves.\n// (iMouse.y-0.5)*(iMouse.x-0.5) > 0: The direction of the composed wave rotates clockwise.\n// iMouse.y = 0.0 or 0.5: linearly polarized wave.\n// (iMouse.y-0.5)*(iMouse.x-0.5) < 0: The direction of the composed wave rotates counter clockwise.\n\n// iMouse.x = 0.25 or 0.75, iMouse.y = 0.25 or 0.75: circular polarized wave.\n\n// https://en.wikipedia.org/wiki/Polarization_(physics)#Polarization_state\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CALCULATE_EVERYTHING\n    \n    vec3 frameColor = vec3(0.88f, 0.85f, 0.92f);\n    float frameAlpha = drawCircle(fragCoord, iResolution.xy * 0.5f, amplitude, false, thickness);\n    vec3 axisColor = vec3(0.3f, 0.25f, 0.33f);\n    float xAxis = drawLine(fragCoord, vec2(0.0f, iResolution.y * 0.5f), vec2(iResolution.x, iResolution.y * 0.5f), thickness);\n    float yAxis = drawLine(fragCoord, vec2(iResolution.x * 0.5f, 0.0f), vec2(iResolution.x * 0.5f, iResolution.y), thickness);\n    float xVis = drawLine(fragCoord, iResolution.xy * 0.5f + vec2(offsets.x, 0.0f), iResolution.xy * 0.5f + offsets, thickness); \n    float yVis = drawLine(fragCoord, iResolution.xy * 0.5f + vec2(0.0f, offsets.y), iResolution.xy * 0.5f + offsets, thickness); \n    float axisAlpha = clamp(xAxis + yAxis + xVis + yVis, 0.0f, 1.0f);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 bufferA = texture(iChannel0, uv); \n    \n    vec3 backgroundColor = vec3(0.23f, 0.2f, 0.27f);\n    vec4 finalColor = vec4(backgroundColor, 1.0f);\n    finalColor = alphaBlend(bufferA, finalColor);\n    finalColor = alphaBlend(vec4(axisColor, axisAlpha), finalColor);\n    finalColor = alphaBlend(vec4(frameColor, frameAlpha), finalColor);\n    finalColor = alphaBlend(vec4(xColor, xCircle), finalColor);\n    finalColor = alphaBlend(vec4(yColor, yCircle), finalColor);\n    finalColor = alphaBlend(vec4(visColor, visAlpha), finalColor);   \n    \n    fragColor = vec4(finalColor.rgb, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926f\nfloat period = 3.0f;\nfloat amplitude = 150.0f;\nfloat radius = 5.0f;\nfloat thickness = 2.0f;\nvec2 speed = vec2(1.5, -1.0);\nvec2 referenceRes = vec2(640.0f, 360.0f);\n\n#define CALCULATE_EVERYTHING \\\n    float scaleFactor = iResolution.y / referenceRes.y;\\\n    amplitude *= scaleFactor;\\\n    radius *= scaleFactor;\\\n    thickness *= scaleFactor;\\\n    speed *= scaleFactor;\\\n    vec2 phaseOffsets = vec2(0.34f, 0.32f);\\\n    if(iMouse.z > 0.0f)\\\n    {\\\n        phaseOffsets = iMouse.xy / iResolution.xy;\\\n    }\\\n    vec2 offsets = getOffsets(iTime, phaseOffsets.x, phaseOffsets.y);\\\n    vec3 xColor = vec3(0.95f, 0.6f, 0.8f);\\\n    float xCircle = drawCircle(fragCoord, iResolution.xy * 0.5f + vec2(offsets.x, 0.0f), radius, true, thickness);\\\n    vec3 yColor = vec3(0.7f, 0.5f, 0.98f);\\\n    float yCircle = drawCircle(fragCoord, iResolution.xy * 0.5f + vec2(0.0f, offsets.y), radius, true, thickness);\\\n    vec3 visColor = vec3(0.98f, 0.93f, 0.90f);\\\n    float visCircle = drawCircle(fragCoord, iResolution.xy * 0.5f + offsets, radius, true, thickness);\\\n    float visLine = drawLine(fragCoord, iResolution.xy * 0.5f, iResolution.xy * 0.5f + offsets, thickness);\\\n    float visAlpha = clamp(visCircle + visLine, 0.0f, 1.0f);\\\n\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    if(l == 0.0f) return length(p-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdBox(vec2 p, vec2 c, vec2 s, float th)\n{\n    vec2 d = abs(p-c) - s;\n    return (d.x * s.y - d.y * s.x) > 0.0f ? d.x : d.y;\n}\n\nfloat drawLine(vec2 fragCoord, vec2 p1, vec2 p2, float thickness)\n{\n    float sdLine = sdOrientedBox(fragCoord, p1, p2, thickness);\n    return smoothstep(1.5f, 0.0f, sdLine);\n}\n\nfloat drawCircle(vec2 fragCoord, vec2 c, float r, bool solid, float thickness)\n{\n    float sdCir = sdCircle(fragCoord, c, r);\n    if(solid)\n    {\n        return smoothstep(1.5f, 0.0f, sdCir);\n    }\n    else\n    {\n        return smoothstep(0.75f, -0.75f, abs(sdCir)-0.5f*thickness);\n    }\n}\n\nvec4 alphaBlend(vec4 ca1, vec4 ca2)\n{\n    vec3 c = ca1.rgb * ca1.a + ca2.rgb * (1.0f - ca1.a);\n    float a = ca1.a + ca2.a * (1.0f - ca1.a);\n    return vec4(c, a);\n}\n\nvec2 getOffsets(float time, float phi, float xi)\n{\n    float sinPhi = sin(PI * phi);\n    float cosPhi = cos(PI * phi);\n    float xFracTime = fract(time / period);\n    float xOffset = cosPhi * sin(xFracTime * 2.0f * PI);\n    float yFracTime = fract(time / period + xi);\n    float yOffset = sinPhi * sin(yFracTime * 2.0f * PI);\n    return amplitude * vec2(xOffset, yOffset);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CALCULATE_EVERYTHING\n    \n    vec4 finalColor = vec4(0.0f, 0.0f, 0.0f, 0.0f);\n    finalColor = alphaBlend(vec4(xColor, xCircle), finalColor);\n    finalColor = alphaBlend(vec4(yColor, yCircle), finalColor);\n    finalColor = alphaBlend(vec4(visColor, visAlpha), finalColor);\n\n    if(iFrame == 0)\n    {\n        fragColor = finalColor;\n    }\n    else\n    {\n        vec2 uv = (fragCoord + speed) / iResolution.xy;\n        vec4 lastFrame = texture(iChannel0, uv);\n        lastFrame.a *= 0.99f;\n        fragColor = alphaBlend(finalColor, lastFrame);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}