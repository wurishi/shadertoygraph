{"ver":"0.1","info":{"id":"DtcBDS","date":"1701635471","viewed":136,"name":"golden ratio police","username":"Carandiru","description":"exploring golden ratio, spiral improves as more time passes","likes":3,"published":3,"flags":32,"usePreview":0,"tags":["polar","phi","goldenratio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// exploring golden ratio, spiral improves as more time passes\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float bn = (textureLod(iChannel2, fragCoord.xy/1024.0f, 0.0f).r * 2.0f - 1.0f) * (7.0f/255.0f);\n    \n    vec3 s0 = vec3(phi,(1.0f-iphi),iphi)*textureLod(iChannel0, uv, 0.0f).rgb; s0 = s0 + bn*abs(s0 - abs(s0 - textureLod(iChannel0, uv, iphi).rgb));\n    vec3 s1 = vec3(iphi,(1.0f-iphi),phi)*textureLod(iChannel1, uv, 0.0f).rgb; s1 = s1 + bn*abs(s1 - abs(s1 - textureLod(iChannel1, uv, iphi).rgb)); \n    \n    float d = length(s1 - s0) * 0.25f;\n    float att = 1.0f / (1.0f + d*d);\n    \n    vec3 color =  att * mix(s0, s1, fract(iTime));\n    \n    color = pow(color*color, sqrt(vec3(phi*(phi+s0+s1)))) * phi + pow((color*color+bn)*(color*color-bn), vec3(phi)) + bn*((1.0f-color)+0.25f);\n    \n    fragColor = vec4(pow(color, vec3(1.0f/2.2f)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = (phi + phi*(iTime + 1.0f));\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0f - 1.0f;\n    uv.x = uv.x * (iResolution.x/iResolution.y);\n    \n    vec4 last = textureLod(iChannel0, fragCoord/iResolution.xy, 0.0f);\n    vec3 color = vec3(0);\n    \n    float angle = t*gangle*mix(iTimeDelta, t/(float(iFrame + 1)), 0.5f) + last.w;\n\n    uv = rotate(uv, angle);\n\n    vec2 p = pow(vec2(iphi), ((2.0f*uv))) * 2.0f - 1.0f;\n    \n    float tangent = atan(uv.x, uv.y);\n    \n    float logspiral = log(length(uv))/log(phi) + tangent;\n    logspiral = sin(logspiral);\n    \n    // reset\n    //uv = fragCoord/iResolution.xy;\n    //uv = uv * 2.0f - 1.0f;\n    \n    float d = logspiral;\n    \n    float hw = 0.5f * fwidth(d);\n    d = smoothstep(-hw, hw, d);\n    \n    color = vec3(d);\n\n    float triangle_wave = abs(fract(angle)/(1.0f + dot(p-uv,p-uv)) * 2.0f - 1.0f);\n\n    fragColor = vec4(mix(color*(1.0f-last.rgb), color*last.rgb, triangle_wave) * iphi + (last.rgb)*(1.0-iphi), angle);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define pi 3.14159265358979323846\n#define GOLDEN_RATIO (1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243) // 1618033988\n#define GOLDEN_RATIO_ZERO (0.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243)\n#define GOLDEN_ANGLE ( 2.0f * pi * (1.0f/(GOLDEN_RATIO*GOLDEN_RATIO)) )\n#define phi GOLDEN_RATIO \n#define iphi GOLDEN_RATIO_ZERO\n#define gangle GOLDEN_ANGLE\n\n#define fma(a,b,c) (a*b+c)\n\nvec2 rotate( in vec2 p, in float angle )\n{\n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = (phi + phi*(iTime + 1.0f) + 1.0f); // +1\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0f - 1.0f;\n    uv.x = uv.x * (iResolution.x/iResolution.y);\n    \n    vec4 last = textureLod(iChannel0, fragCoord/iResolution.xy, 0.0f);\n    vec3 color = vec3(0);\n    \n    float angle = t*gangle*mix(iTimeDelta, t/(float(iFrame + 1) + 1.0f/iTimeDelta), 0.5f) + last.w;\n\n    uv = rotate(uv, angle);\n\n    vec2 p = pow(vec2(iphi), ((2.0f*uv))) * 2.0f - 1.0f;\n    \n    float tangent = atan(uv.x, uv.y);\n    \n    float logspiral = log(length(uv))/log(phi) + tangent;\n    logspiral = sin(logspiral);\n    \n    // reset\n    //uv = fragCoord/iResolution.xy;\n    //uv = uv * 2.0f - 1.0f;\n    \n    float d = logspiral;\n    \n    float hw = 0.5f * fwidth(d);\n    d = smoothstep(-hw, hw, d);\n    \n    color = vec3(d);\n\n    float triangle_wave = abs(fract(angle)/(1.0f + dot(p-uv,p-uv)) * 2.0f - 1.0f);\n\n    fragColor = vec4(mix(color*(1.0f-last.rgb), color*last.rgb, triangle_wave) * (iphi) + (last.rgb)*(1.0-iphi), angle);\n}","name":"Buffer B","description":"","type":"buffer"}]}