{"ver":"0.1","info":{"id":"cdsBzN","date":"1688526616","viewed":50,"name":"Kaleidoscope effect","username":"TastyTortilla","description":"A shader that mirrors an image like these triangle mirror thingies you might have had one of as a child.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["kaleidoscope","mirror"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n * An algorithm that mirrors an image inside a triangle grid\n * using the properties how the pattern repeats after 2 rows\n * and how uv vertex indices repeat after 6 triangles in each row.\n * \n *       1-----2-----0\n *      / \\   / \\   /\n *     /   \\ /   \\ /\n *    2-----0-----1\n *   / \\   / \\   /\n *  /   \\ /   \\ /\n * 0-----1-----2\n *\n * By shearing the uv coordinates to look like a square grid\n * it's easier to find out in which triangle a uv coord lies.\n * \n *  1--2--0  *pretend these are perfect squares*\n *  |\\ |\\ |\n *  | \\| \\|\n *  2--0--1\n *  |\\ |\\ |\n *  | \\| \\|\n *  0--1--2\n *\n * The triangle's vertices are then used to perform a barycentric interpolation.\n */\n\nvec3 barycentric(vec2 p, vec2 a, vec2 b, vec2 c) {\n    vec2 v0 = b - a;\n    vec2 v1 = c - a;\n    vec2 v2 = p - a;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0f - v - w;\n    return vec3(u, v, w);\n}\n\nfloat wrap(float value, float minValue, float maxValue) {\n    return minValue + mod(value - minValue, maxValue - minValue);\n}\n\nconst vec2 SCREEN_RES = vec2(640, 360);\nconst float ASPECT = SCREEN_RES.x / SCREEN_RES.y;\n\n//number of horizontal triangle rows on the screen\nconst float TRIANGLE_ROWS = 3.;\n//how much of the height of the channel input a triangle covers\nconst float triHeight = 1.0;\nconst float triHalfWidth = triHeight / sqrt(3.0) / ASPECT;\n\n//the 3 possible uvs for all triangles in the kaleidoscope\nvec2[3] triangleUvs = vec2[3](\n    vec2(0.5 - triHalfWidth, 0.0), \n    vec2(0.5 + triHalfWidth, 0.0), \n    vec2(0.5, triHeight));\n//the 4 vertices of 2 triangles in a sheared triangle grid\nvec2[4] squareVerts = vec2[4](\n    vec2(0.0, 0.0), \n    vec2(1.0, 0.0), \n    vec2(0.0, 1.0), \n    vec2(1.0, 1.0));\n\nvec2 kaleidoscopeUV(vec2 uv) {\n    vec2 pos = uv;\n    //center triangles horizontally;\n    pos.x += 0.5 + 0.5 * triHalfWidth / TRIANGLE_ROWS;\n    //map triangle width & height to 01 range\n    pos *= vec2(ASPECT, 1.0) / vec2(2.0 / sqrt(3.0), 1.0) * TRIANGLE_ROWS;\n    \n    //wrap pattern after 2 mirroring rows of triangles\n    pos.y = abs(wrap(pos.y, -1.0, 1.0));\n    \n    //rectify triangle position by shearing for easier calculations\n    float shearX = 0.5 * pos.y;\n    pos.x -= shearX;\n    //wrap position after 6 triangles in a row\n    pos.x = mod(pos.x, 3.0);\n\n    //calculate which of the 6 possible triangles the position is inside\n    int vertIndex = int(pos.x / 1.0);\n\n    //calculate which square the triangle is in\n    pos.x = mod(pos.x, 1.0);\n    //ofsset indices 1 more if triangle is ponting downwards\n    int indexOffset = int(pos.x + pos.y);    \n    vertIndex += indexOffset;\n\n    //interpolate weights of the 3 (square) vertices surrounding the position\n    vec3 uvw = barycentric(\n        pos, \n        squareVerts[indexOffset], \n        squareVerts[indexOffset + 1], \n        squareVerts[indexOffset + 2]);\n    //use weights to scale triangle uvs\n    vec2 uvInterpolated =\n        uvw.x * triangleUvs[vertIndex % 3] +\n        uvw.y * triangleUvs[(vertIndex + 1) % 3] +\n        uvw.z * triangleUvs[(vertIndex + 2) % 3];\n\n    return uvInterpolated;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = kaleidoscopeUV(uv);\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"}]}