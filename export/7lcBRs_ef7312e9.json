{"ver":"0.1","info":{"id":"7lcBRs","date":"1663500836","viewed":69,"name":"Teapot DOMASHKA","username":"ilyabelow","description":"This is the first task for computer graphics course","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["teapot","cool","homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 500.\n\n#define EPS 0.01\n#define PI 3.141592\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\n\nfloat hard_intersect(float a, float b) {\n    return max(a, b);\n}\n\nfloat hard_union(float a, float b) {\n    return min(a, b);\n}\n\nfloat smooth_union(float k, float d1, float d2) {\n    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);\n\n    return mix(d2, d1, h) - k*h*(1.0-h); \n}\n\nfloat smooth_subtract(float k, float d1, float d2) {\n    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);\n\n    return mix(d2, -d1, h) + k*h*(1.0-h); \n}\n\nfloat smooth_intersect(float k, float d1, float d2) {\n    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);\n\n    return mix(d2, d1, h) + k*h*(1.0-h); \n}\n\nfloat cylinder_sdf(vec3 p, vec3 center, mat3 rot, vec3 a, vec3 b, float r){\n    vec3 pt = abs(rot * (p-center));\n    vec3 ba = b - a;\n    vec3 pa = pt - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n\n    return sign(d)*sqrt(abs(d))/baba;\n}\nfloat torus_sdf(vec3 p, vec3 center, mat3 rot, float R, float r){\n    p = rot * (p-center);\n    vec2 q = vec2(length(p.xz) - R, p.y);\n\n    return length(q) - r;\n}\n\nfloat sphere_sdf(vec3 p, vec3 center, float radius) {\n    return length(p - center) - radius;\n}\n\n\nfloat plane_sdf(vec3 p, vec3 n, float d) {\n    return dot(p, n)-d;\n}\n\nfloat cone_sdf(vec3 p, vec3 center, float h, float r1, float r2)\n{\n    vec2 q  = vec2(length((p-center).xz), (p-center).y);\n    vec2 k1 = vec2(r2, h);\n    vec2 k2 = vec2(r2 - r1, 2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n\n    return s*sqrt(min(dot(ca, ca),dot(cb, cb)));\n}\n\nfloat sdf(vec3 p) {\n    return hard_union(plane_sdf(p, vec3(0,1,0), -5.),\n    smooth_union(0.2,cone_sdf(p, vec3(0,1.8,0), .5, .05, .3),\n    smooth_union(0.4, torus_sdf(p, vec3(-2, .3, 0), rotateX(PI*.5), .75, .1),\n    smooth_union(0.3,\n        smooth_intersect(.5, \n            cylinder_sdf(p, vec3(2,1,0), rotateZ(-PI*.25), vec3(0), vec3(0,.5,0), .2),\n            plane_sdf(p, vec3(0,1,0), 1.4)),\n    smooth_intersect(0.5, plane_sdf(p, vec3(0,-1,0), 1.),\n    smooth_union(0.1, sphere_sdf(p, vec3(0,.1,0), 1.8),\n    smooth_subtract(0.1, sphere_sdf(p, vec3(0,1,0), 1.5),\n    sphere_sdf(p, vec3(0), 2.))))))));    \n}\n\n\n\nvec3 trace(vec3 from, vec3 dir, out bool hit) {\n    vec3 p = from;\n    hit = false;\n    float total_dist = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float t = sdf(p);\n        if (t <= EPS) {\n            hit = true;\n            break;\n        }\n        p += t * dir;\n        total_dist += t;\n        if (total_dist > MAX_DIST) {\n            break;\n        }\n    }\n    return p;\n}\n\n\nvec3 norm (vec3 p)\n{\n    float d = EPS;\n    float dx1 = sdf(p + vec3(d, 0, 0));\n    float dx2 = sdf(p - vec3(d, 0, 0));\n    float dy1 = sdf(p + vec3(0, d, 0));\n    float dy2 = sdf(p - vec3(0, d, 0));\n    float dz1 = sdf(p + vec3(0, 0, d));\n    float dz2 = sdf(p - vec3(0, 0, d));\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvec3 direction(in vec2 fragCoord) {\n    float scale = 4.;\n    vec2 uv = scale*(fragCoord-.5*iResolution.xy)/max(iResolution.x, iResolution.y);\n    return normalize(vec3(uv, 1));\n}\n\nvec4 sky( in vec2 fragCoord) {\n    float h = fragCoord.y / iResolution.y;\n\n    return (vec4(180,218,231,1)*(1. - h) + vec4(1,114,184,1)*h)/255.;\n}\n\nfloat shadow(vec3 p, vec3 light, float hardness) {\n    float min_dist = MAX_DIST;\n    float prev_t = 0.;\n    float dist_left = length(light - p);\n    vec3 dir = (light - p) / dist_left;\n    p += dir*0.1;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float t = sdf(p);\n        if (t < prev_t && t < min_dist) {\n            min_dist = t;\n        }\n        prev_t = t;\n        p += t * dir;\n        dist_left -= t;\n        if (dist_left <= 0.) {\n            break;\n        }\n    }\n    return 1./(1.+exp(-hardness*min_dist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy -vec2(0.5, 0.5);\n    mat3 m = rotateX(6.28*mouse.y) * rotateY(-6.28*mouse.x);\n\n    vec3 eye = m*vec3(0,0,-4);\n    vec3 dir = m*direction(fragCoord);\n    vec3 light = vec3(10.*cos(iTime),4.+6.*sin(iTime*2.),10.*sin(iTime));\n\n    bool hit = false;\n    vec3 p = trace(eye, dir, hit);\n    if (!hit) {\n        fragColor = sky(fragCoord);\n        return;\n    }\n    vec3 n = norm(p);\n    vec3 l = normalize(light - p);\n    vec3 v = normalize(eye - p);\n    vec3 r = 2.*n*dot(n, l) - l;\n    \n    float lambert = max(0., dot(n, l));\n    float phong = pow(max(0., dot(v, r)), 100.);\n    \n    fragColor = shadow(p, light, 100.)*(lambert+phong)*vec4(1,1,1,1);\n}","name":"Image","description":"","type":"image"}]}