{"ver":"0.1","info":{"id":"4fVGWV","date":"1713294710","viewed":33,"name":"shiny spheres test","username":"daisyowl","description":"look at them!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracingspheres"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_BOUNCES 4\n#define PASSES_PER_FRAME 1\n#define JITTER 0\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float rough;\n    float diffuse;\n    float radius;\n    float emissive;\n};\n\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nRay castSphere(Ray ray, Sphere sphere);\nvec3 raycast(Ray ray);\n\nconst int count = 6;\nSphere[count] spheres = Sphere[count](\n    Sphere(vec3(0.0, -1000, 0.0), 0.0, 0.2, 980.0, 0.0),\n    Sphere(vec3(0.0, 1000, 0.0), 0.0, 0.9, 980.0, 1.0),\n    Sphere(vec3(0.0, 3.0, 10.0), 0.0, 0.9, 1.5, 0.0),\n    Sphere(vec3(3.0, -2.0, 10.0), 0.0, 0.9, 1.5, 0.0),\n    Sphere(vec3(-3.0, -2.0, 10.0), 0.0, 0.9, 1.5, 0.0),\n    Sphere(vec3(0.0, 0.0, 15.0), 0.0, 0.9, 4.0, 0.0)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 accum = vec3(0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    int i = 0;\n    for ( i = 0; i < PASSES_PER_FRAME; i++) { \n        Ray ray = Ray(vec3(0.0), normalize(vec3(uv - 0.5, 1.0) * vec3(aspectRatio, 1.0, 1.0)));\n        ray.pos.x += sin(iTime*1.0) * 3.0;\n        #if JITTER\n        ray.dir += vec3(\n            rand(float(i) + iTime), \n            rand(float(i) + iTime + 0.1), \n            rand(float(i) + iTime + 0.2)\n        ) * 0.001;\n        #endif\n        vec3 col = raycast(ray);\n        accum += col;\n    }\n    fragColor = vec4(accum/float(i),1);\n}\n\n\nvec3 raycast(Ray ray) {\n    vec3 diffuse = vec3(1.0, 1.0, 1.0);\n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        float closestDist = 10000.0;\n        Ray closest = Ray(vec3(0.0), vec3(0.0));\n        Sphere closestSphere = Sphere(vec3(0.0), 0.0, 0.0, 0.0, 0.0);\n        for (int j = 0; j < count; j++) {\n            Sphere sphere = spheres[j];\n            Ray res = castSphere(ray, sphere);\n            if (res.dir != vec3(0.0)) {\n                float dist = length(ray.pos - res.pos);\n                if (dist < closestDist) {\n                    closestDist = dist;\n                    closest = res;\n                    closestSphere = sphere;\n                }\n            }\n        }\n        if (closest.dir != vec3(0.0)) {\n            if (closestSphere.emissive > 0.0) {\n                return vec3(closestSphere.emissive) * diffuse;\n            }\n            ray = closest;\n            diffuse = diffuse * closestSphere.diffuse;\n        } else {\n            // we didn't hit anything\n            break;\n        }\n    }\n\n    float skyColor = 0.5 * (ray.dir.y + 1.0);\n\n    return diffuse * skyColor;\n}\n\nRay castSphere(Ray ray, Sphere sphere) {\n    vec3 pos = ray.pos;\n    vec3 dir = ray.dir;\n    vec3 spherePos = sphere.pos;\n    float sphereRadius = sphere.radius;\n\n    vec3 offset = pos - spherePos;\n    float dd = dot(dir, dir);\n\n    // quadratic eq\n    float a = dd;\n    float b = 2.0 * dot(offset, dir);\n    float c = dot(offset, offset) - sphereRadius * sphereRadius;\n\n    float hitDist1 = (-b + sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n    float hitDist2 = (-b - sqrt(b * b - 4.0 * a * c)) / (2.0 * a);\n\n    float hitDist = min(hitDist1, hitDist2);\n    bool isHit = hitDist < 100000.0 && hitDist > 0.0;\n\n    if (isHit) {\n        // reflection math\n        vec3 hitSpot = pos + dir * hitDist;\n        vec3 normal = normalize(hitSpot - spherePos);\n        vec3 reflected = normalize(dir + normal * -2.0 * dot(dir, normal));\n\n        if (sphere.rough > 0.0) {\n            // roughness\n            vec3 randDir = normalize(normal + vec3(\n                rand(fract(iTime) + hitSpot.x + hitDist),\n                rand(fract(iTime) + hitSpot.y + hitDist+0.1),\n                rand(fract(iTime) + hitSpot.z + hitDist+0.2)\n            ) * sphere.rough);\n\n            if (dot(randDir, normal) < 0.0) {\n                randDir = -randDir;\n            }\n            reflected = randDir;\n        }\n\n        return Ray(hitSpot, reflected);\n    }\n\n    return Ray(vec3(0.0), vec3(0.0));\n\n}\n","name":"Image","description":"","type":"image"}]}