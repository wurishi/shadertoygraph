{"ver":"0.1","info":{"id":"lXfBDj","date":"1729177983","viewed":218,"name":"brick circle SDF","username":"dottedboxguy","description":"somehow reminds me of stargate\nit's possible to align all the bricks so one of their sides are all at the same level, in order to make good arches for windows or bridges","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["sdf","distance","brick","arch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define PI_INV 0.31830988618\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n//trapezoid SDF from IQ\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he ){\n    p = vec2(p.y, -p.x);\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat brick_size(float id, float n, float r){\n    return (cos(mod(round(id)+.4, 2.)*PI)*.5+.5)*.5*r;\n}\n\nfloat sdBrickCircle(vec2 p, float r, float n, float padding, float rotation){\n\n    float inv_n = 1./n;\n    rotation *= n;\n    \n    vec2 point = p;\n    float angle = atan(point.y, point.x); // angle from the x axis\n    float neighbor = 0.;\n    \n    //quantization of the normal's angle. you must normalize the angle before doing quantization\n    angle *= n*PI_INV;\n    \n    angle += rotation;\n    \n    angle = floor(angle);\n    \n    vec2 ids = vec2(angle);\n    \n    angle -= rotation;\n    \n    ids.y += 1.;\n    \n    neighbor = angle + 1.;\n    \n    angle *= inv_n;\n    angle *= PI;\n    neighbor *=PI*inv_n;\n    \n    //recunstructing the normals\n    vec2 right = vec2(cos(angle), sin(angle));\n    vec2 left = vec2(cos(neighbor), sin(neighbor));\n    \n    vec2 sizes = vec2(brick_size(ids.x, n, r), brick_size(ids.y, n, r));\n    \n    //note : you can make the brick size not depend on the radius by removing r here\n    vec4 radii = vec4((1.-cos(inv_n*PI))/sin(inv_n*PI));\n    radii *= r + vec4(sizes.x, -sizes.x, sizes.y, -sizes.y);\n    radii-=padding;\n    \n    vec3 brick0 = vec3(sizes.x, radii.x, radii.y);\n    vec3 brick1 = vec3(sizes.y, radii.z, radii.w);\n    \n    vec2 p_right = vec2(p.x*right.x + p.y*right.y, p.x*right.y - p.y*right.x);\n    p_right.x-=r;\n    \n    float d = sdTrapezoid(p_right, brick0.y, brick0.z, brick0.x);\n    \n    vec2 p_left = vec2(p.x*left.x + p.y*left.y, p.x*left.y - p.y*left.x);\n    p_left.x-=r;\n\n    d = min(d, sdTrapezoid(p_left, brick1.y, brick1.z, brick1.x));\n    \n    return d;\n}\n\nfloat scene(vec2 p){\n    float n = ceil(.2*iTime+2.001);\n    float r = 2.5+1.7*cos(iTime*.5+.29);\n    float rotation = (.5+.5*cos(.3*iTime));\n    float padding = .5*sin(iTime*.3)+.5;\n    float d = sdBrickCircle(p, r, n, padding/n, rotation);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv*=10.;\n    vec2 m = iMouse.xy/iResolution.xy;\n    m-=.5;\n    m.x *= iResolution.x/iResolution.y;\n    m*=10.;\n\n    float d = scene(uv);\n\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    col *= 1.0 - exp(-4.0*abs(d));\n    col *= 0.8 + 0.2*cos(80.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.03,abs(d)));\n    \n    float d_m = scene(m);\n    \n    d = length(uv-m)-abs(d_m);\n    \n    col = mix(vec3(.9, .9, .1), col, clamp(abs((d)*20.), 0.,1.));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}