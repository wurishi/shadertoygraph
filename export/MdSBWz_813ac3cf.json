{"ver":"0.1","info":{"id":"MdSBWz","date":"1500028799","viewed":160,"name":"Not Mars","username":"clumsyrthanu","description":"This is not mars.\n\nWritten using this tutorial on reddit: \nhttps://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","tutorial","sphere","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A lot of the comments and code are from this tutorial on reddit: \n// https://www.reddit.com/r/twotriangles/comments/1hy5qy/tutorial_1_writing_a_simple_distance_field/\n// Additional sources, mentioned below, used for texturing and rotation\n\nconst int MAX_ITERATIONS = 100; // Iterations for the raymarch\nconst float MAX_DISTANCE = 20.0; // Max distance away from the camera\nconst float EPSILON = 0.001; // At this distance we are close enough to the object that we have essentially hit it\n\nconst float PI = 3.14159;\n\n// Distance Function for a sphere\nfloat distanceFunction(vec3 position)\n{\n    return length(position) - 5.0; // Radius\n}\n\n// Rotates point by angle degrees about the Y axis\nvec3 calculateRotationY(float angle, vec3 point)\n{\n    float r = radians(angle);\n    float x = point.x * sin(r) - point.z * cos(r);\n    float z = point.x * cos(r) + point.z * sin(r);\n    return vec3(x, point.y, z);\n}\n\n// Rotates point by angle degrees about the X axis\nvec3 calculateRotationX(float angle, vec3 point)\n{\n    float r = radians(angle);\n    float y = point.y * sin(r) - point.z * cos(r);\n    float z = point.y * cos(r) + point.z * sin(r);\n    return vec3(point.x, y, z);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Basic scene setup\n    vec3 cameraOrigin = vec3(0.0, 0.0, 8.0); // The location of the camera\n    vec3 cameraTarget = vec3(0.0, 0.0, 0.0); // Where the camera is looking at\n    vec3 upDirection = vec3(0.0, 1.0, 0.0); // the world up direction\n        \n    // Calculate camera basis\n    vec3 cameraDirection = normalize(cameraTarget - cameraOrigin); // The camera forward direction (z axis)\n    vec3 cameraRight = normalize(cross(upDirection, cameraOrigin)); // The camera right direction (x axis)\n    vec3 cameraUp = cross(cameraDirection, cameraRight); // The camera top direction (y axis)\n    \n    vec3 lightDirection = normalize(vec3(1.5, 0.6, -0.8)); // The direction of the light\n\n    // Calculate normalized screen position coord, with aspect ratio correction.\n    // The normalized coords are in the range of [-1, 1].\n\n    vec2 screenPosition = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    screenPosition.x *= iResolution.x / iResolution.y;\n    \n    // Calculate the direction of the ray represented by the current screen pixel\n    // The ray direction is going outward of the screen, starting from each screen pixel\n    // This is transformed using the camera basis in order to account for the effect of the camera\n    // on the object. Visualize a frustum with its smaller plane as the screen, that is the effect of\n    // calculating a ray direction using each pixel.\n    \n    vec3 rayDirection = normalize(cameraRight * screenPosition.x + cameraUp * screenPosition.y + cameraDirection);\n        \n    // The basic idea behind raymarching is you define a function which returns the shortest \n    // distance you can travel from a given point in any direction (the ray we calculated) \n    // before you hit an object. We can then iterate a number of times, advancing the ray \n    // forwards by this distance each time, and we are guaranteed to never miss any objects. \n    // We check this distance every iteration, and if it is smaller than EPSILON then we have \n    // hit an object. If the total distance traveled is very large, we assume that we will \n    // never hit anything.\n    \n    // Initialize variables for starting the march\n    float totalDistance = 0.0;\n    vec3 position = cameraOrigin;\n    float dist = EPSILON;\n    \n    for (int i = 0; i < MAX_ITERATIONS; i++)\n    {\n        // Either we've hit the object or gone beyond the max distance\n        if (dist < EPSILON || totalDistance > MAX_DISTANCE)\n            break;\n        \n        dist = distanceFunction(position);\n        totalDistance += dist;\n        position += dist * rayDirection;\n    }\n    \n    if (dist < EPSILON)\n    {\n        // Within this if block, The dist variable represents a surface point, \n        // so this is where the rotation, normal, texture and lighting calculations \n        // are done.\n        \n        // The rotation speed is set to 10 degrees per second.\n        // The object is first rotated around X by 90 to set its poles correctly,\n        // then it is rotated by angle degrees around Y axis for its rotation\n        // Rotation formula reference: https://en.wikipedia.org/wiki/Rotation_matrix\n                \n        float angle = (iTime * 10.0);\n        position = calculateRotationY(angle, calculateRotationX(-90.0, position));\n        lightDirection = calculateRotationY(angle, calculateRotationX(-90.0, lightDirection));\n        \n        // In order to calculate lighting, you need to find the normal of the surface. \n        // This is a vector which points perpendicular to the surface. \n        // Using the distance function, we can calculate this rather easily by sampling a \n        // few points.\n                \n        vec3 epsx = vec3(EPSILON, 0.0, 0.0);\n        vec3 epsy = vec3(0.0, EPSILON, 0.0);\n        vec3 epsz = vec3(0.0, 0.0, EPSILON);\n        \n        vec3 normal = normalize(vec3(\n            distanceFunction(position + epsx) - distanceFunction(position - epsx),\n            distanceFunction(position + epsy) - distanceFunction(position - epsy),\n            distanceFunction(position + epsz) - distanceFunction(position - epsz)\n        ));\n        \n        // Calculate the diffuse lighting\n        float diffuse = max(0.0, dot(-lightDirection, normal));\n        \n        // Set a constant ambient light to brighten the object\n        float ambient = 0.15;\n        \n        // Use normal.xy to calculate the texcoord.uv for the sphere,\n        // Mercator projection to map a flat image onto a sphere\n        // https://en.wikipedia.org/wiki/Mercator_projection\n        vec2 texCoord;\n        texCoord.y = 1.0 - (asin(normal.y) / PI + 0.5);        \n        if (normal.x < 0.0)\n        {\n            texCoord.x = 1.0 - (0.5 * atan(normal.z / normal.x) / PI + 0.25);\n        }\n        else if (normal.x > 0.0)\n        {\n            texCoord.x = 1.0 - (0.5 * atan(normal.z / normal.x) / PI + 0.75);\n        }\n        else\n        {\n            texCoord.x = 0.5;\n        }\n        \n        vec3 color = (vec3(diffuse) + vec3(ambient)) * texture(iChannel0, texCoord).rgb;\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}