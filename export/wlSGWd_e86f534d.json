{"ver":"0.1","info":{"id":"wlSGWd","date":"1561493825","viewed":521,"name":"GPU hacks #08 - OpenCL","username":"PrzemyslawZaworski","description":"Next step in mastering GPU programming - this time we use OpenCL to render raymarching fractal.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["framework","tutorial","code"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nReference: https://www.khronos.org/files/opencl-quick-reference-card.pdf\nSave code as demo.cl and compile by NVCC compiler (or equivalent):\nnvcc -x cu -o demo.exe demo.cl -luser32 -lgdi32 -lOpenCL\nPaste own code inside ComputeKernel. Press ESC to exit program.\n*/\n\n/*\n#include <windows.h>\n#include <CL/cl.h>\n\n#define width 1280\n#define height 720\n\nstatic const char* ComputeKernel =\n\"float3 map (float3 p)\"\n\"{\"\n\t\"for (int i = 0; i < 16; ++i)\"\n\t\"{\"\n\t\t\"p = fabs(p/dot(p,p)-(float3)(0.64,0.46,0.93));\"   \n\t\"}\"\t\n\t\"return (float3)(p.x/50.,p.y/50.,p.z/50.);\"\n\"}\" \n\"float4 raymarch (float3 ro, float3 rd)\"\n\"{\"\n\t\"float3 c = (float3)(0.,0.,0.);\"\n\t\"float t = 0.0;\"\n\t\"for(int i=0; i<50; ++i)\"\n\t\"{\"\n\t\t\"t+=0.5;\"\n\t\t\"c+=map(ro+t*rd);\"\n\t\"}\"\n\t\"return clamp((float4)(c,1.0),(float4)(0.0,0.0,0.0,0.0),(float4)(1.0f,1.0f,1.0f,1.0f));\"\n\"}\"\n\"__kernel void mainImage(__global uchar4 *fragColor, float iTime)\"\n\"{\"\n\t\"unsigned int id = get_global_id(0);\"\n\t\"int2 iResolution = {1280, 720};\"\n\t\"int2 fragCoord = {id % iResolution.x, id / iResolution.x};\" \n\t\"float2 uv = {(2.0 * fragCoord.x - (float)iResolution.x - 1.0) / iResolution.y, (2.0 * fragCoord.y - (float)iResolution.y) / iResolution.y};\"\n\t\"float3 ro = {0.0,3.0*cos(iTime * 0.05),6.0};\"\n\t\"float3 rd = normalize((float3)(uv,2.0));\"\n\t\"rd = (float3)(dot((float3)(1,0,0),rd), dot((float3)(0, cos(iTime * 0.3),sin(iTime * 0.3)),rd),  dot((float3)(0,-sin(iTime * 0.3),cos(iTime * 0.3)),rd));\"\n\t\"rd = (float3)(dot((float3)(cos(iTime * 0.1),sin(iTime * 0.1),0),rd),  dot((float3)(-sin(iTime * 0.1),cos(iTime * 0.1),0),rd), dot((float3)(0,0,1),rd));\"\n\t\"float4 q = raymarch(ro,rd);\"\n\t\"fragColor[id] = (uchar4)( q.z * 255, q.y * 255, q.x * 255, 255);\"\n\"}\";\n\nstatic LRESULT CALLBACK WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)\n{\n\tif (uMsg == WM_KEYUP && wParam == VK_ESCAPE)\n\t{\n\t\tPostQuitMessage(0);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn DefWindowProc(hWnd, uMsg, wParam, lParam);\n\t}\n}\n\nint WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)\n{\n\tint exit = 0;\n\tMSG msg;\n\tWNDCLASS win = {CS_OWNDC|CS_HREDRAW|CS_VREDRAW, WindowProc, 0, 0, 0, 0, 0, (HBRUSH)(COLOR_WINDOW+1), 0, \"OpenCL Demo\"};\n\tRegisterClass(&win);\n\tHWND hwnd = CreateWindowEx(0, win.lpszClassName, \"OpenCL Demo\", WS_VISIBLE|WS_OVERLAPPEDWINDOW, 0, 0, width, height, 0, 0, 0, 0);\n\tconst BITMAPINFO bmi = { {sizeof(BITMAPINFOHEADER),width,height,1,32,BI_RGB,0,0,0,0,0},{0,0,0,0} };\n\tunsigned char* host = (unsigned char*) malloc(width*height*sizeof(uchar4));\n\tsize_t bytes;\t\n\tcl_uint platformCount;\n\tclGetPlatformIDs(0, 0, &platformCount);\n\tcl_platform_id* platforms = (cl_platform_id*) malloc(sizeof(cl_platform_id) * platformCount);\n\tclGetPlatformIDs(platformCount, platforms, 0);\n\tcl_context_properties properties[] = {CL_CONTEXT_PLATFORM, (cl_context_properties)platforms[0], 0};\n\tcl_context context = clCreateContextFromType (properties, CL_DEVICE_TYPE_GPU, 0, 0, 0);\n\tclGetContextInfo (context, CL_CONTEXT_DEVICES, 0, 0, &bytes);\n\tcl_device_id* info = (cl_device_id*) malloc (bytes);\t\n\tclGetContextInfo (context, CL_CONTEXT_DEVICES, bytes, info, 0);\t\n\tcl_program program = clCreateProgramWithSource (context, 1, &ComputeKernel, 0, 0);\n\tclBuildProgram (program, 0, 0, 0, 0, 0);\n\tcl_kernel kernel = clCreateKernel (program, \"mainImage\", 0);\t\n\tcl_command_queue queue = clCreateCommandQueue (context, info[0], 0, 0); \n\tcl_mem buffer = clCreateBuffer (context, CL_MEM_WRITE_ONLY, width*height*sizeof(uchar4), 0, 0);\n\tclSetKernelArg (kernel, 0, sizeof(cl_mem), (void*)&buffer);\n\tsize_t size = width * height;\n\twhile (!exit)\n\t{\n\t\twhile(PeekMessage(&msg, 0, 0, 0, PM_REMOVE))\n\t\t{\n\t\t\tif( msg.message==WM_QUIT ) exit = 1;\n\t\t\tTranslateMessage( &msg );\n\t\t\tDispatchMessage( &msg );\n\t\t}\n\t\tfloat time = GetTickCount() * 0.001f;\n\t\tclSetKernelArg (kernel, 1, sizeof(cl_float), (void*)&time);\n\t\tclEnqueueNDRangeKernel(queue,kernel, 1, 0, &size, 0, 0, 0, 0);\t\n\t\tclEnqueueReadBuffer (queue, buffer, 1, 0, width*height*sizeof(uchar4), host, 0, 0, 0);\t\t\n\t\tStretchDIBits(GetDC(hwnd),0,0,width,height,0,0,width,height,host,&bmi,DIB_RGB_COLORS,SRCCOPY);\n\t}\n\treturn 0;\n}\n*/\n\nvec3 map (vec3 p)\n{\n\tfor (int i = 0; i < 16; ++i)\n\t{\n\t\tp = abs(p/dot(p,p)-vec3(0.64,0.46,0.93));    \n\t}\t\n\treturn p/50.;\n}\n\t\t\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n\tvec3 c = vec3(0,0,0);\n    float t = 0.0;\n\tfor(int i=0; i<50; ++i)\n\t{\n\t\tt+=0.5;\n\t\tc+=map(ro+t*rd);\n\t}\n\treturn vec4(c,1.0);\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n\tvec3 ro = vec3 (0.0,3.0*cos(iTime * 0.05),6.0) ;\n\tvec3 rd = normalize(vec3(uv,2.0)) ;\n    rd = vec3(dot(vec3(1,0,0),rd), dot(vec3(0, cos(iTime * 0.3),sin(iTime * 0.3)),rd), dot(vec3(0,-sin(iTime * 0.3),cos(iTime * 0.3)),rd));\n    rd = vec3(dot(vec3(cos(iTime * 0.1),sin(iTime * 0.1),0),rd), dot(vec3(-sin(iTime * 0.1),cos(iTime * 0.1),0),rd), dot(vec3(0,0,1),rd));\n    fragColor = raymarch(ro,rd);\n}","name":"Image","description":"","type":"image"}]}