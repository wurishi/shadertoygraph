{"ver":"0.1","info":{"id":"3sSczR","date":"1585925597","viewed":364,"name":"Basic MandelBulb","username":"boris159","description":"I really have no ideas how does it work but it looks nice.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","mandelbulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 256.0\n#define MAX_STEPS 256\n#define it 10\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    \n    return normalize(vec3(res / iResolution.yy, 1));\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nfloat mandelBulb(vec3 p, vec3 fp, float power, vec3 ang)\n{\n    p -= fp;\n    p = rotVec(p, ang);\n    \n\tvec3 z = p;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\t\n\tfor(int i = 0; i < it; ++i)\n    {\n\t\tr = length(z);\n        \n\t\tif(r > 2.0)\n            continue;\n        \n\t\ttheta = atan(z.y / z.x);\n        phi = asin(z.z / r) + iTime;\n\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\tr = pow(r, power);\n        \n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\t\n\t\tz = r * vec3(cos(theta) * cos(phi),\n                     sin(theta) * cos(phi), \n                     sin(phi)) + p;\n\t}\n    \n\treturn 0.5 * log(r) * r / dr;\n}\n\nfloat getDist(vec3 origin)\n{\n    vec3 fp = vec3(0);\n    vec3 fr = vec3(0, PI + PI / 4.0, 0);\n    float power = 8.0;\n    \n    return mandelBulb(origin, fp, power, fr);\n}\n\nvec2 rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        float d = getDist(tmp);\n        res += d;\n        \n        if (res >= MAX_DIST || d < EPSILON)\n        \treturn vec2(res, float(i));\n    }\n\n    return vec2(res, float(MAX_STEPS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 origin = vec3(0, 0, -3);\n    vec3 dir = makeRay(fragCoord);\n    \n    vec2 res = rayMarch(origin, dir);\n    float d = res.x;\n    vec3 col;\n    \n    vec3 startCol = vec3(cos(iTime) * 0.25 + 0.75, 0, 0);\n    vec3 finCol = vec3(0, 0, sin(iTime) * 0.25 + 0.75);\n    float delta = 0.5;\n    \n    if (d < MAX_DIST)\n    {\n    \tvec3 p = origin + d * dir;\n        delta = length(p) / 2.0;\n    }\n    \n    col = mix(startCol, finCol, delta) * res.y / float(MAX_STEPS) * 5.0;\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}