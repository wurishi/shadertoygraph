{"ver":"0.1","info":{"id":"3dt3zM","date":"1568176506","viewed":118,"name":"QuadTreeRayCasting","username":"JohnShadow","description":"This is a fast quad tree ray cast, \nit can be easily expanded to octrees if needed.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["quadtree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 inradius(vec2 x, vec3 col)\n{\n    float n = 5.0;//abs(sin(iTime*0.25)) * 8.0;\n    float inv = 1.0-pow(2.0,-n)*2.0;\n    x = x-vec2(1.0,1.0);\n    float st = sin(iTime)*inv;\n    if(dot(x, x) < st * st)\n        return col * vec3(0.3, 0.5, 0.7);\n    return col;\n}\nvec3 raycast(vec2 puv, vec2 pos, vec2 dir)\n{\n\tfloat clx = 0.0;\n\tvec2 aprox = vec2(0.0);\n    float n = 5.0;\n    float np = pow(2.0, n);\n\tfloat inp = pow(2.0, -n);\n    for(float i = 0.0; i < np; ++i)\n\t{\n\t\tvec2 aprox = ceil(pos + dir * 2.0 *  1.41421356237 * i) * inp;\n\t\tif(aprox.x == puv.x && aprox.y == puv.y)\n\t\t\tclx = 0.5;\n\t}\n\treturn vec3(clx, 0, 0);\n}\nvec3 octree(vec2 uv)\n{\n\tvec2 pos = vec2(0.0);\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    float n = 5.0;\n    for(float i = 0.0; i < n; ++i)\n    {\n        float power = pow(2.0, \t-i);\n\t\tif(sign(uv.x - (pos.x + power)) > 0.0)\n\t\t{\n\t\t\tpos.x += power;\n\t\t\tcol += vec3(0.5/n);\n\t\t}\n\t\tif(sign(uv.y - (pos.y + power)) > 0.0)\n\t\t{\n\t\t\tpos.y += power;\n\t\t\tcol += vec3(0.5/n);\n\t\t}\n    }\n    col += raycast(pos, vec2(0), vec2(0.707106781187, 0.707106781187));\n    return inradius(pos, col);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0) * 1.1;\n    uv += vec2(1.0, 1.0);\n\tvec3 col = octree(uv);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}