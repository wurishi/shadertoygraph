{"ver":"0.1","info":{"id":"cl33zH","date":"1681914535","viewed":62,"name":"My Basic Path Tracing","username":"grullier","description":"A basic path tracing scene","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(color, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415\n\nstruct Surface {\n    float distance;\n    vec4 colorEmitance;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Bounce {\n    Ray ray;\n    Surface surface;\n};\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nconst float c_twopi = 2.0f * PI;\n\nvec3 RandomUnitVector(inout uint state)\n{\n    float z = RandomFloat01(state) * 2.0f - 1.0f;\n    float a = RandomFloat01(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 randomSpherePoint(vec3 rand) {\n  float ang1 = (rand.x + 1.0) * PI; // [-1..1) -> [0..2*PI)\n  float u = rand.y; // [-1..1), cos and acos(2v-1) cancel each other out, so we arrive at [-1..1)\n  float u2 = u * u;\n  float sqrt1MinusU2 = sqrt(1.0 - u2);\n  float x = sqrt1MinusU2 * cos(ang1);\n  float y = sqrt1MinusU2 * sin(ang1);\n  float z = u;\n  return vec3(x, y, z);\n}\n\nvec3 randomHemispherePoint(vec3 rand, vec3 normal) {\n  vec3 v = randomSpherePoint(rand);\n  return v * sign(dot(v, normal));\n}\n\nSurface distanceToSphereSurface(vec3 position, vec3 sphereCenter, float sphereRadius, vec4 colorEmitance) {\n    float distanceToSurface = \n         sqrt(\n             pow((sphereCenter.x - position.x),2.0)+\n             pow((sphereCenter.y - position.y),2.0)+\n             pow((sphereCenter.z - position.z),2.0)\n         )-\n         sphereRadius;\n\n    return Surface(distanceToSurface, colorEmitance);\n}\n\nSurface distanceToPlaneSurface(vec3 position, vec3 origin, vec3 normal, vec4 colorEmitance) {\n    float d = \n        normal.x * origin.x+\n        normal.y * origin.y+\n        normal.z * origin.z;\n\n\n    float distanceToSurface = \n        abs( \n           normal.x * position.x+\n           normal.y * position.y+\n           normal.z * position.z+\n           d\n        )/\n        sqrt(\n            pow(normal.x, 2.0)+\n            pow(normal.y, 2.0)+\n            pow(normal.z, 2.0)\n        );\n\n\n    return Surface(distanceToSurface, colorEmitance);\n}\n\nSurface minSurface(Surface s1, Surface s2) {\n    if (min(s1.distance, s2.distance) == s1.distance) {\n        return s1;\n    } else {\n        return s2;\n    }\n}\n\nSurface map(vec3 position) {\n    Surface surface = Surface(10000.0, vec4(1.0)); // The default \n\n    surface = minSurface(surface, distanceToSphereSurface(position, vec3(0.0, 7.0, 0.0), 3.0, vec4(0.0,1.0,0.0,0.0)));\n    surface = minSurface(surface, distanceToSphereSurface(position, vec3(15.0, 7.0, 0.1), 5.0, vec4(1.0,0.0,0,1.0)));\n    \n    surface = minSurface(surface, distanceToPlaneSurface(position, vec3(0.0), vec3(0.0, 1.0, 0.0), vec4(0.0,0.0,0.0,1.0)));\n    surface = minSurface(surface, distanceToPlaneSurface(position, vec3(7.0,0,0), vec3(1.0, 0.0, 0.0), vec4(0.0,0.0,0.0,1.0)));\n    surface = minSurface(surface, distanceToPlaneSurface(position, vec3(0,0,7), vec3(0.0, 0.0, 1.0), vec4(0.0,0.0,0.0,1.0)));\n    return surface;\n}\n\n// A function to calculate the normal to the nearest surface of the map\nvec3 calculateNormal(vec3 position, float epsilon) {\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( \n        e.xyy*map(position + e.xyy*epsilon).distance + \n        e.yyx*map(position + e.yyx*epsilon).distance + \n        e.yxy*map(position + e.yxy*epsilon).distance + \n        e.xxx*map(position + e.xxx*epsilon).distance\n    );\n}\n\nvec4 tracePath(Ray ray, uint rngState) {\n\n    const int maxRaysCount = 5;\n    int hitCount = 0;\n    Bounce[maxRaysCount] bounces;\n    Ray currentRay = ray;\n\n    for(int i = 0; i < maxRaysCount; i++) {\n\n        // Find nearest object\n        float travelledDistance = 1.0; // Length of the first step\n        Surface surface = Surface(10000.0, vec4(1.0)); // The default\n        bool hit = false;\n        for( int i=0; i<128; i++)\n        {\n            // We make one marching step with the ray\n            vec3 rayPosition = currentRay.origin + currentRay.direction * travelledDistance;\n            surface = map(rayPosition);\n            // If we are close enough or missed totally to the surface we stop\n            if(surface.distance < 0.01) {\n                hit = true;\n                break;\n            }\n            // We redefine the step to the closest distance we found\n            travelledDistance += surface.distance;\n        }\n\n        if(!hit) { \n            break;\n        }\n        hitCount++;\n\n        // If we hit something we pick a new direction for a new ray\n        vec3 newRayOrigin = ray.origin + ray.direction * travelledDistance;\n        vec3 normalToSurface = calculateNormal(newRayOrigin, 0.1);\n        vec3 newRayDirection = randomHemispherePoint(RandomUnitVector(rngState), normalToSurface);\n        //vec3 newRayDirection = reflect(ray.direction, normalToSurface);\n        \n        \n        Ray newRay = Ray(newRayOrigin, newRayDirection);\n        \n        // We store the result of the bounce\n        bounces[i] = Bounce(newRay, surface);\n        \n        currentRay = newRay;\n    }\n\n    if(hitCount == 0) {\n        return vec4(0.0); // The void\n    }\n    \n    Bounce lastBounce = bounces[hitCount - 1];\n\n    vec3 normalToSurface = calculateNormal(lastBounce.ray.origin, 0.1);\n    float diffuseness = dot(lastBounce.ray.direction, normalToSurface);\n    vec4 incoming = lastBounce.surface.colorEmitance;\n    \n    for(int i = hitCount - 1; i >= 0; i--) {\n        Bounce bounce = bounces[i];\n        \n        // Compute the BRDF for this ray (assuming Lambertian reflection)\n        vec3 normalToSurface = calculateNormal(bounce.ray.origin, 0.1);\n        float diffuseness = dot(bounce.ray.direction, normalToSurface);\n\n        // Apply the Rendering Equation here.\n        incoming = incoming + bounce.surface.colorEmitance * diffuseness ;\n    }\n    \n    \n    return incoming;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord)/iResolution.y; \n    float aspectRatio = iResolution.y/iResolution.x;\n\n    // Camera\n    float cameraFieldOfView = 1.0; \n    vec3 cameraPosition = vec3(10.0);\n    vec3 cameraOrientation = normalize(vec3(-1.0));\n    \n    // Ray\n    vec3 rayDirection = normalize(\n        vec3(\n            cameraOrientation.x + uv.x * cameraFieldOfView,\n            cameraOrientation.y + uv.y * cameraFieldOfView,\n            cameraOrientation.z\n        )\n    );\n    \n    vec3 rayOrigin = vec3(cameraPosition.x + uv.x, cameraPosition.y + uv.y, cameraPosition.z);\n    \n\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    \n    int numberOfSamples = 5;\n    \n    for(int i = 0; i < numberOfSamples; i++) {\n        // We make some slight variation to the ray direction to make some antialiasing\n        vec3 adjustedDirection = vec3(\n            rayDirection.x + float(cos(float(i)))/1000.0,\n            rayDirection.y + float(sin(float(i)))/1000.0,\n            rayDirection.z - float(sin(float(i)))/1000.0\n        );\n        Ray ray = Ray(rayOrigin, adjustedDirection);\n        color += tracePath(ray, rngState);\n    }\n\n    // We average the color\n    color /= 0.8;\n\n    // average the frames together\n    vec4 lastFrameColor = texture(iChannel0, fragCoord / iResolution.xy);\n    color = mix(lastFrameColor, color, 0.01);\n\n    // show the result\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}