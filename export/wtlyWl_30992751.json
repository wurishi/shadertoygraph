{"ver":"0.1","info":{"id":"wtlyWl","date":"1594004869","viewed":751,"name":"💻 MS-DOS 💾 🤯","username":"rmmcal","description":"MS-DOS => \"MicroShader-DisguiseOperatingSystem\" :) 🍀 🎨 💽 💻 ⌨ 🎵🎶 \n🧙  tips: \"ESC\" key to exit programs....","likes":49,"published":1,"flags":56,"usePreview":0,"tags":["sound","simulation","font","keyboard","dos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////\n////            ....  💻 MS-DOS 💾  ....                ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)🧙🧞\n// - Started: 2020/07 - Published: 2020/07\n// - https://www.shadertoy.com/view/wtlyWl\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  MS-DOS => 🧠 => \"MicroShader-DisguiseOperatingSystem\" 😅\n//  \n//  👾 🤖 👽 👻 🙈🙉🙊 🙏\n//\n//  \n//  Time goes by so fast ... \n//  I'm + 👴 every day and there's still a lot to learn ... \n//\n//\tPass: #Tempo$ ⏳\n//  \n//      ... @rmmcal 2020/07 😷\n//\n//  Wiki: \n// \t=> https://en.wikipedia.org/wiki/MS-DOS\n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////\n////            ....  💻 MS-DOS 💾  ....                ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)🧙🧞\n// - Started: 2020/07 - Published: 2020/07\n// - https://www.shadertoy.com/view/wtlyWl\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  MS-DOS => 🧠 => \"MicroShader-DisguiseOperatingSystem\" 😅\n//  \n//  👾 🤖 👽 👻 🙈🙉🙊 🙏\n//\n//  \n//  Time goes by so fast ... \n//  I'm + 👴 every day and there's still a lot to learn ... \n//\n//\tPass: #Tempo$ ⏳\n//  \n//      ... @rmmcal 2020/07 😷\n//\n//  Wiki: \n// \t=> https://en.wikipedia.org/wiki/MS-DOS\n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n\n#ifndef SHADERTOY_COM\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#extension GL_OES_standard_derivatives : enable\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D backbuffer;\nuniform sampler2D keyboard;\n\n#define iTime time\n#define iChannel0 backbuffer\n#define iChannel1 0 \n#define iChannel2 0\n#define iChannel3 keyboard\n#define texelFetch(a,b,c) texture2D(a, (vec2(b)+vec2(.5))/resolution)\n#define KEYBOARD 0.\n#else \n#define resolution iResolution.xy\n#define time iTime\n#define KEYBOARD 1.\n#endif\n\n#define shiftr(a,b) a / int(pow(2.,float(b)))   \n\nint imax(int a, int b){\n    return a>b?a:b;\n}\nint modi(int a, int n){\n    return a - (n * int(a/n));\n}\nint p2(int x){\n    return int(pow(2.,float(x)));\n}\nint absi(int x){\n    return x < 0? -x : x; \n}\n\nint clampi(int x, int a, int b){\n    x = (x < a ? a : x);\n    x = (x > b ? b : x);\n    return x; \n}\n\nbool checkin(int x, int y, int w, int h){\n    return x>=0&&x<w && y>=0&&y<h; \n}\n\nconst int CHARS_LEN = 97;\nivec4 CHARS[CHARS_LEN];\n\nconst int TEXT_LEN = 32;\nivec4 TEXT[TEXT_LEN];\n\nvoid setup_text(){\n    TEXT[0] = ivec4( 0x251C3E20, 0X24515156, 0X4B504902, 0X4854514F);\n    TEXT[1] = ivec4( 0x022A4354, 0X4602264B, 0X554D1010, 0X10013556);\n    TEXT[2] = ivec4( 0x4354564B, 0X5049022F, 0X350F2631, 0X35101010);\n    TEXT[3] = ivec4( 0x012A2B2F, 0X272F024B, 0X55025647, 0X55564B50);\n    TEXT[4] = ivec4( 0x4902475A, 0X56475046, 0X4746024F, 0X474F5154);\n    TEXT[5] = ivec4( 0x5B101010, 0X02465150, 0X47100100, 0X24434602);\n    TEXT[6] = ivec4( 0x45514F4F, 0X43504602, 0X51540248, 0X4B4E4702);\n    TEXT[7] = ivec4( 0x50434F47, 0X01002B50, 0X58434E4B, 0X4602464B);\n    TEXT[8] = ivec4( 0x54474556, 0X51545B01, 0X00234545, 0X47555502);\n    TEXT[9] = ivec4( 0x4647504B, 0X47460100, 0X2E514346, 0X4B504910);\n    TEXT[10] = ivec4( 0x10100100, 0X4A565652, 0X551C1111, 0X59595910);\n    TEXT[11] = ivec4( 0x554A4346, 0X47545651, 0X5B104551, 0X4F11584B);\n    TEXT[12] = ivec4( 0x47591159, 0X564E5B39, 0X4E010002, 0X38514E57);\n    TEXT[13] = ivec4( 0x4F47024B, 0X50024654, 0X4B584702, 0X25024B55);\n    TEXT[14] = ivec4( 0x022F350F, 0X263135EF, 0X01023851, 0X4E574F47);\n    TEXT[15] = ivec4( 0x02354754, 0X4B434E30, 0X574F4447, 0X54024B55);\n    TEXT[16] = ivec4( 0x02131415, 0X160F1718, 0X191A0102, 0X264B5447);\n    TEXT[17] = ivec4( 0x45565154, 0X5B025148, 0X02251C3E, 0X0101382B);\n    TEXT[18] = ivec4( 0x34373510, 0X25312F02, 0X02020202, 0X1412160E);\n    TEXT[19] = ivec4( 0x15171402, 0X12190F12, 0X140F1412, 0X0213141C);\n    TEXT[20] = ivec4( 0x12124301, 0X352A2326, 0X27343631, 0X3B102531);\n    TEXT[21] = ivec4( 0x2F020202, 0X1B0E1913, 0X13021219, 0X0F12160F);\n    TEXT[22] = ivec4( 0x14120213, 0X141C1212, 0X43012423, 0X2E2E1025);\n    TEXT[23] = ivec4( 0x312F0202, 0X02020202, 0X0213130E, 0X19151402);\n    TEXT[24] = ivec4( 0x12190F12, 0X160F1412, 0X0213141C, 0X12124301);\n    TEXT[25] = ivec4( 0x292E352E, 0X1025312F, 0X02020202, 0X02020213);\n    TEXT[26] = ivec4( 0x120E1312, 0X12021219, 0X0F12160F, 0X14120213);\n    TEXT[27] = ivec4( 0x141C1212, 0X43010202, 0X02021602, 0X484B4E47);\n    TEXT[28] = ivec4( 0x0A550B02, 0X1415170E, 0X1A1B1702, 0X445B5647);\n    TEXT[29] = ivec4( 0x55010202, 0X02020202, 0X02020202, 0X02020202);\n    TEXT[30] = ivec4( 0x02020202, 0X1202445B, 0X56475502, 0X48544747);\n    TEXT[31] = ivec4( 0x01000000, 0X00000000, 0X00000000, 0X00000000);\n}\n\nvoid setup_font(){\n\n    CHARS[0] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00000000); //  0x1e 30\n    CHARS[1] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00000000); //  0x1f 31\n    CHARS[2] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00000000); //   0x20 32\n    CHARS[3] = ivec4(0x00000000, 0x00001818, 0x00181818, 0x3c3c3c18); // ! 0x21 33\n    CHARS[4] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00444466); // \" 0x22 34\n    CHARS[5] = ivec4(0x00000000, 0x00003636, 0x7f36367f, 0x36360000); // # 0x23 35\n    CHARS[6] = ivec4(0x00000000, 0x08083e6b, 0x6b381c0e, 0x6b6b3e08); // $ 0x24 36\n    CHARS[7] = ivec4(0x00000000, 0x00003049, 0x4b360c18, 0x36694906); // % 0x25 37\n    CHARS[8] = ivec4(0x00000000, 0x00006e33, 0x333b6e0c, 0x1c36361c); // & 0x26 38\n    CHARS[9] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00081018); // ' 0x27 39\n    CHARS[10] = ivec4(0x00000000, 0x00003018, 0x0c0c0c0c, 0x0c0c1830); // ( 0x28 40\n    CHARS[11] = ivec4(0x00000000, 0x00000c18, 0x30303030, 0x3030180c); // ) 0x29 41\n    CHARS[12] = ivec4(0x00000000, 0x00000000, 0x663cff3c, 0x66000000); // * 0x2a 42\n    CHARS[13] = ivec4(0x00000000, 0x00000000, 0x18187e18, 0x18000000); // + 0x2b 43\n    CHARS[14] = ivec4(0x00000000, 0x04080c0c, 0x00000000, 0x00000000); // , 0x2c 44\n    CHARS[15] = ivec4(0x00000000, 0x00000000, 0x00007f00, 0x00000000); // - 0x2d 45\n    CHARS[16] = ivec4(0x00000000, 0x00000c0c, 0x00000000, 0x00000000); // . 0x2e 46\n    CHARS[17] = ivec4(0x00000000, 0x00000001, 0x03060c18, 0x30604000); // / 0x2f 47\n    CHARS[18] = ivec4(0x00000000, 0x00003e63, 0x63676f7b, 0x7363633e); // 0 0x30 48\n    CHARS[19] = ivec4(0x00000000, 0x00007e18, 0x18181818, 0x181e1c18); // 1 0x31 49\n    CHARS[20] = ivec4(0x00000000, 0x00007f63, 0x03060c18, 0x3060633e); // 2 0x32 50\n    CHARS[21] = ivec4(0x00000000, 0x00003e63, 0x6060603c, 0x6060633e); // 3 0x33 51\n    CHARS[22] = ivec4(0x00000000, 0x00007830, 0x307f3333, 0x363c3830); // 4 0x34 52\n    CHARS[23] = ivec4(0x00000000, 0x00003e63, 0x6060603f, 0x0303037f); // 5 0x35 53\n    CHARS[24] = ivec4(0x00000000, 0x00003e63, 0x6363633f, 0x0303633e); // 6 0x36 54\n    CHARS[25] = ivec4(0x00000000, 0x00000c0c, 0x0c0c1830, 0x6060637f); // 7 0x37 55\n    CHARS[26] = ivec4(0x00000000, 0x00003e63, 0x6363633e, 0x6363633e); // 8 0x38 56\n    CHARS[27] = ivec4(0x00000000, 0x00003e63, 0x60607e63, 0x6363633e); // 9 0x39 57\n    CHARS[28] = ivec4(0x00000000, 0x00000018, 0x18000000, 0x18180000); // : 0x3a 58\n    CHARS[29] = ivec4(0x00000000, 0x00081018, 0x18000000, 0x18180000); // ; 0x3b 59\n    CHARS[30] = ivec4(0x00000000, 0x00006030, 0x180c060c, 0x18306000); // < 0x3c 60\n    CHARS[31] = ivec4(0x00000000, 0x00000000, 0x007e0000, 0x7e000000); // = 0x3d 61\n    CHARS[32] = ivec4(0x00000000, 0x0000060c, 0x18306030, 0x180c0600); // > 0x3e 62\n    CHARS[33] = ivec4(0x00000000, 0x00001818, 0x00181830, 0x6063633e); // ? 0x3f 63\n    CHARS[34] = ivec4(0x00000000, 0x00003c02, 0x6db5a5a5, 0xb9423c00); // @ 0x40 64\n    CHARS[35] = ivec4(0x00000000, 0x00006363, 0x63637f63, 0x6363361c); // A 0x41 65\n    CHARS[36] = ivec4(0x00000000, 0x00003f66, 0x6666663e, 0x6666663f); // B 0x42 66\n    CHARS[37] = ivec4(0x00000000, 0x00003e63, 0x63030303, 0x0363633e); // C 0x43 67\n    CHARS[38] = ivec4(0x00000000, 0x00003f66, 0x66666666, 0x6666663f); // D 0x44 68\n    CHARS[39] = ivec4(0x00000000, 0x00007f66, 0x46161e1e, 0x1646667f); // E 0x45 69\n    CHARS[40] = ivec4(0x00000000, 0x00000f06, 0x06161e1e, 0x1646667f); // F 0x46 70\n    CHARS[41] = ivec4(0x00000000, 0x00007e63, 0x63637303, 0x0363633e); // G 0x47 71\n    CHARS[42] = ivec4(0x00000000, 0x00006363, 0x6363637f, 0x63636363); // H 0x48 72\n    CHARS[43] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x1818183c); // I 0x49 73\n    CHARS[44] = ivec4(0x00000000, 0x00001e33, 0x33303030, 0x30303078); // J 0x4a 74\n    CHARS[45] = ivec4(0x00000000, 0x00006766, 0x66361e1e, 0x36666667); // K 0x4b 75\n    CHARS[46] = ivec4(0x00000000, 0x00007f66, 0x46060606, 0x0606060f); // L 0x4c 76\n    CHARS[47] = ivec4(0x00000000, 0x00006363, 0x63636b7f, 0x7f776341); // M 0x4d 77\n    CHARS[48] = ivec4(0x00000000, 0x00006363, 0x63737b7f, 0x6f676361); // N 0x4e 78\n    CHARS[49] = ivec4(0x00000000, 0x00003e63, 0x63636363, 0x6363633e); // O 0x4f 79\n    CHARS[50] = ivec4(0x00000000, 0x00000f06, 0x06063e66, 0x6666663f); // P 0x50 80\n    CHARS[51] = ivec4(0x00000000, 0x00603e7b, 0x6b636363, 0x6363633e); // Q 0x51 81\n    CHARS[52] = ivec4(0x00000000, 0x00006766, 0x66363e66, 0x6666663f); // R 0x52 82\n    CHARS[53] = ivec4(0x00000000, 0x00003e63, 0x6360301c, 0x0663633e); // S 0x53 83\n    CHARS[54] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x185a7e7e); // T 0x54 84\n    CHARS[55] = ivec4(0x00000000, 0x00003e63, 0x63636363, 0x63636363); // U 0x55 85\n    CHARS[56] = ivec4(0x00000000, 0x0000081c, 0x36636363, 0x63636363); // V 0x56 86\n    CHARS[57] = ivec4(0x00000000, 0x00004163, 0x777f6b63, 0x63636363); // W 0x57 87\n    CHARS[58] = ivec4(0x00000000, 0x00006363, 0x363e1c1c, 0x3e366363); // X 0x58 88\n    CHARS[59] = ivec4(0x00000000, 0x00003c18, 0x1818183c, 0x66666666); // Y 0x59 89\n    CHARS[60] = ivec4(0x00000000, 0x00007f63, 0x43060c18, 0x3061637f); // Z 0x5a 90\n    CHARS[61] = ivec4(0x00000000, 0x00003c0c, 0x0c0c0c0c, 0x0c0c0c3c); // [ 0x5b 91\n    CHARS[62] = ivec4(0x00000000, 0x00000040, 0x6030180c, 0x06030100); // \\ 0x5c 92\n    CHARS[63] = ivec4(0x00000000, 0x00003c30, 0x30303030, 0x3030303c); // ] 0x5d 93\n    CHARS[64] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x63361c08); // ^ 0x5e 94\n    CHARS[65] = ivec4(0x00000000, 0x00ff0000, 0x00000000, 0x00000000); // _ 0x5f 95\n    CHARS[66] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00100818); // ` 0x60 96\n    CHARS[67] = ivec4(0x00000000, 0x00006e33, 0x33333e30, 0x1e000000); // a 0x61 97\n    CHARS[68] = ivec4(0x00000000, 0x00003e66, 0x66666666, 0x3e060607); // b 0x62 98\n    CHARS[69] = ivec4(0x00000000, 0x00003e63, 0x03030363, 0x3e000000); // c 0x63 99\n    CHARS[70] = ivec4(0x00000000, 0x00006e33, 0x33333333, 0x3e303038); // d 0x64 100\n    CHARS[71] = ivec4(0x00000000, 0x00003e63, 0x037f6363, 0x3e000000); // e 0x65 101\n    CHARS[72] = ivec4(0x00000000, 0x00001e0c, 0x0c0c0c0c, 0x3e0c6c38); // f 0x66 102\n    CHARS[73] = ivec4(0x0000001e, 0x33303e33, 0x33333333, 0x6e000000); // g 0x67 103\n    CHARS[74] = ivec4(0x00000000, 0x00006766, 0x6666666e, 0x36060607); // h 0x68 104\n    CHARS[75] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x1c001818); // i 0x69 105\n    CHARS[76] = ivec4(0x0000001e, 0x33333030, 0x30303030, 0x38003030); // j 0x6a 106\n    CHARS[77] = ivec4(0x00000000, 0x00006766, 0x361e1e36, 0x66060607); // k 0x6b 107\n    CHARS[78] = ivec4(0x00000000, 0x00003c18, 0x18181818, 0x1818181c); // l 0x6c 108\n    CHARS[79] = ivec4(0x00000000, 0x0000636b, 0x6b6b6b7f, 0x37000000); // m 0x6d 109\n    CHARS[80] = ivec4(0x00000000, 0x00006666, 0x66666666, 0x3b000000); // n 0x6e 110\n    CHARS[81] = ivec4(0x00000000, 0x00003e63, 0x63636363, 0x3e000000); // o 0x6f 111\n    CHARS[82] = ivec4(0x0000000f, 0x06063e66, 0x66666666, 0x3b000000); // p 0x70 112\n    CHARS[83] = ivec4(0x00000078, 0x30303e33, 0x33333333, 0x3e000000); // q 0x71 113\n    CHARS[84] = ivec4(0x00000000, 0x00000f06, 0x0606066e, 0x7b000000); // r 0x72 114\n    CHARS[85] = ivec4(0x00000000, 0x00003e63, 0x301c0663, 0x3e000000); // s 0x73 115\n    CHARS[86] = ivec4(0x00000000, 0x0000182c, 0x0c0c0c0c, 0x3f0c0c08); // t 0x74 116\n    CHARS[87] = ivec4(0x00000000, 0x00006e33, 0x33333333, 0x33000000); // u 0x75 117\n    CHARS[88] = ivec4(0x00000000, 0x0000081c, 0x36636363, 0x63000000); // v 0x76 118\n    CHARS[89] = ivec4(0x00000000, 0x0000367f, 0x6b6b6b6b, 0x63000000); // w 0x77 119\n    CHARS[90] = ivec4(0x00000000, 0x00006363, 0x361c3663, 0x63000000); // x 0x78 120\n    CHARS[91] = ivec4(0x0000001f, 0x30607e63, 0x63636363, 0x63000000); // y 0x79 121\n    CHARS[92] = ivec4(0x00000000, 0x00007f43, 0x060c1831, 0x7f000000); // z 0x7a 122\n    CHARS[93] = ivec4(0x00000000, 0x00007018, 0x1818180e, 0x18181870); // { 0x7b 123\n    CHARS[94] = ivec4(0x00000000, 0x00001818, 0x18180000, 0x18181818); // | 0x7c 124\n    CHARS[95] = ivec4(0x00000000, 0x00000e18, 0x18181870, 0x1818180e); // } 0x7d 125\n    CHARS[96] = ivec4(0x00000000, 0x00000000, 0x00000000, 0x00003b6e); // ~ 0x7e 126\n}\n\n#define START_CH 30\n\n#define A 65-START_CH\n#define B 66-START_CH\n#define C 67-START_CH\n#define D 68-START_CH\n#define E 69-START_CH\n#define F 70-START_CH\n#define G 71-START_CH\n#define H 72-START_CH\n#define I 73-START_CH\n#define J 74-START_CH\n#define K 75-START_CH\n#define L 76-START_CH\n#define M 77-START_CH\n#define N 78-START_CH\n#define O 79-START_CH\n#define P 80-START_CH\n#define Q 81-START_CH\n#define R 82-START_CH\n#define S 83-START_CH\n#define T 84-START_CH\n#define U 85-START_CH\n#define V 86-START_CH\n#define W 87-START_CH\n#define X 88-START_CH\n#define Y 89-START_CH\n#define Z 90-START_CH\n\nfloat ch(ivec2 p, int ch) {\n    float c = 0.;\n    if (checkin(p.x,p.y,8,32)) {\n        for (int i = 0; i < CHARS_LEN; i += 1) {\n            if (i == ch)\n                for (int yi = 0; yi < 24; yi += 1) {\n                    if (-p.y+12 == yi){\n                        c += float(modi((CHARS[i][3 - yi / 4] /p2 (modi(yi , 4) * 8) /p2( modi(absi(p.x),8))),2))/1.;\n                    }\n                }\n        }\n    }\n    return c;\n}\n\n#define keyDown(ascii)    ( (texelFetch(iChannel3,ivec2(ascii,1),0).x * KEYBOARD) > 0.)\n#define setCursor(cursor) locScreen = loc(cursor.xy)\n#define getCharCursor() ivec4(texelFetch(iChannel0, locScreen,0)*255.)\n#define writeChOnCursor() if (ip == locScreen) fragColor = vec4(tch)/255.\n\nconst int total = 7;\nconst int len = total;\nvec4 m[len];\n\n#define DRIVE     ivec4(0 ,   4, 0, 0) \n#define FAIL      ivec4(92, 118, 0, 0) \n#define START     ivec4(4 ,  92, 0, 0) \n#define DIR       ivec4(204, 242, 0, 1) \n#define CLS       ivec4(0 ,   4, 0, 0) \n#define CD_NEG    ivec4(137, 190, 0, 1) \n#define CD        ivec4(118, 62, 0, 1) \n#define LOADING   ivec4(152, 190, 0, 1) \n#define SHADERTOY ivec4(164, 190, 0, 1) \n#define BALL      ivec4(152, 190, 0, 1) \n\n#define getInt(a)  a.y * 256 + a.x;  \n#define loadInt(a) a = ivec4(a.y * 256 + a.x, 0, 0, 0)\n#define saveInt(a) a = ivec4(modi(a.x,256),a.x/256, 0, 0)  \n\n#define ROWS 80\n#define LINES 18\n\n#define loc(sp) ivec2(modi(sp.x+sp.y*ROWS+1, ROWS),1 + imax(0, (sp.x+sp.y*ROWS) / ROWS))\n#define print(t) print_mem_start.x = getInt(t.xz); print_mem_end.x = getInt(t.yw); print_mem_stack.x = print_mem_prog.x\n#define printTo(t,to) print_mem_start.x = getInt(t.xz); print_mem_end.x = getInt(t.yw); print_mem_stack.x = to\n#define delaySec(a) print_mem_time.x = int(iTime+a)\n#define MAX_PRINT_SPEED 100\n#define PRINT_SPEED 0\n\n#define ESC     27\n#define RIGTH   39\n#define LEFT    37\n#define UP      40\n#define DOWN    38\n#define ENTER   13\n\nint getTextChAt(int at){\n    ivec4 vt = ivec4(0);  \n    int s1 = 0;\n    int s2 = 0;\n\n    for (int i = 0; i < TEXT_LEN; i++)   {\n        if (( at / 16) == i) {\n            vt = (TEXT[i]);\n            break;\n        }\n    }\n\n    int b = modi(at/4,4);\n    for (int i = 0; i < 4; i++) {\n        if ( i == b) {\n            s1 = vt[i]; \n            break;\n        } \n    }\n    return modi(shiftr(s1, 24-modi(at, 4)*8),256);\n\n}\n\nint getKeyChar(){\n    int key = -1;\n    for (int i=0; i<256; i++) {\n        if (keyDown(i) && i >= START_CH && i<=122) {\n            key = (i-START_CH); \n            break;\n        }\n    }\n    return key;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    ivec2 ir = ivec2(resolution); \n    ivec2 ip = ivec2(fragCoord.xy);\n    vec2 fp = vec2(ip);\n    vec2 fr = vec2(ir);\n    vec2 uv = fp/fr;\n    int row = ir.x/8;\n\n    // load memory //\n    for (int i = 0 ; i < len; i++) \n        m[i] = texelFetch(iChannel0, ivec2(i,0),0)*255.;\n\n    ivec2 spg = ivec2(ip.x/8-1,ir.y/16-ip.y/16-1);// screen point\n    ivec2 locScreen = loc(spg);\n    ivec4 cursor = ivec4(m[0]);\n    ivec4 print_mem_start = ivec4(m[1]);\n    ivec4 print_mem_end   = ivec4(m[2]);\n    ivec4 print_mem_stack = ivec4(m[3]);\n    ivec4 print_mem_int   = ivec4(m[4]);\n    ivec4 print_mem_time  = ivec4(m[5]);\n    ivec4 print_mem_prog  = ivec4(m[6]);    \n\n\n    loadInt(print_mem_start);\n    loadInt(print_mem_end);\n    loadInt(print_mem_stack);\n    loadInt(print_mem_int);\n    loadInt(print_mem_time);\n    loadInt(print_mem_prog);\n\n    ivec4 tch = getCharCursor(); \n    ivec4 sch = getCharCursor(); \n    if (locScreen.y==0)\n        tch *= 0;\n\n    if (ip.y<LINES+2)\n    {\n        setup_text();\n\n        fragColor = texelFetch(iChannel0, ip, 0); // mem last state\n\n        ivec2 sp = cursor.xy;\n        setCursor(cursor.xy);\n        tch = getCharCursor(); \n\n        if (print_mem_time.x <= int(iTime))\n        {\n            if (cursor.y > LINES){\n                // scroll lines\n                cursor.y -= 1;\n                int t = (ip.x+ip.y*80) / (ir.x);\n                fragColor = texelFetch(iChannel0, ip+ivec2(0,1), 0);\n            } \n            else if ((print_mem_start.x) < (print_mem_end.x) ) {\n\n                for (int i = 0; i < MAX_PRINT_SPEED; i++) { \n                    \n                    if (i > cursor.z + PRINT_SPEED) // cursor.z => max char for frame \n                        break;\n                    \n                    if ( (print_mem_start.x) < (print_mem_end.x) ) {\n                        \n                        // print text\n                        tch.x = getTextChAt(print_mem_start.x);\n                        setCursor(cursor.xy);\n                        cursor.x += 1; \n                        print_mem_start.x += 1;\n\n                        if (tch.x == 1) {\n                            // \\n\n                            cursor.x = 0;\n                            cursor.y += 1;                          \n                        }\n                        if (tch.x == 0)\n                        {\n                            // end string\n                            print_mem_start.x = print_mem_end.x;                \n                            print_mem_prog.x = print_mem_stack.x;\n                            cursor.y += 1;\n                            cursor.x = print_mem_stack.x > 0 ? cursor.x : 0;\n                            break;\n                        }\n\n                        if (cursor.y > LINES)\n                            break;\n\n                        writeChOnCursor();\n                    }\n                }\n            }\n            else\n            {\n                if (cursor == ivec4(0.0) ){\n                    // start program\n                    if (KEYBOARD==0.){\n                        printTo(START,30);\n                    }\n                    else{\n                        printTo(START, 0);\n                    }\n\n                }\n                else if (sp.x == 0){\n                    // if sp (screen position <=> terminal cursor) == 0 then print drive\n                    print(DRIVE);\n                }\n\n                if (keyDown(ESC) && print_mem_prog.x > 0){\n                    // if ESC back terminal and clean screen\n                    print_mem_prog.x = 0;\n                    fragColor *= 0.;\n                    cursor.x = 0; \n                    cursor.y = 1; \n                }\n                else if (keyDown(LEFT)){\n                    cursor.x -= 1; \n                }\n                else if (keyDown(RIGTH)){\n                    cursor.x += 1; \n                }\n                else if (keyDown(UP)){\n                    //cursor.y += 1; \n                }\n                else if (keyDown(DOWN)){\n                    //cursor.y -= 1; \n                }\n                else if (keyDown(ENTER))\n                {\n\n                    ivec4 inputCh;\n                    ivec4 inputCh2;\n                    ivec4 ocursor = cursor;\n                    for (int i = 0; i < 4; i++) {\n                        ivec2 p1 = cursor.xy-ivec2(i+1,0);\n                        setCursor(p1);\n                        inputCh[3-i] = getCharCursor().x ;\n                        p1 = ivec2(i+4,cursor.y);\n                        setCursor(p1);\n                        inputCh2[i] = getCharCursor().x ;\n                    }\n                    setCursor(ocursor.xy);\n\n                    if (inputCh.yzw == ivec3(D,I,R) || inputCh2.xyz == ivec3(D,I,R))\n                    {\n                        cursor.x = 1; \n                        cursor.y += 1; \n                        print(DIR);\n                    }\n                    else if (inputCh2.xy == ivec2(C,D))\n                    {\n                        cursor.x = 0; \n                        cursor.y += 1; \n                        print(CD);\n                    }\n                    else if (inputCh2.xy == ivec2(M,D)  || inputCh2.xyz ==  ivec3(D,E,L) || inputCh2.xyzw == ivec4(A,T,T,R))\n                    {\n                        cursor.x = 0; \n                        cursor.y += 1; \n                        print(CD_NEG);\n                    }\n                    else if (inputCh.yzw == ivec3(C,L,S))\n                    {\n                        fragColor *= 0.;\n                        cursor.x = 0; \n                        cursor.y = 1; \n                    }\n                    else  if (inputCh.xyzw == ivec4(I,R,U,S))\n                    {\n                        cursor.x = 0; \n                        cursor.y = LINES; \n                        printTo(LOADING,2);\n                    }\n                    else  if (inputCh2.xyzw == ivec4(B,A,L,L))\n                    {\n                        cursor.x = 0; \n                        cursor.y += 1; \n                        printTo(BALL,10);\n                    }\n                    else  if (inputCh2.xyzw == ivec4(S,H,A,D))\n                    {\n                        cursor.x = 1; \n                        cursor.y += 1; \n                        printTo(SHADERTOY,20);\n                    }\n                    else  if (inputCh2.xyzw == ivec4(R,O,D,R))\n                    {\n                        cursor.x = 1; \n                        cursor.y += 1; \n                        printTo(SHADERTOY,50);\n                    }\n                    else  if (inputCh2.xyzw == ivec4(G,L,S,L))\n                    {\n                        cursor.x = 1; \n                        cursor.y += 1; \n                        printTo(LOADING,32);\n                    }\n                    else if (inputCh2.x != 0 || inputCh2.y != 0 || inputCh2.z != 0)\n                    {\n                        cursor.x = 0; \n                        cursor.y += 1; \n                        print(FAIL);\n                    }\n                    else\n                    {\n                        cursor.x = 0; \n                        cursor.y += 1; \n                    }\n\n                }\n                else if (keyDown(32))\n                {\n                    cursor.x += 1; \n                }\n                else if (keyDown(8) && sp.x > 4)\n                {\n                    cursor.x -= 1; \n                    setCursor(cursor.xy);\n                    tch.x = (0); \n                }\n                else\n                {\n                    int ch = getKeyChar();\n                    if (ch>0){\n                        tch.x = ch; \n                        cursor.x += 1;\n                    }\n                }\n\n                vec2 fv = vec2(float(modi(int(ip.x),90)+13), float(modi(int(ip.y),80)+18))*vec2(1.,2.)-vec2(52. ,55.);\n                float t = fract(time*.1)*320.;\n                if (print_mem_prog.x == 1)\n                {\n                    int cov  = int((fract(0.7325*iTime*0.01)*2.+1.)*(fp.x*fp.y+fp.x+fp.y));\n                    fragColor.xyz = vec3(float(modi(cov,50))/255.);\n                }\n                else if (print_mem_prog.x == 2)\n                {\n                    delaySec(1.0);\n                    tch.x = tch.x == (45-START_CH) ? (124-START_CH ) : (45-START_CH); \n                        if (time>=19.5)\n                        {\n                            printTo(LOADING, 1);\n                        }\n                }\n                else if (print_mem_prog.x == 10)\n                {\n                    delaySec(3.0);\n                    printTo(LOADING, 11);\n                }\n                else if (print_mem_prog.x == 20)\n                {\n                    delaySec(1.0);\n                    print_mem_prog.x = 0;\n                    cursor.x = 0; \n                }\n                else if (print_mem_prog.x == 30)\n                {\n                    printTo(SHADERTOY, 31);\n                }  \n                else if (print_mem_prog.x == 31)\n                {\n                    printTo(DIR, 0);\n                }\n                else if (print_mem_prog.x == 32)\n                {\n                    fragColor.xyz = (vec3(clamp((t-length(fv))/700.,0.,1.))) ;\n                }  \n                else if (print_mem_prog.x == 50)\n                {\n                    ivec3 tOut = ivec3(C,A,L);\n                    for (int i = 0; i < 3; i++)\n                        if (ivec2(fv)==ivec2(0+i,1))\n                            fragColor.xyz = vec3(float(tOut[i]+1)/256.) ;\n                        }\n            }\n        }\n\n        saveInt(print_mem_start);\n        saveInt(print_mem_end);\n        saveInt(print_mem_stack);\n        saveInt(print_mem_int);\n        saveInt(print_mem_time);\n        saveInt(print_mem_prog);\n\n        m[0] = vec4 ( cursor );\n        m[1] = vec4 ( print_mem_start );\n        m[2] = vec4 ( print_mem_end );\n        m[3] = vec4 ( print_mem_stack );\n        m[4] = vec4 ( print_mem_int );\n        m[5] = vec4 ( print_mem_time );\n        m[6] = vec4 ( print_mem_prog );\n\n        for (int i = 0 ; i < len; i++) {\n            if (ip == ivec2(i,0)){\n                fragColor =\tm[i]/255.; \n            }\n        }\n\n\n        writeChOnCursor();\n\n        fragColor.a = 1.; \n        return;\n    }\n\n    setup_font();\n\n    vec3 cor = vec3 (0.);\n    float color = 1.0;\n    float c = 0.;\n\n    float t = iTime;\n    float td = abs(fract(t*.2)*2.-1.);\n    td*=td;\n    td*=td;\n    if (print_mem_prog.x == 1)\n        ip.x += int(cos(fp.y/20.+iTime*15.)*2.*td);\n\n\n    if (modi(int(time*4.),2)==0)\n        c += ch(ip-cursor.xy*ivec2(8,-16)-ivec2(8,ir.y-25),95-START_CH);\n\n    if (tch.x!=0 && spg.y>=0 && spg.x<80 && spg.y<=LINES){\n        ivec2 it = ip;         \n        c += ch(ivec2(modi(it.x,8),modi(it.y+int(0.),16)),tch.x);       \n\n\n        if (print_mem_prog.x == 1)\n        {\n\n            float cm = 0.;\n            ivec2 it = (ivec2(ip.x,ip.y-ir.y+10))/16-ivec2(1,-17)-ivec2(+40-modi(int(iTime*10.),100),0);\n            int i = 0;\n            #define _(v)  cm += ch(ivec2(it-ivec2(i++*8,0)),v);\n            _(C)_(O)_(V)_(I)_(D)_(19)_(27)\n                c *= 1.-min(.4,cm);\n\n            if (c <= 0.1)\n                c = abs(cos(fp.y*2.))*.1;\n            else\n                c -= abs(cos(fp.y*2.))*.5;\n\n        }\n\n    }\n    cor+=c*.8;\n    vec2 pp = vec2(ivec2(fp)/4)*4. ;\n    float tf = float(int(iTime*20.))/60.;\n    vec2 pb =  vec2(abs(fract(tf*.1375)*2.-1.),abs(fract(tf*0.8)*2.-1.))*vec2(640.,360.)   ;\n    pb =  vec2(pb.x, fr.y - pb.y);\n    vec2 pfb = pp-pb;\n\n    if (print_mem_prog.x == 11)\n    {\n        cor = (0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)))*.2;\n        cor += vec3(clamp(sin(max(0.,50.0-(length(pfb)))/5.), 0., 1.));\n        cor += vec3(ivec3(cor*16.))/16. ;\n    }\n    if (print_mem_prog.x == 50)\n    {\n        vec3 b;\n        b += vec3(clamp(sin(max(0.,50.0-(length(pfb)))/5.), 0., 1.));\n        b += vec3(ivec3(b*16.))/16. ;\n        if (b.x > .0)\n        {\n            cor += b;\n        }\n    }\n\n    fragColor = vec4( vec3( cor ), 1.0 );\n\n}\n\n#ifndef SHADERTOY_COM\n/**/\nvoid main( void ) {\n    vec4 color;\n    mainImage(color, gl_FragCoord.xy );\n    gl_FragColor = color;\n\n}\n#endif\n/**/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////////////////////////////////\n////            ....  💻 MS-DOS 💾  ....                ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)🧙🧞\n// - Started: 2020/07 - Published: 2020/07\n// - https://www.shadertoy.com/view/wtlyWl\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  MS-DOS => 🧠 => \"MicroShader-DisguiseOperatingSystem\" 😅\n//  \n//  👾 🤖 👽 👻 🙈🙉🙊 🙏\n//\n//  \n//  Time goes by so fast ... \n//  I'm + 👴 every day and there's still a lot to learn ... \n//\n//\tPass: #Tempo$ ⏳\n//  \n//      ... @rmmcal 2020/07 😷\n//\n//  Wiki: \n// \t=> https://en.wikipedia.org/wiki/MS-DOS\n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n\nint modi(int a, int n){\n    return a - (n * int(a/n));\n}\n\nvec2 mainSound( in int samp, float time )\n{\n\n    float fb = 71.;\n    float f2 = 435.711;\n    vec2 s ;\n    // time += 30.;\n    //HD\n\n    bool b = modi(int(time*fb),2)==0;\n    if (b)\n    {\n        if ( time<20. )\n            for (float i = 0.; i < 50.; i++)\n            {\n                if (b && modi(int(time*7.), int(fract(.235711*(time*10.+5.))*10.))==0 && (time) >=0. )\n                {\n                    float fr = (fract(.435711*time)*1.-1.1*fract(.935711*time)); // 2.83\n                    fr = 2.83;\n                    s += vec2( pow(fract(fr*f2*time), i*5.) );\n                }\n            }\n    }\n    \n    // Siren\n    time-=20.;\n    if ( time>0. )\n    {\n        for (float i = 0.; i < 50.; i++)\n        {\n            {\n                float fr = fract(.235711*time)*1.*1.83; // 2.83\n                s += vec2( pow(fract(fr*f2*time), i*5.) );\n            }\n        }\n        s *=.1;\n    }\n    \n    if (b)\n    {\n        // Music\n        /**/\n        time-=10.;\n        if ( int(time*7.)%4==0 && (time) >=0. )\n        {\n            s += vec2( pow(fract(2.83*f2*time),10.) );\n        }\n        if (int(time*7.)%3==0 && (time) >=5. )\n        {\n            s += vec2( pow(fract(0.31*f2*time),10.) );\n        }\n        if (int(time*7.)%2==0 && (time) >=16. )\n        {\n            s += vec2( pow(fract(1.00*f2*time),10.) );\n        }\n        if ( int(time*7.)%7==0 && (time) >=20. )\n        {\n            s += vec2( pow(fract(1.91*f2*time),10.) );\n        }\n        if ( int(time*7.)%11==0 && (time) >=30. )\n        {\n            s += vec2( pow(fract(1.22*f2*time),10.) );\n        }\n        if ( int(time*3.)%13==0 && (time) >=40. )\n        {\n            s += vec2( pow(fract(2.14*f2*time),10.) );\n        }\n        if ( int(time*2.)%17==0 && (time) >=50. )\n        {\n            s += vec2( pow(fract(3.52*f2*time),10.) );\n        } \n        if ( int(time*1.)%19==0 && (time) >=60. )\n        {\n            s += vec2( pow(fract(3.06*f2*time),10.) );\n        }\n        if ( (time) >= 70. && (time) <= 75. )\n        {\n            s = vec2( (fract(2.06*f2*pow(time/2.,(70.-time*1.)/2.)) ) );\n        }\n        if ( (time) >= 75. && (time) <= 80. )\n        {\n            s = vec2( pow(fract(3.06*f2*(70./time)),10.) );\n        }\n      \n        /**/\n    } \n    \n    if ((time) >= 80. )\n    {\n        s = vec2( 0. );\n    }\n    return s*.05;\n}","name":"Sound","description":"","type":"sound"},{"inputs":[],"outputs":[],"code":"#define SHADERTOY_COM","name":"Common","description":"","type":"common"}]}