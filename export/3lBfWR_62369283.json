{"ver":"0.1","info":{"id":"3lBfWR","date":"1599246916","viewed":235,"name":"Simple Volume","username":"treize","description":"SimpleCloud","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","noise","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\n#define ITERATION_NUM 50\nfloat scene(vec3 p)\n{\t\n\treturn .1-length(p)*.04+fbm_4(p*.3);\n}\nmat3 SetCamera(in vec3 origin, in vec3 target, float rotation)\n{\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec3 org =vec3(0.0,0.0,20.0);\n\tvec3 ta = vec3(0.0);\n    float rotate=0.0;\n    float screen_z=1.5;\n    mat3 camera = SetCamera(org,ta,rotate);\n    vec3 dir= camera * normalize(vec3(p, screen_z));\n\n\tvec4 color=vec4(0.0);\n\tfloat zMax         = 40.;\n\tfloat step         = zMax/float(ITERATION_NUM);\n\tfloat zMaxl         = 20.;\n    vec3 pp             = org;\n    float T            = 1.;\n    float absorption   = 100.;\n\n\tfor(int i=0; i<ITERATION_NUM; i++)\n\t{\n\t\tfloat density = scene(pp);\n\t\tif(density>0.)\n\t\t{\n\t\t\tfloat tmp = density / float(ITERATION_NUM);\n\t\t\tT *= 1. -tmp * absorption;\n\t\t\tif( T <= 0.01)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcolor += vec4(1.)*50.*tmp*T +  vec4(1.0,0.7,0.4,1.0)*90.0*tmp*T;\n\t\t}\n\t\tpp += dir*step;\n\t}    \n    fragColor  = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"void hash11(float p, out float Out)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    Out = fract(p);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float n = p.x + 317.0*p.y + 157.0*p.z;\n    \n    float a;\n    hash11(n+0.0,a);\n    float b; hash11(n+1.0,b);\n    float c; hash11(n+317.0,c);\n    float d; hash11(n+318.0,d);\n    float e; hash11(n+157.0,e);\n\tfloat f; hash11(n+158.0,f);\n    float g; hash11(n+474.0,g);\n    float h; hash11(n+475.0,h);\n\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z);\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\n\nfloat fbm_4( in vec3 x )\n{\n    float f = 2.0;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for( int i=0; i<4; i++ )\n    {\n        float n = noise(x);\n        a += b*n;\n        b *= s;\n        x = f*m3*x;\n    }\n\treturn a;\n}\n","name":"Common","description":"","type":"common"}]}