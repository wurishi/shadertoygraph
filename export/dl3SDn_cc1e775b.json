{"ver":"0.1","info":{"id":"dl3SDn","date":"1685253105","viewed":130,"name":"Electric Field 3D_","username":"Fuergu","description":"This is just a Electromagnetic Field  class problem . I'm not a professional programmer.  I know using 4 buffer is silly. I‘m not using Matlab cause it’s slow.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["electricfield3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*Change mode and parameters in Common*/\n\nvec4 gradient_background2( vec2 uv )\n{\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    return vec4(col,1.0);\n}\n\n\n\nvec4 gradient_background1(vec2 uv ) {\n  vec2 p00 = -1.0 + 2.0*uv;\n  // Compute a simple gradient\n  vec3 col = vec3(.3, uv).zxy;\n  // Reduce intensity of gradient more to the corners\n  col *= 0.71*smoothstep(1.75, 0., length(p00));\n  return vec4(col,.5);\n}\n\nfloat calculateLuminance(vec3 color) {\n    vec3 weights = vec3(0.2126, 0.7152, 0.0722);\n    float luminance = dot(color, weights);\n    float maxLuminance = max(max(color.r, color.g), color.b);\n    return luminance / maxLuminance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 background1=gradient_background1(uv);\n    vec4 background2=gradient_background2(uv);\n    vec4 background=background1*background2;\n    background.r*=.3;background.g*=.7;background.b*=.8;\n    \n    vec4 teccol1 = texture(iChannel0, uv);\n    vec4 col1= vec4(teccol1.rgb, calculateLuminance(teccol1.rgb));\n    \n    vec4 teccol2 = texture(iChannel1, uv);\n    vec4 col2= vec4(teccol2.rgb, calculateLuminance(teccol2.rgb));\n    \n    vec4 teccol3 = texture(iChannel2, uv);\n    vec4 col3= vec4(teccol3.rgb, calculateLuminance(teccol3.rgb));\n    // Output to screen\n    fragColor = background+(col1+col2+col3)*1.3;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float phi(vec2 p,vec2 q,vec2 q1,vec2 q2){\n\treturn q.x/length(q1-p)+q.y/length(q2-p);\n}\n#define e(q) (p - q) / pow( dot(q - p, q - p), 1.5 )\n//// Electric field (Coulomb's law)\nvec2 E(vec2 p,vec2 q,vec2 q1,vec2 q2)\n    {\n\treturn normalize(q.x * e(q1) + q.y * e(q2));\n    }\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    p -= a, b -= a;\n    //return smoothstep(2./iResolution.y,.0,length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) )); \n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) ); \n\n}\n\nvec2 RK4(vec2 p,vec2 q,vec2 q1,vec2 q2){\n    vec2 k1 = E(p,q,q1,q2);\n    vec2 k2 = E(p+0.5*h*k1,q,q1,q2);\n    vec2 k3 = E(p+0.5*h*k2,q,q1,q2);\n    vec2 k4 = E(p+h*k3,q,q1,q2);\n    return h/3.*(0.5*k1+k2+k3+0.5*k4);\n}\n\n\nbool integrate(inout float d,vec2 p,vec2 q,vec2 q1,vec2 q2,vec2 start,vec2 end){\n    d = min(d, line(p,mix(q1,q2,float(length(q1-start)>h*1.001)),start));\n    vec2 pn;\n    vec2 po = start;\n    for(int i = 0;i<MAX_STEPS;i++){\n    \tpn = po+RK4(po,q,q1,q2);\n        d = min(d,line(p,po,pn));\n        po=pn;\n        if(length(end-po)<h){\n            d = min(d,line(p,po,end));\n            return false;\n        }\n        if(abs(po.x)>iResolution.x/iResolution.y||abs(po.y)>1.0)return true;\n    }\n    return true;\n}\n\nvoid mainImage( out vec4 O, in vec2 C )\n{\n    vec2 uv = (2.*C-iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    mouse.x = clamp(mouse.x, -PositionLimit, PositionLimit);\n\n    vec2 q1 = vec2(-.5,0);\n    vec2 q2 = vec2(mouse.x,0);\n    vec2 q =vec2(0.);\n    if(mode==0) \n    {\n    q = vec2(0.1,0.2*smoothstep(-0.7,0.7,mouse.y)-0.1);\n    \n    }\n    if(mode==1)\n    {\n    float mouseValue = mouse.y > 0.0 ? .1 : -.1;\n    q = vec2(0.1,mouseValue);\n    if (mouse.y>0.|| q.y>0.)LINESS=5.;\n    else if (mouse.y<=0.) LINESS=6.;\n    }\n    float idle = float(iMouse.z<0.||iMouse.x<0.001)*0.1, d=1.;\n    O = vec4(0);\n    \n    //idle=1.;\n    \n    \n    //render field line\n    if(idle>0.){q2.x=.4;q.y=.1;}      \n    for(float o = 0.;o<TAU;o+=TAU/LINES){\n        float angle = iDate.w*idle+TAU/(2.*LINES)+o;\n        vec2 os = vec2(cos(angle),sin(angle))*0.01;\n    \tif(integrate(d,uv,q,q1,q2,q1+os,q2)&&abs(q.y)>0.){\n    \t\tintegrate(d,uv,sign(q.y) * q,q1,q2,q2+mat2(-1,0,0,1)*os,q1);\n    \t}\n    \n        float f = phi(uv, q, q1, q2);\n        O = .2* vec4( max(f, 0.), max(-f, 0.), 0,0)\n             +  smoothstep(3./iResolution.y,.0, d);\n    }\n    \n    // render potential line\n    float isoLevel = 0.03; \n    for(float i00=0.;i00<1.;i00=i00+LINESS/200.)\n    {\n        isoLevel+=i00;\n        vec2 electricField = E(uv, q, q1, q2);\n        float potential = phi(uv, q, q1, q2);\n        if (potential >= isoLevel && potential <= isoLevel+LINESS_WIDTH-i00*.006) \n        {\n            vec3 color = vec3(1.,1.-i00*6.,0.); \n            O.rgb=color;\n            if(potential >= isoLevel && potential <= isoLevel+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH)\n             O.rgb = color*smoothstep(isoLevel, isoLevel+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH, potential);\n            if(potential >= (isoLevel+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH)) && potential <= isoLevel+LINESS_WIDTH-i00*.006)\n             O.rgb = color*smoothstep( isoLevel+LINESS_WIDTH-i00*.006, isoLevel+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH),potential);\n\n        }\n    }\n\n\n    float isoLevel1 = 0.03; \n    for(float i00=0.;i00<1.;i00=i00+LINESS/200.)\n    {\n        isoLevel1+=i00;\n        vec2 electricField = E(uv, q, q1, q2);\n        float potential = -phi(uv, q, q1, q2);\n        if (potential >= isoLevel1 && potential <= isoLevel1+LINESS_WIDTH-i00*.006) \n        {\n            O.a=0.;\n            vec3 color = vec3(1.-i00*6.,1.,0.); \n            O.rgb=color;\n            if(potential >= isoLevel1 && potential <= isoLevel1+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH)\n             O.rgb = color*smoothstep(isoLevel1, isoLevel1+(LINESS_WIDTH-i00*.006)/LINESS_SMOOTH, potential);\n            if(potential >= (isoLevel1+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH)) && potential <= isoLevel1+LINESS_WIDTH-i00*.006)\n             O.rgb = color*smoothstep( isoLevel1+LINESS_WIDTH-i00*.006, isoLevel1+(LINESS_WIDTH-i00*.006)*(1.-1./LINESS_SMOOTH),potential);\n\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat GetDist1(vec3 p) {\n    float d1 = sdBox(p, vec3(1.5,0.,1.));\n    return d1;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist1(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist1(p) - \n        vec3(GetDist1(p-e.xyy), GetDist1(p-e.yxy),GetDist1(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m.x = clamp(m.x, -PositionLimit, PositionLimit);\n    \n    vec3 ro = vec3(0, zoom, 0);\n    if(mode==1)\n    ro.yz *= Rot(-m.y*PI);\n    if(mode==0)\n    ro.yz *= Rot(SetAngle*PI);\n    //ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float dif = (dot(n, normalize(vec3(0,-1,1)))*.5+.5)*0.5;\n        dif += (dot(n, normalize(vec3(0,1,1)))*.5+.5)*0.5;\n        dif += (dot(n, normalize(vec3(0,0,1)))*.5+.5)*0.6;\n\n        col = vec3(dif);\n\n      \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    vec3 p = ro + rd * d;\n    vec2 uvTex = p.xz+vec2(1.95,1.) ;  // Adjust texture coordinates based on box size\n    uvTex.x*=0.25;\n    uvTex.y*=0.5;\n    vec4 texColor = texture(iChannel0, uvTex);\n   \n    col.rgb *= texColor.rgb;\n    \n    fragColor = vec4(col,0.);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\nfloat GetDist1(vec3 p) {\n    float d1 = sdBox(rotateMatrix(vec3(1.,0., 0.0), radians(60.)) * p, vec3(1.5,0.,1.));\n    return d1;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist1(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist1(p) - \n        vec3(GetDist1(p-e.xyy), GetDist1(p-e.yxy),GetDist1(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m.x = clamp(m.x, -PositionLimit, PositionLimit);\n\n    vec3 ro = vec3(0, zoom, 0);\n    if(mode==1)\n    ro.yz *= Rot(-m.y*PI);\n    if(mode==0)\n    ro.yz *= Rot(SetAngle*PI);\n    //ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = (dot(n, normalize(vec3(0,-1,1)))*.5+.5)*0.5;\n        dif += (dot(n, normalize(vec3(0,1,1)))*.5+.5)*0.5;\n        dif += (dot(n, normalize(vec3(0,0,1)))*.5+.5)*0.6;\n\n        col = vec3(dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    vec3 p = ro + rd * d;\n    vec2 uvTex = p.xz+vec2(1.95,.5) ;  // Adjust texture coordinates based on box size\n    uvTex.x*=0.25;\n    uvTex.y*=1.;\n    vec4 texColor = texture(iChannel0, uvTex);\n   \n    col.rgb *= texColor.rgb;\n    \n    fragColor = vec4(col,0.);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nfloat GetDist1(vec3 p) {\n    float d1 = sdBox(rotateMatrix(vec3(1.,0., 0.0), radians(120.)) * p, vec3(1.5,0.,1.));\n    return d1;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist1(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist1(p) - \n        vec3(GetDist1(p-e.xyy), GetDist1(p-e.yxy),GetDist1(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    m.x = clamp(m.x, -PositionLimit, PositionLimit);\n\n    vec3 ro = vec3(0, zoom, 0);\n    if(mode==1)\n    ro.yz *= Rot(-m.y*PI);\n    if(mode==0)\n    ro.yz *= Rot(SetAngle*PI);\n    //ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = (dot(n, normalize(vec3(0,-1,1)))*.5+.5)*0.5;\n        dif += (dot(n, normalize(vec3(0,1,1)))*.5+.5)*0.5;\n        dif += (dot(n, normalize(vec3(0,0,1)))*.5+.5)*0.6;\n\n        col = vec3(dif);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    vec3 p = ro + rd * d;\n    vec2 uvTex = p.xz+vec2(1.95,.5) ;  // Adjust texture coordinates based on box size\n    uvTex.x*=0.25;\n    uvTex.y*=1.;\n    vec4 texColor = texture(iChannel0, uvTex);\n   \n    col.rgb *= texColor.rgb;\n    \n    fragColor = vec4(col,0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/*\nh:Time step of numerical integration\nMAX_STEPS: maximum number of steps for numerical integration\nTAU: twice the circumference\nLINES: the number of power lines\nLINESS_WIDTH: the width of the equipotential line\n*/\n#define mode 0\n//mode 0 :Variable charge and position\n//mode 1 :Variable camera\n#define h 0.05\n#define MAX_STEPS 30\n#define LINES 10.\n#define LINEWIDTH 0.003\n#define LINESS_WIDTH 0.006\n#define LINESS_SMOOTH 3.5\n\n#define zoom 2\n\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.28318530718\n#define PI 3.141592\n#define S smoothstep\n#define SetAngle -.001\n\n#define PositionLimit 0.8\n#define T iTime\n\nfloat LINESS=6.;\n\n\n\n\n\nmat3 rotateMatrix(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n    \n    return mat3(\n        oc * x * x + c, oc * x * y - z * s, oc * x * z + y * s,\n        oc * x * y + z * s, oc * y * y + c, oc * y * z - x * s,\n        oc * x * z - y * s, oc * y * z + x * s, oc * z * z + c\n    );\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\n\n\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\n\n","name":"Common","description":"","type":"common"}]}