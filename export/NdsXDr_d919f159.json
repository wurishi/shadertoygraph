{"ver":"0.1","info":{"id":"NdsXDr","date":"1618520474","viewed":128,"name":"Ocean Sunset - Andrew","username":"andrew741","description":"Ocean waves, slowly flowing while the fiery sun sets into the horizon.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sunset","ocean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PERSITION 0.05\n#define MAX_DIST 600.\n#define STEPS 275\n\nvec3 sun_angle = normalize(vec3(0.80, 0.67, 1.));\nvec3 turquoise = vec3(0.10, 0.16, 0.78) * 2.15;\nvec3 dark_ocean_col = vec3(77, 33, 209) / 255.;\n\n\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k * k * (3. - 2. * k);\n}\n\n\nstruct RayCollide\n{\n    float depth;\n    vec3 position;\n};\n\n\nstruct Ray\n{\n    vec3 direction;\n    vec3 position;\n};\n\n\n// the smooth min and max are from https://www.youtube.com/watch?v=lctXaT9pxA0&t=844s\nfloat SmoothMin(float a, float b, float k)\n{\n    float h = clamp((a - b + k) / (2. * k), 0., 1.);\n    return a * h + b * (1. - h) - k * h * (1. - h);\n}\n\n\nfloat SmoothMax(float a, float b, float K)\n{\n    float k = 0. - K;\n    float h = clamp((a - b + k) / (2. * k), 0., 1.);\n    return a * h + b * (1. - h) - k * h * (1. - h);\n}\n\n\nfloat GetWaveHeight(vec2 p)\n{\n    p.x /= 2.;\n    p.y /= 2.;\n    float h1 = sin(p.y / 2.5 + iTime / 2.45 + cos(p.x / 7.7 + iTime / 5.35));\n    h1 = mix(-1. * abs(h1), h1, 0.2);\n    float h2 = sin(p.x / 2.7 + cos(iTime / 3.4) + iTime / 4.5) * (-1. * abs(cos(p.y / 4.2 + iTime / 3.46)));\n    float h3 = (sin(p.x / 3. + iTime / 3. - sin(p.x / 1.2 + iTime / 3.) + p.y + cos(iTime / 5. + p.y / 2.)) / 2. + 0.5) / 2.5;\n    float h4 = sin(p.x / 6. + p.y / 1.76 + cos(iTime/ 2.) - cos(p.x / 7. - p.y / 2. + sin(iTime / 5.))) + cos(p.y - p.x / 6.);\n    return mix(SmoothMax(h1, h2, 2.) / 2. + 0.5, h3 + h4 / 4., 0.25);\n}\n\n\nfloat GetDepth(vec3 p)\n{\n    float dto = (p.y - GetWaveHeight(p.xz));\n    return dto;\n}\n\n\nRayCollide CastRay(Ray ray)\n{\n    vec3 p = ray.position;\n    float dfs = 0.;\n    for (int s = 0; s < STEPS; s++)\n    {\n        float depth = GetDepth(p);\n        dfs += depth;\n        p = ray.position + ray.direction * dfs;\n        if (depth <= PERSITION || dfs >= MAX_DIST)\n        {\n            break;\n        }\n    }\n    return RayCollide(dfs, p);\n}\n\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDepth(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = d - vec3(\n        GetDepth(p - e.xyy),\n        GetDepth(p - e.yxy),\n        GetDepth(p - e.yyx));\n    \n    return normalize(normal);\n}\n\n\nvec3 Invert(vec3 vector)\n{\n    return -1. * vector;\n}\n\n\nvec3 Reflect(vec3 v1, vec3 v2)\n{\n    return Invert(v1) - v2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1.));\n    Ray ray = Ray(rd, vec3(iMouse.x / (iResolution.x / 30.), 10., iMouse.y / (iResolution.y / 30.)));\n    RayCollide collition = CastRay(ray);\n    vec3 normal = GetNormal(collition.position);\n    float lighting = clamp(dot(normal, sun_angle), 0.2, 1.5);\n    float specular = pow(max(dot(rd, sun_angle) * 1.2, 0.65), 1.2);\n    \n    RayCollide light_ray = CastRay(Ray(sun_angle, collition.position - (rd * (PERSITION * 2.))));\n    float depth_to_scene = GetDepth(light_ray.position);\n    if (depth_to_scene <= PERSITION)\n    {\n        lighting *= 0.25;\n        lighting = clamp(lighting, 0.2, 0.15);\n    }\n    \n    lighting = clamp(lighting, 0.1, 1.75);\n    \n    float density = 0.;\n    vec3 p = collition.position;\n    vec3 angle = mix(rd, Reflect(rd, normal), 0.25);  // add refraction\n    for (int s = 0; s < 10; s++)\n    {\n        p = p + angle * (float(s) * 2.);\n        float depth = GetDepth(p);\n        density += 0. - min(depth, 0.);\n    }\n    density /= 145.;\n    \n    vec3 other_col = dark_ocean_col;\n    vec3 col = mix(mix(turquoise, other_col, clamp(density, 0., 1.)) * lighting, vec3(0.45, 0.1, 0.7), clamp(collition.depth / MAX_DIST, 0., 1.));\n    \n    if (collition.depth >= MAX_DIST)\n    {\n        col = mix(mix(col, vec3(1., 0.35, 0.), 0.75), vec3(0.1, 0.05, 0.175), uv.y);\n        col = col * max(Smoothstep(clamp((0. - dot(rd / 1.35, Invert(sun_angle)) * 3.25), 1., 3.) / 2. - 0.5) * 2. + 1., 1.);\n    }\n    else\n    {\n        col = mix(col, mix(vec3(1.), vec3(1., 0.35, 0.), 0.55), clamp(Smoothstep(specular) * lighting * 2.05, 0., 1.));\n    }\n    \n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}