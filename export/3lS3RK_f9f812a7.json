{"ver":"0.1","info":{"id":"3lS3RK","date":"1560499496","viewed":578,"name":"Boss Fight","username":"belfry","description":"Use mouse or arrow keys to move.\nDodge fireballs and collect scrolls to defeat the demon.\nUpon winning the screen turns white and the game resets.","likes":16,"published":1,"flags":112,"usePreview":0,"tags":["game","bullets"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XlBXzz","filepath":"https://soundcloud.com/davies-vis-rinshankaihou/rabi-ribi-original-soundtrack-33-speicher-galerie?in=davies-vis-rinshankaihou/sets/rabi-ribi-soundtrack","previewfilepath":"https://soundcloud.com/davies-vis-rinshankaihou/rabi-ribi-original-soundtrack-33-speicher-galerie?in=davies-vis-rinshankaihou/sets/rabi-ribi-soundtrack","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 scroll(vec2 uv) {\n    vec2 uv2 = uv;\n    uv.y = abs(uv.y - .5) + .5;\n\n    vec2 a = abs(uv - vec2(.5, .8)) - vec2(.3, .07);\n    float d = max(a.x, a.y);\n    vec2 b = abs(vec2(abs(uv.x-.5), uv.y) - vec2(.23, .8)) - vec2(.03, .13);\n    float d2 = max(b.x, b.y);\n    d = min(d, d2);\n    vec2 c = abs(vec2(abs(uv.x-.5), uv.y) - vec2(.315, .8)) - vec2(.02, .035);\n    float d3 = max(c.x, c.y);\n    d = min(d, d3);\n    float lo = abs(uv.x-.5) < .2 ? 0. : .9;\n    lo = abs(uv.x-.5) < .26 ? lo : .05;\n    lo = abs(uv.x-.5) < .3 ? lo : -.217;\n    lo = abs(uv.x-.5) > .2 ? lo : .05;\n    float cyl = step(d, 0.) * (1. + lo + -abs(uv.y - .8)*15.);\n    \n    vec2 q = abs(uv - .5) - vec2(.2, .24);\n    float p = max(q.x, q.y);\n    float alpha = cyl > 0. || step(p, 0.)*.3 > 0. ? 1. : 0.;\n    \n    vec2 v = pow(abs(uv - .5), vec2(2.3));\n    float s = 1.-(v.x + v.y) * 15.;\n    s *= min((.75-pow(abs(uv.y), 1.))*20., 1.);\n    \n    vec2[] lsp = vec2[](vec2(.52, .68), vec2(.45, .5), \n                        vec2(.5, .5), vec2(.58, .68));\n    vec2[] lsp2 = vec2[](vec2(.57, .55), vec2(.5, .55), vec2(.43, .3));\n    float ls = min(sdPolygon(lsp, uv2), sdPolygon(lsp2, uv2));\n    \n    vec3 col = vec3(max(cyl*vec3(.7, .55, .3), step(p, 0.)*.8*s*vec3(.9, .85, .7)));\n    col += smoothstep(fwidth(ls), -fwidth(ls), ls)*.5*s * vec3(1., 1., 0.);\n    return vec4(col, alpha);\n}\n\n#define branchProbability .2\nfloat lightning(vec2 from, vec2 to, vec2 uv, float time) {\n    vec2 dir = to - from;\n    float dirSqr = dot(dir, dir);\n    vec2 newMid = mix(from, to, .5);\n    float t = hash11(time);\n    for (int i = 0; i < 30 && dirSqr > 0.000001; i++) {\n        vec2 mid = mix(from, to, .5);\n        dir = to - from;\n        dirSqr = dot(dir, dir);\n        vec2 normal = (vec2(-dir.y, dir.x));\n        float offsetAmount = .5 + sin(time) * 0.25;\n        vec2 offset = normal * (hash12(mid + t) - 0.5) * offsetAmount;\n        newMid = mid + offset;\n        \n        if (hash12(mid + 3.1 + t) < branchProbability) {\n            offset = normal * (hash12(mid + 0.1 + t) - 0.5) * offsetAmount;\n            vec2 mid2 = mid + offset;\n            vec2 d1 = uv - newMid;\n            vec2 d2 = uv - mid2;\n            if (dot(d1, d1) > dot(d2, d2)) {\n                newMid = mid2;\n            }\n        }\n\n        vec2 p = uv - from;\n        float a = dot(p, dir) / dirSqr;\n        if (a < 0.5) {\n        \tto = newMid;\n        } else {\n            from = newMid;\n        }\n    }\n    return length(uv - newMid);\n}\n\nvec4 knight(vec2 uv, float pumped) {\n    vec2 uv2 = uv;\n    \n    vec2[] a = vec2[](vec2(300., 567)/600., vec2(250., 520.)/600., vec2(300., 320.)/600.);\n    vec2[] b = vec2[](a[1], vec2(199., 510.)/600., a[2]);\n    vec2[] c = vec2[](b[1], vec2(95., 400.)/600., b[2]);\n    vec2[] d = vec2[](c[1], vec2(95., 360.)/600., vec2(300., 280.)/600., c[2]);\n    vec2[] e = vec2[](d[1], vec2(140., 343.)/600., vec2(200., 170.)/600., vec2(130., 200.)/600.);\n    vec2[] f = vec2[](vec2(150., 192.)/600., vec2(140., 85.)/600., vec2(200.,80.)/600., e[2]);\n    vec2[] g = vec2[](f[2], f[3], vec2(260.,140.)/600., vec2(260.,35.)/600.);\n    vec2[] h = vec2[](g[2], g[3], vec2(300.,30.)/600., vec2(300.,120.)/600.);\n    vec2[] i = vec2[](e[1], e[2], h[3], d[2]);\n    \n    vec2[] k = vec2[](vec2(150., 340.)/600., vec2(210., 190.)/600., vec2(230., 180.)/600., vec2(180., 325.)/600.);\n    vec2[] l = vec2[](vec2(205., 315.)/600., vec2(250., 173.)/600., vec2(265., 167.)/600., vec2(250., 300.)/600.);\n    vec2[] m = vec2[](vec2(280., 290.)/600., vec2(290., 165.)/600., vec2(300., 160.)/600., d[2]);\n    \n    \n    float rightLight = uv.x > 0.5 ? .2 : 0.;\n    uv.x = min(uv.x, 1. - uv.x);\n    \n    float aDist = sdPolygon(a, uv);\n    float dist = aDist;\n    float bDist = sdPolygon(b, uv);\n    dist = min(dist, bDist);\n    float cDist = sdPolygon(c, uv);\n    dist = min(dist, cDist);\n    float dDist = sdPolygon(d, uv);\n    dist = min(dist, dDist);\n    float eDist = sdPolygon(e, uv);\n    dist = min(dist, eDist);\n    float fDist = sdPolygon(f, uv);\n    dist = min(dist, fDist);\n    float gDist = sdPolygon(g, uv);\n    dist = min(dist, gDist);\n    float hDist = sdPolygon(h, uv);\n    dist = min(dist, hDist);\n    float iDist = sdPolygon(i, uv);\n    dist = min(dist, iDist);\n    dist -= .003;\n    \n    float slitDist = sdPolygon(k, uv);\n    slitDist = min(slitDist, sdPolygon(l, uv));\n    slitDist = min(slitDist, sdPolygon(m, uv));\n    \n    \n    float alpha = smoothstep(-fwidth(dist), fwidth(dist), dist);\n    float outlineDist = dist + .05 * alpha - .095;\n    float outline = smoothstep(-fwidth(outlineDist), fwidth(outlineDist), outlineDist);\n    vec4 col = vec4(1., 1., 0., 0.);\n    col = mix(vec4(0.), col, outline + 1. - alpha);\n    \n    float innerlineDist = dist + .01;\n    float innerline = smoothstep(-fwidth(innerlineDist), fwidth(innerlineDist), innerlineDist);\n    \n    float alphaA = smoothstep(-fwidth(aDist), fwidth(aDist), aDist);\n    float alphaB = smoothstep(-fwidth(bDist), fwidth(bDist), bDist);\n    float alphaC = smoothstep(-fwidth(cDist), fwidth(cDist), cDist);\n    float alphaD = smoothstep(-fwidth(dDist), fwidth(dDist), dDist);\n    float alphaE = smoothstep(-fwidth(eDist), fwidth(eDist), eDist);\n    float alphaF = smoothstep(-fwidth(fDist), fwidth(fDist), fDist);\n    float alphaG = smoothstep(-fwidth(gDist), fwidth(gDist), gDist);\n    float alphaH = smoothstep(-fwidth(hDist), fwidth(hDist), hDist);\n    float alphaI = smoothstep(-fwidth(iDist), fwidth(iDist), iDist);\n    \n    col = mix(vec4(83./255., 84./255., 88./255., 1.)+rightLight, col, alphaA);\n    col = mix(vec4(100./255., 101./255., 103./255., 1.)+rightLight, col, alphaB);\n    col = mix(vec4(83./255., 84./255., 88./255., 1.)+rightLight, col, alphaC);\n    col = mix(vec4(157./255., 158./255., 162./255., 1.)+rightLight, col, alphaD);\n    col = mix(vec4(85./255., 90./255., 92./255., 1.)+rightLight, col, alphaE);\n    col = mix(vec4(85./255., 90./255., 92./255., 1.)+rightLight, col, alphaF);\n    col = mix(vec4(93./255., 94./255., 99./255., 1.)+rightLight, col, alphaG);\n    col = mix(vec4(96./255., 101./255., 107./255., 1.)+rightLight, col, alphaH);\n    col = mix(vec4(115./255., 120./255., 126./255., 1.)+rightLight, col, alphaI);\n    \n    float alphaSlit = smoothstep(-fwidth(slitDist), fwidth(slitDist), slitDist);\n    col = mix(vec4(2./255., 3./255., 5./255., 1.), col, alphaSlit);\n    \n    col = mix(vec4(0., 0., 0., 1.), col, (1.-innerline) + outline);\n    \n    float eye = length(uv2 - vec2(.61, .46)) - 0.02;\n    float eyeAlpha = smoothstep(-0.08, 0.16, eye);\n    col = mix(vec4(1., .0, .0, 1.), col, eyeAlpha * (pumped) + 1. - pumped);\n    \n    if (fwidth(outlineDist) > .7)\n        return vec4(0.);\n    return vec4(col.rgb, 1.-outline);\n}\n\nvec4 fireball(vec2 uv, vec2 velo) {\n\tvelo = normalize(velo);\n    mat2 r = mat2(velo.x, velo.y, -velo.y, velo.x);\n    uv = uv * r;\n     \n    uv.y += sin(uv.x * 5. + iTime*.1) * .0625;\n    \n    float d = length(uv) - 1.;\n    vec2 p = uv - vec2(-5., 0.);\n    vec2 n = p.yx;\n    n.y = -n.y;\n    n = normalize(n);\n    float d1 = dot(uv - vec2(0., 1.), n);\n    \n    p = uv - vec2(-5., 0.);\n    n = p.yx;\n    n.y = -n.y;\n    n = normalize(n);\n    float d2 = dot(uv - vec2(0., -1.), n);\n    \n    d = min(d, max(max(-d1, d2), uv.x));\n    \n    if (fwidth(d) > .7)\n        return vec4(0.);\n    \n    float a = smoothstep(fwidth(d), -fwidth(d), d);\n    return vec4(1., abs(uv.y)*.15 - uv.x * uv.x * uv.x * .015 + .1, 0., a * .9);\n}\n\nfloat spiral(vec2 x)                                 \n{\n    float l = length(x);\n    float a = l * 100.;\n    return dot(x, vec2(cos(a), -sin(a))) / l * 1.5 + 1.5;\n}                                                   \n\nvec4 demon(vec2 uv, float time, float smile, float npcLives) {\n    vec2 uv3 = uv-.5;\n    float d = length(uv3) - .45;\n    float d1 = length(uv - vec2(.5, 1.)) - .45;\n    float d2 = length(uv - vec2(.5, 1.4)) - .6;\n    d = min(d, max(d1, -d2));\n    d += npcLives > 0. ? 0. : sin(sin(atan(uv3.y, uv3.x) * 5.) * 5.) * .01;\n    float r = d + .05;\n    float dWidth = fwidth(d);\n    d = smoothstep(0. + dWidth, 0. - dWidth, d);\n    float rWidth = fwidth(r);\n    r = smoothstep(0. + rWidth, 0. - rWidth, r);\n    vec4 head = vec4(r, 0., 0., d);\n    \n    vec2 uv2 = uv;\n    uv2.x -= .5;\n    uv2.x = npcLives == 3. ? abs(uv2.x) : uv2.x;\n    vec2 e = vec2(.2, .6);\n    e = uv2 - e;\n    float t = -3. * time;\n    e = mat2(cos(t), sin(t), -sin(t), cos(t)) * e;\n    float x = spiral(e);\n    x *= npcLives >= 2. ? smoothstep(.17, .1, length(e)) : 0.;\n    \n    float m = length(uv - vec2(.5, .4)) - mix(.2, .25, clamp(smile / .7, 0., 1.));\n    m = max(m, -(length(uv - vec2(.5, .5)) - .27));\n    m = mix(m, length(uv - vec2(.5, .2)) - .07, clamp((smile - .7) / .3, 0., 1.));\n    float mWidth = fwidth(m);\n    m = npcLives > 0. ? smoothstep(0. + mWidth, 0. - mWidth, m) : 0.;\n    \n    // fix inconsistent screen space deriviatives when using bounding boxes\n    if (dWidth > .2 || rWidth > .2 || mWidth > .2)\n        return vec4(0.);\n    \n    vec4 c = mix(vec4(0., 0., 0., 0.), head, head.a);\n    c = mix(c, vec4(0., 0., 0., 1.), m);\n    return mix(c, vec4(0., 0., 0., 1.), x);\n}\n\nvec4 hitDisplay(vec2 uv, float hitCount)\n{\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float l = length(uv);\n    float tiling = 12.;\n    float tiled = fract(l * tiling);\n    float id = floor(l * tiling);\n    vec2 offset = sin((hash21(id + 1.) + .5) * iTime * 6.) * .023;\n    float l2 = fract(length(uv + offset) * tiling);\n    return vec4(id <= hitCount && id != 0. ? smoothstep(.45, .6, l2) * smoothstep(.6, .45, l2) * 2. : 0.);\n}\n\nvec4 background( vec2 uv )\n{\n    float s = 3.;\n    float t = 10.;\n    vec3 e = vec3(s * uv.x + uv.y, s - s * uv.x + uv.y, uv.y * 2.) * t;\n   \tvec3 id = floor(e);\n    e = fract(vec3(e.xy, e.z + 1.));\n    e = smoothstep(0., .05, e) * smoothstep(1., .95, e);\n    float l = e.x * e.y * e.z;\n    float n = hash13(id);\n    float fft = texelFetch(iChannel1, ivec2(id.x + id.y + id.z, 0), 0).x;\n    return vec4(n*l*(vec3(0.3) + fft), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 even = ivec2(fragCoord) % 2;\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    ivec2 c = ivec2(fragCoord);\n    vec2 playerPos = texelFetch(iChannel0, ivec2(0), 0).xy;\n    vec4 npc = texelFetch(iChannel0, ivec2(4, 0), 0);\n    vec2 npcPos = npc.xy;\n    float npcSignaling = npc.z;\n    float npcLives = npc.w;\n    vec2 projPos = texelFetch(iChannel0, ivec2(1, 0), 0).xy;\n    vec2 projVelo = texelFetch(iChannel0, ivec2(1, 0), 0).zw;\n    vec2 hitInfo = texelFetch(iChannel0, ivec2(5, 0), 0).xy;\n\tfloat hit = hitInfo.x;\n    float hitCount = hitInfo.y;\n    vec4 pick = texelFetch(iChannel0, ivec2(6, 0), 0);\n    vec2 pickupPos = pick.xy;\n    float pickup = pick.z;\n    float won = texelFetch(iChannel0, ivec2(7, 0), 0).r;\n    \n    vec4 lightningData = texelFetch(iChannel0, ivec2(8, 0), 0);\n    vec2 lightningStart = lightningData.xy;\n    vec2 lightningTarget = lightningData.zw;\n    vec4 lightningTime = texelFetch(iChannel0, ivec2(9, 0), 0);\n    float lightningTimeBuffer = lightningTime.x;\n    float lightningFrame = lightningTime.y;\n    \n    float playerDist = dot(playerPos - uv, playerPos - uv) - .1*.1;\n    float projDist = dot(projPos - uv, projPos - uv) - .12*.12;\n    vec2 npcDist = abs(npcPos - uv) - 1./13.;\n    float pickupDist = dot(pickupPos - uv, pickupPos - uv) - .07*.07;\n    \n    float h = clamp(2. - hit, 0., 2.);\n    float p = clamp(2. - pickup, 0., 2.);\n    vec4 hDisplay = hitDisplay(uv, hitCount);\n    fragColor = hDisplay + \n    \tvec4(h * .2, 0., 0., 0.) + \n        vec4(p * .2, p * .2, 0., 0.) + \n        background(fragCoord / iResolution.xy) + \n        min(vec4(.17 + sin(iTime) * .06, 0.44, .49, 0.) * clamp(1. - length(playerPos - uv), 0., 1.) +\n        vec4(.7, .1, .1, 0.) * clamp(1. - length(npcPos - uv) * 1.3, 0., 1.) + \n        vec4(.7, .1, .1, 0.) * clamp(1. - length(projPos - uv) * 1.3, 0., 1.) + \n        vec4(.29, .44, .49, 0.) * clamp(1. - length(pickupPos - uv), 0., 1.),\n           vec4(.4, .4, .4, .0));\n    \n    if (playerDist < 0.) {\n        vec4 playerCol = knight((uv - playerPos) / 0.1 + .5, hitCount == 0. ? 1. : 0.);\n    \tfragColor = mix(playerCol, fragColor, 1.-playerCol.a);\n    }\n    if (projDist < 0.) {\n        vec4 projCol = fireball((uv - projPos) / 0.02 + .5, projVelo);\n    \tfragColor = mix(fragColor, projCol, projCol.a);\n    }\n    if (max(npcDist.x, npcDist.y) < 0.) {\n        vec4 npcCol = demon((uv - npcPos) * 7. + .5, iTime, npcSignaling, npcLives);\n    \tfragColor = mix(fragColor, npcCol, npcCol.a);\n    }\n    if (pickupDist < 0.) {\n    \tvec4 pickupCol = scroll((uv - pickupPos) * 8. + .5);\n    \tfragColor = mix(pickupCol, fragColor, 1.-pickupCol.a);\n    }\n    \n    if (p > 0.) {\n        float l = lightning(lightningStart, lightningTarget, uv, lightningFrame);\n    \tfragColor.rgb += vec3(smoothstep(.0015, 0., l)) * vec3(0.7, 0.85, 0.9);\n    }\n    \n    uv = (2. * fragCoord - iResolution.xy) / iResolution.xy;\n    uv = abs(uv);\n    uv = pow(uv, vec2(3.));\n    float vignette = clamp(1.4 - pow(uv.x + uv.y, .3), 0., 1.);\n    fragColor = mix(fragColor, vec4(1.), clamp(won, 0., 1.)) * vignette; \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 projectileVelo(vec2 oldPlayerPos, vec2 playerVelo, vec2 npcPos, float projSpeed) {\n    vec2 npc2player = (oldPlayerPos - npcPos);\n    float a = dot(npc2player, npc2player);\n    float b = dot(playerVelo, npc2player);\n    float c = dot(playerVelo, playerVelo) - projSpeed * projSpeed;\n    float time = (-sqrt(b * b - a * c) - b) / c;\n    return npc2player / time + playerVelo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 c = ivec2(fragCoord);\n    if (c.y > 0) {\n        fragColor = vec4(0.);\n        return;\n    }\n    vec2 playerPos;\n    vec2 npcPos;\n    float npcSignaling;\n    float npcLives;\n    vec2 playerVelo;\n    vec2 projPos;\n    vec2 projVelo;\n    vec2 pickupPos;\n    float projSpeed = 1.;\n    float playerSpeed = .3;\n    float lightningSpeed = 9.;\n    float hit;\n    float hitCount;\n    float pickup;\n    vec2 lightningStart;\n    vec2 lightningTarget;\n    float lightningTimeBuffer;\n    float lightningFrame;\n    float won = texelFetch(iChannel0, ivec2(7, 0), 0).r;\n    if (iFrame == 0 || won >= 3.) {\n        playerPos = vec2(-1.1, 0.1);\n        npcPos = vec2(.9);\n        playerVelo = vec2(.2);\n        projPos = vec2(2.);\n        hit = 100.;\n        hitCount = 3.;\n        npcLives = 3.;\n        pickup = 100.;\n        pickupPos = vec2(-.6);\n        won = -3.;\n        lightningTimeBuffer = 1. / lightningSpeed;\n        lightningFrame = 0.;\n    } else {\n        vec4 player = texelFetch(iChannel0, ivec2(0), 0);\n        playerPos = player.xy;\n        playerVelo = player.zw;\n        vec4 projectile = texelFetch(iChannel0, ivec2(1, 0), 0);\n        projPos = projectile.xy;\n        projVelo = projectile.zw;\n        npcPos = texelFetch(iChannel0, ivec2(4, 0), 0).xy;\n        npcSignaling = texelFetch(iChannel0, ivec2(4, 0), 0).z;\n\t\tnpcLives = texelFetch(iChannel0, ivec2(4, 0), 0).w;\n        hit = texelFetch(iChannel0, ivec2(5, 0), 0).x;\n        hitCount = texelFetch(iChannel0, ivec2(5, 0), 0).y;\n        vec4 pick = texelFetch(iChannel0, ivec2(6, 0), 0);\n        pickupPos = pick.xy;\n        pickup = pick.z;\n        //won = texelFetch(iChannel0, ivec2(7, 0), 0).r;\n        vec4 lightning = texelFetch(iChannel0, ivec2(8, 0), 0);\n        lightningStart = lightning.xy;\n        lightningTarget = lightning.zw;\n        vec4 lightningTime = texelFetch(iChannel0, ivec2(9, 0), 0);\n        lightningTimeBuffer = lightningTime.x;\n        lightningFrame = lightningTime.y;\n    }\n    vec2 r = vec2(iResolution.x / iResolution.y, 1.);\n    \n    if (npcLives > 0.) {\n        npcPos = vec2(cos(iTime), sin(iTime)) * .05;// * hitCount;\n        npcPos = mod(npcPos + r, 2. * r) - r;\n    }\n        \n    playerPos += playerVelo * iTimeDelta;\n    playerPos = mod(playerPos + r, 2. * r) - r;\n    \n    lightningTimeBuffer += iTimeDelta;\n    if (lightningTimeBuffer >= 1./lightningSpeed) {\n        lightningTimeBuffer -= 1./lightningSpeed;\n        lightningFrame += 1.;\n        lightningStart = playerPos;\n        lightningTarget = npcPos;\n    }\n    \n    if (iTime > 2. && npcLives > 0.) {\n        if (any(greaterThan(abs(projPos), vec2(iResolution.x / iResolution.y, 1.)))) {\n            npcSignaling += iTimeDelta * 2.;\n            npcSignaling = min(npcSignaling, 1.);\n            if (npcSignaling == 1.) {\n                projPos = npcPos;\n            \tprojVelo = projectileVelo(playerPos, playerVelo, npcPos, projSpeed);\n            }\n        } else {\n            npcSignaling -= iTimeDelta;\n            npcSignaling = max(npcSignaling, 0.);\n        }\n        projPos += projVelo * iTimeDelta;\n    }\n    \n    if (npcLives == 0.) {\n        projPos = vec2(2.);\n    }\n        \n    vec2 m = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    if (iMouse.z > .5 && length(m - playerPos) > .05) {\n        playerVelo = normalize(m - playerPos) * playerSpeed;\n    } else {\n        playerVelo = vec2(0.);\n    }\n    \n    playerVelo.x -= texelFetch( iChannel1, ivec2(37,0), 0 ).x;\n    playerVelo.y += texelFetch( iChannel1, ivec2(38,0), 0 ).x;\n    playerVelo.x += texelFetch( iChannel1, ivec2(39,0), 0 ).x;\n    playerVelo.y -= texelFetch( iChannel1, ivec2(40,0), 0 ).x;\n    \n    playerVelo = dot(playerVelo, playerVelo) > 0. ? \n        normalize(playerVelo) * playerSpeed : vec2(0.);\n    \n    hit += iTimeDelta;\n    if (length(projPos - playerPos) < 0.03) {\n        hit = 0.;\n        projPos = vec2(10.);\n        hitCount += 1.;\n    }\n    \n    pickup += iTimeDelta;\n    if (length(pickupPos - playerPos) < 0.02 + 0.05) {\n        pickup = 0.;\n        vec3 h = hash31(iTime);\n        pickupPos = normalize(h.xy - .5) * clamp(h.z, .8, .9) * clamp(hitCount / 5. + .2, .2, 1.);\n        \n        if (length(pickupPos - playerPos) < 0.02 + 0.75) {\n    \t\tpickupPos *= -1.;\n        }\n        \n        if (hitCount > 0.) {\n        \thitCount -= 1.;\n        } else {\n            npcLives -= 1.;\n        }\n        if (npcLives <= 0.) {\n            pickupPos = vec2(2.);\n        }\n    }\n    hitCount = clamp(hitCount, 0., 5.);\n    npcLives = clamp(npcLives, 0., 3.);\n    \n    if (npcLives == 0.) {\n        won += iTimeDelta;\n    }\n        \n    if (c.x == 0) {\n        fragColor = vec4(playerPos, playerVelo);\n    }\n    if (c.x == 1) {\n     \tfragColor = vec4(projPos, projVelo);\n    }\n    if (c.x == 4) {\n     \tfragColor = vec4(npcPos, npcSignaling, npcLives);\n    }\n    if (c.x == 5) {\n     \tfragColor = vec4(hit, hitCount, 0., 0.);\n    }\n    if (c.x == 6) {\n     \tfragColor = vec4(pickupPos, pickup, 0.);\n    }\n    if (c.x == 7) {\n     \tfragColor = vec4(won, 0., 0., 0.);\n    }\n    if (c.x == 8) {\n     \tfragColor = vec4(lightningStart, lightningTarget);\n    }\n    if (c.x == 9) {\n        fragColor = vec4(lightningTimeBuffer, lightningFrame, 0., 0.);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// --- taken from: https://www.shadertoy.com/view/4djSRW ---\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 19.19;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+19.19);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n// ----------------------------------------------------------\n\n// --- taken from: https://iquilezles.org/articles/distfunctions2d ---\n#define polygon(N) float sdPolygon( in vec2[N] v, in vec2 p ) {\\\n    float d = dot(p-v[0],p-v[0]);\\\n    float s = 1.0;\\\n    for( int i=0, j=N-1; i<N; j=i, i++ )\\\n    {\\\n        vec2 e = v[j] - v[i];\\\n        vec2 w =    p - v[i];\\\n        vec2 b = w - e*clamp( dot(w,e)/(dot(e,e)+0.0001), 0.0, 1.0 );\\\n        d = min( d, dot(b,b) );\\\n        bvec3 c = bvec3(p.y>=v[i].y,p.y<v[j].y,e.x*w.y>e.y*w.x);\\\n        if( all(c) || all(not(c)) ) s*=-1.0;\\\n    }\\\n    return s*sqrt(d);\\\n}\n// -------------------------------------------------------------------------------------------\n\n\npolygon(3)\npolygon(4)","name":"Common","description":"","type":"common"}]}