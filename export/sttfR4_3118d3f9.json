{"ver":"0.1","info":{"id":"sttfR4","date":"1663024331","viewed":77,"name":"Slighty trippy Car","username":"mbeale0","description":" A colorful car with some wonky effects","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"7ldfRr","parentname":"CS4710 - day6 - sdf sphere"},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159;\nmat3 rotateY(float rad){\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nfloat polyN  = 5.0;                 // nb sides for polygon and star shape\nfloat starR  = 0.5;                 // star interior radius ( % exterior )\nvec2  BEVEL = vec2(.5)/4.;\n\n//https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s){\n    return length(p) - s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat circles(vec2 uv, float r){\n    // Position of point assuming center is (.5,.5)\n    vec2 pos = vec2(0.5)-fract(uv);\n    \n    // Find squared distance from origin\n    float lineLength = distance(pos, vec2(0.));\n    return 1.-step(r, lineLength);\n}\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    \n    float lineLength = distance(p, vec2(0.));\n    return 1.-step(r, lineLength);\n}\n//https://www.shadertoy.com/view/ts2SDt\nfloat getShapeValue(vec2 uv){\n    // Scale the coords up by 10 to increase number of shapes\n    uv *= 10.;\n    // Note the column and row of each coord\n    vec2 colRow = floor(uv);\n    // Grab fractional remainders for each to create [0, 1] blocks\n    uv = fract(uv);\n    \n\t// used to determine if the dots should move up or down based off the time\n    bool flipper = mod(floor(iTime), 2.) == 0.;\n    // Scaled and offset so seconds are in increments of Pi\n    float t = PI/2.+(fract(iTime)*PI);\n    // vertical position\n    float v = (sin(t)+1.)/2.;\n    // adjusts positions of pixels\n    if(flipper){\n        // For any pixel in an even column\n        if(mod(colRow.x, 2.) == 0.){\n            uv += vec2(0, v);\n        }\n        else{\n            uv -= vec2(0, v);\n        }\n    }\n    // horizontal position\n    else{\n        // For any pixel in an even row\n        if(mod(colRow.y, 2.) == 0.){\n         uv += vec2(v,0.);\n        }\n        else{\n            uv -= vec2(v,0.);\n        }\n    }\n    return max(circles(uv, .2), sdHexagram(uv, .1));\n}\nvec3 shapeColor(vec3 posdy, vec3 pos, vec3 posdx, vec2 uv){\n    //find vector direction slightly downward on surface\n    vec3 CA = normalize(posdy - pos);\n\n    //find vector direction slightly to the right on the surface\n    vec3 BA = normalize(posdx - pos);\n\n    vec3 normal = cross(CA, BA);\n\n    //a fixed light from the direction of the camera\n    vec3 lightDir = vec3(0,0,1);\n\n    float SinTimeValue = (sin(iTime)+1.)/2.;\n    float r = (256.*SinTimeValue)/256.;\n    float CosTimeValue = (cos(iTime)+1.)/2.;\n    float g = (256.*CosTimeValue)/256.;\n    float val = getShapeValue(uv);       \n    if(val != 0.){\n        return vec3(val);\n    }\n    return vec3(r, g, .3)*dot(-lightDir,normal);\n}\n\nbool testScenePos(vec3 eye, vec3 dir, out vec3 outPos){\n    float t = 0.0;    \n    float an = 2.5*(5.5+0.5*sin(3.0));\n    vec2 c = vec2(sin(an),cos(an));\n    for( int i = 0; i < 50; i++){\n        //calc positions from view rays\n       vec3 pos = eye + dir * t;                       \n\n        //get dist/ance from positions to spheres\n        float dist = min(sdCappedTorus(rotateY(iTime)*pos-vec3(-4, -5.5, 1.75), c, 2., .25), sdBox(rotateY(iTime)*pos-vec3(0, -3, 5), vec3(7., 1.25, 3)));  \n        dist = min(dist, sdCappedTorus(rotateY(iTime)*pos-vec3(4, -5.5, 1.75), c, 2., .25));\n        dist = min(dist, sdCappedTorus(rotateY(iTime)*pos-vec3(-4, -5.5, 8.25), c, 2., .25));\n        dist = min(dist, sdCappedTorus(rotateY(iTime)*pos-vec3(4, -5.5, 8.25), c, 2., .25));\n        dist = min(dist, sdCappedCylinder(rotateX(1.565)*rotateY(iTime) * pos-vec3(4, 1.5, 5), 1.25, .5));\n        dist = min(dist, sdCappedCylinder(rotateX(1.565)*rotateY(iTime)* pos-vec3(-4, 1.5, 5), 1.25, .5));\n        dist = min(dist, sdCappedCylinder(rotateX(1.565)*rotateY(iTime) * pos-vec3(4, 8.5, 5), 1.25, .5));\n        dist = min(dist, sdCappedCylinder(rotateX(1.565)*rotateY(iTime)* pos-vec3(-4, 8.5, 5), 1.25, .5));\n        dist = min(dist, sdBoxFrame(rotateY(iTime)*pos-vec3(-.8, .1, 5), vec3(3.8, 1.9, 2), .3));\n        if(dist < 0.01){\n            outPos = pos;\n            return true;\n        }\n        t += dist;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = fragCoord.xy/iResolution.x - vec2(0.5);    \n    \n    //background color\n    vec3 col = vec3(sin(uv.x*13.0+iTime)*cos(uv.x*30.0+iTime));\n    \n    float rad = iTime;\n    vec2 uvMirror = uv;\n    uvMirror.y = cos(rad)*uv.x + sin(rad) * uvMirror.y;\n    // intermediate colors\n    if(uv.x > 0.4 && uv.x < 0.6 && uv.y > 0.4 && uv.y < 0.6){\n       col = vec3(1,0,0);\n    }\n     \n    if(uv.x < -.30 || (uv.x >= .0 && uv.x < .25) || uv.x >= .4){\n        col.z *= cos(texture(iChannel0, uvMirror + (-iTime/8.)).r);\n    }\n    else{\n        col *= -sin(texture(iChannel0, uvMirror + (-iTime/5.)).rgb);\n    }\n              \n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n\n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.004, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.004, 5));\n    vec3 eye = vec3(0, 3.0, -100);\n    vec3 pos, posdx, posdy;\n         \n    if(testScenePos(eye, dir, pos) && testScenePos(eye, dirdx, posdx)\n        && testScenePos(eye, dirdy, posdy)){\n        col = shapeColor(posdy, pos, posdx, uv);\n        \n    }\n    // Output to screen\n    fragColor = vec4(col,1.0) * sin((iTime* (fragCoord.x*10.)/fragCoord.y)*uv.y);\n}","name":"Image","description":"","type":"image"}]}