{"ver":"0.1","info":{"id":"7tsGzn","date":"1621635256","viewed":111,"name":"Wave 1D","username":"kinokomushroom","description":"A force is applied to each pixel, which is calculated from the value differences from the two pixels next to it.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float point_radius = 3.0; // the wave height at each x value is rendered as a point\n\nvec3 background_color = vec3(0, 0, 0) / 255.0;\nvec3 normal_color = vec3(48, 240, 93) / 255.0; // a cool matrix-ish green color\nvec3 fixed_color = vec3(235, 80, 80) / 255.0; // no color goes better with green than red\nvec3 free_color = vec3(0, 0, 0) / 255.0; // free points should be displayed as non-existent\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 pixel = vec2(1.0, 1.0) / iResolution.xy;\n    \n    // render point\n    bool is_normal = false;\n    bool is_fixed = false;\n    bool is_free = false;\n    for (float d_x = -point_radius; d_x <= point_radius; d_x += 1.0) {\n        vec4 point_info = texture(iChannel0, uv + pixel * vec2(d_x, 0.0));\n        float point_height = point_info.x * iResolution.y;\n        float point_distance = distance(fragCoord, vec2(fragCoord.x + d_x, point_height));\n        if (point_distance <= point_radius) {\n            is_fixed = bool(point_info.z);\n            is_free = bool(point_info.w);\n            is_normal = (!is_fixed && !is_free) ? true : is_normal;\n        }\n    }\n    \n    vec3 final_color = is_normal ? normal_color : (is_free ? free_color : (is_fixed ? fixed_color : background_color));\n    \n    fragColor = vec4(final_color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.1415926535\nfloat frame_length = 1.0 / 60.0;\nfloat acceleration_multiplier = 3600.0; // works best at 3600 (= 60 * 60)\n\nfloat fixed_positions[2] = float[]( 0.0, 1.0 ); // set these in range[0, 1] to make them effective\nfloat free_positions[2] = float[]( -1.0, -1.0 );\nfloat range = 0.03;\n\nstruct pixel_info { // information about pixel\n    float x_position; // uv coordinates\n    int timesteps_ahead;\n    float position;\n    float velocity;\n    float new_position;\n    float new_velocity;\n    bool is_fixed;\n    bool is_free;\n};\n\n// wave_speed has to be a non-negative integer\n// the wave moves at wave_speed pixels per frame\n#define wave_speed 4\nint array_size = wave_speed * 2 + 1;\npixel_info pixel_array[wave_speed * 2 + 1];\n\nfloat remap_range(float value) { // maps range [-1, 1] to [0, 1]\n    return value * 0.5 + 0.5;\n}\n\nfloat unmap_range(float value) { // maps range [0, 1] to [-1, 1]\n    return (value - 0.5) * 2.0;\n}\n\nbool is_fixed( vec2 fragCoord ) { // check if pixel at position is fixed\n    if (abs(fragCoord.x / iResolution.x - fixed_positions[0]) <= range\n        || abs(fragCoord.x / iResolution.x - fixed_positions[1]) <= range) {\n        return true;\n    }\n    return false;\n}\n\nbool is_free( vec2 fragCoord ) { // check if pixel at position is free\n    if (abs(fragCoord.x / iResolution.x - free_positions[0]) <= range\n        || abs(fragCoord.x / iResolution.x - free_positions[1]) <= range) {\n        return true;\n    }\n    return false;\n}\n\nfloat wave( float current_time, float start_time, float duration, float frequency, float phase, float amplitude, int wave_type ) { // generate wave\n    float result;\n    float time = current_time - start_time;\n    if (time > 0.0 && (duration < 0.0 || time * frequency <= duration)) {\n        float base_wave;\n        if (wave_type == 0) { // sin wave\n            base_wave = sin((time * frequency + phase) * 2.0 * pi);\n        }\n        else if (wave_type == 1) { // square wave\n            base_wave = unmap_range(float(int((time * frequency + phase) * 2.0 + 1.0) % 2));\n        }\n        else if (wave_type == 2) { // saw wave\n            base_wave = fract(time * frequency + phase) * 2.0;\n            base_wave -= base_wave <= 1.0 ? 0.0 : 2.0;\n        }\n        else if (wave_type == 3) { // triangle wave\n            float slope = fract(time * frequency + 0.25 + phase) * 2.0;\n            slope = slope <= 1.0 ? slope : 2.0 - slope;\n            base_wave = unmap_range(slope);\n        }\n        return base_wave * amplitude;\n    }\n    else {\n        result = 0.0;\n    }\n    return result;\n}\n\nfloat transform_fixed( float uv_x, int timesteps_ahead ) { // transform fixed points\n    float time = iTime + float(timesteps_ahead) * frame_length / float(wave_speed);\n    \n    if (abs(uv_x - fixed_positions[0]) <= range) {\n        return wave(time, 0.5, 1.0, 0.8, 0.0, 0.3, 0) + wave(time, 0.5, 2.0, 1.6, 0.0, 0.2, 0); // change this to alter wave shape at position 1\n    }\n    if (abs(uv_x - fixed_positions[1]) <= range) {\n        return wave(time, 0.1, 1.5, 1.0, 0.5, 0.2, 0); // change this to alter wave shape at position 2\n    }\n}\n\nvoid initialize_array( vec2 fragCoord ) { // initializes pixel_array with information from the previous buffer\n    int center_index = array_size / 2;\n    \n    for (int index = 0; index < array_size; index++) {\n        float x_difference = float(index - center_index);\n        vec2 target_position = (fragCoord + vec2(x_difference, 0.0)) / iResolution.xy;\n        vec4 target_color = texture(iChannel0, target_position);\n        \n        pixel_array[index].x_position = target_position.x;\n        pixel_array[index].timesteps_ahead = 0;\n        pixel_array[index].position = pixel_array[index].new_position = unmap_range(target_color.x);\n        pixel_array[index].velocity = pixel_array[index].new_velocity = unmap_range(target_color.y);\n        pixel_array[index].is_fixed = bool(target_color.z);\n        pixel_array[index].is_free = bool(target_color.w);\n    }\n}\n\nvoid update_index( int index ) { // calculates pixel information for the next timestep using two adjacent pixels\n    pixel_info target_pixel = pixel_array[index];\n    pixel_info left_pixel = pixel_array[index - 1];\n    pixel_info right_pixel = pixel_array[index + 1];\n    pixel_array[index].timesteps_ahead += 1;\n    \n    if (target_pixel.is_fixed) {\n        pixel_array[index].new_position = transform_fixed(pixel_array[index].x_position, pixel_array[index].timesteps_ahead);\n        return;\n    }\n    if (target_pixel.is_free) {\n        return;\n    }\n    \n    float previous_position = target_pixel.position;\n    float previous_position_left = left_pixel.position;\n    float previous_position_right = right_pixel.position;\n    float position_difference = (previous_position_left - previous_position) * float(!left_pixel.is_free)\n        + (previous_position_right - previous_position) * float(!right_pixel.is_free);\n    float current_acceleration = position_difference * acceleration_multiplier;\n\n    float previous_velocity = target_pixel.velocity;\n    pixel_array[index].new_velocity = previous_velocity + current_acceleration * frame_length;\n    pixel_array[index].new_position = previous_position + pixel_array[index].new_velocity * frame_length;\n}\n\nvoid update_array() { // updates pixel information for next calculation\n    for (int index = 0; index < array_size; index++) {\n        pixel_info target_pixel = pixel_array[index];\n        pixel_array[index].position = target_pixel.new_position;\n        pixel_array[index].velocity = target_pixel.new_velocity;\n    }\n}\n\nvoid recursive_update( vec2 fragCoord ) { // not actually recursive but don't tell anyone shhhh\n    initialize_array(fragCoord);\n    for (int start_index = 1; start_index < array_size - 1; start_index++) {\n        for (int current_index = start_index; current_index < array_size - start_index; current_index++) {\n            update_index(current_index);\n        }\n        update_array();\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float current_position;\n    float current_velocity;\n    \n    if (iFrame == 0) { // initialize values\n        current_position = 0.0;\n        current_velocity = 0.0;\n    }\n    else {\n        int center_index = array_size / 2;\n        recursive_update(fragCoord);\n        current_position = pixel_array[center_index].position;\n        current_velocity = pixel_array[center_index].velocity;\n    }\n    \n    fragColor = vec4(remap_range(current_position), remap_range(current_velocity), float(is_fixed(fragCoord)), float(is_free(fragCoord)));\n}","name":"Buffer A","description":"","type":"buffer"}]}