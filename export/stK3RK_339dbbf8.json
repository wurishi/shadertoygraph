{"ver":"0.1","info":{"id":"stK3RK","date":"1638174152","viewed":226,"name":"equidistant curve","username":"Aiibow","description":"make a equidistant sin curve by newton/chebyshef method","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["2d","curve","offset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float f(float x){\n    return sin(x * 3.) * .5;\n    //return sin(x * 7.) * 0.5;\n}\n\nfloat df(float x){\n    return cos(x * 3.) * .5 * 3.;\n    //return cos(x * 7.) * .5 * 7.;\n}\n\nfloat ddf(float x){\n    return -sin(x * 3.) * .5 * 3. * 3.;\n    //return -sin(x * 7.) * .5 * 7. * 7.;\n}\n\nfloat dddf(float x){\n    return -cos(x) * .5;\n    //return -cos(x * 7.) * .5 * 7. * 7. * 7.;\n}\n\nfloat g(vec2 p, float x){\n    return p.y - f(x) + (p.x - x)/df(x);\n}\n\nfloat dg(float xp, float x){\n    float k = -df(x) + ((x - xp) * ddf(x) - df(x)) / (df(x) * df(x));\n    return k;\n}\n\nfloat ddg(float xp, float x){\n    return -ddf(x) + ((x - xp)*(dddf(x) - 2.* ddf(x) * ddf(x) + 2.*df(x) * ddf(x)))/(df(x) * df(x) * df(x));\n}\n\nfloat h(float xp, float x, float w){\n    return - 1./df(xp) * x + f(xp) + xp/df(xp) - f(x) - w;\n}\n\nfloat dh(float xp, float x){\n    return - 1./df(xp) - df(x);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n\n    float kx = uv.x;\n    float w = 0.15;\n    float lw = w * .1;\n    \n    for( int i = 0; i < 4; i++){\n        float g_x = g(uv, kx);\n        float dg_x = dg(uv.x, kx);\n        // try to fix the issue which derivative equal 0\n        //dg_x = (dFdx(g_x) - g_x) / dFdx(uv.x);\n        //dg_x = sign(dg_x) * (abs(dg_x) + w * 10.);\n        //dg_x = sign(dg_x) * max(abs(dg_x), w * 10.);\n        float ddg_x = ddg(uv.x, kx);\n        kx = kx - g_x / dg_x;\n        \n        //kx = kx - g_x / dg_x - ddg_x * g_x * g_x / (2.* pow(dg_x, 3.)); // chebyshef \n    }\n    \n    float fx = kx;\n    float fy = f(kx);\n    \n    float d0 = 1.;\n    if( dot(vec2(0., 1.), vec2(uv.x - fx, uv.y - fy)) > 0.){    \n        d0 = distance(uv, vec2(fx, fy)) - w;\n        d0 = smoothstep(0., lw, abs(d0));\n    }\n    float d = d0;\n    \n    float d1 = f(uv.x) - uv.y;\n    d1 = smoothstep(.0, lw, abs(d1));\n    d = min(d1, d);\n    \n    float d2 = f(uv.x) - uv.y + w;\n    d2 = smoothstep(.0, lw, abs(d2));\n    d = min(d2, d);\n    \n    float t = fract(iTime * .1) * 4. - 2.;\n    t = iMouse.z > 0. ? (2. * iMouse.xy - iResolution.xy).x / iResolution.y : t;\n    float dSphere = length(uv - vec2(t, f(t))) - w;\n    float d3 = smoothstep(0., lw, abs(dSphere));\n    d = min(d3, d);\n    \n    \n    kx = uv.x;\n    for( int i = 0; i < 4; i++){\n        float h_x = h(uv.x, kx, w);\n        float dh_x = dh(uv.x, kx);\n        kx = kx - h_x / dh(uv.x, kx); // newton method\n    }\n    float radius = distance(vec2(uv.x, f(uv.x)), vec2(kx, f(kx) + w));\n    \n    float a = atan(df(t));\n    radius = w * cos(a); // analysis drectly\n    float d4 = distance(uv, vec2(t, f(t))) - radius;\n    d4 = smoothstep(0., lw, abs(d4));\n    d = min(d4, d);\n    \n    float dDot = length(uv - vec2(t, f(t))) - lw;\n    float d5 = 1. - step(dDot, 0.);\n    d = min(d5, d);\n    \n    // locus parametric equation\n    vec2 p1 = vec2(t, f(t));\n    vec2 p2 = vec2(p1.x + dFdx(uv.x), f(p1.x + dFdx(uv.x)));\n    vec2 pt = vec2(p2.x - (p2.y - p1.y) / distance(p1, p2) * w, p2.y + (p2.x - p1.x) / distance(p1, p2) * w);\n    float dDot2 = distance(uv, pt) - lw;\n    float d6 = 1. - step(dDot2, 0.);\n    d = min(d6, d);\n    \n    vec3 col = vec3(1. - d);\n\n    if (d == d0 || d == d3){\n        col *= vec3(.7, 0.4, 0.1) * 1.5;\n    }\n    else if(d == d2 || d == d4){\n        col *= vec3(0.1, .5, 0.9) * 1.5;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}