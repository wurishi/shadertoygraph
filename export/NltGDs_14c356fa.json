{"ver":"0.1","info":{"id":"NltGDs","date":"1637052225","viewed":545,"name":"[zznewclear13] Cornell Box MIS","username":"zznewclear13","description":"Cornell box path tracing with:\n1 random sample per pixel,\nnext event estimation (1 random sample towards light),\nrussian roulette,\nggx brdf,\nmultiple importance sampling,\ntemporal accumulation.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing","cornell","ggx","multipleimportancesampling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Post-processing.\n\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 Tonemap_ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    color = Tonemap_ACES(color);\n    color = pow(color, vec3(0.4545));\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//BRDF model comes from https://google.github.io/filament/Filament.html\n\n#define DegToRad 0.01745329252\n#define INFINITY 1e10\n#define EPSILON 0.0001\n\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define SQRT2_2 0.70710678118\n\n#define DEFAULT_REFLECTANCE 0.04\n\n/////////////////////////////////////////\n//             Structures              //\n/////////////////////////////////////////\n\nstruct Camera\n{\n    vec3 position;\n    vec3 target;\n    vec3 upVec;\n    float fovy;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere\n{\n    int materialID;\n\n    vec3 center;\n    float radius;\n};\n\nstruct Quad\n{\n    int materialID;\n    \n    vec3 p;\n    vec3 w;\n    vec3 l;\n};\n\nstruct Intersection\n{\n    vec3 position;\n    vec3 normal;\n};\n\nstruct Material\n{\n    int materialType;\n    vec3 baseColor;\n    float roughness;\n    float metallic;\n};\n\n/////////////////////////////////////////\n//            Ray Tracing              //\n/////////////////////////////////////////\n\n//Random functions\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nRay InitRay(Camera camera, vec2 fragCoord, vec2 resolution)\n{\n    vec3 forward = normalize(camera.target - camera.position);\n    vec3 right = normalize(cross(camera.upVec, forward));\n    vec3 up = cross(forward, right);\n       \n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    vec2 realFragCoord = fragCoord + vec2(randomA, randomB) - 0.5;\n    realFragCoord = realFragCoord * 2.0 - resolution.xy;\n    \n    vec2 uv = tan(camera.fovy * DegToRad * 0.5) * (realFragCoord / resolution.yy);\n    vec3 rayDir = normalize(right * uv.x + up * uv.y + forward);\n    \n    return Ray(camera.position, rayDir);\n}\n\nbool SolveQuadratic(float a, float b, float c, out float x0, out float x1)\n{\n    float discriminant = b * b - 4.0 * a * c;\n    if(discriminant < 0.0){ return false;}\n    \n    float rootDisc = sqrt(discriminant);\n    float q = (b > 0.0) ? -0.5 * (b + rootDisc) : -0.5 * (b - rootDisc);\n    float temp0 = q / a;\n    float temp1 = c / q;\n    if (temp1 > temp0)\n    {\n        x0 = temp0;\n        x1 = temp1;   \n    }\n    else\n    {\n        x0 = temp1;\n        x1 = temp0;\n    }\n    return true;  \n}\n\nbool RayQuadIntersect(Ray ray, Quad quad, out float t, out Intersection intersection)\n{\n    vec3 edge1 = quad.w;\n    vec3 edge2 = quad.l;\n    vec3 h = cross(ray.direction, edge2);\n    float a = dot(edge1, h);\n    if(abs(a) < EPSILON) {return false;}\n    \n    float f = 1.0 / a;\n    vec3 s = ray.origin - quad.p;\n    float u = f * dot(s, h);\n    //I modified this a little bit to ensure there could be an intersection near edges.\n    //original:\n    //if(u < 0.0 || u > 1.0) {return false;}\n    if(u < -EPSILON || u > 1.0 + EPSILON) {return false;}\n    \n    vec3 q = cross(s, edge1);\n    float v = f * dot(ray.direction, q);\n    //origin:\n    //if(v < 0.0 || v > 1.0) {return false;}\n    if(v < -EPSILON || v > 1.0 + EPSILON) {return false;}\n    \n    t = f * dot(edge2, q);\n    if(t < EPSILON) {return false;}\n    \n    intersection.position = ray.origin + t * ray.direction;\n    intersection.normal = normalize(cross(edge1, edge2));\n    return true;\n}\n\nbool RaySphereIntersect(Ray ray, Sphere sphere, out float t, out Intersection intersection)\n{\n    bool hasIntersection = false;\n    \n    float t0, t1;\n    vec3 l = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, l);\n    float c = dot(l, l) - sphere.radius * sphere.radius;\n    if (!SolveQuadratic(a, b, c, t0, t1)) {return false;}\n    \n    if(t1 > 0.0)\n    {\n        t = t1;\n        hasIntersection = true;\n    }\n    \n    if(t0 > 0.0)\n    {\n        t = t0;\n        hasIntersection = true;\n    }\n    \n    intersection.position = ray.origin + t * ray.direction;\n    intersection.normal = normalize(intersection.position - sphere.center);\n    return hasIntersection;\n}\n\nbool LightRay(Quad light, Intersection intersection, int j, int k, float ratio, out Ray lightRay, out vec3 rayTarget)\n{\n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    rayTarget = light.p + light.w * (float(j) + randomA) * ratio + light.l * (float(k) + randomB) * ratio;\n    vec3 lightNormal = cross(light.w, light.l);\n    lightRay.direction = normalize(rayTarget - intersection.position);\n    lightRay.origin = intersection.position + lightRay.direction * 0.01;  \n    \n    bool hasLight = (dot(lightRay.direction, lightNormal) < 0.0);\n    return hasLight;\n}\n\n/////////////////////////////////////////\n//              Sampling               //\n/////////////////////////////////////////\n\nvec3 SampleHemiSphere()\n{\n    float theta = acos(GetRandom());\n    float phi = 2.0 * PI * GetRandom();\n    float sinTheta = sin(theta);\n\n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cos(theta));\n}\n\nvec3 SampleHemiSphereGGX(float roughness)\n{\n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    \n    float theta = acos(sqrt((1.0 - randomA) / ((roughness * roughness - 1.0) * randomA + 1.0)));\n    float phi = 2.0 * PI * randomB;\n    float sinTheta = sin(theta);\n    \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cos(theta));\n}\n\nRay GetRandomRay(vec3 lastRayDir, vec3 position, vec3 normal)\n{\n    Ray ray;\n    \n    vec3 s = SampleHemiSphere();\n    s.z = abs(s.z);\n    \n    vec3 w = normal;\n    vec3 u, v;\n    if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) <= SQRT2_2)\n    {\n        u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n        v = cross(w, u);\n    }\n    else\n    {\n        v = normalize(cross(w, vec3(1.0, 0.0, 0.0)));\n        u = cross(v, w);\n    }\n    ray.direction = s.x * u + s.y * v + s.z * w;\n    ray.origin = position + ray.direction * 0.001;\n    \n    return ray;    \n}\n\nRay GetRandomRay_GGX(vec3 lastRayDir, vec3 position, vec3 normal, float roughness, float t)\n{\n    Ray ray;\n\n    float randomValue = GetRandom();\n\n    vec3 w = normal;\n    vec3 s, u, v;\n\n    if(randomValue < t)\n    {\n        //Sample specular, half vector.\n        s = SampleHemiSphereGGX(roughness);\n    }\n    else\n    {\n        //Sample diffuse, sample vector;\n        s = SampleHemiSphere();\n    }\n    \n    s.z = abs(s.z);\n\n    if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) <= SQRT2_2)\n    {\n        u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n        v = cross(w, u);\n    }\n    else\n    {\n        v = normalize(cross(w, vec3(1.0, 0.0, 0.0)));\n        u = cross(v, w);\n    }\n    \n    if(randomValue < t)\n    {\n        vec3 halfVec = s.x * u + s.y * v + s.z * w;\n        ray.direction = reflect(lastRayDir, halfVec);\n    }\n    else\n    {\n        ray.direction = s.x * u + s.y * v + s.z * w;\n    }\n\n    ray.origin = position + ray.direction * 0.001;\n\n    return ray;\n}\n\nRay GetRandomRay_NEE(Quad light, vec3 position, vec3 normal, out float dist)\n{\n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    vec3 lightTarget = light.p + light.w * randomA + light.l * randomB;\n\n    vec3 lightOrigin = position + 0.001 * normal;\n    vec3 lightDirection = normalize(lightTarget - lightOrigin);\n\n    Ray lightRay = Ray(lightOrigin, lightDirection);\n    dist = length(lightTarget - lightRay.origin);\n    return lightRay;\n}\n\n/////////////////////////////////////////\n//                BRDF                 //\n/////////////////////////////////////////\n\n// Bruce Walter et al. 2007. Microfacet Models for Refraction through Rough Surfaces. Proceedings of the Eurographics Symposium on Rendering.\nfloat D_GGX(float NoH, float roughness) {\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    return k * k * INV_PI;\n}\n\n// Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3 (2).\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n// Christophe Schlick. 1994. An Inexpensive BRDF Model for Physically-Based Rendering. Computer Graphics Forum, 13 (3), 233–246.\nfloat F_Schlick(float LoH, float f0, float f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0) {\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F0(vec3 baseColor, float metallic) {\n    return DEFAULT_REFLECTANCE * (1.0 - metallic) + baseColor * metallic;\n}\n\n// Specular BRDF\nvec3 Fr(float NoV, float NoL, float NoH, float LoH, float roughness, vec3 f0) {\n    float D = D_GGX(NoH, roughness);\n    vec3 F = F_Schlick(LoH, f0);\n    float V = V_SmithGGXCorrelated(NoV, NoL, roughness);\n    return D * F * V;\n}   \n\nfloat Fd_Lambert() {\n    return INV_PI;\n}\n\n// Diffuse BRDF\n// Brent Burley. 2012. Physically Based Shading at Disney. Physically Based Shading in Film and Game Production, ACM SIGGRAPH 2012 Courses.\nfloat Fd_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(NoL, 1.0, f90);\n    float viewScatter = F_Schlick(NoV, 1.0, f90);\n    return lightScatter * viewScatter * INV_PI;\n}\n\nvec3 EvaluateBRDF(vec3 wi, vec3 wo, Material material, vec3 normal)\n{\n    vec3 h = normalize(wi + wo);\n    float NdotV = abs(dot(normal, wo)) + 1e-5;\n    float NdotL = max(dot(normal, wi), 0.0);\n    float NdotH = max(dot(normal, h), 0.0);\n    float LdotH = max(dot(wi, h), 0.0);\n    \n    float roughness = material.roughness * material.roughness;\n    vec3 f0 = F0(material.baseColor, material.metallic);\n    vec3 diffuse = material.baseColor * (1.0 - material.metallic);\n\n    vec3 fr = Fr(NdotV, NdotL, NdotH, LdotH, roughness, f0);    \n    vec3 fd = Fd_Burley(NdotV, NdotL, LdotH, roughness) * diffuse;    \n    \n    return (fr + fd) * NdotL;\n}\n\nvec3 EvaluateBRDF(vec3 wi, vec3 wo, Quad light, float dist, Material material, vec3 normal)\n{\n    vec3 h = normalize(wi + wo);\n    float NdotV = abs(dot(normal, wo)) + 1e-5;\n    float NdotL = max(dot(normal, wi), 0.0);\n    float NdotH = max(dot(normal, h), 0.0);\n    float LdotH = max(dot(wi, h), 0.0);\n    \n    float roughness = material.roughness * material.roughness;\n    vec3 f0 = F0(material.baseColor, material.metallic);\n    vec3 diffuse = material.baseColor * (1.0 - material.metallic);\n    \n    vec3 fr = Fr(NdotV, NdotL, NdotH, LdotH, roughness, f0);\n    vec3 fd = Fd_Burley(NdotV, NdotL, LdotH, roughness) * diffuse;\n    \n    vec3 lightNormal = cross(light.w, light.l);\n    float area = length(lightNormal);\n    lightNormal = normalize(lightNormal);\n    float G = dot(-wi, lightNormal) * NdotL / (dist * dist);\n    G = max(G, 0.0);\n    \n    return (fr + fd) * G * area;\n}\n\n/////////////////////////////////////////\n//               PDFs                  //\n/////////////////////////////////////////\n\nfloat PDF_Lambert(vec3 wi, vec3 normal){\n    return INV_PI * max(dot(normal, wi), 0.0);\n}\n\nfloat PDF_GGX(vec3 wi, vec3 wo, vec3 normal, float roughness)\n{\n    vec3 h = normalize(wi + wo);\n    float NdotH = max(dot(normal, h), 0.0);\n    \n    return D_GGX(NdotH, roughness) * NdotH / (4.0 * max(dot(wo, h), 0.001));\n}\n\nfloat PDF_Quad(Quad light, Ray ray)\n{\n    float t;\n    Intersection intersection;\n\n    bool hasIntersect = RayQuadIntersect(ray, light, t, intersection);\n    if(hasIntersect)\n    {\n        vec3 lightNormal = cross(light.w, light.l);\n        float area = length(lightNormal);\n        lightNormal = normalize(lightNormal);\n        \n        return t * t / (area * abs(dot(lightNormal, -ray.direction)));\n    }\n    else\n    {\n        return 0.0;\n    }    \n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Cornell box path tracing with:\n//    1 random sample per pixel,\n//    next event estimation (1 random sample towards light),\n//    russian roulette,\n//    ggx brdf,\n//    and multiple importance sampling.\n\n//Highly unoptimized path tracing, any advice would be greatly appreciated!\n//Combining triangles to quads saves lots of compiling time!\n//Thanks to spalmer, by replacing `0` with `min(0, iFrame)` in for loops, the compile time is greatly reduced!\n\n#define CUBE_COUNT 1\n#define WALL_COUNT 5\n#define SPHERE_COUNT 1\n#define LIGHT_COUNT 1\n\nQuad lights[LIGHT_COUNT];\nQuad quads[CUBE_COUNT * 6 + WALL_COUNT + LIGHT_COUNT];\nSphere spheres[SPHERE_COUNT];\nMaterial materials[6];\n\n///////////////////////////////////////////////////\n//             Scene Build Functions             //\n///////////////////////////////////////////////////\n\nvoid CubeToQuads(int materialID, vec3 center, vec3 xAxis, vec3 size, inout int offset)\n{\n    vec3 u = normalize(xAxis);\n    vec3 w = normalize(cross(u, vec3(0.0, 1.0, 0.0)));\n    vec3 v = cross(w, u);\n    \n    u *= size.x;\n    v *= size.y;\n    w *= size.z;\n        \n    vec3 p0 = center - (u + v + w) * 0.5;   \n    vec3 p6 = center + (u + v + w) * 0.5;\n    \n    quads[offset    ] = Quad(materialID, p0, u, w);\n    quads[offset + 1] = Quad(materialID, p0, v, u);\n    quads[offset + 2] = Quad(materialID, p0, w, v);\n\n    quads[offset + 3] = Quad(materialID, p6, -w, -u);\n    quads[offset + 4] = Quad(materialID, p6, -u, -v);\n    quads[offset + 5] = Quad(materialID, p6, -v, -w);\n\n    offset += 6;\n}\n\n\nvoid MakeScene()\n{\n    //floor\n    quads[0] = Quad(1, vec3(-6.0, 0.0, -6.0), vec3(0.0, 0.0, 12.0), vec3(12.0, 0.0, 0.0));\n   \n    //ceil\n    quads[1] = Quad(1, vec3(-6.0, 10.0, -6.0), vec3(12.0, 0.0, 0.0), vec3(0.0, 0.0, 12.0));\n \n    //left wall\n    quads[2] = Quad(2, vec3(-6.0, 0.0, -6.0), vec3(0.0, 10.0, 0.0), vec3(0.0, 0.0, 12.0));\n\n    //right wall\n    quads[3] = Quad(3, vec3(6.0, 0.0, -6.0), vec3(0.0, 0.0, 12.0), vec3(0.0, 10.0, 0.0));\n  \n    //back wall\n    quads[4] = Quad(1, vec3(-6.0, 0.0, 6.0), vec3(0.0, 10.0, 0.0), vec3(12.0, 0.0, 0.0));\n  \n    int offset = 5;\n    //cube 6-11\n    CubeToQuads(4, vec3(-2.0, 3.0, 3.0), vec3(1.0, 0.0, 0.5), vec3(4.0, 8.0, 4.0), offset);\n    \n    //sphere\n    spheres[0] = Sphere(5, vec3(2.0, 2.0, 0.0), 2.0);\n    \n    //light 12\n    lights[0] = Quad(0, vec3(-2.0, 9.5, -2.0), vec3(4.0, 0.0, 0.0), vec3(0.0, 0.0, 4.0));\n    quads[11] = lights[0];\n    \n    //materials\n    materials[0] = Material(0, vec3(5.0, 5.0, 5.0), 0.0, 0.0);\n    materials[1] = Material(1, vec3(0.7, 0.7, 0.4), 0.9, 0.0);\n    materials[2] = Material(1, vec3(1.0, 0.0, 0.0), 0.9, 0.0);\n    materials[3] = Material(1, vec3(0.0, 1.0, 0.0), 0.9, 0.0);\n    materials[4] = Material(1, vec3(0.7, 0.7, 0.4), 0.1, 0.7);\n    materials[5] = Material(1, vec3(1.0, 0.64, 0.05), 0.6, 0.9);\n}\n\n///////////////////////////////////////////////////\n//             Scene Related Tracing             //\n///////////////////////////////////////////////////\n\nbool TraceScene(Ray ray, out Intersection intersection, out int materialID)\n{\n    float d = INFINITY;\n    bool hasHit = false;\n    for(int i = min(0, iFrame); i < quads.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RayQuadIntersect(ray, quads[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            hasHit = true;\n            \n            materialID = quads[i].materialID;\n            intersection = tempIntersection;\n        }\n    }\n    \n    for(int i = min(0, iFrame); i < spheres.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RaySphereIntersect(ray, spheres[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            hasHit = true;\n            \n            materialID = spheres[i].materialID;\n            intersection = tempIntersection;\n        }\n    }\n\n    return hasHit;\n}\n\nbool TraceLight(Ray ray, int lightMaterialID)\n{\n    float d = INFINITY;\n    int materialID = -1;\n    for(int i = min(0, iFrame); i < quads.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RayQuadIntersect(ray, quads[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            \n            materialID = quads[i].materialID;\n        }\n    }\n    \n    for(int i = min(0, iFrame); i < spheres.length(); i++)\n    {\n        float t;\n        Intersection tempIntersection;\n        bool isHit = RaySphereIntersect(ray, spheres[i], t, tempIntersection);\n        if(isHit && t < d)\n        {\n            d = t;\n            \n            materialID = spheres[i].materialID;\n        }\n    }\n\n    return materialID == lightMaterialID;\n}\n\n///////////////////////////////////////////////////\n//             Scene Related PDFs                //\n///////////////////////////////////////////////////\n\nfloat PDF_NEE(Ray ray)\n{\n    float pdfNEE = 0.0;\n    for (int i = min(0, iFrame); i < lights.length(); i++)\n    {\n        float pdfLight = PDF_Quad(lights[i], ray);\n        pdfNEE += pdfLight;\n    }\n    return pdfNEE / float(lights.length());\n}\n\nfloat PDF_BRDF(vec3 wi, vec3 wo, vec3 normal, float roughness, float t)\n{\n    return (1.0 - t) * PDF_Lambert(wi, normal) + t * PDF_GGX(wi, wo, normal, roughness);\n}\n\nvoid WeightPDF(Ray ray, vec3 wo, vec3 normal, float roughness, float t, out float weightNEE, out float weightBRDF)\n{\n    float pdfNEE = PDF_NEE(ray);\n    float pdfBRDF = PDF_BRDF(ray.direction, wo, normal, roughness, t);\n    \n    float squareSum = pdfNEE * pdfNEE + pdfBRDF * pdfBRDF;\n    if(squareSum == 0.0)\n    {\n        weightNEE = 1.0;\n        weightBRDF = 0.0;\n    }\n    else\n    {\n        weightNEE = pdfNEE / squareSum;\n        weightBRDF = pdfBRDF / squareSum;\n    }\n}\n\n///////////////////////////////////////////////////\n//                Main Function                  //\n///////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    \n    seed = hash12(fragCoord) + iTime;\n    float randomValue = GetRandom();\n\n    Camera camera = Camera(vec3(0.0, 4.0, -12.0), vec3(0.0, 4.0, 0.0), vec3(0.0, 1.0, 0.0), 45.0);\n    \n    Ray ray = InitRay(camera, fragCoord, iResolution.xy);\n    MakeScene();\n    \n    Intersection intersection;\n    int materialID;\n    bool isHit = TraceScene(ray, intersection, materialID);\n    if(isHit)\n    {\n        int depth = 1;\n        Material material = materials[materialID];\n                \n        if(material.materialType == 0)\n        {\n            //Hit light directly.\n            color = material.baseColor;\n        }\n        else\n        {\n            vec3 lastBRDF = vec3(1.0);\n            \n            bool terminateRay = false;\n            while(!terminateRay)\n            {\n                vec3 lastRayDir = ray.direction;\n                float roughness = material.roughness * material.roughness;\n                \n                vec3 F0 = F0(material.baseColor, material.metallic);\n                vec3 diffuse = material.baseColor * (1.0 - material.metallic);\n                float F0Sum = F0.x + F0.y + F0.z;\n                float diffuseSum = diffuse.x + diffuse.y + diffuse.z;\n                float t = max(F0Sum / (diffuseSum + F0Sum), 0.25);\n            \n                //Next event estimation for directional light.\n                vec3 directBRDF = vec3(0.0);\n                \n                for (int i = 0; i < lights.length(); i++)\n                {\n                    float dist;\n                    Ray lightRay = GetRandomRay_NEE(lights[i], intersection.position, intersection.normal, dist);\n                     \n                    float weightNEE, weightIndirect;\n                    WeightPDF(lightRay, -lastRayDir, intersection.normal, roughness, t, weightNEE, weightIndirect);\n\n                    vec3 lightNormal = cross(lights[i].w, lights[i].l);\n                    float LNdotL = dot(lightNormal, -lightRay.direction);\n                    \n                    int lightMaterialID = lights[i].materialID;\n                    if(LNdotL > 0.0)\n                    {\n                        bool isShaded = TraceLight(lightRay, lightMaterialID);\n                        if(isShaded)\n                        {    \n                            directBRDF += EvaluateBRDF(lightRay.direction, -lastRayDir, material, intersection.normal)\n                                          * materials[lightMaterialID].baseColor * weightNEE;\n                        }                    \n                    }\n                }\n                \n                color += lastBRDF * directBRDF;\n                \n                //GGX importance sampling for indirectional light.\n                vec3 indirectBRDF = vec3(0.0);\n                \n                //Russian roulette\n                float randomA = GetRandom();\n                float probability = 1.0 - min(max(max(lastBRDF.r, lastBRDF.g), lastBRDF.b), 1.0);\n                if(randomA >= probability)\n                {\n                    //GGX importance sampling new ray.\n                    ray = GetRandomRay_GGX(lastRayDir, intersection.position, intersection.normal, roughness, t);\n                    float weightNEE, weightIndirect;\n                    WeightPDF(ray, -lastRayDir, intersection.normal, roughness, t, weightNEE, weightIndirect);\n                    \n                    Intersection ggxIntersection;\n                    int ggxMaterialID;\n                    bool ggxHit = TraceScene(ray, ggxIntersection, ggxMaterialID);\n                    if(ggxHit)\n                    {\n                        Material ggxMaterial = materials[ggxMaterialID];\n                        indirectBRDF = EvaluateBRDF(ray.direction, -lastRayDir, material, intersection.normal) / (1.0 - probability);\n                        lastBRDF *= indirectBRDF * weightIndirect;\n\n                        if(ggxMaterial.materialType == 0)\n                        {\n                            //Reached light, terminate ray.\n                            float frontLight = dot(ray.direction, ggxIntersection.normal) < 0.0 ? 1.0 : 0.0;\n                            color += lastBRDF * ggxMaterial.baseColor * frontLight;\n                            terminateRay = true;\n                        }\n                        else\n                        {\n                            //Start a new iteration.\n                            intersection = ggxIntersection;\n                            materialID = ggxMaterialID;\n                            material = ggxMaterial;\n                            depth ++;\n                        }\n                    }\n                    else\n                    {\n                        //GGX importance sampling missed, terminate ray.\n                        terminateRay = true;\n                    }\n                }\n                else\n                {\n                    //Russian roulette failed, terminate ray.\n                    terminateRay = true;\n                }\n            } \n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Accumulate history colors.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if(iFrame == 0)\n    {\n        fragColor = color; return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 bufferA = texture(iChannel0, uv).rgb;\n    vec4 bufferB = texture(iChannel1, uv);\n    \n    if(iMouse.z > 0.0)\n    {\n        fragColor = vec4(bufferA, 1.0);\n    }\n    else\n    {\n        bufferB.a += 1.0;\n        color.rgb = mix(bufferB.rgb, bufferA, 1.0 / bufferB.a);\n        fragColor = vec4(color.rgb, bufferB.a);\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}