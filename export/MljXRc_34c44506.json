{"ver":"0.1","info":{"id":"MljXRc","date":"1445595167","viewed":255,"name":"Raymarched Union","username":"jackdavenport","description":"An example of how raymarching can be used to create blendshapes and boolean functions effortlessly. Based on this article by iq: https://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","liquid","gel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_ITERATIONS 64\n#define MIN_DISTANCE  .01\n\nstruct Ray {\n\tvec3 ori;\n\tvec3 dir;\n};\nstruct Dist {\n\tfloat dist;\n    int id;\n};\nstruct Hit {\n\tvec3 p;\n    Dist dist;\n};\n\nfloat distSphere(vec3 p, vec3 pos, float radius) {\n\n    return length(pos - p) - radius;\n    \n}\n\nfloat distBox(vec3 p, vec3 pos, vec3 r) {\n \n    return length(max(abs(pos - p)-r, 0.));\n    \n}\n\n// Thanks iq! Again..\n// Source: https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat distBall(vec3 p, vec3 pos, float radius) {\n \n    float sph1 = distSphere(p, pos + vec3(0.,0.,.5), radius + .4);\n    float sph2 = distSphere(p, pos + vec3(.3,0.,0.),  radius\t   );\n    \n    return max(-sph2,sph1);\n    \n}\n\nDist distToScene(vec3 p) {\n \n    float s    = sin(iTime);\n    float c    = cos(iTime);\n    vec3  bp   = vec3(0.,0.,2.3) + (vec3(c,s,0.)*vec3(.6));\n    \n    float ball = distBall(p, vec3(0.,0.,2.), .2);\n    float box  = distBox (p, bp, vec3(.3));\n    \n    return Dist(smin(ball, box, 32.), 0);\n    \n}\n    \nHit raymarch(Ray ray) {\n \n    vec3 p = ray.ori;\n    float t = 0.;\n    int id = -1;\n    \n    for(int i = 0; i < MAX_ITERATIONS; i++) {\n     \n        Dist d = distToScene(p);\n        p += ray.ori + (ray.dir * d.dist);\n        \n        if(d.dist <= MIN_DISTANCE) {\n         \n            t = d.dist;\n            id = d.id;\n            \n            break;\n            \n        }\n        \n    }\n    \n    return Hit(p,Dist(t,id));\n    \n}\n\nvec3 normal(vec3 p) {\n \n    const float d = .001;\n    \n    vec3 left = vec3(p.x - d,p.yz);\n    vec3 right = vec3(p.x + d,p.yz);\n    vec3 up = vec3(p.x,p.y-d,p.z);\n    vec3 down = vec3(p.x,p.y+d,p.z);\n    vec3 front = vec3(p.xy,p.z-d);\n    vec3 back = vec3(p.xy,p.z+d);\n    \n    float distLeft = distToScene(left).dist;\n    float distRight = distToScene(right).dist;\n    float distUp = distToScene(up).dist;\n    float distDown = distToScene(down).dist;\n    float distFront = distToScene(front).dist;\n    float distBack = distToScene(back).dist;\n    \n    return normalize(vec3(distRight-distLeft,distDown-distUp,distBack-distFront));\n    \n}\n\nvec4 shade(Ray ray) {\n \n    Hit scene = raymarch(ray);\n    \n    if(scene.dist.id == 0) {\n\n        vec3 n  = normal(scene.p);\n        vec3 rd = reflect(ray.dir, n);\n        \n        return texture(iChannel0, rd);\n        \n    }\n    \n    return texture(iChannel0, ray.dir);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - iResolution.xy / 2.) / iResolution.y;\n\t\n    vec3 ori = vec3(0.,0.,0.);\n    vec3 dir = vec3(uv, .6);\n    \n    fragColor = shade(Ray(ori,dir));\n}","name":"","description":"","type":"image"}]}