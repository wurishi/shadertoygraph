{"ver":"0.1","info":{"id":"ftfSW8","date":"1625520344","viewed":65,"name":"Pixel Matcher","username":"okiyama","description":"Based off https://www.shadertoy.com/view/4lGBRy which is based off my code, https://github.com/okiyama/pixel-matcher","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash( float n ) {\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0-2.0*f);\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\treturn mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t   mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nvec3 getMax(float threshold, vec3 x, vec3 a, vec3 b, vec3 c) {\n    // calculate pixel distances\n    float xa = length(x - a);   \n    float xb = length(x - b);\n    float xc = length(x - c);\n    //float xd = length(x - d);\n    \n    float value = max(max(xa, xb), xc);\n    \n    // choose which pixel to return\n    if (xa < threshold && value == xa) return a;\n    if (xb < threshold && value == xb) return b;\n    if (xc < threshold && value == xc) return c;    \n    //if (xd < threshold && value == xd) return d;\n    \n    // return the original pixel\n    return x;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float threshold = iTime * 0.1;\n    vec2 amount = iMouse.xy/iResolution.xy;\n    \n    amount.y *= 1.7; // sqrt(3)\n\n    // source texture\n    vec3 parent = texture(iChannel0, uv).xyz;\n    \n    // distort the UV\n    //float dTime = iTime * 0.2;\n    //vec2 scale = vec2(sin(5.*uv.x+dTime), sin(5.*uv.y+dTime));\n    //vec2 uvb = sin(uv * (1.0 + .25*scale) + .1*scale);\n    \n    // corruption textures\n    vec3 A = texture(iChannel1, uv).xyz;\n    vec3 B = texture(iChannel2, uv).xyz;\n    vec3 C = texture(iChannel3, uv).xyz;\n    \n    // calculate the pixel value\n    vec3 final = getMax(threshold, parent, A, B, C);\n    \n    // interpolate\n    vec3 color = mix(parent, final, threshold);\n    // add\n    //vec3 color = parent + final * threshold;\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}