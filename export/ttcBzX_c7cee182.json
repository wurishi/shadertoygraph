{"ver":"0.1","info":{"id":"ttcBzX","date":"1613152873","viewed":146,"name":"Audio spectrum split","username":"Patate1er","description":"Just a very simple template to pick frequency range with fft.\nI'm trying to convert my kodelife shader using this kind of fonctionality","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sound","fft","visualization","reactive","music","audio","audiospectrum"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ranges to split\nvec2[3] spec_split = vec2[3](vec2(0.0,0.3),\n                             vec2(0.3,0.7),\n                             vec2(0.7,1.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 spectrum = texelFetch( iChannel0, ivec2(iResolution.x-1.,iResolution.y-1.), 0 ).xyz;\n    \n    //spectrum display\n    vec3 col = vec3(0.0);\n    if(uv.x>=spec_split[0][0] && uv.x<=spec_split[0][1]){\n      col = vec3(1.0-step(spectrum.x,uv.y));\n    }\n    else if(uv.x>=spec_split[1][0] && uv.x<=spec_split[1][1]){\n      col = vec3(1.0-step(spectrum.y,uv.y));\n    }\n    else if(uv.x>=spec_split[2][0] && uv.x<=spec_split[2][1]){\n      col = vec3(1.0-step(spectrum.z,uv.y));\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ranges to split\nvec2[3] spec_split = vec2[3](vec2(0.0,0.3),\n                             vec2(0.3,0.7),\n                             vec2(0.7,1.0));\nint steps = 1;//possibility to skip values for performance if steps > 1\n\n// return 1 value at the time\nfloat spectrum(vec2 spec_split, int steps){\n    float ret = 0.0;\n    int splitStart = int(floor(spec_split.x*512.0));\n    int splitEnd = int(floor(spec_split.y*512.0));\n    for(int i = splitStart; i<=splitEnd;i+=steps){\n        // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n        float fft  = texelFetch( iChannel0, ivec2(i,0), 0 ).x;\n        ret+=fft;\n    }\n    if(splitStart!=splitEnd){\n        ret/=floor(float((splitEnd-splitStart)/steps));\n    }\n    return ret;\n}\n\n//return 3 values\nvec3 spectrum(vec2[3] spec_split, int steps){\n    vec3 ret = vec3(0);\n    for(int i = 0; i<3; ++i){\n        ret[i] = spectrum(spec_split[i], steps);\n    }\n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ceil(fragCoord.x) == iResolution.x && ceil(fragCoord.y) == iResolution.y){//only on last texel\n        fragColor.rgb = spectrum(spec_split,steps);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}