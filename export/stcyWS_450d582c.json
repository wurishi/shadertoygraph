{"ver":"0.1","info":{"id":"stcyWS","date":"1660426606","viewed":108,"name":"Truchet tiling - Animated","username":"revanw","description":"A quick test on Truchet tiling loosely based on the Art of Code tutorial.\n\nAdding some movements on the fly.\n\nTwo overlapping tilings, moving in sync with a phase that kind of jumps from 0 to pi while spending some more time at those phases.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tilingtruchet2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ANIM 1.\n#define PI 3.1415921\n#define Rf 3.\n\nfloat hash21(vec2 p) {\n    p = fract( p * vec2(123.1561, 161.156));\n    p += dot(p, p + 156.16);\n    return fract(p.x * p.y);\n}\n\nvec2 rot2(vec2 v, float a, float k) {\n    float s = sign(cos(a));\n    return vec2(s*pow(abs(cos(a)), 1./k) * v.x + pow(sin(a), k) * v.y, \n                -s*pow(abs(cos(a)), 1./k) * v.y + pow(sin(a), k) * v.x);\n}\n\nvec4 truchet(vec2 p, vec3 c, float t) {\n    vec3 col = vec3(0.);\n    vec2 id = floor(p);\n    float d = 0.;\n    \n    p = fract(p) - 0.5;\n    \n    // Flip\n    vec4 no_base = texture(iChannel0, vec3( id/20. + hash21(c.xy), 0.00 )  );\n    vec4 no_t = texture(iChannel0, vec3( id/20. + hash21(c.xy) + 51.015, 0.005*floor(t) )  );\n    if (no_base.x > 0.5) p.x = -p.x;    \n    \n    // Grid\n    //col += vec3(no); // color noise bg\n    //col += p.y > 0.49 || p.x > 0.49 ? 1.0 : 0.;\n    \n    //vec2 ns = rot2(vec2(1.), 0.0001*2.*PI*no.x * t);\n    //vec2 center = rot2(vec2(.5,.5), 0.0001*2.*PI*no.x * t);\n    float move = no_t.x < 0.2? 1.0 : 0.0;\n    vec2 ns = rot2(vec2(1.), move * (t *(0.5+0.5*no_t.y)), Rf);\n    vec2 center = rot2(vec2(.5,.5), move * (t *(0.5+0.5*no_t.y)), Rf);\n    \n    //float l = smoothstep(0.05, 0.01, abs(dot(rot2(vec2(ns.x, -ns.y), t, 5.), p)));\n    //col += vec3(l, 0., 0.);\n    \n    float s = dot(ns, p) > 0. ? 1.0 : -1.0;\n    \n    p -= s * center; // move circle center and duplicate in each half\n    float w =  0.5;\n    float blur = 0.03;\n    float cd = length(p);\n    cd = 1. - smoothstep(-blur, blur, abs(cd - w)-0.05);\n    \n    col += vec3(cd) * c;\n    \n    return vec4(col, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    uv *= 7.;\n    \n    vec4 t1 = truchet(uv, vec3(0.51, 0.01, 0.40), iTime*0.92);\n    vec4 t2 = truchet(uv - 0.5, vec3(0.48, 0.21, 0.10), iTime*0.92);\n\n    vec3 col = t1.rgb;\n    col += t2.rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}