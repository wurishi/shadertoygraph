{"ver":"0.1","info":{"id":"MlGcWc","date":"1538501496","viewed":402,"name":"Path Tracing the Enterprise","username":"noxbuds","description":"Rendering the main character of Star Trek with path tracing. WASD to move, space/shift to go up/down, move mouse to look around","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["3d","ray","sdf","star","trace","path","enterprise","trek"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Attempting to raymarch the USS Enterprise   //\n//  (the Constitution-class variant as seen in  //\n//  the recent Star Trek movies)                //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Bloom and a bit of anti-aliasing in reflections\n// and stuff. Comment out to disable it.\n#define BLOOM\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Burgess tonemapping - looks fairly bright/cheerful, has quite\n// a bit of contrast aswell\nvec3 burgess(vec3 col)\n{\n    vec3 maxCol = max(vec3(0.0), col - 0.004);\n    vec3 retCol = (maxCol * (6.2 * maxCol + 0.05)) / (maxCol * (6.2 * maxCol + 2.3) + 0.06);\n    return pow(retCol, vec3(1.0 / 2.2));\n}\n\n// Final composition\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Shift the co-ordinates to -1 <= x <= 1\n    // and correct the aspect ratio\n    //uv = uv * 2.0 - 1.0;\n    //uv.x *= iResolution.x / iResolution.y;\n\n    // Setup colour\n    vec3 col = vec3(0.0);\n    \n    // Grab colour from Buf A\n    col = texture(iChannel0, uv).rgb / texture(iChannel0, uv).w;\n    \n    #ifdef BLOOM\n    // Add some bloom\n    for (float xOff = -10.0; xOff <= 10.0; xOff++)\n    {\n        for (float yOff = -10.0; yOff <= 10.0; yOff++)\n        {\n            // Distance multiplier\n            float falloff = min(0.1 / length(vec2(xOff, yOff)), 1.0);\n            \n            // Get colour\n            vec4 ncol = texture(iChannel0, (fragCoord + vec2(xOff, yOff)) / iResolution.xy);\n            \n            ncol.rgb /= ncol.a;\n            ncol.rgb = min(ncol.rgb, vec3(1.0));\n            \n            float bright = ncol.r * 0.2126 + ncol.g * 0.7152 + ncol.b * 0.0722;\n            \n            // Check if it's the bloom colour\n            col = mix(col, ncol.rgb, (falloff * 0.15) * pow(bright, 2.0));\n        }\n    }\n    #endif\n    \n    // Tonemapping to make the scene look better\n    col = pow(col, vec3(2.2));\n    col = burgess(col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Attempting to pathtrace the USS Enterprise  //\n//  (the Constitution-class variant as seen in  //\n//  the recent Star Trek movies)                //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//                 CONSTANTS                   //\n//                                             //\n/////////////////////////////////////////////////\n\n// Numbers\n#define PI 3.142\n#define BIG_NUMBER 1e6\n#define EPS 1e-5\n#define MAX_DEPTH 4\n#define SUN_STRENGTH 40.0\n\n// Number of samples. Set to 1 SPP per default. Increase\n// this is if you have a really good GPU :P\n#define SAMPLES 1.0\n\n// Saturn stuff\n#define SATURN_SIZE 5000.0\n#define SATURN_POS vec3(6000.0, 2000.0, 4000.0)\n\n// Macros\n#define bright(c) (c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722)\n\n// Directional light direction (should probably\n// use area/point lights but whatever)\n//vec3 lightDir = normalize(vec3(0.0, -0.2, -0.5));\nvec3 lightDir = normalize(vec3(0.2, -0.1, -0.2));\n\n// Gas cloud cover (titan's atmosphere?)\nvec3 gasColour = vec3(0.9, 0.4, 0.05);\n\n// Interior light colour\nvec3 intLightCol = vec3(0.9, 0.9, 1.0);\n\n// Raymarching things\n#define RAY_STEPS 400\n#define RAY_MAX_DIST 30.0\n\n// Disables noise reduction\n//#define NOISY\n\n// Fake AA\n#define FAKE_AA\n\n/////////////////////////////////////////////////\n//                                             //\n//              NOISE GENERATION               //\n//                                             //\n/////////////////////////////////////////////////\n\n// 1D value noise\nfloat noisev(float p)\n{\n    return fract(sin(p * 1234.0) * 5647.0);\n}\n\n// 2D value noise\nfloat noisev(vec2 p)\n{\n    return fract(sin(p.x * 1234.0 + p.y * 2413.0) * 5647.0);\n}\n\n// Smoother noise\nfloat noise(vec2 uv)\n{\n    // Noise vector\n    vec2 nv = vec2(0.0);\n    \n    // Local positions\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    // Interpolate lv\n    lv = lv * lv * (3.0 - 2.0 * lv);\n    \n    // Calculate each corner\n    float bl = noisev(id);\n    float br = noisev(id + vec2(1, 0));\n    float tl = noisev(id + vec2(0, 1));\n    float tr = noisev(id + vec2(1, 1));\n    \n    // Interpolate values\n    float b = mix(bl, br, lv.x);\n    float t = mix(tl, tr, lv.x);\n    float n = mix(b, t, lv.y);\n    \n    // Return n\n    return n;\n}\n\n// FBM function\nfloat fbm(vec2 p)\n{\n    float f = 0.0;\n    f += 0.5000 * noise(p); p *= 2.01;\n    f += 0.2500 * noise(p+vec2(0.0, 1.0)); p *= 2.02;\n    f += 0.1250 * noise(p+vec2(1.0, 0.0)); p *= 2.03;\n    f += 0.0625 * noise(p+vec2(1.0, 1.0)); p *= 2.04;\n    f /= 0.9375;\n    return f;\n}\n\n// Random 3D vector function\nvec3 R3D(vec3 p)\n{\n    vec3 a = fract(p.xyx * vec3(123.34, 234.34, 345.65));\n    a += dot(a, a + 34.45);\n    return fract(vec3(a.x * a.y, a.y * a.z, a.x * a.z));\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//             DISTANCE FUNCTIONS              //\n//                                             //\n/////////////////////////////////////////////////\n\n// Max function for 3d vectors\nfloat max3(vec3 v)\n{\n    return max(max(v.x, v.y), v.z);\n}\n\n// Smooth length function for vec2\nfloat slength(vec2 v, float n)\n{\n    return pow(v.x * v.y + v.y * v.y, 1.0 / n);\n}\n\n// Smooth length function for vec3\nfloat slength(vec3 v, float n)\n{\n    return pow(v.x * v.x + v.y * v.y + v.z * v.z, 1.0 / n);\n}\n\n// Renders a sphere\n// p = position in 3d space\n// r = radius of sphere\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n// Renders a box\n// p = position, dim = dimensions\nfloat sdBox(vec3 p, vec3 dim)\n{\n    vec3 d = abs(p) - dim;\n    return length(max(d, 0.0)) + max3(min(d, 0.0));\n}\n\n// Normal cylinder\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n// Smooth-edge cylinder - base formula was made\n// by iq (https://iquilezles.org/articles/distfunctions),\n// this is a version which was modified to use a\n// different length function\nfloat sdSCylinder(vec3 p, vec2 h, float s)\n{\n    vec2 d = abs(vec2(length(p.xz), p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - s;\n}\n\n// Smooth minimum by iq\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n// Combines two objects\nvec2 combine(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    else\n        return b;\n}\n\n// Smoothly combines two objects\nvec2 scombine(vec2 a, vec2 b, float s)\n{\n    // Take the minimum\n    float n = smin(a.x, b.x, s);\n    \n    // Decide, based on the boundary, which\n    // ID to use\n    if (a.x < b.x)\n        return vec2(n, a.y);\n    else\n        return vec2(n, b.y);\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              SCENE CREATION                 //\n//                                             //\n/////////////////////////////////////////////////\n\n// Map function\nvec2 map(vec3 p)\n{\n    // v is the hit data\n    vec2 v;\n    \n    // Create a backup of p\n    vec3 bkp = p;\n    \n    /////////////////////////////\n    // The main saucer section //\n    /////////////////////////////\n    \n    // Before creating a cylinder, deform p to\n    // create a shape closer to the saucer of\n    // the Constitution-class\n    \n    // Create a top part\n    float saucerTop = sdCylinder(p, vec2(2.0, 0.2));\n    p.x *= p.z * 0.1 + 0.7;\n    p.y *= p.z * 0.2 + 0.7;\n    saucerTop = smin(saucerTop, sdCylinder((p + vec3(0.0, 0.0, -3.3)).xzy, vec2(0.3, 2.1)), 0.5);\n    \n    // Reset p and carry on with the top part\n    p = bkp;\n    saucerTop = smin(saucerTop, sdCylinder(p, vec2(0.8, 0.5)), 0.5);\n    \n    // Make the top slightly wider than the bottom\n    p = bkp;\n    p.xz *= 1.0 - p.y * 0.05;\n    \n    // Create the main saucer section and add it on\n    float saucer = sdSCylinder(p, vec2(6.0, 0.2), 0.03);\n    saucer = smin(saucerTop, saucer * 2.0 - 0.1, 0.9);\n    \n    // Add the saucer section in as ID 1\n    v = vec2(saucer, 1);\n    \n    /////////////////////////////\n    // The 'neck' (?)          //\n\t/////////////////////////////\n    \n    // This can roughly be simplified to a box which\n    // has been warped on the z-axis near the bottom\n    p = bkp;\n    \n    // Warp the z-axis\n    p.z += 0.8;\n    p.z *= -0.7;\n    p.z *= 1.2 / (1.0 + pow(p.y, 2.0) * 0.3);\n    p.z += 3.0;\n    \n    // Draw a box\n    float neck = sdBox(p + vec3(0.0, 0.9, -0.5), vec3(0.2, 0.9, 1.0));\n    \n    // Add it in as ID 2\n    v = scombine(v, vec2(neck - 0.3, 2), 0.9);\n    \n    /////////////////////////////\n    // The engineering hull    //\n    /////////////////////////////\n    \n    // This can be done using a cylinder which is warped\n    p = bkp;\n    \n    // Sort of a smooth maximum I guess; we need a smooth\n    // transition between the front and back. Multiplying by\n    // p.z here gives us a nice curve to recreate the shape\n    // of the engineering hull on the Constitution class.\n    p.y *= smin(12.0 - p.z * 2.0, 1.0, 0.5) * -0.02 + 1.06;\n    \n    // Now we multiply the x-axis by the z-axis in order to\n    // make the middle bulge out more\n    p.x *= abs(pow(p.z - 4.0, 2.0)) * 0.01 + 0.99;\n    \n    // Draw a cylinder\n    float body = sdCylinder((p + vec3(0.0, 3.3, -7.1)).xzy, vec2(0.8, 6.0));\n    \n    // Add it in as ID 3\n    v = scombine(v, vec2(body - 0.4, 3), 0.5);\n    \n    /////////////////////////////\n    // Deflector dish          //\n    /////////////////////////////\n    p = bkp;\n    \n    // Curve the dish\n    p.y += 3.25;\n    p.z += length(p.xy) * 0.2;\n    p.y -= 3.25;\n    \n    // Create the deflector dish\n    float dish = sdCylinder((p + vec3(0.0, 3.25, -0.8)).xzy, vec2(1.3, 0.05));\n    \n    // Add it in as ID 4\n    v = combine(v, vec2(dish, 4) );//, 0.5);\n    \n    /////////////////////////////\n    // Engine nacelles         //\n    /////////////////////////////\n    p = bkp;\n    \n    // For the nacelles, we can mirror the shape in the\n    // z-axis so that we don't try and calculate both\n    // nacelles at once.\n    p.x = abs(p.x);\n    vec3 abkp = p; // Backup of the mirrored p (might use for nacelle details)\n    \n    // Make a slight gradient - the rear should be thinner\n    float nwidth = 1.0 - p.z * 0.03;\n    \n    // The nacelles are shorter near the bottom\n    float hmult = p.y * 0.1 + 0.9;\n    \n    // Warp the height a bit\n    p.y *= abs(pow(p.z - 11.0, 2.0)) * 0.005 + 0.995;\n    \n    // First do the nacelles so we know where to place the connectors.\n    // We can once again use warped cylinders.\n    float nacelle = sdCylinder((p - vec3(3.0, 1.0, 14.5)).xzy, vec2(1.0 * nwidth, 6.0 * hmult));\n    \n    // Add in the nacelle as ID 5\n    v = combine(v, vec2(nacelle - 0.4, 5));\n    \n    // In addition, there are spheres on the front which glow\n    p = abkp;\n    \n    // Just a plain sphere\n    float glowsphere = sdSphere(p - vec3(3.0, 0.95, 8.5), 1.1);\n    float glowsphere2 = sdSphere(p - vec3(3.0, 0.7, 20.5), 0.4);\n    glowsphere = min(glowsphere, glowsphere2);\n    \n    // Add it in as ID 6\n    v = combine(v, vec2(glowsphere, 6));\n    \n    /////////////////////////////\n    // Nacelle pylons          //\n    /////////////////////////////\n    p = abkp;\n    \n    // Remember that the pylons are wider at the bottom\n    float pwmult = 0.5 + p.y * p.y * 0.3;\n    \n    // Rotate the pylons correctly\n    p.y -= p.z * 0.025;\n    float rot = 0.22 * PI;\n    p.xy *= mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    \n    // Calculate the pylons\n    float pylon = sdBox(p - vec3(2.0, 0.0, 10.0), vec3(0.01, 2.5, 0.8 * pwmult));\n    \n    // Add them in as ID 7\n    v = scombine(v, vec2(pylon - 0.1, 7), 0.5);\n    \n    // Return v\n    return v;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              LIGHTING/SHADING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Calculate the normal of a point\nvec3 calcNormal(vec3 p)\n{\n    vec2 eps = vec2(0.002, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy).x - map(p - eps.xyy).x,\n        map(p + eps.yxy).x - map(p - eps.yxy).x,\n        map(p + eps.yyx).x - map(p - eps.yyx).x\n    ));\n}\n\n// Cuboid UV mapping\nvec2 cuboidUV(vec3 p, vec3 n)\n{\n    // Setup UV co-ordinates\n    vec2 uv = vec2(0.0);\n    \n    // Since this is just used for cuboids, we can just take\n    // two components of p based on the normal's direction,\n    // seeing as the normal will only be like (0,1,0) or (1,0,0)\n    if (abs(n.x) > 0.9)\n        uv = p.yz;\n    if (abs(n.y) > 0.9)\n        uv = p.xz;\n    if (abs(n.z) > 0.9)\n        uv = p.xy;\n    \n    // Return UV\n    return uv;\n}\n\n// Stores data about a surface at a pixel\nstruct SurfFrag\n{\n    vec3 surface;\n    vec3 emission;\n    float roughness;\n    float ior;\n};\n\n// Returns a surface fragment for a pixel\nSurfFrag surface(int id, vec3 p, vec3 n)\n{\n    // ID 1 is the table and chair\n    // Here the goal is for a polished stone effect\n    // (looks rocky, but is smooth and reflective)\n    if (id == 1)\n    {\n        // This is the main saucer shader. This will\n        // have a few different components so that we\n        // can have the ship's saucer section done in\n        // a single distance function.\n        float roughness = 0.02;\n        \n        // Setup colour\n        vec3 col = vec3(0.6);\n        vec3 emission = vec3(0.0);\n        \n        // UV co-ordinates\n        vec2 uv = vec2(0.0);\n        \n        // Windows on the edges\n        if (abs(n.y) < 0.3)\n        {\n            // Calculate the theta component of\n            // the polar co-ordinates of (p.x, p.z)\n            float angle = atan(p.x, p.z);\n            \n            // Wrap the angle around\n            float modv = 1.0 / 40.0;\n            float c = (angle - mod(angle, modv)) / modv;\n            angle = mod(angle, modv) * 2.0;\n            \n            // Wrap y around twice (we have two floors)\n            float py = mod(p.y * 0.2, 1.0);\n            \n            // Calculate some noise\n            float nv = noise(vec2(c, py));\n            \n            // If the noise is above a threshold, draw\n            // a lit window. Otherwise draw a darker area\n            if (nv > 0.6)\n            {\n                // Lit window\n                \n                // Conditions for displaying a window;\n                // whether angle and py are within bounds\n                bool xcond = angle < modv * 1.5;\n                bool ycond1 = py > 0.02 && py < 0.03;\n                bool ycond2 = p.y < -0.05 && p.y > -0.10;\n                \n                // Display window if necessary\n                if (xcond && (ycond1 || ycond2))\n                {\n                    emission = intLightCol;\n                }\n            }\n            \n            // If we aren't drawing lights or the grey lines,\n            // then we are drawing metal, so it must be reflective\n            roughness = 0.01;\n        }\n        \n        // Create the grey lines that separate the decks here\n        if (p.y > 0.0 && p.y < 0.06 ||\n            p.y > -0.22 && p.y < -0.15 ||\n            p.y > 0.18 && p.y < 0.25)\n        {\n            roughness = 0.4;\n            col = vec3(0.2);\n        }\n        \n        // Top and bottom sections\n        if (abs(n.y) > 0.95)\n        {\n            // Calculate UV co-ords (they are just polar co-ords)\n            uv = vec2(atan(p.x, p.z), length(p.xz));\n            \n            // Create a checker effect to make it look like\n            // it's made of different parts. Restrict this to\n            // outer parts\n            vec2 uvs = vec2(uv.x * 4.0, uv.y);\n            vec2 c = uvs - mod(uvs, vec2(0.6));\n            \n            // Only create plate effect after a radius\n            if (c.y > 1.0)\n            {\n                // Create 'pixellated' noise here\n            \tfloat nv = fbm(c * 1.5);\n            \tcol = mix(col, col * 1.2, nv);\n                roughness = mix(0.0, 0.2, nv);\n                \n                // Draw the registry number (NCC-1701)\n                \n                // Invert uv.y on the bottom\n                if (p.y < 0.0)\n                {\n                    uv.y = 8.0 - uv.y;\n                }\n                \n                // Since uv.x wraps around weirdly, we need to map twice;\n                // once for the 'NCC', once for the '-1701'\n                float d = textMap(vec2((uv.x + PI) * -10.0, 8.0 - uv.y * 2.0));\n                float d2 = textMap(vec2((uv.x - PI) * -10.0, 8.0 - uv.y * 2.0));\n                d = min(d, d2);\n                float tw = 0.2;\n                \n                // Check if we hit something\n                if (d < tw / 2.0 && d > -tw / 2.0)\n                    col = vec3(0.0);\n            }\n            \n            // Top and bottom blue lights\n            if (uvs.y < 0.5)\n            {\n                // Create a light blue colour (navigational lights?)\n                emission = vec3(0.3, 0.9, 1.0);\n            }\n            \n            // Make the nav lights\n            // Green lights (right nav lights)\n            if (length(uvs - vec2(-5.0, 5.5)) < 0.1 ||\n                length(uvs - vec2(-7.0, 5.5)) < 0.1)\n            {\n                emission = vec3(0.2, 1.0, 0.2);\n            }\n\n            // Red lights (left nav lights)\n            if (length(uvs - vec2(5.0, 5.5)) < 0.1 ||\n                length(uvs - vec2(7.0, 5.5)) < 0.1)\n            {\n                emission = vec3(1.0, 0.1, 0.1);\n            }\n        }\n        \n        // Make it pretty smooth\n        return SurfFrag(col, emission, roughness, 0.0);\n    }\n    else if (id == 2)\n    {\n        // This is the neck section\n        // Based on n.x, we use either p.yz or p.xy for UVs\n        \n        // Setup colour\n        vec3 col = vec3(0.6);\n        vec3 emission = vec3(0.0);\n        \n        // Setup UV\n        vec2 uv = vec2(0.0);\n        \n        // Check n.x\n        if (abs(n.x) > 0.9)\n            uv = p.zy;\n        else\n            uv = p.xy;\n        \n        // Calculate local (mod) co-ordinates, and\n        // calculate the cell co-ordinates\n        vec2 c = uv - mod(uv, vec2(0.3, 0.2));\n        vec2 uvm = mod(uv, vec2(0.3, 0.2));\n        \n        // Generate some test lights\n        if (uvm.x < 0.2 && uvm.y < 0.1 && abs(n.x) > 0.9)\n        {\n            // Now that we have a sort of grid,\n            // generate noise to determine what lights\n            // are on or off\n            float nv = noise(c * 7.0);\n            \n            // If the noise value is above threshold,\n            // create some light\n            if (nv > 0.7)\n            {\n                emission = intLightCol;\n            }\n        }\n        \n        // Create the plated effect like on the saucer\n        float reflective = 0.0;\n        \n        // Create new mod co-ords\n        c = uv - mod(uv, vec2(0.3));\n        uvm = mod(uv, vec2(0.3));\n        \n        // Create some noise\n        float nv = noise(c * 2.5);\n        \n        // Create the plate effect\n        col = mix(col, col * 1.2, nv);\n        reflective = mix(0.0, 0.2, nv);\n        \n        // Return a fragment\n        return SurfFrag(col, emission, mix(0.1, 0.0, reflective), 0.0);\n    }\n    else if (id == 3)\n    {\n        // Engineering hull\n        vec3 col = vec3(0.6);\n        float reflective = 0.0;\n        \n        // Calculate UV co-ordinates; we use\n        // cylindrical mapping here\n        p = p.xzy;\n        vec2 uv = vec2(atan(n.x, n.z) / (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);\n        \n        // Map a texture\n        uv.x *= 5.0 / p.z;\n        \n        // Correct the UV coordinates\n        uv = uv * 2.0 - 1.0;\n        \n        // Create new mod co-ords\n        vec2 c = uv - mod(uv, vec2(0.3));\n        vec2 uvm = mod(uv, vec2(0.3));\n        \n        // Create some noise\n        float nv = noise(c * 1.5);\n        \n        // Create the plate effect\n        col = mix(col, col * 1.2, nv);\n        reflective = mix(0.0, 0.2, nv);\n        \n        // Glass\n        return SurfFrag(col, vec3(0.0), reflective, 0.0);\n    }\n    else if (id == 4)\n    {\n        // Deflector dish\n        vec3 col = vec3(0.6);\n        vec3 emission = vec3(0.0);\n        float reflective = 0.1;\n        \n        // Move p.xy to local co-ords\n        p.xy += vec2(0.0, 3.25);\n        \n        // Calculate an angle based on p.xy\n        float angle = atan(p.x, p.y);\n        float r = length(p.xy) + 0.3;\n        \n        // Deflector light col\n        vec3 defLightCol = vec3(0.3, 0.8, 1.0);\n        \n        // Only draw lights on the front\n        if (n.z < 0.0)\n        {\n            // Draw the lights from a radius\n            if (r > 0.9)\n            {\n                // Repeat it\n                float ma = mod(angle, 0.2);\n\n                if (ma < 0.1)\n                {\n                    reflective = 1.0;\n                    emission = defLightCol;\n                }\n            }\n            else if (r > 0.72 && r < 0.82)\n            {\n                reflective = 1.0;\n                emission = defLightCol;\n            }\n        }\n        \n        // Return surface fragment\n        return SurfFrag(col, emission, reflective, 0.0);\n    }\n    else if (id == 5)\n    {\n        // Warp nacelles\n        vec3 col = vec3(0.6);\n        float reflective = 0.0;\n        \n        // Calculate UV co-ordinates; we use\n        // cylindrical mapping here\n        p = p.xzy;\n        vec2 uv = vec2(atan(n.x, n.z) / (2.0 * PI) + 0.5, p.y * 0.5 + 0.5);\n        \n        // Map a texture\n        uv.x *= 6.0 / p.z;\n        uv.y *= 4.0;\n        \n        // Create new mod co-ords\n        vec2 c = uv - mod(uv, vec2(0.3));\n        vec2 uvm = mod(uv, vec2(0.3));\n        \n        // Create some noise\n        float nv = noise(c * 1.5);\n        \n        // Create the plate effect\n        col = mix(col, col * 1.2, nv);\n        reflective = mix(0.0, 0.2, nv);\n        \n        // Rotate UV\n        uv = uv.yx;\n        uv.x = 8.0 - uv.x * 0.25;\n\n        // Draw the registry number on the nacelles\n        float d = textMap(vec2(uv.x * -10.0, 8.0 - uv.y * 2.0));\n\n        // Text width\n        float tw = 0.25;\n\n        // Check if we hit something\n        if (d < tw / 2.0 && d > -tw / 2.0)\n            col = vec3(0.0);\n        \n        // Return the surface fragment\n        return SurfFrag(col, vec3(0.0), reflective, 0.0);\n    }\n    else if (id == 6)\n    {\n        // The glowy spheres on the warp nacelles (active when\n        // warping and stuff)\n        vec3 lightCol = vec3(0.3, 0.8, 1.0);\n        vec3 normCol = vec3(0.0, 0.0, 0.1);\n        \n        // Properties\n        vec3 surf = normCol;\n        vec3 emit = lightCol;\n        \n        // Return a surface fragment\n        return SurfFrag(surf, emit, 0.0, 0.0);\n    }\n    else if (id == 7)\n    {\n        // This is the shader for the engine pylons\n        vec3 col = vec3(0.6);\n        \n        // Not really going to bother with the plates here,\n        // just going to make that grey line near the front\n        if (p.z > 9.7 && p.z < 10.0 && p.y < -0.2 && p.y > -1.5)\n            col = vec3(0.3);\n        \n        // Make it reflective\n        float reflective = 0.1;\n        \n        // Return a surface fragment\n        return SurfFrag(col, vec3(0.0), reflective, 0.0);\n    }\n    else\n    {\n        // Default material\n        return SurfFrag(vec3(1.0), vec3(0.0), 0.7, 0.0);\n    }\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//            BACKGROUND RENDERING             //\n//                                             //\n/////////////////////////////////////////////////\n\n// Sphere intersection\nfloat iSphere(vec4 dim, vec3 o, vec3 r, inout vec3 n)\n{\n    // Move to local co-ordinates\n    o -= dim.xyz;\n    n = vec3(0.0);\n    \n    // Solve the intersection equation\n    float ret = 0.0;\n    float b = 2.0 * dot(o, r);\n    float c = dot(o, o) - dim.w * dim.w;\n    float h = b * b - 4.0 * c;\n    if (h < 0.0) ret = -1.0;\n    else ret = (-b - sqrt(h)) / 2.0;\n    \n    // Return normal and distance\n    n = (o + r * ret) / dim.w;\n    return ret;\n}\n\n// Plane intersection (thanks to:\n// http://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/)\nfloat iPlane(vec3 d, vec3 p, vec3 o, vec3 r)\n{\n    // Normalize vectors\n    d = normalize(d);\n    r = normalize(r);\n    \n    // Setup t\n    float t = 0.0;\n    \n    // Calculate angle between d and r\n    float angle = dot(d, r);\n    \n    // If the angle is not zero, continue\n    if (angle > 1e-6)\n    {\n        vec3 pxl = p - o;\n        t = dot(pxl, d) / angle;\n        return t;\n    }\n    \n    // Return -1 if we didn't hit anything\n    return -1.0;\n}\n\n// Calculates background color for a ray\n// I could use Cubemap A, but that's lower resolution sadly.\nvec3 background(vec3 o, vec3 r)\n{\n    // Background code for saturn and its rings\n    \n    // Background colour\n    vec3 bcol = vec3(0.0);\n    \n    // Stars\n    vec2 uv = vec2(atan(r.x, r.z), r.y);\n    bcol = mix(vec3(0.0), vec3(1.0), step(0.99, noise(uv * 100.0)));\n    \n    // Calculate angle between viewing vector and sun\n    float angle = max(dot(r, -lightDir), 0.0);\n\n    // Create a specular highlight\n    angle = pow(angle, SUN_STRENGTH);\n\n    // Add the sun in\n    //bcol = mix(bcol, vec3(1.0, 1.0, 0.8), angle);\n    bcol += vec3(1.0, 1.0, 0.8) * smoothstep(0.95, 0.952, angle);\n    bcol += mix(bcol, vec3(1.0, 1.0, 0.8), angle * angle * 0.6);\n\n    // Intersect saturn\n    vec3 nSaturn = vec3(0.0);\n    vec4 saturnpos = vec4(SATURN_POS, SATURN_SIZE);\n    float saturn = iSphere(saturnpos, o, r, nSaturn);\n\n    // Direction to plane\n    vec3 pdir = normalize(vec3(0.2, 0.3, 0.1));\n    vec3 pp = SATURN_POS;\n\n    // Calculate plane intersection\n    float tplane = iPlane(pdir, pp, o, r);\n\n    // If we hit saturn, colour it in\n    if (saturn > 0.0)\n    {\n        // Raytracing position\n        vec3 sp = o + r * saturn;\n\n        // Data about the material\n        float sref = 0.0;\n        \n        // diffuse\n        bcol = vec3(0.6, 0.5, 0.4) * dot(nSaturn, -lightDir);\n        \n        float mixv = pow(1.0 - max(dot(nSaturn, -r), 0.0), 6.0);\n        bcol = mix(bcol, vec3(2.0), mixv * max(dot(nSaturn, -lightDir), 0.0) );\n    }\n    if (tplane > 0.0 && saturn < 0.0)\n    {\n        // Raytracing position\n        vec3 sp = o + r * tplane;\n\n        // Length from planet\n        float len = length(sp - pp);\n\n        // Restrict the rings to a radius\n        if (len > 6500.0 && len < 9500.0)\n        {\n            // Material data\n            float rref = 0.0;\n            bool rlight = false;\n            pdir = normalize(pdir);\n            \n            // Create a color\n            bcol = vec3(0.6, 0.5, 0.4);\n\n            // Calculate length from saturn\n            float len = length(sp - SATURN_POS);\n\n            // Create some noise based on the length\n            float nv = fbm(vec2(len * 0.2, 0.0));\n\n            // Blend the colour\n            bcol = mix(vec3(0.0), bcol, nv);\n        }\n    }\n    \n    // Calculate intersection with titan\n    vec3 nTitan = vec3(0.0);\n    vec4 titanpos = vec4(0.0, -20000.0, 0.0, 19000.0);\n    float titan = iSphere(titanpos, o, r, nTitan);\n    \n    // Draw titan\n    if (titan > 0.0)\n    {\n        vec3 p = o + r * titan;\n        bcol = mix(vec3(1.0, 0.5, 0.0), vec3(0.9, 0.4, 0.05), fbm(p.xz / 500.0));\n        bcol *= dot(nTitan, -lightDir);\n        \n        float mixv = pow(1.0 - max(dot(nTitan, -r), 0.0), 6.0);\n        bcol = mix(bcol, vec3(2.0), mixv * dot(nTitan, -lightDir) );\n    }\n    \n    // Return the color\n    return bcol;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//               RENDERING CODE                //\n//                                             //\n/////////////////////////////////////////////////\n\n// Ray-traces and returns an ID\nint trace(vec3 o, vec3 r, inout vec3 n, inout vec3 p)\n{\n    // Stuff\n    float t = 0.0;\n    int id = -1;\n    \n    // Loop a few times\n    for (int i = 0; i < RAY_STEPS; i++)\n    {\n        // If we hit the maximum distance, stop\n        if (t > RAY_MAX_DIST) break;\n        \n        // Setup point to test\n        p = o + r * (t + 0.01);\n        \n        // Evaluate map function\n        vec2 hit = map(p);\n        \n        // Check if we hit an object\n        if (hit.x < 0.0001)\n        {\n            // Calculate normal\n            n = calcNormal(p);\n            \n            // Set ID\n            id = int(hit.y);\n            \n            // Stop\n            break;\n        }\n        \n        // Increment t\n        t += hit.x * 0.4;\n    }\n    \n    // Return ID\n    return id;\n}\n\n// Direct light sampling\nvec3 directLight(vec3 p, vec3 n)\n{\n    // Sampled light color\n    vec3 lightSample = vec3(0.0);\n    \n    // Diffuse light path\n    vec3 vDiff = normalize(R3D(p + iTime) * 2.0 - 1.0);\n    \n    // Temporary p and n\n    vec3 p_, n_ = vec3(0.0);\n    \n    // Setup a ray towards the light\n    vec3 dir = normalize(vDiff - lightDir);\n    \n    // Cast a ray\n    int id = trace(p, dir, n_, p_);\n    \n    // If we hit anything, add its emission\n    if (id == -1)\n    \tlightSample += vec3(1.0);\n    \n    // Return direct light\n    return lightSample;\n}\n\n// Returns probability of reflection vs refraction\nfloat schlick(float cosine, float ior)\n{\n    float R0 = pow((1.0 - ior) / (1.0 + ior), 2.0);\n    return R0 + (1.0 - R0) * pow(1.0 - cosine, 5.0);\n}\n\n// Returns the color at a pixel\nvec3 color(vec3 o, vec3 r, float iSample)\n{\n    // Light color\n    vec3 attenuation = vec3(1.0);\n    vec3 emission = vec3(0.0);\n    \n    // Previous IOR\n    float prevIor = 1.0;\n    \n    // Bounce the ray around\n    for (int i = 0; i < MAX_DEPTH; i++)\n    {\n        // Surface normal and position\n        vec3 n = vec3(0.0);\n        vec3 p = vec3(0.0);\n        \n        // Ray trace and get ID\n        int id = trace(o, r, n, p);\n        \n        // Offset position slightly\n        p += n * EPS;\n        \n        // Fetch a surface fragment\n        SurfFrag Surf = surface(id, p, n);\n        \n        // Incoming light\n        vec3 incLight = directLight(p, n);\n        \n        // Light attenuation\n        if (id != -1)\n        {\n            // Is this right? Doesn't quite seem so but it's the only way I could\n            // make the lights look like they glow without direct light sampling...\n            attenuation = attenuation * Surf.surface + Surf.emission;\n            \n            // Add onto emission\n            emission += Surf.emission + incLight;\n        }\n        else\n        {\n            // IBL\n            //emission += texture(iChannel1, r).rgb;\n            emission += background(o, r);\n            break;\n        }\n        \n        // Diffuse light path\n        vec3 vDiff = normalize(R3D(p + iTime + iSample) * 2.0 - 1.0);\n        \n        // Reflection probability\n        float fresnel = schlick(dot(n, -r), Surf.ior);\n        float nv = noisev(p.x + p.y + p.z + iTime + iSample);\n        \n        // Default path is reflection\n        vec3 vRef = reflect(r, n);\n        \n        // If the object is refractive, refract if nv > fresnel\n        if (nv > fresnel && Surf.ior > 0.0)\n        {\n            p -= 2.0 * n * EPS;\n            vRef = refract(r, n, prevIor / Surf.ior);\n        }\n        \n        // Mix between reflected and diffuse paths\n        r = mix(vRef, vDiff, Surf.roughness);\n        o = p;\n        \n        // Set previous data\n        prevIor = Surf.ior;\n    }\n    \n    // Return light\n    return attenuation * emission;\n}\n\n/////////////////////////////////////////////////\n//                                             //\n//              IMAGE PROCESSING               //\n//                                             //\n/////////////////////////////////////////////////\n\n// Add movement\nvec3 getPosition()\n{\n    // Check the position in the data buffer\n    return texelFetch(iChannel2, ivec2(0, 0), 0).xyz;\n}\n\n// Movement flag\nfloat moveFlag()\n{\n    // Fetch the flag at (0, 1).x\n    return texelFetch(iChannel2, ivec2(0, 1), 0).x;\n}\n\n// Get y rotation\nvec2 getRotation()\n{\n    // Fetch y-rotation at (0, 1).y\n    return texelFetch(iChannel2, ivec2(0, 1), 0).yz;\n}\n\n// Main image processing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n\t// Setup pixel colour\n    vec3 col = vec3(0.0);\n    \n    // Fetch position and rotation\n    vec3 pos = getPosition();\n    vec2 rot = getRotation();\n    \n    // Setup ray\n    vec3 o = vec3(pos.x, 2.0 + pos.y, pos.z - 10.0);\n    vec3 r = normalize(vec3(uv, 0.5 * PI));\n    \n    #ifdef FAKE_AA\n    // Add a random offset to the ray\n    r = normalize(r + R3D(o + r * (iTime + 1.0)).xzy * 0.002);\n    #endif\n    \n    // Rotate camera\n    r.yz *= mat2(cos(rot.x), -sin(rot.x), sin(rot.x), cos(rot.x));\n    r.xz *= mat2(cos(rot.y), -sin(rot.y), sin(rot.y), cos(rot.y));\n    \n    // Setup colour. Since we are only really doing one thing per iteration\n    // of this for loop, we can swap the last statement (n++) with the code\n    // that runs for every step, and replace 'n < SAMPLES' with 'n++ < SAMPLES'\n    for (float n = 0.0; n++ < SAMPLES; col += color(o, r, n) / SAMPLES){}\n    \n    // Output to screen\n    #ifdef NOISY\n    vec3 prevFrame = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(mix(col, prevFrame, 0.25), 1.0);\n    #else\n    float moveFlag = (1.0 - step(0.5, moveFlag()));\n    float mouseFlag = (1.0 - step(0.5, iMouse.z));\n    // Thanks to a comment on https://www.shadertoy.com/view/XtyXW1 - neatened it\n    // up a little and removed the 'if' statement.\n    vec4 prevFrame = texture(iChannel0, fragCoord / iResolution.xy) * moveFlag * mouseFlag;\n    fragColor = vec4(col, 1.0) + prevFrame;\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Attempting to pathtrace the USS Enterprise  //\n//  (the Constitution-class variant as seen in  //\n//  the recent Star Trek movies). Buffer B here //\n//  is the 'data' buffer, which stores data on  //\n//  player position, rotation and possibly      //\n//  other things.                               //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n// Values\n#define PI 3.14159\n#define EPS 1e-5\n\n// Macros\n#define tex(x, y) texelFetch(iChannel0, ivec2(x, y), 0)\n#define getKey(n) texelFetch(iChannel1, ivec2(n, 0), 0).x\n#define getKeyDown(n) texelFetch(iChannel1, ivec2(n, 1), 0).x\n\n// Keys\n#define KEY_LEFT 37\n#define KEY_UP 38\n#define KEY_RIGHT 39\n#define KEY_DOWN 40\n#define KEY_W 87\n#define KEY_A 65\n#define KEY_S 83\n#define KEY_D 68\n#define KEY_SPACE 32\n#define KEY_SHIFT 16\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 data = tex(0, 0);\n    \n    // Old mouse position\n    vec2 oldMouse = iMouse.zw / iResolution.xy;\n    vec2 newMouse = iMouse.xy / iResolution.xy;\n    vec2 dragDiff = newMouse - oldMouse;\n    \n    ////////////////////////////////////////////////////////\n    // Player rotation                                    //\n    ////////////////////////////////////////////////////////\n    vec2 rot = tex(0, 1).yz;\n    \n    // Get y-rotation speed\n    float yrVel = newMouse.x - oldMouse.x;//getKey(KEY_RIGHT) - getKey(KEY_LEFT);\n    yrVel *= step(0.5, iMouse.z);\n    \n    // Get x-rotation speed\n    float xrVel = newMouse.y - oldMouse.y;\n    xrVel *= step(0.5, iMouse.z);\n    \n    // Rotate\n    rot -= vec2(xrVel, yrVel);// * 0.025;\n    \n    ////////////////////////////////////////////////////////\n    // Player position                                    //\n    ////////////////////////////////////////////////////////\n    vec3 pos = tex(0, 0).xyz;\n    \n    // Get the velocity\n    float vHorizontal = getKey(KEY_RIGHT) - getKey(KEY_LEFT) + getKey(KEY_D) - getKey(KEY_A);\n    float vVertical = getKey(KEY_UP) - getKey(KEY_DOWN) + getKey(KEY_W) - getKey(KEY_S);\n    \n    // Clamp velocity\n    vec2 vel = vec2(clamp(vHorizontal, -1.0, 1.0), clamp(vVertical, -1.0, 1.0));\n    \n    // Rotate velocity\n    float yrot = rot.y + 0.5 * PI;\n    vec2 velocity = vel;\n    velocity.x = vel.y * cos(yrot) + vel.x * cos(yrot - 0.5 * PI);\n    velocity.y = vel.y * sin(yrot) + vel.x * sin(yrot - 0.5 * PI);\n    \n    // Move the object\n    pos.xz += velocity * 0.05;\n    \n    ////////////////////////////////////////////////////////\n    // Player jumping                                     //\n    ////////////////////////////////////////////////////////\n    \n    // Upwards velocity (jumping) is stored in data(0, 0).w\n    //float upVel = tex(0, 0).w;\n    \n    // If upwards velocity is zero, and we press the jump key,\n    // set an upward velocity\n    //if (upVel <= EPS && getKeyDown(KEY_SPACE) > 0.0) upVel = 0.12;\n    \n    // Downwards acceleration is 10 m/s^2\n    //upVel -= 0.4 * iTimeDelta;\n    \n    \n    // calculate upwards velocity based on the vertical rotation\n    float upVel = (getKey(KEY_SPACE) - getKey(KEY_SHIFT)) * 0.05;\n    \n    \n    // Update player position based on upwards velocity\n    pos.y += upVel;\n    /*if (pos.y <= EPS)\n    {\n        pos.y = 0.0;\n        upVel = 0.0;\n    }*/\n    \n    ////////////////////////////////////////////////////////\n    // Store data                                         //\n    ////////////////////////////////////////////////////////\n    \n    // Only store the following data at (0, 0)\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n    \t// Store player position\n        data.xyz = pos;\n        \n        // Store upwards velocity\n        data.w = upVel;\n    }\n    // Only store the following data at (0, 1)\n    else if (ivec2(fragCoord) == ivec2(0, 1))\n    {\n        // Store a flag (0 | 1) if the player has moved this frame\n        data.x = step(EPS, abs(velocity.x)) + step(EPS, abs(velocity.y));\n        //if (abs(upVel) > 0.0) data.x = 1.0;\n        data.x += step(EPS, abs(upVel));\n        \n        // Store y rotation\n        data.yz = rot;\n    }\n    \n    // Output data\n    fragColor = data;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//////////////////////////////////////////////////\n//                                              //\n//  Attempting to pathtrace the USS Enterprise  //\n//  (the Constitution-class variant as seen in  //\n//  the recent Star Trek movies)                //\n//                                   - Noxbuds  //\n//                                              //\n//////////////////////////////////////////////////\n\n/////////////////////////////////////////////////\n//                                             //\n//             DISTANCE FUNCTIONS              //\n//                                             //\n/////////////////////////////////////////////////\n\n// 2D functions for drawing text\n\n// 'C' distance\nfloat sdC(vec2 p, vec2 s)\n{\n    // This is a rounded square, cutoff on the right\n    \n    // Round-ness\n    float roundness = 0.5;\n    \n    // Calculate the distance from the square\n    float d = length(max(abs(p) - s * roundness, 0.0));\n    \n    // Subtract the roundness\n    d -= roundness;\n    \n    // Now cut out a box on the right\n    if (p.x > s.x * roundness && p.y > -s.y * roundness && p.y < s.y * roundness)\n        d = 1.0;\n    \n    // Return distance\n    return d;\n}\n\n// 'N' distance\nfloat sdN(vec2 p, vec2 s)\n{\n    // Two rectangles on either side, with a rotated\n    // rectangle in the middle\n    \n    // Size for left and right rectangles\n    vec2 s2 = vec2(s.x * 0.1, s.y);\n    \n    // Draw a main rectangle\n    float d = length(max(abs(p) - s, 0.0));\n    \n    // Cutout the middle\n    if (p.x > -s.x * 0.9 && p.x < s.x * 0.9)\n        d = 1.0;\n    \n    // Warp p to create a diagonal line\n    p.x += p.y * 0.93;\n    \n    // Create another rectangle\n    float d2 = length(max(abs(p) - vec2(s.x * 0.05, s.y), 0.0));\n    \n    d = min(d, d2);\n    \n    // Return distance\n    return d * 2.0;\n}\n\n// Hyphen distance\nfloat sdHyphen(vec2 p, vec2 s)\n{\n    // A small rectangle\n    float d = length(max(abs(p) - s, 0.0));\n    \n    // Cut out parts\n    if (p.x < -s.x * 0.3 || p.x > s.x * 0.3 ||\n       p.y > s.x * 0.075 || p.y < -s.x * 0.075)\n        d = 1.0;\n    \n    // Return the distance\n    return d;\n}\n\n// '1' distance\nfloat sdOne(vec2 p, vec2 s)\n{\n    // A small rectangle\n    float d = length(max(abs(p) - s, 0.0));\n    \n    // Cut out parts\n    if (p.x < -s.x * 0.075 || p.x > s.x * 0.075)\n        d = 1.0;\n    \n    // Return the distance\n    return d;\n}\n\n// '7' distance\nfloat sdSeven(vec2 p, vec2 s)\n{\n    // Rectangle on top, with a diagonal rectangle below\n    float d = length(max(abs(p) - s, 0.0));\n    if (p.y < s.y * 0.91)\n        d = 1.0;\n    \n    // Warp p\n    p.x -= p.y;\n    \n    // Create another rectangle\n    float d2 = length(max(abs(p) - vec2(s.x * 0.04, s.y), 0.0));\n    \n    d = min(d, d2);\n    \n    // Return distance\n    return d * 2.0;\n}\n\n// '0' distance\nfloat sdZero(vec2 p, vec2 s)\n{\n    // Just a cut-out rounded rectangle\n    \n    // Round-ness\n    float roundness = 0.5;\n    \n    // Calculate the distance from the square\n    float d = length(max(abs(p) - s * roundness, 0.0));\n    \n    // Subtract the roundness\n    d -= roundness;\n    \n    // Return distance\n    return d;\n}\n\n// Map function\nfloat textMap(vec2 p)\n{\n    float v = 10.0;\n    \n    // Shift everything left\n    p.x += 6.0;\n    \n    // 'N'\n    v = sdN(p, vec2(1.0));\n    \n    // 'CC'\n    v = min(v, sdC(p + vec2(-2.3, 0.0), vec2(1.0)));\n    v = min(v, sdC(p + vec2(-4.6, 0.0), vec2(1.0)));\n    \n    // '-'\n    v = min(v, sdHyphen(p + vec2(-6.3, 0.0), vec2(1.0)));\n    \n    // '1701'\n    v = min(v, sdOne(p + vec2(-6.9, 0.0), vec2(1.0)));\n    v = min(v, sdSeven(p + vec2(-8.3, 0.0), vec2(1.0)));\n    v = min(v, sdZero(p + vec2(-10.6, 0.0), vec2(1.0)));\n    v = min(v, sdOne(p + vec2(-12.0, 0.0), vec2(1.0)));\n    \n    // Return the distance\n    return v;\n}","name":"Common","description":"","type":"common"}]}