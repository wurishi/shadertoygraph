{"ver":"0.1","info":{"id":"4lfBWf","date":"1513550933","viewed":1340,"name":"Wireframe cube","username":"rkibria","description":"A wireframe cube modeled as vertices and edges is scaled, rotated and translated in homogeneous 3D coordinates, then a perspective matrix is applied and the 2D lines drawn.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","cube","wireframe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float segment(vec2 u, vec2 a, vec2 b)  {         \n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nvoid lineTo(in vec2 uv, inout vec4 fragColor, in vec2 a, in vec2 b, in float w) {\n    float s = segment(uv, a, b);\n    s = 1. - smoothstep(0., 1., s * w);\n    fragColor = max(fragColor, vec4(s));\n}\n\n// unit cube with lower left and front corner at origin\n#define N_VERTICES 8\nconst vec4 vertices[N_VERTICES] = vec4[](\n\tvec4(0., 0., 0., 1.),\n\tvec4(1., 0., 0., 1.),\n\tvec4(1., 1., 0., 1.),\n\tvec4(0., 1., 0., 1.),\n\n\tvec4(0., 0., 1., 1.),\n\tvec4(1., 0., 1., 1.),\n\tvec4(1., 1., 1., 1.),\n\tvec4(0., 1., 1., 1.)\n\t);\n\nconst ivec2 edges[12] = ivec2[](\n    ivec2(0, 1),\n    ivec2(1, 2),\n    ivec2(2, 3),\n    ivec2(3, 0),\n\n    ivec2(4, 5),\n    ivec2(5, 6),\n    ivec2(6, 7),\n    ivec2(7, 4),\n\n    ivec2(0, 4),\n    ivec2(1, 5),\n    ivec2(2, 6),\n    ivec2(3, 7)\n    );\n\n// Each matrix line is a COLUMN not a row\nmat4 scaleMatrix(in vec3 v) {\n\treturn mat4(\n        v.x,          0.0,            0.0,            0.0,\n        0.0,          v.y,            0.0,            0.0,\n        0.0,          0.0,            v.z,            0.0,\n        0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 translateMatrix(in vec3 v) {\n\treturn mat4(\n        1.0,          0.0,            0.0,            0.0,\n        0.0,          1.0,            0.0,            0.0,\n        0.0,          0.0,            1.0,            0.0,\n        v.x,          v.y,            v.z,            1.0\n        );\n}\n\nmat4 rotXMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    1.0,          0.0,            0.0,            0.0,\n\t    0.0,          cos_phi,        sin_phi,        0.0,\n\t    0.0,          -sin_phi,       cos_phi,        0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 rotYMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    cos_phi,      0.0,            -sin_phi,       0.0,\n\t    0.0,          1.0,            0.0,            0.0,\n\t    sin_phi,      0.0,            cos_phi,        0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 rotZMatrix(in float phi) {\n    float cos_phi = cos(phi);\n    float sin_phi = sin(phi);\n    return mat4(\n\t    cos_phi,      sin_phi,        0.0,            0.0,\n\t    -sin_phi,     cos_phi,        0.0,            0.0,\n\t    0.0,          0.0,            1.0,            0.0,\n\t    0.0,          0.0,            0.0,            1.0\n    \t);\n}\n\nmat4 perspectiveMatrix() {\n    const float S = 1.0;\n    const float f = 1.0;\n    const float n = 0.1;\n    return mat4(\n\t    -S,            0.0,            0.0,            0.0,\n\t    0.0,          -S,              0.0,            0.0,\n\t    0.0,          0.0,            -(f+n)/(f-n),   -1.0,\n\t    0.0,          0.0,            -2.*f*n/(f-n),   0.0\n    \t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy / iResolution.x;\n    uv += vec2(-0.5, -iResolution.y / iResolution.x / 2.);\n\n    float t = iTime * 0.5;\n    mat4 mtx = perspectiveMatrix() \n        * translateMatrix(\n            vec3(sin(t+1.)*0.07, \n                sin(t+2.)*0.02, \n                0.2+sin(t+3.)*0.2))\n        * scaleMatrix(vec3(0.05)) \n        * rotZMatrix(t) \n        * rotYMatrix(t) \n        * rotXMatrix(t) \n        * translateMatrix(vec3(-0.5));\n    \n    vec4 transVertices[N_VERTICES];\n    for (int i = 0; i < N_VERTICES; i++) {\n        transVertices[i] = mtx * vertices[i];\n    }\n    \n    for (int i = 0; i < edges.length(); i++) {\n        ivec2 edge = edges[i];\n        vec4 A = transVertices[edge.x];\n        vec4 B = transVertices[edge.y];\n        float Az = A.z;\n        float Bz = B.z;\n        float width = abs(Az+Bz)*200.0;\n        lineTo(uv, \n               fragColor,\n               vec2(A.x/Az, A.y/Az), \n               vec2(B.x/Bz, B.y/Bz),\n               width\n              );\n    }\n}","name":"Image","description":"","type":"image"}]}