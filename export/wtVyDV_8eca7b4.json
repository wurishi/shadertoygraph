{"ver":"0.1","info":{"id":"wtVyDV","date":"1612094435","viewed":84,"name":"4D Quarternion Julia","username":"milez770","description":"is it working....","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["julia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ITER 10\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST 0.00001\n#define SPEED 5.\n\n// 3d mandelbulb\nfloat mandel4(in vec3 v, in vec4 c, out vec3 map){\n    //float t = sin(iTime)*.5+.5;\n    vec4 mv = vec4(v, 0.);\n    \n    vec4 r = mv;\n    vec4 rNext = r;\n    float m = dot(mv, mv);\n    vec4 trap = vec4(abs(r));\n    \n    int i = 0;\n    float d = 1.;\n    \n    float n =  2.;\n    \n    for(i=0; i<ITER; i++){\n        float cr = length(r);\n        float nr = pow(cr, n);\n        \n        d = pow(cr, n-1.) *n * d + 1.0;\n        \n        rNext.x = pow(r.x, n) - pow(r.y, n) - pow(r.z, n) - pow(r.w, n);\n        rNext.y = n*r.x*r.y;\n        rNext.z = n*r.x*r.z;\n        rNext.w = n*r.x*r.w;\n        r = c + rNext;\n        \n        trap = min(trap, vec4(abs(r)));\n        map = vec3(trap.xyz);\n\n        m = dot(r,r);\n        \n        if(m > 3.5){\n            break;\n        }\n    }\n    //return pow(length(r), 2.)+sqrt(m);\n    return  .35*log(m) * sqrt(length(m))/d;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d; \n}\n\nfloat RayMarch(in vec3 ro, in vec3 rd, in vec4 c, out vec3 col){\n    float dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++){\n        vec3 p = ro+rd*dO;\n        //p.xz *= Rot(iTime/SPEED);\n        //p.yz *= Rot(iTime/SPEED-2.);\n        float mbd = mandel4( p, c, col);\n        float dS = mbd;\n        \n        if(dO > MAX_DIST || dS<SURF_DIST) break;\n        dO += dS;\n    }\n    \n    return dO;\n}\nvec3 GetNormal(in vec3 p, in vec4 c){\n     vec3 col;\n    // my e value made black artifacts\n    // so I took a look at iq's normal epsilone. \n    // don't exactly know how this is calculated.\n    // looks like it is relevant to some screen pixel size calculation..?\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.25*2.0/(iResolution.y*1.5);\n    \n    // getting vector with very small vector\n    vec3 n = vec3(\n        e.xyy*mandel4(p+e.xyy, c, col)+\n        e.yxy*mandel4(p+e.yxy, c, col)+\n        e.yyx*mandel4(p+e.yyx, c, col)+\n        e.xxx*mandel4(p+e.xxx, c, col ) \n    );\n    \n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/(iResolution.y);\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1.5, 1.5);\n    ro.xz *= Rot(iTime/5.);\n    ro.y = 2.*sin(iTime/3.);\n    vec3 rd = R(uv, ro, vec3(0,.0,0), .7);\n    \n    vec3 backgrounduv;\n    //2.*(sin(iTime)*.5 +.5)\n    //1.5*(sin(iTime)*.5+.5)\n    float time = iTime*.45;\n    vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + time*vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n    col = vec3(.05, .13, .1);\n    float d = RayMarch(ro, rd, c, backgrounduv);\n    col += vec3(.6-d*.3);\n    //col += .5;\n    col += pow(clamp(3. - backgrounduv.y, 0.0, .99), 9.)*vec3(.5, .3, .4);\n    //col *= 10.;\n    col *= (col+.9)*(col+.6);\n    \n    //light\n    vec3 lp = vec3(0, 3.5, 4.5);\n    lp.xz *= Rot(iTime/3.);\n    //lp.yz *= Rot(iTime/3.);\n    vec3 lr = ro+rd*d;\n    //lr.xz *= Rot(iTime/SPEED);\n    //lr.yz *= Rot(iTime/SPEED-2.);\n    lr = lr;\n    vec3 l = normalize(lp - lr);\n    vec3 n = GetNormal(lr, c);\n    vec3 shadow = clamp(dot(n, l), 0.1, 1.)*vec3(0., .8, 1.)*.7;\n    shadow *= 1.;\n    //col *= vec3(pow(shadow, 1.))*vec3(.3, .6, 1.);\n    \n    \n    vec3 lp2 = vec3(3., 0., 4.5);\n    lp2.xz *= Rot(iTime);\n    lp2.yz *= Rot(iTime/3.);\n    vec3 lr2 = ro+rd*d;\n    //lr2.xz *= Rot(iTime/SPEED);\n    //lr2.yz *= Rot(iTime/SPEED-2.);\n    lr2 = lr2;\n    vec3 l2 = normalize(lp2 - lr2);\n    vec3 n2 = GetNormal(lr2, c);\n    vec3 shadow2 = clamp(dot(n2, l2), 0.1, 1.)*vec3(1., .2, 0.4)*.7;\n    shadow2 *= 1.;\n    col *= (shadow+shadow2);\n    //col += vec3(.09, .04, .09);\n    \n    fragColor = vec4(col, 0);\n}","name":"Image","description":"","type":"image"}]}