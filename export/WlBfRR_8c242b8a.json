{"ver":"0.1","info":{"id":"WlBfRR","date":"1598132371","viewed":169,"name":"The 3D Party Cube","username":"Hexdigest","description":"Bouncing Party Cube, my second ever raymarching & shadertoy project.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","cube","party","hexdigest"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","previewfilepath":"/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n//#define SURF_DIST 44.\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n\n    float d = sdBox(p, vec3(1));\n    \n    if(iTime>22.95){\n        d = sdBox(p, vec3(iTime / 10.,iTime / 10.,iTime / 10.));\n    }\n    \n    if(iTime>35.8){\n        d = sdBox(p, vec3(1.+sin(iTime),2. + sin(iTime),3.+sin(iTime)));\n    } \n    if(iTime>78.06){\n\n\t\td = sdBox(p, vec3(1.+sin(iTime),1. + sin(iTime),1.+sin(iTime)));\n    }\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float fft) {\n\tfloat dO=-333.;\n    float SURF_DIST = fft * 13.;\n    if(iTime>9.8){\n        SURF_DIST = 0.;\n    }\n    if(iTime>22.95){\n        SURF_DIST = fft;\n    }\n\n    if(iTime>70.06){\n        SURF_DIST = sin(iTime)*10.;\n    }\n    \n    if(iTime>78.06){\n        SURF_DIST = fft;\n    }\n    if(iTime>104.){\n        SURF_DIST = 2.0 + sin(iTime * 0.5);\n    }\n    if(iTime>218.){\n        SURF_DIST = 100.;\n    }\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec4 t = texture(iChannel0, uv);\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    vec3 col = vec3(-.2);\n    vec3 ro = vec3(0, 2, -1);\n    ro.x += 1.*sin(iTime / 1.2);\n    ro.y += 1.* cos(iTime / 1.2);\n    ro.z += sin(iTime) * cos(iTime);\n\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    if(iTime>9.8){\n        ro.x += 10.*sin(iTime / 1.88);\n        ro.y += 11.* cos(iTime / .44);\n        ro.z += sin(iTime) * cos(iTime);\n\n        ro.yz *= Rot(-m.y*3.14+1.);\n        ro.xz *= Rot(-m.x*6.2831);\n    }\n    if(iTime>22.95){\n        ro.x = 10.*cos(iTime);\n        ro.y = 10.*sin(iTime);\n        ro.z = 5.;\n        ro.yz *= Rot(-m.y*3.14);\n        ro.xz *= Rot(-m.x*3.14);\n    }\n    \n    if(iTime>48.85){\n        ro.x += 10.*sin(iTime / 1.88);\n        ro.y += 11.* cos(iTime / .44);\n        ro.z += sin(iTime) * cos(iTime);\n\n        ro.yz *= Rot(-m.y*4.);\n        ro.xz *= Rot(-m.x*8.);\n    }\n    \n    if(iTime>61.75){\n        ro.x += 3.;\n        ro.y += 3.;\n        ro.z += 3.;\n    }\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.4);\n    //ro.xy *= sin(iTime / 2.);\n    \n    float fft = texture(iChannel0, vec2(0., 0.)).x;\n    \n    float d = RayMarch(ro, rd, fft);\n   \n    d += 2.;\n    if(iTime>48.85){\n\t\td += -255.;\n    }\n    \n    if(iTime>61.75){   \n\t\td += 215.;\n    }\n    \n    if(iTime>78.06){\n        ro.x = 0.;\n        ro.y = 0.;\n        ro.z = 0.;\n        ro.yz *= Rot(-m.y*2.);\n        ro.xz *= Rot(-m.x*2.);\n    }\n\n    ro.y += iTime * cos(ro.y / 23.);\n    if(iTime>218.){\n        ro.x = 1.;\n        ro.y = 1.;\n        ro.z = 1.;\n        ro.y = 1.;\n    }\n    //uv *= mat2(cos(t), -sin(t), sin(t), cos(t));\n    \n    vec3 lookat = mix(vec3(0), vec3(-1, 0, -1), sin(iTime*1.56)*.5+.5);\n    float zoom = mix(.5, .1, sin(iTime)*.5+.5);\n    \n    vec3 f = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f, r),\n        c = ro + f * zoom,\n        i = c + uv.x * r + uv.y * u;\n    \n    float radius = mix(.3, 1.5, sin(iTime*.4)*.5+.5);\n    \n    float dS, dO;\n    vec3 p;\n    \n    for(int i=0; i<23; i++) {\n    \tp = ro + rd * dO;\n        dS = -(length(vec2(length(p.xz)-4., p.y)) - radius);\n        if(dS<.2) break;\n        dO += dS;\n    }\n\n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol += dif;\n        col.r = d;\n        col.b = d * d;\n\n        float x = atan(p.x, p.z)+iTime*.5;\t\t\t// -pi to pi\n        float y = atan(length(p.xz)-1., p.y);\n        \n        float bands = sin(y*122.+x*30.);\n        float ripples = sin((x*130.-y*30.)*3.)*.5+.5;\n        float waves = sin(x*2.-y*6.+iTime*20.);\n        \n        float b1 = smoothstep(-.4, .2, bands);\n        float b2 = smoothstep(-.4, .2, bands-.5);\n        \n        float m = b1*(1.-b2);\n        m = max(m, ripples*b2*max(0., waves));\n        m += max(0., waves*.1*b2);\n        \n        col.r = sin(iTime / 5.);\n        col.g = cos(iTime / 5.);\n        col.b = tan(iTime / 3.);\n        col += mix(m, 1.-m, smoothstep(-.3, .3, sin(x+iTime)));\n\n   \t\tvec2 f_uv = fract(uv * .0) -.3 * col.r / 2.0;\n        d = length(f_uv);\n    }\n\n    col = pow(col, vec3(sin(iTime)));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}