{"ver":"0.1","info":{"id":"wslBz7","date":"1587975001","viewed":456,"name":"Day10: Mipmap Bloom","username":"fluxatron","description":"Along my attempt to make a guassian bloom i found it was a bit tricky in Shadertoy. So i stopped part way and made this mipmap bloom instead :)\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["bloom","mipmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Mipmap bloom \n\n// Left: Base image\n// Mid: Composite\n// Right: Mipmap blur\n\n\n/* references\nhttps://learnopengl.com/Advanced-Lighting/Bloom\nhttp://rastergrid.com/blog/2010/09/efficient-gaussian-blur-with-linear-sampling/\nhttp://kalogirou.net/2006/05/20/how-to-do-good-bloom-for-hdr-rendering/\n*/\n\nvec3 GetBase(vec2 uv)\n{\n    return texture(iChannel0, uv).rgb;\n}\nvec3 GetBloom(vec2 uv)\n{\n    // Blending various mip levels to try get a soft blurry look\n\treturn \n    \t.1 * texture(iChannel1, uv, 2.).rgb +\n      \t.05 * texture(iChannel1, uv, 3.).rgb +\n        .02 * texture(iChannel1, uv, 5.).rgb;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy; \n    \n    vec3 col = vec3(0);\n\n    float div1 = 1./3.;\n    float div2 = 2./3.;\n    \n    \n    // Base image on left, bloomed image on right\n    if (uv.x < div1)\n\t\tcol = GetBase(uv);\n    else if (uv.x < div2)\n    {\n        uv.x -= div1;\n        col = GetBase(uv) + GetBloom(uv);\n    }\n    else\n    {\n        uv.x -= div2;\n        col = GetBloom(uv);\n    }\n    \n    // Draw divider\n    col = mix(col, vec3(1,0,0), smoothstep(3./iResolution.x,2./iResolution.x,abs(div1-uv.x)));\n    col = mix(col, vec3(1,0,0), smoothstep(3./iResolution.x,2./iResolution.x,abs(div2-uv.x)));\n    \n    // Debug - visualise brighter than (1,1,1)\n    //if (GreaterThan(col, vec3(1))) col = vec3(1,0,1);\n\n    // Grade\n    col *= 0.4; // Exposure bias\n    col = ACESFitted(col); // Tonemap\n    col = pow(col, vec3(1./2.2)); // Linear to sRGB gamma\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Generates an HDR image base image with very bright areas\n\nconst float minBright = 1.;\nconst float maxBright = 10.;\nconst float pulseRate = 1.;\n\n\n// TODO generate our own pulsing \"disco\" squares to make bloom dynamic and perdier\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    vec3 col = pow(texture(iChannel0, uv).rgb, vec3(2.2)); // sRGB > linear\n\n    \n    // Grade source to empasise bloom\n    col = pow(col, vec3(2)); // Increase contrast\n    col *= vec3(minBright + (maxBright - minBright) * (0.5 + 0.5*cos(iTime*pulseRate))); // Increase brightness\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Mipmap blur buffer\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    // Filter bright pixels\n    float brightness = dot(col, vec3(0.2126, 0.7152, 0.0722));\n    col = brightness > 1.0 ? col : vec3(0);\n        \n    col *= vec3(brightness-1.); \n   \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nbool LessThan(vec2 a, vec2 b) { return a.x < b.x && a.y < b.y; }\nbool LessThan(vec3 a, vec3 b) { return a.x < b.x && a.y < b.y && a.z < b.z; }\nbool GreaterThan(vec3 a, vec3 b) { return a.x > b.x && a.y > b.y && a.z > b.z; }\n//bool LessThanOrEquals(vec3 a, vec3 b) { return !GreaterThan(a, b); }\n//bool GreaterThanOrEquals(vec3 a, vec3 b) { return !LessThan(a, b); }\n//bool Equals(vec3 a, vec3 b, float threshold) { vec3 c = a - b; return LessThan(c, vec3(threshold)); }\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// ACES Tonemap: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.07600, 0.02840, \n\t0.35458, 0.90834, 0.13383,\n\t0.04823, 0.01566, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.10208, -0.00327,\n\t-0.53108,  1.10813, -0.07276,\n\t-0.07367, -0.00605,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v)\n{\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFitted(vec3 color)\n{\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit(color);\n\tcolor = ACESOutputMat * color;\n\tcolor = clamp(color,0.0,1.0);\n\treturn color;\n}\n","name":"Common","description":"","type":"common"}]}