{"ver":"0.1","info":{"id":"DttyRS","date":"1699361089","viewed":298,"name":" Roots of 3D","username":"celifan","description":"\"Compas and ruler\" perspective projection.\nABCD  = plan  view \nBCEF = elevation  view \ne = eye.\n","likes":36,"published":1,"flags":0,"usePreview":1,"tags":["projection","perspective","renaissance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.1415926;\nconst float _n = 12.0; // grid num subdivision.\nfloat _pixSize ;\nconst float _lw =1.0; // default line width in pixels\nconst float _ps =3.0; // default point size in pixels\nint _duFade = 20; // default line fade duration.\nint _du = 25; //default line tracing duration.\nint _duPt = 20; // default point tracing duration.\nfloat _ff = .5; // default fade factor.\n// default colors.\nconst vec3 _c0 = vec3(.95,.92,.9);\nconst vec3 _c1 =  vec3(0.4,0.4,0.4);\nconst vec3 _cBlue = vec3(0.0,0.36,1.0);\nconst vec3 _c2 = vec3(.9,.9,.9);\nconst vec3 _pc = vec3( .9,0.3,0.0); \nfloat _f ;\n#define CS(a) vec2(cos(a), sin(a))\n\n// cs = vec2(cos(rotAngle), sin(rotAngle));\nvec2 R(vec2 v, vec2 cs)\n{\n    return mat2(cs.x, cs.y, -cs.y, cs.x)*v;\n}\n\n// Arc aperture at a given time.\nvec2 arcApertureAtTime(vec2 angle, int duration, inout int fBegin)\n{\n    \n      float f = float(clamp(iFrame -fBegin,0,duration))/float(duration);\n      float a = mix(angle.x , angle.y,f );\n      fBegin += duration;\n      return vec2(angle.x,a);\n}\n\n// Segment end point at a given time.\nvec2 segmentEndAtTime(vec2 a, vec2 b,int duration,inout int fBegin)\n{\n    float f = clamp(float(clamp(iFrame -fBegin,0,duration))/float(duration),0.0,1.0);\n    vec2 end = mix( a, b,f );\n    fBegin += duration;\n    return end;\n}\n\n// Fade between 2 colors at a given time.\nvec3 colorAtTime(vec3 a, vec3 b,int duration, float opacity, inout int fBegin)\n{\n    float f = clamp(float(clamp(iFrame -fBegin,0,duration))/float(duration),0.0,opacity);\n    vec3 end = mix( a, b,f );\n    fBegin += duration;\n    return end;\n}\n\n// https://www.shadertoy.com/view/XsXSz4\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\n// signed distance to sector boundary curve\nfloat sdSector(vec2 p, float r, vec2 angles)\n{\n    //\n    vec2 v0 = vec2(cos(angles.x), sin(angles.x));\n    vec2 v1 = vec2(cos(angles.y), sin(angles.y));\n    float cp1 = sign(v1.x*p.y - v1.y*p.x);\n    float cp0 = sign(v0.x*p.y - v0.y*p.x);\n    float is =  angles.y-angles.x>PI ? -1.0 : 1.0;\n\n    return max( length(p)-r,\n                ((is*cp0>0.0 && is*cp1<0.0)?-is :is )*min( length(p - v1*clamp(dot(p,v1),0.0,r)), \n                                                       length(p - v0*clamp(dot(p,v0),0.0,r)))\n               );                                                                                                                      \n}\n\n// signed distance to arc\nfloat sdArc( vec2 p, float r, vec2 angles )\n{\n    float pa = atan(p.y,p.x);\n    pa = pa <0.0 ? pa+2.0*PI:pa;\n    return    pa>angles.x && pa<angles.y  ? abs(length(p)-r) : min(length(p-r*vec2(cos(angles.x),sin(angles.x))),\n                                                                   length(p-r*vec2(cos(angles.y),sin(angles.y))));                                   \n}\n\n// signed distance to segment\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// signed dist to box\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// arclen from angles.x to closest pt from p on arc.\nfloat arcLen(vec2 p, float r,  vec2 a)\n{\n    float pa = atan(p.y,p.x);\n    pa = pa <0.0 ? pa+2.0*PI:pa;\n    return (pa-a.x)*r;\n}\n\nfloat segLen(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ab = b-a;\n    return dot(p-a,normalize(ab));//),0.0,length(ab)); \n    \n}\n\n// fill the interior shape described by sd.\nvoid fill( float sd, vec3 color, inout vec3 pixel  )\n{\n    pixel =  mix(pixel, color, 1.0 - smoothstep(0.0, _pixSize*(_lw +.5), sd));\n    pixel = sd<0.0 ? color : pixel;\n}\n\n// solid stroke for the boundary of shape described by sd\nvoid strokeSolid( float sd, vec3 color,float lineWidth ,inout vec3 pixel  )\n{\n   \n    lineWidth = mix( lineWidth/1.1, lineWidth*1.1,_f);\n    pixel =  mix(pixel, mix(pixel , color,_f), (1.0 - sqrt(smoothstep((lineWidth-1.0)*_pixSize,_pixSize*(lineWidth +.5), abs(sd)))));\n}\n\n// dashed stroke for the boundary of shape described by sd.\nvoid strokeDashed(float sd, float alen, vec3 color, float lineWidth,float dashScale,inout vec3 pixel)\n{ \n    float d = sin((1.0/dashScale)*alen);\n    pixel =  mix(pixel, color,  clamp( .5 + .5*d/fwidth(d) , 0., 1. ) *(1.0 - sqrt(smoothstep((lineWidth-1.0)*_pixSize, _pixSize*(lineWidth +.5),abs(sd)))));\n}\n\n//** higher level drawing functions \n// Note : closed shape returns a signed distance that can be used to fill.\nfloat drawSector(vec2 p, float r,float lineWidth, vec2 angles,\n                 vec3 color,\n                 int duration, int fadeStart, inout int fBegin, inout vec3 pixel )\n{\n   vec2 a = arcApertureAtTime(angles,duration, fBegin);\n   float d = (a.x == a.y) ?1000.0 :sdSector(p,r, a ); \n    // fade factor\n   int fadeDuration = 20;\n   float f = float(clamp( iFrame - (fBegin+fadeStart) ,0, fadeDuration))/float(fadeDuration);\n   strokeSolid(d, color, lineWidth,pixel);\n   return d;\n}\n\nfloat drawSectorDashed(vec2 p, float r,float lineWidth,float dashScale, vec2 angles,\n                       vec3 color,\n                       int duration, int fadeStart, inout int fBegin, float fadeFactor,inout vec3 pixel )\n{\n   vec2 a = arcApertureAtTime(angles,duration, fBegin);\n   float d = (a.x == a.y) ? 1000.0 :sdSector(p,r, a ); \n   float u = arcLen(p,r,a);\n   // fade factor\n   int fadeDuration = 20;\n   float f = float(clamp( iFrame - (fBegin+fadeStart) ,0, fadeDuration))/float(fadeDuration);\n   strokeDashed(d,u, color, lineWidth, dashScale, pixel);\n   return d;\n   \n}\n\nvoid drawArc(vec2 p, float r,float lineWidth, vec2 angles,\n             vec3 color,\n             int duration, inout int fBegin, inout vec3 pixel )\n{\n   vec2 a = arcApertureAtTime(angles,duration, fBegin);\n   float d = a.x == a.y ? 1000.0 :sdArc(p,r, a ); \n   strokeSolid(d, color, lineWidth,pixel);   \n}\n\nvec3 fadeColor( int fStart, int fDuration, float factor, vec3 color, vec3 pixel)\n{\n   float f = float(clamp( iFrame - fStart ,0, fDuration))/(float(fDuration));\n   vec3 fColor = mix(color,pixel,factor*f);\n   return fColor;\n}\n\nvec4 animSeg(vec4 o, vec4 d,int fStart, int fDuration)\n{\n   float f = float(clamp( iFrame - fStart ,0, fDuration))/(float(fDuration));\n   return mix(o,d,f);\n}\n\nvoid drawArcDashed(vec2 p, float r,float lineWidth,float dashScale, vec2 angles,\n                   vec3 color,\n                   int duration, inout int fBegin, inout vec3 pixel )\n{\n   vec2 a = arcApertureAtTime(angles,duration, fBegin);\n   float d = (a.x == a.y) ? 1000.0 : sdArc(p,r, a );\n   float u = arcLen(p,r,a);\n   strokeDashed(d,u, color, lineWidth, dashScale, pixel);\n}\n\nvoid drawSegment(vec2 p, vec2 a, vec2 b,float lineWidth,\n                 vec3 color,\n                 int duration, inout int fBegin, inout vec3 pixel )\n{\n   b = segmentEndAtTime(a,  b,duration, fBegin);\n   float d = a ==b ? 1000.0 :  sdSegment(p,a, b );\n   strokeSolid(d, color, lineWidth,pixel);\n}\n\nvoid drawSegmentDashed(vec2 p, vec2 a, vec2 b,float lineWidth, float dashScale,\n                 vec3 color,\n                 int duration, inout int fBegin, inout vec3 pixel )\n{\n   b = segmentEndAtTime(a,  b,duration, fBegin);\n   float d = a ==b ? 1000.0 :  sdSegment(p,a, b );\n   float u = segLen(p,a,b);\n   strokeDashed(d,u, color, lineWidth, dashScale,pixel);\n   \n}\n\nvoid drawPoint(vec2 p, float pointSize, vec3 color,int duration, inout int fBegin, inout vec3 pixel )\n{\n   \n   float f = float(clamp(iFrame -fBegin,0,duration))/float(duration);\n   float sd =length(p);\n   pixel =  mix(pixel, color, f*(1.0 -sqrt(smoothstep((pointSize-1.0)*_pixSize, _pixSize*(pointSize +.5), abs(sd)))));\n   fBegin += duration;\n}\n\nvoid drawChar(vec2 p, int c,vec3 color,int duration, inout int fBegin, inout vec3 pixel) \n{\n    if (p.x>=.0 && p.x<=1. && p.y>=0.&& p.y<=1.)\n    {\n        float f1 = float(clamp(iFrame -fBegin,0,duration))/float(duration);\n        float f =  textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) ).x;\n        pixel =  mix(pixel, color, f*f1);\n    }\n    fBegin += duration;\n}\n\n// For convenience positions are expressed as integers in a [_n x _n] grid \nconst float s = 0.25; //  grid width in normalize pix coordinates\n\n// transformation to apply to vec2 in [_n X _n ] -->  normalize pix coordinates\n#define V(x,y) (vec2(x,y)*s/_n)\n#define S(x) ((x)*s/_n) \n\n// ! this function assume 2 intersection exists for the given circles.\nvoid solveCircCircIntersection(vec2 p1, float r1, vec2 p2,float r2, out vec2 i0, out vec2 i1)\n{\n    vec2 e1=p2-p1; \n    float d=length(e1);\n    e1=e1/d;\n    vec2 e2=vec2(-e1.y,e1.x); \n    float x=(r1*r1-r2*r2+d*d)/(2.*d);\n    float y=r1*r1-x*x; \n    y=sqrt(y);\n    i0=p1+x*e1+y*e2; \n    i1=p1+x*e1-y*e2; \n    \n}\n\n// ! need to handle separately the case where the intersection is close to the x axis \nvec4 circCircIntersect(vec2 p, vec2 o1, float r1, vec2 o2 , float r2,\n                    vec3 color,int dir, inout vec3 pixel, inout int fBegin)\n{\n     vec2 i0,i1;\n     solveCircCircIntersection(o1,r1,o2,r2, i0,i1);\n     int du = _du;\n     int fadeDu = du*4;\n     // skip when enterly faded.\n     if ( iFrame < fBegin+ du*8+fadeDu)\n     {\n         vec2 i01 = i0-o1;\n         vec2 i02 = i0-o2;\n         //\n         float a01 = atan(i01.y, i01.x);\n         a01 = a01<0.0 ? a01+2.0*PI :a01;\n         float a02 = atan(i02.y, i02.x);\n         a02 = a02<0.0 ? a02+2.0*PI :a02;\n         //\n         vec2 i11 = i1-o1;\n         vec2 i12 = i1-o2;\n         float a11 = atan(i11.y, i11.x);\n         a11 = a11<0.0 ? a11 +2.0*PI:a11;\n         float a12 = atan(i12.y, i12.x);\n         a12 = a12<0.0 ? a12 +2.0*PI:a12;\n         //\n         vec3 c = fadeColor(fBegin+8*du, fadeDu,1.0,color,pixel);\n         if (dir ==0 || dir ==1 )\n         {\n             drawArc(p-o1,\n                     r1,_lw,vec2(a11-PI/12.0,a11+PI/12.0), c,\n                    du, fBegin,pixel);\n              drawArc(p-o2,\n                    r2,_lw,vec2(a12-PI/12.0,a12+PI/12.0),c,\n                    du, fBegin,pixel); \n         }\n         if ( dir ==0 || dir == -1)\n         {\n             drawArc(p-o1,\n                         r1,_lw,vec2(a01-PI/12.0,a01+PI/12.0), c,\n                        du, fBegin,pixel); \n             drawArc(p-o2,\n                    r2,_lw,vec2(a02-PI/12.0,a02+PI/12.0),c,\n                    du, fBegin,pixel);\n         }\n     }\n     else\n     {\n        \n         fBegin += (dir == 0 || dir ==-1)? 2*du:0;\n         fBegin += (dir == 0 || dir ==1)? 2*du:0;\n         \n     }\n     return (dir == 0 || dir ==-1 ) ? vec4(i0,i1) : vec4(i1,i0); \n}\n\n// ! assume the circle and the line intersects and there are 2 intersections !\nvoid solveCircLineIntersect( in vec2 o, in float r, in vec2 a, in vec2 b, out vec2 i0,out  vec2 i1)\n{\n    vec2 ab = b-a;\n    vec2 oa = a-o;\n    float A =   dot(ab,ab);\n    float B = 2.0 * (ab.x * (a.x - o.x) + ab.y * (a.y - o.y));\n    float  C = dot(oa,oa) - r* r;\n    float det_s = sqrt(B * B - 4.0 * A * C);\n    float t = (-B + det_s) / (2.0 * A);\n    i0 = a + t*ab; // a->b\n    t = (-B - det_s) / (2.0 * A);\n    i1 =a + t*ab; // b->a\n           \n}\n\n// ! dir : [0 : both,  1.0 : a->b , -1.0 : b->a ]\nvec4 circLineIntersect( vec2 p, float r, vec2 a, vec2 b,\n                        vec3 color, int dir ,inout vec3 pixel, inout int fBegin)\n{\n    vec2 i0,i1;\n    solveCircLineIntersect(vec2(0.0,0.0),r,a,b,i0,i1);\n    \n    int du = _du;\n    int fadeDu = du*4;\n   \n    \n    int tFaded = fBegin+8*du +fadeDu;\n    if ( iFrame <tFaded )//&&\n    {\n        vec3 c = fadeColor(fBegin+8*du, fadeDu,1.0,color,pixel);\n        if (dir == 0 || dir == 1)\n        {\n            float a0 = atan(i0.y, i0.x);\n            a0 = a0<0.0 ? a0+2.0*PI :a0;\n            // add rotation if a0 within [-PI/12 PI/12]\n            vec2 pa0=  abs(a0)<PI/12.0  ? R(p,CS(PI/12.0)) :p;\n            a0 =  abs(a0)<PI/12.0  ? a0+PI/12.0 : a0;\n            drawArc(pa0,r,_lw,vec2(a0-PI/12.0,a0+PI/12.0), c,du, fBegin,pixel);\n        }\n\n        if (dir == 0 || dir ==-1)\n        {\n            float a1 = atan(i1.y, i1.x);\n            a1 = a1<0.0 ? a1 +2.0*PI:a1;\n            //add rotation if a0 within [-PI/12 PI/12] or [ PI-PI/12, PI + PI/12 ]\n            vec2 pa1= abs(a1)<PI/12.0  ? R(p,CS(-PI/12.0)) :p;\n            a1 = abs(a1)<PI/12.0 ? a1+PI/12.0 : a1;\n            drawArc(pa1,r,_lw,vec2(a1-PI/12.0,a1+PI/12.0), c,du, fBegin,pixel);\n        }\n    }\n    else \n    {\n      fBegin += (dir == 0 || dir ==-1)? du:0;\n      fBegin += (dir == 0 || dir ==1)? du:0;\n    \n    }\n    return vec4(i0,i1);   \n}\n\n// ! assume the line are intersecting !\nvoid solveLineLineIntersect(vec2 p1,vec2 p2, vec2 p3, vec2 p4, out vec2 i0)\n{\n    vec2 p21 =p2 -p1;\n    vec2 p43 = p4-p3;\n    vec2 p13 = p1-p3;\n    \n    float d = (p43.y*p21.x -p43.x*p21.y);\n    float u1 = (p43.x*p13.y-p43.y*p13.x)/d;\n    i0 = p1+u1*p21;\n}\n\n// line perpendicular to l passing by the origin \nvec4 orthoByPoint(vec2 p, vec2 l, vec3 color,\n                    inout vec3 pixel, inout int fBegin)\n{    \n    if ( iFrame -fBegin < fBegin+8*_du +4*_du)\n    {\n        vec4 cli = circLineIntersect(p, S(2.0),vec2(0.0,0.0),l, _c1,0,pixel,fBegin);\n\n        vec4 cci = circCircIntersect( p, cli.xy,S(4.0), cli.zw, S(4.0),\n                                            _c1,0, pixel,fBegin);  \n        return cci;\n    }\n    else\n    {\n        fBegin += 6*_du;\n        return vec4(vec2(0.0),  vec2(-l.y, l.x));\n       \n    }\n}\n\n\nfloat prP(vec2 p, vec2 e, vec2 toProj, vec2 eproj, vec2 dir, vec3 c_blue , vec3 fc, vec3 fc1,float scp,\n            inout vec3 pixel, inout int fBegin)\n{\n    vec2 exy_pxy = toProj-e;\n    drawSegment(p-e, vec2(0.0), exy_pxy*1.2, _lw,\n    fc1, _du, fBegin,pixel); \n    vec2 iA;\n    solveLineLineIntersect( e,toProj,  vec2(scp,0.0), vec2(scp,1.0),  iA);\n    drawPoint(p-iA,_ps, fc, _du, fBegin,pixel);\n    float l=dot(vec2(0.0,1.0), vec2(scp,e.y)-iA);\n    vec4 s1 = animSeg( vec4(iA, vec2(scp,e.y)), vec4(eproj,(eproj +l*dir)), fBegin+_du , _du*4);\n    float fs =_f;\n    _f =1.0;\n    drawSegment(p,s1.xy,s1.zw, _lw*2.0,\n               fc, _du, fBegin,pixel);\n    _f = fs;\n    drawPoint(p-(eproj +l*dir),_ps,fc, _du, fBegin,pixel);\n    return l;\n}\nvec2 prPt(vec2 p,vec2 exy, vec2 exz, vec2 pxy, vec2 pxz , \n            vec2 eproj, vec3 c_blue ,float scp,\n            inout vec3 pixel, inout int fBegin)\n{\n    vec3 fc = fadeColor(fBegin+_du*14, _du*2,1.0,c_blue,pixel);\n    vec3 fc1 = fadeColor(fBegin+_du*14, _du*2,1.0,_c1,pixel);\n    float lx = prP(p, exy, pxy,  eproj,vec2(1.0,0.0), c_blue ,fc,fc1, scp,pixel,  fBegin);\n    float ly = -prP(p,exz, pxz,  eproj, vec2(0.0,-1.0),c_blue , fc,fc1, scp,pixel, fBegin);\n    \n    fBegin+=4*_du;\n    drawSegmentDashed(p-eproj, vec2(lx,-.5), vec2(lx,.5),  _lw,0.003,fc1, _du, fBegin,pixel);\n    drawSegmentDashed(p-eproj, vec2(-.5, ly), vec2(.5,ly),  _lw,0.003,fc1, _du, fBegin,pixel);\n    vec2 res = vec2(lx, ly);\n    drawPoint(p-(eproj+res), _ps,c_blue, _du, fBegin,pixel);\n    return vec2(lx, ly);\n}\n\nvoid draw(in vec2 p,inout vec3 pixel, inout int fBegin)\n{ \n    vec3 lc = _c1;\n    vec3 pc = _pc;\n    float sn = S(_n);\n    float si = 20.0; // label inv scale.\n    //// Draw square ABCD\n    vec2 A = vec2(.5,.25);\n    drawSegment(p-A, V(-_n,0.0),V(2.0*_n,0.0),_lw,\n                 _c1, _du, fBegin,pixel);\n   \n    drawChar((p-A+V(2.5,2.5))*20.0, 65, pc,_du,fBegin,pixel); // A\n    vec4 VA_4 =orthoByPoint(p-A, V(1.0,0.0),lc,pixel, fBegin); // Vertical passing by A\n    vec2 VA = normalize(VA_4.zw - VA_4.xy)*sn;\n    drawSegment(p-A, -VA,3.0*VA,_lw,\n                 _c1, _du, fBegin,pixel);\n    drawPoint(p-A  ,_ps, pc, _du, fBegin,pixel); \n    vec2 B= circLineIntersect(p-A, S(_n),-VA.xy,-VA_4.zw, _c1,1,pixel,fBegin).xy+A; // B\n    drawChar((p-B+V(2.5,2.5))*20.0, 66, pc,_du,fBegin,pixel); // B\n    vec4 HB_4 =orthoByPoint(p-B, V(.0,1.0),lc,pixel, fBegin); // Horizontal passing by B\n    vec2 HB = normalize(HB_4.zw - HB_4.xy)*sn;\n    drawSegment(p-B, HB ,-2.0*HB,_lw,\n                 _c1, _du, fBegin,pixel);  \n    drawPoint(p-B  ,_ps, pc, _du, fBegin,pixel); \n    vec2 C = circLineIntersect(p-B, S(_n),HB_4.zw,HB_4.xy, _c1,1,pixel,fBegin).xy+B;\n    drawChar((p-C+V(2.5,2.5))*20.0, 67, pc,_du,fBegin,pixel); // C\n    vec4 VC_4 =orthoByPoint(p-C, V(1.0,0.0),lc,pixel, fBegin); // Vertical passing by C\n    vec2 VC =normalize(VC_4.zw- VC_4.xy)*sn;\n    drawSegment(p-C, -2.0*VC ,+3.0*VC,_lw,\n                 _c1, _du, fBegin,pixel); \n    drawPoint(p-C  ,_ps, pc, _du, fBegin,pixel); \n    vec2 D;\n    solveLineLineIntersect(C+VC_4.xy,C+VC_4.zw, A ,A + vec2(1.0,0.0),D);  \n    drawPoint(p-D,_ps, pc, _du, fBegin,pixel);\n    drawChar((p-D+V(2.5,2.5))*20.0, 68, pc,_du,fBegin,pixel); // D\n    //// Draw square BFEC\n    vec2 E = circLineIntersect(p-C, S(_n),VC_4.xy,VC_4.zw, _c1,1,pixel,fBegin).xy+C;\n    \n    drawChar((p-E+V(2.5,2.5))*20.0, 69, pc,_du,fBegin,pixel); // E\n    vec2 F = circLineIntersect(p-B, S(_n),VA_4.xy,VA_4.zw, _c1,1,pixel,fBegin).xy+B;\n   \n    drawChar((p-F+V(2.5,2.5))*20.0, 70, pc,_du,fBegin,pixel); // F\n    vec2 HE = normalize(E - F)*sn; \n    drawSegment(p-E,-2.0*HE,1.0*HE, _lw,\n                 _c1, _du, fBegin,pixel); \n    drawPoint(p-F,_ps, pc, _du, fBegin,pixel);\n    drawPoint(p-E,_ps, pc, _du, fBegin,pixel);\n    ////screenPos & eye pos\n    int eye_anim_begin = fBegin+_du*150;\n    float f = float(clamp( iFrame - eye_anim_begin ,0, _du*2))/float(_du*2);\n    float scp = .4 + f*((mix(.1,.8,abs(sin(iTime)))) -.4) ;\n    // screen plane\n    drawSegment(p, vec2(scp,0.0), vec2(scp,1.0), _lw,\n     _c1, _du, fBegin,pixel);  \n    // eye pos.\n    vec3 e = vec3( -1.8*_n,_n*.5+f*_n*cos(iTime),_n*.5+ _n*f*.5*sin(iTime)); \n    vec2 exy =A+S(e.xy);\n    vec3 c_blue = vec3(0.0,.4,.8);\n    drawPoint(p-exy,_ps, c_blue, _du, fBegin,pixel);\n    drawChar((p-exy+V(2.5,2.5))*20.0, 101, c_blue,_du,fBegin,pixel); // e\n    drawSegment(p-exy, vec2(0.0),vec2(.5,0.0), _lw,\n                  fadeColor(fBegin+_du*8, _du*2,1.0,_c1,pixel), _du, fBegin,pixel); \n    drawPoint(p-vec2(scp,exy.y),_ps, c_blue, _du, fBegin,pixel);\n    vec2 exz =B+S(e.xz);\n    drawPoint(p-exz,_ps, c_blue, _du, fBegin,pixel);\n    drawChar((p-exz+V(2.5,2.5))*20.0, 101, c_blue,_du,fBegin,pixel); \n    drawSegment(p-exz, vec2(0.0),vec2(.5,0.0), _lw,\n                  fadeColor(fBegin+_du*8, _du*2,1.0,_c1,pixel), _du, fBegin,pixel); \n    drawPoint(p-vec2(scp,exz.y),_ps, c_blue, _du, fBegin,pixel);\n    //e'\n    vec2 eproj = vec2(1.25, .5);\n    drawSegment(p-eproj,vec2(-.5,0.0),vec2(.5,0.0), _lw,\n                 _c1, _du, fBegin,pixel); \n    drawSegment(p-eproj,vec2(0.0,-.5),vec2(0.0,.5), _lw,\n     _c1, _du, fBegin,pixel); \n    drawPoint(p-eproj,_ps, c_blue, _du, fBegin,pixel);\n    drawChar((p-eproj+V(2.5,2.5))*20.0, 101, c_blue,_du,fBegin,pixel); \n    drawChar((p-eproj+V(1.5,2.5))*20.0, 39, c_blue,_du,fBegin,pixel); \n    if (iFrame > _du*50)\n    {\n        //persp projections\n        vec2 _0 = prPt(p,exy, exz, A, B, eproj, c_blue, scp,pixel,fBegin);\n        vec2 _1 = prPt(p,exy, exz, B, B, eproj, c_blue, scp,pixel,fBegin);\n        drawSegment(p-eproj,_0,_1, _lw,\n        _c1, _du, fBegin,pixel);  \n        vec2 _2 = prPt(p,exy, exz, D, C, eproj, c_blue, scp,pixel,fBegin);\n        vec2 _3 =prPt(p,exy, exz, C, C, eproj, c_blue, scp,pixel,fBegin);\n        drawSegment(p-eproj,_2,_3, _lw,\n        _c1, _du, fBegin,pixel); \n        drawSegment(p-eproj,_0,_2, _lw,\n        _c1, _du, fBegin,pixel); \n        drawSegment(p-eproj,_1,_3, _lw,\n        _c1, _du, fBegin,pixel); \n        //\n\n        vec3 cfill = colorAtTime(pixel,pc, _du, .3, fBegin);\n        float td = sdTriangle(p-eproj,_0,_1,_2);\n        fill(td,  cfill,pixel);\n        td = sdTriangle(p-eproj,_1,_3,_2);\n        fill(td,  cfill,pixel);\n        //\n        td = sdTriangle(p,A,B,D);\n        fill(td,  cfill,pixel);\n        td = sdTriangle(p,B,C,D);\n        fill(td,  cfill,pixel);\n        //\n        vec2 _4 = prPt(p,exy, exz, A, F, eproj, c_blue, scp,pixel,fBegin);\n        vec2 _5 = prPt(p,exy, exz, B, F, eproj, c_blue, scp,pixel,fBegin);\n        drawSegment(p-eproj,_4,_5, _lw,\n        _c1, _du, fBegin,pixel); \n        drawSegment(p-eproj,_0,_4, _lw,\n        _c1, _du, fBegin,pixel); \n        drawSegment(p-eproj,_1,_5, _lw,\n        _c1, _du, fBegin,pixel); \n        vec2 _6 = prPt(p,exy, exz, D, E, eproj, c_blue, scp,pixel,fBegin);\n        vec2 _7 = prPt(p,exy, exz, C, E, eproj, c_blue, scp,pixel,fBegin);\n        drawSegment(p-eproj,_6,_7, _lw,\n        _c1, _du, fBegin,pixel);\n        drawSegment(p-eproj,_4,_6, _lw,\n        _c1, _du, fBegin,pixel); \n        drawSegment(p-eproj,_5,_7, _lw,\n        _c1, _du, fBegin,pixel); \n        drawSegment(p-eproj,_2,_6, _lw,\n        _c1, _du, fBegin,pixel); \n        drawSegment(p-eproj,_3,_7, _lw,\n        _c1, _du, fBegin,pixel);\n\n        //\n\n        vec3 cfill1 = colorAtTime(pixel,_cBlue, _du, .3, fBegin);\n        td = sdTriangle(p,B,F,C);\n        fill(td,  cfill1,pixel);\n         td = sdTriangle(p,F,C,E);\n        fill(td,  cfill1,pixel);\n\n        td = sdTriangle(p-eproj,_2,_3,_6);\n        fill(td,  cfill1,pixel);\n        td = sdTriangle(p-eproj,_3,_6,_7);\n        fill(td,  cfill1,pixel);\n    }\n  \n}\n\n//Integer hash https://www.shadertoy.com/view/fsKBzw\nfloat hash( vec2 f )\n{   uvec2 //x = vec2BitsToUvec2 uvec2( floatBitsToUint(f.x), floatBitsToUint(f.y) ),\n          x = floatBitsToUint(f),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(a,b,u.x), mix(c,d,u.x),u.y);\n}\n\nfloat fbm( in vec2 p )\n{\n    float a =1.0;   \n\tfloat f=0.0;\n    f  =a*noise( p ); p = p*2.0; a*=.5;\n    f += a*noise( p ); p = p*2.0; a*=.5;\n    f += a*noise( p ); p = p*2.0; a*=.5;\n    f += a*noise( p ); p = p*2.0; a*=.5;\n    f += a*noise( p ); p = p*2.0; a*=.5;\n    f += a*noise( p ); \n    return f;\n}\n                  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   // Normalized pixel coordinates (from 0 to 1)\n   vec2 uv = fragCoord/iResolution.y;\n   _pixSize = 1.0/iResolution.y;\n   \n   \n   int fBegin=0;\n   \n   // background.\n   _f = fbm(fragCoord/16.0);\n   vec2 d = vec2(dFdx(_f),dFdy(_f));\n   \n   vec3 pixel =vec3(.8)+ .3*(d.x);\n    \n   draw(uv,pixel,fBegin);\n  \n   // vignette\n   vec2 q = fragCoord/iResolution.xy;\n   float vi= 0.5 + 0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.15);\n\n   // Output to screen\n   fragColor = vec4(pixel*vi,1.0);\n   \n}","name":"Image","description":"","type":"image"}]}