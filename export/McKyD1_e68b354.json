{"ver":"0.1","info":{"id":"McKyD1","date":"1731830280","viewed":72,"name":"Stylized Lens Flare Star v2","username":"8InfinityTaco8","description":"Yet another variant ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["star","lensflare","lensflare","stylized"],"hasliked":0,"parentid":"lcKcWh","parentname":"Stylized Lens Flare Star v0"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float u_transitionAmount; // Controls transition between states\n\nfloat hash(float n) { \n    return fract(sin(n) * 43758.5453123); \n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise2D(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    float a = hash(i.x + i.y * 57.0);\n    float b = hash(i.x + 1.0 + i.y * 57.0);\n    float c = hash(i.x + (i.y + 1.0) * 57.0);\n    float d = hash(i.x + 1.0 + (i.y + 1.0) * 57.0);\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nvec3 calculateSimpleFlare(vec2 uv) {\n    float flareIntensity = 0.0;\n    float eps = 0.001;\n    \n    // Make all lines start extremely small (dot-like)\n    float hLength = mix(0.05, 1.0, u_transitionAmount);  // Start at 5% of original size\n    float diagLength = mix(0.03, 1.0, u_transitionAmount); // Start even smaller for diagonals\n    \n    vec2 scaledUV = uv * vec2(hLength);\n    vec2 diagScaledUV = uv * vec2(diagLength);\n    \n    // Reduce initial intensity\n    float baseIntensity = mix(0.002, 0.01, u_transitionAmount);\n    float diagIntensity = mix(0.001, 0.005, u_transitionAmount);\n    \n    float horizontalFlare = baseIntensity / (abs(scaledUV.x) + eps);\n    horizontalFlare *= smoothstep(hLength, 0.0, abs(uv.y));\n    \n    float verticalFlare = baseIntensity / (abs(scaledUV.y) + eps);\n    verticalFlare *= smoothstep(hLength, 0.0, abs(uv.x));\n    \n    float diagonalFlare1 = diagIntensity / (abs(diagScaledUV.x + diagScaledUV.y) + eps);\n    float diagonalFlare2 = diagIntensity / (abs(diagScaledUV.x - diagScaledUV.y) + eps);\n    \n    diagonalFlare1 *= smoothstep(diagLength, 0.0, length(uv));\n    diagonalFlare2 *= smoothstep(diagLength, 0.0, length(uv));\n    \n    flareIntensity = horizontalFlare + verticalFlare + diagonalFlare1 + diagonalFlare2;\n    \n    // Tighter initial fade\n    float fadeStrength = mix(3.6, 1.8, u_transitionAmount);\n    flareIntensity *= exp(-length(uv) * fadeStrength);\n    \n    vec3 flareColor = vec3(1.0, 0.8, 0.6);\n    return flareColor * flareIntensity * mix(0.05, 0.15, u_transitionAmount);\n}\n\nvec3 calculateComplexFlare(vec2 uv, float flickerIntensity, float transitionAmount) {\n    float flareIntensity = 0.0;\n    float eps = 0.001;\n    \n    // Start extremely small\n    float baseLength = mix(0.05, 1.2, transitionAmount);\n    float diagBaseLength = mix(0.03, 1.2, transitionAmount);\n    \n    vec2 scaledUV = uv * vec2(baseLength);\n    vec2 diagScaledUV = uv * vec2(diagBaseLength);\n    \n    // Reduce initial intensities\n    float horizontalLength = 0.01 * (0.05 + transitionAmount * 1.75);\n    float verticalLength = 0.01 * (0.05 + transitionAmount * 1.75);\n    float diagonalLength = 0.0025 * (0.05 + transitionAmount * 1.75);\n    \n    float time = iTime;\n    vec2 stretchUV = scaledUV * 2.0;\n    vec2 diagStretchUV = diagScaledUV * 2.0;\n    \n    float dynHorizLength = horizontalLength * mix(0.2, 2.0 + transitionAmount * 2.0, noise2D(stretchUV * 2.0 + time));\n    float dynVertLength = verticalLength * mix(0.2, 2.0 + transitionAmount * 2.0, noise2D(stretchUV * 2.0 + time * 0.8));\n    float dynDiagLength1 = diagonalLength * mix(0.2, 2.0 + transitionAmount * 2.5, noise2D(diagStretchUV * 2.0 + time * 0.9));\n    float dynDiagLength2 = diagonalLength * mix(0.2, 2.0 + transitionAmount * 2.5, noise2D(diagStretchUV * 2.0 + time * 1.1));\n    \n    float pulse = sin(time * (2.0 + transitionAmount * 3.0)) * 0.5 + 0.5;\n    pulse *= transitionAmount;\n    \n    float horizontalFlare = dynHorizLength / (abs(scaledUV.x) + eps);\n    horizontalFlare *= smoothstep(baseLength, 0.0, abs(uv.y));\n    \n    float verticalFlare = dynVertLength / (abs(scaledUV.y) + eps);\n    verticalFlare *= smoothstep(baseLength, 0.0, abs(uv.x));\n    \n    float diagAttenuation = smoothstep(diagBaseLength * 1.5, 0.0, length(uv));\n    \n    float diagonalFlare1 = dynDiagLength1 / (abs(diagScaledUV.x + diagScaledUV.y) + eps);\n    diagonalFlare1 *= diagAttenuation;\n    \n    float diagonalFlare2 = dynDiagLength2 / (abs(diagScaledUV.x - diagScaledUV.y) + eps);\n    diagonalFlare2 *= diagAttenuation;\n    \n    flareIntensity = horizontalFlare + verticalFlare + diagonalFlare1 + diagonalFlare2;\n    \n    // Tighter initial fade\n    float distanceFade = exp(-length(uv) * (4.0 + noise2D(uv + time * 0.1)) * (2.0 - transitionAmount));\n    flareIntensity *= distanceFade * flickerIntensity;\n    \n    vec3 baseColor = vec3(1.0, 0.8, 0.6);\n    vec3 energizedColor = vec3(1.0, 0.7, 0.4);\n    vec3 flareColor = mix(baseColor, energizedColor, transitionAmount * pulse);\n    \n    return flareColor * flareIntensity * mix(0.05, 1.0, transitionAmount);\n}\n\nfloat smoothFlicker(float t, float transitionAmount) {\n    return mix(\n        noise(t * (3.0 + transitionAmount * 5.0)),\n        noise(t * (6.0 + transitionAmount * 8.0)),\n        0.5\n    ) * (0.8 + transitionAmount * 0.2) + 0.2;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    u_transitionAmount = abs(sin(iTime * 0.4));\n    \n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec2 simpleMovement = vec2(\n        sin(iTime * 0.5) * 0.5,\n        cos(iTime * 0.3) * 0.3\n    );\n    \n    vec2 complexMovement = vec2(\n        sin(iTime * 0.2) * 0.3,\n        sin(iTime * 0.2) * 0.3\n    );\n    \n    vec2 movement = mix(simpleMovement, complexMovement, u_transitionAmount);\n    uv += movement;\n    \n    float flickerIntensity = smoothFlicker(iTime, u_transitionAmount);\n    vec3 simpleFlare = calculateSimpleFlare(uv);\n    vec3 complexFlare = calculateComplexFlare(uv, flickerIntensity, u_transitionAmount);\n    \n    vec3 color = mix(simpleFlare, complexFlare, u_transitionAmount);\n    \n    vec3 simpleBg = vec3(0.05);\n    vec3 complexBg = vec3(0.05) + vec3(0.02 + u_transitionAmount * 0.05) * noise2D(uv + iTime * 0.1);\n    color += mix(simpleBg, complexBg, u_transitionAmount);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}