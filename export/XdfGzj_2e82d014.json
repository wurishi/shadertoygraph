{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const int STEPS = 96;\nconst float EPSILON = 0.01;\nconst float FAR = 70.0;\nconst float AO_STEPS = 5.0;\nconst float AO_DIST = 1.5;\nconst float PI = 3.1415926;\n\nfloat noise(vec2 uv)\n{\n\treturn fract(sin(dot(uv ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 schlick(vec3 f0, vec3 h, vec3 v)\n{\n\treturn f0 + (1.0 - f0) * pow(1.0 - dot(h,v), 5.0);\n}\n\nvec3 sampleHemi(float u1, float u2, vec3 n)\n{\n\tvec3 v = abs(n.y) < abs(n.z) ? vec3(0.0,1.0,0.0) : vec3(0.0,0.0,1.0);\n\tvec3 w = normalize(cross(n,v));\n\tv = normalize(cross(w,n));\n\t\n\tfloat r = sqrt(u1);\n\tfloat theta = 2.0 * PI * u2;\n\tfloat x = r * cos(theta);\n\tfloat y = r * sin(theta);\n\treturn normalize(n * sqrt(1.0 - u1) + v*x + w*y);\n}\n\nvec3 rotateX(vec3 pt, float theta)\n{\n\treturn vec3(pt.x, cos(theta)*pt.y + sin(theta)*pt.z, cos(theta)*pt.z - sin(theta)*pt.y);\n}\n\nvec3 rotateY(vec3 pt, float theta)\n{\n\treturn vec3(cos(theta)*pt.x + sin(theta)*pt.z, pt.y, cos(theta)*pt.z - sin(theta)*pt.x);\n}\n\nfloat d_plane(vec3 pt, vec4 pln)\n{\n\treturn dot(pt, pln.xyz) - pln.w;\n}\n\nfloat d_sphere(vec3 pt, vec4 sph)\n{\n\treturn length(pt - sph.xyz) - sph.w;\n}\n\nfloat d_spiral(vec3 pt)\n{\n\tpt.x += sin(pt.y) * cos(iTime);\n\tpt.z += cos(pt.y) * sin(iTime);\n\tpt = rotateY(pt,pt.y);\n\treturn length(pt.xz) - 1.5*(2.0 + cos(iTime));\n}\n\nfloat dist(vec3 pt)\n{\n\tfloat d0 = d_plane(pt, vec4(0.0,1.0,0.0,-3.0));\n\t\n\tvec3 pt2 = vec3(mod(pt.x,14.0)-7.0,pt.y,mod(pt.z,14.0)-7.0);\n\tfloat d1 = d_sphere(pt2, vec4(0.0,0.0,0.0,4.0));\n\tpt2 = rotateY(pt2,iTime);\n\tfloat d2 = d_spiral(pt2);\n\td2 += sin(2.0*pt2.x)*cos(2.0*pt2.y)*sin(cos(iTime*4.0)*pt2.z)*0.5;\n\tfloat t = 1.0 - exp(-pt.y/4.0);\n\treturn min(d0,mix(d1,d2,t));\n}\n\nvec3 calc_normal(vec3 pos)\n{\n\tvec3 res;\n\tres.x = dist(pos + vec3(EPSILON,0.0,0.0)) - dist(pos - vec3(EPSILON,0.0,0.0));\n\tres.y = dist(pos + vec3(0.0,EPSILON,0.0)) - dist(pos - vec3(0.0,EPSILON,0.0));\n\tres.z = dist(pos + vec3(0.0,0.0,EPSILON)) - dist(pos - vec3(0.0,0.0,EPSILON));\n\treturn normalize(res);\n}\n\nvec4 march(vec3 ro, vec3 rd)\n{\n\tfloat t = 0.0;\n\tfor (int i=0; i<STEPS; i++)\n\t{\n\t\tvec3 pt = ro + rd * t;\n\t\tfloat d = dist(pt);\n\t\tif (abs(d) < EPSILON)\n\t\t\treturn vec4(pt,1.0);\n\t\tt += d;\n\t\tif (t >= FAR)\n\t\t\tbreak;\n\t}\n\treturn vec4(0.0);\n}\n\nfloat calc_ao(vec3 p, vec3 n)\n{\n\tfloat r = 0.0;\n\tfloat w = 1.0;\n\tfor (float i=0.0; i<AO_STEPS; i++)\n\t{\n\t\tfloat d = ((i + 1.0) / AO_STEPS) * AO_DIST;\n\t\tr += w * (d - dist(p + n * d));\n\t\tw *= 0.5;\n\t}\n\treturn 1.0 - clamp(r,0.0,1.0);\n}\n\nfloat calc_shadow(vec3 p, vec3 l)\n{\n\tfloat r = 1.0;\n\tfloat t = 0.0;\n\tfor (float i=0.0; i<16.0; i++)\n\t{\n\t\tvec3 pt = p + l * t;\n\t\tfloat d = dist(pt);\n\t\tif (d < EPSILON)\n\t\t\treturn 0.0;\n\t\t\n\t\tr = min(r,32.0*d/t);\n\t\tt += clamp(d,0.01,4.0);\n\t}\n\treturn r;\n}\n\nvec3 diffuse(vec3 p, vec3 n, vec2 fragCoord)\n{\n\tvec3 clr = vec3(0.0);\n\tvec3 t = vec3(0.0,1.0,0.0);\n\tif (dot(t,n) < 0.001)\n\t\tt = vec3(0.0,0.0,1.0);\n\tvec3 b = cross(n,t);\n\tt = normalize(cross(b,n));\n\t\n\tfor (float i=0.0; i<8.0; i++)\n\t{\n\t\tfor (float j=0.0; j<8.0; j++)\n\t\t{\n\t\t\tvec2 s = vec2(i,j)*vec2(sin(iTime))*fragCoord.xy;\n\t\t\tfloat u = (noise(n.xy+s)+i)*0.125;\n\t\t\tfloat v = (noise(n.yz+s)+j)*0.125;\n\t\t\tvec3 n0 = sampleHemi(u*0.5,v,n);\n\t\t\tclr += pow(texture(iChannel1,n0).rgb, vec3(2.2));\n\t\t}\n\t}\n\t\n\treturn clr * 0.125 * 0.125;\n}\n\nvec3 shade(vec3 pos, vec3 v, vec2 fragCoord)\n{\n\tconst float spec_power = 128.0;\n\tfloat normalization = (spec_power + 2.0) / (2.0 * PI);\n\t\n\tvec3 ldir = normalize(vec3(cos(iTime),1.0,sin(iTime)));\n\tvec3 n = calc_normal(pos);\n\tvec3 h = normalize(n+ldir);\n\tfloat ndl = max(dot(n,ldir),0.0);\n\tfloat ndh = max(dot(n,h),0.0);\n\tvec3 fresnel = schlick(vec3(0.05,0.05,0.05),h,v);\n\tvec3 spec = vec3(pow(ndh, spec_power)) * normalization * ndl * (PI / 4.0);\n\tvec3 diff = vec3(ndl);\n\tvec3 lcolor = spec * fresnel + diff;\n\tfloat shadow = calc_shadow(pos + n * 0.1, ldir);\n\treturn lcolor*shadow + calc_ao(pos,n) * diffuse(pos,n,fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 rd = normalize(vec3((-1.0 + 2.0 * uv)*vec2(iResolution.x/iResolution.y,1.0), 1.0));\n\tvec3 ro = vec3(0.0, 4.0, -10.0);\n\tvec3 forward = vec3(0.0, 0.0, 1.0);\n\t\n\tfloat theta_y = sin(iTime) * 0.5;\n\trd = rotateY(rd, theta_y);\n\tro += forward * iTime * 8.0;\n\tro.x = cos(iTime) * 2.0;\n\tro.y = sin(iTime) * 4.0 + 6.0;\n\t\n\tvec4 res = march(ro,rd);\n\tif (res.w == 1.0)\n\t{\n\t\tvec4 clr = vec4(pow(shade(res.xyz,rd,fragCoord), vec3(0.45)), 1.0);\n\t\tfragColor = clr;\n\t}\n\telse\n\t{\n\t\tfragColor = texture(iChannel0,rd);\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdfGzj","date":"1373930045","viewed":868,"name":"Spiral Repetition","username":"synulation","description":"Just messing around, trying out shadertoy.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["procedural","raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""}}