{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//------------------------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\n//------------------------------------------------------------\nvec2 z0=vec2( 1.0, 0.0 );\nfloat n;\n\nvec2 f( vec2 x ){return cpow(x, n) + vec2(-1.0, 0.0 )  ;}\n\n\nvec2 df( vec2 z )\n{\t\n    return n*cpow(z,n-1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfloat range =4.0;\nvec2 q = (fragCoord.xy-iMouse.xy) / iResolution.xy;\n\nvec2 p = -0.5*range + range * q;\n\np.y=p.y*iResolution.y/iResolution.x;\nn = 1.00+4.0*sin(0.1*iTime);\t\t\n\n// iterate\t\t\nvec2 dz = vec2( 1.0, 0.0 );\nvec2 z = vec2( 1.0, 0.0 );\nz0=p;\nfloat iter = 0.0;\nfloat k=300.0;\nfor( int i=0; i<300; i++ )\n    {\t\t\n    // derivative\n    vec2 dfz = df( z );\t\t\n\t\t\n    // nova formula\t\t\n    if(dot(dfz,dfz)==0.0)break;\n    vec2 z1=z;\n    z = z-cdiv(f( z ),dfz)-z0;\n    dz =z-z1;\n        \n    \t\n        if( dot(dz,dz)<0.00001 ){\n            k = dot(dz,dz)/0.00001;\n            z = k*z+(1.0-k)*z1;\n            k+= iter;\n            break;\n        }\n        if( dot(dz,dz)>10000.0 ){\n            k = 10000.0/(dot(dz,dz));\n            z = k*z+(1.0-k)*z1;\n            k+= iter;\n            break;\n            }  \n    iter++;\n    }\n\n// normalized iterator\t\t\n\nfloat h=1.0-(k/300.0);\n\n\n//vec3 col = normalize( vec3(1+h,z.x,z.y)) ;\nvec3 col = 0.2+0.2*sin(vec3(0.0,z.x,z.y)+3.0)+ 0.6*sin(vec3(-0.5,-0.2,0.8)+2.3-0.5*log(k));\ncol *= sqrt(h);\nfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsBGRh","date":"1383415101","viewed":289,"name":"Nova to mandelbrot","username":"guil","description":"Oscillation between a nova fractal and a Mandelbrot set by varying the parameter n in a slightly modified nova formula","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","fractal"],"hasliked":0,"parentid":"","parentname":""}}