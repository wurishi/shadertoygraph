{"ver":"0.1","info":{"id":"fdjGD3","date":"1618433717","viewed":108,"name":"CG2021 - 2 Task","username":"Teo","description":"Second Task of course - Computer Graphics 2021, MSU-IIT","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["msuiitcg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(4.5, 3., -3.5);\n\nvec3 L1_POS = vec3(-2, 1.5, 0.0);\nconst float L1_RADIUS = 0.5;\nconst vec3 L1_COLOR = vec3(-2, 1, -3);\n\nvec3 L2_POS = vec3(2, 2, 1);\nconst float L2_RADIUS = 0.25;\nconst vec3 L2_COLOR = vec3(1.0, 1.0, 0.0);\n\nconst vec3 L3_POS = vec3(0.5, 2, 1.3);\nconst float L3_RADIUS = 0.4;\nconst vec3 L3_COLOR = vec3(1.0, 0.4, 0.8);\n\n// My Figure Points\nconst vec3 downP = vec3(0, -1, 0);\nconst vec3 LeftP = vec3(1, 0.5, -1);\nconst vec3 RightP = vec3(-1, 0.5, -1);\nconst vec3 LeftP1 = vec3(1, 0.5, 1);\nconst vec3 RightP1 = vec3(-1, 0.5, 1);\nconst vec3 upP = vec3(0, 2, 0);\n\nvec3 randDir;\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal)\n{\n    float t = (-1.5 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    \n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0) {\n        return INF;\n    }\n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceSphere(vec3 pos, vec3 dir, float r, out vec3 normal) \n{\n    float a = dot(dir, dir);\n    float b = dot(pos, dir);\n    float c = dot(pos, pos) - r * r;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    float t = -b - sqrt(D);\n    if (t > 0.0) {\n        normal = normalize(pos + t * dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0) {\n        return INF;\n    }\n    normal = normalize(pos + t * dir);\n    return t;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir, vec3 x0, vec3 x1, vec3 x2, out vec3 normal)\n{\n    const float EPS = 0.0000001;\n    vec3 edge1, edge2, h, s, q;\n    float a,f,u,v;\n    edge1 = x1 - x0;\n    edge2 = x2 - x0;\n    h = cross(dir, edge2);\n    a = dot(edge1, h);\n    if (a > -EPS && a < EPS) {\n        return INF;    // This ray is parallel to this triangle.\n    }\n    f = 1.0/a;\n    s = pos - x0;\n    u = dot(f * s, h);\n    if (u < 0.0 || u > 1.0) {\n        return INF;\n    }\n    q = cross(s, edge1);\n    v = dot(f * dir, q);\n    if (v < 0.0 || u + v > 1.0) {\n        return INF;\n    }\n    // At this stage we can compute t to find out where the intersection point is on the line.\n    float t = dot(f * edge2, q);\n    if (t > EPS) // ray intersection\n    {\n        // outIntersectionPoint = pos + dir * t;\n        normal = normalize(cross(edge1, edge2));\n        if(dot(normal, dir) <0.0){\n        normal = -normal;\n        }\n        return t;\n    }\n    else // This means that there is a line intersection but not a ray intersection.\n        return INF;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < 0.6) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - 0.6;\n    float D = b * b - a * c;\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) {\n        return INF;\n    }\n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}\n\nbool isOccluded(vec3 pos, vec3 target) \n{\n    vec3 rvec = target - pos;\n    float dist = length(rvec);\n    vec3 dir = rvec / dist;\n    \n    vec3 normal = vec3(0, 0, 0);\n    \n    float triT1= traceTriangle(pos, dir, downP, LeftP, RightP, normal);\n    if (triT1 < dist)\n        return true;\n    float triT2= traceTriangle(pos, dir, downP, LeftP, LeftP1, normal);\n    if (triT2 < dist)\n        return true;\n    float triT3= traceTriangle(pos, dir, downP, RightP, RightP1, normal);\n    if (triT3 < dist)\n        return true;\n    float triT4= traceTriangle(pos, dir, downP, LeftP1, RightP1, normal);\n    if (triT4 < dist)\n        return true;\n    float triT5= traceTriangle(pos, dir, upP, LeftP, RightP, normal);\n    if (triT5 < dist)\n        return true;   \n    float triT6= traceTriangle(pos, dir, upP, LeftP, LeftP1, normal);\n    if (triT6 < dist)\n        return true;\n    float triT7= traceTriangle(pos, dir, upP, RightP, RightP1, normal);\n    if (triT7 < dist)\n        return true;\n    float triT8= traceTriangle(pos, dir, upP, LeftP1, RightP1, normal);\n    if (triT8 < dist)\n        return true;\n        \n    return false;\n}\n\nvec3 computeLight(vec3 worldPos, vec3 color, vec3 normal) \n{\n    vec3 lightPos = L1_POS + randDir * L1_RADIUS;\n    vec3 toLight = lightPos - worldPos;\n    bool occl = isOccluded(worldPos, lightPos);\n    float lightAtten = 10.0f / dot(toLight, toLight) * (occl ? 0.0 : 1.0);\n\n    vec3 light2Pos = L2_POS + randDir * L2_RADIUS;\n    vec3 toLight2 = light2Pos - worldPos;\n    bool occl2 = isOccluded(worldPos, light2Pos);\n    float light2Atten = 20.0f / dot(toLight2, toLight2) * (occl2 ? 0.0 : 1.0);\n    \n    vec3 light3Pos = L3_POS + randDir * L3_RADIUS;\n    vec3 toLight3 = light3Pos - worldPos;\n    bool occl3 = isOccluded(worldPos, light3Pos);\n    float light3Atten = 30.0f / dot(toLight3, toLight3) * (occl3 ? 0.0 : 1.0);\n\n\n    return color * (max(0.0f, dot(normal, normalize(toLight))) * lightAtten * L1_COLOR\n        + max(0.0f, dot(normal, normalize(toLight2))) * light2Atten * L2_COLOR\n        + max(0.0f, dot(normal, normalize(toLight3))) * light3Atten * L3_COLOR\n        + texture(iChannel1, normal).rgb * 0.1).rgb;\n}\n\nfloat rand(float frame)\n{\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if(sinB > 1.0)\n    {\n        return reflect(v, normal);\n    }\n    float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}\n\n// complicated pink color\nfloat colormap_red(float x)\n{\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_green(float x) \n{\n    if (x < 20049.0 / 82979.0) {\n        return 0.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\n    } else if (x <= 1.0) {\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nfloat colormap_blue(float x) \n{\n    if (x < 0.0) {\n        return 54.0 / 255.0;\n    } else if (x < 7249.0 / 82979.0) {\n        return (829.79 * x + 54.51) / 255.0;\n    } else if (x < 20049.0 / 82979.0) {\n        return 127.0 / 255.0;\n    } else if (x < 327013.0 / 810990.0) {\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\n    } else {\n        return 1.0;\n    }\n}\n\nvec4 colormap(float x) \n{\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\n}\n\nfloat rand(vec2 n) \n{ \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n\n    return f/0.96875;\n}\n\nfloat pattern( in vec2 p )\n{\n\treturn fbm( p + fbm( p + fbm( p ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    randDir = normalize(randVals - 0.5);\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randVals.xy - 0.5)) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up * uv.y);\n    \n    L1_POS = L1_POS + randVals*0.2;\n    L2_POS = L2_POS + randVals*0.1;\n     \n    const int EMISS = 0;\n    const int DIFF = 1;\n    const int REFL = 2;\n    const int REFR = 3;\n    \n    const float GLASS_N = 1.5;\n    const float AIR_N = 1.0;\n    float GLASS_R = ((AIR_N - GLASS_N)*(AIR_N - GLASS_N))/((AIR_N + GLASS_N)*(AIR_N + GLASS_N));\n    float n1 = AIR_N;\n    const float DIAMOND_N = 2.5;\n    float DIAMOND_R = ((DIAMOND_N - GLASS_N)*(DIAMOND_N - GLASS_N)) / ((DIAMOND_N + GLASS_N)*(DIAMOND_N + GLASS_N));\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    vec3 colorMult = vec3(1, 1, 1);\n    \n    for (int i = 0; i < 100; ++i)\n    {\n        float t = INF;\n        int material;\n        vec3 color;\n        vec3 normal;\n        float nEnter = AIR_N;\n        \n        vec3 planeN;\n        float planeT = tracePlane(curPos, curDir, planeN);\n        if (planeT < t) \n        {\n            t = planeT;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel0, worldPos.xz*0.3).rgb;\n            normal = planeN;\n        }\n        \n        vec3 l1N;\n        float light1T = traceSphere(curPos - L1_POS, curDir, L1_RADIUS, l1N);\n        if (light1T < t)\n        {\n            t = light1T;\n            material = EMISS;\n            color = L1_COLOR;\n            normal = l1N;\n        }\n        vec3 l2N;\n        float light2T = traceSphere(curPos - L2_POS, curDir, L2_RADIUS, l2N);\n        if (light2T < t) \n        {\n            t = light2T;\n            material = EMISS;\n            color = L2_COLOR;\n            normal = l2N;\n        }\n        vec3 l3N;\n        float light3T = traceSphere(curPos - L3_POS, curDir, L3_RADIUS, l3N);\n        if (light3T < t) \n        {\n            t = light3T;\n            material = EMISS;\n            color = L3_COLOR;\n            normal = l3N;\n        }\n        // 1 side front down\n        vec3 TriagN1;\n        float TriagT1 = traceTriangle(curPos, curDir, downP, RightP, LeftP, TriagN1);\n        if (TriagT1 < t)\n        {\n            t = TriagT1;\n            normal = TriagN1;\n            if (randVals.x < GLASS_R*7.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.5, 0.5, 0.5);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        // 2 side back down\n        vec3 TriagN2;\n        float TriagT2 = traceTriangle(curPos, curDir, downP, LeftP1, RightP1, TriagN2);\n        if (TriagT2 < t) \n        {\n            t = TriagT2;\n            normal = TriagN2;\n            if (randVals.x < GLASS_R*7.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.75, 0.75, 0.75);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        // 3 side left down\n        vec3 TriagN3;\n        float TriagT3 = traceTriangle(curPos, curDir, downP, LeftP, LeftP1, TriagN3);\n        if (TriagT3 < t) \n        {\n            t = TriagT3;\n            normal = TriagN3;\n            if (randVals.x < GLASS_R*7.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.75, 0.75, 0.75);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        // 4 side right down\n        vec3 TriagN4;\n        float TriagT4 = traceTriangle(curPos, curDir, downP, RightP, RightP1, TriagN4);\n        if (TriagT4 < t) \n        {\n            t = TriagT4;\n            normal = TriagN4;\n            if (randVals.x < GLASS_R*7.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.75, 0.75, 0.75);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        // 5 side front up\n        vec3 TriagN5;\n        float TriagT5 = traceTriangle(curPos, curDir, upP, RightP, LeftP, TriagN5);\n        if (TriagT5 < t) \n        {\n            t = TriagT5;\n            normal = TriagN5;\n            if (randVals.x < GLASS_R*4.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.75, 0.75, 1);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        // 6 side back up\n        vec3 TriagN6;\n        float TriagT6 = traceTriangle(curPos, curDir, LeftP1, upP, RightP1, TriagN6);\n        if (TriagT6 < t) \n        {\n            t = TriagT6;\n            normal = TriagN6;\n            if (randVals.x < GLASS_R*4.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.75, 0.75, 1);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        // 7 side left up\n        vec3 TriagN7;\n        float TriagT7 = traceTriangle(curPos, curDir, upP, LeftP1, LeftP, TriagN7);\n        if (TriagT7 < t) \n        {\n            t = TriagT7;\n            normal = TriagN7;\n            if (randVals.x < GLASS_R*4.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.75, 0.75, 1);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        // 8 side right up\n        vec3 TriagN8;\n        float TriagT8 = traceTriangle(curPos, curDir, upP, RightP, RightP1, TriagN8);\n        if (TriagT8 < t) \n        {\n            t = TriagT8;\n            normal = TriagN8;\n            if (randVals.x < GLASS_R*4.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(0.75, 0.75, 1);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = AIR_N;\n                } else {\n                    nEnter = GLASS_N;\n                }\n            }\n        }\n        \n        vec3 cylN;\n        float cylT = traceCylinder(curPos, curDir, cylN);\n        if (cylT < t) {\n            t = cylT;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = texture(iChannel3, worldPos.xz * worldPos.y*0.5).rgb;\n            normal = cylN;\n        }\n        \n        vec3 sphN;\n        float sphT = traceSphere(curPos+vec3(-0.3,-0.1,-0.35), curDir, 0.09, sphN);\n        if (sphT < t) {\n            t = sphT;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = colormap(pattern(worldPos.xy)).rgb*100.0;\n            normal = sphN;\n        }\n        \n        float sph2T = traceSphere(curPos+vec3(0.4,-0.8,-0.35), curDir, 0.25, sphN);\n        if (sph2T < t) {\n            t = sph2T;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = colormap(pattern(worldPos.xy)).rgb*50.0;\n            normal = sphN;\n        }\n        \n        float sph3T = traceSphere(curPos+vec3(0.1,-0.4, 0.55), curDir, 0.27, sphN);\n        if (sph3T < t) {\n            t = sph3T;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = colormap(pattern(worldPos.xy)).rgb*50.0;\n            normal = sphN;\n        }\n        \n        float sph4T = traceSphere(curPos+vec3(0.15,-0.6, 0.5), curDir, 0.2, sphN);\n        if (sph4T < t) {\n            t = sph4T;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = colormap(pattern(worldPos.xy)).rgb*50.0;\n            normal = sphN;\n        }\n        \n        float sph5T = traceSphere(curPos+vec3(-0.2,-0.35, 0.7), curDir, 0.15, sphN);\n        if (sph5T < t) {\n            t = sph5T;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = colormap(pattern(worldPos.xy)).rgb*50.0;\n            normal = sphN;\n        }\n        \n        float sph6T = traceSphere(curPos+vec3(-0.05,0.35, 0.0), curDir, 0.19, sphN);\n        if (sph6T < t) {\n            t = sph6T;\n            normal = sphN;\n            if (randVals.x < DIAMOND_R*10.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(1, 3, 0.1);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = GLASS_N;\n                } else {\n                    nEnter = DIAMOND_N;\n                }\n            }\n        }\n        \n        float sph7T = traceSphere(curPos+vec3(-0.2,-1.3,-0.3), curDir, 0.2, sphN);\n        if (sph7T < t) {\n            t = sph7T;\n            normal = sphN;\n            if (randVals.x < DIAMOND_R*10.0) {\n                material = REFL;\n            } else {\n                colorMult *= vec3(3, 0, 2);\n                material = REFR;\n                if (dot(curDir, normal) > 0.0) {\n                    nEnter = GLASS_N;\n                } else {\n                    nEnter = DIAMOND_N;\n                }\n            }\n        }\n        \n        float sph8T = traceSphere(curPos+vec3(-0.01,-1.7, 0.01), curDir, 0.15, sphN);\n        if (sph8T < t) {\n            t = sph8T;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = colormap(pattern(worldPos.xy)).rgb*100.0;\n            normal = sphN;\n        }\n\n        float sph9T = traceSphere(curPos+vec3(-0.3,-0.7,-0.65), curDir, 0.13, sphN);\n        if (sph9T < t) {\n            t = sph9T;\n            material = DIFF;\n            vec3 worldPos = t * curDir + curPos;\n            color = colormap(pattern(worldPos.xy)).rgb*100.0;\n            normal = sphN;\n        }\n        \n        if (t != INF) \n        {\n            vec3 worldPos = t * curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            if (material == EMISS)\n            {\n                fragColor.rgb = color * colorMult;\n                break;\n            } \n            else if (material == DIFF) \n            {\n                fragColor.rgb = computeLight(worldPos, color, normal) * colorMult;\n                break;\n            }\n            else if (material == REFL) \n            {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-5;\n            } \n            else if (material == REFR) \n            {\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-5;\n                n1 = nEnter;\n            }\n        } \n        else \n        {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult;\n        }\n        \n    }   \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}