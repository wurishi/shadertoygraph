{"ver":"0.1","info":{"id":"XlcSWS","date":"1481308876","viewed":436,"name":"Night Cars - Demo","username":"randomswirls","description":"cars in the night","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["sine","night","mountains","cars","twinkle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TIMESCALE 1.0\n#define SKYCOLORA vec3(.05,.05,.05)\n#define SKYCOLORB vec3(.15,.15,.15)\n#define STARBRIGHTNESS .5\n#define STARSIZE 1.5\n#define CITYLIGHTSFARSIZE .5\n#define CITYLIGHTSFARBRIGHTNESS .8\n#define CITYLIGHTSCLOSESIZE 2.0\n#define CITYLIGHTSCLOSEBRIGHTNESS 1.0\n#define CARSPACING 2.0\n#define CARLENGTH .2\n\nfloat uTime;\n\n// Function to get a random float\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// Function to get a random vector ( 3 floats)\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\n// Test if point p is inside or outside a circle centered at c, with radius r\nfloat circle(vec2 p, vec2 c, float r)\n{\n\tif(length(p-c)<r)\n\t{\n\t\treturn 1.0;\n\t}\n\treturn 0.0;\n}\n\n// Helper function to add width to the car lines by finding the closest point, horizonally\n// The line is specified with the point p0 and direction v\nvec2 closestpointHorizontal(vec2 p, vec2 p0, vec2 v)\n{\n\tfloat t1 = (p.x-p0.x)/v.x;\n\treturn p0+v*t1; // closest point \n}\n\n// Alternate function for call lines to find the closest point, but look in a circle\nfloat linedistA(vec2 p, vec2 p0, vec2 v, float len){\n    vec2 r = p-p0;\n\n    float t1 = r.x*v.x+r.y*v.y;\n    t1 = min(len,max(0.0,t1));\n\n    vec2 d = p0+v*t1 - p; // vector to closest point \n    return d.x*d.x+d.y*d.y;\n}\n\n// Draw sparkles, control the scale by scaling the coordinates\nvec3 sparkles(vec2 coord)\n{\n\n\tfloat h = hash(coord.x*.1+coord.y*1.345);\n\tfloat i  = 0.0;\n\n\tif(h>.995)\n\t{\n\t\ti = .5+.5*sin(6.28*hash(coord.x*1.2568+coord.y*.1578)+uTime);\n\t}\n\n\treturn vec3(i,i,i);\n}\n\n// Function to draw the car lines\nvec3 carlines(vec2 coord,vec2 p0, vec2 v0, bool away)\n{\n    // closest point\n\t// distance\n\t// zvalue\n\t// threshold\n\t// base intensity\n\t// segment value\n\t// final intensity\n\n\tvec2 linepoint = closestpointHorizontal(coord,p0,v0);\n\n\tfloat d = length(linepoint-coord);\n\n\tfloat threshold = max(0.0,-linepoint.y)*.02;\n\n\tfloat intensity = 0.0;\n\tif(d<threshold)\n\t\tintensity = 1.0;\n\n    // offset time\n\tfloat z=threshold;\n\tz = 1.0/(-z); // fake perspective\n\tif(away)\n\t\tz+=uTime;\n\telse\n\t\tz-=uTime;\n   \n    // car spacing\n\tfloat interval = mod(z/CARLENGTH,CARSPACING);\n\tif(away) \n\t\tinterval = 1.0-interval;\n\tif(interval < 0.0 || interval > 1.0)\n\t\tinterval = 0.0;\n\t\n\tinterval = clamp(interval,0.0,1.0);\n\t\n\tintensity = intensity*interval;\n    \n    // if the car is moving away from us, return with line color red\n    // if the car is moving towards us, return with line white\n    // towards or away is spedified as a parameter to this carlines function\n\tif(away)\n\t\treturn vec3(intensity,0,0);\n\telse\n\t\treturn vec3(intensity,intensity,intensity);\n\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ouv = fragCoord.xy / iResolution.xy;\n   \tvec3 uScreen = iResolution;\n    vec3 color;\n    \n    //vec2 ouv = gl_FragCoord.xy/uScreen.xy;\n\tvec2 ocoord = (ouv-vec2(.5,.5))*uScreen.xy;\n\tvec2 uv = ouv;\n\tvec2 coord = ocoord;\n    \n    uTime = iTime*TIMESCALE;\n\t\n\t\n\n\tcolor  = vec3(0,0,0);\n\n    // draw car lines\n    coord.x += .05*uScreen.x*sin(uv.y*20.0); // add a curve to the road\n\tvec2 p1 = vec2(uScreen.x/2.5,0.0);\n\tvec2 p0 = vec2(0,-uScreen.y/2.0);\n\tcolor += carlines(coord, p0, normalize(p1-p0), false);\n\tp0.x+=uScreen.x*.05;\n\tcolor += carlines(coord, p0, normalize(p1-p0), false);\n\tp0.x+=uScreen.x*.1;\n\tcolor += carlines(coord, p0, normalize(p1-p0), true);\n\tp0.x+=uScreen.x*.05;\n\tcolor += carlines(coord, p0, normalize(p1-p0), true);\n    \n    // reset coord value\n    coord.x = ocoord.x;\n    \n    // add a small wobble\n    uv.y += .01*sin(uv.x*20.0);    \n\t// small city lights\n\t{\n        // scale coordinates and generate sparkles\n\t\tvec3 citylights = sparkles(floor(coord/CITYLIGHTSFARSIZE)); \n        citylights*=CITYLIGHTSFARBRIGHTNESS; // Apply brightness\n\t\tcitylights*=clamp(1.0-pow((uv.y-.5)/.03,2.0),0.0,1.0); // Mask y\n\t\tcitylights*=1.0-coord.x/uScreen.x*2.0; // Mask x\n\t\tcolor += citylights;\n\t}\n\t// larger city lights\n\t{\n        // scale coordinates and generate sparkles\n\t\tvec3 citylights = sparkles(floor(coord/CITYLIGHTSCLOSESIZE));\n        citylights*=CITYLIGHTSCLOSEBRIGHTNESS; // Apply brightness\n\t\tcitylights*=clamp(1.0-pow((uv.y-.35)/.08,2.0),0.0,1.0); // mask y\n\t\tcitylights*=(.4-uv.x)*5.0; //mask x\n\t\tcolor += citylights;\n\t}\n    \n    //reset uvs\n    uv.y = ouv.y;\n    \n\t// Mountains and Sky\n    uv.y += -.03*cos(uv.x*6.28); //Curve doordinates\n\tif((uv.y>abs(mod(uv.x,.3)-.15)*.4+.65)\n\t\t&& (uv.y>abs(mod(uv.x,.11)-.055)*.4+.65+.025)){\n                float skymix =  (1.0-uv.y)/.35+hash(uv.x+uv.y)*.05;\n                color  = mix(SKYCOLORA,SKYCOLORB, skymix);\n                color += sparkles(floor(coord/STARSIZE))*mix(STARBRIGHTNESS, .0,skymix);\n\t}\n\n\tfragColor = vec4(color,0.0);\n}","name":"Image","description":"","type":"image"}]}