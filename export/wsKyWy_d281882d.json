{"ver":"0.1","info":{"id":"wsKyWy","date":"1604006098","viewed":439,"name":"Bike 3d","username":"iuryBorgesRodrigues","description":"Bike 3d","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","sdf","iq","bike"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 1\nconst float SURFACE_DISTANCE = .0001;\n\n\nconst int MAX_STEPS = 500;\nconst int MAX_SHADOW_STEPS = 50;\n\nconst float MAX_DISTANCE = 50.;\nconst float MAX_REFLECT_DISTANCE = 5.;\nconst float MAX_SHADOW_DISTANCE = 15.;\nconst vec2 normal = vec2(0, 0.01);\n\nconst float FOV = 700.;\n\nconst vec3 AMBIENT_COL = vec3(0.08, 0.1, 0.14);\nconst float SHADOW_SOFTNESS = .25;\n\nconst float DEG_TO_RAD = 0.01745329251;\nconst vec3 CAMERA_ROTATION = vec3(-25. * DEG_TO_RAD, 35. * DEG_TO_RAD, -15. * DEG_TO_RAD);\nconst mat3 CAMERA_ROTATION_MATRIX = mat3(vec3(1, 0, 0),\n                                         vec3(0, cos(CAMERA_ROTATION.x), -sin(CAMERA_ROTATION.x)),\n                                        vec3( 0, sin(CAMERA_ROTATION.x), cos(CAMERA_ROTATION.x)) )* \n    \t\t\t\t\t\t\t\tmat3(vec3(cos(CAMERA_ROTATION.y), 0, sin(CAMERA_ROTATION.y)),\n                                        vec3(0, 1, 0),\n                                        vec3(-sin(CAMERA_ROTATION.y), 0, cos(CAMERA_ROTATION.y)) )* \n    \t\t\t\t\t\t\t\tmat3(vec3(cos(CAMERA_ROTATION.z), -sin(CAMERA_ROTATION.z), 0),\n                                        vec3(sin(CAMERA_ROTATION.z), cos(CAMERA_ROTATION.z), 0),\n                                        vec3( 0, 0, 1));\n\n\nvec3 CubemapToHDR( vec3 bg )\n{\nbg = bg * bg;\nbg = -log( 1.01f - bg );            \nreturn bg;\n }\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nfloat SDF_Plane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat SDF_Sphere(vec3 p, vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat SDF_Box(vec3 p, vec3 c, vec3 b)\n{\n    p -= c;\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\nfloat SDF_Torus(vec3 p, vec3 c, vec2 t)\n{\n    p -= c;\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdCircle( in vec3 p, in float r ) \n{\n    return length(p)-r;\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat rounding( in float d, in float h )\n{\n    return d - h;\n}\n\nvec4 opU(vec4 d1, vec4 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdStar(in vec2 p, in float r, in int n, in float m,float modi) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = modi/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n\nfloat coroa(vec3 pvec3){\n    \n    \n    \n    \n    vec2 p=pvec3.xy;\n    \n    // animate\n    float t = 8.7;\n    float n = 2.0 + mod(floor(t),9.0);  // n, number of sides\n    float a = fract(t);                 // angle factor\n    float m = 2.0 + a*a*(n-2.0);        // angle divisor, between 2 and n\n    \n    // sdf\n    \n    float d1;\n    float d2;\n    float d3;\n    float d4;\n    \n    d1= sdStar( p, 0.7, int(n), m ,1.141593);\n    d2=sdCircle(p,0.6);\n    d3=sdStar5(p,0.7,0.2);\n    d4=sdCircle(p,0.1);\n    \n    d1=max(d1,-d2)-0.05;\n    \n    d1=min(d1,d3);\n    \n    d1=max(d1,-d4);\n    \n    return opExtrussion(pvec3,d1,0.05);\n    \n    \n}\n\n\nfloat catraca(vec3 pvec3){\n    \n    \n    \n    \n    vec2 p=pvec3.xy;\n    \n    \n    \n    float d1;\n    float d2;\n    \n   \n        // animate\n    float t = 8.7;\n    float n = 2.0 + mod(floor(t),9.0);  // n, number of sides\n    float a = fract(t);                 // angle factor\n    float m = 2.0 + a*a*(n-2.0);        // angle divisor, between 2 and n\n    \n    \n    \n    d1= sdStar( p, 0.7, int(n), m ,1.141593);\n   \n  \n    d2=sdCircle(p,0.15);\n    \n   \n    \n    \n   \n     d1=max(d1,-d2)-0.05;\n    \n    \n    return opExtrussion(pvec3,d1,0.05);\n  \n    \n    \n}\n\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\nmat2 Rot2D(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(vec2(c, -s),vec2( s, c));\n}\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\n\nfloat corrente(vec3 pvec3){\n    \n    vec2 p=pvec3.xy;\n    p.yx/=vec2(0.7,0.5);\n    p.yx-=vec2(0.9,0.6);\n    p.yx*=Rot2D(0.2);\n    \n    vec2 v1 =  vec2(0.0,0.0);\n\tvec2 v2 = vec2(0.0,1.0);\n    float r1 = 0.5+0.1*sin(1.0);\n    float r2 = 0.3+0.1*sin(1.0+2.3*1.0);\n    \n   \n    \n    float corrente=opExtrussion(pvec3,sdUnevenCapsule( p, v1, v2, r1, r2 ),0.02);\n    float corrente2=opExtrussion(pvec3,sdUnevenCapsule( p, v1, v2, r1, r2 ),0.1);\n    corrente=max(corrente,-corrente2);\n    \n   return corrente;\n    \n    \n    \n}\nfloat sdBox2D( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat pedal(vec3 p){\n    \n    \n    \n    vec3 p1=p;\n    vec3 p2=p;\n    vec3 p4=p;\n    vec3 pE=p;\n    \n    vec3 pE2=p;\n    \n    pE+=vec3(0.5,0.7,-0.4);\n    pE*=rotate_x(1.6);\n    pE*=rotate_z(1.6);\n    vec2 p3=pE.xy;\n    \n   \n   \n    pE2+=vec3(-0.6,-0.05,-0.5);\n    pE2*=rotate_x(1.6);\n    pE2*=rotate_z(1.6);\n    vec2 p5=pE2.xy;\n    \n    p4+=vec3(0.0,0.3,-0.5);\n    p1+=vec3(0.4,0.5,-0.5);\n    p2+=vec3(-0.4,0.1,-0.5);\n    p4*=rotate_z(1.6);\n    \n    float pedal[8];\n    \n   \tp3/=vec2(0.4,0.5);\n    p5/=vec2(0.4,0.5);\n    \n    \n    float pedal11;\n    float pedal22;\n    float pedal33;\n    float pedal44;\n    float pedal55;\n    float pedal66;\n   \n \t\n    pedal11= sdBox2D(p3,vec2(0.2))-0.3;\n    pedal22= sdBox2D((p3/vec2(0.6,1.5))+vec2(0.4,0.0),vec2(0.2))-0.01;\n    pedal33= sdBox2D((p3/vec2(0.6,1.5))+vec2(-0.4,0.0),vec2(0.2))-0.01;\n    \n    \n    pedal11=max(pedal11,-pedal22);\n    pedal11=max(pedal11,-pedal33);\n    \n    \n    pedal44= sdBox2D(p5,vec2(0.2))-0.3;\n    pedal55= sdBox2D((p5/vec2(0.6,1.5))+vec2(0.4,0.0),vec2(0.2))-0.01;\n    pedal66= sdBox2D((p5/vec2(0.6,1.5))+vec2(-0.4,0.0),vec2(0.2))-0.01;\n    \n    \n    pedal44=max(pedal44,-pedal55);\n    pedal44=max(pedal44,-pedal66);\n    \n    \n    \n    \n    \n    \n    float pedal1=sdCappedCylinder(p4,0.03,0.4);\n    float pedal2=sdCappedCylinder(p1,0.03,0.2);\n    float pedal3=sdCappedCylinder(p2,0.03,0.2);\n    float pedal4=opExtrussion(pE,pedal11,0.05);\n    float pedal5=opExtrussion(pE2,pedal44,0.05);\n    \n    pedal1=smin(pedal1,pedal2,0.05);\n    pedal1=smin(pedal1,pedal3,0.05);\n    pedal1=smin(pedal1,pedal4,0.05);\n    pedal1=smin(pedal1,pedal5,0.05);\n    \n    return pedal1;\n    \n}\n\nfloat aro(vec3 p){\n    \n    vec3 p1=p;\n    \n    p1+=vec3(0.1,0.2,1.1);\n    float aro0;\n    float aro1;\n    float aro2;\n    float aro3;\n    float aro4;\n    float aro5;\n    float aro6;\n    float aro7;\n    float aro8;\n    float aro9;\n    float aro10;\n    float aro11;\n    \n    \n    \n    aro0=sdCappedCylinder(p1,0.01,0.5);\n    aro1=sdCappedCylinder(p1*rotate_x(0.3),0.01,0.5);\n    aro2=sdCappedCylinder(p1*rotate_x(0.6),0.01,0.5);\n    aro3=sdCappedCylinder(p1*rotate_x(0.9),0.01,0.5);\n    aro4=sdCappedCylinder(p1*rotate_x(1.1),0.01,0.5);\n    aro5=sdCappedCylinder(p1*rotate_x(1.4),0.01,0.5);\n    aro6=sdCappedCylinder(p1*rotate_x(1.7),0.01,0.5);\n    aro7=sdCappedCylinder(p1*rotate_x(2.0),0.01,0.5);\n    aro8=sdCappedCylinder(p1*rotate_x(2.3),0.01,0.5);\n    aro9=sdCappedCylinder(p1*rotate_x(2.3),0.01,0.5);\n    aro10=sdCappedCylinder(p1*rotate_x(2.6),0.01,0.5);\n    aro11=sdCappedCylinder(p1*rotate_x(2.9),0.01,0.5);\n    \n    \n    \n    \n    \n    aro0=min(aro0,aro1);\n    aro0=min(aro0,aro2);\n    aro0=min(aro0,aro3);\n    aro0=min(aro0,aro4);\n    aro0=min(aro0,aro5);\n    aro0=min(aro0,aro6);\n    aro0=min(aro0,aro7);\n    aro0=min(aro0,aro8);\n    aro0=min(aro0,aro9);\n    aro0=min(aro0,aro10);\n    aro0=min(aro0,aro11);\n   \n    \n    \n    \n    \n    return aro0;\n    \n    \n}\n\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// -----------------\n// obj combination\n// -----------------\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\n// -----------------\n// sdf\n// -----------------\nfloat sdCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sdBoxCheap(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n\nfloat sdBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\nfloat comp(float a,float b){\n    \n    return (a < b) ? a : b;\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\nfloat sdTorus82( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length8(p.xz)-t.x,p.y);\n  return length2(q)-t.y;\n}\n\nconst float SPHERE = 1.0;\nconst float GROUND = 2.0;\nconst float FRAME = 3.0;\nconst float WALL = 4.0;\n\nfloat quadro(vec3 p)\n{\n    float d1 = p.y + 1.0;\n    \n    vec3 wP = p;\n    wP.x -= 1.6;\n    \n    // wall\n    vec3 wallP = wP;\n    wallP.y -= 0.5;\n    wallP.x += 2.0;\n    float wall = sdBox2Cheap(wallP.xy, vec2(0.1, 2.5));\n    \n    vec3 windowP = wP;\n    windowP.x += 2.3;\n    windowP.y -= 0.75;\n    windowP.z -= 0.1;\n    float window = sdBoxCheap(windowP, vec3(0.5, 0.8, 0.6));\n    \n    wall = max(-window, wall);\n    \n    \n    // position the frame\n    vec3 fP = p;\n    fP.y += 0.35;\n    pR(fP.xy, radians(13.0));\n    \n    // downtube\n    vec3 dtP = fP;\n    dtP.z += 0.1;\n    pR(dtP.yz, radians(-50.0));\n    float downtube = sdCylinder(dtP, 0.05, 0.9);\n    \n    // headtube\n    vec3 htP = fP;\n    htP.y -= 0.65;\n    htP.z += 0.825;\n    pR(htP.yz, radians(20.0));\n    float headtube = sdCylinder(htP, 0.065, 0.2);\n    \n    //toptube\n    vec3 ttP = fP;\n    pR(ttP.yz, radians(95.0));\n    ttP.z += 0.65;\n    ttP.y -= 0.0;\n    float toptube = sdCylinder(ttP, 0.05, 0.80);\n    \n    // seattube\n    vec3 stP = fP;\n    pR(stP.yz, radians(15.0));\n    stP.z -= 0.7;\n    stP.y -= 0.45;\n    float seattube = sdCylinder(stP, 0.05, 0.75);\n    \n    // seatstays\n    vec3 ssP = fP;\n    ssP.x = abs(ssP.x);\n    ssP.z -= 1.22;\n    ssP.x -= 0.1;\n    ssP.y -= 0.1;\n    pR(ssP.zy, radians(35.0));\n    pR(ssP.xy, radians(5.0));\n    float seatstays = sdCylinder(ssP, 0.015, 0.55);\n    \n    // chainstays\n    vec3 csP = fP;\n    csP.x = abs(csP.x);\n    csP.x -= 0.08;\n    csP.z -= 1.1;\n    csP.y += 0.445;\n    pR(csP.zy, radians(100.0));\n    pR(csP.xy, radians(8.0));\n    float chainstays = sdCylinder(csP, csP.y * 0.03 + 0.03, 0.45);\n    \n    float f1 = fOpUnionRound(downtube, seattube, 0.15);\n    float f2 = fOpUnionRound(f1, chainstays, 0.1);\n    float f3 = fOpUnionRound(f2, headtube, 0.05);\n    float f4 = fOpUnionRound(f3, seatstays, 0.05);\n    float frame = fOpUnionRound(f4, toptube, 0.05);\n    \n   f1=comp(f1,f2);\n    f1=comp(f1,f3);\n    f1=comp(f1,f4);\n    f1=comp(f1,frame);\n    \n    \n   return f1;\n}\n\nvec4 getDist(vec3 p)\n{\n    \n    vec4 obj;\n    \n    \n   \n   \t\n    float rot=-1.6;\n    vec3 pos=vec3(0.2,-0.7,-0.8);\n    \n    \n  \tvec3 p1=p;\n    vec3 p2=p;\n    vec3 p3=p;\n    vec3 p4=p;\n    vec3 p5=p;\n    vec3 p6=p;\n    vec3 p7=p;\n    vec3 p8=p;\n    vec3 p9=p;\n    vec3 p10=p;\n    vec3 p11=p;\n   \tvec3 p12=p;\n    vec3 p13=p;\n    \n    \n    p1.y-=0.5;\n    p2.y-=0.5;\n    p3.y-=0.5;\n    p4.y-=0.5;\n    p5.y-=0.5;\n    p6.y-=0.5;\n    p7.y-=0.5;\n    \n    \n    \n    \n    p1+=pos;\n    p2+=pos;\n    \n    p1*=rotate_y(rot);\n    p2*=rotate_y(rot);\n   \n    \n   \t\n    p1.z*=exp2(p1.x);\n    \n    \n    p3/=vec3(0.5);\n    \n    p3+=vec3(0.11,1.2,2.25);\n    p3*=rotate_x(0.3);\n    p3*=rotate_z(0.05);\n    \n    \n    p4*=rotate_z(-0.1);\n\t\n    \n    p5*=rotate_x(1.6);\n    p5*=rotate_z(1.5);\n    p5+=vec3(1.1,0.0,-0.8);\n    p5*=vec3(0.8,0.6,0.8);\n    p5/=vec3(0.8,0.5,0.8);\n   \n    p6*=rotate_z(3.2);\n    p6+=vec3(-0.1,1.0,0.8);\n    \n    \n    \n    \n    p7*=rotate_z(1.6);\n    \n    p7*=rotate_y(-1.6);\n    p7*=rotate_z(-0.0);\n    \n    p7+=vec3(-0.55,0.15,-1.0);\n    p7.y+=0.04;\n    \n    p7/=vec3(0.5);\n    p6/=vec3(0.55,0.5,0.5);\n    \n    p8/=vec3(0.4);\n    p8+=vec3(-0.3,0.7,-1.3);\n    p8*=rotate_y(1.6);\n    \n    p9/=vec3(0.2);\n    p9+=vec3(-0.3,1.2,-7.3);\n    p9*=rotate_y(1.6);\n    \n    p10.x-=0.1;\n    p10*=rotate_y(1.6);\n    p10*=rotate_z(-1.6);\n    \n\tfloat parteCImaGarfo=sdCappedCylinder(p3+vec3(0.0,-1.2,0.0),0.1,0.3);\n    float parteDebaixoGarfo=sdBox(vec3(abs(p3.x),p3.yz)+vec3(-0.3,0.35,0.0),vec3(0.07,0.1,0.05));\n    float buracoParteDebaixoGarfo=sdCappedCylinder(p3.yzx+vec3(0.41,0.0,0.3),0.05,0.2);\n    float buracoParteDebaixoGarfo2=sdCappedCylinder(p3.yzx+vec3(0.41,0.0,-0.3),0.05,0.2);\n    \n    \n    float garfo=sdLink(p3/vec3(1.0,1.5,1.0),0.3,0.3,0.1);\n    float bola1=sdEllipsoid(p2+vec3(0.2,-0.05,0.1),vec3(0.15,0.075,0.14));\n    float bola2=sdEllipsoid(p2+vec3(0.2,-0.05,-0.1),vec3(0.15,0.075,0.14));\n    float selin = sdEllipsoid(p1,vec3(0.4,0.13,0.25));\n    float pneu= max(sdCappedCylinder(p5,0.5,0.00)-0.1,-sdCappedCylinder(p5,0.45,0.3));\n    float meioPneu=sdCappedCylinder(p5,0.1,0.15);\n    float pneu2= max(sdCappedCylinder(p5+vec3(-2.6,-0.1,0.1),0.5,0.00)-0.1,-sdCappedCylinder(p5+vec3(-2.6,-0.1,0.1),0.45,0.3));\n    float meioPneu2=sdCappedCylinder(p5+vec3(-2.6,-0.1,0.1),0.1,0.15);\n    float coroa=coroa(p8);\n    float catraca=catraca(p9);\n    \n    \n   \n    float corrente=corrente(p10);\n    \n    float pedal=pedal(p12);\n    float aro2=aro(p13+vec3(-0.1,0.0,-2.5));\n    float aro=aro(p13);\n   \n    \n    aro=min(aro,aro2);\n   \n    \n    coroa=min(coroa,catraca);\n    coroa=min(coroa,corrente);\n    \n    //carabina\n   // p6.x+=sin(p.y*0.8)*sin(-p6.y*-0.5);\n    \n    \n   \tfloat guidon=sdLink(p6/vec3(2.0,1.5,2.0),0.3,0.3,0.05);\n    \n    float guidonP1=sdTorus82(p7,vec2(0.4,0.1));\n    float guidonP2=sdTorus82(p7+vec3(0.0,-1.3,0.0),vec2(0.4,0.1));\n    guidonP1=max(guidonP1,-p7.z);\n    guidonP2=max(guidonP2,-p7.z);\n    guidon=max(guidon,-p6.y-0.1);\n    guidon=min(guidon,guidonP1);\n    guidon=min(guidon,guidonP2);\n      \n    float quadro= quadro(p4/vec3(1.0));\n    garfo=min(garfo,parteCImaGarfo);\n    \n    garfo=max(garfo,-p3.y-0.25);\n    garfo=smin(garfo,parteDebaixoGarfo,0.05);\n    garfo=max(garfo,-buracoParteDebaixoGarfo);\n    garfo=max(garfo,-buracoParteDebaixoGarfo2);\n    \n    bola1=max(bola1,-p2.y);\n    bola2=max(bola2,-p2.y);\n    selin=max(selin,-p1.y-0.1);\n    selin=smin(selin,bola1,0.1);\n    selin=smin(selin,bola2,0.1);\n    \n    \n   \n    vec4 Selin = vec4(selin, 0.0,0.0,0.0);\n    vec4 Quadro = vec4(quadro, 0.0,1.0,1.0);\n    vec4 Bola1=vec4(bola1, 0.0,0.0,0.0);\n    vec4 plane = vec4(SDF_Plane(p, vec4(0, 1, 0, 1.)), 1, 1, 1);\n    vec4 Garfo = vec4(garfo*0.6, 0.0,1.0,1.0);\n   \tvec4 Pneu=vec4(pneu,0.0,0.0,0.0);\n    vec4 MeioPneu=vec4(meioPneu,1.0,1.0,1.0);\n    vec4 Pneu2=vec4(pneu2,0.0,0.0,0.0);\n    vec4 MeioPneu2=vec4(meioPneu2,1.0,1.0,1.0);\n    vec4 Guidon=vec4(guidon*0.6,1.0,1.0,1.0);\n    vec4 Coroa=vec4(coroa*0.6,1.0,1.0,1.0);\n    vec4 Pedal=vec4(pedal*0.5,1.0,1.0,1.0);\n    vec4 Aro=vec4(aro,1.0,1.0,1.0);\n     \n    \n    obj=opU(Coroa,  plane);\n    obj=opU(obj,Pedal);\n    obj=opU(obj,Aro);\n  \tobj=opU(obj,Guidon);\n    obj=opU(obj,Selin);\n   \n  \tobj=opU(obj,  Quadro);\n  \tobj=opU(obj,Garfo);\n    obj=opU(obj,  Pneu);\n    obj=opU(obj,  MeioPneu);\n    obj=opU(obj,  Pneu2);\n    obj=opU(obj,  MeioPneu2);\n\n\n    return obj;\n}\n\nvec4 rayMarch(vec3 rO, vec3 rD, float maxDistance)\n{   \n    float dist = 0.001;\n    vec3 col;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec4 dS = getDist(rO + rD * dist);\n        dist += dS.x;\n        col = dS.yzw;\n        if (dS.x < SURFACE_DISTANCE || dist > MAX_DISTANCE) \n        {\n            break;\n        }\n    }\n    \n    return vec4(dist, col.rgb);\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = getDist( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 getNormal(vec3 p)\n{\n    return normalize(vec3(getDist(p - normal.yxx).x, getDist(p - normal.xyx).x, getDist(p - normal.xxy).x));\n}\n\nvec3 shade(vec3 p, vec3 lightDir, vec3 rD, vec3 nrm, vec3 baseCol)\n{\n    vec3 col = vec3(0,0,0);\n    vec3 diff = vec3(max(0., dot(nrm, lightDir))) * baseCol;\n    float spec = pow(max(0., dot(-rD, reflect(lightDir, nrm))), 40.) * .6;\n    col = diff + spec;\n\n    col *= vec3(calcSoftshadow(p - lightDir * 0.01, -lightDir,0.01, 3.0, 0));\n    col += AMBIENT_COL;\n    return col;\n}\n\nvec3 renderSky(vec3 rD)\n{\n    return vec3((1. - rD.y) / 3. + 0.25, (1. - rD.y) / 5. + 0.3, 0.8 - rD.y / 8.);\n}\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n#define PI 3.14159\nmat3 rotation;\n\n\n#define ZERO (min(iFrame,0))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t vec3 tot = vec3(0.0);\nvec3 col = vec3(0,0,0);\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5; \n\t\n\t\n\t\n\t//vec2 fragCoord=FRAGCOORD.xy;\n\t//vec2 iResolution=(1.0/SCREEN_PIXEL_SIZE).xy;\n\t//float iTime=TIME;\n\tvec3 SUN_DIRECTION = normalize(vec3(0, -1, 1));\n\n\t\n   \n    \n    \n  \n\t\n        \n     vec2 m2 = iMouse.xy / iResolution.xy;\n    m2.y *= -1.0;\n    m2 -= vec2(0.5);\n    \n    // initial mouse position\n    if(iMouse.xy == vec2(0.0))\n    {\n        m2= vec2(0.0, 8.0);\n    }\n\n    rotation = mat3(1.0);\n    rotation = rotx(m2.y * 10.0);\n    rotation *= rotx(PI * 0.5);\n    rotation *= roty(m2.x * 10.0);\n   \n    \n    \n    vec2 uv =fragCoord+o - iResolution.xy / vec2(2,2);\n    uv = uv - vec2(0.5, 0.5);\n    uv /= FOV;\n    \n    vec3 rO = vec3(4.8, 3., -5);\n    vec3 rD = CAMERA_ROTATION_MATRIX * normalize(vec3(uv.x, uv.y, 1));\n\n    rO*=rotation;\n    rD*=rotation;\n    vec4 dist = rayMarch(rO, rD, MAX_DISTANCE);\n    \n    \n    if (dist.x < MAX_DISTANCE)\n    {\n        vec3 p = rO + dist.x * rD;\n    \tvec3 nrm = getNormal(p);\n        vec3 lightDir = normalize(SUN_DIRECTION +vec3(0.8,5.0,-3.0) * -6.);\n        \n        col = shade(p, lightDir, rD, nrm, dist.yzw);\n        \n        vec3 ref = reflect(rD, nrm);\n        vec4 refDist = rayMarch(p + (ref * 0.01), ref, MAX_REFLECT_DISTANCE);\n\t\tvec3 reflectCol;\n        \n        if (refDist.x < MAX_REFLECT_DISTANCE)\n        {\n            vec3 refP = (p + ref * 0.01) + (ref * refDist.x);\n            vec3 refNrm = getNormal(refP);\n            reflectCol = shade(refP, lightDir, ref, refNrm, refDist.yzw);\n        }\n        else\n        {\n            //reflectCol = texture(iChannel0, ref).rgb;\n            reflectCol+=textureLod(iChannel0, ref,0.0).rgb;\n            reflectCol=CubemapToHDR(reflectCol);\n        }\n        \n        col = mix(col, reflectCol, clamp(pow(1. - dot(rD, nrm), 4.), 0., 1.));\n    }\n    else \n    {\n    \tcol+=textureLod(iChannel0, rD,0.0).rgb;\n        col=CubemapToHDR(col);\n       \n       // col = renderSky(rD);\n    }\n \ttot += col;\n    }\n     tot /= float(AA*AA);\n    fragColor = vec4(tot,1.0);\n}\n\n\n\n\n/*float lightFeeler = rayMarch(p - lightDir * 0.01, -lightDir, MAX_DISTANCE);\n        \n        if (lightFeeler < MAX_DISTANCE)\n        {\n            col.rgb = AMBIENT_COL;\n        }*/","name":"Image","description":"","type":"image"}]}