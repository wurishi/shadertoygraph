{"ver":"0.1","info":{"id":"cdfGW2","date":"1666787765","viewed":63,"name":"Raytracing in a Weekend - AA","username":"bittermandel","description":"Up until the Antialiasing chapter of Raytracing in a Weekend","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_FLOAT 1e5\n#define SAMPLES_PER_PIXEL 100.0\n\nvec3 rayColor(Ray ray)\n{\n    vec3 unitDirection = normalize(ray.direction);\n    \n    float t = 0.5 * (unitDirection.y + 1.0);\n    \n    return (1.0 - t) * vec3(1.0) + t*vec3(0.5, 0.7, 1.0);\n}\n\nbool raycast(const in Ray r, inout Hit h)\n{\n    Sphere sphere1 = Sphere(vec3(0.0 + sin(iTime), 0.0, -1.0), 0.5);\n    Sphere plane = Sphere(vec3(0.0, -100.5, -1.0), 100.0);\n    \n    bool didHit = false;\n    \n    float t_max = MAX_FLOAT;\n    \n    \n    didHit = hit(r, plane, 0.00001, t_max, h) || didHit;\n    if (didHit)\n    {\n        float t_max = h.t;\n    }\n    didHit = hit(r, sphere1, 0.00001, t_max, h) || didHit;\n    \n    return didHit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    Camera camera = makeCamera(iResolution);\n\n    vec3 col;\n\n    for (float s = 0.0; s < SAMPLES_PER_PIXEL; ++s)\n    {\n        Ray r = Ray(camera.origin, normalize(camera.lowerLeftCorner + uv.x * camera.horizontal + uv.y * camera.vertical - camera.origin));\n\n        Hit h;\n\n        bool didHit = raycast(r, h);\n\n\n        // Output to screen\n        if (didHit)\n        {\n            col += 0.5 * (h.normal + vec3(1.0));\n        }\n        else\n        {\n            col += rayColor(r);\n        }\n    }\n    \n    if (iMouse.z>0.0)\n    {\n   \n        Ray r = Ray(camera.origin, normalize(camera.lowerLeftCorner + m.x * camera.horizontal + m.y * camera.vertical - camera.origin));\n        Hit h;\n\n        bool didHit = raycast(r, h);\n\n        // Output to screen\n        if (didHit)\n        {\n            col = vec3(0.0 * SAMPLES_PER_PIXEL);\n        }\n        else\n        {\n            col += rayColor(r);\n        }\n    }\n\n    \n    float scale = 1.0 / SAMPLES_PER_PIXEL;\n    col = col * scale;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// RAY\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 rayAt(Ray ray, float t)\n{\n    return ray.origin + t*ray.direction;\n}\n\n// CAMERA\n\nstruct Camera {\n    vec3 origin, lowerLeftCorner, horizontal, vertical;\n};\n\nCamera makeCamera(vec3 iResolution)\n{\n    float h = 2.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    float w = h * aspectRatio;\n\n    vec3 origin = vec3(0);    \n    \n    vec3 horizontal = vec3(w, 0, 0);\n    vec3 vertical = vec3(0, h, 0);\n    \n    vec3 lowerLeftCorner = origin - horizontal/2.0 - vertical/2.0 - vec3(0.0, 0.0, 1.0);\n\n    return Camera(origin, lowerLeftCorner, horizontal, vertical);\n}\n\n// GEOMETRY\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n};\n\n// INTERSECTIONS\n\nstruct Hit\n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    bool frontFace;\n};\n\nbool hit(Ray r, Sphere sphere, float t_min, float t_max, inout Hit rec)\n{\n    vec3 oc = r.origin - sphere.center;\n\n    float halfB = dot(oc, r.direction);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n\n    float discriminant = halfB*halfB - c;\n    \n    if (discriminant < 0.0)\n    {\n        return false;\n    }\n\n    float sqrtd = sqrt(discriminant);\n    \n    float t1 = -halfB - sqrtd;\n    float t2 = -halfB + sqrtd;\n    \n    float t = t1 < 0.05 ? t2 : t1;\n    if (t < t_min || t > t_max)\n    {\n        return false;\n    }\n\n    vec3 p = rayAt(r, t);\n        \n    vec3 normal = p - sphere.center;\n\n    bool frontFace = dot(r.direction, normal) > 0.0;\n\n    normal = frontFace ? -normal : normal;\n    normal /= sphere.radius;\n    \n    rec = Hit(t, p, normal, frontFace);\n    \n    return true;\n}\n","name":"Common","description":"","type":"common"}]}