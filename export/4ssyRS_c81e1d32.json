{"ver":"0.1","info":{"id":"4ssyRS","date":"1488997159","viewed":123,"name":"Rotating Cross Optical Illusion","username":"nint22","description":"Implemented this optical illusion from scratch after seeing it in Gif form. Turns out: not trivial to do. Code can be simplified: instead of my two-cross approach, I could just draw one cross at a time (and offset all crosses & flip their colors)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["opticalillusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// This is a Shader clone of the \"Rotating Cross Illusion\", based on a Gif here:\n//     https://www.reddit.com/r/oddlysatisfying/comments/5xamjy/twist_and_turn/\n// Here is the same effect, done in lock-step\n//     http://i.imgur.com/oHxkM4L.gif\n\n// How this is implemented:\n// I draw two crosses at once: a dark one and a light one, and then repeat these based on\n// a specific grid pattern (the grid is *not* an axis-aligned uniform grid of tiles, but\n// is instead a repeated overlapping set of tiles). The core cross-drawing function is\n// \"TestCrossShape(...)\", which returns 0.0 if it doesn't touch the cross, or 1.0 if it does.\n// The \"TestCrossPairShape(...)\" function draws two crosses, assuming one is white and the\n// other dark. This assumption is flipped using a flip parameter. In either case, pixels\n// intersecting the white cross return kLightColor (1.0), pixels intersecting the dark\n// cross returns kDarkColor (0.16), while pixels not intersecting any shape return 0.0.\n// We return these three states as a way to determine the two colors and pass-through logic.\n// Pass-through is critical to having multiple tiles overlapping, which is required for\n// this visual effect to work.\n\n// Helpful constants\nconst float kPI = 3.1415926535897932384626433832795;\nconst float kHalfPI = kPI * 0.5;\n\n// Visual effect contants: cross is a 3x3 group of tiles\nconst float kTileSizePixels = 26.0;\nconst float kCrossSizePixels = kTileSizePixels * 3.0;\n\n// Animation timing elements\nconst float kAnimationDelay = 0.1;\nconst float kAnimationDuration = 0.8;\n\n// Vector used to map on-screen pixels to their respective cross-pair positions\nconst vec2 kCrossdx = vec2( 2.0, -1.0 );\nconst vec2 kCrossdy = vec2( 2.0, 4.0 );\n\n// Our three color constants: a white color, a darker color, and a special black color\n// Note that black (0.0) is reserved as a way to define logical \"transparency\". It could be\n// any value, but is black for convenience.\nconst float kLightColor = 1.0;\nconst float kDarkColor = 0.16;\nconst float kTransparentColor = 0.0;\n\n// Build a 2x2 rotation matrix that you can apply to a vec2 for rotating a point about the origin\nmat2 GetRotationMatrix2D( float theta )\n{\n\t// Simple affine transform matrix\n    return mat2( cos( theta ),-sin( theta ),\n                 sin( theta ), cos( theta ) );\n}\n\n// Tests if the given pixel is within a rotating cross based on rotation phase and cross origin\n// Note that cross origin is defined as bottom-left, not center. Returns 0.0 for being outside, 1.0 for being inside\nfloat TestCrossShape( vec2 crossPos, vec2 pixelPos, float phase )\n{\n\t// Rotate the given pixel position around the center \n    vec2 localTileCenter = (crossPos + 0.5 * vec2( kCrossSizePixels ) );\n    pixelPos -= localTileCenter;\n    pixelPos *= GetRotationMatrix2D( phase * kHalfPI );\n    pixelPos += localTileCenter;\n    \n    // Localize pixel position relative to crossPos (origin)\n    pixelPos -= crossPos;\n    \n    // Todo: remove these conditionals and implement some faster pure-math mechanism? (cross product to determine inclusion?)\n    \n    // Bounds check pixel\n    if( pixelPos.x < 0.0 || pixelPos.y < 0.0 || pixelPos.x >= kCrossSizePixels || pixelPos.y >= kCrossSizePixels )\n        return 0.0;\n    \n    // Test for the horizontal inclusion..\n    if( pixelPos.y >= kTileSizePixels && pixelPos.y < ( 2.0 * kTileSizePixels ) )\n        return 1.0;\n    \n    // Test for vertical inclusion\n    if( pixelPos.x >= kTileSizePixels && pixelPos.x < ( 2.0 * kTileSizePixels ) )\n        return 1.0;\n\t\n    // Pixel is in bounding box, but not in the cross\n    return 0.0;\n}\n\n// Tests if a given pixel is intersecting one of the two pairs of crosses we draw: this function only actually draws\n// one at a time, as a way to prevent one cross from clipping another. By default we draw the white tile at the\n// bottom-left, with the black tile at the top-right. This is flipped if flip = true. Returns kTransparentColor\n// if out of bounds, kDarkColor for the black tile, kLightColor for the white tile\nfloat TestCrossPairShape( vec2 tilePos, vec2 pixelPos, bool flip, bool rotatingWhite, float rotationPhase )\n{\n    // This second tile offset is computed in pixel-space, as the given tilePosition is already in pixel-space\n    const vec2 kSecondTileOffset = vec2( 1.0, 2.0 ) * kTileSizePixels;\n\t\n    if( flip == false )\n    {\n\t\t// Actively drawing bottom-left cross as white\n\t\tif( rotatingWhite == true && TestCrossShape( tilePos, pixelPos, rotationPhase ) > 0.0 )\n\t\t\treturn kLightColor;\n\t\telse if( rotatingWhite == false && TestCrossShape( tilePos + kSecondTileOffset, pixelPos, rotationPhase ) > 0.0 )\n\t\t\treturn kDarkColor;\n    }\n    else\n    {\n\t\t// Actively drawing bottom-left cross as black\n\t\tif( rotatingWhite == false && TestCrossShape( tilePos, pixelPos, rotationPhase ) > 0.0 )\n\t\t\treturn kDarkColor;\n\t\telse if( rotatingWhite == true && TestCrossShape( tilePos + kSecondTileOffset, pixelPos, rotationPhase ) > 0.0 )\n\t\t\treturn kLightColor;\n    }\n    // Else, pass through:\n    return kTransparentColor;\n}\n\n// For a given pixel, returns the cross-pair position (in uniform grid-space, not tile-space\n// or pixel-space). No additional transform *should* be applied here: the returned position\n// is where we should place a cross-pair.\nvec2 GetCrossPairPosition( vec2 pixelPos )\n{\n    // Take pixel, convert to tile coordinates. Note the repeated \"tilePos.x - 1.0\" subtraction:\n    // We're starting at the x-origin of the first 2x3 \"core\"\n    vec2 tilePos = floor( pixelPos / kTileSizePixels );\n    float yOffset = floor( (tilePos.y + floor( (tilePos.x - 1.0) / 2.0 )) / 5.0 );\n    float xOffset = floor( ( tilePos.x - 1.0 ) / 2.0 ) - yOffset;\n    vec2 gridPos = vec2( xOffset, yOffset );\n    \n    // gridPos is now the correct position for the 2x3 \"core\", but it's possible adjacent cross-pairs\n    // may overlap with us. This is true only for one corner above the \"core\" and one below it. We\n    // now check for these cases using a distance vector (not length) from core center to pixel.\n    vec2 crossOrigin = ( gridPos.x * kCrossdx + gridPos.y * kCrossdy ) + vec2( 1, 0 );\n    vec2 dist = ( pixelPos - crossOrigin * kTileSizePixels );\n    \n    // This is touching the right-adjacent tile\n    if( dist.y < kTileSizePixels && dist.x >= kTileSizePixels && dist.x < ( kTileSizePixels * 2.0 ) )\n        gridPos.x += 1.0;\n    \n    // This is touching the left-adjacent tile\n    else if( dist.y > ( kTileSizePixels * 4.0 ) && dist.x < kTileSizePixels )\n        gridPos.x -= 1.0;\n    \n    return gridPos;\n}\n\n// Note: written for online ShaderToy: https://www.shadertoy.com/new\nvoid mainImage( out vec4 fragColor, in vec2 pixelPos )\n{\n\t// Take the global clock and wrap it for the whole animation length (which is two rotations and two delays)\n    float time = mod( iTime, kAnimationDelay * 2.0 + kAnimationDuration * 2.0 );\n    \n    // Initial white tile rotation\n    float delay = kAnimationDelay;\n    float duration = kAnimationDuration;\n    \n    float whiteTilePhase = ( clamp( time, delay, delay + duration ) - delay ) / duration;\n    whiteTilePhase = sin( whiteTilePhase * kHalfPI );\n    \n    // Second black tile rotation\n    delay = kAnimationDelay + kAnimationDuration + kAnimationDelay;\n    \n    float blackTilePhase = ( clamp( time, delay, delay + duration ) - delay ) / duration;\n    blackTilePhase = 1.0 - sin( blackTilePhase * kHalfPI );\n    \n    // Compute flags for which tile is rotating\n    bool rotatingLight = ( time < ( kAnimationDelay + kAnimationDuration ) );\n    float rotationPhase = rotatingLight ? whiteTilePhase : blackTilePhase;\n    \n    // For this pixel, find which cross-pair coordinate (which is in grid-space, not yet pixel-space) to draw\n    vec2 gridPosition = GetCrossPairPosition( pixelPos );\n    \n    // We must draw all four adjacent cross-pairs, to make sure during rotation\n    // we allow the adjacent rotating bits to pass through to our chunk. This is\n    // visual improvement, as you see less edge clipping\n    \n    // Convert from grid to pixel-space\n    vec2 crossPairOrigin = ( gridPosition.x * kCrossdx + gridPosition.y * kCrossdy ) * kTileSizePixels;\n    vec2 crossPairLeft = ( ( gridPosition.x - 1.0 ) * kCrossdx + gridPosition.y * kCrossdy ) * kTileSizePixels;\n    vec2 crossPairRight = ( ( gridPosition.x + 1.0 ) * kCrossdx + gridPosition.y * kCrossdy ) * kTileSizePixels;\n    vec2 crossPairTop = ( gridPosition.x * kCrossdx + ( gridPosition.y + 1.0 ) * kCrossdy ) * kTileSizePixels;\n    vec2 crossPairBottom = ( gridPosition.x * kCrossdx + ( gridPosition.y - 1.0 ) * kCrossdy ) * kTileSizePixels;\n    \n    // Sum *all* of the cross-pair colors\n    float color = TestCrossPairShape( crossPairOrigin, pixelPos, bool(mod(gridPosition.x, 2.0)), rotatingLight, rotationPhase );\n    color += TestCrossPairShape( crossPairLeft, pixelPos, bool(mod(gridPosition.x - 1.0, 2.0)), rotatingLight, rotationPhase );\n    color += TestCrossPairShape( crossPairRight, pixelPos, bool(mod(gridPosition.x + 1.0, 2.0)), rotatingLight, rotationPhase );\n    color += TestCrossPairShape( crossPairTop, pixelPos, bool(mod(gridPosition.x, 2.0)), rotatingLight, rotationPhase );\n    color += TestCrossPairShape( crossPairBottom, pixelPos, bool(mod(gridPosition.x, 2.0)), rotatingLight, rotationPhase );\n    \n    // If color is transparent, set background based on current animation flags\n    if( color == kTransparentColor )\n    \tcolor = rotatingLight ? kDarkColor : kLightColor;\n    \n    // Draw color\n    fragColor = vec4( color, color, color, 1.0 );\n}\n","name":"Image","description":"","type":"image"}]}