{"ver":"0.1","info":{"id":"WttBWj","date":"1613476410","viewed":235,"name":"Trivial Algorithm for Water","username":"Clocktown","description":"Implementation of \"Trivial Algorithm for Interactive Water Simulation\" from AVR 2018\n\nShading could still be improved, and the terrain could be more interesting! Suggestions welcome.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["2d","simulation","heightfield","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"Main\n{\n    InitUV;\n    \n    float b = terrain(Mid);\n    float d = D(iMid).x;\n    \n    vec2 dh = vec2(\n        (D(iRight).x + terrain(Right)) - (D(iLeft).x + terrain(Left)),\n        (D(iUp).x + terrain(Up)) - (D(iDown).x + terrain(Down))\n    );\n    dh *= 0.5;\n    vec3 n = -cross(normalize(vec3(scale, dh.x, 0.0)), normalize(vec3(0.0, dh.y, scale)));\n\n    // Output to screen\n    result = vec4(mix(vec3(b), vec3(0.0, 0.0, 0.5) + (0.75 * vec3(1.0 - n.y)), d),1.0);\n    //result = vec4(vec3(n.y), 1.0);\n    //result = vec4( d, 0.0, 0.0, 1.0);\n    //result = vec4(vec3(b), 1.0);\n    //result = 10.0*C(iMid);\n    //result.w = 1.0;\n    //result = vec4(vec3(10.0*C(iMid).w), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Config Params\nconst float K = 0.9999; // \"Viscosity\" - 1 is no viscosity, lower is higher viscosity (essentially damping)\nconst float P_1 = 0.25; // Speed scale - should probably be 0.25 at most, higher causes bugs\nconst float P_2 = 0.0001;//0.0000001; // Minimum difference that causes overflow\nconst float scale = 0.0001; // defines the width of a cell, used in shading ( water/terrain height are in the order of 1 )\n\n\n// Lots of weird macros\n#define Main void mainImage( out vec4 result, in vec2 fC )\n#define InitUV UV = fC/iResolution.xy; dUV = vec2(1.0)/(iResolution.xy); px = ivec2(fC); Res = iResolution.xy;\n\n// Macros to grab the individual channels with offset\n#define A(x) texelFetch(iChannel0, px + x, 0)\n#define B(x) texelFetch(iChannel1, px + x, 0)\n#define C(x) texelFetch(iChannel2, px + x, 0)\n#define D(x) texelFetch(iChannel3, px + x, 0)\n\n// Macros for pixel offset vectors\n#define Mid vec2(0.0)\n#define iMid ivec2(0)\n#define Left vec2(-1.0, 0.0)\n#define Right vec2(1.0, 0.0)\n#define Up vec2(0.0, 1.0)\n#define Down vec2(0.0, -1.0)\n#define iLeft ivec2(-1, 0)\n#define iRight ivec2(1, 0)\n#define iUp ivec2(0, 1)\n#define iDown ivec2(0, -1)\n\n// Noise functions from Patricio Gonzalez Vizo: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\n// End of Noise functions\n\nivec2 px; // fragCoord in integer, calculate by macro at beginning\nvec2 UV; // UV, calculate it by macro at beginning\nvec2 dUV; // delta UV, calculate it by macro at beginning\nvec2 Res;\n\n// Terrain at integer offset to current pixel\nfloat terrain(vec2 off) {\n    vec2 p = UV + off * dUV;\n    \n    ivec2 pos_pix = ivec2(p * Res);\n    \n    if(pos_pix.x <= 5 || pos_pix.y <= 5 || pos_pix.x >= int(Res.x - 6.0) || pos_pix.y >= int(Res.y - 6.0)) {\n            return 100.0;\n    }\n    \n    // A Noise with slope\n    return noise(10.0 * p) * (1.0 - p.x);\n    \n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// RGBA Inertia\n// reads C + D, writes A\n\nMain\n{\n    InitUV;\n    \n    // Todo: store terrain + depth instead of depth to optimize\n    float dx = D(iMid).x;\n    float hx = terrain(Mid) + dx;\n    vec4 ha = vec4(\n        terrain(Left) + D(iLeft).x,\n        terrain(Up) + D(iUp).x,\n        terrain(Right) + D(iRight).x,\n        terrain(Down) + D(iDown).x\n    );\n    \n    vec4 outflow = max(vec4(hx) - ha, vec4(0.0));\n    \n    vec4 prevS = C(iMid);\n    vec4 S = K * prevS + P_1 * outflow;\n    \n    float Ssum = S.x + S.y + S.z + S.w;//dot(S, vec4(1.0));\n    \n    if(dx < Ssum) {\n        S = (dx * S) / Ssum;\n        Ssum = dx;\n    }\n    \n    // Explicitly fix the boundary, seems to be necessary\n    if(px.x <= 5 || px.y <= 5 || px.x >= int(iResolution.x - 6.0) || px.y >= int(iResolution.y - 6.0)) {\n        S = vec4(0.0);\n    }\n    \n    result = Ssum > P_2 ? S : vec4(0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// water depth\n// reads A and D, writes B\n\nMain\n{\n    InitUV;\n    \n    float dx = D(iMid).x;\n    vec4 S = A(iMid);\n    vec4 adjS = vec4 (\n        A(iLeft).z,\n        A(iUp).w,\n        A(iRight).x,\n        A(iDown).y\n    );\n    \n    float adjSsum = adjS.x + adjS.y + adjS.z + adjS.w; //dot(adjS, vec4(1.0));\n    float Ssum = S.x + S.y + S.z + S.w; //dot(S, vec4(1.0));\n    \n    if(px.x <= 5 || px.y <= 5 || px.x >= int(iResolution.x - 6.0) || px.y >= int(iResolution.y - 6.0)) {\n       result = vec4(0.0);\n    } else {\n        result = vec4(max(dx - Ssum + adjSsum, 0.0), 0.0, 0.0, 0.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// RGBA Inertia (pong)\n\nMain\n{\n    InitUV;\n    \n    vec4 inertia = A(iMid);\n    \n    if(iFrame == 0) {\n        inertia = vec4(0.0);\n    }\n    \n    result = inertia;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// water depth (pong)\n\nMain\n{\n    InitUV;\n    \n    vec4 depth = B(iMid);\n    \n    if(iFrame == 0) {\n        depth.x = 1.0 - UV.x;\n        if(px.x <= 10 || px.y <= 10 || px.x >= int(iResolution.x - 11.0) || px.y >= int(iResolution.y - 11.0)) {\n            depth.x = 0.0;\n        }\n    }\n    \n    result = depth;\n}","name":"Buffer D","description":"","type":"buffer"}]}