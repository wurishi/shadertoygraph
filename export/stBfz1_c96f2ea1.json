{"ver":"0.1","info":{"id":"stBfz1","date":"1651862146","viewed":347,"name":"Ray Marching Basics_","username":"incre_ment","description":"Putting together all the knowledge I've learned in regards to ray marching, so far. \ngoRay uses constant step sized (dt) to find the objects (SLOW)\ngoRay2 uses the distance functions to determine the step size (FAST)","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Marching Fundamentals\n//\n// SDFs from IQ:\n// https://iquilezles.org/articles/distfunctions/\n// goRay uses set steps (dt) to find the objects (SLOW)\n// goRay2 uses the distance functions to determine the step size (FAST)\n\n// Rotation Matrices grabbed from here:\n// https://www.shadertoy.com/view/fdjGRD\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nstruct ray{\n vec3 direction;\n vec3 origin;\n};\n\n// \n\n// Sphere SDF function\nfloat sdSphere( vec3 p, float sphereDim, vec3 sphereLoc)\n{\n    return length(p - sphereLoc)-sphereDim;\n}\n\n// Rounded Box SDF Function\nfloat sdBox( vec3 p, vec3 boxDim, vec3 boxLoc, mat3 transform )\n{\n  p = (p - boxLoc) * transform;\n  vec3 q = abs(p) - boxDim;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.1;\n}\n\n// Torus SDF Function\nfloat sdTorus( vec3 p, vec2 t, vec3 torusLoc, mat3 transform )\n{\n  p = (p - torusLoc) * transform;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nvec3 calcNormalSphere(in vec3 p, float dimVal, vec3 loc){\n  vec2 e = vec2(1.0, -1.0) * .0005;\n  \n  return normalize(\n    e.xyy * sdSphere(p + e.xyy, dimVal, loc) +\n    e.yyx * sdSphere(p + e.yyx, dimVal, loc) +\n    e.yxy * sdSphere(p + e.yxy, dimVal, loc) +\n    e.xxx * sdSphere(p + e.xxx, dimVal, loc));\n}\n\nvec3 calcNormalBox(in vec3 p, vec3 dimVal, vec3 loc, mat3 transform){\n  vec2 e = vec2(1.0, -1.0) * .0005;\n  \n  return normalize(\n    e.xyy * sdBox(p + e.xyy, dimVal, loc, transform) +\n    e.yyx * sdBox(p + e.yyx, dimVal, loc, transform) +\n    e.yxy * sdBox(p + e.yxy, dimVal, loc, transform) +\n    e.xxx * sdBox(p + e.xxx, dimVal, loc, transform));\n}\n\nvec3 calcNormalTorus(in vec3 p, vec2 dimVal, vec3 loc, mat3 transform){\n  vec2 e = vec2(1.0, -1.0) * .0005;\n  \n  return normalize(\n    e.xyy * sdTorus(p + e.xyy, dimVal, loc, transform) +\n    e.yyx * sdTorus(p + e.yyx, dimVal, loc, transform) +\n    e.yxy * sdTorus(p + e.yxy, dimVal, loc, transform) +\n    e.xxx * sdTorus(p + e.xxx, dimVal, loc, transform));\n}\n\n// Updated May 7, 2022 with feedback from FN.\nbool goRay2(vec3 ro, vec3 rd, out vec3 p, out vec3 pN)\n{\n    float mint = -5.0;  // Minimum trace distance\n    float maxt = 20.0;   // Maximum trace distance\n   \n    float dist = mint;\n    while(dist < maxt)\n    {\n        vec3 p = ro + rd*dist;       \n        \n        float sphereRad = .5;\n        vec3 sphereLocation = vec3(1.2,0.,-2.0);\n        float d1 = sdSphere(p,sphereRad,sphereLocation);\n        pN = calcNormalSphere(p, .5, sphereLocation);\n        \n        vec3 boxDimension = vec3(.25,.25,.25);\n        vec3 boxLocation = vec3(-1.2,0.,-2.0);\n        float d2 = min(d1,sdBox(p,boxDimension, boxLocation, rotateX(iTime)*rotateZ(iTime)));\n        if(d2!=d1)pN = calcNormalBox(p, boxDimension, boxLocation, rotateX(iTime)*rotateZ(iTime));\n\n          \n        vec2 torusDimension = vec2(.4,.15);\n        vec3 torusLocation = vec3(.0,0.,-2.0);\n        float d3 = min(d2, sdTorus(p,torusDimension,torusLocation, rotateX(iTime)));\n        if(d3!=d2)pN = calcNormalTorus(p, torusDimension, torusLocation, rotateX(iTime));\n        \n        dist = dist + d3;\n        if (d3 < .001) return true;\n        \n    }\n    return false;\n}\n\n\nbool goRay(vec3 ro, vec3 rd, out vec3 p, out vec3 pN)\n{\n    float dt = 0.02;     // Step delta\n    float mint = -5.0;  // Minimum trace distance\n    float maxt = 20.0;   // Maximum trace distance\n   \n    // Perform the trace, one step (dt) at a time\n    for( float t = mint; t < maxt; t += dt )\n    {\n        vec3 p = ro + rd*t;\n        \n        float sphereRad = .5;\n        vec3 sphereLocation = vec3(1.2,0.,-2.0);\n        if (sdSphere(p,sphereRad,sphereLocation) < .001){\n          pN = calcNormalSphere(p, .5, sphereLocation);\n          return true;\n        }\n        \n        vec3 boxDimension = vec3(.15,.15,.15);\n        vec3 boxLocation = vec3(-1.2,0.,-2.0);\n        if (sdBox(p,boxDimension, boxLocation, rotateX(iTime)*rotateZ(iTime)) < .001){\n        pN = calcNormalBox(p, boxDimension, boxLocation, rotateX(iTime)*rotateZ(iTime));\n          return true;\n        \n        }\n        \n        vec2 torusDimension = vec2(.4,.15);\n        vec3 torusLocation = vec3(.0,0.,-2.0);\n        if (sdTorus(p,torusDimension,torusLocation, rotateX(iTime)*rotateZ(iTime)) < .001){\n        pN = calcNormalTorus(p, torusDimension, torusLocation, rotateX(iTime)*rotateZ(iTime));\n          return true;\n        \n        }\n    }\n    return false;\n}\n\nfloat PI = 3.14159256;\nfloat TAU = 2.*3.14159256;\n\nvoid mainImage0( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   \n   // Background Horizon\n   vec3 horizon = vec3(smoothstep(0.,1.0,pow(19.,-abs(uv.y)-abs(uv.x)*.4)));\n   vec3 col = horizon;\n   \n   // Create ray at eye location, through each point in the \"screen\"\n   ray r;\n   r.origin = vec3(0.,0.,4.); \n   r.direction = normalize(vec3(uv,1.) - r.origin);\n\n   vec3 p, pN;\n   if (goRay2(r.origin, r.direction, p, pN)){\n      \n     vec3 rr = reflect(r.direction, pN); \n     vec3 reflecter = texture(iChannel0,rr).rgb;\n    \n     col = reflecter*.6;\n     \n     // Diffuse light    \n     vec3 light = vec3(0.,0.,1.0);\n     // vec3 light = vec3(.5+.4*sin(iTime),cos(iTime),1.); \n     float dif = clamp(dot(pN, normalize(light-p)),0.,1.);\n     dif *= 9./dot(light - p, light - p);\n     col *= vec3(pow(dif, 0.4545));\n   }\n    \n   fragColor = vec4(col,1.0);\n}\n\n// smart AA, from FabriceNeyret (FN).\nvoid mainImage(out vec4 O, vec2 U) {\n    mainImage0(O,U);\n    bool AA = true;  // AA option\n    if(AA)\n    if ( fwidth(length(O)) > .01 ) {  // difference threshold between neighbor pixels\n        vec4 o;\n        for (int k=0; k < 9; k+= k==3?2:1 )\n          { mainImage0(o,U+vec2(k%3-1,k/3-1)/3.); O += o; }\n        O /= 9.;\n    //  O.r++;                        // uncomment to see where the oversampling occurs\n    }\n}","name":"Image","description":"","type":"image"}]}