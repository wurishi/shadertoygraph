{"ver":"0.1","info":{"id":"43scWH","date":"1726107797","viewed":5,"name":"Pure unbridled chaos","username":"Thor","description":"Background Pattern Credit:\nUser: iq\nTitle: Voronoi - basic","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["yeah","oh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//Background pattern code\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(iTime+6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //For Pattern\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    // Normalized y pixel coordinates (from 0 to 1)    \n    // apply same scale to x pixels\n    vec2 uv = fragCoord/iResolution.yy;\n    vec2 Mouseuv = iMouse.xy/iResolution.yy;\n    \n    //subtracting 0.5 moves origin to middle of window\n    //however x is at a different scale, so we need to scale\n    //based on aspect ratio\n    uv.x = uv.x - 0.5*(iResolution.x/iResolution.y);\n    uv.y = uv.y - 0.5;\n    \n    Mouseuv.x = Mouseuv.x - 0.5*(iResolution.x/iResolution.y);\n    Mouseuv.y = Mouseuv.y - 0.5;\n\n    //set background color\n    //Credit: user=iq, title=Voronoi - basic \n    // computer voronoi patterm\n    vec2 c = voronoi( (14.0+6.0*sin(0.2*iTime))*p );\n\n    // colorize\n    vec3 col = 0.5 + 0.5*cos( c.y*6.2831 + vec3(0.0,1.0,2.0) );\t\n    col *= clamp(1.0 - 0.4*c.x*c.x,0.0,1.0);\n    col -= (1.0-smoothstep( 0.08, 0.09, c.x));\n    \n    //distance along ray\n    float t = 0.0;\n    float tdx = 0.0;\n    float tdy = 0.0;\n    \n    //small distance to offset point\n    float d = 0.0001f;\n    \n    //position and size of the sdf sphere\n    vec3 boxPos = vec3(0.0,-0.15,10.0);\n    vec3 boxDim = vec3(0.25,0.25,0.25);\n    vec3 octPos = vec3(0.0,0.12,10.0);\n    float boxRad = 0.125f;\n    float octDim = 0.25f;\n    float k = 0.1f;\n    \n    vec3 lightPos = vec3(Mouseuv, 0.0);\n    \n    \n    //starting point of ray and the direction it follows\n    vec3 pt = vec3(uv.x, uv.y, 0.0);\n    vec3 ptdx = vec3(uv.x+d, uv.y, 0.0);\n    vec3 ptdy = vec3(uv.x, uv.y+d, 0.0);\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0));\n     \n    //loop that allows us to keep moving along the ray \n    //until we hit the shape or until we run out of \n    //loop iterations (and hit nothing)\n    for( int i = 0; i < 25; i++){\n    \n        //calc positions from view rays\n        vec3 pos = pt + dir * t;\n        vec3 posdx = ptdx + dir * tdx;\n        vec3 posdy = ptdy + dir * tdy;\n            \n        \n        //get distance from position to sphere\n        //subtract spherePos from pos allows us to \"move\"\n        // the position of the sphere in the world\n        //otherwise it is stuck at the world origin\n        float dist = smin(sdRoundBox(pos - boxPos, boxDim, boxRad),\n                         sdOctahedron(pos - octPos, octDim), k);\n        float distdx = smin(sdRoundBox(posdx - boxPos, boxDim, boxRad),\n                           sdOctahedron(posdx - octPos, octDim), k);\n        float distdy = smin(sdRoundBox(posdy - boxPos, boxDim, boxRad),\n                           sdOctahedron(posdy - octPos, octDim), k);\n              \n        if(dist < 0.001 &&\n            distdx < 0.001 &&\n            distdy < 0.001){ //point on ray is close enough\n                        //we'll call this a \"hit\"\n                        \n            vec3 normal = normalize(cross(\n                normalize(posdx - pos),\n                normalize(pos - posdy)));\n                \n            \n            col = vec3(1.0)*dot(normal, normalize(lightPos - pos));  //lets color this fragment\n            col += texture(iChannel0, uv + iTime).rgb*0.75*cos(iTime)*tan(iTime)-.25;\n                              // a \"sphere color\"\n            break;  //stop checking\n            \n        }\n        //update distance along ray if haven't hit yet\n        t += dist;\n        tdx += distdx;\n        tdy += distdy;\n    }\n    //Add noise\n    col += texture(iChannel1, iTime - (2.0 * floor(iTime/2.0)) + texture(iChannel1, iTime - (3.0 * floor(iTime/3.0)) + texture(iChannel1,uv).xy).xy).rgb;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}