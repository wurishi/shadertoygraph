{"ver":"0.1","info":{"id":"wtffDl","date":"1598037488","viewed":193,"name":"Shadow dancing","username":"bwestlin","description":"Playing around with light and shadow rendering turned out to look like some form of dancing shadows.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sound","lightning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SHOW_LIGHTS 1\n#define LIGHT_SIZE  0.2\n\n#define M_NONE\t\t0.0\n#define M_FLOOR\t\t1.0\n#define M_SPHERE\t2.0\n#define M_SPHERE2\t3.0\n#define M_L1\t\t4.0\n#define M_L2\t\t5.0\n\nfloat m(float i) {\n    return texture(iChannel0, vec2(i, 0.0)).x * 2.0;    \n}\n\nvec3 camera(vec2 uv, vec3 origin, vec3 target) {\n    vec3 forward = normalize((target - origin) * vec3(1.0, 1.0, 2.5));\n\tvec3 side = cross(forward, vec3(0.0, 1.0, 0.0));\n\tvec3 up = cross(side, forward);\n\tvec3 rayDir = forward + uv.x * side + uv.y * up;\n\treturn normalize(rayDir);\n}\n\nfloat sdSphere( vec3 p, float s ) {\n\treturn length(p) - s;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\n\n// Smooth minimum : https://iquilezles.org/articles/smin\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat smin08( float a, float b) {\n    return smin(a, b, 0.8);\n}\n\nvec3 l1pos() {\n    return vec3((-3.0 + m(0.1)) * cos(iTime), m(0.6), -5.0);\n}\n\nvec3 l2pos() {\n    return vec3((3.0 + m(0.2)) * cos(iTime), m(0.5), -5.0);\n}\n\nvec2 map(vec3 p, bool lights) {\n    float sphere = sdSphere(p - vec3(0.0, sin(iTime) * 0.2 * m(0.2) * 5.0, -3.0), 1.0);\n    float plane = sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));\n    \n    float sphere2 = smin08(\n        sdSphere(p - vec3( 1.5, -1.0 + sin(iTime * 4.0) * 0.2, -2.5), 1.0),\n        sdSphere(p - vec3(-1.5,-1.0 + sin(iTime * 4.0 + 3.14) * 0.2, -2.5), 1.0)\n    );\n           \n    #if (SHOW_LIGHTS == 0)\n    lights = false;\n    #endif\n    float l1 = lights ? sdSphere(p - l1pos(), LIGHT_SIZE) : 100000.0;\n    float l2 = lights ? sdSphere(p - l2pos(), LIGHT_SIZE) : 100000.0;\n    \n    float d = min(min(smin08(sphere2, smin08(sphere, plane)), l1), l2);\n    \n    if (d == sphere) return vec2(d, M_SPHERE);\n    if (d == sphere2)return vec2(d, M_SPHERE2);\n    if (d == plane)  return vec2(d, M_FLOOR);\n    if (d == l1)  return vec2(d, M_L1);\n    if (d == l2)  return vec2(d, M_L2);\n    \n    return vec2(d, M_NONE);\n}\n\nvec3 normal(vec3 p) {\n    vec3 eps = vec3(0.01, 0.0, 0.0);\n    float x = map(p, true).x;\n    return normalize(vec3(\n        map(p + eps.xzz, true).x - x,\n        map(p + eps.zxz, true).x - x,\n        map(p + eps.zzx, true).x - x\n    ));\n}\n\nvec2 intersect(vec3 origin, vec3 rayDir) {\n    float eps = 0.01;\n    float maxDistance = 100.0;\n    float t = 0.0;\n    \n    vec2 dm = vec2(0.1, M_NONE);\n    \n    for (int i = 0; i < 200; i++) {\n        t += dm.x;\n        dm = map(t * rayDir + origin, true);\n        \n        if (abs(dm.x) <= eps) {\n            break;\n        }\n        if (t > maxDistance) {\n            return vec2(0.0, M_NONE);\n        }\n    }\n    return vec2(t, dm.y);\n}\n\n// Soft shadows: https://iquilezles.org/articles/rmshadows\nfloat shadow(in vec3 ro, in vec3 rd, float mint, float maxt, float k) {  \n    float res = 1.0;\n    for (float t = mint; t < maxt;) {\n        float h = map(ro + rd * t, false).x;\n        if (h < 0.001)\n            return 0.0;\n        res = min(res, k * h / t);\n        t += h;\n    }\n    return res;    \n}\n\nfloat is_shadow(vec3 hit, vec3 lightpos) {\n    vec3 rayDir = normalize(lightpos - hit);\n    float maxDistance = abs(length(lightpos - hit));\n    return shadow(hit, rayDir, 0.1, maxDistance, 32.0);\n}\n\nvec3 diffuseLightning(vec3 n, vec3 lightDir, vec3 lightColor) {\n    float diffuse = dot(n, lightDir);        \n    return lightColor * max(0.0, diffuse);\n}\n\nvec3 specularLightning(vec3 n, vec3 rayDir, vec3 lightDir, vec3 lightColor, float shininess) {\n    float ratio = dot(rayDir, -reflect(lightDir, n));\n\treturn lightColor * pow(max(0., ratio), shininess);\n}\n\nvec3 light(vec3 lightPos, vec3 lightColor, vec3 color, vec3 hit, vec3 n, vec3 rayDir) {\n    vec3 lightDir = normalize(hit - lightPos);\n    vec3 refLight = reflect(lightDir, n);\n    \n    float dist = length(hit - lightPos);\n    float attenuation = (1.0 / (dist * dist)) * (sin(iTime) * 150.0 + 175.0);    \n    lightColor *= attenuation;\n    color += diffuseLightning(n, refLight, lightColor) / 5.0;\n    color *= diffuseLightning(n, refLight, lightColor);\n    color += specularLightning(n, rayDir, lightDir, lightColor, 50.);\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraOrigin = vec3(-(sin(iTime * 0.2) * 3.0 + 2.0), sin(iTime * 0.33) * 3.0 + 2.0, 3.0) * (sin(iTime * 0.66) * 0.25 + 0.75);\n    vec3 cameraTarget = vec3(0.0, -3.0, 0.0);\n\n\tvec2 mPos = vec2(0.0);\n    if (iMouse.x > 0.0 && iMouse.y > 0.0) {\n        mPos = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n    }\n           \n    cameraTarget.xy -= mPos * 8.;\n    \n    vec3 rayDir = camera(uv, cameraOrigin, cameraTarget);\n\n    vec3 color = vec3(0.0);\n    \n    vec2 dm = intersect(cameraOrigin, rayDir);\n    float t = dm.x;\n    float material = dm.y;\n    \n    if (t > 0.0) {\n        vec3 hit = cameraOrigin + t * rayDir;\n        \n        vec3 n = normal(hit);\n        vec3 origColor = vec3(1.0, 0.5, 0.7);\n        \n        vec3 l1color = vec3(sin(iTime * 2.1111) * 0.5 + 0.5, 0.5, sin(iTime * 5.1111) * 0.5 + 0.5);\n        vec3 l1 = light(l1pos(),\n                        l1color,\n                        origColor,\n                        hit,\n                        n,\n                        rayDir) * is_shadow(hit, l1pos());\n\n        vec3 l2color = vec3(sin(iTime * 8.1111) * 0.5 + 0.5, 0.5, sin(iTime * 1.333) * 0.5 + 0.5);\n        vec3 l2 = light(l2pos(),\n                        l2color,\n                        origColor,\n                        hit,\n                        n,\n                        rayDir) * is_shadow(hit, l2pos());\n        \n        color = l1 + l2;\n        \n        #if (SHOW_LIGHTS == 1)\n        if (material == M_L1) color = l1color * 5.0;\n        if (material == M_L2) color = l2color * 5.0;\n        #endif\n    }\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}