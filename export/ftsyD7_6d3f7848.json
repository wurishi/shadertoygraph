{"ver":"0.1","info":{"id":"ftsyD7","date":"1648127159","viewed":131,"name":"Purple Eye","username":"Tiposan","description":"eye ball","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["eye"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 opU2(vec2 d1, vec2 d2)\n{\n    return (d1.x < d2.x) ? d1 : d2;\n}\nvec2 Union(vec2 d1, vec2 d2){\n    return min(d1,d2);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nvec2 map(vec3 pos)\n{\n    \n    vec2 v = vec2(sdSphere(pos+vec3(0.0, 0.0, 0.0), 1.0),1.0);\n    vec2 v2 = vec2(sdSphere(pos+vec3(1.5, 0.0, 0.0), 1.0),1.0);\n    //vec2 sdf_with_materials = opU2(v ,v2);\n    vec2 sdf_with_materials = Union(v, v2);\n    \n    return v;\n}\nvec3 GetNormal (vec3 pos)\n{\n    float v = map(pos).x;\n    vec2 e = vec2(0.001, 0.0);\n    return normalize(vec3(\n        map(pos+e.xyy).x,\n        map(pos+e.yxy).x,\n        map(pos+e.yyx).x) - v);\n}\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat Checker(vec2 uv, vec2 scale)\n{\n    return sign(sin(uv.x*scale.x))* sign(sin(uv.y*scale.y));\n}\nvec2 castRay(vec3 ro, vec3 rd)\n{\n    float c = 0.0;\n    for(int i=0; i<64; i++)\n    {\n        vec2 ray = map(ro + rd * c);\n        if(ray.x <(0.0001*c))\n        {\n            return vec2(c, ray.y);\n        }\n        c += ray.x;\n    }\n    return vec2(-1., 0.0);\n}\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec2 contact = castRay(ro, rd);\n    vec3 nor = GetNormal(ro+ rd *contact.x);\n    \n    vec3 lightDir = vec3(1., 1., 2.);\n    \n    float lambert = dot(nor, lightDir);\n    vec3 col;\n    \n    if (contact.x ==-1.0)\n    {\n        col = vec3(155./255.,196./255.,233./255.);\n    }\n    else\n    {\n       \n        vec3 pos= ro+ rd * contact.x;\n        vec2 projectionUp = pos.xy;\n        projectionUp = projectionUp + 0.5;\n        float rand = clamp(sin(iTime)*5., -0.2, 0.2)+clamp(sin(iTime*3.)/2., -0.05, 0.05);\n\n        projectionUp.x += .5 + rand;\n        projectionUp.x *= .55;\n        \n        col = texture(iChannel1, projectionUp).rgb * 0.5; \n        col*=lambert;\n        \n        //nor.xz *= rot(2.);\n        float fresnel = pow((dot(nor, rd)+1.)*0.5, 1.)*1.5;\n        col += fresnel;\n        vec3 ref = reflect(rd, nor);\n        vec3 cub = texture(iChannel2, ref).rgb*0.15;\n        //col = vec3(fract(projectionUp.x), fract(projectionUp.y), 0.0);\n        col += cub;\n        \n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.,0.0,4.);\n    vec3 cameraTar = vec3(0.0);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0,-1.,0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y* up +2. * forward);\n    // Time varying pixel color\n    vec3 col = render(cameraPos, viewDir);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)\n{\n    return a + b*cos(6.28318*(c*t+d));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = 2.*fragCoord/iResolution.xy-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float p_angle = atan(uv.x, uv.y);\n    float p_distance = length(uv) * 2.;\n    vec2 st = vec2(p_distance, p_angle);\n    //creation de l'iris\n    vec3 iris= texture(iChannel0, vec2(1./(st.x*1.3), st.y*1.3)).rgb*palette(length(uv), vec3(0.4, 0.3, 0.4), vec3(0.6,0.1,0.6), vec3(0.3,0.5,.0), vec3(0.0,.1, 0.1));\n    iris *= min(st.x*1.7,2.);\n    //mask iris\n    vec3 maskIris = vec3(step(length(uv), 0.8));\n    vec3 maskIris2 = vec3(1.-step(length(uv), 0.8));\n    \n    //creation de la pupile\n    vec3 pupile = vec3(1.-step(length(uv), 0.28));\n    \n    //Ombre haut\n    vec3 shadow = vec3(abs(sin(uv.y-0.6)));\n    //ombre border\n    vec3 borderShadow = vec3(1.-length(uv*2.5)+1.6);\n    \n    //float borderShadow = clamp(1.-length(uv*3.);\n    \n    vec3 col = vec3(maskIris * iris * pupile * shadow * borderShadow + maskIris2);\n    //vec3 col = borderShadow;\n    fragColor = vec4(col,1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}