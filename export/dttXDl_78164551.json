{"ver":"0.1","info":{"id":"dttXDl","date":"1685881719","viewed":63,"name":"Fork My First S goshanov 174","username":"goshanov","description":"My first shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["first"],"hasliked":0,"parentid":"DtcSWB","parentname":"My First Shader xxx Private"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdEquilateralTriangle( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// cosine based palette, 4 vec3 params\nvec3 palette( in float t)\n{\n    const vec3 a = vec3(0.508, .558, .688);\n    const vec3 b = vec3(.5, .498, .318);\n    const vec3 c = vec3(-0.472, 1., .648);\n    const vec3 d = vec3(-1.082, -1.792, .498);\n    \n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 rotate2D(in vec2 vec, float rotateAngle) {\n    return vec2(\n        vec.x * cos(rotateAngle) - vec.y * sin(rotateAngle), \n        vec.x * sin(rotateAngle) + vec.y * cos(rotateAngle)\n    );\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 uv0 = uv;\n    \n    uv = uv * 2.;\n    uv = fract(uv);\n    uv = uv - 0.5;\n    \n    float centerDistance = length(uv0);\n    \n    vec2 rotated = rotate2D(uv0, iTime);\n    \n    float dTri = sdEquilateralTriangle(rotated, 1.);\n    dTri = abs(dTri);\n    \n    vec3 colorTri = palette(dTri);\n    vec3 constColorTri = vec3(dTri, 0, 0);\n    float circleDistance = sdCircle(uv, 0.04 * centerDistance);\n    circleDistance = sin(circleDistance * 2.5) * circleDistance * 2. \n      - sin(uv0.y * 13. + iTime * centerDistance / 26.) / 14.;\n    \n    float d0 = sdPentagon(rotate2D(uv0, -iTime / 2.), 2.);\n    \n    \n    \n    float d = sin(5. * d0 + iTime) / 5.;\n    d = abs(d);\n    d = d;\n       \n    vec3 color = palette(d * 5. + iTime * 1.5) / d * 0.04;\n    float fixedCircleDistance = (circleDistance + smoothstep(0.2, 0.5, circleDistance) + 0.075);\n   \n    color = color / fixedCircleDistance ;\n    \n    color += colorTri * 0.5;\n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}