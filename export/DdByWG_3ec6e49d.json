{"ver":"0.1","info":{"id":"DdByWG","date":"1688075711","viewed":69,"name":"Smooth External Ray II","username":"PhDFractal","description":"Like the first Smooth External Ray, except now the ray must go through the mouse location! (Resolution ≤ 10 iterations)","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["fractal","julia","ray","mandelbrot","smooth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////////\n//\n// Smooth External Ray Part II\n//\n// Coloring algorithm for smooth external rays of Absolute and regular Julia.\n// The map is the rounded sawtooth: θ↦2×(θ-π×round(θ/π)). Hence the principal\n// external ray is not identifiable, but among the 2^i rays in ith iteration\n// Smooth escape algorithm was used, and the width of the external ray\n// smoothly decreases by a factor of 2 per iteration. Only shows top half of\n// the Mandelbrot because bottom is symmetric.\n//\n// Press 'o' for original Mandelbrot, and 'o' again for Julia comparison.\n//\n// The ray will go along with the mouse but the sawtooth map is non-invertible.\n// So the rays must stay within [-π,π]/2^iter and jump every π/2^iter.\n// e.g. Currently the Böttcher Isomorphism is too hard to vectorize.\n//\n// Resolution ≤ 10 iterations.\n//\n// Only 25 iterations used for Mandelbrot due to low precision. \n// \n////////////////////////////////////////////////////////////////////////////////\n\n// Created by PhdFractal: https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by PhdFractal (@Fractal MathPro)\".\n\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; }    //for switching modes\nvec4 rainbow(float i,float density){                                                 //rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    float r=(i*density-5.)-100.*floor((i*density-5.)/100.); float R=0.;\n    if(r<16.){ R=r/16.; return R*red+(1.-R)*black; }\n    else if(r>=16. && r<31.){ R=(r-16.)/15.; return R*yellow+(1.-R)*red; }\n    else if(r>=31. && r<45.){ R=(r-31.)/14.; return R*green+(1.-R)*yellow; }\n    else if(r>=45. && r<62.){ R=(r-45.)/17.; return R*cyan+(1.-R)*green; }\n    else if(r>=62. && r<78.){ R=(r-62.)/16.; return R*blue+(1.-R)*cyan; }\n    else{ R=(r-78.)/22.; return R*black+(1.-R)*blue; }\n}\nvec2 sqr(vec2 z){ return vec2(z.x*z.x-z.y*z.y,2.*z.x*z.y); }                         //square,ing\nfloat pi=3.14159265359;                                                              //π\nfloat arg(vec2 z){                                                                   //argument\n    float magn=sqrt(z.x*z.x+z.y*z.y);\n    if(magn==0.) { return 0.; }\n    float arg=acos(z.x/magn);\n    if(z.y>=0.){ return arg; }\n    else{ return -arg; }\n}\nfloat thickness=0.5; float realthick=0.; float index=0.; float density=0.; float offset=0.;\nvec4 extcolor(vec2 z,float angleIter,int iter) //algorithm for continuous escape plus smooth external ray\n{\n  realthick=thickness*log(dot(z,z))/log(1e3)/float(2); density=4.; offset=5.;\n  index=float(iter)+(log(log(1e3))-log(log(dot(z,z))/2.))/log(2.);\n  if(angleIter>=pi-realthick){                                             //shade ray very close to +π\n    if(abs(arg(-z)+pi-angleIter)<=realthick){ return rainbow(index+offset,density); } }\n  else if(angleIter<=realthick-pi){                                        //shade ray very close to –π\n    if(abs(arg(-z)-pi-angleIter)<=realthick){ return rainbow(index+offset,density); } }\n  else{                                                                    //shade ray regular\n    if(abs(arg(z)-angleIter)<=realthick){ return rainbow(index+offset,density); } }\n  return rainbow(index,density);\n}\nvec2 c=vec2(0.,0.);\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    if((iMouse.x==0.)&&(iMouse.y==0.)){ c=vec2(-0.8394175,0.4); }           //along the seahorse (period 2)\n    else{ c=4.*vec2(iMouse.x-.5*iResolution.x,iMouse.y-.5*iResolution.y)/iResolution.x+vec2(-0.5,1.); }\n    vec2 c1=c; bool isOriginal=keypress(79);                                //Press key 'o' for original\n    vec4 color=vec4(0.,0.,0.,1.); vec2 z1=vec2(0.,0.);\n    vec2 z0=vec2(0.,0.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n    vec2 z=vec2(0.,0.); float ray=0.; float bailout=1e4; float bailray=1e3; //Bailout>bailray for best results.\n    for(int iter=1; iter<10; iter++){                      //Key: ray must go through the mouse pointer (at c)!\n        c1=sqr(c1)+c;\n        if(dot(c1,c1)>bailray){ ray=arg(c1)/pow(2.,float(iter)); break; } }\n    float angleIter=ray;\n    if(isOriginal){\n    for(int i=0; i<25; i++){ //Original\n        z=sqr(z0)+4.*pix+vec2(-0.5,1.);\n        if(dot(z,z)>bailout){ color=extcolor(z,angleIter,i); break; }\n        else{ z0=z; } angleIter=2.*(angleIter-pi*round(angleIter/pi)); } }\n    else{ //Julias\n    if(pix.x<=0.){ z1=4.*pix+vec2(1.,0.);\n    for(int i=0; i<25; i++){\n        z=sqr(z0)+sqr(z1)+c;\n        if(dot(z,z)>bailout){ color=extcolor(z,angleIter,i); break; }\n        else{ z0=z; } angleIter=2.*(angleIter-pi*round(angleIter/pi)); } }\n    else{ z0=4.*pix-vec2(1.,0.);\n    for(int i=0; i<25; i++){\n        z=sqr(z0)+c;\n        if(dot(z,z)>bailout){ color=extcolor(z,angleIter,i); break; }\n        else{ z0=z; } angleIter=2.*(angleIter-pi*round(angleIter/pi)); } } }\n    fragColor=color;\n}","name":"Image","description":"","type":"image"}]}