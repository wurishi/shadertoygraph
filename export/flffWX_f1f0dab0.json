{"ver":"0.1","info":{"id":"flffWX","date":"1651547491","viewed":123,"name":"Rainbeam","username":"Inityx","description":"Blinding beam of rainbow","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["screensaver"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float DITHER = 1.0 / 128.0;\nconst float B = 0.2;\n\nconst mat3 BLEED = mat3(\n    1.0, B, B,\n    B, 1.0, B,\n    B, B, 1.0\n);\n\n\nfloat saturate(float value) {\n    return (value <= 0.5)\n        ? value\n        : 1.5 - (1.0 / (value + 0.5));\n}\n\nvec3 grade(vec3 color) {\n    vec3 bled = color * BLEED;\n    return vec3(\n        saturate(bled.r),\n        saturate(bled.g),\n        saturate(bled.b)\n    );\n}\n\nvec3 dither(vec3 color, vec2 fragCoord) {\n    vec3 noise = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n    return color + (noise - 0.5) * DITHER;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 raw = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    vec3 graded = dither(grade(raw), fragCoord);\n    \n    fragColor = vec4(graded, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float FADE_RATE = 1.9;\nconst float ECCENTRICITY = 1.0/48.0;\nconst float BLOB_SIZE = 1.0/56.0;\nconst float PI = 3.14159265;\nconst float TAU = PI * 2.0;\nconst float PHI = 1.618033988;\nconst int BLOBS = 5;\nconst float ROTATION_SPEED = 1.0 / 16.0;\nconst float COLOR_SPEED = 1.0 / 50.0;\nconst float TURBULENCE_SPEED = 1.0 / 2048.0;\n\nvec2 zoom(vec2 uv, float amount) {\n    return ((uv - vec2(0.5)) / amount) + vec2(0.5);\n}\n\nvec3 color_spin(int i) {\n    float theta = (fract(iTime * COLOR_SPEED) + (float(i) / float(BLOBS))) * TAU;\n    vec3 rgb = vec3(\n        sin(theta),\n        sin(theta + 1.0 * TAU / 3.0),\n        sin(theta + 2.0 * TAU / 3.0)\n    );\n    return max(rgb, vec3(0.0));\n}\n    \nvec3 blobs(vec2 uv) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < BLOBS; i++) {\n        float theta = (fract(iTime * ROTATION_SPEED) + (float(i) / float(BLOBS))) * TAU;\n        \n        vec2 direction = vec2(sin(theta), cos(theta));\n        vec2 coordinate = pow(float(i + 1) / float(BLOBS), 0.75) * direction * ECCENTRICITY;\n            \n        if (distance(coordinate, uv) < BLOB_SIZE) {\n            color += color_spin(i);\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 raw_uv = fragCoord/iResolution.xy;\n    vec2 corrected_uv = (raw_uv - vec2(0.5)) / vec2(1.0, iResolution.x/iResolution.y);\n    vec3 blobs = blobs(corrected_uv);\n    \n    vec2 prev_uv =\n        zoom(raw_uv, 1.0 + iTimeDelta) +\n        (texture(iChannel1, corrected_uv - iTime * TURBULENCE_SPEED).rg - 0.5) / 2048.0;\n        \n    vec3 previous = texture(iChannel0, prev_uv).rgb;\n    \n    float factor = 1.0 - (iTimeDelta * FADE_RATE);\n    \n    fragColor = vec4(vec3(blobs + previous * factor), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}