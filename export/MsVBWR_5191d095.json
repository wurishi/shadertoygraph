{"ver":"0.1","info":{"id":"MsVBWR","date":"1528383817","viewed":564,"name":"Full spectral star diffraction","username":"MoltenQwartz","description":"Apperture diffraction is the Fourier Transform of the shape of the apperture.\nTurns out you can derive some close forms for simple apperture shapes.\nWith mathematica I got 3,4,6 bladed\nCircle apperture is deffined by Airy Diffraction.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["diffraction","fullspectral","starrendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Apperture diffraction is the Fourier Transform of the shape of the apperture.\n// Turns out you can derive some close forms for simple apperture shapes.\n// With mathematica I got 3,4,6 bladed (https://physics.stackexchange.com/questions/9899/how-does-fraunhofer-diffraction-depend-on-the-orientation-of-the-sides-of-a-lens)\n// Circle apperture is deffined by Airy Diffraction.\n// \n// Be sure to do the math in full spectral space and integrate down to RGB for better results\n\n// supported apperture blades 3-4-6-Circle\nconst int NumberOfAppertureBlades = 4;\n\n\n// Spectrum to xyz approx function from \"Simple Analytic Approximations to the CIE XYZ Color Matching Functions\"\n// http://jcgt.org/published/0002/02/01/paper.pdf\n//Inputs:  Wavelength in nanometers\nfloat xFit_1931(float wave)\n{\n    float t1 = (wave - 442.0f)*((wave < 442.0f) ? 0.0624f : 0.0374f);\n    float t2 = (wave - 599.8f)*((wave < 599.8f) ? 0.0264f : 0.0323f);\n    float t3 = (wave - 501.1f)*((wave < 501.1f) ? 0.0490f : 0.0382f);\n    return 0.362f*exp(-0.5f*t1*t1) + 1.056f*exp(-0.5f*t2*t2) - 0.065f*exp(-0.5f*t3*t3);\n}\nfloat yFit_1931(float wave)\n{\n    float t1 = (wave - 568.8f)*((wave < 568.8f) ? 0.0213f : 0.0247f);\n    float t2 = (wave - 530.9f)*((wave < 530.9f) ? 0.0613f : 0.0322f);\n    return 0.821f*exp(-0.5f*t1*t1) + 0.286f*exp(-0.5f*t2*t2);\n}\nfloat zFit_1931(float wave)\n{\n    float t1 = (wave - 437.0f)*((wave < 437.0f) ? 0.0845f : 0.0278f);\n    float t2 = (wave - 459.0f)*((wave < 459.0f) ? 0.0385f : 0.0725f);\n\n    return 1.217f*exp(-0.5f*t1*t1) + 0.681f*exp(-0.5f*t2*t2);\n}\n\n// RGB-XYZ Matrix Calculator\n// http://www.russellcottrell.com/photo/matrixCalculator.htm\n// Based on equations found here:\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// And Rec. 2020 values found here:\n// https://en.wikipedia.org/wiki/Rec._2020\n// https://en.wikipedia.org/wiki/Rec._709\n// https://en.wikipedia.org/wiki/SRGB\nvec3 XYZtosRGB(vec3 XYZ)\n{\n    vec3 rgb;\n    rgb.x = XYZ.x *  3.2409699f + XYZ.y * -1.5373832f + XYZ.z * -0.4986108f;\n    rgb.y = XYZ.x * -0.9692436f + XYZ.y *  1.8759675f + XYZ.z *  0.0415551f;\n    rgb.z = XYZ.x *  0.0556301f + XYZ.y * -0.2039770f + XYZ.z *  1.0569715f;\n    \n    return rgb;\n}\n\n// usefull functions\n#define M_2PI 6.28318530718\nfloat sinc(float v)\n{\n    float res = 1.0;\n    if (abs(v) > 0.0001)\n        res = sin(v) / v;\n\n    return res;\n}\n\n#define SPECTRAL_SAMPLES 32\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 dd = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n    float d = length(dd);\n\n    \n    // https://en.wikipedia.org/wiki/Airy_disk\n    // cone spacing in the human eye are around 2.5um, resulting of an apperture of 5.0um\n    const float Apperture = 2.0*2.5;\n    \n    float lamdaStart = 380.0f;\n    float lamdaEnd = 780.0f;\n\n    float dw = (lamdaEnd - lamdaStart) / float(SPECTRAL_SAMPLES);\n\n    // https://en.wikipedia.org/wiki/CIE_1931_color_space\n    // integrating Illuminant\n    vec3 XYZIrradiance = vec3(0.0);\n\n    for (int i = 0; i < SPECTRAL_SAMPLES; i++)\n    {\n        float w = lamdaStart + (float(i) + 0.5f)*dw;\n        \n        float k = M_2PI / w; // k = 2PI/lamda in nm-1\n        float x = d*k*Apperture*1000.0; // um * nm-1 = 10^3\n\n        float dx = dd.x*k*Apperture*1000.0;\n        float dy = dd.y*k*Apperture*1000.0;\n\n        float illuminant = 0.0;\n        \n        x *= 2.0;\n        dx *= 2.0;\n        dy *= 2.0;\nif (NumberOfAppertureBlades == 3)\n{\n    \t// 3 Apperture Blades\n        float u = dx;\n        float u2 = u*u;\n        float u4 = u2*u2;\n\n        float v = dy;\n        float v2 = v*v;\n        illuminant = (3.0*u2 +\n            3.0*v2 + (u2 - 3.0*v2)*cos(3.0*u) -\n            2.0*u*(u + sqrt(3.0)*v)*cos(3.0 / 2.0*(u - sqrt(3.0)*v)) -\n            2.0*u2*cos(3.0 / 2.0*(u + sqrt(3.0)*v)) +\n            2.0*sqrt(3.0)*u*v*cos(3.0 / 2.0*(u + sqrt(3.0)*v)));\n        illuminant *= 3.0 / (2.0*3.14*3.14*u2*(u2 - 3.0*v2)*(u2 - 3.0*v2));\n        if ((length(u - sqrt(3.0)*v) < 0.001) || (length(-u - sqrt(3.0)*v) < 0.001))\n        {\n\n            float s = sin(3.0*u / 2.0);\n            illuminant = 3.0*s*s*s*s / (4.0*3.14*3.14*u4);\n        }\n}\nelse if (NumberOfAppertureBlades == 4)\n{\n        // 4 Apperture Blades\n        illuminant = sinc(dx)*sinc(dx)*sinc(dy)*sinc(dy);\n}\nelse if(NumberOfAppertureBlades == 6)\n{\n        // 6 Apperture Blades\n\t\tilluminant = (2.0*sqrt(3.0)*dx*(cos(dx / 2.0)*cos(sqrt(3.0)*dy / 2.0) - cos(dx)) -\n                    6.0*dy*sin(dx / 2.0)*sin(sqrt(3.0)*dy / 2.0)) / (3.14*dx*(dx*dx - 3.0*dy*dy));\n        illuminant = illuminant*illuminant;\n}\nelse\n{        \n        // Circle apperture\n        // (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3\n        illuminant = cos(x-2.0*3.14/4.0)* cos(x-2.0*3.14/4.0)/(x*x*x);\n    \n        // [Muhammad Taher Abuelmaâ€™atti] Trigonometric Approximations for some Bessel Functions\n   //     illuminant = 1.0/6.0*sin(x/2.0) + 1.0/6.0*sin(x) + sqrt(3.0)/6.0*sin(sqrt(3.0)*x/2.0);\n   //     illuminant = (2.0*illuminant/x)*(2.0*illuminant/x);\n            \n}\n        XYZIrradiance.x += illuminant * xFit_1931(w) * dw;\n        XYZIrradiance.y += illuminant * yFit_1931(w) * dw;\n        XYZIrradiance.z += illuminant * zFit_1931(w) * dw;\n    }\n\n    \n    // XYZ to sRGB\n    vec3 RGBIrradiance = XYZtosRGB(XYZIrradiance);\n \t// sRGB\n    float a = 0.05;\n    RGBIrradiance.r = RGBIrradiance.r <= 0.0031308 ? 12.92*RGBIrradiance.r : (1.0+a)*pow(RGBIrradiance.r,1.0/2.4)-a;\n    RGBIrradiance.g = RGBIrradiance.g <= 0.0031308 ? 12.92*RGBIrradiance.g : (1.0+a)*pow(RGBIrradiance.g,1.0/2.4)-a;\n    RGBIrradiance.b = RGBIrradiance.b <= 0.0031308 ? 12.92*RGBIrradiance.b : (1.0+a)*pow(RGBIrradiance.b,1.0/2.4)-a;\n    \n    \n     fragColor = vec4(RGBIrradiance,1.0);\n\n}","name":"Image","description":"","type":"image"}]}