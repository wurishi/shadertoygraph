{"ver":"0.1","info":{"id":"3dsSR8","date":"1675206302","viewed":69,"name":"Simple Ray March Shader","username":"CaveDraft","description":"A simple implementation of the ray marching algorithm.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF 10.0\n#define EPSILON 0.0001\n\n// from https://inspirnathan.com/posts/54-shadertoy-tutorial-part-8///from \n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, 1, 0),\n        vec3(0, 0, 1)\n    );\n}\n// end from\n\nstruct de_info {\n    float d;\n    vec3 n;\n    vec3 color;\n};\n\n///// start primitives /////\n\nde_info de_sphere(vec3 p, vec3 color, vec3 center, float radius)\n{\n    float d = length(center - p) - radius;\n    vec3 n = normalize(center - p);\n    return de_info(d, n, color);\n}\n\nde_info de_cube(vec3 p, vec3 color, vec3 center, vec3 shape)\n{\n    vec3 d3 = abs(p - center) - shape;\n    vec3 s3 = -sign(p - center);\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    if (d3.x >= d3.y && d3.x >= d3.z)\n    {\n        n.x = s3.x;\n        d = d3.x;\n    }\n    if(d3.y >= d3.x && d3.y >= d3.z)\n    {\n        n.y = s3.y;\n        d = d3.y;\n    }\n    if(d3.z >= d3.x && d3.z >= d3.y)\n    {\n        n.z = s3.z;\n        d = d3.z;\n    }\n    return de_info(d, n, color);\n}\n\n///// end primitives /////\n\nde_info de_min(de_info dei1, de_info dei2) {\n    if (dei1.d <= dei2.d) return dei1; else return dei2;\n}\n\nde_info de_expand(de_info dei, float r) {\n    dei.d -= r;\n    return dei;\n}\n\nde_info de(vec3 p)\n{\n    vec3 blue = vec3(0.1, 0.4, 0.8);\n    vec3 red = vec3(0.8, 0.0, 0.2);\n    return de_min(\n        de_sphere(mod(p, 1.0), blue, vec3(0.5, 0.5, 0.5), .08),\n        de_min(\n            de_sphere(p, red, vec3(0.0, 0.0, 0.0), 0.3),\n            de_expand(\n                de_min(\n                    de_sphere(p, vec3(1.0), vec3(0.0, -0.3, -0.2), 0.24),\n                    de_sphere(p, vec3(1.0), vec3(0.0, +0.3, -0.2), 0.24)\n                ),\n                0.02\n            )\n        )\n    );\n}\n\nvoid update_dei(inout de_info old_dei, in de_info new_dei) {\n    new_dei = old_dei;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    vec3 sun_dir = vec3(0.8, 0.4, -1.0);\n    \n    vec3 background = vec3(0.05, 0.0, 0.07);\n    \n    vec3 o = rotateZ(.4*iTime) * vec3(0.0, -2.0, 0.0);\n    vec3 p = o;\n    float r = 0.0;\n    de_info dei = de_info(1000.0, vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0));\n    \n    vec3 dir = rotateZ(.4*iTime) * normalize(vec3(uv.x, 2.0, uv.y));\n    \n    //update_dei(dei, de(p));\n    dei = de(p);\n    do\n    {\n        p += dei.d * dir;\n        //update_dei(dei, de(p));\n        dei = de(p);\n        r = length(p - o);\n    }\n    while (r < INF && dei.d > EPSILON * r);\n    \n    if (r < INF)\n    {\n        fragColor.xyz = (r/INF) * background + (1.0 - r/INF) * max(0.3, 0.6 + 0.4*dot(sun_dir, dei.n)) * dei.color;\n    }\n    else\n    {\n        fragColor.xyz = background;\n    }\n}","name":"Image","description":"","type":"image"}]}