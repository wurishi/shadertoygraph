{"ver":"0.1","info":{"id":"3dsyDn","date":"1587050878","viewed":162,"name":"Raymarching Project v2","username":"MarvelousBilly","description":"Use the mouse + arrow keys to move the screen\nThis uses raymarching to generate scenes\n\n","likes":2,"published":1,"flags":49,"usePreview":0,"tags":["raymarching","mouse","keyboard","vr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define fov 400 //field of view \n\nvec3 cam = vec3(0.,3.,0.); //camera position \n\nbool outlineOnOff = true;\nfloat outlineSize = 0.1; //not a constant size, but the amount of units wide the outline is\n\n// hi :)\n// this is the most work I put into a shader so far and it has most\n// of the features I would like\n// kthxbye\n\nconst float RenderDistance = 400.; //how far out objects will render\nconst float MinDist = 0.0005; //how close a ray has to be to be considered colliding\nvec2 res;\n\nfloat sdfSphere(vec3 coord, vec3 center, float radius){ \n    return distance(coord,center) - radius; \n} //get the distance to a sphere\n\nvec3 sphereNormal(vec3 coord, vec3 center){\n\treturn normalize(coord-center);\n} //find the normal of a sphere at point p\n\nfloat sdfPlane(vec3 pos, vec3 p, vec4 n){\n  p = pos - p;\n  n = normalize(n);\n  return dot(p,n.xyz) + n.w;\n} //find the distance to a plane\n\nfloat sdBox(vec3 P, vec3 p, vec3 b, float r)\n{\n  p = P-p;\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nint findIndexShortestSphere(vec3 p){\n    float sphereDists = sdfSphere(p,spheres[0].position,spheres[0].radius);\n    int minS = 0;\n    spheres[0].dist = sphereDists;\n    for(int i = 1; i < spheres.length(); i++){\n        if(i == spheres.length()){\n        \tbreak;   \n        }\n        float iSphereSdf = sdfSphere(p,spheres[i].position,spheres[i].radius);\n        sphereDists = min(sphereDists,iSphereSdf);\n        spheres[i].dist = iSphereSdf;\n        if(sphereDists == iSphereSdf){\n            minS = i;\n        }\n    }\n    return minS;\n} //ignore\n\nint findIndexShortestPlane(vec3 p){\n    float planeDists = sdfPlane(p,planes[0].position,planes[0].normal);\n    int minP = 0;\n    planes[0].dist = planeDists;\n    for(int i = 1; i < planes.length(); i++){\n        if(i == planes.length()){\n        \tbreak;   \n        }\n        float iPlaneSdf = sdfPlane(p, planes[i].position, planes[i].normal);\n        planeDists = min(planeDists,iPlaneSdf);\n        planes[i].dist = iPlaneSdf;        \n        if(planeDists == iPlaneSdf){\n            minP = i;\n        }\n    }\n    return minP;\n} \n\nint findIndexShortestBox(vec3 p){\n    float boxDists = sdBox(p,boxes[0].position,boxes[0].size, boxes[0].roundness);\n    int minB = 0;\n    boxes[0].dist = boxDists;\n    for(int i = 1; i < boxes.length(); i++){\n        if(i == boxes.length()){\n        \tbreak;   \n        }\n        float iBoxSdf = sdBox(p, boxes[i].position, boxes[i].size, boxes[0].roundness);\n        boxDists = min(boxDists,iBoxSdf);\n        boxes[i].dist = iBoxSdf;        \n        if(boxDists == iBoxSdf){\n            minB = i;\n        }\n    }\n    return minB;\n}\n\nmapResult map(vec3 p){\n    mapResult m;\n    int minS = findIndexShortestSphere(p);\n    int minP = findIndexShortestPlane(p);\n    int minB = findIndexShortestBox(p);\n    m.Md = min(spheres[minS].dist,planes[minP].dist);\n    m.Md = min(m.Md, boxes[minB].dist);\n    m.minS = minS;\n    m.minP = minP;\n    m.minB = minB;\n    return m;\n} //finds all distances to all objects from point p and returns the smallest one\n\nvec3 estimateNormal(vec3 p) {\n    float EPSILON = 0.000001;\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)).Md - map(vec3(p.x - EPSILON, p.y, p.z)).Md,\n        map(vec3(p.x, p.y + EPSILON, p.z)).Md - map(vec3(p.x, p.y - EPSILON, p.z)).Md,\n        map(vec3(p.x, p.y, p.z + EPSILON)).Md - map(vec3(p.x, p.y, p.z - EPSILON)).Md\n    ));\n}\n\nraymarchResult raymarch(vec3 direction, vec3 camera, float maxD, float outline){ //ray from camera to direction (extended into infinity)\n    direction = normalize(direction);\n    \n    raymarchResult res;\n    res.type = 0.;\n    res.position = vec3(0.);\n    \n    float minH = 999.;\n    float setI = (outline == 2. ? outlineSize + 1. : 0.3);\n    \n    for(float i = setI; i < maxD;){ //i = length of ray\n        vec3 p = camera + i * direction;\n    \tmapResult hMap = map(p); //smallest distance from all objects to point\n        float h = hMap.Md;\n        if(h > minH && minH > MinDist && minH < MinDist + outlineSize && outline != 0.){ //if distance increases from smallest distance\n            res.position = p;\n            res.type = 2.;\n            return(res);\n        }\n        minH = h;\n        \n        \n    \tif(h < MinDist){\n            res.position = p;\n            res.type = 1.;\n\t\t\treturn(res); //successfully hit something at point \"point\"\n        }\n        i += h;\n    }\n\n    return(res);\n} //travel along a ray taking steps only as large as the map function above returns\n\nfloat shadow(vec3 lig, vec3 cam){ \n    float l = distance(cam,lig);\n    vec3 dir = normalize(lig-cam);\n    for(float i = 0.3; i < l;){ //i = length of ray\n        vec3 p = cam + i * dir;\n    \tfloat h = map(p).Md; //smallest distance from all objects to point\n    \tif(h < MinDist){\n\t\t\treturn(0.0); //successfully hit something at point \"point\", make dark\n        }\n        i += h;\n    }\n    return(1.0); //no collision, make light\n} //go from the point you collide with in the above function and go to each light. If there is a collision on the way, you know it is going to be in shadow\n\n\nvec3 objectMapNormals(vec3 pos){\n    const float grad_step = 0.02;\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tmap( pos + dx ).Md - map( pos - dx ).Md,\n\t\t\tmap( pos + dy ).Md - map( pos - dy ).Md,\n\t\t\tmap( pos + dz ).Md - map( pos - dz ).Md\t\t\t\n\t\t)\n\t);\n} //find the normal of the object at point p\n\nfloat objectMapReflectiveness(vec3 p){\n    mapResult M = map(p);\n    float m = M.Md;\n    return m > 50.0 ? 0.\n         : m == spheres[M.minS].dist ? spheres[M.minS].reflectiveness\n         : m == boxes[M.minB].dist ? boxes[M.minB].reflectiveness\n         : m == planes[M.minP].dist ? planes[M.minP].reflectiveness : 0.;\n} //find the reflectiveness value at point p\n\nvec3 objectMapMaterial(vec3 p, vec3 v){\n    float b = 0.;\n    for(int i = 0; i < lights.length(); i++){\n        b += shadow(lights[i].position, p);\n    }\n    b /= float(lights.length());\n\n    mapResult M = map(p);\n    float m = M.Md;\n    \n    vec3 t = texture(iChannel1,p.xz/20.).xyz;\n    float b2 = 0.;\n    for(int i = 0; i < lights.length(); i++){\n        b2 += distance(lights[i].position,p);\n    }\n    b2 /= float(lights.length());\n    b2 = 1.2 - smoothstep(100.,160.,b2); //spotlight effect -- fix this and make it better lol\n    //b*=b2;\n    vec3 n = objectMapNormals(p);\n    \n    vec3 refR = reflect(p-v, n);\n    \n    vec3 skyb = texture(iChannel0, refR).xyz;\n    if(objectMapReflectiveness(p)==0.){\n        skyb = vec3(1.);\n    }\n    return m > 50.0 ? vec3(0.)\n         : m == spheres[M.minS].dist ? spheres[M.minS].material*b*skyb\n         : m == boxes[M.minB].dist ? boxes[M.minB].material*b*skyb\n         : m == planes[M.minP].dist ? planes[M.minP].material*t*b*skyb : vec3(1.,0.,0.);\n} //find the material of the object at point p. This includes the skybox, any textures, and the color\n\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\nvoid setupObjects(){\n    res = (iResolution.xy / 3.) + vec2(3.,0.);\n    //to add more of any of these, copy/paste a group, change the number in brackets to be the next number, and go to the common tab, scroll down and change the line\n    //\"light lights[2];\" or \"sphere spheres[2];\" and add the amount of added objects to the respective number in brackets.\n    \n    //Ex. I add a light\n    //lights[2].position = vec3(x,y,z); (remember the numbers have to have a \".\" after them to work\n    //then i go to common\n    //\"light lights[3];\"\n    //then down at the bottom of the code box, click the arrow to compile and run with the new object\n    \n    lights[0].position = vec3(3.,15.,7.);\n    lights[1].position = vec3(-17.,19.,3.);\n\n    spheres[0].position = vec3(1.+sin(iTime)*10.,3.,10.);\n    spheres[0].radius = 2.; //sphere 1 radius\n    spheres[0].material = vec3(0.8,1.0,0.0);\n    spheres[0].reflectiveness = 1.0;\n    \n    spheres[1].position = vec3(10.,5.,2.);\n    spheres[1].radius = 2.; //sphere 1 radius\n    spheres[1].material = vec3(0.0,1.0,1.0);\n    spheres[1].reflectiveness = 0.0;\n\n    planes[0].position = vec3(0.,-5.,0.); //plane 1 position\n    planes[0].normal = vec4(0.,1.,0.,1.); //plane 1 normal\n    planes[0].material = vec3(1.0,1.0,1.0);\n    planes[0].reflectiveness = 0.0;\n    \n    boxes[0].position = vec3(3.,4.,28.);\n    boxes[0].size = vec3(3.8,5.,1.); //sphere 1 radius\n    boxes[0].material = vec3(0.8,1.0,1.0);\n    boxes[0].reflectiveness = 0.8;\n    boxes[0].roundness = 3.;\n} //place all objects at points defined and give them values\n\nvec3 reflectedVal(inout vec3 cam, inout vec3 p){\n    vec3 col;\n    float ref = objectMapReflectiveness(p);\n    float o = (outlineOnOff == true ? 2. : outlineOnOff == false ? 0. : 3.);\n\n\traymarchResult rmRes = raymarch(reflect(p-cam,objectMapNormals(p)), p, RenderDistance * ref, o); //reflected position, if any\n    vec3 refR = rmRes.position;\n    if(rmRes.type == 2.){\n        return vec3(0.); //reflection color of outline\n    }\n\tfloat b = 0.;\n\tfor(int i = 0; i < lights.length(); i++){ b += shadow(lights[i].position, p); }\n    if(b / float(lights.length()) == 0.){ return vec3(0.); }      \n    col += objectMapMaterial(refR, p); //add the material of the object you hit\n    cam = p;\n    p = refR;\n\treturn col;\n}\n\nvec3 render(vec3 cam, vec3 dir, vec2 fragCoord){\n    vec3 col;\n    vec2 uv = fragCoord-iResolution.xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n    \n    cam += vec3(texelFetch(iChannel2, ivec2(res), 0));\n    float o = (outlineOnOff == true ? 1. : outlineOnOff == false ? 0. : 3.);\n    raymarchResult rmRes = raymarch(dir, cam, RenderDistance, o); //p is where the ray from the camera to \"dir\" (extended) collides with anything\n    vec3 p = rmRes.position;\n    float type = rmRes.type;\n    if(type == 1.){ //collision!\n        //float dist = distance(p, cam); //dist is the distance to the collision point\n        col = objectMapMaterial(p, cam); //find material of the object the first time\n        col += reflectedVal(cam, p);\n\n        col /= 2.0; //take the average of the materials\n    }\n    else if(type == 0.){ //no collision!\n        col = texture(iChannel0, dir).xyz; //skybox\n        //col = vec3(1.);\n    }\n    else{\n        col = vec3(0.); //outline color\n    }\n    return col;\n\n}\n\n/*\nvec3 AntiAlias(float AA, vec3 ro, vec3 rd, vec2 fragCoord) {\n\tvec3 col;\n    vec2 pixSize = vec2(1.) / iResolution.xy;\n    float totalSteps = AA*AA;\n\tif (AA > 1.) {\n\t\tfor (float i = 0.; i < totalSteps; i++) {\n\t\t\tfloat gap = (2. / (AA - 1.)) - 1.; //distance between AA^2 evenly spaced steps from -1 to 1\n            float x = mod(i, AA);\n            float y = floor(i / AA);\n\t\t\tvec2 im = vec2(x, y) - gap;\n\t\t\tvec3 offset = vec3(im * pixSize, 0.); //the xy channels should be transformed to rotate with the camera...\n            vec3 pos = texelFetch(iChannel2, ivec2(res)+ivec2(2,0), 0).xyz;\n            offset *= pos;\n            vec3 renBuf = render(ro, rd + offset, fragCoord);\n            if(renBuf == texture(iChannel0, rd).xyz){\n                //return vec3(0.,1.,0.);\n            \treturn renBuf;   \n            }\n\t\t\tcol += renBuf;\n\t\t}\n\t\tcol /= totalSteps; //average col\n\t}\n\telse {\n\t\tcol = render(ro, rd, fragCoord);\n\t}\n\treturn col;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    setupObjects(); //calls setup object function\n    \n    vec2 uv = fragCoord-iResolution.xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv2 = fragCoord / iResolution.xy;\n    vec2 Mouse = texelFetch(iChannel2, ivec2(res)+ivec2(2,0), 0).xy; //get the mouse position in pixels to the normalized value from 0 to 1\n    \n    vec3 dir = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov) + cam; //rotate the direction you look\n    vec3 col;\n        \n\t/*\n\tfloat AA = 1.;\n\tfloat AAPos = iMouse.x / iResolution.x;\n    if(uv2.x > AAPos){\n    \tAA = 2.;\n    }\n    col = AntiAlias(AA, cam, dir, fragCoord);\n    if(distance(uv2, vec2(AAPos,uv2.y)) < 0.001){\n    \tcol = vec3(0.,1.,1.);   \n    }\n\t*/\n    col = render(cam, dir, fragCoord); //(r,g,b), what will be output to the pixel at position fragCoord\n    \n    \n    //col = texelFetch(iChannel2, ivec2(fragCoord), 0).xyz;\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    setupObjects();\n    vec3 col = render(fragRayOri, fragRayDir, fragCoord);\n    //col = texelFetch(iChannel2, ivec2(fragCoord), 0).xyz;\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//this is for defining objects\n\nstruct light {    \n    vec3 position;\n};\n\nstruct sphere {    \n    float radius;    \n    vec3 position;\n    vec3 material;\n    float reflectiveness;\n    float dist;\n};\n\nstruct plane {    \n    vec4 normal;    \n    vec3 position;\n    vec3 material;\n    float reflectiveness;\n    float dist;\n};\n    \nstruct box {    \n    vec3 size;    \n    vec3 position;\n    float roundness;\n    vec3 material;\n    float reflectiveness;\n    float dist;\n};    \n    \nstruct mapResult {\n\tfloat Md;\n    int minP;\n    int minS;\n    int minB;\n};\n\nstruct raymarchResult {    \n    vec3 position;\n    float type; //0 for no collision, 1 for collision, 2 for close miss\n};\n\n    \nlight lights[2]; //number is number of objects of that type\n\nsphere spheres[2]; //number is number of objects of that type\n\nplane planes[1]; //number is number of objects of that type\n\nbox boxes[1]; //number is number of objects of that type\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fov 400 //field of view \n#define key(ascii)   (texelFetch(iChannel1,ivec2(ascii,0),0).x > 0.)\nbool vr = false;\nvec3 vrDir;\nvec2 res;\n\nvoid prevMouse(out vec4 fragColor) {//mouse position\n    vec4 v = vec4(iMouse.xy/iChannelResolution[0].xy,1.,0.); \n    fragColor = v; //update value stored (mouse position normalized)\n}\n\nvoid initVal(out vec4 fragColor){\n    vec4 val = vec4(0.5,0.5,0.,0.);\n    fragColor = val;\n}\n\nvoid deltaMouse(out vec4 fragColor) {//color stored\n    vec4 val = texelFetch(iChannel0, ivec2(res)+ivec2(2,0), 0);\n    //grab current delta mouse position\n    vec4 oldMouse = texelFetch(iChannel0, ivec2(res)+ivec2(1,0), 0);\n    //grab previous mouse position (last frame)\n    if(iMouse.z > 0.5 && val.w >= 0.5){ //if mouse was not pressed on prev frame, do not update delta\n        //this means it only changes when the mouse is down and does not warp colors.\n        vec2 deltaM = (iMouse.xy/iChannelResolution[0].xy)-oldMouse.xy;\n        //set delta to be the change in mouse positions between frames\n    \tval.xy+=deltaM;\n        //add the delta to val\n    }\n    if(val.x >= 1.){\n    \tval.x = 0.;   \n    }\n    if(val.y >= 1.){\n    \tval.y = 0.;   \n    }\n    val.w = iMouse.z; //update click state\n    fragColor = val;\n}\n\nmat3 rotmat(vec3 axis, float angle){\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n} //rotate a matrix\n\nvoid position(out vec4 fragColor){\n    vec4 val = texelFetch(iChannel0, ivec2(res), 0);\n    vec2 mid = res;\n    vec3 dir;\n    vec3 dirL;\n    if(!vr){\n        vec2 Mouse = texelFetch(iChannel0, ivec2(res)+ivec2(2,0), 0).xy;\n        vec2 uv = iChannelResolution[0].xy/2.-iChannelResolution[0].xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n        dir = normalize(rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov));\n        //need to fix this because I don't quite understand why this works \\/\n        //its just taking the direction and rotating it 90 degrees\n        vec2 MouseL = vec2((Mouse.x + 0.25),0.5); // Normalized pixel coordinates (from 0 to 1)\n        dirL = normalize(rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (MouseL.x * 2.0 - 1.0)) * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (MouseL.y * 2.0 - 1.0)) * vec3(uv.x,uv.y,fov));\n    }\n    else{\n        //vec2 Mouse = texelFetch(iChannel0, ivec2(2,0), 0).xy;\n        //vec2 uv = iChannelResolution[0].xy/2.-iChannelResolution[0].xy/2.0; // Normalized pixel coordinates (from 0 to 1)\n        dir = vrDir;\n    \t//need to fix this because I don't quite understand why this works \\/\n        //its just taking the direction and rotating it 90 degrees\n        //vec2 MouseL = vec2((Mouse.x + 0.25),0.5); // Normalized pixel coordinates (from 0 to 1)\n        dirL = dir;\n  \n        \n    }\n    float speed = 0.5;\n    if(key(16)){\n    \tspeed++; \n    }\n    if(key(87)){\n    \tval.xyz+=dir*speed;\n    }\n    if(key(83)){\n    \tval.xyz-=dir*speed;   \n    }\n    if(key(68)){\n    \tval.xyz+=dirL*speed;   \n    }\n    if(key(65)){\n    \tval.xyz-=dirL*speed;   \n    }\n\n \tfragColor = val; \n}\n\nvoid buffer(out vec4 fragColor, in vec2 fragCoord){\n    res = (iResolution.xy / 3.) + vec2(3.,0.);\n\n    if(iFrame == 0){\n        if(ivec2(fragCoord.xy) == ivec2(res)+ivec2(2, 0)){\n    \t\tinitVal(fragColor);\n        }\n    }\n    else{\n        if (ivec2(fragCoord.xy) == ivec2(res)) {\n            position(fragColor);\n        }\n        if (ivec2(fragCoord.xy) == ivec2(res)+ivec2(1, 0)) {\n            //if pixel that is being checked is 0,0\n            //update the stored value\n            prevMouse(fragColor);\n        }\n        if (ivec2(fragCoord.xy) == ivec2(res)+ivec2(2, 0)) {\n            //if pixel that is being checked is 0,0\n            //update the stored value\n            deltaMouse(fragColor);\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    buffer(fragColor, fragCoord);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vrDir = fragRayDir;\n    buffer(fragColor, fragCoord);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}