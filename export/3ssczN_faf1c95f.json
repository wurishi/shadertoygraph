{"ver":"0.1","info":{"id":"3ssczN","date":"1584375172","viewed":58,"name":"Bela's Brand New Path Tracer","username":"bela333","description":"I tried to rework my previous Path Tracer from the ground up","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["tracer","path","bela"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BRIGHTNESS -0.5\n#define CONTRAST 1.0/5.0\n\n#define C(c) U.x+=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    color = pow(color, vec4(CONTRAST))+BRIGHTNESS;\n    fragColor = color;\n    \n    \n    float previous_frame = -texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    vec4 O = vec4(0.0);\n    vec2 U = ( uv - vec2(.985, 0.))*64.0/4.;\n    int f = abs(iFrame-int(previous_frame));\n    while(f > 0){\n        int v = f%10+48;\n    \tC(v);\n        f /= 10;\n    }\n    C(32);C(58);C(115);C(101);C(108);C(112);C(109);C(97);C(83);\n    fragColor -= O.xxxx;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define iAnimationTime iMouse.x/iResolution.x\n\n#define PI 3.14\n#define EPSILON 0.002\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (float st){\n\treturn random(vec2(st, st*1749.));\n}\n\nfloat random (vec4 st) {\n    float a = dot(st.xy, vec2(62.007, 95.311));\n    float b = dot(st.zw, vec2(13.611, 1.335));\n    return random(vec2(a, b));\n}\n\nvec3 pointOnSphere(vec4 seed){\n\tfloat u = random(seed) * 2. * PI;\n    float v = acos(2.*random(seed*2.) - 1.);\n    \n    return vec3(\n    \tcos(u)*sin(v),\n    \tsin(u)*sin(v),\n        cos(v)\n    );\n}\n\nvec3 pointOnHemisphere(vec4 seed, vec3 n){\n\tvec3 p = pointOnSphere(seed);\n    return dot(n, p) > 0. ? p : -p;\n}\n\nstruct MaterialInfo{\n    vec3 color;\n\tvec3 dir;\n    vec3 emit;  \n};\n    \nvoid unionSDF(float p, int tMat, inout float o, inout int mat){\n    if(p < o){\n    \tmat = tMat;\n    }\n\to = min(p, o);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEPS 96.\n#define MAX_DISTANCE 20.\n#define BOUNCES 4.\n\nfloat sphereSDF(vec3 p, vec3 center, float radius){\n\treturn length(p-center)-radius;\n}\n\nfloat planeSDF(vec3 p, float height){\n\treturn p.y-height;\n}\n\nfloat boxSDF( vec3 p, float b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//Modified version of iq's box SDF\nfloat backdropSDF( vec2 p, float b )\n{\n  return -(length(max(p,0.0)) + min(max(p.x,p.y),0.0));\n}\n\nfloat sceneSDF(vec3 p, out int material){\n    const float drop_radius = 0.5;\n    float backdrop = backdropSDF(-p.zy+vec2(-.5, drop_radius-.5), 1.0)+drop_radius;\n    float cube = boxSDF(p, 0.5);\n    float lamp = sphereSDF(p, vec3(1.0, 2., 1.), .5);\n    lamp = min(lamp, sphereSDF(p, vec3(-1.0, 2., 1.), .5));\n    float sphere = sphereSDF(p, vec3(0.0, 0.5, 0.0), .5);\n    \n    cube = mix(cube, sphere, iAnimationTime);\n    \n    float o = backdrop;\n    material = 2;\n    unionSDF(lamp, 1, o, material);\n    unionSDF(cube, 3, o, material);\n\treturn o;\n}\n\n//MaterialInfo: color, direction, emit\nMaterialInfo getMaterial(int material, vec3 p, vec3 dir, vec3 normal, vec4 seed){\n    switch(material){\n    \tcase 0:\n        \treturn MaterialInfo(vec3(0.0), vec3(0.0), vec3(0.0));\n        case 1:\n        \treturn MaterialInfo(vec3(0.), vec3(0.0), vec3(222./255., 249./255., 255./255.)*100.);\n        \t//return MaterialInfo(vec3(0.0), vec3(0.0), vec3(254./255., 255./255., 222./255.)*100.);\n        case 2:\n        \treturn MaterialInfo(vec3(1.0), pointOnHemisphere(seed, normal), vec3(0.0));\n        case 3:\n        \treturn MaterialInfo(vec3(232./255., 54./255., 30./255.), reflect(dir, normal), vec3(0.0));\n    }\n}\n\n\n\n\n\n\n\n\n\nvec3 march(vec3 from, vec3 dir, out int material){\n    float dist = 0.;\n    float step_dist = EPSILON*2.;\n    for(float i = 0.; i < MAX_STEPS && step_dist > EPSILON && dist < MAX_DISTANCE; i++){\n    \tstep_dist = sceneSDF(from + dir * dist, material);\n        dist += step_dist;\n    }\n    if(step_dist > EPSILON){material = 0;}\n    return from + dir * dist;\n}\n\nvec3 getNormal(vec3 p){\n\tvec2 s = vec2(EPSILON, 0.0);\n    int temp = -1;\n    return normalize(vec3(\n    \tsceneSDF(vec3(p+s.xyy), temp) - sceneSDF(vec3(p-s.xyy), temp),\n        sceneSDF(vec3(p+s.yxy), temp) - sceneSDF(vec3(p-s.yxy), temp),\n        sceneSDF(vec3(p+s.yyx), temp) - sceneSDF(vec3(p-s.yyx), temp)\n    ));\n}\n\nMaterialInfo trace(inout vec3 from, inout vec3 dir, vec4 seed, out vec3 normal){\n    int materialID = 0;\n\tfrom = march(from, dir, materialID);\n    normal = getNormal(from);\n    MaterialInfo material = getMaterial(materialID, from, dir, normal, seed);\n    dir = material.dir;\n    from += normal * EPSILON * 2.;\n    return material;\n}\n\nmat3 lookAtMatrix(vec3 p){\n    p = normalize(p);\n\tvec3 right = normalize(cross(p, vec3(0.0, 1.0, 0.0)));\n    vec3 up = cross(right, p);\n    return mat3(right, up, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //Create seed from time and UV\n    vec3 seed = vec3(uv, iTime);\n    \n        \n    //By exploiting the Monte Carlo averaging, it is trivial to add anti-aliasing\n    //Just simply move the UV around randomly, as long as the wiggle room is 1 px\n    vec2 aa = (fragCoord+vec2(\n        random(vec4(seed, 17.214))-.5, random(vec4(seed, 92.174))-.5\n\t))/iResolution.xy;\n    \n    vec2 centered = aa*2.-1.;\n\n    \n\t//Add aspect ratio correction\n    centered.x *= iResolution.x/iResolution.y;\n    \n    //Camera position\n    vec3 from = vec3(-2.0, 1.0, 1.0);\n    \n    //Direction\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    \n    //Point on projection plane\n    vec3 dir = normalize(vec3(centered, 1.0));\n    dir = lookAtMatrix(target-from) * dir;\n    \n    //The Rendering Equation can be separated into two parts: emission derived and radiation derived (tbh I came up with these names)\n\tvec3 emit = vec3(0.0);\n    vec3 rad = vec3(1.0);\n    \n    //It is advised to return a vec3(0.0) as direction for any material, that is not required to be traced further\n    //For example, the sky must be black no matter what\n    //And the lamp is way too bright\n    //So their dir is 0.0\n    for(float b = 0.0; b < BOUNCES && length(dir) != 0.0; b++){\n        vec3 wi = dir;\n        vec3 normal;\n    \tMaterialInfo material = trace(from, dir, vec4(seed, b), normal);\n        emit += material.emit * rad;\n        rad *= material.color * dot(dir, normal);\n    }\n    \n    //Average out frames\n    vec4 previous_frame = texture(iChannel0, uv);\n    \n    //Getting Start Frame number from previous frame\n    float start_frame = -texelFetch(iChannel0, ivec2(0), 0).x;\n    \n    if(iMouse.z > 0.5 || iFrame == 0){\n    \tstart_frame = float(iFrame);\n    }\n    \n    if(fragCoord.x < 1. && fragCoord.y < 1.){\n    \tfragColor = -vec4(start_frame);\n        return;\n    }\n    \n    emit = max(emit, 0.0);\n    fragColor = (previous_frame*(float(iFrame) - start_frame)+vec4(emit, 1.0))/(float(iFrame+1) - start_frame);\n    //fragColor = vec4(emit, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}