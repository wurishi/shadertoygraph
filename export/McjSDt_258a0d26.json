{"ver":"0.1","info":{"id":"McjSDt","date":"1707005152","viewed":144,"name":"Wiggly blob","username":"kaliuresis","description":"A raymarched wiggly blob using spherical harmonics. Some artifacts since it's using the radial distance and not the true sdf, but it mostly works.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["blob","sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI     3.14159265\n\nuint seed;\nuint randomui()\n{\n    seed = seed * 48271u % 0x7fffffffu;\n    return seed;\n}\n\nfloat random()\n{\n    return mod(0.00001f*float(randomui()), 1.0f);\n}\n\nfloat wiggle()\n{\n    return 0.6*(random()-0.5)*sin(10.0*random()*iTime);\n}\n\nfloat harmonic_series(vec3 r)\n{\n    // const float N_0 = 1.0/(sqrt(4*pi));\n    // const float N_1 = sqrt(3.0/(4.0*pi));\n    // const float N_2 = sqrt(15.0/(4.0*pi));\n    float x = r.x;\n    float y = r.y;\n    float z = r.z;\n    float xx = x*x;\n    float yy = y*y;\n    float zz = z*z;\n\n    return\n        +0.28209479177387814 * wiggle()\n\n        +0.4886025119029199 * wiggle() * y\n        +0.4886025119029199 * wiggle() * z\n        +0.4886025119029199 * wiggle() * x\n\n        +1.0925484305920792 * wiggle() * x*y\n        +1.0925484305920792 * wiggle() * y*z\n        +0.31539156525252005 * wiggle() * (-1.0 + 3.0*zz)\n        +1.0925484305920792 * wiggle() * x*z\n        +0.5462742152960396 * wiggle() * (xx - yy)\n\n        -0.5900435899266435 * wiggle() * y*(-3.0*xx + yy)\n        +2.890611442640554 * wiggle() * x*y*z\n        +0.4570457994644658 * wiggle() * y*(-1.0 + 5.0*zz)\n        +0.3731763325901154 * wiggle() * z*(-3.0 + 5.0*zz)\n        +0.4570457994644658 * wiggle() * x*(-1.0 + 5.0*zz)\n        +1.445305721320277 * wiggle() * (xx - yy)*z\n        +0.5900435899266435 * wiggle() * x*(xx - 3.0*yy)\n\n        +2.5033429417967046 * wiggle() * x*y*(xx - yy)\n        -1.7701307697799307 * wiggle() * y*(-3.0*xx + yy)*z\n        +0.9461746957575601 * wiggle() * x*y*(-1.0 + 7.0*zz)\n        +0.6690465435572892 * wiggle() * y*z*(-3.0 + 7.0*zz)\n        +0.10578554691520431 * wiggle() * (3.0 - 30.0*zz + 35.0*zz*zz)\n        +0.6690465435572892 * wiggle() * x*z*(-3.0 + 7.0*zz)\n        +0.47308734787878004 * wiggle() * (xx - yy)*(-1.0 + 7.0*zz)\n        +1.7701307697799307 * wiggle() * x*(xx - 3.0*yy)*z\n        +0.6258357354491761 * wiggle() * (xx*xx - 6.0*xx*yy + yy*yy)\n\n        +0.6563820568401701 * wiggle() * y*(5.0*xx*xx - 10.0*xx*yy + yy*yy)\n        +8.302649259524165 * wiggle() * x*y*(xx - yy)*z\n        -0.4892382994352504 * wiggle() * y*(-3.0*xx + yy)*(-1.0 + 9.0*zz)\n        +4.793536784973324 * wiggle() * x*y*z*(-1.0 + 3.0*zz)\n        +0.45294665119569694 * wiggle() * y*(1.0 - 14.0*zz + 21.0*zz*zz)\n        +0.1169503224534236 * wiggle() * z*(15.0 - 70.0*zz + 63.0*zz*zz)\n        +0.45294665119569694 * wiggle() * x*(1.0 - 14.0*zz + 21.0*zz*zz)\n        +2.396768392486662 * wiggle() * (xx - yy)*z*(-1.0 + 3.0*zz)\n        +0.4892382994352504 * wiggle() * x*(xx - 3.0*yy)*(-1.0 + 9.0*zz)\n        +2.075662314881041 * wiggle() * (xx*xx - 6.0*xx*yy + yy*yy)*z\n        +0.6563820568401701 * wiggle() * x*(xx*xx - 10.0*xx*yy + 5.0*yy*yy)\n        ;\n}\n\nfloat dist(vec3 p)\n{\n    seed = 128954u;\n    randomui();\n    randomui();\n    randomui();\n    return(length(p)-(1.0f+harmonic_series(normalize(p))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float fov = PI/4.0f;\n    float view_size = tan(fov/2.0f);\n    vec3 ray_dir = vec3(view_size*iResolution.x/iResolution.y*(2.0f*uv.x-1.0f), view_size*(2.0f*uv.y-1.0f), 1.0f);\n    ray_dir = normalize(ray_dir);\n    vec3 p = vec3(0,0,-5);\n\n    float last_dist = 1000.0f;\n    vec3 normal = vec3(0,0,0);\n    vec3 delta = vec3(0.0001, 0.0, 0.0);\n    for(int i = 0; i < 100; i++)\n    {\n        last_dist = dist(p);\n        if(last_dist <= 0.0)\n        {\n            normal = normalize(vec3(dist(p+delta.xzz)-dist(p-delta.xzz),\n                                    dist(p+delta.zxz)-dist(p-delta.zxz),\n                                    dist(p+delta.zzx)-dist(p-delta.zzx)));\n\n            break;\n        }\n        p += ray_dir*last_dist;\n    }\n\n    fragColor = vec4(0,0,0,1);\n    if(last_dist <= 0.0)\n    {\n        float r_dot = dot(normal, vec3(-1,0.5,-1));\n        float g_dot = dot(normal, vec3(+1,0.5,-1));\n        float b_dot = dot(normal, vec3(0.1,-0.5,-1));\n        fragColor.r = 0.2+0.2*r_dot+0.2*pow(r_dot,4.0);\n        fragColor.g = 0.2+0.2*g_dot+0.2*pow(g_dot,4.0);\n        fragColor.b = 0.2+0.2*b_dot+0.2*pow(b_dot,4.0);\n        //fragColor.rgb *= 0.5*texture(iChannel0, ray_dir-2.0*dot(normal,ray_dir)*normal).rgb;\n    }\n\n}\n","name":"Image","description":"","type":"image"}]}