{"ver":"0.1","info":{"id":"MtdXWl","date":"1482254368","viewed":1318,"name":"Simple CRT","username":"b005t3r","description":"A simple CRT shader.\n\nAdjust constants (especially \"scale\") for your liking. You can use the mouse to turn the effect off for part of the picture.\n\nThe main image is upscaled in Buf A and blurred in Buf B, them composed in the Image shader.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["crt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Add final postprocesses, like crt bend and crt mask.\n// \n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float maskStr\t\t\t= 0.0125;\t\t// 0.0 - 1.0\nconst float vignetteStr\t\t= 0.10;\t\t\t// 0.0 - 1.0\nconst float crtBend\t\t\t= 4.8;\nconst float crtOverscan\t\t= 0.1;\t\t\t// 0.0 - 1.0\t\t\t\n\nvec4 alphaBlend(vec4 top, vec4 bottom)\n{\n\tvec4 result;\n    result.a = top.a + bottom.a * (1.0 - top.a);\n    result.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n    \n    return result;\n}\n\nvec3 vignette(vec2 uv)\n{\n    float OuterVig = 1.0; // Position for the Outer vignette\n\tfloat InnerVig = 0.65; // Position for the inner Vignette Ring\n\t\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec2 center = vec2(0.5,0.5); // Center of Screen\n\t\n\tfloat dist  = distance(center,uv )*1.414213; // Distance  between center and the current Uv. Multiplyed by 1.414213 to fit in the range of 0.0 to 1.0 \t\n\tfloat vig = clamp((OuterVig-dist) / (OuterVig-InnerVig),0.0,1.0); // Generate the Vignette with Clamp which go from outer Viggnet ring to inner vignette ring with smooth steps\n    \n    return vec3(vig, vig, vig);\n}\n\nvec2 crt(vec2 coord, float bend)\n{\n\t// put in symmetrical coords\n\tcoord = (coord - 0.5) * 2.0 / (crtOverscan + 1.0);\n\n\tcoord *= 1.1;\t\n\n\t// deform coords\n\tcoord.x *= 1.0 + pow((abs(coord.y) / bend), 2.0);\n\tcoord.y *= 1.0 + pow((abs(coord.x) / bend), 2.0);\n\n\t// transform back to 0.0 - 1.0 space\n\tcoord  = (coord / 2.0) + 0.5;\n\n\treturn coord;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 crtCoords = crt(uv, crtBend);\n\n    if(iMouse.x > fragCoord.x) {\n        fragColor = texture(iChannel1, uv);\n    }\n    else if(crtCoords.x < 0.0 || crtCoords.x > 1.0 || crtCoords.y < 0.0 || crtCoords.y > 1.0) {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else {\n        vec4 final = texture(iChannel0, crtCoords);\n\n        // 9. mix mask with final\n        float moduloX = floor(mod(fragCoord.x, 6.0));\n        float moduloY = floor(mod(fragCoord.y, 6.0));\n\n        vec3 tmp;\n\n        if(moduloX < 3.0) {\n            if(moduloY == 0.0 || moduloY == 5.0)\n                tmp.rgb = vec3(0.0, 0.0, 0.0);\n            else\n                tmp.rgb = vec3(1.0, 1.0, 1.0);\n        }\n        else {\n            if(moduloY == 2.0 || moduloY == 3.0)\n                tmp.rgb = vec3(0.0, 0.0, 0.0);\n            else\n                tmp.rgb = vec3(1.0, 1.0, 1.0);\n        }\n\n        tmp = final.rgb * tmp;\n        final.rgb = alphaBlend(vec4(tmp, maskStr), final).rgb; \n\n        // 10. vignette\n        tmp = final.rgb * vignette(fragCoord.xy / iResolution.xy);\n        final.rgb = alphaBlend(vec4(tmp, vignetteStr), final).rgb;\n\n        fragColor = final;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//\n// Simply upscale the input image.\n//\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float scale \t\t= 13.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord.xy / iChannelResolution[0].xy / scale);\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//\n// Blur the input image and add chromatic aberration to the blurred output.\n//\n\nconst float blurSigma\t\t= 1.5; \t// in pixels\nconst int blurKerSize\t\t= 3;\t// has to be odd and greater than or equal to blurSigma\nconst float aberStr\t\t\t= 1.75;\t// in pixels\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvec4 blur(vec2 fragCoord, float sigma)\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\n    // mSize has to be an odd number greater than or equal to sigma\n    const int mSize = blurKerSize;\n    const int kSize = (mSize-1)/2;\n    float kernel[mSize];\n    vec3 final_colour = vec3(0.0);\n\n    //create the 1-D kernel\n    float Z = 0.0;\n    for (int j = 0; j <= kSize; ++j)\n        kernel[kSize + j] = kernel[kSize - j] = normpdf(float(j), sigma);\n\n    //get the normalization factor (as the gaussian has been clamped)\n    for (int j = 0; j < mSize; ++j)\n        Z += kernel[j];\n\n    //read out the texels\n    for (int i=-kSize; i <= kSize; ++i)\n    {\n        for (int j=-kSize; j <= kSize; ++j)\n        {\n            float kerVal = kernel[kSize + j] * kernel[kSize + i];\n            if(aberStr == 0.0) {\n                final_colour += kerVal * texture(iChannel0, (fragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).rgb;\n            }\n            else {\n                final_colour.r += kerVal * texture(iChannel0, (fragCoord.xy + vec2(float(i) - aberStr, float(j))) / iResolution.xy).r;\n                final_colour.g += kerVal * texture(iChannel0, (fragCoord.xy + vec2(float(i), float(j))) / iResolution.xy).g;\n                final_colour.b += kerVal * texture(iChannel0, (fragCoord.xy + vec2(float(i) + aberStr, float(j))) / iResolution.xy).b;\n            }\n        }\n    }\n\n\n    return vec4(final_colour/(Z*Z), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = blur(fragCoord, blurSigma);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//\n// Add various postprocesses and adjustments.\n//\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nconst float bleedDist\t\t= 1.5;\t\t\t// in pixels\nconst float bleedStr \t\t= 0.5;\t\t\t// 0.0 - 1.0\nconst float blurStr\t\t\t= 0.6;\t\t\t// 0.0 - 1.0\nconst float rgbMaskSub \t\t= 96.0 / 255.0;\nconst float rgbMaskSep\t\t= 1.8;\nconst float rgbMaskStr\t\t= 0.2;\t\t\t// 0.0 - 1.0\nconst float colorNoiseStr\t= 0.225;\t\t// 0.0 - 1.0\nconst float monoNoiseScale\t= 0.4;\t\t\t// 0.0 - 1.0 \nconst float monoNoiseStr\t= 0.15;\t\t\t// 0.0 - 1.0\nconst float vignetteStr\t\t= 0.1;\t\t\t// 0.0 - 1.0\n\nconst float brightness\t\t= 1.025;\nconst float contrast\t\t= 1.05;\nconst float saturation\t\t= 0.95;\n\nconst float minLevels\t\t= 0.0;\nconst float maxLevels\t\t= 235.0 / 255.0;\nconst float blackPoint\t\t= 40.0 / 255.0;\nconst float whitePoint\t\t= 1.0;\n\nconst float interWidth\t\t= 25.0;\t\t\t// in pixels\nconst float interSpeed\t\t= 3.0;\t\t\t// in px per second\nconst float interStr\t\t= 0.05;\t\t\t// 0.0 - 1.0\nconst float interSplit\t\t= 0.25;\n\nvec4 alphaBlend(vec4 top, vec4 bottom)\n{\n\tvec4 result;\n    result.a = top.a + bottom.a * (1.0 - top.a);\n    result.rgb = (top.rgb * top.aaa + bottom.rgb * bottom.aaa * (vec3(1.0, 1.0, 1.0) - top.aaa)) / result.aaa;\n    \n    return result;\n}\n\nvec4 bleed(vec2 fragCoord)\n{\n\tvec2 uvA = (fragCoord.xy + vec2(bleedDist, bleedDist)) / iResolution.xy;\n\tvec2 uvB = (fragCoord.xy + vec2(bleedDist, -bleedDist)) / iResolution.xy;\n\tvec2 uvC = (fragCoord.xy + vec2(-bleedDist, bleedDist)) / iResolution.xy;\n\tvec2 uvD = (fragCoord.xy + vec2(-bleedDist, -bleedDist)) / iResolution.xy;\n\n    vec4 a = texture(iChannel1, uvA);\n    vec4 b = texture(iChannel1, uvB);\n    vec4 c = texture(iChannel1, uvC);\n    vec4 d = texture(iChannel1, uvD);\n\n    return max(max(a, b), max(c, d));\n}\n\nfloat noise(float n)\n{\n    return fract(cos(n * 89.42) * 343.42);\n}\n\nmat4 brightnessMatrix( float brightness )\n{\n    return mat4( 1, 0, 0, 0,\n                 0, 1, 0, 0,\n                 0, 0, 1, 0,\n                 brightness, brightness, brightness, 1 );\n}\n\nmat4 contrastMatrix( float contrast )\n{\n\tfloat t = ( 1.0 - contrast ) / 2.0;\n    \n    return mat4( contrast, 0, 0, 0,\n                 0, contrast, 0, 0,\n                 0, 0, contrast, 0,\n                 t, t, t, 1 );\n\n}\n\nmat4 saturationMatrix( float saturation )\n{\n    vec3 luminance = vec3( 0.3086, 0.6094, 0.0820 );\n    \n    float oneMinusSat = 1.0 - saturation;\n    \n    vec3 red = vec3( luminance.x * oneMinusSat );\n    red+= vec3( saturation, 0, 0 );\n    \n    vec3 green = vec3( luminance.y * oneMinusSat );\n    green += vec3( 0, saturation, 0 );\n    \n    vec3 blue = vec3( luminance.z * oneMinusSat );\n    blue += vec3( 0, 0, saturation );\n    \n    return mat4( red,     0,\n                 green,   0,\n                 blue,    0,\n                 0, 0, 0, 1 );\n}\n\nvec3 interference(vec2 coord, vec3 screen)\n{\n\tscreen.r += sin((interSplit + coord.y / interWidth + (iTime * interSpeed))) * interStr;\n\tscreen.g += sin((coord.y / interWidth + (iTime * interSpeed))) * interStr;\n\tscreen.b += sin((-interSplit + coord.y / interWidth + (iTime * interSpeed))) * interStr;\n\n    screen = clamp(screen, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    \n\treturn screen;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 base\t\t= texture(iChannel0, fragCoord.xy / iResolution.xy);\n    vec4 blured \t= texture(iChannel1, fragCoord.xy / iResolution.xy);\n    vec4 bleeded\t= bleed(fragCoord);\n    vec4 final;\n\n    final.a = 1.0;\n\n    // 1. mix bleeded with base in lighten mode\n    vec3 tmp = max(bleeded.rgb, base.rgb);\n    final.rgb = alphaBlend(vec4(tmp, bleedStr), base).rgb;\n\n    // 2. mix tmp with blured in lighten mode\n    final.rgb = max(tmp, blured.rgb);\n    final.rgb = alphaBlend(vec4(final.rgb, blurStr), blured).rgb;\n\n    float delta = mod(iTimeDelta, 60.0);\n    \n    // 3. add color noise\n    vec3 colorNoise = vec3(\n        noise(sin(fragCoord.x) * fragCoord.y + delta), \n        noise(sin(fragCoord.y) * fragCoord.x + delta),\n        noise(sin(fragCoord.x) * sin(fragCoord.y) + delta)\n    );\n\n    tmp = max(final.rgb, colorNoise); \n    //tmp = final.rgb * colorNoise;\n    final.rgb = alphaBlend(vec4(tmp, colorNoiseStr), final).rgb;\n\n    // 4. add monochromatic noise\n    vec3 monoNoise = vec3(\n        noise(sin(fragCoord.x) * fragCoord.y + delta),\n        noise(sin(fragCoord.x) * fragCoord.y + delta),\n        noise(sin(fragCoord.x) * fragCoord.y + delta)\n    );\n\n    monoNoise = mix(monoNoise, vec3(1.0, 1.0, 1.0), (1.0 - monoNoiseScale));\n\n    tmp = final.rgb * monoNoise;\n    final.rgb = alphaBlend(vec4(tmp, monoNoiseStr), final).rgb;\n\n    // 5. mix rgb mask with final\n    float modulo = floor(mod(fragCoord.x, 3.0));\n    tmp = final.rgb;\n\n    if(modulo == 0.0)\n        tmp -= vec3(0, rgbMaskSub * rgbMaskSep / 2.0, rgbMaskSub * rgbMaskSep);\n    else if(modulo == 1.0)\n        tmp -= vec3(rgbMaskSub * rgbMaskSep / 2.0, 0, rgbMaskSub * rgbMaskSep / 2.0);\n        else\n            tmp -= vec3(rgbMaskSub * rgbMaskSep, rgbMaskSub * rgbMaskSep / 2.0, 0);\n\n        final.rgb = alphaBlend(vec4(tmp, rgbMaskStr), final).rgb;\n\n    // 6. interference\n    final.rgb = interference(fragCoord, final.rgb);        \n\n\n    // 7. contrast adjustment\n    final = brightnessMatrix(brightness - 1.0) *\n        contrastMatrix(contrast) * \n        saturationMatrix(saturation) *\n        final;\n\n    // 8. levels adjustment\n    vec3 minL = vec3(minLevels, minLevels, minLevels);\n    vec3 maxL = vec3(maxLevels, maxLevels, maxLevels);\n\n    final.rgb = mix(\n        vec3(0.0, 0.0, 0.0),\n        vec3(1.0, 1.0, 1.0),\n        final.rgb / (maxL - minL) + minL);\n\n    minL = vec3(blackPoint, blackPoint, blackPoint);\n    maxL = vec3(whitePoint, whitePoint, whitePoint);\n\n    final.rgb = clamp(final.rgb, minL, maxL);\n\n    fragColor = final;\n}","name":"Buf C","description":"","type":"buffer"}]}