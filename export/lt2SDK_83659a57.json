{"ver":"0.1","info":{"id":"lt2SDK","date":"1446747087","viewed":4127,"name":"vt220 at night","username":"sprash3","description":"A review of https://www.shadertoy.com/view/MljXDG but this time with lights off. At night bloom and reflection effects need to be taken care of. To increase quality, increase blur/bloom iterations. Uncomment MOUSE_MOVE to move terminal around.","likes":57,"published":1,"flags":0,"usePreview":0,"tags":["2d","retro","screen","crt","curve","terminal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define MOUSE_CURVE\n//#define MOUSE_MOVE\n\n#define MAIN_BLOOM_ITERATIONS 10\n#define MAIN_BLOOM_SIZE 0.01\n\n#define REFLECTION_BLUR_ITERATIONS 10\n#define REFLECTION_BLUR_SIZE 0.05\n\n#define WIDTH 0.48\n#define HEIGHT 0.3\n#define CURVE 3.0\n\n#define BEZEL_COL vec4(0.8, 0.8, 0.6, 0.0)\n#define PHOSPHOR_COL vec4(0.2, 1.0, 0.2, 0.0)\n#define AMBIENT 0.2\n\n#define NO_OF_LINES iResolution.y*HEIGHT\n#define SMOOTH 0.004\n\nprecision highp float;\n\n// using normal vectors of a sphere with radius r\nvec2 crtCurve(vec2 uv, float r) \n{\n        uv = (uv - 0.5) * 2.0;// uv is now -1 to 1\n    \tuv = r*uv/sqrt(r*r -dot(uv, uv));\n        uv = (uv / 2.0) + 0.5;// back to 0-1 coords\n        return uv;\n}\n\nfloat roundSquare(vec2 p, vec2 b, float r)\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n// Calculate normal to distance function and move along\n// normal with distance to get point of reflection\nvec2 borderReflect(vec2 p, float r)\n{\n    float eps = 0.0001;\n    vec2 epsx = vec2(eps,0.0);\n    vec2 epsy = vec2(0.0,eps);\n    vec2 b = (1.+vec2(r,r))* 0.5;\n    r /= 3.0;\n    \n    p -= 0.5;\n    vec2 normal = vec2(roundSquare(p-epsx,b,r)-roundSquare(p+epsx,b,r),\n                       roundSquare(p-epsy,b,r)-roundSquare(p+epsy,b,r))/eps;\n    float d = roundSquare(p, b, r);\n    p += 0.5;\n    return p + d*normal;\n}\n\n// Some Plasma stolen from dogeshibu for testing\nfloat somePlasma(vec2 uv)\n{\n    if(uv.x < 0.0 || uv.x > 1.0 ||  uv.y < 0.0 || uv.y > 1.0) return 0.0;\n    \n    float scln = 0.5 - 0.5*cos(uv.y*3.14*NO_OF_LINES); // scanlines\n    uv *= vec2(80, 24); // 80 by 24 characters\n    uv = ceil(uv);\n    uv /= vec2(80, 24);\n    \n    float color = 0.0;\n    color += 0.7*sin(0.5*uv.x + iTime/5.0);\n    color += 3.0*sin(1.6*uv.y + iTime/5.0);\n    color += 1.0*sin(10.0*(uv.y * sin(iTime/2.0) + uv.x * cos(iTime/5.0)) + iTime/2.0);\n    float cx = uv.x + 0.5*sin(iTime/2.0);\n    float cy = uv.y + 0.5*cos(iTime/4.0);\n    color += 0.4*sin(sqrt(100.0*cx*cx + 100.0*cy*cy + 1.0) + iTime);\n    color += 0.9*sin(sqrt(75.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += -1.4*sin(sqrt(256.0*cx*cx + 25.0*cy*cy + 1.0) + iTime);\n    color += 0.3 * sin(0.5*uv.y + uv.x + sin(iTime));\n    return scln*floor(3.0*(0.5+0.499*sin(color)))/3.0; // vt220 has 2 intensitiy levels\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 c = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\t// aspect-ratio correction\n\tvec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\tuv = 0.5 + (uv -0.5)/ aspect.yx;\n    \n#ifdef MOUSE_CURVE\n    float r = 1.5*exp(1.0-iMouse.y/iResolution.y);\n#else\n    float r = CURVE;\n#endif\n        \n    // Screen Layer\n    vec2 uvS = crtCurve(uv, r);\n#ifdef MOUSE_MOVE\n    uvS.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n\n    // Screen Content\n    vec2 uvC = (uvS - 0.5)* 2.0; // screen content coordinate system\n    uvC *= vec2(0.5/WIDTH, 0.5/HEIGHT);\n    uvC = (uvC / 2.0) + 0.5;\n    \n    c += PHOSPHOR_COL * somePlasma(uvC);\n    \n    // Simple Bloom\n    float B = float(MAIN_BLOOM_ITERATIONS*MAIN_BLOOM_ITERATIONS);\n    for(int i=0; i<MAIN_BLOOM_ITERATIONS; i++)\n    {\n        float dx = float(i-MAIN_BLOOM_ITERATIONS/2)*MAIN_BLOOM_SIZE;\n        for(int j=0; j<MAIN_BLOOM_ITERATIONS; j++)\n        {\n            float dy = float(j-MAIN_BLOOM_ITERATIONS/2)*MAIN_BLOOM_SIZE;\n            c += PHOSPHOR_COL * somePlasma(uvC + vec2(dx, dy))/B;\n        }\n    }           \n    \n    // Ambient\n    c += max(0.0, AMBIENT - 0.3*distance(uvS, vec2(0.5,0.5))) *\n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvS-0.5, vec2(WIDTH, HEIGHT), 0.05));\n  \n\n    // Enclosure Layer\n    vec2 uvE = crtCurve(uv, r+0.25);\n#ifdef MOUSE_MOVE\n    uvE.x -= iMouse.x/iResolution.x - 0.5;\n#endif\n    \n    // Inner Border\n    for( int i=0; i<REFLECTION_BLUR_ITERATIONS; i++)\n    {\n    \tvec2 uvR = borderReflect(uvC + (vec2(rand(uvC+float(i)), rand(uvC+float(i)+0.1))-0.5)*REFLECTION_BLUR_SIZE, 0.05) ;\n    \tc += (PHOSPHOR_COL - BEZEL_COL*AMBIENT) * somePlasma(uvR) / float(REFLECTION_BLUR_ITERATIONS) * \n\t        smoothstep(-SMOOTH, SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05)) * \n\t\t\tsmoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n    }\n               \n  \tc += BEZEL_COL * AMBIENT * 0.7 *\n        smoothstep(-SMOOTH, SMOOTH, roundSquare(uvS-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT), 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n    \n    // Corner\n  \tc -= (BEZEL_COL )* \n        smoothstep(-SMOOTH*2.0, SMOOTH*10.0, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH*2.0, -SMOOTH*2.0, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05));\n\n    // Outer Border\n    c += BEZEL_COL * AMBIENT *\n       \tsmoothstep(-SMOOTH, SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.05, 0.05)) * \n        smoothstep(SMOOTH, -SMOOTH, roundSquare(uvE-vec2(0.5, 0.5), vec2(WIDTH, HEIGHT) + 0.15, 0.05)); \n\n\n    fragColor = c;\n}","name":"","description":"","type":"image"}]}