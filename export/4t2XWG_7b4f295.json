{"ver":"0.1","info":{"id":"4t2XWG","date":"1446166014","viewed":1191,"name":"Penrose/Robinson Revisited","username":"tomkh","description":"Penrose/Robinson tiling with distance function to edge, textured tiles and cleaned-up commented code :-)","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["tiling","penrose","aperiodic","robinson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Penrose/Robinson Tiling Revisited\n// (procedural texture and distance field)\n// 2015 (C) Tom\n\n// Original shader:\n//   http://polycu.be/edit/?h=mh4l7V\n//   http://webglplayground.net/?gallery=aperiodic-Penrose-Robinson-tilings\n\n// Subsitution rules:\n//   http://tilings.math.uni-bielefeld.de/substitution_rules/robinson_triangle\n\n#define PATTERN 0\n  // 0 = textured Penrose tiles\n  // 1 = colored Robinson tiles with wiggly pattern\n\nconst int base_levels = 9; // base substitution levels\n\n//----------------------------------------------------\n// getTile returns:\n//   * type = tile type, Robinson code 0..3\n//   * q = coordinate in local tile space\n//   * rotation matrix to local tile space\n//----------------------------------------------------\nmat2 getTile(out int type, inout vec2 q, int levels)\n{\n  const float sc = 1.6180339887498947; // = 2.0/(sqrt(5.0)-1.0) (inflation scale)\n  const float pi = 3.1415926535897931;\n   \n  // Transformations constants:\n  \n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  const float a1 = 0.61803398874989479; // = .5/cos(36*pi/180)\n  const float a2 = 0.80901699437494745; // = (1+a1)*.5\n  const float a3 = 0.5877852522924728; // = tan(36*pi/180)*a2\n  const float cos1 = -0.8090169943749475; // = cos(144*PI/180)*sc\n  const float sin1 = 0.5877852522924732; // = sin(144*PI/180)*sc\n  const float cos2 = -0.30901699437494734; // = cos(108*PI/180)*sc\n  const float sin2 = 0.9510565162951536; // = sin(108*PI/180)*sc\n\n  mat2 m, final_m = mat2(1);\n  \n  type = (q.y < 0.) ? 1 : 0; // starting prototile\n  if (q.y < 0.) {\n     // flip rotation matrix as well\n     final_m[0].y = -final_m[0].y;\n     final_m[1].y = -final_m[1].y;\n     q.y = -q.y;\n  }\n  \n  for (int k=0; k<base_levels; k++)  // iterate all subsitutions\n  {\n     if (k >= levels) break;\n     if (type < 2) \n     {\n        // We substitute triangle type 0/1\n        // with three triangles.\n        // We detect in which of those three\n        // our current q = (x,y) lies\n        // by checking line equations separating them:\n        \n        if (1.0 - d1*q.y - q.x > 0.0) // left triangle\n        {         \n           // translate:\n           q.x -= 1.;\n           \n           // mirror:\n           m = mat2(-1.,0.,0.,1.);\n            \n           type = 1 - type; // tile type changes here!\n        } \n        else if (1.0 - d2*q.y - q.x > 0.0) // middle triangle\n        {\n           // translate:\n           q -= vec2(a2,a3);\n           \n           // rotate:\n           m = mat2(cos1,sin1,-sin1,cos1);\n           \n           type = 3 - type; // tile type changes here!\n        } \n        else // right triangle\n        {      \n           // translate (x only):\n           q.x -= a1 + 1.;\n        \n           // rotate:\n           m = mat2(cos1,-sin1,sin1,cos1);\n        }      \n     } \n     else \n     {\n        // We substitute triangle type 2/3\n        // with two triangles (analogically).\n  \n        if (d1*q.y - q.x > 0.0) { // upper triangle\n        \n           // rotate only\n           m = mat2(-cos2,sin2,sin2,cos2);\n                    \n           type -= 2; // tile type changes here!\n           \n        } else { // lower triangle\n        \n           // translate (x only):\n           q.x -= a1;\n           \n           // rotate:\n           m = mat2(cos2,-sin2,sin2,cos2);\n        }\n     }  \n     \n     // final rotate:\n     q = m * q; \n     final_m = m * final_m;\n     \n     // inflaction scale:\n     q *= sc;\n  }\n  \n  // return final rotate (e.g. to rotate normal later):\n  return final_m;\n}\n\n//----------------------------------------------------\n// getEdgeDist returns:\n//   * distance to closest edge of Penrose tile\n//----------------------------------------------------\nfloat getEdgeDist(int type, vec2 q)\n{\n  const float inv_sc = 0.6180339887498949; // = (sqrt(5.0)-1.0)/2.0\n  const float d1 = 1.3763819204711734; // = tan(54*pi/180)\n  const float d2 = 0.32491969623290629; // = tan(18*pi/180)\n  float dist = 0.;\n  if (type < 2) {\n     dist = 1.-(d1*q.y+q.x)*inv_sc;\n     dist = min(dist, (-d1*q.y+q.x)*inv_sc);\n  } else {\n     dist = (-d2*q.y+q.x);\n     dist = min(dist, (inv_sc-d2*q.y-q.x));\n  }\n  return dist;\n}\n\n//------------------------------------------------------\n// getDist returns:\n//   * beveled distance to closest edge of Penrose tile\n//------------------------------------------------------\nfloat getDist(int type, vec2 q)\n{\n  float dist = getEdgeDist(type,q);\n  return min(dist,.05)*2.+min(dist,.15)*1.;\n}\n\n//----------------------------------------------------\n// getNorm returns:\n//   * beveled normal rotated by \"m\"\n//----------------------------------------------------\nvec3 getNorm(int type, vec2 q, mat2 m)\n{\n  const vec2 eps = vec2(.001,0.);\n  vec3 norm = vec3(\n     getDist(type,q+eps.xy) - getDist(type,q-eps.xy),\n     getDist(type,q+eps.yx) - getDist(type,q-eps.yx),\n     eps.x*2.\n   );\n  norm.xy *= m;\n  return normalize( norm );\n}\n\n//----------------------------------------------------\n// getColor returns:\n//   * color from Robinson codes\n//----------------------------------------------------\nvec3 getColor(int type, vec2 q)\n{\n  const float r = .05;\n  vec3 base;\n  if (type >= 2) {\n     float f = (type == 2) ? q.y : -q.y;\n     f = smoothstep(-r,r,f);\n     base = mix(\n        vec3(40./255.,80./255.,166./255.),\n        vec3(86./255.,110./255.,167./255.),f);\n  } else {\n     float f = (type == 0) ? q.y : -q.y;\n     f = smoothstep(-r,r,f);\n     base = mix(\n        vec3(255./255.,204./255.,92./255.),\n        vec3(255./255.,102./255.,0.),f);\n  }\n  return base-.1;\n}\n\n//----------------------------------------------------\n// getTexture returns:\n//   * textured tile color\n//----------------------------------------------------\nvec3 getTexture(int type, vec2 q)\n{\n  const float r = .05;\n  vec3 base;\n  if (type >= 2) {\n     if (type == 2) q.y = -q.y;\n     base = texture(iChannel1, q).xyz*vec3(.12,1.,.1) + vec3(.1);\n  } else {\n     if (type == 0) q.y = -q.y;\n     base = texture(iChannel0, q).xyz + vec3(.25);\n  }\n  return base;\n}\n\n//----------------------------------------------------\n// penrose returns:\n//   * color for penrose tile with shading\n//----------------------------------------------------\nvec3 penrose(mat2 rot, vec2 q0, float sample_size, int levels)\n{\n  int type;\n  vec2 q = q0;\n  \n  rot = getTile(type, q, levels) * rot;\n  \n  vec3 norm = getNorm(type, q, rot);\n  \n  float dist = getDist(type, q);\n  \n#if PATTERN == 1\n  vec3 base = getColor(type, q);\n    \n  // Fancy wiggly pattern:\n  float d;\n  if (type < 2) {\n     d = abs(sqrt(1.0 - dot(q,q))-.6);\n  } else {\n     q.x -= 0.61803398874989479;\n     d = abs(sqrt(dot(q,q))*1.3-.27);\n  }\n  float r = pow(2.,float(levels))*.1*sample_size; // sample size\n  if (d > 0.) {\n    d = (1. - smoothstep(.1-r,.1,d));\n    base = mix(base, vec3(1.), d*.5);\n  }\n    \n  float spec = .2;\n    \n#else\n    \n  vec3 base = getTexture(type, q);\n  float spec = .5;\n\n#endif\n \n  // Lighting:\n  vec3 light_dir = normalize(vec3(.2,-.6,.5));\n  base *= min(1.,dist*5.)*max(0.,dot(norm,light_dir)*.3+.7);\n  base += vec3(1)*pow(max(0.,dot(norm,light_dir)),4.)*spec;\n  \n  return base;\n}\n\n//----------------------------------------------------\n// Main shader code\n//----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = (iMouse.z > 0.) ? iMouse.x*.005 : iTime*.25;\n  time += 2.;\n\n  int type;\n  float co, si;\n  \n  vec2 q;\n  \n  type = 0;\n  \n  // simple roto-zooming:\n  co = cos(time*.6);\n  si = sin(time);\n  float scale = sqrt(co*co + si*si);\n  \n  vec2 p = (fragCoord.xy - iResolution.xy*.5)*.5/iResolution.y;\n  \n  mat2 rot = mat2(co,-si,si,co)*(1./scale);\n  q = rot * p * (.5*scale) + vec2(.8,0.);\n    \n  float sample_size = scale/iResolution.y;\n  \n  vec3 base, base1, base2;\n  float blend = (iMouse.z > 0.) ? smoothstep(-.2,.2,iMouse.y/iResolution.y-.5) : 0.;\n  base1 = (blend < 1.) ? penrose(rot, q, sample_size, base_levels) : vec3(0);\n  base2 = (blend > 0.) ? penrose(rot, q, sample_size, base_levels-1) : base1;\n  base = mix(base1, base2, blend);\n    \n  base = pow(base,vec3(.6));\n\n  fragColor = vec4(base, 1.0);\n}\n","name":"","description":"","type":"image"}]}