{"ver":"0.1","info":{"id":"ctsXD2","date":"1675375085","viewed":98,"name":"spinning circles","username":"stokastic","description":"spinning circles","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["spinningcircles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TWO_PI (PI * 2.0)\n\n#define SC(a) vec2(sin(a),cos(a))\n#define spectrum(x) (0.7 + 0.5 * cos(x - vec3(0.0, 1.0, 2.0) * TWO_PI / 3.0))\n\n//#define QUANTIZE\n#define QUANTIZATION_FACTOR 64.0\n\n// mean distance for circles from origin\nconst float orbit_radius = 0.8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates from 0 to 1\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // World space coordinates from -1 to 1 (x adjusted for aspect ratio)\n\tvec2 xy = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n#ifdef QUANTIZE\n    xy = floor(xy * QUANTIZATION_FACTOR) / QUANTIZATION_FACTOR;\n#endif\n\n    float t = iTime * 1.5;\n    \n    // domain warping: apply various rotations/scaling/translation\n    float rot = 1.0  + sin(t * 0.15);\n    vec2 sc = SC(rot);\n    xy *= mat2(sc.x, -sc.y, sc.y, sc.x);\n    xy += 2.0 * vec2(cos(t * 0.25), sin(t * 0.15));\n\n    float scale = 10.0 * sin(t * 0.25);\n    xy *= scale;\n    \n    xy = sin(xy);\n    \n    // world-space size of one pixel\n\tfloat dy = scale * 2.0 / iResolution.y;\n\t\n    // distance from origin of fragment\n\tfloat r = length(xy);\n    \n\t\n\tfloat num_circles = 16.0;\n    float radius = 0.1 + 0.05 * (1.0 + cos(t));\n    \n\tfloat phi = TWO_PI / num_circles;\n\n    // Without saving any state from frame to frame, we need to calculate the position of a circle\n    // given a profile of it's velocity. The angular velocity is a raised sinusoid (cos(t) + c), meaning\n    // we can integrate to get this position, which is sin(t) + Kt + C. K and C an be chosen freely to\n    // adjust the speed of the animation\n\tfloat theta = atan(xy.y, xy.x) - sin(t) - t * 1.1;\n\t\n\tfloat theta2 = mod(theta, phi);\n\tvec2 p = (orbit_radius + 0.25 * cos(t)) * SC(theta2);\n\t\n\tfloat d = length(p - r * SC(0.5 * phi));\n\t\n\tfloat mask = smoothstep(radius, radius - dy * 2.0, d);\n\t\n\tvec3 col = spectrum(floor(theta / phi) * phi);\n\n    fragColor = vec4(col * mask, 1.0);\n}","name":"Image","description":"","type":"image"}]}