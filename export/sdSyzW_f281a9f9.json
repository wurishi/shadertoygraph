{"ver":"0.1","info":{"id":"sdSyzW","date":"1643156199","viewed":105,"name":"RM Spiked Sphere Driving","username":"larserik","description":"Raymarched sphere with spike pattern driving into the distance.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sphere"],"hasliked":0,"parentid":"ssSyRW","parentname":"RM Sphere Spiked"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Made using https://www.shadertoy.com/view/WtGXDD by Martijn Steinrucken as a starting point\n\n#define MAX_STEPS 100\n#define MAX_DIST 30.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define PI 3.1415\n#define TAU 6.2831\n\n#define SEGMENTS 10.\n\nfloat powerStep(float a, float b, float x, float p) {\n    float k = max(0., min(1., (x-a)/(b-a)));\n    return pow(k, p);\n}\n\nfloat hash(float x) {\n    return fract(sin(x*234.54)*452.46);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdSphere(vec3 p, vec3 s, float r) {\n    vec3 delta = s-p;\n    vec3 nd = normalize(delta);\n    float nr = r;\n    \n    for(float i = 0.; i<39.; i++) {\n        float offs = i*534.23;\n        vec3 spike = normalize(vec3(cos(iTime + offs), sin(iTime + offs), sin((iTime + offs)*.5)));\n        float cp = dot(nd, spike);\n        float pscp = powerStep(.98, 1.0, cp, 3.)*length(spike)*(sin((iTime+offs)*2.)*.5+.5)*.5;\n        r = max(r, nr+pscp);\n    }\n\n    return length(delta)-r;\n}\n\nfloat sdFloor(vec3 p) {\n    return p.y;\n}\n\n\nfloat GetDist(vec3 p) {\n    //float d = sdBox(p, vec3(1));\n    float d = sdSphere(p, vec3(0., 1.15, 0.), 1.);\n    d = min(d, sdFloor(p));\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS*.6;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nfloat GetLight(vec3 lp, vec3 p, vec3 n) {\n    vec3 l = normalize(lp - p);\n    float dif = clamp(dot(n, l)*.4+.39, 0., 1.);\n    \n    p = p + n*SURF_DIST*400.;\n    p.y = max(0.1, p.y);\n    float d = RayMarch(p, l);\n    if (d < length(lp)) {\n        dif *= .2;\n    }\n    \n    return dif;\n    //return dot(n, normalize(vec3(1,2,4)))*.5+.5\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(2.4, 1.4, -1.4);\n    vec3 la = vec3(-1.5, 1., .5);\n    \n    if (iMouse.z > .99) {\n        ro.yz *= Rot(-m.y * 3.14+1.);\n        ro.xz *= Rot(-m.x * 6.2831);\n    }\n    ro.y = max(.01, ro.y);\n    \n    \n    vec3 rd = GetRayDir(uv, ro, la, 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd);\n\n    vec3 lp = vec3(1, 4, 4);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = GetLight(lp, p, n);\n        col = vec3(dif);\n        \n        // Lame reflection attempt. ðŸ‘¼\n        //d = RayMarch(p, r);\n        //if (d<MAX_DIST) {\n        //    col *= 1.5;\n        //}\n    }\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}