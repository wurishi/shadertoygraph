{"ver":"0.1","info":{"id":"NttGz4","date":"1635786881","viewed":98,"name":"2D SDF Slice","username":"lGuy","description":"Trippy looking shader in which we can only see a 2D slice of a 3D world in which there are SDF shapes.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 ortho( \n    float b, float t, float l, float r, \n    float n, float f){ \n    mat4 m = mat4(1.0);\n    \n    m[0][0] = 2.0 / (r - l); \n    m[0][1] = 0.0; \n    m[0][2] = 0.0; \n    m[0][3] = 0.0; \n \n    m[1][0] = 0.0; \n    m[1][1] = 2.0 / (t - b); \n    m[1][2] = 0.0; \n    m[1][3] = 0.0; \n \n    m[2][0] = 0.0; \n    m[2][1] = 0.0; \n    m[2][2] = -2.0 / (f - n); \n    m[2][3] = 0.0; \n \n    m[3][0] = -(r + l) / (r - l); \n    m[3][1] = -(t + b) / (t - b); \n    m[3][2] = -(f + n) / (f - n); \n    m[3][3] = 1.0;\n    \n    return m;\n} \n\nmat4 lookAt(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = vec3(normalize(center - eye));\n    vec3 s = vec3(normalize(cross(f, up)));\n    vec3 u = vec3(cross(s, f));\n\n    mat4 m = mat4(1.0);\n    m[0][0] = s.x;\n    m[1][0] = s.y;\n    m[2][0] = s.z;\n    m[0][1] = u.x;\n    m[1][1] = u.y;\n    m[2][1] = u.z;\n    m[0][2] =-f.x;\n    m[1][2] =-f.y;\n    m[2][2] =-f.z;\n    m[3][0] =-dot(s, eye);\n    m[3][1] =-dot(u, eye);\n    m[3][2] = dot(f, eye);\n    \n    return m;\n}\n\n\nfloat sphere( vec3 p, vec3 center, float rad ) {\n    return length(p - center) - rad;\n}\n\nfloat roundBox( vec3 p, vec3 b, float r ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat torus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat boxFrame( vec3 p, vec3 b, float e ) {\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat smoothUnion( float d1, float d2, float k ) {\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 eyePos = vec3(sin(iTime), cos(iTime), sin(iTime)) * 0.5;\n    vec3 viewDir = vec3(cos(iTime), 0.0, sin(iTime));\n    vec3 upVector = vec3(0.0, sin(iTime), cos(iTime));\n\n    mat4 view = lookAt(eyePos, eyePos + viewDir, upVector);\n    float dim = 1.0;\n    mat4 projection = ortho(-dim, dim, -dim, dim, -dim, dim);\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    vec4 world = projection * view * vec4(p, 0.0, 1.0);\n    \n    float d = 1.e10;\n    \n    float s1 = sphere(world.xyz, vec3(0.0), 0.1);\n    float s2 = sphere(world.xyz, vec3(0.0, 0.0, -0.5 + sin(iTime) * 0.3), 0.1);\n    float u = smoothUnion(s1, s2, 0.1);\n    d = min(u, d);\n    \n    float rb1 = roundBox(world.xyz - vec3(0.5), vec3(0.6, 0.2, 0.7), 0.1);\n    u = smoothUnion(rb1, d, 0.1);\n    d = min(u, d);\n    \n    float t1 = torus(world.xyz - vec3(0.0), vec2(0.1, 0.1));\n    u = smoothUnion(t1, d, 0.1);\n    d = min(u, d);\n    \n    if (d < 0.3) {\n        fragColor = vec4(d * (1.0 / 0.3));\n    }\n    else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}