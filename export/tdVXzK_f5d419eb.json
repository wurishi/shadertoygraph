{"ver":"0.1","info":{"id":"tdVXzK","date":"1574488347","viewed":66,"name":"Random Pipes","username":"kamyarinfinity","description":"A procedural pipe connection","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\n#define INF 1000000.\n\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec2 repeat(vec2 uv, vec2 tile, vec2 off) {\n    return fract(uv * tile-off);\n}\n\nfloat circle(vec2 uv, float radius) {\n \tfloat c = length(uv - 0.5);\n    return c - radius;\n}\nvec3 norm_circle(vec2 uv, float radius) {\n    vec2 n2d = (uv - 0.5);\n    return normalize(vec3(n2d, sqrt(radius*radius-dot(n2d,n2d))));\n}\n\nvec2 line(vec2 uv, vec2 xy, float thickness) {\n    return abs (uv - xy).yx - thickness;\n}\n\nvec4 norm_line(vec2 uv, vec2 xy, float thickness) {\n    vec2 dist = (uv - xy).yx;\n    vec2 up=sqrt(thickness*thickness-dist*dist);\n    return vec4(normalize(vec2(dist.x,up.x)),\n                normalize(vec2(dist.y,up.y)));\n}\n\nvec2 pipe_id(vec2 uv, vec2 tile, vec2 off) {\n\treturn floor(uv * tile + off);\n}\n\nfloat random_select(vec2 id) {\n\treturn INF*(1.-floor(rand(id)+0.5));\n}\n\nfloat mask(float d) {\n  vec2 R = iResolution.xy;\n  float mx = max(R.x, R.y);\n  return smoothstep(1.0,.0,(d+10./mx)*mx/20.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 R = iResolution.xy;\n  float mx = max(R.x, R.y);\n  vec2 center = R / 2.0;\n  vec2 uv_static = fragCoord.xy / mx;\n  vec2 uv_full = uv_static;\n\n  uv_full += iTime/10.0;\n    \n  const float tile_size = 10.0;\n  const float radius = 0.33;\n    \n  vec2 uv = repeat(uv_full, vec2(tile_size), vec2(0.0));\n    \n  float c = circle(uv, radius);\n  \n  vec2 l = line(uv,vec2(0.5), 0.15);\n  \n  vec2 id1 = pipe_id(uv_full, vec2(tile_size), vec2(0.5, 0.0));\n  vec2 id2 = pipe_id(uv_full, vec2(tile_size), vec2(0.0, 0.5));\n    \n  l.x += random_select(id1*1.1);\n  l.y += random_select(id2);\n\n  float col = c;\n  col = min(col, l.x);\n  col = min(col, l.y);\n  col = mask(col);\n    \n  float mask_c = mask(c);\n  float mask_l = col - mask_c;\n    \n  // lighting\n  vec3 pos = vec3(uv_static, max(-c,0.0));\n  vec3 light_pos = vec3(0.7,0.7,0.6);\n  light_pos.xy = vec2(cos(iTime)*cos(iTime/2.0),sin(iTime)*cos(iTime/2.0));\n  vec3 light_dir = light_pos - pos;\n  light_dir = normalize(light_dir);\n    \n  vec3 red = vec3(1,0,0);\n  vec3 yellow = vec3(1,1,0);\n  vec3 white = vec3(1.);\n  vec3 sky_blue = vec3(0.5,0.8,1.);\n\n  // background shading\n  float light_dist = clamp(1.-length(light_pos.xy-uv_static),0.0,1.0);\n  vec3 bg = white * light_dist + sky_blue * (1. - light_dist);\n  float bg_mask = 1. - mask_c - mask_l;\n  vec3 col_bg = bg * bg_mask;\n  \n  // sphere shading\n  vec3 col_c = mask_c * (red * dot(norm_circle(uv, radius), light_dir));\n  col_c = max(col_c,0.0);\n  col_c = mix(sky_blue*0.3,col_c, length(col_c));\n\n  // cylinder shading\n  vec4 nl = norm_line(uv,vec2(0.5), 0.15);\n  vec3 col_l = max(mask_l * (yellow * dot(vec3(0.0,nl.xy), light_dir)),0.0);\n  col_l += max(mask_l * (yellow * dot(vec3(nl.z,0.0,nl.w), light_dir)),0.0);\n\n  fragColor = vec4(col_c + col_l + col_bg, 1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"}]}