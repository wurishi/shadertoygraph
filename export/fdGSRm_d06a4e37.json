{"ver":"0.1","info":{"id":"fdGSRm","date":"1634383958","viewed":171,"name":"[phreax] radial noise gradient","username":"phreax","description":"Inspired by a stage visual mapping I once saw on a festival.\nUsing it as material for MadMapper.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","gradient","fade"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define SIN(x) (.5*sin(x)+.5)\n#define hue(v) (.6+.6*cos(2.*PI*v + vec3(0, -2.*PI/3., 2.*PI/3.)))\n\nfloat t;\n\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\n\n// noise function from https://www.shadertoy.com/view/MdyfWz\nfloat r(in vec2 p)\n{\n    return fract(cos(p.x*42.98 + p.y*43.23) * 1127.53);\n}\n\n// using noise functions from: https://www.shadertoy.com/view/XtXXD8\nfloat n(in vec2 p)\n{\n    vec2 fn = floor(p);\n    vec2 sn = smoothstep(vec2(0), vec2(1), fract(p));\n    \n    float h1 = mix(r(fn), r(fn + vec2(1,0)), sn.x);\n    float h2 = mix(r(fn + vec2(0,1)), r(fn + vec2(1)), sn.x);\n    return mix(h1 ,h2, sn.y);\n}\n\nfloat noise(in vec2 p)\n{\n    return n(p/32.) * 0.58 +\n           n(p/16.) * 0.2  +\n           n(p/8.)  * 0.1  +\n           n(p/4.)  * 0.05 +\n           n(p/2.)  * 0.02 +\n           n(p)     * 0.0125;\n}\n\nvec2 pixelate(vec2 uv, float gran) {\n    return vec2(gran*floor(uv/gran));\n}\n\n\nfloat radial(vec2 uv, float o) {\n    //return SIN(length(2.*uv)-t*2.);\n    \n    //return smoothstep(ts+.1, ts-.1, n);\n    float ts = SIN(length(.5*uv)-t*2.4+o);\n    float n = noise(uv*70.);\n    return smoothstep(ts+.5, ts-.5, n);\n}\n\nvec3 gradient1(vec2 uv) {\n\n    return hue(.4*iTime+2.*radial(uv, 0.3)) - mix(vec3(0.933,1.000,0.000), vec3(0.702,0.000,0.071), radial(uv*4., 0.));\n}\n\nvec3 gradient2(vec2 uv) {\n    return  hue(0.2*iTime+radial(uv, 0.9)) + mix(vec3(0.000,0.047,0.678), vec3(0.110,0.000,0.502), radial(uv*4., .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 uvo = uv;\n    uv = pixelate(uv, .008);\n\n    t= iTime;\n    vec3 col = vec3(0);\n    \n    \n    float r = 2.*length(uv*1.);\n    float n = noise(uv*rot(t*.1)*200.);\n    \n    float ts = SIN(4.5*length(uv)+t*4.);\n    \n    col = mix(gradient1(uvo), gradient2(uvo), smoothstep(ts+.2, ts-.2, n));\n   \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}