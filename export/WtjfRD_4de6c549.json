{"ver":"0.1","info":{"id":"WtjfRD","date":"1598440941","viewed":89,"name":"Fitting to integrated BRDF terms","username":"0x4015","description":"Fitting to integrated BRDF terms by polynomial equations.\nupper left : reference value                        upper right : fitting with cubic functions\nlower left :  fitting with quartic functions      lower right : fitting with quadratic functions","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["brdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\tFitting to integrated BRDF terms by polynomial equations.\n\n\tRendering result is as follows:\n\n\t\tupper left\n\t\t\treference value\n\n\t\tlower left\n\t\t\tfitting with quartic functions\n\n\t\tupper right\n\t\t\tfitting with cubic functions\n\n\t\tlower right\n\t\t\tfitting with quadratic functions\n\n\tThe RGBA componets are as follows:\n\n\t\tR channel\n\t\t\tIntegrated renormalized DisneyDiffuse from the Frostbite BRDF\n\n\t\tG channel\n\t\t\tEnergy compensation term\n\t\t\tFitting with polar coordinate.\n\n\t\tB channel\n\t\t\tDFG2 term from the google Filament\n\t\t\tFitting with polar coordinate.\n\n\t\tA channel\n\t\t\tDFG1 term from the google Filament\n\t\t\tFitting with polar coordinate.\n\n\tSee also:\n\n\t\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\thttps://google.github.io/filament/Filament.html\n\n\tTo display alpha channel set the DISPLAY_A_CHANNEL as 1.\n*/\n\n//-----------------------------------------------------------------------------\n\n#define DISPLAY_A_CHANNEL\t0\n\n#define EPS_AVOID_ZEDO_DIV\t0.000001\n\n#define PI\t\t\t\t\t3.14159265359\n#define GOLDEN_RATIO_PHI1\t1.61803398874989484820\n#define GOLDEN_RATIO_PHI2\t1.32471795724474602596\n#define GOLDEN_RATIO_PHI3\t1.22074408460575947536\n#define GOLDEN_RATIO_PHI4\t1.16730397826141862883\n\nvec2 g_uv;\t\t// update in mainImage().\nvec2 g_mouse;\t// update in mainImage().\n\n//-----------------------------------------------------------------------------\n// utilities\n\nfloat pow5(float x){ return x*x*x*x*x; }\n\n/*\n\tBased on branchlessONB\n\t\thttp://jcgt.org/published/0006/01/01/\n\tModified to right-handed coodinate.\n*/\nmat3 OrthoNormalBasis(vec3 axisZ) {\n\tfloat s = axisZ.z < 0.0 ? 1.0 : -1.0;\n\tfloat a = 1.0 / (axisZ.z - s);\n\tfloat b = axisZ.x * axisZ.y * a;\n\tvec3 axisY = vec3(1.0 + s * axisZ.x * axisZ.x * a, s * b, s * axisZ.x);\n\tvec3 axisX = vec3(b, s + axisZ.y * axisZ.y * a, axisZ.y);\n\treturn mat3(axisX, axisY, axisZ);\n}\n\nvec2 QuasiRandom(int i, int numSamples, vec2 jitter) {\n\treturn vec2(\n\t\t(float(i) + jitter.x) / float(numSamples),\n\t\tfract(GOLDEN_RATIO_PHI1 * float(i) + jitter.y)\n\t);\n}\n\n//-----------------------------------------------------------------------------\n// sampling\n\nfloat GGXAlphaFromPerceptualRoughness(float perceptualRoughness){\n\treturn perceptualRoughness * perceptualRoughness;\n}\n\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float alpha) {\n\tfloat a2 = alpha * alpha;\n\tfloat GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n\tfloat GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n\treturn 0.5 / max(EPS_AVOID_ZEDO_DIV, GGXV + GGXL);\n}\n\nvec3 ImportanceSampleLambert(vec2 u, vec3 N) {\n\tfloat phi = 2.0 * PI * u.x;\n\tfloat cosTheta = sqrt(max(0.0/* avoid NaN */, u.y));\n\tfloat sinTheta = sqrt(max(0.0/* avoid NaN */, 1.0 - cosTheta * cosTheta));\n\tvec3 L = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\treturn OrthoNormalBasis(N) * L;\n}\n\nvec3 ImportanceSampleGGX(vec2 u, float alpha, vec3 N)\n{\n\tfloat phi = 2.0 * PI * u.x;\n\tfloat cosTheta = sqrt(max(0.0/* avoid NaN */, (1.0 - u.y) / (1.0 + (alpha * alpha - 1.0) * u.y)));\n\tfloat sinTheta = sqrt(max(0.0/* avoid NaN */, 1.0 - cosTheta * cosTheta));\n\tvec3 H = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\treturn OrthoNormalBasis(N) * H;\n}\n\n//-----------------------------------------------------------------------------\n// BRDF\n\nvec3 F_SchlickVec3(vec3 f0, float f90, float u) {\n\treturn f0 + (f90 - f0) * pow5(max(0.0/* avoid NaN */, 1.0 - u));\n}\nfloat F_Schlick(float f0, float f90, float u) {\n\treturn f0 + (f90 - f0) * pow5(max(0.0/* avoid NaN */, 1.0 - u));\n}\n\n/*\n\tMoving Frostbite to Physically Based Rendering 3.0\tp.11\tListing 1:\n\t\thttps://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n*/\nfloat RenormalizedDisneyDiffuse(float NoV, float NoL, float LoH, float perceptualRoughness)\n{\n\tfloat energyBias = mix(0.0, 0.5, perceptualRoughness);\n\tfloat energyFactor = mix(1.0, 1.0 / 1.51, perceptualRoughness);\n\tfloat fd90 = energyBias + 2.0 * LoH * LoH * perceptualRoughness;\n\tfloat f0 = 1.0;\n\tfloat lightScatter = F_Schlick(f0, fd90, NoL);\n\tfloat viewScatter = F_Schlick(f0, fd90, NoV);\n\treturn lightScatter * viewScatter * energyFactor;\n}\n\n//-----------------------------------------------------------------------------\n\nfloat IntegrateRenormalizedDisneyDiffuse(float NoV, float perceptualRoughness) {\n\tvec3 N = vec3(0,0,1);\n\tvec3 V;\n\tV.x = sqrt(1.0 - NoV * NoV);\n\tV.y = 0.0;\n\tV.z = NoV;\n\n\tfloat sum = 0.0;\n\tconst int numSamples = 0x100;\n\tfor (int i = 0; i < numSamples; i++) {\n\t\tvec2 u = QuasiRandom(i, numSamples, vec2(0.5));\n\t\tvec3 L = ImportanceSampleLambert(u, N);\n\t\tvec3 H = normalize(L + V);\n\t\tfloat NoL = clamp(L.z, 0.0, 1.0);\n\t\tfloat NoH = clamp(H.z, 0.0, 1.0);\n\t\tfloat VoH = clamp(dot(V, H), 0.0, 1.0);\n\t\tfloat LoH = VoH;\n\n\t\tif (NoL > 0.0) {\n\t\t\tfloat frDiffuse = RenormalizedDisneyDiffuse(NoV, NoL, LoH, perceptualRoughness);\n\t\t\t/*\n\t\t\t\t\t    baseColor\n\t\t\t\tBRDF = ----------- * RenormalizedDisneyDiffuse\n\t\t\t\t\t\t   PI\n\n\t\t\t\tpdf = NoL / PI\n\n\t\t\t\tBRDF / pdf * NoL\n\n\t\t\t\t\t\t\t\t\t\t\t\t baseColor      PI\n\t\t\t\t=\tRenormalizedDisneyDiffuse * ------------ * ----- * NoL\n\t\t\t\t\t\t\t\t\t\t\t\t\tPI          NoL\n\n\t\t\t\t=\tRenormalizedDisneyDiffuse * baseColor\n\t\t\t*/\n\t\t\tfloat baseColor = 1.0;\n\t\t\tsum += frDiffuse * baseColor;\n\t\t}\n\t}\n\treturn sum / float(numSamples);\n}\n\nvec3 IntegrateForSpecular(float\tNoV, float alpha) {\n\tvec3 N = vec3(0,0,1);\n\tvec3 V;\n\tV.x = sqrt(1.0 - NoV * NoV);\n\tV.y = 0.0;\n\tV.z = NoV;\n\n\tvec3 sum = vec3(0);\n\tconst int numSamples = 0x100;\n\tfor (int i = 0; i < numSamples; i++) {\n\t\tvec2 u = QuasiRandom(i, numSamples, vec2(0.5));\n\t\tvec3 H = ImportanceSampleGGX(u, alpha, N);\n\t\tvec3 L = -reflect(V, H);\n\n\t\tfloat VoH = clamp(dot(V, H), 0.0, 1.0);\n\t\tfloat NoL = clamp(L.z, 0.0, 1.0);\n\t\tfloat NoH = clamp(H.z, 0.0, 1.0);\n\t\tif (NoL > 0.0) {\n\t\t\tfloat Vis = V_SmithGGXCorrelated(NoV, NoL, alpha);\n\n\t\t\t/*\n\t\t\t\tpdf = D * NoH / (4 * VoH)\n\n\t\t\t\t    D * G\n\t\t\t\t------------- / pdf * NoL\n\t\t\t\t4 * NoL * NoV\n\n\t\t\t\t=\tVis\t* 4 * VoH * NoL / NoH\n\t\t\t*/\n\t\t\tfloat Fc = pow(abs(1.0 - VoH), 5.0);\n\t\t\tfloat tmp = Vis * 4.0 * VoH * NoL / max(EPS_AVOID_ZEDO_DIV, NoH);\n\t\t\tsum.x += tmp;\n\t\t\tsum.y += Fc * tmp;\n\t\t\tsum.z += (1.0 - Fc) * tmp;\n\t\t}\n\t}\n\treturn sum / float(numSamples);\n}\n\nvec4 ReferenceValue(vec2 uv) {\n\tfloat NoV = uv.x;\n\tfloat perceptualRoughness = uv.y;\n\tfloat alpha = GGXAlphaFromPerceptualRoughness(perceptualRoughness);\n\tvec4 rgba = vec4(\n\t\tIntegrateRenormalizedDisneyDiffuse(NoV, perceptualRoughness),\n\t\tIntegrateForSpecular(NoV, alpha)\n\t);\n\treturn rgba;\n}\n\nvec4 FittingWithQuarticFunctions(vec2 uv) {\n\tvec4 rgba;\n\t{\n\t\tfloat u = uv.x;\n\t\tfloat v = uv.y;\n\t\tfloat uu = u*u;\n\t\tfloat uv = u*v;\n\t\tfloat vv = v*v;\n\t\tfloat uuu = uu*u;\n\t\tfloat uuv = uu*v;\n\t\tfloat uvv = uv*v;\n\t\tfloat vvv = vv*v;\n\t\tfloat uuuu = uuu*u;\n\t\tfloat uuuv = uuu*v;\n\t\tfloat uuvv = uuv*v;\n\t\tfloat uvvv = uvv*v;\n\t\tfloat vvvv = vvv*v;\n\n\t\trgba.r =\n\t\t\tuuuu * -0.995502\n\t\t+\tuuuv * -3.383624\n\t\t+\tuuvv * -0.711406\n\t\t+\tuvvv *  0.035313\n\t\t+\tvvvv * -0.003290\n\t\t+\tuuu  *  4.475896\n\t\t+\tuuv  *  8.125055\n\t\t+\tuvv  *  0.951913\n\t\t+\tvvv  * -0.019424\n\t\t+\tuu   * -6.712384\n\t\t+\tuv   * -6.311030\n\t\t+\tvv   * -0.327508\n\t\t+\tu    *  4.160570\n\t\t+\tv    *  1.344068\n\t\t+\t1.0  *  0.030819;\n\t}\n\t{\n\t\tvec2 uvRemapped = vec2(atan(uv.y, uv.x), length(uv));\n\t\tfloat u = uvRemapped.x;\n\t\tfloat v = uvRemapped.y;\n\t\tfloat uu = u*u;\n\t\tfloat uv = u*v;\n\t\tfloat vv = v*v;\n\t\tfloat uuu = uu*u;\n\t\tfloat uuv = uu*v;\n\t\tfloat uvv = uv*v;\n\t\tfloat vvv = vv*v;\n\t\tfloat uuuu = uuu*u;\n\t\tfloat uuuv = uuu*v;\n\t\tfloat uuvv = uuv*v;\n\t\tfloat uvvv = uvv*v;\n\t\tfloat vvvv = vvv*v;\n\n\t\trgba.g =\n\t\t\tuuuu *  0.198357\n\t\t+\tuuuv *  1.123138\n\t\t+\tuuvv *  0.305852\n\t\t+\tuvvv * -0.566701\n\t\t+\tvvvv *  0.065370\n\t\t+\tuuu  * -0.738891\n\t\t+\tuuv  * -2.459136\n\t\t+\tuvv  *  0.091272\n\t\t+\tvvv  *  0.010436\n\t\t+\tuu   *  0.825102\n\t\t+\tuv   *  1.095841\n\t\t+\tvv   *  0.004532\n\t\t+\tu    * -0.296191\n\t\t+\tv    * -0.101494\n\t\t+\t1.0  *  1.024151;\n\n\t\trgba.b =\n\t\t\tuuuu *  0.073012\n\t\t+\tuuuv *  0.253855\n\t\t+\tuuvv * -0.124140\n\t\t+\tuvvv *  1.196397\n\t\t+\tvvvv *  0.775484\n\t\t+\tuuu  * -0.374658\n\t\t+\tuuv  * -0.439400\n\t\t+\tuvv  * -1.852563\n\t\t+\tvvv  * -4.299512\n\t\t+\tuu   *  0.561013\n\t\t+\tuv   *  0.927519\n\t\t+\tvv   *  6.923373\n\t\t+\tu    * -0.198625\n\t\t+\tv    * -4.400641\n\t\t+\t1.0  *  0.981606;\n\n\t\trgba.a =\n\t\t\tuuuu *  0.125189\n\t\t+\tuuuv *  0.868366\n\t\t+\tuuvv *  0.435596\n\t\t+\tuvvv * -1.760967\n\t\t+\tvvvv * -0.711026\n\t\t+\tuuu  * -0.363909\n\t\t+\tuuv  * -2.023023\n\t\t+\tuvv  *  1.929684\n\t\t+\tvvv  *  4.313474\n\t\t+\tuu   *  0.265110\n\t\t+\tuv   *  0.178983\n\t\t+\tvv   * -6.920030\n\t\t+\tu    * -0.099802\n\t\t+\tv    *  4.298459\n\t\t+\t1.0  *  0.042457;\n\t}\n\treturn clamp(rgba, 0.0, 1.0);\n}\n\nvec4 FittingWithCubicFunctions(vec2 uv) {\n\tvec4 rgba;\n\t{\n\t\tfloat u = uv.x;\n\t\tfloat v = uv.y;\n\t\tfloat uu = u*u;\n\t\tfloat uv = u*v;\n\t\tfloat vv = v*v;\n\t\tfloat uuu = uu*u;\n\t\tfloat uuv = uu*v;\n\t\tfloat uvv = uv*v;\n\t\tfloat vvv = vv*v;\n\n\t\trgba.r =\n\t\t\tuuu *  0.793080\n\t\t+\tuuv *  2.338213\n\t\t+\tuvv *  0.293477\n\t\t+\tvvv * -0.008347\n\t\t+\tuu  * -2.776151\n\t\t+\tuv  * -3.590620\n\t\t+\tvv  * -0.231195\n\t\t+\tu   *  2.744228\n\t\t+\tv   *  1.065963\n\t\t+\t1.0 *  0.148564;\n\t}\n\t{\n\t\tvec2 uvRemapped = vec2(atan(uv.y, uv.x), length(uv));\n\t\tfloat u = uvRemapped.x;\n\t\tfloat v = uvRemapped.y;\n\t\tfloat uu = u*u;\n\t\tfloat uv = u*v;\n\t\tfloat vv = v*v;\n\t\tfloat uuu = uu*u;\n\t\tfloat uuv = uu*v;\n\t\tfloat uvv = uv*v;\n\t\tfloat vvv = vv*v;\n\n\t\trgba.g =\n\t\t\tuuu *  0.483861\n\t\t+\tuuv *  0.486986\n\t\t+\tuvv * -0.454588\n\t\t+\tvvv * -0.324362\n\t\t+\tuu  * -1.263563\n\t\t+\tuv  * -0.548620\n\t\t+\tvv  *  0.625638\n\t\t+\tu   *  0.836366\n\t\t+\tv   * -0.134443\n\t\t+\t1.0 *  0.909178;\n\n\t\trgba.b =\n\t\t\tuuu * -0.033728\n\t\t+\tuuv *  0.020386\n\t\t+\tuvv * -0.175705\n\t\t+\tvvv * -1.350741\n\t\t+\tuu  *  0.093932\n\t\t+\tuv  * -0.013074\n\t\t+\tvv  *  3.843545\n\t\t+\tu   *  0.071942\n\t\t+\tv   * -3.323127\n\t\t+\t1.0 *  0.882314;\n\n\t\trgba.a =\n\t\t\tuuu *  0.516905\n\t\t+\tuuv *  0.466959\n\t\t+\tuvv * -0.280776\n\t\t+\tvvv *  1.028003\n\t\t+\tuu  * -1.355762\n\t\t+\tuv  * -0.534137\n\t\t+\tvv  * -3.220473\n\t\t+\tu   *  0.762957\n\t\t+\tv   *  3.190211\n\t\t+\t1.0 *  0.026451;\n\t}\n\treturn clamp(rgba, 0.0, 1.0);\n}\n\nvec4 FittingWithQuadraticFunctions(vec2 uv) {\n\tvec4 rgba;\n\t{\n\t\tfloat u = uv.x;\n\t\tfloat v = uv.y;\n\t\tfloat uu = u*u;\n\t\tfloat uv = u*v;\n\t\tfloat vv = v*v;\n\n\t\trgba.r =\n\t\t\tuu  * -0.417425\n\t\t+\tuv  * -0.958929\n\t\t+\tvv  * -0.096977\n\t\t+\tu   *  1.050356\n\t\t+\tv   *  0.534528\n\t\t+\t1.0 *  0.407112;\n\t}\n\t{\n\t\tvec2 uvRemapped = vec2(atan(uv.y, uv.x), length(uv));\n\t\tfloat u = uvRemapped.x;\n\t\tfloat v = uvRemapped.y;\n\t\tfloat uu = u*u;\n\t\tfloat uv = u*v;\n\t\tfloat vv = v*v;\n\n\t\trgba.g =\n\t\t\tuu  *  0.133105\n\t\t+\tuv  * -0.278877\n\t\t+\tvv  * -0.417142\n\t\t+\tu   * -0.192809\n\t\t+\tv   *  0.426076\n\t\t+\t1.0 *  0.996565;\n\n\t\trgba.b =\n\t\t\tuu  *  0.055070\n\t\t+\tuv  * -0.163511\n\t\t+\tvv  *  1.211598\n\t\t+\tu   *  0.089837\n\t\t+\tv   * -1.956888\n\t\t+\t1.0 *  0.741397;\n\n\t\trgba.a =\n\t\t\tuu  *  0.078313\n\t\t+\tuv  * -0.115340\n\t\t+\tvv  * -1.629860\n\t\t+\tu   * -0.283015\n\t\t+\tv   *  2.384448\n\t\t+\t1.0 *  0.254571;\n\t}\n\treturn clamp(rgba, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tg_uv = fragCoord / vec2(iResolution);\n\tg_mouse = iMouse.xy / iResolution.xy;\n\tif (iMouse.zw == vec2(0)) g_mouse = vec2(0.5);\n\n\tvec4 rgba = vec4(0);\n\tif (g_uv.x < g_mouse.x) {\n\t\tif (g_uv.y > g_mouse.y) {\n\t\t\t// upper left\n\t\t\trgba = ReferenceValue(g_uv);\n\t\t} else {\n\t\t\t// lower left\n\t\t\trgba = FittingWithQuarticFunctions(g_uv);\n\t\t}\n\t} else {\n\t\tif (g_uv.y > g_mouse.y) {\n\t\t\t// upper right\n\t\t\trgba = FittingWithCubicFunctions(g_uv);\n\t\t} else {\n\t\t\t// lower right\n\t\t\trgba = FittingWithQuadraticFunctions(g_uv);\n\t\t}\n\t}\n\n\tif (DISPLAY_A_CHANNEL != 0) {\n\t\trgba = rgba.aaaa;\n\t}\n\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\tif (abs(g_uv.x - g_mouse.x) < 0.001) rgba *= 0.5;\n\tif (abs(g_uv.y - g_mouse.y) < 0.001 * aspectRatio) rgba *= 0.5;\n\n\tfragColor = rgba;\n}\n\n","name":"Image","description":"","type":"image"}]}