{"ver":"0.1","info":{"id":"wdfczB","date":"1585172846","viewed":146,"name":"Time machine window","username":"ilyaev","description":"Time lapse effect study","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["space","timelapse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define FAR_DISTANCE 4.\n#define MIN_DISTANCE 0.0001\n#define SPEED 1.2\n#define SHOW_FRAME false\n#define SHOW_FULL_PLANET false\n#define PLANET_LAND_COLOR vec3(0.3, .3, .1)\n#define PLANET_OCEAN_COLOR vec3(0., 0., .5)\n#define PLANET_SNOW_COLOR vec3(.8, .3, .1)\n#define PLANET_CLOUD_COLOR vec3(1., 1., 1.) * .6\n#define PLANET_GLOW_COLOR vec3(0., 1.3, 2.8)\n#define PLANET_DEEP_COLOR vec3(0., 0., 0.3)\n#define PI 3.14\n\n\nfloat n21(vec2 p) {\n    return fract(sin(p.x*223.32+p.y*iTime/1000.)*4332.23);\n}\n\nfloat rand(vec2 n) {\n\treturn fract(sin(dot(n, vec2(12.9898, iTime/1000000.))) * 43758.5453);\n}\n\nfloat smoothNoise(vec2 uv) {\n    vec2 lv = smoothstep(0., 1., fract(uv));\n    vec2 id = floor(uv);\n\n    float bl = n21(id);\n    float br = n21(id + vec2(1.,0.));\n    float b = mix(bl, br, lv.x);\n\n    float tl = n21(id + vec2(0.,1.));\n    float tr = n21(id + vec2(1.,1.));\n    float t = mix(tl, tr, lv.x);\n\n    float n = mix(b, t, lv.y);\n    return n;\n}\n\nfloat noise(vec2 uv, int level) {\n    float n = 0.;\n    float d = 1.;\n    if (level > 0) {\n\t    n += smoothNoise(uv * 4.);\n    }\n    if (level > 1) {\n\t    n += smoothNoise(uv * 8.) * .5;\n        d += .5;\n    }\n    if (level > 2) {\n    \tn += smoothNoise(uv * 16.) * .25;\n        d += .25;\n    }\n    if (level > 3) {\n\t    n += smoothNoise(uv * 32.) * .125;\n        d += .125;\n    }\n    if (level > 4) {\n\t    n += smoothNoise(uv * 64.) * .025;\n        d += .0625;\n    }\n    return n / d;\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm2( in vec2 p ){\n    float f = 0.0;\n    f += 0.5000*noise( p); p = m2*p*2.02;\n    f += 0.2500*noise( p); p = m2*p*2.03;\n    f += 0.1250*noise( p); p = m2*p*2.01;\n    f += 0.0625*noise( p);\n\n    return f/0.9375;\n}\n\n\n\nvec3 getPlanetTexture(vec2 uv) {\n    vec3 col = vec3(0.);\n    float size = 450.;\n\n    vec2 guv = uv;\n\n    uv *= size;\n\n    vec2 id = floor(uv);\n    uv = fract(uv);\n\n    // float n = noise(id/500. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED), 5) * .6;\n        float n = fbm2(id/150. + vec2(-iTime/8.*SPEED, iTime/4.*SPEED));//* clamp(sin(iTime) * .5 + .5, .7, 1.);\n    n *= 1.3;\n    // n = fract(n * 1.);\n    float deep = smoothstep(.12, .13, n*.8);\n    float snow = smoothstep(0.57, 0.58, n);\n    float ocean = clamp(n-.1, 0., 1.);\n\n    vec3 oceanTexture = PLANET_OCEAN_COLOR;\n\n    vec3 land = mix(oceanTexture, PLANET_LAND_COLOR, smoothstep(0.4, 0.41, n));\n\n    col += mix(\n        PLANET_SNOW_COLOR,\n        mix(land, land * 6., pow(abs(n - .35), .4))/2.5,\n        1. -snow\n    );\n\n    // col.g = 1. - col.g;\n\n    col = (1. - step(0.001, col)) * oceanTexture + col;\n\n    col = mix(PLANET_DEEP_COLOR, col, deep);\n\n    if (n < .4 && n > .12) {\n        col *= .6;\n    }\n\n    float cloudN = noise(id/450. + iTime/8. * SPEED,4);\n    col = mix(PLANET_CLOUD_COLOR, col, smoothstep(.2, .6, cloudN));\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoords) {\n    vec2 uv = fragCoords / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec2 guv = uv;\n\n\n\n    if (!SHOW_FULL_PLANET) {\n        uv.y += 1.3 + sin(iTime + cos(iTime/2.))*.0099;\n    }\n\n\n    vec3 col = vec3(0.0);\n\n    float a = 2.5;\n    vec3 ro = vec3(0. + sin(a), 0.+cos(a), -1);\n    vec3 lookat = vec3(0.0,.03, 0.);\n\n    float zoom = 22.;\n\n    if (SHOW_FULL_PLANET) {\n         zoom = 4.;\n         ro = vec3(0., 0., -1);\n         lookat = vec3(0.);\n    }\n\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0., 1., 0), f));\n    vec3 u = cross(f, r);\n    vec3 c = ro + f * zoom;\n\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = normalize(i - ro);\n\n    vec3 p = vec3(0., 0., 0.);\n\n    float d = length(cross(rd, p - ro))/length(rd);\n\n    float glowMask = 1. - mix(smoothstep(.2, .02, d*1.5), .0, step(d, .1));\n    glowMask -= (1. - smoothstep(.1, .11, d*1.05))*smoothstep(.1, .11, d*1.02);\n\n    vec3 ds, dt;\n    float sd;\n    int steps;\n\n    for(int i = 0 ; i < MAX_STEPS ; i++) {\n        p = ro + rd * ds;\n        steps += 1;\n\n        sd = length(p) - .0999;\n\n        ds += sd;\n\n        if (sd < MIN_DISTANCE || sd > FAR_DISTANCE) {\n            break;\n        }\n    }\n\n    vec3 globe = vec3(0.);\n\n    if (sd < MIN_DISTANCE) {\n        // p.x += iTime/20.;\n        float x = acos(p.y/length(p));\n        float y = atan(p.z, p.x);\n        vec2 uv = vec2(x, y);\n        globe += smoothstep(.0, 1., clamp(float(steps)/40., 0., 1.))* .5 * PLANET_GLOW_COLOR * .8;\n        globe += getPlanetTexture(uv);\n    }\n\n   // if (SHOW_FRAME) {\n        globe += (1. - glowMask) * PLANET_GLOW_COLOR;\n   // }\n\n    col += globe;\n\n\n    if (SHOW_FRAME) {\n        d = length(guv);\n        col *= step(d, .4);\n        vec3 frame = (step(d, .41) - step(d, .40)) * vec3(.8);\n\n        col += frame;\n    }\n\n\n    fragColor = vec4(col, 1.);\n\n}","name":"Image","description":"","type":"image"}]}