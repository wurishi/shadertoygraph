{"ver":"0.1","info":{"id":"mllSzN","date":"1674432261","viewed":77,"name":"Clouds and checker ground","username":"ianertson","description":"Clouds and checker ground","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["ray","clouds","checker","ground"],"hasliked":0,"parentid":"ctsXzN","parentname":"Ray-marcher template 01"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLUR_RADIUS 2.2\n\nvec3 blur0(sampler2D tex, vec2 uv, vec2 dir) {\n    vec2 texel = 1.0 / vec2(textureSize(tex, 0).xy);\n    float radius = BLUR_RADIUS;\n    vec2 grad = texel*dir*radius;\n    return textureGrad(tex, uv, grad, grad).rgb;\n}\n\nvec3 blur(sampler2D tex, vec2 uv) {\n    return mix(\n        blur0(tex, uv, vec2(1.0, 0.0)), \n        blur0(tex, uv, vec2(0.0, 1.0)),\n        0.5\n    ).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 blurred = blur(iChannel0, uv);\n    float e = extractEdge(iChannel0, uv);\n    col = mix(col, blurred, e);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.14159\n#define TAU (M_PI * 2.0)\n\nmat2 rot(float a) {\n    float s = sin(a); \n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 saturate(vec3 color, float amnt) {\n  float l = color.r * 0.2 + color.g * 0.7 + color.b * 0.1;\n  vec3 gray = vec3(l,l,l);\n  vec3 diff = color.rgb - gray.rgb;\n  diff *= (1.0 + amnt);\n  vec3 saturated = clamp(gray + diff,0.0,1.0);\n  return mix(color, saturated, clamp(amnt, 0.0, 1.0));\n}\n\nvec3 tonemap(vec3 col) {\n    vec3 x = col;\n    vec3 vio = vec3(0.607843, 0.149019, 0.713725);\n    float dotVio = clamp(dot(col, vio), 0.0, 1.0);\n    \n    x = clamp(\n        (x * (2.51 * x + 0.03)) /\n        (x * (2.23 * x + 1.0392) + 0.98),\n    0.0, 1.0);\n   \n    x = saturate(x, dotVio);\n    x = mix(x, pow(x, vec3(2.0)), 0.3491*pow(dotVio, 2.0));\n    x += luma(x)/6.28;\n    x = clamp(x+(x/6.28), 0.0, 1.0);\n    \n    return pow(x, vec3(0.5125));\n}\n\nvec3 extractBump(sampler2D tex, vec2 uv, vec3 worldNormal, float z, float mi) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0));\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 a = normalize(vec3(dy.r - dx.r, dx.g - dy.g, z));\n    vec2 aspect = 1.0 / vec2(textureSize(tex, 0));\n    vec3 px =  color;\n    vec2 value = vec2(0.0);\n    for (float i = 0.0; i < TAU; i += TAU / 16.0) {\n        vec2 dir = vec2(sin(i), cos(i));\n        vec3 next = texture(tex, uv + dir * aspect * 6.0).rgb;\n        value += dir * distance(px, next);\n    }\n    vec3 b = vec3(value, z);\n    vec3 n = normalize(mix(a, b, 0.5));\n    \n    return mix(worldNormal, n+worldNormal, mi);\n}\n\nfloat goldness(vec3 color) {\n    vec3 gold = vec3(1.0, 0.8, 0.4);\n    float distance = length(color - gold);\n    return 1.0 - distance;\n}\n\nfloat grayness(vec3 color) {\n  float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n  float gray = (luminance + color.r + color.g + color.b) / 3.0;\n  return abs(luminance - gray);\n}\n\nfloat copperness(vec3 color) {\n    vec3 copper = vec3(0.9, 0.6, 0.4);\n    float distance = length(color - copper);\n    return 1.0 - distance;\n}\n\nvec3 extractBump(sampler2D tex, vec2 uv, vec3 normal) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0)).xy;\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, 0.033*0.6));\n    return mix(normal, normalize(normal+n), 0.6);\n}\n\nfloat extractRough(vec3 color, vec2 uv, sampler2D tex) {\n    float avg = pow((color.r + color.g + color.b) / 3.0, 2.0);\n    float a = max(0.0001, 1.0 - avg);\n    vec2 tsize = vec2(textureSize(tex, 0).xy);\n    vec2 texel = 1.0 / tsize;\n    vec3 left = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 right = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 up = texture(tex, uv+(texel*vec2(0.0, 1.0))).rgb;\n    vec3 down = texture(tex, uv+(texel*vec2(0.0, -1.0))).rgb;\n    vec3 avgAround = (left+right+up+down) / 4.0;\n    float r = (a+(distance(color, avgAround)*3.0));\n    r *= max(0.001, 1.0 - pow(0.99*luma(color), 2.0));\n    return max(0.0004, smoothstep(0.0, 1.0, r));\n}\n\nfloat extractMetallic(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    return pow((gold + copper + gray) / 3.0, 2.0);\n}\nvec3 extractSpec(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    vec3 goldColor = vec3(1.0, 0.8, 0.4);\n    vec3 copperColor = vec3(0.9, 0.6, 0.4);\n    vec3 grayColor = vec3(0.2126, 0.7152, 0.0722);\n    vec3 spec = ((goldColor * gold) + (copperColor * copper) + (grayColor * gray)) / 3.0;\n    spec += (((vec3(1.0) - color) / M_PI) + luma(color)) / (M_PI*2.0);\n    return smoothstep(0.0, 1.0, pow(spec, vec3(2.1)));\n}\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float strength;\n};\n\nvec3 PBR(\n    vec3 ro,\n    vec3 diffuse,\n    vec3 spec,\n    vec3 env,\n    vec3 normal,\n    vec3 point,\n    float roughness,\n    float metallic,\n    Light light\n) {\n\n\n  \n  vec3 col = vec3(0.0);\n\n\n\n\n  vec3 f0 = mix(vec3(0.04), diffuse, smoothstep(0.0, 1.0, metallic*2.0));\n  vec3 viewdir = normalize(ro - point);\n  vec3 reflection_dir = normalize(reflect(viewdir, normal) * -1.);\n  //vec3 env = texture(envtex, reflection_dir).rgb;\n  float NdotV = abs(dot(normal, viewdir)) + 0.000001;\n  vec3 envBRDF = EnvBRDFApprox(((spec/M_PI) + (vec3(0.1) / M_PI)) + 0.01, pow(roughness, 2.0), NdotV);\n  vec3 F = fresnelSchlickRoughness(NdotV, f0, roughness);\n  vec3 indirectSpecular = env * (F * envBRDF.x + envBRDF.y);\n  col += indirectSpecular;\n  float glossy = max(0.0, 1.0 - (1.3*(roughness + metallic)));\n  \n  // light\n  vec3 L = normalize(point - light.pos);\n  vec3 H = normalize(L + viewdir);\n  float HdotV = clamp(dot(H, viewdir),0.000001, 1.0);\n  float NdotH = clamp(dot(normal, H), 0.000001, 1.0);\n  float NdotL = max(0.0, dot(normal, L));\n  float dist = abs(distance(point, light.pos));\n  float att = NdotL*max(0.000001, (pow(light.strength, 2.0) / max(0.0001, pow(dist, 2.0))));\n\n  vec3 light_reflect_dir = reflect(-L, normal);\n  float VdotR = max(dot(viewdir, light_reflect_dir), 0.0);\n  float specFres = (glossy * pow(VdotR, 64.0));\n  vec3 fresnel = fresnelSchlick(HdotV, f0);\n  float D = microfacetDistribution(roughness, NdotH);\n  float S = DistributionGGX(normal, H, roughness);\n  float G = GeometrySmith(normal, viewdir, L, roughness);\n  float Fsd = (4.0 * NdotV * NdotL);\n  vec3 specularity = (((fresnel * S * G * D) / notzero(Fsd)) / M_PI) * glossy;\n  vec3 kd = (vec3(1.0) - specularity) * (1.0 - metallic);\n  col += (kd * diffuse + specularity + specFres) * ((light.color * att));\n  return max(vec3(0.0), col);\n}\n\nfloat extractEdge(sampler2D tex, vec2 uv) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0));\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec2 a = normalize(vec2(dy.r - dx.r, dx.g - dy.g));\n    vec2 aspect = 1.0 / vec2(textureSize(tex, 0));\n    vec3 px =  color;\n    vec2 value = vec2(0.0);\n    for (float i = 0.0; i < TAU; i += TAU / 16.0) {\n        vec2 dir = vec2(sin(i), cos(i));\n        vec3 next = texture(tex, uv + dir * aspect * 6.0).rgb;\n        value += dir * distance(px, next);\n    }\n    float L = (length(value) + length(a)) / 2.0;\n    return clamp(((abs(a.x) + abs(value.x)) / 2.0) * L, 0.0, 1.0);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R iResolution.xy\n\n#define T (iTime)\n\n#define STEPS 100\n#define NEAR 0.03\n#define FAR 100.0\n\n\n#define ENTITY_NONE 0\n#define ENTITY_GROUND 2\n\n#define ONE(v) clamp(v, 0.0, 1.0)\n\n\nvec3 checker(vec2 uv, float tile) {\n    vec2 id = floor(uv*tile);\n    return mix(\n        vec3(223.0, 230.0, 233.0) / 255.0,\n        vec3(45.0, 52.0, 54.0) / 255.0,\n        float(mod(id.x-id.y, 2.0) > 0.0)\n    );\n}\n\n\nstruct Data {\n    vec3 point;\n    vec3 normal;\n    vec3 diffuse;\n    vec2 uv;\n    float dist;\n    int entity;\n    \n    float metallic;\n    float rough;\n    vec3 spec;\n};\n\n////////////////////// Distance functions\n\n\nfloat getDistPlane(inout Data data, vec3 p, vec3 normal, float height) {\n    return dot(p, normal)+height;\n}\n\nfloat getDist(inout Data data, vec3 p) {\n    float plane = getDistPlane(data, p, vec3(0.0, 1.0, 0.0), 1.5);\n    \n    data.entity = ENTITY_GROUND;\n\n    return plane;\n}\n\n////////////////////// Get data\n\nvec2 getUv(inout Data data) {\n    vec3 p = data.point;\n    vec3 uv = p / FAR;\n    return (uv.xz)*16.0;\n}\n\nvec3 getNormal(inout Data data, vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    \n    return normalize(data.dist - vec3(\n        getDist(data, p + e.xyy),\n        getDist(data, p + e.yxy),\n        getDist(data, p + e.yyx)\n    ));\n}\n\nvec3 getDiffuse(inout Data data) {\n\n    vec2 uv = data.uv;\n    vec3 albedo = checker(uv, 8.0);\n    vec3 diffuse = albedo / M_PI;\n    data.metallic = extractMetallic(albedo);\n    data.rough = 0.55;\n    data.spec = extractSpec(albedo);\n    return diffuse;\n;\n}\n\nvoid getData(inout Data data, vec3 p) {\n    data.dist = getDist(data, p);\n    data.normal = getNormal(data, p);\n    data.uv = getUv(data);\n    data.diffuse = getDiffuse(data);\n}\n\n////////////////////// March\n\nbool march(vec3 ro, vec3 rd, inout Data data) {\n    float dist = 0.0;\n    data.dist = FAR;\n    \n    for (int i = 0; i < STEPS; i++) {\n        vec3 p = ro+rd*dist;\n        float next = getDist(data, p);\n        dist += next;\n        if (dist >= FAR || next <= NEAR) break;\n    }\n    \n    \n    data.point = ro+rd*dist;\n    getData(data, data.point);\n    \n    return dist < FAR;\n}\n\n////////////////////// Render\n\nvec3 skyBox(vec3 ro, vec3 rd) {\n    vec3 blue = vec3(0.25, 0.6, 0.8);\n    vec3 white = vec3(1.0);\n    vec3 bg = texture(iChannel2, rd).rgb;\n    \n    vec3 col = mix(blue, white, 0.5);\n    \n    \n    \n    float dotup = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    \n    vec2 uv = rd.xz/notzero(rd.y);\n    \n    float cloud = 0.0;\n    \n    float freq = 0.25;\n    float scalar = 1.0;\n    \n    cloud += scalar * texture(iChannel3, uv * freq).r; freq *= 2.0; scalar /= 1.6;\n    cloud += scalar * texture(iChannel3, uv * freq).r; freq *= 2.0; scalar /= 1.6;\n    cloud += scalar * texture(iChannel3, uv * freq).r; freq *= 2.0; scalar /= 1.6;\n    \n    cloud += scalar * texture(iChannel3, uv * freq).r; freq *= 2.0; scalar /= 1.6;\n    cloud += scalar * texture(iChannel3, uv * freq).r; freq *= 2.0; scalar /= 1.6;\n    cloud += scalar * texture(iChannel3, uv * freq).r; freq *= 2.0; scalar /= 1.6;\n    \n    cloud /= M_PI;\n    \n    vec3 clouded = col+cloud;\n    \n    col = mix(col, clouded, cloud*dotup);\n    col = mix(col, bg, max(0.0, 0.6 - (cloud + (dotup))));\n    \n    return col;\n    \n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    Light light = Light(vec3(3.0, 5.0, -4.5), vec3(0.89, 0.67, 0.49), 16.0);\n\n    vec3 col = vec3(0.0);\n    Data data;\n    \n    vec3 sky = skyBox(ro, rd);//texture(iChannel2, rd).rgb;\n    \n    if (march(ro, rd, data)) {\n        vec3 diffuse = data.diffuse;\n        vec3 normal = data.normal;\n        vec3 point = data.point;\n        vec3 viewdir = normalize(ro - point);\n        vec3 reflection_dir = normalize(reflect(viewdir, normal) * -1.);\n        vec3 env = skyBox(ro, reflection_dir);//texture(iChannel2, reflection_dir).rgb;\n        \n        col += PBR(\n            ro,\n            diffuse,\n            data.spec,\n            env,\n            normal,\n            point,\n            data.rough,\n            data.metallic,\n            light\n        );\n    } else {\n        col += sky;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    \n    \n    vec2 m = iMouse.z > 0.01 ? iMouse.xy/R : vec2(T*0.1, 0.5*(0.5+(0.5*sin(T*0.5))));\n    float my = 1.0;//float(iMouse.z > 0.01);\n\n    \n    vec3 ro = vec3(0.0, 0.0, -6.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    \n\n    \n    \n    ro.yz *= rot(my*(m.y*M_PI-1.));\n    ro.xz *= rot(-m.x*TAU);\n    \n    rd.yz *= rot(my*(m.y*M_PI-1.));\n    rd.xz *= rot(-m.x*TAU);\n    \n    ro.y = max(0.0, ro.y);\n    \n    \n    rd = normalize(rd);\n    color += render(ro, rd);\n    \n    O = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}