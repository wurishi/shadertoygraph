{"ver":"0.1","info":{"id":"ll3BRj","date":"1540225326","viewed":103,"name":"Ahziel - Test polygon function","username":"Ahziel","description":"Journey through the \"Book of shader\" - Shape / Function\nI do shaders to learn and have fun. If you have any advice, don't hesitate to tell me ! ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["polygon","shape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n// See Book Of Shader : https://thebookofshaders.com/07/\nfloat regularPolygon(in vec2 pos, in vec2 uv, in int nbSides, in float size)\n{\n    float res = 0.0;\n    uv = uv - pos;\n    size = 1./size;\n    \n    // Angle and radius from the current pixel\n    float a = atan(uv.x,uv.y)+PI;\n    float r = TWO_PI/float(nbSides);\n\n    // Shaping function that modulate the distance\n    float d = cos(floor(.5+a/r)*r-a)*length(uv) * size;\n    res = 1.0 - smoothstep(.4,.41,d);\n    \n    return res;\n}\n\nfloat circle(in vec2 pos, in vec2 uv, in float radius)\n{\n    float dist = distance(pos,uv);\n    return 1.0 - smoothstep(radius - 0.01,radius, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 aspect = iResolution.xy / min(iResolution.x, iResolution.y);\n    uv *= aspect;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.5);\n    vec2 center = vec2(0.5) * aspect;\n    const float nbPoly = 30.;\n    \n    for(float i  = nbPoly; i >= 5.0; i--)\n    {\n        float ste = i/nbPoly;\n        col = mix(col, vec3(1.0 - ste),regularPolygon(center,uv,int(i),ste * 1.2));\n    }\n    \n    col = mix(col,vec3(1.0,0.1,0.05),circle(center,uv,0.13));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}