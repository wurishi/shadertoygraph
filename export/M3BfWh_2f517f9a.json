{"ver":"0.1","info":{"id":"M3BfWh","date":"1729563234","viewed":57,"name":"glow - ebajec","username":"ebajec","description":"glow","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["donut"],"hasliked":0,"parentid":"M32fR1","parentname":"ray marching - ebajec"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592654;\nconst float inf = 1e9;\nconst float epsilon = 0.0001;\n\nvec4 quat_mult(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y, \n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x, \n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w, \n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z  \n    );\n}\n\nvec3 rotate(vec3 v, vec3 axis, float angle)\n{\n    vec4 exp_q = vec4(cos(angle/2.0),sin(angle/2.0)*axis);\n    vec4 exp_q_conj = vec4(exp_q.x,-exp_q.yzw);\n    vec4 v_p = vec4(0.0,v);\n\n    vec4 result = quat_mult(quat_mult(exp_q,v_p),exp_q_conj);\n    \n    return result.yzw;\n}\n\nvec3 palette(float t) {\n    float b = 0.7*cos(2.0*PI*t);\n    return clamp(vec3(0.5 - b,0.8 - b,2.0 + b),0.0,1.0);\n}\n\nstruct Result\n{\n    float d; \n    vec3 c;\n};\n\n// Signed distance function for a torus\n// p: the position vector\n// t: vec2 where t.x is the major radius (outer radius), and t.y is the minor radius (tube radius)\nResult sdfTorus(vec3 p,vec3 c, vec2 t, int freq) \n{\n    p = rotate(p-c,vec3(1.0,0.0,0),PI/2.0);\n    \n    float r = length(p.xz) - t.x;\n    float theta = atan(p.z,p.x);\n    float phi = atan(p.y,r);\n        \n    float f = float(freq);// floor(20.0*sin(iTime/2.0));\n    \n    float h = 2.0 + 0.25*cos(f*theta)*1.0*sin(2.0*(phi - theta-2.0*iTime));\n    \n    vec2 q = vec2(r, p.y);  // Flatten to 2D on the xz-plane, then offset by major radius\n    \n    Result result;\n    result.d = length(q) - t.y*h; \n    \n    result.c = palette(phi/(2.0*PI));\n    return result;\n}\n\nResult sdfSphere(vec3 p, vec3 o , float r)\n{\n    vec3 d = p-o;\n    \n    float s_dist = sqrt(d.x*d.x + d.y*d.y + d.z*d.z);\n   \n    float value = s_dist-r;\n    \n  \n    Result result;\n    result.d = value;\n    result.c = vec3(1.0);\n    return result;\n}\n\nResult sdf(vec3 v)\n{   \n    Result result; \n    result.d = inf;\n    result.c = vec3(1.0);\n    \n    return sdfTorus(v,vec3(0,0,0),vec2(17,3),20);\n    const int count = 3;\n    \n    for (int i = 0; i < count; i++)\n    {\n        float u = float(i)/float(count);\n        float t = 2.0*PI*u;\n        float r = 15.0;\n        float h = 5.0;\n        float f = 3.0;\n        //vec3 c = vec3(r*cos(t),r*sin(t),h*sin(f*(t-iTime)));\n        \n        Result ri = sdfTorus(v,vec3(0,0,10.0*sin(float(i)-2.0*iTime)),vec2(10*i,i),1+5*i);\n        //Result ri = sdfSphere(v,c,0.5);\n        //ri.c = palette(u);\n        \n        if (ri.d < result.d) result = ri;\n    }\n    \n    return result;\n}\n\nstruct SurfacePoint\n{\n    vec3 p;\n    vec3 n;\n    vec3 c;\n    float ref;\n    float dif;\n};\n\nvec3 sdf_grad(vec3 p)\n{\n    const float h = 0.00001;\n    const float denom = 1.0/(2.0*h);\n    \n    float delx = denom*(sdf(p + vec3(h,0,0)).d - sdf(p - vec3(h,0,0)).d);\n    float dely = denom*(sdf(p + vec3(0,h,0)).d - sdf(p - vec3(0,h,0)).d);\n    float delz = denom*(sdf(p + vec3(0,0,h)).d - sdf(p - vec3(0,0,h)).d);\n    \n    vec3 grad = vec3(delx,dely,delz);\n    return grad;\n}\n\nSurfacePoint march_ray(vec3 o, vec3 ray, float max_dist)\n{\n    const int max_steps =100;\n    int steps = 0;\n\n    SurfacePoint S;\n    \n    S.p = o;\n    S.n = vec3(0.0);\n    S.c = vec3(0);\n    \n    Result rmin;\n    rmin.d = inf;\n    rmin.c = vec3(0);\n    \n    for (int i = 0 ; i < max_steps; i++)\n    {\n        Result r = sdf(S.p);\n        float dist = r.d;\n        \n        if (dist < rmin.d) rmin = r;\n        \n        if (dist <= epsilon) break;\n        \n        vec3 grad = sdf_grad(S.p);\n        \n        float val = dot(grad,ray);\n        float D = length(grad);\n        \n        if (val > -0.1) \n        {\n            S.p += dist*ray;\n        }\n        else \n        {\n            S.p += dist*ray*(-val/D);\n        }       \n \n        S.c = r.c; \n        \n        if (length(S.p-o) > max_dist) break;\n    }\n    \n    // Now we know that dist < epsilon and dist > 0\n    \n    if (rmin.d <= epsilon)\n    {\n        S.c = rmin.c;\n    }\n    else \n    {\n        S.c = vec3(rmin.c)/(1.0+0.2*rmin.d);\n    }\n       \n    S.n = normalize(sdf_grad(S.p));\n    S.p += epsilon*S.n;\n    \n    return S;\n}\n\nmat3 view(vec3 normal)\n{\n\tvec3 basis[3];\n\n\tnormal = normalize(normal);\n\tbasis[2] = normal;\n\tbasis[0] = cross(normal, vec3(0,0,1));\n\tbasis[1] = cross(basis[0], basis[2]);\n\tbasis[0] = normalize(basis[0]);\n\tbasis[1] = normalize(basis[1]);\n\n\treturn mat3(basis[0],basis[1],basis[2]);\n}\n\n\nconst float max_dist = 1000.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.y/iResolution.x;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float t = 0.0;\n    \n    // Ray marching\n    vec3 o = 40.0*vec3(cos(t),sin(t),0.86);\n    vec3 n = -o;\n    o += vec3(0,0,0);\n    mat3 coords = view(n);\n    vec2 sp = (2.0*uv - vec2(1.0,1.0))*vec2(1.0,aspect);\n    vec3 ray = normalize(coords[2] + sp.x*coords[0]+ sp.y * coords[1]);\n    \n    SurfacePoint S = march_ray(o,ray,1000.0);\n    vec3 color = S.c;\n  \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}