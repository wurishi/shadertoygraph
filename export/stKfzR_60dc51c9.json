{"ver":"0.1","info":{"id":"stKfzR","date":"1663956864","viewed":104,"name":"Remez approximation (minimax)","username":"Envy24","description":"Iteratively finds minimax-poynomial coeffitients that approximates arbitrary func(x) on [a; b].\nfunc(x) defined in Common.\n\nCoefficients and errors for ln(x) on [1, 2], (C++, double presicion):\nhttps://www.desmos.com/calculator/2fljgbzaz6","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["approximation","polynomial","general","remez","minimax"],"hasliked":0,"parentid":"slcfDB","parentname":"Quadratic Remez Approximation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  8.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define PI                          3.1415926535897932\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\nfloat horizontal_line(vec2 NDC, float y0) { return SMAA(abs(NDC.y-y0)); }\nfloat y_axis(vec2 NDC) { return SMAA(abs(NDC.x)); }\nfloat x_axis(vec2 NDC) { return SMAA(abs(NDC.y)); }\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float sdf = NDC.y - fx;\n    return SMAA(abs(sdf) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid Chebyshev_nodes(\n    const float a,\n    const float b,\n    inout float nodes[num_of_nodes],\n    int degree)\n{\n    float mean = (a + b) * 0.5;\n    float half_length = (b - a) * 0.5;\n\n    int last_idx = degree - 1;\n\n    for (int i = 0; i < degree; ++i)\n    {\n        float root = cos((2. * float(i) + 1.) * PI / (2. * float(last_idx) + 2.));\n        nodes[last_idx - i] = mean + half_length * root;\n    }\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = (TO_CENTERED_NDC(SC) + vec2(1.5, 0.5)) * 2.5;\n\n    vec3 color = vec3(1.);\n         color -= x_axis(NDC); color -= y_axis(NDC);         \n\n    /* Remez approximation setup */\n    float coefs[order],\n          nodes[num_of_nodes],\n          a = 1., b = sinOSC(4., 5., iTime),\n          dx = 0.01,\n          y_c, y_n,\n          error_scale = 100.,\n          err_deriv_scale = 40.;\n    int max_num_of_iterations = 2;\n    \n    Chebyshev_nodes(a, b, nodes, num_of_nodes);\n    Remez_approximation(a, b, coefs, nodes, degree, max_num_of_iterations);\n    /* Function. */\n         color.rb -= draw_explicit_func(NDC, func(NDC.x), dfdx(NDC.x)); \n    /* Calculated approximation polynomial. */\n         y_c = polynomial(coefs, NDC.x, degree); y_n = polynomial(coefs, NDC.x+dx, degree);\n         color.rg -= draw_explicit_func(NDC, y_c, (y_n-y_c)/dx);\n    /* Error. */\n         y_c = error_scale*error(coefs, NDC.x, degree), y_n = error_scale*error(coefs, NDC.x+dx, degree);\n         color.gb -= draw_explicit_func(NDC, y_c, (y_n-y_c)/dx);\n    /* First derivative for error function. */\n         y_c = err_deriv_scale*error_dedx(coefs, NDC.x, degree), y_n = err_deriv_scale*error_dedx(coefs, NDC.x+dx, degree);\n         color = mix(color, vec3(1,0,1), draw_explicit_func(NDC, y_c, (y_n-y_c)/dx));     \n    /* Approximation interval. */\n         color -= vertical_line(NDC, a)*0.4; color -= vertical_line(NDC, b)*0.4;\n    /**/\n        \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\n// Define function that you want to approximate and first derivative\n#define func(x) ( log(x) )\n#define dfdx(x) ( 1./(x) )\n//#define func(x) ( sin(x) )\n//#define dfdx(x) ( cos(x) )\n\n//#define func(x) ( exp(-x)*sin(x) )\n//#define func(x) ( 1./sqrt(x) )\n//#define func(x) ( sqrt(x) )\n\n// Numeric derivative (if you don't exact formula for your function).\n//#define dfdx(x) ( ( func( (x+0.01) ) - func( (x-0.01) ) ) / (2. * 0.01) )\n\n/* Remez approximation. */\nconst int degree = clamp(3, /* <-- Your choise */ 1,  5); // works for other degrees, but inefficient for shadertoy. \n// Don't change this values.\nconst int order = degree + 1;\nconst int num_of_nodes = degree + 2;\nconst int row_length = num_of_nodes;\nconst int matrix_size = row_length * row_length;\nconst int extended_size = 2 * matrix_size;\n\n/* Linear Algebra */\n// if return_value >= N OR return_value == -1, then matrix is probably singular.\nint to_upper_triangle(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    int numOfSwaps = 0;\n    int rowSize = 2 * N;\n\n    for (int sub = 0; sub < N - 1;)\n    {\n        float diag = M[sub * rowSize + sub];\n\n        if (diag == 0.0)\n        {\n            int r = sub + 1;\n            while (M[r * rowSize + sub] == 0.0 && r < N) { ++r; }\n\n            if (r == N) { return -1; } // singular matrix\n\n            for (int c = 0; c < rowSize; ++c)\n            {\n                float t = M[r * rowSize + c];\n                M[r * rowSize + c] = M[sub * rowSize + c];\n                M[sub * rowSize + c] = t;\n            }\n\n            diag = M[sub * rowSize + sub];\n\n            if (numOfSwaps >= N) { return numOfSwaps; }\n\n            ++numOfSwaps;\n\n            continue;\n        }\n\n        for (int r = sub + 1; r < N; ++r)\n        {\n            if (M[r * rowSize + sub] == 0.0)\n            {\n                continue;\n            }\n\n            float ratio = M[r * rowSize + sub] / diag;\n\n            for (int c = sub; c < rowSize; ++c)\n            {\n                M[r * rowSize + c] -= M[sub * rowSize + c] * ratio;\n            }\n        }\n        ++sub;\n    }\n\n    return numOfSwaps;\n}\n\n// if return_value >= N OR return_value == -1, then matrix is probably singular.\nint to_lower_triangle(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    int numOfSwaps = 0;\n    int Ndec = N - 1;\n    int rowSize = 2 * N;\n\n    for (int sub = 0; sub < Ndec;)\n    {\n        int mirror = (Ndec - sub);\n        float diag = M[mirror * rowSize + mirror];\n\n        if (diag == 0.0)\n        {\n            int r = mirror - 1;\n\n            while (M[r * rowSize + mirror] == 0.0 && r < N) { ++r; }\n\n            if (r == N) { return -1; } // singular matrix\n\n            for (int c = 0; c < N; ++c)\n            {\n                float t = M[r * rowSize + c];\n                M[r * rowSize + c] = M[mirror * rowSize + c];\n                M[mirror * rowSize + c] = t;\n            }\n\n            diag = M[mirror * N + mirror];\n\n            if (numOfSwaps >= N) { return numOfSwaps; }\n\n            ++numOfSwaps;\n\n            continue;\n        }\n\n        for (int r = mirror - 1; r >= 0; --r)\n        {\n            if (M[r * rowSize + mirror] == 0.0)\n            {\n                continue;\n            }\n\n            float ratio = M[r * rowSize + mirror] / diag;\n\n            for (int c = rowSize - 1; c > mirror - 1; --c)\n            {\n                M[r * rowSize + c] -= M[mirror * rowSize + c] * ratio;\n            }\n        }\n        ++sub;\n    }\n\n    return numOfSwaps;\n}\n\nvoid Jordan_Gauss_inverse(\n    inout float[extended_size] M,\n    in int N) // sqrt(extended_size / 2)\n{\n    to_upper_triangle(M, N);\n    to_lower_triangle(M, N);\n\n    int rowSize = 2 * N;\n\n    for (int r = 0; r < N; ++r)\n    {\n        float invDiag = 1.0 / M[r * rowSize + r];\n\n        for (int c = 0; c < N; ++c)\n        {\n            M[N + r * rowSize + c] *= invDiag;\n        }\n        M[r * rowSize + r] *= invDiag;\n    }\n}\n\nvoid read_right_sub_matrix(\n    in float[extended_size] M,\n    inout float[matrix_size] I,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            I[wOffset++] = M[r * rowSize + N + c];\n        }\n    }\n}\n\nvoid write_right_sub_matrix(\n    inout float[extended_size] M,\n    in float[matrix_size] I,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            M[r * rowSize + N + c] = I[wOffset++];\n        }\n    }\n}\n\nvoid read_left_sub_matrix(\n    in float[extended_size] M,\n    inout float[matrix_size] O,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;\n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            O[wOffset++] = M[r * rowSize + c];\n        }\n    }\n}\n\nvoid write_left_sub_matrix(\n    inout float[extended_size] M,\n    in float[matrix_size] O,\n    in int N) // sqrt(matrix_size)\n{\n    int rowSize = 2 * N;\n    int wOffset = 0;          \n\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            M[r * rowSize + c] = O[wOffset++];\n        }\n    }\n}\n\nvoid multiply_square_matrix_and_vector(\n    inout float R[row_length],\n    in float A[matrix_size],\n    in float B[row_length],\n    in int row_length)\n{\n    for (int r = 0; r < row_length; ++r)\n    {\n        float weighted_sum = 0.0;\n\n        int aRowOffset = r * row_length;\n\n        for (int c = 0; c < row_length; ++c)\n        {\n            weighted_sum += A[aRowOffset + c] * B[c];\n        }\n\n        R[r] = weighted_sum;\n    }\n}\n\nvoid identity(\n    inout float[matrix_size] I,\n    in int N) // not extended row size\n{\n    for (int r = 0; r < N; ++r)\n    {\n        for (int c = 0; c < N; ++c)\n        {\n            I[r * N + c] = float(r == c);\n        }\n    }\n}\n/* Linear Algebra */\n\n\n\n\n/* Remez approximation. */\nfloat polynomial(\n    const float coefs[order],\n    const float x,\n    int degree)\n{\n    float sum = coefs[degree--], power = x; \n\n    while (degree > 0)\n    {        \n        sum += coefs[degree--] * power;\n        power *= x;\n    }\n\n    return sum + coefs[degree] * power;\n}\n\nfloat polynomial_dpdx(\n    const float coefs[order],\n    const float x,\n    const int degree)\n{\n    float sum = 0., power = 1.;\n\n    for (int d = degree - 1; d >= 0; --d)\n    {\n        sum += float(degree - d) * coefs[d] * power;\n        power *= x;\n    }\n\n    return sum;\n}\n\nfloat error(const float coefs[order], const float x, const int degree) { return func(x) - polynomial(coefs, x, degree); }\n\nfloat error_dedx(const float coefs[order], const float x, const int degree) { return dfdx(x) - polynomial_dpdx(coefs, x, degree); }\n\nvoid find_new_nodes(\n    const float a,\n    const float b,\n    const float coefs[order],\n    inout float nodes[num_of_nodes],\n    const int num_of_nodes)\n{\n    //int order = num_of_nodes - 1;\n    //int degree = num_of_nodes - 2;\n\n    int count = 1 << 8;\n    float dx = (b - a) / float(count - 1);\n\n    int i = 0; \n    int w_offset = 1;\n    float x_p = a;\n    float y_p = error_dedx(coefs, x_p, degree);\n\n    while ((w_offset < order) &&\n        (i < (count - 1)))    \n    { \n        float x = a + float(i + 1) * dx,\n              y = error_dedx(coefs, x, degree);\n\n        if (sign(y_p) != sign(y))\n        {\n            nodes[w_offset++] =\n                abs(y_p) < abs(y) ?\n                x_p :\n                x;\n        }\n\n        x_p = x; y_p = y; ++i;\n    }\n\n    nodes[0] = a; nodes[order] = b;\n}\n\nvoid Remez_approximation(\n    const float a,\n    const float b,\n    inout float coefs[order],\n    inout float nodes[num_of_nodes],\n    const int degree,\n    const int num_of_iterations)\n{\n    //int order = degree + 1;\n    //int num_of_nodes = degree + 2;\n    const float tolerance = 1e-7;\n\n    float SYS[row_length * row_length];\n    float EXT[row_length * row_length * 2];\n    float Y[row_length];\n    float X[row_length];\n    int err_idx = num_of_nodes - 1;\n    // Example of system for n == 1:\n    //      M          X         Y\n    //  | 1 x0 1 |   | c0 |   | f(x0) |\n    //  | 1 x1 1 | * | c1 | = | f(x1) |\n    //  | 1 x2 1 |   | E  |   | f(x2) |\n\n    float E = 1.;\n\n    for (int i = 0; i < num_of_iterations; ++i)\n    {\n        float alt_one = 1.;\n\n        for (int r = 0; r < num_of_nodes; ++r)\n        {\n            float power = 1.;\n\n            for (int c = (num_of_nodes - 2); c >= 0; --c)\n            {\n                SYS[r * num_of_nodes + c] = power;\n                power *= nodes[r];\n            }\n            SYS[r * num_of_nodes + (num_of_nodes - 1)] = alt_one;\n            alt_one *= -1.;\n            \n            Y[r] = func(nodes[r]);\n        }\n        \n        write_left_sub_matrix(EXT, SYS, num_of_nodes);\n        identity(SYS, num_of_nodes);\n        write_right_sub_matrix(EXT, SYS, num_of_nodes);\n        Jordan_Gauss_inverse(EXT, num_of_nodes);\n        read_right_sub_matrix(EXT, SYS, num_of_nodes);\n        multiply_square_matrix_and_vector(X, SYS, Y, num_of_nodes);\n\n        for (int k = 0; k < order; ++k) { coefs[k] = X[k]; }\n        \n        if (abs(E - X[err_idx]) < tolerance) { return; }\n        E = X[err_idx];\n\n        find_new_nodes(a, b, coefs, nodes, num_of_nodes);\n    }\n}\n/* Remez approximation. */","name":"Common","description":"","type":"common"}]}