{"ver":"0.1","info":{"id":"NltBWH","date":"1663031488","viewed":111,"name":"Project 1 - Josh did his best","username":"joshyhearne","description":"CS4710 Project 1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["hashtag"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":" // rotate functions\n mat3 rotateY(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0.0, -s,\n        0.0,1.0,0.0,\n        s, 0.0, c\n    );\n}\n\n\nmat3 rotateX(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        0.0,1.0,0.0,\n        c, 0.0, -s,\n        s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float rad) {\n    float c = cos(rad);\n    float s = sin(rad);\n    return mat3(\n        c, 0.0, -s,\n        s, 0.0, c,\n        0.0,1.0,0.0\n    );\n}\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// true if ray hits anything in scene\nbool testScenePos(vec3 eye, vec3 dir, out vec3 outPos) {\n    float t = 0.0;\n    for (int i = 0; i < 60; i++) {\n        // calc positions from view rays\n        vec3 pos = eye + dir * t;\n        \n        // get distance from positions to spheres\n        float dist = opSmoothSubtraction(\n                          sdBoxFrame(rotateX(0.785)*rotateZ(0.785)*rotateY(iTime)*pos,vec3(4.0,4.0,4.0), 0.6),\n                          opSmoothSubtraction(\n                              sdBoxFrame(rotateX(-0.785)*rotateZ(-0.785)*rotateY(iTime)*pos, vec3(4.0,4.0,4.0), 0.6),\n                              sdSphere(pos, 4.8f),\n                              0.9),\n                          0.5);\n        \n        // check if ray hit\n        if (dist < 0.01) {\n            outPos = pos;\n            return true;\n        }\n        t += dist;\n    }\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // set background fractal noise\n    vec3 col = rotateY(cos(iTime))*vec3(fract(tan(fragCoord.x*fragCoord.y-(tan(iTime)/4.0)))/2.0, fract(cos(fragCoord.x*fragCoord.y-(cos(iTime)/4.0)))/2.0, fract(sin(fragCoord.y*fragCoord.x-(sin(iTime)/4.0)))/2.0);\n    \n    // center the shape\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 pos, posdy, posdx, normal;\n    \n    vec3 dir = normalize(vec3(uv.x, uv.y, 5));\n    vec3 dirdx = normalize(vec3(uv.x+0.01, uv.y, 5));\n    vec3 dirdy = normalize(vec3(uv.x, uv.y+0.01, 5));\n    vec3 eye = vec3(0,3.0,-100);\n    \n    if (testScenePos(eye, dir, pos) && \n        testScenePos(eye, dirdx, posdx) &&\n        testScenePos(eye, dirdy, posdy)) {\n        vec3 CA = normalize(posdy - pos);\n        \n        vec3 BA = normalize(posdx - pos);\n        \n        normal = cross(CA, BA);\n        \n        normal.z = -normal.z;\n        \n        vec3 lightDir = normalize(vec3(-(iMouse.xy/iResolution.xy-vec2(0.5)), 1));\n        // modify this for shape textures\n        col = fract(sin(normal*iTime/10.0));\n    }\n\n    // Output to screen -- modify this for whole screen filter\n    fragColor = vec4(col + texture(iChannel0, uv+vec2(fract(iTime), fract(sin(-iTime))*10.0)/10.0).rgb, 1.0);\n}","name":"Image","description":"","type":"image"}]}