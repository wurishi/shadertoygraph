{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n#define lerp(x, y, t) mix(x, y, t)\n\nfloat body(vec3 p)\n{\n  p.x *= 0.6;\n  float d1 = length(p.xy) - 0.4;\n  p.y -= 0.5;\n  float d2 = length(p.xy) - 0.18;\n  float d = lerp(d1, d2, saturate((p.y + 0.9) * 0.8));\n  d = max(d, abs(p.z) - 0.1);  \n  return d;\n}\n\nfloat neck(vec3 p, out float id)\n{ \n  id = 1.0;\n  p.y -= 1.0;\n  float t = min(p.y + 0.7, 1.21);\n  float h = saturate(p.y + 0.7 - 1.21);\n  p.z -= 0.114 - saturate(t) * 0.02 - h * 0.15;\n  if (p.z > -0.012) id = 2.0;\n  p.x *= (1.0 + 0.3 * t) - min(12.0 * h, 0.4 + h);\n  p.y *= (1.0 + h * abs(p.x));\n  float s = clamp((t - 0.32) * 10.0, 0.3, 1.0);\n  float d = length(p.xz * vec2(1.0, s)) - 0.05;\n  p.z += 0.3;\n  s = mod(pow(t, 0.48) + 2.005, 0.036) - 0.002;\n  s = saturate(0.004 - s * s * 800.0 * t);\n  if (s > 0.0 && p.z > 0.3) id = 3.0;\n  p.z -= s;\n  d = max(d, length(p.xz) - 0.3);\n  d = max(d, abs(p.y) - 0.74);  \n  return d * 0.7;\n}\n\nfloat inner(vec3 p)\n{\n  p.y -= 0.32;\n  float d1 = max(length(p.xy) - 0.1, -p.z);\n  float d2 = max(length(p.xy) - 0.2, abs(p.z) - 0.09);\n  return min(d1, d2);  \n}\n\nfloat bridge(vec3 p, out float id)\n{\n  id = 1.0;\n  p.y += 0.06;\n  p.z += clamp(abs(p.x) * 0.12, 0.01, 0.02) - 0.11;\n  float d = length(max(abs(p) - vec3(0.15, 0.02, 0.02), 0.0)) * 0.9;\n  float d2 = length(max(abs(p - vec3(0, 0.012, 0)) - vec3(0.07, 0.003, 0.027), 0.0));\n  if (d2 < d) {d = d2; id = 2.0;}\n  if (abs(p.x) > 0.06) return d;\n  p.x = mod(p.x + 2.0, 0.02) - 0.01;\n  p.z -= 0.025;\n  float d3 = length(p.xyz) - 0.005;\n  if (d3 < d) {d = d3; id = 3.0;}  \n  return d;\n}\n\nfloat screws(vec3 p)\n{\n  float t = min(p.y - 1.53, 0.18);\n  if (t < 0.0) return 1e3;\n  p.z -= 0.075 - 0.15 * t;\n  p.y = mod(t - p.z * 0.2, 0.06) - 0.03;\n  p.x = abs(p.x) - 0.033;\n  float r = p.z < 0.0 ? 0.01 : 0.005;\n  float d = max(length(p.xy) - r, abs(p.z) - 0.035);\n  d = min(d, max(length(p.xy) - 0.009, abs(p.z) - 0.02));\n  p.z += 0.024;\n  d = min(d, max(length(p.yz) - 0.004, abs(p.x) - 0.03));\n\n  // handle\n  p.x -= 0.02 + 0.05 * t;\n  float h = length(p.xyz) - 0.014;\n  p.x -= 0.01;\n  h = max(h, length(max(abs(p.xyz) - vec3(0.01, 0.01, 0.004), 0.0)));\n  d = min(d, h);\n  return d * 0.9;\n}\n\nfloat strings(vec3 p)\n{\n  p.y -= 0.72;\n  float t = min(p.y + 0.785, 1.57);\n  p.x *= (1.0 + 0.4 * t);\n  if (abs(p.x) > 0.06) return 1e3;\n  \n  float f = saturate(p.y - 0.78);\n  if (p.y > 0.0) p.y *= 0.65 + 3.6 * abs(p.x);\n  p.x += clamp(-sign(p.x) * 0.2 * f, -abs(p.x), abs(p.x));\n  p.z += 0.15 * f;\n  \n  float r = 0.0006 - p.x * 0.006;\n  p.z -= 0.125 - 0.015 * t;\n  p.x = mod(p.x + 2.0, 0.02) - 0.01;\n  float d = length(p.xz) - r;\n  d = max(d, abs(p.y) - 0.785);\n  return d;\n}\n\nvec2 DE(vec3 p)\n{\n  // bounding box\n  vec3 bb = saturate(abs(p.xyz) - vec3(0.5, 2, 0.3));\n  if (bb.x > 0.0 || bb.y > 0.0 || bb.z > 0.0) return vec2(length(bb) + 0.01, -1);\n \n  float d = body(p);\n  float id = 1.0;\n  float sid = 0.0;\n  float t = neck(p, sid);\n  if (t < d) {d = t; id = 2.0 + sid * 0.1;}\n  t = -inner(p);\n  if (t > d) {d = t; id = 3.0;}\n  t = bridge(p, sid);\n  if (t < d) {d = t; id = 4.0 + sid * 0.1;}\n  t = screws(p);\n  if (t < d) {d = t; id = 5.0;}\n  t = strings(p);\n  if (t < d) {d = t; id = 6.0;}  \n  return vec2(d, id);\n}\n\nvec4 ray_marching(vec3 ro,  vec3 rd)\n{\n  vec3 p = ro;\n  for (int i = 0; i < 256; ++i)\n  {\n    vec2 d = DE(p);\n    p += d.x * rd;\n    if (d.x < 0.0001) return vec4(p, d.y);\n  }\n \n  float t = (-0.4 - ro.y) / rd.y;\n  vec3 floorp = ro + t * rd;\n  if (t > 0.0) return vec4(floorp, 0.0);\n  return vec4(ro, -1);\n}\n\nvec3 brdf(vec3 diff, float m, vec3 N, vec3 L, vec3 V)\n{\n  vec3 H = normalize(V + L);\n  vec3 F = vec3(0.05 + 0.95 * pow(1.0 - dot(V, H), 5.0));\n  vec3 R = F * pow(max(dot(N, H), 0.0), m);\n  return diff + R * (m + 8.0) / 8.0;\n}\n\nfloat hash(float n)\n{\n  return fract(sin(n) * 43758.5453);\n}\n\nfloat qnoise(in vec3 x)\n{\n  vec3 p = floor(x);\n  vec3 f = fract(x);\n  f = f * f * (3.0 - 2.0 * f);\n  float n = p.x + p.y * 57.0 + 113.0 * p.z;\n  float res = lerp(lerp(lerp(hash(n+  0.0), hash(n+  1.0),f.x),\n                        lerp(hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                   lerp(lerp(hash(n+113.0), hash(n+114.0),f.x),\n                        lerp(hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n  return res;\n}\n\n\nvec4 shade(vec3 ro, vec3 rd)\n{\n  vec4 rm = ray_marching(ro, rd);\n  if (rm.w < 0.0) return vec4(0, 0, 0, 0);\n    \n  vec3 p = rm.xyz;\n  float k = DE(p).x;\n  float gx = DE(p + vec3(1e-5, 0, 0)).x - k;\n  float gy = DE(p + vec3(0, 1e-5, 0)).x - k;\n  float gz = DE(p + vec3(0, 0, 1e-5)).x - k;\n  vec3 N = normalize(vec3(gx, gy, gz));\n \n  float ao = 0.0;\n  ao += DE(p + 0.01 * N).x * 50.0;\n  ao += DE(p + 0.02 * N).x * 10.0;\n\n  vec3 L = normalize(vec3(-0.1, 1, 1));\n  float sr = ray_marching(p + 0.001 * L, L).w;\n  float shadow = sr > 0.0 ? 0.0 : 1.0;\n \n  vec3 diff = vec3(0.6);\n  float m = 10.0;\n  if (rm.w < 0.9) // floor\n  {\n    shadow = saturate(0.4 + 0.6 * shadow + 0.3 * length(p.xz));\n\treturn vec4(vec3(0.0), 1.0 - shadow);\n  }\n  if (rm.w < 1.9) // body\n  {\n    vec3 C = vec3(0.32, 0.24, 0.08);\n    float s = length(p.xy - vec2(0, 0.32));\n    if (abs(s - 0.12) < 0.008) C = vec3(0.01, 0.004, 0);\n    \n    diff = lerp(vec3(0.02, 0.008, 0.001), C, saturate(N.z));\n    float r = qnoise(200.0 * p.xzz + 2.0 * qnoise(5.0 * p.yyz));\n    diff *= (r * 0.3 + 0.7);\n    if (abs(abs(p.z) - 0.08) < 0.005) diff = vec3(0.4);\n  }\n  else if (rm.w < 2.25) // neck\n  {\n    diff = vec3(0.3, 0.18, 0.1) * (0.7 + qnoise(300.0 * p) * 0.3);\n    if (rm.w > 2.15) diff *= 0.3;\n  }\n  else if (rm.w < 2.9)\n  {\n    diff = vec3(0.8, 0.6, 0.4);\n    m = 80.0;\n  }\n  else if (rm.w < 3.9) // inner\n  {\n    diff = vec3(0.25, 0.2, 0.15) * (0.5 + 0.5 * qnoise(400.0 * p.xzz));\n  }\n  else if (rm.w < 4.15) // bridge\n  {\n    diff = vec3(0);\n  }\n  else if (rm.w < 4.25)\n  {\n    diff = vec3(0.6);\n  }\n  else if (rm.w < 4.35)\n  {\n    diff = vec3(0.04);\n    m = 80.0;\n  }\n  else if (rm.w < 5.9) // screws\n  {\n    m = 50.0;\n  }\n  else // strings\n  {\n    m = 50.0;\n  }\n  vec3 f = brdf(diff, m, N, L, -rd);\n\n  vec3 D = vec3(3.0);\n  vec3 A = vec3(0.8);\n  vec3 C = (D * saturate(dot(N, L)) * f * shadow + A * diff) * ao;\n  return vec4(C, 1);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  vec3 p = vec3((uv * 2.0 - 1.0), 0.0);\n  p.xy *= vec2(iResolution.x / iResolution.y, 1.0);\n \n  vec3 param = vec3(iTime * 0.2, 0.3, 7);\n  vec4 rot;\n  rot.x = sin(param.x);\n  rot.y = cos(param.x);\n  rot.z = sin(param.y);\n  rot.w = cos(param.y);\n  \n  vec3 rt = vec3(0, 0.6, 0);\n  vec3 ro = vec3(rot.x * rot.w, abs(rot.y) * rot.z, rot.y);\n  ro = ro * param.z;\n  \n  vec3 cd = normalize(rt - ro);\n  vec3 cr = normalize(cross(cd, vec3(0, 1, 0)));\n  vec3 cu = cross(cr, cd);\n \n  vec3 rd = normalize(p.x * cr + p.y * cu + 5.0 * cd);\n  vec4 radiance = shade(ro, rd);\n  \n  \n  float len2 = dot(p, p);\n  vec3 col = vec3(0.2, 0.26, 0.27) / (1.0 + len2 * len2 * 0.5);\n  //col += qnoise(vec3(fragCoord.xy, 0) * 0.5) * 0.04;\n\t\n  col = lerp(col, radiance.rgb, radiance.a);\n  fragColor = vec4(pow(col, vec3(0.45)), 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsXGW4","date":"1369508450","viewed":968,"name":"guitar","username":"atyuwen","description":"Inspired by iq's piano, I decide to model my guitar in distance field as well, and here it is!\nI originally wrote the shader in HLSL with my own tool: https://github.com/atyuwen/hlsl_live_coding.\nDown the tool and enable 64xAA for much better quality.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}