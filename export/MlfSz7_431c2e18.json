{"ver":"0.1","info":{"id":"MlfSz7","date":"1435564938","viewed":5488,"name":"Equirectangular projection","username":"mlkn","description":"Equirectangular projection.\nControl angles with mouse.","likes":33,"published":3,"flags":0,"usePreview":0,"tags":["sphere","projection","mapping","equirectangular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.14159\n#define drawSphere true\n\nconst float radius = 0.3;\n\nfloat angVelocity = -0.3,\n\t  phi = 0.0,\n      psi = 0.0,\n      theta = 0.0;\n\n\nvec3 sphericalToWorld(vec2 sphCoord, float r)\n{\n    return vec3(\n    \tr * sin(sphCoord.y) * cos(sphCoord.x),\n        r * sin(sphCoord.y) * sin(sphCoord.x),\n        r * cos(sphCoord.y)\n    );\n}\n\nvec2 worldToSpherical(vec3 flatCoord, float r)\n{\n    return vec2(\n        atan(flatCoord.x, flatCoord.y),\n        acos(flatCoord.z / r)\n    );   \n}\n \nmat3 makeRotationMatrix(vec3 a)\n{\n    return mat3(\n    \tcos(a.x) * cos(a.z) - sin(a.x) * cos(a.y) * sin(a.z),\n        -cos(a.x) * sin(a.z) - sin(a.x) * cos(a.y) * cos(a.z),\n        sin(a.x) * sin(a.y),\n        sin(a.x) * cos(a.z) + cos(a.x) * cos(a.y) * sin(a.z),\n        -sin(a.x) * sin(a.z) + cos(a.x) * cos(a.y) * cos(a.z),\n        -cos(a.x) * sin(a.y),\n        sin(a.y) * sin(a.z),\n        sin(a.y) * cos(a.z),\n        cos(a.y)\n    );\n}\n\nvec3 screenToWorld(vec2 myPos, vec2 sphereCenter, float r)\n{\n    vec3 myVec;\n    myVec.y = myPos.x - sphereCenter.x;\n    myVec.z = -(myPos.y - sphereCenter.y);\n    myVec.x = sqrt(r * r - myVec.z * myVec.z - myVec.y * myVec.y);\n    return myVec;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 mouse = iMouse.xy;\n        \n  \tphi = iMouse.x * 2.0 * M_PI / iResolution.x;\n    psi = iMouse.y * M_PI / iResolution.y;\n    theta = iTime * angVelocity;\n    \n    vec2 sphCenter = .5*vec2(iResolution.x/iResolution.y, 1.);\n    vec2 p = fragCoord.xy / iResolution.xy;\n \n    vec3 worldSphCoord = sphericalToWorld(p * vec2(2.0 * M_PI, M_PI), 1.0);\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    if (drawSphere && length(p - sphCenter) < radius)\n        worldSphCoord = screenToWorld(p, sphCenter, radius);\n    \n    mat3 rotationMatrix = makeRotationMatrix(vec3(phi, psi, theta));\n    vec3 rotatedWorldSphCoord = normalize(rotationMatrix * worldSphCoord);\n\n    vec2 rotatedSphericalCoord = worldToSpherical(rotatedWorldSphCoord, 1.0);\n\n    fragColor = texture(iChannel0, rotatedSphericalCoord / vec2(2.*M_PI, M_PI), 0.0);\n}","name":"Image","description":"","type":"image"}]}