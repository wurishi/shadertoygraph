{"ver":"0.1","info":{"id":"tsjGWd","date":"1550352472","viewed":222,"name":"perlin cave","username":"Myro","description":"moving around a cave generated using perlin noise and boolean operations","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","noise","perlin","rainbow","cave","dark","room","exploration","fly","through"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// controls : click and drag to navigate\n\n#define MARCHINGITERATIONS 80\n#define MARCHINGSTEP 0.5\n\n// cosine based palette, 4 vec3 params\nvec3 cosineColor( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 palette (float t) {\n    return cosineColor( t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n}\n\n// hash and noise from iq\nfloat hash(vec3 p)  // replace this by something better\n{\n    p  = fract( p*0.3183099+.1 );\n    p *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x, float step1, float step2)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float n = mix(mix(mix( hash(p+vec3(0,0,0)), \n                        hash(p+vec3(1,0,0)),f.x),\n                   mix( hash(p+vec3(0,1,0)), \n                        hash(p+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(p+vec3(0,0,1)), \n                        hash(p+vec3(1,0,1)),f.x),\n                   mix( hash(p+vec3(0,1,1)), \n                        hash(p+vec3(1,1,1)),f.x),f.y),f.z);\n    n = smoothstep(step1, step2, n);\n    return n;\n}\n\n// MAPPING FUNCTION ... \n// returns the distance of the nearest object in the direction p on the x coordinate \n// and the color on the y coordinate\nvec2 map (vec3 path) {\n    vec3 p = path; \n        \n    // boolean operation : taking a box and extruding a sphere\n    //float dist = max(noise(p*0.5), sphere(p,10.0));\n    \n    // actual perlin cave\n    float dist = 0.0;\n        \n    //playing with noise & operators\n    dist = noise(p*0.1, 0.2, 0.3); \n    dist = min(dist, noise(p*0.2, 0.2, 0.3));\n    float tmp = dist;\n    dist = max(dist, noise(p*0.4, 0.4, 0.6));\n    \n    \n    //detecting boolean operation with a color\n    float c = 0.05*(tmp-dist)+0.0002*length(p);\n    \n    return vec2(dist, c);\n}\n\n// TRACING A PATH : \n// measuring the distance to the nearest object on the x coordinate\n// and returning the color index on the y coordinate\nvec2 trace  (vec3 origin, vec3 ray) {\n    \n    //t is the point at which we are in the measuring of the distance\n    float t =0.0;\n    float c = 0.0;\n    \n    for (int i=0; i<MARCHINGITERATIONS; i++) {\n        vec3 path = origin + ray * t;   \n        vec2 dist = map(path);\n        // we want t to be as large as possible at each step but not too big to induce artifacts\n        t += MARCHINGSTEP * dist.x;\n        c += dist.y;\n    }\n    \n    return vec2(t,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel coordinates from -1 to 1\n    uv = uv * 2.0 - 1.0;\n    // Adjusting aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    //ray direction (camera is at (0,0,0), view plane is at 0,0,1)\n    vec3 ray = normalize(vec3 (uv,1.0));\n\n    // camera position\n    float posY = 40.0 * iMouse.y / iResolution.y;\n    vec3 origin = vec3 (3.0*iTime, posY+0.1*iTime, 1.0 * iTime)+vec3(10.0);  \n    \n    vec2 mouse = vec2(iMouse.x / iResolution.x-0.3,iMouse.y / iResolution.y-0.5);\n    if (iMouse.x <= 0.0 && iMouse.y <= 0.0) {\n        mouse.x = 0.15+0.15*sin(0.3*iTime);\n        mouse.y = 0.25*cos(0.2*iTime+100.0);\n    }\n    //camera rotation (rotating the ray)\n    //rotation around the x axis\n    float mouseRotX =  -2.5 * (mouse.y);\n    ray.yz *= mat2(cos(mouseRotX), -sin(mouseRotX), sin(mouseRotX), cos(mouseRotX));\n\n    //rotation around the y axis\n    float autoRotY = iTime/8.0;\n    //ray.xz *= mat2(cos(autoRotY), -sin(autoRotY), sin(autoRotY), cos(autoRotY));\n    float mouseRotY =  -6.28*(mouse.x);\n    ray.xz *= mat2(cos(mouseRotY), -sin(mouseRotY), sin(mouseRotY), cos(mouseRotY));\n\n    //tracing the ray (getting the distance of the closest object in the ray direction)\n    vec2 depth = trace(origin,ray);\n    \n    //rendering with a fog calculation (further is darker)\n    float fog = 1.0 / (1.0 + pow(depth.x,2.0)  * 0.01);\n    \n    //frag color\n    vec3 fc = vec3(fog);\n    \n    \n    // Output to screen\n    fragColor = vec4(palette(depth.y)*fog,0.0);\n}","name":"Image","description":"","type":"image"}]}