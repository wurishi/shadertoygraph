{"ver":"0.1","info":{"id":"NlyGDK","date":"1638353158","viewed":75,"name":"SH lighting*visibility","username":"tepSHATOY","description":"SH lighting multiply with visibility","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["lighting","spherical","harmonics","sh","visibility","zh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Experiment with SH product\n\n///////////////////////////////////////////////////////////////////////\n// Constants\n///////////////////////////////////////////////////////////////////////\nconst float kInf        = 1e16f; // some random max distance..\nconst float kPi         = 3.14159265358979323846264338327950288;\nconst vec3  kWorldUp    = vec3(0.0, 1.0, 0.0);\n\nconst int kGeomType_Sphere = 0;\nconst int kGeomType_Cylinder = 1;\n\n///////////////////////////////////////////////////////////////////////\n// Types\n///////////////////////////////////////////////////////////////////////\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n\tvec3  center;\n\tfloat radius;\n};\n\nstruct Cylinder\n{\n    vec3 a;\n    vec3 b;\n    float radius;\n};\n\nstruct HitRecord\n{\n    int geomType;\n    vec3 p;\n    vec3 t;\n    vec3 b;\n    vec3 n;\n};\n\nstruct Scene\n{\n    Sphere sphere;\n    Cylinder cylinder;\n};\n\n///////////////////////////////////////////////////////////////////////\n// Utils\n///////////////////////////////////////////////////////////////////////\nfloat sqr(float x)\n{\n    return x*x;\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 LinearToGammaSrgb( vec3 linColor )\n{    \n\tlinColor.r = ( linColor.r <= 0.0031308 ) ? ( 12.92 * linColor.r ) : ( 1.055 * pow( linColor.r, 1.0f/2.4 ) - 0.055 );\n    linColor.g = ( linColor.g <= 0.0031308 ) ? ( 12.92 * linColor.g ) : ( 1.055 * pow( linColor.g, 1.0f/2.4 ) - 0.055 );\n\tlinColor.b = ( linColor.b <= 0.0031308 ) ? ( 12.92 * linColor.b ) : ( 1.055 * pow( linColor.b, 1.0f/2.4 ) - 0.055 );\n    return linColor;\n}\n\n// rotate z to d\n// https://iquilezles.org/articles/noacos\nmat3x3 rotationAlign( vec3 d, vec3 z )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = (1.0f-c)/(1.0001f-c*c);\n\n    return mat3x3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n///////////////////////////////////////////////////////////////////////\n// Intersection\n///////////////////////////////////////////////////////////////////////\nfloat RaySphereIntersect(Ray r, Sphere sphere, float tmin)\n{\n    vec3 oc = r.origin - sphere.center;\n    float a = dot(r.dir, r.dir);\n    float b = 2.0 * dot(oc, r.dir);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n    float discriminant = b * b - 4.0 * a*c;\n\n    if (discriminant > 0.0)\n    {\n        float t = (-b - sqrt(discriminant)) / (2.0 * a);\n        if (tmin < t)\n            return t;\n    }    \n    return -1.0;\n}\n\n// cylinder defined by extremes pa and pb, and radious ra\nvec4 cylIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(-1.0); //no intersection\n}\n\n///////////////////////////////////////////////////////////////////////\n// SH Math (Z-Up)\n///////////////////////////////////////////////////////////////////////\nstruct SH3\n{\n    float data[9];\n};\n\nstruct SH3Color\n{\n    SH3 r;\n    SH3 g;\n    SH3 b;\n};\n\nvoid SH3Scale(inout SH3 sh, float scale)\n{\n    for (int i=0; i<9; i++)\n        sh.data[i] *= scale;       \n}\n\nfloat SH3Dot(SH3 coeffs, SH3 dir)\n{\n    float result = 0.0;\n    for( int i = 0; i < 9; i++ )\n        result += coeffs.data[i] * dir.data[i];\n    return result;\n}\n\nSH3 SH3Evaluate(vec3 xyz)\n{\n    SH3 result;\n    float fX = xyz.x;\n    float fY = xyz.y;\n    float fZ = xyz.z;\n    \n\tfloat fC0, fC1, fS0, fS1, fTmpA, fTmpB, fTmpC;\n\tfloat fZ2 = fZ * fZ;\n\n\tresult.data[0] = 0.2820947917738781;\n\tresult.data[2] = 0.4886025119029199 * fZ;\n\tresult.data[6] = 0.9461746957575601 * fZ2 + -0.3153915652525201;\n\tfC0 = fX;\n\tfS0 = fY;\n\n\tfTmpA = -0.48860251190292;\n\tresult.data[3] = fTmpA * fC0;\n\tresult.data[1] = fTmpA * fS0;\n\tfTmpB = -1.092548430592079 * fZ;\n\tresult.data[7] = fTmpB * fC0;\n\tresult.data[5] = fTmpB * fS0;\n\tfC1 = fX * fC0 - fY * fS0;\n\tfS1 = fX * fS0 + fY * fC0;\n\n\tfTmpC = 0.5462742152960395;\n\tresult.data[8] = fTmpC * fC1;\n\tresult.data[4] = fTmpC * fS1;\n    \n    return result;\n}\n\nvec3 toSHSpace(vec3 dir)\n{\n    return dir.xzy;\n}\n\nvec3 fromSHSpace(vec3 dir)\n{\n    return dir.xzy;\n}\n\nSH3 SH3ProjectCone(float alpha)\n{\n    float cosAlpha = cos(alpha);\n    float sinAlpha = sin(alpha);\n    float sinAlphaSqr = sqr(sinAlpha);\n    \n    SH3 sh;\n    \n    // DC\n    sh.data[0] = 1.77245 * (1.0 - cosAlpha);    \n    // Linear\n    sh.data[1] = 0.0;\n    sh.data[2] = 1.53499 * sinAlphaSqr;\n    sh.data[3] = 0.0;\n    // Quadratic\n    sh.data[4] = 0.0;\n    sh.data[5] = 0.0;\n    sh.data[6] = 1.98166 * cosAlpha * sinAlphaSqr;\n    sh.data[7] = 0.0;\n    sh.data[8] = 0.0;\n    return sh;\n}\n\nSH3 SH3ProjectSmoothCone(float alpha)\n{\n    alpha = max(alpha, radians(0.5));\n    \n    float alpha3 = alpha*alpha*alpha;\n    float sinAlpha = sin(alpha);\n    float cosAlpha = cos(alpha);\n    float cosAlpha2 = cosAlpha * cosAlpha;\n    float cosAlpha3 = cosAlpha2 * cosAlpha;\n    \n    SH3 sh;\n    // DC\n    sh.data[0] = ((alpha3 + 6.0 * alpha - 12.0 * sinAlpha + 6.0 * alpha * cosAlpha) * 1.77245) / alpha3;\n    // Linear\n    sh.data[1] = 0.0;\n    sh.data[2] = ((alpha3 - 3.0 * cosAlpha * sinAlpha + 3.0 * alpha * cosAlpha2) * 3.06998) / (4.0 * alpha3);\n    sh.data[3] = 0.0;\n    // Quadractic\n    sh.data[4] = 0.0;\n    sh.data[5] = 0.0;\n    sh.data[6] = ((-6.0*alpha - 2.0*cosAlpha2*sinAlpha - 9.0*alpha*cosAlpha + 14.0*sinAlpha + 3.0*alpha*cosAlpha3) * 3.96333) / (9.0 * alpha3);\n    sh.data[7] = 0.0;\n    sh.data[8] = 0.0;\n    return sh;\n}\n\n// Performs the SH triple product r = a * b\n// From John Snyder (appendix A8)\n//\nSH3 SH3Product(SH3 a, SH3 b)\n{\n    SH3 r;\n\n    float  ta, tb, t;\n\n    const float C0 = 0.282094792935999980;\n    const float C1 = -0.126156626101000010;\n    const float C2 = 0.218509686119999990;\n    const float C3 = 0.252313259986999990;\n    const float C4 = 0.180223751576000010;\n    const float C5 = 0.156078347226000000;\n    const float C6 = 0.090111875786499998;\n\n    // [0,0]: 0,\n    r.data[0] = C0*a.data[0]*b.data[0];\n\n    // [1,1]: 0,6,8,\n    ta = C0*a.data[0]+C1*a.data[6]-C2*a.data[8];\n    tb = C0*b.data[0]+C1*b.data[6]-C2*b.data[8];\n    r.data[1] = ta*b.data[1]+tb*a.data[1];\n    t = a.data[1]*b.data[1];\n    r.data[0] += C0*t;\n    r.data[6] = C1*t;\n    r.data[8] = -C2*t;\n\n    // [1,2]: 5,\n    ta = C2*a.data[5];\n    tb = C2*b.data[5];\n    r.data[1] += ta*b.data[2]+tb*a.data[2];\n    r.data[2] = ta*b.data[1]+tb*a.data[1];\n    t = a.data[1]*b.data[2]+a.data[2]*b.data[1];\n    r.data[5] = C2*t;\n\n    // [1,3]: 4,\n    ta = C2*a.data[4];\n    tb = C2*b.data[4];\n    r.data[1] += ta*b.data[3]+tb*a.data[3];\n    r.data[3] = ta*b.data[1]+tb*a.data[1];\n    t = a.data[1]*b.data[3]+a.data[3]*b.data[1];\n    r.data[4] = C2*t;\n\n    // [2,2]: 0,6,\n    ta = C0*a.data[0]+C3*a.data[6];\n    tb = C0*b.data[0]+C3*b.data[6];\n    r.data[2] += ta*b.data[2]+tb*a.data[2];\n    t = a.data[2]*b.data[2];\n    r.data[0] += C0*t;\n    r.data[6] += C3*t;\n\n    // [2,3]: 7,\n    ta = C2*a.data[7];\n    tb = C2*b.data[7];\n    r.data[2] += ta*b.data[3]+tb*a.data[3];\n    r.data[3] += ta*b.data[2]+tb*a.data[2];\n    t = a.data[2]*b.data[3]+a.data[3]*b.data[2];\n    r.data[7] = C2*t;\n\n    // [3,3]: 0,6,8,\n    ta = C0*a.data[0]+C1*a.data[6]+C2*a.data[8];\n    tb = C0*b.data[0]+C1*b.data[6]+C2*b.data[8];\n    r.data[3] += ta*b.data[3]+tb*a.data[3];\n    t = a.data[3]*b.data[3];\n    r.data[0] += C0*t;\n    r.data[6] += C1*t;\n    r.data[8] += C2*t;\n\n    // [4,4]: 0,6,\n    ta = C0*a.data[0]-C4*a.data[6];\n    tb = C0*b.data[0]-C4*b.data[6];\n    r.data[4] += ta*b.data[4]+tb*a.data[4];\n    t = a.data[4]*b.data[4];\n    r.data[0] += C0*t;\n    r.data[6] -= C4*t;\n\n    // [4,5]: 7,\n    ta = C5*a.data[7];\n    tb = C5*b.data[7];\n    r.data[4] += ta*b.data[5]+tb*a.data[5];\n    r.data[5] += ta*b.data[4]+tb*a.data[4];\n    t = a.data[4]*b.data[5]+a.data[5]*b.data[4];\n    r.data[7] += C5*t;\n\n    // [5,5]: 0,6,8,\n    ta = C0*a.data[0]+C6*a.data[6]-C5*a.data[8];\n    tb = C0*b.data[0]+C6*b.data[6]-C5*b.data[8];\n    r.data[5] += ta*b.data[5]+tb*a.data[5];\n    t = a.data[5]*b.data[5];\n    r.data[0] += C0*t;\n    r.data[6] += C6*t;\n    r.data[8] -= C5*t;\n\n    // [6,6]: 0,6,\n    ta = C0*a.data[0];\n    tb = C0*b.data[0];\n    r.data[6] += ta*b.data[6]+tb*a.data[6];\n    t = a.data[6]*b.data[6];\n    r.data[0] += C0*t;\n    r.data[6] += C4*t;\n\n    // [7,7]: 0,6,8,\n    ta = C0*a.data[0]+C6*a.data[6]+C5*a.data[8];\n    tb = C0*b.data[0]+C6*b.data[6]+C5*b.data[8];\n    r.data[7] += ta*b.data[7]+tb*a.data[7];\n    t = a.data[7]*b.data[7];\n    r.data[0] += C0*t;\n    r.data[6] += C6*t;\n    r.data[8] += C5*t;\n\n    // [8,8]: 0,6,\n    ta = C0*a.data[0]-C4*a.data[6];\n    tb = C0*b.data[0]-C4*b.data[6];\n    r.data[8] += ta*b.data[8]+tb*a.data[8];\n    t = a.data[8]*b.data[8];\n    r.data[0] += C0*t;\n    r.data[6] -= C4*t;\n    // entry count=13\n    // **multiplications count=120**\n    // **addition count=74**\n    return r;\n}\n\n// http://filmicworlds.com/blog/simple-and-fast-spherical-harmonic-rotation/\nSH3 SH3Rotate(SH3 src, mat3x3 mat)\n{\n\tfloat m00 = mat[0][0];\n\tfloat m01 = mat[0][1];\n\tfloat m02 = mat[0][2];\n\tfloat m10 = mat[1][0];\n\tfloat m11 = mat[1][1];\n\tfloat m12 = mat[1][2];\n\tfloat m20 = mat[2][0];\n\tfloat m21 = mat[2][1];\n\tfloat m22 = mat[2][2];\n\n\tconst float s_c3 = 0.94617469575; // (3*sqrt(5))/(4*sqrt(pi))\n\tconst float s_c4 = -0.31539156525;// (-sqrt(5))/(4*sqrt(pi))\n\tconst float s_c5 = 0.54627421529; // (sqrt(15))/(4*sqrt(pi))\n\n\tconst float s_c_scale = 1.0/0.91529123286551084;\n\tconst float s_c_scale_inv = 0.91529123286551084;\n\n\tconst float s_rc2 = 1.5853309190550713*s_c_scale;\n\tconst float s_c4_div_c3 = s_c4/s_c3;\n\tconst float s_c4_div_c3_x2 = (s_c4/s_c3)*2.0;\n\n\tconst float s_scale_dst2 = s_c3 * s_c_scale_inv;\n\tconst float s_scale_dst4 = s_c5 * s_c_scale_inv;\n\n\tSH3 dst;\n\n\tdst.data[0] = src.data[0];\n\n\t// 9 multiplies\n\tdst.data[1] = ( m11) * src.data[1] + (-m12) * src.data[2] + ( m10) * src.data[3];\n\tdst.data[2] = (-m21) * src.data[1] + ( m22) * src.data[2] + (-m20) * src.data[3];\n\tdst.data[3] = ( m01) * src.data[1] + (-m02) * src.data[2] + ( m00) * src.data[3];\n\n\t// 48 multiplies\n\t// Sparse matrix multiply\n\tfloat sh0 =  src.data[4+3] + src.data[4+4] + src.data[4+4] - src.data[4+1];\n\tfloat sh1 =  src.data[4+0] + s_rc2*src.data[4+2] +  src.data[4+3] + src.data[4+4];\n\tfloat sh2 =  src.data[4+0];\n\tfloat sh3 = -src.data[4+3];\n\tfloat sh4 = -src.data[4+1];\n\n\t// Rotations.  R0 and R1 just use the raw matrix columns\n\tfloat r2x = m00 + m01;\n\tfloat r2y = m10 + m11;\n\tfloat r2z = m20 + m21;\n\n\tfloat r3x = m00 + m02;\n\tfloat r3y = m10 + m12;\n\tfloat r3z = m20 + m22;\n\n\tfloat r4x = m01 + m02;\n\tfloat r4y = m11 + m12;\n\tfloat r4z = m21 + m22;\n\n\t// dense matrix multiplication one column at a time\n\t\n\t// column 0\n\tfloat sh0_x = sh0 * m00;\n\tfloat sh0_y = sh0 * m10;\n\tfloat d0 = sh0_x * m10;\n\tfloat d1 = sh0_y * m20;\n\tfloat d2 = sh0 * (m20 * m20 + s_c4_div_c3);\n\tfloat d3 = sh0_x * m20;\n\tfloat d4 = sh0_x * m00 - sh0_y * m10;\n\t\n\t// column 1\n\tfloat sh1_x = sh1 * m02;\n\tfloat sh1_y = sh1 * m12;\n\td0 += sh1_x * m12;\n\td1 += sh1_y * m22;\n\td2 += sh1 * (m22 * m22 + s_c4_div_c3);\n\td3 += sh1_x * m22;\n\td4 += sh1_x * m02 - sh1_y * m12;\n\t\n\t// column 2\n\tfloat sh2_x = sh2 * r2x;\n\tfloat sh2_y = sh2 * r2y;\n\td0 += sh2_x * r2y;\n\td1 += sh2_y * r2z;\n\td2 += sh2 * (r2z * r2z + s_c4_div_c3_x2);\n\td3 += sh2_x * r2z;\n\td4 += sh2_x * r2x - sh2_y * r2y;\n\n\t// column 3\n\tfloat sh3_x = sh3 * r3x;\n\tfloat sh3_y = sh3 * r3y;\n\td0 += sh3_x * r3y;\n\td1 += sh3_y * r3z;\n\td2 += sh3 * (r3z * r3z + s_c4_div_c3_x2);\n\td3 += sh3_x * r3z;\n\td4 += sh3_x * r3x - sh3_y * r3y;\n\n\t// column 4\n\tfloat sh4_x = sh4 * r4x;\n\tfloat sh4_y = sh4 * r4y;\n\td0 += sh4_x * r4y;\n\td1 += sh4_y * r4z;\n\td2 += sh4 * (r4z * r4z + s_c4_div_c3_x2);\n\td3 += sh4_x * r4z;\n\td4 += sh4_x * r4x - sh4_y * r4y;\n\n\t// extra multipliers\n\tdst.data[4+0] = d0;\n\tdst.data[4+1] = -d1;\n\tdst.data[4+2] = d2 * s_scale_dst2;\n\tdst.data[4+3] = -d3;\n\tdst.data[4+4] = d4 * s_scale_dst4;\n\n\treturn dst;\n}\n\nSH3 ScaleSHBands(SH3 sh, float dcScale, float linearScale, float quadraticScale)\n{\n    SH3 result = sh;\n    \n    result.data[0] *= dcScale;\n    \n    result.data[1] *= linearScale;\n    result.data[2] *= linearScale;\n    result.data[3] *= linearScale;\n    \n    result.data[4] *= quadraticScale;\n    result.data[5] *= quadraticScale;\n    result.data[6] *= quadraticScale;\n    result.data[7] *= quadraticScale;\n    result.data[8] *= quadraticScale;\n    \n    return result;\n}\n\nSH3 RotateZH(SH3 sh, vec3 d)\n{    \n    float dcScale = sh.data[0] * 3.54491;\n    float linearScale = sh.data[2] * 2.04665;\n    float quadraticScale = sh.data[6] * 1.58533;\n    \n    return ScaleSHBands(SH3Evaluate(d), dcScale, linearScale, quadraticScale);\n}\n\nSH3 ConvolveCos(SH3 sh)\n{\n    float dcScale = 1.0 * kPi;\n    float linearScale = 2.0 / 3.0 * kPi;\n    float quadraticScale = 1.0 / 4.0 * kPi;\n    return ScaleSHBands(sh, dcScale, linearScale, quadraticScale);\n}\n\nSH3Color ConvolveCos(SH3Color sh)\n{\n    float dcScale = 1.0 * kPi;\n    float linearScale = 2.0 / 3.0 * kPi;\n    float quadraticScale = 1.0 / 4.0 * kPi;\n    \n    SH3Color result;\n    result.r = ScaleSHBands(sh.r, dcScale, linearScale, quadraticScale);\n    result.g = ScaleSHBands(sh.g, dcScale, linearScale, quadraticScale);    \n    result.b = ScaleSHBands(sh.b, dcScale, linearScale, quadraticScale);\n    return result;\n}\n\nSH3Color GetRadianceSH()\n{\n    SH3Color shColor;\n    \n    shColor.r.data[0] = 0.22351;\n    shColor.r.data[1] = 0.00609654;\n    shColor.r.data[2] = -0.146317;\n    shColor.r.data[3] = 0.0640137;\n    shColor.r.data[4] = 0.0;\n    shColor.r.data[5] = 0.0039353;\n    shColor.r.data[6] = 0.0078706;\n    shColor.r.data[7] = -0.0157412;\n    shColor.r.data[8] = -0.0039353;\n\n    shColor.g.data[0] = 0.13647;\n    shColor.g.data[1] = 0.00372241;\n    shColor.g.data[2] = -0.0781706;\n    shColor.g.data[3] = 0.0297793;\n    shColor.g.data[4] = 0.00480561;\n    shColor.g.data[5] = -0.00720841;\n    shColor.g.data[6] = 0.0024028;\n    shColor.g.data[7] = -0.00720841;\n    shColor.g.data[8] = -0.00961121;\n\n    shColor.b.data[0] = 0.17163;\n    shColor.b.data[1] = 0.00234072;\n    shColor.b.data[2] = -0.0936289;\n    shColor.b.data[3] = 0.0374516;\n    shColor.b.data[4] = 0.00604372;\n    shColor.b.data[5] = -0.00906558;\n    shColor.b.data[6] = 0.00302186;\n    shColor.b.data[7] = -0.00906558;\n    shColor.b.data[8] = -0.0120874;    \n    \n    return shColor;\n}\n\n///////////////////////////////////////////////////////////////////////\n// Scene\n///////////////////////////////////////////////////////////////////////\nvec3 GetBentCone()\n{\n    // define this in SH space\n    float theta = iTime * 0.2;//(sin(iTime * 0.1) * 0.5 + 0.5) * kPi;\n    float phi = -iTime * 1.5; //sqr(cos(iTime * 0.5)) * kPi;\n    \n    vec3 dir;\n    dir.x = sin(theta) * cos(phi);\n    dir.y = sin(theta) * sin(phi);\n    dir.z = cos(theta);\n    \n    return dir;\n/*\n    return normalize(vec3((sin(iTime)*0.5 + 0.5)*2.0, 0, 1));\n*/\n}\n\nScene Scene_Setup()\n{\n    vec3 objCenter = vec3(0, 2, 0);\n    Scene scene;\n\n    scene.sphere.center = objCenter;\n\tscene.sphere.radius = 1.3;\n\n    // bent cone dir\n    vec3 bentConeDir = GetBentCone();\n    float bentConeLength = 1.8;\n    \n    scene.cylinder.a = objCenter;\n    scene.cylinder.b = scene.cylinder.a + bentConeDir * bentConeLength;\n    scene.cylinder.radius = 0.05;   \n    \n    return scene;\n}\n\nbool Scene_RayTrace(Scene scene, Ray r, inout HitRecord hitRecord)\n{\n    float xmin = kInf;\n    \n    // for each Sphere s\n\tSphere s = scene.sphere;\n    {\n        float x = RaySphereIntersect(r, s, 0.0);\n        if (x > 0.0 && x < xmin)\n        {\n            xmin = x;\n            \n            vec3 p = r.origin + x * r.dir;\n            vec3 n = normalize(p - s.center);\n            vec3 t = normalize(cross(kWorldUp, n));\n            vec3 b = normalize(cross(n, t));\n            n = normalize(cross(t, b));\n            hitRecord.geomType = kGeomType_Sphere;\n            hitRecord.p = p;\n            hitRecord.t = t;\n            hitRecord.b = b;\n            hitRecord.n = n;\n        }\n    }\n    \n    // for each Cylinder c\n    Cylinder c = scene.cylinder;\n    {                \n        vec4 cylResult = cylIntersect(r.origin, r.dir, c.a, c.b, c.radius);\n        if (cylResult.x > 0.0 && cylResult.x < xmin)\n        {\n            xmin = cylResult.x;\n        \n            vec3 p = r.origin + xmin * r.dir;\n            hitRecord.geomType = kGeomType_Cylinder;\n            hitRecord.p = p;\n        }    \n    }\n    \n    \n    return (xmin < kInf);\n}\n\n///////////////////////////////////////////////////////////////////////\n// Closest Hit Shader\n///////////////////////////////////////////////////////////////////////\nvec3 ClosestHit(HitRecord hitRecord, Scene scene)\n{\n    // bent cone dir visualization\n    if (hitRecord.geomType == kGeomType_Cylinder)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    \n    vec3 n = hitRecord.n;\n    \n    SH3 dirEval = SH3Evaluate(n);\n    \n    vec3 bentConeDir = GetBentCone();\n    \n    // visibility\n    float alpha = radians(60.0);//(cos(iTime) * 0.5 + 0.5) * kPi;// * 0.5;\n    SH3 shVis = SH3ProjectCone(alpha);    \n    //SH3 shVis = ProjectSmoothCone(alpha);\n    \n    // rotate visibility to direction of bentCone\n    shVis = RotateZH(shVis, bentConeDir);\n    //shVis = SH3Rotate(shVis, rotationAlign(bentConeDir, vec3(0,0,1)));\n\n    // radiance    \n    SH3Color shRadiance = GetRadianceSH();\n    \n    SH3Color shMaskedRadiance;\n    shMaskedRadiance.r = SH3Product(shRadiance.r, shVis);\n    shMaskedRadiance.g = SH3Product(shRadiance.g, shVis);\n    shMaskedRadiance.b = SH3Product(shRadiance.b, shVis);\n    \n    // irradiance\n    SH3Color shIrrad = ConvolveCos(shMaskedRadiance);        \n    \n    vec3 result;\n    result.r = max(SH3Dot(dirEval, shIrrad.r), 0.0);\n    result.g = max(SH3Dot(dirEval, shIrrad.g), 0.0);\n    result.b = max(SH3Dot(dirEval, shIrrad.b), 0.0);\n    \n    return result;\n}\n\nRay Ray_Setup(vec2 screenCoord)\n{\n\tvec2 uv = screenCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n        \n    Ray r;\n    r.origin = vec3(0.0);\n    r.dir = toSHSpace(normalize(vec3(uv.x, uv.y, 1.0))); // this is in SH space\n    return r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray r = Ray_Setup(fragCoord);       \n\n    Scene scene = Scene_Setup();\n\n    // default is sky color\n    vec3 radiance = vec3(0.392, 0.584, 0.929);\n    \n    HitRecord hitRecord;\n    if (Scene_RayTrace(scene, r, hitRecord))\n    {        \n\t\tradiance = ClosestHit(hitRecord, scene);\n        \n        // so we can see better\n        //radiance *= 3.0;\n\t}\n    \n    fragColor.rgb = LinearToGammaSrgb(radiance);\n    fragColor.a = 1.0;\n}","name":"Image","description":"","type":"image"}]}