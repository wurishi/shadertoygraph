{"ver":"0.1","info":{"id":"3tc3W8","date":"1577000774","viewed":74,"name":"Ray March SDF 2","username":"wetzecam","description":"Second attempt at Ray Marching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 camStart = vec3(0.0,0.0 ,-40.0);\n\nfloat depth= 0.25;\n\nvec3 lightColor = vec3(1.0);\n\nfloat ambientStrength = 0.001;\nfloat specStrength = 0.75;\nfloat epsilon = 0.005;\nint MAX_STEPS = 100;\n\nfloat smin(float a, float b, float k){\n\tfloat ex = exp2(-a*k) + exp2(-b*k);\n    return -log2(ex) / k;\n}\nfloat interSDF(float a, float b){return max(a,b);}\nfloat unionSDF(float a, float b){return smin(a,b, 10.0);}\nfloat diffSDF(float a,  float b){return max(a,-b);}\n\nfloat sphereSDF(vec3 p, vec3 R, float r){\n    return length(p-R) - r;\n}\nfloat rectSDF(vec3 p, vec3 R, vec3 r){\n    vec3 q = abs(p-R) - r;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}//vec3(1.0, 0.5, 0.75)\nfloat cylSDF(vec3 p, vec3 R){return 1.0;}\n\nvec3 R = vec3(0.5);\nvec3 r = vec3(0.0, 0.0,0.0);\n\nfloat sceneSDF(vec3 p){\n    p.x = p.x-floor(p.x);\n    p.y = p.y-floor(p.y);\n    p.z = p.z-floor(p.z);\n    return sphereSDF(p, R, 0.25);\n}\n\nvec3 estNormal(vec3 p){\n    float nx = sceneSDF(vec3(p.x + epsilon, p.y, p.z)) - sceneSDF(vec3(p.x - epsilon, p.y, p.z));\n    float ny = sceneSDF(vec3(p.x, p.y + epsilon, p.z)) - sceneSDF(vec3(p.x, p.y - epsilon, p.z));\n    float nz = sceneSDF(vec3(p.x, p.y, p.z + epsilon)) - sceneSDF(vec3(p.x, p.y, p.z - epsilon));\n    return normalize(vec3(nx,ny,nz));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 cam = camStart + vec3(iTime/1.5,iTime/2.5,iTime/5.0);\n    \n    vec3 light = vec3(-1.0, -0.5, 0.5*cos(0.0));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)/2.0 - 0.25;\n    uv.x = 1.75*uv.x;\n    \n    //vec3 ray = (view * normalize(vec4(uv.xy, depth,0.0))).xyz;\n    //ray = ray / abs(length(ray));\n    vec3 ray = normalize(vec3(uv.xy, depth));\n    \n    depth = 0.0;\n    float minDist = 100.0;\n    for(int i=0; i<MAX_STEPS; i++){\n        float dist = sceneSDF(cam + depth*ray);\n        \n        if(dist < epsilon){\n            vec3 p = cam + depth*ray;\n            vec3 n = estNormal(p);\n            vec3 lightDir = normalize(p - light);\n            \n            vec3 ambient = ambientStrength * lightColor;\n            float diff = max(dot(n,lightDir), 0.0);\n            vec3 diffuse = diff * lightColor;\n            \n            vec3 reflectDir = reflect(lightDir, n);\n            float spec = pow(max( dot(ray,reflectDir), 0.0), 32.0);\n            vec3 specular = spec * lightColor * specStrength;\n            \n            vec3 col = vec3(0.5, 0.0, 0.5);//0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n            \n            vec3 result = (specular + ambient + diffuse) * col;\n            \n    \t\t// Output to screen\n    \t\tfragColor = vec4(result,1.0);\n            return; \n        }\n        \n        if(dist < minDist) minDist = dist;\n        \n        depth += dist;\n        \n    }\n    \n\n    // Time varying pixel color\n    vec3 col = cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    col =  cos(2.0*minDist-.70*iTime+vec3(0,2,4));\n    col=vec3(0.1);\n\n    // Output to screen\n    fragColor = vec4(col.xyz, 0.0);\n}","name":"Image","description":"","type":"image"}]}