{"ver":"0.1","info":{"id":"XtcSRr","date":"1477593169","viewed":394,"name":"Multiplication Tables","username":"Patapom","description":"Based on Mathologer episode https://www.youtube.com/watch?v=qhbuKbxJsk8","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["circle","modulo","multiplication"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This shows the multiplication table modulo 200 represented as lines connecting points\n//\ton the unit circle, as explained in the Mathologer video https://www.youtube.com/watch?v=qhbuKbxJsk8\n//\n// I also inverted the positions outside the unit disk to reflect the inside so the look\n//\tis even more interesting :D\n//\n// EDIT: Fixed smoothstep not working with singularity when start and end angles are both 0 (obviously gave a 0/0 NaN)\n//\nconst float\tTWOPI = 6.283185307179586476925286766559;\n    \nconst float\tMODULO = 200.0;\t// Amount of subdivisions of the circle\n\nvec3 ComputeInnerColor( vec2 _uv, float _mul ) {\n\n    float\tisOnLine = 0.0;\n    \n\tvec2\tscStart, scEnd;\n\n\t// Compute start and end anglse based on multiplier\n\tfloat\tdStartAngle = TWOPI / MODULO;\n\tfloat\tdEndAngle = _mul * dStartAngle;\n\tfloat\tstartAngle = dStartAngle;\n\tfloat\tendAngle = dEndAngle;\n\n    for ( float i=1.0; i < MODULO; i++ ) {\n        // Compute start and end position on the unit circle, forming a line\n        scStart.x = sin( startAngle );\n        scStart.y = cos( startAngle );\n        scEnd.x = sin( endAngle );\n        scEnd.y = cos( endAngle );\n        \n        // Compute line normal\n        vec2\tnormal = normalize( vec2( scEnd.y - scStart.y, scStart.x - scEnd.x ) );\n        \n        // Compute distance to line\n        vec2\tdelta = _uv - scStart;\n        float\torthoDistance = abs( dot( delta, normal ) );\n        \n        // Check if the current position is on the line or not\n        isOnLine += smoothstep( 0.005, 0.0, orthoDistance );\n        \n        startAngle += dStartAngle;\n        endAngle += dEndAngle;\n    }\n\n    return vec3( 1.0 - clamp( isOnLine, 0.0, 1.0 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2\tR = iResolution.xy;\n    vec2\tuv = ( 2. * fragCoord - R ) / R.y;\n    \nuv *= 2.0 + sin( iTime );\n    \n    float\tmul = 1.0 + 99.0 * (1.0 - cos( 0.02 * iTime ));\n\n    float\tradius = length( uv );\n//\tfloat\tD = radius < 1. ? 1. :  1. / (radius * radius);\n    float\tD = mix( 1.0, 1.0 / (radius*radius), smoothstep( 0.95, 1.0, radius ) );\t// Smoother joint between regular and reciprocal space\n\tfragColor = vec4( ComputeInnerColor( D*uv, mul ), 1.0 );\n}\n\n","name":"Image","description":"","type":"image"}]}