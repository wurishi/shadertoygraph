{"ver":"0.1","info":{"id":"XtByWW","date":"1555429561","viewed":143,"name":"XRaymarching","username":"Aeless","description":"Raymarching test.. HOORAY","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 64\n#define EPSILON 0.001\n#define DISTANCE_BIAS 0.7\n\nfloat fmod(float a, float b) { if(a<0.0) { return b - mod(abs(a), b); } return mod(a, b); }\n\nfloat Scene_Sphere(in vec3 rayPosition, in vec3 position, in float radius)\n{\n\treturn length(rayPosition - position) - radius;\n}\n\nvec2 Scene(in vec3 rayPosition)\n{\n    float displacement = sin(5.0 * (rayPosition.x + iTime / 3.0)) * sin(5.0 * rayPosition.y + iTime / 3.0) * sin(5.0 * rayPosition.z) * 0.25;\n    \n    vec3 tmpRayPosition = rayPosition;\n    // tmpRayPosition.x = fract(rayPosition.x + 0.5) - 0.5;\n    // tmpRayPosition.z = fmod(rayPosition.z + 1.0, 2.0) - 1.0;\n    \n    // tmpRayPosition.y += sin(rayPosition.x + iTime) * 0.35;\n    // tmpRayPosition.y += cos(rayPosition.z + iTime);\n    \n    float distance = Scene_Sphere(rayPosition, vec3(cos(iTime * 1.2), sin(iTime * 0.97), 1.0), 0.8);\n\tfloat materialID = 1.0;\n    \n    // float distance2 = Scene_Sphere(rayPosition, vec3(0, 0.5 * abs(sin(iTime*3.8)) + 1.0, 5.0), 0.5);\n\t// float materialID2 = 2.0;\n    \n    /*\n    vec3 spherePosition = rayPosition;\n    spherePosition.x = fract(spherePosition.x + 0.5) - 0.5;\n    spherePosition.z = fmod(spherePosition.z + 1.0, 2.0) - 1.0;\n    spherePosition.y += sin(rayPosition.x + iTime) * 0.35;\n    spherePosition.y += cos(rayPosition.z + iTime);\n    \n    float distance2 = Scene_Sphere(spherePosition, vec3(0.0, 0.5, 1.0), 0.15);\n\tfloat materialID2 = 2.0;\n\t\n        \n    if(distance2 < distance)\n    {\n\t\tdistance = distance2;\n        materialID = materialID2;\n    } \n\t*/\n    \n    return vec2(distance + displacement, materialID);\n}\n\nvec2 Raymarch(in vec3 position, in vec3 direction)\n{\n    float totalDistance = NEAR_CLIPPING_PLANE;\n    for(int i = 0 ; i < NUMBER_OF_MARCH_STEPS ; ++i)\n    {\n        vec2 result = Scene(position + direction * totalDistance);\n        if(result.x < EPSILON)\n        {\n            return vec2(totalDistance, result.y);\n        }\n        totalDistance += result.x * DISTANCE_BIAS;\n        if(totalDistance > FAR_CLIPPING_PLANE)\n        {\n            break;\n        }\n    }\n    return vec2(FAR_CLIPPING_PLANE, 0.0);\n}\n\nvec3 GetNormal(vec3 rayHitPosition, float smoothness)\n{\t\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= Scene(rayHitPosition + dn.xyy).x - Scene(rayHitPosition - dn.xyy).x;\n\tn.y\t= Scene(rayHitPosition + dn.yxy).x - Scene(rayHitPosition - dn.yxy).x;\n\tn.z\t= Scene(rayHitPosition + dn.yyx).x - Scene(rayHitPosition - dn.yyx).x;\n\treturn normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cameraPosition = vec3(0, 1.0, -2.5);\n    vec3 direction = normalize(vec3(uv, 2.5));// - cameraPosition);\n    \n    vec3 lightDirection = normalize(vec3(0.0, 1.0, -0.5));\n    vec3 lightDiffuseColor = vec3(1.4, 1.2, 0.7);\n    vec3 lightAmbientColor = vec3(0.2, 0.45, 0.6);\n    \n    vec2 result = Raymarch(cameraPosition, direction);\n    \n    float fog = pow(1.0 / (1.0 + result.x), 0.45);\n    \n    vec3 materialColor = vec3(0.1, 0.1, 0.1);\n    \n    if(result.y == 1.0)\n    {\n        materialColor = vec3(1.0, 0.50, 0.25);\n    }\n    if(result.y == 2.0)\n    {\n       \tmaterialColor = vec3(0.7, 0.7, 0.7);\n    }\n          \n    vec3 intersection = cameraPosition + direction * result.x;\n    vec3 normal = GetNormal(intersection, 0.01);\n    float diffuse = dot(lightDirection, normal);\n    //diffuse = diffuse * 0.5 + 0.5;\n    diffuse = max(0.0, diffuse);\n    vec3 R = 2.0 * dot(lightDirection, normal) * normal - lightDirection;\n    float specular = pow(max(dot(-direction, R), 0.0), 32.0);\n    vec3 diffuseLit = materialColor * (diffuse * lightDiffuseColor + lightAmbientColor) + specular;\n    fragColor = vec4(diffuseLit, 1.0) * fog;\n\n}","name":"Image","description":"","type":"image"}]}