{"ver":"0.1","info":{"id":"lf3fWn","date":"1732912040","viewed":50,"name":"Pythagoras tree animation","username":"Majong562","description":"Pythagoras tree","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fractal","tree","recursive"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.14159265359;\nfloat blur = 0.01;\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define rotate(uv, a) (uv) * rot(a)\n#define rotateAround(uv, pos, a) (uv - pos) * rot(a) + pos\n#define branch(uv, p, s, a) rectangle(uv, p, s, a) + rectangle(uv, p, s, -a)\n\nfloat rectangle(in vec2 uv, vec2 pos, vec2 size, float angle) {\n    uv = rotate(uv - pos, angle);\n    vec2 res = smoothstep(blur, 0., abs(uv - vec2(0., size.y / 2.)) - size / 2.);\n    return res.x * res.y;\n}\n\nfloat rect(in vec2 uv, vec2 pos, vec2 size, float angle) {\n    uv = rotate(uv - pos, angle);\n    return 1. - pow(smoothstep(length(max(2. * abs(uv - vec2(0., size.y / 2.)) - size, 0.)), 0., blur / 4.), 1.5);\n}\n\n\nfloat d[10];\nfloat tree(in vec2 uv, vec2 pos, vec2 size, float angle, int deep) {\n    for (int i = 0; i < 10; i++) { d[i] = 0.; }\n    float result = rectangle(uv, pos, size, 0.);\n    pos += vec2(0., size.y);\n    size *= 0.75;\n    result += branch(uv, pos, size, angle);\n    for (int i = 0; d[0] != 2.;) {\n        if (i < deep && d[i] == 0.) {\n            pos += rotate(vec2(0., size.y), angle);\n            uv = rotateAround(uv, pos, -angle);\n\n            size *= 0.75;\n            result += branch(uv, pos, size, angle);\n            i++;\n        } else if (i < deep && d[i] == 1.) {\n            pos += rotate(vec2(0., size.y), -angle);\n            uv = rotateAround(uv, pos, angle);\n\n            size *= 0.75;\n            result += branch(uv, pos, size, angle);\n            i++;\n        } else {\n            size /= 0.75;\n            if (d[i] == 0.) {\n                uv = rotateAround(uv, pos, angle);\n                pos -= rotate(vec2(0., size.y), angle);\n            } else if (d[i] == 2.) {\n                uv = rotateAround(uv, pos, -angle);\n                pos -= rotate(vec2(0., size.y), angle);\n            }\n            d[i - 1] += 1.;\n            d[i] = 0.;\n            i--;\n        }\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.y;\n    float time = 0.15 + pow(sin(0.35 * iTime), 2.) / 5.;\n    float result = 0.;\n    result += tree(uv, vec2(iResolution.x / iResolution.y / 2., 0.15), vec2(0.02, 0.22), PI * time, 7);\n    fragColor = vec4(1. - result);\n}\n","name":"Image","description":"","type":"image"}]}