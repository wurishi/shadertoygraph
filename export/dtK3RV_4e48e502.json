{"ver":"0.1","info":{"id":"dtK3RV","date":"1684330264","viewed":144,"name":"Love You Mrs Luüòò","username":"Worzfan","description":"Ê∞∏ËøúÁà±‰Ω†ÂìüËÄÅÂ©Üüòò‚Äî‚Äî2023.5.20","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["kirby","520","luqiuxia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_MARCHING_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define PRECISION 0.001\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n \nfloat hash( float n )    // in [0,1]\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x ) // in [0,1]\n{\n    vec3 p = floor(2.*x);\n    vec3 f = fract(2.*x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat fbm( vec3 p )    // in [0,1]\n{\n\t\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f;\n}\n// --- End of Created by inigo quilez\n\nfloat snoise( in vec3 x ) // in [-1,1]\n{ return 2.*noise(x)-1.; }\n\nfloat sfbm( vec3 p )      // in [-1,1]\n{\n\t\n    float f;\n    f  = 0.5000*snoise( p ); p = m*p*2.02;\n    f += 0.2500*snoise( p ); p = m*p*2.03;\n    f += 0.1250*snoise( p ); p = m*p*2.01;\n    f += 0.0625*snoise( p );\n    return f;\n}\nfloat smin( float a, float b, float k )//https://www.desmos.com/calculator/vf5vzm9lks?lang=zh-CN\n{\n    float h = max(k - abs(a-b),0.);//float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return min(a,b) - h*h/(k*4.);//return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smax( float a, float b, float k )//https://www.desmos.com/calculator/vf5vzm9lks?lang=zh-CN\n{\n    return -smin(-a,-b,k);\n}\n\nmat2 rotmat(float a)\n{\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nfloat sdElipsoid(vec3 pos, vec3 rad)//p‰ª£Ë°®pos-cen\n{\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);//https://iquilezles.org/articles/distfunctions/    \n    return k0*(k0-1.)/k1;//Ê§≠ÁêÉ‰ΩìË∑ùÁ¶ªÂú∫ÂÖ¨Âºè\n}//reference:https://www.shadertoy.com/view/tdS3DG\n//Ë∑ùÁ¶ªÂú∫ËÆ°ÁÆóÁöÑÊòØÂà∞Ë°®Èù¢ÁöÑË∑ùÁ¶ªÔºåÂú®Ë°®Èù¢‰∏ä‰∏∫0ÔºåÂú®Ë°®Èù¢ÂÜÖ‰∏∫Ë¥üÊï∞ÔºåÂú®Ë°®Èù¢Â§ñ‰∏∫Ê≠£Êï∞„ÄÇ\n\nvec4 sdElipsoid_2(vec3 pos, vec3 rad)\n{\n    float k0 = length(pos/rad);\n    float k1 = length(pos/rad/rad);   \n    float d = k0*(k0-1.)/k1;\n    return vec4(pos,d);\n}\n\n\nfloat arm(in vec3 pos)\n{\n    \n    pos.x=abs(pos.x);\n    \n    //pos.xz = pos.xz*rotmat(-0.65);\n    vec3 rad = vec3(1.5)*vec3(0.11,0.06,0.06);\n    vec3 cen = vec3(0.12,1.15,0.0);//\n    vec3 ab = pos-cen;\n    ab.xy = rotmat(-1.4)*ab.xy;\n    float d = sdElipsoid(ab,rad);    \n    return d;\n}\nfloat eye(in vec3 pos)\n{\n    \n    pos.x=abs(pos.x);\n    \n    vec3 rad = vec3(1.57)*vec3(0.0285,0.058,0.0285);\n    vec3 cen = vec3(0.048,1.07,0.20);\n    vec3 ep = pos -cen;\n    ep .yz = rotmat(3.44)*ep.yz;\n    float d = sdElipsoid(ep,rad); \n    return d;\n}\nfloat eye2(in vec3 pos)\n{\n    \n    pos.x=abs(pos.x);\n    \n    vec3 rad = vec3(0.64)*vec3(0.021,0.047,0.028);\n    vec3 cen = vec3(0.055,1.12,0.22);\n    vec3 ep = pos -cen;\n    ep .yz = rotmat(3.44)*ep.yz;\n    float d = sdElipsoid(ep,rad); \n    return d;\n}\nfloat cheek(in vec3 pos)\n{\n    \n    pos.x=abs(pos.x);\n    \n    vec3 rad = vec3(1.53)*vec3(0.03,0.025,0.03);\n    vec3 cen = vec3(0.10,0.99,0.20);\n    vec3 ep = pos -cen;\n    ep .yz = rotmat(3.44)*ep.yz;\n    float d = sdElipsoid(ep,rad); \n    return d;\n}\n\nfloat footPlane(vec3 pos,float y)\n{\n    \n    \n    float d = pos.y - y;\n   \n    return d;\n}\n\nfloat foot(in vec3 pos)\n{\n    pos.x=abs(pos.x);    \n    //pos.xz = pos.xz*rotmat(-0.65);\n    vec3 rad = vec3(1.4)*vec3(0.0775,0.09,0.12);\n    vec3 cen = vec3(0.13,0.705,-0.01);\n    vec3 fp = pos - cen;\n    fp .xz = rotmat(3.45)*fp.xz;\n    float d = sdElipsoid(fp,rad); \n    float d3 = footPlane(pos,0.69);\n    d = smax(-d3,d,0.08);\n    return d;\n    \n}\n\n\nfloat mouth(in vec3 pos)\n{\n    vec3 cen = vec3(.0,0.97+8.*pos.x*pos.x,0.19);\n    \n    \n    float d = sdElipsoid(pos-cen,vec3(0.95)*vec3(0.075,0.060,0.075));   \n    \n    return d;//+ 0.5*abs(.09*y); \n}\nfloat tongue(in vec3 pos)\n{\n    vec3 cen = vec3(.0,0.96,0.168);\n    vec3 rad = vec3(-1.5)*vec3(0.081,0.05,0.105);\n    vec3 tp = pos - cen;\n    tp.yz = rotmat(-1.80)*tp.yz;\n    float d = sdElipsoid(tp,rad); \n    \n    return d;\n}\n//float eye_highlight\nfloat heart2(in vec3 pos)\n{\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + pos.y/25.0), 4.0 );\n    pos *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    vec3 p1 = pos;\n    float p2 = pos.x-(0.0);    \n    vec3 cen = vec3(-.08,.6,-0.05);\n    p1 -= cen;\n    p1.xy = rotmat(-3.9)*p1.xy;\n    p1.x  = abs(p1.x);\n    float h1 = sdElipsoid(p1, vec3(4.)*vec3 (0.3,0.15,0.09));    \n    h1 = smax(-p2,h1,0.2);\n    vec3 p3 = pos;\n    vec3 cen2 = vec3(.08,0.6,-0.05);\n    p3 -= cen2;\n    p3.xy = rotmat(3.9)*p3.xy;\n       \n    float h3 = sdElipsoid(p3, vec3(4.)*vec3 (0.3,0.15,0.09));    \n    h3 = smax(p2,h3,0.2);\n    \n    float h4 = smin(h3,h1,0.2);\n    return h4;\n}\n\nfloat heart(in vec3 pos)\n{\n    float ani = pow( 0.5+0.5*sin(6.28318*iTime + pos.y/25.0), 4.0 );\n    pos *= 1.0 - 0.2*vec3(1.0,0.5,1.0)*ani;\n    vec3 p1 = pos;\n    float p2 = pos.x-(0.0);    \n    vec3 cen = vec3(-.08,1.35,-0.05);\n    p1 -= cen;\n    p1.xy = rotmat(-3.9)*p1.xy;\n    p1.x  = abs(p1.x);\n    float h1 = sdElipsoid(p1, vec3(1.1)*vec3 (0.3,0.15,0.09));    \n    h1 = smax(-p2,h1,0.12);\n    vec3 p3 = pos;\n    vec3 cen2 = vec3(.08,1.35,-0.05);\n    p3 -= cen2;\n    p3.xy = rotmat(3.9)*p3.xy;\n       \n    float h3 = sdElipsoid(p3, vec3(1.1)*vec3 (0.3,0.15,0.09));    \n    h3 = smax(p2,h3,0.12);\n    \n    float h4 = smin(h3,h1,0.08);\n    return h4;\n}\nvec2 sdKirby(in vec3 pos)//Ê∑ªÂä†id\n{\n    pos *= vec3(.8);\n    float t = 0.5;//fract(iTime);\n    float y = 4.*t*(1.-t);    \n    float wave = .5+.5*sin(iTime*5.);\n    pos.y += 1.;\n    pos.y *= 1.+.2 * wave;\n    pos.y -= 1.;\n    pos.xz *= 1.-.1 * wave;\n    pos.z = pos.z-0.2*sin(iTime);\n    vec3 cen = vec3(0.,y, 0.);//‰∫åÊ¨°ÂáΩÊï∞‰Ωú‰∏∫yËΩ¥ÁßªÂä®\n    \n    float sy =0.5 + 0.5*y;\n    float sz = 1.0/sy; \n    vec3 rad = vec3(0.25,0.255*sy,0.255*sz);\n    \n    vec3 q = pos - cen;\n    //q.yz = vec2(dot(u,q.yz),dot(v,q.yz));\n    float d = sdElipsoid(q,rad);\n    \n    //d += 0.0005*sin(q.y*120.);\n    //d2_2 = rotmat(0.1);\n    //d =smax(d,-d2_2,0.008);\n    \n    //arm\n    float d3 = arm(pos);\n    d = smin(d,d3,0.015);\n    //mouth\n    //float d4_4 = sdElipsoid(pos-vec3());\n    float d4 = mouth(pos);    \n    float d5 = smax(d4,d,0.005);\n    d = smax(-d4,d,0.004);\n    vec2 res = vec2(d,2.0); \n    \n    float d10 = heart(pos)-0.0015;\n    if(d10<d)\n    {\n        res = vec2(d10,2.5);\n    }\n    //foot\n    float d6 = foot(pos);\n    \n    if(d6<d)\n    {\n        res = vec2(d6,3.0);\n    }\n    //d = smin(d6,d,0.08);\n    float d7 = tongue(pos);\n    if(d7<d)\n    {\n        res = vec2(d7,4.0);\n    }\n    d = min(d,d7);\n    \n    float d2 = eye(pos);\n    if(d2<d)\n    {\n        res = vec2(d,5.);\n    }\n    float d8=eye2(pos);\n    if(d8<d)\n    {\n        res = vec2(d,6.);\n    }\n    float d9 = cheek(pos);\n    if(d9<d)\n    {\n        res = vec2(d,7.);\n    }\n    \n    \n    \n    //res.x = 0.0005*sin(q.y*160.);\n    return res;\n}\n\n/*float bounceKirby(in vec3 pos){\n    float t = fract(iTime);\n    float y = 4.*t*(1.-t);    \n    float d = sdKirby(pos-vec3(0.,y,0.));\n    return d;\n}*/\n\n\nfloat sdPlane(vec3 p){\n    float d;\n    //p.x = abs(p.x);\n    //p.z = p.z + 0.6*iTime;\n    vec3 qos;\n    qos.x = abs(qos.x);\n    qos = vec3(mod(p.x-1.25,5.)-1.2,p.y+0.2*sin(iTime),mod(p.z+1.5,3.)-1.5);\n    \n    float fh = 0.55 + 0.1*(sin(1.8*p.x)+sin(1.8*p.z));\n    float d2 = heart2(qos-vec3(0.6,0.-1.*sin(iTime),0.+0.5*sin((iTime))));\n    \n    d = p.y - fh;\n    d = smin(d,d2,0.3);\n    return d;\n}\n\nvec2 map(vec3 p)\n{\n    \n    vec2 d1 = sdKirby(p);\n    float d2 = sdPlane(p) + 0.015*sfbm(p);\n    return (d2<d1.x) ? vec2(d2,1.0):d1;\n}\n\nvec3 calcuNormal(vec3 p){\n    vec2 e = vec2(1.0, -1.0) * 0.00005; // epsilon\n    \n    return normalize(\n      e.xyy * map(p + e.xyy).x +\n      e.yyx * map(p + e.yyx).x +\n      e.yxy * map(p + e.yxy).x +\n      e.xxx * map(p + e.xxx).x);                     \n}\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.16*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat castShadow(in vec3 ro,vec3 rd)//soft shadow\n{\n    float res = 1.;\n    float t = 0.001;\n    for(int i = 0; i < MAX_MARCHING_STEPS;i++)\n    {\n        vec3 pos = ro + t*rd;\n        float h = map(pos).x;\n        res = min(res,16.*h/t);\n        \n        if(h <0.0001)break;\n        t += t;\n        \n        if(t>20.)break;\n        \n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec2 rayMarch(vec3 ro,vec3 rd)\n{\n    float m = -1.0;//mÊåá‰ª£materialÁöÑid\n    float depth = MIN_DIST;//0.0\n    \n    for (int i = 0; i < MAX_MARCHING_STEPS;i++){\n        vec3 p = ro + depth* rd;\n        vec2 d = map(p);//‰Ωø‰πãÂâçËøõ‰∏Ä‰∏™Âà∞ÊúÄËøëË°®Èù¢ÁöÑË∑ùÁ¶ª        \n        m = d.y;\n        if(d.x < PRECISION )break;\n        depth += d.x;\n        if(depth > MAX_DIST)break;\n    }\n    if(depth > MAX_DIST) m = -1.0;//Âï•ÈÉΩÊ≤°ÊíûÂà∞ÔºåÊòæÁ§∫ËÉåÊôØËâ≤\n    return vec2(depth,m);\n}\n\nmat3 camera(vec3 camera_pos,vec3 look_at_point)\n{\n    vec3 ta = look_at_point;//look at point\n    vec3 ww = normalize(ta-camera_pos);//camera direction\n    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.)));//camera right\n    vec3 vv = normalize(cross(uu,ww));//camera up    \n    mat3 camera_mat = mat3(uu,vv,-ww);//ÂÆö‰πâÁ∫¶ÂÆöÔºåÂíåÊïôÁ®ã‰∏≠xÁöÑÂÆö‰πâÊúâÁÇπÂá∫ÂÖ•\n    \n    return camera_mat;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1. to 1.)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/max(iResolution.y,iResolution.z);\n    vec2 p = uv;      \n    //vec3 ro = vec3(0.,0.,1.5);//camera pos ÁîªÂ∏ÉÂêéÈù¢2‰∏™Âçï‰Ωç    \n    float an = 10.*iMouse.x/iResolution.x;//0.4*iTime;\n    vec2 an_y = 10.*iMouse.xy/iResolution.xy;\n    vec3 ta = vec3(0.,1.,0.+0.2*sin(iTime));//look at point\n    vec3 ro = ta + vec3(1.8*sin(an),0.25*an_y.y,1.8*cos(an));//camera pos\n    vec3 ww = normalize(ta-ro);//camera direction\n    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.)));//camera right\n    vec3 vv = normalize(cross(uu,ww));//camera up    \n    //vec3 rd = normalize(vec3(p,-1.5));//ÊúÄÂéüÂßãÁöÑrdÔºåuvÂä†‰∏äzËΩ¥-1.5ÁöÑÂàÜÈáèÔºå‰πüÁõ∏ÂΩì‰∫é‰ªé(0.,0.,1.)Â∞ÑÂá∫ÂÖâÁ∫ø\n    vec3 rd =normalize(0.05*ta + normalize(p.x*uu+p.y*vv + 1.8*ww));//Á≠â‰∫éÁõ∏Êú∫Áü©Èòµ‰πò‰ª•ÂéüÂßãrd\n    //vec3 rd = 0.05*ta+normalize(camera(ro,ta) * normalize(vec3(p,-1.8)));    \n    vec3 col = vec3(0.4,0.75,1.)-0.7*rd.y; //Â¢ûÂä†Â§©Á©∫Ê∏êÂèò,Ë∂ä‰∏äÂ§©Ë∂äÊöóÔºå\n    //Áî±‰∫érdÊòØÂçï‰ΩçÂêëÈáèÔºåÊâÄ‰ª•ÊåáÂêë‰∏§‰æßyÁöÑÂàÜÈáè‰ºöÊØî‰∏≠Èó¥Â∞è\n    col = mix(col,vec3(0.7,0.75,0.8),clamp(exp(-10.0*rd.y),0.,1.));//mix(x,y,a) return x*(1-a)+a*yÁ∫øÊÄßÊèíÂÄº\n    \n    vec2 dm = rayMarch(ro,rd);\n    \n    \n    if(dm.y > 0.){ //Â¶ÇÊûúÊúâdepthÊ∑±Â∫¶ÂÄº\n    //else{\n        float d = dm.x;\n        vec3 p = ro + rd * d;\n        vec3 normal = calcuNormal(p);   \n        float fresnel = pow(clamp(1. - dot(normal, -rd), 0., 1.), 5.);\n        vec3 rimColor = vec3(0.4, 0.3, 1);\n        vec3 mate = vec3(0.18);\n        if(dm.y <1.5){\n            mate = vec3(1.35)*vec3(0.05,0.1,0.02);\n            float f = -1.+2.*smoothstep(-0.1,0.1,sin(18.*p.x)+sin(18.*p.y)+sin(18.0*p.z)*cos(iTime)*sin(iTime));\n            mate += 0.2*f*vec3(0.06,0.06,0.02);\n            mate += 0.3*fresnel*rimColor;\n        }\n        else if(dm.y <2.5){//body\n            mate = vec3(0.25)*vec3(0.94,0.61,0.76);\n            vec3 f = vec3(1)*(1.-smoothstep(.02,.05,length((p.xy-vec2(0,0.0))*vec2(1.,.48))));\n            mate += fresnel*rimColor;\n            mate += 2.*f;\n        }\n        else if(dm.y <2.9){//heart\n            mate = vec3(0.75)*vec3(0.86,0.08,0.24);\n            mate += 4.*fresnel*rimColor;\n        }\n        else if(dm.y <3.5){//shoe\n            mate = vec3(0.3)*vec3(0.79,0.11,0.21);\n            mate += fresnel*rimColor;\n        }\n        else if(dm.y <4.5){\n            mate = vec3(0.25)*vec3(0.69,0.13,0.13);\n            mate += fresnel*rimColor;\n        }\n        else if(dm.y <5.5){\n           \n            mate = vec3(0.25)*vec3(0.00,0.00,0.00+1./(4.*p.y));\n            mate += fresnel*rimColor;\n        }\n        else if(dm.y <6.5){\n            mate += vec3(0.4)*vec3(1.00,1.00,1.00);\n            mate += fresnel*rimColor;\n        }\n        else if(dm.y < 7.5){\n            mate = vec3(0.75)*vec3(0.86,0.08,0.24);\n        }\n        \n        \n        vec3 sun_dir = normalize(vec3(0.8,0.4,0.2));\n        float sky_dif = clamp(0.5+0.5*dot(normal,vec3(0.,1.,0.)),0.,1.);\n        vec3 new_ray_ori = p+ normal * 0.0016;//ÊµÆ‰∫éË°®Èù¢0.001Ê≥ïÁ∫øÊñπÂêëÁöÑÈò¥ÂΩ±\n        float sun_sha = softshadow(new_ray_ori,sun_dir,0.,256.,32.);//step( rayMarch(new_ray_ori ,sun_dir).y,0.);//float sun_sha = castShadow(new_ray_ori ,sun_dir);//step(a,b)a < b 1;a>b 0;\n        //float fresnel = pow(clamp(1. - dot(normal, -rd), 0., 1.), 6.);\n        float sun_dif = clamp(dot(normal, sun_dir), 0., 1.);\n        float bou_dif = clamp(0.5+0.5*dot(normal,vec3(0.,-1.,0.)),0.,1.);\n        col = normal; //Ê≥ïÁ∫ø col = normal.xxx;...\n        col = mate*vec3(8.,4.5,3.)*sun_dif*sun_sha ;\n        col += mate*vec3(0.5,0.8,0.9)*sky_dif;\n        col += mate*vec3(0.7,0.3,0.2)*bou_dif;//Âú∞Èù¢ÂºπÂ∞Ñbounce\n        //col += vec3(1.)*fresnel;\n        //col = vec3(sun_sha);\n    }\n    \n    col = pow(col,vec3(0.4545));//Ë∞ÉÊï¥gamma\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}