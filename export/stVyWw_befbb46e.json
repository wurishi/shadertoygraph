{"ver":"0.1","info":{"id":"stVyWw","date":"1661882678","viewed":393,"name":"wavy twisty shiny spheres","username":"dsa8","description":"Messing around with ray marching techniques I have seen around here (I don't take credit for any piece of code, it's mostly copied). Fairly new to shader programming any tips tricks critiques are more than welcome :)","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarchglow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdSphere( vec3 p, vec3 pos, float r )\n{\n    return length(p-pos)-r;\n}\n\nfloat map( in vec3 p, inout float glowR, inout float glowI )\n{\n    float d = 0.;\n\n    {\n    vec2 id;\n    float d1;\n    p.x -= iTime*12.;\n    float twistSpeed = .8;\n    p.yz=cos(0.06*p.x+iTime*twistSpeed)*p.yz+sin(0.06*p.x+iTime*twistSpeed)*vec2(p.z,-p.y); // twist\n\n    vec3 q = p;\n    \n    vec3 c = vec3(2., 0.0, 2.);\n    p.x = mod(q.x+0.5*c.x,c.x)-0.5*c.x; \n    id.x = floor(q.x/2.+0.5);\n    \n    vec3 l = vec3(0.0, 0.0, 4.0);\n    q = p-c*clamp(round(p/c),-l,l);\n    id.y = floor(p.z/2.+0.5);\n\n    d1 = sdSphere(q, vec3(.0, .0, .0), .2); \n    d = d1;\n    \n    // modulate glow\n    //vec2 glowWalkSpeed = vec2(30., 5.);\n    // X WALKS\n    //glowR = floor(mod(id.x, 10.)*.12); // single line\n    //glowR = floor(mod(id.x + floor(iTime*glowWalkSpeed.x), 10.)*.12);\n    //glowR = mod( floor(id.x/2.+0.5), 9.) /7.;\n    //glowR = 1.-mod(id.x + floor(iTime*glowWalkSpeed), 10.)*.1;\n    //glowR = 1.-mod(id.x + iTime*glowWalkSpeed.x, 10.)*.1;\n    // Y WALKS\n    //glowR =mod( floor(id.y - iTime * 8./2.+0.5) - 2., 9.) /7.; \n    //glowR *=floor(mod( floor(id.y + iTime * glowWalkSpeed.y /2.+0.5), 8.) /7.); \n    //glowR *= mod( id.y - iTime , 9. ) / 9. ;\n    //glowR *= (1.-glowR) *4.;\n    \n    // DIAGONAL WALK\n    glowR = floor(mod(id.x+id.y - iTime*40., 5. )/4.5);\n    glowR = mod(id.x+id.y  - iTime*30., 80. )/80.;\n    glowR *= glowR;\n    glowI = 1.0;\n    }\n\n\n    return d;\n}\n   \n//https://www.shadertoy.com/view/3s3GDn\nfloat getGlow(float dist, float radius, float intensity){\n\treturn pow(radius / max(dist, 0.01), intensity);\t\n}\n    \n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ro = vec3( .0, .0, 25.9 );\n    vec3 ta = vec3( .0, .0, 26.0 );\n    // camera matrix\n    vec3 ww = -normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n    \n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n        p*=1.6;\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        float glow = 0.;\n        float glowR;\n        float glowI;\n        \n        // raymarch\n        const float tmax = 70.0;\n        float t = 0.0;\n        for( int i=0; i<80; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos, glowR, glowI);\n            \n            glow += getGlow(h, mix(0.0001, 0.004, glowR), 1. ); // mix(0.6, 1.2, glowI)\n            \n            if( h<0.0001 || t>tmax ) break;\n            h*=.5;\n            t += h;\n            \n        }\n        \n        vec3 col;\n        col += glow * vec3(.2, 0.5, .95); // add glow color\n        \n        // background\n        vec2 s = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        float d = length(s-vec2(.0, 3.4))-2.2 + sin(s.x*3.+iTime*.8)*.15;\n        d = min(d, length(s-vec2(.0, -3.4))-2.1 + sin(s.x*2.+(iTime+123.)*.8)*.2);\n        //col = mix(vec3(0.), vec3(1.), d);\n        col += 0.15*mix(vec3(.0,.1,.4), vec3(.02, .15, .6), d);\n\n        \n        col = 1.0 - exp( -col ); // tonemapping\n        col = pow(col, vec3(1.3));\n        // gamma        \n        col = pow(col, vec3(0.4545));\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}