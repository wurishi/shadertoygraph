{"ver":"0.1","info":{"id":"Dl2yzV","date":"1692028509","viewed":72,"name":"Psychology Symbol Ψ","username":"altunenes","description":"Ψ \nI simply used an arcsin function to achieve this shape :) I tried to make it better (visually ) but I gave up for now :love:\n\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["logo","symbol","psychology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265;\n\nvec3 color(float x, vec2 p)\n{\n    vec3 gradient1 = sin(x * PI + vec3(0, 1, 2));\n    vec3 gradient2 = sin(x * PI + vec3(1, 0, 2) + p.y);\n    vec3 gradient3 = sin(x * PI + vec3(2, 1, 0) + p.x);\n    \n    vec3 gradientColor = mix(gradient1, gradient2, 0.5 + 0.5 * sin(iTime + p.y));\n    gradientColor = mix(gradientColor, gradient3, 0.5 + 0.5 * sin(iTime + p.x));\n    \n    return gradientColor * gradientColor;\n}\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 r = iResolution.xy;\n    vec2 p = (I - r * 0.5) / r.y;\n    float scale = -3.0;\n    p *= scale;\n    p.y = -p.y;\n    \n    float l = 2.15;  \n    float s = 1.15; \n    float modifiedX = p.x * abs(p.x);\n    float wingShape = asin(modifiedX);\n    float blendFactor = smoothstep(0.7, 1.0, abs(p.x));\n    wingShape = mix(wingShape, sign(p.x) * PI * 0.5, blendFactor);\n    float wingY = abs(wingShape * l / PI);\n    float distToWing = abs(p.y - wingY);\n    float distToStem = abs(p.x);\n    float shape = min(distToWing, distToStem);\n    if (abs(p.x) < 2.15 && abs(p.y) > s) {\n        shape = 3.1; \n    }\n\n    float phaseDuration = 3.0; \n    float modulationFrequency = (iTime < phaseDuration) ? 20.0 : 3.0;\n    float modulation = sin(modulationFrequency * length(p) + iTime * 2.0);\n    float oscillation = sin(iTime * 2.0 * 3.14159265359 / 10.0); \n    float normalizedOscillation = (oscillation + 1.0) * 0.5;\n    float easedOscillation = smoothstep(0.0, 0.4, normalizedOscillation) * (1.0 - smoothstep(0.6, 1.0, normalizedOscillation));\n    float modulatedValue = mix(0.001, 1.2, easedOscillation);\n    float modulatedShape = shape + modulation * modulatedValue;\n\n    vec3 vibrantCol = color(iTime + modulatedShape * 1.0, p) * 2.0;\n    vibrantCol = vibrantCol / (1.0 + vibrantCol);\n    vec3 bg1 = vec3(0.5, 0.2, 0.7);\n    vec3 bg2 = vec3(0.2, 0.5, 0.7);\n    vec3 bg3 = vec3(0.8, 0.3, 0.4); \n    vec3 bg4 = vec3(0.4, 0.8, 0.5); \n    float hGradient = 1.5 + 0.5 * sin(p.x + iTime * 0.5);\n    float vGradient = 0.5 + 0.5 * sin(p.y + iTime * 0.7);\n    vec3 horizColor = mix(bg1, bg2, hGradient);\n    vec3 vertColor = mix(bg3, bg4, vGradient);\n    vec3 bgColor = mix(horizColor, vertColor, 0.5);\n\n    float edgeThickness = 0.01;\n    float edgeSmooth = smoothstep(0.0, edgeThickness, 0.1 - modulatedShape);\n    vec3 finalCol = mix(bgColor, vibrantCol, edgeSmooth);\n\n    O = vec4(finalCol, 1.0);\n}\n\n\n/* first version (black bg and simple red psi)\nvoid mainImage(out vec4 O, vec2 I)\n{\n    vec2 r = iResolution.xy;\n    vec2 p = (I - r * 0.5) / r.y;\n    float scale = -3.0;\n    p *= scale;\n    p.y = -p.y;\n    float l = 2.15;  \n    float s = 1.15; \n    float modifiedX = p.x * abs(p.x);\n    float wingShape = asin(modifiedX);\n    float blendFactor = smoothstep(0.7, 1.0, abs(p.x));\n    wingShape = mix(wingShape, sign(p.x) * 3.14159 * 0.5, blendFactor);\n    float wingY = abs(wingShape * l / 3.14159);\n    float distToWing = abs(p.y - wingY);\n    float distToStem = abs(p.x);\n    float shape = min(distToWing, distToStem);\n    if (abs(p.x) < 2.15 && abs(p.y) > s) {\n        shape = 3.1; \n    }\n    O = shape < 0.1 ? vec4(1.0, 0.0, 0.0, 0.0) : vec4(0.0, 0.0, 0.0, 1.0);\n}*/","name":"Image","description":"","type":"image"}]}