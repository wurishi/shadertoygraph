{"ver":"0.1","info":{"id":"7sVczK","date":"1655230632","viewed":104,"name":"Retard3D","username":"Amirk","description":"Retardation also distorts the \"image\" of an object. Whiter box represents the true position. Purple box is how an observer would see it due to classical retardation effects. Relativistic dilations are not included. Move with mouse.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["speedoflight","retardation"],"hasliked":0,"parentid":"fsKyzh","parentname":"Retarded position demo"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER 1000.\n#define MAX_DIST 1000.\n#define  SURF  .05\n#define  BOX 0\n\n//visual parameters:\nvec3 RO= vec3(100.,20.,0.);\nvec3 SIZE= vec3(10,10,10); \n\n\n\nfloat sdBox(vec3 p , vec3 s){\n p= abs(p)-s;\nreturn length(max(p,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\n\nfloat getDist(vec3 p, float time){\n    vec2 pos= getPos(center.xz, time);\n    float dist= sdBox(p.xzy-vec3(pos,0), SIZE);\n    \n    vec2 truePos=getPos(center.xz, t);\n    float trueDist= sdBox(p.xzy-vec3(truePos,0),SIZE);\n\n    return .9*(1.-speed)*min(trueDist, dist);\n}\n\n/*\nfloat getDist2(vec3 p){\n    float distRetarded= length(p-retardedSphere)-size;\n    float distTrue= length(p-sphere)-size;\n\n    return min(distTrue, distRetarded);\n}*/\n\nvec3 getRayDir(vec2 uv, vec3 ro,vec3 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt-ro);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    vec3 i= ro+f*zoom+uv.x*r+uv.y*u;\n    return normalize( i-ro);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float time, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec3 p= ro+dO*rd;\n      \n      float dS=side*getDist(p,time-dO/c); //we look back in time as we march further away\n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec3 p, vec3 dir, float time){\n  vec2 e= vec2(0.01,0);\n   float d=getDist(p,time);\n   vec3 n = d-vec3(getDist(p- e.xyy, time-dot(dir,e.xyy)/c),getDist(p- e.yxy,time-dot(dir,e.yxy)/c),getDist(p- e.yyx,time-dot(dir,e.yyx)/c));\n   \n   return normalize(n);\n}\n\n\n\nint getMaterial(vec3 p){\n    vec2 truePos=getPos(center.xz, t);\n    float trueDist= sdBox(p.xzy-vec3(truePos,0), SIZE);\n    if(trueDist<20.*SURF)\n        return 0;\n    else return 1;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = (iMouse.xy-.5)/iResolution.xy;\n\n\n    vec3 col = vec3(0);\n\n    float zoom= 1.;\n    vec3 lookAt = vec3(0);\n    \n    //ro.xz*=rot(PI/2.);\n\n    if(sign(iMouse.z)>0.){\n        RO.xy*=rot(-(m.y-.5)*PI);\n        RO.x+=-(m.x-.5)*200.;\n    }else{\n      //  ro.yz*=rot(sin((t*.5-.5)*PI)*.5-PI*.2);\n    }\n    \n    \n\n    vec3 rd= getRayDir(uv, RO, lookAt,zoom);\n    \n    \n    float d= RayMarch(RO, rd, t,1.);\n    \n    vec3 p=RO;\n    \n     if(d<MAX_DIST){ //if we hit the object:\n          p= p+ d*rd;\n          vec3 n= getNormal(p,rd,t-d/c);\n      \n          float dif= dot(n, normalize(vec3(1,2,0)))*.5+.5;\n          if(getMaterial(p)==BOX)\n              col.rgb=vec3(1);\n          else\n              col.rb=vec2(.8);\n          col*=dif;          \n         //second raymarch inside the box \n         float d2= RayMarch(p-20.*SURF*n, rd,t-d/c,-1.);\n         \n         p=p+d2*rd;\n         vec3 n2= getNormal(p,rd,t-(d+d2)/c);         \n         vec3 col2=vec3(1,0.5,0.5)*(dot(n2, normalize(vec3(1,2,0)))*.5+.5);\n                \n          \n         col=mix(col,col2,.5);\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define t iTime\n#define PI 3.14159265359\nconst float speed= 0.8; //as a fraction of the speed of light\nconst float radius=50.; //radius of the circle\nconst float c=100.; //speed of information and light\nfloat freq = c/radius*speed; //freq*radius ought to be less than c\nconst int iterations=100; //accuracy to calculate the retarded position.\n\n//vec3 retardedSphere= radius* vec3(1,0,0);\nvec3 center= radius* vec3(1,0,0);\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec2 getPos(vec2 p0, float time){\n    return rot(freq*time)*p0;\n}\n\n\nvec2 retardedPos(vec2 uv, vec2 p0, float time){\n    float upper =time;\n    float lower =0.;\n    float tr = time*.5;\n    int n=0;\n    vec2 retardedP=getPos(p0, tr);\n    while(n<iterations){\n        retardedP=getPos(p0, tr);\n        float dist= length(uv-retardedP);\n        if(dist/c>(time-tr)){\n            upper = tr;\n            tr=(upper+lower)*.5;\n        }else{\n            lower= tr;\n            tr=(upper +lower)*.5;\n        }if(tr<.001){\n           tr=0.;\n           break;\n        }\n        retardedP=getPos(p0, tr);\n        n++;\n    }\n    \n    return retardedP;\n}","name":"Common","description":"","type":"common"}]}