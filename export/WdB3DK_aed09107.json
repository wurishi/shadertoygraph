{"ver":"0.1","info":{"id":"WdB3DK","date":"1549956487","viewed":136,"name":"Inverse transform","username":"rory618","description":"Find the inverse of a transformation with stochastic routing. Could work a lot better by combining with a first order iterative approximate at each step of stochastic routing, and to store the top n closest points so that overlapping points don't compete","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["warp","inverse","stochastic","routing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Stochastic Routing\" by rory618. https://shadertoy.com/view/Xd3BW8\n// 2019-02-12 06:43:21\n\nvoid mainImage( out vec4 o, in vec2 i )\n{\n\tvec2 uv = i/R.xy;\n    o = vec4(0);\n    \n    int seed = IHash(F^IHash(int(i.x)^IHash(int(i.y))));\n    \n    for(int j = 0; j < 10; j++){//Rendering pass is just the last layer pass\n        \n        vec4 r = rand4(seed);\n        r.zw = randn(r.zw);\n        vec2 id;\n        \n        //Split the screen into four groups, and sample from different layers of the\n        //process. This is to make it clear what the effect of each layer is.\n        id = texture(iChannel1,(i+r.zw)/R.xy).zw;\n\n            \n        //if(id >= 0.){\n            vec2 t = getParticle(id,R,iFrame-4);\n\t\t\t//draw particles by signed distance function\n            //It is very convinient that everything is still done by distance function\n            //so far. In fact \n            //#define length(x) abs(20.-length(x)) \n            //in common will convert this shader to drawing circles instead.\n            //this time just use all 10 iterations for the output\n        \tfloat d = length(i-t*R.xy);\n        \n        \n        \tvec4 c = texture(iChannel2, id);\n            if(d<4. && R.y/2.>length((id-.5)*R.xy)) o += c;\n        //}\n    }\n    o /= o.w;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define F iFrame\n\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn float(a) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n//Convert uniform random to normal\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(r.x));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n\n// --- pseudo perlin noise 3D\n\nint MOD = 1;  // type of Perlin noise\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define hash31(p) fract(sin(dot(p,vec3(127.1,311.7, 74.7)))*43758.5453123)\nfloat noise3(vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p); f = f*f*(3.-2.*f); // smoothstep\n\n    float v= mix( mix( mix(hash31(i+vec3(0,0,0)),hash31(i+vec3(1,0,0)),f.x),\n                       mix(hash31(i+vec3(0,1,0)),hash31(i+vec3(1,1,0)),f.x), f.y), \n                  mix( mix(hash31(i+vec3(0,0,1)),hash31(i+vec3(1,0,1)),f.x),\n                       mix(hash31(i+vec3(0,1,1)),hash31(i+vec3(1,1,1)),f.x), f.y), f.z);\n\treturn   MOD==0 ? v\n\t       : MOD==1 ? 2.*v-1.\n           : MOD==2 ? abs(2.*v-1.)\n                    : 1.-abs(2.*v-1.);\n}\n\nfloat fbm3(vec3 p) {\n    float v = 0.,  a = .5;\n    mat2 R = rot(.37);\n\n    for (int i = 0; i < 1; i++, p*=2.,a/=2.) \n        p.xy *= R, p.yz *= R,\n        v += a * noise3(p);\n\n    return v/.5;\n}\n\nvoid warp(inout vec2 x, int iFrame){\n    \n    float time = float(iFrame)/60.;\n    float t = 3.*time, K = 1.1, S = 2.;\n    float k = K * max(1.-length(x),0.);\n    x += k * vec2( fbm3(vec3(S*x, t)), fbm3(vec3(S*x+15., t)) ) / S;\n    \n}\n\n// -------------------------------------\n\n//This function defines the location of each particle. The only change here is that now particles are defined by a random location in uv\n//space, and the location is where that pixel maps to under the transformation.\nvec2 getParticle(vec2 id, vec3 R, int iFrame){\n    \n    id = (id - .5)*1.5*R.xy/R.y;\n    \n    warp(id, iFrame);\n    \n    id = id/2./R.xy*R.y + .5;\n    \n    return id;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    \n    int seed = IHash(F^IHash(int(i.x)^IHash(int(i.y))));\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec2 r = rand2(seed);\n        seed = IHash(seed);\n        vec2 id = r.xy;\n        vec2 t = getParticle(id,R,iFrame);//Uniformly sample one of the particles\n\n        float dp = length(i-t*R.xy);\n        //compute the length to see if it is closer than the current champion\n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.xy = id;//Output the nearest points ID\n        }\n    }\n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = rand4(seed);\n        seed = IHash(seed);\n        //Sample using a shrinking normal distribution\n        vec2 id = texture(iChannel1,(i+randn(r.zw)*64.)/R.xy).xy;\n        vec2 t = getParticle(id,R,iFrame-1);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.zw = id;\n        }\n    }    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    \n    int seed = IHash(F^IHash(int(i.x)^IHash(int(i.y))));\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = rand4(seed);\n        seed = IHash(seed);\n        vec2 id = texture(iChannel0,(i+randn(r.zw)*32.)/R.xy).zw;\n        vec2 t = getParticle(id,R,iFrame-1);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.xy = id;\n        }\n    }  \n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = rand4(seed);\n        seed = IHash(seed);\n        //Sample using a shrinking normal distribution\n        vec2 id = texture(iChannel1,(i+randn(r.zw)*16.)/R.xy).xy;\n        vec2 t = getParticle(id,R,iFrame-2);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.zw = id;\n        }\n    }    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    \n    int seed = IHash(F^IHash(int(i.x)^IHash(int(i.y))));\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = rand4(seed);\n        seed = IHash(seed);\n        vec2 id = texture(iChannel0,(i+randn(r.zw)*8.)/R.xy).zw;\n        vec2 t = getParticle(id,R,iFrame-2);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.xy = id;\n        }\n    }  \n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = rand4(seed);\n        seed = IHash(seed);\n        //Sample using a shrinking normal distribution\n        vec2 id = texture(iChannel1,(i+randn(r.zw)*4.)/R.xy).xy;\n        vec2 t = getParticle(id,R,iFrame-3);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.zw = id;\n        }\n    }    \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 o, in vec2 i )\n{\n    o = vec4(-1);\n    \n    int seed = IHash(F^IHash(int(i.x)^IHash(int(i.y))));\n    \n    \n    //Set the current best distance to infinity ish\n    float d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = rand4(seed);\n        seed = IHash(seed);\n        vec2 id = texture(iChannel0,(i+randn(r.zw)*2.)/R.xy).zw;\n        vec2 t = getParticle(id,R,iFrame-3);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.xy = id;\n        }\n    }  \n    //Repeat for each getParticle->x->y->z->w\n    d=1e9;\n    for(int j = 0; j < 10; j++){\n        vec4 r = rand4(seed);\n        seed = IHash(seed);\n        //Sample using a shrinking normal distribution\n        vec2 id = texture(iChannel1,(i+randn(r.zw)*1.)/R.xy).xy;\n        vec2 t = getParticle(id,R,iFrame-4);\n\n        float dp = length(i-t*R.xy);\n        \n        if(abs(dp)<abs(d)){\n            d = dp;\n            o.zw = id;\n        }\n    }    \n}","name":"Buffer D","description":"","type":"buffer"}]}