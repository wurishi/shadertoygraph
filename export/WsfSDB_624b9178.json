{"ver":"0.1","info":{"id":"WsfSDB","date":"1552070166","viewed":179,"name":"SonOfAnotherRaymarchPractice","username":"bignobody","description":"Second generation of my practice raymarcher. Last one wasn't doing more than 1 reflection depth properly and shadows were backwards. Probably still doing lots of things incorrectly, but progress! Thanks as always to iq and Jamie Wong for their tutorials.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_LIGHTS 1\n#define MAX_REFLECTIONS 2\n#define AMBIENT_LIGHT 1.61\n#define NUM_SPHERES\t6\n\nvec3 colours[9] = vec3[](vec3(0.2,0.4,0.6), vec3(0.0,0.6,0.13), vec3(0.5,0.5,0.55), vec3(0.8,0.7,0.2), vec3(0.18,0.64,0.38), vec3(0.75,0.51,0.1), vec3(0.95,0.41,0.51), vec3(0.3,0.4,0.8), vec3(0.2,0.6,0.6));\nvec3 speculars[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9), vec3(0.9,0.9,0.9));\nfloat shine[9] = float[](10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0);\nfloat reflectivity[9] = float[](0.4,0.3,0.85,0.65,0.65,0.65,0.75,0.75,0.5);\n\nvec3 intensities[9] = vec3[](vec3(0.9,0.9,0.9),vec3(0.9,0.9,0.9),vec3(0.8,0.8,0.8), vec3(0.4,0.4,0.4), vec3(0.1,0.4,0.8), vec3(0.25,0.51,0.1), vec3(0.35,0.81,0.01), vec3(0.1,0.3,0.4), vec3(0.9,0.9,0.9));\n\n// adapted sdf functions by iq\nfloat sdfSphere(vec3 p, vec3 t, float r)\n{\n\treturn length(p-t)-r;   \n}\nfloat sdfBox( vec3 p, vec3 t, vec3 b )\n{\n  vec3 d = abs(p - t) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\nfloat sdfPlane( vec3 p, vec3 t, vec4 n )\n{\n  // n must be normalized\n  return dot(p-t,n.xyz) + n.w;\n}\nfloat sdfTorus( vec3 p, vec3 tr, vec2 t )\n{\n\tp = p-tr;\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n////////\n\n// objects map\nfloat distanceToClosest(vec3 p, inout int pick)\n{\n    float def = 500.0;\n    float d = sdfPlane(p,vec3(0.0,-2.0,0.0),normalize(vec4(0.0,1.0,0.0,1.0)));\n    pick = 1;\n    \n    if (d > def)\n    {\n      d = def;\n      pick = 0;\n    }\n\n    float so = opUnion( sdfBox(p, vec3(0.0), vec3(4.0,6.0,1.0)), sdfBox(p, vec3(0.0), vec3(1.0,6.0,4.0)) );\n    if (so < d)\n    {\n        pick = 2;\n        d = so;\n    }\n    \n    float offset = 0.0;\n    float offset2 = 0.0;\n    float offsetinc = 6.28318 / float(NUM_SPHERES);\n\t\n\tfor (int s = 0; s < NUM_SPHERES; s ++)\n    {\n        so = sdfSphere(p,vec3(6.5 * cos(iTime+offset),0.75*cos(iTime*offset),6.5 * sin(iTime+offset)),1.0);\n\t\toffset += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n        so = sdfSphere(p,vec3(8.5 * cos(-iTime+offset2),0.95*cos(-iTime*offset2 * 0.33),8.5 * sin(-iTime+offset2)),1.2);\n\t\toffset2 += offsetinc;    \n    \tif (so < d)\n    \t{\n        \tpick = int(mod(float(s),float(6))+3.0);\n        \td = so;\n    \t}\n\n    }\n\n    return d;\n    \n}\n\nvec3 estimateNormal(vec3 p, inout int pick)\n{\n    const float EPSILON = 0.0001;\n return normalize(vec3(\n        distanceToClosest(vec3(p.x + EPSILON, p.y, p.z),pick) - distanceToClosest(vec3(p.x - EPSILON, p.y, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y + EPSILON, p.z),pick) - distanceToClosest(vec3(p.x, p.y - EPSILON, p.z),pick),\n        distanceToClosest(vec3(p.x, p.y, p.z  + EPSILON),pick) - distanceToClosest(vec3(p.x, p.y, p.z - EPSILON),pick)\n    ));   \n}\n\nvec3 getLightPosition(int l)\n{\n\tvec3 lps[6] = vec3[](vec3(-8.0 * cos(iTime * 0.25),3.5,-8.0 * sin(iTime * 0.25)),\n\t\t\t\tvec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,5.5* cos(iTime * 0.5)),\n                vec3(5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 1.3)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 2.7)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 4.5)),\n                vec3(-5.80 * sin(iTime*0.5),-5.5*cos(iTime*0.5)+4.95 ,-5.5* cos(iTime * 0.5)));\n    if (l > 5)\n    {\n        return lps[0];\n    }\n\n    return lps[l];\n}\n// soft shadows from iq's tutorial\nfloat shadowMarch( vec3 lightOrigin, vec3 surfacePoint )\n{\n    vec3 direction = normalize((lightOrigin)-surfacePoint);\n    float blendFactor = 128.18;\n    int pickTarget = 0;\n  \tfloat res = 1.0;\n    float ph = 1e20;\n    float end = distance(lightOrigin, surfacePoint);\n    for( float s=0.0001; s < end; )\n    {\n        vec3 marchStep = lightOrigin + direction * s;\n        float distNow = distanceToClosest(marchStep, pickTarget);\n        if( distNow<0.001)\n            return 0.0;\n        float y = distNow*distNow/(2.0*ph);\n        float d = sqrt(distNow*distNow-y*y);\n        res = min( res, blendFactor*d/max(0.0,s-y) );\n        ph = distNow;\n        s += distNow;\n    }\n    return res; \n}\nvec3 lightSurfacePoint(vec3 eye, vec3 surfacePoint, vec3 surfaceNormal, float ambientLight, int materialPick)\n{\n\tvec3 surfaceColour = vec3(0.0);\n    float shadow = 1.0;\n\t\n    for (int l = 0; l < NUM_LIGHTS; l ++)\n    {\n        vec3 lightPos = getLightPosition(l);\n        vec3 N = surfaceNormal;\n    \tvec3 L = normalize(lightPos - surfacePoint);\n    \tvec3 V = normalize(eye - surfacePoint);\n    \tvec3 R = normalize(reflect(-L, N));\n        \n    \tfloat dotLN = dot(L, N);\n    \tfloat dotRV = dot(R, V);\n    \tvec3 colour = colours[materialPick] * 0.01;\n    \tif (dotLN < 0.0) \n\t\t{\n        \t// Light not visible from this point on the surface\n        \tcolour =  colours[materialPick] * 0.01;\n    \t} \n    \telse if (dotRV < 0.0) \n\t\t{\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        \tcolour = intensities[l] * (colours[materialPick] * dotLN);\n            shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n    \t}\n        else\n        {\n    \t\tcolour = intensities[l] * (colours[materialPick] * dotLN + speculars[materialPick] * pow(dotRV, shine[materialPick]));\n            shadow = min(shadow, shadowMarch(lightPos, -surfacePoint));\n        }\n\n        surfaceColour += colour;//phongLight((colours[materialPick]* shadow *ambientLight), lightSpec[l], 10.7, getLightPosition(l), lightIntensity[l], surfacePoint, normal, eye);\n    }\n\treturn surfaceColour * ambientLight * shadow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 1.0;\n    vec3 lookAt = vec3(0.0,0.5,0.0);\n    vec3 camOrigin = vec3(10.0 * cos(iTime * 0.1),6.5 * cos(iTime * 0.5)+4.2,-10.0 * sin(iTime * 0.1));\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n    \n    // config and work variables\n    int numReflections = MAX_REFLECTIONS;\n    vec3 surfacePoint = vec3(0.0);\n    vec3 col = vec3(0.1,0.3,0.44);\n\n\tfloat marchDistance = 0.0f;\n    vec3 marchVec = camOrigin;\n    int pickTarget = 0;\n    vec3 surfaceNormal = vec3(0.0);\n    \n    const int MAX_STEPS = 256;\n    const float MAX_DISTANCE = 96.0;\n    const float CLOSE_ENOUGH = 0.0001;\n\tconst int MAX_REFLECT_STEPS = 256;\n\tconst float MAX_REFLECT_DISTANCE = 64.0;\n    \n    vec3 marchStep = vec3(0.0);\n   \tfloat distNow = 0.0;\n\n    vec3 colAccum = vec3(0.0);\n  \n    for (int i = 0; i < MAX_STEPS; i ++)\n    {\n        marchStep = marchVec + rayDirection * marchDistance;\n     \tdistNow = distanceToClosest(marchStep, pickTarget);\n        \n        if (distNow <= CLOSE_ENOUGH)\n        {\n            // hit something!\n            surfacePoint = marchStep;\n    \t\tsurfaceNormal = estimateNormal(surfacePoint, pickTarget);\n            \n            colAccum = lightSurfacePoint(camOrigin, surfacePoint, surfaceNormal, AMBIENT_LIGHT, pickTarget);\n\n            vec3 lastDirection = rayDirection;\n            vec3 lastSurfacePoint = surfacePoint;\n            vec3 lastSurfaceNormal = surfaceNormal;\n\t\t\t\n            for(int r = 0; r < numReflections; r ++)\n            {\n\t\t\t\t\n                vec3 reflectOrigin = lastSurfacePoint;\n                vec3 reflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                float reflectDistance = 0.001;\n    \t\t\tvec3 reflectVec = reflectOrigin;\n    \t\t\tvec3 reflectNormal = vec3(0.0);\n    \n        \t\tfloat reflectDist = 0.0;\n                float refMixVal = 0.35;\n\t\t    \tfor (int k = 0; k < MAX_REFLECT_STEPS; k ++)\n    \t\t\t{\n                    // march again from our new origin and accumulate colour from hit materials\n        \t\t\treflectVec = reflectOrigin + reflectDirection * reflectDistance;\n     \t\t\t\treflectDist = distanceToClosest(reflectVec, pickTarget);\n        \n        \t\t\tif (reflectDist <= CLOSE_ENOUGH)\n        \t\t\t{\n\t\t\t\t\t\t// hit something else!\n            \t\t\tlastSurfacePoint = reflectVec;\n    \t\t\t\t\tlastSurfaceNormal = estimateNormal(lastSurfacePoint, pickTarget);\n                        lastDirection = reflectDirection;\n                        colAccum = mix (colAccum, lightSurfacePoint(reflectOrigin, lastSurfacePoint, lastSurfaceNormal, AMBIENT_LIGHT, pickTarget), mix(reflectivity[pickTarget],refMixVal,0.5));\n                \t\trefMixVal = min(0.95, refMixVal+0.1);\n\t\t\t\t\t\t\n                        reflectDistance = 0.001;\n                        reflectDist = 0.0;\n                        reflectOrigin = lastSurfacePoint;\n                \t\treflectDirection = normalize(reflect((lastDirection), lastSurfaceNormal));\n                        break;\n       \t\n        \t\t\t}\n        \t\t\telse\n                    {\n        \t\t\t\treflectDistance += reflectDist;   \n        \n        \t\t\t\tif (reflectDistance >= MAX_REFLECT_DISTANCE)\n        \t\t\t\t{\n            \t\t\t\t// sky colour\n            \t\t\t\t pickTarget = 0;\n        \t\t\t\t\tcolAccum = mix(colAccum, colours[pickTarget] - reflectDirection.y * 0.5, mix(reflectivity[pickTarget],refMixVal,0.5));\n                        \tbreak;\n        \t\t\t\t}\n                    }\n        \n    \t\t\t}\n\n            }\n\n\t\t\tbreak;         \t\n        }\n        else\n        {\n         \tmarchDistance += distNow;   \n        }\n        if (marchDistance >= MAX_DISTANCE)\n        {\n            // sky colour\n        \tpickTarget = 0;\n\t\t\tcolAccum =  colours[pickTarget] - rayDirection.y * 0.5;\n            break;\n        }\n    }\n    \n    col = colAccum;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}