{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n\nfloat SCurve (float x) {\n\t\n    \n    // ---- by CeeJayDK\n\n\t\tx = x * 2.0 - 1.0;\n\t\treturn -x * abs(x) * 0.5 + x + 0.5;\n\t\t\n        //return dot(vec3(-x, 2.0, 1.0 ),vec3(abs(x), x, 1.0)) * 0.5; // possibly faster version\n\t\n\n    \n    \n    // ---- original for posterity\n    \n    // How to do this without if-then-else?\n    // +edited the too steep curve value\n    \n    // if (value < 0.5)\n    // {\n    //    return value * value * 2.0;\n    // }\n    \n    // else\n    // {\n    // \tvalue -= 1.0;\n    \n    // \treturn 1.0 - value * value * 2.0;\n    // }\n}\n\nvec4 BlurH (sampler2D source, vec2 size, vec2 uv, float radius) {\n\n\tif (radius >= 1.0)\n\t{\n\t\tvec4 A = vec4(0.0); \n\t\tvec4 C = vec4(0.0); \n\n\t\tfloat width = 1.0 / size.x;\n\n\t\tfloat divisor = 0.0; \n        float weight = 0.0;\n        \n        float radiusMultiplier = 1.0 / radius;\n        \n        // Hardcoded for radius 20 (normally we input the radius\n        // in there), needs to be literal here\n        \n\t\tfor (float x = -20.0; x <= 20.0; x++)\n\t\t{\n\t\t\tA = texture(source, uv + vec2(x * width, 0.0));\n            \n            \tweight = SCurve(1.0 - (abs(x) * radiusMultiplier)); \n            \n            \tC += A * weight; \n            \n\t\t\tdivisor += weight; \n\t\t}\n\n\t\treturn vec4(C.r / divisor, C.g / divisor, C.b / divisor, 1.0);\n\t}\n\n\treturn texture(source, uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Apply horizontal blur to final output\n\tfragColor = BlurH(iChannel0, iResolution.xy, uv, 20.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n\nfloat SCurve (float x) {\n\t\n    \n\t\tx = x * 2.0 - 1.0;\n\t\treturn -x * abs(x) * 0.5 + x + 0.5;\n\t\t\n        //return dot(vec3(-x, 2.0, 1.0 ),vec3(abs(x), x, 1.0)) * 0.5; // possibly faster version\n\n}\n\nvec4 BlurV (sampler2D source, vec2 size, vec2 uv, float radius) {\n\n\tif (radius >= 1.0)\n\t{\n\t\tvec4 A = vec4(0.0); \n\t\tvec4 C = vec4(0.0); \n\n\t\tfloat height = 1.0 / size.y;\n\n\t\tfloat divisor = 0.0; \n        float weight = 0.0;\n        \n        float radiusMultiplier = 1.0 / radius;\n\n        for (float y = -20.0; y <= 20.0; y++)\n\t\t{\n\t\t\tA = texture(source, uv + vec2(0.0, y * height));\n            \t\n            \tweight = SCurve(1.0 - (abs(y) * radiusMultiplier)); \n            \n            \tC += A * weight; \n            \n\t\t\tdivisor += weight; \n\t\t}\n\n\t\treturn vec4(C.r / divisor, C.g / divisor, C.b / divisor, 1.0);\n\t}\n\n\treturn texture(source, uv);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy; \n    \n    // Apply vertical blur to buffer A\n\tfragColor = BlurV(iChannel0, iResolution.xy, uv, 20.0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"Mtl3Rj","date":"1423449458","viewed":9891,"name":"Pseudo Gaussian Blur","username":"Loadus","description":"Same as the quick linear blur, but this time the blending has a sigmoid curve applied to it, similar to the bell curve used for gaussian. Written for speed, not Quality. : )","likes":63,"published":1,"flags":32,"usePreview":0,"tags":["blur","linear","gaussian","pseudo","quick"],"hasliked":0,"parentid":"","parentname":""}}