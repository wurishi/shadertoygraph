{"ver":"0.1","info":{"id":"XdSyRt","date":"1499090345","viewed":897,"name":"Atmosphere VPT [WIP]","username":"TinyTexel","description":"volume path tracing of an exponentially decaying atmosphere using rejection sampling (Rayleigh scatt only atm)\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys","likes":25,"published":1,"flags":48,"usePreview":0,"tags":["scattering","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The MIT License\n// Copyright © 2019 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\na tiny volume path tracing setup\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\nconst float Pi = 3.14159265359;\n\n#define Time iTime\n#define Frame iGlobalFrame\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nvec3 sRGB_EOTF(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\n/*\nvec3 Tonemap_Unreal(vec3 x) \n{\n\t// https://docs.unrealengine.com/udk/Three/ColorGrading.html\n\t// sRGB_EOTF baked in!\n\treturn x / (x + 0.187) * 1.035;\n}\n*/\n\n// ACES fit by Stephen Hill (@self_shadow)\n// https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl \n\n// sRGB => XYZ => D65_2_D60 => AP1\nconst mat3 sRGBtoAP1 = mat3\n(\n\t0.613097, 0.339523, 0.047379,\n\t0.070194, 0.916354, 0.013452,\n\t0.020616, 0.109570, 0.869815\n);\n\n// AP1 => RRT_SAT\nconst mat3 RRT_SAT = mat3\n(\n\t0.970889, 0.026963, 0.002148,\n\t0.010889, 0.986963, 0.002148,\n\t0.010889, 0.026963, 0.962148\n);\n\n\n// sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT\nconst mat3 ACESInputMat = mat3\n(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3\n(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 Tonemap_ACESFitted(vec3 srgb)\n{\n    vec3 color = srgb * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n\n    return color;\n}\n\nvec3 Tonemap_ACESFitted2(vec3 acescg)\n{\n    vec3 color = acescg * RRT_SAT;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n    //vec2 uv = floor(fragCoord.xy);\n\tvec2 tex = uv0.xy / PixelCount;\n    \n    vec3 col = textureLod(iChannel0, tex, 0.0).rgb;\n    \n    //col = vec3(col.b);\n    \n    col *= exp2(3.0);\n    col = Tonemap_ACESFitted(col);\n    \n    fragColor = vec4(sRGB_EOTF(clamp01(col)), 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The MIT License\n// Copyright © 2019 Mirko Salm\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\na tiny volume path tracing setup\ncamera controls via mouse + shift key\nlight controls via WASD/Arrow keys\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float RcpPi = 1.0 / Pi;\nconst float RcpPi4 = 1.0 / (4.0 * Pi);\nconst float RcpPi2 = 1.0 / (2.0 * Pi);\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaDecode(float x) {return pow(x,      2.2) ;}\nvec2  GammaDecode(vec2  x) {return pow(x, vec2(2.2));}\nvec3  GammaDecode(vec3  x) {return pow(x, vec3(2.2));}\nvec4  GammaDecode(vec4  x) {return pow(x, vec4(2.2));}\n\nfloat GammaEncode(float x) {return pow(x,      1.0 / 2.2) ;}\nvec2  GammaEncode(vec2  x) {return pow(x, vec2(1.0 / 2.2));}\nvec3  GammaEncode(vec3  x) {return pow(x, vec3(1.0 / 2.2));}\nvec4  GammaEncode(vec4  x) {return pow(x, vec4(1.0 / 2.2));}\n\n\n// single iteration of Bob Jenkins' One-At-A-Time hashing algorithm:\n//  http://www.burtleburtle.net/bob/hash/doobs.html\n// suggested by Spatial on stackoverflow:\n//  http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nuint BJXorShift(uint x) \n{\n    x += x << 10u;\n    x ^= x >>  6u;\n    x += x <<  3u;\n    x ^= x >> 11u;\n    x += x << 15u;\n\t\n    return x;\n}\n\n\n// xor-shift algorithm by George Marsaglia\n//  https://www.thecodingforums.com/threads/re-rngs-a-super-kiss.704080/\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint GMXorShift(uint x)\n{\n    x ^= x << 13u;\n    x ^= x >> 17u;\n    x ^= x <<  5u;\n    \n    return x;\n}\n\n// hashing algorithm by Thomas Wang \n//  http://www.burtleburtle.net/bob/hash/integer.html\n// suggested by Nathan Reed:\n//  http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nuint WangHash(uint x)\n{\n    x  = (x ^ 61u) ^ (x >> 16u);\n    x *= 9u;\n    x ^= x >> 4u;\n    x *= 0x27d4eb2du;\n    x ^= x >> 15u;\n    \n    return x;\n}\n\n//#define Hash BJXorShift\n#define Hash WangHash\n//#define Hash GMXorShift\n\n// \"floatConstruct\"          | renamed to \"ConstructFloat\" here \n// By so-user Spatial        | http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// used under CC BY-SA 3.0   | https://creativecommons.org/licenses/by-sa/3.0/             \n// reformatted and changed from original to extend interval from [0..1) to [-1..1) \n//-----------------------------------------------------------------------------------------\n// Constructs a float within interval [-1..1) using the low 23 bits + msb of an uint.\n// All zeroes yields -1.0, all ones yields the next smallest representable value below 1.0. \nfloat ConstructFloat(uint m) \n{\n\tfloat flt = uintBitsToFloat(m & 0x007FFFFFu | 0x3F800000u);// [1..2)\n    float sub = (m >> 31u) == 0u ? 2.0 : 1.0;\n    \n    return flt - sub;// [-1..1)             \n}\n\nvec2 ConstructFloat(uvec2 m) { return vec2(ConstructFloat(m.x), ConstructFloat(m.y)); }\nvec3 ConstructFloat(uvec3 m) { return vec3(ConstructFloat(m.xy), ConstructFloat(m.z)); }\nvec4 ConstructFloat(uvec4 m) { return vec4(ConstructFloat(m.xyz), ConstructFloat(m.w)); }\n\n\nuint Hash(uint  v, uint  r) { return Hash(v ^ r); }\nuint Hash(uvec2 v, uvec2 r) { return Hash(Hash(v.x , r.x ) ^ (v.y ^ r.y)); }\nuint Hash(uvec3 v, uvec3 r) { return Hash(Hash(v.xy, r.xy) ^ (v.z ^ r.z)); }\nuint Hash(uvec4 v, uvec4 r) { return Hash(Hash(v.xy, r.xy) ^ Hash(v.zw, r.zw)); }\n\n// Pseudo-random float value in interval [-1:1).\nfloat Hash(float v, uint  r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec2  v, uvec2 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec3  v, uvec3 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\nfloat Hash(vec4  v, uvec4 r) { return ConstructFloat(Hash(floatBitsToUint(v), r)); }\n\n\nfloat HashFlt(uint   v, uint  r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec2  v, uvec2 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec3  v, uvec3 r) { return ConstructFloat(Hash(v, r)); }\nfloat HashFlt(uvec4  v, uvec4 r) { return ConstructFloat(Hash(v, r)); }\n\nuint HashUInt(float v, uint  r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec2  v, uvec2 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec3  v, uvec3 r) { return Hash(floatBitsToUint(v), r); }\nuint HashUInt(vec4  v, uvec4 r) { return Hash(floatBitsToUint(v), r); }\n\n\nstruct Cam\n{\n\tvec3 Front, Right, Up;\n\tfloat Aspect;\n\tfloat AxisLen;\t\n};\n\nCam NewCam(vec2 ang, float fov, float aspect)\n{\n    Cam cam;\n\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    cam.Front = vec3(cosPhi * cosTheta, \n                              sinTheta, \n                     sinPhi * cosTheta);\n\n    cam.Right = vec3(-sinPhi, 0.0, cosPhi);\n    cam.Up    = cross(cam.Right, cam.Front);\n\n    cam.Aspect = aspect;\n    cam.AxisLen = aspect * tan(Pi05 - fov * 0.5);\n\n    return cam;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front * cam.AxisLen + (cam.Right * tc.x + cam.Up * tc.y);\n    \n    vec3 dir = normalize(imgPos);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n// tc [-1..1]\nvec3 NewRay(Cam cam, vec2 tc, vec2 llp, float S1, vec2 boff, out vec3 glp)\n{\n    tc.x *= cam.Aspect;\n\n    tc += boff;\n    \n    vec3 imgPos = cam.Front + (cam.Right * tc.x + cam.Up * tc.y) / cam.AxisLen;\n    \n    glp = cam.Right * llp.x + cam.Up * llp.y;\n    \n    vec3 dir = normalize(imgPos * S1 - glp);\n\n    return dir;\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\nvoid Intersect_Ray_CubeBackside(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout float t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 ub = (rp - o) * m;\n\t\n\tt = min(ub.x, min(ub.y, ub.z));\t\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\nvoid Intersect_Ray_SphereBackside(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout float t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = min(dot(rp, rp) - sr2, 0.0);\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\t//if(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(max(0.0, D));\n\n\tt = (-b + sqrtD) / a * 0.5;\n}\n/*\nSOURCE: \n\t\"Building an Orthonormal Basis from a 3D Unit Vector Without Normalization\"\n\t\thttp://orbit.dtu.dk/files/126824972/onb_frisvad_jgt2012_v2.pdf\n\t\t\n\t\"Building an Orthonormal Basis, Revisited\" \n\t\thttp://jcgt.org/published/0006/01/01/\n\t\n\t- modified for right-handedness here\n\t\nDESCR:\n\tConstructs a right-handed, orthonormal coordinate system from a given vector of unit length.\n\nIN:\n\tn  : normalized vector\n\t\nOUT:\n\tox\t: orthonormal vector\n\toz\t: orthonormal vector\n\t\nEXAMPLE:\n\tfloat3 ox, oz;\n\tOrthonormalBasis(N, OUT ox, oz);\n*/\nvoid OrthonormalBasisRH(vec3 n, out vec3 ox, out vec3 oz)\n{\n\tfloat sig = n.z < 0.0 ? 1.0 : -1.0;\n\t\n\tfloat a = 1.0 / (n.z - sig);\n\tfloat b = n.x * n.y * a;\n\t\n\tox = vec3(1.0 + sig * n.x * n.x * a, sig * b, sig * n.x);\n\toz = vec3(b, sig + n.y * n.y * a, n.y);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\n// samples hemisphere if s1 [0..1]\nvec3 Sample_Sphere(float s0, float s1)\n{\n    float ang = Pi * s0;\n    float s1p = sqrt(clamp01(1.0 - s1*s1));\n    \n    return vec3(cos(ang) * s1p, \n                           s1 , \n                sin(ang) * s1p);\n}\n\n// s0 [-1..1], s1 [-1..1]\n// samples spherical cap for s1 [cosAng..1]\nvec3 Sample_Sphere(float s0, float s1, vec3 normal)\n{\t \n    vec3 sph = Sample_Sphere(s0, s1);\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * sph.x) + (normal * sph.y) + (oz * sph.z);\n}\n\n// s0 [-1..1], s1 [-1..1]\nvec3 Sample_Hemisphere(float s0, float s1, vec3 normal)\n{\n    vec3 smpl = Sample_Sphere(s0, s1);\n\n    if(dot(smpl, normal) < 0.0)\n        return -smpl;\n    else\n        return smpl;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec2 Sample_Disk(float s0, float s1)\n{\n    return vec2(cos(Pi * s0), sin(Pi * s0)) * sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvoid Sample_Disk(float s0, float s1, out vec2 dir, out float r)\n{\n    dir = vec2(cos(Pi * s0), sin(Pi * s0));\n    \n    r = sqrt(s1);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n    \n    return vec3(d.x, y, d.y);\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_ClampedCosineLobe(float s0, float s1, vec3 normal)\n{\t \n    vec2 d  = Sample_Disk(s0, s1);\n    float y = sqrt(clamp01(1.0 - s1));\n\n    vec3 ox, oz;\n    OrthonormalBasisRH(normal, ox, oz);\n\n    return (ox * d.x) + (normal * y) + (oz * d.y);\n}\n\n// s [-1..1]\nfloat Sample_Triangle(float s) \n{ \n    float v = 1.0 - sqrt(abs(s));\n    \n    return s < 0.0 ? -v : v; \n}\n\n// s [0..1]\nfloat Sample_HenyeyGreensteinPhF(float s, float g)\n{\t\n    if(abs(g) < 0.0001) return s * 2.0 - 1.0;\n\n    float g2 = g * g;\n\n    float t0 = (1.0 - g2) / (1.0 - g + 2.0 * g * s);\n\n    float cosAng = (1.0 + g2 - t0*t0) / (2.0 * g);\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_HenyeyGreensteinPDF(float s0, float s1, float g, vec3 forward)\n{\t\n    float cosTheta = Sample_HenyeyGreensteinPhF(s1, g);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n// s [0..1]\nfloat Sample_SchlickPhF(float s, float k)\n{\t\n    float t0 = 1.0 + k - 2.0 * s;\n    float t1 = 1.0 + k - 2.0 * s * k;\n\n    float cosAng = t0 / t1;\n\n    return cosAng;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_SchlickPDF(float s0, float s1, float k, vec3 forward)\n{\t\n    float cosTheta = Sample_SchlickPhF(s1, k);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\n//(-2 + 4 s + Sqrt[5 - 16 s + 16 s^2])^(1/3)\n// s [0..1]\nfloat Sample_RayleighPhF(float s)\n{\t\n    float t0 = pow(sqrt((s*s - s) * 16.0 + 5.0) + 4.0 * s - 2.0, 1.0/3.0);\n\n    float cosTheta = t0 - 1.0/t0;\n\n    return cosTheta;\n}\n\n// s0 [-1..1], s1 [0..1]\nvec3 Sample_RayleighPDF(float s0, float s1, vec3 forward)\n{\t\n    float cosTheta = Sample_RayleighPhF(s1);\n\n    return Sample_Sphere(s0, cosTheta, forward);\n}\n\nfloat HenyeyGreensteinPhF(float cosTheta, float g)\n{\n\tfloat g2 = g * g;\n\t\n\tfloat t0 = 1.0 - g2;\n\tfloat t1 = 1.0 + g2 - 2.0 * g * cosTheta;\n\t\n\t return t0 * rsqrt(max(0.0, t1*t1*t1));\n\t//return t0 * rsqrt(max(1.0e-32, t1*t1*t1));\n}\n\nfloat HenyeyGreensteinPDF(float cosTheta, float g)\n{\n    return HenyeyGreensteinPhF(cosTheta, g) * RcpPi4;\n}\n\nfloat RayleighPhF(float cosTheta)\n{\n    return cosTheta*cosTheta * 0.75 + 0.75;\n}\n\nfloat RayleighPDF(float cosTheta)\n{\n    return RayleighPhF(cosTheta) * RcpPi4;\n}\n\n\n// https://en.wikipedia.org/wiki/SRGB\nvec3 XYZ_to_sRGB(vec3 xyz)\n{\n    float r = dot(xyz, vec3( 3.2406, -1.5372, -0.4986));\n    float g = dot(xyz, vec3(-0.9689,  1.8758,  0.0415));\n    float b = dot(xyz, vec3( 0.0557, -0.2040,  1.0570));\n    \n    return vec3(r, g, b);\n}\n\n// https://en.wikipedia.org/wiki/Planck%27s_law\n// wavelength l in nm, temperature T in Kelvin, returns radiance\nfloat Blackbody(float l, float T)\n{\n    const float h = 6.626070040e-16;\n    const float k = 1.38064852e-5;\n    const float c = 299792458.0e9;\n    \n    const float o0 = 2e-3 * h * (c * c);\n    const float o1 = h * c / k * 1.442695;\n    \n    float l5 = ((l * l) * (l * l)) * l;\n    \n    return o0 / (l5 * (exp2(o1 / (l * T)) - 1.0));\n}\n\n// Simple Analytic Approximations to the CIE XYZ Color Matching Functions (https://www.shadertoy.com/view/4ttBRB)\n// https://research.nvidia.com/publication/simple-analytic-approximations-cie-xyz-color-matching-functions\nvec3 XYZ10(float l)\n{\n    vec3 xyz;\n\n    xyz.x = 0.4 * exp2(-866.433976 * Pow2(log2(l * 0.000986 + 0.56213)));\n\txyz.x += 1.13 * exp2(-162.19644 * Pow2(log2(l * -0.001345 + 1.799597)));\n    \n\txyz.y = 1.011 * exp2(-1.442695 * Pow2(l * 0.015325 - 8.522368));\n\n\txyz.z = 2.06 * exp2(-22.18071 * Pow2(log2(l * 0.005543 - 1.474501)));\n    \n    return xyz;\n}\n\nvec3 XYZ2(float l)\n{\n    vec3 xyz;\n\n    {\n        float dParam1 = (l-442.0)*((l < 442.0)?0.0624:0.0374);\n        float dParam2 = (l-599.8)*((l < 599.8)?0.0264:0.0323);\n        float dParam3 = (l-501.1)*((l < 501.1)?0.0490:0.0382);\n        xyz.x = 0.362*exp(-0.5*dParam1*dParam1) + 1.056*exp(-0.5*dParam2*dParam2) - 0.065*exp(-0.5*dParam3*dParam3);\n    }\n\n    {\n        float dParam1 = (l-568.8)*((l < 568.8)?0.0213:0.0247);\n        float dParam2 = (l-530.9)*((l < 530.9)?0.0613:0.0322);\n        xyz.y = 0.821*exp(-0.5*dParam1*dParam1) + 0.286*exp(-0.5*dParam2*dParam2);\n    }\n\n    {\n        float dParam1 = (l-437.0)*((l < 437.0)?0.0845:0.0278);\n        float dParam2 = (l-459.0)*((l < 459.0)?0.0385:0.0725);\n        xyz.z = 1.217*exp(-0.5*dParam1*dParam1) + 0.681*exp(-0.5*dParam2*dParam2);\n    }\n\n    return xyz;\n}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\nbool Intersect_Ray_Scene(vec3 pos, vec3 dir, out vec3 n, out float t)\n{\n    vec2 tt;\n    bool hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, /*out:*/ tt) > 0.0;\n    \n    t = tt.x;\n    \n    if(hit)\n    {\n        n = normalize(pos + dir * t);\n    }\n    \n    {\n    \tvec2 tt; vec3 n0, n1;\n\t\tbool hit0 = Intersect_Ray_Cube(pos, dir, vec3(0.0, 1.0, 0.0), vec3(0.01), /*out:*/ tt, n0, n1) > 0.0;\n    \t\n    \tif(hit0 && (!hit || tt.x < t))\n        {\n            hit = true;\n            t = tt.x;\n            n = n0;\n        }\n    }\n    \n    return hit;\n}\n\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_SHIFT 0x10\n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n\n#define KeyBoard iChannel1\n\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\n\n\n#define VarTex iChannel0\n#define OutCol outCol\n#define OutChannel w\n\n#define WriteVar(v, cx, cy) {if(uv0.x - 0.5 == float(cx) && uv0.y - 0.5 == float(cy)) OutCol.OutChannel = v;}\n#define WriteVar4(v, cx, cy) {WriteVar(v.x, cx, cy) WriteVar(v.y, cx, cy + 1) WriteVar(v.z, cx, cy + 2) WriteVar(v.w, cx, cy + 3)}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{     \n    vec2 uv = uv0.xy - 0.5;\n        \n\tvec2 tex = uv0.xy / iResolution.xy;\n    vec2 tex21 = tex * 2.0 - vec2(1.0);\n    \n    vec4 mouseAccu  = ReadVar4(1, 0);\n    vec4 wasdAccu   = ReadVar4(2, 0);\n    float frameAccu = ReadVar (3, 0);\n\n    vec2 ang = vec2(Pi * 0.0, -Pi * 0.25);\n    ang += mouseAccu.xy * 0.008;\n\n    Cam cam = NewCam(ang, Pi * 0.5, iResolution.x / iResolution.y);\n    \n    float cdist = exp2(0.2 + mouseAccu.w * 0.02);\n    vec3 cpos = -cam.Front * cdist;\n    cpos.y += 1.00001;\n\n    #if 1\n    cpos = normalize(cpos) * max(1.00001, length(cpos));\n    #endif\n    \n    float fId = frameAccu * 1.64683 + 0.84377;\n    \n    vec3 pxId  = vec3(frameAccu, uv); \n         pxId *= vec3( 0.76032, 1.47035, 0.92526); \n         pxId += vec3(-0.69060, 0.02293, 0.68109);\n    \n    uint hh = HashUInt(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));\n    \n    {\n        vec2 off;\n        {\n        \tfloat h0 = Hash(fId, 0xAF609A13u);\n        \tfloat h1 = Hash(fId, 0xE0ABC868u);\n        \n        \t//off = vec2(h0, h1) * 0.5;\n        \toff = vec2(Sample_Triangle(h0), Sample_Triangle(h1));\n        }\n             \n        #if 1\n        {\n            // bloom kernel:\n        \tfloat h0 = HashFlt(hh, 0xE77CA8EFu);\n        \tfloat h1 = HashFlt(hh, 0x86AF71D2u);\n        \th1 = clamp01(h1 * 0.5 + 0.5);\n            \n        \toff += AngToVec(h0 * Pi) * Pow2(log2(1.0 - Pow2(h1))) * 0.25;\n        }\n        #endif\n        \n        tex21 = ((uv.xy + 0.5) + off) / iResolution.xy * 2.0 - vec2(1.0);\n    }\n    \n\n    vec3 rdir = NewRay(cam, tex21);\n \n    \n    vec2 lightAng = vec2(Pi * 0., 0.12 * Pi);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.02; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.02;    \n    \n    float sunCA = cos(0.5 * 0.53 * (Pi / 180.0));\n    \n    vec3 light = AngToVec(lightAng);\n    vec3 lightp = light;\n    {\n        float h0 = HashFlt(hh, 0x9E2355B4u);\n        float h1 = HashFlt(hh, 0xDC305E12u);\n        h1 = clamp01(h1 * 0.5 + 0.5);\n        \n        h1 = mix(sunCA, 1.0, h1);\n        \n        lightp = Sample_Sphere(h0, h1, light);\n    }\n    \n    float wl, wl0;\n    {\n        float h0 = HashFlt(hh, 0x7F1489B8u);\n              h0 = clamp01(h0 * 0.5 + 0.5);\n        \n        wl0 = h0;\n        wl = mix(360.0, 720.0, h0);\n    }\n    \n    //light = vec3(0.0, 1.0, 0.0);\n    float pot = 1.0;\n    float val = 0.0;\n    \n    float E = Blackbody(wl, 5778.0);\n    \n    bool scattered = false;\n    float t = -1.0; vec2 tt = vec2(0.0);\n    vec3 n0, n1;\n    vec3 pos = cpos;\n    vec3 dir = rdir;\n\tfloat ffp = 0.0;\n    \n    float g = 0.0;// asymmetry parameter\n    \n    float ER = 6360.0;//5.8e-6 13.5e-6 33.1e-6 | 1<->6360-6420 = 60km | 8km  8/60= 1/7.5=0.133..\n    vec3 sigma_s3 = vec3(5.8e-3, 13.5e-3, 33.1e-3) * ER;\n    //vec3 gAlbedo3 = vec3(0.1, 0.3, 1.00) * 0.1;\n    //sigma_s3 = vec3(1.8e-3, 2.5e-3, 33.1e-3) * ER;\n    //sigma_s3.xy = sigma_s3.zz;\n    //sigma_s3 = vec3(1.8e-6, 3300.5e-6, 3300.1e-6) * ER;\n    \n    float sigma_e = 100.1e-3 * ER;// extinction coefficient; reciprocal of photon mean-free-path \n    \t  sigma_e = Pow2(Pow2(1.0/(wl * 0.007))) * ER;\n    //sigma_e = mix(0.5, 1.0, Pow4(wl0)) * ER;\n    \t  //sigma_e = max(1e-6, dot(sigma_s3, colW0));\n    \t  //sigma_e = max(1e-6, 1.0/dot(1.0/sigma_s3, colW0));\n    float rcpHR = ER / 7.64;\n    //rcpHR = ER / 20.0;\n    //float gAlbedo = clamp01(dot(gAlbedo3, colW0));\n    \n   // float ah = 6420.0/6360.0 - 1.0;\n    float ar = Pow2(1.0 + 80.0/ER);\n    bool hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), ar, /*out:*/ tt) > 0.0;\n    bool inside = SqrLen(pos) < ar;\n    \n    if(inside) tt.x = 0.0;\n    \n    if(inside || hit)\n    {\n        pos += dir * tt.x;\n        \n        float phase = 0.0;\n        \n        for(float i = 0.0; i < 4.0; ++i)\n        {\n\t\t\t// sample free flight path\n            {\n                float h0 = HashFlt(hh, 0x4EF175A5u);\n                h0 = clamp01(h0 * 0.5 + 0.5);\n                h0 = max(0.0001, h0);\n\n                #if 0\n                if(tex.x < 0.5){\n                h0 = Hash(pxId, uvec3(0xB8D3E97Cu, 0x736D370Fu, 0xA7D00135u));   \n        \t\th0 = clamp01(h0 * 0.5 + 0.5);\n\t\t\t\th0 = fract(h0 + 1.61803398875 * i);\n                    h0 = max(0.0001, h0);}\n                #endif\n                \n                ffp = -log(h0) / sigma_e;\n            }\n\n\t\t\tvec3 n;\n            bool hit = Intersect_Ray_Scene(pos, dir, /*out:*/ n, tt.x);\n            \n            float mt = min(t, tt.x);\n            \n            if(hit && tt.x < ffp)\n            {\n                #if 1\n                pot = 0.0; break;\n                #else\n                pos += dir * tt.x;\n\n                pos += n * 0.0001;\n\n                phase = clamp01(dot(n, lightp)) * RcpPi;\n                //pot *= 0.2;\n                pot *= gAlbedo;\n                \n                float h0 = HashFlt(hh, 0x874C40D4u);\n                float h1 = HashFlt(hh, 0xF27BD7E1u);\n                h1 = clamp01(h1 * 0.5 + 0.5);\n\n                dir = Sample_ClampedCosineLobe(h0, h1, n);\n                \n                scattered = true;\n                #endif\n            }\n\t\t\telse\n            {\n                Intersect_Ray_SphereBackside(pos, dir, vec3(0.0), ar, /*out:*/ t);\n\n                if(t < ffp)// photon hits atmo border earlier than particle\n                {\n                    if(!scattered && dot(dir, light) > sunCA){val += E;}//direct transm\n\n                    break;\n                }\n\n                pos += dir * ffp;\n\n                float h = (length(pos) - 1.0);// / ah;\n\n                // check whether we hit a dummy particle\n                {\n                    float h0 = HashFlt(hh, 0xA5DFC2A9u) * 0.5 + 0.5;\n\n                    if(h0 > exp(-h * rcpHR)) {i -= 1.0-1.0/128.0; continue;}\n                }\n\n                scattered = true;\n\n                phase = RayleighPDF(dot(dir, lightp));\n\n                // sample scattering direction\n                {\n                    float h0 = HashFlt(hh, 0x874C40D4u);\n                    float h1 = HashFlt(hh, 0xF27BD7E1u);\n                    h1 = clamp01(h1 * 0.5 + 0.5);\n\n                    //dir = Sample_SchlickPhase(h0, h1, 0.6, dir);\n                    //dir = Sample_HenyeyGreensteinPDF(h0, h1, g, dir);\n                    dir = Sample_RayleighPDF(h0, h1, dir);\n                }    \n            }\n            \n            //if(false)\n            vec3 n0;\n            if(!Intersect_Ray_Scene(pos, lightp, /*out:*/ n0, tt.x))// direct light sampling\n            {\n                float l, fp = 0.0;\n\t\t\t\tIntersect_Ray_SphereBackside(pos, lightp, vec3(0.0), ar, /*out:*/ l);\n                \n                uint hh2 = Hash(hh, 0xCBC27596u);\n                \n                for(float j = 0.0; j < 256.0; ++j)// step towards sun\n                {\n                    {\n                        float h0 = HashFlt(hh2, 0x4EF175A5u);\n                        h0 = clamp01(h0 * 0.5 + 0.5);\n                        h0 = max(0.0001, h0);\n\n                        fp += -log(h0) / sigma_e;\n                    }\n                    \n                    if(fp > l) break;\n                    \n                    vec3 ppos = pos + lightp * fp;\n                    \n                    float ph = (length(ppos) - 1.0);// / ah;\n            \n                    // check whether we hit a real particle\n                    {\n                        float h0 = HashFlt(hh2, 0x85521C74u) * 0.5 + 0.5;\n\n                        if(h0 <= exp(-ph * rcpHR)) break;\n                    }\n\n                    hh2 = Hash(hh2);\n            \t}\n\n\n                if(fp > l)\n                {\n                    //float phase = HenyeyGreensteinPDF(dot(dir, lightp), g);\n   \t\t\t\t\t//if(i >= 3.0)\n                \tval += pot * phase * E;\n                }\n            }\n\n\n\t\t\t\n            hh = Hash(hh);\n        }\n    }\n\telse\n    {\n        //if(false)\n        if(dot(dir, light) > sunCA)\n        {val += E;}\n    }\n \n    \n    vec3 col = XYZ_to_sRGB(val * XYZ10(wl));\n    vec3 colLast = textureLod(iChannel0, uv0 / iResolution.xy, 0.0).rgb;\n    \n    col = mix(colLast, col, 1.0 / (frameAccu + 1.0));    \n    //col.x = tex21.x;\n    outCol = vec4(col, 0.0);\n    \n    \n    {\n        vec4 iMouseLast     = ReadVar4(0, 0);\n        vec4 iMouseAccuLast = ReadVar4(1, 0);\n        vec4 wasdAccuLast   = ReadVar4(2, 0);\n        float frameAccuLast = ReadVar (3, 0);\n\n\n        bool shift = ReadKey(KEY_SHIFT) != 0.0;\n\n        float kW = ReadKey(KEY_W);\n        float kA = ReadKey(KEY_A);\n        float kS = ReadKey(KEY_S);\n        float kD = ReadKey(KEY_D);\n\n        float left  = ReadKey(KEY_LEFT);\n        float right = ReadKey(KEY_RIGHT);\n        float up    = ReadKey(KEY_UP);\n        float down  = ReadKey(KEY_DOWN);\n        \n        \n        bool anyK = false;\n        \n        anyK = anyK || iMouse.z > 0.0;\n        anyK = anyK || shift;\n        anyK = anyK || kW != 0.0;\n        anyK = anyK || kA != 0.0;\n        anyK = anyK || kS != 0.0;\n        anyK = anyK || kD != 0.0;\n        anyK = anyK || left  != 0.0;\n        anyK = anyK || right != 0.0;\n        anyK = anyK || up    != 0.0;\n        anyK = anyK || down  != 0.0;\n        \n        \n        frameAccuLast += 1.0;\n        if(anyK) frameAccuLast = 0.0;\n        \n\n        vec4 wasdAccu = wasdAccuLast;\n        wasdAccu += vec4(kW, kA, kS, kD);\n        wasdAccu += vec4(up, left, down, right);        \n\n        \n        vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n\n        bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n        vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n        vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n\n        vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n\n        \n        WriteVar4(iMouse,        0, 0);\n        WriteVar4(iMouseAccu,    1, 0);\n        WriteVar4(wasdAccu,      2, 0);\n        WriteVar (frameAccuLast, 3, 0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}