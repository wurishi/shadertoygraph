{"ver":"0.1","info":{"id":"7sSczd","date":"1643923769","viewed":326,"name":"Sploosh, de-golfed","username":"aaaidan","description":"Roughly de-golfed version of Xor's stunning shader.\n\nI tried to eliminate side-effects, for a close-to-true refactor. The purpose is to try to understand the magic, and maybe help others do the same.\n\nUncomment DEBUG define on line 8 for a fun view.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["degolf","golf","twotweet","twigl"],"hasliked":0,"parentid":"sdSyDW","parentname":"Sploosh [256 chars]"},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Degolfed remix of Sploosh by Xor\n//\n// Original Links\n//\n// shadertoy: https://www.shadertoy.com/view/sdSyDW\n// twigl:     https://t.co/WEhc3HtswZ\n// tweet:     https://twitter.com/XorDev/status/1487518399550955520\n\n// Uncomment DEBUG to show points in screenspace\n//#define DEBUG\n\nconst float TAU = 3.141592654 * 2.;\n\nconst int   gridSize = 9; // how many points in x and y\nconst float gridDensity = 1.55; // grid density adjustment\nconst float foreshortening = 1.0; // intensity of faux perspective effect: unknown unit\nconst float rotationSpeed = 0.3; // turntable speed (tau rotations per second)\nconst float heightColorIntensity = 9.; // How much height affects brightness (in \"TAU\" units, sorta)\nconst float heightIntensity = 90.; // pixels?\nconst float heightScale = 200.; // grid unit -> pixels factor?\nconst vec3  colorPalette = vec3(0, 1, 2); // control colorization\n\n// light/color intensity\nconst float pointIntensity = 0.1; \n\n// roughly control the bloom effect\n// 0.9 gives a cool \"HDR\" effect\n// Anything less than that looks odd\nconst float bloom = 1.0; \n\nvoid mainImage(out vec4 pixelColor, vec2 pixelPos)\n{\n    const float gridSizeF = float(gridSize);\n    vec2 screenSize = iResolution.xy;\n    \n#ifndef DEBUG\n    pixelColor = vec4(0.); // make sure the output is blank for compatibility\n#else\n    pixelColor = vec4(1., 1., 1., 0.); // start white\n#endif\n    \n    // Iterate through points\n    for(int i; i<gridSize*gridSize; i++)\n        {\n        // Calculate grid-space position of currently processed point.\n        // 0,0 is center of grid\n        // (size/2, size/2) is \"bottom right\"\n        vec2 gridPos = vec2(i % gridSize, i / gridSize) - gridSizeF / 2. + .5;\n        \n        // Rotate grid about center (e.g. 0,0)\n        // Roughly in \"size/2\" units (-0.5 .. 0.5)\n        vec2 gridPosRotated = rotate2d(gridPos, iTime * rotationSpeed);\n        \n        // Heightmap\n        // Drag the entire grid diagonally through the texture over time, wrapping\n        vec4 sampledColor = texture(iChannel0, (gridPos + iTime) / heightScale);\n        float height = sampledColor.r;\n        \n        // Add projected, colored points to output\n        \n        // intensity increases with resolution for consistent point radius on screen\n        // intensity decreases with square of gridsize to adjust for overexposure.\n        float radius = pointIntensity * screenSize.x / (gridSizeF*gridSizeF); \n        \n        // Height drags each channel through a cos wave, offset by the palette terms\n        vec3 color = cos(height * heightColorIntensity + colorPalette);\n        vec3 light = color + bloom;\n        vec2 scaleAndPerspective = screenSize / ( gridSizeF * gridDensity + foreshortening * gridPosRotated.y);\n        \n        float screenSpaceDistanceToPoint = length(\n            pixelPos - \n            gridPosRotated * scaleAndPerspective - \n            vec2(0, height * heightIntensity) - \n            screenSize * .5 // center\n        );\n        \n#ifdef DEBUG\n        if (mod(iTime * 5.0 + float(i), gridSizeF) < 1.0) {\n            pixelColor.rgb *= smoothstep(12., 14., screenSpaceDistanceToPoint) * vec3(0.4,0.15,1.0) + vec3(0.6,0.85,0);\n        } else {\n            pixelColor.rgb *= smoothstep(9., 10., screenSpaceDistanceToPoint) * 0.1 + 0.9;\n        }\n#else\n        pixelColor.rgb += radius * light / screenSpaceDistanceToPoint;\n#endif\n\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// rotate a point about the origin by a (tau units)\nvec2 rotate2d(const vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2  m = mat2(c, -s, s, c);\n\treturn m * v;\n}","name":"Common","description":"","type":"common"}]}