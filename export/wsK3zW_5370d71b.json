{"ver":"0.1","info":{"id":"wsK3zW","date":"1569871217","viewed":62,"name":"Simple Triangle Fractal","username":"johnnyegel","description":"Renders a simple triangle fractal.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FRACT_ITER 8\n\n\nstruct Triangle {\n    vec2 p0,p1,p2;\n};\n\nvec2 lens(vec2 uv) {\n    const float size = 0.3;\n    float t = iTime * 0.3;\n    \n    vec2 p = vec2(sin(t*3.0)* 0.5, sin(t*5.) * 0.3);\n    vec2 d = p - uv;\n    \n    float l = length(d);    \n    float lf = smoothstep(size+0.01, size-0.01, l);\n    \n    vec2 dn = d / size;\n    \n    //vec2 res = vec2(pow(10., dn.x), pow(10., dn.y));\n    \n    return lf * (dn * dn * dn);\n    \n    //return vec2(0.);\n}\n\n\nbool pointInTriangle(vec2 p, Triangle tri) {\n    float A = 0.5 * (-tri.p1.y * tri.p2.x + tri.p0.y * (-tri.p1.x + tri.p2.x) + \n                     tri.p0.x * (tri.p1.y - tri.p2.y) + tri.p1.x * tri.p2.y);\n    float sign = A < 0. ? -1. : 1.;\n    float s = (tri.p0.y * tri.p2.x - tri.p0.x * tri.p2.y + \n               (tri.p2.y - tri.p0.y) * p.x + (tri.p0.x - tri.p2.x) * p.y) * sign;\n    float t = (tri.p0.x * tri.p1.y - tri.p0.y * tri.p1.x + \n               (tri.p0.y - tri.p1.y) * p.x + (tri.p1.x - tri.p0.x) * p.y) * sign;\n    \n    return s > 0. && t > 0. && (s + t) < 2. * A * sign;\n}\n\n//float getSubTriangle(vec2 p, Triangle tri) {    \nTriangle getSubTriangle(vec2 p, Triangle tri) {    \n    float d0 = length(p - tri.p0);\n    float d1 = length(p - tri.p1);\n    float d2 = length(p - tri.p2);\n        \n    if (d0 < d1 && d0 < d2) {\n        vec2 p01 = vec2((tri.p0 + tri.p1) / 2.);\n        vec2 p20 = vec2((tri.p2 + tri.p0) / 2.);\n        return Triangle(tri.p0, p01, p20);\n    }\n    else if (d1 < d0 && d1 < d2) {\n        vec2 p01 = vec2((tri.p0 + tri.p1) / 2.);\n        vec2 p12 = vec2((tri.p1 + tri.p2) / 2.);\n        return Triangle(p01, tri.p1, p12);\n    }\n    \n    vec2 p12 = vec2((tri.p1 + tri.p2) / 2.);\n    vec2 p20 = vec2((tri.p2 + tri.p0) / 2.);\n    return Triangle(p20, p12, tri.p2);\n}\n\nmat2 rotateMatrix2(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat triangleFractal(vec2 uv, float scale, float minpixel) {\n    vec2 translate = vec2(0.072583, 0.154841);\n    mat2 rot45 = rotateMatrix2((2. * 3.1415) / 3.);\n     \n    vec2 p0 = vec2(0, 0.45);\n    vec2 p1 = p0 * rot45;\n    vec2 p2 = p1 * rot45;\n    \n\tp0 -= translate;\n    p1 -= translate;\n    p2 -= translate;\n    \n    p0 /= scale;\n    p1 /= scale;\n    p2 /= scale;\n    \n    Triangle tri = Triangle(p0, p1, p2);\n    //tri = rotateTriangle(tri, iTime);    \n    \n    while(true) {\n    \tif (!pointInTriangle(uv, tri)) return 0.;\n        tri = getSubTriangle(uv, tri);\n        \n        if (length(tri.p1 - tri.p0) <= minpixel) break;\n        if (length(tri.p2 - tri.p1) <= minpixel) break;\n        if (length(tri.p2 - tri.p0) <= minpixel) break;\n    }\n    \n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n\n    uv -= lens(uv);\n    \n    float a1 = (3./6.) * (2. * 3.141592);\n    float a2 = (9./6.) * (2. * 3.141592);\n    \n    float t = iTime;\n    float trot = t;\n    if (t > a1) {\n        trot = mod(trot - a1, a2 - a1) + a1;\n    }\n    \n    float ts = 0.5;\n    float tl1 = 2.;\n    float tl2 = 10.;\n    \n    float tscale = t;\n    if (t > tl1) {\n        tscale = mod(tscale - tl1, tl2 - tl1) + tl1;\n    }   \n    float texp = pow(2., tscale);\n    float scale = 1.0 / (texp);\n    mat2 rotateUv = rotateMatrix2(trot);\n    \n    \n    // Rotate the UV\n    uv *= rotateUv;\n    \n    float mul = triangleFractal(uv, scale, 1.8 / iResolution.y);\n   \tcol *= mul;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}