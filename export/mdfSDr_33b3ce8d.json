{"ver":"0.1","info":{"id":"mdfSDr","date":"1668730730","viewed":72,"name":"Walk Trough the MandelBulb","username":"LoganOracio","description":"so sloooooow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Some of the Ray Marching stuff taken from mrange:\n\n// CC0: Wednesday messing around\n#define MAX_RAY_LENGTH  1.0\n#define MAX_RAY_MARCHES 70\n#define TOLERANCE       0.001\n#define NORM_OFF        0.001\n\nint g_hit     = 0;\nint g_loop     = 0;\nint g_loop2     = 0;\n\n#define Iterations 50\n#define Power 3.0\n#define Bailout 3.0\n\nfloat DE(vec3 pos) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    int i = 0;\n\tfor (i = 0;i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n    g_loop2 = i;\n\treturn 0.5*log(r)*r/dr;\n}\n\n\nconst float raymarchFactor = 1.0;\n\n\nfloat df(vec3 p) {\n    vec3 c = vec3(1.0);\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float a = DE(q);\n    //a += 1.0/length(p.yz)*.001;\n    return abs(a)-.0001;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float ti) {\n  float t = ti;\n  int i = 0;\n  vec2 dti = vec2(1e10,0.0);\n  for (i = 0; i < MAX_RAY_MARCHES; i++) {\n    float d = df(ro + rd*t);\n    if (d < TOLERANCE) g_hit = 1;\n    if (d < TOLERANCE || t > MAX_RAY_LENGTH) break;\n    if (d<dti.x) { dti=vec2(d,t); }\n    t += raymarchFactor*d;\n  }\n  if(i==MAX_RAY_MARCHES) { t=dti.y; }\n  g_loop = i;\n  return t;\n}\n\nvec3 normal(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df(pos+eps.xyy) - df(pos-eps.xyy);\n  nor.y = df(pos+eps.yxy) - df(pos-eps.yxy);\n  nor.z = df(pos+eps.yyx) - df(pos-eps.yyx);\n  return normalize(nor);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 traj(float time)\n{\n    return vec3(time*0.057832121,time*0.021546,time*0.0157823);\n}\nvec4 render(vec2 p) {\n  \n  vec3 ro = traj(iTime);\n  vec3 la = traj(iTime+.1);\n  vec3 ww = normalize(la-ro);\n  vec3 uu = normalize(cross(vec3(0.0,cos(iTime*0.1),sin(iTime*0.1)), ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = 0.3;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww );\n  \n  g_hit = -1;\n  float t = rayMarch(ro, rd, 0.0001);\n  int hit = g_hit;\n  \n  \n  vec4 col = vec4(0.0);\n  if (hit==1) {\n    vec3 p = ro + rd*t;\n    \n    col.xyz = hsv2rgb(vec3(float(g_loop2)/120.0,0.7,sqrt(1.0/float(g_loop+1))));\n  }\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec4 col = render(uv);\n\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}