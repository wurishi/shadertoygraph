{"ver":"0.1","info":{"id":"ftGSDt","date":"1641486078","viewed":197,"name":"Depth Map For Sphere And Plane","username":"DexM","description":"Does not use ray marching.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF (1.0 / 0.0)\n\n// Rotation happens in the direction specified by right hand rule\n// Axis must be unit vector (normalized)\nvec3 rotate(vec3 vec, vec3 rotationAxis, float rotationAngle)\n{\n    rotationAngle /= 2.0;\n    vec4 q = vec4(rotationAxis * sin(rotationAngle), cos(rotationAngle));\n\n    mat4 p = mat4(\n         0,      vec.z, -vec.y,  vec.x, // Column 1\n        -vec.z,  0,      vec.x,  vec.y, // Column 2\n         vec.y, -vec.x,  0,      vec.z, // Column 3\n        -vec.x, -vec.y, -vec.z,  0);    // Column 4\n\n    mat4 invQ = mat4(\n         q.w, -q.z,  q.y, -q.x,  // Column 1\n         q.z,  q.w, -q.x, -q.y,  // Column 2\n        -q.y,  q.x,  q.w, -q.z,  // Column 3\n         q.x,  q.y,  q.z,  q.w); // Column 4\n    \n    return (q * p * invQ).xyz;\n}\n\n// Calculate distance to an infinite plane\n// Plane is one sided, normal vector specifies outside\nfloat planeDistance(\n    vec3 rayOrigin,\n    vec3 rayDirection,\n    vec3 planeOrigin,\n    vec3 planeNormal)\n{\n    // Check whether ray origin is under the plane\n    float side = sign(dot(rayOrigin - planeOrigin, planeNormal));\n\n    // Calculate distance to the plane\n    float depth = side * dot(planeOrigin - rayOrigin, planeNormal) / dot(rayDirection, planeNormal);\n    \n    // Check whether intersection point is behind ray origin\n    if (depth < 0.0)\n        return side * INF;\n\n    return depth;\n}\n\n// Calculate distance to a sphere\nfloat sphereDistance(\n    vec3 rayOrigin,\n    vec3 rayDirection,\n    vec3 sphereOrigin,\n    float sphereRadius)\n{\n    // Part of the formula we need to get square root of\n    vec3 rso = rayOrigin - sphereOrigin;\n    float rsoLen = length(rso);\n    float rdrsoDot = dot(rayDirection, rso);\n    float d = rdrsoDot * rdrsoDot - rsoLen * rsoLen + sphereRadius * sphereRadius;\n    \n    if (d < 0.0)\n        return INF; // Ray does not intersect sphere\n\n    // Find intersection distances\n    float sq = sqrt(d);\n    vec2 dist = vec2(sq, -sq) - rdrsoDot;\n\n    float minDist = min(dist.x, dist.y);\n    float maxDist = max(dist.x, dist.y);\n\n    // Check whether both intersection points are behind ray origin\n    if (maxDist < 0.0)\n        return INF;\n    \n    // Check whether we are inside the sphere\n    if (minDist < 0.0)\n        return -maxDist;\n    \n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // UV has origin at the center of the screen and farthest edge of the canvas is at distance 1\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Set up camera\n    const vec3 cameraOrigin = vec3(0);\n    const vec3 cameraDirection = vec3(0, 0, -1);\n    const float cameraFieldOfView = radians(90.0) / 2.0; // Divide by 2, because our UV go from -1 to 1\n\n    // Set up ray to render view\n    float rayAngle = cameraFieldOfView * length(uv);\n    vec3 rayRotationAxis = normalize(cross(cameraDirection, vec3(uv, 0)));\n    vec3 ray = rotate(cameraDirection, rayRotationAxis, rayAngle);\n    \n    // Calculate depth\n    const vec3 planeOrigin = vec3(0, -1, 0);\n    const vec3 planeNormal = vec3(0, 1, 0);\n    float depth = planeDistance(cameraOrigin, ray, planeOrigin, planeNormal);\n    \n    const vec3 sphereOrigin = vec3(0, 0, -3);\n    const float sphereRadius = 1.0;\n    depth = min(depth, sphereDistance(cameraOrigin, ray, sphereOrigin, sphereRadius));\n    \n    // Render depth\n    vec3 color = vec3(1.0 - (depth / 5.0)); // Invert colors, so white is closer\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}