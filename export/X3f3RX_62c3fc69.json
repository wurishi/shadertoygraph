{"ver":"0.1","info":{"id":"X3f3RX","date":"1707732551","viewed":68,"name":"[inspirnathan] 16 - cubemaps","username":"hrst4","description":"[inspirnathan] 16 - cubemaps","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["inspirnathan"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This a french translation of the highly educational Nathan Vaughn's tutorials.\n// Un grand merci à lui !\n// his website: https://inspirnathan.com/\n// original:\n// from https://inspirnathan.com/posts/63-shadertoy-tutorial-part-16\n// [0-xx]\n\n#define PART 2\n\n/*\nSalutations, mes amis ! \nBienvenue dans la partie 16 de ma série de tutoriels Shadertoy ! \n\nDans ce tutoriel, je vais expliquer comment utiliser les cubemaps dans Shadertoy, \nafin de pouvoir dessiner des arrière-plans 3D et faire des reflets plus réalistes sur n'importe quel objet 3D !\n\n# Cubemaps\n\nLes cubemaps sont un type spécial de texture qui peut être considéré comme contenant six textures 2D individuelles\nqui forment chacune une face d'un cube.\n\nVous avez peut-être déjà utilisé des cubemaps dans des moteurs de jeu tels que Unity et Unreal Engine.\n\nDans Shadertoy, les cubemaps vous permettent de créer un arrière-plan 3D dynamique qui change en fonction de l'orientation de la caméra.\n\nChaque pixel du canvas de Shadertoy sera déterminé par la direction du on.\n\nLe site web Learn OpenGL fournit une excellente image pour visualiser le fonctionnement des cubemaps.\n(https://learnopengl.com/Advanced-OpenGL/Cubemaps)\n\nhttps://inspirnathan.com/_nuxt/img/img-1.ea62155.png\n\nNous supposons que la caméra se trouve au centre du cube et qu'elle pointe vers une ou plusieurs faces du cube.\nDans l'image ci-dessus, la direction du \non détermine la partie du cubemap à échantillonner.\n\nMettons cela en pratique dans Shadertoy. \n\nCréez un nouveau shader et cliquez sur la case iChannel0. Cliquez sur l'onglet \"Cubemaps\" et sélectionnez le cubemap \"Uffizi Gallery\".\n\nhttps://inspirnathan.com/_nuxt/img/img-2.ac2da60.png\n\nRemplacez ensuite tout le code par ce qui suit :\n*/\n\n\n#if PART == 0\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n  \n  vec3 col = texture(iChannel0, rd).rgb;\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nCe code vous semble-t-il familier ? J'ai repris pour ce tutoriel une partie du code utilisé au début de la partie 14\nde ma série de tutoriels Shadertoy. \n\nNous utilisons le modèle de caméra Lookat pour ajuster la direction du rayon, rd.\n\nLa couleur de chaque pixel, col, sera égale à une valeur de couleur échantillonnée à partir du cubemap stocké dans iChannel0.\nNous avons appris à accéder aux textures dans le tutoriel précédent. \n\nCependant, l'accès aux valeurs d'un cubemap nécessite de passer la direction du rayon, rd, \nau lieu des coordonnées uv comme nous l'avons fait pour les textures 2D.\n\nvec3 col = texture(iChannel0, rd).rgb;\n\nVous pouvez utiliser la souris pour regarder autour du cubemap car nous utilisons la variable globale\niMouse pour contrôler l'origine du rayon, ro, qui est la position de la caméra. \nLa fonction de la caméra change en fonction de ro et de lp, de sorte que la direction du rayon change au fur\net à mesure que nous déplaçons la souris. On dirait que l'arrière-plan est maintenant une scène 3D dynamique !\n\n# Réflections avec les cubemaps\nEn utilisant les cubemaps, nous pouvons donner aux objets un aspect réfléchissant.\nAjoutons une sphère à la scène en utilisant le ray marching.\n\nRemplacez votre code par le suivant :\n\n*/\n#elif PART == 1\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float EPSILON = 0.0005;\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdScene(vec3 p) {\n  return sdSphere(p, 1.);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > MAX_DIST) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * EPSILON;\n    float r = 1.;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal) {\n  vec3 cubemapReflectionColor = texture(iChannel0, reflect(rd, normal)).rgb;\n\n  vec3 K_a = 1.5 * vec3(0.0,0.5,0.8) * cubemapReflectionColor; // Reflection\n  vec3 K_d = vec3(1);\n  vec3 K_s = vec3(1);\n  float alpha = 50.;\n\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\n\nfloat fresnel(vec3 n, vec3 rd) {\n  return pow(clamp(1. - dot(n, -rd), 0., 1.), 5.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n  \n  vec3 col = texture(iChannel0, rd).rgb;\n\n  float d = rayMarch(ro, rd);\n\n  vec3 p = ro + rd * d;\n  vec3 normal = calcNormal(p);\n\n  vec3 lightPosition1 = vec3(1, 1, 1);\n  vec3 lightDirection1 = normalize(lightPosition1 - p);\n  vec3 lightPosition2 = vec3(-8, -6, -5);\n  vec3 lightDirection2 = normalize(lightPosition2 - p);\n\n  float lightIntensity1 = 0.6;\n  float lightIntensity2 = 0.3;\n    \n  vec3 sphereColor = phong(lightDirection1, lightIntensity1, rd, normal);\n  sphereColor += phong(lightDirection2, lightIntensity2, rd, normal);\n  sphereColor += fresnel(normal, rd) * 0.4;\n  \n  col = mix(col, sphereColor, step(d - MAX_DIST, 0.));\n\n  fragColor = vec4(col, 1.0);\n}\n\n/*\nhttps://inspirnathan.com/_nuxt/img/img-3.104132e.png\n\nLorsque vous exécutez le code, vous devriez voir une sphère d'aspect métallique au centre de la scène.\n\nNous utilisons le modèle de réflexion de Phong que nous avons appris dans la partie 11 et la réflexion de Fresnel \nque nous avons apprise dans la partie 12.\n\nDans la fonction phong, nous implémentons le modèle de réflexion de Phong.\n\nLa couleur ambiante de la sphère sera la couleur de la cubemap. \nCependant, remarquez qu'au lieu de passer la direction du rayon, rd, dans la fonction de texture,\nnous utilisons la fonction reflect pour trouver la direction du rayon réfléchi, \ncomme si le rayon rebondissait sur la sphère. \nCela crée l'illusion d'une réflexion sphérique, faisant ressembler la sphère à un miroir.\n\nNous pouvons également nous amuser et ajouter une teinte bleue à la couleur de la sphère.\n\nhttps://inspirnathan.com/_nuxt/img/gif-2.14e71b4.gif\n\nMagnifique!\n\n# Comme utiliser un shader cube ?\n\nNous pouvons créer des cubemaps personnalisés dans Shadertoy en utilisant l'option \"Cube A\". \nTout d'abord, créons un nouveau shader. \nDans le tutoriel précédent, nous avons appris que nous pouvions ajouter des tampons en cliquant sur le signe plus à côté de l'onglet \n\"Image\" en haut de l'interface utilisateur de Shadertoy.\n\nhttps://inspirnathan.com/_nuxt/img/img-4.dd555af.png\n\nEn cliquant sur le signe plus, un menu devrait apparaître. Sélectionnez l'option \"Cubemap A\".\n\nhttps://inspirnathan.com/_nuxt/img/img-5.88cbc28.png\n\nLorsque vous sélectionnez l'option \"Cubemap A\", un nouvel onglet apparaît à gauche de l'onglet \"Image\".\nCet onglet s'intitule \"Cube A\". Par défaut, Shadertoy fournit le code suivant pour ce shader \"Cube A\".\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}\n\nAu lieu de définir une fonction mainImage, nous définissons maintenant une fonction mainCubemap.\n\nElle fournit automatiquement une direction de rayon, rayDir, pour vous. \n\nElle fournit également une origine de rayon, rayOri, au cas où vous en auriez besoin pour effectuer des calculs.\n\nSupposons que nous voulions générer une cubemap personnalisée qui soit rouge sur les faces opposées,\nbleue sur les faces opposées et verte sur les faces opposées.\n\nEssentiellement, nous allons construire un arrière-plan dynamique en forme de cube et déplacer la caméra à l'aide de notre souris.\nCela ressemblera à ce qui suit.\n\nhttps://inspirnathan.com/_nuxt/img/gif-3.3042ba7.gif\n\nNous remplacerons le code du shader \"Cube A\" par le code suivant :\n\nfloat max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 rd = abs(rayDir);\n    \n    vec3 col = vec3(0);\n    if (max3(rd) == rd.x) col = vec3(1, 0, 0);\n    if (max3(rd) == rd.y) col = vec3(0, 1, 0);\n    if (max3(rd) == rd.z) col = vec3(0, 0, 1);\n    \n    fragColor = vec4(col,1.0); // Output cubemap\n}\n\nPermettez-moi d'expliquer ce qui se passe ici.\nLa fonction max3 est une fonction que j'ai créée pour obtenir la valeur maximale de chaque composante d'un vecteur tridimensionnel,\nvec3.\n\nDans la fonction mainCubemap, nous prenons la valeur absolue de la direction du rayon, rayDir. \nPourquoi ? Si nous avons une direction de rayon de vec3(1, 0, 0) et une direction de rayon de vec3(-1, 0, 0),\nnous voulons que la couleur du pixel soit rouge. Ainsi, les faces opposées du cube seront rouges.\n\nNous prenons la valeur maximale de chaque composante de la direction du rayon pour déterminer quelle composante des\naxes X, Y et Z est la plus grande. \n\nCela nous permettra de créer une forme \"carrée\".\n\nImaginez que vous regardiez un cube et que vous calculiez la normale de surface sur chaque face du cube.\nVous obtiendriez six normales de surface uniques : \nvec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1), vec3(-1, 0, 0), vec3(0, -1, 0),vec3(0, 0, -1).\n\nEn prenant la valeur maximale de la direction du rayon, nous créons essentiellement l'une de ces six normales de surface.\nComme nous prenons la valeur absolue de la direction du rayon, nous n'avons à vérifier que trois scénarios différents.\n\nMaintenant que nous avons appris comment fonctionne ce code, revenons au shader \"Image\". \nCliquez sur la case iChannel0, cliquez sur l'onglet \"Misc\" dans le menu contextuel qui apparaît, et sélectionnez l'option \"Cubemap A\".\n\nAjoutez ensuite le code suivant au nuanceur \"Image\" :\n*/\n\n#elif PART == 2\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 3);\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -0.5)); // Notice how we're using -0.5 as the zoom factor instead of -1\n  \n  vec3 col = texture(iChannel0, rd).rgb;\n\n  fragColor = vec4(col, 1.0);\n}\n\n\n/*\nCe code est similaire à celui que nous avons utilisé plus tôt dans ce tutoriel.\nAu lieu d'utiliser la cubemap \"Uffizi Gallery\", nous utilisons la cubemap personnalisée que nous avons créée dans l'onglet \"Cube A\".\n\nNous avons également effectué un léger zoom arrière en modifiant le facteur de zoom de -1 à -0,5.\n\nLorsque vous exécutez le shader, vous devriez voir un arrière-plan coloré qui donne l'impression que nous sommes à l'intérieur d'un cube.\nC'est bien !\n\n# Conclusion\n\nDans ce tutoriel, nous avons appris à utiliser les cubemaps fournis par Shadertoy et à créer nos propres cubemaps. \nNous pouvons utiliser la fonction texture pour accéder aux valeurs stockées dans un cubemap en utilisant la direction du rayon. \nSi nous voulons créer des réflexions, nous pouvons utiliser la fonction reflect avec la direction du rayon et la normale\nde la surface pour créer des réflexions plus réalistes. \n\nEn utilisant le shader \"Cube A\", nous pouvons créer des cubemaps personnalisés.\n\n# Ressources\nhttps://inspirnathan.com/posts/64-shader-resources\n\n*/\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"float max3(vec3 rd) {\n   return max(max(rd.x, rd.y), rd.z);\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3 rd = abs(rayDir);\n    \n    vec3 col = vec3(0);\n    if (max3(rd) == rd.x) col = vec3(1, 0, 0);\n    if (max3(rd) == rd.y) col = vec3(0, 1, 0);\n    if (max3(rd) == rd.z) col = vec3(0, 0, 1);\n    \n    fragColor = vec4(col,1.0); // Output cubemap\n}\n","name":"Cube A","description":"","type":"cubemap"}]}