{"ver":"0.1","info":{"id":"sdKSzV","date":"1635041909","viewed":393,"name":"Golfed SmoothLifeL (455 chars)","username":"Flyguy","description":"Golfed version of SmoothLifeL (https://youtu.be/KJe9H6qS82I).\nUses a simpler threshold based transfer function which produces effectively the same result.","likes":12,"published":3,"flags":32,"usePreview":0,"tags":["organic","life","small","golf","smoothlife"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 c, vec2 p ){\n\tc = texelFetch(iChannel0, ivec2(p), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Sample pixel y value at location v\n#define S(v) texelFetch(iChannel0, ivec2(v),0)\n\nfloat N = 12.; //Neighborhood size\n\nvoid mainImage( out vec4 c, vec2 p ){\n    vec2 a, //Total kernel area (x = neighborhood, y = cell)\n         k, //Neighborhood/cell kernel mask\n         o, //Sample offset\n         f; //Neighborhood/cell fill\n    \n    //Sample pixels in neighborhood/cell\n    for(o.y = -N; o.y++ <= N;){                        \n        for(o.x = -N; o.x++ <= N;){\n            k = step(length(o), vec2(N, N/3.));        //Kernel bounds\n            k.x -= k.y;                                //Neighborhood excludes cell\n            a += k;                                    //Add up kernel area\n            f += k * S(mod(p + o, iResolution.xy)).x;    //Add up neighborhood/cell fill\n        }\n    }\n    \n    f /= a; // Normalize fill to 0-1.\n    \n    //Life rule & euler integration\n    c = clamp(\n    S(p) + .1 * float(          //Time step .1 x 0.5 i.e. how fast a cell heals/degrades per frame\n        f.y < .5 ?              //Select birth/survival threshold if cell fill > 0.5\n        f.x > .26 && f.x < .34: //Dead cell is \"born\" if neighborhood fill >.26 and <.34\n        f.x > .37 && f.x < .55  //Live cell survives if neighborhood fill >.37 and <.55\n    ) - .05 //0.5 x Time step\n    + step(length(iMouse.xy - p), N)                           //Mouse drawing\n    + (iFrame < 2 ? texture(iChannel1, p/1e3, 0.).x-.5 : 0.)   //Initial conditions\n    , 0., 1.);                                                 //Clamp cell value between 0-1.\n}\n","name":"Buffer A","description":"","type":"buffer"}]}