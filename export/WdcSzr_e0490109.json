{"ver":"0.1","info":{"id":"WdcSzr","date":"1571268153","viewed":181,"name":"Relaxing loadingicon","username":"theepicsnail","description":"https://www.reddit.com/r/loadingicon/comments/ddi9vq/relaxing/","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["loadingicon","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Bit of math to make uv range from (-1,-1) to (1,1) centered at the center of the screen.\n    vec2 uv = (fragCoord*2.-iResolution.xy)/min(iResolution.y,iResolution.x);\n    // See the box here: \n    // fragColor = vec4(fract(abs(uv)),0,1); return ;\n    \n    // We'll be coloring a pixel as white if l is near 0. Or the gray if l is large enough.\n    \t\n    // Start out by setting l = 0 when the pixel is exactly on the main circle.\n    // l < 0 inside the circle, l > 0 outside the circle.\n    float l = length(uv)-.8;\n    // View l:\n    //fragColor = vec4(-l,l,0,0)*4.;// Green for l>0, red for l<0, black where l=0\n    \n    // Get the angle from the center of the circle to the pixel we're drawing.\n    // This is used a couple times for offsets in waves. It doesn't rotate though.\n    float angle = atan(uv.y,uv.x);\n    // View angle:\n    //fragColor = vec4(fract(angle/6.28)); return ;\n    \n        \n    // Figure out how large the wavy bit should be.\n    // cos(angle+iTime) gives a value from -1 to 1 for each angle, and rotates in a loop\n    float wave = cos(angle+iTime);\n    // View wave:\n    //fragColor = vec4(-wave,wave,0,1);// Green is where wave = 1, red = -1\n    \n    // smoothstep(.5,1., wave) clips the top of that wave, outputting 0 for all wave < .5, up to 1\n    // now we have a number that's 0 everywhere around the loop, except for a patch where it climbs up\n    // to 1, then back down to 0. Scale that to be a nice looking height for peak waves.\n    float height = smoothstep(.5,1.,wave)*.07;\n    // View height spinning on the circle:\n    //fragColor = vec4(height*10.);\n    \n    \n    // The waves themselves are higher frequency and rotate backwards.\n    // angle*Number = scales up how many bumps we have\n    // - number * iTime = each bump will slide backwards at some speed.\n    float phase = angle*10. - 2.*iTime;\n    // View wavelet phase:\n    // fragColor = vec4(abs(sin(phase))*.2); \n    \n    // Figure out how far the wave is away from the circle's surface\n    float wave_offset = sin(phase) * height;\n    // Remember, we're coloring white where l = 0\n    // l <0 inside the circle, l > 0 outside the circle.\n    // sin will go +- as well.\n    // If we take the absolute value of both of these, then find the difference\n    // We'll know where the wave (or reflected wave) matches up with that distance inside (or outside) the circle.\n    l = abs(l)-abs(wave_offset);\n    \n    // We compute the color based on how close to 0 l is after all of this.\n    // abs(l) is the distance from l being 0.\n    // Use smoothstep to map that distance to [0,1], 0 at distance <= .01, 1 at distance >=.03\n    float c = smoothstep(.01,0.03,abs(l));\n    vec3 col = vec3(mix(1.,.2,c)); // Mix our two colors, if c =0 use white, if c = 1 use a gray.\n    fragColor += vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}