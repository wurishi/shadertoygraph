{"ver":"0.1","info":{"id":"tlsyW7","date":"1592262162","viewed":308,"name":"Particle transition Reversible","username":"zhilichen","description":"Particle transition Reverse","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["transition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float period = 3.0;\t// second  转场时间\nconst float particleSizeMin = 50.0;\t// 最小粒子大小（像素）\nconst float rotationRange = 30.0/180.0 * 3.1415926; // 旋转最大角度\nconst float travelDistanceRatio = 10.0; // times image dim\nconst bool reverse = true; // true: particle to image, false: image to particle\nconst int motionBlurStep = 10;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat pKernel(float r) {\n\treturn 1.0 - smoothstep(0.9, 1.0, r);\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\nfloat quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\nvec2 mirroredSample(vec2 uv0) {\n    vec2 uv = uv0;\n    if (uv0.x <= 0.0) {\n        uv.x = -uv0.x;\n    } else if (uv0.x >= 1.0) {\n        uv.x = 2.0 - uv0.x;\n    }\n    if (uv0.y <= 0.0) {\n        uv.y = -uv0.y;\n    } else if (uv0.y >= 1.0) {\n        uv.y = 2.0 - uv0.y;\n    }\n    return uv;\n}\n\n\nvec4 animatedColor(sampler2D tex0, sampler2D tex1, vec2 fragCoord, vec2 res, float t) {\n\tfloat st = quadraticInOut(t);\n    \n    float particleSizeInit = particleSizeMin;\n    \n    // particle numbers\n    int numX = int(res.x / particleSizeInit);\n    int numY = int(res.y / particleSizeInit);\n    \n    // current camera position\n    float travelDistance = travelDistanceRatio * (res.x + res.y);\n    float fx = travelDistance;\n    vec3 cameraPos = vec3(res/2.0, -fx + travelDistance * 0.8 * st);\n    \n    // rotation\n    float phi0 = rotationRange * st;\n        \n    \n    // loop thru particles\n    vec4 colorSum = vec4(0.0, 0.0, 0.0, 0.0);\n    float weightSum = 0.0;\n    \n    const int maxNumOverlap = 10;\n    int particleIdx[maxNumOverlap];\n    vec3 particlePos0[maxNumOverlap];\n    vec3 particleScreenPos[maxNumOverlap];\n    \n    // find overlap particles\n    int numOverlap = 0;\n    for (int i = 0; i < numX; i++) {\n        for (int j = 0; j < numY; j++) {\n            vec2 coordp = vec2(i, j) * particleSizeInit;\n            float noise = rand(coordp);\n            // position\n            vec3 pos0;\n            pos0.xy = coordp + 60.0 * (noise*2.0-1.0);\n            pos0.z = -(travelDistance * noise) * st * 0.5;\n            \n\t\t\t// init radius\n            float radius0 = particleSizeInit * 1.3 * (0.2 + 0.8 * noise) * (0.5 + 1.0*st);\n            \n            vec3 screenPos = pos0 - cameraPos;\n            if (screenPos.z > 0.0) {\n                // perform rotation here\n                screenPos.xy = vec2(screenPos.x * cos(-phi0) - screenPos.y * sin(-phi0),\n                                   \tscreenPos.x * sin(-phi0) + screenPos.y * cos(-phi0));\n                \n                screenPos.xy = screenPos.xy * fx / screenPos.z;\n                screenPos.xy += res / 2.0;\n            \tfloat screenRadius = radius0 * fx / screenPos.z;\n                \n                // in clip space\n                if (screenPos.x > 0.0 && screenPos.x < res.x &&\n                    screenPos.y > 0.0 && screenPos.y < res.y) {\n                    \n                    // TODO sort\n                    \n                    // see if pixel in particle range\n                \tvec2 dir = fragCoord - screenPos.xy;\n                    float r = length(dir) / screenRadius;\n                    \n                    if (r < 2.0) {\n                        vec2 uv0 = pos0.xy / res;\n        \t\t\t\tvec4 color0 = texture(tex0, uv0);\n                        color0.a = 1.0;\n        \t\t\t\tvec4 color1 = texture(tex1, uv0);\n                        color1.a = 1.0;\n                        vec4 colorP = mix(color0, color1, clamp(st/2.0, 0.0, 1.0));\n                        \n                        float w = pKernel(r);\n                        colorSum += colorP * w;\n                        weightSum += w;\n                    }\n                }\n            }\n        }\n    }\n    \n    if (weightSum > 0.0) {\n        colorSum /= weightSum;\n    }\n    \n    // blend with original images\n    float scale0 = 1.0 / (1.0 + 0.6 * st);\n    vec2 uv = fragCoord - res / 2.0;\n    vec2 uv0 = scale0 * vec2(uv.x * cos(phi0) - uv.y * sin(phi0),\n                   uv.x * sin(phi0) + uv.y * cos(phi0)) / res + 0.5;\n    float scale1 = 1.0/st;\n    vec2 uv1 = scale1 * uv / res + 0.5;\n    vec4 col0 = texture(tex0, mirroredSample(uv0));\n    vec4 col1 = texture(tex1, mirroredSample(uv1));\n    \n    vec4 colBG = mix(col0, col1, exponentialInOut(t));\n    \n    float w = 0.0;\n    if (t < 0.1) {\n        w = smoothstep(0.0, 0.1, t);\n    } else if (t < 0.8) {\n        w = 1.0;\n    } else {\n        w = 1.0 - smoothstep(0.8, 1.0, t);\n    }\n    \n    vec4 col = mix(colBG, colorSum, w * colorSum.a);\n\n    return col;\n}\n                \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int turn = int(iTime / period) % 2;\n    float t = fract(iTime / period);\n    t = clamp((t - 0.2)*1.3, 0.0, 1.0);\n    if (reverse) {\n        t = 1.0 - t;\n    }\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    for (int nt = 0; nt < motionBlurStep; nt++) {\n        float t_offset = 0.01 * (float(nt) / (float(motionBlurStep) - 1.0) * 2.0 - 1.0);\n        float tt = t + t_offset;\n        if (turn == 0) {\n            vec4 colAnim = animatedColor(iChannel0, iChannel1, fragCoord, iResolution.xy, tt);\n            col += colAnim;\n        }\n        else {\n            vec4 colAnim = animatedColor(iChannel1, iChannel0, fragCoord, iResolution.xy, tt);\n            col += colAnim;\n        }\n\t}\n    col = col / col.a;\n    \n\n    // Output to screen\n    fragColor = vec4(col.rgb,1.0);\n}","name":"Image","description":"","type":"image"}]}