{"ver":"0.1","info":{"id":"WslcRl","date":"1590508986","viewed":61,"name":"sdf-modelling","username":"vizaxo","description":"sdf-modelling","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int maxIters = 25;\nfloat epsilon = 0.005;\nconst int subdivisions = 2;\n\nstruct ray {\n    vec3 o;\n    vec3 d;\n};\n    \nfloat square(float x) { return x*x; }\n    \nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 r) {\n    return length(max(abs(p) - r, 0.0));\n}\n\nfloat sdCross(vec3 p) {\n    p = abs(p) - vec3(0.0, 0.48, 0.0);\n    p.y = abs(p.y);\n    p.xz = p.x>p.z ? p.xz : p.zx;\n\treturn length(max(p - vec3(0.17, 0.015, 0.015), 0.0));\n}\n\n\nfloat delta(float k, float diff) {\n    if (diff > k) {\n        return 0.0;\n    } else {\n        return (square(diff-k))*1.0/(4.0*k);\n    }\n}\n\nfloat smax(float a, float b, float k) {\n        return max(a, b) + delta(k, abs(a-b));\n}\n\nfloat sdStick(vec3 p) {\n    float r = 0.5;\n    float line = length(vec3(p.x, max(abs(p.y)-r, 0.0), p.z));\n    return line - 0.01;\n}\n\nfloat gear(vec3 p, float angle) {\n    if (p.y > 0.0) {\n        angle += 0.5*6.28/12.0;\n    }\n    p.xz *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    vec2 q = p.xz;\n    \n\n    float segAngle = 6.28/12.0;\n    float segment = round(atan(p.z, p.x) / segAngle);\n    float theta = segment*segAngle;\n    mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    q = rot* q;\n    float teeth = sdBox(q - vec2(0.212, 0.0), vec2(0.04, 0.02));\n    \n    float ring = abs(length(p.xz) - 0.18) - 0.03;\n    float gear2d = min(teeth, ring);\n    float boundingSphere = abs(length(p) - 0.5) - 0.02;\n    float gear = smax(gear2d, boundingSphere, 0.005) - 0.005;\n    \n    return min(sdCross(p), min(sdStick(p), gear));\n}\n\nfloat gears(vec3 p) {\n    \n    float segAngle = 6.28/6.0;\n    float d = 1000.0;\n    for (int j = 0; j < 2; j++) {\n        vec3 p1 = p;\n        float theta = float(j)*6.28/4.0;\n        mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\t\tp1.xz *= rot;\n\n    for (int i = -1; i < 2; i++) {\n\t\tvec3 p2 = p1;\n        float theta = float(i)*segAngle;\n\n        mat2 rot = mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n\n        p2.xy *= rot;\n        float offset;\n        float segment = 6.28/12.0;\n        switch(i) {\n            case -1: offset = 0.0; break;\n            case 0: offset = segment/2.0; break;\n            case 1: offset = 0.0; break;\n            default: offset = 0.0;\n        }\n        d = min(d, gear(p2, offset + 2.0*iTime*(i % 2 == 0 ? 1.0 : -1.0)));\n    }\n    }\n    return d;\n}\n    \nfloat scene(vec3 p) {\n    float sphere = length(p) - 0.1;\n    return min(sphere, gears(p));\n}\n\nvec3 getNorm(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p + vec3(epsilon, 0, 0))) - scene(vec3(p - vec3(epsilon, 0, 0))),\n        scene(vec3(p + vec3(0, epsilon, 0))) - scene(vec3(p - vec3(0, epsilon, 0))),\n        scene(vec3(p + vec3(0, 0, epsilon))) - scene(vec3(p - vec3(0, 0, epsilon)))\n        ));\n}\n\nvec3 march(ray r) { \n    for (int i = 0; i < maxIters; i++) {\n    \tfloat d = scene(r.o);\n        if (d < epsilon) {\n            return (getNorm(r.o) + 1.0)/2.0;\n        } else {\n            r.o += r.d*d;\n        }\n    }\n    return vec3(0);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 camPos = vec3((iMouse.x/iResolution.x-1.0)*sin(iTime), 2.0*(-iMouse.y/iResolution.y + 0.5), (iMouse.x/iResolution.x-1.0)*cos(iTime));\n    vec3 lookAt = vec3(0);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 camForward = normalize(lookAt - camPos);\n    vec3 camRight = cross(camForward, worldUp);\n    vec3 camUp = cross(camRight, camForward);\n    \n    vec2 filmSize = vec2(1.0, iResolution.y/iResolution.x);\n    vec3 filmCentre = camPos + camForward*0.3;\n    \n    vec3 col = vec3(0);\n    for (int i = 0; i < subdivisions; i++) {\n        for (int j = 0; j < subdivisions; j++) {\n        \tvec2 uv;\n            uv.x = (fragCoord.x + float(i)/float(subdivisions) - 0.5)/iResolution.x - 0.5;\n            uv.y = (fragCoord.y + float(j)/float(subdivisions) - 0.5)/iResolution.y - 0.5;\n        \t\n            vec3 filmPos = filmCentre + filmSize.x*uv.x*camRight + filmSize.y*uv.y*camUp;\n    \t\tray r = ray(camPos, normalize(filmPos - camPos));    \n    \t\tcol += march(r);\n    \t}\n    }\n    fragColor = vec4(col/float(subdivisions*subdivisions), 1.0);\n}","name":"Image","description":"","type":"image"}]}