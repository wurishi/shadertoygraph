{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define ENABLE_REFLECTIONS\n//#define ENABLE_SHADOWS\n\n#define MATERIAL_FLOOR 0\n#define MATERIAL_WALL 1\n#define MATERIAL_CARPET 2\n#define MATERIAL_PICTURE_FIRST 3\n#define PICTURE_COUNT 9\n\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\nvec4 planeDistance(vec3 pos, vec3 center, vec3 normal) {\n    vec3 delta = pos - center;\n    float dist = dot(delta, normal);\n    vec3 surface = pos - normal * dist;\n    return vec4(surface, dist);\n}\n\nvec3 rectDistance(vec3 pos, vec3 center, vec3 normal, float size) {\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    if (abs(dot(up, normal)) > 0.9) {\n        up = vec3(0.0, 0.0, 1.0);\n    }\n    vec3 left = normalize(cross(up, normal));\n    up = normalize(cross(normal, left));\n    \n    vec3 localPos = pos - center;\n    \n\tfloat u = clamp(dot(localPos, up), -size, size);\n    float v = clamp(dot(localPos, left), -size, size);\n    \n    vec3 clampPos = center + up * u + left * v;\n    \n    return vec3(length(clampPos - pos), v/size, u/size);\n}\n\nfloat boxDistance(vec3 pos, vec3 center, vec3 scale) {\n    vec3 localPos = pos - center;\n    vec3 boxPos = clamp(localPos, -scale*0.5, scale*0.5);\n    return length(pos - boxPos - center);\n}\n\nvec2 segDistance(vec3 pos, vec3 start, vec3 end, float radius) {\n    // thanks to iq\n    vec3 a = pos - start;\n    vec3 b = end - start;\n   \tfloat prod = dot(a, b);\n    float norm = prod / dot(b,b);\n    norm = clamp(norm, 0.0, 1.0);\n    vec3 segPos = start * (1.0 - norm) + end * norm;\n    return vec2(length(pos - segPos) - radius, norm);\n}\n\nmat3 combinedDistance(vec3 pos) {\n\tfloat dist;\n    float material;\n    vec3 shadingParameters;\n   \n    vec4 ground = planeDistance(pos, vec3(0.0,-1.0,0.0), vec3(0.0,1.0,0.0));\n    dist = ground.w;\n    material = float(MATERIAL_FLOOR);\n    shadingParameters.xy = ground.xz;\n    \n    float side = pos.x < 0.0 ? 1.0 : -1.0;\n    vec4 wall = planeDistance(pos, vec3(-3.0*side,0.0,0.0), vec3(1.0*side,0.0,0.0));\n    if (wall.w < dist) {\n        dist = wall.w;\n        material = float(MATERIAL_WALL);\n        shadingParameters.xy = wall.zy;\n    }\n\n    float modPos = floor(pos.z/5.0+0.5);\n    vec3 screen = rectDistance(pos, vec3(-2.9*side, 1.0, modPos*5.0), vec3(-1.0*side,0.0,0.0), 1.0);\n    if (screen.x < dist) {\n        dist = screen.x;\n        float screenIndex = abs(modPos) + side;\n        material = floor(mod(screenIndex, float(PICTURE_COUNT)));\n        material += float(MATERIAL_PICTURE_FIRST);\n        shadingParameters.xy = screen.yz;\n    }\n\n    vec3 frame = rectDistance(pos, vec3(-2.95*side, 1.0, modPos*5.0), vec3(-1.0*side,0.0,0.0), 1.2);\n    if (frame.x < dist) {\n        dist = frame.x;\n        material = float(MATERIAL_FLOOR);\n        shadingParameters.xy = frame.yz;\n    }\n\n    float timberHeight = 10.0;\n    float modTimberPos = floor(pos.z/10.0+0.5);\n    float timber = boxDistance(pos, vec3(-3.0*side,0.0,2.5+modTimberPos*10.0), vec3(1.0, timberHeight, 0.5));\n    if (timber < dist) {\n        dist = timber;\n        material = float(MATERIAL_FLOOR);\n    }\n    \n    float timberHigh = boxDistance(pos, vec3(-3.0*side,timberHeight/2.0,pos.z), vec3(1.0, 1.0, 0.5));\n    if (timberHigh < dist) {\n        dist = timberHigh;\n        material = float(MATERIAL_FLOOR);\n    }\n    \n    vec3 carpet = rectDistance(pos, vec3(0.0, -0.99, pos.z), vec3(0.0, -1.0, 0.0), 1.0);\n    if (carpet.x < dist) {\n        dist = carpet.x;\n        material = float(MATERIAL_CARPET);\n    }\n                      \n    return mat3(dist, material, 0.0,\n                shadingParameters.x, shadingParameters.y, shadingParameters.z,\n                0.0, 0.0, 0.0);\n}\n\nfloat combinedDistanceOnly(vec3 pos) {\n\tmat3 d = combinedDistance(pos);\n    return d[0].x;\n}\n\nvec3 surfaceNormal(vec3 pos) {\n \tvec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = combinedDistanceOnly(pos + delta.xyz) - combinedDistanceOnly(pos - delta.xyz);\n    normal.y = combinedDistanceOnly(pos + delta.yxz) - combinedDistanceOnly(pos - delta.yxz);\n    normal.z = combinedDistanceOnly(pos + delta.zyx) - combinedDistanceOnly(pos - delta.zyx);\n    return normalize(normal);\n}\n\nfloat ambientOcclusion(vec3 origin, vec3 ray) {\n    float delta = 0.1;\n    const int samples = 6;\n    float r = 0.0;\n    for (int i = 1; i <= samples; ++i) {\n        float t = delta * float(i);\n     \tvec3 pos = origin + ray * t;\n        mat3 d = combinedDistance(pos);\n        float dist = d[0].x;\n        float len = abs(t - dist);\n        r += len * pow(2.0, -float(i));\n    }\n    return r;\n}\n\nmat3 trace(vec3 origin, vec3 ray, float far) {\n\tfloat t = 0.0;\n    float m = -1.0;\n    float s = 1.0;\n    vec3 shadingParameters;\n    for (int i = 0; i < 64; ++i) {\n        \n        vec3 pos = origin + ray * t;\n        \n\t\tmat3 r = combinedDistance(pos);\n        \n        vec3 d = r[0];\n        shadingParameters = r[1];\n        \n        if (abs(d.x) < 0.001) {\n       \t\tm = d.y;\n            break;\n        }\n        \n        m = d.y;\n     \tt += abs(d.x) * 0.5;\n        \n        if (t >= far) {\n         \tm = -1.0;\n            break;\n        }\n        \n        if (abs(d.x) > 0.1) {\n        \ts = min(s, abs(d.x)/t);\n        }\n    }\n    return mat3(t, m, s, /* distance, material, shadow blend */\n               \tshadingParameters.x, shadingParameters.y, shadingParameters.z,\n                0.0, 0.0, 0.0);\n}\n\nfloat prngNext(inout float state) {\n    // http://obge.paradice-insight.us/wiki/Includes_%28Effects%29\n    vec2 uv = vec2(state, state*2.0);\n    state += 0.01;\n\tfloat noise = (fract(sin(dot(uv ,vec2(12.9898,78.233)*2.0)) * 43758.5453));\n\treturn noise;\n}\n\nvec3 starfield(vec2 uv) {\n    float r = 0.0;\n    float prng = 1.0;\n    for (int i = 0; i < 64; ++i) {\n        vec3 starPos = vec3(prngNext(prng),prngNext(prng),prngNext(prng));\n        starPos.xy = (starPos.xy * 2.0 - 1.0) * 8.0;\n        float maxDepth = 5.0;\n        starPos.z = fract(starPos.z - iTime * 0.3) * maxDepth;\n        if (starPos.z < 0.0)  continue;\n        starPos.xy /= (starPos.z + 1.0) * 3.0;\n        vec2 delta = uv - starPos.xy;\n        float len = dot(delta, delta);\n        starPos.z /= maxDepth;\n        float fade = (1.0 - starPos.z) * starPos.z;\n        float shine = 1.0 / (1.0 * len * 500.0);\n        r += shine * fade;\n        r = min(r, 1.0);\n\n    }\n    return vec3(r, r, r);\n}\n\nvec3 plasma(vec2 uv) {\n\tvec2 center = uv - vec2(cos(iTime), sin(iTime));\n    float len = length(center);\n    float shade0 = sin(len * 10.0 + iTime) * 0.5 + 0.5;\n    \n    float theta = iTime * -1.0;\n    float phi = uv.x * sin(theta) + uv.y * cos(theta*2.0);\n    float shade1 = sin(phi * 10.0 + iTime);\n    \n    float shade2 = sin(uv.x * 10.0 + iTime * 2.0);\n    \n    float r = (shade0 + shade1 + shade2) / 3.0;\n    \n    return vec3(cos(r*3.14), sin(r*3.14), 0.0) * 0.5 + 0.5;\n}\n\nvec3 planeZoom(vec2 uv) {\n    vec3 origin = vec3(0.0, 0.0, iTime * 5.0);\n\tvec3 ray = normalize(vec3(uv, 1.0)) * xrotate(iTime) * zrotate(iTime);\n\tfloat ta = (-1.0 - origin.y) / ray.y;\n    float tb = (1.0 - origin.y) / ray.y;\n    float t = max(ta, tb);\n    vec3 view = origin + ray * t;\n    float mat = max(sign(ta-tb), 0.0);\n    vec3 tex = texture(iChannel1, view.xz * 0.01).xzy;\n    vec3 diff = mix(tex.yxz, tex.zyx, mat);\n    float fog = 1.0 / (1.0 + t * 0.1);\n    return diff * fog;\n}\n\nfloat cubeRotDistance(vec3 pos) {\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 size = vec3(1.0, 1.0, 1.0);\n    pos += vec3(0.0,0.0,-1.5);\n    pos *= yrotate(iTime) * zrotate(iTime);\n\treturn boxDistance(pos, center, size);\n}\n\nvec3 cubeRot(vec2 uv) {\n\tvec3 ray = normalize(vec3(uv, 1.0));\n    float t = 0.0;\n    for (int i = 0; i < 16; ++i) {\n      \tfloat dist = cubeRotDistance(ray * t);\n\t\tif (dist < 0.0) {\n\t\t\tbreak;   \n\t\t}\n\t\tt += dist;\n    }\n    vec3 pos = ray * t;\n    vec3 delta = vec3(0.01, 0.0, 0.0);\n    vec3 normal;\n    normal.x = cubeRotDistance(pos+delta.xyz) - cubeRotDistance(pos-delta.xyz);\n    normal.y = cubeRotDistance(pos+delta.yxz) - cubeRotDistance(pos-delta.yxz);\n    normal.z = cubeRotDistance(pos+delta.zyx) - cubeRotDistance(pos-delta.zyx);\n    normal = normalize(normal);\n    float prod = max(dot(normal,-ray),0.0);\n    float fog = 1.0 - 1.0 / (1.0 + t);\n    return mix(vec3(fog, fog, fog), vec3(1.0,0.0,0.0), prod);\n}\n\nvec3 noise(vec2 uv) {\n    // http://obge.paradice-insight.us/wiki/Includes_%28Effects%29\n    vec2 pos = floor(uv * 16.0);\n    float noise = fract(sin(iTime+dot(pos ,vec2(12.9898,78.233)*2.0)) * 43758.5453);\n\tfloat r = abs(noise);\n    return vec3(r, r, r);\n}\n\nvec3 pulse(vec2 uv) {\n \tfloat theta = length(uv);\n    float x = sin(theta * 10.0 - iTime * 5.0);\n    x *= x;\n    float n = x * 0.5 + 0.5;\n    return vec3(0.0, n, 0.0);\n}\n\nvec3 mandelbrot(vec2 uv) {\n    uv.x = uv.x * 0.5 + 0.5;\n    uv.x = uv.x * 3.5 - 2.5;\n    uv.y *= 3.5 / 2.0;\n    vec2 misiurewicz = vec2(-0.1011, 0.9563);\n    uv -= misiurewicz;\n    uv *= 0.01 * (0.5 - sin(iTime) * 0.5);\n    uv += misiurewicz;\n    vec2 pos = vec2(0.0, 0.0);\n    vec2 escape = vec2(0.0, 0.0);\n    float dist = 100.0;\n    for (int i = 0; i < 32; ++i) {\n        pos = vec2(pos.x*pos.x - pos.y*pos.y, 2.0*pos.x*pos.y);\n        pos += uv;\n        dist = min(dist, distance(pos,escape));\n        if (dot(uv,uv) > 4.0) {\n            dist = 0.0;\n        \tbreak;   \n        }\n    }\n    dist = 1.0 / (1.0 + dist);\n    vec3 inner = vec3(0.0, 0.7, 0.9);\n    vec3 outer = inner * 0.3;\n    return mix(inner, outer, dist);\n}\n\nvec4 material(float type, vec3 shadingParameters) {\n    if (type == float(MATERIAL_FLOOR)) {\n     \tvec2 coords = shadingParameters.yx * 1.1;\n        return vec4(texture(iChannel1, coords).xyz, 0.5);\n    } else if (type == float(MATERIAL_WALL)) {\n     \tvec2 coords = sin(shadingParameters.xy * 0.3) * 0.5 + 0.5;\n        return vec4(texture(iChannel2, coords).xyz, 0.0);\n    } else if (type == float(MATERIAL_CARPET)) {\n     \treturn vec4(0.5, 0.0, 0.0, 0.0);\n    } else if (type == float(MATERIAL_PICTURE_FIRST+0)) {\n     \treturn vec4(starfield(shadingParameters.xy), 0.0);\n    } else if (type == float(MATERIAL_PICTURE_FIRST+1)) {\n     \treturn vec4(plasma(shadingParameters.xy), 0.0);  \n    } else if (type == float(MATERIAL_PICTURE_FIRST+2)) {\n        return vec4(planeZoom(shadingParameters.xy), 0.0);\n    } else if (type == float(MATERIAL_PICTURE_FIRST+3)) {\n        return vec4(cubeRot(shadingParameters.xy), 0.0);\n    } else if (type == float(MATERIAL_PICTURE_FIRST+4)) {\n        return vec4(noise(shadingParameters.xy), 0.0);\n    } else if (type == float(MATERIAL_PICTURE_FIRST+5)) {\n        return vec4(1.0,1.0,1.0,-1.0); /* mirror */\n    } else if (type == float(MATERIAL_PICTURE_FIRST+6)) {\n        vec3 ray = normalize(vec3(shadingParameters.xy, 1.0));\n        ray *= zrotate(iTime) * yrotate(iTime);\n        return vec4(texture(iChannel0, ray).xyz, 0.0);\n    } else if (type == float(MATERIAL_PICTURE_FIRST+7)) {\n        return vec4(pulse(shadingParameters.xy), 0.0);\n    } else if (type == float(MATERIAL_PICTURE_FIRST+8)) {\n        return vec4(mandelbrot(shadingParameters.xy), 0.0);\n    }\n    return vec4(1.0, 0.0, 1.0, 0.0); /* missing material */\n}\n\nvec4 shade(inout vec3 origin, inout vec3 ray) {\n    vec3 lighting = vec3(0.2, 0.2, 0.2) * 5.0;\n    vec3 lightingSpecular = vec3(0.0, 0.0, 0.0);\n    \n    float farPlane = 50.0;\n    \n\tmat3 traced = trace(origin, ray, farPlane);\n    vec3 t = traced[0];\n    \n    vec3 worldPos = origin + ray * t.x;\n    \n    vec3 normal = surfaceNormal(worldPos);\n    \n    float fresnel = 1.0 - max(dot(-ray, normal), 0.0);\n    \n    vec3 specular = normalize(reflect(ray, normal));\n    \n    if (t.y == -1.0) { /* sky */\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    \n    vec4 diff = material(t.y, traced[1]);\n        \n    const int lightCount = 1;\n    for (int i = -1; i <= lightCount; ++i) {\n        float theta = iTime * 1.0 + float(i) / float(lightCount) * 6.28;\n\n    \tfloat modTimberPos = floor(worldPos.z/10.0+0.5) + float(i);\n        vec3 lightPos = vec3(0.0, 2.0, 2.5+modTimberPos*10.0);\n        \n        vec3 surfaceToLight = lightPos - worldPos;\n        float lightDist = length(surfaceToLight);\n        surfaceToLight /= lightDist;\n        \n\n#ifdef ENABLE_SHADOWS\n        float lightVisible = 0.0;\n        mat3 lightTrace = trace(lightPos, -surfaceToLight, lightDist*0.999);\n        if (lightTrace[0].y == -1.0) {\n            //mat3 shadowTrace = trace(lightPos, -surfaceToLight, lightDist*0.9);\n            lightVisible = 1.0;//min(shadowTrace[0].z * 16.0, 1.0);\n        }\n#else\n        float lightVisible = 1.0;\n#endif\n        \n        lightVisible *= max(dot(surfaceToLight, normal), 0.0);\n        \n        vec3 lightReflection = reflect(-surfaceToLight, normal);\n        float lightSpecular = max(dot(-ray, lightReflection), 0.0);\n        lightSpecular = min(pow(0.2 + lightSpecular, 4.0), 1.0);\n        \n        float lightPower = lightVisible * 1.0 / (1.0 + lightDist*lightDist*0.01);\n        vec3 lightColour = vec3(1.0, 1.0, 1.0) * lightPower / float(lightCount);\n        \n        lighting += lightColour;\n        lightingSpecular += lightSpecular * lightColour;\n    }\n\n    float fog = 1.0 - t.x / farPlane;\n    \n    float aoc = 1.0 - ambientOcclusion(worldPos, -ray);\n    aoc = pow(max(aoc, 0.0), 8.0);\n    \n    vec3 final = aoc * fog * (diff.xyz * lighting) + lightingSpecular * 0.01;\n    \n    origin = worldPos + specular * 0.05;\n    ray = specular;\n                                 \n    if (diff.w < 0.0) {\n     \treturn vec4(lightingSpecular.xyz, 0.5);   \n    }\n    \n    return vec4(final, diff.w * fresnel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n    float theta = iTime * 0.1;\n    vec2 mouseNorm = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    mat3 rot = xrotate(-mouseNorm.y * 0.5) * yrotate(-mouseNorm.x * 3.14);\n    \n    if (iMouse.z < 1.0) {\n     \trot = mat3(1.0);   \n    }\n    \n    vec3 origin = vec3(0.0, 0.5, iTime);\n    vec3 ray = normalize(vec3(uv, 1.0/tan(70.0*0.00872664625))) * rot;\n    \n    vec3 result = vec3(0.0, 0.0, 0.0);\n    \n#ifdef ENABLE_REFLECTIONS\n    const int iter = 2;\n#else\n    const int iter = 1;\n#endif\n    \n    float gloss = 1.0;\n    \n    for (int i = 0; i < iter; ++i) {\n    \n        vec4 trace = shade(origin, ray);\n        \n\t\tresult += trace.xyz * gloss;\n        \n        gloss = trace.w;\n        \n        if (gloss == 0.0) {\n        \tbreak;   \n        }\n        \n    }\n    \n\tfragColor = vec4(result, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsSSzG","date":"1412976992","viewed":1375,"name":"The Gallery","username":"dila","description":"Simulated render-to-texture. I'd like render the scene from a different angle into one of the \"textures\", but you can't do recursion in shader code!","likes":43,"published":1,"flags":0,"usePreview":0,"tags":["noise","reflection","raymarch","texture","wood","render","gallery"],"hasliked":0,"parentid":"","parentname":""}}