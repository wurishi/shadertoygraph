{"ver":"0.1","info":{"id":"Nl2GDK","date":"1625249615","viewed":121,"name":"Dancing Barnsley Fern","username":"arifr123","description":"Barnsley fern iterated function system (IFS). Try full screen.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["ifs","barnsleyfern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define sq(x) dot(x, x)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    ivec2 resolution = ivec2(iResolution);\n    \n    vec4 state = texelFetch(iChannel0, coord, 0);\n\n    vec3 col = vec3(0);\n    \n    //col = vec3(unpack(state.zw)) / 10.;\n    if(state.x > 0.) col = vec3(1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    ivec2 resolution = ivec2(iResolution);\n    \n    fragColor = vec4(-1);\n    if(iFrame == 0)\n    {\n        const vec2 init = vec2(100.5, 100.5);\n        if(coord == ivec2(init))\n        {\n            fragColor.xy = init;\n        }\n        \n        return;\n    }\n\n    for(int i = 0; i < TRANSFORMATIONS_NUM; i++)\n    {           \n        for(int x = 0; x <= 1; x++)\n        for(int y = 0; y <= 1; y++)\n        {\n            ivec2 suspect = ivec2(transform(vec2(coord), i, true));\n            suspect += ivec2(x, y);\n            if(clamp(suspect, ivec2(0), resolution - 1) != suspect) continue;\n\n            vec4 state = texelFetch(iChannel0, suspect, 0);\n\n            if(state.x >= 0.)\n            {\n                vec2 newPosition = transform(state.xy, i, false);\n                if(ivec2(newPosition) == coord)\n                {\n                    fragColor.xy = newPosition;\n                }\n            }\n        }\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TRANSFORMATIONS_NUM 4\n\nmat3 get_transformation(int i);\nmat3 get_transformation(int i, bool invert);\nvec2 transform(vec2 v, int i, bool invert);\n\nmat3 _get_transformation(int i, float iTime)\n{\n    iTime *= 0.8;\n\n    switch(i)\n    {\n    case 0:\n        return  mat3(0.85 - 0.04 + 0.05 * sin(2. * iTime), 0.02 - 0.04 * cos(iTime), 0, \n                     -0.02 + 0.04 * cos(iTime), 0.85 + 0.015 * cos(3. * iTime), 1.6,\n                     0, 0, 1);\n        break;\n\n    case 1:\n        return mat3(0.20, -0.26, 0., \n                    0.23, 0.22, 1.6,\n                    0, 0, 1);\n        break;\n\n    case 2:\n        return mat3(-0.15, 0.28, 0, \n                    0.26, 0.24, 0.44,\n                    0, 0, 1);\n        break;\n    \n    case 3:\n        return  mat3(0.02, 0, 0, \n                     0, 0.3, 0,\n                     0, 0, 1);\n        break;\n    }\n}\n\n#define get_transformation(i, invert) _get_transformation(i, invert, iTime)\nmat3 _get_transformation(int i, bool invert, float iTime)\n{\n    if(invert)\n    {\n        return inverse(_get_transformation(i, iTime));\n    }\n    else\n    {\n        return _get_transformation(i, iTime);\n    }\n}\n\n#define transform(v, i, invert) _transform(v, i, invert, iResolution, iTime)\nvec2 _transform(vec2 v, int i, bool invert, vec3 iResolution, float iTime)\n{\n    vec2 shift = iResolution.xy * vec2(0.5, 0);\n    float scale = 12. / iResolution.y;\n\n    v -= shift;\n    v *= scale;\n    \n    vec2 res = (vec3(v, 1) * get_transformation(i, invert)).xy;\n    \n    res /= scale;\n    res += shift;\n    \n    return res;\n}\n\n#define myFloatBitsToInt(v) (floatBitsToInt(v) - (1 << 30))\n#define myIntBitsToFloat(v) intBitsToFloat((v) + (1 << 30))\n\nvec2 pack(ivec3 counters)\n{\n    int combined = counters[1] + (1 << 15) * counters[2];\n    return vec2(myIntBitsToFloat(counters[0]), myIntBitsToFloat(combined));\n}\n\nivec3 unpack(vec2 value)\n{\n    int combined = myFloatBitsToInt(value[1]);\n    return ivec3(myFloatBitsToInt(value[0]), combined % (1 << 15), combined / (1 << 15));\n}","name":"Common","description":"","type":"common"}]}