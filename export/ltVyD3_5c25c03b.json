{"ver":"0.1","info":{"id":"ltVyD3","date":"1538008493","viewed":196,"name":"Periodic2D Seeded Cellular Noise","username":"Markyparky56","description":"Adapted from Brian Sharpe's Cellular Noise Function","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","cellular","periodic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from Brian Sharpe's Cellular Noise from https://github.com/BrianSharpe/GPU-Noise-Lib/blob/master/gpu_noise_lib.glsl\nvoid FAST32_hash_2D( vec2 gridcell, const float seed, float period, out vec4 hash_0, out vec4 hash_1 )\t//\tgenerates 2 random numbers for each of the 4 cell corners\n{    \n    const vec2 OFFSET = vec2( 26.0, 161.0 );\n    const float DOMAIN = 71.0;\n    const vec2 SOMELARGEFLOATS = vec2( 951.135664, 642.949883 );\n    vec4 P = vec4( gridcell.xy, gridcell.xy + 1.0 );\n        \n    // Wrap by period\n    P = mod(P, period);\n    \n    P = P - floor(P * ( 1.0 / (DOMAIN + seed) )) * (DOMAIN + seed);\n    P += OFFSET.xyxy + vec4(seed);\n    P *= P;\n    P = P.xzxz * P.yyww;\n    hash_0 = fract( P * ( 1.0 / SOMELARGEFLOATS.x ) );\n    hash_1 = fract( P * ( 1.0 / SOMELARGEFLOATS.y ) );\n}\n\nvec4 Cellular_weight_samples( vec4 samples )\n{\n    samples = samples * 2.0 - 1.0;\n    //return (1.0 - samples * samples) * sign(samples);\t// square\n    return (samples * samples * samples) - sign(samples);\t// cubic (even more variance)\n}\n\n//\n//\tCellular Noise 2D\n//\tBased off Stefan Gustavson's work at http://www.itn.liu.se/~stegu/GLSL-cellular\n//\thttp://briansharpe.files.wordpress.com/2011/12/cellularsample.jpg\n//\n//\tSpeed up by using 2x2 search window instead of 3x3\n//\tproduces a range of 0.0->1.0\n//\nfloat Cellular2D(vec2 P, const float seed, float period)\n{\n    //\testablish our grid cell and unit position\n    vec2 Pi = floor(P);\n    vec2 Pf = P - Pi;\n\n    //\tcalculate the hash.\n    //\t( various hashing methods listed in order of speed )\n    vec4 hash_x, hash_y;\n    FAST32_hash_2D( Pi, seed, period, hash_x, hash_y );\n    //SGPP_hash_2D( Pi, hash_x, hash_y );\n\n    //\tgenerate the 4 random points\n#if 1\n    //\trestrict the random point offset to eliminate artifacts\n    //\twe'll improve the variance of the noise by pushing the points to the extremes of the jitter window\n    const float JITTER_WINDOW = 0.25;\t// 0.25 will guarentee no artifacts.  0.25 is the intersection on x of graphs f(x)=( (0.5+(0.5-x))^2 + (0.5-x)^2 ) and f(x)=( (0.5+x)^2 + x^2 )\n    hash_x = Cellular_weight_samples( hash_x ) * JITTER_WINDOW + vec4(0.0, 1.0, 0.0, 1.0);\n    hash_y = Cellular_weight_samples( hash_y ) * JITTER_WINDOW + vec4(0.0, 0.0, 1.0, 1.0);\n#else\n    //\tnon-weighted jitter window.  jitter window of 0.4 will give results similar to Stefans original implementation\n    //\tnicer looking, faster, but has minor artifacts.  ( discontinuities in signal )\n    const float JITTER_WINDOW = 0.4;\n    hash_x = hash_x * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, 1.0-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW);\n    hash_y = hash_y * JITTER_WINDOW * 2.0 + vec4(-JITTER_WINDOW, -JITTER_WINDOW, 1.0-JITTER_WINDOW, 1.0-JITTER_WINDOW);\n#endif\n\n    //\treturn the closest squared distance\n    vec4 dx = Pf.xxxx - hash_x;\n    vec4 dy = Pf.yyyy - hash_y;\n    vec4 d = dx * dx + dy * dy;\n    d.xy = min(d.xy, d.zw);\n    return min(d.x, d.y) * ( 1.0 / 1.125 );\t//\tscale return value from 0.0->1.125 to 0.0->1.0  ( 0.75^2 * 2.0  == 1.125 )\n}\n\nvec3 renderGrid(vec2 pos, float period, vec3 gridCol, vec3 colIn)\n{\n    pos.x = mod(pos.x, period*1.0);\n    pos.y = mod(pos.y, period*1.0);\n    float aa = 0.0000000025;\n    \n    vec2 toGrid = pos - round(pos);\n    if(pos.x > (toGrid.x - aa) && pos.x < (toGrid.x + aa)) return gridCol;\n    else if(pos.y > (toGrid.y - aa) && pos.y < (toGrid.y + aa)) return gridCol;\n   \telse return colIn;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    const float period = 7.0;\n    const float seed = 41.0;\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    uv *= 16.0;\n    uv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));    \n\n    vec3 col = vec3(Cellular2D(uv, seed, period));    \n   \n    vec2 griduv = (fragCoord - iResolution.xy * 0.5)/min(iResolution.x, iResolution.y);\n    griduv *= 16.0;\n    griduv += vec2(12.0*sin(iTime*0.25),-12.0*cos(-iTime*0.25));\n    col = renderGrid(griduv, period, vec3(1.0,0.0,0.0), col);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}