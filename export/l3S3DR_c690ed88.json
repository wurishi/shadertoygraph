{"ver":"0.1","info":{"id":"l3S3DR","date":"1708351951","viewed":277,"name":"20240219_0mix s4 arp visualized","username":"0b5vr","description":"The visual explanation of the arpeggio from 0mix section 4\n\nThe original shader: https://www.shadertoy.com/view/msGXWD","likes":14,"published":1,"flags":8,"usePreview":0,"tags":["2d","audio","arpeggio"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// == draw stuff ==\nvec4 drawTarget = vec4( 0.0, 0.0, 0.0, 1.0 );\nvec4 drawColor = vec4( 0.0 );\n\nvec4 blend( vec4 src, vec4 dst ) {\n  float a = mix( dst.a, 1.0, src.a );\n  return a == 0.0\n    ? vec4( 0.0 )\n    : vec4(\n      mix( dst.rgb * dst.a, src.rgb, src.a ) / a,\n      a\n    );\n}\n\nvoid drawSDF( float d ) {\n  float eps = 1.0 / iResolution.y;\n  float shape = linearstep( eps, -eps, d );\n  drawTarget = blend( drawColor * vec4( 1.0, 1.0, 1.0, shape ), drawTarget );\n}\n\nvoid drawCircle( vec2 p, float r ) {\n  drawSDF( length( p ) - r );\n}\n\nvoid drawCircleStroke( vec2 p, float r, float stroke ) {\n  drawSDF( abs( length( p ) - r ) - stroke );\n}\n\nvoid drawLine( vec2 p, vec2 tail, float stroke ) {\n  float h = dot( p, tail ) / dot( tail, tail );\n  drawSDF( length( p - tail * h ) - stroke );\n}\n\nvoid drawLineSeg( vec2 p, vec2 tail, float stroke ) {\n  float h = saturate( dot( p, tail ) / dot( tail, tail ) );\n  drawSDF( length( p - tail * h ) - stroke );\n}\n\nfloat sdbox2( vec2 p, vec2 size ) {\n  vec2 d = abs( p ) - size;\n  return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nvoid drawBox( vec2 p, vec2 size ) {\n  drawSDF( sdbox2( p, size ) );\n}\n\nvoid drawBoxStroke( vec2 p, vec2 size, float stroke ) {\n  drawSDF( abs( sdbox2( p, size ) ) - stroke );\n}\n\nvoid drawChar( vec2 p, int char, float size ) {\n  vec2 char2 = mod( floor( float( char ) * vec2( 1.0, 1.0 / 16.0 ) ), 16.0 ) / 16.0;\n  char2.y = 15.0 / 16.0 - char2.y;\n\n  float t = ( texture( iChannel0, char2 + saturate( p / size + 0.5 ) / 16.0 ).w - 0.5 ) * abs( size );\n  drawSDF( t );\n}\n\n// == step note metric stuff ==\nconst float STEP_INTERVAL = 0.15;\nconst float NOTE_INTERVAL = 0.08;\n\nfloat currentStep;\n\nfloat xToStep( float x ) {\n  float center = floor( currentStep / 16.0 ) * 16.0;\n  center += mix( -8.0, 8.0, smoothstep( 0.0, 2.0, mod( currentStep, 16.0 ) ) );\n  return x / STEP_INTERVAL + center;\n}\n\nfloat stepToX( float st ) {\n  float center = floor( currentStep / 16.0 ) * 16.0;\n  center += mix( -8.0, 8.0, smoothstep( 0.0, 2.0, mod( currentStep, 16.0 ) ) );\n  return ( st - center ) * STEP_INTERVAL;\n}\n\nfloat yToNote( float y ) {\n  return y / NOTE_INTERVAL + ARP_INDEX_RANGE / 2.0;\n}\n\nfloat noteToY( float note ) {\n  return NOTE_INTERVAL * ( note - ARP_INDEX_RANGE / 2.0 );\n}\n\nvec3 pitchToColor( float pitch ) {\n  return 0.5 + 0.5 * cos( TAU * pitch / 12.0 + TAU * vec3( 5.0, 1.0, 3.0 ) / 6.0 );\n}\n\n// == main ==\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  currentStep = mod( iTime / S2T, 256.0 );\n\n  vec2 uv = fragCoord / iResolution.xy;\n  vec2 p = ( uv * 2.0 - 1.0 ) * vec2( iResolution.x / iResolution.y, 1.0 );\n\n  vec2 pt = p;\n\n  float st = xToStep( p.x );\n  float sti = floor( st + 0.5 );\n  \n  // bg\n  drawTarget = vec4( 0.02, 0.04, 0.07, 1.0 );\n  \n  // note lines\n  {\n    float note = yToNote( p.y );\n    float notei = floor( note + 0.5 );\n\n    if ( 0.0 <= notei && notei <= ARP_INDEX_RANGE ) {\n      drawColor.xyz = mix(\n        pitchToColor( arpIndexToPitch( notei ) ),\n        vec3( 0.3 ),\n        smoothstep( 2.0, 0.0, abs( p.x ) )\n      );\n      drawColor.w = mix(\n        0.2,\n        0.5,\n        step( mod( notei, float( N_ARP_NOTES ) ), 0.5 )\n      );\n      drawLine( p - vec2( 0.0, noteToY( notei ) ), vec2( 1.0, 0.0 ), 0.002 );\n    }\n  }\n\n  // arp lines\n  {\n    float stepToDraw = st * ARP_K;\n    float anotherStepToDraw = fract( stepToDraw ) > 0.5 ? 1.0 : -1.0;\n    stepToDraw = floor( stepToDraw );\n    anotherStepToDraw += stepToDraw;\n\n    drawColor = vec4( 0.3, 0.5, 0.8, 0.4 );\n\n    drawLine(\n      p - vec2( stepToX( stepToDraw / ARP_K ), noteToY( 0.0 ) ),\n      vec2( STEP_INTERVAL, NOTE_INTERVAL * ARP_INDEX_RANGE * ARP_K ),\n      0.005\n    );\n\n    drawLine(\n      p - vec2( stepToX( anotherStepToDraw / ARP_K ), noteToY( 0.0 ) ),\n      vec2( STEP_INTERVAL, NOTE_INTERVAL * ARP_INDEX_RANGE * ARP_K ),\n      0.005\n    );\n  }\n\n  // step lines\n  {\n    float note = arp( sti );\n    float notey = noteToY( note );\n\n    drawColor.rgb = vec3( 1.0, 1.0, 1.0 );\n    drawColor.w = mix(\n      0.2 * smoothstep( 1.0, 0.0, abs( notey - p.y ) ),\n      0.3,\n      step( mod( sti, 4.0 ), 0.5 )\n    );\n    drawLine( p - vec2( stepToX( sti ), 0.0 ), vec2( 0.0, 1.0 ), 0.002 );\n  }\n\n  // note circles\n  for ( int i = -1; i <= 1; i ++ ) {\n    float stt = sti + float( i );\n    float note = arp( stt );\n    vec2 pt = p - vec2( stepToX( stt ), noteToY( note ) );\n    float elapsed = currentStep - stt;\n    float sizeAdd = 0.03 * step( 0.0, elapsed ) * exp( -0.5 * elapsed );\n    float pitch = arpIndexToPitch( note );\n    \n    drawColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    drawCircle( pt, 0.04 + sizeAdd );\n    drawColor = mix(\n      vec4( pitchToColor( pitch ), 1.0 ),\n      vec4( 0.6, 0.6, 0.6, 1.0 ),\n      0.1\n    );\n    drawCircle( pt, 0.03 + sizeAdd );\n  }\n\n  // current step line\n  {\n    drawColor = vec4( 1.0, 0.0, 0.3, 0.4 );\n    drawLine( p - vec2( stepToX( currentStep ), 0.0 ), vec2( 0.0, 1.0 ), 0.01 );\n  }\n  \n  fragColor = drawTarget;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define saturate(x) clamp(x,0.,1.)\n#define clip(x) clamp(x,-1.,1.)\n#define linearstep(a,b,t) saturate( ( (t)-(a) ) / ( (b)-(a) ) )\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define tri(p) (1.-4.*abs(fract(p)-0.5))\n\n// constants that you might want to tweak\nconst float BPM = 100.0;\n\nconst int N_ARP_NOTES = 8;\nconst float ARP_NOTES[] = float[](0.0, 0.0, 3.0, 3.0, 7.0, 7.0, 10.0, 14.0); // minor 9th\nconst float ARP_OCT_RANGE = 3.0;\nconst float ARP_INDEX_RANGE = float( N_ARP_NOTES ) * ARP_OCT_RANGE;\n\nconst float ARP_K = 0.615;\n\n// constants\nconst float PI = acos( -1.0 );\nconst float TAU = PI * 2.0;\nconst float SQRT2 = sqrt( 2.0 );\n\nconst float BPS = BPM / 60.0;\nconst float B2T = 1.0 / BPS;\nconst float S2T = 0.25 / BPS;\n\n// the arpeggio function\nfloat arp( float st ) {\n  return floor( ARP_INDEX_RANGE * fract( st * ARP_K ) );\n}\n\nfloat arpIndexToPitch( float fi ) {\n  int i = int( fi );\n  return ARP_NOTES[ i % N_ARP_NOTES ] + 12.0 * float( i / N_ARP_NOTES );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"const float P5 = exp2( 7.0 / 12.0 );\n\nfloat p2f( float p ) {\n  return 440.0 * exp2( ( p - 69.0 ) / 12.0 );\n}\n\nmat2 r2d( float t ) {\n  float c = cos( t );\n  float s = sin( t );\n  return mat2( c, s, -s, c );\n}\n\nvec2 mainSound( int samp, float time ) {\n  float beat = time / B2T;\n    \n  vec2 dest = vec2( 0.0 );\n\n  { // rim\n    float t = mod( time, B2T );\n\n    float env = exp( -300.0 * t );\n\n    float tt = t * mix( 1.0, 1.2, step( mod( time, 4.0 * B2T ), B2T ) );\n    dest += env * tanh( 4.0 * (\n      + tri( tt * 400.0 - 0.5 * env )\n      + tri( tt * 1500.0 - 0.5 * env )\n    ) );\n  }\n\n  { // arp\n    for ( int i = 0; i < 4; i ++ ) {\n      float fi = float( i );\n      float t = mod( time, S2T );\n      float st = mod( floor( time / S2T ) - 3.0 * fi, 256.0 );\n      \n      float env = exp( -10.0 * t );\n      float delayDecay = exp( -fi );\n\n      float note = arp( st );\n      float pitch = 42.0 + arpIndexToPitch( note );\n      float freq = p2f( pitch );\n      vec2 phase = t * freq + vec2( 0.5, 0.0 );\n\n      dest += 0.5 * env * delayDecay * (\n        + fract( phase ) - 0.5 // saw\n        + step( fract( 0.2 + 0.5 * phase ), vec2( 0.03 ) ) // -1 oct pwm\n        - step( fract( 0.7 + 0.5 * phase ), vec2( 0.03 ) ) // another -1 oct pwm\n        + fract( P5 * phase ) - 0.5 // p5 saw\n        + step( fract( 1.5 * phase ), vec2( 0.5 ) ) - 0.5 // 1.5 freq square (somewhat sounds better than p5)\n      ) * r2d( time );\n    }\n  }\n\n  return clip( dest );\n}\n","name":"Sound","description":"","type":"sound"}]}