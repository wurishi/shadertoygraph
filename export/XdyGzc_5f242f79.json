{"ver":"0.1","info":{"id":"XdyGzc","date":"1455538762","viewed":374,"name":"The twisting gherkins ","username":"elzeru","description":"Who are they ? Where are they from ?","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["3d","raytracing","gherkin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// The Twistin' Gherkins\n// By el Zeru\n// When 3D doodling leads you to dancing space condiments\n\nfloat stepize(float a, int nb)\n{\n \ta = float(int(a*float(nb)))/float(nb);   \n    return a;\n}\n\nvec4 cellShading(vec4 inputPixel, int nbColor)\n{\n    vec4 returnImage;\n\treturnImage.x = stepize(inputPixel.x, nbColor);\n    returnImage.y = stepize(inputPixel.y, nbColor);\n    returnImage.z = stepize(inputPixel.z, nbColor);\n    returnImage.a = inputPixel.a;\n    return returnImage; \n}\n\nvec4 lens(vec4 inputPixel, vec2 fragCoord, float amount)\n{\n    vec4 returnImage;\n    \n    vec2 lensShift = vec2(amount*abs(0.5-fragCoord.x/iResolution.x)\n                         ,amount*abs(0.5-fragCoord.y/iResolution.y));\n    vec4 lShift = vec4(texture(iChannel0,(fragCoord-lensShift) / iResolution.xy).xyzx);\n    vec4 rShift = vec4(texture(iChannel0,(fragCoord+lensShift) / iResolution.xy).xyzx);\n   \n    returnImage = vec4(lShift.r, inputPixel.g, rShift.b ,inputPixel.a);\n    \n    return returnImage; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 inputColor = vec4(texture(iChannel0,fragCoord / iResolution.xy).xyzx);\n   \n    fragColor = inputColor;\n    fragColor = lens(inputColor, fragCoord, 10.0);\n    fragColor.xyz = pow(fragColor.xyz,vec3(0.6))*2.0;   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.14159265359\n\nconst int PRIM_RAY_IT = 120 ;\nconst float PRIM_RAY_STEP = 0.01;\nconst float EPS_NOR = 0.01;\n\nstruct Impact {\n\tfloat d;\n    float lum;\n\tvec3 col;\n\tint refl;\n};\n\nstruct Light{\n\tvec3 p;\n    float r;    \n    float lum; \n    vec3 col;\n}\n\n\n\nlight = Light(vec3( 1.0, 1.0, 1.0), 0.01, 1.0, vec3(1.0,1.0,1.0));\n\n// A min function based on the distance for the Impact structures\nImpact getClosest( Impact p1, Impact p2 )\n{\n    if (p1.d<p2.d)\n    {\n        return p1;\n    }\n    else return p2;\n\n}\n\n//Shapes definition\nfloat dSphere( vec3 p, float s )\n{\n\treturn length(p)-s;\n}\n\nfloat dTerrain(vec3 p)\n{    \n    vec3 p2 = p + vec3(PI/2.0,PI/0.1,0.0);\n    float k=0.1;\n    \n    float rotation = iTime*0.2\n        +500.0*cos(p.z)/(1000.0+500.0*(cos(iTime*2.0)+cos(iTime*10.0)*0.45));\n         \n   \n    p2.x = p.x*cos(rotation) + p.y*sin(rotation);\n    p2.y = -p.x*sin(rotation) + p.y*cos(rotation);\n    \n    p2 = p2 + vec3(1.7,1.7,0.0);\n    \n    float peakFrequency = 25.0;\n    float peakAmplitude = 0.01;\n    float rv = (cos(p2.x)+peakAmplitude*cos(peakFrequency*p2.x))\n              *(cos(p2.y)+peakAmplitude*cos(peakFrequency*p2.y))\n              *(sin(p2.z)+peakAmplitude*sin(peakFrequency*p2.z)) +0.6;\n    float dth = 1.0;\n    \n    return rv; \n \n}\n\n//Return information about the closest primitives\nImpact map(in vec3 pos)\n{\n    float terrainDistance = dTerrain(pos);\n    vec3 terrainColour = texture(iChannel0, vec2( pos.x/10.0,pos.y/10.0)).xyz;\n    terrainColour = vec3(1.0,1.0-pos.x/10.0,pos.x/10.0);\n    Impact terrain = Impact(terrainDistance, 0.0, terrainColour, 0);\n    \n    //Light globe\n    float lightRadius = light.r;\n\tfloat lightDistance = dSphere( pos-light.p, lightRadius );\n    Impact light_p = Impact(lightDistance,light.lum, light.col, 0);\n    Impact closest = getClosest(terrain,light_p);\n    return closest;\n}\n\n//Compute the normal - Gradient of the distance function\nvec3 getNormal( in vec3 pos )\n{\n\tvec2 eps = vec2( EPS_NOR, 0.0 );\t\n\tvec3 nor = vec3(\n\t\tmap(pos+eps.xyy).d - map(pos-eps.xyy).d,\n\t\tmap(pos+eps.yxy).d - map(pos-eps.yxy).d,\n\t\tmap(pos+eps.yyx).d - map(pos-eps.yyx).d );\n    \n\treturn normalize(nor);\n}\n\n//Cast a ray from ro in direction d\nImpact castRay(in vec3 ro, in vec3 inputDir)\n{\t\n    vec3 dir = normalize(inputDir);\n    float t;\n    t = 0.1;\n    Impact impact;\n \tfor (int i = 0; i < PRIM_RAY_IT; i++)\n    {\n        impact = map(ro+t*dir);     \n        if(impact.d < t*0.002) {\n            impact.d = t + impact.d;\n            return impact;\n        }\n        t += impact.d*0.4;        \n    }\n    return Impact(0.0,0.0,vec3(0.0,0.0,0.0),-1);\n}\n\nvec3 tracePath(in vec3 po, in vec3 dir)\n{\n    vec3 p = po;\n    vec3 col_base = vec3(1.0);\n    vec3 col = vec3(0.0);\n    vec3 norm = getNormal(p);  \n\n    float fact_r = 1.0;\n    for (int i = 0; i<2 ;i++)\n        {  \n\t        Impact impact = castRay(p,dir);\n    \t    p = p + dir*impact.d;            \n            \n            vec3 norm = getNormal(p);             \n\t\t\t\n\t\t\tvec3 dirToLight0 = light.p - p;\n   \n\t\t\tImpact impactOnLight = castRay(p,dirToLight0);\n           \n            float e = (impactOnLight.lum * dot(dirToLight0, norm) )/(pow(impactOnLight.d+0.01,3.0));\n           \n            vec3 myCol = col_base*(impact.col*0.01)*1.0 + col_base*impact.col*e*4.0;\n\t\t\t\n            col_base = impact.col;             \t\n          \t  \t    \n    \t    col += myCol*fact_r;\n            \n            vec3 newPos = p - dir*impact.d;\n            \n            float distanceToEye = length((po - newPos));\n            \n            col = mix(col, vec3(.0), smoothstep(0., 25., distanceToEye));\n            \n            fact_r *=0.4;\n            \n            norm = getNormal(p);\n           \n            dir = reflect(dir, norm);   \n        }\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 positionShift = vec3(sin(iTime)*0.0, cos(iTime)*0.0, iTime*4.0);\n\n    vec3 eye = vec3(0.0, 0.0,-0.7) + positionShift \n        +vec3(sin(iTime*1.234)*0.2+sin(iTime*2.234)*0.1+sin(iTime*10.234)*0.01,\n        +sin(iTime*0.9234)*0.2+sin(iTime*2.234)*0.1+sin(iTime*4.9234)*0.05,              \n              0.0) ;\n    \n    light.p = positionShift+vec3(0.0,-0.0,-2.0);\n\n    float resRatio = iResolution.x/iResolution.y;\n    \n    vec3 pixelPos = vec3(fragCoord.xy/ iResolution.xy*vec2(resRatio,1.0)-vec2(0.5*resRatio,0.5),0.0) + positionShift;\n    \n    vec3 dir = normalize(pixelPos - eye);      \n        \n    dir = normalize (pixelPos - eye);\n        \n    vec3 col = tracePath(eye,dir);                  \n       \n    fragColor = vec4(col,1.0);\n    \n}","name":"Buf A","description":"","type":"buffer"}]}