{"ver":"0.1","info":{"id":"Ns2fz1","date":"1645717390","viewed":259,"name":"V-Cavity BSDF","username":"LeeTheDev","description":"A V-Cavity BSDF implementation using the GGX microfacet distribution. There might be a better way to implement this, but the point of this is to just be a brute force method to compare against and learn from. Is very slow.","likes":5,"published":1,"flags":48,"usePreview":1,"tags":["specular","brdf","diffuse","bsdf","vcavity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nPress \"M\" to reset accumulation without turning on/off the furnace test. \nPress up arrow to disable or enable the furnace test. \nPress down arrow to make the white furnace test into environment lighting and vice versa.\nPress left arrow to enable colored spheres for environment lighting and furnace test.\nPress right arrow to enable metal spheres. (Only works for the environment lighting and furnace test)\n\nTODO: Implement specular for the Estimate V-Cavity BSDF function\n*/\n\n/*\n    From here.\n\n    https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n*/\nconst mat3x3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3x3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v) {\n    vec3 a = v * (v + 0.0245786f) - 0.000090537f;\n    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = saturate(color);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = ACESFitted(texture(iChannel0, uv).rgb * 1.0);\n         col = LinearToSrgb(col);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define _square(x) (x*x)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define rcp(x) (1.0 / x)\n#define log10(x) (log2(x) / log2(10.0))\n#define coneAngleToSolidAngle(x) (tau*(1.0 - cos(x)))\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_M = 77;\n\nconst float pi = radians(180.0);\nconst float tau = radians(360.0);\nconst float rpi = 1./acos(-1.);\nconst float hpi = acos(0.);\nconst float phi = sqrt(5.) * .5 + .5;\nconst float pi4 = 12.5663706;\nconst float pidiv2 = pi * 0.5;\nconst float piSquared = pi*pi;\nconst float goldenAngle = tau / (phi + 1.0);\n\nconst vec3 lumacoeff_rec709 = vec3(0.2125, 0.7154, 0.0721);\n\nfloat square(in float x) {\n    return _square(x);\n}\n\nvec3 square(in vec3 x) {\n    return _square(x);\n}\n\nfloat cube(in float x) {\n    return x * x * x;\n}\n\nvec3 LinearToSrgb(vec3 linear) {\n    vec3 SRGBLo = linear * 12.92;\n    vec3 SRGBHi = (pow(abs(linear), vec3(1.0/2.4)) * 1.055) - 0.055;\n    vec3 SRGB = mix(SRGBHi, SRGBLo, step(linear, vec3(0.0031308)));\n    return SRGB;\n}\n\nvec3 SrgbToLinear(vec3 color) {\n    vec3 linearRGBLo = color / 12.92;\n    vec3 linearRGBHi = pow((color + 0.055) / 1.055, vec3(2.4));\n    vec3 linearRGB = mix(linearRGBHi, linearRGBLo, step(color, vec3(0.04045)));\n    return linearRGB;\n}\n\nvec2 sincos(float x) { return vec2(sin(x), cos(x)); }\n\nmat2 Rotate(float a) {\n    vec2 m;\n    m.x = sin(a);\n    m.y = cos(a);\n\treturn mat2(m.y, -m.x,  m.x, m.y);\n}\n\nvec2 Rotate(vec2 vector, float angle) {\n\tvec2 sc = sincos(angle);\n\treturn vec2(sc.y * vector.x + sc.x * vector.y, sc.y * vector.y - sc.x * vector.x);\n}\n\nvec3 Rotate(vec3 vector, vec3 axis, float angle) {\n\t// https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n\tvec2 sc = sincos(angle);\n\treturn sc.y * vector + sc.x * cross(axis, vector) + (1.0 - sc.y) * dot(axis, vector) * axis;\n}\n\nvec3 Rotate(vec3 vector, vec3 from, vec3 to) {\n\t// where \"from\" and \"to\" are two unit vectors determining how far to rotate\n\t// adapted version of https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula\n\n\tfloat cosTheta = dot(from, to);\n\tif (abs(cosTheta) >= 0.9999) { return cosTheta < 0.0 ? -vector : vector; }\n\tvec3 axis = normalize(cross(from, to));\n\n\tvec2 sc = vec2(sqrt(1.0 - cosTheta * cosTheta), cosTheta);\n\treturn sc.y * vector + sc.x * cross(axis, vector) + (1.0 - sc.y) * dot(axis, vector) * axis;\n}\n\nmat3 GetRotationMatrix(vec3 from, vec3 to) {\n\tfloat cosine = dot(from, to);\n\n\t//float tmp = SignExtract(cosine);\n\tfloat tmp = cosine < 0.0 ? -1.0 : 1.0;\n\t\t\ttmp = 1.0 / (tmp + cosine);\n\n\tvec3 axis = cross(to, from);\n\tvec3 tmpv = axis * tmp;\n\n\treturn mat3(\n\t\taxis.x * tmpv.x + cosine, axis.x * tmpv.y - axis.z, axis.x * tmpv.z + axis.y,\n\t\taxis.y * tmpv.x + axis.z, axis.y * tmpv.y + cosine, axis.y * tmpv.z - axis.x,\n\t\taxis.z * tmpv.x - axis.y, axis.z * tmpv.y + axis.x, axis.z * tmpv.z + cosine\n\t);\n}\n\nmat3 GetRotationMatrix(vec3 unitAxis, float angle) {\n    float cosine = cos(angle);\n\n    vec3 axis = unitAxis * sin(angle);\n    vec3 tmp = unitAxis - unitAxis * cosine;\n\n    return mat3(\n        unitAxis.x * tmp.x + cosine, unitAxis.x * tmp.y - axis.z, unitAxis.x * tmp.z + axis.y,\n        unitAxis.y * tmp.x + axis.z, unitAxis.y * tmp.y + cosine, unitAxis.y * tmp.z - axis.x,\n        unitAxis.z * tmp.x - axis.y, unitAxis.z * tmp.y + axis.x, unitAxis.z * tmp.z + cosine\n    );\n}\n\nfloat minof(vec2 x) { \n    return min(x.x, x.y); \n}\nfloat minof(vec3 x) { \n    return min(min(x.x, x.y), x.z); \n}\nfloat minof(vec4 x) { \n    x.xy = min(x.xy, x.zw); return min(x.x, x.y); \n}\n\nfloat maxof(vec2 x) { \n    return max(x.x, x.y); \n}\nfloat maxof(vec3 x) { \n    return max(max(x.x, x.y), x.z); \n}\nfloat maxof(vec4 x) { \n    x.xy = max(x.xy, x.zw); return max(x.x, x.y); \n}\n\nvec3 GenerateUnitVector(vec2 hash) {\n    hash.x *= tau; hash.y = hash.y * 2.0 - 1.0;\n    return vec3(vec2(sin(hash.x), cos(hash.x)) * sqrt(saturate(1.0 - hash.y * hash.y)), hash.y);\n}\n\nvec3 GenerateCosineVector(vec3 vector, vec2 xy) {\n    vec3 dir = GenerateUnitVector(xy);\n\n    if(vector + dir == vec3(0.0)) {\n        return vector;\n    } else {\n        return normalize(vector + dir);\n    }\n}\n\nvec2 RSI(vec3 pos, vec3 dir, float radius) {\n    float radiusSquared = square(radius);\n    float posDotDir = dot(pos, dir);\n    float endDist = posDotDir*posDotDir + radiusSquared - dot(pos, pos);\n\n    if(endDist < 0.0) return vec2(-1.0);\n\n    endDist = sqrt(endDist);\n    vec2 ret = -posDotDir + vec2(-endDist, endDist);\n\n    return ret;\n}\n\nbool IntersectSphere(in vec3 rayPosition, in vec3 rayDirection, in float radius, out float dist) {\n    vec2 sphereDists = RSI(rayPosition, rayDirection, radius);\n    \n    if(sphereDists.x > 0.001) {\n        dist = sphereDists.x;\n        return true;\n    } else {\n        dist = sphereDists.y;\n        if(dist < 0.001) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n}\n\nint LinePlaneIntersection(\n    vec3 Lo, vec3 Lv,\n    vec3 Po, vec3 Pn,\n    out float t\n) {\n    float NdotV = dot(Pn, Lv);\n    float NdotO = dot(Pn, Lo - Po);\n    if (NdotV == 0.0) {\n        if (NdotO == 0.0) {\n            return 2;\n        } else {\n            return 0;\n        }\n    }\n\n    t = NdotO / -NdotV;\n\n    return 1;\n}\n\nint RayPlaneIntersection(\n    vec3 Ro, vec3 Rv,\n    vec3 Po, vec3 Pn,\n    out float t\n) {\n    int tmp = LinePlaneIntersection(Ro, Rv, Po, Pn, t);\n    if (tmp == 1 && t < 0.0) {\n        return 0;\n    }\n    \n    if (dot(Rv, Pn) > 0.0) { return 0; }\n\n    return tmp;\n}\n\nuvec3 pcg3d(uvec3 v) {\n    // http://www.jcgt.org/published/0009/03/02/\n\tv = v*1664525u + 1013904223u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\tv ^= v >> 16u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\treturn v;\n}\nuvec4 pcg4d(uvec4 v) {\n\tv = v*1664525u + 1013904223u;\n\tv.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n\tv ^= v >> 16u;\n\tv.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n\treturn v;\n}\n\n// https://nullprogram.com/blog/2018/07/31/\nuint lowbias32(uint x) {\n\tx ^= x >> 16;\n\tx *= 0x7feb352du;\n\tx ^= x >> 15;\n\tx *= 0x846ca68bu;\n\tx ^= x >> 16;\n\treturn x;\n}\n\nuint randState;\nvoid InitRand(uint seed) { randState = lowbias32(seed); }\nuint RandNext() { return randState = lowbias32(randState); }\n#define RandNext2() uvec2(RandNext(), RandNext())\n#define RandNext3() uvec3(RandNext2(), RandNext())\n#define RandNext4() uvec4(RandNext3(), RandNext())\n#define RandNextF() (float(RandNext()) / float(0xffffffffu))\n#define RandNext2F() (vec2(RandNext2()) / float(0xffffffffu))\n#define RandNext3F() (vec3(RandNext3()) / float(0xffffffffu))\n#define RandNext4F() (vec4(RandNext4()) / float(0xffffffffu))\n\n//Complex numbers and functions\nstruct complexFloat {\n\tfloat r;\n\tfloat i;\n};\n\ncomplexFloat complexAdd(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a.r+b.r;\n\tc.i=a.i+b.i;\n\treturn c;\n}\n\ncomplexFloat complexAdd(float a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a+b.r;\n\tc.i= +b.i;\n\treturn c;\n}\n\ncomplexFloat complexAdd(complexFloat a, float b) {\n\tcomplexFloat c;\n\tc.r=a.r+b;\n\tc.i=  a.i;\n\treturn c;\n}\n\ncomplexFloat complexSub(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a.r-b.r;\n\tc.i=a.i-b.i;\n\treturn c;\n}\n\ncomplexFloat complexSub(complexFloat a, float b) {\n\tcomplexFloat c;\n\tc.r=a.r-b;\n\tc.i=  a.i;\n\treturn c;\n}\n\ncomplexFloat complexSub(float a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a-b.r;\n\tc.i= -b.i;\n\treturn c;\n}\n\ncomplexFloat complexMul(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tc.r=a.r*b.r-a.i*b.i;\n\tc.i=a.i*b.r+a.r*b.i;\n\treturn c;\n}\n\ncomplexFloat complexMul(float x, complexFloat a) {\n\tcomplexFloat c;\n\tc.r=x*a.r;\n\tc.i=x*a.i;\n\treturn c;\n}\n\ncomplexFloat complexMul(complexFloat x, float a) {\n\tcomplexFloat c;\n\tc.r=x.r*a;\n\tc.i=x.i*a;\n\treturn c;\n}\n\ncomplexFloat complexSquare(complexFloat x) {\n    return complexMul(x, x);\n}\n\ncomplexFloat complexConjugate(complexFloat z) {\n\tcomplexFloat c;\n\tc.r=z.r;\n\tc.i = -z.i;\n\treturn c;\n}\n\ncomplexFloat complexDiv(complexFloat a, complexFloat b) {\n\tcomplexFloat c;\n\tfloat r,den;\n\tif (abs(b.r) >= abs(b.i)) {\n\t\tr=b.i/b.r;\n\t\tden=b.r+r*b.i;\n\t\tc.r=(a.r+r*a.i)/(den);\n\t\tc.i=(a.i-r*a.r)/(den);\n\t} else {\n\t\tr=b.r/b.i;\n\t\tden=b.i+r*b.r;\n\t\tc.r=(a.r*r+a.i)/(den);\n\t\tc.i=(a.i*r-a.r)/(den);\n\t}\n\treturn c;\n}\n\nfloat complexAbs(complexFloat z) {\n\treturn sqrt(z.r*z.r + z.i*z.i);\n}\n\ncomplexFloat complexSqrt(complexFloat z) {\n\tcomplexFloat c;\n\tfloat x,y,w,r;\n\tif ((z.r == 0.0) && (z.i == 0.0)) {\n\t\tc.r=0.0;\n\t\tc.i=0.0;\n\t\treturn c;\n\t} else {\n\t\tx=abs(z.r);\n\t\ty=abs(z.i);\n\t\tif (x >= y) {\n\t\t\tr=y/x;\n\t\t\tw=sqrt(x)*sqrt(0.5*(1.0+sqrt(1.0+r*r)));\n\t\t} else {\n\t\t\tr=x/y;\n\t\t\tw=sqrt(y)*sqrt(0.5*(r+sqrt(1.0+r*r)));\n\t\t}\n\t\tif (z.r >= 0.0) {\n\t\t\tc.r=w;\n\t\t\tc.i=z.i/(2.0*w);\n\t\t} else {\n\t\t\tc.i=(z.i >= 0.0) ? w : -w;\n\t\t\tc.r=z.i/(2.0*c.i);\n\t\t}\n\t\treturn c;\n\t}\n}\n\ncomplexFloat complexExp(complexFloat z) {\n\treturn complexMul(exp(z.r), complexFloat(cos(z.i), sin(z.i)));\n}\n\ncomplexFloat complexLog(complexFloat z) {\n    return complexFloat(0.5 * log(z.r * z.r + z.i * z.i), atan(z.i, z.r));\n}\n\ncomplexFloat complexSinh(complexFloat z) {\n    return complexFloat(sinh(z.r) * cos(z.i), cosh(z.r) * sin(z.i));\n}\ncomplexFloat complexCosh(complexFloat z) {\n    return complexFloat(cosh(z.r) * cos(z.i), sinh(z.r) * sin(z.i));\n}\n\ncomplexFloat complexSin(complexFloat z) {\n\tz = complexDiv(complexSub(complexExp(complexMul(complexFloat(0.0, 1.0), z)), complexExp(complexMul(complexFloat(0.0, -1.0), z))), complexFloat(0.0, 2.0));\n    return z;\n}\ncomplexFloat complexCos(complexFloat z) {\n\tz = complexDiv(complexAdd(complexExp(complexMul(complexFloat(0.0, 1.0), z)), complexExp(complexMul(complexFloat(0.0, -1.0), z))), complexFloat(2.0, 0.0));\n    return z;\n}\ncomplexFloat complexArgument(complexFloat z) {\n  return complexFloat(atan(z.i, z.r), 0.0);\n}\ncomplexFloat complexArcsin(complexFloat z) {\n  return complexDiv(\n\t  complexLog(\n\t\t  complexAdd(\n\t\t\t  complexMul(complexFloat(0.0, 1.0), z), \n\t\t\t  complexMul(\n\t\t\t\t  sqrt(\n\t\t\t\t\t  complexAbs(\n\t\t\t\t\t\t  complexSub(1.0, complexSquare(z))\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t  complexExp(\n\t\t\t\t  complexMul(\n\t\t\t\t\t  complexFloat(0.0, 0.5), \n\t\t\t\t\t  complexArgument(\n\t\t\t\t\t\t  complexSub(1.0, complexSquare(z))\n\t\t\t\t\t  \t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t), \n\t\tcomplexFloat(0.0, 1.0)\n\t);\n}\n\ncomplexFloat vectorToComplex(vec2 z) {\n\treturn complexFloat(z.x, z.y);\n}\n\ncomplexFloat SnellsLaw(complexFloat theta_i, complexFloat n_i, complexFloat n_t) {\n    return complexArcsin(complexMul(complexDiv(n_i, n_t), complexSin(theta_i)));\n}\n\ncomplexFloat r_s(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexSub(complexMul(n_i, complexCos(theta_i)), complexMul(n_t, complexCos(theta_t))),\n        complexAdd(complexMul(n_i, complexCos(theta_i)), complexMul(n_t, complexCos(theta_t)))\n    );\n}\ncomplexFloat t_s(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexMul(2.0, complexMul(n_i, complexCos(theta_i))),\n        complexAdd(complexMul(n_i, complexCos(theta_i)), complexMul(n_t, complexCos(theta_t)))\n    );\n}\ncomplexFloat r_p(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexSub(complexMul(n_t, complexCos(theta_i)), complexMul(n_i, complexCos(theta_t))),\n        complexAdd(complexMul(n_t, complexCos(theta_i)), complexMul(n_i, complexCos(theta_t)))\n    );\n}\ncomplexFloat t_p(complexFloat theta_i, complexFloat theta_t, complexFloat n_i, complexFloat n_t) {\n    return complexDiv(\n        complexMul(2.0, complexMul(n_i, complexCos(theta_i))),\n        complexAdd(complexMul(n_t, complexCos(theta_i)), complexMul(n_i, complexCos(theta_t)))\n    );\n}\n\nfloat FresnelNonPolarized_R(in float cosTheta, in complexFloat n1, in complexFloat n2) {\n    complexFloat thetaI = complexFloat(acos(cosTheta), 0.0);\n    complexFloat thetaT = SnellsLaw(thetaI, n1, n2);\n\n    float Rs = square(complexAbs(r_s(thetaI, thetaT, n1, n2)));\n    float Rp = square(complexAbs(r_p(thetaI, thetaT, n1, n2)));\n\n    return saturate((Rs + Rp) * 0.5);\n}\n\nfloat FresnelNonPolarized_T(in float cosTheta, in complexFloat n1, in complexFloat n2) {\n    complexFloat thetaI = complexFloat(acos(cosTheta), 0.0);\n    complexFloat thetaT = SnellsLaw(thetaI, n1, n2);\n\n    if(complexAbs(complexSin(thetaT)) > 1.0) {\n        return 0.0;\n    }\n\n    float Ts = square(complexAbs(t_s(thetaI, thetaT, n1, n2)));\n    float Tp = square(complexAbs(t_p(thetaI, thetaT, n1, n2)));\n\n    complexFloat cosThetaI = complexCos(thetaI);\n    complexFloat cosThetaT = complexCos(thetaT);\n\n    float beamRatio = complexAbs(complexDiv(complexMul(n2, cosThetaT), complexMul(n1, cosThetaI)));\n\n    return saturate(beamRatio * (Ts + Tp) * 0.5);\n}\n\ncomplexFloat phase_change(complexFloat wavelength, float thickness, complexFloat theta_2) {\n    // not entirely sure this is correct yet\n    complexFloat path_length_wavelengths = complexDiv(complexMul(complexFloat(thickness, 0.0), complexCos(theta_2)), wavelength);\n    complexFloat path_length_phase_radians = complexMul(tau, path_length_wavelengths);\n    return complexExp(complexMul(complexFloat(0.0, 1.0), path_length_phase_radians));\n}\n\nvoid thin_film_amplitudes(\n    float incident_angle,\n    float incident_wavelength,\n    float thickness,\n    complexFloat n_1, // media on current side\n    complexFloat n_2, // media of thin film\n    complexFloat n_3, // media on other side\n    out complexFloat apparent_amplitude_s_reflected,\n    out complexFloat apparent_amplitude_p_reflected,\n    out complexFloat apparent_amplitude_s_transmitted,\n    out complexFloat apparent_amplitude_p_transmitted\n) {\n    // Wave propagation direction changes in the different media according to Snell's law\n    complexFloat theta_1 = complexFloat(incident_angle, 0.0);\n    complexFloat theta_2 = SnellsLaw(theta_1, n_1, n_2);\n    complexFloat theta_3 = SnellsLaw(theta_1, n_1, n_3);\n\n    // Wavelength also changes in the different media in a similar manner\n    complexFloat wavelength_1 = complexFloat(incident_wavelength, 0.0);\n    complexFloat wavelength_2 = complexMul(complexDiv(n_1, n_2), wavelength_1);\n    complexFloat wavelength_3 = complexMul(complexDiv(n_1, n_3), wavelength_1);\n\n    // compute wave amplitudes\n    complexFloat propagation_phase_change = phase_change(wavelength_2, thickness, theta_2);\n\n    complexFloat amplitude_s_incident_1_2    = complexFloat(1.0, 0.0);\n    complexFloat amplitude_s_reflected_1_2   = complexMul(amplitude_s_incident_1_2, r_s(theta_1, theta_2, n_1, n_2));\n    complexFloat amplitude_s_transmitted_1_2 = complexMul(amplitude_s_incident_1_2, t_s(theta_1, theta_2, n_1, n_2));\n    complexFloat amplitude_p_incident_1_2    = complexFloat(1.0, 0.0);\n    complexFloat amplitude_p_reflected_1_2   = complexMul(amplitude_p_incident_1_2, r_p(theta_1, theta_2, n_1, n_2));\n    complexFloat amplitude_p_transmitted_1_2 = complexMul(amplitude_p_incident_1_2, t_p(theta_1, theta_2, n_1, n_2));\n\n    complexFloat r_s_2_3 = r_s(theta_2, theta_3, n_2, n_3);\n    complexFloat t_s_2_3 = t_s(theta_2, theta_3, n_2, n_3);\n    complexFloat r_p_2_3 = r_p(theta_2, theta_3, n_2, n_3);\n    complexFloat t_p_2_3 = t_p(theta_2, theta_3, n_2, n_3);\n\n    complexFloat amplitude_s_incident_2_3    = complexMul(amplitude_s_transmitted_1_2, propagation_phase_change);\n    complexFloat amplitude_s_reflected_2_3   = complexMul(amplitude_s_incident_2_3, r_s_2_3);\n    complexFloat amplitude_s_transmitted_2_3 = complexMul(amplitude_s_incident_2_3, t_s_2_3);\n    complexFloat amplitude_p_incident_2_3    = complexMul(amplitude_p_transmitted_1_2, propagation_phase_change);\n    complexFloat amplitude_p_reflected_2_3   = complexMul(amplitude_p_incident_2_3, r_p_2_3);\n    complexFloat amplitude_p_transmitted_2_3 = complexMul(amplitude_p_incident_2_3, t_p_2_3);\n\n    complexFloat r_s_2_1 = r_s(theta_2, theta_1, n_2, n_1);\n    complexFloat t_s_2_1 = t_s(theta_2, theta_1, n_2, n_1);\n    complexFloat r_p_2_1 = r_p(theta_2, theta_1, n_2, n_1);\n    complexFloat t_p_2_1 = t_p(theta_2, theta_1, n_2, n_1);\n\n    apparent_amplitude_s_reflected   = amplitude_s_reflected_1_2;\n    apparent_amplitude_s_transmitted = amplitude_s_transmitted_2_3;\n    apparent_amplitude_p_reflected   = amplitude_p_reflected_1_2;\n    apparent_amplitude_p_transmitted = amplitude_p_transmitted_2_3;\n\n    complexFloat coeff_s_reflected   = complexMul(complexMul(r_s_2_1, r_s_2_3), complexMul(propagation_phase_change, propagation_phase_change));\n    complexFloat coeff_p_reflected   = complexMul(complexMul(r_p_2_1, r_p_2_3), complexMul(propagation_phase_change, propagation_phase_change));\n    complexFloat coeff_s_transmitted = complexMul(complexMul(r_s_2_3, r_s_2_1), complexMul(propagation_phase_change, propagation_phase_change));\n    complexFloat coeff_p_transmitted = complexMul(complexMul(r_p_2_3, r_p_2_1), complexMul(propagation_phase_change, propagation_phase_change));\n\n    complexFloat tmp_s_reflected = complexDiv(complexMul(amplitude_s_reflected_2_3, propagation_phase_change), complexSub(1.0, coeff_s_reflected));\n    complexFloat tmp_p_reflected = complexDiv(complexMul(amplitude_p_reflected_2_3, propagation_phase_change), complexSub(1.0, coeff_p_reflected));\n    complexFloat tmp_s_transmitted = complexDiv(complexMul(complexMul(complexMul(amplitude_s_reflected_2_3, propagation_phase_change), r_s_2_1), propagation_phase_change), complexSub(1.0, coeff_s_transmitted));\n    complexFloat tmp_p_transmitted = complexDiv(complexMul(complexMul(complexMul(amplitude_p_reflected_2_3, propagation_phase_change), r_p_2_1), propagation_phase_change), complexSub(1.0, coeff_p_transmitted));\n\n    apparent_amplitude_s_reflected   = complexAdd(apparent_amplitude_s_reflected,   complexMul(tmp_s_reflected,   t_s_2_1));\n    apparent_amplitude_p_reflected   = complexAdd(apparent_amplitude_p_reflected,   complexMul(tmp_p_reflected,   t_p_2_1));\n    apparent_amplitude_s_transmitted = complexAdd(apparent_amplitude_s_transmitted, complexMul(tmp_s_transmitted, t_s_2_3));\n    apparent_amplitude_p_transmitted = complexAdd(apparent_amplitude_p_transmitted, complexMul(tmp_p_transmitted, t_p_2_3));\n}\n\nfloat FresnelThinFilmInterferenceReflected(in float cosTheta, in float thickness, in float lambda, in complexFloat n0, in complexFloat n1, in complexFloat n2) {\n    complexFloat apparent_amplitude_s_reflected;\n    complexFloat apparent_amplitude_p_reflected;\n    complexFloat apparent_amplitude_s_transmitted;\n    complexFloat apparent_amplitude_p_transmitted;\n    thin_film_amplitudes(acos(cosTheta), lambda, thickness, n0, n1, n2, apparent_amplitude_s_reflected, apparent_amplitude_p_reflected, apparent_amplitude_s_transmitted, apparent_amplitude_p_transmitted);\n    return saturate((square(complexAbs(apparent_amplitude_s_reflected)) + square(complexAbs(apparent_amplitude_p_reflected))) / 2.0);\n}\n\nfloat FresnelThinFilmInterferenceTransmitted(in float cosTheta, in float thickness, in float lambda, in complexFloat n0, in complexFloat n1, in complexFloat n2) {\n    complexFloat apparent_amplitude_s_reflected;\n    complexFloat apparent_amplitude_p_reflected;\n    complexFloat apparent_amplitude_s_transmitted;\n    complexFloat apparent_amplitude_p_transmitted;\n    thin_film_amplitudes(acos(cosTheta), lambda, thickness, n0, n1, n2, apparent_amplitude_s_reflected, apparent_amplitude_p_reflected, apparent_amplitude_s_transmitted, apparent_amplitude_p_transmitted);\n\n    //Transmittance requires extra work to make sure things work correctly.\n\n    complexFloat theta_0 = complexFloat(acos(cosTheta), 0.0);\n    complexFloat theta_1 = SnellsLaw(theta_0, n0, n1);\n    complexFloat theta_2 = SnellsLaw(theta_0, n0, n2);\n\n    if(complexAbs(complexSin(theta_1)) > 1.0 || complexAbs(complexSin(theta_2)) > 1.0) {\n        return 0.0;\n    }\n\n    complexFloat cosThetaI = complexCos(theta_0);\n\n    complexFloat cosThetaT_1 = complexCos(theta_1);\n    complexFloat cosThetaT_2 = complexCos(theta_2);\n\n    float beamRatio = complexAbs(complexDiv(complexMul(n2, cosThetaT_2), complexMul(n0, cosThetaI)));\n\n    return saturate(beamRatio * (square(complexAbs(apparent_amplitude_s_transmitted)) + square(complexAbs(apparent_amplitude_p_transmitted))) / 2.0);\n}\n\n/*\n    BSDF Stuff\n*/\nfloat P1(float h) {\n    float value = (h >= -1.0 && h <= 1.0) ? 0.5 : 0.0;\n\n    return value;\n}\n\nfloat C1(float h) {\n    float value = min(1.0, max(0.0, 0.5 * (h + 1.0)));\n\n    return value;\n}\n\nfloat InvC1(float U) {\n    float h = max(-1.0, min(1.0, 2.0 * U - 1.0));\n\n    return h;\n}\n\nfloat Alpha_I(in vec3 wi, in vec2 alpha) {\n    float inverseSinTheta2 = 1.0 / (1.0 - square(wi.z));\n    float cosPhi2 = wi.x * wi.x * inverseSinTheta2;\n    float sinPhi2 = wi.y * wi.y * inverseSinTheta2;\n    float alpha_i = sqrt(cosPhi2 * alpha.x * alpha.x + sinPhi2 * alpha.y * alpha.y);\n    return alpha_i;\n}\n\nfloat P22(in vec2 slope, in vec2 alpha) {\n    if (any(equal(alpha, vec2(0.0)))) { return 0.0; }\n\tfloat tmp = 1.0 + square(slope.x)/square(alpha.x) + square(slope.y)/square(alpha.y);\n\tfloat value = 1.0 / (pi * alpha.x * alpha.y) / (tmp * tmp);\n\treturn value;\n}\n\nfloat Smith_Lambda(in vec3 wi, in vec2 alpha) {\n    if(wi.z > 0.9990) {\n        return 0.0;\n    }\n    if(wi.z < -0.9990) {\n        return -1.0;\n    }\n\n    float theta_I = acos(wi.z);\n    float a = 1.0 / tan(theta_I) / Alpha_I(wi, alpha);\n\n    float value = 0.5 * (-1.0 + sign(a) * sqrt(1.0 + 1.0/square(a)));\n    \n    return value;\n}\n\nfloat ProjectedArea(in vec3 wi, in vec2 alpha) {\n    if(wi.z > 0.9990) {\n        return 1.0;\n    }\n    if(wi.z < -0.9990) {\n        return 0.0;\n    }\n\n    float theta_I = acos(wi.z);\n    float sinTheta_I = sin(theta_I);\n\n    float alphaI = Alpha_I(wi, alpha);\n\n    float value = 0.5 * (wi.z + sqrt(square(wi.z) + square(sinTheta_I) * square(alphaI)));\n\n    return value;\n}\n\nvec2 SampleP22_11(in float theta_I, in vec2 U) {\n    vec2 slope;\n\n    if(theta_I < 0.0001) {\n        float theta = acos(sqrt((1.0f - U.x) / (U.x + 1.0f)));\n        float phi = tau * U.y;\n        slope = vec2(theta * cos(phi), theta * sin(phi));\n\n        return slope;\n    }\n\n    float sinTheta_I = sin(theta_I);\n    float cosTheta_I = cos(theta_I);\n    float tanTheta_I = tan(theta_I);\n\n    float slope_I = cosTheta_I/sinTheta_I;\n\n    float projectedArea = 0.5 * (cosTheta_I + 1.0);\n    if(projectedArea < 0.0001 || projectedArea != projectedArea) {\n        return vec2(0.0);\n    }\n\n    float c = 1.0 / projectedArea;\n\n    float A = 2.0 * U.x / cosTheta_I / c - 1.0;\n    float B = tanTheta_I;\n    float tmp = 1.0 / (square(A) - 1.0);\n\n    float D = sqrt(max(0.0, square(B) * square(tmp) - (square(A) - square(B)) * tmp));\n    vec2 slopeX = vec2(B*tmp - D, B*tmp + D);\n    slope.x = (A < 0.0 || slopeX.y > 1.0 / tanTheta_I) ? slopeX.x : slopeX.y;\n\n    float U2;\n    float S;\n\n    if(U.y > 0.5) {\n        S = 1.0;\n        U2 = 2.0 * (U.y - 0.5);\n    } else {\n        S = -1.0;\n        U2 = 2.0  * (0.5 - U.y);\n    }\n    float z = (U2 * (U2 * (U2 * 0.27385 - 0.73369)+0.46341)) / (U2 * (U2 * (U2 * 0.093073+0.309420) - 1.000000) + 0.597999);\n    slope.y = S * z * sqrt(1.0 + square(slope.x));\n\n    return slope;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define SCATTERING_EVENTS 40\n\nmat3 CalculateTBN(in vec3 normal) {\n    vec3 tangent = normalize(cross(normal, vec3(0, 1, 1)));\n    vec3 bitangent = cross(normal, tangent);\n    return mat3(tangent, bitangent, normal);\n}\n\nfloat StudentT_D(in vec3 omegaH, in float gamma, in vec2 alpha) {\n    //https://www.shadertoy.com/view/sdjXWw\n    float cosTheta = omegaH.z;\n    if(cosTheta <= 0.0) {\n        return 0.0;\n    }\n    \n    float cosThetaSquare = cosTheta * cosTheta;\n    float exponent = ((square(omegaH.x) / square(alpha.x)) + (square(omegaH.y) / square(alpha.y))) / cosThetaSquare;\n    float root = 1.0 + exponent / (gamma - 1.0);\n    float powRootGamma = pow(root, gamma);\n    \n    return 1.0 / (pi * alpha.x * alpha.y * square(cosThetaSquare) * powRootGamma);\n}\n\nvec3 StudentT_SampleD(in vec2 U, in float gamma, in vec2 alpha) {\n    /*\n        From: https://mribar03.bitbucket.io/projects/eg_2017/\n    */\n    //The closer to infinity gamma goes, the closer to Beckmann this becomes.\n    gamma = clamp(gamma, 1.501, 3.4e38); //This is to prevent the physically impossible case that occurs when gamma equals 1.5\n    float phi = atan((alpha.x / alpha.y) * tan(2.0 * pi * U.x)) + pi * round(2.0 * U.x);\n    float A = ((square(cos(phi)) / square(alpha.x)) + (square(sin(phi)) / square(alpha.y))) / (gamma - 1.0);\n    float theta = atan(sqrt(\n        (pow(1.0 - U.y, 1.0 / (1.0 - gamma)) - 1.0)\n        / A\n    ));\n\n    vec3 wm = normalize(vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta)));\n\n    return wm;\n}\n\nfloat D(in vec3 wm, in vec2 alpha) {\n    if(wm.z <= 0.0) {\n        return 0.0;\n    }\n    vec2 slope = -vec2(wm.x, wm.y) / wm.z;\n\n    float value = P22(slope, alpha);\n    return value / pow(normalize(wm).z, 4.0);\n}\n\nvec3 SampleD(in vec2 U, in vec2 alpha) {\n    float theta = acos(sqrt((1.0 - U.x) / ((alpha.x - 1.0) * U.x + 1.0)));\n    float phi   = tau * U.y;\n\n    vec3 wm = normalize(vec3(-cos(phi) * sin(theta), -sin(phi) * sin(theta), cos(theta)));\n\n    return wm;\n}\n\nvec3 SampleDGaussian(in vec2 U, in vec2 alpha) {\n    vec2 r = alpha * sqrt(U.x/(1.0-U.x));\n    float phi = tau * U.y;\n    vec2 slope = vec2(r.x * cos(phi), r.y * sin(phi));\n    \n    if(slope.x != slope.x || isinf(slope.x)) {\n        return vec3(0.0, 0.0, 1.0);\n    }\n\n    vec3 wm = normalize(vec3(-slope.x, -slope.y, 1.0));\n\n    return wm;\n}\n\nfloat HemisphericalAlbedo(in float n) {\n    /*\n        From: http://www.eugenedeon.com/project/hitchhikers/\n    */\n    float n2 = square(n);\n    float T_1 = (4.0 * (2.0 * n + 1.0)) / (3.0 * square(n + 1.0));\n    float T_2 = ((4.0 * cube(n) * (n2 + 2.0 * n - 1.0)) / (square(n2 + 1.0) * (n2 - 1.0))) - \n               ((2.0 * n2 * (n2 + 1.0) * log(n)) / square(n2 - 1.0)) +\n               ((2.0 * n2 * square(n2 - 1.0) * log((n * (n+1.0)) / (n-1.0))) / cube(n2 + 1.0));\n    return saturate(1.0 - 0.5 * (T_1 + T_2));\n}\n\nconst complexFloat n1 = complexFloat(1.00028, 0.0);\nconst complexFloat n2 = complexFloat(1.44000, 0.0);\n\nvec3 SampleFacetBSDF(in vec3 direction, in vec3 normal, inout vec3 throughput, in vec3 albedo) {\n    if(texelFetch(iChannel1, ivec2(KEY_RIGHT, 2), 0).x > 0.9) {\n        float F_M = FresnelNonPolarized_R(dot(direction, normal), n1, complexFloat(1.4, 1.2));\n\n        throughput *= F_M;\n\n        return reflect(-direction, normal);\n    } else {\n        float fresnel_R = FresnelNonPolarized_R(dot(normal, direction), n1, n2);\n        float fresnel_T = FresnelNonPolarized_T(dot(normal, direction), n1, n2);\n\n        float albedoLum = dot(albedo, lumacoeff_rec709);\n        float totalLum = albedoLum * fresnel_T + fresnel_R;\n        float specBounceProbability = fresnel_R / totalLum; //Probability that we do specular or diffuse reflection\n        bool specularBounce = specBounceProbability > RandNextF();\n\n        if(specularBounce) {\n            //Calculate specular reflection\n            throughput /= specBounceProbability;\n\n            throughput *= fresnel_R;\n\n            return reflect(-direction, normal);\n        } else {\n            //Calculate diffuse reflection\n            throughput /= 1.0 - specBounceProbability;\n\n            float energyConservationFactor = 1.0 - HemisphericalAlbedo(n2.r / n1.r);\n\n            throughput *= fresnel_T;\n\n            throughput /= energyConservationFactor;\n\n            vec3 newDirection = GenerateCosineVector(normal, RandNext2F());\n\n            throughput *= albedo;\n\n            float fresnelL_T = FresnelNonPolarized_T(dot(normal, newDirection), n1, n2);\n\n            throughput *= fresnelL_T;\n\n            return newDirection;\n        }\n    }\n}\n\nvec3 SampleBSDF_VCavity(in vec3 incomingDirection, inout vec3 throughput, in vec3 albedo, in vec2 alpha) {\n    vec2 U = RandNext2F();\n\n    vec3 microsurfacePlaneNormal[2];\n    vec3 sampledNormal = SampleD(U, alpha);\n    for (int i = 0; i < 2; i++) {\n        //Calculate the microfacet normal for each plane\n        float angle = float(i) * (tau / float(2));\n\n        microsurfacePlaneNormal[i] = GetRotationMatrix(vec3(0.0, 0.0, 1.0), angle) * sampledNormal;\n    }\n\n    float height = -tan(acos(sampledNormal.z));\n\n    vec3 rayPosition = vec3(sampledNormal.xy == vec2(0.0) ? vec2(0.0) : normalize(sampledNormal.xy) * (2.0 * RandNextF() - 1.0), 0.0);\n\n    vec3 oldIncomingDirection = incomingDirection;\n    bool isSpecular = false;\n    int scatteringOrder = 0;\n    while(scatteringOrder <= SCATTERING_EVENTS) {\n        vec3 normal;\n        vec3 point = rayPosition + incomingDirection * 3.4e38;\n\n        bool hit = false;\n        for (int i = 0; i < 2; ++i) {\n            //Calculate the normals for the whole cavity, as well as update the hit point on the cavity, and whether we hit anything or not\n            float t = 3.4e38;\n            int p = RayPlaneIntersection(\n                rayPosition, incomingDirection,\n                vec3(0.0, 0.0, height), microsurfacePlaneNormal[i],\n                t\n            );\n\n            if(p != 0) {\n                vec3 currentPoint = rayPosition + incomingDirection * t;\n                if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                    if(distance(rayPosition, currentPoint) < distance(rayPosition, point)) {\n                        normal = microsurfacePlaneNormal[i];\n                        point = currentPoint;\n                    }\n                    hit = true;\n                }\n            }\n        }\n\n        if(height == 1e35) {\n            break;\n        }\n\n        scatteringOrder++;\n\n        if(hit) {\n            rayPosition = point;\n\n            incomingDirection = SampleFacetBSDF(-incomingDirection, normal, throughput, albedo);\n        } else {\n            break;\n        }\n\n        if(height != height || incomingDirection.z != incomingDirection.z) {\n            return vec3(0.0, 0.0, 1.0);\n        }\n    }\n\n    if(scatteringOrder > SCATTERING_EVENTS) {\n        throughput = vec3(0.0);\n    }\n    \n    if(throughput != throughput) {\n        throughput = vec3(0.0);\n    }\n\n    return incomingDirection;\n}\n\nfloat VCavity_Shadowng(in vec3 incomingDirection, in vec3 outgoingDirection, in vec2 alpha) {\n    vec2 U = RandNext2F();\n\n    vec3 microsurfacePlaneNormal[2];\n    vec3 sampledNormal = SampleD(U, alpha);\n    for (int i = 0; i < 2; i++) {\n        //Calculate the microfacet normal for each plane\n        float angle = float(i) * (tau / float(2));\n\n        microsurfacePlaneNormal[i] = GetRotationMatrix(vec3(0.0, 0.0, 1.0), angle) * sampledNormal;\n    }\n\n    float height = -tan(acos(sampledNormal.z));\n\n    vec3 rayPosition = vec3(sampledNormal.xy == vec2(0.0) ? vec2(0.0) : normalize(sampledNormal.xy) * (2.0 * RandNextF() - 1.0), 0.0);\n\n    vec3 oldIncomingDirection = incomingDirection;\n\n    vec3 point = rayPosition + incomingDirection * 3.4e38;\n\n    bool hit = false;\n    for (int i = 0; i < 2; ++i) {\n        //Update the hit point on the cavity, and whether we hit anything or not\n        float t = 3.4e38;\n        int p = RayPlaneIntersection(\n            rayPosition, vec3(0, 0, -1),\n            vec3(0.0, 0.0, height), microsurfacePlaneNormal[i],\n            t\n        );\n\n        if(p != 0) {\n            vec3 currentPoint = rayPosition + vec3(0, 0, -1) * t;\n            if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                if(distance(rayPosition, currentPoint) < distance(rayPosition, point)) {\n                    point = currentPoint;\n                }\n                hit = true;\n            }\n        }\n    }\n\n    bool inShadow = false;\n    bool inView = true;\n\n    rayPosition = point;\n\n    for (int i = 0; i < 2; ++i) {\n        //Calculate the visibility of the facet\n        float t;\n        int p = RayPlaneIntersection(\n            rayPosition, incomingDirection,\n            vec3(0.0, 0.0, height), microsurfacePlaneNormal[i],\n            t\n        );\n\n        if(p != 0) {\n            vec3 currentPoint = rayPosition + incomingDirection * t;\n            if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                inView = false;\n            }\n        }\n    }\n\n    for (int i = 0; i < 2; ++i) {\n        //Calculate the shadowing of the facet\n        float t;\n        int p = RayPlaneIntersection(\n            rayPosition, outgoingDirection,\n            vec3(0.0, 0.0, height), microsurfacePlaneNormal[i],\n            t\n        );\n\n        if(p != 0) {\n            vec3 currentPoint = rayPosition + outgoingDirection * t;\n            if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                inShadow = true;\n            }\n        }\n    }\n    \n    float shadowing = 0.0;\n    if(!inShadow) {\n        shadowing = 1.0;\n    } else if(!inView) {\n        shadowing = 0.0;\n    }\n\n    return shadowing;\n}\n\nvec3 EstimateBSDF_VCavity(in vec3 incomingDirection, in vec3 outgoingDirection, in vec3 albedo, in vec2 alpha) {\n    vec3 estimate = vec3(0.0);\n    vec3 throughput = vec3(1.0);\n\n    vec2 U = RandNext2F();\n\n    vec3 microsurfacePlaneNormal[2];\n    vec3 sampledNormal = SampleD(U, alpha);\n    for (int i = 0; i < 2; i++) {\n        //Calculate the microfacet normal for each plane\n        float angle = float(i) * (tau / float(2));\n\n        microsurfacePlaneNormal[i] = GetRotationMatrix(vec3(0.0, 0.0, 1.0), angle) * sampledNormal;\n    }\n\n    float height = -tan(acos(sampledNormal.z));\n\n    vec3 rayPosition = vec3(sampledNormal.xy == vec2(0.0) ? vec2(0.0) : normalize(sampledNormal.xy) * (2.0 * RandNextF() - 1.0), 0.0);\n\n    bool d1_outside = incomingDirection.z < 0.0;\n    bool d2_outside = outgoingDirection.z > 0.0;\n\n    if (d1_outside != d2_outside) { return vec3(0.0); }\n\n    vec3 oldIncomingDirection = -incomingDirection;\n    bool isSpecular = false;\n    int scatteringOrder = 0;\n    while(scatteringOrder <= SCATTERING_EVENTS) {\n        vec3 normal;\n        vec3 point = rayPosition + incomingDirection * 3.4e38;\n\n        bool hit = false;\n        for (int i = 0; i < 2; ++i) {\n            //Calculate the normals for the whole cavity, as well as update the hit point on the cavity, and whether we hit anything or not\n            float t = 3.4e38;\n            int p = RayPlaneIntersection(\n                rayPosition, incomingDirection,\n                vec3(0.0, 0.0, height), microsurfacePlaneNormal[i],\n                t\n            );\n\n            if(p != 0) {\n                vec3 currentPoint = rayPosition + incomingDirection * t;\n                if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                    if(distance(rayPosition, currentPoint) < distance(rayPosition, point)) {\n                        normal = microsurfacePlaneNormal[i];\n                        point = currentPoint;\n                    }\n                    hit = true;\n                }\n            }\n        }\n\n        if(height == 1e35) {\n            break;\n        }\n\n        scatteringOrder++;\n\n        if(hit) {\n            rayPosition = point;\n\n            bool inShadow = false;\n            for (int i = 0; i < 2; ++i) {\n                //Calculate the shadowing\n                float t;\n                int p = RayPlaneIntersection(\n                    rayPosition, outgoingDirection,\n                    vec3(0.0, 0.0, height), microsurfacePlaneNormal[i],\n                    t\n                );\n\n                if(p != 0) {\n                    vec3 currentPoint = rayPosition + outgoingDirection * t;\n                    if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                        inShadow = true;\n                    }\n                }\n            }\n\n            if(alpha.x == 0.0 && alpha.y == 0.0) {\n                //This makes sure the bsdf does not break when roughness is zero.\n                inShadow = false;\n                normal = vec3(0.0, 0.0, 1.0);\n            }\n            \n            /*\n            for (int i = 0; i < 2; ++i) {\n                bool hitI = false;\n                bool hitJ = false;\n\n                if(dot(microsurfacePlaneNormal[i], outgoingDirection) < 0.0) { continue; }\n\n                vec3 direction3 = reflect(outgoingDirection, microsurfacePlaneNormal[i]);\n\n                vec3 point = rayPosition + direction3 * 3.4e38;\n\n                for (int j = 0; j < 2; ++j) {\n                    if(j == i) { continue; }\n                    float t;\n                    int p = RayPlaneIntersection(\n                        rayPosition, direction3,\n                        vec3(0.0, 0.0, height), microsurfacePlaneNormal[j],\n                        t\n                    );\n\n                    if(p != 0) {\n                        vec3 currentPoint = rayPosition + direction3 * t;\n                        if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                            if(distance(rayPosition, currentPoint) < distance(rayPosition, point)) {\n                                point = currentPoint;\n                            }\n                            hitJ = true;\n                        }\n                    }\n                }\n\n                float t;\n                int p = RayPlaneIntersection(\n                    rayPosition, direction3,\n                    vec3(0.0, 0.0, height), microsurfacePlaneNormal[i],\n                    t\n                );\n\n                bool hitIFirst = false;\n                if(p != 0) {\n                    vec3 currentPoint = rayPosition + direction3 * t;\n                    if(distance(rayPosition, currentPoint) < distance(rayPosition, point)) {\n                        hitIFirst = true;\n                    }\n                    if(currentPoint.z <= 0.0 && currentPoint.z >= height) {\n                        hitI = true;\n                    }\n                }\n\n                if(hitI && hitIFirst) {\n                    float F_M = FresnelNonPolarized_R(dot(-incomingDirection, normal), n1, complexFloat(1.4, 1.2));\n                    float F_MR = FresnelNonPolarized_R(dot(-direction3, microsurfacePlaneNormal[i]), n1, complexFloat(1.4, 1.2));\n                    float F = FresnelNonPolarized_R(dot(-direction3, microsurfacePlaneNormal[i]), n1, n2);\n\n                    float energyConservationFactor = 1.0 - HemisphericalAlbedo(n2.r / n1.r);\n\n                    vec3 diffuse  = albedo / pi;\n                         diffuse *= saturate(dot(-direction3, normal));\n                         diffuse *= FresnelNonPolarized_T(         dot(normal, -incomingDirection), n1, n2);\n                         diffuse *= FresnelNonPolarized_T(saturate(dot(normal, -direction3)), n1, n2);\n                         diffuse /= energyConservationFactor;\n                    \n                    if(texelFetch(iChannel1, ivec2(KEY_RIGHT, 2), 0).x > 0.9) {\n                        estimate += throughput * 0.0;\n                    } else {\n                        estimate += throughput * (diffuse * F);\n                    }\n                } else if(hitJ) {\n                    continue;\n                } else {\n                    continue;\n                }\n            }\n            */\n\n            bool metal = texelFetch(iChannel1, ivec2(KEY_RIGHT, 2), 0).x > 0.9;\n\n            if(!inShadow && !metal) {\n                float energyConservationFactor = 1.0 - HemisphericalAlbedo(n2.r / n1.r);\n\n                vec3 diffuse  = albedo / pi;\n                     diffuse *= saturate(dot(outgoingDirection, normal));\n                     diffuse *= FresnelNonPolarized_T(         dot(normal, -incomingDirection), n1, n2);\n                     diffuse *= FresnelNonPolarized_T(saturate(dot(normal, outgoingDirection)), n1, n2);\n                     diffuse /= energyConservationFactor;\n\n                estimate += throughput * diffuse;\n            }\n\n            incomingDirection = SampleFacetBSDF(-incomingDirection, normal, throughput, albedo);\n        } else {\n            break;\n        }\n\n        if(height != height || incomingDirection.z != incomingDirection.z) {\n            return vec3(0.0);\n        }\n    }\n    \n    vec3 halfway = normalize(oldIncomingDirection + outgoingDirection);\n    float F_M = FresnelNonPolarized_R(dot(oldIncomingDirection, halfway), n1, complexFloat(1.4, 1.2));\n    float F = texelFetch(iChannel1, ivec2(KEY_RIGHT, 2), 0).x > 0.9 ? F_M : FresnelNonPolarized_R(dot(oldIncomingDirection, halfway), n1, n2);\n    float G = VCavity_Shadowng(oldIncomingDirection, outgoingDirection, alpha);\n    float numerator = D(halfway, alpha) * F * G;\n    float denominator = 4.0 * outgoingDirection.z * oldIncomingDirection.z;\n    float specular = numerator / denominator;\n\n    return (estimate / outgoingDirection.z) + max(specular, 0.0);\n}\n\nvoid DoSphereShading(in vec3 rayDirection, in vec3 lightDirection, in vec3 sphereOrigin, in float roughness, inout vec3 result, inout bool hit) {\n    float hitDist;\n\n    vec3 albedo = SrgbToLinear(vec3(1.0, 0.7, 0.5));\n    if(IntersectSphere(sphereOrigin, rayDirection, 0.3, hitDist)) {\n        hit = true;\n        vec3 normals = normalize(sphereOrigin + rayDirection * hitDist);\n\n        mat3 tbnMatrix = CalculateTBN(normals);\n\n        mat3 tbnMatrix2 = GetRotationMatrix(tbnMatrix[2], normals) * tbnMatrix;\n        vec3 viewDirection   = rayDirection * tbnMatrix2;\n             viewDirection.z = sign(dot(rayDirection, tbnMatrix[2])) * abs(viewDirection.z);\n\n        vec3 halfway = normalize(lightDirection + -rayDirection);\n\n        float nDotV = dot(normals, -rayDirection);\n        float nDotL = saturate(dot(normals, lightDirection));\n        float nDotH = dot(normals, halfway);\n        float lDotV = dot(lightDirection, -rayDirection);\n        float vDotH = dot(-rayDirection, halfway);\n\n        result = pi * EstimateBSDF_VCavity(viewDirection, lightDirection * tbnMatrix2, albedo, vec2(roughness)) * nDotL;\n    } else if(!hit) {\n        hit = false;\n        result = SrgbToLinear(vec3(1.0));\n    }\n}\n\nvoid DoEnvironmentShading(in vec3 rayDirection, in vec3 sphereOrigin, in float roughness, inout vec3 result, inout bool hit) {\n    float hitDist;\n\n    vec3 albedo = SrgbToLinear(texelFetch(iChannel1, ivec2(KEY_LEFT, 2), 0).x > 0.9 ? vec3(1.0) : vec3(1.0, 0.7, 0.5));\n    if(IntersectSphere(sphereOrigin, rayDirection, 0.3, hitDist)) {\n        hit = true;\n        vec3 normals = normalize(sphereOrigin + rayDirection * hitDist);\n        mat3 tbnMatrix = GetRotationMatrix(vec3(0.0, 0.0, 1.0), normals);\n\n        mat3 tbnMatrix2 = GetRotationMatrix(tbnMatrix[2], normals) * tbnMatrix;\n        vec3 viewDirection   = rayDirection * tbnMatrix2;\n             viewDirection.z = sign(dot(rayDirection, tbnMatrix[2])) * abs(viewDirection.z);\n\n        vec3 throughput = vec3(1.0);\n        rayDirection = tbnMatrix2 * SampleBSDF_VCavity(viewDirection, throughput, albedo, vec2(roughness));\n\n        result = SrgbToLinear(texture(iChannel2, rayDirection).rgb) * throughput;\n    } else if(!hit) {\n        result = SrgbToLinear(texture(iChannel2, rayDirection).rgb);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitRand(uint(fragCoord.x) + uint(iResolution.x) * (uint(fragCoord.y) + uint(iResolution.y) * uint(iFrame)));\n\n    vec2 uv  = (gl_FragCoord.st * rcp(iResolution.xy)) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 aa = (RandNext2F() - 0.5) * rcp(iResolution.xy);\n\n    float frames = texture(iChannel0, gl_FragCoord.st * rcp(iResolution.xy)).a;\n\n    vec3 rayDirection = normalize(vec3((vec2(uv.x, uv.y) + aa) * tan(radians(6.0)), 1.0));\n    \n    vec3 sphereOrigin = vec3(0.0, 0.0, -10.0);\n    vec3 color = vec3(0.0);\n\n    if(texelFetch(iChannel1, ivec2(KEY_UP, 2), 0).x > 0.9) {\n        bool hit = false;\n\n        vec3 lightDirection1 = GetRotationMatrix(vec3(0.0, 1.0, 0.0), radians(45.0)) * -rayDirection;\n\n        DoSphereShading(rayDirection, lightDirection1, sphereOrigin + vec3(1.0, 0.0, 0.0), 0.0, color, hit);\n        DoSphereShading(rayDirection, lightDirection1, sphereOrigin + vec3(0.0, 0.0, 0.0), 0.5, color, hit);\n        DoSphereShading(rayDirection, lightDirection1, sphereOrigin - vec3(1.0, 0.0, 0.0), 1.0, color, hit);\n    } else {\n        bool hit = false;\n\n        DoEnvironmentShading(rayDirection, sphereOrigin + vec3(1.0, 0.0, 0.0), 0.0, color, hit);\n        DoEnvironmentShading(rayDirection,                       sphereOrigin, 0.5, color, hit);\n        DoEnvironmentShading(rayDirection, sphereOrigin - vec3(1.0, 0.0, 0.0), 1.0, color, hit);\n    }\n\n    vec3 previousColor = texture(iChannel0, gl_FragCoord.st * rcp(iResolution.xy)).rgb;\n\n    bool KeyM = texelFetch(iChannel1, ivec2(KEY_M, 1), 0).x > 0.9;\n    bool KeyUp = texelFetch(iChannel1, ivec2(KEY_UP, 1), 0).x > 0.9;\n    bool KeyDown = texelFetch(iChannel1, ivec2(KEY_DOWN, 1), 0).x > 0.9;\n    bool KeyLeft = texelFetch(iChannel1, ivec2(KEY_LEFT, 1), 0).x > 0.9;\n    bool KeyRight = texelFetch(iChannel1, ivec2(KEY_RIGHT, 1), 0).x > 0.9;\n\n    if(KeyM || KeyUp || KeyDown || KeyLeft || KeyRight) {\n        frames = 1.0;\n        previousColor = vec3(0.0);\n    }\n    \n    color = mix(previousColor, color, 1.0 / (frames += 1.0));\n    \n    fragColor = vec4(color, frames);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    vec3  src    = texture(iChannel0, rayDir).rgb;\n    float srcLum = dot(src, lumacoeff_rec709);\n    vec3 hdriHACK = src * (1.0 + srcLum * 2.8);\n\n    fragColor = texelFetch(iChannel1, ivec2(KEY_DOWN, 2), 0).x > 0.9 ? vec4(1.0) : vec4(hdriHACK * 0.5, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}