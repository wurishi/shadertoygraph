{"ver":"0.1","info":{"id":"ldy3DR","date":"1454286051","viewed":292,"name":"Horse ball","username":"SamGondelman","description":"WASD/arrows + space: move\nR: reset position\nMouse: rotate camera\nP: 3rd person\nN: draw normals\nM: draw depth\nB: anti-alias off\nV: draw AA edges\nH: toggle horse blending\n\nMovement is confined to within the white line.\n\nChange SCENE in Buffer B to 0-3!","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","raymarching","mouse","antialiasing","keyboard","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Depth Aware Fast Approximation Anti-Aliasing\n\t\n\tThis was an implementation I devised for the Ray project in CS123, somewhat\n\toptimized for GLSL.\n\n\tBased on differences in depths between neighboring pixels, a pixel is blurred\n\thorizontally, vertically, or both.\n\n\tHold B to turn off anti-aliasing for comparison\n\tHold V to visualize the edges that will be blurred\n\tHold M to draw the depth\n**/\n// Other constants\nconst float TMAX = 250.0;\n\n// Texel storage constants\nconst float KEY_M  = 77.5/256.0;\nconst float KEY_B  = 66.5/256.0;\nconst float KEY_V  = 86.5/256.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {    \n\tvec4 col = texture(iChannel0, fragCoord/iChannelResolution[0].xy);\n\n    if (texture(iChannel1, vec2(KEY_M, 0.25)).x > 0.5) {\t\t\t\t\t// Depth\n        fragColor = vec4(vec3(0.75*pow(col.w/TMAX, 0.25)),1.0);\n    } else if (texture(iChannel1, vec2(KEY_B, 0.25)).x < 0.5) {\t\t\t// FXAA\n        vec4 middle = col;\n        vec4 left = texture(iChannel0, (fragCoord+vec2(-1,0))/iChannelResolution[0].xy);\n        vec4 right = texture(iChannel0, (fragCoord+vec2(1,0))/iChannelResolution[0].xy);\n        vec4 top = texture(iChannel0, (fragCoord+vec2(0,-1))/iChannelResolution[0].xy);\n        vec4 bottom = texture(iChannel0, (fragCoord+vec2(0,1))/iChannelResolution[0].xy);\n\n        float h = abs((left.w-middle.w)/(right.w-middle.w));\n        float v = abs((top.w-middle.w)/(bottom.w-middle.w));\n\n        const float EDGE_THRESHOLD = 5.0;\n        const int BLUR_RADIUS = 5;\n\n        vec4 result = vec4(0.0);\n        float xRadius = float(BLUR_RADIUS)*step(EDGE_THRESHOLD, h);\n        float yRadius = float(BLUR_RADIUS)*step(EDGE_THRESHOLD, v);\n\n        if (texture(iChannel1, vec2(KEY_V, 0.25)).x > 0.5) {\t\t\t\t// AA edges\n            fragColor = vec4(col.xyz, 1.0);\n            float xStep = step(0.5, xRadius);\n            float yStep = step(0.5, yRadius);\n            fragColor.z = xStep + fragColor.z*(1.0-xStep);\n            fragColor.y = yStep + fragColor.y*(1.0-yStep);\n            return;\n        }\n\n        float total = 0.0;\n        for (int y = -BLUR_RADIUS; y <= BLUR_RADIUS; y++) {\n            for (int x = -BLUR_RADIUS; x <= BLUR_RADIUS; x++) {\n                float weightx = 1.0 - abs(float(x)/float(BLUR_RADIUS))*step(0.5, xRadius);\n                float weighty = 1.0 - abs(float(y)/float(BLUR_RADIUS))*step(0.5, yRadius);\n                float weight = weightx*weighty;\n                float xx = float(x)*step(0.5, xRadius);\n                float yy = float(y)*step(0.5, yRadius);\n                result += texture(iChannel0, (fragCoord+vec2(xx,yy))/iChannelResolution[0].xy)*weight;\n                total += weight;\n            }\n        }\n        result /= total;\n        fragColor = vec4(result.xyz, 1.0);\n    } else {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Normal\n        fragColor = vec4(col.xyz, 1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\tPlayer Movement\n\t\n\tThis buffer keeps track of the players position and velocity.\n\n\tPressing a key will set your goal velocity, and you will accelerate towards that\n\tvelocity non-linearly for smooth starts and stops.\n\n\tWASD/arrow keys to move\n\tSpace to use your jetpack.\n\n\tIf your machine is slower you might need to turn VEL_MAG up so you move faster.\n\n\tI used https://www.shadertoy.com/view/MddGzf to figure out how render buffers worked.\n\n\tPress R to reset your position\n**/\n// Math constants\nconst float PI = 3.14159265359;\nconst float EPS = 0.0001;\n\n// Texel addresses\nconst vec2 txPlayerPos = vec2(0.0,0.0);\nconst vec2 txPlayerVel = vec2(1.0,0.0);\n\n// Texel storage constants\nconst float KEY_SPACE = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_A  = 65.5/256.0;\nconst float KEY_S  = 83.5/256.0;\nconst float KEY_D  = 68.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\n// Other constants\nconst float PLAYER_HEIGHT = 1.0;\nconst float VEL_MAG = 50.0;\nconst float GRAVITY = -20.0;\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\n\n// Render buffer helpers\nvec4 loadValue(in vec2 re) {\n    return texture(iChannel0, (0.5 + re)/iChannelResolution[0].xy, -100.0);\n}\n\nfloat isInside(vec2 p, vec2 c) {\n    vec2 d = abs(p-0.5-c) - 0.5;\n    return -max(d.x,d.y);\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord) {\n    fragColor = (isInside(fragCoord, re) > 0.0) ? va : fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if(fragCoord.x > 2.0 || fragCoord.y > 1.0) discard;\n    \n    vec3 playerPos = loadValue(txPlayerPos).xyz;\n    vec3 playerVel = loadValue(txPlayerVel).xyz;\n    \n    if(iFrame == 0 || texture(iChannel1, vec2(KEY_R, 0.25)).x > 0.5) {\n        playerPos = vec3(30.0, 10.0, 0.0);\n        playerVel = vec3(0);\n    }\n    \n    vec3 goalVelocity = vec3(0.0);\n    \n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        m = vec2(0.495, 0.53);\n    }\n    vec3 w = VEL_MAG*normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n\tvec3 u = VEL_MAG*normalize(cross(w,UP));\n    \n    // WASD/arrow key movement\n    if (texture(iChannel1, vec2(KEY_UP, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_W, 0.25)).x > 0.5) {\n        goalVelocity += w;\n    }\n    if (texture(iChannel1, vec2(KEY_DOWN, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_S, 0.25)).x > 0.5) {\n        goalVelocity += -w;\n    }\n    if (texture(iChannel1, vec2(KEY_RIGHT, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_D, 0.25)).x > 0.5) {\n        goalVelocity += u;\n    }\n    if (texture(iChannel1, vec2(KEY_LEFT, 0.25)).x > 0.5 ||\n       texture(iChannel1, vec2(KEY_A, 0.25)).x > 0.5) {\n        goalVelocity += -u;\n    }\n    \n    // Jetpack\n    if (texture(iChannel1, vec2(KEY_SPACE, 0.25)).x > 0.5) {\n        goalVelocity += VEL_MAG/2.0*UP;\n    } else {\n        goalVelocity.y = playerVel.y;\n    }\n    \n    vec3 accel = 15.0*(goalVelocity - playerVel);\n    accel += vec3(0, GRAVITY, 0);\n    \n    playerVel = playerVel + accel * iTimeDelta;\n    playerPos += playerVel * iTimeDelta;\n    \n    if (playerPos.y < PLAYER_HEIGHT) {\n        playerPos.y = PLAYER_HEIGHT + EPS;\n        playerVel.y = 0.0;\n    }\n    \n    if (dot(playerPos.xz,playerPos.xz) > 100.0*100.0) {\n        playerPos.xz = (100.0-EPS)*normalize(playerPos.xz);\n        playerVel.xz = vec2(0.0);\n    }\n    \n    fragColor = vec4(0.0); \n    storeValue(txPlayerPos, vec4(playerPos,0.0), fragColor, fragCoord);\n    storeValue(txPlayerVel, vec4(playerVel,0.0), fragColor, fragCoord);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/** Raymarching\n\n\tThe scene is defined in map() and colored in computeColor().\n\n\tThere are 4 different scenes (change the SCENE variable below).\n\n\tYou can turn on effects by changing the macros below.\n\n\tWorks great on the machines with GTX 970s with everything on,\n\tbut on slower machines:\n\n*** DON'T TURN ON SHADOWS IF REFLECTIONS OR REFRACTIONS ARE ON ***\n\tit'll take forever to compile. \n\n\tReflections and refractions are done in render().\n\n\tCamera motion is in mainImage().\n\n\tClick and drag to move the camera\n\tHold P to show 3rd person\n\tHold N to draw normals\n\tHold H on SCENE 3 to turn off horse blending\n**/\n#define USE_REFLECTIONS 0\n#define NUM_REFLECTIONS 1\n#define USE_REFRACTIONS 0\n#define USE_SHADOWS 0\n#define USE_DAYNIGHT 1\n\n// Scenes:\n// 0 - balls (reflective + refractive)\n// 1 - temple (reflective)\n// 2 - tentacles (refractive)\n// 3 - horse (reflective)\n#define SCENE 3\n\n// Math constants\nconst float PI = 3.14159265359;\nconst float EPS = 0.0001;\nconst float FLT_MAX = 1.0 / 0.000000000001; // hacky but GLSL doesn't have a FLT_MAX by default\n\n// Raymarching constants\nconst float TMAX = 250.0;\nconst int MAX_STEPS = 200;\nconst float DIST_THRESHOLD = 0.00001;\n\n// Texel addresses\nconst vec2 txPlayerPos = vec2(0.0,0.0);\n\n// Texel storage constants\nconst float KEY_N  = 78.5/256.0;\nconst float KEY_P  = 80.5/256.0;\nconst float KEY_H  = 72.5/256.0;\n\n// Other constants\nconst vec3 UP = vec3(0.0, 1.0, 0.0);\nconst float DAY_LENGTH = 5.0;\nconst float GRID_SIZE = 0.75;\n\nstruct Ray {\n    vec3 src;\n    vec3 dir;\n    float t;\n    vec3 pos;\n    vec3 nor;\n    int matID;\n    int iter;\n};\n    \n// GLSL default parameters don't seem to work so this is for any call to map\n// where you don't actually care about the material of what you hit\nint junkMatID;\n\n// Perlin Noise\nfloat hash(float n) { return fract(sin(n)*753.5453123); }\n\nfloat interpolatedNoise2D(vec2 xy, int seed) {\n    vec2 p = floor(xy);\n    vec2 f = fract(xy);\n    f = f*f*(3.0-2.0*f);\n\n    float n = dot(vec3(p.xy, seed), vec3(1, 157, 141));\n    return mix(mix(hash(n+  0.0), hash(n+  1.0),f.x),\n               mix(hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nfloat perlinNoise2D(vec2 xy, float freq, float amp, int octaves, int seed){\n    float total = 0.0;\n    float totalScale = 0.0;\n    // current freq, amp, scale\n    vec3 currFAS = vec3(freq, amp, amp);\n    for(int i = 0; i < 5; i++){\n        total += interpolatedNoise2D(abs(xy) * currFAS.x, seed) * currFAS.y;\n        totalScale += currFAS.z;\n        currFAS *= vec3(2.0, 0.5, 0.5);\n        if (i >= octaves) break;\n    }\n    return amp * (total / totalScale);\n}\n\n// I wrote these primitive equations and CSG operations for my CS123 final\n// Primitives\nfloat plane(vec3 p) {\n    return p.y;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat roundedBox(vec3 p, vec3 dim, float r) {\n    vec3 d = abs(p) - dim;\n    return length(max(d,vec3(0.0))) - r;\n}\n\n// CSG operations\nfloat intersectionDist(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat subtractionDist(float d1, float d2) {\n    return max(d1, -d2);\n}\n\n// Transformations\nvec3 rX(vec3 p, float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    vec3 q = p;\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n    return p;\n}\n\nvec3 rY(vec3 p, float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    vec3 q = p;\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n    return p;\n}\n\nfloat blend(float a, float b, float k) {\n    float h = clamp(mix(1.0, (b-a)/k, 0.5), 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\n// On linux, mod doesn't work as expected for negative numbers\nvec3 repeat(vec3 p, vec3 r) {\n    p = abs(p);\n    return vec3(p.x - (r.x * floor(p.x/r.x)) - 0.5*r.x,\n                p.y - (r.y * floor(p.y/r.y)) - 0.5*r.y,\n                p.z - (r.z * floor(p.z/r.z)) - 0.5*r.z);\n//    return mod(p, r) - 0.5*r;\n}\n\nvoid propose(inout float val, inout int matID, float proposedVal, int proposedMatID) {\n\t// This doesn't work for some reason?\n//    float overridden = step(val, proposedVal);\n//    val = overridden * proposedVal + (1.0-overridden) * val;\n//    matID = int(overridden * float(proposedMatID) + (1.0-overridden) * float(matID));\n    if (proposedVal < val) {\n        val = proposedVal;\n        matID = proposedMatID;\n    }\n}\n\nfloat map(vec3 p, inout int matID, vec3 playerPos, bool drawPlayer, bool drawRefractive) {\n    float res = FLT_MAX;\n    \n#if (SCENE == 0) || (SCENE > 3)\n    // spheres\n    vec3 cen = vec3(0.0, 1.5, 0.0);\n    vec3 d = 0.5*normalize(vec3(1.0, 0, -1.0));\n    vec3 s = 0.4*vec3(0.0, sin(iTime), 0.0);\n    vec3 c = 0.4*vec3(0.0, cos(iTime), 0.0);\n    float disp = 0.03*sin(20.0*p.x+iTime)*sin(40.0*p.y+iTime)*sin(60.0*p.z+iTime);\n    disp *= (1.0 - smoothstep(-0.25, 0.25, cos(iTime/2.0)));\n    propose(res, matID, sphere(p-cen, 0.3)+disp, 3);\n    propose(res, matID, sphere(p-(cen+d.xyx+s), 0.15), 1);\n    propose(res, matID, sphere(p-(cen+d.xyz+c), 0.15), 1);\n    propose(res, matID, sphere(p-(cen+0.5*(-s.yxy)+0.5*vec3(0.0,1.0,0.0)), 0.15), 1);\n    \n    // refractive spheres\n    if (drawRefractive) {\n        propose(res, matID, sphere(p-(cen+d.zyz-s), 0.15), 2);\n    \tpropose(res, matID, sphere(p-(cen+d.zyx-c), 0.15), 2);\n    \tpropose(res, matID, sphere(p-(cen+0.5*(s.yxy)+0.5*vec3(0.0,-1.0,0.0)), 0.15), 2);\n    }\n    \n    // reflective cylinder\n    propose(res, matID, cylinder(p-vec3(0), 4.0, .15), 1);\n\n#elif (SCENE == 1)\n    //temple    \n    float pillars = intersectionDist(cylinder(p-vec3(-50.0, 2.5, 0.0), 8.0, 2.5),\n                                     cylinder(repeat(p-vec3(0.0,2.5,0.0), vec3(5,0,5)), 0.25, 2.5));    \n    float temple = subtractionDist(sphere(p-vec3(-50.0, 0.0, 0.0), 10.0),\n                                   cylinder(p-vec3(-50.0, 2.3, 0.0), 11.0, 2.5));\n    propose(res, matID, blend(pillars, temple, 1.4), 6); \n\n#elif (SCENE == 2)\n    if (drawRefractive) {\n        // blob arm        \n        float arm = cylinder(p-vec3(-50.0, 0.201, 0.0), 5.0, 0.1);\n        for (int i = 0; i < 11; i++) {\n            arm = blend(arm, sphere(p-vec3(-50.0+4.0*float(i)/10.0*cos(float(i+1)+iTime), i+1,\n                                           4.0*float(i)/10.0*sin(float(i+1)+iTime)),\n                                    float(10-i)/20.0 + 0.1), 1.0-float(i)/15.0);\n        }\n        propose(res, matID, arm, 2);\n    }\n    \n#elif (SCENE == 3)\n    // HORSE\n    float blendStep = step(texture(iChannel1, vec2(KEY_H, 0.25)).x, 0.5);\n    \n    float foot1 = roundedBox(rY(p-vec3(0.0,0.249,0.0), -45.0), vec3(0.11,0.09,0.12), 0.05);\n    float ankle1 = cylinder(rX(rY(p-vec3(-0.15,0.75,-0.15), -50.0), 15.0), 0.09, 0.4);\n    float leg1 = cylinder(rX(rY(p-vec3(-0.05,1.65,0.03), 145.0), 35.0), 0.12, 0.6);\n    float thigh1 = cylinder(rX(rY(p-vec3(-0.05,2.35,0.13), 75.0), -25.0), 0.3, 0.4);\n    float fullleg1 = blend(foot1, ankle1, 0.5*blendStep);\n    fullleg1 = blend(fullleg1, leg1, 0.5*blendStep);\n    fullleg1 = blend(fullleg1, thigh1, 0.7*blendStep);\n     \n    float foot2 = roundedBox(rY(p-vec3(0.0-1.5,0.249,0.0+2.0), -25.0), vec3(0.11,0.09,0.12), 0.05);\n    float ankle2 = cylinder(rX(rY(p-vec3(-0.15-1.5,0.69,-0.35+2.0), -20.0), 35.0), 0.09, 0.4);\n    float leg2 = cylinder(rX(rY(p-vec3(-0.05-1.5,1.59,-0.37+2.0), 145.0), 45.0), 0.12, 0.6);\n    float thigh2 = cylinder(rX(rY(p-vec3(-0.05-1.5,2.29,-0.27+2.0), -180.0), -25.0), 0.3, 0.4);\n    float fullleg2 = blend(foot2, ankle2, 0.5*blendStep);\n    fullleg2 = blend(fullleg2, leg2, 0.5*blendStep);\n    fullleg2 = blend(fullleg2, thigh2, 0.7*blendStep);\n    \n    float bod = cylinder(rX(rY(p-vec3(-0.15-0.25,3.5,-0.35+1.75), -40.0), -45.0), 0.7, 1.0);\n    float lowerhalf = blend(fullleg1, bod, 1.3*blendStep);\n    lowerhalf = blend(lowerhalf, fullleg2, 1.3*blendStep);\n    \n    float bod2 = cylinder(rX(rY(p-vec3(-0.4+0.7,5.0,1.4+0.8), -40.0), -10.0), 0.5, 0.8);\n    float lowerhalf2 = blend(lowerhalf, bod2, 1.4*blendStep);\n    \n    float uparm1 = cylinder(rX(rY(p-vec3(-0.05+1.5,4.9,0.53+1.3), 115.0), 70.0), 0.12, 0.75);\n    float wrist1 = cylinder(rX(rY(p-vec3(-0.05+2.2,4.45,0.53+1.7), 115.0), -10.0), 0.1, 0.6);\n    float hand1 = roundedBox(rX(rY(p-vec3(-0.05+2.15,3.95,0.53+1.65), 115.0), 80.0), vec3(0.11,0.09,0.12), 0.05);    \n    float lowerhalf3 = blend(uparm1, lowerhalf2, 1.3*blendStep);\n    lowerhalf3 = blend(lowerhalf3, wrist1, 0.5*blendStep);\n    lowerhalf3 = blend(lowerhalf3, hand1, 0.4*blendStep);\n    \n    float uparm2 = cylinder(rX(rY(p-vec3(-0.05,4.9,0.53+2.8), -25.0), -70.0), 0.12, 0.75);\n    float wrist2 = cylinder(rX(rY(p-vec3(-0.05+0.3,4.45,0.53+3.5), -25.0), 10.0), 0.1, 0.6);\n    float hand2 = roundedBox(rX(rY(p-vec3(-0.05+0.25,3.95,0.53+3.45), -25.0), -80.0), vec3(0.11,0.09,0.12), 0.05);\n    lowerhalf3 = blend(uparm2, lowerhalf3, 1.3*blendStep);\n    lowerhalf3 = blend(lowerhalf3, wrist2, 0.5*blendStep);\n    lowerhalf3 = blend(lowerhalf3, hand2, 0.4*blendStep);\n    \n    float neck = cylinder(rX(rY(p-vec3(-0.4+0.7,6.3,1.4+0.8), -40.0), 5.0), 0.4, 0.6);\n    lowerhalf3 = blend(neck, lowerhalf3, 0.7*blendStep);\n    \n    float head = roundedBox(rX(rY(p-vec3(-0.4+1.1,7.2,1.4+1.2), -40.0), -15.0), vec3(0.2,0.2,0.65), 0.2);\n    float horse = blend(head, lowerhalf3, 0.7*blendStep);\n    \n    float tail = cylinder(rX(rY(p-vec3(-0.15-1.25,3.5,-0.35+0.75), -40.0), 45.0), 0.15, 0.8);\n    \n    propose(res, matID, blend(horse, tail, 0.5*blendStep), 1);\n\n#endif\n\n    // ground plane\n    propose(res, matID, plane(p-vec3(0.0,-1.0,0.0)), 4);\n    \n    // rounded box grid    \n    vec3 v = repeat(p, vec3(GRID_SIZE,0.0,GRID_SIZE));\n    vec3 f = p - v;\n    float h = 30.0*perlinNoise2D(f.xz, 0.01, 1.0, 2, 37);\n    h *= clamp(exp((dot(f.xz,f.xz) - 102.0*102.0)/20000.0)-1.0, 0.0, 1.0);\n\tpropose(res, matID, roundedBox(v, vec3(0.7*GRID_SIZE/2.0,max(0.0, h),0.7*GRID_SIZE/2.0), 0.1), 4);\n    \n    // player\n    if (drawPlayer) {\n        propose(res, matID, sphere(p-playerPos, 0.25), 5);\n    }\n    \n    return res;\n}\n\n// Lighting\nfloat directionalLightDiffuse(vec3 nor, vec3 ldir) {\n    return clamp(dot(nor, -ldir), 0.0, 1.0);\n}\n\nfloat pointLightDiffuse(vec3 pos, vec3 nor, vec3 lpos, vec3 func) {\n    vec3 ldir = normalize(pos - lpos);\n    float dist = length(pos - lpos);\n    float atten = min(1.0/dot(func, vec3(1, dist, dist*dist)), 1.0);\n    return atten * clamp(dot(nor, -ldir), 0.0, 1.0);\n}\n\n// Effects\nfloat softshadow(vec3 pos, vec3 ldir, vec3 playerPos) {\n#if USE_SHADOWS\n    float res = 1.0;\n    float t = 0.01;\n    for(int i = 0; i < 16; i++) {\n        float h = map(pos - ldir*t, junkMatID, playerPos, true, true);\n        res = min(res, 7.0*h/t);\n        t += clamp(h, 0.05, 5.0);\n        if (h < EPS) break;\n    }\n    return clamp(res, 0.0, 1.0);\n#else\n    return 1.0;\n#endif\n}\n\n// Coloring different materials\nvec3 sky(vec3 dir, vec3 SUN_DIR) {\n    float day = step(dot(dir, SUN_DIR), 0.0);\n    \n    float daylightStep = smoothstep(0.5, -0.5, dot(dir, SUN_DIR));\n    vec3 col =  (1.0-daylightStep)*vec3(0) + daylightStep*vec3(0.5, 0.8, 1.0);\n    \n    float sunStep = smoothstep(-0.996, -0.997, dot(dir, SUN_DIR));\n    col = (1.0-sunStep)*col + sunStep*vec3(1.0, 0.75, 0.0);\n    \n    float moonStep = smoothstep(0.996, 0.997, dot(dir, SUN_DIR));\n    col = (1.0-moonStep)*col + moonStep*vec3(0.9);\n    \n    // Stars based on method from https://www.shadertoy.com/view/ldXXDj\n    // Doesn't work on linux?\n    col += 0.5*smoothstep(0.89+0.03*cos(iTime),0.94,\n                          texture(iChannel2, 5.0*dir.xz).x)*(1.0-daylightStep)*(1.0-moonStep);\n\n    return col;\n}\n\nvec3 ground(Ray ray) {\n    // Blue/black stripes\n    float stripeStep = step(GRID_SIZE, mod(ray.pos.z, GRID_SIZE*2.0));\n    vec3 col = stripeStep*vec3(0.0, 0.0, 1.0) + (1.0 - stripeStep)*vec3(0.0);\n    vec3 disp = ray.pos - vec3(30.0, 10.0, 0.0);\n    float radStep = smoothstep(0.0, 200.0, dot(disp.xz, disp.xz));\n\n    // Random color per box\n    vec3 v = repeat(ray.pos, vec3(GRID_SIZE,0.0,GRID_SIZE));\n    vec3 f = ray.pos - v;\n    vec3 randCol = vec3(perlinNoise2D(f.xz, 0.01, 1.0, 1, 37),\n               \t\t    perlinNoise2D(f.xz, 0.01, 1.0, 1, 87),\n               \t\t\tperlinNoise2D(f.xz, 0.01, 1.0, 1, 137));\n    col = radStep*randCol + (1.0-radStep)*col;\n\n    // White boundary line\n    float d = sqrt(dot(f.xz,f.xz));\n    float boundStep = smoothstep(96.0, 100.0, d)*(1.0-smoothstep(100.0, 104.0, d));\n    col = boundStep * vec3(1.0) + (1.0 - boundStep) * col;\n    \n    return col;\n}\n\nvec3 centerSphere(Ray ray) {\n    // Weird colors\n    float colStep = smoothstep(-0.25, 0.25, cos(iTime/2.0));\n    vec3 sphereColor = vec3(0.0, 0.5, 0.5);\n    float radius = length(ray.pos-vec3(0.0, 1.5, 0.0));\n    sphereColor = mix(sphereColor, vec3(0.5, 0.5, 0.0), smoothstep(0.295, 0.3, radius));\n\n    // Beach ball\n    float phi = ceil(acos(dot(normalize(ray.pos.xz), vec2(1,0)))/(PI/3.0))+3.0*step(0.0, ray.pos.z);\n    vec3 bbColor = vec3(0.0);\n    bbColor += vec3(1.0,0.0,0.0)*step(0.5, phi)*step(phi, 1.5);\n    bbColor += vec3(1.0)*step(1.5, phi)*step(phi, 2.5);\n    bbColor += vec3(0.0,0.0,1.0)*step(2.5, phi)*step(phi, 3.5);\n    bbColor += vec3(1.0,0.5,0.0)*step(3.5, phi)*step(phi, 4.5);\n    bbColor += vec3(0.75,0.7,0.3)*step(4.5, phi)*step(phi, 5.5);\n    bbColor += vec3(0.0,1.0,0.0)*step(5.5, phi)*step(phi, 6.5);\n\n    bbColor = mix(vec3(1.0), bbColor, step(0.01, dot(ray.pos.xz, ray.pos.xz)));\n\n    return mix(sphereColor, bbColor, colStep);\n}\n\nvec3 player(Ray ray, vec3 playerPos) {\n    vec3 col = vec3(0.45);\n    \n    // Lines\n    float th = fract(ray.pos.y-playerPos.y);\n    col = mix(vec3(0.6), col, smoothstep(0.0, 0.006, th)*(1.0-smoothstep(0.994, 1.0, th)));\n    float offset = mod(floor(ray.pos.y-playerPos.y),2.0)*0.5;\n    float phi = fract(fract(acos(dot(normalize(ray.nor.xz), vec2(1,0)))/(PI/5.0))+offset);\n    col = mix(vec3(0.65), col, smoothstep(0.0, 0.025, phi)*(1.0-smoothstep(0.975, 1.0, phi)));\n\n    // Eye\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 w = -normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n    vec3 r = normalize(ray.pos - playerPos);\n    \n    float eyeStep1 = smoothstep(0.95, 0.959, dot(r, w));\n    col = mix(col, vec3(0.1), eyeStep1);\n    float eyeStep2 = smoothstep(0.96, 0.999, dot(r, w));\n    col = mix(col, vec3(1.0,0.0,0.0), eyeStep2);\n    float eyeStep3 = smoothstep(0.998, 1.0, dot(r, w));\n    col = mix(col, vec3(1.0,1.0,0.0), eyeStep3);\n    \n    return col;\n}\n\nvec3 temple(Ray ray) {\n    vec3 col = vec3(0.55, 0.25, 0.25);\n    \n    // Lines\n    float th = fract(ray.pos.y*4.0);\n    float heightStep = step(ray.pos.y, 4.8);\n    col = mix(vec3(0.0), col, smoothstep(0.0, 0.05, th)*(1.0-smoothstep(0.95, 1.0, th)*heightStep));\n    float offset = mod(floor(ray.pos.y*4.0),2.0)*0.5;\n    float phi = fract(fract(acos(dot(normalize(ray.nor.xz), vec2(1,0)))/(PI/5.0))+offset);\n    col = mix(vec3(0.0), col, smoothstep(0.0, 0.0, phi)*(1.0-smoothstep(0.95, 1.0, phi))*heightStep);\n\n    col = mix(vec3(0.7), col, heightStep);\n    \n    return col;\n}\n\nvec3 computeColor(Ray ray, vec3 playerPos, vec3 SUN_DIR) {\n    vec3 col = vec3(0.0);\n    \n    // Switch on matID\n    // a return -> different/no lighting\n    // no return -> default lighting\n \tif (ray.matID == 0) {\n    \treturn sky(ray.dir, SUN_DIR);\n    } else if (ray.matID == 1){\t\t\t// reflective balls\n        col = vec3(0.8);\n    } else if (ray.matID == 2){\t\t\t// glass balls\n        col = vec3(0.8);\n    } else if (ray.matID == 3){\n\t\tcol = centerSphere(ray);\n    } else if (ray.matID == 4) {\n        col = ground(ray);\n    } else if (ray.matID == 5) {\n        col = player(ray, playerPos);\n    } else if (ray.matID == 6) {\n        col = temple(ray);\n    }\n    \n    // Default lighting\n    float sunLight = directionalLightDiffuse(ray.nor, SUN_DIR);\n    float sunShadow = softshadow(ray.pos, SUN_DIR, playerPos);\n    \n    float moonLight = directionalLightDiffuse(ray.nor, -SUN_DIR);\n    float moonShadow = softshadow(ray.pos, -SUN_DIR, playerPos);\n#if (SCENE != 1)\n    col = col * (sunLight * sunShadow + 0.4 * moonLight * moonShadow);\n#else\n    vec3 lightPos = vec3(-50.0, 2.0, 0.0);\n    float templeLight = pointLightDiffuse(ray.pos, ray.nor, lightPos, vec3(1.0, 0.0, 0.0));\n    //float templeShadow = softshadow(ray.pos, normalize(ray.pos-lightPos));\n    col = col * (sunLight * sunShadow + 0.6 * moonLight * moonShadow + templeLight);\n#endif\n    \n    return col;\n}\n\nbool isReflective(int matID) {\n    return (matID == 1 || matID == 6);\n}\n\nbool isRefractive(int matID) {\n    return (matID == 2);\n}\n\nvec3 calculateNormal(vec3 pos, vec3 playerPos) {\n    const vec3 e = vec3(EPS, 0.0, 0.0);\n\tfloat p = map(pos, junkMatID, playerPos, true, true);\n\treturn normalize(vec3(map(pos + e.xyy, junkMatID, playerPos, true, true) - p,\n           \t\t\t\t  map(pos + e.yxy, junkMatID, playerPos, true, true) - p,\n                          map(pos + e.yyx, junkMatID, playerPos, true, true) - p));\n}\n\nvec3 raymarch(inout Ray ray, vec3 playerPos, bool drawPlayer, bool drawRefractive, vec3 SUN_DIR) {\n    float h = 1.0;\n    float t = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        h = map(ray.src + t*ray.dir, ray.matID, playerPos, drawPlayer, drawRefractive);\n        t += h;\n        ray.iter = i;\n        if (t > TMAX) break;\n    }\n    int missed = int(step(TMAX, t));\n    ray.matID = (1- missed) * ray.matID;\n    ray.t = float(missed)*TMAX + float(1-missed)*t;\n    ray.pos = ray.src + ray.t*ray.dir;\n    ray.nor = calculateNormal(ray.pos, playerPos);\n    if (texture(iChannel1, vec2(KEY_N, 0.25)).x > 0.5)\t\t\t// Color with normals\n        return normalize(0.5*(ray.nor+1.0));\n    return computeColor(ray, playerPos, SUN_DIR);\n}\n\nvec4 render(Ray ray, vec3 playerPos, bool thirdPerson, vec3 SUN_DIR) {\n    vec3 result = raymarch(ray, playerPos, thirdPerson, true, SUN_DIR);\n    float t1 = ray.t;\n    \n#if USE_REFLECTIONS\n    // Reflections\n    const float REFL_COEF = 0.4;\n    float rc = REFL_COEF;\n    for (int i = 0; i < NUM_REFLECTIONS; i++) {\n        if (!isReflective(ray.matID)) break;\n        \n        ray.dir = reflect(ray.dir, ray.nor);\n        ray.src = ray.pos + EPS*ray.dir;\n        result += raymarch(ray, playerPos, true, true, SUN_DIR)*rc;\n        rc *= REFL_COEF;\n    }\n#endif\n    \n#if USE_REFRACTIONS\n    // Refraction\n    if (isRefractive(ray.matID)) {\n        ray.dir = refract(ray.dir, ray.nor, 1.0/1.2);\n        ray.src = ray.pos + EPS*ray.dir;\n        result += raymarch(ray, playerPos, true, false, SUN_DIR);\n    }\n#endif\n    \n    return vec4(clamp(result, 0.0, 1.0), t1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0+2.0*uv; \t\t\t\t\t\t// Pixel space of the focal plane\n\tp.x *= iResolution.x/iResolution.y;\n    \n    Ray ray;\n    ray.pos = vec3(0.0);\n    ray.nor = vec3(0.0);\n    ray.matID = 0;\n    ray.t = 0.0;\n    \n    #if USE_DAYNIGHT\n    vec3 SUN_DIR = normalize(vec3(0, cos(iTime/DAY_LENGTH), sin(iTime/DAY_LENGTH)));\n    #else\n    vec3 SUN_DIR = normalize(vec3(-1));\n    #endif\n    vec3 playerPos = texture(iChannel0, (txPlayerPos+0.5)/iChannelResolution[0].xy).xyz;\t\t// world space camera location\n    \n\t// camera\t\n\tfloat d = 5.5; \t\t\t\t\t\t\t\t// Distance between eye and focal plane\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.xy == vec2(0)) {\n        m = vec2(0.495, 0.53);\n    }\n    vec3 w = normalize(vec3(cos(2.0*PI*m.x), sin(PI*(m.y-0.5)), sin(2.0*PI*m.x)));\n\tvec3 u = normalize(cross(w,UP));\n\tvec3 v = normalize(cross(u,w));\n    ray.dir = normalize(p.x*u + p.y*v + d*w);\n    ray.src = playerPos;\n    \n    bool thirdPerson = texture(iChannel1, vec2(KEY_P, 0.25)).x > 0.5;\n    if (thirdPerson) {\t\t\t\t\t\t\t// Third person\n        ray.src -= 5.0*w;\n        ray.src.y = max(0.2, ray.src.y);\n    }\n            \n\tfragColor = render(ray, playerPos, thirdPerson, SUN_DIR);\n}","name":"Buf B","description":"","type":"buffer"}]}