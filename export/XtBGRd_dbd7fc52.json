{"ver":"0.1","info":{"id":"XtBGRd","date":"1431318823","viewed":212,"name":"Chinese Lanterns","username":"hypothete","description":"Chinese lanterns float through endless space","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","distf","lanterns"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//thx iq for distance functions: https://iquilezles.org/articles/distfunctions\n\nstruct camera {\n    vec3 position;\n    vec3 direction;\n};\n    \nconst vec3 worldUp = vec3(0.0,-1.0,0.0);\nconst float minStep = 0.1;\nconst float maxStep = 80.0;\nconst float delta = 0.01;\nconst float damping = 0.9;\nconst int numSteps = 100;\n\nbool onALantern = false;\n\nmat3 getViewMatrix (vec3 t, vec3 d, vec3 k)\n{\n\tvec3 z = normalize(d);\n    vec3 x = normalize(cross(d,k));\n    vec3 y = normalize(cross(z,x));\n    return mat3(x,y,z);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n\nfloat opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    float sphereDistf = sdSphere(q,  0.8);\n    float cylDistf = sdCappedCylinder(q,  vec2(0.4,1.0));\n    float coneDistf = udBox(vec3(q.x,q.y+1.6,q.z), vec3(0.2,0.6,0.01));\n    \n    float summed = min(cylDistf , sphereDistf);\n    summed = min(summed, coneDistf);\n    \n\tonALantern = summed == sphereDistf;\n    return summed;\n}\n\n\nfloat distf (vec3 pos)\n{\n\treturn opRep(pos,vec3(10.0));\n}\n\nvec3 normal (vec3 p)\n{\n    vec2 dm = vec2(delta, 0.0);\n\treturn normalize(vec3(\n    \tdistf(p+dm.xyy) - distf(p-dm.xyy),\n        distf(p+dm.yxy) - distf(p-dm.yxy),\n        distf(p+dm.yyx) - distf(p-dm.yyx)\n    ));\n}\n\nfloat castRay ( vec3 pos, vec3 dir, out vec3 norm)\n{\n    float dist = minStep;\n    for(int step = 0; step < numSteps; step++)\n    {\n        norm = pos + dir*dist;\n        float normL = distf(norm);\n        if(normL > delta || dist > maxStep){\n            dist += normL*damping;\n        }\n    }\n    return dist;\n}\n\n\nvec4 render(in vec2 xy)\n{\n    camera myCam = camera( \n    \tvec3(-cos(iTime/30.0)*30.0,3.0*sin(iTime/6.0),-sin(iTime/30.0)*30.0),\n    \tvec3(iMouse.x/iResolution.x*3.0-1.5,iMouse.y/iResolution.y*3.0-1.5,1.0)\n\t);\n    \n    mat3 viewMatrix = getViewMatrix(myCam.position, myCam.direction, worldUp);\n\n\tvec3 rayDir = viewMatrix * normalize(vec3(xy, 1.0));\n    vec3 ro = vec3(0.0,0.0,0.0);\n    vec4 colToRtn = vec4(1.0);\n    float histDistanceFunction = castRay(myCam.position, rayDir, ro);\n    if(histDistanceFunction < maxStep){\n        \n        vec3 nml = normal(ro);\n        if(onALantern){\n            colToRtn=vec4(1.0,1.0,0.8,1.0);\n            colToRtn += vec4(texture(iChannel1, vec2(nml.x,nml.z+iTime/10.0)));\n            colToRtn.xyz *= (15./distance(myCam.position, ro));\n            \n        }\n        else{\n            colToRtn = vec4(nml.x,0.0,0.0,1.0);\n            colToRtn *= vec4(texture(iChannel0, nml.xz));\n            colToRtn.xyz *= (25./distance(myCam.position, ro));\n        }\n        \n        \n        //color correction\n        \n        return colToRtn;\n    }\n    else{\n    \treturn vec4(0);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xx - 0.5;\n    fragColor = render(uv);\n}","name":"","description":"","type":"image"}]}