{"ver":"0.1","info":{"id":"ctscRl","date":"1698114047","viewed":29,"name":"Fork Breaking R chenxianmi 350","username":"chenxianming","description":"My favorite technique for breaking repetition, when using SDFs. Works in 3D too!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf","repetition","technique"],"hasliked":0,"parentid":"mlfcRM","parentname":"Breaking Repetition"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Breaking Repetition\" by @XorDev\n    \n    Here's a simple technique for pseudo-randomly distributing objects.\n    This method preserves proper spacing for distance fields and works in 3D!\n    \n    The concept is simple:\n    -Render a few tiled layers of objects\n    -Rotate and scale the coordinates for each layer\n    -Divide the distance by the octave scale\n    \n    Rotation only helps a ton, but when combined with scaling it's patternless*\n*/\n\n//Optional octave index for coloring\nfloat IND = 1.0;\n//Distance field function\nfloat dist(vec2 p, float num, float scl)\n{\n    //Arbitrary rotation matrix\n    mat2 m = mat2(.8,-.6,.6,.8);\n    //Scaling factor\n    float s = 1.0;\n    //Store minimum distance\n    float d = 1e9;\n    \n    //Loop through passes\n    for(float i = 0.0; i<num; i++)\n    {\n        //Repeating circles rotating octaves and scaling\n        float _d = length( mod( p + vec2( cos( iTime ) * i, sin( iTime ) * i ) + i * .3, 2. ) - 1. ) - .1;\n        //Store closest distance (and optionally, index for coloring)\n        \n        d = min(\n            d,\n            _d\n        );\n        \n        //Scale by factor amount\n        // s *= scl;\n    }\n    //Return distance field\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Centered and scale pixel coordinates\n    vec2 coord = (fragCoord - iResolution.xy*0.5)/3e1;\n    //Time loop\n    float T = round( fract( iTime * .1 ) * 4. );\n    //Number of octaves\n    float N = clamp(T,1.,4.);\n    //Octave scaling\n    float S = clamp(1.4-T*.1,.9,1.);\n    //Distance gradients and coloring\n    fragColor = (1.-dist(coord,5.,S)) * (.5-.5*cos(IND+vec4(0,2,4,0)));\n}","name":"Image","description":"","type":"image"}]}