{"ver":"0.1","info":{"id":"fssBWn","date":"1644703900","viewed":173,"name":"Happy sliding","username":"Flopine","description":"A test, not my best, I like it nonetheless :D","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","cube","animation","isometric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define crep(p,c,l) p-=c*clamp(round(p/c),-l,l)\n#define od(p,d) (dot(p,normalize(sign(p)))-d)\n\n#define dt(off) mod(iTime+off,8.)\n#define anim(x) clamp(abs(x-4.)-2.,0.,1.)\n#define bounce(off) sqrt(sin(dt(off)*PI))\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q= abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nvec2 id;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    \n    float per = 2.8;\n    id = floor(p.xz/per);\n    \n    if (mod(id.y,2.)<0.5) p.x += anim(dt(0.))*per;\n    else p.x -= anim(dt(0.))*per;\n    \n    if (mod(id.x,2.)<0.5) p.z += anim(dt(-1.))*per;\n    else p.z -= anim(dt(-1.))*per;\n    \n    p.xz = mod(p.xz, per)-per*.5;   \n    \n    vec3 pp = p-vec3(0.,bounce(1.)*2.,0.);\n    pp.xz *= rot(dt(0.5)*PI);\n    \n    return min(od(pp,0.2),max(-sc(p, .35),max(sc(p,.45),box(p,vec3(1.)))));\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-e.xyy),SDF(p-e.yxy),SDF(p-e.yyx)));\n}\n\nfloat AO (float eps, vec3 p, vec3 n)\n{return SDF(p+eps*n)/eps;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    vec3 ro=vec3(uv*3.5,-60.), rd=vec3(0.,0.,1.), p=ro,\n    col=vec3(0.7,0.9,0.99), l=normalize(vec3(.5,1.,-1.));\n    bool hit=false;\n    \n    for(float i=0.;i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit=true;break;\n        }\n        p += d*rd*.75;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float l = max(dot(n,l),0.);\n        float ao = AO(0.02,p,n)+AO(0.03,p,n)+AO(0.08,p,n);\n        col = mix(vec3(0.1,0.8,0.5),vec3(0.95,0.9,0.4),l);\n        col *= ao/3.;\n    }\n\n    fragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}