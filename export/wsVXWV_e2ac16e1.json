{"ver":"0.1","info":{"id":"wsVXWV","date":"1575048497","viewed":144,"name":"[rough draft] Happiness…","username":"adurdin","description":"Rough draft. This is woefully incomplete and totally unoptimised and the code’s a mess—I still want to detail the scene and add fog and lighting effects and audio—but I don’t know when I’ll get time to finish it, so I’m putting it up here as is for now.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by andy durdin (@adurdin)\n// This work is licensed under a Creative Commons\n// Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define PI 3.14159264\n#define TWO_PI (2 * PI)\n\n#define MIN_DIST 0.0\n#define MAX_DIST 320.0\n#define EPSILON 0.0001\n\n#define DRAW_BLACKHOLE 0\n#define R_NORMAL 0\n#define R_STEPCOUNT 0\n#define R_DEPTH 0\n\nvec3 blackhole_center = vec3(0.0,-4.0,0.0);\nfloat blackhole_radius = 1.25;\n\n#define inf (1.0/0.000000000000001)\n\n//----------------------------------------------------------------\n\nvec3 TurboColormap(in float x) {\n    // Copyright 2019 Google LLC.\n    // SPDX-License-Identifier: Apache-2.0\n\n    // Polynomial approximation in GLSL for the Turbo colormap\n    // Original LUT: https://gist.github.com/mikhailov-work/ee72ba4191942acecc03fe6da94fc73f\n\n    // Authors:\n    //   Colormap Design: Anton Mikhailov (mikhailov@google.com)\n    //   GLSL Approximation: Ruofei Du (ruofei@google.com)\n    const vec4 kRedVec4 = vec4(0.13572138, 4.61539260, -42.66032258, 132.13108234);\n    const vec4 kGreenVec4 = vec4(0.09140261, 2.19418839, 4.84296658, -14.18503333);\n    const vec4 kBlueVec4 = vec4(0.10667330, 12.64194608, -60.58204836, 110.36276771);\n    const vec2 kRedVec2 = vec2(-152.94239396, 59.28637943);\n    const vec2 kGreenVec2 = vec2(4.27729857, 2.82956604);\n    const vec2 kBlueVec2 = vec2(-89.90310912, 27.34824973);\n\n    x = clamp(x, 0.0, 1.0);\n    vec4 v4 = vec4( 1.0, x, x * x, x * x * x);\n    vec2 v2 = v4.zw * v4.z;\n    return vec3(\n        dot(v4, kRedVec4)   + dot(v2, kRedVec2),\n        dot(v4, kGreenVec4) + dot(v2, kGreenVec2),\n        dot(v4, kBlueVec4)  + dot(v2, kBlueVec2)\n    );\n}\n\nvec3 colorize_sdf(float d)\n{\n    // Colorize: red->yellow positive, green->blue negative.\n    vec3 col = TurboColormap((d*2.0 + 0.5));\n    // Rings\n    col *= 0.8 + 0.2*pow(cos(80.0*d),2.0);\n    // Black at the surface\n    col = mix( col, vec3(0.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    return col;\n}\n\nvec3 colorize_distance(float d)\n{\n    return TurboColormap(1.0 - d);\n}\n\nvec3 colorize_stepCount(int stepCount)\n{\n    return TurboColormap(float(stepCount) / 512.0);\n}\n\n// ---------------------------------------------------\n\nfloat FovHFromY( float fovY, float aspect )\n{\n    return 2.0*atan(tan(0.5*fovY)*aspect);\n}\n\nfloat FovYFromH( float fovH, float aspect )\n{\n    return 2.0*atan(tan(0.5*fovH)/aspect);\n}\n\nmat4 matPerspective( float fovY, float aspect, float zNear, float zFar )\n{\n    float f = cos(0.5*fovY) / sin(0.5*fovY);\n    float g = f/aspect;\n    float a = (zFar + zNear)/(zNear - zFar);\n    float b = 2.0*zFar*zNear/(zNear - zFar);\n    return mat4(\n        vec4( g,   0.0, 0.0, 0.0 ),\n        vec4( 0.0, f,   0.0, 0.0 ),\n        vec4( 0.0, 0.0, a,  -1.0 ),\n        vec4( 0.0, 0.0, b,   0.0 )\n    );\n}\n\nmat4 matLookAt( vec3 eye, vec3 center, vec3 up )\n{\n    up = normalize(up);\n    vec3 f = normalize(center - eye);\n    vec3 s = cross(f, up);\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4( s.x, u.x, -f.x, 0.0 ),\n        vec4( s.y, u.y, -f.y, 0.0 ),\n        vec4( s.z, u.z, -f.z, 0.0 ),\n        vec4( dot(-eye,s), dot(-eye,u), dot(-eye,-f), 1.0 )\n    );\n}\n\n// -------------------------------------------------------------------\n\nmat4 matRotate( vec3 axis, float angle )\n{\n    float c = cos(angle), nc = 1.0 - c, s = sin(angle);\n    float x = axis.x, y = axis.y, z = axis.z;\n    vec3 a = axis;\n    return mat4(\n        (x*x*nc + c),   (y*x*nc + z*s), (x*z*nc - y*s), 0.0,\n        (x*y*nc - z*s), (y*y*nc + c),   (y*z*nc + x*s), 0.0,\n        (x*z*nc + y*s), (y*z*nc - x*s), (z*z*nc + c),   0.0,\n        0.0,            0.0,            0.0,            1.0\n    );\n}\n\nmat4 matTranslate( vec3 pos )\n{\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        pos.x, pos.y, pos.z, 1.0\n    );\n}\n\nmat4 matScale( float s )\n{\n    return mat4(\n        s, 0.0, 0.0, 0.0,\n        0.0, s, 0.0, 0.0,\n        0.0, 0.0, s, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\n// ---------------------------------------------------\n\nstruct field {\n    float d;\n    int mat;\n};\n\nstruct phong_material {\n    float k_a; // ambient factor\n    vec3 k_d; // diffuse color\n    float k_s; // specular factor\n    float alpha; // shininess\n};\n\nfield sdf(vec3 p);\nfield sdf_shadows(vec3 p);\nfield sdf_transcendence(vec3 p, float time);\nphong_material material(int mat);\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.y, p.z)).d - sdf(vec3(p.x - EPSILON, p.y, p.z)).d,\n        sdf(vec3(p.x, p.y + EPSILON, p.z)).d - sdf(vec3(p.x, p.y - EPSILON, p.z)).d,\n        sdf(vec3(p.x, p.y, p.z + EPSILON)).d - sdf(vec3(p.x, p.y, p.z - EPSILON)).d\n    ));\n}\n\nstruct raymarch_result {\n    float depth;\n    int mat;\n    int stepCount;\n};\n\nraymarch_result raymarch(\n    vec3 eye, vec3 direction, float start, float end)\n{\n    raymarch_result result;\n    float depth = start;\n    int mat = -1;\n    int stepCount = 0;\n    for (int i = 0; i < 512; ++i, ++stepCount) {\n        field f = sdf(eye + depth*direction);\n        mat = f.mat;\n        // BUG: sand, maybe pillars have tunnelling artifacts\n        // (due to subtraction of the field). Can use abs(f.d) here\n        // to counteract that.\n        if( abs(f.d)<EPSILON ) break;\n        depth += f.d;\n        if (depth >= end) { mat = -1; break; }\n    }\n    // BUG: we get a few bright pixel artifacts when the\n    // iteration count is exceeded.\n    result.depth = depth;\n    result.mat = mat;\n    result.stepCount = stepCount;\n    return result;\n}\n\nfloat shadowmarch(\n    vec3 eye, vec3 direction, float start, float end)\n{\n    float shadow = 1.0;\n    float t = start;\n    for( int i=0; i<128; ++i ) {\n        float d = sdf_shadows(eye + t*direction).d;\n        shadow = min( shadow, 16.0*d/t );\n        if( d<EPSILON ) break;\n        t += d;\n        if( t>=end ) break;\n    }\n    return clamp(shadow,0.0,1.0);\n}\n\nfloat shadowmarch_sharp(\n    vec3 eye, vec3 direction, float start, float end)\n{\n    float shadow = 1.0;\n    float t = start;\n    for( int i=0; i<128; ++i ) {\n        float d = sdf_shadows(eye + t*direction).d;\n        if( d<EPSILON ) { shadow = 0.0; break; }\n        t += d;\n        if( t>=end ) break;\n    }\n    return clamp(shadow,0.0,1.0);\n}\n\nstruct blackhole_result {\n    vec3 ro;\n    vec3 rd;\n    int stepCount;\n    bool escaped;\n};\n\nblackhole_result blackhole(vec3 p, vec3 d, vec3 eye)\n{\n    blackhole_result result;\n    int stepCount = 0;\n    vec3 vel = 1.0*normalize(d);\n    vec3 c = blackhole_center;\n    float R = blackhole_radius;\n    const float k = 0.01; // step size\n    float ef = 0.3*length(eye-c);\n    for( int i=0; i<512; ++i, ++stepCount )\n    {\n        vec3 r = p - c;\n        vec3 f = r*length(r)/ef;\n        \n        vel += k*f;\n        p += k*vel;\n\n        float l = length(p - c);\n        if( l>R )\n        {\n            result.ro = p;\n            result.rd = normalize(vel);\n            result.escaped = true;\n            result.stepCount = stepCount;\n            return result;\n        }\n    }\n    \n    result.ro = vec3(0);\n    result.rd = vec3(0);\n    result.escaped = false;\n    result.stepCount = stepCount;\n    return result;\n}\n\nraymarch_result raymarch_transcendence(\n    vec3 eye, vec3 direction, float start, float end, float time)\n{\n    raymarch_result result;\n    float depth = start;\n    int mat = -1;\n    int stepCount = 0;\n    for (int i = 0; i < 512; ++i, ++stepCount) {\n        field f = sdf_transcendence(eye + depth*direction, time);\n        mat = f.mat;\n        // BUG: sand, maybe pillars have tunnelling artifacts\n        // (due to subtraction of the field). Can use abs(f.d) here\n        // to counteract that.\n        if( f.d<EPSILON ) break;\n        depth += f.d;\n        if (depth >= end) { mat = -1; break; }\n    }\n    // BUG: we get a few bright pixel artifacts when the\n    // iteration count is exceeded.\n    result.depth = depth;\n    result.mat = mat;\n    result.stepCount = stepCount;\n    return result;\n}\n\n// --------------------------------------------------------------------\n\n#define WINDOW_X_COUNT 1\n#define WINDOW_Y_COUNT 1\n#define WINDOW_COUNT (WINDOW_X_COUNT * WINDOW_Y_COUNT)\n\nconst vec2 windowSize = vec2(1.0 / float(WINDOW_X_COUNT), 1.0 / float(WINDOW_Y_COUNT));\n\nvec2 windowOrigin(int window) {\n    int x = window % WINDOW_X_COUNT;\n    int y = (WINDOW_Y_COUNT - 1 - (window / WINDOW_X_COUNT));\n    return vec2(\n        float(x) * windowSize.x,\n        float(y) * windowSize.y\n    );\n}\n\n// Tex coordinates are bottom-left: 0,0 to top-right: 1,1.\n// Window coordinates are bottom-left: 0.0 to top-right: 1,1.\n// SDF coordinates are bottom-left: -0.5,-0.5 to top-right: 0.5,0.5.\n\nint texWindowIndex(vec2 texCoord) {\n    for (int i = 0; i < WINDOW_COUNT; ++i) {\n        vec2 origin = windowOrigin(i);\n        if (texCoord.x >= origin.x\n            && texCoord.y >= origin.y\n            && (texCoord.x - origin.x) < windowSize.x\n            && (texCoord.y - origin.y) < windowSize.y)\n        {\n            return i;\n        }\n    }\n    // INVALID; but return the first window, whatever.\n    return 0;\n}\n\nvec2 texToWindow(vec2 texCoord, int window) {\n    return (texCoord - windowOrigin(window)) / windowSize;\n}\n\nvec2 windowToTex(vec2 windowCoord, int window) {\n    return (windowCoord * windowSize) + windowOrigin(window);\n}\n\nvec2 windowToSDF(vec2 windowCoord) {\n    return (windowCoord - vec2(0.5, 0.5)) /* * aspectCorrection * windowAspectCorrection  */;\n}\n\nvec2 SDFToWindow(vec2 p) {\n    return (p + vec2(0.5, 0.5));\n}\n\n//-----------------------------------------------------------\n\nvec4 render_default(\n    raymarch_result result, vec3 p, vec3 n, vec3 eye, float energy, int shot, float time\n){\n    if( result.depth<=EPSILON ) {\n        // clipped by near plane\n//        return vec4(0.8,0.1,0.05,1.0); // red so clipping can be seen\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    } else if( result.depth >= MAX_DIST ) {\n        return vec4(1.0, 0.0, 1.0, 1.0);\n    }\n\n    phong_material m = material(result.mat);\n\n    vec3 V = normalize(eye - p);\n    vec3 L, R;\n    float D;\n\n    // Sky (key)\n    vec3 light1_dir = vec3(0.0, -0.5, 0.8);\n    vec3 light1_color = 0.8*vec3(4.0, 4.0, 3.5);\n    L = normalize(-light1_dir);\n    R = normalize(reflect(-L,n));\n    float light1_diffuse = clamp(dot(L,n), 0.0,1.0);\n    float light1_specular = clamp(dot(R,V), 0.0,1.0);\n    float light1_shadow = shadowmarch(p+0.001*n,L,MIN_DIST,MAX_DIST);\n\n    // Positional (fill)\n    vec3 light2_pos = vec3(58.0,-68.0,23.0);\n    // The far wall needs some illumination in the long pan, so:\n    if( shot==3 ) { light2_pos.x = -light2_pos.x; }\n    vec3 light2_color = 0.1*vec3(1.2, 0.8, 0.5);\n    L = normalize(light2_pos - p);\n    R = normalize(reflect(-L,n));\n    float light2_diffuse = clamp(pow(dot(L,n), 4.0), 0.0,1.0);\n    float light2_specular = clamp(dot(R,V), 0.0,1.0);\n\n    // Spotlight (sky)\n    // BUG: this shines on the far wall. BUT for right now that gives\n    // a decent enough rough preview for the atmospherics that I want!\n    vec3 q = vec3(p.x, p.y, mod(p.z + 20.0, 38.0) - 20.0);\n    vec3 light3_pos = vec3(0.0, 24.0, 6.0);\n    vec3 light3_dir = vec3(0.0, -1.0, 0.0);\n    vec3 light3_color = 33.0*vec3(4.0, 4.0, 3.5);\n    L = normalize(light3_pos - q);\n    R = normalize(reflect(-L,n));\n    D = length(light3_pos.xz - q.xz);\n    float light3_falloff = pow(clamp(dot(-light3_dir, L), 0.0,1.0), 20.0) / (D*D);\n    float light3_diffuse = light3_falloff*clamp(dot(L,n), 0.0,1.0);\n    float light3_specular = light3_falloff*clamp(dot(R,V), 0.0,1.0);\n\n    // Positional (flash)\n    float ft = mod(time, 1.0);\n    float flash = 0.0;//step(ft,0.5)-step(ft,0.1); // fixme! figure out the flashes\n    vec3 light4_pos = vec3(0.0,-4.0,0.0);\n    vec3 light4_color = flash*200.0*vec3(0.4, 0.7, 1.0);\n    L = normalize(light4_pos - p);\n    R = normalize(reflect(-L,n));\n    D = length(light4_pos - p);\n    const float radius = 50.0;\n    float falloff = clamp((radius*radius)/(D*D), 0.0,1.0);\n    float light4_diffuse = falloff*clamp(dot(L,n), 0.0,1.0);\n    float light4_specular = clamp(dot(R,V), 0.0,1.0);\n    float light4_shadow = shadowmarch_sharp(p+0.001*n,L,MIN_DIST,D);\n\n    vec3 color = vec3(0.0);\n\n    color += m.k_d*light1_color*light1_diffuse*light1_shadow;\n    color += m.k_s*light1_color*pow(light1_specular, m.alpha)*light1_shadow;\n\n    color += m.k_d*light2_color*light2_diffuse;\n    color += m.k_s*light2_color*pow(light2_specular, m.alpha);\n\n    color += m.k_d*light3_color*light3_diffuse;\n    color += m.k_s*light3_color*pow(light3_specular, m.alpha);\n\n    color += m.k_d*light4_color*light4_diffuse*light4_shadow;\n    color += m.k_s*light4_color*pow(light4_specular, m.alpha);\n\n    color += 4.0*pow(energy, 6.0)*vec3(0.5,1.0,1.0);\n\n    color = pow(color, vec3(0.4545));\n    return vec4(color, 1.0);\n}\n\nvec4 render_stepCount(raymarch_result result)\n{\n    return vec4(colorize_stepCount(result.stepCount), 1.0);\n}\n\nvec4 render_normal(raymarch_result result, vec3 n)\n{\n    if (result.depth < MAX_DIST) {\n        return vec4(abs(n), 1.0);\n    } else {\n        return vec4(0, 0, 0, 1.0);\n    }\n}\n\nvec4 render_depth(raymarch_result result)\n{\n    float scaled_depth = (result.depth - MIN_DIST) / (MAX_DIST - MIN_DIST);\n    return vec4(colorize_distance(scaled_depth), 1.0);\n}\n\nvec4 render(\n    raymarch_result result, vec3 p, vec3 n, vec3 eye, float energy, int shot, float time\n){\n#if R_STEPCOUNT\n    return render_stepCount(result);\n#elif R_NORMAL\n    return render_normal(result, n);\n#elif R_DEPTH\n    return render_depth(result);\n#else\n    return render_default(result, p, n, eye, energy, shot, time);\n#endif\n}\n\nvec4 render_transcendence(raymarch_result result)\n{\n    return vec4(TurboColormap(0.5 - 0.5*float(result.stepCount) / 256.0), 1.0);\n}\n\n\n//-----------------------------------------------------------\n\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = smoothstep(0.0, 1.0, p - ip);\n    float r00 = rand(ip);\n    float r01 = rand(ip + vec2(0, 1));\n    float r10 = rand(ip + vec2(1, 0));\n    float r11 = rand(ip + vec2(1, 1));\n    return mix(mix(r00, r01, fp.y), mix(r10, r11, fp.y), fp.x);\n}\n\n//---------------------------------------------------------\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    float exterior = length(max(d, 0.0));\n    float interior = min(max(d.x, max(d.y, d.z)), 0.0);\n    return exterior + interior;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat moundsHeight( vec3 p )\n{\n    return noise(p.xz * vec2(0.15,0.5) );\n}\n\nvec3 bezier4( float t, vec3 p0, vec3 p1, vec3 p2, vec3 p3 )\n{\n    vec3 a0 = mix(p0,p1,t);\n    vec3 a1 = mix(p1,p2,t);\n    vec3 a2 = mix(p2,p3,t);            \n    vec3 b0 = mix(a0,a1,t);\n    vec3 b1 = mix(a1,a2,t);\n    return mix(b0,b1,t);\n}\n\n//---------------------------------------------------------\n\nphong_material material(int mat)\n{\n    phong_material m;\n\n    if (mat == 0) {\n        // Black hole (untraced)\n        m.k_a = 0.0;\n        m.k_d = vec3(0.000001,0.00002,0.0001);\n        m.k_s = 0.5;\n        m.alpha = 80.0;\n    } else if (mat == 1) {\n        // Room\n        m.k_a = 0.0;\n        m.k_d = 0.3*vec3(0.05,0.12,0.08);\n        m.k_s = 0.0;\n        m.alpha = 0.0;\n    } else if (mat == 2) {\n        // Pillars\n        m.k_a = 0.1;\n        m.k_d = 0.5*vec3(0.07,0.13,0.09);\n        m.k_s = 0.0;\n        m.alpha = 0.0;\n    } else if (mat == 3) {\n        // Ground\n        m.k_a = 0.1;\n        m.k_d = vec3(0.04,0.04,0.03);\n        m.k_s = 0.001;\n        m.alpha = 0.0;\n    } else if (mat == 4) {\n        // Mounds\n        m.k_a = 0.25;\n        m.k_d = vec3(0.04,0.04,0.03);\n        m.k_s = 0.005;\n        m.alpha = 30.0;\n    } else {\n        // Unmapped\n        m.k_a = 0.0;\n        m.k_d = vec3(1000.0,0.0,1000.0);\n        m.k_s = 0.0;\n        m.alpha = 0.0;\n    }\n    return m;\n}\n\n//---------------------------------------------------------\n\nvec3 sdMenger1(vec3 p, float time, mat2 rot, float wow)\n{\n    vec3 p0 = p;\n    const float offset = 4.0;\n\n    // Distort the first sponge:\n    p.xy = rot * p.xy;\n    p.z = pow(p.z, wow);\n    vec3 q = mod(p+0.5*offset,offset)-0.5*offset;\n\n    float d = sdBox(q,vec3(inf));\n    {\n    float s = 1.0;\n    for( int m=0; m<4; m++ ) {\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n        d = max(d,c);\n    }\n    }\n    \n    return vec3(d,0.0,0.0);\n}\n\nvec3 sdMenger2(vec3 p, float time, mat2 rot, float wow)\n{\n    const float offset = 4.0;\n    // Distort the second sponge in opposite fashion:\n    // Rotate opposite:\n    rot[0][1] = -rot[0][1];\n    rot[1][0] = -rot[1][0];\n    p.xy = rot * p.xy;\n\n    // So this is here because it was a bug; but without\n    // this, things change much more rapidly so that it\n    // feels more flickery and less spatial. So I think\n    // I need to keep it!\n    p.z = pow(p.z, wow);\n    // This is what I intended, but with the bug is better.\n    p.z = pow(p.z, (1.0 - wow));\n    \n    vec3 q = mod(p+0.5*offset,offset)-0.5*offset;\n    float d = sdBox(q,vec3(inf));\n    {\n    float s = 1.0;\n    for( int m=0; m<4; m++ ) {\n        vec3 a = mod( p*s, 2.0 )-1.0;\n        s *= 3.0;\n        vec3 r = abs(1.0 - 3.0*abs(a));\n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n        float c = (min(da,min(db,dc))-1.0)/s;\n        d = max(d,c);\n    }\n    }\n\n    return vec3(d,0.0,0.0);\n}\n\n\nfield sdf_transcendence(vec3 p, float time)\n{\n    field f;\n    f.d = MAX_DIST;\n    f.mat = -1;\n\n    // Rotation:\n    float woo = 0.5 - 0.5*cos(0.1*time);\n    float a = 0.0 + woo*8.0*fract(sin(-p.z/6.28));\n    float ss = sin(a);\n    float cc = cos(a);\n    mat2 rot = mat2(cc, ss, -ss, cc);\n    \n    // Zoom:\n    float wow = 0.6 + 0.4*cos(0.1*time);\n\n    vec3 m1 = sdMenger1(p, time, rot, wow);\n    vec3 m2 = sdMenger2(p, time, rot, wow);\n\n    float blend = 0.378465;\n    f.d = mix(m1.x,m2.x,blend);\n\n    return f;\n}\n\nfield sdf(vec3 p)\n{\n    field f;\n    f.d = MAX_DIST;\n    f.mat = -1;\n\n    // Room\n    {\n    float room = -sdBox( p-vec3(0.0,10.0,0.0), vec3(40.0,42.0,160.0) );\n    if( room<f.d ){ f.d=room; f.mat=1; }\n    }\n\n    // Black hole\n    {\n    vec3 q = p - blackhole_center;\n    float d = sdSphere( q, blackhole_radius);\n    if( d<f.d ){ f.d=d; f.mat=0; }\n    }\n\n    // Everything else\n    {\n    field other_f = sdf_shadows(p);\n    if( other_f.d<f.d ){ f = other_f; }\n    }\n    \n    return f;\n}\n\nfield sdf_shadows(vec3 p)\n{\n    field f;\n    f.d = MAX_DIST;\n    f.mat = -1;\n\n    // Pillars\n    {\n    // Repeating domain:\n    vec3 q = vec3( mod(p.x-4.0,26.0), p.y, mod(p.z-8.0+2.0,20.0) );\n    float pillar = sdBox( q-vec3(9.0,8.0,6.0), vec3(2.0,46.0,2.0) );\n    // BUG: the crumbling is the same on each pillar (looks like carvings though!)\n    // BUG: the crumbling causes additional artifacting.\n    float crumble = 0.2*(1.0 - smoothstep( 0.45,0.5, noise(p.yx * 0.4) ));\n    pillar -= crumble;\n    if( pillar<f.d ){ f.d=pillar; f.mat=2; }\n    }\n\n    // Ground (below this plane)\n    {\n    float bounds = sdPlane( p, vec4(0.0,1.0,0.0, 6.0) );\n    if( bounds<f.d ) {\n        float ground = sdPlane( p, vec4(0.0,1.0,0.0, 8.75) );\n        if( ground<f.d ){ f.d=ground; f.mat=3; }\n\n        float mounds = 2.5*moundsHeight(p);\n        // BUG: this sand effect looks pretty bad.\n        float sand = 0.04*noise(p.xz * 12.0);\n        sand *= clamp(0.5*(p.y+8.5),0.0,1.0);\n        float dirt = ground - (mounds + sand);\n        // Smaller steps for the mounds to reduce artifacting:\n        // (0.5 is good for avoiding tunnelling; 0.85 for grazing\n        // angles to reduce edge shimmering from iteration-runout).\n        // Maybe don't need it at all yet?\n//        dirt *= 0.85;\n        if( dirt<f.d ){ f.d = smin(f.d, dirt, 0.2); f.mat=4; }\n    }\n    }\n\n    return f;\n}\n\n\n// ------------------------------------------------------------\n\n#define SHOT_COUNT 8\nfloat shot_durations[SHOT_COUNT+1] = float[](\n    10.0,   // 0\n    10.0,   // 1\n    13.0,   // 2\n    30.0,   // 3\n    18.0,   // 4\n    15.0,   // 5 (rising)\n    5.0,    // 6 (the leap)\n    15.0,   // 7 (transcendence)\n    \n    116.0    // total duration.\n);\n\nstruct camera {\n    vec3 pos;\n    vec3 target;\n    vec3 up;\n    float fovY;\n    float flatten;\n    int scene;\n};\n\ncamera setup_camera( int shot, float shot_start, float time )\n{\n    camera c;\n\n    float shot_duration = shot_durations[clamp(shot,0,SHOT_COUNT)];\n    float shot_time = time - shot_start;\n    \n    float t = shot_time/shot_duration;\n    float wobble = noise(vec2(4.0*time,shot));\n\n    switch(shot) {\n        // Shot cameras:\n        case 0: {\n            // high, far, showing room.\n            blackhole_center = vec3(0.0,-4.0,0.0);\n            blackhole_radius = 0.0;\n            c.pos = vec3(0.0,20.0,117.0);\n            c.target = vec3(-1.0,-10.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 35.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case 1: {\n            // far, zoomed on hole.\n            blackhole_center = vec3(0.0,-4.0,0.0);\n            float bt = smoothstep(-0.1,0.7,t-0.25);\n            const float bs = 0.2;\n            const float be = 0.4;\n            float appear = step(t,be)-step(t,bs);\n            float appeart = (t-bs)/(be-bs);\n            bt = appear*sin(appeart*1.57) + step(be,t);\n            blackhole_radius = bt*1.4;\n            c.pos = vec3(0.0,-4.0,147.0);\n            c.target = vec3(0.0,-6.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 7.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case 2: {\n            // walking beside pillars.\n            blackhole_center = vec3(0.0,-4.0,0.0);\n            blackhole_radius = 1.25;\n            const vec3 p0 = vec3(32.0,-3.0,127.0);\n            const vec3 p1 = vec3(28.0,-3.0,110.0);\n            float walk = shot_time/10.0;\n            float steps = sin(50.0*walk);\n            float bob = sin(50.0*(walk-0.85));\n            float sway = sin(25.0*walk);\n            float s = mix(t, t + 0.005*steps, 0.7);\n            vec3 p = mix(p0,p1,s);\n            float mounds = moundsHeight(p);\n            const vec3 e = vec3(0.2,0.0,0.0);\n            float slope = (moundsHeight(p+e)-moundsHeight(p-e))/(2.0*e.x);\n            vec3 ground = vec3(7.0*slope,0.25*mounds,0);\n            vec3 head = vec3(0.2*sway,0.1*bob,0.0);\n            c.pos = p + ground + head\n                + 0.05*wobble*vec3(0.5,1.0,0.5);\n            c.target = vec3(10.0,-16.0,0.0)\n                + 0.3*wobble*vec3(1.0,0.5,1.0);\n            c.up = normalize(vec3(-0.004*sway,1.0,-0.001*bob));\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case 3: {\n            // track along pillars, facing hole.\n            blackhole_center = vec3(0.0,-4.0,0.0);\n            blackhole_radius = 1.25;\n            float z = 19.0 - 19.6*t;\n            c.pos = vec3(-30.0,-6.9,z);\n            c.target = vec3(30.0,-2.0,z-5.0)\n                + 0.05*wobble*vec3(0.0,0.5,1.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 10.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case 4: {\n            // walking around pillars to peek at hole.\n            blackhole_center = vec3(0.0,-4.0,0.0);\n            blackhole_radius = 1.25;\n            const vec3 p0 = vec3(22.0,-3.0,57.0);\n            const vec3 p1 = vec3(18.0,-3.0,42.0);\n            const vec3 p2 = vec3(12.0,-3.0,35.5);\n            const vec3 p3 = vec3(11.24,-3.0,35.0);\n            float slow = sin(t*1.57);\n            float walk = shot_time/12.0;\n            float steps = sin(100.0*walk);\n            float bob = sin(100.0*(walk-0.85));\n            float sway = sin(50.0*walk);\n            float s = mix(t, t + (0.004-0.004*t)*steps, 0.7);\n            vec3 p = bezier4(s,p0,p1,p2,p3);\n            float mounds = moundsHeight(p);\n            const vec3 e = vec3(0.2,0.0,0.0);\n            float slope = (moundsHeight(p+e)-moundsHeight(p-e))/(2.0*e.x);\n            float fade = 1.0-pow(t,10.0);\n            const float peekt = 0.2;\n            float pt = step(1.0-peekt,t) * (1.0/(peekt+0.05))*(t-(1.0-peekt));\n            float peek = 4.0*pt*(1.0 - pt);\n            vec3 ground = vec3(7.0*slope*fade,0.25*mounds,0);\n            vec3 head = vec3(0.04*sway,0.04*bob,0.0)*fade;\n            c.pos = p + ground + head\n                + 0.02*wobble*vec3(0.5,1.0,0.5)*fade;\n            c.target = vec3(0.0,-4.0,0.0);\n                + 0.3*wobble*vec3(1.0,0.5,1.0)*fade;\n            c.up = normalize(\n                vec3(0.0,1.0,0.0)\n                + vec3(-0.004*sway,0,-0.0005*bob)*fade\n                + vec3(-0.08,0,0)*peek\n            );\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case 5: {\n            // Slow track from high above hole as it starts to rise.\n            float r = step(0.6,t);\n            float rt = r*(t - 0.6);\n            float hole_rise = 10.0*rt*rt;\n            blackhole_center = vec3(0.0,-5.0+hole_rise,0.0);\n            blackhole_radius = 1.25;\n            c.pos = vec3(\n                -25.0+30.0*t,\n                25.0,\n                38.0);\n            c.target = vec3(0.0,-6.0,0.0)\n                + 0.05*wobble*vec3(1.0,0.7,0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 13.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case 6: {\n            // Run at and leap into hole as it rises.\n            float hole_rise = 3.5*sqrt(t);\n            blackhole_center = vec3(0.0,-4.0+hole_rise,0.0);\n            blackhole_radius = 1.25;\n            const vec3 p0 = vec3(3.0,-3.0,40.0);\n            const vec3 p1 = vec3(0.0,-3.0,0.0);\n            float walk = shot_time/9.0;\n            float steps = sin(100.0*walk);\n            float bob = sin(100.0*(walk-0.85));\n            float sway = sin(50.0*walk);\n            vec3 p = mix(p0,p1,t);\n            float mounds = moundsHeight(p);\n            const float leapd = 0.2;\n            const float leaps = 1.0-leapd;\n            float lt = step(leaps,t);\n            float slt = smoothstep(-0.05,0.05, t-leaps);\n            float gt = 1.0-slt;\n            float leapy = 4.0*2.0*(t-leaps)*(1.0-2.0*(t-leaps));\n            vec3 ground = vec3(0.0,0.25*mounds,0.0)*gt;\n            vec3 head = vec3(0.1*sway,0.15*bob,0.0)*gt;\n            vec3 leap = vec3(0.0,2.5*leapy,0.0)*slt;\n            c.pos = p + ground + head + leap;\n                + 0.02*wobble*vec3(0.5,1.0,0.5);\n            c.target = vec3(0.0,-3.0+0.5*hole_rise,0.0) + 0.2*leap;\n                + 1.0*wobble*vec3(0.5,1.0,0.5)*gt;\n            c.up = normalize(\n                vec3(0.0,1.0,0.0)\n                + vec3(-0.004*sway,0,-0.002*bob)*gt\n            );\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 1;\n        } break;\n        case 7: {\n            //float m = (0.5 + 0.5*cos(3.14159*t)); // ease start and end\n            //float m = 1.0+sin(3.14159+0.5*3.14159*t); // ease at end\n            float m = 1.0-t; // linear\n            float a = 15.0*m;\n            c.pos = vec3(0.0,0.0,a);\n            c.target = vec3(0.0,0.0,-1000.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 1.0 + 29.0*m;\n            c.flatten = 1.0;\n            c.scene = 2;\n        } break;\n\n        // Debug cameras:\n        case -1: {\n            // Far, approaching and retreating.\n            c.pos = vec3(0.0,-4.0,4.0 + 10.0 + 10.0*cos(time/10.0));\n            c.target = vec3(0.0 + 5.0*sin(time/10.0),-4.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case -2: {\n            // Near, approaching and retreating.\n            c.pos = vec3(0.0,-4.0,4.0 + 3.0*cos(time/4.0));\n            c.target = vec3(0.0 + 0.0*sin(time/4.0),-4.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case -3: {\n            // Far, still.\n            c.pos = vec3(-4.0,-4.0,28.0);\n            c.target = vec3(0.0,-4.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case -4: {\n            // Near, still.\n            c.pos = vec3(0.6,-4.0,4.0);\n            c.target = vec3(0.0,-4.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case -5: {\n            // Far, reverse, still.\n            c.pos = vec3(-4.0,-4.0,-28.0);\n            c.target = vec3(0.0,-4.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case -6: {\n            // Near, orbiting.\n            float d = 3.0;\n            float t = time/10.0;\n            c.pos = vec3(d*sin(t),-4.0,d*cos(t));\n            c.up = vec3(0.0,1.0,0.0);\n            c.target = vec3(0.0,-4.0,0.0);\n            // BUG: serious distortion when the camera faces reverse from the\n            // starting point. This is because of the pillar modulo!\n            // BUG: also the lighting looks utterly fucked in reverese; so make\n            // sure the lighting suits the camera angles I decide on.\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        case -7: {\n            // track along pillars, facing hole.\n            float z = 19.0 - 19.6*t;\n            c.pos = vec3(30.0,-4.0,z);\n            c.target = vec3(-30.0,-2.0,z-5.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 50.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n        // Whatever:\n        default: {\n            c.pos = vec3(100.0,100.0,100.0);\n            c.target = vec3(0.0,0.0,0.0);\n            c.up = vec3(0.0,1.0,0.0);\n            c.fovY = 30.0;\n            c.flatten = 1.0;\n            c.scene = 0;\n        } break;\n    }\n    return c;\n}\n\nvoid generateRay(camera cam, vec2 texCoord, out vec3 ro, out vec3 rd)\n{\n    mat4 viewFromWorld, worldFromView;\n    vec3 eye;\n    {\n    eye = cam.pos;\n    vec3 center = cam.target;\n    vec3 up = cam.up;\n    viewFromWorld = matLookAt(eye,center,up);\n    worldFromView = inverse(viewFromWorld);\n    }\n\n    // Rays:\n\n    {\n    vec2 aspectCorrection = vec2((iResolution.x / iResolution.y), 1.0);\n    vec2 windowAspectCorrection = vec2((windowSize.x / windowSize.y), 1.0);\n    float aspect = aspectCorrection.x*windowAspectCorrection.x;\n    float lensFovY = radians(cam.fovY);\n    float lensFovX = lensFovY*aspect;\n\n    vec2 clipCoord = vec2(texCoord*2.0-1.0);\n    float ax = clipCoord.x * lensFovX/2.0;\n    float ay = clipCoord.y * lensFovY/2.0;\n\n    // Rotate the forward vector up/down, then across.\n    // This gives bowing out on the horizontals, but keeps verticals straight.\n    mat4 vx = matRotate( vec3(0.0,1.0,0.0), ax );\n    mat4 vy = matRotate( vec3(1.0,0.0,0.0), ay );\n    mat4 m = vx*vy;\n    rd = ( worldFromView*m*vec4(0.0,0.0,-1.0,0.0) ).xyz;\n    ro = eye;\n    \n    // Flatten the lens with this one weird trick!\n    rd.z *= cam.flatten;\n    rd = normalize(rd);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 aspectCorrection = vec2((iResolution.x / iResolution.y), 1.0);\n    vec2 windowAspectCorrection = vec2((windowSize.x / windowSize.y), 1.0);\n    vec2 texCoord = (fragCoord / iResolution.xy);\n\n    // Window:\n\n    int window = texWindowIndex(texCoord);\n    vec2 windowCoord = texToWindow(texCoord, window);\n    vec2 windowPixelSize = windowSize * iResolution.xy;\n    vec2 windowPixelCoord = windowCoord * windowPixelSize;\n\n    // Camera:\n    int shot = 999;\n    float time = mod(iTime, shot_durations[SHOT_COUNT]);\n    float shot_start = 0.0;\n#if 0\n    // force shot 6-7 transition\n    time = mod(iTime, shot_durations[6]+shot_durations[7]/8.0);\n    for( int i=6; i<8; ++i ) {\n#else\n    for( int i=0; i<SHOT_COUNT; ++i ) {\n#endif\n        float d = shot_durations[i];\n        if( (shot_start + d)>time ) {\n            shot = i;\n            break;\n        }\n        shot_start += d;\n    }\n\n#if 0\n    // Force a specific shot.\n    shot = 6;\n    shot_start = 0.0;\n    float shot_duration = shot_durations[clamp(shot,0,SHOT_COUNT)];\n    time = mod(iTime, shot_duration);\n#endif\n\n    camera cam = setup_camera( shot, shot_start, time );\n\n    vec3 ro, rd;\n    generateRay(cam, windowCoord, ro, rd);\n    \n    // FIXME: insert transition here!\n\n    // Raymarch:\n    \n    if( cam.scene<=1 ) {\n        raymarch_result result = raymarch(ro, rd, MIN_DIST, MAX_DIST);\n\n        float energy = 0.0;\n    \n    #if DRAW_BLACKHOLE\n        if( result.mat==0 )\n        {\n            vec3 p = ro + result.depth*rd;\n    \n            float b = 4.0*blackhole_radius/abs(eye.z - blackhole_center.z);\n    \n            // Want the screen space distance to the center of the hole.\n            // BUG: This isn't right, it's just fixed on the hole's \"front\".\n            float r = length(p.xy - blackhole_center.xy);\n            energy = 1.0-pow(r/blackhole_radius, 1.5);\n    \n            // BUG: need a parameter to mix blackhole/solid sphere rendering.\n            // March the ray through the hole.\n            blackhole_result br = blackhole(p, rd, eye);\n            if( br.escaped ) {\n                // March the ray where it exited the hole.\n                ro = br.ro;\n                rd = br.rd;\n                raymarch_result r2 = raymarch(ro, rd, 0.01, MAX_DIST);\n                result.depth = r2.depth;\n                result.mat = r2.mat;\n                result.stepCount = result.stepCount + br.stepCount + r2.stepCount;\n            } else {\n                // Ray didn't escape. We can do something interesting with this,\n                // as it gives us a glimpse into an alternate universe?\n                result.depth = MAX_DIST;\n            }\n        }\n    #endif\n        \n        vec3 p = ro + result.depth*rd;\n        vec3 n = estimateNormal(p);    \n    \n        // Render:\n    \n    //    window = 4; // force a slice view.\n    \n        switch(window) {\n            case 0: {\n                fragColor = render(result, p, n, ro, energy, shot, time);\n\n                // Okay, this is a mess, but for scene 1 we need both the room\n                // and the start of the transcendence for the transition...\n                // So let's do the transcendence too!\n                float shot_time = time - shot_start;\n                const float fs = 4.5;\n                if( cam.scene==1 && shot_time >= fs && result.mat == 0 ) {\n                    float shot_duration = shot_durations[clamp(shot,0,SHOT_COUNT)];\n                    float t = shot_time/shot_duration;\n                    camera c1;\n                    // This is ripped from shot 7 at t <= 0:\n                    float ofs = 8.0;\n                    float a = 15.0 + ofs - t*ofs;\n                    c1.pos = vec3(0.0,0.0,a);\n                    c1.target = vec3(0.0,0.0,-1000.0);\n                    c1.up = vec3(0.0,1.0,0.0);\n                    c1.fovY = 30.0;\n                    c1.flatten = 1.0;\n\n                    vec3 ro, rd;\n                    generateRay(c1, windowCoord, ro, rd);\n                    \n                    float t1 = clamp((shot_time-fs)/(shot_duration-fs), 0.0,1.0);\n                    raymarch_result result1 = raymarch_transcendence(\n                        ro, rd, MIN_DIST, MAX_DIST, 0.0);\n                    vec4 color = render_transcendence(result1);\n\n                    fragColor = mix(fragColor, color, t1);\n                }\n\n            } break;\n    \n            case 1: {\n                fragColor = render_stepCount(result);\n            } break;\n    \n            case 2: {\n                fragColor = render_normal(result, n);\n            } break;\n    \n            case 3: {\n                fragColor = render_depth(result);\n            } break;\n    \n            case 4: {\n                // Ignore the raymarch; slice the sdf instead.\n                vec2 centeredCoord = (windowCoord - vec2(0.5)) * 2.0;\n                centeredCoord *= (windowAspectCorrection * aspectCorrection);\n                float scale = 1.0/100.0;\n                vec3 p = vec3(centeredCoord/scale, 0.0);\n    //            p = p.zyx; // side\n    //            p = p.xyz; // front\n                p = p.yzx + vec3(0.0,-4.0,0.0); // top (with sphere)\n    //            p = p.xzy + vec3(0.0,-4.0,0.0); // top 2 (with sphere)\n                field f = sdf(p);\n                fragColor = vec4(colorize_sdf(f.d), 1.0);\n            } break;\n    \n            case 5: {\n                // Ignore the previous raymarch; render orthographically instead.\n                vec2 centeredCoord = 2.0*windowCoord - 1.0;\n                float scale = 1.0;\n                vec3 eye = vec3(centeredCoord/scale, 60.0);\n                vec3 dir = vec3(0.0, 0.0, -1.0);\n                raymarch_result result = raymarch(eye, dir, MIN_DIST, MAX_DIST);\n                fragColor = render_depth(result);\n            } break;\n    \n            default: {\n                fragColor = vec4(1, 0, 1, 1);\n            } break;\n        }\n\n    } else if( cam.scene==2 ) {\n        raymarch_result result = raymarch_transcendence(ro, rd, MIN_DIST, MAX_DIST, (time - shot_start));\n        fragColor = render_transcendence(result);\n    }\n\n}\n","name":"Image","description":"","type":"image"}]}