{"ver":"0.1","info":{"id":"dtBBRK","date":"1694225415","viewed":26,"name":"Pizza SDF 3D","username":"twixuss","description":".","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","circle","slice","segment","pizza"],"hasliked":0,"parentid":"WtGXDD","parentname":"RayMarching starting point"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Forked from template by BigWIngs https://www.shadertoy.com/view/WtGXDD\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime\n#define S01(x) S(0.0, 1.0, x)\n#define SAT(x) clamp(x, 0.0, 1.0)\n#define LSQ(x) dot(x, x)\n\nvec2 closest(vec2 point, vec2 linea, vec2 lineb) {\n\tfloat l2 = LSQ(linea-lineb);\n\tif (l2 == 0.) return linea;\n\n\tfloat t = dot(point - linea, lineb - linea) / l2;\n    t = clamp(t, 0.0, 1.0);\n\treturn linea + t * (lineb - linea);\n}\nvec2 project(vec2 v, vec2 n) {\n    return n*dot(v,n);\n}\nfloat sdDisk(vec3 uv) {\n    vec3 t = uv;\n    if (length(t.xz) > 1.0) t.xz = normalize(t.xz);\n    t.y = 0.0;\n    return distance(uv,t);\n}\nfloat sdPizza(vec3 uv, float angle) {\n    vec3 t = uv;\n    if (length(t.xz) > 1.0) t.xz = normalize(t.xz);\n    t.y = 0.0;\n    float a = fract(atan(t.z, t.x)/TAU)*TAU;\n    if (a > angle) {\n        vec2 l1 = closest(t.xz, vec2(0), vec2(1,0));\n        vec2 l2 = closest(t.xz, vec2(0), vec2(cos(angle),sin(angle)));\n        t.xz = LSQ(l1) > LSQ(l2) ? l1 : l2;\n    }\n    \n    return distance(uv,t);\n}\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat random_float(vec3 p){\n\tvec3 a = fract((p + 1.414) * vec3(31.123, 3.141, 6.762));\n\ta += dot(a, a + 12.653);\n\ta = vec3(a.x * a.y, a.x * a.z, a.y * a.z);\n    return fract(dot(a,a));\n}\nvec3 random_vec3(vec3 a) {\n    a = vec3(dot(a,vec3(127.1,311.7,634.8)), \n\t\t\t dot(a,vec3(269.5,183.3,878.8)), \n\t\t\t dot(a,vec3(413.2,631.3,194.3)));\n\treturn fract(sin(a)*43758.5453);\n}\nfloat voronoi(vec3 uv) {\n    vec3 tile = floor(uv);\n    vec3 local = uv - tile;\n    \n    float d = 100.;\n    \n    vec3 r[3*3*3];\n    \n    for (int x = -1; x <= 1; ++x) {\n        for (int y = -1; y <= 1; ++y) {\n            for (int z = -1; z <= 1; ++z) {\n                d = min(d, distance(local, vec3(x,y,z) + random_vec3(tile + vec3(x,y,z))));\n            }\n        }\n    }\n    \n    return d;\n}\nfloat noise(vec3 uv){\n    vec3 r = fract(uv);\n    r = smoothstep(0., 1., r);\n\n    vec3 t = floor(uv);\n    \n\n    float a = random_float(t + vec3(0,0,0));\n    float b = random_float(t + vec3(1,0,0));\n    float c = random_float(t + vec3(0,1,0));\n    float d = random_float(t + vec3(1,1,0));\n    float e = random_float(t + vec3(0,0,1));\n    float f = random_float(t + vec3(1,0,1));\n    float g = random_float(t + vec3(0,1,1));\n    float h = random_float(t + vec3(1,1,1));\n    return mix(mix(mix(a, b, r.x), mix(c, d, r.x), r.y),\n               mix(mix(e, f, r.x), mix(g, h, r.x), r.y), r.z);\n}\n\n\nfloat smin(float a, float b, float k) {\n\tfloat h = SAT((b-a)/k+0.5);\n\treturn b+h*(a-b+k*0.5*(h-1.0));\n}\nfloat GetDist(vec3 p) {\n    float t = 0.4 + 0.2*sin(iTime);\n    //t = 0.1;\n    t = 0.15 + 0.05*sin(iTime*1.2);\n    //t = iMouse.y/iResolution.y;\n    float a = sin(iTime)*PI+PI;\n    //a = TAU*0.1;\n    //a = iMouse.x/iResolution.x*TAU;\n    float d = sdPizza(p, a)-t;\n    d = smin(d, -(sdDisk(p*(1.0+t)-vec3(0,t,0))-t*0.5), -0.1);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p) - \n        vec3(GetDist(p-e.xyy), GetDist(p-e.yxy),GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = vec2(iTime*0.1,-0.2-0.1*sin(iTime*0.8));//iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n   \n    vec3 V = normalize(rd);\n   \n    float d = RayMarch(ro, rd);\n\n    vec3 L = normalize(vec3(2,3,1));\n    vec3 ambient = vec3(.3,.6,.9);\n    \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        vec3 N = n;\n        vec3 H = normalize(L-V);\n\n        vec4 material = mix(\n            vec4(0.9, 0.6, 0.3, 0),\n            vec4(0.9, 0.15, 0.1, 0.5), \n            S(0.5, 0.4, voronoi(p*5.0))*S(0.9,0.89,length(p))\n        );\n        material = mix(material,\n            vec4(1.0, 1.0, 0.3, 0.5),\n            S(0.3,0.2,noise((p+noise(p))*20.0))*S(0.9,0.89,length(p))\n        );\n\n        vec3 albedo = material.xyz;\n        float shiny = material.w;\n\n        vec3 dif = albedo * (ambient/PI + (dot(n, normalize(vec3(1,2,3)))*.5+.5));\n        float specular = pow(max(0.001, dot(N, H)), shiny * 100.) * shiny;\n        col = dif + specular;\n    } else {\n        col = sin(V*TAU*4.0);\n        col = vec3(0.3,0.6,0.9) + 0.1*smoothstep(0.0, 0.1, max(max(col.x, col.y), col.z));\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}