{"ver":"0.1","info":{"id":"7tdSzn","date":"1638741764","viewed":330,"name":"2D SDF Lighting","username":"Langwedocjusz","description":"Done: lights and mirrors. To do: optimization, transparent materials.\nCrank up SAMPLES in Buffer B to get cleaner visuals.\nIdea from here: https://github.com/miloyip/light2d, first implementation I saw: https://www.shadertoy.com/view/lldcDf","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DENOISE\n\n//Fast denoising from here: https://www.shadertoy.com/view/7d2SDD\nvec3 sirBirdDenoise(sampler2D imageTexture, in vec2 uv, in vec2 imageResolution);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ts = fragCoord/iResolution.xy;\n    \n    float res = 512.;\n    vec2 iChannel0Resolution = vec2(res, res * (iResolution.y/iResolution.x));\n    \n    #ifdef DENOISE\n    vec3 col = sirBirdDenoise(iChannel0, ts, iChannel0Resolution).rgb;\n    #else\n    vec3 col = texture(iChannel0, ts).rgb;\n    #endif\n\n    fragColor = vec4(col,1.0);\n}\n\n//================================================================================\n\n#define SAMPLES 40  // HIGHER = NICER = SLOWER\n#define DISTRIBUTION_BIAS 0.6 // between 0. and 1.\n#define PIXEL_MULTIPLIER  1.5 // between 1. and 3. (keep low)\n#define INVERSE_HUE_TOLERANCE 20.0 // (2. - 30.)\n\n#define GOLDEN_ANGLE 2.3999632 //3PI-sqrt(5)PI\n\n#define pow(a,b) pow(max(a,0.),b) // @morimea\n\nmat2 sample2D = mat2(cos(GOLDEN_ANGLE),sin(GOLDEN_ANGLE),-sin(GOLDEN_ANGLE),cos(GOLDEN_ANGLE));\n\nvec3 sirBirdDenoise(sampler2D imageTexture, in vec2 uv, in vec2 imageResolution) {\n    \n    vec3 denoisedColor           = vec3(0.);\n    \n    const float sampleRadius     = sqrt(float(SAMPLES));\n    const float sampleTrueRadius = 0.5/(sampleRadius*sampleRadius);\n    vec2        samplePixel      = vec2(1.0/imageResolution.x,1.0/imageResolution.y); \n    vec3        sampleCenter     = texture(imageTexture, uv).rgb;\n    vec3        sampleCenterNorm = normalize(sampleCenter);\n    float       sampleCenterSat  = length(sampleCenter);\n    \n    float  influenceSum = 0.0;\n    float brightnessSum = 0.0;\n    \n    vec2 pixelRotated = vec2(0.,1.);\n    \n    for (float x = 0.0; x <= float(SAMPLES); x++) {\n        \n        pixelRotated *= sample2D;\n        \n        vec2  pixelOffset    = PIXEL_MULTIPLIER*pixelRotated*sqrt(x)*0.5;\n        float pixelInfluence = 1.0-sampleTrueRadius*pow(dot(pixelOffset,pixelOffset),DISTRIBUTION_BIAS);\n        pixelOffset *= samplePixel;\n            \n        vec3 thisDenoisedColor = \n            texture(imageTexture, uv + pixelOffset).rgb;\n\n        pixelInfluence      *= pixelInfluence*pixelInfluence;\n        /*\n            HUE + SATURATION FILTER\n        */\n        pixelInfluence      *=   \n            pow(0.5+0.5*dot(sampleCenterNorm,normalize(thisDenoisedColor)),INVERSE_HUE_TOLERANCE)\n            * pow(1.0 - abs(length(thisDenoisedColor)-length(sampleCenterSat)),8.);\n            \n        influenceSum += pixelInfluence;\n        denoisedColor += thisDenoisedColor*pixelInfluence;\n    }\n    \n    return denoisedColor/influenceSum;\n    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Hash function from here: https://www.shadertoy.com/view/Msf3WH\nfloat hash(vec2 point) {\n    point = mod(point, 1.0);\n\tfloat p = dot(point,vec2(127.1,311.7));\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n//Generate noise texture once per resolution change:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 res;\n    \n    if (iFrame < 1)\n        res = iResolution;\n    \n    if (iFrame < 1 || res != iResolution) {\n        res = iResolution;\n        vec3 col = vec3(hash(uv));\n        fragColor = vec4(col,1.0);\n    }\n    \n    else\n        fragColor = texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//#define ART_DECO\n#define USE_BOUNDING_BOXES\n#define USE_REFLECTIONS\n#define MAX_BOUNCES 2\n\n#define NUM_OF_OBJECTS 3\n#define NUM_OF_LIGHTS 2\n\nconst vec3 COLORS[3] = vec3[3](vec3(0.0), vec3(0.9, 0.9, 1.0), vec3(1.0, 1.0, 0.1));\n\n#define MAT_EMISSIVE 0\n#define MAT_REFLECTIVE 1\n\n#define MAX_MARCH_STEPS 32\n#define MAX_MARCH_DIST  4.66\n#define MIN_MARCH_DIST  0.0005\n\n#define SAMPLES 32\n\nconst float inv_samples = 1.0/float(SAMPLES);\n\nfloat sdfCircle(vec2 point, float radius) {\n    return length(point) - radius;\n}\n\nfloat sdfBox(vec2 point, vec2 box_dims ) {\n    vec2 q = abs(point) - box_dims;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nBoundingBox getBoundingBox(int i){\n    vec2 translation, half_dims;\n    \n    switch(i) {\n        //Emissive:\n        case 0:\n            translation = vec2(0.8, 0.0);\n            half_dims = vec2(0.22);\n            break;\n        case 1:\n            translation = vec2(-0.4, 0.0) + 0.3*vec2(cos(iTime), 0.0);\n            half_dims = vec2(0.11);\n            break;\n        //Reflective:\n        case 2:\n            translation =  vec2(-0.8, 0.0);\n            half_dims = vec2(0.2, 0.35);\n            break;\n    }\n    \n    return CreateBox(translation, half_dims);\n}\n\nvoid AddObj(inout float dist, float sd) {\n    if (dist > sd)\n        dist = sd;\n}\n\nvoid AddObj(inout float dist, float sd, inout int MAT, int mat, inout int ID, int id) {\n    if (dist > sd) {\n        dist = sd;\n        ID = id;\n        MAT = mat;\n    }  \n}\n\nfloat Map(vec2 point) {\n    float dist = 1e9;\n    \n    //Reflective stuff:\n    AddObj(dist, max(sdfBox(point - vec2(-0.8, 0.0), vec2(0.2, 0.35)), \n                    -sdfCircle(point - vec2(-0.6, 0.0), 0.3)));\n    \n    return dist;\n}\n\nfloat Map(vec2 point, inout int MAT, inout int ID) {\n    float dist = 1e9;\n    \n    //Lights:\n    AddObj(dist, sdfBox(point - vec2(0.8, 0.0), vec2(0.22-0.05))-0.05,\n           MAT, MAT_EMISSIVE, ID, 1);\n    vec2 translation = vec2(-0.4, 0.0) + 0.3*vec2(cos(iTime), 0.0);\n    AddObj(dist, sdfCircle(point - translation, 0.11),\n           MAT, MAT_EMISSIVE, ID, 2);\n    \n    //Reflective stuff:\n    AddObj(dist, max(sdfBox(point - vec2(-0.8, 0.0), vec2(0.2, 0.35)), \n                    -sdfCircle(point - vec2(-0.6, 0.0), 0.3)),\n           MAT, MAT_REFLECTIVE, ID, 0);\n    \n    return dist;\n}\n\nvec2 Gradient(vec2 point) {\n    float h = 0.001;\n    vec2 ve = vec2(0.0,h);\n    float x = Map(point + ve.yx) - Map(point - ve.yx);\n    float y = Map(point + ve.xy) - Map(point - ve.xy);\n    return normalize(vec2(x,y));\n}\n\nvec3 Trace(vec2 origin, vec2 direction) {\n    float total_dist = 0.0;\n    int material = 0, id = 0, bounces = 0;\n    vec2 point = origin;\n    \n    //Early exit when inside objects\n    if (Map(point, material, id) < 0.0)\n        return vec3(float(material == MAT_EMISSIVE));\n    \n    //Raymarching:\n    for (int i=0; i < MAX_MARCH_STEPS && total_dist < MAX_MARCH_DIST; i++) {\n        float sd = Map(point, material, id);\n        \n        if (abs(sd) < MIN_MARCH_DIST && material == MAT_EMISSIVE)\n            return COLORS[id];\n        \n        else if (abs(sd) < MIN_MARCH_DIST){\n            #ifdef USE_REFLECTIONS\n            direction = reflect(direction, Gradient(point));\n            bounces++;\n            if (bounces > MAX_BOUNCES) break;\n            #else\n            break;\n            #endif\n        }\n        \n        point += sd * direction;\n        total_dist += sd;\n    }    \n    \n    return vec3(0.0);\n}\n\n\nvec3 Sample(vec2 point, vec2 coords) {\n    vec3 sum = vec3(0.0);\n    for (int i=0; i<SAMPLES; i++) {\n        float theta = 2.0*PI*inv_samples*(float(i)\n            #ifndef ART_DECO\n                + texture(iChannel0, coords).r\n            #endif\n        );\n        vec2 dir = vec2(cos(theta), sin(theta));\n        \n        //Discard ray if it doesn't intersect any of the bounding boxes:\n        #ifdef USE_BOUNDING_BOXES\n        bool intersects = false;\n        for (int j=0; j<NUM_OF_OBJECTS; j++) {\n            intersects = intersects || IntersectBox(getBoundingBox(j), point, dir);\n        }\n        if (intersects)\n        #endif\n            sum += 2.0*Trace(point, dir);\n    }\n    return inv_samples*sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ts = fragCoord/iResolution.xy;\n    vec2 uv = 2.0*ts - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = Sample(uv, ts);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535\n\nstruct BoundingBox {\n    float min_x, max_x, min_y, max_y;\n};\n\nBoundingBox CreateBox(vec2 translation, vec2 half_dims) {\n    return BoundingBox(translation.x - half_dims.x, translation.x + half_dims.x,\n                       translation.y - half_dims.y, translation.y + half_dims.y);\n}\n\nbool IntersectBox(BoundingBox b, vec2 origin, vec2 dir) {\n    vec2 inv = 1.0/dir;\n\n    float tx1 = (b.min_x - origin.x)*inv.x;\n    float tx2 = (b.max_x - origin.x)*inv.x;\n\n    float tmin = min(tx1, tx2);\n    float tmax = max(tx1, tx2);\n\n    float ty1 = (b.min_y - origin.y)*inv.y;\n    float ty2 = (b.max_y - origin.y)*inv.y;\n\n    tmin = max(tmin, min(ty1, ty2));\n    tmax = min(tmax, max(ty1, ty2));\n\n    return tmax >= tmin;\n}","name":"Common","description":"","type":"common"}]}