{"ver":"0.1","info":{"id":"DtX3W4","date":"1671916047","viewed":119,"name":"fibbin lattice!","username":"valalalalala","description":"Hexagon sphere stuff led to the need to evenly distributed points and Fibonnaci Lattice. Holding \"1\", \"2\", \"3\" will switch lattice implementations. Pressing space toggles animation.\n\nBlackle's \"Satanic Torture  Ball\" provided a lot of the heavy lifting. ","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","fibonnaccilattice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"         /////////////////////////////////////////////////////////////////\n        //                                                            ////\n       //  \"fibbin lattice!\"                                         // //\n      //                                                            //  //\n     //  While working on doing some hexagon sphere stuff, the     //   //\n    //  need to evenly distributed points on a sphere arose and   //    //\n   //  led to the fibonnaci lattice. Blackle's \"Satanic Torture  //     //\n  //  Ball\" provided a lot of the heavy lifting.                //     //\n //                                                            //     //\n////////////////////////////////////////////////////////////////     //\n//                                                            //    //\n// Creative Commons Attribution-NonCommercial-ShareAlike      //   //\n// 3.0 Unported License                                       //  //\n//                                                            // //\n// by Val \"valalalalala\" GvM ðŸ’ƒ 2022                          ////\n//                                                            ///\n////////////////////////////////////////////////////////////////\n//\n// There are 3 slightly different fibonnaci lattice\n// implementations:\n//\n// *) default is Blackle's version\n// 1) Martin Roberts\n// 2) Fnord off StackOverflow\n// 3) Tweak of Fnord\n//\n// The Martin Robert's and Blackle's implementation look\n// similar but are mirrored in y. Blackle's has the\n// advantage of cleaner code. Fnord's seems to have more \n// uniform distances.\n//\n// Hitting the numeric keys 1, 2, or 3 will toggle the \n// different implementations.\n//\n// Pressing space will toggle the animation.\n// Pressing 0 will draw a faceted sphere.\n//\n// Changing the FIBONACCI_LATTICE_POINTS in Buffer B to \n// either very large of small values is kinda fun.\n//\n// Sources:\n//\n// - Blackle's \"Satanic Torture Ball\" https://www.shadertoy.com/view/3dffDS\n// - Martin Roberts http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/\n// - Fnord https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere\n// -- https://arxiv.org/pdf/0912.4540.pdf\n//\n////////////////////////////////////////////////////////////////\n\nfloat NOW; // set in whatTimeIsIt, toggles animation with \"space\"\n\n////////////////////////////////////////////////////////////////\n\n// closest fibbonacci lattice point for this point\nvec4 fibber( vec3 p ) {\n    vec2 suv = map_from_sphere( p );\n    return texture(iChannel1, suv);\n}\n\n////////////////////////////////////////////////////////////////\n\n// false, true, ...\nbool keyToggle( int key ) {\n    return ZED < texelFetch( iChannel2, ivec2(key,2), 0 ).x;\n}\n\n////////////////////////////////////////////////////////////////\n \nSun makeSun( float cameraDistance, vec3 target, float roll, float zoom ) {\n    return Sun(\n        gl_FragCoord.xy, iResolution.xy, iMouse.xyz, NOW,\n        cameraDistance, target, roll, zoom\n    );\n}\n\nSun makeSun() {\n    return makeSun( 2., FV4.xxx, ZED, EINS );\n}\n\nRay sunshine() {\n    return shine( makeSun() );\n}\n\nRay sunshine(float cameraDistance, vec3 target, float roll, float zoom ) {\n    return shine( makeSun( cameraDistance, target, roll,  zoom ) );\n}\n\n////////////////////////////////////////////////////////////////\n\nvec4 facet( vec3 p, vec3 q ) {\n    p = normalize( p );\n    q = normalize( q );\n    \n    float d = dot( p, q );\n    return vec4( p - q * d, d );\n}\n\nvec4 facet( vec3 p ) {\n    return facet( p, fibber( p ).xyz );\n}\n\nfloat map( vec3 p ) {\n    vec2 t = trig( NOW );\n\n    float radius = 1. - .22 * t.x;\n        \n    vec3 onSphere = normalize( p );\n    vec4 fib = fibber( onSphere );\n\n    if ( keyToggle( 48 ) ) {\n        return distance( p, facet( p, fib.xyz ).xyz ) - radius;\n    }\n   \n    return length(p) - radius - fib.w * t.y;\n} \n        \nvec4 march( vec3 eye, vec3 direction ) { \n    float total = .0, now;\n    vec3 current = eye;\n    for( int i = 0 ; i < int( ZFAR ) ; i++ ) {\n        total += ( now = map( current ) );\n        if ( abs( now ) < EPSILON ) {\n            return vec4( current, total );\n        }\n        if ( total > ZFAR ) break;\n        current = eye + total * direction;\n    }\n        \n    return vec4( current, -abs( total ) );\n}\n\n// https://suricrasia.online/demoscene/functions/\nvec3 mapNormal(vec3 p,float d) {\n    mat3 k = mat3(p,p,p) - mat3( d * EPSILON );\n    return normalize( map(p) - vec3( map(k[0]), map(k[1]), map(k[2])) );\n}\n\n////////////////////////////////////////////////////////////////\n\nvec2 reRez( in vec2 fragCoord, in vec2 srcResolution, in vec2 dstResolution ) {\n   return mod( fragCoord / srcResolution * dstResolution, dstResolution ); \n}\n\nvec2 reRez( in vec2 fragCoord ) {\n    return reRez( fragCoord, iResolution.xy, iChannelResolution[0].xy );\n}\n\nvec3 missColor( in vec2 fragCoord, Ray ray, vec4 hit ) {\n    vec2 uv = reRez( fragCoord );\n    ivec2 st = ivec2( uv );\n    \n    // show the full fibbonaci lattic and the\n    // closest assignment\n    \n    vec3 fib = texelFetch( iChannel0, st, 0 ).rgb;\n    vec3 cls = texelFetch( iChannel1, st, 0 ).rgb;\n    \n    // edge detection\n    \n    vec2 nb = reRez( fragCoord + vec2( EINS ) );\n    vec3 kls = texelFetch( iChannel1, ivec2( nb ), 0 ).rgb;\n    float cd = dot( kls, cls );\n    //return 1.-cls;\n    \n    vec3 edgeColor = 2. * abs(kls-cls);\n    cls = mix( cls, edgeColor, step(cd,.999 ) );\n    \n    // fade the 2 backgrounds\n    \n    float t = abs( cos( NOW * .33 ) );\n    t = sign( t ) * t * t;\n    \n    return mix( fib, cls, t );\n}\n\nvec3 hitColor( in vec2 fragCoord, Ray ray, vec4 hit ) {\n    vec4 fibd = fibber( hit.xyz );\n    vec3 n = mapNormal( fibd.xyz, .001 );\n    \n    // axis lighting from https://www.shadertoy.com/view/ttGfz1\n    float l = dot(max(n, 0.), vec3(.77));\n    \n#if 0\n    // idk...\n    vec4 f4 = facet( hit.xyz, fibd.xyz );\n    vec3 nf = mapNormal( f4.xyz, EPSILON );\n#else\n\n    l += fibd.w * 2.2;\n    vec3 color = l * fibd.xyz;\n \n    return color;\n#endif\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid whatTimeIsIt() {\n    NOW = keyToggle( 32 ) ? ZED : iTime;\n}\n\n////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    whatTimeIsIt();\n    fragColor.a = EINS;\n    \n    Ray ray = sunshine();\n    vec4 hit = march( ray.eye, ray.direction );\n    \n    if ( hit.w < ZED ) {\n        fragColor.rgb = missColor( fragCoord, ray, hit ); \n    } else {\n        hit = mix( hit, march( ray.eye + EPSILON, ray.direction ), .33 );\n        fragColor.rgb = hitColor( fragCoord, ray, hit );\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\n *\n * This buffer just shows a really large lattice and is not\n * really used for anything besides background\n *\n */\n \nfloat getIndex( in vec2 fragCoord, in vec3 resolution ) {\n    return fragCoord.x + fragCoord.y * resolution.x;\n}\n\nbool keyDown( int key ) {\n    return .0 < texelFetch( iChannel0, ivec2(key,0),0 ).x;\n}\n\nint getWhich() {\n    int which = 0;  \n    if ( keyDown( 49 ) ) which = 1; else \n    if ( keyDown( 50 ) ) which = 2; else\n    if ( keyDown( 51 ) ) which = 3;\n    return which;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // avoids duplication but can't change implementations dynamically\n    if (false && iFrame != 0) {\n        fragColor = texelFetch(iChannel1,ivec2(fragCoord.xy),0);\n        return;\n    }\n    \n    float index = getIndex( fragCoord, iResolution );\n    float maxIndex = iResolution.x * iResolution.y;\n    int which = getWhich();\n    \n    vec3 fib = fibbonaciLattice( which, fragCoord, index, maxIndex );\n    \n    vec3 uvs = map_to_sphere( fragCoord / iResolution.xy );\n    float d = distance( fib, uvs );\n\n    fragColor = vec4( .5 + .5 * fib, d );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/**\n *\n * Define some constants, some utility functions and some \n * raymarching boilerplate\n *\n */\n\nconst vec4 FV4 = vec4( .0, (44.0 / 7.0), .5, 1. );\nconst vec3 V101 = vec3( -1., .0, +1. );\n\n#define ZED  FV4.x\n#define TAU  FV4.y\n#define HALB FV4.z\n#define EINS FV4.w\n#define PI   (TAU * HALB)\n\n#define EPSILON  .001\n#define ZFAR     199.\n\nconst float GOLDEN_RATIO = ( 1. + sqrt(5.) ) / 2.;\nconst float GOLDEN_ANGLE = PI * ( 3. - sqrt( 5. ) );\n\nconst vec2 HEX_MOD = vec2( 1., sqrt( 3. ) );\n\n\n/////////////////////////////////////////////////////////////////////////////\n\nfloat scaleOff( float v, float m ) {\n    return m + v * m;\n}\n\nvec2 trig( float angle ) {\n    return vec2( cos(angle), sin(angle) );\n}\n\nvec2 pixelToUv( vec2 st, vec2 resolution ) {\n    return ( st * 2. - resolution.xy ) / resolution.y;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// from Blackle's https://www.shadertoy.com/view/3dffDS\n\nvec3 map_to_sphere(vec2 p){\n    float theta = (p.x-0.5)*PI*2.;\n    float phi = (p.y-0.5)*PI*2.;\n    return vec3(sin(phi)*sin(theta), sin(phi)*cos(theta), cos(phi));\n}\n\nvec2 map_from_sphere(vec3 p) {\n    p = normalize(p);\n    return vec2(atan(p.x,p.y)/PI/2.+0.5, acos(p.z)/PI/2.+0.5);\n}\n\nvec3 blackle( in vec2 fragCoord, float index, float maxIndex ) {\n    float longitude = GOLDEN_ANGLE * index;\n    float latitude = asin( -1. + 2. * index / maxIndex );\n\n    return vec3(\n        sin( longitude ) * cos( latitude ),\n        cos( longitude ) * cos( latitude ),\n        sin( latitude )\n    );\n}\n\n// http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/\nvec3 martinRoberts( in vec2 fragCoord, float index, float maxIndex ) {\n    float epsilon = .33;\n#if 1    \n    if( maxIndex >= 600000. ) epsilon = 214.; else\n    if( maxIndex >= 400000. ) epsilon = 75.; else\n    if( maxIndex >= 11000. ) epsilon = 27.; else\n    if( maxIndex >= 890. ) epsilon = 10.; else\n    if( maxIndex >= 177. ) epsilon = 3.33; else\n    if( maxIndex >= 24. ) epsilon = 1.33;\n#endif\n\n    float longitude = TAU * index / GOLDEN_RATIO; // theta\n    float latitude = acos(1. - 2.*(index+epsilon)/(maxIndex-1.+2.*epsilon)); // phi\n\n    return vec3(\n        cos( longitude ) * sin( latitude ),\n        sin( longitude ) * sin( latitude ),\n        cos( latitude )\n    );\n}\n\n// based on https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere\nvec3 fnord( in vec2 fragCoord, float index, float maxIndex ) {\n    float i = index / maxIndex;\n\n    float y = 1. - i * 2.; // from +1 to -1\n    float radius = sqrt( 1. - pow( y, 2. ) ); // radius at y\n\n    float theta = GOLDEN_ANGLE * index;// # golden angle increment\n\n    float x = cos( theta ) * radius;\n    float z = sin( theta ) * radius;\n\n    return vec3( x, y, z );\n}    \n\n// messin' around...\nvec3 fnordish( in vec2 fragCoord, float index, float maxIndex ) {\n    float i = index / maxIndex;\n    \n    float y = 1. - i * 2.; // from +1 to -1\n    float radius = sqrt( 1. - pow( y, 2. ) ); // radius at y\n    \n    float theta = GOLDEN_RATIO * index;// # golden ratio increment\n\n    return vec3( radius * trig( theta ), y ).xzy;\n}\n\nvec3 fibbonaciLattice( in int which, in vec2 fragCoord, float index, float maxIndex ) {\n    switch ( which ) {\n        case 1: return martinRoberts( fragCoord, index, maxIndex );\n        case 2: return fnord( fragCoord, index, maxIndex );\n        case 3: return fnordish( fragCoord, index, maxIndex );\n    }\n    return blackle( fragCoord, index, maxIndex );\n} \n\n////////////////////////////////////////////////////////////////////////////\n\nstruct Sun {\n    vec2 st;\n    vec2 resolution;\n    vec3 mouse;\n    float now;\n    float cameraDistance;\n    vec3 target;\n    float roll;\n    float zoom;\n};\n\nstruct Ray {\n    vec2 uv;\n    vec3 eye;\n    vec3 direction;\n};\n\n//////////////////////////////////////////////////////\n\n// zab,xZup,yXz | zxy:ab,zup,xz\nmat3 makeCamera( vec3 a, vec3 b, float roll ) {\n    vec3 up = vec3( sin(roll),cos(roll), .0);\n\tvec3 z = normalize( b - a );\n\tvec3 x = normalize( cross( z, up ) );\n\tvec3 y = normalize( cross( x, z ) );\n\treturn mat3( x, y, z );\n}\n\nvec3 cameraEye( vec3 mouse, vec2 resolution, float viewDistance, float now ) {\n    vec2 ms = pixelToUv( mouse.xy, resolution.xy );\n    \n    if ( mouse.z < .0 ) {\n        ms = vec2( cos( now * .33 ), .0 );\n    }\n    \n    vec2 t = viewDistance * trig( ms.x );\n    return vec3( t.y, viewDistance * sin( ms.y * TAU ), t.x );\n}\n\nRay shine( Sun sun ) {\n    vec2 uv = pixelToUv( sun.st, sun.resolution );\n    \n    vec3 eye = cameraEye( sun.mouse, sun.resolution, sun.cameraDistance, sun.now );\n    \n    mat3 camera = makeCamera( eye, sun.target, sun.roll );\n    vec3 direction = normalize( camera * vec3( uv.xy, sun.zoom ) );\n\n    return Ray( uv, eye, direction );\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nfloat sdHex( vec2 uv ) {    \n    uv = abs( uv );\n    float angled = dot( uv, normalize( HEX_MOD ) );\n    float sides = uv.x;\n    \n    return max( angled, sides );\n}\n\nvec4 hexTile( vec2 uv ) {\n    vec2 hexHalb = HALB * HEX_MOD;\n    \n    vec2 a = mod( uv ,          HEX_MOD ) - hexHalb;\n    vec2 b = mod( uv + hexHalb, HEX_MOD ) - hexHalb;\n    \n    vec2 nu = dot( a,a ) < dot( b,b ) ? a : b;\n    vec2 id = ( uv - nu );\n\n    float angle = atan( nu.x, nu.y );\n    float d = .5 - sdHex( nu );\n\n    return vec4( angle, d, id.x, id.y );\n}\n\nvec3 hexColor( vec4 hx ) {\n    return fract( vec3( \n        HALB + HALB * hx.y * cos( hx.x ),\n        abs(hx.wz+3.) * 3.3\n    ) );\n}\n\nvec3 hexColor( vec2 uv ) {\n    return hexColor( hexTile( uv ) );\n}\n\n// face mapping from http://www.adventuresingamedev.com/home/texture-mapping-on-a-sphere \nvec2 normalPointTo2d( vec3 n, vec3 p ) {\n    vec3 a = abs( n );\n    float m = max( a.x, max( a.y, a.z ) );\n    if ( m == a.x ) return n.x < ZED ? vec2( -p.z, p.y ) : p.zy; // left or right\n    if ( m == a.y ) return n.y < ZED ? vec2( -p.x, p.z ) : p.xz; // down or up\n    return n.z < ZED ? p.xy : vec2( -p.x, p.y );\n}\n\n////////////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/**\n *\n * This buffer precalculates the closest fibonnacci lattice\n * point for any given point. Basically the same as Blackle's \n * Satanic Torture Ball https://www.shadertoy.com/view/3dffDS\n * Buffer A\n *\n */\n \n// setting this it to 256 or 1024 doesn't seem to \n// impact performance. setting it to silly low values\n// is actually pretty fun (like 13). I picked 202 because\n// I like the vibe...\n\nconst int FIBONACCI_LATTICE_POINTS = 202; // 1024; //256;\n \nbool keyDown( int key ) {\n    return .0 < texelFetch( iChannel0, ivec2(key,0),0 ).x;\n}\n\nint getWhich() {\n    int which = 0;  \n    if ( keyDown( 49 ) ) which = 1; else \n    if ( keyDown( 50 ) ) which = 2; else\n    if ( keyDown( 51 ) ) which = 3;\n    return which;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // avoids duplication but can't change implementations dynamically\n    if (false && iFrame != 0) {\n        fragColor = texelFetch(iChannel1,ivec2(fragCoord.xy),0);\n        return;\n    }\n    \n    const int count = FIBONACCI_LATTICE_POINTS;\n    int which = getWhich();\n    \n\n    vec3 uvs = map_to_sphere( fragCoord / iResolution.xy );\n    \n    vec3 closest;\n    float minimumDistance = 3e11;\n    \n    for ( int i = 0 ; i < count ; i++ ) {\n        vec3 fib = fibbonaciLattice( which, fragCoord, float(i), float(count) );\n        \n        float d = distance( uvs, fib );\n        if ( d < minimumDistance ) {\n            closest = fib;\n            minimumDistance = d;\n        }\n    }\n    \n    fragColor = vec4( closest, minimumDistance );\n}","name":"Buffer B","description":"","type":"buffer"}]}