{"ver":"0.1","info":{"id":"4cyXW3","date":"1716765703","viewed":40,"name":"Raymarching studies - 00","username":"zschzen","description":"a simple studie","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","studies"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS    80\n#define SURFACE_DIST 0.001\n#define MAX_DIST     100.0\n\n// Signed distance function for the scene\nfloat\nsceneSDF( vec3 p )\n{\n    //Sphere xyz is position w is radius\n    vec4 s        = vec4( sin( iTime ) * 3., 0, 0, 1 );\n    float dSphere = sdSphere( p - s.xyz, s.w );\n\n    float dBox = sdBox( p, vec3( .75 ) );\n\n    float ground = p.y + .75;\n\n    // Return the minimum distance to the geometry\n    return min( ground, smin( dSphere, dBox, 1.0 ) );\n}\n\n// Ray marching algorithm to find intersection with the scene\nfloat\nRayMarch( vec3 ro, vec3 rd )\n{\n    float t = 0.;  // Initialize ray march distance\n    for ( int i = 0; i < MAX_STEPS; ++i )\n    {\n        vec3  p = ro + t * rd;    // Current point along the ray\n        float d = sceneSDF( p );  // Distance to the scene\n\n        t += d;                   // Advance the ray\n\n        // Break if the ray hits the object or goes beyond max distance\n        if ( d < SURFACE_DIST || t > MAX_DIST ) break;\n    }\n    return t;\n}\n\nvoid\nmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates\n    vec2 uv = ( fragCoord * 2. - iResolution.xy ) / iResolution.y;\n    vec2 m  = ( iMouse.xy * 2. - iResolution.xy ) / iResolution.y;\n    \n    // Initialize ray origin and direction\n    vec3 ro = vec3( 0.0, 0.0, -3. );\n    vec3 rd = normalize( vec3( uv, 1.0 ) );\n\n    // Apply camera rotations based on mouse position\n    {\n        mat2 r = rot2D(-m.y);\n        // Vertical rotation\n        ro.yz *= r; rd.yz *= r;\n        r = rot2D(-m.x);\n        // Horizontal rotation\n        ro.xz *= r; rd.xz *= r;\n    }\n\n    // Perform ray marching\n    float t  = RayMarch( ro, rd );\n    vec3 col = vec3( t * 0.2 );\n    \n    // Set the fragment color\n    fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI  3.1415925359\n#define TAU 6.2831852\n\n//------------------------------------------------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n//------------------------------------------------------------------\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nmat2 rot2D( float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    \n    return mat2( c, -s, s, c );\n}\n\n// Rodrigues rotation formula\nvec3 rot3D( vec3 p, vec3 axis, float angle )\n{\n    return mix( dot( axis, p ) * axis, p, cos( angle ) )\n            + cross( axis, p ) * sin( angle );\n}","name":"Common","description":"","type":"common"}]}