{"ver":"0.1","info":{"id":"fscSz7","date":"1632833364","viewed":84,"name":"SuperSimpleRayTracing","username":"liaozixin","description":"A simple and crude Whitted-Style Ray Tracing, only specular reflection.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","cg"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n#define EPSILON 0.001\n#define MAX_T 1000000.\n#define BOUND_N 100\n\nstruct Sphere\n{\n    vec3 c;\n    float r;\n};\n\nstruct Plane\n{\n    vec3 p;\n    vec3 n;\n};\n\n\nstruct Ray\n{\n    vec3 o;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 pos;\n    vec3 col;\n};\n\nstruct Intersection\n{\n    bool exist;\n    vec3 p;\n    vec3 n;\n    float t;\n    bool reflect;\n};\n\nIntersection RaySphere(Ray r, Sphere s)\n{\n    Intersection i;\n    i.exist = false;\n    \n    float t = MAX_T;\n    i.t = t;\n    float a = dot(r.dir, r.dir);\n    vec3 d = r.o - s.c;\n    float b = 2. * dot(d, r.dir);\n    float c = dot(d, d) - s.r * s.r;\n    \n    float delta = b * b - 4. * a * c;\n    \n    if (delta < 0.)\n        return i;\n       \n    t = (-b + sqrt(delta)) / 2. * a;\n    t = min(t, (-b - sqrt(delta)) / 2. * a);\n    \n    \n    \n    if (t < 0.)\n        return i;\n        \n    vec3 p = r.o + t * r.dir;\n    vec3 n = 2. * vec3(p.x - s.c.x, p.y - s.c.y, p.z - s.c.z);\n    i.exist = true;\n    i.p = p;\n    i.t = t;\n    i.n = normalize(n);\n    i.reflect = true;\n    return i;\n}\n\nIntersection RayPlane(Ray r, Plane pl)\n{\n    Intersection i;\n    i.exist = false;\n    \n    float t = MAX_T;\n    i.t = t;\n    t = dot(pl.p - r.o, pl.n) / dot(r.dir, pl.n);\n    if (t < 0.)\n        return i;\n    \n    vec3 p = r.o + t * r.dir;\n    i.exist = true;\n    i.p = p;\n    i.t = t;\n    i.n = pl.n;\n    i.reflect = false;\n    return i;\n}\n\nIntersection CloseIntersection(Intersection a, Intersection b)\n{\n    if(a.t > b.t)\n        return b;\n    else\n        return a;\n}\n\nIntersection RayTracing(Ray r)\n{\n    Intersection i;\n    i.exist = false;\n    \n    Plane pl;\n    pl.p = vec3(0, 0, 0);\n    pl.n = normalize(vec3(0, 1, 0));\n    \n    Sphere sp;\n    sp.c = vec3(0, 1, 4);\n    sp.r = 1.;\n    \n    Sphere sp1;\n    sp1.c = vec3(2, 1, 5);\n    sp1.r = 1.;\n    \n    Sphere sp2;\n    sp2.c = vec3(-2, 0.8, 4.5);\n    sp2.r = 0.8;\n    \n    Intersection iplane = RayPlane(r, pl);\n    Intersection isphere = RaySphere(r, sp);\n    Intersection isphere1 = RaySphere(r, sp1);\n    Intersection isphere2 = RaySphere(r, sp2);\n    \n    i = CloseIntersection(iplane, isphere);\n    i = CloseIntersection(isphere1, i);\n    i = CloseIntersection(isphere2, i);\n    \n    return i;\n}\n\nRay Reflect(Ray r, vec3 p, vec3 n)\n{\n    Ray ref;\n    ref.o = p;\n    vec3 ld = p - r.o;\n    ref.dir = reflect(ld, n);\n    \n    \n    return ref;\n}\n\nvec3 Getlight(Ray r, Light l)\n{\n    vec3 col = vec3(0, 0, 0);\n    \n    \n    for(int i = 0; i < BOUND_N; ++i)\n    {\n        Intersection p = RayTracing(r);\n        if (p.exist == true)\n        {\n\n            vec3 ld = normalize(l.pos - p.p);\n            float dif = clamp(dot(ld, p.n), 0., 1.);\n            col += dif * l.col;\n        }\n        else\n        {\n            col += vec3(0, 0, 0);\n            break;\n        }\n        if (p.reflect == false)\n            break;\n        r = Reflect(r, p.p, p.n);\n        l.col *= 0.7;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 col = vec3(0.0);\n    \n    Ray r;\n    r.o = vec3(0, 1, 0);\n    r.dir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    Light l;\n    l.pos = vec3(0, 6, 0);\n    l.pos.xz += vec2(sin(iTime), cos(iTime) * 2.);\n    l.col = vec3(1, 1, 1);\n    \n    col = Getlight(r, l);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}