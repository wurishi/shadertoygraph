{"ver":"0.1","info":{"id":"4tXXW7","date":"1436978707","viewed":334,"name":"Epitrochoidal taps","username":"nmz","description":"Red lines = tile boundaries\nMagenta lines = pattern repeats/complete cycle (also tile boundary)","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["procedural","texture","technique"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//Epitrochoidal taps by nmz (twitter: @stormoid)\n\n#define time iTime\n\n/*\n\tUsing Epitrochoidal taps to allow for non-repeating, tileable\n\tnoise, works in any dimensions, but each repeating axis needs\n\t2 dimensions of noise.\n\n\tExamples: \n\t\t-2d noise with 1 repeating dimension = 3d noise needed\n\t\t-2d noise with 2 repeating dimensions= 4d noise needed\n\t\t-3d noise with 1 repeating dimension = 4d noise needed\n\t\t-3d noise with 3 repeating dimensions= 6d noise needed\n\t\tetc..\n\n\tHere's a link to a plot of the epitrochoidal curve being used to tap the higher\n\tdimensional textures (hopefully that helps understand what i'm doing):\n\thttp://www.wolframalpha.com/input/?i=parametric+plot+cos(t)-cos(t*4)%2csin(t)-sin(t*4)\n\n\n\tN.B. The tiles produced are only interchangeable on one axis, this\n\tmeans you can't just get a random array of those tiles and splat them\n\taround in multiple dimensions, they need kept in the base order.\n*/\n\n//Number of zero passes per full cycles (number of different tiles)\nconst int passes = 5;\nconst float zoom = 7.;\n\nconst float c= float(passes);\n\n//From tekF: https://www.shadertoy.com/view/ltXGWS\nfloat cells(in vec4 p){\n    p = fract(p/2.0)*2.0;   \n    p = min( p, 2.0-p );\n    return min(length(p),length(p-1.0));\n}\nfloat noise4d(in vec4 p)\n{\n    p*= 2.4;\n    p.x += sin(p.z+p.y+p.w+time);\n    return pow(cells(p),2.)-.6;\n}\n\nfloat gf = 0.;\nfloat gf2 = 0.;\n\n//Using n+2 dimensional noise to create seamless repetition on two axes\nfloat tap4d(in vec2 p)\n{ \n    float x = cos(p.x)-cos(p.x*c);\n    float y = sin(p.x)-sin(p.x*c);\n    \n    float xx = cos(p.y)-cos(p.y*c);\n    float yy = sin(p.y)-sin(p.y*c);\n    \n    vec4 z = vec4(x, xx, y, yy);\n    z *= .33;\n    \n    //for the \"debug\" lines\n    if (cos(p.x) > 0.99995 || cos(p.y) > 0.99995)gf2= 1.;\n    if (length(vec2(x,y))< 0.00185*c*zoom || length(vec2(xx,yy))< 0.00185*c*zoom)gf=1.;\n    \n    return noise4d(z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    p.x += time*0.1;\n    p.y -= 0.05;\n    \n    p *= zoom;\n    vec3 col = vec3(tap4d(p));\n    \n    if (gf == 1.)col.r += 1.;\n    if (gf2 == 1.)col.b += 1.;\n    \n\tfragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}