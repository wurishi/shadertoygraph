{"ver":"0.1","info":{"id":"dsd3Df","date":"1677982033","viewed":395,"name":"Faster ray-marching","username":"ianertson","description":"Faster ray-marching by... throwing less rays :D\n(by using a smaller resolution)","likes":7,"published":1,"flags":48,"usePreview":1,"tags":["raymarching","raymarch","performance","perf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = fc/(R.xy*RES_SCALE);\n    col = texture(iChannel0, uv).rgb;\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime+6.845)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, OB, id_) if (id_ != skip && var < dist) { id = id_; o = OB, dist = var; }\n#define AMBIENT 0.04\n#define RES_SCALE 4.\n\nfloat luma(in vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Object { vec3 p; vec3 r; };\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\nstruct Material { float rough; float spec; float metallic; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0)\nstruct Data { vec3 ro; vec3 rd; vec3 p; vec3 n; float d; int id; int skip; Material m; Object o; };\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), FAR, 0, 0, NEW_MATERIAL, NEW_OBJECT)\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\nvec3 getLightDir(in Light light, in vec3 p) { return light.type == LIGHT_AMBIENT ? normalize(light.p) : light.type == LIGHT_POINT ? normalize(light.p - p) : normalize(light.d);}\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (pow(light.s, 2.0) / max(0.0001, pow(distance(\n            light.p, p), 2.0))); break;\n        case LIGHT_DIR: return light.c * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    return vec3(0.0);\n}\nvec2 boxUv(in vec3 p, in vec3 n) { return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0)))); }\n\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            speed *= 1.; //+ 2. * texture(iChannel0,vec2(KEY_SHIFT,0.)).r;\n\n            speed *= 3.0;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 64\n\n#define ID_NONE 0\n#define ID_GROUND 1\n\n#define FREE_MOVE 0\n\nfloat rand(in vec2 p, in float seed) {\n    vec2 p2 = fract(p*10.9281821391)*2.2938185-0.928821231;\n    float r1 = fract(dot(p, p2));\n    return fract(cos((r1+seed)*6.22828281823) * dot(p-(p2*seed), vec2(16.2939281, 19.982717145)));\n}\n\nvec3 noise(in vec2 p, in float seed) {\n    return textureLod(iChannel3, (p+((seed*2.0-1.0)*1.9981898593))/256., 0.0).xyz;\n}\n\nvec3 snoise(in vec2 p, in float seed) {\n    p += 0.092818723;\n    vec2 id = floor(p); vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(noise(id, seed), noise(id + vec2(1, 0), seed), lv.x),\n        mix(noise(id + vec2(0, 1), seed), noise(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise6(in vec2 p, in float seed, in float freq) {\n    p += 0.123456789;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 6; i++) {\n        n += amp * snoise(p*freq, seed*freq); div += amp; amp /= 2.0; freq *= 2.0;\n    }  \n    return n/div;\n}\n\nvec3 noiseLod(in vec2 p, in float seed, in float lod) {\n    return textureLod(iChannel3, (p+((seed*2.0-1.0)*1.2981898593))/256., lod).xyz;\n}\n\nvec3 snoiseLod(in vec2 p, in float seed, in float lod) {\n    p += 0.999927271;\n    vec2 id = floor(p); vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(noiseLod(id, seed, lod), noiseLod(id + vec2(1, 0), seed, lod), lv.x),\n        mix(noiseLod(id + vec2(0, 1), seed, lod), noiseLod(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise6Lod(in vec2 p, in float seed, in float freq, in float lod) {\n    p += 0.902329128459;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < 6; i++) {\n        n += amp * snoiseLod(p*freq, seed*freq, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }  \n    return n/div;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat getHeight(in vec3 p, in vec3 ro, in vec3 rd) {\n    float h = 0.0;\n    \n        float area = smoothstep(8., 64., distance(p.xz, vec2(0.)));\n    \n    //vec3 ro = data.ro;\n    //vec3 rd = data.rd;\n    \n    float lod = clamp(pow(distance(p, ro)/FAR, 10.)*10., 0.0, 10.);\n    \n    vec3 lf1 = snoise6Lod(p.xz, 3.0239124, 0.05, lod);\n    vec3 lf2 = snoise6Lod(p.zx, 15.55553299, 0.03, lod);\n    vec3 lf3 = snoise6Lod(p.xz-0.22919192, 18.82882913, 0.04, lod);\n    vec3 hf1 = snoise6Lod(p.zx+3.33321, 0.02222211293, 0.3, lod);\n    vec3 mixer = snoise6Lod(p.xz, 10.93872125, 0.1, lod);\n    \n    \n    float crust = mix(mix(hf1.x, hf1.y, mixer.x), hf1.z, mixer.y);\n    float valleys = smoothstep(0.25, 0.4, pow(mix(mix(lf3.x, lf3.y, mixer.x), lf3.z, mixer.y), 2.))*10.;\n    float planes = smoothstep(0.26, 0.3, pow(mix(mix(lf2.x, lf2.y, mixer.x), lf2.z, mixer.y), 2.))*2.;\n    float mountains = smoothstep(0.25, 0.6, pow(mix(mix(lf1.x, lf1.y, mixer.x), lf1.z, mixer.y), 2.))*30.;\n    \n    float sx = exp(sin(p.x*0.1)-1.);\n    float sz = exp(cos(p.z*0.1)-1.);\n //   mountains *= sx * sz;\n   // valleys *= sx * sz;\n   // planes *= sx * sz;\n    \n    h += mountains;\n    h += planes;\n    h -= valleys;\n    \n    h += (crust * 2.0 - 1.0)*2.;\n    \n    h *= clamp(sx+sz, 0.0, 1.0);\n    h *= area;\n    \n    return h;\n}\nfloat groundSDF(in Data data, in vec3 p) {\n    if (abs(p.y) > 39.) return p.y;\n    float h = 0.0;\n    vec3 ro = data.ro;\n    vec3 rd = data.rd;\n    float lod = clamp(pow(distance(p, ro)/FAR, 10.)*10., 0.0, 10.);\n    \n    h = getHeight(p, data.ro, data.rd);\n\n    float d = p.y - h;\n    \n    return (d/2.2) + lod*2.;\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(data, p);\n\n    SAMPLE(ground, o, ID_GROUND);\n    \n    data.id = id;\n    data.d = dist;\n    data.o = o;   \n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        float next = sdf(data, ro+rd*d); d += next;\n        if ((next) <= (NEAR * (1.0 + abs(d*2.)))) break; if (abs(d) >= FAR) return false;\n    }\n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    data.p = p;\n    data.n = n;\n    data.d = d;\n    return true;\n}\n\nfloat getShadow(in int skip, in vec3 ro, in vec3 rd, in float near, in float far) {\n    float d = 0.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    for (int i = ZERO; i < STEPS; i++) {\n        float next = sdf(data, ro+rd*d); d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break; if (abs(d) >= far) return 1.0;\n    }\n    return clamp(pow(d/(1.0+d), 2.), AMBIENT, 1.0);\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, in vec3 n, inout Material m) {\n    vec3 col = vec3(0.0);\n    //uv *= 10.;\n    \n    vec3 hf1 = snoise(uv*200., 0.28827815);\n    vec3 hf2 = snoise6(uv, 3.33387762113, 64.);\n    vec3 hf3 = snoise6Lod(uv, 10.111182838, 100.0, 2.5);\n    \n    vec3 lf1 = snoise6Lod(uv, 6.6837177739, 4., 1.5);\n    vec3 lf2 = snoise6(uv, 16.39288883989, 3.);\n    vec3 lf3 = snoise6Lod(uv*0.5, 0.002988152, 0.5, 3.);\n    \n    vec3 g1 = rgb(97, 123, 27);\n    vec3 g2 = rgb(105, 109, 72);\n    vec3 g3 = rgb(50, 55, 34);\n    vec3 g4 = rgb(110, 121, 83);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    col += grassCol;\n    \n    vec3 d1 = rgb(76, 62, 49);\n    vec3 d2 = rgb(127, 102, 82);\n    vec3 d3 = rgb(120, 101, 94);\n    vec3 d4 = rgb(156, 129, 97);\n    \n    vec3 dirtCol = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n    dirtCol = mix(dirtCol, dirtCol*dirtCol, clamp(lf2.y*2., 0.0, 1.0));\n    \n    float dirtReg = pow(lf1.x, 2.);\n    dirtReg = clamp(smoothstep(0.16, 0.6, dirtReg)*2., 0.0, 1.0);\n    dirtReg *= clamp(pow(lf2.x, 6.)*3., 0.0, 1.0);\n    vec3 no = normalize(p);\n    dirtReg += max(0.0, 1.0 - (pow(cdot(n, vec3(0, 1, 0)), 3.)*2.)) * clamp(pow(max(adot(n, vec3(1, 0, 0)), adot(n, vec3(0, 0, 1))), 2.)*4., 0.0, 1.0)*smoothstep(-2., 2.0, max(0.0, p.y));\n    \n    col = mix(col, dirtCol, dirtReg);\n    float grain = clamp(smoothstep(0.39, 1., hf3.x)*4., 0.0, 1.0);\n    \n    float wetReg = clamp(smoothstep(0.34, 1., lf3.x)*4., 0.0, 1.0)*lf1.z;\n    \n    \n    col = mix(col, col*col, grain);\n    col = mix(col, col*col, wetReg);\n    \n    m.spec = clamp(((dirtReg*dirtReg) + (wetReg*0.2*wetReg)), grain*0.2, 1.0);\n    \n    return col;\n}\n\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = p.xz;//boxUv(p, n);\n    vec3 col = grassTexture(uv, p, n, data.m);\n    return col;\n}\n\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n    }\n    return vec3(0.77);\n}\n\n\nvec3 getSky(in vec3 ro, in vec3 rd) {\n  vec3 col = vec3(0.0);\n  vec2 uv = rd.xz / rd.y;\n  vec3 blue = vec3(0.3, 0.56, 0.8);\n  \n  \n  float dotup = cdot(rd, vec3(0, 1, 0));\n\n  col = pow(blue, vec3(1.0 + (dotup * 2.)));\n    \n  if (dotup <= 0.0) return col;\n\n  float time = T * 0.2;\n\n  vec2 shift = vec2(cos(time), sin(time));\n  uv += sin(shift * 6.) * 0.01;\n\n  vec3 lf1 = snoise6(uv + shift, 0.03291895, 0.9);\n  vec3 hf1 = snoise6(uv - (shift * 0.2), 1.2321956,\n                    16.0 + mix(0.0, 1., pow(lf1.z, 2.0)));\n  vec3 mixer = snoise6(uv + sin(shift), 0.11111223, 0.9);\n\n  float mixf = mix(mixer.x, mixer.y, 0.5 + (0.5 * sin(time)));\n\n  float low = mix(lf1.x, lf1.y, 0.5 + (0.5 * cos(time)));\n  float high = mix(hf1.x, hf1.y, 0.5 + (0.5 * sin(time)));\n\n  vec3 lfi = snoise6(uv + shift, 0.53928111, 1.0);\n  float inv = pow(mix(lfi.x, lfi.y, 0.5 + (0.5 * cos(time))), 2.0);\n\n  float clouds = mix(low, high, mixf);\n\n  clouds = mix(clouds, 0.0, inv);\n  clouds = pow(clouds, 3.0);\n  \n  clouds *= clamp(dotup*40., 0.0, 1.0);\n\n  col = mix(col + clouds, mix(col, vec3(1.0), clouds),\n            0.5 + (0.5 * cos(time + low + high + inv)));\n\n  return col;\n}\n\nvec3 lightEffect(in vec3 ro, in vec3 rd, in Light light) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 L = getLightDir(light, ro);\n    float VdotL = cdot(rd, L);\n    \n    col += light.c * light.s * pow(VdotL, 16.);\n    \n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 diffuse, in vec3 ro, in vec3 rd) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.);\n    vec3 att = getLightAtt(light, p, n);\n    int skip = data.id;\n    float shadow = getShadow(skip, p+(n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR : distance(light.p, p));\n    \n    return (diffuse + spec) * att * shadow;\n}\n\n#define NUM_LIGHTS 1\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    data.ro = ro;\n    data.rd = rd;\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.97, 0.59), 2.0, LIGHT_AMBIENT);\n    \n    bool hit = false;\n    \n    vec3 primRo = ro;\n    vec3 primRd = rd;\n    float primDist = FAR;\n    \n    if (march(data, ro, rd)) {\n        hit = true;\n        primDist = data.d;\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        \n        for (int i = 0; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, diffuse, ro, rd);\n        }\n    }  else {\n        col += getSky(ro, rd);\n    }\n   \n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -8.);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if FREE_MOVE\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    ro += walk;\n    ro.y += fly.y;\n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    #else\n    rd.xz *= rot(radians(mix(-10., 10., 0.5+(0.5*cos(T)))));\n    ro.z += T*10.;\n    float h = getHeight(ro, ro, rd);\n    ro.y += h;\n    #endif\n    \n    ro.y += 10.;\n   // ro.y = max(0.5, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec2 res = R.xy/RES_SCALE;\n    if (fc.x > res.x || fc.y > res.y) {\n        O = vec4(0.);\n        return;\n    }\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*res.xy)/res.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    depth = 0.;\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col += (col*col*luma(col));\n    col /= 1.0 + max(col-0.5, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(clamp(col, 0.0, 1.0), depth);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}