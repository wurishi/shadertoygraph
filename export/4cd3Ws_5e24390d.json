{"ver":"0.1","info":{"id":"4cd3Ws","date":"1712261006","viewed":29,"name":"We slidin' in pink","username":"PiouPiou","description":"This is a bubble of some sort sliding on a noisy floor. The camera is usable!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","noise","waves","shadow","water","metal","floor","mercury"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"We slidin'\" by Obama. https://shadertoy.com/view/lctGDf\n// 2024-04-04 20:03:05\n\n//GLOBAL CONSTANTS--------------------//\nconst float PI = 3.14159;\nconst float MOVEMENT_SPEED = -10.;\nconst float TIME_DAMPENING = -800.0;\n\n//NOISES METHODS----------------------//\n\n#define S(a, b, t) smoothstep(a, b, t)\n\nvec3 rotate(vec3 p, vec3 axis, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return vec3(p.x * (axis.x * axis.x * oc + c) +\n        p.y * (axis.x * axis.y * oc - axis.z * s) +\n        p.z * (axis.x * axis.z * oc + axis.y * s), p.x * (axis.y * axis.x * oc + axis.z * s) +\n        p.y * (axis.y * axis.y * oc + c) +\n        p.z * (axis.y * axis.z * oc - axis.x * s), p.x * (axis.z * axis.x * oc - axis.y * s) +\n        p.y * (axis.z * axis.y * oc + axis.x * s) +\n        p.z * (axis.z * axis.z * oc + c));\n}\n\nfloat hash(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat coefA(vec2 ij)\n{\n    float u = 50. * fract(ij.x / PI);\n    float v = 50. * fract(ij.y / PI);\n    return hash(vec2(u, v));\n}\n\nfloat coefB(vec2 ij) \n{ \n    return coefA(ij + vec2(1., 0.)); \n}\n\nfloat coefC(vec2 ij) \n{ \n    return coefA(ij + vec2(0., 1.)); \n}\n\nfloat coefD(vec2 ij) \n{ \n    return coefA(ij + vec2(1., 1.)); \n}\n\nfloat AUGH(float lambda) \n{ \n\treturn 3. * pow(lambda, 2.) - 2. * pow(lambda, 3.); \n}\n\nfloat snoise(vec3 pos)\n{\n    vec2 xz = pos.xz;\n    vec2 ij = vec2(floor(xz.x), floor(xz.y));\n    float i = ij.x;\n    float j = ij.y;\n    float x = xz.x;\n    float z = xz.y;\n    float a = coefA(ij);\n    float b = coefB(ij);\n    float c = coefC(ij);\n    float d = coefD(ij);\n    return a +\n           (b - a) * AUGH(x - i) +\n           (c - a) * AUGH(z - j) +\n           (a - b - c + d) * AUGH(x - i) * AUGH(z - j);\n}\n\n//SHAPES METHODS----------------------//\n\n//This is a Minkowski distance method\nfloat len(vec3 point, float order) \n{\n    //Len settings\n    const float LEN_RATIO = 1.0;\n\n\tpoint = pow(abs(point), vec3(order));\n\treturn pow(point.x + point.y + point.z, LEN_RATIO/order);\n}\n\n//This is used to create the sphere\nfloat Sphere(vec3 position, float radius) \n{\n    //Sphere settings\n    const float SPHERE_SHAPE = 2.0; //1.0 = Triangle, 2.0 = Sphere, 100.0 = Rectangle\n\n\treturn len(position, SPHERE_SHAPE) - radius;\n}\n\n//MAP CREATION-------------------------//\n\nfloat map(vec3 position) \n{\n    //Map settings\n    const float MAP_FLOOR_NOISE_FREQUENCY = 0.4;\n    const float MAP_FLOOR_NOISE_AMPLITUDE = 2.;\n    const float MAP_SPHERE_HEIGHT = 2.0;\n    const float MAP_SPHERE_RADIUS = 2.0;\n\n    //Variables\n    float movement_offset = (iTime+TIME_DAMPENING)*MOVEMENT_SPEED; //Be careful, movement offset is (in this case) already negative\n\n    //Creation of the floor\n\tfloat floor = position.y - (snoise(position * MAP_FLOOR_NOISE_FREQUENCY) * MAP_FLOOR_NOISE_AMPLITUDE);\n\n    //Creation of the sphere (using the floor)\n    vec3 spherePosition = position - vec3(movement_offset, MAP_SPHERE_HEIGHT, 0.0) + vec3(0.0, floor, 0.0);\n\tfloat sphereDistance = Sphere(spherePosition, MAP_SPHERE_RADIUS);\n\n    //Union of the floor and the sphere\n    return min(sphereDistance, floor);\n}\n\n//RAY TRACING METHODS-------------------//\n\nfloat rayMarch(vec3 ro, vec3 rd, float m) \n{\n    //RayMarch settings\n    const float RAYMARCH_MINIMUM_DISTANCE = 0.001;\n    const float RAYMARCH_DISTANCE_MULTIPLIER = 0.0001;\n    const int RAYMARCH_MAX_ITERATIONS = 200;\n    const float RAYMARCH_RATIO = 0.67;\n\n    //Variables\n\tfloat tracing = 0.0;\n    int i;\n\n\tfor(i = 0; i < RAYMARCH_MAX_ITERATIONS; i++) \n    {\n\t\tfloat d = map(ro + rd*tracing);\n\t\tif(d < (RAYMARCH_MINIMUM_DISTANCE + RAYMARCH_DISTANCE_MULTIPLIER*tracing) || tracing >= m) break;\n\t\ttracing += d*RAYMARCH_RATIO;\n\t}\n\n\treturn tracing;\n}\n\nvec3 normal(vec3 position) \n{\n    //Global settings\n    const vec2 NORMAL_OFFSET = vec2(0.01, 0.0);\n\n\tvec3 n = vec3(\n\t\tmap(position + NORMAL_OFFSET.xyy) - map(position - NORMAL_OFFSET.xyy),\n\t\tmap(position + NORMAL_OFFSET.yxy) - map(position - NORMAL_OFFSET.yxy),\n\t\tmap(position + NORMAL_OFFSET.yyx) - map(position - NORMAL_OFFSET.yyx)\n\t);\n\n\treturn normalize(n);\n}\n\nfloat ambientOcclusion(vec3 position, vec3 normal) \n{\n    //AmbientOcclusion settings\n    const int AMBIENT_OCCLUSION_ITERATIONS = 15;\n    const float AMBIENT_OCCLUSION_DAMPING_FACTOR = 0.98;\n    const float AMBIENT_OCCLUSION_MIN_VALUE = 0.0;\n    const float AMBIENT_OCCLUSION_MAX_VALUE = 1.0;\n    const float AMBIENT_OCCLUSION_BASE_VALUE = 1.0;\n\n    //Variables\n\tfloat occlusionAmmount = .5;\n    float stepSize = 0.005;\n    float weight = 1.0;\n    float distance;\n    int i;\n\t\n\tfor(i = 0; i < AMBIENT_OCCLUSION_ITERATIONS; i++) {\n\t\tdistance = map(position + normal*stepSize);\n\t\tocclusionAmmount += (stepSize - distance)*weight;\n\t\tweight *= AMBIENT_OCCLUSION_DAMPING_FACTOR;\n\t\tstepSize += stepSize/float(i + 1);\n\t}\n\t\n\treturn AMBIENT_OCCLUSION_BASE_VALUE - clamp(occlusionAmmount, AMBIENT_OCCLUSION_MIN_VALUE, AMBIENT_OCCLUSION_MAX_VALUE);\n}\n\n//CAMERA METHODS-----------------------//\nmat3 createCameraMatrix(vec3 origin, vec3 lookAtPoint) \n{\n    //CreateCameraMatrix settings\n    const vec3 CAMERA_MATRIX_UP_DIRECTION_VECTOR = vec3(0, 1, 0);\n\n    //Variables\n    vec3 forwardDirection;\n    vec3 rightDirection;\n    vec3 upDirection;\n\n\tforwardDirection = normalize(lookAtPoint - origin);\n\trightDirection = normalize(cross(CAMERA_MATRIX_UP_DIRECTION_VECTOR, forwardDirection));\n\tupDirection = normalize(cross(forwardDirection, rightDirection));\n\t\n\treturn mat3(rightDirection, upDirection, forwardDirection);\n}\n\n//This method was created by the teacher in the example he created in lecture 2, I left it untouched\nvec3 localRay;\nvoid CamPolar(out vec3 pos, out vec3 ray, in vec3 origin, in vec2 rotation, in float distance, in float zoom, in vec2 fragCoord) \n{\n    vec2 c = vec2(cos(rotation.x), cos(rotation.y));\n    vec4 s;\n    s.xy = vec2(sin(rotation.x), sin(rotation.y));\n    s.zw = -s.xy;\n\n    ray.xy = fragCoord.xy - iResolution.xy * .5;\n    ray.z = iResolution.y * zoom;\n    ray = normalize(ray);\n    localRay = ray;\n\n    ray.yz = ray.yz * c.xx + ray.zy * s.zx;\n    ray.xz = ray.xz * c.yy + ray.zx * s.yw;\n\n    pos = origin - distance * vec3(c.x * s.y, s.z, c.x * c.y);\n}\n\n//MAIN--------------------------------//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\t\n\tvec3 ro = vec3(4.5, 2.5, 0);\n\tvec3 rd = createCameraMatrix(ro, vec3(0., 0., 0.))*normalize(vec3(p, 1.97));\n\t\n    vec2 camRot = vec2(0.5, 0.) + vec2(-.35, 4.5) * (iMouse.yx / iResolution.yx);\n    CamPolar(ro, rd, vec3(0., 1.5, 0), camRot, 10., 1.0, fragCoord);\n\n    //This line is used to make the camera moves at the same speed and same rate as the sphere does.\n    //This whole movement thing could probably be made much more efficiently (or easier at least) if the floor was moving instead.\n    float movement_offset = (iTime+TIME_DAMPENING)*MOVEMENT_SPEED;\n\tro = vec3(ro.x + movement_offset,ro.y, ro.z);\n\n\tvec3 col = mix(vec3(0.016,0.004,0.698), vec3(0.988,0.012,0.729),p.y/4.) ;\n    vec3 l = vec3(hash(vec2(iTime)), hash(vec2(iTime)), hash(vec2(iTime)));\n\tvec3 lig = normalize(l);\n    lig = rotate(lig, vec3(p/2., 1.), 1. * iTime);\n\t\n\tfor(int i = 0; i < 3; i++) {\n\t\tfloat t = rayMarch(ro, rd, 50.0);\n\t\tif(t < 50.0) {\n\t\t\tvec3 rcol = vec3(0);\n\t\t\t\n\t\t\tvec3 pos = ro + rd*t;\n\t\t\tvec3 nor = normal(pos);\n\t\t\tvec3 ref = reflect(rd, nor);\n            vec3 refra = refract(rd, nor, 1.0 / 1.5);\n\t\t\t\n            //Shadows\n\t\t\tfloat occ = ambientOcclusion(pos, nor);\n\t\t\tfloat sha = step(5.0, rayMarch(pos + nor*0.001, lig, 5.0));\n\t\t\t\n            //Lighting\n\t\t\trcol += 0.2*occ;\n\t\t\trcol += clamp(dot(lig, nor), 0.0, 1.0)*occ*sha;\n\t\t\trcol += pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0)*occ;\n\t\t\trcol += 50.0*pow(clamp(dot(ref, lig), 0.0, 1.0), 30.0)*occ;\n\t\t\trcol += 100.0*pow(clamp(dot(refra, lig), 0.0, 1.0), 30.0)*occ;\n\t\t\t\n            //Texture and colors\n\t\t\tif(pos.y > -0.99)\n\t\t\t\trcol *= vec3(0.988,0.012,0.729);\n\t\t\telse\n\t\t\t\trcol *= 0.3 + 0.7*mod(floor(pos.x) + floor(pos.z), 2.0); //I am not using this, it was for the first version\n\t\t\t\n            //Ro & rd initialization\n\t\t\tro = pos + nor*0.001;\n\t\t\trd = ref;\n\t\t\t\n            //Fog\n\t\t\trcol = mix(rcol, vec3(0.000,0.067,1.000), 1.0 - exp(-0.1*t));\n\t\t\t\n            //This is important to limit the reflections on each iteration\n\t\t\tif(i == 0) col = rcol;            \n\t\t\telse col *= mix(rcol, vec3(1), 1.0 - exp(-0.8*float(i)));\n\t\t}\n\t}\n\t\n    //Gamma correction\n\tcol = 1.0 - exp(-0.5*col);\n\tcol = pow(abs(col), vec3(1.0/2.2));\n\t\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}