{"ver":"0.1","info":{"id":"MXSSWR","date":"1710867434","viewed":216,"name":"Card Holofoil","username":"roar","description":"PBR card holofoil.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 spinning_camera(float t)\n{\n    return vec4(2.0 * sin(t), -0.5, -2.0 * cos(t), 1.5);\n}\n\nvec4 fixed_camera()\n{\n    return vec4(0.0, -13.0 / 3.5, -17.5 / 3.5, 4.0);\n}\n\n\nvec4 mouse_camera()\n{\n    vec2 m = vec2(0.5);\n    if (iMouse.z > 0.0)\n    {\n        m = iMouse.xy / iResolution.xy;\n    }\n    \n\tfloat ax = -m.x * 3.14 * 2.0  + 3.14 / 2.0;\n\tfloat ay = -m.y * 3.14;\n    return vec4(2.0 * cos(ax), 2.0 * cos(ay), 2.0 * sin(ax), 1.5);\n}\n\nvec4 camera()\n{\n    //return fixed_camera();\n    return mouse_camera();\n}\n\nvec3 fixed_light()\n{\n    return vec3(0.0, 0.0, -64.5 / 3.5);\n}\n\nvec3 spinning_light(float t)\n{\n    return vec3(64.5 / 3.5 * sin(t), 1.0, -64.5 / 3.5 * cos(t));\n}\n\nvec3 spinning_light_2(float t)\n{\n    return vec3(10.5 * sin(t), -10.5 * cos(t), -10.5);\n}\n\nvec3 light()\n{\n    //return spinning_light(iTime);\n    return spinning_light_2(iTime / 2.0);\n    return fixed_light();\n}\n\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n    vec2 q = vec2(dot(p,vec2(127.1,311.7)),\n                  dot(p,vec2(269.5,183.3)) );\n\treturn fract(vec2(sin(q)*43758.5453));\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nvec4 hash4( vec2 p )\n{\n    vec4 q = vec4( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)), \n\t\t\t\t   dot(p,vec2(832.3,201.5)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n//https://iquilezles.org/articles/voronoise\nfloat voronoise( in vec2 p, float u, float v )\n{\n\tfloat k = 1.0+63.0*pow(1.0-v,6.0);\n\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n\tvec2 a = vec2(0.0,0.0);\n    for( int y=-2; y<=2; y++ )\n    for( int x=-2; x<=2; x++ )\n    {\n        vec2  g = vec2( x, y );\n\t\tvec3  o = hash3( i + g )*vec3(u,u,1.0);\n\t\tvec2  d = g - f + o.xy;\n\t\tfloat w = pow( 1.0-smoothstep(0.0,1.414,length(d)), k );\n\t\ta += vec2(o.z*w,w);\n    }\n\t\n    return max(a.x/a.y, 0.0);\n}\n\n//https://iquilezles.org/articles/voronoilines/\nvec2 voronoi(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    vec2 mz = vec2(0.0);\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec4 o = hash4(ip + g);//*vec3(u,u,1.0);\n        vec2 r = g + vec2(o) - fp;\n        float d = dot(r,r);\n\n        if(d < md)\n        {\n            md = d;\n            mr = r;\n            mg = g;\n            mz = o.zw;\n        }\n    }\n\n    return mz;\n}\n\n\n//https://stackoverflow.com/questions/3407942/rgb-values-of-visible-spectrum\nvec3 spectral_spektre(float l)\n{\n    l = 400.0 + l * 300.0;\n    float r=0.0,g=0.0,b=0.0;\n         if ((l>=400.0)&&(l<410.0)) { float t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n    else if ((l>=410.0)&&(l<475.0)) { float t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n    else if ((l>=545.0)&&(l<595.0)) { float t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n    else if ((l>=595.0)&&(l<650.0)) { float t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n    else if ((l>=650.0)&&(l<700.0)) { float t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n         if ((l>=415.0)&&(l<475.0)) { float t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n    else if ((l>=475.0)&&(l<590.0)) { float t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n    else if ((l>=585.0)&&(l<639.0)) { float t=(l-585.0)/(639.0-585.0); g=0.82-(0.80*t)           ; }\n         if ((l>=400.0)&&(l<475.0)) { float t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n    else if ((l>=475.0)&&(l<560.0)) { float t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n    return vec3(r,g,b);\n}\n\n//https://www.alanzucconi.com/2017/07/15/improving-the-rainbow/\nvec3 spectral_gems(float w)\n{\n    return vec3\n    (       \n        max(1.0 - pow(4.0 * (w - 0.75), 2.0), 0.0),\n        max(1.0 - pow(4.0 * (w - 0.5), 2.0), 0.0),\n        max(1.0 - pow(4.0 * (w - 0.25), 2.0), 0.0)\n    );\n}\n\nvec3 voronoi_normal(vec2 uv, vec3 normal, vec3 forward)\n{\n    //float noise = voronoise(uv * 20.0, 0.0, 0.0);\n    vec2 noise = voronoi(uv * 20.0);\n    //vec2 white_noise = hash2(uv);\n    //vec2 noise = white_noise * 1.0;//voronoi_noise * 0.995 + white_noise * 0.005;\n    //noise.x = voronoise(uv * 120.0 * vec2(4.0, 1.0), 0.0, 1.0);\n    //noise.y = voronoise(uv * 120.0 * vec2(4.0, 1.0), 0.0, 1.0);\n    \n    float theta = noise.x * 2.0 * 3.14;\n    float phi = acos(1.0 - noise.y * 0.00125);\n\n    vec3 k = cross(normal, normalize(forward));\n    vec3 v = normal;\n\n    vec3 a = normal * cos(phi) + cross(k, v) * sin(phi) + k * dot(k, v) * (1.0 - cos(phi));\n    vec3 b = dot(a, normal)*normal;\n    vec3 o = a - b;\n    vec3 w = cross(normal, o);\n    vec3 th = length(o)*(cos(theta)*normalize(o)+sin(theta)*normalize(w));\n    return b + th;\n}\n\nvec3 bump_normal(vec2 uv, vec3 normal, vec3 forward)\n{\n    float delta = 0.001;\n    float delta_h = 0.00003;\n    vec2 noise = hash2(uv);\n    float p = voronoise(uv * 120.0 * vec2(4.0, 1.0), 0.0, 1.0) * delta_h;\n    float x = voronoise((uv + vec2(delta, 0.0)) * 120.0 * vec2(4.0, 1.0), 0.0, 1.0) * delta_h;\n    float y = voronoise((uv + vec2(0.0, delta)) * 120.0 * vec2(4.0, 1.0), 0.0, 1.0) * delta_h;\n    \n    return normalize(cross(vec3(delta, 0.0, x - p), vec3(0.0, delta, y - p)));\n}\n\nfloat draw_point(vec3 ro, vec3 rd, vec3 p)\n{\n    float d = length(cross(p - ro, rd)) / length(rd);\n    d = smoothstep(.03, .01, d);\n    return d;\n}\n\n\nvec4 plane_from_basis(vec3 v0, vec3 v1, vec3 v2)\n{\n    vec3 vc = cross(v2 - v0, v1 - v0);\n    return vec4(vc, -dot(vc, v0));\n}\n\nvec4 ray_plane_intersect(vec3 ro, vec3 rd, vec4 plane)\n{\n    float v = dot(vec3(plane), rd);\n    float o = dot(vec3(plane), ro);\n    float od = -plane.w - o;\n    float d = od / v;\n    return vec4(ro + d * rd, d);\n}\n\nvoid draw_card(\n       out vec3 position, out vec3 normal, out vec3 uv, out vec3 holo_normal, out vec3 color,\n       vec3 ro, vec3 rd, vec3 p, vec3 w, vec3 h, float r)\n{\n    vec3 d0 = normalize(w);\n    vec3 d1 = normalize(h);\n    \n    vec4 plane = plane_from_basis(p, w, h);\n    vec4 plane_intersect = ray_plane_intersect(ro, rd, plane);\n    \n    float u = dot(vec3(plane_intersect) - p, d0);\n    u = clamp(u, 0.0, length(w));\n    float v = dot(vec3(plane_intersect) - p, d1);\n    v = clamp(v, 0.0, length(h));\n    \n    vec3 projection = p + u * d0 + v * d1;\n    color = vec3(smoothstep(r + 0.005, r, length(projection - vec3(plane_intersect))));\n    \n    uv = vec3(plane_intersect) - p - w / 2.0 - h / 2.0;\n    position = vec3(plane_intersect);\n    normal = bump_normal(vec2(uv), cross(d0, d1), d0);\n    holo_normal = voronoi_normal(vec2(uv), cross(d0, d1), d0);\n}\n\nvec3 light(\n    vec3 light_pos,\n    vec3 light_color,\n    vec3 object_color,\n    vec3 object_position,\n    vec3 object_normal,\n    vec3 object_width,\n    vec3 object_height,\n    vec3 object_uv,\n    vec3 holo_normal,\n    vec3 ro,\n    vec3 rd)\n{\n    float ambient_c = 0.0;\n    vec3 ambient = ambient_c * light_color;\n    \n    float diffuse_c = 0.1;\n    vec3 light_dir = normalize(light_pos - object_position);\n    float diff = max(dot(object_normal, light_dir), 0.0);\n    vec3 diffuse = diffuse_c * diff * light_color;\n    \n    float specular_c = 1.0;\n    vec3 reflect_dir = reflect(-light_dir, object_normal);\n    float spec = pow(clamp(dot(-normalize(rd), reflect_dir), 0.0, 1.0), 512.0);\n    vec3 specular = specular_c * spec * light_color;\n\n    vec3 n1 = holo_normal * 0.8;\n    vec3 n2 = object_normal * 0.2;\n    vec3 n = normalize(vec3((n1.x + n2.x) * 2.0, (n1.y + n2.y) * 2.0, holo_normal.z * 1.0));\n    \n    float a = dot(n, ro);\n    float b = dot(n, light_pos);\n    float t = a / (a + b);\n    vec3 s = (1.0 - t) * (ro - n * a) + t * (light_pos - n * b);\n    vec3 disp = object_position - s;\n    \n    float angle = atan(disp.y, disp.x);\n    \n    float spectrum = pow(max(dot(-normalize(rd), reflect(-light_dir, n)), 0.0), 2.0);\n    float corner = (1.0 + cos(4.0 * angle + 3.14)) / 2.0;\n    spectrum = (spectrum + corner * 0.42) * (1.0 - corner * 0.29);\n    \n    float holo_a = 0.55;\n    float holo_b = 0.20;\n    float holo_c = 0.2;\n    float holo_d = 0.825;\n    vec3 holo = spectral_gems(1.0 - (spectrum - holo_a) / holo_b) * smoothstep(0.0, holo_c, cos(8.0 * angle) - holo_d) * light_color;\n    //return vec3(holo_normal.x, holo_normal.y, 0) * object_color;\n    return (ambient + diffuse + specular + holo) * object_color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float card_height = 1.0;\n    float card_width = 0.66;\n    float corner_radius = 0.04;\n    \n    vec4 cam = camera();\n    \n    vec3 ro = vec3(cam);\n    vec3 lookat = vec3(0.);\n    float zoom = cam.w;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 f = normalize(lookat - ro);\n    vec3 r = cross(vec3(0.0, 1.0, 0.0), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f * zoom;\n    vec3 i = c + uv.x * r + uv.y * u;\n    \n    vec3 rd = i - ro;\n\n    vec3 p = vec3(0.0 + card_width / 2.0, 0.0 - card_height / 2.0, 0.0);\n    vec3 d0 = vec3(-card_width,0.,0.);\n    vec3 d1 = vec3(0.0,card_height,0.0);\n\n    vec3 position;\n    vec3 normal;\n    vec3 card_uv;\n    vec3 holo_normal;\n    vec3 color;\n    draw_card(position, normal, card_uv, holo_normal, color, ro, rd, p, d0, d1, corner_radius);\n    \n    \n    vec3 light_pos = light();\n    vec3 light_color = vec3(255.0 / 255.0, 244.0 / 255.0, 229.0 / 255.0);\n    \n    vec3 out_color = vec3(0.0);\n    out_color += light(spinning_light_2(iTime / 2.0), light_color, color, position, normal, d0, d1, card_uv, holo_normal, ro, rd);\n    out_color += light(spinning_light_2(iTime / 2.1 + 3.14), light_color, color, position, normal, d0, d1, card_uv, holo_normal, ro, rd);\n    out_color += color * light_color * 0.1;\n    //color += vec3(draw_point(ro, rd, light()));\n\n    fragColor = vec4(out_color, 0.0);\n}","name":"Image","description":"","type":"image"}]}