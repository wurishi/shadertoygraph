{"ver":"0.1","info":{"id":"XfjBRD","date":"1724719292","viewed":16,"name":"Rubik's","username":"Elsio","description":"Olha só esse jeito de rotacionar as layers! se eu fosse fazer do zero sem ver o código do colega @shadertoyjiang eu rotarionaria peça por peça (ou conjunto de peças). Mas esse código está literalmente fatiando o SDF. Eu amei conhecer essa técnica!","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cube","magic","rubiks","cubo"],"hasliked":0,"parentid":"XfXXRH","parentname":"魔方Rubik's 2"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define h11(k) fract(sin(k * 12345.) * 4567.)\n#define rot(a) mat2(cos(a + vec4(0, 3.5 * pi, 10.5 * pi, 0)))\n#define normal(p) normalize(vec3(map(p + e.yxx), map(p + e), map(p + e.xxy)) - s)\n#define pi acos(-1.)\n#define T iTime\n\nvec4 col;\n\nvoid rot3D(out vec3 p, vec3 n, float z) {\n    p.xy *= rot(n.z * z);\n    p.zx *= rot(n.y * z);\n    p.yz *= rot(n.x * z);\n}\n\nvec3 rxyz(vec3 p) {\n    p.xy *= rot(T * .2);\n    p.yz *= rot(T * .3);\n    \n    float theta,\n          t = sin(T * .1) * 16. + 16.,\n          i = floor(t);\n    \n    while(i > 0.) {\n        vec3 n;\n        n [ int(h11(i) * 3.) ] = floor(.5 + h11(i)) * 2. - 1.;\n        theta = 3.14 / 2.;\n        \n        if(i == floor(t)) theta *= min(fract(t) * 2.2, 1.);\n        rot3D(p, n, theta * length(step(.5, p * n)));\n        i --;\n    }\n    return p;\n}\n\nfloat map(vec3 p) {\n    p = rxyz(p);\n    \n    vec3 m, q, k;\n    float d1, d2, d3, c;\n    \n    d1 = length(p) - 1.42;\n    m = abs(p);\n    k = floor(.5 + m - max(m - 1., 0.)) * sign(p);\n    d2 = length(max(abs(p - k) - .26, 0.)) - .2;\n    q = (1. - sign(abs(m - max(m.x, max(m.y, m.z))))) * sign(p);\n    d3 = length(max(abs(p - k - q * .18) - .29, 0.)) - .05;\n    col = vec4(q, step(d2, d3));\n    \n    return min(d1, min(d2, d3));\n}\n\n// só fico chateado de não ter encontrado uma função\n// curta que me retorne as cores certas do cubo.\nvec4 rubikCol(vec4 col){\n    // pois pras cores erradas tem:\n    // return col.w < .5? vec4(.5 - col * .5) : vec4(1.3);\n    \n    col = col.w < .5\n        ? abs(col.z) == 1.\n            ? col.z > 0.\n                ? vec4(0, 1, 0, 0)\n                : vec4(0, 0, 1, 0)\n            : abs(col.x) == 1.\n                ? col.x > 0.\n                    ? vec4(0)\n                    : vec4(1, 1, 0, 0) * 1.2\n                : abs(col.y) == 1.\n                    ? col.y > 0.\n                        ? col.yxzw\n                        : vec4(8, 4, 1, 0) / 6.\n                    : vec4(0)\n        : vec4(1.3);        \n\n    return col;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float dt, i, s, d,\n          steps = 90.;\n    \n    vec2 r = iResolution.xy;\n    u = (u - r / 2.) / r.y;\n    \n    vec3 p  = vec3(0, 0, - 8),\n         q  = vec3(- 1, 0, 0), N,\n         ld = normalize(vec3(- 1, 2, - 3)),\n         D  = normalize(vec3(u, 2)),\n         e  = vec3(0, 1e-3, 0);\n    \n    o = vec4(- u.y) * vec4(5, 6, 8, 0) / 18. + .2;\n    \n    while(i ++ < steps) {\n        p += s * D * .6;\n        s = map(p);\n        \n        if(s < .01 && i < steps) {\n            N = normal(p),\n            dt = max(0., dot(ld, N)),\n            o = (.4 - .1 * dt) * rubikCol(col) + pow(dt, 200.) * .3;\n            \n            break;\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}