{"ver":"0.1","info":{"id":"7tscRs","date":"1648726935","viewed":54,"name":"Maserati","username":"letiushev","description":"Maserati GranTurismo, bumper is polished before leaving\n\nI did implement:\n-Material properties\n-textures \n-two light sources\n-objectâ€™s movement animated \n\nI didn't manage to implement:\n-Shadows\n-Refraction","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["homework","class"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//camera rotation\nmat2 rotate2d(float theta) {  \n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) { \n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\n//primitive figures are taken from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n//primitive figures are taken from https://iquilezles.org/articles/distfunctions\n\nMaterial gold() {\n  vec3 aCol = 0.5 * vec3(0.7, 0.5, 0);\n  vec3 dCol = 0.6 * vec3(0.7, 0.7, 0);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial textured(vec3 p) {\n  vec3 aCol = 0.8 *vec3(texture(iChannel1, p.xy).rgb); //texture implementation\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial silver() {\n  vec3 aCol = vec3(0.5,0.5,0.5);\n  vec3 dCol = vec3(1);\n  vec3 sCol = vec3(1);\n  float a = 50.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial blueGlass() {\n  vec3 aCol = 0.4 * vec3(0.0,0.5,0.8);\n  vec3 dCol = 0.5 * vec3(0.7);\n  vec3 sCol = 0.6 * vec3(1, 1, 1);\n  float a = 5.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\nMaterial floorM(vec3 p) {\n  vec3 aCol = vec3(1. + 0.5*mod(floor(p.x) + floor(p.z), 2.0)) * 0.3;\n  vec3 dCol = vec3(0.3);\n  vec3 sCol = vec3(0);\n  float a = 1.;\n\n  return Material(aCol, dCol, sCol, a);\n}\n\n//union operation (adding objects to the scene)\nSurface opUnion(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2;\n  return obj1;\n}\n\n// scene implementation (what we will see)\nSurface scene(vec3 p) {    \n  Surface Floor         = Surface(1,            p.y + 1., floorM(p));\n  Surface Box           = Surface(2, sdBox(     p-  vec3( 0.0,0.5 , 0.0),vec3(1.1,0.3,4.2)), gold());\n  Surface Sphere        = Surface(3, sdSphere(  p - vec3( 2.8,0.0 , 2.8), 1.), textured(p));\n  Surface Sphere2       = Surface(4, sdSphere(  p - vec3(-2.8,0.0 , 2.8), 1.), textured(p));\n  Surface BoxFrame      = Surface(5, sdBoxFrame(p-  vec3( 0.0,1.25, 1),vec3(1.3,1.25,3.2), 0.1 ), blueGlass());\n  Surface Capsule       = Surface(6, sdCapsule( p-  vec3( 0.5,0.0 , 2.8),vec3(0,0,0), vec3(1.5,0.0,0), 0.3), blueGlass());\n  Surface Capsule2      = Surface(7, sdCapsule( p-  vec3(-2. ,0.0 , 2.8),vec3(0,0,0), vec3(2.5,0.0,0), 0.3), blueGlass());\n  Surface Sphere3       = Surface(8, sdSphere(  p - vec3(-2.8,0.0 ,-1.5), 1.), textured(p));\n  Surface Sphere4       = Surface(9, sdSphere(  p - vec3( 2.8,0.0 ,-1.5), 1.), textured(p));\n  Surface Capsule3      = Surface(10,sdCapsule( p-  vec3( 0.5,0.0 ,-1.5),vec3(0,0,0), vec3(1.5,0.0,0), 0.3), blueGlass());\n  Surface Capsule4      = Surface(11,sdCapsule( p-  vec3(-2. ,0.0 ,-1.5),vec3(0,0,0), vec3(1.5,0.0,0), 0.3), blueGlass());\n  Surface Cone          = Surface(11,sdCone(    p-  vec3( 0.4*sin(iTime*3.f),1.5 ,-3.0),vec2(1.0,0.7),0.7 ), silver());\n   \n  Surface co = opUnion(Floor, Box); // closest object\n  co = opUnion(co, Sphere);\n  co = opUnion(co, Sphere2);\n  co = opUnion(co, BoxFrame);\n  co = opUnion(co, Capsule);\n  co = opUnion(co, Capsule2);\n  co = opUnion(co, Sphere3);\n  co = opUnion(co, Sphere4);\n  co = opUnion(co, Capsule3);\n  co = opUnion(co, Capsule4);\n  co = opUnion(co, Cone);\n  return co;\n}\n\n// ray marching alg https://www.shadertoy.com/view/4dSfRc\nSurface rayMarch(vec3 ro, vec3 rd) {\n  float depth = MIN_DIST;\n  Surface co;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    co = scene(p);\n    depth += co.sd;\n    if (co.sd < PRECISION || depth > MAX_DIST) break;\n  }\n  \n  co.sd = depth;\n\n  return co;\n}\n\n//returns ray direction of the direction of a point on the sphere is facing\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n      e.xyy * scene(p + e.xyy).sd +\n      e.yyx * scene(p + e.yyx).sd +\n      e.yxy * scene(p + e.yxy).sd +\n      e.xxx * scene(p + e.xxx).sd);\n}\n\n//https://en.wikipedia.org/wiki/Phong_reflection_model\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 rd, vec3 normal, Material mat) {\n  vec3 cubemapReflectionColor = texture(iChannel0, reflect(rd, normal)).rgb;\n\n  vec3 K_a = 1.5 * mat.ambientColor * cubemapReflectionColor; // Reflection\n  vec3 K_d = mat.diffuseColor;\n  vec3 K_s = mat.specularColor;\n  float alpha = mat.alpha;\n\n  float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n  float specular = pow(clamp(dot(reflect(lightDir, normal), -rd), 0., 1.), alpha);\n\n  return lightIntensity * (K_a + K_d * diffuse + K_s * specular);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  if (mouseUV == vec2(0.0)) mouseUV = vec2(0.5); // trick to center mouse on page load\n\n  vec3 lp = vec3(0);\n  vec3 ro = vec3(0, 0, 9); // ->8 to zoom out.  0<- to zoom in\n  ro.yz *= rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz *= rotate2d(mix(-PI, PI, mouseUV.x));\n\n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n  \n  vec3 col = texture(iChannel0, rd).rgb;//background cubemap\n  vec3 backgroundColor = col;\n  \n  Surface co = rayMarch(ro, rd);\n  if (co.sd > MAX_DIST) {\n    col = backgroundColor;\n  } else {\n      vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n      vec3 normal = calcNormal(p); // surface normal\n\n      // light 1\n      vec3 lightPosition1 = vec3(1, 1, 1);\n      vec3 lightDirection1 = normalize(lightPosition1 - p);\n      float lightIntensity1 = 0.8;\n      // light 2\n      vec3 lightPosition2 = vec3(-8, -6, -5);\n      vec3 lightDirection2 = normalize(lightPosition2 - p);\n      float lightIntensity2 = 0.4; \n      \n      // final color of object\n      col = phong(lightDirection1, lightIntensity1, rd, normal, co.mat);\n      col += phong(lightDirection2, lightIntensity2, rd, normal, co.mat);\n  }\n\n  fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265359;\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;  //if rays gone too far we stop\nconst float PRECISION = 0.001; //if the value less we consider that an object\n\nstruct Material {\n  vec3 ambientColor;  //the color of an object where it is in shadow\n  vec3 diffuseColor;  // color that the object reveals under pure white light\n  vec3 specularColor; // the color of the light of a specular reflection\n  float alpha;        // shininess\n}; \n\nstruct Surface {\n  int id;      // id of object\n  float sd;    // signed distance\n  Material mat;\n};","name":"Common","description":"","type":"common"}]}