{"ver":"0.1","info":{"id":"dsVGzV","date":"1678843216","viewed":40,"name":"Fork Radial nav sjinno 196","username":"sjinno","description":"Animation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["animation"],"hasliked":0,"parentid":"dl2XRK","parentname":"Radial nav animation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float kInvPi = 1.0 / 3.141592;\n\n\nvec3 PlotPoint(vec3 rgb, vec2 fragCoord, vec2 point, vec3 pointColor) {\n\tfloat fDistToPointB = length( point - fragCoord.xy) - 4.0;\n\treturn mix(rgb, pointColor , (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n}\n\n// Plot Mouse Pos\n// rgb = PlotPoint(rgb, fragCoord, vec2(iMouse.x, iMouse.y), vec3(0.0, 1.0, 0.0));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float indicator = 0.0;\n    // Define how blurry the circle should be. \n    // A value of 1.0 means 'sharp', larger values\n    // will increase the bluriness.\n    float bluriness = 1.0;\n    \n    // In the range (0, 1].\n    float radius = 0.75;\n    \n    // In the range (0, 1].\n    float thickness = 0.5;\n    \n\n    // Optional offset.\n    float offset = 0.5;// * iTime;\n    \n    // Calculate texture coordinates. Normally you would\n    // simply pass them from the vertex shader.\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Convert from range [0,1] to [-1,1]\n    uv = 2.0 * uv - 1.0;\n    \n    // Adjust for the aspect ratio. Not necessary if\n    // you supplied texture coordinates yourself.\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    \n    float transition = smoothstep(0.7,1.0, sin(iTime * 1.5));// * .5;\n  \n\n    // Calculate distance to (0,0).\n    float distance = length( uv );\n\n    float waggleX = transition * sin((uv.y) * 100.0) * 0.08;\n    float waggleY = transition * sin((uv.x) * 100.0) * 0.08;\n    distance += waggleX + waggleY;\n    \n\n\n    // float edgeWidth = 0.01;\n    \n    // anti-alias the edges of the circle. This scales nicely with the display size\n    float edgeWidth = bluriness * fwidth( distance );\n    \n    \n     edgeWidth += transition * abs(uv.x);\n    \n     // color the circle (1.0) if distance is inside the outer radius, else 0.0 (with a smooth transition at the edge)\n     float circle = smoothstep( radius + edgeWidth, radius - edgeWidth, distance );\n\n    \n    // Now cut a hole in it by un-coloring inside the inner circle\n    float inner = radius - thickness;\n    circle -= smoothstep( inner + edgeWidth, inner - edgeWidth, distance ) * .5;\n    \n\n    \n    // Calculate angle, so we can draw segments, too.\n    float angle = atan( uv.x, uv.y ) * kInvPi * 0.5;\n    angle = fract( angle - offset );\n    \n    // In the range (0, 1].\n    float len = smoothstep(2.0, 1.0, abs(sin( iTime * 10. * 1.0 ) * 5.0)); // 0.65 + 0.4 * \n\n    // Or only draw a portion (segment) of the circle.\n    float wa = fwidth( angle ) * bluriness;\n    float segment = smoothstep( len + wa, len - wa, angle );\n    segment *= smoothstep( 0.0, 2.0 * wa, angle );    \n    //circle *= mix( segment, 1.0, step( 1.0, len ) );\n        \n    // Let's define the circle's color now.\n    vec3 vColor = vec3( 0.95, 0.95, 0.95 ) - ((1.0 - transition) * circle * vec3(0.2, 0.2, 0.2) ); \n        \n    \n    // Output final color.\n    fragColor = vec4( vColor, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}