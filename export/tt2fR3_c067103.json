{"ver":"0.1","info":{"id":"tt2fR3","date":"1599540561","viewed":366,"name":"Godray fog","username":"edo_m18","description":"Godray fog.\n\n// Refer to : https://www.shadertoy.com/view/WsfBDf\n//\n// This work refers to above post.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["godray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Refer to : https://www.shadertoy.com/view/WsfBDf\n//\n// This work refers to above post.\n//\nconst vec3 c_lightDirection = normalize(vec3(0.0, 0.4, -1.0));\nconst float c_rayMaxDist = 10000.0f;\nconst int c_numRayMarchSteps = 100;\nconst vec3 c_fogColorLit = vec3(1.0, 1.0, 1.0);\nconst vec3 c_fogColorUnlit = vec3(0.0, 0.0, 0.0);\nconst float c_fogDensity = 0.015f;\n\nstruct SRayHitInfo\n{\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n};\n    \nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere\n{\n    float radius;\n    vec3 position;\n    vec3 color;\n};\n    \nstruct Plane\n{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n};\n\nbool RayVsSphere(Ray ray, Sphere sphere, inout SRayHitInfo hitInfo)\n{\n    vec3 a = ray.origin - sphere.position;\n    float b = dot(a, ray.direction);\n    float c = dot(a, a) - (sphere.radius * sphere.radius);\n    float d = b * b - c;\n    float t = -b - sqrt(d);\n    \n    if (d > 0.0 && t > 0.0 && t < hitInfo.dist)\n    {\n        vec3 hitPoint = ray.origin + ray.direction * t;\n        hitInfo.dist = t;\n        hitInfo.normal = normalize(hitPoint - sphere.position);\n        hitInfo.diffuse = sphere.color;\n        return true;\n    }\n    \n    return false;\n}\n\nvoid RayVsPlane(Ray ray, Plane plane, inout SRayHitInfo hitInfo)\n{\n    float d = -dot(plane.position, plane.normal);\n    float v = dot(ray.direction, plane.normal);\n    float t = -(dot(ray.origin, plane.normal) + d) / v;\n    \n    if (t > 0.0 && t < hitInfo.dist)\n    {\n        vec3 hitPoint = ray.origin + ray.direction * t;\n        hitInfo.normal = plane.normal;\n        hitInfo.diffuse = plane.color;\n        hitInfo.dist = t;\n    }   \n}\n\nSRayHitInfo RayVsScene(Ray ray)\n{\n    SRayHitInfo hitInfo;\n    hitInfo.dist = c_rayMaxDist;\n    \n    // sphere init\n    Sphere spheres[3];\n    \n    {\n        spheres[0].radius = 1.0;\n        spheres[0].position = vec3(1.0, -0.5, 0.0);\n        spheres[0].color = vec3(1.0, 0.0, 0.0);\n\n        spheres[1].radius = 2.0;\n        spheres[1].position = vec3(7.0, 0.0, 0.0);\n        spheres[1].color = vec3(0.0, 1.0, 0.0);\n\n        spheres[2].radius = 3.5;\n        spheres[2].position = vec3(-8.0, 0.5, 0.0);\n        spheres[2].color = vec3(0.0, 0.0, 1.0);\n    }\n    \n    RayVsSphere(ray, spheres[0], hitInfo);\n    RayVsSphere(ray, spheres[1], hitInfo);\n    RayVsSphere(ray, spheres[2], hitInfo);\n    \n    Plane plane = Plane(vec3(0.0, -8.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.15));\n    RayVsPlane(ray, plane, hitInfo);\n    \n    return hitInfo;\n}\n\nvec3 GetColorForRay(in Ray ray, out float hitDistance)\n{\n    SRayHitInfo hitInfo = RayVsScene(ray);\n    hitDistance = hitInfo.dist;\n    \n    if (hitInfo.dist == c_rayMaxDist)\n    {\n        return texture(iChannel0, ray.direction).rgb;\n    }\n    \n    float dp = clamp(dot(hitInfo.normal, c_lightDirection), 0.0, 1.0);\n    return hitInfo.diffuse * dp;\n}\n\nvec3 ApplyFog(in Ray ray, in vec3 sceneColor, in float dist)\n{\n    float fogLitPercent = 0.0;\n    for (int i = 0; i < c_numRayMarchSteps; i++)\n    {\n        vec3 testPos = ray.origin + ray.direction * dist * (float(i) / float(c_numRayMarchSteps));\n        Ray newRay = Ray(testPos, c_lightDirection);\n        SRayHitInfo shadowHitInfo = RayVsScene(newRay);\n        fogLitPercent = mix(fogLitPercent, (shadowHitInfo.dist == c_rayMaxDist) ? 1.0 : 0.0, 1.0 / float(i + 1));\n    }\n    \n    vec3 fogColor = mix(c_fogColorUnlit, c_fogColorLit, fogLitPercent);\n    float absorb = exp(-dist * c_fogDensity);\n    return mix(fogColor, sceneColor, absorb);\n}\n    \nmat3 camera(in vec3 ro, in vec3 ta)\n{\n    const vec3 up = vec3(0, 1.0, 0);\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy;\n    float angleX = -mouse.x * 16.0f / float(iResolution.x);\n    float angleY = mix(0.0, 3.14159265359, mouse.y / float(iResolution.y));\n    float cameraDistance = 30.0;\n    float x = sin(angleX) * sin(angleY) * cameraDistance;\n    float y = -cos(angleY) * cameraDistance;\n    float z = cos(angleX) * sin(angleY) * cameraDistance;\n    \n    vec3 ro = vec3(x, y, z) + vec3(-20.0, cameraDistance, 30.0);\n    vec3 ta = vec3(0.0, 0.0, 0);\n    \n    mat3 c = camera(ro, ta);\n    \n    Ray ray;\n    ray.origin = ro;\n    ray.direction = normalize(c * vec3(p, 3.0));\n        \n    float hitDistance;\n    vec3 col = GetColorForRay(ray, hitDistance);  \n    col = ApplyFog(ray, col, hitDistance);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}