{"ver":"0.1","info":{"id":"DdsBWS","date":"1689181352","viewed":71,"name":"Magic Circle creator","username":"GianlcaV","description":"a customizable magic circle","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["circle","magic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n\nvec3 palette( float t ) {\n    return vec3(1.0*t,0.1*t,0.4*t);\n}\n\nvec2 rotate(vec2 uv, float th) {\n    return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvec3 getCircle(vec2 p, vec2 rp, float size, vec3 color){\n    p += rp;\n    p = rotate(p,iTime);\n    \n    float c = step(distance(p, rp), size);\n    c -= step(distance(p, rp), size*0.9);\n    \n    return c*color;\n}\n\nvec3 getCircle(vec2 p, vec2 rp, float size, vec3 color, float rotationSpeed){\n    p += rp;\n    p = rotate(p,rotationSpeed*iTime);\n    \n    float c = step(distance(p, rp), size);\n    c -= step(distance(p, rp), size*0.9);\n    \n    return c*color;\n}\n\nvec3 getCircle(vec2 p, vec2 rp, float size, vec3 color, float rotationSpeed, float rotationOffset){\n    p += rp;\n    p = rotate(p,rotationSpeed*iTime+rotationOffset);\n    \n    float c = step(distance(p, rp), size);\n    c -= step(distance(p, rp), size*0.9);\n    \n    return c*color;\n}\n\nvec3 getPolynomial(vec2 p, vec2 rp, int sides,float size, vec3 color){\n    \n    p -= rp;\n    p = rotate(p,iTime);\n    float d = 0.0;\n\n    // Number of sides of your shape\n    int N = sides;\n\n    // Angle and radius from the current pixel\n    float a = atan(p.x,p.y)+PI;\n    float r = TWO_PI/float(N);\n\n    // Shaping function that modulate the distance\n    d = cos(floor(.5+a/r)*r-a)*length(p);     //test the .5 later, interesting effect\n    \n    float t = (1.0-step(size*0.5,d));\n    t -= (1.0-step(size*0.5*0.9,d));\n\n    return  t*color;\n}\n\nvec3 getPolynomial(vec2 p, vec2 rp, int sides, float size, vec3 color, float rotationSpeed){\n    \n    p -= rp;\n    p = rotate(p,rotationSpeed*iTime);\n    float d = 0.0;\n\n    // Number of sides of your shape\n    int N = sides;\n\n    // Angle and radius from the current pixel\n    float a = atan(p.x,p.y)+PI;\n    float r = TWO_PI/float(N);\n\n    // Shaping function that modulate the distance\n    d = cos(floor(.5+a/r)*r-a)*length(p);     //test the .5 later, interesting effect\n    \n    float t = (1.0-step(size*0.5,d));\n    t -= (1.0-step(size*0.5*0.9,d));\n\n    return  t*color;\n}\n\nvec3 getPolynomial(vec2 p, vec2 rp, int sides, float size, vec3 color, float rotationSpeed, float rotationOffset){\n    \n    p -= rp;\n    p = rotate(p,rotationSpeed*iTime+rotationOffset);\n    float d = 0.0;\n\n    // Number of sides of your shape\n    int N = sides;\n\n    // Angle and radius from the current pixel\n    float a = atan(p.x,p.y)+PI;\n    float r = TWO_PI/float(N);\n\n    // Shaping function that modulate the distance\n    d = cos(floor(.5+a/r)*r-a)*length(p);     //test the .5 later, interesting effect\n    \n    float t = (1.0-step(size*0.5,d));\n    t -= (1.0-step(size*0.5*0.9,d));\n\n    return  t*color;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n  vec2 uv0 = uv;\n  vec3 finalColor = vec3(0.0);\n    \n  float d = 1.0;\n  \n\n\n\n  \n  vec3 color = palette(length(uv0) + (1.0+sin(iTime)/1.5));\n  \n  float rs1 = 1.1;\n  vec3 rectangle1 = getPolynomial(uv, vec2(0.0, 0.0),4,rs1,color,1.,0.215);\n  \n  float cs1 = 1.;\n  vec3 circle1 = getCircle(uv, vec2(0.0, 0.0), cs1,color);\n  \n  float cs2 = 0.5;\n  vec3 circle2 = getCircle(uv, vec2(0.0, 0.0), cs2,color);\n  \n  float ts1 = 1.0;\n  vec3 triangle1 = getPolynomial(uv, vec2(0.0, 0.0),3,ts1,color,-1.,1.);\n  \n  float ts2 = 0.5;\n  vec3 triangle2 = getPolynomial(uv, vec2(0.0, 0.0),3,ts2,color,-0.33);\n  float ts3 = 0.5;\n  vec3 triangle3 = getPolynomial(uv, vec2(0.0, 0.0),3,ts3,color,-0.33,1.);\n  \n  \n  float ps2 = 1.6;\n  vec3 poly = getPolynomial(uv, vec2(0.0, 0.0),8,ps2,color,0.33,0.2);\n  \n\n  finalColor = (triangle1 + rectangle1 + circle1 + triangle2 + circle2+ poly+triangle3) * d;\n  fragColor = vec4(finalColor,1.0);\n    \n \n}","name":"Image","description":"","type":"image"}]}