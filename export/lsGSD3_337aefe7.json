{"ver":"0.1","info":{"id":"lsGSD3","date":"1466951632","viewed":252,"name":"Dodge the cubes","username":"sergiu","description":"Simple experimental game, developped by Javier Soria Garcia y Sergiu Ovidiu Oprea for PGATR subject. \nMIGJRV 2015-2016 master's degree.\n\nDodge the cubes using the mouse. After 3 impacts, you die. Press space bar to restart the game. Good luck and hf!\n","likes":5,"published":1,"flags":112,"usePreview":0,"tags":["procedural","raymarching","voronoi","game","pgatr","cellularmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Mds3WX","filepath":"https://soundcloud.com/futurecopofficial/1-futurecop-transformers?in=futurecopofficial/sets/the-movie-album-2012","previewfilepath":"https://soundcloud.com/futurecopofficial/1-futurecop-transformers?in=futurecopofficial/sets/the-movie-album-2012","type":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/****************************************************************/\n/****************************************************************/\n/*  Dodge the cubes - Sergiu Ovidiu Oprea & Javier Soria GarcÃ­a */\n/****************************************************************/\n/****************************************************************/\n/** Inspired on: https://www.shadertoy.com/view/MsX3Rf **********/\n/*************** https://www.shadertoy.com/view/ldSGRW **********/\n/*************** https://www.shadertoy.com/view/Xds3zN **********/\n/****  PGATR subject - MIGJRV 2015-2016 master degree  **********/\n/****************************************************************/\n/****************************************************************/\n\n//Buffer A\nconst vec2 Points     = vec2(0.0,0.0);\t\t\t\t//Total points\nconst vec2 State      = vec2(1.0,0.0);\t\t\t\t//Current state\n\n\nfloat focus = 3.0;\t\t\t\t\t\t\t//Tunnel focus coefficient\nfloat far = 5.5;\t\t\t\t\t\t\t//Far plane for the tunnel\nconst int maxIterations = 40;  \t\t\t\t//Raymarching iterations\nconst float mouseRadius = 0.10;\t\t\t\t//Mouse range movement from center\nconst float tunnelRadius = 0.30;\t\t\t//Tunnel radius\nconst float cellNumber = 8.0;\t\t\t\t//Cell number for tunnel walls\nbool bumpTunnel = true;\t\t\t\t\t\t//Walls bumpmapping using the cellular map\nconst float bumpMappingTunnelCoef = 0.3;\t//Bumpmapping coefficient\nconst float pi = 3.14159265;\t\t\t\t//Pi number\nfloat cubeSpeedCoef = 2.0;\t\t\t\t\t//Cube speed\nvec3 cubeSize = vec3(0.02);\t\t\t\t\t//Cube size\nconst int cubeNumber = 20;\t\t\t\t\t//Total number of cubes generated by frame\nconst int cubeNumberPerDim = 4; \t\t\t//Cubes per dimension. We will store the cubes in 2D, so: sqrt(cubeNumber)\nconst float collisionThresholdXY = 0.03;\t//Collision threshold. Collision in the x and y axis with mouse position and cubes\nconst float collisionThresholdZ = 0.3;\t\t//Collision threshold. Collision in the z axis with cube and camera position\t\n\n\n//Cell structure. Voronoi algorithm output\nstruct Cell\n{\n\tfloat d;\t\n\tvec2 hash;\t\t\n\tvec2 pos;\t\n};\n    \n//https://iquilezles.org/articles/distfunctions\nfloat box( vec3 p, vec3 b ) \n{\t\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n//Pseudo random number generator for seed n\nfloat rand(float n)\n{\n    return fract(sin(n * 12.9898) * 43758.5453);\n}\n\n//Cellular map noise\nvec2 Hash2(vec2 p)\n{\n    float r = 523.0 * sin(dot(p, vec2(53.3158, 43.6143)));\n    return vec2(fract(15.32354 * r), fract(17.25865 * r));\n}\n\n//Voronoi noise implementation. Based on iÃ±igo quilez.\nCell voronoise(in vec2 p)\n{\n    Cell result;\n\tp *= cellNumber;\n\t\n\tfloat d = 1.0e20;\n\tvec2 hash;\n\tvec2 pos;\n\t\n    for (int i = -1; i <= 1; i++)\n\t\tfor (int j = -1; j <= 1; j++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(i, j);\n\t\t\tvec2 h = Hash2(vec2(mod(tp.x, cellNumber), tp.y)); \n      \t\tfloat m = length(p - tp - h);\n\t\t\n\t\t\tif (m < d) \n\t\t\t{\n\t\t\t\td = m;\n\t\t\t\thash = h;\n\t\t\t\tpos = tp;\n\t\t\t}\n\t\t}\n\t\n\treturn Cell(d, hash, pos);\n}\n\n//Map function. Tunnel and box render. Inspired in https://www.shadertoy.com/view/ldSGRW\nvec4 map(vec3 p, vec2 mouse)\n{\n\tfloat d0, d1;\n\tvec3 pos = p;\n\t\n\tvec2 uv = vec2((atan(p.y, p.x) + pi) / (pi * 2.0), \n                   (iTime*0.6) * -1.0 + p.z * 0.4);\n\tCell cell = voronoise(uv);\n    \n    if(bumpTunnel)\n\t\tpos.xy *= 1.0 + (cell.d - 1.0) * bumpMappingTunnelCoef;\n    else\n        pos.xy *= 1.0 + cell.d * bumpMappingTunnelCoef;\n   \n\td0 = max(length(pos.xy) -  tunnelRadius + 0.01,\n          -(length(pos.xy) -  tunnelRadius)); //smoothstep interpolation value\n    \n    vec3 col1 = vec3(0.5, 0.2, 0.1);\n\tvec3 col2 = vec3(cell.hash.x*0.8, cell.hash.y*0.3, 0.45);\n\tvec3 col = mix(col1, col2 * cell.d, smoothstep(0.8, 0.6, d0)); //tunnel color\n\n    for(int i = 0; i < cubeNumberPerDim; i++)\n    for(int j = 0; j < cubeNumberPerDim; j++)\n    {\n        //Buffer A cube positions\n        vec4 pos = texture(iChannel0, (vec2(float(i) +2.0, float(j)) + 0.5)/iChannelResolution[0].xy);\n\n        d1 = box(p-pos.xyz, cubeSize); \n\n        if (d1 < d0)\n        {\n            d0 = d1;\n            col = vec3(0.5, 0.8, 0.5);\n\n            //Cube collision detection\n            if(abs(pos.x - mouse.x) < collisionThresholdXY && abs(pos.y - mouse.y) < collisionThresholdXY \n               && abs(pos.z - 1.5) < collisionThresholdZ)\n            {\n                col = mix(col, vec3(1.0, 0.0, 0.0), 0.7);\n            }\n        }\n    }\n\n\treturn vec4(col, d0);\n}\n\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n    \n    //Mouse\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    if(length(mouse) > mouseRadius) mouse *= mouseRadius / length(mouse);\n\t\n  \t//Ray configuration\n    vec3 ro = vec3(mouse, 1.5); //ray origin\n    vec3 ta = vec3(mouse, 0.0);\n    mat3 camera = setCamera(ro, ta, 0.0); //camera matrix\n    vec3 rd = camera * normalize(vec3(uv.xy, 2.5)); //ray direction\n    \n    //Raymarching\n    vec4 res;\n\tfloat depth = 0.0;\n\t\n    for(int i = 0; i < maxIterations; ++i) \n\t{\n        res = map(ro, mouse);\n\t\t\n        depth += res.w;\n        ro += rd * res.w;\n\t\t\n        if(res.w < 0.01) break;\n        if(depth > far) { depth = far; break; }\n    }\n\t\n    float b = 1.0 - depth/far;\n\tvec3 col = b * res.rgb;\n\t\n\tcol *= pow(1.2 + smoothstep(0.6, 0.0, abs(sin(ro.z+iTime*2.0))), 2.0);\n    \n   \tfloat points = texture(iChannel0, Points + 0.5 /iChannelResolution[0].xy).x;\n    float factor; \n    \n    if( points == 3.0)\n        factor = 2.0;\n    \n    if( points == 2.0)\n        factor = 1.0;\n    \n    if( points == 1.0)\n        factor = 0.5;\n    \n\tcol *= 1.0 - smoothstep(0.0, factor, length(uv.xy));\n\t\n    col += texture(iChannel1, fragCoord/iChannelResolution[1].xy).xyz;\n\t\n\tfragColor = vec4(col*1.2, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float mouseRadius = 0.10;\nconst int blocksNumber = 20;\nconst int blocksPerDim = 4;\nconst float collisionThresholdXY = 0.03;\t//Collision threshold. Collision in the x and y axis with mouse position and cubes\nconst float collisionThresholdZ = 0.3;\t\t//Collision threshold. Collision in the z axis with cube and camera position\t\nfloat blockSpeed = 1.5;\n\n\nconst float KEY_SPACE = 32.5/256.0;\n\nconst vec2 Points     = vec2(0.0,0.0);\t\t\nconst vec2 State      = vec2(1.0,0.0);\t\t\nconst vec2 Speed \t  = vec2(9.0,0.0);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\n\n//----------------------------------------------------------------------------------------------\n\nvec4 loadValue( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n//----------------------------------------------------------------------------------------------\n\n\nfloat rand(float n)\n{\n    return fract(sin(n * 12.9898) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    if( fragCoord.x > 14.0 || fragCoord.y>14.0 ) discard;\n    \n  \tvec2 points    = loadValue( Points ).xy;\n    float state     = loadValue( State ).x;\n    float speed     = loadValue( Speed ).x;\n\tvec4 spots[blocksNumber];\n    \n    for(int i = 0; i < blocksPerDim; i++)\n    for(int j = 0; j < blocksPerDim; j++)\n       \tspots[blocksPerDim * i + j] = texture(iChannel0, (vec2(float(i) +2.0, float(j)) + 0.5)/iChannelResolution[0].xy).xyzw;       \n\n       \n    \n    //Mouse\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = mouse * 2.0 - 1.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    if(length(mouse) > mouseRadius) mouse *= mouseRadius / length(mouse);\n   \n    \n   \tif( iFrame==0 ) { state = -1.0; }\n    \n    if(state == -1.0)\n    {\n        for(int i = 0; i < blocksNumber; i++)\n            spots[i].w = 1.0;\n    \n        state = 0.0;  \n        speed = 2.0; \n        points.x = 3.0;\n        points.y = 0.0;\n    }\n        \n\telse if(state == 0.0)\n    {\n       \n        for(int i = 0; i < blocksNumber; i++)\t\t\n        {\n            float ltime = iTime * speed + float(i) * 30.0;\n            float r = rand(float(i)*20.33);\n            float z = -6.0+mod(ltime*(r + 0.5), 15.0);\n\n            spots[i].xyz = vec3(0.04*mod(float(i), 5.0) - 0.09, 0.08*floor(float(i)/5.0) -0.08, z);    \n\n            if(iTime > 2.5)\n            {\n                if(abs(spots[i].x - mouse.x) < collisionThresholdXY && abs(spots[i].y - mouse.y) < collisionThresholdXY \n                   && abs(spots[i].z - 1.5) < collisionThresholdZ && spots[i].w == 1.0)\n                {\n                   points.x -= 1.0;\n                   spots[i].w = 0.0;\n                } \n\n                if(spots[i].w == 0.0 && spots[i].z < 0.0)\n                    spots[i].w = 1.0;\n                \n                points.y += 0.005; //score\n            }\n        }\n    }\n    else \n    {\n        float pressSpace = texture( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n        if( pressSpace>0.5 )\n        {\n            points.x = 3.0;\n            points.y = 0.0;\n            speed = 2.0;\n            state = -1.0;\n        }\n    }\n    \n    \n    if(points.x == 0.0)\n        state = 1.0;\n    \n    if(speed < 5.0)\n    \tspeed += 0.001;\n    \n    storeValue( Points,   vec4(points,0.0,0.0),\t      fragColor, fragCoord );\n    storeValue( State,    vec4(state,0.0,0.0,0.0),    fragColor, fragCoord );\n    storeValue( Speed,    vec4(speed,0.0,0.0,0.0),    fragColor, fragCoord );\n    \n    for(int i = 0; i < blocksPerDim; i++)\n    {\n        for(int j = 0; j < blocksPerDim; j++)\n        {\n        \tstoreValue( vec2(float(i) + 2.0, float(j)),    spots[blocksPerDim * i+j],    fragColor, fragCoord );\n        }\n    }\n    \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\nconst vec2 Points     = vec2(0.0,0.0);\t\t\nconst vec2 State      = vec2(1.0,0.0);\nconst vec2 Lifes \t  = vec2(8.0,0.0);\n\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆ     010    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆâ–ˆâ–ˆ -> 111 -> 010 101 101 111 101 101 101 -> 712557\nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \n*/\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\nvec2 res = iResolution.xy / 4.0;\nvec2 print_pos = vec2(2,2);\n\n//Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n//Returns the digit sprite for the given number.\nfloat get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return 0.0;\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= 0;i--)\n    {\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0); //Clip off leading zeros.\n        \n        float digit = mod(number / pow(10.0, float(i)),10.0);\n        \n        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;\n        \n        dec_pos.x += CHAR_SPACING.x * clip;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / 4.0;\n    uv =  floor(uv);\n    \n    float col = 0.0;\n    \n    print_pos = vec2(2);\n    print_pos = floor(print_pos);\n    \n    \n   \tvec2 points = texture(iChannel0, Points + 0.5 /iChannelResolution[0].xy).xy;\n       \n    col += char(ch_p,uv);\n    col += char(ch_o,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_t,uv);\n    col += char(ch_s,uv);\n    \n    col += char(ch_col,uv);\n    \n\tcol += print_number(points.y, print_pos,uv);\n    \n    print_pos = vec2(2.0, 100.0);\n    \n    col += char(ch_l,uv);\n    col += char(ch_i,uv);\n    col += char(ch_f,uv);\n    col += char(ch_e,uv);\n    col += char(ch_s,uv);\n    \n    col += char(ch_col,uv);\n\tcol += print_number(points.x, print_pos,uv);\n    \n    \n    if(points.x == 0.0)\n    {\n        print_pos = vec2(res.x/2.0 - STRWIDTH(11.0)/2.0,res.y/2.0 - STRHEIGHT(1.0)/2.0);\n        print_pos = floor(print_pos);\n        \n        col = char(ch_g,uv);\n        col += char(ch_a,uv);\n        col += char(ch_m,uv);\n        col += char(ch_e,uv);\n        \n        col += char(ch_sp,uv);\n        \n        col += char(ch_o,uv);\n        col += char(ch_v,uv);\n        col += char(ch_e,uv);\n        col += char(ch_r,uv);\n        \n        print_pos = vec2(res.x/2.0 - STRWIDTH(11.0)/2.0,res.y/2.0 - STRHEIGHT(4.0)/2.0);\n        print_pos = floor(print_pos);\n        \n        col += char(ch_s,uv);\n        col += char(ch_c,uv);\n        col += char(ch_o,uv);\n        col += char(ch_r,uv);\n        col += char(ch_e,uv);\n        col += char(ch_col,uv);\n        \n        col += print_number(points.y, print_pos,uv);\n    \n    }\n    \n    if(iTime < 2.5)\n    {\n        print_pos = vec2(res.x/2.0 - STRWIDTH(3.0)/2.0,res.y/2.0 - STRHEIGHT(-4.0)/2.0);\n        print_pos = floor(print_pos);\n        \n        col = char(ch_g, uv);\n        col += char(ch_o, uv);\n        col += char(ch_exc, uv);\n    }\n    \n    if(iTime < 2.0)\n    {\n        print_pos = vec2(res.x/2.0 - STRWIDTH(5.0)/2.0,res.y/2.0 - STRHEIGHT(-4.0)/2.0);\n        print_pos = floor(print_pos);\n        \n        col = char(ch_r, uv);\n        col += char(ch_e, uv);\n        col += char(ch_a, uv);\n        col += char(ch_d, uv);\n        col += char(ch_y, uv);\n        \n    }\n    \n    if(iTime < 1.0)\n    {\n        print_pos = vec2(res.x/2.0 - STRWIDTH(7.0)/2.0,res.y/2.0 - STRHEIGHT(-4.0)/2.0);\n        print_pos = floor(print_pos);\n        \n        col = char(ch_p, uv);\n        col += char(ch_r, uv);\n        col += char(ch_e, uv);\n        col += char(ch_p, uv);\n        col += char(ch_a, uv);\n        col += char(ch_r, uv);\n        col += char(ch_e, uv);\n    }\n\n    \n\tfragColor = vec4(vec3(col), 1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}