{"ver":"0.1","info":{"id":"XcBfR1","date":"1724614368","viewed":15,"name":"Fork Interior M PicassoCT 285","username":"PicassoCT","description":"Interior Mapping - most simple implementation (for beginners)\n\nAnimated the nyan cat and the room switching on and off lights","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["parallax","interiormapping"],"hasliked":0,"parentid":"DldcRs","parentname":"Interior Mapping (tutorial)"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Interior room count (width, height, depth)\nconst vec3 interior = vec3(4.0f, 4.0f, 1.0f);\n\nfloat rand(float v){\n    return fract(sin(v * 30.11));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Pixel position\n    vec3 pixel = vec3(uv.x, uv.y, 0.0f);\n    // apply tiling\n    pixel = fract(pixel * interior);\n    \n    // Camera position\n    //vec3 camera = vec3(1.0f, 1.0f, 1.0f);\n    vec3 camera = vec3(0.5f + cos(iTime*0.5f)*0.5f, 0.5f + sin(iTime*0.5f)*0.5f, 1.0f);\n    // apply tiling offset\n    camera.xy -= (uv - pixel.xy);\n    \n    // Up vector\n    vec3 up = vec3(0.0f, 1.0f, 0.0f);\n    \n    // Right vector\n    vec3 right = vec3(1.0f, 0.0f, 0.0f);\n    \n    // View direction\n    vec3 viewDir = pixel - camera;\n\n    // Floor position\n    vec3 floor;\n    floor.y = 0.0f;\n    floor.z = ((pixel.y/camera.y)*camera.z) / (1.0f-(pixel.y/camera.y));\n    floor.x = (pixel.x-camera.x + (camera.z/(camera.z+floor.z))*camera.x) / (camera.z/(camera.z+floor.z));\n\n    // Ceiling position\n    vec3 ceiling;\n    ceiling.y = 1.0f;\n    ceiling.z = ((1.0f - pixel.y)/(1.0f-camera.y))*camera.z / (1.0f-((1.0f - pixel.y)/(1.0f-camera.y)));\n    ceiling.x = camera.x + (pixel.x-camera.x)*(ceiling.z+camera.z)/camera.z;\n    \n    // Left Wall position\n    vec3 leftWall;\n    leftWall.x = 0.0f;\n    leftWall.z = ((pixel.x/camera.x)*camera.z) / (1.0f-(pixel.x/camera.x));\n    leftWall.y = (pixel.y - (leftWall.z/(leftWall.z+camera.z))*camera.y) / (1.0f-leftWall.z/(leftWall.z+camera.z)); \n    \n    // Right Wall position\n    vec3 rightWall;\n    rightWall.x = 1.0f;\n    rightWall.z = (((1.0f-pixel.x)/(1.0f-camera.x))*camera.z) / (1.0f-(1.0f-pixel.x)/(1.0f-camera.x));\n    rightWall.y = (pixel.y - (rightWall.z/(rightWall.z+camera.z))*camera.y) / (1.0f-rightWall.z/(rightWall.z+camera.z));;\n    \n    // Back Wall position\n    vec3 backWall;\n    backWall.z = interior.z;\n    backWall.x = (pixel.x-camera.x)*(camera.z+interior.z)/(camera.z) + camera.x;\n    backWall.y = (pixel.y-camera.y)*(camera.z+interior.z)/(camera.z) + camera.y;\n    \n    // Compute intersecting plane\n    bool isCeiling = dot(viewDir, up) > 0.0f;\n    bool isRightWall = dot(viewDir, right) > 0.0f;\n    \n    float leftRightWallsDepth = isRightWall? rightWall.z : leftWall.z;\n    float floorCeilingDepth = isCeiling? ceiling.z : floor.z;\n     \n    bool isWallsClosest = leftRightWallsDepth < floorCeilingDepth;\n    float closestHit = isWallsClosest? leftRightWallsDepth : floorCeilingDepth; \n    \n    bool isBackClosest = interior.z < closestHit;\n     \n    // Sample texture\n    if(isBackClosest)\n    {\n        fragColor = texture(iChannel2, backWall.xy);\n    }\n    else if(isWallsClosest)   \n    {\n        if(isRightWall)\n        {\n            fragColor = texture(iChannel1, rightWall.zy);\n        }\n        else\n        {\n            fragColor = texture(iChannel1, leftWall.zy);\n        }\n    }\n    else\n    {\n        if(isCeiling)\n        {\n            fragColor = texture(iChannel0, ceiling.xz);\n        }\n        else\n        {\n            fragColor = texture(iChannel0, floor.xz);\n        }\n    }\n    \n        \n    // Chair Layer position\n    vec3 chairLayer;\n    chairLayer.z = interior.z * 0.5f;\n    chairLayer.x = (pixel.x-camera.x)*(camera.z+interior.z*0.5f)/(camera.z) + camera.x;\n    chairLayer.y = (pixel.y-camera.y)*(camera.z+interior.z*0.5f)/(camera.z) + camera.y;\n    bool isChairClosest = interior.z * 0.5f< closestHit;\n    \n    if(isChairClosest)\n\t{\n        chairLayer.x = chairLayer.x+ sin(iTime);\n\t\tvec4 chairTexture = texture(iChannel3, chairLayer.xy);\n\t\tfragColor = mix(fragColor, chairTexture, chairTexture.a);\n\t}\n\n    // random \"lighting\" per room\n    vec2 room = ceil(uv * interior.xy);\n    float roomID = room.y * interior.x + room.x;\n    float slowShift = (iTime/100.0);\n    fragColor.rgb *= mix(0.5f, 1.5f, rand(roomID + slowShift));\n    \n}","name":"Image","description":"","type":"image"}]}