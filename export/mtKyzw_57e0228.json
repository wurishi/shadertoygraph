{"ver":"0.1","info":{"id":"mtKyzw","date":"1700299426","viewed":155,"name":"Flowing Water Over The Rock","username":"binzero","description":"a simple flowing water ","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","water","rock","stoneheightmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Flowing Water \n\n    Based on:\n    \n    The Rock generates based on:  \n    Shane' Precalculated Voronoi Heightmap- https://www.shadertoy.com/view/ldtGWj\n    \n    The movements based on: \n    fizzer'Flowing Lava -  https://www.shadertoy.com/view/4djSzR\n    \n\n    BufferA: Voronoi Heightmap for rock\n    BufferB: Camera change tracking\n    \n             \n*/\n\n\n\n#define FAR 80. // Maximum ray distance. Analogous to the far plane.\n\n\nfloat moveSpeed= 0.5;\nconst vec3 waterColor = vec3(.4,.8,1.) * 0.5; //vec3(0.1,0.27,0.65);\n\n\nvec3 ACESFilm(vec3 x)\n{\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\n\nfloat cubic(float x)\n{\n    return (3.0 * x - 2.0 * x * x) * x;\n}\n\nvec3 rotateX(float angle, vec3 v)\n{\n    return vec3(v.x, cos(angle) * v.y + sin(angle) * v.z, cos(angle) * v.z - sin(angle) * v.y);\n}\n\nvec3 rotateY(float angle, vec3 v)\n{\n    return vec3(cos(angle) * v.x + sin(angle) * v.z, v.y, cos(angle) * v.z - sin(angle) * v.x);\n}\n\nfloat hash(float n)\n{\n    n=mod(n,1024.0);\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 p)\n{\n    return hash(p.x + p.y*57.0);\n}\n\nfloat evalWaterHeight(vec2 p)\n{\n    float move_ofs = iTime*moveSpeed;\n    float l = cubic(clamp(1.0-(-p.y-move_ofs) +sin(p.x+iTime*0.2),0.0,1.0));\n    float fade = clamp((p.y + move_ofs )/ (20.), 0., 1.);\n    \n    return  mix(-0.5,0.25, l) + mix(0., 1., fade * fade); \n}\n\n\n\n\n// ------------------------------------ Rock\n\n// Grey scale.\nfloat getGrey(vec3 p){ return p.x*0.299 + p.y*0.587 + p.z*0.114; }\n\n\nfloat heightField(vec2 p)\n{\n    return texture(iChannel1, fract(p/11.)).w;\n}\n\n\nvec3 getNormal( vec2 p, float t) // for terrain g(p)\n{\n    const float eps = 0.005; // or some other value\n    vec2 h = vec2(eps * t,0);\n    return normalize( vec3( heightField(p-h.xy) - heightField(p+h.xy),\n                            2.0*h.x,\n                            heightField(p-h.yx) - heightField(p+h.yx) ) );\n}\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n )\n{\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor)\n{\n   \n    const float eps = 0.001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x-eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y-eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z-eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex,  p , nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n\n\nfloat map(vec3 p)\n{\n    float waterHeight = evalWaterHeight(p.xz);\n    float h = max(waterHeight,heightField(p.xz));\n    \n    return p.y - h;\n}\n\n// Ambient occlusion, for that self shadowed look.\n// Based on the original by IQ.\nfloat calculateAO(vec3 p, vec3 n)\n{\n   const float AO_SAMPLES = 5.0;\n   float r = 1.0, w = 1.0;\n   for (float i=1.0; i<=AO_SAMPLES; i++)\n   {\n      float d0 = i/AO_SAMPLES;\n      r += w * (map(p + n * d0) - d0);\n      w *= 0.5;\n   }\n   return clamp(r, 0.0, 1.0); \n}\n\n// Cool curve function, by Shadertoy user, Nimitz.\nfloat curve(in vec3 p){\n\n    const float eps = 0.0225, amp = 7.5, ampInit = 0.525;\n\n    vec2 e = vec2(-1., 1.)*eps; //0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\nvec3 sun_dir=normalize(vec3(-1., 1.5,-.6));\nvec3 sun_col=2.*vec3(1., 0.86, 0.4);\nvec3 render_rock(vec3 p, vec3 norm, vec3 ro, vec3 rd, float waterHeight)\n{\n   // vec3 shadingCol = shadingSimple_III(p, norm, ro, rd);\n   \n      vec3 shadingCol = vec3(0.);\n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro - rd * 2.; // Put it a bit in front of the camera.\n    \n    // Texture scale factor.\n    const float tSize0 = 1./3.;\n    \n    norm = doBumpMap(iChannel0, p*tSize0, norm, 0.02);\n    \n    // Obtaining the texel color. \n\tvec3 texCol = tex3D(iChannel0, p*tSize0, norm);\n    \n    vec3 sky=vec3(0.2,0.7,1.);\n    \n    vec3 n = norm;\n    \n    // --- The Sun\n    float dif=max(0.,dot(n,sun_dir));\n    float bac=max(0.,dot(n,-sun_dir));\n    float amb=max(0.,dot(n,vec3(0,1,0)));\n    vec3 Lo=6.5*dif*sun_col;\n    Lo+=0.5*bac*sun_col;\n    Lo+=3.5*amb*sky;\n   \tLo*=smoothstep(-1.,10.,p.y);\n    \n    shadingCol = Lo*texCol*0.4;\n    \n    \n    // --- The Light in front of camera\n    \n    // Light direction vectors.\n\tvec3 ld = lp-p;\n    \n    // Distance from respective lights to the surface point.\n\tfloat lDist = max(length(ld), 0.001);\n    \n    // Normalize the light direction vectors.\n\tld /= lDist;\n    \n    // Light attenuation, based on the distances above.\n\tfloat atten = 1./(1. + lDist*lDist*0.05);\n    \n    // Ambient light.\n\tfloat ambience = 0.5;\n    //float ambience=max(0.,dot(norm,vec3(0,1,0)));\n    \n    // Diffuse lighting.\n\tfloat diff = max( dot(norm, ld), 0.0);\n    \n    // Specular lighting.\n    vec3 halfwayDir = normalize(ld - rd);  \n\tfloat spec = pow(max(dot(norm, halfwayDir), 0.0), 16.);\n\n    vec3 rCol =  getGrey(texCol)*0.5 + texCol*0.5;\n    \n    float ao =  clamp(pow(max(p.y,0.05) * 1., 0.5) / 0.45,0.0,1.0);\n\n    float crv = curve(p); // Curve value, to darken the crevices.\n    crv = smoothstep(0., 1., crv)*.3  + .7; // Tweaking the curve value a bit.\n    \n    shadingCol += (rCol * (diff * 1.) + spec*texCol*0.7)*atten;\n    \n    shadingCol = shadingCol *ao * crv ;\n    \n    shadingCol += getGrey(texture(iChannel3, p.xz).xyz) * clamp((1.0-norm.y)*0.1+pow(max(0.0,(1.0-abs(waterHeight-p.y)*4.0)),4.0),0.0,1.0)*0.04;\n    return shadingCol;\n}\n\n\n\n//  ------------------------------------------  Water \n\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n\nfloat hash1(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\n\nfloat waterNoise(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hash1(p+vec2(0,0));\n    float b = hash1(p+vec2(1,0));\n    float c = hash1(p+vec2(0,1));\n    float d = hash1(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\n\n\nfloat water(vec2 p)\n{\n    p*=1.;\n\tfloat f = 2.;\n    float s = 0.4;\n    float a = 0.0;\n    float b = 0.5;\n    for(int i=0; i<5+min(0,iFrame); i++)\n    {\n        float n = waterNoise(vec2(p.x+10.,p.y+iTime*0.5));\n        a += b*n;\n        b *= s;\n        p = f*m2*p;\n    }\n\treturn 3.*a;\n}\n\nvec3 water_normal(vec2 pos, float t) \n{\n\tvec2 e=vec2(1e-5* t * t * t,0.0);\n    return normalize(vec3(water(pos-e.xy)-water(pos+e.xy),\n                          2.0*e.x,\n                          water(pos-e.yx)-water(pos+e.yx)));\n}\n\n\nvec3 march_rock(vec3 ro, vec3 rd)\n{\n    float t0=(0.9-ro.y)/rd.y;\n    float t1=(0.0-ro.y)/rd.y;\n    \n    vec3 prevp=ro+rd*t0,p=prevp;\n    float ph=heightField(prevp.xz);\n    \n    const int n= 10;\n    \n     float t = 0., d;\n\n    // Raymarch through the heightfield with a fixed number of steps.\n    for(int i=1;i<n;i+=1)\n    {\n        float pt=mix(t0,t1,float(i-1)/float(n));\n        float t=mix(t0,t1,float(i)/float(n));\n        p=ro+rd*t;\n        float h= heightField(p.xz);\n        if(h>p.y)\n        {\n            // Refine the intersection point.\n            float lrd=length(rd.xz);\n            vec2 v0=vec2(lrd*pt, prevp.y);\n            vec2 v1=vec2(lrd*t, p.y);\n            vec2 v2=vec2(lrd*pt, ph);\n            vec2 dv=vec2(h-v2.y,v2.x-v1.x);\n            float inter=dot(v2-v0,dv)/dot(v1-v0,dv);\n            p=mix(prevp,p,inter);\n\n            break;\n        }\n        prevp=p;\n        ph=h;\n    }\n    \n    return p;\n}\n\n\nvec3 render_water(vec3 p, vec3 norm, float t, vec3 ro, vec3 rd, float waterHeight)\n{\n    vec3 rock_n = norm;\n    vec3 n = water_normal(p.xz, t);\n    \n    \n    float foamAmount = smoothstep(0.0, 1.0, (p.z + iTime * moveSpeed + sin(p.x + iTime * 0.2) + 1.0) * 0.3 + 0.1);\n    foamAmount = clamp( 0.55 - foamAmount + smoothstep(0.25, 0.0, waterHeight) , 0.0, 1.) ;\n    \n    vec2 foamMapUV = p.zx;\n    foamMapUV = foamMapUV * 20.0 + waterHeight * 10.;\n    vec2 foamSampleUV = foamMapUV * 0.1 ;\n    vec4 foamSample = texture( iChannel3, foamSampleUV + sin(foamMapUV.x) * 0.05 + noise(foamMapUV * 0.1) * 0.04, 0.0 );\n    \n    float foam = getGrey(foamSample.xyz);\n\n    foam = 1.f - foam;\n    foam = 1.f - foam* foam;\n                \n    \n    norm = n;\n    //vec3 diffuse = 1.5*vec3(0.1,0.25,0.35);\n\n    //diffuse = diffuse*(0.5+0.5*n.x)*2.5;\n    \n    \n    vec3 shading = vec3(0.);\n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro - rd * 2.; // Put it a bit in front of the camera.\n    \n     // Obtaining the texel color. \n\tvec3 texCol = waterColor;\n    \n    // Light direction vectors.\n\tvec3 ld = lp-p;\n    \n    // Distance from respective lights to the surface point.\n\tfloat lDist = max(length(ld), 0.001);\n    \n    // Normalize the light direction vectors.\n\tld /= lDist;\n    \n    // Light attenuation, based on the distances above.\n\tfloat atten = 1./(1. + lDist*lDist*0.04);\n    \n    // Ambient light.\n\tfloat ambience = .5;\n    \n    // Diffuse lighting.\n\tfloat diff = max( dot(norm, ld), 0.0);\n    \n    // Specular lighting.\n\tfloat spec = pow(max( dot( reflect(-ld, norm), -rd ), 0.0 ), 8.);\n    \n    vec3 rCol = getGrey(texCol)*0.5 + texCol*0.5;;\n    \n    shading += (rCol * (diff * 1. +  ambience ) + spec*texCol*2.)*atten;\n\n    float falloff=0.;\n\n    vec3 rock_p = march_rock(ro, rd);\n    \n    falloff=1.-(smoothstep(-0.1, 1.5,  waterHeight + mix(0., 0.5, (ro.y - p.y)/ 25.)));\n    vec3 refrcol=render_rock(rock_p, rock_n, ro, rd, waterHeight);\n    \n    shading = mix(shading,refrcol,falloff*falloff );\n\n\n    return shading * (1.0 - foamAmount) +  foam * foamAmount * 0.4;\n}\n\n\n//  ------------------------------------------  Scene\n\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    float waterHeight=0.0;\n   \n    const int n= 64;\n    \n    vec3 p = vec3(0.0);\n    float prevph= p.y;\n    float ph=heightField(p.xz);\n    \n    float t = 0., d;\n    \n    // Raymarch through the heightfield with a fixed number of steps.\n    for(int i=1;i<n;i+=1)\n    {\n        d = map(p=ro+rd*t);\n        \n        if(abs(d)<.001*(t*.05 + 1.) || t>FAR) break;\n        \n        t += d*.7;\n    }\n    \n    return t;\n}\n\n\nvec3 sampleScene(vec2 coord)\n{\n\n    // Set up ray.\n    vec4 cameraSetting = texelFetch(iChannel2, ivec2(0.5, 1.5), 0);\n    float cam_dist = cameraSetting.x;\n    float cam_rotateY = cameraSetting.y;\n\n    vec3 ro=vec3(0.0, 5.0 + cam_dist,-2.0-iTime*moveSpeed+cos(iTime*1.0)*0.05);\n    vec3 rd=rotateY(3.1415926 +sin(iTime*0.1) - cam_rotateY,rotateX(1.0+sin(iTime*0.4)*0.05,normalize(vec3(coord,-1.3))));\n\n    \n    // Render Scene\n     float t = 0.;\n     vec3 p = vec3(0.0);\n     float waterHeight = 0.0;\n     \n     t = trace(ro, rd);\n     \n      vec3 col = vec3(0.0);\n      if (t < FAR)\n      {\n           p = ro+rd*t;\n     \n           // Re-evaluate the water height using the refined intersection point.\n           waterHeight = evalWaterHeight(p.xz);\n\n           vec3 norm= getNormal(p.xz, t);  \n           float mask =  max(0.0, 1.0 - abs(waterHeight - p.y) * 16.);\n           \n           // Wrap lighting is applied here, both to the rock, water\n           vec3 waterCol = render_water(p, norm, t, ro, rd, waterHeight);\n           vec3 rockCol =  render_rock(p, norm, ro, rd, waterHeight);\n    \n           col = waterCol * mask + rockCol * (1. - mask);\n\n    }\n    \n    // Apply Fog\n    col = mix(col, vec3(0.007, .01, .013) * 3., smoothstep(10., 60., t));\n    \n    return col ;\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (uv - vec2(0.5)) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    fragColor.rgb=sampleScene(uv);\n    \n    fragColor.rgb=ACESFilm(fragColor.rgb);\n    \n     // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    fragColor.rgb *= min(pow(16.*(1. - uv.x)*(1. - uv.y)*uv.x*uv.y, 1./8.)*1.1, 1.);\n    \n    // Gamma\n    fragColor.rgb = pow(fragColor.rgb, vec3(0.4545)); \n    fragColor.rgb=pow(fragColor.rgb,vec3(0.9,1.,0.95));\n    \n    //fragColor.rgb = texture(iChannel1, fragCoord.xy / iResolution.yy).www;\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// 2x2 hash algorithm.\nvec2 hash22(vec2 p) { \n    \n    // This line makes the pattern repeatable. \n    p = mod(p, 5.); \n\n    // More concise, but wouldn't disperse things as nicely as other versions.\n    float n = sin(dot(p, vec2(41, 289))); \n    return fract(vec2(8, 1)*262144.*n);\n\n    //p = fract(vec2(8, 1)*262144.*n);\n    //return sin(p*6.283 + iTime)*0.5 + 0.5;\n\n}\n\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(1); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -1; y <= 1; y++){\n\t\tfor(int x = -1; x <= 1; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o);            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n\t\n    return d.y - d.x;\n    // return d.x;\n    // return max(d.y*.91 - d.x*1.1, 0.)/.91;\n    // return sqrt(d.y) - sqrt(d.x); // etc.\n}\n\n// Prerendering a simple stone texture to one of the offscreen buffers. The process is simple, but\n// definitely not simple enough to calculate it on the fly inside a distance function.\n//\n// There is one minor complication, and that is the texture needs to be repeatable. That's its own\n// discussion, but if you're not sure how it's achieved, the key to repeatable Voronoi are the lines \n// \"p = mod(p, 5)\" and \"float c = voronoi(p*5.)... .\" I'm sure you'll figure it out from there. :)\n//\n// The random pixelization business is just a hacky way to redraw the texture when the canvas is resized.\n// Definitely not the best way to go about it, that's for sure.\n//\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Offscreen buffer coordinates.\n    vec2 p = fragCoord.xy/iResolution.xy;\n\n    // On the first frame, render the entire texture. Otherwise, randomly render every 8 pixels,\n    // which, in theory, should lessen the workload. I'm continuously rendering parts of the texture\n    // to account for resizing events. If you resize, the new heighmap will quickly pixel fade in.\n    \n    // Obviously, a better solution would be to detect a resize and render the texture just once, or \n    // better yet, have a fixed size offscreen buffer option... Although, that sounds like a backend \n    // nightmare. :)\n    //if(hash22(p + iTime).x< 1./8. || iFrame==0){\n    if(floor(hash22(p + iTime).x*8.)< 1. || iFrame==0){    \n        \n        // The stone texture. I made this up on the spot. Basically add three second order Voronoi\n        // layers of varying amplitudes and frequency. Also, perturb the initial UV coordinates\n        // to give it more of a natural look. Finally, add some fine detailing via one of Shadertoy's\n        // in-house textures. By the way, you could generate that also, but I didn't want to \n        // overcomplicate a simple example.\n        \n        // Texture value. Reversing the channels for a different color variation.\n        vec3 tx = texture(iChannel1, p).xyz; tx *= tx;\n        tx = smoothstep(0., .5, tx);\n        \n        // Perturbing the UV coordinates just slightly to give the stones a slightly more natural feel.\n        // Note the PI frequencies. That's for texture wrapping purposes.\n        p += sin(p*6.283*2. - cos(p.yx*6.283*4.))*.01;\n        \n        // Three Voronoi layers. Pretty standard. I could have put a lot more effort into this\n        // part, but it's just a simple proof of concept, so just three lazy layers.\n        \n        // More stone looking.\n        //float c = voronoi(p*5.)*.8 + voronoi(p*15.)*.15 + voronoi(p*45.)*.05;\n        \n        // Less detail.\n        float c = voronoi(p*5.) - (1.-voronoi(p*15.))*.08 + voronoi(p*45.)*.04;\n        //float c = (1.-voronoi(p*15.))*.08;\n        \n       \n        //float c = voronoi(p*5.)*.6 + voronoi(p.yx*5. + vec2(2.666, 1.666))*.4 - (1.-voronoi(p*15.))*.08 + voronoi(p*45.)*.04;\n        //float c = voronoi(p*5. - .35)*.6 + voronoi((p.yx + .5)*10.)*.3 + (1.-voronoi(p*25.))*.075 + voronoi(p*60.)*.025;\n \n        \n\n        // Finally, using the greyscale texture value to add some fine detailing.\n        c += dot(tx, vec3(.299, .587, .114))*.05;\n        \n        \n        // Storing away the values for use in the main part of the application.\n        fragColor.xyz = tx; // Put the texture color in the XYZ channels.\n        fragColor.w = min(c/1.1, 1.); // Store the heightmap value in the \"W\" channel.\n\n\n    }\n    // Copy the rest of the pixels over to the new frame. Obvious, but it'd been a while, so I had to \n    // figure that one out. :)\n    else fragColor = texture(iChannel0, p); \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Track mouse movement change between frames and set camera distance and yaw.\n\n#define PI 3.14159\n\nconst float maxCameraZoomDist = 10.;\nconst float minCameraZoomDist = -1.;\nconst vec2 cameraMoveScale = vec2(5.0, 5.0);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)){\n    \n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0).xyzw;\n        vec4 mouse = (iMouse / iResolution.xyxy); \n        vec4 newMouse = vec4(0);\n        \n        float dist = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).x;\n        \n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0){\n            \n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy-oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + cameraMoveScale * mouseMove, mouse.xy);\n        }else{\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        \n         newMouse.x = mod(newMouse.x, 2.0*PI);\n        //newMouse.y = min(0.99, max(-0.99, newMouse.y));\n\n\n        // Store mouse data in the first pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 0.5)){\n            // Set value at first frames\n            if(iFrame < 5){\n                mouse = vec4(1.15, 0.2, 0.0, 0.0);\n            }\n            fragColor = vec4(newMouse);\n        }\n\n        // Store camera distance in the second pixel of Buffer B.\n        if(fragCoord == vec2(0.5, 1.5)){\n            \n            // Set value at first frames\n            if(iFrame < 5){\n                dist = 0.;\n            }\n            else\n            {\n                 // Set camera position from mouse information.\n                 float mouseMove = newMouse.w-newMouse.y;\n                 dist = mouseMove;\n                 \n                 dist = clamp(dist, minCameraZoomDist, maxCameraZoomDist);   \n            }\n        \n             fragColor = vec4(dist, newMouse.x, 0.0, 0.0);\n            \n        }\n        \n         // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)){\n            if(iMouse.z > 0.0){\n            \tfragColor = vec4(vec3(1.0), 1.0);\n            }else{\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n        }\n\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}