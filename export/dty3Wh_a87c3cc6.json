{"ver":"0.1","info":{"id":"dty3Wh","date":"1683924113","viewed":111,"name":"Fast Exhaustive Worley Noise","username":"MartyMcFly","description":"Common Worley searches 3x3, exhaustive search without bugs commonly searches 5x5. However, the results of 3x3 can be achieved with 8 taps, and the results of 5x5 can be achieved with ~9.61 on average.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["worley","cellular","voronoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Worley's cellular noise divides space into N-cubes, places a random point into each cell,\n    the resulting value of the noise is the distance of each point in space to the closest point.    \n    \n    Worley is most commonly implemented as a 3 wide search, i.e. in 2D, the 3x3 neighbourhood\n    around the current cell is searched for the minimal distance.\n    \n    This is however prone to error, as point constellations are possible where the closest point\n    to a given point in the center cell is 2 cells apart.\n    \n    The usual fix for this is to search in a 5x5 neighbourhood but this raises computation cost significantly.\n    \n    common implementation = 9 samples\n    exhaustive search     = 25 samples\n    \n    If we consider the maximum possible distance to the random point in the center cell, this limits \n    necessary search distance. Any cell that is farther away than the farthest sample point in the center cell\n    can be skipped:\n    \n    skip corners in 5x5                       = 21 taps    \n    4x4 depending on quadrant in center cell  = 16 taps\n    4x4 without corners (still exhaustive)    = 12 taps\n    \n    But we can go deeper: The 2-wide cells are only relevant if our evalulation point lies on the outer areas\n    of the center cell. Inside of this boundary, we only need 8 samples - 3x3 without the corner opposite the\n    quadrant we are in. The boundary is not _exactly_ a circle but almost, a conservative boundary that still \n    never misses a point is a circle of radius ~0.438.\n    \n    8 + 4 taps in outer areas                ~= 9.61 taps \n*/\n\n#define OVERVIEW_WITH_FORCED_WORST_CASES 0  //locks random points to cell corners, causes 3x3 errors to increase a lot\n\n\nvec2 hash( vec2 x )\n{\n\tx = vec2( dot(x,vec2(127.1,311.7)),\n\t\t\t  dot(x,vec2(269.5,183.3)));\n\n\tvec2 rand = fract(sin(x)*43758.5453123);    \n#if OVERVIEW_WITH_FORCED_WORST_CASES != 0\n    rand = step(rand, vec2(0.5));  \n#endif\n    return rand;\n}\n\nfloat test_cell(vec2 ip, vec2 fp, vec2 delta)\n{\n    vec2 r = delta - fp + hash(ip + delta);\n    return dot(r, r);\n}\n\n\nfloat worleyorig(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);    \n       \n    float dmin = 100.0f;\n    \n    for(int x = -1; x <= 1; x++)\n    for(int y = -1; y <= 1; y++)\n    {\n        float d = test_cell(ip, fp, vec2(x, y));\n        dmin = min(dmin, d);    \n    }\n    \n    return sqrt(dmin);\n}\n\nfloat worleyexhaustiveopt(vec2 x)\n{\n    vec2 ip = floor(x);\n    vec2 fp = fract(x);    \n       \n    float dmin = 100.0f;    \n    \n    //we search in a 4x4 pattern excluding corners\n    //shifted based on in which quadrant of the center tile we are   \n    vec2 shift = step(0.5, fp);\n    \n    vec4 dx = vec4(-1.0, 0.0, 1.0, 2.0);\n    vec4 dy = vec4(-1.0, 0.0, 1.0, 2.0);    \n    dx = fp.x < 0.5 ? -dx : dx;\n    dy = fp.y < 0.5 ? -dy : dy;    \n    float r = length(fp - 0.5);   \n    \n    //8 corners we need almost always\n    //3x3 minus the corner opposite of the quadrant we are in\n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.z, dy.z)));   \n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.z, dy.y)));   \n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.z, dy.x)));         \n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.y, dy.z)));   \n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.y, dy.y)));   \n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.y, dy.x)));  \n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.x, dy.z)));   \n    dmin = min(dmin, test_cell(ip, fp, vec2(dx.x, dy.y))); \n    \n    //auxiliary 4 taps we need only if we are in the outskirts\n    //the area where we don't need them is not _exactly_ a circle, \n    //it'a bit bigger even but this is a conservative and fast method    \n    if(r > 0.436)\n    {    \n        dmin = min(dmin, test_cell(ip, fp, vec2(dx.w, dy.z)));   \n        dmin = min(dmin, test_cell(ip, fp, vec2(dx.w, dy.y)));   \n        dmin = min(dmin, test_cell(ip, fp, vec2(dx.z, dy.w))); \n        dmin = min(dmin, test_cell(ip, fp, vec2(dx.y, dy.w)));\n    }   \n\n    return sqrt(dmin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 tuv = fragCoord / iResolution.xy;\n    vec2 uv = fragCoord/iResolution.x * 4.0f + vec2(49.0f, 46.5f);   \n#if OVERVIEW_WITH_FORCED_WORST_CASES != 0\n    uv *= -8.0f;\n#endif    \n    float orig = worleyorig(uv);\n    float opt = worleyexhaustiveopt(uv);   \n\n    \n    fragColor = vec4(tuv.x > iMouse.x / iResolution.x ? opt : orig)*0.85;  \n    //fragColor *= fragColor;\n    float error = min(1.0f, 10.0f* abs(orig-opt)); \n    error *= pow(sin(iTime*2.0f)*0.5+0.5, 4.0);\n    \n    fragColor.yz -= error;    \n    \n    float dx = abs(fragCoord.x - iMouse.x);\n    dx /= 1.0 + abs(dFdx(dx));\n    \n    fragColor *= vec4(step(1.0, dx));  \n    \n}","name":"Image","description":"","type":"image"}]}