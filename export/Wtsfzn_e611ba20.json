{"ver":"0.1","info":{"id":"Wtsfzn","date":"1595859040","viewed":247,"name":"Glowy shapes :)","username":"makio135","description":"Based on resources from iq, mercury hg_SDF and evvvil üôèüôèüôè","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define u_resolution iResolution\n#define u_time iTime*.2\n\n\n// Antialiasing: number of samples in x and y dimensions\n#define AA 3\n\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n\nfloat sdOctahedron(in vec3 p, in float s) {\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n    vec3 q;\n    if(3.0 * p.x < m) q = p.xyz;\n    else if(3.0 * p.y < m) q = p.yzx;\n        else if(3.0 * p.z < m) q = p.zxy;\n            else return m * 0.57735027;\n\n            float k = clamp(0.5 * (q.z - q.y + s), 0.0, s); \n        return length(vec3(q.x, q.y - s + k, q.z - k)); \n}\nfloat sdTorus(vec3 p, vec2 t){\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n        + min(max(d.x, max(d.y, d.z)), 0.0); // remove this line for an only partially signed sdf \n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\n// subtract d1 from d2\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\n// from https://www.alanzucconi.com/2016/07/01/signed-distance-functions/#part4\nfloat opBlend(float sdf1, float sdf2, float amount) {\n    return amount * sdf1 + (1. - amount) * sdf2;\n}\n\nfloat linearstep(float begin, float end, float t) {\n    return clamp((t - begin) / (end - begin), 0.0, 1.0);\n}\n\nvec3 GDFVectors[19];\nvoid initGDFVectors() {\n    GDFVectors[0] = normalize(vec3(1, 0, 0));\n    GDFVectors[1] = normalize(vec3(0, 1, 0));\n    GDFVectors[2] = normalize(vec3(0, 0, 1));\n\n    GDFVectors[3] = normalize(vec3(1, 1, 1 ));\n    GDFVectors[4] = normalize(vec3(-1, 1, 1));\n    GDFVectors[5] = normalize(vec3(1, -1, 1));\n    GDFVectors[6] = normalize(vec3(1, 1, -1));\n\n    GDFVectors[7] = normalize(vec3(0., 1., PHI+1.));\n    GDFVectors[8] = normalize(vec3(0., -1., PHI+1.));\n    GDFVectors[9] = normalize(vec3(PHI+1., 0., 1.));\n    GDFVectors[10] = normalize(vec3(-PHI-1., 0., 1.));\n    GDFVectors[11] = normalize(vec3(1., PHI+1., 0.));\n    GDFVectors[12] = normalize(vec3(-1., PHI+1., 0.));\n\n    GDFVectors[13] = normalize(vec3(0., PHI, 1.));\n    GDFVectors[14] = normalize(vec3(0., -PHI, 1.));\n    GDFVectors[15] = normalize(vec3(1., 0., PHI));\n    GDFVectors[16] = normalize(vec3(-1., 0., PHI));\n    GDFVectors[17] = normalize(vec3(PHI, 1., 0.));\n    GDFVectors[18] = normalize(vec3(-PHI, 1., 0.));\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n    float d = 0.;\n    for (int i = 13; i <= 18; ++i) d = max(d, abs(dot(p, GDFVectors[i])));\n    return d - r;\n}\n\nfloat glow = 0.;\nvec2 sceneSDF(vec3 p) {\n    p *= rotate3D((u_time + .3) * TAU, vec3(-1., 1.5, .2));\n\n    initGDFVectors();\n\n    float t = mod(u_time * 3., 3.);\n    float a = sdOctahedron(p, 1.5);\n    float b = sdTorus(p * rotate3D(PI/4., vec3(1, 1, 0)), vec2(1.1, .4));\n    float c = fDodecahedron(p * rotate3D(PI/2., vec3(1, 0 , 0)), 1.);\n    float d = opBlend(\n        opBlend(\n            opBlend(\n                a, \n                b, \n                linearstep(2., 2.3, t)\n            ), \n            c, \n            linearstep(1., 1.3, t)\n        ), \n        a, \n        linearstep(0., .3, t)\n    );\n\n    float d2 = 999.;\n    for(float i = -1.; i <= 1.; i+= .1) {\n        d2 = opUnion(d2, sdBox(p + vec3(0., (i - fract(t) * .2) * 3., 0.), vec3(2., .01, 2.)));\n    }\n\n    float d3 = d + .02;\n\n    d2 = opSubtraction(d - .1, opIntersection(d, d2));\n    glow += (0.005 / (0.004 + d2 * d2 * 50.)) * 1.5; \n\n    return vec2(d2, 1.);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    #if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n    #endif\n\n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = sceneSDF(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNormal(in vec3 pos) {\n    // epsilon = a small number\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy).x + \n        e.yyx * sceneSDF(pos + e.yyx).x + \n        e.yxy * sceneSDF(pos + e.yxy).x + \n        e.xxx * sceneSDF(pos + e.xxx).x\n    );\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = sceneSDF(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n    return calcNormal(pos);\n}\n\n// https://iquilezles.org/articles/palettes\nvec3 palette(float t){ \n    return vec3(0.50,0.50,0.50) + vec3(0.50,0.50,0.50) * cos(2. * 3.141592653589793 * (vec3(1.00,1.00,1.00) * t + vec3(0.00,0.33,0.67)));\n}\n\nvec3 render(in vec3 ro, in vec3 rd) { \n    // cast ray to nearest object\n    vec2 res = castRay(ro, rd);\n    float distance = res.x; // distance\n    float materialID = res.y; // material ID\n\n    vec3 col = vec3(0.6 - length((gl_FragCoord.xy - u_resolution.xy / 2.) / u_resolution.x));;\n        if(materialID > 0.0) {\n            vec3 pos = ro + distance * rd;\n            col = computeColor(ro, rd, pos, distance, materialID);\n        }\n    // col += glow * vec3(0.9, 0.9, 0.1);\n    col += glow * palette(u_time);\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Ray Origin)\\t\n    vec3 ro = vec3(0., 0., 3.6);\n    vec3 ta = vec3(0.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 color = vec3(0.0);\n\n    #if AA>1\n    for(int m = 0; m < AA; m++)\n        for(int n = 0; n < AA; n++) {\n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n            #else\n            vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n            #endif\n\n            // ray direction\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n            // render\\t\n            vec3 col = render(ro, rd);\n\n            color += col;\n            #if AA>1\n        }\n    color /= float(AA*AA);\n    #endif\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}