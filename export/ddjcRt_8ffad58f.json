{"ver":"0.1","info":{"id":"ddjcRt","date":"1688062517","viewed":41,"name":"Red wool","username":"Oxys","description":"What was once an hexagon grid has somehow turned into this.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["grid","hexagon","red"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 centerImage(vec2 uv){\n    uv=(uv*2.-iResolution.xy)/min(iResolution.x, iResolution.y);\n    return uv;\n}\n\nfloat calcHexDistance(vec2 p, float radius){\n     const vec2 s = vec2(1, sqrt(3.));\n     p = abs(p);\n     return max(dot(p, s * .5), p.x) - radius;\n}\n\n#define ratio sqrt(3./2.)/2.\n\nvec2 distanceGrid1(vec2 uv, float radius) {\n    float nearest_x = 2. * radius * floor(uv.x / (2. * radius) + .5);\n    float nearest_y = 3. * radius * ratio * floor(uv.y / (3. * radius * ratio) + .5);\n    vec2 nearest = vec2(nearest_x, nearest_y);\n    return nearest;\n}\n\nvec2 distanceGrid2(vec2 uv, float radius) {\n    float nearest_x = 2. * radius * floor(uv.x / (2. * radius)) + radius;\n    float nearest_y = 3. * radius * ratio * floor(uv.y / (3. * radius * ratio)) + 1.5 * ratio;\n    vec2 nearest = vec2(nearest_x, nearest_y);\n    return nearest;\n}\n\nvec2 nearestCenter(vec2 uv, float radius) {\n    vec2 c1 = distanceGrid1(uv, radius);\n    vec2 c2 = distanceGrid2(uv, radius);\n    float d1 = distance(c1, uv);\n    float d2 = distance(c2, uv);\n    return d1 < d2 ? c1 : c2;\n}\n\nvoid mainImage0(out vec4 fragColor,in vec2 fragCoord)\n{\n    vec2 uv = centerImage(fragCoord) + 0.2 * vec2(iTime, 0.5 * iTime);\n\n    float radius = 1.0;\n\n    uv *= 5.;\n\n    vec2 nearest = nearestCenter(uv, radius);\n    uv -= nearest;\n    float d = calcHexDistance(uv, radius);\n\n    fragColor=vec4(d, 0., 0., 1.);\n}\n\n// Auto antialiasing by GregRostami & FabriceNeyret2\n// Check out https://www.shadertoy.com/view/wtBBW3 (Same code but easier to read)\n// Usage: paste this bit of code at the end of any shader, change the AA value,\n//       the higher the AA value, the longer it takes to render.\n//       AA = 1 is no antialiasing, AA = 2 is 2x2, AA = 3 is 3x3, etc.\n\n#define AA 8\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {                \n    vec4 T;\n    fragColor = vec4(0.);\n    float x, y, d = 1./float (AA);\n    for (x = 0.; x < 1.; x += d) {\n        for (y = 0.; y < 1.; y += d) {\n            mainImage0( T, fragCoord + vec2(x,y));\n            fragColor += min(abs(T), 1.);\n        }\n    }\n    fragColor *= d*d;\n}\n","name":"Image","description":"","type":"image"}]}