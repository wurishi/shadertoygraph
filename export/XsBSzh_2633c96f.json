{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"float hash( float n ) { return fract(sin(n)*43758.5453123); }\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123));\n}\n\nvec3 hash3( float n )\n{\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 mushroom(in vec3 p)\n{\n    vec2 cap = vec2(opS(sdSphere((p-vec3(0.,.2,0.))*vec3(1.20, 1.3, 1.20), .75),sdBox(p+vec3(0.,1.,0.), vec3(1.)))   , 1.);\n    vec2 stock = vec2(sdCylinder(p, vec2(.2+(1./exp(p.y*2.3))*.03, .65)), 2.);\n    return opU(cap,stock);\n}\n\nvec2 map(in vec3 p)\n{\n    vec3 q = p;\n    return opU(vec2(sdBox(p, vec3(2., .01, 2.)), 0.), mushroom(q-vec3(0.,.65,0.)));\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.0001;\n    float h=precis*2.0;\n    float t = 0.0;\n    float m = -1.0;\n    for( int i=0; i<130; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\n        t += h;\n        vec3 p = ro+rd*t;\n\t    vec2 res = map( p );\n        h = res.x;\n\t    m = res.y;\n    }\n\n    if( t>maxd ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 surfcol(in float id, in vec3 p)\n{\n    if(id == 0.) return (vec3(.3, .2, .05)+vec3(noise(p*20.)*.06))*.8;\n    if(id == 1.) \n    {\n        vec3 q = opRep(p+vec3(noise(p)*.2), vec3(.4));\n        float r = sdSphere(q, .01);\n        return r < .1 ? vec3(.935, .92, .93)*.8 : vec3(.9, .1, .05)*.8;\n    }\n    if(id == 2.) return vec3(.8, .8, .5)*.8;\n    return vec3(1.);\n}\n\nvec3 cosdir( const vec3 n ) {\n\tvec3  uu = normalize( cross( n, vec3(0.0,1.0,1.0) ) );\n\tvec3  vv = normalize( cross( uu, n ) );\n\tvec2 rv2 = hash2(n.x);\n\tfloat ra = sqrt(rv2.y);\n\tfloat rx = ra*cos(6.2831*rv2.x); \n\tfloat ry = ra*sin(6.2831*rv2.x);\n\tfloat rz = sqrt( 1.0-rv2.y );\n\tvec3  rr = vec3( rx*uu + ry*vv + rz*n );\n\n    return normalize( rr );\n}\n\nvec3 background(vec3 rd) { return texture(iChannel0, rd).xyz; }\nfloat shadow(in vec3 p, in vec3 rd) { return castRay(p+rd*.001, rd, 1000.).y >= 0. ? 0. : 1.; }\nvec3 lighting(in vec3 p, in vec3 n)\n{\n    vec3 c = vec3(0.);\n    {\n        vec3 pt = cosdir(n) * 1000.;\n        vec3 lr = normalize(pt - p);\n        c += texture(iChannel1, lr).xyz * shadow(p, lr);\n    }\n    return c;\n}\n\nvec3 brdf_ray(in vec3 p, in vec3 n, in vec3 rd, in float id)\n{\n    return cosdir(n);\n}\n#define HAX\nvec3 render(vec3 ro, vec3 rd)\n{\n    #ifdef HAX\n    vec2 r = castRay(ro, rd, 1000.);\n    if(r.y >= 0.)\n    {\n        vec3 l = normalize(vec3(1., .5, 0.));\n        vec3 p = ro+rd*r.x;\n        vec3 n = calcNormal(p);\n        vec3 sc = surfcol(r.y, p);\n        float sh = 1.;\n        if(castRay(p+l*.01, l, 100.).y >= 0.) sh = 0.;\n        vec3 c = (sc*dot(n,l)*sh)+(sc*.2)*calcAO(p, n);\n        return c;\n    }\n    else { return texture(iChannel0, rd).xyz; }\n    #else\n    vec3 fcol = vec3(1.);\n    vec3 tcol = vec3(0.);\n    for(int i = 0; i < 10; ++i)\n    {\n        vec2 r = castRay(ro, rd, 1000.);\n        if(r.y < 0.)\n        {\n            if(i == 0) fcol = background(rd);\n            else break;\n        }\n        vec3 pos = ro + rd*r.x;\n        vec3 nor = calcNormal(pos);\n        vec3 scol = surfcol(r.y, pos);\n        vec3 dcol = lighting(pos, nor);\n        ro = pos;\n        rd = brdf_ray(pos, nor, rd, r.y);\n        \n        fcol *= scol;\n        tcol += fcol*dcol;\n    }\n    return tcol;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 2.0 + 10.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( 0. );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    \n    vec3 col = vec3(0.);\n    for(int i = 0; i < 10; ++i)\n    {\n        vec2 sp = p + hash2(float(i))*.005;\n\t\tvec3 rd = normalize( sp.x*cu + sp.y*cv + 2.5*cw );\n    \tcol += render( ro, rd );\n    }\n    col /= 10.;\n    col = sqrt(col);\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsBSzh","date":"1408631921","viewed":2020,"name":"Forest Mushroom","username":"squid","description":"Raymarched mushroom, simple lighting and textures so far. Most fascinating part is probably where I change the radius of the cylinder based on the current y position and a exp function. Undef HAX to see my broken path tracer, which badly needs help","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarch","mushrooms"],"hasliked":0,"parentid":"","parentname":""}}