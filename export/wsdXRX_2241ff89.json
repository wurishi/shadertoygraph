{"ver":"0.1","info":{"id":"wsdXRX","date":"1572534137","viewed":121,"name":"Mi first fractal :D","username":"rueton","description":"Mi primer fractal, \nThanks to FabriceNeyret2 for help :D","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Attemping to add the possibility to navegate across the fractal with the keys.\n\nint resolution_factor = 5000; //English:increase this number to  10000 get better resolution, take care of low fps.\n\t\t\t\t\t\t\t//Spanish: aumentar las iteraciones para mayor eficiencia, cuidado que realentiza el pc\n\nvec2 multi(vec2 z){\n    //multiply complex numbers,z =  x+iy, is written as vec2\n\treturn(vec2(z.x*z.x  - z.y * z.y , 2.*z.x *z.y));\n       }\nfloat fractal(vec2 c, float tolerance ){ \n    //Spanish:realiza las iteraciones del conjunto de maldebrot y devuleve 0 o 1 si la serie converge o no.\n    //English:It computes the mandelbrot set and results a 0 or 1 depending the convergence of the sucesion.\n vec2 z = vec2(0,0);\n  \n    for( int i = 0; i<resolution_factor; i++){ \n        z = multi(z) + c;\n    }\n    \n    if(abs(z.x)<(2. + tolerance)){\n    return 1.;\n        }else{\n        return 0.;}\n} //Joseph is the best jojo.\n       \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y * vec2( 1./(0.005* pow(iTime ,2.)))+vec2(0.4 );\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //Spanish:multiplico por el cÃ¡lculo de pertenencia\n    // english: multiply color to fractal result in this pixel.\n    fragColor = vec4(col*fractal(uv,1.),1.0);\n}","name":"Image","description":"","type":"image"}]}