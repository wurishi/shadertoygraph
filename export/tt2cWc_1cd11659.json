{"ver":"0.1","info":{"id":"tt2cWc","date":"1706648675","viewed":170,"name":"Pillars Glow Scene","username":"spalmer","description":"trying to replicate a scene by blackle but idk what got into me, decided to try to simplify it even more by refactoring what I can.\nTHEN I decided I better learn some damn Calculus if I hope to follow along!","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["reflection","raymarch","domainrepetition","blob","glow","gaussian","pillars","hardshadows","pathintegral","simplescene","turbulencetexture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://shadertoy.com/view/tt2cWc\n// variant of (still private?!  doh) Nano Camera at http://shadertoy.com/view/WtjcDm\n// few things from Fly Camera at http://shadertoy.com/view/tdsfR4\n\n// inspired by blackle's Gaussian Distributed Fog http://shadertoy.com/view/WtByzV\n// which is only 3000 characters yet has texture, soft shadows,\n// specular lighting, reflections, and the gaussian glow.\n\n// The goal was originally making a nice looking skeleton\n// raymarch toy, and golfing that, comparing to blackle's toy.\n\n// Then I realized I didn't know wtf I was even doing with the glow ball.\n\n// I had some hacks that kind of worked ok-ish, but apparently\n// didn't know how to compute the gaussian blob integral.\n// So I went to trying to learn, in my typical fashion.\n// If you want to watch an old fart teach himself \n// fundamental vector calculus, over the span of,\n// what has it been now, several years?!  proceed to read along.\n// Like I told Ford, I should have stayed in college!\n\n// or you can skip straight to gaussSpalmer.\n\n// the golfing part will have to continue in another fork.  I'm 1000+ch over rn!  probably all the #if 0\n\n// hey maybe I can finally get my line integral fog noise working now!\n\nconst float pi = acos(-1.);\n\nfloat erf(float x) \n{\n  #if 0\n    // Abramowitz and Stegun 1964 http://wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\n    // max error: 5×10−4    Horner reduced by spalmer\n    float y = x, \n        b = (((.078108 * x + .000972) * x + .230389) * x + .278393) * x + 1.;\n    b *= b;\n    return sign(y) * (1. - 1. / (b * b));\n  #elif 0\n    // turns out this error function approximation is actually \n    // *my* exp2 suggestion from comment at http://shadertoy.com/view/7sKSRh\n    // oneshade been using it all over!  it's based on oneshade's original exp erf,\n    // I can't recall if I improved it, or just converted it to base 2.\n    return sign(x) * sqrt(1. - exp2(-1.787776 * x * x));\n    // missing a 2/sqrt(pi) factor mentioned on Wikipedia\n    // but is VERY close to true value at 1.0;\n    // I'd really like to get rid of that sqrt if possible! see below\n  #elif 0\n    // this archived paper discusses obtaining exp-based approximation of erf that was likely based on:\n    // http://web.archive.org/web/20100601094000/http://homepages.physik.uni-muenchen.de/~Winitzki/erf-approx.pdf\n    // Winitzki, 2008\n    float xx = x * x, axx = .147 * xx;\n    return sign(x) * sqrt(1. - exp(-xx * (4. / pi + axx) / (1. + axx)));\n  #elif 0\n    // FordPerfect's tanh complex erf, converted to real\n    return tanh((.099792702 * x * x + 1.129675826) * x);\n    // tanh is erf-ish enough for practical purposes\n  #elif 0\n    // FordPerfect's smoother quintic approximation for error function\n    x = clamp(x, -1.8, 1.8);\n    return ((.019846 * (x * x) - .21433) * (x * x) + 1.0417) * x;\n  #elif 0\n    // blackle's 'silly' smoothstep² approximation for error function, slightly tweaked\n    return smoothstep(0., 1., smoothstep(-2.13, 2.13, x)) * 2. - 1.;\n    // That's just some 9th order polynomial? fairly cheap to compute.\n    // easier to graph as this polynomial Ford pointed out and I Horner reduced:\n    // ((((.00006925698581901403 * (x * x) - .002827908170660563) * (x * x) + .03848980973840971) * (x * x) - .2522352701587202) * x * x + 1.056338028169014) * x\n  #elif 0\n    // rational erf approx by FordPerfect in comment\n    x = clamp(x, -3., 3.);\n    return 1.13072 * x / ((-.01014 * (x * x) + .357055) * (x * x) + 1.);\n  #elif 0\n    // FordPerfect's smoothstep approximation for error function - fast and cheap\n    return smoothstep(-1.5059, 1.5059, x) * 2. - 1.;\n  #else\n    // I just threw this together:  decent >= 1, slope doesn't match erf at x=0 though.\n    // but it's quite cheap, if exp2 is cheap anyway.  Got rid of that pesky sqrt!\n    float s = sign(x); x = abs(x);\t// thanks @Ford for the sign fix.\n    return s * (1. - exp2(-1.22 * x * (1.2 + x))); //(1. - exp2(-1.33 * x * (1. + x))); //\n  #endif\n}\n\n// considering it's just used for an integration, by subtracting erf from erf,\n// it seems overkill to involve transcendentals and such\n// when blackle's double-smoothstep works just as well.\n\n// Wolfram Alpha uses Gamma to compute erf, and says erf(1.0) = .84270079\n// oneshade's/mine is .8428, Ford's is .8424, blackle's is .8398\n// I think I may have put effort into making mine match this, possibly\n// at expense of overall precision.\n\n// I honestly cannot tell the difference between any of the above approximations, in this toy.\n\n\n// so FordPerfect helped me figure out how to use Maxima better;\n// here's his example of how to get Maxima to give us the answer:\n/*\n(%i1)\td:[d_x, d_y, d_z];\n(d)\t[d_x,d_y,d_z]\n(%i2)\te:[e_x, e_y, e_z];\n(e)\t[e_x,e_y,e_z]\n(%i3)\tintegrate(exp(-((d*t+e).(d*t+e))),t);\n(%o3)\t(sqrt(%pi)*%e^((2*d_z*e_z+2*d_y*e_y+2*d_x*e_x)^2/(4*(d_z^2+d_y^2+d_x^2))-e_z^2-e_y^2-e_x^2)*erf(sqrt(d_z^2+d_y^2+d_x^2)*t+(2*d_z*e_z+2*d_y*e_y+2*d_x*e_x)/(2*sqrt(d_z^2+d_y^2+d_x^2))))/(2*sqrt(d_z^2+d_y^2+d_x^2))\n*/\n// I could swear I had tried that very thing, before!\n// that's pretty typical maxima spew; seems like something I can work with, though!  Finally!\n// %o3 formats to:\n/*\n(sqrt(%pi) * \n    %e^(\n        (2*d_z*e_z+2*d_y*e_y+2*d_x*e_x)^2\n            /\n        (4*(d_z^2+d_y^2+d_x^2))\n        -e_z^2-e_y^2-e_x^2\n        )\n    *\n    erf(\n            sqrt(d_z^2+d_y^2+d_x^2)*t +\n                  (2*d_z*e_z+2*d_y*e_y+2*d_x*e_x)\n                /\n                  (2*sqrt(d_z^2+d_y^2+d_x^2))\n                )\n       )\n/\n                  (2*sqrt(d_z^2+d_y^2+d_x^2))\n*/\n// I'll chew on that.  there's obviously a few common factors, and some things devolve to dot products.\n// with a bit of wrangling I can probably make that look like gaussSpalmer\n\n/*\n// perhaps FordPerfect can help me figure this out finally!\n// http://shadertoy.com/view/lcBXDW\n// Public Domain under http://unlicense.org, see link for details.\n\n// ∫ exp(-(t-T)²/R²) dt on [L; H]\nfloat I(float P, float Q, float R, float L, float H)\n{\n    float X = .5 * Q / P;\n    float Fl = erf(P * L + X); // oh, I lost the + X term here.  restored!\n    float Fh = erf(P * H + X);\n    return .5 * sqrt(pi) / P * exp(X * X - R) * (Fh - Fl);\n}\n\n// Integrate blob's field along the\n// ray t * rd + ro, on [L, H].\n// has b_M scale argument preserved.\nfloat BlobI(vec3 ro, vec3 rd, float b_M, float L, float H)\n{\n    rd *= sqrt(b_M);\n    ro *= sqrt(b_M);\n    return I(\n        length(rd),\n        2. * dot(ro, rd), //dot(ro, rd) + dot(rd, ro), // becomes 2*X in I fn\n        dot(ro, ro), // becomes R in I fn\n        L, H);\n}\n\nfloat gaussFordPerfect(vec3 ro, vec3 rd, float t)\n{\n    return 3. * BlobI(ro, rd, 32., 0., t);\n}\n*/\n\n/*\n// more FordPerfect but rearranged so it matches the other one a little more perhaps\n// like, where the hell is the antiderivative part, even?!  there should be a\n// subtraction of antiderivatives, it has been optimized away by F.P. somehow!\n// ah, it's just the erf.  The antiderivative is simply erf.  maybe times some constant factor.\n\n// seems like in this toy, P will always be 1.0 since rd is a unit vector\n// except that we put b_M into there!  let's try to put into t instead\n// ∫ e^-(dot(t * rd + ro, t * rd + ro)) on [L; H]\nfloat gaussFordPerfectB(vec3 ro, vec3 rd, float t)\n{\n    float s = 32.,\n        Q = sqrt(s) * dot(ro, rd),\n        R = s * dot(ro, ro),\n        L = 0.,  \n        H = sqrt(s) * t;\n    return 3. * .125 * sqrt(pi) * exp(Q * Q - R) *\n        (erf(H + Q) - erf(L + Q));\n}\n// totally different way than blackle.\n// OR IS IT?!\n*/\n\n/*\nfloat gaussFordPerfectC(vec3 o, vec3 d, float t)\n{\n    float s = 32.;\n    float\n        od = sqrt(s) * dot(o, d),\n        oo = dot(o, o);\n    t *= sqrt(s);\n    return 3. * .125 * sqrt(pi) * exp(od * od - s * oo) *\n        (erf(od + t) - erf(od));\n}\n*/\n\n/*\n(%i4)\tintegrate(exp(-s*((d*t+e).(d*t+e))),t);\n(%o4)\t(sqrt(%pi)*%e^((2*d_z*e_z*s+2*d_y*e_y*s+2*d_x*e_x*s)^2/(4*(d_z^2*s+d_y^2*s+d_x^2*s))-e_z^2*s-e_y^2*s-e_x^2*s)*erf(sqrt(d_z^2+d_y^2+d_x^2)*sqrt(s)*t+(2*d_z*e_z*s+2*d_y*e_y*s+2*d_x*e_x*s)/(2*sqrt(d_z^2+d_y^2+d_x^2)*sqrt(s))))/(2*sqrt(d_z^2+d_y^2+d_x^2)*sqrt(s))\n*/\n\n// spalmer 1/30/2024 extracted common uniform scaled gaussian spherical blob\n// functionality with exposed blob scale argument\n// compute ∫(x, 0, t) e^-(x * d + o)²\n// with an extra scale factor s must sort out the details of\n// it probably goes on e^-(s(x * d + o)²) or like e^-((x * d + o)² / s)\nfloat gaussSpalmer(vec3 o, vec3 d, float t, float s)\n{\n    s = 1. / s; // convert blob size arg to FordPerfect style m scale\n    float od = sqrt(s) * dot(o, d);\n    t *= sqrt(s);\n    return .5 * sqrt(pi) * exp(od * od - s * dot(o, o)) *\n        (erf(od + t) - erf(od));\n}\n// like I want the s factor to be the normal distribution of the gaussian.\n// effectively it's 'size'.\n// there might be a wee bit of optimizing left to do in there.\n// so it fits into the test and matches the other examples:\nfloat gaussSpalmerShim(vec3 o, vec3 d, float t)\n{\n    return .75 * gaussSpalmer(o, d, t, .03125); //1./32.);\n}\n\n/*\n// distilled from blackle http://shadertoy.com/view/WtByzV\nfloat gaussblackle2(vec3 o, vec3 d, float t)\n{\n    o *= sqrt(32.); t *= sqrt(32.);\n    float od = dot(o, d);\n    return 1./3.33 * sqrt(pi) * exp(od * od - dot(o, o)) * \n        (erf(od + t) - erf(od));\n}\n*/\n// I might finally be getting close to understanding how blackle obtained this!\n/*\n// argh, just stole blackle's for now to compare at least, see something that works :)\n// http://shadertoy.com/view/WtByzV\n// idk how the tuning relates, I have 'em tuned similarly now\nfloat adblackle(vec3 o, vec3 d, float t)\n{\n    // antiderivative for exp(-dot(o+d*t, o+d*t))\n    float od = dot(o, d);\n    return sqrt(pi) * exp(od * od - dot(o, o)) * erf(od + t);\n}\n\nfloat gaussblackle(vec3 ro, vec3 rd, float t)\n{\n    ro *= sqrt(32.); t *= sqrt(32.);\n    return 1./3.33 * (adblackle(ro, rd, t) - adblackle(ro, rd, 0.));\n}\n*/\n\n/*\n// so it seemed Maxima may be hitting a wall on the multidimensional integral (no, I'm just a poor user)\n// so I coerced WolframAlpha into doing an indefinite integral for me:\n// integral e^(-({x u + p, x v + q})^2) dx\n// =\n// {(sqrt(π) erf(p + u x))/(2 u), (sqrt(π) erf(q + v x))/(2 v)} + constant\n// now to translate that back to glsl!\n// but.. hold on, that's just partial antiderivatives, I wanted the full antiderivative!\n// am I an idiot?\n//{(sqrt(π) erf(p + u x))/(2 u), \n// (sqrt(π) erf(q + v x))/(2 v)}\n// = \n//(sqrt(π) / 2) * {\n//   erf(p + u x) / u, \n//   erf(q + v x) / v\n//}\n\nfloat adWolfram(vec3 o, vec3 d, float t)\n{\n    // antiderivative for exp(-(o+d*t)²)\n    float od = dot(o, d);\n    return .5 * sqrt(pi) * dot(1. / d,\n        vec3(erf(t * d.x + o.x), erf(t * d.y + o.y), erf(t * d.z + o.z)));\n}\n// FIXME it seems like we should need only one erf here anyway\n\nfloat gaussWolframFail(vec3 ro, vec3 rd, float t)\n{\n    ro *= sqrt(32.); t *= sqrt(32.); // assuming rd is unit vector and passing it through somehow\n    return 1. / 333.33 * (adWolfram(ro, rd, t) - adWolfram(ro, rd, 0.));\n}\n// nevermind, this is just some per-axis b.s. like I was coming up with\n*/\n\n\n/*\n// I started working on the glow ball integration finally\n// telling Maxima to integrate this, \n// after having failed at integrating\n// the full 3D equation several times\n// (%i1) integrate(e^-(x*x), x);\n// (%o1) (sqrt(%pi)*erf(sqrt(log(e))*x))/(2*sqrt(log(e)))\n// look at Maxima being a joker with sqrt(log(e)) == 1  harhar\n// simplifies to   sqrt(%pi) / 2 * erf(x)\n// aha! So that's where blackle\n// got the root of pi factor\n// and the erf business.  Gotcha.\n// log(e) means ln(e) which equals 1.0\n// so it's really saying sqrt(pi)/2 * erf(x)\n// where erf is presumably something that handles the infinity\n// blackle uses a smoothstep there\n// aha! ok, apparently erf is actually a thing\n// called the Gaussian Error Function\n// http://.wikipedia.org/wiki/Error_function\n// which is like a signed infinite-order smoothstep\n// apparently this is a primitive normal distribution\n// http://wikipedia.org/wiki/Normal_distribution\n// these things turn up everywhere, in probability\n// and statistical problems, apparently.\n// In this case, even simpler, as we don't normalize\n// the PDF to summed area 1.0, \n// and discard the .5 factor on the exponent,\n// so it's not *quite* the same bell curve.\n// anyway that still only integrated the infinite line\n// down the center of the gaussian blob!\n// still must breakdown the blob itself\n// and consider the partial ray (definite integration)\n// the 3D trace can, similar to a cone,\n// be broken down into scalar components.\n// in fact a sphere vs ray would break down similarly\n// into dot(ro,ro) and dot(rd,ro) components\n// can then be mapped onto a 2d view of the situation\n// which is symmetric about the origin\n// this also means it's symmetric hemispherically\n// or planar in any given direction\n// result depends only on these dot products' results\n// so winds up being a 2d trace problem\n// which seems solvable\n// basically any point on the ray maps to some\n// x on the graph of e^-(x*x)\n// then we're just integrating\n// those from a to b\n// so then proceed to this:\n// (%i2) integrate(e^-(x*x), x, a, b);\n// (%o2) (sqrt(%pi)*erf(b*sqrt(log(e))))/(2*sqrt(log(e)))\n//     - (sqrt(%pi)*erf(a*sqrt(log(e))))/(2*sqrt(log(e)))\n// ok, so that's just antiderivative at b - antiderivative at a\n// pretty standard calculus, from what I'm getting.\n// Apparently this is just basic line integral calculus.\n// or what's known as \"definite integration\"\n// ok, so there it is, same thing blackle got,\n// just turn it back into code!  ;)\n// ok actually it's not quite the same yet.\n// definitely some devils in those details.\n// but I can see some light at the end of the tunnel!\n\n// simplify a little, may as well have Maxima do it:\n// (%i3) ratsimp(%)\n// (%o3) (sqrt(%pi) * (erf(b*sqrt(log(e)))-erf(a*sqrt(log(e))))) / (2*sqrt(log(e)))\n// but this actually still simplifies a lot:\n//\t\tsqrt(%pi) / 2 * (erf(b) - erf(a))\n// wow.\n// ok, so then all we need is to obtain a and b.\n// situation is radially symmetric as I said, so\n// imagine the trace ray being mapped onto the \n// y = 0 plane intersecting the origin\n// take the ray start ro, consider it as a point a\n// on the x axis at y = 0, x = dot(ro, ro) or something\n// then the trace is just a line\n// if our query were directed straight at the blob center\n// (the origin) then we'd be done already,\n// but must handle the case where ray and origin aren't aligned\n// in these cases, the falloff is shaped much like the other\n// but is multiplied at every point by the\n// gaussian along the y axis at that point\n// so I guess you'd wind up multiplying\n// the integrals of the x and y cases\n// of the \"2D\" view of the 3D trace,\n// the along-axis and off-axis portions.\n// or multiply the whole 1D trace\n// by the e^-(x*x) of the closest distance\n// the infinite trace gets to the origin\n// because that's the maximum point on the bump from there.\n// well it makes sense to me!  ;)\n\n// did some experimenting:\n    //c = vec3(exp(-16.*dot(q.xy,q.xy))); // what we're trying to trace through, in 2D\n    //c = vec3(exp(-16.*q.x*q.x)*exp(-16.*q.y*q.y)); // but this is the same thing!  :)\n    // aha so it *does* factor out, excellent!\n    // so the coords can either be summed prior to exp\n    // or producted after exp, either way.\n    // That's really good to know!  ;)\n// so really we can just multiply\n// the individual integrations for each axis,\n// which is simple enough, but apparently\n// if one factors the situation into 2d\n// like I said, we should be able to\n// do *that* in 2 axes independently,\n// but may also be able to reduce even further\n// to a simply modification of the 1d problem, idk.\n\n// antiderivative of our exponential in one axis, according to Maxima\n//float ad(float x)\n//{\n//    return .5 * sqrt(pi) * erf(x);\n//}\n\nfloat digauss(float a, float b)\n{\n    return .5 * sqrt(pi) * abs(erf(b) - erf(a)); //ad(b) - ad(a); //\n}\n// at first, simply try doing all 3 axes; not ideal but should work, I think.\n// no, it does not work.  It does a simplistic job of approximating\n// the individual plane equations.\nfloat digauss(vec3 a, vec3 b)\n{\n    a *= 8.; b *= 8.;\n    return (digauss(a.x, b.x)\n          * 1. //digauss(a.y, b.y)\n          * digauss(a.z, b.z)\n           ) / 12.;\n}\n\nfloat gaussfail1(vec3 e, vec3 d, float t)\n{\n    return digauss(e, t * d + e);\n}\n*/\n\n/*\n// think I finally got Maxima to give me Blackle's result, or something close to it:\n\n//(%i1)\tintegrate(%e^-((ey + t * rd)^2), t, a,b);\n//(%o1)\t(sqrt(%pi) * erf(b * rd + ey)) / (2*rd)\n//    - (sqrt(%pi) * erf(a * rd + ey)) / (2*rd)\n\n// not quite right because it's treating ey and rd as scalars, not vectors\n// yeah Maxima just cannot handle integrating vector integrals, I think:\n//(%i15)\tintegrate(%e^-((ey + t * rd).(ey + t * rd)), t, a,b);\n//(%o15)\tintegrate(%e^(-(rd*t+ey)^^2),,a,b)\n// interesting that it translated V.V to V^^2 not V^2, and that it omitted the t arg\n// but this basically means that it failed to do the integration symbolically\n\nfloat adfail2(float t, vec3 o, vec3 d)\n{\n    return \n          sqrt(pi) / 2. / d.x * (erf(-1e-1 * abs(t * d.x + o.x)))\n        * sqrt(pi) / 2. / d.y * (erf(-1e-1 * abs(t * d.y + o.y)))\n        * sqrt(pi) / 2. / d.z * (erf(-1e-1 * abs(t * d.z + o.z)))\n        ; // TODO I'm hoping that will simplify\n} // sqrt(log(2.)) * \n\nfloat gaussfail2(vec3 ro, vec3 rd, float t)\n{\n    return adfail2(t, ro, rd) - adfail2(0., ro, rd);\n}\n// nevermind, that doesn't work at all!\n// seems like it's integrating the axes separately and combining incorrectly.\n*/\n\n/*\n// mo' simpler - kind of like the AngularSeg trick\n// it just checks whether the lightsource is blocked,\n// uses angular trick to get a blobby distance from ray\n// no actual integration of beer's law\nfloat newhack(vec3 ro, vec3 rd, float t)\n{\n    if (t < length(ro)) return 0.;\n    vec3 v = cross(rd, -ro);\n    return exp2(-40. * dot(v, v));\n}\n\n// check this out:\n// Maxima:\n// (%i1) ratsimp(e^(-x*x) * e^(-y*y) - e^(-x*x-y*y));\n// (%o1) 0\n// that means I can factor out the gaussians per-axis somehow\n// exp2 works also, same thing\n*/\n\n/*\n// my old hacks just approximate the blob angularly\n// without actually calculating any limiting trace through it\n// it takes the infinite angular trace and multiplies it\n// by the regular fog equation of the distance, beer's law,\n// which kind of works I guess; I raised it as a hack\n// but still isn't quite right, you can tell when the\n// glow-ball gets obscured by a nearby pillar, it should\n// be blocked, but you can still dimly see it.\n// for an old hack, it's not bad, though.  :)\nfloat oldhack(vec3 eye, vec3 view, float t)\n{\n    float ld = length(eye); // HACK light at origin again :)\n    // massive hacks :) just trying to approximate the integral, not calculate it precisely, so far\n    vec3 exv = cross(eye, view);\n    // might need arcsine to get angle; trying some hacks first, meh\n    float glowangle = pow(clamp(length(exv) / ld, 0., 1.), 1.4); //asin(clamp(length(exv) / ld, 0., 1.)) * 2./pi; //\n    glowangle = clamp(glowangle, 0., 1.);\n    float r = \n        //* max(0., 1. - 1. * pow(length(exv) / ld, .2))\n        //* (1.-pow(glowangle, .2))\n          pow(1.-glowangle, 20.)\n        * pow(clamp(t / ld, 0., 1.), 16.)\n     //   * (1.-exp2(-.1*t))\n        ; // glow\n    return r;\n}\n*/\n\n// wrapper to convert ray to segment or dispatch to alternative implementation\nfloat digauss(vec3 ro, vec3 rd, float t)\n{\n    return\n//     gaussFordPerfect // proper gaussian integration, optimized totally different way, definitely loses me.  \n//     gaussFordPerfectB // proper gaussian integration redux.\n//     gaussFordPerfectC // closer and closer!\n     gaussSpalmerShim // hey it's a hybrid!  cross-pollination or maybe like a distilled whisky blend\n//     gaussblackle2 // proper gaussian integration redux\n//     gaussblackle // proper gaussian integration, pretty straightforward even if it loses me.\n//     gaussWolframFail\n//     gaussfail1 // FAIL\n//     gaussfail2 // FAIL\n//     newhack\n//     oldhack\n        (ro, rd, t);\n}\n\n\n\n#define ZERO min(0, iFrame)\n\t\nstruct Hit\n{\n    float d; // distance\n    int m; // material\n};\n    // normal - may be easier to compute in scene fn than discretely\n    // uv - likewise easier to compute in dScene along w everything else\n    // in this case though we can get away with using world coordinate mapping\n    // directly, and can easily compute the derived normal and other quantities later\n\nHit join(Hit a, Hit b)\n{\n    if (abs(a.d) < abs(b.d)) \n        return a;\n    else\n        return b;\n}\n    // glsl ES cannot ?: on structure types :(\n    //return abs(a.d) < abs(b.d) ? a : b;\n    \nHit scene(vec3 p)\n{\n    float df = .5 - abs(p.y);\n    float dp = length(fract(p.xz) - .5) - .1;\n    return join(Hit(df, 0), Hit(dp, 1));\n}\n    //float ds = length(p) - .1; // the glowy thing at the origin isn't solid\n\n// anti-unrolled forward-difference gradient loop from old Fly Camera\n// but not quite as good as what I did for Inigo/Hooper's tetrahedral gradient.\nvec3 nScene(vec3 p, float h, out float nd)\n{\n    vec3 n, o = vec3(0,0,h);\n    vec4 s;\n    for (int i = ZERO + 4; i-- > 0; o = vec3(o.yz, 0))\n        s[i] = scene(p + o).d;       \n    n = s.yzw - s.x;\n    nd = s.x; // caller may want to use this to fine-adjust the hit point\n    return dot(n,n) < 1e-7 ? vec3(0,1,0) : normalize(n);\n}\n\nHit march(vec3 pos, vec3 dir, float tmax, int iter)\n{\n    iter += ZERO;\n    Hit r = Hit(-1., -1);\n\tfor (float t = .0; t < tmax && iter-- > 0; ) {\n\t\tvec3 p = pos + t * dir;\n    \tHit h = scene(p);\n\t\tif (abs(h.d) < 1e-3 * t) { \n\t\t\tr = Hit(t, h.m); break; // successfully hit something at point p, time t\n\t\t}\n\t\tt += h.d;\n\t}\n    return r;\n}\n\nfloat shadow(vec3 p, vec3 l, float tmax, int ssteps)\n{\n    float att = 1., t = 1e-2;\n    for ( ; ssteps-- > 0 && t < tmax; ) {\n        float d = scene(t * l + p).d;\n        att = min(att, d / t + exp2(.02 * t) - 1.);\n        t += max(.02, d);\n    }\n    return clamp(12. * att, 0., 1.);\n}\n// I can't even remember what this did anymore:\n// TODO reincorporate it or delete it\n/*\nstruct Fuzz\n{\n    float t; // distance to point of closest intersection along trace ray\n    int m; // material of nearest grazing object\n    float d; // closest near-miss distance (<= epsilon if actually hit something)\n    // currently n gives the \"permittivity\" of the trace\n    // 0 if totally blocked/shadowed, 1 if nothing in the way\n    float n; // nearness factor of some sort - some way to interpret the result as a fraction    \n};\n\n// a fuzzy directional query,\n// useful for blurry reflections, soft shadows,\n// ambient occlusion, and depth of field effects.\n// focus is a cosine of aperture half-angle of\n// conic gaussian beam query\n// I'm sure I can only approximate it, \n// probably use some hacks\nFuzz fuzz(vec3 pos, vec3 dir, float focus, int iter) //, float dmax\n{\n    pos += dir * 5e-3;\n    iter += Z;\n    float dmax = 1. / (1. - focus + 1e-3)\n    //, dfinal = 3.4e38\n    ;\n\tFuzz r = Fuzz(-3.4e38, -1, 0., 1.);\n    Hit h;\n    for (float t = .0; t < dmax && iter-- > 0; ) {\n\t\tvec3 p = pos + t * dir;\n    \th = scene(p);\n        // I could probably get outer penumbra pretty easily using h.d ratio\n        // but what about the inner umbra?  The hard shadow edge should\n        // map to .5 but all the region .5 < x < 1 should block the trace\n        // and stop it from reaching the light or full distance.\n        if (abs(h.d) < abs(r.d)) //  d / dmax\n            r = Fuzz(t, h.m, h.d, 1.); //clamp(1. - t / dmax, 0., 1.)); // tracks closest near-miss\n\t\tif (abs(h.d) < 1e-3 * t) { // close enough to consider a hit and stop?\n\t\t\tr = Fuzz(t, h.m, h.d, 0.); // but didn't we already always do this? t may have grown, instead.\n            break; // successfully hit something at point p, time t\n\t\t}\n        //dfinal = h.d;\n\t\tt += h.d;\n\t}\n    //r.d = dfinal;\n    //r.t = t;\n    //r.m = h.m;\n    //r.d = \n    // amount of fuzz is a function of focus and dfinal somehow TODO\n    // well I have dmax estimate now...\n    return r;\n}\n*/\nvec3 getMaterial(int m)\n{\n    vec3 c = vec3(.5);\n    switch (m) {\n        case 1: c = vec3(.1, .3, .5); break;\n    }\n    return c;\n}\n\n// diffuse lighting; sa = shadow attenuation\nvec3 light(vec3 pos, vec3 normal, vec3 v, vec3 albedo, float dist, vec3 env, float sa)\n{\n    float tex1 = texture(iChannel1, 1.5*pos).r, \n        tex2 = texture(iChannel1, .75*pos + vec3(0,tex1,0) * .2).r, \n        tex = tex1 * .0 + tex2 * 1.;\n    albedo *= mix(tex, 1., .3);\n    sa = clamp(sa, 0., 1.);\n    vec3 l = normalize(-pos); // more light at origin HACK\n\tfloat nl = max(0., dot(normal, l));\n    if (nl > 0.) {\n        float ld = length(pos); // light happens to be at origin HACK\n\t\tnl *= 1. / (1.5 * ld * ld + 1e-2); //nl *= exp2(-.5*h.d); // attenuate light  \n    }\n    vec3 h = normalize(v + l);\n    float nh = dot(normal, h),\n        specpower = 32.,\n        spec = specpower * (1./8./pi) * pow(max(nh, 0.), specpower), // blinn-phong specular\n        ambient = .06;\n    nl = clamp(nl * sa, 0., 1.);\n    nl = mix(nl, 1., ambient);\n    vec3 ltot = (albedo + spec) * nl;\n    vec3 lit = ltot; // colorize light\n    float fd = .3*dist;\n\treturn mix(env, lit, exp2(-fd)); // fog\n}\n\n// rotate vector a through b by radians r\nvoid rot(inout vec3 a, inout vec3 b, float r)\n{\n    float c = cos(r), s = sin(r);\n    vec3\n        t = a * c + b * s; // temporary\n        b = b * c - a * s;\n        a = t; // modify interdependently\n}\n\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n\tvec2 R = iResolution.xy,\n      m = iMouse.xy / R;\n    if (iMouse.z <= 0.) // not pressing mouse button?\n        m += vec2(iTime*.01, dot(iMouse.xy, iMouse.xy) < 2. ? .5 : 0.); // spin at mid or most recent angle\n    float wig = .35;\n    m.y = clamp(m.y, .5-wig, .5+wig); // stop camera from going beneath ground plane - but it's a HACK for the given range of .4\n    // TODO could probably calculate out the angle it would penetrate the plane and stop prior\n\tm -= .5; m.x *= 3.;\n    // view to world transform given angles\n    mat3 V = mat3(1);\n    rot(V[2], V[0], m.x);\n    rot(V[2], V[1], m.y);    \n\tvec3 clite = 1. * vec3(1, 1, max(.1, sin(iTime*.2))), //.9,.8,.2) //\n        env = vec3(.1,.03,.03), // reddish enviro/fog color\n        c = env, // result color default\n        eye = -1.35 * V[2], // eye pos\n        q = vec3((p - .5 * R) / R.y, 1.),\n        view = normalize(V * q); // rotate view ray dir by aim; // eye pos\n    const float dmax = 16.;\n    Hit h = march(eye, view, dmax, 256);\n    bool miss = h.d < 0.; // ray missed scene?\n    bool pen = h.d >= 0. && h.d < 5e-3; // camera inside something?\n    if (h.d < 0.) h.d = dmax;\n    float ndadj;\n    vec3 hp = eye + view * h.d,\n        n = nScene(hp, 1e-3*h.d, ndadj),\n        r = normalize(reflect(view, n));\n    \n    hp -= n * ndadj; // move out of surface (or precisely to surface)\n    hp += n * .01; //3e-0; // * h.d; // self-shadow bias\n    vec3 l = -normalize(hp); // HACK light is at origin - how many damn places am I going to put this hack anyway?\n    const float dsmax = 2., drmax = 2.;\n    float nl = dot(n, l),\n        ld = length(eye), // yet another light pos at origin hack\n        dl = length(hp), // HACK distance to light source\n        dslim = min(dsmax, dl);\n    Hit //hs = march(hp, l, dslim, 32), // hard shadow\n        hs = Hit(nl > 0. ? shadow(hp, l, dslim, 32) : 0., 1), // soft shadow\n        hr = march(hp + r * 1e-3, r, drmax, 32); // glossy reflection\n    bool rpen = hr.d >= 0. && hr.d < 2e-3; // reflection hit itself? trying to debug\n    if (hs.d < 0.) hs.d = dslim;\n    if (hr.d < 0.) hr.d = drmax; // maybe this should go inside march? FIXME\n    vec3 phs = hp + l * hs.d;\n    float dhs = scene(phs).d,\n        s2 = dhs / hs.d;\n    const float aod = .04; // ambient occlusion hack dims join between pillars and floor/ceiling a bit\n    //Fuzz\n    //    fa = fuzz(hp, n, 0., 4),\n    //    fr = fuzz(hp, r, .5, 16),\n    //    fs = fuzz(hp, l, .5, 24); // TODO soft shadow etc.\n    //if (fa.d > aod || fa.d < 0.) fa.d = aod;\n    vec3 rp = hp + r * hr.d;\n    float\n        ao = clamp(scene(hp + n * aod).d / aod, 0., 1.), //1. // - 1. / fa.d //distance(hp, hp + n * fa.d) //\n        s1 = hs.d > dl || hs.d < 0. ? 1. : .1,\n       // hs.d > dl ? 1. : pow(hs.d / dl, 2.)\n        s3 = clamp(hs.d / dslim, 0., 1.),\n        sh = mix(s1, 1., s3), //s2 //\n        satten = ao * sh;\n    vec3 amain = getMaterial(h.m), arefl = getMaterial(hr.m);\n    float rdadj;\n    vec3 cr = mix(\n            light(rp, nScene(rp, 2e-3*(h.d+.1), rdadj), -r, arefl, hr.d + hr.d, env, 1.),\n            1. * env,\n            clamp(hr.d / drmax, 0., 1.)), //env //\n        cl = light(hp, n, -view, amain, h.d, env, satten);\n    c = (cl + .05 * cr) * clite;\n    c += 4. * clite // really strong!\n        * digauss(eye, view, h.d);\n//    if (pen) c = vec3(.5 * max(0., sin(20.*iTime)),0,0); // debug camera inside object problems\n//    if (rpen) c = vec3(0,.5 * max(0., sin(20.*iTime)),0); // debug reflection problems - guess it just needed a bias on the trace start.\n//    if (isnan(dot(n,n)) || dot(n,n) < .9) c = vec3(1,1,0);\n//    if (miss) c = vec3(0,0,5. * max(0., sin(20.*iTime))); // debug camera ray missed scene problems\n    //c += clite * fuzz(eye, view, .1, 20, 5.).d; // TODO something more like this\n  \n    // tonemap, OETF to sRGB gamut & dither to 8bit/ch\n\to = vec4(1.15 * (c / (c + .18)) // reinhard approx\n\t   + (texelFetch(iChannel0, ivec2(p) & 1023, 0).x - .5) * exp2(-8.), // dither using blue noise texture, assumed to be 1024x, assuming output is 8bit/ch\n\t   1); \n}\n\n// I wish I had noticed iq's fog sphere before making this!  http://shadertoy.com/view/XljGDy\n// in comment there, Fabrice suggests reading Stam's paper http://dgp.toronto.edu/public_user/stam/reality/Research/pdf/gi94.pdf\n","name":"Image","description":"","type":"image"}]}