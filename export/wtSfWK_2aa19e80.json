{"ver":"0.1","info":{"id":"wtSfWK","date":"1599840041","viewed":548,"name":"Basic volumetric light","username":"boris159","description":"Basic implementation of volumetric lightning using pathtracing and raymarching algorithms.","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","volumetric","fog","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 tex = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 col = tex.xyz / tex.a;\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON 0.001\n#define PI 3.141592\n#define MAX_DIST 256.0\n#define MAX_STEPS 256\n#define bounces 5\n\nfloat seed;\n\nfloat rand()\n{\n    seed += 0.15342;\n    return fract(sin(seed) * 35423.7652344);\n}\n\nfloat randUnit(float a, float b)\n{\n\treturn a + (b - a) * rand();\n}\n\nvec3 randDir(vec3 dir, float spread)\n{\n    vec3 b3 = normalize(dir);\n    vec3 different = (abs(b3.x) < 0.5) ? vec3(1, 0, 0) : vec3(0, 1, 0);\n    vec3 b1 = normalize(cross(b3, different));\n    vec3 b2 = cross(b1, b3);\n\n    float z = randUnit(cos(spread * PI), 1.0);\n    float r = sqrt(1.0 - z * z);\n    float theta = randUnit(-PI, PI);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n\n    return b1 * x + b2 * y + b3 * z;\n}\n\nmat2 rot(float ang)\n{\n    float s = sin(ang);\n    float c = cos(ang);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotVec(vec3 p, vec3 r)\n{\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    p.xy *= rot(r.z);\n    return p;\n}\n\nstruct BounceData\n{\n    vec3 emitt;\n    vec3 ref;\n};\n\nvec3 makeRay(vec2 origin)\n{\n    vec2 res;\n    res.x = origin.x - iResolution.x * 0.5;\n    res.y = origin.y - iResolution.y * 0.5;\n    return normalize(vec3(res / iResolution.yy, 1.0));\n}\n\nfloat box(vec3 b, vec3 pos, vec3 p)\n{\n    vec3 q = abs(p - pos) - b;\n  \treturn length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat emptyBox(vec3 b, vec3 pos, vec3 p, float inner)\n{\n    return max(box(b, pos, p), -box(b * inner, pos, p));\n}\n\nfloat getDist(vec3 origin)\n{\n    //origin.xz *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    float box1 = emptyBox(vec3(1.5, 1, 2), vec3(0), origin, 0.9);\n    float box2 = box(vec3(1, 0.5, 1), vec3(1, 0, 0), origin);\n    return max(box1, -box2);\n}\n\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy),\n        getDist(p-e.yxy),\n        getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec2 rayMarch(vec3 origin, vec3 direct)\n{\n    float res = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 tmp = origin + direct * res;\n        float d = getDist(tmp);\n        res += d;\n        \n        if (res >= MAX_DIST || d < EPSILON)\n        \treturn vec2(res, float(i));\n    }\n\n    return vec2(res, float(MAX_STEPS));\n}\n\nvec3 trace(vec3 origin, vec3 dir)\n{\n\tvec3 globalCol = vec3(0);\n    BounceData cols[bounces];\n    vec3 pos = origin, end;\n    \n    for (int b = 0; b < bounces; b++)\n    {\n        vec2 res = rayMarch(origin, dir);\n        \n        if (b == 0)\n            end = origin + dir * res.x;\n        \n        if (res.x >= MAX_DIST)\n        {\n            cols[b] = BounceData(vec3(0.75), vec3(0));\n            break;\n        }\n        else\n        \tcols[b] = BounceData(vec3(0), vec3(0.5));\n        \n        origin += dir * res.x;\n        vec3 normal = getNormal(origin);\n        origin += normal * EPSILON * 5.0;\n        dir = randDir(normal, 0.5);\n    }\n    \n    for (int i = bounces - 1; i >= 0; i--)\n    \tglobalCol = cols[i].emitt + globalCol * cols[i].ref;\n    \n    float toAdd = 1.0 / float(bounces);\n    \n    for (int i = 0; i < bounces; i++)\n    {\n        vec3 p = mix(pos, end, rand());\n        vec2 res = rayMarch(p, normalize(vec3(1, 0.75, 0)));\n        \n        if (res.x >= MAX_DIST)\n            globalCol += toAdd;\n    }\n\n    return globalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    vec3 pos = vec3(-0.75, 0, -1.75);\n    vec3 dir = makeRay(fragCoord);\n    dir = rotVec(dir, vec3(0, -PI / 6.0, 0));\n    \n    vec4 col = texture(iChannel0, fragCoord / iResolution.xy);\n    vec3 traced = trace(pos, dir);\n    col += vec4(traced, 1);\n    \n    if (iMouse.z > 0.0)\n        col = vec4(0);\n    \n    fragColor = col;\n}","name":"Buffer A","description":"","type":"buffer"}]}