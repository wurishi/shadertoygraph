{"ver":"0.1","info":{"id":"tscGWM","date":"1568657601","viewed":539,"name":"Sine wave SDF (bound)","username":"Blake447","description":"This ones a doozy, and was pretty fun to derive. This uses a similar method to my paraboloid and hyperboloid sdf's, in which I either evaluate a tangent line or a chord between two points, but the inflection points complicate things a bit.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","raymarch","sdf","sinewave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Convert degrees to radians\nfloat Radians(float deg)\n{\n \treturn deg / 360.0 * 2.0 * 3.14159; \n}\n\n// Do a safe absolute value function for edge cases\nfloat safeAbs(float x)\n{\n\tif (x == 0.0)\n\t{\n\t\treturn 0.0;\n\t}\n\treturn abs(x);\n\n}\n\n// Write a float4 function for some of the HLSL Code conversion\nvec4 float4(float x, float y, float z, float w)\n{\n \treturn vec4(x,y,z,w);   \n}\n\n// Write a float3 function for the same purpose\nvec3 float3(float x, float y, float z)\n{\n \treturn vec3(x,y,z);   \n}\n\n// And a float2\nvec2 float2(float x, float y)\n{\n \treturn vec2(x, y);   \n}\n\n// A method for the intersection of two lines (in 2 dimensions)\nvec2 intersectionOfTwoLines(vec2 A, float sa, vec2 B, float sb)\n{\n\tfloat buffer = (sa*A.x - A.y - sb * B.x + B.y) / (sa - sb);\n\tvec2 intersection = float2(buffer, sa*(buffer - A.x) + A.y);\n\treturn intersection;\n}\n\n// Exact intersection of a sphere. Resolves a quatratic equation. Returns the \n// min distance, max distance, and discriminant to determine if the intersections\n// actually exist.\nvec3 intersections_of_sphere(vec3 pos_vector, vec3 dir_vector, float sphere_radius)\n{\n\t// Derivation for formula:\n\t//\t\tLet the ray be represented as a point P plus a scalar multiple t of the direction vector v,\n\t//\t\tThe ray can then be expressed as P + vt\n\t//\n\t//\t\tThe point of intersection I = (x, y, z) must be expressed as this, but must also be some distance r\n\t//\t\tfrom the center of the sphere, thus x*x + y*y + z*z = r*r, or in vector notation, I*I = r*r\n\t//\n\t//\t\tIt therefore follows that (P + vt)*(P + vt) = r*r, or when expanded and rearranged,\n\t//\t\t(v*v)t^2 + (2P*v)t + (P*P - r*r) = 0. For this we will use the quadratic equation for the points of\n\t//\t\tintersection\n\n\t// a, b, and c correspond to the second, first, and zeroth order terms of t, the parameter we are trying to solve for.\n\tfloat a = dot(dir_vector, dir_vector);\n\tfloat b = 2.0 * dot(pos_vector, dir_vector);\n\tfloat c = dot(pos_vector, pos_vector) - sphere_radius * sphere_radius;\n\n\t// to avoid imaginary number, we will find the absolute value of the discriminant.\n\tfloat discriminant = b * b - 4.0 * a*c;\n\tfloat abs_discriminant = abs(discriminant);\n\tfloat min_dist = (-b - sqrt(abs_discriminant)) / (2.0 * a);\n\tfloat max_dist = (-b + sqrt(abs_discriminant)) / (2.0 * a);\n\n    // return the two intersections, along with the discriminant to determine if\n    // the intersections actually exist.\n\treturn float3(min_dist, max_dist, discriminant);\n\n}\n\n// Exact SDF for a sphere\nfloat dSphere(vec3 pos, vec3 center, float radius)\n{\n    // find the distance to the center\n    vec3 v = pos - center;\n    \n    // return that, minus the radius\n    return length(v) - radius;\n}\n\nfloat fmod(float a, float base)\n{\n \tfloat b = fract(a / base) * base;  \n    return b;\n}\n\nfloat sgn(float a)\n{\n \tif (a < 0.0)\n    {\n     \treturn -1.0;   \n    }\n    return 1.0;\n}\n\nfloat fBox(vec3 p, vec3 b, vec3 c)\n{\n\tvec3 d = abs(p-c) - b;\n\treturn max(max(d.x, d.y), d.z);\n}\n\nfloat fSinusoidal(vec3 p, vec3 center)\n{\n    const float PI = 3.14159;\n    \n    vec3 Point_original = p - center;\n    \n\tfloat d_sign = 1.0;\n\tif (Point_original.y < sin(Point_original.x))\n\t{\n\t\td_sign *= -1.0;\n\t}\n\n\tvec2 Point;\n\tPoint.y = Point_original.y*sgn(Point_original.x);\n\tPoint.x = abs(Point_original.x);\n\n\tfloat h = (fmod(Point.x, PI));\n\tfloat h2 = PI*0.5 - abs(abs(h) - PI * 0.5);\n\tfloat h3 = (fmod((Point.x), 2.0*PI));\n\n\tfloat parity = 1.0 - 2.0 * float(int(fmod(abs(Point.x / (PI)), 2.0)));\n\n\tvec2 A = float2(h, Point.y*parity);\n\n\t//int quad = (int) Point.x/()\n\n\t// Calculation for greater than function, greater than zigzag.\n\tvec2 r_of_h = float2(A.x, sin(A.x));\n\tfloat t_of_h = cos(A.x);\n\tfloat n_of_h = -1.0 / t_of_h;\n\tvec2 t_int_n = intersectionOfTwoLines(r_of_h, t_of_h, A, n_of_h);\n\tfloat dist1 = distance(A, t_int_n);\n\tfloat dist = dist1;\n\t//float dist = 2000;\n\n\t// Calculation for the less than function, less than zigzag\n\tvec2 B = float2(h2, A.y);\n\tfloat clamped_height = clamp(B.y, 0.0, 1.0);\n\tvec2 P = float2(h2, sin(h2));\n\tvec2 Q = float2(asin(clamped_height), clamped_height);\n\n\tfloat s_of_P2Q = (P.y - Q.y) / (P.x - Q.x);\n\tfloat n_of_P2Q = -1.0 / s_of_P2Q;\n\n\tvec2 R = intersectionOfTwoLines(P, s_of_P2Q, B, n_of_P2Q);\n\tfloat dist2 = distance(B, R);\n\n\tif (abs(B.y) < h2)\n\t{\n\n\t\tdist = min(dist, dist2);\n\t}\n\n\tfloat slope = 1.0;\n\tfloat tangent = -1.0;\n\tvec2 T = intersectionOfTwoLines(float2(0.0,0.0), 1.0 *sgn(Point.x), float2(h2, A.y), -1.0 *sgn(Point.x));\n\tfloat dist3 = distance(float2(h2, A.y), T);\n\n\tif (h3 > PI && h3 < 2.0*PI && Point.y > sin(Point.x))\n\t{\n\t\tdist = min(dist, dist3);\n\t}\n\n\tif (h3 < PI && h3 > 0.0 && Point.y < sin(Point.x))\n\t{\n\t\tdist = min(dist, dist3);\n\t}\n\n\n\treturn dist*d_sign;\n}\n\n\n\n// Distance estimation for the scene\nfloat DE(vec3 p, vec3 c)\n{\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 bounds = vec3(4.0, 4.0, 4.0);\n    \n\tfloat s1 = fSinusoidal(p * vec3(1.0, -1.0, 1.0), center);   \t\n    float b1 = dSphere(p, center, 8.0);\n    \n    //float d2 = (-abs(p.y)-c.y) + 1.0;\n    \n    float d = max(s1, b1);\n    //float d = b1;\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define the iterations for the marcher.\n    const int ITERATIONS = 60;\n    \n    // Define the roation speed. Set to 0 to disable\n    const float ROTATION_SPEED = 0.6;\n    \n    // Define the start angle for the rotation (in degrees)\n    const float START_ANGLE = 0.0;\n    \n    // Define the orbit radius\n    const float ORBIT_RADIUS = 16.0;\n    \n    // Define the epsilon value for closeness to be considered a hit\n    const float EPSILON = 0.005;\n    \n    const bool HIDE_BACKGROUND = true;\n\n    // Define the center of the SDF\n    vec3 sdf_center = vec3(0.0, 0.0, 0.0);\n \n    // Calculate the starting angles for the orbit\n    float theta = iTime * ROTATION_SPEED;\n    float phi = Radians(START_ANGLE);\n    \n    // Take some mouse input\n    vec4 mouse = iMouse / iResolution.xyxx;\n    \n    // If the mouse is being held down\n    if (mouse.z > 0.0)\n    {\n        // convert the mouse input to angles\n        theta = mouse.x * 2.0 * 3.14159;\n        phi = (mouse.y - 0.5) * 1.0 * 3.14159;\n    }\n    \n    // Define an orbital path based on time\n    vec3 orbit = vec3(cos(theta)*cos(phi), sin(phi), sin(theta)*cos(phi));\n    \n    // Cacluate the normal of the path. Since its a circle, it will just\n    // be back down into the center\n    vec3 normal = -normalize(orbit);\n    \n    // Calculate the tangent of the path\n    // A circle consists of <cost, sint>, which when differentiated yields\n    // <-sint, cost>. since z is already sint, and x is already cost, the equation\n    // is as follows.\n    vec3 tangent = normalize(vec3(-normal.z, 0.0, normal.x));\n    \n\t// Calculate the UV coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Convert the UV coordinates to a range between -1 and 1\n    vec2 range = uv*2.0 - vec2(1.0,1.0);\n    \n    // Define the Camera position\n    vec3 cam_pos = orbit*ORBIT_RADIUS;\n    \n    // Define the forward, up, and right vectors (needs rework)\n    vec3 forward = normal;\n    vec3 up = normalize(cross(normal, tangent));\n    vec3 right = tangent;\n        \n    // Calculate the aspect ratio of the screen\n    float aspect = float(iResolution.y) / float(iResolution.x);\n    \n    // Calculate the ray as a normalized combination of the forward, right, and up vectors.\n    // Note that the purely forward + horizonal combination yield vectors 45 degrees outward\n    // for a 90 degree field of view. This may be updated with a fov option\n    vec3 ray = normalize(forward + range.x*right + range.y*up*aspect);\n    \n    // Initialize the ray marched point p\n    vec3 p = cam_pos;\n\n\n\t// Initialize the distance\n    float dist = 1.0;\n    \n    // Calculate the exact distance from a sphere of radius 2 using a raytracing function\n    vec3 init_distance = intersections_of_sphere(p - sdf_center, ray, 16.0);\n    \n    // If we are outside a bubble around the raymarched fractal\n    if (init_distance.z > 0.0)\n    {\n        // Step onto the sphere so we start off a bit closer.\n    \tp += ray * clamp(init_distance.x, 0.0, init_distance.x);\n    }\n\n    // declare a dummy variable to store the number of iterations into.\n    // I'm doing it this way because on my phone it didnt let me use an\n    // already declared variable as the loop iterator.\n    int j;\n    \n    \n\t// Begin the raymarch\n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        // Estimate the distance to the julia set\n        dist = DE(p, sdf_center);\n        \n        // Move forward that distance\n        p += ray*dist;\n        \n        // Record the number of iterations we are on\n        j = i;\n        \n        // If we hit the julia set, or get too far away form it\n        if (dist < EPSILON || dot(p - sdf_center, p-sdf_center) > 4096.1)\n        {\n            // Break the loop.\n        \tbreak;   \n        }\n        \n    }\n   \n    // determine if we hit the SDF\n    float hit = step(dist, EPSILON);\n    \n    // calculate the brightness based on iterations used\n\tfloat di = (float(j) + (dist / EPSILON)*hit) / float(ITERATIONS);\n\t\n\n   \n    di = 1.0 - di; \n    if (HIDE_BACKGROUND)\n    {\n    \tdi = di*hit;\n\t}\n    \n    // define some phase angle\n    float psi = Radians(70.0);\n    \n    // Time varying pixel color (included in default shadertoy project)\n    //vec3 col = 0.8 + 0.2*cos(iTime*0.5+uv.xyx+vec3(0,2,4) + psi*hit);\n\t\n    // Boring old white instead of the above commented code. Will tweak rendering later\n    vec3 col = vec3(1.0,1.0,1.0);\n    \n    \n    // Output to screen. Modifiy the color with the brightness calculated as di.\n    fragColor = vec4(col*di,1.0);\n}","name":"Image","description":"","type":"image"}]}