{"ver":"0.1","info":{"id":"4dKyD3","date":"1523644644","viewed":275,"name":"Failed Menger Sponge","username":"bombshell93","description":"I tried to make a menger sponge from scratch, test my ability to bodge together a working formula, I didn't quite get it but I found this shape interesting in its place, threw some bad lighting and ao in there and gave it a spin.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["fractal","light","color","ao","ambientocclusion","spin","repeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\n#define FOV PI * 0.5\n#define COSTIME cos(iTime * 0.1)\n#define SINTIME sin(iTime * 0.1)\n\n#define SHAPE_DIVISION 4\n#define SHAPE_SPACE 2.1\n\n#define RAY_STEPS 64\n#define RAY_MIN_DIST 0.001\n#define RAY_MAX_DIST 1024.0\n\n#define AO_SAMPLES 32\n\n#define NORMAL_SAMPLE_LENGTH 0.005\n\n#define LIGHT_AMBIENT vec3(0.5, 0.5, 0.5);\n#define LIGHT_INTENSITY 0.5\n#define LIGHT_RAY_STEPS 64\n#define LIGHT_RAY_DIST 0.0001\n\n#define SPECULAR_POWER 4.0\n#define SPECULAR_INTENSITY 1.0\n\nfloat sat(float a) {\n    \n    return min(1.0, max(0.0, a));\n}\nfloat opU(float a, float b) { return min(a, b); }\nfloat opS(float a, float b) { return max(a, -b); }\nvec3 opT(vec3 p, vec3 o) { return p - o; }\nvec3 opR(vec3 p, vec3 c) { return mod(p, c) - 0.5 * c; }\nfloat box(vec3 p, vec3 b) { vec3 d = abs(p) - b; return max(d.x, max(d.y, d.z)); }\nfloat ibox(vec3 p, vec3 b) { vec3 d = abs(p) - b; return -max(d.x, max(d.y, d.z)); }\nfloat map(vec3 p) {\n    \n    float d = RAY_MAX_DIST;\n    vec3 rp = p;\n    rp = opR(rp, vec3(SHAPE_SPACE, SHAPE_SPACE, SHAPE_SPACE));\n    float fd = box(rp, vec3(1.0, 1.0, 1.0));\n    float sd = RAY_MAX_DIST;\n    for (int i = 0; i < SHAPE_DIVISION; ++i) {\n        \n        vec3 tp = rp;\n        float s = pow(3.0, float(i ));\n        tp = opT(tp, vec3(2.0, 2.0, 2.0) / s);\n        tp = opR(tp, vec3(2.0, 2.0, 2.0) / s);\n        sd = opU(sd, box(tp, vec3(0.66, 0.66, 0.66) / s));\n    }\n    fd = opS(fd, sd);\n    d = opU(d, fd);\n    return d;\n}\n\nfloat findDist(vec3 ro, vec3 rd, int max_steps, float min_dist, float max_dist) {\n    \n    float len = min_dist;\n    for (int i = 0; i < max_steps && len < max_dist; ++i) {\n        \n        float dist = map(ro + rd * len);\n        if (dist <= min_dist) {\n            \n            return len;\n        }\n        len += dist;\n    }\n    return RAY_MAX_DIST;\n    \n}\n\nvec3 findNormal(vec3 p) {\n    \n    float u = map(p + vec3(0.0, 0.0, NORMAL_SAMPLE_LENGTH))\n        , d = map(p - vec3(0.0, 0.0, NORMAL_SAMPLE_LENGTH))\n        , r = map(p + vec3(NORMAL_SAMPLE_LENGTH, 0.0, 0.0))\n        , l = map(p - vec3(NORMAL_SAMPLE_LENGTH, 0.0, 0.0))\n        , f = map(p + vec3(0.0, NORMAL_SAMPLE_LENGTH, 0.0))\n        , b = map(p - vec3(0.0, NORMAL_SAMPLE_LENGTH, 0.0));\n    return normalize(vec3(r - l, f - b, u - d));\n}\n\nfloat findAO(vec3 p, vec3 n) {\n    \n    float ao = 0.0;\n    for (int i = 0; i < AO_SAMPLES; ++i) {\n        \n        float w = pow(float(i + 1), 2.0);\n        float sd = 0.001 * w;\n        ao += max(0.0, map(p + n * sd) / sd) / float(AO_SAMPLES);\n    }\n    return max(min(ao, 1.0), 0.0);\n}\n\nvec3 phong(vec3 p, vec3 e, vec3 n, vec3 l, vec3 c, float i) {\n    \n    vec3 ptol = l - p;\n    vec3 etop = p - e;\n    float diff = dot(normalize(ptol), n);\n    float spec = pow(sat(dot(normalize(etop), normalize(ptol))), SPECULAR_POWER) * SPECULAR_INTENSITY;\n    float dist = 1.0 / (pow(length(ptol) / i, 2.0));\n    if (findDist(l, normalize(-ptol), LIGHT_RAY_STEPS, LIGHT_RAY_DIST, length(ptol)) < RAY_MAX_DIST) {\n        \n        return vec3(0.0, 0.0, 0.0);\n    }\n    return (c * (diff + spec) * dist) / i;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc ) {\n    \n    vec2 uv = (vec2(fc.x, fc.y) - iResolution.xy * 0.5) / iResolution.y;\n    vec3 e = vec3(0.0, iTime * 0.25, 0.0);\n    vec3 l = e + vec3(0.0, 1.0, 0.0);\n    \n    vec3 f = normalize(l - e);\n    vec3 u = vec3(COSTIME, 0.0, SINTIME);\n    vec3 r = cross(u, f);\n    \n    vec3 rd = normalize(f + r * uv.x * FOV + u * uv.y * FOV);\n    vec3 ro = e + rd * RAY_MIN_DIST;\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float d = findDist(ro, rd, RAY_STEPS, RAY_MIN_DIST, RAY_MAX_DIST);\n    if (d < RAY_MAX_DIST) {\n        \n        vec3 p = ro + rd * d;\n        vec3 n = findNormal(p);\n        float ao = findAO(p, n);\n\n        vec3 l = phong(p, e, n, e + vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 1.0), LIGHT_INTENSITY) + LIGHT_AMBIENT;\n        l *= ao;\n        vec3 c = normalize(vec3(mod(floor(p / SHAPE_SPACE), vec3(1.0, 1.0, 1.0) * SHAPE_SPACE)) * 0.5 + 0.5);\n        fragColor = vec4(c * l, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}