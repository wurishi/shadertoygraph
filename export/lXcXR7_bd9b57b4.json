{"ver":"0.1","info":{"id":"lXcXR7","date":"1718966578","viewed":109,"name":"Gamepad","username":"smarchevsky","description":"SDF gamepad moving parts. Based on smooth boolean function shapes.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["sdf","smooth","union","signeddistance","gamepad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// GAMEPAD\n\n// Author : Stanislav Marchevsky\n// Created : Jun 2024\n\n// Use it wherever you want, but don't hurt anyone with this code.\n// If you mention my authorship, you'll make \"that guy from shadertoy\" a bit happier :)\n// But if you don't - I won't come for you.                                                                                 (maybe)\n\n\n#define ADD(tCur, currentMask) if(tCur < t2) { t2 = tCur; materialIndex = currentMask; }\n\n\n// you can increase this val to face triggers and shoulders to top view camera\n#define INIT_TRIG_SHOULD_ROTATION (34. / 57.3)\n\n\n// NOW WITH BUTTON BIT MASK !\n\n#define LEFT_STICK   (1<<0)\n// #define RIGHT_STICK  (1<<1)\n\n#define DPAD_LEFT    (1<<2)\n#define DPAD_RIGHT   (1<<3)\n#define DPAD_UP      (1<<4)\n#define DPAD_DOWN    (1<<5)\n#define DPAD_ALL     (DPAD_LEFT | DPAD_RIGHT | DPAD_UP | DPAD_DOWN)\n\n#define BUTTON_LEFT  (1<<6)\n#define BUTTON_RIGHT (1<<7)\n#define BUTTON_UP    (1<<8)\n#define BUTTON_DOWN  (1<<9)\n\n#define SHOULDER_LEFT   (1<<10)\n#define SHOULDER_RIGHT  (1<<11)\n#define TRIGGER_LEFT    (1<<12)\n#define TRIGGER_RIGHT   (1<<13)\n\n#define SELECT_BUTTON_0 (1<<14)\n#define SELECT_BUTTON_1 (1<<15)\n#define SELECT_BUTTON_2 (1<<16)\n\n// DPad pos used in paint, moved above paint\n#define XBOX_LAYOUT \n#ifdef XBOX_LAYOUT\n    vec3 dPadPos = vec3(-0.05, 0.2, 0.3);\n    vec3 leftStickPos = vec3(-0.28, 0.4, 0.33);\n#else\n    vec3 dPadPos = vec3(-0.28, 0.43, 0.3);\n    vec3 leftStickPos = vec3(-0.05, 0.2, 0.33);\n#endif\n\n\n\n// based on https://www.shadertoy.com/view/ltVBWc\n// Car paint is under CC BY-NC-SA 4.0 International License\nvec3 Paint( vec3 p, vec3 normal, vec3 ray, int matIndex, float ao )\n{\n    vec4 black = vec4(vec3(.06), 1.);\n    vec4 grey = vec4(0.353,0.37, .4, .2);\n    vec4 metallic = vec4(vec3(.99), .5);\n    vec4 silver = vec4(1.4, 1.4, 1.4, .5);\n    \n    float d = clamp(-dot(normal,ray), 0.,1.);\n    float fresnel = pow( 1. - d, 5. );\n    \n    vec4 paint = grey;\n    \n    if(matIndex != 0)\n        paint = vec4(2.*pal(float(matIndex%91) * .421, vec3(1.0,1.0,1.0), vec3(0.,0.333,0.667)), 0.1);\n        \n    vec3 refl = reflect(ray,normal);\n    vec3 finalColor = mix(\n        mix ( \n            LDRtoHDR(textureLod( iChannel0, normal.yzx, 6. ).rgb), // diffuse\n            LDRtoHDR(textureLod( iChannel0, refl.yzx, 4. ).rgb), // metallic\n            paint.a) * paint.rgb,\n        LDRtoHDR(texture( iChannel1, refl.yzx ).rgb), // clearcoat\n        mix( .02, 1., fresnel )\n    );\n    \n    int timeMask = 1 << (int(iTime * 3.) % 17);\n    timeMask |= 1 << (int(iTime * 1.1) % 17);\n    \n    int finalMask = timeMask & matIndex;\n    if(matIndex != 0)\n        if((finalMask & DPAD_ALL) != 0){\n            vec3 dPadCoord = p - dPadPos;\n            finalColor = mix(finalColor, vec3(1), saturate( 0.f\n                + float((finalMask & DPAD_LEFT) != 0) * dPadCoord.y*5.\n                + float((finalMask & DPAD_RIGHT)!= 0) * dPadCoord.y*-5.\n                + float((finalMask & DPAD_UP)   != 0) * dPadCoord.x*5.\n                + float((finalMask & DPAD_DOWN) != 0) * dPadCoord.x*-5.\n            )\n            );\n        } else \n           finalColor = ((finalMask != 0) ? vec3(1) : finalColor); \n        \n    finalColor *= ao;\n    \n    return finalColor;\n    return vec3(ao);\n}\n\nconst float smallR = 0.03;\nvoid pipka(vec3 p, inout float t,  inout float t2, inout int materialIndex, vec2 rotation){\n    \n    t = sUnion(t, sdSphere(p, 0.16), 0.05);\n    t = sSubtract(sdSphere(p - vec3(0,0,0.3), 0.23), t, 0.02);\n    p = rotateXYZ(vec3(rotation.x ,0,rotation.y)* 0.4) * p;\n    \n    const float stickHeight = 0.18;\n    const float stickWidth = 0.1;\n    float tFinal = sUnion( sdSphere(p, 0.12), sdCappedCylinder(p.yzx, stickHeight, 0.03), smallR);\n    float pipkaSize = 0.1;\n    tFinal = sUnion(tFinal, sdEllipsoid(p- vec3(0,0,stickHeight), vec3(stickWidth,stickWidth,0.04)), smallR);\n    tFinal = sSubtract(sdEllipsoid(p- vec3(0,0,stickHeight + 0.05), vec3(stickWidth,stickWidth,0.04)), tFinal, 0.01);\n    ADD(tFinal, LEFT_STICK)\n}\n\nvoid dPad(vec3 p, inout float t, inout float t2, inout int materialIndex){\n    float cylinder = sdCappedCylinder((p - vec3(0, 0, 0)).yzx, 0.1 /*h*/, 0.11 /*r*/) - 0.01;\n    t = sUnion(t, cylinder, 0.1);\n    \n    float tCross = sdCross(p.xy, vec2(0.23, 0.06), 0.02);\n    tCross = sIntersect(tCross, \n              sdCappedCylinder((p - vec3(0, 0, 0.099)).yzx, 0.01 /*h*/, 0.11 /*r*/)- 0.03, 0.01);\n              \n    t = sSubtract(tCross - 0.003, t, 0.01);\n    ADD(tCross, DPAD_ALL)\n}\n\nvoid buttons(vec3 p, inout float t, inout float t2, inout int materialIndex) {\n    const float offset = 0.13;\n    vec3 btnPositions[4] = vec3[4](\n        vec3( offset, 0,  0.02), // bottom\n        vec3(-offset, 0,  0.02), // top\n        vec3(0,  offset,  0.02), // right\n        vec3(0, -offset,  0.02) // left\n    );\n    for(int i=0;i<4;++i) t = sUnion(t, sdSphere(p - btnPositions[i], 0.1), 0.05);\n    for(int i=0;i<4;++i) t = sSubtract(sdSphere(p - btnPositions[i] - vec3(0,0,0.14), 0.1), t, 0.02);\n    \n    ADD(sdSphere(p - btnPositions[0], 0.09), BUTTON_LEFT)\n    ADD(sdSphere(p - btnPositions[1], 0.09), BUTTON_RIGHT)\n    ADD(sdSphere(p - btnPositions[2], 0.09), BUTTON_UP)\n    ADD(sdSphere(p - btnPositions[3], 0.09), BUTTON_DOWN)\n}\n\nvoid smallButtons(vec3 p, inout float t, inout float t2, inout int materialIndex) {\n\n    vec3 btnPositions[3] = vec3[3](vec3(-0.4, .1, 0.39), vec3(-0.4, -.1, 0.39), vec3(-0.28, 0, 0.39) );\n    const float btnLength = 0.06;\n    const float btnWidth = 0.03;\n    for(int i=0;i<3;++i) t  = sUnion(t, sdVerticalCapsule(p - btnPositions[i], btnLength, btnWidth), .07);\n    for(int i=0;i<3;++i) t  = sSubtract(sdVerticalCapsule(p - btnPositions[i] - vec3(0,0,0.03), btnLength, btnWidth), t, .02);\n    \n    ADD(sdVerticalCapsule(p - btnPositions[0], btnLength, btnWidth * .8), SELECT_BUTTON_0);\n    ADD(sdVerticalCapsule(p - btnPositions[1], btnLength, btnWidth * .8), SELECT_BUTTON_1);\n    ADD(sdVerticalCapsule(p - btnPositions[2], btnLength, btnWidth * .8), SELECT_BUTTON_2);\n}\n\nfloat topSide(vec3 p){\n    return sIntersect(sdPlane(p,  vec3(-.866, 0, -0.5)) - .39, sdPlane(p, vec3(-0.26, 0.966, 0.0)) - 0.77, 0.4);\n}\n\nvoid mainBody(vec3 p, inout float t){\n    t = sdEllipsoid(p - vec3(-0.2,0,0), vec3( .8,  3.5, .4 ));\n    t = sIntersect(topSide(p), t, 0.4); // top\n}\n\nvoid triggersShoulders(vec3 p, inout float t, inout float t2, inout int materialIndex, float tMainBody, vec2 triggerScale){\n    const vec3 triggerAxCenter = vec3(-0.43, 0.47, 0.22);\n    bool left = false;\n    if(p.y < 0.) { p.y=-p.y; left = true; }\n    p -= triggerAxCenter; // trigger axis center\n    float tTrigShould = sdEllipsoid(p, vec3(.4,.14,.4));\n    \n    vec3 pInitRot = rotateY(INIT_TRIG_SHOULD_ROTATION) * p;\n    vec3 pTrigRot = rotateY(saturate(left ? triggerScale.x : triggerScale.y) * (-30. / 57.3)) * pInitRot;\n\n    float tSmallSphere = sdCappedCylinder(p, .0, .14)-0.05;\n    tSmallSphere = sSubtract(sdPlane(pInitRot-vec3(0, 0, 0.02), vec3(0,0,-1)), tSmallSphere, 0.03);\n\n    t = sUnion(sIntersect(tSmallSphere- 0.0, tMainBody - 0.0, 0.01), t, 0.1);\n    \n    float tTrig = sIntersect(abs(topSide(pTrigRot + triggerAxCenter) - 0.07) - 0.03, tTrigShould, 0.05);\n    float tShould = sIntersect(abs(topSide(pInitRot + triggerAxCenter) - 0.07) - 0.03, tTrigShould, 0.05);\n    \n    \n    tTrig = sUnion(tSmallSphere, tTrig, 0.06);\n    tShould = sUnion(tSmallSphere, tShould, 0.06);\n    \n    \n    tTrig = sSubtract(sdCylinder(pTrigRot, vec3(-.28, -.38, 0.23)), tTrig, .03);\n\n    tShould = sSubtract(sdPlane(\n    pInitRot-vec3(0, 0, 0.05), vec3(0,0,-1)), tShould, 0.03);\n    \n    tTrig = sSubtract(sdPlane(pTrigRot-vec3(0, 0, -0.09), vec3(0,0,-1)), tTrig, 0.06);\n    tShould = sSubtract(sdPlane(pInitRot-vec3(0, 0, -0.07), vec3(0,0,1)), tShould, 0.06);\n    \n    ADD(tShould, (left ? SHOULDER_LEFT : SHOULDER_RIGHT));\n    ADD(tTrig, (left ? TRIGGER_LEFT : TRIGGER_RIGHT));\n    //t2 = min(t2, sdCylinder(p, vec3(0,0, 0.02))); // visualize axis center\n}\n\n\nvec3 map(vec3 p) // t, materialIndex, AO\n{\n    float t = 999999999., t2 = 999999999.; // separate for moving parts to calc AO between t and t2\n    \n    vec3 pmy = p; pmy.y = abs(pmy.y);\n    \n    mainBody(pmy, t);\n    float tMainBody = t; // used for triggers\n    t = sIntersect(sdPlane(pmy, vec3(0,0,-1)) - 0.1, t, 0.2); // lower bound\n\n    int materialIndex = 0;\n    float tDpad, tStick0, tStick1;\n    vec4 tButtons, tSmallButtons, tTrig;\n    \n    vec2 trigScales = sin(iTime * vec2(2,3.1)) * 1.5 + 0.5;\n    \n    pipka(p - leftStickPos, t, t2, materialIndex, vec2(sin(iTime * 1.7), sin(iTime * 3.)) ); // left stick\n    materialIndex = materialIndex << 1;\n    pipka(p - vec3(-0.05, -0.2, 0.33), t, t2, materialIndex, vec2(sin(iTime*1.9), sin(iTime * 3.1)) ); // right stick\n\n    triggersShoulders(p, t, t2, materialIndex, tMainBody, trigScales);    \n    dPad (p - dPadPos, t, t2, materialIndex);\n    \n    buttons (p - vec3(-0.28, -0.42, 0.33), t, t2, materialIndex);   \n    smallButtons(p, t, t2, materialIndex);\n    \n    t = sSubtract(sIntersect(sdPlane(pmy,vec3(-1,0,0))+ .1, sdPlane(pmy, vec3(-0.5,0.866,0.0))-0.25,0.2), t, 0.1); // lower\n    t = sSubtract(sIntersect(sdPlane(pmy,vec3(0,0,1)) -.05, sdPlane(pmy, vec3(-0.1,0.866,0.5))-0.35,0.2), t, 0.3); // under\n    float ao = sUnion(t, t2, 0.06);\n    \n    if(t < t2) { t2 = t; materialIndex = 0; }\n    return vec3(t2, materialIndex, ao);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy * map( pos + e.xyy*ep ).x + \n                      e.yyx * map( pos + e.yyx*ep ).x + \n                      e.yxy * map( pos + e.yxy*ep ).x + \n                      e.xxx * map( pos + e.xxx*ep ).x );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor -= fragColor;\n    float time = iTime * 1.0;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec2 uv = -1. + 2. * fragCoord / iResolution.xy; uv.y *= iResolution.y / iResolution.x;\n    vec3 target = vec3(-0.2, 0, 0.2); \n    vec2 angle = mo * 8. + vec2(-1,-2.2);\n    \n    // comment below for mouse movement\n    // angle.y = -2.3; angle.x = iTime * PI / 10.;\n\n    mat3 rotationMatrix = rotateXYZ(vec3(0, angle ));\n    \n    vec3 ro = target + rotationMatrix * vec3(0, 0, -5.);\n    vec3 rd = rotationMatrix * normalize(vec3(uv.xy, 3.5));  \n    const float far = 10.;\n\n    float t = 0.0;\n    int materialIndex = 0;\n    float ao = 0.;\n    for(int i = 0; i < 128; i++) {\n        vec3 p = ro + t*rd;\n        vec3 result = map(p);\n        float h = result.x;\n        materialIndex = int(result.y);\n        ao = result.z;\n        if(abs(h) < 0.001 || t > far) break;\n        t += h;\n    }\n\n    vec3 col = vec3(0.0);\n\n    if( t < far) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        ao = smoothstep(0., -0.01, ao); ao*=ao*ao;\n        col = Paint(pos, nor, rd, materialIndex, 1.-ao);\n    } else {\n       col = LDRtoHDR(texture( iChannel1, rd.yzx ).rgb);\n    }\n\n    \n   col = HDRtoLDR(col);\n   //col = sqrt( col );\n   fragColor = vec4(col, 1.);\n \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.141592653589793;\n#define saturate(x) clamp(x, 0.,1.)\n\n\n\n// UNION INTERPOLATION TYPES\n// https://www.shadertoy.com/view/DlVcW1\n#define UNION_TYPE 1\nfloat sUnion( float a, float b, float k )\n{\n// Quadratic\n#if (UNION_TYPE == 0)\n    \n    //k *= 4.0;\n    k *= 0.6;\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n    \n// Cubic\n#elif (UNION_TYPE == 1)\n   \n    //k *= 6.0;\n    k *= 0.9;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n\n// Quartic\n#elif (UNION_TYPE == 2)\n{\n    //k *= 16.0/3.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*(4.0-h)*k*(1.0/16.0);\n}\n\n// Circular\n#elif (UNION_TYPE == 3)\n\n    //k *= 1.0/(1.0-sqrt(0.5));\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - k*0.5*(1.0+h-sqrt(1.0-h*(h-2.0)));\n\n// Exponential\n#elif (UNION_TYPE == 4)\n\n    return -k*log2( exp2( -a/k ) + exp2( -b/k ) );\n\n// Sigmoid\n#elif (UNION_TYPE == 5)\n\n    k *= 0.1;\n    float x = b-a;\n    \n    return a + x/(1.0-exp2(x/k));\n\n\n// SquareRoot\n#elif (UNION_TYPE == 6)\n    k *= 0.4;\n    float x = b-a;\n    return 0.5*( a+b-sqrt(x*x+k*k) );\n\n#endif\n} // sUnion\nfloat sSubtract(float d1, float d2, float k) { return -sUnion(d1,-d2,k); }\nfloat sIntersect( float d1, float d2, float k) { return -sUnion(-d1,-d2,k); }\n\n\n// DISTANCE FUNCTIONS\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane( vec3 p, vec3 n ) { return dot(p, n); }\nfloat sdPlaneShell( vec3 p, vec3 n, float thickness ) { return abs(dot(p, n)) - thickness; }\n\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float r ) {  return length(p) - r; }\nfloat sdSphereShell( vec3 p, float r, float thickness ) {  return abs(length(p) - r) - thickness; }\n\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h ); return length( p ) - r;\n}\n\nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;    \n\tvec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k); \n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n// ROTATIONS\n\nmat3 rotateXYZ(vec3 angle) {\n    float sx = sin(angle.x); float cx = cos(angle.x);\n    float sy = sin(angle.y); float cy = cos(angle.y);\n    float sz = sin(angle.z); float cz = cos(angle.z);\n    return mat3(\n\tcx*cy\t\t\t\t,cx*sy\t\t\t\t,sx,\n\tsz*sx*cy-cz*sy\t\t,sz*sx*sy+cz*cy\t\t,-sz*cx,\n\t-(cz*sx*cy+sz*sy)\t,cy*sz-cz*sx*sy\t\t,cz*cx);\n}\n\nmat3 rotateY(float angleY) {\n    float sy = sin(angleY); float cy = cos(angleY);\n    return mat3( cy, 0., sy, 0., 1, 0., -sy , 0., cy );\n}\n\nvec3 pal( in float t, vec3 c, vec3 d ){ return .5 + .5 * cos( 6.28318*(c*t+d) ); }\n\n\n\n// https://www.shadertoy.com/view/ltVBWc\nconst float whiteSoftness = 0.15;\nvec3 HDRtoLDR( vec3 col )\n{\n    // soft clamp to white (oh this is so good)\n    float w2 = whiteSoftness*whiteSoftness;\n    col += w2;\n    col = (1.-col)*.5;\n    col = 1. - (sqrt(col*col+w2) + col);\n    \n    // linear to sRGB (approx)\n    col = pow( col, vec3(1./2.2) );\n\n    return col;\n}\n\nvec3 LDRtoHDR( vec3 col )\n{\n    // sRGB to linear (approx)\n    col = pow( col, vec3(2.2) );\n    \n    col = clamp(col,0.,.99);\n    \n    float w2 = whiteSoftness*whiteSoftness;\n    col = (w2 - col*col + 2.*col - 1.)/(2.*(col - 1.)); // inverted by wolfram\n    col = 1.-col*2.;\n    col -= w2;\n    \n    return col;\n}\n","name":"Common","description":"","type":"common"}]}