{"ver":"0.1","info":{"id":"fl3fRH","date":"1662646026","viewed":153,"name":"walk on spheres","username":"Veemon","description":"runs walk on sphere and samples if we exit in the upper half plane rotated at some angle","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["wos"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 frag_color, in vec2 frag_coord ){\n    // coordinates in [-1,1] ish\n    vec2 norm_coords = (frag_coord.xy / iResolution.xy);\n    norm_coords      =  norm_coords * 2.0f - 1.0f;\n    norm_coords.x   *= (iResolution.x/iResolution.y);\n    \n    float mag_sq = norm_coords.x*norm_coords.x + norm_coords.y*norm_coords.y;\n    \n    // output\n    vec4 value = texelFetch(iChannel0, ivec2(frag_coord), 0);\n    \n    #if 1\n        // sphere masking\n        const float sphere_radius_sq = 0.5;\n        float sphere = 1.0f-smoothstep(sphere_radius_sq-0.01f, sphere_radius_sq, mag_sq);\n        value *= sphere;\n    #endif\n    \n    frag_color = vec4(pow(value.rgb, vec3(0.4545)), 1.0); // slight gamma correction\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PHI = 1.61803398874989484820; // Î¦ = Golden Ratio \nconst float TAU = 6.28318530717958647693;\n\nfloat gold_noise(in vec2 xy, in float seed) {\n    return fract(tan(distance(xy*PHI, xy)*seed)*xy.x);\n}\n\nfloat nrand( vec2 n ){\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n#define SQ_LEN(a) (a.x*a.x + a.y*a.y)\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ){\n    // coordinates in [-1,1] ish\n    vec2 norm_coords = (frag_coord.xy / iResolution.xy);\n    norm_coords      =  norm_coords * 2.0f - 1.0f;\n    norm_coords.x   *= (iResolution.x/iResolution.y);\n\n    const float sphere_radius_sq = 0.5f;\n    \n    // walk on sphere\n    #define N_SAMPLES     4\n    vec2 next_points[N_SAMPLES];\n    for (int i = 0; i < N_SAMPLES; i++) {\n        next_points[i] = norm_coords;\n    }\n    \n    float dist_to_boundary = 1000.0f;\n    for (int j = 0; j < N_SAMPLES; j++) {\n        for(int i = 0; i < 32; i++) {\n            float next_point_mag_sq = SQ_LEN(next_points[j]);\n\n            #if 1\n                // annulus\n                dist_to_boundary = abs(sphere_radius_sq - next_point_mag_sq);\n            #else\n                // disc\n                dist_to_boundary = sphere_radius_sq - next_point_mag_sq;\n            #endif\n\n            #if 1\n                float sample_point = TAU * gold_noise(frag_coord, fract(iTime));\n            #else\n                float sample_point = TAU * nrand(frag_coord + fract(iTime));\n            #endif\n            \n            next_points[j] += dist_to_boundary*vec2(cos(sample_point), sin(sample_point));\n        }\n        next_points[j] *= (sphere_radius_sq / (SQ_LEN(next_points[j])+1e-10)); // projection\n    }\n    \n    // average boundary samples -- FIXME: this does nothing? why no convergence?\n    vec2 next_point = vec2(0);\n    for (int i = 0; i < N_SAMPLES; i++) {\n        next_point += next_points[i];\n    }\n    next_point /= float(N_SAMPLES);\n    \n    // color by if the sample walk exited in upper half plane rotated by angle t\n    #if 1\n    {\n        float t = 0.5f * iTime;\n        float c = cos(t);\n        float s = sin(t);\n        mat2 rot = mat2( c, -s, s, c );\n        next_point *= rot;\n    }\n    #endif\n    float value = smoothstep(0.0f, 0.001f, next_point.y);\n\n    // average between previous trial\n    const float weight = 0.0125f;\n    float prev_value = texelFetch(iChannel0, ivec2(frag_coord), 0).r;\n    float sample_value = weight*value + (1.0f-weight)*prev_value;\n    // sample_value = value; // debug -- to see contribution for each time step\n    \n    frag_color.rgb = vec3(sample_value);\n}","name":"Buffer A","description":"","type":"buffer"}]}