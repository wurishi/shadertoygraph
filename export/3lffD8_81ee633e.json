{"ver":"0.1","info":{"id":"3lffD8","date":"1596540533","viewed":455,"name":"Simple Volume Rendering - Smoke","username":"mithrandir","description":"Simple volume rendering experiment for learning purposes.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_DIR vec3(0.8, 0.2, 1.0)\n#define DENSITY_THRESHOLD 0.5\n#define DENSITY_MULTIPLIER 2.0\n#define STEPS_NUM 100.0\n#define BILLOW_NOISE false\n#define NOISE_OCTAVES 2\n#define PREVIEW_NOISE false\n\n//Fast noise from https://www.shadertoy.com/view/XslGRr\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n\tvec2 uv = (p.xy+vec2(37.0,239.0)*p.z) + f.xy;\n    vec2 rg = textureLod(iChannel0,(uv+0.5)/256.0,0.0).yx;\n\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm(vec3 p, int octaves, bool billow)\n{\n    float noiseSum = 0.0;\n    float amplitude = 1.0;\n    float frequency = 1.0;\n    \n    for (int i = 0; i < octaves; i++)\n    {\n        noiseSum += abs(noise(p*frequency)*amplitude);\n        frequency*=2.0;\n        amplitude*=0.5;\n    }\n    \n    if (!billow)\n        noiseSum = 1.0 - noiseSum;\n    \n    return noiseSum * 0.5;\n}\n\n\nRay CreateCameraRay(vec2 uv)\n{\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, CAMERA_HEIGHT, -CAMERA_DISTANCE);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    \n    return CreateRay(ro, rd);\n}\n\nRayHit Trace(Ray ray)\n{\n    RayHit hit = CreateRayHit();\n    IntersectSphere(ray, hit, vec4(vec3(0.0, 0.0, 0.0), 5.0));\n    return hit;\n}\n\nfloat SampleDensity(vec3 pos)\n{\n   pos.y -= iTime;\n   float warp = noise(vec3(pos.x + iTime * 2.0, pos.y, pos.z)*1.5)*0.9;\n   float n =  fbm(((pos*2.0 + warp) * 0.2), NOISE_OCTAVES, BILLOW_NOISE) + 0.5 * 0.5;\n   \n   float density = max(0.0, n - DENSITY_THRESHOLD) * DENSITY_MULTIPLIER;\n   return density;\n}\n\nvec3 Shade(RayHit hit, Ray ray, float transmitance)\n{\n    vec3 LightDir = normalize(LIGHT_DIR);\n    \n    float dif = clamp(dot(hit.Normal, LightDir), 0.0, 1.0);\n    vec3 reflection = normalize(2.0 * dif * hit.Normal - LightDir);\n    float specular = pow(clamp(dot(reflection, -ray.Direction), 0.0, 1.0), 32.0) * dif;\n    \n    vec3 col = vec3(0.7) * (1.0 - transmitance);\n    return 0.1 + col * dif + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinates from -1 to 1\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0.0);\n    \n    Ray ray = CreateCameraRay(uv);\n    \n    RayHit hit = Trace(ray);    \n    \n    \n    if (hit.Distance > 0.0)\n    {\n        float CloseDst = hit.Distance;\n        float FarDst = hit.FarDistance;\n\n        float TravelledDst = 0.0;\n        float StepSize = FarDst / STEPS_NUM;\n        float dstLimit = FarDst;\n        float TotalDensity = 0.0;\n        while (TravelledDst < dstLimit)\n        {\n            vec3 rayPos = ray.Origin + normalize(ray.Direction) * (CloseDst + TravelledDst);\n            TotalDensity += SampleDensity(rayPos) * StepSize;\n            TravelledDst += StepSize;\n        }\n        \n        float transmitance = exp(-TotalDensity);\n        \n        col = mix(vec3(0.1,0.2, 0.5), vec3(0.0, 0.4, 0.2), 1.0 - transmitance) * (1.0 - transmitance);//Shade(hit, ray, transmitance);\n    }\n    \n    \n    if (PREVIEW_NOISE)\n    \tcol = vec3(fbm(vec3(uv.x*5.0, uv.y*5.0, 0.0), NOISE_OCTAVES, BILLOW_NOISE) + 0.5 * 0.5);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define CAMERA_DISTANCE 5.0\n#define CAMERA_HEIGHT 3.0\n#define PI 3.14159265359\n\nstruct Ray\n{\n    vec3 Origin;\n    vec3 Direction;\n    vec3 Energy;\n};\n\nstruct RayHit\n{\n  vec3 Position;\n  float Distance;\n  float FarDistance;\n  vec3 Normal;\n  vec2 uv;\n  int MaterialId;\n};\n    \nmat2 Rot(float a) \n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}  \n    \nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z)\n{\n    vec3 f = normalize(l-p),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = p+f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i-p);\n    return d;\n}\n\nRay CreateRay(vec3 ro, vec3 rd)\n{\n    Ray ray;\n    ray.Origin = ro;\n    ray.Direction = rd;\n    ray.Energy = vec3(1.0);\n    return ray;\n}\n\nRayHit CreateRayHit()\n{\n    RayHit hit;\n    hit.Position = vec3(0.0);\n    hit.Distance = -1.;\n    hit.FarDistance = -1.;\n    hit.Normal = vec3(0.0);\n    hit.uv = vec2(0.0);\n    return hit;\n}\n    \nvoid IntersectSphere(Ray ray, inout RayHit hit, vec4 sphere)\n{\n    //get the vector from the center of this circle to where the ray begins.\n\tvec3 m = ray.Origin - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, ray.Direction);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    \n    hit.FarDistance = -b + sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }    \n\n    //Check if the hitted point is closer to the camera\n    if (collisionTime < hit.Distance || hit.Distance == -1.0)\n    {\n        // return the time t that the collision happened, as well as the surface normal\n    \tvec3 p = ray.Origin + ray.Direction * collisionTime;\n        // calculate the normal, flipping it if we hit the inside of the sphere\n    \tvec3 normal = normalize((ray.Origin+ray.Direction*collisionTime) - sphere.xyz) * normalMultiplier;\n        \n        hit.Distance = collisionTime;\n        hit.Position = p;\n        hit.Normal = normal;\n        \n        //Calculate uv coordinates at hit point\n        vec3 d = normalize(p - sphere.xyz);\n        float u = 0.5 + atan(d.z, d.x)/ 2.0*PI;\n        float v = 0.5 - asin(d.y)/PI;\n        hit.uv = vec2(u,v);\n        \n        hit.MaterialId = 1;\n    }    \n}","name":"Common","description":"","type":"common"}]}