{"ver":"0.1","info":{"id":"wdGBDW","date":"1607114919","viewed":47,"name":"basic 2d-rostro-v3","username":"jorge2017a1","description":"basic 2d-rostro-v3","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["basic2drostrov3"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//----por jorge2017a -......jorge flores p.\n//basic 2d rostro-v3\n//04/dic/2020\n\n\n\n\nfloat oU( float d1, float d2 ) { return  min(d1,d2); }\nfloat oS( float d1, float d2 ) { return max(-d1,d2); }\nfloat oI( float d1, float d2 ) { return max(d1,d2); }\n\n\nvec2 oU2( vec2 d1, vec2 d2 ) \n{\n    if (d1.x<d2.x)\n       return d1; \t\n    else\n       return d2;\n}\n\nvec2 oS2( vec2 d1, vec2 d2 )\n{\n    if  (-d1.x<d2.x)\n        return d1;\n    else\n        return d2;\n}\n\nvec2 oI2( vec2 d1, vec2 d2 ) \n{\n    if (d1.x>d2.x)\n       \treturn d1;\n    else\n        return d2;\n}\n\nfloat f_width(float f)\n{\n    return sqrt(dFdx(f)*dFdx(f) + dFdy(f)*dFdy(f));\n}\n\nvec4 render(float d, vec3 color, float stroke)\n{\n    float fw = f_width(d);\n    float anti = fw * 1.0;\n    float fw_stroke = fw*stroke;\n    vec4 strokeLayer = vec4(vec3(0.05), 1.0-smoothstep(-anti, anti, d - fw_stroke));\n    vec4 colorLayer = vec4(color, 1.0-smoothstep(-anti, anti, d));\n\n    if (stroke < 0.000001) {\n    \treturn colorLayer;\n    }\n    //return mix(vec4(0.0),vec4(1.0),smoothstep(0.0,0.04,d));\n    return  vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\n\nvec2 vehiculo(vec2 p)\n{    \n    float b1= sdBox(p-vec2(0.0,0.0), vec2(0.22,0.08) );\n    float c1= sdCirc(p-vec2(-0.1,-0.1), 0.05);\n    float c2= sdCirc(p-vec2(0.1,-0.1), 0.05);\n    \n    vec2 res= vec2(9999.0,0.0);\n    b1=oS(c1,b1);\n    b1=oS(c2,b1);\n    \n    res=oU2(res, vec2(b1,1.0));\n    res=oU2(res, vec2(c1,2.0));\n    res=oU2(res, vec2(c2,2.0));\n    \n    return res;\n}    \n\nvec2 nubes(vec2 p)\n{    \n    vec2 centro=vec2(0.0,0.0);\n    \n    float c1a= sdCirc(p-vec2(0.0,0.05), 0.105);\n    float c2a= sdCirc(p-vec2(0.15,0.02), 0.065);\n    float c3a= sdCirc(p-vec2(-0.15,0.02), 0.065);\n    float b1a=sdBox(p-vec2(0.0,-0.09), vec2(0.28,0.08 ) );\n    \n    float resa=oU(c1a, c2a);\n    resa=oU(resa, c3a);  \n    \n    resa=oS(  b1a,resa ); \n    vec2 res2=vec2(resa,0.0);\n    \n    \n\treturn res2;  \n}\n\n\nvec2 nubesv2(vec2 p)\n{\n    vec2 centro=vec2(0.0,0.0);\n    \n    float c1a= sdCirc(p-vec2(0.0,0.05), 0.205);\n    float c2a= sdCirc(p-vec2(0.25,0.02), 0.125);\n    float c3a= sdCirc(p-vec2(-0.18,0.02), 0.125);\n    float b1a=sdBox(p-vec2(0.0,-0.01), vec2(0.6,0.16 ) );\n    \n    float resa=oU(c1a, c2a);\n    resa=oU(resa, c3a);  \n    vec2 res2=vec2(resa,0.0);\n    \n    \n\treturn res2;  \n}\n\n\n//----------------------=================------------------\n\n float rnd;\n float intensity;\n float colorswap;\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 spawn(  in vec2 fragCoord , float time)\n{\n\t\n    vec4 fragColor;\n    \n    vec2 p=fragCoord;\n\n    vec4 gColor;\n    vec2 gTexCoord;\n    gColor=vec4(1.0,1.0,1.0,1.0*sin(time));\n    gTexCoord=  p;  \n    intensity=1.0;\n    rnd=2.0*sin(time);    \n    \n\tfloat f = max(0.0, rand(vec2(fragCoord.y, fragCoord.x+rnd)) - rand(vec2(0.0, fragCoord.x+rnd))*intensity);\n\n\t\n    vec4 color = vec4(0, f, 0, texture(iChannel0, gTexCoord).w * gColor.w * f);\n\t\n\t\n    vec4 c = texture(iChannel0, gTexCoord);\n    \n\tfloat r = c.r; float b = c.b; float g = c.g;\n\n\tfloat swap2 = (0.5f - abs(0.5f - colorswap))*2.0f;\n\tc.r = r*(1.0f-swap2) + g*swap2;\n\tc.b = b*(1.0f-swap2) + g*swap2;\n\tc.g = g*(1.0f-swap2) + b*swap2;\n\t\n\tfloat swap1 = colorswap * (1.0f - swap2);\n\tr = c.r; b = c.b;\n\t\n\tc.r = r*(1.0f-swap1) + b*swap1;\n\tc.b = b*(1.0f-swap1) + r*swap1;\n\t\n\tvec4 c1 = c * gColor;\n\t\n\t//c1.w *= 1.0f-intensity;\n\t//c1.w -= gl_FragCoord.y*0.1f;\n\t\n\tfragColor = c1*(1.0-intensity*2.0) + color*intensity*2.0;\n    return fragColor;\n}\n\n\n//----------------------=================------------------\nvec4 television(vec2 p)\n{\n    vec4 resp=spawn(  p ,iTime);\n    \n    float b1a=sdBox(p-vec2(-2.5,-1.01), vec2(0.8,0.816 ) );\n    float  s1= sdSegment( p-vec2(0.15,-2.2), vec2(-2.5,2.0), vec2(-3.0,2.3) );\n    float  s2= sdSegment( p-vec2(0.15,-2.2), vec2(-2.5,2.0), vec2(-2.0,2.3) );\n    \n    b1a=oU(s1, b1a);\n    b1a=oU(s2, b1a);\n    \n   \tresp=vec4(resp.xyz,b1a);\n    return resp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=0.5;\n    uv*=4.5;\n    uv.x*= iResolution.x/iResolution.y;\n\tvec2 p=uv;\n    \n    \n   \n    \n    \n    \n    float tt=iTime;\n    float cOjoPupilaIzq = sdCirc(p-vec2(-0.1+0.15*sin(tt),0.0), 0.02) ;\n    float cOjoPupilaDer = sdCirc(p-vec2(0.5+0.15*sin(tt),0.0), 0.02) ;\n    \n    float cOjoIzq = sdCirc(p-vec2(-0.1,0.0), 0.2) ;\n    float cOjoDer = sdCirc(p-vec2(0.5,0.0), 0.2) ;\n    float cRostro = sdCirc(p-vec2(0.25,-0.2), 1.0) ;\n    \n    float sBoca= sdEllipse(p-vec2(0.2,-0.6), vec2(0.2,0.1+0.12*sin(mod(tt,4.0))) );\n    \n    float spelo= sdEllipse(p-vec2(0.2,0.1), vec2(1.3,1.1) );\n    \n    float px=-2.0+mod(iTime*0.5, 12.0 );\n    \n    //-----------\n    float cx=0.19;\n    float px2=mod(10.0, cx )-cx*0.5;\n    \n    float t2=mod(iTime, 10.0);\n    vec2 mover=p- vec2(px2+t2,0.0);\n    //-------------\n    \n\tvec2 mover2=opRep2D(p-vec2(0.0+px,0.0), vec2(4.0,8.0) );\n    vec2 mover3=opRep2D(p-vec2(2.0+px2,0.0), vec2(15.0,9.0) );\n    \n\t\n    \n    vec2 n1= nubes(mover2-vec2(0.0,1.5));\n    \n    vec2 n2= nubesv2(mover-vec2(-2.0,1.8));\n    vec2 n3= nubesv2(mover-vec2(-5.5,0.8));\n    vec2 n4= nubesv2(mover-vec2(-3.5,1.8));\n    \n    \n        \n    vec3 col=vec3(1.0);\n    \n    vec4  colt=television(p);\n    fragColor = vec4(col,1.0);\n    \n    // Time varying pixel color\n    vec3 colc1=vec3(1.0);\n    vec4 b1 = render(cOjoIzq, colc1,3.);\n    \n    vec3 colc2=vec3(1.0);\n    vec4 b2 = render(cOjoDer, colc2,3.);\n    \n    \n    vec3 colc1a=vec3(0.0);\n    vec4 b1a = render(cOjoPupilaIzq, colc1a,3.);\n    \n    vec3 colc2a=vec3(0.0);\n    vec4 b2a = render(cOjoPupilaDer, colc2a,3.);\n    \n    \t\n    vec3 colc3= getColor(17);\n    vec4 b3 = render(cRostro, colc3,3.);\n    \n    \n    \n    vec3 colc4= getColor(2);\n    vec4 b4 = render(sBoca, colc4,3.);\n    \n    \n    vec3 colc5= getColor(18);\n    vec4 b5 = render(spelo, colc5,3.);\n    \n    vec3 colc6= getColor(23);\n    vec4 bNube1 = render(n1.x, colc6,3.);\n    \n    vec3 colc7= getColor(22);\n    vec4 bNube2 = render(n2.x, colc7,3.);\n    \n    \n    vec3 colc8= getColor(15);\n    vec4 bNube3 = render(n3.x, colc8,3.);\n    \n    vec3 colc9= getColor(21);\n    vec4 bNube4 = render(n4.x, colc9,3.);\n    \n    \n    vec4 bTeve = render(colt.w, colt.xyz,3.);\n    \n    \n    fragColor = mix(fragColor, b5, b5.a); //pelo\n    fragColor = mix(fragColor, b3, b3.a);//rostro\n    fragColor = mix(fragColor, b1, b1.a); //ojo izq\n    fragColor = mix(fragColor, b2, b2.a); //ojo der\n    \n    fragColor = mix(fragColor, b1a, b1a.a); //pupila izq\n    fragColor = mix(fragColor, b2a, b2a.a); //pupila der\n    \n    \n    fragColor = mix(fragColor, b4, b4.a);\n    \n    fragColor = mix(fragColor, bNube1, bNube1.a);\n\tfragColor = mix(fragColor, bNube2, bNube2.a);\n    fragColor = mix(fragColor, bNube3, bNube3.a);\n    fragColor = mix(fragColor, bNube4, bNube4.a);\n    \n    fragColor = mix(fragColor, bTeve, bTeve.a);\n    \n    \n    \n    fragColor = pow(fragColor,vec4(0.5));\n\t\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//referencia\n//https://iquilezles.org/articles/distfunctions2d\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n#define SS(U) smoothstep(3./R.y,0.,U)\n\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0)/255.0,  //0\nvec3(255.,255.,255.)/255.0, //1\nvec3(255,0,0)/255.0,  //2\nvec3(0,255,0)/255.0,   //3\nvec3(0,0,255)/255.0,   //4\nvec3(255,255,0)/255.0,  //5\nvec3(0,255,255)/255.0,  //6 \nvec3(255,0,255)/255.0,   //7\nvec3(192,192,192)/255.0,  //8\nvec3(128,128,128)/255.0,  //9\nvec3(128,0,0)/255.0,   //10\nvec3(128,128,0)/255.0,  //11\nvec3(0,128,0)/255.0,   //12\nvec3(128,0,128)/255.0,  //13\nvec3(0,128,128)/255.0,  //14\nvec3(0,0,128)/255.0,    //15\nvec3(255, 204, 188)/255.0,  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(247./255., 168./255.,  184./255.),  //21\nvec3(0, 1, 1),                           //22 \nvec3(85./255., 205./255., 252./255.),    //23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),  //24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),       //25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),     //26\nvec3(0.1, 0.5, 1.0),                           //27   \nvec3(0.0, 0.6, 0.0),                       //28 \nvec3(0.1,0.1,0.7),                          //29\nvec3(0.99, 0.2, 0.1) //30\n);\n\n//----------------------------------------------------\nvec3 getColor(int i)\n{    \n   // if (i==-2 ) {return mObj.color; }       \n    if (i>-1 ) \n\t\treturn Arrcolores[i];\n}\n///--------------------------------------------\n\nvec2 opRep2D( in vec2 p, in vec2 c )\n{\n    vec2 q = mod(p+0.5*c,c)-0.5*c; \n    return  q ;\n}\n\n\n\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCirc(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nfloat sdStar5(in vec2 p, in float r, in float rf)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x,k1.y);\n    p.x = abs(p.x);\n    p -= 2.0*max(dot(k1,p),0.0)*k1;\n    p -= 2.0*max(dot(k2,p),0.0)*k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n    float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n    return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n}\n\n\n\nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\n","name":"Common","description":"","type":"common"}]}