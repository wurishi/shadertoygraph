{"ver":"0.1","info":{"id":"4XdSWM","date":"1719133766","viewed":26,"name":"ggx_tut","username":"dabingnn","description":"ggx","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["ggx"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 500\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n#define PI 3.14159265\n#define INVERSE_PI 1./3.14159265\n\nfloat D_GGX_v0(vec3 h, vec3 n, float roughness)\n{\n    float a2 = roughness * roughness * roughness * roughness;\n    float noh = clamp(dot(n, h), 0., 1.);\n    float G1 = noh * noh * (a2 - 1.) + 1.;\n    return a2 / (PI * G1 * G1);\n}\n\nfloat D_GGX_v1( vec3 h, vec3 n, float roughness )\n{\n    float NoH = clamp(dot(n, h), 0., 1.);\n    float a2 = roughness * roughness * roughness * roughness;\n\tfloat d = ( NoH * a2 - NoH ) * NoH + 1.;\t// 2 mad\n\treturn a2 / ( PI*d*d );\t\t\t\t\t// 4 mul, 1 rcp\n}\n\nfloat GV(vec3 n, vec3 v, float GK)\n{\n    return 1. / (clamp(dot(n, v), 0., 1.) * (1. - GK) + GK);\n}\n\n// G with normalize factor in GGX\nfloat G_GGX_v0(float roughness, vec3 n, vec3 l, vec3 v)\n{\n    float GK = (roughness + 1.) * (roughness + 1.) / 8.;\n    return GV(n, l, GK) * GV(n, v, GK) * 0.25;\n}\n\nfloat Vis_Schlick( float roughness, vec3 n, vec3 l, vec3 v)\n{\n    float a2 = roughness * roughness * roughness * roughness;\n    float NoV = clamp(dot(n, v), 0., 1.0);\n    float NoL = clamp(dot(n, l), 0., 1.0);\n\tfloat k = sqrt(a2) * 0.5;\n\tfloat Vis_SchlickV = NoV * (1. - k) + k;\n\tfloat Vis_SchlickL = NoL * (1. - k) + k;\n\treturn 0.25 / ( Vis_SchlickV * Vis_SchlickL );\n}\n\nvec3 F_Schlick( vec3 SpecularColor, vec3 v, vec3 h)\n{\n    float VoH = clamp(dot(v, h), 0., 1.);\n\tfloat Fc = pow( 1. - VoH, 5. );\t\t\t\t\t// 1 sub, 3 mul\n\t//return Fc + (1 - Fc) * SpecularColor;\t\t// 1 add, 3 mad\n\t\n\t// Anything less than 2% is physically impossible and is instead considered to be shadowing\n\treturn clamp(( 50.0 * SpecularColor.g ) * Fc + (1. - Fc) * SpecularColor, 0., 1.);\n}\n\nvec3 F_GGX_v0(vec3 F0, vec3 v, vec3 h)\n{\n    float voh = clamp(dot(v, h), 0., 1.);\n    float FPow = pow(2., -5.55473 * voh * voh - 6.98316 * voh);\n    return F0 + (1. - F0) * FPow;\n}\n\nvec3 lighting(vec3 ro, vec3 p, vec3 n)\n{\n    vec3 SpecularColor = vec3(0.95, 0.64, 0.54);\n    float roughness = 0.78;\n    vec3 LightDir = normalize(vec3(-0.3, 1., -0.8));\n    vec3 ViewDir = normalize(ro - p);\n    vec3 halfDir = normalize(ViewDir + LightDir);\n    vec3 LightCol = vec3(5);\n    //return vec3(Vis_Schlick(roughness, n, LightDir, ViewDir));\n    return LightCol * D_GGX_v1(halfDir, n, roughness)\n    * F_Schlick(SpecularColor, ViewDir, halfDir)\n    * Vis_Schlick(roughness, n, LightDir, ViewDir);\n}\n\nfloat getDist(vec3 p, out vec3 normal)\n{\n    vec4 Sphere = vec4(0.0, 2.0, 8.0, 2.0);\n    float sphereDist = length(p - Sphere.xyz) - Sphere.w;\n    float planeDist = p.y;\n    normal = vec3(0.0, 1.0, 0.0);\n    if(sphereDist < planeDist)\n    {\n        normal = normalize(p - Sphere.xyz);\n        return sphereDist;\n    }\n    else\n    {\n        return planeDist;\n    }\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, out vec3 normal)\n{\n    float dO = 0.0f;\n    for(int i= 0; ; ++i)\n    {\n        vec3 p = ro + rd * dO;\n        float ds = getDist(p, normal);\n        dO += ds;\n        if(ds < SURF_DIST) break;\n        if(dO > MAX_DIST || i == MAX_STEPS)\n        {\n            dO = -1.;\n            break;\n        }\n    }\n    return dO;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0., 1., 0.);\n    vec3 rd = normalize(vec3(uv.x ,uv.y, 1));\n    vec3 normal = vec3(0, 0, 0);\n    float dO = rayMarch(ro, rd, normal);\n    vec3 col = vec3(0., 0.0, 0.0);\n    if(dO > 0.)\n    {\n        col = lighting(ro, ro + rd * dO, normal);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}