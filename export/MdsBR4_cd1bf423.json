{"ver":"0.1","info":{"id":"MdsBR4","date":"1495136116","viewed":571,"name":"triTunnel","username":"nshelton","description":"raymarch triangle tunnel","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["tunnel","raymarch","triangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col;\n    vec2 delta = vec2(uv - 0.5)* 0.5 * sin(iTime);\n    \n    col.r = texture(iChannel0, uv + delta).r;\n    col.g = texture(iChannel0, uv).g;\n    col.b = texture(iChannel0, uv - delta).b;\n    col.a  = 1.0;\n\tfragColor = sqrt(col);\n\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat map(vec3 p)\n{\n    vec3 q = p;\n    vec3 c = vec3(0.5);\n    p.z = mod(p.z,c.z)-0.5*c.z;\n    \n    p = rotationMatrix(vec3(0,0,1), sin(floor(q.z / 0.5) / 2.0) * sin(iTime/5.0) * 1.0) * p;\n    \n    float rad = sin(q.z* 6.0) * 0.3 + 1.0;\n\tfloat outer = sdTriPrism(p, vec2(rad, 0.1));\n    float inner = sdTriPrism(p, vec2((sin(iTime + q.z * 10.0) * 0.2 + 0.6) * rad, 0.6));\n    \n    return opS(inner, outer);\n}\n\nvoid getCamPos(inout vec3 ro, inout vec3 rd)\n{\n    ro.z = iTime;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 _p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec3 ray = normalize(vec3(_p, 1.0));\n    vec3 cam = vec3(0.0, 0.0, 0.0);\n    \n    getCamPos(cam, ray);\n    \n    float depth = 0.0, d = 0.0, iter = 0.0;\n    vec3 p;\n    \n    for( int i = 0; i < 50; i ++)\n    {\n    \tp = depth * ray + cam;\n        d = map(p);\n                  \n        if (d < 0.001)\n\t\t\tbreak;\n                   \n\t\tdepth += d * 0.5;\n\t\titer++;\n                   \n    }\n    \n    vec3 col = vec3(1.0 - iter / 50.0);\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Buf A","description":"","type":"buffer"}]}