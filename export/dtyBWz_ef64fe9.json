{"ver":"0.1","info":{"id":"dtyBWz","date":"1701983469","viewed":59,"name":"projetv3","username":"roulia_","description":"Thomas le train dans l'espace sur la route arc-ciel (par qu'il ressemble quand même à un canon de Mario Kart)","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["glsl","thomasletrain","schrek","routearcciel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NB_PLAN 8\n#define NB_CIRCLE 5\n#define NB_SPHERE 3\n#define NB_CYL 4\n#define NB_CONE 1\n#define NB_LUM 5\n#define MOUVT 20.0*boucle\n\nfloat time;\nfloat boucle;\n\nmat3 rotateX(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, -s,\n        0.0, s, c\n    );\n}\n\nmat3 rotateY(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, 0.0, s,\n        0.0, 1.0, 0.0,\n        -s, 0.0, c\n    );\n}\n\nmat3 rotateZ(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat3(\n        c, -s, 0.0,\n        s, c, 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Lum {\n    vec3 Color;\n    vec3 Pos;\n};\n\nstruct Plan {\n    vec3 Dir1;\n    vec3 Dir2;\n    vec3 Color;\n    vec3 Center;\n    float h;\n    float w;\n};\n\nstruct Circle {\n    vec3 Dir1;\n    vec3 Dir2;\n    vec3 Color;\n    vec3 Center;\n    vec3 loc;\n    bool text;\n    float h;\n    float w;\n    float r;\n};\n\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n   vec3 Color;\n};\n\n\n\nstruct Cylinder {\n   vec3 Center;\n   vec3 Dir;  \n   vec3 Color;\n   float r;\n   float h;\n};\n\nstruct Cone {\n    vec3 Center;\n    vec3 Dir;\n    vec3 Color;\n    float r;\n    float s;\n    float h;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    vec3 vertical = vec3(0.0,0.0,1.0);\n    C.View = (LookAt - Obs) / length(LookAt - Obs);\n    C.Horiz = normalize(cross(vertical, C.View));\n    C.Up = normalize(cross(C.View,C.Horiz));\n    C.Obs = Obs;\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/2.0/tan(aperture * 3.1415 / 180.0 /2.0);\n    return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = C.View * C.z + (XY.x - 0.5 * C.W) * C.Horiz + (XY.y - 0.5 * C.H) * C.Up;\n   return r;\n}\n\nLum lum(in vec3 Color, in vec3 Pos) {\n    Lum L;\n    L.Color = Color;\n    L.Pos = Pos;\n    return L;\n}\n\nPlan plan(vec3 center, vec3 d1, vec3 d2, vec3 color, float h, float w) {\n    Plan P;\n    P.Dir1 = d1;\n    P.Dir2 = d2;\n    P.Center = center;\n    P.Color = color;\n    P.h = h;\n    P.w = w;\n    return P;\n}\n\nCircle circle(vec3 center, vec3 d1, vec3 d2, vec3 color, float h, float w, float r) {\n    Circle C;\n    C.Dir1 = d1;\n    C.Dir2 = d2;\n    C.Center = center;\n    C.Color = color;\n    C.text = false;\n    C.h = h;\n    C.w = w;\n    C.r = r;\n    return C;\n} \n\nCylinder cylinder(vec3 center, vec3 d, vec3 color, float r, float h) {\n    Cylinder C;\n    C.Center = center;\n    C.Dir = d;\n    C.Color = color;\n    C.r = r;\n    C.h = h;\n    return C;\n}\n\nCone cone(vec3 center, vec3 d, vec3 color, float r, float s, float h) {\n    Cone C;\n    C.Center = center;\n    C.Dir = d;\n    C.Color = color;\n    C.r = r;\n    C.s = s;\n    if (h>s) {h=s;}\n    C.h = h;\n    return C;\n}\n\nconst float ORIGINTX = -200.0;\nconst float LT = 6.0;\nconst float DLT = LT/2.0;\n\nPlan plans(int num) {\n    Plan P;\n\n    if (num == 0) {\n        P = plan(vec3(0.0,6.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(1, 0, 0),-1.0,1.0);\n    }\n    if (num == 1) {\n        P = plan(vec3(0.0,4.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(1.0, 0.2, 0),-1.0,1.0);  \n    }\n    if (num == 2) {\n        P = plan(vec3(0.0,2.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(1, 1, 0),-1.0,1.0);  \n    }\n    if (num == 3) {\n        P = plan(vec3(0.0,0.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(0,1,0),-1.0,1.0);\n    }\n    if (num == 4) {\n        P = plan(vec3(0.0,-2.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(0,0,1),-1.0,1.0);\n    }\n    if (num == 5) {\n        P = plan(vec3(0.0,-4.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(0.3, 0, 0.5),-1.0,1.0);\n    }\n    if (num == 6) {\n        P = plan(vec3(0.0,-6.0,-4.0),vec3(-1.0,0.0,0.0),vec3(0.0,1.0,0.0),vec3(0.6, 0, 0.5),-1.0,1.0);\n    }\n    if (num == 7) {\n        P = plan(vec3(0.0,0.0,7.0),vec3(0.0,0.0,1.0),vec3(0.0,1.0,0.0),vec3(1,1,1),2.0,6.0);\n    }\n\n    \n//vec3 colors[NB_PLAN] = {vec3(1, 0, 0), vec3(1, 0.5, 0), vec3(1, 1, 0), vec3(0, 1, 0), vec3(0, 0, 1), vec3(0.3, 0, 0.5), vec3(0.6, 0, 0.5)};\n    \n    return P;\n}\n\n\nCircle circles(int num) {\n    Circle C;\n    if (num == 0) {\n    //roue avant gauche\n        C = circle(vec3(1.5 + ORIGINTX+MOUVT, 2.0, -1.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),vec3(0.91,0.21,0.24),5.0,5.0,1.5);\n        C.text = true;\n    }\n    if (num == 1) {\n    //roue avant droite\n        C = circle(vec3(1.5 + ORIGINTX+MOUVT, -2.0, -1.0),vec3(-1.0,0.0,0.0),vec3(0.0,0.0,1.0),vec3(0.91,0.21,0.24),5.0,5.0,1.5);\n        C.text = true;\n    }\n    if (num == 2) {\n        //roue arrière gauche\n        C = circle(vec3(-1.5 + ORIGINTX+MOUVT, 2.0, -1.0),vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),vec3(0.91,0.21,0.24),5.0,5.0,1.5);\n        C.text = true;\n    }\n    if (num == 3) {\n        //roue arrierre droite\n        C = circle(vec3(-1.5 + ORIGINTX+MOUVT, -2.0, -1.0),vec3(-1.0,0.0,0.0),vec3(0.0,0.0,1.0),vec3(0.91,0.21,0.24),5.0,5.0,1.5);\n        C.text = true;\n    }\n    if (num == 4) {\n        //cul\n        C = circle(vec3(ORIGINTX+MOUVT-DLT,0.0, 0.0),vec3(0.0,1.0,0.0),vec3(0.0,0.0,1.0),vec3(0.02,0.43,0.62),5.0,5.0,2.0);\n    }\n    if (num == 5) {\n        //tete\n        //C = circle(vec3(ORIGINTX+MOUVT+DLT,0.0, 0.0),vec3(0.0,1.0,0.0),vec3(0.0,0.0,-1.0),vec3(0.02,0.43,0.62),5.0,5.0,2.0);\n        //C.text = false;\n   }\n    \n    return C;\n}\n\nCylinder cylinders(int num) {\n    Cylinder C;\n    if (num == 0) {\n        //corps\n        C = cylinder(vec3(ORIGINTX+MOUVT,0.0,0.0),vec3(1.0,0.0,0.0),vec3(0.02,0.43,0.62),2.0,LT);\n    }\n    if (num == 1) {\n        //cheminée\n        C = cylinder(vec3(DLT + ORIGINTX+MOUVT,0.0,2.0),vec3(0.0,0.0,1.0),vec3(0.1,0.1,0.1),0.2,2.5);\n    }\n    if (num == 2) {\n        C = cylinder(vec3(0.0,-6.5,3.5),vec3(0.0,0.0,1.0),vec3(1,1,1),1.0,15.0);\n    }\n    if (num == 3) {\n        C = cylinder(vec3(0.0,6.5,3.5),vec3(0.0,0.0,1.0),vec3(1,1,1),1.0,15.0);\n\n    }\n    return C;\n}\n\n \nSphere spheres(int num) {\n    Sphere S;\n    if (num == 0) {\n        //tete\n        S = Sphere(vec3(0.0+DLT + ORIGINTX+MOUVT, 0.0, 0.0), 2.0 , vec3(0.02,0.43,0.62));\n    }\n    if (num == 1) {\n        //oeil gauche\n        S = Sphere(vec3(DLT + 1.2 + ORIGINTX+MOUVT, 0.7, 1.0), 0.6, vec3(0.8,0.8,0.8));\n    }\n    if (num == 2) {\n        //oeil droit\n        S = Sphere(vec3(DLT +1.2 + ORIGINTX+MOUVT, -0.7, 1.0), 0.6, vec3(0.8,0.8,0.8));\n    }\n    return S;\n}\n\n\n\n\nCone cones(int num) {\n    Cone C;\n    if (num == 0) {\n        C = cone(vec3(0.0,0.0,1.0),vec3(0.0,0.0,1.0),vec3(0,1,0),1.0,6.0,3.0);\n    }\n    if (num == 1) {\n        //\n    }\n    if (num == 2) {\n        //\n    }\n    if (num == 3) {\n        //\n        }\n    return C;\n}\n\nLum lumieres(int num) {\n    Lum L;\n    if (num == 0) {\n        L = lum(vec3(1,1,1), vec3(10.0 + ORIGINTX+MOUVT,0.0,50.0));\n    }\n    if (num == 1) {\n        L = lum(vec3(1.0, 1.0, 1.0), vec3(ORIGINTX+MOUVT, 10.0, 0.0));\n    }\n    if (num == 2) {\n        L = lum(vec3(1.0, 1.0, 1.0), vec3(ORIGINTX+MOUVT, -10.0, 0.0));\n    }\n    if (num == 3) {\n        L = lum(vec3(1.0, 1.0, 1.0), vec3(ORIGINTX+MOUVT-DLT-10.0, 0.0, 0.0));\n    }\n    if (num == 4) {\n        //L = lum(vec3(1.0, 1.0, 1.0), vec3(20.0, 0.0, 0.0));\n    }\n    if (num == 5) {\n        //L = lum(vec3(1.0,0.0,0.0), vec3(50.0, 0.0, 5.0));\n    }\n    if (num == 6) {\n        //L = lum(vec3(0.0, 1.0, 0.0), vec3(0.0, 50.0, 0.0));\n    }\n    if (num == 7) {\n        //L = lum(vec3(0.0, 0.0, 1.0), vec3(10.0, 0.0, 50.0));\n    }\n    return L;\n}\n\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    \n    float a = dot(R.Dir,R.Dir);\n    float b = 2.0*dot(R.Dir,(R.Origin - S.Center));\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R*S.R;\n    float delta = b*b - 4.0*a*c;   \n        \n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0*a);\n        float t2 = (-b + sqrt(delta)) / (2.0*a);\n        t = t1;\n        if (t1 < 0.0) {\n            t = t2;\n            if (t2 < 0.0) {return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n        if (t < 0.0) {return false;}\n    } else {\n        t = -1.0;\n        return false;\n    }\n    return true;\n}\n\nbool intersect_plan(in Ray R, in Plan P, out float t) {\n    vec3 n = cross(P.Dir1,P.Dir2);\n    if (dot(n,R.Dir)!=0.0) {\n        mat3 X = mat3(R.Dir,-P.Dir1,-P.Dir2);\n        mat3 Xinv = inverse(X);\n        vec3 V0 = P.Center - R.Origin;\n        vec3 C = Xinv*V0;\n        t = C.x;\n        float u = C.y;\n        float v = C.z;\n        \n        \n        if ( ( P.h > 0.0 && P.h < abs(u) )||  ( P.w > 0.0 && P.w < abs(v) ) )  {\n            t = -1.0;\n            return false;\n        }\n        if (t > 0.0) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool intersect_circle(in Ray R, in Circle C, out float t, out vec3 color) {\n    vec3 n = cross(C.Dir1,C.Dir2);\n    float denom = dot(n, R.Dir);\n    \n    if (denom > 1e-6) {\n        vec3 p0l0 = C.Center - R.Origin;\n        t = dot(p0l0, n) / denom;\n        \n        mat3 X = mat3(R.Dir,-C.Dir1,-C.Dir2);\n        mat3 Xinv = inverse(X);\n        vec3 V0 = C.Center - R.Origin;\n        vec3 Cp = Xinv*V0;\n        float u = Cp.y;\n        float v = Cp.z;\n        vec2 loc = vec2(u,v);\n\n        if (t >= 0.0) {\n            vec3 p = R.Origin + t * R.Dir;\n            vec3 d = p - C.Center;\n            float distanceSquared = dot(d, d);\n            \n            if (distanceSquared <= C.r * C.r) {\n                if (C.text) {\n                    color = texture(iChannel1, loc/3.0 +vec2(0.5,0.5) ).rgb;\n                } else {\n                    color = vec3(0,0,0);\n                }\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n\nbool intersect_cylinder(in Ray R, in Cylinder C, out float t,  out bool devant, out vec3 color) {\n  \n    vec3 x = R.Dir - dot(C.Dir,R.Dir)*C.Dir;\n    vec3 y = R.Origin - C.Center - dot(C.Dir,R.Origin-C.Center)*C.Dir;\n    float a = dot(x,x);\n    float b = 2.0*dot(x,y);\n    float c = dot(y,y) - C.r*C.r;\n    \n    float delta = b*b - 4.0*a*c;   \n    \n    \n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0*a);\n        float t2 = (-b + sqrt(delta)) / (2.0*a);\n        t = t1;\n        float l = dot(C.Dir,C.Center - (R.Origin + t*R.Dir));\n        devant = true;\n        if ( C.h > 0.0 && (-(C.h /2.0) > l || l > C.h/2.0 )) {\n            t = t2;\n            devant = false;\n            //color = vec3(1,0,0);//rouge\n            l = dot(C.Dir,C.Center - (R.Origin + t*R.Dir));\n            if ( C.h > 0.0 && (-(C.h /2.0) > l || l > C.h/2.0 )) {\n                t=-1.0;\n                return false;\n            }\n        }\n        \n        if (t < 0.0) {\n            t = t2;\n            devant = false;\n            //color = vec3(0,1,0);//vert\n            if (t < 0.0) {t=-1.0; return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n        //color = vec3(0,0,1); //bleu\n        if (t < 0.0) {t=-1.0; return false;}\n    } else {\n        t = -1.0;\n        return false;\n    } \n    return true;\n}\n\nbool intersect_cone(in Ray R, in Cone C, out float t, out bool devant) {\n  \n    vec3 x = R.Dir - dot(C.Dir,R.Dir)*C.Dir;\n    vec3 y = R.Origin - C.Center - dot(C.Dir,R.Origin-C.Center)*C.Dir;\n    float a1 = dot(x,x);\n    float b1 = 2.0*dot(x,y);\n    float c1 = dot(y,y);\n    float a2 = C.r*C.r/(C.s*C.s)*pow(dot(C.Dir,R.Dir),2.0);\n    float b2 = 2.0*C.r*C.r/(C.s*C.s)*dot(C.Dir,R.Dir)*dot(C.Dir,R.Origin-C.Center) - 2.0*C.r*C.r/C.s*dot(C.Dir,R.Dir);\n    float c2 = C.r*C.r/(C.s*C.s)*pow(dot(C.Dir,R.Origin-C.Center),2.0) - 2.0*C.r*C.r/C.s*dot(C.Dir,R.Origin-C.Center) + C.r*C.r;\n    float a = a1 -a2;\n    float b = b1- b2;\n    float c = c1- c2;\n    \n    \n    float delta = b*b - 4.0*a*c;   \n    \n    \n    if (delta > 0.0) {\n        float t1 = (-b - sqrt(delta)) / (2.0*a);\n        float t2 = (-b + sqrt(delta)) / (2.0*a);\n        t = t1;\n        float l = dot(C.Dir,C.Center +(R.Origin + t*R.Dir));\n        devant = true;\n        if ( C.h > 0.0 && (0.0 > l || l > C.h )) {\n            t = t2;\n            devant = false;\n            //color = vec3(1,0,0);//rouge\n            l = dot(C.Dir,C.Center + (R.Origin + t*R.Dir));\n            if ( C.h > 0.0 && (0.0 > l || l > C.h )) {\n                t=-1.0;\n                return false;\n            }\n        }\n        \n        if (t < 0.0) {\n            t = t2;\n            devant = false;\n            //color = vec3(0,1,0);//vert\n            if (t < 0.0) {t=-1.0; return false;}\n        }\n    \n    } else if (delta == 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n        //color = vec3(0,0,1); //bleu\n        if (t < 0.0) {t=-1.0; return false;}\n    } else {\n        t = -1.0;\n        return false;\n    } \n    return true;\n}\n\nvec3 apply_light_sphere(in Ray R, in Sphere S, in Lum L, in float t, in int i) {\n    float costheta = dot(normalize(S.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    if (costheta < 0.0){costheta=0.0;}\n    \n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n    //Ombres sphères sur sphères\n    float t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (j != i && length(spheres(j).Center - L.Pos) > 0.1) {\n            t2 = -1.0;\n            if (intersect_sphere(Rl, spheres(j), t2)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    //Ombres plan sur sphère\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (intersect_plan(Rl, plans(j), t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cylindres sur sphère\n    t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        bool devant;\n        vec3 color;\n        if (intersect_cylinder(Rl, cylinders(j), t2, devant, color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cones sur sphère\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        bool devant;\n        if (intersect_cone(Rl, cones(j), t2, devant)){\n            if (t2 > 0.000000001 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n\n    //Ombres cercles sur sphère\n    t2 = -1.0;\n    for(int j = 0; j < NB_CIRCLE; j++) {\n        vec3 color;\n        if (intersect_circle(Rl, circles(j), t2, color)){;\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    return vec3(S.Color*L.Color*costheta);\n}\n\nvec3 apply_light_plan(in Ray R, in Plan P, in Lum L, in float t, in int i) {\n    vec3 n = cross(P.Dir1,P.Dir2);\n    float costheta = dot(normalize(n),normalize((R.Origin + t*R.Dir)- L.Pos));\n    if (costheta < 0.0){costheta=0.0;}\n    \n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n    //Ombres plan sur plan\n    float t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (j != i) {\n            t2 = -1.0;\n            if (intersect_plan(Rl, plans(j), t2)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    //Ombres sphère sur plan\n    t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (intersect_sphere(Rl, spheres(j), t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cylindres sur plan\n    t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        bool devant;\n        vec3 color;\n        if (intersect_cylinder(Rl, cylinders(j), t2, devant, color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cones sur plan\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        bool devant;\n        if (intersect_cone(Rl, cones(j), t2, devant)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n\n    //Ombres cercles sur plan\n    t2 = -1.0;\n    for(int j = 0; j < NB_CIRCLE; j++) {\n        vec3 color;\n        if (intersect_circle(Rl, circles(j), t2, color)){;\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n\n    return vec3(P.Color*L.Color*costheta);\n}\n\nvec3 apply_light_circle(in Ray R, in Circle C, in Lum L, in float t, in int i) {\n    vec3 n = cross(C.Dir1,C.Dir2);\n    float costheta = dot(normalize(n),normalize((R.Origin + t*R.Dir)- L.Pos));\n    if (costheta < 0.0){costheta=0.0;}\n    \n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n    //Ombres cercle sur cercle\n    float t2 = -1.0;\n    for(int j = 0; j < NB_CIRCLE; j++) {\n        if (j != i) {\n            t2 = -1.0;\n            vec3 color;\n            if (intersect_circle(Rl, circles(j), t2, color)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    //Ombres sphère sur cercle\n    t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (intersect_sphere(Rl, spheres(j), t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cylindres sur cercle\n    t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        bool devant;\n        vec3 color;\n        if (intersect_cylinder(Rl, cylinders(j), t2, devant, color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cones sur cercle\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        bool devant;\n        if (intersect_cone(Rl, cones(j), t2, devant)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    return vec3(C.Color*L.Color*costheta);\n}\n\nvec3 apply_light_cylinder(in Ray R, in Cylinder C, in Lum L, in float t, bool devant, in int i) {\n    float costheta = dot(normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    if (!devant) {\n        costheta = dot(-normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    }\n    if (costheta < 0.0){costheta=0.0;}\n\n    \n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n   \n    //Ombres cylindres sur cylindres\n    float t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        if (j != i && length(cylinders(j).Center - L.Pos) > 0.1) {\n            t2 = -1.0;\n            bool devant;\n            vec3 color;\n            if (intersect_cylinder(Rl, cylinders(j), t2, devant, color)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    //Ombres plan sur cylindre\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (intersect_plan(Rl, plans(j), t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres sphère sur cylindre\n    t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (intersect_sphere(Rl, spheres(j), t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cones sur cylindre\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        bool devant;\n        if (intersect_cone(Rl, cones(j), t2, devant)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n\n    //Ombres cercles sur cylindre\n    t2 = -1.0;\n    for(int j = 0; j < NB_CIRCLE; j++) {\n        vec3 color;\n        if (intersect_circle(Rl, circles(j), t2, color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    return vec3(C.Color*L.Color*costheta);\n}\n\nvec3 apply_light_cone(in Ray R, in Cone C, in Lum L, in float t, bool devant, in int i) {\n    float costheta = dot(normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    if (!devant) {\n        costheta = dot(-normalize(C.Center - (R.Origin + t*R.Dir)),normalize((R.Origin + t*R.Dir) - L.Pos));\n    }\n    if (costheta < 0.0){costheta=0.0;}\n\n    Ray Rl;\n\n    Rl.Origin = R.Origin + t*R.Dir;\n    Rl.Dir = L.Pos - Rl.Origin;\n    \n    \n    //Ombres cone sur cone\n    float t2 = -1.0;\n    for(int j = 0; j < NB_CYL; j++) {\n        if (j != i && length(cones(j).Center - L.Pos) > 0.1) {\n            t2 = -1.0;\n            bool devant;\n            vec3 color;\n            if (intersect_cone(Rl, cones(j), t2, devant)){\n                if (t2 > 0.01 && t2 < 0.99) {\n                    return vec3(0,0,0);\n                }  \n            }\n        }\n    }\n    \n    \n    //Ombres plan sur cone\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n        if (intersect_plan(Rl, plans(j), t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres sphère sur cone\n    t2 = -1.0;\n    for(int j = 0; j < NB_SPHERE; j++) {\n        if (intersect_sphere(Rl, spheres(j), t2)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cylindre sur cone\n    t2 = -1.0;\n    for(int j = 0; j < NB_PLAN; j++) {\n    vec3 color;\n            if (intersect_cylinder(Rl, cylinders(j), t2, devant,color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n    \n    //Ombres cercles sur cone\n    t2 = -1.0;\n    for(int j = 0; j < NB_CIRCLE; j++) {\n        vec3 color;\n        if (intersect_circle(Rl, circles(j), t2, color)){\n            if (t2 > 0.01 && t2 < 0.99) {\n                return vec3(0,0,0);\n            }  \n        }\n    }\n\n    return vec3(C.Color*L.Color*costheta);\n}\n\nvec3 Dave_Hoskins_Warp_Shader(in vec2 fragCoord) {\n\tfloat s = 0.0, v = 0.0;\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tfloat t = iTime*0.005;\n\tuv.x = (uv.x * iResolution.x / iResolution.y) + sin(t)*.5;\n\tfloat si = sin(t+2.17); // ...Squiffy rotation matrix!\n\tfloat co = cos(t);\n\tuv *= mat2(co, si, -si, co);\n\tvec3 col = vec3(0.0);\n\tfor (int r = 0; r < 100; r++) \n\t{\n\t\tvec3 p= vec3(0.3, 0.2, floor(time) * 0.0008) + s * vec3(uv, 0.143);\n\t\tp.z = mod(p.z,2.0);\n\t\tfor (int i=0; i < 10; i++) p = abs(p*2.04) / dot(p, p) - 0.75;\n\t\tv += length(p*p)*smoothstep(0.0, 0.5, 0.9 - s) * .002;\n\t\tcol +=  vec3(v * 0.8, 1.1 - s * 0.5, .7 + v * 0.5) * v * 0.013;\n\t\ts += .01;\n\t}\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    boucle = mod(iTime,12.0);\n    \n   \n    mat3 rotZ = rotateZ(boucle/2.0);\n    vec3 offset = vec3(20.0 + ORIGINTX + MOUVT, 10.0, 7.0);\n    vec3 rotatedOffset = rotZ*offset;\n\n\n    float pi = 3.1415;\n    Camera C = camera(\n        rotatedOffset,\n        vec3(ORIGINTX + MOUVT, 0.0, 0.0),\n        50.0  \n    );\n    \n    //Couleur fond\n    time = (iTime+2.4) * 60.0;\n    vec3 col = Dave_Hoskins_Warp_Shader(fragCoord);\n    fragColor = vec4(col,1.0);\n    \n   \n    \n    //vec2 uv = fragCoord/iResolution.xy;\n    //vec4 channel1 = texture(iChannel1, uv.xy);\n    //fragColor = channel1;\n    \n    //Intersection rayon-objets\n    float best_dist = 999999.0;\n    \n    //Intersection cylindre Camera+Lumiere+Ombres\n    best_dist = 999999.0;\n    for(int i = 0; i < NB_CYL; i++) { //pour toutes les cylindres\n       Ray R = launch(C, fragCoord);\n       float t;     \n       bool devant;\n       Cylinder C = cylinders(i);\n       if (intersect_cylinder(R, cylinders(i), t, devant, C.Color)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_cylinder(R,cylinders(i), lumieres(j), best_dist,devant, i) ,1);\n               }\n           }\n       }\n    }\n    \n    //Intersection sphere Camera+Lumiere+Ombres\n    for(int i = 0; i < NB_SPHERE; i++) { //pour toutes les sphères\n       Ray R = launch(C, fragCoord);\n       float t = 0.0;     \n       if (intersect_sphere(R, spheres(i), t)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_sphere(R,spheres(i), lumieres(j), best_dist, i) ,1);\n               }\n           }\n       }\n    }\n    //intersection plan Camera+Lumiere+Ombres\n    //best_dist = 999999.0;\n    for (int i = 0; i < NB_PLAN ; i++) {\n       Ray R = launch(C, fragCoord);\n       float t = 0.0;\n       if (intersect_plan(R,plans(i),t)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_plan(R,plans(i), lumieres(j), best_dist, i) ,1);\n               }\n           }\n       }\n    }\n    \n    //intersection circle Camera+Lumiere+Ombres\n    //best_dist = 999999.0;\n    for (int i = 0; i < NB_CIRCLE ; i++) {\n       Ray R = launch(C, fragCoord);\n       float t = 0.0;\n       vec3 color;\n       if (intersect_circle(R,circles(i),t, color)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(color,1.0);//vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_circle(R,circles(i), lumieres(j), best_dist, i) ,1);\n               }\n           }\n       }\n    }\n    \n    //Intersection cone Camera+Lumiere+Ombres\n    best_dist = 999999.0;\n    for(int i = 0; i < NB_CONE; i++) { //pour toutes les cones\n       Ray R = launch(C, fragCoord);\n       float t;     \n       bool devant;\n       if (intersect_cone(R, cones(i), t, devant)) {\n           if (t>0.0 && t< best_dist) {\n               best_dist = t;\n               fragColor = vec4(0,0,0,1);\n               for(int j = 0; j < NB_LUM; j++) { //pour toutes les lumieres\n                   fragColor = vec4(fragColor.xyz + apply_light_cone(R,cones(i), lumieres(j), best_dist, devant, i) ,1);\n               }\n           }\n       }\n    }\n    \n   \n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 center = vec2(0.5);\n    float radius = 0.2;\n    float thickness = 0.05;\n    \n    // Draw the circle\n    float dist = distance(uv, center);\n    float circle = smoothstep(radius, radius + thickness, dist);\n    \n    // Draw the spokes\n    float angle = atan(uv.y - center.y, uv.x - center.x);\n    float spokes = step(0.5, fract(12.0 * angle / (2.0 * 3.1415)));\n    \n    // Combine the circle and the spokes\n    float wheel = min(circle, spokes);\n    \n    fragColor = vec4(vec3(wheel), 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}