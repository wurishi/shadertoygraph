{"ver":"0.1","info":{"id":"ldByRd","date":"1493311117","viewed":89,"name":"[MIGJRV] PGATR - Practica 3","username":"alopezviz","description":"Shader para la práctica de la asignatura PGATR.\nAlejandro López Vizuete\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["practica"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Tutorial utilizado para aprender a utilizar la herramienta Shadertoy -> https://www.shadertoy.com/view/Md23DV\n//Efecto Blob de la parte Izquierda, aprendida de -> https://www.shadertoy.com/view/4slGW7\n//Iluminacion Phong en la parte Derecha, aprendida de -> Apuntes Graficos 3D\n\nvec3 sceneBlob(vec2[6] pos,const int numEsferas,float radio)\n{\n    //Hacemos un calculo entre el radio y su posicion para poder hacer el efecto al\n    //acercarse a otras esferas\n\tfloat esfera;\n    for(int i=0;i<numEsferas;i++){\n    \tesfera+= radio/length(pos[i]*pos[i]); //Hacemos pos*pos para que sean esferas mas cuadradas\n    }\n\n\t//Calculamos el color que devolveremos\n\tvec3 color;\n\t//Estilo cartoon\n    if(esfera>0.8){\n        //Color interior va cambiando segun las funciones seno y coseno en el tiempo\n    \tcolor = vec3(sin(iTime),cos(iTime),sin(iTime)*cos(iTime));\n    }\n    else\n    if(esfera>0.6 && esfera<0.8){\n        //Bordeado de color complementario al interior\n    \tcolor = vec3(1.0,1.0,1.0)-vec3(sin(iTime),cos(iTime),sin(iTime)*cos(iTime));\n    }\n\n\treturn vec3(color);\n}\n\nvec3 scenePhong(float radius,vec2 position, vec3 cLight)\n{\t\n    //Calculamos la Z gracias a ecuacion cartesiana de la esfera\n    // x^2 + y^2 + z^2 = R\n    float z = sqrt(radius*radius - position.x*position.x - position.y*position.y);\n    //Calculamos la normal de la posicion en la que nos encontremos\n\tvec3 normal = normalize(vec3(position.x, position.y, z));\n    \n    //Variables de la luz\n    vec3 Ia = vec3(0.0, 0.0, 0.0); \n    vec3 Id = vec3(0.8, 0.5, 0.9); \n    vec3 Is = vec3(1.0, 0.9, 1.0);\n    vec3 ka = vec3(0.9, 0.1, 0.1);\n \tvec3 kd = vec3(0.1, 0.9, 0.5);\n    vec3 ks = vec3(0.9, 0.9, 0.9);\n    float shine = 20.0;\n    \n    //Calculamos los vectores V,L y R necesarios para el calculo de phong\n    vec3 V = normalize(vec3(0.0,0.0,0.0) - vec3(position,z));\n    vec3 L = normalize(cLight- vec3(position,z));   \n   \tvec3 R = reflect(-L,normal);\n    \n    //Calculamos el color según la funcion phong\n    vec3 phong =  clamp((Ia*ka),0.0,1.0) + clamp((kd*Id*dot(L,normal)),0.0,1.0)+ clamp((ks*pow(dot(R,V),shine))*Is,0.0,1.0);\n    return phong;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    //Configuramos la pantalla\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n    \n\t//Creamos la variable para el color del pixel actual\n\tvec4 color;\n    \n    //ZONA IZQUIERDA DE LA PANTALLA\n    if(p.x < 0.5){\n        //Arreglamos el eje de coordenadas para ponerlo a la izquierda\n        vec2 q = r - vec2(-xMax*0.5,0.0); \n        \n        //Ponemos el fondo, para pintarlo primero\n \t\tcolor = mix(vec4(0.0,0.0,0.0,1.0),vec4(1.0,1.0,1.0,1.0),length(vec2(q.x,q.y)*0.3));\n\t\t    \n        //Escogemos la posicion de cada esfera\n        const int numeroEsferas = 6;\n        vec2 pos[numeroEsferas];\n        pos[0] = q-vec2(0.0,0.0);\n        pos[1] = q-vec2(0.6*cos(iTime*3.0),sin(iTime));\n        pos[2] = q-vec2(0.6*sin(iTime*3.0),0.0);\n        pos[3] = q-vec2(0.6*-cos(iTime*3.0),cos(iTime));\n        pos[4] = q-vec2(0.6*cos(iTime*3.0),-cos(iTime));\n        pos[5] = q-vec2(0.6*-cos(iTime*3.0),-sin(iTime));\n        //Radio de las esferas\n    \tfloat radio = .013;\n        //Ponermos en la variable color, el resultado de la llamada a la funcion\n        color += vec4(sceneBlob(pos,numeroEsferas,radio),1.0);\n    }\n    else{\n        //Arreglamos el eje de coordenadas para ponerlo a la derecha\n        vec2 q = r - vec2(xMax*0.5, 0.0); \n        //Posicion según el nuevo eje\n        vec2 pos = q-vec2(0.0,0.0);\n        //Radio de nuestra esfera\n        float radio = 0.5;\n        \n        //Posicion de la luz\n        //Podemos coger la entrada del raton si pulsamos en la escena DERECHA\n        //Si mantenemos pulsado y arrastramos, controlamos la luz\n        //Si no mantenemos pulsado, la luz se moverá sola\n        \n        //Coordenadas del raton\n        vec2 mouseP = vec2(iMouse.zw / iResolution.xy);\n\t\tvec2 mouseR =  2.0*vec2(iMouse.xy - 0.5*iResolution.xy)/iResolution.y;\n        vec3 posLuz;\n        //Si pulsamos en la escena derecha, controlamos el raton\n        if(mouseP.x>0.5){\n        \tposLuz = vec3(vec2(mouseR.x-1.0,mouseR.y),1.0);\n        }\n        //Si no, se mueve según las funciones coseno y seno\n        else{\n        \tposLuz = vec3(vec2(0.6*cos(iTime*3.0),sin(iTime)),1.0);\n        }\t\n      \n        //Guardamos el color asociado al pixel\n        vec3 colorEsf;\n        colorEsf = scenePhong(radio, pos, posLuz);\n\t\t//Pintamos únicamente la esfera\n        if(length(pos) < radio){\n           color = vec4(colorEsf, 1.);\n         } \n\n    }\n    //Pintamos cada pixel del color calculado\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}