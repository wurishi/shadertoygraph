{"ver":"0.1","info":{"id":"ttXBW4","date":"1596706782","viewed":124,"name":"Hard to name it","username":"Onnion","description":"I'm not sure what I'm doing, but it renders something","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["albumcover"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel2,uv.xy); \n    fragColor = color; \n   \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Basic sobel filter implementation\n// Jeroen Baert - jeroen.baert@cs.kuleuven.be\n// \n// www.forceflow.be\n\n// Original done by: https://www.shadertoy.com/view/Xdf3Rf\n\n\n// Use these parameters to fiddle with settings\nfloat step = 1.0;\nfloat middle_pr = 2.0; \nfloat side_pr = 1.;\n\nfloat intensity(in vec4 color){\n\treturn sqrt((color.x*color.x)+(color.y*color.y)+(color.z*color.z));\n}\n\nvec3 sobel(float stepx, float stepy, vec2 center){\n\t// get samples around pixel\n    float tleft = intensity(texture(iChannel0,center + vec2(-stepx,stepy)));\n    float left = intensity(texture(iChannel0,center + vec2(-stepx,0)));\n    float bleft = intensity(texture(iChannel0,center + vec2(-stepx,-stepy)));\n    float top = intensity(texture(iChannel0,center + vec2(0,stepy)));\n    float bottom = intensity(texture(iChannel0,center + vec2(0,-stepy)));\n    float tright = intensity(texture(iChannel0,center + vec2(stepx,stepy)));\n    float right = intensity(texture(iChannel0,center + vec2(stepx,0)));\n    float bright = intensity(texture(iChannel0,center + vec2(stepx,-stepy)));\n \n\t// Sobel masks (see http://en.wikipedia.org/wiki/Sobel_operator)\n\t//        1 0 -1     -1 -2 -1\n\t//    X = 2 0 -2  Y = 0  0  0\n\t//        1 0 -1      1  2  1\n\t\n\t// You could also use Scharr operator:\n\t//        3 0 -3        3 10   3\n\t//    X = 10 0 -10  Y = 0  0   0\n\t//        3 0 -3        -3 -10 -3\n \n    float x = side_pr*tleft + middle_pr*left + side_pr*bleft - side_pr*tright - middle_pr*right - side_pr*bright;\n    float y = -side_pr*tleft - middle_pr*top - side_pr*tright + side_pr*bleft + middle_pr*bottom + side_pr*bright;\n    float color = sqrt((x*x) + (y*y));\n    return vec3(color,color,color);\n }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel0, uv.xy);\n\tfragColor.xyz = sobel(step/iResolution[0], step/iResolution[1], uv);\n    \n    fragColor = 1.0- fragColor; \n    \n    if(fragColor.r > 0.2)\n        fragColor = vec4(1.0); \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvec3 rgb2hsl( in vec3 c ){\n  float h = 0.0;\n\tfloat s = 0.0;\n\tfloat l = 0.0;\n\tfloat r = c.r;\n\tfloat g = c.g;\n\tfloat b = c.b;\n\tfloat cMin = min( r, min( g, b ) );\n\tfloat cMax = max( r, max( g, b ) );\n\n\tl = ( cMax + cMin ) / 2.0;\n\tif ( cMax > cMin ) {\n\t\tfloat cDelta = cMax - cMin;\n        \n        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original\n\t\ts = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );\n        \n\t\tif ( r == cMax ) {\n\t\t\th = ( g - b ) / cDelta;\n\t\t} else if ( g == cMax ) {\n\t\t\th = 2.0 + ( b - r ) / cDelta;\n\t\t} else {\n\t\t\th = 4.0 + ( r - g ) / cDelta;\n\t\t}\n\n\t\tif ( h < 0.0) {\n\t\t\th += 6.0;\n\t\t}\n\t\th = h / 6.0;\n\t}\n\treturn vec3( h, s, l );\n}\n\n\nfloat HueShift(float hue, float perOne) \n{\n  return float( int((hue + perOne)*100.0) % 100) / 100.0;    \n}\n\nfloat lerp(float smin, float smax, float alpha) \n{\n \treturn smin + alpha*(smax-smin);    \n}\n            \n\nfloat trheshold = 0.2; \nfloat MaxLuminanceTrheshold = 0.8; \nfloat LuminanceTrheshold = 0.6; \nfloat LuminanceTrhesholdB = 0.46;\nfloat LuminanceTrhesholdC = 0.3;\nfloat speed = 2.0; \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec4 color = texture(iChannel1, uv.xy);\n    float alpha = (sin(iTime / speed)/2.0)+.5;\n\n    if(color.r > trheshold){\n        \n        color = texture(iChannel0,uv.xy);\n        color = vec4(rgb2hsl(color.rgb),1.0); \n        color.b += (texture(iChannel2, uv.xy).r - 0.5) * lerp(0.0,0.5,1.-alpha); \n        if(color.b > lerp(LuminanceTrhesholdC,MaxLuminanceTrheshold,alpha)){   \n        \tcolor.g = 1.f;//lerp(color.g, 1.0, alpha);\n            color.r = HueShift(color.r, 0.0);\n        }\n        else if(color.b > lerp(LuminanceTrhesholdC, LuminanceTrheshold,alpha))\n        {\n            color.g = 0.75;  \n            color.r = HueShift(color.r, 0.5);\n        }\n        else if(color.b > lerp(LuminanceTrhesholdC, LuminanceTrhesholdB,alpha)){\n            \n            color.g = 0.45;  \n            color.r  =HueShift(color.r, .75); \n        }\n        else \n        { \n            color.g = 0.2;\n            color.b += 0.1;\n            color.r = HueShift(color.r, alpha); \n        }\n        color = vec4(hsl2rgb(color.rgb),1.0);\n        \n    }\n\n    fragColor = color; \n}","name":"Buffer C","description":"","type":"buffer"}]}