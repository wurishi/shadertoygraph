{"ver":"0.1","info":{"id":"Xt2BWd","date":"1517588525","viewed":192,"name":"Relativistic Light","username":"Fra32","description":"A shader simulating what it would look like if light moved a lot slower than usual.\nThe scene starts at a fairly high speed of light, but steadily decreases it until it is equal to the camera movement speed.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nUse the mouse to move the camera.\n\nAs the speed decreases, your Field of View starts to shift due to you \"catching up\" with light rays that would normaly move faster\nthan you. This eventually causes the area behind you to fade out while everything else is shifted forwards.\n\nDue to the light intensity shifting as you get closer to the speed of light, light in front of you is perceived more bright while\nlight behind you fades to black. This is called the Searchlight Effect.\n\nAnother effect caused by this is the change in light frequency's. At normal speed, the spheres change betwee red and blue color,\nbut as light gets slower, black seems to appear inbetween too. I simulated this in a primitive way by using the color hue as an\nalternative for the frequency. Light in front of you get's blueshift, which causes the rainbow colors to fade to blue and then\nto ultraviolet, leaving only the originally red light as short blue pulses. Similarly, light behind you get's redshift before\nfading out.\n\nThe final effect is Time Dillation. The slower light get's, the more time it requires to reach an object. This causes the\nsynchronized pulses to appear delayed. Time in front of you seems to pass twice as fast at slow speed of light, while it doesn't\nseem to pass at all behind you.\n\nUses Raymarching to render the spheres and manipulates the image depending on the current speed of light.\n*/\n\nfloat pi = 3.14159267378979;\nfloat light = 1000.;\n\nstruct ray{vec3 o; vec3 d;};\n\n//The hue-color function, offset depending on RGB component\nfloat h2col(float h, float col)\n{\n\th=h+1./3.-col/3.;\n    float val;\n    if(h<=0.)\n    val = 0.;\n    else if(h<=1./6.){  \n        val = h*6.;\n        if(col==0.)val = 0.;\n    }\n    else if(h<=1./2.){\n        val = 1.;\n        if(col==0.&& h <= 1./3.)val = h*6.-1.;\n        if(col==2.&& h >= 1./3.)val = 1.-(h-1./3.)*6.;\n    }\n    else if(h<=2./3.){\n        val = 4.-h*6.;\n        if(col==2.)val = 0.;\n    }\n    else val = 0.;\n    return val;\n}\n\nvec3 hsv2rgb(vec3 col)\n{\n    float r = h2col(col.x,0.);\n    float g = h2col(col.x,1.);\n    float b = h2col(col.x,2.);\n    float s = col.y;\n    float v = col.z;\n    return v*vec3((r-1.)*s+1.,(g-1.)*s+1.,(b-1.)*s+1.);\n}\n\n\nvec3 loop(vec3 p)\n{\n return vec3(\nmod(p.x+2.,4.)-2., \nmod(p.y+2.,4.)-2.,\nmod(p.z+2.,4.)-2.);\n}\n\nfloat sphere(vec3 p, vec3 o, float r)\n{\n return distance(o,p)-r;   \n}\n\n\nfloat sdf(vec3 o)\n{ \t\n    vec3 b1s = vec3(1,1,1);\n \treturn sphere(o,vec3(0),.5);\n}\n\nvoid rotX(inout vec3 p, float a)\n{\n    p = vec3(p.x,p.y*cos(a)-p.z*sin(a),p.y*sin(a)+p.z*cos(a));\n}\n\nvoid rotY(inout vec3 p, float a)\n{\n    p = vec3(p.x*cos(a)-p.z*sin(a),p.y,p.x*sin(a)+p.z*cos(a));\n}\n\nvoid rotZ(inout vec3 p, float a)\n{\n    p = vec3(p.x*cos(a)-p.y*sin(a),p.x*sin(a)+p.y*cos(a),p.z);\n}\n\nvoid rotX(inout ray r, float a)\n{\n    rotX(r.o,a);\n    rotX(r.d,a);\n}\nvoid rotY(inout ray r, float a)\n{\n    rotY(r.o,a);\n    rotY(r.d,a);\n}\nvoid rotZ(inout ray r, float a)\n{\n    rotZ(r.o,a);\n    rotZ(r.d,a);\n}\n\n\nfloat sqr(float a){\n    return pow(a,2.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    //Defining the camera movement and the speed of light depending on time\n    float mvs = 4.;\n    vec3 mvdir = vec3(0,0,mvs);\n    light = mvs+2000./pow(2.,iTime/2.);\n    \n    //Setting up the camera rays\n\tvec2 uv = fragCoord.xy / iResolution.xy-vec2(.5);\n    ray r = ray(vec3(0),normalize(vec3(uv,1)));\n    \n    vec2 mouse = iMouse.xy/iResolution.xy-vec2(.5);\n    float mlen = length(mouse);\n    mouse = normalize(mouse)*2.;\n    \n    rotX(r,-mouse.y*sqr(mlen)*pi*2.);\n    rotY(r,-mouse.x*sqr(mlen)*pi*2.);\n    r.o = loop(r.o+mvdir*iTime) + vec3(2,2,0);\n    \n    //Reference value for evaluating distances\n    vec3 campos = r.o;\n    \n    //Calculating the FoV manipulation caused by relativistic speeds. As you get faster, more and more light from behind you reaches your eye.\n    float x = -length(r.d.xy);\n    float y = -r.d.z;\n    float a = (sqrt(sqr(light)+sqr(mvs*y/light)-sqr(mvs))-mvs*y/light)*light;\n    \n    //Overriding the ray direction\n    r.d = r.d*a-mvdir;\n    r.d = normalize(r.d);\n    \n    //Intensity at which the light hit's the camera. Increases in front of you, decreases behind you.\n    float li = length(r.d+mvdir/light);\n    \n    //Performing the raymarch\n    for(int i=0;i<200;i++)\n    {\n        float d = sdf(loop(r.o));\n        if(d<.001 || length(r.o-campos)>200.) break; \n     \tr.o += r.d*d;\n    }\n    \n    //Calculating the time the light takes to reach the camera.\n    float timeDil = distance(campos,r.o)/light;\n    \n    //A primitive modelling of light frequencys. Spheres simultaneously shift from red to blue.\n    float h = 380. + (790.-380.)*(.5-.5*cos((iTime-timeDil)/1.5));\n    \n    //Implementation of the Doppler Effect. The faster light hit's you, the more blueshift it is, the slower it hit's you, the more redshift it is.\n    h /= li;\n    h = .7-.7*(h-380.)/(790.-380.);\n    \n    //Simple flat shading with distance fog\n    vec3 n = normalize(loop(r.o));\n    float angcos = dot(n,-r.d);\n    float colval = 1.-((1.-1./(1.+pow(distance(campos,r.o)/10.,2.))*angcos));\n    \n    //Applying the searchlight effect. Light in front of you gets brighter and dimmer behind you.\n    colval = (-1./(colval-1.)-1.)*li;\n    colval = 1.-1./(1.+colval);\n    \n    //Converting hue to RGB and calculating final color.\n    vec3 hue =hsv2rgb(vec3(h,1.,1.));\n    vec3 col = hue*colval;\n    \n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}