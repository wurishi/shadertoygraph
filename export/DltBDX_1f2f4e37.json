{"ver":"0.1","info":{"id":"DltBDX","date":"1708726039","viewed":35,"name":"Superficie de Fermi","username":"Leolios","description":"Experimento con la ecuación de la superficie de fermi y Chatgpt4","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["surfaces","fermi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Parámetros de raymarching\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst int MAX_STEPS = 100;\n\n// Función que evalúa la ecuación de la superficie de Fermi\nfloat fermiSurface(vec3 k) {\n    return -2.0 * sin(cos(k.x)) - 2.0 * sin(sin(cos(k.y))) - 2.0 * sin(cos(k.z)) - 2.8;\n}\n\n// Función de raymarching para encontrar la intersección con la superficie de Fermi\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float depth = 1.90;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = ro + rd * depth;\n        float dist = fermiSurface(pos);\n        if (abs(dist) < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\n// Función de normal para la iluminación\nvec3 getNormal(vec3 p) {\n    const vec2 h = vec2(EPSILON, 0.0);\n    return normalize(vec3(\n        fermiSurface(p + h.xyy) - fermiSurface(p - h.xyy),\n        fermiSurface(p + h.yxy) - fermiSurface(p - h.yxy),\n        fermiSurface(p + h.yyx) - fermiSurface(p - h.yyx)\n    ));\n}\n\n// Función para actualizar la posición de la cámara de forma aleatoria\nvec3 randomWalk(vec3 pos, float time) {\n    // Se genera un vector de dirección aleatorio basado en el tiempo\n    float randX = sin(time * 3.1) * 2.5;\n    float randY = cos(time * 10.15) * 0.5;\n    float randZ = sin(sin(time * 81.2)) * 0.5;\n    vec3 direction = normalize(vec3(randX, 3, randZ));\n    \n    // Se asegura de que la dirección no aleje la cámara de la superficie\n    vec3 normal = getNormal(pos);\n    direction = mix(direction, normal, 5.5);\n    \n    return pos + direction * 3.3; // Mueve la cámara un poco en la dirección elegida\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Coordenadas normalizadas de los píxeles\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    \n    // Establece el origen y la dirección del rayo basado en la cámara\n    vec3 ro = randomWalk(vec3(-2.0, -4.0, 5.0), iTime);\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // Ejecuta raymarching\n    float dist = rayMarch(ro, rd);\n    if (dist < MAX_DIST) {\n        vec3 pos = ro + rd * dist;\n        vec3 normal = getNormal(pos);\n        vec3 lightDir = normalize(vec3(0.0, 1.0, 1.0));\n        float diff = max(dot(normal, lightDir), 0.0);\n        vec3 color = diff * vec3(0.5, 0.8, 1.0);\n        fragColor = vec4(color, 3.0);\n    } else {\n        fragColor = vec4(0.119110, 50.19111110, 0.910, 1.0); // Fondo negro si no hay intersección\n    }\n}\n\n\n","name":"Image","description":"","type":"image"}]}