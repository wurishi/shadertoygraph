{"ver":"0.1","info":{"id":"mdBBDc","date":"1690223470","viewed":62,"name":"disattraction","username":"pik","description":"voronoi","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","sphereintersection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define S smoothstep\n#define mm 1\nconst float delta=0.001;\nconst int div=1;\n\nvec2 hash(vec2 p)\n{\n    p=vec2(dot(p,vec2(78.3979,13.397)),dot(p,vec2(219.233,79.247)));\n    return fract(sin(p)*38807.12);//[0,+1]\n}\n\nvec4 voronoi(vec2 p,vec2 tag){\n    vec2 n=floor(p);\n    vec2 f=p-n;\n    vec3 res=vec3(8.);\n    for(float i=-1.;i<=1.;i++)\n    for(float j=-1.;j<=1.;j++){\n        vec2 b=vec2(i,j);\n        vec2 point=hash(n+b);\n        vec2 l=point+b-f;\n        float g=dot(l,l);\n        if(g<res.x){\n            res=vec3(g,point);\n        }\n    }\n    float s=(dot(tag-res.yz,tag-res.yz)<0.0001) ? 1. : 0.;\n    return vec4(sqrt(res.x),res.y,res.z,s);\n}\n\nfloat sphIntersect( vec3 ro, vec3 rd, vec4 sph)\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    h = sqrt( h );\n    return -b - h;\n}\n\nvec3 setcam(vec3 c,vec3 t,vec2 uv)\n{\n    vec3 f=normalize(t-c);\n    vec3 u=vec3(0.,1.,0.);\n    vec3 s=normalize(cross(f,u));\n    u=cross(s,f);\n    return normalize(uv.x*s+uv.y*u+f);\n}\n\nfloat sabs(float x,float k){\n    return sqrt(x*x+k);\n}\nfloat smin(float a,float b,float k){\n    return (a+b-sabs(a-b,k))*0.5;\n}\nfloat sphere(vec3 p){\n    return length(p)-1.;\n}\n\nfloat map(vec3 p){\n    float s=length(p)-1.;\n    return s;\n}\nvec3 normal(vec3 p)\n{\n    vec2 e=vec2(delta,0.);\n    return normalize(vec3(map(p+e.xyy)-map(p),\n                            map(p+e.yxy)-map(p),\n                            map(p+e.yyx)-map(p)));\n}\nvec3 transform(vec3 p){\n    float a=pow(sin(iTime*0.3)+0.5,10.);;\n    a=iTime*(1.+9.*a);\n    p.yz*=rot(a);\n    p.zx*=rot(a*1.2);\n    return p;\n}\nvec3 U(vec2 tag){\n    vec2 h=hash(vec2(iTime,tag.x+tag.y));\n    return normalize(vec3(tag.x+h.x,tag.y+h.y,tag.x+tag.y))*pow(sin(iTime*0.3)+0.5,10.)*0.2;\n}\n\n//////////Color//////////////\nvec4 albedo(vec2 p,vec2 tag){\n    p*=float(div);\n    tag=hash(tag);\n    vec4 vor=voronoi(p,tag);\n    vec4 col=vec4(0.5+sin((vor.y+vor.z)*PI*2.+vec3(3.,1.,2.)),1.);\n    return (vor.w>0.5) ? col : vec4(0.);\n}\n////////////lighting/////////\nvec3 lightpos=vec3(1.,1.,-1.);///change!!!\nconst vec3 ks=vec3(0.9);\nconst vec3 specularcolor=vec3(0.9,0.2,0.9);\nconst vec3 amb=vec3(0.5);//////with AO?\nfloat shadow(vec3 p,vec3 ld){\n    float l=0.001;\n    float r=1.;\n    float shadowcoef=0.5;\n    for(int i=0;i<50;i++)\n    {\n        float d=map(p+ld*l);\n        if(d<0.001){return shadowcoef;}\n        r=min(r,d*16./l);\n        l+=d;\n    }\n    return mix(shadowcoef,1.0,r);\n}\nfloat ao(vec3 p,vec3 n){\n    float a=0.;\n    float sc=10.;\n    for(int i=0;i<5;i++)\n    {\n        float h=0.01+0.02*float(i*i);\n        float d=map(p+n*h);\n        float ao=clamp(h-d,0.,1.);\n        a+=ao*sc;\n        sc*=0.8;\n    }\n    return clamp(1.-5.*a,0.,1.);\n}\n\nvec4 BlinnPhong(vec3 p,vec3 cam,vec3 N,vec2 tag){\n    vec3 lightcolor=vec3(1.,1.,1.);\n    vec3 kd=vec3(1.)-ks;\n    vec3 L=normalize(lightpos-p);\n    vec3 V=normalize(cam-p);\n    vec3 H=normalize(L+V);\n    vec3 R=normalize(reflect(-L,N));\n    float nl=max(dot(N,L),0.);\n    float vr=max(dot(V,R),0.);\n    float nh=max(dot(V,H),0.);\n    float dist=length(lightpos-p);\n    float atten=1./(dist*dist);//減衰\n    ////Phong\n    vec4 albedo=albedo(vec2(atan(p.x,p.z)*0.5,atan(p.y,p.x)*0.5),tag);\n    vec3 Diffuse=kd*albedo.rgb*nl*lightcolor*atten;\n    vec3 Specular=ks*specularcolor*pow(vr,8.)*nl*lightcolor*atten;\n    vec4 color=vec4(Diffuse+Specular+amb*albedo.rgb*ao(p+0.001*N,N),albedo.a);\n    //color*=shadow(p+N*0.001,L);\n    return color;\n}\nvec4 bg(vec2 p){\n    return vec4(mix(vec3(0.9,0.4,0.1),vec3(0.7,0.7,0.5),p.y*p.y)*1.9,1.);\n}\n\n//////////////////////////////////////////////\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    uv.x*=iResolution.x/iResolution.y;\n    vec4 col=bg(uv);\n    float cm=dot(uv,uv);\n    float light=0.5/cm*S(0.0,1.,pow(sin(iTime*0.3)+0.5,10.));\n    vec3 lightcol=vec3(0.1,0.6,0.8);\n    col.rgb+=light*lightcol;\n    vec3 cam=vec3(0.,0.,-3.);\n    #ifdef mm\n        vec2 mouse=PI*(iMouse.xy/iResolution.xy);\n        cam.yz*=rot(mouse.y+1.);\n        cam.xz*=rot(mouse.x*2.);\n    #endif\n    vec3 tar=vec3(0.,0.,0.);\n    vec3 ro=cam;\n    vec3 rd=setcam(cam,tar,uv);\n    ////intersection\n    for(int i=-4*div*div-1;i<=4*div*div+1;i++)\n    for(int j=-4*div*div-1;j<=4*div*div+1;j++)\n    {\n        vec2 tag=vec2(i,j);\n        vec3 X=U(tag);\n        float l=sphIntersect(ro,rd,vec4(X,1.));\n        if(l>0.){\n            vec3 p=ro+rd*l-X;\n            p=transform(p);\n            vec3 n=normal(p);\n            vec4 frag=BlinnPhong(p,cam,n,tag);\n            col=mix(col,frag,frag.a);\n        }\n    }\n    ///GAMMMA\n    col=col/(col+vec4(1.));\n    col=pow(col,vec4(1./2.2));\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}