{"ver":"0.1","info":{"id":"7tf3Wj","date":"1623105089","viewed":76,"name":"Rock Noise3D","username":"Beh_gin","description":"3D noise generated in 8 octants. Rock like object to be seen from a cone of angles.\nThe 3D perlin noise has been improved a little bit, but still not quite right.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","camera"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS     1300.0\n#define SURFACE_DIST  0.01\n#define MAX_DIST      5.0\n\nfloat smoothy(float t){return t*t*t*(3.-2.*t);}\n\nint octantX(vec3 point, vec3 center, out vec3[8] corners)\n{\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    corners = vec3[8](\n        vec3(center.x-res.x,center.y      ,center.z      ),vec3(center.x,center.y      ,center.z      ),\n        vec3(center.x-res.x,center.y-res.y,center.z      ),vec3(center.x,center.y-res.y,center.z      ),\n        vec3(center.x-res.x,center.y      ,center.z-res.z),vec3(center.x,center.y      ,center.z-res.z),\n        vec3(center.x-res.x,center.y-res.y,center.z-res.z),vec3(center.x,center.y-res.y,center.z-res.z));\n    \n    if (point.x > center.x+res.x ||\n        point.y > center.y+res.y ||\n        point.z > center.z+res.z ||\n        point.x < center.x-res.x ||\n        point.y < center.y-res.y ||\n        point.z < center.z-res.z)\n    {\n        return 8;\n    }\n    if (point.x > center.x)\n    {\n        if (point.y > center.y)\n        {\n            if (point.z > center.z)\n            {\n                for (int i = 0; i< 8; i++)\n                {\n                    corners[i].xyz += res.xyz;\n                }\n                return 0;\n            }\n            for (int i = 0; i< 8; i++)\n            {\n                corners[i].xy += res.xy;\n            }\n            return 1;\n        }\n        if (point.z < center.z)\n        {\n            for (int i = 0; i< 8; i++)\n            {\n                corners[i].x += res.x; //?\n            }\n            return 3;\n        }\n        for (int i = 0; i< 8; i++)\n        {\n            corners[i].xz += res.xz; //?\n        }\n        return 2;\n    }\n    if (point.y > center.y)\n    {\n        if (point.z > center.z)\n        {\n            for (int i = 0; i< 8; i++)\n            {\n                corners[i].yz += res.yz;\n            }\n            return 5;\n        }\n        for (int i = 0; i< 8; i++)\n        {\n            corners[i].y += res.y;\n        }\n        return 6;\n    }\n    if (point.z > center.z)\n    {\n        for (int i = 0; i< 8; i++)\n        {\n            corners[i].z += res.z;\n            \n        }\n        return 4;\n    }\n    for (int i = 0; i < 8; i++)\n    {\n        //corners[i].x += res.x;\n    }\n    return 7;\n}\n\nfloat calcNoise3d(vec3[8] pos, vec3[8] height, vec3 center, vec3 point)\n{\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    float a, b, c, d, x, y, z;\n    x = smoothy((pos[0].x-point.x)/res.x);\n    y = smoothy((pos[0].y-point.y)/res.y);\n    z = smoothy((pos[0].z-point.z)/res.z);\n    a = mix(dot(point-pos[0],height[0]), dot(point-pos[1],height[1]), x);\n    b = mix(dot(point-pos[2],height[2]), dot(point-pos[3],height[3]), x);\n    c = mix(dot(point-pos[4],height[4]), dot(point-pos[5],height[5]), x);\n    d = mix(dot(point-pos[6],height[6]), dot(point-pos[7],height[7]), x);\n    return mix(mix(a,b,y),mix(c,d,y),z);\n}\n\n\nint[8] octanteMapper(int oct)\n{\n    int[8] indecies = int[8](0, 0, 0, 0, 0, 0, 0, 0);\n    switch(oct){\n    case 1:\n        indecies = int[8](11, 12, 14, 15, 2, 3, 5, 6);\n        break;\n    case 0:\n        indecies = int[8](20, 21, 23, 24, 11, 12, 14, 15);\n        break;\n    case 2:\n        indecies = int[8](23, 24, 26, 27, 14, 15, 17, 18);\n        break;\n    case 3: // frb\n        indecies = int[8](14, 15, 17, 18, 5, 6, 8, 9);\n        break;\n    case 4: // blb\n        indecies = int[8](22, 23, 25, 26, 13, 14, 16, 17);\n        break;\n    case 5: // blt\n        indecies = int[8](19, 20, 22, 23, 10, 11, 13, 14);\n        break;\n    case 6: // flt\n        indecies = int[8](10, 11, 13, 14, 1, 2, 4, 5);\n        break;\n    case 7: // flb\n        indecies = int[8](13, 14, 16, 17, 4, 5, 7, 8);\n        break;\n    }\n    return indecies;\n}\nfloat noise3simple(vec3 point)\n{\n    vec3 center = vec3(0., 0., 2.0);\n    vec3 res = iResolution.xyy/iResolution.xxx;\n    \n    vec3[5] Parts = vec3[5](vec3(.4,1.,.6),vec3(-.3,-.9,-.8),vec3(-1.,1.,1.),vec3(.7,1.,-1.),vec3(.47,1.,-.3));\n    vec3[8] height;\n    vec3[8] corners;\n    \n    int q = octantX(point, center, corners);\n    if (q == 8){return 1.;}\n    for (int i = 0; i < 8; i++)\n    {\n    //This spot seems to be the problem \n    // The corner \"heights\" are not do not match\n    // in different quadrants\n        //q {0 - 7} we need to map these to a subset\n        // of 27 numbers\n        int[8] indecies = octanteMapper(q);\n        height[i] = normalize(vec3(\n            .65*Parts[indecies[i]*(43)%5].z,\n            .54*Parts[indecies[i]*(27)%5].y,\n            .75*Parts[indecies[i]*(37)%5].x));\n    }\n    \n    return calcNoise3d(corners, height, center, point);\n}\n\nfloat getValue3(vec3 point)\n{\n    return (noise3simple(point))+distance(point, vec3(0.0, 0.0, 2.0))-.7;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd)\n{\n    float distFromOrigin = 0.0;\n    float dist;\n    for( float i=0.0; i<MAX_STEPS; i++ ){\n        vec3 point =vec3(ro.x, ro.y, ro.z);\n        point.xyz += rd.xyz * distFromOrigin;\n        //println(\"ray O: \" + rayOrigin);\n        //println(\"Point: \" + point);\n        dist = getValue3(point);\n        //println(dist);\n        distFromOrigin += MAX_DIST/MAX_STEPS;\n        if(dist < SURFACE_DIST || distFromOrigin>MAX_DIST){ break; }\n    }\n    return distFromOrigin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 objAt = vec3(0.,0.,2.);\n    vec3 camAt = vec3(cos(iTime/15.)*2.,sin(iTime/15.)*2., -0.3);\n    vec2 screen = vec2(fragCoord/iResolution.xx*2. - iResolution.xy/iResolution.xx);\n    vec3 camDir = normalize(objAt - camAt);\n    camDir.xy += screen/2.;\n    camDir = normalize(camDir);\n    \n    float C = rayMarch(camAt, camDir)/MAX_DIST;\n    fragColor = vec4(vec3(C), 1.);\n}","name":"Image","description":"","type":"image"}]}