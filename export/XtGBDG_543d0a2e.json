{"ver":"0.1","info":{"id":"XtGBDG","date":"1543743725","viewed":175,"name":"Construction","username":"shutosg","description":"TDF2018に提出予定だった作品","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tdf2018"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//// rayの定義に視野角を使うか\n#define RAY_FOVY\n\n//// アニメーションするか\n// #define SCALE_ANIMATION\n#define GO_ANIMATION\n#define DIR_ANIMATION\n\n//// rotateするか\n#define USE_ROTATE\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n//// 各種パラメータ設定\n#define resolution iResolution\n#define duration 30.\n#define gTime iTime * .75\n#define PI 3.14159265\n#define INFINITY 1. / 0.\n#define RAY_HIT_THRESHOLD 0.001\n#define MAX_MARCHING_ITTRATION 128\n#define EDGE_THRESHOLD 0.0005\n#define FAR_CLIP 1E30\n#define FRACTAL_STEP 5\n\n//// enum\n#define OR  0\n#define AND 1\n#define SUB 2\n// material\n#define M_BASE 0.\n#define M_CROSS 1.\n#define M_EDGE 2.\n#define M_SPHEREE 3.\n#define M_TORUS 4.\n// color\n#define C_YELLOW vec3(.9, 1., .4)\n#define C_BLACK vec3(.0)\n#define C_WHITE vec3(1.)\n#define C_GRAY vec3(.05)\n#define C_PINK vec3(.8, .05, .35)\n#define C_RED vec3(.99, .0, .0)\n\n#define C_BASE C_BLACK\n#define C_CROSS C_RED\n#define C_EDGE C_RED\n#define C_TORUS C_BLACK\n#define C_AO C_WHITE\n\n/// Easing\nfloat easeOutExpo(float t, float from, float to, float dur)\n{\n    return from + (to - from) * (1. - pow(2., -10. * t / dur));\n}\n\n/// math\nfloat sin2(float x, float min, float max)\n{\n    float len = max - min;\n    return min + (len * sin(x) + len) * .5;\n}\n\nfloat max2(vec2 v)\n{\n    return max(v.x, v.y);\n}\n\n/// Noise Functions ==============================\nvec2 dotedRandom(vec2 st)\n{\n    st = vec2( dot(st,vec2(127.1,311.7)),\n                    dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat perlinNoise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n\n    vec2 v00 = dotedRandom(p+vec2(0,0));\n    vec2 v10 = dotedRandom(p+vec2(1,0));\n    vec2 v01 = dotedRandom(p+vec2(0,1));\n    vec2 v11 = dotedRandom(p+vec2(1,1));\n\n    return mix( mix( dot( v00, f - vec2(0,0) ), dot( v10, f - vec2(1,0) ), u.x ),\n                    mix( dot( v01, f - vec2(0,1) ), dot( v11, f - vec2(1,1) ), u.x ), \n                    u.y) + 0.5;\n}\n\nfloat fBm (vec2 st) \n{\n    float f = 0.;\n    vec2 q = st;\n\n    f += 0.5000 * perlinNoise( q );\n    q *= 2.01;\n    f += 0.2500 * perlinNoise( q );\n    q *= 2.02;\n    f += 0.1250 * perlinNoise( q );\n    q *= 2.03;\n    f += 0.0625 * perlinNoise( q );\n    q *= 2.01;\n\n    return f;\n}\n\nfloat animNoise(float speed, float offset, float scale)\n{\n    return scale * (fBm(vec2(cos(gTime * speed + offset / PI), sin(gTime * speed + offset / PI))) - .5);\n}\n\nvec3 getRayDirection(vec3 cDir, vec3 cUp, vec2 fPosition)\n{\n    vec3 cSide = cross(cDir, cUp);\n    float targetDepth = 1.0;\n#ifdef RAY_FOVY\n    float angle = 135. + 45. * easeOutExpo(gTime, 1., 0., 2.); \n    vec2 aspect = resolution.xy / min(resolution.x, resolution.y);\n    float fov = angle * 0.5 * PI / 180.;\n    float aspectm = max2(aspect);\n    return normalize(\n        cDir + \n        cSide * targetDepth * tan(fov * aspect.x / aspectm) * fPosition.x / aspect.x +\n        cUp * targetDepth * tan(fov * aspect.y / aspectm) * fPosition.y / aspect.y);\n#else\n    return normalize(cSide * fPosition.x + cUp * fPosition.y + cDir * targetDepth);\n#endif\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nvec2 rotate2d(vec2 xy, float thete)\n{\n    return mat2(cos(thete), -sin(thete), sin(thete), cos(thete)) * xy;\n}\n\n/// Filter effect ==============================\n\n// horizontal displacement map\nfloat displacementAmount(float gTimeOffset)\n{\n    // エフェクトの間隔\n    float gTimeInterval = 2.;\n    // sinc関数のxの範囲(0. ~ xRange)\n    float xRange = 20.;\n    float x = mod((iTime + gTimeOffset) * xRange / gTimeInterval, xRange);\n    return sin(x) / pow(x, 3.);\n}\nvec2 flHorizontalDisplacement(vec2 fPosition, float timeOffset)\n{\n    float noiseValue = (perlinNoise(floor(vec2(fPosition.y * 100., iTime + timeOffset)) / 1.01) - .5) * displacementAmount(0.) * 2.;\n    fPosition.x = fPosition.x + noiseValue * 3.0;\n    return fPosition;\n}\n\n/// Operations for Ray Marching ==============================\n// Union\nfloat opU(float d1, float d2)\n{\n    return min(d1, d2);\n}\nvec2 opU(vec2 d1, vec2 d2)\n{\n    if(d1.x < d2.x) return d1;\n    return d2;\n}\n\n// Substraction\nfloat opS(float d1, float d2)\n{\n    return max(d1, -d2);\n}\nvec2 opS(vec2 d1, vec2 d2)\n{\n    if(d1.x > -d2.x + EDGE_THRESHOLD) return d1;\n    if(d1.x < -d2.x - EDGE_THRESHOLD) return vec2(-d2.x, d2.y);\n    return vec2(d1.x, M_EDGE);\n}\nvec2 opS(vec2 d1, vec2 d2, vec3 p)\n{\n    if(d1.x > -d2.x + EDGE_THRESHOLD) return d1;\n    if(d1.x < -d2.x - EDGE_THRESHOLD) return vec2(-d2.x, d2.y);\n    // edge\n    float radius = mod(iTime / 2., 2.);\n    float margin = .1 * perlinNoise(p.xy * 10.);\n    float l = length(p);\n    if(l < radius + margin && l > radius - margin) return vec2(d1.x, M_EDGE);\n    return d1;\n}\n\n// Intersection\nfloat opI(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\n// Repetition\nvec3 opRep(vec3 p, vec3 interval)\n{\n    return mod(p, interval * 2.) - interval;\n}\nvec3 opRep(vec3 p, float interval) { return opRep(p, vec3(interval)); }\n\n/// Distance Functions ==============================\n// 2d Rectangle\nfloat dfRect(vec2 p, vec2 size)\n{\n    vec2 d = abs(p) - size;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// 3d Box\nvec2 dfBox(vec3 p, vec3 size)\n{\n    vec3 d = abs(p) - size;\n    return vec2(min(max(d.x, max(d.y, d.z)), .0) + length(max(d, .0)), M_BASE);\n}\n\nvec2 dfInfCross(vec3 p, float side)\n{\n    // optimized\n    float pillarX = dfRect(p.xy, vec2(side));\n    float pillarY = dfRect(p.yz, vec2(side));\n    float pillarZ = dfRect(p.zx, vec2(side));\n    /*\n    vec2 pillarX = dfBox(p, vec3(INFINITY, side, side));\n    vec2 pillarY = dfBox(p, vec3(side, INFINITY, side));\n    vec2 pillarZ = dfBox(p, vec3(side, side, INFINITY));\n    */\n    return vec2(opU(pillarX, opU(pillarY, pillarZ)), M_CROSS);\n}\n\nvec2 dfSphere(vec3 p, vec3 position, float scale)\n{\n    float radius = 1. * scale;\n    return vec2(length(p - position) - radius, M_SPHEREE);\n}\n\nvec2 dfTorus(vec3 p, vec3 position, float size, float thickness){\n    vec2 r = vec2(length(p.xy) - size, p.z);\n    return vec2(length(r) - thickness, M_TORUS);\n}\n\nvec2 dfMenger(vec3 p)\n{\n    float cubeSize = 1.;\n    float count = 1.;\n    vec2 baseCube = dfBox(p, vec3(cubeSize));\n    vec2 dist = baseCube;\n    for(int i=1; i<=FRACTAL_STEP; i++)\n    {\n        // if(i > int(floor(mod(gTime * 3., 5.)))) break;\n        // float repeatInterval = 1.25 - abs(pow(1. * cos(gTime / PI), 2.) * 1.0);\n        float repeatInterval = 0.6 - abs(.2 * cos(gTime / PI *.5));\n        // float repeatInterval = 1. / 3.;\n        vec3 a = opRep(p * count, repeatInterval);\n        vec3 r = 1. - 3. * abs(a);\n\n        count *= 3.;\n        vec2 c = vec2(dfInfCross(r, cubeSize / 3.).x / count, M_CROSS);\n        dist = opS(dist, c, p);\n    }\n    return dist;\n}\n\nvec2 dfSphere2(vec3 p)\n{\n    float z = 1.;\n    return opS(opS(opS(\n        dfSphere(p, vec3(0., 0., z), .065), \n        dfSphere(p, vec3(cos(gTime * 3.) * 0.05, sin(gTime * 2.) * 0.05, 0.04 * sin(gTime * 3.) + z), .025)),\n        dfSphere(p, vec3(cos(gTime * 2.) * 0.05, sin(gTime * 2.5) * 0.065, 0.04 * sin(gTime * 2.) + z), .045)),\n        dfSphere(p, vec3(cos(gTime * 1.) * 0.05, sin(gTime * 3.5) * 0.065, 0.05 * sin(gTime * 1.) + z), .03));\n}\n\nvec2 distanceFunc(vec3 p)\n{\n    // vec2 dist = dfMenger(rotate(opRep(p, 1.5), radians(gTime / PI * 100.), vec3(1., 1., 0.)));\n    vec2 dist = opU(\n        dfMenger(opRep(vec3(p.xy, p.z -1.125 * gTime), vec3(vec2(1.25 + .25 * displacementAmount(-1.)), 1.001))),\n        dfSphere2(p));\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.0001;  // 法線を得るためにrayの始点をずらす量\n    return normalize(vec3(\n        distanceFunc(p + vec3(  d, 0.0, 0.0)).x - distanceFunc(p + vec3( -d, 0.0, 0.0)).x,\n        distanceFunc(p + vec3(0.0,   d, 0.0)).x - distanceFunc(p + vec3(0.0,  -d, 0.0)).x,\n        distanceFunc(p + vec3(0.0, 0.0,   d)).x - distanceFunc(p + vec3(0.0, 0.0,  -d)).x\n    ));\n}\n\nfloat getSimpleLightingDiffuse(vec3 rPosition, vec3 lightPos)\n{\n    vec3 normal = getNormal(rPosition);\n    return clamp(dot(lightPos, normal), 0.05, 1.0);\n}\n\nfloat getSoftShadow(vec3 rPosition, vec3 lDirection){\n    lDirection = normalize(lDirection);\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for(float t = 0.0; t < 50.0; t++){\n        h = distanceFunc(rPosition + lDirection * c).x;\n        if(h < 0.001){\n            return shadowCoef;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvec4 getColor(vec2 fPosition)\n{\n    // camera\n#ifdef SCALE_ANIMATION\n    float k = 9.;\n    float animTime = mod(gTime, 3.);\n    if(mod(floor(gTime / 3.), 2.) == 1.) animTime = 3. - animTime; \n    vec3 cPosition = vec3(0.0,  0.0,  2.) + vec3(fBm(vec2(cos(gTime / PI), sin(gTime / PI))) - .5, fBm(vec2(sin(gTime / PI), cos(gTime / PI))) - .5, mix(200., .0, 1.0 - exp( -animTime * k )));\n#elif defined GO_ANIMATION\n    float camSpeed = 1.;\n    vec3 cPosition = vec3(0.0,  0.0,  2.25) + \n    vec3(animNoise(1., 0., .1),\n         animNoise(1., 10., .2),\n         -1.125);\n#else\n    vec3 cPosition = vec3(0.0,  0.0,  2.25);\n#endif\n\n#ifdef DIR_ANIMATION\n    vec3 cDirection = vec3(\n        animNoise(0.1, 1., 7.5),\n        animNoise(0.1, 0., 7.5),\n        -1.);\n#else\n    vec3 cDirection = vec3(0.0,  0.0, -1.0);\n#endif\n\n    // light\n    vec3 lPosition = vec3(0.577, 2., 1.577);\n    \n    // rayの方向ベクトル\n    vec3 rDirection = getRayDirection(cDirection, vec3(0., 1., 0.), fPosition);\n    \n    // marching loop\n    vec2 distance = vec2(0.); // rayとオブジェクト間の最短距離\n    float rLength = 0.0;     // rayの長さ\n    vec3  rPosition = cPosition;    // rayの先端位置\n    float ittrCount = 0.;\n    for(int i = 0; i < MAX_MARCHING_ITTRATION; i++) {\n        distance = distanceFunc(rPosition);\n        float absDist = abs(distance.x);\n        if(distance.y == M_SPHEREE && (absDist < RAY_HIT_THRESHOLD || absDist > FAR_CLIP)) {\n            rLength += distance.x;\n            vec3 newDir = getNormal(rPosition);\n            rPosition = cPosition + rDirection * rLength;\n            rDirection = newDir;\n            ittrCount++;\n            continue;\n        }\n        if(absDist < RAY_HIT_THRESHOLD || absDist > FAR_CLIP) { break; }\n        rLength += distance.x;\n        rPosition = cPosition + rDirection * rLength;\n        ittrCount++;\n    }\n    \n    // 衝突判定\n    float diffuse = getSimpleLightingDiffuse(rPosition, lPosition);\n    float shadow = getSoftShadow(rPosition + getNormal(rPosition) * 0.001, lPosition);\n    vec3 color = C_BASE; \n    if (distance.y == M_BASE)  color = C_BASE;\n    if (distance.y == M_CROSS) color = C_CROSS;\n    if (distance.y == M_EDGE)  color = C_EDGE;\n    \n    float aoCoeff = smoothstep(0., 1., ittrCount / float(MAX_MARCHING_ITTRATION));  // AOの係数(濃さ)\n    return vec4(color * diffuse * max(.5, shadow) * (1. - aoCoeff) + C_AO * aoCoeff, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // fragment position\n    vec2 fPosition = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    \n    fragColor = getColor(flHorizontalDisplacement(fPosition, 0.));\n}","name":"Image","description":"","type":"image"}]}