{"ver":"0.1","info":{"id":"McjGR1","date":"1703945788","viewed":34,"name":"Donut sector sampling","username":"mrboggieman","description":"Sample along donut sectors","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sampling","donut","sector"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A simple way of distributing random points so there is at least a minimum distance between the points\n// We map each point to a segment of a circle with a hole in the middle\n// Each point is allocated every other segment to ensure they are a segment apart\n\nconst float center_percent = 0.5;\n\nconst int num_points = 5;\n\n// START\nconst int num_segments = num_points * 2;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy * 0.5;\n    float radius = min(center.x, center.y);\n    \n    float min_radius = radius * center_percent;\n    float max_radius = radius;\n    \n    // draw the donut\n    vec2 point_dir = fragCoord - center;\n    float point_dist = length(point_dir);\n    \n    if (point_dist < min_radius || point_dist > radius) {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n        return;\n    }\n    \n    float wedge_size = 2.0 * PI / float(num_segments);\n    \n    //generate a point for every other segment and position randomly within the segment\n    for (int i=0; i<int(float(num_segments)/2.0); i++) {\n        float wedge_start = float(i*2)*wedge_size;\n\n        float rand_angle = rand_between(iTime+float(i), wedge_start, wedge_start + wedge_size);\n        float rand_radius = rand_between(iTime+float(i+num_segments), min_radius, max_radius);\n        \n        vec2 rand_point = center + rotate(right * rand_radius, rand_angle);\n        \n        if (distance(rand_point, fragCoord) < 10.0) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n    }\n\n    // change the colour based on the index of the segment along the donut\n    float angle = abs_angle(right, point_dir);\n    int wedge_index = int(angle / wedge_size);\n\n    fragColor = vec4(rand(wedge_index), rand(wedge_index+1), rand(wedge_index+2), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI  = 3.14159265358979323846264;\n\nconst vec2 right = vec2(1.0, 0.0);\n\n// Noise\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(in float n) {\n    return fract(sin(n) * 43758.5453123);\n}\n\nfloat rand(in int n) {\n    return rand(float(n));\n}\n\nfloat rand_between(in float n, in float min_val, in float max_val) {\n    return (rand(n) * (max_val-min_val)) + min_val;\n}\n\n// Angle from pos\nfloat det2(in vec2 a, in vec2 b) {\n    return a.x*b.y - b.x*a.y;\n}\n\nfloat abs_angle(in vec2 a, in vec2 b) {\n    //gives a number from 0 to 2PI in an anti-clockwise rotation from right vec\n    return atan(det2(-a, b), dot(a, -b)) + PI;\n}\n\nvec2 rotate(in vec2 a, in float angle) {\n    return mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    ) * a;\n}\n","name":"Common","description":"","type":"common"}]}