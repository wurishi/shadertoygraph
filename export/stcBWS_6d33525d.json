{"ver":"0.1","info":{"id":"stcBWS","date":"1664493293","viewed":62,"name":"IDKhowToMakeATorus","username":"RedWool","description":"cruller","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["letstry"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat3 rotY (float a)\n{\n    return mat3(\n    cos(a), 0, -sin(a),\n    0,1,0,\n    sin(a),0,cos(a));\n}\n\nmat3 rotZ (float a)\n{\n    return mat3(\n    cos(a),-sin(a),0,\n    sin(a),cos(a),0,\n    0,0,1);\n}\n\nfloat sdfTorus (vec3 o, vec3 c, float r, float t)\n{\n\n    vec3 dif = o - c;\n    dif.xz -= r * normalize(dif.xz);\n    \n    return length(dif)-t;\n}\n\nfloat cruller(vec3 o)\n{\n    return sdfTorus(o * rotY(iTime*1.) * rotZ(iTime*1.47), vec3(0), 2., .8) \n    + sin(o.x * 5. + o.z * 5.+iTime*1.) * .2;\n}\n\nfloat map(vec3 o)\n{\n    float dist = cruller(o);\n    for (int i = 0; i < 5; i++)\n    {\n        dist = min(dist, dist);\n    }\n    return dist;\n}\n\nvec3 normal(vec3 o)\n{\n    vec3 s = vec3(.001, 0, 0);\n    return normalize(vec3(\n    map(o + s.xyy) - map(o - s.xyy),\n    map(o + s.yxy) - map(o - s.yxy),\n    map(o + s.yyx) - map(o - s.yyx)));\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd)\n{\n    float dist = 0.;\n    const int maxMarch = 32;\n    const float minDist = .001;\n    const float maxDist = 100.;\n    \n    for(int i = 0; i < maxMarch; i++)\n    {\n        vec3 co = ro + rd * dist;\n        \n        float cd = map(co);\n        \n        if (cd < minDist)\n        {\n            vec3 light = vec3(0,sin(iTime)*4.,0);\n            float inten = dot(normal(co), normalize(light-co))*.3+.8;\n            return vec3(.9,.5,.7)*inten;\n        }\n        else if (cd > maxDist)\n        {\n            break;\n        }\n        \n        dist += cd;\n    }\n    \n    return vec3(rd.y *.5+.5,rd.y*.5+.5,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    vec3 camPos = vec3(0,sin(iTime)*3.,-10);\n    vec3 ro = vec3(uv, 1);\n\n    // Time varying pixel color\n    vec3 col = rayMarch(camPos,ro);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}