{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n Some wierd balls.... umh... enjoy...\n\n 06/08/13: \n\tpublished\n\n 09/08/13: \n \timplemented an occlusion function where you can specify a range where you want to \n\tscan for minimum distance. This allows me to only scan in the proximity of the \n\tballs and I don't have to go all the way till the lightsource.\n\tThe result is that the shadows look better with only 10 iterations so you also get\n\ta performance boost.\n\t\nmuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define occlusion_enabled\n#define occlusion_pass1_quality 9\n#define occlusion_pass2_quality 8\n\n#define noise_use_smoothstep\n\n#define object_count 8\n#define object_speed_modifier 1.0\n\n#define render_steps 40\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\n\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, +.0,\n\t\t+.0, +.0,+1.0);\n}\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nfloat dist(vec3 p)//distance function\n{\n\tfloat t = iTime+4.0;\n\tfloat d = 1000.0;//p.y+2.0;\n\tp.y+=sin(t*.5)*.2;\n\td=min(length(p)-1.0,d);\n\t\n\tfor (int i=0; i<object_count; i++)\n\t{\n\t\tfloat fi = float(i); \n\t\tfloat tof=1442.530/float(object_count)*fi;\n\t\tvec3 offs = vec3(\n\t\t\tsin(t*.7+tof*6.0),\n\t\t\tsin(t*.8+tof*4.0),\n\t\t\tsin(t*.9+tof*3.0));\n\t\tvec3 v = p+normalize(offs)*1.3;\n\t\td = min(d,length(v)-.3);\n\t}\n\t\n\treturn d;\n}\n\nfloat amb_occ(vec3 p)\n{\n\tfloat acc=0.0;\n\t#define ambocce 0.2\n\n\tacc+=dist(p+vec3(-ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(-ambocce,+ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,-ambocce,+ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,-ambocce));\n\tacc+=dist(p+vec3(+ambocce,+ambocce,+ambocce));\n\treturn 0.5+acc /(16.0*ambocce);\n}\n\nfloat occ(vec3 start, vec3 light_pos, float size)\n{\n\tvec3 dir = light_pos-start;\n\tfloat total_dist = length(dir);\n\tdir = dir/total_dist;\n\t\n\tfloat travel = .1;\n\tfloat o = 1.0;\n\tvec3 p=start;\n\t\n\tfloat search_travel=.0;\n\tfloat search_o=1.0;\n\t\n\tfloat e = .5*total_dist/float(occlusion_pass1_quality);\n\t\n\t//pass 1 fixed step search\n\t\n\tfor (int i=0; i<occlusion_pass1_quality;i++)\n\t{\n\t\ttravel = (float(i)+0.5)*total_dist/float(occlusion_pass1_quality);\n\t\tfloat cd = dist(start+travel*dir);\n\t\tfloat co = cd/travel*total_dist*size;\n\t\tif (co<search_o)\n\t\t{\n\t\t\tsearch_o=co;\n\t\t\tsearch_travel=travel;\n\t\t\tif (co<.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//pass 2 tries to find a better match in close proximity to the result from the \n\t//previous pass\n\t\t\n\tfor (int i=0; i<occlusion_pass2_quality;i++)\n\t{\n\t\tfloat tr = search_travel+e;\n\t\tfloat oc = dist(start+tr*dir)/tr*total_dist*size;\n\t\tif (tr<.0||tr>total_dist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (oc<search_o)\n\t\t{\n\t\t\tsearch_o = oc;\n\t\t\tsearch_travel = tr;\n\t\t}\n\t\te=e*-.75;\n\t}\n\t\n\to=max(search_o,.0);\n\n\treturn o;\n}\n\nfloat occ(vec3 start, vec3 light_pos, float size, float dist_to_scan)\n{\n\tvec3 dir = light_pos-start;\n\tfloat total_dist = length(dir);\n\tdir = dir/total_dist;\n\t\n\tfloat travel = .1;\n\tfloat o = 1.0;\n\tvec3 p=start;\n\t\n\tfloat search_travel=.0;\n\tfloat search_o=1.0;\n\t\n\tfloat e = .5*dist_to_scan/float(occlusion_pass1_quality);\n\t\n\t//pass 1 fixed step search\n\t\n\tfor (int i=0; i<occlusion_pass1_quality;i++)\n\t{\n\t\ttravel = (float(i)+0.5)*dist_to_scan/float(occlusion_pass1_quality);\n\t\tfloat cd = dist(start+travel*dir);\n\t\tfloat co = cd/travel*total_dist*size;\n\t\tif (co<search_o)\n\t\t{\n\t\t\tsearch_o=co;\n\t\t\tsearch_travel=travel;\n\t\t\tif (co<.0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t//pass 2 tries to find a better match in close proximity to the result from the \n\t//previous pass\n\t\t\n\tfor (int i=0; i<occlusion_pass2_quality;i++)\n\t{\n\t\tfloat tr = search_travel+e;\n\t\tfloat oc = dist(start+tr*dir)/tr*total_dist*size;\n\t\tif (tr<.0||tr>total_dist)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tif (oc<search_o)\n\t\t{\n\t\t\tsearch_o = oc;\n\t\t\tsearch_travel = tr;\n\t\t}\n\t\te=e*-.75;\n\t}\n\t\n\to=max(search_o,.0);\n\n\treturn o;\n}\n\nvec3 normal(vec3 p,float e) //returns the normal, uses the distance function\n{\n\tfloat d=dist(p);\n\treturn normalize(vec3(dist(p+vec3(e,0,0))-d,dist(p+vec3(0,e,0))-d,dist(p+vec3(0,0,e))-d));\n}\n\nvec3 background(vec3 p,vec3 d)//render background\n{\n\tvec3 color = mix(vec3(.9,.6,.2),vec3(.1,.4,.8),d.y*.5+.5);\n\treturn color*(noise(d)+.3*pow(noise(d*4.0),4.0));\n\t//return texture(iChannel0,d).xyz*vec3(.2,.4,.6);\n}\n\nfloat noise(float p)\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\nvec3 object_material(vec3 p, vec3 d) //computes the material for the object\n{\n\tvec3 n = normal(p,.001); //normal vector\n\tvec3 oldn=n; float nns = 64.0; float nna = .1;\n\tn.x+=(noise(oldn.yz*nns)-.5)*nna;\n\tn.y+=(noise(oldn.zx*nns)-.5)*nna;\n\tn.z+=(noise(oldn.xy*nns)-.5)*nna;\n\tn=normalize(n);\n\tvec3 r = reflect(d,n); //reflect vector\n\tfloat ao = amb_occ(p); //fake ambient occlusion\n\tvec3 color = vec3(.0,.0,.0); //variable to hold the color\n\tfloat reflectance = 1.0+dot(d,n);\n\t//return vec3(reflectance);\n\t\n\tfloat or = occ(p,p+r*10.0,0.5,2.0);\n\t\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tfloat fi = float(i);\n\t\tvec3 offs = vec3(\n\t\t\t-sin(5.0*(1.0+fi)*123.4),\n\t\t\t-sin(4.0*(1.0+fi)*723.4),\n\t\t\t-sin(3.0*(1.0+fi)*413.4));\n\t\n\t\tvec3 lp = offs*100.0;\n\t\tvec3 ld = normalize(lp-p);\n\t\t\n\t\tfloat diffuse = dot(ld,n);\n\t\tfloat od=.0;\n\t\tif (diffuse>.0)\n\t\t{\n\t\t\tod = occ(p,lp,0.05,2.0);\n\t\t}\n\t\t\n\t\tfloat spec = pow(dot(r,ld)*.5+.5,100.0);\n\t\t\n\t\tvec3 icolor = vec3(.6,.6,.6)*diffuse*od*.6 + vec3(spec)*od*reflectance;\n\t\tcolor += icolor;\n\t}\n\n\tcolor += background(p,r)*(.1+or*reflectance);\n\n\t\n\treturn color*ao*1.2;\n\t\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x *= iResolution.x/iResolution.y; //fix aspect ratio\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n\t\n\tfloat t = iTime*.5*object_speed_modifier + 30.0;\n\tmouse += vec3(sin(t)*.1,sin(t)*.1,.0);\n\t\n\t//setup the camera\n\tvec3 p = vec3(.0,0.0,-2.0);\n\tp = rotate_x(p,mouse.y*9.0);\n\tp = rotate_y(p,mouse.x*9.0);\n\tp.y*.2;\n\tvec3 d = vec3(uv,1.0);\n\td.z -= length(d)*.6; //lens distort\n\td = normalize(d);\n\td = rotate_x(d,mouse.y*9.0);\n\td = rotate_y(d,mouse.x*9.0);\n\t\n\tvec3 sp = p;\n\tvec3 color;\n\tfloat dd;\n\t\n\t//raymarcing \n\tfor (int i=0; i<render_steps; i++)\n\t{\n\t\tdd = dist(p);\n\t\tp+=d*dd;\n\t\tif (dd<.001||dd>2.0) break;\n\t}\n\t\n\tif (dd<.03)\n\t{\n\t\tcolor = object_material(p,d);\n\t}\n\telse\n\t{\n\t\tcolor = background(p,d);\n\t}\n\t\n\tcolor = mix(color*color,color,1.4);\n\tcolor *=.8;\n\tcolor -= length(uv)*.1;\n\tcolor = cc(color,.5,.5);\n\tcolor += hash(uv.xy+color.xy)*.02;\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XslGRX","date":"1375811715","viewed":966,"name":"Wierd Balls","username":"mu6k","description":"Some wierd balls.... umh... enjoy...","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","spheres","shadows"],"hasliked":0,"parentid":"","parentname":""}}