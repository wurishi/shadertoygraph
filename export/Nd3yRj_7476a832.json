{"ver":"0.1","info":{"id":"Nd3yRj","date":"1653678799","viewed":172,"name":"Grainy static gradient","username":"020406","description":"Fork of Integer Hash II by iq: https://www.shadertoy.com/view/XlXcW4","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gradient","static","grain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2017 Inigo Quilez\n\n// Based on https://www.shadertoy.com/view/4tfyW4, but simpler and faster\n//\n// See these too: \n//\n// - https://www.shadertoy.com/view/llGSzw\n// - https://www.shadertoy.com/view/XlXcW4\n// - https://www.shadertoy.com/view/4tXyWN\n//\n// Not testes for uniformity, stratification, periodicity or whatever. Use (or not!) at your own risk\n\n\n  const uint k = 1103515245U;  // GLIB C\n//const uint k = 134775813U;   // Delphi and Turbo Pascal\n//const uint k = 20170906U;    // Today's date (use three days ago's dateif you want a prime)\n//const uint k = 1664525U;     // Numerical Recipes\n\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uvec3 p = uvec3(fragCoord / 1., 337.);\n    float r = (uv.x * hash(p).x * 0.5 * sin(iTime) + pow(uv.x, 1.)) / 1.;\n    float r2 = hash(uvec3(fragCoord * 0., 337.)).x;\n    float r3 = hash(uvec3(fragCoord * 100., 337.)).x;\n    float t = 0.5 * (1. + sin(iTime));\n    vec3 col = uv.y > t ? vec3(1.) - vec3(0.9 + (1. - r)/1., 0.85 - r, r2) : vec3(0.5 + (1. - r)/2., 0.85 - r, r2);\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}