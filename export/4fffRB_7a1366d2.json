{"ver":"0.1","info":{"id":"4fffRB","date":"1723911473","viewed":17,"name":"{ Recursive Voronoi }","username":"inverse_transpose","description":"Voronoi","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SS(v,d) smoothstep(1.0,-1.0,((v)-(d))/fwidth(v))\n#define ISS(v,d) (1.0-SS(v,d))\n#define hash22(u) textureLod(iChannel0, (u+.5)/256.0, 0.0).xy\n#define hash23(u) textureLod(iChannel0, (u+.5)/256.0, 0.0).xyz\n#define dot2(p) dot(p,p)\n\n#define MULT1 .5\n#define MULT2 .25\n#define MULT3 .125\n\n//#define GRID\n\nvec3 voronoi(in vec2 uv)\n{\n    vec2 ip = floor(uv);\n    vec2 fp = fract(uv);\n    \n    float md = 100.0;\n    vec2 mp = vec2(md);\n    vec2 mk = vec2(md);\n    \n    for (float i = -1.0; i < 1.01; ++i)\n    for (float j = -1.0; j < 1.01; ++j)\n    {\n        vec2 g = ip + vec2(i,j);\n        vec3 h = hash23(g*10.);\n\n        if (h.z < .75)\n        {\n            vec2 p = g + h.xy*MULT1;\n            vec2 k = uv - p;\n\n            float d = dot(k,k);\n            if (d < md)\n            {\n                md = d;\n                mp = p;\n                mk = k;\n            }\n        }\n        else\n        {\n            for (float u = 0.0; u < .99; u += 0.5)\n            for (float v = 0.0; v < .99; v += 0.5)\n            {\n                vec2 g2 = g + vec2(u,v);\n                vec3 h2 = hash23(g2*10.);\n                vec2 p = g2 + h2.xy*MULT2;\n                vec2 k = uv - p;\n                \n                if (h2.z < .5)\n                {\n                    float d = dot(k, k);\n                    if (d < md)\n                    {\n                        md = d;\n                        mp = p;\n                        mk = k;\n                    }\n                }\n                else\n                {\n                    for (float x = 0.0; x < .99; x += 0.5)\n                    for (float y = 0.0; y < .99; y += 0.5)\n                    {\n                        vec2 g3 = g2 + vec2(x,y);\n                        vec2 h3 = hash22(g3*10.);\n                        vec2 p = g3 + h3*MULT3;\n                        vec2 k = uv - p;\n                        \n                        float d = dot(k,k);\n                        if (d < md)\n                        {\n                            md = d;\n                            mp = p;\n                            mk = k;\n                        }\n                    }\n                }\n            }\n\n        }\n\n    }\n    \n    md = 100.0;\n    for (float i = -2.0; i < 2.01; ++i)\n    for (float j = -2.0; j < 2.01; ++j)\n    {\n        vec2 g = ip + vec2(i,j);\n        vec3 h = hash23(g*10.);\n        \n        if (h.z < .75)\n        {\n            vec2 p = g + h.xy*MULT1;\n            vec2 k = uv - p;\n            \n            if (dot2(k - mk) > 0.00001)\n            {\n                md = min(md, dot(0.5 * (mk + k), normalize(k - mk)));\n            }\n        }\n\n        else\n        {\n            for (float u = 0.0; u < .99; u += 0.5)\n            for (float v = 0.0; v < .99; v += 0.5)\n            {\n                vec2 g2 = g + vec2(u,v);\n                vec3 h2 = hash23(g2*10.);\n\n                if (h2.z < .5)\n                {\n                    vec2 p = g2 + h2.xy*MULT2;\n                    vec2 k = uv - p;\n                    \n                    if (dot2(k - mk) > 0.00001)\n                    {\n                        md = min(md, dot(0.5 * (mk + k), normalize(k - mk)));\n                    }\n                }\n                else\n                {\n                    for (float x = 0.0; x < .99; x += 0.5)\n                    for (float y = 0.0; y < .99; y += 0.5)\n                    {\n                        vec2 g3 = g2 + vec2(x,y);\n                        vec2 h3 = hash22(g3*10.);\n                        vec2 p = g3 + h3*MULT3;\n                        vec2 k = uv - p;\n                        \n                        if (dot2(k - mk) > 0.00001)\n                        {\n                            md = min(md, dot(0.5 * (mk + k), normalize(k - mk)));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return vec3(md, dot2(uv-mp), hash22(mp).x);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    vec2 R = iResolution.xy,\n        uv = (2.0*F - R.xy)/R.y;\n\n    uv.x += 20.*cos(iTime*.01);\n    uv.y += 20.*sin(iTime*.01);\n\n    vec3 d = voronoi(3.0*uv);\n    \n    float mdb = sqrt(d.x),\n          mdp = sqrt(d.y);\n          \n    vec3 c = vec3(.2);\n \n    c += 1.1*ISS(mdb,.2)*vec3(1);\n    c *= (1.15 + .5*cos(110.0*mdb));\n    \n    c += SS(mdb,.2)*vec3(1);\n    c = mix(c, vec3(0), SS(mdp,.02));\n    \n#ifdef GRID\n    vec2 fp = fract(2.5*uv);\n    if (abs(fp.x)>.98 || abs(fp.y)>.98)\n        c = vec3(.2);\n#endif\n\n    O = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}