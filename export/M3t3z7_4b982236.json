{"ver":"0.1","info":{"id":"M3t3z7","date":"1716426138","viewed":59,"name":"2d sdf repeat","username":"letbonsaibe","description":"2d sdf Symmetry/mirror/repeat/polar repeat","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","repeat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define iColor vec3(.5, 0., 0.)\n#define oColor vec3(.0, .5, 0.)\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCircle( in vec2 p, in vec2 c, in float r) {\n    return distance(p, c) - r;\n}\n\n\nfloat circleAndBox(in vec2 p) {\n    return min(sdBox(p-vec2(0.5), vec2(.5, 0.4)), sdCircle(p, vec2(0.2), 0.5));\n}\n\nvec2 mirror( in vec2 p)\n{\n    p.x = abs(p.x);\n    return p;\n}\n\nvec2 mirror2(in vec2 p) {\n    float angle = sin(iTime) * 6.18;\n    mat2 rotaion = mat2(\n        cos(angle), -sin(angle),\n        sin(angle), cos(angle)\n    );\n    return rotaion*p;\n}\n\nvec2 repeat1( vec2 p )\n{\n    p.x = p.x - round(p.x);\n\treturn p;\n}\n\nvec2 repeat2( vec2 p )\n{\n\treturn p - round(p);\n}\n\nvec2 repeat3( vec2 p, float rows )\n{\n    vec2 q = p * rows/2.0  ;\n    q = fract(q);\n    q = q * 2.0 - 1.0;\n    return q;\n}\n\nvec2 polarRepeat(vec2 p, float cells) {\n    const float PI = 3.141592653;\n    float cellSize = PI * 2. / cells;\n    vec2 polarP = vec2(atan(p.x, p.y), length(p));\n    polarP.x = mod(mod(polarP.x, cellSize) + cellSize, cellSize) + sin(iTime);\n    p.x = sin(polarP.x);\n    p.y = cos(polarP.x);\n    p = p * polarP.y;\n    return p;\n}\n\n\n// shameless stolen from https://www.ronja-tutorials.com/post/034-2d-sdf-basics/\nvoid paintSdf(inout vec3 color, float dist, float  lineDistance, float lineThinkness, float subLineThinkness, float subLineCount) {\n    float distanceChange = fwidth(dist) * .5; // anti aliasing\n\n    float majorLineDistance = abs(fract(dist / lineDistance + 0.5) - 0.5) * lineDistance;\n    float majorLines = smoothstep(lineThinkness - distanceChange, lineThinkness + distanceChange, majorLineDistance);\n    float distanceBetweenSubLines = lineDistance / subLineCount;\n    float subLineDistance = abs(fract(dist / distanceBetweenSubLines + 0.5) - 0.5) * distanceBetweenSubLines;\n    float subLines = smoothstep(subLineThinkness - distanceChange, subLineThinkness + distanceChange, subLineDistance);\n    color *= majorLines;\n    color *= subLines;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    \n    \n    // mirror1 \n    //float dist = circleAndBox(mirror(uv)) ;\n    \n    \n    // mirror2 \n    //float dist = circleAndBox(uv);;\n    //float dist2 = circleAndBox(mirror2(uv));\n    //dist = min(dist, dist2);\n    \n    // repeat1\n    //vec2 uv2 = repeat1(uv);\n    //uv2 = repeat2(uv);\n    \n    //float rows = 2.0;\n    //uv2 = repeat3(uv, rows);\n    \n   \n    vec2 uv2 = polarRepeat(uv, 3.0);\n    float dist = circleAndBox(uv2);\n\n    \n    vec3 color = mix(iColor, oColor, step(0., dist));\n    paintSdf(color, dist, 0.5, 0.02, 0.005, 3.0);\n    \n  \n  \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}