{"ver":"0.1","info":{"id":"sdS3R3","date":"1617808719","viewed":145,"name":"Cloud Texture - Andrew","username":"andrew741","description":"A worly noise render. It has multiple octaves (the number of them varies with a sing wave). The worly noise is 3D.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["clouds","worlynoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// remaps a value\nfloat map(float val, float cMin, float cMax, float nMin, float nMax)\n{\n    // a basic remapping function\n    // remapping from 0 - any\n    float nVal = val - cMin;\n    // scaling from 0 - (new_max - new_min)\n    nVal *= (nMax - nMin) / (cMax - cMin);\n    // adding the new min\n    nVal += nMin;\n    // returning it\n    return nVal;\n}\n\n\n// a heighly random persudo random number generator that takes in a vec3 and returns a vec3\nvec3 random(vec3 co)\n{\n    // note that this code is from another user (on shadertoy)\n    vec3 p = co;\n    p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n    vec3 output_ = fract(sin(p)*43758.5453123);\n\treturn output_;\n}\n\n\n// a smoothstep function\nfloat Smoothstep(float x)\n{\n    float k = clamp(x, 0., 1.);\n    return k * k * (3. - 2. * k);\n}\n\n\n// returns the output of random (contained extra code in an earlier version)\nvec3 RandPos(vec3 pos, float e)\n{\n    return random(pos);\n}\n\n\n// returns the magnitude\nfloat mag(vec3 v)\n{\n    // this is just the dot of v\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\n\n// returns a value between 0 and 1 (of worly noise)\nfloat WorlyNoise(vec3 sample_pos, float scale, int o)\n{\n    // e is unused and is here because it was used in an earlier version\n    float e = float(o);\n    // geting the sample poses cell pos\n    vec3 cell_pos = floor(sample_pos / scale);\n    \n    // generating cells/nabors positions\n    // layer 1\n    vec3 cell1 = cell_pos + vec3(1., -1., -1.);\n    vec3 cell2 = cell_pos + vec3(1., 0., -1.);\n    vec3 cell3 = cell_pos + vec3(1., 1., -1.);\n    \n    vec3 cell4 = cell_pos + vec3(0., -1., -1.);\n    vec3 cell5 = cell_pos + vec3(0., 0., -1.);\n    vec3 cell6 = cell_pos + vec3(0., 1., -1.);\n    \n    vec3 cell7 = cell_pos + vec3(-1., -1., -1.);\n    vec3 cell8 = cell_pos + vec3(-1., 0., -1.);\n    vec3 cell9 = cell_pos + vec3(-1., 1., -1.);\n    \n    // layer 2\n    vec3 cell10 = cell_pos + vec3(1., -1., 0.);\n    vec3 cell11 = cell_pos + vec3(1., 0., 0.);\n    vec3 cell12 = cell_pos + vec3(1., 1., 0.);\n    \n    vec3 cell13 = cell_pos + vec3(0., -1., 0.);\n    vec3 cell14 = cell_pos + vec3(0., 0., 0.);\n    vec3 cell15 = cell_pos + vec3(0., 1., 0.);\n    \n    vec3 cell16 = cell_pos + vec3(-1., -1., 0.);\n    vec3 cell17 = cell_pos + vec3(-1., 0., 0.);\n    vec3 cell18 = cell_pos + vec3(-1., 1., 0.);\n    \n    // layer 3\n    vec3 cell19 = cell_pos + vec3(1., -1., 1.);\n    vec3 cell20 = cell_pos + vec3(1., 0., 1.);\n    vec3 cell21 = cell_pos + vec3(1., 1., 1.);\n    \n    vec3 cell22 = cell_pos + vec3(0., -1., 1.);\n    vec3 cell23 = cell_pos + vec3(0., 0., 1.);\n    vec3 cell24 = cell_pos + vec3(0., 1., 1.);\n    \n    vec3 cell25 = cell_pos + vec3(-1., -1., 1.);\n    vec3 cell26 = cell_pos + vec3(-1., 0., 1.);\n    vec3 cell27 = cell_pos + vec3(-1., 1., 1.);\n    \n    // generating the random offests for cell points\n    // layer1\n    vec3 rand1 = RandPos(cell1, e) * scale;\n    vec3 rand2 = RandPos(cell2, e) * scale;\n    vec3 rand3 = RandPos(cell3, e) * scale;\n    vec3 rand4 = RandPos(cell4, e) * scale;\n    vec3 rand5 = RandPos(cell5, e) * scale;\n    vec3 rand6 = RandPos(cell6, e) * scale;\n    vec3 rand7 = RandPos(cell7, e) * scale;\n    vec3 rand8 = RandPos(cell8, e) * scale;\n    vec3 rand9 = RandPos(cell9, e) * scale;\n    // layer2\n    vec3 rand10 = RandPos(cell10, e) * scale;\n    vec3 rand11 = RandPos(cell11, e) * scale;\n    vec3 rand12 = RandPos(cell12, e) * scale;\n    vec3 rand13 = RandPos(cell13, e) * scale;\n    vec3 rand14 = RandPos(cell14, e) * scale;\n    vec3 rand15 = RandPos(cell15, e) * scale;\n    vec3 rand16 = RandPos(cell16, e) * scale;\n    vec3 rand17 = RandPos(cell17, e) * scale;\n    vec3 rand18 = RandPos(cell18, e) * scale;\n    // layer3\n    vec3 rand19 = RandPos(cell19, e) * scale;\n    vec3 rand20 = RandPos(cell20, e) * scale;\n    vec3 rand21 = RandPos(cell21, e) * scale;\n    vec3 rand22 = RandPos(cell22, e) * scale;\n    vec3 rand23 = RandPos(cell23, e) * scale;\n    vec3 rand24 = RandPos(cell24, e) * scale;\n    vec3 rand25 = RandPos(cell25, e) * scale;\n    vec3 rand26 = RandPos(cell26, e) * scale;\n    vec3 rand27 = RandPos(cell27, e) * scale;\n    \n    // generating the distance to each of those cell positions/points position (the mag not length)\n    // layer1\n    float dist1 = mag(sample_pos - (cell1 * scale + rand1));\n    float dist2 = mag(sample_pos - (cell2 * scale + rand2));\n    float dist3 = mag(sample_pos - (cell3 * scale + rand3));\n    float dist4 = mag(sample_pos - (cell4 * scale + rand4));\n    float dist5 = mag(sample_pos - (cell5 * scale + rand5));\n    float dist6 = mag(sample_pos - (cell6 * scale + rand6));\n    float dist7 = mag(sample_pos - (cell7 * scale + rand7));\n    float dist8 = mag(sample_pos - (cell8 * scale + rand8));\n    float dist9 = mag(sample_pos - (cell9 * scale + rand9));\n    // layer2\n    float dist10 = mag(sample_pos - (cell10 * scale + rand10));\n    float dist11 = mag(sample_pos - (cell11 * scale + rand11));\n    float dist12 = mag(sample_pos - (cell12 * scale + rand12));\n    float dist13 = mag(sample_pos - (cell13 * scale + rand13));\n    float dist14 = mag(sample_pos - (cell14 * scale + rand14));\n    float dist15 = mag(sample_pos - (cell15 * scale + rand15));\n    float dist16 = mag(sample_pos - (cell16 * scale + rand16));\n    float dist17 = mag(sample_pos - (cell17 * scale + rand17));\n    float dist18 = mag(sample_pos - (cell18 * scale + rand18));\n    // layer3\n    float dist19 = mag(sample_pos - (cell19 * scale + rand19));\n    float dist20 = mag(sample_pos - (cell20 * scale + rand20));\n    float dist21 = mag(sample_pos - (cell21 * scale + rand21));\n    float dist22 = mag(sample_pos - (cell22 * scale + rand22));\n    float dist23 = mag(sample_pos - (cell23 * scale + rand23));\n    float dist24 = mag(sample_pos - (cell24 * scale + rand24));\n    float dist25 = mag(sample_pos - (cell25 * scale + rand25));\n    float dist26 = mag(sample_pos - (cell26 * scale + rand26));\n    float dist27 = mag(sample_pos - (cell27 * scale + rand27));\n    \n    // finding the smallest value\n    // layer1\n    float strength1 = min(min(min(dist1, dist2), min(dist3, dist4)), min(min(dist5, dist6), min(dist7, min(dist8, dist9))));\n    // layer2\n    float strength2 = min(min(min(dist10, dist11), min(dist12, dist13)), min(min(dist14, dist15), min(dist16, min(dist17, dist18))));\n    // layer3\n    float strength3 = min(min(min(dist19, dist20), min(dist21, dist22)), min(min(dist23, dist24), min(dist25, min(dist26, dist27))));\n    // finding the overal smallest and taking the square root of it to get the length to it\n    // layers all\n    float strength = sqrt(min(min(strength1, strength2), strength3));\n    \n    // returning and remapping\n    return map(strength / (scale * 1.25), 0., 1., 1., 0.);\n}\n\n// generates a noise texture (a height from 0 - 1 based on position)\nfloat OctaveWorly(vec2 fragCoord, vec4 iMouse, int octaves, float scale, float persistance, float luclarity, vec3 offset)\n{   \n    // initializing veriables\n    float height = 0.;\n    float l = 1.;\n    float total = 0.;\n    // looping over all octaves\n    for (int o = 0; o < octaves; o++)\n    {\n        // getting the height for that octave and adding it\n        height += WorlyNoise(vec3(fragCoord + floor(iMouse.xy) + WorlyNoise(vec3(fragCoord + floor(iMouse.xy) + float(o * 2000) - 500., (iTime * 10.)) + offset, scale * 0.25, o) * 128. + float(o * 2000), (iTime * 10.)) + offset, scale, o) * l;\n        // this is to remap the final height\n        total += l * 0.95;  // the 0.95 is because the height of the bumps (when added up) is almost never equal to the max height and thefore the more octaves, the duller the color\n        // changing the height and scale based on inputed paramaters\n        l *= luclarity;\n        scale *= persistance;\n    }\n    // remaping the final height\n    height /= total;\n    // returning the height\n    return height;\n}\n\n\n// main loop/the shader\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv (unused rn)\n    vec2 uv = fragCoord/iResolution.xy * vec2(1., 0.75);\n    // getting the cloud texture\n    float height = OctaveWorly(fragCoord * vec2(1., 0.75), iMouse, int(round(map(cos(iTime / 6. + 3.1415), -1., 1., 1., 6.))), 125., 0.5, 0.4, vec3(0.));\n    height = pow(1. - abs(height * 2. - 1.), 1.5);\n    // creating the color based on it\n    vec3 col = mix(vec3(0.9, 0.4, 0.8) * height + vec3(0., 0.4, 0.6) * pow(height, 4.), mix(vec3(0.3, 0.8, 0.5) * height, vec3(0.8, 0.2, 0.6) / height, 0.7), min(pow(smoothstep(0., 0.5, 1. - height), 8.), 0.7));\n    //col = vec3(height);\n\n    col *= vec3(smoothstep(0.25 * height, 1., uv.x), 0.5, smoothstep(0.25 * height, 1., 1.-uv.x));\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}