{"ver":"0.1","info":{"id":"McscDN","date":"1721163578","viewed":21,"name":"Spiral 2 - Gradient","username":"L1x3N","description":"Added my trusted gradient setup. \nI know that there's a bit of antialiasing but I don't know the right piece of code to use yet.\nI leave the consts to you, my dear followers (sike, I have 0 followers yet :'D)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["spiral","colorful","gradient","endless","rotation","twirl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3[] COLORS_VALUES = vec3[](vec3(0.), vec3(1., 0., 0.), vec3(0.), vec3(0., 1., 0.), vec3(0.), vec3(0., 0., 1.), vec3(0.));\nconst float[] COLORS_POS = float[](0., 23. / 100., 33. / 100., 56. / 100., 66. / 100., 89. / 100., 1.);\n\nconst bool GRADIENT_BLEND_MODE = false;\nconst bool ASPECT_RATIO = true;\n\nconst float SPIRAL_SPEED = 1.1;\nconst float SPIRAL_STRENGTH = 6.5;\nconst float SPIRAL_INTENSITY = 4.;\nconst bool ADD_TIME = false;\n\nvec2 rotate_center(vec2 myUvs, vec2 center, float angle) {\n    float s = sin(angle), c = cos(angle);\n    mat2 rMatrix = (mat2(c, - s, s, c) * 0.5 + 0.5) * 2. - 1.;\n    return (myUvs - center) * rMatrix + center;\n}\n\nvec2 twirl_center(vec2 myUvs, vec2 center, float strength, vec2 offset) {\n    vec2 delta = myUvs - center;\n    float angle = strength * length(delta);\n    float x = cos(angle) * delta.x - sin(angle) * delta.y;\n    float y = sin(angle) * delta.x + cos(angle) * delta.y;\n    return vec2(x + center.x + offset.x, y + center.y + offset.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Uv setup\n\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 newUv = uv - 0.5;\n\n    if(ASPECT_RATIO)\n        newUv.x *= iResolution.x / iResolution.y;\n\n    newUv = rotate_center(newUv, vec2(0.), SPIRAL_SPEED * (ADD_TIME ? iTime : - iTime));\n    newUv = twirl_center(newUv, vec2(0.), SPIRAL_STRENGTH, vec2(0.));\n\n    // Uv fun stuff !\n\n    float spiralUv;\n\n    spiralUv = fract((newUv.x) * SPIRAL_INTENSITY);\n\n    // Applying gradient from arrays\n\n    vec3 myColor;\n\n    int colorPosIndex;\n    for(colorPosIndex = 0; colorPosIndex < (COLORS_POS.length()); colorPosIndex ++) {\n        if(spiralUv < COLORS_POS[colorPosIndex])\n            break;\n    }\n\n    if(GRADIENT_BLEND_MODE) {\n        float colorUv = (spiralUv - COLORS_POS[colorPosIndex - 1]) / (COLORS_POS[colorPosIndex] - COLORS_POS[colorPosIndex - 1]);\n        myColor = mix(COLORS_VALUES[colorPosIndex - 1], COLORS_VALUES[colorPosIndex], colorUv);\n    } else {\n        myColor = COLORS_VALUES[colorPosIndex];\n    }\n\n    // myColor = vec3(spiralUv);\n\n    fragColor = vec4(myColor, 1.);\n}","name":"Image","description":"","type":"image"}]}