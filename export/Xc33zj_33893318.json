{"ver":"0.1","info":{"id":"Xc33zj","date":"1711876772","viewed":54,"name":"video pixel to circle","username":"yufengjie","description":"A small attempt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["video","circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define resolution 80.\n#define circleRadius 0.5\n\nfloat pix;\n\nfloat plotCircle(vec2 p, vec2 c) {\n    float cir = length(p-c) - 0.1;\n    return smoothstep(pix*4., 0., cir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y * resolution;\n    pix = 1. / iResolution.y * resolution;\n    vec2 uvi = floor(uv);\n    vec2 uvf = fract(uv);\n    \n    vec3 c_fin = vec3(0.);\n    float cir = plotCircle(uvf, vec2(0.5));\n    \n    vec2 uv2 = fragCoord/iResolution.xy;\n    vec3 c_video = texture(iChannel0, uv2).rgb;\n    \n    float l = dot(c_video, vec3(0.2126, 0.7152, 0.0722));\n    //float l = c_video.r;\n    \n    \n    if(l>0.5) {\n        vec3 c = palette(noise(uvi/resolution + iTime));\n       c_fin += cir * c;\n    }\n    \n    \n\n\n    fragColor = vec4(c_fin,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nvec3 palette(float t) {\n  vec3 a = vec3(0.731, 1.098, 0.192);\n  vec3 b = vec3(0.358, 1.090, 0.657);\n  vec3 c = vec3(1.077, 0.360, 0.328);\n  vec3 d = vec3(0.965, 2.265, 0.837);\n  return a + b * cos(6.28318 * (c * t + d));\n}","name":"Common","description":"","type":"common"}]}