{"ver":"0.1","info":{"id":"MlGBDc","date":"1544279345","viewed":382,"name":"Simple Raytracer with Atmosphere","username":"skythedragon","description":"A simple raytracer that also includes atmospheric fog.\nIt's the first shader I ever made.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","fog","rendering","atmosphere","dem"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// define some standard values\n#define Epsilon 1e-3\n#define Bounces 4 // light bounces\n#define Max 1e24 // high value for distance\n\n\n// ray struct\nstruct Ray {\n    vec3 Origin;\n    vec3 Direction;\n};\n    \n// Material struct, stores material properties\nstruct Material {\n    vec3 Color;\n    float Diffuse;\n    float Specular;\n};\n    \n// struct representing a ray hitting the surface\n// length is 0 for a miss\nstruct Hit {\n\tvec3 Normal;\n    float Length;\n    Material material;\n};\n\nconst Hit miss = Hit(vec3(0), 0.0, Material(vec3(0), 0.0, 0.0));\n\n// a sunlight\nstruct DirectionalLight {\n    vec3 Direction;\n    vec3 Color;\n};\n    \n// objects\nstruct Sphere {\n    float Radius;\n    vec3 Position;\n    Material material;\n};\n\nstruct Plane {\n    vec3 Normal;\n    Material material;\n};\n\n// intersection functions\n// sphere\nHit Intersect(Ray ray, Sphere sphere) {\n    // Check for a Negative Square Root\n    vec3 oc = sphere.Position - ray.Origin;\n    float l = dot(ray.Direction, oc);\n    float det = pow(l, 2.0) - dot(oc, oc) + pow(sphere.Radius, 2.0);\n    if (det < 0.0) return miss;\n\n    // Find the Closer of Two Solutions\n             float len = l - sqrt(det);\n    if (len < 0.0) len = l + sqrt(det);\n    if (len < 0.0) return miss;\n    return Hit((ray.Origin + len*ray.Direction - sphere.Position) / sphere.Radius, len, sphere.material);\n}\n\n\n\n\n// Plane\nHit Intersect(Ray ray, Plane plane) {\n    float len = -dot(ray.Origin, plane.Normal) / dot(ray.Direction, plane.Normal);\n    if (len < 0.0) return miss;\n    return Hit(plane.Normal, len, plane.material);\n}\n\n// traces the scene, in this case it's hardcoded\nHit Trace(Ray ray) {\n    // scene\n    Hit SphereA = Intersect(ray, Sphere(2.0, vec3(-3, 1.9, 2), Material(vec3(0.0, 0.16, 0.28), 0.1, 0.1)));\n    Hit SphereB = Intersect(ray, Sphere(2.0, vec3(3, 1.9, 2), Material(vec3(0.9, 0.9, 0.9), 0.5, 0.1)));\n    Hit plane = Intersect(ray, Plane(vec3(0, 1, 0), Material(vec3(1.0, 1.0, 1.0), 1.0, 0.0)));\n    // distance\n    float dist = 1e12;\n    Hit vout = miss;\n    if (SphereA != miss && SphereA.Length < dist) { vout = SphereA; dist = SphereA.Length; }\n    if (SphereB != miss && SphereB.Length < dist) { vout = SphereB; dist = SphereB.Length; }\n    if (plane != miss && plane.Length < dist) { vout = plane; dist = plane.Length; }\n    return vout;           \n}\n\n// function to add atmospheric fog to the image\n// original by Inigo Quilez https://iquilezles.org/articles/fog\nvec3 ApplyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    float fogAmount = 1.0; - exp( -distance*1.0);\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.3,0.7,1.0)*8.0, // bluish\n                           vec3(1.0,0.9,0.7)*32.0, // yellowish\n                           pow(sunAmount,64.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n \n\n// const DirectionalLight light = DirectionalLight(normalize(vec3(-1.0, 0.75, 1.0)), vec3(100));\n\n// computes the color of a ray\nvec3 CalculateColor(Ray ray) {\n    \n    DirectionalLight light = DirectionalLight(normalize(vec3(cos(iTime/2.0), 0.5, sin(iTime/2.0))), vec3(200,200,200));\n    \n    vec3 Color = vec3(0);\n    vec3 fresnel = vec3(0);\n    vec3 mask = vec3(1.0);\n    for(int i = 0; i < Bounces; ++i) {\n        Hit hit = Trace(ray);\n        if (hit != miss) { \n            // if it hit something\n            vec3 r0 = hit.material.Color.rgb * hit.material.Specular;\n            float hv = clamp(dot(hit.Normal, -ray.Direction), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 8.0);\n            mask *= fresnel;\n            \n            if (Trace(Ray(ray.Origin + hit.Length * ray.Direction + Epsilon * light.Direction, light.Direction)) == miss) {\n                \n                Color += clamp(dot(hit.Normal, light.Direction), 0.0, 1.0) * light.Color\n                       * hit.material.Color.rgb * hit.material.Diffuse\n                       * (1.0 - fresnel) * mask / fresnel;\n                // mask = vec3(0);\n            \n            }\n\n            // new ray\n            vec3 reflection = reflect(ray.Direction, hit.Normal);\n            ray = Ray(ray.Origin + hit.Length * ray.Direction + Epsilon * reflection, reflection);\n\n        } else {\n            \n            Color += mask * ApplyFog(Color, float(Max), ray.Direction, light.Direction)*8.0; // apply fog too\n            break;\n            \n        }\n    }\n    return Color;\n}\n  \n\n\n// now render the image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv    = fragCoord.xy / iResolution.xy - vec2(0.5);\n         uv.x *= iResolution.x / iResolution.y;\n\t\n    float exposure = 1e-2;\n\tfloat gamma = 2.3;\n\n    Ray ray = Ray(vec3(0.0, 2.5, 12.0), normalize(vec3(uv.x, uv.y, -1.0)));\n    fragColor = vec4(pow(CalculateColor(ray) * exposure, vec3(1.0 / gamma)), 1.0);\n}","name":"Image","description":"","type":"image"}]}