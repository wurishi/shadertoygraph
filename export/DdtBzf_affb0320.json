{"ver":"0.1","info":{"id":"DdtBzf","date":"1699567648","viewed":38,"name":"TP  BOUDJEBBOUR- AZIZI","username":"mboudj","description":"Ray tracing","likes":0,"published":1,"flags":0,"usePreview":1,"tags":["cylindre"],"hasliked":0,"parentid":"mdGczy","parentname":"anis"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//BOUDJEBBOUR Maya, AZIZI Anis\nstruct Sphere {\n    vec3 c; \n    float r; \n    int i; \n};\n\nstruct Ellipsoid {\n    vec3 center;\n    vec3 radii; \n    int i;\n};\n\nstruct Cylinder {\n    vec3 a; \n    vec3 b; \n    float r; \n    int i; \n};\n\nstruct Cube {\n    vec3 center; \n    float size;  \n    int textureId; \n};\n\nstruct Capsule {\n    vec3 a; \n    vec3 b; \n    float r;\n    int i; \n};\n\nstruct Torus {\n    vec3 center; \n    float majorRadius;  \n    float minorRadius;  \n    int i;        \n};\n\nstruct Plane {\n    vec3 n; \n    vec3 p; \n    int i; \n};\n\nstruct Hit {\n    float t; \n    vec3 n; \n    int i; \n};\n\nstruct Ray {\n    vec3 o;\n    vec3 d; \n};\n\nstruct Material {\n    vec3 amb;  \n    vec3 d;  \n    vec3 sp; \n    float shininess; \n    float reflection; \n};\n\n\nstruct UniformTexture {\n    vec3 color; \n};\n\nstruct CheckerTexture {\n    vec3 color1; \n    vec3 color2; \n    float sideLength; \n};\n\n\nUniformTexture UniformTextureFunction(vec3 p, UniformTexture texture) {\n    return texture; \n}\n\n\nCheckerTexture CheckerTextureFunction(vec3 p, CheckerTexture texture) {\n    int i = int(floor(p.x / texture.sideLength));\n    int j = int(floor(p.y / texture.sideLength));\n    int k = int(floor(p.z / texture.sideLength));\n    if ((i + j + k) % 2 == 0) {\n        return CheckerTexture(texture.color1, texture.color2, texture.sideLength);\n    } else {\n        return CheckerTexture(texture.color2, texture.color1, texture.sideLength);\n    }\n}\n\n// phong shader functtion\nvec3 PhongShading(Material mat, vec3 normal, vec3 lightDir, vec3 viewDir) {\n    vec3 ambient = mat.amb;\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    vec3 diffuse = mat.d * diff;\n    \n    vec3 reflectDir = reflect(-lightDir, normal);\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), mat.shininess);\n    vec3 specular = mat.sp * spec;\n    \n    return ambient + diffuse + specular;\n}\n\n// Texture de Damier utilisant les couleurs diffus et speculaire\nvec3 PhongCheckerTextureFunction(vec3 p, CheckerTexture texture, Ray ray) {\n    int i = int(floor(p.x / texture.sideLength));\n    int j = int(floor(p.y / texture.sideLength));\n    int k = int(floor(p.z / texture.sideLength));\n    if ((i + j + k) % 2 == 0) {\n        vec3 checkerColor = mix(texture.color1, texture.color2, 0.5);\n        Material squareMaterial = Material(vec3(0.1),vec3(0.5, 0.9, 0.9),vec3(0.3, 0.3, 0.3),20.0,0.); \n        vec3 squareNormal = vec3(0.0, 0.0, 1.0); \n        vec3 squarePoint = vec3(texture.sideLength * float(i), texture.sideLength * float(j), p.z);\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); \n        vec3 shadingColor = PhongShading(squareMaterial, p, lightDir, ray.d);\n        return checkerColor * shadingColor;\n    } else {\n        return mix(texture.color2, texture.color1, 0.5); \n    }\n}\n\n\n//Fonction de Translation\nvec3 translate(vec3 point, vec3 translation) {\n    return point + translation;\n}\n\n//Fonction de rotation\nvec3 rotate(vec3 point, vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float t = 1.0 - c;\n    axis = normalize(axis);\n    mat3 rotationMatrix = mat3(\n        t * axis.x * axis.x + c, t * axis.x * axis.y - s * axis.z, t * axis.x * axis.z + s * axis.y,\n        t * axis.x * axis.y + s * axis.z, t * axis.y * axis.y + c, t * axis.y * axis.z - s * axis.x,\n        t * axis.x * axis.z - s * axis.y, t * axis.y * axis.z + s * axis.x, t * axis.z * axis.z + c\n    );\n    return rotationMatrix * point;\n}\n\n//fonction d'homothétie\nRay homothetieVecteur(Ray ray, float scaleFactor) {\n    ray.d *= scaleFactor;\n    return ray;\n} \nfloat homothetieR(float ray, float scaleFactor) {\n    ray *= scaleFactor;\n    return ray;\n}\n\n\nfloat Checkers(in vec2 p) {\n    vec2 w = fwidth(p) + 0.001;\n    vec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n    return 0.5 - 0.5 * i.x * i.y;\n}\n\nvec3 Point(Ray ray, float t) {\n    return ray.o + t * ray.d;\n}\n\nMaterial Texture(vec3 p, int i) {\n    if (i == 1) {\n        return Material(vec3(0., 0., 0.),vec3(0.8, 0.5, 0.4),vec3(0., 0., 0.),0.0,0.0);\n    }\n    else if (i == 0) {\n        float f = Checkers(0.5 * p.xy);\n        vec3 col = vec3(0.4, 0.5, 0.7) + f * vec3(0.1);\n        return Material(vec3(0., 0., 0.),col,vec3(0., 0., 0.),0.0,0.0);\n    } else if (i==2) {\n    return Material(vec3(0.1, 0.1, 0.1),vec3(0.2, 0.2, 0.2), vec3(0.8, 0.8, 0.8),64.0,0.0); \n    } else if (i==3) {\n    return Material(vec3(0.1, 0.1, 0.1),vec3(0.0, 0.0, 0.0),vec3(1.0, 1.0, 1.0),256.0,0.0);\n    } else if(i==4) {\n    return Material(vec3(0.1, 0.1, 0.1),vec3(0.0, 0.0, 0.0),vec3(1.0, 1.0, 1.0),128.0,0.0);\n    } else if (i==5) {\n    return Material(vec3(0.1, 0.1, 0.1),vec3(0.9, 0.9, 0.9),vec3(0.8, 0.8, 0.8),32.0,0.0);\n    }\n    return Material(vec3(0., 0., 0.),vec3(0.0, 0.0, 0.),vec3(0., 0., 0.),0.0,0.0);\n}\n\n\n// Intersection avec une sphère\nbool IntersectSphere(Ray ray, Sphere sph, out Hit x) {\n    vec3 oc = ray.o - sph.c;\n    float b = dot(oc, ray.d);\n    float c = dot(oc, oc) - sph.r * sph.r;\n    float d = b * b - c;\n    if (d > 0.0) {\n        float t = -b - sqrt(d);\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            x = Hit(t, normalize(p - sph.c), sph.i);\n            return true;\n        }\n    }\n    return false;\n}\n\n// Intersection avec un ellipsoïde\nbool IntersectEllipsoid(Ray ray, Ellipsoid ellipsoid, out Hit x) {\n    vec3 oc = ray.o - ellipsoid.center;\n    vec3 e = ellipsoid.radii;\n    \n    float a = dot(ray.d / e, ray.d / e);\n    float b = 2.0 * dot((oc / e), (ray.d / e));\n    float c = dot(oc / e, oc / e) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n\n        float t = min(t1, t2);\n        if (t > 0.0) {\n            vec3 p = Point(ray, t);\n            vec3 n = normalize((2.0 * (p - ellipsoid.center)) / (e * e));\n            x = Hit(t, n, ellipsoid.i);\n            return true;\n        }\n    }\n    return false;\n}\n\n// Intersection avec un cylindre\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x) {\n    vec3 oc = ray.o - cyl.a;\n    vec2 d = ray.d.xy; \n    float a = dot(d, d);\n    float b = dot(oc.xy, d) * 2.0;\n    float c = dot(oc.xy, oc.xy) - cyl.r * cyl.r;\n\n    float discriminant = b * b - 4.0 * a * c;\n\n    x = Hit(1000.0, vec3(0), -1); \n\n    if (discriminant > 0.0) {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        float t = min(t1, t2);\n        float z_intersection = ray.o.z + t * ray.d.z;\n\n        if (t > 0.0 && z_intersection >= cyl.a.z && z_intersection <= cyl.b.z) {\n            vec3 p = Point(ray, t);\n\n            vec3 n = normalize(vec3(p.x - cyl.a.x, p.y - cyl.a.y, 0.0));\n            x = Hit(t, n, cyl.i);\n            return true;\n        }\n    }\n\n    float t_disc = (cyl.a.z - ray.o.z) / ray.d.z;\n    vec3 p_disc = Point(ray, t_disc);\n    if (t_disc > 0.0 && length(p_disc.xy - cyl.a.xy) <= cyl.r) {\n        x = Hit(t_disc, vec3(0.0, 0.0, 1.0), cyl.i);\n        return true;\n    }\n\n    t_disc = (cyl.b.z - ray.o.z) / ray.d.z;\n    p_disc = Point(ray, t_disc);\n    if (t_disc > 0.0 && length(p_disc.xy - cyl.a.xy) <= cyl.r) {\n        x = Hit(t_disc, vec3(0.0, 0.0, -1.0), cyl.i);\n        return true;\n    }\n\n    return false;\n}\n\n\n// Intersection avec un cube\nbool IntersectCube(Ray ray, Cube cube, out Hit x) {\n    // Définition des faces du cube\n    vec3 cubeMin = cube.center - 0.5 * cube.size;\n    vec3 cubeMax = cube.center + 0.5 * cube.size;\n\n    // Calcul de l'intersection avec les plans du cube\n    vec3 tMin = (cubeMin - ray.o) / ray.d;\n    vec3 tMax = (cubeMax - ray.o) / ray.d;\n\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n\n    // Intersection avec le cube\n    if (tNear <= tFar && tFar > 0.0) {\n        // Point d'intersection\n        vec3 intersectionPoint = ray.o + tNear * ray.d;\n        \n        // Calcul de la normale de la face intersectée\n        vec3 normal = vec3(0.0);\n\n        if (abs(intersectionPoint.x - cubeMin.x) < 1e-5) {\n            normal = vec3(-1.0, 0.0, 0.0);\n        } else if (abs(intersectionPoint.x - cubeMax.x) < 1e-5) {\n            normal = vec3(1.0, 0.0, 0.0);\n        } else if (abs(intersectionPoint.y - cubeMin.y) < 1e-5) {\n            normal = vec3(0.0, -1.0, 0.0);\n        } else if (abs(intersectionPoint.y - cubeMax.y) < 1e-5) {\n            normal = vec3(0.0, 1.0, 0.0);\n        } else if (abs(intersectionPoint.z - cubeMin.z) < 1e-5) {\n            normal = vec3(0.0, 0.0, -1.0);\n        } else if (abs(intersectionPoint.z - cubeMax.z) < 1e-5) {\n            normal = vec3(0.0, 0.0, 1.0);\n        }\n\n        x = Hit(tNear, normal, cube.textureId);\n        return true;\n    }\n\n    return false;\n}\n\n// Intersection avec une capsule\nbool IntersectCapsule(Ray ray, Capsule cap, out Hit x) {\n    Sphere spha = Sphere(cap.a, cap.r, cap.i);\n    Sphere sphb = Sphere(cap.b, cap.r, cap.i);\n  \n    Hit hitSph1, hitSph2;\n    bool intersectSph1 = IntersectSphere(ray, spha, hitSph1);\n    bool intersectSph2 = IntersectSphere(ray, sphb, hitSph2);\n\n    Cylinder cyl = Cylinder(cap.a, cap.b, cap.r, cap.i);\n    Hit hitCyl;\n    bool intersectCyl = IntersectCylinder(ray, cyl, hitCyl);\n\n    bool hit = false;\n    x = Hit(1000.0, vec3(0), -1);\n\n    if (intersectSph1 && hitSph1.t < x.t) {\n        x = hitSph1;\n        hit = true;\n    }\n    \n    if (intersectSph2 && hitSph2.t < x.t) {\n        x = hitSph2;\n        hit = true;\n    }\n\n    if (intersectCyl && hitCyl.t < x.t) {\n        x = hitCyl;\n        hit = true;\n    }\n\n    return hit;\n}\nbool IntersectTorus(Ray ray, Torus torus, out Hit hit) {\n    hit.t = -1.0;  \n    vec3 ro = ray.o - torus.center;\n    vec3 rd = ray.d;\n    float Ra2 = torus.majorRadius * torus.majorRadius;\n    float ra2 = torus.minorRadius * torus.minorRadius;\n    float m = dot(ro, ro);\n    float n = dot(ro, rd);\n    float k = (m - ra2 - Ra2) / 2.0;\n    float k3 = n;\n    float k2 = n * n + Ra2 * rd.z * rd.z + k;\n    float k1 = k * n + Ra2 * ro.z * rd.z;\n    float k0 = k * k + Ra2 * ro.z * ro.z - Ra2 * ra2;\n    float c2 = 2.0 * k2 - 3.0 * k3 * k3;\n    float c1 = k3 * (k3 * k3 - k2) + k1;\n    float c0 = k3 * (k3 * (-3.0 * k3 * k3 + 4.0 * k2) - 8.0 * k1) + 4.0 * k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2 * c2 + c0;\n    float R = 3.0 * c0 * c2 - c2 * c2 * c2 - c1 * c1;\n    float h = R * R - Q * Q * Q;\n    float z = 0.0;\n    if(h < 0.0) {\n        float sQ = sqrt(Q);\n        z = 2.0 * sQ * cos(acos(R / (sQ * Q)) / 3.0);\n    } else {\n        float sQ = pow(sqrt(h) + abs(R), 1.0 / 3.0);\n        z = sign(R) * abs(sQ + Q / sQ);\n    }\n\n    z = c2 - z;\n\n    float d1 = z - 3.0 * c2;\n    float d2 = z * z - 3.0 * c0;\n\n    if(abs(d1) < 1.0e-4) {\n        if(d2 < 0.0) {\n            return false; \n        }\n        d2 = sqrt(d2);\n    } else {\n        if(d1 < 0.0) {\n            return false;  \n        }\n        d1 = sqrt(d1 / 2.0);\n        d2 = c1 / d1;\n    }\n\n    float result = 10.;\n\n    h = d1 * d1 - z + d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = -d1 - h - k3;\n        float t2 = -d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = t1;\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n\n    h = d1 * d1 - z - d2;\n\n    if(h > 0.0) {\n        h = sqrt(h);\n        float t1 = d1 - h - k3;\n        float t2 = d1 + h - k3;\n\n        if(t1 > 0.0) {\n            result = min(result, t1);\n        }\n        if(t2 > 0.0) {\n            result = min(result, t2);\n        }\n    }\n    \nif (result < 100.0 && result > 0.0) {  \n    vec3 q = ray.o + ray.d * hit.t;\n    vec3 normal = normalize(vec3(\n        2.0 * (q.x - torus.center.x),\n        2.0 * (q.y - torus.center.y),\n        2.0 * (q.z - torus.center.z)\n    ));\n    hit.n = normal;\n    hit.i = torus.i;  \n    return true; \n}\n\n    \n    return false;  \n}\n\nbool IntersectPlane(Ray ray, Plane pl, out Hit x) {\n    float t = -dot(ray.o - pl.p, pl.n) / dot(ray.d, pl.n);\n    if (t > 0.0) {\n        x = Hit(t, vec3(0, 0, 1), 0);\n        return true;\n    }\n    return false;\n}\n\nbool Intersect(Ray ray, out Hit x) {\n     x = Hit(1000.0, vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n    const Sphere sph1 = Sphere(vec3(1.0, 1.0, 1.5), 1.0, 2);\n    const Sphere sph2 = Sphere(vec3(3.0, 3.0, 1.5), 1.0, 15);\n    const Sphere sph3 = Sphere(vec3(5.0, 5.0, 1.5), 1.0, 9); \n    const Ellipsoid ellipsoid1 = Ellipsoid(vec3(10., 10., 1.5), vec3(1.0, 2.0, 1.4), 14);\n    const Ellipsoid ellipsoid3 = Ellipsoid(vec3(7.0, 7.0, 1.5), vec3(3.0, 1.0, 1.4), 11);\n    const Cylinder cyl1 = Cylinder(vec3(-2, -2, 0.5), vec3(-2, -2, 6.5), 1.0, 13);\n    const Cube myCube = Cube(vec3(-6.0, -6.0, 1.5), 2.0, 3);\n    const Capsule cap1 = Capsule(vec3(-4.0, -4.0, 1.5), vec3(-4., -4., 5.), 0.5, 10);\n    const Torus torus1 = Torus(vec3(-9.0, -9.0, 1.48), 2.0, 0.5, 5);\n    \n    const Plane pl = Plane(vec3(0.0, 0.0, 1.5), vec3(0.0, 0.0, 0.0), 0);\n    \n    if (IntersectSphere(ray, sph1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectSphere(ray, sph2, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    Hit currentEllipsoid;\n    if (IntersectEllipsoid(ray, ellipsoid1, currentEllipsoid) && currentEllipsoid.t < x.t) {\n        x = currentEllipsoid;\n        ret = true;\n    }\n     Hit currentEllipsoid2;\n    if (IntersectEllipsoid(ray, ellipsoid3, currentEllipsoid2) && currentEllipsoid2.t < x.t) {\n        x = currentEllipsoid2;\n        ret = true;\n    }\n    \n    if (IntersectCylinder(ray, cyl1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectCube(ray, myCube, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    if (IntersectCapsule(ray, cap1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n   \n    if (IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n    \n    Hit currentSph3;\n    if (IntersectSphere(ray, sph3, currentSph3) && currentSph3.t < x.t) {\n    x = currentSph3;\n    ret = true;\n}\n    Hit currentTorus;\n    if (IntersectTorus(ray, torus1, currentTorus) && currentTorus.t < x.t) {\n    x = currentTorus;\n    ret = true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd) {\n    return mix(vec3(0.8, 0.8, 0.9), vec3(0.7, 0.7, 0.8), rd.z);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvec3 Color(Material m, vec3 n, vec3 p) {\n       vec3 light = normalize(vec3(4, 1, 3));\n\n    Hit osef;\n    if (!Intersect(Ray(p + n * 0.01, light), osef)) {\n        float diff = clamp(dot(n, light), 0., 1.);\n        vec3 col = m.d * diff + vec3(.2,.2,.2);\n        return col;\n    } else {\n       return vec3(.2);\n    }\n    \n}\n\n\n//texture concentrique en fonction de la distance par rapport au centre\nvec3 ConcentricTexture(vec3 p) {\n    float distanceToCenter = length(p);\n    float t = mod(distanceToCenter, 2.0) / 2.0; \n\n    vec3 color1 = vec3(0.5, 0.0, 0.2); \n    vec3 color2 = vec3(0.4, 0.0, 0.6); \n    vec3 color3 = vec3(0.8, 0.2, 0.5); \n\n    vec3 concentricColor;\n\n    if (t < 1.0 / 3.0) {\n        concentricColor = mix(color1, color2, t * 3.0);\n    } else if (t < 2.0 / 3.0) {\n        concentricColor = mix(color2, color3, (t - 1.0 / 3.0) * 3.0);\n    } else {\n        concentricColor = mix(color3, color1, (t - 2.0 / 3.0) * 3.0);\n    }\n\n    return concentricColor;\n}\n\n\n/****************** EXTRA : Marbre **************************/\n// Fonction de bruit de Perlin\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\nfloat turbulence(vec3 p, int octaves) {\n    float value = 0.0;\n    float scale = 1.0;\n    \n    for (int i = 0; i < octaves; i++) {\n        value += Noise(p) * scale; \n        p *= 2.0; \n        scale *= 0.5; \n    }\n    \n    return abs(value);\n}\n\n\nvec3 MarbleTexture(vec3 p) { p=p*4.8;\n    float turbulenceValue = turbulence(p, 5); \n    float marbleValue = 0.5 + 0.5 * sin(p.z + turbulenceValue);\n    \n    vec3 color1 = vec3(0.8, 0.8, 0.8); \n    vec3 color2 = vec3(0.2, 0.2, 0.2);\n\n    return mix(color1, color2, marbleValue);\n}\n\nvec3 WoodTexture(vec3 p) {\n    float woodValue = Noise(p * 4.0);\n    vec3 woodColor = mix(vec3(0.5, 0.25, 0.05), vec3(0.35, 0.15, 0.03), woodValue);\n    return woodColor;\n}\n\n\n//Occlusion ambiante \nvec3 Hemisphere(int seed, vec3 n)\n{\n    float a = fract(sin(176.19 * float(seed))); \n    float b = fract(sin(164.19 * float(seed)));\n    float u = 2.0 * 3.1415 * a; \n    float v = acos(2.0 * b - 1.0); \n    vec3 d = vec3(cos(u) * cos(v), sin(u) * cos(v), sin(v)); \n\n    if (dot(d, n) < 0.0) {\n        d = -d; \n    }\n\n    return d;\n}\n\n\nfloat AmbientOcclusion(vec3 p, vec3 n, int N)\n{\n    if (N == 0) {\n        return 1.0;\n    }\n\n    float ao = 0.0;\n\n    for (int i = 0; i < N; i++)\n    {\n        vec3 d = Hemisphere(i, n); \n\n        Ray aoRay;\n        aoRay.o = p + normalize(n)*0.01; \n        aoRay.d = d;\n\n        Hit hit;\n        if (Intersect(aoRay, hit)) {\n            ao += 1.0;\n        }\n    }\n\n    ao /= float(N)*0.5;\n    return ao;\n}\n\n\n\nvec3 Shade(Ray ray) {\n    Hit x;\n    bool idx = Intersect(ray, x);\n    vec3 finalColor;\n    if (idx) {\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n\n        if (x.i == 2) {\n        vec3 checkerColor = CheckerTextureFunction(p, CheckerTexture(vec3(0.2), vec3(0.8), 0.5)).color1;\n            finalColor =  checkerColor;\n        } else if (x.i == 3) {\n            vec3 marbleColor = MarbleTexture(p);\n            finalColor = marbleColor;\n        } else if (x.i == 4) {\n            //red\n            finalColor = vec3(1.0, 0.0, 1.0);\n        } else if (x.i == 5) {\n            // vert foncé\n            finalColor = vec3(0.6, 0.0, 0.8);\n        } else if (x.i == 6) {\n            //bordeaux\n            finalColor = vec3(0.5, 0.0, 0.2);\n        } else if (x.i == 7) {\n            //vert\n            finalColor =  vec3(0.0, 0.5, 0.0);\n        } else if (x.i == 8) {\n            finalColor = vec3(0.53, 0.81, 0.98);\n        } else if (x.i == 9) {\n            vec3 concentricColor = ConcentricTexture(p);\n            finalColor = concentricColor;\n        } else if (x.i == 10) { // Texture uniforme\n            vec3 uniformRed = UniformTextureFunction(p, UniformTexture(vec3(1.0, 0.0, 0.0))).color;  // Couleur rouge uniforme\n            finalColor = uniformRed;\n        } else if (x.i == 11) {\n            // Calculate Phong shading\n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); \n            vec3 viewDir = -ray.d;\n            Material mat1 = Texture(p, 5);\n            vec3 phongColor = PhongShading(mat1, x.n, lightDir, viewDir);\n            finalColor = phongColor;\n        } else if (x.i == 12) {\n            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n            vec3 viewDir = -ray.d;\n            Material mat1 = Texture(p, 4);\n            vec3 phongColor = PhongShading(mat1, x.n, lightDir, viewDir);\n            finalColor = phongColor;\n        \n        } else if (x.i == 13) { // Texture de bois\n            vec3 woodColor = WoodTexture(p);\n            finalColor = woodColor;\n        } else if (x.i == 15) {\n            vec3 checkerColor = PhongCheckerTextureFunction(p, CheckerTexture(vec3(0.2), vec3(0.8), 0.5),ray);\n            finalColor = checkerColor;}\n        \n        else if (x.i == 14) {\n                // Mirror Material\n                Material mat = Material(vec3(0.1, 0.1, 0.1),vec3(0.2, 0.2, 0.2), vec3(0.8, 0.8, 0.8),64.0, 0.); \n                vec3 reflectionDir = reflect(ray.d, x.n);\n                vec3 reflectionColor = vec3(0., 0, 0.);\n                const int numReflections = 1; //pour 1 niveau de reflexion\n                for (int i = 0; i < numReflections; i++) {\n                    Ray reflectionRay = Ray(p + x.n * 0.001, reflectionDir);\n                    Hit reflectionHit;\n                    if (Intersect(reflectionRay, reflectionHit)) {\n                        reflectionColor += Color(Texture(Point(reflectionRay, reflectionHit.t), reflectionHit.i), reflectionHit.n, Point(reflectionRay, reflectionHit.t));\n\n                        reflectionDir = reflect(reflectionRay.d, reflectionHit.n);\n                        p = Point(reflectionRay, reflectionHit.t);\n                    } else {\n                        break;\n                        }\n                }\n                if (reflectionColor == vec3(0.0))reflectionColor=Background(ray.d);\n                finalColor = mix(reflectionColor, Color(mat, x.n, p), mat.reflection);\n            } else {\n            float ao = AmbientOcclusion(p, x.n,56);\n            finalColor =  Color(mat, x.n, p)*(1.0 - ao) ;\n        }\n        return finalColor;\n    } else {\n        return Background(ray.d);\n    }\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (-iResolution.xy + 2.2 * fragCoord.xy) / iResolution.y;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 ro = 21.0 * normalize(vec3(sin(2.0 * 3.14159265359 * mouse.x), cos(2.0 * 3.14159265359 * mouse.x), 1.4 * (mouse.y - 0.1)));\n    vec3 ta = vec3(0.0, 0.5, 0.5);\n    mat3 ca = setCamera(ro, ta);\n    \n    vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.5)), 1.0));\n    \n \n    vec3 col = Shade(Ray(ro, rd));\n    \n    fragColor = vec4(col, 1.0);\n    \n}\n","name":"Image","description":"","type":"image"}]}