{"ver":"0.1","info":{"id":"wsfcRN","date":"1584264909","viewed":292,"name":"pixar 2010 ssao","username":"Daedelus","description":"I tried to implement SSAO from Toy Story 3. It works surprisingly well.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["ao","ambientocclusion","screenspace","ssao","screenspaceambientocclusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttp://advances.realtimerendering.com/s2010/Ownby,Hall%20and%20Hall%20-%20Toystory3%20(SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course).pdf\n\nThe main implementation is in Buf B.\n\nA renders a depth-normals pass (raymarched)\n\nB does AO (with fading of previous frames to improve look for static images)\n(we should actually do an edge-preserving-blur of buf B \nbut I didn't get there yet so jittering the AO samples over \ntime and blending is a good preview).\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0);\n    fragColor = pow(fragColor, vec4(1.0 / 2.2));\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float yFov = radians(30.0); // field of view\nconst float farClip = 100.0;\n\n#define sat(x) clamp(x, 0.0, 1.0)\n\nvoid pR(inout vec2 p, float a){p = cos(a)*p+sin(a)*vec2(p.y,-p.x);}\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n    \nmat4 _cameraMatrix(float time)\n{\n    // world space camera transform animation\n    float tx = sin(time) * 2.0;\n    float ry = sin(time) * 0.125;\n    mat4 uC = mat4(cos(ry), 0.0, -sin(ry), 0.0,\n                  0.0, 1.0, 0.0, 0.0,\n                  sin(ry), 0.0, cos(ry), 0.0,\n                  tx, 0.0, 0.0, 1.0);\n    return uC;\n}\n    \nmat4 _projectionMatrix(vec2 resolution, float time)\n{\n    // perspective Y matrix\n    // I'm actually not sure if this should be transposed to match glFrustum or not\n    const float nearClip = 0.1;\n    float height = 2.0 * tan(yFov * 0.5);\n    float C = (farClip + nearClip) / (farClip - nearClip);\n    float D = (2.0 * farClip * nearClip) / (farClip - nearClip);\n    float aspect = resolution.x / float(resolution.y);\n    mat4 uP = mat4(2.0 / (height * aspect), 0.0, 0.0, 0.0,\n    \t0.0, 2.0 / height, 0.0, 0.0,\n    \t0.0, 0.0, -C, -1.0,\n    \t0.0, 0.0, -D, 0.0);\n    return uP;\n}\n\nmat4 viewProjectionMatrix(vec2 resolution, float time)\n{\n    return _projectionMatrix(resolution, time) * inverse(_cameraMatrix(time));\n}\n\nRay screenRay(vec2 resolution, float time)\n{\n    float top = tan(yFov * 0.5);\n    vec2 frustum = vec2(top * (resolution.x / resolution.y), top);\n    vec3 rd = normalize(vec3(mix(-frustum, frustum, gl_FragCoord.xy / resolution), -1.0)); // openGL looks down the negative Z axis\n    mat4 uC = _cameraMatrix(time);\n    rd = mat3(uC) * rd;\n    vec3 ro = _cameraMatrix(time)[3].xyz;\n    return Ray(ro, rd);\n}\n\nfloat fBox(vec2 p, vec2 s)\n{\n    p = abs(p) - s;\n    return max(p.x, p.y);\n}\n\nfloat fBox(vec3 p, vec3 s)\n{\n    p = abs(p) - s;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat pMod(inout float p, float d)\n{\n    float c = p / d + 0.5;\n    p = (fract(c) - 0.5) * d;\n    return floor(c);\n}\n\nfloat fField(vec3 p)\n{\n    vec3 op = p;\n    float r = 2.0 - abs(p.y);\n    \n    p.x = abs(p.x) - 3.0;\n    float c = pMod(p.z, 10.0);\n    pR(p.xz, c / 3.14);\n    p.y -= sin(c * 23.0);\n    float ir = fBox(p, vec3(1.0, 2.0, 1.0));\n    p = op;\n    \n    float tmp = fBox(vec2(r, ir), vec2(0.1, 0.2));\n    tmp = min(tmp, fBox(vec2(r, ir), vec2(0.3, 0.1)));\n    \n    return min(tmp, min(r, ir));\n}\n\nfloat trace(Ray ray)\n{\n    // trace a scene\n    float totalDistance = 0.1;\n    vec3 intersection;\n    for(int i = 0; i < 400; ++i)\n    {\n        intersection = ray.o + ray.d * totalDistance;\n        float sampl = fField(intersection);\n        if(sampl < 1e-5)\n            break;\n        totalDistance += sampl;\n        if(totalDistance > farClip)\n            break;\n    }\n    return totalDistance;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(1e-5,0);\n    return normalize(vec3(\n        fField(p + e.xyy)-fField(p - e.xyy),\n    \tfField(p + e.yxy)-fField(p - e.yxy),\n    \tfField(p + e.yyx)-fField(p - e.yyx)));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    Ray ray = screenRay(iResolution.xy, iTime);\n    float t = trace(ray);\n    fragColor.xyz = normal(ray.o + ray.d * t) * 0.5 + 0.5;\n    fragColor.w = t;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nI attmpted to implement the technique from this presentaiton:\nhttp://advances.realtimerendering.com/s2010/Ownby,Hall%20and%20Hall%20-%20Toystory3%20(SIGGRAPH%202010%20Advanced%20RealTime%20Rendering%20Course).pdf\n*/\n\n\n// The original paper advises looping over a set of radii, so that' what I did. But not too many as\n// it seems to provide better quality at large radii but we don't often need that.\nconst int numAORadii = 3;\n// in units\nconst float aoRadii[numAORadii] = float[numAORadii](0.1, 0.25, 0.6); \n// relative to the sampling sphere, so 1 is every sample slightly outside the sample sphere is ignored (way too greedy), 2 is allow twice the radius, etc.\nconst float depthAttenuation = 3.0; \n\nconst float previousFrameStrength = 0.0; // temporal reprojection, not necessarily AO related\n\nconst int sampleCount = 6;\nconst int halfSampleCount = sampleCount / 2;\n\n// these are our carefully copied sample points\n// they are made up of pairs where [i] == -[n/2+i]\n// we also always take a sample at 0, 0\nconst vec2 sampleUVs[7] = vec2[7](\n    vec2(118.0, 118.0) / 118.0 - 1.0, // == vec2(0.0, 0.0)\n\tvec2(118.0, 60.0) / 118.0 - 1.0,\n    vec2(93.0, 103.0) / 118.0 - 1.0,\n    vec2(40.0, 163.0) / 118.0 - 1.0,\n    vec2(118.0, 177.0) / 118.0 - 1.0,\n    vec2(144.0, 133.0) / 118.0 - 1.0,\n    vec2(195.0, 73.0) / 118.0 - 1.0\n);\n\n// the volume associated with each point\nconst float sampleVolumes[7] = float[7](\n\t0.134642365128,\n\t0.356312922271,\n\t0.313701337059,\n\t0.262368821398,\n\t0.354222040364,\n\t0.316412058113,\n\t0.262343849996);\n\n// and the thickness at each point\n// return 2.0 * sqrt(max(0.0, 1.0 - dot(uv, uv)));\nconst float sampleDepths[7] = float[7](\n    1.0,\n    0.870863225672,\n    0.968996554932,\n    0.646238536383,\n    0.866025403784,\n    0.967104742455,\n    0.654794704138);\n\n// cache some rotation matrices to cycle for each pixel to offset the sample uvs with\nconst vec2 rotationInfo[16] = vec2[16](\n\tvec2(0.0258680602083, 0.99966536574),\n\tvec2(0.212035979099, 0.977261860285),\n\tvec2(0.426436590527, 0.904517459345),\n\tvec2(0.543092406498, 0.839672935139),\n\tvec2(0.706427385962, 0.707785524268),\n\tvec2(0.805829172803, 0.592148076295),\n\tvec2(0.938961400683, 0.34402251093),\n\tvec2(0.985381245922, 0.170363729079),\n\tvec2(0.999136734909, 0.0415425679986),\n\tvec2(0.977369945045, -0.211537208366),\n\tvec2(0.935130665042, -0.354303033149),\n\tvec2(0.853693312085, -0.520776083265),\n\tvec2(0.701671138004, -0.712500957257),\n\tvec2(0.52739141996, -0.849622439765),\n\tvec2(0.355102067877, -0.934827535639),\n\tvec2(0.163369403358, -0.986564968994)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // the first sample positions our sphere\n    vec4 color_depth = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0);\n    float depth = color_depth.w;\n    // it is by default 50% occluded\n    float occlusion = sampleVolumes[0] * 0.5;\n    \n    for(int j = 0; j < numAORadii; ++j)\n    {\n        // get pixel rotator\n    \tivec2 tx = ivec2(gl_FragCoord.xy);\n        tx.x += iFrame + j; // cycle over time\n        tx &= 3; // mask to get index\n        vec2 sincos = rotationInfo[(tx.x << 2) + tx.y];\n        mat2 rotator = mat2(sincos.y, sincos.x, -sincos.x, sincos.y);\n\n        // given the depth and frustum we can reverse engineer the radius of this sphere in pixels\n        float aoRadius = aoRadii[j];\n        float aoRadiusInPixels = ((iResolution.y * 0.5) / (tan(yFov * 0.5) * color_depth.w)) * aoRadius;\n        float fixUp[sampleCount+1];\n        for(int i = 1; i < sampleCount + 1; ++i)\n        {\n            vec2 sampleUV = (gl_FragCoord.xy + aoRadiusInPixels * (rotator * sampleUVs[i])) / iResolution.xy;\n            float sampleDepth = texture(iChannel0, sampleUV).w;\n\n            // relative to sample sphere\n            float delta = sampleDepth - depth;\n            // unitize, [-1, 1] sample position\n            delta /= aoRadius;\n\n            // distance attenuation\n            if(abs(delta) > depthAttenuation)\n            {\n                if(i<halfSampleCount+1) // early fixUp samples are skipped and later their paired value is negated and used.\n                    fixUp[i] = -1.0;\n                else if(fixUp[i - halfSampleCount] != -1.0) // late fixUp samples are fixed immediately by negating their paired sample, if available\n                    occlusion += sampleVolumes[i] * (1.0 - fixUp[i - halfSampleCount]);\n                continue;\n            }\n            // project on sample line to get a clamped [0, 1] occlusion amount\n            float t = sat(0.5 - delta * sampleDepths[i]);\n            // factor in the volume and occlude\n            occlusion += sampleVolumes[i] * t;\n\n            // early sample, not requiring fixup\n            if(i<halfSampleCount+1) \n                fixUp[i] = t;\n            else\n            {\n                if(fixUp[i-halfSampleCount]==-1.0) // late sample, earlier sample required fixeup\n                {\n                    occlusion += sampleVolumes[i-halfSampleCount] * (1.0 - t);\n                    fixUp[i-halfSampleCount] = 0.0;\n                }\n            }\n        }\n\n        // any sample still requiring fixing means the entire pair required fixing, default to 0.5\n        for(int i=0;i<halfSampleCount;++i)\n        if(fixUp[i+1] == -1.0)\n            occlusion += (sampleVolumes[i+1] + sampleVolumes[i+1+halfSampleCount]) * 0.5;\n    }\n    occlusion /= float(numAORadii);\n    \n    // shade and apply occlusion\n    float fog = sat(depth / farClip);\n    fragColor.xyz = mix(color_depth.xyz * min(1.0, 2.0 - occlusion), vec3(0.0), pow(fog, 4.0));\n    fragColor.w = color_depth.w;\n    \n    // this is where the AO logic ends, this reprojection logic should be done at a higher quality in a TAA pass, and even then the blur pass is kind of needed\n    // fade with previous frame, ghosts like crazy in motion though, which in turn can be fixed with temporal reprojection so it may be a pretty good solution\n    #if 1\n    vec4 ts = texelFetch(iChannel1, ivec2(gl_FragCoord.xy), 0);\n    #else\n    // temporal reprojection\n    // current world position\n    Ray ray = screenRay(iResolution.xy, iTime);\n    vec3 worldPos = ray.o + ray.d * color_depth.w;\n    // project to screen space of previous frame\n    vec4 proj = viewProjectionMatrix(iResolution.xy, iTime - iTimeDelta) * vec4(worldPos, 1.0);\n    proj.xy /= proj.w;\n    // proj.x *= (iResolution.x / iResolution.y);\n    proj.xy = proj.xy * 0.5 + 0.5;\n    vec4 ts = texture(iChannel1, proj.xy);\n    if(abs(ts.w - color_depth.w) > 0.5)\n        ts = fragColor; // avoid ghosting at big depth differences\n    #endif\n    fragColor = mix(fragColor, ts, previousFrameStrength);\n    \n}\n","name":"Buffer B","description":"","type":"buffer"}]}