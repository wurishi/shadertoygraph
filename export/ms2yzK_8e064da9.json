{"ver":"0.1","info":{"id":"ms2yzK","date":"1687936131","viewed":184,"name":"Rotating stars in galaxy","username":"nayk","description":"procedural, noise, stars, universe, galaxy","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","noise","galaxy","stars","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*remake Art Of Code: Starfield! (SS7)  https://www.shadertoy.com/view/wtcXWX\n*/\n\nconst float PI = 3.14;\n\nmat2 rotationMatrix(float angle)\n{\n\tangle *= PI / 180.0;\n    float s=sin(angle), c=cos(angle);\n    return mat2( c, s, -s, c );\n}\n\nvec4 texLookup(vec2 coord)\n{    \n    float t = iTime * 0.2;\n    vec2 uv = (vec2(t, 0.5) + coord) * 0.5; // + vec2(uv.x * sin(t) + uv.y * cos(t), uv.x * cos(t) - uv.y * sin(t));\n    \n    //uv = floor(uv);\n    \n    return texture(iChannel0, uv); vec4(fract((uv.x - uv.y) / 2.));\n}\n\nvoid vertPlaneIntersect(inout vec3 o, inout vec3 d, in float r, in float alpha)\n{\n    float s_a = sin(alpha);\n    float c_a = cos(alpha);\n    \n    float t = (r - o.x*s_a - o.y*c_a)/(d.x*s_a + d.y*c_a);\n    \n    vec3 nrm = vec3(s_a, c_a, 0.);\n    \n    o = (t > 0.01 && t*d.z + o.z < 5.) ? t*d + o : d * 1e4;\n\n    d = (o.z < 5.) ? d - 2. * nrm * dot(d, nrm) : d;\n}\n\nvoid multiIntersect(inout vec3 o, inout vec3 d, inout vec4 col, in int n)\n{\n    vec3 o_new = d * 1e4;\n    vec3 d_new = d;\n    vec4 c_new = col;\n    \n    for (int i = 0; i<n; i++)\n    {\n        vec3 o_tmp = o;\n        vec3 d_tmp = d;\n        vertPlaneIntersect(o_tmp, d_tmp, 1., 3.14159265359 * 2. / float(n) * float(i) + iTime * 0.05);\n        \n        d_new = o_tmp.z < o_new.z ? d_tmp : d_new;\n        c_new = o_tmp.z < o_new.z ? vec4(0.8, 0.85, 0.9, 1.) * col : c_new;\n        o_new = o_tmp.z < o_new.z ? o_tmp : o_new;\n    }\n    \n    o = o_new;\n    d = d_new;\n    col = c_new;\n}\n\n\nvec4 bounceRay(inout vec3 o, inout vec3 d)\n{\n    vec4 col = vec4(1.);\n    \n    for (int i = 0; i < 8; i++)\n    {\n        multiIntersect(o, d, col, 5);\n    }\n    \n    return col * texLookup(o.xy / o.z);\n}\n\nfloat rand(vec2 c){\n\treturn fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nvec2 rand2(vec2 c){\n\treturn vec2(rand(c.xy), rand(c.yx));\n}\n\n    \nfloat\nmakeStar(vec2 uv, float flare)\n{\n    float d = length(uv);\n    float star = 1.16/d;\n    float m = star;\n\n\n    float rays = max(1.0 - abs(uv.x*uv.y * 100.0), 0.0);\n    m *=rays * flare;\n\n \n        rays = max(1.0 - abs(uv.x*uv.y * 100.0), 0.0);\n        m +=rays*flare *0.3;\n\n    m *= smoothstep(0.1, 0.1, d);\n\n    return m;\n}\n\nfloat\nsport21(vec2 p)\n{\n    p = fract(p*vec2(13.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x*p.y);\n}\n\nvec2 \nrandom2D(vec2 val){\n    val = vec2(dot(val, vec2(17.1, 311.7)),\n               dot(val, vec2(22.51, 184.2)));\n    \n    float scale = 184.0;\n    return 1.0 -  2.0 * fract(sin(val) * scale);\n}\n\nfloat \nnoise(vec2 p){\n    const float K1 = 1.366025404; \n    const float K2 = 0.211324865; \n\n    vec2 i = floor( p + (p.x + p.y) * K1);\n\n    vec2 a = p - i + (i.x + i.y)*K2;\n    vec2 o = step(a.yx, a.xy);\n    vec2 b = a - o + K2;\n    vec2 c = a - 0.0 + 2.0*K2;\n\n    vec3 h = max( 0.5 - vec3(dot(a,a), dot(b,b), dot(c,c)), 0.0);\n\n    vec3 n = h*h*h*h*vec3(dot(a, random2D(i)), dot(b, random2D(i + o)), dot(c, random2D(i+1.0)));\n\n    return dot(n, vec3(100.0));\n}\nfloat \nsimplex(vec2 p, int octaves){\n    mat2 m = mat2(0.2, 0.1, -1.2, 1.6);\n\n    float f = 0.0;\n    float scale = 1.0;\n    for(int i = 0; i < octaves; i++){\n        scale /= 5.0;\n        f += scale*noise(p);\n        p *= m;\n    }\n\n    return 0.5 + 0.5*f;\n}\n\nvec3\nStarLayer(vec2 uv)\n{\n    vec3 col = vec3(0.0);\n    vec2 id = floor(uv);\n    vec2 gv = fract(uv) - 0.5;\n\n    for(int y = -1; y <= 1; ++y)\n    for(int x = -1; x <= 1; ++x)\n    {\n        vec2 offset = vec2(x, y);\n        float n = sport21(id + offset);\n        float size = fract(n*n*1425.45);\n\n        float star = makeStar(gv - offset - vec2(n, fract(n*34.0) ) + 1.1, smoothstep(.1, 0.5, size)* 5.6);\n        vec3 color = atan(vec3(0.2, 0.3, 0.2)*fract(n*2345.2) * 1.2)*.5 + 0.5;\n        color = color * vec3(0.5, 0.5, 0.5 + size);\n        star *= sin(iTime*3.0 + n)*0.5 +1.;\n        col += star*size*color;\n    }\n\n    return col;\n}\n\nvec3\ngas_halo_outer(vec2 uv, float size, int density)\n{\n    float halo_mask = 0.0;\n    vec3 col = vec3(0.0);\n    vec3 color =  vec3(1.5, 1.3, 0.8);\n    for(int i = 0; i < density; ++i){\n        float offset = sport21(vec2(i));\n        float r = size + (size / 2.0f) * cos(atan(uv.y + offset * 1.2f, uv.x)* (3.0 ) + radians(offset * 360.0f));\n        halo_mask = smoothstep(r, r + 2.35f, length(uv));\n        col += color * (0.0 - halo_mask - simplex(uv, 1)) *  1.0f / float(density);\n    }\n    return clamp(col, 0.02, 1.0);\n}\nmat2 rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n#define RANGE 0.2\n#define ANGLE 0.5\n#define SPEED 3.\n\nvec2 twirl(vec2 uv,vec2 center,float range,float angle)\n{\n    float d = distance(uv,center);\n    uv -= center;\n    //d = clamp(-angle/range*d+angle,0.,angle); // cause flashing\n    d = smoothstep(0.,range,range-d) * angle;\n    uv *= rotate(d);\n    uv += center;\n    return uv;\n}\n\n\n\n#define NUM_LAYERS 1.0\nvoid\nmainImage(out vec4 fragColor, in vec2 fragPosition)\n{\n    vec2 uv  = ((fragPosition) - 0.5*iResolution.xy)/iResolution.y;\n uv *= rotationMatrix( 10.0 * -iTime );\n vec2 trs = vec2(cos(iTime*0.1),sin(iTime*0.3));\n uv+=trs;\n     vec4 col = vec4(0.);\n   \n    float t = iTime*.04;\n    uv+= 2. * (fragPosition-iResolution.xy*0.5)/iResolution.yy;\n    \n     \n    \n    for (int i = 0; i < 16; i++)\n    {\n        vec3 o = vec3(rand2(vec2(float(i) + iTime + uv.x,float(16-i)+uv.y))-vec2(0.5,0.5), 0.)*0.3;\n        vec3 d = vec3(uv, 1.5);\n        vec4 c_tmp = bounceRay(o, d);\n        col += c_tmp*c_tmp;\n    }\n     uv+=fragPosition/iResolution.y;\n    vec2 mouse = iMouse.xy/iResolution.y;\n    float time = sin(iTime*SPEED);\n    \n    if(iMouse.xy == vec2(0))\n    {\n        mouse = vec2(0.5);\n        mouse.x *= iResolution.x/iResolution.y;\n    }\n    uv = twirl(uv,mouse,RANGE,ANGLE*time);\n\n    vec4 color = texture(iChannel0,uv);\n    //multiIntersect(o, d, col, 5);\n    \n    fragColor = sqrt(col/8.);// vec4(d.xy, 0., 1.);\n    for(float i = 0.0;i < 1.0; i += 1.0/NUM_LAYERS)\n    {\n        float depth = fract(i +t);\n\n        float scale = mix(50., 5.5, depth);\n\n        float fade = fract(depth*smoothstep(1., .9, depth));\n\n        float size = 1.6;\n\n        col+= vec4(StarLayer(uv*scale + i*153.2)*fade,0.);\n        scale = mix(10.0, 0.5, fract(i + 1.0*t));\n        \n    }\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"}]}