{"ver":"0.1","info":{"id":"DsByD1","date":"1687632233","viewed":112,"name":"less_basic_raymarcher","username":"MadMath123","description":"so um... now it can handle reflections so yeah\nalso i made the direction vectors a bit wOnKy so now there is more fnnuy noise\nalso now the light will like appear on camera lens lol\noh yeah there is a tint to thte things\nalso fog\nalso now soft shadows","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","reflection","ray","sdf","raymarcher","animated","animation","reflect","fnnuy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BLURDIST 2.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 stepUV = vec2(1./iResolution.x, 1./iResolution.y);\n    vec3 mainCol = texture(iChannel0, uv).rgb;\n    vec4 curCol;\n    vec3 sampleCol = vec3(0.);\n    float sampleLength = 0.;\n    float depth = texture(iChannel0, uv).a;\n    float blurSize = depth / 8.;\n    blurSize *= blurSize;\n    for(float i = -BLURDIST * blurSize; i <= BLURDIST * blurSize; i ++){\n        for(float j = -BLURDIST * blurSize; j <= BLURDIST * blurSize; j ++){\n            curCol = texture(iChannel0, uv + vec2(stepUV.x*i, stepUV.y*j));\n            \n            if(abs(curCol.a - depth) < .5){\n                sampleCol += curCol.rgb;\n                sampleLength += 1.;\n            }\n        }\n    }\n    sampleCol /= sampleLength;\n    fragColor = vec4(sampleCol, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define EPSILON .001\n#define PI 3.1415926535\n#define DIST 7.\n#define CAMDIST 7.\n#define SAMPLE 16.\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nmat2 rotate(float d)\n{\n    float c = cos(d);\n    float s = sin(d);\n    return  mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec4 sphere, vec3 position)\n{\n    return length(position - sphere.xyz) - sphere.w;\n}\n\nfloat sdTwist(vec4 cube, vec3 position, float r)\n{\n    position.xz *= rotate(cos(iTime+position.y*PI/16.));\n    position.xz *= (abs(mod(position.y,2.)-1.) + 7.) / 8.;\n    position.y /= 8.;\n    float ret = length(max(abs(position-cube.xyz)-vec3(cube.w),  0.)) - r;\n    return ret;\n}\n\nfloat sdCube(vec4 cube, vec3 position, float r)\n{\n    float ret = length(max(abs(position-cube.xyz)-vec3(cube.w-r),  0.))-r;\n    return ret;\n}\n\nfloat getDist(vec3 position)\n{\n    \n    vec4 box = vec4(0, 0, 0, 2);\n    float bDist = sdCube(box, position, .5);\n    vec4 box2 = vec4(2, 2, 2, 1);\n    float bDist2 = sdCube(box2, position, .5);\n    float wDist = min(min(\n        min(position.x+DIST, DIST-position.x),\n        min(position.y+DIST, DIST-position.y)),\n        min(position.z+DIST, DIST-position.z));\n    //float wDist = position.y+DIST;\n    float sDist = sdSphere(vec4(3., -3., 3., 2.), position);\n    //if(position.x < 1. && position.x > -1. && position.z < 1. && position.z > -1.) groundDist = 50.;\n    \n    return min(min(min(bDist, bDist2), wDist), sDist);\n}\n\nfloat getObject(vec3 position)\n{\n    \n    vec4 box = vec4(0, 0, 0, 2);\n    float bDist = sdCube(box, position, .5);\n    vec4 box2 = vec4(2, 2, 2, 1);\n    float bDist2 = sdCube(box2, position, .5);\n    float wDist = min(min(\n        min(position.x+DIST, DIST-position.x),\n        min(position.y+DIST, DIST-position.y)),\n        min(position.z+DIST, DIST-position.z));\n    //float wDist = position.y+DIST;\n    float sDist = sdSphere(vec4(3., -3., 3., 2.), position);\n    float mini = min(min(min(bDist, bDist2), wDist), sDist);\n    //if(position.x < 1. && position.x > -1. && position.z < 1. && position.z > -1.) groundDist = 50.;\n    if(bDist == mini){\n        return 1.;\n    }\n    if(wDist == mini || bDist2 == mini){\n        return 1.;\n    }\n    return 1.;\n}\n\nvec3 getNormal(vec3 position)\n{\n    float dist = getDist(position);\n    vec2 epsilon = vec2(EPSILON, 0);\n    vec3 normal = dist - vec3(\n        getDist(position - epsilon.xyy),\n        getDist(position - epsilon.yxy),\n        getDist(position - epsilon.yyx)\n    );\n    return normalize(normal);\n}\n\nfloat march(vec3 position, vec3 direction)\n{\n    float dist = 0.;\n    float curDist = 0.;\n    for(int i = 0; i < 128; i ++){\n        curDist = getDist(position + direction * dist);\n        dist += curDist;\n        if(abs(curDist) < EPSILON) break;\n    }\n    return dist;\n}\n\nfloat getLightSpec(vec3 position, vec3 light, vec3 origin)\n{\n    vec3 lightDir = normalize(light - position);\n    vec3 viewDir = normalize(origin - position);\n    vec3 normal = getNormal(position);\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    float burn = pow(max(dot(viewDir, lightDir), 0.0), 16.);\n    return specular + burn;\n}\n\nfloat getLight(vec3 position, vec3 light, vec3 origin)\n{\n    vec3 lightDir = normalize(light - position);\n    vec3 viewDir = normalize(origin - position);\n    vec3 normal = getNormal(position);\n    float hitToLightDist = march(position + normal * EPSILON * 2., lightDir);\n    float lightDist = length(light - position);\n    if(hitToLightDist < lightDist) return 0.;\n    float lightVal = clamp(dot(lightDir, normal), 0., 1.);\n    return clamp(lightVal + getLightSpec(position, light, origin),0.,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 iMousePos = (iMouse.xy - .5 * iResolution.xy) / iResolution.y * 2.;\n    if(iMouse.xy == vec2(0., 0.)){iMousePos = vec2(iTime / 16., -.375 + cos(iTime / 8.) / 4.);}\n    vec3 origin = vec3(0., 0., -CAMDIST);\n    vec3 direction = normalize(vec3(uv, 1));\n    direction.yz *= rotate((iMousePos.y - 1.5) * PI);\n    origin.yz *= rotate((iMousePos.y - 1.5) * PI);\n    direction.xz *= rotate(iMousePos.x * PI);\n    origin.xz *= rotate(iMousePos.x * PI);\n    float dist = march(origin, direction);\n    vec3 hit = origin + direction * dist;\n    float hits = 0.;\n    float totalDist = dist;\n    while(mod(getObject(hit),2.) == 0. && hits < 16.){\n        direction = reflect(direction, getNormal(hit));\n        hit += getNormal(hit) * EPSILON * 2.;\n        dist = march(hit, direction);\n        hit += direction * dist;\n        totalDist += dist;\n        hits ++;\n    }\n    float lightVal = 0.;\n    vec3 r1, r2;\n    float lightVal2;\n    vec4 l1 = vec4(-3, 3, 3, 0.);\n    vec4 l2 = vec4(-2, 4, 4, .25);\n    for(float i = 0.; i < SAMPLE; i ++){\n        r1 = vec3(rand(direction.x+uv.x+i), rand(direction.x+uv.x+.1+i), rand(direction.x+uv.x+.2+i));\n        r2 = vec3(rand(direction.y+uv.y+i), rand(direction.y+uv.y+.1+i), rand(direction.y+uv.y+.2+i));\n        r1 *= l1.w / length(r1);\n        r2 *= l2.w / length(r2);\n        lightVal2 = getLight(hit, l1.xyz+r1, origin) + getLight(hit, l2.xyz+r2, origin);\n        lightVal += lightVal2;\n    }\n    lightVal /= 2. * SAMPLE;\n    \n    for(float i = 0.; i < hits; i ++)\n    {\n        lightVal = (lightVal - .125) * .25 + .125;\n    }\n    lightVal *= (512. - totalDist) / 512.;\n    vec3 col = vec3(lightVal);\n    // Output to screen\n    fragColor = vec4(col, totalDist);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define BLURDIST 2.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 stepUV = vec2(1./iResolution.x, 1./iResolution.y);\n    vec3 mainCol = texture(iChannel0, uv).rgb;\n    vec3 curCol;\n    vec3 sampleCol = vec3(0.);\n    vec3 avgCol = vec3(0.);\n    float sampleLength = 0.;\n    float avgLength = 0.;\n    for(float i = -BLURDIST; i <= BLURDIST; i ++){\n        for(float j = -BLURDIST; j <= BLURDIST; j ++){\n            curCol = texture(iChannel0, uv + vec2(stepUV.x*i, stepUV.y*j)).rgb;\n            avgCol += curCol;\n            avgLength += 1.;\n            if(length(curCol - mainCol) < .5){\n                sampleCol += curCol;\n                sampleLength += 1.;\n            }\n        }\n    }\n    \n    if(sampleLength/avgLength > .25){\n    sampleCol /= sampleLength;}else{\n    \n    avgCol /= avgLength;\n    sampleCol = avgCol;\n    }\n    fragColor = vec4(sampleCol, texture(iChannel0,uv).a);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"vec3 tCol(vec2 uv)\n{\n    return texture(iChannel0, uv).rgb;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 stepuv = vec3(1./iResolution.x, 1./iResolution.y, 0.);\n    vec3 col = tCol(uv)\n                 + tCol(uv + stepuv.xz)\n                 - tCol(uv + stepuv.xy)\n                 + tCol(uv + stepuv.zy)\n                 - tCol(uv + stepuv.zy - stepuv.xz)\n                 + tCol(uv - stepuv.xz)\n                 - tCol(uv - stepuv.xy)\n                 + tCol(uv - stepuv.zy)\n                 - tCol(uv - stepuv.zy + stepuv.xz);\n    fragColor = vec4(col,texture(iChannel0, uv).a);\n}","name":"Buffer C","description":"","type":"buffer"}]}