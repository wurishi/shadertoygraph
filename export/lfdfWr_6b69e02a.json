{"ver":"0.1","info":{"id":"lfdfWr","date":"1732980594","viewed":83,"name":"basic geomatric shapes","username":"lem","description":"basic shapes","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["basic","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.001\n\n// Get color based on position and time\nvec3 getObjectColor(vec3 p, float objType) {\n    float t = iTime * 0.5;\n    \n    // Different color patterns for each object\n    if (objType == 1.0) { // Sphere\n        return vec3(0.5 + 0.5 * sin(t + p.y),\n                   0.5 + 0.5 * sin(t * 1.2 + p.x),\n                   0.5 + 0.5 * sin(t * 0.8 + p.z));\n    } else if (objType == 2.0) { // Box\n        return vec3(0.5 + 0.5 * cos(t * 0.7 + p.z),\n                   0.5 + 0.5 * sin(t + p.y),\n                   0.5 + 0.5 * cos(t * 1.1 + p.x));\n    } else { // Torus\n        return vec3(0.5 + 0.5 * sin(t * 1.3 + length(p.xz)),\n                   0.5 + 0.5 * cos(t + p.y),\n                   0.5 + 0.5 * sin(t * 0.9 + p.x));\n    }\n}\n\n// Signed Distance Functions for primitives\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// Scene distance function and object ID\nvec2 getDist(vec3 p) {\n    // Animate position based on time\n    vec3 spherePos = vec3(sin(iTime) * 2.0, cos(iTime), 0);\n    vec3 boxPos = vec3(-2, sin(iTime) * 0.5 + 0.5, 0);\n    vec3 torusPos = vec3(2, cos(iTime) * 0.5, 0);\n    \n    // Calculate distances to primitives\n    float sphereDist = sdSphere(p - spherePos, 1.0);\n    float boxDist = sdBox(p - boxPos, vec3(0.75));\n    float torusDist = sdTorus(p - torusPos, vec2(1.0, 0.3));\n    \n    // Return minimum distance and object ID\n    float d = min(sphereDist, min(boxDist, torusDist));\n    float objType = 1.0;\n    if (d == boxDist) objType = 2.0;\n    if (d == torusDist) objType = 3.0;\n    \n    return vec2(d, objType);\n}\n\n// Calculate normal at a point\nvec3 getNormal(vec3 p) {\n    float d = getDist(p).x;\n    vec2 e = vec2(0.01, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x);\n    return normalize(n);\n}\n\n// Ray marching function\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float dO = 0.0;\n    float objType = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO;\n        vec2 dS = getDist(p);\n        dO += dS.x;\n        objType = dS.y;\n        if(dO > MAX_DIST || abs(dS.x) < SURF_DIST) break;\n    }\n    \n    return vec2(dO, objType);\n}\n\n// Lighting calculation\nvec3 getLight(vec3 p, float objType) {\n    vec3 lightPos = vec3(2, 5, -4);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float diff = clamp(dot(n, l), 0.1, 1.0);\n    \n    // Shadow calculation\n    float d = rayMarch(p + n * SURF_DIST * 2.0, l).x;\n    if(d < length(lightPos - p)) diff *= 0.1;\n    \n    // Get object color\n    vec3 objColor = getObjectColor(p, objType);\n    \n    return objColor * diff;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera setup\n    vec3 ro = vec3(0, 2, -5); // Ray origin (camera position)\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); // Ray direction\n    \n    vec2 march = rayMarch(ro, rd);\n    float d = march.x;\n    float objType = march.y;\n    vec3 p = ro + rd * d;\n    \n    vec3 color = getLight(p, objType);\n    \n    // Add some ambient light\n    color += vec3(0.1, 0.1, 0.1);\n    \n    // Fog effect\n    color = mix(color, vec3(0.1), 1.0 - exp(-0.02 * d));\n    \n    // Gamma correction\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}