{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/*by mu6k, Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n This started off as test of some noise functions. \n Well the only proper way to test it is with volumetric rendering. \n This is not physically accurate, it just looks nice. \n Use the mouse to rotate and to modify the density.\n\n 02/05/2013:\n - published\n\n 03/05/2013:\n - modified the init of ray variables (more compatible)\n - moved illumination to a separate function\n - added parameters \n\n muuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuusk!*/\n\n#define quality 20 // number of steps 20+ is decent for current setup\n#define illum_quality 10 // nr of steps for illumination\n//#define noise_use_smoothstep //different interpolation for noise functions\n\n//mouse.x rotates the cloud\n//mouse.y changes the density of the gas\n//note: performance = density * 1.0/quality * 1.0/illum_quality\n//note: if you only see a white blob, reduce the quality... there are supposed to be shadows\n\nfloat hash(float x)\n{\n\treturn fract(sin(x*.0127863)*17143.321); //decent hash for noise generation\n}\n\nfloat hash(vec2 x)\n{\n\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); \n}\n\nfloat hashmix(float x0, float x1, float interp)\n{\n\tx0 = hash(x0);\n\tx1 = hash(x1);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(0.0,1.0,interp);\n\t#endif\n\treturn mix(x0,x1,interp);\n}\n\nfloat hashmix(vec2 p0, vec2 p1, vec2 interp)\n{\n\tfloat v0 = hashmix(p0[0]+p0[1]*128.0,p1[0]+p0[1]*128.0,interp[0]);\n\tfloat v1 = hashmix(p0[0]+p1[1]*128.0,p1[0]+p1[1]*128.0,interp[0]);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec2(0.0),vec2(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[1]);\n}\n\nfloat hashmix(vec3 p0, vec3 p1, vec3 interp)\n{\n\tfloat v0 = hashmix(p0.xy+vec2(p0.z*143.0,0.0),p1.xy+vec2(p0.z*143.0,0.0),interp.xy);\n\tfloat v1 = hashmix(p0.xy+vec2(p1.z*143.0,0.0),p1.xy+vec2(p1.z*143.0,0.0),interp.xy);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec3(0.0),vec3(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[2]);\n}\n\nfloat hashmix(vec4 p0, vec4 p1, vec4 interp)\n{\n\tfloat v0 = hashmix(p0.xyz+vec3(p0.w*17.0,0.0,0.0),p1.xyz+vec3(p0.w*17.0,0.0,0.0),interp.xyz);\n\tfloat v1 = hashmix(p0.xyz+vec3(p1.w*17.0,0.0,0.0),p1.xyz+vec3(p1.w*17.0,0.0,0.0),interp.xyz);\n\t#ifdef noise_use_smoothstep\n\tinterp = smoothstep(vec4(0.0),vec4(1.0),interp);\n\t#endif\n\treturn mix(v0,v1,interp[3]);\n}\n\nfloat noise(float p) // 1D noise\n{\n\tfloat pm = mod(p,1.0);\n\tfloat pd = p-pm;\n\treturn hashmix(pd,pd+1.0,pm);\n}\n\nfloat noise(vec2 p) // 2D noise\n{\n\tvec2 pm = mod(p,1.0);\n\tvec2 pd = p-pm;\n\treturn hashmix(pd,(pd+vec2(1.0,1.0)), pm);\n}\n\nfloat noise(vec3 p) // 3D noise\n{\n\tvec3 pm = mod(p,1.0);\n\tvec3 pd = p-pm;\n\treturn hashmix(pd,(pd+vec3(1.0,1.0,1.0)), pm);\n}\n\nfloat noise(vec4 p) // 4D noise\n{\n\tvec4 pm = mod(p,1.0);\n\tvec4 pd = p-pm;\n\treturn hashmix(pd,(pd+vec4(1.0,1.0,1.0,1.0)), pm);\n}\n\nvec3 cc(vec3 color, float factor,float factor2) // color modifier\n{\n\tfloat w = color.x+color.y+color.z;\n\treturn mix(color,vec3(w)*factor,w*factor2);\n}\n\nvec3 ldir = normalize(vec3(-1.0,-1.0,-1.0)); //light direction\n\nfloat density(vec3 p) //density function for the cloud\n{\n\tvec4 xp = vec4(p*0.4,iTime*0.1+noise(p));\n\tfloat nv=pow(pow(noise(xp),2.0)*2.1,\t2.5)*(10.0-length(p.xyz));\n\tnv = max(0.0,nv); //negative density is illegal.\n\tnv = min(1.0,nv); //high density causes artifacts\n\treturn nv;\n}\n\nfloat illumination(vec3 p,float density_coef)\n{\n\tvec3 l = ldir;\n\tfloat il = 1.0;\n\tfloat ill = 1.0;\n\t\t\n\tfor(int i=0; i<int(illum_quality); i++) //illumination\n\t{\n\t\til-=density(p-l*hash(p.xy+vec2(il,p.z))*0.5)*density_coef;\n\t\tp-=l;\n\t\tif (il <= 0.0)\n\t\t{\n\t\t\til=0.0;\n\t\t\tbreak; //light can't reach this point in the cloud\n\t\t}\n\t\tif (il == ill)\n\t\t{\n\t\t\tbreak; //we already know the amount of light that reaches this point\n\t\t\t//(well not exactly but it increases performance A LOT)\n\t\t}\n\t\till = il;\n\t}\n\t\n\treturn il;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n\tuv.x = uv.x*iResolution.x/iResolution.y;\n\tvec2 m = iMouse.xy / iResolution.xy - 0.5;\n\t\n\t\n\tfloat rot = m.x*3.14159*2.0;\n\t\n\tvec3 d = vec3(sin(rot),.0,cos(rot)); //ray direction\n\tvec3 p = -20.0*d; //ray position\n\t\n\tvec3 t = cross(d,vec3(0.0,1.0,0.0)); \n\td.x = d.x+uv.x*t.x; //perspective projection\n\td.y = uv.y;\n\td.z = d.z +uv.x*t.z;\n\t\n\td=normalize(d);\n\t\n\tp+=d*10.0; //move the ray forward by 10.0 units \n\t//because cloud is a inside a 10.0 radius sphere\n\t//and initial ray position is 20.0 units away\n\t\n\tfloat illum_acc = 0.0;\n\tfloat dense_acc = 0.0;\n\tfloat density_coef = m.y*.35+0.23;\n\tfloat quality_coef = 20.0/float(quality);\n\t\n\tfor (int i=0; i<quality; i++) //max 20 step raycast\n\t{\n\t\tfloat ld0=length(p);\n\t\t\n\t\tp+=d*quality_coef;\n\t\tfloat ld1=length(p);\n\t\t\n\t\tif(ld1>ld0&&ld1>10.0) \n\t\t{\n\t\t\tbreak; //break condition: ray is moving away from the sphere\n\t\t\t//and is not inside the sphere\n\t\t}\n\t\t\n\t\tfloat nv = density(p+d*hash(uv+vec2(iTime,dense_acc))*0.25)*density_coef*quality_coef;\n\t\t//evaluate the density function\n\t\t\n\t\tvec3 sp = p;\n\t\tdense_acc+=nv;\n\t\t\n\t\tif (dense_acc>1.0)\n\t\t{\n\t\t\tdense_acc=1.0; //break condition: following steps do not contribute \n\t\t\tbreak; //to the color because it's occluded by the gas\n\t\t}\n\t\t\n\t\tfloat il = illumination(p,density_coef);\n\t\t\n\t\tillum_acc+=max(0.0,nv*il*(1.0-dense_acc)); \n\t\t//nv - alpha of current point\n\t\t//il - illumination of current point\n\t\t//1.0-dense_acc - how much is visible of this point\n\t}\n\n\tvec3 illum_color = vec3(1.1,0.85,0.3)*illum_acc*1.55;\n\t\n\tfloat sun = dot(d,-ldir); sun=.5*sun+.5; sun = pow(sun,100.0);\n\tvec3 sky_color = vec3(0.3,0.5,0.8);\n\t\n\tvec3 dense_color = sky_color*0.51; //color of the dark part of the cloud\n\t\n\tsky_color=sky_color*(1.0-uv.y*0.2)+vec3(sun);\n\n\tvec3 color = mix(sky_color,dense_color+illum_color,smoothstep(0.0,1.0,dense_acc)); color-=length(uv)*0.2;\n\tcolor+=hash(color.xy+uv)*0.01; //kill all color banding\n\tcolor =cc(color,0.5,0.4); \n\t\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sl3Dn","date":"1367508203","viewed":2165,"name":"A Cloud","username":"mu6k","description":"This started off as test of some noise functions. Well the only proper way to test it is with volumetric rendering. This is not physically accurate, it just looks nice. Use the mouse to rotate and to modify the density.","likes":47,"published":1,"flags":0,"usePreview":0,"tags":["3d","noise","volume"],"hasliked":0,"parentid":"","parentname":""}}