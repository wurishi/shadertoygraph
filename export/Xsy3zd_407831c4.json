{"ver":"0.1","info":{"id":"Xsy3zd","date":"1455886691","viewed":1545,"name":"blood flow","username":"nsweb","description":"This is the result of some experiments with the curl noise idea from Robert Bridson.\nIt uses some 3d simplex noise code from nikat for the flow perturbation.\n","likes":27,"published":1,"flags":0,"usePreview":1,"tags":["curl","flow","simplexnoise","vectorfield"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Created by Nicolas SÃ©rouart, nsweb 2015\n * This work is licensed under a \n * Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n * http://creativecommons.org/licenses/by-nc-sa/3.0/\n *  - You must attribute the work in the source code \n *    (link to https://www.shadertoy.com/view/Xsy3zd).\n *  - You may not use this work for commercial purposes.\n *  - You may distribute a derivative work only under the same license.\n */\n\n// uncomment for 2D curl debugging \n//#define SHOW_ARROW\n\nconst float ARROW_TILE_SIZE = 0.045;\n\n// signed distance to capsule (for arrow visualization)\nvec2 sdCapsule(vec3 p, vec3 p0, vec3 p1, float r)\n{\n    vec3 v = vec3( p1 - p0 );\n\tvec3 w = vec3( p - p0 );\n\tfloat t_seg = max( dot( v, w ), 0.0 );\n\n\tfloat v2 = dot( v, v );\n\tt_seg = min( t_seg, v2 );\n\tt_seg = t_seg / v2;\n\tw += v*(-t_seg);\n\n\treturn vec2( sqrt( dot( w, w) ) - r, t_seg );\n}\n\n// computes arrow center location from given pos\nvec3 arrowTilePos(vec3 p) \n{\n\treturn (floor(p / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n// get the arrow color under pos (transparent if no hit)\nvec4 arrowColor(vec3 p, vec3 arrow_center, vec3 arrow_vec) \n{\n    const float scale = ARROW_TILE_SIZE;\n    arrow_vec *= 0.15;\n\tvec2 darrow = sdCapsule(p, arrow_center - arrow_vec*scale, arrow_center + arrow_vec*scale, (ARROW_TILE_SIZE*1.005)*0.5 );\n\tif( darrow.x > 0.0 )\n        return vec4(0.0);\n    \n    return vec4( mix(vec3(0.2,0.0,0.0), vec3(0.5,1.0,0.5), darrow.y), 1.0 );\n}\n\n/*************************************************/\n/* 3d simplex noise code taken from nikat\n * https://www.shadertoy.com/view/XsX3zB\n */\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n/*************************************************/\n\n\n// the scalar field driving the effect\n// curl operator is applied on top of it\nfloat field2d(vec3 p)\n{\n    // combination of an upward stream...\n    float v = -p.x*(1.0 - p.y);\n    // ... and of simplex noise\n    v += 0.25*(1.2 + 0.5*p.y) * simplex3d( vec3( p.xy*4.0, iTime*0.5 ) );\n\n    return v;\n}\n\n// the curl operator in 2d\nvec3 curl2d(vec3 p)\n{\n    vec3 e = vec3(0.001,-0.001,0.0);\n    float fxp = field2d(p + e.xzz);\n    float fxm = field2d(p + e.yzz);\n    float fyp = field2d(p + e.zxz);\n    float fym = field2d(p + e.zyz);\n\n    vec3 c = vec3( \t(fyp - fym) / (2.*e.x),\n                 \t(-fxp + fxm) / (2.*e.x),\n                 \t0.0 );\n\treturn c;   \n}\n\n// computes stream color at given pixel pos, returns transparent if outside of range\nvec4 getColor2d(vec3 p)\n{\n    const int step_count = 160;\n    const float dt = 0.005;\n    int step_idx = 0;\n    \n    for( int i = 0; i < step_count; i++ )\n    {   \n    \tvec3 f = curl2d(p);\n        p -= f * dt;\n        if( p.y < -1.3 )\n            break;\n        step_idx++; \n    }\n    \n    if( step_idx < step_count && abs(p.x) < 0.4 )\n    {\n        float fade = 1.0 - smoothstep( 0.15, 0.4, abs(p.x) );\n        float ratio = pow( float(step_idx) / float(step_count), 2.0 );\n        vec3 col = texture( iChannel0, vec2(abs(p.x), ratio-iTime*0.5) ).rgb;\n        col *= vec3(0.8, 0.1, 0.1);\t // red tint\n        col = pow( col, vec3(1.6) ); // darkens color\n        \n        return vec4( col, fade * (1.0 - ratio) );\n    }\n    \n    return vec4(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p = vec3( (fragCoord.xy / iResolution.xx - 0.5) * 2.0, 0.0 );\n    \n#ifdef SHOW_ARROW\n    vec4 ar = arrowColor( p, arrowTilePos(p), curl2d( arrowTilePos(p) ) );\n#else\n    vec4 ar = vec4(0.0);\n#endif\n\t\n    vec4 c = getColor2d( p );\n    vec3 bg_col = vec3(field2d( p ));\n    vec4 col = mix( vec4(bg_col*0.5 + 0.5,1.0), ar, ar.a );\n    col = mix( col, c, c.a );\n\n    fragColor = col;\n}\n\n\n\n\n","name":"Image","description":"","type":"image"}]}