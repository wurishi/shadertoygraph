{"ver":"0.1","info":{"id":"7ltSW2","date":"1639846113","viewed":144,"name":"bouncing glospheroids","username":"Firepal","description":"bouncy","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int DIST = 0;\nconst int MAT = 1;\n\nvec2 map(in vec3 p)\n{\n    vec2 d0 = vec2( dot(p,vec3(0.0,1.0,0.0)), 1.0 );\n    vec2 res = d0;\n    \n    float time = iTime;\n    \n    vec3 d1pos = vec3(cos(time)*2.0,abs(sin(time)*4.0)*1.5+0.5,0.0);\n    vec2 d1 = vec2( length(p-d1pos)-0.5, 0.0 );\n    if (d1[DIST] < res[DIST]) { res = d1; }\n    \n    time -= 0.4;\n    \n    vec3 d2pos = vec3(cos(time),abs(sin(time)*4.0)+0.5,0.0);\n    vec2 d2 = vec2( length(p-d2pos)-0.5, 0.0 );\n    if (d2[DIST] < res[DIST]) { res = d2; }\n    \n    time -= 0.4;\n    \n    vec3 d3pos = vec3(cos(time)*0.5,abs(sin(time)*4.0)*0.5+0.5,0.0);\n    vec2 d3 = vec2( length(p-d3pos)-0.5, 0.0 );\n    if (d3[DIST] < res[DIST]) { res = d3; }\n    \n    time -= 0.4;\n    \n    vec3 d4pos = vec3(cos(time)*2.0,abs(sin(time)*4.0)*2.5+0.5,0.0);\n    vec2 d4 = vec2( length(p-d4pos)-0.5, 0.0 );\n    if (d4[DIST] < res[DIST]) { res = d4; }\n    \n    time -= 0.4;\n    \n    vec3 d5pos = vec3(cos(time)*3.5,abs(sin(time)*4.0)+0.5,0.0);\n    vec2 d5 = vec2( length(p-d5pos)-0.5, 0.0 );\n    if (d5[DIST] < res[DIST]) { res = d5; }\n    \n    return res;\n}\n\nfloat checkersTexture( in vec2 p )\n{\n    vec2 q = floor(p);\n    return mod( q.x+q.y, 2.0 );            // xor pattern\n}\n\nvec3 planeMat(in vec3 ray)\n{\n    return vec3( checkersTexture(ray.xz)*0.5+0.5 );\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 0.01;\n    const vec2 k = vec2(1,-1)*0.5773;\n    return normalize( k.xyy*map( p + k.xyy*h )[DIST] + \n                      k.yyx*map( p + k.yyx*h )[DIST] + \n                      k.yxy*map( p + k.yxy*h )[DIST] + \n                      k.xxx*map( p + k.xxx*h )[DIST] );\n}\n\n\nvec3 calcColor(in float matID, in vec3 pos)\n{\n    vec3 mate = vec3(0.0);\n    \n    if(matID < 0.5) { mate = vec3(1.0); } // sphere\n    else if(matID < 1.5) { mate = planeMat(pos); }\n    return mate;\n}\n\nvec2 raymarch(in vec3 ro, in vec3 rd, out vec3 ray)\n{\n    float total_dist = 0.0;\n    \n    for (int i=0; i<100; i++)\n    {\n        vec3 ray_pos = (rd*total_dist)+ro;\n        \n        vec2 dist_march = map(ray_pos);\n        \n        if (total_dist > 100.0){\n            break;\n        }\n        \n        if (dist_march[DIST] < 0.01){\n            ray = ray_pos;\n            return vec2(total_dist,dist_march[MAT]);\n        }\n        \n        total_dist += dist_march[DIST];\n    }\n    \n    ray = vec3(-1.0);\n    return vec2(-1.0);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nint AO_SAMPS = 32;\nfloat ao(in vec3 pos, in vec3 normal, in vec2 screenuv)\n{\n    vec3 tn = normalize(cross(normal,vec3(0.0,1.0,0.0)));\n    vec3 bitn = normalize(cross(tn,normal));\n    \n    float occ = 0.0;\n    for (int i=0;i<AO_SAMPS;i++)\n    {\n        vec2 aa = hash22(screenuv*float(i+1)+iTime);\n        float ra = sqrt(aa.y);\n        float rx = ra*cos(6.2831*aa.x);\n        float ry = ra*sin(6.2831*aa.x);\n        float rz = sqrt(1.0-aa.y);\n        vec3 dir = vec3(tn*rx + bitn*ry + rz*normal);\n        vec3 y;\n        occ += step(0.0,raymarch(pos+dir*0.3, dir, y)[DIST]);\n    }\n    return occ/float(AO_SAMPS);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 ro = vec3(0.0,1.0,-6.0);\n    //ro.y = abs(cos(iTime)*1.0)+1.0;\n    vec2 uvrd = (uv-0.5)*3.0;\n    uvrd.y *= iResolution.y/iResolution.x;\n    //float yes = (uvrd.x*uvrd.x)+(uvrd.y*uvrd.y);\n    //uvrd *= 1.0 + yes * 0.5;\n    \n    vec3 rd = vec3(uvrd,1.0);\n    rd = normalize(rd+vec3(0.0,abs(sin(iTime)*0.4)+0.1,0.0));\n    \n    vec3 ray;\n    vec2 rayr = raymarch(ro,rd,ray);\n    \n    vec3 color = vec3(0.0);\n    color = calcColor(rayr[MAT],ray);\n    \n    vec3 normal = calcNormal(ray);\n    color *= ao(ray,calcNormal(ray),fragCoord)*3.0;\n    \n    \n    color *= exp(rayr[DIST]*-0.1);\n    if (rayr[DIST] < 0.0) { color = vec3(0.0); }\n    \n    fragColor = vec4(vec3( color ),1.0);\n}","name":"Image","description":"","type":"image"}]}