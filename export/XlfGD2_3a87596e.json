{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//-----------------------------------------------------\nstruct Sphere {\n\tvec3 c;// Center\n\tfloat r;// Radius\n};\n    \nvec3 theEye = vec3(0., 0., -1); // -Z, Some distance behind the screen\nSphere theSphere = Sphere(vec3(0.0, 0.0, 3.0), 2.5); // Position size of sphere\nfloat G1V(float nDotv, float aSqr) { return 2.0/(nDotv*(1.-aSqr)+aSqr); } //GGX-Smith visibility helper\n\n//-----------------------------------------------------\nvec3 lit(vec3 litPosition, vec3 sphereCenter, vec3 lightPos) {\n\n\tvec3 n = normalize(litPosition - sphereCenter);\n\tvec3 l = normalize(lightPos - litPosition);\n\tvec3 v = normalize(theEye - litPosition);\n\tvec3 h = normalize(v + l);\n    vec3 r = reflect(-l,n);\n    float Pi = 3.14159265359;\n    \n    vec3 albedo = vec3(1,0,0);\n    vec3 ambient = 0.20 * albedo;\n    \n    float specPower = (iMouse.y/iResolution.y * 30.0 + 2.0);\n    specPower *= specPower;\n    \n    //lambert\n    float nDotl =  max(0.0, dot(n, l));\n    vec3 diffuseLambert = albedo * nDotl;\n    //return ambient + diffuseLambert;\n    \n    //phong\n    float rDotv =  max(0.0, dot(r, v));\n    float phongSpec = pow(rDotv,specPower);\n\t//return ambient + diffuseLambert + phongSpec;\n    \n    //blinn phong\n    float nDoth =  max(0.0, dot(n, h));\n    float blinnPhongSpec = pow(nDoth,specPower);\n\t//return diffuseLambert + blinnPhongSpec;\n    \n    //phong with normalized spec\n    float phongNormFactor = (specPower + 2.0) / (2.0 * Pi);\n\t//return ambient + diffuseLambert + phongNormFactor * phongSpec;\n    \n    //blinn-phong with normalized spec\n    float blinnPhongNormFactor = (specPower + 2.0) / (2.0 );\n\t//return ambient + diffuseLambert + blinnPhongNormFactor * blinnPhongSpec;\n    \n    //blinn-phong with normalized spec & spec/diffuse energy conservation\n    vec3 diffuseColor = mix(albedo, vec3(0,0,0), iMouse.x/iResolution.x);\n    vec3 specularColor = vec3(1.0,1.0,1.0)-diffuseColor.rrr;\n    //return ambient+ diffuseColor * nDotl + specularColor * blinnPhongNormFactor * blinnPhongSpec;\n    \n    //blinn-phong BRDF fix f0 (thus not energy conservative)\n    vec3 f0 = vec3(0.971519,0.959915,0.915324); //silver\n    float lDoth =  max(0.0, dot(l, h));\n    float nDotv =  max(0.0, dot(n, v));\n    vec3 F = f0 + (1.0 - f0) * pow( (1.0 - lDoth), 5.0);\n    float D = blinnPhongNormFactor * blinnPhongSpec;\n    float G = nDotl * nDotv;\n    vec3 specBRDF = (F * G * D) / ((4.0 * nDotl * nDotv) + 0.001);\n    //return ambient + diffuseColor * nDotl + f0 * specBRDF;\n    \n\t//blinn-phong BRDF with metalness\n    float metalness = (iMouse.x/iResolution.x) * 2.;\n    metalness = max (metalness,0.);\n    metalness = min (metalness,1.);\n    diffuseColor = mix(albedo, vec3(0,0,0), metalness);\n    ambient = 0.20 * diffuseColor;\n    vec3 minf0 = vec3(0.04,0.04,0.04);\n    f0 = mix(minf0, f0, metalness);\n    F = f0 + (1.0 - f0) * pow( (1.0 - lDoth), 5.0);\n    specBRDF = (F * G * D) / ((4.0 * nDotl * nDotv) + 0.001);\n    vec3 blinnPhongMetalness = diffuseColor * nDotl + f0 * specBRDF;\n    //return ambient + blinnPhongMetalness;\n    \n    //adding reflection (very fake)\n    float veryFakeReflectionGlossyness = iMouse.y/iResolution.y;\n    vec3 glossyReflection = texture( iChannel0, n ).xyz;\n    vec3 blurryReflection = texture( iChannel1, n ).xyz;\n    vec3 FresnelReflection = f0 + (1.0 - f0) * pow( (1.0 - nDotv), 5.0);\n    vec3 reflectionBRDF  = FresnelReflection * mix(blurryReflection,glossyReflection, veryFakeReflectionGlossyness);\n    //return ambient + reflectionBRDF;\n        \n    //all together\n    return ambient + blinnPhongMetalness + reflectionBRDF;\n}\n\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////\n\n//-----------------------------------------------------\nstruct Ray {\n\tvec3 o; // Origin\n\tvec3 d; // Direction\n};\n\n//-----------------------------------------------------\nfloat intersectSphere(Ray ray, Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.o - sphere.c;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discriminant = dot(co, ray.d) * dot(co, ray.d)\n\t\t\t- (dot(co, co) - sphere.r * sphere.r);\n\n\t// If answer is not negative, calculate the origin-surface distance\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.d, co) - sqrt(discriminant); //\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\n//-----------------------------------------------------\nvec4 GetBackgroundColor(vec2 viewCoord)\n{\n\tvec2 uv = viewCoord.xy / iResolution.xy;\n\treturn vec4(uv,0.5+0.5*sin(iTime),1.0) * 0.25;\n}\n\n//-----------------------------------------------------\nvec2 FromPixelsCoordToNDC(vec2 viewCoord)\n{\n    // Renaming\n\tfloat widthInPixels = iResolution.x;\n\tfloat heightInPixel = iResolution.y;\n    \n    // Converting all coordinates (x,y) to be in the range [0,1]\n\tfloat x = viewCoord.x / widthInPixels;\n\tfloat y = viewCoord.y / heightInPixel;\n\n\t// Converting from range [0,1] to NDC [-1,1]\n\t// Effectively moves pixel (0,0) to the middle of the viewport\n    float aspectRatio = widthInPixels / heightInPixel;\n\tfloat posPixelX = x * (2.0 * aspectRatio) - aspectRatio;\n\tfloat posPixelY = y * 2.0 - 1.0;\n    \n    return vec2(posPixelX, posPixelY);\n}\n\n//-----------------------------------------------------\nvec3 GetLightPos()\n{\n    vec2 ndcMousePos = FromPixelsCoordToNDC(iMouse.xy);\n    //return vec3(ndcMousePos, -2.);\n    return vec3(2.0*ndcMousePos.x,0, 0);\n}\n\n//-----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t/*\n\tfragCoord is an input variable\n\tthat contains the window relative coordinates\n\t(x, y, z, 1/w) values for the fragment.\n\n\t The first two values (x,y) contain the pixelâ€™s center\n\t coordinates where the fragment is being rendered. For\n\t instance, with a frame buffer resolution of 800Ã—600, a\n\t fragment being rendered in the bottom-left corner would\n\t fall over the pixel position (0.5,0.5); a fragment\n\t rendered into the most top-right corner would have\n\t coordinates (799.5, 599.5). For applications that use\n\t multi-sampling these values may fall elsewhere on the pixel area.\n\t */\n\n\t// fragCoord is in window coordinates\n\tvec2 viewCoord = fragCoord.xy;\n    vec2 ndc = FromPixelsCoordToNDC(viewCoord.xy);\n\n\t// All the code from here is in Normalised Device Coordinates\n\t// The ray direction is the normalised eye-to-pixel vector (posPixel - posEye)\n\tvec3 posPixel = vec3(ndc, 0);\n\n\t// Ray from Eye to PixelOnScreen\n\tvec3 eye2Pixel = posPixel - theEye;\n\n\t// Normailse it, to use as a unit of distance\n\tvec3 theRay = normalize(eye2Pixel);\n\n\t// Does rayDirUnit ray from ndcEye intersect the sphere?\n\tfloat eyeToSphereDist = intersectSphere(Ray(theEye, theRay), theSphere);\n\n\t// If positive, then we have a hit\n\tif (eyeToSphereDist >= 0.)\n\t{\n\t\t// lit\n        vec3 pixelColor = lit(theEye + eyeToSphereDist * theRay, theSphere.c, GetLightPos());\n\t\tfragColor = vec4(pixelColor,1);\n\n\t} else\n        //background\n        fragColor = GetBackgroundColor(viewCoord);\n}\n\nvoid GGXSmithBRDF()\n{\n    float nDoth, D, Pi, G, nDotl, nDotv, specBRDF, F;\n    vec3 f0, diffuseColor, ambient;\n    float roughtness = 1.-(iMouse.y/iResolution.y);\n    float a = roughtness * roughtness;\n    float aSqr = a * a;\n    float DDenom = nDoth* nDoth * (aSqr-1.) + 1.;\n    D = aSqr / ( Pi * DDenom * DDenom);\n    float k = a/2.0;\n    G = G1V(nDotl,k)*G1V(nDotv,k);\n    specBRDF = (F * G * D) * nDotl;\n    vec3 ggxSmith = ambient + f0 * specBRDF + nDotl * diffuseColor;\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XlfGD2","date":"1425097288","viewed":1410,"name":"PBR Tests","username":"Lenorian","description":"clic + Mouse X = move light and change metalness \nclic + Mouse Y = change spec power\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["fromphongtopbrblinnphong"],"hasliked":0,"parentid":"","parentname":""}}