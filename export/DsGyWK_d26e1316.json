{"ver":"0.1","info":{"id":"DsGyWK","date":"1696582665","viewed":133,"name":"micrograin - Mossy Stones","username":"SimonL","description":"micrograin demo - Mossy Stones\n\nLeft : Linear blend, Right : Our visibility blend\n\nYou can control the camera position with WASD or Arrow keys, and the camera rotation with the mouse. It is recommended to keep the mouse inside the viewport to avoid unexpe","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["brdf","microfacet","siggraph","porosity","micrograin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// camera misc\nvec3 getVec3(int add);\nvoid setVec3(vec3 v, int add, inout vec4 o);\nvoid setMat3(mat3 m, int add, inout vec4 o);\nmat3 getMat3(int address);\n\n// raytrace\nfloat intersect_plane( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor );\n\n\nvoid mainImage( out vec4 out_col, in vec2 in_coord )\n{\n    out_col = vec4(0.);\n    \n    // frame uv\n    vec2 uv = (in_coord-iResolution.xy*.5)/iResolution.y;\n    \n    // light animation time\n    float anim = iTime*0.1*PI;\n    \n    // ray generation\n    mat3 cam = getMat3(0);\n    vec3 ray_dir = cam * normalize(vec3(uv, 1.5));\n    vec3 ray_ori = getVec3(3);\n    \n    \n    // test intersection with the plane\n\tvec3 pos, nor;\n\tif( intersect_plane( ray_ori, ray_dir, pos, nor) < 1e6 )\n\t{\n        nor = normal_mapping(pos.xz, nor, 0.1, iChannel1);\n        \n        // light definition\n        #if 0 // point light\n            vec3 point_light_pos = vec3(3.*cos(anim),0.1,3.*sin(anim));\n            vec3 light_dir = point_light_pos-pos;\n            float d_sqr = dot(light_dir,light_dir);\n            float r = 10.;\n            light_dir /= sqrt(d_sqr);\n            float light_attenuation = (2. / (d_sqr + r*r + sqrt(d_sqr) * sqrt(d_sqr + r*r)));\n            float light_intensity = 1000.;\n        #else // directional light\n            vec3 light_dir = normalize(vec3(0.0,sin(anim)*0.5 + 0.6,1.0));\n            float light_attenuation = 1.;\n            float light_intensity = 4.;\n        #endif\n        \n        // Correct normal (back facing normal case)\n        if (dot(nor, -ray_dir) <= 0.0){\n            nor = normalize(nor + 2.*ray_dir *dot(nor, -ray_dir));\n        }\n        \n        // filling factor\n        float tau_0 = pow(texture(iChannel1,pos.xz).x,1.);\n        \n        // porous layer anfractuosity\n        float beta = 0.75 * (1. - tau_0*tau_0);\n        // base roughness\n        float alpha = mix(0.1,0.5,tau_0);\n        // porous layer diffuse color\n        vec3 color_noise = texture(iChannel2,pos.xz*0.05).xxx;\n        color_noise = smoothstep(vec3(0.4),vec3(0.6),color_noise);\n        vec3 kd_s = vec3(0.251,0.333,0.192) + (color_noise-0.5)*0.15;\n        // base diffuse color\n        vec3 kd_b = texture(iChannel0,pos.xz*2.).xyz;\n        \n        //tau_0 = 0.;\n        // porous layer R0\n        vec3 R0_s  = vec3(0.0);\n        // base R0\n        vec3 R0_b  = vec3(0.053);\n        \n        // porous layer type (conductor or plastic) \n        bool is_conductor_s = false;\n        // base type (conductor or plastic)\n        bool is_conductor_b = false;\n        \n        bool linear_blend = uv.x < 0.;\n        // model evalutation\n        out_col.xyz = eval(\n              nor\n            , -ray_dir\n            , light_dir\n            , tau_0\n            , beta\n            , alpha\n            , kd_s\n            , kd_b\n            , R0_s\n            , R0_b\n            , is_conductor_s\n            , is_conductor_b\n            , linear_blend);\n            \n        out_col.xyz *= light_intensity * light_attenuation;\n\t}\n    else {\n        out_col = vec4(0.01);\n    }\n\t\n    \n    // tonemapping\n    out_col = out_col/(1.+out_col);\n    // gamma correction\n    out_col = pow(out_col,vec4(1.0/2.2));\n}\n\n\n// raytrace\nfloat intersect_plane( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor )\n{\n\tfloat tmin = 1e6;\n\tnor = vec3(0.);\n\tpos = vec3(0.);\n\t\n\tfloat h = (0.-ro.y)/rd.y;\n\tif(h > 0.) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.,1.,0.); \n\t\tpos = ro + h*rd;\n\t}\n\n\treturn tmin;\t\n}\n\n// camera misc\nvec3 getVec3(int add) {\n    return vec3(\n        texelFetch(iChannel3, ivec2(add, 0), 0).w,\n        texelFetch(iChannel3, ivec2(add, 1), 0).w,\n        texelFetch(iChannel3, ivec2(add, 3), 0).w\n    );\n}\nvoid setVec3(vec3 v, int add, inout vec4 o) {\n    ivec2 u = ivec2(gl_FragCoord.xy);\n    if(u == ivec2(add, 0)) o.w = v.x;\n    if(u == ivec2(add, 1)) o.w = v.y;\n    if(u == ivec2(add, 3)) o.w = v.z;\n}\nvoid setMat3(mat3 m, int add, inout vec4 o) {\n    for(int i = 0; i < 4; i++) {\n        setVec3(m[i], add+i, o);\n    }\n}\nmat3 getMat3(int address) {\n    return mat3(getVec3(address), getVec3(address+1), getVec3(address+2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////\n// Previous work /\n/////////////////\n\nvec3 FresnelDielectricDielectric(vec3 Eta, float CosTheta);\nvec3 FresnelDielectricConductor(vec3 Eta, vec3 Etak, float CosTheta);\nconst float PI = 3.141593f;\n\nfloat D_ggx(float alpha_sqr, float cos_theta)\n{\n    float cos2_theta = cos_theta*cos_theta;\n    float tan2_theta = (1.-cos2_theta) / cos2_theta;\n   \n    float denom = PI * cos2_theta * cos2_theta * (alpha_sqr + tan2_theta)*(alpha_sqr + tan2_theta);\n    \n    return alpha_sqr / denom;\n}\n\nfloat lambda_ggx(float alpha_sqr, float tan_theta)\n{\n    return (-1. + sqrt(1.+alpha_sqr*tan_theta*tan_theta))/2.;\n}\n\nfloat G1_ggx(float alpha_sqr, float cos_theta)\n{\n    float tan_theta = sqrt(1. - cos_theta * cos_theta) / cos_theta;\n    return 1./(1.+lambda_ggx(alpha_sqr,tan_theta));\n}\n\nfloat G_ggx(float alpha_sqr, float cos_theta_i, float cos_theta_o)\n{\n    return G1_ggx(alpha_sqr,cos_theta_i) * G1_ggx(alpha_sqr,cos_theta_o);\n}\n\n\nvec3 ggx_conductor_brdf(\n      float alpha_sqr\n    , vec3 R0\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{    \n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_ggx(alpha_sqr,cos_theta_h);\n    float G = G_ggx(alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    //vec3 F = FresnelDieletricConductor(eta,kappa,cos_theta_d);\n    return D*G*F / (4. * cos_theta_i * cos_theta_o);\n}\n\nvec3 ggx_plastic_brdf(\n      float alpha_sqr\n    , vec3 R0\n    , vec3 kd\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{    \n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_ggx(alpha_sqr, cos_theta_h);\n    float G = G_ggx(alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    vec3 spec = D*G*F / (4. * cos_theta_i * cos_theta_o);\n    \n    vec3 Ti = 1. - FresnelDielectricDielectric(eta,cos_theta_i);\n    vec3 To = 1. - FresnelDielectricDielectric(eta,cos_theta_o);\n    vec3 diff = To * Ti * kd / PI;\n    \n    return spec + diff;\n}\n\n/////////\n// Our /\n///////\n\n\n// Eq 18.\nfloat alpha2beta(float alpha,float tau_0)\n{\n    float fac = sqrt(-tau_0 / log(1. - tau_0));\n    return alpha / fac;\n}\n\n// Eq 18.\nfloat beta2alpha(float beta, float tau_0)\n{\n    float fac = sqrt(-tau_0 / log(1. - tau_0));\n    return beta * fac;\n}\n    \n// Eq. in section visible filling factor\nfloat gamma_beta(float beta_sqr,float cos_theta)\n{\n    float cos2_theta = cos_theta * cos_theta;\n    float sin2_theta = 1. - cos2_theta;\n    return sqrt(beta_sqr * sin2_theta + cos2_theta);\n}\n\n// Eq. in section Visible filling factor\nfloat gamma_beta_plus(float beta_sqr, float cos_theta)\n{\n    return 0.5 * (cos_theta + gamma_beta(beta_sqr,cos_theta));\n}\n\n// Eq. 21\nfloat tau_theta(float tau_0, float beta_sqr, float cos_theta)\n{\n    return 1. - pow((1. - tau_0) , (gamma_beta(beta_sqr,cos_theta)/cos_theta));\n}\n\n// Eq. 22\nfloat tau_theta_plus(float tau_0, float beta_sqr, float cos_theta)\n{\n    return 1. - sqrt((1. - tau_theta(tau_0, beta_sqr, cos_theta))*(1. - tau_0));\n}\n\n\n// Eq. in supplemental\nfloat G1_our(float tau_0, float beta_sqr, float cos_theta)\n{ \n    float pi_gamma = -log(1. - tau_0);\n    float exp_pi_gamma_minus_one = exp(pi_gamma) - 1.;\n\n    cos_theta = clamp(cos_theta,0.00001,0.99999);\n    float mu  = cos_theta / sqrt(1. - cos_theta * cos_theta);\n    \n    float beta2  = beta_sqr;\n    float beta4  = beta2  * beta2;\n    float beta6  = beta4  * beta2;\n    float beta8  = beta6  * beta2;\n    float beta10 = beta8  * beta2;\n    float beta12 = beta10 * beta2;\n    \n    float mu2  = mu   * mu;\n    float mu4  = mu2  * mu2;\n    float mu6  = mu4  * mu2;\n    float mu8  = mu6  * mu2;\n    float mu10 = mu8  * mu2;\n    float mu12 = mu10 * mu2;\n    \n    float beta2_mu2 = beta2 + mu2;\n    float sqrt_beta2_mu2 = sqrt(beta2_mu2);\n    \n    float F0 = pi_gamma * (-mu + sqrt_beta2_mu2)/(2.*mu);\n\n    float F1 = pow(pi_gamma,2.) * (beta2+2. * mu * (mu-sqrt_beta2_mu2))/(8. * mu * sqrt_beta2_mu2);\n\n    float F2 = pow(pi_gamma,3.) * (3. * beta4+12. * beta2 * mu2+8. * mu4-8. * mu * pow(beta2_mu2,3./2.))/(96. * mu * pow(beta2_mu2,3./2.));\n\n    float F3 = pow(pi_gamma,4.) * (5. * beta6+30. * beta4 * mu2+40. * beta2 * mu4+16. * mu6-16. * mu * pow(beta2_mu2,5./2.))/(768. * mu * pow(beta2_mu2,5./2.));\n\n    float F4 = pow(pi_gamma,5.) * (35. * beta8+280. * beta6 * mu2+560. * beta4 * mu4+448. * beta2 * mu6+128. * mu8-128. * mu * pow(beta2_mu2,7./2.))/(30720. * mu * pow(beta2_mu2,7./2.));\n\n    float F5 = pow(pi_gamma,6.) * (63. * beta10+630. * beta8 * mu2+1680. * beta6 * mu4+2016. * beta4 * mu6+1152. * beta2 * mu8+256. * mu10-256. * mu * pow(beta2_mu2,9./2.))/(368640. * mu * pow(beta2_mu2,9./2.));\n\n    float F6 = pow(pi_gamma,7.) * (231. * beta12+2772. * beta10 * mu2+9240. * beta8 * mu4+14784. * beta6 * mu6+12672. * beta4 * mu8+5632. * beta2 * mu10 + 1024. * mu12-1024. * mu * pow(beta2_mu2,11./2.))/(10321920. * mu * pow(beta2_mu2,11./2.));\n    \n    float lambda_ = (F0 + F1 + F2 + F3 + F4 + F5 + F6) / exp_pi_gamma_minus_one;\n    \n    return 1. / (1. + lambda_);\n}\n\nfloat G_our(float tau_0, float beta_sqr, float alpha_sqr, float cos_theta_i, float cos_theta_o)\n{\n    return G1_our(tau_0, beta_sqr, cos_theta_i) * G1_our(tau_0, beta_sqr, cos_theta_o);\n}\n\n\n// Eq. 16\nfloat D_our(float tau_0, float beta_sqr, float cos_theta_m)\n{ \n    float cos2_theta_m = cos_theta_m * cos_theta_m;\n    float tan2_theta_m = (1. - cos2_theta_m) / cos2_theta_m;\n    float tmp = beta_sqr + tan2_theta_m;\n    float num = beta_sqr * log(1. - tau_0) * pow(1. - tau_0,tan2_theta_m / tmp);\n    float denum = tau_0 * PI * tmp * tmp * cos2_theta_m * cos2_theta_m;\n    return -num / denum;\n}\n\n// Eq. 24\nfloat visibility_weight(float tau_0, float beta_sqr, float cos_theta_i, float cos_theta_o)\n{\n    float cos_theta_i_ = clamp(abs(cos_theta_i),0.00001,1.);\n    float cos_theta_o_ = clamp(abs(cos_theta_o),0.00001,1.);\n    return 1. - ((1. - tau_theta_plus(tau_0,beta_sqr, cos_theta_i_)) * (1. - tau_theta_plus(tau_0,beta_sqr, cos_theta_o_)) / (1.- tau_0));\n}\n\n// Eq. 1\nvec3 visibility_blend_our(float tau_0, float beta_sqr, float cos_theta_i, float cos_theta_o, vec3 brdf_s, vec3 brdf_b)\n{\n    return mix(brdf_b, brdf_s, visibility_weight(tau_0, beta_sqr, cos_theta_i, cos_theta_o));\n}\n\n\nvec3 micrograin_conductor_bsdf(\n      float tau_0\n    , float beta_sqr\n    , float alpha_sqr\n    , vec3 R0\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{    \n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_our(tau_0,beta_sqr,cos_theta_h);\n    float G = G_our(tau_0, beta_sqr, alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    //vec3 F = FresnelDielectricConductor(eta,kappa,cos_theta_d);\n    return D*G*F / (4. * cos_theta_i * cos_theta_o);\n}\n\nvec3 micrograin_plastic_bsdf(\n      float tau_0\n    , float beta_sqr\n    , float alpha_sqr\n    , vec3 R0\n    , vec3 kd\n    , float cos_theta_i\n    , float cos_theta_o\n    , float cos_theta_h\n    , float cos_theta_d)\n{\n    vec3 eta = (1. + sqrt(R0))/(1. - sqrt(R0));\n    float D = D_our(tau_0,beta_sqr,cos_theta_h);\n    float G = G_our(tau_0, beta_sqr, alpha_sqr, cos_theta_i,cos_theta_o);\n    vec3 F = FresnelDielectricDielectric(eta,cos_theta_d);\n    vec3 spec = D*G*F / (4. * cos_theta_i * cos_theta_o);\n    \n    vec3 Ti = 1. - FresnelDielectricDielectric(eta,cos_theta_i);\n    vec3 To = 1. - FresnelDielectricDielectric(eta,cos_theta_o);\n    vec3 diff = To * Ti * kd / PI;\n    \n    return spec + diff;\n}\n\n\nvec3 eval(\n      vec3 n\n    , vec3 wi\n    , vec3 wo\n    , float tau_0\n    , float beta\n    , float alpha\n    , vec3 kd_s\n    , vec3 kd_b\n    , vec3 R0_s\n    , vec3 R0_b\n    , bool is_conductor_s\n    , bool is_conductor_b\n    , bool linear_blend)\n{\n    vec3 wh = normalize(wi+wo);\n\tfloat cos_theta_o = clamp(dot(n,wo) ,0.0,1.0);\n\tfloat cos_theta_i = clamp(dot(n,wi) ,0.0,1.0);\n\tfloat cos_theta_h = clamp(dot(n,wh) ,0.0,1.0);\n\tfloat cos_theta_d = clamp(dot(wh,wi),0.0,1.0);\n    beta = clamp(beta,0.001,1.);\n    tau_0 = clamp(tau_0,0.001,0.999);\n    float beta_sqr = beta*beta;\n    float alpha_sqr = alpha*alpha;\n    \n    vec3 brdf_s = is_conductor_s ? \n        micrograin_conductor_bsdf(\n          tau_0\n        , beta_sqr\n        , alpha_sqr\n        , R0_s\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d) \n        :\n        micrograin_plastic_bsdf(\n          tau_0\n        , beta_sqr\n        , alpha_sqr\n        , R0_s\n        , kd_s\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d);\n    \n\n    \n    vec3 brdf_b = is_conductor_b ? \n        ggx_conductor_brdf(\n          alpha_sqr\n        , R0_b\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d)\n        :\n        ggx_plastic_brdf(\n          alpha_sqr\n        , R0_b\n        , kd_b\n        , cos_theta_i\n        , cos_theta_o\n        , cos_theta_h\n        , cos_theta_d);\n    \n    \n    vec3 col = linear_blend ? \n    mix(brdf_b,brdf_s,tau_0)\n    :\n    visibility_blend_our(\n          tau_0\n        , beta_sqr\n        , cos_theta_i\n        , cos_theta_o\n        , brdf_s\n        , brdf_b);\n\n    return col * cos_theta_o;\n    \n    \n    \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n//////////\n// Misc /\n////////\n\n\n// Tileable noise\nvec2 hash( in vec2 p, in float scale, int seed )\n{\n    p = mod(p,scale);\n    p += float(seed) * scale;\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p, in float scale, in int seed)\n{\n    p *= scale;\n    p = mod(p,scale);\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0), scale, seed ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0), scale, seed ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0), scale, seed ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0), scale, seed ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat fbm(in vec2 p, in float scale, in int octaves, in int seed){\n\tfloat amp = 0.5;\n    float sum = 0.;\n\tfloat sum_amp = 0.;\n\tfor (int i = 0; i < octaves; i++)\n\t{\n\t\tsum += noise(p, scale, seed) * amp;\n        sum_amp += amp;\n        amp *= 0.5;\n        scale *= 2.;\n\t}\n\treturn sum/sum_amp;\n}\n\n// Tileable texture\nvec2 hash(vec2 p)\n{\n\treturn fract(sin((p) * mat2(127.1, 311.7, 269.5, 183.3) )*43758.5453);\n}\n\nconst mat2 grid_to_skewed_grid = mat2(1.0, 0.0, -0.57735027, 1.15470054);\n\nvoid triangle_grid(vec2 uv,\n\tout float w1, out float w2, out float w3,\n\tout vec2 vertex1, out vec2 vertex2, out vec2 vertex3)\n{\n\n\tvec2 skewed_coord = grid_to_skewed_grid * uv;\n\n\tvec2 baseId = floor(skewed_coord);\n\tvec3 temp = vec3(fract(skewed_coord), 0);\n\ttemp.z = 1.0 - temp.x - temp.y;\n\tif (temp.z > 0.)\n\t{\n\t\tw1 = temp.z;\n\t\tw2 = temp.y;\n\t\tw3 = temp.x;\n\t\tvertex1 = baseId;\n\t\tvertex2 = baseId + vec2(0, 1.);\n\t\tvertex3 = baseId + vec2(1., 0);\n\t}\n\telse\n\t{\n\t\tw1 = -temp.z;\n\t\tw2 = 1.0 - temp.y;\n\t\tw3 = 1.0 - temp.x;\n\t\tvertex1 = baseId + vec2(1., 1.);\n\t\tvertex2 = baseId + vec2(1., 0);\n\t\tvertex3 = baseId + vec2(0, 1.);\n\t}\n}\n\nvec4 hpn(sampler2D tex, vec2 uv){\n    float w1, w2, w3;\n\tvec2 vertex1, vertex2, vertex3;\n\ttriangle_grid(uv*2., w1, w2, w3, vertex1, vertex2, vertex3);\n    \n    vec2 of1 = hash(vec2(vertex1));\n    vec2 of2 = hash(vec2(vertex2));\n    vec2 of3 = hash(vec2(vertex3));\n    \n\n    mat2 unskew = transpose(inverse(grid_to_skewed_grid));\n    vec2 v1 = vec2(vertex1)*unskew;\n    vec2 v2 = vec2(vertex2)*unskew;\n    vec2 v3 = vec2(vertex3)*unskew;\n    \n    vec2 uv1 = uv - v1;\n\tvec2 uv2 = uv - v2;\n\tvec2 uv3 = uv - v3;\n\n\n    vec2 duvdx = dFdx(uv);\n\tvec2 duvdy = dFdy(uv);\n\n    uv1 -= 0.5 + of1; \n    uv2 -= 0.5 + of2;\n    uv3 -= 0.5 + of3;\n    \n    vec4 E = texture(tex,vec2(0.5),100.);\n    \n    // Fetch Gaussian input\n    vec4 G1,G2,G3;\n    G1 = textureGrad(tex, uv1, duvdx,duvdy) - E;\n    G2 = textureGrad(tex, uv2, duvdx,duvdy) - E;\n    G3 = textureGrad(tex, uv3, duvdx,duvdy) - E;\n\n    \n    // Burley 2019 /////////////////////////\n    #define p(x) pow(w.x,lambda)\n    vec3 w = vec3(w1,w2,w3);\n    float lambda = 1.;\n    float l = p(x)+p(y)+p(z);\n    w = vec3(p(x)/l,p(y)/l,p(z)/l);\n    ////////////////////////////////////////\n\n    w = normalize(w);\n    vec4 G = w.x*G1 + w.y*G2 + w.z*G3 + E;\n    \n    // Time varying pixel color\n    return G;\n\n}\n\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec3 FresnelDielectricConductor(vec3 Eta, vec3 Etak, float CosTheta)\n{  \n   float CosTheta2 = CosTheta * CosTheta;\n   float SinTheta2 = 1. - CosTheta2;\n   vec3 Eta2 = Eta * Eta;\n   vec3 Etak2 = Etak * Etak;\n\n   vec3 t0 = Eta2 - Etak2 - SinTheta2;\n   vec3 a2plusb2 = sqrt(t0 * t0 + 4. * Eta2 * Etak2);\n   vec3 t1 = a2plusb2 + CosTheta2;\n   vec3 a = sqrt(0.5f * (a2plusb2 + t0));\n   vec3 t2 = 2. * a * CosTheta;\n   vec3 Rs = (t1 - t2) / (t1 + t2);\n\n   vec3 t3 = CosTheta2 * a2plusb2 + SinTheta2 * SinTheta2;\n   vec3 t4 = t2 * SinTheta2;   \n   vec3 Rp = Rs * (t3 - t4) / (t3 + t4);\n\n   return 0.5 * (Rp + Rs);\n}\n\n// https://seblagarde.wordpress.com/2013/04/29/memo-on-fresnel-equations/\nvec3 FresnelDielectricDielectric(vec3 Eta, float CosTheta)\n{\n   float SinTheta2 = 1. - CosTheta * CosTheta;\n\n   vec3 t0 = sqrt(1. - (SinTheta2 / (Eta * Eta)));\n   vec3 t1 = Eta * t0;\n   vec3 t2 = Eta * CosTheta;\n\n   vec3 rs = (CosTheta - t1) / (CosTheta + t1);\n   vec3 rp = (t0 - t2) / (t0 + t2);\n\n   return 0.5 * (rs * rs + rp * rp);\n}\n\n\n// https://www.shadertoy.com/view/4sSSW3\nmat3 orthonormal_basis(in vec3 n)\n{\n    vec3 f,r;\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n        float a = 1./(1. + n.z);\n        float b = -n.x*n.y*a;\n        f = normalize(vec3(1. - n.x*n.x*a, b, -n.x));\n        r = normalize(vec3(b, 1. - n.y*n.y*a , -n.y));\n    }\n    return( mat3(f,r,n) );\n}\n\nvec3 normal_mapping(vec2 uv, vec3 n, float scale, sampler2D channel) {\n  vec2 d_step = vec2(5. / 1024.);\n    \n  float height = texture(channel, uv).r;\n    \n  vec2 slope = height - vec2(\n      texture(channel,uv - vec2(d_step.x, 0.)).r, \n      texture(channel,uv - vec2(0., d_step.y)).r\n  );\n    \n  vec3 normal = normalize(vec3(slope * scale / d_step, 1.));\n  \n  return normalize(orthonormal_basis(n) * normal.xyz);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Tileable noise\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(\n          fbm(fragCoord/iResolution.xy,40.,6,0)\n        , fbm(fragCoord/iResolution.xy,40.,6,1)\n        , fbm(fragCoord/iResolution.xy,40.,6,2)\n    );\n    col = col*0.5 + 0.5;\n    fragColor = vec4(col,1);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// camera from  loicvdb's shader : https://www.shadertoy.com/view/flc3Rn\n\n#define FLY_MODE_QWERTY\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#ifdef FLY_MODE_QWERTY\nconst int FORWARD = 87;\nconst int BACKWARD = 83;\nconst int UP = 16;\nconst int DOWN = 17;\nconst int RIGHT = 68;\nconst int LEFT = 65;\n#endif\n\n#ifdef FLY_MODE_AZERTY\nconst int FORWARD = 90;\nconst int BACKWARD = 83;\nconst int UP = 16;\nconst int DOWN = 17;\nconst int RIGHT = 68;\nconst int LEFT = 81;\n#endif\n\nconst int ARROW_LEFT = 37;\nconst int ARROW_UP = 38;\nconst int ARROW_RIGHT = 39;\nconst int ARROW_DOWN = 40;\n\n\nvec3 getVec3(int add) {\n    return vec3(\n        texelFetch(iChannel0, ivec2(add, 0), 0).w,\n        texelFetch(iChannel0, ivec2(add, 1), 0).w,\n        texelFetch(iChannel0, ivec2(add, 3), 0).w\n    );\n}\n\n\nvoid setVec3(vec3 v, int add, inout vec4 o) {\n    ivec2 u = ivec2(gl_FragCoord.xy);\n    if(u == ivec2(add, 0)) o.w = v.x;\n    if(u == ivec2(add, 1)) o.w = v.y;\n    if(u == ivec2(add, 3)) o.w = v.z;\n}\n\n\nvoid setMat3(mat3 m, int add, inout vec4 o) {\n    for(int i = 0; i < 4; i++) {\n        setVec3(m[i], add+i, o);\n    }\n}\n\n\nmat3 getMat3(int address) {\n    return mat3(getVec3(address), getVec3(address+1), getVec3(address+2));\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n\n    o = texelFetch(iChannel0, ivec2(u), 0);\n    \n    setMat3(getMat3(0), 5, o);\n    vec3 p = getVec3(3);\n    setVec3(p, 8, o);\n    \n\n    // == mouse control ====================================\n    \n    vec3 v = iFrame == 0 ? normalize(vec3(1.,-1,0.)) : getVec3(4);\n    const float sensitivity = 2.;\n    if(sign(iMouse.z) == -1. && sign(iMouse.w) == -1.) {\n        if(v.z > 0.) {\n            v.z = -1.;\n            v.xy += (iMouse.xy+iMouse.zw) * sensitivity/iResolution.y;\n        }\n    } else {\n        v.z = 1.;\n    }\n    setVec3(v, 4, o);\n    \n    vec2 rot = v.xy;\n    if(iMouse.z > 0.) {\n        rot += (iMouse.xy-abs(iMouse.zw)) * sensitivity/iResolution.y;\n    }\n    \n    \n    \n    \n    // == rotation matrix =====================================\n    \n    vec2 c = cos(rot);\n    vec2 s = sin(rot);\n    mat3 rx = mat3(1, 0, 0, 0, c.y, -s.y, 0, s.y, c.y);\n    mat3 ry = mat3(c.x, 0, -s.x, 0, 1, 0, s.x, 0, c.x);\n    mat3 cam = ry * rx;\n    \n    // == keyboard control ====================================\n    \n    p = iFrame==0 ? vec3(0.,1.,0.) : p;\n    vec3 m = vec3(0);\n    if(keyClick(FORWARD ) || keyClick(ARROW_UP)) m += cam * vec3(0, 0, 1);\n    if(keyClick(BACKWARD) || keyClick(ARROW_DOWN)) m -= cam * vec3(0, 0, 1);\n    if(keyClick(UP      )) m += vec3(0, 1, 0);\n    if(keyClick(DOWN    )) m -= vec3(0, 1, 0);\n    if(keyClick(RIGHT   ) || keyClick(ARROW_RIGHT)) m += cam * vec3(1, 0, 0);\n    if(keyClick(LEFT    ) || keyClick(ARROW_LEFT)) m -= cam * vec3(1, 0, 0);\n    if(dot(m, m) > 0.) {\n        p += normalize(m)*iTimeDelta*(1.+p.y * sqrt(p.y));\n    }\n    p.y = max(p.y, .001);\n    \n    \n    setMat3(cam, 0, o);\n    setVec3(p, 3, o);\n    \n    vec3 res = getVec3(10);\n    \n    if(res == iResolution) {\n        return;\n    }\n    \n   \n    \n}","name":"Buffer D","description":"","type":"buffer"}]}