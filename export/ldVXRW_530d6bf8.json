{"ver":"0.1","info":{"id":"ldVXRW","date":"1463273980","viewed":474,"name":"Spongebob Squarepants","username":"zackpudil","description":"Inspired by [Inigo's Mike](https://www.shadertoy.com/view/MsXGWr). ","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields","character"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n    return fract(sin(n)*4358.5453);\n}\n\nfloat noise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    \n    f = f*f*(3.0 - 2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    \n    return mix(\n        mix(\n            mix(hash(n + 000.0), hash(n + 001.0), f.x),\n            mix(hash(n + 057.0), hash(n + 058.0), f.x),\n            f.y),\n        mix(\n            mix(hash(n + 113.0), hash(n + 114.0), f.x),\n            mix(hash(n + 170.0), hash(n + 171.0), f.x),\n            f.y),\n        f.z);\n}\n\nvoid rotate(inout vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    \n    p = mat2(c, s, -s, c)*p;\n}\n\nfloat len(vec3 p, float l) {\n    p = pow(abs(p), vec3(l));\n    return pow(p.x + p.y + p.z, 1.0/l);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\nfloat dBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nvec2 dSegment(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return vec2(length(pa - ba*h), h);\n}\n\nvec2 dSegment15(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    \n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    \n    return vec2(len(pa - ba*h, 15.0), h);\n}\n\nvec2 dSpongeBob(vec3 p) {\n    float res = 0.0;\n    // body\n    float b = dBox(p - vec3(0, 0.5, 0), vec3(1.0, 1.5, .5)/2.0) - 0.02;\n    b += 0.02*smoothstep(0.4, 1.0, noise(10.0*p))*smoothstep(0.1, 0.11, p.y);\n    b -= 0.75*smoothstep(0.2, 1.0, p.y)*smoothstep(-0.13, -0.12, -p.y);\n    \n    // belt\n    vec3 q = p;\n    q.y *= 18.0;\n    q.z *= 1.9;\n    float e = len(q + vec3(0, 2.3, 0), 15.0) - 0.54;\n    b = min(b, e);\n    \n    // tie\n    q = p;\n    q.x *= 0.4;\n    vec2 s = dSegment15(q + vec3(0, -0.09, -0.28), vec3(0, -0.23, 0), vec3(0));\n    float r = 0.04 - 0.02*smoothstep(0.5, 0.8, s.y) - 0.04*(1.0 - s.y);\n    if(s.x - r < b) res = 1.0;\n    b = min(b, s.x - r);\n    \n    // collar\n    p.x = -abs(p.x);\n    q = p;\n    s = dSegment15(q + vec3(0, -0.09, -0.25), vec3(0), vec3(-0.15, 0, 0));\n    r = 0.01 + 0.045*s.y*smoothstep(-0.2, -0.0, -q.y);\n    if(s.x - r < b) res = 0.0;\n    b = smin(b, s.x - r, 70.0);\n    \n    // arms\n    q = p;\n    rotate(q.xy, 0.4*q.y);\n    s = dSegment(q + vec3(0.63, -0.3, 0.0), vec3(0., -0.5, 0), vec3(0.05, 0, 0));\n    r = 0.034 + 0.05*smoothstep(0.85, 0.88, s.y) + 0.015*smoothstep(-0.1, 0.0, -s.y);\n    if(s.x - r < b) res = 0.0;\n    b = min(b, s.x - r);\n    \n    // hands\n    q = p;\n    q.z *= 1.9;\n    q += vec3(0.61, 0.26, 0.0);\n    q.x *= 2.7;\n    e = length(q) - 0.08;\n    if(e < b) res = 0.0;\n    b = smin(b, e, 100.0);\n    \n    // fingers\n    q = p;\n    q += vec3(0.61, 0.26, 0.0);\n    q = q.zyx;\n    float f = 100.0;\n    s = dSegment(q, vec3(0, -0.01, 0.04), vec3(0, -0.08, 0.07));\n    r = 0.01;\n    rotate(q.xy, 0.3*smoothstep(0.12, 0.17, -q.y));\n    f = min(f, s.x - r);\n    s = dSegment(q, vec3(0, -0.07, -0.02), vec3(0, -0.16, -0.04));\n    f = min(f, s.x - r);\n    s = dSegment(q, vec3(0, -0.07, -0.0), vec3(0, -0.16, -0.0));\n    f = min(f, s.x - r);\n    s = dSegment(q, vec3(0, -0.07, 0.02), vec3(0, -0.16, 0.04));\n    f = min(f, s.x - r);\n    \n    b = smin(f, b, 60.0);\n    \n    // legs\n    s = dSegment(p + vec3(0.25, 0.3, 0.0), vec3(0), vec3(0, -0.65, 0));\n    r = 0.05;\n    r -= 0.02*smoothstep(0.2, 0.21, s.y);\n    r += 0.015*smoothstep(0.7, 0.715, s.y);\n    if(s.x - r < b) res = 0.0;\n    b = min(b, (s.x) - r); \n    \n    // shoes\n    q = p;\n    q.y *= 1.0 + 0.05*smoothstep(0.05, 0.2, p.z);\n    q.z *= 0.6;\n    e = length(q + vec3(0.25, 0.98, -0.05)) - 0.08;\n    if(s.x - r < b) res = 0.0;\n    b = smin(b, e, 60.0);\n    \n    // nose\n    q = p;\n    rotate(q.zy, -0.25*p.z*p.z);\n    s = dSegment(q + vec3(0.0, -0.6, 0.0), vec3(0), vec3(0.0, 0.0, .6));\n    b = min(b, s.x - 0.035);\n    \n    // eyes\n    q = p;\n    q.y *= 0.75;\n    q.z *= 1.5;\n    q += vec3(0.15, -0.6, -0.3);\n    e = length(q) - 0.2 - 0.02*smoothstep(0.56, 0.58, p.y - 0.39);\n    if(e < b) res = 2.0;\n    b = min(b, e);\n    e = length(q + vec3(0, 0, -0.14)) - 0.07;\n    if(e < b) res = 3.0;\n    b = min(b, e);\n    \n    // mouth\n    q = p;\n    rotate(q.xy, 0.45*q.z);\n    s = dSegment(q + vec3(0, -0.4, -0.27), vec3(-0.25, 0.0, 0.0), vec3(0.2, 0.0, 0.0));\n    r =  0.03 - 0.02*smoothstep(0.0, 0.1, s.y);\n    if(s.x - r < b) res = 1.0;\n    b = min(b, s.x - r);\n    \n    // teeth\n    e = dBox(p + vec3(0.042, -0.36, -0.27), vec3(0.03, 0.05, 0.01));\n    if(e < b) res = 2.0;\n    b = min(b, e);\n    \n    return vec2(b, res); \n}\n\nvec2 map(vec3 p) {\n    vec2 g = vec2(p.y + 1.0, -2.0);\n    vec2 sb = dSpongeBob(p);\n        return g.x < sb.x ? g : sb;\n}\n\nvec2 march(vec3 ro, vec3 rd) {\n    float t = 0.0;\n    float m = -4.0;\n    \n    for(int i = 0; i < 150; i++) {\n        vec2 h = map(ro + rd*t);\n        if(abs(h.x) < 0.0001 || t >= 10.0) break;\n        t += h.x*0.5;\n        m = h.y;\n    }\n    \n    return vec2(t, m);\n}\n\nvec3 normal(vec3 p) {\n    vec2 h = vec2(0.001, 0.0);\n    vec3 n = vec3(\n        map(p + h.xyy).x - map(p - h.xyy).x,\n        map(p + h.yxy).x - map(p - h.yxy).x,\n        map(p + h.yyx).x - map(p - h.yyx).x\n    );\n    return normalize(n);\n}\n\nfloat shadow(vec3 p, vec3 l) {\n    float res = 1.0;\n    float t = 0.002;\n    \n    for(int i = 0; i < 200; i++) {\n        float h = map(p + l*t).x;\n        if(abs(h) < 0.00 || t >= 6.0) break;\n        t += h;\n        res = min(res, 16.0*h/t);\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nfloat ao(vec3 p, vec3 n) {\n    float s = 0.004;\n    float t = s;\n    \n    float o = 0.0;\n    float w = 1.0;\n    \n    for(int i = 0; i < 10; i++) {\n        float h = map(p + n*t).x;\n        \n        o += (t - h)*w;\n        w *= 0.95;\n        \n        t += s;\n    }\n    \n    return 1.0 - clamp(o, 0.0, 1.0);\n}\n\nmat3 camera(vec3 eye, vec3 lat) {\n    vec3 ww = normalize(lat - eye);\n    vec3 vv = normalize(cross(vec3(0, 1, 0), ww));\n    vec3 uu = normalize(cross(ww, vv));\n    \n    return mat3(vv, uu, ww);\n}\n\nvec3 material(vec3 p, float m) {\n    vec3 mat = vec3(2.000,1.938,0.129);\n    \n    if(p.y < -0.86) {\n        mat = vec3(0.2);\n    } else if(p.y < -0.75) {\n        mat = mix(vec3(2.0, 0.0, 0.0), vec3(2.0), 1.0 - smoothstep(-0.79, -0.78, p.y));\n    } else if(p.y >= -0.45 && p.y < -0.15 && abs(p.x) < 0.55) {\n        mat = vec3(1.0, 0.2, 0.0);\n    } else if(p.y >= -0.17 && p.y < -0.095 && abs(p.x) < 0.55) {\n        mat = vec3(0.1);\n        float a = atan(p.z, p.x);\n        a = mod(a, 0.4);\n        mat = mix(mat, vec3(1.0, 0.2, 0.0), smoothstep(0.1, 0.101, a));\n    } else if(p.y >= -0.095 && p.y < 0.12 && abs(p.x) < 0.55) {\n        mat = vec3(2.0);\n        if(m == 1.0) mat = vec3(2.0, 0.0, 0.0);\n    } else if(p.y > 0.3 && p.y < 0.48 && abs(p.x) > 0.5 && abs(p.z) < 0.08) {\n        mat = vec3(2.0);\n    } else if(m == 2.0 && p.y < 0.96) {\n        mat = vec3(2.0);\n    } else if(m == 3.0) {\n        p.x = -abs(p.x) + 0.15;\n        p.y -=  0.8;\n        mat = mix(vec3(0.3, 0.5, 1.0), vec3(0.2), 1.0 - smoothstep(0.0, 0.001, length(p.xy) - 0.02));\n    }\n    \n    return mat;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = -1.0 + 2.0*(fragCoord/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.20, 0.34, 0.70);\n    \n    float an = iTime*0.5;\n    \n    vec3 ro = 2.5*vec3(cos(an), .9/3.0, -sin(-1.0));\n    vec3 rd = camera(ro, vec3(0))*normalize(vec3(uv, 1.97));\n    \n    vec2 i = march(ro, rd);\n    \n    if(i.x < 10.0) {\n        vec3 pos = ro + rd*i.x;\n        vec3 nor = normal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        vec3 sli = normalize(vec3(0.8, 0.7, 0.6));\n        vec3 gli = normalize(vec3(0.0, -0.7, 0.0));\n        vec3 bli = vec3(-sli.x, sli.y, -sli.z);\n\n        float amb = clamp(0.5 + 0.5*nor.y, 0.0, 1.0);\n        float gif = clamp(dot(gli, nor), 0.0, 1.0);\n        float sif = clamp(dot(sli, nor), 0.0, 1.0);\n        float bac = clamp(0.3 + 0.7*dot(bli, nor), 0.0, 1.0);\n        float spe = pow(clamp(dot(sli, ref), 0.0, 1.0), 8.0);\n        float fre = pow(clamp(1.0 + dot(rd, nor), 0.0, 1.0), 2.0);\n\n        float sha = shadow(pos, sli);\n        float occ = ao(pos, nor);\n\n        col  = 0.2*amb*vec3(0.20, 0.34, 0.70);\n        col += 0.3*gif*vec3(1.00, 1.00, 1.00)*sha;\n        col += 0.7*sif*vec3(1.00, 0.97, 0.85)*sha;\n        col += 0.1*bac*vec3(1.00, 0.97, 0.85);\n\n        if(pos.y > -0.99) {\n            col *= material(pos, i.y);\n        } else {\n            col *= vec3(0.8, 0.8, 0.5);\n        }\n\n        col += 0.4*spe*vec3(1.00, 0.97, 0.85)*sif*sha;\n        col += 0.2*fre*vec3(1.00, 1.00, 1.00);\n\n        col *= vec3(occ);\n    }\n    \n    col = pow(col, vec3(.454545));\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}