{"ver":"0.1","info":{"id":"XdScWy","date":"1493492995","viewed":445,"name":"UE4 IBL Tracing","username":"aumfer","description":"Using Epic's UE4 Image Based Lighting shader code to trace some spheres","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["pathtracing","ibl","ue4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// tracing stuff: line ~900 (tweak mainImage NUM_SAMPLES for quality)\n// shading stuff: line ~850 (tweak ImageBasedLightingMIS NumSamples for quality)\n\nconst float M_PI = 3.14159265358979323846;\nconst float M_PHI = 1.6180339887498948482045868343656;\nconst float FLT_EPSILON = 9.99999974737875E-06;\nconst float FLT_MAX = 3.402823466e+38F;\n\nfloat unorm(float v) {\n\treturn v * 0.5 + 0.5;\n}\nvec2 unorm(vec2 v) {\n\treturn v * 0.5 + 0.5;\n}\nvec3 unorm(vec3 v) {\n\treturn v * 0.5 + 0.5;\n}\nfloat snorm(float v) {\n    return v * 2.0 - 1.0;\n}\nvec2 snorm(vec2 v) {\n\treturn v * 2.0 - 1.0;\n}\nvec3 snorm(vec3 v) {\n\treturn v * 2.0 - 1.0;\n}\n\nfloat mincomp(vec2 v) { return min(v.x, v.y); }\nfloat maxcomp(vec2 v) { return max(v.x, v.y); }\nfloat mincomp(vec3 v) { return min(min(v.x, v.y), v.z); }\nfloat maxcomp(vec3 v) { return max(max(v.x, v.y), v.z); }\n\nfloat smin(float a, float b, float k) {\n    // https://iquilezles.org/articles/smin\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\nfloat cubemap_layerface(float layer_orig) {\n\tfloat layer = floor(layer_orig / 6.0);\n\tfloat face = layer_orig - (layer * 6.0);\n\treturn face;\n}\n\nfloat sFract(float x, float sm){ float fx = fract(x); return min(fx, fx*(1. - fx)/fwidth(x)/sm); }\n// Only correct for nonnegative values, but in this example, numbers aren't negative.\nfloat sFloor(float x){ return x - sFract(x, 1.); } \n\nvoid swap(inout float a, inout float b) {\n\tfloat t = a;\n\ta = b;\n\tb = t;\n}\nfloat gamma(float n) {\n\treturn (n * FLT_EPSILON) / (1.0 - n * FLT_EPSILON);\n}\n\n//==========================================================================================\n// indexing\n//==========================================================================================\n\nint index2d(ivec2 p, ivec2 bounds) {\n\tint index = p.x +\n\t\t\t\tp.y * bounds.x;\n\treturn index;\n}\nint index3d(ivec3 p, ivec3 bounds) {\n\tint index = p.x +\n\t\t\t\tp.y * bounds.x +\n\t\t\t\tp.z * bounds.x * bounds.y;\n\treturn index;\n}\nint index4d(ivec4 p, ivec4 bounds) {\n\tint index = p.x +\n\t\t\t\tp.y * bounds.x +\n\t\t\t\tp.z * bounds.x * bounds.y +\n\t\t\t\tp.w * bounds.x * bounds.y * bounds.z;\n\treturn index;\n}\n\n//==========================================================================================\n// hashes\n//==========================================================================================\n\nfloat hash1(vec2 p) {\n\tp = 50.0*fract(p*0.3183099);\n\treturn fract(p.x*p.y*(p.x + p.y));\n}\n\nfloat hash1(float n) {\n\treturn fract(n*17.0*fract(n*0.3183099));\n}\n\nvec2 hash2(float n) { return fract(sin(vec2(n, n + 1.0))*vec2(43758.5453123, 22578.1459123)); }\n\nvec2 hash2(vec2 p) {\n\tconst vec2 k = vec2(0.3183099, 0.3678794);\n\tp = p*k + k.yx;\n\treturn fract(16.0 * k*fract(p.x*p.y*(p.x + p.y)));\n}\n\n//==========================================================================================\n// rng\n//==========================================================================================\n\n// http://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n\tx += (x << 10u);\n\tx ^= (x >> 6u);\n\tx += (x << 3u);\n\tx ^= (x >> 11u);\n\tx += (x << 15u);\n\treturn x;\n}\n// Compound versions of the hashing algorithm I whipped together.\nuint hash(uvec2 v) { return hash(v.x ^ hash(v.y)); }\nuint hash(uvec3 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z)); }\nuint hash(uvec4 v) { return hash(v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w)); }\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct(uint m) {\n\tconst uint ieeeMantissa = 0x007FFFFFu;\t// binary32 mantissa bitmask\n\tconst uint ieeeOne = 0x3F800000u;\t\t// 1.0 in IEEE binary32\n\n\tm &= ieeeMantissa;\t\t\t\t\t\t// Keep only mantissa bits (fractional part)\n\tm |= ieeeOne;\t\t\t\t\t\t\t// Add fractional part to 1.0\n\n\tfloat  f = uintBitsToFloat(m);\t\t\t// Range [1:2]\n\treturn f - 1.0;\t\t\t\t\t\t\t// Range [0:1]\n}\n\n//uniform uvec4 random_seed;\n//uvec4 seed = random_seed;\nuvec4 seed = uvec4(0);\nvoid random_init1ui(uint x) {\n\tseed ^= uvec4(x, ~x, -x, -~x);\n}\nvoid random_init2ui(uvec2 x) {\n\tseed ^= uvec4(x.x, x.y, ~x.x, ~x.y);\n}\nvoid random_init2f(vec2 v) {\n\tuvec2 x = floatBitsToUint(v);\n\tseed ^= uvec4(x.x, x.y, ~x.x, ~x.y);\n}\nfloat random1f() {\n\treturn floatConstruct(hash(seed++));\n}\nvec2 random2f() {\n\treturn vec2(random1f(), random1f());\n}\nvec3 random3f() {\n\treturn vec3(random1f(), random1f(), random1f());\n}\nfloat normal1f() {\n\treturn sqrt(random1f()) * cos(random1f() * M_PI * 2.0);\n}\nvec2 normal2f() {\n\treturn vec2(normal1f(), normal1f());\n}\n\n//==========================================================================================\n// encoding\n//==========================================================================================\n\n// https://www.shadertoy.com/view/4t2XWK\nfloat madfrac(float a, float b) { return a*b - floor(a*b); }\nvec2  madfrac(vec2 a, float b) { return a*b - floor(a*b); }\n\nfloat encode_normal(vec3 p, float n) {\n\tfloat phi = min(atan(p.y, p.x), M_PI), cosTheta = p.z;\n\n\tfloat k = max(2.0, floor(log(n * M_PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta)) / log(M_PHI*M_PHI)));\n\tfloat Fk = pow(M_PHI, k) / sqrt(5.0);\n\n\tvec2 F = vec2(round(Fk), round(Fk * M_PHI));\n\n\tvec2 ka = -2.0*F / n;\n\tvec2 kb = 2.0*M_PI*madfrac(F + 1.0, M_PHI - 1.0) - 2.0*M_PI*(M_PHI - 1.0);\n\tmat2 iB = mat2(ka.y, -ka.x, -kb.y, kb.x) / (ka.y*kb.x - ka.x*kb.y);\n\n\tvec2 c = floor(iB * vec2(phi, cosTheta - (1.0 - 1.0 / n)));\n\tfloat d = 8.0;\n\tfloat j = 0.0;\n\tfor (int s = 0; s<4; s++)\n\t{\n\t\tvec2 uv = vec2(float(s - 2 * (s / 2)), float(s / 2));\n\n\t\tfloat cosTheta = dot(ka, uv + c) + (1.0 - 1.0 / n);\n\n\t\tcosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n\t\tfloat i = floor(n*0.5 - cosTheta*n*0.5);\n\t\tfloat phi = 2.0*M_PI*madfrac(i, M_PHI - 1.0);\n\t\tcosTheta = 1.0 - (2.0*i + 1.0) / n;\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n\t\tvec3 q = vec3(cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n\t\tfloat squaredDistance = dot(q - p, q - p);\n\t\tif (squaredDistance < d)\n\t\t{\n\t\t\td = squaredDistance;\n\t\t\tj = i;\n\t\t}\n\t}\n\treturn j;\n}\n\nvec3 decode_normal(float i, float n) {\n\tfloat phi = 2.0*M_PI*madfrac(i, M_PHI);\n\tfloat zi = 1.0 - (2.0*i + 1.0) / n;\n\tfloat sinTheta = sqrt(1.0 - zi*zi);\n\treturn vec3(cos(phi)*sinTheta, sin(phi)*sinTheta, zi);\n}\n\n//==========================================================================================\n// sampling\n//==========================================================================================\n\nfloat radicalInverse_VdC(uint bits) {\n\tbits = (bits << 16u) | (bits >> 16u);\n\tbits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n\tbits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n\tbits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n\tbits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n\treturn float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley2d(uint i, uint N) {\n\treturn vec2(float(i) / float(N), radicalInverse_VdC(i));\n}\nvec2 hammersley2d(int i, int N) {\n\treturn vec2(float(i) / float(N), radicalInverse_VdC(uint(i)));\n}\n\n// https://www.shadertoy.com/view/MsdGzl\nvec3 cosineDirection(vec2 rnd, vec3 nor) {\n\t// compute basis from normal\n\t// see http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n\t// (link provided by nimitz)\n\tvec3 tc = vec3(1.0 + nor.z - nor.xy*nor.xy, -nor.x*nor.y) / (1.0 + nor.z);\n\tvec3 uu = vec3(tc.x, tc.z, -nor.x);\n\tvec3 vv = vec3(tc.z, tc.y, -nor.y);\n\n\tfloat u = rnd.x;\n\tfloat v = rnd.y;\n\tfloat a = M_PI * 2.0 * v;\n\n\tvec3 d = sqrt(u)*(cos(a)*uu + sin(a)*vv) + sqrt(1.0 - u)*nor;\n\td = normalize(d);\n\treturn d;\n}\n\nvec2 sampleSphericalMap(vec3 v) {\n\tconst vec2 invAtan = vec2(0.1591, 0.3183);\n    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n    uv *= invAtan;\n    uv += 0.5;\n    return uv;\n}\n\n//==========================================================================================\n// distance\n//==========================================================================================\n\nvec2 sdTranslate(vec2 p, vec2 t) {\n\treturn p - t;\n}\n\nfloat sdSmoothMerge(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5*(d2 - d1)/k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0-h);\n}\n\nfloat sdMerge(float d1, float d2) {\n\treturn min(d1, d2);\n}\n\nfloat sdMergeExclude(float d1, float d2) {\n\treturn min(max(-d1, d2), max(-d2, d1));\n}\n\nfloat sdSubstract(float d1, float d2) {\n\treturn max(-d1, d2);\n}\n\nfloat sdIntersect(float d1, float d2) {\n\treturn max(d1, d2);\n}\n\nfloat sdPie(vec2 p, float angle) {\n\tangle = radians(angle) / 2.0;\n\tvec2 n = vec2(cos(angle), sin(angle));\n\treturn abs(p).x * n.x + p.y*n.y;\n}\n\nfloat sdCircle(vec2 p, float radius) {\n\treturn length(p) - radius;\n}\n\n\nfloat sdTriangle(vec2 p, float radius) {\n\treturn max(\tabs(p).x * 0.866025 + \n\t\t\t   \tp.y * 0.5, -p.y) \n\t\t\t\t-radius * 0.5;\n}\n\nfloat sdTriangle(vec2 p, float width, float height) {\n\tvec2 n = normalize(vec2(height, width / 2.0));\n\treturn max(\tabs(p).x*n.x + p.y*n.y - (height*n.y), -p.y);\n}\n\nfloat sdSemiCircle(vec2 p, float radius, float angle, float width) {\n\twidth /= 2.0;\n\tradius -= width;\n\treturn sdSubstract(sdPie(p, angle), \n\t\t\t\t\t abs(sdCircle(p, radius)) - width);\n}\n\nfloat sdBox(vec2 p, vec2 size, float radius) {\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat sdLine(vec2 p, vec2 start, vec2 end, float width) {\n\tvec2 dir = start - end;\n\tfloat lngth = length(dir);\n\tdir /= lngth;\n\tvec2 proj = max(0.0, min(lngth, dot((start - p), dir))) * dir;\n\treturn length( (start - p) - proj ) - (width / 2.0);\n}\n\n//==========================================================================================\n// intersection\n//==========================================================================================\n\nfloat isect_sphere(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h<0.0) {\n\t\treturn -1.0;\n\t}\n\th = sqrt(h);\n\treturn -b - h;\n}\n\nfloat isect_plane(vec3 ro, vec3 rd, vec4 p) {\n\tfloat t = -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n\treturn t;\n}\n\nfloat minT(float a, float b) {\n\tconst float zfar = -1.0;\n\treturn (a<b)? zfar: (b<0.)? (a>0.)? a: zfar: b;\n}\n\n// https://www.shadertoy.com/view/XtGXRz\nfloat isect_aabb(vec3 ro, vec3 rd, vec3 mins, vec3 maxs) {\n\tvec3 t1 = (mins - ro)/rd; //https://www.siggraph.org/education/materials/HyperGraph/raytrace/rtinter3.htm\n\tvec3 t2 = (maxs - ro)/rd;\n\tvec3 tn = min(t1, t2);\n\tvec3 tx = max(t1, t2);\n    float d = minT(mincomp(tx),maxcomp(tn)); //minT calculates the minimum positive, if n/a then returns zfar\n\treturn d;\n}\n\nfloat isect_triangle( vec3 orig\n                       , vec3 dir\n                       , vec3 vert0\n                       , vec3 vert1\n                       , vec3 vert2\n                       , out float u\n                       , out float v\n                       ) {\n    // Fast, Minimum Storage Ray-Triangle Intersection\n    //\n    // Tomas Möller and Ben Trumbore. Fast, minimum storage ray-triangle intersection.\n    // Journal of graphics tools, 2(1):21-28, 1997\n    //\n    // http://www.jcenligne.fr/download/little3d/\n    //     jgt%20Fast,%20Minumum%20Storage%20Ray-Triangle%20Intersection.htm\n\n    const float JGT_RAYTRI_EPSILON = 0.000001;\n\tfloat t;\n\n    vec3 edge1, edge2, tvec, pvec, qvec;\n    float det, inv_det;\n\n    // Find vectors for two edges sharing vert0\n    edge1 = vert1 - vert0;\n    edge2 = vert2 - vert0;\n\n    // Begin calculating determinant - also used to calculate U parameter\n    pvec = cross(dir, edge2);\n\n    // If determinant is near zero, ray lies in plane of triangle\n    det = dot(edge1, pvec);\n\n    if (det > -JGT_RAYTRI_EPSILON && det < JGT_RAYTRI_EPSILON) {\n        return -1.0;\n\t}\n    inv_det = 1.0 / det;\n\n    // Calculate distance from vert0 to ray origin\n    tvec = orig - vert0;\n\n    // Calculate U parameter and test bounds\n    u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return -1.0;\n\t}\n\n    // Prepare to test V parameter\n    qvec = cross(tvec, edge1);\n\n    // Calculate V parameter and test bounds\n    v = dot(dir, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return -1.0;\n\t}\n\n    // Calculate t, ray intersects triangle\n    t = dot(edge2, qvec) * inv_det;\n\n    return t;\n}\n\n//==========================================================================================\n// pbr\n//==========================================================================================\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\n\nvec3 FresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//==========================================================================================\n// common\n// https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Shaders/Common.usf\n//==========================================================================================\n\nfloat ClampedPow(float X, float Y) {\n\treturn pow(max(abs(X),0.000001f),Y);\n}\nfloat Pow5( float x ) {\n\tfloat xx = x*x;\n\treturn xx * xx * x;\n}\n\nfloat Square(float X) {\n\treturn X * X;\n}\nfloat rcp(float X) {\n\treturn 1.0 / X;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec2 saturate(vec2 x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n\nuint bitfieldReverse(uint bits) {\n\tbits = ( bits << 16) | ( bits >> 16);\n\tbits = ( (bits & 0x00ff00ffu) << 8u ) | ( (bits & 0xff00ff00u) >> 8u );\n\tbits = ( (bits & 0x0f0f0f0fu) << 4u ) | ( (bits & 0xf0f0f0f0u) >> 4u );\n\tbits = ( (bits & 0x33333333u) << 2u ) | ( (bits & 0xccccccccu) >> 2u );\n\tbits = ( (bits & 0x55555555u) << 1u ) | ( (bits & 0xaaaaaaaau) >> 1u );\n\treturn bits;\n}\n\n//==========================================================================================\n// monte carlo\n// https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Shaders/MonteCarlo.usf\n//==========================================================================================\n\nconst float PI = M_PI;\n\nvec3 TangentToWorld( vec3 Vec, vec3 TangentZ ) {\n\tvec3 UpVector = abs(TangentZ.z) < 0.999 ? vec3(0,0,1) : vec3(1,0,0);\n\tvec3 TangentX = normalize( cross( UpVector, TangentZ ) );\n\tvec3 TangentY = cross( TangentZ, TangentX );\n\treturn TangentX * Vec.x + TangentY * Vec.y + TangentZ * Vec.z;\n}\n\nvec2 Hammersley( uint Index, uint NumSamples, uvec2 Random ) {\n\tfloat E1 = fract( float(Index) / float(NumSamples) + float( Random.x & 0xffffu ) / float(1<<16) );\n\tfloat E2 = float( bitfieldReverse(Index) ^ Random.y ) * 2.3283064365386963e-10;\n\treturn vec2( E1, E2 );\n}\n\nvec4 UniformSampleSphere( vec2 E ) {\n\tfloat Phi = 2.0 * PI * E.x;\n\tfloat CosTheta = 1.0 - 2.0 * E.y;\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\n\tfloat PDF = 1.0 / (4.0 * PI);\n\n\treturn vec4( H, PDF );\n}\n\nvec4 UniformSampleHemisphere( vec2 E ) {\n\tfloat Phi = 2.0 * PI * E.x;\n\tfloat CosTheta = E.y;\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\n\tfloat PDF = 1.0 / (2.0 * PI);\n\n\treturn vec4( H, PDF );\n}\n\nvec2 UniformSampleDisk(vec2 Random) {\n\tfloat Theta = 2.0f * PI * Random.x;\n\tfloat Radius = sqrt(Random.y);\n\treturn vec2(Radius * cos(Theta), Radius * sin(Theta));\n}\n\nvec4 CosineSampleHemisphere( vec2 E ) {\n\tfloat Phi = 2.0 * PI * E.x;\n\tfloat CosTheta = sqrt( E.y );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\n\tfloat PDF = CosTheta / PI;\n\n\treturn vec4( H, PDF );\n}\n\nvec4 UniformSampleCone( vec2 E, float CosThetaMax ) {\n\tfloat Phi = 2.0 * PI * E.x;\n\tfloat CosTheta = mix( CosThetaMax, 1.0, E.y );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 L;\n\tL.x = SinTheta * cos( Phi );\n\tL.y = SinTheta * sin( Phi );\n\tL.z = CosTheta;\n\n\tfloat PDF = 1.0 / ( 2.0 * PI * (1.0 - CosThetaMax) );\n\n\treturn vec4( L, PDF );\n}\n\nvec4 ImportanceSampleBlinn( vec2 E, float Roughness ) {\n\tfloat m = Roughness * Roughness;\n\tfloat n = 2.0 / (m*m) - 2.0;\n\n\tfloat Phi = 2.0 * PI * E.x;\n\tfloat CosTheta = ClampedPow( E.y, 1.0 / (n + 1.0) );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\n\tfloat D = (n+2.0)/ (2.0*PI) * ClampedPow( CosTheta, n );\n\tfloat PDF = D * CosTheta;\n\n\treturn vec4( H, PDF );\n}\n\nvec4 ImportanceSampleGGX( vec2 E, float Roughness ) {\n\tfloat m = Roughness * Roughness;\n\tfloat m2 = m * m;\n\n\tfloat Phi = 2.0 * PI * E.x;\n\tfloat CosTheta = sqrt( (1.0 - E.y) / ( 1.0 + (m2 - 1.0) * E.y ) );\n\tfloat SinTheta = sqrt( 1.0 - CosTheta * CosTheta );\n\n\tvec3 H;\n\tH.x = SinTheta * cos( Phi );\n\tH.y = SinTheta * sin( Phi );\n\tH.z = CosTheta;\n\t\n\tfloat d = ( CosTheta * m2 - CosTheta ) * CosTheta + 1.0;\n\tfloat D = m2 / ( PI*d*d );\n\tfloat PDF = D * CosTheta;\n\n\treturn vec4( H, PDF );\n}\n\n// Multiple importance sampling power heuristic of two functions with a power of two. \n// [Veach 1997, \"Robust Monte Carlo Methods for Light Transport Simulation\"]\nfloat MISWeight( uint Num, float PDF, uint OtherNum, float OtherPDF ) {\n\tfloat Weight = float(Num) * PDF;\n\tfloat OtherWeight = float(OtherNum) * OtherPDF;\n\treturn Weight * Weight / (Weight * Weight + OtherWeight * OtherWeight);\n}\n\n//==========================================================================================\n// brdf\n// https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Shaders/BRDF.usf\n//==========================================================================================\n\nvec3 Diffuse_Lambert( vec3 DiffuseColor ) {\n\treturn DiffuseColor * (1.0 / PI);\n}\n\n// GGX / Trowbridge-Reitz\n// [Walter et al. 2007, \"Microfacet models for refraction through rough surfaces\"]\nfloat D_GGX( float Roughness, float NoH ) {\n\tfloat a = Roughness * Roughness;\n\tfloat a2 = a * a;\n\tfloat d = ( NoH * a2 - NoH ) * NoH + 1.0;\t// 2 mad\n\treturn a2 / ( PI*d*d );\t\t\t\t\t// 4 mul, 1 rcp\n}\n\nfloat Vis_Implicit() {\n\treturn 0.25;\n}\n\n// [Kelemen 2001, \"A microfacet based coupled specular-matte brdf model with importance sampling\"]\nfloat Vis_Kelemen( float VoH ) {\n\t// constant to prevent NaN\n\treturn rcp( 4.0 * VoH * VoH + 1e-5);\n}\n\n// Tuned to match behavior of Vis_Smith\n// [Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"]\nfloat Vis_Schlick( float Roughness, float NoV, float NoL ) {\n\tfloat k = Square( Roughness ) * 0.5;\n\tfloat Vis_SchlickV = NoV * (1.0 - k) + k;\n\tfloat Vis_SchlickL = NoL * (1.0 - k) + k;\n\treturn 0.25 / ( Vis_SchlickV * Vis_SchlickL );\n}\n\n// Appoximation of joint Smith term for GGX\n// [Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"]\nfloat Vis_SmithJointApprox( float Roughness, float NoV, float NoL ) {\n\tfloat a = Square( Roughness );\n\tfloat Vis_SmithV = NoL * ( NoV * ( 1.0 - a ) + a );\n\tfloat Vis_SmithL = NoV * ( NoL * ( 1.0 - a ) + a );\n\t// Note: will generate NaNs with Roughness = 0.  MinRoughness is used to prevent this\n\treturn 0.5 * rcp( Vis_SmithV + Vis_SmithL );\n}\n\nvec3 F_None( vec3 SpecularColor ) {\n\treturn SpecularColor;\n}\n\n// [Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"]\nvec3 F_Schlick( vec3 SpecularColor, float VoH ) {\n\tfloat Fc = Pow5( 1.0 - VoH );\t\t\t\t\t// 1 sub, 3 mul\n\t//return Fc + (1 - Fc) * SpecularColor;\t\t// 1 add, 3 mad\n\t\n\t// Anything less than 2% is physically impossible and is instead considered to be shadowing\n\treturn saturate( 50.0 * SpecularColor.g ) * Fc + (1.0 - Fc) * SpecularColor;\n\t\n}\n\n//==========================================================================================\n// shading models\n// https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Shaders/ShadingModels.usf\n//==========================================================================================\n\nvec3 StandardShading( vec3 DiffuseColor, vec3 SpecularColor, vec3 LobeRoughness, vec3 LobeEnergy, vec3 L, vec3 V, vec3 N ) {\n\tvec3 H = normalize(V + L);\n\tfloat NoL = max(0.0, dot(N, L) );\n\tfloat NoV = max(0.0, abs( dot(N, V) ) + 1e-5 );\n\tfloat NoH = max(0.0, dot(N, H) );\n\tfloat VoH = max(0.0, dot(V, H) );\n\t\n\t// Generalized microfacet specular\n\tfloat D = D_GGX( LobeRoughness[1], NoH ) * LobeEnergy[1];\n\tfloat Vis = Vis_SmithJointApprox( LobeRoughness[1], NoV, NoL );\n\tvec3 F = F_Schlick( SpecularColor, VoH );\n\n\tvec3 Diffuse = Diffuse_Lambert( DiffuseColor );\n\t//vec3 Diffuse = Diffuse_Burley( DiffuseColor, LobeRoughness[1], NoV, NoL, VoH );\n\t//vec3 Diffuse = Diffuse_OrenNayar( DiffuseColor, LobeRoughness[1], NoV, NoL, VoH );\n\n\treturn Diffuse * LobeEnergy[2] + (D * Vis) * F;\n}\n\nvec3 SimpleShading( vec3 DiffuseColor, vec3 SpecularColor, float Roughness, vec3 L, vec3 V, vec3 N ) {\n\tvec3 H = normalize(V + L);\n\tfloat NoH = saturate( dot(N, H) );\n\t\n\t// Generalized microfacet specular\n\tfloat D = D_GGX( Roughness, NoH );\n\tfloat Vis = Vis_Implicit();\n\tvec3 F = F_None( SpecularColor );\n\n\treturn Diffuse_Lambert( DiffuseColor ) + (D * Vis) * F;\n}\n\nvec3 ClearCoatShading( vec3 DiffuseColor, vec3 SpecularColor, vec3 LobeRoughness, vec3 LobeEnergy, vec3 L, vec3 V, vec3 N ) {\n\tconst float ClearCoat\t\t\t= 1.0;\n\tconst float ClearCoatRoughness\t= 0.1225;\n\tconst float Film = 1.0 * ClearCoat;\n\tconst float MetalSpec = 0.9;\n\n\tvec3 H = normalize(V + L);\n\tfloat NoL = saturate( dot(N, L) );\n\tfloat NoV = saturate( abs( dot(N, V) ) + 1e-5 );\n\tfloat NoH = saturate( dot(N, H) );\n\tfloat VoH = saturate( dot(V, H) );\n\t\n\t// Generalized microfacet specular\n\tfloat D = D_GGX( LobeRoughness[0], NoH ) * LobeEnergy[0];\n\tfloat Vis = Vis_Kelemen( VoH );\n\t\n\t// F_Schlick\n\tfloat F0 = 0.04;\n\tfloat Fc = Pow5( 1.0 - VoH );\n\tfloat F = Fc + (1.0 - Fc) * F0;\n\tF *= ClearCoat;\n\n\tfloat Fr1 = D * Vis * F;\n\n\tfloat LayerAttenuation = (1.0 - F);\n\n\t// Generalized microfacet specular\n\tfloat D2 = D_GGX( LobeRoughness[1], NoH ) * LobeEnergy[1];\n\tfloat Vis2 = Vis_Schlick( LobeRoughness[1], NoV, NoL );\n\t//vec3 F2 = F_Schlick( SpecularColor, VoH );\n\tvec3 F2 = saturate( 50.0 * SpecularColor.g ) * Fc + (1.0 - Fc) * SpecularColor;\n\n\t//vec3 Fr2 = Diffuse_Burley( DiffuseColor, LobeRoughness[1], NoV, NoL, VoH ) * LobeEnergy[2] + (D2 * Vis2) * F2;\n\tvec3 Fr2 = Diffuse_Lambert( DiffuseColor ) * LobeEnergy[2] + (D2 * Vis2) * F2;\n\t\n\treturn Fr1 + Fr2 * LayerAttenuation;\n}\n\n\n//==========================================================================================\n// image based lighting\n// //https://github.com/EpicGames/UnrealEngine/blob/master/Engine/Shaders/PostProcessAmbient.usf\n//==========================================================================================\n\n// using this instead of just sampling the env map\nvec3 sampleWorld(vec3 ro, vec3 rd);\n\nvec3 DiffuseIBL(uvec2 Random, vec3 DiffuseColor, float Roughness, vec3 p, vec3 N, vec3 V) {\n\tvec3 DiffuseLighting = vec3(0);\n\t\n\tfloat NoV = max(0.0, dot( N, V ));\n\n\tconst uint NumSamples = 16u;\n\tfor(uint i = 0u; i < NumSamples; ++i) {\n\t\tvec2 E = Hammersley( i, NumSamples, Random );\n\t\tvec3 L = TangentToWorld( CosineSampleHemisphere( E ).xyz, N );\n\t\tvec3 H = normalize(V + L);\n\n\t\tfloat NoL = max(0.0, dot(N, L));\n\t\tfloat NoH = max(0.0, dot(N, H));\n\t\tfloat VoH = max(0.0, dot(V, H));\n\n\t\tif (NoL > 0.0) {\n\t\t\tvec3 SampleColor = sampleWorld(p, L);\n\n\t\t\tfloat FD90 = ( 0.5 + 2.0 * VoH * VoH ) * Roughness;\n\t\t\t//float FD90 = 0.5 + 2 * VoH * VoH * Roughness;\n\t\t\tfloat FdV = 1.0 + (FD90 - 1.0) * pow( 1.0 - NoV, 5.0 );\n\t\t\tfloat FdL = 1.0 + (FD90 - 1.0) * pow( 1.0 - NoL, 5.0 );\n\n\t\t\t// lambert = DiffuseColor * NoL / PI\n\t\t\t// pdf = NoL / PI\n\t\t\tDiffuseLighting += SampleColor * DiffuseColor * FdV * FdL * ( 1.0 - 0.3333 * Roughness );\n\t\t\t//DiffuseLighting += SampleColor * DiffuseColor;\n\t\t}\n\t}\n\n\treturn DiffuseLighting / float(NumSamples);\n}\n\nvec3 SpecularIBL(uvec2 Random, vec3 SpecularColor, float Roughness, vec3 p, vec3 N, vec3 V) {\n\tvec3 SpecularLighting = vec3(0);\n\n\tconst uint NumSamples = 16u;\n\tfor(uint i = 0u; i < NumSamples; ++i) {\n\t\tvec2 E = Hammersley( i, NumSamples, Random );\n\t\tvec3 H = TangentToWorld( ImportanceSampleGGX( E, Roughness ).xyz, N );\n\t\tvec3 L = 2.0 * dot( V, H ) * H - V;\n\n\t\tfloat NoV = max(0.0, dot(N, V));\n\t\tfloat NoL = max(0.0, dot(N, L));\n\t\tfloat NoH = max(0.0, dot(N, H));\n\t\tfloat VoH = max(0.0, dot(V, H));\n\t\t\n\t\tif( NoL > 0.0 ) {\n\t\t\tvec3 SampleColor = sampleWorld(p, L);\n\n\t\t\tfloat Vis = Vis_SmithJointApprox( Roughness, NoV, NoL );\n\t\t\tfloat Fc = pow( 1.0 - VoH, 5.0 );\n\t\t\tvec3 F = (1.0 - Fc) * SpecularColor + Fc;\n\n\t\t\t// Incident light = SampleColor * NoL\n\t\t\t// Microfacet specular = D*G*F / (4*NoL*NoV) = D*Vis*F\n\t\t\t// pdf = D * NoH / (4 * VoH)\n\t\t\tSpecularLighting += SampleColor * F * ( NoL * Vis * (4.0 * VoH / NoH) );\n\t\t}\n\t}\n\n\treturn SpecularLighting / float(NumSamples);\n}\n\nvec3 ImageBasedLightingMIS(vec3 DiffuseColor, vec3 SpecularColor, float Roughness, vec3 p, vec3 V, vec3 N, uvec2 Random) {\n\tvec3 Lighting = vec3(0);\n\t\n\tconst uint NumSamples = 16u;\n\tfor (uint Set = 0u; Set < 2u; ++Set) {\n\t\tfor (uint i = 0u; i < NumSamples; ++i) {\n\t\t\tvec2 E = Hammersley( i, NumSamples, Random );\n\t\t\t\n\t\t\tvec3 L, H;\n\t\t\tif (Set == 0u) {\n\t\t\t\tL = TangentToWorld(CosineSampleHemisphere(E).xyz, N);\n\t\t\t\tH = normalize(V + L);\n\t\t\t} else if (Set == 1u) {\n\t\t\t\tH = TangentToWorld(ImportanceSampleGGX(E, Roughness).xyz, N);\n\t\t\t\tL = 2.0 * dot( V, H ) * H - V;\n\t\t\t}\n\n\t\t\tfloat NoL = max(0.0, dot(N, L));\n\t\t\tfloat NoH = max(0.0, dot(N, H));\n\t\t\tfloat VoH = max(0.0, dot(V, H));\n\t\t\n\t\t\tif (NoL > 0.0 && VoH > 0.0) {\n\t\t\t\tvec3 SampleColor = sampleWorld(p, L);\n\n\t\t\t\tfloat[] PDF = float[](\n\t\t\t\t\tNoL / PI,\n\t\t\t\t\tD_GGX( Roughness, NoH ) * NoH / (4.0 * VoH)\n\t\t\t\t);\n\n\t\t\t\t// MIS balance heuristic\n\t\t\t\tfloat InvWeight = 0.0;\n\t\t\t\tfor (uint j = 0u; j < 2u; ++j) {\n\t\t\t\t\tInvWeight += PDF[j] * float(NumSamples);\n\t\t\t\t}\n\t\t\t\tfloat Weight = rcp(InvWeight);\n\n\t\t\t\tvec3 Shading = StandardShading(DiffuseColor, SpecularColor, vec3(Roughness), vec3(1), L, V, N);\n\t\t\t\t//vec3 Shading = SimpleShading(DiffuseColor, SpecularColor, Roughness, L, V, N);\n\t\t\t\t//vec3 Shading = ClearCoatShading(DiffuseColor, SpecularColor, vec3(Roughness), vec3(1), L, V, N);\n\t\t\t\n\t\t\t\tLighting += SampleColor * Shading * ( NoL * Weight );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Lighting;\n}\n\n//==========================================================================================\n// drawing\n//==========================================================================================\n\nvec3 background(vec3 rd) {\n    return texture(iChannel0, rd).rgb;\n}\n\nstruct Sphere {\n    vec3 position;\n    float radius;\n    vec3 diffuse;\n    float roughness;\n};\nSphere[] spheres = Sphere[](\n    Sphere( vec3(0), 1.0, vec3(0.2, 0.2, 0.2), 0.0 ),\n    Sphere( vec3(0), 0.5, vec3(0.2, 0.0, 0.0), 1.0 ),\n    Sphere( vec3(0), 0.5, vec3(0.0, 0.2, 0.0), 0.8 ),\n    Sphere( vec3(0), 0.5, vec3(0.0, 0.0, 0.2), 0.6 ),\n    Sphere( vec3(0), 0.5, vec3(0.2, 0.2, 0.0), 0.4 ),\n    Sphere( vec3(0), 0.5, vec3(0.0, 0.2, 0.2), 0.2 ),\n    Sphere( vec3(0), 0.5, vec3(0.2, 0.0, 0.2), 0.0 )\n);\n\nbool trace(vec3 ro, vec3 rd, out float t, out vec3 p, out vec3 N, out vec3 diffuse, out vec3 specular, out float roughness) {\n    t = -1.0;\n    for (int i = 0; i < spheres.length(); ++i) {\n        Sphere s = spheres[i];\n        float d = isect_sphere(ro, rd, vec4(s.position, s.radius));\n        if (d > 0.0 && (t < 0.0 || d < t)) {\n            t = d;\n            p = ro + rd*t;\n            N = normalize(p - s.position);\n            diffuse = s.diffuse;\n            specular = vec3(0.04);\n            roughness = max(0.04, s.roughness);\n        }\n    }\n    return t > 0.0;\n}\n\nvec3 sampleWorld(vec3 ro, vec3 rd) {\n    float t;\n\tvec3 p;\n\tvec3 N;\n\tvec3 diffuse;\n    vec3 specular;\n    float roughness;\n    if (trace(ro, rd, t, p, N, diffuse, specular, roughness)) {\n        return diffuse;\n    }\n    return background(rd);\n}\n\nbool shade(inout vec3 ro, inout vec3 rd, out vec3 color) {\n    float t;\n\tvec3 p;\n\tvec3 N;\n\tvec3 diffuse;\n    vec3 specular;\n    float roughness;\n\tif (trace(ro, rd, t, p, N, diffuse, specular, roughness)) {\n\t\tvec3 V = -rd;\n\t\tcolor = ImageBasedLightingMIS(diffuse, specular, roughness, p, V, N, floatBitsToUint(random2f()));\n\t\treturn true;\n\t}\n\tcolor = background(rd);\n\treturn false;\n}\n\nmat3 camera(in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, -cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    random_init2f(fragCoord);\n    float aspect = iResolution.x / iResolution.y;\n    \n    for (int i = 1; i < spheres.length(); ++i) {\n        float it = iTime + float(i)/2.0;\n        spheres[i].position = 2.0*vec3(sin(it), cos(it), 0.0);\n    }\n    \n\tvec3 total = vec3(0.0);\n    const int NUM_SAMPLES = 4;\n\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n        vec2 p = snorm(fragCoord / iResolution.xy) * vec2(aspect, 1);\n        \n\t\tvec2 off = hammersley2d(i, NUM_SAMPLES);\n\t\t//vec2 off = random2f();\n\t\toff = snorm(off) / iResolution.xy;\n\t\tp += off;\n\n\t\tvec3 ro = vec3(0, 0, 10);\n\t\tvec3 ta = vec3(0, 0, 0);\n\t\tmat3 cam = camera(ro, ta, 0.0);\n\t\tvec3 rd = normalize(cam * vec3(p.xy, -2.5));\n\n\t\t//vec3 color = render(ro, rd);\n        vec3 color;\n        shade(ro, rd, color);\n\t\ttotal += color;\n\t}\n\ttotal /= float(NUM_SAMPLES);\n\n\t// tonemapping\n\ttotal = total / (total + vec3(1.0));\n\t// gamma\n\ttotal = pow(total, vec3(1.0 / 2.2));\n\n\tfragColor = vec4(total, 1);\n}","name":"Image","description":"","type":"image"}]}