{"ver":"0.1","info":{"id":"MllXzH","date":"1452865531","viewed":241,"name":"Atari Days! Intro","username":"frutbunn","description":"Nothing special, a Shadertoy version of a little intro I made in WebGL while playing with the FlodJS audio library. ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define MAX_STEPS           50\n#define MAX_DISTANCE        2.\n#define MARCHING_STEP_INC   .7\n\n#define EPSILON .001\n\n#define COLORS  6\n\n#define PI 3.14159265358979323846\n#define TIMER(sec, min, max) (((mod(iTime, sec) * (max - min)) / sec) + min)\n\nvec4 texSphere(sampler2D t, vec3 p, vec3 n, float scale) {\n    return texture(t, p.yz * scale) * abs (n.x)\n     + texture(t, p.xz * scale) * abs (n.y)\n     + texture(t, p.xy * scale) * abs (n.z);\n}\n\nmat2 mm2(in float a) {\n    float c = cos(a), s = sin(a);\n    \n    return mat2(c, s, -s, c);\n}\n\nfloat smin(in float a, in float b ) {\n    const float k=32.;\n    float res = exp( -k*a ) + exp( -k*b );\n    \n    return -log( res )/k;\n}\n\nfloat map(in vec3 p, out float o[COLORS]) {\n    o[0] = length(p+vec3(.0, -.5, .0))-.1;\n    o[2] = length(p+vec3(.0, .5, .0))-.2;\n    o[3] = length(p+vec3(.5, .0, .0))-.3;\n    o[4] = length(p+vec3(-.5, .0, .0))-.4;\n\n    vec2 t = vec2(.5, .01);\n    o[1] = length(vec2(length(p.xz)-t.x, p.y))-t.y;\n    \n    p.xy *= mm2(PI*.5);\n    o[5] = length(vec2(length(p.xz)-t.x, p.y))-t.y;  \n    \n    return smin(o[0], smin(o[1], smin(o[5], smin(o[2], smin(o[3], o[4])))));\n}\n\nfloat scene(in vec3 p, out float o[COLORS]) {\n    return map(p, o);\n}\n\nfloat scene(in vec3 p) {\n    float o[COLORS]; return map(p, o);\n}\n\nvoid colorize(in float depth, in vec3 color, out float current_depth, out vec3 current_color) {\n    const float max_displace = .25;\n    const float max_color_bleed = .25;\n    \n    float c = smoothstep(depth-max_color_bleed, depth+max_color_bleed, current_depth);\n    float d = smoothstep(depth-max_displace, depth+max_displace, current_depth);\n    \n    current_depth = depth*(d) + current_depth*(1.-d);\n    current_color = (1.-c)*current_color + (c)*color;\n}\n\nfloat rayMarch(in vec3 origin, in vec3 ray, out vec3 col) {\n    float o[COLORS];\n    \n    float t = 0.;\n    for (int i=0; i < MAX_STEPS; i++) {\n        float d = scene(origin + ray*t, o);\n        if (d < EPSILON) break;\n        t += d*MARCHING_STEP_INC;\n        if (t > MAX_DISTANCE) break;\n    }\n    float cd = 1000.;\n\n    colorize(o[0], vec3(0.3, 0., 0.), cd, col ); \n    colorize(o[1], vec3(1., .7, 0.2), cd, col ); \n    colorize(o[2], vec3(0., 0.3, 0.3), cd, col ); \n    colorize(o[3], vec3(0., 0., 0.4), cd, col ); \n    colorize(o[4], vec3(0.3, 0.3, 0.3), cd, col ); \n    colorize(o[5], vec3(1., .7, 0.), cd, col ); \n    \n    return t;\n}\n\nfloat ambientOcculation(in vec3 origin, in vec3 ray) {\n    const float delta = .1;\n    const int samples = 6;\n    float r = 0.;\n    \n    for (int i=1; i <= samples; i++) {\n        float t = delta * float(i);\n        float d = scene(origin + ray*t);\n        float len = abs(t - d);\n        r += len * pow(2.0, -float(i));\n    }\n    \n    return r;\n}\n\nfloat shadowSample(in vec3 origin, in vec3 ray) {\n    float r = 1.;\n    float t = 1.;\n    const int samples = 6;\n    \n    for (int i=0; i <= samples; i++) {\n        float d = scene(origin + ray*t);\n        r = min(r, 2.0*d/t);\n        t += d;\n    }\n    \n    return r;\n}\n\nvec3 getNormal(in vec3 p, in float ep) {\n    float d0 = scene(p);\n    float dX = scene(p - vec3(ep, 0.0, 0.0));\n    float dY = scene(p - vec3(0.0, ep, 0.0));\n    float dZ = scene(p - vec3(0.0, 0.0, ep));\n\n    return normalize(vec3(dX-d0, dY-d0, dZ-d0));\n}\n\nvec3 starfield(in vec2 uv) {\n    vec3 col = vec3(.0, 0., 0.);\n    vec3 ray = vec3(uv.x, uv.y, 1.);\n    \n    vec3 t = -ray/ray.y;\n    vec3 p = t+.5;\n\t\n    for (int i=0; i<2; i++) {\n      float n=fract(sin(dot((vec2(floor(p.xy*30.334))), vec2(12.9898, 78.233)) )*43758.5453);//+.5;\n        float d = 40.*fract(cos(n)-sin(n)-iTime*.1)-p.z;\n      \n        float j = max(0., 1.5-1.*length(fract(p.xy)-.5));\n        \n        vec3 c = max(vec3(0.), vec3(.3-abs(d))*(1./t.z*5.));\n \n        col += (1.-d)*c*j;\n        p += t;\n    }\n\n    return col;\n}\n\nvec3 calcCopper(in vec2 uv, in float f, in float s, in vec3 col) {\n    return  col * pow(smoothstep(0.3, 0., distance(sin(iTime*f*s + uv.x)*.25 + .5, uv.y)), 1.);\n}\n\n#define GAMMA 1.2\n#define CONTRAST 1.05\n#define SATURATION 1.1\n#define BRIGHTNESS 1.2\nvec3 postEffects(in vec3 rgb, in vec2 xy)\n{\n    rgb = pow(rgb, vec3(GAMMA));\n    rgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);    \n\n    return rgb;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) - vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n    vec2 uv2 = uv;\n \n    float o = min(TIMER(10., -PI*2., PI*2.), TIMER(10., PI*2., -PI*2.))+PI;    \n    float o2 = min(TIMER(20., -PI*2., PI*2.), TIMER(20., PI*2., -PI*2.))+PI;\n        \n    float o3 = min(TIMER(5., -PI*2., PI*2.), TIMER(5., PI*2., -PI*2.))+PI;\n    float o3b = min(TIMER(10., -PI*2., PI*2.), TIMER(10., PI*2., -PI*2.))+PI;\n    \n    uv.x+=cos(o)*.5;\n    uv.y+=cos(o2)*.3;\n    uv*= ( (1.5+cos(o3)) + (1.5+cos(o3b)) ) *.5;\n \n    vec3 eye = vec3(0., -0., -1.5);\n    vec3 light = vec3(-1, 1., -2.1);\n    vec3 ray = vec3(uv.x, uv.y, 1.);\n    \n    vec3 scene_color = vec3(0.);\n\n    float rx = TIMER(6., 0., PI*2.);\n    float ry = TIMER(1.5 ,0., PI*2.);\n    float rz = TIMER(5. ,0., PI*2.);\n      \n    eye.zx*=mm2(rx); eye.xy*=mm2(rz); eye.zy*=mm2(ry);\n    light.zx*=mm2(rx); light.xy*=mm2(rz); light.zy*=mm2(ry);\n    ray.zx*=mm2(rx); ray.xy*=mm2(rz); ray.zy*=mm2(ry);\n    \n    float depth = rayMarch(eye, ray, scene_color);   \n    if (depth < MAX_DISTANCE) {\n        vec3 p = (eye + ray*depth);\n        vec3 p_normal = getNormal(p, EPSILON);\n        vec3 light_dir = -normalize(light-p);\n        vec3 reflected_light_dir = reflect(-light_dir, -p_normal);\n        \n        const float j=.003;\n        float shadow = shadowSample(p, -light_dir);\n        float attenuation = 1./(1. + j*pow( length(light-p), 2.0));\n        attenuation -= (1.-shadow)*.6;\n        \n        float ambient = pow(1.-ambientOcculation(p, -ray), 8.);\n        float diffuse = max(0., dot(light_dir, p_normal));\n        float lighting = max(0., (diffuse*.4 + ambient*.6)*attenuation);\n        \n        vec3 reflectioncolor = texture(iChannel1, reflect(ray, p_normal)).rgb;\n        vec3 texcol = texSphere(iChannel0, .1*p, p_normal, 1.0 ).rgb*lighting;\n\n        scene_color = (clamp(mix(scene_color, reflectioncolor, max(0., 1.+(dot(-p_normal, ray)))), 0., 1.)+scene_color*.2)*lighting;\n        scene_color = scene_color + texcol*.4;\n\n        scene_color *= max(dot(-p_normal,-ray),0.0);\n    } else {\n        scene_color = calcCopper(uv+vec2(.5), 2.0, 0.0, vec3(0.0, 0.0, 1.0) );\n        scene_color += calcCopper(uv+vec2(.5), 2.6, 0.2, vec3(0.0, 1.0, 0.0) );\n        scene_color += calcCopper(uv+vec2(.5), 2.9, 0.4, vec3(1.0, 0.0, 0.0) );\n\n        scene_color = scene_color.rrg + scene_color.rgg + scene_color.brb;\n        scene_color*=sin(abs(TIMER(10., -.5, .5)));\n        \n        scene_color = max(starfield(uv2), scene_color);\n    }\n    \n    fragColor = vec4(postEffects(scene_color, uv), 1.);\n}\n","name":"","description":"","type":"image"}]}