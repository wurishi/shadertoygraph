{"ver":"0.1","info":{"id":"fstSDX","date":"1634075189","viewed":97,"name":"Newton's Fractal Test","username":"tague","description":"Based on https://www.youtube.com/watch?v=-RdOwhmqP5s\n\nInteractive: click near any of the roots and drag to move it around!\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fractal","math"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 800\n\n/* Source for product, divide: https://stackoverflow.com/questions/26874957/operations-on-complex-numbers-in-vertex-shader */\n#define product(a, b) vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x)\n#define divide(a, b) vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)))\n\nvec2 poly(vec2 x, vec2[TERMS] s)\n{\n    vec2 a = x - s[0];\n    for (int i = 1; i < TERMS; i++)\n        a = product(a, (x - s[i]));\n    return a;\n}\n\n\nvec2 approach (vec2 x, vec2[TERMS] s)\n{\n    vec2 atCur = poly(x, s);\n    vec2 dist = vec2(0.01);\n    vec2 downDist = poly(x - dist, s);\n    vec2 upDist = poly(x + dist, s);\n    \n    vec2 slope = divide((upDist - downDist), (dist * 2.0));\n    return x - divide(atCur, slope);\n}\n\nvec3 drawPt(vec3 col, vec2 pos, vec2 pt)\n{\n    float d = distance(pos, pt);\n    return d < 3.0 ? vec3(1,1,1) : (d < 5.0 ? vec3(0,0,0) : col);\n}\n\nvec4 colNear(vec4 col, vec2 pos, vec2 pt, vec3 newCol)\n{\n    float d = distance(pos, pt);\n    return d <= col.w ? vec4(newCol, d) : col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n\n        \n    vec2 terms[] = vec2[TERMS](\n        vec2(0,0),\n        vec2(0,0),\n        vec2(0,0),\n        vec2(0,0),\n        vec2(0,0),\n        vec2(0,0),\n        vec2(0,0)\n    );\n    \n    for (int i = 0; i < TERMS; i++) {\n            vec4 val = texelFetch(iChannel0, txPositions[i], 0);\n            val.xy *= iResolution.xy;\n            terms[i] = val.xy; \n    }\n    \n    vec3 colors[] = vec3[TERMS](\n        vec3(0.765,0.765,0.902),\n        vec3(0.82,0.784,0.882),\n        vec3(0.733,0.627,0.792),\n        vec3(0.702,0.439,0.69),\n        vec3(0.529,0.145,0.357),\n        vec3(0.357, 0.145, 0.529),\n        vec3(0.702, 0.784, 0.357)\n    );\n    \n    \n    // Step this coordinate toward a nearby root on the polynomial using Newton's method\n    vec2 pos = uv;\n    for (int i = 0; i < STEPS; i++) {\n        pos = approach(pos, terms);\n    }\n    \n    // Color this coordinate based on the nearest root\n    vec4 cd = vec4(0,0,0,99999999.0);\n    for (int i = 0; i < TERMS; i++)\n        cd = colNear(cd, pos, terms[i], colors[i]);\n    \n    // Draw the roots as circles\n    vec3 col = cd.rgb;\n    for (int i = 0; i < TERMS; i++)\n        col = drawPt(col, uv, terms[i]);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord - 0.5);    \n    vec2 mp = iMouse.xy;\n    \n\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n\n\n    if (iFrame == 0) {\n        vec2 terms[] = vec2[TERMS](\n            vec2(64, 64),\n            vec2(391, 192),\n            vec2(123, 541),\n            vec2(512, 512),\n            vec2(127, 123),\n            vec2(53, 600),\n            vec2(200, 400)\n        );\n        for (int i = 0; i < TERMS; i++) {\n            if (txPositions[i].x == ifc.x && txPositions[i].y == ifc.y)\n                fragColor = vec4(terms[i] / iResolution.xy, 0.0, 1.0);\n        }\n    } else {\n    \n        float minDistance = 999.9f;\n        for (int i = 0; i < TERMS; i++) {\n            vec4 val = texelFetch(iChannel0, txPositions[i], 0);\n            val.xy *= iResolution.xy;\n            float dist = distance(mp, val.xy);\n\n            if (dist < minDistance) {\n                minDistance = dist;\n            }\n        }\n    \n        for (int i = 0; i < TERMS; i++) {\n            vec4 val = texelFetch(iChannel0, txPositions[i], 0);\n            val.xy *= iResolution.xy;\n\n            if (distance(mp, val.xy) < 150.0 && distance(mp, val.xy) <= minDistance && iMouse.z > 0.0) {\n                val.xy = mp;\n            }\n\n            if (txPositions[i].x == ifc.x && txPositions[i].y == ifc.y) {\n                val.xy /= iResolution.xy;\n                fragColor = val;\n            }\n        }\n    }\n    \n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define TERMS 7\n\n\nconst ivec2 txPositions[TERMS] = ivec2[TERMS](\n    ivec2(31, 1),\n    ivec2(31, 3),\n    ivec2(31, 5),\n    ivec2(31, 7),\n    ivec2(31, 9),\n    ivec2(31,11),\n    ivec2(31,13)\n);\n","name":"Common","description":"","type":"common"}]}