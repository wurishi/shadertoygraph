{"ver":"0.1","info":{"id":"3tXfR4","date":"1596079018","viewed":219,"name":"fractal crystal","username":"pixlpa","description":"documenting some render ideas","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["fractal","volume","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//global variables\n\n#define fractal_iterations 7\n#define fractal_elongate 0.21\n#define volume_iterations 7\n#define volume_step 0.05\n#define density 0.45\n#define max_distance 5.\n#define grad_step 0.0001\n#define stop_threshold 0.005\n#define maxiterations 200\n\n#define scale 2.75\n#define offset 0.22\n\nconst vec3 nn1 = normalize(vec3(-0.2,.5,1.));\n\nmat3 objRot = mat3(1.);\nmat3 frcRot = mat3(1.);\n\n//iq distance functions\n\nfloat sdfSphere(vec3 z, vec3 pos, float s){\n\tvec3 p = z-pos;\n\treturn length(p)-s;\n}\n\nfloat sdfOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n//fractal sdf routine\n//based on the ideas and code presented here: http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/\nfloat sdfFractal(vec3 z)\n{\n    float r;\n    int n = 0;\n    while (n < fractal_iterations) {\n\t //rotate and twist\n\t   z = mix(z, z * frcRot,float(n>0));\n\n\t //do the tetrahedron\n\t   vec3 trap = z;\n\t   trap.xy = mix(trap.xy,-trap.yx,step(trap.x+trap.y,0.));\n\t   trap.xz = mix(trap.xz,-trap.zx,step(trap.x+trap.z,0.));\n\t   trap.zy = mix(trap.zy,-trap.yz,step(trap.y+trap.z,0.));\n\n\t //scale and offset\n       z = trap*scale - offset*(scale-1.0);\n\t//folding plane\t   \n\t   z-=2.0 * min(0.0, dot(z, nn1)+fractal_elongate) * (nn1+fractal_elongate);\n       z-=2.0 * min(0.0, dot(z, nn1)+fractal_elongate) * (nn1+fractal_elongate);\n       z-=2.0 * min(0.0, dot(z, nn1)+fractal_elongate) * (nn1+fractal_elongate);\n       n++;\n    }\n\t//apply either sphere or cube SDF\n\treturn sdfSphere(z,vec3(0.),1.)*pow(scale,-float(n));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}           \n\n\nvec2 map(vec3 z){\n\tfloat upscale = 2.8;\n\tvec3 rotated = (z*objRot)/upscale;\n\tfloat d0a = sdfOctahedron(rotated-vec3(0.,0.11,0.),.4);\n\tfloat d0b = sdfSphere(rotated,vec3(0.,-0.2,0.),0.15);\n\tfloat d1 = sdfFractal(rotated);\n\td1 = opSmoothUnion(d1,d0b,0.15);\n\td1 = opSmoothIntersection(d1,d0a, 0.0001);\n\treturn vec2(d1/upscale,1.);\n}\n\nvec3 calcNormal(vec3 pos ){   \n\tvec3 eps = vec3( grad_step, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){    \n\tfloat result = -1.0;\n    float id = -1.;\n    float dist = stop_threshold*2.0;\n\n    for (int i = 0; i < maxiterations; i++) {\n        vec3 p = ro+rd*dist;\n        vec2 res = map(p);\n        if (res.x <= stop_threshold) break;\n        dist += res.x;\n        id = res.y; \n        if (dist >= max_distance) break;\n    }\n\n    result = dist;\n\tid = mix(id,-1.0,float(dist>max_distance));\n    \n    return vec2(result,id);   \n}\n\n//diffuse lighting calc\nvec3 calcLight(vec3 p, vec3 eye2, vec3 N, \n\t\t\t\t\t\t\tvec3 lightPos, vec3 lightIntensity) {\n    vec3 L = normalize(lightPos);\n    vec3 V = normalize(eye2 - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (dotLN);\n    }\n    return lightIntensity * (dotLN);\n}\n\n// procedural volume\n// maps position to color\n// based on https://www.shadertoy.com/view/ttSczc\nvec4 volumeFunc(vec3 p)\n{\n\tp*= objRot;\n\treturn colornoise(p*objRot*2.,iTime*0.2, 0.8);\n}\n\nvec4 volumeMarch(vec3 rayOrigin, vec3 rayDir)\n{\n\tvec4 sum = vec4(0, 0, 0, 0);\n\tvec3 pos = rayOrigin;\n\tvec3 ref = rayDir;\n\tfloat dist = 0.005;\n\tfor(int i=0; i<volume_iterations; i++) {\n\t\tvec3 p = pos + ref * dist;\n\t\tdist += volume_step;\n\t\tvec4 vol = volumeFunc(p); \n\t\tsum.rgb += vol.rgb*vol.a*density;\n\t\tsum.a += vol.a*density;\n\t\tref = mix(ref,refract(rayDir, vol.xyz, 1./1.5),0.95);\n\t}\n\treturn abs(sum);\n}\n\nvec3 render(vec2 res, vec3 ro, vec3 rd) {\n    vec3 color = vec3(0.,0.,0.);\n\tif( res.y > -0.5 ) {\n\t\tvec3 p = ro +rd * res.x;\n\t\tvec3 norm = calcNormal(p);\n        \n        color = calcLight(p, ro, norm, \n\t\t\t\t\t\t\tvec3(1.,1.,0.5), vec3(1.,0.47,0.4)*0.35); \n\t\t\n\t\tvec4 vol = volumeMarch(p, refract(rd,norm,1./1.95));\n\t\tvol.a = pow(vol.a,1.5);\n\t\tvol = clamp(vol,0.,1.);\n\t\tcolor += vol.rgb*vol.a;\n\t}\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-iResolution.xy+2.0*fragCoord)/iResolution.y;\n\tvec3 ro = vec3(0.,0.,2.);\n\tvec3 ta = vec3(0.);\n\t\n\t//initialize globals\n\tobjRot = rot3Dmat(vec3(-0.5,iTime*0.3,0.));\n\tfrcRot = rot3Dmat(vec3(sin(iTime*0.23)*2.5,0.,iTime*0.3));\n\n\tmat3 camMat = calcLookAtMatrix(ro, ta, 0.);\n\tvec3 rd = normalize(camMat * vec3(p.xy,2.0) );\n    vec2 res = calcIntersection(ro, rd);\n\tvec3 color = render(res,ro,rd);\n\n    // Output to screen\n    fragColor = mix(vec4(0.25,0.4,0.45,1.),vec4(color, 1.0),float(res.y>-0.5));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \nmat2 m2 = mat2(0.970,  0.242, -0.242,  0.970);\n\nfloat triNoise3d(in vec3 p)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nvec4 colornoise(vec3 p, float rgboff, float simple){\n\tvec4 color = vec4(0.);\n\tvec3 pos = p+vec3(0.,0.,rgboff);\n\tcolor.r = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(0.,0.,-rgboff);\n\tcolor.g = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(0.,rgboff,0.);\n\tcolor.b = triNoise3d(pos*0.25)*simple+snoise(pos);\n\tpos = p+vec3(2.,0.,-rgboff);\n\tcolor.a = triNoise3d(pos*0.25)*simple+snoise(pos);\n\treturn color;\n}\n\n//Rotation matrix from euler (X/Y/Z) angles. http://glslsandbox.com/e#48064.5\nmat3 rot3Dmat(vec3 angles)\n{\n\tvec3 c = cos(angles);\n\tvec3 s = sin(angles);\n\t\n\tmat3 rotX = mat3( 1.0, 0.0, 0.0, 0.0,c.x,s.x, 0.0,-s.x, c.x);\n\tmat3 rotY = mat3( c.y, 0.0,-s.y, 0.0,1.0,0.0, s.y, 0.0, c.y);\n\tmat3 rotZ = mat3( c.z, s.z, 0.0,-s.z,c.z,0.0, 0.0, 0.0, 1.0);\n\t\n\treturn rotX * rotY * rotZ;\n}\n\n//-----------------------------------------------------------------------------\n//Vectors\n//-----------------------------------------------------------------------------\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}","name":"Common","description":"","type":"common"}]}