{"ver":"0.1","info":{"id":"ltGGRw","date":"1473754412","viewed":1646,"name":"Eikonal equation signed","username":"sebbbi","description":"Distance field generated by repeatedly applying eikonal equation on a grid. Generates signed result.\nEnable #ifdefs to show error (x100) compared to analytical solution.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["sdf","eikonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Enable to show error x100\n//#define VISUALIZE_ERROR\n//#define SHOW_ONLY_ERROR\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float val = texture(iChannel0, uv).r * 0.003;\n    float analytic = texture(iChannel0, uv).a * 0.003;\n    \n    // Colorization\n    vec3 outColor = vec3(val, val, val);\n\n#ifdef VISUALIZE_ERROR\n\t// Green-blue colorization    \n    if (val < 0.0) outColor = vec3(0.0, 1.0 + val * 4.0, 1.0 + val * 4.0);\n    else if (val < 0.5) outColor = vec3(0.0, val * 2.0, 0.0);\n    else if (val < 1.0) outColor = vec3(0.0, 0.0, (val - 0.5) * 2.0);\n    else outColor = vec3(0.0, (val - 1.0) * 2.0, (val - 1.0) * 2.0);\n    \n    // Red channel = error compared to analytical solution\n    outColor.r = abs(val - analytic) * 100.0;\n#else\n    // Full RGB colorization / no error visualization\n    if (val < 0.0) outColor = vec3(1.0 + val * 4.0, 1.0 + val * 4.0, 1.0 + val * 4.0);\n    else if (val < 0.25) outColor = vec3(val * 4.0, 0.0, 0.0);\n    else if (val < 0.5) outColor = vec3(0.0, (val - 0.25) * 4.0, 0.0);\n    else if (val < 0.75) outColor = vec3(0.0, 0.0, (val - 0.5) * 4.0);\n    else if (val < 1.0) outColor = vec3((val - 0.75) * 4.0, (val - 0.75) * 4.0, 0.0);\n    else outColor = vec3((val - 1.0) * 2.0, (val - 1.0) * 2.0, (val - 1.0) * 2.0);\n#endif\n    \n#ifdef SHOW_ONLY_ERROR\n    outColor.rgb *= vec3(1.0, 0.0, 0.0);\n#endif\n        \n    fragColor.rgb = outColor;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define START_FROM_ANALYTICAL_RESULT\n\nconst float seedRadius = 1.5;\t\t\t\t// sqrt(2) round up\nconst float maxValue = 1024.0 * 16.0;\n\nconst vec2 point0 = vec2(300.5, 30.5);\t\t// pixel center\nconst vec2 point1 = vec2(110.7, 430.2);\nconst vec2 point2 = vec2(200.3, 349.6);\nconst vec2 point3 = vec2(30.0, 123.0);\t\t// between pixels\n\nconst vec2 circle = vec2(732.4, 534.1);\nconst float circleRad = 129.3;\n\nfloat distFunc(vec2 p)\n{\n    float d = distance(point0, p);\n    d = min(d, distance(point1, p));\n    d = min(d, distance(point2, p));\n    d = min(d, distance(point3, p));\n    d = min(d, distance(circle, p) - circleRad);\t\t// signed circle\n    return d;\n}\n\nfloat absMin(float a, float b)\n{\n    return abs(a) < abs(b) ? a : b;\n}\n\nfloat negSign(float v)\n{\n    return v < 0.0 ? -1.0 : 1.0;\n}\n\n// https://en.wikipedia.org/wiki/Eikonal_equation\nfloat eikonal1d(float h, float v, float g)\n{\n    float hv = absMin(h, v);\n\treturn hv + g * negSign(hv);\n}\n\nfloat eikonal2d(float h, float v, float g)\n{\n    float hv = h + v;\n    float d = hv*hv - 2.0 * (h*h + v*v - g*g);\n    if (d < g*g) return maxValue;\n   \treturn 0.5 * (hv + sqrt(d) * negSign(hv));\n}\n\nfloat neighborMin(vec2 coord, vec2 delta)\n{\n    float a = texture(iChannel0, coord + delta).r;\n    float b = texture(iChannel0, coord - delta).r;\n    return absMin(a, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int frame = iFrame;\n    vec2 pixel = fragCoord;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float distAnalytical = distFunc(pixel);\n    \n    float dist = 0.0;\n    if (frame == 0)\n    {\n        dist = distAnalytical;\n   \n        // Clamp non-seed values to max\n#ifndef START_FROM_ANALYTICAL_RESULT\n        if (abs(dist) > seedRadius) dist = maxValue;\n#endif\n    }\n    else\n    {    \n        float xd = 1.0 / iResolution.x;\n        float yd = 1.0 / iResolution.y;\n\n        float h = neighborMin(uv, vec2(xd, 0.0));\n        float v = neighborMin(uv, vec2(0.0, yd));\n        \n        float cur = texture(iChannel0, uv).r;\n        \n        float e1 = eikonal1d(h, v, 1.0);\n        float e2 = eikonal2d(h, v, 1.0);\n        float new = absMin(e1, e2);\n        \n        dist = absMin(new, cur);\n    }\n    \n    fragColor = vec4(dist, dist, dist, distAnalytical);\n}\n\n","name":"Buf A","description":"","type":"buffer"}]}