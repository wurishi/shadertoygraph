{"ver":"0.1","info":{"id":"3lSGRR","date":"1558166707","viewed":83,"name":"Simple Lit Spheres","username":"nordaj","description":"Just learning","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 512\n#define MAX_DIST 256.\n#define EPSILON .001\n\nfloat sdSphere(vec3 point, vec3 sPos, float sRad)\n{\n    return length(sPos - point) - sRad;\n}\n\nfloat dFloor(vec3 point, float fPosY)\n{\n    return abs(point.y - fPosY);\n}\n\nfloat sdScene(vec3 point)\n{\n    float d;\n    d = \tsdSphere(point, vec3(0, 1, 2), 1.);\n    d = min(sdSphere(point, vec3(1, 2, 0), .5), d);\n    d = min(dFloor(point, 0.), d);\n    return d;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    vec3 point = rayOrigin;\n    float sceneDist;\n    float rayDist;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        sceneDist = sdScene(point);\n        \n        rayDist += sceneDist;\n        point += rayDir * sceneDist;\n        \n        if (sceneDist <= EPSILON || rayDist >= MAX_DIST)\n            break;\n    }\n    return rayDist;\n}\n\nvec3 CalcNormal(vec3 point)\n{\n    float dist = sdScene(point);\n    \n    //epsilon just needs to be smaller than one used to march\n    return normalize(dist - vec3(\n    \tsdScene(point - vec3(EPSILON / 2., 0, 0)),\n        sdScene(point - vec3(0, EPSILON / 2., 0)),\n\t\tsdScene(point - vec3(0, 0, EPSILON / 2.))\n    ));\n}\n\nfloat CalcLight(vec3 point)\n{\n    //Simple directinal light\n    vec3 lightDir = -normalize(vec3(-1, -1, .5));\n    float sunSize = 1.;\n    \n    //Calculate simple diffuse\n    vec3 normal = CalcNormal(point);\n    float diffuse = clamp(dot(lightDir, normal), 0., 1.);\n    \n    //Hard shadows\n    float d = RayMarch(point + (normal * EPSILON * 2.), lightDir);\n    if (d < MAX_DIST)\n        diffuse = 0.;\n\n    return clamp(diffuse, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get coords\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    //Simple camera\n    //vec3 rayOrigin = vec3(sin(iTime) * 5., 1, cos(iTime) * 5.);\n    vec3 rayOrigin = vec3(0, 1, -4);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    //Ray march\n    float dist = RayMarch(rayOrigin, rayDirection);\n    \n    //Shading and background\n    vec3 col = vec3(CalcLight(rayOrigin + (rayDirection * dist)));\n    if (dist >= MAX_DIST) col = vec3(0, 0, 0);\n    \n    //Output\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}