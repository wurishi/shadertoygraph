{"ver":"0.1","info":{"id":"XdsyWf","date":"1490366846","viewed":376,"name":"PBRT Cook-Torrance","username":"AngryBaguette","description":"WIP","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","signeddistancefield","brdf","pbrt"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cook-Torrance implementation and Schilck/Beckmann/Smith approximation\n//\n// References:\n// Mathematics for 3d Game Programming & Computer Graphics (second edition)\n// http://simonstechblog.blogspot.fr/2011/12/microfacet-brdf.html\n// http://graphicrants.blogspot.fr/2013/08/specular-brdf-reference.html\n// http://renderwonk.com/publications/s2010-shading-course/gotanda/course_note_practical_implementation_at_triace.pdf\n// https://de45xmedrsdbp.cloudfront.net/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n//\n// Distance function\n// https://iquilezles.org/articles/distfunctions\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\nconst float GRAD_STEP = 0.1;\nconst float PI_4 = 0.78539816339744;\nconst float PI_2 = 1.57079632679489;\nconst float PI = 3.14159265358979;\nconst float PI2 = 6.28318530717958;\n\n// sqrt(2/PI)\nconst float GSchilkFactor = 0.79788456080286;\n\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct MaterialPhong\n{\n    vec3 Ka;\n    vec3 Kd;\n    vec3 Ks;\n    float e;\n};\n  \n// For typical dielectric materials, n is between 1.3 and 1.7    \nstruct MaterialPBR\n{\n    vec3 Kd;\n    vec3 Ks;\n    float m; \t// roughness 0.0 - 1.0\n    float n;\t// reflectance 1.0 20.0\n};\n\nstruct Light\n{\n    vec3 P;\t\t// pos\n    vec3 Kd;\t// diff\n    vec3 Ks;\t// spec\n    float I;\t// intensity\n};\n    \n// Union\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// Substraction\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// Intersection\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// Twist operator\nvec3 opTwist( vec3 p, float sa )\n{\n    float c = cos(sa*p.y);\n    float s = sin(sa*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n// Box\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// Sphere\nfloat sdSphere( vec3 p, float r )\n{\n     return length(p)-r;\n}\n\nfloat sdCircle(vec2 uv, vec2 center, float r)\n{\n    vec2 c = (uv - center);\n    return 1.0-clamp(dot(c,c)/r,0.0,1.0);\n}\n    \n// Rotation matrix from euler angle (radian)\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\n\n// The scene\nfloat sdScene(vec3 p)\n{     \n    // twist\n\t//p = fromEuler( vec3(0.0,0.0,p.y) ) * p;\n    p = opTwist(p, 0.5);\n    \n    //return sdSphere(p,1.0);\n    //return sdBox(p,vec3(0.75,0.75,0.5));\n    //return opS( sdSphere(p,1.0), sdBox(p,vec3(0.75,0.75,0.5)) );\n    //return opS( sdBox(p,vec3(0.8,0.8,0.5)), sdSphere(p,1.0) );\n    return opU( sdBox(p,vec3(2.0,2.0,2.0)), sdSphere(p,2.7) );\n}\n\n// Compute through gradient\nvec3 sdSceneNormal(vec3 p) \n{\n    return normalize(vec3(\n        sdScene(vec3(p.x + GRAD_STEP, p.y, p.z)) - sdScene(vec3(p.x - GRAD_STEP, p.y, p.z)),\n        sdScene(vec3(p.x, p.y + GRAD_STEP, p.z)) - sdScene(vec3(p.x, p.y - GRAD_STEP, p.z)),\n        sdScene(vec3(p.x, p.y, p.z  + GRAD_STEP)) - sdScene(vec3(p.x, p.y, p.z - GRAD_STEP))\n    ));\n}\n\n// Ray marching algorithm\nfloat sdRayMarching(Ray ray, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sdScene(ray.origin + depth * ray.direction);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n// Compute ray\nRay sdRay(vec3 origin, vec2 frag, vec2 res, float fov)\n{\n    Ray ray;\n    ray.origin = origin;\n    vec2 xy = frag - res / 2.0;\n    float z = res.y / tan(fov / 2.0);\n    ray.direction = normalize(vec3(xy, -z));\n    \n    return ray;\n}\n\n\n// Ka,Kd,Ks : Ambient/Diffuse/Specular\n// Ki : intensity\n// e : Specular exponent\n//\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\nvec3 Phong(vec3 Ka, vec3 Kd, vec3 Ks, float Ki, float e, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 color = Ka;\n    vec3 L = normalize(LP-P);\n    vec3 V = normalize(E-P);\n    vec3 R = reflect(-L,N);\n    //vec3 H = normalize(V + R);\n    \n    float NDotL = dot(N,L);\n    if(NDotL < 0.0)\n    {\n        return color;\n    }\n    \n    // Diffuse\n    color += NDotL * Kd;\n    \n    // Specular or NDotH\n    float NDotR = max(0.0, dot(V,R));\n    color += pow(NDotR, e) * Ks;\n    \n    return color;\n}\n\n// Fresnel term Cook-Torrance\nfloat FCook(float LDotH, float n)\n{\n    float gmLdotH = (n-LDotH);\n    float gpLdotH = (n+LDotH);\n    float a = (LDotH * gpLdotH - 1.0);\n    float b = (LDotH * gmLdotH + 1.0);\n    float ab = a / b;\n    ab *= ab;\n    return 0.5 * (gmLdotH*gmLdotH) / (gpLdotH*gpLdotH) * ( ab+1.0 );\n}\n\n// Fresnel term Schilk approximation\nfloat FSchilck(float LDotH, float n)\n{\n    float f0 = (1.0-n)/(1.0+n);\n    f0 *= f0;     \n    return f0 + (1.0 - f0) * pow(1.0-LDotH,5.0);\n}\n\n// Cook-Torrance distribution\n// m : roughness\n// ref : Book\nfloat DCook(float NDotH, float m)\n{\n    float NDotH2 = NDotH * NDotH;\n    float NDotH2m = NDotH2 * m * m;\n    return exp((NDotH2 - 1.0) / NDotH2m) / ( 4.0 * NDotH2 * NDotH2m);\n}\n\n// Blinn distribution\nfloat DBlinn(float NDotH, float m)\n{\n    // Blinn distribution\n    float shininess = 2.0 / ( m * m ) - 2.0;\n    return ( shininess + 2.0 ) / 2.0 * pow( NDotH, shininess );\n}\n\n// Beckmann distribution (isotropic)\n// m : roughness\n// ref : http://simonstechblog.blogspot.fr/2011/12/microfacet-brdf.html\nfloat DBeck(float NDotH, float m)\n{\n    float NDotH2 = NDotH * NDotH;\n    float NDotH2m = NDotH2 * m * m;\n    return exp((NDotH2 - 1.0) / NDotH2m) / (PI * NDotH2 * NDotH2m);\n}\n\n// GGX / Trowbridge-Reitz (isotropic)\n// [Walter et al. 2007, \"Microfacet models for refraction through rough surfaces\"]\nfloat DGGX(float NDotH, float m)\n{\n   \tfloat m2 = m * m;\n\tfloat d = ( NDotH * m2 - NDotH ) * NDotH + 1.0;\n\treturn m2 / ( PI*d*d );\n}\n\n// Geometric term Smith using Schlick approximation\nfloat GSmith(float LDotH, float m)\n{\n    float k = m*GSchilkFactor;\n    float f = LDotH / (LDotH*(1.0-k)+k);\n    return f*f;\n}\n    \n// Geometry term is used for describing how much the microfacet is blocked by other microfacet\nfloat GCook(float NDotH, float NDotV, float LDotH, float NDotL)\n{\n    float a = 2.0 * NDotH / LDotH;\n    return min(1.0, min(NDotV,NDotL)*a);  \n}\n\n// GImplicit\n// It is called implicit because when it is used, the microfacet BRDF will only depends on Fresnel equation and distribution function\nfloat GImplicit(float NDotV, float NDotL)\n{\n\treturn NDotL * NDotV;\n}\n\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\nvec3 CookTorrance(MaterialPBR material, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 L = normalize(LP-P);\n    float NDotL = dot(N,L);\n    if(NDotL <= 0.0)\n    {\n        return vec3(0.0,0.0,0.0);\n    }\n    \n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n        \n    float NDotV = min(dot(N,V) + 1e5,1.0);\n    float NDotH = dot(N,H);\n    float LDotH = dot(L,H); // == dot(V,H)\n    \n    \n    // Compute Fresnel factor\n    float Fs = FCook(LDotH, material.n);\n    float Fd = FCook(NDotL, material.n);\n    //float Fd = FSchilck(LDotH, material.n);\n    \n    // Compute Distribution Factor\n    //float D = DCook(NDotH, material.m);\n    //float D = DBeck(NDotH, material.m);\n    float D = DGGX(NDotH, material.m);\n    \n    // Compute Geometrical Factor\n    //float G = GImplicit(NDotV,NDotL);\n    //float G = GCook(NDotH, NDotV, LDotH, NDotL);\n    float G = GSmith(LDotH,material.m);\n    \n    vec3 Spec = material.Ks * Fs * D * G / ( PI * NDotV * NDotL); \n    vec3 Diff = material.Kd * (1.0 - Fd) ;\n    return (Spec + Diff) * vec3(1.0) * NDotL;\n}\n\n\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\nvec3 BRDF2(MaterialPBR material, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 L = normalize(LP-P);\n    float NDotL = dot(N,L);\n    if(NDotL <= 0.0)\n    {\n        return vec3(0.0,0.0,0.0);\n    }\n    \n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n        \n    float NDotV = min(dot(N,V) + 1e5,1.0);\n    float NDotH = dot(N,H);\n    float LDotH = dot(L,H); // == dot(V,H)\n    \n    // Compute Distribution Factor\n    //float D = DCook(NDotH, material.m);\n    //float D = DBeck(NDotH, material.m);\n    float D = DGGX(NDotH, material.m);\n    \n    // Compute Geometrical Factor\n    //float G = GImplicit(NDotV,NDotL);\n    //float G = GCook(NDotH, NDotV, LDotH, NDotL);\n    float G = GSmith(LDotH,material.m);\n    \n    // Compute Fresnel factor\n    // Smith approx\n    vec3 Fs = material.Ks * (1.0 - material.Ks) * pow(1.0 - LDotH, 5.0);\n    vec3 Fd = material.Ks * (1.0 - material.Ks) * pow(1.0 - NDotL, 5.0);    \n    \n\tvec3 Spec = Fs * D * G / ( NDotV * NDotL * PI );\n\tvec3 Diff = material.Kd * ( 1.0 - Fd );\n    return (Spec + Diff) * vec3(1.0) * NDotL;\n}\n\n// Unreal fashion Fresnel term\n// E : Eye position\n// P : Pixel position\n// N : Normal\n// LP : Light Position\n// TriAce : http://renderwonk.com/publications/s2010-shading-course/gotanda/course_note_practical_implementation_at_triace.pdf\nvec3 BRDF3(MaterialPBR material, vec3 E, vec3 P, vec3 N, vec3 LP)\n{\n    vec3 L = normalize(LP-P);\n    float NDotL = dot(N,L);\n    if(NDotL <= 0.0)\n    {\n        return vec3(0.0,0.0,0.0);\n    }\n    \n    vec3 V = normalize(E-P);\n    vec3 H = normalize(L+V);\n        \n    float NDotV = min(dot(N,V) + 1e5,1.0);\n    float NDotH = dot(N,H);\n    float LDotH = dot(L,H); // == dot(V,H)\n    \n    // Compute Distribution Factor\n    //float D = DCook(NDotH, material.m);\n    //float D = DBeck(NDotH, material.m);\n    float D = DGGX(NDotH, material.m);\n    \n    // Compute Geometrical Factor\n    //float G = GImplicit(NDotV,NDotL);\n    //float G = GCook(NDotH, NDotV, LDotH, NDotL);\n    float G = GSmith(LDotH,material.m);\n    \n    // Compute Fresnel factor\n    // Smith approx\n    vec3 Fs = material.Ks * (1.0 - material.Ks) * pow(1.0 - LDotH, 5.0);\n    vec3 Fd = material.Ks * (1.0 - material.Ks) * pow(1.0 - NDotL, 5.0);    \n    \n\tvec3 Spec = Fs * D * G / ( NDotV * NDotL * PI );\n\tvec3 Diff = material.Kd * ( 1.0 - Fd );\n    return (Spec + Diff) * vec3(1.0) * NDotL;\n}\n                                          \nvec3 Light1(vec3 E, vec3 P, vec3 N)\n{\n    // Light position\n    vec3 LP = vec3(0.0, 0.0, 6.0);\n    \n    mat3 rot = fromEuler( vec3(0.0, iTime*0.5, iTime*0.5) );\n    LP = rot * LP;\n    \n    \n\n        // Material\n    MaterialPBR material;\n    material.Kd = vec3(1.0,0.71,0.29);\n    material.Ks = vec3(1.0,1.0,1.0);\n    material.m = 0.03;\n    material.n = 1.0;\n    \n    //return Phong(vec3(0.0), material.Kd, material.Ks, 1.0, 64.0, E, P, N, LP);\n    \n    return CookTorrance( material, E, P, N, LP);\n    //return BRDF2( material, E, P, N, LP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec3 E = vec3(0.0, 0.0, 15.0);\n    Ray ray = sdRay(E, fragCoord.xy, iResolution.xy, PI_4);\n    \n    //mat3 rot = fromEuler( vec3(0.0, iTime, iTime) );\n    //ray.origin = rot * ray.origin;\n    //ray.direction = rot * ray.direction;\n    \n        \n    vec3 color = vec3(0.0);\n    float d = sdRayMarching( ray, MIN_DIST, MAX_DIST);\n    if(d < MAX_DIST)\n    {\n        vec3 P = ray.origin + ray.direction * d;\n        vec3 N = sdSceneNormal(P);\n        \n        // Apply Light\n        color += Light1(E,P,N);\n    }\n    else\n    {\n        // No intersection\n        color = vec3(0.3,0.3,0.3);\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}