{"ver":"0.1","info":{"id":"fdtyR7","date":"1653261261","viewed":100,"name":"hex Hoops light mode","username":"HaleyHalcyon","description":"r","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["r"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TURN 6.283185\n// rotation matrix. idk why it works. thanks fabriceneyret!\n#define rot(a) mat2( cos( a + vec4(0,33,11,0) ) )\n\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n#define COLOR_SMOOTHING 0.1\nvec3 color(float x) {\n    float factor = mod(x, 4.);\n    float f0 = smoothstep(0., 0. + COLOR_SMOOTHING, factor);\n    float f1 = smoothstep(1., 1. + COLOR_SMOOTHING, factor);\n    float f2 = smoothstep(2., 2. + COLOR_SMOOTHING, factor);\n    float f3 = smoothstep(3., 3. + COLOR_SMOOTHING, factor);\n    return (\n        HEX(0x009BE8) * (f0 - f1) +\n        HEX(0xEB0072) * (f1 - f2) +\n        HEX(0xfff100) * (f2 - f3) +\n        HEX(0x010a31) * (f3 - f0 + 1.)\n    );\n}\n\n#define SQRT3 (1.7320508)\nfloat hex(vec2 uv) {\n    uv = abs(uv);\n    return max(\n        (uv.x + uv.y * SQRT3) / 2.,\n        uv.x\n    );\n}\n\nfloat zigzag(float x) {\n    return 1. - abs(1. - 2. * fract(x));\n}\n\nfloat fluct(float x) {\nfloat x2 = x*x;\n    return -0.6 * x2 * x2\n    + 2.4 * x2 * x\n    -2.3 * x2\n    + 0.1 * x;\n}\n\nfloat fxor(float a, float b) {\n    return a + b - 2. * a * b;\n}\n\n#define LAYERSPERLOOP 4.\n#define LAYERS 24.\n#define LAYERFADE 2.\n#define LAYERSCALE 3.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 2.);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / length(iResolution.xy);\n    \n    const vec3 bg0 = HEX(0xC4D7F0);\n    const vec3 bg1 = HEX(0xFFFFFF);\n    float r = -0.5 / (length(uv));\n    float aaR = min(0.5, fwidth(r) * 6.);\n    float zigR = smoothstep(\n        -aaR, aaR, zigzag(4. * r - 2.5 * t) - 0.5\n    );\n    float theta = atan(uv.y, uv.x) * 24. / TURN;\n    float aaTheta = min(fwidth(atan(uv.y, uv.x)), fwidth(atan(uv.x, uv.y))) * 6.;\n    float zigTheta = smoothstep(\n        -aaTheta, aaTheta, zigzag(theta + 0.5 * t) - 0.5\n    );\n    vec3 bg = mix(bg0, bg1,\n        zigR + zigTheta - 2. * zigR * zigTheta\n    );\n    vec3 col = bg;\n    \n    for (float i = 0.; i < LAYERS; i++) {\n        float z = LAYERS - (i + t * LAYERSPERLOOP);\n        float layerDark = clamp(\n            (i + (t - 1.) * LAYERSPERLOOP) * LAYERFADE,\n            0., 1.\n        );\n        float layerAlpha = clamp(z * 5., 0., 1.); \n        vec2 uvScale = (uv\n        * max(0.03, z * LAYERSCALE)\n        + fluct(z * 0.35) * vec2(0., -1.))\n        * rot(z * TURN / -6. / LAYERSPERLOOP)\n        ;\n        float hex = hex(uvScale);\n        float aa = fwidth(hex) * 1.3;\n        col = mix(\n            col,\n            mix(\n                bg,\n                mix(\n                    color(-i),\n                    vec3(0),\n                    fxor(\n                        step(0.5, zigzag(uv.y * z * 12.0 + z * 0.2)),\n                        step(0.5, zigzag(uv.x * z * 12.0))\n                    )\n                ),\n                layerDark\n            ),\n            smoothstep(\n                0., aa,\n                0.12 - abs(0.5 - hex)\n            ) * layerAlpha\n        );\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}