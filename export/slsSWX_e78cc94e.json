{"ver":"0.1","info":{"id":"slsSWX","date":"1628022655","viewed":171,"name":"Smooth Mandelbrot Attempt","username":"incription","description":"A prototype of the true fractional iteration of the mandelbrot f^s(x) = x^2 + c can be found in common, but it does not work yet.\nUsing simple smoothing between iterations","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["mandelbrot","shadertoy","buffer","pass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 sm(vec2 a, vec2 b, float t) {\n    return vec2(smoothstep(a.x, b.x, t), smoothstep(a.y,b.y,t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 dat = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec2 c = vec2(3, 2) * fragCoord / iResolution.xy - vec2(2, 1);\n    \n    float t = smoothstep(0., 1.,  float(iFrame%dt)/float(dt));\n    vec2 old = dat.xy;\n    dat.xy = mix(dat.xy, cpow(dat.xy,vec2(2,0))+c, t);\n    vec2 z = dat.xy;\n    float i = dat.z * _iter;\n    uv = (z +  vec2(2, 1)) / vec2(3,2);\n    \n    vec2 uvm = uv * iResolution.xy;\n    uvm /= _cbsize; // uvm = floor(uvm / _cbsize);\n    vec2 a = sin(3.14*uvm);\n    float PatternMask = -a.x*a.y; \n    PatternMask /= fwidth(PatternMask)*.2;\n    vec3 col = vec3(.5+.5*PatternMask);\n    \n    float factor = 1. - 1. / (dat.x * dat.x + dat.y * dat.y);\n    col = mix(col, vec3(0), max(0., factor));\n    \n    fragColor.rgb = col;\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 c = vec2(3, 2) * fragCoord / iResolution.xy - vec2(2, 1);\n    \n    vec4 dat = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    if( iFrame == 0) {\n        dat.xy = c;\n        dat.z = 0.;\n    } else {\n        if (iFrame % dt == 0) {\n            if( true ) {\n                dat.xy = cpow(dat.xy, vec2(2,0)) + c;\n                dat.z += 1. / _iter;\n            }\n        } else {\n            dat.x = dat.x;\n        }\n    }\n    \n    fragColor = dat;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define _iter 3.\n#define dt 240\n#define _cbsize 50.\n#define _n 5.\n\n/*\nfrom\nhttps://stackoverflow.com/questions/56725883/how-to-express-tetration-function-for-complex-numbers\n*/\n\nfloat gamma01(in float x) {\n    return 2.80508 * x + 8.14950446 - sqrt(47.9819532714 * x + 51.1136058464);\n}\n\nfloat gamma(in float x) {\n    float h = floor(x), f = x - h, y = gamma01(f);\n    if (x < 0.0) for (float n=0.0; n < -h; n++) y /= f - n;\n    else for (float n=1.0; n < h + 1.0; n++) y *= f + n;\n    return y;\n}\n\nfloat factorial(in float x) {\n    return gamma01(x + 1.);\n}\n\nfloat choose(in float n, in float k) {\n    return factorial(n)/(factorial(k) * factorial(n - k));\n}\nvec2 cmul(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\n// complex exponent e^a\nvec2 cexp(in vec2 a) {\n    float ea = exp(a.x);\n    float vl = a.y;\n    return ea * vec2( cos(vl), sin(vl) );\n}\n\n// complex natural logarithm ln(a)\nvec2 cln(in vec2 a) {\n    float ql = length(a);\n    return vec2( log(ql), atan(a.y, a.x));\n}\n\n// complex power function a^b\nvec2 cpow(in vec2 a, in vec2 b) {\n    return cexp(cmul(cln(a), b));   \n}\n\nvec2 iterate(vec2 z, vec2 c, float n) {\n    for(float i=0.; i < n; i++) {\n        if(z.x * z.x + z.y * z.y > 4.) return vec2(0);\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.y * z.x) + c;\n    }\n    return z;\n}\n\nvec2 mandeln(vec2 z, vec2 c, float s) { //computes f^s(x)\n    vec2 k_sum;\n    float k;\n    vec2 _;\n    float n = _n;\n    \n    for(k = 0.; k < n; k++) {\n        _ = vec2((s - n) / (s - k), 0);\n        _ = cmul(_, vec2(choose(n, k), 0));\n        _ = cmul(_, vec2(pow(-1., n - k), 0));\n        _ = cmul(_, iterate(z, c, floor(k)));\n        k_sum += _;\n    }\n    \n    return cmul(vec2(choose(s, n), 0), k_sum);\n    \n}","name":"Common","description":"","type":"common"}]}