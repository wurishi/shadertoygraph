{"ver":"0.1","info":{"id":"4f2yDh","date":"1722267384","viewed":41,"name":"The D6","username":"Eolc","description":"Reroll your destiny\nThe D6 in The Binding of Isaac","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","game","dice","thebindingofisaac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.01\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define PI 3.1415926\nfloat hole(vec3 p, float r)\n{\n    float c = min(0., length(p.xz) - r);\n    return (p.y > 0.) ? length(vec2(c, p.y)) : r - length(p);\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\n// Die SDF.\nfloat die(vec3 p)\n{\n    vec3 q = abs(p);\n\n    bvec3 dots = sign(p.z) > 0. ? bvec3(false, true, true) : bvec3(true, true, false);\n    vec3 b = p.xzy * sign(p.z);\n\n    if(q.x > q.y && q.x > q.z)\n    {\n        b = p.zxy * sign(p.x);\n        b.z = -b.z;\n        dots = sign(p.x) > 0. ? bvec3(false, true, false) : bvec3(true, true, true);\n    }\n    else if(q.y > q.z)\n    {\n        b = p.zyx * sign(p.y);\n        dots = sign(p.y) > 0. ? bvec3(false, false, true) : bvec3(false, false, false);\n    }\n    \n    float r = .02, r2 = .08 ,r3 = .08;\n    b.y -= .5 - r;\n    float d;\n\n    if(all(not(dots)))\n    {\n        // Special case for side 6.\n        b.x = abs(b.x);\n        b.z = mod(b.z + .3 / 2., .3) - .3 / 2.;\n        d = hole(b - vec3(.2, 0, 0), r3);\n    }\n    else\n    {\n        // The sides other than 6 have reflective symmetry in two lines.\n        if(b.x > -b.z)\n            b.xz = -b.zx;\n\n        if(b.x > b.z)\n            b.xz = b.zx;\n        if(b.z - b.x > .25)\n            d = dots.y ? hole(b - vec3(-1, 0, +1) / 4., r3) : b.y;\n        else if(-b.x - b.z > .25)\n            d = dots.x ? hole(b - vec3(-1, 0, -1) / 4., r3) : b.y;\n        else\n            d = dots.z ? hole(b, r3): b.y;\n    }\n\n    return max(d - r, sdRoundBox(p, vec3(.5) - r2, r2));\n}\nfloat sdRect(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat sdScene(vec3 p)\n{\n    vec3 boxPos = p;\n\n    float t = iTime;\n    boxPos*=mat3(cos(t),sin(t)*sin(t),cos(t)*sin(t),\n                 0.,cos(t),-sin(t),\n                 -sin(t),cos(t)*sin(t),cos(t)*cos(t));\n\n    float die = die(boxPos);\n\n    float plane = p.y+1.5;\n    \n    float d = min(die,plane);\n    \n    return d;\n}\nvec3 getNormal(vec3 p)\n{\n    float d = sdScene(p);\n    vec2 e = vec2(0.01,0);\n    return normalize(d-vec3(sdScene(p-e.xyy),\n                          sdScene(p-e.yxy),\n                          sdScene(p-e.yyx)));\n}\nfloat Raymarch(vec3 ro, vec3 rd)\n{\n    float d = 0.;\n    for(int i=0; i<MAX_STEPS ;i++)\n    {\n        vec3 p = ro + d*rd;\n        d += sdScene(p);\n        if(d>MAX_DIST || d<MIN_DIST)\n        {\n            break;\n        }\n    }\n    return d;\n}\nfloat light(vec3 p)\n{\n    vec3 light = vec3(0.,5.,-2.);\n\n    vec3 n = getNormal(p);\n    vec3 l = normalize(light-p);\n    \n    \n    float dif = clamp(dot(l,n),0.,1.);\n    float amb = 0.1 + max(0.25 * dot(l,n),0.);\n    float pr = Raymarch(p+l*MIN_DIST*2.,l);\n    if(pr < length(light - p)) dif *= 0.1;\n    return dif+amb;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.,0.,-4.), rd = normalize(vec3(uv.x,uv.y,1.));\n    float dist = Raymarch(ro,rd);\n    vec3 p = ro + dist*rd;\n    float color = light(p);\n    if (p.y > -1. && dist<10.)\n    {\n        // dice\n        vec3 light = vec3(0.,2.,-2.);\n\n        vec3 n = getNormal(p);\n        vec3 l = normalize(light-p);\n        vec3 boxPos = p;\n\n        float t = iTime;\n        boxPos*=mat3(cos(t),sin(t)*sin(t),cos(t)*sin(t),\n                 0.,cos(t),-sin(t),\n                 -sin(t),cos(t)*sin(t),cos(t)*cos(t));\n        vec3 baseCol = mix(vec3(.8, 0., 0.),vec3(0.),\n                           smoothstep(0.1, 0.5, sdRoundBox(boxPos, vec3(.5)-.07, .07)));\n        if(die(boxPos) > 0.0 && sdRect(boxPos,vec3(0.5)) < 0.)\n            baseCol = vec3(0.);\n        vec3 diff = vec3(0.5 + 0.5 * dot(n, l)) + vec3(0.5 + 0.5 * -n.y) * vec3(.1, .1, .2) * 1.5;\n        float fresnel = mix(0.01, .5, pow(clamp(1. + dot(rd, n), 0., 1.), 2.));\n        col = mix(baseCol * diff, vec3(0.), fresnel);\n\n    }\n    else\n    {\n        col = vec3(sqrt(color));\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}