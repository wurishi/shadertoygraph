{"ver":"0.1","info":{"id":"WtfXzs","date":"1563875672","viewed":84,"name":"raytracing with rotate cam","username":"suraimu752","description":"raytracing by myself","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 pos;\n    vec3 col;\n    float radius;\n};\n\nstruct Plane{\n    float height;\n    vec3 col;\n};\n\nstruct Ray{\n    vec3 col;\n    vec3 origin;\n    vec3 direction;\n    vec3 pos;\n};\n\nint nearestSphere(Sphere S, Plane P, Ray R){\n    if(distance(R.pos, S.pos) - S.radius < (R.pos.z < 90. ? abs(R.pos.y - P.height) : 1000.)){\n        return 0;\n    }\n    else{\n        return 1;\n    }\n}\n\nvec3 lightDirection = vec3(1., 1., -1.) * 250.;\n// vec3 lightDirection = vec3(1.) * 2.;\n\nvoid df(Sphere S, Plane P, inout Ray R){\n    float depth = 0.;\n    for(int i = 0; i < 200; i++){\n        R.pos = R.origin + R.direction * depth;\n\n        int index = nearestSphere(S, P, R);\n        // index = -1;\n        // then sphere < plane\n        if(index == 0){\n            float dist = distance(R.pos, S.pos) - S.radius;\n            depth += dist;\n            if(dist < 0.0001){\n                R.col = S.col * clamp(dot(R.pos - S.pos, normalize(lightDirection) * 1.5), .05, 1.);\n                break;\n            }\n        }   // then plane < sphere\n        else{\n            float dist = abs(R.pos.y - P.height);\n            depth += dist;\n            if(dist < 0.0001){\n                R.col = P.col;\n                R.col *= (1. - (mod(floor(R.pos.x * 6.) + floor(R.pos.z * 6.), 2.) * .2));\n                float a = pow(length(R.pos - lightDirection), 2.);\n                float b = 2. * dot(lightDirection - S.pos, R.pos - lightDirection);\n                float c = pow(length(lightDirection - S.pos), 2.) - pow(S.radius, 2.);\n                float d = pow(b, 2.) - 4. * a * c;\n                if(d >= 0.){\n                    // R.col *= .7;\n                    // R.col *= clamp(clamp(1. / (d * d * d), 0., 1.)\n                    //        * pow(distance(R.pos, S.pos), 2.), 0., 1.);\n                    R.col *= clamp(distance(R.pos, S.pos) * .7 - 1., 0.05, 1.);\n                }\n                R.col *= clamp(dot(lightDirection, vec3(0, 1, 0)), 0., 1.) * .9;\n                // if(R.pos.z > 3. && 3.1 > R.pos.z) R.col = vec3(1.);\n            }\n        }\n    }\n}\n\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 rotateY(float t){\n    return mat3(\n        cos(t), 0, sin(t),\n        0, 1, 0,\n        -sin(t), 0, cos(t)\n    );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 p = (fragCoord * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    // float screenZ = sin(iTime) - 1.;\n    float screenZ = -1.;\n    Ray ray;\n    ray.origin = vec3(0, 0, screenZ);\n    ray.direction = normalize(vec3(p, 0) - ray.origin) * rotateY(sin(iTime * .3));\n    ray.pos = ray.origin;\n    ray.col = vec3(0, 0, .05);\n\n    Sphere sphere;\n    sphere.col = vec3(1.);\n    sphere.pos = vec3(1., 0, 2.);\n    sphere.radius = 1.;\n\n    Plane plane;\n    plane.height = -1.;\n    plane.col = vec3(1.);\n\n    // if((rand(p) + rand(p+vec2(1.)) + rand(p+vec2(2.))) * .333 > .95){\n    //     ray.col = vec3(1.);\n    // }\n\n    df(sphere, plane, ray);\n\n    fragColor = vec4(ray.col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}