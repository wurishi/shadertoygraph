{"ver":"0.1","info":{"id":"wslSWs","date":"1552591198","viewed":102,"name":"Ray Marching with Lighting","username":"drichardson","description":"Following along to \nhttps://www.youtube.com/watch?v=PGtv-dBi2wE","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray Marching implementation using Sphere Tracing.\n// Produces a distance field visualization of the scene.\n//\n// Taken from Ray Marching for Dummies\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n//\n// I changed variable names and added comments to make\n// the purpose of variables and functions more obvious.\n\n// scene description\nconst vec3 CAMERA_POSITION = vec3(0,1,0);\nconst vec3 SPHERE_POSITION = vec3(0, 1, 6);\nconst float SPHERE_RADIUS = 1.;\nconst float PLANE_POSITION_Y = 0.;\nconst vec3 LIGHT_PIVOT = vec3(0, 5, 2);\nconst float LIGHT_PIVOT_DISTANCE = 4.;\nconst vec3 LIGHT_COLOR = vec3(1,1,1);\n\n// GetDistanceNearestSurface is hard coded for our scene, which is comprised\n// of a plane and a sphere.\n// The plane is axis aligned with the camera and below the camera.\nfloat GetDistanceToNearestSurface(vec3 point)\n{\n    float distanceToSphere = length(point-SPHERE_POSITION)-SPHERE_RADIUS;\n    float distanceToPlane = point.y - PLANE_POSITION_Y;\n    float distanceToNearestSurface = min(distanceToSphere, distanceToPlane);\n    return distanceToNearestSurface;\n}\n\nconst int MAX_STEPS = 50;\nconst float MAX_DIST = 100.;\nconst float SURFACE_DIST = 0.01;\n\n// Ray Marching using a Sphere Trace algorithm.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceFromOrigin = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayOrigin + distanceFromOrigin * rayDirection;\n        float distanceToScene = GetDistanceToNearestSurface(p);\n        distanceFromOrigin += distanceToScene;\n        bool foundSurface = distanceToScene < SURFACE_DIST;\n        bool exceededMax = distanceFromOrigin > MAX_DIST;\n        if (foundSurface || exceededMax)\n            break;\n    }\n    return distanceFromOrigin;\n}\n\n// Get the normal of the surface at point p.\n// To see why this works read:\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetSurfaceNormal(vec3 p)\n{\n    float d = GetDistanceToNearestSurface(p);\n    const vec2 h = vec2(.0001,0);\n    vec3 dh = vec3(\n        GetDistanceToNearestSurface(p-h.xyy),\n        GetDistanceToNearestSurface(p-h.yxy),\n        GetDistanceToNearestSurface(p-h.yyx));\n    \n    return normalize(d - dh);\n}\n\nfloat GetDiffuseLight(vec3 pointOnSurface)\n{\n    vec3 lightPos = LIGHT_PIVOT;\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * LIGHT_PIVOT_DISTANCE;\n    vec3 lightNormal = normalize(lightPos - pointOnSurface);\n    vec3 surfaceNormal = GetSurfaceNormal(pointOnSurface);\n    return clamp(dot(lightNormal, surfaceNormal), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv is the fragCoord with (0,0) in the center of the screen.\n    // The division by minres uses the same scaling on both\n    // axis to avoid distortion. The min is not strictly necessary in\n    // ShaderToy, since the aspect ratio is such that the min\n    // is always iResolution.y.\n    float minres = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - .5*iResolution.xy) / minres;\n    \n    // Camera Model\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Compute Distance\n    vec3 rayOrigin = CAMERA_POSITION;\n    float distanceToSurface = RayMarch(rayOrigin, rayDirection);\n    \n    // Lighting\n    vec3 pointOnSurface = rayOrigin + rayDirection * distanceToSurface;\n    float diffuse = GetDiffuseLight(pointOnSurface);\n    \n    fragColor = vec4(diffuse * LIGHT_COLOR, 1.);\n}\n","name":"Image","description":"","type":"image"}]}