{"ver":"0.1","info":{"id":"ctt3z8","date":"1682464835","viewed":110,"name":"Poincare Tessellation","username":"lolucky","description":"Click on the screen to more the polygons\nP is the number of edges on the polygon\nQ is the number of polygons that meet at a vertex\nsome combinations of P and Q are impossible\n\nThe codes a bit of a mess","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["tessellation","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int P = 5;\nconst int Q = 4;\n\nvec2 verts[3];\nvec3 edge;\nfloat PI = 3.1415926535;\n\nfloat cros(vec2 a, vec2 b) {\n    return a.x * b.y - b.x * a.y;\n}\nvec2 cx_mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\nvec2 cx_div(vec2 a, vec2 b) {\n    return cx_mul(a,vec2(b.x,-b.y)) / dot(b,b);\n}\n\nvec2 hyper_translate(vec2 z, vec2 p) {\n    if (p == vec2(0)) return z;\n    float r = (1.+length(p))/(1.-length(p));\n    if (r < 0. || r > 30.) r = 30.;\n    z = cx_mul(z, normalize(p));\n    z = cx_div(vec2(1. - r, 0) + (1. + r) * z,\n               vec2(1. + r, 0) + (1. - r) * z);\n    z = cx_div(z, normalize(p));\n    return z;\n}\n\nvoid set_fundamental(vec2 pq) {\n    vec2 angles = PI / pq;\n    angles.y = PI / 2. - angles.y;\n    vec2 tn = tan(angles);\n    \n\tfloat dist = sqrt((tn.y - tn.x) / (tn.y + tn.x));\n    \n    verts[0] = vec2(0);\n    verts[1] = vec2(dist * cos(angles.x), dist * sin(angles.x));\n    edge.xy = vec2((1.+dist*dist)/2./dist/cos(angles.x), 0);\n    edge.z = edge.x*edge.x-1.;\n    verts[2] = vec2(edge.x-sqrt(edge.z), 0);\n}\n\nvec2 flip_to_fundamental(vec2 uv) {\n    for (int i=0; i<20; ++i) {\n        vec2 diff = uv - edge.xy;\n        float d0 = dot(diff, diff);\n        if (d0 < edge.z) { \n            uv = edge.xy + (uv - edge.xy) * edge.z / d0;\n        }\n        \n        diff = uv - verts[0];\n        if (cros(diff, verts[1] - verts[0]) < 0.) {\n            vec2 dir = normalize(verts[1] - verts[0]);\n            uv = (verts[0] + dir * dot(uv - verts[0], dir)) * 2. - uv;\n        }\n        \n        diff = uv - verts[0];\n        if (cros(diff, verts[0] - verts[2]) < 0.) {\n            vec2 dir = normalize(verts[2] - verts[0]);\n            uv = (verts[0] + dir * dot(uv - verts[0], dir)) * 2. - uv;\n        }\n    }\n    return uv;\n}\n\nvec2 to_uv(vec2 uv) {\n    return (2. * uv - iResolution.xy) / iResolution.y;\n}\n\nvoid mainImage( out vec4 C, in vec2 uv )\n{\n    uv = to_uv(uv);\n    \n    C = vec4(0);\n    if(length(uv) < 1.) {\n        uv = hyper_translate(uv, to_uv(iMouse.xy)*vec2(1,-1));\n        set_fundamental(vec2(Q, P));\n        vec2 uv2 = flip_to_fundamental(uv);\n        float r = length(verts[0]-verts[2]) \n                * length(verts[1]-verts[2]) \n                * length(verts[0]-verts[1])\n                / abs(cros(verts[0]-verts[1], verts[0]-verts[2]));\n        \n        C = mix(vec4(\n            1. - length(verts[0] - uv2) / r,\n            1. - length(verts[1] - uv2) / r,\n            1. - length(verts[2] - uv2) / r,\n        1), vec4(0), vec4(uv2.y<.01));\n    }\n}","name":"Image","description":"","type":"image"}]}