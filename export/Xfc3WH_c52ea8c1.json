{"ver":"0.1","info":{"id":"Xfc3WH","date":"1711606748","viewed":85,"name":"noise_flow","username":"yufengjie","description":"use segement rotate angle to create noise flow effect","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise","sdf","flow","segement"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415926;\nfloat pix;\nfloat lineWidth;\n\n// p屏幕坐标，a起点，b终点\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\nfloat plotLine(vec2 uv, vec2 start, vec2 end, float lineWidth) {\n  float l = sdSegment(uv, start, end) - lineWidth;\n  return smoothstep(lineWidth * 1.5, lineWidth, abs(l));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy;\n  pix = 1. / iResolution.y;\n  //lineWidth = 10. * pix;\n  lineWidth = 0.05;\n\n  float cellSize = 40.;\n  vec2 rc = iResolution.xy / cellSize; // rows and cols\n  vec2 uvi = floor(uv / cellSize);\n  vec2 uvf = fract(uv / cellSize);\n  vec3 fin_c = vec3(0.);\n\n  bool showBorder = false;\n  if(showBorder) {\n    float border1 = smoothstep(10. * pix, 0., abs(uvf.x));\n    float border2 = smoothstep(10. * pix, 0., abs(uvf.x - 1.));\n    float border3 = smoothstep(10. * pix, 0., abs(uvf.y));\n    float border4 = smoothstep(10. * pix, 0., abs(uvf.y - 1.));\n    float border = border1 + border2 + border3 + border4;\n    fin_c += border * vec3(1.);\n  }\n\n  float noiseVal = noise(uvi / rc + iTime);\n  float angle = noiseVal * PI * 2.;\n  float lineLen = (.4 - lineWidth * 2.) * noiseVal  + 0.1;\n  vec2 start = vec2(0.5);\n  vec2 end = vec2(cos(angle) * lineLen, sin(angle) * lineLen) + start;\n  float line = plotLine(uvf, start, end, lineWidth);\n  vec3 color = palette(noiseVal);\n  fin_c = mix(fin_c, color, line);\n  //fin_c += color * line;\n\n  fragColor = vec4(fin_c, 1.);\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n  float a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n    // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n  return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\nfloat noise(vec3 x) {\n  const vec3 step = vec3(110, 241, 171);\n\n  vec3 i = floor(x);\n  vec3 f = fract(x);\n\n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n  float n = dot(i, step);\n\n  vec3 u = f * f * (3.0 - 2.0 * f);\n  return mix(mix(mix(hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix(hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix(hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix(hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nvec3 palette(float t) {\n  vec3 a = vec3(1.000, 0.500, 0.500);\n  vec3 b = vec3(0.500, 0.500, 0.500);\n  vec3 c = vec3(0.750, 1.000, 0.667);\n  vec3 d = vec3(0.800, 1.000, 0.333);\n  return a + b * cos(6.28318 * (c * t + d));\n}","name":"Common","description":"","type":"common"}]}