{"ver":"0.1","info":{"id":"4sVGRG","date":"1455120610","viewed":392,"name":"2D Line Distance In A Grid","username":"bloxard","description":"The shader shows the distance to a 2D Line segment in a grid.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","2dline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Per Bloksgaard, 2015 - https://perbloksgaard.dk\n\n#define PI 3.14159265358979\n\nfloat DistanceToLineSegment(in vec2 a, in vec2 b, in vec2 p)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n\treturn length(pa-ba*h);\n}\n\nvec3 HSLtoRGB(in float h, in float s, in float l)\n{\n  vec3 rgb = clamp( abs(mod(h+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  return l + s * (rgb-0.5)*(1.0-abs(2.0*l-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 s = (-iResolution.xy+2.*gl_FragCoord.xy)/iResolution.y;\n  float t = iTime;\n  float u = t*0.2;\n  float v = -PI*0.6-cos(t*0.01)*PI*0.1;\n  float f = clamp(cos(t*0.5),0.0,1.0)*15.5;\n  vec3 target = vec3(0.0,0.2,0.0);\n  vec3 origin = vec3(cos(u)*sin(v)*2.0,0.4+f,sin(u)*sin(v));\n  vec3 camForward = normalize(target-origin);\n  vec3 wldUp = vec3(0.0,1.0,0.0);\n  vec3 camRight = normalize(cross(camForward,wldUp));\n  vec3 camUp = normalize(cross(camRight,camForward));\n  vec3 direction = normalize(s.x*camRight+s.y*camUp+camForward*1.7);\n\n  float distance = 200.0;\n  if (direction.y<0.0)\n  {\n    distance = -origin.y/direction.y;\n  }\n  vec3 pos = origin + direction*distance;\n\n  float fLineBase = 2.0 + (iResolution.x / 600.0)*10.0;\n  float fLineWidth = (fLineBase+10.0*(1.0-clamp(origin.y*0.3,0.0,1.0))*clamp(-direction.y/clamp(distance*0.6,0.01,1.0),0.0,1.0)) / iResolution.x;\n  float fLineHeight = (fLineBase+10.0*(1.0-clamp(origin.y*0.3,0.0,1.0))*clamp(-direction.y/clamp(distance*0.6,0.01,1.0),0.0,1.0)) / iResolution.x;\n  float grid = step(fract(pos.x),fLineWidth);\n  grid = max(step(fract(pos.z),fLineHeight),grid);\n  grid = max(step(fract(pos.x*2.0),fLineWidth)*0.3,grid);\n  grid = max(step(fract(pos.z*2.0),fLineHeight)*0.3,grid);\n  grid *= clamp((-direction.y/clamp(distance*0.1,0.01,2.0)*clamp(origin.y*5.0,0.0,2.0)),0.0,1.0);\n  vec3 c = vec3(1.0-grid);\n\n  float fCos = cos(iTime);\n  float fSin = sin(iTime);\n  float fLen = 0.7 + cos(iTime*0.3)*0.2;\n    \n  vec2 v1 = vec2(fCos*-fLen,fSin*fLen);\n  vec2 v2 = vec2(fSin*fLen,fCos*fLen);\n  float d = DistanceToLineSegment(v1, v2, vec2(pos.x, pos.z))*400.0;\n  float h = d*0.023+5.4;\n  float q = smoothstep(-5.0, 35.0, d);\n  float l = 0.5*q;\n  l *= 1.0-smoothstep(180.0, 250.0, d);\n  l += 1.0-smoothstep(2.0, 3.0, d);\n  vec3 w = HSLtoRGB(h,q,l);\n  w += vec3(1)-c;\n  fragColor = vec4(w,1.0);\n}\n","name":"Image","description":"","type":"image"}]}