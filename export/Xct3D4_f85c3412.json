{"ver":"0.1","info":{"id":"Xct3D4","date":"1711831045","viewed":28,"name":"TP3 Otmane ","username":"otmane100","description":"TP3 shadows Otmane El Mouki","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tp3shadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Otmane El Mouki\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 Rz(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\nstruct Ray {\nvec3 ro; // Ray origin\nvec3 rd; // Direction\n};\n\n// Compute a point on the ray\n// ray : Ray\n// t   : depth\nvec3 Point(Ray ray,float t)\n{\n  return ray.ro+t*ray.rd;\n}\n\n// Compute the ray\n//     m : Mouse position\n//     p : Pixel\nRay CreateRay(vec2 m,vec2 p)\n{\n  float a=3.*3.14*m.x; \n  float le=3.5;\n  \n  // Origin\n  vec3 ro=vec3(35.,0.,10.)*Rz(a);\n  \n  // Target point\n  vec3 ta=vec3(0.,0.,3.);\n  \n  // Orthonormal frame\n  vec3 w=normalize(ta-ro);\n  vec3 u=normalize(cross(w,vec3(0.,0.,1.)));\n  vec3 v=normalize(cross(u,w));\n  vec3 rd=normalize(p.x*u+p.y*v+le*w);\n  return Ray(ro,rd);\n}\n\n// Primitives\n\n// Sphere\n// p : point\n// c : center of skeleton\n// r : radius\nfloat Sphere(vec3 p,vec3 c,float r)\n{\n  return length(p-c)-r;\n}\n\n// Plane\n// p : point\n// c : center of skeleton\n// n : Normal\nfloat Plane(vec3 p,vec3 c,vec3 n)\n{\n  return dot(p-c,n);\n}\n\n\n// Tronc de l'arbre comme un cylindre\nfloat Tronc(vec3 p, vec3 base, float hauteur, float rayon) {\n    vec3 dist = p - base;\n    float tronc = max(length(dist.xy) - rayon, abs(dist.z) - hauteur);\n    return tronc;\n}\n\n// Couronne de l'arbre comme une sphère\nfloat Couronne(vec3 p, vec3 centre, float rayon) {\n    return length(p - centre) - rayon;\n}\n\n\n\n// Operators\n\n// Union\n// a,b : field function of left and right sub-trees\nfloat Union(float a,float b)\n{\n  return min(a,b);\n}\n\n// Union, extension to four sub-trees\n// a,b,c : field function of left and right sub-trees\nfloat Union(float a,float b,float c,float d)\n{\n  return min(min(a,b),min(c,d));\n}\n\n// Difference\n// a,b : field function of left and right sub-trees\nfloat Difference(float a,float b)\n{\n  return max(a,-b);\n}\n\n// Potential field of the object\n// p : point\n\n/*float object(vec3 p) {\n    // Objets existants\n    float v = Sphere(p, vec3(3., 0., 6.), 4.);\n    v = Union(v, Sphere(p, vec3(0., 2., 3.), 3.));\n  \n    float d = Union(\n        Sphere(p, vec3(5., 1., 5.), 3.),\n        Sphere(p, vec3(-1., 1., 6.), 3.),\n        Sphere(p, vec3(-1., 2., 2.), 2.),\n        Sphere(p, vec3(1., 1., 6.), 2.)\n    );\n    v = Difference(v, d);\n    v = Union(v, Plane(p, vec3(0., 0., -1.), vec3(0., 0.0, 1.0)));\n\n \n\n    return v;\n}\n*/ \n\n\nfloat object(vec3 p) {\n    // Objets existants\n    float v = Sphere(p, vec3(3., 0., 6.), 4.);\n    v = Union(v, Sphere(p, vec3(0., 2., 3.), 3.));\n  \n    float d = Union(\n        Sphere(p, vec3(5., 1., 5.), 3.),\n        Sphere(p, vec3(-1., 1., 6.), 3.),\n        Sphere(p, vec3(-1., 2., 2.), 2.),\n        Sphere(p, vec3(1., 1., 6.), 2.)\n    );\n    v = Difference(v, d);\n    v = Union(v, Plane(p, vec3(0., 0., -1.), vec3(0., 0.0, 1.0)));\n\n    vec3 baseTronc = vec3(-8.0, .0, 0.0); \n    float tronc = Tronc(p, baseTronc, 5.0, 0.6); \n    vec3 centreCouronne = baseTronc + vec3(0.0, 0.0, 7.0); // Ajustement pour la taille du tronc\n    float couronne = Couronne(p, centreCouronne, 4.0); // Couronne plus grande\n\n    // On combine l'arbre avec les autres éléments\n    v = Union(v, tronc);\n    v = Union(v, couronne);\n\n    return v;\n}\n\n\n\n// Analysis of the scalar field\n\nconst int Steps=200;// Number of steps\nconst float Epsilon=.01;// Marching epsilon\n\n// Object normal\n// p : point\nvec3 ObjectNormal(vec3 p)\n{\n  const float eps=.001;\n  vec3 n;\n  float v=object(p);\n  n.x=object(vec3(p.x+eps,p.y,p.z))-v;\n  n.y=object(vec3(p.x,p.y+eps,p.z))-v;\n  n.z=object(vec3(p.x,p.y,p.z+eps))-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// ray : Ray \n// e : Maximum distance\n// h : hit\n// s : Number of steps\nfloat SphereTrace(Ray ray,float e,out bool h,out int s)\n{\n  h=false;\n  \n  // Start at the origin\n  float t=0.;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=Point(ray,t);\n    float v=object(p);\n    // Hit object\n    if(v<0.)\n    {\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,v);\n    // Escape marched too far away\n    if(t>e)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Lighting\n\n// Background color\n// d : Ray direction\nvec3 Background(vec3 d)\n{\n  return mix(vec3(.45,.55,.99),vec3(.65,.69,.99),d.z*.5+.5);\n}\n\n\n\n\n////////////////////////////////////////////////Fonctions pour les ombres\n\nconst float PI = 3.14159265359; // Déclaration de PI\n\n\n\n//1° Fonction pour les Ombres dures\n\n\n\nfloat Shadow(vec3 point, vec3 lightPos) {\n    Ray shadowRay; // Définit le rayon d'ombre\n    shadowRay.ro = point + ObjectNormal(point) * 0.01;\n    shadowRay.rd = normalize(lightPos - point); // Direction du rayon vers la lumière\n    bool h; // Variable pour vérifier si le rayon intersecte un objet\n    int steps; // Compte le nombre de pas effectués par le ray marching\n    float t = SphereTrace(shadowRay, length(lightPos - point), h, steps); // Trace le rayon\n    if(h) return 0.0; // Si intersection, le point est dans l'ombre\n    return 1.0; // Sinon, le point est éclairé\n}\n\n\n\n\n////////////////////////////////2° Fonction Fibonaci pour les ombres douces \n\nvec3 Fibonacci(int i, int n) {\n    float phi = float(i) * 2.39996323;\n\n    // Calcule 'z' comme la cosinus de 'phi' pour simuler une distribution sur l'axe vertical\n    float z = cos(phi);\n\n    // Calcule le rayon horizontal en fonction de 'z'\n    float radius = sqrt(1.0 - z * z);\n\n    // Utilise 'phi' directement pour la répartition autour de la sphère\n    float x = radius * cos(phi);\n    float y = radius * sin(phi);\n\n    return vec3(x, y, z);\n}\n\n\n\n\n\n\n////////////////////////////////3° Fonction SoftShadow \n\nfloat SoftShadow(vec3 point, vec3 lightPos, int samples) {\n    float shadow = 0.0; // Accumulateur pour l'ombre\n    for(int i = 0; i < samples; ++i) { // Boucle sur le nombre d'échantillons\n        vec3 sampleDir = Fibonacci(i, samples); // Génère une direction sur la sphère\n        vec3 samplePos = lightPos + sampleDir * 0.1; // Positionne le point de lumière étendue\n        shadow += Shadow(point, samplePos); // Calcule l'ombre pour ce point\n    }\n    return shadow / float(samples); // Moyenne l'ombre sur tous les échantillons\n}\n\n\n//////////////////////////////4° Fonction Hemisphere pour l'occlusion Ambiente\n\n\n\n// i : l'index du point courant\n// n : le nombre total de points à générer\n// normal : la normale à la surface en ce point, déterminant l'orientation de l'hémisphère\n\n\nvec3 Hemisphere(int i, int n, vec3 normal) {\n    // Ratio d'or, utilisé pour répartir uniformément les points sur une sphère\n    float goldenRatio = (1.0 + sqrt(5.0)) / 2.0;\n    \n    // Calcule l'angle theta autour de la sphère, en utilisant le ratio d'or pour une distribution uniforme\n    float theta = 2.0 * PI * float(i) / goldenRatio;\n    \n    // Calcule l'angle phi à partir du plan, en assurant une distribution uniforme des points sur l'hémisphère\n    float phi = acos(1.0 - 2.0 * (float(i) + 0.5) / float(n));\n\n    // Conversion des coordonnées sphériques en coordonnées cartésiennes\n    vec3 dir = vec3(cos(theta) * sin(phi), sin(theta) * sin(phi), cos(phi));\n\n    // Oriente la direction générée selon la normale fournie, pour aligner avec l'hémisphère\n    vec3 up = abs(normal.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n    vec3 right = normalize(cross(up, normal));\n    up = cross(normal, right);\n\n    return normalize(dir.x * right + dir.y * up + dir.z * normal);\n}\n\n\n\n\n\n\n///////////////////////////5° Fonction pour l'occlusion ambiante\n\n\n/* Calcule une approximation de l'occlusion ambiante en lançant des rayons dans les directions \ngénérées par `Hemisphere` et en vérifiant si ces rayons rencontrent un obstacle. */ \n\n// point : le point à partir duquel l'occlusion est calculée\n// normal : la normale à la surface en ce point\n// samples : le nombre de rayons à lancer pour estimer l'occlusion\n\n\nfloat Occlusion(vec3 point, vec3 normal, int samples) {\n    float occlusion = 0.0;\n    for (int i = 0; i < samples; ++i) {\n        // Génère une direction de rayon à partir de l'hémisphère orienté par la normale\n        vec3 dir = Hemisphere(i, samples, normal);\n        \n        // Prépare le rayon pour le test d'occlusion, avec un petit offset pour éviter l'auto-intersection\n        Ray ray;\n        ray.ro = point + normal * 0.01;\n        ray.rd = dir;\n\n        bool hit;\n        int step;\n        // Lance le rayon et vérifie s'il rencontre un obstacle à une distance fixe\n        float dist = SphereTrace(ray, 1.0, hit, step);\n        if (hit) {\n            occlusion += 1.0; // Incrémente l'occlusion pour chaque obstacle rencontré\n        }\n    }\n    // Renvoie la proportion de directions non obstruées, inversée pour indiquer l'occlusion\n    return 1.0 - occlusion / float(samples);\n}\n\n\n\n\n\n//////////////////////////////////////////////////////////////////---------------\n\n\n\n// Shading and lighting\n// p : Point\n// n : Normal at point\n// e : Eye direction\n\n\n/*\nIci on a les differentes versions de la fonction Shade utilisées pour les différentes tests,\npour bien voir la différence entre les ombres douces/dures et l'occlusion ambiante.\n\n*/\n\n\n\n//Rendu avec ombres dures \n\n/* \nvec3 Shade(vec3 p, vec3 n, vec3 e, int aoSamples) {\n    const vec3 lp = vec3(5., 10., 30.); // Position de la source lumineuse\n    vec3 l = normalize(lp - p);\n    vec3 ambient = 0.25 + 0.25 * Background(n);\n    float shadow = Shadow(p, lp); // Calcule l'ombre dure\n\n    vec3 diffuse = 0.35 * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n    vec3 r = reflect(e, n);\n    vec3 specular = 0.15 * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n    vec3 c = ambient + shadow * (diffuse + specular); // Applique l'ombre au shading\n    return c;\n}\n\n*/\n\n\n\n\n//Rendu avec ombres douces\n\n/*\nvec3 Shade(vec3 p, vec3 n, vec3 e, int aoSamples) {\n    const vec3 lp = vec3(5., 10., 30.); // Position de la source lumineuse\n    vec3 l = normalize(lp - p);\n    vec3 ambient = 0.25 + 0.25 * Background(n);\n    \n    // Utilise SoftShadow au lieu de Shadow pour des ombres douces\n    // Spécifie le nombre d'échantillons, par exemple 16 pour ce cas\n    float shadow = SoftShadow(p, lp,16);\n\n    vec3 diffuse = 0.35 * clamp(dot(n, l), 0., 1.) * vec3(1., 1., 1.);\n    vec3 r = reflect(e, n);\n    vec3 specular = 0.15 * pow(clamp(dot(r, l), 0., 1.), 35.) * vec3(1., 1., 1.);\n    \n    // Applique l'ombre au shading\n    vec3 c = ambient + shadow * (diffuse + specular);\n    return c;\n}\n\n*/\n\n\n//rendu avec l'occlusion ambiente\n\n/*\nvec3 Shade(vec3 p, vec3 n, vec3 viewDir, int aoSamples, const vec3 lightPos) {\n    // Paramètres de lumière\n    vec3 lightColor = vec3(1.0, 1.0, 1.0); // Couleur blanche pour l'exemple\n    float lightIntensity = 1.0; // Intensité de la source lumineuse\n\n    // Calcul de la direction de la lumière et de la vue\n    vec3 l = normalize(lightPos - p); // Direction de la lumière\n\n    // Lumière ambiante modulée par l'occlusion ambiante\n    float ao = Occlusion(p, n, aoSamples);\n    vec3 ambient = vec3(0.2, 0.2, 0.2) * ao; // Lumière ambiante avec occlusion\n\n    // Calcul du terme diffus\n    float diff = max(dot(n, l), 0.0);\n    vec3 diffuse = diff * lightColor * lightIntensity;\n\n    // Combinaison de la lumière ambiante avec le terme diffus\n    vec3 color = ambient + diffuse;\n\n    return color;\n}\n\n*/\n\n\n\n// Shading avec ombres douces et occlusion ambiante\n// p : position du point sur l'objet\n// n : normale au point p\n// e : direction de l'oeil ou de la caméra\n// aoSamples : nombre d'échantillons pour l'occlusion ambiante\n\n\n    vec3 Shade(vec3 p, vec3 n, vec3 e, int aoSamples) {\n    // Définition de la position de la source lumineuse\n    const vec3 lp = vec3(5., 10., 30.);\n    \n    // Calcul de la direction de la lumière et de la vue\n    vec3 l = normalize(lp - p); // Direction de la lumière\n    vec3 viewDir = normalize(e - p); // Direction de la vue\n    \n    // Lumière ambiante basique, pourrait être ajustée pour refléter l'environnement\n    vec3 ambient = vec3(0.2, 0.2, 0.2);\n    \n    // Application de l'occlusion ambiante\n    float ao = Occlusion(p, n, aoSamples);\n    ambient *= ao; // Moduler la lumière ambiante basée sur l'occlusion\n    \n    // Calcul des ombres douces\n    float softShadow = SoftShadow(p, lp, 16); // 16 échantillons pour les ombres douces\n    \n    // Calcul du terme diffus\n    float diff = max(dot(n, l), 0.0);\n    vec3 diffuse = diff * vec3(1.0, 1.0, 1.0); // Couleur diffuse blanche\n    \n    \n    vec3 reflectDir = reflect(-l, n); // Direction du reflet\n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0); \n    vec3 specular = spec * vec3(1.0, 1.0, 1.0); // Couleur spéculaire blanche\n    \n    // Combinaison des termes d'éclairage avec les ombres douces\n    vec3 color = ambient + softShadow *(diffuse + specular);\n    \n    return color;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)  \n{\n  // Pixel\n  vec2 pixel=(-iResolution.xy+2.*pxy)/iResolution.y;\n\n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  Ray ray=CreateRay(m,pixel);\n  \n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n   // Trace ray\n float t=SphereTrace(ray,75.,hit,s);\n  \n  // Shade background\n  vec3 rgb=Background(ray.rd);\n  \n  if(hit)\n  {\n    // Position\n    vec3 p=Point(ray,t);\n    \n    // Compute normal\n    vec3 n=ObjectNormal(p);\n    \n    // Shade object with light\n    \n    rgb = Shade(p, n, -ray.rd, 16);\n  }\n    \n  color=vec4(rgb,1.);\n}\n","name":"Image","description":"","type":"image"}]}