{"ver":"0.1","info":{"id":"DsjGzz","date":"1667149177","viewed":168,"name":"[ConcoursJFIG2022] GRM","username":"Romimap","description":"Entrée pour le concours shadertoy 2022.\n\nCe shader représente un trou noir autour duquel gravite son disque d'accrétion (fait de vin, bien entendu) et une bouteille de JFIG 2022. \n\nRomain Fournier\n\n","likes":2,"published":1,"flags":32,"usePreview":1,"tags":["concoursjfig2022"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  __  __   _   ___ _  _ \n |  \\/  | /_\\ |_ _| \\| |\n | |\\/| |/ _ \\ | || .` |\n |_|  |_/_/ \\_\\___|_|\\_|\n                        \n*/\n\n\n// fires a curved ray in the current pixel, shade and print the returned position/color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = vec2(min(RESOLUTION.x, iResolution.x), min(RESOLUTION.y, iResolution.y));\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n \n    //Chromatic abérrations\n    vec2 c = vec2(0.5, 0.4);\n    vec2 uvR = normalize(c - uv) * clamp(1.0 / distance(c, uv), 1.0, 5.0) * 0.0018 * (sin(iTime * 5.0) * 0.5 + 0.5);\n    vec2 uvG = normalize(c - uv) * clamp(1.0 / distance(c, uv), 1.0, 5.0) * 0.0012 * (sin(iTime * 5.0) * 0.5 + 0.5);\n    vec2 uvB = normalize(c - uv) * clamp(1.0 / distance(c, uv), 1.0, 5.0) * 0.0006 * (sin(iTime * 5.0) * 0.5 + 0.5);\n    \n    //Vignette\n    float vignette = clamp(1.5 - distance(vec2(0.5), uv), 0.0, 1.0);\n    \n    uv /= iResolution.xy/r;\n    uvR /= iResolution.xy/r;\n    uvG /= iResolution.xy/r;\n    uvB /= iResolution.xy/r;\n \n    color.r = texture(iChannel0, uv + uvR).r;\n    color.g = texture(iChannel0, uv + uvG).g;\n    color.b = texture(iChannel0, uv + uvB).b;\n        \n    //ASC-CDL\n    vec3 slope  = vec3(1.0, 1.0, 1.1) * 1.5;\n    vec3 offset = vec3(0.0, 0.0, 0.0) + 0.1;\n    vec3 power  = vec3(1.0, 1.05, 1.05) * 1.2;\n    color = pow((color * slope) + offset, power);\n    color = tanh(color);\n    fragColor.rgb = color * vignette;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n  ___ ___ _____ _____ ___ _  _  ___ ___ \n / __| __|_   _|_   _|_ _| \\| |/ __/ __|\n \\__ \\ _|  | |   | |  | || .` | (_ \\__ \\\n |___/___| |_|   |_| |___|_|\\_|\\___|___/\n                                        \n*/\n\n/* Scales down the resolution to get more frames per seconds\n Low = 0.75 (GTX 970)\n Medium = 2.5 (RTX 3060)\n High = 6.0\n Elon Musk's personal supercomputer = 9999.0\n */\nconst float RENDER_SCALE = 2.0;\n\n/* Strength of the black hole (value of G * m1 * m2)\n Default = 0.1\n */\nconst float gravityStrength = 1.5;\n\n/* Base velocity of the light\n Default = 0.1\n */\nconst float baseVelocity = 0.4;\n\n/* The renderer uses stratified sampling to alleviate alliasing. This value controls the randomness of the sampling\n Default = 0.5\n */\nconst float stratifiedSamplingStength = 0.0;\n\n\n\n\n\n\n\n\n/*\n   ___ ___  _  _ ___ _____ ___ \n  / __/ _ \\| \\| / __|_   _/ __|\n | (_| (_) | .` \\__ \\ | | \\__ \\\n  \\___\\___/|_|\\_|___/ |_| |___/\n                               \n*/\nconst vec2 RESOLUTION = vec2(320, 180) * RENDER_SCALE;\nconst int MAXITER = 150;\nconst float EPSILON = 0.05;\nconst float INFINITY = 120.0;\nconst vec3 GRAVITYLOCATION = vec3(0.0, 0.0, 20.0);\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//JFIG 2022 bitmap\n\n\nconst int array[2048] = int[2048] (\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,0,0,0,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,1,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,1,1,1,1,1,0,1,1,1,0,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,0,0,1,1,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,1,1,0,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,0,1,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,0,0,1,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,1,1,1,1,0,0,0,0,1,1,1,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,0,1,1,0,1,0,0,0,1,1,0,0,1,0,0,0,1,0,0,1,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,0,0,1,1,0,0,0,1,0,1,1,1,0,0,1,0,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,0,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,1,1,0,0,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,0,0,1,0,1,0,0,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,0,0,0,1,1,0,0,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,0,0,1,1,1,0,0,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,0,0,1,1,0,0,1,0,0,1,1,1,1,1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,1,1,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.y = 1.0 - uv.y;\n    uv.x *= 64.0;\n    uv.y *= 32.0;\n    fragColor = vec4(vec3(array[int(uv.y) * 64 + int(uv.x)]), 1);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\n  ___    _   _  _ ___  \n | _ \\  /_\\ | \\| |   \\ \n |   / / _ \\| .` | |) |\n |_|_\\/_/ \\_\\_|\\_|___/ \n                       \n*/\n\n\n//Returns a random float between 0 and 1 (exclusive) from a vec2 seed\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\n//Returns a random vec2 between (0, 0) and (1, 1) (exclusive) from a vec2 seed\nvec2 rand2(vec2 co) {\n    return vec2(rand(co.yx*123.2434), rand(co.xy*73.2673));\n}\n\n\n\n\n\n/*\n  __  __   _ _____ ___ ___ ___ ___ ___ \n |  \\/  | /_\\_   _| _ \\_ _/ __| __/ __|\n | |\\/| |/ _ \\| | |   /| | (__| _|\\__ \\\n |_|  |_/_/ \\_\\_| |_|_\\___\\___|___|___/\n                                       \n*/\n\n\n//Rotates l gradients around Y\nmat4 T_RotateY(float l) {\n    mat4 transform = mat4(\n    cos(l) , 0      , sin(l) , 0      , \n    0      , 1      , 0      , 0      ,\n    -sin(l), 0      , cos(l) , 0      ,\n    0      , 0      , 0      , 1      \n    );\n    return transform;\n}\n\n\n//Rotates l gradients around X\nmat4 T_RotateX(float l) {\n    mat4 transform = mat4(\n    1      , 0      , 0      , 0      , \n    0      , cos(l) , -sin(l), 0      ,\n    0      , sin(l) , cos(l) , 0      ,\n    0      , 0      , 0      , 1      \n    );\n    return transform;\n}\n\n\n//Translates t units\nmat4 T_Translate(vec3 t) {\n    mat4 transform = mat4(\n    1      , 0      , 0      , t.x   , \n    0      , 1      , 0      , t.y   ,\n    0      , 0      , 1      , t.z   ,\n    0      , 0      , 0      , 1      \n    );\n    return transform;\n}\n\n\n//Transforms a point P with a matrix T\nvec3 T_GetPos(vec3 P, mat4 T) {\n    return (vec4(P, 1) * inverse(T)).xyz;\n}\n\n\n//Transforms a vector V with a matrix T\nvec3 T_GetVec(vec3 V, mat4 T) {\n    return (vec4(V, 0) * inverse(T)).xyz;\n}\n\n\n\n\n\n/*\n  ___ ___  ___   \n / __|   \\| __|__\n \\__ \\ |) | _(_-<\n |___/___/|_|/__/\n                 \n*/\n\n\n//A sphere SDF of center <center> and radius <radius>\nfloat sphereSDF (vec3 P, vec3 center, float radius) {\n    return distance(center, P) - radius;\n}\n\n\n//A rounded cylinder SDF of center p, radius ra, height h and rounded with rb (Credits to Inigo Quilez)\nfloat roundedCylinderSDF(vec3 P, vec3 p, float ra, float rb, float h )\n{\n    p = P - p;\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n/* A special SDF only used to render the wine bottle label. It is a rounded cylinder sdf (cf roundedCylinderSDF(...))\n * that fetches a color from the buffer A to render the text on the label, \"JFIG 2022\".\n*/\nfloat EtiquetteSDF(vec3 P, vec3 p, float ra, float rb, float h, out vec4 color) {\n    //cylinder projection\n    vec2 uv = vec2(0.5);\n    uv.y = (P - p).y / (h * 2.0) + 0.5;\n    vec3 n = P-p;\n    n.y = 0.0;\n    n = normalize(n);\n    float c = dot(n, vec3(1, 0, 0));\n    float s = dot(n, vec3(0, 0, 1));\n    if (s < 0.0) uv.x = 1.0 - acos(c) / 6.2831;\n    else uv.x = (acos(c) / 6.2831);\n    uv.x = uv.x * 2.0;\n    \n    //colors\n    if(texture(iChannel1, uv).r < 0.5) {\n        color = vec4(0, 0, 0, 0);\n    } else {\n        color = vec4(1, 1, 1, 0);\n    }\n    \n    //cylinder\n    p = P - p;\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\n\n\n\n/*\n  ___ ___  ___    ___ ___  __  __ ___  ___  ___ ___ _____ ___ ___  _  _ \n / __|   \\| __|  / __/ _ \\|  \\/  | _ \\/ _ \\/ __|_ _|_   _|_ _/ _ \\| \\| |\n \\__ \\ |) | _|  | (_| (_) | |\\/| |  _/ (_) \\__ \\| |  | |  | | (_) | .` |\n |___/___/|_|    \\___\\___/|_|  |_|_|  \\___/|___/___| |_| |___\\___/|_|\\_|\n      \n*/\n\n\n//Smooth min function, used to blend the SDFs together\nvec2 smin( float a, float b, float k) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    float m = h*h*0.5;\n    float s = m*k*(1.0/2.0);\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,1.0-m);\n}\n\n\n//mixes together two SDFs and two colors. Returns a new distance and a new color.\nfloat mixSDF (float a, float b, vec4 CA, vec4 CB, out vec4 C, float k) {\n    vec2 l = smin(a, b, k);\n    C = CB * (l.y) + CA * (1.0 - l.y);\n    return l.x;\n}\n\n\n//The SDF of the scene. Returns a distance and a color.\nfloat sceneSDF (vec3 P, out vec4 color) {\n    vec4 green = vec4(32, 79, 45, 64) / 255.0;\n    vec4 beige = vec4(235, 190, 113, 0) / 255.0;\n    vec4 white = vec4(1, 1, 1, 0);\n    vec4 gold = vec4(242, 212, 121, 255) / 255.0;\n    vec4 bordeau = vec4(92, 32, 46, 255) / 255.0;\n    vec4 black = vec4(vec3(0.02), 0.0);\n\n    // Black hole\n    float l = sphereSDF(P, vec3(0.0, 0.0, 20.0), 4.0);\n    color = black;\n    \n    \n    // Wine ring\n    float orbit = 11.0;\n    float period = 1.0;\n    float size = 1.0;\n    float height = 1.0;\n    \n    for (int i = 0; i < 20; i++) {\n        float rorbit = (rand(vec2(3 * i, 4 * i)) + 1.0) * orbit;\n        float rpediod = (rand(vec2(i, 2 * i)) + 1.0) * period;\n        float rsize = (rand(vec2(7 * i, 9 * i)) + 1.0) * size;\n        float rheight = (rand(vec2(21 * i, i)) + 1.0) * height;\n\n        mat4 T = T_Translate(vec3(sin(iTime * rpediod) * orbit, rheight - height, cos(iTime * rpediod) * (rorbit) + 20.0));\n        l = mixSDF(sphereSDF(T_GetPos(P, T), vec3(0), rsize),\n        l, bordeau, color, color, 3.0);\n    }\n    \n    // Wine Bottle\n    mat4 transform = \n          T_RotateY(iTime * 3.0) \n        * T_RotateX(1.0) \n        * T_RotateY(iTime * 2.0) \n        * T_Translate(vec3(sin(iTime * 0.75) * 25.0, 2, cos(iTime * 0.75) * 25.0 + 20.0));\n    \n    l = mixSDF(roundedCylinderSDF(T_GetPos(P, transform), vec3(0.0, 0.0, 0.0), 1.0, 0.5, 5.0), l, green, color, color, 0.01);    \n    l = mixSDF(sphereSDF         (T_GetPos(P, transform), vec3(0.0, 5.0, 0.0), 2.0), l, green, color, color, 0.01);\n    l = mixSDF(roundedCylinderSDF(T_GetPos(P, transform), vec3(0.0, 8.0, 0.0), 0.45, 0.2, 2.0), l, green, color, color, 0.5);\n    l = mixSDF(roundedCylinderSDF(T_GetPos(P, transform), vec3(0.0, 10.5, 0.0), 0.50, 0.2, 0.5), l, green, color, color, 0.2);\n    l = mixSDF(roundedCylinderSDF(T_GetPos(P, transform), vec3(0.0, 11, 0.0), 0.40, 0.25, 0.5), l, beige, color, color, 0.01);\n    vec4 c = vec4(0);\n    float e = EtiquetteSDF(T_GetPos(P, transform), vec3(0.0, 0, 0.0), 1.02, 0.2, 2.0, c);\n    l = mixSDF(e, l, c, color, color, 0.01);    \n    \n    \n    return l;\n}\n\n\n\n\n\n/*\n  ___ ___ _  _ ___  ___ ___ ___ ___ \n | _ \\ __| \\| |   \\| __| _ \\ __| _ \\\n |   / _|| .` | |) | _||   / _||   /\n |_|_\\___|_|\\_|___/|___|_|_\\___|_|_\\\n                                    \n*/\n\n\n//Uses a finite difference derivative to return the normal at a position P\nvec3 normal (vec3 P) {\n    vec4 c =  vec4(0);\n    return normalize(vec3(\n        sceneSDF(P + vec3(EPSILON, 0.0, 0.0),c),\n        sceneSDF(P + vec3(0.0, EPSILON, 0.0),c),\n        sceneSDF(P + vec3(0.0, 0.0, EPSILON),c)    \n    ) - sceneSDF(P, c));\n}\n\n\n//Trace a straight ray\nfloat sray (vec3 P, vec3 D, out vec4 C, out vec3 newP) {\n    float l = 0.0;\n    for (int i = 0; i < MAXITER; i++) {\n        float dist = sceneSDF(P, C);\n        if (dist <= EPSILON) {\n            newP = P;\n            return l;\n        }\n        P += D * dist;\n        l += dist;\n\n        if (l > INFINITY) {\n            newP = P;\n            return INFINITY;\n        }\n    }\n    newP = P;\n    return INFINITY;\n}\n\n\n//Returns the distance squared between A and B\nfloat distSquared(vec3 A, vec3 B) {\n    vec3 C = A - B;\n    return dot(C, C);\n}\n\n\n//Trace a curved ray, influenced by gravity\nfloat cray (vec3 P, vec3 D, out vec4 C, out vec3 newP) {\n    float l = 0.0;\n    float prevL = 0.0;\n    vec3 prevP = P;\n    for (int i = 0; i < MAXITER; i++) {\n    \n        float dist = sceneSDF(P, C);\n        \n        if (dist <= EPSILON) {\n            return prevL + sray(prevP, normalize(D), C, newP);\n        }\n        \n        vec3 center = P;\n        for (int j = 0; j < MAXITER; j++) {\n            vec3 force = normalize(GRAVITYLOCATION - P) * (gravityStrength / distSquared(GRAVITYLOCATION, P));\n            D += force;\n            prevP = P;\n            P = P + D;\n            prevL = l;\n            l += length(D);\n            if (distance(center, P) > dist) {\n                break;\n            }            \n        }\n        \n        if (l > INFINITY) {\n            newP = P;\n            return INFINITY;\n        }\n    }\n    newP = P;\n    return INFINITY;\n}\n\n\n//Returns a float from 0 to 1 representing the shadowing at a point ro. (Credits to Inigo Quilez)\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k ) {\n    float res = 1.0;\n    float ph = 1e20;\n    vec4 c;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t, c);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\n//Returns the shading at a point P\nvec3 shade (vec3 P, vec3 ld, vec3 lc) {\n    vec3 N = normal(P);\n    return max(0.0, dot(N, ld) * softshadow(P + N * EPSILON * 4.0, ld, 0.0, 15.0, 4.0)) * lc;\n}\n\n\n\n\n\n/*\n  __  __   _   ___ _  _ \n |  \\/  | /_\\ |_ _| \\| |\n | |\\/| |/ _ \\ | || .` |\n |_|  |_/_/ \\_\\___|_|\\_|\n                        \n*/\n\n\n// fires a curved ray in the current pixel, shade and print the returned position/color.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = vec2(min(RESOLUTION.x, iResolution.x), min(RESOLUTION.y, iResolution.y));\n    vec2 uv = (fragCoord + (rand2(fragCoord) * stratifiedSamplingStength) - vec2(0.5))/r;\n    if (uv.x > 1.0 || uv.y > 1.0) return;\n\n    \n    float ratio = iResolution.y / iResolution.x;\n\n    float t = 1.0;\n    vec3 P = vec3(0.0, 25.0 * sin(t / 5.0) + 4.0, -55.0);\n    vec3 D = normalize(vec3((uv - vec2(0.5) + vec2(0, -0.5) * sin(t / 5.0)) * vec2(1.0, ratio), 1)) * baseVelocity;\n    vec4 C;\n    vec3 newP;\n    \n    float l = cray(P, D, C, newP);\n    if (l < INFINITY) {\n        //Shading\n        C.rgb *= \n          shade(newP, normalize(vec3(0.5, 0.5, -1.0)), vec3(1.0, 0.95, 0.9) * 1.5) \n        + shade(newP, normalize(vec3(-0.5, 0.2, 1.0)), vec3(0.5, 0.8, 1.0) * 1.5) \n        + shade(newP, normalize(vec3(0.5, -0.1, -1.0)), vec3(1.0, 0.6, 0.5) * 0.5) \n        + vec3(1.0) * 0.2;\n        \n        //Reflections\n        if (C.a <= 0.5) { //Specular\n            vec3 col = C.rgb;\n            vec3 nrm = normal(newP);\n            C.rgb = col + texture(iChannel0, reflect(D, nrm)).rgb * C.a * 2.0;\n        } else { //\"Transparent\"\n            vec3 col = C.rgb;\n            vec3 nrm = normal(newP);\n            C.rgb = pow(col * 1.55, vec3(15.0)).rrr * texture(iChannel0, reflect(D, nrm)).rgb * 0.05;\n            C.rgb += pow(col * 1.5, vec3(2.0)) * texture(iChannel0, reflect(-D, nrm)).rgb * 1.5;\n        }\n    } else\n        C.rgb = texture(iChannel0, D).rgb * 3.0;\n   \n    fragColor = vec4(tanh(C.rgb), 1.0);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}