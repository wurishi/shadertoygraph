{"ver":"0.1","info":{"id":"MtcSzn","date":"1477692805","viewed":391,"name":"CS8EC","username":"4onen","description":"Simple line drawing animation of n-sided polygons for extra credit in the UCSB CS8 class.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Made by Matthew Dupree for fun. No profit, no credit.\n\n//Don't try stealing this to use for credit in CS8.\n//For one thing, you're probably not the only person in the class to find this.\n//If you both submit it and say \"Hey, look how smart we are!\" you two will\n//look pretty dumb to the academic counseling office.\n\n//Also, this is written in the wrong language. Go do your assignment in Python.\n\n//P.P.S. I know Python has an OpenGL library that could theoretically run this code\n//under the hood. That's not going to work either. The ShaderToy environment is\n//too complicated for someone in CS8 to replicate on-the-fly in Python.\n\n//Good luck!\n\n\n\n\n//The actual number of sides each polygon has in the shadertoy\n#define SIDE_COUNT 4\n//---------------------------------\n//CHANGE THE ABOVE VALUE FOR FUN!\n//---------------------------------\n\n//The maximum number of sides the polygon can have.\n//Necessary because loop counters can't be compared to dynamic numbers as the break condition.\n//Weird things happen if this is lower than SIDE_COUNT\n#define MAX_POLY_SIDE_COUNT 16\n\n//Pi. Does this really need explanation?\n#define PI 3.14159265358979323846264338\n\n//Used to rotate things.\n//Returns a matrix that'll rotate a vector2 by angle radians about the origin.\nmat2 rotation(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s\n               ,s,  c);\n}\n\n//Returns 1.0 when in the bounding box given\nfloat inBB(vec2 r, vec2 p1, vec2 p2){\n    if(((r.x<p1.x && r.x<p2.x)||(r.x>p1.x && r.x>p2.x))\n       ||(r.y<p1.y && r.y<p2.y)||(r.y>p1.y && r.y>p2.y))\n       return 0.0;\n    else\n       return 1.0;\n}\n\n//Returns 1.0 when in the _rectangle_ given\nfloat smoothProperRect(vec2 r, vec2 topLeft, vec2 botRight, float edgeBlur){\n    float ret;\n    ret  = smoothstep(topLeft.x-edgeBlur, topLeft.x+edgeBlur, r.x);\n    ret *= smoothstep(topLeft.y-edgeBlur, topLeft.y+edgeBlur, r.y);\n    ret *= 1.0 - smoothstep(botRight.y-edgeBlur, botRight.y+edgeBlur, r.y);\n    ret *= 1.0 - smoothstep(botRight.x-edgeBlur, botRight.x+edgeBlur, r.x);\n    return ret;\n}//Does the same, but doesn't require that you set the edge blur.\nfloat smoothProperRect(vec2 r, vec2 topLeft, vec2 botRight){\n    return smoothProperRect(r,topLeft,botRight,0.005);\n}\n\n//Returns 1.0 at the very center of the given circle, dropping linearly to the edge.\nfloat smoothPointBloom(vec2 r, vec2 center, float radius){\n    return 1.0-smoothstep(0.0,radius,length(center-r));\n}\n\n//Returns 1.0 when on the line given\nfloat line(vec2 r, vec2 p1, vec2 p2, float lineWidth){\n    vec2 midpointRSpace = (p1.xy+p2.xy)/2.0;\n    \n    float angle = atan((p1.y-p2.y)/(p1.x-p2.x));\n    \n    vec2 rotatedSpaceCord = (r-midpointRSpace)*rotation(-angle);\n    \n    float lineLength = length(p1-p2);\n    \n    return smoothProperRect(\n        rotatedSpaceCord,\n        vec2(-lineLength/2.0,-lineWidth/2.0),\n        vec2(lineLength/2.0,lineWidth/2.0),\n        lineWidth\n    );\n}\n\n//Returns 1.0 when on the described polygon's edge.\nfloat polygonWireframe(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    //If we're outside any possible radius, break.\n    if(length(r.xy-center.xy)>radius+lineWidth) return 0.0;\n    //If the side count makes no sense, break.\n    if(sideCount<1) return 0.0;\n    \n    float ret = 0.0;\n    \n    //Point radius length up from center:\n    vec2 p0 = vec2(0.0, radius);\n    //Angle of rotation swept by each edge:\n    float angle = 2.0*PI/float(sideCount);\n    \n    //Loop all possible sides\n    for(int i=0;i<MAX_POLY_SIDE_COUNT;i++){\n        //Loop all given sides\n        if(i>=sideCount) break;\n        vec2 p1 = p0*rotation(angle*float(i));\n        vec2 p2 = p1*rotation(angle);\n        ret += line(r, p1+center, p2+center, lineWidth);\n    }\n    return ret;\n}\n\n//Returns 1.0 if the given point is on one of the lines of the described polygons.\n//Used to render polygons at each tip of a given polygon.\nfloat polyPointedPoly(vec2 r, vec2 center, float radius, int sideCount, float lineWidth){\n    if(length(r.xy-center.xy)>radius+(radius*2.0/float(sideCount))+lineWidth) return 0.0;\n    \n    if(sideCount < 1) return 0.0;\n    \n    float ret = 0.0;\n    \n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    \n    for(int i=0; i<MAX_POLY_SIDE_COUNT;i++){\n        if(i>=sideCount) break;\n        vec2 p1 = p0*rotation(angle*float(i));\n        ret += polygonWireframe(r, center+p1, radius*2.0/float(sideCount), sideCount, lineWidth);\n    }\n    return ret;\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth vertex.\nvec2 getPolyPointN(vec2 center, float radius, int sideCount, int sideNum){\n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    return center + p0*rotation(angle*float(sideNum));\n}\n\n//Returns a vector 2 representing the position of this polygon's sideNumth point,\n//adjusted for time to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyPointNTimeAdjust(vec2 center, float radius, int sideCount, int sideNum, float time){\n    vec2 p0 = getPolyPointN(center, radius, sideCount, sideNum);\n    vec2 p1 = getPolyPointN(center, radius, sideCount, sideNum + 1);\n    return p0*time+p1*(1.0-time);\n}\n\n//Returns a vector2 representing the position of the sideNumth point of the polyNumth polygon,\n//adjusted for time to linearly phase toward the next side number.\n//Valid time values are 0.0 to 1.0\nvec2 getPolyOfPolysPointNTimeAdjust(vec2 center, float radius, int sideCount, int polyNum, int sideNum, float time){\n    vec2 p0 = vec2(0.0, radius);\n    float angle = 2.0*PI/float(sideCount);\n    vec2 p1 = p0*rotation(angle*float(polyNum));\n    return center + getPolyPointNTimeAdjust(p1, radius*2.0/float(sideCount), sideCount, sideNum, time);\n}\n\n//Main image, GLSL entry point\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Define our grid space\n    vec2 p = vec2(fragCoord.xy / iResolution.xy);\n    //Make an aspect ratio out of it and align the origin to the center of the screen\n    vec2 r = 1.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/(iResolution.y);\n    \n    //The current time, in two second loops.\n    float time = mod(iTime,2.0)/2.0;\n    \n    //A list of colors. Have fun messing with these!\n    const vec3 bgColor = vec3(0.25,0.0,0.3);\n    const vec3 polyColor = vec3(5.0,0.0,5.0);\n    const vec3 lineColor = vec3(1.0,0.99,1.0);\n    const vec3 capColor = vec3(1.0);\n    \n    const vec2 center = vec2(0.0);\n    const float radius = 0.3;\n    \n    vec3 ret = bgColor;\n    ret = mix(ret,polyColor,polyPointedPoly(r, center, radius, SIDE_COUNT, 0.001));\n    for(int side=0; side<MAX_POLY_SIDE_COUNT; side++){\n        if(side>=SIDE_COUNT) break;\n        \n        for(int poly=0; poly<MAX_POLY_SIDE_COUNT; poly++){\n            if(poly>=SIDE_COUNT) break;\n            \n            vec2 p0 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, poly, side, time);\n            vec2 p1 = getPolyOfPolysPointNTimeAdjust(center, radius, SIDE_COUNT, poly+1, side+1, time);\n            ret = mix(ret, lineColor, line(r, p0, p1, 0.002));\n            ret = mix(ret, capColor, smoothPointBloom(r, p0, 0.01));\n        }\n    }\n\tfragColor = vec4(ret,1.0);\n}","name":"Image","description":"","type":"image"}]}