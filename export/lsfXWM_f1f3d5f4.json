{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define M_PI 3.1415926535\n\nstruct ray {\n\tvec3 origin;\n\tvec3 direction;\n\tvec4 lightColor;\n\tfloat transmittance;\n\tfloat rayLength;\n\tint lastHitObject;\n};\n\n\n//Camera position setup\nvec3 startingLocation = vec3(0.0, 5.0, 15.0);\n\t\n//Floor setup\nconst vec4 sceneFloor = vec4(0.0, 1.0, 0.0, 0.0);\nconst float floorTransmission = 0.7;\n\n//Window setup\nconst vec4 sceneWindow = vec4(-1.0, 0.0, 0.0, -7.5);\nconst vec2 windowStart = vec2(-10.0, 1.0);\nconst vec2 windowWidthHeight = vec2(20.0, 15.0);\nconst float glassTransmission = 0.5;\n\n//Random meaningless sphere setup\nconst vec4 sceneSphere = vec4(0.0, 3.0, 3.0, 3.0);\nconst float sphereTransmission = 0.5;\n\n//Light setup\nvec4 light = vec4(-480.0, 0.0, 0.0, 110.0);\n\nconst float tau = 6.28318530717958647692;\n\n// Using modified Fast Voronoi Pattern (https://www.shadertoy.com/view/Msl3Rl) for the stained glass effect\n// Created by Ben Weston - 2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec4 Rand( ivec2 pos ) {\n\treturn texture( iChannel0, (.5+vec2(pos.xy))/256.0, -100.0 );\n}\n\nvec3 Voronoi( vec2 pos ) {\n\tvec2 d[8];\n\td[0] = vec2(0);\n\td[1] = vec2(1,0);\n\td[2] = vec2(0,1);\n\td[3] = vec2(1);\n\t\n\tconst float maxDisplacement = .7;//.518; //tweak this to hide grid artefacts\n\t\n\tfloat closest = 12.0;\n\tvec4 result;\n\tfor ( int i=0; i < 8; i++ )\n\t{\n\t\tvec4 r = Rand(ivec2(floor(pos+d[i])));\n\t\tvec2 p = d[i] + maxDisplacement*(r.xy-.5);\n\t\tp -= fract(pos);\n\t\tfloat lsq = dot(p,p);\n\t\tif ( lsq < closest )\n\t\t{\n\t\t\tclosest = lsq;\n\t\t\tresult = r;\n\t\t}\n\t}\n\treturn fract(result.xyz+result.www); // random colour\n}\n\nmat4 rotateX(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(1.0, 0.0, 0.0, 0.0,\n\t\t\t\t0.0, cosTheta, -sinTheta, 0.0,\n\t\t\t\t0.0, sinTheta, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 rotateY(float theta) {\n\tfloat cosTheta = cos(theta);\n\tfloat sinTheta = sin(theta);\n\treturn mat4(cosTheta, 0.0, sinTheta, 0.0,\n\t\t\t\t0.0, 1.0, 0.0, 0.0,\n\t\t\t\t-sinTheta, 0.0, cosTheta, 0.0,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translate(vec3 v) {\n\treturn mat4(1.0, 0.0, 0.0, v.x,\n\t\t\t\t0.0, 1.0, 0.0, v.y,\n\t\t\t\t0.0, 0.0, 1.0, v.z,\n\t\t\t\t0.0, 0.0, 0.0, 1.0);\n}\n\nfloat iPlane(in ray sceneRay, in vec4 plane) {\n\treturn -(dot(sceneRay.origin, normalize(plane.xyz)) + plane.w) / dot(sceneRay.direction, plane.xyz);\n}\n\nfloat iRectangle(in ray sceneRay, in vec4 plane, in vec2 constraintsXY, in vec2 widthHeight, out vec2 uvCoord) {\n\tfloat planeIntersection = iPlane(sceneRay, plane);\n\tvec3 hitPoint = sceneRay.origin + sceneRay.direction*planeIntersection;\n\tif (hitPoint.z < constraintsXY.x || hitPoint.z > constraintsXY.x+widthHeight.x) {\n\t\tplaneIntersection = -1.0;\n\t}\n\telse if (hitPoint.y < constraintsXY.y || hitPoint.y > constraintsXY.y+widthHeight.y) {\n\t\tplaneIntersection = -1.0;\n\t}\n\t\n\tif (planeIntersection >= 0.0) {\n\t\tuvCoord = vec2(hitPoint.z - constraintsXY.x, hitPoint.y - constraintsXY.y);\n\t}\n\telse {\n\t\tuvCoord = vec2(-1.0);\n\t}\n\treturn planeIntersection;\n}\n\nvec2 iSphere(in ray sceneRay, in vec4 sph) {\n\t//sphere at origin has equation |xyz| = r\n\t//so |xyz|^2 = r^2.\n\t//Since |xyz| = rayOrigin + t*rayDirection (where t is the distance to move along the ray),\n\t//we have rayOrigin^2 + 2*rayOrigin*t*rayDirection + t^2 - r^2. This is a quadratic equation, so:\n\tvec3 oc = sceneRay.origin - sph.xyz; //distance ray origin - sphere center\n\t\n\tfloat b = dot(oc, sceneRay.direction);\n\tfloat c = dot(oc, oc) - sph.w * sph.w; //sph.w is radius\n\tfloat h = b*b - c; //Commonly known as delta. The term a is 1 so is not included.\n\t\n\tvec2 t;\n\tif(h < 0.0) \n\t\tt = vec2(-1.0);\n\telse  {\n\t\tfloat sqrtH = sqrt(h);\n\t\tt.x = (-b - sqrtH); //Again a = 1.\n\t\tt.y = (-b + sqrtH);\n\t}\n\treturn t;\n}\n\n//Get sphere normal.\nvec3 nSphere(in vec3 pos, in vec4 sph) {\n\treturn normalize((pos - sph.xyz)/sph.w);\n}\n\nfloat fancyLight(ray primaryRay, vec4 light) {\n\tfloat luminance = 0.0;\n\t//vector from origin to light center\n\tvec3 originToLight = light.xyz - primaryRay.origin;\n\t\n\t//check to see if the light is behind us\n\tif(dot(primaryRay.direction, originToLight) >= 0.0) {\n\t\t//see if our ray is within the light boundary\n\t\tvec3 nearest = -(originToLight\n\t\t\t\t\t\t + primaryRay.direction * dot(-originToLight, primaryRay.direction));\n\t\tfloat dist = length(nearest);\n\t\tif(dist <= light.w) {\n\t\t\tfloat lightness = (light.w - dist) / light.w;\n\t\t\tluminance = pow(lightness, 22.0);\n\t\t}\n\t}\n\treturn luminance;\n}\n\n//check for ray intersection against scene elements\nint intersect(in ray sceneRay, out vec2 t, out vec2 uvCoord) {\n\tt = vec2(1000.0);\n\tint hitId = -1;\n\t\n\t//check against the floor\n\tfloat tFloor = iPlane(sceneRay, sceneFloor);\n\tif (tFloor > 0.0 && tFloor < t.x) {\n\t\tt = vec2(tFloor);\n\t\thitId = 0;\n\t}\n\t\n\t//check against the stained glass window\n\tfloat tWindow = iRectangle(sceneRay, sceneWindow, windowStart, windowWidthHeight, uvCoord);\n\tif (tWindow > 0.0 && tWindow < t.x) {\n\t\tt = vec2(tWindow);\n\t\thitId = 1;\n\t}\n\t\n\tvec2 tSphere = iSphere(sceneRay, sceneSphere);\n\tif (tSphere.x > 0.0 && tSphere.x < t.x) {\n\t\tt = tSphere;\n\t\thitId = 2;\n\t}\n\t\n\treturn hitId;\n}\n\nvec4 doLighting(vec3 eyePoint, vec3 objPoint, vec3 normalAtPoint, vec3 lightPos, vec4 lightParams) {\n\tfloat fresnelBias = lightParams.x;\n\tfloat fresnelPower = lightParams.y;\n\tfloat fresnelScale = lightParams.z;\n\tfloat constAttenuation = 9000000.0;\n\tfloat linearAttenuation = 0.22;\n\tfloat quadraticAttenuation = 0.2;\n\tfloat dist = length(lightPos-objPoint);\n\tfloat attenuation = constAttenuation / ((1.0+linearAttenuation*dist)*(1.0+quadraticAttenuation*dist*dist));\n\tfloat shininess = lightParams.w;\n\tvec3 I = normalize(objPoint - eyePoint);\n\tvec3 lightDirection = normalize(lightPos-objPoint);\n\tvec3 viewDirection = normalize(eyePoint-objPoint);\n\tvec3 halfVector = normalize(lightDirection + viewDirection);\n\tfloat dif = clamp(dot(normalAtPoint, lightDirection), 0.0, 1.0);\n\tfloat spec = max(0.0, pow(dot(normalAtPoint, halfVector), shininess));\n\tfloat fresnel = clamp(fresnelBias + fresnelScale * pow(1.0 + dot(I, normalAtPoint), fresnelPower), 0.0, 1.0);\n\treturn attenuation * vec4(vec3(mix(spec, dif, fresnel)), 1.0);\n}\n\nvec4 doLighting(vec3 eyePoint, vec3 objPoint, vec3 normalAtPoint, vec3 lightPos) {\n\tfloat fresnelBias = 0.25;\n\tfloat fresnelPower = 5.0;\n\tfloat fresnelScale = 1.0;\n\tfloat shininess = 20.0;\n\tvec4 lightParams = vec4(fresnelBias, fresnelPower, fresnelScale, shininess);\n\treturn doLighting(eyePoint, objPoint, normalAtPoint, lightPos, lightParams); \n}\n\nvoid doShadowColor(in ray primaryRay, inout vec4 col) {\n\tvec4 returnColor = vec4(0.0);\n\tvec2 shadowUV;\n\tvec2 shadowT;\n\tint shadowId;\n\tfloat shadowCheckDelta = light.w;\n\tray shadowRay;\n\tshadowRay.lightColor = primaryRay.lightColor;\n\tshadowRay.transmittance = primaryRay.transmittance;\n\tvec3 pos = primaryRay.origin + primaryRay.rayLength*primaryRay.direction;\n\tshadowRay.origin = pos - 0.001*primaryRay.direction;\n\tfor (int i = 0; i < 7; i++) {\n\t\t//soft shadows\n\t\tif (i == 0) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.x += shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 1) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.x -= shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 2) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.y += shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 3) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.y -= shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 4) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.z += shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse if (i == 5) {\n\t\t\tvec4 tempLight = light;\n\t\t\ttempLight.z -= shadowCheckDelta;\n\t\t\tshadowRay.direction = normalize(tempLight.xyz-pos);\n\t\t}\n\t\telse\n\t\t\tshadowRay.direction = normalize(light.xyz-pos);\n\t\tshadowId = intersect(shadowRay, shadowT, shadowUV);\n\t\tvec3 shadowHit = shadowRay.origin + shadowT.x * shadowRay.direction;\n\t\t\n\t\t//if we have a non-negative id, we've hit something\n\t\tif (shadowId >= 0 && primaryRay.lastHitObject >= 0) {\n\t\t\tvec4 tempColor;\n\t\t\tif (light.y > 0.0) {\n\t\t\t\tif (primaryRay.lastHitObject != 1\n\t\t\t\t\t&& shadowId == 1\n\t\t\t\t\t&& length(light.xyz-shadowRay.origin) > length(shadowHit-shadowRay.origin)) {\n\t\t\t\t\t//shade objects that are shadowed by the window\n\t\t\t\t\tvec3 nor = sceneWindow.xyz;\n\t\t\t\t\tshadowRay.lightColor = doLighting(primaryRay.origin, shadowHit, nor, light.xyz);\n\t\t\t\t\tshadowRay.lightColor *= 1.0 - vec4(Voronoi(shadowUV),1.0);\n\t\t\t\t\tshadowRay.transmittance = primaryRay.transmittance * glassTransmission;\n\t\t\t\t\ttempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);\n\t\t\t\t}\n\t\t\t\telse if (primaryRay.lastHitObject == 1) {\n\t\t\t\t\t//shade the back side of the window\n\t\t\t\t\tvec3 nor = -sceneWindow.xyz;\n\t\t\t\t\tshadowRay.lightColor = doLighting(primaryRay.origin, shadowHit, nor, light.xyz);\n\t\t\t\t\tshadowRay.lightColor *= vec4(Voronoi(shadowUV),1.0);\n\t\t\t\t\tshadowRay.transmittance = primaryRay.transmittance * glassTransmission;\n\t\t\t\t\ttempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);\n\t\t\t\t}\n\t\t\t\tif (primaryRay.lastHitObject != 1 && shadowId != 1) {\n\t\t\t\t\t//shadows for everything else in the scene\n\t\t\t\t\tshadowRay.lightColor = shadowRay.lightColor;\n\t\t\t\t\tshadowRay.transmittance = 0.5*primaryRay.transmittance;\n\t\t\t\t\ttempColor = mix(shadowRay.lightColor, col, 1.0-shadowRay.transmittance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (primaryRay.lastHitObject >= 0) {\n\t\t\t\t//before \"sunrise\"\n\t\t\t\tshadowRay.lightColor = shadowRay.lightColor;\n\t\t\t\tshadowRay.transmittance = 0.5*primaryRay.transmittance;\n\t\t\t\ttempColor = mix(shadowRay.lightColor, col, shadowRay.transmittance);\n\t\t\t}\n\t\t\treturnColor += tempColor;\n\t\t}\n\t}\n\t//if we use a number slightly higher than our iteration count,\n\t//then we get dark, but not black, shadows.  This also washes\n\t//out the color of the color of the glass, so it's kind of a\n\t//trade-off.\n\tcol -= returnColor*(1.0/8.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//pixel coordinates from 0 to 1\n\tfloat aspectRatio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tfloat time = mod(0.1*iTime, M_PI);\n\tfloat sinTime = sin(time);\n\tlight.y = light.y + 500.0 * sinTime-100.0;\n\tlight.z = 450.0 * cos(time);\n\t\n\tvec2 mouse0To2PI = iMouse.xy/iResolution.xy*2.0*M_PI;\n\tmat4 cameraRotation = rotateY(mouse0To2PI.x);\n\tvec4 ro = vec4(startingLocation, 1.0);\n\tmat4 compound = translate(-ro.xyz) * cameraRotation * translate(ro.xyz);\n\tro = compound * ro;\n\t\n\t//generate a ray with origin ro and direction rd\n\tray primaryRay;\n\tprimaryRay.origin = ro.xyz;\n\tprimaryRay.direction = (cameraRotation * vec4(normalize(vec3( (-1.0+2.0*uv) * vec2(aspectRatio, 1.0), -1.0)), 1.0)).xyz;\n\tprimaryRay.lightColor = vec4(1.0);\n\tprimaryRay.transmittance = 1.0;\n\tprimaryRay.rayLength = -1.0;\n\tprimaryRay.lastHitObject = -1;\n\t\n\tray traceRay = primaryRay;\n\t\n\t\n\tvec4 col = vec4(1.0);\n\t//intersect the ray with scene\n\tvec2 uvCoord;\n\tvec2 t;\n\t//did we hit something?\n\tfor (int i = 0; i < 8; i++) {\n\t\tint id = intersect(traceRay, t, uvCoord);\n\t\tif (traceRay.transmittance > 0.01) {\n\t\t\ttraceRay.lastHitObject = id;\n\t\t\tif (primaryRay.lastHitObject < 0)\n\t\t\t\tprimaryRay.lastHitObject = traceRay.lastHitObject;\n\t\t\t//find the point where we hit\n\t\t\ttraceRay.rayLength = t.x;\n\t\t\tif (primaryRay.rayLength < 0.0)\n\t\t\t\tprimaryRay.rayLength = traceRay.rayLength;\n\t\t\t\n\t\t\tvec3 pos = traceRay.origin + traceRay.rayLength*traceRay.direction;\n\t\t\ttraceRay.origin = pos + 0.001 * traceRay.direction;\n\t\t\t\n\t\t\tif (id == 0) {\n\t\t\t\tcol = doLighting(primaryRay.origin, pos, sceneFloor.xyz, light.xyz);\n\t\t\t\ttraceRay.direction = reflect(traceRay.direction, sceneFloor.xyz);\n\t\t\t\ttraceRay.transmittance *= floorTransmission;\n\t\t\t\ttraceRay.lightColor = col;\n\t\t\t\tvec4 groundTextureColor = texture(iChannel1, 0.125*pos.xz, 0.0);\n\t\t\t\tcol = mix(primaryRay.lightColor, col, traceRay.transmittance);\n\t\t\t\tcol *= vec4(groundTextureColor.rgb, 1.0);\n\t\t\t}\n\t\t\telse if (id == 1) {\n\t\t\t\ttraceRay.lightColor = vec4(Voronoi(uvCoord),1.0);\n\t\t\t\ttraceRay.transmittance *= glassTransmission;\n\t\t\t\tray glassRay = traceRay;\n\t\t\t\ttraceRay.direction = reflect(traceRay.direction, sceneWindow.xyz);\n\t\t\t\t//did we hit something after the glass?\n\t\t\t\tint id = intersect(glassRay, t, uvCoord);\n\t\t\t\tif (id != 1 && glassRay.transmittance > 0.0) {\n\t\t\t\t\tglassRay.lastHitObject = id;\n\t\t\t\t\tglassRay.rayLength = t.x;\n\t\t\t\t\t\n\t\t\t\t\t//do stained glass coloring on the other side... effectively another shadow call\n\t\t\t\t\tvec4 stainedShadowColor = col;\n\t\t\t\t\t//This appears to break in Firefox, but not Chrome:\n\t\t\t\t\t//doShadowColor(glassRay, stainedShadowColor);\n\t\t\t\t\tvec3 pos = glassRay.origin + glassRay.rayLength*glassRay.direction;\n\t\t\t\t\t\n\t\t\t\t\tif (id == 0) {\n\t\t\t\t\t\tvec4 groundTextureColor = texture( iChannel1, 0.125*pos.xz, 0.0 );\n\t\t\t\t\t\tcol = mix(groundTextureColor, col, 1.0-glassRay.transmittance);\n\t\t\t\t\t}\n\t\t\t\t\tvec4 lighting = 0.25*doLighting(primaryRay.origin, pos, sceneFloor.xyz, light.xyz);\n\t\t\t\t\tcol = mix(lighting, col, 1.0-glassRay.transmittance);\n\t\t\t\t\t\n\t\t\t\t\tcol = mix(stainedShadowColor, col, 1.0-glassRay.transmittance);\n\t\t\t\t\t\n\t\t\t\t\tcol = mix(glassRay.lightColor, col, 1.0-glassRay.transmittance);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (id == 2) {\n\t\t\t\tvec3 sphNormal = nSphere(pos, sceneSphere);\n\t\t\t\ttraceRay.direction = reflect(traceRay.direction, sphNormal);\n\t\t\t\ttraceRay.transmittance *= sphereTransmission;\n\t\t\t\tfloat fresnelBias = 0.25;\n\t\t\t\tfloat fresnelPower = 5.0;\n\t\t\t\tfloat fresnelScale = 1.0;\n\t\t\t\tfloat shininess = 5.0;\n\t\t\t\tvec4 lightParams = vec4(fresnelBias, fresnelPower, fresnelScale, shininess);\n\t\t\t\tcol = doLighting(primaryRay.origin, pos, sphNormal, light.xyz, lightParams);\n\t\t\t\ttraceRay.lightColor = col;\n\t\t\t\tcol = mix(traceRay.lightColor, col, traceRay.transmittance);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//sky\n\t\t\t\tcol = vec4(0.7*sinTime, 0.65*sinTime, sinTime, 1.0);\n\t\t\t\ttraceRay.lightColor = col;\n\t\t\t}\n\t\t}\n\t}\n\tif (primaryRay.lastHitObject < 0 || primaryRay.lastHitObject == 1) {\n\t\tif (light.y > 0.0) {\n\t\t\tfloat lightValue = 2.0*fancyLight(primaryRay, light);\n\t\t\tcol += vec4(vec3(1.0-col.rgb)*lightValue*primaryRay.lightColor.rgb, 1.0);\n\t\t}\n\t}\n\t\n\tdoShadowColor(primaryRay, col);\n\t\n\tfragColor = clamp(col, vec4(0.0), vec4(1.0));\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lsfXWM","date":"1402363733","viewed":1219,"name":"Stained","username":"slade","description":"A little ray tracing experiment with colored light transmittance and Fresnel reflectance with Voronoi \"stained glass\".  Mouse left/right to rotate the scene.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ray","light","glass","transmittance","fresnel","trace","stained"],"hasliked":0,"parentid":"","parentname":""}}