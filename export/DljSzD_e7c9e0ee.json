{"ver":"0.1","info":{"id":"DljSzD","date":"1675775763","viewed":119,"name":"2D grid stretching","username":"MatheoMoinet","description":"Press \"g\"to toggle Perlin noise vs grid mode. \"n\" to switch additive and multiplicative noise.\n\"c\" for color mode. \"f\" for texture.\n\"space\" to toggle deformation.\n\"1' to deform 4-neigh, \"2\" for 8-neigh, \"3\" for 4-neigh+1.\n\"t\" to scale grid with time.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["mapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"2D grid stretching\" by MatheoMoinet. https://shadertoy.com/view/DljSzD\n// 2023-02-08 15:47:21\n\nconst int NOISE_OCTAVE = 5;\nconst float NOISE_SCALE = 2.;\n\n#define USE_COLOR 1\n\n#if USE_COLOR\nvec3[nbr_of_points] point_colors = vec3[](\n    vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.), vec3(1.,0.,0.),\n    vec3(0.,0.,1.), vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.),\n    vec3(0.,1.,0.), vec3(0.,0.,1.), vec3(1.,0.,0.), vec3(0.,1.,0.),\n    vec3(1.,0.,0.), vec3(0.,1.,0.), vec3(0.,0.,1.), vec3(1.,0.,0.)\n);\n#endif\n\nint g_id(ivec2 x){\n    return (x.x + (grid_size.x-1-x.y)*grid_size.x);\n}\n\nfloat get_value_at_pos(vec2 pos){\n    float noise = keyToggle(78.) ? noise_mul(pos*NOISE_SCALE,NOISE_OCTAVE) : noise_sum(pos*NOISE_SCALE,NOISE_OCTAVE);\n    float val = noise;\n    \n    if (keyToggle(71.)){\n        // -1: small grid, -2: big grid, -3: corners \n        val = any(lessThan(mod(pos,0.1), vec2(0.01))) ? -1.: 0.;\n        val = any(lessThan(mod(pos,1.), vec2(0.01))) ? -2.: val;\n        val = all(lessThan(mod(pos,1.), vec2(0.05))) ? -3.: val;\n        val = all(greaterThan(mod(pos,1.), vec2(1.-0.05))) ? -3.: val;\n    }\n    return val;\n}\n\n\n\nvec2 get_pos_in_grid(vec2 grid_coords){\n    vec2 text_coords = (grid_coords+0.5)/iResolution.xy;\n    vec2 pos = texture(iChannel1, text_coords).xy;\n    pos *=vec2(grid_size);\n    pos*= keyToggle(84.) ? mod(iTime/25.,0.9)+0.1: 1.;\n    return pos;\n}\n\n\nfloat get_value_in_grid2(vec2 grid_coords){\n    vec2 pos = get_pos_in_grid(grid_coords);\n    float val = get_value_at_pos(pos);\n    return val ;\n}\n\n#if USE_COLOR\nvec3 get_col_at_grid(ivec2 grid_idx){\n    int idx = g_id(grid_idx);\n    vec3 col = point_colors[idx];\n    return col;\n}\n#endif\n\nvec3 get_color_at_pos(vec2 pos){\n    vec3 col;\n    #if USE_COLOR\n    ivec2 grid_id = ivec2(pos);\n    vec2 grid_sub_coords = fract(pos);\n    vec3 colx1 = mix(get_col_at_grid(grid_id),get_col_at_grid(grid_id+ivec2(1,0)), grid_sub_coords.x );\n    vec3 colx2 = mix(get_col_at_grid(grid_id+ivec2(0,1)),get_col_at_grid(grid_id+ivec2(1,1)), grid_sub_coords.x );\n    col = mix(colx1, colx2, grid_sub_coords.y);\n    #endif\n    col = keyToggle(70.) ? texture(iChannel0, pos/(vec2(grid_size)-1.)).xyz : col;\n    return col;\n}\n\nvec3 get_color_in_grid(vec2 grid_coords){\n    vec2 pos = get_pos_in_grid(grid_coords);\n    vec3 col = get_color_at_pos(pos);\n    col = keyToggle(70.) ? texture(iChannel0, pos/(vec2(grid_size)-1.)).xyz : col;\n    return col ;\n}\n\nvec2 uv2grid_coords(vec2 uv){\n    float grid_range = 1.-2.*bottom_margin;\n    vec2 grid_coords = (uv + grid_range)/(2.*grid_range);\n    grid_coords *= float(grid_size-1);\n    return grid_coords;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n    vec2 mStart_uv = 2.*(abs(iMouse.zw)-(0.5*iResolution.xy)).xy/iResolution.y;\n    vec2 mCurr_uv = 2.*(iMouse.xy-(0.5*iResolution.xy)).xy/iResolution.y;\n    \n    //iMouse_uv *= mouseClicked && !keyToggle(32) ? 1.:0.;\n    \n    vec3 col = vec3(0.);\n    \n    \n    float grid_range = 1.-2.*bottom_margin;\n    if (all(lessThan( abs(uv), vec2(grid_range)))){\n        col = vec3(1.);\n\n        vec2 grid_coords = uv2grid_coords(uv);\n        \n        col = vec3(1.) * get_value_in_grid2(grid_coords);\n        col = keyToggle(67.) ? vec3(1.) * get_color_in_grid(grid_coords) : col;\n        \n        switch(int(col.x)){\n            case -1:\n                col = vec3(1.,1.,1.);\n                break;\n            case -2:\n                col = vec3(0.,1.,0.);\n                break;\n            case -3:\n                col = vec3(1.,1.,0.);\n                break;\n        }\n        \n        \n        ivec2 grid_id = ivec2(grid_coords);\n        vec2 grid_sub_coords = grid_coords - vec2(grid_id);\n        if (any(lessThan(grid_sub_coords, vec2(0.005)))){\n            col = vec3(1.,0.,0.);\n        }\n        if (any(greaterThan(grid_sub_coords, vec2(1.-0.005)))){\n            col = vec3(1.,0.,0.);\n        }\n        \n    } \n    \n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec2 get_pos_at_grid(ivec2 grid_idx){\n    vec2 pos = vec2(grid_idx);\n    return pos;\n}\n\n\nvec2 uv2grid_coords(vec2 uv){\n    float grid_range = 1.-2.*bottom_margin;\n    vec2 grid_coords = (uv + grid_range)/(2.*grid_range);\n    grid_coords *= float(grid_size-1);\n    return grid_coords;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord.xy-(0.5*iResolution.xy))/iResolution.y;\n    vec2 mStart_uv = 2.*(abs(iMouse.zw)-(0.5*iResolution.xy)).xy/iResolution.y;\n    vec2 mCurr_uv = 2.*(iMouse.xy-(0.5*iResolution.xy)).xy/iResolution.y;\n    \n    //iMouse_uv *= mouseClicked && !keyToggle(32) ? 1.:0.;\n    vec2 pos;\n    \n    if (fragCoord.x < float(grid_size.x) && fragCoord.y < float(grid_size.y)){\n        ivec2 grid_id = ivec2(fragCoord);\n        vec2 pos_displasment;\n        if (mouseClicked && !keyToggle(32)){\n            vec2 mStart_grid_coords = uv2grid_coords(mStart_uv);\n            vec2 mCurr_grid_coords = uv2grid_coords(mCurr_uv);\n            ivec2 mouse_grid_id = ivec2(mStart_grid_coords);\n            vec2 mouse_mvmt = mCurr_grid_coords - mStart_grid_coords;\n            \n            ivec2 mouse_cell_dif = abs(grid_id-mouse_grid_id);\n            //int manat_dist_mouse = mouse_cell_dif.x + mouse_cell_dif.y;\n            float dist_mouse = length(vec2(mouse_cell_dif));\n            \n            float accepted_dist = 0.;\n            \n            if (keyToggle(49.) || keyToggle(50.) || keyToggle(51.)){\n                accepted_dist  = 1.;\n            }\n            if (keyToggle(50.) || keyToggle(51.)){\n                accepted_dist = 1.5; // sqrt(2)\n            }\n            if (keyToggle(51.)){\n                accepted_dist = 2.;\n            }\n            \n            if (dist_mouse <= accepted_dist){\n                pos_displasment = mouse_mvmt;\n            }\n        }\n        \n        pos = get_pos_at_grid(grid_id);\n        pos +=pos_displasment;\n        \n        pos /= vec2(grid_size);\n        \n    }\n    \n    // Output to screen\n    fragColor = vec4(pos, 0.0,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 grid_size = ivec2(4,4);\nconst int nbr_of_points = grid_size.x * grid_size.y;\nconst float bottom_margin = 0.02;\n\n\n\n#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n#define mouseUp      ( iMouse.z < 0. )                  // mouse up even:   mouse button released (well, not just that frame)\n#define mouseDown    ( iMouse.z > 0. && iMouse.w > 0. ) // mouse down even: mouse button just clicked\n#define mouseClicked ( iMouse.w < 0. )                  // mouse clicked:   mouse button currently clicked\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash22(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n\n\n#define rand_unit_vector(p) normalize(2.*hash22(p)-1.)\nfloat perlin_noise(vec2 p,float grid_size)\n{\n    p*=grid_size;\n\tvec2 pi = floor(p);\n    vec2 pf = p-pi;\n    \n    vec2 w = pf*pf*(3.-2.*pf);\n    \n    \n    float f00 = dot(rand_unit_vector(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(rand_unit_vector(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(rand_unit_vector(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(rand_unit_vector(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n    \n    float ym = mix(xm1,xm2,w.y); \n    \n    return ym*1./sqrt(1./2.);\n   \n}\n\nfloat noise_sum(vec2 p,int octave){\n\tfloat a = 1., r = 0., s=0.;\n    \n    for (int i=0; i<octave; i++) {\n      r += a*perlin_noise(p,1.); s+= a; p *= 2.; a*=.5;\n    }\n    \n    return r/s;\n}\n\nfloat noise_mul(vec2 p,int octave){\n\tfloat r = 1., s=1.;\n    for (float i=0.; i<float(octave); i+=1.){\n        r *= smoothstep(-0.5,0.5, perlin_noise(p,1.))*2.;\n        s *= 2.;     \n        p*=2.;\n    }\n    return r/s;\n}","name":"Common","description":"","type":"common"}]}