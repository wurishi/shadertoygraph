{"ver":"0.1","info":{"id":"dtscD8","date":"1690714676","viewed":55,"name":"Water physic","username":"tacos_au_chili","description":"YOU CAN GRAB THE PARTICLES\na shader who display a water simulation with particles\nit's very instable","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["waterphysicsmoothmin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PRECISION 50\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n//Main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame%2==0)discard;\n    vec3 color;\n\n    vec2 r = iResolution.xy;\n    \n    int size = getInt(iChannel0,ivec2(0,0)).x;\n    \n    vec3 points[particlesNumber];\n    for(int i = 0;i<size;i++)\n        points[i] = get(iChannel0,ivec2(0,i+1))*r.xyy;\n    vec3 p = vec3(fragCoord,0);\n    \n    float dist=10000.0;\n    \n    for(int i = 0;i<size;i++)\n        dist = smin(dist,distance(points[i],p),smoothVal);\n    \n    color = mix(hsv2rgb(vec3(dist/10.0,1.0,0.2)),vec3(0,1,1),vec3(smoothstep(21.0,20.0,dist)));\n    \n    \n    //Draw points\n    /*\n    color = mix(color,vec3(1,0,0),smoothstep(7.0,5.0,distance(p,a)));\n    color = mix(color,vec3(1,0,0),smoothstep(7.0,5.0,distance(p,b)));\n    color = mix(color,vec3(1,0,0),smoothstep(7.0,5.0,distance(p,c)));\n    color = mix(color,vec3(1,0,0),smoothstep(7.0,5.0,distance(p,d)));\n    */\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Points array storage:\nivec2 U;\nvec3 O;\n\nbool set(ivec2 p,vec3 val){\n    if(p==U){\n        O=val;\n        return true;\n    }\n    return false;\n}\nvec3 intToCol(ivec3 v){\n    return vec3(v)/2.0/float(maxInt)+0.5;\n}\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    U=ivec2(FragCoord);\n    O=get(iChannel0,U);\n    int size = getInt(iChannel0,ivec2(0,0)).x;\n    vec2 pos = get(iChannel0,ivec2(0,U.y)).xy*iResolution.xy;\n    \n    if(iMouse.z>0.0){\n        if(getInt(iChannel0,ivec2(1,0)).r==0){\n            int r = 0;\n            float dMin = distance(iMouse.xy,get(iChannel0,ivec2(0,1)).xy*iResolution.xy);\n            for(int i = 1;i<size;i++){\n                float dist=distance(iMouse.xy,get(iChannel0,ivec2(0,i+1)).xy*iResolution.xy);\n                if(dist<dMin){\n                    dMin=dist;\n                    r=i;\n                }\n            }\n            set(ivec2(1,0),intToCol(ivec3(r+1)));\n        }\n        else{\n            if(set(ivec2(0,getInt(iChannel0,ivec2(1,0)).r),vec3(iMouse.xy/iResolution.xy,0.0))){\n                pos = iMouse.xy;\n            }\n        }\n    }else set(ivec2(1,0),intToCol(ivec3(0)));\n    \n    set(ivec2(1.0/get(iChannel0,ivec2(0)).g-1.0,1.0),vec3(iMouse.xy/iResolution.xy,0.0));\n    \n    \n    //Updating\n    \n    if(U.x==0&&U.y>0&&U.y<=size+1){\n        \n        \n        pos.y-=1.0;\n        //Resolve\n        for(int i = 0;i<size;i++){\n            if(i+5!=U.y){\n                    for(int j = 0;j<10;j++){\n                    vec2 partPos = get(iChannel0,ivec2(0,i+1)).xy*iResolution.xy;\n                    float d = distance(pos,partPos);\n                    if(d<particleRadius)pos =mix(pos,partPos+ normalize(pos-partPos)*particleRadius,liquidity);\n                    pos=clamp(vec2(particleRadius),pos,iResolution.xy-particleRadius);\n                }\n            }\n        }\n        set(U,vec3(pos/iResolution.xy,0));\n    }\n    \n    if(iFrame==0){\n        size = particlesNumber;\n        set(ivec2(0,0),intToCol(ivec3(size,0,0)));\n        for(int i = 0;i<size;i++)\n            set(ivec2(0,i+1),vec3(float(i)/float(size-1),random(float(i)+float(size)*float(seed)),0));\n    }\n    FragColor=vec4(O,1);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define maxInt 10000\n#define particlesNumber 30\n#define particleRadius 30.0\n#define liquidity 0.01\n#define seed 0\n#define smoothVal 3.0\n//Buffer getting\nvec3 get(sampler2D channel,ivec2 p){\n    return texelFetch(channel,ivec2(p),0).rgb;\n}\nivec3 getInt(sampler2D channel,ivec2 p){\n    return ivec3(round((get(channel,p)-0.5)*float(maxInt)*2.0));\n}\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n// Pseudo-random value in half-open range [0:1].\nfloat random( float  v ) { return floatConstruct(hash(floatBitsToUint(v))); }","name":"Common","description":"","type":"common"}]}