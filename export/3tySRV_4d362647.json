{"ver":"0.1","info":{"id":"3tySRV","date":"1583107451","viewed":125,"name":"The Lighting Equation","username":"srishti87","description":"The Lighting Equation - A tutorial for calculating ray intersection with sphere and applying the ambient, diffuse and specular lighting.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["light"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Ray represents a ray of light's origin and direction\nstruct Ray {\n\tvec3 origin; // Origin\n\tvec3 direction; // Direction\n};\n\n// Sphere represents of centre and radius of a sphere\nstruct Sphere {\n\tvec3 center;  // Center\n\tfloat radius; // Radius\n};\n\nvec4 diffuse(in vec3 pointOnSurface, in vec3 center, in vec4 color, in vec3 litePos) {\n\t// Surface normal\n\tvec3 n = normalize(pointOnSurface - center);\n\t\n\t// Light direction from surface\n\tvec3 l = normalize(litePos - pointOnSurface);\n\n\t// The diffuse equation\n\treturn color * max(0.0, dot(n, l));\n}\nvec4 specular(in vec3 eyePos, in vec3 litePos, in vec3 pointOnSurface, in vec3 center, in vec4 color, float shininess)\n{\n    // Surface normal\n\tvec3 n = normalize(pointOnSurface - center);\n\t\n\t// Light direction from surface\n\tvec3 l = normalize( litePos- pointOnSurface);\n\n    //directionof viewing\n    vec3 v = normalize(eyePos- pointOnSurface );\n\tvec3 halfwayVect = normalize(v+l);\n    float mgls = 8.0;\n    float spe = pow(clamp(dot(halfwayVect, n), 0.0, 1.0), mgls);;\n    return  spe * color * shininess;\n    \n}\n\nfloat intersectSphere(in Ray ray, in Sphere sphere) {\n\t// Sphere center to ray origin\n\tvec3 co = ray.origin - sphere.center;\n\n\t// The discriminant is negative for a miss, or a postive value\n\t// used to calcluate the distance\n\tfloat discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n\t\t\t- (dot(co, co) - sphere.radius * sphere.radius);\n\n\t// If answer is not negative, calculate the origin-surface distance\n\tif (discriminant >= 0.0)\n\t\treturn -dot(ray.direction, co) - sqrt(discriminant); //\n\telse\n\t\treturn -1.; // Any negative number to indicate no intersect\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t// Converting all coordinates (x,y) to be in the range [0,1]\n\tfloat x = fragCoord.x / iResolution.x; // iResolution.x is width in pixels\n\tfloat y = fragCoord.y / iResolution.x; // iResolution.y is height in pixels\n\n\t// Now convert from coordinate range [0,1] to [-1,1]\n\t// This moves pixel (0,0) to the middle of the screen\n    // This coordinate system is a common convention\n\tx = x * 2.0 - 1.0;\n\ty = y * 2.0 - 0.5;\n\n    // For raytracing, we need a ray - i.e. a direction and a point of origin\n    // The direction is the pixel position minus the eye postition,\n    // which is normalized.\n    // Normailizing makes rayDir a unit of distance (as well as direction)\n    \n\t// The pixel position in 3D space - i.e. the z value, 0.0, is the plane of the screen.\n\tvec3 pixelPos = vec3(x, y, 0);\n\n    // The eye position in this example is fixed.\n    vec3 eyePos = vec3(0, 0, -2); // Some distance in front of the screen\n    \n\t// The ray for the raytrace - which is just intersectSphere in this tutorial\n\tvec3 rayDir = normalize(pixelPos - eyePos);\n    \n    Sphere sphere = Sphere(vec3(0.0, 0.0, 8.0), 2.0); // Position and size of sphere\n\n\t// Does rayDirUnit ray from ndcEye intersect the sphere?\n\tfloat eyeToSphere = intersectSphere(Ray(eyePos, rayDir), sphere);\n\n\t// If positive, then we draw a pixel of the sphere\n\tif (eyeToSphere >= 0.)\n\t{\n\t\t// Choose an ambient colour\n\t\tvec4 ambientColour =  vec4(0.0,0.2,0.,1);\n\n        // Position of a white light\n        vec3 litePos = vec3(3., 0., 0.);\n        fragColor = ambientColour;\n        \n\t\t// Choose a diffuse colour\n\t\tvec4 diffuseColour =  vec4(0.,0.5,0.5,1);\n        fragColor +=  diffuse(eyePos + eyeToSphere * rayDir, sphere.center, diffuseColour, litePos);\n        \n        // Choose an specular colour\n        vec4 specularColour =  vec4(0.7,0.3,0.6,1);\n        float shininess =1.0;\n        fragColor +=  specular(eyePos,litePos, (eyePos + eyeToSphere * rayDir), sphere.center, specularColour, shininess);\n\n\t} else\n        // Otherwise we draw the colour of the background\n\t\tfragColor = vec4(0, 0, 0, 1);\n    fragColor.rgb = pow(fragColor.rgb,vec3(1.0/2.2));\n}\n\n","name":"Image","description":"","type":"image"}]}