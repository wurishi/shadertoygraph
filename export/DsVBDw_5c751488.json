{"ver":"0.1","info":{"id":"DsVBDw","date":"1698280398","viewed":72,"name":"Simple infinte-state CA","username":"laserbat","description":"Looks better in full screen. The main computation is done in \"Buffer A\" tab. Click to randomize all cells.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SQRT_3 1.73205080757\n#define ZOOM 2.0\n\n// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float val = texelFetch(iChannel0, ivec2(fragCoord / ZOOM), 0).x;\n    \n    // Arbitrary values to create semi-random colors\n    fragColor.r = fract(val * 137.0);\n    fragColor.g = fract(val * 713.0);\n    fragColor.b = fract(val * 435.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define GET(d) texelFetch(iChannel0, ivec2(fragCoord + vec2(d)), 0).x\n#define swap(x, y) if (vals[x] > vals[y]) {float t = vals[y]; vals[y] = vals[x]; vals[x] = t;};\n\n#define M 16777216\n\n// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    float a = fract(co.x * 10.5 + co.y * 7.5 + fract(iDate.a));\n    a = fract(715.5 * a * a + 57.1 * co.x);\n    a = fract(1371.5 * a * a + 757.1 * co.y);\n    return a;\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Randomize initial state on 0th frame or if mouse button is pressed\n    if (iFrame <= 0 || iMouse.z > 0.0) {\n        fragColor.x = noise(fragCoord/iResolution.xy);\n    } else {\n    \tivec2 d;\n        \n        float vals[9];\n        int hash = 0;\n\n        int i = 0;\n\n    \tfor(d.y = -1; d.y <= +1; d.y++)\n        \tfor(d.x = -1; d.x <= +1; d.x++){\n                vals[i] = GET(d);\n                \n                hash += int(vals[i] * float(M));\n                    \n                i += 1;\n             }\n        \n        // Sort the array using a sorting network\n        swap(0, 1);\n        swap(3, 4);\n        swap(6, 7);\n        swap(1, 2);\n        swap(4, 5);\n        swap(7, 8);\n        swap(0, 1);\n        swap(3, 4);\n        swap(6, 7);\n        swap(0, 3);\n        swap(3, 6);\n        swap(0, 3);\n        swap(1, 4);\n        swap(4, 7);\n        swap(1, 4);\n        swap(2, 5);\n        swap(5, 8);\n        swap(2, 5);\n        swap(1, 3);\n        swap(5, 7);\n        swap(2, 6);\n        swap(4, 6);\n        swap(2, 4);\n        swap(2, 3);\n        swap(5, 6);\n\n        fragColor.x = vals[hash % 9];\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}