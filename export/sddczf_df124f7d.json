{"ver":"0.1","info":{"id":"sddczf","date":"1653882259","viewed":94,"name":"3D rock","username":"kovaxis","description":"Infinite procedural rocks made from a simple process of cutting planes out.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","rock"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_STEPS = 100;\nconst float MAX_DIST = 100.;\nconst float SURF_DIST = .01;\nconst float PHI = 2.39996322973;\n\nfloat rayMarch(vec3 ro, vec3 rd);\nvec3 getNormal(vec3 p);\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nmat3 rot3(vec3 axis, float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(\n        oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n        oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n        oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n    );\n}\n\nfloat plane(vec3 p, vec3 pl) {\n    float n = length(pl);\n    return dot(p, pl) / n - n;\n}\n\nfloat cube(vec3 p, vec3 r) {\n    p = abs(p) - r;\n    return max(p.x, max(p.y, p.z));\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nvec3 fibpoint(float i, float n) {\n    float y = 1. - i * (2. / n);\n    float r = sqrt(1. - y*y);\n    float theta = PHI * i;\n    float x = sin(theta) * r;\n    float z = -cos(theta) * r;\n    return vec3(x, y, z);\n}\n\nfloat rock(float seed, vec3 p, float N) {\n    float noise = 0.5;\n    float regularity = 1.;\n    float thin = 1.;\n    \n    seed = rand(vec2(seed, 1.23));\n    float d = -MAX_DIST;\n    float d2 = MAX_DIST;\n    for(float i = 0.36; i <= N; i += 1.) {\n        float r = rand(vec2(seed+i, floor(iTime / 2.)));\n        vec3 n = vec3(r, fract(r*123.2), fract(r * 48.3)) * 2. - 1.;\n        n = fibpoint(i, N) + noise * n;\n        n *= vec3(1, thin, 1);\n        n = mix(n, normalize(n), regularity);\n        \n        d = max(d, plane(p, n));\n        d2 = min(d2, sphere(p - n, 0.05));\n    }\n    //d = min(d, d2);\n    //d = d2;\n    return d;\n}\n\nfloat getDist(vec3 p){\n    \n    float d = MAX_DIST;\n    \n    //d = min(d, p.y);\n    \n    //p = rot3(vec3(1,0,0), 0.6) * p;\n    float rd = rock(1., p - vec3(0, 0.5, 0), 12.);\n    //rd = max(rd, -rock(2., p - vec3(1, 0, 0), 8.));\n    d = min(d, rd);\n    \n    return d;\n}\n\nvec3 getColor(vec3 p) {\n    vec3 n = getNormal(p);\n    //return n * .5 + .5;\n    \n\n \tvec3 lightPos = vec3(-5., 5., 6.);\n    //lightPos.xz += vec2(cos(iTime), sin(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    float diff = clamp(dot(l, n)*.5+.5, 0., 1.);\n    \n    //float d = rayMarch(p+n*SURF_DIST*2., l);\n    //if(d < length(p-lightPos)) diff*= .1;\n    return vec3(diff);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd){\n\tfloat dO = 0.;\n        \n  \tfor(int i = 0; i < MAX_STEPS; i++){    \t\n   \t\tvec3 p = ro + rd*dO;\n        float ds = getDist(p);\n        dO += ds;\n        if(ds < SURF_DIST || dO > MAX_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 getNormal(vec3 p){\n\tvec2 e = vec2(.01, .0);\n    float d = getDist(p);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy - .5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec2 rot = mouse * vec2(6., 3.);\n    mat3 cam = rot3(vec3(0, 1, 0), -rot.x) * rot3(vec3(1, 0, 0), rot.y);\n    \n    vec3 ro = cam * vec3(0, 0, -8);\n    vec3 rd = cam * normalize(vec3(uv.x, uv.y, 1.));\n    \n    ro += vec3(0, 1, 0);\n    float d = rayMarch(ro, rd);\n    if (d < MAX_DIST) {\n        vec3 p = ro + rd*d;\n        col = getColor(p);\n    }\n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}