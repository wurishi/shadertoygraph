{"ver":"0.1","info":{"id":"Xc2BWy","date":"1725560631","viewed":43,"name":"Slime Mold Simulation 1 - DJ","username":"DjBlueBear","description":"A simulation of slime mold inspired by Sebastian Lague's video on slime mold and ant colony simulation \nhttps://www.youtube.com/watch?v=X-iSQQgOd1A","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["simulation","slimemold","slimemold"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 buffer1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 buffer2 = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 buffer3 = texelFetch(iChannel3, ivec2(fragCoord), 0);\n\n\n\n    fragColor = vec4(buffer0.w,buffer1.w, 0.0, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nconst float randWalk = 0.01;\n\nconst float decayRate = 1.01;\n\nconst float trailWeight = 1.0;\n\nconst float sensorGap = 3.0;//the horizontal distance between the left and right sensors\nconst float sensorSize = 1.0;//double the size of each sensor in pixels, each sensor is a square\nconst float sensorDistance = 3.0;//the forward distance from the agent of all the sensors\nconst float sensorOffset = 1.0;// the forward offset of the forward sensor from the other sensors\n\nconst float maxTurnSpeed = 0.3;\n  \nfloat sense(in vec2 position, in float angle)\n{\n    vec2 dir = vec2(cos(angle), sin(angle));\n    \n    float forwardSensor = 1.0;\n    float rightSensor = 0.0;\n    float leftSensor = 0.0;\n    \n    vec2 offset = dir * sensorDistance;\n    vec2 forwardOffset = dir * sensorOffset;\n    vec2 leftOffset = vec2(cos(angle + (pi / 2.0)), sin(angle + (pi / 2.0)));\n    vec2 rightOffset = vec2(cos(angle - (pi / 2.0)), sin(angle - (pi / 2.0)));\n\n    int total = 0;\n    \n    for(float y = -sensorSize; y <= sensorSize; y++)\n    {\n        for(float x = -sensorSize; x <= sensorSize; x++)\n        {\n            total += 1;\n\n            forwardSensor += texelFetch(iChannel0, ivec2(mod(position + vec2(x,y) + offset + forwardOffset, iResolution.xy)), 0).w;\n            leftSensor += texelFetch(iChannel0, ivec2(mod(position + vec2(x,y) + offset + leftOffset, iResolution.xy)), 0).w;\n            rightSensor += texelFetch(iChannel0, ivec2(mod(position + vec2(x,y) + offset + rightOffset, iResolution.xy)), 0).w;\n            \n            forwardSensor -= texelFetch(iChannel2, ivec2(mod(position + vec2(x,y) + offset + forwardOffset, iResolution.xy)), 0).w;\n            leftSensor -= texelFetch(iChannel2, ivec2(mod(position + vec2(x,y) + offset + leftOffset, iResolution.xy)), 0).w;\n            rightSensor -= texelFetch(iChannel2, ivec2(mod(position + vec2(x,y) + offset + rightOffset, iResolution.xy)), 0).w;\n        }\n    }\n    forwardSensor /= float(total);\n    rightSensor /= float(total);\n    leftSensor /= float(total);\n    \n    float rotation = (leftSensor - rightSensor) / forwardSensor;\n    \n    return clamp(rotation, -maxTurnSpeed, maxTurnSpeed);\n}\n\nvoid updateAgent(inout vec2 position, inout float rotation, inout uint seed)\n{\n    rotation += (rand(seed) * 2.0 - 1.0) * tau * randWalk;\n\n    vec2 dir = vec2(cos(rotation), sin(rotation));\n    position += dir;\n    position = mod(position, iResolution.xy);\n\n    rotation += sense(position, rotation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 buffer1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    vec2 position = buffer0.xy;\n    float rotation = buffer0.z;\n    float trail = buffer0.w;\n\n    trail /= decayRate;\n\n    if(buffer1.x > 0.0)\n    {\n        trail += trailWeight;\n    }\n    \n\n    uint seed = uint((fragCoord.x * iResolution.y + fragCoord.y)  * float(iFrame));//mod(float(iFrame) + iDate.w, 1024.0));\n\n    if(iFrame == 1)\n    {\n        position = randVec3(seed).xy * iResolution.xy;//whatever you want the starting position to be;\n        rotation = rand(seed) * tau;\n        trail = 0.01;\n        fragColor = vec4(position.xy, rotation, trail);\n        return;\n    }\n\n    uint id = uint(floor(fragCoord.y) * iResolution.x + fragCoord.x);\n \n    if(id > agentNumA)\n    {\n        fragColor = vec4(0.0,0.0,0.0,trail);\n        return;\n    }\n \n    updateAgent(position, rotation, seed);\n    \n    fragColor = vec4(position.xy, rotation, trail);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nconst float randWalk = 0.01;\n\nconst float decayRate = 1.01;\n\nconst float trailWeight = 0.5;\n\nconst float sensorGap = 3.0;//the horizontal distance between the left and right sensors\nconst float sensorSize = 1.0;//double the size of each sensor in pixels, each sensor is a square\nconst float sensorDistance = 3.0;//the forward distance from the agent of all the sensors\nconst float sensorOffset = 1.0;// the forward offset of the forward sensor from the other sensors\n\nconst float maxTurnSpeed = 0.3;\n  \nfloat sense(in vec2 position, in float angle)\n{\n    vec2 dir = vec2(cos(angle), sin(angle));\n    \n    float forwardSensor = 1.0;\n    float rightSensor = 0.0;\n    float leftSensor = 0.0;\n    \n    vec2 offset = dir * sensorDistance;\n    vec2 forwardOffset = dir * sensorOffset;\n    vec2 leftOffset = vec2(cos(angle + (pi / 2.0)), sin(angle + (pi / 2.0)));\n    vec2 rightOffset = vec2(cos(angle - (pi / 2.0)), sin(angle - (pi / 2.0)));\n    \n    for(float y = -sensorSize; y < sensorSize; y++)\n    {\n        for(float x = -sensorSize; x < sensorSize; x++)\n        {\n            forwardSensor += texelFetch(iChannel0, ivec2(mod(position + vec2(x,y) + offset + forwardOffset, iResolution.xy)), 0).w;\n            leftSensor += texelFetch(iChannel0, ivec2(mod(position + vec2(x,y) + offset + leftOffset, iResolution.xy)), 0).w;\n            rightSensor += texelFetch(iChannel0, ivec2(mod(position + vec2(x,y) + offset + rightOffset, iResolution.xy)), 0).w;\n            \n            forwardSensor -= texelFetch(iChannel2, ivec2(mod(position + vec2(x,y) + offset + forwardOffset, iResolution.xy)), 0).w;\n            leftSensor -= texelFetch(iChannel2, ivec2(mod(position + vec2(x,y) + offset + leftOffset, iResolution.xy)), 0).w;\n            rightSensor -= texelFetch(iChannel2, ivec2(mod(position + vec2(x,y) + offset + rightOffset, iResolution.xy)), 0).w;\n        }\n    }\n    \n    float rotation = (leftSensor - rightSensor) / forwardSensor;\n    \n    return clamp(rotation, -maxTurnSpeed, maxTurnSpeed);\n}\n\nvoid updateAgent(inout vec2 position, inout float rotation, inout uint seed)\n{\n    rotation += (rand(seed) * 2.0 - 1.0) * tau * randWalk;\n\n    vec2 dir = vec2(cos(rotation), sin(rotation));\n    position += dir;\n    position = mod(position, iResolution.xy);\n\n    rotation += sense(position, rotation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 buffer1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    \n    vec2 position = buffer0.xy;\n    float rotation = buffer0.z;\n    float trail = buffer0.w;\n\n    trail /= decayRate;\n\n    if(buffer1.y > 0.0)\n    {\n        trail += trailWeight;\n    }\n\n    uint seed = uint((fragCoord.x * iResolution.y + fragCoord.y)  * float(iFrame)) + 1u;//mod(float(iFrame) + iDate.w, 1024.0));\n\n    if(iFrame == 1)\n    {\n        position = randVec3(seed).xy * iResolution.xy;//whatever you want the starting position to be;\n        rotation = rand(seed) * tau;\n        trail = 0.01;\n        fragColor = vec4(position.xy, rotation, trail);\n        return;\n    }\n\n    uint id = uint(floor(fragCoord.y) * iResolution.x + fragCoord.x);\n \n    if(id > agentNumB)\n    {\n        fragColor = vec4(0.0,0.0,0.0,trail);\n        return;\n    }\n \n    updateAgent(position, rotation, seed);\n\n    fragColor = vec4(position.xy, rotation, trail);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    vec4 buffer1 = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    vec4 buffer2 = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    vec4 buffer3 = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    \n    if(buffer0.w > 0.0 || iFrame == 1)\n    {\n        for(uint i = 0u; i < agentNumA; i++)\n        {\n            float x = mod(float(i), iResolution.x);\n            float y = floor(float(i) / iResolution.x);\n            vec2 pos = texelFetch(iChannel0, ivec2(x,y), 0).xy;\n        \n            if(distance(pos, fragCoord) <= trailSizeA)\n            {\n                fragColor.x = 1.0;\n                break;\n            }\n        }\n    }\n    \n    if(buffer1.w > 0.0 || iFrame == 1)\n    {\n        for(uint i = 0u; i < agentNumB; i++)\n        {\n            float x = mod(float(i), iResolution.x);\n            float y = floor(float(i) / iResolution.x);\n            vec2 pos = texelFetch(iChannel1, ivec2(x,y), 0).xy;\n        \n            if(distance(pos, fragCoord) <= trailSizeB)\n            {\n                fragColor.y = 1.0;\n                break;\n            }\n        }\n    }\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct agent{\n    vec2 pos;\n    float angle;\n};\n\nconst float trailSizeA = 0.5;\nconst float trailSizeB = 0.5;\n\nconst uint agentNumA = 500u;\nconst uint agentNumB = 500u;\n\nconst float pi = 3.141592653;\nconst float tau = 6.28318530718;\nconst float deg2Rad = pi / 180.0;\n\nuint hash(inout uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\n\nfloat rand(inout uint seed)\n{\n    seed += 1u;\n    return fract(float(hash(seed))/ 4294967296.0);//4294967296 ! 2 ^ 32 ! 32 bit unsigned integer limit\n}\n\nfloat randNorm(inout uint seed)\n{   \n    float theta = 2.0 * pi * rand(seed);\n    float rho = sqrt( -2.0 * log(rand(seed)));\n    return rho * cos(theta);\n}\n\nvec3 randVec3(inout uint seed)\n{\n    float rand0 = rand(seed);\n    float rand1 = rand(seed);\n    float rand2 = rand(seed);\n\n    return vec3(rand0, rand1, rand2);\n}\n\nvec3 randVec3Norm(inout uint seed)\n{\n    float rand0 = randNorm(seed);\n    float rand1 = randNorm(seed);\n    float rand2 = randNorm(seed);\n\n    return normalize(vec3(rand0, rand1, rand2));\n}","name":"Common","description":"","type":"common"}]}