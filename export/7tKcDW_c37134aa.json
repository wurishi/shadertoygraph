{"ver":"0.1","info":{"id":"7tKcDW","date":"1662455146","viewed":213,"name":"Multiple Phong Shading Examples","username":"H2ongzh","description":"A sample for Physical Based Shading \n1. Phong (left, bottom)\n2. Blinn Phong (left, top)\n3. Normalized Blinn Phong (right, top)  \n4. Normalized Blinn Phong with Fresnel Term (right, bottom)\nRef: http://renderwonk.com/publications/s2010-shading-course/","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: HongZhang\n// Date: 08/26/2022\n\n#define PI 3.141592653\n#define FOV 45.\n#define rad(x) x * PI / 180.\n#define MaxV 1e10\n#define Gramma(x) pow(x, vec3(1./2.2))\n\n// Camera\nconst vec3 cam = vec3(0., 0., 3.5);\n\n// define the SDF for sphere\nfloat sphereSDF(vec3 p, float radius){\n    return length(p) - radius;\n}\n\nvec3 sphereNormal(vec3 p){\n    return normalize(p);\n}\n\n// compute the view direction\nvec3 computeView(vec2 uv){\n    uv = (uv - 0.5) * 2.;\n    float h = tan(rad(FOV)/2.);\n    float w = h * (iResolution.x / iResolution.y);\n    return normalize(vec3(w * uv.x, h * uv.y, -1.));\n}\n\n// compute the sphere-line intersection \nvec2 computeIntersection(vec3 origin, vec3 ray, float radius){\n    float factor = pow(dot(origin, ray), 2.) - (dot(origin, origin) - radius * radius);\n    if(factor >= 0.){\n        float t1 = -dot(origin, ray) - sqrt(factor);\n        float t2 = -dot(origin, ray) + sqrt(factor);\n        return vec2(t1, t2);\n    }\n    return vec2(MaxV, -MaxV);\n}\n\n// get the light \nvoid getLight(out vec3 pos, out vec3 col){\n   pos = 5. * vec3(cos(iTime), 0.5, sin(iTime));\n   col = vec3(1.);\n}\n\n\n// Attributes For Materials \nstruct MaterialAttr{\n    vec3 col_a; // ambient\n    vec3 col_d; // diffuse\n    vec3 col_s; // spec\n    float roughness;\n};\n\n// Fresnel Term\n// Schlick Approximation\n// norm could be the normal of the surface or the half-way normal\nvec3 Fschlick(vec3 col0, vec3 l_dir, vec3 norm){\n    return col0 + (1. - col0) * pow(1. - dot(l_dir, norm), 5.);\n}\n\n// Phong Shading (PS)\nvec4 PS(MaterialAttr mat, vec3 p, vec3 norm, vec3 view, vec3 l_pos, vec3 l_col){\n    vec3 l_dir = normalize(l_pos - p);\n    vec3 ambient = mat.col_a;\n    vec3 diffuse = mat.col_d * max(0., dot(norm, l_dir)) ;\n    \n    vec3 v_ref = normalize(view + 2. * norm * dot(-view, norm)); // reflected view\n    vec3 spec = mat.col_s * pow(max(0., dot(v_ref, l_dir)), mat.roughness);\n    \n    vec4 res = vec4((ambient + diffuse + spec) * l_col, 1.);\n    return res;\n}\n\n// Blinn Phong Shading  (BPS)\nvec4 BPS(MaterialAttr mat, vec3 p, vec3 norm, vec3 view, vec3 l_pos, vec3 l_col){\n    vec3 l_dir = normalize(l_pos - p);\n    vec3 ambient = mat.col_a;\n    vec3 diffuse = mat.col_d * max(0., dot(norm, l_dir)) ;\n    \n    vec3 half_norm = normalize(l_dir - view); // half-way normal\n    vec3 spec = mat.col_s * pow(max(0., dot(half_norm, norm)), mat.roughness);\n    \n    vec4 res = vec4((ambient + diffuse + spec) * l_col, 1.);\n    return res; \n}\n\n// Normalized Blinn Phong Shading (NBPS)\nvec4 NBPS(MaterialAttr mat, vec3 p, vec3 norm, vec3 view, vec3 l_pos, vec3 l_col){\n    vec3 l_dir = normalize(l_pos - p);\n    vec3 ambient = mat.col_a;\n    vec3 diffuse = mat.col_d * max(0., dot(norm, l_dir)) ;\n    \n    vec3 half_norm = normalize(l_dir - view); // half-way normal\n    float normalized_factor = (mat.roughness + 2.) / 8.;\n    vec3 spec = mat.col_s * normalized_factor *  pow(max(0., dot(half_norm, norm)), mat.roughness);\n    \n    vec4 res = vec4((ambient + diffuse + spec) * l_col, 1.);\n    return res; \n}\n\n// Normalized Blinn Phong Shading With Fresnel Term (NBPSF)\n// BRDF: ambient + diffuse * (1 - fresnel) + fresnel * specular\n// where the spec term is represented by (2. + r) / 8 * (h . n) ^ r * (n . l)\n// h: the half-way normal\n// n: the normal of the surface\n// l: the direction of light\n// r: the roughness \nvec4 NBPSF(MaterialAttr mat, vec3 p, vec3 norm, vec3 view, vec3 l_pos, vec3 l_col){\n    vec3 l_dir = normalize(l_pos - p);\n    vec3 ambient = mat.col_a;\n    vec3 diffuse = mat.col_d * max(0., dot(norm, l_dir)) ;\n    \n    vec3 half_norm = normalize(l_dir - view); // half-way normal\n    float normalized_factor = (mat.roughness + 2.) / 8.;\n    vec3 fresnel_col_spec = Fschlick(mat.col_s, l_dir, half_norm);\n    vec3 spec = fresnel_col_spec * normalized_factor *  pow(max(0., dot(half_norm, norm)), mat.roughness);\n    spec *= max(0., dot(l_dir, norm));\n    \n    diffuse *= (1. - fresnel_col_spec);\n    \n    vec4 res = vec4((ambient + diffuse + spec) * l_col, 1.);\n    return res; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // divide the screen into 4 parts \n    float n = 2.;\n    vec2 uv_i = floor(uv * n);  // integer\n    vec2 uv_f = fract(uv * n);  // fractions\n    \n    if(abs(uv.x - 1./n) - 0.002 < 0. || abs(uv.y - 1./n) - 0.002 < 0.){\n        fragColor = vec4(1.);\n        return;\n    }\n    \n    // 1. get the light info\n    vec3 l_pos, l_col;\n    getLight(l_pos, l_col);\n    \n    // 2. compute the view dir\n    vec3 view = computeView(uv_f);\n    \n    float radius = 1.;\n    // 3. compute the sphere-view intersections\n    vec2 t = computeIntersection(cam, view, radius);\n    if(t == vec2(MaxV, -MaxV)){\n        fragColor = vec4(vec3(0.1), 1.);\n        return;\n    }\n    \n    // 4. the intersection\n    vec3 point = cam + min(t.x, t.y) * view;\n    vec3 norm = sphereNormal(point);\n    \n    // 5. set the material\n    MaterialAttr obj = MaterialAttr(vec3(0.02),\n                                         vec3(0.5),\n                                         vec3(0.17),\n                                         64. + 48. * sin(iTime*2.));\n    \n    // 6.shading \n    // 6.1. Phong Shading \n    if(uv_i.x == 0. && uv_i.y == 0.){\n        vec4 color = PS(obj, point, norm, view, l_pos, l_col);\n        fragColor = vec4(Gramma(color.xyz), 1.);\n        return;\n    }\n    \n    // 6.2. Blinn Phong Shading \n    if(uv_i.x == 0. && uv_i.y == 1.){\n        vec4 color = BPS(obj, point, norm, view, l_pos, l_col);\n        fragColor = vec4(Gramma(color.xyz), 1.);\n        return;\n    }\n    \n    // 6.3. Normalized Blinn Phong Shading \n    if(uv_i.x == 1. && uv_i.y == 1.){\n        vec4 color = NBPS(obj, point, norm, view, l_pos, l_col);\n        fragColor = vec4(Gramma(color.xyz), 1.);\n        return;\n    }\n    \n    // 6.4. Normalized Blinn Phong Shading With Fresnel Term for specular color\n    if(uv_i.x == 1. && uv_i.y == 0.){\n        vec4 color = NBPSF(obj, point, norm, view, l_pos, l_col);\n        fragColor = vec4(Gramma(color.xyz), 1.);\n        return;\n    }\n    \n}","name":"Image","description":"","type":"image"}]}