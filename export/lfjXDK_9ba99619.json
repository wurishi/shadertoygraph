{"ver":"0.1","info":{"id":"lfjXDK","date":"1706852104","viewed":76,"name":"Pac World","username":"michaelbrand","description":"My first ray marching experiment on Shadertoy. It includes a flyover of a mazelike truchet wall patten with stationary yellow balls and bouncing lit-up red balls. Features luminescence, radiance, reflectivity, shadows, antialiasing and motion blur.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","bouncingballs","maze","luminescence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Pac World\"\n// Copyright Michael Brand, 2024.\n// Distributed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license.\n// Contact e-mail: shader@brand.scso.com\n\n\n#define PI 3.14159265358979\n#define SQRT2 1.4142135623730951\n#define G 9.8\n\n#define MAXMARCHSTEPS 200\n#define EPSILON 0.001\n#define MAXREFLECT 2\n#define AA 1\n#define BLUR 1\n\n// Dithering\n#define SUBPIXEL\n#define SUBFRAME\n\n// Enable for night mode\n// #define NIGHTMODE\n#define INTERMITTENTNIGHT\n\n// Flashing: Disable if slow\n// #define RADIANCE\n#define INTERMITTENTRADIANCE\n#define PBCOL vec3(1.0, 0.0, 0.0)\n#define BLINKFREQ 1.0\n\n\n#define MAZESIZE 10.0\n#define WALLHEIGHT 2.5\n#define WALLTHICKNESS 1.0\n#define BALLRADIUS 1.0\n#define BALLHEIGHT 1.25\n#define BALLSEP (2.5 * SQRT2)\n#define POWERBALLRADIUS 1.5\n#define POWERBALLHEIGHT 1.75\n#define POWERBALLSEP (10.0 * MAZESIZE)\n#define TILESIZE 3.0\n#define MINHEIGHT 5.0\n#define MAXHEIGHT 30.0\n#define NIGHTLENGTH 10.0\n\n// #define PINK\n// #define BLUE\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( (p+0.5347)*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nmat2x2 rot( float angle )\n{\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat2x2(c, s, -s, c);\n}\n\nvec2 wallcoord( vec2 board, vec2 delta )\n{\n    vec2 bd = board / MAZESIZE;\n    vec2 gridpoint = floor(bd);\n    float orientation = step(0.5, hash1(gridpoint)) * 2.0 - 1.0;\n    vec2 pos = fract(bd) + (delta / MAZESIZE) - 0.5;\n    mat2x2 matrot = rot(orientation * PI * 0.25);\n    pos = matrot * pos;\n    pos.y = abs(pos.y);\n    pos.y = abs(pos.y - SQRT2 * 0.25);\n    return MAZESIZE * pos;\n}\n\nvec2 sdf_perturb( vec3 pos, vec3 delta, float curr_time )\n{\n  vec2 dist = vec2(2.0, pos.y + delta.y); // Plane\n  \n  // The closest objects are always in the current gridpoint, never in +-1.\n  vec2 coord = wallcoord(pos.xz, delta.xz);\n  float wdist = length(vec2(coord.y, max(pos.y+delta.y-WALLHEIGHT, 0.0))) - WALLTHICKNESS;\n  if (wdist < dist.y) {\n    dist = vec2(3.0, wdist); // Wall\n  }\n\n  vec2 pbpos = POWERBALLSEP * (0.5 - abs(fract(pos.xz / POWERBALLSEP) + (delta.xz / POWERBALLSEP) - 0.5));\n  vec2 pbid = floor((pos.xz / POWERBALLSEP) - 0.5);\n  float maxheight = hash1(pbid) * (MAXHEIGHT-MINHEIGHT) + MINHEIGHT;\n  float phase = hash1(pbid.yx);\n  float revolution = sqrt(8.0 * maxheight / G);\n  float time = mod(curr_time + phase, revolution) - revolution * 0.5;\n  float height = maxheight - 0.5 * G * time * time;\n  \n  float pdist = length(vec3(pbpos, pos.y+delta.y-POWERBALLHEIGHT-height)) - POWERBALLRADIUS;\n  if (pdist < dist.y) {\n    dist = vec2(5.0, pdist); // PowerBall\n  }\n\n    coord.y = MAZESIZE * SQRT2 * 0.25 - coord.y;\n  coord.x = mod(coord.x, BALLSEP);\n  coord.x = min(coord.x, BALLSEP-coord.x);\n  float bdist = length(vec3(coord, pos.y+delta.y-BALLHEIGHT)) - BALLRADIUS;\n  if ((bdist < dist.y) && (length(pbpos) > length(coord)+EPSILON)) {\n    dist = vec2(4.0, bdist); // Ball\n  }\n  return dist;\n}\n\nvec2 sdf( vec3 pos, float curr_time )\n{\n  return sdf_perturb(pos, vec3(0.0), curr_time);\n}\n\nvec3 normvec( vec3 pos, float curr_time )\n{\n  vec3 norm;\n  float base = sdf(pos, curr_time).y;\n  norm.x = sdf_perturb(pos, vec3(EPSILON, 0.0, 0.0), curr_time).y-base;\n  norm.y = sdf_perturb(pos, vec3(0.0, EPSILON, 0.0), curr_time).y-base;\n  norm.z = sdf_perturb(pos, vec3(0.0, 0.0, EPSILON), curr_time).y-base;\n  return normalize(norm);\n}\n\nvec2 raymarch( vec3 camera, vec3 ray, float curr_time )\n{\n  float dist = 0.0;\n  vec2 delta;\n  vec3 pos = camera;\n  for (int s=0; s<MAXMARCHSTEPS; s++) {\n    delta = sdf(pos, curr_time);\n    if (abs(delta.y) < EPSILON) {\n      break;\n    }\n    dist += delta.y;\n    pos = camera + dist * ray;\n  }\n  if (abs(delta.y) >= EPSILON) {\n    return vec2(0.0, 0.0); // Sky\n  }\n  if (dist < EPSILON) {\n    return vec2(1.0, 0.0); // Object interior\n  }\n  return vec2(delta.x, dist);\n}\n\nvec3 paintsky( vec3 ray, vec3 sun ) {\n#ifdef NIGHTMODE\n  return vec3(0.25);\n#endif\n#ifdef INTERMITTENTNIGHT\n  if (int(iTime / NIGHTLENGTH) % 2 == 1) {\n    return vec3(0.25);\n  }\n#endif\n  vec3 sky = mix(vec3(1.0, 1.0, 1.0), vec3(0.2, 0.3, 0.7), atan(ray.y, length(ray.xz)) / (PI * 0.5));\n  sky = mix(sky, vec3(1.0, 1.0, 0.2), pow(max(dot(ray, sun), 0.0), 50.0));\n  return sky;\n}\n\nbool isinshadow( vec3 pos, vec3 norm, vec3 sun, float curr_time ) {\n#ifdef NIGHTMODE\n  return true;\n#endif\n#ifdef INTERMITTENTNIGHT\n  if (int(iTime / NIGHTLENGTH) % 2 == 1) {\n    return true;\n  }\n#endif\n  return raymarch(pos + 3.0 * EPSILON * norm, sun, curr_time).x != 0.0;\n}\n\nvoid islit( vec3 pos, vec3 norm, float curr_time, out vec3 litnorm, out vec3 litcol ) {\n  vec3 start = pos + 3.0 * EPSILON * norm;\n  vec2 pbpos = - POWERBALLSEP * (fract(start.xz / POWERBALLSEP + 0.5) - 0.5);\n  vec2 pbid = floor((start.xz / POWERBALLSEP) - 0.5);\n  float maxheight = hash1(pbid) * (MAXHEIGHT-MINHEIGHT) + MINHEIGHT;\n  float phase = hash1(pbid.yx);\n  float revolution = sqrt(8.0 * maxheight / G);\n  float time = mod(curr_time + phase, revolution) - revolution * 0.5;\n  float height = maxheight - 0.5 * G * time * time;\n  litnorm = normalize(vec3(pbpos.x, POWERBALLHEIGHT+height-start.y, pbpos.y));\n  litcol = vec3(0.0);\n\n  vec2 rm = raymarch(start, litnorm, curr_time);\n  if (rm.x != 5.0) { // Powerball not visible\n    return;\n  } else {\n    vec3 radiance = 100.0 * PBCOL * (0.5 + 0.5*sin(curr_time * BLINKFREQ + phase * 2.0 * PI));\n    litcol = radiance * pow(POWERBALLRADIUS / (rm.y + POWERBALLRADIUS), 2.0);\n  }\n}\n\nvec3 paintlambert( vec3 pos, vec3 norm, vec3 ray, vec3 sun, vec3 ambient, vec3 diffuse,\n                   vec3 specular, float spec_coef, float curr_time )\n{\n#ifdef RADIANCE\n  bool radiance = true;\n#else\n#ifdef INTERMITTENTRADIANCE\n  bool radiance = int(iTime / NIGHTLENGTH) % 2 == 1;\n#else\n  bool radiance = false;\n#endif\n#endif\n\n  if (isinshadow(pos, norm, sun, curr_time)) {\n    if (radiance) {\n      vec3 litnorm;\n      vec3 litcol;\n      islit(pos, norm, curr_time, litnorm, litcol);\n      return ambient + max(dot(norm, litnorm), 0.0) * litcol * diffuse;\n    } else {\n      return ambient;\n    }\n  }\n  vec3 lambert = ambient + dot(norm, sun) * diffuse;\n  lambert += pow(dot(reflect(ray, norm), sun), spec_coef) * specular;\n  if (radiance) {\n    vec3 litnorm;\n    vec3 litcol;\n    islit(pos, norm, curr_time, litnorm, litcol);\n    lambert += max(dot(norm, litnorm), 0.0) * litcol * diffuse;\n  }\n  return lambert;\n}\n\nvec3 paintplane( vec3 pos, vec3 norm, vec3 ray, vec3 sun, out vec3 reftint, out vec3 refdir,\n                 float curr_time ) {\n#ifdef BLUE\n  reftint = vec3(0.0, 0.0, 0.0);\n  refdir = vec3(0.0, 0.0, 1.0);\n  return vec3(0.0);\n#endif\n  vec2 gridpoint = floor (pos.xz / TILESIZE);\n  float parity = mod(gridpoint.x+gridpoint.y, 2.0);\n  vec3 ambient = vec3(0.1, 0.2, 0.3) * (1.0 + parity);\n  vec3 diffuse = vec3(0.15, 0.3, 0.45) * (1.0 + parity);\n  vec3 specular = vec3(1.0, 1.0, 1.0);\n  float spec_coef = 5.0;\n  vec3 reflective = vec3(0.3, 0.6, 0.3);\n  reftint = reflective;\n  refdir = reflect(ray, norm);\n  return paintlambert(pos, norm, ray, sun, ambient, diffuse, specular, spec_coef, curr_time);\n}\n\nvec3 paintwall( vec3 pos, vec3 norm, vec3 ray, vec3 sun, out vec3 reftint, out vec3 refdir,\n                float curr_time ) {\n#ifdef PINK\n  vec3 ambient = vec3(0.75, 0.5, 0.5);\n  vec3 diffuse = vec3(1.0, 0.75, 0.75);\n#else\n#ifdef BLUE\n  vec3 ambient = vec3(0.0, 0.0, 0.5);\n  vec3 diffuse = vec3(0.0, 0.0, 0.8);\n#else\n  vec3 ambient = vec3(0.3, 0.3, 0.5);\n  vec3 diffuse = vec3(0.7, 0.7, 0.8);\n#endif\n#endif\n  vec3 specular = vec3(1.0, 1.0, 1.0);\n  float spec_coef = 5.0;\n  vec3 reflective = vec3(0.3, 0.3, 0.6);\n  reftint = reflective;\n  refdir = reflect(ray, norm);\n  return paintlambert(pos, norm, ray, sun, ambient, diffuse, specular, spec_coef, curr_time);\n}\n\nvec3 paintball( vec3 pos, vec3 norm, vec3 ray, vec3 sun, float curr_time ) {\n  vec3 ambient = vec3(0.2, 0.2, 0.0);\n  vec3 diffuse = vec3(0.8, 0.8, 0.0);\n  vec3 specular = vec3(1.0, 1.0, 1.0);\n  float spec_coef = 5.0;\n  return paintlambert(pos, norm, ray, sun, ambient, diffuse, specular, spec_coef, curr_time);\n}\n\nvec3 paintpowerball( vec3 pos, vec3 norm, vec3 ray, vec3 sun, out vec3 reftint, out vec3 refdir,\n                     float curr_time) {\n#ifdef RADIANCE\n  bool radiance = true;\n#else\n#ifdef INTERMITTENTRADIANCE\n  bool radiance = int(iTime / 10.0) % 2 == 1;\n#else\n  bool radiance = false;\n#endif\n#endif\n\n  vec3 ambient = vec3(0.2, 0.05, 0.0);\n  vec3 diffuse = vec3(0.8, 0.2, 0.0);\n  vec3 specular = vec3(1.0, 1.0, 1.0);\n  float spec_coef = 5.0;\n  vec3 reflective = vec3(0.5, 0.5, 0.5);\n  reftint = reflective;\n  refdir = reflect(ray, norm);\n  vec3 col = paintlambert(pos, norm, ray, sun, ambient, diffuse, specular, spec_coef, curr_time);\n  if (radiance) {\n    vec2 pbid = floor((pos.xz / POWERBALLSEP) - 0.5);\n    float phase = hash1(pbid.yx);\n    col -= dot(norm, ray) * PBCOL * (0.5 + 0.5*sin(curr_time * BLINKFREQ + phase * 2.0 * PI));\n  }\n  return col;\n}\n\nvec3 get_color( vec2 uv, float curr_time )\n{\n    float st5 = sin(curr_time / 5.0);\n    float ct5 = cos(curr_time / 5.0);\n    float st10 = sin(curr_time / 10.0);\n    float ct10 = cos(curr_time / 10.0);\n    \n    vec2 cameravxz = vec2(15.0 * st10, 15.0 * ct5);\n    float h = 30.0 - 0.5 * (cameravxz.x * cameravxz.x + cameravxz.y * cameravxz.y) / G;\n    vec3 camera = vec3(-150.0 * ct10, h, 75.0 * st5);\n    vec2 cameraaxz = vec2(1.5 * ct10, -3.0 * st5);\n    vec3 camerav = vec3(cameravxz.x, -(cameravxz.x*cameraaxz.x+cameravxz.y*cameraaxz.y)/G, cameravxz.y);\n    \n    vec3 force = vec3(cameraaxz.x, G-(cameraaxz.x*cameraaxz.x+cameraaxz.y*cameraaxz.y\n                                      -cameravxz.x*0.15*st10-cameravxz.y*0.6*ct5)/G, cameraaxz.y);\n    vec3 ncamerav = normalize(camerav);\n    vec3 dirx = normalize(cross(force, ncamerav));\n    vec3 diry = cross(ncamerav, dirx);\n\n    vec3 ray = normalize(uv.x*dirx + uv.y*diry + ncamerav);\n    \n    vec3 sun = normalize(vec3(0.5, 0.5, -1.0));\n    \n    vec3 origin = camera;\n    vec3 direction = ray;\n    vec3 col = vec3(0.0);\n    vec3 mult = vec3(1.0);\n    vec3 reftint;\n    vec3 refdir;\n    \n    for(int r=0; r<MAXREFLECT; r++) {\n      vec2 dist = raymarch(origin, direction, curr_time);\n      \n      if (dist.x == 0.0) { // Sky\n        col += mult * paintsky(direction, sun);\n        break;\n      } else\n      if (dist.x == 1.0) { // Object interior\n        break;\n      } else {\n        vec3 pos = origin + dist.y * direction;\n        vec3 norm = normvec(pos, curr_time);\n        if (dist.x == 2.0) { // Plane\n          col += mult * paintplane(pos, norm, direction, sun, reftint, refdir, curr_time);\n          mult *= reftint;\n          direction = refdir;\n          origin = pos + 3.0 * EPSILON * direction;\n        } else\n        if (dist.x == 3.0) { // Wall\n          col += mult * paintwall(pos, norm, direction, sun, reftint, refdir, curr_time);\n          mult *= reftint;\n          direction = refdir;\n          origin = pos + 3.0 * EPSILON * direction;\n        } else\n        if (dist.x == 4.0) { // Ball\n          col += mult * paintball(pos, norm, direction, sun, curr_time);\n          break;\n        } else\n        if (dist.x == 5.0) { // PowerBall\n          col += mult * paintpowerball(pos, norm, direction, sun, reftint, refdir, curr_time);\n          mult *= reftint;\n          direction = refdir;\n          origin = pos + 3.0 * EPSILON * direction;\n        }\n      }\n    \n    }\n    \n    return col;\n}\n\nvec3 get_color_blur( vec2 uv, float curr_time )\n{\n#if BLUR>1\n  vec3 col=vec3(0.0);\n  for(int i = 0; i < BLUR; i++) {\n    float ofs = ((float(i)+hash1(2.0*uv+curr_time)) / float(BLUR) - 0.5) / 120.0; // simulating 60fps.\n    col += get_color(uv, curr_time+ofs);\n  }\n  return col / float(BLUR);\n#else\n#ifdef SUBFRAME\n  float ofs = (hash1(2.0*uv+curr_time) - 0.5) / 120.0; // simulating 60fps.\n  return get_color(uv, curr_time+ofs);\n#else\n  return get_color(uv, curr_time);\n#endif\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.yy;\n\n    // Lens distortion\n    float uvlen = length(uv);\n    uv = normalize(uv) * (uvlen + 0.2 * pow(uvlen, 3.0));\n\n#if AA>1\n    vec3 col = vec3(0.0);\n    \n    for(int xx=0; xx<AA; xx++) {\n      for(int yy=0; yy<AA; yy++) {\n        vec2 ofs = (vec2(float(xx),float(yy))/float(AA)-0.5)/iResolution.yy;\n        col += get_color_blur(uv+ofs, iTime);\n      }\n    }\n    col /= pow(float(AA), 2.0);\n#else\n#ifdef SUBPIXEL\n    vec3 col = get_color_blur(uv+(hash1(uv+iTime)-0.5)/iResolution.yy, iTime);\n#else\n    vec3 col = get_color_blur(uv, iTime);\n#endif\n#endif\n\n    // apperture\n    // col *= (1.0 - 0.7 * pow(length(uv), 2.0));\n    \n    col *= 0.8; // Exposure\n    col = sqrt((tanh(col  * col))); // Simple tonemap operator\n    // col = pow(col, vec3(1./2.2)); // Approximate sRGB gamma encode, 1./2.2\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}