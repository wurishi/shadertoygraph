{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"music","id":"XdfGzn","filepath":"/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float eps = 0.01;\nconst float texelSize = 1.0 / 64.0;\nconst int numPlanes = 32;\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nbool intersectConvex(vec3 ro, vec3 rd,\n\t\t\t\t\t out vec3 p1, out vec3 p2,\n\t\t\t\t\t out vec3 n1, out vec3 n2)\n{\n   bool hit = true;\n   float t1 = 0.0;\n   float t2 = 1e10;\n\n   // intersect ray with convex polyhedron\n   for(int i=0; i<numPlanes; i++) {\n\t  // read plane from texture\n\t  //float j = 0.0;\t// static planes\n\t  float j = texelSize*iTime;\t// animate planes\n\t  vec3 s = texture(iChannel0, vec2(float(i)*texelSize, j)).xyz*2.0-1.0;\n      vec3 n = normalize(s);\n\t  //float d = 1.0;\t// try this if you don't have WebAudio\n\t  float d = texture(iChannel2, vec2(0.25, 0.0)).x;\t// move planes with music\n\n\t  // intersect ray against plane\n\t  // http://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\t   \n\t   \n\t  float denom = dot(n, rd);\n\t  float dist = d - dot(n, ro);\n\t  float t = dist / denom;\n\t  if (denom < 0.0) {\n\t\t  // entering halfspace\n\t\t  if (t > t1) {\n\t\t\t  t1 = t;\n\t\t\t  n1 = n;\n\t\t  }\n\t  } else  {\n\t\t  // leaving halfspace\n\t\t  if (t < t2) {\n\t\t\t  t2 = t;\n\t\t\t  n2 = n;\n\t\t  }\n\t  }\n\t  if (t1 > t2) {\n\t     hit = false;\n\t  }\n   }\n\t\n   // intersection points\n   p1 = ro + t1*rd;\n   p2 = ro + t2*rd;\t\n   return hit;\n}\n\nfloat fresnel(vec3 n, vec3 v, float minr)\n{\n\treturn minr + (1.0-minr)*pow(1.0 - clamp(dot(n, v), 0.0, 1.0), 2.0);\n}\n\n// lighting\nvec3 shade(vec3 pos, vec3 n, vec3 eyePos)\n{\n    //const float shininess = 20.0;\n\t//const vec3 l = vec3(0.577, 0.577, -0.577);\n    vec3 v = normalize(eyePos - pos);\n    //vec3 h = normalize(v + l);\n\t\n    //float diff = dot(n, l);\n    //float spec = pow(max(0.0, dot(n, h)), shininess) * float(diff > 0.0);\n    //diff = max(0.0, diff);\n    //diff = 0.5+0.5*diff;\n\t\n\t// reflection\n\tvec3 R = reflect(-v, n);\n\tvec3 Rcol = texture(iChannel1, R).xyz;\n\t\n\t// refraction\n\t//const float eta = 1.0 / 1.4;\t// air-glass\n\tconst float eta = 1.0 / 1.1;\t// air-glass\n\t\t\n#if 0\n\tvec3 T = normalize(-v + n*0.1);\n\t//vec3 T = refract(-v, n, eta);\n\tvec3 Tcol = texture(iChannel1, T).xyz;\n#else\n\t// dispersion\n\tvec3 T = refract(-v, n, eta);\n\tvec3 Tcol;\n\tTcol.r = texture(iChannel1, T).r;\n\tT = refract(-v, n, eta + 0.01);\n\tTcol.g = texture(iChannel1, T).g;\t\n\tT = refract(-v, n, eta + 0.02);\n\tTcol.b = texture(iChannel1, T).b;\t\n#endif\n\t\n    float f = fresnel(n, v, 0.2);\n\n    //return diff*c + vec3(spec);\n\t//return c;\n\t//return Rcol;\n\t//return Tcol;\n    //return vec3(diff*ao)*c + vec3(spec);\n    //return n*0.5+0.5;\n    //return vec3(f);\t\n\treturn Rcol*f;\n\t//return mix(Tcol, Rcol, f);\n}\n\n// lighting\nvec3 shade2(vec3 p, vec3 p2, vec3 n, vec3 n2, vec3 eyePos)\n{\n\tvec3 c;\n    vec3 v = normalize(eyePos - p);\n\n\t// exponential absorption\n\tfloat dist = length(p2 - p)*2.0;\n\tvec3 absorp = exp(-dist*vec3(1.0, 0.2, 0.5));\n\t\n\t// reflection\n\tvec3 R = reflect(-v, n);\n\tvec3 Rcol = texture(iChannel1, R).xyz;\t\n    float f = fresnel(n, v, 0.2);\n\n\t// 2nd hit\n\tv = normalize(eyePos - p2);\n\n\t// refraction\n\tconst float eta = 1.0 / 1.1;\t// air-glass\t\n\t//vec3 T = normalize(-v + n*0.1);\n#if 0\n\tvec3 T = refract(-v, -n2, eta);\n\tvec3 Tcol = texture(iChannel1, T).xyz;\n#else\n\t// dispersion\n\tvec3 T = refract(-v, -n2, eta);\n\tvec3 Tcol;\n\tTcol.r = texture(iChannel1, T).r;\n\tT = refract(-v, -n2, eta + 0.01);\n\tTcol.g = texture(iChannel1, T).g;\t\n\tT = refract(-v, -n2, eta + 0.02);\n\tTcol.b = texture(iChannel1, T).b;\t\n#endif\n\n\tTcol *= absorp;\n\tc = mix(Tcol, Rcol, f);\n\t\n\t//c = Tcol;\t\n\t//c = Rcol;\n\t//c = vec3(dist);\n\t//c = vec3(absorp);\n\t//c = vec3(f);\t\n\treturn c;\n}\n\n\nvec3 background(vec3 rd)\n{\n    //return mix(vec3(1.0), vec3(0.0, 0.25, 1.0), rd.y);\n    //return vec3(0.5);\n\treturn texture(iChannel1, rd).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -2.0));\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\tfloat roty;\n\tfloat rotx = 0.0;\n\tif (iMouse.z <= 0.0) {\n\t\troty = iTime*0.25;\t\n\t} else {\n\t\trotx = (mouse.y-0.5)*3.0;\n\t\troty = -(mouse.x-0.5)*6.0;\n\t}\n\t\n    rd = rotateX(rd, rotx);\n    ro = rotateX(ro, rotx);\n\t\t\n    rd = rotateY(rd, roty);\n    ro = rotateY(ro, roty);\n\t\t\n    // trace ray\n\tvec3 p, p2;\n    vec3 n, n2;\t\n    bool hit =  intersectConvex(ro, rd, p, p2, n, n2);\n\n    vec3 rgb;\n    if(hit)\n    {\n        // shade\n        rgb = shade(p, n, ro);\n\t\t//rgb = shade2(p, p2, n, n2, ro);\n\n     } else {\n        rgb = background(rd);\n     }\n    \n\t// vignetting\n    rgb *= 0.5+0.5*smoothstep(2.0, 0.5, dot(pixel, pixel));\n\t\n    fragColor=vec4(rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdf3zM","date":"1365091501","viewed":3114,"name":"Shard","username":"simesgreen","description":"messing about with ray casting convex polyhedra, defined by random half-planes read from texture","likes":43,"published":1,"flags":0,"usePreview":0,"tags":["raycast","cubemap","convex"],"hasliked":0,"parentid":"","parentname":""}}