{"ver":"0.1","info":{"id":"WdccRX","date":"1601487110","viewed":228,"name":"Cornell Box FDGI","username":"JacobC","description":"Faking IL\nI think everyone must do a Cornell box scene once in their life\nA simple scene of the famous Cornell box to test color bleeding for diffuse objects\nMove camera with mouse by clicking the screen","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Cornell Box FDGI\" by Jacob Ceron aka JacobC - 2020\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: jacobceron6@gmail.com\n */\n\n/*\nJust doing a simple color accumulation from sphere tracing that you can find it in function uop\nmarked with a comment that says: \"Fake IL\".\nAlso because i wanted to watch it on my phone\n*/\n\n// Change to 1. if runs slow\n#define AA 2.\n\n#define Pi 3.141592\n#define T iTime\n\n// Background light\n#define gd vec3(3.) * clamp(sin(T * .25) * 2., 0., 1.)\n#define sk vec3(1.5, 2., 3.) * clamp(sin(T * .25) * 2., 0., 1.)\n\n// Light Pos and color\n#define l0 vec3(0., 6., 0.)\n#define lc vec3(1., .8, .6)\n\nstruct mat\n{\n    float z;\n    vec3 c;\n    float ao;\n    vec3 i;\n    bool e;\n};\n\nfloat disk(in vec3 p, in vec2 r)\n{   \n    return length(vec2(max(length(p.xz) - r.x + r.y, 0.), p.y)) - r.y;\n}\n    \nfloat plane(in vec3 p, in vec2 s, float r)\n{\n    p.xy = max(abs(p.xy) - s, 0.);\n    return length(p) - r;\n}\n    \nfloat cube(in vec3 p, in vec3 s, float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(p, 0.)) - k;\n}\n\nfloat sphere(in vec3 p, float k)\n{\n    return length(p) - k;\n}\n\nfloat map(float i, float c, float l, float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\nmat uop(in mat a, in mat b)\n{\n    float s = max(a.z, b.z);\n    float ao = map(s, 1.5, 5.6, 14.4);\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c,\n            a.ao * ao, // Fake AO from: https://www.shadertoy.com/view/ttXfWX\n            a.i * mix(a.z > b.z ? a.c : b.c, vec3(1.), map(s, 1., .01, .002)), // Fake IL\n            a.z < b.z ? a.e : b.e\n        );\n}\n\nmat uope(in mat a, in mat b)\n{\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c,\n            a.ao, // Fake AO from: https://www.shadertoy.com/view/ttXfWX\n            a.i, // Fake IL\n            a.z < b.z ? a.e : b.e\n        );\n}\n\nmat scene(in vec3 p)\n{    \n    // Sphere\n    vec3 pp = p;\n    float a;\n    pp -= vec3(sin(T), cos(T), 1.) * 4.;\n    mat p0 = mat(sphere(pp, 2.), vec3(3., 0., 1.5) / Pi, 1., vec3(1.), false);\n    \n    // Right wall\n    pp = p;\n    a = -90. * Pi / 180.;\n    pp.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    pp.z -= 6.;\n    mat p1 = mat(plane(pp, vec2(6.), .0), vec3(0., 1.5, 3.) / Pi, 1., vec3(1.), false);\n    \n    // Left wall\n    pp = p;\n    pp.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    pp.z += 6.;\n    mat p2 = mat(plane(pp, vec2(6.), .0), vec3(3., 1.5, 0.) / Pi, 1., vec3(1.), false);\n    \n    // Prism\n    pp = p;\n    pp -= -2.;\n    a = -45. * Pi / 180.;\n    pp.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    mat p3 = mat(cube(pp, vec3(2., 4., 2.), 0.), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Front wall\n    pp = p;\n    pp.z += 6.;\n    mat p4 = mat(plane(pp, vec2(6.), .0), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Ceiling\n    pp = p;\n    pp.y -= 6.;\n    mat p5 = mat(plane(pp.xzy, vec2(6.), .0), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Floor\n    pp = p;\n    pp.y += 6.;\n    mat p6 = mat(plane(pp.xzy, vec2(6.), .0), vec3(3.) / Pi, 1., vec3(1.), false);\n    \n    // Light source\n    mat pl = mat(disk(p - l0, vec2(2., 0.)), vec3(1.) / Pi, 1., vec3(1.), true);\n    \n    mat q = uop(p0, p1);\n    q = uop(q, p2);\n    q = uop(q, p3);\n    q = uop(q, p4);\n    q = uop(q, p5);\n    q = uop(q, p6);\n    // Doesn't take in account AO or bleeding for Emissive\n    q = uope(q, pl);\n    \n    return q;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.001, .0);\n    float d = scene(p).z;\n    return normalize(d - vec3(scene(p - e.xyy).z, scene(p - e.yxy).z, scene(p - e.yyx).z));\n}\n\n#define STEPS 255\n#define MIN_S .01\n#define MAX_S 32.\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.z * .7;\n        if (s.z < MIN_S)\n            return mat(t, s.c, s.ao, s.i, s.e);\n        if (t > MAX_S)\n            break;\n    }\n    return mat(t, vec3(-1.), -1., vec3(-1.), false);\n}\n\n// Soft shadows: https://iquilezles.org/articles/rmshadows\n#define SSTEPS 255\n#define OFF .1\nfloat shadow(in vec3 o, in vec3 d, float k)\n{\n    float t = 0.;\n    float ms = 1.;\n    for (int i = 1; i <= SSTEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        ms = min(ms, s.z / float(i) * k);\n        t += s.z * OFF; // multiply it by a number less than 1 to remove acne\n        if (s.e)\n            break;\n        if (s.z < MIN_S)\n            return 0.;\n    }\n    return ms;\n}\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0., 1., 0.), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord;\n    vec3 fc;\n    \n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st + n - iResolution.xy * .5) / iResolution.y;\n            vec2 ms = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n            float a = 0.;\n            vec3 o = (iMouse.z > 0. ? vec3(sin(ms.x), ms.y, cos(ms.x)) : vec3(0., 0., 1.)) * 18.;\n            vec3 d = camera(uv, o, vec3(0., 0., 0.));\n            vec3 bg = mix(gd, sk, d.y * .5 + .5);\n            vec3 col;\n\n            mat m = marcher(o, d);\n            if (m.ao != -1.)\n            {\n                if (!m.e)\n                {\n                    vec3 p = o + d * m.z;\n                    vec3 n = normal(p);\n                    bg = mix(gd, sk, n.y * .5 + .5);\n\n                    vec3 l = l0 - p;\n                    vec3 ld0 = normalize(l);\n                    float att = 1.-map(length(l), 1., .02, .001);\n                    float sh = shadow(p + n * .1, ld0, 255.);\n                    vec3 diff = max(dot(ld0, n), 0.) * lc * att * sh + (m.ao / Pi * m.i);\n                    vec3 ambi = bg * m.ao / Pi * m.i;\n\n                    vec3 all_l = ambi + diff;\n\n                    col += all_l * m.c;\n                }\n                else\n                    col += 1.;\n            }\n            else\n                col += bg / Pi;\n            fc += col;\n        }\n    }\n\n    fc /= AA * AA;\n    \n    fragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}