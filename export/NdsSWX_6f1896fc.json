{"ver":"0.1","info":{"id":"NdsSWX","date":"1619361738","viewed":198,"name":"N64 Logo","username":"ccincotti3","description":"After watching tutorials and reading ray tracing books I decided to give this a go - spec based off of https://i.redd.it/zlxt4qezv0y51.png\n\nBig thanks to The Art of Code! https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg/videos","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["retro","n64"],"hasliked":0,"parentid":"NssXW2","parentname":"n64 first draft"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define SURFACE_DIST.0001\n#define MAX_DIST 10.\n#define SAMPLES 10\n\n#define HEIGHT 1.\n#define WIDTH 1.\n#define DEPTH 1.\n#define PI 3.14159265359\n#define WEIGHT DEPTH*.21\n#define SPACE_BETWEEN DEPTH*.42\n\nmat2 Rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 rand( const float n ) {\n\treturn (fract(sin(vec2(n,n+1.))*vec2(43758.5453123)) - .5)/500.;\n}\n\n/*\n* SDFs\n*/\nfloat sdBox(vec3 p,vec3 b){\n    vec3 q=abs(p)-b;\n    return length(max(q,0.))+min(max(q.x,max(q.y,q.z)),0.);\n}\n\nfloat sdPlane(vec3 p,vec3 r){\n    return dot(p,normalize(r));\n}\n\nfloat sdTri(vec3 p,float cBd,vec3 cutPlane){\n    float cPd=sdPlane(p,cutPlane);\n    return-max(cPd,cBd);\n}\n\nfloat sdN(vec3 p){\n    float dpth=DEPTH*.29;\n    float box=sdBox(p,vec3(WIDTH,HEIGHT,dpth));// main box that forms N.\n    \n    vec3 cutPlane=vec3(0,HEIGHT,0.);\n    cutPlane.xy*=Rot(PI/2.-atan(SPACE_BETWEEN/(dpth*2.)));\n    \n    // Build triangles to cut out of box to build N\n    float cBd=sdBox(p,vec3(SPACE_BETWEEN,(29./WEIGHT)*SPACE_BETWEEN,.3));// box to slice into triangle\n    \n    vec3 triLoc=p+vec3(.0,SPACE_BETWEEN+.025,0);// bottom tri\n    float tri=sdTri(triLoc,cBd,cutPlane);\n    \n    triLoc=p-vec3(.0,SPACE_BETWEEN+.025,0);// top tri\n    triLoc.xy*=Rot(PI);\n    float tri2=sdTri(triLoc,cBd,cutPlane);\n    \n    float d=max(max(tri,tri2),box);// cut\n    return d;\n}\n\n// Could probably simplify this down to one N draw\nfloat GetDist(vec3 p){\n    vec3 bp=p;\n    if(sign(bp.z)<0.)\n        bp.xz*=Rot(PI);\n    float dN1=sdN(bp-vec3(0.,0,WIDTH/2.+WEIGHT));\n    p.xz*=Rot(PI/2.);\n    if(sign(p.z)<0.)\n        p.xz*=Rot(PI);\n    float dN2=sdN(p-vec3(WIDTH/2.-.5,0,WIDTH/2.+WEIGHT));\n    return min(dN1,dN2);\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n    float dO=0.;\n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+dO*rd;// point along the ray\n        float dS=GetDist(p);\n        dO+=dS;\n        if(dS<SURFACE_DIST||dO>MAX_DIST)break;\n    }\n    return dO;\n}\n\nvec3 GetNormal(vec3 p){\n    vec2 e=vec2(.01,0);\n    float d=GetDist(p);\n    vec3 n=d-vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\n// TK\nfloat GetLight(vec3 p, vec3 lightPos){\n    vec3 l=normalize(lightPos-p);// direction vector of the surface point to the light pos\n    vec3 n=GetNormal(p);\n    float dif=clamp(dot(n,l),0.,1.);// value between -1 and 1. Something to be aware of. Should clamp to avoid probs.\n    return dif;\n}\n\nvec3 GetRayDir(vec2 uv,vec3 ro,vec3 lookAt,float zoom){\n    vec3 globalUp=vec3(0,1,0);\n    vec3 forward=normalize(lookAt-ro);\n    vec3 right=normalize(cross(globalUp,forward));\n    vec3 up=cross(forward,right);\n    vec3 center=forward*zoom;//center of screen\n    vec3 i=center+uv.x*right+uv.y*up;\n    return normalize(i);\n}\n\nvec3 colorByNormals(vec3 p,vec3 n,float d){\n    vec3 col;\n    if(abs(n.z)>0.){\n        col=vec3(0.2470,0.6353,0.2667);\n    }\n    \n    if(\n        (abs(n.y)>0.49&&abs(n.x)>0.49)||\n        (n.y<-.01&&n.z>0.)||\n        (p.x>0.&&n.y<-.01&&n.z<0.)\n    ){\n        col=vec3(0.76862,0,0.149);\n    }\n    \n    if(abs(n.y)>.9){\n        col=vec3(0.94902,0.6706,0.);\n    }\n    \n    if(abs(n.x)>.9||\n    (p.z<0.&&n.x<-.1&&n.y<0.)||\n    (p.z>0.&&n.x>.1&&n.y<0.)\n    ){\n        col=vec3(0.2196,0.2196,0.7725);\n    }\n\n    if(d>7.){\n        col=vec3(0.);\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    // opposed to vec2 uv = fragCoord/iResolution.xy;  (from 0 to 1)\n\n    vec2 uv=(fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m=iMouse.xy/iResolution.xy;\n    vec3 col;\n    float oTime = iTime;\n    vec3 ro=vec3(0.,-3.,-5.);\n    ro.yz*=Rot(-m.y*3.14+1.);\n    ro.xz*=Rot(-m.x*6.2831);\n    ro.xz*=Rot(-oTime/4.*6.2831);\n\n\n    vec3 lookAt=vec3(0.,0.,0.);\n    float zoom=1.;\n    for( int j=0; j<SAMPLES; j++ ) {\n        float time = iTime;\n        float fj = float(j);\n        vec3 rd=GetRayDir(uv+rand(fj+iTime),ro,lookAt,zoom);\n\n        float d=RayMarch(ro,rd);\n        vec3 p=ro+rd*d;// get point to shade with light\n        vec3 normal=GetNormal(p);\n        vec3 lightPos=vec3(-5,0,-3);\n        lightPos.xz *= inverse(Rot(oTime/4.*6.2831));\n\n        float dif = GetLight(p, lightPos);\n        col+= dif*.3;\n        col+=colorByNormals(p,normal,d);\n    }\n    // Output to screen\n    fragColor=vec4(col/float(SAMPLES),1.);\n}","name":"Image","description":"","type":"image"}]}