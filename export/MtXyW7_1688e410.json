{"ver":"0.1","info":{"id":"MtXyW7","date":"1505051330","viewed":109,"name":"3D Testing","username":"Lucky4Luuk","description":"Isn't it amazing?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NEAR_CLIPPING_PLANE 0.1\n#define FAR_CLIPPING_PLANE 100.0\n#define NUMBER_OF_MARCH_STEPS 40\n#define EPSILON 0.01\n#define DISTANCE_BIAS 0.7\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from https://iquilezles.org/articles/distfunctions\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat sdPlane(vec3 p)\n{\n    return p.y;\n}\n\nfloat fmod(float a, float b)\n{\n    if(a<0.0)\n    {\n        return b - mod(abs(a), b);\n    }\n    return mod(a, b);\n}\n\nvec2 scene(vec3 position)\n{\n    vec3 translate = vec3(0.0, 0.5, 1.0);\n    float distance = sdSphere(position - translate, 0.5);\n    float materialID = 1.0;\n    \n    translate = vec3(0.0, -1.0, 0.0);\n    float distance2 = sdPlane(position - translate);\n    float materialID2 = 2.0;\n    \n    //translate = vec3(0.0, 0.5, 1.0);\n    //vec3 sphere_pos = position - translate;\n    //sphere_pos.x = fract(sphere_pos.x + 0.5) - 0.5;\n    //sphere_pos.z = fmod(sphere_pos.z + 1.0, 2.0) - 1.0;\n    \n    //sphere_pos.y += sin(position.x + iTime) * 0.35;\n    //sphere_pos.y += cos(position.z + iTime);\n    \n    //float distance2 = sdSphere(sphere_pos, 0.25);\n    //float materialID2 = 2.0;\n    \n    //if (distance2 < distance)\n    //{\n    //    distance = distance2;\n    //    materialID = materialID2;\n    //}\n    \n    if (distance2 < distance)\n    {\n        distance = distance2;\n        materialID = materialID2;\n    }\n    \n    return vec2(distance, materialID);\n}\n\nvec2 raymarch(vec3 position, vec3 direction)\n{\n    float total_distance = NEAR_CLIPPING_PLANE;\n    for (int i = 0; i < NUMBER_OF_MARCH_STEPS; i++) {\n        vec2 result = scene(position + direction * total_distance);\n        if (result.x < EPSILON)\n        {\n            return vec2(total_distance, result.y);\n        }\n        \n        total_distance += result.x * DISTANCE_BIAS;\n        \n        if (total_distance > FAR_CLIPPING_PLANE)\n            break;\n    }\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\n    vec3 n;\n    vec2 dn = vec2(smoothness, 0.0);\n    n.x = scene(ray_hit_position + dn.xyy).x - scene(ray_hit_position - dn.xyy).x;\n    n.y = scene(ray_hit_position + dn.yxy).x - scene(ray_hit_position - dn.yxy).x;\n    n.z = scene(ray_hit_position + dn.yyx).x - scene(ray_hit_position - dn.yyx).x;\n    return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // smaller Z is bigger FOV\n    vec3 direction = normalize(vec3(uv, 2.5));\n    \n    // if you rotate the direction with a rotation matrix you can turn the camera too\n    vec3 camera_origin = vec3(0.0, 1.0, -2.5);\n    \n    vec2 result = raymarch(camera_origin, direction);\n    \n    float fog = pow(1.0 / (1.0 + result.x), 0.45);\n    \n    vec3 materialColor = vec3(0.0, 0.0, 0.0);\n    if (result.y == 1.0)\n    {\n        materialColor = vec3(1.0, 0.25, 0.1);\n    }\n    if (result.y == 2.0)\n    {\n        materialColor = vec3(0.7, 0.7, 0.7);\n    }\n    \n    vec3 intersection = camera_origin + direction * result.x;\n    \n    vec3 nrml = normal(intersection, 0.01);\n    \n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n    float diffuse = dot(light_dir, nrml);\n    \n    diffuse = diffuse * 0.5 + 0.5;\n    diffuse = max(0.0, diffuse);\n    \n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n    fragColor = vec4(diffuseLit, 1.0) * fog;\n}","name":"Image","description":"","type":"image"}]}