{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Perlin Noise Sphere by Johannes Diemke 2012.\n//\n// description:\n// very simple and still impressive. the signed distance field is basically\n// sdf(p) := sdSphere(p) - scale * pnoise(p)\n// GLSL perlin noise implementation from taken from\n// https://github.com/ashima/webgl-noise\n//\n// UPDATE: uses now iqs fast 3d noise\n//\n// video:\n// http://www.youtube.com/watch?v=ntYFwDKEj4o\n//\n// contact:\n// johannes.diemke@uni-oldenburg.de\n\n#define time\t(iTime * 0.2)\n#define width  iResolution.x\n#define height iResolution.y\n\nconst float DELTA  = 0.02;\nconst float PI\t   = 3.14159265;\n\nconst vec3 lightPosition  = vec3(0.1, 0.1, -1.0);\nconst vec3 cameraPosition = vec3(0.0, 0.0, -1.6);\n#define aspect\t\t\t  (width / height)\n\nfloat sphere(vec3 position, float r) {\n\treturn length(position) - r;\n}\n\nvec3 rotateX(vec3 pos, float alpha) {\t\t\t\t\n\treturn vec3(pos.x,\n\t\t\t\tpos.y * cos(alpha) + pos.z * -sin(alpha),\n\t\t\t\tpos.y * sin(alpha) + pos.z * cos(alpha));\n}\n\nvec3 rotateY(vec3 pos, float alpha) {\n\treturn vec3(pos.x * cos(alpha) + pos.z * sin(alpha),\n\t\t\t\tpos.y,\n\t\t\t\tpos.x * -sin(alpha) + pos.z * cos(alpha));\n}\n\nvec3 translate(vec3 position, vec3 translation) {\n\treturn position - translation;\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r ) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n  return length(p)-s;\n}\n\nfloat opU( float d1, float d2 ) {\n    return min(d1,d2);\n}\n\nfloat snoise(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nint colorIndex = 0;\n\nfloat function(vec3 position) {\n\t\n\tvec3 pos = rotateY(rotateX(position, time*2.0),time*1.5);\n\t\n\treturn opU(sphere(pos, 0.58)-0.38*snoise(vec3(pos*4.5+time*1.5)),\n\t\t\t   udRoundBox( position-vec3(0.0,0.0,4.0), vec3(8.0,4.0,1.0), 0.2 ));\n}\n\nvec3 ray(vec3 start, vec3 direction, float t) {\n\treturn start + t * direction;\n}\n\nvec3 gradient(vec3 position) {\n\n\treturn vec3(function(position + vec3(DELTA, 0.0, 0.0)) - function(position - vec3(DELTA, 0.0, 0.0)),\n\tfunction(position + vec3(0.0,DELTA, 0.0)) - function(position - vec3(0.0, DELTA, 0.0)),\n\tfunction(position + vec3(0.0, 0.0, DELTA)) - function(position - vec3(0.0, 0.0, DELTA)));\n\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\t\n\tvec3 nearPlanePosition = vec3((fragCoord.x - 0.5 * width) / width * 2.0  * aspect,\n\t\t\t\t\t\t\t      (fragCoord.y - 0.5 * height) / height * 2.0,\n\t\t\t\t\t\t\t       0.0);\n\t\t\t\t\t\t\t  \n\tvec3 viewDirection = normalize(nearPlanePosition - cameraPosition);\n\t\n\tfloat t = 0.0;\n\tfloat distance;\n\tvec3 position;\n\tvec4 color = vec4(vec3(1.,1.,0.4),1.0);// plasma();//vec4(0.0,0.2,0.0,1);\n\tvec3 normal;\n\tvec3 up = normalize(vec3(-0.0, 1.0,0.0));\n\t\n\tfor(int i=0; i < 40; i++) {\n\t\tposition = ray(cameraPosition,\tviewDirection, t);\n\t\tdistance = function(position);\n\t\t\n\t\n\t\t\n\t\tif(distance < 0.002) {\n\t\t\t\n\t\t\t\t\n\t\t\tnormal = normalize(gradient(position));\n\t\t\t\n\t\t\tvec4 color1 = vec4(0.5, 0.9, 0.5,1.0);\n\t\t\tvec4 color2 = vec4(1.0, 0.1, 0.1,1.0);\n\t\t\t\n\t\t\tvec4 color3 = mix(color2, color1, (1.0+dot(up, normal))/2.0);\n\t\t\t\n\t\t\t//if(colorIndex == 1) color3 = vec4(float(0xAD)/255.0,float(0xFF)/255.0,float(0x2F)/255.0,1.0);\n\t\t\t//if(colorIndex == 2) color3 = plasma();\n\t\t\tcolor = color3*0.7 * max(dot(normal, normalize(lightPosition-position)),0.0) ;//+vec4(0.1,0.1,0.1,1.0);\n\n\t\t\t//specular\n\t\t\tvec3 E = normalize(cameraPosition - position);\n\t\t\tvec3 R = reflect(-normalize(lightPosition-position), normal);\n\n\t\t\t\n\t\t\tfloat specular = pow( max(dot(R, E), 0.0), \n\t\t                 39.0);\n\t\t\t\n\t\t\tfloat alpha = 1.0-clamp( pow(length(position-vec3(0.0,0.0,1.0)),3.0)*0.0018,0.0, 1.0);\n\t\t\t\n\t\t\tfloat ao = 1.0;//computeAO(position, normal);\n\t\t\t//color = vec4(color.xyz * ao, 1.0);\n\n\t\t\t//sss\n\t\t\tfloat sss = 1.0 ;//-computeAO(position,viewDirection)*3.0;\n\n\t\t\tfloat shad = 1.0;//computeShadow(position+normalize(lightPosition-position)*0.1);\n\n//\t\t\tif(dot(normalize(lightPosition-position), normal) < 0.0)\n//\t\t\t\tshad =0.3;\n\t\t\tfloat shadow =0.3+ 0.7 * shad;\n\n\t\t\t  color = vec4(color.xyz *shad+ color3.xyz*0.4*ao, 1.0);\n\n\n\t\t\tcolor +=vec4(0.6, 0.4,0.4,0.0)*specular *shad;\ncolor =mix( color,vec4(1.0, 0.5,0.1,1.0),(1.0-sss));\n\t\t\t\n\t\t\t// interation glow\n\t\t\tcolor += vec4(vec3(0.5, 0.8,0.1)*0.8*pow(float(i)/32.0*1.0, 2.0),1.0);\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\tt = t + distance * 0.68;\n\t}\n\t\t\t\t\t\t\t\t  \t\t\t\t\t\t  \n\tfragColor = color;\t\t\t\t\t\t\t\t  \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msf3DH","date":"1368616102","viewed":5136,"name":"perlin noise sphere","username":"triggerHLM","description":"description: see source code","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise","spheretracing","distortedsphere"],"hasliked":0,"parentid":"","parentname":""}}