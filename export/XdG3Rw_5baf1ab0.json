{"ver":"0.1","info":{"id":"XdG3Rw","date":"1453586900","viewed":496,"name":"Sobel Filter 2","username":"sillsm","description":"image gradient","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["imagegradient"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Max Sills 2016\n// Licensed under the MIT license.\n//\n// http://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm\n// http://homepages.inf.ed.ac.uk/rbf/HIPR2/convolve.htm\n//\n// Using matrixCompMult, component-wise multiplication for convolution.\n// OpenGL is mat[col][row].\n/*\n 0   1    2\n 3   4(C) 5\n 6   7    8\n Pixel 4 is the center\n*/\n// Given an array of pixels, return 3*3 matrix of pixel intensities.\nmat3 intensityMatrix(vec4 n[9]){\n    mat3 o;\n    o[0] = vec3(sqrt(dot(n[0].xyz, n[0].xyz)), sqrt(dot(n[3].xyz, n[3].xyz)), sqrt(dot(n[6].xyz, n[6].xyz)));\n    o[1] = vec3(sqrt(dot(n[1].xyz, n[1].xyz)), sqrt(dot(n[4].xyz, n[4].xyz)), sqrt(dot(n[7].xyz, n[7].xyz)));\n    o[2] = vec3(sqrt(dot(n[2].xyz, n[2].xyz)), sqrt(dot(n[5].xyz, n[5].xyz)), sqrt(dot(n[8].xyz, n[8].xyz)));\n\treturn o;\n}\n\nfloat convolution(mat3 x, mat3 y) {\n return dot(x[0],y[0]) + dot(x[1],y[1]) + dot(x[2],y[2]);\n}\n\n// Given a texture and  a center coordinate\n// neighbors returns an array of the neighbor coordinates.\nvoid neighbors(lowp sampler2D s, vec2 res, vec2 center, out vec4 n[9]) {\n    n[0] = texture( s, (center + vec2(-1.0, 1.0)) / res);\n    n[1] = texture( s, (center + vec2(0, 1.0)) / res);\n    n[2] = texture( s, (center + vec2(1.0, 1.0)) / res);\n    \n    n[3] = texture( s, (center + vec2(-1.0, 0)) / res);\n    n[4] = texture( s, (center) / res);\n    n[5] = texture( s, (center + vec2(1.0, 0)) / res);\n    \n    n[6] = texture( s, (center + vec2(-1.0, -1.0)) / res);\n    n[7] = texture( s, (center + vec2(0, -1.0)) / res);\n    n[8] = texture( s, (center + vec2(1, -1.0)) / res);\n}\n\nfloat convolve(mat3 m1, mat3 m2){\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samples[9];\n    neighbors(iChannel0, iResolution.xy, fragCoord, samples);\n    mat3 intensity = intensityMatrix(samples);\n\n    mat3 Gx = mat3(1.0, 2.0,  1.0, // 1. column\n                   0.0, 0.0,  0.0,  // 2. column\n                   -1.0, -2.0,  -1.0); // 3. column\n    \n    mat3 Gy = mat3(-1.0, 0,   1.0,  // 1. column\n                   -2.0, 0.0, 2.0,  // 2. column\n                   -1.0, 0.0, 1.0); // 3. column\n        \n    float gx = convolution(intensity,Gx);\n    float gy = convolution(intensity,Gy);\n\tfloat color = sqrt((gx*gx) + (gy*gy));\n    \n    fragColor = vec4(color, color, color, 0.0);\n    \n}","name":"","description":"","type":"image"}]}