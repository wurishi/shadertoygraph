{"ver":"0.1","info":{"id":"dlKGWc","date":"1685077062","viewed":75,"name":"Voronoi WebBackground","username":"Drunkain","description":"Voronoi Look for my portfolio","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2*tan(radians(45)/2)\n#define FOV45 0.82842693331417825056778150945139\n\n#define PI 3.1415926535\n\nvec3 UvToWorld(vec2 uv) { return normalize(vec3((uv-0.5) * iResolution.xy, -iResolution.y / FOV45)); }\n\nfloat Hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 3812015801U);\n\t//uvec2 q = uvec2(ivec2(p)) * uvec2(1597334673U, 2973125087U);\n\tuint n = (q.x ^ q.y) * 1597334673U;\n\treturn float(n) * (1.0 / float(0xffffffffU));\n}\nvec3 Hash3(vec3 p)\n{\n    return(vec3(Hash12(p.xy),Hash12(p.yz),Hash12(p.zx)));\n}\n\n//perlin function from piyushslayer\nfloat perlin (vec2 p) \n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float final= mix( mix( Hash12( i + vec2(0.0,0.0) ), \n                     Hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( Hash12( i + vec2(0.0,1.0) ), \n                     Hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n                     \n\tfinal = 0.5 + 0.5*final;\n\t\n    return final;\n}\n\n//curl function from piyushslayer\nvec2 curl (vec2 uv)\n{\n    vec2 eps = vec2(0, 1);\n    \n    float n1, n2, a, b;\n    n1 = perlin(uv+eps);\n    n2 = perlin(uv-eps);\n    a = (n1-n2)/(2.*eps.y); // ∂x1/∂y\n    \n    n1 = perlin(uv+eps.yx);\n    n2 = perlin(uv-eps.yx);\n    b = (n1-n2)/(2.*eps.y); // ∂y1/∂x\n    \n    return vec2(a, -b);\n}\n\nfloat Voronoi(vec3 p)\n{\n\tvec3 n = floor(p);\n\tvec3 f = fract(p);\n\n\tfloat shortestDistance = 1.0;\n\tfor (int x = -1; x < 1; x++) {\n\t\tfor (int y = -1; y < 1; y++) {\n\t\t\tfor (int z = -1; z < 1; z++) {\n\t\t\t\tvec3 o = vec3(x,y,z);\n\t\t\t\tvec3 r = (o - f) + 1.0 + sin(Hash3(n + o)*50.0)*0.2;\n\t\t\t\tfloat d = dot(r,r);\n\t\t\t\tif (d < shortestDistance) {\n\t\t\t\t\tshortestDistance = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn shortestDistance;\n}\n\nvec2 cart2pol(vec2 uv) {\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    a = mod(a, PI * 2.0);\n    return vec2(r, a);\n}\n\nfloat VoronoiMarching(vec3 uv, int depthSteps,vec3 frequencySteps, float amplitudeSteps)\n{    \n    vec3 p = vec3(0,iTime*0.15,0);\n    float result = 0.0, a = 1.0;\n    vec3 f = vec3(0.5,0.5,0.5);\n    for (int i=0;i < depthSteps;i++)\n    {\n        p = p+uv*f;\n        result += Voronoi(p)*a;\n        f*=frequencySteps;\n        a*=amplitudeSteps;\n        uv = uv*1.2;\n     }\n     return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy);//-vec2(0.5,0.5))*vec2(0.5,1);\n    //uv = cart2pol(uv);\n    float mask = sqrt(sqrt(sin(uv.x*3.14)));\n    float tm = -0.5;\n    if(uv.x<0.5){tm=-tm;}\n    uv = uv*0.8+curl(uv*vec2(6.0,4.0)+iTime*vec2(tm,0))*1.0;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    float col = VoronoiMarching(UvToWorld(uv),3,vec3(2.71,2.47,5.2),0.7);\n    col = col*col;\n    col = mix(col,0.05,mask);\n    \n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}","name":"Image","description":"","type":"image"}]}