{"ver":"0.1","info":{"id":"flffRs","date":"1652889440","viewed":173,"name":"Soap bubble bu GeraNyan","username":"geranyan","description":"A simple approximation of a soap bubble","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["soapbubble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Thanks to https://iquilezles.org/articles/warp/ \n//And http://docplayer.net/36054413-Bubble-shader-bubble-shader-john-isidoro-ati-research-david-gosselin-ati-research.html\n\n\n#define MAX_STEP 1100\n#define MIN_DIST 0.000001\n#define MAX_DIST 100.0\n#define REFLECTION_COUNT 3\n#define REFRACTION_COUNT 4\n//do not use AA if you have slow gpu\n#define AA\n\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x)*sin(p.y);\n}\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p*2.02;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p*2.03;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p*2.04;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p*2.01;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f/0.96875;\n}\n\nvec3 getRayDirection(vec2 pixelCoord, vec3 cameraPos, vec3 lookAt) {\n    vec3 ww = normalize(lookAt - cameraPos);\n    vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n    vec3 vv = normalize(cross(uu, ww));\n    \n    return pixelCoord.x * uu + pixelCoord.y * vv + ww;\n}\n\nfloat sph(in vec3 pos, in vec3 cen, in float r) {\n\treturn length(pos - cen) - r; \n}\n\nstruct intersection {\n    vec3 pos;\n    float d;\n    // 0 - transparent sphere \n    float type;\n};\n\n\nvec2 map(in vec3 ray) {\n    \n    vec3 firstSph = vec3(0.0, 0.0, 0.0);\n    float sphR = 1.5;\n    float disp = sin(1.0*ray.x + iTime) * sin(1.0*ray.y + iTime) * sin(1.0*ray.z + iTime * 0.1) * 0.15;\n    vec3 secondSph = vec3(1.0, 0.0, 6.30);\n    \n    \n    float d = sph(ray, firstSph, sphR) + disp;\n    return vec2(d, 1.0);\n}\n\nvec3 normal(in vec3 pos)\n{\n\tconst vec3 eps = vec3(0.01, 0.0, 0.0);\n        \n    float grad_x = map(pos + eps.xyy).x - map(pos - eps.xyy).x;\n    float grad_y = map(pos + eps.yxy).x - map(pos - eps.yxy).x;\n    float grad_z = map(pos + eps.yyx).x - map(pos - eps.yyx).x;\n  \n    return normalize(vec3(grad_x, grad_y, grad_z));\n}\n\nintersection rayMarching(vec3 ro, vec3 rd, float sgn) {\n    \n    float t = 0.0; \n    intersection res;\n    \n    for(int i = 0; i < MAX_STEP; i++){\n    \n    \tvec2 pos = map(ro + t * rd);\n        float dist = pos.x * sgn;\n        \n        if(dist < MIN_DIST){\n            \n            res.pos = ro + t * rd;\n            res.d = t;\n            res.type = pos.y;\n            return res;\n        } \n        \n        if(dist > MAX_DIST){\n        \tbreak;\n        }\n        \n        t += 0.01;\n    }\n    res.pos = vec3(-1.0);\n    res.d = -1.0;\n    res.type = -1.0;\n    return res;\n}\n\nfloat pattern( in vec2 p, out vec2 q, out vec2 r )\n{\n    q.x = fbm( p + vec2(0.0,0.1 * iTime) );\n    q.y = fbm( p + vec2(5.2,1.3) );\n\n    r.x = fbm( p + 4.0*q + vec2(100.7 + 0.1 * iTime,91.2) );\n    r.y = fbm( p + 4.0*q + vec2(90.3,2.8 + 0.1 * iTime) );\n\n    return fbm(vec2(fbm( p * p + 10.0*r + fbm(5.0 * p + q)), fbm(100.0 * p * p * q)));\n}\n\nvec4 reflection(in vec3 ro, in vec3 rd) {\n    vec4 col = vec4(0.0);\n    \n\tfor (int i = 0; i < REFLECTION_COUNT; i++) {\n        \n        intersection result = rayMarching(ro, rd, 1.0);\n        \n        vec3 newRO = ro;\n        vec3 newRD = rd;\n        \n        if (result.type == 1.0) {\n            vec3 n = normal(result.pos);\n            vec3 p = normalize(ro - rd);\n            vec2 q = vec2(1.0);\n            vec2 rr = vec2(1.0);\n            float r = pattern(p.xy, q, rr);\n            float g = pattern(p.yz, q, rr);\n            float b = pattern(p.zx, q, rr);\n            col =  (texture(iChannel0, rd) + 0.09 * vec4(r, 0.45 * g, b, 1.0)) *  max(0.75, dot(n, p));\n            \n            \n            col *= 2.0 * vec4(r, g, b, 1.0), vec4(0.1);\n            \n            newRD = reflect(rd, n);\n            newRO = result.pos + newRD * 0.1;\n            \n        }\n        \n        if (result.type == -1.0) {\n            if (i == 0)\n                col = texture(iChannel0, rd);\n            else \n                col = mix(texture(iChannel0, rd), col, 0.75);\n        }\n        \n        ro = newRO;\n        rd = newRD;\n        \n        \n    }\n    \n    return col;\n    \n}\n\nvec4 refraction(in vec3 ro, in vec3 rd, in float refractionRatio, float sgn) {\n    vec4 col = vec4(0.0);\n    \n    \n\tfor (int i = 0; i < REFRACTION_COUNT; i++) {\n        \n        intersection result = rayMarching(ro, rd, sgn);\n        vec3 n = sgn * normal(result.pos);\n        \n        if (i == 0 && result.type != 1.0) {\n            break;\n        }\n        \n        if (result.type == 1.0) {\n            \n        \n            col = texture(iChannel0, ro);\n\n        }\n        \n        vec3 refractDir = refract(rd, n, refractionRatio);\n        vec3 reflectDir = reflect(rd, n);\n\n\n        if (dot(refractDir, refractDir) < 0.001) {\n                //total internal reflection\n                rd = reflectDir;\n                ro = result.pos + rd * 0.01;\n        } else {\n                //flip normal direction and refractionRatio for the next ray\n                rd = refractDir;\n                ro = result.pos + rd * 0.01;\n                refractionRatio = 1.0 / refractionRatio;\n   \n        } \n        \n        \n        \n    }\n    \n    return col;\n}\n\n\nvec4 render(in vec3 ro, in vec3 rd) {\n\n    vec4 reflection = reflection(ro, rd);\n    vec4 refractionCol = refraction(ro, rd, 1.0/1.4, 1.0);\n    \n    vec3 col = reflection.xyz + 0.2 * refractionCol.xyz;\n    \n\tcol = pow(col, vec3(1.0/1.2)); \n    \n    \n    return vec4(col, 1.0);\n\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    float an = 10.0 * iMouse.x/iResolution.x;\n    \n    vec3 cameraPos = vec3(1.0, 1.0, 2.5);\n    vec3 lookAt = vec3(0.0);\n    // simple antialiasing\n    vec3 rayDir1 = getRayDirection(uv, cameraPos, lookAt);\n    vec4 col = render(cameraPos, rayDir1); \n    fragColor = col;\n#ifdef AA\n    vec3 rayDir2 = getRayDirection(uv, cameraPos, lookAt + vec3(0.01, 0.0, 0.0));\n    vec3 rayDir3 = getRayDirection(uv, cameraPos, lookAt + vec3(0.0, 0.01, 0.0));\n    vec3 rayDir4 = getRayDirection(uv, cameraPos, lookAt + vec3(0.0, 0.0, 0.01));\n    vec4 col1 = render(cameraPos, rayDir2);\n    vec4 col2 = render(cameraPos, rayDir3);\n    vec4 col3 = render(cameraPos, rayDir4);\n    // Output to screen\n    fragColor = 0.25 * (col + col1 + col2 + col3);\n#endif\n    \n}","name":"Image","description":"","type":"image"}]}