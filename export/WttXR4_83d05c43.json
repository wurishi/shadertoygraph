{"ver":"0.1","info":{"id":"WttXR4","date":"1580504742","viewed":205,"name":"return of the obra dither","username":"JackSolace","description":"Basic Raymarch with a dithering effect to show basis of most basic \"toon\" shaders","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["ray","sphere","dither","march","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Carter S. Jan 2020\n//Basic Raymarch with a dithering effect to show basis of most basic \"toon\" shaders\n\n\n//from the Sphere example\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\n\n//This function grows with more objects and operations (unions, distortions, perturbations, ect)\n//This is usually where acceleration structures and ad hoc hackery goes down\nfloat map_the_world(in vec3 p)\n{//this one is simple since there is only 1 sdf to check\n    float obj_dist = distance_from_sphere(p, vec3(0.0,0.0,0.0), 0.3);\n\n    return obj_dist;\n}\n\n\n//Find the normal of the surface at this point P\nvec3 calculate_normal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    //take small steps to find normal\n    return normalize( e.xyy*map_the_world( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map_the_world( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map_the_world( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map_the_world( pos + e.xxx ) );  \n}\n\n//macintosh-like toon dithering\n//Note AA will break dithering\nfloat calculate_dither(vec3 normal, vec3 light_direction, vec2 frag){\n    //constants for dither thresholds (play with these values)\n    float quarter_dither = 0.6;\n    float half_dither = 0.3;\n    float full_dither = -0.1;\n    \n    //get integer pixel coords\n    int x = int(frag.x);\n    int y = int(frag.y);\n    //similar to diffuse calculations\n\tfloat ang = dot(normal,light_direction);\n    \n    //series of threshold checks\n    if (ang > full_dither) {\n        //get checkered coords\n        int rx = x % 2;\n        int ry = y % 2;\n        if (ang > half_dither){\n            if (ang > quarter_dither){\n            \treturn 1.0;\n            }\n        \tif (rx == 1 && ry == 1){//1 in 4 pixels passes this check\n        \t\treturn 0.0;\n        \t}\n        \treturn 1.0;\n        }\n        if (rx == ry){//1 in 2 pixels passes this check\n        \treturn 0.0;\n        }\n        return 1.0;\n    }\n    return 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // camera movement from https://www.shadertoy.com/view/tdXGWr\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ray_origin = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 origin = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix (for ease of animation)\n    vec3 ww = normalize( origin - ray_origin );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    //initialize color (background)\n    vec3 total = vec3(0.25);\n    \n \t//what pixel are we marching through\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\n\t// create view ray\n    vec3 ray_direction = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // raymarch\n    const float tmax = 2.0; //max march depth\n    float t = 0.0;//current depth\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ray_origin + t*ray_direction;\n        //get dist to nearest surface\n        float h = map_the_world(pos);\n        //if we hit something break\n        if( h<0.0001 || t>tmax ) break;\n        //step forward\n        t += h;\n    }\n        \n    \n     // ambient + diffuse light color calculations\n     vec3 color = vec3(0.0);\n     if( t<tmax )\n     {\n        //postion of intersect\n        vec3 pos = ray_origin + t*ray_direction;\n        //normal at surface\n        vec3 normal = calculate_normal(pos);\n        // dither value\n        float dither = calculate_dither(normal,normalize(vec3(0.5,0.5,0.5)-pos),fragCoord);\n        //ambient sphere value\n        float ambient = 0.1;\n        //combine it all\n        color = 0.25*vec3(0.2,0.3,0.4)*ambient + 0.75*vec3(0.8,0.7,0.5)*dither;\n     }\n\n     // gamma color calculation    \n     color = sqrt( color );\n\t total += color;\n\n\t fragColor = vec4( total, 1.0 );\n}","name":"Image","description":"","type":"image"}]}