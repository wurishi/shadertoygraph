{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const float MAX_DIST = 120.0; // Max rendering distance\nconst int MAX_STEPS = 60; // Max steps for ray marching\nconst float FREQUENCY = 0.03; // Terrain frequency\nconst float HEIGHT = 3.2; // Terrain height variation\nconst float DISTRIB = 2.5; // Terrain redistribution factor\nconst vec3 SKY_COLOR = vec3(0.69, 0.90, 1.0);\nconst vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);\nconst vec3 MOUNT_COLOR = vec3(0.16, 0.1, 0.05);\n\n// ------------Noise algorithm--------------\nvec2 hash(vec2 p) { // Generate a random number\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return fract(sin(p) * 43758.5453) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 p) { // Create Simplex Noise\n    const float K1 = 0.366025404;\n    const float K2 = 0.211324865;\n    vec2 i = floor(p + (p.x + p.y) * K1);\n    vec2 a = p - i + (i.x + i.y) * K2;\n    vec2 o = step(a.yx, a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0 * K2;\n    vec3 h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), 0.0);\n\tvec3 n = h * h * h * h * vec3(dot(a, hash(i)), dot(b, hash(i + o)), dot(c, hash(i + 1.0)));\n    return dot(n, vec3(70.0));\n}\n\nfloat fbm (vec2 p) { // Create Fractal Brownian Motion\n    float f = 0.0; \n    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);\n    f = 0.5000 * noise(p); p = m * p; \n    f += 0.2500 * noise(p); p = m * p;\n    f += 0.1250 * noise(p); p = m * p;\n    f += 0.0625 * noise(p); p = m * p;\n    f = 0.5 + 0.5 * f; // Map f to range [0,1]\n    return f;\n}\n// ----------------------------------------\n\nfloat terrain(vec2 p) { // Generate Terrain\n    return pow(fbm(p * FREQUENCY) * HEIGHT, DISTRIB) + fbm(p * 0.4); // Get basic height and add details\n}\n\nfloat distMin(vec3 p) { // Check the closest intersection and return the distance\n\tfloat distMin = MAX_DIST; // Initialize shortest distance\n\tfloat h = terrain(p.xz); // Find height of terrain\n\tfloat dist = p.y - h; // Vercital distance of ray origin and terrain\n\tif (dist < distMin) { distMin = dist; } // Update shortest distance\n\treturn distMin;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) { // Ray marching\n    float dO = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * dO; // Current point along the ray\n        float dS = distMin(p); // Distance to the nearest surface\n        dO += dS; // Move forward\n        if (dO > MAX_DIST) break;\n    }\n    return dO;\n}\n\nvec3 normal(vec3 p) { // Calculate normal\n    vec2 e = vec2(0.01, 0.0);\n    vec3 n = distMin(p) - vec3(distMin(p - e.xyy), distMin(p - e.yxy), distMin(p - e.yyx)); // Partial derivative\n    return normalize(n);\n}\n\nvec3 render(vec3 p) { // Calculate the final color\n    vec3 lightPos = vec3(0.0, 3.0, 1.0);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normal(p);\n    float dif = clamp(dot(n, l) * 0.5 + 0.5, 0.0, 1.0); // Diffuse lighting\n    float ambient = 0.2; // Ambient lighting\n    vec3 lighting = LIGHT_COLOR * (dif + ambient);\n    vec3 color = MOUNT_COLOR * pow(p.y, 0.7) * lighting;\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y; // Normalize frag coordinates with aspect ratio correction\n    vec3 ro = vec3(0.0 + iTime, 9.0, 0.0); // Ray origin, panning by time\n    vec3 rd = normalize(vec3(uv, -1.0)); // Ray direction\n    rd *= mat3(vec3(1, 0, 0), // Rotation matrix, adjust the camera rotation to look downwards\n                vec3(0, cos(-0.5), -sin(-0.5)),\n                vec3(0, sin(-0.5), cos(-0.5)));\n    vec3 col = SKY_COLOR;\n    float d = rayMarch(ro, rd); // Perform ray march\n    if(d < MAX_DIST) { // Check for intersection\n    \tvec3 p = ro + rd * d;\n    \tcol = render(p);\n    }\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McGfRc","date":"1734305430","viewed":76,"name":"Simple Procedural Noise Terrain","username":"luoluobuli","description":"Generating terrain by taking fractal noise as heightmap.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d"],"hasliked":0,"parentid":"","parentname":""}}