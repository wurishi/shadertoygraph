{"ver":"0.1","info":{"id":"ltGSzz","date":"1482478948","viewed":274,"name":"Silo Princeps Fec It","username":"alytile","description":"https://en.wikipedia.org/wiki/Silo_of_Asturias\nStone commemorating Silo's foundation of the church of Santianes de Pravia. Beginning with the central \"S\" and moving in any direction spells Silo princeps fecit (Prince Silo made [it]).","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tessellation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#version 150\n//https://www.shadertoy.com/view/ltGSzz\n#define SHADER_SHADERTOY 0\n#define SHADER_VSCODE 1\n#define SHADER_HTML 2\n#define SHADER_KODELIFE 3\n\n#if __VERSION__ != 150\n#define SHADER SHADER_SHADERTOY\n//#define SHADER SHADER_VSCODE\n//#define SHADER SHADER_HTML\n#else\n#define SHADER SHADER_KODELIFE\n#endif\n\n#if SHADER == SHADER_VSCODE\n#define texture vec4(0);\n#endif\n#if SHADER == SHADER_HTML\n#define texture texture2D\n#endif\n#if SHADER == SHADER_KODELIFE\n#define texture vec4(0);\nout vec4 fragColor;\n#endif\n#if SHADER >= SHADER_HTML\nuniform float time;uniform vec2 mouse, resolution;uniform vec3 spectrum;uniform sampler2D texture0, texture1, texture2, texture3, prevFrame;\n#define iResolution resolution\n#define iTime time\n#define iMouse mouse\n#define iChannel0 texture0\n#define iChannel1 texture1\n#define iChannel2 texture2\n#define iChannel3 texture3\n#endif\n\n\n// Bitmap font is based on Hamneggs's https://www.shadertoy.com/view/4dtGD2\n// Tessellation code is based on soma_arc's https://www.shadertoy.com/view/4t3SDs\n\n#define _f float\nconst lowp _f CH_C    = _f(0xe111e), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n              CH_I    = _f(0xf444f), CH_L    = _f(0x1111f), CH_N    = _f(0x9bd99),\n              CH_O    = _f(0x69996), CH_P    = _f(0x79971), CH_R    = _f(0x79759),\n              CH_S    = _f(0xe1687), CH_T    = _f(0xf4444);\nconst lowp vec2 MAP_SIZE = vec2(4,5);\n#undef flt\nconst lowp vec2 charSize = vec2(.5, .5);\nconst lowp vec2 charPos = vec2(0.45, 0.25);\nconst lowp vec2 rectSize = vec2(1.3333, 1.);\nconst float minxRange = -9.0 * rectSize.x;\nconst float maxxRange = 10.0 * rectSize.x;\nconst vec4 black = vec4(0,0,0,0);\n// CEFILNOPRST\nconst vec4 color_c = vec4(0.850,0.862,0.898,1.0);\nconst vec4 color_e = vec4(0.839,0.803,0.764,1.0);\nconst vec4 color_f = vec4(0.803,0.796,0.705,1.0); \nconst vec4 color_i = vec4(0.823,0.831,0.854,1.0); \nconst vec4 color_l = vec4(0.843,0.835,0.788,1.0); \nconst vec4 color_n = vec4(0.760,0.764,0.705,1.0); \nconst vec4 color_o = vec4(0.717,0.741,0.741,1.0); \nconst vec4 color_p = vec4(0.850,0.886,0.905,1.0); \nconst vec4 color_r = vec4(0.803,0.811,0.807,1.0); \nconst vec4 color_s = vec4(0.803,0.827,0.768,1.0); \nconst vec4 color_t = vec4(0.772,0.760,0.694,1.0); \n\nfloat getBit( in float map, in float index )\n{\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\nfloat drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv-=pos;\n    uv /= size;\n    float res;\n    res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= MAP_SIZE;\n    res*=getBit( char, 4.0*floor(uv.y) + floor(uv.x) );\n    return clamp(res,0.0,1.0);\n}\nvec4 getColor(float opCount, vec2 pos) {\n    float chr = 0.0; \n    float which=mod(opCount,17.0);    \n    if (which==0.0 || which==11.0) {\n        chr = drawChar( CH_S, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_s; }\n    } else if (which==1.0 || which==6.0 || which==15.0) {\n        chr = drawChar( CH_I, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_i; }\n    } else if (which==2.0) {\n        chr = drawChar( CH_L, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_l; }\n    } else if (which==3.0) {\n        chr = drawChar( CH_O, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_o; }\n    } else if (which==4.0 || which==10.0) {\n        chr = drawChar( CH_P, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_p; }\n    } else if (which==5.0 ) {\n        chr = drawChar( CH_R, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_r; }\n    } else if (which==7.0) {\n        chr = drawChar( CH_N, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_n; }\n    } else if (which==8.0 || which==14.0) {\n        chr = drawChar( CH_C, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_c; } \n    } else if (which==9.0 || which==13.0) {\n        chr = drawChar( CH_E, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_e; }\n    } else if (which==12.0) {\n        chr = drawChar( CH_F, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_f; }\n    } else if (which==16.0) {\n        chr = drawChar( CH_T, charPos, charSize, pos);\n        if (chr >0.0) { return black; } else { return color_t; }\n    }\n}\n\nconst int MAX_ITERATIONS = 100;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.x / iResolution.y / 2.0;\n    \n    vec2 pos = (fragCoord.xy / iResolution.yy ) - vec2(ratio, 0.5);\n    pos *= 15.0;\n    pos.y += 0.5;\n    pos.x +=0.65;\n    if (pos.x < minxRange || pos.x > maxxRange ) {\n        fragColor = black;\n        return;\n    }\n    \n    bool isFund = true;\n    float opCount = 0.;\n    for(int i = 0 ; i < MAX_ITERATIONS ; i++){\n        isFund = true;\n        if(pos.x < 0. || rectSize.x < pos.x){\n            opCount += abs(floor(pos.x / rectSize.x));\n            pos.x = mod(pos.x, rectSize.x);\n            isFund = false;\n        }\n        if(pos.y < 0. || rectSize.y < pos.y){\n            opCount += abs(floor(pos.y / rectSize.y));\n            pos.y = mod(pos.y, rectSize.y);\n            isFund = false;\n        }\n        if(isFund) break;\n    }   \n    if (isFund==false) {\n        fragColor = black;\n        return;\n    }\n    fragColor = getColor(opCount,pos);\n}\n\n\n#if SHADER != SHADER_SHADERTOY\nvoid main(void)\n{\n#if SHADER <= SHADER_HTML\n    vec4 fragColor = vec4(0);\n#endif\n    mainImage(fragColor,gl_FragCoord.xy);\n#if SHADER <= SHADER_HTML\n    gl_FragColor = fragColor;\n#endif\t\n}\n#endif","name":"Image","description":"","type":"image"}]}