{"ver":"0.1","info":{"id":"3l2yWK","date":"1595379909","viewed":80,"name":"00-a: Lambertian Sphere","username":"yarn","description":"learn","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// todo moon orbiting and casting a shadow + stars/nebulae\n\n\nvec3 normal_at(vec3 s_c, vec3 point) {\n\treturn normalize(point - s_c);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    float aspect_ratio = iResolution.x / iResolution.y;\n    uv.x *= aspect_ratio; // unstretch\n    uv.x += (1.0 - aspect_ratio) / 2.0; // centre\n    \n    //vec2  mouse_loc = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y);\n\t//vec2 mouse_loc = vec2(0.5) + 0.2*vec2(sin(0.05 * iTime), cos(0.05 * iTime));\n    vec2 mouse_loc = vec2(0.5);\n \n    //vec3 sphere_centre = vec3(0.2);\n    vec3 sphere_centre = vec3(mouse_loc.x, 0.3, mouse_loc.y);\n    float sphere_radius = 0.2;\n    \n    vec3 ray_origin = vec3(uv.x, -1.0, uv.y); // view plane at z = -1.0\n    \n    vec3 ray_dir = vec3(0.0, 1.0, 0.0); // straight from view plane\n    \n    float t = iTime * 5.0;\n    \n    vec3 light_pos = vec3(0.5 + 0.3 * sin(0.3 * t), 0.3 + 0.2*sin(0.5 * t), 0.5 + 0.3 * cos(0.3 * t));\n    \n    vec3 col;\n    \n    float root = pow(dot(ray_dir, ray_origin - sphere_centre) , 2.0) - pow(length(ray_origin - sphere_centre), 2.0) + pow(sphere_radius, 2.0);\n    \n    if (root < 0.0) {\n    \tcol = vec3(0.0);   \n    } else {\n        float t = -(dot(ray_dir, ray_origin - sphere_centre)) - sqrt(root);\n        //col = vec3(1.0 - 0.7*t);\n\n        vec3 light_dir = -normalize(sphere_centre - light_pos);\n        vec3 norm = (normal_at(sphere_centre, ray_origin +  t * ray_dir)); // norman!\n        \n        \n        col = vec3(dot(light_dir, norm));\n    }\n    \n    float light_point = step(distance(uv, vec2(light_pos.x, light_pos.z)), (0.3 - 0.2*sin(0.5 * t)) * 0.03);\n    \n    if (light_point > 0.95) {\n     \tcol = vec3(0.0, 0.3 - 0.2*sin(0.5 * t), 0.0);   \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}