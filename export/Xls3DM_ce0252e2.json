{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Alexander Lemke, 2015\n\n// A rough draft of a ray tracer, I need to go back through and fix some artifacts and optimize\n\n// References:\n// Used iq's noise example and anji's ray tracer as initial examples\n\n// https://www.shadertoy.com/view/lsf3WH\n// https://www.shadertoy.com/view/4dsGRn\n\n//////////////////////////////////////////////////\n// Settings\n//////////////////////////////////////////////////\n#define     NUMBER_OF_BOUNCES   \t4\n#define     MATERIALS_ENABLED   \t1\n#define     SHADOWS_ENABLED     \t1\n#define     SOFT_SHADOWS_ENABLED\t1\n#define \tSOFT_SHADOW_SAMPLES\t\t26 // 100 looks nice but is slow, need to optimize\n#define     SHOW_NORMALS        \t0\n\n//////////////////////////////////////////////////\n// Constants\n//////////////////////////////////////////////////\nconst float     PI \t\t\t\t = 3.14159265359;\nconst float     MAX_DISTANCE \t = 1000.0;\nconst float     EPSILON \t\t = 0.001;\n\n//////////////////////////////////////////////////\n// Helpers\n//////////////////////////////////////////////////  \nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Noise(in vec2 uv)\n{ \n    return fract(sin(dot(uv.xy, vec2(12.9898, 78.233))) * 43758.5453); \n} \n\nfloat ComputeFresnel(in float NdotV)\n{\n\tconst float fresnelReflectionIndex = 0.01;\n\tfloat fresnel = fresnelReflectionIndex + (1.0 - fresnelReflectionIndex) * pow((1.0 - NdotV), 5.0);\n    return fresnel;\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float rc = 1.0 - c;\n    \n    return mat3(rc * axis.x * axis.x + c,          rc * axis.x * axis.y - axis.z * s, rc * axis.z * axis.x + axis.y * s,\n                rc * axis.x * axis.y + axis.z * s, rc * axis.y * axis.y + c,          rc * axis.y * axis.z - axis.x * s,\n                rc * axis.z * axis.x - axis.y * s, rc * axis.y * axis.z + axis.x * s, rc * axis.z * axis.z + c);\n}\n\n//////////////////////////////////////////////////\n// Materials\n//////////////////////////////////////////////////  \nstruct Material\n{\n    vec3    mAlbedo;\n    vec3    mSpecular;\n    float   mMicrosurface;\n};\n    \nconst int NUMBER_OF_MATERIALS = 5;\nMaterial gMaterials[NUMBER_OF_MATERIALS];\n\nvoid InitializeMaterials()\n{\n    gMaterials[0] = Material(vec3(0.8, 0.8, 0.8), vec3(0.80), 1.0);\n    gMaterials[1] = Material(vec3(0.1, 1.0, 0.1), vec3(0.32), 0.3);\n    gMaterials[2] = Material(vec3(1.0, 0.7, 0.0), vec3(0.42), 0.1);\n    gMaterials[3] = Material(vec3(0.4, 0.4, 0.8), vec3(0.05), 0.2); \n    gMaterials[4] = Material(vec3(0.9, 0.1, 0.1), vec3(0.02), 0.2); \n}\n\n//////////////////////////////////////////////////\n// Geometry\n//////////////////////////////////////////////////\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n};    \n\nstruct Sphere\n{\n    vec3    mCenter;\n    float   mRadius;\n\n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n\nstruct Plane\n{\n    vec3    mNormal;\n    float   mD;\n    \n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n        \n//////////////////////////////////////////////////\n// Intersection Helpers\n//////////////////////////////////////////////////   \nstruct IntersectionPoint\n{\n    vec3        mPoint;\n    vec3        mNormal;\n    float       mT;\n    \n#if MATERIALS_ENABLED\n    Material    mMaterial;\n#endif // MATERIALS_ENABLED\n};\n    \nIntersectionPoint GetClosestIntersection(in IntersectionPoint a, in IntersectionPoint b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;  \n}\n  \nbool IsIntersectionValid(in IntersectionPoint a)\n{\n    return (a.mT < (MAX_DISTANCE - EPSILON));  \n}\n\n//////////////////////////////////////////////////\n// Creation Helpers\n////////////////////////////////////////////////// \n#if MATERIALS_ENABLED\n#define CREATE_SPHERE(position, radius, material) Sphere(position, radius, material)\n#define CREATE_PLANE(normal, d, material) Plane(normalize(normal), d, material)\n#define CREATE_TRIANGLE(a, b, c, material) Triangle(a, b, c, material)\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE, gMaterials[0])\n#else\n#define CREATE_SPHERE(position, radius, material) Sphere(position, radius)    \n#define CREATE_PLANE(normal, d, material) Plane(normalize(normal), d)   \n#define CREATE_TRIANGLE(a, b, c) Triangle(a, b, c)\n#define INVALID_INTERSECTION IntersectionPoint(vec3(0.0), vec3(0.0), MAX_DISTANCE) \n#endif // MATERIALS_ENABLED  \n\n//////////////////////////////////////////////////\n// Intersection Tests\n////////////////////////////////////////////////// \nIntersectionPoint RayPlaneIntersectionTest(in Ray ray, in Plane plane)\n{\n    IntersectionPoint intersection = INVALID_INTERSECTION;\n    \n    float numerator = plane.mD - dot(plane.mNormal, ray.mPosition);\n    float denominator = dot(plane.mNormal, ray.mDirection);\n    if(abs(denominator) > EPSILON)\n    {\n        float t = numerator / denominator;\n        if(t > EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = plane.mNormal;\n            intersection.mT = t;\n\n#if MATERIALS_ENABLED\n            intersection.mMaterial = plane.mMaterial;\n#endif // MATERIALS_ENABLED   \n        }\n    }\n    return intersection;\n}\n\nIntersectionPoint RaySphereIntersectionTest(in Ray ray, in Sphere sphere)\n{   \n    IntersectionPoint intersection = INVALID_INTERSECTION;\n\n    float sRadiusSquared = sphere.mRadius * sphere.mRadius;\n    vec3 eDistance = ray.mPosition - sphere.mCenter;\n    \n    float b = dot(eDistance, ray.mDirection);\n    float c = dot(eDistance, eDistance) - sRadiusSquared;\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        float t = max(-b - sqrt(discriminant), 0.0); // clamp t to zero incase it started inside the sphere\n           \n        if(discriminant >= EPSILON)\n        {\n            intersection.mPoint = ray.mPosition + ray.mDirection * t;\n            intersection.mNormal = normalize(intersection.mPoint - sphere.mCenter);\n            intersection.mT = t;\n      \n#if MATERIALS_ENABLED\n            intersection.mMaterial = sphere.mMaterial;\n#endif // MATERIALS_ENABLED          \n       }      \n    }\n    return intersection;\n}\n\nIntersectionPoint CheckSceneForIntersection(in Ray currentRay)\n{\n    // Spheres\n    Sphere sphere0 = CREATE_SPHERE(vec3(-1.3, -0.2, -0.2), 0.2 + pow(abs(sin(iTime * PI * 0.4 + 0.2) * 0.4), 2.0), gMaterials[1]);  \n    Sphere sphere1 = CREATE_SPHERE(vec3(-0.1, (sin(iTime * PI * 0.4) * 0.75) + 0.35, -0.5), 0.7, gMaterials[2]);  \n    Sphere sphere2 = CREATE_SPHERE(vec3(0.9, -0.05, 0.2), 0.4, gMaterials[3]);\n    Sphere sphere3 = CREATE_SPHERE(vec3(0.1 + (cos(iTime * PI * 0.4)), 0.8, 0.7), 0.5, gMaterials[4]);\n\n    // Check scene for intersection   \n    IntersectionPoint sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere0);\n    IntersectionPoint sphereIntersection1 = RaySphereIntersectionTest(currentRay, sphere1);\n    IntersectionPoint closestIntersection = GetClosestIntersection(sphereIntersection0, sphereIntersection1);\n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere2);\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n    sphereIntersection0 = RaySphereIntersectionTest(currentRay, sphere3);\n    closestIntersection = GetClosestIntersection(closestIntersection, sphereIntersection0);\n   \n    // Ground Plane\n    Plane plane0 = CREATE_PLANE(vec3(0.0, 1.0, 0.0), -1.1, gMaterials[0]);  \n    IntersectionPoint planeIntersection = RayPlaneIntersectionTest(currentRay, plane0);\n    closestIntersection = GetClosestIntersection(closestIntersection, planeIntersection);\n     \n    return closestIntersection;\n}\n\n//////////////////////////////////////////////////\n// Lighting Helpers\n//////////////////////////////////////////////////\nstruct DirectionalLight\n{\n    vec3 mDirection;\n    vec3 mColor;\n}; \n    \nvec3 ApplyDirectionalLight(in DirectionalLight light, in IntersectionPoint geometryIntersection, in vec3 startingPoint)\n{\n    // Determine some values\n    vec3 normal = normalize(geometryIntersection.mNormal);\n    vec3 lightDirection = normalize(-light.mDirection);\n    vec3 viewVector = normalize(startingPoint - geometryIntersection.mPoint);\n    vec3 halfVector = normalize(lightDirection + viewVector);\n    \n    // Wolfgang's cook torrence approach from Programming Vertex and Pixel shaders \n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = Saturate(dot(normal, viewVector));\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float NHSquared = NdotH * NdotH;\n    float roughnessSquared = geometryIntersection.mMaterial.mMicrosurface * geometryIntersection.mMaterial.mMicrosurface;\n    \n    float microfacets = 0.0;\n    float geometricAttenuation = 0.0;\n    vec3 specular = vec3(0.0);\n    \n    float denom0 = roughnessSquared * NHSquared;\n    float denom1 = denom0 * NHSquared;\n    \n    if((abs(denom0) > EPSILON) && (abs(denom1) > EPSILON))\n    {\n    \tmicrofacets = (1.0 / denom1) * (exp(-((1.0 - NHSquared) / denom0))); // D\n    }\n   \tif(abs(VdotH) > EPSILON)\n    {\n    \tgeometricAttenuation = min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)); // G\n    }\n    float fresnel = ComputeFresnel(NdotV); // F\n    \n    float denom2 = PI * NdotL * NdotV;\n    if(abs(denom2) > EPSILON)\n    {\n    \tspecular = (fresnel * microfacets * geometricAttenuation) / denom2 * geometryIntersection.mMaterial.mSpecular;\n    }\n    vec3 lighting = ((NdotL * Saturate(1.5 * ((0.7 * NdotL * geometryIntersection.mMaterial.mAlbedo + specular)))))  * light.mColor;\n        \n    // Cast a ray to check for shadows\n    float shadow = 1.0;\n#if SHADOWS_ENABLED\n   \n#if SOFT_SHADOWS_ENABLED  \n    // Create slight varations around the incomming light direction for sampling\n    vec3 axis0 = normalize(cross(lightDirection, vec3(0.0, 1.0, 0.0)));\n    vec3 axis1 = normalize(cross(lightDirection, axis0));\n                       \n    for(int i = 0; i < SOFT_SHADOW_SAMPLES; ++i)\n    {   \n        float index = float(i);\n        float sampleIndex = index / float(SOFT_SHADOW_SAMPLES / 4) * 2.0 * PI + Noise(startingPoint.xz);\n     \tfloat pushAmount = (mod(index, 4.0) + 1.0) * 0.25;\n        vec3 offset = (cos(sampleIndex) * axis0 + sin(sampleIndex) * axis1) * pushAmount * 0.01;\n        \n    \tRay shadowRay = Ray(geometryIntersection.mPoint + (EPSILON * normal), (lightDirection + offset));\n    \tIntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n        shadow += IsIntersectionValid(lightIntersection) ? 0.0 : 1.0; // Determine if we hit an object and are in a shadow region\n    }\n    shadow /= float(SOFT_SHADOW_SAMPLES);\n#else\n    Ray shadowRay = Ray(geometryIntersection.mPoint + (EPSILON * normal), lightDirection);\n    IntersectionPoint lightIntersection = CheckSceneForIntersection(shadowRay);\n    shadow = IsIntersectionValid(lightIntersection) ? 0.0 : shadow; // Determine if we hit an object and are in a shadow region\n#endif // SOFT_SHADOWS_ENABLED\n    \n#endif // SHADOWS_ENABLED\n    \n    return (lighting * shadow);\n}\n\nvec3 CalculateLighting(in IntersectionPoint intersection, in vec3 startingPoint)\n{\n    DirectionalLight directionalLight = DirectionalLight(vec3(0.4, -1.0, -0.8), vec3(1.0));    \n    return ApplyDirectionalLight(directionalLight, intersection, startingPoint);\n}\n\n//////////////////////////////////////////////////\n// Implementation\n//////////////////////////////////////////////////\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    InitializeMaterials();\n\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    float aspectRatio = (iResolution.x / iResolution.y);\n    vec2 uv =  2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec2 aspectRatioAdjustedUVs = vec2(uv.x * aspectRatio, uv.y);\n       \n    // Rotate the scene\n    float rotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * PI * 2.0 : (iTime * PI) * 0.1; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 rotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), rotationValue);\n    vec3 cameraPosition = vec3(2.0 * sin(rotationValue), 0.0, 2.0 * cos(rotationValue));\n    \n    // Determine the inital ray, the camera ray \n    vec3 cameraRayDirection = normalize(vec3(aspectRatioAdjustedUVs.xy, -1.0));\n    cameraRayDirection = (rotationMatrix * cameraRayDirection);\n    Ray ray = Ray(cameraPosition, cameraRayDirection);\n          \n    vec3 color = vec3(0.0);\n    \n    // Find the first collision\n    IntersectionPoint currentIntersection = CheckSceneForIntersection(ray);\n\n#if SHOW_NORMALS    \n    vec3 normal = currentIntersection.mNormal;\n#endif // SHOW_NORMALS\n    \n    vec3 specular = vec3(1.0); // Specular starts at one and will decrease with every bounce\n\tvec3 lighting = vec3(1.0); // Lighting starts at one so background cubemap will be lit\n \n    for(int i = 0; i < NUMBER_OF_BOUNCES; ++i)\n    {\n        // Only apply the bounces if we actually hit something\n        if(IsIntersectionValid(currentIntersection))\n        {\n            lighting = CalculateLighting(currentIntersection, ray.mPosition);\n            color += (lighting * specular);\n            \n            specular *= (currentIntersection.mMaterial.mSpecular); \n\n            // Determine the bounce direction of the ray and update the structure\n            ray.mDirection = reflect(ray.mDirection, currentIntersection.mNormal);\n            ray.mPosition = currentIntersection.mPoint + ray.mDirection * EPSILON;\n\n            // Trace the ray forward\n            currentIntersection = CheckSceneForIntersection(ray);\n        }\n        else\n        {\n            // We didn't hit anything, so return the texture cube color and break out!\n            color.rgb += texture(iChannel0, ray.mDirection).rgb * specular; \n            break; \n        }\n    }\n    \n#if SHOW_NORMALS    \n    fragColor = vec4(normal * 0.5 + 0.5, 1.0); // Modify the normal to go from [0,0] to [1,1]\n#else\n    fragColor = vec4(color.rgb, 1.0);\n#endif \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xls3DM","date":"1422494432","viewed":573,"name":"A Simple Ray Tracer","username":"AxleMike","description":"My first ray tracer.  Basically a testbed to mess around in.","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","raytracer","sphere","softshadows","plane"],"hasliked":0,"parentid":"","parentname":""}}