{"ver":"0.1","info":{"id":"Mc3cRn","date":"1730396572","viewed":346,"name":"Lego blocks","username":"morimea","description":"Simple lego blocks in SDF.\n\n[b]Control:[/b]\nMouse x (click)- left middle right - 3 views\nMouse y - shift for view","likes":34,"published":3,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","grid","sdf","voxel","cubes","lego"],"hasliked":0,"parentid":"DljGzy","parentname":"TEMPLATE 3d sdf raymarch 2023"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Danil (2024+) https://github.com/danilw\n// https://mastodon.gamedev.place/@danil\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// self https://www.shadertoy.com/view/Mc3cRn\n\n\n// if you look for templates - look\n// https://danilw.github.io/blog/my_shader_templates_list/\n\n\n// CONTROL:\n// Mouse x (click)- left middle right - 3 views\n// Mouse y - shift for view\n\n\n// Ultra-wide screen fix - define this - or/and edit second clamp value in that define\n//#define FIX_FOV_UW\n\n\n//-------------------------\n\n// using\n// https://iquilezles.org/articles/distfunctions/\n// https://mercury.sexy/hg_sdf\n// palette from iq https://www.shadertoy.com/view/ll2GD3\n// sdf repetition fix by blackle https://www.shadertoy.com/view/WtXcWB\n\n\n//-------------------------\n\n// angle loop fix\n#define ANGLE_loop (min(iFrame,0))\n//#define ANGLE_loop 0\n\n#define MIN_DIST 0.000001\n#define MAX_DIST 1000.\n\n#define MAX_MARCHING_STEPS 256\n// set epsilon_step bigger for smaller number of step\n// for 64 is 0.01, for 256 is 0.001, 512 0.0001\n#define epsilon_step 0.0001\n\n#define MAX_SHADOW_STEPS 64\n#define MAX_REFL_STEPS 64\n\n\n//-------------------------\n\n#define OBJ_SKIP -1\n#define OBJ_SKY 0\n#define OBJ_CUBE 10\n#define OBJ_CT0 250100\n#define OBJ_CT1 501000\n#define OBJ_CT2 1100000\n\n//-------------------------\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n\nconst vec3 lightDir = normalize(vec3(1.5, .65, 1.50));\n// ggx only\nconst float sunIluminance = 1.25;\nconst vec3 ggx_light2_dir = normalize(vec3(-0.2662, -0.8589, 0.4376));\nconst vec3 sky_topCol = vec3(0.51, 0.534, 1.0);\nconst vec3 bottomCol = vec3(1.);\n\n//-------------------------\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nvec3 get_maid(int tid);\nvec2 map( in vec3 pos)\n{\n    vec2 res = vec2( MAX_DIST, float(OBJ_SKY));\n    {\n        vec2 tp = pos.xz;\n        vec2 tidt = pMod2(tp, vec2(1.));\n        int tid = int(tidt.x)*500+int(tidt.y);\n        \n        const float rad = 0.0525;\n        const vec3 box = vec3(0.5)-0.0003;\n        \n        \n        // sdf repetition fix by blackle https://www.shadertoy.com/view/WtXcWB\n        // needed only when boxed have different height, and when camera outside\n        {\n            res = opU( res, vec2(sdBox( vec3(tp.x-1.,pos.y,tp.y+0.), box*0.795 ),float(OBJ_SKIP)));\n            //res = opU( res, vec2(sdBox( vec3(tp.x+1.,pos.y,tp.y+0.), box*0.95 ),float(OBJ_SKIP)));\n            res = opU( res, vec2(sdBox( vec3(tp.x+0.,pos.y,tp.y-1.), box*0.795+vec3(1.,0.,0.)),float(OBJ_SKIP)));\n            //res = opU( res, vec2(sdBox( vec3(tp.x+0.,pos.y,tp.y+1.), box*0.95 ),float(OBJ_SKIP)));\n        }\n        \n        if(tidt.x<0.||tidt.y<0.||tidt.x>500.||tidt.y>500.){return res;}\n        vec3 tpa = get_maid(tid);\n        \n        res = opU( res, vec2(sdRoundBox( vec3(tp.x-tpa.y,pos.y,tp.y-tpa.z), box+vec3(tpa.x,0.,1.), rad ),float(OBJ_CUBE+tid)));\n        res = opU( res, vec2(sdRoundedCylinder( vec3(tp.x,pos.y-.5,tp.y), 0.25*0.5, 0.051, 0.15 ),float(OBJ_CT0+tid)));\n    }\n    \n    return res;\n}\n\n// map_n to fix - line on normal\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/Mc3cRn_norm.png\nvec2 map_nbox( in vec3 pos)\n{\n    vec2 res = vec2( MAX_DIST, float(OBJ_SKY));\n    \n    {\n        vec2 tp = pos.xz;\n        vec2 tidt = pMod2(tp, vec2(1.));\n        int tid = int(tidt.x)*500+int(tidt.y);\n        const float rad = 0.0525;\n        const vec3 box = vec3(0.5)-0.0003;\n        \n        if(tidt.x<0.||tidt.y<0.||tidt.x>500.||tidt.y>500.){return res;}\n        vec3 tpa = get_maid(tid);\n        \n        res = opU( res, vec2(sdRoundBox( vec3(tp.x-tpa.y,pos.y,tp.y-tpa.z), box+vec3(tpa.x,0.,1.), rad ),float(OBJ_CUBE+tid)));\n        //res = opU( res, vec2(sdRoundedCylinder( vec3(tp.x,pos.y-.5,tp.y), 0.25*0.5, 0.051, 0.15 ),float(OBJ_CT0+tid)));\n    }\n    \n    return res;\n}\nvec2 map_ncyl( in vec3 pos)\n{\n    vec2 res = vec2( MAX_DIST, float(OBJ_SKY));\n    \n    {\n        vec2 tp = pos.xz;\n        vec2 tidt = pMod2(tp, vec2(1.));\n        \n        int tid = int(tidt.x)*500+int(tidt.y);\n        \n        const float rad = 0.0525;\n        const vec3 box = vec3(0.5)-0.0003;\n        \n        if(tidt.x<0.||tidt.y<0.||tidt.x>500.||tidt.y>500.){return res;}\n        vec3 tpa = get_maid(tid);\n        \n        //res = opU( res, vec2(sdRoundBox( vec3(tp.x-tpa.y,pos.y,tp.y-tpa.z), box+vec3(tpa.x,0.,1.), rad ),float(OBJ_CUBE+tid)));\n        res = opU( res, vec2(sdRoundedCylinder( vec3(tp.x,pos.y-.5,tp.y), 0.25*0.5, 0.051, 0.15 ),float(OBJ_CT0+tid)));\n    }\n    \n    return res;\n}\n\n// 10-cube variations 0-9\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/X32fzK_tid.jpg\n// 1xxxxxxx\nuint [12] maidx1 = uint[12](\n10610661u,\n12732773u,\n10101061u,\n12345273u,\n10145061u,\n12323273u,\n10106101u,\n12327323u,\n10610661u,\n12732773u,\n18066101u,\n19277323u\n);\n\nuint [12] maidx2 = uint[12](\n18018061u,\n19239273u,\n10101018u,\n14523239u,\n14501801u,\n12323923u,\n10610661u,\n12732773u,\n10106101u,\n12327323u,\n10101018u,\n12323239u\n);\n\n// color index\nuint[6] idti1 = uint[6](\n1112222u,\n3344555u,\n6644777u,\n8899900u,\n1112222u,\n3444455u\n);\n\nuint[6] idti2 = uint[6](\n1223444u,\n5566778u,\n5577900u,\n1112222u,\n3344455u,\n6677889u\n);\n\n// color index shift at (where 0)\nivec2 ti1 = ivec2(4,2);\nivec2 ti2 = ivec2(4,1);\n\nfloat hash11(float p);\nfloat get_maiddpal(int tid){\n    ivec2 tidp = ivec2(tid/500, tid%500);\n    int tidg = (tidp/ivec2(7,12)).x+(tidp/ivec2(7,12)).y*50;\n    tidp = tidp%ivec2(7,12);\n    float et = .0;\n    if((tidg%2)==0){if(!((tidp.y/2==ti1.y&&tidp.x>ti1.x)||tidp.y/2>ti1.y))et = 0.35;}\n    else{if(!((tidp.y/2==ti2.y&&tidp.x>ti2.x)||tidp.y/2>ti2.y))et = 0.35;}\n    uint ma = 0u;\n    if((tidg%2)==0)ma=idti1[5-tidp.y/2];\n    else ma=idti2[5-tidp.y/2];\n    const uint[10] upw = uint[10](1u, 10u, 100u, 1000u, 10000u, 100000u, 1000000u, 10000000u, 100000000u, 1000000000u);\n    uint mda = upw[6-tidp.x];\n    int idx = int(ma/mda)%10;\n    //return float(idx)/7.;\n    return float(tidg)*.3+(hash11(float(tidg)*0.53+0.3)*1.2+0.2)*float(idx)/7.+et;\n}\n\nvec3 get_maid(int tid){\n    ivec2 tidp = ivec2(tid/500, tid%500);\n    int tidg = (tidp/ivec2(7,12)).x+(tidp/ivec2(7,12)).y*50;\n    tidp = tidp%ivec2(7,12);\n    uint ma = 0u;\n    if((tidg%2)==0)ma=maidx1[11-tidp.y];\n    else ma=maidx2[11-tidp.y];\n    const uint[10] upw = uint[10](1u, 10u, 100u, 1000u, 10000u, 100000u, 1000000u, 10000000u, 100000000u, 1000000000u);\n    uint mda = upw[6-tidp.x];\n    int idx = int(ma/mda)%10;\n    return vec3(float(idx<8),float(idx<6)*float(1-2*(idx%2)),float(idx<4)*float(2*(idx/2)-1)+float(idx>5)*float(2*(idx%2)-1));\n}\n\n//-------------------------\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 get_pal(float d){\n    d = fract(d);\n    vec3 col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n    //col.b += col.g*col.b;\n    return normalize(col*col+0.001)*0.75+0.25*col*col;\n}\n\nvec3 color_by_object_id(int obj_id){\n    if(obj_id>=OBJ_CUBE&&obj_id<OBJ_CUBE+500*500)obj_id=obj_id-OBJ_CUBE;\n    if(obj_id>=OBJ_CT0)obj_id=obj_id-(obj_id>OBJ_CT0+500*500?(obj_id>OBJ_CT1+500*500?OBJ_CT2:OBJ_CT1):OBJ_CT0);\n    vec3 albedo = get_pal(get_maiddpal(obj_id)*1.33);\n    return albedo;\n}\n\n//-------------------------\n\nvec2 raycast( in vec3 ro, in vec3 rd){\n    vec2 res = vec2( MAX_DIST, float(OBJ_SKY));\n\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n    \n    //call boxAABB here to save performance\n\n    float t = tmin;\n    for( int i=ANGLE_loop; i<MAX_MARCHING_STEPS && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t);\n        if( abs(h.x)<(epsilon_step*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ANGLE_loop; i<MAX_SHADOW_STEPS; i++ )\n    {\n\t\tfloat h = map(ro + rd*t).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n\nfloat calcSoftshadow_reflect( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ANGLE_loop; i<MAX_REFL_STEPS; i++ )\n    {\n\t\tfloat h = map(ro + rd*t).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\n// https://iquilezles.org/articles/normalsSDF\n\n// map_n to fix - line on normal\n// https://danilw.github.io/GLSL-howto/vulkan_sh_launcher/X32fzK_tid.jpg\nvec3 calcNormal( in vec3 pos, int obj_id)\n{\n\n    vec2 e = vec2(1.0,-1.0)*0.00025;\n    /*\n        return normalize( e.xyy*map( pos + e.xyy).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx).x ); \n    */\n    if(obj_id>=OBJ_CUBE&&obj_id<OBJ_CUBE+500*500){\n        return normalize( e.xyy*map_nbox( pos + e.xyy).x + \n\t\t\t\t\t  e.yyx*map_nbox( pos + e.yyx).x + \n\t\t\t\t\t  e.yxy*map_nbox( pos + e.yxy).x + \n\t\t\t\t\t  e.xxx*map_nbox( pos + e.xxx).x );  \n    }\n    if(obj_id>=OBJ_CT0){\n        return normalize( e.xyy*map_ncyl( pos + e.xyy).x + \n\t\t\t\t\t  e.yyx*map_ncyl( pos + e.yyx).x + \n\t\t\t\t\t  e.yxy*map_ncyl( pos + e.yxy).x + \n\t\t\t\t\t  e.xxx*map_ncyl( pos + e.xxx).x );  \n    }\n    \n    return normalize(pos);\n}\n\n// https://iquilezles.org/articles/nvscene2008/rwwtt.pdf\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ANGLE_loop; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map(pos + h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 applyFog(in vec3  rgb, in vec3 skyColor, in float dist) {\n    float startDist = MAX_DIST/1.75-2.;\n    float fogAmount = 2.0 * (1.0 - exp(-(dist-startDist) * (1.0/startDist)));\n    return mix(rgb, skyColor, clamp(fogAmount, 0.0, 1.0));\n}\n\nvec3 calculateSunColor(float sunZenith);\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness);\nvec3 get_sky_color(vec3 rd, float sunIlum, float sun_power);\nvec3 render( in vec3 ro, in vec3 rd)\n{ \n    // sky\n    vec3 sky_col = get_sky_color(rd, sunIluminance, 1.);\n    //vec3 col = sky_col;\n    vec3 col = vec3(0.);\n    \n    // raycast scene\n    vec2 res = raycast(ro, rd);\n    float t = res.x;\n\tint mid = int(res.y);\n    \n\n    if( mid>OBJ_SKY )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos, mid);\n\n        float mat_s=0.05;\n\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = color_by_object_id(mid);\n        \n        float ks = 1.;\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n\n\n\t\tfloat lamb1 = clamp((dot(nor, lightDir))*(1./PI), 0.0, 1.0);\n\t\tfloat lamb2 = clamp((dot(nor, ggx_light2_dir))*(1./PI), 0.0, 1.0);\n        vec3 sunColor = calculateSunColor(lightDir.y);\n        vec3 sunColor2 = calculateSunColor(ggx_light2_dir.y);\n\n        float reflect_sh = 1.;\n        reflect_sh=calcSoftshadow_reflect( pos, ref, 0.02, 4.5 );\n        float shadow = 1.;\n\t\tshadow = calcSoftshadow( pos, lightDir, 0.02, 20.5 );\n\t\tfloat ao = smoothstep(0., 4., occ);\n        \n\t\tfloat diffuse = lamb1;\n\t\tdiffuse *= shadow;\n\t\tvec3 result = mix(vec3(0.), sunColor, diffuse);\n\n\t\tdiffuse += lamb2*ao;\n\t\tresult += mix(vec3(0.), sunColor2, lamb2*ao);\n        \n        const float material_shininess = 0.543;\n        mat_s+=material_shininess;\n\n\t\tconst float material_intensity = 0.15;\n\t\tconst float AMB_STRENGTH = .63;\n        \n        diffuse += ao*AMB_STRENGTH;\n        \n        vec3 AMB_COL = vec3(0.3);\n        float tmat_s=1.-(mat_s+0.5);\n        const float mix_material_skyref = 0.5;\n        AMB_COL+=mix(sky_topCol,mix_material_skyref*sky_topCol,tmat_s);\n\t\tresult += mix(vec3(0), AMB_COL, ao*AMB_STRENGTH);\n        vec3 albedo = col;\n\t\tresult*= albedo;\n        \n\t\tfloat spec = ggx(nor, -rd, lightDir, mat_s);\n\t\tfloat specular = spec*material_intensity;\n        \n\t\tresult = mix(result*0.75+result*reflect_sh*0.25, result+sunColor, specular*shadow);\n        \n\t\tlin = result;\n\n        col = lin;\n        //col = applyFog(col, sky_col, t);\n\n    }\n\treturn vec3(col);\n}\n\n//-------------------------\n\nmat2 MD(float a){float s = sin( a );float c = cos( a );return mat2(vec2(c, -s), vec2(s, c));}\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    float camf = 1.-clamp(iMouse.y/iResolution.y,0.,1.);\n    float came = 1.-clamp(iMouse.x/iResolution.x,0.,1.);\n    vec2 c3 = vec2(.5,5.*camf);\n    vec2 c1 = vec2(1.,1.*camf);\n    vec2 c2 = vec2(0.,.5);\n    \n    int mid=int(3.*abs(iMouse.z)/iResolution.x);\n    if(mid==0){camf=c1.x;came=c1.y;}\n    if(mid==1){camf=c2.x;came=c3.y;}\n    if(mid==2){camf=c3.x;came=c3.y;}\n    \n    ro = vec3(250.,2.5+10.*came*0.5+55.*(1.-smoothstep(0.,1.,sqrt(camf))),250.);\n    ro.xz+=vec2(150.,0.)*MD(iTime*(1./75.)*(3.14159265*2.)*0.1);\n    \n    vec2 m = (iMouse.xy/iResolution.xy-0.5)*3.14159265*vec2(2.,1.);\n    m=vec2(0.,-0.5*3.1415926);\n    vec2 sm = m;\n    sm.x = atan(-fract((1./75.)*iTime*0.1))*4.*2.;\n    sm.y = sm.y+camf*0.82;\n    m = sm;\n    \n    m.y = -m.y;\n#ifdef FIX_FOV_UW\n    float fov=clamp(20.+60.*camf,20.,65.);\n    if(mid==2)fov=clamp(120.-80.*camf,20.,65.);\n#else\n    float fov=clamp(20.+60.*camf,20.,80.);\n    if(mid==2)fov=clamp(120.-80.*camf,20.,120.);\n#endif\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n    \n    // cylindrical perspective https://www.shadertoy.com/view/ftffWN\n      float a = rd.x/rd.z;\n      rd.xz = rd.z * vec2(sin(a),cos(a));\n    \n    rd = normalize(rd);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n\n    \n      const float maxFocalLength = 1.97;\n      float focalLength = maxFocalLength;\n      vec3 camForward = vec3(0., 0., 1.);\n      rd = normalize(rd+camForward * focalLength);\n\n    rd = (rotY * rotX) * rd;\n}\n//-------------------------\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro; vec3 rd;\n    SetCamera(uv, ro, rd);\n    vec3 color = render( ro, rd );\n    \n    color = ACESFilm(color);\n    color = srgb_encode(color);\n\n    color = pow( color, vec3(0.4545) );\n    fragColor = vec4( color, 1.0 );\n}\n\n\n// sky\n//----------------------------------------------\n\nconst float sunAngularDiameter = 2.5;\n\nconst float goldenAngle = 2.3999632297286533;\n\n\n// sky from https://www.shadertoy.com/view/3dlSW7\n\nfloat hGPhase(float cosTheta, const float g){\n\tfloat g2 = g * g;\n    \n    return 0.25 * (1.0 - g2) * pow(g2 - 2.0 * g * cosTheta + 1.0, -1.5);\n}\n\nvec3 calculateSunColor(float sunZenith){\n\treturn mix(vec3(1.0, 0.4, 0.05), vec3(1.0), max(sunZenith, 0.0));\n}\n\nfloat calculateSun(float lDotV, float sunIlum){\n    const float cosRad = cos(radians(sunAngularDiameter));\n    float sunLuminance = sunIlum / ((1.0 - cosRad) * TAU);\n    \n    return smoothstep(cosRad,cosRad*1.001, lDotV) * sunLuminance;\n}\n\nvec3 calculateSky(vec3 background, float lDotU, float lDotV, float sunIlum){\n    float phaseMie = hGPhase(lDotV, 0.8);\n    \n    float zenith = max(lDotU, 0.0);\n    \n    float sunZenith = lightDir.y;\n    \n    vec3 sky = mix(sky_topCol, (bottomCol + sky_topCol), exp2(-zenith * 8.0));\n         sky += phaseMie * exp2(-zenith * 6.0);\n    \n    vec3 absorbColor = calculateSunColor(1.0 - exp2(-zenith * 2.0));\n    \n    sky = sky * mix(absorbColor * 0.9 + 0.1, vec3(1.0), sunZenith);\n\treturn background * absorbColor + sky * sunIlum * (1.0 - clamp(-sunZenith * 10.0, 0.0, 1.0));\t\n}\n\nvec3 get_sky_color(vec3 rd, float sunIlum, float sun_power){\n    float lDotU = dot(rd, vec3(0.,1.,0.));\n\tfloat lDotV = dot(rd, lightDir);\n    vec3 col = vec3(0.0);\n    col += sun_power*calculateSun(lDotV,sunIlum)*calculateSunColor(lightDir.y);\n    col = calculateSky(col, lDotU, lDotV,sunIlum);\n    return col;\n}\n\n//----------------------------------------------\n\n// ggx\n//----------------------------------------------\nfloat G(float dotNV, float k){\n\treturn 1.0/(dotNV*(1.0f-k)+k);\n}\nfloat ggx(vec3 N, vec3 V, vec3 L, float roughness){\n    float F0 = 0.6;\n\tfloat alpha = roughness*roughness;\n\n\tvec3 H = normalize(V+L);\n\n\tfloat dotNL = clamp(dot(N,L),0.,1.);\n\tfloat dotNV = clamp(dot(N,V),0.,1.);\n\tfloat dotNH = clamp(dot(N,H),0.,1.);\n\tfloat dotLH = clamp(dot(L,H),0.,1.);\n\n\tfloat F, D, vis;\n\n\tfloat alphaSqr = alpha*alpha;\n\tfloat pi = 3.14159;\n\tfloat denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n\tD = alphaSqr/(pi * denom * denom);\n\n\tfloat dotLH5 = pow(1.0 - dotLH, 5.0);\n\tF = F0 + (1.0 - F0)*(dotLH5);\n\n\tfloat k = alpha * 0.5;\n\n\treturn dotNL * D * F * G(dotNL,k)*G(dotNV,k);\n}\n\n\n// look https://www.shadertoy.com/view/4fsSRn\n// read https://arugl.medium.com/hash-noise-in-gpu-shaders-210188ac3a3e\n\n#define FIX_FRACT_HASH 1000.\n\n#ifdef FIX_FRACT_HASH\nfloat fix_float(float x){return sign(x)*(floor(abs(x))+floor(fract(abs(x))*FIX_FRACT_HASH)/FIX_FRACT_HASH);}\n#else\nfloat fix_float(float x){return x;}\n#endif\n\nfloat hash12(vec2 p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash11(float p)\n{\n#ifdef FIX_FRACT_HASH\n    p = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n#endif\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n","name":"Image","description":"","type":"image"}]}