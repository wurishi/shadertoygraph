{"ver":"0.1","info":{"id":"ltjcWW","date":"1508679506","viewed":2546,"name":"Smooth Step Alternatives","username":"tholzer","description":"Comparing some smooth step (x & y: 0.0 to 1.0) alternatives... \nPress mouse button to see function graph without  x=clamp(x,0,1);\nSwitch to fullscreen for better comparison of function differences.\n","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["graph","smoothstep","smooth","ramp","step","interpolate","smootherstep","diagram","antialaised","tanh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//---------------------------------------------------------\n// Smooth_Step_Alternatives.glsl\n//\n// Comparing some smooth step alternatives...\n// Press mouse button to see function graph without x=clamp(x,0,1);\n// Switch to fullscreen to examine differences.\n//\n// v1.0  2017-10-22  initial release\n// v1.1  2017-11-04  gain(x,k) function added\n// v1.2  2018-01-30  smootheststep(x,s) added\n// v1.3  2018-11-05  hyperbolicTangent(x,s) added\n// v1.4  2021-12-09  improved version\n// v1.5  2023-03-19  improved ss_sinus to ss_cosine\n//\n// see also:\n//   https://www.shadertoy.com/view/4ldSD2 by stubbe\n//   https://www.shadertoy.com/view/ltByWW by grinist\n//   https://www.shadertoy.com/view/Xl2cDW by luluco250\n//   https://www.shadertoy.com/view/ldjcDc by gPlatl\n//\n// tags: smooth, smoothstep, smootherstep, gain, ramp, step,\n//       interpolate, antialiased, graph, diagram, tanh\n//\n// Desmos function plotter\n//   https://www.desmos.com/calculator/j1zjtitajn?lang=de\n//\n// function plotter created from Inigo Quilez:\n//   https://iquilezles.org/apps/graphtoy/\n//---------------------------------------------------------\n\nconst float pi = atan(1.0) * 4.0;\n\nbool mousePressed = false;\n\nfloat xClamp(float x)\n{\n  return mousePressed ? x : clamp(x, 0.0, 1.0);\n}\n\n//-------- alternative smooth step fucntions --------------\n\nfloat _smoothstep(float x)    // original smoothstep function\n{\n  return x*x*(3.0 - 2.0*x);   // y: 0.0 .. 1.0\n}\n\n// sstep - \"smootherstep alternative\"  y=x/(x+(1-x)*(1-x))\nfloat sstep(float x)\n{\n  x = xClamp(x);\n  float ix = 1.0 - x;       \n  x = x * x;\n  return x / (x + ix * ix);    \n}\n\n// ssteppow - Like above but with a pow function to control the shape.\n// p < 1: seat, p = 1: lerp, p > 1: sigmoid\n// demo range of 'p':  0.0 .. 2.0\nfloat ssteppow(float x, float p)\n{\n  x = xClamp(x);\n  float ix = 1.0 - x;\n  x = pow(x, p);\n  return x / (x + pow(ix, p));  // y=x/(x+(1-x)^p)\n}\n\n// Original smootherstep\nfloat smootherstep(float x)\n{\n  x = xClamp(x);\n  return x * x * x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n// https://www.shadertoy.com/view/ltSfWV\n// continuity is independent of steepness parameter s\n// at x = 1/2: 3rd derivative = 0 for s = 1;  2rd derivative = 0 for all values of s\nfloat smoothestStep(float x, float s)\n{\n  const float ss = 2.88539;// 2.0 / log(2.0)\n  s *= ss;\n  x = clamp(x, 0.0, 1.0);\n  return 1.0 / (1.0 + exp2(tan(x * pi - pi*0.5) * -s));\n}\n\n// Regular sigmoid curve with the exception of\n// x * 10 - 5, which seems to normalize the curve.\nfloat sigmoid(float x)\n{\n  //x = xClamp(x);\n  return 1.0 / (1.0 + exp(-(x * 10.0 - 5.0)));\n}\n\nfloat ss_cosine(float x)\n{\n  x = xClamp(x);\n//return sin(x * pi - pi * 0.5) * 0.5 + 0.5;\n//return 0.5 * (1.0 - cos(pi*x));    // see @Dusty's comment\n  return 0.5 - 0.5*cos(pi*x);\n}\n\n// added from https://www.shadertoy.com/view/MdBfR1\n// demo range of 'k':  2.0 .. 8.0\nfloat gain1(float x, float k)\n{\n  x = clamp(x, 0.0, 1.0);\n  float s = sign(x-0.5);\n  float o = (1.0+s)/2.0;\n  return o - 0.5*s*pow(2.0*(o-s*x),k);\n}\n\nfloat gain2(float x)\n{\n  x = xClamp(x);\n  float s = sign(x-0.5);\n  x =    1.0 + s*(1.0-2.0*x);\n  return 0.5*(1.0 + s*(1.0-x*x));\n}\n\n// https://en.wikipedia.org/wiki/Hyperbolic_function\n// https://www.researchgate.net/figure/Hyperbolic-tangent-function-Plot-of-the-hyperbolic-tangent-function-y-tanhax-for_fig9_6266085\n// https://de.wikipedia.org/wiki/Tangens_hyperbolicus_und_Kotangens_hyperbolicus\n// demo range of 'k':  4.0 .. 8.0\nfloat hyperbolicTangent(float x, float k)\n{\n\treturn 0.5 + 0.5 * tanh((x-0.5)*k);\n}\n//---------------------------------------------------------\nvec2 uv = vec2(0.0);      // pixel position\nvec2 dxy = vec2(0.002);   // pixel size in graph units\n\nvoid mixColor(inout vec4 baseCol, vec4 color, float alpha)\n{\n  baseCol = vec4(mix(baseCol.rgb, color.rgb, alpha * color.a), 1.0);\n}\n\nvoid drawGrid(inout vec4 baseCol, float stepSize, vec4 gridCol)\n{\n  float mul = 1.0 / stepSize;\n  vec2 g = abs(vec2(-0.5) + fract((uv + vec2(stepSize) * 0.5) * mul)); // g passes 0 at stepSize intervals\n  g = vec2(1.0) - smoothstep(vec2(0.0), dxy * mul * 1.5, g);\n  mixColor(baseCol, gridCol, max(g.x, g.y));\n}\n\nvoid drawCurve(inout vec4 baseCol, vec4 curveCol, float value)\n{\n  // Using y distance to curve, modifying distance threshold with approximated slope\n  // Derivative breaks with drastic changes of value and discontinuities, but so be it\n  float yDist = abs(value - uv.y);\n  float dValue = abs(dFdx(value));\n  float c = 1.0 - smoothstep(0.0, (dxy.y + dValue) * 2.0, yDist);\n  mixColor(baseCol, curveCol, c);\n}\n\n//---------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  // set global values\n  float aspect = iResolution.x / iResolution.y;\n  uv =   fragCoord.xy / iResolution.xy * 2.0 -1.0;  //-1 .. 1\n  vec2 mp = iMouse.xy / iResolution.xy * 2.0 -1.0;\n  uv = 0.5 + uv * 0.6 * vec2(aspect, 1.0);\n  dxy = 0.7 * vec2(aspect, 1.0) / iResolution.xy;\n  mousePressed = iMouse.z > 0.0;\n\n  // background\n//vec4 col = vec4(0.9, 0.9, 0.9, 1.0);\n  vec4 col = mix(vec4(1.0), vec4(0.7, 0.7, 0.7, 1.0), pow(length(0.5 - uv) * 1.2, 3.5));\n\n  // grid\n  drawGrid(col, 0.1, vec4(0.0, 0.0, 0.0, 0.2));\n  drawGrid(col, 0.5, vec4(0.0, 0.0, 0.0, 0.3));\n  drawGrid(col, 1.0, vec4(0.0, 0.0, 0.0, 0.4));\n\n  // curves\n  vec4 yellow = vec4(0.77, 0.77, 0.15, 0.8);\n  vec4 gray75 = vec4(0.75, 0.75, 0.75, 0.8);\n  vec4 green  = vec4(0.35, 0.85, 0.15, 0.8);\n  vec4 orange = vec4(1.00, 0.50, 0.25, 0.8);\n  vec4 olive  = vec4(0.10, 0.50, 0.10, 0.8);\n  vec4 red    = vec4(0.91, 0.13, 0.23, 0.8);\n  vec4 blue   = vec4(0.15, 0.45, 0.85, 0.8);\n  vec4 violet = vec4(0.55, 0.15, 0.55, 0.8);\n  vec4 gray25 = vec4(0.25, 0.25, 0.25, 0.8);\n  float sinTime = sin(iTime);\n  \n  if (mp.x < 0.5)\n  { // draw static curves                       \n    drawCurve(col, gray75, smoothstep(0.0,1.0,uv.x));\n    drawCurve(col,  green, smootherstep(uv.x));\n    drawCurve(col,    red, sstep(uv.x));\n    drawCurve(col, yellow, sigmoid(uv.x));\n    drawCurve(col, violet, ss_cosine(uv.x));\n    drawCurve(col,   blue, gain2(uv.x));\n  }\n  // draw animated curves\n  drawCurve(col,  olive, smoothestStep(uv.x, 1.5 + sinTime)); // 0.5 .. 2.5\n//drawCurve(col, gray25, ssteppow(uv.x, 2.0 + sinTime));      // 1 .. 3\n  drawCurve(col,   blue, gain1(uv.x, 5.0 + 3.0*sinTime));      // 2 .. 8\n  drawCurve(col, orange, hyperbolicTangent(uv.x, 6.0+2.0*sinTime));  // 4 .. 8\n  \n  fragColor = col;\n}\n","name":"Image","description":"","type":"image"}]}