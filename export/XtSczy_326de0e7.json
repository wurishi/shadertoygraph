{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//the colors at the bottom of the image show the physics simulation buffer in action.\n#define numpts 20\n#define radius 0.2\n#define fdist 0.8\n#define eps 0.1\n#define sharpness 3.\n#define floorheight -20.\n#define outradius 1.\n#define inradius 0.2\n#define reflectivity 0.2\n#define maxdist 100.\n#define previewy 20.\n\nvec3 getpos(in float y) {\n    return textureLod(iChannel0, vec2(0., y/iResolution.y), 0.).xyz;\n}\n\nfloat torussdf( vec3 pos )\n{\n    vec3 p = pos - vec3(sin(iTime) * 2., 0.8, sin(iTime / 2.) * 10.);\n    vec2 q = vec2(length(p.yz)-outradius,p.x);\n    return length(q)-inradius;\n}\n\nfloat capsulesdf(vec3 pos, vec3 a, vec3 b) {\n    vec3 dir = b - a;\n    vec3 view = pos - a;\n    float h = clamp(dot(dir, view) / dot(dir, dir), 0., 1.);\n    return length(view - h * dir) - radius;\n}\n\nfloat chainsdf(vec3 pos) {\n    int i;\n    vec3 a = getpos(0.);\n    vec3 b = getpos(1.);\n    float d = exp(-capsulesdf(pos, a, b) * sharpness);\n    for (i=2; i<numpts; i++) {\n        a = b;\n        b = getpos(float(i));\n        d += exp(-capsulesdf(pos, a, b) * sharpness);\n    }\n    return -log(d) / sharpness;\n}\n\nvec2 sdf(vec3 pos) {\n    float h1 = chainsdf(pos);\n    float h2 = torussdf(pos);\n    return h1 < h2 ? vec2(h1, 2.) : vec2(h2, 1.);\n}\n\nvec3 getchainnormal(vec3 pos) {\n    float xp = chainsdf(pos + vec3(eps, 0., 0.));\n    float xm = chainsdf(pos - vec3(eps, 0., 0.));\n    float ddx = xp - xm;\n    float yp = chainsdf(pos + vec3(0., eps, 0.));\n    float ym = chainsdf(pos - vec3(0., eps, 0.));\n    float ddy = yp - ym;\n    float zp = chainsdf(pos + vec3(0., 0., eps));\n    float zm = chainsdf(pos - vec3(0., 0., eps));\n    float ddz = zp - zm;\n    return normalize(vec3(ddx, ddy, ddz));\n}\nvec3 gettorusnormal(vec3 pos) {\n    float xp = torussdf(pos + vec3(eps, 0., 0.));\n    float xm = torussdf(pos - vec3(eps, 0., 0.));\n    float ddx = xp - xm;\n    float yp = torussdf(pos + vec3(0., eps, 0.));\n    float ym = torussdf(pos - vec3(0., eps, 0.));\n    float ddy = yp - ym;\n    float zp = torussdf(pos + vec3(0., 0., eps));\n    float zm = torussdf(pos - vec3(0., 0., eps));\n    float ddz = zp - zm;\n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec2 raytrace(vec3 rp, vec3 rd) {\n    vec2 d = sdf(rp);\n    float dist = d.x;\n    float t = 0.;\n    int i;\n    for (i=0; i<100; i++) {\n        t += dist/1.3;\n        d = sdf(rp + t * rd);\n        dist = d.x;\n        if (abs(dist) < eps || dist > maxdist) break;\n    }\n    if (abs(dist) < eps) {\n        return vec2(t, d.y);\n    } else {\n        return vec2(t, 0.);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > previewy) {\n       \n        vec2 uv = fragCoord / iResolution.x;\n        //camera\n\n        vec3 camPos = vec3(-40., -11., 0.);\n        vec3 ww = normalize(vec3(1., 0., 0.));\n        vec3 uu = normalize(cross(ww, vec3(0., 1., 0.)));\n        vec3 vv = cross(uu, ww);\n        vec3 rd = ww * fdist + (uv.x-0.5) * uu + (uv.y-0.5*iResolution.y/iResolution.x) * vv;\n\n        vec2 d = raytrace(camPos, rd);\n        if (d.y > 1.5) {\n            vec3 norm = getchainnormal(camPos + d.x * rd);\n            vec3 refl = reflect(rd, norm);\n            vec3 col1 = texture(iChannel1, refl).xyz;\n            vec3 col2 = (norm.xyz + 1.)/2.;\n            fragColor = vec4(col1 * reflectivity + col2 * (1.-reflectivity), 1.);\n        } else if (d.y > 0.5) {\n            vec3 norm = gettorusnormal(camPos + d.x * rd);\n            fragColor = vec4((norm + 1.).yyy/2., 1.);\n        } else {\n            fragColor = texture(iChannel1, rd);\n        }\n    } else {\n        vec2 uv = vec2(fragCoord.y/previewy*2.,fragCoord.x/iResolution.x*float(numpts));\n        ivec2 iuv = ivec2(round(uv.x), round(uv.y));\n        fragColor = vec4(abs(texelFetch(iChannel0, iuv, 0).xyz), 1.);\n    }\n        //fragColor = vec4(abs(texture(iChannel0, fragCoord/iResolution.xy/10.).xyz), 1.);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"//physics happens here.\n#define numpts 20.\n#define gravity 0.002\n#define friction 0.0001\nvec3 getpos(in float y) {\n    return textureLod(iChannel0, vec2(0., y/iResolution.y), 0.).xyz;\n}\n\nvec3 getvel(in float y) {\n    return textureLod(iChannel0, vec2(1., y)/iResolution.y, 0.).xyz;\n}\n\nvoid edge(in vec3 pos, in vec3 ovel, in float y2, inout vec3 vel) {\n    vec3 posdiff = getpos(y2) - pos;\n    vec3 veldiff = getvel(y2) - ovel;\n    vel += normalize(posdiff) * (clamp(length(posdiff)-1., -1., 1.) * 0.15);\n    vel += normalize(posdiff) * (dot(normalize(posdiff),veldiff) * 0.20);\n                                 \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.y >= numpts || fragCoord.x >= 2.) discard;\n    \n    vec3 pos = getpos(fragCoord.y);\n    vec3 vel = getvel(fragCoord.y);\n    vec3 ovel = vel;\n    \n    //last point in chain should only have one edge\n    if (fragCoord.y < numpts - 1.)\n        edge(pos, ovel, fragCoord.y + 1., vel);\n    edge(pos, ovel, fragCoord.y - 1., vel);\n    vel.y -= gravity;\n    vel *= (1.-friction);\n    pos += vel;\n    \n    //initialization\n    if (iFrame == 0) {\n        pos = vec3(2.*sin(fragCoord.y), 0., fragCoord.y);\n        vel = vec3(0., 0., 0.);\n    }\n    \n    //anchor point behavior\n    if (fragCoord.y < 1.) {\n        pos = vec3(sin(iTime) * 2., 0., sin(iTime / 2.) * 10.);\n        vel = vec3(0., 0., 0.);\n    }\n    \n    fragColor = vec4(fragCoord.x >= 1. ? vel : pos, 0.);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"XtSczy","date":"1508962066","viewed":860,"name":"Worm Physics","username":"ShnitzelKiller","description":"Floppy physics simulation takes place in buffer A. I was inspired by Archee's cloth physics (https://www.shadertoy.com/view/MldXWX), so I adapted his method to a 1D lattice. I'm wasting most of the buffer, but it works.","likes":11,"published":3,"flags":32,"usePreview":0,"tags":["3d","simulation","raycasting","physics","worm"],"hasliked":0,"parentid":"","parentname":""}}