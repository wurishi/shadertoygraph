{"ver":"0.1","info":{"id":"llVGWR","date":"1474231239","viewed":90,"name":"raymarching16091801","username":"francisco","description":"just playing with color","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_P=5;\nvec2 contour[MAX_P];\nfloat sdFloor(vec3 p){\n    return p.y;\n}\nfloat plane(vec3 p,vec3 po,vec3 n){\n    n=normalize(n);\n    vec3 dp=p-po;\n    return dot(dp,n);\n}\nfloat sphere(vec3 p,float r){\n    return length(p)-r;\n}\nfloat line(vec3 p,vec3 po,vec3 n){\n    n=normalize(n);\n    vec3 dp=po-p;\n    vec3 prj_dp=dot(n,dp)*n;\n    vec3 d=dp-prj_dp;\n    return length(d);\n}\nfloat cylinder(vec3 p,vec3 po,vec3 n,float r){\n    return line(p,po,n)-r;\n}\nfloat cone(vec3 p,vec3 po,vec3 n,float dr){\n    n=normalize(n);\n    vec3 dp=po-p;\n    vec3 prj_dp=dot(n,dp)*n;\n    float r=length(prj_dp)*dr;\n    vec3 d=dp-prj_dp;\n    return length(d)-r;\n}\nvec2 opU( vec2 d1, vec2 d2 )\n{\n    if(d1.x<d2.x)\n        return d1;\n    else\n        return d2;\n}\n\nvec2 opS( vec2 d1, vec2 d2 )\n{\n    if(-d1.x>d2.x)\n        return d1;\n    else\n        return d2;\n}\n\nvec2 opI( vec2 d1, vec2 d2 )\n{\n    if(d1.x>d2.x)\n        return d1;\n    else\n        return d2;\n}\nfloat carving(vec3 p){\n    vec3 zero=vec3(0,0,0);\n    float d=0.0;\n    vec3 q0=vec3(1,0,10);\n    for(float alpha=3.1459/3.0;alpha<2.0*3.14159;alpha+=3.1459/3.0){\n        float x=cos(alpha);\n        float y=sin(alpha);\n        vec3 q1=vec3(x,y,10);\n        vec3 v1=q1-q0;\n        vec3 n=normalize(cross(q0,v1));\n        q0=q1;  \n        d=max(d,plane(p,zero,n));\n    }\n    return d;\n}\nfloat coneContour(vec3 p){\n    vec3 zero=vec3(0,0,0);\n    float d=0.0;\n    float x0=contour[0].x;\n    float y0=contour[0].y;\n    vec3 q0=vec3(x0,y0,-1);\n    for(int i=1;i<MAX_P;i++){\n        float x=contour[i].x;\n        float y=contour[i].y;\n        vec3 q1=vec3(x,y,-1);\n        vec3 v1=q1-q0;\n        vec3 n=normalize(cross(q0,v1));\n        q0=q1;  \n        d=max(d,plane(p,zero,n));\n    }\n    //close the contour\n    vec3 q1=vec3(x0,y0,-1);\n    vec3 v1=q1-q0;\n    vec3 n=normalize(cross(q0,v1));\n    d=max(d,plane(p,zero,n));\n    return d;\n}\nvec2 map(vec3 p){\n    vec3 zero=vec3(0.0,0.0,0.0);\n    vec2 p1=vec2(plane(p,vec3( 0.0,-1.0, 0.0),vec3( 0, 1, 0)),1);\n    vec2 p2=vec2(plane(p,vec3( 0.0, 1.0, 0.0),vec3( 0,-1, 0)),1);\n    vec2 p3=vec2(plane(p,vec3( 0.0, 0.0, 1.0),vec3( 0, 0,-1)),1);\n    vec2 p4=vec2(plane(p,vec3( 0.0, 0.0,-1.0),vec3( 0, 0, 1)),1);\n    vec2 p5=vec2(plane(p,vec3( 1.0, 0.0, 0.0),vec3(-1, 0, 0)),1);\n    vec2 p6=vec2(plane(p,vec3(-1.0, 0.0, 0.0),vec3( 1, 0, 0)),1);\n    vec2 c=opI(opI(opI(opI(opI(p3,p4),p2),p1),p5),p6);\n    //carved cube\n    //return opI(opI(opI(opI(opI(p3,p4),p2),p1),p5),p6);\n    vec2 pc=vec2(plane(p,vec3(0.0, 0.0, -1.0),vec3( 0, 0,1)),2);\n    vec2 cc=vec2(coneContour(p),1);\n    return opU(pc,cc);\n}\nvec3 grad(vec3 p){\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    float d=map(p).x;\n    float gx=map(p+eps.xyy).x - d;\n    float gy=map(p+eps.yxy).x - d;\n    float gz=map(p+eps.yyx).x - d;\n\tvec3 g = vec3(gx,gy,gz);\n\treturn g;\n}\nvec2 trace(vec3 o,vec3 r){\n    float t=0.0;\n    vec2 d=vec2(0,-1);\n    for(int i=0;i<128;i++){\n        vec3 p=o+r*t;\n        d=map(p);\n        if(d.x<0.01)\n            break;\n        t+=d.x*0.95;\n    }\n    if(d.x>=0.01)\n        return vec2(0,-1);\n    else\n        return vec2(t,d.y);\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    contour[0]=vec2( 1, 1);\n    contour[1]=vec2( 0, 0.5);\n    contour[2]=vec2(-1, 1);\n    contour[3]=vec2(-1,-1);\n    contour[4]=vec2( 1,-1);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv=uv*2.0-1.0;\n    uv.x*=iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = iTime*0.0;\n\n\t// camera\t\n\tvec3 ro = vec3(3.5*cos(0.1*time + 2.0*3.1459*mo.x), 4.0 - 4.0*mo.y, 3.5*sin(0.1*time + 2.0*3.1459*mo.x) );\n\tvec3 ta = vec3( 0.0, .0, 0.0 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(uv.xy,2.0) );\n    vec3 r=normalize(vec3(uv,1.0));\n    float the=iTime;\n    //r.xz*=mat2(cos(the),-sin(the),sin(the),cos(the));\n    vec3 o=vec3(0.0,0.0,-3);\n    vec2 tc=trace(ro,rd);\n    float t=tc.x;\n    float c=tc.y;\n    vec3 color=vec3(0,0,1);\n    if(c==1.0)\n        color=vec3(1.0,1.0,0.0);\n    if(c==2.0)\n        color=vec3(1.0,0.0,0.0);\n    vec3 p=ro+rd*t;\n    vec3 l=normalize(vec3(3.0,2.0,-1.0));\n    vec3 n=normalize(grad(p));\n    float dif=abs(dot(l,n));\n    float fog=1.0/(1.0+t*t*0.1);\n    vec3 fc=color*(dif);\n    //vec3 fc=vec3(dif,dif,0.0);\n\tfragColor = vec4(fc,1.0);\n}","name":"Image","description":"","type":"image"}]}