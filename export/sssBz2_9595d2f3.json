{"ver":"0.1","info":{"id":"sssBz2","date":"1645100935","viewed":382,"name":"Layers of Poincare Disks","username":"Kamoshika","description":"I layered the Poincare disks (Hyperbolic Tessellation Disks).\nIt's done by raycasting to planes.","likes":27,"published":1,"flags":64,"usePreview":0,"tags":["raycasting","hyperbolic","poincare"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MtXSWf","filepath":"https://soundcloud.com/notakermusic/infinite","previewfilepath":"https://soundcloud.com/notakermusic/infinite","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define AA 1\n\n// If you have a strong PC, make it bigger.\n#define AA 3\n\n#define hash(x) fract(sin(x) * 43758.5453)\nconst float PI = acos(-1.);\nconst float PI2 = acos(-1.)*2.;\n\nconst float BPM = 100.;\nconst float layerInterval = 1.0;\nconst vec3 lightDir = normalize(vec3(-5, 7, 2));\n\nvec3 background = vec3(0);\n\nmat2 rotate2D(in float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c, s, -s, c);\n}\n\n// Get pattern number n1 and n2 from a layer ID.\nvoid getPatternNum(in float ID, out int n1, out int n2){\n    // N1 and n2 satisfy the following condition.\n    // (n1 - 2) * (n2 - 2) > 4\n    n1 = 3 + int(pow(hash(ID), 3.) * 10.); // range [3, 12]\n    n2 = int(4. / float(n1 - 2)) + 3 + int(pow(hash(ID * 1.1), 3.) * 10.);\n}\n\n// Prepare for Hyperbolic Tessellation.\nvoid prepare(in int n1, in int n2, out float a1, out float a2, out float radius, out vec2 center){\n    a1 = PI / float(n1); // Angle between line L1 and L2.\n    a2 = PI / float(n2); // Angle of intersection between line L1 and circle C.\n    \n    float cosa2 = cos(a2);\n    float sina1 = sin(a1);\n    float coeff = 1. / sqrt(cosa2 * cosa2 - sina1 * sina1);\n    radius = sina1 * coeff; // Radius of the circle C used for inversion.\n    center = vec2(cosa2 * coeff, 0.); // Center of the circle C used for inversion.\n}\n\n// Implement Hyperbolic Tessellation.\n// It does roughly the same thing as the shader below, but I've reassembled the formula.\n// \"Poincare Disk\" by soma_arc.\n// https://www.shadertoy.com/view/4tdSD4\nvec2 tessellate(in vec2 p, in float a1, in float a2, in float radius, in vec2 center){\n    float p2 = dot(p,p);\n    if(p2 > 1.){\n        p /= p2; // Inversion about unit circle.\n    }\n    \n    float da1 = a1 * 2.;\n    float cosda1 = cos(da1);\n    float sinda1 = sin(da1);\n    float tana1 = tan(a1);\n    float radius2 = radius * radius;\n    \n    for(int j=0; j<40; j++){\n        vec2 ctop = p - center;\n        float ctop2 = dot(ctop, ctop);\n        \n        if(p.y > tana1 * p.x){\n            p *= mat2(cosda1, sinda1, sinda1, -cosda1); // Inversion about line L1.\n        } else if(p.y < 0.){\n            p.y = -p.y; // Inversion about line L2.\n        } else if(ctop2 < radius2){\n            p = ctop * radius2 / ctop2 + center; // Inversion about circle C.\n        } else {\n            break;\n        }\n    }\n    \n    return p;\n}\n\n// HSV to RGB\nvec3 hsv(in float h, in float s, in float v){\n    vec3 res = fract(h + vec3(0, 2, 1) / 3.) * 6. - 3.;\n    res = abs(res) - 1.;\n    res = clamp(res, 0., 1.);\n    res = (res - 1.) * s + 1.;\n    res *= v;\n    \n    return res;\n}\n\n// Camera path.\nvec2 path(in float z){\n    z /= layerInterval;\n    \n    int n1;\n    int n2;\n    float a1;\n    float a2;\n    float radius;\n    vec2 center;\n    \n    float dis = 0.1;\n    \n    float ID = floor(z);\n    getPatternNum(ID, n1, n2);\n    prepare(n1, n2, a1, a2, radius, center);\n    vec2 p0 = vec2(center.x - radius + dis, 0);\n    p0 *= rotate2D(PI2 / float(n1) * floor(hash(ID*1.2) * float(n1)));\n    \n    ID += 1.;\n    getPatternNum(ID, n1, n2);\n    prepare(n1, n2, a1, a2, radius, center);\n    vec2 p1 = vec2(center.x - radius + dis, 0);\n    p1 *= rotate2D(PI2 / float(n1) * floor(hash(ID*1.2) * float(n1)));\n    \n    float f = fract(z);\n    return mix(p0, p1, f*f*f*(6.*f*f-15.*f+10.));\n}\n\n// Height used for shading.\nfloat getHeight(in vec2 p, in float radius, in vec2 center) {\n    float tmp = length(p - center) - radius;\n    return exp(-tmp * tmp * 60.);\n}\n\n// Raycasting and shading.\nvec3 render(in vec3 ro, in vec3 rd){\n    vec3 col = vec3(0);\n    \n    int n1;\n    int n2;\n    float ID;\n    float t;\n    float a1;\n    float a2;\n    float rotA;\n    float radius;\n    vec2 center;\n    vec2 pt;\n    vec3 rp;\n    \n    // Detect collision between ray and a plane cut out by a pattern.\n    // Collision detection is performed in order from front to back.\n    bool hit = false;\n    for(int i=0; i<7; i++){\n        float z = ro.z / layerInterval;\n        float flz = floor(z);\n        ID = flz - float(i);\n        t = (ID * layerInterval - ro.z) / rd.z;\n        rp = ro + t * rd;\n        \n        getPatternNum(ID, n1, n2);\n        prepare(n1, n2, a1, a2, radius, center);\n        \n        float rotEase = flz + smoothstep(0.4, 0.6, fract(z));\n        \n        rotA = 0.;\n        if(iTime > 76.0){\n            float h1 = hash(ID*1.4 + flz);\n            float h2 = hash(h1*500.);\n            rotA += fract(rotEase / float(n1)) * PI2 * sign(h1 - 0.5) * ceil(h2 * float(n1));\n        }\n        \n        pt = tessellate(rp.xy * rotate2D(rotA), a1, a2, radius, center);\n        \n        if(length(pt - center) < radius + 0.03){\n            hit = true;\n            break;\n        }\n    }\n    \n    // Perform shading.\n    if(hit){\n        float ho = getHeight(pt, radius, center);\n        \n        vec2 eps = vec2(0.001, 0);\n        pt = tessellate((rp.xy + eps.xy) * rotate2D(rotA), a1, a2, radius, center);\n        float hx = getHeight(pt, radius, center);\n        pt = tessellate((rp.xy + eps.yx) * rotate2D(rotA), a1, a2, radius, center);\n        float hy = getHeight(pt, radius, center);\n        \n        vec3 normal = normalize(vec3(-(hx - ho)/eps.x, -(hy - ho)/eps.x, 1.));\n        \n        float diff = max(dot(normal, lightDir), 0.);\n        float spec = pow(max(dot(reflect(lightDir, normal), rd), 0.), 20.);\n        float metal = 0.6;\n        float lightPwr = 8.;\n        float amb = 0.5;\n        \n        col = hsv(ID * PI * 0.5, 0.7, 1.);\n        col *= diff * (1. - metal) * lightPwr + spec * metal * lightPwr + amb;\n    }\n    \n    float tmp = t / layerInterval;\n    col = mix(background, col, exp(-tmp * tmp * 0.2));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec3 col = vec3(0);\n    \n    if(iTime > 57.5){\n        background += pow(sin(iTime * BPM / 60. * PI) * 0.5 + 0.5, 20.);\n    }\n    \n    // Refference: \"Hexagonal Grid Traversal - 3D\" by iq\n    // https://www.shadertoy.com/view/WtSfWK\n    for(int m=0; m<AA; m++){\n        for(int n=0; n<AA; n++){\n            vec2 of = vec2(m, n) / float(AA) - 0.5;\n            vec2 uv = ((fragCoord + of) * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n            \n            float time = iTime;\n            float T = smoothstep(0., 10., iTime);\n            float h;\n            \n            // Motion Blur.\n            #if AA > 1\n            h = hash(dot(fragCoord, vec2(8.2365 + float(m), 9.2742 + float(n))) * 1.3783 + iTime);\n            time += h * mix(0.5, 0.02, T);\n            #endif\n            \n            vec3 ro = vec3(0, 0, -time * layerInterval * BPM / 60. * 0.5);\n            \n            float T2 = smoothstep(38., 39.5, iTime);\n            ro.xy = mix(vec2(0), path(ro.z), T2);\n            vec3 ta = vec3(path(ro.z - layerInterval * 0.1), ro.z - layerInterval * 0.5);\n            vec3 dir = mix(vec3(0, 0, -1), normalize(ta - ro), T2);\n            \n            vec3 side = normalize(cross(dir, vec3(vec2(0, 1) * rotate2D(ro.y * 2.0 + ro.z * 0.1), 0)));\n            vec3 up = normalize(cross(side, dir));\n            vec3 rd = normalize(uv.x * side + uv.y * up + dir * (2.125 - length(uv) * 0.25));\n            \n            // DOF.\n            #if AA > 1\n            vec3 fp = ro + rd * 1.0;\n            h = hash(dot(fragCoord, vec2(3.23481 + float(m), 5.57264 + float(n))) * 1.2253 + iTime);\n            ro.xy += (vec2(h, hash(h*500.)) - 0.5) * mix(0.5, 0.02, T);\n            rd = normalize(fp - ro);\n            #endif\n            \n            col += render(ro, rd);\n        }\n    }\n    col /= float(AA*AA);\n    \n    // Tone mapping.\n    //float l=3.;\n    //col = col / (1.+col) * (1.+col/l/l);\n    \n    // Gamma.\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    // Vignetting.\n    vec2 p = fragCoord/iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * p.x * p.y * (1.0 - p.x) * (1.0 - p.y), 0.5);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}