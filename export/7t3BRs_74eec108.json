{"ver":"0.1","info":{"id":"7t3BRs","date":"1663520159","viewed":279,"name":"Menger Corridor","username":"Poisson","description":"A menger sponge corridor.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","fractal","tunnel","ray","raymarcher","menger","metal","mb","corridor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2 // antialiasing\n#define PI 3.141592\n#define TAU 6.283185\n#define MAX_DIST 8.\n#define FRACTAL_ITER 4 // menger fractal detail\n#define LOOK 1 // fractal look\n\nconst vec3 LIGHT_1_COLOR = vec3(1,.5,.3);\nconst vec3 LIGHT_2_COLOR = vec3(.3,.5,1);\n\n//const vec3 LIGHT_1_COLOR = vec3(.3,1,.5);\n//const vec3 LIGHT_2_COLOR = vec3(.5,.3,1);\n\nfloat time;\nvec3 l1,l2;\n\n// get the ray direction\nvec3 getRayDir(vec2 uv, vec3 c, vec3 t, float z) {\n    vec3 f = normalize(t - c);\n    vec3 s = normalize(cross(vec3(0,1,0), f));\n    vec3 u = cross(f, s);\n    return normalize(f*z + uv.x*s + uv.y*u);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// path of the camera\nvec2 path(float z){\n    return vec2(sin(z*.5),0); \n}\n\n// corridor\nfloat map(vec3 p) {\n    p.xy -= path(p.z);\n    float d = -1e10;\n    \n    float s = 1.;\n    for (int m=0; m<FRACTAL_ITER; m++) {\n        vec3 a = mod(p*s, 2.) - 1.;\n        s *= 3.;\n        vec3 r = 1. - 3.*abs(a);\n        #if LOOK == 1\n        r.yz *= rot(.25*PI);\n        #endif\n        r = abs(r);\n        \n        float da = max(r.x,r.y);\n        float db = max(r.y,r.z);\n        float dc = max(r.z,r.x);\n    \n        float c = min(da,min(db,dc)) - 1.;\n        \n        d = max(d, c/s);\n    }\n    \n    return d;\n}\n\n// raymarching loop\nfloat intersect(vec3 ro, vec3 rd) {\n    float t = 0.;\n    \n    for (int i = 0; i < 512; i++) {\n        vec3 p = ro + rd * t;\n        float h = map(p);\n        t += h;\n        if (h < .0001 || t > MAX_DIST) break;\n    }\n    \n    return t;\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(.0001,0);\n    float h = map(p);\n    \n    return normalize(h- vec3(map(p - e.xyy),\n                             map(p - e.yxy),\n                             map(p - e.yyx)));\n}\n\n// occlusion function by iq\nfloat calcAO(vec3 p, vec3 n) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    \n    for(int i=0; i<4; i++) {\n        float h = .01 + .12*float(i)/4.;\n        float d = map(p + h * n);\n        occ += (h-d)*sca;\n        sca *= .95;\n        if( occ>.35 ) break;\n    }\n    \n    return clamp(1. - 3.*occ, 0., 1.);\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(0);\n    float t = intersect(ro, rd);\n\n    if (t < MAX_DIST) {\n        \n        // color and lighting\n        \n        vec3 p = ro + rd * t;\n        vec3 n = calcNormal(p);\n        \n        vec3 mat = vec3(.9,.85,1);\n        \n        // apply texture\n        \n        vec3 xy = texture(iChannel1, p.xy*4.).rgb;\n        vec3 xz = texture(iChannel1, p.xz*4.).rgb;\n        vec3 yz = texture(iChannel1, p.yz*4.).rgb;\n        vec3 m = abs(n);\n        vec3 tex = yz*m.x + xz*m.y + xy*m.z;\n        tex *= tex;\n        \n        // lighting\n        \n        vec3 lig = normalize(l1 - p);\n        vec3 lig2 = normalize(l2 - p);\n        float dif = clamp(dot(n, lig),0.,1.);\n        float dif2 = clamp(dot(n, lig2),0.,1.);\n        float occ = calcAO(p, n); // ambient occlusion\n        float focc = smoothstep(sign(p.y),0.,p.y); // darkening the top and the bottom\n        occ *= .4+.6*focc;\n        \n        col = vec3(0);\n        col += .2*mat*tex*occ; // base layer\n        col += 3.*tex*LIGHT_1_COLOR*pow(dif,8.)*occ*occ; // first light\n        col += 2.*tex*LIGHT_2_COLOR*pow(dif2,6.)*occ*occ; // second light\n        \n        col += 1.5*tex*LIGHT_1_COLOR*pow(dif,16.)*occ*occ; // first light\n        col += tex*LIGHT_2_COLOR*pow(dif2,12.)*occ*occ; // second light\n                      \n        // fog\n                       \n        float fog = 1.-exp(-.05*t*t*t);\n        col = mix(col, vec3(0), fog);\n    }\n    \n    return col;\n}\n\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.43;\n    float d =  .59;\n    float e =  .14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    vec3 tot = vec3(0);\n    for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n        vec2 o = vec2(i, j) / float(AA) - .5;\n        vec2 uv = (fragCoord+o - .5*iResolution.xy) / iResolution.y;\n        \n        // motion blur\n        \n        float mb = float(i*AA+j) + texelFetch(iChannel0, ivec2(fragCoord)&1023, 0).x;\n        time = iTime+3.*m.x - .02*mb/float(AA*AA);\n        \n        // setup camera and lights\n        \n        vec3 ro = vec3(0,0,1.5*time);\n        vec3 ta = ro + vec3(0,0,.1);\n        \n        l1 = ro + vec3(0,0,.4);\n        l2 = ro + vec3(0,0,.9);\n        \n        ro.xy += path(ro.z);\n        ta.xy += path(ta.z);\n        l1.xy += path(l1.z);\n        l2.xy += path(l2.z);\n        \n        vec3 rd = getRayDir(uv, ro, ta, .8);\n        rd.xy *= rot(path(ta.z).x*.25); // turning the camera at corridor corners\n        \n        // render\n        \n        vec3 col = render(ro, rd);\n        \n        tot += col;\n    }\n    }\n    tot /= float(AA*AA);\n    \n    \n    tot = pow(tot, vec3(.4545)); // gamma correction\n    // constrast\n    float f0 = .4;\n    tot = tot*(1.+f0)-.5*f0;\n    // vignetting\n    vec2 p = fragCoord / iResolution.xy;\n    tot *= clamp(pow(80. * p.x*p.y*(1.-p.x)*(1.-p.y), .1), 0., 1.);\n                                                    \n    // output\n    fragColor = vec4(tot,1.0);\n}","name":"Image","description":"","type":"image"}]}