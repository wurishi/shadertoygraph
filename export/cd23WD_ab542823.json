{"ver":"0.1","info":{"id":"cd23WD","date":"1667614715","viewed":375,"name":"[Inércia 2022] Train Station","username":"Xor","description":"Results from my first shader royale!","likes":34,"published":1,"flags":32,"usePreview":0,"tags":["livecode","shaderroyale"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"[Inércia 2022] Train Station\" by @XorDev\n    \n    This my first attempt at shader royale (Inércia Shader Royale 2022).\n    I got 7th out of 27, which I'm happy with.\n    The pressure to create in such a time frame is quite difficult.\n    I'd like to do more planning next time, but it was fun!\n    \n    Not my prettiest code.... You've been warned\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGRr","filepath":"/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","previewfilepath":"/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define time (iTime+1e2)\n\n//Can't exactly recreate the FFT of Bonzmatic\nfloat FFT(float f)\n{\n    f = fract(f-.1*cos(f*f*5e2));\n    return (texture(iChannel0,vec2(f,1)).r-0.5)/16.;\n}\nvec3 path(float z)\n{\n    return vec3(cos(z/vec2(13,15))*vec2(4,1)-vec2(0,1)*((tanh(mod(z-2e1,4e1)-2e1)*.2)+1.)+FFT(0.0)/.01,0);\n}\nfloat dist(vec3 p)\n{\n    p += path(p.z);\n    float m = 1e3;\n    m = min(m,min(p.y+6.+cos(ceil(p.x)*(2.+cos(ceil(p.z/ceil(8.+7.*cos(ceil(p.x)))+ceil(p.x))))),max(10.-abs(p.x),5.-p.y)));\n    m = min(m,max(abs(length(p.xy)-(10.+FFT(0.0)/.1+.4*sign(cos(atan(p.y,p.x)/.1+p.z)))/\n    (2.+cos(ceil(p.z/4e1))))-1.,abs(mod(p.z,4e1)-2e1)-6.-5.*cos(pow(ceil(p.z/4e1),2.))));\n    vec3 a = abs(mod(p+vec3(0,0,0),2e1)-10.);\n    m = min(m,length(min(a,a.yzx))-1.);\n    vec3 M = mod(p+vec3(cos(pow(ceil(p.y+9.),2.))*FFT(0.5)*5e2,20,cos(ceil(p.x/4e1))*time*3e1),4e1)-2e1;\n    M.z -= clamp(M.z,-4.,4.);\n    m = min(m,length(max(abs(M)-4.,-.5))-1.);\n    return m+FFT(p.z/1e2)/.1;\n}\nvec3 nor(vec3 p)\n{\n    vec2 e = vec2(.1,-.1);\n    return normalize(dist(p+e.yxx)*e.xyy+dist(p+e.xyx)*e.xxy+dist(p+e.xxy)*e.xxy+dist(p+e.y)*e.y);\n  \n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n    vec2 puv = uv;\n    uv -= 0.5;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    uv *= mat2(cos(cos(time*.1)*.2+vec4(0,11,33,0)));\n    \n    #define cube(x) (x)*(x)*(x)\n    uv.x += cos(cube(floor(uv.y/.1)))*(FFT(uv.x-.5));\n    uv.y += cos(cube(floor(uv.x/.1)))*FFT(uv.y-.5);\n    //uv = fract(uv-.5)-.5;\n\n    vec3 d = normalize(vec3(uv,1));\n\n    d.zx *= mat2(cos(tanh(sin(time*.3)/.1-8.)*.75+.75+vec4(0,11,33,0)));\n    vec3 p = vec3(0,0,time/.1);\n    vec3 cam = path(p.z);\n    p -= cam;\n\n    int i = 0;\n    for(;i<99;i++)\n    {\n      float s = dist(p);\n\n       p += d*s;\n    if (s<0.01) break;\n    }\n    vec3 n = nor(p);\n    vec3 r = reflect(d,n);\n    vec3 l = normalize(vec3(1,2,cos(time)));\n    float d_l = dot(n,l);\n    float lig = max(d_l,d_l*.1+.1);\n    //lig *= clamp(dist(p+n*.1)/.1,0.,1.);\n    vec3 c = max(cos(pow(ceil((p+cam).z),3.)+vec3(0,2,4)),0.)*lig/float(i)*1e1+max(dot(r,l)*9.-8.,0.);\n    c.yz /= 1.+.02*(p-vec3(0,0,time/.1)).yz;\n    c[int(time)%3] = texture(iChannel1,puv)[int(time+1.4+.5*cos(time*.3))%3];\n\n\n    fragColor = vec4(c,1);\n}","name":"Buffer A","description":"","type":"buffer"}]}