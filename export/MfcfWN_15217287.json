{"ver":"0.1","info":{"id":"MfcfWN","date":"1733106971","viewed":112,"name":"effects in digital twins1","username":"letbonsaibe","description":"some effects can be used in  digital twins scene,  all fork or deep inspired by shader below. I leave some code comment or implement in easy-understanding way. ","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["fui","digitaltwins"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S (1. + sin(iTime) / 4.)\n#define C (1. + cos(iTime) / 4.)\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define SMOOTH2(r,R) (1.0-smoothstep(R-0.01, R+0.01, r))\n#define SS(r,R) (smoothstep(r-0.005, r+0.005, R))\n#define ROT(p, a) (mat2(cos(a),-sin(a),sin(a),cos(a))*p)\n\n\n// fork1: https://www.shadertoy.com/view/fdK3DD\n// fork2: https://www.shadertoy.com/view/4dVXWy\n// fork3: https://www.shadertoy.com/view/MlyGzW\n\nconst float PI = 3.14159;\nconst float TAU = PI * 2.;\nconst float QTR_PI = PI / 4.;\n\n\n\nfloat stroke(float x, float s, float w) { \n    float d = SS(s, x + w / 2.) - SS(s, x - w / 2.);\n    return clamp(d, 0., 1.);\n}\n\nfloat fill(float x, float size) { \n    return 1. - SS(size, x);\n}\n\n\nfloat sdCircle(vec2 st) { \n    return length(st - 0.5) * 2.;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3(p3.x+p3.y, p3.x+p3.z, p3.y+p3.z)*p3.zyx);\n}\nfloat snoise3(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - K2);\n    vec3 d2 = d0 - (i2 - K1);\n    vec3 d3 = d0 - 0.5;\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    //-----------\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nfloat light0(float intensity, float attenuation, float dist) {\n    return intensity / (dist * attenuation);\n}\n\nfloat light1(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * attenuation);\n}\nfloat light2(float intensity, float attenuation, float dist)\n{\n    return intensity / (1.0 + dist * dist * attenuation);\n}\n\nfloat circle2(float d, float radius, float vignette) {\n    return smoothstep(radius * vignette, radius, d);\n}\n\nfloat circle3(float d, float radius) {\n    return .1 - smoothstep(radius, radius + 0.01, d);\n}\n\n\nvec3 draw(vec2 st, vec2 tileXY, vec2 count) {\n\n\n    int cardNumber = int(tileXY.x + (-tileXY.y + count.y - 1.) * count.x);\n    vec3 retCol = vec3(0.);\n    float color = 0.0;\n    \n    switch(cardNumber) {\n    \n    case 5: {\n        st = st * 2.0 - 1.0;\n        float d = length(st);\n        float r = 0.1 + mod(iTime * 0.1, 0.4);\n         color = smoothstep(max(0.09,r-0.11),r,d)-\n           SMOOTH2(r,d);\n        retCol = vec3(color);\n         break;\n    }\n   case 4: {\n        st = st * 2.0 - 1.0;\n        float radius = 0.5;\n        float theta = fract(iTime * .25) * 2. * PI;\n        float r = length(st);\n        float d = sdSegment(st, vec2(0.), vec2(cos(theta), sin(-theta)));\n        float angle = mod(atan(st.y, st.x)+theta, 2. * PI);\n        float range = 0.5 * PI;\n        float intensity = clamp (range -  angle, 0.0, range) / range;\n        color = SMOOTH(d*200., 1.) + 0.8*intensity;\n        color = r < radius ?  color  : 0.0;\n                retCol = vec3(color);\n        retCol = vec3(color);\n\n         break;\n    }\n    case 2: {\n        st = st * 2.0 - 1.0;\n        float d = length(st) - 0.5;\n        float angle = atan(st.y, st.x);\n        float fallOff = fract(-0.5*(angle/PI)-iTime*0.5);\n        float width = 0.01 * fallOff;\n        color = smoothstep(0.005, 0.0, abs(d) - width);\n                retCol = vec3(color);\n\n        break;\n    }\n    case 0: {\n        st = st * 2.0 - 1.0;\n        st.x = mod(st.x - iTime, 1.0);\n        float d = sdUnevenCapsule(st, vec2(0., 0.),  vec2(0.5, 0.), 0.005, 0.04);\n        color =  smoothstep(0.005, 0.0, d);\n                retCol = vec3(color);\n\n        break;\n    }\n    case 1: {\n        st = st * 2.0 - 1.0;\n        \n        vec2 wh = vec2(0.6, 0.4);\n        float d = sdBox(st, wh);\n        color =  smoothstep(0.01, 0.0, abs(d));\n        float aspect = wh.y / wh.x;\n        float dir = (abs(st.x) * aspect > abs(st.y)) ?\n        -sign(st.x) : sign(st.y);\n        float dashed = 0.1;\n        float dash = step(dashed/2.0, mod(dir*(st.x + st.y) + iTime * 0.2 , dashed));\n        color *= dash;\n                retCol = vec3(color);\n\n        break;\n    }\n    case 3: {\n        st = st * 2.0 - 1.0;\n        st = ROT(st, S);\n        float dist = length(st);\n        float radius = 0.5; \n        float gapCount = 8.0;\n        float gapAngle = 4.0;\n        float width = 0.02;\n        float r = dist;\n    \n        float theta = 180.0*(atan(st.y,st.x)/PI);\n        float baseAngle = 180. / gapCount;\n        float outerCircle = SMOOTH2(dist-width/2.0,radius);\n        float innerCircle = SMOOTH2(dist+width/2.0,radius);\n        float gap = smoothstep(gapAngle, gapAngle+0.1, abs(mod(theta+gapAngle, baseAngle)-gapAngle));\n        float intensity =  mix( 0.2, 1.0, step(0., mod(theta, 90.0)-45.0) ) ;\n\n        color =  gap *  intensity * (outerCircle - innerCircle);\n                retCol = vec3(color);\n\n        break;\n    }\n    case 6: {\n        // https://www.shadertoy.com/view/MlyGzW\n        st = st * 2.0 - 1.0;\n        vec2 center = vec2(0.0);\n        vec2 offset = vec2(cos(iTime / 2.0) * 0.5, sin(iTime/ 2.0)* 0.5);\n        vec3 lightColor = vec3(sin(iTime), 0.84, cos(iTime));\n        float radius = 0.5;\n        float dist1 = distance(st, center)-radius;\n        float dist2 = distance(st, offset)-radius;\n        float intensity =  light0(0.03, 1., dist1);\n        if (dist1 < 0.) {\n            intensity *= 0.03/ abs(dist2);\n        }\n        retCol = lightColor * intensity;        \n    \n        break;\n        \n    }\n    case 7: {\n        // https://www.shadertoy.com/view/3tBGRm\n        st = st * 2.0 - 1.0;\n\n// const vec3 color1 = vec3(0.611765, 0.262745, 0.996078);\n// const vec3 color2 = vec3(0.298039, 0.760784, 0.913725);\n// const float innerRadius = 0.6;\n// const float noiseScale = 0.9;\n// const vec3 color3 = vec3(0.062745, 0.078431, 0.600000);\n\nconst vec3 color1 = vec3(1.0, 0.262745, 0.996078);\nconst vec3 color2 = vec3(1., 0.827, 0.);\nconst vec3 color3 = vec3(0.2, 0.2, 0.2);\nconst float innerRadius = 0.5;\nconst float noiseScale = 0.65;\n\n\n\n        float angle = atan(st.y, st.x);\n        float len = length(st);\n\n        float n0 = snoise3( vec3(st * noiseScale, iTime * 0.5) ) * 0.5 + 0.5;\n        float r = mix(innerRadius-0.05, innerRadius+0.05, n0);\n        float dist = abs(len - r);\n        float baseLight = light1(1.0, 10.0, dist);\n\n        // high light\n        float a = iTime * -1.0;\n        vec2 pos = vec2(cos(a), sin(a)) * r; // 边缘点\n        dist = distance(st, pos);\n        float highLight = light2(1.5, 5.0, dist);\n        highLight *= light1(1.0, 10.0, dist);\n\n        // outer\n        float decay = smoothstep(r * 1.05, r, len);\n        // inner\n        float hole = smoothstep(innerRadius*0.5, innerRadius, len);\n\n        float cl = cos(angle + iTime * 2.0) * 0.5 + 0.5;\n        vec3 col = mix(color1, color2, cl);\n        col = mix(color3, col, baseLight);\n        retCol  = (col  + highLight)  * hole * decay;\n        break;   \n    }\n\n    case 8: {\n        st = st * 2.0 - 1.0;\n        float radius = 0.48;\n        float radius2 = sin(iTime * 5.) / 50. + 0.78;\n        float radius3 = fract(iTime / 2.4);\n        vec3 color = vec3(1.0, 0.0 ,0.0);\n        float len = length(st);\n        float v;\n\n        // basic  outter line\n        v += circle2(len, radius + 0.02, 0.8);\n        // breath outter line\n        v += circle2(len, radius2, 0.5);\n        // core and limit outter line\n        v += circle3(len, .13) ;\n        // limit outter line\n        v += circle3(len, radius)*3.;\n\n        // pulsar\n        v += circle2(len, radius3, 0.5);\n        v += circle3(len, radius3);\n \n\n        //v += circle3(len, radius)*3.;\n\n\n\n\n\n        retCol = v  * color;\n\n\n        break;\n     }\n    \n    \n   \n    \n    } // switch end\n    return retCol;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float coordAspectRatio = iResolution.y / iResolution.x;\n    \n    vec2 count = vec2(3, 3);\n    float tileW = iResolution.x / count.x;\n    float tileH = iResolution.y / count.y;\n    float tileAspectRatio = tileH / tileW;\n    vec2 tileXY = floor(uv * count);\n    // coordinates for each tile\n    vec2 st = vec2(\n        uv.x * count.x - tileXY.x, \n        (uv.y * count.y - tileXY.y - 0.5) * tileAspectRatio + .5\n    );\n    vec2 gridBars = clamp(cos(uv * TAU * count) * 10. - 9.9, 0., 1.); // ---^---^---\n    float grid = max(gridBars.x, gridBars.y)*2.0;\n    \n    \n    vec3 color = draw(st, tileXY, count);\n    color += vec3(grid);\n\n    \n     if (iMouse.z > 0.01) {\n        tileXY = floor(iMouse.xy / iResolution.xy * count);\n        st.x = (uv.x - .5) / coordAspectRatio + .5;\n        st.y = uv.y;\n        \n        color *= 0.15;\n        color += clamp(draw(st, tileXY, count), 0., .85);\n    }\n    \n    \n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}