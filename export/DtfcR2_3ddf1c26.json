{"ver":"0.1","info":{"id":"DtfcR2","date":"1690929077","viewed":53,"name":"Protoglyphs","username":"thedarkbunny","description":"Playing with biarcs and glyph generation.","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["glyphs","biarcs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nArc distance code adapted from Inigo Quilez: https://www.shadertoy.com/view/wl23RK\nBiarc midpoint functions from Ryan Juckett: https://www.ryanjuckett.com/biarc-interpolation/\n\n*/\n\n\n#define TAU 6.2831853\n\n#define P0 vec2(0.0,0.0)\n#define P1 vec2(0.0,1.0)\n#define P2 vec2(0.9510565,0.309017)\n#define P3 vec2(0.5877853,-0.809017)\n#define P4 vec2(-0.5877853,-0.809017)\n#define P5 vec2(-0.9510565,0.309017)\n\n#define T1 -perp(P1)\n#define T2 -perp(P2)\n#define T3 -perp(P3)\n#define T4 -perp(P4)\n#define T5 -perp(P5)\n\n\n\n\n//convenience function - perpendicular vector.\nvec2 perp(vec2 t1){\n    return t1.yx*vec2(-1.,1.);\n}\n\nfloat sd_arc(in vec2 p, in vec2 p1, in vec2 p2, in vec2 t1){\n    vec2 p_mid = (p1+p2)*.5;\n    vec2 n_mid = perp(p2-p1);\n    float n_ext = dot(p1-p_mid,t1) / dot(n_mid,t1);\n    vec2 ctr = p_mid + n_ext*n_mid;\n    \n    vec2 rot = normalize(p_mid-ctr);\n    mat2 rm = mat2(rot.y,-rot.x,rot.x,rot.y);\n    \n    //There's probably a way to do this with fewer square roots,\n    //but I don't know what it is.\n    float r = distance(ctr,p1);\n    \n    vec2 sc = vec2(distance(p1,p_mid),distance(ctr,p_mid))/r;\n    \n    \n    float longarc = sign(dot(p_mid-p1,t1));\n    \n    if (longarc < 0.){\n        sc.y *= -1.;\n        rm *= -1.;\n    }\n\n    p = (p-ctr)*rm;\n    \n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*r) : abs(length(p)-r));\n\n}\n\n\n//'dumb' distance, requires manual midpoint spec.\nfloat sd_biarc(in vec2 p, in vec2 p1, in vec2 p2, in vec2 t1, in vec2 t2, in vec2 pm){\n    float a1 = sd_arc(p, p1, pm, t1);\n    //negative, because we're going backwards.\n    float a2 = sd_arc(p, p2, pm, -t2);\n    return min(a1,a2);\n}\n\n\n\n//computes biarc midpoint with automatic distance.\n//Tangents MUST be normalized.\nvec2 biarc_pm_auto(in vec2 p1, in vec2 p2, in vec2 t1, in vec2 t2){\n    \n    //precomputed for convenience\n    vec2 v = p2-p1;\n    vec2 t = t1+t2;\n\n    //might as well allocate this early.\n    float d;\n    \n    //Check for equal tangents.\n    if(dot(t1,t2) > 0.999){\n        //now check for perpendicular vector:\n        if(abs(dot(t,v)) < 0.001){\n            //d is infinity, override final results.\n            return (p1+p2)*0.5;\n        }else{\n            d = dot(v,v) / dot(v,t) * 0.5;\n            return (p1+p2+d*(t1-t2))*0.5;\n        }\n    }else{\n        float vt = dot(v,t);\n        float ntt = 1.-dot(t1,t2);\n        d = (sqrt( vt*vt+2.*ntt*dot(v,v) ) - vt) / ntt * 0.5;\n        return (p1+p2+d*(t1-t2))*0.5;\n    }\n    \n\n}\n\nfloat biarc_all(in vec2 p, in vec2 p1, in vec2 p2, in vec2 t1, in vec2 t2){\n    vec2 pm = biarc_pm_auto(p1,p2,t1,t2);\n    return sd_biarc(p,p1,p2,t1,t2,pm);\n}\n\n//moving arc generation to its own function, per FabriceNeyret2's comment\nfloat fv(in vec2 uv, in int id){\n    switch(id){\n    case  0: return min(biarc_all(uv,P1,P2,T1,T2),biarc_all(uv,P1,P5,-T1,-T5));\n    case  1: return min(biarc_all(uv,P2,P3,T2,T3),biarc_all(uv,P4,P5,T4,T5));\n    case  2: return biarc_all(uv,P3,P4,T3,T4);\n    case  3: return min(biarc_all(uv,P1,P2,-P3,-P5),biarc_all(uv,P1,P5,P4,P2));\n    case  4: return min(biarc_all(uv,P2,P3,-P4,-P1),biarc_all(uv,P4,P5,-P1,-P3));\n    case  5: return biarc_all(uv,P3,P4,-P5,-P2);\n    case  6: return min(biarc_all(uv,P1,P3,P3,-P1),biarc_all(uv,P1,P4,P4,-P1));\n    case  7: return min(biarc_all(uv,P2,P4,P4,-P2),biarc_all(uv,P3,P5,P5,-P3));\n    case  8: return biarc_all(uv,P2,P5,P5,-P2);\n    case  9: return min(biarc_all(uv,P1,P3,-P1,P3),biarc_all(uv,P1,P4,-P1,P4));\n    case 10: return min(biarc_all(uv,P2,P4,-P2,P4),biarc_all(uv,P3,P5,-P3,P5));\n    case 11: return biarc_all(uv,P2,P5,-P2,P5);\n    \n    }\n}\n\nvec3 glyph(in vec2 uv, in int gid){\n    uv = uv * 1.3;\n    \n    gid = gid % 144;\n        \n    float vdist = fv(uv,gid/12);\n    vdist = min(vdist,fv(uv,gid%12));\n    \n    vec3 inner = (1.-vdist*5.)*vec3(1.,0.5,0.);\n    \n    float o_v = clamp(1.-vdist*3.,0.,1.);\n    \n    vec3 outer = vec3(o_v*o_v*o_v,o_v*o_v,o_v);\n    \n    return mix(inner,outer,clamp(vdist-0.09,0.,0.02)*50.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = (fragCoord-iResolution.xy*0.5)/max(iResolution.x,iResolution.y)*2.;\n    \n    vec2 vv = (uv+vec2(0.,-iTime*0.1))*5.;\n    \n    vec2 fv = fract(vv);\n    vec2 iv = vv-fv+79.;\n    \n    int gid = ( (int(iv.y)*35)%289+int(iv.x)*103)%144;\n    \n    vec3 col = glyph(fv*2.-1.,gid);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}