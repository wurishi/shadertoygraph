{"ver":"0.1","info":{"id":"DdV3Dz","date":"1680794974","viewed":97,"name":"reflexesRefractionsLightShadows","username":"JaumeAvinyo","description":"-3D rayIntersections to draw soheres and planes even if they intersect between them\n- Local illumination (ambient, diffuse, specular)\n-Hard shadows\n-Reflections\n-refractions\n-Distance fog\n-plane pattern","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sphereslightreflexesrefractionsshadows"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 originVar = vec3(0.,1.,-1.);\nvec3 lightOrigin = vec3(-3.,5.,0.);\n\nvec3 fogColor = vec3(1.0,0.8,0.8);\nfloat fogMinDistance = 10.;\nfloat fogMaxDistance = 70.;\n\n\nfloat airRefractiveIndex = 1.0003;\n\nstruct HIT{\n    vec3 rayDir;\n    vec3 pos;\n    vec3 normal;\n    float t; //distance to hit\n    \n    vec3 intersectedObjectColor;\n    \n   \n    float reflectionFactor;//0-1 0 = total reflection 1 means no reflection\n    \n    \n    int refracterID;\n    bool refracter;\n    float refractFactor;\n    \n    bool toRefract; //if true, drawshapes returns the second most near intersection (avoid intersecting with itself when refracting)\n    \n};\n\nstruct plane{\n\n    //inputs\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    float brightness;\n    bool drawSquares;\n    float reflectionFactor;\n    \n    //output\n    float distanceFromOrigin;\n    \n};\n\nstruct sphere{\n    \n    //inputs\n    vec3 pos;\n    float radius;\n    float brightness;\n    vec3 color;\n    float reflectionFactor;\n    \n    //output\n    float distanceFromOrigin;\n    \n    bool refracter;\n    \n    float refractFactor;\n \n};\n\nvec3 cameraPosition(float zoom, vec2 rotation){\n    float x = sin(rotation.x) * cos(rotation.y) * zoom;\n    float y = sin(rotation.y) * zoom;\n    float z = cos(rotation.x) * cos(rotation.y) * zoom;\n    return vec3(x, y, z);\n}\n\n\nvec3 reflectRay(vec3 Incident, vec3 Normal) {\n    return Incident - 2.0 * dot(Incident, Normal) * Normal;\n}\n\n\nvec3 refractRay(vec3 incidetRayDir, vec3 surfNormal, float objRefractFactor){\n   vec3 refractedRay;\n   //airRefracterFactor*sin(angle between rayDir and normal) = objectRefractFactor*sin(angle between modifiedRayDir and normal)\n   \n    float cosi = dot(incidetRayDir, surfNormal);\n    float etai = airRefractiveIndex, etat = objRefractFactor;\n    vec3 n = surfNormal;\n    \n    if (cosi < 0.0)\n    {\n        cosi = -cosi;\n    }\n    else\n    {\n        float temp = etai;\n        etai = etat;\n        etat = temp;\n        n = -surfNormal;\n    }\n    \n    float eta = etai / etat;\n    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);\n    vec3 refracted;\n    \n    if (k < 0.0)\n    {\n        refractedRay = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        refractedRay = eta * incidetRayDir + (eta * cosi - sqrt(k)) * n;\n    }\n    \n    normalize(refractedRay);\n    \n    return refractedRay;\n   \n   \n}\n\n\nbool is_inside_square(vec2 point, float square_width) {\n  vec2 mod_point = mod(point, square_width * 2.0);\n  return (mod_point.x < square_width) != (mod_point.y < square_width);\n}\n\n\nbool castRayToPlane(in vec3 origin, in vec3 rayDir, in plane _plane, out float distanceToHit){\n    bool ret = false;\n    \n    vec3 p0 = vec3(1.,_plane.pos.y,1);\n    distanceToHit = (dot((p0-origin),_plane.normal))/dot(rayDir,_plane.normal);\n                  \n    if(distanceToHit > 0.){\n        ret = true;\n    }\n      \n    return ret;\n}\n\n\nbool castRayToSphere(in vec3 origin, in vec3 rayDir,in sphere _sphere,out float distanceToHit){\n   \n    \n    \n    // Calculate the vector from the ray origin to the center of the sphere\n    vec3 toSphere = _sphere.pos - origin;\n    \n    // Calculate the length of the projection of toSphere onto the ray direction\n    float projLength = dot(toSphere, rayDir);\n    \n    // If the projection length is negative, the sphere is behind the ray and there is no intersection\n    if (projLength < 0.0) {\n        return false;\n    }\n    \n    // Calculate the length of the perpendicular distance from the ray to the sphere\n    float dist = length(toSphere - projLength * rayDir);\n    \n    // If the distance is greater than the radius, there is no intersection\n    if (dist > _sphere.radius) {\n        return false;\n    }\n    \n    float t = sqrt(_sphere.radius * _sphere.radius - dist * dist);\n    distanceToHit = projLength - t;\n    \n    // Otherwise, the ray intersects with the sphere in the direction of the ray\n    return true;\n    \n    \n}\n\n\nvec3 drawSquaresOnPlane(plane _plane, HIT hit,float squareWidth){\n    vec3 color;\n   \n    vec2 hitPoint = vec2(hit.pos.x,hit.pos.z);\n    if(is_inside_square(hitPoint, squareWidth)){\n        color = _plane.color*0.1; // return color\n    }else{\n        color = _plane.color; // return color\n    }\n               \n    return color;\n}\n\n\nvec3 drawShapes(in plane planes[1],in sphere spheres[3],in vec3 origin, in vec3 rayDir,out HIT hit){\n    vec3 color = vec3(0.7,0.0,0.);       \n    \n    float squareWidth = 1.0;\n    int hits = 0;\n    \n     \n    int nearestPlane = -1;\n    int nearestSphere = -1;\n    \n    int refractorObj = 2;\n    \n    for(int i = 0;i<planes.length();i++){//cast ray and check if collides with any plane\n    float distanceToHit;\n        if(castRayToPlane(origin,rayDir, planes[i],distanceToHit) == true){//if ray collides with a plane\n            hits++;\n            planes[i].distanceFromOrigin = distanceToHit;\n      \n            if(nearestPlane == -1){\n                nearestPlane = i;\n            }else if(nearestPlane != -1){\n                if(planes[nearestPlane].distanceFromOrigin > planes[i].distanceFromOrigin){\n                   \n                    nearestPlane = i;\n                }\n            }\n            hit.t = distanceToHit;\n            hit.reflectionFactor = planes[i].reflectionFactor;\n            hit.intersectedObjectColor = planes[i].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*planes[i].distanceFromOrigin);\n            hit.normal = planes[i].normal;\n            \n            //draw squares if needed\n            \n            if(planes[nearestPlane].drawSquares == true){\n                     color = drawSquaresOnPlane(planes[nearestPlane],hit,squareWidth);\n            }else{\n                color = planes[i].color;\n            }          \n        }\n    }\n       \n    for(int i = 0;i<spheres.length();i++){//cast ray and check if collides with any sphere\n    float distanceToHit;\n        if(castRayToSphere(origin,rayDir, spheres[i],distanceToHit) == true){//if ray collides with a sphere\n            hits++;\n            spheres[i].distanceFromOrigin = distanceToHit;\n            \n            if(nearestSphere == -1){\n                nearestSphere = i;\n            }else if(nearestSphere != -1){\n                if(spheres[nearestSphere].distanceFromOrigin > spheres[i].distanceFromOrigin){\n                    \n                    nearestSphere = i;\n                }\n            }\n            hit.t = distanceToHit;\n            hit.reflectionFactor = spheres[i].reflectionFactor;\n            hit.intersectedObjectColor = spheres[i].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*spheres[i].distanceFromOrigin);\n            hit.normal = hit.pos-spheres[i].pos;\n            \n            if(spheres[i].refracter == true){\n                hit.refracter = true;\n                \n                hit.refractFactor = spheres[i].refractFactor;\n            }else{\n                hit.refracter = false;\n            }\n            \n            color = spheres[i].color; // return color\n        }\n    }\n    \n    //check other hits and distances\n    if(hits > 1){\n        if(nearestPlane != -1 && nearestSphere != -1){//intersection sphere and plane\n            if(planes[nearestPlane].distanceFromOrigin < spheres[nearestSphere].distanceFromOrigin ){\n                color = planes[nearestPlane].color;\n                \n                hit.t = planes[nearestPlane].distanceFromOrigin;\n                hit.reflectionFactor = planes[nearestPlane].reflectionFactor;\n                hit.intersectedObjectColor = planes[nearestPlane].color;\n                hit.rayDir = rayDir;\n                hit.pos = origin+(rayDir*planes[nearestPlane].distanceFromOrigin);\n                hit.normal = planes[nearestPlane].normal;               \n                \n                if(planes[nearestPlane].drawSquares == true){\n                     color = drawSquaresOnPlane(planes[nearestPlane],hit,squareWidth);\n                }               \n                 \n            }else{\n                            \n                color = spheres[nearestSphere].color;\n                \n                \n                hit.t = spheres[nearestSphere].distanceFromOrigin;\n                hit.reflectionFactor = spheres[nearestSphere].reflectionFactor;\n                hit.intersectedObjectColor = spheres[nearestSphere].color;\n                hit.rayDir = rayDir;\n                hit.pos = origin+(rayDir*spheres[nearestSphere].distanceFromOrigin);\n                hit.normal = hit.pos-spheres[nearestSphere].pos;\n                \n                if(spheres[nearestSphere].refracter == true){\n                    hit.refracter = true;\n                    \n                    hit.refractFactor = spheres[nearestSphere].refractFactor;\n                }else{\n                    hit.refracter = false;\n                }\n                \n            }\n        }else if(nearestPlane == -1 && nearestSphere != -1){\n            color = spheres[nearestSphere].color;\n            \n            hit.t = spheres[nearestSphere].distanceFromOrigin;\n            hit.reflectionFactor = spheres[nearestSphere].reflectionFactor;\n            hit.intersectedObjectColor = spheres[nearestSphere].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*spheres[nearestSphere].distanceFromOrigin);\n            hit.normal = hit.pos-spheres[nearestSphere].pos;\n            \n            if(spheres[nearestSphere].refracter == true){\n                hit.refracter = true;\n                \n                hit.refractFactor = spheres[nearestSphere].refractFactor;\n            }else{\n                hit.refracter = false;\n            }\n            \n        }else if(nearestPlane != -1 && nearestSphere == -1){ \n            color = planes[nearestPlane].color;\n            \n            hit.t = planes[nearestPlane].distanceFromOrigin;\n            hit.reflectionFactor = planes[nearestPlane].reflectionFactor;\n            hit.intersectedObjectColor = planes[nearestPlane].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*planes[nearestPlane].distanceFromOrigin);\n            hit.normal = planes[nearestPlane].normal;\n            \n            if(planes[nearestPlane].drawSquares == true){\n                 color = drawSquaresOnPlane(planes[nearestPlane],hit,squareWidth);\n            }\n            \n        }\n    }\n    \n    \n    return color;\n   \n    \n}\n\n\nvec3 drawShapesRefraction(in plane planes[1],in sphere spheres[3],in vec3 origin, in vec3 rayDir,int refractedObject,out HIT hit){\n    vec3 color = vec3(0.7,0.0,0.);       \n    \n    float squareWidth = 1.0;\n    int hits = 0;\n    \n     \n    int nearestPlane = -1;\n    int nearestSphere = -1;\n    \n    int refractorObj = 2;\n    \n    for(int i = 0;i<planes.length();i++){//cast ray and check if collides with any plane\n    float distanceToHit;\n        if(castRayToPlane(origin,rayDir, planes[i],distanceToHit) == true){//if ray collides with a plane\n            hits++;\n            planes[i].distanceFromOrigin = distanceToHit;\n      \n            if(nearestPlane == -1){\n                nearestPlane = i;\n            }else if(nearestPlane != -1){\n                if(planes[nearestPlane].distanceFromOrigin > planes[i].distanceFromOrigin){\n                   \n                    nearestPlane = i;\n                }\n            }\n            hit.t = distanceToHit;\n            hit.reflectionFactor = planes[i].reflectionFactor;\n            hit.intersectedObjectColor = planes[i].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*planes[i].distanceFromOrigin);\n            hit.normal = planes[i].normal;\n            \n            //draw squares if needed\n            \n            if(planes[nearestPlane].drawSquares == true){\n                     color = drawSquaresOnPlane(planes[nearestPlane],hit,squareWidth);\n            }else{\n                color = planes[i].color;\n            }          \n        }\n    }\n       \n    for(int i = 0;i<spheres.length();i++){//cast ray and check if collides with any sphere\n    float distanceToHit;\n    if(i != refractedObject){\n        if(castRayToSphere(origin,rayDir, spheres[i],distanceToHit) == true){//if ray collides with a sphere\n            hits++;\n            spheres[i].distanceFromOrigin = distanceToHit;\n            \n            if(nearestSphere == -1){\n                nearestSphere = i;\n            }else if(nearestSphere != -1){\n                if(spheres[nearestSphere].distanceFromOrigin > spheres[i].distanceFromOrigin){\n                    \n                    nearestSphere = i;\n                }\n            }\n            hit.t = distanceToHit;\n            hit.reflectionFactor = spheres[i].reflectionFactor;\n            hit.intersectedObjectColor = spheres[i].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*spheres[i].distanceFromOrigin);\n            hit.normal = hit.pos-spheres[i].pos;\n            \n            if(spheres[i].refracter == true){\n                hit.refracter = true;\n                \n                hit.refractFactor = spheres[i].refractFactor;\n            }else{\n                hit.refracter = false;\n            }\n            \n            color = spheres[i].color; // return color\n        }\n    }\n        \n    }\n    \n    //check other hits and distances\n    if(hits > 1){\n        if(nearestPlane != -1 && nearestSphere != -1){//intersection sphere and plane\n            if(planes[nearestPlane].distanceFromOrigin < spheres[nearestSphere].distanceFromOrigin ){\n                color = planes[nearestPlane].color;\n                \n                hit.t = planes[nearestPlane].distanceFromOrigin;\n                hit.reflectionFactor = planes[nearestPlane].reflectionFactor;\n                hit.intersectedObjectColor = planes[nearestPlane].color;\n                hit.rayDir = rayDir;\n                hit.pos = origin+(rayDir*planes[nearestPlane].distanceFromOrigin);\n                hit.normal = planes[nearestPlane].normal;               \n                \n                if(planes[nearestPlane].drawSquares == true){\n                     color = drawSquaresOnPlane(planes[nearestPlane],hit,squareWidth);\n                }               \n                 \n            }else{\n                            \n                color = spheres[nearestSphere].color;\n                \n                \n                hit.t = spheres[nearestSphere].distanceFromOrigin;\n                hit.reflectionFactor = spheres[nearestSphere].reflectionFactor;\n                hit.intersectedObjectColor = spheres[nearestSphere].color;\n                hit.rayDir = rayDir;\n                hit.pos = origin+(rayDir*spheres[nearestSphere].distanceFromOrigin);\n                hit.normal = hit.pos-spheres[nearestSphere].pos;\n                \n                if(spheres[nearestSphere].refracter == true){\n                    hit.refracter = true;\n                    \n                    hit.refractFactor = spheres[nearestSphere].refractFactor;\n                }else{\n                    hit.refracter = false;\n                }\n                \n            }\n        }else if(nearestPlane == -1 && nearestSphere != -1){\n            color = spheres[nearestSphere].color;\n            \n            hit.t = spheres[nearestSphere].distanceFromOrigin;\n            hit.reflectionFactor = spheres[nearestSphere].reflectionFactor;\n            hit.intersectedObjectColor = spheres[nearestSphere].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*spheres[nearestSphere].distanceFromOrigin);\n            hit.normal = hit.pos-spheres[nearestSphere].pos;\n            \n            if(spheres[nearestSphere].refracter == true){\n                hit.refracter = true;\n                \n                hit.refractFactor = spheres[nearestSphere].refractFactor;\n            }else{\n                hit.refracter = false;\n            }\n            \n        }else if(nearestPlane != -1 && nearestSphere == -1){ \n            color = planes[nearestPlane].color;\n            \n            hit.t = planes[nearestPlane].distanceFromOrigin;\n            hit.reflectionFactor = planes[nearestPlane].reflectionFactor;\n            hit.intersectedObjectColor = planes[nearestPlane].color;\n            hit.rayDir = rayDir;\n            hit.pos = origin+(rayDir*planes[nearestPlane].distanceFromOrigin);\n            hit.normal = planes[nearestPlane].normal;\n            \n            if(planes[nearestPlane].drawSquares == true){\n                 color = drawSquaresOnPlane(planes[nearestPlane],hit,squareWidth);\n            }\n            \n        }\n    }\n    \n    \n    return color;\n   \n    \n}\n\nvec3 applyReflection(in vec3 pixelColor,in HIT hit,in plane planes[1],in sphere spheres[3],in vec3 origin, in vec3 rayDir){\n\n    //REFLECTIONS HERE\n   \n    \n    vec3 reflectedRay = reflectRay(hit.rayDir,hit.normal);\n    HIT secondHit;\n    //the color reflected is also stored in secondHit.intersectedObjectColor\n    vec3 colorReflected = drawShapes(planes,spheres,hit.pos,normalize(reflectedRay),secondHit);\n    \n    vec3 re_reflectedRay = reflectRay(secondHit.rayDir,secondHit.normal);\n    HIT thirdHit;\n    //the color reflected is also stored in thirdHit.intersectedObjectColor\n    vec3 colorRe_reflected = drawShapes(planes,spheres,secondHit.pos,normalize(re_reflectedRay),thirdHit);\n    \n   \n    \n    //two reflection\n    pixelColor = mix(colorRe_reflected,pixelColor,hit.reflectionFactor);\n    \n    //one reflection\n    pixelColor = mix(colorReflected,pixelColor,hit.reflectionFactor);\n    return pixelColor; \n}\n\nvec3 applyShaders(in plane planes[1],in sphere spheres[3],in vec3 origin, in vec3 rayDir, in vec3 lightOrigin,in HIT hit,in vec3 pixelColor,int refracterID){\n    \n    \n    //SHADOWS HERE\n    float lightIntensity = 1.0;\n    \n    vec3 lightDir = normalize(lightOrigin-hit.pos);\n    float distanceToHit;\n    \n    bool rayIntersects = false;\n    \n    for(int i = 0;i<planes.length();i++){\n        if(castRayToPlane(hit.pos,lightDir,planes[i],distanceToHit)){\n            rayIntersects = true;\n        }else{\n            lightIntensity = dot(hit.normal,lightDir)+0.25;//specular\n        }\n    }\n    for(int i = 0;i<spheres.length();i++){\n    if(spheres[i].refracter == false){\n        if(castRayToSphere(hit.pos,lightDir,spheres[i],distanceToHit)){\n            rayIntersects = true;\n        }else{\n            lightIntensity = dot(hit.normal,lightDir)+0.25;//specular\n        }\n    }\n        \n    }\n    \n    if(rayIntersects){//light when should be shadow = ambient light\n        lightIntensity = 0.2;\n    }\n    \n    vec3 reflPixelColor = applyReflection(pixelColor,hit,planes,spheres,origin,rayDir);\n   \n    vec3 refrPixelColor;\n    \n    //REFRACTION HERE\n    HIT tmpHit;\n    if(hit.refracter){\n        hit.refracterID = refracterID;    \n        //no shadows:\n        lightIntensity = 0.9;         \n        vec3 refractionRayDir = refractRay(rayDir, hit.normal, hit.refractFactor);\n        //i think is colliding with itself, thats why it is blue, bc the sphere is blue\n        refrPixelColor = drawShapesRefraction(planes,spheres,hit.pos,normalize(refractionRayDir),hit.refracterID,tmpHit);\n        pixelColor = mix(reflPixelColor,refrPixelColor,0.9);\n    }else{\n        pixelColor = reflPixelColor;\n    }\n    \n    \n    \n    if(hit.t != 0.){//dirRay hits with something\n         return pixelColor*lightIntensity;//here we cast the dark shadows = diffuse\n    }else{\n         return pixelColor;\n    }\n   \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = (uv*2.)-1.;//(from -1 to 1)\n    uv.y/=2.;\n   \n   \n    // Camera zoom\n    float zoom = 0.5;//-0.5 + iMouse.y * 0.01;   \n    // Camera rotation\n    vec2 rotation = vec2(0./*-iMouse.x * 0.01*/,  iMouse.y * 0.01);\n    if(rotation.y > 4.){\n        rotation.y = 4.;\n    }\n    if(rotation.y < 1.){\n        rotation.y = 1.;\n    }\n    vec3 camPos = cameraPosition(zoom, rotation);\n    \n    camPos.y+=1.;\n   \n    vec3 pixelTarget = vec3(uv.x,uv.y+1.,0.);\n    vec3 rayDir = normalize(pixelTarget - camPos);\n        \n    //Scene objects\n    plane planes[1];\n    \n    plane plane1;\n    plane1.pos = vec3(0.,-1.,0.);\n    plane1.normal = vec3(0.,1.,0.);\n    plane1.color = vec3(1.,1.,1.);\n    plane1.drawSquares = true;\n    plane1.reflectionFactor = 0.9;\n    planes[0] = plane1;\n    \n    sphere spheres[3];\n    \n    sphere sphere1;\n    sphere1.pos = vec3(3.,sin(iTime*2.),sin(iTime)*2.+5.);\n    sphere1.radius = 1.9;\n    sphere1.color = vec3(0.9,0.9,0.9);\n    sphere1.reflectionFactor = 0.0;\n    sphere1.refracter = false;\n    spheres[0] = sphere1;\n    \n    sphere sphere2;\n    sphere2.pos = vec3(sin(iTime)-3.,0.,4.);\n    sphere2.radius = 0.9;\n    sphere2.color = vec3(0.3,0.3,0.3);\n    sphere2.reflectionFactor = 1.0;\n    sphere2.refracter = false;\n    spheres[1] = sphere2;\n    \n    \n    sphere sphere3;\n    sphere3.pos = vec3(-3.,sin(iTime)*2.,3.);\n    sphere3.radius = 2.0;\n    sphere3.color = vec3(0.3,0.9,0.9);\n    sphere3.reflectionFactor = 0.5;\n    sphere3.refracter = true;\n    sphere3.refractFactor = 1.20;\n    spheres[2] = sphere3;\n    \n    \n    \n    HIT hit;\n    hit.t = 0.;\n    //lightOrigin.z = sin(iTime)*2.;\n    \n    \n    \n    vec3 pixelColor = drawShapes(planes,spheres,camPos,rayDir,hit);\n    \n    //to avoid ray intersection with the hit point\n    \n    hit.pos = hit.pos + hit.normal*0.001;\n    \n    \n    vec3 modifiedPixelColor = applyShaders(planes,spheres,camPos,rayDir,lightOrigin,hit,pixelColor,2);\n   \n    \n   \n    float fogFactor = smoothstep(fogMinDistance,fogMaxDistance,hit.t);\n   \n    modifiedPixelColor = mix(modifiedPixelColor,fogColor,fogFactor);\n    // Output to screen\n    fragColor = vec4(modifiedPixelColor,1.0);\n}","name":"Image","description":"","type":"image"}]}