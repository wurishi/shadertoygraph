{"ver":"0.1","info":{"id":"7scSRj","date":"1633509263","viewed":107,"name":"Circle Inversion __","username":"Envy24","description":"https://en.wikipedia.org/wiki/Inversive_geometry\n\nmouse.x = zoom","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circle","checkerboard","mapping","inversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 circleInversion_inPolarCoords(in vec2 uv)\n{\n    uv = mapCartesianToPolar(uv);  \n    uv.x = 1.0 / uv.x;  \n    return mapPolarToCartesian(uv);\n}\n\nvec2 circleInversion_inCartesianCoords(in vec2 uv) { return uv / dot(uv, uv); }\n\nvec4 sceneA(in vec2 P)\n{\n    float S = 200.0 * MX;\n    vec2 uv = (P/R.x) * S;\n    \n    uv -= vec2(0.5 * S, (R.y/R.x) * 0.5  * S);\n    uv = circleInversion_inCartesianCoords(uv);\n    uv += (iTime * 0.1);\n\n    return checkerboard(uv, 10.0);\n}\n\nvec4 sceneB(in vec2 P)\n{\n    vec2 R = iResolution.xy;\n    \n    P = (P+P-R) / R.x * MX;\n    P = sin(sin(mod(P / dot(P, P) + iTime*2.5, 4.0)));\n\n    //return vec4(vec3(P.x), 1.0); \n    return vec4(P.x, P.y, P.x * P.y, 1.0);\n}\n\nvoid sceneC(out vec4 O, in vec2 P)\n{\n    vec2  R = iResolution.xy,\n          U = (P+P-R) / (R.x*.25 * MX);\n          U = U*U;\n\n    float S = TAU*5.;\n    U = sin(S*mod( U/dot(U,U) + iTime*.1,S));\n    U *= U.y;\n    //O += U.x/fwidth(U.x);\n    O += 0.5 -U.x;\n}\n\nvoid sceneD(out vec4 O, in vec2 P)\n{\n    vec2  R = iResolution.xy,\n          U = (P+P-R) / (R.x* MX);        \n\n    float S = TAU*5.;\n    U = sin(S*mod( U/dot(U,U) + iTime*.1,S));\n    U *= U.y;\n    //O += U.x/fwidth(U.x);\n    O += 0.5-U.x;\n}\n\nvoid sceneE(out vec4 O, in vec2 P)\n{\n    vec2  R = iResolution.xy,\n          U = (P+P-R) / (R.x*.125 * MX);\n          U = log2(U*U*U*U);\n\n    float S = TAU*5.;\n    U = sin(S*mod(U/dot(U,U) + iTime*.1,S));\n    U *= U.y;\n    O += U.x/fwidth(U.x);\n    //O += 0.5 -U.x;\n\n}\n\nvoid sceneF(out vec4 O, in vec2 P)\n{\n    vec2  R = iResolution.xy,\n          U = (P+P-R) / (R.x*.125 * MX);\n          U = log2(U*U*U*U);\n\n    float S = TAU*5.;\n    U = sin(S*mod( U/dot(U,U) + iTime*.1,S));\n    U *= (U.y / U.x) / (U.y / U.x);\n    O += U.x/fwidth(U.x);\n    //O += 0.5 -U.x;\n\n}\n\nvoid mainImage( out vec4 O, in vec2 P)\n{\n    O = vec4(0);\n    /**/\n    float T = mod(iTime, 24.);\n\n    if (T < 4.0) {  O = sceneA(P); }\n    else if (T < 8.0) { O = sceneB(P); }\n    else if (T < 12.0) { sceneC(O, P); }\n    else if (T < 16.0) { sceneD(O, P); }\n    else if (T < 20.0) { sceneE(O, P); }\n    else { sceneF(O, P); }\n    /**/\n    \n    /**\n    //O = sceneA(P);\n    //O = sceneB(P);\n    //sceneC(O, P);\n    //sceneD(O, P);\n    //sceneE(O, P);\n    sceneF(O, P);\n    /**/\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R        iResolution\n#define TAU      6.2831853071795862\n#define MX       (0.251 - (iMouse.x / iResolution.x))\n\nvec4 checkerboard(vec2 uv, float count)\n{\n    uv = mod(uv * count, 2.0);\n      \n    return vec4((uv.x < 1.0) ^^ (uv.y < 1.0));\n}\n\nvec2 mapCartesianToPolar(vec2 uv)\n{\n    float phi = atan(uv.x, uv.y);\n\n    phi = phi < 0.0 ? phi + TAU : phi;\n\n    return vec2(\n        sqrt(uv.x * uv.x + uv.y * uv.y), // r\n        phi);                            // phi [0.0; 2*PI].\n}\n\nvec2 mapPolarToCartesian(vec2 uv)\n{\n    return vec2(\n        uv.x * cos(uv.y),   // x\n        uv.x * sin(uv.y));  // y\n}","name":"Common","description":"","type":"common"}]}