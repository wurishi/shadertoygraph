{"ver":"0.1","info":{"id":"DsyfD1","date":"1698161714","viewed":42,"name":"two-dimensional random noise","username":"tomcat7479","description":" Plot the simple ground with two-dimensional random noise\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["twodimensionalrandomnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n  Plot the ground with two-dimensional random noise\n*/\n\n#define N 2\n#define min_iter_distance 0.1\n#define max_iter_distance 200.0\n#define iter_count 200\n#define iter_precision 1e-4\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nfloat hash12(vec2 p) {\n\t  vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat random(vec2 pos) {\n    // return abs(fract(78523.215 * sin(dot(pos, vec2(25.32, 547.23)))));\n    return hash12(pos);\n}\n\nfloat noise(vec2 pos) {\n    vec2 i = floor(pos);\n    vec2 f = fract(pos);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    // (1 - u.x) * a + u.x * b + (c - a) * u.y * (1 - u.x) + (d - b) * u.x * u.y 二维插值 \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 y_dir = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, y_dir));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat ground(vec2 p) {\n    return 3.0 * noise(p);\n}\n\nvec3 calNormal(vec3 p) {\n    vec2 epsilon = vec2(1e-5, 0);\n    return normalize(vec3(\n        ground(p.xz + epsilon.xy) - ground(p.xz - epsilon.xy),\n        2.0 * epsilon.x,\n        ground(p.xz + epsilon.yx) - ground(p.xz - epsilon.yx)\n    ));\n}\n\n/**\n  trick1 about Iteration accuracy: \n      In fact, in order to reduce the number of iterations, we can make a rough estimate of the distant pixel\n      position, which we do as follows:\n        h_diff < iter_precision * t, t is the current ground sdf distance\n      In general, for distant pixel positions, the value of t is larger, so iteration can be stopped quickly.\n\n  trick2 about ground sdf: \n    We use vertical distance directly when calculating the height difference between pixel and ground, \n    but there is a problem with this trick: the actual sdf minimum distance must be less than the height\n    difference we currently calculate, which will introduce a certain error in rendering. \n\n    However, we have a simple way to deal with it: give a samll scale, either fixed or dynamically determined base on the position\n    In the current case, we choose fixed scale.\n      code: t += 0.1 * h_diff    \n*/\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = min_iter_distance;\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ro + t * rd;\n        float d = ground(p.xz);\n        float h_diff = abs(p.y - d);\n        if (h_diff < iter_precision * t || t > max_iter_distance) {\n            break;\n        }\n        t += 0.1 * h_diff;\n    }\n    return t;\n}\n\nvec3 render(in vec2 uv) {\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 5.0, 3.0);\n\n    float focus_distance = 1.0;\n    vec3 ro = vec3(4.0 * sin(0.2 * iTime), 4.0, 4.0 * cos(0.2 * iTime));\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, focus_distance));\n    float rm = rayMarch(ro, rd);\n    vec3 color = vec3(0.38, 0.93, 0.93);\n    vec3 ground_color = vec3(0.67, 0.57, 0.44);\n    if (rm < max_iter_distance) {\n        vec3 p = ro + rm * rd;\n        vec3 n = normalize(calNormal(p));\n        vec3 l = normalize(light_pos - p);\n        \n        vec3 ambient = ground_color * light_color * 0.41;\n\n        float dif_cos = clamp(dot(n, l), 0.0, 1.0);\n        vec3 diffuse = ground_color * light_color * dif_cos * 0.91;\n\n        color = ambient + diffuse;\n    }\n    return color;\n}\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = 2.0 * (vec2(float(i), float(j)) / float(N) - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    return color / float(N * N);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}