{"ver":"0.1","info":{"id":"DtyGDt","date":"1684893783","viewed":102,"name":"Fork Dual Sound liangjiaqi 928","username":"liangjiaqi","description":"a music shader","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["tunnel","checkerboard","shader","3dimensional"],"hasliked":0,"parentid":"llyGWh","parentname":"Dual SoundCloud Visualizer"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis tunnel shader was simplified to be specially usable for raycasting.\n*/\n\n//扫光控制\nfloat sweepControl = 1.0;\n\n//扫光颜色\nvec3 sweepColor = vec3(1);\n\n//扫光快慢\nfloat sweepSpeed = 0.2;\n\n//扫光频率\nfloat sweepFreq = 0.1;\n\n//扫光开始宽度\nfloat sweepWidthStart = 0.1;\n\n//扫光结束宽度\nfloat sweepWidthEnd = 0.01;\n\n//X背景颜色\nvec3 XBGColor = vec3(0.1);\n\n// 控制线条宽度\nfloat lineWidth = 0.15; \n\n//隧道背景颜色\nvec3 tunneBgColor = vec3(0.3);\n\n//隧道内颜色\nvec3 tunneInnerColor = vec3(1);\n\n//隧道外颜色\nvec3 tunneOutterColor = vec3(0.5);\n\n//内外颜色比例\nfloat tunnerColorRate = 2.;\n\n//隧道快慢\nfloat tunneSpeed = 0.5;\n\n//隧道数量\nfloat tunneNumber = 0.3;\n\n//音乐颜色\nvec3 musicColor = vec3(0.0,0.6,0.0);\n\n//扫光位置\nfloat sweepStartPos = 7.;\n\nfloat sweepCurrentPos = 0.0;\n\nvec3 debug = vec3(1.0);\n\nvec2 tunnelize(vec2 uv, float size) {\n    float xmod = uv.x;\n    float ymod = size / max(abs(uv.x), abs(uv.y)) + iTime * tunneSpeed;\n    return vec2(xmod, ymod);\n}\n\nfloat map(float value) {\n    return (value * (10.0 - sweepStartPos)) + sweepStartPos;\n}\n\nvec3 TunLayer(vec2 uvh,vec2 uvT,float dist,vec2 circlePos) {\n    \n    float sweepMask1 = 1.0;\n    float sweepMask2 = 1.0;\n    \n    vec2 uv = (uvh + 1.0)/ 2.0;\n    \n    if ((uv.x < uv.y && (1.0 - uv.x) > uv.y) || (uv.x > uv.y && (1.0 - uv.x) < uv.y)) {\n        sweepMask1 = length(0.5 - uv.x);\n    }\n    else\n    {\n        sweepMask2 = length(0.5 - uv.y);\n    }\n    \n    float sweepMask = sweepMask1 * sweepMask2;\n    \n    \n    // 将dist映射到0到1的范围\n    float lineDist = clamp(dist / sqrt(2.0), 0.0, 1.0);\n    \n    //把 dist 映射成非线性\n    dist = pow(dist, tunnerColorRate);\n    \n    vec3 color = mix(tunneInnerColor, tunneOutterColor,sweepMask);\n    \n    float ymod = tunneNumber / max(abs(uvh.x), abs(uvh.y)) + map(sweepCurrentPos) * tunneSpeed;\n\n    \n    float t = sin(uvT.y * 50.0) * 0.5 + 0.5;\n        \n    color = mix(tunneBgColor, color, t);\n    \n    \n    debug = color;\n    \n    float sweepWidth = mix(sweepWidthStart,sweepWidthEnd,sweepMask);\n    \n    sweepWidth = clamp(sweepWidth, 0.01, 0.1);\n    \n    // 添加扫光效果\n    //float sweep = smoothstep(sweepWidth, 0.0, fract(uvT.y * sweepFreq + iTime * sweepSpeed));\n    \n    float sweepPhase = abs(fract(ymod * sweepFreq + 10.0 * sweepSpeed) - 0.5) * 2.0;\n    float sweep = smoothstep(sweepWidth, 0.0, sweepPhase);\n    \n    float line1 = abs(uvh.x - uvh.y);\n    float line2 = abs(uvh.x + uvh.y);\n    \n    vec3 lineColor = vec3(color);\n    \n    lineWidth = mix(0.0,lineWidth,lineDist);\n    \n    float edge = smoothstep(lineWidth, lineWidth + 0.3, min(line1, line2));\n    lineColor = mix(XBGColor, lineColor, edge);\n    \n    \n    lineColor += sweepColor * sweep * sweepControl * lineColor * 2.;\n    \n    return lineColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n    \n    vec2 uvh = uv*2.0-1.0;\n    //uvh.y -= 1.5;\n    vec2 uvk = tunnelize(uvh, tunneNumber);\t\n    \n    // 计算距离中心点的距离\n    float dist = length(uvh);\n    \n    vec2 circlePos = vec2(iResolution.x / iResolution.y - 0.5 *iResolution.x / iResolution.y ,iResolution.y / iResolution.x);\n    \n    vec3 color = TunLayer(uvh,uvk,dist,circlePos);\t\n    \n\tfragColor = vec4(color * musicColor,1.0);\n    \n    //fragColor = vec4(debug,1.0);\n}","name":"Image","description":"","type":"image"}]}