{"ver":"0.1","info":{"id":"NsjfWR","date":"1646004797","viewed":192,"name":"Exponent Grid","username":"ChunderFPV","description":"Transform grids with the exponent (power function).\nMouse x: exponent\nMouse y zoom","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["grid","power","transform","exponent"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// updated Jan 2023\n\n#define S 6. // scale\n#define R iResolution.xy\n#define M iMouse\n#define R2N(m) ((abs(m) > 1.) ? 1./(2.*sign(m)-(m)): m) // range: +-2 to number line\n\n// x grid transform\nfloat xgt(float x, float w)\n{\n    x = max(abs(x), 1./abs(x))*sign(x); // reciprocals\n    float l = max(0., 1.-(abs(fract(x+.5)-.5)/fwidth(x)/w)), // lines\n          g = pow(1.-abs(sin(x*3.1416)), 4.), // glow\n          d = min(1., sqrt(1./abs(x))); // darken\n    return (l+g)*d;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY)\n{\n    vec3  c = vec3(0);\n    vec2  m = (M.xy/R*4.)-2.; // mouse coords\n    float z = (M.z > 0.) ? pow(S, R2N(-m.y))*S: S, // zoom\n          sec = 30., // time for number line\n          e = (M.z > 0.) ? R2N(m.x): R2N(((mod(iTime, sec)/sec)-.5)*4.), // exponent\n          aa = 2., // anti-aliasing (1=off)\n          b = .5,  // brightness\n          w = 1.5; // line size\n    \n    for (int k = 0; k < int(aa*aa); k++) // aa loop\n    {\n        vec2 o = vec2(k%2, k/2)/aa,   // aa offset\n             u = (XY-.5*(R+o))/R.y*z; // screen coords\n        u = exp(log(abs(u))/e);       // apply exponent\n        float x = abs(u.x),\n              y = abs(u.y);\n        \n        // grids\n        c    += xgt( x, w)*b;   // x\n        c    += xgt( y, w)*b;   // y\n        c.rg += xgt( x+y, w)*b; // add\n        c.b  += xgt( x-y, w)*b; // subtract\n        c.gb += xgt( x*y, w)*b; // multiply\n        c.rb += xgt( x/y, w)*b; // divide\n    }\n    c /= aa*aa; // fix brightness after aa\n    \n    vec2 u = (XY-.5*R)/R.y*2.; // digit coords\n    c = max(c, digit(iChannel0, u-vec2(0, -.95), e, .2, 4., 3.)); // digits\n    \n    RGBA = vec4(c*sqrt(c), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// font code from https://www.shadertoy.com/view/7tV3zK\nvec4 char(sampler2D ic, vec2 p, int c)\n{\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad(ic, p/16. + fract( vec2(c, 15-c/16)/16.), dFdx, dFdy );\n}\nvec4 pInt(sampler2D ic, vec2 p, float n, float d)\n{\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(ic, p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = d; i>0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(ic, p - .5*vec2(i-1.,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// texture, screen coords, value, size, num left digits, num right digits\nvec3 digit(sampler2D ic, vec2 uv, float v, float s, float l, float r)\n{\n    float numleft = min(log2(abs(v))/log2(10.), l-1.);\n    l = max(floor(numleft), 0.)+1.;\n    uv /= s; // size\n    if (isinf(abs(v))) return vec3(char(ic, uv*.7+vec2(.5, .3), 153).x); // infinity symbol\n    uv += vec2((l+1.)/2., .28); // center on decimal\n    vec3 d = vec3(0);\n    d += pInt(ic, uv, v, l).x; // left of decimal\n    uv.x -= l/2.;\n    d += char(ic, uv, 46).x; // decimal point\n    uv.x -= .5;\n    d += pInt(ic, uv, floor(abs(v)*pow(10., r)), r).x; // right of decimal\n    return d;\n}\n","name":"Common","description":"","type":"common"}]}