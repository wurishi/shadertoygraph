{"ver":"0.1","info":{"id":"dtj3Rh","date":"1672992016","viewed":187,"name":"Christmas boids party","username":"tieutieu","description":"\nI'v tried to reach that result [url]https://vimeo.com/455364677[/url]\nNot quite yet but it's still interesting to watch.\nenjoy!\n\nInclude:\n[url]https://www.shadertoy.com/view/3ty3Dy[/url] (fork)\n\n","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["2d","perlinnoise","particles","splat","swarm","boids","voronoitracking","write2xy","writetoxy","voronoiparticlestracking"],"hasliked":0,"parentid":"mtSGRh","parentname":"firefly swarm"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//DRAW PARTICLE\n\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = T2(I);\n    \n\n\n    //\n    float sinTime       = iTime/COLOR_PERIOD*3.14;\n    float sinTimeOffset = 0.5*3.14;\n    \n    // PARTICLE POST PROCESS\n    vec4 a = T1(I);         // 4 particule id (supposed to be particles closest to I)\n    \n    for(int i = 0; i < 4; i++){ // draw Gaussian blobs\n        \n        float iP = a[i];\n        vec4 P = A(iP);\n        vec4 M = A_mode(iP);\n        \n        vec2 v = I - P.xy;\n  \n         \n        if( length(v) < PARTICLE_SIZE ){\n            O += vec4(1.,1.,1.,0.0)*0.3*max( 1.-M.y,0.6);\n        }\n        \n\n  \n     }\n    \n    \n    //O = vec4(fract(I.xy/10.),0.,0.);\n    \n    //O = T0(I);//DEBUG BUFFER A\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n//PARTICLE BEHAVIOR / POSITION & MOMENTUM STORAGE\n\n\nfloat perlin_noise_animated(vec2 p, float scale, float speed)\n{\n    float value = perlin_noise(vec3(p.x*scale,p.y*scale, iTime*speed));\n    return value;\n}\n\nvec2 perlin_noise_animated_rotate_vector(vec2 p, float scale, float speed)\n{\n    float angle = perlin_noise_animated( p.xy, scale, speed)*3.14 *2. ;\n    return vec2(cos(angle),sin(angle));    \n}\n\n#define DEBUG_PERLIN_NOISE 0\n#define DEBUG_PERLIN_NOISE_VECTOR 0\n#define DEBUG 0\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = T0(I);               \n    O.xy = mod(O.xy,R);\n\n    if(iFrame<T_START){\n        vec4 r = rand4( int(I.x) + int(I.y)*2141 + (int(iTime*2141.)+iFrame)*2141);\n        O.xy = I.xy;//r.xy*R;\n        O.zw = .25*cos(TAU*(vec2(0,.25)+r.z));    \n    }\n    else{\n        vec2 p     = O.xy;\n        vec2 v_mom = O.zw;\n        vec4 M = T3(I);\n\n        // STEER\n        float perlin_scale = PARTICLE_STEERING_PERLIN_SCALE;\n        float perlin_speed = PARTICLE_STEERING_PERLIN_SPEED;\n\n        float steer_power = perlin_noise(I.xyx)*PARTICLE_STEERING_POWER;\n        vec2 v_steer = perlin_noise_animated_rotate_vector(O.xy, perlin_scale, perlin_speed)*steer_power;\n\n        //NEIGHBOR BEHAVIOR - maintain dist / attract / straight / repluse / \n        float neighborMode =M.z;\n        vec4 a = T1(p.xy);\n        vec4 bary = ( A(a[0])+A(a[1])+A(a[2])+A(a[3]) )/4.;\n        vec2 vRegroup = bary.xy - p;\n        vRegroup = normalize(vRegroup);   \n\n        vec2 v_mom_next = v_mom + v_steer;\n        \n        if( neighborMode < -0.5 ){ //maintain dist \n            float dist = 5.;\n            vec2 vBarToPos = normalize(vRegroup*-1.)*dist;\n            vec2 vTarget = (bary.xy + vBarToPos) - (p + v_mom + v_steer) ;\n            v_mom_next = v_mom + v_steer + vTarget * 0.1 ;\n            \n            v_mom_next *= 1. - ENV_FRICTION;//FRICTION\n        }        \n        \n        if( ( -0.5 < neighborMode )&&( neighborMode < 0.5) ){ //ATTRACT\n            v_mom_next = v_mom + v_steer + vRegroup*0.1; \n            \n            v_mom_next *= 1. - ENV_FRICTION;//FRICTION\n        }\n        \n        if( ( 0.5 < neighborMode )&&( neighborMode < 2.5) ){ //STRAIGHT\n            v_mom_next = v_mom ; \n        }\n        \n        if( 2.5 < neighborMode ){ //REPULSE\n            v_mom_next = v_mom + v_steer + vRegroup*0.1*-1.;\n            \n            v_mom_next *= 1. - ENV_FRICTION;//FRICTION\n        }\n        \n\n\n                \n        \n        float speed = length(v_mom_next);\n        if( speed < MIN_SPEED ){\n            v_mom_next = normalize(v_mom_next) * MIN_SPEED;\n        }\n        \n        p += v_mom_next;\n\n        //next step\n        O.zw = p - O.xy;\n        O.xy = p;\n    }\n    \n    \n     \n \n \n#if DEBUG_PERLIN_NOISE_VECTOR \n    vec2 perlin_vector = perlin_noise_animated_rotate_vector(I.xy, perlin_scale, perlin_speed);\n    \n    float d_r =  max( 0.,perlin_vector.x);\n    float d_g =  max( 0.,perlin_vector.y);\n    float d_b =  max( 0.,perlin_vector.x*-1.);\n    \n    O = vec4( d_r,d_g,d_b,1.); // DEBUG\n#endif\n\n#if DEBUG_PERLIN_NOISE\n    float perlin_value = perlin_noise_animated(I.xy, perlin_scale, perlin_speed);\n    O =vec4( perlin_value,0,0,0 );\n    if( perlin_value < 0. )\n        O =vec4( 0.,perlin_value*-1.,0,0 );\n#endif\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n//OPTIM - FOR EACH PIXEL STORE 4 CLOSEST PARTICLES ( voronoitracking )\n\n\n\n// --- insert (i,d) and maintain the 4 closest (i_,d_) \nvoid list_insert(inout vec4 i, inout vec4 d, float i_, float d_){\t\n    if(i_ == 0.) return;           // not a particle : exit\n    if(any(equal(vec4(i_),i))) return; // already in top4 : exit\n    if     (d_ < d[0])             // closer to closest: insert here\n        i = vec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             // closer to 2nd closest: insert here\n        i = vec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])             // closer to 3rd closest: insert here\n        i = vec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])             // closer to 4th closest: insert here\n        i = vec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\n\nvec2 D;\n#define dist(i) ( D = mod( A(i).xy-I + R/2., R) - R/2., dot(D,D) )\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    vec4  i = vec4(0);\n    vec4  d = vec4(1e9); \n    \n    // STORE FROM HERE\n    vec4 i0 = T1( I ); \n    for(int k = 0; k < 4; k++)    \n        list_insert( i, d, i0[k], dist(i0[k]) );\n         \n    // 4 closests particles from n around\n    for( int n = 1; n < 1+TRACKING_SUROUND_PIXEL_CIRCLE_TO_CHECK; n++){\n        vec4 ia = T1( mod(I + vec2( 1*n, 0*n),R) );  \n        vec4 ib = T1( mod(I + vec2( 0*n, 1*n),R) );\n        vec4 ic = T1( mod(I + vec2(-1*n, 0*n),R) );\n        vec4 id = T1( mod(I + vec2( 0*n,-1*n),R) );\n\n        for(int k = 0; k < 4; k++){    \n            list_insert( i, d, ia[k], dist(ia[k]) );\n            list_insert( i, d, ib[k], dist(ib[k]) );\n            list_insert( i, d, ic[k], dist(ic[k]) );\n            list_insert( i, d, id[k], dist(id[k]) );\n        }\n\n#if 0 \n        // also checking diagonal (to test possibly axis bias)\n        ia = T1( mod(I + vec2( 1*n, 1*n),R) ),\n        ib = T1( mod(I + vec2(-1*n, 1*n),R) ),\n        ic = T1( mod(I + vec2( 1*n,-1*n),R) ),\n        id = T1( mod(I + vec2(-1*n,-1*n),R) );\n        for(int k = 0; k < 4; k++){    // sorts all these\n            list_insert( i, d, ia[k], dist(ia[k]) );\n            list_insert( i, d, ib[k], dist(ib[k]) );\n            list_insert( i, d, ic[k], dist(ic[k]) );\n            list_insert( i, d, id[k], dist(id[k]) );\n        }\n#endif        \n    }\n\n    // INSERT AT THE BEGINING OF THE FRAME\n    if(iFrame < T_START*2){\n        //vec2 pa = mod(I + vec2( 1, 0),R);  \n        //vec2 pb = mod(I + vec2( 0, 1),R);\n        //vec2 pc = mod(I + vec2(-1, 0),R);\n        //vec2 pd = mod(I + vec2( 0,-1),R);\n        //\n        //float i0 = I.y  * R.x + I.x;  \n        //float ia = pa.y * R.x + pa.x;  \n        //float ib = pb.y * R.x + pb.x;\n        //float ic = pc.y * R.x + pc.x;\n        //float id = pd.y * R.x + pd.x;\n          //\n        //i = vec4(i0,ib,ic,id);\n        //d = vec4(0.,1.,1.,1.);\n        \n        for(int k = 0; k < 1; k++){    \n        \n            int r = IHash( int(I.x) + int(I.y)*2141 + iFrame*2141*2141 +k*11131);\n            int i_ =  1 + r % ( int(R.x*R.y)/int(PARTICLES_NBR) );\n            list_insert(i, d, float(i_), dist(i_) );\n        }\n    }\n    \n    // stores 4 closest\n    O = vec4(i); \n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//DRAW PARTICLE TRAIL\n\nvec4 Red    = vec4( 0.9 , 0. , 0., 1.);\nvec4 GreenP = vec4( 0.4 , 0.6, 0.3, 1.);\n\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    // TRAIL\n    float sinTime       = iTime/COLOR_PERIOD*3.14;\n    float sinTimeOffset = 0.5*3.14;\n    \n    O = T2(I);\n    O.x*=0.99;\n    O.y*=0.99;\n    O.z*=0.99;\n    \n    // PARTICLE\n    vec4 a = T1(I);         // 4 particule id (supposed to be particles closest to I)\n    \n    for(int i = 0; i < 4; i++){ // draw Gaussian blobs\n        \n        float iP = a[i];\n        vec4 P = A(iP);\n        vec4 M = A_mode(iP);\n        \n        vec2 v = I - P.xy;\n        \n        if( length(v) < PARTICLE_SIZE ){\n            //O = vec4( abs(sin(sinTime))*0.8+0.5, abs(sin(sinTime+sinTimeOffset))*0.4, abs(sin(sinTime+sinTimeOffset*2.))*0.4, 1.);\n            O = GreenP * M.x + Red*( 1.0 - M.x);\n        }\n  \n     }\n\n   \n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//PARAMETERS\n#define PARTICLES_NBR 1. // 1 is the nbr max of particles (screen resolution) \n#define PARTICLE_SIZE 1.\n\n#define PARTICLE_STEERING_PERLIN_SCALE 0.01\n#define PARTICLE_STEERING_PERLIN_SPEED 0.5\n#define PARTICLE_STEERING_POWER 0.4\n\n#define ENV_FRICTION 0.05\n\n#define COLOR_PERIOD 5.\n\n//TECHNICAL PARAMETERS\n#define T_START 60*2\n#define TRACKING_SUROUND_PIXEL_CIRCLE_TO_CHECK 2\n#define MIN_SPEED 0.1\n\n\n\n\n\n\n//////////////////////////////////////////////////////////////UTILS\n\n// --- translate particle id (in [1,Rx*Ry] ) to buffer pixel \n#define A(n) T0( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 )  // +.5 useless\n#define A_mode(n) T3( vec2( (int(n)-1) % iR.x,      \\\n                       (int(n)-1) / iR.x ) +.5 )  // +.5 useless   \n\n// --- utils\n                           \n#define R     iResolution.xy\n#define iR    ivec2(iResolution)\n#define T0(U) texelFetch( iChannel0, ivec2(U)   , 0 )\n#define T1(U) texelFetch( iChannel1, ivec2(U)%iR, 0 )\n#define T2(U) texelFetch( iChannel2, ivec2(U)   , 0 )\n#define T3(U) texelFetch( iChannel3, ivec2(U)   , 0 )\n\n#define l2(x) dot(x,x)\n\n#define TAU 6.2831853\n                           \n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n                           \n\n// --- random numbers\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\n#define Hash(a) ( float(IHash(a)) / float(0x7FFFFFFF) ) // Uniform in [0,1]\n\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\n\n// --- normal law random generator\nvec2 randn(vec2 r){ // r: randuniform\n    r.x = sqrt( -2.* log(1e-9+abs(r.x)));\n    r.y *= TAU;\n    return r.x * vec2(cos(r.y),sin(r.y));\n}\n\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p)\n{\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    \n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    \n    return \tmix(\n        \t\tmix(\n                \tmix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),\n                       \tw.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),\n                       \tw.x),\n                \tw.z),\n        \t\tmix(\n                    mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),\n                       \tw.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),\n                       \tw.x),\n                \tw.z),\n    \t\t\tw.y);\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n//PARTICLE BEHAVIOR / POSITION & MOMENTUM STORAGE\n\n\nfloat perlin_noise_animated(vec2 p, float scale, float speed, float offset)\n{\n    float value = perlin_noise(vec3(p.x*scale,p.y*scale, iTime*speed+offset));\n    return value;\n}\n\nvec2 perlin_noise_animated_rotate_vector(vec2 p, float scale, float speed, float offset)\n{\n    float angle = perlin_noise_animated( p.xy, scale, speed,offset)*3.14 *2. ;\n    return vec2(cos(angle),sin(angle));    \n}\n\n#define DEBUG_PERLIN_NOISE 0\n#define DEBUG_PERLIN_NOISE_VECTOR 0\n#define DEBUG 0\nfloat sin_off =  0.7;\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n    O = T3(I); \n    vec4 P = T0(I);\n    //color/pointMode/NeighborBehavior\n\n    if(iFrame<T_START*5){\n        float perlin_value = perlin_noise(I.xyx);\n        \n        //COLOR - rouge / bleu vert\n        O.x = 0.;\n        if( 0. < perlin_value )\n            O.x = 1.;\n        //POINT MODE - none / point blanc / light\n        O.y = 1.;\n        //NEIGHBOR BEHAVIOR - maintain dist / attract / straight / repluse / \n        O.z = 0.;\n\n    }\n    else{\n        float perlin_value_i        = perlin_noise_animated(I, PARTICLE_STEERING_PERLIN_SCALE*2., PARTICLE_STEERING_PERLIN_SPEED,sin_off);\n        float perlin_value_B = perlin_noise_animated(P.xy, PARTICLE_STEERING_PERLIN_SCALE*0.2, PARTICLE_STEERING_PERLIN_SPEED*0.7,sin_off);\n        float perlin_value_momentum = perlin_noise_animated( vec2(length(P.zw)), PARTICLE_STEERING_PERLIN_SCALE*1.5, PARTICLE_STEERING_PERLIN_SPEED*0.3,sin_off);\n        //COLOR - rouge / bleu vert\n        O.x = 0.;\n        if( 0. < perlin_value_i )\n            O.x = 1.;\n            \n        //if(0.9<length(P.zw)){\n        //    O.x = 0.;\n        //    if( 0. < perlin_value_i )\n        //        O.x = 1.;\n        //}\n\n        //NEIGHBOR BEHAVIOR - maintain dist / attract / straight / repluse / \n        //O.z = 1.;\n        \n        O.z *= 0.95;\n        O.y *= 0.95;\n        \n        vec2 vDistC0 = (P.xy - vec2( sin(iTime*0.05+sin_off)*R.x,sin(iTime*0.01+sin_off)*R.y) );\n        float l_dist = length(vDistC0);\n        \n        if( (700.*sin(iTime*0.2-0.+sin_off)< l_dist)&&( l_dist < 700.*sin(iTime*0.2+0.5+sin_off)  ) )\n        {\n            \n            if( 0. < perlin_value_B ){\n                O.z = 3.;  \n                O.y = 1.;\n                O.x = 0.;\n            }\n        }\n\n        if( ( -0.01 < O.z)&&(O.z < 1.01) )\n        {\n        \n            \n            vec2 vDistC2 = (P.xy - R); \n            if(0.1<perlin_value_B)//(  length(vDistC2) < 900.*sin(iTime*0.6+0.5) )\n            {\n                O.y = 1.;\n                if( 0.5 < O.z )\n                    O.y = 3.;\n                \n                \n                O.z = -1.*sin(iTime*0.2+sin_off);\n                O.x = 1.;\n                \n            }\n        }\n    }\n    \n    \n     \n    \n    \n}","name":"Buffer D","description":"","type":"buffer"}]}