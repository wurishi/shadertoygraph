{"ver":"0.1","info":{"id":"wlfXWH","date":"1568039816","viewed":333,"name":"From Two to Three","username":"belfry","description":"Made the 2D version first, then decided to attempt a 3D version.\nMouseable.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void twod( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float expand = sin(iTime*.25)*0.5 - .5;\n    //float expand = sin(126.59*.25)*0.5 - .5;\n    uv -= -smoothstep(-1., 0., expand);\n    vec2 o = vec2(10000.);\n    for(float i = 0.; i < 5.; i++) {\n        uv -= smoothstep(-1., 0., expand);\n        float a = .3 + .5/length(uv) + iTime * .125;\n        uv *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        uv = abs(uv) * 1.3;\n        o = min(o, vec2(length(uv - 1.), length(uv - vec2(0., 1.))));\n    }\n\t//float d = length(uv) - 1.;\n    fragColor = vec4((o.yyx + o.yxx)*.5, 1.);\n}\n\nvec4 sdf( vec3 p )\n{\n    vec3 uv = p;\n    //float expand = sin(iTime*.25)*0.5 - .5;\n    float expand = sin(126.59*.25)*0.5 - .5;\n    uv -= -smoothstep(-1., 0., expand);\n    vec2 o = vec2(10000.);\n    for(float i = 0.; i < 7.; i++) {\n        uv -= smoothstep(-1., 0., expand);\n        float a = .3 + .5/length(uv) + iTime * .125 * 1.333;\n        uv.xy *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        uv = abs(uv) * 1.3;\n        o = min(o, vec2(length(uv - 1.), length(uv - vec3(0., 1., 0.))));\n    }\n\tfloat d = length(uv) - 1.2;\n    return vec4(d, (o.yyx + o.yxx)*.5);\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(0., .005);\n    float dx = sdf(p + eps.yxx).x - sdf(p - eps.yxx).x;\n    float dy = sdf(p + eps.xyx).x - sdf(p - eps.xyx).x;\n    float dz = sdf(p + eps.xxy).x - sdf(p - eps.xxy).x;\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec3 trace(vec3 camPos, vec3 dir, out vec3 p) {\n    float i = 0.;\n    float t = 0.03;\n    vec3 orb = vec3(0.);\n    for (; i < 350.; i++) {\n        p = t * dir + camPos;\n        vec4 d = sdf(p);\n        orb = d.yzw;\n        if (abs(d.x) < 0.05 * t) {\n            break;\n        }\n        t += abs(d.x) * .01;\n        if (t > 100.)\n            break;\n    }\n    \n    return orb * (.2 + .2 * t + i / 100. * max(0.2, (1.-t)));\n}\n\nvoid threed( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 camPos = vec3(-0.065 + sin(iTime * .3) * .1, -0.75 + sin(iTime * .2) * .9, -.4 + sin(iTime * .1) * 1.5);\n    vec3 dir = normalize(vec3(uv, 1. / tan(radians(60.) * .5)));\n    float a = iTime * .1;\n    dir.xz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    bool hit = false;\n    vec3 p = vec3(0.);\n    vec3 orb = trace(camPos, dir, p);\n    vec3 n = normal(p);\n    orb *= .8+.5*trace(p, reflect(dir, n), p) * orb.b * pow(1.-abs(dot(n, -dir)), orb.r);\n    \n    fragColor = vec4(orb, 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float x = iMouse.x / iResolution.x;\n    x = x == 0. ? step(iTime, 6.28) * sin(iTime) * .5 + .5 : x;\n    if (fragCoord.x / iResolution.x < x)\n    \ttwod(fragColor, fragCoord);\n    else\n        threed(fragColor, fragCoord);\n    \n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.xy;\n    uv = pow(abs(uv), vec2(3.));\n\tfragColor *= clamp(1.5-sqrt(uv.x + uv.y)*.9, 0., 1.);\n}\n","name":"Image","description":"","type":"image"}]}