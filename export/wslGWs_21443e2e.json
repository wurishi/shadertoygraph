{"ver":"0.1","info":{"id":"wslGWs","date":"1548021446","viewed":540,"name":"Noise Examples","username":"Xor","description":"Value noise (top-left), Perlin noise (top-right).\nWorley noise (bottom-left), Simplex noise (bottom-right).\n\t\nThis shows the different types of noise functions.\nFeel free to get creative and play around with them.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["2d","perlin","worley","simplex","value"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\t\"Noise Examples\" by Xor (@XorDev).\n\t\n\tValue noise (top-left), Perlin noise (top-right).\n\tWorley noise (bottom-left), Simplex noise (bottom-right).\n\t\n\tThis shows the different types of noise functions.\n\tFeel free to get creative and play around with them.\n*/\n\n//Simple hash function:\nfloat Hash(vec2 P)\n{\n\treturn fract(cos(dot(P,vec2(91.52,-74.27)))*939.24);\n}\n//2D signed hash function:\nvec2 Hash2(vec2 P)\n{\n\treturn 1.-2.*fract(cos(P.x*vec2(91.52,-74.27)+P.y*vec2(-39.07,09.78))*939.24);\n}\n//2D value noise.\nfloat Value(vec2 P)\n{\n\tvec2 F = floor(P);\n\tvec2 S = P-F;\n    //Bi-cubic interpolation for mixing the cells.\n\tvec4 M = (S*S*(3.-S-S)).xyxy;\n    M = M*vec4(-1,-1,1,1)+vec4(1,1,0,0);\n\t\n    //Mix between cells.\n\treturn (Hash(F+vec2(0,0))*M.x+Hash(F+vec2(1,0))*M.z)*M.y+\n\t\t   (Hash(F+vec2(0,1))*M.x+Hash(F+vec2(1,1))*M.z)*M.w;\n}\n//2D Perlin gradient noise.\nfloat Perlin(vec2 P)\n{\n\tvec2 F = floor(P);\n\tvec2 S = P-F;\n    //Bi-quintic interpolation for mixing the cells.\n\tvec4 M = (S*S*S*(6.*S*S-15.*S+10.)).xyxy;\n    M = M*vec4(-1,-1,1,1)+vec4(1,1,0,0);\n\t\n    //Add up the gradients.\n\treturn (dot(Hash2(F+vec2(0,0)),S-vec2(0,0))*M.x+dot(Hash2(F+vec2(1,0)),S-vec2(1,0))*M.z)*M.y+\n\t\t   (dot(Hash2(F+vec2(0,1)),S-vec2(0,1))*M.x+dot(Hash2(F+vec2(1,1)),S-vec2(1,1))*M.z)*M.w+.5;\n}\n//2D Worley noise.\nfloat Worley(vec2 P)\n{\n    float D = 1.;\n\tvec2 F = floor(P+.5);\n   \t\n    //Find the the nearest point the neigboring cells.\n    D = min(length(.5*Hash2(F+vec2( 1, 1))+F-P+vec2( 1, 1)),D);\n    D = min(length(.5*Hash2(F+vec2( 0, 1))+F-P+vec2( 0, 1)),D);\n    D = min(length(.5*Hash2(F+vec2(-1, 1))+F-P+vec2(-1, 1)),D);\n    D = min(length(.5*Hash2(F+vec2( 1, 0))+F-P+vec2( 1, 0)),D);\n    D = min(length(.5*Hash2(F+vec2( 0, 0))+F-P+vec2( 0, 0)),D);\n    D = min(length(.5*Hash2(F+vec2(-1, 0))+F-P+vec2(-1, 0)),D);\n    D = min(length(.5*Hash2(F+vec2( 1,-1))+F-P+vec2( 1,-1)),D);\n    D = min(length(.5*Hash2(F+vec2( 0,-1))+F-P+vec2( 0,-1)),D);\n    D = min(length(.5*Hash2(F+vec2(-1,-1))+F-P+vec2(-1,-1)),D);\n    return D;\n}\n//2D Simplex gradient noise.\n//3D cases will be covered under this patent:\n//https://en.wikipedia.org/wiki/Simplex_noise#Legal_status\nfloat Simplex(vec2 P)\n{\n    //Skewing and \"unskewing\" constants as decribed here: https://en.wikipedia.org/wiki/Simplex_noise\n    #define S (sqrt(.75)-.5)\n\t#define G (.5-inversesqrt(12.))\n   \n    //Calculate simplex cells.\n    vec2 N = P+S*(P.x+P.y);\n    vec2 F = floor(N);\n    vec2 T = vec2(1,0)+vec2(-1,1)*step(N.x-F.x,N.y-F.y);\n    \n    //Distance to the nearest cells.\n    vec2 A = F   -G*(F.x+F.y)-P;\n    vec2 B = F+T -G*(F.x+F.y)-G-P;\n    vec2 C = F+1.-G*(F.x+F.y)-G-G-P;\n    \n    //Calculate weights and apply quintic smoothing.\n    vec3 I = max(.5-vec3(dot(A,A),dot(B,B),dot(C,C)),0.);\n    I = I*I*I*(6.*I*I,-15.*I+10.);\n    I /= dot(I,vec3(1));\n    \n    //Add up the gradients.\n    return .5+(dot(Hash2(F),A)*I.x+\n        \t   dot(Hash2(F+T),B)*I.y+\n        \t   dot(Hash2(F+1.),C)*I.z);\n}\n\n//Output the noise types.\nvoid mainImage(out vec4 Color, in vec2 Coord)\n{\n    //Noise output float.\n    float N = 0.;\n    \n    //Coordinates for the noise.\n    vec2 P = Coord + 20.*iTime;\n    \n    //Centered coordinates for noise dividers.\n    vec2 U = Coord-.5*iResolution.xy;\n    \n    if (U.y>0.)\n    {\n        if (U.x<0.)\n        {\n            //Top-left: Fractal value noise.\n            N = .4*Value(P/64.)+.3*Value(P/32.)+.2*Value(P/16.)+.1*Value(P/8.);\n        }\n        else\n        {\n            //Top-right: Fractal Perlin noise.\n            N = .4*Perlin(P/64.)+.3*Perlin(P/32.)+.2*Perlin(P/16.)+.1*Perlin(P/8.);\n        }\n    }\n    else\n    {\n        if (U.x<0.)\n        {\n            //Bottom-left: Fractal Worley noise.\n            N = .4*Worley(P/64.)+.3*Worley(P/32.)+.2*Worley(P/16.)+.1*Worley(P/8.);\n        }\n        else\n        {\n            //Bottom-right: Fractal Simplex noise.\n            N = .4*Simplex(P/64.)+.3*Simplex(P/32.)+.2*Simplex(P/16.)+.1*Simplex(P/8.);\n        }\n    }\n    //Add the divider.\n    N *= smoothstep(1.,2.,min(abs(U.x),abs(U.y)));\n    \n\tColor = vec4(N,N,N,1);\n}","name":"Image","description":"","type":"image"}]}