{"ver":"0.1","info":{"id":"l3VGDm","date":"1717761459","viewed":44,"name":"(Tutorial) Distorted Lightning","username":"Muhammad","description":"distortion lightning shader with simple noise and easy steps to follow","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tutorial"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Pseudo-random number generator based on input coordinates\nfloat random(vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\n// Simple noise function\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n    // Smooth interpolation\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    // Mix 4 corners percentages\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy * 2.0) - 1.0; // (-1, 1) // getting the range in the middle\n    //cartesian coordinates?\n    \n    // Calculate sine offsets\n    float sineOffset = sin(uv.y * 3.0 + iTime * 2.) * 0.3; // first offset\n    float sine2 = cos(uv.y * 2.0 + iTime * 2.) * 0.2; //second offset\n    float final = sine2 * sineOffset; //you dont really need to do this but its better for making more distorted effects\n    //multiplying results of different amplitudes really results well\n\n    // Add noise to the x coordinate\n    float noiseFactor = noise(uv * 14. + iTime) * noise(uv * 14. + iTime * 2.); // Adjust the scale for desired noise effect\n    //noise factor is just to distort like lightning over time multiplying it to have complex shape\n    \n    //the d before any of the above code = 0.5 - length(uv.x) which gives a white light beam in the middle gradiently\n    //towards the black to the left and right. We are offsetting it to have complex lightning shape by adding final and noise factor. Play around with multiplication values \n    //to obtain different results\n    float d = 0.5 - length(uv.x + final + noiseFactor * 0.1) / 0.05; // Adjust noise intensity with the multiplier\n    \n    // Set the fragment color\n    fragColor = vec4(vec3(d + 1.) * vec3(0.,0.8,1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}