{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\n:globals\n\t@vec3 uniform =iResolution\n\t@float uniform =iTime\n;\n\n:m time iTime ;\n\n: rand ( x:float -> float )\n\tx 123 * 17 + sin x 69 * 49 + sin *\n;\n\niResolution frag->position 2 * =p\n\n:m vlinear { } ;\n:m vsine { sin } ;\n:m vspherical { !length / } ;\n:m vswirl { ( $i ) [ i .x 2 sq sin * i .y 2 sq cos * - i .x 2 sq cos * i .y 2 sq sin * + ] } ;\n:m vdisc { ( $i ) [ i length pi * !sin swap cos ] i .y.x atan2 * } ;\n\n[\n\t[ [ 1 0 0 ] 1 10 / [ -.30 time 2.3 / sin * .82 -.90 ] [ -.11 -.23 time 3.7 / sin * 0 ] vlinear ]\n\t[ [ 0 1 0 ] 1 5 / [ .24 -.79 time 4.8 / sin * .73 ] [ .63 -.12 -.25 time 9.7 / sin * ] vsine ]\n\t[ [ 0 0 1 ] .3 [ .98 time sin * .69 -.27 ] [ -.70 .96 .57 time atan * ] vspherical ]\n\t[ [ 1 0 1 ] .5 [ -.13 -.27 time * .19 ] [ .31 -.89 time * .5 ] vswirl ]\n\t[ [ 0 1 1 ] 1 [ .60 -.75 time * -.84 ] [ -.45 time 3 / sin * .14 -.32 ] vdisc ]\n] =>funcs\n\n5 =>runs\n\n[ 0 0 0 0 ] =hist\n\n{ ( i )\n\t[ time p .x + i float 1 + 379 / + rand time 17 * p .y + p .x + i float 1 + 417 / + rand ] =P\n\t[ 0 0 0 ] =C\n\n\t50 =>iters\n\t{ ( ii )\n\t\tP .x 673 * p .y 319 * + time 417 * + rand abs funcs size * floor =ci\n\t\t\t[ funcs enumerate /{ ( [ i [ color weight xvars yvars block ] ] ) [ ci i <=\n\t\t\t\t{\n\t\t\t\t\t[\n\t\t\t\t\t\tP .x xvars .x * P .y xvars .y * + xvars .z +\n\t\t\t\t\t\tP .x yvars .x * P .y yvars .y * + yvars .z +\n\t\t\t\t\t] *block =P\n\t\t\t\t\tC color + 2 / =C\n\t\t\t\t}\n\t\t\t] } /flatten flatten ]\n\t\tcond\n\t\t{\n\t\t\t[ hist .x 1 + hist .yzw P p - length .01 / / C + 2 / ] =hist\n\t\t} P p - length 1 hist .x 3 * / .001 + < ii #20 >= and when\n\t} iters times\n} runs times\n\nhist .yzw hist .x 1 - log * ->fragcolor\n*/\n\nfloat rand(float x) {\n\treturn sin(x * 123. + 17.) * sin(x * 69. + 49.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 P;\n\tvec3 C;\n\tvec4 hist;\n\tvec2 p = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.) * 2.;\n\thist = vec4(0., 0., 0., 0.);\n\tfor(int temp_7 = 0; temp_7 < 5; ++temp_7) {\n\t\tP = vec2(rand(iTime + p.x + (float(temp_7) + 1.) / 379.), rand(iTime * 17. + p.y + p.x + (float(temp_7) + 1.) / 417.));\n\t\tC = vec3(0., 0., 0.);\n\t\tfor(int temp_9 = 0; temp_9 < 50; ++temp_9) {\n\t\t\tfloat ci = floor(abs(rand(P.x * 673. + p.y * 319. + iTime * 417.)) * 5.);\n\t\t\tif(ci <= 0.) {\n\t\t\t\tP = vec2(P.x * vec3(-.30 * sin(iTime / 2.3), .82, -.90).x + P.y * vec3(-.30 * sin(iTime / 2.3), .82, -.90).y + vec3(-.30 * sin(iTime / 2.3), .82, -.90).z, P.x * vec3(-.11, -.23 * sin(iTime / 3.7), 0.).x + P.y * vec3(-.11, -.23 * sin(iTime / 3.7), 0.).y + vec3(-.11, -.23 * sin(iTime / 3.7), 0.).z);\n\t\t\t\tC = (C + vec3(1., 0., 0.)) / 2.;\n\t\t\t} else if(ci <= 1.) {\n\t\t\t\tP = sin(vec2(P.x * vec3(.24, -.79 * sin(iTime / 4.8), .73).x + P.y * vec3(.24, -.79 * sin(iTime / 4.8), .73).y + vec3(.24, -.79 * sin(iTime / 4.8), .73).z, P.x * vec3(.63, -.12, -.25 * sin(iTime / 9.7)).x + P.y * vec3(.63, -.12, -.25 * sin(iTime / 9.7)).y + vec3(.63, -.12, -.25 * sin(iTime / 9.7)).z));\n\t\t\t\tC = (C + vec3(0., 1., 0.)) / 2.;\n\t\t\t} else if(ci <= 2.) {\n\t\t\t\tP = vec2(P.x * vec3(.98 * sin(iTime), .69, -.27).x + P.y * vec3(.98 * sin(iTime), .69, -.27).y + vec3(.98 * sin(iTime), .69, -.27).z, P.x * vec3(-.70, .96, .57 * atan(iTime)).x + P.y * vec3(-.70, .96, .57 * atan(iTime)).y + vec3(-.70, .96, .57 * atan(iTime)).z) / length(vec2(P.x * vec3(.98 * sin(iTime), .69, -.27).x + P.y * vec3(.98 * sin(iTime), .69, -.27).y + vec3(.98 * sin(iTime), .69, -.27).z, P.x * vec3(-.70, .96, .57 * atan(iTime)).x + P.y * vec3(-.70, .96, .57 * atan(iTime)).y + vec3(-.70, .96, .57 * atan(iTime)).z));\n\t\t\t\tC = (C + vec3(0., 0., 1.)) / 2.;\n\t\t\t} else if(ci <= 3.) {\n\t\t\t\tvec2 macro_temp_4_i = vec2(P.x * vec3(-.13, -.27 * iTime, .19).x + P.y * vec3(-.13, -.27 * iTime, .19).y + vec3(-.13, -.27 * iTime, .19).z, P.x * vec3(.31, -.89 * iTime, .5).x + P.y * vec3(.31, -.89 * iTime, .5).y + vec3(.31, -.89 * iTime, .5).z);\n\t\t\t\tP = vec2(macro_temp_4_i.x * sin(4.) - macro_temp_4_i.y * cos(4.), macro_temp_4_i.x * cos(4.) + macro_temp_4_i.y * sin(4.));\n\t\t\t\tC = (C + vec3(1., 0., 1.)) / 2.;\n\t\t\t} else if(ci <= 4.) {\n\t\t\t\tvec2 macro_temp_5_i = vec2(P.x * vec3(.60, -.75 * iTime, -.84).x + P.y * vec3(.60, -.75 * iTime, -.84).y + vec3(.60, -.75 * iTime, -.84).z, P.x * vec3(-.45 * sin(iTime / 3.), .14, -.32).x + P.y * vec3(-.45 * sin(iTime / 3.), .14, -.32).y + vec3(-.45 * sin(iTime / 3.), .14, -.32).z);\n\t\t\t\tfloat var_9 = length(macro_temp_5_i) * 3.14159;\n\t\t\t\tP = vec2(sin(var_9), cos(var_9)) * atan(macro_temp_5_i.y, macro_temp_5_i.x);\n\t\t\t\tC = (C + vec3(0., 1., 1.)) / 2.;\n\t\t\t}\n\t\t\tif(length(P - p) < (1. / (hist.x * 3.) + .001) && temp_9 >= 20) {\n\t\t\t\thist = vec4(hist.x + 1., (hist.yzw / (length(P - p) / .01) + C) / 2.);\n\t\t\t}\n\t\t}\n\t}\n\tfragColor = vec4(hist.yzw * log(hist.x - 1.), 1.);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtsGzM","date":"1420331442","viewed":505,"name":"Fractal Flame 2","username":"daeken","description":"Another test of my fractal flame shader.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["fractal","flame","ifs","shaderforth"],"hasliked":0,"parentid":"","parentname":""}}