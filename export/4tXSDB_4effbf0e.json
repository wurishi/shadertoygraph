{"ver":"0.1","info":{"id":"4tXSDB","date":"1439336568","viewed":618,"name":"City of Mod","username":"squid","description":"Insane. Also, this is a scary city to drive in. Bloom is for if you have a really good graphics card. Inspired by: https://www.youtube.com/watch?v=-d2-PtK4F6Y","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarch","mod","bloom","city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\n//City of Mod by squid\n\n//I get 6.2fps in windowed mode with bloom on & 120steps + cars + background (ffx windows10 no angle, on R9 290X)\n//\t\t1.4fps same setup but with cars+background\n//#define BLOOM\n// for BLOOM_RAD, lower numbers work, but because of the lower radius, the bloom is less obvious\n#define BLOOM_RAD 8 \n\n//camera zoom for autorotate/mouse mode\n#define ZOOM 90.\n\n//time+mouse rotates camera\n// turn off but path off as well => mouse movment\n//#define CAMERA_AUTOROTATE\n\n//camera goes on a ride\n#define CAMERA_PATH\n\n#ifdef BLOOM\n//steps for bloom on\n#define STEPS 120\n#else\n//steps for bloom off\n#define STEPS 500\n#endif\n\n//turn on/off the cars\n#define CARS\n//turn on/off background+moon\n#define COOL_BACKGROUND\n\n#define GRADIENT_DELTA 0.5\n#define FUDGE_FACTOR 0.5\n#define COMPARE_FUDGE_FACTOR 0.2\n\n\n#define time iTime\n#define size iResolution\n\n#define MOD2 vec2(443.8975,397.2973)\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\n#define MOD4 vec4(443.8975,397.2973, 491.1871, 470.7827)\nfloat hash11(float p)\n{\n\tvec2 p2 = fract(vec2(p) * MOD2);\n    p2 += dot(p2.yx, p2.xy+19.19);\n\treturn fract(p2.x * p2.y);\n}\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * MOD2);\n    p += dot(p.xy, p.yx+19.19);\n    return fract(p.x * p.y);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * MOD3);\n   p3 += dot(p3.xyz, p3.yzx + 19.19);\n   return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\n\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n\nfloat hash13(vec3 p)\n{\n\tp  = fract(p * MOD3);\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3.zxy, p3.yxz+19.19);\n    return fract(vec3(p3.x * p3.y, p3.x*p3.z, p3.y*p3.z));\n}\nvec3 hash33(vec3 p)\n{\n\tp = fract(p * MOD3);\n    p += dot(p.zxy, p+19.19);\n    return fract(vec3(p.x * p.y, p.x*p.z, p.y*p.z));\n}\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx) * MOD4);\n    p4 += dot(p4.wzxy, p4+19.19);\n    return fract(vec4(p4.x * p4.y, p4.x*p4.z, p4.y*p4.w, p4.x*p4.w));\n}\n#ifdef COOL_BACKGROUND\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#endif\n\nvec2 opU(vec2 d1, vec2 d2) { return (d1.x<d2.x)?d1:d2; }\nvec3 opU( vec3 d1, vec3 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n#ifdef CARS\nvec3 cars(in vec3 p) {\n    float h1 = hash11(floor((p.x-6.8)/13.));\n    p.z += iTime*5. + h1*120.;\n    vec4 hh = hash41(floor(p.z/3.));\n    if(hh.x > .07) return vec3(9e9, 0., 0.);\n    p.x -= 6.7+sin(hh.y*6.)*.1;\n    p.x = mod(p.x, 13.) - (13.*.5);\n    p.z = mod(p.z, 3.) - 1.5;\n    p.y -= .15;\n    float m = 10.;\n    if(p.z > 0.23) m += 0.1;\n    else if(p.z < -0.23) m += 0.2;\n    vec3 r = vec3(\n        sdBox(p, vec3(0.08, 0.02, 0.2)), m, hh.z);\n    return r;\n}\n#endif\n\nvec3 building(in vec3 p, in vec2 id) {\n    vec3 hh = hash32(id);\n    if(hh.z > 0.5) return vec3(9e9,0.,0.);\n    vec4 hh2 = hash41(hh.z);\n    float height = ceil(4.+pow(hh.x,1.5)*(8.+pow(hh.x,30.)*5.));\n    vec2 ext = vec2(2.+pow(hh2.x,3.)*2.,2.+pow(hh2.y,3.)*2.);\n    vec3 o = vec3(sin(hh.y*5.)*2.,height,cos(hh.y*5.)*2.);\n\tfloat d = sdBox(p-o, vec3(ext.x,height,ext.y));\n    vec2 r = vec2(d, p.y>height*2. ? 7.5 : 7.);\n    if(hh2.z > .7) {\n        height+=1.;\n    \tr = opU(r, \n                vec2(sdBox(p-o-vec3(0.,height,0.), vec3(ext.x*.5, .5, ext.y*.5)),\n                    7.6));\n    }\n    if(height > 14.) {\n        r = opU(r, vec2(\n            sdSphere((p-o-vec3(ext.x*.2,height+2.,ext.y*.2))*4.5, 1.)\n            , 8. + sin(iTime*5.+hh2.z*8.) ));\n    }\n    return vec3(r,0.);\n}\n\nvec3 moon( in vec3 pos) {\n\tfloat d = length(pos-vec3(.2, .2, 1.)*(400. + iTime))-20.;\n    return vec3(d, 12., 0.);\n}\n\nvec3 map( in vec3 pos )\n{\n    const vec2 REP = vec2(13.);\n    vec2 rq = mod(pos.xz, REP)-0.5*REP;\n    vec2 id = floor(pos.xz/REP);\n    \n    float pmid = 0.;\n    if(abs(rq.x+REP.x*.5)-1. < .01 || abs(rq.y+REP.y*.5)-1. < .01) {\n    \tpmid = 9.;\n        if((abs((rq.x+REP.x*.5) - .5)*2.+ceil(sin(rq.y*6.))*.04 < .04) ||\n           (abs((rq.y+REP.y*.5) - .5)*2.+ceil(sin(rq.x*6.))*.04 < .04)) {\n        \tpmid += .1;\n        }\n    }\n   \tvec3 res = vec3(pos.y, pmid, 0.);\n\n    res = opU(res, building(vec3(rq.x, pos.y, rq.y), id));\n    \n    #ifdef CARS\n    res = opU(res, cars(pos));\n    res = opU(res, cars((pos-vec3(.6,0.,0.))*vec3(1.,1.,-1.) ));\n    res = opU(res, cars(pos.zyx));\n    res = opU(res, cars((pos.zyx-vec3(.6,0.,.0))*vec3(1.,1.,-1.) ));\n    #endif\n#ifdef COOL_BACKGROUND\n    res = opU(res, moon(pos));\n#endif   \n    return res;\n}\n\n\nfloat DE(vec3 p0)\n{\n    return map(p0).x;\n}\n\nvec2 DDE(vec3 p, vec3 rd){\n\tfloat d1=DE(p);\n\tfloat dt=GRADIENT_DELTA*log(d1+1.0);\n\tfloat d2=DE(p+rd*dt);\n\tdt/=max(dt,d1-d2);\n\treturn vec2(d1,FUDGE_FACTOR*log(d1*dt+1.0));\n}\n\nfloat rndStart(vec2 co){return fract(sin(dot(co,vec2(123.42,117.853)))*412.453);}\n\nmat3 lookat(vec3 fw,vec3 up){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,up));return mat3(rt,cross(rt,fw),fw);\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 eps = vec2(.001, 0.);\n    return normalize(vec3(\n        DE(p+eps.xyy) - DE(p-eps.xyy),\n        DE(p+eps.yxy) - DE(p-eps.yxy),\n        DE(p+eps.yyx) - DE(p-eps.yyx)));\n}\n\n\nfloat saturate(float v) { return clamp(v, 0.0,       1.0);       }\nvec2  saturate(vec2  v) { return clamp(v, vec2(0.0), vec2(1.0)); }\nvec3  saturate(vec3  v) { return clamp(v, vec3(0.0), vec3(1.0)); }\nvec4  saturate(vec4  v) { return clamp(v, vec4(0.0), vec4(1.0)); }\n\nvec3 ColorTemperatureToRGB(float temperatureInKelvins)\n{\n\tvec3 retColor;\n\t\n    temperatureInKelvins = clamp(temperatureInKelvins, 1000.0, 40000.0) / 100.0;\n    \n    if (temperatureInKelvins <= 66.0)\n    {\n        retColor.r = 1.0;\n        retColor.g = saturate(0.39008157876901960784 * log(temperatureInKelvins) - 0.63184144378862745098);\n    }\n    else\n    {\n    \tfloat t = temperatureInKelvins - 60.0;\n        retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));\n        retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));\n    }\n    \n    if (temperatureInKelvins >= 66.0)\n        retColor.b = 1.0;\n    else if(temperatureInKelvins <= 19.0)\n        retColor.b = 0.0;\n    else\n        retColor.b = saturate(0.54320678911019607843 * log(temperatureInKelvins - 10.0) - 1.19625408914);\n\n    return retColor*vec3(1.04,1.,1.);\n}\nvec3 mat_col(vec2 m, vec3 p) {\n    float id = m.x;\n    if(id == 0.) return vec3(0.01);\n    else if(id == 7.) {\n    \tvec3 ci = hash32(ceil(p.zy+p.xy));\n        return ci.x > 0.1 ? vec3(0.01*ci.y) : \n        \tColorTemperatureToRGB(2800.+ci.y*10000.) +\n                (ci.x < 0.01 ? vec3(0., .2, 0.) : vec3(0.));\n    } \n    else if(id == 7.6) return vec3(0.06, 0.5, 0.2)*0.01;\n    else if(id >= 8. && id < 9.) {\n        float t = max(0.,id-8.);\n        return vec3(1., .04, 0.)*2.*t;\n    } else if(id >= 9. && id < 10.) {\n        if(id == 9.1) return vec3(1., 1., 0.)*1.5;\n    \telse return vec3(.1);\n    }\n    else if(id >= 10. && id < 11.) {\n        if(id == 10.1) return vec3(1., 0.08, 0.);\n        else if(id == 10.2) return vec3(1., 1., .6);\n        \n    \treturn mix(vec3(0.01, 0.0, 0.), vec3(0., 0., 0.01), m.y);\n    } \n    #ifdef COOL_BACKGROUND\n    else if(id == 12.) {\n        float fn = pow(noise(p*0.2), .3);\n    \treturn vec3(1., 1., 0.8)*fn;\n    }\n    #endif\n    return vec3(0.);\n}\n\nvec3 compute_color(vec3 ro, vec3 rd, float t)\n{\n    vec3 p = ro+rd*t;\n    //vec3 nor = normal(p);\n    //vec3 ref = reflect(rd, nor);\n    \n    vec2 m = map(p).yz;\n    #ifdef COOL_BACKGROUND\n    if(m.x == 12.) {\n        vec3 n = normal(p);\n    \treturn mat_col(m,p) * pow(dot(n, vec3(0., 0., -1.)),2.);\n    }\n    #endif\n    return mat_col(m,p);\n\n\t/*vec3 f = vec3(0.);\n    //for(int i = 0; i < 1; ++i) {\n    vec3 l = normalize(vec3(0.5, .7, .3));\n   \n    \n    //float shd = calcSoftshadow(p, l, 10.);\n    float dif = clamp( dot( nor, l ), 0.0, 1.0 );\n   \tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n    \n    \n    vec3 v = vec3(0.);\n    v += .6*vec3(dif);//*shd;\n    v += .2*fre*vec3(.8, .7, .6);\n \tf += mat_col(m,p)*v;\n    //}\n    return f;*/\n}\n\n#ifdef COOL_BACKGROUND\nvec3 background(vec2 px, vec3 ro, vec3 rd) {\n    return vec3(0.05, 0., 0.2)*pow(.5-rd.y*.5, 4.);\n}\n#endif\n\nvec4 pixel(vec2 pxx)\n{\n    float pxl=4.0/size.y;//find the pixel size\n\n\t\n\t//position camera\n    vec2 m = iMouse.xy / size.xy;\n    m = length(m) < 0.05 ? vec2(100., 0.2) : m;\n    m.y += 0.2;\n    #ifndef CAMERA_PATH\n    float tim=\n        #ifdef CAMERA_AUTOROTATE\n        time*\n        #endif\n        0.08+(m.x)*5.;\n\tvec3 ro=vec3(cos(tim),0.5+(m.y)*2.-1.,sin(tim))*ZOOM;\n\tvec3 rd=normalize(vec3((2.0*pxx-size.xy)/size.y,2.0));\n\trd=lookat(-ro,vec3(0.0,1.0,0.0))*rd;\n    #else\n    float tim = time*0.08+(iMouse.x/size.x)*80.+100.;\n    vec3 ro=vec3(sin(tim)*2., 40.+sin(tim*.5)*30., tim*20.);\n    vec3 mp = map(ro);\n    if(mp.x < 0.01) {\n    \tro *= 1.4;\n    }\n   \tvec3 rd=normalize(vec3((2.0*pxx-size.xy)/size.y,2.0));\n\trd=lookat(ro+vec3(cos(tim*.1)*9000., -3000., 0.),vec3(0.0,1.,0.0))*rd;\n    #endif\n    //return vec4(background(pxx,ro,rd),1.);\n\t//ro=eye;rd=normalize(dir);\n\tvec3 bcol=vec3(1.0);\n\t//march\n\t\n\tfloat t=DDE(ro,rd).y*rndStart(pxx),d,od=1.0;\n    bool hit = false;\n\tfor(int i=0;i<STEPS;i++){\n\t\tvec2 v=DDE(ro+rd*t,rd);\n\t\td=v.x;\n\t\tfloat px=pxl*(1.0+t);\n\t\tif(d<px){\n            hit = true;\n            break;\n\t\t}\n\t\tod=d;\n\t\tt+=v.y;//d;\n\t\tif(t>1000.0)break;\n\t}\n    if(hit) {\n        vec3 c = compute_color(ro, rd, t);\n        return vec4(c, 1.);\n    } else {\n    \t#ifdef COOL_BACKGROUND\n        return vec4(background(pxx, ro, rd), 1.);\n        #endif\n        return vec4(0.);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec4 pxcolor = pixel(fragCoord.xy);\n    \n    #ifdef BLOOM\n    vec4 blurrd = pxcolor;\n    const float rd = 1.;\n    for(int i = 0; i < BLOOM_RAD; ++i) {\n    float rdd = rd*float(i);\n    blurrd += pixel(fragCoord.xy+vec2(0.,rdd));\n    blurrd += pixel(fragCoord.xy+vec2(0.,-rdd));\n    blurrd += pixel(fragCoord.xy+vec2(rdd,0.));\n    blurrd += pixel(fragCoord.xy+vec2(-rdd,0.));\n    blurrd += pixel(fragCoord.xy+vec2(rdd,rdd));\n    blurrd += pixel(fragCoord.xy+vec2(-rdd,-rdd));\n    blurrd += pixel(fragCoord.xy+vec2(rdd,-rdd));\n    blurrd += pixel(fragCoord.xy+vec2(-rdd,rdd));\n    }\n    blurrd /= (1.+8.*8.);\n    \n    const float I = 1.5;\n    const float T = 0.08;\n    vec4 hlt = clamp(blurrd-T,0.0,1.0)*1.0/(1.0-T);\n        \n    pxcolor = 1.0-(1.0-pxcolor)*(1.0-hlt*(I));\n    #endif\n    vec2 xy = (fragCoord.xy/size.xy);\n\tfloat v = .2 + 0.4*pow(50.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.7);\n    fragColor=pow(pxcolor*v+hash12(fragCoord.xy+iTime)*.005, vec4(1./2.2));\n\t\n} ","name":"","description":"","type":"image"}]}