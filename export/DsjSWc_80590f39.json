{"ver":"0.1","info":{"id":"DsjSWc","date":"1673347631","viewed":184,"name":"Raymarched Hopf Fibers","username":"gk3776","description":"Hopf fibration visualisation","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","topology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n// This work is licensed under GPLv3. See the details at https://github.com/Tsmith3776/GLSL-Hopf-Fibration/blob/main/LICENSE\n\n// This is a visualisation of the Hopf Fibration (https://en.wikipedia.org/wiki/Hopf_fibration).\n// For a set of points on the surface of the 2-sphere which lie on a plane parallel to its equator, each ring shown\n// is a stereographic projection of the fiber (a great circle on the 3-sphere) mapped to that point.\n// The points on the 2-sphere are revolving around the vertical axis whilst travelling up and down between the poles;\n// this produces the expansion and rotation of the projected fibers, revealing some of the fibration's structure...\n\n// Find a unit vector orthogonal to vectors v1, v2\nvec3 orth(vec3 v1, vec3 v2)\n{\n    return normalize(cross(v1,v2));\n}\n\n// Find the radius and center of a circle given 3 points on its circumference\n// https://math.stackexchange.com/questions/1076177/3d-coordinates-of-circle-center-given-three-point-on-the-circle\nvec4 p3toCircle(vec3 p1, vec3 p2, vec3 p3)\n{\n    vec3 cu = p2 - p1;\n    vec3 cv = p3 - p1;\n    float a = dot(cu, cu);\n    float b = dot(cv, cv);\n    float c = dot(cu, cv);\n    \n    float m = 1./(2.*(a*b - c*c));\n    float j = m * b * (a-c);\n    float k = m * a * (b-c);\n    \n    vec3 center = p1 + j*cu + k*cv;\n    \n    return vec4(center, length(center - p1));\n}\n\n// Signed distance to a torus\nfloat torusDist (vec3 p, vec2 r)\n{\n    float d = length(vec2(length(p.xy) - r.x, p.z));\n    return d - r.y;\n}\n\n// Given a point on S^2 and angle in radians, identify a point which lies on the fiber\n// yielded by the inverse Hopf map from S^2 to S^3 at that angle\nvec4 iHopf(vec3 p, float th)\n{\n    float st = sin(th);\n    float ct = cos(th);\n    vec4 v = vec4((1.+p.z)*ct, p.x*st - p.y*ct, p.x*ct + p.y*st, (1.+p.z)*st);\n    return (1./sqrt(2.*(1.+p.z))) * v;\n}\n\n// Stereographically project a given point in S^3 to R^3\nvec3 s3r3stereo(vec4 p)\n{\n    return (vec3(p.xyz)/(1.-p.w));\n}\n\n// Signed distance from a point to a fiber determined by a pair of orthogonal points on the fiber in S^3\nfloat fiberDist(vec3 p, vec4 q1, vec4 q2)\n{\n    // Project 3 non-colinear points on the fiber into R^3\n    vec3 p1 = s3r3stereo(q1);\n    vec3 p2 = s3r3stereo(-q1);\n    vec3 p3 = s3r3stereo(q2);\n    \n    // Find the center and radius of the projected fiber\n    vec4 circle = p3toCircle(p1,p2,p3);\n    vec3 c = circle.xyz;\n    float rad = circle.w;\n    \n    // Find the transformation from global coords to (orthonormal) ones with xy plane as the projected fiber plane\n    vec3 b1 = normalize(p1);\n    vec3 b2 = normalize(p3);\n    vec3 b3 = orth(b1,b2);\n    mat3 A = transpose(mat3(b1,b2,b3));\n    \n    // Query the SDF of a torus in fiber-aligned coordinates with the projected center and radius\n    vec3 po = A*p;\n    po += A*c;\n    \n    return torusDist(po, vec2(rad, 0.09));\n}\n\n\n// Signed distance from a point to the scene\nfloat sceneDist(vec3 p)\n{\n    p = p.yzx;\n    float ct = cos(iTime);\n    float st = sin(iTime);\n    vec3 p_ = normalize(vec3(ct, st, st-.5));\n    vec4 f1 = iHopf(p_, PI*.5);\n    vec4 f2 = iHopf(p_, PI);\n    float d = fiberDist(p, f1, f2);\n    \n    for(int i=1; i<8; i++) {\n        float a = float(i) * (.25*PI);\n        p_ = normalize(vec3( cos(a + iTime), sin(a + iTime), st-.5));\n        f1 = iHopf(p_, PI*.5);\n        f2 = iHopf(p_, PI);\n    \n        d = min(d, fiberDist(p, f1, f2));\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -.5 to .5)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    // Camera settings\n    vec3 cameraPos = vec3(uv,-5.);\n    vec3 cameraDir = normalize(vec3(uv,1.));\n\n    // Rendering settings\n    vec3 rayPos = cameraPos;\n    float minD = 1e-3;\n    float maxD = 10.;\n    int maxIters = 100;\n    float stepSize = sceneDist(rayPos);\n    \n    // Background colour\n    vec3 col = vec3(0.);\n\n    for (int i=0; i<maxIters; i++)\n    {\n        // March the ray to the closest point in the scene\n        rayPos += cameraDir * stepSize;\n\n        // Check for collision\n        float dist = sceneDist(rayPos);\n        if (dist < minD)\n        {\n            float d = length(cameraPos - rayPos);\n            col = vec3(1.-0.1*d);\n            break;\n        }\n        else if (dist > maxD)\n        {\n            break;\n        }\n\n        stepSize = dist;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}