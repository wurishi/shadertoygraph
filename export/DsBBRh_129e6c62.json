{"ver":"0.1","info":{"id":"DsBBRh","date":"1689444682","viewed":42,"name":"ShapeExample","username":"FancyShirt","description":"Reference: \nhttps://www.youtube.com/watch?v=f4s1h2YETNY&t=1135s&ab_channel=kishimisu","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["experiment"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sdCircle( vec2 p, float r) {\n    // p: canvas coordination\n    // r: Radius\n    return length(p) - r;\n}\n\nfloat sdTriangleIsosceles(vec2 p, vec2 q) {\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp(dot(p, q)/dot(q, q), 0.0, 1.0);\n    vec2 b = p - q*vec2(clamp(p.x/q.x, 0.0, 1.0), 1.0);\n    float s = -sign(q.y);\n    vec2 d = min (vec2(dot(a, a), s*(p.x*q.y - p.y*q.x)), \n                  vec2(dot(b, b), s*(p.y - q.y)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdPentagon( in vec2 p, in float r ) {\n    // r: size\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y)*.1*iTime;\n}\n\nvec3 palette( in float t )\n{\n    vec3 a = vec3(0.558, 0.5, 0.5);\n    vec3 b = vec3(0.5, 0.5, 0.5);\n    vec3 c = vec3(1.0, 1.0, 1.0);\n    vec3 d = vec3(-0.362, 0.528, 0.468);\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Constant variable.\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_refer = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n    vec2 uv = uv_refer;\n    \n    // Initialize the final color output to be black.\n    vec3 finalColor = vec3(0.0);\n    \n    // Using for-loop to creating repeating pattern for diversity.\n    float diversity_layers = 3.0;\n    for (float i = 0.; i < diversity_layers; i++) {\n        // To create the fraction of the pattern:\n        //    Scale the uv by a asymmetric value (1.5) to avoid the single-tone changes\n        //    and re-centered it by 0.5\n        uv = fract(uv * 1.75) - 0.5;\n\n        // The distance variable for referencing the distance to the center of the canvas\n        float dis = length(uv_refer);\n        \n        // Define the color and add time variance to it so the color's phase shifts overtime.\n        float palette_f = dis;   // Make the color changes depends on distance to the relative center.        \n        palette_f += .75*iTime;  // Add color changes shifting overtime.\n        palette_f += i*.4;       // Make the color changes for each iteration.\n        \n        vec3 col = palette(palette_f);\n\n        // Creating the shape (Hexagon)\n        float sharpness = 5.;    // The sharpness of the shape, the larger the sharper\n        float thickness = 5.;    // The greater the thinner\n        vec2 p = abs(uv);        // The distance reference    \n        p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n        p -= vec2(clamp(p.x, -k.z*sharpness, k.z*sharpness), sharpness);\n        \n        // Apply the x*exp(-x) function to create the tilted shape for variation.\n        float tilt_scale = .17;  //  The greater, the tilter\n        float len_p = length(p)*exp(-tilt_scale*length(uv_refer));\n        \n        // Create the desired shape\n        float shape = sin(len_p*sign(p.y)*thickness + iTime)/8.;\n\n        // Reverse the black and white color to form a neon light feeling\n        shape = abs(shape);\n        shape = 0.008/shape;  // Tuning the width of the edge.\n        \n        // Using pow(_, x) function to enhance/blur the contrast of the image\n        //    To blur: x < 1.0\n        //    To enhance: x > 1.0\n        shape = pow(shape, .8);\n\n        // Apply the color to the shape to finalColor for output\n        finalColor += col * shape;\n    }\n    \n    // Output to screen\n    fragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}