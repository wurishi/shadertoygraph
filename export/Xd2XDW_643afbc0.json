{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float DE(vec3 p, float pixsize) {\n    const vec3 p0 = vec3(-1,-1,-1);\n    const vec3 p1 = vec3(1,1,-1);\n    const vec3 p2 = vec3(1,-1,1);\n    const vec3 p3 = vec3(-1,1,1);\n\n    const int maxit = 15;\n    const float scale = 2.;\n    for (int i = 0; i < maxit; ++i) {\n        float d = distance(p, p0);\n        vec3 c = p0;\n        \n        float t = distance(p, p1);\n        if (t < d) {\n            d = t;\n            c = p1;\n        }\n        \n        t = distance(p, p2);\n        if (t < d) {\n            d = t;\n            c = p2;\n        }\n        \n        t = distance(p, p3);\n        if (t < d) {\n            d = t;\n            c = p3;\n        }\n        \n        p = (p-c)*scale;\n    }\n    \n    return length(p) * pow(scale, float(-maxit))\n        - pixsize; // let the leaves be one pixel in size\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float unit_pixsize = 1./(iResolution.x+iResolution.y);\n    \n    // camera parameters\n    vec3 origin = vec3(-4,mouse*2.-1.);\n    vec3 direction = normalize(vec3(1, uv*2.-1.));\n    \n    float ang1 = sin(iTime*0.9+42.)*2.+42.;\n    float ang2 = sin(iTime*1.1)*3.;\n    \n    mat3 rotation1 = mat3(\n        1,0,0,\n        0,cos(ang1),-sin(ang1),\n        0,sin(ang1),cos(ang1)\n    );\n    mat3 rotation2 = mat3(\n        cos(ang2),0,-sin(ang2),\n        0,1,0,\n        sin(ang2),0,cos(ang2)\n    );\n    mat3 rotation = rotation1 * rotation2;\n    \n    const float diameter = 100.;\n    const int maxit = 40;\n    const float eps = 1e-5;\n    \n    vec3 p = origin;\n    int it = maxit;\n    for (int i = 1; i <= maxit; ++i) {\n        if (dot(p, p) > diameter) {\n            it = i;\n            break;\n        }\n        float d = DE(rotation * p, unit_pixsize * distance(p, origin));\n        if (d < eps) {\n            it = i;\n            break;\n        }\n        p += direction * d;\n    }\n\n    if (it == 0)\n\t\tfragColor = vec4(.5, .5, .9, 1.0);\n    else {\n        float t = 1. - float(it) / float(maxit);\n        fragColor = vec4(t,t,t,1.0);\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xd2XDW","date":"1412140174","viewed":665,"name":"3d sierpinski triangle","username":"al13n","description":"Implementation of a simple example from http://blog.hvidtfeldts.net/index.php/2011/08/distance-estimated-3d-fractals-iii-folding-space/","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","distanceestimation"],"hasliked":0,"parentid":"","parentname":""}}