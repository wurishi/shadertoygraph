{"ver":"0.1","info":{"id":"mdfSWr","date":"1668705803","viewed":1013,"name":"Lost Monoliths","username":"kishimisu","description":"Control the time of the day with left/right mouse movements","likes":49,"published":1,"flags":32,"usePreview":1,"tags":["raymarching","terrain","volume","sdf","cloud","lighting","repetition","fog","scene","realistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \"Lost Monoliths\" by @kishimisu (2022) - https://www.shadertoy.com/view/mdfSWr\n   \n   This is my first attempt at creating a somewhat \"realistic\" scene.\n   \n   Control the time of the day with left/right mouse movements!\n   \n   Huge thanks to Inigo Quilez for all his informative and\n   helpful tutorials and the amazing video\n   \"Painting a Landscape with maths\" \n   (https://www.youtube.com/watch?v=BFld4EBO2RE)\n   which inspired me to create this scene.\n   \n   There are a lot of things that could be improved \n   but after too much tweaking I didn't want the code \n   to become a mess and was starting to hit performance \n   issues, so I decided to leave it as is and focus on \n   optimizing the performances. It still seem to be a \n   very demanding scene that suffer from some artefacts, \n   but I will do better next time!\n   \n   The mini-monoliths in the foreground hill slowly blend \n   into more of a tree shape and green color in order to \n   have only 1 distance computation for both elements.\n   \n   Finally the night lighting on the distant monoliths was\n   quickly added with 2 lines of code, so it's a bit glitchy\n   but I liked the effect.\n   \n   Visual or technical feedback is welcome!\n*/\n\nvoid mainImage(out vec4 O, vec2 F) {    \n    vec3 col = texelFetch(iChannel0, ivec2(F-0.5), 0).rgb;\n    col *= pow(smoothstep(1., 0., length(F/iResolution.xy-.5)), .4);\n    O = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MOTION_BLUR     10.\n#define MAX_ITERATIONS  100.\n#define EPSILON         0.03\n#define MAX_DIST        3e4\n#define VOLUME_STEPS    20.\n#define VOLUME_DENSITY  1.1\n#define VOLUME_LIGHT    0.007\n\n#define sunCycle (iMouse.z == 0. ? 1. : iMouse.x/iResolution.x*.9+.1)\n#define sunColor vec3(1.000,0.933,0.859)*(sunCycle*.9+.15)\n#define skyColor vec3(0.400,0.663,0.941)*(sunCycle*.9+.15)\nconst vec3 groundColor = vec3(0.616,0.498,0.361);\nconst vec3 grassColor  = vec3(0.114,0.353,0.047);\n\n#define rep(p,r)  (mod(p+r/2.,r)-r/2.)\n#define rid(p,r)  floor((p+r/2.)/r)\n#define rot(a)    mat2(cos(a), -sin(a), sin(a), cos(a))\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\nfloat smax( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// https://iquilezles.org/articles/boxfunctions/\nvec2 boxIntersection(in vec3 ro, in vec3 rd, in vec3 rad)  {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n\n// https://shadertoyunofficial.wordpress.com/2019/01/02/\nvec3 hash33(vec3 p) {\n    return fract(cos((p)*mat3(127.1,311.7,74.7,269.5,183.3,246.1,113.5,271.9,124.6))*43758.5453123);\n}\n\n// https://www.shadertoy.com/view/lsf3WH\nfloat hash(vec2 p) {\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\nfloat noise2(vec2 p) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// https://www.shadertoy.com/view/3ddGzn\nfloat noise3(vec3 p) {\n\tvec3 ip=floor(p), s=vec3(7, 157, 113);\n\tvec4 h=vec4(0, s.yz, s.y+s.z)+dot(ip, s);\n\tp-=ip; p=p*p*(3.-2.*p);\n\th=mix(fract(43758.5*sin(h)), fract(43758.5*sin(h+s.x)), p.x);\n\th.xy=mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\n// https://iquilezles.org/articles/fbm/\nfloat fbm2(vec2 p) {\n    p += 9.1;\n    float f = 1.0, a = 1.0,\n          t = noise2(p);\n    for(int i=1; i<8; i++) {\n        t += a*noise2(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\nfloat fbm3(vec3 p) { \n    float f = 1.0, a = 1.0,\n          t = noise3(p);\n    for(int i=1; i<5; i++) {\n        t += a*noise3(f*p);\n        f *= 2.0; a *= .5;\n    }\n    return t;\n}\n\n#define trep 50.\n#define tStep smoothstep(500., 1500., length(p.xz))\n#define forestNoise smoothstep(.4, .8, noise2(p.xz/1000.))\n\nfloat terrainHeight(vec3 p) {\n    vec3 q = p;\n    p.xz *= rot(.8);\n    float lmountain = 3000. * smoothstep( 12000., 8000., length(p.xz - 2.8*vec2(6000. , 1500.))  );\n    float rmountain = 3000. * smoothstep( 5000., 2000., length(p.xz - 2.8*vec2(1000. ,-3000.)) );\n    float valley    = 550. * smoothstep(2000., 0., abs(length(p.xz) - 2000.));\n    float terrainH  = 500.*fbm2(q.xz/1000.) + lmountain + rmountain - valley;\n    return terrainH;\n}\n\nvec2 map(vec3 p, inout vec3 light) {\n    // terrain\n    float terrainH  = terrainHeight(p);\n    float terrainFH = terrainHeight(floor((p+trep/2.)/trep)*trep);\n    float ground    = p.y - terrainH;\n    \n    // monoliths\n    vec3 sp = vec3(p.z + 190., p.y - mix(1100., terrainFH + 300., step(1400., length(p.xz))), p.x + 100.);\n    sp.xz = rep(sp.xz, 2800.);\n    float mono = sdBox(sp, vec3(10, 370, 40));\n    mono = smax(mono, -(length(sp.zy - vec2(0., 250.)) - 45.), 5.) - 10.;\n    mono *= .7;\n    \n    // monolith night lighting\n    float ld = length(sp - vec3(0., 250., 0.)) - 50.;\n    light += hash33(rid(p,2800.).xzz)*vec3(1.4,.5,1.6) / (1. + pow(abs(ld*.4), 1.1));\n    \n    // repeated shapes\n    vec3 fid = rid(p, trep); fid.y = 0.;\n    vec3 fn = hash33(fid);\n    vec3 fp = rep(p, trep); \n    fp.y = p.y - terrainFH;\n    \n    float hv = fn.z*400.*smoothstep(600., 200., p.y);\n    float cr = mix(15. + fn.y*10., (fn.y*10.+15.) * (smoothstep(80., 0., p.y - terrainFH)+.4), tStep) * .8;\n    float ch = mix(60. + hv, fn.x*150., tStep) - forestNoise*200.*tStep;\n    float shape = sdCylinder(fp + 1.*vec3(cr,0.,cr)*(fn.yxz-.5)*tStep, cr, ch) - 2.;\n    shape *= .4;\n    \n    vec2 res = vec2(ground, 0.);\n    \n    if (shape < res.x) res = vec2(shape, 1.);\n    if (mono  < res.x) res = vec2(smin(res.x, mono, 30.), 2.); \n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 getNormal(vec3 p) {\n    vec3 l;\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.01;\n    return normalize(e.xyy*map(p + e.xyy, l).x + e.yyx*map(p + e.yyx, l).x + \n\t\t\t\t\t e.yxy*map(p + e.yxy, l).x + e.xxx*map(p + e.xxx, l).x);\n}\n\n// https://iquilezles.org/articles/rmshadows/\nfloat getShadow(vec3 ro, vec3 rd, float maxt) {\n    vec3 l;\n    float t = 0., res = 1., k = 140.;\n    for (float i = 0.; i < MAX_ITERATIONS*.8; i++) {\n        vec3 p = ro + t*rd;\n        float d = map(p, l).x;\n        res = min(res, k*d/t);\n        t += d;\n        if (t > maxt || d < EPSILON) return res;\n    }\n    return 0.;\n}\n\nvec3 volumeColor(vec3 ro, vec3 rd, float near, float far, float bh, vec3 col) {\n    vec3 vcol  = vec3(0.);\n    float mask = 1.;\n    float vstep = (far - near + hash33(ro).x*.01) / VOLUME_STEPS;\n    const float dh = 1./VOLUME_DENSITY;\n\n    for (float t = near, i = 0.; t <= far && i < VOLUME_STEPS; t += vstep, i++) {\n        vec3 p = ro + t*rd;\n        \n        float dens = fbm3(p/400. + vec3(iTime*.3, iTime*.1, 0.));\n        dens = 0.1 * smoothstep(dh, dh+1., dens) * smoothstep(bh*2., bh, p.y) * smoothstep(4000., 2500., length(p.xz))  + \n               4.0 * smoothstep(bh*4.1, 0., length(p + vec3(0.,bh*2.,0.)));\n        \n        float prev = mask;\n        mask *= exp(-dens * vstep * .03);\n        float absorbed = prev - mask;\n        \n        vec3 light = mix(vec3(.05,.1,.08), sunColor, smoothstep(150., bh, p.y));\n        vcol += vec3(.9, .97, .92) * absorbed * vstep * light * VOLUME_LIGHT;          \n    }\n    \n    return col*mask + min(vcol, vec3(1.));\n}\n\nvoid initRayOriginAndDirection(vec2 uv, inout vec3 ro, inout vec3 rd) {\n    float t = iTime*.2;\n    ro = vec3(-100., 1370., 700.);\n    ro.yz *= rot(cos(t)*.05);\n    ro.zx *= rot(sin(t)*.2);\n    vec3 f = normalize(vec3(20.*cos(t),1200.+cos(t)*10.,20.*sin(t))-ro), \n         r = normalize(cross(vec3(0,1,0), f));\n    rd = normalize(f + uv.x*r + uv.y*cross(f, r));\n}\n    \nvoid mainImage(out vec4 O, in vec2 F) {\n    vec2 d, uv = (2.*F - iResolution.xy)/iResolution.y;\n    vec3 p, ro, rd, col, light;\n    float t = 0.;\n\n    initRayOriginAndDirection(uv, ro, rd);\n    \n    // raymarch to the closest point\n    for (float i = 0.; i < MAX_ITERATIONS; i++) {\n        p = ro + t*rd;\n        d = map(p, light);\n        t += d.x > 0. ? d.x : d.x*.5;\n        if (abs(d.x) < EPSILON || t > MAX_DIST) break;\n    }\n    \n    float phi = 0.32 * 6.28, the = 0.22 * 3.14 + 1.27 - (1.-sunCycle)*.7;\n    vec3 lightDir = normalize(vec3(sin(the)*sin(phi), cos(the), sin(the)*cos(phi)));\n        \n    if (t < MAX_DIST) {\n        // hit object\n        vec3  n = getNormal(p);  \n        float tex = texture(iChannel0, p.xy/200.).b * .5 + .5;\n        float th  = terrainHeight(p);\n        float sunLight    = max(0., dot(n, -lightDir));   \n        float sunShadow   = max(.1, getShadow(p + n*EPSILON*8., -lightDir, MAX_DIST*.3));\n        float bounceLight = max(0., dot(n, lightDir));\n        float skyLight    = n.y*.5+.5;\n\n        if (d.y == 0.) {\n            // terrain\n            col = mix(groundColor, grassColor, smoothstep(.5, .65, n.y));\n            col *= forestNoise+.1;\n        } else if (d.y == 1.) {\n            // surface structures & trees\n            float occ = smoothstep(0., 40., p.y - th);\n            float spec = mix(pow(1. - clamp(dot(n, -rd), 0., 1.), 3.), 0., tStep);\n            col = mix(vec3(2.), hash33(vec3(rid(p, trep).xz, 0.))*vec3(.3,.5,.7) + vec3(0,.5,0), tStep);\n            col *= occ * tex;\n            col += 2. * spec * skyColor;    \n        } else {\n            // monoliths\n            float occ = smoothstep(0., 200., p.y - th + 30.);\n            col = vec3(2.) * tex * occ;\n        }\n        \n        // scene lighting\n        col *= 0.9*sunLight*sunColor;\n        col *= 1.0*sunShadow;\n        col += 0.1*skyLight*skyColor;\n        col += 0.1*bounceLight*groundColor;  \n    }\n    \n    // volume rendering\n    const float bh = 450.;\n    vec2 hit = boxIntersection(ro - vec3(0, bh, 0), rd, vec3(3500., bh, 3500.));\n    if (hit.x > 0. && hit.x < t) {\n        col = volumeColor(ro, rd, hit.x, min(hit.y, t), bh, col);\n    }\n    \n    // final lighting\n    vec3 fog = exp2(-t*0.00009*vec3(1,1.8,4)); \n    col = mix(clamp(skyColor - abs(rd.y)*.7, vec3(0.), vec3(1.)), col, fog);\n    \n    float glare = max(0., dot(rd, -lightDir));\n    col += pow(glare, 4.) * sunColor;\n\n    col = pow(col, vec3(.8, .85, 1.));\n    col = smoothstep(0., 1., col);\n    \n    // gamma correction\n    col = pow(col, vec3(.4545));\n    \n    // applying more lights after gamma correction is a bad practice\n    // but I liked the result for this specific case\n    col += light * smoothstep(.7, 0., sunCycle);\n\n    // accumulate frames\n    vec3 ocol = texelFetch( iChannel1, ivec2(F-0.5), 0 ).xyz;\n    if(iFrame==0) ocol = col;\n    col = mix(ocol, col, 1./MOTION_BLUR);\n    O = vec4(col, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}