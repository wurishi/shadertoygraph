{"ver":"0.1","info":{"id":"XdfBR7","date":"1495225158","viewed":388,"name":"BoxJump","username":"dila","description":"Simple jumping box animation sequence :)","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float x) {\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{ /* iq's box distance */\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat jump(float t) {\n    /* simple quadratic curve */\n    return t * (1.0 - t) * 4.0;\n}\n\nvec3 tuv = vec3(0.0);\nfloat mat = 0.0;\n\nfloat map(vec3 p) {\n    float bs = 1.0;\n    float be = 0.1;\n    \n    float al = 3.0;\n    \n    float ut = iTime * 0.25;\n    float gt = fract(ut) * 4.0;\n    float t1 = clamp(gt, 0.0, 1.0);\n    float t2 = clamp(gt - 1.0, 0.0, 1.0);\n    float t3 = clamp(gt - 2.0, 0.0, 1.0);\n    float t4 = clamp(gt - 3.0, 0.0, 1.0);\n    \n    float md = bs * 1.5; /* horizontal move dist */\n    \n    p.x += smoothstep(0.0, 1.0, t1) * al * md;\n    p.x += smoothstep(0.0, 1.0, t3) * al * md;\n    \n    float x1 = (t1 + t4) * al * md;\n    float x2 = (t2 + t3) * al * md;\n    \n    float h1 = bs * 2.0 * (1.0 - t1 + t4);\n    float h2 = bs * 2.0 * (t2 - t3);\n    \n    h1 += (jump(t1) + jump(t4)) * 4.0;\n    h2 += (jump(t3) + jump(t2)) * 4.0;\n    \n    p.y += (h1 + h2) * 0.5;\n    \n\tfloat g = p.y;\n    \n    vec3 p1 = vec3(x1, bs + h1, 0.0);\n    vec3 p2 = vec3(x2, bs + h2, 0.0);\n    \n    vec3 c1 = p - p1;\n    vec3 c2 = p - p2;\n    \n    c1.xy *= rot((t1 + t4) * -3.141592 * 2.0);\n    c2.xy *= rot((t2 + t3) * -3.141592 * 2.0);\n    \n    c1.xz *= rot(0.6 + (t1 + t4) * 3.141592);\n    c2.xz *= rot(1.1 + (t2 + t3) * 3.141592);\n    \n    float b1 = udRoundBox(c1, vec3(bs - be), be);\n\tfloat b2 = udRoundBox(c2, vec3(bs - be), be);\n    \n    float d = g;\n    mat = 0.0;\n    tuv = p;\n    tuv.x -= floor(ut);\n    \n    if (b1 < d) { /* box1 is closer? */\n        d = b1;\n        mat = 1.0;\n        tuv = c1;\n    }\n    \n    if (b2 < d) { /* box2 is closer? */\n        d = b2;\n        mat = 2.0;\n        tuv = c2;\n    }\n    \n    float sky = 100.0 - p.y;\n    if (sky < d) { /* upper skybox */\n        d = sky;\n        mat = 0.0;\n        tuv = p;\n    }\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t);\n    }\n    return t;\n}\n\nvec3 texup(vec3 p) {\n    vec3 ta = texture(iChannel0, p.yz).xyz;\n    vec3 tb = texture(iChannel0, p.xz).xyz;\n    vec3 tc = texture(iChannel0, p.xy).xyz;\n    return (ta * ta + tb * tb + tc * tc) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.2 - dot(uv,uv) * 0.2));\n    \n    mat2 ryz = rot(3.141592 * -0.1);\n    float rt = iTime * -0.5;\n    \n    r.xy *= rot(sin(iTime) * 0.3);\n    \n    r.yz *= ryz;\n    r.xz *= rot(rt);\n    \n    vec3 o = vec3(0.0, 2.0, -6.0 - abs(sin(rt)) * 2.0);\n    o.yz *= ryz;\n    o.xz *= rot(rt);\n    \n    float t = trace(o, r);\n    vec3 w = o + r * t;\n    vec3 sn = normal(w);\n   \n    vec3 tex = texup(tuv * 1.0); \n    if (mat == 0.0) {\n        tex = texture(iChannel1, tuv.xz * 0.1).xyz;\n        tex *= tex;\n    }\n    \n    float aoc = map(w + sn * 1.4);\n    float fd = map(w);\n    float f = 1.0 / (1.0 + t * t * 0.0005);\n    \n    vec3 lpos = o + vec3(0.5);\n    vec3 ldel = w - lpos;\n    vec3 ldir = normalize(ldel);\n    float lprod = max(dot(ldir, -sn), 0.0);\n    vec3 refv = reflect(r, -sn);\n    \n    vec3 sky = texture(iChannel2, r).xyz;\n    vec3 ref = texture(iChannel2, refv).xyz;\n    float fres = max(dot(sn, -r), 0.0);\n    fres = 1.0 - pow(1.0 - fres, 2.0);\n    ref = mix(ref, vec3(0.0), fres);\n    \n    if (mat == 0.0) {\n        ref = vec3(0.0);\n    }\n    \n    vec3 fc = tex * aoc * f * lprod;\n    fc += ref * mix(0.25, 1.0, aoc) * f * lprod;\n    \n    fc += sky * (1.0 - f);\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}