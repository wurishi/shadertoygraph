{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"vec2 uv;\n//float time = iTime;\n\nvec4 sphere1 = vec4(0.0,-0.1,0.0,0.1);\t\t\t\t\t\t\nvec3 sphere1Color = vec3(1.0, 0.0, 0.0);\n\t\nvec4 sphere2 = vec4(0.0,0.2,0.0,0.1);\t\t\t\t\t\t\nvec3 sphere2Color = vec3(0.0, 1.0, 0.0);\n\nvec4 sphere3 = vec4(0.0,-0.2,0.2,0.1);\t\t\t\t\t\t\nvec3 sphere3Color = vec3(0.0, 0.0, 1.0);\t\n\t\nvec3 lightDir = normalize( vec3(0.5, 0.5, 0.5) );\nvec3 bgColor = vec3(0.2, 0.2, 0.2);\n\nvec3 ambient = vec3(0.5, 0.1, 0.1);\n\n\nfloat maxDist = 1024.0;\n\nstruct face{\n\tvec4 stats;\n};\n\nstruct cube{\n\n\tface faces[6];\n}cube1;\n\n// ro is the ray origin, rd is the ray direction, and s is the sphere\nfloat sphereInter( vec4 ro, vec3 rd, vec4 s ) {\n    // Transform the ray into object space\n    vec3 oro =  ro.xyz - s.xyz ;\n\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oro, rd);\n    float c = dot(oro, oro) - s.w * s.w; // w is the sphere radius\n\n    float d = b * b - 4.0 * a * c;\n\n    if(d < 0.0) return d; // No intersection\n    \n    return (-b - sqrt(d)) / 2.0;\n}\n\nvec3 sphereNorm( vec3 pt, vec4 s ) {\n    return (pt - s.xyz )/ s.w;\n}\n\nfloat intersect( vec4 ro, vec3 rd, vec4 s,vec3 sc,out vec3 norm, out vec3 color ) {\n    float dist = maxDist;\n\n    float interDist = sphereInter( ro, rd, s ); \n\t\n\tvec3 pt = ro.xyz + interDist * rd;\t\n\t\n\tif ( interDist > 0.0 && interDist < dist ) {\n        dist = interDist;\n\n        vec3 pt = ro.xyz + dist * rd; // Point of intersection\n        norm = sphereNorm(pt, s); // Get normal for that point\n        color = sc; // Get color for the sphere\n    }\n\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tuv = fragCoord.xy / iResolution.xy;\n    float time = iTime;\n\tfloat  fl= 40.0;\n    \n    // Wiggle the sphere back and forth a bit\n    sphere1.x = 0.1 * sin(time);\n    sphere1.z = 0.1 * cos(time * 3.0);\n\t\n\tsphere2.x = 0.2*(sin(time) - cos(time));\n\tsphere2.y = 0.1*(cos(time) - sin(time))-0.2;\n\tsphere2.z = 2.1*(cos(time) - sin(time));\n\t\n\tsphere3.x = 0.1*( -1.0*cos(time) -sin(time));\n\tsphere3.y = 0.1*(sin(time) +cos(time));\n\tsphere3.z = 3.1*(sin(time) - cos(time));\n\t\n    \n    // Cast a ray out from the eye position into the scene\n    vec4 ro = vec4(0.2*sin(time), 0.0, fl,1);\n    vec4 rd = normalize(vec4(uv.x-0.5,0.5-uv.y,-fl,0));\n    \n    vec3 rayColor = bgColor; \n    vec3 objNorm, objColor;\n    float t;\n\t\n\tvec3 objNorm1, objColor1;\n\tvec3 objNorm2, objColor2;\n\tvec3 objNorm3, objColor3;\n\t\n\tfloat t1 = intersect(ro, rd.xyz,sphere1,sphere1Color, objNorm1, objColor1);\n    float t2 = intersect(ro, rd.xyz,sphere2,sphere2Color, objNorm2, objColor2);\n\tfloat t3 = intersect(ro, rd.xyz,sphere3,sphere3Color, objNorm3, objColor3);\n\n    mat4 inverseMatrix = mat4(1.,0.0,0.0,0.0, 0.0,cos(time),sin(time),0.0, 0.,-sin(time),cos(time),0.0, 0.2,0.2,0.2,0.2);\n\n\t\n\tcube1.faces[0].stats =vec4(1.0,0,0,-0.3)*inverseMatrix; \n\tcube1.faces[1].stats =vec4(-1.0,0,0,-0.3)*inverseMatrix;\n\tcube1.faces[2].stats =vec4(0,1.0,0,-0.3)*inverseMatrix;\n\tcube1.faces[3].stats =vec4(0,-1.0,0,-0.3)*inverseMatrix;\n\tcube1.faces[4].stats =vec4(0,0,1.0,-0.3)*inverseMatrix;\n\tcube1.faces[5].stats =vec4(0,0,-1.0,-0.3)*inverseMatrix;\n\t\n\tfloat tmin =-102400.0;\n\tfloat tmax =102400.0;\n\tint  minface=0,maxface=-1;\n\tvec3 faceNorm;\n\tfor( int i=0;i<6;i++){\n\t\t\n\t\tfloat lw = dot(rd,cube1.faces[i].stats );\n\t\tfloat lv = dot(ro,cube1.faces[i].stats );\n\t\tif(lw < 0.0){\n\t\t\tfloat t = -1.0*lv/lw;\n\t\t\tif(t>tmin){\n\t\t\t\ttmin = t;\n\t\t\t\tminface = i; \n\t\t\t\tfaceNorm = vec3(cube1.faces[i].stats.xyz);\n\t\t\t}\n\t\t}\n\t\tif(lw > 0.0){\n\t\t\tfloat t = -1.0*lv/lw;\n\t\t\tif(t<tmax){\n\t\t\t\ttmax = t;\n\t\t\t\tmaxface=i;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\tvec3 objColorCube= vec3(1.0,0.5,0.0);\n\tvec3 faceNormm = normalize(faceNorm);\n\t\n\tif(tmin<tmax){\n\t\t\n\t\tif(tmin<t1 && tmin<t2 && tmin<t3){\n\t\t\tt=tmin;\n\t\t\tobjNorm=faceNormm;\n\t\t\tobjColor=objColorCube;\n\t\t}\n\t}\n\telse{\n\t\n\tif(t1<t2){\n\t\tif(t1<t3){\n\t\t\tt= t1;\n\t\t\tobjNorm= objNorm1;\n\t\t\tobjColor= objColor1;\n\t\t}\n\t\telse{\n\t\t\tt= t3;\n\t\t\tobjNorm= objNorm3;\n\t\t\tobjColor= objColor3;\n\t\t}\n\t}\n\telse{\n\t\tif(t2<t3){\n\t\t\tt= t2;\n\t\t\tobjNorm= objNorm2;\n\t\t\tobjColor= objColor2;\n\t\t}\n\t\telse{\n\t\t\tt= t3;\n\t\t\tobjNorm= objNorm3;\n\t\t\tobjColor= objColor3;\n\t\t}\n\t}\t\n\t}\n\t\n\t// Cast a ray out from every point towards the light source to form shadows\n    //vec3 shadOr = vec3(0.0, 0.0, fl);\n\n   // vec3 shadDir = normalize(vec3(uv.x-0.5,0.5-uv.y,-fl));\n\n    if ( t < maxDist ) {\n        float diffuse = clamp(dot(objNorm, lightDir), 0.0, 1.0); // diffuse factor\n        rayColor = objColor * diffuse + ambient;\n    } \n    \n    fragColor = vec4(rayColor, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdlGDf","date":"1380866848","viewed":211,"name":"3 balls and a cube","username":"shaqal","description":"3 balls in their own paths. The cube tries to catch them and fails everytime!! Haha.. maybe someday it will.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","cube","sphere","animated","ambient"],"hasliked":0,"parentid":"","parentname":""}}