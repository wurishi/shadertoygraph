{"ver":"0.1","info":{"id":"mlf3zB","date":"1671935241","viewed":68,"name":"tut6","username":"jfwf","description":"study test","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["tut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MATCHING_STEP=255;\nconst float MIN_DIST=0.0;\nconst float MAX_DIST=100.0;\nconst float PRECISION=0.001;\n\n\nvec4 sdSphere(vec3 p,float r,vec3 offset,vec3 col)\n{\n    float d=length(p - offset)-r;\n    return vec4(d,col);\n}\n\nvec4 sdFloor(vec3 p,vec3 col)\n{\n    float d= p.y - (-1.0) ;\n    return vec4(d,col);\n}\n\nvec4 minWithColor(vec4 obj1,vec4 obj2)\n{\n    if(obj2.x < obj1.x ) return obj2;\n    return obj1 ;\n}\n\n\nvec4 sdScene(vec3 p)\n{\n    vec4 d1=sdSphere(p,1.0 , vec3(-2.5,0.0,-2.0) , vec3(1.0,0.0,0.0) );\n    vec4 d2=sdSphere(p,1.0 , vec3( 2.5,0.0,-2.0) , vec3(0.0,1.0,0.0) );\n    vec4 res=minWithColor(d1,d2);\n    \n    vec3 floorColor=vec3( 0.7*mod(floor(p.x)+floor(p.z),2.0) ) ;\n    \n    res=minWithColor(res,sdFloor(p, floorColor));\n    \n    return res;\n}\n\n\nvec3 calNormal(vec3 p)\n{\n    float e=0.0005;//epsilon\n    float r=1.0;//radius of sphere\n    float dfx= sdScene( vec3(p.x+e,p.y,p.z) ).x - sdScene( vec3(p.x-e,p.y,p.z) ).x ;\n    float dfy= sdScene( vec3(p.x,p.y+e,p.z) ).x - sdScene( vec3(p.x,p.y-e,p.z) ).x ;\n    float dfz =sdScene( vec3(p.x,p.y,p.z+e) ).x - sdScene( vec3(p.x,p.y,p.z-e) ).x ;\n    return normalize( vec3(dfx,dfy,dfz) ) ;\n}\n\n\n\nvec4 rayMarch(vec3 ro,vec3 rd,float start,float end)\n{\n    float depth=start;\n    vec4 co;\n    for(int i=0;i<MAX_MATCHING_STEP;++i)\n    {\n        vec3 p=ro+depth*rd;\n        co = sdScene(p);\n        depth+=co.x;\n        if(co.x<PRECISION||depth>end) break;\n    }\n    return vec4(depth, co.yzw);\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5 ;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    \n    vec3 lightPosition=vec3( cos(iTime*2.0)*4.0, 2.0 ,4.0*sin(iTime*2.0) ) ;\n\n    vec3 col = vec3(0.);\n    \n    \n    //ray origin\n    vec3 ro = vec3(0.,0.,3.);\n    \n    //ray direction\n    vec3 rd=normalize(vec3(uv.x,uv.y,-1));\n    \n    vec4 d=rayMarch(ro,rd,MIN_DIST,MAX_DIST);\n    \n    if(d.x>MAX_DIST) {\n        col=vec3(0.6);//do not hit anything\n    }else{\n        //on the sphere surface\n        vec3 p=ro+rd*d.x ;\n        vec3 norm=calNormal(p) ;\n        vec3 lightDirection=normalize(lightPosition-p) ;\n        float dif = clamp( dot(norm,lightDirection), 0.3, 1.0) ;\n        col=vec3(dif)*d.yzw;\n    }\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}