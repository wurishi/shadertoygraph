{"ver":"0.1","info":{"id":"3lBSRc","date":"1566760704","viewed":210,"name":"A E S T H E T I C","username":"clevijoki","description":"Going off on a ray traced reflection tangent while following the iq shader deconstruction video.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float MAT_SKY = 1.0;\nconst float MAT_FLOOR = 2.0;\nconst float MAT_WHITE = 3.0;\nconst float MAT_RED = 4.0;\nconst float MAT_GREEN = 5.0;\nconst float MAT_BLUE = 6.0;\nconst float MAT_COLUMN = 7.0;\n\nvec2 PixelCoords(in vec2 fragCoord) {\n    \n    return (2.0 * fragCoord-iResolution.xy) / iResolution.y;\n}\n\nfloat Noise( in vec2 f ) {\n    \n    vec2 p = floor(f);\n    f = fract(f);\n    f = f*f*(3.0-2.0*f);\n    float res = textureLod(iChannel0, (p+f+.5)/256.0, 0.0).x;\n    return res;\n}\n\n\nvec3 CreateRayDir(in vec3 ray_origin, in vec3 look_at, in vec2 pixel) {\n    \n    vec3 z = normalize(look_at - ray_origin);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    return normalize(pixel.x*x + pixel.y*y + 1.5*z);\n}\n\nvec3 ApplyGamma(in vec3 col) {\n\treturn pow(col, vec3(0.4545));\n}\n\nvec2 MapSphere(in vec3 sample_pos, in vec3 pos, in float radius, in float material, in vec2 res) {\n\n    float d = length(sample_pos - pos)-radius;\n    if (d < res.x)\n        return vec2(d, material);\n    \n    return res;\n}\n\nvec2 MapColumn(in vec3 sample_pos, in vec3 pos, in float radius, in float height, in float material, in vec2 res) {\n    \n    float col_y = clamp(sample_pos.y, pos.y, pos.y+height);\n        \n    float spiral_speed = 60.0;\n\n    float d = length((sample_pos - vec3(pos.x, col_y, pos.z))*vec3(1.0,10.0,1.0))-radius;\n    \n    if (d < res.x)\n        return vec2(d, material);\n    \n    return res;\n}\n\nvec2 MapScene(in vec3 pos) {\n    \n    const float DEG_TO_RAD = 3.14159/180.0;\n    const vec3 ORBIT_A = normalize(vec3(sin(DEG_TO_RAD*  0.0), 2.5, cos(DEG_TO_RAD*  0.0)));\n    const vec3 ORBIT_B = normalize(vec3(sin(DEG_TO_RAD*120.0), 2.5, cos(DEG_TO_RAD*120.0)));\n    const vec3 ORBIT_C = normalize(vec3(sin(DEG_TO_RAD*240.0), 2.5, cos(DEG_TO_RAD*240.0)));\n    \n\tconst float ORBIT_DIST = 0.52;\n    const float ORBIT_SPEED = 0.6;\n    \n    float time_a = (iTime + 3.14159*1.0) * ORBIT_SPEED;\n    float time_b = (iTime + 3.14159*2.0) * ORBIT_SPEED;\n    float time_c = (iTime + 3.14159*3.0) * ORBIT_SPEED;\n    \n    float plane_d = pos.y + 0.25;\n//    float tile_d = 0.2*clamp(sin(pos.x*10.0)*sin(pos.z*10.0)*3.0+0.05, 0.01, 0.2);    \n//    plane_d -= max(0.0, tile_d) * 0.1;\n    vec2 res = vec2(plane_d, MAT_FLOOR);\n    \n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1 + sin(iTime)*0.05, 0.0),\n        0.25,\n        MAT_WHITE,\n        res);\n    \n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1, 0.0) + \n        \tORBIT_A.yzx * ORBIT_DIST * sin(time_a) +\n        \tORBIT_A.zxy * ORBIT_DIST * cos(time_a),\n        0.1,\n        MAT_RED,\n        res);\n\n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1, 0.0) +\n        \tORBIT_B.yzx * ORBIT_DIST * sin(time_b) +\n        \tORBIT_B.zxy * ORBIT_DIST * cos(time_b),\n        0.1,\n        MAT_GREEN,\n        res);\n        \n    res = MapSphere(\n        pos,\n        vec3(0.0, 0.1, 0.0) +\n        \tORBIT_C.yzx * ORBIT_DIST * sin(time_c) +\n        \tORBIT_C.zxy * ORBIT_DIST * cos(time_c),\n        0.1,\n        MAT_BLUE,\n        res);\n    \n    res = MapColumn(\n        vec3(mod(pos.x*0.5, 1.0)-0.5, pos.y, mod(pos.z, 1.0)-0.5),\n        vec3(\n            0.0,\n            -0.4,\n            0.0\n        ),\n        0.04,\n        1.0,\n        MAT_COLUMN,\n        res);    \n       \n    return res;\n}\n\nvec3 CalcNormal(in vec3 pos) {\n\t\n    vec2 e = vec2(0.0001, 0.0);\n    \n    return normalize(\n        vec3(\n\t        MapScene(pos+e.xyy).x-MapScene(pos-e.xyy).x,\n   \t    \tMapScene(pos+e.yxy).x-MapScene(pos-e.yxy).x,\n    \t    MapScene(pos+e.yyx).x-MapScene(pos-e.yyx).x\n    \t)\n   \t);\n}\n\nvec2 CastRay(in vec3 ray_origin, vec3 ray_dir) {\n\n    vec2 res = vec2(0.0, -1.0);\n    float t = 0.0;\n    \n    for (int i = 0; i < 400; ++i) {\n        \n        vec3 pos = ray_origin + t * ray_dir;\n        \n        vec2 h = MapScene(pos);\n        \n        if (h.x < 0.001)\n            return vec2(t, h.y);\n        \n        t += h.x;\n        \n        if (t>20.0)\n            return vec2(-1.0, MAT_SKY);\n    }\n        \n    return vec2(t, MAT_SKY);\n}\n\nfloat CalcCloud(in vec3 ray_origin, vec3 ray_dir) {\n    if (ray_dir.y < 0.01)\n        return 0.0;\n    \n    vec3 cloud_pos = ray_origin + ray_dir * ((10.0-ray_origin.y)/ray_dir.y);\n    cloud_pos.xz += vec2(iTime*2.0);\n    float cloud_color = 0.0;\n\n    cloud_color += Noise((cloud_pos.xz+vec2(iTime*2.0))*0.1) * 0.2;\n    cloud_color += mix(-1.0, 1.0, Noise((cloud_pos.xz+vec2(iTime*3.3)-ray_dir.xz*2.0)*0.2)) * 0.1;\n    cloud_color += mix(-1.0, 1.0, Noise((cloud_pos.xz+vec2(iTime*3.0)+ray_dir.xz*3.0)*0.4)) * 0.05;\n    cloud_color += mix(-1.0, 1.0, Noise((cloud_pos.xz+vec2(iTime*2.5)+ray_dir.xz*4.0)*0.6)) * 0.025;\n\n    return smoothstep(max(0.0, cloud_color), 0.0, 0.1);\n}\n\nfloat CastSoftShadow(in vec3 ray_origin, vec3 ray_dir) {\n    \n    float res = max(0.1, 1.0-CalcCloud(ray_origin, ray_dir)*1.2);\n    \n    float t = 0.02;\n    float tmax = 12.0;\n    \n    for (int i = 0; i < 25; ++i) {\n        \n        vec3 pos = ray_origin + t * ray_dir;\n        \n        float h = MapScene(pos).x;\n        res = min(res, max(0.0, 16.0 * h/t));\n        t += clamp(h, 0.05, 0.4);\n        \n        if (res < 0.005 || t>tmax)\n            break;\n    }\n\n    return res;\n}\n\nfloat RaymarchPixel(in vec3 ray_origin, in vec3 ray_dir, out vec3 hit_pos, out vec3 color, out vec3 normal) {\n\n    vec3 fog_color = vec3(1.0);\n\n    vec2 hit = CastRay(ray_origin, ray_dir);\n    \n    if (hit.x > 0.0) {\n        \n        hit_pos = ray_origin + hit.x * ray_dir;\n        normal = CalcNormal(hit_pos);\n                \n        vec3 sun_dir = normalize(vec3(0.8,0.4,0.2));\n        float sun_dif = clamp(dot(normal, sun_dir), 0.0, 1.0);\n        float sun_sha = CastSoftShadow(hit_pos + normal*0.001, sun_dir);\n        float sky_dif = 0.5 + 0.5 * normal.y;\n        float bounce_dif = 0.4 + normal.y * -0.5;\n        \n        vec3 light = vec3(0.0);\n        \n        light += vec3(10.0, 6.0, 3.0) * sun_dif*sun_sha;\n        light += vec3(0.5, 0.8, 0.9) * sky_dif;\n        light += vec3(0.7, 0.3, 0.2) * bounce_dif;\n        \n        vec3 material = vec3(0.2);\n        float reflection = 0.45;\n        \n        if (hit.y == MAT_FLOOR) {\n\t        material = vec3(0.2*clamp(sin(hit_pos.x*10.0)*sin(hit_pos.z*10.0)*1.0+0.05, 0.01, 0.2));\n            reflection = 0.05;\n        }\n        else if (hit.y == MAT_COLUMN) {\n            material = vec3(0.25);\n            reflection = 0.0;\n        }\n        else if (hit.y == MAT_WHITE) {\n            material = vec3(0.18);\n        }\n        else if (hit.y == MAT_RED) {\n            material = vec3(0.2, 0.01, 0.04);\n        }\n        else if (hit.y == MAT_GREEN) {\n            material = vec3(0.01, 0.2, 0.04);\n        }\n        else if (hit.y == MAT_BLUE) {\n            material = vec3(0.01, 0.04, 0.2);\n        }\n        \n        color = material * light;\n        // distance fog\n        color = mix(color, fog_color, clamp(hit.x*hit.x*0.01, 0.0, 1.0));\n        \n        return reflection;\n        \n    } else {\n        \n        color = vec3(0.4, 0.75, 1.0) - 0.7*ray_dir.y;\n\n        color += CalcCloud(ray_origin, ray_dir);\n        \n        color = mix(color, fog_color, clamp(exp(-8.0*ray_dir.y), 0.0, 1.0));\n\n        hit_pos = normal = vec3(0.0);\n        \n        return 0.0;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = PixelCoords(fragCoord);\n    \n    float an = 10.*iMouse.x/iResolution.x;\n    an += iTime * -0.09;\n    \n    vec3 ray_origin = vec3(sin(an), 0.1, cos(an));\n    vec3 look_at = vec3(0.0, 0.1, 0.0);\n\n    vec3 ray_dir = CreateRayDir(ray_origin, look_at, p);\n    \n    vec3 color = vec3(1.0);\n    float hit_strength = 1.0;\n    \n    for (int n = 0; n < 3; ++n) {\n        vec3 hit_pos, hit_color, hit_normal;\n        \n        float reflect_amount = RaymarchPixel(\n            ray_origin,\n            ray_dir,\n            hit_pos,\n            hit_color,\n            hit_normal\n        );\n\n        color = mix(color, hit_color, hit_strength);\n        hit_strength *= reflect_amount;\n\n        if (hit_strength > 0.001) {\n            ray_origin = hit_pos + hit_normal * 0.001;\n\t        ray_dir = reflect(ray_dir, hit_normal);            \n        }\n        else {\n            break;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(ApplyGamma(color),1.0);\n}\n","name":"Image","description":"","type":"image"}]}