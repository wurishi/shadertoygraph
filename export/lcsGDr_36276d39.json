{"ver":"0.1","info":{"id":"lcsGDr","date":"1702975882","viewed":14,"name":"mipt-hw3","username":"honoody","description":"mipt cg","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["hw"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITER 100000\n#define THRES_CLOSE .0001\n#define MAX_TRACE 1000.\n#define FAR_PLANE 510.\n#define NEAR_PLANE 490.\n\nin vec2 fragTexCoord;\nin vec4 fragColor;\n\nvec3 move(vec3 pos, vec3 delta)\n{\n    return pos - delta;\n}\n\nvec4 sdExpand(vec4 sd, float val)\n{\n    return vec4(sd.xyz, sd.w - val);\n}\n\nvec4 sdUnion(vec4 sd1, vec4 sd2)\n{\n    float weight = step(sd1.w, sd2.w);\n    float len = min(sd1.w, sd2.w);\n    vec3 nrm = sd1.xyz * weight + sd2.xyz * (1.-weight);\n    return vec4(nrm, len);\n}\n\nvec4 sdIntersect(vec4 sd1, vec4 sd2)\n{\n    float weight = step(sd2.w, sd1.w);\n    float len = max(sd1.w, sd2.w);\n    vec3 nrm = sd1.xyz * weight + sd2.xyz * (1.-weight);\n    return vec4(nrm, len);\n}\n\nvec4 sdSubstract(vec4 sd, vec4 sub)\n{\n    return sdIntersect(sd, -sub);\n}\n\nvec4 sdPoint(vec3 pos, vec3 size)\n{\n    vec3 p = abs(pos) - size;\n    float d = max(max(p.x, p.y), p.z);\n    float s = smoothstep(-THRES_CLOSE, THRES_CLOSE, d);\n    // Закругление углов\n    vec3 rounded = vec3(max(p.x, 0.0), max(p.y, 0.0), max(p.z, 0.0));\n    float roundness = 0.5;\n    float r = smoothstep(roundness, -roundness, (size.x - rounded.x));\n\n    return vec4(pos, d + r) * s;\n}\n\n\nvec4 sdPlanet(vec4 sd, vec3 pos, float x, float y, float z, vec3 cubeSize)\n{\n    pos = move(pos, 12.*vec3(sin(x), sin(y), sin(z)));\n    sd = sdUnion(sd, sdExpand(sdPoint(pos, cubeSize), 1.));\n    return sd;\n}\n\nvec4 sdWorld(vec3 pos)\n{\n    vec4 sd = sdPoint(pos, vec3(4.));\n\n\n\n    sd = sdPlanet(sd, pos, iTime, 1.1*iTime, 1.3*iTime, vec3(1.));\n    sd = sdPlanet(sd, pos, 1.1*iTime, 1.3*iTime, 1.7*iTime, vec3(1.));\n    sd = sdPlanet(sd, pos, 1.3*iTime, 1.7*iTime, 1.9*iTime, vec3(1.));\n    sd = sdPlanet(sd, pos, 1.7*iTime, 1.9*iTime, 2.3*iTime, vec3(1.)); \n    sd = sdPlanet(sd, pos, 1.9*iTime, 2.3*iTime, 2.7*iTime, vec3(1.)); \n    return sd;\n}\n\nvec4 march(vec3 pos, vec3 dir)\n{\n    float len;\n    for (int i=0; i<MAX_ITER; ++i)\n    {\n        vec4 sd = sdWorld(pos);\n        pos += sd.w * dir;\n        len += sd.w;\n        if (sd.w < THRES_CLOSE)\n        {\n            return vec4(sd.xyz, len);\n        }\n        else if (len > MAX_TRACE)\n        {\n            return vec4(-dir, MAX_TRACE);\n        }\n    }\n    return vec4(-dir, MAX_TRACE);\n}\n\nfloat hash(vec2 p)\n{\n    p = 50.0 * fract(p * 0.3183099 + vec2(2.71,7.113));\n    return fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(hash(i + vec2(0.0, 0.0)), \n                   hash(i + vec2(1.0, 0.0)), u.x),\n               mix(hash(i + vec2(0.0, 1.0)), \n                   hash(i + vec2(1.0, 1.0)), u.x), u.y);\n}\n\nvec3 bag(vec3 rd, vec2 uv) {\n    vec2 texturecoords = vec2(atan(rd.x, rd.z), rd.y) * 0.5;\n    float k = rd.x * 0.5;\n\n    float n = noise(texturecoords * iTime * 1.5);\n    vec3 texturecol = texture(iChannel0, uv).rgb;\n\n    vec3 col = mix(vec3(0.0, 0.1, 0.3), cos(iTime + vec3(1.0, 3.0, 3.0)), k) * 1.2;\n\n    vec3 result = mix(col, texturecol, 0.1);\n    \n\n    return result;\n}\n\n\nvec3 lighting(vec3 origin, vec3 hit, vec3 normal, vec3 albedo)\n{\n    vec3 lightPos = vec3(50. * cos(iTime), 50. * sin(iTime), 30.);\n    vec3 lightColor = vec3(.7+.3*sin(iTime*.1),.7+.3*sin(iTime*.2),.7+.3*sin(iTime*.5));\n    float intensity = .7;\n    float lightDist = length(lightPos - hit);\n\n    vec3 view = normalize(origin - hit);\n    vec3 light = (lightPos - hit) / lightDist;\n    vec3 halfNormal = normalize(view + light);\n\n    float shadow = step(lightDist - 1., march(hit+.1*normal, light).w);\n\n    vec3 diffuse = albedo * max(0.,dot(light, normal)) * lightColor * intensity;\n    vec3 specular = pow(max(0., dot(halfNormal, normal)), 120.) * lightColor;\n    vec3 ambient = .4 * albedo;\n\n    return shadow * (diffuse + specular) + ambient;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 view = (gl_FragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd = 2.0*normalize(vec3(uv, -1.0));\n    \n\n\n    vec3 origin = vec3(0., 00., 500.);\n    vec3 camDir = vec3(0., -.0, -1.);\n    vec3 camUp = vec3(0., 1., 0.);\n\n    camDir = normalize(camDir);\n    vec3 camRight = cross(camUp, camDir);\n    camUp = cross(camDir, camRight);\n\n    float fov = 0.05;\n    vec3 viewDir = camDir + fov * (camUp * view.y + camRight * view.x);\n    vec4 ret = march(origin, viewDir);\n\n    vec3 hit = origin + ret.w * viewDir;\n    vec3 normal = ret.xyz;\n    vec3 albedo = vec3(uv, .5 + .5 *sin(.2 * iTime));\n\n    float bg = step(ret.w, MAX_TRACE - 1.);\n    vec3 col = lighting(origin, hit, normal, albedo) * bg + albedo * (1.-bg) * .2;\n\n    col += bag(rd, uv);\n    vec3 textureColor = texture(iChannel1, uv).rgb;\n    col += textureColor;\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime * 0.1; \n\n    float stripes = sin(uv.y * 10.0 + time);\n    vec3 col = vec3(stripes);\n    fragColor = vec4(col, 1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}