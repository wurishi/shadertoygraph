{"ver":"0.1","info":{"id":"4cfSWj","date":"1705691620","viewed":108,"name":"box sketchs thing","username":"chenxianming","description":"box sketchs thing","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define I iResolution\n#define A max( I.x, I.y )\n#define T mod( iTime * ( iMouse.x > I.x / 2. ? -1. : 1. ), PI * 2. )\n#define S smoothstep\n#define D( u, a ) d( u - a )\n#define PI 3.14\n#define rot( a ) mat2( cos( a + vec4( 0, 11, 33, 0 ) ) )\n#define s( a ) ( a + f ) / f\n#define v2p( p ) vec2( s( p.z ) * p.x, s( p.z ) * p.y )\n#define d(a) dot( a, a )\n#define l .15\n#define f 8.\n#define gf( a ) int( floor( T / 1.57 ) + a ) % 4\n\n\n\n/*\n    f1 0123\n    f2 0374\n    f3 4567\n    f4 1562\n    f5 0154\n    f6 3256\n*/\n\n\nconst vec3[] cube = vec3[](\n    vec3( -l, l, l ),\n    vec3( l, l, l ),\n    vec3( l, -l, l ),\n    vec3( -l, -l, l ),\n    vec3( -l, l, -l ),\n    vec3( l, l, -l ),\n    vec3( l, -l, -l ),\n    vec3( -l, -l, -l )\n);\n\nvec2[] vertex = vec2[](\n    vec2(0),\n    vec2(0),\n    vec2(0),\n    vec2(0),\n    vec2(0),\n    vec2(0),\n    vec2(0),\n    vec2(0)\n);\n\nvec4[] faces = vec4[](\n    vec4( 0, 1, 2, 3 ),\n    vec4( 0, 4, 7, 3 ),\n    vec4( 4, 5, 6, 7 ),\n    vec4( 1, 5, 6, 2 ),\n    vec4( 0, 1, 5, 4 ),\n    vec4( 3, 2, 6, 7 )\n);\n\nvoid updatePos( inout vec3 p ){\n    p.xz *= rot( T );\n    p.yz *= rot( PI * .1 );\n    return ;\n}\n\nvoid getVertices( inout vec2[8] v ){\n\n    for( int t = 0; t < v.length(); t++ ){\n        vec3 x = cube[t];\n\n        updatePos( x );\n        \n        v[t] = v2p( x );\n    }\n\n    return ;\n}\n\nfloat sdSegment( in vec2 u, in vec2 v1, in vec2 v2 )\n{\n    u -= v1;\n    v2 -= v1;\n\treturn length( \n        u - \n        v2 * clamp(dot(u,v2)/dot(v2,v2), 0.0, 1.0)\n    );\n}\n\n\nfloat getFace( vec2 u, vec2[8] v, int i ){\n    float d = .9;\n    \n    d = min( d, \n        sdSegment( u, v[ int( faces[i].x ) ], v[ int( faces[i].y ) ] )\n    );\n\n\n    d = min( d, \n        sdSegment( u, v[ int( faces[i].y ) ], v[ int( faces[i].z ) ] )\n    );\n\n\n    d = min( d, \n        sdSegment( u, v[ int( faces[i].z ) ], v[ int( faces[i].w ) ] )\n    );\n\n\n    d = min( d, \n        sdSegment( u, v[ int( faces[i].w ) ], v[ int( faces[i].x ) ] )\n    );\n    \n    return d;\n}\n\nfloat sdWire( vec2 u, vec2[8] v ){\n    float d = .9;\n    \n    u.x += .25;\n    u.x -= .5 * clamp( round( u.x / .5 ), 0., 1. );\n    \n    /*\n        mean value faceIdx\n        0 = far\n        1 = left\n        2 = near\n        3 = right\n        \n        4 = top\n        5 = bottom\n    */\n    \n    \n    \n    d = min(\n        d,\n        getFace( u, v, 4 )\n    );\n\n    int i = gf(2.), j = gf(3.);\n\n    d = min(\n        d,\n        getFace( u, v, i )\n    );\n    \n    d = min(\n        d,\n        getFace( u, v, j )\n    );\n\n    \n    return d;\n}\n\nvoid mainImage( out vec4 U, in vec2 V )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 u = ( V * 2. - I.xy ) / A;\n    \n    vec2 m = ( iMouse.xy * 2. - I.xy ) / A;\n    \n    // Time varying pixel color\n    vec3 c;\n    \n    getVertices( vertex );\n\n    \n    c += S( .01, 0., abs( sdWire( u, vertex ) ) );\n    \n    \n    if( iMouse.z > .0001 )\n        c += S( 0.01, .0, abs( length(u-m) - sdWire( m, vertex ) ) );\n        \n\n    // Output to screen\n    U = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}