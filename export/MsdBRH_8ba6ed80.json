{"ver":"0.1","info":{"id":"MsdBRH","date":"1524119404","viewed":303,"name":"Tell me of your homeworld, Usul","username":"hypothete","description":"Trying out Perlin noise as an SDF landscape generator.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["dune","arrakis","desertplanet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON 0.01\n#define MAXSTEPS 128\n#define NEAR 0.1\n#define FAR 100.0\n#define TWOPI 6.28319\n\nprecision mediump float;\n\nin vec2 vTextureCoord;\n\nstruct Camera {\n    vec3 pos;\n    vec3 dir;\n};\n\nfloat rand (vec2 st) {\n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nvec2 grad (vec2 st) {\n    float nn = rand(st);\n    return vec2(cos(nn * TWOPI), sin(nn * TWOPI));\n}\n\nfloat gradnoise (vec2 st) {\n    // returns range -1, 1\n    vec2 pa = floor(st);\n    vec2 pb = pa + vec2(1.0, 0.0);\n    vec2 pc = pa + vec2(0.0, 1.0);\n    vec2 pd = pa + vec2(1.0);\n    vec2 ga = grad(pa);\n    vec2 gb = grad(pb);\n    vec2 gc = grad(pc);\n    vec2 gd = grad(pd);\n    float ca = dot(ga, st - pa);\n    float cb = dot(gb, st - pb);\n    float cc = dot(gc, st - pc);\n    float cd = dot(gd, st - pd);\n    vec2 frast = fract(st);\n    return mix(\n        mix(ca, cb, smoothstep(0.0, 1.0, frast.x)),\n        mix(cc, cd, smoothstep(0.0, 1.0, frast.x)),\n        smoothstep(0.0, 1.0, frast.y));\n}\n\nfloat perlin (vec2 st, float scale, float freq, float persistence, float octaves) {\n    float p = 0.0;\n    float amp = 1.0;\n    for (float i=0.0; i<octaves; i++) {\n        p += gradnoise(st * freq / scale) * amp;\n        amp *= persistence;\n        freq *= 2.0;\n    }\n    return p;\n}\n\nfloat sdfSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdfPerlin(vec3 p) {\n    return p.y + 4.0 * perlin(p.xz, 6.0, 0.5, 0.5, 3.0) + 0.5;\n}\n\nfloat sceneSDF(vec3 p) {\n    float moon1 = sdfSphere(p + vec3(-60.0, -40.0, -70.0), 5.0);\n    float moon2 = sdfSphere(p + vec3(-30.0, -20.0, -70.0), 2.0);\n    float land = sdfPerlin(vec3(p.x, p.y, p.z + iTime));\n    return min(min(moon1, moon2), land);\n}\n\nvec3 sceneNormal(vec3 p) {\n    vec3 v1 = vec3(1.0, -1.0, -1.0);\n    vec3 v2 = vec3(-1.0, -1.0, 1.0);\n    vec3 v3 = vec3(-1.0, 1.0, -1.0);\n    vec3 v4 = vec3(1.0, 1.0, 1.0);\n    return normalize(\n        v1 * sceneSDF(p + v1*EPSILON) +\n        v2 * sceneSDF(p + v2*EPSILON) +\n        v3 * sceneSDF(p + v3*EPSILON) +\n        v4 * sceneSDF(p + v4*EPSILON)\n    );\n}\n\nfloat distToSurface(Camera c, out vec3 ip) {\n    float depth = NEAR;\n    for (int i=0; i<MAXSTEPS; i++) {\n        ip = c.pos + c.dir * depth;\n        float distToScene = sceneSDF(ip);\n        if (distToScene < EPSILON) {\n            return depth;\n        }\n        depth += distToScene;\n        if (depth >= FAR) {\n            return FAR;\n        }\n    }\n    return depth;\n}\n\nfloat lambert(vec3 norm, vec3 lpos) {\n    return max(dot(norm, normalize(lpos)), 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 nrmDir = normalize(vec3(uv, 1.0));\n    Camera camera = Camera(vec3(0.0, 2.0, -3.0), nrmDir);\n    vec3 endPt;\n    float t = distToSurface(camera, endPt);\n    vec3 ambi = vec3(0.01, 0.001, 0.001);\n    vec3 sky = mix(vec3(0.1,0.2,1.0), vec3(1.0), smoothstep(0.0, 1.0, 1.0 - uv.y / 2.0 - 0.5));\n    vec3 col = sky;\n\n    if (t < FAR) {\n        vec3 nrm = sceneNormal(endPt);\n        vec3 lpos = vec3(-1.0, 0.5, -0.4); // light position\n        vec3 diff = vec3(0.6, 0.17, 0.01); // landscape diffuse\n        col = ambi + diff * lambert(nrm, lpos);\n        if (endPt.y < 10.0) {\n        \tcol = mix(col, sky, length(endPt) / FAR);\n        }\n        else {\n            col = sky + vec3(0.5) * lambert(nrm, lpos);\n        }\n    }\n\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}