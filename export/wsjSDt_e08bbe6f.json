{"ver":"0.1","info":{"id":"wsjSDt","date":"1555395653","viewed":419,"name":"compatible bit buffer","username":"ollj","description":"i want to store bits in fragments, fast and compatible, using [ __VERSION__ ]\nso, whats good approaches here?\nand is pow(2,24) really an upper limit due to 32 bit float base size?\ncan only use 23 bits  of a float?\n\nuintBits","likes":1,"published":3,"flags":32,"usePreview":0,"tags":["thewitness2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 read0(vec2 u){\n ;//u=floor(u)//floor() is a FAD idea, it causes bleeding.\n ;//return texelFetch(iChannel0,ivec2(u),1)//i am not a fan of texelFetch here.\n ;return texture(iChannel0,u/iResolution.xy)\n ;}\n\n/*\nfloat drawMaze1(vec2 u//u is NOT scaled by resolution\n){//float r=0;\n ;u=floor(u)\n ;if(u==vec2(0))return 1.;\n ;return 0.;\n ;}\n*/\n\n\nvoid mainImage(out vec4 o,vec2 u\n){u/=8.//zoom\n ;vec3 c=vec3(0)\n ;//c.x=drawMaze1(u-neo)\n ;//o=vec4(c,1.)\n ;//o=read0(u)\n ;o=read0(vec2(0))\n ;//o.w =intBitsToFloat(1);\n  //https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/intBitsToFloat.xhtml \n  //is opengl3.30 and it has bad NaN/intinity coding, i expect incompatibility.\n  //floatBitsToInt() is its pseudo-inverse\n ;if(floor(u.y)==4.\n ){\n  ;if(getBit(mod(float(fram),BitCap),pow(2.,floor(u.x)))==1.)o.x=1.\n  //;if(getBit(BitCap-1.,BitCap-1.)==1.)o.x=1.\n  ;}\n ;}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//this shader just wants to run in ( __VERSION__==100 )\n//at all costs, so intBitsToFloat() is not even an option!\n//and i think that explicit float-exponent extraction is worth it.\n\n// https://www.shadertoy.com/view/4lBfRm\n//claims to store 32bit per channel, 128 bit per voxel/texel/fragment\n//by using intBitsToFloat() (actually its unsigned variant)\n//but i think the NaN-case fucks this one over,or its just not as compatible.\n//\n//https://www.shadertoy.com/view/llSfzw\n//realizes that arbitiaryNaN-handling constrains this a lot.\n//\n//https://www.shadertoy.com/results?query=BitsToFloat\n//investigates compatibility further.\n\n\nvec4 read0(vec2 u){\n ;u=floor(u)\n ;//return texelFetch(iChannel0,ivec2(u),1)//i am not a fan of texelFetch here.\n ;return texture(iChannel0,u/iResolution.xy)\n ;}\n\n//a fragment stores a lot of bits, useful do define a maze and maxe-solver-states.\nfloat drawMaze1(vec2 u//u is NOT scaled by resolution\n){\n ;u=floor(u)\n ;if(u==vec2(0))return mod(float(fram),BitCap)/BitCap//offset of 0 floor(u)==vec2(0) has line1 bleed into line0.\n ;return 0.;\n ;}\n//maybe i should not divide by /BitCap to fit in range [0..1]\n//that may give be more usable bits, but it may also diminish compoatibility, (or not?).\n\n/*\n//one-time multi-pass\nvec4 iFrame10(vec2 u\n){float w=drawMaze1(u)\n ;return vec4(1)\n ;}\nvec4 iFrame11(vec2 u\n){\n ;return vec4(1)\n ;}\nvec4 colorFrame(vec2 u\n){if(fram<10){return vec4(1);}\n ;}\n*/\n\nvoid mainImage(out vec4 o,vec2 u\n){\n ;vec3 c=vec3(0)\n ;c.b=drawMaze1(u-neo)\n ;o=vec4(c,1.)\n ;//if(fram<10){o=vec4(0);return;}\n ;}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//node-exists-offset allows to offset the vertex-database-matrix\n//that buffers Node-exists-state (and a bit more)\n#define neo vec2(0)\n\n#if (__VERSION__==300)\nint   mo(int a  ,int   b){return a%b;}\nivec2 mo(ivec2 a,ivec2 b){return a%b;}\nivec3 mo(ivec3 a,ivec3 b){return a%b;}\nivec4 mo(ivec4 a,ivec4 b){return a%b;}\n#else\nint   mo(int a  ,int   b){return int  (mod(float(a),float(b)));}\nivec2 mo(ivec2 a,ivec2 b){return ivec2(mod(vec2 (a),vec2 (b)));}\nivec3 mo(ivec3 a,ivec3 b){return ivec3(mod(vec3 (a),vec3 (b)));}\nivec4 mo(ivec4 a,ivec4 b){return ivec4(mod(vec4 (a),vec4 (b)));}\n#endif\n\n//we scale floats to bitcap, for compatibility, we store bits in floats.\n//15 bits should be doable even in explicitly lowPrecision environments.\n//is expressed as BitCap=pow(2,floor(B))\n#define BitCap pow(2.,24.)\n//it seems that pow(2,24) is an upper limit for the operations that i do., \n//pow(2,25) loses too much precision with large offsets of [fram]\n\n//fram is [iframe] with (large) offset, to test larger values earlier\n#define fram (iFrame+int(pow(2.,24.))    )\n//+int(pow(2.,23.))+int(pow(2.,22.))+int(pow(2.,21.))+int(pow(2.,20.))\n//+int(pow(2.,19.))+int(pow(2.,18.))+int(pow(2.,17.))+int(pow(2.,16.))\n//+int(pow(2.,15.))+int(pow(2.,14.))+int(pow(2.,13.))+int(pow(2.,12.))\n//+int(pow(2.,11.))+int(pow(2.,10.))+int(pow(2., 9.))+int(pow(2., 8.))\n\n\n//#define fram (iFrame+int(pow(2.,25.))) already loses too much precision.\n\n/*\n//these branchless comparators compare [c] with [0.0] to return [a]==true or [b]==false;\n//based on \n//  https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n//(c> 0)?a:b\n#define greater(a,b,c)   mix(a,b,step(c,0.))\n//(c< 0)?a:b\n#define less(a,b,c)      mix(a,b,step(0.,c))\n//(c==0)?a:b\n#define equals(a,b,c)    mix(b,a,step(c,0.)+step(0.,c)-1.)\n////#define equalsA(a,b,c) mix(b,a,(sign(c)+sign(-c))*.5)//here you can NOT substitute sign(-c) for=sign(c),because that implies a [signed null]!\n//----------- mirror symmetry mirror==swap outputs--------------------\n//(c!=0)?a:b\n#define unequal(a,b,c)   mix(a,b,step(c,0.)+step(0.,c)-1.)\n//(a>=0)?a:b   \"unless   \"=not less  ==greater OR equal\n#define unless(a,b,c)    mix(b,a,step(0.,c))\n/**/\n//(c<=0)?a:b   \"ungreater\"=not greater==less    OR equal\n#define ungreater(a,b,c) mix(b,a,step(c,0.))\n\n\n//assert: b=pow(2.,floor(abs(B))) ; a=floor(abs(A))\n//check if single bit [b] is in [a] ; (int(a)&int(b))>0)\nfloat getBit(float a,float b\n){//if (b>=BitCap)return 0.//optionally include this bound\n #if (__VERSION__==300)\n ;return float(sign((int(a)&int(b))-1))*.5+.5\n ;//if(             (int(a)&int(b))>0)return 1.\n #else\n ;for(float i=BitCap;i>=1.;i/=2.//i>=1 to evade tangential paradox\n ){if(a==0.)return 0.;\n  ;if(i==b&&a>=b)return 1.\n  ;a=ungreater(i-a,a-i,a);//if(i-a<=0.)a=a-i;\n  ;}\n #endif\n ;return 0.;}\n","name":"Common","description":"","type":"common"}]}