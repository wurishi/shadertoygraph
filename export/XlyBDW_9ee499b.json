{"ver":"0.1","info":{"id":"XlyBDW","date":"1542477157","viewed":138,"name":"GlassBall","username":"Falko","description":"move mouse to rotate camera","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 v;\nvec3 lightSource = vec3(20.0, 0.0, 6.0);\nfloat bLightSource = 0.6;\nfloat ba = 0.4;\n\nfloat pi(){\n \treturn radians(180.0);   \n}\n\nvec2 intersectCircle(vec2 cp, vec2 rView){\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nvec2 intersect_ball(vec3 cp, vec3 rView){\n            float cp_projected = dot(rView, cp);\n            return vec2(cp_projected, pow(cp_projected, 2.0)-dot(cp, cp));\n    }\n\nfloat specular(vec3 normal, vec3 p, vec3 rCamera){\n            vec3 dir_light = normalize(p-lightSource);\n            vec3 dir_reflect = reflect(dir_light, normal);\n            float spec = pow(max(0.0, dot(rCamera, dir_reflect)), 200.0);\n            return spec;\n            \n    }\n\nfloat diffuse(vec3 p, vec3 normal){\n            vec3 dirLight = normalize(lightSource-p);\n            return bLightSource*max(0.0, dot(normal, dirLight));\n    }\n\nvec3 chess(vec3 p, vec3 pFrag){\n    vec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n \t\n    float tileSize = 4.0;\n    float pixSize = 3.0*2.0*length(v-p)\n        \t\t\t\t\t\t\t/(min(iResolution.x, iResolution.y)\n                                    *length(v-pFrag)\n                                    *tileSize);\n    \n    vec2 ij = floor(p.xy/tileSize);\n   \tvec3 cChess;\n    if(mod(ij.x, 2.0)==mod(ij.y, 2.0)){\n        cChess = cSand;\n    }\n    else{\n     \tcChess = cSandStone;   \n    }\n    \n    vec2 pLocal = abs(fract(p.xy/tileSize)-0.5);\n    float maxLocal = max(pLocal.x, pLocal.y);\n    \n    float bd = diffuse(p, vec3(0.0, 0.0, 1.0));\n    return (ba+bd)*mix(cRock, cChess, smoothstep(0.0, pixSize, 0.49-maxLocal));  \n}\n\nvec3 rostrum(vec3 p, vec3 rView, float radius){\n    vec3 cRock = vec3(0.71, 0.7, 0.65);\n    float h = 2.0;\n \t\n    vec2 sol = intersectCircle(-p.xy, normalize(rView.xy));\n    \n    vec3 pCylinder = p + rView*\n        \t\t\t\t(sol.x+sqrt(sol.y+pow(radius, 2.0)))\n                         /length(rView.xy);\n    //float temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n    //vec3 pIntersect = p\t+ (-sol.y-pow(radius, 2.0)+ pow(sol.x, 2.0)) \n        \t\t\t\t//* rView / (temp*length(rView.xy));\n    vec3 nCylinder = normalize(vec3(-pCylinder.xy, 0.0));\n    vec3 pPlane = p - (p.z-h) * rView / rView.z;\n    \n    float bd = mix(diffuse(pCylinder, nCylinder),\n             diffuse(pPlane, vec3(0.0, 0.0, 1.0)),\n             smoothstep(h-0.1, h, pCylinder.z));\n    return (ba+bd)*cRock;\n}\n\nvec3 computeBackground(vec3 p, vec3 rView){\n \tvec3 cSand = vec3(0.76, 0.7, 0.5);\n    vec3 cSandStone = vec3(0.76, 0.57, 0.5);\n    vec3 cSky = vec3(0.5, 0.76, 0.7);\n    \n    //check if XY-plane is visible\n    if(dot(rView, vec3(0.0, 0.0, 1.0))>-0.01*3.14){\n     \treturn cSky;   \n    }\n    \n    //calculate intersection with XY-plane\n    vec3 pXY = p - p.z * rView / rView.z;\n    float l0 = length(pXY);\n    float l1 = length(p - (p.z-2.0) * rView / rView.z);\n    vec2 polar = vec2(acos(pXY.x/l0)*sign(pXY.y)+pi(), l0);\n    \n    if(l1>30.0){\n        \n     \treturn cSky;  \n    }\n    else if(l0>25.0){\n        vec3 cRostrum = rostrum(p, rView, 25.0);\n        vec3 mix0 = mix(chess(pXY, p), cRostrum,\n                   smoothstep(25.0, 25.4, l0));  \n     \treturn mix(mix0, cSky,\n                   smoothstep(29.3, 30.0, l1));   \n    }\n    else{\n        return chess(pXY, p); \n     \t//return mix(cSand, cSandStone, 0.5*(1.0+cos(4.0*polar.x)));   \n    }\n}\n\n\n    \n\nmat3 rotationMatrix(const float angle, const vec3 axis){\n \tfloat alpha = radians(angle);\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat3 R;\n    R[0] = axis * axis.x * (1.0-c) + vec3(c, axis.z*s, -axis.y*s);\n    R[1] = axis * axis.y * (1.0-c) + vec3(-axis.z*s, c, axis.x*s);\n    R[2] = axis * axis.z * (1.0-c) + vec3(axis.y*s, -axis.x*s, c);\n    return R;\n}\n\nvec3 getCameraPosition(vec4 mouse){\n    vec3 v0 = 20.0*vec3(1.0, 0.0, 1.0);\n    \n    if(iMouse.w<0.){\n        return v0;\n    }\n    else{\n        vec3 v;\n    \tvec2 angle = 200.0*(mouse.xy-mouse.zw);\n        angle.y = min(abs(angle.y), 40.0)*sign(angle.y);\n        \n        vec3 axVert = vec3(0.0, 0.0, 1.0);\n        mat3 rVert = rotationMatrix(angle.x, axVert);\n        v = rVert*v0;\n        \n        vec3 axFlat = normalize(cross(-v, axVert));\n\t\tmat3 rFlat = rotationMatrix(angle.y, axFlat);\n        return rFlat*v;\n    }\n}\n\nvec3 polar_pattern(vec3 p){\n           vec3 color_ball = vec3(0.8, 0.25, 0.33);\n           \n           \n           float n = 11.0;\n           \n           vec2 px = p.xy;\n           vec2 pz = normalize(p.zy);\n           \n           vec2 polar = vec2(0.5*n*(acos(px.x)*sign(px.y)/pi()+1.0),\n                             0.5*n*(acos(pz.x)*sign(pz.y)/pi()+1.0));\n           vec2 ij = floor(polar);\n           if(abs(mod(ij.x, 2.0)-mod(ij.y, 2.0))<0.001){\n                   return color_ball;\n           }\n           else{\n                   return 0.5*color_ball;\n           }\n           \n           //return p;\n   \n   }\n\nvec3 reflectionBall(vec3 pSurface, vec3 center, vec3 pFrag, vec3 rView){\n    vec3 n = normalize(pSurface-center);\n    vec3 rReflected = reflect(rView, n);\n    vec3 pFragReflected = pSurface - rReflected * length(pSurface-pFrag);\n    \n    \n    float spec = specular(n, pSurface, -rView);\n    \n    return mix(computeBackground(pFragReflected, rReflected),\n               vec3(1.0), spec);\n}\n\nvec3 refractionBall(vec3 pFront, vec3 center, vec3 pFrag, vec3 rView){\n    vec3 nFront = normalize(pFront-center);\n    \n    vec3 rRefracted = refract(rView, nFront, 1.0/1.49);\n    vec3 pBack = center+reflect(pFront-center, -rRefracted);\n    vec3 nBack = normalize(pBack-center);\n    rRefracted = refract(rRefracted, -nBack, 1.49);\n    vec3 pFragRefracted = pFront - rRefracted * length(pBack-pFrag);\n    \n    return computeBackground(pFragRefracted, rRefracted);\n}\n\nvec4 computeObject(vec3 p, vec3 rView){\n    vec3 cBrick = vec3(0.8, 0.25, 0.33);\n    vec3 center = vec3(0.0, 0.0, 6.0);\n    float radius =  5.0;\n    \n    vec2 sol = intersect_ball(center-p, rView);\n    \n    if(pow(radius, 2.0)+sol.y>0.0){\n           float temp = sol.x+sqrt(sol.y+pow(radius, 2.0));\n           vec3 p0 = p+(-sol.y-pow(radius, 2.0)+pow(sol.x, 2.0))*rView/temp;\n           float alpha = max(0.0, -dot(rView, normalize(p0-center)));\n           \n           vec3 color = reflectionBall(p0, center, p, rView);\n        \n           color = mix(color, refractionBall(p0, center, p, rView),\n                       pow(alpha, 0.7));\n           return vec4(color , smoothstep(0.0, 0.3, pow(radius, 2.0)+sol.y));\n           }\n           else{\n           return vec4(cBrick, 0.0);\n            }        \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0*(fragCoord-0.5*iResolution.xy)/min(iResolution.x, iResolution.y);\n    vec4 mouse = iMouse/min(iResolution.x, iResolution.y);\n    \n    // set up camera\n    //vec3 v = 10.0*vec3(1.0, 0.0, 1.0);\n    v = getCameraPosition(mouse);\n    vec3 vDir = normalize(-v);\n    vec3 vLeft = normalize(cross(vDir, vec3(0.0, 0.0, 1.0)));\n    vec3 vUp = cross(vLeft, vDir);\n    float dScreen = 2.5;\n    \n    //calculate fragment position in space\n    vec3 pFrag = v + dScreen * vDir + uv.x*vLeft + uv.y * vUp;\n    \n    vec3 rView = normalize(pFrag-v);\n    \n    vec4 colorBall = computeObject(pFrag, rView);\n    \n    vec3 color = computeBackground(pFrag, rView);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(mix(color, colorBall.xyz, colorBall.w),1.0);\n}","name":"Image","description":"","type":"image"}]}