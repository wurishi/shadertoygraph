{"ver":"0.1","info":{"id":"tlBSzz","date":"1565121064","viewed":371,"name":"Toilet Humour :-)","username":"peet","description":"A fun scene to test my raymarcher.\nThis is can be close to the limits of compilation, you may need to tweak MSAA settings/toggle defines if compiler times out!\nMSAA=2.0 speeds compile time, at expense of FPS, bit strange!","likes":20,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","reflection","animation","softshadows","fresnel","schlick","emoji","toilet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////\n// Raymarching an SDF, with a cute emoji for fun :) /////////////////////// peet //\n///////////////////////////////////////////////////////////////////////////////////\n// This is can exceed compilation time limits with many options enabled ///////////\n// Setting both MSAA to 2.0 improves compilation time at expense for FPS //////////\n// Remove STUFF2/SIDEWALLS/MRSPOO also if you're having problems viewing //////////\n///////////////////////////////////////////////////////////////////////////////////\n// Snippets of code taken from others, mostly SDF from IQ /////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MARCH_ITERATIONS 40\t\t\n\n#define REFLECT_ITERATIONS 3\t\n#define MSAA_X 1.0\t\t\t\t// Both set to 2.0 improves compilation time!\n#define MSAA_Y 1.0\t\t\t\t// Runs much faster at 1.0, but may not compile\n\n///////////////////////////////////////////////////////////////////////////////////\n// More stuff -> longer compilation times (may timeout)\n\n#define POO\n#define MRSPOO\n#define STUFF\n#define SIDEWALLL\n//#define SIDEWALLR\n//#define EYESOCKETS\n//#define STUFF2\t\t// just some minor details, which can be freely disabled\n\n///////////////////////////////////////////////////////////////////////////////////\n// optionals\n\n#define FOLLOWCAM\n//#define ROUGH\n#define LIGHTBULB\n#define SOFTSHADOWS\t\n//#define ENCLOSED\n//#define DITHER\n//#define SLOW_NORMALS\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define TILES 0\n#define WHITE 1\n#define EYEBL 2\n#define EYEWH 3\n#define CHROM 4\n#define SIERP 5\n#define BROWN 6\n#define GREY  7\n#define MAGEN 8\n\nconst Material g_brown = Material(vec3(0.4, 0.2, 0.1), 0.3, 0.044);\nconst Material g_white = Material(vec3(1.0, 1.0, 1.0), 4.5, 0.08);\nconst Material g_eyebl = Material(vec3(0.0, 0.0, 0.0), 0.9, 0.04);\nconst Material g_eyewh = Material(vec3(1.0, 1.0, 1.0), 0.9, 0.04);\nconst Material g_chrom = Material(vec3(0.2, 0.25, 0.3), 0.1, 0.99);\nconst Material g_sierp = Material(vec3(0.2, 0.5, 0.1), 4.5, 0.04);\nconst Material g_tiles = Material(vec3(0.6, 0.9, 0.8), 0.9, 0.2);\nconst Material g_grey = Material(vec3(1.0, 0.3, 1.0), 1.6, 0.004);\nconst Material g_magen = Material(vec3(1.0, 0.0, 1.0), 1.0, 0.0);\n\nMaterial g_mats[10];\n\nAnimObj g_poo;\nAnimObj g_poo2;\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#ifdef LIGHTBULB\nconst vec3 g_lightpivot = vec3(2.0, 3.75, -1.0);\nconst vec3 g_lightpos = vec3(2.0, 0.75, -1.0);\n\nLight g_light = Light(vec3(1.3, 1.0, -0.5), vec3(100.0, 100.0, 100.0)*0.25);\n#else\nLight g_light = Light(normalize(vec3(1.0, -1.0, 1.0)), vec3(100.0, 100.0, 100.0));\n#endif\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's texture based noise function (37,17) FTW!\n\nfloat noise( in vec3 x )\n{\n    x *= 5.0;\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0. ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// composite SDF's\n\nSDFResult lightSDF( vec3 p )\n{\n    float cablelen = g_lightpivot.y - g_lightpos.y;\n    vec3 vecY = g_light.pos - g_lightpivot;\n    vecY = normalize(vecY);\n        \n    SDFResult res = vertcapSDF2(VertCap(g_lightpivot, cablelen-0.1, 0.005, WHITE), vecY, p);\n    return res;\n}\n\nSDFResult wallsSDF( vec3 p )\n{\n    // floor\n    SDFResult res = boxSDF2(RoundBox(vec3(0.0, -1.1, 0.0), vec3(7.0, 0.1, 2.0), 0.0, TILES), p);\n    // back\n    res = opAdd(boxSDF2(RoundBox(vec3(0.0, 1.0, 3.5), vec3(7.0, 3.0, 2.0), 0.0, TILES), p), res);          \n#ifdef SIDEWALLR\n    // RHS\n    res = opAdd(boxSDF2(RoundBox(vec3(4.6, 1.0, 0.0), vec3(0.1, 2.0, 1.5), 0.0, TILES), p), res);              \n#endif //SIDEWALLR\n#ifdef SIDEWALLL\n    // LHS\n    res = opAdd(boxSDF2(RoundBox(vec3(-1.6, 1.0, 0.0), vec3(0.1, 2.0, 1.5), 0.0, TILES), p), res);          \n#endif //SIDEWALLL\n    \n#ifdef ENCLOSED\n    res = opAdd(planeSDF2(Plane(vec3(0.0, 0.0, -3.5), vec3(0.0, 0.0, 1.0), TILES), p), res);          \n    res = opAdd(planeSDF2(Plane(vec3(0.0, 3.0, 0.0), vec3(0.0, -1.0, 0.0), TILES), p), res);          \n#endif //ENCLOSED\n    \n#ifdef LIGHTBULB    \n    res = opAdd(lightSDF(p), res);\n#endif //LIGHTBULB\n    \n#ifdef MRSPOO\n    // recess\n    res = opSmoothSub(roundboxSDF(RoundBox(vec3(2.0, 2.0, 2.5), vec3(1.1, 1.1, 1.0), 0.05, SIERP), p), res, 0.05);          \n#endif //MRSPOO\n        \n    return res;\n}\n\n// eyes\nSDFResult eyeSDF( vec3 p )\n{\n#ifdef EYESOCKETS    \n\tconst float eyeoffset=0.0;        \n#else\n\tconst float eyeoffset=-0.1;    \n#endif\n    SDFResult res = sphereSDF(Sphere(vec3(0.15, 0.6, eyeoffset-0.31), 0.12, EYEWH), p);\n    res = opSmoothAdd(sphereSDF(Sphere(vec3(-0.15, 0.6, eyeoffset-0.31), 0.12, EYEWH), p), res, 0.01);      \n    res = opSmoothAdd(sphereSDF(Sphere(vec3(0.15, 0.6, eyeoffset-0.41), 0.06, EYEBL), p), res, 0.01); \n    res = opSmoothAdd(sphereSDF(Sphere(vec3(-0.15, 0.6, eyeoffset-0.41), 0.06, EYEBL), p), res, 0.01);      \n    return res;    \n}\n   \n// poop //\nSDFResult pooSDF( vec3 p, AnimObj obj, int matindex )\n{   \n    p-=obj.pos;\t// p from world space into local space\n    SDFResult res = SDFResult(TOO_FAR, MAGEN);\n\n    if (length(p-obj.centre) < obj.radius)\n    {   \n        p /= obj.scale;\n        \n        // poop\n        res = torusSDF2(Torus(vec3(0.0, 0.2, 0.0), 0.5, 0.2, matindex), p);      \n        res = opSmoothAdd(sphereSDF(Sphere(vec3(-0.2, 1.05, 0.1), 0.08, matindex), p), res, 0.01);\n        res = opSmoothAdd(torusSDF(Torus(vec3(0.0, 0.8, 0.0), 0.1, 0.2, matindex), p), res, 0.2);      \n        res = opSmoothAdd(torusSDF(Torus(vec3(0.0, 0.5, 0.0), 0.3, 0.2, matindex), p), res, 0.1);      \n#ifdef EYESOCKETS\n        // eye sockets        \n        res = opSmoothSub(sphereSDF(Sphere(vec3(0.15, 0.6, -0.5), 0.15, matindex), p), res, 0.1);      \n        res = opSmoothSub(sphereSDF(Sphere(vec3(-0.15, 0.6, -0.5), 0.15, matindex), p), res, 0.1);      \n#endif //EYESOCKETS\n#ifdef ROUGH        \n        res -= clamp(noise(p*10.0), 0.0, 0.5)*0.005;\n#endif        \n        res = opSmoothAdd(eyeSDF(p), res, 0.01); \n    }\n    return res;\n}\n\n// brush\nSDFResult brushSDF( vec3 p )\n{\n    vec3 orig = vec3(0.8, -1.0, 1.2);        \n    // handle\n    SDFResult res = vertcapSDF(VertCap(vec3(-0.0, -0.0, .0)+orig, 0.75, 0.02, CHROM), p);\n    res = opSmoothAdd(vertcapSDF(VertCap(vec3(0.0, 0.0, 0.0)+orig, 0.2, 0.1, CHROM), p), res, 0.01);\n    return res;\n}\n\nSDFResult tapsSDF( vec3 p )\n{\n    SDFResult res = SDFResult(TOO_FAR, MAGEN);\n    res = roundboxSDF(RoundBox(vec3(2.0, 0.4, 1.5), vec3(0.04, 0.14, 0.01), 0.01, CHROM), p);\n    res = opSmoothAdd(roundboxSDF(RoundBox(vec3(2.0, 0.5, 1.5), vec3(0.04, 0.01, 0.09), 0.01, CHROM), p), res, 0.01);\n    res = opSmoothAdd(roundboxSDF(RoundBox(vec3(2.0, 0.55, 1.5), vec3(0.04, 0.005, 0.09), 0.01, CHROM), p), res, 0.01);    \n\treturn res;\n}\n\n// sink\nSDFResult sinkSDF( vec3 p )\n{\n    SDFResult res = SDFResult(TOO_FAR, MAGEN);  \n    vec3 orig = vec3(2.0, -1.0, 1.0);        \n\n    vec3 centre = vec3(0.0, 1.0, 0.0)+orig;\n    const float radius = 1.3;\n    if (length(p-centre) < radius) \n    {   \n        // pedestal\n        res = roundboxSDF(RoundBox(vec3(0.0, 0.2, 0.4)+orig, vec3(0.2, 0.6, 0.1), 0.1, WHITE), p);\n        // bowl \n        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 1.2, 0.2)+orig, vec3(0.5, 0.2, 0.15), 0.15, WHITE), p), res, 0.1);\n        res = opSmoothSub(roundboxSDF(RoundBox(vec3(0.0, 1.7, 0.2)+orig, vec3(0.5, 0.2, 0.15), 0.15, MAGEN), p), res, 0.1);\n        // base\n        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 0.0, 0.6)+orig, vec3(0.3, 0.05, 0.35), 0.05, WHITE), p), res, 0.1);\n        // taps\n#ifdef STUFF2\n\t\tres = opSmoothAdd(tapsSDF(p), res, 0.01);\n#endif //STUFF2\n    }\n    return res;\n}\n\n// bath\nSDFResult bathSDF( vec3 p )\n{\n    SDFResult res = SDFResult(TOO_FAR, MAGEN);   \n    vec3 orig = vec3(3.75, -1.0, 0.2);        \n\n    vec3 centre = vec3(0.0, 0.5, 0.0)+orig;\n    const float radius = 2.3;\n    if (length(p-centre) < radius) \n    {   \n        // pedestal\n        res = roundboxSDF(RoundBox(vec3(0.0, 0.5, 0.0)+orig, vec3(0.55, 0.5, 1.0), 0.1, WHITE), p);    \n    }\n    return res;\n}\n\n// toilet\nSDFResult toiletSDF( vec3 p )\n{\n    SDFResult res = SDFResult(TOO_FAR, MAGEN);    \n    vec3 orig = vec3(0.0, -1.0, 1.0);        \n\n    vec3 centre = vec3(0.1, 1.0, 0.0)+orig;\n    const float radius = 1.3;\n    if (length(p-centre) < radius) \n    {   \n        // pedestal\n        res = roundboxSDF(RoundBox(vec3(0.0, 0.2, 0.0)+orig, vec3(0.2, 0.5, 0.2), 0.1, WHITE), p);\n        // bowl and lid\n        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 0.6, -0.1)+orig, vec3(0.5, 0.2, 0.3), 0.05, WHITE), p), res, 0.1);\n        res = opSmoothSub(roundboxSDF(RoundBox(vec3(0.0, 0.78, -0.1)+orig, vec3(0.5, 0.000002, 0.3), 0.05, WHITE), p), res, 0.001);\n        // reservoir\n        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 1.4, 0.5)+orig, vec3(0.5, 0.5, 0.1), 0.05, WHITE), p), res, 0.1);\n        res = opSmoothSub(roundboxSDF(RoundBox(vec3(0.0, 1.8, 0.5)+orig, vec3(0.5, 0.000002, 0.1), 0.05, WHITE), p), res, 0.001);\n        // base\n        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 0.0, 0.0)+orig, vec3(0.3, 0.05, 0.35), 0.05, WHITE), p), res, 0.1);\n#ifdef STUFF2\n        // button & brush\n        res = opSmoothAdd(roundboxSDF(RoundBox(vec3(0.0, 1.93, 0.5)+orig, vec3(0.05, 0.02, 0.05), 0.05, WHITE), p), res, 0.01);\n        res = opSmoothAdd(brushSDF(p), res, 0.1);\n#endif //STUFF2\n    }\n    return res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF scene\n\nSDFResult sceneSDF(vec3 p )\n{\n    SDFResult res = wallsSDF(p);   \n#ifdef POO    \n    res = opSmoothAdd(pooSDF(p, g_poo, BROWN), res, 0.01);\n#endif //POO\n#ifdef STUFF\n    res = opSmoothAdd(toiletSDF(p), res, 0.01);\n    res = opSmoothAdd(sinkSDF(p), res, 0.01);\n    res = opSmoothAdd(bathSDF(p), res, 0.01);\n#endif //STUFF\n#ifdef MRSPOO\n    //res = opAdd(sierSDF(p, SIERP, iTime), res);\n    res = opAdd(pooSDF(p, g_poo2, GREY), res);\n#endif //MRSPOO            \n\treturn res;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF system\n\nResult resultSDF(vec3 p)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), TOO_FAR, TOO_FAR, 0.0, g_magen);\n    SDFResult res2 = SDFResult(TOO_FAR, MAGEN);\n    res2 = sceneSDF(p);\n#ifdef SLOW_NORMALS    \n    result.normal.x = sceneSDF(p + vec3(EPSILON, 0.0, 0.0)).dist - res2.dist;\n    result.normal.y = sceneSDF(p + vec3(0.0, EPSILON, 0.0)).dist - res2.dist;\n    result.normal.z = sceneSDF(p + vec3(0.0, 0.0, EPSILON)).dist - res2.dist;\n#else\n    result.normal = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1), ((i>>1)&1), (i&1))-1.0);\n        result.normal += e*sceneSDF(p+EPSILON*e).dist;\n    }\n#endif  \n    result.normal = normalize(result.normal);        \n    \n    SDFResult res = SDFResult(TOO_FAR, MAGEN);    \n    res = sceneSDF(p);\n            \n    result.mat=g_mats[res.matindex];\n        \n    result.pos = p;\n    result.t = res2.dist;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// quick light visualisation\n\nvec3 drawlights( Ray ray )\n{   \n    vec3 delta = g_light.pos - ray.pos;\n    vec3 closest = ray.pos + ray.dir*dot(delta, ray.dir);\n    float len = length(g_light.pos-closest);\n\n    vec3 colour = 0.5*g_light.colour/(len*300.0);\n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch world query\n\nResult raymarch_query(Ray ray, float maxdist)\n{\n    float mint=TOO_FAR;\n    float maxt=0.0;\n\tfloat travelled=0.0;\n    for (int i=0; i<MARCH_ITERATIONS; i++)\n    {\n    \tSDFResult res = sceneSDF(ray.pos);\n        \n      \tmaxt = max(maxt, res.dist);    \n       \tif (res.dist<maxt)    \n        {\n\t        mint = min(mint, res.dist);            \n        }\n                \n        ray.pos += res.dist*ray.dir; \n        travelled += res.dist;\n        \n        if (travelled>maxdist)\n            break;\n    }     \n    \n    Result result = resultSDF(ray.pos);\n    result.mint = mint;\n    result.travelled=travelled;\n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// raymarch light integrator\n\nvec3 raymarch(Ray inputray)\n{\n    const float exposure = 1e-2;\n    const float gamma = 2.2;\n    const float intensity = 100.0;\n    vec3 ambient = vec3(0.2, 0.3, 0.6) *6.0* intensity / gamma;\n\n    vec3 prevcolour = vec3(0.0, 0.0, 0.0);\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n    vec3 mask = vec3(1.0, 1.0, 1.0);\n    vec3 fresnel = vec3(1.0, 1.0, 1.0);\n    \n    Ray ray=inputray;\n        \n#ifdef LIGHTBULB    \n    vec3 lightpos = g_light.pos;\n#else\n    vec3 lightpos = -g_light.pos*200000000000.0;\t// 'directional'\n#endif\n    \n    for (int i=0; i<REFLECT_ITERATIONS; i++)\n    {\n        Result result = raymarch_query(ray, 10.0);\n\n        vec3 tolight = lightpos - result.pos;\n        tolight = normalize(tolight);\n                \n        if (result.t > NOT_CLOSE)\n        {\n#ifdef LIGHTBULB            \n            vec3 spotlight = drawlights(ray)*600.0;\n#else            \n            vec3 spotlight = vec3(1e4) * pow(clamp(dot(ray.dir, tolight),0.0,1.0), 75.0);\n#endif //LIGHTBULB           \n            \n//          ambient = texture(iChannel1, ray.dir).xyz*100.0;\n            ambient = mix(vec3(1.0, 1.0, 1.0), vec3(0.2, 0.2, 0.5), pow(abs(ray.dir.y), 0.5))*300.0;\n                       \n            colour += mask * (ambient + spotlight);                             \n            break;\n        }\n        else\n        {   \n            //result.mat.colour.rgb *= noise(ray.pos);\n\t\t\tprevcolour = result.mat.colour.rgb;\n            \n            vec3 r0 = result.mat.colour.rgb * result.mat.specular;\n            float hv = clamp(dot(result.normal, -ray.dir), 0.0, 1.0);\n            fresnel = r0 + (1.0 - r0) * pow(1.0 - hv, 5.0);\n            mask *= fresnel;            \n            \n            vec3 possiblelighting = clamp(dot(result.normal, tolight), 0.0, 1.0) * g_light.colour\n                    * result.mat.colour.rgb * result.mat.diffuse\n                    * (1.0 - fresnel) * mask / fresnel;\n            \n            if (length(possiblelighting) > 0.01f)\n            {\n                Ray shadowray = Ray(result.pos+result.normal*0.01, tolight);\n                Result shadowresult = raymarch_query(shadowray, length(lightpos - result.pos)*0.9);\n#ifdef SOFTSHADOWS                \n                colour += possiblelighting*clamp(shadowresult.mint*4.0, 0.0, 1.0);\n#else\n                if (shadowresult.travelled >= length(lightpos - result.pos)*0.9)\n                \tcolour += possiblelighting;\n#endif\n            }\n            \n            Ray reflectray;\n            reflectray.pos = result.pos + result.normal*0.02f;\n            reflectray.dir = reflect(ray.dir, result.normal);\n            ray = reflectray;\n        }\n    }\n        \n    colour.xyz = vec3(pow(colour * exposure, vec3(1.0 / gamma)));    \n    return colour;    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// Update trajectory and scaling\n\nAnimObj UpdateObj(float time)\n{\n    AnimObj obj;    \n    float t = time*3.5;\n    float trans = mod(t, 4.0*PI) / PI;\n    \n    float tt1 = floor(t/(2.0*PI));\n    float tt2 = floor(t/(2.0*PI))+1.0;\n    vec2 src = 1.0 - vec2(perlin(tt1*37.0, 1.0), perlin(tt1*37.0, 2.0))*2.0;\n    vec2 dst = 1.0 - vec2(perlin(tt2*37.0, 1.0), perlin(tt2*37.0, 2.0))*2.0;\n    \n    if (trans < 1.0)\n        trans = trans;\n    else if (trans <2.0)\n        trans = 1.0;\n    else if (trans<3.0)\n        trans = trans-2.0;\n    else\n        trans = 1.0;\n    \n    float mysin = sin(t);\n    float ypos = clamp(mysin, 0.0, 1.0) - 1.0;\n    float scale = 1.0 + clamp(mysin, -1.0, 0.0)*0.5;\n    \n    vec2 loc = mix(src, dst, trans);\n    \n    obj.pos = vec3(1.0 + loc.x*1.25, ypos, loc.y*0.0 + 0.25); \n    obj.centre = vec3(0.0, 0.6, 0.0);\n    obj.radius = 1.3;\n    obj.scale.x = 1.0/sqrt(scale);\n    obj.scale.y = scale;\n    obj.scale.z = 1.0/sqrt(scale);    \n    return obj;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{               \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA_X*MSAA_Y);\n    \n    // poo\n    AnimObj pp1,pp2,pp3;\n    pp1 = UpdateObj(iTime);\n    pp2 = UpdateObj(iTime+0.1);\n    pp3 = UpdateObj(iTime+0.2);\n    g_poo = pp1;\n    g_poo.pos = pp1.pos*0.4 + pp2.pos*0.3 + pp3.pos*0.3;\n    g_poo.scale = pp1.scale*0.4 + pp2.scale*0.3 + pp3.scale*0.3;\n\n    AnimObj qq1;\n    qq1 = UpdateObj(iTime*1.31 + 1234.0);\n\tg_poo2 = qq1;\n    g_poo2.pos *= 0.5;\n    g_poo2.pos.y -= 0.6;\n    g_poo2.pos.z -= 1.0;\n    g_poo2.scale *= 0.5;\n    g_poo2.radius *= 0.5;\n    g_poo2.centre *= 0.5;\n    g_poo2.pos += vec3(1.6, 2.0, 3.0);\n \n    \n    // light\n    vec3 pivot = g_lightpivot;\n    vec3 pos = g_lightpos;\n    pos.x += sin(iTime*2.0*1.5);\n    pos.z += cos(iTime*1.5);\n    pos = normalize(pos-pivot)*3.0 + pivot;\n    g_light.pos=pos;\n    \n    // materials\n    g_mats[TILES]=g_tiles;\n    g_mats[WHITE]=g_white;\n    g_mats[EYEBL]=g_eyebl;\n    g_mats[EYEWH]=g_eyewh;\n    g_mats[CHROM]=g_chrom;\n    g_mats[SIERP]=g_sierp;\n    g_mats[BROWN]=g_brown;\n    g_mats[GREY ]=g_grey;\n    g_mats[MAGEN]=g_magen;\n\n#ifdef FOLLOWCAM\n    // eval past camera path\n    float weight=0.0;\n    vec3 camtarget = vec3(0.0);\n    for (float t=-1.0; t<=0.0; t++)\n    {\n        AnimObj h = UpdateObj(iTime+t);\n\t    camtarget+=h.pos;\n        weight+=1.0;\n    }\n    camtarget.y*=0.3;\n    camtarget /= weight;\n#endif //FOLLOWCAM\n    \n    for (float x=0.0; x<MSAA_X; x++)\n    {\n        for (float y=0.0; y<MSAA_Y; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA_X))*x;\n            uv.y += (1.0/(iResolution.y*MSAA_Y))*y;\n            \n            Ray ray;\n            ray.pos = vec3(2.0, 0.0, -3.0);\n            ray.dir = uv.xyx;\n            ray.dir.z = 1.0;\n            ray.dir = normalize(ray.dir);\n            \n#ifdef FOLLOWCAM\n            vec3 p0 = vec3(1.0, 0.0, -2.5);\n            vec3 p1 = (camtarget + vec3(1.0, 0.25, 1.0))*0.5;\n            vec3 dir = (p1-p0);\n            dir = normalize(dir);\n            vec3 up = vec3(0.0, 1.0, 0.0);\n            up = normalize(up);\n            vec3 right = -cross(dir, up);\n            right = normalize(right);\n            up = -cross(right, dir);\n            up = normalize(up);  \n            \n            ray.pos = p0;\n            ray.dir = dir*1.0 + up*(uv.y + (1.0/(iResolution.y*MSAA_Y))*y) + right*(uv.x + (1.0/(iResolution.x*MSAA_X))*x);\n    \t\tray.dir = normalize(ray.dir);\n#endif //FOLLOWCAM\n            \n#ifdef DITHER            \n            float dither = hashfloat(uint(fragCoord.x+iResolution.x*fragCoord.y)+uint(iResolution.x*iResolution.y)*uint(iFrame));//Updated with iFrame dimension    \n            ray.pos += ray.dir*dither*0.1;\n#endif //DITHER            \n            \n            fragColor.xyz += raymarch(ray)*factor;            \n\t\t\tfragColor.xyz += drawlights(ray)*factor;\n    \t}        \n    }    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"///////////////////////////////////////////////////////////////////////////////////\n\n#define TOO_FAR 100000000.0\n#define NOT_CLOSE 4.0\n#define EPSILON 0.0001\n#define PI 3.14159\n\n///////////////////////////////////////////////////////////////////////////////////\n\nstruct AnimObj\n{\n\tvec3 pos;\n    vec3 scale;\n    vec3 rot;\n    vec3 centre;\n    float radius;\n};\n\nstruct Material {\n    vec3 colour;\n    float diffuse;\n    float specular;\n};\n    \nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    int matindex;\n};\n\nstruct Torus {\n    vec3 pos;\n    float ring;\n    float radius;\n    int matindex;\n};\n        \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n\nstruct Plane {\n    vec3 pos;\n    vec3 norm;\n    int matindex;\n};\n\nstruct RoundBox {\n    vec3 pos;\n    vec3 dimensions;\n    float radius;\n    int matindex;\n};\n\nstruct VertCap {\n    vec3 pos;\n    float height;\n    float radius;\n    int matindex;\n};\n        \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    float t;\n    float mint;\n    float travelled;\n    Material mat;\n};\n    \nstruct SDFResult\n{\n\tfloat dist;\n    int matindex;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nmat3 rotationmatrix(vec3 a)\n{\n    float cp=cos(a.x);\n    float sp=sin(a.x);\n    float cy=cos(a.y);\n    float sy=sin(a.y);\n    float cr=cos(a.z);\n    float sr=sin(a.z);\n    mat3 pitch = mat3(1, 0, 0, 0, cp, sp, 0, -sp, cp);\n    mat3 yaw = mat3(cy, 0, -sy, 0, 1, 0, sy, 0, cy);\n\tmat3 roll = mat3(cr, sr, 0, -sr, cr, 0, 0, 0, 1);\n    mat3 rotation = pitch*yaw*roll;    \n    return rotation;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// SDF's & other spatial query functions\n\nSDFResult opAdd( SDFResult r1, SDFResult r2 ) \n{\n\treturn SDFResult((r1.dist<r2.dist)?r1.dist:r2.dist, (r1.dist<r2.dist)?r1.matindex:r2.matindex);\n}\n\nSDFResult opSmoothAdd( SDFResult r1, SDFResult r2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(r2.dist-r1.dist)/k, 0.0, 1.0 );\n    SDFResult res;\n    res.dist = (mix( r2.dist, r1.dist, h ) - k*h*(1.0-h));\n    res.matindex = ((r2.dist>r1.dist)?r1.matindex:r2.matindex);\n    return res; \n}\n\nSDFResult opSmoothSub( SDFResult r1, SDFResult r2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(r2.dist+r1.dist)/k, 0.0, 1.0 );\n    SDFResult res;\n    res.dist = (mix( r2.dist, -r1.dist, h ) + k*h*(1.0-h));\n    res.matindex = ((r2.dist>r1.dist)?r1.matindex:r2.matindex);\n    return res; \n}\n\nSDFResult sphereSDF(Sphere sphere, vec3 p) \n{\n    vec3 diff = (sphere.pos - p);\n    diff.y *= 0.65;\n    return SDFResult(length(diff) - sphere.radius, sphere.matindex);\n}\n\nSDFResult sphereSDF2(Sphere sphere, vec3 p) \n{\n    vec3 delta = sphere.pos - p;\n    delta.xz += delta.y*delta.y*delta.y*10.0;\n    return SDFResult(length(delta) - sphere.radius, sphere.matindex);\n}\n\nSDFResult torusSDF( Torus torus, vec3 p )\n{\n    p -= torus.pos;\n    \n\tvec2 q = vec2(length(p.xz)-torus.ring,p.y);\n\treturn SDFResult(length(q)-torus.radius, torus.matindex);\n}\n\nSDFResult torusSDF2( Torus torus, vec3 p )\n{\n    p -= torus.pos;\n    \n    const float scale = 0.05;\n    float topdiff = clamp((0.1 - p.y), 0.0, scale);\n    float botdiff = clamp((p.y - ((p.x*p.x*2.0)-scale)), 0.0, scale);\n    \n    if ( topdiff>0.0 && botdiff>0.0 )\n    {\n        float v = min(topdiff, botdiff)/scale;\n        v = 3.0*v*v - 2.0*v*v*v;\n        p.z-=v*scale*0.5;\n    }\n    \n\tvec2 q = vec2(length(p.xz)-torus.ring,p.y);\n\treturn SDFResult(length(q)-torus.radius, torus.matindex);\n}\n\nSDFResult planeSDF( Plane plane, vec3 p )\n{\n    return SDFResult(dot(plane.norm, p) - dot(plane.pos, plane.norm), plane.matindex);\n}\n\nSDFResult roundboxSDF( RoundBox box, vec3 p )\n{\n    p -= box.pos;\n    vec3 d = abs(p) - box.dimensions;\n    SDFResult res;\n    res.dist = length(max(d,0.0)) - box.radius + min(max(d.x,max(d.y,d.z)),0.0);\n    res.matindex = box.matindex;\n    return res;\n}\n\nSDFResult vertcapSDF( VertCap cap, vec3 p )\n{\n    p -= cap.pos;\n    p.y -= clamp( p.y, 0.0, cap.height );\n    return SDFResult(length( p ) - cap.radius, cap.matindex);\n}\n\nSDFResult vertcapSDF2( VertCap cap, vec3 axis, vec3 p )\n{\n    p -= cap.pos;\n    float y = dot(axis, p);\n    p -= axis*clamp( y, 0.0, cap.height);\n    return SDFResult(length( p ) - cap.radius, cap.matindex);\n}\n\nSDFResult planeSDF2( Plane plane, vec3 p )\n{\n    float ly = dot((p-plane.pos), plane.norm);\n    vec3 local = p - (plane.pos + plane.norm*ly);\n    \n    float ridgex = mod(local.x, 1.0)-0.5;\n    float ridgey = mod(local.y, 1.0)-0.5;\n    float ridgez = mod(local.z, 1.0)-0.5;\n    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;\n    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;\n    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;\n    \n    return SDFResult(ly - ridgex - ridgey - ridgez, plane.matindex);\n}\n\nSDFResult boxSDF2( RoundBox box, vec3 p )\n{    \n    p -= box.pos;\n    vec3 d = abs(p) - box.dimensions;\n    float l = length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n\n    float ridgex = mod(p.x, 1.0)-0.5;\n    float ridgey = mod(p.y, 1.0)-0.5;\n    float ridgez = mod(p.z, 1.0)-0.5;\n    ridgex = clamp(ridgex*ridgex*10.0, 0.0, 0.005)*0.5;\n    ridgey = clamp(ridgey*ridgey*10.0, 0.0, 0.005)*0.5;\n    ridgez = clamp(ridgez*ridgez*10.0, 0.0, 0.005)*0.5;    \n \n    return SDFResult((l - ridgex - ridgey - ridgez), box.matindex);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat hashfloat( uint n ) \n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return float( n & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// IQ's sierpinski\n\nconst vec3 g_va = vec3(  0.0, -0.95,  0.0 );\nconst vec3 g_vb = vec3(  0.0, 0.55,  1.15470 );\nconst vec3 g_vc = vec3(  1.0, 0.55, -0.57735 );\nconst vec3 g_vd = vec3( -1.0, 0.55, -0.57735 );\n\nSDFResult sierSDF( vec3 p, int matindex, float time )\n{\n    mat3 rot = rotationmatrix(vec3(time, time*1.1, time*1.22));\n    vec3 va = rot * g_va * 0.7;\n    vec3 vb = rot * g_vb * 0.7;\n    vec3 vc = rot * g_vc * 0.7;\n    vec3 vd = rot * g_vd * 0.7;\n    \n    p -= vec3(2.0, 1.9, 2.0);\n    \n    if (length(p) > 1.2)\n        return SDFResult(TOO_FAR, matindex);\n    \n\tfloat a = 0.0;\n    float s = 1.0;\n    float r = 1.0;\n    float dm;\n    vec3 v;\n    for( int i=0; i<6; i++ )\n\t{\n\t    float d, t;\n\t\td = dot(p-va,p-va);              v=va; dm=d; t=0.0;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }\n        d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }\n        d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }\n\t\tp = v + 2.0*(p - v); r*= 2.0;\n\t}\n\t\n\treturn SDFResult(((sqrt(dm)-1.0)/r), matindex);\n}","name":"Common","description":"","type":"common"}]}