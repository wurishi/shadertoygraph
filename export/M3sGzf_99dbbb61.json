{"ver":"0.1","info":{"id":"M3sGzf","date":"1707788019","viewed":158,"name":"Crumbling Breach","username":"Cellulose","description":"A hexagonal grid is offset and sampled as a voronoi pattern.  I sample the difference between the two minimum distances and use it to generate cracks.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n\nvec2 project(vec2 a, vec2 b)    {return b * (dot(a,b) / dot(b,b));}\nvec2 reject (vec2 a, vec2 b)    {return a - project(a,b);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    \n    vec2 gridscale = vec2(.866, 1);\n    uv *= 8.0;\n   \n    uv += .03 * cos(3.0*sin(dot(uv.yx, vec2(3.6, 3.1))));\n    \n    \n    //uv.x *= 1.3;\n    ivec2 gridp = ivec2(round(uv.x/gridscale.x), round(uv.y/gridscale.y));\n    \n    \n    vec3 near1, near2;\n    near1.z = near2.z = 1000.0;\n    \n    ivec2 off;\n    for (off.x = -2; off.x <= 2; ++off.x)\n        for (off.y = -2; off.y <= 2; ++off.y)\n    {\n        ivec2 cell = gridp + off;\n        vec2 corner = vec2(cell)*gridscale;\n        corner.y += (mod(float(cell.x),2.0)<=0.5) ? -.25 : +.25;\n        vec2 center = corner + vec2(.5, .5)*gridscale;\n        \n        float ang = rand(.81*center) * 6.2831853072;\n        float offm = .5 * rand(corner);\n        \n        vec2 pt = center + offm * vec2(cos(ang), sin(ang));\n        \n        float dist = distance(uv, pt);\n        \n        if (dist < near1.z)\n        {\n            near2 = near1;\n            near1 = vec3(pt, dist);\n        }\n        else if (dist < near2.z)\n        {\n            near2 = vec3(pt, dist);\n        }\n    }\n    \n    // Project onto the voronoi line\n    vec2 mid = .5 * (near1.xy + near2.xy), orth = (near2.xy - near1.xy);\n    orth = vec2(orth.y, -orth.x);\n    \n    float center_dist = near1.z;\n    float surface_dist = -length(reject(uv-mid, orth));\n    \n    float circle_rad = (3.0 + 1.5 * sin(iTime));\n    float circle_dist = distance(uv, vec2(7,4));\n    \n    float dist = mix(center_dist, surface_dist,\n        clamp(circle_dist / circle_rad, 0.0, 1.0));\n    //dist += .25;\n       \n    dist += .2 - .16 * (circle_dist / circle_rad);\n    \n    //dist -= .3 * (distance(uv, vec2(7,4)) - circle_rad);\n    \n    \n    vec3 col = vec3(max(0.0, 20.0 * dist));\n    //col.r = max(0.0, 1.0-5.0*(near2.z-near1.z));\n    //col.g = near1.z;\n    \n    \n    //vec3 col = vec3(max(0.0, 1.0-5.0*(near2.z-near1.z))); // Crude dividing lines\n    \n    //vec3 col = vec3(max(0.0,\n    //    (30.0 + 15.0 * sin(iTime))-10.0*distance(uv, vec2(7,4))-20.0*sqrt(near2.z-near1.z)));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}