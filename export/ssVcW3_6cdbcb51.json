{"ver":"0.1","info":{"id":"ssVcW3","date":"1655753111","viewed":79,"name":"Manual Color Mapper","username":"MisterSirCode","description":"A fullscreen color mapping shader I made so I could align the brightness and colors of my screen on both sides perfectly.\n\nThis is really only useful for my specific monitor, but you may find it useful.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","screen","filter","color","map","mapping","brightness","tone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Color stuff obtained here: https://www.shadertoy.com/view/4dKcWK\n\n#define EPSILON 0.000001\n\nvec3 HUEtoRGB(float hue) {\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\nvec3 HSVtoRGB(vec3 hsv) {\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nvec3 RGBtoHCV(vec3 rgb) {\n    vec4 p = (rgb.g < rgb.b) ? vec4(rgb.bg, -1., 2. / 3.) : vec4(rgb.gb, 0., -1. / 3.);\n    vec4 q = (rgb.r < p.x) ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx);\n    float c = q.x - min(q.w, q.y);\n    float h = abs((q.w - q.y) / (6. * c + EPSILON) + q.z);\n    return vec3(h, c, q.x);\n}\n\nvec3 RGBtoHSV(vec3 rgb) {\n    vec3 hcv = RGBtoHCV(rgb);\n    float s = hcv.y / (hcv.z + EPSILON);\n    return vec3(hcv.x, s, hcv.z);\n}\n\n// Shader\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // Resolution dependent spherical gradient. Use for finding good black levels.\n    float sphere = length(uv * 1.5) - 0.5;\n    float lckSphr = clamp(sphere, 0.0, 1.0);\n    \n    // Resolution dependent lines. Useful for detail settings\n    float lines = ((cos(uv.y * (iResolution.y / 4.0)) + 1.0) / 2.0) < 0.5 ? 1.0 : 0.0; \n    \n    // Filter lines and gradient\n    float lineGrad = (sphere * -lines + 1.0) * smoothstep(0.0, 0.03, sphere + 0.05);\n    float whiteFilter = -(lines - lckSphr) + 1.0;\n    float satFilter = lines > 0.0 ? (lckSphr < 1.0 ? whiteFilter : 1.0) : 1.0;\n    \n    // Resolution dependent rainbow. Useful for color + brightness settings.\n    vec3 col = HSVtoRGB(vec3((uv.y + 1.0) / 2.0, satFilter, 1.0)); \n    \n    fragColor = vec4(abs(uv.x) > 1.0 ? col : col * lineGrad, 1.0);\n}","name":"Image","description":"","type":"image"}]}