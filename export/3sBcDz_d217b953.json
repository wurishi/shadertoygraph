{"ver":"0.1","info":{"id":"3sBcDz","date":"1586399483","viewed":55,"name":"menger--v6-sphere-v1","username":"jorge2017a1","description":"menger--v6-sphere-v1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["mengerv6spherev1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////modificado por jorge flores.p --\n//Gracias a ....Created by russ in 2017-03-06\n//https://www.shadertoy.com/view/XsfczB\n    \n\nconst int iter =80;\nconst float eps = 0.001, far = 20.;\nvec3 lDir0 = normalize(vec3(1,2,1)), lDir1 = normalize(vec3(-1,1.0,-2));\nvec3 lCol0 = vec3(1,.8,.5), lCol1 = vec3(.6,0.8,1); \n\n\n#define PI 3.1415926\n\n///-------------------------------------\nconst int MAX_RAY_STEPS = 64;\nconst float RAY_STOP_TRESHOLD = 0.0001;\nconst int MENGER_ITERATIONS = 5;\n///-------------------------------------\n\nfloat NumCol;\n\n\n\n\n\n//--------------------------------------------\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\nfloat sdCross(vec3 p) {\n\tp = abs(p);\n\tvec3 d = vec3(max(p.x, p.y),\n\t\t\t\t  max(p.y, p.z),\n\t\t\t\t  max(p.z, p.x));\n\treturn min(d.x, min(d.y, d.z)) - (1.0 / 3.0);\n}\n\nfloat sdCrossRep(vec3 p) {\n\tvec3 q = mod(p + 1.0, 2.0) - 1.0;\n\treturn sdCross(q);\n}\n\nfloat sdCrossRepScale(vec3 p, float s) {\n\treturn sdCrossRep(p * s) / s;\t\n}\n\n\n\n\nfloat differenceSDF(float distA, float distB) \n{\n    return max(distA, -distB);\n}\n\n\n//---------------------\n\nfloat sdSphere( vec3 p, float s1 )\n{\n   vec4 s = vec4(0, s1, 9, s1);\n   return  length(p-s.xyz)-s.w;   \n}\n\nvec2 opU(vec2 d1, vec2 d2 ) {\n  vec2 resp;\n    if (d1.x < d2.x){ \n        resp = d1;\n    }\n    else\n    {\n        resp = d2;\n    }\n     \n   return resp; \n}\n\n\nfloat diso( vec3 p)\n{\n    \n    vec2 res=vec2(9999.,0.0);\n    float dif1,dif2;\n\n    float sdsp1= sdSphere(p- vec3(0.0,4.0,0.0), 9.0 );\n    float sdsp2= sdSphere(p- vec3(0.0,4.0,0.0), 3.0 );\n     dif1 =differenceSDF(sdsp1, sdsp2);\n        \n    \n    \n    res=opU(res, vec2(dif1,6 ));\n\n   // d = res.x;\n    return res.x;\n}  \n\n//--------------------------\nfloat DE(vec3 p) {\n\t\n    float scale;\n    \n    if (mod(iTime,8.)>0.5 )\n    \t scale = 0.33;\n     else\n         scale = 0.43;\n    \n    vec2 res=vec2(9999.9,0.0) ;\n\n    float dist, dist1;\n     dist=-999.0;\n     dist =diso(p);\n \n    \n\tfor (int i = 0; i < MENGER_ITERATIONS; i++) {\n\t\tdist = max(dist, -sdCrossRepScale(p, scale));\n\t\tscale *= 3.0;\n\t}\n\n\n    \n    res=opU(res, vec2(dist,11.0) );\n    \n    NumCol =res.y;\n    \n\treturn res.x;\n}\n\n//oooooooooooooooooooooooooooooooooooooooooooooooooooo\n\n\n\nvec2 march(vec3 ro, vec3 rd){\n\tfloat t=0. , d = far, it = 0.;\n    for (int i=0;i<iter;i++){\n     \tt += (d = DE(ro+t*rd));\n        if(d<eps || t> far) break;\n        it += 1.;\n    }\n    return vec2(t,it/float(iter));\n}\n\nfloat getShadow(vec3 p, vec3 n, vec3 ld){\n    p +=  2. * eps * n;\n    float t=0.,d=far;\n    for(int i=0;i<50;i++){\n        t += (d=DE(p + t*ld));\n        if (d<eps || t>3.) break;\n    }\n    return t<=3. ? 0.1 : 1. ;\n}\n\nvec3 getRay(vec3 ro, vec3 look, vec2 uv){\n    vec3 f = normalize(look - ro);\n    vec3 r = normalize(vec3(f.z,0,-f.x));\n    vec3 u = cross (f,r);\n    return normalize(f + uv.x * r + uv.y * u);\n}\n\nvec3 getNorm(vec3 p){\n    vec2 e = vec2(eps, 0);\n    return normalize(vec3(DE(p+e.xyy)-DE(p-e.xyy),DE(p+e.yxy)-DE(p-e.yxy),DE(p+e.yyx)-DE(p-e.yyx)));\n}\n\nvec3 light(vec3 p, vec3 n){\n    vec3 col = vec3(0.01);\n    for(int i=0;i<2;i++){\n        vec3 ld = (i==0) ? lDir0 : lDir1;\n        float diff = max(dot(n, (ld)),0.);\n        diff *= getShadow(p, n, ld);\n        col += diff * (i==0 ? lCol0 : lCol1);\n    }\n    return col * .7;\n}\n//----------------------------------------------------\n\n// Single rotation function - return matrix\nmat2 r2(float a){ \n  float c = cos(a); float s = sin(a); \n  return mat2(c, s, -s, c); \n}\n//--------------------\n\n// iMouse pos function - take in a vec3 like ro\n// simple pan and tilt and return that vec3\nvec3 get_mouse(vec3 ro) {\n    float x = iMouse.xy==vec2(0) ? -.2 :\n    \t(iMouse.y / iResolution.y * .5 - 0.25) * PI;\n    float y = iMouse.xy==vec2(0) ? .0 :\n    \t-(iMouse.x / iResolution.x * 1.0 - .5) * PI;\n    float z = 0.0;\n\n    ro.zy *= r2(x);\n    ro.zx *= r2(y);\n    \n    return ro;\n}\n\n//----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float time = iTime * 0.5;\n   vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n    \n  \n\n    vec3 ro = vec3(0.0,6.5,8.0+ 6.0*cos(iTime*0.5+3.0));\n\n\tvec3 rd =normalize(vec3(uv,1.0) );\n\n\n    vec2 hit = march(ro, rd);\n    vec3 p = ro + hit.x*rd;\n    \n    vec3 col = hit.x<far ? light(p, getNorm(p)) : vec3(.1*(1.-length(uv)));\n    \n    col += pow(hit.y,3.);\n\tfragColor = vec4(sqrt(col),1.0);\n}","name":"Image","description":"","type":"image"}]}