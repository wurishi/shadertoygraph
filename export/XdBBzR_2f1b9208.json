{"ver":"0.1","info":{"id":"XdBBzR","date":"1499012437","viewed":1350,"name":"Ray-marching metaballs","username":"dcbrwn","description":"Based on work:\n\nhttp://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\nhttp://iquilezles.org/articles/distfunctions/distfunctions.htm","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision mediump float;\n\nconst int MAX_MARCHING_STEPS = 64;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n  float c = cos(theta);\n  float s = sin(theta);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\n\n/**\n * Signed distance function for a sphere centered at the origin with radius r.\n */\nfloat sphereSDF(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n/**\n * Signed distance function describing the scene.\n */\nfloat sceneSDF(vec3 samplePoint) {\n  float ballRadius = 1.0;\n  float t = iTime / 3.0 + 10500.0;\n  float balls = MAX_DIST;\n  for (float i = 1.0; i < 4.0; i += 1.3) {\n    for (float j = 1.0; j < 4.0; j += 1.3) {\n      float cost = cos(t * j);\n      balls = smin(balls, sphereSDF(samplePoint + vec3(sin(t * i) * j, cost * i, cost * j), ballRadius), 0.7);\n    }\n  }\n\n  return balls;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n *\n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n  float depth = start;\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    float dist = sceneSDF(eye + depth * marchingDirection);\n    if (dist < EPSILON) {\n      return depth;\n    }\n    depth += dist;\n    if (depth >= end) {\n      return end;\n    }\n  }\n  return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldOfView) / 2.0);\n  return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n  return normalize(vec3(\n    sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n    sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n    sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n  ));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n  // Based on gluLookAt man page\n  vec3 f = normalize(center - eye);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 viewDir = rayDirection(90.0, iResolution.xy, gl_FragCoord.xy);\n  vec3 eye = rotateY(iTime / 3.0) * vec3(3.0, 3.0, 10.0);\n  mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n  vec3 worldDir = viewToWorld * viewDir;\n  float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n\n  if (dist > MAX_DIST - EPSILON) {\n    fragColor = texture(iChannel0, worldDir, 0.0);\n    return;\n  }\n\n  vec3 p = eye + dist * worldDir;\n  vec3 normal = estimateNormal(p);\n  vec4 tex = texture(iChannel0, reflect(worldDir, normal), 0.0);\n\n  fragColor = (tex + (normal.y / 2.0 - 0.2)) * vec4(1.0, 0.8, 0.6, 1.0);\n}","name":"Image","description":"","type":"image"}]}