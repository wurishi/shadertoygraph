{"ver":"0.1","info":{"id":"4lXyRf","date":"1505868227","viewed":740,"name":"Visualizing 2D dot products","username":"etale_cohomology","description":"Part of the video tutorial: youtube.com/watch?v=hYPuXCYOH48","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["2d","math","tutorial","space","vector","dot","product"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Part of the video tutorial: youtube.com/watch?v=hYPuXCYOH48\n\n#define SCALE 2.\n#define FSAA (SCALE * 4. / iResolution.y)\n#define GRID_REPEAT 1.\n\n#define RGB_DARK  vec3(.04)\n#define RGB_LIGHT vec3(.96)\n#define RGB_GRAY  vec3(.5)\n#define RGB_RED   vec3(1., .4, .4)\n#define RGB_BLUE  vec3(.0, .5, 1.)\n#define RGB_PURP  vec3(.8, .4, 1.)\n\nfloat op_join(float a, float b){\n    return min(a, b);\n}\n\nfloat vproj_scalar(vec2 vec_a, vec2 vec_b){\n    return dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\n\nvec2 vproj(vec2 vec_a, vec2 vec_b){\n    return vproj_scalar(vec_a, vec_b) * vec_b;\n}\n\nvec2 vproj01(vec2 vec_a, vec2 vec_b){\n    return clamp(vproj_scalar(vec_a, vec_b), .0, 1.) * vec_b;\n}\n\nfloat df_line(vec2 uv, vec2 vec_a, vec2 vec_b, float thickness){\n    vec2 vec_ap = uv    - vec_a;\n    vec2 vec_ab = vec_b - vec_a;\n    return distance(vec_ap, vproj(vec_ap, vec_ab)) - thickness;\n}\n\nfloat df_segment(vec2 uv, vec2 vec_a, vec2 vec_b, float thickness){\n    vec2 vec_ap = uv    - vec_a;\n    vec2 vec_ab = vec_b - vec_a;\n    return distance(vec_ap, vproj01(vec_ap, vec_ab)) - thickness;\n}\n\n// ------------------------------------------------------------------------------------------------ \n#define ARROW_THICKNESS .01\n#define ARROW_HEAD_LEN  .05\n\n#define PI  3.14159\n#define TAU (2. * PI)\n#define XI  (.5 * PI)\n\n#define rot2D(t) mat2(cos(t), sin(t), -sin(t), cos(t))\n\nstruct Arrow{\n    vec2  pos;    // Position!\n    float norm;   // Magnitude/length!\n    float angle;  // Angle!\n};\n\nconst Arrow ARROW_DEFAULT = Arrow(vec2(.0, .0), 1., XI);\n\n// An arrow made of 3 line segments!\nfloat arrow_draw(vec2 uv, Arrow arrow){\n    vec2 arrow_uv = uv - arrow.pos;\n    arrow_uv *= rot2D(arrow.angle);\n\n    vec2 head_end = vec2(arrow.norm, .0);\n    float norm_sign = sign(arrow.norm);\n\n    float stem = df_segment(arrow_uv, vec2(.0, .0), head_end, ARROW_THICKNESS);\n\n    float head_len = min(ARROW_HEAD_LEN, norm_sign * arrow.norm);\n    float head_left  = df_segment(arrow_uv, head_end, head_end + vec2(-norm_sign * head_len, +norm_sign * head_len), ARROW_THICKNESS);\n    float head_right = df_segment(arrow_uv, head_end, head_end + vec2(-norm_sign * head_len, -norm_sign * head_len), ARROW_THICKNESS);\n    float head = op_join(head_left, head_right);\n\n    float arrow_full = op_join(stem, head);\n    return smoothstep(FSAA, .0, arrow_full);\n}\n\nvec2 arrow_polar2rect(Arrow arrow){\n    return arrow.norm * vec2(cos(arrow.angle), sin(arrow.angle));\n}\n\nfloat arrow_vproj_scalar(Arrow arrow0, Arrow arrow1){\n    vec2 arrow0_rect = arrow_polar2rect(arrow0);\n    vec2 arrow1_rect = arrow_polar2rect(arrow1);\n    return dot(arrow0_rect, arrow1_rect) / dot(arrow1_rect, arrow1_rect);\n}\n\nfloat arrow_dot(Arrow arrow0, Arrow arrow1){\n    vec2 arrow0_rect = arrow_polar2rect(arrow0);\n    vec2 arrow1_rect = arrow_polar2rect(arrow1);\n    return dot(arrow0_rect, arrow1_rect);\n    //return arrow0.norm * arrow1.norm * cos(arrow0.angle - arrow1.angle);\n}\n\n// ------------------------------------------------------------------------------------------------ \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = SCALE * (2. * fragCoord.xy - iResolution.xy) / iResolution.y;  // [-1; 1]\n\n    // Axes!\n    float axis_x = df_line(uv, vec2(0, 0), vec2(1, 0), .01);\n    float axis_y = df_line(uv, vec2(0, 0), vec2(0, 1), .01);\n    float axes = smoothstep(FSAA, .0, op_join(axis_x, axis_y));\n\n    // Grid!\n    float half_repeat = .5 * GRID_REPEAT;\n    vec2 grid_uv = mod(uv - half_repeat, GRID_REPEAT) - half_repeat;\n    float grid_x = df_line(grid_uv, vec2(0, 0), vec2(1, 0), .001);\n    float grid_y = df_line(grid_uv, vec2(0, 0), vec2(0, 1), .001);\n    float grid = smoothstep(FSAA, .0, op_join(grid_x, grid_y));\n\n    Arrow arrow0 = ARROW_DEFAULT;\n    Arrow arrow1 = ARROW_DEFAULT;\n    Arrow arrow2 = ARROW_DEFAULT;\n\n    arrow0.angle = .5 * iTime;\n    arrow1.angle = .1 * PI;\n    arrow2.angle = arrow1.angle;\n    arrow0.norm = 1.1;\n    arrow1.norm = 2.2;\n    arrow2.norm = arrow_vproj_scalar(arrow0, arrow1) * arrow1.norm;\n\n    float dot_product = df_segment(uv, vec2(0, 0), vec2(arrow_dot(arrow0, arrow1), 0), .01);\n    dot_product = smoothstep(FSAA, .0, dot_product);\n\n    vec3 scene = RGB_DARK;\n    scene = mix(scene, RGB_GRAY, grid);\n    scene = mix(scene, RGB_LIGHT, axes);\n    scene = mix(scene, RGB_RED,   arrow_draw(uv, arrow0));\n    scene = mix(scene, RGB_BLUE,  arrow_draw(uv, arrow1));\n    scene = mix(scene, RGB_LIGHT, arrow_draw(uv, arrow2));\n    scene = mix(scene, RGB_PURP,  dot_product);\n\tfragColor.rgb = scene;\n}\n","name":"Image","description":"","type":"image"}]}