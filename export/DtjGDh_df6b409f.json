{"ver":"0.1","info":{"id":"DtjGDh","date":"1673249392","viewed":86,"name":"Sliding Mondrian Rectangles","username":"D_Bbomb","description":"Some sort of Mondrian-inspired rectangle thing that I thought might look neat.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["mondrian"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HOLD_TIME_S (1.5)\n#define CHANGE_TIME_S (1.0)\n#define TIME_TOTAL_S (HOLD_TIME_S+CHANGE_TIME_S)\n#define HOLD_PER (HOLD_TIME_S/TIME_TOTAL_S)\n\n#define MAX_LINES (10.)\n#define MAX_BLOCKS (4.)\n#define BAR_DIMS (2.)\n#define TOTAL_FRAND (BAR_DIMS+MAX_LINES+MAX_BLOCKS)\n\n#define ZONE_HEIGHT (0.2)\n#define ZONE_WIDTH  (0.15)\n\nfloat rand(float x) {\n    return fract(sin(x+0.211231f)*43758.5453123);\n}\n\nfloat frand(float x, float item) {\n    return rand(floor(x) * TOTAL_FRAND + item);\n}\n\nfloat rect(vec2 pos, vec2 size, vec2 coord) {\n    vec2 h = size*.5;\n    return smoothstep(h.x+0.0015, h.x-0.0015, abs(coord.x - pos.x))\n         * smoothstep(h.y+0.0015, h.y-0.0015, abs(coord.y - pos.y));\n}\n\nfloat vbar(float b, float t) {\n    const float bars = 4.;\n    return frand(t, floor(b*bars)/bars)*\n        (2.*ZONE_WIDTH)-ZONE_WIDTH;\n}\n\nfloat hbar(float b, float t) {\n    const float bars = 6.;\n    return frand(t, 1. + floor(b*bars)*bars)*\n        (2.*ZONE_HEIGHT)-ZONE_HEIGHT;\n}\n\nvec4 line_rect(float rect_i, float t) {\n    float n = 2.+rect_i;\n    vec4 p = vec4(frand(t,n), frand(t,n+0.25), frand(t,n+0.50), frand(t,n+0.75));\n    vec4 r = vec4(0.);\n\n    if(p.x > .5) {\n        float vb = vbar((p.x-.5)*2.,t);\n        float h = p.z*ZONE_HEIGHT*1.1;\n        r.xy = vec2(vb, p.w*ZONE_HEIGHT*0.5);\n        r.zw = vec2(p.y*0.01, h);\n    } else {\n        float hb = hbar(p.x*2.,t);\n        float w = p.z*ZONE_WIDTH*1.1;\n        r.xy = vec2(p.w*ZONE_WIDTH*0.5, hb);\n        r.zw = vec2(w, p.y*0.01);\n    }\n    \n    return r;\n}\n\nvec4 box_rect(float rect_i, float t) {\n    float n = (BAR_DIMS+MAX_LINES)+rect_i;\n    vec4 p = vec4(frand(t,n), frand(t,n+0.1), frand(t,n+0.2), frand(t,n+0.3));\n    \n    float b1 = vbar(p.x, t);\n    float b2 = vbar(p.y, t);\n    float b3 = hbar(p.z, t);\n    float b4 = hbar(p.w, t);\n    \n    return vec4(\n        (b1+b2)*.5, (b3+b4)*.5,\n        abs(b2-b1), abs(b3-b4)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    //vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x;\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.x;\n\n    // Time stepping\n    float t = iTime / TIME_TOTAL_S;\n    t = smoothstep(HOLD_PER,1.,fract(t))+floor(t);\n\n    float b_rects = 0.;\n\n    float pt = fract(t);\n    for(int i=0; i<int(MAX_LINES); i++) {\n        vec4 r0 = line_rect(float(i), t);\n        vec4 r1 = line_rect(float(i), t+1.);\n        \n        b_rects = max(b_rects, rect(\n            mix(r0.xy, r1.xy, pt),\n            mix(r0.zw, r1.zw, pt),\n            uv)\n        );\n    }\n    \n    vec3 col = vec3(1.,1.,0.94);\n    for(int i=0; i<int(MAX_BLOCKS); i++) {\n        vec4 r0 = box_rect(float(i), t);\n        vec4 r1 = box_rect(float(i), t+1.);\n        \n        \n        float v = rect(\n            mix(r0.xy, r1.xy, pt),\n            mix(r0.zw, r1.zw, pt),\n            uv\n        );\n        \n        float n = (BAR_DIMS+MAX_LINES)+float(i);\n        vec3 c0 = vec3(frand(t,n+0.4),frand(t,n+0.5),frand(t,n+0.6));\n        vec3 c1 = vec3(frand(t+1.,n+0.4),frand(t+1.,n+0.5),frand(t+1.,n+0.6));\n        \n        col -= mix(c0,c1,pt) * v;\n    }\n    \n    col = vec3(col-b_rects);\n    \n    col -= 1.-rect(vec2(0.), vec2(ZONE_WIDTH*2.4, ZONE_HEIGHT*2.4), uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}