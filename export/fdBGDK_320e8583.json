{"ver":"0.1","info":{"id":"fdBGDK","date":"1617927137","viewed":84,"name":"softshadow test","username":"tono","description":"softshadow","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float    bo(vec3 p,vec3 s){p = abs(p) - s;return max(p.x,max(p.y,p.z));}\nfloat inBox(vec3 p,vec3 s){p = abs(p) - s;return min(p.x,min(p.y,p.z));}\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat pi = acos(-1.);\nfloat smoothmin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\n\nvec3 pointlight = normalize(vec3(2.,0.,-6.));\n\nvoid initP()\n{\n    pointlight.xz *= rot(iTime);\n}\n\n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n//float id = 0.;\n\nvec2 map(vec3 p)\n{\n    float o = 0.;\n    float id = 0.;\n    p.xy *= rot(iTime/4.7);\n    p.xz *= rot(iTime/5.1);\n    p.yz *= rot(iTime/6.);\n    float box = bo(p,vec3(1.));\n    float s = 5.1;\n    float w = 70.;\n    //o = min( min(abs(p.z + s),abs(p.z - s)),min(min(abs(p.x + s),abs(p.x - s)),min(abs(p.y + s),abs(p.y - s))));\n    \n    vec3 p1 = p;\n    vec3 p2 = p;\n    vec3 p3 = p;\n    p1.x = abs(p.x) - s;\n    box = bo(p1 , vec3(1.,w,w));\n    p2.y = abs(p.y) - s;\n    box = min(box, bo(p2 , vec3(w,1.,w)));\n    p3.z = abs(p.z) - s;\n    box = min(box, bo(p3 , vec3(w,w,1.)));\n    \n    o = box;\n    //if(o < 1.)\n    //{\n    //    o -= snoise(p * 10.)/110.;\n    //}\n    \n    \n    //o = bo(p , vec3(100.));\n    //o = max(-o,length(p) - 6.);\n    float t = floor(iTime) + pow(fract(iTime),1.);\n    vec3 op = p - vec3(sin(t),cos(t),cos(t))/1.;\n    float sph = length(op) - .6;\n    vec3 op2 = p - vec3(cos(t),1. -sin(t + pi/6.),sin(t))/1.;\n    float sph2 = length(op2) - .7;\n    vec3 op3 = p - vec3(cos(t + pi/6.),sin(t ),sin(t))/1.;\n    float sph3 = length(op3) - .4;\n    sph = smoothmin(sph ,sph2,4.);\n    sph = smoothmin(sph ,sph3,6.);\n    o = min(o,sph);\n    if(o < 1.)\n    {\n        o -= snoise(p * 10.)/110.;\n    }\n    float pl = length(p - pointlight) - .1;\n    \n    if(o > pl)\n    {\n        //o = pl;\n        id = 1.;\n    }\n    o = min(o,0.08);\n    return vec2(o,id);\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    float depth = 0.;\n    float id = 0.;\n    for(int i = 0 ; i < 128 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.01)\n        {\n            return vec2(depth , d.y);\n        }\n        id = d.y;\n        depth += d.x;\n    }\n    return vec2(-depth , id);\n}\n\n//https://www.shadertoy.com/view/tlXBRl\nfloat calculateObstruction(vec3 pos, vec3 lpos, float lrad)\n{\n    // A homemade algorithm to compute obstruction\n    // Raymarch to the light source, and\n    // record the largest obstruction.\n    // We assume that if the ray passes through an object at depth\n    // d (negative distance), then the object obstructs light\n    // proportional to the relative size of d projected on the light\n    // as given by Thales's theorem.\n    vec3 toLight = normalize(lpos-pos);\n    float distToLight = length(lpos-pos);\n    float d, t=lrad*.1;\n    float obstruction=0.;\n    for(int j=0; j<128; j++)\n    {\n        d = map(pos + t*toLight).x;\n        obstruction = max(.5+(-d)*distToLight/(2.*lrad*t), obstruction);\n        if(obstruction >= 1.){break;}\n        // If we're stuck, advance by the characteristic \n        // size of an obstructing object\n        t += max(d, lrad*t/distToLight);\n        if(t >= distToLight) break;\n    }\n    return clamp(obstruction, 0.,1.);\n}\n\n\nconst int SOFT_SHADOW_STEPS = 50;\nfloat getSoftShadowFactor(vec3 point, vec3 light)\n{\n\tvec3 rd = normalize(light - point);\n\tvec3 ro = point;\n\tfloat maxt = distance(light, point);\n\tfloat t = 0.01;\n    float res = 1.0;\n\tconst float k = 3.0;\n    for( int i = 0; i <  SOFT_SHADOW_STEPS; i++)\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001)\n            return 0.0;\n\t\t\n\t\tres = min( res, k*h/t );\t\t\n        t += h;\n\t\t\n\t\tif(t > maxt)\n\t\t\treturn res;\n    }\n    return res;\n}\n\n//\tSimplex 3D Noise \n\n\nfloat getshadow(vec3 pos, vec3 N , vec3 lpos)\n{\n    vec3 ldir = normalize(pos - lpos);\n    vec3 ro = pos + N * 0.01;\n    float depth = 0.;\n    for(int i = 0 ; i < 256 ; i++)\n    {\n        ro = ro + ldir * snoise(ro * 70.) * 0.01;\n        float d = map(ro).x;\n        if(d < 0.01)\n        {\n            //return smoothstep( 0.,1.,log(1./(length(lpos - ro) + 1.)));\n            //return log((length(lpos - ro) + 1.))/5.;\n            return smoothstep(0.,1.,-log(1./(length(lpos - ro) + 1.))/5.);\n        }\n    }\n    return 1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 col = vec3(0.);\n    vec3 cp = vec3(0.,0.,-3.);\n    vec3 target = vec3(0.,0.,0.);\n    vec3 cd = normalize(target -cp);\n    vec3 cs = normalize(cross(vec3(0.,1.,0.),cd));\n    vec3 cu = normalize(cross(cs,cd));\n    \n    float fov = 1.3 - dot(p,p);\n    fov = 1.;\n    vec3 rd = normalize(cd * fov + cs * p.x + cu * p.y);\n    initP();\n    vec2 d = march(cp,rd);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = cp + rd * d.x;\n        vec2 e = vec2(0.001,0.);\n        vec3 N = -normalize(map(pos).x - vec3(map(pos - e.xxy).x , map(pos - e.xyx).x,map(pos - e.yxx).x));\n        // vec3 pointlight = normalize(vec3(12.,0.,0.));\n        // pointlight.xz *= rot(time);\n        vec3 ldir = normalize(pos - pointlight);\n        float lrad = 0.2;\n        float distToLight = length(pointlight + lrad - pos);\n        float lightStrength = 35.;\n        float diff = max(0.,dot(ldir,N))/(distToLight*distToLight)*lightStrength;\n        float sp = max(0.,dot(reflect(ldir,N) , -rd));\n        diff = mix(diff,  1. , 0.);\n        sp = pow(sp , 12.);\n        \n        if(d.y == 0.)\n        {\n            col = vec3(0.,.5,1.);\n        }\n        else if(d.y == 1.)\n        {\n            col = vec3(1.);\n        }\n        \n       // float shadow = step(march(pos + N * 0.001 , ldir).x,0.);\n        float obstruction = calculateObstruction(pos,pointlight,lrad);\n        float level = diff * (1. - obstruction);\n        col = level * col + sp * col;\n        col = 1.-exp(-2.*col);\n    }\n    col = clamp(col,0.,1.);\n   // col = normalize(col);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}