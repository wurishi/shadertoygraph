{"ver":"0.1","info":{"id":"MdByWw","date":"1499024786","viewed":1262,"name":"worms wood","username":"balkhan","description":" ","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n#define I_MAX   100\n#define E       0.001\n\n#define LPOS\tvec3(0., 0., 0.)\n#define L2\t\tvec3(+cos(t*1.)*3.,2.0,-0.+sin(t*1.)*3.)\n\n//#define SPIRAL\n\nvoid      rotate(inout vec2 v, float angle);\nfloat     sdTorus( vec3 p, vec2 t );\nvec2      march(vec3 pos, vec3 dir);\nvec3      camera(vec2 uv);\nvec3      blackbody(float Temp);\nfloat     scene(vec3 p);\n\nfloat     t; // time\nvec3      h;\nconst vec3      lightCol = vec3(1.,.7,.51);\n\n// blackbody by aiekick : https://www.shadertoy.com/view/lttXDn\n\n// -------------blackbody----------------- //\n\n// return color from temperature\n//http://www.physics.sfasu.edu/astro/color/blackbody.html\n//http://www.vendian.org/mncharity/dir3/blackbody/\n//http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html\n\nvec3 blackbody(float Temp)\n{\n        vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n    col.y = 100.04 * log(Temp) - 623.6;\n    if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n    col.z = 194.18 * log(Temp) - 1448.6;\n    col = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n    return col;\n}\n\n// -------------blackbody----------------- //\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n        vec2 d = abs(vec2(length(p.xy),p.z )) - h;\n        return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// sebH's volumetric light : https://www.shadertoy.com/view/XlBSRz\n\n// ------------volumetric light----------- //\n\n\nvec3 evaluateLight(in vec3 pos)\n{\n    float distanceToL = length(LPOS-pos);\n    float distanceToL2 = length(L2-pos);\n    return (\n           +lightCol * 1.0/(distanceToL2*distanceToL2)\n           );\n}\n\n// ------------volumetric light----------- //\n\n\n// spiral by FabriceNeyret : https://www.shadertoy.com/view/ldBGDc\n\n// -------------spiral--------------------- //\n\nfloat spiral(vec2 m) {\n      float r = length(m);\n      float a = atan(m.y, m.x);\n      float v = sin(100.*(sqrt(r)-0.02*a-.3*t*1.));\n      return clamp(v,0.,1.);\n\n}\n\n// -------------spiral--------------------- //\n\nfloat   de_0(vec3 p)\n{\n    float   ming = 1e5;\n    float   a = ( (t+p.z *.515)  ) * 1.;\n    vec3    pr = p;\n\trotate(pr.yz, t);\n\n    #ifndef SPIRAL\n    ming = length( (pr.zy) )-1.5+.051*spiral(.05*( pr.xy) )-(.5*length(pr)-2.1);\n    #else\n    ming = length( (pr.zy) )-1.5+.051*spiral(.1075*( pr.xy) )-(.5*length(pr)-1.31);\n    #endif\n    return (ming);\n}\n\nfloat   scene(vec3 p)\n{\n    float       mind = length(p-L2)-.1;\n    p.y += 2.;\n    mind = min(mind, de_0(vec3(p.x,p.z,p.y) ));\n    return mind;\n\n}\n\nvec2    march(vec3 pos, vec3 dir)\n{\n    vec2        dist = vec2(0.0);\n    vec3        p = vec3(0.0);\n    vec2        s = vec2(0.0);\n\n    vec3        dirr;\n    for (int i = 0; i < I_MAX; ++i)\n    {\n      dirr = dir;\n        rotate(dirr.zx, .05*dist.y);\n\n        p = pos + dirr * dist.y;\n        dist.x = scene(p);\n        dist.y += dist.x;\n        h+= evaluateLight(p);\n        if (dist.x < E )\n        {\n           break;\n        }\n        s.x++;\n    }\n    s.y = dist.y;\n    return (s);\n}\n\nvoid mainImage(out vec4 o, in vec2 f )\n{\n    o -= o;\n    h = vec3(0.);\n    t = iTime*.5;\n    vec2 R = iResolution.xy,\n          uv  = vec2(f-R/2.) / R.y;\n    vec3  dir = camera(uv);\n    vec3  pos = vec3(.0, 0., 7.0);\n    vec2  inter = (march(pos, dir));\n    o.xyz += h*1.;\n    o.xyz += .25*blackbody(( (inter.y) )*150.);\n}\n\n// Utilities\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.zy)-t.x,p.x);\n\n    return length(q)-t.y;\n}\n\nvec3    camera(vec2 uv)\n{\n    float   fov = 1.;\n    vec3    forw  = vec3(0.0, 0.0, -1.0);\n    vec3    right = vec3(1.0, 0.0, 0.0);\n    vec3    up    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n\nvoid rotate(inout vec2 v, float angle)\n{\n        v = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}","name":"Image","description":"","type":"image"}]}