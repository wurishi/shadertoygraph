{"ver":"0.1","info":{"id":"DtKBDK","date":"1702502295","viewed":33,"name":"Fork Rod Refraction v2","username":"mehow_one","description":"Emulation of optic refraction through glass rods.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["noise","refraction","glass"],"hasliked":0,"parentid":"mtBXRh","parentname":"Rod Refracted Noise"},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n#define PI 3.141528\n\nconst float refractIndex = .5;\n\n\nvec3 hsv(float h,float s,float v){return ((clamp(abs(fract(h+vec3(0.,.666,.333))*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;}\n\nfloat map(float val, float inA, float inB, float outA, float outB) {\n  return (val - inA) / (inB - inA) * (outB - outA) + outA;\n}\n\nfloat fresnel(vec3 direction, vec3 normal, float power, bool invert) {\n    vec3 halfDirection = normalize( normal + direction );\n    float cosine = dot( halfDirection, direction );\n    float product = max( cosine, 0.0 );\n    float factor = invert ? 1.0 - pow( product, power ) : pow( product, power );\n    return factor;\n}\nvec4 remapShadows(vec4 color) {\n  float factor = 12.;\n  return vec4(\n    pow(color.x, factor),\n    pow(color.y, factor),\n    pow(color.z, factor),\n    color.w\n  );\n}\nfloat specular(vec3 eyeVector, vec3 worldNormal, vec3 light, float shininess, float diffuseness) {\n  vec3 normal = worldNormal;\n  vec3 lightVector = normalize(-light);\n  vec3 halfVector = normalize(eyeVector + lightVector);\n  float NdotL = dot(normal, lightVector);\n  float NdotH =  dot(normal, halfVector);\n  float kDiffuse = max(0.0, NdotL);\n  float NdotH2 = NdotH * NdotH;\n  float kSpecular = pow(NdotH2, shininess);\n  return kSpecular + kDiffuse * diffuseness;\n}\n\n\nvec3 dispersion(vec2 pos,vec3 rd,vec3 normal,vec2 uv){\n    \n    \n    float uIor = 1./1.188;\n    vec3 color = vec3(0.0);\n    vec3 eye = rd;\n    float uChromaticAberration = refractIndex;\n    float uRefractPower = 1.0;\n    int LOOP = 8;\n    for (int i = 0; i < LOOP; i++) {\n    float slide = (float(i) / float(LOOP)) * 0.825;\n      vec3 refractVec = mix(normal, rd, uIor);\n      float r = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 0.5;\n      float y = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 +\n                 texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y * 2.0 -\n                 texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z) / 6.0;\n      float g = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.0) * uChromaticAberration).y * 0.5;\n      float c = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).y * 2.0 +\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).z * 2.0 -\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 2.5) * uChromaticAberration).x) / 6.0;\n      float b = texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 3.0) * uChromaticAberration).z * 0.5;\n      float p = (texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).z * 2.0 +\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).x * 2.0 -\n             texture(iChannel1, uv + refractVec.xy * (uRefractPower + slide * 1.0) * uChromaticAberration).y) / 6.0;\n\n      float re = r + (2.0*p + 2.0*y - c)/3.0;\n      float gr = g + (2.0*y + 2.0*c - p)/3.0;\n      float bl = b + (2.0*c + 2.0*p - y)/3.0;\n\n      color.r += re;\n      color.g += gr;\n      color.b += bl;\n      //color += remapShadows(vec4(color,1.)).rgb*.000125;\n  \n}\n    color /= float(LOOP);\n    \n    return color;\n    \n}\n\nvec4 sampleBackground(vec3 normal, sampler2D bg) {\n  // x = rho sin(phi) cos(theta)\n  // y = rho cos(phi)\n  // z = rho sin(phi) sin(theta)\n  // rho = 1 after normalization\n  float phi = acos(normal.y);\n  float sinPhi = sin(phi);\n  float theta =\n    abs(sinPhi) > 0.0001\n      ? acos(normal.x / sinPhi)\n      : 0.;\n  vec2 coord = vec2(\n    map(theta, 0., PI, 0., 1.),\n    map(phi, 0., PI, 1., 0.)\n  );\n    \n  return texture(bg, coord);\n}\n\n\n\nfloat lambert(vec3 normal, vec3 lightPos)\n{\n\treturn max(dot(normal, lightPos), 0.05);\n}\n\n\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    x = x * 1.5;\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / R.xy;\n    vec2 p = (2.0*fragCoord - R.xy)/R.y;\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n\n    // define  \"glass rods\" and normals\n    float rod_x = fract(p.x * 4.0) * 2.0 - 1.0;\n    float rod_z = sqrt(1.0 - rod_x*rod_x);\n    vec3 n = vec3(rod_x, 0.0, -rod_z);\n    \n    // refracted position extrapolation\n    float refractive_index = refractIndex;\n    vec3 refracted_ray = mix(n, rd, refractive_index);\n    float dist = 0.4;\n    float z_dist = dist / (refracted_ray.z + 0.000001);\n    vec3 pos = vec3(p, 0.0) + z_dist*refracted_ray;\n    vec2 subPos = vec2(pos.xy * pos.z)+.5;\n    // not really sure about this, but hey, it works !\n    float ratio = iResolution.x / iResolution.y;\n    subPos *= vec2(1./ratio,1.);\n    subPos.x += .22;\n    // light stuff\n    vec3 lpos = normalize(vec3(0.5, -0.5, 1.0));\n    vec3 lcol = vec3(1.);\n    float lambert = pow(lambert(n,lpos),1.);\n    float specularLight = specular(rd, n, lpos, 8., 1.);\n    vec3 reflectedDir = normalize(reflect(rd, n));\n    vec4 diffuseColor = sampleBackground(n, iChannel1);\n    vec4 reflectionColor = remapShadows(sampleBackground(reflectedDir, iChannel0));\n    float fresnel = fresnel(rd, n, 8.,true);\n    float fresnelStrength = 0.995;\n    float reflectionStrength = 0.525;\n    float reflectionAmount = reflectionStrength + fresnelStrength * fresnel;\n\n\n    vec3 color = texture(iChannel1,(subPos)).rgb * .75;\n    // glass shading\n    float g = 1.0 - abs(n.z);\n    g = g * 0.4 / (g * 0.4 - g + 1.0);\n    float glass = (1.0 - 0.3 * g);\n    // rendering stuff\n    color += dispersion((subPos),rd,n,uv) * glass * .75;\n    color += specularLight*diffuseColor.rgb*.125;\n    color += reflectionAmount * reflectionColor.rgb;\n    color += lambert;\n    color = clamp(1.-color,0.,1.);\n    color = pow(color,vec3(1./1.222));\n    // composite image\n    vec3 col = vec3(glass) - color;\n    \n    fragColor = vec4(col,1.0);\n    //fragColor = texture(iChannel1,uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define C(c) U.x-=.5; O+= char(U,64+c)\n#define R iResolution\n\nmat2 rotate(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/32.),dFdy(p/32.) );\n}\n\nvoid mainImage( out vec4 O, vec2 frag )\n{\n    O = vec4(0.0);\n    \n    vec2 uv = frag/iResolution.y;\n    uv -= .5;\n    uv.x -= .4;\n    uv.x += sin(iTime*.25*6.2830)*.5;\n    //uv *= rotate(iTime*.25*6.2830);\n    //uv += .5;\n    float FontSize = 84.;\n    vec2 position = vec2(-.8,-0.15);\n    \n    vec2 U = ( uv - position +.5)*64.0/FontSize;\n    C(1);//C(5);C(12);C(12);C(15);C(-32);C(23);C(15);C(18);C(12);C(4);C(-31);\n    O.x = smoothstep(0.4,0.9,O.x);\n    O = O.xxxx+texture(iChannel1,vec2((R.y/R.x)*frag.x/iResolution.y,frag.y/iResolution.y));\n}","name":"Buffer A","description":"","type":"buffer"}]}