{"ver":"0.1","info":{"id":"3lyyDw","date":"1611150020","viewed":638,"name":"Simpler Particles","username":"UnstableLobster","description":"Nothing keeps them from dissapearing except their other selves","likes":37,"published":1,"flags":32,"usePreview":0,"tags":["particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \n    Simple particle algo.\n    \n    Each pixel can be a particle, the only thing that prevents them from\n    falling in the same pixel is the force they exert upon each other.\n    \n    For this to work you need stability, so instead of storing their velocity\n    the next step position is stored and corrected.\n    \n    Here is a good paper on this https://matthias-research.github.io/pages/publications/posBasedDyn.pdf\n    \n    \n    This should be quite fast for smaller sized particles, though this specific shader is not meant to show that.\n    The slowest side seems to be the rendering.\n\n*/\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n\n    col.xyz = vec3(1.0);\n    \n    float d = 100.0;\n    \n    vec3 c = vec3(1.0);\n    float m = 1.0;\n    \n    //rendering\n    int I = int(ceil(particle_size*0.5))+2; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch0, tpos);\n        particle P0 = getParticle(data, tpos);\n        \n        if (P0.M == 0.0) continue;\n         \n        float nd = distance(pos, P0.NX) - P0.R;\n        \n        if (nd < d)\n        {\n            //color\n            vec2 V = (P0.NX - P0.X)*1.0/dt;         \n            c = vec3(V*0.5+0.5, (P0.M-1.0)/3.0);\n            c = mix(vec3(1.0), c, length(V));\n            \n            //mass\n            m = P0.M;\n        }\n        \n        d = min(d, nd);\n        \n        if (d < 0.0) break;\n    } \n    \n    //shadow\n    float s = 100.0;\n    vec2 off = vec2(5.0, 5.0);\n    if (d > 0.0 && int(pos.x) % 2 == 0 && int(pos.y) % 2 == 0)\n    {\n        range(i, -I, I) range(j, -I, I)\n        {\n            vec2 tpos = pos-off + vec2(i,j);\n            vec4 data = texel(ch0, tpos);\n            particle P0 = getParticle(data, tpos);\n            \n            if (tpos.x < 0.0\n            ||  tpos.x > R.x\n            ||  tpos.y < 0.0\n            ||  tpos.y > R.x) { s = 0.0; break; }\n            if (P0.M == 0.0)  { continue; }\n\n            float nd = distance(pos - off, P0.NX) - P0.R;\n            s = min(s, nd);\n        } \n    }\n    \n    \n    if (d < 0.0)\n        d = sin(d);\n    col.xyz = vec3(abs(d));\n    if (d < 0.0)\n    {\n        col.xyz *= c;\n        col.xyz /= 0.4 + m*0.25;\n    }\n    \n    col.xyz = saturate(col.xyz);    \n    if (d > 0.0)\n        col.xyz *= mix(vec3(0.5), vec3(1.0), saturate(s));\n    \n    if (pos.x < 3.0\n    ||  pos.x > R.x - 3.0\n    ||  pos.y < 3.0\n    ||  pos.y > R.y - 3.0)\n    col.xyz = vec3(0.5); \n    \n    //col.xyz = pow(col.xyz, vec3(1.0/2.2));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define Bf(p) p\n#define Bi(p) ivec2(p)\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define G(x) exp(-dot(x*2.0,x*2.0))\n#define GS(x) exp(-length(x*2.0))\n\n#define dt 2.0\n\n\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time-0.0)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return bound - 15.0;\n    return min(bound, box);\n    return max(drain,min(bound, box));\n}\n\n#define hh 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-hh,0,hh);\n    vec4 idx = vec4(-1./hh, 0., 1./hh, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    \n    //return unpackSnorm2x16(X);\n    return unpackHalf2x16(X);\n}\n\nfloat encode(vec2 x)\n{\n    //uint X = packSnorm2x16(x);\n    uint X = packHalf2x16(x);\n\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 NX;\n    float R;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.NX = decode(data.y) + pos;\n    P.R = data.z;\n    P.M = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = P.X - pos;\n    P.NX = P.NX - pos;\n    return vec4(encode(P.X), encode(P.NX), (P.R), (P.M));\n}\n\n\n\n//-------------\n// Random\n//-------------\n\nuvec4 s0; \n\nvoid rng_initialize(vec2 p, int frame)\n{\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand() { pcg4d(s0); return float(s0.x)/float(0xffffffffu);  }\nvec2 rand2() { pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);  }\nvec3 rand3() { pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu); }\nvec4 rand4() { pcg4d(s0); return vec4(s0)/float(0xffffffffu);     }\n\n\n\n//-------------\n// Sim\n//-------------\n#define particle_size 10.5\n#define relax_value 0.9 / 3.0\n\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    vec2 F = vec2(0.0);\n    \n    int I = int(ceil(particle_size)); \n    range(i, -I, I) range(j, -I, I)\n    {\n        if (i == 0 && j == 0) continue;\n        \n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        \n        if (P0.M == 0.0) continue;\n        \n        vec2 dx = P0.NX - P.NX;\n        float d = length(dx);\n        float r = P.R + P0.R;\n        float m = ((1.0/P.M) / ((1.0/P.M)+(1.0/P0.M))) * 2.0;\n        m = (((P.M-P0.M)/(P.M+P0.M)) + ((2.0*P0.M)/(P.M+P0.M)));\n        m = P0.M/(P.M+P0.M);\n        \n        /*float k = 0.5;\n        float s = 1.0 - pow(1.0 - k, 1.0/3.0);*/\n        \n        if (d < r)\n            F -= normalize(dx) * (r - d) * m;\n    }\n\n    //border\n    vec2 dp = P.NX;\n    float d = border(dp);\n    if (d < 0.0)\n        F -= bN(dp).xy*d;\n      \n    P.NX += F * relax_value;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvoid Integrate(sampler2D ch, inout particle P, vec2 pos)\n{\n    int I = 3; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        \n        if (tpos.x < 0.0 || tpos.y < 0.0) continue;\n       \n        particle P0 = getParticle(data, tpos);\n\n        //falls in this pixel\n        if (P0.NX.x >= pos.x-0.5\n        &&  P0.NX.x < pos.x+0.5\n        &&  P0.NX.y >= pos.y-0.5\n        &&  P0.NX.y < pos.y+0.5\n        &&  P0.M > 0.5)\n        {\n            vec2 P0V = (P0.NX - P0.X)/dt;\n        \n            //external forces\n            if(iMouse.z > 0.0)\n            {\n                /*vec2 dm =(iMouse.xy - iMouse.zw)/10.; \n                float d = distance(iMouse.xy, P0.NX)/20.;\n                P0V += 0.005*dm*exp(-d*d) * 1.0;*/\n                \n                vec2 dm = P0.NX - iMouse.xy;\n                float d = length(dm/50.0);\n                P0V += normalize(dm) * exp(-d*d)*0.3;\n            }\n            \n            \n\n            P0V += vec2(0., -0.005);\n\n            float v = length(P0V);\n            P0V /= (v > 1.0) ? v : 1.0;\n\n            //\n            P0.X = P0.NX;     \n            P0.NX = P0.NX + P0V*dt;\n            P = P0;\n            break;\n        }\n    }\n}\n\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy;\n    rng_initialize(pos, iFrame);\n\n    particle P;      \n    Integrate(ch0, P, pos);\n   \n    if (iFrame == 0)\n    {\n        if (rand() > 0.992)\n        {\n            P.X = pos;\n            P.NX = pos + (rand2()-0.5)*0.0;\n            \n            float r = pow(rand(), 2.0);         \n            P.M = mix(1.0, 4.0, r);\n            P.R = mix(1.0, particle_size * 0.5, r);\n        }\n        else\n        {\n            P.X = pos;\n            P.NX = pos;\n            P.M = 0.0;\n            P.R = particle_size * 0.5;\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;     \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0)\n        Simulation(ch0, P, pos);\n \n    U = saveParticle(P, pos);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;     \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0)\n        Simulation(ch0, P, pos);\n \n    U = saveParticle(P, pos);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;     \n    vec4 data = texel(ch0, pos); \n    particle P = getParticle(data, pos);\n      \n    if (P.M > 0.0)\n        Simulation(ch0, P, pos);\n \n    U = saveParticle(P, pos);\n}","name":"Buffer D","description":"","type":"buffer"}]}