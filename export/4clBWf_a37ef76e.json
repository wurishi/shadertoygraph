{"ver":"0.1","info":{"id":"4clBWf","date":"1724466906","viewed":80,"name":"Signed Heat Method SDF","username":"chronos","description":"Tried to implement \"A Heat Method for Generalized Signed Distance\"","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["sdf","distance","heat","signed","generalized","method"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Signed Heat Method SDF by chronos\n    -------------------------------------------------------------\n    Tried to implement\n    https://nzfeng.github.io/research/SignedHeatMethod/\n    \n    \"A Heat Method for Generalized Signed Distance\" by \n    Nicole Feng  and Keenan Crane, Carnegie Mellon University\n    \n    See accompanying Siggraph 2024 video for an overiew:\n    https://www.youtube.com/watch?v=IzBY-jGI24M\n    \n    --------------------------------------------------------------\n    \n    This method can reconstruct a signed distance field from a broken boundary (with oriented normals).\n    \n    An advantage of this method is that it creates a correct *signed* distance field\n    from a broken boundary in a way that signing an unsigned distance field (e.g with winding numbers)\n    does not. It also supposedly reconstructs in a slightly different way than winding numbers / poisson reconstruction,\n    which can be advantageous, according to the video.\n    \n    -----------------------------------------------------------------\n    \n    This has to be some of the messiest code I've written in recent years. Apologies :/\n    \n    Seems to kinda work, idk. Kinda hacked together only based on a high level description of the method\n    after half-paying-attention to the 10 minute supplementary video. Haven't even read the paper yet :P\n    \n    So, be warned that this implementation is probably wrong in a million different ways ^_^'\n    \n    Some observations:\n        The resulting distance and normals are approximations, but seem to be quite decent.\n        especially the distances seem to be quite good, but the normal seem to break down a bit,\n        mostly in the interior near the medial axis / skeleton, and when you get furtger away from the surface\n        in the exterior part. Still, this may be in part due to my hacky numerical solvers that probably\n        accumulate errors quite rapidly. Some of it may also im part be due to some of the limitations that they\n        mention in the \"Limitations\" part of the paper. Not sure.\n    \n    Algorithm:\n    - Generate initial boundary with normals\n    - blur normal field to propagate\n    - normalize blurred normals\n    - integrate normal field\n    \n    --------------------------------------------------\n        self link: https://www.shadertoy.com/view/4clBWf\n*/\n\nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p,b)/dot(b,b), 0.,1.) * b - p);\n}\n\nvec3 get_color(vec2 fragCoord)\n{\n    vec4 samp = texelFetch(iChannel2, ivec2(fragCoord), 0);\n    \n    vec2 normal = texelFetch(iChannel1,  ivec2(fragCoord), 0).rg;\n    if(length(normal) > 0.) normal = normalize(normal);\n    \n    float dist = abs(samp.r);\n    vec3 color =  sign(samp.r) * vec3(.5*(1.+normal), tanh(dist) / 500.) * (1.-exp(-dist*0.1)) + step(0.,-sign(samp.r));\n        \n    if(dist == 0.) color *= 0.;    \n        \n    vec2 uv = (2.*fragCoord-iResolution.xy) / iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy) / iResolution.y;\n    float ps = 2./iResolution.y;\n    \n    // Draw animated distance and projection point tester\n    {\n        vec2 distance_tester_pos = (vec2(sin(iTime/8.), cos(iTime))*.5 + .5) ;\n        \n        if(length(iMouse.xy) > 10.) distance_tester_pos = iMouse.xy/iResolution.xy;\n\n        vec4 tester_samp = texture(iChannel2, distance_tester_pos);\n        if(tester_samp.a >.5)\n        {\n            float tester_dist = abs(tester_samp.r);\n            vec2 tester_normal = texture(iChannel1, distance_tester_pos).rg;\n            if(length(tester_normal) > 0.) tester_normal = normalize(tester_normal);\n\n            if(tester_dist < 1e9)\n            {\n                vec2 pixel_pos = fragCoord.xy;\n                float circ = abs(length(distance_tester_pos* iResolution.xy - pixel_pos) - tester_dist);\n                float alpha = smoothstep(3., 1., circ );\n                color = mix(color, vec3(1), 0.5*alpha);\n\n                float tester_dot = length(distance_tester_pos* iResolution.xy - pixel_pos)-5.;\n                alpha = smoothstep(2., -1., tester_dot);\n                color = mix(color, vec3(1), alpha);\n\n\n                float tester_proj = length(distance_tester_pos* iResolution.xy - tester_normal*tester_samp.r - pixel_pos)-5.;\n                alpha = smoothstep(2., -1., tester_proj);\n                color = mix(color, vec3(1), alpha);\n\n                float tester_proj_seg = seg(distance_tester_pos* iResolution.xy, distance_tester_pos* iResolution.xy - tester_normal*tester_samp.r, pixel_pos);\n                alpha = smoothstep(3., 1., tester_proj_seg);\n                color = mix(color, vec3(1), alpha);\n            }\n        }\n    }\n    \n    // field iso lines\n    float f = pow(abs(cos(3.14159265 * dist/15.)), 20.);\n    color = mix(color, vec3(step(0., sign(samp.r))), .5*f);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float ps = 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    vec4 bufA = texture(iChannel0, fragCoord/iResolution.xy);\n    vec4 bufB = texture(iChannel1, fragCoord/iResolution.xy);\n    vec4 bufC = texture(iChannel2, fragCoord/iResolution.xy);\n    \n    \n    color = bufB.rgb;\n    \n    \n    if(length(color.rg) > 0.) color.rg = normalize(color.rg);\n    \n    color = vec3(.5) + \n        color.r * normalize(vec3(-1, 1, 0)) +\n        color.g * normalize(vec3( 1, 1, -2))\n        ;\n    \n    color = clamp(color, 0., 1.);\n    \n    float alpha = bufA.a;\n        \n    {\n        float sdf = bufC.r;\n        color = mix(color, max(sign(sdf) * vec3(1, 0, -1),0.), \n         \n                .5 * (step(0., -sdf) + sign(sdf) * (.5 + .5 * cos(sdf * 3.14159265 / 10.))\n            \n            )\n            );\n    }\n    {\n        color = mix(color, \n            get_color(fragCoord),\n            bufC.a);\n            \n    }\n    \n    color = mix(color, vec3(1), alpha);\n    \n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Source field buffer\n\nfloat field(vec2 p)\n{\n    float sdf = \n        min(\n            (length(p-vec2(.5, 0))- .5),\n            (length(p-vec2(-.5, 0))- .5)\n            )\n            ;\n            \n   return sdf;\n}\n\nfloat boundary(vec2 p)\n{\n    float sdf = \n        min(\n            abs(length(p-vec2(.5, 0))- .5),\n            abs(length(p-vec2(-.5, 0))- .5)\n            )\n            ;\n            \n   return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float ps = 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    float sdf = boundary(uv);\n            \n    \n    float alpha = smoothstep(2.*ps, .5*ps, sdf);\n    \n    alpha = min(alpha, step(0.5, abs(uv.x)));\n    \n    float e = 1e-3;\n    vec2 normal = normalize(vec2(\n        field(uv + vec2(e,0)) - field(uv + vec2(-e,0)),\n        field(uv + vec2(0,e)) - field(uv + vec2(0,-e))\n        \n        )/2.);\n        \n    \n    color = mix(color, vec3(normal, 0), alpha);\n\n    fragColor = vec4(color, alpha);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Blur normal field\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    float ps = 2. / iResolution.y;\n\n    vec3 color = vec3(0);\n    \n    if(iFrame == 1)\n        {\n            color += texelFetch(iChannel0, ivec2(fragCoord), 0).rgb;\n            fragColor = vec4(color, 1);\n            return;\n        }\n    else\n    {\n    const int N = 3;\n    for(int i = -N; i <= N; i++)\n    for(int j = -N; j <= N; j++)\n        color += texelFetch(iChannel1, ivec2(fragCoord) + ivec2(i,j), 0).rgb;\n        \n    color /= float( (2 * N + 1)*(2 * N + 1));\n    \n    color = \n        mix(color, \n            texelFetch(iChannel0, ivec2(fragCoord), 0).rgb,\n            float(0.5 < texelFetch(iChannel0, ivec2(fragCoord), 0).a)\n            )\n            ;\n    \n    }\n\n\n    fragColor = vec4(color, 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Terribly hacky \"integration\"\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float filled = 0.;\n    float sdf = 0.;\n    if(iFrame > 1)\n    {\n        filled = texelFetch(iChannel2, ivec2(fragCoord), 0).a;\n        sdf= texelFetch(iChannel2, ivec2(fragCoord), 0).r;\n    }\n    else \n    {\n        filled = float(texelFetch(iChannel0, ivec2(fragCoord), 0).a > 0.5);\n        fragColor = vec4(vec3(0), filled);\n        return;\n    }\n      \n    if(iFrame > 160 && filled < .5)\n    {\n        vec2 normal = texelFetch(iChannel1, ivec2(fragCoord), 0).rg;\n        if(length(normal) > 0.) normal = normalize(normal);\n        \n        \n        const int N = 1;\n        for(int i = -N; i <= N; i++)\n        for(int j = -N; j <= N; j++)\n        {\n            if(filled > 0.) continue;\n            \n            vec2 offset = vec2(i, j);\n            bool nfilled = (0. < texelFetch(iChannel2, ivec2(fragCoord+offset), 0).a);\n\n            if(nfilled)\n            {\n                filled = 1.;\n                sdf = texelFetch(iChannel2, ivec2(fragCoord+offset), 0).r + dot(normal, floor(fragCoord) - floor(fragCoord+offset));\n            }\n        }\n    }\n    \n    \n    \n    \n\n    fragColor = vec4(vec3(sdf), filled);\n}","name":"Buffer C","description":"","type":"buffer"}]}