{"ver":"0.1","info":{"id":"tt3BWB","date":"1613347366","viewed":712,"name":"Ensō","username":"igneus","description":"An experiment with \"metacurves\", the charge isosurface around polynomial splines instead of points. My hope was that animating them would give a motion-blurred effect. What I got wasn't quite what I intended, but the finished look is still interesting. ","likes":26,"published":1,"flags":32,"usePreview":0,"tags":["blobs","metaballs","particles","blobby","isosurface","enso","metacurves"],"hasliked":0,"parentid":"Wltfz2","parentname":"Ensō Scratchpad"},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\nfloat vignette(in vec2 fragCoord)\n{\n    vec3 uvr = xyToUvr(fragCoord, iResolution);\t\t\t\t\n    return mix(1.0, max(0.0, 1.0 - pow(uvr.z * kVignetteScale, kVignetteExponent)), kVignetteStrength);\n}\n\nfloat filmGrain(in vec2 fragCoord)\n{  \n    pcgInitialise(iFrame);\n    vec4 jitter = rand();\n    \n    vec2 uv = xyToUvr(fragCoord, iResolution).xy;\n    \n    float octaves = 0.0;\n    octaves += 1.0 * (textureLod(iChannel2, vec2(mod((uv.x + jitter.x) * kFilmGrainFreq, 1.0), mod((uv.y + jitter.y) * kFilmGrainFreq, 1.0)), 0.0).x);\n    octaves += 1.0 * (textureLod(iChannel2, vec2(mod((uv.x + jitter.z) * 2.0 * kFilmGrainFreq, 0.9), mod((uv.y + jitter.w) * 2.0 * kFilmGrainFreq, 0.9)), 0.0).x);\n    octaves /= 2.0;\n    \n    return 1.0 + (octaves - 0.5) * kFilmGrainStrength;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    vec3 rgb = kZero; \n    vec4 texel;\n    #if kApplyBloom == 1\n    {\n        rgb += vec3(bloom(fragCoord, iResolution, ivec2(0, 1), iChannel1).w * kBloomGain);// * vec3(0.5, 0.9, 1.0);\n        \n        if(kDebugBloom)\n        {\n            fragColor = vec4(rgb, 1.0);\n            return;\n        }\n  \n        texel = texture(iChannel0, fragCoord / iResolution.xy);\n    }\n    #else\n    {\n        texel = renderMetaballs(fragCoord, iResolution, iTime, iChannel2);\n    }\n    #endif\n    \n    rgb += texel.rgb;\n    \n    rgb = clamp(rgb, vec3(0.0), vec3(1.0));\n    \n    if(kApplyNoise)\n    {        \n        rgb *= filmGrain(fragCoord);\n    }\n    \n    if(kApplyVignette) { rgb *= vignette(fragCoord); }    \n    \n    fragColor.xyz = rgb;\n    fragColor.w = 1.0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n#define kApplyBloom           1\n#define kApplyVignette        true            // Apply vignette as a post-process\n#define kApplyNoise           true\n\n#define kBloomGain            10.0             // The strength of the bloom effect \n#define kBloomTint            vec4(1.0)       // The tint applied to the bloom effect\n#define kBloomWidth           0.07             // The width of the bloom effect as a proportion of the buffer width\n#define kBloomHeight          0.07          // The height of the bloom effect as a proportion of the buffer height\n#define kBloomShape           1.0            // The fall-off of the bloom shape. Higher value = steeper fall-off\n#define kBloomDownsample      6              // How much the bloom buffer is downsampled. Higher value = lower quality, but faster\n#define kDebugBloom           false           // Show only the bloom in the final comp\n#define kBloomBurnIn          vec4(0.6)\n\n#define kVignetteStrength         0.5             // The strength of the vignette effect\n#define kVignetteScale            0.75             // The scale of the vignette effect\n#define kVignetteExponent         2.5             // The rate of attenuation of the vignette effect\n\n#define kFilmGrainStrength        0.2             // The strength of film grain post-process\n#define kFilmGrainFreq            2.0             // The relative frequency of the film grain effect. Higher = finer grain.\n\n#define kNumMetaballs         500\n#define kInterpolationOrder   2\n\n#define kMetaSpeed            0.01\n#define kMetaSpeedVariance    0.35\n#define kMetaSpeedSkew        2.0\n\n#define kMetaSpread           0.33\n#define kMetaSpreadVariance   0.3\n#define kMetaSpreadSkew       1.0\n\n#define kMetaCharge           0.0008\n#define kMetaChargeVariance   0.9\n#define kMetaChargeSkew       2.0\n\n#define kMetaThreshold        8.0\n\n#define kTimeStretch          1.0\n#define kMorphSpeed           0.007\n#define kShutterInterval      5.0\n\n#define kTimeDelay            0.0\n\n#define kLissajousMaxHarmonic   3.0\n#define kLissajousHarmonicBias  0.8\n\n#define kPi                    3.14159265359\n#define kTwoPi                 (2.0 * kPi)\n#define kHalfPi                (0.5 * kPi)\n#define kRoot2                 1.41421356237\n#define kFltMax                3.402823466e+38\n#define kIntMax                0x7fffffff\n#define kOne                   vec3(1.0)\n#define kZero                  vec3(0.0)\n#define kPink                  vec3(1.0, 0.0, 0.2)\n\nfloat cubrt(float a)           { return sign(a) * pow(abs(a), 1.0 / 3.0); }\nfloat toRad(float deg)         { return kTwoPi * deg / 360.0; }\nfloat toDeg(float rad)         { return 360.0 * rad / kTwoPi; }\nfloat sqr(float a)             { return a * a; }\nint sqr(int a)                 { return a * a; }\nint mod2(int a, int b)         { return ((a % b) + b) % b; }\nfloat length2(vec2 v)          { return dot(v, v); }\nint sum(ivec2 a)               { return a.x + a.y; }\nfloat luminance(vec3 v)        { return v.x * 0.17691 + v.y * 0.8124 + v.z * 0.01063; }\nfloat mean(vec3 v)             { return v.x / 3.0 + v.y / 3.0 + v.z / 3.0; }\nvec4 mul4(vec3 a, mat4 m)      { return vec4(a, 1.0) * m; }\nvec3 mul3(vec3 a, mat4 m)      { return (vec4(a, 1.0) * m).xyz; }\nfloat sin01(float a)           { return 0.5 * sin(a) + 0.5; }\nfloat cos01(float a)           { return 0.5 * cos(a) + 0.5; }\nfloat saturate(float a)        { return clamp(a, 0.0, 1.0); }\n\nvec2 safeNormalize(vec2 v)\n{\n    float l2 = dot(v, v);\n    return (l2 < 1e-15) ? vec2(0.0) : (v / sqrt(l2));\n}\n\nivec2 kFragCoord;\nuvec4 rngSeed; \n\n// Maps the input xy texel coordinates to UV [0.0, 1.0] and distance R from center\nvec2 xyToUv(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = vec2(xy.x / iResolution.x, xy.y / iResolution.y);\n    uv.x = (uv.x - 0.5) * (iResolution.x / iResolution.y) + 0.5;     \n    return uv;\n}\n\n// Maps the input xy texel coordinates to UV [-1.0, 1.0] and distance R from center\nvec3 xyToUvr(in vec2 xy, in vec3 iResolution)\n{\n    vec2 uv = xyToUv(xy, iResolution);    \n    float x = 2.0 * (uv.x - 0.5);\n    float y = 2.0 * (uv.y - 0.5);\n    \n    return vec3(uv, sqrt(x*x + y*y) / kRoot2);\n}\n\n// Permuted congruential generator from \"Hash Functions for GPU Rendering\" (Jarzynski and Olano)\n// http://jcgt.org/published/0009/03/02/paper.pdf\nuvec4 pcgAdvance()\n{\n    rngSeed = rngSeed * 1664525u + 1013904223u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    rngSeed ^= rngSeed >> 16u;\n    \n    rngSeed.x += rngSeed.y*rngSeed.w; \n    rngSeed.y += rngSeed.z*rngSeed.x; \n    rngSeed.z += rngSeed.x*rngSeed.y; \n    rngSeed.w += rngSeed.y*rngSeed.z;\n    \n    return rngSeed;\n}\n\n// Seed the PCG hash function with the current frame multipled by a prime\nvoid pcgInitialise(int frame)\n{    \n    rngSeed = uvec4(20219u, 7243u, 12547u, 28573u) * uint(frame);\n}\n\n// Generates a tuple of canonical random number and uses them to sample an input texture\nvec4 rand(sampler2D sampler)\n{\n    return texelFetch(sampler, (kFragCoord + ivec2(pcgAdvance() >> 16)) % 1024, 0);\n}\n\n// Generates a tuple of canonical random numbers in the range [0, 1]\nvec4 rand()\n{\n    return vec4(pcgAdvance()) / float(0xffffffffu);\n}\n\nvec3 hue(float phi)\n{\n    float phiColour = 6.0 * phi / kTwoPi;\n    int i = int(phiColour);\n    vec3 c0 = vec3(((i + 4) / 3) & 1, ((i + 2) / 3) & 1, ((i + 0) / 3) & 1);\n    vec3 c1 = vec3(((i + 5) / 3) & 1, ((i + 3) / 3) & 1, ((i + 1) / 3) & 1);             \n    return mix(c0, c1, phiColour - float(i));\n}\n\nvec3 hue(float phi, float saturation, float brightness)\n{\n    vec3 rgb = hue(phi);\n    \n    rgb = mix(vec3(0.5), rgb, saturation);\n    \n    return (brightness < 0.5) ? mix(kZero, rgb, brightness * 2.0) :\n                                mix(rgb, kOne, (brightness - 0.5) * 2.0);\n}\n\n\n// Seperable bloom function. This filter requires two passes in the horizontal and vertical directions which are combined as a post-process\n// effect after each frame. The accuracy/cost of the effect can be tuned by dialing the kBloomDownsample parameter. \nvec4 bloom(vec2 fragCoord, vec3 iResolution, ivec2 delta, sampler2D renderSampler)\n{        \n    vec2 scaledResolution = vec2(iResolution.x, iResolution.y) / float((delta.x == 1) ? kBloomDownsample : 1);\n   \n    if(fragCoord.x > scaledResolution.x || fragCoord.y > scaledResolution.y) { return vec4(0.0); }\n    \n    float bloomSize = (delta.x == 1) ? kBloomWidth : kBloomHeight;\n    \n    int kKernelWidth = int(bloomSize * max(iResolution.x, iResolution.y) + 0.5) / ((delta.x == 1) ? kBloomDownsample : 1);\n    vec4 sumWeights = vec4(0.0);\n    vec4 sumRgb = vec4(0.0);\n    for(int i = -kKernelWidth; i <= kKernelWidth; i++)\n    {      \n        vec2 xy = vec2(fragCoord.x + float(i * delta.x), fragCoord.y + float(i * delta.y));\n        \n        if(delta.x == 1) { xy *= float(kBloomDownsample); }\n        else { xy /= float(kBloomDownsample); }\n        \n        if(xy.x < 0.0 || xy.x > iResolution.x || xy.y < 0.0 || xy.y > iResolution.y) { continue; }\n            \n        vec4 rgb = texture(renderSampler, xy / iResolution.xy);\n        float d = float(abs(i)) / float(kKernelWidth);\n           \n        vec4 weight = vec4(1.0);\n        if(i != 0)\n        {\n            // Currently using a single weight although this effect can be done per-channel\n            float kernel = pow(max(0.0, (exp(-sqr(d * 4.0)) - 0.0183156) / 0.981684), kBloomShape);            \n            weight = vec4(1.0) * kernel;\n        }\n            \n        sumRgb += ((delta.y == 1) ? rgb : max(vec4(0.0), rgb - kBloomBurnIn)) * weight;         \n        sumWeights += weight;\n    }\n    \n    sumRgb = sumRgb / sumWeights;\n    \n    return (delta.x == 1) ? sumRgb : (sumRgb * kBloomTint);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\nconst int lissajousIndirection[20] = int[20](1, 8, 4, 16, 9, 11, 6, 14, 2, 13, 3, 19, 7, 15, 12, 17, 0, 18, 5, 10);\nvec3 harmonic[2];\nfloat delta;\nconst mat3 M = mat3(vec3(2.0, -4.0, 2.0), vec3(-3.0, 4.0, -1.0), vec3(1.0, 0.0, 0.0));\n\nvec3 lissajous(vec4 xi, int idx)\n{        \n    idx = lissajousIndirection[idx % 20];\n    \n    vec3 params;\n    params.x = 1.0 + float(idx / 15);\n    params.y = 1.0 + float(idx / 5 - idx / 15);\n    params.z = kHalfPi * float(idx % 5) / 4.0;\n    \n    return params;\n}\n\nvec2[3] controlPoints(int numPoints, vec4 xi, float time)\n{\n    float speed = kMetaSpeed * mix(1.0 - kMetaSpeedVariance, 1.0, pow(xi.y, kMetaSpeedSkew)) / kTimeStretch;      \n    vec2 aspectRatio = vec2(1.0);\n    \n    xi.z = 0.0;\n    \n    vec2 v[3];  \n    float shutterInterval = kShutterInterval * kTimeStretch;\n    for(int i = 0; i < numPoints; i++)\n    {    \n        float shutter = mix(-shutterInterval * 0.5, shutterInterval * 0.5, float(i) / float(max(1, numPoints - 1)));\n        vec2 p = vec2(cos((speed * (time + shutter) + xi.z) * harmonic[0].y * kTwoPi),\n                    cos((speed * (time + shutter) + xi.z) * harmonic[0].x * kTwoPi + harmonic[0].z)) * aspectRatio * kMetaSpread;        \n\n        vec2 q = vec2(cos((speed * (time + shutter) + xi.z) * harmonic[1].y * kTwoPi),\n                    cos((speed * (time + shutter) + xi.z) * harmonic[1].x * kTwoPi + harmonic[1].z)) * aspectRatio * kMetaSpread;\n                    \n        v[i] = mix(p, q, sin01(kHalfPi * (-1.0 + 2.0 * delta)));\n    }  \n    \n    return v;\n}\n\nvec3 field0thOrder(vec2 xy, vec4 xi, float time)\n{                   \n    return vec3(controlPoints(1, xi, time)[0], 0.0);\n}\n\nvec3 field1stOrder(vec2 xy, vec4 xi, float time)\n{\n    vec2 v[3] = controlPoints(2, xi, time);\n    \n    float lat = kMetaSpread * (mix(0.0, kMetaSpreadVariance, pow(xi.x, kMetaSpreadSkew)) - kMetaSpreadVariance * 0.5);\n    vec2 traj = safeNormalize(v[1] - v[0]);\n    v[0] += lat * vec2(traj.y, -traj.x);\n    v[1] += lat * vec2(traj.y, -traj.x);\n        \n    vec2 d = v[1] - v[0];\n    float tPerp = dot(xy - v[0], d) / dot(d, d);\n    \n    return vec3(v[0] + d * saturate(tPerp), tPerp);\n}\n\nvec3 field2ndOrder(vec2 xy, vec4 xi, float time)\n{\n    vec2 v[3] = controlPoints(3, xi, time);\n    \n    float lat = kMetaSpread * (mix(0.0, kMetaSpreadVariance, pow(xi.x, kMetaSpreadSkew)) - kMetaSpreadVariance * 0.5);\n    vec2 traj0 = safeNormalize(v[1] - v[0]);\n    vec2 traj1 = safeNormalize(v[2] - v[0]);\n    vec2 traj2 = safeNormalize(v[2] - v[1]);\n    v[0] += lat * vec2(traj0.y, -traj0.x);\n    v[1] += lat * vec2(traj1.y, -traj1.x);\n    v[2] += lat * vec2(traj2.y, -traj2.x);\n    \n    float l0 = length(v[0] - v[1]);\n    float l1 = length(v[2] - v[1]);\n    if(dot(v[2] - v[1], v[0] - v[1]) / (l0 * l1) < -0.995 || max(l0, l1) < 0.01)\n    {\n        vec2 d = v[2] - v[0];\n        float tPerp = dot(xy - v[0], d) / dot(d, d);    \n        return vec3(v[0] + d * saturate(tPerp), tPerp);\n    }\n    \n    mat3 M = mat3(vec3(2.0, -4.0, 2.0), vec3(-3.0, 4.0, -1.0), vec3(1.0, 0.0, 0.0));    \n    vec3 abcX = vec3(v[0].x, v[1].x, v[2].x) * M;\n    float a0 = abcX.x, b0 = abcX.y, c0 = abcX.z;\n    vec3 abcY = vec3(v[0].y, v[1].y, v[2].y) * M;\n    float d0 = abcY.x, e0 = abcY.y, f0 = abcY.z;\n    float n0 = xy.x, m0 = xy.y;\n    \n    float a = -2.0*a0*a0 - 2.0*d0*d0;\n    float b = -3.0*a0*b0 - 3.0*d0*e0;\n    float c = -b0*b0 - 2.0*a0*c0 - e0*e0 - 2.0*d0*f0 + 2.0*d0*m0 + 2.0*a0*n0;\n    float d = -b0*c0 - e0*f0 + e0*m0 +  b0*n0;\n    \n    float p = (3.0*a*c - b*b)/(3.0*a*a);\n    float q = (2.0*b*b*b - 9.0*a*b*c + 27.0*a*a*d)/(27.0*a*a*a);    \n    float det = 4.0*p*p*p + 27.0*q*q;\n    \n    if(det > 0.0)\n    {        \n        float alpha = sqrt(q*q/4.0 + p*p*p/27.0);\n        float t = cubrt(-q/2.0 + alpha) + cubrt(-q/2.0 - alpha);\n        \n        float x = clamp(t - b/(3.0*a), 0.0, 1.0);\n        return vec3(abcX.x * x*x + abcX.y * x + abcX.z,\n                    abcY.x * x*x + abcY.y * x + abcY.z, x);\n    }\n    else\n    {\n        float alpha = acos(3.0*q/(2.0*p) * sqrt(-3.0/p)) / 3.0;        \n        float beta = 2.0*sqrt(-p/3.0); \n        float nearest = 1e15;\n        float xNear;\n        vec2 perpNear;\n        for(int i = 0; i < 3; i++)\n        {\n            float t = beta * cos(alpha - 2.0*kPi*float(i)/3.0);\n            float x = clamp(t - b/(3.0*a), 0.0, 1.0);\n            \n            vec2 perp = vec2(abcX.x * x*x + abcX.y * x + abcX.z,\n                             abcY.x * x*x + abcY.y * x + abcY.z);\n                             \n            float dist = length2(xy - perp);\n            if(dist < nearest)\n            {\n                nearest = dist;\n                perpNear = perp;\n                xNear = x;\n            }            \n        }   \n        \n        return vec3(perpNear, xNear);\n    }      \n}\n\nvoid field(in vec2 xy, in float time, vec3 iResolution, out float F, out vec2 delF)\n{          \n    F = 0.0;\n    delF = vec2(0.0);\n    float minLength = 0.0;\n    float denom = 0.0;\n    float sumWeights = 0.0;\n    vec2 delAbsF = vec2(0.0);\n    \n    vec2 aspectRatio = vec2(1.0);//vec2(iResolution.x / iResolution.y, 1.0); \n                                     \n    float cursor = time * kMorphSpeed / kTimeStretch;\n    int idx = int(cursor);\n    delta = saturate((2.0 * (fract(cursor) - 0.5)) + 0.5);\n    \n    pcgInitialise(idx);\n    harmonic[0] = lissajous(rand(), idx);\n    pcgInitialise(idx + 1);\n    harmonic[1] = lissajous(rand(), idx + 1);\n    \n    pcgInitialise(0);\n    \n    for(int i = 0; i < kNumMetaballs; i++)\n    {\n        vec4 xi1 = rand();        \n        vec4 xi2 = rand();      \n        \n        float c = kMetaCharge * mix(1.0 - kMetaChargeVariance, 1.0, pow(xi1.y, kMetaChargeSkew));       \n        \n        #if kInterpolationOrder == 0\n            vec3 pt = field0thOrder(xy, xi2, time);\n        #elif kInterpolationOrder ==1\n            vec3 pt = field1stOrder(xy, xi2, time);\n        #else\n            vec3 pt = field2ndOrder(xy, xi2, time);\n        #endif      \n        \n        F += c / length2(xy - pt.xy);\n        \n        float n = sqr(xy.x - pt.x) + sqr(xy.y - pt.y);\n        delF.x += -c * 2.0 * (xy.x - pt.x) / sqr(n);\n        delF.y += -c * 2.0 * (xy.y - pt.y) / sqr(n);        \n        \n        denom += c / n;\n    }   \n    \n    F = 1.0 / sqrt(F) - 1.0 / sqrt(kMetaThreshold);   \n    \n    // Vector derivative of F\n    delF = -0.5 * delF / pow(denom, 1.5);\n    \n    // Vector derivative of |F|\n    //delIsoF = (0.5 * delF) * (-1.0 / sqrt(kMetaThreshold) + 1.0 / sqrt(denom)) / (pow(denom, 1.5) * (abs(-1.0 / sqrt(kMetaThreshold)) + 1.0 / sqrt(denom)));\n}\n\nvec4 renderMetaballs(vec2 fragCoord)\n{                \n    vec2 xy = vec2((fragCoord.x - 0.5 * iResolution.x) / iResolution.y, \n                   (fragCoord.y - 0.5 * iResolution.y) / iResolution.y);\n                 \n    float time = max(0.0, iTime - kTimeDelay) * 60.0;\n\n    float F;\n    vec2 delF;\n    field(xy, time, iResolution, F, delF);           \n\n    float delFLength = length(delF);\n    vec2 delFNorm = delF / ((delFLength > 1.0) ? delFLength : 1.0);\n    delFNorm = normalize(delF);            \n\n    float FMax = ((30.0) / iResolution.x) * length(delF);          \n\n    float alpha = saturate((FMax - F) / FMax);\n    \n    // Define an angle that means we can get a nice chromium effect by sampling the normal map\n    float theta = (alpha == 1.0) ? pow(clamp(-F * 2.5, 0.0, 1.0), 0.7) : mix(-1.0, 0.0, alpha);\n    // Push the values towards the extrema at -1 and 1\n    theta = sign(theta) * pow(abs(theta), 0.7);\n    // Remap so theta corresponds to the angle between the normal and positive z axis\n    theta = 1.0 - (theta * 0.5 + 0.5);\n    theta *= 0.5;\n    \n    vec3 normal = normalize(vec3(delFNorm * sin(kPi * theta), cos(kPi * theta)));\n    normal = clamp(normal, vec3(-1.0), vec3(1.0));\n    //colour = normal;\n    //normal = vec3(0.0, 0.0, 1.0);\n    //colour = vec3(normal.z);// * 0.5 + 0.5;\n    //return vec4(colour, 0.0);\n                \n    float L = pow(luminance(textureLod(iChannel0, normal.xyz, 1.0).xyz), 1.5);      \n    vec3 thinFilm = kOne;//hue(5.0 * F * kTwoPi, 1.0, 0.9);    \n    \n    //return vec4(thinFilm, 0.0); \n    \n    vec3 colour = mix(kOne, mix(kZero, kOne, L), alpha);\n\n    return vec4(colour, mix(1.3, L, alpha));  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    kFragCoord = ivec2(fragCoord);\n    \n    #if kApplyBloom == 1   \n    {\n        fragColor = renderMetaballs(fragCoord);\n    }\n    #endif\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*//////////////////////////////////////////////////////////////////////////////////////////////////\n\n   Copyright (c) 2021 Ben Spencer   \n   Released under the MIT Licence\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n//////////////////////////////////////////////////////////////////////////////////////////////////*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if kApplyBloom == 1   \n    {    \n        fragColor = bloom(fragCoord, iResolution, ivec2(1, 0), iChannel0);\n    }\n    #endif\n}","name":"Buffer B","description":"","type":"buffer"}]}