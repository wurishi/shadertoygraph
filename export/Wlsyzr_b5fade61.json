{"ver":"0.1","info":{"id":"Wlsyzr","date":"1591312615","viewed":135,"name":"Voronoi Marbles","username":"spalmer","description":"deconstructing and simplifying dr2's cool rolling marbles demo [url]https://shadertoy.com/view/wtfcRr[/url], trying to refactor as much as possible of the shared code into Common tab - click upper right to reset, lower right to toggle view","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","collision","raymarch","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// simplified version refactored to common tab by spalmer\n\n// \"Channeling Marbles\" by dr2 at https://shadertoy.com/view/wtfcRr\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nint idBall;\nfloat tCur, dstFar;\nvec3 vnObj, ltDir;\n\nfloat SurfRay(vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  dHit = dstFar;\n  if (rd.y < 0.) {\n    s = - (ro.y - vorHt) / rd.y;\n    sLo = s;\n    for (int j = 0; j < 96; ++j) {\n      p = ro + s * rd;\n      h = p.y - SurfHt(p.xz);\n      if (h < 0.) break;\n      sLo = s;\n      s += max(.2, .4 * h);\n      if (s > dstFar) break;\n    }\n    if (h < 0.) {\n      sHi = s;\n      for (int j = 0; j < 5; ++j) {\n        s = .5 * (sLo + sHi);\n        p = ro + s * rd;\n        if (p.y > SurfHt(p.xz)) sLo = s;\n        else sHi = s;\n      }\n      dHit = .5 * (sLo + sHi);\n    }\n  }\n  return dHit;\n}\n\nfloat BallHit(vec3 ro, vec3 rd)\n{\n  vec4 p;\n  vec3 u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; ++n) {\n    p = Loadv4(chBuf, chSize, 4 * n);\n    u = ro - p.xyz;\n    rad = .45;\n    b = dot(rd, u);\n    w = b * b - dot(u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt(w);\n      if (d > 0. && d < dMin) {\n        dMin = d;\n        vnObj = (u + d * rd) / rad;\n        idBall = n;\n      }\n    }\n  }\n  return dMin;\n}\n\nfloat BallHitSh(vec3 ro, vec3 rd, float rng)\n{\n  vec4 p;\n  vec3 rs, u;\n  float b, d, w, dMin, rad;\n  dMin = dstFar;\n  for (int n = 0; n < nBall; ++n) {\n    p = Loadv4(chBuf, chSize, 4 * n);\n    u = ro - p.xyz;\n    rad = .45;\n    b = dot(rd, u);\n    w = b * b - dot(u, u) + rad * rad;\n    if (w >= 0.) {\n      d = - b - sqrt(w);\n      if (d > 0. && d < dMin) dMin = d;\n    }\n  }\n  return smoothstep(0., rng, dMin);\n}\n\nfloat BallChqr(int idBall, vec3 vnBall)\n{\n  vec3 u;\n  vec2 a;\n  u = vnBall * QtToRMat(Loadv4(chBuf, chSize, 4 * idBall + 2));\n  a = mod(floor(8. * vec2(atan(u.x, u.y), asin(u.z)) / pi), 2.) - .5;\n  return .5 + .5 * step(0., sign(a.x) * sign(a.y));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix(vec3(1), clamp(abs(fract(c.xxx + vec3(1, 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nvec3 BgCol(vec3 rd)\n{\n  return vec3(.5, .7, 1);\n}\n\nvec2 Rot2D(vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin(a + vec2(.5 * pi, 0));\n  return vec2(dot(q, vec2(cs.x, - cs.y)), dot(q.yx, cs));\n}\n\nfloat Noisefv2(vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor(p);  \n  fp = fract(p);\n  fp = fp * fp * (3. - 2. * fp); // only cubic smoothing\n  t = mix(Hashv2v2(ip), Hashv2v2(ip + vec2(0, 1)), fp.y);\n  return mix(t.x, t.y, fp.x);\n}\n\nfloat Fbmn(vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3(0);\n  a = 1.;\n  for (int j = 0; j < 4; ++j) {\n    s += a * vec3(Noisefv2(p.yz), Noisefv2(p.zx), Noisefv2(p.xy));\n    a *= .5;\n    p *= 2.;\n  }\n  return dot(s, abs(n));\n}\n\nvec3 VaryNf(vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2(.1, 0);\n  g = vec3(Fbmn(p + e.xyy, n), Fbmn(p + e.yxy, n), Fbmn(p + e.yyx, n)) - Fbmn(p, n);\n  return normalize(n + f * (g - n * dot(n, g)));\n}\n\nvec3 ShowScene(vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, bgCol;\n  float dstObj, dstSurf, sh;\n  HexVorInit();\n  bgCol = BgCol(rd);\n  dstObj = BallHit(ro, rd);\n  dstSurf = SurfRay(ro, rd);\n  if (min(dstObj, dstSurf) < dstFar) {\n    if (dstObj < dstSurf) {\n      ro += dstObj * rd;\n      vn = vnObj;\n      col4 = vec4(HsvToRgb(vec3(float(idBall) / float(nBall), .8, BallChqr(idBall, vn))), .3);\n    } else if (dstSurf < dstFar) {\n      ro += dstSurf * rd;\n      vn = SurfNf(ro);\n      vn = VaryNf(4. * ro, vn, max(.1, 2. - 2. * dstSurf / dstFar));\n      col4 = vec4(.7*mix(vec3(.4, .3, .3), vec3(.8, .85, .8), smoothstep(0., .02, ro.y)), 0.);\n    }\n    sh = BallHitSh(ro + .01 * ltDir, ltDir, 10.);\n    col = col4.rgb * (.2 + .1 * max(-dot(vn.xz, normalize(ltDir.xz)), 0.) + \n       .1 * max(vn.y, 0.) + .8 * sh * max(dot(vn, ltDir), 0.)) +\n       col4.a * pow(max(dot(normalize(ltDir - rd), vn), 0.), 32.);\n    col = mix(col, bgCol, 1. - min(1., exp2(8. * (1. - 1.2 * min(dstObj, dstSurf) / dstFar))));\n    \n  } else col = bgCol;\n  return clamp(col, 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 stDat, mPtr;\n  vec3 col, rd, ro, vd, bMid;\n  vec2 canvas, uv, ut;\n  float az, el, asp, zmFac, s, mb;\n  int fBall;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4(chBuf, chSize, 4 * nBall + 0);\n  vorSmth = stDat.xyz;\n  stDat = Loadv4(chBuf, chSize, 4 * nBall + 1);\n  vorAmp = stDat.x;\n  vorHt = stDat.y;\n  vorScl = stDat.z;\n  stDat = Loadv4(chBuf, chSize, 4 * nBall + 2);\n  mPtr.xyz = stDat.xyz;\n  fBall = int(stDat.w);\n  az = 0.;\n  el = 0.;\n  ut = vec2(mPtr.x, abs(mPtr.y)) + .05 * vec2 (1. / asp, 1.) - .5;\n  mb = min(ut.x, ut.y);\n  if (mPtr.z > 0. && mb < 0.) {\n    az = 2. * pi * mPtr.x;\n    el = .5 * pi * (mPtr.y + .25);\n  } else {\n    if (fBall < 0) {\n      az += .03 * pi * tCur;\n      el += pi * (.17 + .1 * sin(.041 * pi * tCur));\n    }\n  }\n  if (fBall >= 0) {\n    ro = Loadv4(chBuf, chSize, 4 * fBall + 0).xyz;\n    ro.y += .7;\n    vd = Loadv4(chBuf, chSize, 4 * fBall + 1).xyz;\n    vd = normalize(vec3(vd.x, 0, vd.z));\n    vd.xz = Rot2D(vd.xz, -az);\n    ro.xz -= .7 * vd.xz;\n    vuMat = mat3(vec3(vd.z, 0, -vd.x), vec3(0, 1, 0), vd);\n    zmFac = 2.;\n  } else {\n    el = clamp (el, .02 * pi, .4 * pi);\n    bMid.xz = vec2(0);\n    for (int n = 0; n < nBall; ++n) bMid.xz += Loadv4(chBuf, chSize, 4 * n).xz;\n    bMid.xz /= float(nBall);\n    bMid.y = vorHt;\n    ro = bMid + 60. * vec3(cos(el) * sin(az + vec2(.5 * pi, 0)), 2. * sin(el)).xzy;\n    vd = normalize(bMid - ro);\n    s = sqrt(max(1. - vd.y * vd.y, 1e-6));\n    vuMat = mat3(vec3(vd.z, 0., -vd.x) / s,\n                 vec3(-vd.y * vd.x, 1. - vd.y * vd.y, -vd.y * vd.z) / s\n                 , vd);\n    zmFac = 6.;\n  }\n  rd = vuMat * normalize(vec3(uv, zmFac));\n  dstFar = 200.;\n  ltDir = normalize(vec3(1, 2, -1));\n  col = ShowScene(ro, rd);\n//  if (mPtr.z > 0. && min(uv.x - asp, abs(uv.y) - 1.) > -.1)\n//     col = mix(col, vec3(1, .3, 0), .3); // idk what it does\n  col = pow(col, vec3(1./2.2)); // gamma->sRGB\n  fragColor = vec4(col, 1);\n}\n\n//dstFar = 3e38;\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// \"Channeling Marbles\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define chBuf  iChannel0\n#define chSize iChannelResolution[0].xy\nconst float txRow = 128.;\n\nconst int nBall = 64; //16; //\nconst float pi = 3.14159, sqrt3 = 1.73205;\n\nvec3 vorSmth;\nfloat todCur, nStep, vorHt, vorAmp, vorScl;\nint fBall;\n\nvec4 Loadv4(sampler2D txBuf, vec2 txSize, int idVar)\n{\n  float fi;\n  fi = float(idVar);\n  return texture(txBuf, (vec2(mod(fi, txRow), floor(fi / txRow)) + .5) / txSize);\n}\n\nvoid Savev4(int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi = float(idVar);\n  d = abs(fCoord - vec2(mod(fi, txRow), floor(fi / txRow)) - .5);\n  if (max(d.x, d.y) < .5) fCol = val;\n}\n\nvec2 cossin(float rads)\n{\n    return sin(rads + vec2(.5 * pi, 0));\n}\n\nvec2 PixToHex(vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2(1./sqrt3 * p.x - 1./3. * p.y, 2./3. * p.y);\n  c.y = - c.x - c.z;\n  r = floor(c + 0.5);\n  dr = abs(r - c);\n  r -= step(dr.yzx, dr) * step(dr.zxy, dr) * dot(r, vec3(1));\n  return r.xz;\n}\n\nvec2 HexToPix(vec2 h)\n{\n  return vec2(sqrt3 * (h.x + .5 * h.y), 3./2. * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit()\n{\n  vec3 e = vec3(1, 0, -1);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; ++k) hVec[k] = HexToPix(gVec[k]);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashff(float p)\n{\n  return fract(sin(p) * cHashM);\n}\n\nvec3 Hashv3f(float p)\n{\n  return fract(sin(p + vec3(37, 39, 41)) * cHashM);\n}\n\nvec2 Hashv2v2(vec2 p)\n{\n  vec2 cHashVA2 = vec2(37, 39);\n  return fract(sin(dot(p, cHashVA2) + vec2(0, cHashVA2.x)) * cHashM);\n}\n\nfloat SmoothMin(float a, float b, float r)\n{\n  float h;\n  h = clamp(.5 + .5 * (b - a) / r, 0., 1.);\n  return mix(b, a, h) - r * h * (1. - h);\n}\n\nfloat HexVor(vec2 p)\n{\n  vec4 sd;\n  vec2 ip, fp, d, u;\n  float a;\n  p *= vorScl;\n  ip = PixToHex(p);\n  fp = p - HexToPix(ip);\n  sd = vec4(4);\n  for (int k = 0; k < 7; ++k) {\n    u = Hashv2v2(ip + gVec[k]);\n    a = 2. * pi * (u.y - .5);\n    d = hVec[k] + vorAmp * (.4 + .6 * u.x) * cossin(a) - fp;\n    sd.w = dot(d, d);\n    if (sd.w < sd.x) sd = sd.wxyw;\n    else sd = sd.w < sd.y ? sd.xwyw :\n      sd.w < sd.z ? sd.xyww : sd;\n  }\n  sd.xyz = sqrt(sd.xyz);\n  return SmoothMin(sd.y, sd.z, vorSmth.z) - sd.x;\n}\n\n// quaternions?  cool, not many use them here\nvec4 QtMul(vec4 q1, vec4 q2)\n{\n  return vec4(\n       q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n       q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n     - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n     - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nvec4 RMatToQt(mat3 m)\n{\n  vec4 q;\n  const float tol = 1e-6;\n  q.w = .5 * sqrt(max(1. + m[0][0] + m[1][1] + m[2][2], 0.));\n  if (abs(q.w) > tol) q.xyz =\n     vec3(m[1][2] - m[2][1], m[2][0] - m[0][2], m[0][1] - m[1][0]) / (4. * q.w);\n  else {\n    q.x = sqrt(max(.5 * (1. + m[0][0]), 0.));\n    if (abs(q.x) > tol) q.yz = vec2(m[0][1], m[0][2]) / q.x;\n    else {\n      q.y = sqrt(max(.5 * (1. + m[1][1]), 0.));\n      if (abs(q.y) > tol) q.z = m[1][2] / q.y;\n      else q.z = 1.;\n    }\n  }\n  return normalize(q);\n}\n\n// only used in Image but may as well be in Common too\nmat3 QtToRMat(vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  q = normalize(q);\n  s = q.w * q.w - .5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nmat3 LpStepMat(vec3 a)\n{\n  mat3 m1, m2;\n  vec3 t, c, s;\n  float b1, b2;\n  t = .25 * a * a;\n  c = (1. - t) / (1. + t);\n  s = a / (1. + t);\n  m1[0][0] = c.y * c.z;  m2[0][0] = c.y * c.z;\n  b1 = s.x * s.y * c.z;  b2 = c.x * s.z;\n  m1[0][1] = b1 + b2;  m2[1][0] = b1 - b2;\n  b1 = c.x * s.y * c.z;  b2 = s.x * s.z;\n  m1[0][2] = - b1 + b2;  m2[2][0] = b1 + b2;\n  b1 = c.y * s.z;\n  m1[1][0] = - b1;  m2[0][1] = b1;  \n  b1 = s.x * s.y * s.z;  b2 = c.x * c.z;\n  m1[1][1] = - b1 + b2;  m2[1][1] = b1 + b2; \n  b1 = c.x * s.y * s.z;  b2 = s.x * c.z;\n  m1[1][2] = b1 + b2;  m2[2][1] = b1 - b2;\n  m1[2][0] = s.y;  m2[0][2] = - s.y;\n  b1 = s.x * c.y;\n  m1[2][1] = - b1;  m2[1][2] = b1;\n  b1 = c.x * c.y;\n  m1[2][2] = b1;  m2[2][2] = b1;\n  return m1 * m2;\n}\n\nfloat SurfHt(vec2 p)\n{\n  return vorHt * smoothstep(vorSmth.x, vorSmth.y, HexVor(p));\n}\n\nvec3 SurfNf(vec3 p)\n{\n  const vec2 e = vec2(.01, 0);\n  return normalize(vec3(SurfHt(p.xz) - vec2(SurfHt(p.xz + e.xy), SurfHt(p.xz + e.yx)), e.x).xzy);\n}\n\nvoid Step(sampler2D ch, vec2 txSize, int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  vec4 p;\n  vec3 rmN, rmN1, rmN2, vmN, wmN, dr, dr1, dr2, dv, drw, am, wam;\n  float fOvlap, fricN, fricT, fricS, fricSW, fDamp, fPull, grav, rSep,\n     fc, ft, drv, dt;\n  fOvlap = 500.;\n  fricN = 10.;\n  fricS = .1;\n  fricSW = 1.;\n  fricT = .5;\n  fPull = .5;\n  fDamp = .5;\n  grav = 5.;\n  p = Loadv4(ch, txSize, 4 * mId);\n  rm = p.xyz;\n  vm = Loadv4(ch, txSize, 4 * mId + 1).xyz;\n  qm = Loadv4(ch, txSize, 4 * mId + 2);\n  wm = Loadv4(ch, txSize, 4 * mId + 3).xyz;\n  am = vec3(0);\n  wam = vec3(0);\n  for (int n = 0; n < nBall; ++n) {\n    p = Loadv4(ch, txSize, 4 * n);\n    rmN = p.xyz;\n    dr = rm - rmN;\n    rSep = length (dr);\n    if (n != mId && rSep < 1.) {\n      fc = fOvlap * (1. / rSep - 1.);\n      vmN = Loadv4(ch, txSize, 4 * n + 1).xyz;\n      wmN = Loadv4(ch, txSize, 4 * n + 3).xyz;\n      dv = vm - vmN;\n      drv = dot(dr, dv) / (rSep * rSep);\n      fc = max(fc - fricN * drv, 0.);\n      am += fc * dr;\n      dv -= drv * dr + cross(.5 * (wm + wmN), dr);\n      ft = min(fricT, fricS * abs(fc) * rSep / max(.001, length(dv)));\n      am -= ft * dv;\n      wam += (ft / rSep) * cross(dr, dv);\n    }\n  }\n  dr.xz = .5 * SurfNf(rm).xz;\n  dr.y = rm.y + .5 - SurfHt(rm.xz - dr.xz);\n  rSep = length(dr);\n  if (rSep < 1.) {\n    fc = fOvlap * (1. / rSep - 1.);\n    dv = vm;\n    drv = dot(dr, dv) / (rSep * rSep);\n    fc = max(fc - fricN * drv, 0.);\n    am += fc * dr;\n    dv -= drv * dr + cross(wm, dr);\n    ft = min(fricT, fricSW * abs(fc) * rSep / max(.001, length(dv)));\n    am -= ft * dv;\n    wam += (ft / rSep) * cross(dr, dv);\n  }\n  am += vec3(fPull * vec2(1, .5 * sin(.005 * 2. * pi * nStep)), - grav).xzy -\n     fDamp * vec3(1, 5, 1) * vm;\n  dt = fBall < 0 ? .02 : .005;\n  vm += dt * am;\n  rm += dt * vm;\n  wm += dt * wam / .1;\n  qm = normalize(QtMul(RMatToQt(LpStepMat(.5 * dt * wm)), qm));\n}\n\nvoid Init(int mId, out vec3 rm, out vec3 vm, out vec4 qm, out vec3 wm)\n{\n  float mIdf;\n  mIdf = float(mId);\n  rm.xz = vec2(0, 1.5 * mIdf) + 35. * mod(todCur, 10.);\n  rm.y = vorHt + 1.5;\n  vm = .5 * (2. * Hashv3f(mIdf + todCur) - 1.);\n  qm = vec4(0, 0, 0, 1);\n  wm = vec3(0);\n}\n\nvoid mainBuffer(out vec4 fragColor, vec2 fragCoord, \n                sampler2D ch, vec2 txSize,\n                int frame, vec3 res, vec4 mouse, vec4 date)\n{\n  vec4 mPtr, mPtrP, stDat, qm;\n  vec3 rm, vm, wm;\n  vec2 iFrag, canvas;\n  float asp;\n  int mId, pxId, kp;\n  bool doInit;\n  iFrag = floor(fragCoord);\n  pxId = int(iFrag.x + txRow * iFrag.y);\n  if (iFrag.x >= txRow || pxId >= 4 * nBall + 3) discard;\n  canvas = res.xy;\n  todCur = iDate.w;\n  mPtr = mouse;\n  mPtr.xy = mPtr.xy / canvas - .5;\n  asp = canvas.x / canvas.y;\n  HexVorInit();\n  vorAmp = .4;\n  vorHt = 1.;\n  vorScl = .2;\n  vorSmth = vec3(.1, .8, .2);\n  mId = (pxId < 4 * nBall) ? pxId / 4 : -1;\n  fBall = -1;\n  if (frame < 3) { //frame == 0) { // thumbnail issues\n    doInit = true;\n  } else {\n    doInit = false;\n    stDat = Loadv4(ch, txSize, 4 * nBall);\n    nStep = stDat.w;\n    ++nStep;\n    stDat = Loadv4(ch, txSize, 4 * nBall + 2);\n    mPtrP.z = stDat.z;\n    fBall = int(stDat.w);\n    if (mPtr.z > 0. && mPtrP.z < 0. && mPtr.x > .5 - .05 / asp && abs(mPtr.y) > .5 - .05) {\n      if (mPtr.y > 0.) {\n        if (nStep > 100.) doInit = true;\n      } else {\n        if (fBall >= 0) fBall = -1;\n        else fBall = int(float(nBall) * Hashff(mod(todCur, 1000.)));\n      }\n    }\n  }\n  if (doInit) {\n    nStep = 0.;\n    fBall = -1;\n  }\n  if (mId >= 0) {\n    if (doInit)      Init(mId, rm, vm, qm, wm);\n    else Step(ch, txSize, mId, rm, vm, qm, wm);\n  }\n  if (pxId < 4 * nBall) {\n    kp = 4 * mId;\n    if      (pxId == kp    ) stDat = vec4(rm, 0);\n    else if (pxId == kp + 1) stDat = vec4(vm, 0);\n    else if (pxId == kp + 2) stDat = qm;\n    else if (pxId == kp + 3) stDat = vec4(wm, 0);\n  } else {\n    kp = 4 * nBall;\n    if      (pxId == kp    ) stDat = vec4(vorSmth, nStep);\n    else if (pxId == kp + 1) stDat = vec4(vorAmp, vorHt, vorScl, 0);\n    else if (pxId == kp + 2) stDat = vec4(mPtr.xyz, fBall);\n  }\n  Savev4(pxId, stDat, fragColor, fragCoord);\n}\n\n\n#define BUFFER\t\t\t\t\t\t\t\t\t\\\nvoid mainImage(out vec4 o, vec2 p)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\t\t\t\\\n\tmainBuffer(o, p, chBuf, chSize,\t\t\t\t\\\n\t\tiFrame, iResolution, iMouse, iDate);\t\\\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"BUFFER\n\n// To increase speed\n// simply make more Buffer tabs\n// and copy this code to them\n// setting the prior buffer\n// in circular ring as iChannel0\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"BUFFER\n    \n    ","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"BUFFER\n    \n    ","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"BUFFER\n    \n    ","name":"Buffer D","description":"","type":"buffer"}]}