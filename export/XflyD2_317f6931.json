{"ver":"0.1","info":{"id":"XflyD2","date":"1721620645","viewed":28,"name":"PlasterSence","username":"cinanmon","description":"whatever","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\n\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCylinderX(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.yz), p.x)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone(vec3 p, vec2 c, float h)\n{\n    vec2 q = h * vec2(c.x / c.y, -1.0);\n    vec2 w = vec2(length(p.xz), p.y);\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 b = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(b, b));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nstruct Material {\n    vec3 ambientColor; // k_a * i_a\n    vec3 diffuseColor; // k_d * i_d\n    vec3 specularColor; // k_s * i_s\n    float alpha; // shininess\n};\n\nstruct Surface {\n    int id; // id of object\n    float sd; // signed distance\n    Material mat;\n};\n\nMaterial glassMaterial() {\n    vec3 aCol = 0.5 * vec3(0.7, 0.7, 0.9);\n    vec3 dCol = 0.6 * vec3(0.7, 0.7, 0.9);\n    vec3 sCol = 0.9 * vec3(1, 1, 1);\n    float a = 128.0;\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial plasterMaterial() {\n    vec3 aCol = vec3(0.75, 0.85, 0.95);\n    vec3 dCol = vec3(0.95, 0.85, 0.85);\n    vec3 sCol = vec3(0.0, 0.0, 0.0);\n    float a = 2.0;\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial floorMaterial() {\n    vec3 aCol = vec3(0.2, 0.2, 0.2);\n    vec3 dCol = vec3(0.2, 0.2, 0.2);\n    vec3 sCol = vec3(0);\n    float a = 1.0;\n    return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n    if(obj2.sd < obj1.sd){\n        \n    return obj2 ;\n    }\n    else{\n        return obj1;\n    }\n}\n\nSurface scene(vec3 p) {\n    Surface sFloor = Surface(1, p.y + 1., floorMaterial());\n    Surface sSphere = Surface(2, sdSphere(p - vec3(1, 0.5, 0), 0.5), plasterMaterial());\n    Surface sBox = Surface(3, sdBox(p - vec3(1, -0.5, 0), vec3(0.5, 0.5, 0.5)), glassMaterial());\n    Surface sCylinder = Surface(4, sdCylinderX(p - vec3(0, -0.5, -1), vec2(0.19, 0.5)), plasterMaterial());\n    Surface sCone = Surface(5, sdCone(p - vec3(0, 0, -1), vec2(0.42, 1.0), 1.0), plasterMaterial());\n\n    Surface co = opUnion(sFloor, sSphere);\n    co = opUnion(co, sBox);\n    co = opUnion(co, sCylinder);\n    co = opUnion(co, sCone);\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    Surface co;\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = scene(p);\n        depth += abs(co.sd);\n        if (abs(co.sd) < PRECISION || depth > MAX_DIST) break;\n    }\n\n    co.sd = depth;\n    return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos);\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n    vec3 cu = normalize(cross(cd, cr));\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co) {\n    vec3 bgColor = vec3(0.835, 1.0, 1.0);\n    if (co.sd > MAX_DIST) return bgColor;\n\n    vec3 ambient = co.mat.ambientColor;\n    float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n    vec3 diffuse = co.mat.diffuseColor * dotLN;\n    float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n    vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n    vec3 col = lightIntensity * (ambient + diffuse + specular);\n    col = mix(col, bgColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd));\n    return col;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < MAX_SHADOW_STEPS; i++) {\n        float h = scene(ro + rd * t).sd;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 lp = vec3(0);\n    vec3 ro = vec3(5. * cos(-iTime), 0., 5. * sin(-iTime));\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1));\n\n    Surface co = rayMarch(ro, rd);\n    vec3 p = ro + rd * co.sd;\n    vec3 normal = calcNormal(p);\n\n    vec3 lightPosition = 4. * vec3(cos(iTime), 1., sin(iTime));\n    vec3 lightDirection = normalize(p - lightPosition);\n    float lightIntensity = 0.9;\n\n    col = phong(lightDirection, lightIntensity, normal, rd, co);\n\n    if (co.id == 1 && co.sd < 0.2 * MAX_DIST) {\n        float softShadow = clamp(softShadow(p, -lightDirection, 100. * PRECISION, length(p - lightPosition)), 0.2, 1.0);\n        col *= softShadow;\n    }\n\n    if (co.id == 2 && scene(p).sd < 10. * PRECISION) {\n        vec3 reflRD = reflect(rd, normal);\n        vec3 reflRO = p + 1.1 * PRECISION * normal;\n        Surface reflCO = rayMarch(reflRO, reflRD);\n        vec3 reflP = reflRO + reflRD * reflCO.sd;\n        vec3 reflNormal = calcNormal(reflP);\n        reflCO.sd += co.sd;\n        vec3 reflCol = phong(lightDirection, lightIntensity, reflNormal, reflRD, reflCO);\n        col = mix(col, reflCol, 0.2);\n    }\n\n    if (co.id == 3 && scene(p).sd < 10. * PRECISION) {\n        const float ETA = 1.69;\n        vec3 refrRD1 = refract(rd, normal, 1. / ETA);\n        vec3 refrRO1 = p - 2.1 * PRECISION * normal;\n        Surface refrCO1 = rayMarch(refrRO1, refrRD1);\n        vec3 refrP1 = refrRO1 + refrRD1 * refrCO1.sd;\n        vec3 refrN1 = calcNormal(refrP1);\n\n        vec3 refrRD2 = refract(refrRD1, -refrN1, ETA);\n        vec3 refrRO2 = refrP1 + 2.1 * PRECISION * refrN1;\n        Surface refrCO2 = rayMarch(refrRO2, refrRD2);\n        vec3 refrP2 = refrRO2 + refrRD2 * refrCO2.sd;\n        vec3 refrN2 = calcNormal(refrP2);\n        refrCO2.sd += refrCO1.sd + co.sd;\n        vec3 refrCol = phong(lightDirection, lightIntensity, refrN2, refrRD2, refrCO2);\n        col = mix(col, refrCol, 0.2);\n    }\n\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}