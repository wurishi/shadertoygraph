{"ver":"0.1","info":{"id":"NlyXRw","date":"1642192529","viewed":111,"name":"Simple Ray Tracer - unfinished","username":"Pyromma","description":"unfinished","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\n// Material\nstruct Material\n{\n    vec3 diffuse;\n    vec3 specular;\n    float glossiness;\n    float reflectance;\n\tfloat transmission;\n\tfloat iOR;\n};\n\nstruct HitInfo\n{\n    bool isHit;\n    bool inPrimitive;\n    float t;\n    vec3 position;\n    vec3 normal;\n    Material material;\n};\n\nHitInfo emptyHit()\n{\n    HitInfo hit;\n    hit.isHit = false;\n    hit.inPrimitive = false;\n    hit.t = 0.0;\n    hit.position = vec3(0.0); \n    hit.normal = vec3(0.0);\n    hit.material = Material(vec3(0.0), vec3(0.0), 0.0, 0.0, 0.0, 1.0);\n    return hit;\n}\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 direction;\n};\n\n// Shoot Ray\nRay getFragCoordRay(const vec2 frag_coord) {\n  \t   \n    // FOV\n    float fov = 100.;\n    float cameraDistance = 1.0f / tan(fov * 0.5f * PI / 180.0f);\n    \n    vec3 rayTarget = vec3((frag_coord/iResolution.xy) * 2.0f - 1.0f, cameraDistance);\n    rayTarget.y /= (iResolution.x / iResolution.y);\n    \n  \tvec3 origin = vec3(0.1*sin(iTime), 0.1*cos(iTime), 0.0);\n\n    vec3 direction = normalize(rayTarget - origin);\n  \n  \treturn Ray(origin, direction);\n}\n\n\n\n// Geometry & Light\n\nstruct Light \n{\n\tvec3 position;\n\tvec3 color;\n};\n\nstruct Sphere\n{\n    Material material;\n    vec3 position;\n    float radius;\n};\n\nstruct Cylinder\n{\n    Material material;\n    vec3 position;\n    float radius;\n    vec3 direction;\n};\n\nconst int lightsCount = 3;\nconst int spheresCount = 4;\nconst int cylindersCount = 3;\n\nstruct Scene\n{\n    vec3 ambient;\n    Light[lightsCount] light;\n    Sphere[spheresCount] sphere;\n    Cylinder[cylindersCount] cylinder;\n};\n\n/*\n    Useful functions\n*/\n\nfloat smallestT(in float t1, in float t2)\n{\n\tif(t2 < t1) \n    {\n\t\treturn t2;\n\t}\n    return t1;\n}\n\nbool inInterval(const float t, const float tMin, const float tMax)\n{\n    return t > tMin && t < tMax;\n}\n\nHitInfo closestHit(const HitInfo oldHitInfo, const HitInfo newHitInfo)\n{\n    if(newHitInfo.isHit)\n  \t\tif(newHitInfo.t < oldHitInfo.t)\n          return newHitInfo;\n  \treturn oldHitInfo;\n}\n\nvec3 background(const Ray ray, const Scene scene, vec2 fragCoord) {\n  // A simple implicit sky that can be used for the background\n  \tvec3 background = (vec3(texture(iChannel0, ray.direction.xy).x * 0.5) + vec3(0.5)) \n    * vec3(1.0-length(fragCoord.xy / iResolution.xy - 0.5), length(fragCoord.xy / iResolution.xy - 0.5), 0.5);\n     //* max(0.0, ray.direction.y);\n    return background * scene.ambient;\n}\n\nfloat fresnel(const vec3 viewDirection, const vec3 normal)\n{\n\treturn dot(normalize(viewDirection), normal) + 1.0;\n}\n\n/*\n    Intersections\n*/\n\nHitInfo intersectSphere(const Ray ray, const Sphere sphere, const float distMin, const float distMax)\n{\n    HitInfo hit;\n    \n    vec3 to_sphere = ray.origin - sphere.position;\n    \n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, to_sphere);\n    float c = dot(to_sphere, to_sphere) - sphere.radius * sphere.radius;\n    float D = b * b - 4.0 * a * c;\n    \n    if (D > 0.0)\n    {\n        float t0 = (-b - sqrt(D)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2.0 * a);\n        \n        float t = smallestT(t0, t1);\n        \n        if(inInterval(t, distMin, distMax))\n        {\n            hit.isHit = true;\n            hit.inPrimitive = length(ray.origin - sphere.position) < sphere.radius + distMin ? \n                true:\n                false;\n            hit.t = t;\n            hit.position = ray.origin + t * ray.direction; \n            hit.normal = hit.inPrimitive ? \n                -normalize(hit.position - sphere.position):\n                normalize(hit.position - sphere.position);\n            hit.material = sphere.material;\n        }\n                \n    }\n    \n    return hit;\n    \n}\n\nHitInfo intersectCylinder(const Ray ray, const Cylinder cylinder, const float distMin, const float distMax)\n{\n    HitInfo hit;\n    \n    vec3 to_cylinder = ray.origin - cylinder.position;\n    \n    float a = dot(ray.direction - dot(ray.direction, cylinder.direction) * cylinder.direction, ray.direction - dot(ray.direction, cylinder.direction) * cylinder.direction);\n\tfloat b = 2.0 * dot(ray.direction - dot(ray.direction, cylinder.direction) * cylinder.direction, to_cylinder - dot(to_cylinder, cylinder.direction) * cylinder.direction);\n\tfloat c = dot(to_cylinder - dot(to_cylinder, cylinder.direction) * cylinder.direction, to_cylinder - dot(to_cylinder, cylinder.direction) * cylinder.direction) - cylinder.radius * cylinder.radius;\n    float D = b * b - 4.0 * a * c;\n    \n    if (D > 0.0)\n    {\n        float t0 = (-b - sqrt(D)) / (2.0 * a);\n\t\tfloat t1 = (-b + sqrt(D)) / (2.0 * a);\n        \n        float t = smallestT(t0, t1);\n        \n        if(inInterval(t, distMin, distMax))\n        {\n            hit.isHit = true;\n            hit.inPrimitive = length(ray.origin - cylinder.position) < cylinder.radius + distMin ? \n                true:\n                false;\n            hit.t = t;\n            hit.position = ray.origin + t * ray.direction; \n            hit.normal = hit.inPrimitive ? \n                -normalize((hit.position - cylinder.position) - (dot(cylinder.direction,  (hit.position - cylinder.position))) * cylinder.direction):\n                normalize((hit.position - cylinder.position) - (dot(cylinder.direction,  (hit.position - cylinder.position))) * cylinder.direction);\n            hit.material = cylinder.material;\n        }\n                \n    }\n    \n    return hit;\n    \n}\n\nHitInfo intersectScene(Scene scene, const Ray ray, const float distMin, const float distMax)\n{\n     HitInfo hit = emptyHit();\n     hit.t = distMax;\n     \n     for(int i = 0; i < spheresCount; i++)\n     {\n         hit = closestHit(hit, intersectSphere(ray, scene.sphere[i], distMin, distMax));\n     }\n     \n     for(int i = 0; i < cylindersCount; i++)\n     {\n         hit = closestHit(hit, intersectCylinder(ray, scene.cylinder[i], distMin, distMax));\n     }\n     \n     return hit;\n}\n\nvec3 shadeFromLight(const Scene scene, const Ray ray, const HitInfo hit, const Light light)\n{ \n  vec3 hitToLight = light.position - hit.position;\n  \n  vec3 lightDirection = normalize(hitToLight);\n  vec3 viewDirection = normalize(hit.position - ray.origin);\n  vec3 reflectedDirection = reflect(viewDirection, hit.normal);\n  float diffuse = max(0.0, dot(lightDirection, hit.normal));\n  float specular  = pow(max(0.0, dot(lightDirection, reflectedDirection)), hit.material.glossiness);\n  \n  HitInfo shadowHit = intersectScene(scene, Ray(hit.position, lightDirection), 0.001, 1000.0);\n  \n  if(shadowHit.isHit)\n  {\n      return shadowHit.material.transmission * shadowHit.material.diffuse * light.color * (specular * hit.material.specular + diffuse * hit.material.diffuse);\n  }\t\n\n  return light.color * (specular * hit.material.specular + diffuse * hit.material.diffuse);\n}\n\nvec3 shade(const Scene scene, const Ray ray, const HitInfo hitInfo) \n{\n\t\n\t//return vec3(0.5) * hitInfo.normal + vec3(0.5);\n    vec3 shading = scene.ambient * hitInfo.material.diffuse;\n    //vec3 shading = scene.ambient * hitInfo.material.diffuse * 0.6 + hitInfo.normal * 0.4;\n    for (int i = 0; i < lightsCount; ++i) {\n        shading += shadeFromLight(scene, ray, hitInfo, scene.light[i]);\n    }\n    return shading;\n}\n\nScene initScene()\n{\n    Scene scene;\n    \n    scene.ambient = vec3(0.5) + 0.5 * vec3(cos(iTime), 0.5, 1.0 - sin(iTime));\n    \n    scene.light[0].position = vec3(7.0, 5.0, -10.0);\n    scene.light[0].color = vec3(0.5, 0.5, 0.0);\n    \n    scene.light[1].position = vec3(-40.0, 35.0, -1.0);\n    scene.light[1].color = vec3(0.0, 1.0, 0.3);\n    \n    scene.light[2].position = vec3(-4.0, -2.0, 9.0);\n    scene.light[2].color = vec3(1.0, 0.4, 0.1);\n    \n    scene.sphere[0].position = vec3(-2.0, -1.0, 3.0);\n    scene.sphere[0].radius = 1.0;\n\tscene.sphere[0].material.diffuse = vec3(0.6, 0.5, 0.0);\n    scene.sphere[0].material.specular = vec3(1.0);\n    scene.sphere[0].material.glossiness = 10.0;\n    scene.sphere[0].material.reflectance = 0.6;\n    scene.sphere[0].material.transmission = 0.0;\n    scene.sphere[0].material.iOR = 0.9;\n    \n    scene.sphere[1].position = vec3(0.3 * cos(iTime) - 1.8, 0.0, 3.5 + 0.5 * sin(iTime));\n    scene.sphere[1].radius = 1.0;\n\tscene.sphere[1].material.diffuse = vec3(0.0, 0.4, 0.5);\n    scene.sphere[1].material.specular = vec3(0.9);\n    scene.sphere[1].material.glossiness = 16.0;\n    scene.sphere[1].material.reflectance = 1.0;\n    scene.sphere[1].material.transmission = 1.0;\n    scene.sphere[1].material.iOR = 1.5;\n    \n    scene.sphere[2].position = vec3(sin(iTime), cos(iTime) - 0.3, 4.0);\n    scene.sphere[2].radius = 0.8;\n\tscene.sphere[2].material.diffuse = vec3(0.6, 0.1, 0.0);\n    scene.sphere[2].material.specular = vec3(0.4);\n    scene.sphere[2].material.glossiness = 10.0;\n    scene.sphere[2].material.reflectance = 0.8;\n    scene.sphere[2].material.transmission = 1.0;\n    scene.sphere[2].material.iOR = 1.7;\n    \n    scene.sphere[3].position = vec3(0.4, 0.3, 5.0);\n    scene.sphere[3].radius = 0.8;\n\tscene.sphere[3].material.diffuse = vec3(0.0, 0.15, 0.0);\n    scene.sphere[3].material.specular = vec3(1.5);\n    scene.sphere[3].material.glossiness = 40.0;\n    scene.sphere[3].material.reflectance = 1.0;\n    scene.sphere[3].material.transmission = 0.0;\n    scene.sphere[3].material.iOR = 1.3;\n    \n    scene.cylinder[0].position = vec3(1.3, -2.0, 10.0);\n    scene.cylinder[0].radius = 0.2;\n    scene.cylinder[0].direction = normalize(vec3(-0.1, -0.1, 1.0));\n\tscene.cylinder[0].material.diffuse = vec3(0.4, 0.04, 0.2);\n    scene.cylinder[0].material.specular = vec3(1.0);\n    scene.cylinder[0].material.glossiness = 20.0;\n    scene.cylinder[0].material.reflectance = 0.4;\n    \n    scene.cylinder[1].position = vec3(3.0, 7.0, 15.0);\n    scene.cylinder[1].radius = 0.3;\n    scene.cylinder[1].direction = normalize(vec3(-0.2, -0.1, 1.0));\n\tscene.cylinder[1].material.diffuse = vec3(0.4, 0.04, 0.2);\n    scene.cylinder[1].material.specular = vec3(1.0);\n    scene.cylinder[1].material.glossiness = 20.0;\n    scene.cylinder[1].material.reflectance = 0.4;\n    \n    scene.cylinder[2].position = vec3(5.0, 7.0, 15.0);\n    scene.cylinder[2].radius = 0.1;\n    scene.cylinder[2].direction = normalize(vec3(-0.2, -0.1, 1.0));\n\tscene.cylinder[2].material.diffuse = vec3(0.4, 0.04, 0.2);\n    scene.cylinder[2].material.specular = vec3(1.0);\n    scene.cylinder[2].material.glossiness = 20.0;\n    scene.cylinder[2].material.reflectance = 0.4;\n    \n    return scene;\n}\n\nvec3 colorFromCoord(Scene scene, vec2 fragCoord)\n{\n    // Minimum and Maximum distance that ray can travel in check for intresection\n    const float distMin = 0.01f;\n    const float distMax = 1000.0f;\n    \n    float bgVisibility = 1.;\n    \n    Ray initialRay = getFragCoordRay(fragCoord);   \n    HitInfo initialHitInfo = intersectScene(scene, initialRay, distMin, distMax);\n    \n    vec3 valueFrag = background(initialRay, scene, fragCoord);\n    \n    Ray currentRay = initialRay;\n    HitInfo currentHitInfo = initialHitInfo;\n    \n    float reflectionWeight = 1.0;\n    float refractionWeight = 1.0;\n  \t\n  \tconst int maxReflectionStepCount = 2;\n    const int maxRefractionStepCount = 2;\n    \n    float currentIOR = 1.0;\n    \n    if(initialHitInfo.isHit)\n    {\n        valueFrag = shade(scene, initialRay, initialHitInfo);\n        \n        for(int i = 0; i < maxReflectionStepCount; i++)\n        {\n            if(currentHitInfo.material.reflectance == 0.0) break;\n            reflectionWeight *= fresnel(currentRay.direction, currentHitInfo.normal);\n            reflectionWeight *= currentHitInfo.material.reflectance;\n        \n            currentRay = Ray(currentHitInfo.position, reflect(currentRay.direction, currentHitInfo.normal));\n            currentHitInfo = intersectScene(scene, currentRay, distMin, distMax);\n            \n            if(!currentHitInfo.isHit) \n            {\n               valueFrag += reflectionWeight * background(currentRay, scene, fragCoord) * (1.0 / bgVisibility);\n               break;\n            }\n            valueFrag += reflectionWeight * shade(scene, currentRay, currentHitInfo);\n        }\n        \n        currentRay = initialRay;\n        currentHitInfo = initialHitInfo;\n            \n        for(int i = 0; i < maxRefractionStepCount; i++)\n        {\n            if(currentHitInfo.material.transmission == 0.0) break;\n            float sourceIOR = currentIOR;\n            float destIOR = currentHitInfo.material.iOR;\n        \n            refractionWeight *= 1.0 - fresnel(currentRay.direction, currentHitInfo.normal);\n            refractionWeight *= currentHitInfo.material.transmission;\n        \n            currentRay = Ray(currentHitInfo.position, refract(currentRay.direction, currentHitInfo.normal, sourceIOR/destIOR));\n            currentHitInfo = intersectScene(scene, currentRay, distMin, distMax);\n            \n            currentIOR = destIOR;\n            \n            if(!currentHitInfo.isHit) \n            {\n               valueFrag += refractionWeight * background(currentRay, scene, fragCoord) * (1.0 / bgVisibility);\n               break;\n            }\n            valueFrag += refractionWeight * shade(scene, currentRay, currentHitInfo);\n        }\n    }\n\n    //return vec3(fresnel(currentRay.direction, currentHitInfo.normal),fresnel(initialRay.direction, initialHitInfo.normal),0);\n    return valueFrag;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Scene scene = initScene();\n\n    fragColor = vec4(colorFromCoord(scene, fragCoord), 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}