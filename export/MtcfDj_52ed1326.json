{"ver":"0.1","info":{"id":"MtcfDj","date":"1541715999","viewed":2658,"name":"Color Blindness LMS Curves","username":"Tynach","description":"Draws curves representing the LMS cone fundamentals atop the resulting spectrum. Blends between Gaussian parameters to simulate color blindness (some issues with tritanopia, however).\n\nPause as the curve you want to edit is animated to adjust via mouse.","likes":37,"published":1,"flags":0,"usePreview":0,"tags":["simulation","srgb","protanopia","deuteranopia","tritanopia","lms","spectral","protanomaly","deuteranomaly","tritanomaly","simulated"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/************************************************************************\n * Scroll to line 376 to change the parameters used to draw the diagram *\n ************************************************************************/\n\nprecision highp float;\n\n#define PI 3.1415926535897932384626433832795\n#define EULER 2.7182818284590452353602874713527\n#define EV_CONV 1239.842\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 white;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(r1, r2, g1, g2, b1, b2)\\\n\tmat3(\\\n\t\t(r1), (r2), 1.0 - (r1) - (r2),\\\n\t\t(g1), (g2), 1.0 - (g1) - (g2),\\\n\t\t(b1), (b2), 1.0 - (b1) - (b2))\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y)\\\n\tvec3((x), (y), 1.0 - (x) - (y))/(y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag(inverse((space).primaries)*(space).white)\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\n/*\n * Standard XYZ -> LMS transformation matrices\n */\n\nconst mat3 CIECAM02 = mat3(\n\t0.7328, -0.7036, 0.003,\n\t0.4296, 1.6975, 0.0136,\n\t-0.1624, 0.0061, 0.9834\n);\n\nconst mat3 HUNT = mat3(\n\t0.38971, -0.22981, 0,\n\t0.68898, 1.1834, 0,\n\t-0.07868, 0.04641, 1\n);\n\nconst mat3 CIECAM97_1 = mat3(\n\t0.8951, -0.7502, 0.0389,\n\t0.2664, 1.7135, -0.0685,\n\t-0.1614, 0.0367, 1.0296\n);\n\nconst mat3 CIECAM97_2 = mat3(\n\t0.8562, -0.836, 0.0357,\n\t0.3372, 1.8327, -0.0469,\n\t-0.1934, 0.0033, 1.0112\n);\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// CIE 1931 RGB\nconst mat3 primariesCie = Primaries(\n\t0.72329, 0.27671,\n\t0.28557, 0.71045,\n\t0.15235, 0.02\n);\n\n// Identity RGB\nconst mat3 primariesIdentity = mat3(1.0);\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC (Rec. 601) and SMPTE-240M\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Never-popular, antiquated, and idealized 'HDTV' primaries based mostly on the\n// 1953 NTSC colorspace. SMPTE-240M officially used the SMPTE-C primaries\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// DCI-P3 primaries\nconst mat3 primariesDciP3 = Primaries(\n\t0.68, 0.32,\n\t0.265, 0.69,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// If the HUNT XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesHunt = Primaries(\n\t0.8374, 0.1626,\n\t2.3, -1.3,\n\t0.168, 0.0\n);\n\n// If the CIECAM97_1 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam971 = Primaries(\n\t0.7, 0.306,\n\t-0.357, 1.26,\n\t0.136, 0.042\n);\n\n// If the CIECAM97_2 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam972 = Primaries(\n\t0.693, 0.316,\n\t-0.56, 1.472,\n\t0.15, 0.067\n);\n\n// If the CIECAM02 XYZ->LMS matrix were expressed instead as\n// chromaticity coordinates, these would be them\nconst mat3 primariesCiecam02 = Primaries(\n\t0.711, 0.295,\n\t-1.476, 2.506,\n\t0.144, 0.057\n);\n\n// LMS primaries as chromaticity coordinates, computed from\n// http://www.cvrl.org/ciepr8dp.htm, and\n// http://www.cvrl.org/database/text/cienewxyz/cie2012xyz2.htm\n/*const mat3 primariesLms = Primaries(\n\t0.73840145, 0.26159855,\n\t1.32671635, -0.32671635,\n\t0.15861916, 0.0\n);*/\n\n// Same as above, but in fractional form\nconst mat3 primariesLms = Primaries(\n\t194735469.0/263725741.0, 68990272.0/263725741.0,\n\t141445123.0/106612934.0, -34832189.0/106612934.0,\n\t36476327.0/229961670.0, 0.0\n);\n\n// Original LMS matrix used to derive above primaries\nconst mat3 xyzFromLms = mat3(\n\t1.94735469, 0.68990272, 0,\n\t-1.41445123, 0.34832189, 0,\n\t0.36476327, 0, 1.93485343\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = White(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = White(1.0/3.0, 1.0/3.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = White(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = White(0.312713, 0.329016);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = White(0.34567, 0.35850);\n\n// White point for DCI-P3 Theater\nconst vec3 whiteTheater = White(0.314, 0.351);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = White(0.283, 0.298);\n\n// White balance for LMS so that each channel's spectral sensitivities peak at\n// exactly 1.0, at least according to the 2006 cone fundamentals\n//const vec3 whiteLmsUnity = White(89766673.0/387074477.0, 103822461.0/387074477.0);\nconst vec3 whiteLmsUnity = vec3(0.89766673, 1.03822461, 1.93485343);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Linear gamma\nconst transfer gam10 = transfer(1.0, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 1.8; used by older Macintosh systems\nconst transfer gam18 = transfer(1.8, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, and is what Adobe RGB uses\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308);\n\n\n/*\n * RGB Colorspaces\n */\n\n// CIE 1931 RGB\nconst rgb_space Cie1931 = rgb_space(primariesCie, whiteE, gam10);\n\n// Identity RGB\nconst rgb_space Identity = rgb_space(primariesIdentity, whiteE, gam10);\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// DCI-P3 D65\nconst rgb_space DciP3D65 = rgb_space(primariesDciP3, whiteD65, gam170m);\n\n// DCI-P3 D65\nconst rgb_space DciP3Theater = rgb_space(primariesDciP3, whiteTheater, gam170m);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65, gam170m);\n\n// Hunt primaries, balanced against equal energy white point\nconst rgb_space HuntRgb = rgb_space(primariesHunt, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point\nconst rgb_space Ciecam971Rgb = rgb_space(primariesCiecam971, whiteE, gam10);\n\n// CIE CAM 1997 primaries, balanced against equal energy white point and linearized\nconst rgb_space Ciecam972Rgb = rgb_space(primariesCiecam972, whiteE, gam10);\n\n// CIE CAM 2002 primaries, balanced against equal energy white point\nconst rgb_space Ciecam02Rgb = rgb_space(primariesCiecam02, whiteE, gam10);\n\n// Lms primaries, balanced against equal energy white point\nconst rgb_space LmsRgb = rgb_space(primariesLms, whiteE, gam10);\n\n\n/**************\n *            *\n *  Settings  *\n *            *\n **************/\n\n// Convert to this colorspace\nconst rgb_space space = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// Use LMS primaries instead of a pre-created matrix\nconst mat3 toRgb = xyzToRgb(space);\nconst mat3 toXyz = rgbToXyz(space);\nconst mat3 toLms = xyzToRgb(LmsRgb);\nconst mat3 whiteBalance = diag((toLms*space.white)/(toLms*whiteE));\n\n\n// Converts RGB colors to a linear light scale\nvec3 toLinear(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToLinear));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToLinear));\n\tvec3 higher = pow((color + trc.off)/(1.0 + trc.off), vec3(trc.power));\n\tvec3 lower = color/trc.slope;\n\tvec3 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec3(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec3 toGamma(vec3 color, transfer trc)\n{\n\tbvec3 cutoff = lessThan(color, vec3(trc.cutoffToGamma));\n\tbvec3 negCutoff = lessThanEqual(color, vec3(-1.0*trc.cutoffToGamma));\n\tvec3 higher = (1.0 + trc.off)*pow(color, vec3(1.0/trc.power)) - trc.off;\n\tvec3 lower = color*trc.slope;\n\tvec3 neg = (-1.0 - trc.off)*pow(-1.0*color, vec3(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// x = current wavelength\n// u = control point wavelength\n#define gauss(x, u, o, A)\\\n\tA/o*exp(-0.5*pow((x - u)/o, 2.0))\n\n// Converts from a wavelength to LMS.\n// Constructed using multi-peak Gaussian functions generated using Labplot\n// and closely fitted to the CIE 2006 2Â° cone fundamentals created by\n// Stockman & Sharp 2000).\n// Takes an 'amount' vector which determines how strong each type of\n// color blindness will be\nvec3 waveToLms(float wave, vec3 amount)\n{\n\t// LMS Gaussian function parameters for each cone type\n\tconst vec3[5] lParams = vec3[](\n\t\tvec3(449.682, 21.6622, 2.36612),\n\t\tvec3(477.589, 11.0682, 1.39883),\n\t\tvec3(532.488, 25.7494, 34.0478),\n\t\tvec3(570.2, 5.91487, 0.243387),\n\t\tvec3(585.858, 34.98, 77.8669)\n\t);\n\n\tconst vec3[5] mParams = vec3[](\n\t\tvec3(450.237, 19.5222, 3.33537),\n\t\tvec3(479.559, 13.3211, 3.68813),\n\t\tvec3(519.924, 17.1502, 9.68484),\n\t\tvec3(542.8, 3.27696, 0.105766),\n\t\tvec3(552.158, 33.3895, 77.9298)\n\t);\n\n\tconst vec3[5] sParams = vec3[](\n\t\tvec3(467.661, 8.84562, 5.32073),\n\t\tvec3(422.211, 10.2028, 8.58498),\n\t\tvec3(443.084, 11.9848, 19.6347),\n\t\tvec3(444.863, 1.30608, -0.0330768),\n\t\tvec3(460.886, 25.7907, 24.9128)\n\t);\n\n\t// Color blindness simulation constants\n\tconst vec3 white = inverse(xyzFromLms)*whiteE;\n\tconst vec3 blue = inverse(xyzFromLms)*LmsRgb.primaries[2];\n\tconst vec3 red = inverse(xyzFromLms)*LmsRgb.primaries[0];\n\n\tconst vec2 prota = inverse(mat2(\n\t\twhite.g, blue.g,\n\t\twhite.b, blue.b\n\t))*vec2(white.r, blue.r);\n\n\tconst vec2 deuta = inverse(mat2(\n\t\twhite.r, blue.r,\n\t\twhite.b, blue.b\n\t))*vec2(white.g, blue.g);\n\n\tconst vec2 trita = inverse(mat2(\n\t\twhite.r, red.r,\n\t\twhite.g, red.g\n\t))*vec2(white.b, red.b);\n\n\t// Color blindness adjusted parameters for each cone type\n\tvec3[5] lParamsMod = vec3[](\n\t\tmix(lParams[0], mParams[0], amount.x),\n\t\tmix(lParams[1], mParams[1], amount.x),\n\t\tmix(lParams[2], mParams[2], amount.x),\n\t\tmix(lParams[3], mParams[3], amount.x),\n\t\tmix(lParams[4], mParams[4], amount.x)\n\t);\n\n\tvec3[5] mParamsMod = vec3[](\n\t\tmix(mParams[0], lParams[0], amount.y),\n\t\tmix(mParams[1], lParams[1], amount.y),\n\t\tmix(mParams[2], lParams[2], amount.y),\n\t\tmix(mParams[3], lParams[3], amount.y),\n\t\tmix(mParams[4], lParams[4], amount.y)\n\t);\n\n\tvec3[5] sParamsMod = vec3[](\n\t\tmix(sParams[0], mParams[0], amount.z),\n\t\tmix(sParams[1], mParams[1], amount.z),\n\t\tmix(sParams[2], mParams[2], amount.z),\n\t\tmix(sParams[3], mParams[3], amount.z),\n\t\tmix(sParams[4], mParams[4], amount.z)\n\t);\n\n\t// Color blindness adaptation matrices\n\t/*mat3 adaptProta = mat3(\n\t\t1.0 - amount.x, 0.0, 0.0,\n\t\tprota.x*amount.x, 1.0, 0.0,\n\t\tprota.y*amount.x, 0.0, 1.0\n\t);\n\n\tmat3 adaptDeuta = mat3(\n\t\t1.0, deuta.x*amount.y, 0.0,\n\t\t0.0, 1.0 - amount.y, 0.0,\n\t\t0.0, deuta.y*amount.y, 1.0\n\t);\n\n\tmat3 adaptTrita = mat3(\n\t\t1.0, 0.0, trita.x*amount.z,\n\t\t0.0, 1.0, trita.y*amount.z,\n\t\t0.0, 0.0, 1.0 - amount.z\n\t);\n\n\tmat3 adapt = adaptTrita*adaptDeuta*adaptProta;*/\n\n\tmat3 adapt = mat3(\n\t\t1.0 - amount.x, deuta.x*amount.y, trita.x*amount.z,\n\t\tprota.x*amount.x, 1.0 - amount.y, trita.y*amount.z,\n\t\tprota.y*amount.x, deuta.y*amount.y, 1.0 - amount.z\n\t);\n\n\t// Return the LMS values for the given wavelength\n\treturn (adapt*vec3(1))*vec3(\n\t\t// L cone response curve\n\t\tgauss(wave, lParamsMod[0].x, lParamsMod[0].y, lParamsMod[0].z) +\n\t\tgauss(wave, lParamsMod[1].x, lParamsMod[1].y, lParamsMod[1].z) +\n\t\tgauss(wave, lParamsMod[2].x, lParamsMod[2].y, lParamsMod[2].z) +\n\t\tgauss(wave, lParamsMod[3].x, lParamsMod[3].y, lParamsMod[3].z) +\n\t\tgauss(wave, lParamsMod[4].x, lParamsMod[4].y, lParamsMod[4].z),\n\n\t\t// M cone response curve\n\t\tgauss(wave, mParamsMod[0].x, mParamsMod[0].y, mParamsMod[0].z) +\n\t\tgauss(wave, mParamsMod[1].x, mParamsMod[1].y, mParamsMod[1].z) +\n\t\tgauss(wave, mParamsMod[2].x, mParamsMod[2].y, mParamsMod[2].z) +\n\t\tgauss(wave, mParamsMod[3].x, mParamsMod[3].y, mParamsMod[3].z) +\n\t\tgauss(wave, mParamsMod[4].x, mParamsMod[4].y, mParamsMod[4].z),\n\n\t\t// S cone response curve\n\t\tgauss(wave, sParamsMod[0].x, sParamsMod[0].y, sParamsMod[0].z) +\n\t\tgauss(wave, sParamsMod[1].x, sParamsMod[1].y, sParamsMod[1].z) +\n\t\tgauss(wave, sParamsMod[2].x, sParamsMod[2].y, sParamsMod[2].z) +\n\t\tgauss(wave, sParamsMod[3].x, sParamsMod[3].y, sParamsMod[3].z) +\n\t\tgauss(wave, sParamsMod[4].x, sParamsMod[4].y, sParamsMod[4].z)\n\t)/sqrt(2.0*PI);\n}\n\n// Scales a color to the closest in-gamut representation of that color\n// Preserves both hue and luminosity, but at the cost of saturation\nvec3 gamutScale(vec3 color)\n{\n\tfloat luma = (toXyz*color).y;\n\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor += scale*(luma - color);\n\n\treturn color;\n}\n\n\nconst float minWave = 390.0;\nconst float maxWave = 730.0;\nconst float waveRange = maxWave - minWave;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Number of pixels to the left and right of the current pixel to sample\n\t// the LMS spectral values\n\tconst float offset = 0.5;\n\n\t// Which period of 5-second intervals is currently active\n\t// Synchronizes with the default animation's timing\n\tfloat timeSegment = mod(iTime/5.0, 3.0);\n\n\t// How strong the color blindness is for each channel\n\tvec3 amount;\n\n\t// By default (or if the leftmost column of pixels was clicked last)\n\tif (iMouse.x == 0.0) {\n\t\t// Have the amount of each channel move on a sine wave that is\n\t\t// different for each channel, clamped so that only one changes\n\t\t// at a time, each taking 5 seconds. iTime values of note:\n\n\t\t// amount.x ('L') starts:  0.0; peaks:  2.5; ends:  5.0\n\t\t// amount.y ('M') starts:  5.0; peaks:  7.5; ends: 10.0\n\t\t// amount.z ('S') starts: 10.0; peaks: 12.5; ends: 15.0\n\t\tamount = vec3(iTime*2.0/15.0);\n\t\tamount += vec3(1.0/6.0, -0.5, -7.0/6.0);\n\t\tamount = clamp(sin(amount*PI)*2.0 - 1.0, 0.0, 1.0);\n\t} else {\n\t\t// Depending on which 'time segment' is currently observed, change\n\t\t// which curve the user can edit with their mouse\n\n\t\t// These are meant to be synchronized with the animation detailed\n\t\t// above, that way a user can pause the shader to manipulate the\n\t\t// curve that was being animated at the time they paused it\n\t\tamount = vec3(\n\t\t\tiMouse.x/iResolution.x*float(floor(timeSegment) == 0.0),\n\t\t\tiMouse.x/iResolution.x*float(floor(timeSegment) - 1.0 == 0.0),\n\t\t\tiMouse.x/iResolution.x*float(floor(timeSegment) - 2.0 == 0.0)\n\t\t);\n\t}\n\n\t// Obtain the LMS values to eventually become the color for each pixel\n\tvec2 uv = gl_FragCoord.xy/iResolution.xy;\n\tvec3 color = waveToLms(waveRange*uv.x + minWave, amount);\n\n\t// Only show the spectrum in the center slice\n\tbvec3 showSpectrum = bvec3(int(uv.y*3.0) % 3 - 1);\n\tcolor = mix(color, vec3(0), showSpectrum);\n\n\t// Uniformly brighten the image to fit it within sRGB while\n\t// retaining full accuracy\n\tcolor += inverse(xyzFromLms)*vec3(1.076);\n\tcolor /= 3.71;\n\n\t// Perform white balance and convert to RGB\n\tcolor = toRgb*xyzFromLms*whiteBalance*color;\n\n\t// Scale out-of-gamut colors just in case\n\tcolor = gamutScale(color);\n\n\t// Sample of the line 'offset' pixels to the left and right of the\n\t// current column of pixels\n\tvec3 bef = waveToLms(waveRange*(fragCoord.x + offset)/iResolution.x + minWave, amount)/2.5;\n\tvec3 aft = waveToLms(waveRange*(fragCoord.x - offset)/iResolution.x + minWave, amount)/2.5;\n\n\t// Apply white balance to LMS curve samples\n\tbef = toLms*xyzFromLms*whiteBalance*bef;\n\taft = toLms*xyzFromLms*whiteBalance*aft;\n\n\n\t// Calculate distance from the L line\n\tvec2 p1L = vec2(fragCoord.x - offset, bef.x*iResolution.y);\n\tvec2 p2L = vec2(fragCoord.x + offset, aft.x*iResolution.y);\n\tvec2 toUvL = p2L - fragCoord;\n\tvec2 unitL = normalize(p2L - p1L);\n\tfloat distL = length(toUvL - dot(toUvL, unitL)*unitL);\n\n\t// Calculate distance from the M line\n\tvec2 p1M = vec2(fragCoord.x - offset, bef.y*iResolution.y);\n\tvec2 p2M = vec2(fragCoord.x + offset, aft.y*iResolution.y);\n\tvec2 toUvM = p2M - fragCoord;\n\tvec2 unitM = normalize(p2M - p1M);\n\tfloat distM = length(toUvM - dot(toUvM, unitM)*unitM);\n\n\t// Calculate distance from the S line\n\tvec2 p1S = vec2(fragCoord.x - offset, bef.z*iResolution.y);\n\tvec2 p2S = vec2(fragCoord.x + offset, aft.z*iResolution.y);\n\tvec2 toUvS = p2S - fragCoord;\n\tvec2 unitS = normalize(p2S - p1S);\n\tfloat distS = length(toUvS - dot(toUvS, unitS)*unitS);\n\n\n\t// Calculate line colors\n\tvec3 lineL = inverse(toLms)*whiteBalance*vec3(1, 0.1, 0.1);\n\tvec3 lineM = inverse(toLms)*whiteBalance*vec3(0.1, 1, 0.1);\n\tvec3 lineS = inverse(toLms)*whiteBalance*vec3(0.1, 0.1, 1);\n\n\t// Set all colored lines to the same luminosity\n\tlineL = lineL/lineL.y*0.25;\n\tlineM = lineM/lineM.y*0.25;\n\tlineS = lineS/lineS.y*0.25;\n\n\t// Convert line colors to RGB and scale them to be in-gamut so they blend smoothly\n\tlineL = gamutScale(toRgb*lineL);\n\tlineM = gamutScale(toRgb*lineM);\n\tlineS = gamutScale(toRgb*lineS);\n\n\n\t// Draw the black lines\n\tcolor = mix(vec3(0), color, clamp(distL - 2.5*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(vec3(0), color, clamp(distM - 2.5*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(vec3(0), color, clamp(distS - 2.5*iResolution.y/1024.0, 0.0, 1.0));\n\n\t// Draw the colored lines\n\tcolor = mix(lineL, color, clamp(distL - 1.0*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(lineM, color, clamp(distM - 1.0*iResolution.y/1024.0, 0.0, 1.0));\n\tcolor = mix(lineS, color, clamp(distS - 1.0*iResolution.y/1024.0, 0.0, 1.0));\n\n\n\t// Apply display transfer characteristics (or 'gamma')\n\tcolor = toGamma(color, space.trc);\n\n\t// Set the pixel's color\n\tfragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}