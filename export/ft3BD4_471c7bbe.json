{"ver":"0.1","info":{"id":"ft3BD4","date":"1663122365","viewed":546,"name":"Lego Water","username":"Spheya","description":"water :)","likes":34,"published":1,"flags":0,"usePreview":0,"tags":["lego"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Hit {\n    vec3 pos;\n    vec3 normal;\n    vec3 albedo;\n    bool hit;\n};\n\nfloat aabbIntersection(vec3 ro, vec3 rd, vec3 bMin, vec3 bMax) {\n    // Ray AABB intersection from\n    // https://tavianator.com/2011/ray_box.html\n    vec3 t1 = (bMin - ro) / rd;\n    vec3 t2 = (bMax - ro) / rd;\n    vec3 t3 = min(t1, t2);\n    vec3 t4 = max(t1, t2);\n    float tMin = max(t3.x, max(t3.y, t3.z));\n    float tMax = min(t4.x, max(t4.y, t4.z));\n    return tMax >= tMin ? tMin : -1.0;\n}\n\nvec3 cylinderIntersection (vec3 ro, vec3 rd, float r, float h, out vec3 normal){\n    float distToTopPlane = (h - ro.y) / rd.y;\n    vec3 topPlaneHitPos = ro + rd * distToTopPlane;\n    if(dot(topPlaneHitPos.xz, topPlaneHitPos.xz) < r*r) {\n        normal = vec3(0.0, 1.0, 0.0);\n        return topPlaneHitPos;\n    }\n    \n    float len = length(rd.xz);\n    float distToClosestPoint = -dot(ro.xz, rd.xz/len);\n    vec2 closestPoint = ro.xz + rd.xz/len * distToClosestPoint;\n    float distToCenterSq = dot(closestPoint, closestPoint);\n    if(distToCenterSq < r * r && distToClosestPoint > 0.0) {\n        float offset = sqrt(r * r - distToCenterSq);\n        vec3 pos = ro + (rd/len) * (distToClosestPoint - offset);\n        if(pos.y > h || pos.y < -h)\n            return vec3(0.0);\n        \n        vec2 n = normalize(pos.xz);\n        normal = vec3(n.x, 0.0, n.y);\n        return pos;\n    }\n    return vec3(0.0);\n}\n\nvec3 roundPlateIntersection(vec3 ro, vec3 rd, out vec3 normal) {\n    vec3 stub = cylinderIntersection(ro - vec3(0.0, 0.3, 0.0), rd, 0.3, 0.1, normal);\n    if(stub != vec3(0.0))\n        return stub;\n    \n    vec3 bigCylinder = cylinderIntersection(ro - vec3(0.0, 0.15, 0.0), rd, 0.48, 0.06, normal);\n    if(bigCylinder != vec3(0.0))\n        return bigCylinder;\n        \n    vec3 smallCylinder = cylinderIntersection(ro - vec3(0.0, 0.12, 0.0), rd, 0.384, 0.24, normal);\n    if(smallCylinder != vec3(0.0))\n        return smallCylinder;\n}\n\nfloat brickHeight(float h) {\n    return round(h * 2.4) / 2.4;\n}\n\nfloat wave(float x) {\n    return 1.0 - sqrt(sin(x) * 0.5 + 0.5);\n}\n\nbool hitsVoxel(vec2 gridPos, vec3 ro, vec3 rd, vec2 mask, out vec3 normal, out vec3 albedo) {\n    normal = vec3(0.0);\n    albedo = vec3(0.0, 0.2, 0.5);\n\n    if(min(gridPos.x, gridPos.y) < 0.0  || \n       max(gridPos.x, gridPos.y) >= 40.0 ||\n       ro.y < 0.0)\n        return false;\n        \n    vec2 noiseOffset = vec2(texture(iChannel0, gridPos / 200.0).x, texture(iChannel0, (gridPos / 200.0) + 0.5).x) * 30.0;\n    \n    vec2 noisePos = gridPos + noiseOffset;\n    float w1 = wave(noisePos.x *  0.10 + noisePos.y *  0.05 + iTime * 1.5) * 8.0;\n    float w2 = wave(noisePos.x * -0.10 + noisePos.y *  0.05 + iTime * 1.0) * 8.0;\n    float w3 = wave(noisePos.x * -0.20 + noisePos.y * -0.44 + iTime * 3.0) * 1.0;\n    float w4 = wave(noisePos.x *  0.10 + noisePos.y * -0.20 + iTime * 6.0) * 3.0;\n    float w5 = wave(noisePos.x * -0.03 + noisePos.y *  0.08 + iTime * 1.0) * 3.0;\n    \n    float w = w1 + w2 + w3 + w4 + w5;\n        \n    w = pow(w, 1.5) * 0.15;\n    \n    float height = brickHeight(w) + 0.41666;\n    \n    noiseOffset.x;\n    if(ro.y < height) {\n        normal = vec3(mask.x, 0.0, mask.y) * -sign(rd);\n        albedo = vec3(0.0, 0.2, 0.5) * (min(ro.y*0.05, 0.6)+0.4);\n        return true;\n    }\n    \n    float t = min((floor(max(max(w1, w2), max(w4, w5)) / 2.0) * 2.0) / 4.0, 1.0);\n    vec3 albedoCol = vec3(0.0, 0.2, 0.5) * t + vec3(0.1, 0.35, 0.5) * (1.0 - t);\n     \n    vec3 pos;\n    if(max(w1, w2) > 7.2 || w5 > 2.9) {\n        vec3 offset = vec3(gridPos.x + 0.5, height, gridPos.y + 0.5);\n        pos = roundPlateIntersection(ro - rd - offset, rd, normal);\n        albedo = vec3(0.9, 0.9, 1.0);\n    } else {\n        vec3 offset = vec3(gridPos.x + 0.5, height + 0.1, gridPos.y + 0.5);\n        pos = cylinderIntersection(ro - rd - offset, rd, 0.3, 0.1, normal);\n        albedo = albedoCol;\n    }\n    if(pos != vec3(0.0))\n        return true;\n    \n    albedo = albedoCol;\n    \n    float dist = (height - ro.y) / rd.y;\n    vec3 hitPos = ro + rd * dist;\n    if(hitPos.x < gridPos.x + 1.0 && hitPos.z < gridPos.y + 1.0 && hitPos.x > gridPos.x && hitPos.z > gridPos.y) {\n        normal = vec3(0.0, 1.0, 0.0);\n        return true;\n    }\n    \n    return false;\n}\n\nHit rayMiss(vec3 ro, vec3 rd) {\n    float distToGround = -ro.y / rd.y;\n    if(distToGround > 1.0) {\n        Hit hit;\n        hit.pos = ro + rd * distToGround;\n        vec2 d = abs(hit.pos.xz-20.0) - vec2(20.0);\n        float ao = length(max(d, 0.0)) + min(max(d.x,d.y), 0.0);\n        hit.albedo = vec3(min(ao * 1.2, 0.6)) + 0.4;\n        hit.normal = vec3(0.0, 1.0, 0.0);\n        hit.hit = true;\n        return hit;\n    }\n    Hit hit;\n    hit.pos = vec3(0.0);\n    hit.albedo = vec3(0.0);\n    hit.normal = vec3(0.0);\n    hit.hit = false;\n    return hit;\n}\n\nHit castRay(vec3 ro3, vec3 rd3) {\n    vec2 ro = ro3.xz;\n    vec2 rd = rd3.xz;\n    \n    float boundingBoxIntersect = aabbIntersection(ro3, rd3, vec3(0.0), vec3(40.0));\n    if(boundingBoxIntersect == -1.0) {\n        return rayMiss(ro3, rd3);\n    }\n    if(boundingBoxIntersect < 0.0)\n        boundingBoxIntersect = 0.01;\n\n    // Grid traversal from\n    // https://www.shadertoy.com/view/4dX3zl\n    vec2 gridPos = floor(ro + rd * (boundingBoxIntersect - 0.01));\n    vec2 sideDist = abs(length(rd) / rd);\n    vec2 toSide = (sign(rd) * (gridPos - ro) + (sign(rd) * 0.5) + 0.5) * sideDist;\n    \n    vec3 pos = ro3;\n    vec2 mask;\n    bool hits = false;\n    vec3 normal = vec3(0.0);\n    vec3 albedo = vec3(0.0);\n    \n    for(int i = 0; i < 80; ++i) {\n        if(hitsVoxel(gridPos, pos, rd3, mask, normal, albedo)) {\n            hits = true;\n            break;\n        }\n    \n        mask = vec2(lessThanEqual(toSide.xy, toSide.yx));\n        toSide += sideDist * mask;\n        gridPos += mask * sign(rd);\n        \n        float dist = dot(mask * ((gridPos + vec2(lessThan(rd, vec2(0.0))) - ro) / rd), vec2(1.0));\n        pos = ro3 + rd3 * dist;\n    }\n    \n    if(hits) {\n        Hit hit;\n        hit.pos = pos;\n        hit.albedo = albedo;\n        hit.normal = normal;\n        hit.hit = true;\n        return hit;\n    }else{\n        return rayMiss(ro3, rd3);\n    }\n}\n\nvec3 calculateColor(vec3 albedo, vec3 normal, vec3 pos, vec3 viewDir, vec2 seed) {\n    const vec3 lDir = normalize(vec3(1.0, 1.0, -0.2));\n    \n    float shadow = 0.0;\n    for(int i = 0; i < 12; i++) {\n        vec3 rand = textureLod(iChannel1, seed, 0.0).xyz;\n        seed = fract(rand.xy * 100.0);\n        vec3 rayDirection = normalize(lDir + (rand - 0.5) * 0.4);\n        shadow += castRay(pos + rayDirection * 0.001, rayDirection).hit ? 0.0 : 1.0;\n    }\n    shadow /= 12.0;\n    \n    float diffuse = max(dot(normal, lDir), 0.0) * shadow;\n    diffuse = diffuse * 0.7 + 0.45;\n    \n    float r0 = 0.1;\n    float fresnel = r0 + (1.0 - r0) * pow(1.0 - dot(-viewDir, normal), 5.0);\n    float specular = max(dot(reflect(viewDir, normal), lDir), 0.0) * fresnel * (shadow * 0.9 + 0.1);\n    \n    return diffuse * albedo + specular + fresnel * 0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screenPos = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    vec3 ro = vec3(-25.0, 62.0, -25.0);\n    \n    float angle = sin(iTime) * 0.5;\n    vec3 rd = normalize(vec3(screenPos, 1.8));\n    float rx = 30.0;\n    float ry = 45.0;\n    rd *= mat3(\n       0.7071, 0.5, 0.5, \t\t\n\t   0.0,     0.7071,   -0.7071,\n\t  -0.7071, 0.5, 0.5\n    );\n\n    Hit mainRay = castRay(ro, rd);\n    if(mainRay.hit) {\n        vec3 col = calculateColor(mainRay.albedo, mainRay.normal, mainRay.pos, rd, fragCoord * 113.14235);\n        fragColor = vec4(pow(col, vec3(1.0 / 2.2)), 1.0);\n    } else {\n        fragColor = vec4(0.1, 0.1, 0.1, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}