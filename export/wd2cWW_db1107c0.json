{"ver":"0.1","info":{"id":"wd2cWW","date":"1586968676","viewed":206,"name":"The Dyson Sphere","username":"ZiMMaBuE","description":"Dyson sphere","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["sphere","reproduction","dyson"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define MAX_DIST 20.\n#define EPS 0.001\nconst float PI = acos(-1.0);\n\nmat3 rotX(float angle)\n{\n    return mat3(1,\t0,\t\t\t0,\n               0,\tcos(angle), -sin(angle),\n               0,\tsin(angle), cos(angle));\n}\n\nmat3 rotY(float angle)\n{\n\treturn mat3(cos(angle), 0, sin(angle),\n               0,\t\t\t1, 0,\n               -sin(angle), 0, cos(angle));\n}\n\nmat3 rotZ(float angle)\n{\n\treturn mat3(cos(angle), -sin(angle), 0,\n               sin(angle), \tcos(angle),\t 0,\n               0,\t\t \t0,\t\t\t 1);\n}\n\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\n\nfloat sdCube(vec2 pos, vec2 r)\n{\n\tvec2 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat sdCube(vec3 pos, vec3 r)\n{\n\tvec3 q = abs(pos) - r;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere(vec3 pos, float r)\n{\n    return length(pos) - r;\n}\n\nfloat sdRing(vec3 pos, float r)\n{\n    pos.zy = opRevolution(pos, r);\n    return sdCube(vec2(pos.z, pos.y), vec2(0.02, 0.03));\n}\n\nfloat sdRingsCross1( in vec3 pos, in float r )\n{\n    float d1 = sdRing(pos, r);\n    \n    pos *= rotZ(PI/2.);\n    float d2 = sdRing(pos, r);\n    \n    pos *= rotX(PI/2.);\n    float d3 = sdRing(pos, r);\n    \n    pos *= rotX(PI/4.);\n    float d4 = sdRing(pos, r);\n    \n    return min(d1,min(d2,min(d3,d4)));\n}\n\nfloat sdRingsCross2( in vec3 pos, in float r )\n{\n    pos *= rotZ(PI/4.);\n    float d1 = sdRing(pos, r);\n    \n    pos *= rotZ(PI/2.);\n    float d2 = sdRing(pos, r);\n    \n    return min(d1,d2);\n}\n\nfloat sdDysonSphere( in vec3 pos, in float r )\n{\n    float d1 = sdRingsCross1(pos, r);\n    \n    pos *= rotY(PI/4.);\n    float d2 = sdRingsCross2(pos, r);\n    \n    pos *= rotY(PI/2.);\n    float d3 = sdRingsCross2(pos, r);\n    \n    return min(d1, min(d2, d3));\n}\n\nfloat map(vec3 pos)\n{\n    \n    float d0 = sdSphere(pos, 0.2+sin(iTime*0.3)*0.05);\n    float d1 = sdDysonSphere(pos * rotY(iTime * 1.00), 0.5);\n    float d2 = sdDysonSphere(pos * rotY(iTime * 0.50), 0.7);\n    float d3 = sdDysonSphere(pos * rotY(iTime * 0.25), 0.9);\n    \n    float res = MAX_DIST;\n    res = min(res, d0);\n    res = min(res, d1);\n    res = min(res, d2);\n    res = min(res, d3);\n    return res;\n}\n\nvec3 normals(vec3 pos)\n{\n    vec2 e = vec2(0, 0.01);\n    return normalize(vec3(\n    \tmap(pos+e.yxx)-map(pos-e.yxx),\n        map(pos+e.xyx)-map(pos-e.xyx),\n        map(pos+e.xxy)-map(pos-e.xxy)\n    ));\n}\n\nconst vec4 miss = vec4(MAX_DIST, vec3(0));\nvec4 raymarch(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i = 0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = ro + rd*t;\n        float d = map(pos);\n        \n        if(abs(d)<=EPS) return vec4(length(pos-ro), normals(pos));\n        if(d >= MAX_DIST) return miss;\n        \n        t+=d;\n    }\n         \n    \n    return miss;\n}\n\nconst vec3 BACKGROUND = vec3(0.2);\nvec3 GetScene(vec3 ro, vec3 rd)\n{\n    \n    vec4 a = raymarch(ro, rd);\n    float d = a.x;\n    vec3 nor = a.yzw;\n    \n    vec3 col = BACKGROUND;\n    \n    if(d < MAX_DIST)\n    {\n        vec3 pos = ro+rd*d;\n        \n        float li = dot(normalize(-pos), nor);\n        li = li*0.5+0.5;\n        li = li*0.9+0.1;\n        \n        col = vec3(1, 0.94, 0.8) * li;\n    }\n    \n    return col;\n    \n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    float camAngle = PI/4.; // mouse.x*PI*2.;\n    vec2 p = 3.0 * vec2(cos(camAngle), sin(camAngle));\n    vec3 ro = vec3(p.x,1.5,p.y);\n    mat3 ca = setCamera(ro, vec3(0,0,0), 0.0);\n    vec3 rd = ca*normalize(vec3(uv,1.8));\n    \n    vec3 col = GetScene(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}