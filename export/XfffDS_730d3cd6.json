{"ver":"0.1","info":{"id":"XfffDS","date":"1724252332","viewed":13,"name":"2 Bit Integer Shader","username":"_JZ","description":"simple xor fractal patterns using only integer operations","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["xor","pattern","integer"],"hasliked":0,"parentid":"McXfzs","parentname":"Integer Shader: Xor Pattern"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    //vec2 uv = fragCoord/iResolution.xy;\n    int threshold = 5;\n    int scalingFactor = 2;\n    //convert everything to integers\n    int time = int(iTime * 10.0);\n\n    int x = int(fragCoord.x/4.0); //scale image\n    int y = int(fragCoord.y/4.0);\n    \n    int r = 0;//2+ bit color depth\n    int g = 0; \n    int b = 0;\n    \n    #define shader 4\n    \n    #if shader==1\n        threshold = 5;\n        int tmp_x = x + time;\n        int tmp_y = y + int(2.0*sin(float(x/2))); //could use pingpong instead of sin\n        \n        r = 2*int((tmp_x ^ (tmp_y)) % 7 >threshold) + int((tmp_x+2 ^ (tmp_y+1)) % 7 >threshold);\n    \n        g = 2*int((tmp_x+2 ^ (tmp_y)) % 7 >threshold) + int((tmp_x+2 ^ (tmp_y)) % 7 >threshold);\n    \n        b = 2*int((tmp_x ^ (tmp_y)) % 7 >threshold) + int((tmp_x+2 ^ (tmp_y)) % 7 >threshold);\n    #endif\n    \n    #if shader==2 //blur\n        threshold = 1;\n        int tmp_x = x + time;\n        int tmp_y = y + time + int(2.0*sin(float(x/2)));\n        \n        r = int((tmp_x ^ tmp_y) % 7 >threshold) + int((tmp_x+1 ^ tmp_y+1) % 7 >threshold) + int((tmp_x-1 ^ tmp_y) % 7 >threshold);\n    \n        b = 3*int((tmp_x ^ tmp_y) % 7 >threshold);\n    \n        g = int((tmp_x ^ tmp_y) % 7 >threshold) + int((tmp_x+1 ^ tmp_y) % 7 >threshold) + int((tmp_x-1 ^ tmp_y) % 7 >threshold);\n    #endif\n    \n    #if shader==3\n        threshold = 14-(time/4)%15;\n        int tmp_x = x + time;\n        int tmp_y = y + int(2.0*sin(float(x/4)));\n        \n        r = 3*int(((tmp_x ^ tmp_y) % 7 + (tmp_x ^ tmp_y) % 9) >threshold) //base pattern\n        - max(int( (abs(x*(-threshold) + y - int(iResolution.x)/8 - int(iResolution.y)/8))%16 -13),0); //grey lines\n    \n        g = r;\n    \n        b = r;\n    #endif\n    \n    #if shader==4 //no modulo\n    \n      int tmp_x;\n      int tmp_y;\n      float mirrorScale = 1.0; //set this to 1.0\n      #if 0 //use floatingpoint scaling\n\n        tmp_x = int(abs(fragCoord.x-iResolution.x/2.0)/6.0*iTime/4.0+iTime*iTime*mirrorScale); //zoom out (uses floating point math)\n        tmp_y = int(abs(fragCoord.y-iResolution.y/2.0)/6.0*iTime/4.0+iTime*iTime*mirrorScale + (2.0*sin(float(x/2)+2.0*iTime))); //somewhat works with int only\n      #else\n        tmp_x = abs(int(fragCoord.x)-int(iResolution.x/2.0))/4+int(iTime*mirrorScale); //mirror the pattern by shifting 0/0 to center\n        tmp_y = abs(int(fragCoord.y)-int(iResolution.y/2.0))/4+int(iTime*mirrorScale);\n      #endif\n        tmp_x = (tmp_x)<<scalingFactor;\n        tmp_y = (tmp_y)<<scalingFactor;\n        \n        int basepattern = ((tmp_x ^ tmp_y)%90)/30;\n        \n        r = ((tmp_x-1 ^ tmp_y)%90)/30 + (1 * int(basepattern > 0));\n    \n        g = ((tmp_x+1 ^ tmp_y)%90)/30 + (1 * int(basepattern > 0));\n    \n        b = basepattern + (1 * int(basepattern > 0));\n    #endif\n    \n\n    vec3 col = vec3(float(r)/3.0,float(g)/3.0,float(b)/3.0); //expects values 0.0 to 1.0\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}