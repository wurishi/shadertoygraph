{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// The atmosphere fog effect is a pretty expensive part of the shader since I'm\n// recomputing the effect once per time feature.  I rescale and shift the atmos\n// effect per time feature to provide the illusion of depth.  Decrease the number\n// of ATMOS_DETAIL_ITERATIONS if your gpu is melting, or to get more detail in the\n// atmosphere, increase it to 8.\n//\n\n#define ATMOS_DETAIL_ITERATIONS 4\n\n#define MONTH_WIDTH .05\n#define DAY_WIDTH .025\n#define HOUR_WIDTH .0125\n#define MINUTE_WIDTH .006\n#define SECOND_WIDTH .0015\n#define TICK_WIDTH .1\n\n// ------------------------------------\n// following grabbed and modified from Fire from @301z - https://www.shadertoy.com/view/Xsl3zN\n// hash grabbed from David Hoskins - https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nfloat noise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\n    return mix(mix(hash12(b), \n                   hash12(b + d.yx), f.x), \n               mix(hash12(b + d.xy), \n                   hash12(b + d.yy), f.x), \n               f.y);\n}\n\nfloat fbm(vec2 n) \n{\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < ATMOS_DETAIL_ITERATIONS; i++) \n    {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\nfloat atmos( vec2 p )\n{\n\tfloat q = fbm(p - iTime * 0.1);\n\tvec2 r = vec2(fbm(p + q + iTime * 0.01 - p.x - p.y), fbm(p + q - iTime * 0.04));\n\treturn mix(.1, .4, fbm(p + r)) + mix(.6, .8, r.x) - mix(.0, .4, r.y);\n}\n\n// ------------------------------------\n\nvec3 draw_grid(vec2 uv) \n{\n    float gridLine = fract(60. * uv.x);\n    float mask = smoothstep(0., .1, uv.y) * smoothstep(1., .9, uv.y) ;\n    \n    mask *= smoothstep( .05, .0, abs(gridLine - .5));\n    return mask * 0.05 * vec3(1., 1., 1.);\n}\n\nvec3 draw_bg_and_tick(vec2 uv)\n{ \n    float tickCenter = (1. + 2. * TICK_WIDTH) * fract(iTime * .1) - TICK_WIDTH;\n    float f = abs(uv.x - tickCenter);\n\n    float beamSpread = .1;\n    float lightBeam = smoothstep( TICK_WIDTH + beamSpread, TICK_WIDTH - beamSpread, f);\n            \n    vec3 lightColor = mix(vec3(1., 0., 0.),  vec3(1.4, .4, .3), lightBeam);\n    \n    lightColor *= atmos( 6. * (uv + vec2(50., 50.)) ); // scale and shift fog to fake depth\n\n    return .3 * mix( lightColor, vec3(.1,.1,.1), uv.y);\n}\n\nvec3 draw_second(vec2 uv) \n{\n    float secondCenter = fract(floor(iDate.w) / 60.);\n    float f = abs(uv.x - secondCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), 4. * smoothstep(.001, .0, pow(uv.y, 1.5)));    \n    float beamSpread = .001;    \n    lightBeam *= smoothstep( SECOND_WIDTH + beamSpread, SECOND_WIDTH - beamSpread, f);\n    \n    float lightIntensity = lightBeam * 6.2;\n    lightIntensity += .8 * smoothstep(.1, .0, uv.y) * smoothstep(.05, .0, abs(uv.x - secondCenter)); \n    \n    lightIntensity *= atmos( 5.5 * (uv + vec2(50., 50.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., .12, .1) * lightIntensity;\n}\n\nvec3 draw_minute(vec2 uv) \n{\n    float minuteCenter = fract(iDate.w / 3600.); \n    float f = abs(uv.x - minuteCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.02, .0, pow(uv.y, 1.6)));\n    float beamSpread = .005 + .05 * max(0., pow((.9 - uv.y), 3.));\n    lightBeam *= smoothstep( MINUTE_WIDTH + beamSpread, MINUTE_WIDTH - beamSpread, abs(uv.x - minuteCenter));\n    \n    float lightIntensity = lightBeam;\n    lightIntensity += .8 * smoothstep(.03, .0, uv.y) * smoothstep(.03, .0, abs(uv.x - minuteCenter)); \n    \n    lightIntensity *= atmos( 4.5 * (uv + vec2(40., 40.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., .41, .18) * lightIntensity;\n}\n\nvec3 draw_hour(vec2 uv) \n{\n    float hourCenter = fract(iDate.w / 86400.);  \n    float f = abs(uv.x - hourCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.03, .0, pow(uv.y, 1.5)));    \n    float beamSpread = .008 + .05 * max(0., pow((1. - uv.y), 3.));\n    lightBeam *= smoothstep( HOUR_WIDTH + beamSpread, HOUR_WIDTH - beamSpread, f);\n        \n    float lightIntensity = lightBeam * .8;    \n    lightIntensity += smoothstep(.02, -.01, uv.y) * smoothstep(.05, .0, f);     \n    \n    lightIntensity *= atmos( 4. * (uv + vec2(30., 30.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., .6, .3) * lightIntensity;\n    \n}\n\nvec3 draw_day(vec2 uv) \n{\n    float dayCenter = iDate.z / 31.;\n\tfloat f = abs(uv.x - dayCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.05, .0, pow(uv.y, 1.4)));\n    float beamSpread = .01 + .1 * max(0., pow((1. - uv.y), 3.));\n    lightBeam *= smoothstep( DAY_WIDTH + beamSpread, DAY_WIDTH - beamSpread, f);\n    \n    float lightIntensity = lightBeam * .6;\n    lightIntensity += smoothstep(.02, -.01, uv.y) * smoothstep(.13, .0, f);\n    \n    lightIntensity *= atmos( 3.5 * (uv + vec2(20., 20.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., 0.7, 0.5) * lightIntensity;\n    \n}\n\nvec3 draw_month(vec2 uv) \n{\n    float monthCenter = iDate.y / 12.;\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.15, .0, pow(uv.y, 1.3)));        \n    float f = .03 + .1 * max(0., pow((1.2 - uv.y), 3.));    \n    lightBeam *= smoothstep( MONTH_WIDTH + f, MONTH_WIDTH - f, abs(uv.x - monthCenter));\n    \n    float lightIntensity = lightBeam * .4;\n    lightIntensity += .5 * smoothstep(.012, .0, uv.y) * smoothstep(.18, .0, abs(uv.x - monthCenter)); \n    \n    lightIntensity *= atmos( 3. * (uv + vec2(10., 10.)) ); // scale and shift fog to fake depth\n\n    return vec3(1., 0.8, 0.7) * lightIntensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 scene_color = vec3(0.);\n    scene_color += draw_month(uv);\n    scene_color += draw_day(uv);\n    scene_color += draw_hour(uv);\n    scene_color += draw_minute(uv);\n    scene_color += draw_second(uv);    \n    scene_color += draw_bg_and_tick(uv);\n    scene_color += draw_grid(uv);\n    \n    fragColor.rgb = scene_color;\n    \n    //fragColor.rgb = vec3(atmos(5. * uv));\n}\n                                ","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsBXRw","date":"1410062747","viewed":1094,"name":"Light Clock","username":"mplanck","description":"Testing the iDate variable and came up with this quick sketch.  Thanks to @301z for his sweet fire shader (repurposed here)","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["clock","atmosphere","date"],"hasliked":0,"parentid":"","parentname":""}}