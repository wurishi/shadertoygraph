{"ver":"0.1","info":{"id":"NtVGWy","date":"1638421097","viewed":420,"name":"Oblique Slices","username":"panna_pudi","description":"(ಠ o ಠ)¤=[]:::::>","likes":29,"published":1,"flags":0,"usePreview":0,"tags":["slice","conetracing","cut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Desert Bloom by Pudi\n// Email: k.a.komissar@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// Thanks to Flopine, provod, YX, NuSan, slerpy, wwrighter, Shane,\n// BigWings, FabriceNeyret, iq, and Blackle for sharing their knowledge\n//\n// Inspired by wblut's work.\n//\n// cmarangu/CM2 nails this down with precise control where is the\n// untransformed space and should be rotated/slices. I'm just sneaky\n// avoiding problems with a least amount of artifacts.\n// https://www.shadertoy.com/view/tddGzf\n//\n// Cone tracing and effects took from TekF's shader. Would like to\n// see explanation with graphics and pictures what they are doing v-v\n// https://www.shadertoy.com/view/MsBGWm\n\nconst vec3 EPS = vec3(0., 0.01, 0.0001);\nconst float PI = acos(-1.);\nconst float TAU = 2.0 * PI;\n\n// https://jbaker.graphics/writings/DEC.html\nfloat sd_dodecahedron(vec3 p, float radius) {\n    const float phi = 1.61803398875;\n    const vec3 n = normalize(vec3(phi, 1, 0));\n\n    p = abs(p / radius);\n    float a = dot(p, n.xyz);\n    float b = dot(p, n.zxy);\n    float c = dot(p, n.yzx);\n    return (max(max(a, b), c) - n.x) * radius;\n}\nfloat sd_icosahedron(vec3 p, float radius){\n    const float q = 2.61803398875;\n    const vec3 n1 = normalize(vec3(q, 1, 0));\n    const vec3 n2 = vec3(0.57735026919);\n\n    p = abs(p / radius);\n    float a = dot(p, n1.xyz);\n    float b = dot(p, n1.zxy);\n    float c = dot(p, n1.yzx);\n    float d = dot(p, n2) - n1.x;\n    return max(max(max(a, b), c) - n1.x, d) * radius;\n}\nfloat sd_icosahestar(vec3 p){\n    float radius = 1.5;\n    return min(sd_dodecahedron(p, radius), sd_icosahedron(p.zyx, radius));\n}\n\nconst int NUM_CUTS = 5;\nvec3 CUT_DIR[NUM_CUTS];\nfloat CUT_WIDTH[NUM_CUTS];\nfloat CUT_OFFSET[NUM_CUTS];\n\nvoid setup_cuts() {\n    CUT_DIR[0] = normalize(vec3(0., 1., 0.9));\n    CUT_DIR[1] = normalize(vec3(1., 0., 0.));\n    CUT_DIR[2] = normalize(vec3(0., 0.6, 0.));\n    CUT_DIR[3] = normalize(vec3(-1., 0.5, 0.1));\n    CUT_DIR[4] = normalize(vec3(-1., 1., 0.));\n\n    CUT_WIDTH[0] = 0.3;\n    CUT_WIDTH[1] = 0.2;\n    CUT_WIDTH[2] = 0.4;\n    CUT_WIDTH[3] = 0.2;\n    CUT_WIDTH[4] = 0.6;\n\n    CUT_OFFSET[0] = 0.5;\n    CUT_OFFSET[1] = -0.2;\n    CUT_OFFSET[2] = 0.3;\n    CUT_OFFSET[3] = -0.4;\n    CUT_OFFSET[4] = 0.;\n}\n\nstruct Cut {\n    vec3 off;\n    float d;\n    float sign;\n};\n\nCut op_cut(vec3 p, vec3 n, float w, float width) {\n    float dt = dot(p, n) - w;\n    float dcut = abs(dt) - width;\n    float s = sign(dt);\n    return Cut(width * n * s, dcut, s);\n}\n\nCut merge_cuts(Cut a, Cut b) {\n    // Sign computing is not right as expected,\n    // but I didn't stumble on this problem yet\n    return Cut(a.off + b.off, min(a.d, b.d), a.sign * b.sign);\n}\n\nCut dummy_cut() {\n    return Cut(vec3(0.), 9999., 1.);\n}\n\n// https://suricrasia.online/demoscene/functions/ blackle is a qt >:3c\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax, p) * ax, p, cos(ro)) + cross(ax, p) * sin(ro);\n}\n\nfloat back_out(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (f * f - f * 0.8 * sin(f * PI));\n}\n\nfloat map(vec3 p) {\n    float time = mod(iTime / 14., 1.);\n    float dist = 999.;\n\n    float trig_wave = min(time, 1. - time);\n    float saddle = 4. * trig_wave - 0.5;\n\n    Cut cut = dummy_cut();\n    for (int i = NUM_CUTS - 1; i >= 0; --i) {\n        float harm = saddle * float(NUM_CUTS) - float(i);\n        float delay = 0.4;\n        float release = clamp((harm - delay) / (1. - delay), 0., 1.);\n        release = 0.50 - 0.5 * cos(release);\n        if (release == 0.) continue;\n\n        Cut current_cut =\n            op_cut(p, CUT_DIR[i], CUT_OFFSET[i], CUT_WIDTH[i] * release);\n        cut = merge_cuts(cut, current_cut);\n        // Adjust position in the direction of cut\n        p -= current_cut.off;\n\n        // Rotate space on the last cut\n        int last_cut = NUM_CUTS - 1;\n        if (i == last_cut) {\n            float rot_dir = current_cut.sign;\n            p = erot(p, CUT_DIR[last_cut],\n                     rot_dir * back_out(release) * PI);\n        }\n    }\n\n    dist = sd_icosahestar(p);\n    dist = max(dist, -cut.d);\n\n    return dist;\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 20; i++) {\n        float d = map(ro + t * rd);\n        if (abs(d) < 0.0001 || t > 20.) break;\n        t += d;\n    }\n    return t;\n}\n\nmat3 get_camera(vec3 eye, vec3 at) {\n    vec3 zaxis = normalize(at - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nvec3 get_normal(vec3 p, float r) {\n    mat3 k = mat3(p, p, p) - mat3(r);\n    return normalize(vec3(map(p)) - vec3(map(k[0]), map(k[1]), map(k[2])));\n}\n\nvec3 sky2(vec3 rd) {\n    vec3 col = vec3(0.);\n    col+=smoothstep(0.2,1.5,dot(rd, normalize(vec3(0.,-1.,0.)))) * 0.1*vec3(0.67843,0.67451,0.709);\n    col+=smoothstep(.2,1.0, dot(rd, normalize(vec3(0,1,-3)))) * 0.2 * vec3(0.3647,0.2902,0.63137);\n    col+=smoothstep(-0.4,0.4, dot(rd, normalize(vec3(0.9,0.2,0.6)))) * 0.2 * vec3(0.1,0.4,0.3);\n    col+=smoothstep(-0.4,0.4, dot(rd + vec3(0.0,0.7,0.0), normalize(vec3(0.0,-0.2,0.0)))) *\n           vec3(0.1, 0.0, 0.3) * 0.1;\n    return col;\n}\n\n// Thanks al-ro\nvec3 sky(vec3 rd){\n    return mix(0.12 * vec3(0.75, 0.5, 1.0),\n                0.4 * vec3(0.25, 0.5, 1.0), 0.5 + 0.5 * normalize(rd).y);\n}\n\n//https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n            * vec2(iResolution.x / iResolution.y, 1.);\n    float time = iTime;\n\n    setup_cuts();\n\n    vec3 target = vec3 (0., 0., 0.);\n    float an = TAU * time / 20. + PI;\n    vec3 ro = target + 2.8 * vec3(cos(an), .8, sin(an));\n    mat3 cam = get_camera(ro, target);\n    float zoom = 1.;\n    vec3 rd = cam * vec3(uv, zoom);\n\n    float cone_radius = .7071 / (iResolution.y * zoom);\n\n    float coverage = -1.0;\n    vec3 cover_dir = vec3(0.);\n\n    const float aperture = .025;\n    const float focus = 1.9;\n\n    vec3 col = vec3(0.);\n\n    float t = 0.;\n    for (int i = 0; i < 25; ++i) {\n        float radius = t * cone_radius + aperture * abs(t - focus);\n        vec3 pos = ro + t * rd;\n        float dist = map(pos);\n\n        if (dist < radius) {\n            vec3 normal = get_normal(pos, radius);\n\n            vec3 albedo = vec3(.15);\n            vec3 refl_col = vec3(0.);\n            // if the normal not looking outside of the sphere\n            // so it's inner plane and should be colored\n            if (dot(pos, normal) < 0.5) {\n                albedo = vec3(3.5, 0.0, 0.0);\n                \n                vec3 rd = reflect(rd, normal);\n                float t = trace(ro + normal * 0.02, rd);\n                vec3 nro = ro + rd * t;\n                vec3 new_norm = get_normal(nro, radius);\n                refl_col = vec3(.95, 0., 0.) *\n                           (dot(new_norm, normalize(ro)) * 0.5 + 0.5);\n\n            }\n\n            vec3 ambient =\n                vec3(.1) * smoothstep(.7, 2.0, length(pos.xz) + abs(pos.y));\n            vec3 directional =\n                3.0 * vec3(1, .1, .13) *\n                max(dot(normal, normalize(vec3(-2, -2, -1))), .0);\n            directional *=\n                smoothstep(.5, 1.5, dot(pos, normalize(vec3(1, 1, -1))));\n\n            float f = 1.0 - abs(dot(normal, rd));\n            float fresnel = f*f*f*f*f;\n            fresnel = mix(.03, 1.0, fresnel);\n\n            vec3 reflection = sky(reflect(rd, normal));\n\n            vec3 sample_color = mix(albedo * (ambient + directional),\n                                    reflection, vec3(fresnel));\n            sample_color += refl_col;\n\n            // bottom light\n            {\n                float dif = 0.02 * clamp(0.5 - 0.5 * normal.y, 0., 1.);\n                sample_color += dif;\n            }\n\n            float new_coverage = -dist / radius;\n            vec3 new_coverage_dir = normalize(normal - dot(normal, rd) * rd);\n\n            new_coverage +=\n                (1.0 + coverage) * (.5 - .5 * dot(new_coverage_dir, cover_dir));\n            new_coverage = min(new_coverage, 1.0);\n\n            if (new_coverage > coverage) {\n                col += sample_color * (new_coverage - coverage) * .5;\n\n                cover_dir =\n                    normalize(mix(new_coverage_dir, cover_dir,\n                                  (coverage + 1.0) / (new_coverage + 1.0)));\n                coverage = new_coverage;\n            }\n        }\n        t += max(dist, radius );\n        if (dist < -radius || coverage > 1.0)\n            break;\n    }\n    col += (1.0 - coverage) * .5 * sky(rd);\n    \n    // Tonemapping\n    col = ACESFilm(col);\n    \n    col = clamp(col, 0., 1.);\n    \n    // Gamme correction\n    col = pow(col, vec3(0.4545));\n    \n    // Dithering\n    col += sin(fragCoord.x * 114.0) * sin(fragCoord.y * 163.9) / 256.0;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}