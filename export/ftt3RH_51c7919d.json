{"ver":"0.1","info":{"id":"ftt3RH","date":"1635711280","viewed":223,"name":"[ConcoursJFIG2021] IBL","username":"xavierchermain","description":"Simple image based lighting with varying roughness. The logo is a revisited version of the logo of the Alpes-Maritimes.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["concoursjfig2021"],"hasliked":0,"parentid":"ftd3zn","parentname":"xcTest2"},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, 1]^2\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // [-0.5, 0.5]^2\n    uv -= 0.5;\n    // Correct aspect ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // Incomming radiance\n    vec3 Li = vec3(0.);\n    \n    float cameraAngle = cos(iTime*0.7) * PI / 4. + PI / 2.;\n\n    Ray ray;\n    // Ray origin\n    ray.o = vec3(cos(cameraAngle), 0., sin(cameraAngle));\n    // The camera look at position lookAt\n    vec3 lookAt = vec3(0.);\n    // Zoom of the camera\n    float zoom = 1. + (cos(iTime*0.7)+1.)*0.2;\n    // Forward direction of the camera\n    vec3 camForward = normalize(lookAt - ray.o);\n    // Right direction of the camera\n    vec3 camRight = cross(camForward, vec3(0, 1, 0));\n    // Up direction of the camera\n    vec3 camUp = cross(camRight, camForward);\n    // Center of the screen\n    vec3 screenCenter = ray.o + camForward * zoom;\n    // Intersection point of the screen\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    // Ray direction\n    ray.d = normalize(screenIntersection - ray.o);\n    \n    // Initialize sphere\n    Sphere sphere;\n    sphere.radius = 0.5;\n    sphere.worldToObject = mat4(1.);\n    mat4 scale = createInvScaleTransformation(vec3(0.9, 0.9, 0.1));\n    mat4 rotateX = createInvRotateXTransformation(PI*0.5);\n    sphere.worldToObject = rotateX * scale * sphere.worldToObject;\n    \n    // Trace the ray\n    \n    float tHit;\n    SurfaceInteraction si;\n    if(intersectSphere(sphere, ray, tHit, si)){\n        // Mirrored direction\n        vec3 wi = reflect(-si.wo, si.n);\n        vec2 transformedUV = si.uv * vec2(-2.,1.6) -vec2(-1., 0.28);\n        transformedUV.y = clamp(transformedUV.y, 0., 1.);\n        // Real-time image based lighting use mipmapped environment map\n        // The roughness is the LOD of the environment map\n        // The roughness map is the red channel of buffer a\n        // (the logo of the Alpes-Maritimes department in France)\n        float roughness = texture(iChannel0, transformedUV).r * 6.;\n        // The incomming radiance is approximated by the result of the\n        // mipmap filtering\n        Li = pow(textureLod(iChannel1, wi, roughness).rgb, vec3(2.2));\n        // The albedo of the surface is the logo of the Alpes-Maritimes department in France\n        Li *= texture(iChannel0, transformedUV).rgb;\n    } else {\n        // If no intersection, then hit the environment map\n        Li = pow(texture(iChannel1, ray.d).rgb, vec3(2.2));\n    }\n    \n    // Exposition\n    Li = Li / (Li + vec3(.4));\n    // Gamma correction\n    Li = pow(Li, vec3(0.4545));\n   \n    \n    fragColor = vec4(vec3(Li), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//! Common functions\n\n#define PI 3.141592\n#define TWOPI 6.283185\n\n//! Solve a quadratic equation of the form at^2 + bt + c = 0\n//! If solutions were found, t0 is always smaller or equal to t1\n//! \\return true is solutions were found\nbool solveQuadraticEquation(in float a, in float b, in float c, out float t0, out float t1){\n    // Find quadratic discriminant\n    float discrim = b*b - 4. * a * c;\n    if(discrim < 0.) return false;\n    float rootDiscrim = sqrt(discrim);\n    // Compute quadratic t values\n    float q;\n    if(b < 0.) q = -0.5 * (b - rootDiscrim);\n    else       q = -0.5 * (b + rootDiscrim);\n    t0 = q / a;\n    t1 = c / q;\n    if(t0 > t1){\n        // Swap t0 and t1\n        float tmp = t0;\n        t0 = t1;\n        t1 = tmp;\n    }\n    return true;\n}\n\n\nmat4 createInvTranslationTransformation(vec3 delta){\n    mat4 m = mat4(1.);\n    m[3] = vec4(-delta, 1.);\n    return m;\n}\n\nmat4 createInvScaleTransformation(vec3 s){\n    mat4 m = mat4(1.);\n    m[0][0] = 1./s[0];\n    m[1][1] = 1./s[1];\n    m[2][2] = 1./s[2];\n    return m;\n}\n\nmat4 createInvRotateXTransformation(float theta){\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    mat4 m = mat4(vec4(1., 0.,        0.,       0.),\n                  vec4(0., cosTheta, -sinTheta, 0.),\n                  vec4(0., sinTheta,  cosTheta, 0.),\n                  vec4(0., 0.,        0.      , 1.));\n    return m;\n}\n\n//! Structure of a ray\nstruct Ray{\n    //! Origin of the ray\n    vec3 o;\n    //! Direction of the ray\n    vec3 d;\n};\n\n//! Compute the point at a particular position along a ray\n//! The ray is a function of a single parameter t\nvec3 computePointAlongRay(in Ray r, float t){\n    return r.o + r.d * t;\n}\n\n//! Transform a point p with a transformation t. The function converts\n//! the point to homogeneous coordinates, then transforms the point and convert back\n//! to a nonhomogeneous point representation\n//! \\param p Point with nonhomogeneous representation\n//! \\param t 4x4 transformation matrix\n//! \\return The transformed point with nonhomogeneous representation\nvec3 transformPoint(in vec3 p, in mat4 t){\n    // Homogeneous point representation\n    vec4 homogeneousPoint = vec4(p, 1.);\n    vec4 transformedPoint = t * homogeneousPoint;\n    // We assume homogeneous weight = 1, i.e.,\n    // t[0][3] = t[1][3] = t[2][3] = 0.\n    return transformedPoint.xyz;\n}\n\n//! Transform a vector v with a transformation t. The function converts\n//! the vector to homogeneous coordinates, then transforms the vector and convert back\n//! to a nonhomogeneous vector representation\n//! \\param v Vector with nonhomogeneous representation\n//! \\param t 4x4 transformation matrix\n//! \\return The transformed vector with nonhomogeneous representation\nvec3 transformVector(in vec3 v, in mat4 t){\n    // Homogeneous vector representation\n    vec4 homogeneousVector = vec4(v, 0.);\n    vec4 transformedVector = t * homogeneousVector;\n    return transformedVector.xyz;\n}\n\n//! Transform a normal n with a transformation t.\n//! \\param n Normal\n//! \\param t 4x4 transformation matrix\n//! \\return The transformed normal\nvec3 transformNormal(in vec3 n, in mat4 t){\n    // Homogeneous normal representation\n    vec4 homogeneousNormal = vec4(n, 0.);\n    vec4 transformedNormal = transpose(inverse(t)) * homogeneousNormal;\n    return transformedNormal.xyz;\n}\n\n//! Transform a ray with a transformation\nRay transformRay(in Ray ray, in mat4 t){\n    Ray transformedRay;\n    transformedRay.o = transformPoint(ray.o, t);\n    transformedRay.d = transformVector(ray.d, t);\n    return transformedRay;\n}\n\n//! The SurfaceInteraction abstraction supplies information about\n//! the surface point to allow the shading to be implemented\nstruct SurfaceInteraction{\n    //! The intersection point\n    vec3 p;\n    //! The time associated to the intersection point\n    float time;\n    //! The negative ray direction (observation direction for the first intersection)\n    vec3 wo;\n    //! The surface normal at the point\n    vec3 n;\n    //! The (u,v) coordinates from the parameterization of the surface\n    vec2 uv;\n    //! Partial derivatives of the point\n    vec3 dpdu, dpdv;\n};\n\n//! Structure of a sphere\nstruct Sphere{\n    //! The radius of the sphere\n    float radius;\n    //! The world to object transformation of the sphere\n    mat4 worldToObject;\n};\n\n// Inspiration: pbrt-v3\nbool intersectSphere(in Sphere s, in Ray r, out float tHit, out SurfaceInteraction si){\n    // Initialize tHit\n    tHit = 0.;\n    // Transform ray to object space\n    Ray ray = transformRay(r, s.worldToObject);\n    // Compute quadratic sphere coefficients\n    float a = ray.d.x * ray.d.x + ray.d.y * ray.d.y + ray.d.z * ray.d.z;\n    float b = 2. * (ray.d.x * ray.o.x + ray.d.y * ray.o.y + ray.d.z * ray.o.z);\n    float c = ray.o.x * ray.o.x + ray.o.y * ray.o.y + ray.o.z * ray.o.z - s.radius * s.radius;\n    float t0, t1;\n    if(!solveQuadraticEquation(a, b, c, t0, t1)){\n        return false;\n    }\n    // Check quadric shape t0 and t1 for nearest intersection\n    if(t1 <= 0.)\n        return false;\n    float tShapeHit = t0;\n    if(tShapeHit <= 0.){\n        tShapeHit = t1;\n    }\n    // Compute sphere hit\n    vec3 pHit = computePointAlongRay(ray, tShapeHit);\n    // Refine sphere intersection point\n    pHit *= s.radius / length(pHit);\n    // Compute sphere phi\n    float phi = atan(pHit.y, pHit.x);\n    if(phi < 0.) phi += TWOPI;\n    // Find parametric representation of sphere hit\n    float u = phi / TWOPI;\n    float theta = acos(clamp(pHit.z / s.radius, -1., 1.));\n    float v = theta / PI;\n    // Compute partial derivatives\n    float zRadius = sqrt(pHit.x * pHit.x + pHit.y * pHit.y);\n    float invZRadius = 1. / zRadius;\n    float cosPhi = pHit.x * invZRadius;\n    float sinPhi = pHit.y * invZRadius;\n    vec3 dpdu = vec3(-TWOPI * pHit.y, TWOPI * pHit.x, 0.);\n    vec3 dpdv = PI * vec3(pHit.z * cosPhi, pHit.z * sinPhi, -s.radius * sin(theta));\n    // Initialize surface interaction\n    mat4 objectToWorld = inverse(s.worldToObject);\n    si.p = transformPoint(pHit, objectToWorld);\n    si.time = tShapeHit;\n    si.wo = -r.d;\n    si.n = normalize(transformNormal(normalize(pHit), objectToWorld));\n    si.uv = vec2(u,v);\n    si.dpdu = transformVector(dpdu, objectToWorld);\n    si.dpdv = transformVector(dpdv, objectToWorld);\n    // Update tHit\n    tHit = tShapeHit;\n    return true;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//! Draw the logo of the Alpes-Maritimes department\n\n// Inspiration: https://www.youtube.com/watch?v=LLZPnh_LK8c&t=1950s\nfloat drawTaperBox(vec2 p, float wb, float wt, float yb, float yt, float blur){\n    float m = smoothstep(-blur, blur, p.y - yb);\n    m *= smoothstep(blur, -blur, p.y-yt);\n    p.x = abs(p.x);\n    float w = mix(wb, wt, (p.y - yb) / (yt - yb));\n    m *= smoothstep(blur, -blur, p.x - w);\n    return m;\n}\n\n// Inspiration: https://www.youtube.com/watch?v=LLZPnh_LK8c&t=1950s\nfloat drawTree(vec2 uv, float blur){\n    float m = drawTaperBox(uv, .03, .03, .0, .25, blur); // trunk\n    m += drawTaperBox(uv, .2, .1, .25, .5, blur); // canopy 1\n    m += drawTaperBox(uv, .15, .05, .5, .75, blur); // canopy 2\n    m += drawTaperBox(uv, .1, .0, .74, 1., blur); // top\n    return m;\n}\n\n// Inspiration: https://www.shadertoy.com/view/XssSRX\nfloat drawPalmTree(vec2 uv){\n    uv = mat2(5., 0., 1., 3.) * uv - vec2(2.5, 0.2);\n    vec2 p = uv;\n\tvec2 q = p - vec2(0.33,0.7);\n\t\t\n\tvec3 col = mix( vec3(1.0,0.3,0.0), vec3(1.0,0.8,0.3), sqrt(p.y) );\n\t\n\tfloat r = 0.2 + 0.1*cos( atan(q.y,q.x)*10.0 + 20.0*q.x + 1.0);\n\tcol *= smoothstep( r, r+0.01, length( q ) );\n\n\tr = 0.015;\n\tr += 0.002*sin(120.0*q.y);\n\tr += exp(-40.0*p.y);\n    col *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x-0.25*sin(2.0*q.y))))*(1.0-smoothstep(0.0,0.1,q.y));\n    if(uv.y < 0.1)\n        col = vec3(1.);\n    if(col.r < 0.5)\n        col = vec3(0.);\n    else\n        col = vec3(1.);\n    \n    return 1. - col.r;\n}\n\nfloat drawCircle(vec2 uv, vec2 p, float r, float blur){\n    uv = uv - p;\n    float d = length(uv);\n    float c = smoothstep(r-blur, r, d);\n    return 1. - c;\n}\n\nfloat drawBand(float t, float start, float end, float blur){\n    float step1 = smoothstep(start-blur, start+blur,t);\n    float step2 = smoothstep(end-blur, end+blur,t);\n    step2 = 1. - step2;\n    return step1 * step2;\n}\n\nfloat drawRect(vec2 uv, float left, float right, float bottom, float top, float blur){\n    float band1 = drawBand(uv.x, left, right, blur);\n    float band2 = drawBand(uv.y, bottom, top, blur);\n    return band1 * band2;\n}\n\nfloat drawFlower(in vec2 uv){\n    uv = mat2(2.5, 0., 0., 2.5) * uv - vec2(-0.7, 0.);\n    float a = atan(uv.y, uv.x);\n    float r = length(uv);\n    float ir= 1.0 - r;\n    \n    ir += 0.1 * sin(a * 5.0 + r * 50.0 * 0.3);\n    float c = smoothstep(0.8, 0.85, ir);\n    \n    c += (1.0 - smoothstep(0.01, 0.03, abs(uv.x + 0.1 * sin(uv.y * 9.0)))) \n        * (1.0 - smoothstep(0.01, 0.03, uv.y));\n    if(uv.y < -0.35)\n        c = 0.;\n    if(c < 0.5)\n        c = 0.;\n    else\n        c = 1.;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 mask = vec3(1.);\n    mask -= drawCircle(uv, vec2(0.,0.), 0.5, 0.01) * (1. - vec3(0.58, 0.57, 0.39));\n    mask -= drawCircle(uv, vec2(0.,0.), 0.47, 0.01) \n        * (vec3(0.58, 0.57, 0.39) - vec3(0.77, 0.21, 0.18));\n    mask -= drawCircle(uv, vec2(0.25,0.), 0.24, 1e-10);\n    mask -= drawCircle(uv, vec2(-0.25,0.), 0.24, 1e-10);\n    mask -= drawCircle(uv, vec2(0.,0.25), 0.24, 1e-10);\n    mask -= drawCircle(uv, vec2(0.,-0.25), 0.24, 1e-10);\n    mask = clamp(mask, 0., 1.);\n    if(mask.r < 0.1)\n        mask = vec3(0.58, 0.57, 0.39);\n    mask -= drawCircle(uv, vec2(0.25,0.), 0.18, 1e-10);\n    mask -= drawCircle(uv, vec2(-0.25,0.), 0.18, 1e-10);\n    mask -= drawCircle(uv, vec2(0.,0.25), 0.18, 1e-10);\n    mask -= drawCircle(uv, vec2(0.,-0.25), 0.18, 1e-10);\n    mask -= drawCircle(uv, vec2(0.,0.), 0.19, 1e-10);\n    mask = clamp(mask, 0., 1.);\n    if(mask.r < 0.1)\n        mask = vec3(0.14, 0.25, 0.54);\n        \n    // Cross\n    mask -= drawRect(uv, 0.22, 0.22+0.06, -0.13, 0.13, 1e-10);\n    mask -= drawRect(uv, 0.128, 0.128 + 0.24, -0.03, 0.03, 1e-10);\n    \n    // Tree\n    mask -= drawTree(uv*vec2(2.,3.)+vec2(0., -0.2), 1e-10);\n    // Palm tree\n    mask -= drawPalmTree(fragCoord.xy / iResolution.xy);\n    \n    // Flower\n    mask -= drawFlower(uv);\n    if(mask.r < 0.1)\n        mask = vec3(0.58, 0.57, 0.39);\n    \n    vec3 col = mask;\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}