{"ver":"0.1","info":{"id":"wl3BRM","date":"1655251026","viewed":84,"name":"Octree Point Render","username":"JohnShadow","description":"Octree Point Render","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["octreepointrender"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi2 6.28\nint points[8] = int[8](82640, 810, 735435, 0, 0, 0, 0, 0);\nvec3 cube[8] =\nvec3[8](\nvec3(0, 0, 0),\nvec3(-1, 0, 0),\nvec3(0, -1, 0),\nvec3(-1, -1, 0),\nvec3(0, 0, -1),\nvec3(-1, 0, -1),\nvec3(0, -1, -1),\nvec3(-1, -1, -1)\n);\nfloat renderPoint(vec2 uv, vec3 point)\n{   \n    vec2 pt = point.xy/(-point.z * 0.5);\n    float signage = -floor(sign(abs(uv.y) - 0.5) + sign(abs(uv.x) - 0.5));\n    vec2 subbed = (uv - pt.xy) * point.z * 10.0;\n    return signage * floor(dot(subbed, subbed));\n}\nvec3 rotate(vec3 point, vec4 qrot)\n{   \n    return point + 2.0 * cross(qrot.xyz, cross(qrot.xyz, point) + qrot.w * point);\n}\nfloat renderBoundingCube(vec2 uv, vec3 positon, vec4 rotation)\n{\n\tfloat outcol = 1.0;\n    for(int i = 0; i < 8; ++i)\n        outcol = min(outcol, renderPoint(uv, rotate(cube[i], rotation) + positon));\n    return 1.0 - outcol;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y;\n    // Time varying pixel color\n    float signage = -floor(sign(abs(uv.y) - 0.5) + sign(abs(uv.x) - 0.5));\n\n    float outcol = 1.0;\n    float bestVal = 1.0;\n    vec4 qrot = normalize(vec4(cos(iTime), sin(iTime), 1.0, 1.0));\n    vec4 offset = vec4(sin(iTime), cos(iTime), 10, 0);\n    vec4 wallet = vec4(0, 0, 0, 0);\n    \n    //gradient regression\n    int amount = int(mod(iTime, 20.0));\n    for(int i = 0; i < amount; ++i)\n    {\n        for(int j = 1; j < 8; ++j)\n            points[0] += points[0] - points[j];\n    }\n\n    // foreach point\n    for(int j = 0; j < 8; ++j)\n    {\n        vec4 wallet = vec4(0, 0, 0, 0);\n        for(int i = 0; i < 10; ++i)\n        {\n            int sindex = i * 3;\n            float oneover = 1.0 / pow(2.0, float(i) + 1.0);\n            wallet.x += float((points[j]>>sindex) & 1) * oneover;\n            wallet.y += float((points[j]>>(sindex + 1)) & 1) * oneover;\n            wallet.z += float((points[j]>>(sindex + 2)) & 1) * oneover;\n        }\n        wallet -= offset;\n        float renderedPoint = renderPoint(uv, wallet.xyz);\n        if(renderedPoint < bestVal)\n        {\n            bestVal = renderedPoint;\n            outcol = 0.0;\n        }\n    }\n    float bounds = renderBoundingCube(uv, offset.xyz, vec4(0, 0, 0, 0));\n    vec3 col = vec3(outcol - bounds, outcol - bounds, max(outcol, bounds));\n    // Output to screen\n    fragColor = vec4(col * signage,1.0);\n}","name":"Image","description":"","type":"image"}]}