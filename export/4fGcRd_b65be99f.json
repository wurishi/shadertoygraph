{"ver":"0.1","info":{"id":"4fGcRd","date":"1732217877","viewed":112,"name":"glowing hexstar 2","username":"aladin","description":"one of my older shaders... just an glowing experiment with raymarching...","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","glow","glowing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// just use the mouse with this\n\n// options\n#define centralSun      \t1\n#define numOuterSuns        24.\n#define spEED               ( 1./4. )\n#define glow\t\t\t\t( 1./160. )\n#define move\t\t\t\t1\n#define col             \tvec3( 5., 3., 26. )\n#define rotationSpeed\t\t( 1./1. )\n#define AA                  1.\n\n// stuff 1\nconst float tau = atan( 1. )*8.; // 6.28318530718..\nconst float sqrt3 = sqrt( 3. );\n#define time ( iTime*spEED )\n#define A O.a\n#define C O.rgb\n#define res iResolution.xy\n#define rot( a ) mat2( cos( a*tau ), -sin( a*tau ), sin( a*tau ), cos( a*tau ) )\n\n// global stuff\nvec2 p, m = vec2( 0. );\nvec3 c = vec3( 0. );\n\n// 3d geometry\nfloat sdTetrahedron( vec3 p ) { return ( max( abs( p.x + p.y ) - p.z, abs( p.x - p.y ) + p.z ) - 1. )/( sqrt3 ); }  // sqrt3 = 1.73205.. = sqrt( 3. )are ue8f 57\n\nfloat nSpheres( vec3 p, float r, float num )  // by ändrom3da\n\t{ float theta = atan( p.x, p.y ) + tau/2.;\n\tfloat nt = num/tau; float pn  = ( floor( theta*nt ) + .5 )/nt;\n\tvec3 circleCenter = vec3( -sin( pn ), -cos( pn ), 0. )*r;\n\tfloat circleRadius = r*sin( .5/nt );\n\t#define thetaaa 10. // fix\n\treturn distance( p, circleCenter ) - circleRadius*( sin( thetaaa + 1. )*.333 + .9 )*0.66; }\n\n\nfloat map( vec3 p )\n\t{ p -= float( move )*9.*vec3( sin( time ), 0., cos( time ) );\n\tif ( iMouse == vec4( 0. ) ) p.xy -= vec2( 20., 10. );\n    p.xy -= m*24.;\n\tp.yz *= rot( time*tau*rotationSpeed/43. );\n\tp.xz *= rot( cos( 3.*time*rotationSpeed/5. ) );\n\tp.xy *= rot( time*tau/4. );\n\tfloat d = nSpheres( p, 18., numOuterSuns );\t\n\tp.xy *= rot( -time*tau*rotationSpeed/43. );\n\tp.xz *= rot( cos( -3.*time*rotationSpeed/15. ) );\n\tp.yz *= rot( -6.*time*tau/43. );\n\t#if ( centralSun == 1 ) // the hexstar in the middle\n\tfloat tetra1 = sdTetrahedron( p/1.5 );\n\tp.xy *= rot ( .25 );\n\tfloat tetra2 = sdTetrahedron( p/1.5 );\n\tfloat tetra = min( tetra1, tetra2 );\n\td = min( tetra, d );\n\t#endif\n\treturn d; }\n\nvec3 Image0( vec2 p )\n\t{ vec3 o = vec3( 0. );\n\tvec3 camPos = vec3( 0., 0., -21.5 );\n\tvec3 rayDir = normalize( vec3( p, 1. ) );\n\tfloat depth = 0.;\n\tfor ( int i = 0; i < 64; i++ )\n\t\t{ vec3 rayPos = camPos + rayDir * depth;\n\t\tfloat dist = map( rayPos );\n\t\to += vec3( glow )/( dist );\n\t\tif ( dist < 0.01 ) { o = vec3( 4. ); break; }\n\t\tdepth += dist; }\n    o *= col/1.67; // twist\n\to = 1. - exp2( -o ); // some tonemapping\n    //o = tanh( o ); // another tonemapping formula\n\treturn o; }\n\n// main\n\nvoid mainImage( out vec4 O, in vec2 POS )\n    { A = 1.; m = iMouse.xy;\n    m = ( m.xy - res/2. )/res.y;\n\t// nested AA loop \n    for ( float kk = 0.; kk < AA; kk++ ) for ( float kkk = 0.; kkk < AA; kkk++ )\n    \t\t{ vec2 k = ( vec2( kk, kkk ) - .5 )/vec2( AA );\n\t\tp = ( POS.xy - k - res/2. )/res.y;  \n\t\tc += Image0( p ); } // acc the color    \n\tc /= AA*AA;\n\tO = vec4( c, 1. ); } //ändrom3da\n","name":"Image","description":"","type":"image"}]}