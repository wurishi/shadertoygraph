{"ver":"0.1","info":{"id":"lXKXDw","date":"1720208801","viewed":158,"name":"the_vortex_gambit","username":"numpyhard","description":"Circles wiggling on a chessboard.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["vortex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MOD3 vec3(.1031,.11369,.13787)\n#define PI 3.141592654\n#define gridscale 4.\n#define aberration 0.08\n#define smoothness 0.1\n#define vortexes 100.\n#define vortexWidth 0.2\n#define swirliness .7\n\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat perlin_noise(vec3 p){\n    vec3 pi = floor(p);\n    vec3 pf = p - pi;\n    vec3 w = pf * pf * (3.0 - 2.0 * pf);\n    return \tmix(mix(mix(dot(pf - vec3(0, 0, 0), hash33(pi + vec3(0, 0, 0))), \n                        dot(pf - vec3(1, 0, 0), hash33(pi + vec3(1, 0, 0))),w.x),\n                \tmix(dot(pf - vec3(0, 0, 1), hash33(pi + vec3(0, 0, 1))), \n                        dot(pf - vec3(1, 0, 1), hash33(pi + vec3(1, 0, 1))),w.x),w.z),\n        \t\tmix(mix(dot(pf - vec3(0, 1, 0), hash33(pi + vec3(0, 1, 0))), \n                        dot(pf - vec3(1, 1, 0), hash33(pi + vec3(1, 1, 0))),w.x),\n                   \tmix(dot(pf - vec3(0, 1, 1), hash33(pi + vec3(0, 1, 1))), \n                        dot(pf - vec3(1, 1, 1), hash33(pi + vec3(1, 1, 1))),w.x),w.z),w.y);\n}\n\n\nfloat monoboard(vec2 p){\n    float t = mod(floor(gridscale*p.x)+floor(gridscale*p.y),2.0);\n    return clamp(t, 0.2, 0.9);\n\n}\n\nvec3 checkerboard(vec2 p){\n    float r = monoboard(p+vec2(aberration,0.));\n    float g = monoboard(p);\n    float b = monoboard(p+vec2(-aberration,0.));\n    \n    return vec3(r,g,b);\n}\nfloat smoothSquareWave(float x, float eps){\n    return sin(x*PI)/sqrt(pow(sin(x*PI),2.)+eps);\n}\n\nvec3 checkerboard2(vec2 p){\n    p = p*gridscale;\n    float t = mod(floor(p.x)+floor(p.y),2.);\n\n    float r1 = smoothSquareWave(t+p.y+aberration, smoothness);\n    float g1 = smoothSquareWave(t+p.y, smoothness);\n    float b1 = smoothSquareWave(t+p.y-aberration, smoothness);\n\n    float r2 = smoothSquareWave(t+p.x+aberration, smoothness);\n    float g2 = smoothSquareWave(t+p.x, smoothness);\n    float b2 = smoothSquareWave(t+p.x-aberration, smoothness);\n\n    float r = abs(r1-r2);\n    float g = abs(g1-g2);\n    float b = abs(b1-b2);\n    \n    return vec3(r,g,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 chessv = uv;\n    \n    vec2 vort, dir;\n    float rad, z,d,angle;\n    \n    for(float i=0.; i<vortexes; i++){\n        vort.x = 1.7*perlin_noise(vec3(-i*5.3, .2*iTime+i, 0.))*sin(.2*iTime);\n        vort.y = 1.*perlin_noise(vec3(i*2.7+.8, .2*iTime+1.+i, 3.))*cos(.2*iTime);\n        rad = (.5+.5*sin(.3*iTime))*2.*(.5+perlin_noise(vec3(i*10., .2*iTime+1., 3.)));\n        d = length(uv-vort);\n        z = smoothstep(vortexWidth,0.,abs(d-rad));\n        \n        angle = mod(.2*i, swirliness*2.*PI);\n        dir = vec2(sin(angle),cos(angle));\n        uv += .08*z*dir;\n        \n    }\n\n    vec3 col = checkerboard2(uv);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}