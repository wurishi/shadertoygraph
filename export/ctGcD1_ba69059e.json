{"ver":"0.1","info":{"id":"ctGcD1","date":"1700198569","viewed":26,"name":"Simple Matrix Interpolation","username":"ArthMax","description":"Sequence of the N simple (linear) interpolations between consecutive matrices: M0\n --> M1 --> M2 --> ... --> M0 --> ...\nArea of the central circle is proportional to determinant of current interpolated matrix M","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n        const int N = 4;                          \n           // 0 and N frame  -- initial and finished frame\n          const mat3 M0 = mat3(\n                           1.,    0. ,    0., // \n                           0.,    1. ,    0., // \n                          //------------\n                            0.,   0.,     1.0   // \n                        );\n\n              // 1 frame             \n          const mat3 M1 = mat3(\n                           0.,    -2. ,   -1.,  // \n                           1.,    0. ,    0.5,  // \n                          //------------\n                           0.0,  1.0 ,   1.0   // \n                          );         \n              // 2 frame                                       \n           const mat3 M2 = mat3(\n                           -2.,    2. ,    -1., // \n                           0.,     2. ,    -0.7, // \n                          //------------\n                           0.,     0. ,   1.0 // \n                          );                     \n              //last frame            \n           const mat3 M3 = mat3(\n                           -1.5,    0. ,    1., // \n                           0.,    -1.5 ,    0., // \n                          //------------\n                            0.,   0.,     1.0   // \n                          );\n                                                                                \n\n            const mat3 F[N]= mat3 [](M0, M1, M2, M3 );    // Array Of Matrices (Frames) \n\n\n           \n           \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n//control size by mouse \n vec2 m = iMouse.xy/iResolution.xy *20.0;\n  float size = max(1.0,m.x); ;\n    // set size \n    vec2 uv =2.0*size*fragCoord/iResolution.xy; // <0, size>\n          uv -= size; // <-size, size>\n     // fix aspect ratio          \n    float aspect = iResolution.x/iResolution.y;      \n           uv.x *= aspect; \n            // make homogenious vector p from uv\n            vec3  p = vec3(uv,1.0);               \n           \n           \n // times and indexes\n float t = mod(iTime / 10.0, float(N));   // t in [0, N)\n float  t_ = mod(t, 1.0);            // t_ in [0, 1) from t \n float   _t = 1.0-t_;                // _t in (1, 0] from t_ \n int    i = int(t);                  //  i in {0, 1, .. N-1}\n int     i_ = i + 1; if(i_>=N)i_=0;   //   i_ = ( i + 1) mod N\n           \n                    //M is interpolated matrix between F[i] and F[i+1] by simple linear interpolation          \n                    mat3 M = F[i]*_t + F[i_]*t_; \n                     float d = determinant(M);\n\n                      //compile colors of all figures\n                      vec3 b = vec3(0., 0., 0.);//vec3(0.1,.1, 0.4); // background\n                      const vec3 green = vec3(0., 1., 0.);\n                      vec2 center = vec2(0., 0.);\n                      vec3 c = (1. - coloredCircle(p, d/16., center, green ))/2. ;//value of determinant(M) as circle size and color \n                       for(int k=0; k<N; k++)\n                           c = max(c, drawHeart(p*inverse(F[k]),b)); // add images of key frames (matrices)                \n                           \n                        c = max(c,drawScene(p*inverse(M))); // add image of variable matrix M \n                        \n                   //add determinant d decimal value   \n                     vec2 vFontSize = iResolution.yx/32.0; // vec2(8.0, 12.0);\n                     vec2  in_place_for_determinant = (fragCoord -  iResolution.xy/2.) / vFontSize +vec2(4.5,2.5);\n                     const vec3 magenta = vec3(1.0, 0.0, 1.0);        \n                          c =  mix( c, magenta, DecimalForm(in_place_for_determinant, d, 3.0, 2.0));\n                   //add time decimal value   \n                    vec2  in_place_for_time = fragCoord / vFontSize;\n                          c =  mix( c, green, DecimalForm(in_place_for_time, t, 2.0, 2.0));\n\n                        \n                           fragColor = vec4(c,1.0); // Output to screen\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Visit my tutorial to learn how this works: https://inspirnathan.com/posts/50-shadertoy-tutorial-part-4\n        vec3 getBackgroundColor(vec2 uv) {\n            uv += 0.5 ;// remap uv from <-0.5,0.5> to <0.,1.>\n            vec3 gradientStartColor = vec3(0., 0., 0.5);\n            vec3 gradientEndColor = vec3(0., 1., 1.);\n            vec3 gradientEnd2Color = vec3(95, 0.5, 0.5);\n             vec3 colorMix1 = mix(gradientStartColor, gradientEndColor, uv.y);\n            //  vec3 colorMix3 = mix(colorMix1,gradientEnd2Color, uv.x);\n            float f=2.0; \n                   colorMix1 *=(1.+(sin(f*8.*uv.x)+cos(f*4.*uv.x))/64.);\n                    return colorMix1; // gradient mix\n        }\n        \n        float sdSquare(vec2 p, float size, vec2 offset) {\n            float x = p.x - offset.x;\n            float y = p.y - offset.y;\n        \n             return max(abs(x), abs(y)) - size;\n        }\n        \n        float sdCircle(vec2 p, float r, vec2 offset) {\n            float x = p.x - offset.x;\n            float y = p.y - offset.y;\n            \n             return length(vec2(x, y)) - r;\n        }\n        \n        vec3 coloredCircle(vec3 p, float r, vec2 offset, vec3 endColor) {\n            vec2 uv = p.xy;\n            float r_ = sqrt(abs(r));\n             float circle = -sdCircle(uv, r_, offset); \n            vec3 startColor = vec3(1.); \n            //if(r<0.)endColor = 1. - endColor;  \n             vec3 resultColor = mix(startColor, endColor, step(0., circle));\n            \n             return resultColor;\n        }\n        \n        float sdHeart (vec2 p, float size, vec2 offset) { // Credit: https://mathworld.wolfram.com/HeartCurve.html\n            float x = p.x - offset.x;\n            float y = p.y - offset.y;\n            float  xx = x * x;\n            float  yy = y * y;\n            float   yyy = yy * y;\n            float    group = xx + yy - size;\n            \n             return group * group * group - xx * yyy;\n        }\n        \n        float sdStar5 (vec2 p, float r, float rf, vec2 offset) // Credit: https://iquilezles.org/articles/distfunctions2d\n        {\n            p -= offset;\n            const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n            const vec2 k2 = vec2(-k1.x,k1.y);\n             p.x = abs(p.x);\n              p -= 2.0*max(dot(k1,p),0.0)*k1;\n               p -= 2.0*max(dot(k2,p),0.0)*k2;\n                p.x = abs(p.x);\n                p.y -= r;\n              vec2 ba = rf*vec2(-k1.y,k1.x) - vec2(0,1);\n               float h = clamp( dot(p,ba)/dot(ba,ba), 0.0, r );\n        \n                return length(p-ba*h) * sign(p.y*ba.x-p.x*ba.y);\n        }\n        \n        \n    vec3 drawHeart(vec3 p, vec3 background) {\n         vec2 uv = p.xy;\n         \n        float heart  = sdHeart (uv, 0.01,       vec2(0., 0.));\n        float square = sdSquare(uv, 0.025,        vec2(-0.1, 0.15));\n        float circle = sdCircle(uv, 0.05,        vec2(-0., 0.));\n        float star   = sdStar5 (uv, 0.05, 0.32, vec2(0.1, 0.15));\n        \n        \n        vec3 heartColor  = vec3(0.8, 0, 0.6);\n        vec3 squareColor = vec3(0, 1, 0);\n        vec3 circleColor = vec3(0.5, 1, 0);\n        vec3 starColor   = vec3(0, 0, 1);\n       // vec3 heartColor  = vec3(1., 0.5, 0.);\n       // vec3 squareColor = vec3(0.5, 0, 0.);\n       // vec3 circleColor = vec3(0.75, 0., 0.);\n       // vec3 starColor   = vec3(0.75, 0, 1);\n        \n         vec3 resultColor = background; vec3(.25, .25, .25);\n         resultColor = mix(heartColor,  resultColor, step(0.0000001, heart));\n          resultColor = mix(squareColor, resultColor, step(0., square));\n           resultColor = mix(circleColor, resultColor, step(0., circle));\n            resultColor = mix(starColor,   resultColor, step(0., star));\n        \n              return resultColor;\n    }    \n\n    vec3 drawScene(vec3 p) {\n         vec2 uv = p.xy;\n         \n        float heart  = sdHeart (uv, 0.01,       vec2(0., 0.));\n        float square = sdSquare(uv, 0.025,        vec2(-0.1, 0.15));\n        float circle = sdCircle(uv, 0.05,        vec2(-0., 0.));\n        float star   = sdStar5 (uv, 0.05, 0.32, vec2(0.1, 0.15));\n        \n        \n        vec3 heartColor  = vec3(0.85, 0, 0.);\n        vec3 squareColor = vec3(0, 1, 0);\n        vec3 circleColor = vec3(0.5, 1, 0);\n        vec3 starColor   = vec3(0, 0, 1);\n        \n         vec3 resultColor = getBackgroundColor(uv);\n         resultColor = mix(heartColor,  resultColor, step(0.0000001, heart));\n          resultColor = mix(squareColor, resultColor, step(0., square));\n           resultColor = mix(circleColor, resultColor, step(0., circle));\n            resultColor = mix(starColor,   resultColor, step(0., star));\n        \n              return resultColor;\n    }\n    \n    \n    const float Bin[10]= float[] (480599.,\n                                  139810.,\n                                  476951.,\n                                  476999.,\n                                  350020.,\n                                  464711.,\n                                  464727.,\n                                  476228.,\n                                  481111.,\n                                  481095.\n                                 );\n\nfloat DecimalForm( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\t      fValue = abs(fValue);\n    \n\tfloat  fLog10Value = log2(fValue) / log2(10.0);\n\tfloat   fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\t       if(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\t      if(fDigitIndex > fBiggestIndex) {\n\t\t\t     if((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t      }\n              else {\t\t\n\t\t\t        if(fDigitIndex == -1.0) {\n\t\t\t\t       if(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t        }\n                    else {\n                          float fReducedRangeValue = fValue;\n                                 if(fDigitIndex < 0.0) {\n                                    fReducedRangeValue = fract( fValue ); \n                                    fDigitIndex += 1.0; \n                                 }\n\t\t\t\t                  float fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                                   fCharBin = /*Digit*/Bin[int(floor(mod(fDigitValue, 10.0)))];\n\t\t\t             }\n                   }\n\t      }\n           return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n\n","name":"Common","description":"","type":"common"}]}