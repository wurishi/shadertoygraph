{"ver":"0.1","info":{"id":"XsKBWd","date":"1531095130","viewed":175,"name":"Islamic motif trial","username":"saidwho12","description":"test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["2d","test","pattern","motif","islamic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\tTried to implement this algorithm: https://pdfs.semanticscholar.org/2924/e3afe0a0c07bd1f02fbe1089dcb8b4516212.pdf \n *\tI failed miserably...\n *\tIt is just not a very good solution for this case.\n */\n\nfloat udLine(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = -p - a, ba = b - a;\n    float h = clamp(dot(pa,ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nmat2 rotate(in float theta) {\n\tfloat c = cos(theta), s = sin(theta);\n    return mat2(c, -s, s, c);\n}\n\nstruct ray {\n\tvec2 o, d;\n};\n    \nconst float PI = 3.14159;\nconst float TAU = 6.28318;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    float x = 1.5;\n    p = fract(p*x-0.5*vec2(0,0.0*floor(p.x*x)))*2.0-1.0;\n    \n    const int N = 4;\n    \n    vec3 col = vec3(0);\n    float res = 1.0;\n    \n    float theta = 0.5*PI*(iMouse.x/iResolution.x);\n    theta = radians(67.0);\n    float delta = 0.05;\n    \n    float c=0.,v;\n#define  min(r,v) ( v < r ? c=float(i+1), v : r)\n\n    for(int i = 0; i < N; i++) {\n    \tfloat a = TAU*float(i+1)/float(N);\n        float b = 0.5*PI-theta;\n        vec2 d = vec2(sin(a), cos(a)),\n        d0 = rotate(b)*-d,\n        d1 = rotate(-b)*-d;\n        \n        res = min(res, udLine(p, d, d+d0*100.0));\n        res = min(res, udLine(p, d, d+d1*100.0));\n    }\n    fragColor =   smoothstep(x*12.0/iResolution.y, 0.0, res)\n                * mod(c/vec4(1,2,3,1),2.);\n}","name":"Image","description":"","type":"image"}]}