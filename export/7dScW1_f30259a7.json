{"ver":"0.1","info":{"id":"7dScW1","date":"1656951671","viewed":299,"name":"The Old Pathtracer Except Better","username":"trigophers","description":"Hold space to clear samples, and mouse to look around.","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["ray","global","illumination"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I finally got depth of field and refraction working!\n// mouse for camera control (hold space to clear samples)\n\n// parabolic vignette to make things look very very pretty\nfloat vignette(float x, float intensity) {\n    intensity = 1.-intensity;\n    return (4.-4.*intensity)*(x-x*x)+intensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col = texture(iChannel0, vec2(uv));\n    vec3 dispc = col.xyz/col.w;\n    \n    fragColor = vec4(pow(vignette(uv.x, 0.25)*vignette(uv.y, 0.25)*dispc, vec3(.4545)), 1.0); // gamma correction\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//render distance (mostly doesn't affect performance)\n#define maxDist 100000. \n//samples per pixel per frame\n#define SPF 16\n#define pi 3.14159265359\n//scene\n#define scenen 0\n\n// maybe I'll get rid of global variables in the future\nvec3 center;\nvec3 ray;\nfloat rdist;\nvec3 normal;\nvec3 color;\nint material;\nfloat ior;\nbool inside;\n\n// visual studios rand()\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void) { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// hash to initialize the random seed (copied from Hugo Elias)\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\n// http://amietia.com/lambertnotangent.html\nvec3 cosineDirection( in vec3 nor)\n{\n    float u = frand()*2.0-1.0;\n    float a = frand()*2.0*pi;\n    return normalize(nor+vec3(sqrt(1.0-u*u)*vec2(cos(a),sin(a)), u) );\n}\n\n// pick random point within circle of specified radius\nvec2 randCircle(float rad) {\n    float d = frand()*2.0*pi;\n    float m = sqrt(frand())*rad;\n    return m*vec2(cos(d), sin(d));\n}\n\n// euler rotation system pretty much grabbed off of stack overflow\nvec3 rotate(vec3 inpoint, float pitch, float roll, float yaw) {\n    // create rotation matrix\n    \n    float cosa = cos(yaw);\n    float sina = sin(yaw);\n\n    float cosb = cos(pitch);\n    float sinb = sin(pitch);\n\n    float cosc = cos(roll);\n    float sinc = sin(roll);\n    \n    vec3 Ax = vec3(cosa*cosb, cosa*sinb*sinc - sina*cosc, cosa*sinb*cosc + sina*sinc);\n    vec3 Ay = vec3(sina*cosb, sina*sinb*sinc + cosa*cosc, sina*sinb*cosc - cosa*sinc);\n    vec3 Az = vec3(-sinb, cosb*sinc, cosb*cosc);\n\n    // rotate\n    return vec3(dot(Ax, inpoint),\n                dot(Ay, inpoint),\n                dot(Az, inpoint));\n}\n\n// schlick's approx (for dielectric materials)\nfloat calcFresnel(float n0, float n1) {\n    float r = (n0-n1)/(n0+n1);\n    r = r*r;\n    float a = dot(ray, normal);\n    return r+(1.-r)*pow((1.+a), 5.);\n}\n\n// simple gradient for a sky texture:\n// light grayish blue to deeper blue,\n// doesn't continute below horizon\nvec3 sky(float y) {\n    y = min(max(y, 0.0), 1.0);\n    return vec3(mix(0.66015625, 0.21953125, y), \n                mix(0.75390625, 0.475,      y), \n                mix(0.75390625, 0.72265625, y));\n}\n\n// prettier sky:\n// tries to mimic nishita sky model\n// at around 45 degree sun angle.\n// continues below horizon\nvec3 sky2(float y) {\n    y = (y + 1.0) / 2.0;\n    vec3 oc = vec3(0);\n    if (y < 0.32 && y >= 0.0) {\n        y = y / 0.32;\n        oc.x = mix(32.0/255.0, 126.0/255.0, y);\n        oc.y = mix(22.0/255.0, 126.0/255.0, y);\n        oc.z = mix(15.0/255.0, 103.0/255.0, y);\n    } else if (y < 0.5) {\n        y = (y - 0.32) / 0.18;\n        oc.x = mix(126.0/255.0, 255.0/255.0, y);\n        oc.y = mix(126.0/255.0, 218.0/255.0, y);\n        oc.z = mix(103.0/255.0, 173.0/255.0, y);\n    } else if (y < 0.57) {\n        y = (y - 0.5) / 0.07;\n        oc.x = mix(255.0/255.0, 238.0/255.0, y);\n        oc.y = mix(218.0/255.0, 250.0/255.0, y);\n        oc.z = mix(173.0/255.0, 255.0/255.0, y);\n    } else {\n        y = (y - 0.57) / 0.43;\n        oc.x = mix(238.0/255.0, 148.0/255.0, y);\n        oc.y = mix(250.0/255.0, 184.0/255.0, y);\n        oc.z = mix(255.0/255.0, 209.0/255.0, y);\n    }\n    return oc;\n}\n\n// if a color channel is maxed out\n// it starts bleeding into other color channels\n// (like real life cameras)\nvec3 filmBleed(vec3 inc, float bleedThreshold, float bleedAmount) {\n    vec3 addon = max(inc - vec3(bleedThreshold), vec3(0))*vec3(bleedAmount);\n    return inc + vec3(addon.y+addon.z, addon.x+addon.z, addon.x+addon.y);\n}\n\n// sphere of size ra centered at point ce\n// from the inigo quilez page on ray/object intersections\n// needs to be more concise\nvoid iSphere(vec3 ce, float ra, vec3 sColor, int m) {\n    vec3 temp1 = center - ce;\n    float temp0x = dot( temp1, ray );\n    float temp0y = dot( temp1, temp1 ) - ra*ra;\n    float temp0z = temp0x*temp0x - temp0y;\n    if(temp0z >= 0.0) {\n        temp0z = sqrt(temp0z);\n        bool hit = false;\n        float d;\n        if (dot(temp1, temp1) < ra*ra) {\n            d = -temp0x+temp0z;\n            if (d < rdist && d > 0.0) \n                hit = inside = true;\n        } else {\n            d = -temp0x-temp0z;\n            if (d < rdist && d > 0.0) {\n                hit = true; inside = false;\n            }\n        }\n        if (hit) {\n            rdist = d;\n            vec3 intersect = center+ray*rdist;\n            normal = normalize(intersect-ce);\n            if (inside) normal *= -1.0;\n        \n            color = sColor;\n            material = m;\n            \n            // glass\n            if (m == 2) {\n                float f = calcFresnel(inside?1.333:1.0, inside?1.0:1.333);\n                if (frand() < f) {\n                    material = 3;\n                    color = vec3(1);\n                }\n            } else if (m == 4) { // glossy\n                material = 0;\n                float f = calcFresnel(1.0, 1.15);\n                if (frand() < f) {\n                    material = 3;\n                    color = vec3(1);\n                }\n            }\n        }\n    } \n}\n\n// scene to be rendered\nvoid scene() {\n    if (scenen == 0) {\n        iSphere(vec3(-5.14*3.0, 5.14, 10.0), 5.0, vec3(0.99, 0.99, 0.99), 3); // only specular\n        iSphere(vec3(-5.14, 5.14, 20.0), 5.0, 1.5*vec3(200, 100, 50), 1); // light source\n        iSphere(vec3(5.14, 5.14, 5.0), 5.0, vec3(0.99, 0.99, 0.99), 2); // glass (ior 1.333)\n        iSphere(vec3(5.14*3.0, 5.14, 25.0), 5.0, vec3(0.99, 0.99, 0.99), 4); // glossy\n\n        // ground\n        iSphere(vec3(0, -1000000, 30), 1000000.0, vec3(0.7, 0.7, 0.7), 4);\n\n        // light\n        iSphere(vec3(-10, 50, 20), 25.0, 2.0*vec3(200, 200, 175), 1);\n    } else {\n        iSphere(vec3(-12.0, 3.05, -49.18), 8.0, vec3(0.9, 0.25, 0.25), 4);\n        iSphere(vec3(-1.67, -0.55, -66.5802), 4.277, vec3(0.99, 0.99, 0.99), 2);\n        iSphere(vec3(-9.75, -2.2, -77.38), 2.649, 400.0*vec3(1.0, 0.4, 0.1), 1);\n        iSphere(vec3(18.58, 8.6, -94.41), 13.451, vec3(0.5, 0.2, 0.1), 0);\n        iSphere(vec3(3.88, -1.1, -94.41), 3.725, vec3(0.99, 0.99, 0.99), 3);\n        iSphere(vec3(0.68, 3.2, -105.3), 8.0, vec3(0.99, 0.99, 0.99), 2);\n        iSphere(vec3(-22.32, 0.5, -172.6), 5.357, vec3(0.3, 0.8, 0.4), 4);\n        \n        iSphere(vec3(0, -1000005, 30), 1000000.0, vec3(0.9, 0.9, 0.9), 0);\n    }\n}\n\n// trace the scene\nvec3 raytrace(vec2 uv, float DoF, float aperture) {\n    uv += vec2(frand(), frand())/iResolution.yy;\n    \n    vec3 s = vec3(1.0/256.0);\n    \n    // depth of field\n    vec2 coff = randCircle(aperture);\n    //vec2 coff = vec2(0);\n    center = vec3(0.0+coff.x, 4.0+coff.y, -30.0);\n    vec2 m;\n    if (iMouse.xy == vec2(0)) {\n        m = vec2(0);\n    } else {\n        m = vec2((iMouse.x-iResolution.x/2.0)/-iResolution.y, (iMouse.y-iResolution.y/2.0)/iResolution.y);\n    }\n    if (scenen == 0) {\n        ray = rotate(normalize(vec3(uv, 2)), -coff.x/DoF+m.x, coff.y/DoF+m.y, 0.0);\n    } else {\n        ray = rotate(normalize(vec3(uv, 2)), coff.x/DoF+m.x+pi, coff.y/DoF+m.y, 0.0);\n    }\n    \n    // light bounces\n    for (int i=0; i<8; i++) {\n        rdist = maxDist;\n        scene();\n        if (rdist<maxDist) {\n            s *= color;\n            if (material == 2) {\n                center += rdist*ray-normal/10.0;\n            } else {\n                center += rdist*ray+normal/10.0; \n            }\n            if (material == 0) {\n                ray = cosineDirection(normal);\n            } else if (material == 1) {\n                break;\n            } else if (material == 2) {\n                float eta = 1.0/1.333;\n                if (inside) {eta = 1.333;}\n                ray = normalize(refract(ray, normal, eta));\n            } else if (material == 3) {\n                ray = normalize(reflect(ray, normal));\n            }\n        } else {\n            if (scenen == 0) {\n                s = vec3(0); // black sky (light only comes from light sources)\n            } else {\n                s *= 256.0*sky2(ray.y);\n            }\n            break;\n        }\n    } \n    \n    return filmBleed(s, 1.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    vec3 col = vec3(0);\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 px = (fragCoord-iResolution.xy/2.0)/iResolution.y;\n    \n    // do SPF samples per pixel per frame\n    for (int i = 0; i < SPF; i++) {\n        if (scenen == 0) {\n            col += raytrace(px, 42.87, 2.0);\n        } else {\n            col += raytrace(px, 64.727989, 2.0);\n        }\n    }\n    \n    vec4 data = texture(iChannel0, uv);\n    if (texelFetch(iChannel1,ivec2(32,0),0).x==1.0 || iMouse.z > 0.0) data = vec4(0.0);\n    data += vec4(col/float(SPF), 1.0); // accumulate\n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"}]}