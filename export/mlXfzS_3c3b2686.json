{"ver":"0.1","info":{"id":"mlXfzS","date":"1693170069","viewed":63,"name":"Domain repetition patterns","username":"nikita_gaidukov","description":"Repetition experiments inspired by https://iquilezles.org/articles/sdfrepetition/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["sdf","repetition","transition","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// --------- Helpers  --------- \n\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat easeInOutCubic(float x) {\n    return x < .5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat line(float lineWidth, float linePosition, float point) {\n    return step(lineWidth,abs(linePosition - point));\n}\n\n\n// --------- SDFs  --------- \nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdRoundedCross( in vec2 p, in float h, float rotation)\n{\n    // Rotate\n    p = rotate2d(rotation) * p;\n\n    float k = 0.5*(h+1.0/h);\n    \n    p = abs(p);\n    return ( p.x<1.0 && p.y<p.x*(k-h)+h ) ? \n             k-sqrt(dot2(p-vec2(1,k)))  :  // circular arc\n           sqrt(min(dot2(p-vec2(0,h)),     // top corner\n                    dot2(p-vec2(1,0))));   // right corner\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdRoundedBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\n\nfloat sdCross( in vec2 p, in vec2 b, float r, float rotation ) \n{\n    // Rotate\n    p = rotate2d(rotation) * p;\n\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n// --------- Repeition --------- \nfloat repeatedCircles(vec2 p, float radius)\n{\n    float s = 2.0;\n    vec2 id = round(p/s);\n    vec2  o = sign(p-s*id); \n    \n    float d = 1e20;\n    for( int j=0; j<2; j++ )\n    for( int i=0; i<2; i++ )\n    {\n        vec2 rid = id + vec2(i,j)*o;\n        vec2 r = p - s*rid;\n        \n        d = min( d, sdCircle(r, radius) );\n    }\n    return d;\n}\n\nfloat repeatedCircleCross(vec2 p, float height, float rotation)\n{\n    float s = 2.0;\n    vec2 id = round(p/s);\n    vec2  o = sign(p-s*id); \n    \n    float d = 1e20;\n    for( int j=0; j<2; j++ )\n    for( int i=0; i<2; i++ )\n    {\n        vec2 rid = id + vec2(i,j)*o;\n        vec2 r = p - s*rid;\n        d = min( d, sdRoundedCross(r, height, rotation) );\n    }\n    return d;\n}\n\nfloat repeatedBox(vec2 p, vec2 size, vec4 radius)\n{\n    float s = 2.0;\n    vec2 id = round(p/s);\n    vec2  o = sign(p-s*id); \n    \n    float d = 1e20;\n    for( int j=0; j<2; j++ )\n    for( int i=0; i<2; i++ )\n    {\n        vec2 rid = id + vec2(i,j)*o;\n        vec2 r = p - s*rid;\n        d = min( d, sdRoundedBox(r, size, radius) );\n    }\n    return d;\n}\n\n\nfloat repeatedCross(vec2 p, vec2 size, float rotation)\n{\n    float s = 2.0;\n    vec2 id = round(p/s);\n    vec2  o = sign(p-s*id); \n    \n    float d = 1e20;\n    for( int j=0; j<2; j++ )\n    for( int i=0; i<2; i++ )\n    {\n        vec2 rid = id + vec2(i,j)*o;\n        vec2 r = p - s*rid;\n        d = min( d, sdCross(r, size, 0.0, rotation) );\n    }\n    return d;\n}\n\n// --------- Main --------- \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = fragCoord/iResolution.xy;\n\n    uv -= 0.5;\n    uv.x *= iResolution.x/ iResolution.y;\n    uv += 0.5;\n  \n    // Move the whole canvas to the left \n    uv.x += 0.1 * iTime;\n    \n    // Keyframe animation\n    float animationDuration = 8.0;\n    float animationProgress = mod(iTime, animationDuration) / animationDuration; // convert to 0...1\n    float keyFrames = 5.0;\n    float localProgress = fract(animationProgress * keyFrames);\n    float keyFrameIndex = floor(animationProgress * keyFrames);\n  \n    float dist = 0.0;\n    \n    // Easing/ convert to local key frame progress\n    localProgress = easeInOutCubic(localProgress);\n    \n    vec3 inside = vec3(1.0);\n    vec3 outside = vec3(0.0);\n    float borderTresh = 0.02;\n    // Circles\n    if (keyFrameIndex == 0.0) {\n        dist = repeatedCircles(uv * 9.0, localProgress);\n    } \n    \n    // Circle Cross\n    if (keyFrameIndex == 1.0) {\n\n       float rot = 1.57 * localProgress;\n       dist = repeatedCircleCross((uv - 1.0) * 9.0, 1.0, rot);\n       \n       inside = vec3(0.0);\n       outside = vec3(1.0);\n    }\n    \n    // Boxes\n    if (keyFrameIndex == 2.0) {\n        float radius = 1.0 - localProgress;\n        float size = (1.0 - localProgress) * 0.5 + 0.5;\n\n        dist = repeatedBox(uv * 9.0, vec2(size), vec4(radius));\n    }\n    \n    // Crosses\n    if (keyFrameIndex == 3.0) {\n        float sizeX = (localProgress) * 0.51 + 0.5;\n        float rot = 1.57 * localProgress;\n        dist = repeatedCross(uv * 9.0, vec2(sizeX, 0.5), rot);\n        //borderTresh = 0.01;\n    }\n    \n    // Boxes\n    if (keyFrameIndex == 4.0) {\n        float size = (localProgress) * 0.51 + 0.5;\n\n        dist = repeatedBox((uv - 1.0) * 9.0, vec2(size), vec4(0.0));\n        inside = vec3(0.0);\n        outside = vec3(1.0);\n    }\n\n    float isInside = smoothstep(-borderTresh, borderTresh, dist);\n    vec3 color = mix(outside, inside, isInside);\n\n    // Colored wave\n    float wave = line(0.15, 0.5 + sin(pos.x * 3.0 + iTime) * 0.1, pos.y);\n    fragColor = vec4(wave);\n    \n    if (wave == 0.0) {\n        vec3 c1 = vec3(0.910,0.094,0.284);\n        vec3 c2 = vec3(0.082,0.911,0.718);\n        color = mix(c1, c2, color.r);\n    }\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}