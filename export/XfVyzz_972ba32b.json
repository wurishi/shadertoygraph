{"ver":"0.1","info":{"id":"XfVyzz","date":"1731421648","viewed":93,"name":"AI mandelbulb","username":"redcassis","description":"This is a mandelbulb generated by chatgpt o1-preview","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal","ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Enhanced Mandelbulb Fractal Shader\n\n// Distance estimator for the Mandelbulb fractal\nfloat mandelbulb(vec3 p)\n{\n    vec3 z = p;\n    float dr = 1.0;\n    float r = 0.0;\n    const float Power = 8.0;\n    const int Iterations = 10;\n\n    for(int i = 0; i < Iterations ; i++)\n    {\n        r = length(z);\n        if(r > 4.0)\n            break;\n\n        // Convert to polar coordinates\n        float theta = acos(z.z / r);\n        float phi = atan(z.y, z.x);\n        dr =  pow(r, Power - 1.0) * Power * dr + 1.0;\n\n        // Scale and rotate the point\n        float zr = pow(r, Power);\n        theta = theta * Power;\n        phi = phi * Power;\n\n        // Convert back to cartesian coordinates\n        z = zr * vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n        z += p;\n    }\n\n    return 0.5 * log(r) * r / dr;\n}\n\n// Normal calculation using numerical gradient\nvec3 calcNormal(vec3 p)\n{\n    const float eps = 0.001;\n    vec3 grad;\n    grad.x = mandelbulb(p + vec3(eps, 0.0, 0.0)) - mandelbulb(p - vec3(eps, 0.0, 0.0));\n    grad.y = mandelbulb(p + vec3(0.0, eps, 0.0)) - mandelbulb(p - vec3(0.0, eps, 0.0));\n    grad.z = mandelbulb(p + vec3(0.0, 0.0, eps)) - mandelbulb(p - vec3(0.0, 0.0, eps));\n    return normalize(grad);\n}\n\n// Ambient occlusion calculation\nfloat calcAO(vec3 p, vec3 n)\n{\n    float ao = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++)\n    {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aop = n * hr + p;\n        float dd = mandelbulb(aop);\n        ao += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - ao, 0.0, 1.0);\n}\n\n// Soft shadow calculation\nfloat softShadow(vec3 ro, vec3 rd)\n{\n    float res = 1.0;\n    float t = 0.02;\n    for(int i = 0; i < 30; i++)\n    {\n        float h = mandelbulb(ro + rd * t);\n        if(h < 0.001)\n            return 0.0;\n        res = min(res, 16.0 * h / t);\n        t += h;\n        if(t > 8.0)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Camera setup\n    float time = iTime * 0.2;\n    vec3 ro = vec3(0.0, 0.0, -4.0 + sin(time) * 2.0); // Ray origin\n    vec3 rd = normalize(vec3(uv, 1.5));              // Ray direction\n\n    // Rotate camera\n    float angle = time;\n    mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    ro.xz = ro.xz * rot;\n    rd.xz = rd.xz * rot;\n\n    // Ray marching parameters\n    float totalDistance = 0.0;\n    const float maxDistance = 20.0;\n    const float minDistance = 0.001;\n    const int maxSteps = 100;\n\n    int steps;\n    bool hit = false;\n    for(steps = 0; steps < maxSteps; steps++)\n    {\n        vec3 p = ro + rd * totalDistance;\n        float distance = mandelbulb(p);\n        if(distance < minDistance)\n        {\n            hit = true;\n            break;\n        }\n        totalDistance += distance;\n        if(totalDistance > maxDistance)\n            break;\n    }\n\n    if(hit)\n    {\n        // Compute position and normal\n        vec3 p = ro + rd * totalDistance;\n        vec3 n = calcNormal(p);\n\n        // Lighting\n        vec3 lightPos = vec3(5.0 * sin(iTime), 5.0, 5.0 * cos(iTime));\n        vec3 lightDir = normalize(lightPos - p);\n        float diff = clamp(dot(n, lightDir), 0.0, 1.0);\n\n        // Soft shadows\n        float shadow = softShadow(p + n * minDistance * 2.0, lightDir);\n\n        // Ambient occlusion\n        float ao = calcAO(p, n);\n\n        // Color based on position\n        vec3 baseColor = 0.5 + 0.5 * cos(p * 0.5 + vec3(0.0, 2.0, 4.0));\n\n        // Combine lighting effects\n        vec3 color = baseColor * diff * shadow * ao;\n\n        // Add ambient light\n        color += 0.05 * baseColor * ao;\n\n        fragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        // Background gradient\n        float t = 0.5 * (rd.y + 1.0);\n        vec3 bgColor = mix(vec3(0.1, 0.2, 0.3), vec3(0.8, 0.9, 1.0), t);\n        fragColor = vec4(bgColor, 1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}