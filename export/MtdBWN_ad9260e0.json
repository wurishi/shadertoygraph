{"ver":"0.1","info":{"id":"MtdBWN","date":"1539887335","viewed":260,"name":"Spiral Graph","username":"AntoineC","description":"Sine spiral with amplitude modulation. Better in full screen!","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["2d","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define Pi     3.14159265359\n#define Tau    6.28318530718\n#define Rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define RadiusIncrease 0.08\n\n\n\nfloat TriangleSd(vec2 uv, float radius)\n{\n\treturn max(0.866025*abs(uv.x) + 0.5*uv.y, -uv.y) - 0.5*radius;\n}\n\nfloat Triangle(vec2 uv)\n{\n    uv = Rot(-0.3*iTime) * uv;\n    return smoothstep(0.782, 1.0, 1.0-TriangleSd(uv, 0.5 + 0.1*cos(iTime)));\n}\n\nfloat SpiralTurn(vec2 uv, float turn)\n{\n    // Polar coordinates:\n    float r = length(uv);\n    float a = Pi+atan(uv.y, uv.x);\n    \n    // Turn angle:\n    a += Tau*turn;\n    \n    // Polar function:\n    float tr = Triangle(uv);\n    float am = 0.35*tr*smoothstep(0.0, 0.1, r);\n    float p = RadiusIncrease*(a/Tau + am*sin(-4.0*iTime+0.54*a*a));\n    \n    return r-p;\n}\n\n\nfloat SpiralTurnDe(vec2 uv, float turn)\n{\n    // IQ's |f|/|Grad(f)| distance estimator:\n    float f = SpiralTurn(uv, turn);\n    vec2 eps = vec2(0.00005, 0);\n    vec2 grad = vec2(\n        SpiralTurn(uv + eps.xy, turn) - SpiralTurn(uv - eps.xy, turn),\n        SpiralTurn(uv + eps.yx, turn) - SpiralTurn(uv - eps.yx, turn)) / (2.0*eps.x);\n    \n    return f/length(grad);\n}\n\n\nfloat Spiral(vec2 uv, float eps)\n{\n    // Modulation source:\n    float tr = Triangle(uv);\n\n    // Split in concentric rings:\n    float r = length(uv);\n    float turn = floor(r/RadiusIncrease);\n    \n    // Draw a spiral contained in a ring + adjacent ones to handle overlap:\n    float thick = 0.0040*tr;\n    float aa = 1.2*eps;\n    float d;\n    d  = smoothstep(thick, thick+aa, abs(SpiralTurnDe(uv, turn)));\n    d *= smoothstep(thick, thick+aa, abs(SpiralTurnDe(uv, turn+1.0)));\n    d *= smoothstep(thick, thick+aa, abs(SpiralTurnDe(uv, turn-1.0)));\n    return d;\n}\n\n\n// Randomly dither colors for smoother gradients\nvoid Dither(inout vec4 fragColor, in vec2 fragCoord)\n{\n    // Position + Time Hash (based on Dave Hoskins hash33):\n    vec3 p3 = fract(vec3(fragCoord, iFrame) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+19.19);\n    vec3 hash = fract((p3.xxy + p3.yxx)*p3.zyx);\n    \n    // RGB Dithering:\n    float softness = 255.0; // Should be 255. Lower value for grainy/fuzzy effect.\n    fragColor.rgb = (floor(softness*fragColor.rgb) + step(hash, fract(softness*fragColor.rgb)))/softness;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized coordinates:\n    float eps = 2.0/iResolution.y;\n    vec2  uv =  eps*(fragCoord - 0.5*iResolution.xy);\n    uv.x = -uv.x;\n    \n    //uv *= Rot(-0.15*iTime);\n    \n    // Polar:\n    float r = length(uv);\n    //float a = atan(uv.y, uv.x);\n\n    \n    // Back:\n    vec3 back = vec3(0.20, 0.25, 0.3);\n    // - Add vignetting:\n    back *= mix(0.237, 1.0, pow(smoothstep(2.0, 2.0*0.45, r), 4.0*0.1637));\n\n        \n    // Disk:\n    vec3 disk = vec3(0.904, 0.902, 0.827);\n    \n    // - Add Grid:\n    float grid = mod(floor(r/RadiusIncrease), 2.0);\n    disk = mix(disk, vec3(0.836,0.848,0.840), grid);\n    \n    // - Add inner shadow:\n    disk *= mix(0.023, 1.0, pow(smoothstep(0.9, 0.75, r), 0.4));\n    \n    // - Add spiral:\n    disk = mix(0.2*disk, disk, pow(Spiral(uv, eps), 0.45));\n\n    \n    // Combine Back and Disk:\n    float mask = smoothstep(0.9+eps, 0.9, r);\n    vec3 col = mix(back, disk, mask);\n\n    \n    // Output:\n    fragColor = vec4(col,1.0);\n    \n    \n    // Dither post-process:\n    Dither(fragColor, fragCoord);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}