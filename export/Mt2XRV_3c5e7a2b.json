{"ver":"0.1","info":{"id":"Mt2XRV","date":"1445151368","viewed":157,"name":"[CIS565 2015F] Bridge_ish","username":"momeg","description":"https://github.com/megmo21/Project5-GLSL-Ray-Marcher\nhttps://github.com/megmo21/Project5-GLSL-Ray-Marc\nAcknoledgments: (also at top of script) \nNumerical Methods for Ray Tracing Implicitly Defined Surfaces (2014). PDF\nIÃ±igo QuÃ­lez. Terrain Raymarchi\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cis565"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"//https://iquilezles.org/articles/menger - mendel sponge\n//https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_shading_model - blinn-phong lighting\n//http://graphics.cs.williams.edu/courses/cs371/f14/reading/implicit.pdf - ray marching/sphere tracing\n//http://www2.compute.dtu.dk/pubdb/views/edoc_download.php/6392/pdf/imm6392.pdf - ambient occlusion/soft shadows\n//https://www.shadertoy.com/view/4t2SRz - smoke color\n//https://www.shadertoy.com/view/MdXGW2 - water\n//https://www.shadertoy.com/view/MdX3zr - smoke movement\n//--Distance Functions-------------------------------------------------------------------\n\nfloat time;\nfloat newPos = 0.0;\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\n#define BUMPFACTOR 0.1\n#define EPSILON 0.1\n#define BUMPDISTANCE 60.\n\n#define SPHERE_TRACE 1\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn (length(spr.xyz-p) - spr.w);\n}\n\nfloat planeDist( vec3 p )\n{\n    /*if (p.y < ((sin(p.x) - sin(p.z)) / 4.0)) return (sin(p.x) - sin(p.z)) / 4.0;\n     else return 100.0;\n     return 100.0;*/\n    return p.y;\n    \n}\n\nfloat ellipsoidDist( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat cylinderDist( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sphereDist(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat flame(vec3 p)\n{\n\tfloat d = sphere(p*vec3(6.,-1.0,5.), vec4(.0,-.9,.0,1.0));\n\treturn d + (noise(p+vec3(.0,iTime*6.0,.0)) + noise(p*6.)*.5)*.25*(p.y) ;\n}\n\nfloat boxDist( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat torusDist( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat roundBoxDist( vec3 p, vec3 b, float r )\n{\n    return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat capsoleDist( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat crossDist( in vec3 p )\n{\n    float da = boxDist(p.xyz,vec3(100000,1.0,1.0));\n    float db = boxDist(p.yzx,vec3(1.0,100000,1.0));\n    float dc = boxDist(p.zxy,vec3(1.0,1.0,100000));\n    return min(da,min(db,dc));\n}\n\n//--CSG Functions----------------------------------------------------------------------\n\nfloat diffFunc(float d1, float d2) {\n    return max(d1, -d2);\n}\n\nfloat intersectionFunc(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat repeat( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    vec4 height = texture(iChannel0, p.xz);\n    //float avg = clamp((height.x + height.y + height.z + height.w) / 4.0, 0.0, 2.0);\n    return capsoleDist(q - vec3(-1.0, -1.0, -2.0), vec3(1.0,-4.0,1.0), vec3(1.0,1.0,1.0), 0.75);\n}\n\n/*vec3 transform( vec3 p, mat4 m )\n{\n    //vec3 q = invert(m)*p;\n    return box(p);\n}*/\n\nfloat displace( vec3 p )\n{\n    float d1 = capsoleDist(p, vec3(-6.3,-4.0,-8.1), vec3(2.8,-0.50,-3.), 5.0);\n    float d2 = (sin(20.0*p.z)*sin(20.0*p.y)*sin(20.0*p.x)*sin(iTime)) / (16.0*p.y);\n    return d1+d2;\n}\n\nfloat bend( vec3 p )\n{\n    float c = cos(20.0*p.y);\n    float s = sin(20.0*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 newp = m*p.xz;\n    vec3  q = vec3(newp.x, p.y, newp.y);\n    return boxDist(q, vec3(1.0));\n}\n\nvec2 myMin(vec2 d1, vec2 d2) {\n    \n    return (d1.x<d2.x) ? d1 : d2;\n}\n\n//--Scenes------------------------------------------------------------------------\n\nvec2 scene(vec3 ro, vec3 rd, float t) {\n    vec3 pt = ro + rd*t;\n    newPos = (-sin(mod(iTime/8.0, radians(90.0))))*10.0 + 5.;\n    vec2 obj;\n    vec4 color1 = texture (iChannel0, pt.xz/256.0);\n    float avg = (color1.x + color1.y + color1.z) / 3.0;\n    avg -= 2.0;\n    float tmin = boxDist(pt - vec3(0.0, -2.75, 1.0), vec3(6.0, 3.0, .2));\n    obj = myMin(vec2(tmin, 1.0), vec2(roundBoxDist(pt - vec3(0.0 + newPos, 0.475, 1.0), vec3(0.3, 0.15, .125), .05), 2.0));\n    obj = myMin(obj, vec2(cylinderDist(pt - vec3(-0.2 + newPos, 0.775, 1.0), vec2(0.05, 0.25)), 2.0));\n    obj = myMin(obj, vec2(roundBoxDist(pt - vec3(0.7 + newPos, 0.475, 1.0), vec3(0.3, 0.15, .125), .05), 2.0));\n    obj = myMin(obj, vec2(roundBoxDist(pt - vec3(1.4 + newPos, 0.475, 1.0), vec3(0.3, 0.15, .125), .05), 2.0));\n    obj = myMin(obj, vec2(flame(pt - vec3(-0.2 + newPos, 0.775, 1.0)), 3.0));\n    obj = myMin(obj, vec2(boxDist(pt - vec3(0.0, 0.265, 1.15), vec3(6.0, .01, .01)), 1.0));\n    obj = myMin(obj, vec2(boxDist(pt - vec3(0.0, 0.265, 0.85), vec3(6.0, .01, .01)), 1.0));\n    obj = vec2(diffFunc(obj.x, repeat(pt - vec3(0.0, -0.85, 2.0), vec3(1.75, 0.0, 0.0))), obj.y); //diffFunc(tmin, repeat(pt, vec3(1.0, 0.0, 1.0)));\n    //obj = myMin(obj, vec2(planeDist(pt - vec3(0.0, -2.0, 0.0)), 5.0));\n    //obj = myMin(obj, vec2(planeDist(pt - vec3(0.0, -2.0, 0.0)), 4.0));\n    return obj;\n}\n\nvec2 sceneHeight(vec3 ro, vec3 rd, float t) {\n    vec3 pt = ro + rd*t;\n    vec4 color1 = texture (iChannel0, pt.xz/256.0);\n    float avg = (color1.x + color1.y + color1.z) / 3.0;\n    \n    float tmin = pt.y - (avg+(pt.z/iResolution.y)*64.);\n    return vec2(tmin, 4.0);\n}\n\n//--Ray Marching------------------------------------------------------------------\n\nvec3 calcNorm( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n                    scene(pos+eps.xyy, vec3(0.0), 0.0).x - scene(pos-eps.xyy, vec3(0.0), 0.0).x,\n                    scene(pos+eps.yxy, vec3(0.0), 0.0).x - scene(pos-eps.yxy, vec3(0.0), 0.0).x,\n                    scene(pos+eps.yyx, vec3(0.0), 0.0).x - scene(pos-eps.yyx, vec3(0.0), 0.0).x );\n    return normalize(nor);\n}\n\nvec3 findRoot(vec3 ro, vec3 rd) {\n    float dist = 100.0;\n    float i = 0.0;\n    float numObj = 0.0;\n    for (float t = 0.0; t < 5.0; t += .005) {\n        i++;\n        vec2 obj = scene(ro, rd, t);\n        if (obj.x < 0.0) {\n            dist = t;\n            numObj = obj.y;\n            break;\n        }\n    }\n    \n    return vec3(dist, i, numObj);\n    \n}\n\nvec3 sphereTrace(vec3 ro, vec3 rd, float t) {\n    //float t = 0.0;\n    float dt;\n    vec2 objs;\n    float numTraces = 0.0;\n    float numObj = 0.0;\n    for (int i = 0; i < 50; i++) {\n        numTraces++;\n        objs = scene(ro, rd, t);\n        dt = objs.x;\n        numObj = objs.y;\n        t = t + dt;\n        if (dt < 0.0001) {\n            break;\n        }\n    }\n    return vec3(t, numTraces, numObj);\n}\n\nvec3 getColor(vec3 pt, vec3 norm, float t) {\n \tvec4 color = texture (iChannel2, pt.xz);\n    if (pt.y > 10.0) {\n    \tcolor *= pt.y;\n    }\n    \n    // snow\n    /*float h = smoothstep(55.0,80.0,pt.y/SC + 25.0*fbm(0.01*pt.xz/SC) );\n    float e = smoothstep(1.0-0.5*h,1.0-0.1*h,norm.y);\n    float o = 0.3 + 0.7*smoothstep(0.0,0.1,norm.x+h*h);\n    float s = h*e*o;\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), smoothstep( 0.1, 0.9, s ) );*/\n\treturn vec3(color);\n    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    float shadow = 1.0;\n    float t = tmin;\n    float d = 0.0;\n\n    for( int i=0; i<16; i++ )\n    {\n        d = scene(ro, rd, t).x;\n        if (d < 0.0001) return 0.0;\n        shadow = min( shadow, 8.0*d/t );\n        t += d;\n        if( d<0.0001 || t > tmax) break;\n    }\n    return clamp(shadow, 0.0, 1.0);\n    \n}\n\nfloat ambientOcc( in vec3 pt, in vec3 norm )\n{\n    float occ = 0.0;\n    float d = 0.0;\n    for(float k=1.0; k<10.0; k++ )\n    {\n        d = scene(pt, norm, .01*k).x;\n        occ = (1.0 / pow(2.0, k)) * (k*.01 - d);\n    }\n    return clamp(1.0 - 3000.0*occ, 0.0, 1.0);\n}\n\nfloat random(float x) {\n \n    return fract(sin(x) * 10000.);\n    \n}\n\nfloat noise2(vec2 p) {\n    \n \treturn random(p.x + p.y * 10000.);\n    \n}\n\nvec2 sw(vec2 p) { return vec2(floor(p.x), floor(p.y)); }\nvec2 se(vec2 p) { return vec2(ceil(p.x), floor(p.y)); }\nvec2 nw(vec2 p) { return vec2(floor(p.x), ceil(p.y)); }\nvec2 ne(vec2 p) { return vec2(ceil(p.x), ceil(p.y)); }\nfloat smoothNoise(vec2 p) {\n \n    vec2 interp = smoothstep(0., 1., fract(p));\n    float s = mix(noise2(sw(p)), noise2(se(p)), interp.x);\n    float n = mix(noise2(nw(p)), noise2(ne(p)), interp.x);\n    return mix(s, n, interp.y);\n    \n}\n\n\nfloat noise3( const in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\n\nconst mat2 m4 = mat2( 0.60, -0.80, 0.80, 0.60 );\n\nconst mat3 m3 = mat3( 0.00,  0.80,  0.60,\n                     -0.80,  0.36, -0.48,\n                     -0.60, -0.48,  0.64 );\n\nfloat fbm( in vec3 p ) {\n    float f = 0.0;\n    f += 0.5000*noise3( p ); p = m3*p*2.02;\n    f += 0.2500*noise3( p ); p = m3*p*2.03;\n    f += 0.1250*noise3( p ); p = m3*p*2.01;\n    f += 0.0625*noise3( p );\n    return f/0.9375;\n}\n\nfloat fractalNoise(vec2 p) {\n \n    float n = 0.;\n    n += smoothNoise(p);\n    n += smoothNoise(p * 2.) / 2.;\n    n += smoothNoise(p * 4.) / 4.;\n    n += smoothNoise(p * 8.) / 8.;\n    n += smoothNoise(p * 16.) / 16.;\n    n /= 1. + 1./2. + 1./4. + 1./8. + 1./16.;\n    return n;\n    \n}\n\nfloat waterMap( vec2 pos ) {\n\tvec2 posm = pos * m4;\n\t\n\treturn abs( fbm( vec3( 8.*posm, time ))-0.5 )* 0.1;\n}\n\nbool intersectPlane(const in vec3 ro, const in vec3 rd, const in float height, inout float dist) {\t\n\tif (rd.y==0.0) {\n\t\treturn false;\n\t}\n\t\t\n\tfloat d = -(ro.y - height)/rd.y;\n\td = min(100000.0, d);\n\tif( d > 0. && d < dist ) {\n\t\tdist = d;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvec3 lig = normalize(vec3( 0.3,0.25, -0.6));\n\nvec3 bgColor( const in vec3 rd ) {\n\tfloat sun = clamp( dot(lig,rd), 0.0, 1.0 );\n\tvec3 col = vec3(0.5, 0.52, 0.55) - rd.y*0.2*vec3(1.0,0.8,1.0) + 0.15*0.75;\n\tcol += vec3(1.0,.6,0.1)*pow( sun, 8.0 );\n\tcol *= 0.95;\n\treturn col;\n}\n\n\nvec4 render(in vec3 ro, in vec3 rd, float t) {\n    // TODO\n    int debug = 0;\n    bool root;\n    if (SPHERE_TRACE == 1) root = false;\n    else root = true;\n    vec3 col = vec3(.8, .9, 1.0);\n    //float t = -1.0;\n    vec3 dist;\n    if (root) {\n        dist = findRoot(ro, rd);\n    }\n    else {\n        dist = sphereTrace(ro, rd, t);\n    }\n    t = dist.x;\n    if (t < 10.0) {\n        vec3 pt = ro + rd*t;\n        vec3 norm = calcNorm(pt);\n        \n        //material\n        \n        vec4 x = texture( iChannel1, pt.yz );\n        vec4 y = texture( iChannel1, pt.zx );\n        vec4 z = texture( iChannel1, pt.yx );\n        vec3 a = abs(norm);\n        vec4 diffuse = (x*a.x + y*a.y + z*a.z) / (a.x + a.y + a.z);\n        if (dist.z == 1.0 && norm.y >= 0.999) {\n            diffuse *= vec4(0.3, 0.0, 0.0, 1.0);\n        }\n        if (dist.z == 2.0) {\n            diffuse = vec4(.2118, 0.2706, 0.3098, 1.0);\n        }\n\n        //end material\n\n        vec3 ref = reflect(rd, norm);\n        vec3 light = normalize(vec3(0.0, 2.0, 2.0) - pt);\n        float lambert = clamp(dot(light, norm), 0.0, 1.0);\n        //float amb = ambientOcc(pt, norm);\n        //soft shadows\n        //lambert *= softshadow( pt, light, 0.02, 2.5 );\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        //dom *= softshadow( pt, ref, 0.02, 2.5 );\n\n        float specular = 0.0;\n        if (lambert > 0.0) {\n            vec3 viewDir = normalize(-pt);\n            vec3 halfDir = normalize(light + viewDir);\n            float specAngle = clamp(dot(halfDir, norm), 0.0, 1.0);\n            specular = pow(specAngle, 4.0);\n\n        }\n\n        col = vec3(.2) + lambert * vec3(diffuse) + specular * vec3(0.5); //amb*\n\n        col = pow(col, vec3(1.0/2.2));\n        col *= 1.0 - smoothstep( 20.0, 40.0, t );\n        if (dist.z == 3.0) {\n            float x = fractalNoise(pt.xz * 6.);\n            col = mix(vec3(x), vec3(.75, .85, 1.0), pow(abs(pt.y), .6));\n     \t\t//return vec4(rd, dist.y*3.0 / 50.0);\n    \t}\n        if (dist.z == 4.0) {\n            col = getColor(pt, norm, t);\n        }\n        \n        if (debug == 1) {\n            col = norm;\n        }\n        else if (debug == 2) {\n            if (root) {\n                col = vec3(1.0, 1.0, 1.0)*(dist.y / 1000.0);\n            }\n            else {\n                col = vec3(1.0, 0.0, 0.0)*(dist.y*3.0 / 50.0);\n            }\n        }\n        else if (debug == 3) {\n            col = vec3(1.0) * ((5.0 - t) / 5.0);\n        }\n        \n        \n    }\n    \n    \n    return vec4(col, 1.0); //rd;  // camera ray direction debug view\n}\n\t\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n    \n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nfloat intersectSimple( const vec3 ro, const vec3 rd ) {\n\tfloat maxd = 10000.0;\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float t = 0.0;\n    for( int i=0; i<50; i++ ) {\n\t\tif( abs(h)<precis || t>maxd ) break;  {\n\t\t\tt += h;\n\t\t\tvec2 newt = scene(ro, rd, t);\n            h = newt.x;\n\t\t}\n    }\n\n    return t;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n    \n    time = 15.0 + iTime;\n    \n    // camera\n    vec3 ro = vec3(\n                   -0.5 + 3.5 * cos(0.1  + 6.0 * mo.x),\n                   0.0 + 2.0 * mo.y,\n                   0.5 + 3.5 * sin(0.1  + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n    \n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n    \n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n    \n    \n\tfloat fresnel, refldist = 5000., maxdist = 5000.;\n\tbool reflected = false;\n\tvec3 normal, col = bgColor( rd );\n\tvec3 roo = ro, rdo = rd, bgc = col;\n\tfloat distSimple = intersectSimple(ro,rd);\n    if( intersectPlane( ro, rd, 0., refldist ) && refldist < distSimple ) {\n\t\tro += (refldist)*rd;\t\n\t\tvec2 coord = ro.xz;\n\t\tfloat bumpfactor = BUMPFACTOR * (1. - smoothstep( 0., BUMPDISTANCE, refldist) );\n\t\t\t\t\n\t\tvec2 dx = vec2( EPSILON, 0. );\n\t\tvec2 dz = vec2( 0., EPSILON );\n\t\t\n\t\tnormal = vec3( 0., 1., 0. );\n\t\tnormal.x = -bumpfactor * (waterMap(coord + dx) - waterMap(coord-dx) ) / (2. * EPSILON);\n\t\tnormal.z = -bumpfactor * (waterMap(coord + dz) - waterMap(coord-dz) ) / (2. * EPSILON);\n\t\tnormal = normalize( normal );\t\t\n\t\t\n\t\tfloat ndotr = dot(normal,rd);\n\t\tfresnel = pow(1.0-abs(ndotr),5.);\n\n\t\trd = reflect( rd, normal);\n\n\t\treflected = true;\n\t\tbgc = col = bgColor( rd );\n\t}\n\n    // render\n    vec4 color = render(roo, rdo, 0.);\n    col = vec3(color);\n    if(reflected) {\n\t\tcol = mix( col.xyz, bgc, 1.0-exp(-0.0000005*refldist*refldist) );\n\t\tcol *= fresnel*0.9;\t\t\n\t\tvec3 refr = refract( rdo, normal, 1./1.3330 );\n\t\tintersectPlane( ro, refr, -2., refldist );\n\t\tcol += mix( texture( iChannel2, (roo+refldist*refr).xz*1.3 ).xyz * \n\t\t\t\t   vec3(1.,.9,0.6), vec3(1.,.9,0.8)*0.5, clamp( refldist / 3., 0., 1.) ) \n\t\t\t   * (1.-fresnel)*0.125;\n        \n\t}\n    col = pow(col, vec3(0.7)); //4545));\n    col = col*col*(3.0-2.0*col);\n    col = mix( col, vec3(dot(col,vec3(0.33))), -0.5 );\n    col *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n    fragColor = vec4(col, 1.0);\n    \n    \n}","name":"","description":"","type":"image"}]}