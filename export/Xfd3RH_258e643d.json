{"ver":"0.1","info":{"id":"Xfd3RH","date":"1711930802","viewed":86,"name":"Internal reflection test","username":"Dhyrey","description":"Internal reflection test\n\nTODO : optimize object collisions, especially when inside the object","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["reflection","refraction","internalreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n \n\n*/\n\n// A great read on all this stuff:\n// https://graphics.stanford.edu/courses/cs148-10-summer/docs/2006--degreve--reflection_refraction.pdf\n\n// refractive index of some common materials:\n// http://hyperphysics.phy-astr.gsu.edu/hbase/Tables/indrf.html\n#define REFRACTIVE_INDEX_OUTSIDE 1.00029\n#define REFRACTIVE_INDEX_INSIDE  1.445\n\n// lighting parameters\n#define LIGHT_DIRECTIONAL_DIR   normalize(-vec3(1.0,2.0,1.0))\n#define LIGHT_DIRECTIONAL_COLOR vec3(1.0)\n#define LIGHT_AMBIENT           vec3(0.1)\n#define MAX_RAYS                15 // 2^(n+1) - 1 where n is the max number of bounces\n#define RENDER_DISTANCE         100.0\n#define MAX_ITER                100\n#define MAX_INTERNAL_BOUNCE     1024\n\n// object color parameters\n#define MAX_SDF_POINT_COUNT 256\n#define OBJECT_DIFFUSE      vec3(0.0)\n#define OBJECT_SPECPOWER    0.0\n#define OBJECT_REFLECTIVITY 0. // How reflective the object is. 1 is fully reflective, 0 is fresnel and -1 is no reflection\n#define OBJECT_ABSORB       vec3(8.0, 8.0, 3.0) // for beers law\n\n// object type\n#define OBJECT_COUNT 1\n\n#define BOX_TYPE    0\n#define SPHERE_TYPE 1\n#define SDF_TYPE    2\n\nstruct Object {\n    int type;\n    vec3 center;\n    vec3 dimensions;\n    float radius;\n    vec4 points[MAX_SDF_POINT_COUNT];\n    vec3 color;\n    float smoothFactor;\n    int len;\n} objects[OBJECT_COUNT];\n\n// objects to render\n\nvoid initObjects(){\n    \n    /*\n    // object 1 : SDF\n    objects[0].type = SDF_TYPE;\n    objects[0].points[0] = vec4(0.0, 0.0, 0.0, 0.5);\n    objects[0].points[1] = vec4(sin(iTime) * 0.85, 0.0, cos(iTime) * 1.7, 0.3);\n    objects[0].points[2] = vec4(sin(-iTime) * 1.4, 0.0, cos(-iTime) * 0.7, 0.2);\n    objects[0].len = 3;\n    objects[0].smoothFactor = 0.4;\n    objects[0].color = vec3(0.5,0.5,1.0);\n    */\n    \n    \n    //object 2 : Box\n    objects[0].type = BOX_TYPE;\n    objects[0].center = vec3(0.,0.,0.0);\n    objects[0].dimensions = vec3(1.0,0.8,1.0);\n    objects[0].color = vec3(0.5,1.0,0.5);\n    \n    \n    /*\n    //object 3 : Sphere\n    objects[2].type = SPHERE_TYPE;\n    objects[2].center = vec3(-2.,0.,1.0);\n    objects[2].radius = 0.3;\n    objects[2].color = vec3(1.0,0.5,0.5);\n    */\n}\n\n// hash21 from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n//============================================================\n\n// Function to calculate the intersection distance between a ray and an AABB\nvec4 RayIntersectBox(in vec3 rayPos, in vec3 rayDir, in vec3 center, in vec3 dimensions) {\n\n    vec3 minCorner = center - (dimensions / 2.);\n    vec3 maxCorner = center + (dimensions / 2.);\n    vec3 invDir = 1.0 / rayDir;\n    vec3 t0s = (minCorner - rayPos) * invDir;\n    vec3 t1s = (maxCorner - rayPos) * invDir;\n\n    vec3 tMin = min(t0s, t1s);\n    vec3 tMax = max(t0s, t1s);\n\n    float tNear = max(max(tMin.x, tMin.y), tMin.z);\n    float tFar = min(min(tMax.x, tMax.y), tMax.z);\n\n    // Check if ray intersects the AABB\n    if (tNear <= tFar && tFar > 0.) {\n    \n        float t = tNear;\n        if(tNear < 0.){\n            t = tFar;\n        }\n        \n        \n        rayPos += rayDir * t;\n    \n        // Calculate the normal at the intersection point\n        vec3 normal;\n        if (abs(rayPos.x - minCorner.x) < 0.001) {\n            normal = vec3(-1.0, 0.0, 0.0);\n        } else if (abs(rayPos.x - maxCorner.x) < 0.001) {\n            normal = vec3(1.0, 0.0, 0.0);\n        } else if (abs(rayPos.y - minCorner.y) < 0.001) {\n            normal = vec3(0.0, -1.0, 0.0);\n        } else if (abs(rayPos.y - maxCorner.y) < 0.001) {\n            normal = vec3(0.0, 1.0, 0.0);\n        } else if (abs(rayPos.z - minCorner.z) < 0.001) {\n            normal = vec3(0.0, 0.0, -1.0);\n        } else if (abs(rayPos.z - maxCorner.z) < 0.001) {\n            normal = vec3(0.0, 0.0, 1.0);\n        } else {\n            // The intersection point is not on the face of the AABB (should not happen in practice)\n            normal = vec3(0.0);\n        }\n    \n        // Ray intersects AABB, return the closest intersection distance\n        return vec4(t,sign(tNear)*normal);\n    }\n    \n    // Ray misses the AABB\n    return vec4(-1.0);\n}\n\nbool isInsideBox(in vec3 rayPos, in int ident)\n{\n    vec3 minCorner = objects[ident].center - (objects[ident].dimensions / 2.);\n    vec3 maxCorner = objects[ident].center + (objects[ident].dimensions / 2.);\n    return  rayPos.x < minCorner.x || rayPos.x > maxCorner.x ||\n            rayPos.y < minCorner.y || rayPos.y > maxCorner.y ||\n            rayPos.z < minCorner.z || rayPos.z > maxCorner.z;\n}\n\n//============================================================\n// returns t and surface normal\n// sphere xyz = position, w = radius\nvec4 RayIntersectSphere (in vec3 rayPos, in vec3 rayDir, in vec4 sphere)\n{\n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn vec4(-1.0);\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn vec4(-1.0);\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat normalMultiplier = 1.0;\n\tfloat collisionTime = -b - sqrt(discr);\n    if (collisionTime < 0.0)\n    {\n        collisionTime = -b + sqrt(discr);\n        normalMultiplier = -1.0;\n    }\n    \n    // calculate the normal, flipping it if we hit the inside of the sphere\n    vec3 normal = normalize((rayPos+rayDir*collisionTime) - sphere.xyz) * normalMultiplier;\n    \n    // return the time t that the collision happened, as well as the surface normal\n    return vec4 (collisionTime, normal);\n}\n\nbool isInsideSphere(in vec3 rayPos, in int ident)\n{\n    return length(rayPos - objects[ident].center) < objects[ident].radius;\n}\n\n//============================================================\n\nfloat smoothMin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat dPoints(in vec3 rayPos, in Object inSDF)\n{   \n    vec4 SDFPoint = inSDF.points[0];\n    float d = distance(rayPos,SDFPoint.xyz)-SDFPoint.w;\n    for(int i = 1; i < inSDF.len; i++){\n        SDFPoint = inSDF.points[i];\n        d = smoothMin(d,distance(rayPos,SDFPoint.xyz)-SDFPoint.w,inSDF.smoothFactor);\n    }\n    return d;\n}\n\nvec3 computeNormalSDF(in vec3 point, in Object inSDF) {\n    float e = 0.001;\n\n    float dx = (dPoints(point + vec3(e, 0.0, 0.0), inSDF) - dPoints(point - vec3(e, 0.0, 0.0), inSDF)) / (2.0 * e);\n    float dy = (dPoints(point + vec3(0.0, e, 0.0), inSDF) - dPoints(point - vec3(0.0, e, 0.0), inSDF)) / (2.0 * e);\n    float dz = (dPoints(point + vec3(0.0, 0.0, e), inSDF) - dPoints(point - vec3(0.0, 0.0, e), inSDF)) / (2.0 * e);\n\n    return normalize(vec3(dx, dy, dz));\n}\n\nvec4 RayIntersectSDF(in vec3 rayPos, in vec3 rayDir, in Object inSDF, in float epsilon)\n{\n    rayDir = normalize(rayDir);\n    float dTraveled = 0.;\n    \n    float sdfDistance = dPoints(rayPos, inSDF);\n    if( sdfDistance > 0.0){\n        for(int i = 0; i < MAX_ITER && dTraveled < RENDER_DISTANCE; i++){\n            vec3 currentPos = rayPos + dTraveled * rayDir;\n            sdfDistance = dPoints(currentPos, inSDF);\n            if(sdfDistance  < epsilon){\n                return vec4(dTraveled, computeNormalSDF(currentPos, inSDF));\n            }\n            dTraveled += sdfDistance ;\n        }\n        return vec4(-1.);\n    }\n    else{\n        dTraveled += 2. * epsilon;\n        for(int i = 0; i < MAX_ITER && dTraveled < RENDER_DISTANCE; i++){\n            vec3 currentPos = rayPos + dTraveled * rayDir;\n            sdfDistance = -dPoints(currentPos, inSDF);\n            if(sdfDistance  < epsilon){\n                return vec4(dTraveled, -computeNormalSDF(currentPos, inSDF));\n            }\n            dTraveled += sdfDistance ;\n        }\n        return vec4(-1.);\n    }\n}\n\nbool isInsideSDF(in vec3 rayPos, in int ident)\n{\n    return dPoints(rayPos,objects[ident]) < 0.;\n}\n\n//============================================================\n// returns t and surface normal\n// plane xyz = normal, w = d\n// from https://www.cs.princeton.edu/courses/archive/fall00/cs426/lectures/raycast/sld017.htm\nvec4 RayIntersectPlane (in vec3 rayPos, in vec3 rayDir, in vec4 plane, out vec2 uv)\n{   \n    float collisionTime = -(dot(rayPos, plane.xyz)+plane.w) / dot(rayDir, plane.xyz);\n    vec3 uaxis = normalize(cross(plane.xyz, vec3(0.0, 1.0, 0.0)));\n    vec3 vaxis = normalize(cross(plane.xyz, uaxis));\n    vec3 collisionPos = rayPos + rayDir * collisionTime;\n    uv.x = dot(collisionPos, uaxis);\n    uv.y = dot(collisionPos, vaxis);    \n    return vec4(collisionTime, plane.xyz);\n}\n\n//============================================================\nvoid TrimRayInterval (vec3 rayPos, vec3 rayDir, inout vec2 rayMinMax, vec4 plane, inout vec3 nearNormal, inout vec3 farNormal)\n{\n    vec2 uv;\n    vec4 rayInfo = RayIntersectPlane(rayPos, rayDir, plane, uv);   \n    if (dot(rayInfo.yzw, rayDir) < 0.0)\n    {\n        if (rayInfo.x > rayMinMax.x)\n        {\n            rayMinMax.x = rayInfo.x;\n            nearNormal = rayInfo.yzw;\n        }\n    }\n    else\n    {\n        if (rayInfo.x < rayMinMax.y)\n        {\n            rayMinMax.y = rayInfo.x;\n            farNormal = rayInfo.yzw;\n        }\n    }\n}\n\n//============================================================\n\nvec4 RayIntersectObject (in vec3 rayPos, in vec3 rayDir, out int object_identifier)\n{\n        vec4 collision;\n        vec4 bestCollision = vec4(-1.);\n        int i_min = 0;\n        float t_min = RENDER_DISTANCE;\n        for(int i = 0; i < OBJECT_COUNT; i++){\n        \n            if(objects[i].type == SPHERE_TYPE){\n                collision = RayIntersectSphere(rayPos, rayDir, vec4(objects[i].center,objects[i].radius));\n            }\n            if(objects[i].type == BOX_TYPE){\n                collision = RayIntersectBox(rayPos, rayDir, objects[i].center, objects[i].dimensions);\n            }\n            if(objects[i].type == SDF_TYPE){\n                collision = RayIntersectSDF(rayPos, rayDir, objects[i], 0.0001);\n            }\n            \n            if(collision.x < t_min && collision.x > 0.0){\n                t_min = collision.x;\n                i_min = i;\n                bestCollision = collision;\n            }\n        }\n        \n        object_identifier = i_min;\n    \treturn bestCollision;\n}\n\nbool RayInsideObject (in vec3 rayPos, in int ident)\n{\n    if(objects[ident].type == SPHERE_TYPE){\n        return isInsideSphere(rayPos,ident);\n    }\n    if(objects[ident].type == BOX_TYPE){\n        return isInsideBox(rayPos,ident);\n    }\n    if(objects[ident].type == SDF_TYPE){\n        return isInsideSDF(rayPos,ident);\n    }\n    return false;\n}\n\n//============================================================\nvec3 Checkerboard (vec2 uv)\n{\n    return vec3(mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) < 1.0 ? 1.0 : 0.4);\n}\n\n//============================================================\n// this is ibox() from https://www.shadertoy.com/view/ld23DV\n// Just renamed some things to be more clear and minimized to needed functionality\n// returns t and normal\nvec4 RayIntersectBase ( in vec3 rayOrigin, in vec3 rayDirection, in vec3 boxHalfSizes, out vec2 uv ) \n{\n\t// ray-box intersection\n    vec3 m = 1.0/rayDirection;    // how many steps on each axis to travel 1 unit on that axis\n    vec3 n = m*rayOrigin;         // how many steps on each axis the ray origin is from the object origin\n    vec3 k = abs(m)*boxHalfSizes; // how many steps on each axis it takes to get from the center of the box to the edge\n\t\n    vec3 t1 = -n - k;   // how many steps on each axis to get from the ray origin to the negative surface of the box.\n    vec3 t2 = -n + k;   // how many steps on each axis to get from the ray origin to the positive surface of the box.\n\n\tfloat timeNear = max( max( t1.x, t1.y ), t1.z );\n\tfloat timeFar = min( min( t2.x, t2.y ), t2.z );\n\n\tif( timeNear > timeFar || timeFar < 0.0)\n        return vec4(-1.0);\n\n\t//vec3 normal = -sign(rayDirection)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    \n    if (timeNear < 0.0)\n        timeNear = timeFar;\n    \n    vec3 relPoint = rayOrigin + rayDirection * timeNear;\n    \n    vec3 absRelPoint = abs(relPoint) / boxHalfSizes;\n    \n    vec3 normal;\n    vec3 uaxis;\n    vec3 vaxis;\n    // if Y isn't the biggest value it can't be the normal axis\n    if (absRelPoint.x >= absRelPoint.y)\n    {\n        // if X is the winner\n        if (absRelPoint.x >= absRelPoint.z)\n        {\n            normal = vec3(1.0, 0.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(0.0,1.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);            \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }\n    }\n    // else X isn't the biggest value so it can't be the normal axis\n    else\n    {\n        // if Y is the winner\n        if (absRelPoint.y >= absRelPoint.z)\n        {\n            normal = vec3(0.0, 1.0, 0.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,0.0,1.0);\t           \n        }\n        // else it's Z\n        else\n        {\n            normal = vec3(0.0, 0.0, 1.0) * -sign(rayDirection);\n\t\t\tuaxis = vec3(1.0,0.0,0.0);\n\t\t\tvaxis = vec3(0.0,1.0,0.0);            \n        }        \n    }\n    \n\tuv = vec2\n\t(\n\t\tdot(relPoint, uaxis),\n\t\tdot(relPoint, vaxis)\n\t);    \n\n\treturn vec4( timeNear, normal );    \n}\n\n//============================================================\nvec3 LightPixel (vec3 rayPos, vec3 rayDir, vec3 diffuse, vec3 normal, float specPower, bool doShadow)\n{   \n    // ambient\n    vec3 pixelColor = diffuse * LIGHT_AMBIENT;\n    int ident;\n    \n    // see if we are in shadow by casting in the light direction and seeing if we hit the object.\n    // if we do hit the object, return just the ambient lighting shaded color we have already calculated.\n    if (doShadow && normal.y >= 0.9 && RayIntersectObject(rayPos, -LIGHT_DIRECTIONAL_DIR,ident).x >= 0.0)\n        return pixelColor;\n    \n    // diffuse\n    float dp = clamp(dot(normal, -LIGHT_DIRECTIONAL_DIR), 0.0, 1.0);\n    pixelColor += diffuse * dp * LIGHT_DIRECTIONAL_COLOR;\n    \n    // specular highlight\n    if (specPower > 0.0)\n    {\n    \tvec3 reflection = reflect(-LIGHT_DIRECTIONAL_DIR, normal);\n    \tdp = clamp(dot(rayDir, reflection), 0.0, 1.0);\n\t\tpixelColor += LIGHT_DIRECTIONAL_COLOR * pow(dp, specPower);    \n    }\n    \n    return pixelColor;\n}\n\n\n\n//============================================================\nvec3 GetSceneRayColor (in vec3 rayPos, in vec3 rayDir)\n{\n    // Returns the lit RGB for this ray intersecting with the scene, ignoring the main object.\n    // Used for reflection off the surface of the object, and refraction out the back of the object.\n    \n    // if we hit the box, return the lit box color\n    vec2 uv;\n    vec4 rayInfo = RayIntersectBase(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0)\n        return LightPixel(rayPos + rayDir*rayInfo.x, rayDir, Checkerboard(uv), rayInfo.yzw, 100.0, true);\n    // else return skybox color\n    else\n        return texture(iChannel0, rayDir).rgb;\n}\n\n\n//============================================================\n\nfloat fresnel(in vec4 rayInfo, in vec3 rayDir, in float r)\n{\n    float f = pow(clamp(1. - dot(rayInfo.yzw, -rayDir), 0., 1.), 5.);\n    return (0.5 - f)*r*r + 0.5*r + f;\n    \n}\n\nvec3 RayTracePixelColor (in vec3 rayPos, in vec3 rayDir)\n{   \n    vec4 bestRayHitInfo = vec4(1000.0, 0.0, 0.0, 0.0);\n    vec3 rayHitDiffuse = vec3(1.0);\n    vec3 additiveColor = vec3(0.0);\n    \n    vec3 ret = vec3(0.0);\n           \n    // see if we've hit the platform and remember if we have\n    vec2 uv;    \n    vec4 rayInfo = RayIntersectBase(rayPos + vec3(0.0, 1.51, 0.0), rayDir, vec3(1.0, 1.0, 1.0), uv);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {\n        bestRayHitInfo = rayInfo;\n        rayHitDiffuse = Checkerboard(uv);\n    }\n    \n    \n    // if we've hit the main object, and it's closer than the platform\n    int ident = 0;\n    rayInfo = RayIntersectObject(rayPos, normalize(rayDir),ident);\n    if (rayInfo.x >= 0.0 && rayInfo.x < bestRayHitInfo.x)\n    {   \n        \n        // light the surface of the ball a bit\n        additiveColor += LightPixel(rayPos, rayDir, OBJECT_DIFFUSE, rayInfo.yzw, OBJECT_SPECPOWER, false);\n        \n        // declarations of all variable used\n        int isLeafArr[MAX_RAYS];\n        int collisionObject[MAX_RAYS];\n        float fresnelArr[MAX_RAYS];\n        \n        float rayPosArrX[MAX_RAYS];\n        float rayPosArrY[MAX_RAYS];\n        float rayPosArrZ[MAX_RAYS];\n        \n        float rayDirArrX[MAX_RAYS];\n        float rayDirArrY[MAX_RAYS];\n        float rayDirArrZ[MAX_RAYS];\n        \n        vec3 colorArr[MAX_RAYS];\n        int onlyLeaf = (MAX_RAYS-1)/2;\n        vec3 reflectDir;\n        vec3 reflectPos;\n        vec3 refractDir;\n        vec3 refractPos;\n        \n        // init of the first element of each array\n        for(int i = 0; i < MAX_RAYS; i++){\n            isLeafArr[i] = 0;\n            colorArr[i] = vec3(0.0);\n        }\n        collisionObject[0] = ident;\n        rayPosArrX[0] = rayPos.x;\n        rayPosArrY[0] = rayPos.y;\n        rayPosArrZ[0] = rayPos.z;\n        \n        rayDirArrX[0] = rayDir.x;\n        rayDirArrY[0] = rayDir.y;\n        rayDirArrZ[0] = rayDir.z;\n        \n        // generation of all rays\n        for(int i = 0; i < MAX_RAYS; i++){\n        \n            // case 1 : the ray does not exist and it has sons\n            if(isLeafArr[i] == 2 && i < onlyLeaf){\n                isLeafArr[(2*i)+1] = 2;\n                isLeafArr[(2*i)+2] = 2;\n                continue;\n            }\n            \n            // the ray exists so we retrieve its data and compute the next intersection\n            rayPos = vec3(rayPosArrX[i], rayPosArrY[i], rayPosArrZ[i]);\n            rayDir = normalize(vec3(rayDirArrX[i], rayDirArrY[i], rayDirArrZ[i]));\n            rayInfo = RayIntersectObject(rayPos, rayDir, ident);\n            collisionObject[i] = ident;\n            \n            if(rayDir == vec3(0.)){\n                return vec3(1.,0.,0.);\n            }\n            \n            // case 2 : ray intersect nothing or has max bounces\n            if(rayInfo.x < 0.0 || i >= onlyLeaf){\n                isLeafArr[i] = 1;\n                \n                if(i < onlyLeaf){ // if it hasn't reach max bounce we need to marks the next rays in the branch as non-existant\n                    isLeafArr[(2*i)+1] = 2;\n                    isLeafArr[(2*i)+2] = 2;\n                }\n                \n                continue;\n            }\n            \n            // case 3 : ray hasn't reach max bounce and intersect an object\n            if(rayInfo.x >= 0.0 && i < onlyLeaf){\n                isLeafArr[i] = 0;\n                fresnelArr[i] = fresnel(rayInfo, rayDir, OBJECT_REFLECTIVITY);\n                \n                int reflectIndex = (2 * i) + 1;\n                int refractIndex = (2 * i) + 2;\n                \n                // reflection ray\n                reflectDir = normalize(reflect(rayDir, rayInfo.yzw));\n                reflectPos = rayPos + rayDir * rayInfo.x + 0.001 * reflectDir;\n                \n                rayPosArrX[reflectIndex] = reflectPos.x;\n                rayPosArrY[reflectIndex] = reflectPos.y;\n                rayPosArrZ[reflectIndex] = reflectPos.z;\n                rayDirArrX[reflectIndex] = reflectDir.x;\n                rayDirArrY[reflectIndex] = reflectDir.y;\n                rayDirArrZ[reflectIndex] = reflectDir.z;\n\n                // refraction ray\n                vec3 refractDirInside = refract(rayDir, rayInfo.yzw, REFRACTIVE_INDEX_OUTSIDE/REFRACTIVE_INDEX_INSIDE);\n                refractPos = rayPos + rayDir * rayInfo.x + refractDirInside * 0.001;\n                vec4 rayInfoInside = RayIntersectObject(refractPos, refractDirInside, ident);\n                if (rayInfoInside.x >= 0.0) {\n                    refractDir = refract(refractDirInside, rayInfoInside.yzw, REFRACTIVE_INDEX_INSIDE/REFRACTIVE_INDEX_OUTSIDE);\n                    \n                    if(refractDir == vec3(0.)){\n                        reflectPos = refractPos;\n                        for(int j = 0; j < MAX_INTERNAL_BOUNCE; j ++){\n                            reflectDir = reflect(refractDirInside, rayInfoInside.yzw);\n                            reflectPos += refractDirInside * rayInfoInside.x + 0.001 * reflectDir;\n                            rayInfoInside = RayIntersectObject(reflectPos, reflectDir, ident);\n                            \n                            refractDirInside = reflectDir;\n                            \n                            refractDir = refract(reflectDir, rayInfoInside.yzw, REFRACTIVE_INDEX_INSIDE/REFRACTIVE_INDEX_OUTSIDE);\n                            \n                            if(refractDir != vec3(0.)){\n                                reflectDir = refractDir;\n                                break;\n                            }\n                        }\n                        \n                        reflectPos += refractDirInside * rayInfoInside.x + 0.001 * reflectDir;\n                        \n                        rayPosArrX[refractIndex] = reflectPos.x;\n                        rayPosArrY[refractIndex] = reflectPos.y;\n                        rayPosArrZ[refractIndex] = reflectPos.z;\n                        rayDirArrX[refractIndex] = reflectDir.x;\n                        rayDirArrY[refractIndex] = reflectDir.y;\n                        rayDirArrZ[refractIndex] = reflectDir.z;\n\n                        continue;\n                    }\n                    \n                    refractPos += refractDirInside * rayInfoInside.x + 0.001 * refractDir;\n                    rayPosArrX[refractIndex] = refractPos.x;\n                    rayPosArrY[refractIndex] = refractPos.y;\n                    rayPosArrZ[refractIndex] = refractPos.z;\n                    rayDirArrX[refractIndex] = refractDir.x;\n                    rayDirArrY[refractIndex] = refractDir.y;\n                    rayDirArrZ[refractIndex] = refractDir.z;\n                }\n                \n            }\n        }\n        \n        // computing the color of the rays (starting from the bottom of the tree)\n        for(int i = MAX_RAYS - 1; i >= 0; i--){\n            // case 1 : no ray\n            if(isLeafArr[i] == 2){\n                continue;\n            }\n\n            //case 2 : leaf ray\n            if(isLeafArr[i] == 1){\n                rayPos = vec3(rayPosArrX[i], rayPosArrY[i], rayPosArrZ[i]);\n                rayDir = vec3(rayDirArrX[i], rayDirArrY[i], rayDirArrZ[i]);\n                colorArr[i] = GetSceneRayColor(rayPos, rayDir);\n                continue;\n            }\n\n            // case 3 : ray is the combination of a reflect ray and a refract ray\n            if(isLeafArr[i] == 0){\n                colorArr[i] = fresnelArr[i] * colorArr[(2*i)+1];\n                colorArr[i] += (1. - fresnelArr[i]) * colorArr[(2*i)+2];\n                continue;\n            }\n        }\n        \n        //return maxReflectionDepth(isLeafArr);\n        //return vec3(rayPosArrX[5], rayPosArrY[5], rayPosArrZ[5]);\n        return ret + colorArr[0] + additiveColor;\n        \n    }\n    // else we missed the object, so return either the skybox color, or the platform color, as appropriate\n    else\n    {\n        //return rayDir;\n        \n        if (bestRayHitInfo.x == 1000.0)    \n            return texture(iChannel0, rayDir).rgb;\n        else\n        {\n            // move the ray to the intersection point (so we can shadow) and light the pixel\n        \trayPos += rayDir * bestRayHitInfo.x;    \n            return LightPixel(rayPos, rayDir, rayHitDiffuse, bestRayHitInfo.yzw, 100.0, true);    \n        }\n    }\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    //----- Camera Setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 3.14 + iTime * 0.25;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) - 0.4 : 0.3;\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 6.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!\n\n    //----- Ray Setup\n    vec2 rawPercent = (fragCoord.xy / iResolution.xy); \n    vec2 percent = rawPercent - vec2(0.5,0.5);\n\n    vec3 rayTarget = (cameraFwd * vec3(cameraDistance,cameraDistance,cameraDistance))\n        - (cameraLeft * percent.x * cameraViewWidth)\n        + (cameraUp * percent.y * cameraViewHeight);\n    vec3 rayDir = normalize(rayTarget);\n    \n    //----- Object Init\n    initObjects();\n\n    //----- Ray Trace\n    vec3 finalColor = vec3(0.0);\n\n \tfinalColor = RayTracePixelColor(cameraPos, rayDir);\n    \n    //----- Final color, gamma corrected\n    fragColor = vec4(pow(finalColor, vec3(1.0/2.2)),1.0);        \n}","name":"Image","description":"","type":"image"}]}