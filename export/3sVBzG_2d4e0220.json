{"ver":"0.1","info":{"id":"3sVBzG","date":"1616798457","viewed":56,"name":"Sphere Rouge & plane","username":"Mehdix92i","description":"Lance un rayon qui intersecte une sphÃ¨re rouge et un plan avec illumination","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Material\n{\n    float Ka;\n    float Kd;\n    float Ks;\n    float Kn;\n};\n\n// In GLSL, IEEE 754 infinity can conveniently be achieved by dividing by zero:\nconst float FLT_MAX = 1.0 / 0.0;   \n\n// Camera parameters\nconst vec3\tcameraPos    = vec3(6, 4, -5);\nconst vec3\tcameraTarget = vec3(3, 1, -8);\nconst float cameraFovY   = 80.0;\t\t\t// NOTE: angle in degree\n\n// Sphere parameters\nconst vec3  \tspherePos    = cameraTarget + vec3(0, 1, 2);\nconst float \tsphereRadius = 1.0;\nconst vec3 \t\tsphereCol\t = vec3(1,0,0);\nconst int \t\tsphereId \t = 1;\nconst Material \tsphereMat \t = Material(0.2/*Ka*/, 0.7/*Kd*/, 1.0/*Ks*/, 50.0/*Kn*/);\n    \n//Light Parameters\nconst vec3 ambiantCol  \t= vec3(0,0,1);\nconst vec3 lightCol \t= vec3(1,1,1);\nconst vec3 lightPos \t= vec3(8,10,-12);\n\n//Sky parameters\nconst vec3 skyCol = vec3(0);\t//black\nconst int \tskyId = 0;\n\n//Plane parameters\nconst vec3 planePos \t= vec3(0, 0.1, 0);\nconst vec3 planeNormal \t= vec3(0, 1.0, 0);\nconst vec3 planeCol1 \t= vec3(1.0);\nconst vec3 planeCol2 \t= vec3(0.4);\nconst Material planeMat = Material(0.2, 1.0, 0.2, 5.0);\nconst int planeId = 2;\n    \n\n//##############################################################################################\n\nfloat raySphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float sphereRadius, out vec3 intersecS, out vec3 normalS)\n{\n    \n    vec3 diff = rayPos - spherePos;\n    \n    float a =       dot(rayDir, rayDir);\n    float b = 2.0 * dot(diff  , rayDir);\n    float c =       dot(diff  , diff  ) - sphereRadius * sphereRadius;\n    \n    float di = b*b - 4.0*a*c;\n    \n    if (di >= 0.0)\n    {\n        float sdi = sqrt(di);\n        float den = 1. / (2.0 * a);\n        float t1  = (-b - sdi) * den;\n        float t2  = (-b + sdi) * den;\n        \n        /*if(t1>0.0)\n        {\n            if(t2>t1)\n            \tintersecS = rayPos + t2*rayDir;\n            else\n                intersecS = rayPos + t1*rayDir;  \n        }\n        else if(t2>0.0)\n        {\n            if(t2>t1)\n                intersecS = rayPos + t2*rayDir;\n            else\n                intersecS = rayPos + t1*rayDir;\n        }\n        normalS = -normalize(spherePos - intersecS);\n        return di;*/\n    \t\n        float t = (t1>0.0) ? t1 : t2;\n        float dir = (t1>0.0) ? 1.0 : -1.0;\n        intersecS = rayPos +t * rayDir;\n        normalS = dir * normalize(intersecS - spherePos);\n        return t;\n    }\n    \n    return -1.0;\n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat  rayPlane(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal, out vec3 intersecP, out vec3 normalP)\n{\n    float den = dot(rayDir, planeNormal);\n    if(abs(den)>0.000001)\n    {\n        float t = dot(planeNormal, planePos - rayPos) / den;\n        intersecP = rayPos + t * rayDir;\n        normalP = -sign(den) * planeNormal;\n        return t;\n    }\n \treturn -1.0;   \n}\n\n//----------------------------------------------------------------------------------------------\n\nfloat computeNearestIntersection(vec3 rayPos, vec3 rayDir, out int objectId, out vec3 intersecI, out vec3 normalI)\n{\n    /*// Test ray-sphere intersection\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    \n    // Test ray-plane intersection\n    vec3 intersecP, normalP;\n    float distP = rayPlane(rayPos, rayDir, planePos, planeNormal, intersecP, normalP);\n    \n    if(distS < distP || (distS!=-1.0 && distP==-1.0))\n    {\n        intersecI = intersecS;\n        normalI = normalS;\n        objectId = sphereId;\n        return distS;\n    }\n    else if(distP < distS || (distP!=-1.0 && distS==-1.0))\n    {\n        intersecI = intersecP;\n        normalI = normalP;\n        objectId = planeId;\n        return distP; \n    }\n    else\n    {\n        objectId = skyId;\n    \treturn -1.0;\n\n    }*/\n    \n     // Set the default value when no intersection is found: we hit the 'sky'\n    float minDist  = FLT_MAX;\n          objectId = skyId;\n    \n    // Test the sphere\n    vec3 intersecS, normalS;\n    float distS = raySphere(rayPos, rayDir, spherePos, sphereRadius, intersecS, normalS);\n    if ((distS > 0.0) && (distS < minDist))\n    {\n        objectId  =  sphereId;\n        minDist   =     distS;\n        intersecI = intersecS;\n          normalI =   normalS;\n    }\n    \n    // Test the plane\n    vec3 intersecP, normalP;\n    float distP =  rayPlane(rayPos, rayDir,  planePos,  planeNormal, intersecP, normalP);\n    if ((distP > 0.0) && (distP < minDist))\n    {\n        objectId  =   planeId;\n        minDist   =     distP;\n\t    intersecI = intersecP;\n    \t  normalI =   normalP;\n    }\n    \n    // To remain coherent with the raySphere & rayPlane function that returns -1 when no\n    // intersetion is found, we add the following two lines:\n    if (objectId == skyId)\n        minDist = -1.0;\n    \n    return minDist;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvoid computeCameraRayFromPixel( in vec2 pixCoord, out vec3 rayPos, out vec3 rayDir)\n{\n                 \n    float focal = 1.0 / tan(radians(cameraFovY) / 2.0);\n    \n    vec3 cz = normalize(cameraTarget - cameraPos);\n       \n    vec3 up = vec3(0,1,0);\t\t\t\t\t\t\t// perfect up vector\n    vec3 cx = normalize(cross(-up, cz));\n    \n    vec3 cy = normalize(cross( cz, cx));\n   \n    vec2 pt = (2.*pixCoord - iResolution.xy) / iResolution.y;\n    \n    rayPos = cameraPos;\n    rayDir = normalize(pt.x * cx - pt.y * cy + focal * cz);\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getSphereColorAtPoint(vec3 pt)\n{\n    return sphereCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getPlaneColorAtPoint(vec3 pt)\n{\n    vec3 wX = vec3(1,0,0);\n    vec3 axisX = normalize(wX - dot(wX, planeNormal) * planeNormal);\n    vec3 axisY = normalize(cross(planeNormal, axisX));\n    \n    vec3 diff = pt - planePos;\n    float u = dot(diff, axisX);\n    float v = dot(diff, axisY);\n    return mod(floor(u*0.5) + floor(v*0.5), 2.0) < 1.0 ? planeCol1 : planeCol2; \n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 getObjectColorAtPoint(int objectId, vec3 pt, out Material objectMat)\n{\n    if(objectId == sphereId)\n    {\n        objectMat = sphereMat;\n        return getSphereColorAtPoint(pt);\n    }\n    else if(objectId == planeId)\n    {\n       \tobjectMat = planeMat;\n        return getPlaneColorAtPoint(pt); \n    }\n    return skyCol;\n}\n\n//----------------------------------------------------------------------------------------------\n\nvec3 computePhongShading(vec3 objectCol, Material objectMat, vec3 normalS, vec3 L, vec3 R, vec3 V)\n{\n    vec3 ambiant = ambiantCol * objectMat.Ka;\n    vec3 diffuse = objectCol * lightCol * max(dot(normalS,L),0.0) * objectMat.Kd;\n    vec3 specular = lightCol * objectMat.Ks * (pow(max(dot(R,V),0.0), objectMat.Kn));\n    return ambiant + diffuse + specular;\n}\n\n//##############################################################################################\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Compute the ray to be casted through the pixel towards the 3D scene\n    vec3 rayPos, rayDir;\n    computeCameraRayFromPixel(fragCoord, rayPos, rayDir);\n    \n     // Test ray intersection\n    vec3 intersecI, normalI;\n    int objectId;\n    float dist = computeNearestIntersection(rayPos, rayDir, objectId, intersecI, normalI);\n    \n    if (dist>0.0)\n    {\n       vec3 L = normalize(lightPos - intersecI);\n        \n       vec3 R = normalize(2.0*dot(normalI, L)*normalI - L);\n        \n       vec3 V = normalize(cameraPos - intersecI);\n        \n       Material objectMat;\n       vec3 objectCol = getObjectColorAtPoint(objectId, intersecI, objectMat);\n        \n       fragColor = vec4(computePhongShading(objectCol, objectMat, normalI, L, R, V),1.0);\n    }\n    else\n    \tfragColor = vec4(skyCol, 1);\n}","name":"Image","description":"","type":"image"}]}