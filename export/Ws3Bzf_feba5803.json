{"ver":"0.1","info":{"id":"Ws3Bzf","date":"1605632113","viewed":474,"name":"Human Meat Grinder","username":"jpupper","description":"So , I was trying to make a colorfull , full of love shader but i came out with this. \n\n\nSpecial thanks to kali for the structure\n\ncode is in spanish but whatever.","likes":17,"published":3,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// RESTAR UN OBJETO A OTRO\n\n// Igual al ejemplo anterior, pero reemplazamos la esfera central\n// por otro objeto que resulta de restarle a un cubo la esfera\n\n\n// VARIABLES GLOBALES\n\nfloat det = 0.05;\nfloat maxdist = 800.;\nint maxsteps = 100;\nvec3 objcol;\n\n// FUNCION DE ROTACION\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\n// FUNCIONES DE DISTANCIA PRIMITIVAS \n\nfloat sphere(vec3 p, float rad) \n{\n    return length(p) - rad;\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    p=abs(p)-c;\n    return length(max(p,0.))+min(0.,max(p.z,max(p.x,p.y)));\n}\n\n// construccion de un objeto usando las primitivas combinadas con max\n// para obtener su interseccion. Esto generará una forma que es igual\n// al espacio donde formas combinadas se intersecten.\n// en este caso intersectamos un cubo con una esfera\n\nfloat obj1(vec3 p,vec3 s) \n{\n\n    s.y+=1.-abs(p.x);\n    s.y*=.2;\n    float box = box(p, s);\n\n   // p.y+=fract(p.y*.1+time);\n    //p.x+=fract(time);09\n    float sph = sphere(p,0.9);\n    float d = box;\n    return d;\n}\n\nfloat obj2(vec3 p) \n{\n    float box = box(p, vec3(0.2,500.1,0.2));\n  \n    // de esta manera le restamos al cubo la forma de la esfera\n    float d = box;\n    return d;\n}\n\n\n// FUNCION DE ESTIMACION DE DISTANCIA\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n    \n    \nfloat de(vec3 p) \n{\n\n    float ms = floor(10.0)+1.;\n\n \n    p.z+=iTime*10.;\n       float indexy = floor(p.z/ms);\n    // rotamos en dos ejes\n    p.xy *= rot(iTime*.03+indexy);\n\n    float id2 = floor(p.z/ms);\n    \n    p.x = mod(p.x, ms) - ms/2.;\n    p.z = mod(p.z, ms) - ms/2.;\n \n    //p.z+=sin(id2*4+time);\n    //p.y = mod(p.y, ms*2.) - ms*2/2;\n    \n    \n    vec3 p3 = p;\n    float obj2 = obj2(p3); //Columna\n    //p.xz*=rot(time);\n   //  p.xy*=rot(time);\n   // p=abs(p);\n    //0p -= sin(time)*.1+.51;\n   \n    vec3 p2 = p;\n    float ms2 = 3.0;\n    \n    p2.y+=iTime;\n   // p2.z+=time;\n    float id = floor(p2.y/ms2);\n    \n   \n    p2.y = mod(p2.y,ms2) -ms2/2.;\n    p2.xz*=rot(iTime*2.+id*10.);\n \n    \n    float obj1 = obj1(p2,vec3(0.8+sin(id+iTime*5.)*.5+.5,0.,0.0));\n    \n   // obj1 = opSmoothIntersection(obj1,obj2,-0.8);\n    //p.z =sin(p.x*1);\n   //   obj1 = max(obj1, sphere(p2, sin(time)*.02+1.1));\n    // obtenemos la distancia minima entre obj1 y obj2 para combinarlas en la escena\n    float d = opSmoothUnion(obj1, obj2,.0);\n      //    d = min(obj1, obj2);0\n     // d = obj2;\n    // coloreamos segun el objeto con el que choca el rayo\n    if (d == obj2) objcol = vec3(.0, 0.0, 0.0);\n    if (d == obj1) objcol = vec3(sin(id*5.+iTime)*.5+.5, sin(id*5.+iTime)*.1+.1, 0.0);\n\n    return d*0.2;\n}\n\n\n\n\n\n\n\n\n\n// FUNCION NORMAL\n\nvec3 normal(vec3 p) \n{   \n    vec2 d = vec2(0., det);\n    \n    return normalize(vec3(de(p + d.yxx), de(p + d.xyx), de(p + d.xxy)) - de(p));\n}\n\n// FUNCION SHADE\n\nvec3 shade(vec3 p, vec3 dir) {\n    \n    vec3 lightdir = normalize(vec3(1.5, 1.2, -1.)); \n    \n    // aquí definimos el color del objeto según la variable objcolor seteada en la funcion\n    // de distancia. La guardamos en col antes de llamar a la funcion normal\n    vec3 col = objcol;\n    \n    \n    vec3 n = normal(p);\n    \n    float diff = max(0.2, dot(lightdir, n));\n    \n    vec3 refl = reflect(dir, n);\n    \n    float spec = pow(max(0.2, dot(lightdir, refl)), 5.);\n    \n    float amb = .1;\n    \n    \n    \n\n    return (col*(amb + diff) + spec * .8);\n    \n}\n\n\n\n// FUNCION DE RAYMARCHING\n\nvec3 march(vec3 from, vec3 dir) \n{\n\n    float d, td=0.;\n    vec3 p =vec3(0);\n    vec3 col = vec3(0);\n    \n    for (int i=0; i<maxsteps; i++) \n    {\n        p = from + td * dir;\n\n        d = de(p);\n\n        if (d < det || td > maxdist) break;\n\n        td += d;\n    }\n\n    if (d < det)\n    {\n        p -= det * dir;\n        col = shade(p, dir);\n    }\n    else \n    {\n        // para este background estoy ubicando la posición en el fondo de la escena\n        // from + distancia máxima * dirección del rayo\n        p = from + maxdist * dir;\n        // usamos esta posición para dibujar un fondo\n        // en este caso es un fondo simple usando la función sin\n       // col += vec3(.0);\n    }\n    \n     col = mix(vec3(.0),col, exp(-.0005*td*td));\n    \n    \n    return col;    \n}\n\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = gl_FragCoord.xy/iResolution.xy - .5; \n\n    uv.x *= iResolution.x / iResolution.y; \n    \n    vec3 from = vec3(0., 0., -15.);\n \n    vec3 dir = normalize(vec3(uv, 1.));\n    dir.yz*=rot(.8);\n    \n    from.x-=sin(iTime);\n \n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}