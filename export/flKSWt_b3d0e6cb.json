{"ver":"0.1","info":{"id":"flKSWt","date":"1641520809","viewed":92,"name":"Phong Reflections With Shadows","username":"DexM","description":"Phong reflection model with shadows. No ray marching.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INF (1.0 / 0.0)\n\nstruct Material\n{\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n};\n\n// Rotation happens in the direction specified by right hand rule\n// Axis must be unit vector (normalized)\nvec3 rotate(vec3 vec, vec3 rotationAxis, float rotationAngle)\n{\n    rotationAngle /= 2.0;\n    vec4 q = vec4(rotationAxis * sin(rotationAngle), cos(rotationAngle));\n\n    mat4 p = mat4(\n         0,      vec.z, -vec.y,  vec.x, // Column 1\n        -vec.z,  0,      vec.x,  vec.y, // Column 2\n         vec.y, -vec.x,  0,      vec.z, // Column 3\n        -vec.x, -vec.y, -vec.z,  0);    // Column 4\n\n    mat4 invQ = mat4(\n         q.w, -q.z,  q.y, -q.x,  // Column 1\n         q.z,  q.w, -q.x, -q.y,  // Column 2\n        -q.y,  q.x,  q.w, -q.z,  // Column 3\n         q.x,  q.y,  q.z,  q.w); // Column 4\n    \n    return (q * p * invQ).xyz;\n}\n\n// Get a rotation axis if you want to turn source vector in the direction of destination\nvec3 rotationAxisForVectors(vec3 source, vec3 destination)\n{\n    return normalize(cross(source, destination));\n}\n\nfloat angleBetweenVectors(vec3 a, vec3 b)\n{\n    return acos(dot(a, b) / length(a) / length(b));\n}\n\n// Calculate distance to an infinite plane\n// Plane is one sided, normal vector specifies outside\nfloat planeDistance(vec3 rayOrigin, vec3 rayDirection, vec3 planeOrigin, vec3 planeNormal)\n{\n    // Check whether ray origin is under the plane\n    float side = sign(dot(rayOrigin - planeOrigin, planeNormal));\n\n    // Calculate distance to the plane\n    float depth = side * dot(planeOrigin - rayOrigin, planeNormal) / dot(rayDirection, planeNormal);\n    \n    // Check whether intersection point is behind ray origin\n    if (depth < 0.0)\n        return side * INF;\n\n    return depth;\n}\n\n// Calculate distance to a sphere\nfloat sphereDistance(vec3 rayOrigin, vec3 rayDirection, vec3 sphereOrigin, float sphereRadius)\n{\n    // Part of the formula we need to get square root of\n    vec3 rso = rayOrigin - sphereOrigin;\n    float rsoLen = length(rso);\n    float rdrsoDot = dot(rayDirection, rso);\n    float d = rdrsoDot * rdrsoDot - rsoLen * rsoLen + sphereRadius * sphereRadius;\n    \n    if (d < 0.0)\n        return INF; // Ray does not intersect sphere\n\n    // Find intersection distances\n    float sq = sqrt(d);\n    vec2 dist = vec2(sq, -sq) - rdrsoDot;\n\n    float minDist = min(dist.x, dist.y);\n    float maxDist = max(dist.x, dist.y);\n\n    // Check whether both intersection points are behind ray origin\n    if (maxDist < 0.0)\n        return INF;\n    \n    // Check whether we are inside the sphere\n    if (minDist < 0.0)\n        return -maxDist;\n    \n    return minDist;\n}\n\n// Calculate pixel color based on phong reflection model\nvec3 singleLightPhong(vec3 normal, vec3 cameraDirection, vec3 lightDirection, Material material)\n{\n    float diffuseDot = dot(lightDirection, normal);\n    material.diffuseColor *= max(diffuseDot, 0.0);\n    \n    vec3 reflectionDirection = reflect(-lightDirection, normal);\n    float specularDot = dot(reflectionDirection, cameraDirection);\n    material.specularColor *= pow(specularDot, material.shininess) * step(0.0, specularDot);\n\n    return material.ambientColor + material.diffuseColor + material.specularColor;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // UV has origin at the center of the screen and farthest edge of the canvas is at distance 1\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / max(iResolution.x, iResolution.y);\n\n    // Set up camera\n    const vec3 cameraOrigin = vec3(0);\n    const vec3 cameraDirection = vec3(0, 0, -1);\n    const float cameraFieldOfView = radians(45.0) / 2.0; // Divide by 2, because our UV go from -1 to 1\n\n    // Set up ray to render view\n    float rayAngle = cameraFieldOfView * length(uv);\n    vec3 rayRotationAxis = rotationAxisForVectors(cameraDirection, vec3(uv, 0));\n    vec3 ray = rotate(cameraDirection, rayRotationAxis, rayAngle);\n\n    // Scene setup\n    const vec3 planeOrigin = vec3(0, -1, 0);\n    const vec3 planeNormal = vec3(0, 1, 0);\n\n    const float sphereRadius = 1.0;\n    const vec3 sphereOrigin1 = vec3(-1.1, 0, -7);\n    const vec3 sphereOrigin2 = vec3(1.1, 0, -7);\n\n    const vec3 pointLightInitialPosition = vec3(0, 0, 5);\n    const vec3 pointLightOrbitCenterTranspose = vec3(0, 5, -7);\n    const vec3 pointLightOrbitAxis = normalize(vec3(0.1, 1, 0));\n\n    const float pointLightRadius = 0.3;\n    const int shadowCatcherSamples = 32; // How many rays to cast to check for shadow strength\n\n    const Material backgroundMaterial = Material(vec3(0.07), vec3(0), vec3(0), 0.0);\n    const Material planeMaterial = Material(vec3(0.07), vec3(0.1, 0.9, 0.1), vec3(0), 0.0);\n    const Material sphereMaterial1 = Material(vec3(0.2, 0.07, 0.07), vec3(0.8, 0, 0), vec3(0.2, 0.4, 0.4), 5.0);\n    const Material sphereMaterial2 = Material(vec3(0.07, 0.07, 0.3), vec3(0, 0, 0.7), vec3(1), 20.0);\n    \n    const float ambientOcclusionStrength = 0.6;\n\n    // Calculate depth, normal and material\n    float depth = INF;\n    vec3 normal = -ray;\n    Material material = backgroundMaterial;\n    float ambientOcclusion = 0.0;\n\n    float newDepth;\n    \n    newDepth = planeDistance(cameraOrigin, ray, planeOrigin, planeNormal);\n    if (newDepth < depth)\n    {\n        depth = newDepth;\n        normal = planeNormal;\n        material = planeMaterial;\n    }\n    \n    newDepth = sphereDistance(cameraOrigin, ray, sphereOrigin1, sphereRadius);\n    if (newDepth < depth)\n    {\n        depth = newDepth;\n        normal = normalize(cameraOrigin + ray * depth - sphereOrigin1);\n        material = sphereMaterial1;\n        ambientOcclusion = smoothstep(0.6, 1.0, dot(normal, vec3(0, -1, 0)));\n    }\n    \n    newDepth = sphereDistance(cameraOrigin, ray, sphereOrigin2, sphereRadius);\n    if (newDepth < depth)\n    {\n        depth = newDepth;\n        normal = normalize(cameraOrigin + ray * depth - sphereOrigin2);\n        material = sphereMaterial2;\n        ambientOcclusion = smoothstep(0.6, 1.0, dot(normal, vec3(0, -1, 0)));\n    }\n    \n    // Calculate lighting\n    vec3 surfacePoint = cameraOrigin + ray * depth;\n    vec3 pointLightPosition = rotate(pointLightInitialPosition, pointLightOrbitAxis, iTime) + pointLightOrbitCenterTranspose;\n    vec3 lightDirection;\n    if (isinf(depth))\n        lightDirection = -ray;\n    else\n        lightDirection = normalize(pointLightPosition - surfacePoint);\n    \n    vec3 color = singleLightPhong(normal, -ray, lightDirection, material);\n    \n    // Add shadow\n    const float shadowCatcherRotationAngle = radians(360.0) / float(shadowCatcherSamples);\n    const float shadowCatcherContribution = 1.0 / float(shadowCatcherSamples);\n    \n    if (!isinf(depth))\n    {\n        surfacePoint += normal * 0.0001; // To avoid surface intersecting with itself at surface point\n        lightDirection = normalize(pointLightPosition - surfacePoint);\n\n        float lightDistance = distance(pointLightPosition, surfacePoint);\n        vec3 shadowCatcherRay = cameraOrigin + vec3(0, pointLightRadius, 0) + cameraDirection * lightDistance;\n        vec3 shadowCatcherDirection = normalize(shadowCatcherRay);\n        float shadowCatcherDistance = length(shadowCatcherRay);\n\n        shadowCatcherDirection = rotate(\n            shadowCatcherDirection,\n            rotationAxisForVectors(cameraDirection, lightDirection),\n            angleBetweenVectors(cameraDirection, lightDirection));\n\n        float shadowStrength = 0.0;\n        for (int i = 0; i < shadowCatcherSamples; i++)\n        {\n            vec3 currentShadowCatcherDirection = rotate(shadowCatcherDirection, lightDirection, shadowCatcherRotationAngle * float(i));\n\n            depth = min(\n                sphereDistance(surfacePoint, currentShadowCatcherDirection, sphereOrigin1, sphereRadius),\n                sphereDistance(surfacePoint, currentShadowCatcherDirection, sphereOrigin2, sphereRadius));\n\n            shadowStrength += shadowCatcherContribution * step(0.0, shadowCatcherDistance - depth);\n        }\n\n        color = mix(color, material.ambientColor, shadowStrength);\n    }\n\n    // Add ambient occlusion\n    color *= 1.0 - ambientOcclusion * ambientOcclusionStrength;\n\n    // Render result\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}