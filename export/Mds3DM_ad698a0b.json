{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"const float dl = .2;\nconst float tanfov = 3.;\nconst float blackHoleDist = 2.;\nconst float blackHoleMass = .1;\t//2M = R = Schwarzschild radius\nconst int maxiter = 30;\n\nconst mat3 viewMatrix = mat3(\n\t0., 0., -1.,\n\t1., 0., 0., \n\t0., -1., 0.);\nconst mat3 viewMatrixInv = mat3(\n\t0., 1., 0.,\n\t0., 0., -1.,\n\t-1., 0., 0.);\n\nvec3 rotate(const vec3 v, float theta, const vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\treturn v * cosTheta + cross(axis, v) * sin(theta) + axis * dot(v, axis) * (1. - cosTheta);\n}\n\nvec4 calcRayAccel(vec4 pos, vec4 vel) {\t\n\t//calculate schwarzschild geodesic acceleration\n\tfloat r = length(pos.xyz);\n\tfloat oneMinus2MOverR = 1. - 2.*blackHoleMass/r;\t\t\t\n\tfloat posDotVel = dot(pos.xyz, vel.xyz);\n\tfloat velDotVel = dot(vel.xyz, vel.xyz);\n\tfloat r2 = r * r;\n\tfloat invR2M = 1. / (r * oneMinus2MOverR);\n\tfloat rMinus2MOverR2 = oneMinus2MOverR / r;\n\tfloat MOverR2 = blackHoleMass / r2;\n\tvec4 accel = vec4(0.);\n\taccel.xyz = -MOverR2 * (rMinus2MOverR2 * pos.xyz * vel.w * vel.w + invR2M * (pos.xyz * velDotVel - 2. * vel.xyz * posDotVel));\n\taccel.w = 2. * MOverR2 * invR2M * posDotVel * vel.w;\n\treturn accel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\t//get screen coords\t\n\tvec2 uv = fragCoord.xy / vec2(iResolution.xy);\n\tuv -= .5;\n\tuv *= tanfov;\n\t\n\t//rotate z- to x+\n\tvec3 uv3 = normalize(viewMatrixInv * vec3(uv, -1.));\n\t\n\t//start us off\n\tvec4 pos = vec4(0.);\n\tvec4 vel = vec4(uv3, 0.);\n\t//offset position\n\tpos.x -= blackHoleDist;\n\t//normalize velocity\n\tfloat r = length(pos.xyz);\n\tvel.w = 1. / (1. - 2. * blackHoleMass / r);\n\t\t\n\tfor (int i = 0; i < maxiter; ++i) {\n\t\t/* Euler integration * /\n\t\tvec4 accel = calcRayAccel(pos, vel);\n\t\tvec4 newpos = pos + vel * dl;\n\t\tvec4 newvel = vel + accel * dl;\n\t\t/**/\n\t\t/* Runge-Kutta 4 integration */\n\t\tvec4 accel1 = calcRayAccel(pos, vel);\n\t\tvec4 vel2 = vel + .5 * dl * accel1;\n\t\tvec4 accel2 = calcRayAccel(pos + .5 * dl * vel, vel2);\n\t\tvec4 vel3 = vel + .5 * dl * accel2;\n\t\tvec4 accel3 = calcRayAccel(pos + .5 * dl * vel2, vel3);\n\t\tvec4 vel4 = vel + dl * accel3;\n\t\tvec4 accel4 = calcRayAccel(pos + dl * vel3, vel4);\n\t\tvec4 newpos = pos + (vel + 2. * vel2 + 2. * vel3 + vel4) * dl / 6.;\n\t\tvec4 newvel = vel + (accel1 + 2. * accel2 + 2. * accel3 + accel4) * dl / 6.;\n\t\t/**/\n\t\t\n\t\tpos = newpos;\n\t\tvel = newvel;\n\t}\n\n\t//rotate x+ to z-\n\tvec3 cubeTexCoord = viewMatrix * vel.xyz;\n\n\t//give texcoords some rotation\n\tcubeTexCoord = rotate(cubeTexCoord, iTime * .2, vec3(0., 1., 0.));\n\t\n\tvec4 color = texture(iChannel0, cubeTexCoord);\n\t\n\t//if we failed to escape ...\n\tr = length(pos.xyz);\n\tif (r < blackHoleMass * 2.) {\n\t\tcolor = vec4(0., 0., 0., 1.);\n\t} else {\n\t//otherwise, shift frequency\n\t\t\n\t\t//lambda = lambda0 * (1 - blackHoleMass / r);\n\t}\n\t\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Mds3DM","date":"1372812531","viewed":997,"name":"Black Hole Raytracer","username":"thenumbernine","description":"relativistic raytracer via null geodesics in Schwarzschild metric around a black hole","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raytrace","blackhole","relativistic"],"hasliked":0,"parentid":"","parentname":""}}