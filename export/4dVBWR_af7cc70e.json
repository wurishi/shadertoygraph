{"ver":"0.1","info":{"id":"4dVBWR","date":"1528316232","viewed":339,"name":"CCT Tint slider","username":"MoltenQwartz","description":"Spectral blackbody spectrum RGB integration coupled with Correlated Color Temperature calculation and displacement along isotherms on the Planckian locus. (http://www.lrc.rpi.edu/programs/nlpip/lightinganswers/lightsources/whatisCCT.asp)","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["blackbody","colortemperature","cct","planckianlocus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// T range K\nconst float Tmin = 1000.0;\nconst float Tmax = 20000.0;\n\n// Tint slider (-1,1)\nconst float DTint = 0.0;\n\n// https://en.wikipedia.org/wiki/Black-body_radiation\nfloat BlackBoddyRadiation(float lambda, float T)\n{\n    // lambda in nm\n    return 1.19104f*pow(10.0f, 19.0f) / pow(lambda, 5.0f) * 1.0f / (exp(1.4387769599838158*pow(10.0,7.0) / (lambda*T)) - 1.0f);\n}\n\n\n// Spectrum to xyz approx function from \"Simple Analytic Approximations to the CIE XYZ Color Matching Functions\"\n// http://jcgt.org/published/0002/02/01/paper.pdf\n//Inputs:  Wavelength in nanometers\nfloat xFit_1931(float wave)\n{\n    float t1 = (wave - 442.0f)*((wave < 442.0f) ? 0.0624f : 0.0374f);\n    float t2 = (wave - 599.8f)*((wave < 599.8f) ? 0.0264f : 0.0323f);\n    float t3 = (wave - 501.1f)*((wave < 501.1f) ? 0.0490f : 0.0382f);\n    return 0.362f*exp(-0.5f*t1*t1) + 1.056f*exp(-0.5f*t2*t2) - 0.065f*exp(-0.5f*t3*t3);\n}\nfloat yFit_1931(float wave)\n{\n    float t1 = (wave - 568.8f)*((wave < 568.8f) ? 0.0213f : 0.0247f);\n    float t2 = (wave - 530.9f)*((wave < 530.9f) ? 0.0613f : 0.0322f);\n    return 0.821f*exp(-0.5f*t1*t1) + 0.286f*exp(-0.5f*t2*t2);\n}\nfloat zFit_1931(float wave)\n{\n    float t1 = (wave - 437.0f)*((wave < 437.0f) ? 0.0845f : 0.0278f);\n    float t2 = (wave - 459.0f)*((wave < 459.0f) ? 0.0385f : 0.0725f);\n\n    return 1.217f*exp(-0.5f*t1*t1) + 0.681f*exp(-0.5f*t2*t2);\n}\n\n// RGB-XYZ Matrix Calculator\n// http://www.russellcottrell.com/photo/matrixCalculator.htm\n// Based on equations found here:\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// And Rec. 2020 values found here:\n// https://en.wikipedia.org/wiki/Rec._2020\n// https://en.wikipedia.org/wiki/Rec._709\n// https://en.wikipedia.org/wiki/SRGB\nvec3 XYZtosRGB(vec3 XYZ)\n{\n    vec3 rgb;\n    rgb.x = XYZ.x *  3.2409699f + XYZ.y * -1.5373832f + XYZ.z * -0.4986108f;\n    rgb.y = XYZ.x * -0.9692436f + XYZ.y *  1.8759675f + XYZ.z *  0.0415551f;\n    rgb.z = XYZ.x *  0.0556301f + XYZ.y * -0.2039770f + XYZ.z *  1.0569715f;\n    \n    return rgb;\n}\n\n\n#define SPECTRAL_SAMPLES 32\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float T = mix(Tmin,Tmax,1.0-uv.x);\n    \n    \n    float lamdaStart = 380.0f;\n    float lamdaEnd = 780.0f;\n\n    float dw = (lamdaEnd - lamdaStart) / float(SPECTRAL_SAMPLES);\n\n    // https://en.wikipedia.org/wiki/CIE_1931_color_space\n    // integrating Illuminant\n    float N = 0.0;\n\n    vec3 XYZIrradiance = vec3(0.0);\n\n    for (int k = 0; k < SPECTRAL_SAMPLES; k++)\n    {\n        float w = lamdaStart + (float(k) + 0.5f)*dw;\n        \n\n        float illuminant = BlackBoddyRadiation(w,T);\n        \n        N += illuminant * yFit_1931(w) * dw;\n        XYZIrradiance.x += illuminant * xFit_1931(w) * dw;\n        XYZIrradiance.y += illuminant * yFit_1931(w) * dw;\n        XYZIrradiance.z += illuminant * zFit_1931(w) * dw;\n    }\n\t//XYZIrradiance /= N;\n    XYZIrradiance /= max(XYZIrradiance.x,max(XYZIrradiance.y,XYZIrradiance.z));\n    \n    // XYZ to xyY\n    float x = XYZIrradiance.x/(XYZIrradiance.x + XYZIrradiance.y + XYZIrradiance.z);\n    float y = XYZIrradiance.y/(XYZIrradiance.x + XYZIrradiance.y + XYZIrradiance.z);\n    float Y = XYZIrradiance.y;\n\n    // https://en.wikipedia.org/wiki/Color_temperature#Correlated_color_temperature\n    // xy to uv\n    float u = 4.0*x/(-2.0*x+12.0*y+3.0);\n    float v = 6.0*y/(-2.0*x-12.0*y+3.0);\n    \n    // slider along illuminant\n    float delta = 0.05;\n    float Duv = clamp(-DTint,-1.0,1.0); // -1,1\n    u += Duv*delta;\n    v += Duv*delta;\n    \n    // uv to xy\n    x = ((1.5*(0.25*u + 1.0*u*v))/(0.5 + 0.25*u + 1.0*v + 1.0*u*v));\n    y = (0.25*v)/(0.5 + 0.25*u + 1.0*v + 1.0*u*v);\n    \n    \n    // xyY to XYZ\n    XYZIrradiance.x = x*Y/y;\n    XYZIrradiance.y = Y;\n    XYZIrradiance.z = (1.0 - x - y)*Y/y;\n    \n    // XYZ to sRGB\n    vec3 RGBIrradiance = XYZtosRGB(XYZIrradiance);\n \t// sRGB\n    float a = 0.05;\n    RGBIrradiance.r = RGBIrradiance.r <= 0.0031308 ? 12.92*RGBIrradiance.r : (1.0+a)*pow(RGBIrradiance.r,1.0/2.4)-a;\n    RGBIrradiance.g = RGBIrradiance.g <= 0.0031308 ? 12.92*RGBIrradiance.g : (1.0+a)*pow(RGBIrradiance.g,1.0/2.4)-a;\n    RGBIrradiance.b = RGBIrradiance.b <= 0.0031308 ? 12.92*RGBIrradiance.b : (1.0+a)*pow(RGBIrradiance.b,1.0/2.4)-a;\n    \n    // Output to screen\n    fragColor = vec4(RGBIrradiance,1.0);\n}","name":"Image","description":"","type":"image"}]}