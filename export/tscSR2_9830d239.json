{"ver":"0.1","info":{"id":"tscSR2","date":"1572356439","viewed":197,"name":"ShaderTober - Tasty","username":"Flopine","description":"A small doodle with inktober's theme \"Tasty\"","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","chocolate","inktober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, Coyhot, Alkama and YX for teaching me\n// Thanks LJ for giving me the love of shadercoding :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI 3.141592\n#define ITER 100.\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 rot (float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = (2.*PI)/rep;\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a,per)-per*0.5;\n    p = vec2(cos(a),sin(a))*l;\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat pour (vec3 p, float rythm, float width)\n{\n    p.xz *= rot(sin(-p.y*rythm+iTime));\n    moda(p.xz, 3.);\n    p.x -= width;\n    return cyl(p.xzy, width*0.5, 10.);\n}\n\nfloat SDF (vec3 p)\n{\n    p.xz *= rot(p.y*0.5+iTime);\n    float ry = 0.5,wi = 0.5;\n    float d = pour(p, ry, wi);\n    for (int i=-2; i<=2; i+=2)\n    {\n        ry += 0.2;\n        wi -= 0.1;\n        for (int j=-2; j<=2; j+=2)\n    \t{\n            vec3 offset = vec3(float(i),0.,float(j));\n            d = smin(d, pour(p+offset, ry, wi), 2.);\n    \t}\n    }\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(vec3( SDF(p+eps.xyy)-SDF(p-eps.xyy),\n                         SDF(p+eps.yxy)-SDF(p-eps.yxy),\n                         SDF(p+eps.yyx)-SDF(p-eps.yyx)\n                         )\n                    );\n}\n\nfloat lighting (vec3 n, vec3 l)\n{return dot(n, normalize(l))*0.5+0.5;}\n\n// courtesy of Alkama\nvec3 pales (vec2 uv)\n{\n  uv *= rot(-iTime*.2);\n  return floor(smoothstep(0.1, 0.2,cos(atan(uv.y, uv.x)*5.)))*vec3(0.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\tvec3 ro = vec3(0.001,0.001,-7.),\n        p = ro,\n        rd = normalize(vec3(uv,1.)),\n        l = vec3(0.,5.,-2.),\n        col = mix(vec3(0.),\n              mix(vec3(0.3,0.25,0.15), vec3(0.8,0.7,0.4), pales(uv)),\n              smoothstep(0.35,1.,abs(uv.x)));\n    \n    float shad = 0.;\n    bool hit = false;\n    \n    for (float i=0.; i<ITER; i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            shad = i/ITER;\n            break;\n        }\n        p += d*rd*0.5;\n    }\n    float t = length(ro-p);\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        col = mix(vec3(0.01,0.005,0.005), vec3(0.05,0.01,0.01), lighting(n,l));\n        col += vec3(0.,0.02,0.05)*(1.-pow(clamp(dot(n,-rd),0.,1.),.2));\n        vec3 h = normalize(l-rd);\n        col += pow(max(dot(h,n) ,0.), 25.)*vec3(0.2,0.25,0.25);\n        col *= vec3(1.-shad);\n    }\n    // Output to screen\n    fragColor = vec4(pow(col,vec3(0.4545)),1.0);\n}","name":"Image","description":"","type":"image"}]}