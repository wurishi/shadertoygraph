{"ver":"0.1","info":{"id":"4Xc3Wj","date":"1717017990","viewed":47,"name":"Color loop","username":"francesco_vmk","description":"Really slow\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"lXc3WS","parentname":"Rotations and deform raymarch"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Ray march 0.2 with transparance\" by francesco_vmk. https://shadertoy.com/view/cdtfD8\n// 2023-11-21 17:12:12\n\n//CONSTANTS\nconst float MAX_DIST = 25.0;\nconst float MIN_DIST = 0.01;\nconst float pi = 3.141592653589793;\n//structs\n\nstruct Point{\n    float dist;\n    vec4 color;\n    int shapeId;\n};\n\n//random\n\n\nfloat rand(float i, float seed){return fract(sin(i) * seed);}\n\nvec4 colors[3]= vec4[3](\n    vec4(0.000,1.000,0.000,1.0), \n    vec4(1.000,0.000,0.000,1.0), \n    vec4(0.000,0.000,1.000,1.0)\n);\n    \nvec4 randomColor(float seed, float i)\n{\n    int arrayLength = colors.length();\n    int randomIndex = int(rand(i, seed) * float(arrayLength));\n    return colors[randomIndex];\n}\n\n\n\n//shapes\n\nPoint sdfSphere(vec3 p, vec3 center, float radius, vec4 color, int currentId)\n{\n    Point res;\n    res.color = color;\n    res.dist = length(p - center) - radius;\n    res.shapeId = currentId;\n    return res;\n}\n\nPoint sdfPlane( vec3 p, vec3 n, float h, vec4 color, int currentId)\n{\n  // n must be normalized\n  return Point(dot(p,n) + h, color, currentId);\n}\n\n\nPoint sdfBox( vec3 p, vec3 b, vec3 center, vec4 color, vec3 base1, vec3 base2, vec3 base3, vec3 rotation, vec3 pivot, vec3 deform1, vec3 deform2, vec3 deform3, vec3 deformPivot, int currentId)\n{\n  \n  \n  p = p - center;//center\n  \n    \n  //change base\n  p = p[0] * base1 + p[1] * base2 + p[2] * base3;\n  \n  //rotation matrix\n    mat2 rotX = mat2(cos(rotation.x), -sin(rotation.x),\n                     sin(rotation.x),  cos(rotation.x));\n    vec2 yz = rotX * p.yz;\n    p.y = yz.x;\n    p.z = yz.y;\n\n    mat2 rotY = mat2(cos(rotation.y), sin(rotation.y),\n                    -sin(rotation.y), cos(rotation.y));\n    vec2 xz = rotY * p.xz;\n    p.x = xz.x;\n    p.z = xz.y;\n\n    mat2 rotZ = mat2(cos(rotation.z), -sin(rotation.z),\n                     sin(rotation.z),  cos(rotation.z));\n    vec2 xy = rotZ * p.xy;\n    p.x = xy.x;\n    p.y = xy.y;\n  \n  \n  \n\n  \n  p += pivot;//apply pivot\n  \n  \n  vec3 q = abs(p) - b;\n  q = q[0] * deform1 + q[1] * deform2 + q[2] * deform3;\n  q += deformPivot;\n  \n  return Point(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), color, currentId);\n}\n\n//functions\n\nPoint opSmoothUnion(Point d1, Point d2, float k){\n\n    float h = clamp(0.5 + 0.5 * (d2.dist - d1.dist) / k, 0.0, 1.0);\n    \n    vec4 color = vec4(mix(d2.color, d1.color, h));\n    \n    int shapeId = h > 0.5 ? d1.shapeId : d2.shapeId;\n    \n    return Point(mix(d2.dist, d1.dist, h) - k * h * (1.0-h), color, shapeId);\n}\n\n\nconst float radius = 3.;\nconst float elementsN = 10.;\nconst float waves = 1.;\n\nPoint map(vec3 p, int jumpShape){\n    \n    int shapeIndex = 1;\n    \n    Point m = sdfPlane(p, \n        vec3(0.0, 1.0, 0.0), 0.8, vec4(1.0),\n        shapeIndex\n    );\n    \n    shapeIndex++;\n    \n    Point obj;\n    \n    \n    \n    for(float i = 0.; i < elementsN; i++){\n    \n        if(shapeIndex != jumpShape){\n    \n            float angle = i * pi * 2. / elementsN;\n            angle += iTime;\n            obj = sdfBox(p, \n            vec3(0.5, 0.1, 0.3), \n\n            vec3(sin(angle) * radius, -sin(iTime * 2.5 + angle * waves) + 1.5, cos(angle) * radius),\n\n            vec4(cos(angle), sin(angle) , -0.5,0.6),\n\n            //base\n            vec3(1.0, 0.0, 0.0),\n            vec3(0.0, 1.0, 0.0),\n            vec3(0.0, 0.0, 1.0),\n\n            //rotate\n            vec3(1.55, 0., -angle + 1.6), //rotation\n            vec3(0., 0., 0.), //pivot\n\n            //deform\n            vec3(0.1, 0., -0.1),\n            vec3(0.0, 0.1, 0.0),\n            vec3(0.1, 0., -0.1),\n\n            vec3(0.0, 0.0, 0.0), //deformPivot\n\n            shapeIndex\n            );\n\n\n            if(obj.dist <= m.dist){\n                m = Point(obj.dist, obj.color, obj.shapeId);\n            }\n        }\n        \n        shapeIndex++;\n\n    }\n    \n \n    if(shapeIndex != jumpShape){\n    \n        float angle = (iTime * 3.5) * pi * 2. / elementsN;\n        angle += iTime;\n        angle = -angle;\n\n        obj = sdfBox(p, \n        vec3(0.3, 0.3, 0.3), \n\n        vec3(sin(angle) * radius, -sin(iTime * 2.5 + angle * waves) + 1.5, cos(angle) * radius),\n\n        vec4(cos(angle), sin(angle) , -0.5,0.7),\n\n        //base\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0),\n\n        //rotate\n        vec3(1.55, 0., -angle + 1.6), //rotation\n        vec3(0., 0., 0.), //pivot\n\n        //deform\n        vec3(0.1, 0.1, 0.1),\n        vec3(0.1, 0.1, 0.1),\n        vec3(0.1, 0.1, 0.1),\n\n        vec3(0.05, 0.05, 0.05), //deformPivot\n\n        shapeIndex\n        );\n    \n        m = opSmoothUnion(obj, m, 0.08);\n    }\n    shapeIndex++;\n    \n\n   \n    \n   return m;\n}\n\nvec3 getNormal(vec3 p){\n    vec2 e = vec2(0.0001, -0.0001);\n    int j = 0;\n    return normalize(\n          e.xxx * map(p+e.xxx, j ).dist\n        + e.xyy * map(p+e.xyy, j).dist\n        + e.yxy * map(p+e.yxy, j).dist\n        + e.yyx * map(p+e.yyx, j).dist\n            );\n}\n\nPoint rayMarch(vec3 ro, vec3 rd, float maxDist){\n\n    \n    int jShapes;\n    \n    Point p = map(ro, jShapes);\n    float dist = p.dist;\n    Point oldP = Point(MAX_DIST, vec4(0.706,0.992,0.996,1.0), -1);\n    \n    int i = 0;\n    \n    \n    while(dist < maxDist && i < 200){\n      i++;\n      p = map(ro + rd * dist, jShapes);\n      if(p.dist <= MIN_DIST){\n          if(p.color.w >= 1.0){\n              if(oldP.shapeId < 0){\n                  oldP.dist = dist;\n                  oldP.color = p.color;\n              }else{\n                  p.color = mix(p.color, oldP.color, oldP.color.w);\n                  oldP.color = p.color;\n              }\n              \n              break;\n          }else{\n              p.color = mix(oldP.color, p.color, p.color.w);\n              oldP.color = p.color;\n              if(oldP.dist >= MAX_DIST){\n                  oldP.dist = dist;\n                  \n                  oldP.shapeId = p.shapeId;\n              }\n              \n             jShapes = p.shapeId;\n          }\n\n      }\n      \n      dist += p.dist;\n    }\n    \n    \n    return oldP;\n\n\n}\n\n\n\nPoint rayMarchShadow(vec3 ro, vec3 rd, float maxDist){\n\n    float t = 0.0;\n    float minT = maxDist;\n    for( int i=0; i<256 && t<maxDist; i++ )\n    {\n        Point h = map(ro + rd*t, 0);\n        if( h.dist<0.001 && t > 0.7)\n            return Point(t, h.color, h.shapeId);\n        t += h.dist;\n    }\n    return Point(-1.0, vec4(0.706,0.992,0.996,1.0), -1);\n\n\n}\n\nvoid camera(vec2 uv,out vec3 ro, out vec3 rd){\n    //camera from https://www.shadertoy.com/view/XsXXDB\n\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    float hd = -m.x * 14.0 + 3.14159;\n    float elv = m.y * 3.14159 * 0.4 - 3.14159 * 0.25;\n    ro = vec3(sin(hd) * cos(elv), sin(elv), cos(hd) * cos(elv));\n    ro = ro * 8.0 + vec3(0.0, 6.0, 0.0);\n    \n\n    // camera tx\n    vec3 cw = normalize( ta-ro );\n    vec3 cp = vec3( 0.0, 1.0, 0.0 );\n    vec3 cu = normalize( cross(cw,cp) );\n    vec3 cv = normalize( cross(cu,cw) );\n    rd = normalize( uv.x*cu + uv.y*cv + 2.5*cw );\n}\n\nvec3 render(vec2 uv){\n    \n\n    vec3 ro;\n    vec3 rd;\n    vec3 color;\n    \n    camera(uv, ro, rd);\n    \n    Point p = rayMarch(ro, rd, MAX_DIST);\n    \n    \n    if (p.dist < MAX_DIST)\n    {\n        //color = vec3(1.0);\n        \n        //normals\n        vec3 pos = ro + rd * (p.dist); //get point wher you need to calculate the normals\n        vec4 baseColor = p.color;\n        vec3 normal = getNormal(pos);\n        \n        \n        //lighting\n        \n        //ambient\n        vec3 ambient = vec3(1.000,1.000,1.000);\n        \n        //diffuse\n        vec3 lightColor = vec3(1.000,1.000,1.000);\n        float lightWidth = 0.1;\n        vec3 lightSource = vec3(3.0, 2.5, -2.5);\n        float diffuseStrength = max(0.0, dot(normalize(lightSource),normal));\n        \n        vec3 diffuse = lightColor * diffuseStrength;\n        \n        //specular\n        lightColor = vec3(1.000,1.000,1.000);\n        \n        vec3 viewSource = normalize(ro);\n        vec3 reflectSource = normalize(reflect(-lightSource,normal));\n        float specularStrength = max(0.0, dot(viewSource, reflectSource));\n        specularStrength = pow(specularStrength, 64.0);\n        vec3 specular = specularStrength * lightColor;\n        \n        vec3 lighting = ambient * 0.4 + diffuse * 1.00 + specular * 0.6;\n        \n        color = baseColor.rgb * lighting;\n        \n        //shadows\n        vec3 lightDirection = normalize(lightSource);\n        float distToLightSource = distance(lightSource, pos);\n        ro = pos;\n        rd = lightDirection;\n        Point pointShadow = rayMarchShadow(ro, rd, distToLightSource);\n        \n         if(pointShadow.dist > 0.){\n         \n             float dBlocker = (distToLightSource - pointShadow.dist);\n             float penumbra = ((distToLightSource - dBlocker) * lightWidth)/dBlocker;\n             \n             penumbra = clamp(penumbra, 0.0, 0.4);\n             \n             color = mix(pointShadow.color.rgb * 0.6, color * penumbra,  pointShadow.color[3]).rgb;\n             //color *= penumbra;\n             \n         }\n        \n        \n        \n        //gamma correction\n        color = pow(color, vec3(1.0 / 2.2));\n        \n        // Tone mapping\n        //color = 1.-exp(-2.*color);\n        \n    }\n    else{\n        color = p.color.rgb;\n    }\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate aspect ratio\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - 1.0;\n\n    // Correct for aspect ratio\n    uv.x *= aspectRatio;\n\n    vec3 color = vec3(0.0);\n\n    color = render(uv);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}