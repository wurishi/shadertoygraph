{"ver":"0.1","info":{"id":"lsG3RG","date":"1584302411","viewed":125,"name":"Diamond Cubic","username":"kqyrt","description":"diamond cubic crystal structure: https://en.wikipedia.org/wiki/Diamond_cubic","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.01;\nconst float clip_far = 1000.0;\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nfloat sdSphere(vec3 pos, float r) {\n\treturn length(pos) - r;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n    \n}\n\nvec3 RotateX(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n\tfloat cos = cos(rad);\n\tfloat sin = sin(rad);\n\treturn vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nfloat base_unit(vec3 pos, float r) {\n    vec3 pm = vec3(.0, .0, .0);\n    vec3 p1 = vec3(-r, -r, -r);\n    vec3 p2 = vec3(r, -r, r);\n    float rr = .1 * r;\n    vec3 pos1 = pos;\n    if (pos1.x + pos1.y > 0.0) {\n        pos1.xy = -pos1.xy;\n    }\n    float d1 = sdCapsule(pos1, pm, p1, rr);\n    \n    vec3 pos2 = pos;\n    if (pos2.x < pos2.y) {\n        pos2.xy = -pos2.xy;\n    }\n    float d2 = sdCapsule(pos2, pm, p2, rr);\n\n    float ret = 1000.0;\n    ret = min(d1, ret);\n    ret = min(d2, ret);\n    return ret;\n}\n\nvec3 diag_mirror(vec3 pos, float r) {\n    if (pos.x > r && pos.y > r) {\n        pos.xy -= 2.0 * r;\n    } else if (pos.x > r && pos.z > r ) {\n        pos.xz -= 2.0 * r;\n    } else if (pos.y > r && pos.z > r) {\n        pos.yz -= 2.0 * r;\n    }\n    return pos;\n}\n\nfloat diamond_cube(vec3 pos, float r) {\n    float ret = 1000.0;\n    pos += vec3(r, r, r);\n    pos = diag_mirror(pos, r);\n    float d0 = base_unit(pos, r);\n    ret = min(d0, ret);\n    ret = min(d0, sdSphere(pos, r * 0.3));\n    return ret;\n}\n\nfloat mod1(float x, float r, float l, float t) {\n    if (abs(x) < l * r) {\n       return mod(x + r * t, r * 4.) - r * t;\n    }\n    return x;\n}\n\nvec3 mod_xyz(vec3 pos, float r, float l, float t) {\n    pos.x = mod1(pos.x, r, l, t);\n    pos.y = mod1(pos.y, r, l, t);\n    pos.z = mod1(pos.z, r, l, t);\n    return pos;\n}\n\nfloat bond(vec3 pos, float r) {\n    if (abs(pos.x) < 4.0 * r ) {\n      pos.x = mod(pos.x, r * 4.0) - r * 2.0;\n    }\n    if (abs(pos.y) < 4.0 * r ) {\n      pos.y = mod(pos.y, r * 4.0) - r * 2.0;\n    }\n    if (abs(pos.z) < 4.0 * r ) {\n      pos.z = mod(pos.z, r * 4.0) - r * 2.0;\n    }\n    return diamond_cube(pos, r);\n}\n\nfloat atom1(vec3 pos, float r) {    \n    float dr = r * 0.3;\n    pos = mod_xyz(pos, r, 6., 1.);\n    return sdSphere(pos, dr);\n}\n\nfloat atom2(vec3 pos, float r) {\n    float dr = r * 0.3;\n    pos = mod_xyz(pos, r, 5.5, 1.);\n    pos = diag_mirror(pos, r);\n    return sdSphere(pos, dr);\n}\n\nfloat dist_field(vec3 pos) {\n    float r = 0.08;\n    float ret = 10000.;\n    ret = min(ret, bond(pos, r));\n    ret = min(ret, atom1(pos, r));\n    ret = min(ret, atom2(pos, r));\n    return ret;\n}\n\nvec2 ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n    float min_dist = 1000.0;\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n        min_dist = min(dist, min_dist);\n\t\tif ( dist < stop_threshold ) {\n\t\t\tbreak;\n\t\t}\n\t\tdepth += dist * 0.3;\n\t\tif ( depth >= end) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec2(depth, min_dist);\n}\n\nvec3 shading(vec3 v, vec3 n, vec3 eye) {\n\tvec3 final = vec3(0.);\n\n\tvec3 ev = normalize(v - eye);\n    vec3 ref = reflect(ev, n);\n    vec3 reftex = texture(iChannel0, ref).xyz;\n    final += reftex * vec3(1., 1., 1.);\n\n    return final;\n}\n\nvec3 gradient(vec3 pos) {\n\tconst vec3 dx = vec3(grad_step, 0.0, 0.0);\n\tconst vec3 dy = vec3(0.0, grad_step, 0.0);\n\tconst vec3 dz = vec3(0.0, 0.0, grad_step);\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field(pos + dx) - dist_field(pos - dx),\n\t\t\tdist_field(pos + dy) - dist_field(pos - dy),\n\t\t\tdist_field(pos + dz) - dist_field(pos - dz)\t\t\t\n\t\t)\n\t);\n}\n\nvec3 ray_dir(float fov, vec2 size, vec2 pos) {\n\tvec2 xy = pos - size * 0.5;\n\tfloat cot_half_fov = tan((90.0 - fov * 0.5) * DEG_TO_RAD);\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\treturn normalize(vec3(xy, -z));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 eye = vec3(0.0, 0.0, 1.3);\n\tvec3 dir = ray_dir(45.0, iResolution.xy, fragCoord.xy);\n    float rotate_x = .0;\n    float rotate_y = .0;\n    \n    if (iMouse.z > .0) {\n      rotate_x = - (iMouse.y / iResolution.y - 0.5) * PI;\n      rotate_y = iMouse.x / iResolution.x * PI;\n    } else {\n      rotate_x = iTime / 3.0;\n      rotate_y = iTime / 3.0;\n    }\n    dir = RotateX(dir,  rotate_x);\n    dir = RotateY(dir,  rotate_y);\n    eye = RotateX(eye,  rotate_x);\n    eye = RotateY(eye,  rotate_y);\n\tfloat depth = ray_marching(eye, dir, 0.0, clip_far).x;\n\tif (depth >= clip_far) {\n\t\tfragColor = texture(iChannel0, dir);\n        return;\n\t}\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient(pos);\n\tfragColor = vec4(shading(pos, n, eye), 1.0);\n}","name":"Image","description":"","type":"image"}]}