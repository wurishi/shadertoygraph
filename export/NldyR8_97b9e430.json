{"ver":"0.1","info":{"id":"NldyR8","date":"1659260916","viewed":98,"name":"normal quantization test","username":"JuanDeager","description":"modify BITS at the top to change the number of bits in the normals representation","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","normal","quantization"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BITS 8\n\n#define EPSILON (1e-4)\n\nfloat sdSphere(vec3 pos, vec3 spherePos, float sphereRadius)\n{\n    return distance(pos, spherePos) - sphereRadius;\n}\n\nbool epsilonEquals(float a, float b, float e)\n{\n    return abs(a - b) < e;\n}\n\nfloat sceneSDF(vec3 p)\n{\n    return sdSphere(p, vec3(0, 0, -0.7), 0.5);\n}\n\nvec3 getNormal(vec3 pos, float origDist)\n{\n    float xDiff = sceneSDF(pos + vec3(EPSILON, 0, 0));\n    float yDiff = sceneSDF(pos + vec3(0, EPSILON, 0));\n    float zDiff = sceneSDF(pos + vec3(0, 0, EPSILON));\n    return normalize(vec3(xDiff, yDiff, zDiff) - origDist);\n}\n\nstruct RayHit\n{\n    float t;\n    vec3 normal;\n};\n\nRayHit rayMarch(vec3 origin, vec3 direction)\n{\n    RayHit hit;\n    hit.t = -1.0;\n    \n    vec3 curPos = origin;\n    float nextDist = 0.0;\n    for (int i = 0; i < 250; i++)\n    {\n        curPos += nextDist * direction;\n        nextDist = sceneSDF(curPos);\n        \n        if (nextDist < EPSILON)\n        {\n            hit.t = distance(origin, curPos);\n            hit.normal = getNormal(curPos, nextDist);\n            break;\n        }\n    }\n    \n    return hit;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    float aspect = iResolution.y / iResolution.x;\n    uv.y *= aspect;\n    \n    vec3 origin = vec3(sin(iTime)/15., 0., 0.00);\n    //vec3 origin = vec3(0.);\n    vec3 dir = normalize(vec3(uv, -1.0));\n\n    RayHit hit = rayMarch(origin, dir);\n    \n    vec3 color = vec3(0.0);\n    color = dir * .5 + .5;\n    if (hit.t >= 0.0)\n    {\n        vec3 hitP = origin + dir * hit.t;\n        \n#if BITS < 24\n        ivec3 inorm = ivec3(hit.normal * float((1 << BITS) - 1));\n        hit.normal = vec3(inorm) / float((1 << BITS) - 1);\n#endif\n        \n        hit.normal = normalize(hit.normal);\n        vec3 refldir = reflect(dir, hit.normal);\n        color = texture(iChannel0, refldir).rgb;\n    }\n    else // sky hit\n    {\n        vec3 horizon = vec3(.4, .3, .4);\n        vec3 sky = vec3(.2, .5, .8);\n        color = mix(horizon, sky, smoothstep(0., .1, dir.y));\n    }\n    \n    // gamma correct output\n    fragColor = vec4(pow(color, vec3(1./1.0)), 1.0);\n}","name":"Image","description":"","type":"image"}]}