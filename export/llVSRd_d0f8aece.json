{"ver":"0.1","info":{"id":"llVSRd","date":"1485843975","viewed":96,"name":"GR - Rotating Noise Shape","username":"bradleygriffith","description":"Rotatable noise wave. Adjustment variables in comments.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["noise","wave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n\n//bool isinf(float val) {\n//    return (val != 0.0 && val * 2.0 == val) ? true : false;\n//}\n\n// Fix a floating point number to two decimal places\nfloat toFixedTwo(float f) {\n    return float(int(f * 100.0)) / 100.0;\n}\n\n// Taken from http://thebookofshaders.com/\nfloat rand (in float _x) {\n    return fract(sin(_x)*1e4);\n}\n\n// Taken from http://thebookofshaders.com/\nfloat noise (in float _x) {\n    float i = floor(_x);\n    float f = fract(_x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\n// Returns the slope of a line given the degrees of the angle on which that line is rotated;\nfloat slopeForDegrees(float deg) {\n    // Ensure degrees stay withing 0.0 - 360.0\n    deg = mod(deg, 360.0);\n    \n    float radians = deg * (PI / 180.0);\n\n    return tan(radians);\n}\n\n// Given x, a slope, and another point, find y for x.\nfloat yForXOnSlope(float x, float slope, vec2 p2) {\n    return -1.0 * ((slope * (p2.x - x)) - p2.y);\n}\n\n// Given y, a slope, and another point, find x for y.\nfloat xForYOnSlope(float y, float slope, vec2 p2) {\n    return ((y - p2.y) + (slope * p2.x)) / slope;\n}\n\n// Returns slope adjusted for screen ratio.\nfloat normalizedSlope(float slope) {\n    vec2 p = vec2(1.0) / iResolution.xy;\n    return ((slope * 100.0) / p.x) / (100.0 / p.x);\n}\n\n// Returns offsets (+/-) for any coordinate at distance given slope.\n//   Note: This function does not normalize distance.\n//   Note: This function does not adjust slope for screen ratio.\nvec2 offsetsForCoordAtDistanceOnSlope(float d, float slope) {\n    return vec2(\n        (d * cos(atan(slope))),\n        (d * sin(atan(slope)))\n    );\n}\n// Returns a boolean designating whether or not an infinite line intersects with an infinite line, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineIntersection (out vec2 intersect, in vec2 p1, in float m1, in vec2 p2, in float m2) {\n    // See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n    //      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n    bool isIntersecting = false;\n\n    float dx = 1.0;\n    float dy = m1;\n\n    float dxx = 1.0;\n    float dyy = m2;\n\n    float denominator = ((dxx * dy) - (dyy * dx));\n    if (denominator == 0.0) {\n        // Lines are parallel\n        return isIntersecting;\n    }\n    \n    if (isinf(dy)) {\n        float y = yForXOnSlope(p1.x, m2, p2);\n        isIntersecting = true;\n        intersect = vec2(p1.x, y);\n        return isIntersecting;\n    }\n\n    if (isinf(dyy)) {\n        float y = yForXOnSlope(p2.x, m1, p1);\n        isIntersecting = true;\n        intersect = vec2(p2.x, y);\n        return isIntersecting;\n    }\n\n    float u = ((dx * (p2.y - p1.y)) + (dy * (p1.x - p2.x))) / denominator;\n\n    isIntersecting = true;\n    intersect = p2 + (u * vec2(dxx, dyy));\n\n    return isIntersecting;\n}\n\n// Returns a boolean designating whether or not an infinite line intersects with a line segment, and sets an `out` variable for the intersection point if it is found.\n//   Note: This function does not adjust slope for screen ratio.\nbool lineLineSegmentIntersection (out vec2 intersect, in vec2 point, in float m, in vec2 pA, in vec2 pB) {\n    // See: http://gamedev.stackexchange.com/questions/44720/line-intersection-from-parametric-equation\n    //      http://stackoverflow.com/questions/41687083/formula-to-determine-if-an-infinite-line-and-a-line-segment-intersect/41687904#41687904\n\n    bool isIntersecting = false;\n\n    float dx = 1.0;\n    float dy = m;\n\n    float dxx = pB.x - pA.x;\n    float dyy = pB.y - pA.y;\n\n    float denominator = ((dxx * dy) - (dyy * dx));\n    if (denominator == 0.0 || (isinf(dyy / dxx) && isinf(dy))) {\n        // Lines are parallel\n        return isIntersecting;\n    }\n\n    if (isinf(dy)) {\n        float m2 = dyy / dxx;\n        float y = yForXOnSlope(point.x, m2, pB);\n        isIntersecting = true;\n        intersect = vec2(point.x, y);\n        return isIntersecting;\n    }\n\n    float u = ((dx * (pA.y - point.y)) + (dy * (point.x - pA.x))) / denominator;\n\n    if (u >= 0.0 && u <= 1.0) {\n        // Intersection occured on line segment\n        isIntersecting = true;\n        intersect = pA + (u * vec2(dxx, dyy));\n    }\n\n    return isIntersecting;\n}\n// Dev Note: Terrible code. Needs refactor. Just trying to find \n//   which two edges of the rect the intersections occur at.\nvoid intersectsOnRectForLine(out vec2 iA, out vec2 iB, in vec2 rMinXY, in vec2 rMaxXY, in vec2 point, in float slope) {\n    bool firstIntersectFound = false;\n\n    vec2 intersectA = vec2(0.0);\n    vec2 intersectB = vec2(0.0);\n    vec2 intersectC = vec2(0.0);\n    vec2 intersectD = vec2(0.0);\n\n    bool intersectsLeft = lineLineSegmentIntersection(intersectA, point, slope, rMinXY, vec2(rMinXY.x, rMaxXY.y));\n    bool intersectsTop = lineLineSegmentIntersection(intersectB, point, slope, vec2(rMinXY.x, rMaxXY.y), rMaxXY);\n    bool intersectsRight = lineLineSegmentIntersection(intersectC, point, slope, rMaxXY, vec2(rMaxXY.x, rMinXY.y));\n    bool intersectsBottom = lineLineSegmentIntersection(intersectD, point, slope, rMinXY, vec2(rMaxXY.x, rMinXY.y));\n\n    if (intersectsLeft) {\n        iA = intersectA;\n        firstIntersectFound = true;\n    }\n    \n    if (intersectsTop) {\n        if (firstIntersectFound) {\n            iB = intersectB;\n        }\n        else {\n            iA = intersectB;\n            firstIntersectFound = true;\n        }\n    }\n    \n    if (intersectsRight) {\n        if (firstIntersectFound) {\n            iB = intersectC;\n        }\n        else {\n            iA = intersectC;\n            firstIntersectFound = true;\n        }\n    }\n    \n    if (intersectsBottom) {\n        if (firstIntersectFound) {\n            iB = intersectD;\n        }\n        else {\n            iA = intersectD;\n        }\n    }\n}\n\nfloat isWave(vec2 uv, vec2 centerUv, float deg, float width, float smoothing, float amplitude, float volatility) {\n    \n    // Setup\n    // -------------------------------\n    \n    // Dev Note: I've seen some strange artifacting when the input degrees have\n    //   a high number of decimal places. Fixing degrees to a max of two decimal places\n    //   fixes this bug. Not sure that it's the full solution but the problem is mitigated.\n    deg = toFixedTwo(deg);\n    \n    float halfWidth = width / 2.0;\n    float slope = normalizedSlope(slopeForDegrees(deg));\n    float perpendicularDeg = mod(deg + 90.0, 360.0); // Offset angle by 90.0, but keep it from exceeding 360.0\n    float perpendicularSlope = normalizedSlope(slopeForDegrees(perpendicularDeg));\n   \n\n    // Get offset UVs for width of line, adjacent to center point\n    // -------------------------------\n\n    float angleA = perpendicularDeg;\n    float angleB = mod(perpendicularDeg + 180.0, 360.0); // Offset angle by 180.0, but keep it from exceeding 360.0\n    \n    float slopeA = normalizedSlope(slopeForDegrees(angleA));\n    float slopeB = normalizedSlope(slopeForDegrees(angleB));\n    \n    vec2 kA = offsetsForCoordAtDistanceOnSlope(halfWidth, slopeA);\n    vec2 kB = offsetsForCoordAtDistanceOnSlope(halfWidth, slopeB);\n    \n    vec2 offsetCoordA = centerUv * iResolution.xy;\n    vec2 offsetCoordB = centerUv * iResolution.xy;\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kA;\n    }\n    else {\n        offsetCoordA -= kA;\n    }\n\n    if (angleB <= 90.0 || angleB >= 270.0) {\n        offsetCoordB += kB;\n    }\n    else {\n        offsetCoordB -= kB;\n    }\n    \n    // Denormalize uvs and uv offsets and find closest point on line for our uv, then renormalize.\n    vec2 coordA = vec2(0.0);\n    lineLineIntersection(coordA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n    vec2 coordB = vec2(0.0);\n    lineLineIntersection(coordB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n\n\n    // Find intersects for line with edges of viewport\n    // -------------------------------\n\n    vec2 coordAIntersectA = vec2(0.0);\n    vec2 coordAIntersectB = vec2(0.0);\n    intersectsOnRectForLine(coordAIntersectA, coordAIntersectB, vec2(0.0) - amplitude - smoothing, iResolution.xy + amplitude + smoothing, offsetCoordA, slope);\n    \n    vec2 coordBIntersectA = vec2(0.0);\n    vec2 coordBIntersectB = vec2(0.0);\n    intersectsOnRectForLine(coordBIntersectA, coordBIntersectB, vec2(0.0) - amplitude - smoothing, iResolution.xy + amplitude + smoothing, offsetCoordB, slope);\n    \n    vec2 perpendicularIntersectA = vec2(0.0);\n    vec2 perpendicularIntersectB = vec2(0.0);\n    // Note: We use `coordA` here. `coordB` would have same effect and what we want is to\n    //   find the intersect perpedicular to the coord's closest point on the line.\n    intersectsOnRectForLine(perpendicularIntersectA, perpendicularIntersectB, vec2(0.0) - amplitude, iResolution.xy + amplitude, coordA, perpendicularSlope); \n    \n    \n    // Prepare wave\n    // -------------------------------\n    \n    // Find length of each edge of line in relation to the viewport, and to the\n    //   perpendicular line cutting through each coord's closest point on the line.\n    float aLength = distance(coordAIntersectA, coordAIntersectB);\n    float bLength = distance(coordBIntersectA, coordBIntersectB);\n    float perpendicularIntersectionLength = distance(perpendicularIntersectA, perpendicularIntersectB);\n\n    // Find percent of edge length that the uv's closest point on the line constitutes\n    //   for each edge of the line. Note that we find the distance from a point on a circle larger\n    //   than our viewport to our line point uv so that the line does not distort as it is rotated.\n  \n    // Relatively arbitrary. We just want a distance from center that is absolutely offscreen.\n    float outsideOffsetRadiusA = max(iResolution.x, iResolution.y) * 2.0;\n    vec2 outsideOffsetPointA = offsetCoordA;\n    vec2 outsideOffsetKA = offsetsForCoordAtDistanceOnSlope(outsideOffsetRadiusA / 2.0, slope);\n    if (deg <= 90.0 || deg >= 270.0) {\n        outsideOffsetPointA += outsideOffsetKA;\n    } else {\n        outsideOffsetPointA -= outsideOffsetKA;\n    }\n    float aDistance = (distance(outsideOffsetPointA, coordA) / aLength);\n    \n    float outsideOffsetRadiusB = max(iResolution.x, iResolution.y) * 2.0;\n    vec2 outsideOffsetPointB = offsetCoordB;\n    vec2 outsideOffsetKB = offsetsForCoordAtDistanceOnSlope(outsideOffsetRadiusB / 2.0, slope);\n    if (deg <= 90.0 || deg >= 270.0) {\n        outsideOffsetPointB += outsideOffsetKB;\n    } else {\n        outsideOffsetPointB -= outsideOffsetKB;\n    }\n    float bDistance = (distance(outsideOffsetPointB, coordB) / bLength);\n\n    // Define wave \n    \n    amplitude *= 2.0; // Noise wave stuff is weird. Amplitude makes sense for the user but it's not really amplitude.\n    volatility *= 0.3; // `volatility` values are between 0.0 and 1.0, but we really need a value between 0.0 and 0.3 (0.3 is about as volatile as it gets).\n    \n    float volatilityA = (1.0 * aLength) * volatility;\n    float volatilityB = (1.0 * bLength) * volatility;\n    \n    float varianceA = (amplitude / 2.0) * -1.0;\n    varianceA += noise((aDistance * PI) * volatilityA) * amplitude;\n    float varianceB = (amplitude / 2.0) * -1.0;\n    varianceB += noise((bDistance * PI) * volatilityB) * amplitude;\n\n    // Use wave variance as offsets of each point along our line and adjust each uv's closest\n    //   point on the line accordingly.\n    vec2 kVA = offsetsForCoordAtDistanceOnSlope(varianceA, slopeA);\n    vec2 kVB = offsetsForCoordAtDistanceOnSlope(varianceB, slopeB);\n    \n    if (angleA <= 90.0 || angleA >= 270.0) {\n        offsetCoordA += kVA;\n    }\n    else {\n        offsetCoordA -= kVA;\n    }\n    \n    if (angleB <= 90.0 || angleB >= 270.0) {\n        offsetCoordB += kVB;\n    }\n    else {\n        offsetCoordB -= kVB;\n    }\n    \n    lineLineIntersection(coordA, offsetCoordA, slope, uv * iResolution.xy, perpendicularSlope);\n    lineLineIntersection(coordB, offsetCoordB, slope, uv * iResolution.xy, perpendicularSlope);\n    \n\n    // Define wave edges\n    // -------------------------------\n\n    vec2 combinedDistance = step(coordA, uv * iResolution.xy) + step(coordB, uv * iResolution.xy);\n    float inWave = (min(combinedDistance.x, combinedDistance.y) == 1.0) ? 1.0 : 0.0;\n\n    float distA = distance(coordA, uv * iResolution.xy);\n    float distB = distance(coordB, uv * iResolution.xy);\n    distA = smoothstep(0.0, smoothing, distA);\n    distB = smoothstep(0.0, smoothing, distB);\n\n    float wave = min(distA, distB) * inWave;\n\n\n    // Return Wave\n    // -------------------------------\n    \n    return wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    // Setup\n    // -------------------------------\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    lowp vec2 position = vec2(0.5, 0.5);\n    lowp float deg = 180.0;\n    if (iMouse.z > 1.0) {\n        position = iMouse.xy / iResolution.xy;\n        deg = (position.x * 360.0);\n    }\n    \n    float width = 320.0;\n    float amplitude = 60.0;\n    float smoothing = 200.0;\n    float volatility = 0.185;\n    float speed = 0.025;\n    \n\n    // Prepare edge details \n    // -------------------------------\n\n    //deg = fract(iTime * speed) * 360.0;\n    float wave = isWave(uv, position, deg, width, smoothing, amplitude, volatility);\n    \n    fragColor = vec4(wave);\n}\n","name":"Image","description":"","type":"image"}]}