{"ver":"0.1","info":{"id":"DllGWn","date":"1674611913","viewed":138,"name":"basic_raymarch","username":"MadMath123","description":"just a basic raymarcher :) (:","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarchbasic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPSILON .001\n#define PI 3.1415926535\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\nfloat rand(vec3 co){ return rand(co.xy+rand(co.z)); }\n\nmat2 rotate(float d)\n{\n    float c = cos(d);\n    float s = sin(d);\n    return  mat2(c, -s, s, c);\n}\n\nfloat sdSphere(vec4 sphere, vec3 position)\n{\n    return length(position - sphere.xyz) - sphere.w;\n}\n\nfloat sdTwist(vec4 cube, vec3 position, float r)\n{\n    position.xz *= rotate((position.y + 1.) * PI / 4. * cos(iTime) * 1.);\n    //position.yz *= rotate((position.y + 1.) * PI / 4. * cos(iTime) * .25);\n    position.y /= 2.;\n    float ret = length(max(abs(position-cube.xyz)-vec3(cube.w),  0.)) - r;\n    return ret;\n}\n\nfloat sdCube(vec4 cube, vec3 position, float r)\n{\n    float ret = length(max(abs(position-cube.xyz)-vec3(cube.w-r),  0.))-r;\n    return ret;\n}\n\nfloat getDist(vec3 position)\n{\n    \n    vec4 box = vec4(0, 0, 0, 1);\n    float bDist = sdTwist(box, position, 1.);\n    \n    float groundDist = position.y + sin(iTime+position.x) + cos(iTime+position.z);\n    //if(position.x < 1. && position.x > -1. && position.z < 1. && position.z > -1.) groundDist = 50.;\n    \n    return min(bDist, groundDist);\n}\n\nvec3 getNormal(vec3 position)\n{\n    float dist = getDist(position);\n    vec2 epsilon = vec2(EPSILON, 0);\n    vec3 normal = dist - vec3(\n        getDist(position - epsilon.xyy),\n        getDist(position - epsilon.yxy),\n        getDist(position - epsilon.yyx)\n    );\n    return normalize(normal);\n}\n\nfloat march(vec3 position, vec3 direction)\n{\n    float dist = 0.;\n    float curDist = 0.;\n    for(int i = 0; i < 256; i ++){\n        curDist = getDist(position + direction * dist);\n        dist += curDist;\n        if(abs(curDist) < EPSILON) break;\n    }\n    return dist;\n}\n\nfloat getLight(vec3 position, vec3 light, vec3 origin)\n{\n    vec3 lightDir = normalize(light - position);\n    vec3 viewDir = normalize(origin - position);\n    vec3 normal = getNormal(position);\n    float hitToLightDist = march(position + normal * EPSILON * 2., lightDir);\n    float lightDist = length(light - position);\n    if(hitToLightDist < lightDist) return 0.;\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.);\n    float lightVal = clamp(dot(lightDir, normal), 0., 1.);\n    \n    return lightVal + specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 iMousePos = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    if(iMouse.xy == vec2(0., 0.)){iMousePos = vec2(iTime / 16., -.375);}\n    vec3 origin = vec3(0., 0., -8.);\n    vec3 direction = normalize(vec3(uv, 1));\n    direction.yz *= rotate((iMousePos.y - 1.5) * PI);\n    origin.yz *= rotate((iMousePos.y - 1.5) * PI);\n    direction.xz *= rotate(iMousePos.x * PI);\n    origin.xz *= rotate(iMousePos.x * PI);\n    origin += vec3(0., 2., 0.);\n    float dist = march(origin, direction);\n    vec3 hit = origin + direction * dist;\n    float lightVal = getLight(hit, vec3(-6, 6, 6), origin);\n    vec3 col = vec3(lightVal);\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}