{"ver":"0.1","info":{"id":"MsGGDW","date":"1454462018","viewed":297,"name":"Simple Shader Practice","username":"teessider","description":"This shader was made to practice my shader skills. I have lots more to learn!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","funky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// By Andrew \"teessider\" Bell\n\nfloat A = 1.0;\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n\n// https://www.shadertoy.com/view/XsXSz4 - SDF 2D Triangle!\nfloat SDTriangle(in vec2 point0, in vec2 point1, in vec2 point2, in vec2 coord)\n{  \n    vec2 edge0 = point1 - point0;\n    vec2 edge1 = point2 - point1;\n    vec2 edge2 = point0 - point2;\n    \n    // These seem to be gradients from edge of screen \n    // to edges of triangle/points of triangle ?\n    vec2 v0 = coord - point0;\n    vec2 v1 = coord - point1;\n    vec2 v2 = coord - point2;\n    \n    // I don't know what these do yet xD\n    vec2 pq0 = v0 - edge0 * saturate(dot(v0, edge0) / dot(edge0, edge0));\n    vec2 pq1 = v1 - edge1 * saturate(dot(v1, edge1) / dot(edge1, edge1));\n    vec2 pq2 = v2 - edge2 * saturate(dot(v2, edge2) / dot(edge2, edge2));\n    \n    // or these either xD xD\n    float s = sign(edge0.x*edge2.y - edge0.y*edge2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s*(v0.x*edge0.y-v0.y*edge0.x)),\n                     vec2(dot(pq1, pq1), s*(v1.x*edge1.y-v1.y*edge1.x))),\n                 \t vec2(dot(pq2, pq2), s*(v2.x*edge2.y-v2.y*edge2.x)));\n    \n    return -sqrt(d.x)*sign(d.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec3 red = vec3(1.0, 0, 0);\n    vec3 green = vec3(0, 1.0, 0);\n    \n    //// PREVIOUS PRACTICE FOLLOWS\n    \n    //float mix_alpha = pow(distance(uv.x, uv.y), dot(uv.x, uv.y));\n    \n    // Alternative way of doing previous float\n    // Thanks FabriceNeyet2\n    //float mix_alpha = pow(abs(uv.x-uv.y), uv.x*uv.y);\n    \n    // mix function is GLSL version of lerp function in HLSL\n    //fragColor = vec4(invertRGB(mix(red, green, mix_alpha)), 1.0);\n    \n    // Alternative to making a oneMinus and invertRGB functions!\n    // Thanks demofox\n    //fragColor = vec4(1.0 - mix(red, green, mix_alpha), 1.0);\n    \n    //// END OF PREVIOUS PRACTICE\n    \n    \n    // TRIANGLE POINTS\n    vec2 a = vec2(0.4, 0.4);\n    vec2 b = vec2(0.75, 0.5);\n    vec2 c = vec2(0.69, 0.65);\n    \n    float triangle = 1.0 - smoothstep(0.0, 0.01, SDTriangle(a, b, cos(c * iTime) * sin(c * iTime), uv));\n    \n    //// TODO:\n    // REFERENCE\n    // https://www.shadertoy.com/view/Xl2yDW - EQUAL TRI\n    // https://www.shadertoy.com/view/4sXXRN - SDF 3D Triangle!\n    // https://www.shadertoy.com/view/4dlSRX - more triangle reference\n    // https://www.shadertoy.com/view/4sSSzG - EVEN more triangle reference\n    \n    vec2 test2 = uv;\n    \n    //fragColor = vec4(test2, 0.0, 1.0);  // Testing \n    //fragColor = vec4(mix(vec3(test2, 0.0), vec3(triangle), clamp(sin(iTime*0.5), 0.0, 1.0)), 1.0);\n    fragColor = vec4(vec3(triangle), 1.0);\n}","name":"Image","description":"","type":"image"}]}