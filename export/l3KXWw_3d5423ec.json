{"ver":"0.1","info":{"id":"l3KXWw","date":"1720046824","viewed":29,"name":"Squircle Vs RoundBox (2D)","username":"nathannerd","description":"Can you use a rounded box (https://iquilezles.org/articles/distfunctions2d/) to simulate a Squircle? Which one is faster? Which one has better continuity (G2 curvature continuity)?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["2d","distance","signed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// remap function, lerp plus inverse lerp\nfloat remap( float value, float iMin, float iMax, float oMin, float oMax )\n{\n    // inverse lerp\n    // float t = (value - iMin)/(iMax-iMin);\n    // optional clamp\n    // t = clamp(t,0.0,1.0);\n    // lerp\n    // return oMin*(1-t) + oMax*t;\n    // return oMin + t*(oMax-oMin); \n    return oMin + (value - iMin)*(oMax-oMin)/(iMax-iMin);\n}\n\nfloat maxComp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat maxComp(in vec2 p ) { return max(p.x,p.y);}\n\n//SDF for a circle\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b, in vec4 r )\n{\n    // r.x = Quad1 = (+x,+y) , r.y = Quad2 = (-x,+y)\n    // r.z = Quad3 = (-x,-y) , r.w = Quad4 = (+x,-y)\n    // if r>0 for a certain corner, it will round to a circle\n    // if r=1 for a corner, the whole quadrant will be a circle\n    r.xy = (p.x>0.0)?r.xw : r.yz;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n\nfloat sdBox( in vec2 p, in float b, in vec4 r )\n{\n    return sdBox(p, b*vec2(1.0), r);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdBox( in vec2 p, in float b )\n{\n    return sdBox(p, b*vec2(1.0));\n}\n\n// SDF for a squircle\nfloat sdSquircle( in vec2 p, in float r, in vec4 c )\n{\n    // to make the volume of the squircle (super egg with power 4)\n    //   equal to the volume of a similar sized box,\n    //   I approximated to multiple the radius by 1.0727 for 3D, and 1.0386 for 2D\n\n    c.xy = (p.x>0.0)?c.xw : c.yz;\n    c.x  = (p.y>0.0)?c.x  : c.y;\n    // now c.x contains the current quadrant\n    // if this corner is not zero, use squircle function\n    // if this corner is zero, should be box\n    float sdf = 0.0;\n    sdf = (c.x>0.0001)?\n        sqrt(sqrt(p.x*p.x*p.x*p.x + p.y*p.y*p.y*p.y)) - r : \n        sdBox(p, r);\n        \n    return sdf;\n}\n\nfloat sdSquircle( in vec2 p, in float r )\n{\n    return sqrt(sqrt(p.x*p.x*p.x*p.x + p.y*p.y*p.y*p.y)) - r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Split screen for two SDFs\n    // use 'screen' to determine which screen you are on\n    //vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.x;\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.x;\n    bool screen = p.x<0.0;\n    p.x = (screen)? p.x+0.5:p.x-0.5;\n    p = 2.0*p;\n    \n    // rotate P (rotates the boxes)\n    float rps = 1.0/8.0; // rotations per second\n    float theta = rps * iTime * radians(360.0); // how do I write 2pi???\n    mat2 rotM = mat2( cos(theta), sin(theta),   // first column\n                     -sin(theta), cos(theta) ); // second column\n    vec2 pOG = p;\n    p *= rotM;\n    \n    float rBox = 0.30; //radius of the box\n    float roundBox = 0.5; // roundess of the box corners\n    vec4 corners = vec4(1.0, 1.0, 0.0, 0.0);\n    float box = sdBox(p, rBox, roundBox*rBox*corners);\n    float squircle = sdSquircle(p,rBox, corners);\n    \n    // Testing Performance of sdBox\n    // nBox=2000 -> ~17fps\n    const int nBox = 0;\n    for( int i=min(iFrame,0); i<nBox; i++ )\n    {\n        box += sdBox( p+0.1*cos(iTime+float(i)), rBox);\n    }\n    // box /= float(nBox);\n    \n    // Testing Performance of sdSquircle\n    // nSquircle=2000 -> ~16fps\n    const int nSquircle = 0;\n    for( int i=min(iFrame,0); i<nSquircle; i++ )\n    {\n        squircle += sdSquircle( p+0.1*cos(iTime+float(i)), rBox);\n    }\n    // squircle /= float(nSquircle);\n\n    // Setting colors \n    \n    float d = (screen)? box : squircle;\n    vec3 color = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    // each band is length 0.1, screen goes from [-1,+1]\n\tcolor *= 0.6 + 0.4*smoothstep(0.52,0.48, abs(1.0 - mod(10.0*d-0.5,2.0)));\n    color = mix( color, vec3(1.0), smoothstep( 0.008,0.004,abs(d) ) );\n    color = mix( color, vec3(0.0), smoothstep( 0.008,0.004,abs(1.0-maxComp(abs(pOG))) ) );\n    // smoothstep does inverse lerp and clamping, plus a low cost smoothing effect\n    //    it provides a nice antialias edge\n    \n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}