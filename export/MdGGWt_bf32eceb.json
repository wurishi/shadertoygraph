{"ver":"0.1","info":{"id":"MdGGWt","date":"1582402983","viewed":353,"name":"stb - attribute field","username":"stb","description":"Press r to restart\nMouse for magnifier","likes":28,"published":1,"flags":48,"usePreview":0,"tags":["2d","sdf","distance","field","attribute","dart","throwing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float CornerRad = 0.5; // relative to object size, not pixels\n\n//#define t2D(o) texture(iChannel0, uv-o/res)\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nfloat rBox(in vec2 p, float r1, float ang) {\n    float r2 = r1 * CornerRad;\n    p = rotate(p, ang);\n    p = max(vec2(0.), abs(p)-r1+r2);\n    return length(p)-r2;\n}\n\nfloat brick(vec2 p) {\n    return 2.-4.*max(abs(mod(p.x+floor(p.y), 2.)-1.)-.5, abs(fract(p.y)-.5));\n}\n\n#define t2D(o) texture(iChannel0, (uv/zoom-o/res))\n#define len 1. * res.y * rBox((fc-pos)/res.y, rad/res.y, ang)\n//#define len length(fc/zoom-pos) - rad\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 fc = fragCoord;\n    vec2 res = iResolution.xy;\n    vec2 uv = fc / res;\n    vec2 p = fc / res.y;\n    vec3 o = vec3(1., -1., 0.);\n    \n    //float zoom = 0.+16.*iMouse.x/res.y;\n    //fc /= zoom;\n    \n    float zoom = 1.;\n    vec2 uv2 = (uv-iMouse.xy/res) * vec2(res.x/res.y, 1.);\n    if(iMouse.z>0. && dot(uv2, uv2)<32./res.y) {\n        zoom = 12. - .1 * res.y * dot(uv2, uv2);\n        vec2 m = (1.-zoom) * iMouse.xy;\n    \tuv -= m / res;\n    \tfc -= m;\n        fc /= zoom;\n        // lens color\n        //RGB += vec3(.5, .0, 1.) * pow(8./zoom, 8.);\n    }\n    \n    vec2 dirs[8];\n    dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;\n    dirs[4] = o.xx; dirs[5] = o.yx; dirs[6] = o.xy; dirs[7] = o.yy;\n    \n    // current position\n    vec2 pos = t2D(o.zz).rg;\n    float rad = t2D(o.zz).b;\n    float ang = t2D(o.zz).a;\n    \n    float tex = brick(rotate((2.*uv*res/zoom-pos)/rad, ang));\n    float c = len;\n    \n    float rad_ = rad;\n    \n    // object gradient\n    float ct = 1.;\n\tfor(int i=0; i<8; i++) {\n        pos = t2D(dirs[i]).rg;\n    \trad = t2D(dirs[i]).b;\n        ang = t2D(dirs[i]).a;\n        if(len<c) {\n            tex = brick(rotate((2.*uv*res/zoom-pos)/rad, ang));\n            c = len;\n            ct++;\n        }\n    }\n    \n    float ss = 1. / zoom;\n    tex = min(tex, 16.*clamp(-c/32., 0., 1.));\n    c = smoothstep(-ss, ss, c);\n    c = max(c, tex);\n    \n    //c = brick(p*4.);\n    \n    fragColor = vec4(vec3(c), 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float SizeMin  = 1.0;\nconst float SizeMax  = 12.0;\nconst float CornerRad = 0.5; // relative to object size, not pixels\n\nconst float Key_R = 82.5 / 256.;\nconst float Key_X = 88.5 / 256.;\nconst float Key_Space = 32.5 / 256.;\n\n#define NULL_POS vec2(-10000.)\n\n#define t2D(o) texture(iChannel0, uv-o/res)\n#define isKeyHeld(key) texture(iChannel3, vec2(key, .2)).r > 0.\n#define dataAt(x) texture(iChannel0, vec2(x+.5, .5)/res)\n\n// hash without sine\n// https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975,397.2973, 491.1871)\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat s, c;\n#define rotate(p, a) mat2(c=cos(a), s=-sin(a), -s, c) * p\n\nfloat rBox(in vec2 p, float r1, float ang) {\n    float r2 = r1 * CornerRad;\n    p = rotate(p, ang);\n    p = max(vec2(0.), abs(p)-r1+r2);\n    return length(p)-r2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 res = iResolution.xy;\n    vec2 fc = fragCoord;\n\tvec2 uv = fc / res;\n    vec3 o = vec3(1., -1., 0.);\n    \n    vec2 dirs[8];\n    dirs[0] = o.xz; dirs[1] = o.yz; dirs[2] = o.zx; dirs[3] = o.zy;\n    dirs[4] = o.xx; dirs[5] = o.yx; dirs[6] = o.xy; dirs[7] = o.yy;\n    \n    vec2 pos = t2D(o.zz).rg;\n    float rad = t2D(o.zz).b;\n    float ang = t2D(o.zz).a;\n    \n    float ct = 0.;\n    for(int i=0; i<8; i++) {\n        // neighbor's stored attributes\n        vec2 iPos = t2D(dirs[i]).rg;\n        float iRad = t2D(dirs[i]).b;\n        float iAng = t2D(dirs[i]).a;\n        \n        // if distance produced by neighbor is less than the current one, take its attributes\n        if(rBox(fc-iPos, iRad, iAng) < rBox(fc-pos, rad, ang)) {\n            pos = iPos;\n            rad = iRad;\n            ang = iAng;\n        }\n    }\n\t\n    // add new objects over time\n    if(.01>hash12(uv+mod(iTime/100., 100.))) {\n        //float tRad = max(SizeMin, rad / 1.25);\n        float tRad = mix(SizeMin, SizeMax, pow(hash12(-uv-mod(iTime/100., 100.)), 1.));\n        //float tAng = 3.14159265 * hash12(-uv-3.1-mod(iTime/100., 100.));\n        float rb = rBox(fc-pos, rad, ang);\n        //float tRad = clamp(rb, SizeMin, SizeMax);\n\t\t\n        //if(true) {\n\t\tif(rb>tRad && rb<tRad+.2) {\n            pos = fc;\n            rad = tRad;\n            ang += .25 * (.5-hash12(-uv-mod(iTime/100., 100.)));\n            //ang = tAng;\n        }\n    }\n    \n    // initialize attributes\n    if(iFrame==0 || isKeyHeld(Key_R)) {\n        if(.00001>hash12(uv+mod(iTime/100., 100.))) {\n        //if(floor(fc)==floor(res/2.)) {\n            pos = fc;\n            //rad = SizeMax;\n            //ang = 0.;\n            rad = mix(SizeMin, SizeMax, hash12(-uv-mod(iTime/100., 100.)));\n            ang = 3.14159265 * hash12(-uv-3.1-mod(iTime/100., 100.));\n        }\n        else {\n            pos = NULL_POS;\n            rad = 0.;\n            ang = 0.;\n        }\n    }\n    \n    // save attributes\n    fragColor = vec4(pos, rad, ang);\n}","name":"Buffer A","description":"","type":"buffer"}]}