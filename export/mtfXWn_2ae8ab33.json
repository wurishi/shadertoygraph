{"ver":"0.1","info":{"id":"mtfXWn","date":"1696526707","viewed":48,"name":"Mandelbulb Raymarcher","username":"samkhorner","description":"Simple mandelbulb raymarcher, MB1 to rotate","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 colourGradient[16] = vec3[16](vec3(0.259,0.118,0.059),vec3(0.098,0.027,0.102),vec3(0.035,0.004,0.184),vec3(0.016,0.016,0.286),vec3(0.0,0.027,0.392),vec3(0.047,0.173,0.541),vec3(0.094,0.322,0.694),vec3(0.224,0.49,0.82),vec3(0.525,0.71,0.898),vec3(0.827,0.925,0.973),vec3(0.945,0.914,0.749),vec3(0.973,0.788,0.373),vec3(1.0,0.667,0.0),vec3(0.8,0.502,0.0),vec3(0.6,0.341,0.0),vec3(0.416,0.204,0.012));\n\nstruct surface{\n    float sd;\n    vec3 col;\n};\n\nmat3 identity(){\n    return mat3(\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n        );\n}\n\nmat3 rotateY(float theta){\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c,0,s),\n        vec3(0,1,0),\n        vec3(-s,0,c)\n    );\n}\n\nsurface mandelbulb(vec3 pos, mat3 transformation, int iters, float power, float bound){\n    vec3 z = pos;\n    z *= transformation; // Apply transformation\n    highp float delta_r = 1.0; // Gradient of the distance from the origin\n    highp float r = 0.0;  // Distance from origin of point\n    highp float n = power;  // Power\n    highp float dist = 1e20f;\n    \n    for (int i = 0; i < iters; i++){\n        r = length(z); // Distance from origin to z\n        if (r > bound){break;} // Escape iteration if r > escape radius\n        \n        // Obatain polar angles\n        highp float phi = atan(z.y,z.x);\n        highp float theta = acos(z.z/r);\n        // Calculate gradient of r\n        delta_r = (pow(r,n-1.)*n*delta_r) + 1.;\n        \n        // Scale and rotate z\n        highp float rn = pow(r,n);\n        phi *= n;\n        theta *= n;\n        \n        // Convert back to cartesian\n        z = rn * vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n        // Make relative to pos\n        z += pos;\n        \n        dist = min(dist, length(z));\n    }\n    // Scaling and returning log(r) * r/delta_r as estimated distance\n    return surface(0.5 * log(r) * r/delta_r,colourGradient[int(sqrt(dist) * (8.*sqrt(2.)) - 1.)]);\n}\n\nsurface scene(in vec3 pos){\n    //surface mandelbulb = mandelbulb(pos, rotateY((iMouse.x / iResolution.x - 0.5) * 3.14159 * 2.), 50, clamp(iTime /10. + 1., 1.0, 6.0), 2.0);\n    surface mandelbulb = mandelbulb(pos, rotateY((iMouse.x / iResolution.x - 0.5) * 3.14159 * 2.), 50, 8., 2.);\n    \n    return mandelbulb;\n}\n\nvec3 calcNormals(in vec3 p){\n    const vec3 nudge = vec3(0.01, 0.0, 0.0);\n    \n    float gradX = scene(p + nudge.xyy).sd - scene(p - nudge.xyy).sd;\n    float gradY = scene(p + nudge.yxy).sd - scene(p - nudge.yxy).sd;\n    float gradZ = scene(p + nudge.yyx).sd - scene(p - nudge.yyx).sd;\n    \n    vec3 normal = vec3(gradX, gradY, gradZ);\n    \n    return normalize(normal);\n}\n\nvec3 raymarch(in vec3 ro, in vec3 rd, in vec3 lp){\n    // VAR_SETUP\n    float totalDis = 0.0;\n    \n    const int MAX_STEPS = 100;\n    const float MIN_DIS = 0.001;\n    const float MAX_DIS = 10.0;\n    \n    // Raymarching loop\n    for (int i = 0; i <= MAX_STEPS; ++i){\n        vec3 pos = ro + totalDis * rd;\n        surface sc = scene(pos);\n        \n        // CASE: HIT DETECTED\n        if (sc.sd < MIN_DIS){\n            vec3 normal = calcNormals(pos);\n            \n            vec3 ld = normalize(pos - lp);\n            float diffuseIntensity = max(0.0, dot(normal, ld));\n            \n            return(sc.col * diffuseIntensity);\n        }\n        // CASE: MAX_DIST EXCEEDED\n        if (totalDis > MAX_DIS){\n            break;\n        }\n        totalDis += sc.sd;\n    }\n    return vec3(1.0,1.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 virtualCamera = vec3(0,0,-3);\n    vec3 rayDirection = vec3(uv, 1.0);\n    vec3 lightPos = vec3(2, -10, 2);\n    \n    vec3 col = raymarch(virtualCamera, rayDirection, lightPos);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}