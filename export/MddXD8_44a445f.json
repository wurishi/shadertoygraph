{"ver":"0.1","info":{"id":"MddXD8","date":"1459184674","viewed":323,"name":"Analytic line light","username":"gcordonnier","description":"Inspired from https://www.shadertoy.com/view/Xd3SWH. + bump map from https://www.shadertoy.com/view/Xd3SWH\nLeft: diffuse light comes from nearest point of the line. Right: contribution is integrated over the line.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["line","light","analytic","exact"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Analytic line light - gcoronnier\n// inspired from https://www.shadertoy.com/view/Xd3SWH, I try to see the difference of two implementation of\n// the line light. The first one (taken from the original), compute the diffuse illumination from the distance to the\n// nearest point of the line (left)\n// The second one is the analytic result of the integral of light contribution over the line (left)\n\n\n\nstruct LineLight\n{\n    vec3 start;\n    vec3 stop;\n    vec4 color;\n};\n    \nvec4 getTex(sampler2D tex, vec2 uv)\n{\n    return pow(texture( tex, uv ), vec4(2.2));\n}\n\nvec4 simpleLight(vec3 pos, vec3 norm, LineLight light)\n{\n    //line \n    vec3 lineVec = light.stop - light.start;\n    float lineLength = length(lineVec); \n    vec3 lineDir = lineVec / lineLength;\n    \n    // Project pos on line\n    float proj_t = clamp(dot(lineDir, pos-light.start) / lineLength, 0.0, 1.0);\n    vec3 posInLine = lineVec * proj_t + light.start;\n    \n    // light vector\n    vec3 lightVec = posInLine - pos;\n    float lightDist = length(lightVec);\n\n    // Get Final Distances for attenuation calculation\n    float diffuse = dot(norm, lightVec) / lightDist / lightDist / lightDist;\n    \n    return light.color * diffuse; \n}\n\nvec4 analyticLight(vec3 pos, vec3 norm, LineLight light)\n{\n    vec3 lineVec = light.stop - light.start;\n    vec3 startToPos = light.start - pos;\n    \n    float a = dot(lineVec, lineVec);\n    float b = 2.0 * dot(lineVec, startToPos);\n    float c = dot(startToPos, startToPos);\n    \n    float delt = b*b-4.0*a*c;\n    \n    float I0 = (-(4.0*a+2.0*b)/sqrt(a+b+c) + 2.0*b / sqrt(c))/delt;\n    float Ix = ((2.0*b+4.0*c)/sqrt(a+b+c) - 4.0*c / sqrt(c))/delt;\n    \n    float diffuse = dot(norm, lineVec) * Ix + dot(norm, startToPos) *I0;\n    \n    return light.color * diffuse;\n}\n\n// https://www.shadertoy.com/view/ldSGzR\nvec3 doBump( in vec3 pos, in vec3 nor, in float signal, in float scale )\n{\n    // build frame\t\n    vec3  s = dFdx( pos );\n    vec3  t = dFdy( pos );\n    vec3  u = cross( t, nor );\n    vec3  v = cross( nor, s );\n    float d = dot( s, u );\n\n    // compute bump\t\n    float bs = dFdx( signal );\n    float bt = dFdy( signal );\n\t\n    // offset normal\t\n#if 1\n\treturn normalize( nor - scale*(bs*u + bt*v)/d );\n#else\n    // if you cannot ensure the frame is not null\t\n\tvec3 vSurfGrad = sign( d ) * ( bs * u + bt * v );\n    return normalize( abs(d)*nor - scale*vSurfGrad );\n#endif\n}\n\nvoid mainImage( out vec4 color, in vec2 fragCoord )\n{\n    // Setup stuff\n    vec3 position = vec3(iResolution.xy * vec2(0.5+0.1*sin(iTime), 0.5), 20.0);\n    \n    float angle = iTime * 2.0;\n    vec3 dir\t=\tvec3(cos(angle), sin(angle), 0.0);\n    \n    LineLight light;\n    light.color = vec4(1.0, 0.35, 1.0, 1.0);\n    light.start = position - (dir * iResolution.x * 0.15);\n\tlight.stop\t= position + (dir * iResolution.x * 0.15);\n    \n    vec4 ambient = vec4(1.0, 1.0, 1.0, 1.0);\n    \n    //Start of Shader\n    vec3 pos = vec3(fragCoord.xy, 0.0);\n    vec4 texColor = getTex( iChannel0, fragCoord / iResolution.xy ); \n    vec3 normal = doBump(pos, vec3(0.0,0.0,1.0), dot(texColor.xyz,vec3(0.33)), 5.0 );\n       \n    float kd = 800.0; // Cause 2d and no normals\n    float ka = 0.001;\n    \n    vec4 l0 = analyticLight(pos, normal, light);\n    vec4 l1 = simpleLight(pos, normal, light);\n    \n    float side = step(iResolution.x*0.5, fragCoord.x);\n    vec4 ldif = side * l0 + (1.0-side)*l1;\n    \n   \tcolor = texColor * (ka * ambient  + kd *  ldif);\n    \n    color = pow(color, vec4(1.0/2.2));\n}","name":"Image","description":"","type":"image"}]}