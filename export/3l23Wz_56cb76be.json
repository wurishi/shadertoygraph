{"ver":"0.1","info":{"id":"3l23Wz","date":"1559171393","viewed":497,"name":"Bilinear Point Distribution","username":"fizzer","description":"Here is a method of sampling bilinearly-distributed points. It could perhaps be used for sampling a low-res environment map or emissive surface map. Hold the mouse button to see non-jittered points.","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["sampling","points","distribution","bilinear"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Here is a method of sampling bilinearly-distributed points.\n//\n// A uniform distribution can be 're-shaped' into some other distribution using what's\n// known as a cumulative distribution function (CDF). This CDF can be created by inverting the integral\n// of your distribution function, and that's what I've done here. It turned out to be quite\n// straightforward, not requiring higher than 2nd-order polynomials.\n//\n// For the explanation I'll talk about a 1-dimensional bilinear patch defined with control points\n// like this:\n//\n//\t  0  --u-→ 1\n//\t  | p0   p1\n//\t  v\n//\t  ↓ p2   p3\n//    1\n//\n// The bilinear distribution function is F=(p0+(p1-p0)u)(1-v)+(p2+(p3-p2)u)v\n//\n// For each v there is a linear function c+mu where c=p0+v(p2-p0) and m=(p1-p0)+v((p3-p2)-(p1-p0)),\n// which when integrated over [0,1] yields c+m/2\n//\n// c+m/2 as a function of v is another linear function, which can easily be integrated.\n//\n// Integrating c+m/2 gives the following quadratic polynomial:\n// \n// \t\tv(v(p2+p3-p0-p1)+2(p0+p1))/4\n//\n// This function of v can be inverted to obtain a cumulative distribution function.\n//\n// After a value for v has been found by applying the CDF to a uniformly-chosen v,\n// the corresponding linear function of u for that 'slice' of the patch can easily\n// be integrated and inverted to produce a CDF for u.\n//\n//\n\n// Degree-2 polynomial, with c = 0\nfloat quadratic(float x, float b, float a)\n{\n    return (b + a * x) * x;\n}\n\n// Inverse degree-2 polynomial, with c = 0\n// Assumes real solution, and returns the 2nd root\nfloat inverseQuadratic(float y, float b, float a)\n{\n    float d = b * b + 4. * a * y;\n    return (sqrt(d) - b) / (2. * a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2. - 1.;\n\n    uv.x *= iResolution.x / iResolution.y;\n\n    fragColor = vec4(0, 0, 0, 1);\n    vec2 p = uv.xy / 1.7 + .5;\n\n    fragColor.rgb = vec3(.8);\n    \n    if(all(greaterThan(p, vec2(-.05))) && all(lessThan(p, vec2(1.05))))\n\t    fragColor.rgb = vec3(.05);\n\n    const float pi = 3.14159265358979323;\n    \n    if(all(greaterThan(p, vec2(0))) && all(lessThan(p, vec2(1))))\n    {\n\n        // Bilinear patch control points\n        float p0 = pow(.5 + .5 * cos(iTime + pi * 0.0), 6.);\n        float p1 = pow(.5 + .5 * cos(iTime + pi * 0.5), 6.);\n        float p2 = pow(.5 + .5 * cos(iTime + pi * 1.0), 6.);\n        float p3 = pow(.5 + .5 * cos(iTime + pi * 1.5), 6.);\n\n        // Fv polynomial coefficients\n        float b2 = 2. * (p0 + p1) / 4.;\n        float c2 = (p2 + p3 - p0 - p1) / 4.;\n\n        // sum is the bilinear patch integrated over the domain\n        float sum = quadratic(1., b2, c2);\n\n        const int n = 32;\n        \n        fragColor.rgb = vec3(mix(mix(p0, p1, p.x), mix(p2, p3, p.x), p.y));\n        \n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n            {                \n                vec4 ns = texelFetch(iChannel0, ivec2(i, j) & 255, 0);\n\n                // Jitter\n                float ju = iMouse.z < .5 ? ns.x : .5;\n                float jv = iMouse.z < .5 ? ns.y : .5;\n\n                float u = (float(i) + ju) / float(n), v = (float(j) + jv) / float(n);\n\n                // Remap U to the domain of Fv\n                v *= sum;\n\n                // Apply Fv\n                v = inverseQuadratic(v, b2, c2);\n\n                // U-axis linear function coefficients\n                float c2 = mix(p0, p2, v);\n                float m2 = mix(p1 - p0, p3 - p2, v) / 2.;\n\n                // Remap U to the domain of Fu\n                u *= c2 + m2; // = quadratic(1., c2, m2);\n\n                // Apply Fu\n                u = inverseQuadratic(u, c2, m2);\n\n                vec3 sprite = vec3(1. - clamp((distance(p, vec2(u, v)) - .007) / .001, 0., 1.));\n\n                fragColor.rgb = mix(sprite, fragColor.rgb,\n                                    clamp((distance(p, vec2(u, v)) - .01) / .001, 0., 1.));\n            }\n    }\n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1. / 2.2));\n}","name":"Image","description":"","type":"image"}]}