{"ver":"0.1","info":{"id":"4XjSRd","date":"1729166807","viewed":47,"name":"SDF Propagation Comparison","username":"yetsun","description":"Compare methods of signed distance field generatioin.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["sdf","jfa","eikonal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Enable to show error x100\n//#define VISUALIZE_ERROR\n//#define SHOW_ONLY_ERROR\n\n//#define USE_EIKONAL_EQUATION\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n#ifndef USE_EIKONAL_EQUATION\n    float val;\n    vec4 packed = texture(iChannel0, uv);\n    if (packed.z == 0.0)\n    {\n        val = 1024.0 * 16.0;\n    }\n    else\n    {\n        val = packed.z * distance(fragCoord, packed.xy);\n    }\n    float analytic = packed.a * 0.003;\n#else\n    float val = texture(iChannel1, uv).r;\n    float analytic = texture(iChannel1, uv).a * 0.003;\n#endif\n    val *= 0.003;\n\n    \n    \n    // Colorization\n    vec3 outColor = vec3(val, val, val);\n\n#ifdef VISUALIZE_ERROR\n\t// Green-blue colorization    \n    if (val < 0.0) outColor = vec3(0.0, 1.0 + val * 4.0, 1.0 + val * 4.0);\n    else if (val < 0.5) outColor = vec3(0.0, val * 2.0, 0.0);\n    else if (val < 1.0) outColor = vec3(0.0, 0.0, (val - 0.5) * 2.0);\n    else outColor = vec3(0.0, (val - 1.0) * 2.0, (val - 1.0) * 2.0);\n    \n    // Red channel = error compared to analytical solution\n    outColor.r = abs(val - analytic) * 100.0;\n#else\n    // Full RGB colorization / no error visualization\n    if (val < 0.0) outColor = vec3(1.0 + val * 4.0, 1.0 + val * 4.0, 1.0 + val * 4.0);\n    else if (val < 0.25) outColor = vec3(val * 4.0, 0.0, 0.0);\n    else if (val < 0.5) outColor = vec3(0.0, (val - 0.25) * 4.0, 0.0);\n    else if (val < 0.75) outColor = vec3(0.0, 0.0, (val - 0.5) * 4.0);\n    else if (val < 1.0) outColor = vec3((val - 0.75) * 4.0, (val - 0.75) * 4.0, 0.0);\n    else outColor = vec3((val - 1.0) * 2.0, (val - 1.0) * 2.0, (val - 1.0) * 2.0);\n#endif\n    \n#ifdef SHOW_ONLY_ERROR\n    outColor.rgb *= vec3(1.0, 0.0, 0.0);\n#endif\n        \n    fragColor.rgb = outColor;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Jump Flooding\n\n//#define DEBUG_NEAREST_CALCULATION\n\n\nvec4 testNeighbor(vec2 uv, vec2 delta, vec2 p, vec4 curr)\n{\n    vec4 neighbor = texture(iChannel0, uv + delta);\n    \n    if (neighbor.z == 0.0)\n    {\n        return curr;\n    }\n        \n    if (curr.z == 0.0)\n    {\n        return neighbor;\n    }\n    else\n    {\n        if (distance(p, neighbor.xy) < distance(p, curr.xy))\n        {\n            return neighbor;\n        }\n    }\n    return curr;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixel = fragCoord;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 analytical = distFunc(pixel);\n    \n    if (iFrame == 0)\n    {\n        // Intialize\n        \n        vec2 seed = analytical.xy;\n        float dist = analytical.z;\n   \n#ifndef DEBUG_NEAREST_CALCULATION\n        if (abs(dist) > seedRadius)\n        {\n            fragColor = vec4(seed, 0.0, maxValue);\n        }\n        else\n#endif\n        {\n            fragColor = vec4(seed, dist > 0.0 ? 1.0 : -1.0, dist);\n        }\n    }\n    else\n    {\n        fragColor = texture(iChannel0, uv);\n        \n#ifndef DEBUG_NEAREST_CALCULATION\n        int iter = iFrame / 15;\n        if (iter < 12) // 4096\n        {\n            float stepSize = iter == 0 ? 1.0 : exp2(12.0 - float(iter));\n            vec2 offset = stepSize / iResolution.xy;\n            \n            vec3 best;\n            float bestDist = maxValue;\n            \n            for (int y = -1; y <= 1; ++y)\n            {\n                for (int x = -1; x <= 1; ++x)\n                {\n                    vec3 other = texture(iChannel0, uv + vec2(x, y) * offset).xyz;\n                    float newDist = distance(pixel, other.xy);\n                    \n                    if (other.z != 0.0 && newDist < bestDist)\n                    {\n                        bestDist = newDist;\n                        best = other;\n                    }\n                }\n            }\n            fragColor.xyz = best;\n        }\n#endif\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Distance Functions\n\n#define SOLID_FILL\n\nconst float seedRadius = 1.5;\t\t\t\t// sqrt(2) round up\n\nconst float maxValue = 1024.0 * 16.0;\n\nconst vec2 point0 = vec2(300.5, 30.5);\t\t// pixel center\nconst vec2 point1 = vec2(110.7, 430.2);\nconst vec2 point2 = vec2(200.3, 349.6);\nconst vec2 point3 = vec2(30.0, 123.0);\t\t// between pixels\n\nconst vec2 circleCen = vec2(732.4, 534.1);\nconst float circleRad = 129.3;\n\nconst vec2 rectPos = vec2(500.34, 500.34);\nconst vec2 rectExt = vec2(100, 100);\n\nvec3 distPoint(vec2 point, vec2 p)\n{\n    float d = distance(point, p);\n    vec2 seed = point;\n    return vec3(seed, d);\n}\n\nvec3 distCircle(vec2 center, float radius, vec2 p)\n{\n    vec2 toCenter = center - p;\n    float l = length(toCenter);\n    \n    float d = l - radius;\n    vec2 seed = l > 0.0 ? p + toCenter / l * d : p;\n    \n#ifdef SOLID_FILL\n    if (d < 0.0)\n    {\n        d = 0.0;\n        seed = p;\n    }\n#endif\n\n    return vec3(seed, d);\n}\n\nvec3 distRect(vec2 rectPos, vec2 rectExt, vec2 p)\n{\n    vec2 toCenter = rectPos - p;\n    vec2 q = abs(toCenter) - rectExt;\n    \n    vec2 seed;\n    float d = length(max(q, 0.0));\n    if (d > 0.0)\n    {\n        seed.x = q.x > 0.0 ? (rectPos.x - sign(toCenter.x) * rectExt.x) : p.x;\n        seed.y = q.y > 0.0 ? (rectPos.y - sign(toCenter.y) * rectExt.y) : p.y;\n    }\n    else\n    {\n        d = max(q.x, q.y);\n        if (q.x > q.y)\n        {\n            seed.x = p.x;\n            seed.y = rectPos.y - sign(toCenter.y) * rectExt.y;\n        }\n        else\n        {\n            seed.x = rectPos.x - sign(toCenter.x) * rectExt.x;\n            seed.y = p.y;\n        }\n    }\n    \n#ifdef SOLID_FILL\n    if (d < 0.0)\n    {\n        d = 0.0;\n        seed = p;\n    }\n#endif\n\n    return vec3(seed, d);\n}\n\nvec3 distMin(vec3 a, vec3 b)\n{\n    return a.z < b.z ? a : b;\n}\n\nvec3 distFunc(vec2 p)\n{\n    vec3 ret = distPoint(point0, p);\n    ret = distMin(ret, distPoint(point1, p));\n    ret = distMin(ret, distPoint(point2, p));\n    ret = distMin(ret, distPoint(point3, p));\n    ret = distMin(ret, distCircle(circleCen, circleRad, p));\n    ret = distMin(ret, distRect(rectPos, rectExt, p));\n\n    return ret;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Split distance value to positive and negative, and apply eikonal equation on them independently.\n\n//#define START_FROM_ANALYTICAL_RESULT\n\n// https://en.wikipedia.org/wiki/Eikonal_equation\nfloat eikonal1d(float h, float v, float g)\n{\n    float hv = min(h, v);\n\treturn hv + g;\n}\n\nfloat eikonal2d(float h, float v, float g)\n{\n    float hv = h + v;\n    float d = hv*hv - 2.0 * (h*h + v*v - g*g);\n    if (d < g*g)\n        return eikonal1d(h, v, g);\n    else\n        return 0.5 * (hv + sqrt(d));\n}\n\nfloat neighborMin(vec2 coord, vec2 delta, float cur_sign)\n{\n    float a = texture(iChannel0, coord + delta).r;\n    a = a * cur_sign > 0.0 ? abs(a) : 0.0;\n    \n    float b = texture(iChannel0, coord - delta).r;\n    b = b * cur_sign > 0.0 ? abs(b) : 0.0;\n    \n    return min(a, b);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    int frame = iFrame;\n    vec2 pixel = fragCoord;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    float distAnalytical = distFunc(pixel).z;\n    \n    float dist = 0.0;\n    if (frame == 0)\n    {\n        dist = distAnalytical;\n        \n        // Clamp non-seed values to max\n#ifndef START_FROM_ANALYTICAL_RESULT\n        if (abs(dist) > seedRadius) dist = dist > 0.0 ? maxValue : -maxValue;\n#endif\n    }\n    else\n    {    \n        float xd = 1.0 / iResolution.x;\n        float yd = 1.0 / iResolution.y;\n        \n        float cur = texture(iChannel0, uv).r;\n        float cur_sign = cur > 0.0 ? 1.0 : -1.0;\n\n        float h = neighborMin(uv, vec2(xd, 0.0), cur_sign);\n        float v = neighborMin(uv, vec2(0.0, yd), cur_sign);\n        \n        dist = min(abs(cur), eikonal2d(h, v, 1.0)) * cur_sign;\n    }\n    \n    fragColor = vec4(dist, dist, dist, distAnalytical);\n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}