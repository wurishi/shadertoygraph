{"ver":"0.1","info":{"id":"cdlczH","date":"1686855495","viewed":504,"name":"Updated Analytic 3D Direct Light","username":"Mathis","description":"Improving the 3D direct illumination shader with better performance and shorter compilation time\nClosed form solution for diffuse direct illumination on a simple scene. GGX BRDF can also be used!\n\nUse WASD and mouse to move around","likes":33,"published":1,"flags":48,"usePreview":0,"tags":["3d","illumination","analytic","direct"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nDirect Light Integration\n\n\nControls\n    WASD to move\n        Space to move faster\n    Mouse to look around\n    Uncomment \"//#define PathTracing\" to path trace instead\n*/\n\n\n//#define PathTracing\n\n\nvec3 Integrate(vec3 P, vec3 N, int TriangleIndex) {\n    //Integral\n    float NEAR = 0.00001;\n    vec3 Integral = vec3(0.);\n    TriangleI VTris[(NTris-1)*2]; //Clipped geometry\n    Triangle3 OTris[(NTris-1)*3]; //Negative and positive emissive triangles\n    //Clip all geometry\n    int NVTris = 0; int NOTris;\n    for (int i=0; i<NTris; i++) {\n        //For all triangles\n        if (i==TriangleIndex) continue;\n        Triangle TriS = Triangles[i];\n        vec3 P0 = TriS.p0;\n        vec3 P1 = TriS.p1;\n        vec3 P2 = TriS.p2;\n        vec3 DotV = vec3(dot(N,TriS.p0-P),dot(N,TriS.p1-P),dot(N,TriS.p2-P));\n        bvec3 DotVb = bvec3(DotV.x>NEAR,DotV.y>NEAR,DotV.z>NEAR);\n        float NFront = dot(vec3(1.),vec3(DotVb));\n        if (NFront<0.5) {\n            //Triangle is behind P\n            continue;\n        } else if (NFront<1.5) {\n            //1 point in front of P\n            if (!DotVb.x) {\n                if (DotVb.y) {\n                    P1 = TriS.p0;\n                    P0 = TriS.p1;\n                } else {\n                    P2 = TriS.p0;\n                    P0 = TriS.p2;\n                }\n            }\n            vec3 IP0 = P0+(P1-P0)*(-dot(P0-P,N)/dot(P1-P0,N));\n            vec3 IP1 = P0+(P2-P0)*(-dot(P0-P,N)/dot(P2-P0,N));\n            VTris[NVTris] = TriangleI(P0,IP0,IP1,i);\n            NVTris += 1;\n        } else if (NFront<2.5) {\n            //2 points in front of P\n            if (DotVb.x) {\n                if (!DotVb.y) {\n                    P1 = TriS.p2;\n                    P2 = TriS.p1;\n                }\n            } else {\n                P0 = TriS.p2;\n                P1 = TriS.p1;\n                P2 = TriS.p0;\n            }\n            vec3 IP0 = P0+(P2-P0)*(-dot(P0-P,N)/dot(P2-P0,N));\n            vec3 IP1 = P1+(P2-P1)*(-dot(P1-P,N)/dot(P2-P1,N));\n            VTris[NVTris] = TriangleI(P0,IP0,P1,i);\n            VTris[NVTris+1] = TriangleI(P1,IP0,IP1,i);\n            NVTris += 2;\n        } else {\n            //Triangle is completely in front of P\n            VTris[NVTris] = TriangleI(TriS.p0,TriS.p1,TriS.p2,i);\n            NVTris += 1;\n        }\n    }\n    //Integrate\n    for (int SubjectIndex=0; SubjectIndex<NVTris; SubjectIndex++) {\n        //For all visible triangles\n        TriangleI CTri = VTris[SubjectIndex];\n        if (CTri.Index<6 || CTri.Index==TriangleIndex) continue;\n        vec3 Emissive = ((CTri.Index==7)?E7:E6);\n        Integral += Emissive*abs(SolidAngle(P,N,Triangle(CTri.p0,CTri.p1,CTri.p2,vec3(0.))));\n        //Attributes\n        vec3 CNor = normalize(cross(CTri.p1.xyz-CTri.p0.xyz,CTri.p2.xyz-CTri.p0.xyz));\n        CNor *= sign(dot(P-CTri.p0,CNor));\n        float CTanLen = length(CTri.p1-CTri.p0);\n        vec3 CTan = (CTri.p1-CTri.p0)/CTanLen;\n        vec3 CBit = normalize(cross(CTan,CNor));\n        //Occluder\n        int tmpNOTris = 1;\n        int NOTris = 1;\n        OTris[0] = Triangle3(CTri.p0,CTri.p1,CTri.p2,1.);\n        for (int OIndex=0; OIndex<NVTris; OIndex++) {\n            //For all visible triangles\n            TriangleI OTri = VTris[OIndex];\n            if (OTri.Index==CTri.Index) continue;\n            tmpNOTris = NOTris;\n            for (int oti=0; oti<tmpNOTris; oti++) {\n                //For every occluder triangle\n                Triangle3 OT = OTris[oti];\n                //Projection\n                float ssds,ssdC; vec3 VDot,TNormS,pp0,pp1,pp2,IFDir,ssns,ssnC; vec3 TPOut[6],TPIn[6];   \n                //Triangle intersection: https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm\n                int NPoints = 3; int OutPoints = 3; pp0 = OTri.p0; pp1 = OTri.p1; pp2 = OTri.p2;\n                vec3 LTan,tmpp0,cpp,cppPrev,cppIntersect;\n                TPOut = vec3[6](OT.p0,OT.p1,OT.p2,vec3(0.),vec3(0.),vec3(0.));\n                for (int SH=0; SH<3; SH++) { //For every clip-line in the clipping triangle\n                    LTan = normalize(cross(pp0-P,pp0-pp1));\n                    LTan = LTan*sign(dot(LTan,pp2-pp0));\n                    TPIn = TPOut;\n                    NPoints = OutPoints;\n                    OutPoints = 0;\n                    cppPrev = TPIn[NPoints-1];\n                    for (int ci=0; ci<NPoints; ci++) { //For every point in the subject polygon\n                        cpp = TPIn[ci];\n                        cppIntersect = cpp-(cpp-cppPrev)*dot(cpp-pp0,LTan)/dot(cpp-cppPrev,LTan);\n                        if (dot(cpp-pp0,LTan)>=0.) {\n                            if (dot(cppPrev-pp0,LTan)<0.) {\n                                //Enough precision\n                                TPOut[OutPoints] = cppIntersect;\n                                OutPoints += 1;\n                            }\n                            TPOut[OutPoints] = cpp;\n                            OutPoints += 1;\n                        } else if (dot(cppPrev-pp0,LTan)>=0.) {\n                            TPOut[OutPoints] = cppIntersect;\n                            OutPoints += 1;\n                        }\n                        cppPrev = cpp;\n                    }\n                    tmpp0 = pp0;\n                    pp0 = pp1;\n                    pp1 = pp2;\n                    pp2 = tmpp0;\n                }\n                //Add occluded geometry as signed emissive triangles\n                if (OutPoints>=3) {\n                    //In front test\n                    IFDir = normalize((TPOut[0]+TPOut[1]+TPOut[2])/3.-P);\n                    bool BTCT = TriangleA(P,IFDir,CTri.p0,CTri.p1,CTri.p2,ssdC,ssnC);\n                    bool BTst = TriangleA(P,IFDir,OTri.p0,OTri.p1,OTri.p2,ssds,ssns);\n                    if (ssdC>=ssds) {\n                        //A clipped polygon -> 1 or more triangles\n                        pp0 = TPOut[0];\n                        pp1 = TPOut[1];\n                        for (int it=2; it<OutPoints; it++) {\n                            Triangle3 tmpWT = Triangle3(pp0,pp1,TPOut[it],-OT.Sign);\n                            Integral -= Emissive*abs(SolidAngle(P,N,Triangle(tmpWT.p0,tmpWT.p1,tmpWT.p2,vec3(0.))))*OT.Sign;\n                            OTris[NOTris] = tmpWT;\n                            NOTris += 1;\n                            pp1 = TPOut[it];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    //Return\n    return max(vec3(0.),Integral)/(2.*PI);\n}\n\nvec3 acesFilm(vec3 x) {\n    //Aces film curve\n    return clamp((x*(2.51*x+0.03))/(x*(2.43*x+0.59)+0.14),0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Epic animated triangles\n    float tAngle = iTime*0.7;\n    int TriIndex = 2;\n    for (float fti=0.; fti<2.5; fti++) {\n        tAngle += 2.0943951;\n        vec3 RotVec = vec3(sin(tAngle),cos(tAngle),0.);\n        vec3 RotTan = vec3(-RotVec.y*0.,RotVec.x*0.+1.,0.)*0.79;\n        vec3 RotPos = vec3(0.,1.6,0.)+RotVec*0.8;\n        Triangles[TriIndex] = Triangle(RotPos+RotTan,RotPos-RotTan,RotPos+vec3(0.4,0.,-1.5),vec3(0.99));\n        TriIndex += 1;\n    }\n    float Sine = sin(iTime*1.5);\n    float Scale = (pow(abs(Sine),0.25)*sign(Sine)*0.5+0.5);\n    vec3 RotVec = vec3(-0.6,0.,1.)*(0.8999+Scale*0.9);\n    vec3 RotPos = vec3(-1.,0.,-1.8);\n    Triangles[5] = Triangle(RotPos+RotVec,RotPos-RotVec,RotPos+RotVec*0.5+vec3(0.2,1.5+Scale*1.5,0.),vec3(0.99));\n    //Pos\n    vec3 Color = vec3(0.);\n    vec3 SunDir = texture(iChannel0,vec2(5.5,0.5)*IRES).xyz;\n    vec3 Pos = texture(iChannel0,vec2(3.5,0.5)*IRES).xyz;\n    vec3 Eye = texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n    vec3 Dir = normalize(vec3((fragCoord*IRES*2.-1.)*(ASPECT*CFOV),1.)*TBN(Eye));\n    //Render scene\n    HIT Pixel = TraceRay(Pos,Dir,-1);\n    if (Pixel.D<9990.) {\n        if (Pixel.Index==7) {\n            Color = E7;\n        } else if (Pixel.Index==6) {\n            Color = E6;\n        } else {\n            vec3 Integral = vec3(0.);\n            #ifdef PathTracing\n                //Path tracing\n                vec3 Diffuse = vec3(0.);\n                float NSamples = 64.;\n                for (float i=0.; i<NSamples-0.5; i++) {\n                    vec3 rdir = RandSample(texture(iChannel3,(fragCoord+i*(vec2(314.734,517.394)))/1024.).zw)*TBN(Pixel.N);\n                    HIT RefHit = TraceRay(Pixel.P+Pixel.N*0.001,rdir,Pixel.Index);\n                    if (RefHit.D<99990.) {\n                        if (RefHit.Index==6) Diffuse += E6;\n                        if (RefHit.Index==7) Diffuse += E7;\n                    }\n                }\n                Integral = Diffuse/NSamples;\n            #else\n                //Integral\n                Integral += Integrate(Pixel.P,Pixel.N,Pixel.Index);\n            #endif\n            //Color\n            Color = Pixel.C*Integral;\n        }\n    } else {\n        //Sky\n        Color = vec3(0.);\n    }\n    //Output\n    fragColor = vec4(pow(acesFilm(Color),vec3(0.45)),1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Settings\nconst float FOV = 0.7; //In radians\n\n//Other vars\nconst int NTris = 8;\nconst vec3 E7 = vec3(0.3,0.9,1.)*3.;\nconst vec3 E6 = vec3(1.,0.35,0.05)*3.;\nconst float CFOV = tan(FOV);\nconst float PI = 3.141592653;\n#define RES iResolution.xy\n#define IRES (1./iResolution.xy)\n#define ASPECT vec2(iResolution.x/iResolution.y,1.)\n\nstruct HIT { float D; vec3 P; vec3 N; vec3 C; int Index; };\nstruct Triangle { vec3 p0; vec3 p1; vec3 p2; vec3 C; };\n//struct Triangle2 { vec2 p0; vec2 p1; vec2 p2; float Sign; };\nstruct Triangle3 { vec3 p0; vec3 p1; vec3 p2; float Sign; };\nstruct TriangleI { vec3 p0; vec3 p1; vec3 p2; int Index; };\n\nTriangle Triangles[NTris]=Triangle[NTris](\n        Triangle(vec3(-64.,0.,3.),vec3(0.,0.,-64.),vec3(64.,0.,3.),vec3(1.)), //Floor\n        Triangle(vec3(-4.,0.,0.),vec3(4.,0.,0.),vec3(0.,1024.,0.),vec3(1.)), //Wall\n        //Occluders\n        Triangle(vec3(0.,0.6,0.5),vec3(-0.3,0.000,0.5),vec3(0.3,0.,0.5),vec3(0.4,0.4,1.)),\n        Triangle(vec3(0.,0.6,0.5),vec3(-0.3,0.000,0.5),vec3(0.3,0.,0.5),vec3(0.4,0.4,1.)),\n            Triangle(vec3(-0.3,0.,0.6),vec3(-0.1,0.,1.),vec3(-0.2,0.9,0.75),vec3(0.4,0.4,1.)),\n            Triangle(vec3(0.3,0.,-1.4),vec3(0.9,0.,-2.9),vec3(0.6,1.7,-2.15),vec3(0.4,0.4,1.)),\n        //Emissive\n            Triangle(vec3(-2.5,0.0001,-0.0001),vec3(-2.5,0.0001,-2.5),vec3(-2.5,2.5,-2.5),vec3(1.)), //Quad\n            Triangle(vec3(-2.5,0.0001,-0.0001),vec3(-2.5,2.5,-0.0001),vec3(-2.5,2.5,-2.5),vec3(1.))\n        );\n\nmat3 TBN(vec3 N) {\n    vec3 Nb,Nt;\n    if (abs(N.y)>0.999) {\n        Nb = vec3(1.,0.,0.);\n        Nt = vec3(0.,0.,1.);\n    } else {\n    \tNb = normalize(cross(N,vec3(0.,1.,0.)));\n    \tNt = normalize(cross(Nb,N));\n    }\n    return mat3(Nb.x,Nt.x,N.x,Nb.y,Nt.y,N.y,Nb.z,Nt.z,N.z);\n}\n\nvec3 TBN(vec3 N, out vec3 O) {\n    O = normalize(cross(N,vec3(0.001,1.,0.)));\n    return normalize(cross(O,N));\n}\n\nvec3 RandSample(vec2 v) {\n    float theta = sqrt(v.x);\n    float phi = 2.*3.14159*v.y;\n    float x = theta*cos(phi);\n    float z = theta*sin(phi);\n    return vec3(x,z,sqrt(max(0.,1.-v.x)));\n}\n\nbool TriangleA(vec3 p, vec3 d, vec3 p0, vec3 p1, vec3 p2, out float hit, out vec3 triN) {\n    //From https://github.com/Jojendersie/gpugi/blob/5d18526c864bbf09baca02bfab6bcec97b7e1210/gpugi/shader/intersectiontests.glsl#L63\n    vec3 e0 = p1-p0;\n    vec3 e1 = p0-p2;\n    triN = cross(e1,e0);\n    vec3 e2 = (1./dot(triN,d))*(p0-p);\n    vec3 i  = cross(d,e2);\n    vec3 barycentricCoord = vec3(0.);\n    barycentricCoord.y = dot(i,e1);\n    barycentricCoord.z = dot(i,e0);\n    barycentricCoord.x = 1.-(barycentricCoord.z+barycentricCoord.y);\n    hit = dot(triN,e2);\n    return  (hit>=0.) && all(greaterThanEqual(barycentricCoord,vec3(0.)));\n    //return (hit>NEAR) && all(greaterThanEqual(barycentricCoord,vec3(0.)));\n}\n\nHIT TraceRay(vec3 Pos, vec3 Dir, int IgnoreIndex) {\n    //Ray tracing against geometry\n    float sd; float D = 10000.; Triangle Sample; vec3 sn;\n    HIT OUT = HIT(D,vec3(0.),vec3(0.),vec3(0.),-1);\n    for (int i=0; i<NTris; i++) {\n        if (i==IgnoreIndex) continue;\n        Sample = Triangles[i];\n        if (TriangleA(Pos,Dir,Sample.p0,Sample.p1,Sample.p2,sd,sn)) {\n            if (sd<D) {\n                D = sd;\n                OUT = HIT(D,Pos+Dir*D,sn,Sample.C,i);\n            }\n        }\n    }\n    OUT.N = normalize(OUT.N)*sign(dot(-Dir,OUT.N));\n    return OUT;\n}\n\nfloat SolidAngle(vec3 P, vec3 N, Triangle Tri) {\n    //Returns the solid angle for a visible triangle\n    vec3 v0 = normalize(Tri.p0-P);\n    vec3 v1 = normalize(Tri.p1-P);\n    vec3 v2 = normalize(Tri.p2-P);\n    float ret = abs(dot(N,normalize(cross(v0,v1)))*acos(dot(v0,v1))+\n                dot(N,normalize(cross(v1,v2)))*acos(dot(v1,v2))+\n                dot(N,normalize(cross(v2,v0)))*acos(dot(v2,v0)));\n    return ((isnan(ret))?0.:ret);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Storage\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 Color = texture(iChannel0,fragCoord.xy/iResolution.xy);\n    if (iFrame==0) { //Initialization\n        if (fragCoord.x<10. && fragCoord.y<1.) { //Store vars\n            if (fragCoord.x<1.) Color = vec4(0.,0.,0.,0.); //Mouse\n            else if (fragCoord.x<2.) Color = vec4(-0.5,-0.05,0.,0.); //Player Eye (Angles)\n            else if (fragCoord.x<3.) Color = vec4(0.,0.,0.,1.); //Player Eye (Vector)\n            else if (fragCoord.x<4.) Color = vec4(-0.3,3.,-4.,1.); //Player Pos\n        }\n    } else { //Update\n\t\tif (fragCoord.x<16. && fragCoord.y<1.) { //Update vars\n            if (fragCoord.x<1.) { //Mouse\n                if (iMouse.z>0.) { //Börjat klicka\n                    if (Color.w==0.) {\n                    \tColor.w = 1.;\n                    \tColor.xy = iMouse.zw;\n                    }\n                } else Color.w = 0.;\n            } else if (fragCoord.x<2.) { //Player Eye (Angles)\n                vec4 LMouse = texture(iChannel0,vec2(0.5,0.5)*IRES);\n                if (LMouse.w==0.)  Color.zw = Color.xy;\n                if (LMouse.w==1.) {\n                \t//Y led\n                \tColor.x = Color.z+(iMouse.y-LMouse.y)*0.01;\n                \tColor.x = clamp(Color.x,-2.8*0.5,2.8*0.5);\n                \t//X led\n                \tColor.y = Color.w-(iMouse.x-LMouse.x)*0.02;\n               \t\tColor.y = mod(Color.y,3.1415926*2.);\n                }\n            } else if (fragCoord.x<3.) { //Player Eye (Vector)\n                vec3 Angles = texture(iChannel0,vec2(1.5,0.5)*IRES).xyz;\n                Color.xyz = normalize(vec3(cos(Angles.x)*sin(Angles.y),\n                  \t\t\t   \t\t\tsin(Angles.x),\n                  \t\t\t   \t\t\tcos(Angles.x)*cos(Angles.y)));\n            } else if (fragCoord.x<4.) { //Player Pos\n                float Speed = iTimeDelta;\n                if (texelFetch(iChannel1,ivec2(32,0),0).x>0.) Speed = 5.*iTimeDelta;\n                vec3 Eye=texture(iChannel0,vec2(2.5,0.5)*IRES).xyz;\n                if (texelFetch(iChannel1,ivec2(87,0),0).x>0.) Color.xyz += Eye*Speed; //W\n                if (texelFetch(iChannel1,ivec2(83,0),0).x>0.) Color.xyz -= Eye*Speed; //S\n                vec3 Tan = normalize(cross(vec3(Eye.x,0.,Eye.z),vec3(0.,1.,0.)));\n                if (texelFetch(iChannel1,ivec2(65,0),0).x>0.) Color.xyz -= Tan*Speed; //A\n                if (texelFetch(iChannel1,ivec2(68,0),0).x>0.) Color.xyz += Tan*Speed; //D\n            }\n        }\n    }\n    fragColor = Color;\n}","name":"Buffer A","description":"","type":"buffer"}]}