{"ver":"0.1","info":{"id":"4l2BzK","date":"1516515125","viewed":92,"name":"First shader: raytracer","username":"Axioplase","description":"Basic raytracer. Next step will be reflections, I guess?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct sphere_t {\n    int id;\n    vec3 center;\n    float radius;\n    vec3 colour;\n};\n\nstruct hit_t {\n    vec3 hitPos;\n    int sphere_id;\n};\n\nvec3 r = vec3(.5,0.,0.);\nvec3 g = vec3(0.,.5,0.);\nvec3 b = vec3(0.,0.,.5);\nsphere_t spheres[4];\nfloat pi = 3.14159265;\n\nvec3 showLightSource(in vec3 orig, in vec3 direction, in vec3 source) {\n    return vec3(smoothstep(0.2, .9, 0.051/length(cross(source-orig, direction))/length(direction)));\n}\n\nvec3 normalAtHitPoint(in hit_t hit) {\n\tsphere_t s = spheres[hit.sphere_id];\n\treturn normalize(hit.hitPos - s.center);\n}\n\nbool inSphere(in vec3 pos, in int sphere_id) {\n    sphere_t sphere = spheres[sphere_id];\n    return (length(pos - sphere.center) <= sphere.radius);\n}\n\nvoid castRay(in vec3 orig, in vec3 direction, in int sphere_id, inout hit_t store) {\n    sphere_t sphere = spheres[sphere_id];\n    \n    vec3 l = sphere.center - orig;\n    float ta = dot(l, direction);\n    \n    if (ta <= 0.) { //sphere.radius) {\n        return; // we're inside the sphere, or it's behind us. Let's ignore.\n    }\n    \n    float d = sqrt(dot(l,l) - ta*ta);\n        \n    if (d >= sphere.radius) {\n        return; // no intersection\n    }\n    \n    vec3 proj = orig + direction*ta; // This is the projection of center on ray.\n    \n    float distFromProjSoThatOnSphere = sqrt(sphere.radius * sphere.radius - d*d);\n    vec3 vectorsToIntersections = direction*distFromProjSoThatOnSphere;\n    vec3 intersection1 = proj - vectorsToIntersections; // closer\n    vec3 intersection2 = proj + vectorsToIntersections;\n    vec3 bestHit;\n    // just in case\n    if(length(intersection1 - orig) <= length(intersection2 - orig)) {\n    \tbestHit = intersection1;\n    } else {\n        bestHit = intersection2;\n    }\n\n    float distanceToOrigin = length(bestHit - orig);\n    if (distanceToOrigin < length(store.hitPos - orig)) {\n        store.sphere_id = sphere_id;\n        store.hitPos = bestHit;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5; // center\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor.w = 1.;\n    \n    vec3 lightSource = vec3(1.5*cos(iTime/3. + pi/3.), 1.5*sin(iTime/2. + pi/3.),10.+4.*sin(iTime));\n    vec3 camera = vec3(4.*cos(iTime), 0., 4.*sin(iTime));\n    vec3 lookAt = vec3(1.2*cos(iTime/3. + pi/3.), 1.2*sin(iTime/2. + pi/3.), 10.+3.5*sin(iTime));\n    vec3 f = normalize(lookAt - camera);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f, r);\n    //vec3 direction = normalize(vec3(uv.x, uv.y, 0.) - camera);\n    float zoom = 2.0;\n    vec3 center = camera + f * zoom;\n    vec3 i = center + uv.x*r + uv.y*u;\n    vec3 direction = normalize(i - camera);\n\n    // Show a light. It'll be masked if behind a sphere.\n    fragColor.xyz = showLightSource(camera, direction, lightSource);\n\n    spheres[0].radius=.5;\n    spheres[0].colour=r;\n    spheres[0].center=vec3(cos(iTime), sin(iTime), 10.0);\n    spheres[0].id = 0;\n\n    spheres[1].radius=.4;\n    spheres[1].colour=g;\n    spheres[1].center=vec3(cos(iTime + 2.*pi/3.), sin(iTime + 2.*pi/3.), 11.0);\n    spheres[1].id = 1;\n    \n    spheres[2].radius=.6;\n    spheres[2].colour=b;\n    spheres[2].center=vec3(cos(iTime + 4.*pi/3.), sin(iTime + 4.*pi/3.), 12.0);\n    spheres[2].id = 2;\n\n    spheres[3].radius=5.;\n    spheres[3].colour=vec3(1.);\n    spheres[3].center=vec3(0., 0., 24.5);\n    spheres[3].id = 3;\n\n\n    // If the light is in another sphere, then all is dark\n    for (int i = 0; i < 4; i++) {\n        if (inSphere(lightSource, i)) {\n            fragColor = vec4(0.);\n        }\n    }\n    \n    // render all spheres\n    hit_t closest;\n    closest.hitPos = vec3(1e3); // far away\n    closest.sphere_id = -1; // not_found\n    for (int i = 0; i < 4; i++) {\n        castRay(camera, direction, i, closest);\n    }\n    \n    // there was no hit, so return the backgroud\n    if (closest.sphere_id == -1) {\n       return;\n    }\n\n    // there was a hit\n    sphere_t s = spheres[closest.sphere_id];\n    vec3 hitPos = closest.hitPos;\n    vec3 normal = normalAtHitPoint(closest);\n\n    // add lighting\n    // We'll cast a ray from the intersection point to the light.\n    vec3 newDirection = normalize(lightSource - hitPos);\n    hit_t lightHit;\n    lightHit.hitPos = vec3(1e3); // there's no null value to initialize with\n    lightHit.sphere_id = -1; // idem\n    \n    for (int i = 0; i < 4; i++) {\n   \n        // avoid hitting yourself\n        if (i == s.id) {\n            continue;\n        }\n        \n        // If the light is in another sphere, then all is dark\n        if (inSphere(lightSource, i)) {\n            fragColor = vec4(0.);\n            return;\n        }\n\n        castRay(hitPos, newDirection, i, lightHit);\n    }\n\n    float dist = length(hitPos - lightSource);\n    vec3 coul = 2.*dot(newDirection, normal)*s.colour/(dist);\n    // if there was nothing between the intersection and the light source, add some light!\n        if (lightHit.sphere_id == -1) {\n\t    fragColor.xyz += coul;\n    } else {\n        // we hit something in front.\n        if (dot(lightSource - hitPos, lightHit.hitPos - hitPos) >= 0. ) {\n            // light is closer than new hit point\n            if (length(lightSource - hitPos) < length(lightHit.hitPos - hitPos)) {\n                fragColor.xyz = coul;    \n            }\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}