{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\nvec3 lightDir = normalize(vec3(40.0,40.0,40.0));\n\nconst float viewDist = 200.0;\n\nconst float EPILSON = 0.001;\nconst int maxIter = 1024;\n\nvec3 cameraUp = vec3(0.0,1.0,0.0);\nvec3 cameraRight,cameraPosition,cameraDirection;\n\nvec3 rayPos;\nvec3 startRayPos,startRayDir;\n\n\nconst vec3 pos = vec3(0.0,0.0,0.0);\nconst vec3 size = vec3(30.0,20.0,30.0);\nconst vec3 maxSize = vec3(36.0,26.0,36.0);\nconst vec3 space = vec3(4.0,4.0,4.0);\nconst vec3 repeatSize = vec3(8.0,8.0,8.0);\n\n\nfloat endlessFloorMap() {\n    return abs(-10.0-rayPos.y);\n}\n\n#define prec 0.1\nfloat distMap(vec3 r) {\n    float cubeLen = length(max(abs(r)-maxSize,0.0));\n    \n    if (cubeLen <= prec) {\n        vec3 rIn = r;\n        rIn += texture(iChannel2,normalize(rIn)).xyz*6.0;\n        return min(prec,length(max(abs(rIn)-size,0.0)));\n    }\n    \n    return cubeLen;\n}\n#define NORMAL_EPILSON 0.1\nvec3 distMapNormal(vec3 p) {\n    return normalize(vec3(\n        distMap(vec3(p.x+NORMAL_EPILSON,p.y,p.z))-distMap(vec3(p.x-NORMAL_EPILSON,p.y,p.z)),\n        \n\t\tdistMap(vec3(p.x,p.y+NORMAL_EPILSON,p.z))-distMap(vec3(p.x,p.y-NORMAL_EPILSON,p.z)),\n        \n        distMap(vec3(p.x,p.y,p.z+NORMAL_EPILSON))-distMap(vec3(p.x,p.y,p.z-NORMAL_EPILSON))\n        ));\n}\n\n\nfloat trace() {\n    float scal = 0.0,dist = 0.0;\n    \n    for (int i = 0; i < maxIter; i++) {\n        \n        rayPos = startRayPos+startRayDir*scal;\n        \n        dist = distMap(rayPos);\n        dist = min(dist,endlessFloorMap());\n        \n        if (dist <= EPILSON) {\n            return dist;\n        }\n        if (scal > viewDist) {\n            break;\n        }\n        \n        scal += dist+EPILSON;\n        \n    }\n    \n    return viewDist;\n}\n\n\nvec4 colorMap() {\n    if (rayPos.y <= -9.8) {//ground\n        return texture(iChannel1,rayPos.xz*0.1);\n    }\n    \n    \n    //cube\n    vec4 samp = texture(iChannel2,normalize(rayPos));\n    return samp*0.3+\n        samp*max(0.0,dot(lightDir,distMapNormal(rayPos)));\n}\n\n\nvec4 scene() {\n    \n\tfloat d = trace();\n    \n    if (d < viewDist) {\n        return colorMap();\n    }\n    \n\treturn vec4(0.0);\n}\n\n\n\n\nconst float cameraMoveSpeed = 0.2;\n\nconst vec2 center = vec2(0.5,0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //calculate camera\n    cameraPosition = vec3(sin(iTime*cameraMoveSpeed)*60.0,sin(iTime)*10.0+10.0,cos(iTime*cameraMoveSpeed)*60.0);\n    cameraDirection = normalize(-cameraPosition);\n    \n\tvec2 cUv = (fragCoord.xy / iResolution.xy)-center;\n    cUv.x *= iResolution.x/iResolution.y;\n\t\n    //camera vectors\n    cameraRight = cross(cameraDirection,cameraUp);\n    cameraUp = cross(cameraRight,cameraDirection);\n    \n    //calculate perspective ray from uv and camera vectors\n    vec3 rPoint = cUv.x*cameraRight +\n                  cUv.y*cameraUp +\n        \t\t  cameraPosition + cameraDirection;\n    \n  \tstartRayDir = normalize(rPoint-cameraPosition);\n    startRayPos = cameraPosition;\n    \n    \n    fragColor = scene();\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"llfGDN","date":"1422827482","viewed":1043,"name":"displacement map","username":"public_int_i","description":"saw trisnomie using tex cubes for displacement and wanted to try it myself.\nEDIT: added color from the texture cube :)\nEDIT2: made the displacement way bigger","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["ray","displacement","distance","march"],"hasliked":0,"parentid":"","parentname":""}}