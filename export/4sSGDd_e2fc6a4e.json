{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define FARCLIP    35.0\n\n#define MARCHSTEPS 90\n\n#define PI         3.14\n#define PI2        PI*0.5    \n\n#define MAT1       1.0\n\n#define FOV 1.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\n\nvec2 rot(vec2 k, float t) {\n    float ct=cos(t); \n    float st=sin(t);\n    return vec2(ct*k.x-st*k.y,st*k.x+ct*k.y);\n}\n\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=1./l;\n\tfloat ofs=s+s/(r*2.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n/***********************************************\nfloat hash(float n) { \n\treturn fract(sin(n)*43758.5453123); \n}\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + p.z*113.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n/***********************************************/\n\nvec2 DE(vec3 p) {\n\nvec3 q=p;\n    //ball\n    oprep2(p.xz,8.0,0.1, -iTime);\n    oprep2(p.zy,16.0,0.25, -iTime); \n    float t=rbox(p,vec3(0.25,0.025,0.1),0.05);   \n   //tube\n\n    p=q; \n    p.y-=1.0;  \n    p.xy=rot(p.xy,p.z*0.15); \n    p.z+=iTime;\n    p.xy=mod(p.xy,6.0)-0.5*6.0;    \n    p.xy=rot(p.xy,-floor(p.z/0.75)*0.35);   \n    p.z=mod(p.z,0.75)-0.5*0.75;\n    oprep2(p.xy,3.0,0.15, iTime);  \n    \n    float c=rbox(p,vec3(0.1,0.025,0.25),0.05);\n   //tube\n  p=q; \n    p.y+=2.0;  \n    p.yz=rot(p.yz,p.x*0.15); \n    p.x+=iTime;\n    p.yz=mod(p.yz,6.0)-0.5*6.0;    \n    p.yz=rot(p.yz,-floor(p.x/0.75)*0.35);   \n    p.x=mod(p.x,0.75)-0.5*0.75;\n    oprep2(p.yz,3.0,0.15, iTime);  \n    float r=rbox(p,vec3(0.25,0.1,0.025),0.05);\n    \n  t= min(min(t,c),r);\n \n\treturn vec2( t*0.85 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.01,-0.01,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -10.0);\n\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n\t\n//\tfloat ma=iTime*0.2+ sin(iTime*0.5);\n//\tfloat mb=iTime*0.1- cos(iTime*0.1);\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n    ro.xz=rot(ro.xz,iTime*0.23);\n    ro.xy=rot(ro.xy,iTime*0.12);\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,1.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( FOV*p.x*cr + FOV*p.y*cu + 2.5*cf );\n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\n        if( r.x<0.0 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\t\n\t\n\tfloat lp=sin(iTime)+1.5;\n    vec3 nor=normal(ww);\n\n\tif( r.x<FARCLIP ) {\n\n        col=vec3(0.43,0.84,0.97); \n\n    \tfloat amb=0.5;\t\n    \tfloat dif=0.5*clamp(dot(ww,-nor),-1.0,1.0);\n    \tfloat bac=0.2*clamp(dot(ww,nor),0.0,1.0);\n\n\t    col *= amb + dif +bac;\n\t    \n\t    float spe= pow(clamp( dot( nor, reflect(ww,nor) ), 0.0, 1.0 ) ,16.0 );\n\t    col += 0.5*pow(spe,1.0);\n\n        col*=lp;\n\n        col*=exp(-0.2*r.x); col*=1.5;\n\t} \n      \n    /* sun */\n    vec3 lpos=vec3(0.0, 0.0, 0.0);\n    \n\tfloat m = dot(rd, -ro);\n\t      d = length(ro-lpos+m*rd);\n\t\n\tfloat a = -m;\n\tfloat b = r.x-m;\n\tfloat aa = atan(a/d);\n\tfloat ba = atan(b/d);\n\tfloat to = (ba-aa)/d;\n\n    col+=to*0.15*lp;\n    /* sun */\n\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sSGDd","date":"1394949557","viewed":4413,"name":"abstract","username":"avix","description":"just bored and goofing around a bit...","likes":28,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarch"],"hasliked":0,"parentid":"","parentname":""}}