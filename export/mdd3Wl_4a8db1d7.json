{"ver":"0.1","info":{"id":"mdd3Wl","date":"1680559242","viewed":122,"name":"Futurama Head In A Jar 3.1.1","username":"foodini","description":"Change BufferB channel 3 to webcam. Press X to clear debug.\n\nThis is the ray tracer I've been developing for a while. I've merged in the debugger from another shader I wrote. I need to get it documented and update the comments on features and fixes.","likes":4,"published":1,"flags":48,"usePreview":1,"tags":["debugging"],"hasliked":0,"parentid":"mdc3WX","parentname":"printf Debugging Shaders v1.2.0!"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// There are EIGHT coordinates reserved by this system. fragCoord == \n\n// iMouse.xy: fragCoord + 0.5 of the last mouse event \n// iMouse.z: Mouse button currently down.\n// iMouse.w: Mousedown event\n\n// fragCoord will be 0.5, 1.5, 2.5, etc.\n// iMouse will be 0.0, 1.0, 2.0... I've no fucking idea why.\n\n//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C_r2l(c) out_color += char(U,64+c).xxxx; U.x+=.5\n#define C_l2r(c) out_color += char(U,64+c).xxxx; U.x-=.5\n\n#define _SPACE -32\n#define _MINUS -19\n#define _PERIOD -18\n#define _SLASH -17\n#define _A 1\n#define _B 2\n#define _C 3\n#define _D 4\n#define _E 5\n#define _F 6\n#define _G 7\n#define _H 8\n#define _I 9\n#define _J 10\n#define _K 11\n#define _L 12\n#define _M 13\n#define _N 14\n#define _O 15\n#define _P 16\n#define _Q 17\n#define _R 18\n#define _S 19\n#define _T 20\n#define _U 21\n#define _V 22\n#define _W 23\n#define _X 24\n#define _Y 25\n#define _Z 26\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n#define BLACK vec4(0.0) \n#define WHITE vec4(1.0)\n\nvec4 draw_float(in float f, in vec2 position, in float fract_digits, in float font_size, in vec2 uv) {\n    vec4 out_color = vec4(0.0);\n    bool negative = false;\n\n    if(f == reserved_float) {\n        return vec4(0.0);\n    }\n\n\n    if(f < 0.0) {\n        negative = true;\n        f = -f;\n    }\n\n    // Add juuuuust enough to f that we'll round off the last digit. It'll turn\n    // 0.999999 into 0.9999995 which will then round off to 1.000000. Given how\n    // often normalized axial vectors end up being <0.999999, 0.0, 0.0>, this is\n    // a good thing.\n    f += 5.0 * pow(10.0, -(fract_digits + 1.0));\n\n    vec2 U = (uv - position)*64.0/font_size;\n    // Not sure I can explain this. It has to do with the default-to-centering of the font system and\n    // the left-to-right nature of printing in most cases.\n    U.x += (0.50 + 0.25); \n\n    int fraction = int(fract(f) * pow(10.0, fract_digits));\n    for(float i=0.0; i<fract_digits; i+=1.0) {\n        C_r2l((fraction%10) - 16);\n        fraction /= 10;\n    }\n    if(fract_digits > 0.0) {\n        C_r2l(_PERIOD); // decimal point\n    }\n    \n    int mantissa = int(f);\n    \n    do{\n        C_r2l(mantissa%10 - 16);\n        mantissa /= 10;\n    } while(mantissa != 0);\n    if(negative) {\n        C_r2l(_MINUS);\n    }\n    \n    return out_color;\n}\n\nvec4 draw_char(in int c, in vec2 position, in float font_size, in vec2 uv) {\n    vec4 out_color = vec4(0.0);\n\n    vec2 U = (uv - position)*64.0/font_size;\n    // Not sure I can explain this. It has to do with the default-to-centering of the font system and\n    // the left-to-right nature of printing in most cases.\n    U.x += (0.25); \n    C_l2r(c);\n    \n    return out_color;\n}\n\nvec4 draw_string(in int[10]s, in vec2 position, in float font_size, in vec2 uv) {\n    vec4 out_color = vec4(0.0);\n\n    vec2 U = (uv - position)*64.0/font_size;\n    // Not sure I can explain this. It has to do with the default-to-centering of the font system and\n    // the left-to-right nature of printing in most cases.\n    U.x += (0.25); \n\n    for(int i=0; i<10; i++) {\n        C_l2r(s[i]);\n    }\n\n    return out_color;\n}\n\nint fps_string[10] = int[10](_F, _P, _S, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE);\nint normal_string[10] = int[10](_N, _O, _R, _M, _A, _L, _SPACE, _SPACE, _SPACE, _SPACE);\nint color_string[10] = int[10](_C, _O, _L, _O, _R, _SPACE, _SPACE, _SPACE, _SPACE, _SPACE);\nint distance_string[10] = int[10](_D, _I, _S, _T, _A, _N, _C, _E, _SPACE, _SPACE);\nint iterations_string[10] = int[10](_I, _T, _E, _R, _A, _T, _I, _O, _N, _S);\nvec4 debug_overlay(vec2 fragCoord) {\n    vec2 uv = fragCoord_to_uv(iResolution, fragCoord);\n    \n    vec4 out_color = BLACK;\n\n    float fps = 1.0/iTimeDelta;\n    float font_size = 2.9;\n    float char_width = font_size / 128.0;\n    float char_height = font_size / 64.0;\n\n    vec2 bottom_right = vec2(1.0, -0.57);\n    vec2 position = bottom_right - vec2(char_width * 13.0, 0.0);\n    out_color += draw_float(iResolution.x, position, 0.0, font_size, uv);\n    position = bottom_right - vec2(char_width * 13.0, 0.0);\n    out_color += draw_char(_X, position, font_size, uv);\n    position = bottom_right - vec2(char_width * 8.0, 0.0);\n    out_color += draw_float(iResolution.y, position, 0.0, font_size, uv);    \n    position = bottom_right - vec2(char_width * 3.0, 0.0);\n    out_color += draw_float(fps, position, 1.0, font_size, uv);\n    position = bottom_right - vec2(char_width * 3.0, 0.0);\n    out_color += draw_string(fps_string, position, font_size, uv);\n\n    float str_left_side = -0.99;\n    float val_left_side = -0.33;\n    float first_row = 0.51;\n    float skip_right = 0.44;\n    float skip_down = char_height * 0.75;\n    position.y = first_row+skip_down;\n    vec4 texel;\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = get_val_at_index(0.0);\n    out_color += draw_string(normal_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.r, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.g, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.b, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.a, position, 6.0, font_size, uv);\n#endif\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = get_val_at_index(1.0);\n    out_color += draw_string(color_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.r, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.g, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.b, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.a, position, 6.0, font_size, uv);\n#endif\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = get_val_at_index(2.0);\n    out_color += draw_string(distance_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.r, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.g, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.b, position, 6.0, font_size, uv);\n    position.x += skip_right;\n    out_color += draw_float(texel.a, position, 6.0, font_size, uv);\n#endif\n#if 1\n    position.x = str_left_side;\n    position.y -= skip_down;\n    \n    texel = get_val_at_index(3.0);\n    out_color += draw_string(iterations_string, position, font_size, uv);\n    position.x = val_left_side;\n    out_color += draw_float(texel.r, position, 1.0, font_size, uv);\n#endif\n#if 1\n    //I'm just using this for any uniform I want to track. iMouse, iFrame, etc.\n    position.x = -0.75;\n    position.y = -0.57;\n    out_color += draw_float(float(iTimeDelta), position, 4.0, font_size, uv);\n#endif\n\n    return out_color;\n}\n\nbool key_toggle_state(float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.75);\n    float key = texture(iChannel2, uv).r;\n\n    return key > 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n#if DEBUG\n    fragColor = max(vec4(0.0), fragColor);\n    if(key_toggle_state(88.0)) {\n        return;\n    }\n    fragColor += debug_overlay(fragCoord);\n    fragColor = min(vec4(1.0), fragColor);\n    \n    float empty_radius = 3.0;\n    float reticle_size = 20.0;\n    vec4 mouse = get_val_at_index(8.0);\n    if((abs(mouse.x - fragCoord.x) <= 2.5 || abs(mouse.y - fragCoord.y) <= 2.5) &&\n       (abs(mouse.x - fragCoord.x) > empty_radius || abs(mouse.y - fragCoord.y) > empty_radius) &&\n       (abs(mouse.x - fragCoord.x) < reticle_size && abs(mouse.y - fragCoord.y) < reticle_size)) {\n        if(abs(mouse.x - fragCoord.x) <= 1.0 || abs(mouse.y - fragCoord.y) <= 1.0) {\n            fragColor = vec4(1.0);\n        } else {\n            fragColor = vec4(0.0);\n        }\n    }\n    \n    //fragColor = texture(iChannel1, fragCoord/iResolution.xy).wwww;\n#endif\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float reserved_float = -867.5309;\nvec4 debug_trace_value;\nint debug_trace_index;\nbool debug_trace_occurred;\n\n#define DEBUG 1\n#if DEBUG\n\n//DEBUG_TRACE will not overwrite a previously-traced value in the current frame.\n#define DEBUG_TRACE(index, val) \\\n    do{\\\n        if(!debug_trace_occurred && index == debug_trace_index) {\\\n            debug_trace_value = val;\\\n            debug_trace_occurred = true;\\\n        }}while(false)\n//DEBUG_RETRACE will overwrite any value already recorded for this property.\n#define DEBUG_RETRACE(index, val) \\\n    do{\\\n        if(index == debug_trace_index) {\\\n            debug_trace_value = val;\\\n            debug_trace_occurred = true;\\\n        }}while(false)\n#define DEBUG_INCREMENT(index, val) \\\n    do{\\\n        if(index == debug_trace_index) {\\\n            if(debug_trace_val.x == reserved_float) \\\n                debug_trace_val = val;\\\n            else\\\n                debug_trace_val += val;\\\n        }}while(false)\n#define get_val_at_index(index)\\\n    texture(iChannel0, vec2((index) + 0.5, 0.5)/iResolution.xy);\n#else\n#define DEBUG_TRACE(index, val) do{}while(false)\n#define DEBUG_RETRACE(index, val) do{}while(false)\n#endif\n\nvec2 fragCoord_to_uv(in vec3 uniformResolution, in vec2 fragCoord) {\n    vec2 uv = fragCoord - uniformResolution.xy/2.0;\n    return uv*2.0/uniformResolution.x;\n}\n\nvec2 mouse_to_fragCoord(vec4 mouse) {\n    return mouse.xy + 0.5;\n}\n\nvec2 mouse_to_uv(in vec3 uniformResolution, vec4 mouse) {\n    return fragCoord_to_uv(uniformResolution, mouse_to_fragCoord(mouse));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//thanks to Fabrice Neyret for algorhitm https://www.shadertoy.com/view/llySRh\n//and thanks to otaviogood for font texture\n#define C(c) fragColor.rgb -= char(U,64+c).xxx; U.x-=.5\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\n#define BACKGROUND vec4(0.2509, 0.1137, 0.0118, 0.0)\n#define BRASS      vec4(0.4667, 0.3333, 0.0510, 1.0)\n#define BLACK      vec4(0.0,    0.0,    0.0,    1.0)\n\n#define BRASS_HEIGHT     0.20\n#define BRASS_WIDTH      0.75\n#define BORDER_THICKNESS 0.02\n#define ROUNDING_RADIUS  0.10\n\n\nvoid mainImage( out vec4 fragColor, vec2 uv )\n{\n    fragColor = vec4(0.0);\n    uv -= iResolution.xy/2.0;\n    uv /= iResolution.x;\n    uv *= 2.0;\n    \n    fragColor = BACKGROUND;\n    vec2 abs_uv = abs(uv);\n    vec2 corner_pos = vec2(BRASS_WIDTH, BRASS_HEIGHT);\n    if(abs_uv.x < BRASS_WIDTH && abs_uv.y < BRASS_HEIGHT && length(abs_uv - corner_pos) > ROUNDING_RADIUS) {\n        fragColor = BRASS;\n    } else if (\n            abs_uv.x < BRASS_WIDTH + BORDER_THICKNESS && \n            abs_uv.y < BRASS_HEIGHT + BORDER_THICKNESS &&\n            length(abs_uv - corner_pos) > ROUNDING_RADIUS - BORDER_THICKNESS) {\n        fragColor = BLACK;\n    }\n        \n\n    float num_characters = 9.0;\n    float FontSize = 18.;\n    float width = (num_characters + 1.0)*FontSize/256.0;\n    float height = FontSize/128.0;\n\n    vec2 position = vec2(-width, -height);\n    vec2 U = ( uv - position)*64.0/FontSize;\n    C(-32);C(6);C(15);C(15);C(4);C(9);C(14);C(9);C(-32);  \n    fragColor = clamp(fragColor, 0.0, 1.0);\n}\n\n\n//line 12 -> x,y coordinates of text, counted from left down corner\n//line 13 -> higher value = greater font size\n//line 15 -> Every argument is another char","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nFINALLY RUNNING BELOW 60FPS on my desktop machine!  =]\n\n\nOkay, there's still a lot to do, but this gets the proof-of-concept out of the way.\n\nFirst, the checklist of what works;\n* \"Recursive\" ray tracing.\n* Reflection and refraction of nested objects. This only works if the interior\n  objects' indices of refraction are specified relative to their parent. A sphere\n  of ior 1.8 inside a 1.5 is specified with an ior of 1.8/1.5.\n* \"Barf-o-morphism\" I want to just keep a list of objects, each of which knows its\n  type. You just write the intersection function for an object type (and, \n  eventually, provide texturing info) and you don't have to think about anything else.\n* Fresnel reflection. Glass objects don't _just_ refract. Some of the light that\n  hits the glass surface is reflected. It's a complicated interaction that involves\n  the polarization of light and it's not worth getting into here. Frankly, I can't\n  even say I barely understand it. I'm operating on faith here.\n* Perlin noise. Only currently used for warping the mandelbrot texture. I may use it\n  to create some \"proper\" textures like wood, etc. Maybe\n* Visible light sources. It's fake, but it's not too bad. It depends upon the angle\n  between the cast ray and the direction to the center of the light source, which\n  means its size is constant in screenspace and gives it a very wonky behavior as\n  it passes in front of the camera. I don't know if I'll try to fix this.\n* Soft shadows. This is expensive as hell. It's easier to see with only one light\n  source or without the messed up mandelwarp. I may eliminate this to go to just one\n  light and try to do actual real-time caustics. That's probabaly the next project,\n  and I'll have to finish it before Kerbal Space Program 2 comes out.\n* Depth-of-field. Only those things at the camera's focal length are in sharp focus.\n\n3.1\n* Incorporated my shader debugger into the ray tracer. I need to do some more thought\n  about how it prints (eliminate \"normal\", \"color\", \"distance\"?) But it's there and it\n  already helped me eliminate a bug where I was recursing too deeply.\n\n3.1.1\n* Planes with UV mapping. \n* UV mapping supports chromakey.\n\nGLSL has no recursion. \"Recursive\" ray-tracers generally work by replacing a ray,\nwhen it hits a refractive surface, with one ray that goes through the object surface\nand one that reflects off of it. These two rays are computed by a self call to a \ntrace() function... which you can't do in glsl.\n\nInstead, I just have a worklist of unprocessed rays. Each ray knows how much of the\nfinal color it contributes. For example, if a ray passes through a filter, the ray that\ncomes out the other side knows that whatever it hits in the end, only a fraction of\nthe surface's color will be used for the pixel color. Each time a ray hits a filter\nof any kind, new rays are generated with more and more attenuation.\n\nI have no idea how to explain this properly. It's too late at night for that. Hit me\nup in the comments and I'll try to make sense of it. In the meantime, enjoy the todo\nlist:\n\n\nTODO: \n* FIX REFRACTIVE ATTENUATION.\n* trace() is returning negative values. When the grid() is left un min/maxed in the Image\n  tab's mainImage function, the blending with the debug overlay is bugged.\n* I strongly dislike the fact that alpha blending is such a hack. When process_texture\n  returns a value, I know that it's going to be added to accumulated_texture - but the\n  place where this is done doesn't know anything about alpha. It just adds whatever came\n  out of process_texture to the accumulation and moves on. I feel like alpha should affect\n  \"current_contribution\" or however that's managed.\n* The add_[object] helpers are all still macros. This was so we could add an object to\n  any list, but since we're not CSG anymore, this isn't really necessary.\n* FIX RAND. Use rand textures.\n* What the hell happened to soft shadows? FIX RAND!\n* Do a major debug pass on attenuation. I'm not sure it's working for glass transmission,\n  reflection attenuation, etc. (It must be close for reflection since fresnel works.)\n* BOUNDING VOLUMES! cylinders are expensive.\n* I want to get transmissive attenuation working. Glass isn't transparent. It\n  slightly impedes photons as they pass through. I want blue glass and red glass\n  and grey glass.\n* Caustics? This is not, by any measure, even remotely easy. As I write this comment,\n  the scene is entirely static, so I could accumulate a lightmap texture over hundreds\n  of frames and produce a good caustic. I'm wondering if I can do something in real\n  time with some dynamic geometry.\n  \n  It can't be entirely insane. The scene here is (at the time of writing) throwing\n  nine rays per pixel for antialiasing. I don't need more than 4 unless depth-of-field\n  is on. If the texture to which I render the caustic is about the same size as the\n  screen and I throw about 4-9 rays per lightmap pixel, my rendering time will roughly\n  double. (I may turn off Fresnel reflection for caustics.)\n  \n  Might need: https://www.youtube.com/watch?v=EqNcqBdrNyI\n* Frequency-based refraction? This would cost a fortune. A ray would have to encode\n  more than r,g,b, it would have to encode a gamut of frequencies in the visible spectrum.\n  Each refraction would generate one new rays FOR EACH FREQUENCY instead of just 1-2.\n* I want to be apply any texture to any object. This may not be possible in the long\n  run, but a sphere, a plane, and an isomorph should all be refractable, perlin-able,\n  etc.\n* Add perlin bump mapping, normal mapping. \n* Video textures?\n* More interesting objects. Geometric, parametric, and...? Possibly terrain, though \n  that's a stretch. Isomorphs (blobs) definitely. Doing blobs means supporting just\n  about any raymarched geometry which provides a lot of options, but is insanely\n  expensive.\n* CONSTRUCTIVE SOLID GEOMETRY!\n* Subsurface scattering? Just shoot me.\n*/\n\nconst float MAX_DIST = 1e30;\n\nstruct Object {\n    int   type;\n    vec3  vec3_prop_0;\n    vec3  vec3_prop_1;\n    vec3  vec3_prop_2;\n    \n    float float_prop_0;\n    float float_prop_1;\n    float float_prop_2;\n    float float_prop_3;\n      \n    int   texture_index;\n    bool  casts_shadow;\n};\n\n// For Spheres:\nconst int SPHERE_TYPE = 0;\n#define sphere_pos                    vec3_prop_0\n#define sphere_radius                 float_prop_0\n#define new_sphere(pos,radius,texture_index) Object(SPHERE_TYPE,pos,vec3(0.0),vec3(0.0),radius,0.0,texture_index)\n        \n// For Planes:\nconst int PLANE_TYPE = 1;\n#define plane_normal                  vec3_prop_0\n#define plane_displacement            float_prop_0\n#define new_plane(normal,displacement) Object(PLANE_TYPE,normal,vec3(0.0),vec3(0.0)\n\n// For Cylinders:\nconst int CYLINDER_TYPE = 2;\n#define cylinder_cap0_pos             vec3_prop_0\n#define cylinder_cap1_pos             vec3_prop_1\n// TODO: rename centerline to something that indicates the direction it points\n#define cylinder_centerline           vec3_prop_2\n#define cylinder_radius               float_prop_0\n#define cylinder_height               float_prop_1\n#define cylinder_height_plus_diameter float_prop_2\n\nconst int TUBE_TYPE = 3;\n#define tube_cap0_pos             vec3_prop_0\n#define tube_cap1_pos             vec3_prop_1\n// TODO: rename centerline to something that indicates the direction it points\n#define tube_centerline           vec3_prop_2\n#define tube_major_radius         float_prop_0\n#define tube_minor_radius         float_prop_1\n#define tube_height_plus_diameter float_prop_2\n\nstruct Texture {\n    int   texture_type;                // REFLECT, REFRACT, MAND, etc.\n    int   int_prop_0;\n    bool  bool_prop_0;\n    vec3  vec3_prop_0;\n    vec3  vec3_prop_1; \n    vec3  vec3_prop_2; \n    float float_prop_0;\n    float float_prop_1;\n    float float_prop_2;\n    float float_prop_3;\n};\n\n// For Textures:\nconst int TEX_REFLECT        = 0;\nconst int TEX_REFRACT        = 1;\nconst int TEX_MIN_DIFFUSE_ID = 100;  // ANYTHING with an id between [100..199] is diffuse-lit.\nconst int TEX_MAND           = 100;\nconst int TEX_GRID           = 101;\nconst int TEX_PERLIN         = 102;\nconst int TEX_MANDWARP       = 103;\nconst int TEX_FLAT           = 104;\nconst int TEX_UV             = 105;\nconst int TEX_MAX_DIFFUSE_ID = 199;\n\n\n// We don't have the same protections against re-use of fields, here. Reflective attenuation is used\n// by more than one texture. Make SURE you aren't using the same field twice in the same texture type.\n#define tex_reflective_attenuation    vec3_prop_0\n#define tex_transmissive_coefficient  vec3_prop_1\n#define tex_ior                       float_prop_0\n#define tex_diffuse_color             vec3_prop_0\n\n// For uv-mapped surfaces. These values are used differently depending upon the object type.\n#define tex_uv_center                 vec3_prop_0\n#define tex_uv_v_dir                  vec3_prop_1\n#define tex_uv_u_dir                  vec3_prop_2\n#define tex_uv_v_scale                float_prop_0\n#define tex_uv_u_scale                float_prop_1\n#define tex_uv_v_offset               float_prop_2\n#define tex_uv_u_offset               float_prop_3\n#define tex_uv_channel                int_prop_0\n#define tex_uv_chromakey              bool_prop_0\n\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    float size;\n};\n\nconst int max_objects = 10;\nint constructed_obj_count = 0;\nObject objects[max_objects];\n\nconst int max_textures = 10;\nint constructed_texture_count = 0;\nTexture textures[max_textures];\n\nconst int max_lights = 3;\nint constructed_light_count = 0;\nLight lights[max_lights];\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nconst float PI = 3.1415926538;\nconst float EULER = 2.71828183;\nint rand_seed = 2987492621;\n// THIS SUCKS and is making antialiasing terrible.\nfloat rand(in vec2 co){\n    int chaos = int(co.x * 867530.9 * sin(PI + iTime) + co.y * 555236.8 * cos(EULER + iTime));\n    rand_seed += chaos;\n    rand_seed *= 1664525;\n    rand_seed += 1013904223;\n    return abs(float(rand_seed) / float(2147483647));\n}\n\nvec3 rand_normalized_vector() {\n    /*\n    You can generate normally-distributed numbers on the surface of the unit sphere with something like\n    the following. The math should be right, but I've not tried it. Note the cost. \n    */\n    float phi = 2.0 * PI * rand(vec2(EULER, PI));\n    float theta = acos(2.0 * rand(vec2(EULER, PI)) - 1.0);\n    float u = cos(phi);\n    float root = sqrt(1.0 - u*u);\n    float x = root * cos(theta);\n    float y = root * sin(theta);\n    float z = u;\n    \n    \n    return vec3(x, y, z);\n}\n\nbool approximately_equal(float a, float b, float epsilon) {\n    return abs(a-b) < epsilon;\n}\n\n//The ray tracing bible: https://iquilezles.org/articles/intersectors/\n\nfloat sphere_dist(in Object sphere, in Ray ray) {\n    vec3 OC = sphere.sphere_pos - ray.origin;\n    float len_OC_squared = dot(OC, OC);\n    float r_squared = sphere.sphere_radius*sphere.sphere_radius;\n    float Tca;\n    float Tca_squared;\n    float Thc_squared;\n    \n    Tca = dot(OC, ray.dir);\n\n    // Is the ray origin outside the sphere?\n    if(len_OC_squared >= r_squared) {\n        // Does the ray point away from the sphere?\n        if(Tca < 0.0) {\n            return MAX_DIST;\n        } else {\n            Tca_squared = Tca * Tca;\n            Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        }\n        // Does the ray miss the sphere?\n        if(Thc_squared < 0.0)\n            return MAX_DIST;\n        return Tca - sqrt(Thc_squared);\n    } else {\n        Tca_squared = Tca * Tca;\n        Thc_squared = r_squared - len_OC_squared + Tca_squared;\n        return Tca + sqrt(Thc_squared);\n    }\n}\n\nfloat plane_dist(in Object plane, in Ray ray) {\n    float Vprd = dot(plane.plane_normal, ray.dir);\n    float Vpro = -(dot(plane.plane_normal, ray.origin) + plane.plane_displacement);\n    float t = Vpro / Vprd;\n    if(t>0.0)\n        return t;\n    return MAX_DIST;\n}\n\nfloat _cylinder_dist(in vec3 cap0_pos, in vec3 cap1_pos, in float radius, in Ray ray) {\n    vec3 ba = cap1_pos - cap0_pos;\n    vec3 oc = ray.origin - cap0_pos;\n\n    float baba = dot(ba, ba);\n    float bard = dot(ba, ray.dir);\n    float baoc = dot(ba, oc);\n    float k2 = baba - bard*bard;\n    float k1 = baba * dot(oc, ray.dir) - baoc*bard;\n    float k0 = baba * dot(oc, oc) - \n        baoc*baoc - radius * radius * baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) \n        return MAX_DIST;\n    \n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n    \n    // body\n    float y = baoc + t * bard;\n    if(y > 0.0 && y < baba) {\n        return t > 0.0 ? t : MAX_DIST;\n    }\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return t > 0.0 ? t : MAX_DIST;\n    }\n\n    return MAX_DIST;\n}\n\n// I don't have a cylinder intersector that works from inside the cylinder - it only finds the near faces.\n// To deal with this, I back up the starting ray by the smallest amount that is guaranteed to take an\n// interior start point to the exterior (the sum of the height plus the diameter.) If an intersection is\n// found, and it is found to be nearer than this bias, I do another test from the other side of the \n// cylinder.... which is guaranteed to hit. Whichever point is in front of - and nearest to - the original\n// ray is our solution.\nfloat cylinder_dist(in Object cylinder, in Ray ray) {    \n    if(textures[cylinder.texture_index].texture_type != TEX_REFRACT) {\n        return _cylinder_dist(cylinder.cylinder_cap0_pos, cylinder.cylinder_cap1_pos, cylinder.cylinder_radius, ray);\n    } else {\n        //TODO: Optimize this. Store the displacement distance in the object.\n        Ray tmp_ray;\n        tmp_ray.dir = ray.dir;\n        tmp_ray.origin = ray.origin - cylinder.cylinder_height_plus_diameter * ray.dir;\n        float first_pass_dist = _cylinder_dist(\n            cylinder.cylinder_cap0_pos, cylinder.cylinder_cap1_pos, cylinder.cylinder_radius, tmp_ray);\n        if(first_pass_dist == MAX_DIST)\n            return MAX_DIST;\n        if(first_pass_dist > cylinder.cylinder_height_plus_diameter)\n            return first_pass_dist - cylinder.cylinder_height_plus_diameter;\n        \n        tmp_ray.origin = ray.origin + cylinder.cylinder_height_plus_diameter * ray.dir;\n        tmp_ray.dir = -ray.dir;\n        float second_pass_dist = _cylinder_dist(\n            cylinder.cylinder_cap0_pos, cylinder.cylinder_cap1_pos, cylinder.cylinder_radius, tmp_ray);\n        second_pass_dist = cylinder.cylinder_height_plus_diameter - second_pass_dist;\n        return second_pass_dist;\n    }\n}\n\n//#define DRAW_NORMALS\n// TODO(Optimization): Do a version that skips anything that isn't necessary for refraction.\nfloat tube_dist(in Object tube, in Ray ray) {\n    // We're using a cylinder intersection routine that only gives us near hits, and we need \n    // a test that will work from inside geometry. So, we have to make this thing work - somewhat\n    // optimally, for a ray that starts anywhere.\n\n    Ray frontface_ray;\n    frontface_ray.dir = ray.dir;\n    frontface_ray.origin = ray.origin - tube.tube_height_plus_diameter * ray.dir;\n    \n    float major_frontface_dist;\n    float minor_frontface_dist;\n    float major_backface_dist;\n    float minor_backface_dist;\n\n    // Copy the initial ray but back it up by enough that, if the original ray started inside the cylinder, it is\n    // now guaranteed to be outside the cylinder. If it misses, we have missed the entire thing.\n\n    //MAJOR FRONTFACE:\n    major_frontface_dist = _cylinder_dist(tube.tube_cap0_pos, tube.tube_cap1_pos, tube.tube_major_radius, frontface_ray);\n    if(major_frontface_dist == MAX_DIST) {\n        return MAX_DIST;\n    }\n    // remove the displacement bias. major_frontface_dist will now be negative if the ray started inside the cyl.\n    // That's okay.\n    major_frontface_dist -= tube.tube_height_plus_diameter;\n\n    Ray backface_ray;\n    backface_ray.dir = -ray.dir;\n    float backface_ray_displacement = tube.tube_height_plus_diameter + major_frontface_dist;\n    backface_ray.origin = ray.origin + backface_ray_displacement * ray.dir;\n\n    // I could save a bit by doing these only when called for, but it wouldn't save much (the savings would be in the rare\n    // cases) and this thing is \n    // MAJOR BACKFRACE\n    major_backface_dist = _cylinder_dist(tube.tube_cap0_pos, tube.tube_cap1_pos, tube.tube_major_radius, backface_ray);\n    if(major_backface_dist != MAX_DIST)\n        major_backface_dist = backface_ray_displacement - major_backface_dist;\n\n    // If the entire object is behind the ray:\n    if(major_backface_dist < 0.0)\n        return MAX_DIST;\n\n    // MINOR FRONTFACE:\n    minor_frontface_dist = _cylinder_dist(tube.tube_cap0_pos, tube.tube_cap1_pos, tube.tube_minor_radius, frontface_ray);\n    if(minor_frontface_dist != MAX_DIST)\n        minor_frontface_dist -= tube.tube_height_plus_diameter;\n    // MINOR BACKFRACE\n    minor_backface_dist = _cylinder_dist(tube.tube_cap0_pos, tube.tube_cap1_pos, tube.tube_minor_radius, backface_ray);\n    if(minor_backface_dist != MAX_DIST)\n        minor_backface_dist = backface_ray_displacement - minor_backface_dist;\n    \n    \n    // All of the m*or_*face_dists are now the distance from the original ray to the surface they're testing. Negatives\n    // represent things behind the source ray and MAX_DIST represents, of course, misses.\n    \n    bool frontfaces_equal = approximately_equal(major_frontface_dist, minor_frontface_dist, 0.001);\n    if(!frontfaces_equal) {\n        if(major_frontface_dist > 0.0) {\n            return major_frontface_dist;\n        }\n        if(minor_frontface_dist > 0.0) {  // UNTESTED REFRACTION CASE\n            return minor_frontface_dist;\n        }\n    }\n\n    bool backfaces_equal = approximately_equal(major_backface_dist, minor_backface_dist, 0.001);\n    if(!backfaces_equal) {\n        if(minor_backface_dist > 0.0) {\n            return minor_backface_dist;\n        }\n        if(major_backface_dist > 0.0) { // OPTIMIZE. This should always be true if we've gotten here.\n            return major_backface_dist;\n        }\n    }\n\n    return MAX_DIST;\n}\n\n// TODO: OPTIMIZE. dist_from_centerline computes nearest_point_on_centerline, which could be used again\n//                 by dist_along_centerline. The former is used in get_normal as a preamble to the\n//                 lighting calculation. The latter, by texturing.\nfloat dist_from_centerline(in vec3 intersect_point, in vec3 cap0, in vec3 centerline, out vec3 centerline_to_intersect_point) {\n    vec3 nearest_point_on_centerline = dot(intersect_point - cap0, centerline) * centerline + cap0;\n    centerline_to_intersect_point = intersect_point - nearest_point_on_centerline;\n    return length(centerline_to_intersect_point);\n}\n\nfloat fract_along_centerline(vec3 intersect_point, in vec3 cap0, in float height, in vec3 centerline) {\n    vec3 nearest_point_on_centerline = dot(intersect_point - cap0, centerline) * centerline + cap0;\n    return length(nearest_point_on_centerline - cap0) / height;\n}\n\nfloat plane_usdf(vec3 p, vec3 normal, float displacement) {\n    return dot(normal, p) - displacement;\n}\n\n#define sdf_normal(normal,obj,p,mapping_func)\\\n    do {\\\n        vec2 e = vec2(1.0, -1.0) * 0.5773;\\\n        normal = normalize(\\\n            e.xyy*mapping_func(obj, p + e.xyy*0.0005) +\\\n            e.yyx*mapping_func(obj, p + e.yyx*0.0005) +\\\n            e.yxy*mapping_func(obj, p + e.yxy*0.0005) +\\\n            e.xxx*mapping_func(obj, p + e.xxx*0.0005));\\\n    } while(false)\n\nfloat obj_dist(in Object obj, in Ray ray) {\n    if(obj.type == SPHERE_TYPE) {\n        return sphere_dist(obj, ray);\n    } \n    if(obj.type == PLANE_TYPE) {\n        return plane_dist(obj, ray);     \n    }\n    if(obj.type == CYLINDER_TYPE) {\n        return cylinder_dist(obj, ray);\n    }\n    if(obj.type == TUBE_TYPE) {\n        return tube_dist(obj, ray);\n    }\n}\n\n// Returns a normal that points toward the ray source. Reflection, refraction, and lighting all\n// depend upon this assumption. Refraction requires that we know if we're entering or exiting\n// the object, so we return that information as well.\n// TODO: save the dot product by taking a bool that tells the function whether or not it's needed.\nvec3 get_normal(in Object object, in vec3 ray_dir, in vec3 intersect_point, out bool incident_upon_exterior) {\n    vec3 normal;\n    \n    if(object.type == SPHERE_TYPE) {\n        normal = normalize(intersect_point - object.sphere_pos);\n    } else if(object.type == PLANE_TYPE) {\n        normal = object.plane_normal;\n    } else if(object.type == CYLINDER_TYPE) {\n        float dot_prod = dot(object.cylinder_centerline, intersect_point - object.cylinder_cap0_pos);\n        vec3 nearest_point_on_axis = \n            object.cylinder_cap0_pos + object.cylinder_centerline * dot_prod;\n        vec3 direction = intersect_point - nearest_point_on_axis;\n        float dist_from_nearest_to_intersect = length(direction);\n        if(dist_from_nearest_to_intersect < (0.9999 * object.cylinder_radius)) {\n            if(dot_prod < 0.01) {\n                normal = -object.cylinder_centerline;\n            } else {\n                normal = object.cylinder_centerline;\n            }\n        } else {\n            normal = normalize(intersect_point - nearest_point_on_axis);\n        }\n    } else if (object.type == TUBE_TYPE) {\n        float r = dist_from_centerline(intersect_point, object.tube_cap0_pos, object.tube_centerline, normal);\n        if(approximately_equal(r, object.tube_major_radius, 0.001)) {\n            normal = normal/r;\n        } else if(approximately_equal(r, object.tube_minor_radius, 0.001)) {\n            normal = normal/r;\n        } else if(approximately_equal(length(intersect_point - object.tube_cap0_pos), r, 0.001)) {\n            normal = -object.tube_centerline;\n        } else {\n            normal = object.tube_centerline;\n        }\n    }\n    incident_upon_exterior = (dot(ray_dir, normal) < 0.0);\n    if(!incident_upon_exterior)\n        normal = -normal;\n    \n    return normal;\n}\n\n// TODO: add the actual intersect point (since p is essentially a uv) and the normal\nvec4 mand(in vec2 uv, in vec3 intersect_point, in vec3 normal) {\n    vec2 c = vec2(uv.x, uv.y) * 0.003;// * (0.0005 + pow(sin(iTime/15.0), 2.0));\n    c += vec2(0.1382309, 0.643002);\n    vec2 z = c;\n    vec2 zn;\n    \n    for(float i=0.; i<500.; i++) {\n        if(dot(zn,zn) >= 4.0) {\n            float d = i + 1. - log(log(length(zn)))/log(2.);\n            return vec4(\n                (1.0+sin((iTime*5. + d)/17.))/2.0,\n                (1.0+cos((iTime*7. + d)/13.))/2.0,\n                (1.0+sin((iTime*11. + d)/11.))/2.0,\n                1.0);\n        } else {\n            zn = mat2(zn,-zn.y,zn.x) * zn + c;\n    \t\tz = zn;\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec4 grid(in vec2 p) {\n    float sx = sin(p.x*PI);\n    float sy = sin(p.y*PI);\n    \n    sx *= sx * sx;\n    sx = pow(sx, 20.0);\n    sy *= sy * sy;\n    sy = pow(sy, 20.0);\n    \n    float intensity = max(sx, sy);\n    intensity = max(0.0, intensity);\n    intensity = min(1.0, intensity);\n    return vec4(intensity, intensity, intensity, 1.0);\n}\n\n//https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n//\tClassic Perlin 2D Noise \n//\tby Stefan Gustavson\n//\nvec2 fade(vec2 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nvec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}\n\n/*\nfloat cnoise(vec2 P){\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n  vec4 i = permute(permute(ix) + iy);\n  vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n  vec4 gy = abs(gx) - 0.5;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n  vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n  g00 *= norm.x;\n  g01 *= norm.y;\n  g10 *= norm.z;\n  g11 *= norm.w;\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n*/\n\n//\tClassic Perlin 3D Noise \n//\tby Stefan Gustavson\n//\nfloat cnoise(vec3 P){\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod(Pi0, 289.0);\n  Pi1 = mod(Pi1, 289.0);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 / 7.0;\n  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 / 7.0;\n  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n//TODO: Take a look at the noise/marble info here: https://cs.nyu.edu/~perlin/courses/spring2015/0225/\nvec4 perlin(in vec3 p) {\n    return vec4(cnoise(p+iTime), cnoise(p+200.0+iTime), cnoise(p+500.0+iTime), 1.0);\n}\n\n\n//TODO: Get the 2d version of the perlin function....\nvec4 mandwarp(in vec3 p, in vec3 intersect_point, in vec3 normal) {\n    vec3 p1 = p + perlin(p).xyz * 0.4;\n    return mand(p1.xz, intersect_point, normal);\n}\n\nstruct RayContext {\n    Ray ray;\n    vec3 contribution;\n};\nconst int max_contexts = 10;\nint num_contexts = 0;\nRayContext contexts[max_contexts];\n\nbool push(in Ray ray, in vec3 contribution) {\n    if(num_contexts == max_contexts)\n        return false;\n    \n    contexts[num_contexts].ray = ray;\n    contexts[num_contexts].contribution = contribution;\n    num_contexts++;\n    \n    return true;\n}\n\nbool pop(out Ray ray, out vec3 contribution) {\n    if(num_contexts == 0)\n        return false;\n    \n    num_contexts--;\n    ray = contexts[num_contexts].ray;\n    contribution = contexts[num_contexts].contribution;\n    \n    return true;\n}\n\nfloat max_vec3(in vec3 i) {\n    return max(max(i.x, i.y), i.z);\n}\n\n// Fresnel is very costly to compute. I should just replace this with a cheap approximation.\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/introduction-to-shading/reflection-refraction-fresnel.html\nfloat fresnel_reflection_fraction(in vec3 ray_dir, in vec3 normal, in float ior) {\n    //return false;\n    \n    float cosi = dot(ray_dir, normal);\n    float etai;\n    float etat;\n    if (cosi < 0.0) {\n        etai = 1.0;\n        etat = ior;\n    } else {\n        etai = ior;\n        etai = 1.0;\n    }\n    \n    float sint = etai / etat * sqrt(max(0.0, 1.0 - cosi * cosi));\n    if(sint >= 1.0)\n        return 1.0;\n    \n    float cost = sqrt(max(0.0, 1.0 - sint * sint));\n    cosi = abs(cosi);\n    float Rs = ((etat * cosi) - (etai * cost)) / ((etat * cosi) + (etai * cost));\n    float Rp = ((etai * cosi) - (etat * cost)) / ((etai * cosi) + (etat * cost));\n    \n    return (Rs * Rs + Rp * Rp) / 2.0;\n}\n\nvoid push_reflection_ray(in Ray ray, in vec3 normal, in vec3 intersect_point, in vec3 contribution) {\n    if(max_vec3(contribution) > 0.005) {\n        Ray new_ray;\n        new_ray.dir = reflect(ray.dir, normal); // _SHOULDN'T_ need normalizing.....\n        new_ray.origin = intersect_point + normal * 0.001;\n        push(new_ray, contribution);\n    }\n}\n\nvoid push_refraction_ray(in Ray ray, in vec3 normal, in vec3 intersect_point, in vec3 contribution, in float ior) {\n    float eta = 1.0/ior;\n    if(max_vec3(contribution) > 0.005) {\n        Ray new_ray;\n        new_ray.dir = refract(ray.dir, normal, eta); // _SHOULDN'T_ need normalizing.....\n        if(dot(new_ray.dir, new_ray.dir) == 0.0) {\n            // This is the \"total internal reflection\" case. glsl reflect() returns a zero vector for\n            // this situation, so we have to make it ourselves:\n            push_reflection_ray(ray, normal, intersect_point, contribution);\n        } else {\n            new_ray.origin = intersect_point - normal * 0.001;\n            push(new_ray, contribution);\n        }\n    }\n}\n\nvoid push_transmissive_ray(Ray ray, in vec3 intersect_point, in vec3 contribution) {\n    Ray new_ray = ray;\n    new_ray.origin = intersect_point + ray.dir * 0.0005;\n    push(new_ray, contribution);\n}\n\nvec4 channel_uv_lookup(in int channel_id, in vec2 uv) {\n    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n        \n\n    if(channel_id < 2) {\n        if(channel_id == 0) {\n            return texture(iChannel0, uv); \n        } else {\n            return texture(iChannel1, uv); \n        }\n    } else {\n        if(channel_id == 2) {\n            return texture(iChannel2, uv); \n        } else {\n            return texture(iChannel3, uv); \n        }\n    }\n}\n\nconst float chroma_threshold = 0.585;\nconst float chroma_padding = 0.05;\nfloat get_chromakey_opacity(in vec4 input_color) {\n    vec3 background_color = vec3(0.0, 1.0, 0.0);\n    vec3 diff = input_color.rgb - background_color;\n    float alpha = smoothstep(\n        chroma_threshold - chroma_padding,\n        chroma_threshold + chroma_padding, \n        dot(diff,diff));\n    return alpha;\n}\n\nvec4 diffuse_lighting(in Object object, in Ray ray, in Texture object_texture, in vec3 intersect_point, in vec3 normal) {\n    vec4 diffuse_color;\n    if(object_texture.texture_type == TEX_MAND) {\n        diffuse_color = mand(intersect_point.xz, intersect_point, normal);\n    } else if(object_texture.texture_type == TEX_GRID) {\n        diffuse_color = grid(intersect_point.xz);\n    } else if(object_texture.texture_type == TEX_PERLIN) {\n        diffuse_color = perlin(intersect_point);\n    } else if(object_texture.texture_type == TEX_MANDWARP) {\n        diffuse_color = mandwarp(intersect_point, intersect_point, normal);\n    } else if(object_texture.texture_type == TEX_FLAT) {\n        diffuse_color = vec4(object_texture.tex_diffuse_color, 1.0);\n    } else if(object_texture.texture_type == TEX_UV) {\n        if(object.type == PLANE_TYPE) {\n            vec3 relative = intersect_point - object_texture.tex_uv_center;\n            float u = (dot(relative, object_texture.tex_uv_u_dir) + object_texture.tex_uv_u_offset)\n                / object_texture.tex_uv_u_scale;\n            float v = (dot(relative, object_texture.tex_uv_v_dir) + object_texture.tex_uv_v_offset)\n                / object_texture.tex_uv_v_scale;\n\n            // u and v are in [-1.0..1.0] space. re-scale for texture lookup.\n            vec2 uv = vec2(u,v) / 2.0 + 0.5;\n                \n            diffuse_color = channel_uv_lookup(object_texture.tex_uv_channel, uv);\n            if(object_texture.tex_uv_chromakey) {\n                diffuse_color.a *= get_chromakey_opacity(diffuse_color);\n            }\n            diffuse_color.a += 0.0;  // DO NOT REMOVE. This was eliminating some odd math bug that\n                                     // made alphas of opaque objects semi-transparent.\n            return diffuse_color;\n        } else if(object.type == CYLINDER_TYPE) {\n            float normal_dot_u = dot(normal, object_texture.tex_uv_u_dir);\n            float normal_dot_v = dot(normal, object_texture.tex_uv_v_dir);\n            if(abs(normal_dot_v) > 0.99) {\n                //TODO: we hit an endcap. Use the first 0.25 and last 0.25 of texmap in v dir.\n                return vec4(0.0);\n            } else {\n                //TODO(OPTIMIZE): use a 3x3 matrix for the scale/xlate/scale of uv.\n                float abs_cos_angle = dot(normal, object_texture.tex_uv_center);\n                float u = sign(normal_dot_u) *  acos(abs_cos_angle) / PI;\n                u = (u + object_texture.tex_uv_u_offset) / object_texture.tex_uv_u_scale;                \n                //scale from [-1.0..1.0] to [0.0..1.0]\n                u = u / 2.0 + 0.5;\n                \n                float v = fract_along_centerline(\n                    intersect_point, object.cylinder_cap0_pos, object.cylinder_height, object.cylinder_centerline);\n                \n                //scale from [0.0..1.0] to [-1.0..1.0]\n                v = (v - 0.5) * 2.0;\n                v = (v + object_texture.tex_uv_v_offset) / object_texture.tex_uv_v_scale;\n                //scale from [-1.0..1.0] to [0.0..1.0]\n                v = v / 2.0 + 0.5;\n               \n                vec2 uv = vec2(u,v);\n                diffuse_color = channel_uv_lookup(object_texture.tex_uv_channel, uv);\n                DEBUG_TRACE(0, diffuse_color);\n                DEBUG_TRACE(1, vec4(uv.x, uv.y, 0.0, 0.0));\n\n                if(object_texture.tex_uv_chromakey) {\n                    diffuse_color.a *= get_chromakey_opacity(diffuse_color);\n                }\n            }\n        }\n    }\n\n    // If it's transparent, let the texturing function generate a new transmission ray:\n    if(diffuse_color.a == 0.0) {\n        return diffuse_color;\n    }\n\n    vec3 lit = vec3(0.0);\n    float max_samples = 8.0;\n    for(int light_index = 0; light_index < constructed_light_count; light_index++) {\n        for(float sample_id = 0.0; sample_id < max_samples; sample_id += 1.0) {\n            bool obstructed = false;\n            vec3 point_on_light_sphere = lights[light_index].pos + rand_normalized_vector() * lights[light_index].size;\n            vec3 to_light = point_on_light_sphere - intersect_point;\n            float dist_to_light = length(to_light);\n            to_light /= dist_to_light;\n            Ray test_ray;\n            test_ray.origin = intersect_point + 0.001*normal;\n            test_ray.dir = to_light;\n            for(int obj_index = 0; obj_index < constructed_obj_count; obj_index++) {\n                if(objects[obj_index].casts_shadow) {\n                    float dist_to_object = obj_dist(objects[obj_index], test_ray);\n                    if(dist_to_object > 0.0 && dist_to_object < dist_to_light) {\n                        obstructed = true;\n                        break;\n                    }\n                }\n            }\n            if(!obstructed) {\n                lit += diffuse_color.rgb * lights[light_index].color/max_samples * dot(normal, to_light);\n            }\n        }\n    }\n    vec4 retval = vec4(lit, diffuse_color.a + 0.0);  // DO NOT REMOVE THE +0.0. 1.0s are getting mangled.\n    return retval;\n}\n\nvec3 process_texture(in Object nearest, in Ray ray, in float nearest_dist, vec3 current_contribution) {\n    vec3 intersect_point;\n    Texture object_texture = textures[nearest.texture_index];\n    \n    intersect_point = ray.origin + ray.dir * nearest_dist;\n\n    bool incident_upon_exterior = true;\n    vec3 normal = get_normal(nearest, ray.dir, intersect_point, incident_upon_exterior);\n\n    vec4 tex_color;\n    if(object_texture.texture_type >= TEX_MIN_DIFFUSE_ID && object_texture.texture_type >= TEX_MIN_DIFFUSE_ID) {\n        tex_color = diffuse_lighting(nearest, ray, object_texture, intersect_point, normal);\n        if(tex_color.a > 0.995) {\n            return tex_color.rgb;\n        }\n\n        push_transmissive_ray(ray, intersect_point, current_contribution * (1.0 - tex_color.a));\n        return tex_color.rgb * tex_color.a;\n    } else if(object_texture.texture_type == TEX_REFLECT) {\n        push_reflection_ray(\n            ray, normal, intersect_point, current_contribution * object_texture.tex_reflective_attenuation);\n    } else if (object_texture.texture_type == TEX_REFRACT) {\n        float ior = object_texture.tex_ior;\n        if(!incident_upon_exterior) {\n            // We've hit the inside of the object. We have to apply transmissive attenuation.\n            ior = 1.0/ior;\n            /*\n            TODO: The glass attenuation comp is broken. I'm getting near-black in the glass tube.\n            current_contribution.x *= \n                (1.0 - pow(10.0, -object_texture.tex_transmissive_coefficient.x * nearest_dist));\n            current_contribution.y *= \n                (1.0 - pow(10.0, -object_texture.tex_transmissive_coefficient.y * nearest_dist));\n            current_contribution.z *= \n                (1.0 - pow(10.0, -object_texture.tex_transmissive_coefficient.z * nearest_dist));\n            */\n        }\n        float reflection_fraction = fresnel_reflection_fraction(ray.dir, normal, ior);\n        if(reflection_fraction > 0.002) {\n            vec3 reflection_contribution = \n                reflection_fraction * current_contribution * object_texture.tex_reflective_attenuation;\n            push_reflection_ray(ray, normal, intersect_point, reflection_contribution);\n        } \n      \n        //W W W TTT FFF\n        // WWW   T  FF\n        // W W   T  F       WHY IS reflection_fraction 0?\n        //reflection_fraction = 0.0;\n        if(reflection_fraction < 0.998) {\n            vec3 refraction_contribution = (1.0 - reflection_fraction) * current_contribution;\n            push_refraction_ray(ray, normal, intersect_point, refraction_contribution, ior);\n        }\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 trace() {\n    Object nearest;\n    int nearest_index;\n    \n    bool traversed;\n    \n    Ray ray;\n    vec3 current_contribution = vec3(1.0);\n\n    vec3 accumulated_texture = vec3(0.0);\n    \n    int ray_count = 0;\n\n    while(pop(ray, current_contribution)) {\n        float nearest_dist = MAX_DIST;\n        nearest.type = -1;\n        nearest_index = -1;\n        for(int obj_index=0; obj_index<=constructed_obj_count; obj_index++) {\n            float dist = obj_dist(objects[obj_index], ray);\n            if(dist < nearest_dist) {\n                nearest = objects[obj_index];\n                nearest_dist = dist;\n                nearest_index = obj_index;\n            }\n        }\n\n        if(nearest_dist != MAX_DIST) {\n            //return vec3(fract(2.0*nearest_dist));\n            accumulated_texture += current_contribution * process_texture(\n                nearest, ray, nearest_dist, current_contribution);\n        } else {\n            //nothing hit\n            float sky_blue = ray.dir.y > 0.0 ? ray.dir.y: 0.0;\n            float sky_rg = pow(sky_blue, 4.0);\n            accumulated_texture += current_contribution * vec3(sky_rg, sky_rg, sky_blue);\n        }\n        \n        DEBUG_TRACE(2, vec4(nearest_dist));\n        \n        // Do a distance check to the light and see if it's closer than the nearest hit object?\n        // I need some way to determine if the current ray is in free space before I accumulate\n        // the light color for visible lighting.\n        \n        for(int light=0; light<constructed_light_count; light++) {\n            vec3 to_light = lights[light].pos - ray.origin;\n            if(dot(to_light, to_light) < nearest_dist * nearest_dist) {\n                float dot_prod = dot(to_light, ray.dir);\n                // I used to normalize to_light first, then do the dot_prod check for > 0.0, but that \n                // does a possibly unnecessary sqrt in computing the length for normalization. This avoids that:\n                if(dot_prod > 0.0) {\n                    float len = length(to_light);\n                    to_light /= len;\n                    accumulated_texture += lights[light].color * pow(dot_prod/len, 280.0) * current_contribution;\n                }\n            }\n        }\n        \n        \n        // REMEMBER that the max ray count is no the max recursion depth, but the max number of\n        // rays tested for a single pixel. Two nested spheres can requrie 50 or more at current\n        // limits.\n        ray_count++;\n        DEBUG_RETRACE(3, vec4(ray_count));\n        if(ray_count == 25) {\n            //return vec3(fract(nearest_dist*2.0));\n            //return accumulated_texture;\n            break;\n        }\n    }\n\n    DEBUG_TRACE(1, vec4(accumulated_texture, 1.0));\n    return accumulated_texture;\n}\n\n#define add_sphere(obj_list,obj_count,max_count,pos,radius,tex_index,shadow)\\\n    obj_count;  /*To \"return constructed object ID\"*/ \\\n    do {\\\n        if(obj_count<max_count) {\\\n            obj_list[obj_count].type = SPHERE_TYPE;\\\n            obj_list[obj_count].sphere_pos = pos;\\\n            obj_list[obj_count].sphere_radius = radius;\\\n            obj_list[obj_count].texture_index = tex_index;\\\n            obj_list[obj_count].casts_shadow = shadow;\\\n            obj_count++;\\\n        }\\\n    }while(false)\n\n#define add_plane(obj_list,obj_count,max_count,normal,displacement,tex_index,shadow)\\\n    obj_count;  /*To \"return constructed object ID\"*/ \\\n    do {\\\n        if(obj_count<max_count) {\\\n            obj_list[obj_count].type = PLANE_TYPE;\\\n            obj_list[obj_count].plane_normal = normal;\\\n            obj_list[obj_count].plane_displacement = displacement;\\\n            obj_list[obj_count].texture_index = tex_index;\\\n            obj_list[obj_count].casts_shadow = shadow;\\\n            obj_count++;\\\n        }\\\n    }while(false)\n\n#define add_cylinder(obj_list,obj_count,max_count,cap0_pos,cap1_pos,radius,tex_index,shadow)\\\n    obj_count;  /*To \"return constructed object ID\"*/ \\\n    do {\\\n        if(obj_count<max_count) {\\\n            obj_list[obj_count].type = CYLINDER_TYPE;\\\n            obj_list[obj_count].cylinder_cap0_pos = cap0_pos;\\\n            obj_list[obj_count].cylinder_cap1_pos = cap1_pos;\\\n            obj_list[obj_count].cylinder_centerline = cap1_pos - cap0_pos;\\\n            obj_list[obj_count].cylinder_height = length(obj_list[obj_count].cylinder_centerline);\\\n            obj_list[obj_count].cylinder_centerline /= obj_list[obj_count].cylinder_height;\\\n            obj_list[obj_count].cylinder_radius = radius;\\\n            obj_list[obj_count].cylinder_height_plus_diameter = obj_list[obj_count].cylinder_height + 2.0 * radius;\\\n            obj_list[obj_count].texture_index = tex_index;\\\n            obj_list[obj_count].casts_shadow = shadow;\\\n            obj_count++;\\\n        }\\\n    } while(false)\n\n#define add_tube(obj_list,obj_count,max_count,cap0_pos,cap1_pos,major_radius,minor_radius,tex_index,shadow)\\\n    obj_count;  /*To \"return constructed object ID\"*/ \\\n    do {\\\n        if(obj_count<max_count) {\\\n            obj_list[obj_count].type = TUBE_TYPE;\\\n            obj_list[obj_count].tube_cap0_pos = cap0_pos;\\\n            obj_list[obj_count].tube_cap1_pos = cap1_pos;\\\n            obj_list[obj_count].tube_centerline = cap1_pos - cap0_pos;\\\n            float len = length(obj_list[obj_count].tube_centerline);\\\n            obj_list[obj_count].tube_centerline /= len;\\\n            obj_list[obj_count].tube_major_radius = major_radius;\\\n            obj_list[obj_count].tube_minor_radius = minor_radius;\\\n            obj_list[obj_count].tube_height_plus_diameter = len + 2.0 * major_radius;\\\n            obj_list[obj_count].texture_index = tex_index;\\\n            obj_list[obj_count].casts_shadow = shadow;\\\n            obj_count++;\\\n        }\\\n    } while(false)\n\n\nint add_tex_refract(in vec3 reflective_attenuation, in vec3 transmissive_coefficient, in float ior) {\n    if(constructed_texture_count == max_textures)\n        return 0;\n\n    textures[constructed_texture_count].texture_type = TEX_REFRACT;\n    textures[constructed_texture_count].tex_reflective_attenuation = reflective_attenuation;\n    textures[constructed_texture_count].tex_transmissive_coefficient = transmissive_coefficient;\n    textures[constructed_texture_count].tex_ior = ior;\n    return constructed_texture_count++;\n}\n\nint add_tex_reflect(in vec3 reflective_attenuation) {\n    if(constructed_texture_count == max_textures)\n        return 0;\n\n    textures[constructed_texture_count].texture_type = TEX_REFLECT;\n    textures[constructed_texture_count].tex_reflective_attenuation = reflective_attenuation;\n    return constructed_texture_count++;\n}\n\nint add_tex_parametric(in int texture_type) {\n    if(constructed_texture_count == max_textures)\n        return 0;\n\n    textures[constructed_texture_count].texture_type = texture_type;\n    return constructed_texture_count++;\n}\n\nint add_tex_flat(in int texture_type, in vec3 color) {\n    if(constructed_texture_count == max_textures)\n        return 0;\n\n    textures[constructed_texture_count].texture_type = TEX_FLAT;\n    textures[constructed_texture_count].tex_diffuse_color = color;\n    return constructed_texture_count++;\n}\n\nint add_uv_tex(\n        in vec3 center, in vec3 u_dir, in vec3 v_dir, \n        in float u_scale, in float v_scale,\n        in float u_offset, in float v_offset,\n        in int channel, in bool chromakey) {\n    textures[constructed_texture_count].texture_type = TEX_UV;\n    textures[constructed_texture_count].tex_uv_center = center;\n    textures[constructed_texture_count].tex_uv_u_dir = normalize(u_dir);\n    textures[constructed_texture_count].tex_uv_v_dir = normalize(v_dir);\n    textures[constructed_texture_count].tex_uv_u_scale = u_scale;\n    textures[constructed_texture_count].tex_uv_v_scale = v_scale;\n    textures[constructed_texture_count].tex_uv_u_offset = u_offset;\n    textures[constructed_texture_count].tex_uv_v_offset = v_offset;\n    textures[constructed_texture_count].tex_uv_channel = channel;\n    textures[constructed_texture_count].tex_uv_chromakey = chromakey;\n\n    return constructed_texture_count++;    \n}\n\nvoid add_light(in vec3 pos, in vec3 color, in float size) {\n    if(constructed_light_count == max_lights)\n        return;\n    \n    lights[constructed_light_count].pos = pos;\n    lights[constructed_light_count].color = color;\n    lights[constructed_light_count].size = size;\n    \n    constructed_light_count++;\n}\n\nconst float glass_min_y = -0.5;\nconst float glass_height = 1.3;\nconst float glass_major_radius = 0.6;\nconst float glass_minor_radius = 0.55;\nconst float platform_height = 0.4;\n\nvoid render(out vec4 fragColor, in vec2 fragCoord)\n{\n/*\n    int water_tex_index = add_tex_refract(vec3(0.90), vec3(0.8, 0.0, 0.0), 1.333);\n    int mandelbrot_tex_index = add_tex_parametric(TEX_MAND);\n    int grid_tex_index = add_tex_parametric(TEX_GRID);\n    int perlin_tex_index = add_tex_parametric(TEX_PERLIN);\n*/\n\n#if 0\n    int mandelwarp_tex_index = add_tex_parametric(TEX_MANDWARP);\n    int glass_tex_index = add_tex_refract(vec3(0.90), vec3(0.1, 0.0, 0.01), 1.5);\n\n    add_plane(objects, constructed_obj_count, max_objects,\n        vec3( 0.0,  1.0, 0.0), 4.0, mandelwarp_tex_index, false);\n        \n    add_sphere(objects, constructed_obj_count, max_objects,\n        vec3(0.0, 0.0, 0.0), 2.0, glass_tex_index, true);\n#endif\n\n#if 0\n    int mandelwarp_tex_index = add_tex_parametric(TEX_MANDWARP);\n    int glass_tex_index = add_tex_refract(vec3(0.90), vec3(0.1, 0.0, 0.01), 1.5);\n    int reflect_tex_index = add_tex_reflect(vec3(0.90));\n\n    add_plane(objects, constructed_obj_count, max_objects,\n        vec3( 0.0,  1.0, 0.0), 4.0, mandelwarp_tex_index, false);\n\n    add_tube(objects, constructed_obj_count, max_objects,\n        vec3(2.0, 2.0, -1.0), vec3(2.0, 2.0, 1.0), 1.9, 1.1, glass_tex_index, true);\n        \n    add_sphere(objects, constructed_obj_count, max_objects,\n        vec3(2.0, 2.0, -1.0), 0.25, reflect_tex_index, true);\n\n    add_sphere(objects, constructed_obj_count, max_objects,\n        vec3(2.0, 2.0, 1.0), 0.25, reflect_tex_index, true);\n\n    add_cylinder(objects, constructed_obj_count, max_objects,\n        vec3(-2.0, 2.0, -1.0), vec3(-2, 2.0, 1.0), 1.9, reflect_tex_index, true);\n#endif\n\n#if 0\n    int mandelwarp_tex_index = add_tex_parametric(TEX_MANDWARP);\n    int plane_uv_tex_index = add_plane_uv_tex(\n        vec3(0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 1.0, 0.666, 2, true);\n\n    add_plane(objects, constructed_obj_count, max_objects,\n        vec3( 0.0,  1.0, 0.0), 4.0, mandelwarp_tex_index, false);  \n        \n    add_plane(objects, constructed_obj_count, max_objects,\n        vec3(0.0, 0.0, -1.0), 0.0, plane_uv_tex_index, false);\n#endif\n\n#if 1\n    int water_tex_index = add_tex_refract(vec3(0.90), vec3(0.1, 0.0, 0.01), 1.333);\n    int glass_tex_index = add_tex_refract(vec3(0.90), vec3(0.1, 0.0, 0.01), 1.5);\n    int flat_tex_index = add_tex_flat(TEX_FLAT, vec3(0.2509, 0.1137, 0.0118));\n    int mandelwarp_tex_index = add_tex_parametric(TEX_MANDWARP);\n    int grid_tex_index = add_tex_parametric(TEX_GRID);\n    int perlin_tex_index = add_tex_parametric(TEX_PERLIN);\n    int plane_uv_tex_index = add_uv_tex(\n        vec3(0.0, 0.1, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), \n        0.5, 0.6, 0.0, 0.0, 3, true);\n    int cylinder_uv_tex_index = add_uv_tex(\n        vec3(0.0, 0.0, 1.0), vec3(-1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), \n        0.3, 1.0, 0.0, 0.1, 2, false);\n\n    //floor plane\n    add_plane(objects, constructed_obj_count, max_objects,\n        vec3( 0.0,  1.0, 0.0), 4.0, mandelwarp_tex_index, false);  \n\n    //glass bowl:\n    add_tube(objects, constructed_obj_count, max_objects,\n        vec3(0.0, glass_min_y, 0.0), vec3(0.0, glass_min_y + glass_height, 0.0), \n        glass_major_radius, glass_minor_radius, glass_tex_index, false);\n    /*\n    add_cylinder(objects, constructed_obj_count, max_objects,\n        vec3(0.0, glass_min_y, 0.0), vec(0.0, glass_min_y + glass_height * .9, 0.0),\n        glass_minor_radius*0.99, water_tex_index);\n    */\n    //bulk of the platform\n    add_cylinder(objects, constructed_obj_count, max_objects,\n        vec3(0.0, glass_min_y, 0.0), vec3(0.0, glass_min_y - platform_height, 0.0), \n        glass_major_radius, flat_tex_index, true);\n    \n    //platform rim\n    add_cylinder(objects, constructed_obj_count, max_objects,\n        vec3(0.0, glass_min_y, 0.0), vec3(0.0, glass_min_y - 0.1, 0.0), \n        glass_major_radius + 0.03, flat_tex_index, true);\n        \n    //the head\n    add_plane(objects, constructed_obj_count, max_objects,\n        vec3(0.0, 0.0, -1.0), 0.0, plane_uv_tex_index, false);\n        \n    //nameplate\n    add_cylinder(objects, constructed_obj_count, max_objects,\n        vec3(0.0, glass_min_y - platform_height, 0.0), vec3(0.0, glass_min_y, 0.0), \n        glass_major_radius + 0.02, cylinder_uv_tex_index, true);\n    \n#endif\n    \n    add_light( vec3( 4.0,  5.0,  0.0), vec3(0.3, 0.1, 1.0), 1.0);\n    add_light( vec3( 0.0,  5.5,  4.0), vec3(1.0, 0.1, 0.3), 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 screen_space = uv * 2.0 - 1.0;\n    screen_space.x *= (iResolution.x/iResolution.y);\n\n    \n    float dist_to_pix_plane = 5.0;\n    float t = sin(iTime) / 8.0;\n    vec3 cam_position = vec3(dist_to_pix_plane * sin(t), 1.2, dist_to_pix_plane * cos(t));\n    //cam_position = vec3(0.0, 1.2, dist_to_pix_plane);\n    \n    float pix_plane_height = 2.1;\n    vec3 cam_look_at = vec3( -1.2 * cos(iTime/2.0), 2.0, 1.2 * sin(iTime/2.0));\n    cam_look_at = vec3(0.0, -0.1, 0.0);\n    vec3 cam_look_dir = dist_to_pix_plane * normalize(cam_look_at - cam_position);\n    \n    vec3 right = cross(vec3(0.0, 1.0, 0.0), cam_look_dir);\n    right = (pix_plane_height / 2.0) * normalize(right);\n    vec3 up = cross(cam_look_dir, right);\n    up = (pix_plane_height / 2.0) * normalize(up);\n    \n    vec3 pixel_width = right/iResolution.x;\n    vec3 pixel_height = up/iResolution.y;\n    \n    // You can get away with an aa level of 4ish if you turn off depth-of-field. Once\n    // I have lighting working, the DOF effect won't be so impactful and can be turned\n    // down.\n    float antialias_level = 4.0;\n    float depth_of_field_intensity = 3.0;\n    \n    \n    vec3 out_color = vec3(0.0);\n    Ray ray;\n    for(float aa=0.0; aa<antialias_level; aa+=1.0) {\n        vec3 ray_screen_isect_point = cam_position + cam_look_dir + \n            (screen_space.x * right) + (screen_space.y * up);\n        \n        ray_screen_isect_point += pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n        ray_screen_isect_point += pixel_height * (rand(uv*(aa+1.5) * 2.0 - 1.0));\n\n        ray.origin = cam_position;\n        if(depth_of_field_intensity > 0.0) {\n            ray.origin += depth_of_field_intensity * pixel_width * (rand(uv*(aa+1.0) * 2.0 - 1.0));\n            ray.origin += depth_of_field_intensity * pixel_height * (rand(uv*(aa+1.0) * 2.0 - 1.0));                 \n        }\n\n        ray.dir = normalize(ray_screen_isect_point - ray.origin);\n\n        push(ray, vec3(1.0));\n        out_color += trace();\n    }\n    out_color /= float(antialias_level);\n\n    // do a bit of fake gamma correcting as we output:\n    fragColor = vec4(\n        pow(out_color.x, 0.5),\n        pow(out_color.y, 0.5),\n        pow(out_color.z, 0.5),\n        1.0);\n}\n\n//////////////////////////////////// \n////////////////////////////////////\n// If anything changes below this line, do it in the parent shader and copy in.\n////////////////////////////////////\n////////////////////////////////////\n\n\nbool keydown_event(float keyCode) {\n    keyCode = (keyCode + 0.5) / 256.0;\n    vec2 uv = vec2(keyCode, 0.5);\n    float key = texture(iChannel1, uv).r;\n\n    return key > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#if DEBUG\n    debug_trace_index = -1;\n    debug_trace_occurred = false;\n    if(fragCoord.y == 0.5 && fragCoord.x <= 9.5) {\n        //////////////////\n        // TODO: GET OFF THE MAGIC NUMBERS FOR NUM FIELDS AND MOUSE STORAGE LOCATION!!!!!!!\n        //////////////////\n        vec4 mouse = get_val_at_index(8.0);\n        if(fragCoord.x < 8.5) {\n            debug_trace_index = int(fragCoord.x);\n            render(fragColor, mouse_to_fragCoord(mouse));\n        } else if(fragCoord.x == 8.5) {\n            //////\n            // Sorry, but I had to choose between fidelity and speed. I can make it so that\n            // WASD will move by one pixel every frame, but it's very hard to adjust by just\n            // one pixel in that case. By looking at the keyboard texture's indication that\n            // a key went down in this frame and only moving on those events, it is easy to\n            // adjust by a single pixel. My first attempt at this was to count the number of\n            // frames since the last keystroke and do some math with the iFrameDelta to make\n            // the thing move only every 500ms, but it seems that when a shader is paused,\n            // it stops rendering entirely unless it gets a keyboard or mouse event. Having\n            // a key or button held down is not an event. Only going up or going down are,\n            // so I have no way of checking how long a key has been held down before moving\n            // the cursor, so we're currently stuck with the limited cursor motion mechanism\n            // we have here:\n            if(iMouse.z > 0.0) {\n                fragColor = iMouse;\n            } else {\n                fragColor = mouse;\n                fragColor.w += 1.0;\n                // I'm a dvorak user, so I support WASD or \",AOE\". A is the same on both.\n                if(keydown_event(38.0) || keydown_event(87.0) || keydown_event(188.0))   // ↑ W ,\n                    fragColor.y += 1.0;\n                if(keydown_event(37.0) || keydown_event(65.0))                           // ← A\n                    fragColor.x -= 1.0;\n                if(keydown_event(40.0) || keydown_event(79.0) || keydown_event(83.0))    // ↓ S O\n                    fragColor.y -= 1.0;\n                if(keydown_event(39.0) || keydown_event(68.0) || keydown_event(69.0))    // → D E\n                    fragColor.x += 1.0;             \n            }\n        } \n    } else {\n        render(fragColor, fragCoord);\n    }\n    \n    if(debug_trace_index >= 0) {\n        if(debug_trace_occurred) {\n            fragColor = debug_trace_value;\n        } else {\n            fragColor = vec4(reserved_float);\n        }\n    }\n   \n#else\n    render(fragColor, fragCoord);\n#endif\n}","name":"Buffer B","description":"","type":"buffer"}]}