{"ver":"0.1","info":{"id":"ftGfW1","date":"1664401056","viewed":175,"name":"Nyan-nyan-nyan-nyan-nyan....","username":"rah","description":"homegirl needs a rainbow!","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["nyan","pixel","rainbow","cat"],"hasliked":0,"parentid":"stGBDR","parentname":"naked nyan"},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// By @rah\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// Cosine palette function, courtesy of @iq\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n// Simple hash, courtesy of @TDM\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    // Scale and position Nyan\n    vec2 newUv = uv;\n    newUv *= 2.;\n    newUv -= vec2(2.5, 0.55);\n    newUv.y -= sin(1.5 * 6. + iTime * 1.5) * 0.4;\n    newUv = clamp(newUv, 0., 1.);    \n    \n    // get the appropriate nyan animation frame\n\tfloat frame = floor( mod( iTime*10.0, 6.0 ) );\n\tfloat nyanWidthUV = 40.0/256.0;\n\tnewUv.x = (newUv.x + frame)*nyanWidthUV;\n    \n    vec3 bg = vec3(0.1, 0.1, 0.3);\n    \n    // compute rainbow wwave offsets BEFORE pixelating\n    float littleWave = cos(uv.x * 20. + iTime * 2.) * 0.03;\n    float bigWave = cos(uv.x * 3. + iTime * 1.5) * 0.2;\n    float waveOffset = littleWave + bigWave;\n\n    // pixelate our uv space\n    float pixelSize = 1.0/iResolution.y;\n    float cellSize = 8. * pixelSize;\n    float starUVx = uv.x + pixelSize * float(int(iTime * 200.));\n\n    starUVx = floor(starUVx / cellSize) * cellSize;\n    uv.x = floor(uv.x / cellSize) * cellSize;\n    uv.y = floor(uv.y / cellSize) * cellSize;\n        \n    // draw simple stars, 6 frames of stars synced with nyan animation\n    float starOffset = floor( mod( iTime*10.0, 100.0 ) );\n    if (hash(vec2(starUVx, uv.y) * 0.25) > 0.985)\n    {\n        bg = vec3(0.7, 0.7, 1.);\n    }\n\n    uv.y += waveOffset;\n    \n    // Define the top and bottom of the rainbow\n    float uvRB1 = 0.42;\n    float uvRB2 = 0.57;\n    \n    // The smaller the uv.x, the wider the rainbow\n    float rainbowWidenFactor = 1. - uv.x/1.5;\n    rainbowWidenFactor = pow(rainbowWidenFactor, 2.);\n    uvRB1 -= mix(0., 0.3, rainbowWidenFactor);\n    uvRB2 += mix(0., 0.3, rainbowWidenFactor);\n    if (uv.x < 1.4\n        && uv.y > uvRB1\n        && uv.y < uvRB2)\n    {\n        // remap our uv.y value into nice values for our cosine palette\n        float t = map(uv.y, uvRB1, uvRB2, 0.25, 1.2);\n        \n        // bucket the t values to get hard-edged stripes\n        t = floor(t/0.125) * 0.125 + 0.05;\n        bg = pal(t, \n            vec3(0.5,0.5,0.5),\n            vec3(0.5,0.5,0.5),\n            vec3(1.0,1.0,1.0),\n            vec3(0.0,0.33,0.67) );\n    }\n        \n    // composite in nyan!\n\tvec4 nyan = texture( iChannel0, newUv );\n\tvec3 col = mix(bg, nyan.xyz, nyan.a);\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}