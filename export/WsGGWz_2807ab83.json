{"ver":"0.1","info":{"id":"WsGGWz","date":"1569959277","viewed":106,"name":"ecLipse","username":"foran","description":"ecLipse","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["eclipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D \n//               noise functions.\n//      Author : People\n//  Maintainer : Anyone\n//     Lastmod : 20120109 (Trisomie21)\n//     License : No Copyright No rights reserved.\n//               Freely distributed\n//\n/*\nfloat snoise(vec3 uv)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e4);\n\tvec3 f = fract(uv);\n\tf = f*f*(3.0-2.0*f);\n\tuv = floor(uv);\n\tvec4 v = vec4(dot(uv, s)) + vec4(0., s.x, s.y, s.x+s.y);\n\tvec4 r = fract(sin(v*1e-3)*1e5);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\tr = fract(sin((v+s.z)*1e-3)*1e5);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n*/\n//--------------\n/*\n//float Cellular3D(vec3 P)\nfloat snoise(vec3 uv)\n{\n\t//\testablish our grid cell and unit position\n\tvec3 Pi=floor(uv);\n\tvec3 Pf=uv-Pi;\n\t\n\t// clamp the domain\n\tPi.xyz=Pi.xyz-floor(Pi.xyz*(1./69.))*69.;\n\tvec3 Pi_inc1=step(Pi,vec3(69.-1.5))*(Pi+1.);\n\t\n\t// calculate the hash ( over -1.0->1.0 range )\n\tvec4 Pt=vec4(Pi.xy,Pi_inc1.xy)+vec2(50.,161.).xyxy;\n\tPt*=Pt;\n\tPt=Pt.xzxz*Pt.yyww;\n\tconst vec3 SOMELARGEFLOATS=vec3(635.298681,682.357502,668.926525);\n\tconst vec3 ZINC=vec3(48.500388,65.294118,63.934599);\n\tvec3 lowz_mod=vec3(1./(SOMELARGEFLOATS+Pi.zzz*ZINC));\n\tvec3 highz_mod=vec3(1./(SOMELARGEFLOATS+Pi_inc1.zzz*ZINC));\n\tvec4 hash_x0=fract(Pt*lowz_mod.xxxx)*2.-1.;\n\tvec4 hash_x1=fract(Pt*highz_mod.xxxx)*2.-1.;\n\tvec4 hash_y0=fract(Pt*lowz_mod.yyyy)*2.-1.;\n\tvec4 hash_y1=fract(Pt*highz_mod.yyyy)*2.-1.;\n\tvec4 hash_z0=fract(Pt*lowz_mod.zzzz)*2.-1.;\n\tvec4 hash_z1=fract(Pt*highz_mod.zzzz)*2.-1.;\n\t\n\t//  generate the 8 point positions\n\tconst float JITTER_WINDOW=.166666666;// 0.166666666 will guarentee no artifacts.\n\thash_x0=((hash_x0*hash_x0*hash_x0)-sign(hash_x0))*JITTER_WINDOW+vec4(0.,1.,0.,1.);\n\thash_y0=((hash_y0*hash_y0*hash_y0)-sign(hash_y0))*JITTER_WINDOW+vec4(0.,0.,1.,1.);\n\thash_x1=((hash_x1*hash_x1*hash_x1)-sign(hash_x1))*JITTER_WINDOW+vec4(0.,1.,0.,1.);\n\thash_y1=((hash_y1*hash_y1*hash_y1)-sign(hash_y1))*JITTER_WINDOW+vec4(0.,0.,1.,1.);\n\thash_z0=((hash_z0*hash_z0*hash_z0)-sign(hash_z0))*JITTER_WINDOW+vec4(0.,0.,0.,0.);\n\thash_z1=((hash_z1*hash_z1*hash_z1)-sign(hash_z1))*JITTER_WINDOW+vec4(1.,1.,1.,1.);\n\t\n\t//\treturn the closest squared distance\n\tvec4 dx1=Pf.xxxx-hash_x0;\n\tvec4 dy1=Pf.yyyy-hash_y0;\n\tvec4 dz1=Pf.zzzz-hash_z0;\n\tvec4 dx2=Pf.xxxx-hash_x1;\n\tvec4 dy2=Pf.yyyy-hash_y1;\n\tvec4 dz2=Pf.zzzz-hash_z1;\n\tvec4 d1=dx1*dx1+dy1*dy1+dz1*dz1;\n\tvec4 d2=dx2*dx2+dy2*dy2+dz2*dz2;\n\td1=min(d1,d2);\n\td1.xy=min(d1.xy,d1.wz);\n\treturn min(d1.x,d1.y)*(9./12.);// return a value scaled to 0.0->1.0\n}\n*/\n//-----------\n//float Perlin3D(vec3 P)\nfloat snoise(vec3 uv)\n{\n\t//  https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\n\t\n\t// establish our grid cell and unit position\n\tvec3 Pi=floor(uv);\n\tvec3 Pf=uv-Pi;\n\tvec3 Pf_min1=Pf-1.;\n\t\n\t// clamp the domain\n\tPi.xyz=Pi.xyz-floor(Pi.xyz*(1./69.))*69.;\n\tvec3 Pi_inc1=step(Pi,vec3(69.-1.5))*(Pi+1.);\n\t\n\t// calculate the hash\n\tvec4 Pt=vec4(Pi.xy,Pi_inc1.xy)+vec2(50.,161.).xyxy;\n\tPt*=Pt;\n\tPt=Pt.xzxz*Pt.yyww;\n\tconst vec3 SOMELARGEFLOATS=vec3(635.298681,682.357502,668.926525);\n\tconst vec3 ZINC=vec3(48.500388,65.294118,63.934599);\n\tvec3 lowz_mod=vec3(1./(SOMELARGEFLOATS+Pi.zzz*ZINC));\n\tvec3 highz_mod=vec3(1./(SOMELARGEFLOATS+Pi_inc1.zzz*ZINC));\n\tvec4 hashx0=fract(Pt*lowz_mod.xxxx);\n\tvec4 hashx1=fract(Pt*highz_mod.xxxx);\n\tvec4 hashy0=fract(Pt*lowz_mod.yyyy);\n\tvec4 hashy1=fract(Pt*highz_mod.yyyy);\n\tvec4 hashz0=fract(Pt*lowz_mod.zzzz);\n\tvec4 hashz1=fract(Pt*highz_mod.zzzz);\n\t\n\t// calculate the gradients\n\tvec4 grad_x0=hashx0-.49999;\n\tvec4 grad_y0=hashy0-.49999;\n\tvec4 grad_z0=hashz0-.49999;\n\tvec4 grad_x1=hashx1-.49999;\n\tvec4 grad_y1=hashy1-.49999;\n\tvec4 grad_z1=hashz1-.49999;\n\tvec4 grad_results_0=inversesqrt(grad_x0*grad_x0+grad_y0*grad_y0+grad_z0*grad_z0)*(vec2(Pf.x,Pf_min1.x).xyxy*grad_x0+vec2(Pf.y,Pf_min1.y).xxyy*grad_y0+Pf.zzzz*grad_z0);\n\tvec4 grad_results_1=inversesqrt(grad_x1*grad_x1+grad_y1*grad_y1+grad_z1*grad_z1)*(vec2(Pf.x,Pf_min1.x).xyxy*grad_x1+vec2(Pf.y,Pf_min1.y).xxyy*grad_y1+Pf_min1.zzzz*grad_z1);\n\t\n\t// Classic Perlin Interpolation\n\tvec3 blend=Pf*Pf*Pf*(Pf*(Pf*6.-15.)+10.);\n\tvec4 res0=mix(grad_results_0,grad_results_1,blend.z);\n\tvec4 blend2=vec4(blend.xy,vec2(1.-blend.xy));\n\tfloat final=dot(res0,blend2.zxzx*blend2.wwyy);\n\treturn(final*1.1547005383792515290182975610039);// scale things to a strict -1.0->1.0 range  *= 1.0/sqrt(0.75)\n}\n//----------\n//rob dot dunn at gmail \n//Inspired by Ken Perlin's slides: http://www.noisemachine.com/talk1/24a.html\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\tvec2 p = ( fragCoord.xy / iResolution.xy ) - vec2(0.5);\n\tp.x *= iResolution.x/iResolution.y;\t\t\n\tfloat color1 = 3.0 - (3.*length(2.*p));\n\tfloat color2 = 3.0 - (3.*length(2.*p));\n\tfor(int i = 1; i <= 8; i++)\n\t{\n\t\tfloat power = pow(2.0,float(i));\n\t\tcolor1 -= ( (1.5 / power) * snoise( 2.*vec3( (atan(p.y,p.x))*power, (2.*length(p)-(iTime/16.))*power,  (iTime/8.) ) ) );\n\t\tcolor2 -= ( (1.5 / power) * snoise( 2.*vec3( (atan(p.y,-p.x)+2.*PI)*power, (2.*length(p)-(iTime/16.))*power,  (iTime/8.) ) ) );\n\t}\n\tcolor1 *= smoothstep(PI,0.,(abs(atan(p.y,p.x))));\n\tcolor2 *= smoothstep(PI,0.,(abs(atan(p.y,-p.x))));\n\tfloat color = color1+color2;\n\n\tfragColor = vec4( color, pow(max(color,0.),2.)*0.4, pow(max(color,0.),3.)*0.15 , 1.0 );\n\tif(length(p)<0.12) fragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"}]}