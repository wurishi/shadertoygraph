{"ver":"0.1","info":{"id":"slVXWG","date":"1644072162","viewed":44,"name":"cours 2 ","username":"Entwouanne","description":"cours 2 ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["cours"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n\n\nconst vec3 terreColor = vec3(1, 1, 0);\nconst vec3 luneColor = vec3(0, 1, 0);\nconst vec3 background = vec3(1, 1, 1);\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs; \n   C.View = normalize(LookAt - C.Obs);\n   C.Horiz = normalize(cross(vec3(0, 0, 1), C.View));\n   C.Up = normalize(cross(C.View, C.Horiz));\n   C.H = iResolution.y;\n   C.W = iResolution.x;\n   C.z = C.H / 2.0 / tan(aperture * PI / 180. / 2.);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   vec3 p = C.Obs+C.z * C.View +(XY.x-C.W/2.) * C.Horiz + (XY.y-(C.H/2.)) * C.Up;\n   r.Dir = p - r.Origin;\n   return r;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    float a = dot(R.Dir, R.Dir);\n    float b = 2. * dot(R.Dir, R.Origin - S.Center);\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R * S.R;\n    float delta = b * b - 4. * a * c;\n    t = (-b - sqrt(delta)) / (2. * a);\n    if (delta >= 0.) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\nbool intersect_floor(in Ray R, in float h, out float t){\n    if (R.Dir.z == 0.0) {\n        return false ;\n    } else {\n        t = (-h-R.Origin.z)/R.Dir.z ;\n        if (t >= 0.0) {\n            return true ;\n        } else {\n            return false ;\n        }\n    }\n}\n\n\nstruct Light{\n    vec3 Pos;\n    vec3 Color;\n};\n\n\nvec3 eclaire(Light lum, vec3 camobs, vec3 raydir, vec3 centreboule, float tcoef)\n{\n \n    vec3 point = camobs + tcoef*raydir ;\n    vec3 normale = normalize(point-centreboule) ;\n    vec3 incident = normalize(lum.Pos-point) ;\n    float costeta = dot(incident,normale) ;\n    return costeta*lum.Color ;\n}\n\nvec3 eclairesol(Light lum, vec3 camobs, vec3 raydir, float hauteur, float tcoef)\n{\n    vec3 point = camobs + tcoef*raydir ;\n    vec3 normale = normalize(vec3(0.0,0.0,hauteur)) ;\n    vec3 incident = normalize(lum.Pos-point) ;\n    float costeta = dot(incident,normale) ;\n    return costeta*lum.Color ;\n\n}\n\nfloat ombresphere(vec3 camobs, vec3 raydir, float tcoef, Sphere sombre, Light lux)\n{\n    vec3 point = camobs + tcoef*raydir ;\n    vec3 dir = point-lux.Pos ;\n    float a = dot(dir,dir) ;\n    float b = 2.0*dot(dir,(lux.Pos-sombre.Center)) ;\n    float c = dot((lux.Pos-sombre.Center),(lux.Pos-sombre.Center))-pow(sombre.R,2.0) ;\n    float delta = pow(b,2.0)-4.0*a*c ;\n    if (delta >= 0.0) {\n        float t = ((-b-sqrt(delta))/(2.0*a)) ;\n        if (t >= 0.0 && t <= 1.0) {\n            return 0.0 ;\n        } else {\n            return 1.0 ;\n        }\n    } else {\n        return 1.0 ;\n    } \n}\n\n\n\nvec3 rotPos(float rayon, float t, int sens, vec3 centre) {\n    if (sens == 1) { // sens horaire\n        return vec3(centre.x + rayon*cos(-t), centre.y + rayon*sin(-t), centre.z) ;\n    } else { // sens trigo\n        return vec3(centre.x + rayon*cos(t), centre.y + rayon*sin(t), centre.z) ;\n    }\n}\n\nvec3 texturePlaneXZ(vec3 pos) {\n\treturn texture(iChannel0, pos.xz).rgb;\n}\n\n\nvec3 tourneplan(float rayon, float t, int sens, vec3 centre)\n{\n    if (sens == 1) { // sens horaire\n        return vec3(centre.x + rayon*cos(-t), centre.y + rayon*sin(-t), centre.z) ;\n    } else { // sens trigo\n        return vec3(centre.x + rayon*cos(t), centre.y + rayon*sin(t), centre.z) ;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n  \n   Camera C = camera(\n       vec3(rotPos(3.8, 0.5*iTime, 1, vec3(0,0,6))),\n       vec3(0.5, 0.5, 0.5),\n       60.0\n   );\n   \n   \n   \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float size = (-uv.y+.1)/1.5;\n\n  \n    Ray r = launch(C, fragCoord) ;\n\n    // background\n    vec3 col = texture(iChannel0, r.Origin.xy).rgb;\n\n    const int nSphere = 2 ;\n    const int nLux = 2 ;\n\n\n    // SphÃ¨res\n    Sphere sph[nSphere] ;\n    sph[0] = Sphere(vec3(0,0,0),0.5) ;\n    sph[1] = Sphere(rotPos(1.2,0.5*iTime,-1,vec3(0,0,0)),0.2) ;\n\n\n\n    // LumiÃ¨res\n    Light lum[nLux] ;\n    lum[0] = Light(vec3(5.5,14,1.5), vec3(0,1,1)) ;\n    lum[1] = Light(vec3(0,3,6), vec3(1,0,0)) ;\n    \n\n    float t[nSphere] ;\n    bool b[nSphere] ;\n    for (int i = 0 ; i < nSphere ; i++) {\n        b[i] = intersect_sphere(r, sph[i], t[i]) ;\n    }\n\n    // Calcul de la sphÃ¨re la plus proche\n    int imin = -1 ;\n    for (int i = 0 ; i < nSphere ; i++) {\n        if (b[i]) {\n            if (imin < 0 && t[i] > 0.0) {\n                imin = i ;\n            } else {\n                if (t[i] > 0.0 && t[i] < t[imin]) {\n                    imin = i ;\n                }\n            }\n        }\n    }\n    \n\n    // Gestion du sol\n    float tsol = 1. ;\n    float h = 1.0 ;\n    bool bsol = intersect_floor(r, h, tsol) ;\n    if (bsol) {\n      vec3 sum;\n      sum = vec3(0.,0.,0.);\n      sum += texture(iChannel0,(r.Origin+tsol*r.Dir).xy).xyz; \n        for (int i = 0 ; i < nLux ; i++) {\n            float o = 1.0 ;\n            for (int j = 0 ; j < nSphere ; j++) {\n                o *= ombresphere(C.Obs, r.Dir, tsol, sph[j], lum[i]) ;\n            }\n            sum += o*eclairesol(lum[i], C.Obs, r.Dir, h, tsol) ;\n        }\n        col = vec3(1,1,1)*sum ;\n        \n    }\n    \n    // sphÃ¨re la plus proche\n    if (imin >= 0 && t[imin] < tsol) {\n        vec3 sum = vec3(0, 0, 0) ;\n        for (int i = 0 ; i < nLux ; i++) {\n            float o = 1.0 ;\n            for (int j = 0 ; j < nSphere ; j++) {\n                if (imin != j) {\n                    o *= ombresphere(C.Obs, r.Dir, t[imin], sph[j], lum[i]) ;\n                }\n            }\n            sum += o*eclaire(lum[i], C.Obs, r.Dir, sph[imin].Center, t[imin]) ;\n        }\n        col = vec3(1,1,1)*sum;\n\n    }   \n    \n    fragColor = vec4(col,1.0) ;\n}\n","name":"Image","description":"","type":"image"}]}