{"ver":"0.1","info":{"id":"mlVyzw","date":"1700075999","viewed":53,"name":"Zelda Sea (WIP)","username":"3t13nn3","description":"Zelda Sea","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["zeldasea"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SEED 1.\n\nvec2 pixalate(inout vec2 uv, float pixelNumber) {\n    return floor(uv * pixelNumber) / pixelNumber;\n}\n\nvec3 sepia(inout vec3 col, float rate) {\n    // Convert to grayscale\n    float gray = dot(col.rgb, vec3(0.299, 0.587, 0.114));\n\n    // Apply sepia tone\n    vec3 sepia = vec3(gray * 1.2, gray * 0.9, gray * 0.7);\n\n    // Mix the sepia tone with the original color\n    return mix(col.rgb, sepia, rate);\n}\n\nmat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat hash(float n) {\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat rand(float minVal, float maxVal, float seed) {\n    return mix(minVal, maxVal, hash(seed));\n}\n\nfloat sdTriangle(in vec2 p, in vec2 off, in float r)\n{\n    p += off;\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nstruct Box {\n    vec2 pos;\n    vec2 offset;\n    vec2 prop;\n    float sdf;\n};\n\nBox sdBox(vec2 pos, vec2 offset, vec2 prop)\n{\n    vec2 d = abs(pos + offset) - prop;\n    float sdf = length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n    return Box(pos, offset, prop, sdf);\n}\n\nvec3 clouds(in vec2 uv, inout vec3 col) {\n    vec2 circleUV = uv / 5.;\n    float d = length(vec2(circleUV.x - 0.35, circleUV.y - 0.18));\n    d = min(d, length(vec2(circleUV.x - 0.3, circleUV.y - 0.14)));\n    d = min(d, length(vec2(circleUV.x - 0.27, circleUV.y - 0.07)));\n    d = min(d, length(vec2(circleUV.x - 0.29, circleUV.y - 0.02)));\n    d = min(d, length(vec2(circleUV.x - 0.23, circleUV.y + 0.02)));\n    d = min(d, length(vec2(circleUV.x - 0.2, circleUV.y + 0.06)));\n    d = min(d, length(vec2(circleUV.x - 0.16, circleUV.y + 0.10)));\n    d = min(d, length(vec2(circleUV.x - 0.1, circleUV.y + 0.10)));\n    d = min(d, length(vec2(circleUV.x - 0.06, circleUV.y + 0.08)));\n    d = min(d, length(vec2(circleUV.x - 0.02, circleUV.y + 0.12)));\n    d = min(d, length(vec2(circleUV.x + 0.04, circleUV.y + 0.13)));\n    d = min(d, length(vec2(circleUV.x + 0.10, circleUV.y + 0.11)));\n    d = min(d, length(vec2(circleUV.x + 0.17, circleUV.y + 0.08)));\n    d = min(d, length(vec2(circleUV.x + 0.22, circleUV.y + 0.04)));\n    d = min(d, length(vec2(circleUV.x + 0.27, circleUV.y + 0.07)));\n    d = min(d, length(vec2(circleUV.x + 0.33, circleUV.y + 0.02)));\n    d = min(d, length(vec2(circleUV.x + 0.35, circleUV.y - 0.02)));\n    d = min(d, sdBox(uv, vec2(1.4, 0.42), vec2(0.4, 0.2)).sdf);\n    d = min(d, sdBox(uv, vec2(-1.4, 0.3), vec2(0.4, 0.2)).sdf);\n    d = min(d, sdBox(uv, vec2(-1.6, -0.3), vec2(0.2, 0.4)).sdf);\n\n    float cloudRadius = 0.04;\n    float contourWidth = 0.0025;\n    if ((d < cloudRadius)) {\n        col = mix(vec3(1.0), vec3(0.071,0.443,0.471) - uv.y, 1.-exp(uv.y));\n    } else if (d - cloudRadius < contourWidth) {\n        col = mix(col, vec3(0.0, 0.1, 0.1), 0.5);\n    }\n    return col;\n}\n\nvec3 triforce(in vec2 uv, inout vec3 col, float size, float rotationDegree) {\n    float triangleSDF = sdTriangle(uv * rotate(rotationDegree), vec2(0.0, -0.25) * rotate(rotationDegree), size);\n    float angle = 3.1415;\n    float smallTriangleSDF = sdTriangle(uv * rotate(angle) * rotate(rotationDegree), vec2(0.0, -0.25) * rotate(angle) * rotate(rotationDegree), size / 2.);\n    float shape = max(triangleSDF, -smallTriangleSDF);\n    if (shape < 0.0) {\n        col = vec3(0.890,0.757,0.125);\n    } else if (shape < 1.) {\n        col = col = mix(col, vec3(0.890,0.757,0.125), 1.- smoothstep(-0.25 , abs(cos(iTime)) / 5., shape));\n    }\n\n    if (shape > -abs(cos(iTime / 2.)) * size * 0.05 && shape < 0.0) {\n        col = mix(col, vec3(0.478,0.408,0.063), 0.5);\n    }\n    return col;\n}\n\nvec3 water(in vec2 uv, inout vec3 col) {\n    const int numBoxes = 20;\n    Box boxes[numBoxes];\n    for(int i = 0; i < numBoxes; ++i) {\n        float currPos = (rand(-5., 5., float(i*2) * SEED) + iTime * (rand(0.8, 1.2, float(i) * SEED)));\n        currPos = mod(currPos, 10.0) - 5.;\n        boxes[i] = sdBox(uv,\n            vec2(\n                currPos,\n                rand(0.55, 0.98, float(i) * SEED)\n            ),\n            vec2(rand(0.2, 0.5, float(i*2) * SEED), 0.01)\n        );\n        if (boxes[i].sdf < 0.0) {\n            col = vec3(0.537,0.835,0.894);\n        }\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv = pixalate(uv, 70.0);\n    \n    vec3 col = vec3(0.0);\n    \n    if(uv.y >= -0.5) {\n        col = vec3(0.220,0.667,0.878);\n        \n        //col = triforce(uv + vec2(sin(iTime), cos(iTime) / 2.), col, 0.5);\n    \n        col = clouds(uv, col);   \n    }\n    \n    \n    \n    if(uv.y < -0.5) {\n        col = vec3(0.071,0.443,0.471);\n        col = water(uv, col);\n        \n    }\n    \n    col = sepia(col, 0.25 + cos(iTime) / 2.);\n    \n    if(uv.y >= -0.5) {\n        float time = iTime + 3.1415 / 2.0;\n        vec2 triforcePos[4];\n        triforcePos[0] = vec2(-1.4, 0.45);\n        triforcePos[1] = vec2(1.4, 0.45);\n        triforcePos[2] = vec2(1.4, -0.45);\n        triforcePos[3] = vec2(-1.4, -0.45);\n\n        int i = int(mod(time / 2. * (2. /  3.1415) , 4.0));\n\n        vec2 startPos = triforcePos[i];\n        vec2 endPos = triforcePos[(i + 1) % 4];\n\n        float t = smoothstep(0.0, 1.0, cos(iTime));\n        vec2 interpolatedPos = mix(startPos, endPos, t);\n        col = mix(col, triforce(uv + interpolatedPos, col, 0.25, cos(iTime) * sin(iTime * 10.) / 5.), clamp(cos(iTime), 0.0, 1.0));\n    }\n    \n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}