{"ver":"0.1","info":{"id":"4lySDh","date":"1484038243","viewed":127,"name":"data buf","username":"acdimalev","description":"General purpose computing with a data buffer.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["gpgpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Demonstrate using a buffer for GPGPU.\n// \n// This is intended for diagnostic to verify that the basic functionality\n// works across a variety of graphics cards.\n// \n// bottom-left and top-right should fade from black to white\n// bottom-right and top-left should fade from white to black\n// \n// If you see any other behavior, please shout out at me about what kind\n// of video card you have!\n\n\n// must match the datumRes in Buf A\nconst vec2 datumRes = vec2(2.0, 2.0);\n\n// grab a bit of data from a given index\nvec4 datum(int i) {\n    return texelFetch(iChannel0, ivec2(i, 0), 0);\n}\n\n// overly simple and verbose logic\n// as hard to get wrong as possible\n// to make troubleshooting data storage easier\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool left = fragCoord.x < iResolution.x / 2.0;\n    bool bottom = fragCoord.y < iResolution.y / 2.0;\n    \n    bool right = !left;\n    bool top = !bottom;\n    \n    float value = 0.0;\n    \n    if (bottom && left) { value = datum(0).x; }\n    if (bottom && right) { value = datum(2).x; }\n    if (top && left) { value = datum(3).x; }\n    if (top && right) { value = datum(1).x; }\n    \n    fragColor = vec4(vec3(value), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// grab a bit of data from a given index\nvec4 datum(int i) {\n    return texelFetch(iChannel0, ivec2(i, 0), 0);\n}\n\n// fade colors in two different directions\n// using functions to abstract function from data location\n\nconst float steps = 256.0;\n\nvoid advance(out vec4 fragColor, in int i) {\n    float last = datum(i).x * steps;\n    float next = mod(last + 1.0, steps);\n    fragColor = vec4(next / steps, vec3(1.0));\n}\n\nvoid retreat(out vec4 fragColor, in int i) {\n    float last = datum(i).x * steps;\n    float next = mod(last - 1.0, steps);\n    fragColor = vec4(next / steps, vec3(1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int i = int(fragCoord.x);\n    if (3 < i) discard;\n    \n    if (i == 0 || i == 1) { advance(fragColor, i); }\n    if (i == 2 || i == 3) { retreat(fragColor, i); }\n}","name":"Buffer A","description":"","type":"buffer"}]}