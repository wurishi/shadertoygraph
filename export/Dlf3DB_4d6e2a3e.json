{"ver":"0.1","info":{"id":"Dlf3DB","date":"1672324963","viewed":135,"name":"Recursive Glass RT","username":"kastorp","description":"tentative to implement glass raytracing recursion using stack \n\n","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","glass","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Recursive Glass RT by Kastorp\n//  tentative to implement glass raytracing recursion using stack \n// \n// the original version with macro is faster https://www.shadertoy.com/view/mtlGW7\n// but this version allows double ray depth (and almost total reflection).\n// Probably reusing stackdata output as input I could gain more fps \n//------------------\n// Credits:\n//   recursion logic from https://www.shadertoy.com/view/MsXyRM \n//   rendering from https://www.shadertoy.com/view/4s2Gz3\n//   model from https://www.shadertoy.com/view/ltsfzN\n//-------------------------------------\n\n\nint SCENE= -1;  //0=DODECAHEDRON,1=ICOSAHEDRON,  2=TRUNCATED ICOSAHEDRON. -1=all\n//#define BUMPY\n#define AUTOCAM\n#define SPIN\n#define DEPTH 8 //ray depth  (try with 18 to simulate total internal reflections)\n\n\n// rotate camera\n#define PI 3.141592653\n#ifdef AUTOCAM\n#define anglex2 (sin(iTime*0.3)*0.4)\n#define angley2 (iTime*0.2-0.4)\n#else\n #define anglex2  (0.5 - iMouse.y/iResolution.y)*PI*1.2\n #define angley2  -iMouse.x/iResolution.x*PI*2.0\n#endif\n\nvec3 campos;\nvec3 dir;\nint side; // 1 for ray outside glass,  -1 for ray inside glass\nfloat gTravel;\nvec3 gNormal;\nfloat travelMax,travelMin;\nvec3 normalMax,normalMin;\n \n\n//from https://www.shadertoy.com/view/4s2Gz3\nvec3 sky()\n{\n    vec3 sunDir = normalize(vec3(0.0,0.3,1.0));\n\tfloat f = max(dir.y,0.0);\n\tvec3 color = 1.0-vec3(1,0.85,0.7)*f;\n\tcolor *= dir.z*0.2+0.8;\t\n\tif (dot(sunDir,dir)>0.0)\n\t{\n\t f = max(length(cross(sunDir,dir))*10.0,1.0);\t\t\n\t color += vec3(1,0.9,0.7)*40.0/(f*f*f*f);\n\t}\n\treturn color;\t\n}\n\nvec3 backGround()\n{\n    //return abs(dir)*2.-max(dir,vec3(0)).zxy +min(dir,vec3(0)).yzx;\n \tif (dir.y>=0.0) return sky();\n \tvec3 raypos2 = campos - dir*(campos.y / dir.y);\n\tfloat fog = exp(length(raypos2)/-8.0);\n \treturn sky()*(1.0-fog) +texture(iChannel0,raypos2.xz*1.).rgb *fog;\n}\n\n\n\nvec3 rotatex(vec3 v,float anglex)\n{\n\tfloat t;\n\tt =   v.y*cos(anglex) - v.z*sin(anglex);\n\tv.z = v.z*cos(anglex) + v.y*sin(anglex);\n\tv.y = t;\n\treturn v;\n}\n\nvec3 rotcam(vec3 v)\n{\n\tfloat t;\n\tv = rotatex(v,anglex2);\n\t\n\tt = v.x * cos(angley2) - v.z*sin(angley2);\n\tv.z = v.z*cos(angley2) + v.x*sin(angley2);\n\tv.x = t;\n\treturn v;\n}\n\n//from https://www.shadertoy.com/view/4s2Gz3\n// a ray hits a surface surfaceside shows weather it hit from the rear or front of the plane \nvoid update(float surfaceside,float travel,vec3 normal)\n{\n\tif (surfaceside<0.0)\n\t{\n\t\tif (travelMax<travel)\n\t\t{\n\t\t\ttravelMax = travel;\n\t\t\tnormalMax = normal;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (travelMin>travel)\n\t\t{\n\t\t\ttravelMin = travel;\n\t\t\tnormalMin = normal;\n\t\t}\n\t}\n}\n\n//from https://www.shadertoy.com/view/4s2Gz3\nvoid hitPlane(vec3 normal,float shift) // check ray-plane intersection. Planes are infinte large\n{\n#ifdef SPIN\n\tfloat angle = fract(iTime*0.25);\n\tangle = min(angle*1.5,1.0);\n\t\n\tnormal = rotatex(normal,angle*PI*2.0);        // rotate object\n#endif\n\tshift += normal.y*1.0;         // and shift up from the ground height\n\t\n\tfloat distFromPlane = dot(normal,campos) - shift;\n\tfloat travel = -distFromPlane / dot(normal,dir);\n\tupdate(dot(normal,dir),travel,normal);\n}\n\n//from https://www.shadertoy.com/view/4s2Gz3\nvoid startObj()\n{\n\ttravelMax = -1e35;\n\ttravelMin = 1e35;\n}\n\n//from https://www.shadertoy.com/view/4s2Gz3\nvoid endObj()\n{\n//\tif (travelMax<travelMin)     // enable this for nonconvex objects\n\t{\n\t\tif (side>0)\n\t\t{\n\t\t\tif (travelMax<travelMin && travelMax>0.0 && travelMax<gTravel)\n\t\t\t{\n\t\t\t\tgTravel = travelMax;\n\t\t\t\tgNormal = normalMax;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (travelMin>0.0 && travelMin<gTravel)\n\t\t\t{\n\t\t\t\tgTravel = travelMin;\n\t\t\t\tgNormal = -normalMin;\n\t\t\t}\n\t\t}\n\t}\n}\n\n//from https://www.shadertoy.com/view/4s2Gz3\nvec3 glassColorFunc(float dist) // exponentially turn light green as it travels within glass (real glass has this prorperty)\n{\n\tif(side>0) return vec3(1,1,1);\n    //dist*=2.;\n\treturn vec3(exp(dist*-0.4),exp(dist*-0.05),exp(dist*-0.2));\n}\n\n//https://www.shadertoy.com/view/ltsfzN\n// i=0..11 dodecahedron normals\n//   divided into 6 pairs: 0-3, 1-2, 4-7, 5-6, 9-10, 8-11\n// i=12..32 icosahedron normals\n//  divided into 5 tetrahedra groups: 12-17-23-29, 13-19-20-27, 14-18-22-24, 15-16-21-30, 25-26-28-31\nvec3 getNormal(int i) {\n\tint block = i / 4;\n    vec3 signs = sign(vec3(i & ivec3(4, 2, 1)) - 0.1);\n    \n    if (block > 5) return 0.5774 * signs;\n    \n    vec3 r = signs * (block < 3 ? vec3(0.0,0.8507, 0.5257 ) : vec3(0.0, 0.3568,0.9342));\n   i=block%3;\n   return i==0?r:i==1 ?r.zxy:r.yzx;\n}      \n\nvoid hitObject() // trace the mesh\n{\n\tstartObj();\n    if(SCENE<0) SCENE=int(iTime/5.)%3;\n    int i1=0,i2=12; //dodecahedron as twelve planes intersection\n    if(SCENE>=1) i2=32;\n    if(SCENE==1) i1=12;    \n    for(int i=min(iFrame,i1);i<i2;i++) hitPlane(getNormal(i),.7*(i < 12 ? 1.0 : 0.975));\n\tendObj();\t\n}\n\n\nvec3 glassBG() //necessary if DEPTH<18 \n{\n   // return vec3(10,0,0); \n\treturn vec3(.3,.8,.7);\n}\n\n\nvoid bumpit()\n{\n#ifdef BUMPY\n\tgNormal.x += sin(campos.x*30.0)*0.007;\n\tgNormal.y += sin(campos.y*30.0)*0.007;\n\tgNormal.z += sin(campos.z*30.0)*0.007;\n\tgNormal = normalize(gNormal);\n#endif\n}\n\nvec3 trace() // recursive RayTracing - optimized version\n{    \n    #define ITERS (DEPTH*4) //max number of stack operations\n     \n    int cycle=0; //cycle counter; each ray has 4 cycles\n\n    struct ray{ \n        int i,    // ray depth\n            t,    // type: 1=object 2:exterior\n            p;    // recursion completion 0=no ray, 1=refraction ray, 2=both\n        float fr, // fresnel \n              gT; // glass travel\n        vec3 s,   // light sum\n             oP,  // hit position\n             rD;  // reflect dir\n    }; \n      \n    ray stack[DEPTH];  \n    const int CALL=1, RETURN=0; \n    \n    //initialization\n    int z=0;        //current depth\n    int mode=CALL;\t//call mode     \n    stack[0] = ray(1,1,0,0.,0.,vec3(0),vec3(0),vec3(0));  //initial ray\n     \n    do {    \n       if (mode==CALL) { \n           int zn=z+1;         \n           if (!(length(dir)<1.01) || !(length(dir)>0.99)) {stack[z].s=vec3(0);mode = RETURN; }          \n           if(stack[z].t!=1) {stack[z].s=backGround(); mode = RETURN; }\n           else if(stack[z].i>=DEPTH) {stack[z].s=glassBG(); mode = RETURN; }\n           else {\n                gTravel=1e35;\n                hitObject(); \n                if (gTravel>1e34) {stack[z].t=2; stack[z].s=backGround();mode = RETURN; }\n                else{\n                    campos += dir * gTravel;\n                    bumpit();                  \n                    stack[z].gT = (gTravel);                    \n                    stack[z].oP = campos;                    \n                    stack[z].rD=reflect(dir,gNormal);\n                    dir = refract(dir,gNormal,side>0 ? 1.0/1.52 : 1.52); \n                    float t = clamp(1.0+dot(gNormal,side>0?-stack[z].rD : dir),0.0,1.0);\t\n                    stack[z].fr = 0.1 + (t*t*t*t*t)*0.9;                    \n                    side *=-1;                                                   \n                    stack[zn].i=stack[z].i+1;\n                    stack[zn].t=stack[z].i<=1?1:2; //refraction is internal on first ray, and otherwise external\n                    stack[zn].s=vec3(0.);\n                    stack[zn].p=0;\n                    z=zn;                   \n                }\n           }\n       } else { //mode == RETURN\n            int zp=z-1;\n            if (z<=1) return stack[z].s;\n            else if(stack[zp].t!=1 ){               \n                stack[zp].s +=stack[z].s; \n                z=zp;\n            }\n            else if(stack[zp].p==0 ){ \n                stack[zp].p++; \n                stack[zp].s+=stack[z].s*(1.0-stack[zp].fr); \n                side *=-1;\n                campos = stack[zp].oP;  \n                dir = stack[zp].rD;                 \n                stack[z].s = vec3(0);\n                stack[z].t=stack[zp].i<=1?2:1;//reflection is external on first ray, and otherwise internal\n                stack[z].p=0;\n                mode = CALL;                \n            }\n            else if(stack[zp].p>=1 ){ \n                stack[zp].p++; \n                stack[zp].s+=stack[z].s*stack[zp].fr;\n                stack[zp].s*=glassColorFunc(stack[zp].gT);\n                z=zp;                \n            }\n         }\n    } while(cycle++<ITERS ); \n\n    return vec3(-1.);        \n}\n\n\n#define R iResolution.xy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tcampos = vec3(0,1.0,0)-rotcam(vec3(0,0,2));\n\tdir = normalize(rotcam(vec3((fragCoord.xy -R*.5)/R.y,1)));\n    side = 1;\t\n\tfragColor = vec4((trace()*min(iTime/5.0,1.0)),1.0); \n}\n\n/*\n//unoptimized version - has too many array copy operations\nvec3 trace() \n{\n    #define SIZE 9 //stack depth \n    #define ITERS 18 //max number of stack operations\n     \n    int cycle=0; //cycle counter\n\n    //auxiliary functions (should be the same for every direct recursion function\n    struct StackData{ \n        int i;    // ray depth\n        int t;    // type: 1=internal 2:external\n        int p;    // recursion completion 0=no ray, 1=refraction ray, 2=both\n        float fr; // fresnel \n        vec3 s;   // light sum\n        vec3 gC,  // glass color\n        oD,       // hit direction\n        oP,       // hit position\n        oN;       // hit normal\n    }; \n    #define new(ii,tt,cc) StackData(ii,tt,0,0.,cc,vec3(1),vec3(0),vec3(0),vec3(0))\n    StackData n; //current ray    \n    StackData stack[SIZE];  \n    int z=0; \n    int mode; const int CALL=1, RETURN=0;\n    \n    #define push(v)       stack[z++] = v\n    #define pop()         stack[--z]\n    #define empty()       z<=0\n    #define CALL(v)     { SAVE_CTX; push(v); mode = CALL;   }\n    #define RETURN(v)   { push(v); mode = RETURN; }\n    #define SAVE_CTX      push(n)\n    #define RESTORE_CTX   n = pop()\n    #define GET_PARAM     pop()\n    #define GET_RETURN    pop(); RESTORE_CTX   \n \n    // recursion engine  \n\t\n    CALL(new(1,1,vec3(0)))\n    do {    \n       if (mode==CALL) { \n           n = GET_PARAM;\n           if (!(length(dir)<1.01) || !(length(dir)>0.99)) RETURN(new(1,2,vec3(0)))          \n           if(n.t!=1) RETURN(new(n.i,2,backGround()))\n           else if(n.i>=SIZE) RETURN(new(n.i,2,glassBG()))\n           else {\n                gTravel=1e35;\n                hitObject(); \n                if (gTravel>1e34) RETURN(new(n.i,2,backGround()))\n                else{\n                    campos += dir * gTravel;\n                    bumpit();\n                    n.gC = glassColorFunc(gTravel);\n                    n.oD = dir;\n                    n.oP = campos;\n                    n.oN = gNormal;\n                    dir = refract(n.oD,n.oN,side>0 ? 1.0/1.52 : 1.52); \n                    float t = clamp(1.0+dot(gNormal,side>0?n.oD : dir),0.0,1.0);\t\n                    n.fr = 0.1 + (t*t*t*t*t)*0.9;\n                    side *=-1;             \n\n                    CALL(new(n.i+1,n.i<=1?1:2,vec3(0.))); \n                }\n           }\n       } else {  \n            StackData v = GET_RETURN; \n            if (empty()) return v.s;//*v.gC;\n            else if(n.t!=1 ){\n                v.s*=n.gC;\n               RETURN(v);\n            }\n            else if(n.p==0 ){ \n                n.p++; \n                n.s+=v.s*(1.0-n.fr); \n                side *=-1;\n                campos = n.oP;\n                gNormal=n.oN;\n                dir = reflect(n.oD,n.oN);\n                //RETURN(n)  \n                CALL(new(n.i+1,n.i<=1?1:2,vec3(0)))  \n            }\n            else if(n.p>=1 ){ \n                n.p++; \n                n.s+=v.s*n.fr;\n                n.s*=n.gC;\n                RETURN(n)  \n            }\n         }\n    } while(cycle++<ITERS ); \n\n    return vec3(-1.);        \n}\n\n//previous version with different stack data\nvec3 trace() \n{\n    \n    #define ITERS (DEPTH*4) //max number of stack operations\n     \n    int cycle=0; //cycle counter; each ray has 4 cycles\n\n    struct ray{ \n        int i;    // ray depth\n        int t;    // type: 1=object 2:exterior\n        int p;    // recursion completion 0=no ray, 1=refraction ray, 2=both\n        float fr; // fresnel \n        vec3 s;   // light sum\n        vec3 gC,  // glass color\n             oD,  // hit direction\n             oP,  // hit position\n             oN;  // hit normal\n    }; \n      \n    ray stack[DEPTH];  \n    const int CALL=1, RETURN=0; \n    \n    //initialization\n    int z=0;        //current depth\n    int mode=CALL;\t//call mode     \n    stack[0] = ray(1,1,0,0.,vec3(0),vec3(1),vec3(0),vec3(0),vec3(0));  //initial ray\n     \n    do {    \n       if (mode==CALL) { \n           int zn=z+1;         \n           if (!(length(dir)<1.01) || !(length(dir)>0.99)) {stack[z].s=vec3(0);mode = RETURN; }          \n           if(stack[z].t!=1) {stack[z].s=backGround(); mode = RETURN; }\n           else if(stack[z].i>=DEPTH) {stack[z].s=glassBG(); mode = RETURN; }\n           else {\n                gTravel=1e35;\n                hitObject(); \n                if (gTravel>1e34) {stack[z].t=2; stack[z].s=backGround();mode = RETURN; }\n                else{\n                    campos += dir * gTravel;\n                    bumpit();                  \n                    stack[z].gC = glassColorFunc(gTravel);\n                    stack[z].oD = dir;\n                    stack[z].oP = campos;\n                    stack[z].oN = gNormal;\n                    dir = refract(stack[z].oD,stack[z].oN,side>0 ? 1.0/1.52 : 1.52); \n                    float t = clamp(1.0+dot(gNormal,side>0?stack[z].oD : dir),0.0,1.0);\t\n                    stack[z].fr = 0.1 + (t*t*t*t*t)*0.9;\n                    side *=-1;                                                   \n                    stack[zn].i=stack[z].i+1;\n                    stack[zn].t=stack[z].i<=1?1:2; //refraction is internal on first ray, and otherwise external\n                    stack[zn].s=vec3(0.);\n                    stack[zn].p=0;\n                    z=zn;                   \n                }\n           }\n       } else { //mode == RETURN\n            int zp=z-1;\n            if (z<=1) return stack[z].s;\n            else if(stack[zp].t!=1 ){               \n                stack[zp].s +=stack[z].s; \n                z=zp;\n            }\n            else if(stack[zp].p==0 ){ \n                stack[zp].p++; \n                stack[zp].s+=stack[z].s*(1.0-stack[zp].fr); \n                side *=-1;\n                campos = stack[zp].oP;                \n                dir = reflect(stack[zp].oD,stack[zp].oN);\n                stack[z].s = vec3(0);\n                stack[z].t=stack[zp].i<=1?2:1;//reflection is external on first ray, and otherwise internal\n                stack[z].p=0;\n                mode = CALL;                \n            }\n            else if(stack[zp].p>=1 ){ \n                stack[zp].p++; \n                stack[zp].s+=stack[z].s*stack[zp].fr;\n                stack[zp].s*=stack[zp].gC;\n                z=zp;                \n            }\n         }\n    } while(cycle++<ITERS ); \n\n    return vec3(-1.);        \n}\t\t\t\t\t \n\n\n\n*/","name":"Image","description":"","type":"image"}]}