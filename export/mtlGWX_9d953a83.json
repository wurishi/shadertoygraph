{"ver":"0.1","info":{"id":"mtlGWX","date":"1672800669","viewed":78,"name":"REP1","username":"BrushC","description":"Raymarching Engine Practice 1\n\ntrying to get familiar with space distortions and general principals of rendering","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to make a simple camera\nCamera makeCamera(vec2 fragCoord, float zoomFactor, mat4 transformation) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 normalizedUV = uv * 2.0 - 1.0;\n    normalizedUV.x *= (iResolution.x / iResolution.y);\n    \n    vec4 rO = vec4(0, 0, 0.0, 1.0); // Ray origin\n    vec4 rD = vec4(normalizedUV * zoomFactor, 1.0, 1.0); // Ray direction\n    \n    rO *= transformation;\n    rD *= transformation;\n    \n    rD -= rO;\n    \n    return Camera(rO.xyz, rD.xyz);\n}\n\n// DE\nfloat distanceEstimator(vec3 point) {\n/*\n    mat4 transformation = mTranslation(6.0, 0., 0.) * mRotY(iTime);\n    float sphere1 = sdfSphere(point, 1.0, transformation);\n    float sphere2 = sdfSphere(point, 1.0, mIdentity());\n    float plane = sdfPlane(point, vec4(0, 1, 0, 2), mIdentity());\n    \n    float d = min(sphere1, sphere2);\n    d = min(d, plane);\n    \n    return d;\n*/\n    vec3 nP = point + 0.5;\n    float r1 = random(vec2(round(nP.x), round(nP.y)));\n    float r2 = random(vec2(round(nP.y), round(nP.z)));\n    float r3 = random(vec2(round(nP.z), round(nP.x)));\n\n    vec3 modSpace = mod(point, 1.0);\n    mat4 transformation = mTranslation(vec3(-0.5)) \n        * mRotX(r1*iTime) \n        * mRotY(r2*iTime) \n        * mRotZ(r3*iTime);\n    return sdfBox(modSpace, vec3(r1 * 0.2, r2 * 0.2, r3 * 0.2), transformation);\n}\n\n// Raymarch specifically for geometry\nvec4 geometryRaymarch(vec3 rO, vec3 rD) {\n    vec4 ray = vec4(rO, 0.0);\n    \n    for (int i = 0; i < GEOMETRY_MAX_MARCHES; i++) {\n        float stepDistance = distanceEstimator(ray.xyz);\n        stepDistance *= GEOMETRY_SCALE;\n        ray.xyz += rD * stepDistance;\n        ray.w += stepDistance;\n        \n        if (\n            stepDistance <= GEOMETRY_MIN_DISTANCE ||\n            stepDistance >= GEOMETRY_MAX_DISTANCE\n        ) return ray;\n    }\n    \n    ray.w = GEOMETRY_MAX_DISTANCE;\n    return ray;\n}\n\n// Geometry normal calculation\nvec3 geometryNormal(vec3 point) {\n    vec2 d = vec2(NORMAL_STEP_DISTANCE, 0.0);\n    \n    vec3 normal = distanceEstimator(point) - vec3(\n        distanceEstimator(point - d.xyy),\n        distanceEstimator(point - d.yxy),\n        distanceEstimator(point - d.yyx)\n    );\n    return normalize(normal);\n}\n\n// Calculates surface lighting\nvec3 calculateLighting(vec3 point, vec3 normal, Light light) {\n    vec3 trueColor = light.color.xyz * light.color.w;\n    vec3 lighting = vec3(0);\n    \n    switch(light.type) {\n        // Point light\n        case(0): {\n            float falloff = pow(length(point - light.position), 2.0);\n            vec3 omega = normalize(light.position - point);\n            lighting = dot(normal, omega) * trueColor / falloff;\n        } break;\n        \n        // Directional light\n        case(1): {\n            lighting = dot(normal, normalize(-light.direction)) * trueColor;\n        } break;\n    }\n    \n    return max(lighting, 0.0);\n}\n\n// Ray marching for shadows (penumbra approximation)\nfloat shadowRaymarch(vec3 point, Light light) {\n    float shadow = 1.0;\n    float intensity = light.color.w;\n    vec3 rD = vec3(1);\n    \n    switch(light.type) {\n        // Point light\n        case(0): { \n            rD = normalize(light.position - point); \n            intensity /= pow(length(light.position - point), 2.0);\n        } break; \n        case(1): { rD = normalize(-light.direction); } break; // Directional light\n    }\n    \n    vec4 ray = vec4(point, 0.0);\n    \n    for (int i = 0; i < SHADOW_MAX_MARCHES; i++) {\n        float stepDistance = distanceEstimator(ray.xyz);\n        stepDistance *= SHADOW_SCALE;\n        ray.xyz += rD * stepDistance;\n        ray.w += stepDistance;\n        \n        shadow = min(shadow, SHADOW_PENUMBRA * stepDistance / ray.w);\n        \n        if (stepDistance <= SHADOW_MIN_DISTANCE) {\n            shadow = 0.0;\n            break;\n        }\n        if (stepDistance >= SHADOW_MAX_DISTANCE) {\n            break;\n        }\n        \n    }\n    \n    return (1.0 - shadow) * intensity;\n}\n\n// Composition\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 col = vec3(0.1, 0.11, 0.15);\n    \n    vec2 mouseNormalized = (vec2(iMouse) / vec2(iResolution)) * 2.0 - 1.0;\n    \n    mat4 rotationTransformation = mRotX(PI * mouseNormalized.y) * mRotY(-TAU * mouseNormalized.x);\n    mat4 cameraTransformation = rotationTransformation;\n    cameraTransformation *= mTranslation(vec3(sin(iTime), cos(iTime), iTime * 2.0));\n    Camera camera = makeCamera(fragCoord, 1.0, cameraTransformation);\n    camera.rD = normalize(camera.rD);\n    \n    vec4 cP = geometryRaymarch(camera.rO, camera.rD); // Collision point\n    \n    // No hit\n    if (cP.w >= GEOMETRY_MAX_DISTANCE) {\n        fragColor = vec4(col, 1.0);\n        return;\n    }\n    \n    // Hit\n    vec3 sP = cP.xyz; // + camera.rD * distanceEstimator(cP.xyz) * GEOMETRY_SCALE; // Surface point\n    vec3 sN = geometryNormal(sP); // Surface normal\n    vec3 sS = sP + sN * SHADOW_OFFSET; // Surface shadow\n    \n    Light l1 = Light(1, vec3(0, 5, 0), vec3(1, -1, 1), vec4(1, 0.8, 0.8, 0.6));\n    Light l2 = Light(1, vec3(0), vec3(-1, -0.7, 0), vec4(0.0, 0.4, 1.0, 0.4));\n    \n    vec3 nP = sP + 0.5;\n    float r = random(vec2(round(nP.x), round(nP.y)));\n    float g = random(vec2(round(nP.y), round(nP.z)));\n    float b = random(vec2(round(nP.z), round(nP.x)));\n    \n    vec3 color = vec3(r, g, b);\n    vec3 lighting = calculateLighting(sP, sN, l1) + calculateLighting(sP, sN, l2);\n    float fog = 1.0 - exp(0.5 * -cP.w);\n    float shadow = shadowRaymarch(sS, l1) + shadowRaymarch(sS, l2);\n    shadow = pow(shadow, 5.0);\n    // vec3 composition = max(lighting - shadow, 0.0);\n    \n    vec3 composition = lighting + color / 2.0;\n    composition = mix(composition, col, fog);\n\n    fragColor = vec4(composition, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415\n#define TAU 6.2831\n\n#define GEOMETRY_MAX_MARCHES 128\n#define GEOMETRY_MIN_DISTANCE 1e-2\n#define GEOMETRY_MAX_DISTANCE 1e2\n#define GEOMETRY_SCALE 0.8\n\n#define NORMAL_STEP_DISTANCE 1e-3\n\n#define SHADOW_MAX_MARCHES 40\n#define SHADOW_MIN_DISTANCE 1e-4\n#define SHADOW_MAX_DISTANCE 1e4\n#define SHADOW_PENUMBRA 9.0\n#define SHADOW_SCALE 0.9\n#define SHADOW_OFFSET 5e-1\n\n// Simple random\nfloat random(vec2 co){\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// Structures\n\nstruct Camera {\n    vec3 rO;\n    vec3 rD;\n};\n\nstruct Light {\n    int type;\n    vec3 position;\n    vec3 direction; // Not rotation\n    vec4 color;\n};\n\n// Matrix functions\n\nmat4 mIdentity() {\n    return mat4(1, 0, 0, 0,  // Column 1, not row 1\n                0, 1, 0, 0,  // Column 2\n                0, 0, 1, 0,  // Column 3\n                0, 0, 0, 1); // Column 4\n}\n\nmat4 mTranslation(vec3 t) {\n    mat4 m = mIdentity();\n    m[0].w = t.x;\n    m[1].w = t.y;\n    m[2].w = t.z;\n    return m;\n}\n\nmat4 mRotX(float a) {\n    mat4 m = mIdentity();\n    m[1].y = cos(a);\n    m[1].z = sin(a);\n    m[2].y = -sin(a);\n    m[2].z = cos(a);\n    return m;\n}\n\nmat4 mRotY(float a) {\n    mat4 m = mIdentity();\n    m[0].x = cos(a);\n    m[0].z = -sin(a);\n    m[2].x = sin(a);\n    m[2].z = cos(a);\n    return m;\n}\n\nmat4 mRotZ(float a) {\n    mat4 m = mIdentity();\n    m[0].x = cos(a);\n    m[0].y = sin(a);\n    m[1].x = -sin(a);\n    m[1].y = cos(a);\n    return m;\n}\n\n// Signed Distance Functions\n\nfloat sdfSphere(vec3 point, float r, mat4 transformation) {\n    vec4 t = vec4(0, 0, 0, 1) * transformation;\n    return length(point - t.xyz) - r;\n}\n\nfloat sdfPlane(vec3 point, vec4 plane, mat4 transformation) {\n    vec4 n = vec4(normalize(plane.xyz), 1.0) * transformation;\n    return dot(point, n.xyz) + plane.w;\n}\n\nfloat sdfBox(vec3 point, vec3 box, mat4 transformation) {\n    vec3 newPoint = (vec4(point, 1.0) * transformation).xyz;\n    vec3 q = abs(newPoint) - box;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n}","name":"Common","description":"","type":"common"}]}