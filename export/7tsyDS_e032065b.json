{"ver":"0.1","info":{"id":"7tsyDS","date":"1648715250","viewed":73,"name":"Assignment/bkunii","username":"bkunii","description":"Saturn of another dimension. Gravity works differently... of course.  And the triangle was a design choice, a weird one :).\n\nAssignment of K9PGL0.","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Image\n// iChannel0: Buffer A\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = 2.*texelFetch(iChannel0,ivec2(fragCoord),0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Buffer A\n// iChannel0: Buffer A\n// iChannel1: Keyboard\n// iChannel2: a cubemap\n\nconst int spheresNo = 4;\nSphere spheres[spheresNo];\n\nconst int planeNo = 1;\nPlane planes[planeNo];\n\nconst int disksNo = 2;\nDisk disks[disksNo];\n\nconst int trianglesNo = 1;\nTriangle triangles[trianglesNo];\n\nMaterial materials[spheresNo + planeNo + disksNo + trianglesNo];\n\nTraceResult raycast(Ray ray);\n\nvec4 missColor(Ray ray) {\n    //return vec4(texture(iChannel2, ray.v).xyz,1.);\n    return vec4(0,0,0,0);\n}\n\nvec4 hitColor(Ray ray, TraceResult tr, vec3 lightPos) {\n    Material material = materials[tr.matID];\n\n    vec3 p = ray.p0 + ray.v*tr.t;\n    vec3 n = tr.n;\n    \n    vec3 v = -ray.v;\n    vec3 l = normalize(lightPos-p);\n    \n    // shadow\n    Ray shadowray = Ray(p, 0.001, l, length(lightPos - p));\n    TraceResult shadowRes = raycast(shadowray);\n    if(shadowRes.t < shadowray.tmax){\n        return vec4(0,0,0,1);\n    }\n    \n    // diffuse\n    float costheta = max(dot(n,l),0.);\n    vec3 k_d = material.color * material.roughness;\n    \n    // specular\n    vec3 toLight = normalize(lightPos - p);\n    vec3 toEye = -ray.v;\n    vec3 k_s = vec3(material.metalness);\n    \n    vec3 h = normalize(toLight+toEye);\n    float si = pow(clamp(dot(h,n),0.,1.),100.);\n    \n    // sum\n    vec3 col = (k_d + si * k_s) * costheta;\n    \n    return vec4(col,1.);\n}\n\n\n// ---- CAMERA and EVENTs ----\n// Common key codes (WASD instead of arrows)\n\nconst int KeyLeft  = 65;\nconst int KeyRight = 68;\nconst int KeyUp    = 87;\nconst int KeyDown  = 83;\n\n#define isKeyHeld(k)  (texelFetch(iChannel1, ivec2(k,0), 0).x > 0.)\n\nconst vec3 EyeStartPosition = vec3(10,7,16);\n\nRay Camera(vec2 fragCoord, out vec3 eye, out vec2 data2) {\n    /*\n        We will use the first 2 pixels of the buffer to store the information we need.\n        Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n            pixel0 = (empty, cameraX, cameraY, cameraZ)\n            pixel1 = (empty, empty, U, V)\n        where \n            cameraX, cameraY and cameraZ describe the position of the camera respectively\n            U,V give the current rotation of the camera in spherical coordinates\n\t*/\n    \n    // Ray generation\n    eye = texelFetch(iChannel0, ivec2(0,0), 0).yzw+EyeStartPosition;\t\t// camera position\n    data2 = texelFetch(iChannel0, ivec2(1,0), 0).zw;\t// spherical coordinates\n    vec2 uv\t= abs(data2);\n    \n   \tif(iMouse.z>0. || data2.x >= 0.)\t//mouse held or was held last frame\n        uv += (abs(iMouse.zw)-abs(iMouse.xy))*0.01;\n    \n    vec3 w = vec3(cos(uv.x)*cos(-uv.y),\n                  \t\t\tsin(-uv.y),\n                  sin(uv.x)*cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0,1,0),w));\n\tvec3 v = cross(w,u);\n    \n    vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    \n    // Keyboard and mouse handling:\n\tfloat speed = 0.2;\n    if (isKeyHeld(KeyLeft )) eye -= u*speed;\n    if (isKeyHeld(KeyRight)) eye += u*speed;\n    if (isKeyHeld(KeyUp   )) eye += w*speed;\n    if (isKeyHeld(KeyDown )) eye -= w*speed;\n    \n    if(iMouse.z>=0.)\t\t//mouse held\n        data2 = abs(data2.xy);\n\telse if(data2.x >= 0.)\t//mouse released\n        data2 = -mod(uv,2.*pi);\n    \n    // Ray generation\n    return Ray(eye,\t\t\t\t\t\t\t//P\n               0.5,\t\t\t\t\t\t\t//minT\n               normalize(w+px.x*u+px.y*v),\t//V\n               500.);\t\t\t\t\t\t//maxT\n}\n\n// ---- MAIN ----\n\nconst float maxT = 1000.0;\n\nTraceResult intersectDisk(Ray ray, Disk disk) {\n    float t = dot(disk.n, disk.q0 - ray.p0) / dot(disk.n, ray.v);\n    vec3 p = ray.p0 + t * ray.v;\n    if(distance(p, disk.q0) > disk.R){\n        return TraceResult(vec3(0),ray.tmax, -1); // no intersection\n    }\n    \n    if(distance(p, disk.q0) < disk.r){\n        return TraceResult(vec3(0),ray.tmax, -1); // no intersection\n    }\n    return TraceResult(disk.n, t, disk.matID);\n}\n\nTraceResult intersectSphere(Ray ray, Sphere s) {\n    vec3 p0c = ray.p0 - s.c;\n    float a = dot(ray.v, ray.v);\n    float b = 2.0 * dot(p0c, ray.v);\n    float c = dot(p0c,p0c) - s.r*s.r;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0)\n        return TraceResult(vec3(0),ray.tmax, -1); // no intersection\n    float sqd = sqrt(discriminant);\n    float numerator = -b - sqd;\n    if(numerator < 0.0)\n        numerator = -b + sqd;\n    float t = 0.5 * numerator / a;\n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - s.c);\n    return TraceResult(normal, t, s.matID);\n}\n\nTraceResult intersectPlane(Ray ray, Plane plane) {\n    float t = dot(plane.q0-ray.p0,plane.n)/dot(ray.v,plane.n);\n    return TraceResult(plane.n, t, plane.matID);\n}\n\nTraceResult intersectTriangle(Ray ray, Triangle triangle) {\n    float t, u, v;\n    \n    vec3 ab = triangle.a - triangle.b;\n    vec3 ac = triangle.c - triangle.a;\n    vec3 ap = ray.p0 - triangle.a;\n    vec3 f = cross(ray.v, ac);\n    vec3 g = cross(ap,ab);\n    \n    t = (1.0 / dot(f,ab)) * dot(g, ac);\n    u = (1.0 / dot(f,ab)) * dot(f,ap);\n    v = (1.0 / dot(f,ab)) * dot(g,ray.v);\n    \n    if(t < 0.0 || u < 0.0 || v < 0.0 || (1.0 - u - v) < 0.0) {\n        return TraceResult(vec3(0),ray.tmax, -1); // no intersection\n    }\n    \n    vec3 p = ray.p0 + t * ray.v;\n    vec3 normal = normalize(p - cross(ab,ac));\n    \n    return TraceResult(normal, t, triangle.matID);\n    \n}\n\nTraceResult raycast(Ray ray) {\n    TraceResult res = TraceResult(vec3(0), ray.tmax, -1);\n    for(int i = 0; i < spheresNo; ++i) {\n        TraceResult res2 = intersectSphere(ray, spheres[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    for(int i = 0; i < planeNo; ++i) {\n        TraceResult res2 = intersectPlane(ray, planes[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    for(int i = 0; i < disksNo; ++i) {\n        TraceResult res2 = intersectDisk(ray, disks[i]);\n        if(res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    for(int i = 0; i < trianglesNo; ++i) {\n        TraceResult res2 = intersectTriangle(ray, triangles[i]);\n        if(res2.t < ray.tmax && res2.t > ray.tmin && res2.t < res.t){\n            res = res2;\n        }\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Create moons\n    float radius = 20.0;\n    float x_0 = radius * cos(0.05 * iTime * 2.0 * pi);\n    float y_0 = radius * sin(0.05 * iTime * 2.0 * pi);\n    \n    float x_1 = radius * cos(0.13 * (iTime + 0.) * 2.0 * pi);\n    float y_1 = radius * sin(0.13 * (iTime + 0.) * 2.0 * pi);\n    \n    float x_2 = radius * cos(0.22 * (iTime + 0.) * 2.0 * pi);\n    float y_2 = radius * sin(0.22 * (iTime + 0.) * 2.0 * pi);\n    \n                           //color, rougness, emission, metalness\n    materials[0] = Material(vec3(2.3, 2.3, 3.1), 0.1, vec3(0), 0.7);\n    spheres[0] = Sphere(vec3(x_0, 0.1 * x_0 + y_0, y_0), 0.5, 0);\n    \n    materials[1] = Material(vec3(0.5, 2.5, 1), 0.2, vec3(0), 0.7);\n    spheres[1] = Sphere(vec3(x_1 + 6., 0, y_1 + 6.), 0.7, 1);\n    \n    materials[2] = Material(vec3(3.2, 0.3, 2.9), 0.1, vec3(0), 0.3);\n    spheres[2] = Sphere(vec3(x_2 + 10., x_2 / 2. + y_2 / 2. , y_2 + 10.), 0.9, 2);\n    \n    // Create bottom plane\n    materials[4] = Material(vec3(2.5, 0.2, 3.2), 0.1, vec3(0), 0.1);\n    planes[0] = Plane(vec3(-25), normalize(vec3(0,1,0)), 4);\n    \n    // Create planet\n    materials[3] = Material(vec3(0, 1.9, 2), 0.1, vec3(0), 0.9);\n    spheres[3] = Sphere(vec3(0, 0, 0), 5.f, 3);\n    \n    // Create rings\n    materials[5] = Material(vec3(0.5, 3., 2.), 0.1, vec3(0), 0.8);\n    disks[0] = Disk(vec3(0.,0.,0.), normalize(vec3(2.0 + (sin(0.5*iTime) * sin(0.5* iTime) * 2.0), 5.0 + (sin(0.5*iTime) * sin(0.5*iTime) * 2.0), 0)), 10.0, 6.0, 5);\n\n    materials[6] = Material(vec3(0.3, 0.8, 1.5), 0.1, vec3(0), 0.8);\n    disks[1] = Disk(vec3(0.,0.,0.), normalize(vec3(-1. + + (cos(0.1*iTime) * cos(0.1* iTime)),2,0)), 12.5, 11.5, 6);\n    \n    // Triangle stuff:\n    materials[7] = Material(vec3(2.5,0.2,3.2), 0.1, vec3(0), 0.7);\n    triangles[0] = Triangle(vec3(10,-10,0), vec3(0,5,-4), vec3(0,0,1), 7);\n\n    vec3 eye; vec2 data;                    // this will be saved into first two pixels\n    Ray ray = Camera(fragCoord, eye, data); // Generate ray from pixel\n    \n    TraceResult result = raycast(ray);      // Raycast\n    \n    if(ray.tmax<=result.t)\n        fragColor = missColor(ray);  \n    else {\n        fragColor = hitColor(ray, result, vec3(10.,10.,10.));\n        fragColor += hitColor(ray, result, vec3(0.,20.,20.));\n    }\n        \n    vec4 prev = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor = 0.3*prev + 0.7*fragColor;   // Motion blur\n    fragColor.w = result.t;\n\n    // First two pixels are reserved\n    if(fragCoord.x == 0.5 && fragCoord.y == 0.5) // pixel (0,0)\n        fragColor.yzw = eye-EyeStartPosition;\n    if(fragCoord.x == 1.5 && fragCoord.y == 0.5) //pixel (1,0)\n        fragColor.zw = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Common\n\nconst float pi = 3.1415926535897932384626433832795;\n \nstruct Material {\n    vec3 color; // [0,1/pi]\n    float roughness; // [0,~7]\n    vec3 emission; // [0, inf]\n    float metalness; // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n}; \n\nstruct Sphere {\n    vec3 c;    // center\n    float r;   // radius\n    int matID;\n};\n \nstruct Plane {\n    vec3 q0;    // any point on the plane\n    vec3 n;    // normal\n    int matID;\n};\n\nstruct Disk {\n    vec3 q0;   // point on the plane\n    vec3 n;    // normal vector of the plane\n    float R;    // disk outer radius\n    float r; // disk inner radius\n    int matID;\n};\n\nstruct Triangle {\n    vec3 a;\n    vec3 b;\n    vec3 c;\n    int matID;\n};\n \nstruct Ray\n{\n    vec3 p0;    // ray origin if tmin=0\n    float tmin; // omit solutions t<tmin\n    vec3 v;     // direction\n    float tmax; // omit solutions t>tmax\n};\n \nstruct TraceResult\n{\n    vec3 n;  // Normal vector on surface\n    float t; // Distance taken on ray\n    int matID; // Material properties of the object\n};\n\n","name":"Common","description":"","type":"common"}]}