{"ver":"0.1","info":{"id":"WsXSz2","date":"1551642111","viewed":104,"name":"Logistic Map In Motion - Chaos","username":"dj","description":"playing around with the logistic map more, this time with more chaos!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","chaos","logistic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Each line is the function v_N(r) for a given initial point/line v_0(r) = v0.\n// v_{n+1}(r) = r * v_n(r) * (1 - v_n(r))\n// N = TOTAL_ITER below.\n// We draw N_LINES total lines with different v0 values spread across (0, 0.5).\n\n// Total recursive iterations thru the logistic map to render\n// Higher means more like the real logistic map bifurcation diagram, with more chaos at right\n#define TOTAL_ITER 20\n// Number of lines to render\t\t\t\n#define N_LINES 15\n// Minimum r-value (x axis)\n#define R_MIN 2.5\n// Maximum r-value (x axis)\n#define R_MAX 4.0\n// Higher means thinner lines\n#define LINE_PRECISION 4.0\n// Lower means more \"bloom\" or \"glow\", but below 2 is dangerous\n#define LINE_ACCURACY 2.25\n// Number of loops in searching for minimum distance to curves\n#define DIST_FN_ACCURACY 7\n\n// Represents a (r, v) point on a line defined by v0, as well the distance\n// from (r, v) to given (r_fixed, v_fixed).\nstruct point {\n    // There's an implied 'float r', as well as 'float v0' which defines the line.\n    // Callers should know these values upfront.\n    float v; // v(r)\n    float dv; // dv/dr at r\n    float D2; // distance squared from (r_f, v_f) to (r, v)\n    float dD2dr; // d(D2)/dr at r.  Currently not used and set to 0.0\n};\n\n// Might as well use the logistic sigmoid...\nfloat sigmoid(float x, float mid, float slope) {\n\treturn 1.0 / (1.0 + exp(-slope * (x - mid)));\n}\n\n// Gets data about the point at r on the line defined by v0, compared to\n// arbitrary (r_f, v_f).\npoint get_point(float r_fixed, float v_fixed, float r, float v0) {\n    float v = v0;\n    float dv = 0.0;\n    \n    for (int a = 0; a < TOTAL_ITER; a++) {\n        float v_comp = 1.0 - v;\n        float v_prod = v * v_comp; // v*(1-v)\n        dv = v_prod + r * dv * (v_comp - v); // v*(1-v) + r*dv*(1-2v)\n        v = r * v_prod; // r*v*(1-v)\n    }\n    \n    float dist_r = r - r_fixed;\n    float dist_v = v - v_fixed;\n    float D2 = dist_r * dist_r + dist_v * dist_v;\n    float dD2dr = 0.0; // Disabled because not using, but would be: dist_r + dv * dist_v;\n    \n    return point(v, dv, D2, dD2dr);\n}\n\n// Gets the minimum squared distance from (r_f, v_f) to the line defined by v0.\nfloat get_min_D2(float r_fixed, float v_fixed, float v0) {\n    float r = r_fixed;\n    point p = get_point(r_fixed, v_fixed, r, v0);\n    float min_D2 = p.D2;\n    \n    for (int a = 0; a < DIST_FN_ACCURACY; a++) {\n        // Old, imperfect gradient-descent based approach:\n        // r = r + clamp(-0.5 * p.dD2dr / float(a + 1), -0.05, 0.05);\n        \n        // Find the best-guess tangent point on v(r) relative to (r_f, v_f)\n        // using dv/dr.\n        float dv2 = p.dv * p.dv;\n        r = (r_fixed + dv2 * r + (v_fixed - p.v) * p.dv) / (1.0 + dv2);\n        p = get_point(r_fixed, v_fixed, r, v0);\n        \n        min_D2 = min(min_D2, p.D2);\n    }\n    \n    return min_D2;\n}\n\n// Get color for a line.\nvec3 get_color(int index) {\n    float frac = float(index) / max(float(N_LINES - 1), 1.0);\n    vec3 color = mod(vec3(frac, frac + 1.0 / 3.0, frac + 2.0 / 3.0), 1.0);\n    color = max(2.5 * color - 1.0, 0.0);\n    return color;\n}\n\n// Get color to apply given distance to the line.\nvec3 get_color(float D2, int index) {\n    float strength = sigmoid(pow(D2, -0.1), LINE_PRECISION, LINE_ACCURACY);\n\treturn strength * get_color(index);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Get our pixel coord in [0, 1] (r is x, v is y)\n\tfloat r_frac = fragCoord.x / iResolution.x;\n\tfloat v = fragCoord.y / iResolution.y;\n\t\n\t// Shift r-axis to desired range\n\tfloat r = (R_MAX - R_MIN) * r_frac + R_MIN;\n\t\n\t// Some sinusoids to mess with the map over time\n\tfloat s = sin(iTime / 17.29);\n\tfloat c = cos(iTime / 21.0);\n\t\n    vec3 color = vec3(0.0);\n\t// Go thru each line, find its v0, get distance to our pixel, and add its color.\n\tfor (int index = 0; index < N_LINES; index++) {\n        // Get time-based and index-based trig term and limit to [-1, 1].\n        float bmod = float(index - 3 * (index / 3));\n        float trig_term = (s + bmod * c) / (1.0 + bmod);\n        \n        // Combine with index and limit to [0, 0.5], since [0.5, 1] is a mirror of it.\n        float frac = (float(1 + index) + trig_term) / (2.0 * float(N_LINES + 1));\n        \n        // Pass thru the logistic sigmoid for fun, plus to avoid 0.0 and 0.5.\n\t\tfloat v0 = 0.5 * sigmoid(frac, 0.25, 15.0);\n        \n        // Get dist sq from our pixel to the line defined by v0.\n        float D2 = get_min_D2(r, v, v0);\n        \n        color += get_color(D2, index);\n\t}\n    \n    fragColor = vec4(min(color, 1.0), 1.0);\n}","name":"Image","description":"","type":"image"}]}