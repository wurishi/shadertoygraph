{"ver":"0.1","info":{"id":"ltsXDB","date":"1439513462","viewed":328,"name":"Bumpy Reflecting Balls","username":"metabog","description":"Groovy m8.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"const int MAX_ITER = 100; // 100 is a safe number to use, it won't produce too many artifacts and still be quite fast\nconst float MAX_DIST = 200.0; // Make sure you change this if you have objects farther than 20 units away from the camera\nconst float EPSILON = 0.001; // At this distance we are close enough to the object that we have essentially hit it\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\nfloat distfunc(vec3 pos)\n{\n    \n    pos.x = mod(pos.x,10.0) - 5.0;\n    pos.y = mod(pos.y,10.0) - 5.0;\n    pos.z = mod(pos.z,10.0) - 5.0;\n    \n    float value =0.0;\n    \n    value = sphere(pos,2.0);\n    \n    return value;\n}\n\nvec4 evaluate(vec2 uv)\n{\n    \n    vec3 cameraOrigin = vec3(cos(iTime*0.02)*50.0,cos(iTime*0.05)*50.0,sin(iTime*0.02)*50.0); //vec3(2.0, 7.0, 2.0);\n\tvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 upDirection = vec3(0.0, 1.0, 0.0);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n    \n     float totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n    \n    vec3 rayDir = normalize(cameraRight * uv.x + cameraUp * (uv.y) + cameraDir);\n    \n    vec4 color = vec4(0.0,0.0,0.0,0.0);\n    \n    bool hasHitOnce = false;\n    \n    int hitTimes = 1;\n    \n    for (int i = 0; i < MAX_ITER; i++)\n\t{\n        \n        if(totalDist>MAX_DIST)\n            break;\n        \n        \n    \t // Either we've hit the object or hit nothing at all, either way we should break out of the loop\n   \t\t if ((dist < EPSILON) )\n   \t\t {\n        \tvec2 eps = vec2(0.0, EPSILON);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdistfunc(pos + eps.yxx) - distfunc(pos - eps.yxx),\n   \t\t\tdistfunc(pos + eps.xyx) - distfunc(pos - eps.xyx),\n   \t\t\tdistfunc(pos + eps.xxy) - distfunc(pos - eps.xxy)));\n    \n            //let's fuck with the normals a bit\n            normal.x += texture(iChannel0, vec2(pos.x,pos.z)*0.1).x*0.1;\n            normal.y += texture(iChannel0, vec2(pos.y,pos.z)*0.1).x*0.1;\n            normal.z += texture(iChannel0, vec2(pos.z,pos.x)*0.1).x*0.1;\n\n   \t\t\tfloat diffuse = max(0.0, dot(-rayDir, normal));\n    \t\tfloat specular = pow(diffuse, 64.0);\n        \tfloat value = diffuse*0.6;\n            vec4 hitcolor = hsv2rgb(vec3(totalDist/100.0,1.0,1.0)).xyzz*value + specular*0.002;\n             \n            if(hitTimes<3)\n            color += hitcolor/float(hitTimes);\n       \t \thasHitOnce = true;\n             \n            rayDir = 2.0 * dot(rayDir,normal)*normal - rayDir;\n            pos += rayDir*5.0;\n            totalDist = 0.0;\n\t\t\tdist = EPSILON;\n             \n            hitTimes++;\n   \t\t }\n        \n   \n        \n        \n    \tdist = distfunc(pos); // Evalulate the distance at the current point\n    \ttotalDist += dist;\n    \tpos += dist * rayDir; // Advance the point forwards in the ray direction by the distance\n\t}\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    uv*=0.1; //FOV\n    uv.x*= iResolution.x /iResolution.y;\n   \tvec4 col = evaluate(uv);\n\tfragColor = col;\n}","name":"Image","description":"","type":"image"}]}