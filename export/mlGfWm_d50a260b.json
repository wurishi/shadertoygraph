{"ver":"0.1","info":{"id":"mlGfWm","date":"1703069097","viewed":91,"name":"Generative Triangle Mosiac","username":"totimannino","description":"This algorithm breaks the image into blocks, each block storing a cache of random triangles.\nThe diff of each block to the original image is stored, triangles regen if the diff is too high.\nDiff threshold increases over 30 sec to ensure a halting point.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["triangle","generative","mosiac","multipass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // channel 1 shows the difference image\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License: Creative Commons Attribution-NonCommercial 4.0 International\n\nint seed = 0;\nint coordIdx = 0;\nvec3 prevResolution = vec3(0.);\nfloat timeOffset = 0.0;\n\n// tiny encryption algorithm for random sampling\n// https://redirect.cs.umbc.edu/~olano/papers/GPUTEA.pdf\n// implementation from https://www.shadertoy.com/view/4lfcDr\nvoid tinyEncrypt(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg.x;\n    uint v1 = arg.y;\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key.x) ^ (v1 + sum) ^ ((v1 >> 5) + key.y);\n\t\tv1 += ((v0 << 4) + key.z) ^ (v0 + sum) ^ ((v0 >> 5) + key.w);\n\t}\n\targ.x = v0;\n\targ.y = v1;\n}\n\nvec2 random2d()\n{\n  \tuvec2 arg = uvec2(coordIdx, seed++);\n  \ttinyEncrypt(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n\nvec4 GenerateRandomTriangle(in vec2 fragCoord)\n{\n        vec2 uvStep = vec2(1.)/iResolution.xy;\n        float fBSize = float(BLOCK_SIZE);\n        vec2 blockCenter = fBSize*(0.7*random2d() + 0.15 + floor(fragCoord/float(TRIPERBLOCKSQRT)));\n        vec2 sampScale = iChannelResolution[1].xy*uvStep;\n        \n        const float angDiv = 0.33*2.0*3.1415925;\n        float randAng = random2d().x*2.0*3.1415925;\n        vec2 cp0 = vec2(cos(randAng), sin(randAng))*(0.5*random2d().x + 0.5);\n        vec2 cp1 = vec2(cos(angDiv + randAng), sin(angDiv + randAng))*(0.5*random2d().x + 0.5);\n        vec2 cp2 = vec2(cos(2.*angDiv + randAng), sin(2.*angDiv + randAng))*(0.5*random2d().x + 0.5);\n        vec2 p0 = (blockCenter + cp0*fBSize)*uvStep;\n        vec2 p1 = (blockCenter + cp1*fBSize)*uvStep;\n        vec2 p2 = (blockCenter + cp2*fBSize)*uvStep;\n        vec4 imSamp = texelFetch(iChannel1, ivec2(blockCenter.xy*sampScale), 0);\n        // store triangle\n        return vec4(uintBitsToFloat(pack2x16(p0)),\n                    uintBitsToFloat(pack2x16(p1)),\n                    uintBitsToFloat(pack2x16(p2)),\n                    uintBitsToFloat(pack4x8(imSamp*0.5)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // for random2d\n    coordIdx = int(dot(fragCoord.xy, vec2(1, iResolution.y)));\n    seed = iFrame*coordIdx;\n    vec3 col = vec3(0.);\n    \n    ivec2 scoreIdx = BLOCK_SIZE*ivec2(floor(fragCoord/float(TRIPERBLOCKSQRT)));\n    float score = texelFetch(iChannel2, scoreIdx, 0).x;\n    \n    float timeOffset = texelFetch(iChannel3, ivec2(0), 0).x;\n    \n    // initialize first frame\n    // smoothly raise the score requirement over time to ensure convergence\n    if (iFrame == 0 || score > smoothstep(0., 30., iTime - timeOffset))\n    {   \n        fragColor = GenerateRandomTriangle(fragCoord);\n\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    \n    prevResolution = iResolution;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// BLOCK_SIZE == pixel block side width for triangle bin for that block area\n// TRIPERBLOCKSQRT == sqrt of number of triangles per block\n// compression ratio ~= (BLOCK_SIZE/TRIPERBLOCKSQRT)^2 since the size of triangle == size of texel\n\n//#define BLOCK_SIZE 32\n//#define TRIPERBLOCKSQRT 2\n\n#define BLOCK_SIZE 16\n#define TRIPERBLOCKSQRT 3\n\nuint pack2x16(vec2 x) {\n    x = round(clamp(x, 0., 1.) * 65535.);\n    uvec2 r = uvec2(x);\n    return r.x << 16 | r.y;\n}\n\nvec2 unpack2x16(uint x) {\n    uvec2 r = (uvec2(x) >> uvec2(16, 0)) & uvec2(0xFFFF);\n    vec2 v = vec2(r) / 65535.;\n    return v;\n}\n\nuint pack4x8(vec4 x) {\n    x = round(clamp(x, 0., 1.) * 255.);\n    uvec4 r = uvec4(x);\n    return r.x << 24 | r.y << 16 | r.z << 8 | r.w;\n}\n\nvec4 unpack4x8(uint x) {\n    uvec4 r = (uvec4(x) >> uvec4(24, 16, 8, 0)) & uvec4(0xFF);\n    vec4 v = vec4(r) / 255.0;\n    return v;\n}\n\nbool IsInsideTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c)\n{\n    vec2 ca = c - a;\n    vec2 ba = b - a;\n    vec2 pa = p - a;\n    \n    float dotcc = dot(ca, ca);\n    float dotcb = dot(ca, ba);\n    float dotcp = dot(ca, pa);\n    float dotbb = dot(ba, ba);\n    float dotbp = dot(ba, pa);\n    float det = dotcc*dotbb - dotcb*dotcb;\n    \n    if (det == 0.0f)\n    {\n        return false;\n    }\n    \n    float u = dotbb*dotcp - dotcb*dotbp;\n    float v = dotcc*dotbp - dotcb*dotcp;\n    \n    return (u >= 0.0f) && (v >= 0.0f) && (u <= det) && (v <= det) && ((u+v) <= det);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// License: Creative Commons Attribution-NonCommercial 4.0 International\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    vec3 col = vec3(0.);\n    float csum = 0.0;\n    float fBSize = float(BLOCK_SIZE);\n    float triPerBlock = float(TRIPERBLOCKSQRT);\n    vec2 blockOffset = triPerBlock*floor(fragCoord/fBSize);\n    \n    for (int i = -TRIPERBLOCKSQRT; i < 2*TRIPERBLOCKSQRT; ++i)\n    {\n        for (int j = -TRIPERBLOCKSQRT; j < 2*TRIPERBLOCKSQRT; ++j)\n        {\n            ivec2 ijClip = ivec2(int(blockOffset.x) + i, \n                                 int(blockOffset.y) + j);\n                                 \n            if ((ijClip.x >= 0) && \n                (ijClip.y >= 0) && \n                (ijClip.x < int(iResolution.x)) &&\n                (ijClip.y < int(iResolution.y)))\n            {\n                vec4 triangle = texelFetch(iChannel0, ijClip, 0);\n\n                if(triangle.a > 0.0)\n                {\n                    vec2 pt0 = unpack2x16(floatBitsToUint(triangle.x));\n                    vec2 pt1 = unpack2x16(floatBitsToUint(triangle.y));\n                    vec2 pt2 = unpack2x16(floatBitsToUint(triangle.z));\n                    vec4 ptc = 2.0*unpack4x8(floatBitsToUint(triangle.a));\n\n                    if (IsInsideTriangle(uv, pt0, pt1, pt2))\n                    {\n                        col += ptc.rgb;\n                        csum += 1.0f;\n                    }\n                }\n            }\n        }\n    }\n    \n    if (csum > 0.0)\n    {\n        col /= csum;\n    }\n    fragColor = vec4(col,1.0);\n    //fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// License: Creative Commons Attribution-NonCommercial 4.0 International\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 sampScale = iChannelResolution[1].xy/iResolution.xy;\n\n    float diffSum = 0.;\n    \n    for (int i = 0; i < BLOCK_SIZE; ++i)\n    {\n        for (int j = 0; j < BLOCK_SIZE; ++j)\n        {\n            vec4 orig = texelFetch(iChannel0, ivec2(fragCoord + vec2(i,j)), 0);\n            vec4 mosiac = texelFetch(iChannel1, ivec2((fragCoord + vec2(i,j))*sampScale), 0);\n            diffSum += distance(orig.rgb, mosiac.rgb);\n        }\n    }\n    \n    float diffCnt = float(BLOCK_SIZE*BLOCK_SIZE);\n    fragColor = vec4(vec3(diffSum/diffCnt), 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// input buffer\n// I wish I didn't need an entire buffer just for this :(\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if (iFrame == 0)\n    {\n        fragColor = vec4(vec3(0.), 1.);\n    }\n    else\n    {\n        if (iMouse.z > 0.)\n        {\n            fragColor = vec4(vec3(iTime), 1.);\n        }\n        else\n        {\n            fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        }\n    }\n    \n}","name":"Buffer D","description":"","type":"buffer"}]}