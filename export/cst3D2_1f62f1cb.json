{"ver":"0.1","info":{"id":"cst3D2","date":"1677858884","viewed":50,"name":"Glitchy ball","username":"benec","description":"A glitchy pendulum animation","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["glitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// intentionally Jumpy animation \n// rendering from the wrong frame onward\n// using smoothstep to perturb a linear [0,1] range\n// and using that to drive a sinusoidal frame count\n\nconst float PI = 3.1415926535897932384626433832795;\n\nbool inSphere(vec2 coord) {\n  return 1.0 >= coord.x*coord.x + coord.y*coord.y;\n}\n\nvec3 sphereColor(vec2 coord) {\n    const vec3 lightDir = normalize(vec3(1.0));\n    float z = sqrt((- pow(coord.y, 2.0) ) - pow(coord.x, 2.0)  + 1.0);\n    vec3 surfacePoint = vec3(coord, z);\n    float intensity = dot(surfacePoint, lightDir)*0.55;\n    vec3 ambient = vec3(0.9, 0.3, 0.3);\n    return vec3(intensity)+ambient;\n}\n\nfloat getFrame() {\n    float lin01 = mod(iTime*0.6, 1.0);\n    const float jumpAmount = 0.08;\n    // according to maxima....\n    // (%i1) solve(1 = (x-b)*a, [a]);\n    //                                          1\n    // (%o1)                             [a = -----]\n    //                                        x - b\n    // (%i2) %, x=1;\n    //                                          1\n    // (%o2)                             [a = -----]\n    //                                        1 - b\n    // (%i3) \n    const float jumpCorrection = 1.0 / (1.0 - jumpAmount);\n    float jumpOffset = smoothstep(0.42, 0.425, lin01)*jumpAmount;\n    float linJumpy = (lin01 - jumpOffset)*jumpCorrection;\n    float sinJumpy = sin(linJumpy*2.0*PI);\n    return sinJumpy*0.5+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // center\n    uv -= vec2(0.5);\n    uv *= vec2(2.0*(iResolution.x/iResolution.y),2.0);\n    \n    uv *= vec2(5.0);\n    \n    float animFrame = getFrame();\n\n    const float maxTau = PI/2.0;\n    \n    float tau = -maxTau+2.0*maxTau*animFrame;\n    \n    vec2 offset = vec2(sin(tau), cos(tau))*vec2(3.0);\n    uv += offset;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.8);\n\n    if (inSphere(uv)) {\n        col = sphereColor(uv);\n    }\n    \n    // gamma correct\n    col = pow(col, vec3(1.0/2.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}