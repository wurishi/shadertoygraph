{"ver":"0.1","info":{"id":"wljGzD","date":"1558731786","viewed":114,"name":"[0001] mirror spheres","username":"Meow8p","description":"[0001] mirror spheres","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sphere","mirror","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS (128)\n#define MAX_DIST (100.0)\n#define SURFACE_DIST (0.001)\n   \nint mat=0;\n   \nvec2 rotate(vec2 p, float a)\n{\n   float s=sin(a);\n   float c=cos(a);\n   mat2 r=mat2(c, -s, s, c);\n   return p*r;\n}\n\nfloat sphereDist(vec3 p, vec3 origin, float radius)\n{\n   return length(p-origin)-radius;\n}\n\nfloat planeDist(vec3 p, float position)\n{\n   return p.y-position;\n}\n   \nfloat sceneDistance(vec3 p)\n{\n   float s1=sphereDist(p, vec3(0.0, 0.5, 0.0), 0.2);\n   if(s1<SURFACE_DIST)\n   {\n      mat=1;\n   }\n   float p1=planeDist(p, 0.0);\n   if(p1<SURFACE_DIST)\n   {\n      mat=2;\n   }\n   p.xz=rotate(p.xz, iTime);\n   float s2=sphereDist(p, vec3(1.0, 0.5, 0.0), 0.2);\n   if(s2<SURFACE_DIST)\n   {\n      mat=3;\n   }\n   return min(p1, min(s1, s2));\n}\n\nvec3 normalAt(vec3 p)\n{\n   float dist=sceneDistance(p);\n   vec2 epsilon=vec2(0.01,0.0);\n   return normalize(vec3(dist-sceneDistance(p-epsilon.xyy), \n                         dist-sceneDistance(p-epsilon.yxy),\n                         dist-sceneDistance(p-epsilon.yyx)));\n}\n   \nfloat lightAt(vec3 p)\n{\n   vec3 lightPosition=vec3(0.0,2.0,0.0);\n   vec3 n=normalAt(p);\n   vec3 lightDirection=normalize(lightPosition-p);\n   \n   float diffuse=clamp(dot(n, lightDirection), 0.0, 1.0);\n   return diffuse;\n}\n\nvec3 pixelColor(vec2 uv)\n{\n   vec3 direction=normalize(vec3(uv,1.0));\n   vec3 color=vec3(0.0,0.0,0.0);\n   float distance=0.0;\n   vec3 camera=vec3(0.0,0.5,-0.5);\n   float sceneDist=0.0;\n   vec3 p;\n   int reflectCount=0;\n   \n   for(int i=0;i<MAX_STEPS;i++)\n   {\n      p=camera+distance*direction;\n      sceneDist=sceneDistance(p);\n      distance+=sceneDist;\n      if(distance>=MAX_DIST)\n      {\n         break;\n      }\n      if(sceneDist<=SURFACE_DIST)\n      {\n         if(reflectCount<=1)\n         {\n            color=vec3(lightAt(p));         \n            vec3 n=normalAt(p);\n            distance=0.0;\n            direction=reflect(direction,n);\n            camera=p+direction/2.0;\n            reflectCount++;\n         }\n         else\n         {\n            break;\n         }\n      }\n   }\n   \n   if(sceneDist<=SURFACE_DIST)\n   {\n      color=vec3(lightAt(p));\n   }\n   \n   if(mat==1)\n   {\n      color*=vec3(1.0,0.0,0.0);\n   }\n   else if(mat==2)\n   {\n      color*=vec3(0.0,1.0,0.0);\n   }\n   else if(mat==3)\n   {\n      color*=vec3(0.0,0.0,1.0);\n   }\n   \n   return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    fragColor = vec4(pixelColor(uv),1.0);\n}","name":"Image","description":"","type":"image"}]}