{"ver":"0.1","info":{"id":"M3BXRm","date":"1711324483","viewed":174,"name":"Barely Alive","username":"3t13nn3","description":"Barely Alive Tribute with their logo head headbanging in a retro 80's world (Adapted to a BPM, setted at 150 here).\n Weeble Wobble  Weeble Wobble  Weeble Wobble  Weeble Wobble  Weeble Wobble  Weeble Wobble ","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["reflection","dubstep","synthwave","barelyalive","raymarchingnheadbang"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"lsGGzR","filepath":"https://soundcloud.com/disciple/letitspin?in=barelyalive","previewfilepath":"https://soundcloud.com/disciple/letitspin?in=barelyalive","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DEPTH_LIMIT 50.0\n#define TAU 6.283185\n#define PI 3.141592\n#define BPM 150.0\n#define BPM_FACTOR BPM / 60.0\n#define T iTime\n#define SPEED 20.\n#define TIME_FACTOR T * PI * BPM_FACTOR\n#define RAY_ITERATION 200\n\n\nconst float factors[] = float[](1.0, 2.0, 0.5);\n\nstruct Material {\n    float depth;\n    vec3 color;\n    float id;\n};\n\nvec3 moveCharacter(float factor) {\n    float bpm = BPM;\n    float speed = 1.0 / bpm * 60.0;\n    float xOffset = sin(T * speed * PI);\n    float depthOffset =  -60.0 / bpm * 4.0 + cos(T * speed * PI * 4.) * 60.0 / bpm * 4.0;\n    return vec3(xOffset, 0.0, depthOffset);\n}\n\nfloat randomFloat() {\n    float segmentDurationFactor0 = BPM_FACTOR * 16.0;\n    float segmentDurationFactor1 = BPM_FACTOR * 32.0;\n    float segmentDurationFactor2 = BPM_FACTOR * 8.0;\n\n    float elapsedTime = mod(T, segmentDurationFactor0 + segmentDurationFactor1 + segmentDurationFactor2);\n\n    float factor;\n    if (elapsedTime < segmentDurationFactor0) {\n        factor = factors[0];\n    } else if (elapsedTime < segmentDurationFactor0 + segmentDurationFactor1) {\n        factor = factors[1];\n    } else {\n        factor = factors[2];\n    }\n\n    return factor;\n}\n\nvec3 rotatePoint(vec3 p, vec3 axis, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n    float oneMinusCosA = 1.0 - cosA;\n    \n    mat3 rotationMatrix = mat3(\n        cosA + axis.x*axis.x*oneMinusCosA,     axis.x*axis.y*oneMinusCosA - axis.z*sinA, axis.x*axis.z*oneMinusCosA + axis.y*sinA,\n        axis.y*axis.x*oneMinusCosA + axis.z*sinA, cosA + axis.y*axis.y*oneMinusCosA,     axis.y*axis.z*oneMinusCosA - axis.x*sinA,\n        axis.z*axis.x*oneMinusCosA - axis.y*sinA, axis.z*axis.y*oneMinusCosA + axis.x*sinA, cosA + axis.z*axis.z*oneMinusCosA\n    );\n\n    return rotationMatrix * p;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nMaterial opU(in Material d1, in Material d2) {\n\tif (d2.depth < d1.depth) {\n        return d2;\n    } else {\n        return d1;\n    }\n}\n\nMaterial sMin(Material a, Material b, float k) {\n    float h = clamp(0.5 + 0.5 * (b.depth - a.depth) / k, 0.0, 1.0);\n    Material result;\n    result.depth = mix(b.depth, a.depth, h) - k * h * (1.0 - h);\n    result.color = mix(b.color, a.color, h);\n    return result;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRectangle(vec2 p, vec2 size) {\n    vec2 d = abs(p) - size;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nMaterial sdBarelyAlive(vec3 pos, vec3 boxCenter, vec3 boxSize, float cornerRadius, float borderWidth, vec3 edgeColor) {\n    float factor = randomFloat();\n    pos += moveCharacter(factor);\n\n    vec3 directionHeadbang = vec3(1., 0.0, 0.0);\n\n    float headbangAngle = sin(TIME_FACTOR * factor) * PI / 4.0 / max(1., factor);\n    float nonLinearFactor = 1.0 - abs(sin(TIME_FACTOR) * PI / 8.0);\n    headbangAngle *= nonLinearFactor * 2.0; // amplitude\n\n    vec3 offset = vec3(cos(T) * 1.8, 0.0, T * factor * SPEED);\n    pos = rotatePoint(pos - boxCenter - offset, directionHeadbang, headbangAngle) + boxCenter;\n\n    directionHeadbang = vec3(0., 0.0, 1.0);\n    headbangAngle = cos(TIME_FACTOR / 4.) * PI / 8.0;\n\n    pos = rotatePoint(pos - boxCenter, directionHeadbang, headbangAngle) + boxCenter;\n\n    float d = sdRoundBox(pos - boxCenter, boxSize, cornerRadius);\n\n    vec3 boxColor = vec3(0.025);\n    float currId = 1.5;\n\n    bool boxRight = abs(pos.x - boxCenter.x) > boxSize.x - borderWidth;\n    bool boxTop = abs(pos.y - boxCenter.y) > boxSize.y - borderWidth;\n    bool boxFront = abs(pos.z - boxCenter.z) > boxSize.z - borderWidth;\n\n    if ((boxRight && boxTop) || (boxTop && abs(pos.z - boxCenter.z) > boxSize.z - borderWidth) ||\n        (boxFront && abs(pos.x - boxCenter.x) > boxSize.x - borderWidth)) {\n        boxColor = edgeColor;\n        currId = 1.0;\n    }\n\n    if (pos.z < boxCenter.z) {\n        float distToCircle1 = distance(pos.xy, vec2(-0.6, 1.)); \n        float distToCircle2 = distance(pos.xy, vec2(0.6, 1.)); \n        float circleRadius = 0.1;\n\n        if (abs(distToCircle1 - circleRadius) < borderWidth ||\n            abs(distToCircle2 - circleRadius) < borderWidth) {\n            boxColor = vec3(1.0, 0.208, 0.067) + vec3(sin(T + pos.y * PI), cos(T) / 3., tan(T) / 4.);\n            currId = 0.0;\n        }\n    }\n\n    float tooth = (boxSize.x - 1.93 * borderWidth) / 6.0;\n    float startY = boxCenter.y - 0.8 * boxSize.y + 0.1;\n    for (float i = -6. + 2.; i < 6.; i += 4.) {\n        if (pos.z < boxCenter.z &&\n            abs(pos.x - tooth * i) < tooth &&\n            abs(pos.y - startY) < 0.125) {\n            boxColor = edgeColor;\n            currId = 1.0;\n        }\n    }\n\n    float availableWidthEyebrow = (boxSize.x - 2.0 * borderWidth) / 2.35;\n    float startXEyebrow = boxCenter.x - 0.5 * availableWidthEyebrow; \n    float startYEyebrow = boxCenter.y + 0.075 * boxSize.y;         \n\n    for (float i = -1.; i < 2.; i += 2.) {\n        vec3 rotatedPos = rotatePoint(pos - boxCenter, vec3(0.0, 0.0, 1.0), i * PI / 6.0) + boxCenter;\n        if (rotatedPos.z < boxCenter.z &&\n            abs(rotatedPos.x - availableWidthEyebrow * i * 1.5) < availableWidthEyebrow &&\n            abs(rotatedPos.y - startYEyebrow) < 0.09) {\n            boxColor = edgeColor;\n            currId = 1.0;\n        }\n    }\n\n    return Material(d, boxColor, currId);\n}\n\n\nfloat pyramidDistance(vec3 p, float size) {\n    vec3 q = abs(p) - vec3(size); \n    return max(q.y - max(q.x, q.z), -q.y);\n}\n\nMaterial map(in vec3 pos) {\n    vec3 np = pos;\n   \n    float d = pos.y +0.75;\n    vec3 groundColor = vec3(0.047,0.012,0.039);\n\n    float gridSpacing = 1.0;\n    float gridWidth = 0.075;\n    \n    float gridX = mod(pos.x + gridWidth / 2., gridSpacing);\n    float gridZ = mod(pos.z + gridWidth / 2., gridSpacing);\n\n\n    if (gridX < gridWidth) {\n        groundColor = mix(groundColor, vec3(0.75 + fract(sin(pos.x + T + sin(pos.z / 10.))) * 1.5, 0.25, 0.9), 0.75); // + fract(cos(pos.z + iTime + (pos.z / 10.)))\n        groundColor *= 1.5;\n    } else if (gridZ < gridWidth) {\n        groundColor = mix(groundColor, vec3(0.75 + sin(pos.x + T / PI), 0.50, 0.75 + abs(sin(pos.x + T))), 0.75);\n        groundColor *= 1.2;\n    } else if (gridX > gridWidth || gridZ > gridWidth) {\n        vec3 id = floor(pos);\n        groundColor += 0.03*cos((id.z*id.x*14.31+id.z*32.341+id.x*1.)) * ( 1. - abs(cos(T / 10.)));\n    }\n    \n    Material ground = Material(d, groundColor, 0.0);\n    \n    float factor = randomFloat();\n\n    vec3 boxCenter = vec3(0.0, 1.0, 4.0);\n    vec3 boxSize = vec3(1.5, 1.05, 1.05);\n    float cornerRadius = 0.1;\n    vec3 boxColor = vec3(0.025);\n    vec3 edgeColor = vec3(0.122,0.851,0.016);\n    float borderWidth = 0.2;\n    float amplitude = 2.0;\n\n    vec3 directionHeadbang = vec3(1., 0.0, 0.0);\n\n    Material barelyAlive = sdBarelyAlive(pos, boxCenter, boxSize, cornerRadius, borderWidth, edgeColor);\n\n    Material res = opU(ground, barelyAlive);\n\n    pos = np - vec3(8.0, 3.25, 0.0);\n    \n    if (np.y > 3.5) {\n        return res;\n    }\n\n    vec3 pOffset = vec3(1., 0.0, 0.5);\n    float angle = radians(45.);\n    vec3 rotatedPos = rotatePoint(mod(pos, 16.)/8. - pOffset, vec3(0.0, 1.0, 0.0), angle);\n    d = pyramidDistance(rotatedPos, 1.0);\n    Material s = Material(d, groundColor, 0.);\n    res = opU(res, s);\n    return res;\n}\n\nMaterial rayCast(in vec3 ro, in vec3 rd, float dist) {\n    float t = 0.0;\n    Material mat;\n    vec3 prevCol = mat.color;\n    for(int i = 0; i < RAY_ITERATION; ++i) {\n        vec3 pos = ro + rd * t;\n        mat = map(pos);\n        \n        if(abs(mat.depth) < 0.001 || mat.depth > dist) break;\n        \n        t+= mat.depth * 0.8;\n        \n    }\n    \n    if (t < dist) {\n        return Material(t, mat.color, mat.id);\n    }\n    \n    return Material(dist, vec3(0.0), mat.id);\n}\n\nvec3 getNormal(in vec3 pos, float t) {\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(pos+e.xyy).depth - map(pos-e.xyy).depth,\n                          map(pos+e.yxy).depth - map(pos-e.yxy).depth,\n                          map(pos+e.yyx).depth - map(pos-e.yyx).depth));\n}\n\n\n////////// https://www.shadertoy.com/view/cdjGWy\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro;\n\n    float shade = 1.;\n    float t = 0.; \n    float end = max(length(rd), .0001);\n\n    rd /= end;\n\n\n    for (int i = min(iFrame, 0); i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t).depth;\n        shade = min(shade, k*d/t);\n\n        t += clamp(d, .005, .15); \n\n        if (d<0. || t>end) break; \n    }\n\n    return max(shade, 0.); \n}\n\nfloat calcAO(in vec3 p, in vec3 n){\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr).depth;\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n//////////\n\nvec3 background(vec3 rd, float t, inout vec3 col, float rf) {\n    rd.xy += vec2(cos(T) / 25., 0.0);\n    float sunRadius = 0.2;\n    float distToSun = length(\n        vec2(\n            rd.x,\n            (rd.y - 0.10)\n        )\n    ) - 0.012;\n\n    // Sunrise effect\n    if(rd.y < 0.2){\n        distToSun = mix(\n                        distToSun,\n                        max(distToSun, -sin(3.*exp(-rd.y) * (18.0 + T))),\n                        (rd.y*t/4. + 0.10 + sin(rd.x * 2. + (T + 5.) / PI) / 2.)\n                       );\n    }\n\n    distToSun*=smoothstep(0.00,abs(sin(T/PI/PI)) / PI, distToSun);\n\n    // CLOUD\n    float cloudRadius = 0.04;\n    float gridSpacing = 0.775;\n\n    vec2 gridPosition = vec2(\n        mod(rd.x - (T / 26.0), gridSpacing) - gridSpacing / 2.,\n        mod(rd.y + T / 199.7, gridSpacing) - gridSpacing / 2.\n    );\n\n\n\n    float d = length(gridPosition);\n    d = min(length(gridPosition), length(gridPosition + 0.05 + cos(T) / 220.2));\n    d = min(d, length(vec2(gridPosition.x - 0.012 + cos(T) / 220.2, gridPosition.y + 0.05)));\n    d = min(d, length(vec2(gridPosition.x + 0.032 + cos(T) / 120.2, gridPosition.y - 0.015 + sin(T) / 142.3)));\n    d = min(d, length(vec2(gridPosition.x + 0.07 + sin(T) / 100.3, gridPosition.y - 0.005 + sin(T) / 90.3)));\n    \n    float freq = texture(iChannel0, vec2(0.02, 0.15)).x;\n    d -=  freq / 50.;\n\n    float contourWidth = 0.01;\n\n    vec2 p = rd.xy * 1.0;\n    p.y += abs(sin(T/ PI)) / 75.;\n    float rect = sdRectangle(p.xy, vec2(0.05, 0.15));\n\n    rect = min(rect, sdRectangle(vec2(p.x + 0.12, p.y), vec2(0.05, 0.1)));\n\n    rect = min(rect, sdRectangle(vec2(p.x + 0.24, p.y), vec2(0.05, 0.05)));\n    rect = min(rect, sdRectangle(vec2(p.x + 0.24, p.y), vec2(0.025, 0.125)));\n    rect = min(rect, sdRectangle(vec2(p.x + 0.24, p.y), vec2(0.0125, 0.2)));\n\n    rect = min(rect, sdRectangle(vec2(p.x - 0.17, p.y), vec2(0.1, 0.075)));\n    rect = min(rect, sdRectangle(vec2(p.x - 0.14, p.y), vec2(0.035, 0.175)));\n    rect = min(rect, sdRectangle(vec2(p.x - 0.20, p.y), vec2(0.035, 0.125)));\n\n    rect = min(rect, sdRectangle(vec2(p.x - 0.305, p.y), vec2(0.0175, 0.045)));\n    rect = min(rect, sdRectangle(vec2(p.x + 0.305, p.y), vec2(0.0175, 0.075)));\n\n    if (rect < -0.001) {\n        vec3 bat = vec3(0.227,0.055,0.239) - rd.y * 3.;\n        col = mix( col, bat, 1.-exp( -0.0009*t*t*t ));\n    } else if (distToSun < sunRadius) {\n        col += vec3(0.7, 0.1, 0.1);\n        vec3 sun = vec3(0.847,0.643,0.263) - rd.y;\n        sun = mix(col, sun, exp(-10.0*rd.y));\n\n        col = mix( col, sun, 1.0-exp( -0.00005*t*t*t ));\n    } else if ((d < cloudRadius && d < distToSun)) {\n        col = mix( col, vec3(0.980,0.941,0.863) - rd.y, 1.0-exp( -0.000008*t*t*t ));\n    } else if (d - cloudRadius < contourWidth) {\n        vec3 sun = vec3(0.847,0.643,0.263) - rd.y * 3.;\n        col = mix( col +  freq / 3., 1.-sun, 1.0-exp( -0.000001*t*t*t ));\n    }\n\n    //GLOW \n    if (rect < 1.0 && rect > -0.001) {\n        vec3 bat = vec3(1.000,0.106,0.035) - rd.y * 0.7;\n        col = mix( col, bat* sin(TIME_FACTOR*rf) * PI / 4.0 / rf, 1.- smoothstep(-0.15 + sin(T / PI)/ 20.5 , 0.08, rect));\n    }\n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in Material tm, in vec3 lp) {\nfloat rf = randomFloat();\n    vec3 fg = vec3(0.875,0.235 + clamp(sin(TIME_FACTOR*rf) * PI / 4.0 / rf, 0., 1.) / 1.5,0.537);\n    vec3 col = vec3(0.408,0.169,0.624) - 0.7 * rd.y;\n    \n    //col = mix(col, fg* sin(TIME_FACTOR*rf) * PI / 4.0 / rf, exp(-10.0*rd.y)* sin(TIME_FACTOR*rf) * PI / 4.0 / rf);\n    col = mix(col, fg, exp(-10.0*rd.y));\n    \n    \n    float t = tm.depth;\n    if(t < DEPTH_LIMIT) {\n\t    vec3 sp = ro + rd*t;\n        vec3 sn = getNormal(sp, t);\n\n\t    vec3 ld = lp - sp;\n            \n        float lDist = max(length(ld), .001);\n        ld /= lDist;\n\n        float atten = 1./(1. + lDist*.05);\n\n        float sh = softShadow(sp, lp, sn, 16.);\n        float ao = calcAO(sp, sn); \n        \n        float diff = max(dot(sn, ld), 0.0);\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.);\n        \n        col = tm.color;\n        if(tm.id == 1.5) {\n            vec3 reflectedRay = normalize(reflect(rd, sn));\n            vec3 reflectedColor = rayCast(sp + reflectedRay * .001, reflectedRay, DEPTH_LIMIT / 2.).color;\n            col = tm.color + reflectedColor * 0.4;\n        } else if(tm.id == 1.) {\n            vec3 reflectedRay = normalize(reflect(rd, sn));\n            vec3 reflectedColor = rayCast(sp + reflectedRay * .001, reflectedRay, DEPTH_LIMIT / 2.).color;\n            col = tm.color + reflectedColor * 0.2;\n        }\n        \n        col = col*(diff*sh + .3 + vec3(1, .97, .92)*spec*2.0*sh);\n        \n        col *= ao*atten;\n        \n        \n        col = mix( col, vec3(0.5,0.7,0.9), 1.0-exp( -0.00001*t*t*t ));// smoothstep(0., .99, t/DEPTH_LIMIT)\n    } else {\n        col = background(rd, t, col, rf);\n    }\n    return col;\n}\n\nvec3 calculateRayDirection(vec3 ro, vec3 lookAtPos, float FOV, vec2 uv) {\n    vec3 fwd = normalize(lookAtPos - ro);\n    vec3 rgt = normalize(cross(vec3(0, 1, 0), fwd)); \n    vec3 up = cross(fwd, rgt);\n    vec3 rd = normalize(uv.x * rgt + uv.y * up + fwd / FOV);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    float currSpeed = T * randomFloat() * SPEED;\n    vec3 speedOffset = vec3(cos(T) * 2., 0.0, currSpeed);\n    \n    vec3 ro = vec3(0.0, 1.0, -1.0) + speedOffset;\n    vec3 lookAtPos = vec3(0.0, 1.0 - 0.06, 0.0) + speedOffset;\n    float FOV = 1.0;\n    vec3 rd = calculateRayDirection(ro, lookAtPos, FOV, uv);\n    \n    vec3 lp = vec3(2.0, 2.0, 0.0 + sin(T/ 2.) * 6.) + speedOffset;\n    \n    Material tm = rayCast(ro, rd, DEPTH_LIMIT);\n    \n    vec3 col = render(ro, rd, tm, lp);\n    \n    // sqrt gamma correction\n    fragColor = vec4(pow(col, vec3(0.6545)), 1.0);\n}","name":"Image","description":"","type":"image"}]}