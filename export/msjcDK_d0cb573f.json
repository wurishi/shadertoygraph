{"ver":"0.1","info":{"id":"msjcDK","date":"1688215010","viewed":131,"name":"Visibility buffer rasterization","username":"chronos","description":"Visibility buffer edge function rasterization. Kind of. The visibility buffer is the combination of just the primitive ID and z buffer at each pixel.\nHere it's not really proper rasterization since it is a pixel shader, so all compotation is redone per px","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["rasterizer","edge","function","rasterization","buffer","visibility"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Assumes camera is positioned at 0,0,0, looking down z axis\n// There's a lot of redundant computation here that could be optimized, but I left it like this for clarity.\n// @return reciprocal z = 1./z    Note that this number will be positive in front of camera, e.g the Z axis is not world z, but camera forward dir!\nfloat render_tri(ivec3 prim, vec3 ray_dir)\n{\n    vec3 v0 = verts[prim.x];\n    vec3 v1 = verts[prim.y];\n    vec3 v2 = verts[prim.z];\n    \n    vec3 v0xv1 = cross(v0, v1);\n    vec3 v1xv2 = cross(v1, v2);\n    vec3 v2xv0 = cross(v2, v0);\n    \n    vec3 normal = normalize(cross(v1 - v0, v2 - v0));\n    \n    float step_size_along_normal = dot(normal, ray_dir); // should be negative, otherwise the ray dir is pointing away from the triangle!\n    \n    if(step_size_along_normal >= 0.) return 0.;\n    \n    float step_size_along_z = ray_dir.z; // also negative, so this cancels the negative step size from the step size along the normal when multiplied\n    \n    float step_along_z_per_step_along_normal = step_size_along_z / step_size_along_normal;\n    \n    float triangle_distance = dot(vec3(0) - v0, normal); // to camera at (0,0,0), should be positive\n    \n    // Some interpretations for other quantities, could have just made rcp_z = 1./z , but I simplified it instead.\n    // float number_of_steps = triangle_distance / step_size_along_normal;\n    // float z = step_size_along_z * number_of_steps;\n    // float fraction_of_distance_covered_by_step = step_size_along_normal / triangle_distance;\n    \n    float rcp_z = step_size_along_normal / (step_size_along_z * triangle_distance);\n    \n    float edge01 = -dot(ray_dir, v0xv1);\n    float edge12 = -dot(ray_dir, v1xv2);\n    float edge20 = -dot(ray_dir, v2xv0);\n    \n    float mask = step(0., edge01)  * step(0., edge12) * step(0., edge20);\n    \n    return rcp_z * mask; // if outside the triangle mask, given by the edge functions, then set rcp_z to be zero (infinitely far away)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord.xy - iResolution.xy)/iResolution.y;\n    \n    vec3 ray_dir = normalize(vec3(uv, -1.)); // camera looks down negative z\n\n    float rcp_z = 0.;\n    int prim_id = 0;\n    for(int i = 0; i < num_prims; i++)\n    {        \n        float candidate_rcp_z = render_tri(prims[i], ray_dir);\n        \n        if(candidate_rcp_z > rcp_z) // When using reciprocal z, i.e 1./z, larger values are nearer.\n        {\n            rcp_z = candidate_rcp_z;\n            prim_id = i;\n        }\n    }\n    \n    // The visibility buffer is now essentially the pair of values (rcp_z, prim_id) per pixel.\n    // We'll visualize it by looking up the \"material\" by prim_id and combining it with the z value.\n    \n    vec3 color = vec3(rcp_z) * rgb_palette[prim_id];\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec3 verts[12] = vec3[12]\n\t(\n\t\tvec3(-1., -1., -1.), // 0\n\t\tvec3( 1., -1., -1.), // 1\n\t\tvec3( 1.,  1., -1.), // 2\n\t\tvec3(-1.,  1., -1.), // 3\n\t\tvec3(-1., -1., -2.), // 4\n\t\tvec3( 1., -1., -2.), // 5\n\t\tvec3( 1.,  1., -2.), // 6\n\t\tvec3(-1.,  1., -2.), // 7\n\t\tvec3(-2., -2., -1.), // 8\n\t\tvec3( 2., -2., -1.), // 9\n\t\tvec3( 2.,  2., -1.), // 10\n\t\tvec3(-2.,  2., -1.)  // 11\n\t);\n    \nconst int num_prims = 18;\nconst ivec3 prims[num_prims] = ivec3[num_prims]\n(\n    ivec3(0, 1, 5  ),\n    ivec3(0, 5, 4  ),\n    ivec3(1, 2, 5  ),\n    ivec3(2, 6, 5  ),\n    ivec3(2, 7, 6  ),\n    ivec3(2, 3, 7  ),\n    ivec3(4, 5, 6  ),\n    ivec3(4, 6, 7  ),\n    ivec3(0, 4, 3  ),\n    ivec3(3, 4, 7  ),\n    ivec3(8, 3, 11 ),\n    ivec3(8, 0, 3  ),\n    ivec3(8, 1, 0  ),\n    ivec3(8, 9, 1  ),\n    ivec3(1, 9, 2  ),\n    ivec3(2, 9, 10 ),\n    ivec3(3, 2, 11 ),\n    ivec3(2, 10, 11)\n);\n\nvec3 rgb_palette[num_prims] = vec3[num_prims]\n\t(\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(0., 1., 0.),\n\t\tvec3(0., 1., 0.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 1., 1.),\n\t\tvec3(1., 0., 0.),\n\t\tvec3(1., 0., 0.),\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5,\n\t\tvec3(1., 1., 1.)*0.5\n\n\t);","name":"Common","description":"","type":"common"}]}