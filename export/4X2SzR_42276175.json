{"ver":"0.1","info":{"id":"4X2SzR","date":"1710202977","viewed":142,"name":"WebGL1 hash functions","username":"munrocket","description":"New WebGL1 noise without sine.\n\nRef: Hash Functions for GPU Rendering https://www.shadertoy.com/view/XlGcRh","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","hash","floats"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License. © 2024 munrocket\nvec3 fakepcg3d(vec3 v) {\n    v = fract(v/128.)*128. - vec3(64.340622, 72.465622, 66.3125);\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v = fract(v/128.)*128. - vec3(66.3125, 64.340622, 72.465622);\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    return fract(v/128.)*128. - 64.;\n}\n\n// MIT License. © 2024 munrocket\nvec4 fakepcg4d(vec4 v) {\n    v = fract(v/128.)*128. - vec4(64.340622, 72.465622, 66.3125, 69.625);\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    v = fract(v/128.)*128. - vec4(69.625, 64.340622, 72.465622, 66.3125);\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n    return fract(v/128.)*128. - 64.;\n}\n\n// MIT License. © 2024 munrocket\nvec3 texBased3d(vec3 pos) {\n    vec2 uv = fract(pos.xz) + pos.yz/1271.;\n    return texture(iChannel0, uv).xyz;\n}\nvec4 texBased4d(vec4 pos) {\n    vec2 uv = fract(pos.xz) + pos.yw/1271.;\n    return texture(iChannel0, uv);\n}\n\n// Hash without Sine\n// https://www.shadertoy.com/view/4djSRW\nvec3 hashwithoutsine33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hashwithoutsine44(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// UE4's PseudoRandom function\n// https://github.com/EpicGames/UnrealEngine/blob/release/Engine/Shaders/Private/Random.ush\nfloat pseudo(vec2 v) {\n    v = fract(v/128.)*128. + vec2(-64.340622, -72.465622);\n    return fract(dot(v.xyx * v.xyy, vec3(20.390625, 60.703125, 2.4281209)));\n}\n\n// Interleaved Gradient Noise\n//  - Jimenez, Next Generation Post Processing in Call of Duty: Advanced Warfare\n//    Advances in Real-time Rendering, SIGGRAPH 2014\nfloat ign(vec2 v) {\n    vec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n    return fract(magic.z * fract(dot(v, magic.xy)));\n}\n\n// Ian McEwan, Ashima Arts.\n// https://github.com/stegu/webgl-noise/blob/master/src/noise4D.glsl\nvec3 mod289(vec3 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec3 perm(vec3 x){return mod289(((x * 34.0) + 1.0) * x);}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\n// common GLSL hash\n//  - Rey, On generating random numbers, with help of y= [(a+x)sin(bx)] mod 1,\n//    22nd European Meeting of Statisticians and the 7th Vilnius Conference on\n//    Probability Theory and Mathematical Statistics, August 1998\nfloat trig(vec2 p) {\n    return fract(43757.5453*sin(dot(p, vec2(12.9898,78.233))));\n}\n// same idea but for 33 https://www.shadertoy.com/view/4djSRW\nvec3 trig33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(p)*43758.5453123);\n}\n\nuvec3 hash(vec2 s) {\t\n    /*\n        Uncomment the hash you want to visualize.\n\n\t\tNote that most of these examples the hash is only given 2 inputs unless the hash requires more.\n\t\tBut Common includes 1 through 4 input variations of the hash if they exist.\n\n\t\tYou should play around with different seeds/different number of inputs.\n\t*/    \n    \n    uvec4 u = uvec4(s, uint(s.x) ^ uint(s.y), uint(s.x) + uint(s.y)); // Play with different values for 3rd and 4th params. Some hashes are okay with constants, most aren't.\n    vec4 p = vec4(u);\n    \n    return uvec3(fakepcg3d(p.xyz) * float(0xffffffffu));\n    //return uvec3(fakepcg4d(p).xyz * float(0xffffffffu));\n    //return uvec3(texBased3d(p.xyz) * float(0xffffffffu));\n    //return uvec3(texBased4d(p).xyz * float(0xffffffffu));\n    //return uvec3(hashwithoutsine33(p.xyz) * float(0xffffffffu));\n    //return uvec3(hashwithoutsine44(p).xyz * float(0xffffffffu));\n    //return uvec3(pseudo(s) * float(0xffffffffu));\n    //return uvec3(ign(s) * float(0xffffffffu));\n    //return uvec3(perm(p).xyz * float(0xffffffffu));\n    //return uvec3(perm(p.xyz) * float(0xffffffffu));\n    //return uvec3(trig(s) * float(0xffffffffu));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // WebGL2 noise visualizer https://www.shadertoy.com/view/lt2yDm\n    vec2 uv = fragCoord/iResolution.xy;\n    uint bit = uint(8.0 * uv.x) + 8u * uint(4.0 * uv.y);\n    vec2 seed = mod(fragCoord, vec2(iResolution.x/8.0, iResolution.y/4.0));\n    seed += 100.0 * iTime;\n\n    uvec3 hash = hash(seed);\n    fragColor = vec4((hash >> bit) & 1u, 1.0);\n    fragColor *= step( 10.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0));\n    fragColor *= step( 10.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n}","name":"Image","description":"","type":"image"}]}