{"ver":"0.1","info":{"id":"cdGfWD","date":"1698213250","viewed":78,"name":"When raymarching goes bad","username":"seven_dc","description":"This happened me while playing around. hope you can enjoy bad raymatching artifacts.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarchnormals"],"hasliked":0,"parentid":"3lKBRV","parentname":"Basic raymarcher example.normals"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 150\n#define MAX_DIST 10.\n#define SURF_DIST .01\n\n\nfloat GetDistance(vec3 point) {\n\tvec4 sphere = vec4(cos(iTime), sin(iTime)+1., sin(iTime)+5., 1);\n  \n    float sphereDist = length(point-sphere.xyz)-sphere.w;\n    \n    float texture = point.y;\n    for(float s = 2.; s<20.; s/=.6) {\n        texture += abs(dot(sin(point.xz*s*.6)/s, iResolution.xy/iResolution.xy));\n    }\n    float planeDist = texture+sin(point.x*sin(iTime));\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy),\n      GetDistance(point-e.yxy),\n      GetDistance(point-e.yyx));\n  \n  return normalize(normal);\n}\n\nfloat RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    \n    for(int i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return distance;\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  float dif = clamp(dot(normal, direction), 0., 1.);\n  float d = RayMarch(point+normal*.1, direction);\n  if ( d < length(lightPos-point)) dif *= .5;\n  \n  return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 1, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n\n    float d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightPos = vec3(1.+sin(iTime), 3., 3.+sin(iTime));\n    \n    if (d < 13.) {\n        vec3 p = rayOrgin + rayDirection * d;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        col = vec3(light*vec3(.9,.9,1.));\n    }\n    col.b += d/80.;\n    col.r += exp(d-15.);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}