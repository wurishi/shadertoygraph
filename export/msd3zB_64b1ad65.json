{"ver":"0.1","info":{"id":"msd3zB","date":"1677498791","viewed":238,"name":"Fork Seigaiha M reverland 684","username":"reverland","description":"https://www.shadertoy.com/view/WdtGWf\nhttps://www.shadertoy.com/view/4tlXWX\n","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["motion","hypnotic","pattern","japanese","scales","fabric"],"hasliked":0,"parentid":"WdtGWf","parentname":"Seigaiha Mandala"},"renderpass":[{"inputs":[{"id":"4lXGDj","filepath":"https://soundcloud.com/alvydasm/the-heart-of-reiki-1","previewfilepath":"https://soundcloud.com/alvydasm/the-heart-of-reiki-1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// Seigaiha Mandala by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// eyes: https://www.shadertoy.com/view/4tlXWX\n\n#define S(a,b,c) smoothstep(a,b,c)\n\nvec3 hash3( float n )\n{\n    return vec3(-0.5,-0.5,0.0)+fract(sin(vec3(n,n+1.0,n+2.0))*vec3(13.5453123,31.1459123,37.3490423));\n}\n\nvec3 noise( in float x )\n{\n    float p = floor(x);\n    float f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    return mix( hash3(p+0.0), hash3(p+1.0),f);\n}\n\nvec4 rgb(in int r, in int g, in int b)\n{\n    float rf=float(r);\n    float gf=float(g);\n    float bf=float(b);\n    \n    return vec4(rf/255.0,gf/255.0,bf/255.0,0.0);\n}\nvoid eye(inout vec4 c,in vec2 coord,in vec2 pos, in float size,in vec2 mouse,in vec4 col1, in vec4 col2)\n{\n    vec4 e=c;\n    \n    //vec2 iris=pos+(mouse-pos)/20.0;\n    vec2 iris=pos+noise(pos.x*37.0+pos.y*123.0+float(iTime/3.0)).xy/2.0*size;\n    \n    vec2 almond=coord;\n    \n    float opening=0.5+sin(iTime)/2.;\n    \n    almond=vec2(almond.x,almond.y-sign(pos.y-almond.y)*size*0.9);\n    \n    \n    \n\n    \n    \n    coord-=(vec2(0.5,0.5)-coord)*0.6*size;\n    \n    \n    \n    \n    \n    if (length(almond-pos)<size*1.5)\n    {\n        if (length(pos-coord)<size)\n        {\n            if (length(coord-iris)>0.5*size)\n                e=rgb(255,251,237);\n            else\n            {\n                if (length(coord-iris)>0.25*size)\n                {\n                    e=mix(col1,col2,(coord.y-iris.y)/size);\n                    if (length(coord-iris)>0.3*size\n                        && length(coord-iris)<0.45*size)\n                    {\n                        vec2 rad=coord-iris;\n                        if (mod(floor(atan(rad.y,rad.x)*8.0),2.0)==0.0)\n                        e=e*0.9;\n                    }\n                    \n                }\n                else\n                    e=rgb(44,68,71);\n            }\n        \n        if (length(coord-(pos+vec2(0.5,0.2)*size))<0.1*size)\n            e=vec4(1.0);\n    \t}\n        else\n        {\n            e=rgb(133,91,75);\n        }\n        \n        \n        if (length(almond-pos)>size*1.4 && almond.y>=pos.y)\n        {\n            e=e*0.9;\n        }\n        \n    }\n    \n    \n\n    \n    c=e;\n}\n\n// blends a pre-multiplied src onto a dst color (without alpha)\nvec3 premulMix(vec4 src, vec3 dst)\n{\n    return dst.rgb * (1.0 - src.a) + src.rgb;\n}\n\n// blends a pre-multiplied src onto a dst color (with alpha)\nvec4 premulMix(vec4 src, vec4 dst)\n{\n    vec4 res;\n    res.rgb = premulMix(src, dst.rgb);\n    res.a = 1.0 - (1.0 - src.a) * (1.0 - dst.a);\n    return res;\n}\n\n// compute the round scale pattern and its mask\n// output rgb is premultiplied by alpha\nvec4 roundPattern(vec2 uv)\n{\n    float dist = length(uv);\n    \n    // Resolution dependant Anti-Aliasing for a prettier thumbnail\n    // Thanks Fabrice Neyret & dracusa for pointing this out.\n    float aa = 8. / iResolution.x;\n\n    // concentric circles are made by thresholding a triangle wave function\n    float triangle = abs(fract(dist * 12.0 + 0.3) - 0.5);\n    float circles = S(0.25 - aa * 10.0, 0.25 + aa * 10.0, triangle);\n\n    // a light gradient is applied to the rings\n    float grad = dist * 2.0;\n    vec3 col = mix(vec3(0.0, 0.5, 0.6),  vec3(0.0, 0.2, 0.5), grad * grad);\n    col = mix(col, vec3(1.0), circles);\n        \n        \n    vec2 mouse=iMouse.xy / iResolution.xy;\n    mouse=vec2(mouse.x,mouse.y*(iResolution.y/iResolution.x));\n\n    vec4 c=vec4(mouse.x,mouse.y,0.,0.);\n\n    eye(c,uv+0.5,vec2(0.5,0.5),1.0, mouse, rgb(145,210,218),rgb(84,133,139));\n    col = c.xyz;\n    \n    // border and center are red\n    //vec3 borderColor = vec3(0.7, 0.2, 0.2);\n    //col = mix(col, borderColor, S(0.44 - aa, 0.44 + aa, dist));\n    //col = mix(col, borderColor, S(0.05 + aa, 0.05 - aa, dist));\n    \n    // computes the mask with a soft shadow\n    float mask = S(0.5, 0.49, dist);\n    float blur = 0.3;\n    float shadow = S(0.5 + blur, 0.5 - blur, dist);\n   \n    return vec4(col * mask, clamp(mask + shadow * 0.55, 0.0, 1.0)); \n}\n\n\n//computes the scales on a ring of a given radius with a given number of scales\nvec4 ring(vec2 uv, float angle, float angleOffet, float centerDist, float numcircles, float circlesRad)\n{\n    // polar space is cut in quadrants (one per scale)\n    float quadId = floor(angle * numcircles + angleOffet);\n    \n    // computes the angle of the center of the quadrant\n    float quadAngle = (quadId + 0.5 - angleOffet) * (6.283 / numcircles);\n    \n    // computes the center point of the quadrant on the circle\n    vec2 quadCenter = vec2(cos(quadAngle), sin(quadAngle)) * centerDist;\n    \n    // return to color of the scale in the quadrant\n    vec2 circleUv = (uv + quadCenter) / circlesRad;\n    return roundPattern(circleUv);\n}\n\n// computes a ring with two layers of overlapping patterns\nvec4 dblRing(vec2 uv, float angle, float centerDist, float numcircles, float circlesRad, float t)\n{\n    // Odd and even scales dance up and down\n    float s = sin(t * 3.0 + centerDist * 10.0) * 0.05;\n    float d1 = 1.05 + s;\n    float d2 = 1.05 - s;\n    \n    // the whole thing spins with a sine perturbation\n    float rot = t * centerDist * 0.4 + sin(t + centerDist * 5.0) * 0.2;\n    \n    // compute bith rings\n    vec4 ring1 = ring(uv, angle, 0.0 + rot, centerDist * d1, numcircles, circlesRad);\n    vec4 ring2 = ring(uv, angle, 0.5 + rot, centerDist * d2, numcircles, circlesRad);\n    \n    // blend the results\n    vec4 col = premulMix(ring1, ring2);\n    \n    // add a bit of distance shading for extra depth\n    col.rgb *= 1.0 - (centerDist * centerDist) * 1.6;\n    \n    return col;\n}\n\n// computes a double ring on a given radius with a number of scales to fill the circle evenly\nvec4 autoRing(vec2 uv, float angle, float centerDist, float t)\n{\n    float nbCircles = 1.0 + floor(centerDist * 23.0);\n    return dblRing(uv, angle, centerDist, nbCircles, 0.23, t);\n}\n\n// Computes the pixel color for the full image at a givent time\nvec3 fullImage(vec2 uv, float angle, float centerDist, float t)\n{\n    vec3 col;\n    \n    // the screen is cut in concentric rings\n    float space = 0.1;\n    \n    // determine in which ring the pixel is\n    float ringRad = floor(centerDist / space) * space;\n    \n\t// computes the scales in the previous, current and next ring\n\tvec4 ringCol1 = autoRing(uv, angle, ringRad - space, t);\n \tvec4 ringCol2 = autoRing(uv, angle, ringRad, t);\n    vec4 ringCol3 = autoRing(uv, angle, ringRad + space, t);\n    \n    // blends everything together except in the center\n    if (ringRad > 0.0)\n    {\n        col.rgb = ringCol3.rgb;\n        col.rgb = premulMix(ringCol2, col.rgb);\n        col.rgb = premulMix(ringCol1, col.rgb);\n    }\n\telse\n    {\n        col.rgb = ringCol2.rgb; \n    }\n\n    return col;\n}\n\n// A noise function that I tried to make as gaussian-looking as possible\nfloat noise21(vec2 uv)\n{\n    vec2 n = fract(uv* vec2(19.48, 139.9));\n    n += sin(dot(uv, uv + 30.7)) * 47.0;\n    return fract(n.x * n.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y; \n    \n    uv *= 0.9;\n    \n    // Computes polar cordinates\n    float angle = atan(uv.y, uv.x) / 6.283 + 0.5;\n    float centerDist = length(uv);\n    \n    vec3 col = vec3(0.0);\n    \n\t// average 4 samples at slightly different times for motion blur\n    float noise = noise21(uv + iTime);\n    for (float i = 0.0; i < 4.0; i++)\n    {\n        col += fullImage(uv, angle, centerDist, iTime - ((i + noise) * 0.03));\n    }\n    col /= 4.0;\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}