{"ver":"0.1","info":{"id":"4csyzH","date":"1720856126","viewed":135,"name":"Blood flows in blood vessels","username":"Capo","description":"I used noise to mimic the flow of blood in blood vessels","likes":14,"published":1,"flags":32,"usePreview":1,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPIRAL_NOISE_ITER 8\n#define R(p, a) p = cos(a) * p + sin(a) * vec2(p.y, -p.x)\n\nfloat hash(const in vec3 p) {\n    return fract(sin(dot(p, vec3(127.1, 311.7, 758.5))) * 43758.54);\n}\n\nfloat pn(in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n    f *= f * (3. - f - f);\n    vec2 uv = (p.xy + vec2(37, 17) * p.z) + f.xy,\n        rg = textureLod(iChannel0, (uv + .5) / 256., -100.).yx;\n    return 2.4 * mix(rg.x, rg.y, f.z) - 1.;\n}\n\nconst float nudge = 20.;\nfloat normalizer = 1.0 / sqrt(1.0 + nudge * nudge);\nfloat SpiralNoiseC(vec3 p, vec4 id) {\n    float iter = 2., n = 2. - id.x;\n    for (int i = 0; i < SPIRAL_NOISE_ITER; i++) {\n        n += -abs(sin(p.y * iter) + cos(p.x * iter)) / iter;\n        p.xy += vec2(p.y, -p.x) * nudge;\n        p.xy *= normalizer;\n        p.xz += vec2(p.z, -p.x) * nudge;\n        p.xz *= normalizer;  \n        iter *= id.y + .733733;\n    }\n    return n;\n}\n\n// Helper functions\nvec4 permute(vec4 x) {\n    return mod(((x*34.0)+1.0)*x, 289.0);\n}\n\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// Simplex noise\nfloat simplex(vec3 v) {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0);\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx);\n\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min(g.xyz, l.zxy);\n    vec3 i2 = max(g.xyz, l.zxy);\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    i = mod(i, 289.0);\n    vec4 p = permute(permute(permute(\n                i.z + vec4(0.0, i1.z, i2.z, 1.0))\n              + i.y + vec4(0.0, i1.y, i2.y, 1.0))\n              + i.x + vec4(0.0, i1.x, i2.x, 1.0));\n\n    vec4 j = p - 49.0 * floor(p * 0.0243902439);\n    vec4 x_ = floor(j * 0.142857142857);\n    vec4 y_ = floor(j - 7.0 * x_);\n\n    vec4 x = x_ *0.142857142857 + 0.071428571428571;\n    vec4 y = y_*0.142857142857 + 0.071428571428571;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4(x.xy, y.xy);\n    vec4 b1 = vec4(x.zw, y.zw);\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;\n\n    vec3 g0 = vec3(a0.xy,h.x);\n    vec3 g1 = vec3(a0.zw,h.y);\n    vec3 g2 = vec3(a1.xy,h.z);\n    vec3 g3 = vec3(a1.zw,h.w);\n\n    vec4 norm = taylorInvSqrt(vec4(dot(g0,g0), dot(g1,g1), dot(g2,g2), dot(g3,g3)));\n    g0 *= norm.x;\n    g1 *= norm.y;\n    g2 *= norm.z;\n    g3 *= norm.w;\n\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot(m*m, vec4(dot(g0,x0), dot(g1,x1),\n                                dot(g2,x2), dot(g3,x3)));\n}\n\n// Voronoi noise (Worley noise)\nfloat voronoi(vec3 p) {\n    vec3 b, r;\n    float d = 1e30;\n    for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n            for (int i = -1; i <= 1; i++) {\n                b = floor(p) + vec3(i, j, k);\n                r = p - b - hash(b);\n                d = min(d, dot(r, r));\n            }\n        }\n    }\n    return sqrt(d);\n}\n\n// fBM noise\nfloat fbm(vec3 p) {\n    float f = 0.0;\n    mat3 m = mat3( 0.0,  0.8,  0.6, \n                  -0.8,  0.36, -0.48, \n                   0.6,  0.48, -0.64 );\n    for (int i = 0; i < 5; i++) {\n        f += 0.5 * simplex(p);\n        p = m * p * 2.0;\n    }\n    return f;\n}\n\n#ifdef SHANE_ORGANIC\nfloat map(vec3 p, vec4 id) {\n    float k = 2. * id.w + .1;\n    p *= (.5 + 4. * id.y);\n    return k * (.1 + abs(dot(p = cos(p * .6 + sin(p.zxy * 1.8)), p) - 1.1) * 3. + pn(p * 4.5) * .12);\n}\n#elif defined SIMPLEX_NOISE\nfloat map(vec3 p, vec4 id) {\n    float k = 2. * id.w + .1;\n    return k * (.5 + simplex(p * .4132 + 333.) * 3. + pn(p * 8.5) * .12);\n}\n#elif defined VORONOI_NOISE\nfloat map(vec3 p, vec4 id) {\n    float k = 2. * id.w + .1;\n    return k * (.5 + voronoi(p.zxy * .4132 + 333.) * 3. + pn(p * 8.5) * .12);\n}\n#elif defined FBM_NOISE\nfloat map(vec3 p, vec4 id) {\n    float k = 2. * id.w + .1;\n    return k * (.5 + fbm(p * .4132 + 333.) * 3. + pn(p * 8.5) * .12);\n}\n#else\nfloat map(vec3 p, vec4 id) {\n    float k = 2. * id.w + .1;\n    return k * (.5 + SpiralNoiseC(p.zxy * .4132 + 333., id) * 3. + pn(p * 8.5) * .12);\n}\n#endif\n\nvec3 hsv2rgb(float x, float y, float z) {    \n    return z + z * y * (clamp(abs(mod(x * 6. + vec3(0, 4, 2), 6.) - 3.) - 1., 0., 1.) - 1.);\n}\n\nvec4 renderSuperstructure(vec3 ro, vec3 rd, const vec4 id) {\n    const float max_dist = 20.;\n    float ld, td = 0., w, d, t, noi, lDist, a,         \n          rRef = 2. * id.x,\n          h = .05 + .25 * id.z;\n   \n    vec3 pos, lightColor;   \n    vec4 sum = vec4(0);\n    \n    t = .3 * hash(vec3(hash(rd)) + iTime / 3.0); // Slow down time by 3 times\n\n    for (int i = 0; i < 200; i++)  {\n        if(td > .9 || sum.a > .99 || t > max_dist) break;\n        a = smoothstep(max_dist, 0., t);\n        d = abs(map(pos = ro + t * rd, id)) + .07;\n        lDist = max(length(mod(pos + 2.5, 5.) - 2.5), .001);\n        noi = pn(0.03 * pos);\n        lightColor = mix(hsv2rgb(noi, .5, .6), \n                         hsv2rgb(noi + .3, .5, .6), \n                         smoothstep(rRef * .5, rRef * 2., lDist));\n        sum.rgb += a * lightColor / exp(lDist * lDist * lDist * .08) / 30.;\n        if (d < h) {\n            td += (1. - td) * (h - d) + .005;\n            sum.rgb += sum.a * sum.rgb * .25 / lDist;\n            sum += (1. - sum.a) * .05 * td * a;\n        } \n        td += .015;\n        t += max(d * .08 * max(min(lDist, d), 2.), .01);\n    }\n    \n    sum *= 1. / exp(ld * .2) * .9;\n    sum = clamp(sum, 0., 1.);\n    sum.xyz *= sum.xyz * (3. - sum.xyz - sum.xyz);\n    return sum;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec4 sliderVal = vec4(\n        0.5 + 0.5 * sin(iTime * 0.002 / 3.0), \n        0.4 + 0.4 * sin(iTime * 0.0024 / 3.0),  \n        0.2 + 0.2 * sin(iTime * 0.0028 / 3.0),  \n        0.4 + 0.4 * sin(iTime * 0.0032 / 3.0)  \n    );\n\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 ro = vec3(15. + iTime * 0.2 / 3.0, cos(.01 * iTime / 3.0), 15. + iTime * 0.2 / 3.0);  // Slow down time by 3 times\n    vec3 rd = normalize(vec3((fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y, 1.));\n   \n    R(rd.zx, 0.02 * m.x);  \n    R(rd.yx, 0.123 * m.y); \n    R(rd.xz, iTime * .0009 / 3.0);  // Slow down time by 3 times\n       \n    vec4 col = renderSuperstructure(ro, rd, sliderVal);\n\n    fragColor = vec4(col.rgb, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\n\nvec4 sliderVal;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    sliderVal = vec4(\n        0.5 + 0.5 * sin(iTime * 0.02),  \n        0.4 + 0.4 * sin(iTime * 0.024),\n        0.2 + 0.2 * sin(iTime * 0.028),\n        0.4 + 0.4 * sin(iTime * 0.032)\n    );\n\n    fragColor = sliderVal;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}