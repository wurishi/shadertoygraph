{"ver":"0.1","info":{"id":"MXd3WM","date":"1717094130","viewed":125,"name":"Wavy Grid Illusion","username":"incre_ment","description":"Wavy grid illusion using domain repetition.\nThe illusion is a famous one (the appearance of black circles at the white intersections).\nThanks to IQ and Big WIngs for the knowledge.\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["grid","domainrepetition","wavy","illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Wavy grid illusion using domain repetition.\n// The illusion is the appearance of black circles at the white intersections.\n// Thanks to IQ and BigWIngs for the knowledge\n\nfloat PI = 3.14159256;\nfloat TAU = 2.0*3.14159256;\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat lineSeg( in vec2 p, in vec2 a, in vec2 b )\n{\n    b -= a; p -= a;\n    return length(p - b* clamp( dot(p,b)/dot(b,b), 0., 1.) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = ( fragCoord - .5* iResolution.xy ) /iResolution.y;\n   vec3 col = vec3(0.); \n   float tt = fract(.4*iTime);\n      \n   // Grid Scale Factor\n   uv *= 12.;\n   \n   // Create cell IDs\n   vec2 cellID = round(uv);\n   \n   // Each cell goes from -.5 to .5\n   uv = fract(uv + .5) - .5;\n   \n   // Rotation radius of point in each cell\n   float rr = .25;\n   \n   float lineVal = 0.;\n   vec2 points[9];\n   float offs[9];\n\n   // Calculate motion of current and neighboring cells.  I do all 9 here,\n   // even though only 5 needed for this shader (Central + above, below, left, and right).\n   int count = 0;\n   for(float i = -1.; i <= 1.; i++)\n   for(float j = -1.; j <= 1.; j++){  \n     float offset = length(cellID + vec2(i,j));\n     offs[count] = offset;\n     vec2 motion = vec2(rr*cos(TAU*tt+offset),rr*sin(TAU*tt+offset));\n     points[count] = vec2(i,j) + motion;\n     count++;   \n  \n   }\n\n   // Draw the lines to the neighboring cells.  Attempt at interpolating the line width\n   // between the cells based on their offset.  Not sure I got it quite right...\n   for(int i = 0; i < 9; i++){\n      float glow = .085;    \n      vec2 p1 = points[4];\n      vec2 p2 = points[i];      \n      vec2 pVec = p2 - p1;     \n      float pVal = dot(normalize(pVec),uv); \n      \n      float oVal = 1.3 + sin(TAU*tt + mix(offs[4], offs[i], pVal));\n      \n      // Only draw the horizontal and verical lines\n      if(i == 1 || i == 3 || i == 5 || i == 7)\n      lineVal += oVal*pow(glow/(lineSeg(uv, points[4], points[i])),3.0);    \n   }   \n   col += lineVal;\n   fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}