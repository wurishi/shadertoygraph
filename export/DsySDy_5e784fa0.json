{"ver":"0.1","info":{"id":"DsySDy","date":"1681505895","viewed":94,"name":"phoenix smactal (don't ask)","username":"graygoose","description":"click, hold and move mouse to \"rotate the hyperobject\".","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["fractal","simple"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"smactal (don't ask)\" by graygoose. https://shadertoy.com/view/mdyXRd\n// 2023-04-14 20:48:58\n\n// Fork of \"newtons_fract_simple\" by graygoose. https://shadertoy.com/view/sdKBDw\n// 2023-04-14 05:14:18\n\n#define PI 3.14159265359\n#define TAU 6.283185307179586\n#define MAX_ITERS 300.\n#define SPHERE_EPS .000005\n\nvec3 sphereMapping(vec3 dir) {\n  float t_off = 0.01*cos(iTime*0.15);\n  vec2 uv = vec2(atan(dir.z, dir.x-t_off), asin(dir.y));\n  uv /= TAU;\n  uv += .5;\n  \n  float t = iTime * 0.1;\n  vec2 c = vec2(-cos(t) * cos(t), sin(t) * cos(t));\n\n  vec2 z = vec2(0.0, 0.0);\n  float iter;\n  for (iter=0.; iter < MAX_ITERS; iter++) {\n    vec2 newZ = dot(z, z) + c;\n    if (dot(newZ, newZ) > 4.0) break;\n    z = newZ;\n  }\n\n  float displacement = iter / float(MAX_ITERS);\n  vec3 normal = normalize(dir);\n  vec3 perturbation = displacement * normal;\n  \n  float maxDisplacement = .01 * length(normal);\n  perturbation *= min(0.0, maxDisplacement / length(perturbation));\n  \n  return texture(iChannel0, uv).rgb + perturbation;\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n  vec2 z = ( 2.0 * U - iResolution.xy ) / iResolution.y;\n  \n  float t = iTime * 0.5;\n  \n  vec3 rayDir = normalize(vec3(z, -1.0));\n  vec3 rayPos = vec3(0.0, 0.0, 1.25);\n  \n\n  float dist = 0.0;\n  vec3 color = vec3(0.0);\n  for (int i = 0; i < 100; i++) {\n    vec3 pos = rayPos + dist * rayDir;\n    vec3 normal = normalize(pos);\n    float d = length(pos) - 1.0 + 0.2 * length(sphereMapping(normal));    \n    if (d < SPHERE_EPS) {\n      color = sphereMapping(normal);\n    }\n    dist += d;\n    if (dist > 10.0) break;\n  }\n\n  O = vec4(7.*color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\nvec2 wrap(in vec2 p, in vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.753,0.380,0.796,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MOUSE\n\n#define NROOTS 3\nvec2 roots[NROOTS];\n\n\nint get_nearest_root(vec2 z){\n    int index = 0; float dist = 1000.;\n    \n    for(int i = 0; i < NROOTS; i++){\n        float d = length(z - roots[i]);\n        if(d < dist){\n            index = i; dist = d;\n        }\n    }\n    \n    return index;\n}\n\nvec2 phoenix_iter(in vec2 z, float stepSize){\n    vec2 sum = vec2(0.);\n\n    for(int j = 0; j < NROOTS; j++){\n        vec2 dist = z - roots[j];\n        float delta = dist.x*dist.x+dist.y*dist.y;\n        if (delta < 0.0001) return z;\n        \n        sum += vec2(dist.x * cos(delta) + dist.y * sin(delta), -dist.x * sin(delta) + dist.y * cos(delta)) / delta;\n    }\n    \n    return z - (normalize(vec2(sum.x, -sum.y)) * stepSize);\n}\n\n\nfloat rand(int seed) {\n    return fract(sin(float(seed) * 1234.5678) * 9876.5432);\n}\n\n\n\nvoid generateInitialRootPositions() {\n    for (int i = 0; i < NROOTS; i++) {\n        roots[i] = vec2(rand(i), rand(i + 1));\n    }\n}\n\n#define MOVE_SCALE 1.63-abs(sin(0.125*iTime))\n#define MOVE_SPEED 0.19\n\nvoid moveRoots(float time) {\n    for (int i = 0; i < NROOTS; i++) {\n        float t = MOVE_SPEED * time * (float(i + 1) * 0.1 + 1.0) + (float(i + 1) * .1);\n        float radius = 0.5 + 0.2 * float(i);\n        roots[i].x = MOVE_SCALE * cos(t + float(i));\n        roots[i].y = MOVE_SCALE * sin(t + float(i));\n    }\n}\n\n\n#define ITER_COUNT 150\n#define ITER(z) phoenix_iter(z, .462)\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    generateInitialRootPositions();\n    moveRoots(iTime);\n    \n    // scale math space\n    vec2 z = scale(fragCoord.xy, iResolution.xy, mat2(-1.25, 1.25, -.5, 1.)); \n    z += vec2(0.5, -.5);\n\n    #ifdef MOUSE\n    if (iMouse.z > 0.0) {\n        vec2 m = scale(iMouse.xy, iResolution.xy,  mat2(-1.25, 1.25, -.5, 1.)*2.);\n        z *= m;\n    }\n    #endif\n    // calculate pixel convergence & color\n    for(int i = 0; i < ITER_COUNT; i++){\n        z = ITER(z);\n    }\n    \n    // coloring\n    int col_index = get_nearest_root(z);\n    vec3 col = vec3(col_index-0==0,col_index-1==0,col_index-2==0);\n    \n    vec3 normalized_col = col / max(col.r, max(col.g, col.b));\n    fragColor = vec4(hueShift(normalized_col, cos(0.25*iTime)), 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 C1 = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    vec4 L0 = filter3x3(fragCoord.xy, LAPLACIAN, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n    \n    fragColor = C0 + G1;\n    fragColor *= -L0 / (2.-C0);\n    \n    fragColor += C1 + G1;\n    fragColor += -L0 / (2.-C1);\n\n    \n    fragColor += G1 + L0;\n    fragColor *= 0.3;\n}","name":"Buffer B","description":"","type":"buffer"}]}