{"ver":"0.1","info":{"id":"WtKXRh","date":"1582187104","viewed":115,"name":"02 Simple Shapes","username":"waffles","description":"Examples of simple shapes","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["shadertoy","shapes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Licensed under Creative Commons CC0: https://creativecommons.org/share-your-work/public-domain/cc0/\n\n// More 2D shapes here: https://iquilezles.org/articles/distfunctions2d\n\nmat2 rotateZ(float angleDeg)\n{\n  // \"radians — convert a quantity in degrees to radians\"\n  float angleRad = radians(angleDeg);\n  // http://mathworld.wolfram.com/RotationMatrix.html\n  mat2 rot = mat2(vec2(cos(angleRad), sin(angleRad)), vec2(-sin(angleRad), cos(angleRad)));\n  return rot;\n}\n\nfloat circle(vec2 coord, float size)\n{\n  // \"length — calculate the length of a vector\"\n  return length(coord)-size;\n}\n\nfloat rect(vec2 p, vec2 b)\n{\n    /*\n    // \"Traditional\" CPU way-of-working could look something like this\n    for (int y = 0; y < height; y++) {\n        for (int x = 0; x < width; x++) {\n            plotPixel(positionX + x, positionY + y);\n        }\n    }\n\n\t// GPU way-of-working would then be like\n\tif (positionX >= x && positionX < x+width\n\t\t&& positionY >= y && positionY < y+height) {\n\t\tplotPixel(positionX, positionY);\n\t}\n    */\n\n  // \"abs — return the absolute value of the parameter\"\n  vec2 d = abs(p) - b;\n  // \"min — return the lesser of two values\"\n  // \"max — return the greater of two values\"\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// Note that IQ provides much more efficient way to do this\n// however this is to illustrate that more complex shapes\n// can be created from simpler shapes\nfloat xcross(vec2 p, vec2 b)\n{\n  p *= rotateZ(45.0);\n  float dist = rect(p, b);\n\n  p *= rotateZ(90.0);\n  dist = min(dist, rect(p, b));\n\n  return dist;\n}\n\nfloat triangle(vec2 p, vec2 h)\n{\n  // https://en.wikipedia.org/wiki/Steiner_tree_problem\n  // \"sqrt — return the square root of the parameter\"\n  float steinerRatio = sqrt(3.0)/2.0;\n  return max(-h.y,max(abs(p).x*steinerRatio-p.y*0.5,p.y)-h.x*0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // setup coordinates here\n    // \"uv\" refers to UV mapping https://en.wikipedia.org/wiki/UV_mapping\n    // just think UV as normalized coordinates in the screen\n    // where x is 0.0 - 1.0 and y is 0.0 - 1.0\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 aspectRatio = vec2(iResolution.x/iResolution.y, -1.0);\n    vec2 coord = aspectRatio * (uv - 0.5);\n\n    // define shapes\n    // \"d\" is for distance.\n    // Shape is drawn in later part, when the value is negative :-)\n    float d = triangle(coord + vec2(0.4,-0.03), vec2(0.12));\n    \n    d = min(d,\n        // Circle with a hole\n        max(circle(coord + vec2(0.12,0.0), 0.1),\n        -circle(coord + vec2(0.12,0.0), 0.08))\n    );\n    d = min(d, xcross(coord + vec2(-0.13,0.0), vec2(0.04,0.1)));\n    d = min(d, rect(coord + vec2(-0.4,0.0), vec2(0.09)));\n    \n    d = min(d, xcross(coord + vec2(-0.13,0.0), vec2(0.04,0.1)));\n\t\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Apply shapes\n    // \" sign returns -1.0 if x is less than 0.0, 0.0 if x is equal to 0.0, and +1.0 if x is greater than 0.0. \"\n    col = sign(d)*col;\n    vec3 shapeColor = vec3(1.0,0.0,0.0);\n    if (uv.y > 0.5) {\n      //antialiased version\n      // \"mix — linearly interpolate between two values\"\n      // \"smoothstep performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where a threshold function with a smooth transition is desired.\"\n      col = mix(col, shapeColor, 1.0-smoothstep(0.0,0.003,d));\n    } else {\n      //not antialiased version\n      col = mix(col, shapeColor, d > 0.0 ? 0.0 : 1.0);\n    }\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}