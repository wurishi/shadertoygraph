{"ver":"0.1","info":{"id":"7tSGzK","date":"1624268537","viewed":213,"name":"Triangle of Triangles SDF","username":"lumic","description":"SDF for triangle of triangles","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sdf","triangle"],"hasliked":0,"parentid":"WttBRs","parentname":"Simple Beating Heart SDF - exact"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\nconst float TWOPI = 6.28318530718;\n\nconst float upperRadius = 0.2;\nconst float lowerRadius = 0.55;\n\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nfloat sdCircle(vec2 p, vec2 center, float r)\n{\n    return length(p - center) - r;\n}\n\n// c is the sin/cos of the angle. r is the radius\nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,r) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdBox(vec2 p, vec2 bottomLeft, vec2 topRight)\n{\n    vec2 center = 0.5 * (bottomLeft + topRight);\n    vec2 extents = 0.5 * (topRight - bottomLeft);\n    vec2 d = abs(p -  center) - extents;\n    return length(max(d, vec2(0, 0))) + min(max(d.x, d.y), 0.0);\n}\n\n\n// From: https://iquilezles.org/articles/distfunctions2d\n// https://www.shadertoy.com/view/wl23RK\n// sca is the sin/cos of the orientation\n// scb is the sin/cos of the aperture\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p, scb) : length(p);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    float radians = angle + deg / 360.0 * (2.0 * PI);\n    return vec2(r * cos(radians), r * sin(radians));\n}\n\nfloat combine( float d1, float d2 ) { return min(d1,d2); }\nfloat difference( float d1, float d2 ) { return max(d1,-d2); }\nfloat intersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smoothIntersect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat mixer() {\n    return (sin(iTime * 1.5) + 1.0) * 0.5;\n}\n\n\nfloat draw_solid(float d) {\n    return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\n\nfloat sdEquilateralTriangle(vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if (p.x + k * p.y > 0.0f) p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0f;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\nfloat testTrianglePattern(vec2 p) {\n    p = p - vec2(1.0, -1.0);\n    float d1 = sdEquilateralTriangle(p);\n    \n    vec2 q = vec2(p.x + 2.0, p.y);\n    float d2 = sdEquilateralTriangle(q);\n    \n    vec2 r = 0.5 * (p + q) + vec2(0.0, -sin(PI / 3.0) * 2.0);\n    float d3 = sdEquilateralTriangle(r);\n    \n    return combine(combine(d1, d2), d3);\n}\n\nfloat testTrianglePattern2(vec2 p) {\n    float d1 = sdEquilateralTriangle(p);\n    \n    vec2 q = vec2(p.x, -p.y);\n    float d2 = sdEquilateralTriangle(q * 2.0);\n    \n    return difference(d1, d2);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float t = 0.0f;\n    vec2 uv = squareFrame(iResolution.xy, fragCoord);\n    vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n    vec2 rd = normalize(-ro);\n\n    vec2 p = (uv - vec2(0, 0.15)) * 1.5;\n\n    float d = testTrianglePattern((p + vec2(0., 0.1)) *  2.1);\n  \n    // coloring\n    vec3 col = (d<0.0) ? vec3(0.6,0.3,1.0) : vec3(0.2,0.4,0.8);\n    col *= 1.0 - exp(-9.0*abs(d));\n    col *= 1.0 + 0.2*cos(128.0*abs(d));\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    fragColor.rgb = col;\n    fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"}]}