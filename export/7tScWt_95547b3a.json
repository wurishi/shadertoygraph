{"ver":"0.1","info":{"id":"7tScWt","date":"1650401925","viewed":115,"name":"Learning#RayMarching","username":"yumjelly","description":"Learning how to do RayMarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["testing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\n#define BALL_X 0.\n#define BALL_Y 1.\n#define BALL_Z 10.\n\n#define LIGHT_X 0.\n#define LIGHT_Y 5.\n#define LIGHT_Z 10.\n\n//Learning RayMarching \n//Yin's note:\n//Ray Marching or Sphere Tracing(Maybe Sphere Tracing is more accurate)\n//Normalized pixel coordinates (from 0 to 1)\n/*\n@ SURF_DIST: when the ray is smaller than this value, we count that a hit\n@ ro: ray orgin\n@ rd: ray direction\n@ ds: distance from p \n@ LightVector: Direction from point to the light source. \n@ dif: diffuse lighting \n\nlight = dot(lightVector,NormalVector) 因为光线lightVector越是垂直于地面，光强就越强，越是平行于地面越是趋近于0\n由于lightVector和NormalVector只表示方向，所以should be normalized, NormalVector 应该通过计算地面的斜率然后计算地面表面法向量得到\n\nshadow 使用shadowmap计算\n*/\n    \nfloat GetDist(vec3 p){\n    vec4 s=vec4(BALL_X,BALL_Y,BALL_Z,1);\n    \n    float sphereDist =length(p-s.xyz)-s.w;\n    float planeDist =p.y;\n    \n    float d=min(sphereDist,planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO=0.;\n     \n    for(int i=0;i<MAX_STEPS;i++){\n        vec3 p=ro+rd*dO;\n        float dS=GetDist(p);\n        dO+=dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    return dO;\n}\n\n\n//get ground normal from point p\nvec3 GetNormal(vec3 p){\n    float d=GetDist(p);\n    vec2 e=vec2(.01,0);\n    \n    vec3 n=d-vec3(\n        GetDist(p-e.xyy), //e.xyy = vec3(.01,0,0)\n        GetDist(p-e.yxx),\n        GetDist(p-e.yyx));\n        \n    return normalize(n);\n\n}\n\nfloat GetLight(vec3 p){\n    vec3 lightPos= vec3(LIGHT_X,LIGHT_Y,LIGHT_Z);\n    lightPos.xz+=vec2(sin(iTime),cos(iTime))*LIGHT_Z;//move Light around\n\n    vec3 l= normalize(lightPos-p);\n    vec3 n= GetNormal(p);\n    \n    float dif= clamp(dot(n,l),0.,1.);\n    //Shadow(shadowmap)\n    float d=RayMarch(p+n*SURF_DIST*2.,l);\n    if(d<length(lightPos-p))\n        dif *= .1;\n    \n    return dif;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord- .5*iResolution.xy)/iResolution.y;  \n    // Time varying pixel color\n    vec3 col = vec3(0);\n    \n    vec3 ro=vec3(0,1,0);\n    vec3 rd =normalize(vec3(uv.x,uv.y,1));\n    \n    float d = RayMarch(ro,rd);\n    \n    vec3 p= ro+rd*d;\n    \n    float dif =GetLight(p);\n    col=vec3(dif);\n\n    //col=GetNormal(p);//Testing GetNormal()\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}