{"ver":"0.1","info":{"id":"7sGfzG","date":"1658399448","viewed":111,"name":"special relativity raycaster","username":"Koulatko","description":"\n\nUpdate 2022-10-23: I've noticed the precession fix unfortunately introduced a lot of numerical instability at high speeds compared to the naive implementation","likes":3,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","raytracing","relativity"],"hasliked":0,"parentid":"ssGBzG","parentname":"relativity attempt"},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 ray_grid(vec3 ro, vec3 rd, out int obj_id){\n    const float epsilon = 0.0001;\n    float depth = 0.0;\n    float stepsize = 1.0;\n    //Could use some optimization (stop marching through empty space)\n    for(int i = 0; i < 50; i++){\n        vec3 p = fract(ro + (depth)*rd);\n        vec3 F = floor(ro + depth*rd);\n        \n        \n        vec4 hashpx = hash42(2.0*F.xy+vec2(1.0, 0.0));\n        vec4 hashnx = hash42(2.0*F.xy-vec2(1.0, 0.0));\n        vec4 hashpy = hash42(2.0*F.xy+vec2(0.0, 1.0));\n        vec4 hashny = hash42(2.0*F.xy-vec2(0.0, 1.0));\n\n\n        float rad = 0.1;\n\n        vec4 brg = vec4(hashpx.z, hashnx.z, hashpy.z, hashny.z);\n\n        vec4 h;\n        vec4 h1;\n        int obj_id_tmp;\n        float p_width = 0.2;\n        \n        if(hashpx.y > 0.9){\n            h1 = ray_sphere(ro-vec3(F.xy, 0.0)-vec3(0.5, 0.5, 0.18), rd, 0.08);\n            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n                h = h1;\n                obj_id_tmp = 3;\n            }\n        }\n        \n        \n        h1 = ray_box(ro-vec3(F.xy, 0.0)-vec3(0.5, 0.5, 0.0), rd, vec3(p_width, p_width, 0.1));\n        if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n            h = h1;\n            obj_id_tmp = 1;\n        }\n\n        for(int i = 0; i < 4; i++){//Vomit-inducing code but who cares :P\n            vec2 off[4] = vec2[](vec2(1.0, 0.0), vec2(-1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, -1.0));\n\n            if(brg[i] > 0.5){\n                \n                h1 = ray_box(ro-vec3(F.xy, 0.0)-vec3(0.5+0.5*off[i], 0.02), rd, vec3(0.1+0.2*abs(off[i]), 0.06));\n\n                if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n                    h = h1;\n                    obj_id_tmp = 1;\n                }\n            } else\n            if(ray_boundbox(ro-vec3(F.xy, 0.16)-vec3(0.5+(p_width-0.01)*off[i], 0.0), rd, vec3(0.01+0.19*abs(off[i].yx), 0.08)) ) {\n                \n                \n                \n                h1 = ray_box(ro-vec3(F.xy, 0.22)-vec3(0.5+(p_width-0.01)*off[i], 0.0), rd, vec3(0.01+0.19*abs(off[i].yx), 0.01));\n                \n                \n\n                \n                if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n                    h = h1;\n                    obj_id_tmp = 2;\n                }\n                \n                for(int j = 0; j < 4; j++){\n                    \n                    vec2 poff = off[i].yx;\n                    float fj = (float(j)+0.5)/4.0;\n                    vec3 p1 = vec3(0.5+(p_width-0.01)*off[i] + 0.2*(-1.0+2.0*fj)*poff, 0.15);\n                    vec3 s1 = vec3(0.008, 0.008, 0.075);\n                    h1 = ray_box(ro-vec3(F.xy, 0.0)-p1, rd, s1);\n\n                    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n                        h = h1;\n                        obj_id_tmp = 2;\n                    }\n                }\n            \n            }\n        }\n\n\n        if(h.w > 0.0){obj_id = obj_id_tmp; return h;};\n        \n        \n        vec3 o = 1.0 - max(vec3(0.0), sign(-rd));\n        float q1 = min(\n            -(p.x-o.x)/rd.x,\n            -(p.y-o.y)/rd.y\n            );\n        \n        depth += q1+epsilon;\n    }\n    return vec4(0.0);\n}\n\nvec4 ray_scene(vec4 wo, vec4 wd, out vec4 dat, out int obj_id){\n    vec4 h;\n    vec4 h1;\n    \n    /*\n    h1 = ray_sphere(wo.xyz-vec3(2.,0.,0.),normalize(wd.xyz), 1.);\n    h1.w /= length(wo.xyz);\n    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n        h = h1;\n        float ht = wo.w+h.w*wd.w;\n        \n        dat.xyz = hue(0.5*ht);\n    }\n    */\n    //wd = normalize(wd);\n    \n    \n        \n    \n    \n    \n    \n    \n    \n    \n    h1 = ray_grid(wo.xyz/8.0, normalize(wd.xyz), obj_id);\n    h1.w /= length(wd.xyz);\n    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n        h = h1;\n        h.w *= 8.0;\n        float ht = LIGHTSPEED*wo.w+h.w*wd.w;\n        ht /= LIGHTSPEED;\n        \n        dat.xyz = hue(0.5*ht);\n    }\n    \n    for(int i = 0; i < 8; i++){\n        vec3 vertexpos = vec3(i&1, (i>>1)&1, (i>>2)&1);\n        h1 = ray_sphere(wo.xyz-vertexpos, normalize(wd.xyz), 0.1);\n        h1.w /= length(wd.xyz);\n        if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){h = h1; obj_id = 0x100+i;}\n    }\n    \n    \n    for(int i = 0; i < 2; i++){\n        for(int j = 0; j < 2; j++){\n            bool hitframe = false;\n            h1 = ray_cylinder(wo.xyz, normalize(wd.xyz), vec3(i,j,0.), vec3(i,j,1), 0.03);\n            h1.w /= length(wd.xyz);\n            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){h = h1; obj_id = 100; dat = vec4(0.2);}\n            h1 = ray_cylinder(wo.xyz, normalize(wd.xyz), vec3(j,0,i), vec3(j,1,i), 0.03);\n            h1.w /= length(wd.xyz);\n            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){h = h1; obj_id = 100; dat = vec4(0.2);}\n            h1 = ray_cylinder(wo.xyz, normalize(wd.xyz), vec3(0,i,j), vec3(1,i,j), 0.03);\n            h1.w /= length(wd.xyz);\n            if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){h = h1; obj_id = 100; dat = vec4(0.2);}\n            \n        }\n    }\n    \n    \n    /*\n    h1 = ray_plane(wo.xyz,normalize(wd.xyz), vec4(0.,0.,1.,0.));\n    h1.w /= length(wo.xyz);\n    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n        h = h1;\n        vec4 hp = wo*vec4(1.,1.,1.,LIGHTSPEED)+h.w*wd;\n        hp.w /= LIGHTSPEED;\n        \n        dat.xyz = hue(hp.w + 0.04*hp.x);\n        \n        //dat.xyz = sin(6.28*hp.w)*vec3(1.);\n    }\n    */\n    \n    \n    /*\n    h1 = ray_grid(ro/8.0, rd, obj_id);\n    if(h1.w > 0.0 && (h1.w < h.w || h.w <= 0.0)){\n        h = h1;\n        h.w *= 8.0;\n    }*/\n    \n    \n    return h;\n}\n\nvec3 triplanar(sampler2D tex, vec3 p, vec3 d){\n    vec3 X = texture(tex, p.yz).xyz;\n    vec3 Y = texture(tex, p.xz).xyz;\n    vec3 Z = texture(tex, p.xy).xyz;\n    \n    vec3 w = abs(d);\n    w /= dot(w, vec3(1.0));\n    \n    return w.x*X + w.y*Y + w.z*Z;\n    \n    return mat3(X,Y,Z)*w;\n}\n\nvec3 sky(vec3 rd, bool indirect){\n\n    float z = rd.z*0.5+0.5;\n    \n    vec3 o = (z*z*z*z)*vec3(0.4, 0.6, 0.9);\n    \n    vec3 L = normalize(vec3(1.0, 0.4, 1.0));\n    if(!indirect) o += min(1.0, 0.005/(1.0-dot(rd, L)));\n    return o;\n}\n\nvec3 camera_stereographic(vec2 ss){\n    float stereo_denom = 1./(1.+dot(ss,ss));\n    vec3 rd = vec3(2.*ss.x, 2.*ss.y, -2.)*stereo_denom;\n    rd.z += 1.;\n    return rd;\n}\n\nvec3 aberration(vec3 rd, vec3 dir, float v){\n    float q = 1.-v*v;\n    float h = 1./sqrt(q)-1.;\n    float k = sqrt(1./q-1.);\n    return normalize(rd-dir*(k-h*dot(rd,dir)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 ss = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    vec4 pos_texel = texelFetch(iChannel3, ivec2(0,0), 0);\n    vec3 ro = pos_texel.xyz;\n    \n    vec4 camera_angle_texel = texelFetch(iChannel3, ivec2(1,0), 0);\n    float pitch = camera_angle_texel.y;\n    float yaw = camera_angle_texel.x;\n    \n    vec3 right = vec3(sin(yaw), -cos(yaw), 0.0);\n    vec3 up = vec3(-cos(yaw)*sin(pitch), -sin(yaw)*sin(pitch), cos(pitch));\n    vec3 forward = vec3(cos(yaw)*cos(pitch), sin(yaw)*cos(pitch), sin(pitch));\n\n    vec3 rd = normalize(vec3(ss,-1.5));\n    rd = mat3(right,up,-forward)*rd;\n    \n    \n    \n    vec4 cam_vel_texel = texelFetch(iChannel3, ivec2(6,0), 0);\n    \n    //name left over from past version\n    vec3 cam_vel = cam_vel_texel.xyz;\n    \n    \n    float cam_vel_l = length(cam_vel);\n    \n    float lorenz = sqrt(1.+dot(cam_vel,cam_vel)/(LIGHTSPEED*LIGHTSPEED));\n    \n    vec3 ground_velocity = cam_vel/lorenz;\n    float ground_speed = length(ground_velocity);\n    \n    //rd = aberration(rd, normalize(ground_velocity), ground_speed/LIGHTSPEED);\n    \n   \n    vec4 wo = pos_texel;\n    vec4 wd = vec4(rd, -1.);\n    \n    \n    //uncomment\n    wd = lorentz_boost(-ground_velocity+vec3(0.00001),LIGHTSPEED)*wd;\n    \n    //rd = normalize(wd.xyz);\n    \n    \n    //rd = camera_stereographic(ss);\n    \n    \n    \n    int o_id;\n    vec4 dat;\n    vec4 h = ray_scene(wo, wd, dat, o_id);\n    \n    vec3 col;\n    if(h.w > 0.0){\n        vec3 L = normalize(vec3(1.0, 0.4, 1.0));\n        vec3 N = h.xyz;\n        \n        vec3 illum = vec3(0.15, 0.2, 0.3);\n        \n        int trashi;\n        //vec4 shadow_cast = ray_scene(ro+h.w*rd+0.001*N, L, trashi);\n        if(/*shadow_cast.w <= 0.0*/true){\n            illum += vec3(1.5, 1.4, 1.3)*max(0.0, dot(N, L));\n        }\n        \n        vec3 apparent_hit = wo.xyz+h.w*wd.xyz;\n        vec3 tex = pow(triplanar(iChannel0, apparent_hit , h.xyz), vec3(2.2));\n        \n       \n        \n        if(o_id < 3) tex = tex.zyx;\n        if(o_id == 3) tex = tex.xzy;\n        \n        if(o_id == 3) tex = dat.xyz;\n        \n        if(o_id == 100) tex = vec3(0.3);\n        if(o_id >= 0x100) tex = vec3(((o_id-0x100)>>0)&1, ((o_id-0x100)>>1)&1, ((o_id-0x100)>>2)&1);\n        \n        \n        \n        float wl = 550.;\n        \n        \n        float beta = ground_speed/LIGHTSPEED;\n        float gamma = 1./sqrt(1.-beta*beta);\n        wl /= (gamma*(1.+beta*dot(normalize(wd.xyz), normalize(ground_velocity))));\n        \n        //tex = wl_to_xyz(wl);\n        \n        col = illum*tex;\n    } else {\n        /*float wl = 1000.;\n        \n        \n        float beta = ground_speed/LIGHTSPEED;\n        float gamma = 1./sqrt(1.-beta*beta);\n        wl /= (gamma*(1.+beta*dot(normalize(wd.xyz+0.00001), normalize(ground_velocity+0.0001))));\n        \n        col = wl_to_xyz(wl);*/\n    }\n    \n    //col = mix(col, sky(rd, h.w > 0.0), h.w <= 0.0 ? vec3(1.0) : vec3(1.0)-exp(-0.03*vec3(0.4, 0.5, 0.6)*h.w));\n    \n    \n    mat3 xyz_to_rgb = mat3(3.2404542, -0.9692660, 0.0556434,\n                    -1.5371385, 1.8760108, -0.2040259,\n                    -0.4985314, 0.0415560, 1.0572252);\n    \n    \n    \n    col = pow(col, vec3(1./2.2));\n    //col = pow(xyz_to_rgb*col, vec3(1.0/2.2));\n    \n    \n    \n    \n    col += PrintValue(fragCoord, vec2(20.), vec2(15.), ground_speed, 4., 3.);\n    col += PrintValue(fragCoord, vec2(iResolution.x-160.,20.), vec2(15.), iTime, 4., 3.);\n    col += PrintValue(fragCoord, vec2(iResolution.x-160.,50.), vec2(15.), pos_texel.w, 4., 3.);\n    \n    \n    \n    /*\n    col = pow(0.0+1.*xyz_to_rgb*wl_to_xyz(uv.x*1000.), vec3(1.0/2.2));\n    \n    if(uv.y < 0.5) spectral_color(col.x,col.y,col.z,uv.x*1000.);\n    \n    col *= 0.6;\n    \n    //col = xyz_to_rgb*pow(0.0+0.5*wl_to_xyz(uv.x*1000.), vec3(1.0/2.2));\n    */\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec2 try_rotate_pitchyaw(vec2 py, vec4 quat){\n    py.x += atan(quat.z,quat.w)*2.;\n    py.y += atan(dot(vec2(sin(py.x),-cos(py.x)),quat.xy),quat.w)*2.;\n    if(py.y < -0.5*PI) py.y = -0.5*PI;\n    if(py.y > 0.5*PI) py.y = 0.5*PI;\n    return py;\n}\n\n\n\n\nvec3 get_acceleration(){\n    vec4 camera_angle_texel = texelFetch(iChannel0, ivec2(1,0), 0); //Geometry\n    float pitch = camera_angle_texel.y;\n    float yaw = camera_angle_texel.x;\n\n    vec3 off;\n\n    float W = texelFetch(iChannel1, ivec2(87, 0), 0).x;\n    float S = texelFetch(iChannel1, ivec2(83, 0), 0).x;\n    float A = texelFetch(iChannel1, ivec2(65, 0), 0).x;\n    float D = texelFetch(iChannel1, ivec2(68, 0), 0).x;\n    float space = texelFetch(iChannel1, ivec2(32, 0), 0).x;\n    float shift = texelFetch(iChannel1, ivec2(16, 0), 0).x;\n\n    float F = texelFetch(iChannel1, ivec2(70, 0), 0).x;\n\n    vec3 hor_forward = vec3(cos(yaw), sin(yaw), 0.0); \n    vec3 hor_right = vec3(sin(yaw), -cos(yaw), 0.0);\n\n    vec3 Adt = vec3(0.);\n\n    float spd = 4.1;\n    if(F > 0.0) spd *= 2.0;\n    if(W > 0.0){\n        Adt += spd*iTimeDelta*hor_forward;\n    }\n    if(S > 0.0){\n       Adt -= spd*iTimeDelta*hor_forward;\n    }\n    if(A > 0.0){\n        Adt -= spd*iTimeDelta*hor_right;\n    }\n    if(D > 0.0){\n        Adt += spd*iTimeDelta*hor_right;\n    }\n    if(space > 0.0){\n        Adt.z += spd*iTimeDelta;\n    }\n    if(shift > 0.0){\n        Adt.z -= spd*iTimeDelta;\n    }\n    return Adt;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //W = 87\n    //S = 83\n    //D = 68\n    //A = 65\n    //space = 32\n    //shift = 16\n    \n    //0,0 = camera pos\n    //1,0 = camera_euler\n    \n    bool is_start = iFrame == 0;\n    \n    ivec2 fc = ivec2(fragCoord);\n    vec4 cv = texelFetch(iChannel0, fc, 0);\n    vec4 nv = cv;\n    if(fc == ivec2(0,0)){\n        if(is_start){ //Init\n            fragColor = vec4(0.0, 0.0, 2.0, 0.0);\n            return;\n        }\n        vec3 vel = texelFetch(iChannel0, ivec2(6,0), 0).xyz;\n        nv.xyz = cv.xyz + iTimeDelta*vel;\n        \n        float lorenz = sqrt(1.+dot(vel,vel)/(LIGHTSPEED*LIGHTSPEED));\n        nv.w = cv.w + lorenz*iTimeDelta;\n        \n    }\n    if(fc == ivec2(6,0)){ //velocity\n        \n        if(is_start){ //Init\n            fragColor = vec4(0.0, 0.0, 0.0000, 0.0);\n            return;\n        }\n        \n        vec3 Adt = get_acceleration();\n        \n        nv.xyz = celerity_addition(nv.xyz,Adt);\n        \n        \n        \n        \n        //nv *= exp(-iTimeDelta);\n    }\n    \n    //0 - increment per-frame, smoother\n    //1 - increment relative to last click, time-stable but stutters\n    \n    int mouse_mode = 0;\n    \n    \n    if(fc == ivec2(1,0)){\n        if(is_start){\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            return;\n        }\n        vec4 old_mouse = texelFetch(iChannel0, ivec2(2,0), 0);\n        vec4 anchor = texelFetch(iChannel0, ivec2(2,1), 0);\n        \n        if(old_mouse.z > 0.0){\n            if(mouse_mode == 0){\n                nv.xy = cv.xy - 1.5*vec2(1.0,-1.0)*(iMouse.xy - old_mouse.xy)/iResolution.y;\n                nv.x = mod(nv.x, 2.0*PI);\n                nv.y = clamp(nv.y, -0.5*PI, 0.5*PI);\n            }\n            if(mouse_mode == 1){\n                nv.xy = anchor.xy + 0.01*vec2(-1.0, 1.0)*(iMouse.xy - old_mouse.xy);\n            }\n            \n        }\n        \n        vec3 c_cel = texelFetch(iChannel0, ivec2(6,0), 0).xyz; \n        \n        vec4 quat = celerity_gyrator_quaternion(c_cel, get_acceleration());\n        \n        \n        nv.xy = try_rotate_pitchyaw(nv.xy, quat);\n        \n    }\n    if(fc == ivec2(2,0)){\n        if(mouse_mode == 0){\n            nv = iMouse;\n        }\n        if(mouse_mode == 1){\n            if(iMouse.z != cv.z) nv = iMouse;\n        }\n    }\n    if(fc == ivec2(2,1)){\n        if(mouse_mode == 1){\n            vec4 old_mouse = texelFetch(iChannel0, ivec2(2,0), 0);\n            if(iMouse.z != old_mouse.z) nv = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    \n    fragColor = nv;\n    //fragColor = cv;\n    \n}\n","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979\n\n#define LIGHTSPEED 1.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvoid spectral_color(out float r, out float g, out float b, in float l) // RGB <0,1> <- lambda l <400,700> [nm]\n    {\n    float t;  r=0.0; g=0.0; b=0.0;\n         if ((l>=400.0)&&(l<410.0)) { t=(l-400.0)/(410.0-400.0); r=    +(0.33*t)-(0.20*t*t); }\n    else if ((l>=410.0)&&(l<475.0)) { t=(l-410.0)/(475.0-410.0); r=0.14         -(0.13*t*t); }\n    else if ((l>=545.0)&&(l<595.0)) { t=(l-545.0)/(595.0-545.0); r=    +(1.98*t)-(     t*t); }\n    else if ((l>=595.0)&&(l<650.0)) { t=(l-595.0)/(650.0-595.0); r=0.98+(0.06*t)-(0.40*t*t); }\n    else if ((l>=650.0)&&(l<700.0)) { t=(l-650.0)/(700.0-650.0); r=0.65-(0.84*t)+(0.20*t*t); }\n         if ((l>=415.0)&&(l<475.0)) { t=(l-415.0)/(475.0-415.0); g=             +(0.80*t*t); }\n    else if ((l>=475.0)&&(l<590.0)) { t=(l-475.0)/(590.0-475.0); g=0.8 +(0.76*t)-(0.80*t*t); }\n    else if ((l>=585.0)&&(l<639.0)) { t=(l-585.0)/(639.0-585.0); g=0.84-(0.84*t)           ; }\n         if ((l>=400.0)&&(l<475.0)) { t=(l-400.0)/(475.0-400.0); b=    +(2.20*t)-(1.50*t*t); }\n    else if ((l>=475.0)&&(l<560.0)) { t=(l-475.0)/(560.0-475.0); b=0.7 -(     t)+(0.30*t*t); }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec3 hue(float x){\n    x = fract(x)*6.0;\n    return vec3(\n    min(1.0,max(max(0.0,min(1.0,2.0-x)),x-4.0)),\n    max(0.0,min(min(x,1.0),4.0-x)),\n    min(1.0,min(max(0.0,x-2.0),6.0-x))\n    );\n}\n\nmat4 lorentz_boost(vec3 v, float c){\n    float v2 = dot(v,v);\n    float gamma = 1./sqrt(1.-v2/(c*c));\n    \n    return mat4(\n    1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n    (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n    (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c,\n    -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c, gamma\n    );\n}\n\nvec3 celerity_addition(vec3 u, vec3 v){\n    float beta_u = 1./sqrt(1.+dot(u,u)/(LIGHTSPEED*LIGHTSPEED));\n    float beta_v = 1./sqrt(1.+dot(v,v)/(LIGHTSPEED*LIGHTSPEED));\n\n    return u + v + u*(dot(u,v)*beta_u/((1.+beta_u)*LIGHTSPEED*LIGHTSPEED) + (1.-beta_v)/beta_v);\n}\n\n\n//I don't know how to simplify this\n\nvec3 celerity_gyrator(vec3 a, vec3 b, vec3 x){\n    return celerity_addition(-celerity_addition(a,b),celerity_addition(a,celerity_addition(b,x)));\n}\n//https://math.stackexchange.com/questions/725123/axis-and-angle-of-rotation-of-3x3-matrix\nvec4 mat3_axisangle(mat3 m){\n    mat3 s = m-transpose(m);\n    vec3 axis = vec3(m[2][1]-m[1][2],m[0][2]-m[2][0],m[1][0]-m[0][1]);\n    float trace = m[0][0]+m[1][1]+m[2][2];\n    float ang = .5*(trace - 1.);\n    if(abs(ang) >= 1. || length(axis) < 0.0001) return vec4(0.);\n    ang = acos(ang);\n    return vec4(-normalize(axis),ang);\n}\nvec4 celerity_gyrator_quaternion(vec3 a, vec3 b){\n\n    float gamma = 1./sqrt(1.-dot(a,a)/(LIGHTSPEED*LIGHTSPEED));\n    \n    //a *= 1./(sqrt(1.+dot(a,a)));\n    \n    \n    \n    \n    float av = (gamma*gamma/(1.+gamma))*length(cross(a,b));\n    \n    \n    //av = 0.;\n    //return vec4(normalize(cross(a,b))*sin(.5*av), cos(.5*av));\n    \n    vec4 z = mat3_axisangle(mat3(\n    celerity_gyrator(a,b,vec3(1.,0.,0.)),\n    celerity_gyrator(a,b,vec3(0.,1.,0.)),\n    celerity_gyrator(a,b,vec3(0.,0.,1.))\n    ));\n    return vec4(z.xyz*sin(.5*z.w),cos(.5*z.w));\n}\n\n\n\nvec4 ray_plane(vec3 ro, vec3 rd, vec4 plane){\n    float a = dot(plane.xyz, rd);\n    float b = dot(plane.xyz, ro) - plane.w;\n    return vec4(plane.xyz, -b/a);\n}\n\nvec4 ray_sphere(vec3 ro, vec3 rd, float r){\n    float b = -dot(ro, rd);\n    float c = dot(ro, ro) - r*r;\n    float d = b*b-c;\n    if(d < 0.0) return vec4(-1.0);\n    float h = sqrt(d);\n    float t = b < h ? b+h : b-h;\n    return vec4((ro+t*rd)/r, t);\n}\n\nvec4 ray_box(vec3 ro, vec3 rd, vec3 S){\n    vec3 c = -ro/rd;\n    vec3 d = S/abs(rd);\n    \n    vec3 N = c-d;\n    vec3 F = c+d;\n    \n    float tN = max(N.x, max(N.y, N.z));\n    float tF = min(F.x, min(F.y, F.z));\n    \n    if(tN > tF) return vec4(-1.0);\n    float t = tN > 0.0 ? tN : tF;\n    vec3 nrm = -sign(rd)*vec3(\n    N.x == tN ? 1.0 : 0.0,\n    N.y == tN ? 1.0 : 0.0,\n    N.z == tN ? 1.0 : 0.0\n    );\n    return vec4(nrm, t);\n}\n\nbool ray_boundbox(vec3 ro, vec3 rd, vec3 S){\n    vec3 c = -ro/rd;\n    vec3 d = S/abs(rd);\n    \n    vec3 N = c-d;\n    vec3 F = c+d;\n    \n    float tN = max(N.x, max(N.y, N.z));\n    float tF = min(F.x, min(F.y, F.z));\n    \n    return tN < tF && (tN > 0.0 || tF > 0.0);\n}\n\n\n\n\n\n\n\n//https://iquilezles.org/articles/intersectors/\nvec4 ray_cylinder( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( (oc+t*rd-ca*y/caca)/ra, t );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( ca*sign(y)/caca, t );\n    return vec4(-1.0); //no intersection\n}\n\n\n\n\n\n\n//https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\n//https://twistedpairdevelopment.wordpress.com/2013/02/11/rotating-a-vector-by-a-quaternion-in-glsl/\nvec4 qmul(vec4 q1, vec4 q2){\n\treturn vec4(\n\t\tq2.xyz * q1.w + q1.xyz * q2.w + cross(q1.xyz, q2.xyz),\n\t\tq1.w * q2.w - dot(q1.xyz, q2.xyz)\n\t);\n}\n\nvec3 rotate_vector(vec4 q, vec3 v){\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nvec4 axis_angle_to_quat(vec4 a){\n    return vec4(a.xyz*sin(a.w/2.0), cos(a.w/2.0));\n}\n\nvec4 quat_to_axis_angle(vec4 q){\n    vec3 axis = normalize(q.xyz);\n    float angle = acos(q.w)*2.0;\n    return vec4(axis, angle);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//http://cvrl.ioo.ucl.ac.uk/cmfs.htm\n\n\nconst vec3 CMF[95] = vec3[](\nvec3(0.000129900000,0.000003917000,0.000606100000),vec3(0.000232100000,0.000006965000,0.001086000000),vec3(0.000414900000,0.000012390000,0.001946000000),vec3(0.000741600000,0.000022020000,0.003486000000),vec3(0.001368000000,0.000039000000,0.006450001000),vec3(0.002236000000,0.000064000000,0.010549990000),vec3(0.004243000000,0.000120000000,0.020050010000),vec3(0.007650000000,0.000217000000,0.036210000000),vec3(0.014310000000,0.000396000000,0.067850010000),vec3(0.023190000000,0.000640000000,0.110200000000),vec3(0.043510000000,0.001210000000,0.207400000000),vec3(0.077630000000,0.002180000000,0.371300000000),vec3(0.134380000000,0.004000000000,0.645600000000),vec3(0.214770000000,0.007300000000,1.039050100000),vec3(0.283900000000,0.011600000000,1.385600000000),vec3(0.328500000000,0.016840000000,1.622960000000),vec3(0.348280000000,0.023000000000,1.747060000000),vec3(0.348060000000,0.029800000000,1.782600000000),vec3(0.336200000000,0.038000000000,1.772110000000),vec3(0.318700000000,0.048000000000,1.744100000000),vec3(0.290800000000,0.060000000000,1.669200000000),vec3(0.251100000000,0.073900000000,1.528100000000),vec3(0.195360000000,0.090980000000,1.287640000000),vec3(0.142100000000,0.112600000000,1.041900000000),vec3(0.095640000000,0.139020000000,0.812950100000),vec3(0.057950010000,0.169300000000,0.616200000000),vec3(0.032010000000,0.208020000000,0.465180000000),vec3(0.014700000000,0.258600000000,0.353300000000),vec3(0.004900000000,0.323000000000,0.272000000000),vec3(0.002400000000,0.407300000000,0.212300000000),vec3(0.009300000000,0.503000000000,0.158200000000),vec3(0.029100000000,0.608200000000,0.111700000000),vec3(0.063270000000,0.710000000000,0.078249990000),vec3(0.109600000000,0.793200000000,0.057250010000),vec3(0.165500000000,0.862000000000,0.042160000000),vec3(0.225749900000,0.914850100000,0.029840000000),vec3(0.290400000000,0.954000000000,0.020300000000),vec3(0.359700000000,0.980300000000,0.013400000000),vec3(0.433449900000,0.994950100000,0.008749999000),vec3(0.512050100000,1.000000000000,0.005749999000),vec3(0.594500000000,0.995000000000,0.003900000000),vec3(0.678400000000,0.978600000000,0.002749999000),vec3(0.762100000000,0.952000000000,0.002100000000),vec3(0.842500000000,0.915400000000,0.001800000000),vec3(0.916300000000,0.870000000000,0.001650001000),vec3(0.978600000000,0.816300000000,0.001400000000),vec3(1.026300000000,0.757000000000,0.001100000000),vec3(1.056700000000,0.694900000000,0.001000000000),vec3(1.062200000000,0.631000000000,0.000800000000),vec3(1.045600000000,0.566800000000,0.000600000000),vec3(1.002600000000,0.503000000000,0.000340000000),vec3(0.938400000000,0.441200000000,0.000240000000),vec3(0.854449900000,0.381000000000,0.000190000000),vec3(0.751400000000,0.321000000000,0.000100000000),vec3(0.642400000000,0.265000000000,0.000049999990),vec3(0.541900000000,0.217000000000,0.000030000000),vec3(0.447900000000,0.175000000000,0.000020000000),vec3(0.360800000000,0.138200000000,0.000010000000),vec3(0.283500000000,0.107000000000,0.000000000000),vec3(0.218700000000,0.081600000000,0.000000000000),vec3(0.164900000000,0.061000000000,0.000000000000),vec3(0.121200000000,0.044580000000,0.000000000000),vec3(0.087400000000,0.032000000000,0.000000000000),vec3(0.063600000000,0.023200000000,0.000000000000),vec3(0.046770000000,0.017000000000,0.000000000000),vec3(0.032900000000,0.011920000000,0.000000000000),vec3(0.022700000000,0.008210000000,0.000000000000),vec3(0.015840000000,0.005723000000,0.000000000000),vec3(0.011359160000,0.004102000000,0.000000000000),vec3(0.008110916000,0.002929000000,0.000000000000),vec3(0.005790346000,0.002091000000,0.000000000000),vec3(0.004109457000,0.001484000000,0.000000000000),vec3(0.002899327000,0.001047000000,0.000000000000),vec3(0.002049190000,0.000740000000,0.000000000000),vec3(0.001439971000,0.000520000000,0.000000000000),vec3(0.000999949300,0.000361100000,0.000000000000),vec3(0.000690078600,0.000249200000,0.000000000000),vec3(0.000476021300,0.000171900000,0.000000000000),vec3(0.000332301100,0.000120000000,0.000000000000),vec3(0.000234826100,0.000084800000,0.000000000000),vec3(0.000166150500,0.000060000000,0.000000000000),vec3(0.000117413000,0.000042400000,0.000000000000),vec3(0.000083075270,0.000030000000,0.000000000000),vec3(0.000058706520,0.000021200000,0.000000000000),vec3(0.000041509940,0.000014990000,0.000000000000),vec3(0.000029353260,0.000010600000,0.000000000000),vec3(0.000020673830,0.000007465700,0.000000000000),vec3(0.000014559770,0.000005257800,0.000000000000),vec3(0.000010253980,0.000003702900,0.000000000000),vec3(0.000007221456,0.000002607800,0.000000000000),vec3(0.000005085868,0.000001836600,0.000000000000),vec3(0.000003581652,0.000001293400,0.000000000000),vec3(0.000002522525,0.000000910930,0.000000000000),vec3(0.000001776509,0.000000641530,0.000000000000),vec3(0.000001251141,0.000000451810,0.000000000000)\n);\n\nvec3 wl_to_xyz(float lambda){\n    if(lambda < 360.0 || lambda > 830.0) return vec3(0.0);\n    \n    int i0 = int(floor((lambda-360.0)/5.0));\n    int i1 = i0+1;\n\n    float t = mod(lambda, 5.0)/5.0;\n    \n    return mix(CMF[i0], CMF[i1], t);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Prints numbers\n\n// Original version: https://www.shadertoy.com/view/4sBSWW\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Note that the values printed are not always accurate!\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n// Original version\nfloat PrintValue00(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// Improved version\n//\n// Most important change is dropping everything left of the decimal point ASAP \n// when printing the fractional digits. This is done to bring the magnitule down\n// for the following division and modulo.\n//\n// Another change is to replace the logarithm with a power-of-ten value \n// calculation that is needed later anyway.\n// This change is optional, either one works.\nfloat PrintValue(vec2 fragCoord, vec2 pixelCoord, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (fragCoord - pixelCoord) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"}]}