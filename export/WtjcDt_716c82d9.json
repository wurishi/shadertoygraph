{"ver":"0.1","info":{"id":"WtjcDt","date":"1595720308","viewed":617,"name":"trying to understand 3d rotation","username":"CoolerZ","description":"Originally made this to visualize 3d rotations.","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["3d","raymarching","rotation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nALSO SEE https://youtu.be/zc8b2Jo7mno\nGimbal lock is a problem that occurs when the rotation axes are dependent on each other.\nIf we use fixed rotation axes instead then we still have the problem that rotations are not commutative.\nThe order in which rotations are applied matters. See https://en.wikipedia.org/wiki/3D_rotation_group\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord-.5), 0).rgb;\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITERS 100\n#define EPSILON 0.001\n#define PERSISTENCE .95\n\nvec3 rot(vec3 point, vec3 axis, float angle)\n{\n    // based on https://suricrasia.online/demoscene/functions/#erot\n    // axis should be normalized, angle should be in radians\n    vec3 origin = dot(point, axis)*axis;\n    vec3 diff = point - origin;\n    vec3 z_axis = -axis;\n    vec3 x_axis = normalize(diff);\n    vec3 y_axis = normalize(cross(z_axis, x_axis));\n    float R = length(diff);\n    return origin + x_axis*R*cos(angle) + y_axis*R*sin(angle);\n}\n\nfloat sphere_d(vec3 p, float r)\n{\n    return length(p)-r;\n}\n\nfloat plane_d(vec3 p)\n{\n    return p.y;\n}\n\nfloat cylinder_x_d(vec3 p, float r)\n{\n    return length(p.yz)-r;\n}\nfloat cylinder_y_d(vec3 p, float r)\n{\n    return length(p.xz)-r;\n}\nfloat cylinder_z_d(vec3 p, float r)\n{\n    return length(p.xy)-r;\n}\n\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    // taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvec3 apply_rot(mat4 r, vec3 p)\n{\n    return (r*vec4(p, 1.)).xyz;\n}\n\nfloat scene_d(vec3 p)\n{\n    const float rad = 0.1;\n    float time = iTime;\n    vec3 sphere_pos = vec3(0., 0., 1.);\n    //mat4 rot_y = rotationMatrix(vec3(0.,1.,0.), -45.);\n    //mat4 rot_x = rotationMatrix(vec3(1.,0.,0.), 45.);\n    //mat4 rot_y = rotationMatrix(vec3(0.,1.,0.), -80.*iTime);\n    //mat4 rot_x = rotationMatrix(vec3(1.,0.,0.), -80.*iTime);\n    // 1. MAKE THE ROTATION MATRICES STATIC by uncommenting above.\n    // 2. MAKE CAMERA LOOK STRAIGHT DOWN THE Z AXIS by uncommenting stuff in the mainImage function.\n    // 3. SWITCH THESE 2 rotations to see that order in which the rotations are applied is important\n    //sphere_pos = apply_rot(rot_y, sphere_pos);\n    //sphere_pos = apply_rot(rot_x, sphere_pos);\n    sphere_pos = rot(sphere_pos, vec3(0.,1.,0.), radians(-80.*iTime));\n    sphere_pos = rot(sphere_pos, vec3(1.,0.,0.), radians(-80.*iTime));\n    float d = sphere_d(p-sphere_pos, 2.*rad);\n    d = min(d, plane_d(p-vec3(0.,-2.,0.)));\n    d = min(d, cylinder_x_d(p, rad));\n    d = min(d, cylinder_y_d(p, rad));\n    d = min(d, cylinder_z_d(p, rad));\n    return d;\n}\n\nvec3 get_normals(vec3 p)\n{\n    float x1 = scene_d(p+vec3(-EPSILON,0.,0.));\n    float x2 = scene_d(p+vec3( EPSILON,0.,0.));\n\n\tfloat y1 = scene_d(p+vec3(0.,-EPSILON,0.));\n    float y2 = scene_d(p+vec3(0., EPSILON,0.));\n\n    float z1 = scene_d(p+vec3(0.,0.,-EPSILON));\n    float z2 = scene_d(p+vec3(0.,0., EPSILON));\n\n    return normalize(vec3(x2-x1,y2-y1,z2-z1)/(2.*EPSILON));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    vec2 uv = (fragCoord-.5)/(iResolution.xy-1.);\n    uv = 2.*uv-1.;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //vec3 cam_pos = vec3(0.,0.,2.);\n    vec3 cam_pos = vec3(1., 2., 2.);\n    // vec3 cam_pos = vec3(2.*cos(time), 2., 2.*sin(time));\n    vec3 look_at = vec3(0.);\n    vec3 cam_dir = normalize(look_at - cam_pos);\n    vec3 world_up = vec3(0., 1., 0.);\n    vec3 cam_right = normalize(cross(cam_dir, world_up));\n    vec3 cam_up = normalize(cross(cam_right, cam_dir));\n    float focal_dist = 1.;\n    vec3 pixel_pos = cam_pos + focal_dist*cam_dir + uv.x*cam_right + uv.y*cam_up;\n\n    vec3 ray_o = pixel_pos;\n    vec3 ray_d = cam_dir; // orthographic\n    //vec3 ray_d = normalize(pixel_pos - cam_pos); // perspective\n    float dist_along_ray = 0., d = 0.;\n    vec3 light_pos_1 = vec3(0., 10., 10.);\n    vec3 light_col_1 = vec3(1.);\n    float light_brightness_1 = 10.;\n    vec3 light_pos_2 = vec3(0., 1., -10.);\n    // vec3 light_pos_2 = cam_pos;\n    vec3 light_col_2 = vec3(1.);\n    float light_brightness_2 = 2.;\n    vec3 hit_pos = ray_o + ray_d*dist_along_ray;\n    bool hit = false;\n\n    for(int i=0;i<MAX_ITERS;i++)\n    {\n        d = scene_d(ray_o + ray_d*dist_along_ray);\n        if(d < EPSILON)\n        {\n            hit_pos = ray_o + ray_d*dist_along_ray;\n            hit = true;\n            break;\n        }\n        dist_along_ray += d;\n    }\n\n    vec3 col = vec3(0.);\n    // vec3 col = vec3(0.,0.2,0.25);\n    if(hit)\n    {\n        // light 1\n        vec3 normals = get_normals(hit_pos);\n        vec3 light_dir = normalize(hit_pos - light_pos_1);\n        vec3 reflect_dir = reflect(light_dir, normals);\n        col += light_brightness_1*light_col_1*clamp(dot(-ray_d, reflect_dir), 0., 1.);\n        // light 2\n\t\tlight_dir = normalize(hit_pos - light_pos_2);\n        reflect_dir = reflect(light_dir, normals);\n        col += light_brightness_2*light_col_2*clamp(dot(-ray_d, reflect_dir), 0., 1.);\n\t\tcol = abs(get_normals(hit_pos));\n        col *= vec3(clamp(1./max(dist_along_ray, EPSILON), 0., 1.));\n        col = 1.-col;\n        // col *= clamp(1./max(dist_along_ray*dist_along_ray, EPSILON), 0., 1.);\n    }\n    col = mix(col, texelFetch(iChannel0, ivec2(fragCoord-.5), 0).rgb, PERSISTENCE);\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}