{"ver":"0.1","info":{"id":"ltcSRM","date":"1478652086","viewed":230,"name":"Perlin Landscape","username":"aszecsei","description":"Attempting to make a procedural desert landscape with sand effects.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["procedural","landscape"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int firstOctave = 3;\nconst int octaves = 8;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\nfloat map(vec3 p) {\n    vec3 q = fract(p) * 2.0 - 1.0;\n    q.y = p.y + texture(iChannel0, p.xz * 0.125).x * 0.25 + PerlinNoise2D(p.x * 0.05, p.z * 0.01) * 3.0;\n    \n    return q.y - 0.25;\n}\n\nfloat trace(vec3 o, vec3 r) {\n    float t = 0.0;\n    \n    for(int i=0; i<32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d * 0.5;\n    }\n    \n    return t;\n}\n\nfloat lerp(float a, float b, float t) {\n    return (1.0 - t) * a + (t * b);\n}\n\nvec3 lerp3(vec3 a, vec3 b, float t) {\n    return vec3(lerp(a.x, b.x, t), lerp(a.y, b.y, t), lerp(a.z, b.z, t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0));\n    \n    float the = iTime * 0.2;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    vec3 o = vec3(0, 1.0, iTime);\n    \n    float t = trace(o, r);\n    \n    float fog = 1.0 / (1.0 + t * t * 0.1);\n    \n    vec3 sandColor = vec3(0.761, 0.698, 0.502);\n    vec3 skyColor = vec3(0.529, 0.808, 0.98);\n    fragColor = vec4(lerp3(vec3(0), sandColor, fog),1.0);\n}","name":"Image","description":"","type":"image"}]}