{"ver":"0.1","info":{"id":"csKSRh","date":"1680711551","viewed":102,"name":"Aliased and anti-aliased cube","username":"HenroKriel","description":"On the left is an aliased cube, and on the right is a cube anti-aliased with color averaging.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["alias"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Intersection\n{\n    bool valid;\n    vec3 pos;\n    vec3 norm;\n};\n\nstruct Ray\n{\n    vec3 o;\n    vec3 d;\n};\n\nfloat sdBox(vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 gradBox(vec3 p, vec3 b) {\n    const float h = 0.001;\n    \n    float f = sdBox(p, b);\n    \n    vec3 x_input = p + vec3(h, 0, 0);\n    vec3 y_input = p + vec3(0, h, 0);\n    vec3 z_input = p + vec3(0, 0, h);\n    vec3 fplus = vec3(sdBox(x_input, b), sdBox(y_input, b), sdBox(z_input, b));\n    return (fplus - f)/h;\n}\n\nIntersection intersect(Ray ray)\n{\n    Intersection sect;\n    sect.valid = false;\n    \n    mat4 translate = mat4(1.0, 0.0, 0.0, 0.0,\n                          0.0, 1.0, 0.0, 0.0,\n                          0.0, 0.0, 1.0, 0.0,\n                          0.0, 0.0, 5.0, 1.0);\n    \n    mat4 rotateX = mat4(1.0, 0.0, 0.0, 0.0,\n                        0.0, cos(iTime), sin(iTime), 0.0,\n                        0.0, -sin(iTime), cos(iTime), 0.0,\n                        0.0, 0.0, 0.0, 1.0);\n                       \n    mat4 rotateY = mat4(cos(iTime), 0.0, -sin(iTime), 0.0,\n                        0.0, 1.0, 0.0, 0.0,\n                        sin(iTime), 0.0, cos(iTime), 0.0,\n                        0.0, 0.0, 0.0, 1.0); \n\n    mat4 rotateZ = mat4(cos(iTime), sin(iTime), 0.0, 0.0,\n                        -sin(iTime), cos(iTime), 0.0, 0.0,\n                        0.0, 0.0, 1.0, 0.0,\n                        0.0, 0.0, 0.0, 1.0);   \n\n    mat4 transform = translate*rotateX*rotateY*rotateZ;\n    \n    vec3 b = vec3(1.0);\n    \n    const float MAX_DIST = 100.0;\n    const float MIN_HIT_DIST = 0.01;\n    const int NUM_ITER = 32;\n    \n    vec4 o = inverse(transform)*vec4(ray.o, 1.0);\n    vec4 d = vec4(inverse(mat3(transform))*ray.d, 0.0);\n    \n    float total_dist = 0.0;\n\n    for(int i = 0; i < NUM_ITER && total_dist < MAX_DIST; i++)\n    {\n        vec4 p = o + d*total_dist;\n\n        float dist = sdBox(vec3(p), b);\n\n        if(abs(dist) < MIN_HIT_DIST)\n        {\n            sect.valid = true;\n            vec3 norm = gradBox(vec3(p), b);\n\n            sect.pos = vec3(transform*p);\n            sect.norm = (transpose(inverse(mat3(transform)))*norm);\n            sect.norm = normalize(sect.norm);\n            \n            break;\n        }\n        \n        //approach surface cautiously, so that it doesn't go inside shape.\n        //without it, you get weird shadows around the edges.\n        float alpha = 0.9;\n        total_dist += alpha*dist;\n    }\n    \n    return sect;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int NUM_BUCKETS = 100;\n    float bucketSize = iResolution.x/float(NUM_BUCKETS);\n    vec2 bucketIndex = floor(fragCoord/bucketSize);\n    vec2 discreteFragCoord = bucketIndex*bucketSize;\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 centerCoord = discreteFragCoord - iResolution.xy/vec2(2.0);\n    vec2 uv = vec2(2.0)*centerCoord/iResolution.x;\n    \n    vec3 eye = vec3(0.0, 0.0, -1.0);\n    vec3 lightPos = vec3(0.0, 0.0, 0.0);\n    \n    //background\n    fragColor = mix(vec4(0.0, 0.0, 1.0, 1.0), vec4(0.0, 1.0, 1.0, 1.0), fragCoord.y/iResolution.y);\n    \n    //left cube\n    if(fragCoord.x < iResolution.x/2.0)\n    {\n        uv.x += 0.5;\n        \n        Ray ray;\n        ray.o = eye;\n        ray.d = vec3(uv, 0.0) - eye;\n\n        Intersection sect = intersect(ray);\n\n        if(sect.valid)\n        {\n            vec3 color = vec3(0.5, 0.5, 0.5);\n            vec3 L = normalize(lightPos-sect.pos);\n            fragColor = vec4(dot(sect.norm, L)*color, 1.0);\n        }\n    }\n    \n    //right cube\n    else\n    {\n        uv.x -= 0.5;\n        \n        const int RAY_SQ_LEN = 2;\n        const int NUM_RAYS = RAY_SQ_LEN*RAY_SQ_LEN;\n        \n        //size of pixel in uv space\n        float uvBucketSize = 2.0/float(NUM_BUCKETS);\n        //evenly spaces rays around a pixel.\n        float offsetSize = 1.0/float(RAY_SQ_LEN + 1)*uvBucketSize;\n        \n        vec3 colorSum = vec3(0.0);\n        \n        for(int i = 0; i < NUM_RAYS; i++)\n        {\n            //index like a 2d array\n            int rayI = i % RAY_SQ_LEN + 1;\n            int rayJ = i / RAY_SQ_LEN + 1;\n            vec2 offset = vec2(float(rayI)*offsetSize, float(rayJ)*offsetSize);\n            //center it\n            offset -= uvBucketSize/2.0;\n\n            Ray ray;\n            ray.o = eye;\n            ray.d = vec3(uv + offset, 0.0) - eye;\n            \n            Intersection sect = intersect(ray);\n            \n            vec3 color = vec3(fragColor);\n\n            if(sect.valid)\n            {\n                color = vec3(0.5, 0.5, 0.5);\n                vec3 L = normalize(lightPos-sect.pos);\n                color = dot(sect.norm, L)*color;\n            }\n\n            colorSum += color;\n        }\n        \n        fragColor = vec4(colorSum/float(NUM_RAYS), 1.0);\n    }\n    \n}","name":"Image","description":"","type":"image"}]}