{"ver":"0.1","info":{"id":"MtS3R3","date":"1430779879","viewed":186,"name":"extruded sphere intersections","username":"jonbro","description":"ideas cribbed from\nhttps://www.shadertoy.com/view/4slGzn\nhttp://i.imgur.com/t0rxWqH.jpg\nhttps://www.shadertoy.com/view/Xds3zN","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// intersect\nfloat opI( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n// add\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n// subtract\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoxRepeat(vec3 p, vec3 b, vec3 c){\n    vec3 q = mod(p,c)-0.5*c;\n    return sdBox( q, b );\n}\nfloat sdRotatedBoxRepeat( vec3 p, vec3 b, vec3 c, mat4 m )\n{\n    vec3 q = (vec4(p.x, p.y, p.z, 1.0)*m).xyz;\n    return sdBoxRepeat(q, b, c);\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat sdSphereRepeat(vec3 p, float s, vec3 c){\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q, s );\n}\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\n// the scene map\nvec2 map( in vec3 pos )\n{\n    mat4 rotMatrix = setRotation(sin(0.001*iTime),0.0,sin(0.004*iTime));\n    vec2 res = vec2(opI(\n\t\t\t\t\t        sdSphere(pos-vec3( 0.0,0.0, 0.0), 1.47),\n                        \tsdRotatedBoxRepeat(pos-vec3(iTime*0.015, iTime*0.025, iTime*0.035), vec3(0.31, 0.21, 0.21), vec3(.8, .5, .45), rotMatrix )\n                   ));\n    rotMatrix = setRotation(sin(0.003*iTime),0.0,sin(0.004*iTime));\n    res = opU(res, vec2(opI(\n\t\t\t\t\t        sdSphere(pos-vec3( 0.0,0.0, 0.0), 1.5 ),\n                        \tsdRotatedBoxRepeat(pos-vec3(-iTime*0.016, iTime*0.021, iTime*0.05), vec3(0.11, (sin(iTime)+1.0)*0.5*0.21, 0.21), vec3(.42, .5, .45), rotMatrix )\n                   )));\n    return res;\n}\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n// cast the ray into the scene, take into account time and mouse position\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<50; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.8, 0.9, 1.0);\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n    \tcol = 0.45 + 0.3*sin(nor*(m-1.0) );\n    }\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = vec3( -0.5+3.2*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 3.2*sin(0.1*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.5, -0.4, 0.5 );\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.5) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}","name":"","description":"","type":"image"}]}