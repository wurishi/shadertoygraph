{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// IÃ±igo Quilez's noise functions\nfloat hash(float n)\n{\n  return fract(cos(n) * 41415.92653);\n}\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nmat3 m = mat3( 0.00,  1.60,  1.20, \n\t\t\t  -1.60,  0.72, -0.96, \n\t\t\t  -1.20, -0.96,  2.28 );\nfloat fbm( vec3 p ) // experimented with and kind of modified\n{\n  float f = 0.5000 * noise( p ); p = m * p * 0.72;\n  f += 0.2500 * noise( p ); p = m * p * 0.73;\n  f += 0.1250 * noise( p ); p = m * p * 0.74;\n  f += 0.0625 * noise( p ); p = m * p * 0.75; \n  f += 0.03125 * noise( p ); p = m * p;// * 0.76;\n  //f += 0.015625 * noise( p );// p = m * p;\n  //f += 0.0078125 * noise( p ); \t\n  return f;\n}\n\n// scene stuff\nfloat objFloor(in vec3 p, in float height) // terrain's just a noisy floor\n{\n\treturn p.y + height * fbm(vec3(p.xz, 10));\n}\nvec2 scene(in vec3 p)\n{\n\t#define FLOOR_HEIGHT 2.5\n\tvec2 floorPlane = vec2(objFloor(p, FLOOR_HEIGHT),\n\t\t\t\t\t\t   1.0);\n\treturn floorPlane;\n}\n\n// raymarching stuff\nvec3 calcNormal(in vec3 p)\n{\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\t\n\tvec3 n;\n\tn.x = scene(p + e.xyy).x - scene(p - e.xyy).x;\n\tn.y = scene(p + e.yxy).x - scene(p - e.yxy).x;\n\tn.z = scene(p + e.yyx).x - scene(p - e.yyx).x;\n\t\n\treturn normalize(n);\n}\n\n#define MAX_STEPS 64\n#define MAX_DEPTH 24.0\nvec2 intersect(in vec3 origin, in vec3 direction)\n{\n\tfloat rayLength = 0.0;\n\tvec2 hit = vec2(1.);\n\tfor (int i = 0; i < MAX_STEPS; ++i)\n\t{\n\t\tif (hit.x < 0.001 || rayLength > MAX_DEPTH)\n\t\t\tbreak;\n\t\t\n\t\thit = scene(origin + direction * rayLength);\n\t\t \n\t\t// increment by a slightly reduced length to lessen wavy artifacts\n\t\trayLength += hit.x * 0.6;\n\t}\n\t\t\n\treturn vec2(rayLength, rayLength > MAX_DEPTH ? \n\t\t\t\t\t\t   0. : hit.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// setup space\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = (uv * 2.0 - 1.0); p.x *= iResolution.x / iResolution.y;\n\t\n\t// setup camera\n\t#define SPEED_SCALE 0.125\n\tvec3 origin = vec3(3. * cos(SPEED_SCALE * iTime),\n\t\t\t\t\t   1,\n\t\t\t\t\t   2. * sin(SPEED_SCALE * iTime));\n\tvec3 target = vec3(0,0,0);\n\t\n\t// camera direction\n\tvec3 direction = normalize(target - origin);\n\t// right\n\tvec3 right = normalize(cross(direction, vec3(0,1,0)));\n\t// up vector\n\tvec3 up = normalize(cross(right, direction));\n\t// ray direction\n\tvec3 rayDirection = normalize(p.x * right + p.y * up + 1.5 * direction);\n\t\n\t// shade scene\n\tvec3 color = mix(vec3(32./255.), //background\n\t\t\t\t\tvec3(225./255.),\n\t\t\t\t\tuv.y);\n\t// x is the proper distance to the intersection point, y is the material\n\tvec2 result = intersect(origin, rayDirection);\n\t\n\tif (result.y > 0.5)\n\t{\n\t\tvec3 position = origin + rayDirection * result.x;\n\t\tvec3 normal = calcNormal(position);\n\t\tvec3 light = normalize(vec3(0., 3., -1.));\n\t\t\n\t\tcolor = vec3(fbm(vec3(position.xz, 10))) /*\n\t\t\t\t max(0., dot(normal, light))*/;\n\t}\n\t\n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dfSW7","date":"1401986133","viewed":633,"name":"Foggy Terrain","username":"andrewsantamaria","description":"The title says it all.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["procedural","terrain"],"hasliked":0,"parentid":"","parentname":""}}