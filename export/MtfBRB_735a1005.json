{"ver":"0.1","info":{"id":"MtfBRB","date":"1512259818","viewed":985,"name":"RGB Colorspace Conversion","username":"Tynach","description":"Converts images encoded for different TV standards.\n\nAlso manually implements bilinear and bicubic texture filtering so that it can be done in linear light. Uses bicubic by default.\n\nThe left half is untouched. The right half is converted.","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["rgb","gamma","linear","xyz","colorspaces","colorspace","bilinear","srgb","whitepoint","ntsc","primaries","smpte","240m","smptec","ebu","trc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**************************************************************************\n * Scroll to the bottom to change the parameters used to draw the diagram *\n **************************************************************************/\n\nprecision highp float;\n\n\n/*\n * Structures\n */\n\n// Parameters for transfer characteristics (gamma curves)\nstruct transfer {\n\t// Exponent used to linearize the signal\n\tfloat power;\n\n\t// Offset from 0.0 for the exponential curve\n\tfloat off;\n\n\t// Slope of linear segment near 0\n\tfloat slope;\n\n\t// Values below this are divided by slope during linearization\n\tfloat cutoffToLinear;\n\n\t// Values below this are multiplied by slope during gamma correction\n\tfloat cutoffToGamma;\n\n\t// Gamma-corrected values should be in the range 16-235\n\tbool tvRange;\n};\n\n// Parameters for a colorspace\nstruct rgb_space {\n\t// Chromaticity coordinates (xyz) for Red, Green, and Blue primaries\n\tmat3 primaries;\n\n\t// Chromaticity coordinates (xyz) for white point\n\tvec3 whitePoint;\n\n\t// Linearization and gamma correction parameters\n\ttransfer trc;\n};\n\n\n/*\n * Preprocessor 'functions' that help build colorspaces as constants\n */\n\n// Turns 6 chromaticity coordinates into a 3x3 matrix\n#define Primaries(rx, ry, gx, gy, bx, by)\\\n\tmat3(\\\n\t\t(rx), (ry), 1.0 - (rx) - (ry),\\\n\t\t(gx), (gy), 1.0 - (gx) - (gy),\\\n\t\t(bx), (by), 1.0 - (bx) - (by))\n\n// Creates a whitepoint's xyz chromaticity coordinates from the given xy coordinates\n#define White(x, y)\\\n\tvec3((x), (y), 1.0 - (x) - (y))/(y)\n\n// Creates a scaling matrix using a vec3 to set the xyz scalars\n#define diag(v)\\\n\tmat3(\\\n\t\t(v).x, 0.0, 0.0,\\\n\t\t0.0, (v).y, 0.0,\\\n\t\t0.0, 0.0, (v).z)\n\n// Creates a conversion matrix that turns RGB colors into XYZ colors\n#define rgbToXyz(space)\\\n\tspace.primaries*diag(inverse((space).primaries)*(space).whitePoint)\n\n// Creates a conversion matrix that turns XYZ colors into RGB colors\n#define xyzToRgb(space)\\\n\tinverse(rgbToXyz(space))\n\n// Creates a conversion matrix converts linear RGB colors from one colorspace to another\n#define conversionMatrix(f, t)\\\n\txyzToRgb(t)*rgbToXyz(f)\n\n\n/*\n * Chromaticities for RGB primaries\n */\n\n// Original 1953 NTSC primaries\nconst mat3 primariesNtsc = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.14, 0.08\n);\n\n// Never-popular and antiquated 'HDTV' primaries based mostly on 1953 NTSC\nconst mat3 primaries240m = Primaries(\n\t0.67, 0.33,\n\t0.21, 0.71,\n\t0.15, 0.06\n);\n\n// European Broadcasting Union primaries for SDTV and Rec. 601 (625 lines)\nconst mat3 primariesEbu = Primaries(\n\t0.64, 0.33,\n\t0.29, 0.6,\n\t0.15, 0.06\n);\n\n// P22 Phosphor primaries (allegedly; only found one source)\n// Used by older versions of SMPTE-C, before specific chromaticities were given\nconst mat3 primariesP22 = Primaries(\n\t0.61, 0.342,\n\t0.298, 0.588,\n\t0.151, 0.064\n);\n\n// Modern day SMPTE-C primaries, used in modern NTSC and Rec. 601 (525 lines)\nconst mat3 primariesSmpteC = Primaries(\n\t0.63, 0.34,\n\t0.31, 0.595,\n\t0.155, 0.07\n);\n\n// Alleged primaries for old Sony TVs with a very blue whitepoint\nconst mat3 primariesSony = Primaries(\n\t0.625, 0.34,\n\t0.28, 0.595,\n\t0.155, 0.07\n);\n\n// Rec. 709 (HDTV) and sRGB primaries\nconst mat3 primaries709 = Primaries(\n\t0.64, 0.33,\n\t0.3, 0.6,\n\t0.15, 0.06\n);\n\n// Rec. 2020 UHDTV primaries\nconst mat3 primaries2020 = Primaries(\n\t0.708, 0.292,\n\t0.17, 0.797,\n\t0.131, 0.046\n);\n\n// Approximate Google Pixel primaries\nconst mat3 primariesPixel = Primaries(\n\t0.66, 0.34,\n\t0.228, 0.719,\n\t0.144, 0.04\n);\n\n\n/*\n * Chromaticities for white points\n */\n\n// Standard Illuminant C. White point for the original 1953 NTSC color system\nconst vec3 whiteC = White(0.310063, 0.316158);\n\n// Standard illuminant E (also known as the 'equal energy' white point)\nconst vec3 whiteE = vec3(1.0);\n\n// Alleged whitepoint to use with the P22 phosphors (D65 might be more proper)\nconst vec3 whiteP22 = White(0.313, 0.329);\n\n// Standard illuminant D65. Note that there are more digits here than specified\n// in either sRGB or Rec 709, so in some cases results may differ from other\n// software. Color temperature is roughly 6504 K (originally 6500K, but complex\n// science stuff made them realize that was innaccurate)\nconst vec3 whiteD65 = White(0.312713, 0.329016);\n\n// Standard illuminant D50. Just included for the sake of including it. Content\n// for Rec. 709 and sRGB is recommended to be produced using a D50 whitepoint.\n// For the same reason as D65, the color temperature is 5003 K instead of 5000 K\nconst vec3 whiteD50 = White(0.34567, 0.35850);\n\n// Very blue white point for old Sony televisions. Color temperature of 9300 K.\n// Use with the 'primariesSony' RGB primaries defined above\nconst vec3 whiteSony = White(0.283, 0.298);\n\n// Approximate Google Pixel white point\n//const vec3 whitePixel = white(0.299, 0.324);\nconst vec3 whitePixel = White(0.312, 0.334);\n\n\n/*\n * Gamma curve parameters\n */\n\n// Gamma of 2.2; not linear near 0. Was defined abstractly to be used by early\n// NTSC systems, before SMPTE 170M was modified to specify a more exact curve\nconst transfer gam22 = transfer(2.2, 0.0, 1.0, 0.0, 0.0, true);\n\n// Gamma of 2.2; not linear near 0 and full range. Commonly used with some\n// computer monitors, including all Adobe RGB monitors\nconst transfer gam22Pc = transfer(2.2, 0.0, 1.0, 0.0, 0.0, false);\n\n// Gamma of 2.4; not linear near 0. Seems a popular choice among some people\n// online, so I included it. I don't think any standard uses this\nconst transfer gam24 = transfer(2.4, 0.0, 1.0, 0.0, 0.0, true);\n\n// Gamma of 2.5; not linear near 0. Approximately what old Sony TVs used\nconst transfer gam25 = transfer(2.5, 0.0, 1.0, 0.0, 0.0, true);\n\n// Gamma of 2.8; not linear near 0. Loosely defined gamma for European SDTV\nconst transfer gam28 = transfer(2.8, 0.0, 1.0, 0.0, 0.0, true);\n\n// Modern SMPTE 170M, as well as Rec. 601, Rec. 709, and a rough approximation\n// for Rec. 2020 content as well. Do not use with Rec. 2020 if you work with\n// high bit depths!\nconst transfer gam170m = transfer(1.0/0.45, 0.099, 4.5, 0.0812, 0.018, true);\n\n// Gamma for sRGB. Besides being full-range (0-255 values), this is the only\n// difference between sRGB and Rec. 709.\nconst transfer gamSrgb = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308, false);\n\n// This is sRGB's gamma, but set to TV value ranges (16-235)\nconst transfer gamSrgbTv = transfer(2.4, 0.055, 12.92, 0.04045, 0.0031308, true);\n\n\n/*\n * RGB Colorspaces\n */\n\n// Original 1953 NTSC\nconst rgb_space Ntsc = rgb_space(primariesNtsc, whiteC, gam22);\n\n// Mostly unused and early HDTV standard (SMPTE 240M)\nconst rgb_space Smpte240m = rgb_space(primaries240m, whiteD65, gam22);\n\n// European Broadcasting Union SDTV\nconst rgb_space Ebu = rgb_space(primariesEbu, whiteD65, gam28);\n\n// Original, imprecise colorspace for NTSC after 1987 (probably incorrect)\nconst rgb_space SmpteC = rgb_space(primariesP22, whiteD65, gam22);\n\n// Modern SMPTE \"C\" colorimetry\nconst rgb_space Smpte170m = rgb_space(primariesSmpteC, whiteD65, gam170m);\n\n// Old Sony displays using high temperature white point\nconst rgb_space Sony = rgb_space(primariesSony, whiteSony, gam25);\n\n// Rec. 709 (HDTV)\nconst rgb_space Rec709 = rgb_space(primaries709, whiteD65, gam170m);\n\n// sRGB (mostly the same as Rec. 709, but different gamma and full range values)\nconst rgb_space Srgb = rgb_space(primaries709, whiteD65, gamSrgb);\n\n// Same as sRGB, but with limited range values (16-235)\nconst rgb_space SrgbTv = rgb_space(primaries709, whiteD65, gamSrgbTv);\n\n// Rec. 2020\nconst rgb_space Rec2020 = rgb_space(primaries2020, whiteD65, gam170m);\n\n// Approximate Google Pixel colorspace\nconst rgb_space Pixel = rgb_space(primariesPixel, whitePixel, gam22Pc);\n\n\n/*\n * Filtering functions\n */\n\n// Catmull-Rom Interpolation\nvec4 cubic(vec4 color0, vec4 color1, vec4 color2, vec4 color3, float interp)\n{\n\tvec4 A0 = mix(color0, color1, interp+1.0);\n\tvec4 A1 = mix(color1, color2, interp);\n\tvec4 A2 = mix(color2, color3, interp-1.0);\n\n\tvec4 B0 = mix(A0, A1, 0.5*interp + 0.5);\n\tvec4 B1 = mix(A1, A2, 0.5*interp);\n\n\treturn mix(B0, B1, interp);\n}\n\n\n/*\n * Conversion Functions\n */\n\n// Converts RGB colors to a linear light scale\nvec4 toLinear(vec4 color, const transfer trc)\n{\n\tif (trc.tvRange) {\n\t\tcolor = color*85.0/73.0 - 16.0/219.0;\n\t}\n\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToLinear));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToLinear));\n\tvec4 higher = pow((color + trc.off)/(1.0 + trc.off), vec4(trc.power));\n\tvec4 lower = color/trc.slope;\n\tvec4 neg = -1.0*pow((color - trc.off)/(-1.0 - trc.off), vec4(trc.power));\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\treturn color;\n}\n\n// Gamma-corrects RGB colors to be sent to a display\nvec4 toGamma(vec4 color, const transfer trc)\n{\n\tbvec4 cutoff = lessThan(color, vec4(trc.cutoffToGamma));\n\tbvec4 negCutoff = lessThanEqual(color, vec4(-1.0*trc.cutoffToGamma));\n\tvec4 higher = (1.0 + trc.off)*pow(color, vec4(1.0/trc.power)) - trc.off;\n\tvec4 lower = color*trc.slope;\n\tvec4 neg = (-1.0 - trc.off)*pow(-1.0*color, vec4(1.0/trc.power)) + trc.off;\n\n\tcolor = mix(higher, lower, cutoff);\n\tcolor = mix(color, neg, negCutoff);\n\n\tif (trc.tvRange) {\n\t\tcolor = color*73.0/85.0 + 16.0/255.0;\n\t}\n\n\treturn color;\n}\n\n// Scales a color to the closest in-gamut representation of that color\nvec4 gamutScale(vec4 color, float luma)\n{\n\tfloat low = min(color.r, min(color.g, min(color.b, 0.0)));\n\tfloat high = max(color.r, max(color.g, max(color.b, 1.0)));\n\n\tfloat lowScale = low/(low - luma);\n\tfloat highScale = max((high - 1.0)/(high - luma), 0.0);\n\tfloat scale = max(lowScale, highScale);\n\tcolor.rgb += scale*(luma - color.rgb);\n\n\treturn color;\n}\n\n// Converts from xy to RGB\nvec4 convert(vec4 color, rgb_space from, rgb_space to)\n{\n\tcolor.xyz = rgbToXyz(from)*color.rgb;\n\tfloat luma = color.y;\n\n\tcolor.rgb = xyzToRgb(to)*color.rgb;\n\tcolor = gamutScale(color, luma);\n\n\treturn color;\n}\n\n// Sample a texture's linear light values\n#define texLinear(tex, offset, trc) \\\ntoLinear(texelFetch(tex, ivec2(texCoord + offset), 0), trc)\n\n\n// Convert half of the image\nvoid mainImage(out vec4 color, in vec2 fragCoord)\n{\n\t// Change these to change what colorspace is being converted from/to\n\trgb_space from = rgb_space(primariesSony, whiteSony, gam25);\n\trgb_space to = rgb_space(primaries709, whiteD65, gamSrgbTv);\n\n\tivec2 texRes = textureSize(iChannel0, 0);\n\tvec2 texCoord = fragCoord;\n\tfloat scale = float(texRes.x)/iResolution.x;\n\ttexCoord *= scale;\n\ttexCoord -= 0.5;\n\n\tbool right = bool(int(round(texCoord.x/float(texRes.x))));\n\n\tif (!right) {\n\t\tfrom = Srgb;\n\t\tto = from;\n\t}\n\n\t// Bicubic filtering\n\tvec4 color0 = texLinear(iChannel0, vec2(-1, -1), from.trc);\n\tvec4 color1 = texLinear(iChannel0, vec2(0, -1), from.trc);\n\tvec4 color2 = texLinear(iChannel0, vec2(1, -1), from.trc);\n\tvec4 color3 = texLinear(iChannel0, vec2(2, -1), from.trc);\n\n\tvec4 color4 = texLinear(iChannel0, vec2(-1, 0), from.trc);\n\tvec4 color5 = texLinear(iChannel0, vec2(0, 0), from.trc);\n\tvec4 color6 = texLinear(iChannel0, vec2(1, 0), from.trc);\n\tvec4 color7 = texLinear(iChannel0, vec2(2, 0), from.trc);\n\n\tvec4 color8 = texLinear(iChannel0, vec2(-1, 1), from.trc);\n\tvec4 color9 = texLinear(iChannel0, vec2(0, 1), from.trc);\n\tvec4 colorA = texLinear(iChannel0, vec2(1, 1), from.trc);\n\tvec4 colorB = texLinear(iChannel0, vec2(2, 1), from.trc);\n\n\tvec4 colorC = texLinear(iChannel0, vec2(-1, 2), from.trc);\n\tvec4 colorD = texLinear(iChannel0, vec2(0, 2), from.trc);\n\tvec4 colorE = texLinear(iChannel0, vec2(1, 2), from.trc);\n\tvec4 colorF = texLinear(iChannel0, vec2(2, 2), from.trc);\n\n\tvec4 row0 = cubic(color0, color1, color2, color3, fract(texCoord.x));\n\tvec4 row1 = cubic(color4, color5, color6, color7, fract(texCoord.x));\n\tvec4 row2 = cubic(color8, color9, colorA, colorB, fract(texCoord.x));\n\tvec4 row3 = cubic(colorC, colorD, colorE, colorF, fract(texCoord.x));\n\n\tcolor = cubic(row0, row1, row2, row3, fract(texCoord.y));/**/\n\n\t// Bilinear filtering\n\t/*vec2 loCoord = floor(texCoord) + 0.5;\n\tvec2 hiCoord = loCoord + 1.0;\n\n\tvec4 color1 = texLinear(iChannel0, vec2(0, 1), from.trc);\n\tvec4 color2 = texLinear(iChannel0, vec2(1, 1), from.trc);\n\tvec4 color3 = texLinear(iChannel0, vec2(0, 0), from.trc);\n\tvec4 color4 = texLinear(iChannel0, vec2(1, 0), from.trc);\n\n\tvec2 interp = fract(texCoord);\n\n\tvec4 interpBot = mix(color1, color2, interp.x);\n\tvec4 interpTop = mix(color3, color4, interp.x);\n\n\tcolor = mix(interpTop, interpBot, interp.y);/**/\n\n\t// Standard filtering\n\t/*color = toLinear(texture(iChannel0, (texCoord + 0.5)/vec2(texRes)), from.trc);/**/\n\n\tcolor = convert(color, from, to);\n\tcolor = toGamma(color, to.trc);\n}","name":"Image","description":"","type":"image"}]}