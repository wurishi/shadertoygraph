{"ver":"0.1","info":{"id":"7lK3Rc","date":"1707334638","viewed":138,"name":"Angle-breaking Julia Set","username":"16384","description":"mandelbrot/julia set, but instead of breaking out of the loop when the magnitude is large enough, we do so when theta is within a certain range","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["fractal","juliaset","mandelbrotset","fraktal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 c, vec2 f )\n{\n    c = texture(iChannel0, f/iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float PI = 3.14159265358979323;\n\nconst int maxIterations = 1000;\nconst bool julia = true;\nconst vec2 add = vec2(-1.9, -1.0);\nconst vec2 mult = vec2(1.0, 1.0);\nconst float colorPower = 0.5;\n\n\n//Found this little random function somewhere, don't remember where\nfloat rand(float co) { return fract(sin(co*(91.3458)) * 47453.5453); }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 z0 = (fragCoord + vec2(rand(1.0 + fragCoord.x + fragCoord.y + iTime), rand(5.23 + fragCoord.x + fragCoord.y + float(iFrame)))) / iResolution.y * 2.0;\n    vec2 a = iMouse.xy / iResolution.y * 2.0; //for Julia set, mouse as a\n    \n    z0 += add;\n    a += add;\n    \n    z0 *= mult;\n    a *= mult;\n    \n    vec2 z = z0;\n    int iterations1 = maxIterations;\n    int iterations2 = maxIterations;\n    float smallestAngle = PI;\n    \n    for(int i = 0; i < maxIterations; i++) {\n        if (julia) {\n            z = vec2(z.x * z.x - z.y * z.y + a.x, 2.0 * z.x * z.y + a.y);\n        } else {\n            z = vec2(z.x * z.x - z.y * z.y + z0.x, 2.0 * z.x * z.y + z0.y);\n        }\n        \n        \n        float theta = atan(z.y/z.x);\n        theta *= theta < 0.0 ? -1.0 : 1.0;\n        \n        float distFromAxis = min(theta, abs(2.0 * PI - theta));\n        if (distFromAxis < smallestAngle) smallestAngle = distFromAxis;\n            \n        //if (z.x*z.x+z.y*z.y > 4.0) {\n        if (theta < PI / 16. && iterations1 == maxIterations) {\n            iterations1 = i;\n        }\n        if (fract(theta * (1000. / PI)) < 0.005 && iterations2 == maxIterations) {\n            iterations2 = i;\n        }\n        \n        if (iterations1 != maxIterations && iterations2 != maxIterations) break;\n    }\n    \n    vec3 color = vec3(sqrt(smallestAngle / PI), 0.2 * float(iterations1) / float(maxIterations), 0.5 * sqrt(float(iterations2) / float(maxIterations)));\n    \n    color = vec3(pow(color.r, colorPower), pow(color.g, colorPower), pow(color.b, colorPower));\n    \n    vec4 lastFrameColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (lastFrameColor.a == 0.0f || iMouse.z > 0.0) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    color = mix(lastFrameColor.rgb, color, blend);\n    \n    fragColor = vec4(color, blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}