{"ver":"0.1","info":{"id":"NlKSDW","date":"1640705590","viewed":191,"name":"Tired flames","username":"panna_pudi","description":"It's my first try to work with volumetrics. I'm not happy with the result I have right now, but fixes only after some rest.\nI used this shader as reference https://www.shadertoy.com/view/4dGyRh","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["fire","volumetrics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Box { vec3 o, size; };\n\nconst float PI = acos(-1.);\nconst float TAU = 2. * PI;\nconst float FAR = 100.;\n\nfloat tri(in float x) { return abs(fract(x) - 0.5) - .25; }\nfloat trids(in vec3 p) { return max(tri(p.z), min(tri(p.x), tri(p.y))); }\nfloat tri2(in float x) { return abs(fract(x) - .5); }\nvec3 tri3(in vec3 p) {\n    return vec3(tri(p.z + tri(p.y * 1.0)), tri(p.z + tri(p.x * 1.05)),\n                tri(p.y + tri(p.x * 1.1)));\n}\n\nmat2 m2 = mat2(0.970, 0.242, -0.242, 0.970);\nfloat triNoise3d(in vec3 p, in float spd, in float time) {\n    float z = 1.45;\n    float rz = 0.;\n    vec3 bp = p;\n    for (float i = 0.; i < 4.; i++) {\n        vec3 dg = tri3(bp);\n        p += (dg + time * spd + 10.1);\n        bp *= 1.65;\n        z *= 1.5;\n        p *= .9;\n        p.xz*= m2;\n\n        rz += (tri2(p.z + tri2(p.x + tri2(p.y)))) / z;\n        bp += 0.9;\n    }\n    return rz;\n}\n\nbool boxIntersection(in vec3 ro, in vec3 rd, Box box, out vec2 dist) {\n    ro -= box.o;\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * box.size;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    if (tN > tF || tF < 0.0) return false;\n    dist = vec2(tN, tF);\n    return true;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sd_round_cone(vec3 p, float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if (k < 0.0) return length(q) - r1;\n    if (k > a * h) return length(q - vec2(0.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat sd_box(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nmat3 get_cam(vec3 eye, vec3 at) {\n    vec3 zaxis= normalize(at - eye);\n    vec3 xaxis = normalize(cross(zaxis, vec3(0., 1., 0.)));\n    vec3 yaxis = cross(xaxis, zaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\n// https://www.shadertoy.com/view/7sKGzR\nvec2 polarSmoothFold(vec2 p, float n, float k) {\n    n *= 0.5;\n    float a = asin(sin(atan(p.y, p.x) * n) / (k + 1.0)) / n;\n    return vec2(sin(a), cos(a)) * length(p);\n}\n\nfloat transform(inout vec3 p, float t) {\n    float off = 1.5;// 1. + 1. * (cos(1.75 * t));\n    float n = 5.;\n    p.xy *= rot(t * 0.75);\n    float id = floor((atan(p.y, p.x) / PI / 2. + 0.5) * n) / n;\n    p.z -= 0.3 * cos(id * 14. + iTime * 2.);\n    p.xy = polarSmoothFold(p.xy, n, .4);\n    p -= vec3(0., off, 0.);\n    return id;\n}\n\nfloat scene(vec3 p) {\n    float id = transform(p, iTime);\n    return length(p) - 0.40;\n}\n\nvec3 normal(vec3 p) {\n    mat3 k = mat3(p, p, p) - mat3(0.001);\n    return normalize(vec3(scene(p)) -\n                     vec3(scene(k[0]), scene(k[1]), scene(k[2])));\n}\n\nfloat march(vec3 ro, vec3 rd, float t_min, float t_max) {\n    float t = t_min;\n    for (int i = 0; i < 100; i++) {\n        float d = scene(ro + rd * t);\n        if (abs(d) < 0.01 ) break;\n        t += d;\n        if (t >= t_max) break;\n    }\n    return t;\n}\n\nvec3 shape_col(vec3 ro, vec3 rd, float t) {\n    vec3 p = ro + rd * t;\n    vec3 n = normal(p);\n\n    float fres = pow(1. - dot(-rd, n), 5.);\n    fres = mix(.002, .5, fres);\n\n    vec3 col = vec3(0.9) * fres;\n\n    return col;\n}\n\nfloat scene_vol(vec3 p) {\n    float id = transform(p, iTime);\n\n    float length = 4.5;\n    p.zy *= rot(PI / 2.);\n\n    return sd_round_cone(p, 0.4, 0.1, length) +\n           triNoise3d(p - vec3(0., 0., iTime * 5.), 0.1, iTime) * 0.1;\n}\n\n#define CLR_BLUE vec3(0.000,0.082,0.702)\n#define CLR_PURPLE vec3(0.427,0.020,0.478)\nvec3 volume_march(in vec3 ro, in vec3 rd, in float t, in float t_max) {\n    vec4 res = vec4(0.);\n    float dist = t;\n    float time = iTime;\n\n    bool hit = false;\n    for (int i = 0; i < 25; i++) {\n        float c = scene_vol(ro + rd * dist);\n        if (c < 0.02) {\n            hit = true;\n            break;\n        }\n        dist += c;\n        if (t > t_max) return res.rgb;\n    }\n    if (!hit) return res.rgb;\n\n    t = dist;\n    for (int i = 0; i < 35; i++) {\n        if (res.a > 1.0) break;\n        vec3 pos = ro + rd * t;\n\n        float r = triNoise3d(pos - vec3(0., 0., 5. * time), 0.1, time);\n        float gr = clamp((r - triNoise3d(pos + vec3(.0, .7, 0.0), .1, time)) / .3, 0., 1.);\n        vec3 lg =\n            vec3(0.72, 0.28, .0) * 2.2 + 1.3 * vec3(0.53, .74, 2.3) * (pos.z - 1.6) * gr;\n        vec4 col =\n            vec4(lg, r * r * r * 1.5);\n        col *= smoothstep(t - 0.2, t + 0.2, t_max);\n\n        col.rgb *= col.a;\n        res = res + col * (1. - res.a);\n        t += 0.1;\n    }\n\n    res.g *= res.w * 0.9 + 0.12;\n    res.r *= res.w * 0.5 + 0.48;\n    return clamp(res.rgb, 0., 1.);\n}\n\n// https://iquilezles.org/articles/filterableprocedurals\nfloat grid(in vec2 p) {\n    const float width = 25.0;\n    vec2 ddx = dFdx(p), ddy = dFdy(p);\n    vec2 pix = fwidth(p) + .001;\n\n    vec2 a = p + 0.5 * pix;\n    vec2 b = p - 0.5 * pix;\n    vec2 i = (floor(a) + min(fract(a) * width, 1.0) - floor(b) -\n              min(fract(b) * width, 1.0)) / (width * pix);\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord/iResolution.xy * 2. - 1.)\n            * vec2(iResolution.x / iResolution.y, 1.);\n\n    float time = iTime;\n\n    float phi = -PI / 5.;  // + time * 0.2;\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    ro += 4. * vec3(cos(phi), 0.5, sin(phi));\n    mat3 cam = get_cam(ro, vec3(0.));\n    vec3 rd = cam * normalize(vec3(uv, 1));\n\n    vec3 col = vec3(0.);\n    float dist = 1e9;\n\n    vec2 box_dist;\n    Box bounding_box = Box(vec3(0., 0., 2.), vec3(2.0, 1.9, 3.));\n\n    float floor_dist = (-3.5 - ro.y) / rd.y;\n    bool hit_floor = floor_dist >= 0. && floor_dist < dist;\n    if (hit_floor) {\n        vec3 p = ro + rd * floor_dist;\n        float disp = triNoise3d(p / 3., 0.1, 0.);\n\n        float grid = 1. - grid(p.xz - vec2(0., time * 1.) );\n        col += vec3(0.8, 0.2, 0.4) * grid * 0.35;\n\n        col = mix(col, vec3(0.01, 0.00, 0.03), disp);\n        col *= smoothstep(40., 0., length(p.xz));\n\n        dist = floor_dist;\n\n        vec3 ro = p;\n        vec3 rd = reflect(rd, normalize(vec3(0., 1., 0.) + disp * 0.10));\n\n        if (boxIntersection(ro, rd, bounding_box, box_dist)) {\n            float t = march(ro, rd, box_dist.x, box_dist.y);\n            float absorbtion = 0.3;\n            col += volume_march(ro, rd, box_dist.x, box_dist.y) * 0.3;\n            if (t < box_dist.y) {\n            /* if (t < FAR) { */\n                col = shape_col(ro, rd, t) * 0.2;\n            }\n        }\n    }\n\n    if (boxIntersection(ro, rd, bounding_box, box_dist)) {\n        dist = min(march(ro, rd, box_dist.x, box_dist.y), dist);\n\n        col += volume_march(ro, rd, box_dist.x, box_dist.y);\n        if (dist < box_dist.y) {\n            col = mix(col, shape_col(ro, rd, dist), 0.98);\n        }\n    }\n\n    col = mix(col, col.brg, 0.1);\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}