{"ver":"0.1","info":{"id":"7tfSR7","date":"1625334413","viewed":82,"name":"City View (Twitch)","username":"rimina","description":"Here is the shader I did on my Twitch live coding stream on 2nd of July 2021. I added some quick camera run which goes to static scene after 2min. So start over if you want to see some flyby.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","twitch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Copyright Â© 2021-2022 rimina.\n// All rights to the likeness of the visuals reserved.\n\n// Any individual parts of the code that produces the visuals is\n// available in the public domain or licensed under the MIT license,\n// whichever suits you best under your local legislation.\n\n// This is to say: you can NOT use the code as a whole or the visual\n// output it produces for any purposes without an explicit permission,\n// nor can you remix or adapt the work itself without a permission.*\n// You absolutely CANNOT mint any NFTs based on the Work or part of it.\n// You CAN however use any individual algorithms or parts of the Code\n// for any purpose, commercial or otherwise, without attribution.\n\n// *(In practice, for most reasonable requests, I will gladly grant\n//   any wishes to remix or adapt this work :)).\n\n\nconst float E = 0.001;\nconst float FAR = 100.0;\nconst int STEPS = 64;\n\nint M = 0;\n\nconst vec3 FOG_COLOR = vec3(0.6, 0.7, 0.8);\nconst vec3 LIGHT_COLOR = vec3(0.9, 0.9, 0.7);\n\nfloat plane(vec3 p, vec3 n, float d){\n  return dot(p, n) + d;\n}\n\nfloat sphere(vec3 p, float r){\n  return length(p)-r;\n}\n\nfloat box(vec3 p, vec3 b){\n  vec3 d = abs(p)-b;\n  return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat cosNoise(vec2 p){\n  return 0.5*(sin(p.x) + sin(p.y));\n}\n\nfloat scene(vec3 p){\n  \n  vec3 pp = p;\n  vec3 ppp = p;\n  \n  //For the plane distortion I have taken some inspiration from here:\n  //https://www.shadertoy.com/view/XlSSzK\n  float h = 0.0;\n  vec2 q = p.xz*0.5;\n  float s = 0.5;\n\n  const mat2 m2 = mat2(1.,-1.,1., 0.5);\n  \n  float a = iTime;\n  float b = 0.0;\n  if(p.z > -30.0){\n\n    for(int i = 0; i < 6; ++i){\n      h += s*cosNoise(q+a); \n      q = m2*q*0.8; \n      q += vec2(5.41+b+cos(a+b),3.13+b+sin(a+b));\n      s *= 0.52 + 0.2*h;\n    }\n    h *= 1.2;\n  }\n  \n  //maa = ground\n  float maa = plane(p, vec3(0.0, 1.0, 0.0), 0.0)-h;\n  //pallo = ball\n  float pallo = sphere(p-vec3(0.0, 1.0, -10.0), 1.5);\n  \n  vec2 offset = vec2(40.0, 20.0);\n  vec2 offset2 = vec2(25.0, 40.0);\n  \n  float building = 100.0;\n  \n  vec2 id = floor((p.xz + offset*0.5)/offset);\n  pp.xz = mod(p.xz + offset*0.5, offset) - offset*0.5;\n  \n  vec2 id2 = floor((p.xz + offset2*0.5)/offset2);\n  ppp.xz = mod(p.xz + offset2*0.5, offset2) - offset2*0.5;\n  \n  if(p.z < -30.0){\n    building = box(pp, vec3(10.0, 20.0-cosNoise(id)*5.0, 6.0));\n    building = min(building, box(ppp, vec3(7.0, 30.0-cosNoise(id2)*10.0, 4.0)));\n  }\n  float guard = -box(pp, vec3(20.0, 50.0, 10.0));\n  guard = abs(guard) + offset.x * 0.1;\n  \n  float guard2 = -box(ppp, vec3(10.0, 50.0, 20.0));\n  guard2 = abs(guard2) + offset2.y * 0.1;\n  \n  guard = min(guard, guard2);\n\n\n  \n  if(maa < pallo && maa < building){\n    M = 1;\n  }\n  else if(building < pallo && building < maa){\n    M = 2;\n  }\n  else{\n    M = 0;\n  }\n  \n  return min(maa, min(pallo, min(guard , building)));\n}\n\n//ro = ray origin, rd = ray direction\nfloat march(vec3 ro, vec3 rd){\n  float t = E;\n  //p = position\n  vec3 p = ro;\n  for(int i = 0; i < STEPS; ++i){\n    float d = scene(p);\n    t += d;\n    p = ro + rd * t;\n    \n    if(d < E || t > FAR){\n      break;\n    }\n  }\n  \n  return t;\n}\n\nvec3 normals(vec3 p){\n  vec3 e = vec3(E, 0.0, 0.0);\n  return normalize(vec3(\n    scene(p + e.xyy) - scene(p - e.xyy),\n    scene(p + e.yxy) - scene(p - e.yxy),\n    scene(p + e.yyx) - scene(p - e.yyx)\n  ));\n}\n\nvec3 shade(vec3 rd, vec3 p, vec3 n, vec3 ld){\n  float l = max(dot(n, ld), 0.0);\n  float a = max(dot(reflect(ld, n), rd), 0.0);\n  float shiny = 20.0;\n  vec3 col = vec3(0.1, 0.3, 0.35);\n  vec3 col2 = vec3(0.7, 0.9, 1.0);\n  if(p.z < -30.0){\n    col = vec3(0.5, 0.8, 0.2);\n    col2 = vec3(0.5, 1.0, 0.4);\n    shiny = 1.0;\n  }\n  \n  if(M == 0){\n    col = col.rrg;\n    shiny = 2.0;\n  }\n  else if( M == 2){\n    col = vec3(1.0, 0.0, 1.0);\n    col2 = col + 0.2;\n    shiny = 2.0;\n  }\n  else{\n  }\n  \n  float s = pow(a, shiny);\n  \n  return l * col*0.4 + s * col2*0.6;\n  \n}\n\n//https://iquilezles.org/articles/fog\nvec3 fog(vec3 col, vec3 p, vec3 ro, vec3 rd, vec3 ld){\n  float dist = length(p-ro);\n\tfloat sunAmount = max( dot(rd, -ld), 0.0 );\n\tfloat fogAmount = 1.0 - exp( -dist*0.035);\n\tvec3  fogColor = mix(FOG_COLOR, LIGHT_COLOR, pow(sunAmount, 4.0));\n  return mix(col, fogColor, fogAmount);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = -1.0 + uv*2.0;\n    uv *= vec2(iResolution.x / iResolution.y, 1);\n\n    //ray origin\n    vec3 ro = vec3(15.0*smoothstep(0.0, 50.0, iTime), 10.0+30.5*smoothstep(0.0, 60.0, iTime), 30.0-80.0*smoothstep(0.0, 60.0, iTime));\n    //ray target\n    vec3 rt = vec3(15.0*smoothstep(0.0, 60.0, iTime), 30.0*smoothstep(0.0, 60.0, iTime), ro.z-20.0);\n    \n    if(iTime >= 60.00 && iTime < 120.00){\n        ro = vec3(15.0, 40.5, -50.0-(iTime-50.0));\n        rt = vec3(15.0, 30.0, -70.0 + 71.0*smoothstep(60.0, 70.0, iTime));\n        \n    }\n    else if(iTime >= 120.00){\n        ro = vec3(15.0, 30.0, 10.0);\n        rt = vec3(15.0, 18.0, -10.0);\n    }\n\n    vec3 z = normalize(rt-ro);\n    vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n    vec3 y = normalize(cross(x, z));\n\n    vec3 rd = normalize(mat3(x, y, z) * vec3(uv, radians(60.0)));\n\n    vec3 col = FOG_COLOR;\n    float t = march(ro, rd);\n\n    vec3 p = ro + rd *t;\n    vec3 n = normals(p);\n\n    vec3 lp = vec3(30.0, -50.0, 100.0);\n    vec3 lt = ro;\n    vec3 ld = normalize(lt-lp);\n\n    if(t < FAR){\n        col = shade(rd, p, n, ld);\n\n        if((M == 1 && p.z > -30.0) || M == 2){\n            vec3 refd = reflect(rd, n);\n            vec3 refo = p + 2.0*E*n;\n            t = march(refo, refd);\n            vec3 pr = refo + refd * t;\n            if(t < FAR){\n                n = normals(pr);\n                col += shade(refd, pr, n, ld);\n                col *= 0.5;\n            }\n        }\n    }\n    col = fog(col, p, ro, rd, -ld);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}