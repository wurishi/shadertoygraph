{"ver":"0.1","info":{"id":"dslyWM","date":"1686877485","viewed":33,"name":"Lista 4 - Część I","username":"dkuzior","description":"Podpunkt 12","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // q - Wektor oznaczjący pozycję pixela (w postaci znormalizwoanej)\n    vec2 q = fragCoord.xy / iResolution.xy;\n    \n    // p - wektor q po porawieniu proporcji\n    vec2 p = (-1.0 + 2.0 * q) * vec2(iResolution.x / iResolution.y, 1.0);\n    \n    // Nowy środek układu - na środku sceny:\n    vec2 srodek = vec2(0.0, 0.0);\n    \n    // d - odległość punktu p (piksela) od środka układu\n    float d = length(p - srodek);\n    d = 1.0 - d; // inwersja odległości\n    \n    // Wyliczam kąt phi (między wektorem p, a osią X):\n    float phi = atan(p.y, p.x) + iTime * 0.15;\n    \n    // Dodaje zmodyfikowaną wartość sinusa kąta phi do d\n    d += sin(phi * 25.0)/5.0;\n    \n    // Zmiana gradientu do kształtu \" wygładzonego kółka\"\n    d = smoothstep(0.3, 0.6, d);\n    \n    \n    // Kolor każdego piksela jest zależny od inwersji odległości od środka układu:\n    vec3 col = vec3(d, d, d - 0.5); // Dodatkowo zmieniam kolor\n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}