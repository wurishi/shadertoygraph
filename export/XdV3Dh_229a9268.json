{"ver":"0.1","info":{"id":"XdV3Dh","date":"1454268702","viewed":131,"name":"CS224_BALL_zli27","username":"zli27","description":"You toggle motion blur and anti-aliasing off by comment #define motionblur and #define antialiasing out. ","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","motionblur","antialiasing","softshadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ground plane is at Y=0\n// sphere is resting on top of ground plane.\n\n#define motionblur\n\n//Super sampling -> 9 Sample points\n#define antialiasing \n\nvec3 fogCol   = vec3(.5);\nconst float SPHERE_RADIUS = .6;\nconst float EPSILON = 0.05;\n\n//****** SPHERES ****** //\n\nvec3 CENTER = vec3(-10.,2.,8.);\nvec4 SPHERE1 = vec4(-10., 1. + .5 * sin(iTime * 10.), 10.,.5);\nvec4 SPHERE2 = vec4(SPHERE1.x-2.5*SPHERE_RADIUS * cos(iTime / 3.),SPHERE_RADIUS,SPHERE1.z- 2.5*SPHERE_RADIUS*sin(iTime / 3.),.7);\nvec4 SPHERE3 = vec4(SPHERE1.x+4.5*SPHERE_RADIUS * cos(iTime * 3.0),SPHERE_RADIUS,SPHERE1.z+ 4.5*SPHERE_RADIUS*sin(iTime * 3.0),.5);\nvec4 SPHERE4 = vec4(SPHERE1.x+6.5*SPHERE_RADIUS * sin(iTime * 2.),SPHERE_RADIUS,SPHERE1.z+ 6.5*SPHERE_RADIUS*cos(iTime * 2.),.4);\nvec4 SPHERE5 = vec4(SPHERE1.x-7.5*SPHERE_RADIUS* sin(iTime),.25 + .2 * sin(iTime),SPHERE1.z- 7.5*SPHERE_RADIUS*cos(iTime),.25 + .1 * sin(iTime));\n\n\nvec3 POINT_LIGHT = vec3(-20. * smoothstep(-.5,.5,sin(iTime / 3.)),22., -7.); \nconst vec3 SPHERE_AMBIENT1 = vec3(.0);\nconst vec3 SPHERE_AMBIENT2 = vec3(.5);\nconst vec3 SPHERE_DIFFUSE = vec3(.5, 0.5, 0.5); // diffuse color of the sphere\nconst vec3 SPHERE_SPECULAR = vec3(.5);\nconst vec3 WORLD_COLOR = vec3(0.8, 0.9, 1.0);\nconst vec3 GROUND_COLOR_2 = vec3(0.05);\nconst vec3 GROUND_COLOR_1 = vec3(0.9,0.9,0.9);\nconst vec3 LIGHT_COLOR = vec3(1.);\n\n//Returns the sphere(#3) position at given time\nvec3 getPosition(float time, int which)\n{\n    if (which == 1){\n        return vec3(-10., 1. + .5 * sin(time * 10.), 10.);\n    } else if (which == 2){\n        return vec3(SPHERE1.x-2.5*SPHERE_RADIUS * cos(time / 3.),SPHERE_RADIUS,SPHERE1.z- 2.5*SPHERE_RADIUS*sin(time / 3.));\n    } else if (which == 3){\n        return vec3(SPHERE1.x+4.5*SPHERE_RADIUS * cos(time * 3.0),SPHERE_RADIUS,SPHERE1.z+ 4.5*SPHERE_RADIUS*sin(time * 3.0));\n    } else if (which == 4){\n        return vec3(SPHERE1.x+6.5*SPHERE_RADIUS * sin(time * 2.),SPHERE_RADIUS,SPHERE1.z+ 6.5*SPHERE_RADIUS*cos(time * 2.));\n    } else {\n        return vec3(SPHERE1.x-7.5*SPHERE_RADIUS* sin(time),.25 + .2 * sin(time),SPHERE1.z- 7.5*SPHERE_RADIUS*cos(time));\n    }   \n}\nfloat getBlendFactor(in vec3 pos, in vec4 sphere)\n{\n    float dist = distance(pos, sphere.xyz) - sphere.w;\n    return clamp(dist, 0., 1.);\n}\n\n//Ray : x = ro + t * rd\n//Sphere : |x - o| = r\n//Equation : t2 + 2 * t * (ro*rd - o*rd) + (ro-o)2 - r2 = 0\n//--> [A]t2 + [B]2 * t * <rd, ro-o> + [C](ro-o)2 - r2 = 0\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sphere)\n{\n \n    vec3 ro2o = ro - sphere.xyz;\n    float b = dot(rd, ro2o);\n    float c = dot(ro2o, ro2o) - pow(sphere.w, 2.);\n    float delta = pow(b, 2.) - c;\n    \n    //IF DELTA < 0 : no intersection\n    if(delta < 0.){\n        return -1.;\n    }\n    \n    return -b - sqrt(delta);    \n}\n\n//Idea from iq\n//https://iquilezles.org/articles/sphereshadow\n//Equation for testing intersection is identical with the above function\nfloat sphSoftShadow( in vec3 ro, in vec3 rd, in vec4 sphere, in float k )\n{\n    vec3 ro2o = ro - sphere.xyz;\n    float b = dot(rd, ro2o );\n    float c = dot(ro2o, ro2o) - pow(sphere.w, 2.);\n    float delta = b*b - c;\n    \n    //T is identical with the intersection result\n    //no further shadow calculation requires if there is no intersection\n    float t = -b - sqrt(max(0.0,delta));\n    if(t < 0.0){\n        return 1.;\n    }\n    \n    //d is the closest distance from sphere center to the ray\n    //Draw a line from sphere center which perpendicular to the ray direction\n    //the length between the intersection point and the sphere center is d\n    //\n   \n    float l2 = dot(ro2o,ro2o);\n    float projection2 = pow(dot(rd,ro2o), 2.);\n    float d = sqrt(max(0., l2 - projection2)) - sphere.w;\n    return smoothstep(0.0, 1.0, k*d / t);\n}\n\nvec3 sphereNormal(in vec3 pos, in vec4 sphere)\n{\n    return normalize(pos - sphere.xyz);\n}\n\nvec3 illuminateSphere(in vec3 pos, in vec4 sphere)\n{\n    vec3 normal = sphereNormal(pos,sphere);\n    \n    //Phong lighting \n    vec3 l = normalize(POINT_LIGHT - pos);\n    vec3 r = normalize(reflect(l,normal));\n    vec3 e = normalize(vec3(10., 2.1, 20.) - pos);\n    float spec = max(0., dot(e, r));\n    vec3 ambient = vec3(0.);\n    float angle = atan(pos.x / pos.z * .8) * 160.;\n    if(tan(angle) > .0){\n        ambient = SPHERE_AMBIENT1;\n    }else{\n        ambient = SPHERE_AMBIENT2;\n    }\n    vec3 specular = SPHERE_SPECULAR * pow(spec,10.);\n    vec3 phong = ambient + SPHERE_DIFFUSE * max(0., dot(normal,l)) + specular;\n    float alpha = getBlendFactor(pos, sphere);\n    return mix(phong, vec3(.5), alpha);\n}\n\nvec3 refl( in vec3 pos, in vec3 rd)\n{\n    vec3 gnormal = vec3(0., 1., 0.);\n    vec3 r = normalize(reflect(rd, gnormal));\n    vec3 p = vec3(0.);\n    vec3 col = vec3(0.);\n    float mint = 1e10;\n    float h = iSphere(pos,r,SPHERE1);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE1);\n    }\n    h = iSphere(pos,r,SPHERE2);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE2);\n    }\n    h = iSphere(pos,r,SPHERE3);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE3);\n    }\n    h = iSphere(pos,r,SPHERE4);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE4);\n    }\n    h = iSphere(pos,r,SPHERE5);\n    if(h > 0. && h < mint){\n        mint = h;\n        p = pos + h * r;\n        col = illuminateSphere(p,SPHERE5);\n    }\n    \n    return col; \n}\n\nvec3 illuminateGround(in vec3 pos, in vec3 rd)\n{\n    vec3 col = vec3(0.);\n    \n    float diff = pow((pos.x-SPHERE1.x),2.) + pow((pos.z-SPHERE1.z),2.);\n    if(sin(diff/pow(SPHERE_RADIUS,2.)) <= 0.){\n        col = GROUND_COLOR_2;\n    }else{\n        col = GROUND_COLOR_1;\n    } \n    \n    //Apply soft shadow on the ground\n    float sshadow = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE1, 5.);\n    col *= sshadow;\n    float sshadow2 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE2, 10.);\n    col *= sshadow2;\n    float sshadow3 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE3, 12.);\n    col *= sshadow3;\n    float sshadow4 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE4, 16.);\n    col *= sshadow4;\n    float sshadow5 = sphSoftShadow(pos, normalize(POINT_LIGHT-pos), SPHERE5, 32.);\n    col *= sshadow5;\n    \n    //Get the reflection color\n    vec3 reflcol = refl(pos, rd);\n    \n    col = mix(col, reflcol, .22);\n      \n    return col;\n}\n\n//Brute force motion blur\nvec3 motionBlur(in vec3 ro, in vec3 rd, int which, float radius)\n{\n    vec3 col = vec3(0.0);\n    const int samples = 40;\n    \n    //Sample at 60 different points\n    for( int i=0; i<samples; i++ )\n\t{   \n        //Sample time interval \n        float deltaT = float(i) / float(samples);\n        vec3 ap = getPosition(iTime + deltaT / 15., which);\n        \n        //Ambient color if doesn't intersect with the current position\n        vec3 tcol = vec3(.5);\n        \n        vec4 newSpherePos = vec4(ap, radius);\n        \n        float t = iSphere( ro, rd, newSpherePos);\n        \n        //If there is an intersection at the sample position\n        if( t > 0.0 )\n        {\n            vec3 pos = ro + t * rd;\n            vec3 nor = sphereNormal(pos, newSpherePos);\n            tcol = illuminateSphere(pos, newSpherePos);\n        }\n        col += tcol;\n\t}\n    \n    //Divide by sample num\n\tcol /= float(samples);\n    \n    return col;\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 pos = vec3(0.);\n    vec3 col = vec3(0.);\n    float mint = 1e10;\n    float h = iSphere(ro,rd,SPHERE1);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        \n        #ifdef motionblur\n        col = motionBlur(ro, rd, 1,SPHERE1.w);\n        #else\n        col = illuminateSphere(pos,SPHERE1);\n        #endif\n    }\n    h = iSphere(ro,rd,SPHERE2);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        col = illuminateSphere(pos,SPHERE2);\n    }\n    h = iSphere(ro,rd,SPHERE3);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        #ifdef motionblur\n        col = motionBlur(ro, rd, 3,SPHERE3.w);\n        #else\n        col = illuminateSphere(pos,SPHERE3);\n        #endif\n    }\n    h = iSphere(ro,rd,SPHERE4);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        #ifdef motionblur\n        col = motionBlur(ro, rd,4, SPHERE4.w);\n        #else\n        col = illuminateSphere(pos,SPHERE4);\n        #endif\n    }\n    h = iSphere(ro,rd,SPHERE5);\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        #ifdef motionblur\n        col = motionBlur(ro, rd, 5,SPHERE5.w);\n        #else\n        col = illuminateSphere(pos,SPHERE5);\n        #endif\n    }\n    h =  -ro.y / rd.y;\n    if(h > 0. && h < mint){\n        mint = h;\n        pos = ro + h * rd;\n        col = illuminateGround(pos, rd);\n    }\n    \n    float d = distance(pos, POINT_LIGHT);\n    \n    //Light attenuation\n    float atten = min(1., 20. / (1. + .8 * d + 1.8 * pow(d, .4)));\n    \n    col *= atten;\n    \n    //Distance fog\n    float fog = 1. - exp(distance(ro, pos) * .07);\n    \n    col = mix(col, fogCol, fog);\n        \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*uv; // pixel space of the focal plane\n    p.x *= iResolution.x/iResolution.y;\n    \n    // camera   \n    vec3 eye = vec3(-10. + 5. * sin(iTime),7. + 2. * sin(iTime / 2.), -5. + 2.5 * cos(iTime)); // world space camera location\n    vec3 look = CENTER; // where camera is pointing at\n    vec3 up = vec3( 0.0, 1.0, 0.0 ); // up axis of world\n    float d = 5.5; // distance between eye and focal plane\n    \n    vec3 w = normalize( look - eye);\n    vec3 u = normalize( cross(w,up) );\n    vec3 v = normalize( cross(u,w) );\n    vec3 rd = normalize( p.x*u + p.y*v + d*w );\n    \n    //Color gained from the central ray\n    vec3 col = render(eye,rd);\n    \n    #ifdef antialiasing\n    \n       float samplex = 1. / iResolution.x;\n       float sampley = 1. / iResolution.y;\n       for(int i=-1;i<=1;i++){\n           for(int j=-1;j<=1;j++){\n               if( i == 0 && j == 0) continue;\n               vec2 sp = p + vec2(samplex * float(i), sampley*float(j));\n               vec3 srd = normalize(sp.x*u+sp.y*v+d*w);\n               col += render(eye,srd);\n           }\n       }\n    \n       col /= 9.;\n    #endif\n    \n    fragColor=vec4(col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}