{"ver":"0.1","info":{"id":"tsyfzd","date":"1726723129","viewed":32,"name":"1st try demo","username":"padriaan","description":"First demo try. ","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIR_LEFT -1.     // change to 1 for left to right\n#define DIRECTION DIR_LEFT // of stars\n#define LAYERS 6    // of stars\n#define SPEED 100.  // of stars\nconst vec2 O = vec2(0.,1.);\n\n// globe constants\n#define PI 3.1415926536\nconst mat3 mRot = mat3(0.9553, -0.2955, 0.0, 0.2955, 0.9553, 0.0, 0.0, 0.0, 1.0);\nconst vec3 ro = vec3(0.0,0.0,-4.0);\nconst vec3 cRed = vec3(1.0,0.0,0.0);\nconst vec3 cWhite = vec3(1.);\nconst vec3 cGrey = vec3(0.66);\nconst vec3 cPurple = vec3(0.51,0.29,0.51);\nconst float maxx = 0.9;    // max x distance\n\n\nfloat makePoint(float x,float y,float fx,float fy,float sx,float sy,float t){\n   float xx=(x)+sin(t*fx)*sx;\n   float yy=(y+.6)+cos(t*fy)*sy;\n   return 2.0/sqrt(xx*xx+yy*yy);\n}\n\nfloat rand (in vec2 uv) { \n    return fract(sin(dot(uv,vec2(12.4124,48.4124)))*48512.41241); \n}\n\nfloat noise (in vec2 uv) {\n\tvec2 b = floor(uv);\n\treturn mix(mix(rand(b),rand(b+O.yx),.5),mix(rand(b+O),rand(b+O.yy),.5),.5);\n}\n\nfloat Circle(vec2 uv, vec2 p,float r, float blur){   //uv, position, radius, blur \n    \n    float d = length(uv-p);    // length from uv coordinate\n    float c = smoothstep(r, r - blur, d);  // geeft witte cirkel; want low and high omgewisseld\n    \n    return c;\n}    \n\nfloat Band(float t, float start, float end, float blur) {    // t = positie\n    \n     float step1 = smoothstep(start - blur, start + blur, t);     // vertikale links zwart, rechts wit\n     float step2 = smoothstep(end + blur, end - blur, t);         // horizontale links wit en rechts zwart\n    \n     return step1*step2;         // vertikale band: zwart - wit zwart (want zwart=0 en wit = 1, dus\n                           //                 vermenigvuldiging geeft alleen wit (1x1)\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) \n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat aspect = iResolution.y/iResolution.x;\n\n    float Time_bars = iTime*-1.6 ; // time for bars, change speed here\n    float Time_norm = iTime;  \n\n    // stars\n    float stars = 0.;\n\tfloat fl, s;\n\tfor (int layer = 0; layer < LAYERS; layer++) {\n\t\tfl = float(layer);\n\t\ts = (300.-fl*10.);\n\t\tstars += step(.1,pow(noise(mod(vec2(uv.x*s - Time_norm*SPEED*DIRECTION - fl*100.,uv.y*s),iResolution.x)),18.)) \n                 * (fl/float(LAYERS));\n\t}\n    vec3 colour = vec3(0.);\n    colour = vec3(stars);\n  \n    // bars\n    uv -= 0.5;     // \"move\" coordinate system \n                   // center is 0.5,0.5 , so range now from -0.5 <> 0.5\n    uv.x *= iResolution.x/iResolution.y;  // \"fix\" aspect ratio so that circle is a circle\n                                           // circle was too wide in x direction\n\n    float mask_blur  = abs(cos(Time_bars-10.0)+1.5);\n    float mask2_blur = abs(cos(Time_bars)+1.5);\n    float mask3_blur = abs(cos(Time_bars-5.0)+1.5);\n    \n    float mask  =  Band(uv.y + (sin((Time_bars-10.0)) * 0.2) - 0.2, 0.0, 0.03 * abs(cos(Time_bars-10.0)+1.3)\n                        , 0.01 * mask_blur);\n\n    float mask2 =  Band(uv.y + (sin((Time_bars     )) * 0.2) - 0.2, 0.0, 0.03 * abs(cos(Time_bars)+1.3)\n                        , 0.01 * mask2_blur);\n\n    float mask3 =  Band(uv.y + (sin((Time_bars-5.0 )) * 0.2) - 0.2, 0.0, 0.03 * abs(cos(Time_bars-5.0)+1.3)\n                        , 0.01 * mask3_blur);\n\n    // define balls\n    //float mask_ball1 = Circle(uv,vec2( (sin(Time_bars/2.0) * 0.6)-.15, (sin(Time_bars/.4) * 0.06) + 0.2), 0.07, 0.01);\n    //float mask_ball2 = Circle(uv,vec2( (sin(Time_bars/2.0) * 0.6) + .0, (sin(Time_bars/.4) * 0.06) + 0.2), 0.07, 0.01);\n    //float mask_ball3 = Circle(uv,vec2( (sin(Time_bars/2.0) * 0.6) + .15, (sin(Time_bars/.4) * 0.06) + 0.2), 0.07, 0.01);\n    \n    // globe, https://www.shadertoy.com/view/4ssGWn\n\tvec2 uv_globe = (fragCoord.xy / iResolution.xy);\n    float xt = mod(Time_norm+.36,6.0);   // horizontal motion ; 1. for stationary\n\tfloat dir = (step(xt,3.0)-0.5);  // direction and speed\n\tuv_globe.x -= (maxx*2.0*dir)*mod(xt,3.0)/3.0+(-maxx*dir) -.2;  // vert. dir\n\tuv_globe.y -= abs(sin(4.5+Time_norm*1.3))*0.2- .1;\n   \n    vec3 rd = normalize(vec3((uv_globe*2.0-1.4)*vec2(1.0,aspect),1.5));\n\tfloat b1 = dot(rd,ro);\n\tfloat t1 = b1*b1-15.95;    // size\n    float t = -b1-sqrt(t1);\n\tvec3 nor = normalize(ro+rd*t)*mRot;\n    \n\tvec2 tuv = floor(  vec2(atan(nor.x,nor.z)\n                               /PI+((floor((Time_norm*-dir)*60.0)/60.0)*1.5),  // 1.5 speed rotation\n                            acos(nor.y)/PI)*5.0);   // pattern on globe\n\n    // bars\n    float lowest  = min( min( mask_blur, mask2_blur ), mask3_blur);\n    float highest = max( max( mask_blur, mask2_blur ), mask3_blur);\n    float mediest = mask_blur + mask2_blur + mask3_blur - lowest - highest;\n           // = a+b+c-lo-hi\n    \n    float prec = 0.0001;\n    \n    if ( abs(lowest -  mask_blur) < prec) { colour = mix(colour, vec3(1.0, 1.0, 0.0), mask) ;} // yellow    \n    if ( abs(lowest - mask2_blur) < prec) { colour = mix(colour, vec3(0.0, 1.0, 1.0), mask2);} // cyan    \n    if ( abs(lowest - mask3_blur) < prec) { colour = mix(colour, vec3(1.0, 0.0, 0.0), mask3);} // red\n\n    if ( abs(mediest -  mask_blur) < prec ) { colour = mix(colour, vec3(1.0, 1.0, 0.0), mask) ;} // yellow    \n    if ( abs(mediest - mask2_blur) < prec ) { colour = mix(colour, vec3(0.0, 1.0, 1.0), mask2);} // cyan    \n    if ( abs(mediest - mask3_blur) < prec ) { colour = mix(colour, vec3(1.0, 0.0, 0.0), mask3);} // red\n\n    // display balls\n    //colour = mix(colour, vec3(0.0, 1.0, 0.0), mask_ball1);\n    //colour = mix(colour, vec3(0.7, 0.2, 1.0), mask_ball2);\n    //colour = mix(colour, vec3(0.8, 0.1, 0.5), mask_ball3);\n    \n    // display globe\n    colour = mix(colour ,mix(cRed,cWhite,clamp(mod(tuv.x+tuv.y,2.0),0.0,1.0)),\n                         1.-step(t1,0.0));\n\n    if ( abs(highest -  mask_blur) < prec ) { colour = mix(colour, vec3(1.0, 1.0, 0.0), mask) ;} // yellow    \n    if ( abs(highest - mask2_blur) < prec ) { colour = mix(colour, vec3(0.0, 1.0, 1.0), mask2);} // cyan    \n    if ( abs(highest - mask3_blur) < prec ) { colour = mix(colour, vec3(1.0, 0.0, 0.0), mask3);} // red    \n\n    // include blobs on bottom half : https://www.shadertoy.com/view/lsfGzr\n    vec2 p=(fragCoord.xy/iResolution.x)*2.0-vec2(1.0,iResolution.y/iResolution.x);\n    p=p*2.0;\n    float x=p.x;\n    float y=p.y;\n\n    float a= makePoint(x,y,3.3,2.9,0.3,0.3,Time_norm);\n    a=a+makePoint(x,y,1.9,2.0,0.4,0.4,Time_norm);\n    a=a+makePoint(x,y,0.8,0.7,0.4,0.5,Time_norm);\n\n    float b= makePoint(x,y,1.2,1.9,0.3,0.3,Time_norm);\n    b=b+makePoint(x,y,0.7,2.7,0.4,0.4,Time_norm);\n    b=b+makePoint(x,y,1.4,0.6,0.4,0.5,Time_norm);\n\n    float c= makePoint(x,y,3.7,0.3,0.3,0.3,Time_norm);\n    c=c+makePoint(x,y,1.9,1.3,0.4,0.4,Time_norm);\n    c=c+makePoint(x,y,0.8,0.9,0.4,0.5,Time_norm);\n\n    vec3 d=vec3(a,b,c)/48.0;\n   \n    fragColor = vec4(d.x,d.y,d.z,(d.x+d.y+d.z)/3.0);\n\n    // add top + (bars + globe)\n    fragColor += vec4(colour, 1.0); \n}\n","name":"Image","description":"","type":"image"}]}