{"ver":"0.1","info":{"id":"stfXWn","date":"1625439637","viewed":492,"name":"white noise vs bayer","username":"Jodie","description":"testing bayer matrices as a replacement for noise for rough reflections","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","raytrace"],"hasliked":0,"parentid":"4ds3RN","parentname":"Cubemap Shading"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"#define steps 1\n\n// curve matched with turingbot\nvec3 srgbToLinear(const vec3 x){\n    return 0.315206*x*((2.10545+x)*(0.0231872+x));\n}\n\nvec3 linearToSrgb(vec3 x){\n    x=clamp(x,0.,1.);\n    return sqrt((-2.8450663e-1*x+1.2580714)*x-2.4727747e-3);\n}\n\nuint bitfieldInterleaveReverse(uint x,uint y){\n\t\n    x = ((x>>8u) | (x << 16u)) & 0x00FF00FFu;\n    x = ((x>>4u) | (x <<  8u)) & 0x0F0F0F0Fu;\n    x = ((x>>2u) | (x <<  4u)) & 0x33333333u;\n    x = ((x>>1u) | (x <<  2u)) & 0x55555555u;\n\n    y = ((y>>8u) | (y << 16u)) & 0x00FF00FFu;\n    y = ((y>>4u) | (y <<  8u)) & 0x0F0F0F0Fu;\n    y = ((y>>2u) | (y <<  4u)) & 0x33333333u;\n    y = ((y>>1u) | (y <<  2u)) & 0x55555555u;\n\n    return y | (x << 1u);\n}\n\nfloat bayer(vec2 fragCoord){\n    const float rcpMaxInt = 1./exp2(32.);\n    uvec2 x = uvec2(fragCoord);\n\treturn float(\n        bitfieldInterleaveReverse(x.x^x.y, x.y)\n    ) * rcpMaxInt;\n}\n\nfloat pow2(float x){return x*x;}\nfloat pow3(float x){return x*x*x;}\nfloat pow5(float x){return x*x*x*x*x;}\n\nfloat fresnel(float f0, float LoH) {\n    \n    float n1=1.;\n    \n    float n2=(sqrt(f0) + 1.)/(1. - sqrt(f0));\n\n    float sinTheta = sqrt(1.-LoH*LoH);\n    float ct = sqrt(1.-pow2((n1/n2)*sinTheta));\n    \n    float rs=pow2((n1*ct-n2*LoH)/(n1*ct+n2*LoH));\n    float rp=pow2((n1*LoH-n2*ct)/(n1*LoH+n2*ct));\n   \n    return (rs+rp)*.5;\n}\n\n\n// height correlated smith\nfloat masking(float a, float NoV){\n    float a2 = a * a;\n    return 2.0 * NoV / (sqrt(a2 + (1.0 - a2) * pow2(NoV)) + NoV);\n}\nfloat geometry(float a, float NoV, float NoL) {\n        float a2 = a * a;\n        float b = sqrt(a2 + (1.0 - a2) * pow2(NoV));\n        float c = sqrt(a2 + (1.0 - a2) * pow2(NoL));\n        return (2.0 * NoL * NoV) / (NoV * c + NoL * b);\n}\n\nfloat geometryNormalized(float a, float NoV, float NoL) {\n        float a2 = a * a;\n        float b = sqrt(a2 + (1.0 - a2) * pow2(NoV));\n        float c = sqrt(a2 + (1.0 - a2) * pow2(NoL));\n        return .5 / (NoV * c + NoL * b);\n}\n\nfloat normalization(float a, float NoV, float NoL) {\n        //return geometry(a, NoV, NoL)/masking(a,NoV);\n        float a2 = a * a;\n        float b = sqrt(a2 + (1.0 - a2) * pow2(NoV));\n        float c = sqrt(a2 + (1.0 - a2) * pow2(NoL));\n        return NoL*(b + NoV) / (NoV * c + NoL * b);\n}\n\n// https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;  // GLIB C\nvec3 hash( uvec3 x ){\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\nvec4 intersectSphere(vec3 rpos, vec3 rd){\n\tfloat rad = 5.0;\n    vec3 oc = -rpos;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - rad*rad; \n\t\n\tfloat h = b*b - c; \n\t\t\n\tif (h > 0.0){\n\t\tfloat t = b - sqrt(h);\n\t\treturn vec4((rd*t-oc)/rad, t);\n\t}\n\t\n\treturn vec4(0.0);\n}\n\n\n\n\n//http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html\nvec3 hemisphereSample_cos(float p) {\n    const float tau = radians(360.);\n    const float phi = sqrt(5.) * .5 + .5;\n    const float goldenAngle = tau / phi / phi;\n    \n    float x = p;\n    float y = p*float(steps)*1024.*goldenAngle;\n \n    float cosTheta = sqrt(1.0 - x);\n    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n    return vec3(cos(y) * sinTheta, sin(y) * sinTheta, cosTheta);\n}\n\n// http://jcgt.org/published/0007/04/01/\nvec3 halfVector(vec3 v, float alpha, float p){\n    const float tau = radians(360.);\n    const float phi = sqrt(5.) * .5 + .5;\n    const float goldenAngle = tau / phi / phi;\n    \n    vec2 U;\n    U.x=p;\n    U.y=p*float(steps)*1024.*goldenAngle;\n\n\tvec3 Vh = normalize(vec3(alpha * v.x, alpha * v.y, v.z));\n\t// Section 4.1: orthonormal basis\n\tfloat lensq = Vh.x * Vh.x + Vh.y * Vh.y;\n\tvec3 T1 = lensq > 0. ? vec3(-Vh.y, Vh.x, 0)*inversesqrt(lensq) : vec3(1,0,0);\n\tvec3 T2 = cross(Vh, T1);\n\t// Section 4.2: parameterization of the projected area\n\tfloat r = sqrt(U.x);\n\tfloat y = U.y;\n\tfloat t1 = r * cos(y);\n\tfloat t2 = r * sin(y);\n\tfloat s = 0.5 * (1.0 + Vh.z);\n\tt2 = (1.0 - s)*sqrt(1.0 - t1*t1) + s*t2;\n\t// Section 4.3: reprojection onto hemisphere\n\tvec3 Nh = t1*T1 + t2*T2 + sqrt(1.0 - t1*t1 - t2*t2)*Vh;\n\t// Section 3.4: transforming the normal back to the ellipsoid configuration\n\treturn normalize(vec3(alpha * Nh.x, alpha * Nh.y, Nh.z));\t\n}\n\n//https://twvideo01.ubm-us.net/o1/vault/gdc2017/Presentations/Hammon_Earl_PBR_Diffuse_Lighting.pdf\nvec3 diffuse(const float NdotL, const float NdotV, const float LdotV, const float r, const vec3 albedo) {\n    \n    float alpha = r*r;\n    \n    float RNdotH = sqrt(2.*LdotV+2.)/(NdotL+NdotV);\n    \n    float rough = (LdotV*(-.1*LdotV+.25)+.35)*(.5*RNdotH + 1.);\n    float smoot = 1.05*(1.-pow5(1.-NdotL))*(1.-pow5(1.-NdotV));\n    float single = mix(smoot, rough, alpha);\n    float multi = .3641105886 * alpha;\n    return //clamp(NdotL,0.,1.) * \n        albedo * (albedo*multi+single);\n}\n\n\nfloat specularPointLight(float NdotL, float NdotV, float LdotV, float r, float f0){\n    const float pi = radians(180.);\n    float alpha = r * r;\n\n    float rcpLen_LV = inversesqrt(2.*LdotV+2.);\n    float NdotH = (NdotL+NdotV)*rcpLen_LV;\n    float LdotH = rcpLen_LV * LdotV + rcpLen_LV;\n\n    float alpha2 = alpha*alpha;\n    float d = NdotH * NdotH * (alpha2 - 1.) + 1.;\n    float D = alpha2/(pi * d * d);\n\n    float F = fresnel(f0, LdotH);\n    float Gn = geometryNormalized(alpha, NdotV, NdotL);\n\n    return NdotL * F * Gn * D;\n}\n\nvec3 trace(vec3 rayPos, vec3 v, vec2 fragCoord){\n    vec3 albedo = vec3(0);\n    vec3 up = vec3(0,1,0);\n    float roughness = .3;\n    float alpha = roughness * roughness;\n    float alpha2 = alpha * alpha;\n    float f0 = .8;\n    float dither = bayer(fragCoord.xy);\n    \n    if(fragCoord.x<iResolution.x/2.){\n        dither = hash(uvec3(fragCoord,0)).x;\n    }\n\n\tvec3 col = srgbToLinear(texture(iChannel0, v).rgb);\n\t\n\tvec4 r = intersectSphere(rayPos, -v);\n\t\n\tif (r.w > 0.0){\n         \n\t\tvec3 n = r.xyz;\n        \n        float NoV = clamp(dot(n, v),0.,1.);\n        vec3 tangent = normalize(cross( up, n ));\n        mat3 tbn = mat3( tangent, cross(n, tangent), n );\n        vec3 specularc = vec3(0);\n        vec3 diffusec = vec3(0);\n        \n        #pragma unroll\n        for (int i = 0; i < steps; i++){\n            vec3 l = tbn * hemisphereSample_cos((dither+float(i))/float(steps));\n            float NoL = clamp(dot(n, l),0.,1.);\n            float LoV = clamp(dot(l, v),0.,1.);\n            diffusec += diffuse(NoL, NoV, LoV, roughness, albedo) * srgbToLinear(texture(iChannel0, -l).rgb);\n        }\n        \n        #pragma unroll\n        for (int i = 0; i < steps; i++){\n            vec3 h = tbn * halfVector(\n                v*tbn,\n                alpha,\n                (dither+float(i))/float(steps)\n            );\n\n            float VoH = clamp(dot(v, h),0.,1.);\n            vec3 l = (2. * VoH) * h - v; // -reflect(v, h);\n            float NoL = clamp(dot(n, l),0.,1.);\n            float NoH = clamp(dot(n, h),0.,1.);\n\n            float F = fresnel(f0, VoH);\n            \n            if (NoL==0.){ // attempt second bounce off microsurface\n                \n                vec3 v=l;\n                vec3 h = n;\n\n                float VoH = clamp(dot(v, h),0.,1.);\n                vec3 l = (2. * VoH) * h - v; // -reflect(v2, h);\n                float NoL = clamp(dot(n, l),0.,1.);\n                float NoH = clamp(dot(n, h),0.,1.);\n                float NoV = clamp(dot(n, v),0.,1.);\n\n                float F2 = fresnel(f0, VoH);\n                \n                specularc += srgbToLinear(texture(iChannel0, -l).rgb) * F * F2 * normalization(alpha, NoV, NoL);\n            } else {\n                specularc += srgbToLinear(texture(iChannel0, -l).rgb) * F * normalization(alpha, NoV, NoL);\n            }\n            \n        }\n        vec3 color = (specularc + diffusec) / float(steps) ;\n        vec3 l = normalize(vec3(.5,-1,0));\n        float NoL = clamp(dot(n,l),0.,1.);\n        float LoV = dot(l,v);\n        color+=specularPointLight(NoL, NoV, LoV, roughness, f0)*0.5;\n        color+= diffuse(NoL, NoV, LoV, roughness, albedo) * NoL*0.5;\n        \n        return color;\n\t}\n\t\n\treturn col;\n}\n\nvec3 rotate(vec3 p, float theta){\n    mat2 m = mat2(\n        cos(theta),-sin(theta),\n        sin(theta), cos(theta));\n    \n    p.xz = m*p.xz;\n        \n\treturn p;\n}\nvec3 camera(vec2 fragCoord){\n\tvec2 rd = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\n\tfloat time = iTime * 0.2;\n\tvec3 rayDir = rotate(normalize(vec3(rd.x, rd.y, 1.0)), time);\n\tvec3 rayPos = rotate(vec3(0.0, 0.0, 9.0), time);\n\t\t\n\treturn trace(rayPos, rayDir, fragCoord);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\tvec3 col = camera(fragCoord.xy);\n\t\t\n\tfragColor.rgb = linearToSrgb(col);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //fragColor.rgb=vec3( fresnel(uv.x,uv.y) );\n    if(fragColor.r==1./0.)fragColor.rgb=vec3(1,0,0);\n    if(fragColor.r<0.)fragColor.rgb=vec3(1,0,0);\n}","name":"Image","description":"","type":"image"}]}