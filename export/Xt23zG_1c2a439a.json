{"ver":"0.1","info":{"id":"Xt23zG","date":"1429971567","viewed":1254,"name":"Experiment#DF4","username":"tomkh","description":"Repetition with overlap benchmark.\nTry changing SCENE and OVERLAP_SCENE, DEBUG_MODE.\nLighting is not perfect, I know. Prev.attempts: [url=https://www.shadertoy.com/view/ltSGRG]ltSGRG[/url] and [url=https://www.shadertoy.com/view/llSGRy]llSGRy[/url]. ","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefields","benchmark"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Just for my own educational purposes...\n// Extended from my previous attempt: llSGRy\n// tomkh@2015\n\n#define SCENE 2\n//   0 = centered bboxes\n//   1 = centered decorated bboxes\n//   2 = non-centered bboxes\n//   3 = non-centered decorated\n\n#define OVERLAP_SCENE 2\n//   0 = coins\n//   1 = pipes\n//   2 = tori\n//   To show nothing just comment out OVERLAP.\n\n// Enable to test overlap (must be less than 0.5):\n#define OVERLAP 0.1\n\n// Enable to debug distance field:\n#define DEBUG_MODE 1\n//   0 = no debug\n//   1 = show DF plane\n//   2 = show all DF slices\n\n// Enable experimental AO (I still need to work on it):\n//#define TEST_AO\n\n#define VIEW_DIST 1\n//   0 = short distance\n//   1 = middle\n//   2 = far\n\n#if VIEW_DIST == 0\n\tconst int ray_steps = 160;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 20.0;\n\tconst float cam_tilt = -.2;\n#elif VIEW_DIST == 1\n\tconst int ray_steps = 80;\n\tconst float dist_max = 20.0;\n\tconst float fog_start = 25.0;\n\tconst float fog_density = 0.05;\n\tconst float cam_dist = 30.0;\n\tconst float cam_tilt = -.4;\n#else\n\tconst int ray_steps = 80;\n\tconst float dist_max = 200.0;\n\tconst float fog_start = 100.0;\n\tconst float fog_density = 0.02;\n\tconst float cam_dist = 80.0;\n\tconst float cam_tilt = -.4;\n#endif\nconst float floor_plane = -5.0;\n\n// Tile space:\nconst float tile_d = 2.0;\nconst float tile_ood = 1.0/tile_d;\n\nmat3 tori_rot[2];\n\n// P-----+-----Q\n// |     |     |\n// |  A--|--B  |\n// |  |p |  |  |\n// +-----+-----+\n// |  |  |  |  |\n// |  C--|--D  |\n// |     |     |\n// R-----+-----S\n// Say we want to find DF(p) = a distance field for \"p\",\n// and \"p\" is inside ABCD boundary, where A,B,C,D are our tile centers.\n// We have to assume max/min height.\n// We call \"frame\", a bounding area of everything outside PQRS (estimated using max/min height).\n// Algorithm:\n//   For \"p\" we evaluate DF for 4 tiles: A,B,C,D\n//   (possibly with early-out optimization with rough distance estimation)\n//   and we bound it additionally to distance to PQRS frame.\n\nfloat dist2frame(vec3 p, float box_y)\n{\n#ifdef OVERLAP\n    vec3 dp = vec3(\n        tile_d*(1.0-OVERLAP)-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d*(1.0-OVERLAP)-abs(p.z));\n#else\n    vec3 dp = vec3(\n        tile_d-abs(p.x),\n        max(0.0,abs(p.y)-box_y),\n        tile_d-abs(p.z));\n#endif\n    return length(vec2(min(dp.x,dp.z),dp.y));\n}\n\nfloat dist2box(vec3 p, float box_x, float box_y, float box_z, float box_r)\n{\n    // Distance to rounded box:\n    vec3 dp = vec3(\n        max(0.0,abs(p.x)-box_x),\n        max(0.0,abs(p.y)-box_y),\n        max(0.0,abs(p.z)-box_z));\n    return length(dp) - box_r;\n}\n\nfloat dist2pipe(vec3 p, float r, float h, float cap)\n{\n    float dxz = length(p.xz) - r;\n    float dy = max(0.0, abs(p.y) - h);\n    return length(vec2(dxz,dy)) - cap;\n}\n\nfloat dist2cyl(vec3 p, float r, float h, float cap)\n{\n    float dxz = max(0.0, length(p.xz) - r);\n    float dy = max(0.0, abs(p.y) - h);\n    return length(vec2(dxz,dy)) - cap;\n}\n\nfloat evaluate_tile(vec3 p, vec3 p_id, float dx, float dy)\n{\n    p_id.xz += vec2(dx,dy);\n    p.xz -= vec2(dx-.5,dy-.5)*tile_d;\n    float anim = iTime*.25;\n    float p1, dist;\n    p1 = sin(p_id.x+anim)*sin(p_id.z+anim*.33);\n#ifdef OVERLAP\n    float r = tile_d*(.5 + OVERLAP);\n    #if OVERLAP_SCENE == 0\n    \tdist = dist2cyl(vec3(p.x,p.y-p1*.25,p.z),r-.25,.0,.25);\n    #elif OVERLAP_SCENE == 1\n    \tdist = dist2pipe(vec3(p.x,p.y-p1*2.0,p.z),r-.25,1.75,.25);\n    #else\n    \tmat3 rot = (mod(p_id.x*.17 + p_id.z*.71,2.0)<1.0) ? tori_rot[0] : tori_rot[1];\n        dist = dist2pipe(vec3(p.x,p.y-p1*3.0,p.z)*rot,r-.25,.0,.25);\n    #endif\n#else\n    dist = 1e32;\n#endif\n#if SCENE >= 2\n    p1 = 4.0 - abs(p1)*3.9;\n    float id = p_id.x + p_id.z;\n    vec3 p2 = p + vec3(cos(id*3.0+anim*1.11),0,sin(id*3.0+anim*1.11))*.5;\n    dist = min(dist, dist2box(p2, .25, p1, .25, 0.025));\n    #if SCENE == 3\n    \t//if (dist > .3) return dist - .1; // simple early-out optimziation\n    \tdist = min(dist, dist2box(p2 - vec3(0,p1*.333,0), .25, .0, .25, .1));\n        dist = min(dist, dist2box(p2 - vec3(0,p1*.666,0), .25, .0, .25, .1));\n    #endif\n#else\n    p1 = 4.0 - abs(p1)*3.8;\n    float p2 = 0.2 + abs(cos(p_id.x+anim*.5)*cos(p_id.z+anim*.66))*.7;\n    dist = min(dist, dist2box(p, p2, p1, p2, 0.025));\n    #if SCENE == 1\n        //if (dist > .2) return dist - .1; // simple early-out optimziation\n        dist = min(dist, dist2box(p, p2+.1, p1-.1, .1, 0.025));\n        dist = min(dist, dist2box(p, .1, p1-.1, p2+.1, 0.025));\n    #endif\n#endif\n    return dist;\n}\n\nfloat get_distance(vec3 p)\n{\n    vec3 p_id = vec3(\n        floor(p.x*tile_ood),\n        0,\n        floor(p.z*tile_ood));\n    \n    p = vec3(\n        (fract(p.x*tile_ood)-.5)*tile_d,\n        p.y, //(fract(p.y*tile_ood)-.5)*tile_d,\n        (fract(p.z*tile_ood)-.5)*tile_d);\n    \n    float dist = dist2frame(p, 4.25);\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 0.0));\n    dist = min(dist, evaluate_tile(p, p_id, 0.0, 1.0));\n    dist = min(dist, evaluate_tile(p, p_id, 1.0, 1.0));\n\n    dist = min(dist, abs(p.y - floor_plane));\n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n    const float eps = 1e-3;\n    const vec3 x_eps = vec3(eps,0,0);\n    const vec3 y_eps = vec3(0,eps,0);\n    const vec3 z_eps = vec3(0,0,eps);\n    return normalize(vec3(\n        get_distance(p + x_eps) - get_distance(p - x_eps),\n        get_distance(p + y_eps) - get_distance(p - y_eps),\n        get_distance(p + z_eps) - get_distance(p - z_eps) ));\n}\n\nfloat get_ao(vec3 hit, vec3 n)\n{\n#ifdef TEST_AO\n    // TODO: this AO sux, so would be nice to implement better approximation ;)\n    const float ao_step = .1;\n    float ao_dist, ao_len, d;\n    hit += n*ao_step;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len = d;\n    hit += n*ao_dist;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len += d;\n    hit += n*ao_dist;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len += d;\n    hit += n*ao_dist;\n    ao_dist = get_distance(hit); d = ao_dist*ao_dist; ao_len += d;\n    return clamp(0.0,1.0,ao_len*1.5);\n#else\n    return 1.0; // no AO for now looks better :(\n#endif\n}\n\nvec3 trace(vec3 p_start, vec3 n)\n{\n#if DEBUG_MODE != 2\n    float ray_len;\n    float dist;\n    const float dist_eps = .001;\n    vec3 p = p_start;\n    for(int k=0; k<ray_steps; ++k) {\n    \tdist = get_distance(p);\n        if (dist < dist_eps || dist > dist_max) break;\n        p += dist*n;\n        ray_len += dist;\n    }\n    \n    //vec3 light_dir = normalize(vec3(.1,1.0,-.3));\n    float light_ang = (iMouse.x/iResolution.x-.5) + 1.0;\n    vec3 light_dir = normalize(vec3(cos(light_ang),2.0,-sin(light_ang)));\n    vec3 normal = get_normal(p);\n    float shade = 0.0;\n    float specular = 0.0;\n    vec3 base_color = vec3(1.0,1.0,1.0);\n    if (dist < dist_eps) {\n        if (p.y < floor_plane + dist_eps*2.0) {\n            float d = (p_start.y - floor_plane) / -n.y;\n        \tvec3 hit = p_start + n*d;\n            float pattern = mod(floor(hit.x/tile_d)+floor(hit.z/tile_d),2.0);\n            base_color = mix(vec3(.2,.4,.6),vec3(.4,.6,.8),pattern);\n        }\n        //shade = (1.0 - dist/dist_eps)*dot(normal, light_dir);\n        shade = dot(normal, light_dir);\n        shade = max(0.0, shade);\n        shade *= get_ao(p,normal);\n        specular = max(0.0,dot(n, light_dir - normal*dot(normal,light_dir)*2.0));\n        specular = pow(specular,32.0)*.25;\n    }\n        \n    vec3 color = mix(vec3(0.,.1,.3),vec3(1.,1.,.9),shade)*base_color;\n    color += vec3(1.,1.,1.)*specular;\n\n    // Test ray with cut_plane:\n#if DEBUG_MODE == 1\n    float cut_plane = (iMouse.y / iResolution.y - 0.1) * 8.0;\n    cut_plane = max(0.0, cut_plane);\n    if (n.y*sign(p_start.y-cut_plane) < 0.0) {\n        float d = (p_start.y - cut_plane) / -n.y;\n        if (d < ray_len) {\n            vec3 hit = p_start + n*d;\n            float hit_dist = get_distance(hit);\n            float iso = fract(hit_dist*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            dist_color *= 1.0/(max(0.0,hit_dist)+.001);\n            //dist_color = min(vec3(1.0,1.0,1.0),dist_color);\n            color = mix(color,dist_color,.25);\n            ray_len = d;\n        }\n    }\n#endif\n    vec3 fog_color = vec3(.8,.8,.8);\n    float fog = 1.0-1.0/exp(max(0.0,ray_len-fog_start)*fog_density);\n    color = mix(color,fog_color,fog);\n#else\n    vec3 color = vec3(0.,.1,.3);\n   \n    for(float cut_plane = 4.0; cut_plane >= 0.0; cut_plane -= 0.1) {\n        // Test ray with cut_plane:\n        if (n.y*sign(p_start.y-cut_plane) < 0.0) {\n            float d = (p_start.y - cut_plane) / -n.y;\n            vec3 hit = p_start + n*d;\n            float hit_dist = get_distance(hit);\n            float iso = fract(hit_dist*5.0);\n            vec3 dist_color = mix(vec3(.2,.4,.6),vec3(.2,.2,.4),iso);\n            dist_color *= 1.0/(max(0.0,hit_dist)+.05);\n            color += dist_color*.02*cut_plane*.25;\n        }\n    }\n#endif\n\n\treturn color;\n}\n\nmat3 from_axis_angle(float angle, vec3 axis) {\n  \tfloat si, co, ti, tx, ty, tz, sx, sy, sz;\n\n    si = sin(angle);\n    co = cos(angle);\n    ti = 1.0 - co;\n\n    tx = ti * axis.x; ty = ti * axis.y; tz = ti * axis.z;\n    sx = si * axis.x; sy = si * axis.y; sz = si * axis.z;\n\n    return mat3(\n        tx * axis.x + co, tx * axis.y + sz, tx * axis.z - sy,\n        tx * axis.y - sz, ty * axis.y + co, ty * axis.z + sx,\n        tx * axis.z + sy, ty * axis.z - sx, tz * axis.z + co\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    \n    float anim = iTime*.25;\n    \n    float a = -0.2; //iMouse.x / iResolution.x * 2.0 - 1.0; \n    a += cos(anim)*.05;\n    float co = cos(a);\n    float si = sin(a);\n    vec3 p1 = vec3(-cam_dist*si, 0, -cam_dist*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    //a = iMouse.y / iResolution.y * 2.0 + sin(anim*(2.0/3.0))*.2 - 2.0;\n    a = cam_tilt;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n#if defined(OVERLAP) && OVERLAP_SCENE == 2\n    tori_rot[0] = from_axis_angle(anim, normalize(vec3(.5,.2,.3)));\n\ttori_rot[1] = from_axis_angle(anim+2.0, normalize(vec3(.3,.7,-.2)));\n#endif\n    \n    fragColor = vec4(trace(p2, n3), 1.0);\n    \n}\n","name":"","description":"","type":"image"}]}