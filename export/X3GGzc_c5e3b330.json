{"ver":"0.1","info":{"id":"X3GGzc","date":"1717963316","viewed":75,"name":"Antialiased Sphere","username":"OscarSaharoy","description":"using a 1.414px interpolation zone along the edge of the sphere to blend to the background and remove the jagged edge. On the left is standard and the right is antialiased","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sphere","antialiasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159\n\n\nvec4 intersectSphere(\n    vec3 rayOrigin, vec3 rayDir, float pxAngle,\n    vec3 sphereCentre, float sphereRadius\n) {\n\n    vec3 ro = rayOrigin;\n    vec3 rd = rayDir;\n    vec3 c  = sphereCentre;\n    float R = sphereRadius;\n\n    vec4 result = vec4(0.0);\n\n    vec3 ro2c = c - ro;\n    float distToClosest = dot(rd, ro2c);\n    vec3 closestPoint = ro + rd * distToClosest;\n    float centreToClosest = length(\n        closestPoint - sphereCentre\n    );\n    \n    // ============================ antialias ===================================\n    \n    float pxDist = pxAngle * length(ro - c);\n    result.w = clamp( -(centreToClosest - R) / 1.414 / pxDist, 0., 1. );\n    \n    // ==========================================================================\n\n    if( distToClosest > 0. )\n        result.xyz = closestPoint;\n\n    if( centreToClosest > R )\n        return result;\n\n    float closestToIntersect = sqrt(\n        R*R - centreToClosest*centreToClosest\n    );\n    float distToSphere = distToClosest - closestToIntersect;\n    float distThroughSphere =\n        closestToIntersect * 2. + min(0., distToSphere);\n\n    if( distThroughSphere < 0. )\n        return result;\n\n    vec3 intersect =\n        rayOrigin + max(0., distToSphere) * rayDir;\n\n    result.xyz = intersect;\n    \n\n    return result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3 miResolution = fragCoord.y < iResolution.y / 2. ? iResolution / 5. : iResolution;\n    vec2 mFragCoord = fragCoord.y < iResolution.y / 2. ? fragCoord / 5. : fragCoord;\n    mFragCoord -= mod(mFragCoord, vec2(1)) - .5;\n\n    vec3 viewPos = vec3(sin(iTime*.4), cos(iTime*.4), 0);\n    float fov = pi * .4;\n    vec3 viewDir = getViewDir( mFragCoord, viewPos, miResolution, fov );\n    \n    float pxAngle = mFragCoord.x > miResolution.x / 2. ? fov / miResolution.x : 0.0001;\n    vec3 sphereCentre = vec3(0);\n    float sphereRadius = 0.2;\n    \n    vec4 sphereIntersect = intersectSphere( viewPos, viewDir, pxAngle, sphereCentre, sphereRadius );\n    \n    vec4 envLight = texture(iChannel0, mat3(1,0,0,0,0,1,0,1,0) * viewDir);\n    fragColor = envLight;\n    \n    if( sphereIntersect.w != 0. )\n        fragColor = mix( envLight, vec4(sphereIntersect.xyz * 5., 1), sphereIntersect.w );\n    \n    vec2 offsetFragCoord = fragCoord - iResolution.xy / 2.;\n    if( abs(offsetFragCoord.x) < 1. || abs(offsetFragCoord.y) < 1. )\n        fragColor = vec4(1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec3 getViewDir(\n    vec2 fragCoord, vec3 viewPos, vec3 iResolution,\n    float fov\n) {\n\n    vec3 toward = normalize( -viewPos );\n    vec3 up = vec3( 0, 0, 1 );\n    vec3 right = normalize( cross( toward, up ) );\n    vec3 over = cross( right, toward );\n\n    vec2 uv = (fragCoord - iResolution.xy/2.)\n        / iResolution.x;\n        \n    float l = .5 / tan( fov / 2. );\n\n    return normalize(\n        l * toward\n        + uv.x * right\n        + uv.y * over\n    );\n}\n","name":"Common","description":"","type":"common"}]}