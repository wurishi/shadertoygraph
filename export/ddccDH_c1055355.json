{"ver":"0.1","info":{"id":"ddccDH","date":"1694992853","viewed":112,"name":"Agate growth","username":"stb","description":"(Not a real-world simulation.)\n\nMove the mouse to adjust light, press 'r' for new shape.","likes":15,"published":1,"flags":48,"usePreview":0,"tags":["2d","shading","bump","quartz","silica"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define res iResolution.xy\n\nfloat map (vec2 uv, vec2 p) {\n    vec2 pos = texture(iChannel0, uv).rg;\n    \n    //float r = fract(length(p-pos));\n    return min(.25, length(p-pos));\n}\n\nvec3 getNorm(vec2 uv, vec2 p) {\n    vec3 o = 2. * vec3(-1., 0., 1.) / res.y;\n    return\n        normalize(\n            vec3(\n                map(uv, p-o.xy) - map(uv, p-o.zy),\n                map(uv, p-o.yx) - map(uv, p-o.yz),\n                1./res.y\n            )\n        );\n}\n\nvoid mainImage(out vec4 fo, in vec2 fc) {\n    vec2 uv = fc.xy / res;\n    vec2 p = (fc.xy-res/2.) / res.y;\n    \n    // mouse position\n    vec2 m = 1.74 * (iMouse.xy-res/2.) / res.y;\n    \n    // agate distance\n    float d = map(uv, p);\n    \n    // initial rgb value\n    vec3 rgb = vec3(0.);\n    \n    // normal\n    vec3 norm = 4. * getNorm(uv, p);\n    \n    // light position\n    vec2 lpos = vec2(m);\n    \n    // background\n    vec3 bg = mix(vec3(.5), texture(iChannel1, uv).rgb, .5);\n    \n    // drop shadow, just a basic circular gradient\n    bg -= .3 * max(0., -4. * (length(p+.3*lpos) - .5));\n    \n    // fake caustic (color is hard-coded)\n    bg += max(vec3(0.), -2.5*vec3(1., .7, .5) * (length(p+.15*lpos) - .45));\n    \n    // agate striations\n    rgb += texture(iChannel1, vec2(d, .2)*.2).rgb;\n    \n    // a bit of texture noise\n    rgb += .15 * bg;\n    \n    // refractive effect / background lighting\n    float refr = .1 * (1. - 3. * length(p-m-norm.xy/10.));\n    rgb += refr;\n    bg += .5 * refr;\n    \n    // bluish interior\n    rgb = mix(rgb, vec3(.3, .5, .7), d);\n    \n    \n    // 'density'\n    rgb *= max(.75, 12. * abs(d-.125));\n    \n    // 'specular'\n    m *= 1.5;\n    vec3 spec = mix(rgb, vec3(1.5), .5*pow(max(0., 1.-8.*dot(p-m, p-m)), 2.));\n    rgb += spec;\n    \n    //bg = mix(bg, vec3(0.), float(map(uv, p+lpos/10.)<-.15));\n    \n    // select bewtween background and agate\n    rgb = mix(bg, rgb, smoothstep(0., 2./res.y, d));\n    \n    //rgb = vec3( float(map(uv, p)>0.) );\n    \n    fo = vec4(rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// hash without sine: https://www.shadertoy.com/view/4djSRW\n#define MOD3 vec3(443.8975, 397.2973, 491.1871) // uv range\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n// a time-based, pseudo-random float\nfloat trand(vec2 p){ return hash12(mod(p+iDate.w/10., 100.));}\n\n// texture definition\n#define tx(o) texture( iChannel0, uv+o/res )\n\nvoid mainImage( out vec4 fo, in vec2 fc ) {\n\tvec2 res = iResolution.xy;\n    vec2 uv = fc / res;\n    vec2 p = (fc.xy-res/2.) / res.y;\n    vec3 o = vec3(-1., 0., 1.);\n    \n    // texture sample directions\n    // s[7] s[4] s[8]\n\t// s[1] s[0] s[2]\n\t// s[5] s[3] s[6]\n    \n    vec4 s[9];\n    \n    s[0] = tx(o.yy);\n    \n    s[1] = tx(o.xy);\n    s[2] = tx(o.zy);\n    s[3] = tx(o.yx);\n    s[4] = tx(o.yz);\n    \n    s[5] = tx(o.xx);\n    s[6] = tx(o.xz);\n    s[7] = tx(o.zx);\n    s[8] = tx(o.zz);\n    \n    // position vector\n    vec2 pos;\n    \n    // Set pixels for first frame or when 'r' is pressed\n    if(iFrame==0 || length(p)>.5 || texture(iChannel2, vec2(82.5/256., .2)).r>0.) {\n        if(length(p) > .5-.23*texture(iChannel1, p/2.+mod(iDate.w/vec2(5., 13.777), 100.)).r) {\n            pos = p;\n        }\n        else {\n            pos = vec2(8.);\n        }\n    }\n    \n    // Set pixels for all other frames\n    else{\n        // this cell's position\n        pos = s[0].rg;\n        \n        // save position\n        vec2 opos = pos;\n        \n        // loop through neighbors\n        float lpos;\n        for(int i=1; i<9; i++) {\n        \n            // attempt to round things out by randomly bailing out on corner samples\n            if(i>4 && trand(p+2.34) < .9)\n                break;\n                \n            // sample neighboring position\n            vec2 ipos = s[i].rg;\n\n            // compare distance-to-pos with distance-to-ipos\n            // ...and rewrite pos when the latter is less than the former\n            lpos = length(pos-p);\n            if(length(ipos-p) < lpos)\n                pos = ipos;\n        }\n        \n        // move a newly-adjusted position randomly for unset cells\n        float rndamt = 1.; // random amount\n        if(length(opos) > 4.)\n            pos += rndamt / res.y * (.5-hash22(mod(uv+iDate.w/10., 100.)));\n        \n    }\n    \n    // output\n\tfo = vec4(pos, 0., 1.);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Buffer A","description":"","type":"buffer"}]}