{"ver":"0.1","info":{"id":"XsVGzR","date":"1453022885","viewed":799,"name":"Vortex Pair Warp [Style Net]","username":"Flexi","description":"Remake of http://cake23.de/vortex-pair-warp.html - Use mouse drag to smear\nThe pyramid still has a little offset issue and the net is not supposed to shift\nI'm slowly getting used to the idea that i must use a custom linear interpolation lookup function","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["blur","pyramid","missionary"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel1, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixelSize = 1. / iResolution.xy;\n    vec2 uv = fragCoord.xy * pixelSize;\n\n    vec2 d = pixelSize*4.;\n    vec2 gx;\n    gx.x = BlurA(uv-vec2(1.,0.)*d, 0).x - BlurA(uv+vec2(1.,0.)*d, 0).x;\n    gx.y = BlurA(uv-vec2(0.,1.)*d, 0).x - BlurA(uv+vec2(0.,1.)*d, 0).x;\n\n    float r_lo = BlurA(uv + gx*pixelSize *192., 4).r;\n\n    float r_hi = BlurA(uv - gx*pixelSize *2., 1).r*4. - BlurA(uv + gx*pixelSize *192.*0., 0).r*14.;\n\n    fragColor = vec4(1.2,0.9,0.3,1.) * r_lo;\n    fragColor = mix(fragColor, vec4(0.9,1.,1.4,1.), r_hi);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define pi 3.141592653589793238462643383279\n#define pi_inv 0.318309886183790671537767526745\n#define pi2_inv 0.159154943091895335768883763372\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec2 mouseDelta(){\n    vec2 pixelSize = 1. / iResolution.xy;\n    float eighth = 1./8.;\n    vec4 oldMouse = texture(iChannel3, vec2(7.5 * eighth, 2.5 * eighth));\n    vec4 nowMouse = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    if(oldMouse.z > pixelSize.x && oldMouse.w > pixelSize.y && \n       nowMouse.z > pixelSize.x && nowMouse.w > pixelSize.y)\n    {\n        return nowMouse.xy - oldMouse.xy;\n    }\n    return vec2(0.);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel1, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec2 complex_mul(vec2 factorA, vec2 factorB){\n    return vec2( factorA.x*factorB.x - factorA.y*factorB.y, factorA.x*factorB.y + factorA.y*factorB.x);\n}\n\nvec2 spiralzoom(vec2 domain, vec2 center, float n, float spiral_factor, float zoom_factor, vec2 pos){\n    vec2 uv = domain - center;\n    float d = length(uv);\n    return vec2( atan(uv.y, uv.x)*n*pi2_inv + d*spiral_factor, -log(d)*zoom_factor) + pos;\n}\n\nvec2 complex_div(vec2 numerator, vec2 denominator){\n    return vec2( numerator.x*denominator.x + numerator.y*denominator.y,\n                numerator.y*denominator.x - numerator.x*denominator.y)/\n        vec2(denominator.x*denominator.x + denominator.y*denominator.y);\n}\n\nfloat circle(vec2 uv, vec2 aspect, float scale){\n    return clamp( 1. - length((uv-0.5)*aspect*scale), 0., 1.);\n}\n\nfloat sigmoid(float x) {\n    return 2./(1. + exp2(-x)) - 1.;\n}\n\nfloat smoothcircle(vec2 uv, vec2 aspect, float radius, float ramp){\n    return 0.5 - sigmoid( ( length( (uv - 0.5) * aspect) - radius) * ramp) * 0.5;\n}\n\nfloat conetip(vec2 uv, vec2 pos, float size, float min)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    return max( min, 1. - length((uv - pos) * aspect / size) );\n}\n\nfloat warpFilter(vec2 uv, vec2 pos, float size, float ramp)\n{\n    return 0.5 + sigmoid( conetip(uv, pos, size, -16.) * ramp) * 0.5;\n}\n\nvec2 vortex_warp(vec2 uv, vec2 pos, float size, float ramp, vec2 rot)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n\n    vec2 pos_correct = 0.5 + (pos - 0.5);\n    vec2 rot_uv = pos_correct + complex_mul((uv - pos_correct)*aspect, rot)/aspect;\n    float _filter = warpFilter(uv, pos_correct, size, ramp);\n    return mix(uv, rot_uv, _filter);\n}\n\nvec2 vortex_pair_warp(vec2 uv, vec2 pos, vec2 vel)\n{\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    float ramp = 4.;\n\n    float d = 0.1;\n\n    float l = length(vel);\n    vec2 p1 = pos;\n    vec2 p2 = pos;\n\n    if(l > 0.){\n        vec2 normal = normalize(vel.yx * vec2(-1., 1.))/aspect;\n        p1 = pos - normal * d / 2.;\n        p2 = pos + normal * d / 2.;\n    }\n\n    float w = l / d * 2.;\n\n    // two overlapping rotations that would annihilate when they were not displaced.\n    vec2 circle1 = vortex_warp(uv, p1, d, ramp, vec2(cos(w),sin(w)));\n    vec2 circle2 = vortex_warp(uv, p2, d, ramp, vec2(cos(-w),sin(-w)));\n    return (circle1 + circle2) / 2.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 noise = texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime));\n\n    if(iFrame<10)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    vec2 mouseV = mouseDelta();\n    vec2 aspect = vec2(1.,iResolution.y/iResolution.x);\n    vec2 pixelSize = 1. / iResolution.xy;\n\n    uv = vortex_pair_warp(uv, iMouse.xy*pixelSize, mouseV*aspect*1.4);\n\n    fragColor = BlurA(uv, 0);\n    fragColor += ((BlurA(uv, 1) - BlurA(uv, 2))*0.5 + (noise-0.5) * 0.004); \n\n    vec2 d = pixelSize*3.5;\n    vec2 gx;\n    gx.x = BlurA(uv-vec2(1.,0.)*d, 3).x - BlurA(uv+vec2(1.,0.)*d, 3).x;\n    gx.y = BlurA(uv-vec2(0.,1.)*d, 3).x - BlurA(uv+vec2(0.,1.)*d, 3).x;\n\n    vec2 uvr = uv + gx*7.*pixelSize;\n\n    float r = BlurA(uvr, 0).r;\n    r += (BlurA(uvr, 1).r - BlurA(uv, 4).r) * 22.5/256.; // \"reaction-diffusion\"\n    r += 2.25 / 256.;\n\n\tfragColor.r = r;\n    \n    fragColor = clamp(fragColor, 0., 1.);\n\n    //fragColor = noise; // reset\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 BlurA(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel0, fract(uv));\n    }\n\n    uv = upper_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvec4 BlurB(vec2 uv, int level)\n{\n    if(level <= 0)\n    {\n        return texture(iChannel1, fract(uv));\n    }\n\n    uv = lower_left(uv);\n    for(int depth = 1; depth < 8; depth++)\n    {\n        if(depth >= level)\n        {\n            break;\n        }\n        uv = lower_right(uv);\n    }\n\n    return texture(iChannel3, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 noise = texture(iChannel2, fragCoord.xy / iChannelResolution[2].xy + fract(vec2(42,56)*iTime));\n\n    if(iFrame<10)\n    {\n        fragColor = noise;\n        return;\n    }\n\n    float time = float(iFrame)/60.;\n    vec2 pixelSize = 1./iResolution.xy;\n\t\n    uv = uv + vec2(sin(time*0.1 + uv.x*2. +1.) - sin(time*0.214 + uv.y*2. +1.), sin(time*0.168 + uv.x*2. +1.) - sin(time*0.115 +uv.y*2. +1.))*pixelSize*1.5;\n\n    fragColor = BlurB(uv, 0);\n    fragColor += ((BlurB(uv, 3) - BlurB(uv, 5))*0.5 + (noise-0.5) * 0.004); \n\n    fragColor = clamp(fragColor, 0., 1.);\n\n    //fragColor = noise; // reset\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// resolution reduction and horizontal blur\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_horizontal(sampler2D channel, vec2 uv, float scale)\n{\n    float h = scale / iResolution.x;\n    vec4 sum = vec4(0.0);\n\n    sum += texture(channel, fract(vec2(uv.x - 4.0*h, uv.y)) ) * 0.05;\n    sum += texture(channel, fract(vec2(uv.x - 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x - 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x - 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 0.0*h, uv.y)) ) * 0.16;\n    sum += texture(channel, fract(vec2(uv.x + 1.0*h, uv.y)) ) * 0.15;\n    sum += texture(channel, fract(vec2(uv.x + 2.0*h, uv.y)) ) * 0.12;\n    sum += texture(channel, fract(vec2(uv.x + 3.0*h, uv.y)) ) * 0.09;\n    sum += texture(channel, fract(vec2(uv.x + 4.0*h, uv.y)) ) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvec4 blur_horizontal_left_column(vec2 uv, int depth)\n{\n    float h = pow(2., float(depth)) / iResolution.x;    \n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x - 4.0 * h, uv.y) * 2.);\n    uv2 = fract(vec2(uv.x - 3.0 * h, uv.y) * 2.);\n    uv3 = fract(vec2(uv.x - 2.0 * h, uv.y) * 2.);\n    uv4 = fract(vec2(uv.x - 1.0 * h, uv.y) * 2.);\n    uv5 = fract(vec2(uv.x + 0.0 * h, uv.y) * 2.);\n    uv6 = fract(vec2(uv.x + 1.0 * h, uv.y) * 2.);\n    uv7 = fract(vec2(uv.x + 2.0 * h, uv.y) * 2.);\n    uv8 = fract(vec2(uv.x + 3.0 * h, uv.y) * 2.);\n    uv9 = fract(vec2(uv.x + 4.0 * h, uv.y) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level >= depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel3, uv1) * 0.05;\n    sum += texture(iChannel3, uv2) * 0.09;\n    sum += texture(iChannel3, uv3) * 0.12;\n    sum += texture(iChannel3, uv4) * 0.15;\n    sum += texture(iChannel3, uv5) * 0.16;\n    sum += texture(iChannel3, uv6) * 0.15;\n    sum += texture(iChannel3, uv7) * 0.12;\n    sum += texture(iChannel3, uv8) * 0.09;\n    sum += texture(iChannel3, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    if(uv.x < 0.5)\n    {\n        vec2 uv_half = fract(uv*2.);\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_horizontal(iChannel0, uv_half, 1.);\n        }\n        else\n        {\n            fragColor = blur_horizontal(iChannel1, uv_half, 1.);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y > 0.5) || (uv.x <= 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_horizontal_left_column(uv_half, level);\n            uv = uv_half;\n        }\n    }\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// vertical blur (second pass)\n\nvec2 lower_left(vec2 uv)\n{\n    return fract(uv * 0.5);\n}\n\nvec2 lower_right(vec2 uv)\n{\n    return fract((uv - vec2(1, 0.)) * 0.5);\n}\n\nvec2 upper_left(vec2 uv)\n{\n    return fract((uv - vec2(0., 1)) * 0.5);\n}\n\nvec2 upper_right(vec2 uv)\n{\n    return fract((uv - 1.) * 0.5);\n}\n\nvec4 blur_vertical_upper_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, upper_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_lower_left(sampler2D channel, vec2 uv)\n{\n    float v = 1. / iResolution.y;\n    vec4 sum = vec4(0.0);\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 4.0*v)) ) * 0.05;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y - 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 0.0*v)) ) * 0.16;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 1.0*v)) ) * 0.15;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 2.0*v)) ) * 0.12;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 3.0*v)) ) * 0.09;\n    sum += texture(channel, lower_left(vec2(uv.x, uv.y + 4.0*v)) ) * 0.05;\n    return sum/0.98; // normalize\n}\n\nvec4 blur_vertical_left_column(vec2 uv, int depth)\n{\n    float v = pow(2., float(depth)) / iResolution.y;\n\n    vec2 uv1, uv2, uv3, uv4, uv5, uv6, uv7, uv8, uv9;\n\n    uv1 = fract(vec2(uv.x, uv.y - 4.0*v) * 2.);\n    uv2 = fract(vec2(uv.x, uv.y - 3.0*v) * 2.);\n    uv3 = fract(vec2(uv.x, uv.y - 2.0*v) * 2.);\n    uv4 = fract(vec2(uv.x, uv.y - 1.0*v) * 2.);\n    uv5 = fract(vec2(uv.x, uv.y + 0.0*v) * 2.);\n    uv6 = fract(vec2(uv.x, uv.y + 1.0*v) * 2.);\n    uv7 = fract(vec2(uv.x, uv.y + 2.0*v) * 2.);\n    uv8 = fract(vec2(uv.x, uv.y + 3.0*v) * 2.);\n    uv9 = fract(vec2(uv.x, uv.y + 4.0*v) * 2.);\n\n    if(uv.y > 0.5)\n    {\n        uv1 = upper_left(uv1);\n        uv2 = upper_left(uv2);\n        uv3 = upper_left(uv3);\n        uv4 = upper_left(uv4);\n        uv5 = upper_left(uv5);\n        uv6 = upper_left(uv6);\n        uv7 = upper_left(uv7);\n        uv8 = upper_left(uv8);\n        uv9 = upper_left(uv9);\n    }\n    else{\n        uv1 = lower_left(uv1);\n        uv2 = lower_left(uv2);\n        uv3 = lower_left(uv3);\n        uv4 = lower_left(uv4);\n        uv5 = lower_left(uv5);\n        uv6 = lower_left(uv6);\n        uv7 = lower_left(uv7);\n        uv8 = lower_left(uv8);\n        uv9 = lower_left(uv9);\n    }\n\n    for(int level = 0; level < 8; level++)\n    {\n        if(level > depth)\n        {\n            break;\n        }\n\n        uv1 = lower_right(uv1);\n        uv2 = lower_right(uv2);\n        uv3 = lower_right(uv3);\n        uv4 = lower_right(uv4);\n        uv5 = lower_right(uv5);\n        uv6 = lower_right(uv6);\n        uv7 = lower_right(uv7);\n        uv8 = lower_right(uv8);\n        uv9 = lower_right(uv9);\n    }\n\n    vec4 sum = vec4(0.0);\n\n    sum += texture(iChannel2, uv1) * 0.05;\n    sum += texture(iChannel2, uv2) * 0.09;\n    sum += texture(iChannel2, uv3) * 0.12;\n    sum += texture(iChannel2, uv4) * 0.15;\n    sum += texture(iChannel2, uv5) * 0.16;\n    sum += texture(iChannel2, uv6) * 0.15;\n    sum += texture(iChannel2, uv7) * 0.12;\n    sum += texture(iChannel2, uv8) * 0.09;\n    sum += texture(iChannel2, uv9) * 0.05;\n\n    return sum/0.98; // normalize\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uv_orig = uv;\n    vec2 uv_half = fract(uv*2.);\n    if(uv.x < 0.5)\n    {\n        if(uv.y > 0.5)\n        {\n            fragColor = blur_vertical_upper_left(iChannel2, uv_half);\n        }\n        else\n        {\n            fragColor = blur_vertical_lower_left(iChannel2, uv_half);\n        }\n    }\n    else\n    {\n        for(int level = 0; level < 8; level++)\n        {\n            if((uv.x > 0.5 && uv.y >= 0.5) || (uv.x < 0.5))\n            {\n                break;\n            }\n            vec2 uv_half = fract(uv*2.);\n            fragColor = blur_vertical_left_column(uv_half, level);\n            uv = uv_half;\n        }  \n    }\n    uv = uv_orig;\n    float eighth = 1./8.;\n    if(uv.x > 7.*eighth && uv.x < 8.*eighth && uv.y > 2.*eighth && uv.y < 3.*eighth)\n    {\n        fragColor = vec4(iMouse.xy / iResolution.xy, iMouse.zw / iResolution.xy);\n    }\n}","name":"Buf D","description":"","type":"buffer"}]}