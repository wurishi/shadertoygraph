{"ver":"0.1","info":{"id":"DlfcRX","date":"1693405116","viewed":83,"name":"Happy jumping raymarcher","username":"vizaxo","description":"Roughly following IQ's tutorial: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarcher","animation","creature","happyjumping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n\nconst float epsilon = 0.001;\nconst float farPlane = 100.0;\n\n#define time iTime\n#define dist iTime\n\n#define HIT vec2\n\nuint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat fhash(float x) { return uintBitsToFloat(hash(floatBitsToUint(x))); }\n\nfloat noise(vec2 i) {\n    return fhash(fhash(i.x) * i.y);\n}\n\n//-------\n// SDFs \n//-------\n\nfloat sdSphere(vec3 p, float r) { return length(p) - r; }\nfloat sdYPlane(vec3 p) { return p.y; }\nvec2 sdU(vec2 a, vec2 b) { if (a.x < b.x) return a; else return b; }\nfloat square(float x) { return x*x; }\nfloat sdElipsoid(vec3 p, vec3 r) {\n    float k0 = length(p/r);\n    float k1 = length(p/r/r);\n    return k0*(k0-1.)/k1;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.0);\n    return min(a,b) - h*h/(k*4.0);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = max(k - abs(a-b), 0.0);\n    return max(a,b) + h*h/(k*4.0);\n}\n\nvec2 sdCharacter(vec3 p) {\n    float t = fract(time);\n    float t2 = fract(time-0.05);\n    float y = 4.*(1.-t)*t;\n    float dy = 4.0*(1.0-2.0*t);\n    \n    //float sy = 0.5+0.5*(4.*(1.-t2)*t2);\n    float sy = 1.0-abs(mod(t+0.21,1.0)-0.5)*1.0+0.5;\n    float sz = 1./sy;\n    \n    float height = clamp(y-0.08, 0., 1.);\n    \n    vec3 r = vec3(0.25*sqrt(sz), 0.25*sy, 0.25*sqrt(sz));\n    vec3 c = vec3(0., height+0.32, dist);\n    vec3 q = p - c;\n    \n    vec2 res;\n    //body\n    float body = sdElipsoid(q, r);\n    \n    //head\n    vec3 h = q-vec3(0.0, 0.28, 0.0);\n    float head = sdElipsoid(h, vec3(0.2));\n        \n    h.x = abs(h.x);\n    //eyebrows\n    vec3 eb = h - vec3(0.13, 0.10, 0.15);\n    eb.xy = (mat2(8,15,-15,8)/17.0)*eb.xy;\n    float eyebrows = sdElipsoid(eb, vec3(0.07, 0.04, 0.05));\n    head = smin(head, eyebrows, 0.05);\n    \n    //mouth\n    vec3 mo = h - vec3(0.0, -0.07 + 4.0*h.x*h.x, 0.2);\n    float mouth = sdElipsoid(mo, vec3(0.08, 0.038, 0.2));\n    head = smax(head, -mouth, 0.03);\n\n    //eyes\n    float eye = sdSphere( h - vec3(0.1, 0.05, 0.15), 0.05);\n    head = min(head, eye);\n    float d = smin(body, head, 0.05);\n    res = d<eye ? vec2(d, 2.0) : vec2(eye, 3.0);\n    \n    float pupil = sdSphere( h - vec3(0.12, 0.05, 0.22), 0.01);\n    res = res.x<pupil ? res : vec2(pupil, 4.0);\n    \n    return res;\n}\n\n\nvec2 scene(vec3 p) {\n    vec2 d = vec2(1000000.0,0);\n    \n    float groundHeight = -1.0 + sin(p.x/1.0+12.0)*0.10 + sin(p.z/1.0 + 1.2)*0.05;\n    float groundD = sdYPlane(p - vec3(0.0, groundHeight, 0.0));\n\n\n    float blobGridScale = 5.0;\n    vec2 blobId = vec2(floor(p.x / blobGridScale), floor(p.z / blobGridScale));\n    vec3 blobs = p;\n    blobs.x = mod(blobs.x,blobGridScale) - blobGridScale/2.;\n    blobs.z = mod(blobs.z,blobGridScale) - blobGridScale/2.;\n    //blobs.y -= fract(fhash(blobId.x) * fhash(blobId.y)) * 10.0;\n    float rnd1 = texture(iChannel0, blobId / 256.0).x;\n    if (rnd1 < 0.2) {\n        float rnd2 = texture(iChannel0, (blobId+vec2(3., 19.)) / 256.0).x;\n        rnd2 += time / 3.0;\n        rnd2 = fract(rnd2);\n        float blobY = rnd2 * 4.0 + (groundHeight - 1.5);\n        //blobY = mod(blobY + time, 5.0);\n        //blobY += time;\n        blobs.y -= blobY;\n\n        float blobScale = pow(1.-rnd2,0.5);\n        //float blobScale = smoothstep(0.2, 0.0, sin(100.0*p.x * 100.0*p.z));\n        groundD = smin(groundD, sdElipsoid(blobs, blobScale*vec3(1.0, 1.0, 1.0)), 1.0);\n    }\n\n    d = sdU(vec2(groundD, 1.0), sdCharacter(p-vec3(0.0, groundHeight, 0.0)));\n    \n    return d;\n}\n\n//-------\n// marching \n//-------\n\nvec2 march(vec3 ro, vec3 rd) {\n    vec2 d;\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 d = scene(ro + t*rd);\n        if (abs(d.x) < epsilon*t) {\n            d.x = t;\n            return d;\n        }\n        if (d.x > farPlane)\n            break;\n        t += d.x;\n    }\n    d.x = farPlane;\n    d.y = -1.0;\n    return d;\n}\n\nfloat castShadow(vec3 ro, vec3 rd) {\n    float t = epsilon*10.0;\n    float res = 100000.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        float d = scene(ro+t*rd).x;\n        res = min(res, 16.0*d/t);\n        if (d < epsilon) break;\n        if (t > farPlane) break;\n        t+=d;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 getNorm(vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p + vec3(epsilon, 0.0, 0.0))).x - scene(vec3(p - vec3(epsilon, 0.0, 0.0))).x,\n        scene(vec3(p + vec3(0.0, epsilon, 0.0))).x - scene(vec3(p - vec3(0.0, epsilon, 0.0))).x,\n        scene(vec3(p + vec3(0.0, 0.0, epsilon))).x - scene(vec3(p - vec3(0.0, 0.0, epsilon))).x\n        ));\n}\n\n//-------\n// main \n//-------\n\nvec3 draw(vec2 uv) {\n    // camera\n    vec2 mouse = iMouse.xy;\n    if (iMouse.x == 0.) mouse.x = iResolution.x/2.;\n    if (iMouse.y == 0.) mouse.y = iResolution.y/6.;\n    float angle = 5.0*mouse.x / iResolution.x + 3.9;\n    float height = mouse.y / iResolution.y - 0.20;\n    vec3 camPos = vec3(sin(angle), height, cos(angle)) * 4.0;\n    camPos += vec3(0., 0., dist);\n    //vec3 camPos = vec3(0.0, height, 1.0) * 3.0;\n    vec3 lookAt = vec3(0.0, camPos.y, dist);\n    vec3 worldUp = vec3(0.0, 1.0, 0.0);\n    vec3 camForward = normalize(lookAt - camPos);\n    vec3 camRight = normalize(cross(camForward, worldUp));\n    vec3 camUp = cross(camRight, camForward);\n    \n    //return camForward + vec3(0.5);\n    vec2 filmPlaneSize = vec2(1.0, iResolution.y / iResolution.x) * 0.3;\n    vec3 filmPlaneCentre = camPos + camForward * 0.3;\n    vec3 pixelPos = filmPlaneCentre\n        + uv.x * filmPlaneSize.x * camRight\n        + uv.y * filmPlaneSize.y * camUp;\n    vec3 ro = pixelPos;\n    vec3 rd = normalize(ro - camPos);\n    \n    // march\n    vec2 d = march(ro, rd);\n    float t = d.x;\n    float m = d.y;\n    vec3 p = ro + t*rd;\n    \n    \n    if (t >= farPlane) {\n        // sky\n        return mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.2, 4.0), pow(max(0.0,dot(rd, vec3(0.0, 1.0, 0.0)))+0.01, 0.2));\n        return vec3(0.0, 0.2, 1.0) * 0.3 + 0.5*  vec3(1.0, 1.0, 1.0)* smoothstep(0.2, -0.1, dot(rd, vec3(0.0, 1.0, 0.0)));\n    }\n    if (d.y < 0.0) return vec3(0.0);\n    \n    \n    //colours\n    vec3 material = vec3(0.2);\n    if (m < 1.5) {\n        // grass\n        float f = smoothstep(0.2, 0.5, sin(10.*p.x) * cos(11.*p.z) + 0.3*sin(1.*p.y));\n        material = vec3(0.05, 0.2, 0.02);\n        material += 0.01*f;\n        //material = clamp(vec3(0.0), vec3(1.0), material);\n        //material = vec3(0.1, 0.4, 0.1);\n    }\n    else if (m < 2.5) material = vec3(0.2, 0.1, 0.02); // body\n    else if (m < 3.5) material = vec3(0.3, 0.3, 0.3); // eyes\n    else if (m < 4.5) material = vec3(0.02); // pupils\n\n    \n    // ligting\n    vec3 sunDir = normalize(vec3(-3.0, -1.0, -2.0));\n    vec3 norm = getNorm(p);\n    // march returns normal or position?\n    float sunShadow = castShadow(p, -sunDir);\n\n    vec3 sunDif = sunShadow * max(0.0, dot(-sunDir, norm)) * vec3(8.0, 5.0, 3.0);\n    vec3 skyDif = max(0.0, 0.5 + 0.5*dot(vec3(0.0, 1.0, 0.0), norm)) * vec3(0.5, 0.8, 0.9);\n    vec3 bounceDif = max(0.0, dot(vec3(0.0, -1.0, 0.0), norm)) * vec3(0.8, 0.5, 0.3) * 0.2;\n\n    vec3 col = sunDif + skyDif + bounceDif;\n    col *= material;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = draw(uv - 0.5);\n    col = pow(col, vec3(0.4545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}