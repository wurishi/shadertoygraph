{"ver":"0.1","info":{"id":"WtjcRG","date":"1594680281","viewed":88,"name":"fancy perlin","username":"ni_cc","description":"perlin noise, with the values offset by another perlin noise, then plugged into a color ramp.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","perlin","color"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int firstNoiseLayer = 3;\nconst int noiseLayers = 5;\nconst float amplitudeMultPerLayer = 0.8;\n\nfloat noise(vec2 offset, int x, int y, int loop)\n{\n    float fx = mod(float(x), float(loop));\n    float fy = mod(float(y), float(loop));    \n    \n    return 2.0 * fract(sin(dot(offset + vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothedNoise(vec2 offset, int x, int y, int loop)\n{\n\treturn (noise(offset, x - 1, y - 1, loop) + noise(offset, x + 1, y - 1, loop) + noise(offset, x - 1, y + 1, loop) + noise(offset, x + 1, y + 1, loop)) / 16.0\n        + (noise(offset, x - 1, y, loop) + noise(offset, x + 1, y, loop) + noise(offset, x, y - 1, loop) + noise(offset, x, y + 1, loop)) / 8.0\n        + noise(offset, x, y, loop) / 4.0;\n}\n\n\nfloat interpolatedNoise(vec2 offset, vec2 p, int loop)\n{\n\tint ix = int(p.x);\n    int iy = int(p.y);\n    \n    float fx = p.x - float(ix);\n    float fy = p.y - float(iy);\n    \n    float v1 = smoothedNoise(offset, ix, iy, loop);\n    float v2 = smoothedNoise(offset, ix + 1, iy, loop);\n    float v3 = smoothedNoise(offset, ix, iy + 1, loop);\n    float v4 = smoothedNoise(offset, ix + 1, iy + 1, loop);\n    \n    float i1 = mix(v1, v2, fx);\n    float i2 = mix(v3, v4, fx);\n    \n    float i = mix(i1, i2, fy);\n    \n    return i;\n}\n\nfloat perlinNoise(vec2 uv)\n{\n\tfloat total = 0.0;\n    \n    float totalWeight = 0.0;\n    for (int i = firstNoiseLayer; i < noiseLayers + firstNoiseLayer; ++i)\n    {\n\t\tfloat frequency = pow(2.0, float(i));\n        float amplitude = pow(amplitudeMultPerLayer, float(i));\n        \n        vec2 offset = float(i-firstNoiseLayer) * vec2(8.0, 8.0);\n        \n        totalWeight += amplitude;\n        \n        total += interpolatedNoise(offset, uv * frequency, int(frequency)) * amplitude;\n    }\n    \n    total /= totalWeight;\n    \n    return total;\n}\n\nfloat lerp ( float percentage, float a, float b ) {\n    return a + percentage*(b-a);\n}\n\nvec3 lerp ( float percentage, vec3 a, vec3 b) {\n    return vec3(lerp(percentage,a.x,b.x),lerp(percentage,a.y,b.y),lerp(percentage,a.z,b.z));\n}\n\n// input 0 to 1\nvec3 colorRamp( float color ) {\n    vec3 pink = vec3(1.0,0.0,0.5);\n    vec3 green = vec3(0.0,1.0,0.5);\n    vec3 blue = vec3(0.0,0.0,1.0);\n    \n    if(color > 0.5) {\n    \treturn lerp((color-0.5)*2.0,green,blue);\n    } else {\n        //return pink;\n        return lerp(color*2.0,pink,green);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 metaOffset = vec2(iTime, sin(iTime)*1.0);\n    vec2 offset = vec2(perlinNoise(uv+metaOffset/20.0), perlinNoise(uv+metaOffset/20.0));\n    float value = (perlinNoise(uv+offset*5.0)+0.25)*2.0;\n    \n\n    // Output to screen\n    fragColor = vec4(colorRamp(value),1.0);\n}","name":"Image","description":"","type":"image"}]}