{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// sphere tracing transparent stuff\n// @simesgreen\n\nconst int maxSteps = 64;\nconst float hitThreshold = 0.01;\nconst float minStep = 0.01;\nconst float PI = 3.14159;\n\n#define TEST_OBJECT 0\n\nconst vec3 translucentColor = vec3(0.8, 0.2, 0.1)*3.0;\n//const vec3 translucentColor = vec3(0.2, 0.05, 0.5)*2.0;\n\nfloat difference(float a, float b)\n{\n    return max(a, -b);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z )*2.0-1.0;\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p *= m*2.02; //p = p*2.02;\n    f += 0.2500*noise( p ); p *= m*2.03; //p = p*2.03;\n    f += 0.1250*noise( p ); p *= m*2.01; //p = p*2.01;\n    f += 0.0625*noise( p ); \t\n    return f;\n}\n\n\n// transforms\nvec3 rotateX(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(p.x, ca*p.y - sa*p.z, sa*p.y + ca*p.z);\n}\n\nvec3 rotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca*p.x + sa*p.z, p.y, -sa*p.x + ca*p.z);\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// distance to scene\nfloat scene(vec3 p)\n{          \n    float d;\n\n\t\n#if TEST_OBJECT\n\t//d = p.y;\n\td = sphere(p, 1.0);\n\t//d = box(p, vec3(1.0));\n\td = difference(box(p, vec3(1.1)), d);\n\td = min(d, sphere(p, 0.5));\n\t\n\tvec3 np = p;\n\t//vec3 np = p + vec3(0.0, -iTime*0.2, 0.0);\n\td += fbm(np)*0.2;\n#else\n\tvec3 np = p + vec3(0.0, 0.0, -iTime);\n\td = fbm(np)*0.8 + 0.2;\n#endif\n\t\n\treturn d;\n}\n\n// calculate scene normal\nvec3 sceneNormal(in vec3 pos )\n{\n    float eps = 0.05;\n    vec3 n;\n    float d = scene(pos);\n    n.x = scene( vec3(pos.x+eps, pos.y, pos.z) ) - d;\n    n.y = scene( vec3(pos.x, pos.y+eps, pos.z) ) - d;\n    n.z = scene( vec3(pos.x, pos.y, pos.z+eps) ) - d;\n    return normalize(n);\n}\n\n\n// trace ray using regular sphere tracing\n// returns position of closest surface\nvec3 trace(vec3 ro, vec3 rd, out bool hit)\n{\n    hit = false;\n    vec3 pos = ro;\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tfloat d = scene(pos);\n\t\tif (abs(d) < hitThreshold) {\n\t\t\thit = true;\n\t\t}\n\t\tpos += d*rd;\n    }\n    return pos;\n}\n\n// trace all the way through the scene,\n// keeping track of distance traveled inside volume\nvec3 traceInside(vec3 ro, vec3 rd, out bool hit, out float insideDist)\n{\n    hit = false;\n\tinsideDist = 0.0;\t\n    vec3 pos = ro;\n\tvec3 hitPos = pos;\n    for(int i=0; i<maxSteps; i++)\n    {\n\t\tfloat d = scene(pos);\n\t\td = max(abs(d), minStep) * sign(d); // enforce minimum step size\n\t\t\n\t\tif (d < hitThreshold && !hit) {\n\t\t\t// save first hit\n\t\t\thitPos = pos;\n\t\t\thit = true;\n\t\t}\n\t\t\n\t\tif (d < 0.0) {\n\t\t\t// sum up distance inside\n\t\t\tinsideDist += -d;\n\t\t}\n\t\tpos += abs(d)*rd;\n    }\n    return hitPos;\n}\n\nvec3 background(vec3 rd)\n{\n     return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel = (fragCoord.xy / iResolution.xy)*2.0-1.0;\n\n    // compute ray origin and direction\n    float asp = iResolution.x / iResolution.y;\n    vec3 rd = normalize(vec3(asp*pixel.x, pixel.y, -1.5));\n    vec3 ro = vec3(0.0, 0.0, 2.5);\n\n     vec2 mouse = iMouse.xy / iResolution.xy;\n     float roty = -iTime*0.2;\n     float rotx = 0.0;\n     if (iMouse.z > 0.0) {\n          rotx = (mouse.y-0.5)*PI;\n          roty = -(mouse.x-0.5)*PI*2.0;\n     }\n     \n    rd = rotateX(rd, rotx);\n    ro = rotateX(ro, rotx);\n          \n    rd = rotateY(rd, roty);\n    ro = rotateY(ro, roty);\n          \n    // trace ray\n    bool hit;\n\tfloat dist;\n\t//vec3 hitPos = trace(ro, rd, hit);\n\tvec3 hitPos = traceInside(ro, rd, hit, dist);\n\n    vec3 rgb = vec3(0.0);\n    if(hit) {\n\t\tvec3 n = sceneNormal(hitPos);\n\t\t//rgb = n*0.5+0.5;\n\t\t//rgb = vec3(dist*0.2);\n\t\t\n\t\t// exponential fall-off:\n\t\trgb = exp(-dist*dist*translucentColor);\n\t\t\n\t\t// cubemap reflection\n\t\tvec3 i = normalize(hitPos - ro);\n\t\tvec3 r = reflect(i, n);\n\t\tfloat fresnel = 0.1 + 0.9*pow(1.0 - clamp(dot(-i, n), 0.0, 1.0), 2.0);\n\t\trgb += texture(iChannel1, r).rgb * fresnel;\n\t\t//rgb += vec3(fresnel);\n\n     } else {\n        rgb = background(rd);\n     }\n     \n    fragColor=vec4(rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Msf3Dj","date":"1379433626","viewed":2056,"name":"blue ice","username":"simesgreen","description":"experiment in sphere tracing translucent objects.\n\nthe idea is here is to sphere trace as usual, but carry on after the first hit, keeping track of the distance traveled inside the surface. then apply some exponential color decay with distance, bingo!","likes":67,"published":1,"flags":0,"usePreview":0,"tags":["noise","distancefield","translucent"],"hasliked":0,"parentid":"","parentname":""}}