{"ver":"0.1","info":{"id":"tsXfzr","date":"1587597123","viewed":315,"name":"Infinite Raymarch Spheres","username":"KeeganPillow","description":"Uses modulo to create infinite raymarched spheres","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarched","spheres","infinite"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXSTEPS 100\n#define MAX_DISTANCE 100.0\n#define GLERP 0.01\n\n//Returns the distance to a sphere\n//Pos is the position of the object.\n//Sphere\n//xyz describes the position of the sphere.\n//w describes the radius of the sphere.\nfloat Sphere (vec3 Pos, vec4 Sphere)\n{\n    return distance(Pos, Sphere.xyz) - Sphere.w;\n}\n\n//Returns the distance from objects in the scene.\nfloat GetDistanceFromScene(vec3 Pos)\n{\n   float modDist = 2.0;\n    \n   vec3 ModPos = vec3(mod(Pos, modDist));\n    \n   //Sphere 'nuff said.\n   float SP = Sphere(ModPos, \n                     vec4(1.0,\n                     1.0,\n                     1.0,\n                     0.25 + sin(iTime) * 0.125));\n    \n   //Sphere 'nuff said.\n   //float SP2 = Sphere(Pos, \n   //                   vec4(1.0 + cos(iTime / 4.0) * 2.0,\n   //                   1.0,\n   //                   6.0 + sin(iTime / 4.0) * 2.0, \n   //                   1.0) ); \n    \n   //SP = min (SP, mod(3.0, SP));\n    \n   //Ground plane (XZ)\n   float G = Pos.y; \n   \n   float minDist = min(SP, SP);\n   minDist = min(minDist, G);\n   return minDist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDistanceFromScene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistanceFromScene(p-e.xyy),\n        GetDistanceFromScene(p-e.yxy),\n        GetDistanceFromScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\n//Gets the depsth of the camera in the direction it's facing.\nfloat GetDepth(vec3 Position, vec3 direction)\n{\n   //Total accumulated distance\n   float dist = 0.0;\n    \n   //Raymarching loop.\n   for (int i = 0; i < MAXSTEPS; ++i)\n   {\n       //Finds the current position of ray\n       vec3 p = Position + dist * direction;\n       //Finds the distance from objects in the scene\n       float distScene = GetDistanceFromScene(p);\n       //Adds that distance to the total.\n       dist += distScene;\n       //Check for a break condition\n       if (distScene < GLERP || distScene > MAX_DISTANCE) break;\n   }\n   //Return the distance\n   return dist;\n}\n\n//Gets the normal of an object\n//Pos is the position of the object.\nfloat GetLight(vec3 p)\n{\n    vec3 LightPos = vec3(0.0, 5.0, iTime);\n    \n    vec3 l = normalize(LightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    //Look for shadows\n    \n    //Get distance raymarched from surface point to the light\n    float d = GetDepth(p + n * GLERP * 2.0, l);\n    \n    //Check is shorter than the distance to the light\n    if (d < length(LightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n   \n    \n    //Hey some camera stuff.\n    vec3 Position  = vec3(0.0, 1.0, -5.0 + iTime);\n    vec3 RayDir    = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Time varying pixel color\n    float depth = GetDepth(Position, RayDir);\n\n    //Diffuse lighting by finding normal from last position found in depth function\n    float dif = GetLight(Position + RayDir * depth);\n    \n    // Output to screen\n    fragColor = vec4(dif, dif, dif,1.0);\n    //fragColor = vec4(depth/10.0, depth/10.0, depth/10.0,1.0);\n}","name":"Image","description":"","type":"image"}]}