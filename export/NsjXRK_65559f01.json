{"ver":"0.1","info":{"id":"NsjXRK","date":"1620593546","viewed":96,"name":"Noisy sphere tracing","username":"anael","description":"Trying a silly idea to reduce the number of marching steps with noise","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","random"],"hasliked":0,"parentid":"sdSSRV","parentname":"Randomized sphere tracing"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint  seed = 1;\nvoid srand(int s ) { seed = s; }\nint  rand(void) { seed = seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\n\n// --------------------------------------\n// hash to initialize the random sequence (copied from Hugo Elias)\n// --------------------------------------\nint hash( int n )\n{\n\tn = (n << 13) ^ n;\n    return n * (n * n * 15731 + 789221) + 1376312589;\n}\n\n\n//////////////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/distfunctions\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n//////////////////////////////////////////////////////////////////////////\n\n\nfloat sceneSDF(vec3 samplePoint)\n{\n    float t = 3.14 * 0.5;\n    \n    vec3 spherePos = vec3(cos(t), 0.0, sin(t));\n    vec3 torusPos  = vec3(spherePos.x, cos(t), spherePos.z);\n\n    float d = sdSphere(samplePoint + spherePos, 0.5);     \n\n    for (int i = -2; i <= 2; i++) {\n        d = min(d, sdTorus(\n            samplePoint + torusPos + vec3(0.0, float(i) * 1.0, 10.0),\n            vec2(2.0 + abs(float(i)) * 1.0, 0.3)\n            ));\n    }\n        \n    return d;\n}\n\nbool marching_random(out int stepc, vec3 eye, vec3 dir)\n{\n    float noise_range = (1.1 + cos(float(iFrame) * 0.02)) * 0.008;\n\n    int i, count = 0;\n    float depth = 0.0;\n    vec3 p = eye;\n\n    for (i = 0; i < 64; i++) {\n\n        float dist = sceneSDF(p) + depth * noise_range * 0.5;\n        float randf = float(rand()) / 32767.0 * depth * noise_range;\n        \n        if (dist < randf) {\n            count++;\n            stepc = count;\n            return true;\n        }\n\n        float rdist = dist * (1.0 + randf);\n\n        p += dir * rdist;\n        depth += rdist;\n\n        count++;\n\n        if (depth > 1000.0)\n            break;\n    }\n\n    stepc = count;\n    return false;\n}\n\n// from https://www.shadertoy.com/view/WdVyDW\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) * 0.025;   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvec3 rayDir(float fov, vec2 resolution, vec2 fragCoord) {\n    vec2 xy = fragCoord - resolution / 2.0;\n    float z = resolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n    int stepc;\n    \n    ivec2 q = ivec2(fragCoord);\n    srand(hash(q.x+hash(q.y)));\n\n\tvec3 dir = rayDir(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0.0, 0.0, 5.0);\n    \n    hit = marching_random(stepc, eye, dir);\n    \n    fragColor = vec4(ShadeSteps(stepc), 1.0);\n\n    //if (hit)\n      //  fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}