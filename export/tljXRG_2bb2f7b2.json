{"ver":"0.1","info":{"id":"tljXRG","date":"1568301142","viewed":103,"name":"Ballception","username":"martytram","description":"Simple scene using raymarching and special modulo operation. One that does not have hard edges (it's seamless). There are no shadows casted by spheres onto other spheres. Spheres cast shadows just on themselves.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","antialiasing","spheres","infinite","directionallight"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000.\n#define MAX_DIST 300.\n#define EPSILON .01\n#define PI 3.14159265\n\n// set number of subdivisions for antialiasing\n#define AA_SUBDIV 1\n//#define MOVING_Z\n#define MOVING_Y\n//#define RANDOM_SPEED\n#define RANDOM_COLOR\n\nstruct ray{ vec3 org, dir; };\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\n//conversion helper\nfloat f(float n, vec3 hsl){\n    float k = mod(n+hsl.x*12., 12.);\n    float a = hsl.y*min(hsl.z, 1.-hsl.z);\n    return hsl.z-a*max(min(k-3., min(9.-k, 1.)),-1.);\n}\n// hsl in range <0, 1>^3\nvec3 hsl2rgb(vec3 hsl){\n    return vec3(f(0.,hsl), f(8.,hsl), f(4.,hsl));\n}\n\nray getRay(vec2 uv, vec3 camPos, vec3 lookAt, float zoom){\n    ray ray;\n    vec3 f = normalize(lookAt - camPos);\n    vec3 r = cross(vec3(0,1,0), f);\n    vec3 u = cross(f, r);\n    vec3 centre = camPos + f*zoom;\n    vec3 intersection = centre + uv.x*r + uv.y*u;\n    \n    ray.org = camPos;\n    ray.dir = normalize(intersection - camPos);\n    return ray;\n}\nfloat myMod(float p, float m){\n    return abs(mod(p, m)-.5*m);\n}\nvec2 myMod(vec2 p, float m){\n    return vec2(myMod(p.x, m), myMod(p.y, m));\n}\nvec3 myMod(vec3 p, float m){\n    return vec3(myMod(p.xy, m), myMod(p.z, m));\n}\nfloat sdSphere(vec3 p, vec3 c, float r){\n    return length(myMod(p, 5.)-c)-r;\n}\n\nfloat getSceneDist(vec3 p){\n#ifdef MOVING_Y\n    p.y += 2.*iTime;\n#endif\n\n#ifdef RANDOM_SPEED\n    float xzHash = N21(floor(p.xz/5.));\n    float speed = 2.*pow(xzHash, 0.5)-1.; // <-1,1> range with more values around -1 and 1\n    p.y += 3.*speed*iTime;\n    return .5*sdSphere(p, vec3(0), 1.); // .5 removes artifacts\n#endif\n\n\n    return sdSphere(p, vec3(0), 1.);\n}\n\nfloat rayMarchDist(ray ray){\n    float dist = 0.;\n    for(float i = 0.; i<MAX_STEPS; i+=1.){\n        vec3 p = ray.org + dist*ray.dir;\n        float currD = getSceneDist(p);\n        dist += currD;\n        \n        if(dist >= MAX_DIST)\n            return MAX_DIST;\n        if(currD <= EPSILON)\n            return dist;\n    }\n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    float d = getSceneDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        getSceneDist(p-e.xyy),\n        getSceneDist(p-e.yxy),\n        getSceneDist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat getLight(vec3 n, vec3 view){\n    //directional light without hard shadows (only selfcast)\n    float k_a = .05;\n    float k_d = .8;\n    float k_s = .2;\n    \n    vec3 lDir = normalize(vec3(0,5,6));\n    vec3 rDir = reflect(lDir, n);\n    float d = dot(n, lDir);\n    float amb = k_a;\n    float diff = clamp(d, 0., 1.)*k_d;\n    float spec = k_s*pow(clamp(dot(rDir, view), 0., 1.), 4.);\n    \n    return amb+diff+spec;\n}\n\n\nmat2 rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 getColor(vec2 uv, vec3 camPos, vec3 lookAt) {\n    ray ray = getRay(uv, camPos, lookAt, 1.);\n#ifdef MOVING_Z\n    ray.org.z -= 5.*iTime;\n#endif\n    \n    float d = rayMarchDist(ray);\n    vec3 p = ray.org + d*ray.dir;\n    vec3 l = vec3(0);\n\n#ifdef RANDOM_COLOR\n    \n    float xzHash = N21(floor(p.xz/5.));\n    vec3 col = hsl2rgb(vec3(xzHash, 1.,.5));\n#else\n    vec3 col = vec3(1);\n#endif\n\n    vec3 bg = vec3(getLight(ray.dir, vec3(0.)));\n    \n    float v = d/MAX_DIST;\n    \n    if(d<MAX_DIST)\n    \treturn mix(col*getLight(getNormal(p), ray.dir), bg, exp2(v*v)-1.);\n    \n    return bg;\n}\n\n// subdivide pixel\nvec3 getColorAA(vec2 uv, vec3 camPos, vec3 lookAt) {\n    const float subdivCount = float(AA_SUBDIV);\n    vec2 subdivDim = (1./iResolution.xy) * (1./subdivCount);\n    \n    vec3 res = vec3(0);\n    for(float i = 0.; i < subdivCount; i+=1.){\n        for(float j = 0.; j < subdivCount; j+=1.){\n            res += getColor(uv+vec2(i*subdivDim.x, j*subdivDim.y), camPos, lookAt);\n        }\n    }\n    \n    return res/pow(subdivCount, 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    vec3 camPos = vec3(0, 0, -0.1); // small offset for rotation\n    camPos.yz *= rot(-m.y*PI*.5+.25*PI);\n    camPos.xz *= rot(-m.x*4.*PI);\n    vec3 lookAt = vec3(0, 0, 0);\n    \n    \n    \n    col = getColorAA(uv, camPos, lookAt);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}