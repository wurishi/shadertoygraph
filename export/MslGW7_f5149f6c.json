{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// Shows the error (difference between hit-point height and the heightmap's height at that point)\n// -- Left: before interval mapping -- Right: after interval mapping\n//#define SHOW_ERROR    \n\n// Use interval mapping\n#define INTERVAL\n\n// Quality settings\n#define LOW\n//#define MEDIUM\n//#define HIGH\n\n//#define CLOUDS\n//#define SHADOWS\n\n#define SHADOW_ITERS 10\n#define SHADOW_QUALITY 3.0\n\n#ifdef LOW\n\t#define LINEAR_ITERS 45\n\t#define INTERVAL_ITERS 3\n\t#define LINEAR_ACCURACY 0.7\n\t#define FOG_BASE 0.08\n\t#define MAX_DIST 1300.0\n#endif\n\n#ifdef MEDIUM\n\t#define LINEAR_ITERS 80\n\t#define INTERVAL_ITERS 2\n\t#define LINEAR_ACCURACY 0.6\n\t#define FOG_BASE 0.06\n\t#define MAX_DIST 1500.0\n#endif\n\n#ifdef HIGH\n\t#define LINEAR_ITERS 140\n\t#define INTERVAL_ITERS 3\n\t#define LINEAR_ACCURACY 0.5\n\t#define FOG_BASE 0.04\n\t#define MAX_DIST 2000.0\n\t#define AA\n#endif\n\n#define PI 3.14159265358979\n\n//// Noise function by iq\n\nfloat hash(float n)\n{\n    return fract(sin(n)*43758.5453123);\n}\n\nfloat noise(in vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n    float res = mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                    mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y);\n    return res;\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix(hash(n+  0.0), hash(n+  1.0), f.x),\n                        mix(hash(n+ 57.0), hash(n+ 58.0), f.x), f.y),\n                    mix(mix(hash(n+113.0), hash(n+114.0), f.x),\n                        mix(hash(n+170.0), hash(n+171.0), f.x), f.y), f.z);\n    return res;\n}\n\n//// End iq\n\nvec3 rotate(vec3 p, float theta)\n{\n\tfloat c = cos(theta), s = sin(theta);\n\treturn vec3(p.x, p.y * c + p.z * s,\n\t\t\t\tp.z * c - p.y * s);\n}\n\nfloat clouds(vec2 p) {\n\tfloat final = noise(p);\n\tp *= 2.94; final += noise(p) * 0.4;\n\tp *= 2.87; final += noise(p) * 0.2;\n\tp *= 2.93; final += noise(p) * 0.1;\n\treturn final;\n}\n\nfloat fbm(vec2 p) {\n\tfloat final = noise(p);\n\tp *= 2.94; final += noise(p) * 0.4;\n\tp *= 2.87; final += noise(p) * 0.1;\n\tfinal += 0.005 + final * 0.005; // Compensate for mssing noise on low quality version\n\treturn pow(final, 1.5) - 1.0;\n}\n\nfloat fbmHigh(vec3 p) {\n\tfloat final = noise(p.xz);\n\tp *= 2.94; final += noise(p.xz) * 0.4;\n\tp *= 2.87; final += noise(p.xz) * 0.1;\n\tp *= 2.97; final += noise(p.xz) * final * 0.02;\n\tfinal = pow(final, 1.5);\n\tp *= 1.97; final += noise(p) * final * 0.007;\n\tp *= 1.99; final += noise(p) * final * 0.002;\n\tp *= 1.91; final += noise(p) * final * 0.0008;\n\treturn final - 1.0;\n}\n\nfloat terrain(vec2 pos) {\n\treturn fbm(pos * 0.006) * 80.0 - 65.0;\n}\n\nfloat sceneHigh(vec3 pos) {\n\treturn pos.y - fbmHigh(pos * 0.006) * 80.0 + 65.0;\n}\n\nvec3 normal(vec3 p) {\n\tconst vec2 eps = vec2(0.1, 0.0);\n\tfloat h = terrain(p.xz);\n\treturn normalize(vec3(\n\t\t(terrain(p.xz+eps.xy)-h),\n\t\teps.x,\n\t\t(terrain(p.xz+eps.yx)-h)\n\t));\n}\n\nvec3 normalHigh(vec3 x) {\n\tconst vec2 eps = vec2(0.1, 0.0);\n\tfloat h = sceneHigh(x);\n\treturn normalize(vec3(\n\t\t(sceneHigh(x+eps.xyy)-h),\n\t\t(sceneHigh(x+eps.yxy)-h),\n\t\t(sceneHigh(x+eps.yyx)-h)\n\t));\n}\n\nfloat shadow(vec3 rpos, vec3 rdir) {\n\tfloat t = 1.0+SHADOW_QUALITY;\n\tfloat sh = 1.0;\n\tfor (int i = 0; i < SHADOW_ITERS; i++) {\n\t\tvec3 pos = rpos + rdir * t;\n\t\tfloat h = pos.y - terrain(pos.xz);\n\t\tif (h < 0.0) return 0.0;\n\t\tsh = min(sh, h/t*8.0);\n\t\tt += max(h, SHADOW_QUALITY);\n\t}\n\treturn sh;\n}\n\nconst float waterHeight = 105.0;\nconst vec3 lightDir = vec3(0.819232, 0.573462, 0.);\n\nvec3 calculateFogColor(vec3 rpos, vec3 rdir) {\n\tvec3 col = mix(vec3(0.3, 0.5, 0.7), vec3(0.0, 0.05, 0.1), clamp(rdir.y*2.5, 0.0, 1.0));\n\tcol += pow(dot(lightDir, rdir) * 0.5 + 0.5, 2.0) * vec3(0.3, 0.2, 0.1);\t\n\treturn col;\n}\n\nvec3 shade(vec3 rpos, vec3 rdir, float t, vec3 pos) {\n\tfloat watert = ((rpos.y - waterHeight) / rdir.y);\n\t\n\t// Calculate fog\n\tfloat b = 0.01;\n\tfloat fogt = min(watert, t);\n\tfloat fog = 1.0 - FOG_BASE * exp(-rpos.y*b) * (1.0-exp(-fogt*rdir.y*b)) / rdir.y;\n\tvec3 fogColor = calculateFogColor(rpos, rdir);\n\n\tvec4 ns = texture(iChannel0, pos.xz * 0.1);\n\t\n\tif (fog < 0.01) return fogColor;\n\t\n\tvec3 nl = normal(pos);\n\tvec3 n = normalHigh(pos);\n\tfloat h = pos.y;\n\t\n\tfloat slope = n.y;\n\tvec3 albedo = vec3(0.36, 0.25, 0.15);\n\t\n\t// Apply texture above water\n\tif (watert > t) {\n\t\tfloat snowThresh = 1.0 - smoothstep(-50.0, -40.0, h) * 0.4 + 0.1;\n\t\tfloat grassThresh = smoothstep(-70.0, -50.0, h) * 0.3 + 0.75;\n\t\t\n\t\tif (nl.y < 0.65)\n\t\t\talbedo = mix(albedo, vec3(0.65, 0.6, 0.5), smoothstep(0.65,0.55,nl.y));\n\t\tif (slope > grassThresh - 0.1)\n\t\t\talbedo = mix(albedo, vec3(0.4, 0.6, 0.2), smoothstep(grassThresh-0.1,grassThresh+0.1,slope));\n\t\tif (slope > snowThresh - 0.1)\n\t\t\talbedo = mix(albedo, vec3(1.0, 1.0, 1.0), smoothstep(snowThresh-0.1,snowThresh+0.1,slope));\n\t}\n\t\n\t// Fade in 'beach' and add a bit of noise\n\talbedo = mix(albedo, vec3(0.6, 0.5, 0.2), smoothstep(-waterHeight+4.0,-waterHeight+0.5,h));\n\talbedo *= ns.rgb * 0.1 + 0.95;\n\t\n\t// Lighting\n\tfloat diffuse = clamp(dot(n, lightDir), 0.0, 1.0);\n\t#ifdef SHADOWS\n\tif (diffuse > 0.005) diffuse *= shadow(pos, vec3(lightDir.xy, -lightDir.z));\n\t#endif\n\tvec3 col = vec3(0.0);\n\tcol += albedo * vec3(1.0, 0.9, 0.8) * diffuse;\n\tcol += albedo * fogColor * max(n.y * 0.5 + 0.5, 0.0) * 0.5;\n\t\n\t// Shade water\n\tif (t >= watert) {\n\t\tfloat dist = t - watert;\n\t\tvec3 wpos = rpos+rdir*watert;\n\t\tcol *= exp(-vec3(0.3, 0.15, 0.08)*dist);\n\t\t\n\t\tfloat f = 1.0 - pow(1.0 - clamp(-rdir.y, 0.0, 1.0), 5.0);\n\t\tvec3 refldir = rdir * vec2(-1.0, 1.0).yxy;\n\t\trefldir = normalize(refldir + ns.xyz * 0.1);\n\t\tvec3 refl = calculateFogColor(wpos, refldir);\n\t\tcol = mix(refl, col, f);\n\t}\n\t\n\treturn mix(fogColor, col, fog);\n}\n\nvec3 trace(vec3 rpos, vec3 rdir) {\n\tfloat t = (rpos.y - 10.0) / rdir.y;\n\tfloat tfar = (rpos.y - 150.0) / rdir.y;\n\tfloat cloudst = (rpos.y + 130.0) / rdir.y;\n\tfloat dt = (tfar - t) / 80.0;\n\t\n\tif (t > 0.0 && tfar > t) {\n\t\tfloat prevt = 0.0, prevh, dist;\n\t\tvec3 pos = vec3(0.0);\n\t\tfloat h = 0.0;\n\t\t\n\t\t/// Distance map search\n\t\tfor (int i = 0; i < LINEAR_ITERS; i++) {\n\t\t\tpos = rpos + rdir * t;\n\t\t\tprevh = h;\n\t\t\th = terrain(pos.xz);\n\t\t\tdist = pos.y - h;\n\t\t\tif (dist < 0.0) break;\n\t\t\tprevt = t;\n\t\t\t\n\t\t\tif (dist > 30.0)\n\t\t\t\tt += max(dist * 1.2, t * 0.03) * LINEAR_ACCURACY;\n\t\t\telse\n\t\t\t\tt += max(dist, 5.0) * LINEAR_ACCURACY;\n\t\t\t\t\n\t\t\tif (t > tfar || t > MAX_DIST) return calculateFogColor(rpos, rdir);\n\t\t}\n\t\t\t\t\n\t\t#ifdef SHOW_ERROR\n\t\tif (fragCoord.x < iResolution.x*0.5) return vec3(abs(dist*0.1));\n\t\t#endif\n\t\t\t\n\t\t/// Interval mapping\n\t\t#ifdef INTERVAL\n\t\tfloat before = prevt;\n\t\tvec3 beforePos = rpos + rdir * before;\n\t\tfloat beforeH = terrain(beforePos.xz);\n\t\t\n\t\tfloat after = t;\n\t\tvec3 afterPos = rpos + rdir * after;\n\t\tfloat afterH = terrain(afterPos.xz);\n\t\t\n\t\tfloat best = before;\n\t\tfor (int i = 0; i < INTERVAL_ITERS; i++)\n\t\t{\n\t\t\tfloat interval = before - after;\n\t\t\tfloat deltaL = beforeH - afterH;\n\t\t\tfloat deltaR = rdir.y * interval;\n\t\t\t\n\t\t\tfloat curt = (beforeH * interval - deltaL * before) / (deltaR - deltaL);\n\t\t\tif (curt < before - 1.0 || curt > after + 1.0) break;\n\t\t\t\n\t\t\tpos = rpos + rdir * curt;\n\t\t\tfloat height = terrain(pos.xz);\n\t\t\tdist = height - pos.y;\n\t\t\t\n\t\t\tif (height < pos.y)\n\t\t\t{\n\t\t\t\tbeforeH = height;\n\t\t\t\tbefore = curt;\n\t\t\t\tt = curt;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tafterH = height;\n\t\t\t\tafter = curt;\n\t\t\t\tt = curt;\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\t\n\t\t#ifdef SHOW_ERROR\n\t\treturn vec3(abs(dist*0.1));\n\t\t#endif\n\t\t\n\t\treturn shade(rpos, rdir, t, rpos + rdir * t);\n\t}\n\t#ifdef CLOUDS\n\telse if (cloudst > 0.0) {\n\t\tvec3 fc = calculateFogColor(rpos, rdir);\n\t\tfloat f = 1.0/exp(cloudst*0.0005);\n\t\t\n\t\tvec3 pos = rpos + rdir * cloudst;\n\t\tfloat c = clouds(pos.xz*0.005);\n\t\tfloat c2 = clouds((pos.xz+vec2(50.0, 0.0))*0.005);\n\t\tfloat dir = max((c-c2)+0.5, 0.0);\n\t\t\n\t\tc = max(c - 0.5, 0.0) * 1.8;\n\t\tc = c*c*(3.0-2.0*c);\n\t\tvec3 col = mix(vec3(0.4, 0.5, 0.6), vec3(1.0, 0.9, 0.8), dir);\n\t\treturn mix(fc, col, clamp(f*c, 0.0, 1.0));\n\t}\n\t#endif\n\t\n\treturn calculateFogColor(rpos, rdir);\n}\n\n// Ray-generation\nvec3 camera(vec2 px) {\n\tvec2 rd = (px / iResolution.yy - vec2(iResolution.x/iResolution.y*0.5-0.5, 0.0)) * 2.0 - 1.0;\n\tvec3 rpos = vec3(iTime*2.0, 0.0, iTime*20.0);\t\n\tvec3 rdir = rotate(vec3(rd.x*0.5, rd.y*0.5, 1.0), -0.2);\n\treturn trace(rpos, normalize(rdir));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t#ifdef AA\n\tvec3 col = (camera(fragCoord.xy) + camera(fragCoord.xy + vec2(0.0, 0.5))) * 0.5;\n\t#else\n\tvec3 col = camera(fragCoord.xy);\n\t#endif\n\tfragColor = vec4(pow(col, vec3(0.4545)), 1.0);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MslGW7","date":"1372444764","viewed":2342,"name":"Interval mapping","username":"vanburgler","description":"Based on Lakes and Mountains (https://www.shadertoy.com/view/Xdl3W7) but replaces binary search with interval mapping. It is quite a bit faster. http://graphics.cs.ucf.edu/IntervalMapping/images/IntervalMapping.pdf","likes":33,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","heightmap","intervalmapping"],"hasliked":0,"parentid":"","parentname":""}}