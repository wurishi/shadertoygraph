{"ver":"0.1","info":{"id":"flcSDX","date":"1639865594","viewed":164,"name":"infinite Cube","username":"kastorp","description":"yees! a crazy symmetry puzzle ","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["cube","box","sgi","frame"],"hasliked":0,"parentid":"7t3XW2","parentname":"Box frame variations"},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Infinite Cube by kastorp\n// ----------------------------------------------------------------------------------------\n// the easiest solution would be the union of 18 boxes, but using symmetries only 3 SDF primitives are evaluated.\n// UPDATE: added a new algorithm which is faster and requires only one primitive SDF \n//-----------------------------------------------------------------------------------------\n// ALGORITHM1 :\n// the cube is subdivided in 8 corners, each one corrisponding to a vertex:\n//     z\n//     | \n//   B |______ C\n//     |\\     \\\n//     | \\    |\\\n//     |F \\___|_\\ G\n//   A |__|___|_|______ x\n//     \\  |  D\\ |\n//      \\ |    \\|\n//    E  \\|_____| H\n//        \\\n//         \\ y\n//\n// A and G have symmetry on 3 planes (all parallel to AG) \n// F and D have symmetry on 1 plane ( parallel to x and AF)\n// E and C have symmetry on 1 plane ( parallel to y and AC)\n// B and H have symmetry on 1 plane ( parallel to z and AH)\n//\n// using symmetries, from 3 boxes we obtain 9 (in vertexes A or G) or 6 (other vertexes), applying respectively 3 or 2 shift\n// then the unused boxes are hidden, obtaing 6 edges (case A or G) or 4 (other cases)\n//--------------------------------------------------------------------------------------\n// ALGORITHM 2 \n// much better based on the fact that 2 corners have triple symmetry, and 6 corner have double symmetry\n//\n// these are the steps:\n// 1) subdivide in 8 corners\n// 2) for corner A & G  reflect from y to z, otherwise shift and rotate\n// 3) reflect from x to y\n// 4) reflect from x to z\n// 5) shift in y\n// 6) apply sdfs\n//---------------------------------------------------------------------------------------\n// NOTE:  here is am alternate version by Fizzer: https://www.shadertoy.com/view/tls3DS \n// -----------------------------------------------------------------------------------------\nfloat corner(vec3 v) {return length(max(vec3(v.x,v.y,v.z),0.0))+min(max(v.x,max(v.y,v.z)),0.0);}\nfloat capsule(vec3 p,vec3 a,vec3 b) { return distance(p, mix(a, b, clamp(dot(p - a, normalize(b - a)) / length(b - a), 0., 1.)));}\nfloat torus( vec3 p, vec2 t ) { return length(vec2(length(p.xz)-t.x,p.y))-t.y; }\nfloat qtorus( vec3 p, vec2 t ) { return max(torus(p+vec3(t.x,0,t.x),t), corner(-p-vec3(t.x))); }\n#define CAPSULE //uncomment to use capsules as edges\n\n\n\nfloat infiniteCube2( vec3 p, float b, float e, float k )\n{ \n float t=1.*min(1.,sin(iTime)*2.5+2.5); // uncomment to animate\n vec3 ny=normalize(vec3(-t,1,0)); \n vec3 nz=normalize(vec3(-t,0,1));\n vec3 nx=normalize(vec3(0,t,-1)); \n    float s=abs(dot(sign(p),vec3(1,2,4))); //get current corner\n    float r=2.*e;      \n    p=abs(p)-(.3+t*.7)*b*(1.-k); // position relative to closest corner\n    float d = max(min(min(p.x,p.y),p.z)+b*(1.1-k),max(max(p.x,p.y),p.z)-b*k); //artifact removal with hidedn cross sdf\n    \n    if(s==7.){\n        if( dot(p, nx) < 0. )  p = reflect(p, nx); } // y to z \n    else{\n        p= (s==5.)?p.yzx:(s==3.)?p.zxy:p; //rotate\n        p.z-=k*b*t; //shift\n    }\n     \n    if(dot(p, ny) < 0. )  p = reflect(p, ny); // x to y\n    if(dot(p, nz) < 0. )  p = reflect(p, nz); // x to z\n    p.y-=b*k*t; //shift\n\n#ifndef CAPSULE\n    vec3 q = abs(p+e )-e; //from corner to box\n    d=min(d,corner(vec3(p.x,q.y,q.z)));\n#else\n    d= min(d, qtorus(p.xyz ,vec2(r*t,e)));\n    d= min(d, capsule(p,vec3(-r*t,0,0),vec3(-b*t,0,0))-e);   \n#endif\n    return d;\n}\n\n\nfloat infiniteCube( vec3 p, float b, float e, float k )\n{  \n  float s=abs(dot(sign(p),vec3(1,2,4)));  //s=7 for A and G,5 for F and D,3 for C and E,1 for B and H\n  p = abs(p  );\n  float d = max(min(min(p.x,p.y),p.z)+b*0.4,max(max(p.x,p.y),p.z) -b); //artifact removal with hidedn cross sdf\n  \n  vec3  m=step(p.zxy,p)*step(p.yzx,p), // max coordinate normal  == shift direction for A and G\n          mm= (s==1.) ?vec3(step(p.xy,p.yx),0):  //shift direction for other corners\n              (s==3.) ?vec3(step(p.x,p.z),0,step(p.z,p.x)):\n                       vec3(0,step(p.yz,p.zy));\n  bvec3 c= bvec3(m.x==0.,m.y==0.,m.z==0.); //removal condition for A and G\n  if(s!=7.) c=bvec3((s!=1. || mm.x==1. ) && (s!=3. || mm.x==1. ), //removal condition for other corners\n                    (s!=1. || mm.y==1. ) && (s!=5. || mm.y==1. ),\n                    (s!=5. || mm.z==1. ) && (s!=3. || mm.z==1. ));\n      \n  //c=bvec3(true); //uncomment to show hidden edges\n  if(s==7.) p -= b*((1.-k)+m*k); else  p -= b*(1.-mm*k); //apply shift\n#ifndef CAPSULE\n  vec3 q = abs(p+e )-e; //from corner to box\n  vec3 dd= vec3(\n  corner(vec3(p.x,q.y,q.z)),\n  corner(vec3(q.x,p.y,q.z)),\n  corner(vec3(q.x,q.y,p.z)));\n#else\n  float r=2.*e; \n  d= min(d,qtorus(((!c.x)?p.zxy:(!c.y)?p.xyz:p.yzx) ,vec2(r,e)));\n     //min(d,length(p-vec3(0,0,0))-r+e); //ball join\n  vec3 dd= vec3(capsule(p,vec3(-r,0,0),vec3(-b,0,0))-e,\n                capsule(p,vec3(0,-r,0),vec3(0,-b,0))-e,\n                capsule(p,vec3(0,0,-r),vec3(0,0,-b))-e);               \n#endif \n  dd+=1e5 *(1.- vec3(c)); d=min(min(d,dd.x),min(dd.y,dd.z));\n  return d;\n}\n\n\n//--------------------------------------------------\n\nfloat map(vec3 p) {      \n    float d= p.y; \n    p -= vec3(0.,.48,0.);\n    //d= min(d,length(p)-.2); //ball\n    //d= min(d,infiniteCube(p ,.45,.04,.25));\n    d= min(d,infiniteCube2(p ,.45,.04,.25));\n    return d;\n}\n\nvec3 calcN(vec3 p, float t) {\n\tfloat h = .001 * t;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e * map(p + e * h);\n\t}\n\treturn normalize(n);\n}\n\nfloat calcShadow(vec3 p, vec3 ld) {\n\tfloat s = 1., t = .05;\n\tfor (float i = 0.; i < 40.; i++)\n\t{\n\t\tfloat h = map(p + ld * t);\n\t\ts = min(s, 15. * h / t);\n\t\tt += h;\n\t\tif (s < .001) break;\n\t}\n\treturn clamp(s, 0., 1.);\n}\n\n\nvec3 vignette(vec3 c, vec2 fc) {\n\tvec2 q = fc.xy / iResolution.xy;\n\tc *=  .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn c;\n}\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n\tvec3 f = normalize(lookAt - ro),\n\t\t r = normalize(cross(vec3(0,1., 0), f));\n\treturn normalize(f + r * uv.x + cross(f, r) * uv.y);\n}\n\nvec3 lights(vec3 p, vec3 rd, float d) {\n    vec3 lightDir = normalize( vec3(15.,19.,6.) );\n\tvec3 ld = normalize(lightDir*6.5 - p), n = calcN(p, d) ;\n\n\tfloat ao = 1.,\n\tl1 = max(0., .2 + .8 * dot(ld, n)),\n\tl2 = 0.,\n\tspe = max(0., dot(rd, reflect(ld, n))) * .1,\n\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n));\n\n\tl1 *= .1 + .9 * calcShadow(p+.001*n, ld);\n\tvec3 lig = ((l1 + l2) * ao + spe) * vec3(1.) *2.5;\n\treturn mix(.3, .4, fre) * lig;\n}\n//--------------------SHANE---------------------\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){ \n    n = max(abs(n), 0.001);//n = max((abs(n) - 0.2)*7., 0.001); //  etc.\n    n /= (n.x + n.y + n.z ); \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tfor (float i = 0.; i < 100.; i++) {\n\t\tp = ro + rd * d;\n\t\tfloat h = map(p);\n\t\tif (abs(h) < .001  )break;\n        if(d >10.) return vec3(0,.3,.3);\n\t\td += h; // No hit, so keep marching.\n\t} \n  \n\treturn (p.y>=0.01?  tex3D(iChannel0 ,p, calcN(p, d) ).rgb:tex3D(iChannel1 ,p, calcN(p, d) ).rgb)*lights(p, rd, d) * exp(-d * .085);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fc)\n{\n\t\n    float t=-iTime*.5;\n\tvec3 ro = vec3(1.*cos(t), .7 +3.*iMouse.y/iResolution.y, 1.*sin(t));\t\n\tvec2 uv = (fc - .5 * iResolution.xy) / iResolution.y;\n\tfragColor = vec4(vignette(pow(march(ro, getRayDir(ro, vec3(0,.5,0), uv)), vec3(.45)), fc), 0);\n}\n","name":"Image","description":"","type":"image"}]}