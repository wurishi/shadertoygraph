{"ver":"0.1","info":{"id":"X323zV","date":"1708629088","viewed":67,"name":"NaN Buffer Bug","username":"Hyeve","description":"Weird things happened in a shader I was working on, this is my test case reproducing it.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["bug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*--------- NaN Buffer Bug ---------\n\nOn my hardware (RTX 2060 Super), this\nshader outputs a pure white screen.\n\nThis can only happen if X > 0 and \nX < 0 both evaluate to true - a\nlogical impossibility.\n\nX is initialized as 0 / 0 in the\nbuffer, which according to the IEEE\nstandard, should result in NaN.\n\nHowever, after passing it through\nthe buffer and reading it out,\nit is not detected as NaN.\n\nAnd, indeed, all comparisions with\nNaN should return false, except !=\n- yet that's not what happens here.\n\nCuriously, checking isinf(X) causes\nthe checks to no longer return true.\n\n----------------------------------*/\n\nfloat bug(float X) {\n\n    /*----- UPDATE -----\n    \n    Found the cause!\n    It appears that my compiler is assuming\n    that values read out of the buffer cannot\n    be NaN (even though they absolutely can)\n\n    Uncommenting the line below forces the \n    compiler to acknowledge that it could be \n    NaN, and suddenly the isnan check trips!\n    \n    ------------------*/\n\n    //if(iFrame < 0) X = 0. / 0.;\n\n    if(isnan(X)) {\n        //This return doesn't matter. Just shows that the NaN check fails.\n        return 0.1; \n    }\n    \n    if(isinf(X)) {\n        //If uncommented, this value is NOT returned, but causes a different later value to be returned.\n        //Seems like the isinf check actually mutates x (and is unsurprisingly optimized out with no return).\n        \n        //return 0.1;\n    }\n\n    if(X > 0.) {\n        if(X < 0.) {\n            //This is the return that should be impossible to hit.\n            return 1.; \n        }\n         \n        //This return is required to prevent the compiler from optimizing the if statements.\n        return 0.; \n    }\n    \n    //This return cannot have the same value as the return just above (zero), for the same reason.\n    return 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float bad = texture(iChannel0, uv).x;\n    fragColor = vec4(bug(bad));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0. / 0.);\n}","name":"Buffer A","description":"","type":"buffer"}]}