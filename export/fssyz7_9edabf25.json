{"ver":"0.1","info":{"id":"fssyz7","date":"1641888398","viewed":93,"name":"Sphere reflections","username":"maxbergmark","description":"Simple demo for recursive reflections in spheres","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NUM_SPHERES 6\n#define NUM_REFLECTIONS 5\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec4 color;\n};\n\nstruct Collision {\n    Sphere sphere;\n    float distance;\n    vec3 point;\n    bool hasHit;\n};\n\nvec2 raySphereIntersect2(vec3 r0, vec3 rd, vec3 s0, float sr) {\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n\tfloat disc = b * b - 4.0 * a* c;\n    if (disc < 0.0) {\n        return vec2(-1.0, -1.0);\n    }else{\n\t\treturn vec2(-b - sqrt(disc), -b + sqrt(disc)) / (2.0 * a);\n\t}\n}\n\nCollision findFirstCollision(Sphere[NUM_SPHERES] spheres, vec3 origin, vec3 dir) {\n    Collision firstCollision = Collision(Sphere(vec3(0), -1.0, vec4(0)), 1e9, vec3(0), false);\n    for (int i = 0; i < NUM_SPHERES; i++) {\n        Sphere sphere = spheres[i];\n        if (abs(length(origin - sphere.center) - sphere.radius) > firstCollision.distance) {\n            continue;\n        }\n        vec2 d = raySphereIntersect2(origin, dir, sphere.center, sphere.radius);\n        float dist = d.x > 0.0 ? d.x : d.y;\n        if (dist > 0.0 && dist < firstCollision.distance) {\n            firstCollision.sphere = sphere;\n            firstCollision.distance = dist;\n            firstCollision.point = origin + firstCollision.distance * dir;\n            firstCollision.hasHit = true;\n        }\n    }\n    return firstCollision;\n}\n\nvec3 findReflections(Sphere[NUM_SPHERES] spheres, vec3 origin, vec3 dir, inout vec4 color) {\n\n    for (int l = 0; l <= NUM_REFLECTIONS; l++) {\n        Collision collision = findFirstCollision(spheres, origin, dir);\n        if (collision.hasHit) {\n            Sphere sphere = collision.sphere;\n            vec3 normal = normalize(collision.point - sphere.center);\n            if (length(origin - sphere.center) < sphere.radius) {\n                normal *= -1.0;\n            }\n            dir = reflect(dir, normal);\n            // move a small distance to account for self-intersection on next bounce\n            origin = collision.point + 0.01 * dir;\n            color *= sphere.color;\n            \n        } else {\n            return dir;\n        }\n    }\n    return dir;\n}\n\nvec4 renderSpheres(vec3 dir, Sphere[NUM_SPHERES] spheres) {\n    vec3 origin = vec3(0);\n    vec4 mixedColor = vec4(1);\n    vec3 reflection = findReflections(spheres, origin, dir, mixedColor);\n    vec4 color = texture(iChannel0, reflection) * mixedColor;\n    return color;\n}\n\nSphere[NUM_SPHERES] getSpheres(vec3 camD) {\n    Sphere c0 = Sphere(camD * 5.0, 1.0 + sin(iTime) * 0.1, vec4(1, 0.7, 0.7, 1.0));\n    Sphere c1 = Sphere(vec3(10, 0, 0), 3.0 + sin(iTime) * 0.1, vec4(0.7, 1.0, 0.7, 1.0));\n    \n    vec3 p2 = vec3(5.5 * sin(iTime), 1.0 * cos(iTime), 5.0 * cos(iTime));\n    Sphere c2 = Sphere(p2, 2.0 + sin(iTime) * 0.1, vec4(1.0, 0.7, 1.0, 1.0));\n    vec3 p3 = vec3(-5.5 * sin(iTime), 1.0 * cos(iTime), -5.0 * cos(iTime));\n    Sphere c3 = Sphere(p3, 2.0 + sin(iTime) * 0.1, vec4(0.5, 1.0, 1.0, 1.0));\n    \n    Sphere c4 = Sphere(vec3(0, 100.0, 0), 90.0 + 8.0 * sin(iTime * 0.7), vec4(1.0));\n    Sphere c5 = Sphere(vec3(0, -100.0, 0), 90.0 + 8.0 * sin(iTime * 0.6), vec4(1.0));\n    Sphere[] spheres = Sphere[] (c0, c1, c2, c3, c4, c5);\n    return spheres;\n}\n\nvec4 renderPixel(vec2 mousePos, vec2 fragCoord) {\n\n    float rotX = (iMouse.x / iResolution.x) * 2.0 * 3.14;\n    float rotY = (iMouse.y / iResolution.y) * 3.14; \n    vec2 uv = 2.5 * (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xx;\n\n    vec3 camO = vec3(cos(rotX), cos(rotY), sin(rotX));\n    vec3 camD = normalize(vec3(0)-camO);\n    vec3 camR = normalize(cross(camD, vec3(0, 1, 0)));    \n    vec3 camU = cross(camR,camD);\n    vec3 dir = normalize(uv.x * camR + uv.y * camU + camD);\n\n    return renderSpheres(dir, getSpheres(camD));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0);\n    int aaLevel = 2;\n    float samples = pow(float(aaLevel), 2.0);\n    float inc = 1.0 / (float(aaLevel) - 1.0);\n    // anti-aliasing\n    for (float x = -0.5; x <= 0.5; x += inc) {\n        for (float y = -0.5; y <= 0.5; y += inc) {\n            vec2 offset = vec2(x, y);\n            color += renderPixel(iMouse.xy, fragCoord + offset);\n        }\n    }\n    fragColor = color / samples;\n\n}","name":"Image","description":"","type":"image"}]}