{"ver":"0.1","info":{"id":"mtlGWj","date":"1672455800","viewed":77,"name":"The Eyes are watching","username":"PHTest","description":"A modified version of IQ's painting an eye with maths: https://www.youtube.com/watch?v=emjuqqyq_qc\nI also took boxDivide from another shaderToy example but can't find from where at the moment. I will update this description with credit.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["eyes","fbm","boxdivide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592654\n\n// http://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n  // return a + b*cos( 6.28318*(c*t+d) );\n  return pow(a + b*cos( 6.28318*(c*t+d) ), vec3(2.2));\n}\n\nfloat random(vec2 st) {\n  return fract(\n      sin(\n          dot(st.xy,vec2(12.9898, 78.233))\n          ) * 43758.5453123);\n}\n\n// the main noise interpolation function using a hermite polynomial\nfloat noiseInterpolate(const in float x) \n{ \n    float x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec2 noiseInterpolate(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec3 noiseInterpolate(const in vec3 x) \n{ \n    vec3 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec4 noiseInterpolate(const in vec4 x) \n{ \n    vec4 x2 = x * x;\n    return x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n}\nvec4 noiseInterpolateDu(const in vec2 x) \n{ \n    vec2 x2 = x * x;\n    vec2 u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    vec2 du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n    return vec4(u, du);\n}\nvoid noiseInterpolateDu(const in vec3 x, out vec3 u, out vec3 du) \n{ \n    vec3 x2 = x * x;\n    u = x2 * x * (x * (x * 6.0 - 15.0) + 10.0); \n    du = 30.0 * x2 * (x * (x - 2.0) + 1.0);\n}\nfloat noise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  float ll_corner = random(i);\n  float lr_corner = random(i + vec2(1.0,0.0));\n  float ul_corner = random(i + vec2(0.0,1.0));\n  float ur_corner = random(i + vec2(1.0,1.0));\n\n  vec2 u = smoothstep(0.0, 1.0, f);\n\n  return mix(ll_corner, lr_corner, u.x) +\n      (ul_corner - ll_corner)*u.y*(1.0 - u.x) +\n      (ur_corner - lr_corner)*u.x*u.y;\n}\n\nuint ihash1D(uint q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nuvec2 ihash1D(uvec2 q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\nuvec4 ihash1D(uvec4 q)\n{\n    // hash by Hugo Elias, Integer Hash - I, 2017\n    q = (q << 13u) ^ q;\n    return q * (q * q * 15731u + 789221u) + 1376312589u;\n}\n\n// @return Value of the noise, range: [0, 1]\nfloat hash1D(float x)\n{\n    // based on: pcg by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uint state = uint(x * 8192.0) * 747796405u + 2891336453u;\n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return float((word >> 22u) ^ word) * (1.0 / float(0xffffffffu));;\n}\n\n// @return Value of the noise, range: [0, 1]\nfloat hash1D(vec2 x)\n{\n    // hash by Inigo Quilez, Integer Hash - III, 2017\n    uvec2 q = uvec2(x * 8192.0);\n    q = 1103515245u * ((q >> 1u) ^ q.yx);\n    uint n = 1103515245u * (q.x ^ (q.y >> 3u));\n    return float(n) * (1.0 / float(0xffffffffu));\n}\n\n// @return Value of the noise, range: [0, 1]\nfloat hash1D(vec3 x)\n{\n    // based on: pcg3 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec3 v = uvec3(x * 8192.0) * 1664525u + 1013904223u;\n    v += v.yzx * v.zxy;\n    v ^= v >> 16u;\n    return float(v.x + v.y * v.z) * (1.0 / float(0xffffffffu));\n}\n\n// @return Value of the noise, range: [0, 1]\nvec2 hash2D(vec2 x)\n{\n    // based on: Inigo Quilez, Integer Hash - III, 2017\n    uvec4 q = uvec2(x * 8192.0).xyyx + uvec2(0u, 3115245u).xxyy;\n    q = 1103515245u * ((q >> 1u) ^ q.yxwz);\n    uvec2 n = 1103515245u * (q.xz ^ (q.yw >> 3u));\n    return vec2(n) * (1.0 / float(0xffffffffu));\n}\n\n// @return Value of the noise, range: [0, 1]\nvec3 hash3D(vec2 x) \n{\n    // based on: pcg3 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec3 v = uvec3(x.xyx * 8192.0) * 1664525u + 1013904223u;\n    v += v.yzx * v.zxy;\n    v ^= v >> 16u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return vec3(v) * (1.0 / float(0xffffffffu));\n}\n\n// @return Value of the noise, range: [0, 1]\nvec3 hash3D(vec3 x) \n{\n    // based on: pcg3 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec3 v = uvec3(x * 8192.0) * 1664525u + 1013904223u;\n    v += v.yzx * v.zxy;\n    v ^= v >> 16u;\n\n    v.x += v.y * v.z;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    return vec3(v) * (1.0 / float(0xffffffffu));\n}\n\n// @return Value of the noise, range: [0, 1]\nvec4 hash4D(vec2 x)\n{\n    // based on: pcg4 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec4 v = uvec4(x.xyyx * 8192.0) * 1664525u + 1013904223u;\n\n    v += v.yzxy * v.wxyz;\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v.x += v.y * v.w;\n    v.w += v.y * v.z;\n    \n    v ^= v >> 16u;\n\n    return vec4(v ^ (v >> 16u)) * (1.0 / float(0xffffffffu));\n}\n\n// @return Value of the noise, range: [0, 1]\nvec4 hash4D(vec4 x)\n{\n    // based on: pcg4 by Mark Jarzynski: http://www.jcgt.org/published/0009/03/02/\n    uvec4 v = uvec4(x * 8192.0) * 1664525u + 1013904223u;\n\n    v += v.yzxy * v.wxyz;\n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n    \n    v.x += v.y * v.w;\n    v.y += v.z * v.x;\n    v.z += v.x * v.y;\n    v.w += v.y * v.z;\n\n    v ^= v >> 16u;\n\n    return vec4(v ^ (v >> 16u)) * (1.0 / float(0xffffffffu));\n}\n// based on GPU Texture-Free Noise by Brian Sharpe: https://archive.is/Hn54S\nvec3 permutePrepareMod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permutePrepareMod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec4 permuteResolve(vec4 x) { return fract( x * (7.0 / 288.0 )); }\nvec4 permuteHashInternal(vec4 x) { return fract(x * ((34.0 / 289.0) * x + (1.0 / 289.0))) * 289.0; }\n\n// generates a random number for each of the 4 cell corners\nvec4 permuteHash2D(vec4 cell)    \n{\n    cell = permutePrepareMod289(cell * 32.0);\n    return permuteResolve(permuteHashInternal(permuteHashInternal(cell.xzxz) + cell.yyww));\n}\n\n// generates 2 random numbers for each of the 4 cell corners\nvoid permuteHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    cell = permutePrepareMod289(cell);\n    hashX = permuteHashInternal(permuteHashInternal(cell.xzxz) + cell.yyww);\n    hashY = permuteResolve(permuteHashInternal(hashX));\n    hashX = permuteResolve(hashX);\n}\n\n// generates 2 random numbers for the coordinate\nvec2 betterHash2D(vec2 x)\n{\n    uvec2 q = uvec2(x);\n    uint h0 = ihash1D(ihash1D(q.x) + q.y);\n    uint h1 = h0 * 1933247u + ~h0 ^ 230123u;\n    return vec2(h0, h1)  * (1.0 / float(0xffffffffu));\n}\n\n// generates a random number for each of the 4 cell corners\nvec4 betterHash2D(vec4 cell)    \n{\n    uvec4 i = uvec4(cell);\n    uvec4 hash = ihash1D(ihash1D(i.xzxz) + i.yyww);\n    return vec4(hash) * (1.0 / float(0xffffffffu));\n}\n\n// generates 2 random numbers for each of the 4 cell corners\nvoid betterHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 i = uvec4(cell);\n    uvec4 hash0 = ihash1D(ihash1D(i.xzxz) + i.yyww);\n    uvec4 hash1 = ihash1D(hash0 ^ 1933247u);\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n}\n\n// generates 2 random numbers for each of the 2D coordinates\nvec4 betterHash2D(vec2 coords0, vec2 coords1)\n{\n    uvec4 i = uvec4(coords0, coords1);\n    uvec4 hash = ihash1D(ihash1D(i.xz) + i.yw).xxyy;\n    hash.yw = hash.yw * 1933247u + ~hash.yw ^ 230123u;\n    return vec4(hash) * (1.0 / float(0xffffffffu));;\n}\n\n// generates 2 random numbers for each of the four 2D coordinates\nvoid betterHash2D(vec4 coords0, vec4 coords1, out vec4 hashX, out vec4 hashY)\n{\n    uvec4 hash0 = ihash1D(ihash1D(uvec4(coords0.xz, coords1.xz)) + uvec4(coords0.yw, coords1.yw));\n    uvec4 hash1 = hash0 * 1933247u + ~hash0 ^ 230123u;\n    hashX = vec4(hash0) * (1.0 / float(0xffffffffu));\n    hashY = vec4(hash1) * (1.0 / float(0xffffffffu));\n} \n\n// 3D\n\n// generates a random number for each of the 8 cell corners\nvoid permuteHash3D(vec3 cell, vec3 cellPlusOne, out vec4 lowHash, out vec4 highHash)     \n{\n    cell = permutePrepareMod289(cell);\n    cellPlusOne = step(cell, vec3(287.5)) * cellPlusOne;\n\n    highHash = permuteHashInternal(permuteHashInternal(vec2(cell.x, cellPlusOne.x).xyxy) + vec2(cell.y, cellPlusOne.y).xxyy);\n    lowHash = permuteResolve(permuteHashInternal(highHash + cell.zzzz));\n    highHash = permuteResolve(permuteHashInternal(highHash + cellPlusOne.zzzz));\n}\n\n// generates a random number for each of the 8 cell corners\nvoid fastHash3D(vec3 cell, vec3 cellPlusOne, out vec4 lowHash, out vec4 highHash)\n{\n    // based on: https://archive.is/wip/7j1wv\n    const vec2 kOffset = vec2(50.0, 161.0);\n    const float kDomainScale = 289.0;\n    const float kLargeValue = 635.298681;\n    const float kk = 48.500388;\n    \n    //truncate the domain, equivalant to mod(cell, kDomainScale)\n    cell -= floor(cell.xyz * (1.0 / kDomainScale)) * kDomainScale;\n    cellPlusOne = step(cell, vec3(kDomainScale - 1.5)) * cellPlusOne;\n\n    vec4 r = vec4(cell.xy, cellPlusOne.xy) + kOffset.xyxy;\n    r *= r;\n    r = r.xzxz * r.yyww;\n    highHash.xy = vec2(1.0 / (kLargeValue + vec2(cell.z, cellPlusOne.z) * kk));\n    lowHash = fract(r * highHash.xxxx);\n    highHash = fract(r * highHash.yyyy);\n}\n\n// generates a random number for each of the 8 cell corners\nvoid betterHash3D(vec3 cell, vec3 cellPlusOne, out vec4 lowHash, out vec4 highHash)\n{\n    uvec4 cells = uvec4(cell.xy, cellPlusOne.xy);  \n    uvec4 hash = ihash1D(ihash1D(cells.xzxz) + cells.yyww);\n    \n    lowHash = vec4(ihash1D(hash + uint(cell.z))) * (1.0 / float(0xffffffffu));\n    highHash = vec4(ihash1D(hash + uint(cellPlusOne.z))) * (1.0 / float(0xffffffffu));\n}\n\n// @note Can change to (faster to slower order): permuteHash2D, betterHash2D\n// Each has a tradeoff between quality and speed, some may also experience artifacts for certain ranges and are not realiable.\n#define multiHash2D betterHash2D\n\n// @note Can change to (faster to slower order): fastHash3D, permuteHash3D, betterHash3D\n// Each has a tradeoff between quality and speed, some may also experience artifacts for certain ranges and are not realiable.\n#define multiHash3D betterHash3D\n\nvoid smultiHash2D(vec4 cell, out vec4 hashX, out vec4 hashY)\n{\n    multiHash2D(cell, hashX, hashY);\n    hashX = hashX * 2.0 - 1.0; \n    hashY = hashY * 2.0 - 1.0;\n}\n// 2D Value noise.\n// @param scale Number of tiles, must be an integer for tileable results, range: [2, inf]\n// @param phase The phase for rotating the hash, range: [0, inf], default: 0.0\n// @param seed Seed to randomize result, range: [0, inf]\n// @return Value of the noise, range: [-1, 1]\nfloat noise(vec2 pos, vec2 scale, float phase, float seed) \n{\n    const float kPI2 = 6.2831853071;\n    pos *= scale;\n    vec4 i = floor(pos).xyxy + vec2(0.0, 1.0).xxyy;\n    vec2 f = pos - i.xy;\n    i = mod(i, scale.xyxy) + seed;\n\n    vec4 hash = multiHash2D(i);\n    hash = 0.5 * sin(phase + kPI2 * hash) + 0.5;\n    float a = hash.x;\n    float b = hash.y;\n    float c = hash.z;\n    float d = hash.w;\n\n    vec2 u = noiseInterpolate(f);\n    float value = mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n    return value * 2.0 - 1.0;\n}\n\nfloat fbm6(vec2 st) {\n  float val = 0.0;\n  float amp = 1.0;\n  val += noise(st); st *= 2.0;\n  val += 0.5000*noise(st); st *= 2.02;\n  val += 0.2500*noise(st); st *= 2.03;\n  val += 0.1250*noise(st); st *= 2.01;\n  val += 0.0625*noise(st); st *= 2.04;\n\n  return val / 0.9375;\n}\n\nvec3 hsb2rgb( in vec3 c ){\n  vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                           6.0)-3.0)-1.0,\n                   0.0,\n                   1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb);\n  return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec3 hsb2rgb(float h, float s, float b) {\n  return hsb2rgb(vec3(h,s,b));\n}\n\nfloat uSin(float x) {\n  return 0.5*sin(x) + 0.5;\n}\n\nfloat uCos(float x) {\n  return 0.5*cos(x) + 0.5;\n}\n// NOTE: From https://github.com/tuxalin/procedural-tileable-shaders/blob/master/fbm.glsl\n// Classic FBM implementation using Value noise.\n// @param scale Number of tiles, must be  integer for tileable results, range: [2, inf]\n// @param octaves Number of octaves for the fbm, range: [1, inf]\n// @param shift Position shift for each octave, range: [0, inf]\n// @param timeShift Time shift for each octave, range: [-inf, inf]\n// @param gain Gain for each fbm octave, range: [0, 2], default: 0.5\n// @param lacunarity Frequency of the fbm, must be integer for tileable results, range: [1, 32]\n// @param octaveFactor The octave intensity factor, the lower the more pronounced the lower octaves will be, range: [-1, 1], default: 0.0\n// @param seed Seed to randomize result, range: [0, inf], default: 0.0\n// @return value of the noise, range: [0, inf]\nfloat fbm(vec2 pos, vec2 scale, int octaves, float shift, float timeShift, float gain, float lacunarity, float octaveFactor, float seed) \n{\n    float amplitude = gain;\n    float time = timeShift;\n    vec2 frequency = scale;\n    vec2 offset = vec2(shift, 0.0);\n    vec2 p = pos * frequency;\n    octaveFactor = 1.0 + octaveFactor * 0.12;\n    \n    vec2 sinCos = vec2(sin(shift), cos(shift));\n    mat2 rotate = mat2(sinCos.y, sinCos.x, sinCos.x, sinCos.y);\n\n    float value = 0.0;\n    for (int i = 0; i < octaves; i++) \n    {\n        float n = noise(p / frequency, frequency, time, seed);\n        value += amplitude * n;\n        \n        p = p * lacunarity + offset * float(1 + i);\n        frequency *= lacunarity;\n        amplitude = pow(amplitude * gain, octaveFactor);\n        time += timeShift;\n        offset *= rotate;\n    }\n    return value * 0.5 + 0.5;\n}\n\nfloat fbm_value_periodic(vec2 pos) {\n\treturn fbm(pos*0.1, vec2(4.0), 6, 0.0, 0.0, 0.5, 8.0, 0.0, 0.0);    \n}\n/*\n\n\tBox Divide ID\n\t-------------\n\n\tBox divide formula with tile IDs based on position.\n\n*/\n\n// The algorithm still tiles space on a repeat square grid which can obviously\n// look a little repetitive. The following will offset the vertical to break up \n// the straight lines a little more. In fact, it'd be possible to put in more \n// effort and stagger them, or something to that effect. If you were repeat tiling \n// a 3D object, etc, you'd probably want to turn this off. The SHOW_GRID define \n// below will illustrate it better.\n#define VERT_OFFSET\n\n// Show the grid outlines. Note the difference when using the vertical offset, above.\n//#define SHOW_GRID\n\n// Variable line width, if desired.\n//#define VARIABLE_LINE_WIDTH\n\n\n\n// IQ's signed box formula.\nfloat sBox(vec2 p, vec2 b, float r){\n  \n  // Just outside lines.\n  //p = max(abs(p) - b + r, 0.);\n  //return length(p) - r;\n\n  // Inside and outside lines.\n  vec2 d = abs(p) - b + r;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - r;\n}\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Custom box divide formula: I wrote this from scratch, and based it on various \n// techniques, but changed a lot of it to cut down on operations. I also went to\n// some trouble to take a space and position preserving approach, which should make\n// it much easier to work with. The routines I've come across don't do that. :)\n//\n// The idea is simple, in theory, and the solution was simple, but as usual, I had\n// to make way too many mistakes to get there. Basically, you start in one of the\n// corners of the grid square, produce a random number, then split space vertically \n// or horizontally, according to the random factor. For instance, if the random number\n// is \".6,\" then split the space in a 60% to 40% ratio, update postions (depending\n// which side of the line you're on), reduce the space dimensions accordingly, etc.\n//\n// Simple, right? It should have been. :D Anyway, it's done now, so feel free to\n// use it for whatever you want.\n//\nvec4 boxDivide(in vec2 p, out float d) {\n    \n    \n    // Scaling factor. If changing this, you may need to change a few settings\n    // here and there to suit your needs.\n    const float sc = 1.5;\n    p *= sc;\n    \n    \n    // Basid grid tile ID. This will be further split into subtiles, which will\n    // each have their own ID based on postion.\n    vec2 ip = floor(p); \n   \n    // If using the vertical offset option, update the position and ID accordingly.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        p.y -= 1./2.;\n        ip = floor(p);\n    }\n    #endif\n   \n    p -= ip + .5; // The original grid tile's base local coordinates.\n    \n    \n    #ifdef SHOW_GRID\n    float grid = abs(max(abs(p.x), abs(p.y)) - .5) - .005;\n    #endif\n    \n    // Block dimension. Every time there's a random split, it'll be factored down\n    // according to the random split factor.\n    vec2 l = vec2(1, 1);  \n    \n    // The starting point, which represents the bottom left corner (or is it the top left corner?)\n    // of the grid cell. With every split, it will be moved to the new split position.\n    vec2 s = vec2(-.5);    \n    \n    // Split number.\n    const int iNum = 6;\n\n    \n    //float r = hash21(ip);\n    //float r2 = hash21(ip + .35);\n    \n    float count = 0.;\n    \n    \n    // Create a box, divide it randomly, then do the same with the \n    // divided portions. Ad infinitum...\n    for(int i=0; i<iNum; i++) {\n \n        float r = hash21(ip + l + float(i)/float(iNum))*.3 + (1. - .3)/2.;\n        // Forcing a vertical to horizontal split (and vice versa) every\n        // iteration. It's not necessary, but I think it looks nicer.\n        float r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        \n        // Alternate, more randomized sequence.\n        //float r2 = hash21(ip + 113.5 + l.yx + float(i)/float(iNum));\n        // Alternate heuristic, for aesthetics purposes, to ensure at least one split.\n        // If using this, be sure to uncomment the \"count++\" line below.\n        //if(i==iNum-1 && count<1.5) r2 = 1.;\n\t\t//if(i==iNum-1 && count>float(iNum) - 2.5) r2 = 0.;\n \n        \n        // Alternate way to randomize things. How this is achieved is up to the user.\n        //r = hash21(l + r + float(i)/float(iNum))*.3 + (1.-.3)/2.;\n        //r2 = hash21(l.yx + r + r2 + float(i)/float(iNum));\n        \n         \n        //r2 = mod(float(i), 2.)>.5? 0. : 1.;\n        //if(r2<.5) { p = p.yx; l = l.yx; s = s.yx; }\n        \n        // If the second random number is above a certain threshold, split \n        // vertically. Otherwise, split horizontally.\n        if(r2>.5){ \n            \n            // Counter for heuristics above. Uncomment if using them.\n            // count++;\n            \n            // This line splits the current cell down the middle, in accordance with\n            // the random factor, \"r,\" and the cell width \"l.x.\" \n            if(p.x>s.x + l.x*r) {\n\n                s.x += l.x*r; // Advance the position to the right of the split.\n                l.x *= (1. - r); // Reduce the width by a factor of \"1 - r.\"\n            }\n            else l.x *= r; // No need to advance position, but we need to reduce the width.\n        \n        }\n        else {\n            \n             // This line splits the current cell horizontally, in accordance with\n             // the random factor, \"r,\" and the cell height \"l.y.\" \n             if(p.y>s.y + l.y*r) {\n\n                s.y += l.y*r; // Advance the position above (or below?) the split.\n                l.y *= (1. - r); // Reduce the height by a factor of \"1 - r.\"\n\n             }\n             else l.y *= r; // No need to advance position, but we need to reduce the height.\n            \n        }\n        \n        // There are many ways to vary the line width.\n        #ifdef VARIABLE_LINE_WIDTH\n        //l *= 1. - r*.03;\n        //l *= 1. - length(l)*.02;\n        //l *= .986;\n        #endif\n\n    }\n    \n    \n    // Constructing the box itself: Actually, once you have the box coordinates, you can \n    // do whatever you want with them.\n    //\n    // Rounding factor: This depends on the look you're after. It could be a constant, \n    // or you could choose to have no rounding at all. After experimentingn, I decided \n    // to make the roundedness of the tile dependent on the minimum side length.\n    float rf = min(l.x, l.y); \n    d = sBox(p - s - l/2., l/2., .08*sqrt(rf)) + .00*sc;\n    \n   \n    \n    // Smoothing factor.\n    float sf = 1./iResolution.y*sc;\n    \n    // Individual, position-based tile ID. Note that it'll read into the texture\n    // at the correct position.\n    vec2 id = ip + s + l/2.;\n    \n    // If using the vertical offset, the ID needs to follow suit.\n    #ifdef VERT_OFFSET\n    if(mod(ip.x, 2.)>.5){\n        id.y += .5;\n    }\n    #endif\n    \n    \n    \n    // Using the ID to color the individual tile.\n    \n    \n    // Textured version. Note that this is not an overlay -- Each tile has \n    // a uniform color.\n    //vec3 tx = texture(iChannel0, id/sc/1.5).xyz; tx *= tx;\n\n\tvec3 colorA = vec3(0.8, 0.6, 0.4);\n\t  vec3 colorB = vec3(0.7, 0.5, 0.5);\n\t  vec3 colorC = vec3(1.0, 1.0, 1.0);\n\t  vec3 colorD = vec3(0.0, 0.1, 0.20);\n\tvec3 tx = palette(length(id/sc/1.5), colorA, colorB, colorC, colorD);\n\n    vec3 pCol = min(tx*2., 1.);\n    \n    // Original random colored version.\n    //vec3 pCol = vec3(1, hash21(id), hash21(id*57. + .5));\n    \n    // 2D noise, etc.\n    //float c =  n2D(id*2. + iTime);\n    //vec3 pCol = min(vec3(c*.1 + .9, c + .05, c*c*.7), 1.); \n\n    \n   \n    \n    vec3 col = vec3(.125);\n    float sh = clamp(.5 - d*5./length(l), 0., 1.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d)); // Rounded pavers.\n    col = mix(col, pCol, 1. - smoothstep(0., sf, d + .005*sc)); \n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(d + .01*sc) - .001*sc)); \n    // More decoration, if so desired.\n    //col = mix(col, mix(pCol*1.5, vec3(1), .35), 1. - smoothstep(0., sf, d + .005*sc)); \n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, d + .012*sc))*.9); \n    //col = mix(col, pCol*sh, 1. - smoothstep(0., sf, d + .016*sc)); \n \n    \n    // Center, space preserving dots.\n    \n    // Just the center dot.\n    float d2 = length(p - s - l/2.) - min(.01, l.x*l.y)/sc;\n    \n    // Splitting space to produce four rivot-looking dots.\n    //p = abs(p - s - l/2.) - l/2. + .035;\n    //float d2 = length(p) - .01/sc;\n    \n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, d2)); // Rounded pavers.\n    \n    \n    #ifdef SHOW_GRID\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf*2., grid - .005)); \n    col = mix(col, vec3(1, .8, .2), 1. - smoothstep(0., sf, grid)); \n    #endif\n \n    \n\tvec2 coord = p-s-l/2.;\n\tfloat aspect = 1.0;\n\tif (l.y > l.x) {\n\t\tcoord = coord.yx;\n\t\taspect = l.y / l.x;\n\t\t//coord.y *= l.y / l.x;\n\t\tcoord = coord / l.x;\n\t} else {\n\t\t//coord.x *= l.x / l.y;\n\t\taspect = l.x / l.y;\n\t\tcoord = coord / l.y;\n\t}\n    return vec4(coord, id);\n    \n}\n\nfloat expImpulse( float x, float k )\n{\n    float h = k*x;\n    return h*exp(1.0-h);\n}\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b)/(pow(a,a)*pow(b,b));\n    return k*pow(x,a)*pow(1.0-x,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = gl_FragCoord.xy / iResolution.xy;\n  float aspect = iResolution.x / iResolution.y;\n  uv.x *= aspect;\n\n  float tile_offset_iteration = floor(0.05*iTime);\n  float tiling_rand_offset = random(vec2(93.0, 77.0) + vec2(tile_offset_iteration*13.0));\n  float d;\n  vec4 box = boxDivide(uv*0.33 + 1000.0*vec2(tiling_rand_offset), d);\n  vec2 st = box.xy*1.0;\n\n  //vec2 st = 2.0*uv - 1.0;\n  //st.x *= aspect;\n\n  //st = mod(st*2.0, 1.0) - vec2(0.5);\n\n  st *= 2.0;\n\n  vec3 color = vec3(0.0);\n  float a = atan(st.y, st.x);\n  float rad = length(st);\n\n  float elongatedRad = rad + abs(st.y*0.5);\n\n  float box_rand_1 = random(box.zw);\n  float iteration = floor(0.3*iTime + box_rand_1);\n  float box_rand_func = random(box.zw + vec2(13.0, 19.0) + vec2(iteration*19.0));\n\n  float box_rand_2 = random(box.zw + vec2(1.0, 0.0) + vec2(iteration*19.0));\n  float box_rand_3 = random(box.zw + vec2(1.0, 1.0) + vec2(iteration*19.0));\n  float box_rand_4 = random(box.zw + vec2(0.0, 1.0) + vec2(iteration*19.0));\n  float box_rand_5 = random(box.zw + vec2(2.0, 1.0) + vec2(iteration*19.0));\n  float box_rand_6 = random(box.zw + vec2(2.0, 2.0) + vec2(iteration*19.0));\n  float box_rand_7 = random(box.zw + vec2(1.0, 2.0) + vec2(iteration*19.0));\n  float box_rand_8 = random(box.zw + vec2(2.0, 0.0) + vec2(iteration*19.0));\n  float box_rand_9 = random(box.zw + vec2(0.0, 2.0) + vec2(iteration*19.0));\n  float box_rand_10 = random(box.zw + vec2(3.0, 0.0) + vec2(iteration*19.0));\n  float box_rand_11 = random(box.zw + vec2(3.0, 3.0) + vec2(iteration*19.0));\n  float box_rand_12 = random(box.zw + vec2(0.0, 3.0) + vec2(iteration*19.0));\n  float box_rand_13 = random(box.zw + vec2(3.0, 1.0) + vec2(iteration*19.0));\n  float box_rand_14 = random(box.zw + vec2(1.0, 3.0) + vec2(iteration*19.0));\n\n  float ss = 0.0;\n  if (box_rand_func > 0.5) {\n  \tss = expImpulse(fract(0.3*iTime + box_rand_1), 2.0+(16.0*abs(random(box.zw + vec2(iteration*13.15749)))));\n  }\n\telse {\n\tss = pcurve(fract(0.3*iTime + box_rand_1),\n\t\t\t  4.0-(2.0*abs(random(box.zw + vec2(iteration*13.15749)))),\n\t\t\t4.0-(2.0*abs(random(box.zw + vec2(iteration*47.71922)))));\n  }\n  //float ss = 0.5 + 0.5*sin(3.0*u_time*(1.0+box_rand_1));\n  //float ss = expImpulse(fract(0.2*u_time + box_rand_1*PI), 2.0+(16.0*abs(random(box.zw + vec2(iteration*13.15749)))));\n  //ss = (1.0-ss);\n  float anim = 1.0 + 0.8*ss*(1.0 - rad);\n\n  //elongatedRad += anim*(abs(st.y)/(1.0 - ss));\n  elongatedRad += anim*(abs(st.y)/(ss));\n\n  //float iteration = floor(((3.0*u_time) / (2.0*PI)) + 0.25);\n\n  if (elongatedRad < 0.8) {\n\n    color = vec3(1.0);\n\n    float eyeR = 0.42;\n    if (rad < eyeR) {\n      //color = vec3(0.0, 0.7, 0.1)*anim*0.8;\n\t  //color = rand1.xyz*anim*0.8;\n\t\tvec3 colorA = vec3(0.8, 0.6, 0.4);\n\t  vec3 colorB = vec3(0.7, 0.5, 0.5);\n\t  vec3 colorC = vec3(1.0, 1.0, 1.0);\n\t  vec3 colorD = vec3(0.0, 0.1, 0.20);\n\t  color = vec3(abs(box_rand_2), abs(box_rand_3), abs(box_rand_4))*anim*0.8;\n\n      float eyeR = rad / eyeR;\n\n      //a += 0.05*fbm_value_periodic(30.0*st);\n      //float f = 1.0 - smoothstep(0.42, 1.0, anim*eyeR*fbm(vec2(9.0*eyeR, 28.0*a)));\n      float f = 1.0 - smoothstep(0.42, 1.0, anim*eyeR*fbm6(vec2(9.0*box_rand_11*eyeR, 24.0*a)));\n      //color = mix(color, vec3(0.6,0.1,0.1), f);\n\t  vec3 mix_color = vec3(abs(box_rand_5), abs(box_rand_6), abs(box_rand_7));\n      color = mix(color, mix_color, f);\n\n      f = 1.0 - smoothstep(0.42,1.7,fbm6(vec2(7.0*box_rand_12*eyeR, 12.0*a)));\n      color *= f;\n\n      f = smoothstep(0.6,1.2, eyeR);\n\t  mix_color = vec3(abs(box_rand_8), abs(box_rand_9), abs(box_rand_10));\n      color = mix(color, mix_color, f);\n\n      f = 1.0 - smoothstep(0.22, 0.42, anim*eyeR);\n      color = mix(color, vec3(0.0,0.0,0.0), f);\n\n      f = smoothstep(0.95,1.0,eyeR);\n      color = mix(color, vec3(1.0), f);\n\n      f = smoothstep(0.22, 0.42, eyeR);\n      color *= f;\n\n      // f = 1.0 - smoothstep(0.0,0.5,length(st - vec2(0.3,0.2)));\n      // color += vec3(0.7,0.7,0.6)*f*0.3;\n    }\n\n    float f = smoothstep(0.95,1.0,elongatedRad/0.8);\n    color = mix(color, vec3(0.0, 0.0, 0.0), f);\n  } else {\n\t  color = vec3(d);\n\t  color = vec3(1.1-elongatedRad)*vec3(0.7, 0.4, 0.4);\n\t  //color = vec3(d)*vec3(1.1-elongatedRad)*vec3(0.9, 0.8, 0.6);\n\t  //color = vec3(d)*vec3(1.1-elongatedRad)*vec3(0.9, 0.8, 0.6);\n  }\n\n  //color = vec3(fbm_value_periodic(st*10.0));\n  //color = vec3(fbm6(st*10.0));\n\n  fragColor = vec4(color, 1.0);\n  //frag_color = vec4(box.zw, 0.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}