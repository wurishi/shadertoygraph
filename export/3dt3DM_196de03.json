{"ver":"0.1","info":{"id":"3dt3DM","date":"1569830183","viewed":146,"name":"JEWEL","username":"ankd","description":"volumetric rendering.\nreference : \"Playing marble\" by guil\nhttps://www.shadertoy.com/view/MtX3Ws","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(in float t) {\n\tfloat s = sin(t+sin(t*1.1+sin(t*1.2)));\n    return s;\n}\n\nmat2 rotate(in float r) { float c=cos(r),s=sin(r); return mat2(c, s, -s, c); }\n\nvec2 cmul(in vec2 a, in vec2 b) { return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x); }\nvec2 csqr(in vec2 a) { return vec2(a.x*a.x - a.y*a.y, 2.0*a.x*a.y); }\n\n// distance function\nfloat sphere(in vec3 p, in float r) { return length(p) - r; }\nfloat box(in vec3 p, in vec3 b) { vec3 d=abs(p)-b; return length(max(d, 0.))+min(max(d.x,max(d.y,d.z)),0.); }\n\n// get geometry\nfloat geometry(in vec3 p) {\n    vec3 q = p;\n    vec3 c = vec3(1.);\n    //q = mod(q, c) - 0.5*c;\n    \n    float res = box(q, vec3(0.3));\n\treturn res;\n}\n\nvec3 normal(in vec3 p) {\n    vec2 e = vec2(1., -1.) * 0.001;\n    return normalize(\n    \te.xyy*geometry(p+e.xyy) +\n    \te.yxy*geometry(p+e.yxy) +\n    \te.yyx*geometry(p+e.yyx) +\n    \te.xxx*geometry(p+e.xxx)\n    );\n}\n\n// pattern in geometry\nfloat map(in vec3 p) {\n\tfloat res = 0.;\n    vec3 c = p;\n\tfor (int i = 0; i < 10; ++i) {\n        //p =.7*abs(p)/dot(p,p) -.7;\n        p =.7*abs(p)/dot(p,p) -.8*noise(iTime*0.3);\n        p.yz= csqr(p.yz);\n        p=p.zxy;\n        res += exp(-19. * abs(dot(p,c)));\n\t}\n\treturn res/2.;\n}\n\n\n// ray march to get geometry\nvec2 getTMinMax(in vec3 ro, in vec3 rd, in vec2 cminmax) {\n    vec2 res = vec2(-1.);\n    float thr = 0.001;\n\n    // calc tmin\n    float t = cminmax.x;\n    for(int i=0;i<128;i++) {\n    \tfloat tmp = geometry(ro + rd*t);\n        tmp = max(tmp, 0.);\n        if(tmp<thr || cminmax.y<t) {\n            break;\n        }\n        t += tmp*0.5;\n    }\n    if(cminmax.y<t) return vec2(-1.);\n    res.x = t;\n    \n    // calc tmax\n    //t += 4.*thr;\n    t += 0.05;\n    for(int i=0;i<128;i++) {\n    \tfloat tmp = geometry(ro + rd*t);\n        tmp *= -1.;\n        if(tmp<thr || cminmax.y<t) {\n            break;\n        }\n        t += tmp*0.5;\n    }\n    res.y = cminmax.y<t ? cminmax.y : t;\n    return res;\n}\n\n// \nvec3 rayMarch(in vec3 ro, in vec3 rd, in vec2 tminmax) {\n    vec3 col = vec3(0.);\n    \n\tfloat t = tminmax.x;\n\tfloat dt = (tminmax.y-tminmax.x) / 64.;\n    //dt = 0.02;\n\tfor(int i=0;i<16;i++) {\n\t\t// march t\n        t += dt;\n\t\tif(tminmax.y<t) break;\n        float c = map(ro + rd*t);\n        col = 0.99*col + 0.02*vec3(c*c);\n    }\n    //col = vec3(acc);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord*2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat time = iTime*0.1;\n\n    // camera\n    vec3 ro = vec3(cos(time), 0., sin(time));\n    //ro = vec3(0., 0., -time);\n    vec3 ta = vec3(0., 0., 0.);\n    float cr = 0.3*sin(0.1*iTime);\n    vec3 cz = normalize(ta-ro);\n    vec3 cx = normalize(cross(cz, vec3(sin(cr), cos(cr), 0.)));\n    vec3 cy = normalize(cross(cx, cz));\n    vec3 rd = normalize(mat3(cx, cy, cz) * vec3(p, 2.));\n    \n    // get tmin, tmax\n    vec2 tmm = getTMinMax(ro, rd, vec2(0., 10.));\n        \n    // render\n    vec3 col = vec3(0.);\n    if(tmm.x<0.){\n        col = vec3(1.0);\n    } else {\n\t    col = rayMarch(ro, rd, tmm);\n    }\n    \n    col += 0.3*vec3(tmm.y-tmm.x);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}