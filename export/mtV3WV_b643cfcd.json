{"ver":"0.1","info":{"id":"mtV3WV","date":"1684737057","viewed":103,"name":"ray marching effect 0","username":"ZeroSkyline","description":"ray marching 0","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HIGH_QUAL\nstruct Ray\n{\n    vec3 p;\n    float t;\n    vec3 d;\n};\nstruct Hit\n{\n    float t;\n    vec3 n;\n};\nvec3 GetPixelDir(float fov, vec2 fragCoord)\n{\n    vec3 dir;\n    dir.xy = fragCoord - iResolution.xy * 0.5;\n    dir.z = iResolution.y * 0.5 / tan(radians(fov*0.5));\n    return normalize(dir);\n}\nfloat SpherePixelDistance(vec3 p, vec3 c, float r)\n{\n    return distance(p, c) - r;\n}\nfloat ScenePixelDistance(vec3 p)\n{\n    float sd = 10000.f, d;\n    float r = .4f;\n    \n    d = SpherePixelDistance(p, vec3(sin(iTime)*r, cos(iTime)*r, 1.f), .2f);\n    sd = min(sd, d);\n    d = SpherePixelDistance(p, vec3(sin(iTime*(1.f+.302f))*r, cos(iTime*(1.f+.154f))*r, 1.f), .3f);\n    sd = min(sd, d);\n    d = SpherePixelDistance(p, vec3(sin(iTime*(1.f+.247f))*r, cos(iTime*(1.f+.74f))*r, 1.f), .3f);\n    sd = min(sd, d);\n    d = SpherePixelDistance(p, vec3(sin(iTime*(1.f-.990f))*r, cos(iTime*(1.f-.100f))*r, 1.f), .2f);\n    sd = min(sd, d);\n    d = SpherePixelDistance(p, vec3(sin(iTime*(1.f-.191f))*r, cos(iTime*(1.f-.149f))*r, 1.f), .2f);\n    sd = min(sd, d);\n    return sd;\n}\nfloat BlurScenePixelDistance(vec3 p)\n{\n    float d = 0.128f;\n    float r = ScenePixelDistance(p + vec3(1.f,0.f,0.f)*d);\n    float l = ScenePixelDistance(p + vec3(-1.f,0.f,0.f)*d);\n    float f = ScenePixelDistance(p + vec3(0.f,0.f,-1.f)*d);\n    float b = ScenePixelDistance(p + vec3(0.f,0.f,1.f)*d);\n    float u = ScenePixelDistance(p + vec3(0.f,1.f,0.f)*d);\n    float dn = ScenePixelDistance(p + vec3(0.f,-1.f,0.f)*d);\n    #ifdef HIGH_QUAL\n    float t = .707f;\n    float lub = ScenePixelDistance(p + vec3(-t, t, t)*d);\n    float rub = ScenePixelDistance(p + vec3(t, t, t)*d);\n    float ldb = ScenePixelDistance(p + vec3(-t, -t, t)*d);\n    float rdb = ScenePixelDistance(p + vec3(t, -t, t)*d);\n    float luf = ScenePixelDistance(p + vec3(-t, t, -t)*d);\n    float ruf = ScenePixelDistance(p + vec3(t, t, -t)*d);\n    float ldf = ScenePixelDistance(p + vec3(-t, -t, -t)*d);\n    float rdf = ScenePixelDistance(p + vec3(t, -t, -t)*d);\n    return (l + r + u + dn + f + b + lub + rub + ldb + rdb + luf + ruf + ldf + rdf) / 14.f;\n    #else\n    return (l + r + u + dn + f + b) / 6.f;\n    #endif\n\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = .128f;\n    float dx = BlurScenePixelDistance(p + vec3(d, 0.f, 0.f)) - BlurScenePixelDistance(p - vec3(d, 0.f, 0.f));\n    float dy = BlurScenePixelDistance(p + vec3(0.f, d, 0.f)) - BlurScenePixelDistance(p - vec3(0.f, d, 0.f));\n    float dz = BlurScenePixelDistance(p + vec3(0.f, 0.f, d)) - BlurScenePixelDistance(p - vec3(0.f, 0.f, d));\n    return normalize(vec3(dx, dy, dz));\n}\nHit RayMarching(Ray r)\n{\n    Hit h;\n    float t = r.t;\n    for(int i = 0; i != 64; i++)\n    {\n        vec3 p = r.p + t * r.d;\n        float d = BlurScenePixelDistance(p);\n        if(d < 0.0001)\n        {\n            h.t = t;\n            h.n = GetNormal(p);\n            return h;\n        }\n        else\n        {\n            t += d;\n        }\n    }\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    Ray r;\n    r.p = vec3(0.f);\n    r.t = 0.f;\n    r.d = GetPixelDir(60.f, fragCoord);\n    \n    Hit h = RayMarching(r);\n    \n    float nl = dot(h.n, normalize(vec3(1.f,1.f,-1.f)));\n    \n    vec3 col = mix(vec3(.8f, .8f, 0.8f), vec3(.02f, .1f, .1f), clamp(nl, 0.f, 1.f));\n        \n    float nv = dot(h.n, vec3(0.f, 0.f, 1.f));\n    col += (vec3(clamp(nv, 0.f, 1.f)) * 0.5f + 0.5f) * vec3(.7f,.7f,0.8f);\n    \n    float env_nl0 = dot(h.n, normalize(vec3(0.f,1.f,-.5f)));\n    col += vec3(pow(clamp(env_nl0, 0.f, 1.f), 1000.f)) * vec3(1.f, .5f, .2f);\n    float env_nl1 = dot(h.n, normalize(vec3(-1.f,1.f,-1.f)));\n    col += vec3(pow(clamp(env_nl1, 0.f, 1.f), 90.f)) * vec3(1.f,.9f,.5f);\n    col += vec3(pow(clamp(nl, 0.f, 1.f), 30.f)) * vec3(.8f, .9f, 1.f);\n\n    if (h.t <= 0.f)\n        col *= mix(0.128f, 0.333f, uv.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}