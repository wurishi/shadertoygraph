{"ver":"0.1","info":{"id":"WtScDc","date":"1595495932","viewed":84,"name":"RepOrg","username":"fayolle","description":"Some blended organic repeated structure","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blend","repeatingstructures"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 2\n\n// ----------------- code simple scene\n\nfloat boundblenduni(float f1, float f2, float f3, float a0, float a1, float a2, float a3)\n{\n  float r1 = f1*f1/(a1*a1)+f2*f2/(a2*a2);\n  float r2 = 0.0;\n  if (f3 > 0.0) r2 = f3*f3/(a3*a3);\n  float rr = 0.0;\n  if (r1 > 0.0) rr = r1/(r1+r2);\n  float d = 0.0;\n  if (rr < 1.0) d = a0*(1.0-rr)*(1.0-rr)*(1.0-rr)/(1.0+rr);\n  return f1 + f2 + sqrt(f1*f1 + f2*f2) + d;\n}\n\nfloat torus_x(float x, float y, float z, float cx, float cy, float cz, float R, float r)\n{\n  float x0 = x - cx;\n  float x1 = y - cy;\n  float x2 = z - cz;\n  \n  return (r * r) - (x0 * x0) - (x1 * x1) - (x2 * x2) - (R * R) + 2.0 * R\n      * sqrt((x1 * x1) + (x2 * x2));\n}\n\nfloat torus_y(float x, float y, float z, float cx, float cy, float cz, float R, float r)\n{\n  float x0 = x - cx;\n  float x1 = y - cy;\n  float x2 = z - cz;\n  \n  return (r * r) - (x0 * x0) - (x1 * x1) - (x2 * x2) - (R * R) + 2.0 * R\n      * sqrt((x0 * x0) + (x2 * x2));\n}\n\nfloat torus_z(float x, float y, float z, float cx, float cy, float cz, float R, float r)\n{\n  float x0 = x - cx;\n  float x1 = y - cy;\n  float x2 = z - cz;\n  \n  return (r * r) - (x0 * x0) - (x1 * x1) - (x2 * x2) - (R * R) + 2.0 * R\n      * sqrt((x0 * x0) + (x1 * x1));\n}\n\nfloat sphere(float x, float y, float z, float cx, float cy, float cz, float r)\n{\n  float x0 = x - cx;\n  float x1 = y - cy;\n  float x2 = z - cz;\n  \n  return (r * r) - (x0 * x0) - (x1 * x1) - (x2 * x2);\n}\n\nfloat r_union(float f, float g)\n{\n  return f + g + sqrt(f*f + g*g);\n}\n\nfloat rep(float x, float y, float z)\n{\n  float M_PI = 3.14159;\n  float xt = 2.0*(0.5-atan(1.0/tan(M_PI*(x/5.0-0.5)))/M_PI) - 1.0;\n  float yt = 2.0*(0.5-atan(1.0/tan(M_PI*(y/5.0-0.5)))/M_PI) - 1.0;\n  float zt = 2.0*(0.5-atan(1.0/tan(M_PI*(z/5.0-0.5)))/M_PI) - 1.0;\n\n  float torus1 = torus_z(xt, yt, zt, -1.0, 1.0, 0.0, 1.0, 0.1);\n  float torus2 = torus_x(xt, yt, zt, 0.0, -1.0, -1.0, 1.0, 0.1);\n  float torus3 = torus_y(xt, yt, zt, 1.0, 0.0, 1.0, 1.0, 0.1);\n\n  float sphere1 = sphere(xt, yt, zt, 0.0, 0.0, 0.0, 0.8);\n\n  // Boolean version\n  //float res1 = r_union(torus1, torus2);\n  //float res = r_union(res1, torus3);\n\n  // Blended version\n  float res1 = boundblenduni(torus1, torus2, sphere1, 0.08, 1.0, 1.0, 1.0);\n  float res = boundblenduni(res1, torus3, sphere1, 0.08, 1.0, 1.0, 1.0);\n\n  return res;\n}\n\n// ------\n\nfloat scene(in vec3 p)\n{\n    return -rep(p.x, p.y, p.z);\n}\n\nvec3 grad(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return e.xyy * scene(pos + e.xyy) +\n                     e.yyx * scene(pos + e.yyx) +\n                     e.yxy * scene(pos + e.yxy) +\n                     e.xxx * scene(pos + e.xxx);\n}\n\nfloat map(in vec3 p)\n{\n    return scene(p);\n}\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n    float res = -1.0;\n\n    float tmin = 0.1;\n    float tmax = 300.0;\n\n    float t = tmin;\n    for (int i = 0; i < 300 && t < tmax; i++)\n    {\n        float h = map(ro + rd * t);\n        if (abs(h) < (0.0001 * t))\n        {\n            res = t;\n            break;\n        }\n        t += h;\n    }\n\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(pos + e.xyy) +\n                     e.yyx * map(pos + e.yyx) +\n                     e.yxy * map(pos + e.yxy) +\n                     e.xxx * map(pos + e.xxx));\n}\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y, 0.0) * 0.3;\n    float t = castRay(ro, rd);\n\n    if (t != -1.0)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        // material\n        col = vec3(0.7, 0.1, 0.1) - max(rd.y, 0.0) * 0.3;\n\n        // lighting\n        vec3 lig = normalize(vec3(-0.5, 0.4, -0.6));\n        vec3 hal = normalize(lig - rd);\n        float amb = sqrt(clamp(0.5 + 0.5 * nor.y, 0.0, 1.0));\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.2, 0.2, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\n        float spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n                    dif *\n                    (0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\n        vec3 lin = vec3(0.0);\n        lin += 3.80 * dif * vec3(1.30, 1.00, 0.70);\n        lin += 0.55 * amb * vec3(0.40, 0.60, 1.15);\n        lin += 0.85 * dom * vec3(0.40, 0.60, 1.30);\n        lin += 0.55 * bac * vec3(0.25, 0.25, 0.25);\n        lin += 0.25 * fre * vec3(1.00, 1.00, 1.00);\n        col = col * lin;\n        col += 7.00 * spe * vec3(1.10, 0.90, 0.70);\n\n        col = mix(col, vec3(0.7, 0.7, 0.9), 1.0 - exp(-0.0001 * t * t * t));\n    }\n    else\n    {\n        col = vec3(1.0, 1.0, 1.0);\n    }\n\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = (cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n    float time = 15.0 + iTime * 1.5;\n\n    // camera\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro = ta + vec3(12.5 * cos(0.1 * time + 6.0 * mo.x), 1.0 + 2.0 * mo.y, 15.0 * sin(0.1 * time + 6.0 * mo.x));\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 tot = vec3(0.0);\n#if AA > 1\n    for (int m = 0; m < AA; m++)\n        for (int n = 0; n < AA; n++)\n        {\n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;\n#else\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n#endif\n\n            // ray direction\n            vec3 rd = ca * normalize(vec3(p, 2.5));\n\n            // render\n            vec3 col = render(ro, rd);\n\n            // gamma\n            col = pow(col, vec3(0.4545));\n\n            tot += col;\n#if AA > 1\n        }\n    tot /= float(AA * AA);\n#endif\n\n    fragColor = vec4(tot, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}