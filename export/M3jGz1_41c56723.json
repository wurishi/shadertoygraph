{"ver":"0.1","info":{"id":"M3jGz1","date":"1708218486","viewed":53,"name":"Level 2 - 15-25 points","username":"JetJayy","description":" Low to medium complexity\n Example: interpolating between an animated gradient via distance","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [0, 0] at bottom left, [1, 1] at top right \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // [0, 0] at centre, [-1, -1] at bottom left, [1, 1] at top right\n    vec2 n = uv * 2.0 - 1.0;\n    \n    // Apply aspect ratio (otherwise our circle gets distorted)\n    n.x *= iResolution.x / iResolution.y;\n    \n    // Black-red-green-yellow\n    vec3 a = vec3(uv.x, uv.y, 0.0);\n    \n    // Blue-magenta-teal-white gradient\n    vec3 b = vec3(uv.x, uv.y, 1.0);\n    \n    // Distance from centre to current fragment (0 at centre, 1 at edges)\n    float d = length(n);\n    \n    // Varying sphere size based on time\n    float sphereSize = abs(sin(iTime));\n    \n    // Adjust distance based on sphere size\n    d = d * sphereSize;\n    \n    // Black background\n    vec3 background = vec3(0.0, 0.0, 0.0);\n    \n    // Blend between gradients via sine wave function\n    vec3 gradient = mix(a, b, sin(iTime + d) * 0.5 + 0.5);\n    \n    // Blend between background & gradient based on distance from centre\n    vec3 color = mix(gradient, background, d);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}