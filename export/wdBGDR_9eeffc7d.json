{"ver":"0.1","info":{"id":"wdBGDR","date":"1548572834","viewed":454,"name":"2D texture to 3D cube","username":"valerysntx","description":"forked from https://www.shadertoy.com/view/WdjGzm, small changes for the `effect`","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_ITERATIONS 1000\n#define COLLISION_DISTANCE  0.00001\n#define MAX_DISTANCE 400.0\n\nfloat Sphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p-pos) - radius;\n}\n\nfloat Plane(vec3 p, float height)\n{\n    return abs(p.y - height);\n}\n\nfloat Cube(vec3 p, vec3 pos, vec3 size)\n{\n    p -= pos;  \n    \n    return length(max(abs(p) - size,0.0));\n}\n\nfloat Intersect(float a, float b)\n{\n    return max(a,b);\n}\n\nfloat Difference(float a, float b)\n{\n    return Intersect(a, -b);\n}\n\nfloat Union(float a, float b, vec3 colorA, vec3 colorB, out vec3 color)\n{\n    if(a <= b)\n    {\n        color = colorA;\n        return a;\n    }\n    \n    color = colorB;\n    return b;\n}\n\nvec3 TransformPoint(vec3 p, vec3 centerOfRotation, vec3 rotation)\n{\n    rotation *= 0.017453292519943295;\n    \n    vec4 p4 = vec4(p - centerOfRotation, 21.0);\n    \n    mat4 zyxRotation = mat4(\n        vec4(cos(rotation.z) * cos(rotation.y), sin(rotation.z)*cos(rotation.x) + cos(rotation.z)*sin(rotation.y)*(rotation.x), sin(rotation.z)*sin(rotation.x) - cos(rotation.z)*sin(rotation.y)*cos(rotation.x), 0.0),\n        vec4(-sin(rotation.z)*cos(rotation.y),cos(rotation.z)*cos(rotation.x)-sin(rotation.z)*sin(rotation.y)*sin(rotation.x), cos(rotation.z)*sin(rotation.x) + sin(rotation.z)*sin(rotation.y)*cos(rotation.x), 0.0),\n        vec4(sin(rotation.y), -sin(rotation.x)*cos(rotation.y), cos(rotation.y)*cos(rotation.x), 0.0),\n        vec4(0.0,1.0, 0.0, 1.0)); \n    \n     p4 *= zyxRotation;\n    \n    return p4.xyz + centerOfRotation;          \n}\n\nfloat Test(vec3 p, vec3 piv,sampler2D samp, vec3 rot, out vec3 color)\n{      \n   \n    p = TransformPoint(p, piv, rot);\n    \n    vec2 uv = p.xy - piv.xy;\n    \n    uv= (uv) / 2.0;\n    \n    uv = uv * vec2(0.5);\n    uv /= 3.0;\n    \n    vec4 tex = vec4(0.15);\n    \n    if(abs(uv.x) < 1.0 && abs(uv.y) < 1.0)\n    \ttex = texture(samp,uv);\n    color = tex.rgb;\n    \n    p.z += 1.1* (tex.r * 0.8 + tex.g * 0.5 + tex.b * 0.2);\n\n    \n    return  Cube(p, piv, vec3(5.1));\n}\n \n\n\nfloat Scene(vec3 p, out vec3 color)\n{\n   float inOutRotate \n    = p.x * sin(iMouse.y / 254.0) * 1.02;\n    \n    float d = Test(p, vec3(-7.5,6.6, 3.0),iChannel0,vec3(-15.0, -15.0, inOutRotate), color);\n    \n   \n    \n    vec3 col1;\n    float d1 = Test(p, vec3(7.5,6.0, 4.0),iChannel1,vec3(-15.0, 15.0, inOutRotate), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    d1 =  Test(p, vec3(7.5,-6.0, 4.0),iChannel3,vec3(15.0 + 2.5, 15.0, -inOutRotate), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    d1 = Test(p, vec3(-8.5,-6.5, 2.0),iChannel2,vec3(15.0, -15.0, inOutRotate), col1);\n    \n    d = Union(d,d1,color,col1, color);\n    \n    return d;\n}\n\nfloat Raymarching(vec3 cameraPos, vec3 rd, out vec3 color)\n{   \n    float t = 0.0;\n    for(int i=0;i<MAX_ITERATIONS;++i)\n    {\n        float d = Scene(cameraPos + rd * t, color);\n        \n        t += d;\n        \n        if(t > MAX_DISTANCE || d < COLLISION_DISTANCE)\n            break;\n    }\n    \n    return t;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    vec2 e = vec2(COLLISION_DISTANCE * 0.111, 1.0);\n    vec3 color;\n    float d = Scene(p, color);\n    \n    vec3 n = vec3(\n        d - Scene(p-e.xyy, color),\n        d - Scene(p-e.yxy, color),\n        d - Scene(p-e.yyx, color));\n    \n    return normalize(n);\n}\n\nfloat GetDiffuseLight(vec3 p, vec3 pos)\n{\n    vec3 normal = GetNormal(p);\n    \n    vec3 light = pos - p;\n    \n    return dot(normalize(light), normal);\n}\n\nvec3 GetShadow(vec3 p, vec3 light)\n{\n    vec3 dir = normalize(light - p);\n    vec3 color;\n    float d = Raymarching(p, dir, color);\n    \n    if(d < length(light - p))\n        return vec3(0.1);\n    \n    return vec3(1.0);\n}\n\n\nfloat GetLight(vec3 p)\n{\n    vec3 pos1 = vec3(5.0 * sin(2.0 * iTime), 5.0 * cos(2.0 * iTime), -2.0); \n    \n    float diff = 0.25 + 0.5 * clamp(GetDiffuseLight(p, pos1), 0.5, 1.0);\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 cameraPos = vec3(0.1,1.0, -30.0  );\n    \n    vec3 dir = vec3(normalize(vec3(uv.xy, 1.50 )));\n    \n    vec3 color = vec3(0.0) * dir;\n    \n    float d = Raymarching(cameraPos, dir, color);\n    \n    float light = GetLight( cameraPos +  d * dir);\n\n  \n\n\n    // post\n    float vgn = smoothstep(1.1,1.5,abs(uv.y)) * smoothstep(1.1,1.5,abs(uv.x));\n    color *= 1.8 - (0.44 - vgn) * 0.23;\t\n    \n    fragColor = vec4(color * light, 1.0);\n}","name":"Image","description":"","type":"image"}]}