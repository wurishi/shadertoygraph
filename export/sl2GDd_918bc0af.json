{"ver":"0.1","info":{"id":"sl2GDd","date":"1625024322","viewed":357,"name":"Expanding Coral Growth","username":"oneshade","description":"Cool coral-like growth pattern I accidentally made while working on something completely different. Thought I'd share it.","likes":20,"published":3,"flags":32,"usePreview":0,"tags":["coral","growth","happyaccident"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Hue to RGB function from Fabrice's shadertoyunofficial blog:\n#define hue2rgb(hue) (0.6 + 0.6 * cos(6.3 * hue + vec3(0.0, 23.0, 21.0)))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float unit = 2.0 / iResolution.y;\n    vec4 buf = texture(iChannel0, fragCoord / iResolution.xy);\n    fragColor = vec4(buf.x > unit ? vec3(0.0) : hue2rgb(buf.w) * smoothstep(unit, 0.0, buf.x), 1.0);\n    fragColor += 0.125 + 0.125 * sin(buf.x * 400.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define load(addr) texelFetch(iChannel0, addr, 0)\n#define pixel2uv(pixel) ((pixel - 0.5 * iResolution.xy) / iResolution.y)\n#define uv2pixel(uv) (uv * iResolution.y + 0.5 * iResolution.xy)\n#define minSDG(a, b) (a.x < b.x ? a : b)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat Hash11(in float x) {\n    x = fract(x * 0.1031);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n}\n\nvec2 Hash12(in float x) {\n    vec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3(signed distance, gradient)\n// Buffering the distance field already lowers\n// precision so buffering an exact gradient is\n// helpful\nvec3 sdgDisk(in vec2 p, in float r) {\n    float d = length(p);\n    float sd = d - r;\n    return vec3(sd, p / d * sign(sd));\n}\n\nvoid mainImage(out vec4 data, in vec2 addr) {\n    data = vec4(-1.0);\n    vec2 uv = pixel2uv(addr);\n    if (iFrame == 0) {\n        data.xyz = sdgDisk(uv, 0.15);\n        data.w = 0.0;\n    }\n\n    if (iFrame > 0) {\n        ivec2 iAddr = ivec2(addr);\n        float seed = iDate.w;\n        data = load(iAddr);\n\n        // \"Random\" starting position\n        vec2 start = pixel2uv(iResolution.xy * Hash12(seed));\n\n        // Project onto the SDFs surface (approximate, actual version will use iterrative)\n        vec3 sdg = load(ivec2(uv2pixel(start))).xyz;\n        sdg.x -= 0.01; // Slightly extra to be outside\n        start -= sdg.yz * sdg.x;\n\n        data.xyz = minSDG(data.xyz, sdgDisk(uv - start, 0.01));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}