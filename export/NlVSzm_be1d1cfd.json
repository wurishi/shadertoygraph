{"ver":"0.1","info":{"id":"NlVSzm","date":"1641866198","viewed":59,"name":"Ray Marching w/ Volumetrics","username":"avinitzca","description":"An exercise of Blinn-Phong and volumetrics with Ray-Marching SDFs.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 LIGHTPOSITION = vec3(10.0, 10.0, 10.0);\nconst vec3 LIGHTCOLOR = vec3(5.0, 5.0, 6.0);\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nconst int AXIS_COUNT = 5;\n\nfloat rand(vec3 cdo){\n    return fract(sin(dot(cdo, vec3(12.9898,78.233, 35.1355))) * 43758.5453);\n}\n\n\nfloat sceneSDF(vec3 point)\n{\n    float minDistance = sdSphere(point - vec3(0.0, 5.5, 0.0), 5.0);\n    \n    minDistance = min(minDistance, sdBox(point + vec3(0.0, 0.0, 0.0), vec3(30.0, 0.0, 30.0)));\n    \n    return minDistance;\n}\n\nfloat shadow( in vec3 eye, in vec3 marchingDirection, float start, float end )\n{\n    for( float t=start; t<end; )\n    {\n        float h = sceneSDF(eye + marchingDirection*t);\n        if( h<EPSILON )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSDF(ro + rd*t);\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) \n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n\n     \nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat saturate(float value)\n{\n    return clamp(value, 0.0, 1.0);\n}\n\nvec3 blinnPhong(vec3 point, vec3 normal, vec3 eyePosition, vec3 materialColor, vec4 params)\n{\n    vec3 ambient = materialColor * params.r * LIGHTCOLOR;\n    \n    vec3 lightVector = normalize(LIGHTPOSITION - point);\n    \n    vec3 diffuse = saturate(dot(normal, lightVector)) * params.g * LIGHTCOLOR;\n    \n    \n    vec3 eyeVector = normalize(eyePosition - point);\n    vec3 halfway = normalize(eyeVector + lightVector);\n    \n    vec3 specular = pow(saturate(dot(halfway, normal)), params.a) * params.g * LIGHTCOLOR;\n    \n    \n    return (diffuse + ambient) * materialColor + specular;    \n}\n\nfloat canSeeLight(in vec3 point, in vec3 lightPosition, in float minDistance)\n{\n    vec3 lightToPoint = point - lightPosition;\n    float distanceBetween = length(lightToPoint);\n    vec3 lightToPointDirection = lightToPoint / distanceBetween;\n\n    for( float t = minDistance; t < distanceBetween; )\n    {\n        float h = sceneSDF(lightPosition + lightToPointDirection * t);\n        if( h < EPSILON)\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nconst int VOLUMETRIC_STEPS = 120;\n\nfloat volumetrics(in vec3 rayOrigin, in vec3 rayDirection, in float minDistance, in float maxDistance, in vec3 eye, in vec3 lightPosition)\n{\n    vec3 pointToCamera = eye - rayOrigin;\n    float distanceToTravel = length(pointToCamera);\n    float stepToTravel = distanceToTravel / float(VOLUMETRIC_STEPS);\n    \n    float pointToLightLength = length(rayOrigin - lightPosition);\n    \n    vec3 normalizedPointToCamera = pointToCamera / distanceToTravel;    \n    \n    float accumulated = 0.0;\n    for(float accumulatedDistance = 0.01; accumulatedDistance < distanceToTravel; accumulatedDistance += stepToTravel)\n    {\n        vec3 point = rayOrigin + normalizedPointToCamera * accumulatedDistance;\n        vec3 direction = normalize(LIGHTPOSITION - point);\n        /*float shorte = shortestDistanceToSurface(point, direction, 0.0, 500.0);\n        \n        if(shorte > EPSILON)\n            accumulated -= 0.005;*/\n            \n        /*float shadow = softshadow(point, direction, 0.01, 200.0, 1.0);\n        \n        \n        if(shadow > 0.0)\n            accumulated -= 1.0 / float(VOLUMETRIC_STEPS);*/\n            \n        float canSee = canSeeLight(point, LIGHTPOSITION, minDistance);\n        \n        accumulated += canSee;\n    }\n    return accumulated / float(VOLUMETRIC_STEPS) * 5.0 - 4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xx;\n\n    // Camera and ray tracing \n    float zoom = 1.5;    \n    vec3 normalUp = vec3(0.0, 1.0, 0.0);    \n    vec3 rayOrigin = vec3(0.0);\n    \n    rayOrigin = vec3(100.0 * sin(iTime), 100.0, 100.0 * cos(iTime));\n    \n    vec3 lookAtPosition = vec3(0.0, 0.0, 0.0);    \n    vec3 cameraForward = normalize(lookAtPosition - rayOrigin);\n    vec3 cameraRight = cross(normalUp, cameraForward);\n    vec3 cameraUp = cross(cameraForward, cameraRight);\n    \n    vec3 center = rayOrigin + cameraForward * zoom;\n    vec3 intersection = center + (uv.x - 0.5) * cameraRight + (uv.y - 0.25) * cameraUp;\n        \n    vec3 rayDirection = normalize(intersection - rayOrigin);\n        \n    \n    \n    \n    float march = shortestDistanceToSurface(rayOrigin, rayDirection, MIN_DIST, MAX_DIST);\n        \n    \n    if (march > MAX_DIST - EPSILON)\n    {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }\n    \n    vec3 point = rayOrigin + rayDirection * march;\n    \n    vec3 normal = estimateNormal(point);\n    \n    vec3 lightIntensity = blinnPhong(point, normal, rayOrigin, vec3(0.2, 0.2, 0.2), vec4(0.1, 0.5, 0.7, 16.0));\n    \n    lightIntensity *= softshadow(point, normalize(LIGHTPOSITION - point), 0.8, 500.0, 16.0);\n        \n    lightIntensity *= volumetrics(point, normalize(LIGHTPOSITION - point), MIN_DIST, MAX_DIST, rayOrigin, LIGHTPOSITION);\n        \n    // Gamma\n    \n    lightIntensity = pow(lightIntensity, vec3(1.0/2.2));\n    \n    // Output to screen\n    fragColor = vec4(lightIntensity,1.0);\n}","name":"Image","description":"","type":"image"}]}