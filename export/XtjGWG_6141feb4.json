{"ver":"0.1","info":{"id":"XtjGWG","date":"1432041294","viewed":278,"name":"Pseudo TD style exposure effect","username":"grieve","description":"A shoddy attempt at a similar base effect to that used in the True Detective title scenes. First attempt.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["perlin","britney","mask","exposure","truedetective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// remove greenscreen by averaging rb vs g and cubing to increase translucency\nvec4 degreen(vec4 inColor)\n{\n    lowp float rbAverage = inColor.r * 0.7 + inColor.b * 0.7;\n    lowp float gDelta = inColor.g - rbAverage;\n    // keep opacity quite high because we're actually using the inverse\n    inColor.a = 1.0 - smoothstep(0.0, 0.10, gDelta);\n    inColor.a = inColor.a * inColor.a * inColor.a;\n    return inColor;\n}\n\n// compute a vignette value for given uv\nfloat vig(vec2 uv)\n{\n    \n    float outer = 1.0;\n    float inner = 0.001;\n    vec2 center = vec2(0.5, 0.5);\n    float dist = distance(center, uv) * 1.414213;\n    float val = clamp((outer - dist) / (outer - inner), 0.0, 1.0);\n    return val;\n}\n\n// desaturate the texel by a given value (0.0 - 1.0)\nvec4 desat(vec4 color, float val)\n{\n    float lvl = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    return vec4(lvl * val + color.r * (1.0 - val), lvl * val + color.g * (1.0 - val), lvl * val + color.b * (1.0 - val),1.0);\n}\n\n// a corrupted version of desat that has a levels-like effect\nvec4 level(vec4 color, float val)\n{\n    float lvl = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;\n    return vec4(lvl * val + color.r * (1.0 - lvl), lvl * val + color.g * (1.0 - lvl), lvl * val + color.b * (1.0 - lvl),1.0);\n}\n\nvec2 perlin(vec2 uv)\n{\n    vec2 x = vec2(0.0);\n    for (int i = 0; i < 6; ++i)\n    {\n        float j = pow(2.0, float(i));\n        x += (texture(iChannel3, uv * j * 0.001).xy-0.5) / j;\n    }\n    return x;\n}\n\n\n// sample from the video channel, but \"smoke\" it out based on sin'd time\nvec4 smokeSample(vec2 uv, vec2 offset)\n{\n    const int steps = 10;\n    \n    // clamp the sin'd time so that it goes from 0.0 to 4.0 (and lingers at both)\n    float t = clamp(sin(iTime * 0.5 + 2.0) * 4.0, 0.0, 4.0);\n    vec4 col = vec4(0.0);\n    for (int i = 1; i < steps; ++i)\n    {\n        uv += perlin(uv + offset) * t * 0.01 / float(i);\n        uv.y -= t * 0.01;\n        col += texture(iChannel0, uv, float(steps - i) * t * 0.8);\n    }\n    // fudge the green channel so image is more opaque when smoke is max\n    col.g = max(col.g, col.g * t);\n    return col / float(steps);\n}\n\nvec4 exposure(vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec4 maskTexel = smokeSample(uv, fragCoord.xy / 2.0);\n    // get greenscreen alpha\n\tfloat maskAlpha = degreen(maskTexel).a;\n    \n    // a little pan based on time\n    float pan = (sin(iTime * 0.1) * 0.2) + 0.2;\n    vec2 texelSample = vec2(uv.x + pan, uv.y * -1.0) * 0.7;\n    \n    // get the inverse sample as we will be subtracting it and apply vignette\n    vec4 texel = vec4(1.0) - texture(iChannel1, texelSample) * 0.3 / vig(uv);\n\t\n    // subtract the sample from white after levels/desat and xAlpha\n    // and add the desat mask xAlpha\n   \treturn vec4(1.0) - (\n        level(texel, 1.0) * maskAlpha\n    ) + (\n        level(desat(maskTexel, 0.85), 0.98) * maskAlpha\n    );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = exposure(fragCoord);\n}","name":"","description":"","type":"image"}]}