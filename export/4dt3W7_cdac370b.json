{"ver":"0.1","info":{"id":"4dt3W7","date":"1450111948","viewed":1275,"name":"1D Error Diffusion","username":"104","description":"Extremely impractical to do error diffuse dithering in a frag shader :)","likes":13,"published":1,"flags":0,"usePreview":1,"tags":["dithering","errordiffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\n// number of pixels wide to accumulate error. outside of a frag shader, this would naturally be the width of the image in pixels.\nconst float accWidth = 250.;\nconst float resMult = 1.;\n//#define COLOR\n\nvoid mainImage( out vec4 o, in vec2 pix)\n{\n    pix = floor(pix/resMult)*resMult;\n    vec3 outpColor;\n    vec3 accErr;\n    for(float i = accWidth; i >= 0.; -- i)\n    {\n        // make sure we're always working from specific boundaries, otherwise the\n        // error accumulation effect doesn't behave correctly\n        float leftBoundary = floor(pix.x/accWidth)*accWidth;\n        if(pix.x-i < leftBoundary)\n            continue;\n\n        vec2 uv = vec2(pix.x-i,pix.y)/iResolution.xy;\n        o = texture(iChannel0, uv);\n        vec3 idealColor = o.rgb;//= (o.r+o.g+o.b)/3.;// gray scale.\n        #ifndef COLOR\n        idealColor = vec3(o.r+o.g+o.b)/3.;// gray scale.\n        #endif\n\n        vec3 idealColorWithErrCorr = idealColor + accErr;\n        outpColor = step(0.,idealColorWithErrCorr-.5);\n        accErr = idealColorWithErrCorr - outpColor;\n    }\n    \n    o=vec4(outpColor,1);\n}\n\n\n","name":"","description":"","type":"image"}]}