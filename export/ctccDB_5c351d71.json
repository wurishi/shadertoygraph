{"ver":"0.1","info":{"id":"ctccDB","date":"1699640456","viewed":47,"name":"Large neighborhood experiments","username":"laserbat","description":"This CA is based around the same ideas as the ones I published earlier but is implemented differently to reduce the computational requirements. Because of this, it is limited to only 32 states. ","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["feedback","cellularautomata"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ZOOM 1.0\n\n// Colorization and output stuff here.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    int val = GET(fragCoord.xy / ZOOM, ivec2(0, 0));\n\n    val = hash(val + 1314);\n    \n    fragColor.r = float(val % D) / float(D);\n    val /= D;\n    fragColor.g = float(val % D) / float(D);\n    val /= D;\n    fragColor.b = float(val % D) / float(D);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Simple time-dependant noise function, for seeding CA\nfloat noise(in vec2 co){\n    int x = int(co.x * float(M));\n    int y = int(co.y * float(M));\n    int z = int(iDate.a);\n    int w = int(fract(iDate.a) * float(M));\n    int res = hash(x + hash(y + hash(z + hash(w))));\n    \n    return float(res);\n}\n\n// Main CA computation\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    int S = 32;\n    \n    // Randomize initial state on 0th frame or if mouse button is pressed\n    if (iFrame <= 0 || iMouse.z > 0.0) {\n        fragColor.x = float(int(noise(round(20.0 * fragCoord/iResolution.xy))) % S);\n    } else {\n    \tivec2 d;\n        \n        int i = 0;\n        int cen = GET(fragCoord, ivec2(0, 0));\n        int V = 0, res = 0;\n        \n        int R = 8;\n\n    \tfor(d.y = -R; d.y <= +R; d.y++)\n        \tfor(d.x = -R; d.x <= +R; d.x++){ \n                if(d.x*d.x + d.y*d.y > R*R) continue;\n                V |= (1 << (GET(fragCoord, d)));\n             }\n        \n\n        res = (((V ^ 42521) % 8191) >> 9);\n        \n        for (i = 0; (i < S) && (((V >> ((i + res)) % S) & 1) == 0); i ++){\n            ;\n        }\n        \n        res = (i + res) % S;\n\n        fragColor.x = float(res);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define swap(x, y) if (vals[x] > vals[y]) {int t = vals[y]; vals[y] = vals[x]; vals[x] = t;};\n#define GET(coord, offset) int(texelFetch(iChannel0, ivec2(mod(coord + vec2(offset) + iResolution.xy, iResolution.xy)), 0).x)\n\n#define D 256\n#define M (D * D * D)\n\nint hash(int x) {\n    x++;\n    x ^= x >> 17;\n    x *= 0xed5ad4bb;\n    x ^= x >> 11;\n    x *= 0xac4c1b51;\n    x ^= x >> 15;\n    x *= 0x31848bab;\n    x ^= x >> 14;\n    return x;\n}","name":"Common","description":"","type":"common"}]}