{"ver":"0.1","info":{"id":"4XjGWy","date":"1709026761","viewed":171,"name":"Voronoi Overlay Network","username":"aliendino","description":"A shader for a voronoi overlay network  for my presentation. \n\nEdit: AH! I released it publicly with my own modifications! This wasn't the intended result but it looks really nice!\n\nThanks before hand for any advice y'all post! Much is appreciated!","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["voronoi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A shader for a Voronoi Overlay Network\n// I used this: https://iquilezles.org/articles/voronoilines/\n// Based off this: https://thebookofshaders.com/12/\n\n#define GRID_SIZE 5.0\n#define OBJ_FREQ 5.0\n#define TOI vec2(2.0, 2.0)\n#define AOI 1.5\n\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat random (float f){\n    return fract(sin(f)*100000.0);\n}\n\nvec2 random_vec2 (vec2 p){ // distribution's weird but who cares\n    return fract(\n        sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*438.5453\n        );\n\n}\n\nfloat sdCircle( vec2 p, float r, vec2 c)\n{\n    return length(p - c) - r;\n}\n\n\n\nstruct VoroResult {\n    vec2 m_point;\n    vec2 pre_point;\n    vec2 m_tile;\n    float m_dist;\n    vec2 m_diff;\n};\n\nvec2 getPointInTime(vec2 tile, vec2 pre_point){\n    // return pre_point + sin(iTime+pre_point)*0.5;\n    return  (tile == vec2(-1.0)) ? pre_point :\n       0.5 + 0.5*sin(iTime + 6.2831*pre_point);\n}\n\nvec2 getPointofTile(vec2 tn){\n    return tn + getPointInTime(tn, random_vec2(tn));\n}\n\n\n\nVoroResult voronoi(in vec2 uv){\n    VoroResult res;\n    \n    vec2 mousePos = GRID_SIZE*iMouse.xy/iResolution.y;\n\n    vec2 st = uv*GRID_SIZE;\n    //st = sqrt(st)*5.0;\n    vec2 f_st = fract(st);\n    vec2 i_st = floor(st);\n\n    // Loop through each tile\n    res.m_dist = 1000.0;\n    res.m_point = random_vec2(i_st);\n\n    float f_dist = 1000.0;\n    vec2 f_offset = vec2(0.0);\n    vec2 f_diff = vec2(0.0);\n\n    // Initialize with mouse coords\n\n    //res.m_tile = floor(mousePos); // there is no tile\n    //res.pre_point = mousePos - res.m_tile;\n    //res.m_point = res.pre_point;\n    //res.m_diff = res.m_point - uv*GRID_SIZE;\n    //res.m_dist = dot(res.m_diff, res.m_diff);\n\n    //f_dist = res.m_dist;\n    //f_diff = res.m_diff;\n    //f_offset = vec2(0.0);\n\n\n\n    for (int y= -1; y <= 1; y++) {\n        for (int x= -1; x <= 1; x++) {\n            // Neighbor place in the grid\n            vec2 offset = vec2(float(x),float(y));\n            vec2 tile = i_st + offset;\n            vec2 pre_point = random_vec2(tile);// wrt to tile of fragment\n            vec2 point = getPointInTime(tile, pre_point);\n\n            vec2 diff = offset + point - f_st;\n            float dist = dot(diff, diff);\n            if (dist < res.m_dist){\n                res.m_diff = diff;\n                res.m_dist = dist;\n                res.m_tile = tile;\n                res.pre_point = pre_point;\n                res.m_point = point;\n\n\n                f_dist = dist;\n                f_diff = diff;\n                f_offset = offset;\n\n            }\n            //m_dist = min(length(diff), m_dist);\n        }\n    }\n\n    //res.m_point = m_point;\n    \n    //res.m_dist = res.m_dist*2.0;\n    res.m_dist = sqrt(res.m_dist);\n\n    // res.m_dist = 8.0;\n    if (true){\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 offset = f_offset + vec2(float(i), float(j));\n        vec2 tile = offset + i_st;\n        vec2 pre_point =  random_vec2(tile);\n        vec2 point = getPointInTime(tile, pre_point);\n\n        vec2 diff =\n        offset + point - f_st;\n\n        float d = dot(0.5*(diff + f_diff), normalize(diff - f_diff));\n\n        res.m_dist = min(res.m_dist, d);\n    }\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 st = uv*GRID_SIZE;\n    //st = sqrt(st);\n    \n    vec2 f_st = fract(st);\n    vec2 i_st = floor(st);\n\n    vec2 fi_st = fract(st*OBJ_FREQ);\n    vec2 ii_st = floor(st*OBJ_FREQ);\n\n    vec3 col = vec3(0.0);\n    // col.gb = vec2(0.5);\n    float d = 0.0;\n    vec2 p = vec2(0.0);\n\n    // col += 1.0-vec3(step(.02, d));\n\n    //col.b += step(.98, f_st.x) + step(.98, f_st.y);\n\n\n\n    //vec2 mousePos = GRID_SIZE*iMouse.xy/iResolution.y;\n\n    VoroResult res = voronoi(uv);\n\n    //col.r = res.m_point.x;\n    col = vec3(res.m_point*0.5, 0.5); // cool colors\n    \n    // col.gb = 0.6+((res.pre_point)/15.); // 1 gradient for my presentation...\n    \n    vec2 toi = TOI;\n    float aoi = AOI;// + (sin(iTime*0.5));\n    vec2 poi = getPointofTile(toi);\n\n    //float s = sdCircle(uv*GRID_SIZE, aoi, poi);\n    //col.r = (-0.05 < s && s < 0.0) ? 1.0 : col.r;\n\n    vec3 objColor = vec3(0.2, 0.1, 0.2);\n    float dimFactor = 0.0;\n    /*\n    if (res.m_tile == toi){\n        col.g = 0.5;\n        objColor = vec3(1.0, 1.0, 0.0);\n        dimFactor = 1.0;\n    } else if (distance(getPointofTile(res.m_tile), poi) < aoi) {\n        dimFactor = 0.7;\n        objColor = vec3(0.5, 0.0, 0.0);\n        col.b = 0.5;\n    } */\n    \n    col = mix(col, vec3(dimFactor), smoothstep(1.5*GRID_SIZE/iResolution.y, 0., res.m_dist) );\n\n    /*\n    if (st.x < 5.0 && st.y < 3.0){\n        vec2 objPos = random_vec2(ii_st);\n        float objDist = distance(fi_st, objPos);\n        col = mix(col, vec3(1.0), (1.0-vec3(step(.02*GRID_SIZE, objDist))) *\n                    objColor);\n    }*/\n    col += res.m_dist;\n\n    //col -= abs(sin(40.0*res.m_dist))*0.1;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}