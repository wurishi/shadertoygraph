{"ver":"0.1","info":{"id":"ctKBzV","date":"1702290686","viewed":118,"name":"Mandelbrot Base Layers %scouttea","username":"scouttea","description":"A collection of visualization techniques for the Mandelbrot set.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["mandelbrot","template","normalfractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Base for all mandelbrot visualisations\n\nstruct OrbitTrap\n{\n    float dist;\n    float iter_count;\n};\n\nstruct State\n{\n    bool escaped;\n    // Escape distance;\n    float escape;\n    // max iteration count\n    int max_iter;\n    // start point\n    vec2 c;\n    // current iteration\n    int i;\n    // current position\n    vec2 z;\n    // derivative of d( mandelbrotCalculation( c ) )/dc \n    vec2 dz;\n    // Wakes subresults\n    float wakes;\n    // Orbit Trap\n    OrbitTrap trap;\n};\n\nstruct Result\n{\n    bool escaped;\n    // escape distance\n    float escape;\n    // max iteration count\n    float max_iter;\n    // escape iteration count\n    float iter_count;\n    // Smooth iteration count: https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Continuous_(smooth)_coloring\n    float smooth_count;\n    // first order normal\n    vec2 normal;\n    // Wakes\n    float wakes;\n    // external distance\n    float dist;\n    // Orbit Trap\n    OrbitTrap trap;\n};\n\n// Calculate distance to trap object\nfloat trap_distance( vec2 pos )\n{\n    pos = pos;\n    \n    // trap object = origin\n    return dot(pos,pos);\n    \n    //trap object = x-axis\n    return abs( pos.x );\n    \n    // trap object = integer xy grid\n    vec2 tmp = abs(pos - round( pos ));\n    return min( tmp.x, tmp.y );\n}\n\nvec2 comp( vec2 z )\n{\n    return z * vec2( 1., -1. );\n}\n\nvec2 mult( vec2 a, vec2 b )\n{\n    return vec2( a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x );\n}\n\n\nvoid compute_z( inout State state )\n{\n    state.z = mult( state.z, state.z ) + state.c;\n}\n\nvoid compute_dz( inout State state )\n{\n    // Z_n = Z_(n-1)^2 + c\n    // dZ_n = 2 * Z_n * dZ_(n-1) + 1\n    state.dz = 2. * mult( state.z, state.dz ) + vec2(1., 0.);\n}\n\nvoid compute_wakes( inout State state )\n{\n    state.wakes += sin( 5. * atan( state.z.y, state.z.x ) );\n}\n\nvoid compute_orbit_trap( inout State state )\n{\n    float dist = trap_distance( state.z );\n    \n    if( dist < state.trap.dist )\n    {\n        state.trap.dist = dist;\n        state.trap.iter_count = float(state.i);\n    }\n}\n\nResult mandelbrotCalculation( vec2 c )\n{\n    State state = State(\n        false,    // escaped\n        1000000., // escape distance\n        512,      // max iteration count\n        c,        // start point\n        0,        // current iteration\n        vec2(0.), // current position\n        vec2(0.), // derivative\n        0.,       // Wakes\n        OrbitTrap(\n            10000.,\n            0.\n        )\n    );\n    \n    for(; state.i<state.max_iter; state.i++ )\n    {\n        if( dot(state.z,state.z) > state.escape )\n        {\n            state.escaped = true;\n            break;\n        }\n        compute_dz( state );\n        compute_wakes( state );\n        compute_z( state );\n        compute_orbit_trap( state );\n    }\n    \n    State next_state = state;\n    compute_dz( next_state );\n    compute_wakes( next_state );\n    compute_z( next_state );\n    \n    \n    // Normal calculation\n    vec2 u = mult( state.z, comp(state.dz) ) / dot(state.dz,state.dz);\n    // Smooth iteration count\n    float si = float(state.i) - log2( log( dot(state.z,state.z) ) / log( state.escape ) );\n     \n    // distance\t\n\t// d(c) = |Z|Â·log|Z|/|Z'|\n\tfloat dist = 0.5*sqrt(dot(state.z,state.z)/dot(state.dz,state.dz))*log(dot(state.z,state.z));\n    \n    return Result(\n        state.escaped,\n        state.escape,\n        float(state.max_iter),\n        float(state.i),\n        si,\n        normalize(u),\n        mix( state.wakes, next_state.wakes, fract(si) ),\n        dist,\n        state.trap\n    );\n}\n\nvec4 previewIterCount( Result result )\n{\n    vec4 color = vec4(1.);\n    \n    if( result.escaped )\n    {\n        color.xyz = vec3( mod(result.iter_count, 2.) );\n    }\n    \n    return color;\n}\n\nvec4 previewSmoothCount( Result result )\n{\n    vec4 color = vec4(1.);\n    \n    if( result.escaped )\n    {\n        color.xyz = vec3( result.iter_count / result.max_iter );\n    }\n    \n    return color;\n}\n\nvec4 previewNormal( Result result )\n{\n    vec4 color = vec4(1.);\n    \n    if( result.escaped )\n    {\n        color.xyz = vec3( dot( result.normal, vec2( cos( iTime ), sin( iTime ) ) ) );\n    }\n    \n    return color;\n}\n\nvec4 previewWakes( Result result )\n{\n    vec4 color = vec4(1.);\n    \n    if( result.escaped )\n    {\n        color.xyz = vec3( sqrt(sqrt( abs(result.wakes)/result.max_iter )) );\n    }\n    \n    return color;\n} \n\nvec4 previewDist( Result result )\n{\n    vec4 color = vec4(1.);\n    \n    if( result.escaped )\n    {\n        color.xyz = vec3( mod( log( result.dist ), 2. ) );\n    }\n    \n    return color;\n}\n\nvec4 previewOrbitTrap( Result result )\n{\n    vec4 color = vec4(1.);\n    \n    //color.xyz = vec3( mod( result.trap.iter_count, 5. ) / 5. );\n    color.xyz = vec3( sqrt(sqrt(result.trap.dist)) );\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Mapped coords such that the square (-1,-1) -> (1,1) fits on screen\n    vec2 ab = (2.*fragCoord - iResolution.xy )/min(iResolution.x,iResolution.y);\n\n    // Select Positioning\n    vec2 center = vec2( -1.373547, -0.01234831 );\n    float zoom = .001;\n    \n    vec2 coord = ab * zoom + center;\n\n    // Output to screen\n    Result result =  mandelbrotCalculation( coord );\n    \n    fragColor = previewNormal( result );\n}","name":"Image","description":"","type":"image"}]}