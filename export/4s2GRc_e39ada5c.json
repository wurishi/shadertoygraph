{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"struct sphere_t\n{\n    vec3 position;\n    float radius;   \n};\n\n\nstruct ray_t\n{\n    vec3 origin;\n    vec3 direction;   \n};\n\n   \nconst float max_distance = 1e5;\n\n\nstruct plan_t\n{\n    vec3 normal;\n    float d;\n};\n\n\nstruct light_t\n{\n    vec3 direction;\n    float contribution;\n\n};\n   \nstruct surface_t\n{\n    vec3 normal;\n    vec3 position;\n};\n   \n   \n   \n   \n   \n   \n   \nfloat intersect_plan(const in ray_t ray,const in plan_t plan)\n{\n    float result = max_distance;\n       \n    float alpha = (plan.normal.x*ray.origin.x)\n                +(plan.normal.y*ray.origin.y)\n                +(plan.normal.z*ray.origin.z)+plan.d;\n       \n    float beta = (plan.normal.x*ray.direction.x)\n                +(plan.normal.y*ray.direction.y)\n                +(plan.normal.z*ray.direction.z);\n       \n   \n    result = min(result,(-alpha/beta));\n    if(result < 0.0) result = max_distance;\n   \n    return result;\n   \n   \n}\n   \n\nfloat intersect_sphere(const in ray_t ray,const in sphere_t sphere)\n{\n    float result = max_distance;\n\n   \n    float a = (ray.direction.x * ray.direction.x)\n            +(ray.direction.y * ray.direction.y)\n            +(ray.direction.z* ray.direction.z);\n   \n    float b = ((ray.origin.x-sphere.position.x)*ray.direction.x)\n            +((ray.origin.y-sphere.position.y)*ray.direction.y)\n            +((ray.origin.z-sphere.position.z)*ray.direction.z);\n   \n    b *= 2.0;\n\n    float c = ((ray.origin.x-sphere.position.x) * (ray.origin.x-sphere.position.x))\n            +((ray.origin.y-sphere.position.y) * (ray.origin.y-sphere.position.y))\n            +((ray.origin.z-sphere.position.z) * (ray.origin.z-sphere.position.z))- (sphere.radius*sphere.radius);\n   \n   \n    float delta = b*b - (4.0*a*c);\n   \n   \n   \n    if(!(delta < 0.0)){\n        float dist = (-b + sqrt(delta))/(2.0*a);\n        float dist2 = (-b - sqrt(delta))/(2.0*a);\n        result = min(dist,dist2);\n    }\n\n   \n\n   \n    return result;\n   \n}\n\n\n\nvoid light_information(out light_t light)\n{\n   \n    light.direction = normalize(vec3(1.0*sin(iTime),1.0,1.0*cos(iTime)));\n    light.contribution = 1.0;\n   \n}\n\nfloat illumination(const in ray_t primary_ray,const in surface_t surface,const in light_t light)\n{\n   \n    float diffuse = light.contribution * max(dot(surface.normal,light.direction),0.0);\n    vec3 reflected = reflect(primary_ray.direction,surface.normal);\n   \n    float specular = pow(max(dot(reflected,light.direction),0.0),5.0);\n   \n   \n    return diffuse+specular;\n\n}\n\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coordonate = fragCoord.xy/iResolution.xy;\n    vec2 screen_coordonate_centered = 2.0 * screen_coordonate -1.0;\n   \n    float screen_ratio = iResolution.x/iResolution.y;\n    vec2 screen_coordonate_line_corrected = vec2(screen_ratio,1.0)*screen_coordonate_centered;\n   \n   \n    ray_t primary_ray;\n    primary_ray.origin = vec3(0.0,0.0,1.5);\n    primary_ray.direction = vec3(screen_coordonate_line_corrected,-1.0);\n   \n    sphere_t sphere;\n    sphere.position = vec3(0.0,0.0,0.0);\n    sphere.radius = 0.5;   \n   \n   \n    plan_t plan;\n    plan.normal = vec3(0.2,0.9,0.04);\n    plan.d = 0.1;\n   \n   \n    light_t light;\n   \n    light_information(light);\n   \n   \n    float distance_plan_from_origin = intersect_plan(primary_ray,plan);\n    float distance_sphere_from_origin = intersect_sphere(primary_ray,sphere);\n   \n    if(distance_sphere_from_origin < max_distance)\n    {\n       \n        float x_a = (primary_ray.origin.x) + distance_sphere_from_origin*(primary_ray.direction.x);\n        float y_a = (primary_ray.origin.y) + distance_sphere_from_origin*(primary_ray.direction.y);\n        float z_a = (primary_ray.origin.z) + distance_sphere_from_origin*(primary_ray.direction.z);\n           \n       \n        vec3 sphere_normal = normalize(vec3( (x_a - sphere.position.x),(y_a - sphere.position.y),(z_a - sphere.position.z)));\n\n        surface_t surface;\n        surface.normal = sphere_normal;\n        surface.position = vec3 (x_a,y_a,z_a);\n       \n        float illumination_from_lightsource = illumination(primary_ray,surface,light);\n       \n       \n        fragColor = vec4(illumination_from_lightsource,illumination_from_lightsource,illumination_from_lightsource,1.0);\n    }\n   \n    else if(distance_plan_from_origin < max_distance)\n    {\n       \n        float x_a = (primary_ray.origin.x) + distance_plan_from_origin*(primary_ray.direction.x);\n        float y_a = (primary_ray.origin.y) + distance_plan_from_origin*(primary_ray.direction.y);\n        float z_a = (primary_ray.origin.z) + distance_plan_from_origin*(primary_ray.direction.z);\n       \n        surface_t surface;\n        surface.normal = plan.normal;\n        surface.position = vec3 (x_a,y_a,z_a);\n       \n        float illumination_from_lightsource = illumination(primary_ray,surface,light);\n       \n       \n        fragColor = vec4(illumination_from_lightsource,illumination_from_lightsource,illumination_from_lightsource,1.0);\n\n    }\n\n   \n    else\n    {\n        const vec3 background_color = vec3(0.0,0.0,0.4);\n        fragColor = vec4(background_color,1.0);       \n    }\n       \n       \n       \n   \n    //fragColor = vec4( abs(primary_ray.direction),1.0);\n   \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4s2GRc","date":"1391769306","viewed":130,"name":"TP1-Shader","username":"Thomas","description":"Ceci est le premier TP du cours de shader.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["tp1"],"hasliked":0,"parentid":"","parentname":""}}