{"ver":"0.1","info":{"id":"7tj3zG","date":"1626601243","viewed":100,"name":"DG Storm in a Chalice","username":"DG622","description":"This is a raymarched chalice, it is not perfect but time does not allow me to work out how to do the other fiddly bits","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarchreflectrefract"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 Rot (float a){\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);    \n}\n\nfloat sphere (vec4 dim, vec3 p){\n\t\t\tfloat retValue = length(p - dim.xyz)-dim.w;\n\t\t\treturn retValue;\n\t\t\t\t}\nfloat box (vec3 p, vec3 s){\n                return length (max(abs(p) - s, 0.0));\n                }\n                \nfloat hexagon(vec2 p,float size){//care of Andrew Hung game dev blogg\n    size /=1.732508;\n    float hexhlf = size;//size to fit in the cube!\n    vec2 s = vec2(1.0, 1.7320508);  //equilateral triangle  \n    p = abs(p);\n    return max(dot( p, s * 0.5), p.x) - hexhlf;\n}\nfloat GetGem(vec3 p, vec3 objpos, float offset,float size, float angle){\n        objpos.x-=offset/6.0;\n        objpos.y-=offset;       \n       // objpos.z+=offset/10.0;\n        objpos.xz*=Rot(angle);\n        \n    \tvec3 bp = p-vec3(objpos);//box position      \n        float bx1 = box(bp, vec3(size));  //size box   \n        vec2 rotAngxz = vec2(p.x-objpos.x,p.z-objpos.z);\n        vec2 rotAngxy = vec2(p.x-objpos.x,p.y-objpos.y);\n        vec2 rotAngyz = vec2(p.y-objpos.y,p.z-objpos.z);\n       \n       // vec2 rotAngFc = vec2(p.x-xpos, p.z-zpos*0.83);\n        float xzPlane = hexagon (rotAngxz,size);\n        float xyPlane = hexagon (rotAngxy,size);\n        float yzPlane = hexagon (rotAngyz,size);\n        float gem = max(bx1, xzPlane);//makes the hexagon out of the box and hexagon plane!!\n        gem = max(gem,xyPlane);// again at 90 degrees\n        gem = max(gem,yzPlane);\n        //front face from this below size/2.0 gives the correct slice plane in the z\n        float facePlane = dot(vec3(p.x,p.y,p.z-objpos.z-size/2.0), normalize(vec3 (0.0,0.0,1.0)));//the front face        \n        gem = max(gem, facePlane);\n       \n        return gem/2.0;\n}\n\n\t\n       vec2 chalice(vec3 p){\n\t\t\tvec2 retVal = vec2(0.0,0.0);\n            vec3 objpos = vec3(0.0,0.0,0.0);//0.0,2.0,-10\n            float offset = 4.6;//position the stem\n            float gem;\n          \n            //Main sphere         \n           float dSphere = sphere(vec4(objpos,3.0),p);\n           float dPlane = dot(vec3(objpos.x,p.y-objpos.y-0.1,objpos.z), normalize(vec3 (0.0,1.0,0.0)));//the vec 3 is the normal of the plane       \t\t\t\t\t\t\t\n           dSphere = abs(dSphere);// hollows it out the goblet so the fluid sphere shows        \n           float d = max(dSphere, dPlane) ;//- 0.01;//max gives intersection of a plane, the number: thickness\n\t\t\t\n           //fluid levels\n           float wave =sin(iTime*2.0)* sin(15.0*p.x+iTime*2.0)*0.08;//fluid moves\n           float fSphere = sphere(vec4(objpos,2.9),p);                     \t\t\t\n           float FPlane = dot(vec3(p.x ,p.y-objpos.y+0.2-wave,p.z), normalize(vec3 (0.0,1.0,0.0)));        \n           float dF = max(fSphere, FPlane) ;//- 0.01;\n           \n           float danddF = min (d, dF);//goblet and fluid\n               if(d > dF){ retVal.y = 5.0;//flag to indicate fluid       \n            }else if(d > FPlane) retVal.y = dF;//so carry the inner fluid mass to main for refraction if below the fluid plane\n            //box         \n            vec3 bp = p-vec3(objpos.x ,objpos.y-offset, objpos.z  );//box position\n            float scale = mix (0.8,3.0, smoothstep(-1.0, 0.5, bp.y));//gives the tapered column\n            bp.xz *= scale;\n            float db = box( bp , vec3(1.3));                    \n            retVal.x = min(danddF, db)/2.0;\n           // retVal.x = min(dF, db)/2.0;\n            if(d > db)retVal.y = 10.0;//flag to indicate stem\n           //minor sphere\n           float mSphere = sphere(vec4(objpos.x,objpos.y-offset+1.0,objpos.z,0.8),p);\n           if(retVal.x > mSphere)retVal.y = 10.0;\n           retVal.x =min(retVal.x,mSphere);\n           //the gems\n           for(float n=-1.0;n<3.0;n++){           \n                 gem = GetGem(p,objpos,offset-1.0,0.73, 1.571*n);\n                 if(retVal.x > gem) retVal.y = 2.0+n;\n                 retVal.x = min(retVal.x, gem);\n              }   \n                 \n                 \n                retVal.x/=2.0;\n               \n            return retVal;\n        } \n        \n\n\nvec2 GetDist(vec3 p){\n       vec2 retVal;\n       float wPlane = dot(vec3(p.x,p.y+2.5,p.z), normalize(vec3 (0.0,1.0,0.0)));     \n       vec2 mvase = chalice(p);\n     \n       retVal = mvase;\n       return retVal;  \n         \n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float flag){\n            float dO = 0.0;\n            vec2 retVal;\n            for(int i = 0; i < 100; i++){\n                vec3 p = ro + dO * rd;\n                retVal = GetDist(p)*flag;               \n           \t\tfloat dS = retVal.x;\n                dO += dS;\n                if( dS < 0.01 || dO > 100.0){\n                    break;\n                    }\n              }\n          \tretVal.x = dO;\n            \n            return retVal;           \n       }\n\n\t\tvec3 GetNormal (vec3 p){\n            vec2 e = vec2(0.01, 0.0);\n            vec2 retVal = GetDist(p);\n          \tfloat d = retVal.x;          \n            vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x, GetDist(p-e.yyx).x);           \n            n = normalize(n);\n            return n;           \n       }\n        \n     vec3 GetRayDir( vec2 uv, vec3 p, vec3 l, float z){\n     vec3 f = normalize (l - p);\n     vec3 r = normalize (cross(vec3(0.0,1.0,0.0), f));\n     vec3 u = cross( f, r);\n     vec3 c = f * z;\n     vec3 i = c + uv.x* r + uv.y * u;\n     return normalize (i);\n     }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n            vec3 col = vec3(0.0);\n            vec3 RGB1 = vec3(0.834289, 0.695724, 0.221846);//gold \n    \t\n            vec3 refl;\n            vec3 refr;\n            vec2 uv = (fragCoord- 0.5*iResolution.xy)/iResolution.y; \n            vec2 m = iMouse.xy/iResolution.xy;//as per Art of Code camera model\n            vec3 ro = vec3(5.0,-5.0,-5.0);\n            ro.yz *= Rot(-m.y * 3.14+1.0);\n            ro.xz *= Rot(-m.x * 6.2831);\n            \n            \n            vec3 rd = GetRayDir(uv, ro, vec3(0.0,0.0,0.0), 0.7);\n            col = texture(iChannel0, rd).rgb;\n            vec2 retVal = RayMarch(ro,rd,1.0);\n\t\t\tfloat d = retVal.x;\n            float IOR = 1.33;//ignore the glass as so small so refract once for water\n             vec3 cup = vec3(0.0);\n            if(d < 100.0){\n                vec3 p= ro+rd*d;\n                vec3 n = GetNormal (p);\n                refl = reflect(rd, n);\n                vec3 nExit = vec3(0.0);\n                vec3 pExit = vec3(0.0);\n              \n                //refraction\n                if(retVal.y < 1.0){//ie is the glass goblet carries Df the fluid\n                    vec3 rdIn = refract(rd, n, 1.0/IOR);//air to glass\n                    vec3 pEnter = p - n*0.003;//this moves input point a smidge to make raymarch work else will break out\n                                             \n                    pExit = pEnter + rdIn * retVal.y;//so retval carries the fluid's distance value\n                    nExit = -GetNormal(pExit);\n                     \n                    vec3 rdOut = refract(rdIn, nExit, IOR);\n                                \n                    cup  = texture(iChannel0, rdOut).rgb ;\n                   if (retVal.y != 0.0){cup+=vec3(0.13467,0.01245,0.1314);// ie its the fluids distance value\n                                      cup*=cup;\n                   }else if(dot(rd,nExit) > 0.0)cup+=vec3(0.1);    \n                                                               \n                   }else  col = (texture(iChannel0, refl).rgb)* 0.5;//attenuate the effect with *0.5\n                    \n                if(retVal.y==10.0)   col += (mix(RGB1, col, smoothstep(0.0, 0.9,-n.y))*0.5);//add gold colour, ditto also attenuate\n               // if(retVal.y==0.0) col+=(texture(iChannel0, refr).rgb)* 0.5;\n                if(retVal.y==5.0) col+=vec3(0.13467,0.01245,0.1314);\n                if(retVal.y==3.0) col+=vec3(0.111,0.123,0.531);\n                if(retVal.y==2.0) col+=vec3(0.531,0.123,0.131);\n                if(retVal.y==1.0) col+=vec3(0.111,0.323,0.331);\n                if(retVal.y==4.0) col+=vec3(0.111,0.123,0.131);\n                col+=cup;\n              } \n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}