{"ver":"0.1","info":{"id":"4X2yWV","date":"1727737227","viewed":16,"name":"Floatingbubble","username":"priyeshwani","description":"Floating bubble","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["floatingbubble"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\nprecision mediump int;\n#endif\n\n// Signed Distance Function (SDF) for the bubble with wobble effect\nfloat sdf(vec3 p) {\n    // Bubble position oscillates up and down\n    vec3 bubblePos = vec3(0.0, sin(iTime) * 0.5, 0.0);\n    p -= bubblePos;\n\n    // Wobble effect using sine functions\n    float wobble = sin(p.x * 3.0 + iTime * 2.0) * 0.05 +\n                   sin(p.y * 5.0 + iTime * 2.5) * 0.05 +\n                   sin(p.z * 4.0 + iTime * 3.0) * 0.05;\n\n    float radius = 1.0 + wobble;\n    return length(p) - radius;\n}\n\n// Calculate normal vector at point p\nvec3 calcNormal(vec3 p) {\n    float h = 0.001;\n\n    float dx = sdf(p + vec3(h, 0.0, 0.0)) - sdf(p - vec3(h, 0.0, 0.0));\n    float dy = sdf(p + vec3(0.0, h, 0.0)) - sdf(p - vec3(0.0, h, 0.0));\n    float dz = sdf(p + vec3(0.0, 0.0, h)) - sdf(p - vec3(0.0, 0.0, h));\n\n    return normalize(vec3(dx, dy, dz));\n}\n\n// Function to compute color along a ray\nvec3 rayColor(vec3 ro, vec3 rd) {\n    // Check for intersection with ground plane at y = -1.0\n    if (rd.y < 0.0) {\n        float t = (-1.0 - ro.y) / rd.y;\n        vec3 p = ro + rd * t;\n        float gridSize = 2.0;\n        vec2 coord = p.xz;\n        float xi = floor(coord.x / gridSize);\n        float yi = floor(coord.y / gridSize);\n        float checker = mod(xi + yi, 2.0);\n        vec3 groundColor = mix(vec3(0.3, 0.2, 0.1), vec3(0.2, 0.3, 0.1), checker);\n        // Add some lighting to the ground\n        float light = dot(normalize(vec3(0.0, 1.0, 0.0)), normalize(-rd));\n        groundColor *= 0.5 + 0.5 * light;\n        return groundColor;\n    } else {\n        // Procedural sky gradient\n        float t = 0.5 * (rd.y + 1.0);\n        vec3 skyColor = mix(vec3(0.6, 0.8, 1.0), vec3(0.1, 0.3, 0.6), t);\n        return skyColor;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -5.0); // Camera position\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.5)); // Ray direction\n\n    // Ray marching parameters\n    float t = 0.0;\n    const float tMax = 20.0;\n    const float minDist = 0.001;\n    const int maxSteps = 100;\n    float dist;\n    int i;\n\n    // Ray marching loop\n    for (i = 0; i < maxSteps; i++) {\n        vec3 p = ro + rd * t;\n        dist = sdf(p);\n        if (dist < minDist) break;\n        t += dist;\n        if (t > tMax) break;\n    }\n\n    vec3 col;\n    if (t < tMax) {\n        // Hit the bubble\n        vec3 p = ro + rd * t;\n        vec3 normal = calcNormal(p);\n\n        // Adjusted refractive index for realistic refraction\n        float eta = 1.0 / 1.05; // Refractive index (air to bubble)\n        vec3 refractedDir = refract(rd, normal, eta);\n        vec3 refractedColor = rayColor(p + refractedDir * minDist * 2.0, refractedDir);\n\n        // Reflection calculations\n        vec3 reflectedDir = reflect(rd, normal);\n        vec3 reflectedColor = rayColor(p + reflectedDir * minDist * 2.0, reflectedDir);\n\n        // Fresnel effect for blending reflection and refraction\n        float fresnel = pow(1.0 - max(dot(rd, normal), 0.0), 5.0);\n        col = mix(refractedColor, reflectedColor, fresnel);\n\n        // Add some bubble tint\n        col *= vec3(0.9, 0.95, 1.0);\n\n        // Add bubble surface lighting\n        vec3 lightDir = normalize(vec3(-0.5, 1.0, -0.5));\n        float diffuse = max(dot(normal, lightDir), 0.0);\n        col += 0.2 * diffuse * vec3(1.0, 1.0, 1.0);\n    } else {\n        // Background color\n        col = rayColor(ro, rd);\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}