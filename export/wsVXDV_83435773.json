{"ver":"0.1","info":{"id":"wsVXDV","date":"1575061912","viewed":119,"name":"Shitty Raytracing","username":"sebost1234","description":"ok","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shitty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int nrofspheres = 7;\nvec4 getSphere(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec4(1.0+sin(iTime)   ,0.9,0.4, 0.01);\n    case 1:\n        return vec4(1.0+sin(iTime+.1),0.7,0.4, 0.01);\n    case 2:\n        return vec4(1.0+sin(iTime+.2),0.5,0.4, 0.01);    \n    case 3:\n        return vec4(1.0+sin(iTime+.3),0.3,0.4, 0.01);   \n    case 4:\n        return vec4(1.0+sin(iTime+.4),0.1,0.4, 0.01);\n    case 5:\n        return vec4(1.0,0.1,5.0, 7.0);\n    case 6:\n        return vec4(1.0+sin(iTime*0.4)*4.,2.0,5.0+cos(iTime*0.4)*4., 1);\n    } \n}\n\nvec3 getSphereColor(int i)\n{\n\tswitch(i)\n    {\n    case 0:\n        return vec3(85./255., 205./255., 252./255.);\n    case 1:\n        return vec3(247./255., 168./255.,  184./255.);\n    case 2:\n        return vec3(1.0, 1.0, 1.0);\n    case 3:\n        return vec3(247./255., 168./255.,  184./255.); \n    case 4:\n        return vec3(85./255., 205./255., 252./255.);\n    case 5:\n        return vec3(0.5);\n    case 6:\n        return vec3(1.0, 0.5, 0.5);\n    } \n}\n\nfloat getSphereOpacity(int i)\n{\n    return 0.3;    \n}\n\n\nvec3 getLightDir()\n{\n    return vec3(-1.,-1.,0.2);\n}\n\nvec3 skyColor(vec3 ray)\n{\n    float diffuse = clamp(dot(ray,-getLightDir()), 0.0, 10.0);\n    float specular = pow(diffuse, 2.);\n    \n    float tmp1 = diffuse+specular+0.1f;\n    \n    vec3 light = (vec3(tmp1*1., tmp1*1., tmp1*1.)+vec3(0.0,0.0,0.1));\n\n    return light;\n\n    //return texture(iChannel0, ray).rgb;\n}\n\n\nstruct RayCastInfo\n{\n\tint sphereid;//-1 if not hit\n\tfloat t0;\n    float t1;\n};\n\nRayCastInfo calculateRay(vec3 pos, vec3 dir)\n{\n    int sphereid = -1;\n    float truet0=999999999999.;\n    float truet1=999999999999.;\n\n    for(int i = -1;i<nrofspheres;i++)\n    {\n        vec4 sphere = getSphere(i);\n\n        vec3 L = sphere.xyz - pos; \n        float tca = dot(L,dir); \n        if (tca >= 0.)\n        {\n            float d2 = dot(L,L) - tca * tca; \n            if (d2 <= sphere.w)\n            {\n                float thc = sqrt(sphere.w - d2); \n                float t0 = tca - thc; \n                float t1 = tca + thc;\n\n                if(t0<truet0)\n                {\n                    sphereid = i;\n                    truet0 = t0;\n                    truet1 = t1;\n                }\n\n            }\n        }\n    }\n\n    RayCastInfo tmp;\n    tmp.sphereid = sphereid;\n    tmp.t0 = truet0;\n    tmp.t1 = truet1;\n  \treturn tmp;\n}\n\n\nconst int nrofrays = 15;\n\nvec3 calculateMainRay(vec3 startpos, vec3 startdir)\n{\n    vec3 pos[nrofrays];\n    vec3 dir[nrofrays];\n    vec3 color[nrofrays];\n    float count[nrofrays];\n    bool finished[nrofrays];\n    int raycount = 1;\n    \n    pos[0] = startpos;\n    dir[0] = startdir;\n    color[0] = vec3(1.0);\n    finished[0] = false;\n    count[0] = 1.;\n    \n    \n    for(int i = 0;i<nrofrays-1;i++)\n    {\n        for(int o = 0;o<raycount;o++)\n        {\n            if(!finished[o])\n            {\n                RayCastInfo tmp = calculateRay(pos[o],dir[o]);\n\n                if(tmp.sphereid!=-1)\n                {\n                    vec4 sphere = getSphere(tmp.sphereid);\n                    vec3 spherecolor = getSphereColor(tmp.sphereid);\n\t\t\t\t\tfloat sphereopacity = getSphereOpacity(tmp.sphereid);\n                    \n                    pos[o] = pos[o] + dir[o]*tmp.t0;\n                    vec3 normal = normalize(pos[o] - sphere.xyz);\n                    \n\n                    //refraction\n                    if(raycount<nrofrays&&sphereopacity>0.001)\n                    {\n                        raycount++;\n                        \n                        float size = tmp.t1 - tmp.t0;\n                        \n                        vec3 shiftdir = cross(normal, dir[o]);\n                       \n                        pos[raycount-1] =  pos[o] + dir[o]*tmp.t1 + shiftdir*size;\n\n                        dir[raycount-1] = dir[o];\n                        color[raycount-1] = (spherecolor/(size+0.1))*color[o];\n                        color[raycount-1] *= sphereopacity;\n                        \n                        finished[raycount-1] = false;\n                        count[raycount-1] = count[o];\n                    }\n\n                    //reflection\n                    {\n                        dir[o] = reflect(dir[o], normal);\n                        \n                        color[o] *= spherecolor;\n                        \n                        count[o]++;\n                    }\n\n\n                }\n                else \n                {\n                    finished[o] = true;\n                    color[o] *= skyColor(dir[o]);\n                }\n            }\n        }\n    }\n    \n    //if(raycount==2) return vec3(0.0, 1.0, 0.0);\n    \n    \n    vec3 finalcolor = vec3(0.0);\n    for(int i = 0;i<raycount;i++)\n    {\n        finalcolor += color[i]/count[i];\n    }\n    \n    return finalcolor/float(raycount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = vec3(fragCoord/iResolution.y, 0); \n    \n    \n    vec2 center = vec2((iResolution.x*0.5)/iResolution.y, (iResolution.y*0.5)/iResolution.y);\n    \n    vec3 raydirection = normalize(pos - vec3(center, pos.z-0.6));\n\n\n    \n    fragColor = vec4(calculateMainRay(pos, raydirection), 0.0);\n}","name":"Image","description":"","type":"image"}]}