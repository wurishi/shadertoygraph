{"ver":"0.1","info":{"id":"st3BDf","date":"1663730954","viewed":616,"name":"Truchet Trip","username":"BigWIngs","description":"What you get when you weave two quad truchet layers. ","likes":51,"published":1,"flags":0,"usePreview":0,"tags":["truchet","quad","weave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Truchet Trip\" \n// by Martijn Steinrucken aka BigWings/The Art of Code - 2021\n//\n// I recently made a tutorial on how to make a weave of two quad truchet layers.\n// Check it out here:\n// https://youtu.be/pmS-F6RJhAk\n//\n// Here is a 'sketch' I had lying around that makes use of this.\n\n\n#define S smoothstep\n#define TAU 6.283185\n#define AA 3\n\nmat2 Rot(float a) {\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 Tile(vec2 p) {\n    bool corner = p.x>-p.y;\n    p -= corner?.5:-.5;\n    float d = length(p);\n    \n    float a = atan(p.x,p.y)/TAU +.5;\n    a = fract(a*4.);\n    \n    float m = cos(d*TAU*2.);\n    \n    return vec2(a-.5, d-.5);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.489,234.95));\n    p += dot(p, p+34.4);\n    return fract(p.x*p.y);\n}  \n\nfloat Xor(float a, float b) {\n    return a*(1.-b) + b*(1.-a);\n}\n\nvec3 TileLayer(vec2 p, float w) {\n    vec2 gv = fract(p)-.5;\n    \n    p.y = mod(p.y, 6.);\n    vec2 id = floor(p);\n   // id = mod(id, 16.);\n    \n    float checker = mod(id.x+id.y, 2.);\n    \n    float n = Hash21(id);\n    //n = .3;\n    float flip = step(n, .5);\n    \n    if(flip==1.) gv.x *= -1.;\n    \n    vec2 st = Tile(gv);\n\n    st.x = mix(st.x, 1.-st.x, checker);\n    st.x = (st.x-.5)/2.+.5;\n    st.y = st.y*(Xor(checker, flip)*2.-1.)/(w*2.);\n    \n    float z = gv.x>.48 || gv.y>.48 ? 1. : 0.;\n    return vec3(st, z);\n}\n\nvec3 Render(vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    float r = 16., r2=r/2., r4=r/4.;\n    float t = iTime+M.x*17.;\n    t = mod(t, r);\n    \n    vec2 p = uv;\n    float cd = length(p), lcd = log(cd);\n    \n    p*= Rot(sin(t*TAU/r+lcd)*.2);\n    float a = atan(p.x,p.y);\n    p = vec2(a/TAU+.5, lcd);\n    p*= vec2(4.,1.);\n    \n    p.y -= t/r4;\n    \n    float scale = 3.;\n    float w = .2;\n    vec3 st1 = TileLayer(p*scale, w);\n    \n   // st.x = fract(st.x+t*.1);\n    float m1 = S(.01,.0,abs(st1.y)-w);\n    float h1 =  S(.0,.5, .5-abs(st1.x-.5));\n     \n    vec3 st2 = TileLayer((p+.5)*scale, .5);\n    float m2 = S(.01,.0,abs(st2.y)-w);\n    float h2 =  S(0., .5, .5-abs(st2.x-.5));\n    \n    float t1 = st1.x+sin(st1.x*TAU)*.0;\n    float t2 = st2.x;\n    float arrow = st1.x+abs(st1.y);\n    arrow = fract(arrow-t/2.+a/TAU+lcd);\n    \n    col += vec3(1,.02,.02)*t1*h1*m1 * arrow;\n    \n    vec3 ribbon = vec3(.02,1,.02)*t2;\n    ribbon += sin(st2.x*TAU*4.+t*TAU/r4-a-lcd)*.1;\n    ribbon += sin(st2.y*TAU*20.)*.01;\n    \n    col += ribbon*h2*m2;\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for(int x=0; x<AA; x++) {\n        for(int y=0; y<AA; y++) {\n            vec2 offs = vec2(x, y)/float(AA);\n            col += Render(fragCoord+offs);\n        }\n    }\n    col /= float(AA*AA);\n    \n    col = vec3(sqrt(col.r+col.g));\n  \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}