{"ver":"0.1","info":{"id":"cdjcDh","date":"1687665693","viewed":103,"name":"diffusion_test","username":"usgai","description":"test","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["diffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash21(vec2 p){\n    vec2 p2 = fract(p*1324.518);\n    p2+=dot(p2,p2.yx+22.541);\n    return fract((p2.x+p2.y)*p2.y);\n}\nvec2 random2(vec2 p, vec2 seed){\n    float n = hash21((p.xy));\n    float n2 = 4.412;\n    float evol = seed.x + n;\n    float evol0 = floor(evol);\n    float evol1 = evol0+1.0;\n    vec2 p2 = fract((p.xy)*(34.532+evol0*n2 + (seed.y) * 0.3973)) ;\n    p2+=dot(p2,p2.yx+15.434);\n    vec2 result1 = fract((p2.xy+p2.yx + 0.523)*p2.yx +n);\n\n    vec2 p22 = fract((p.xy)*(34.532+evol1*n2 + (seed.y) * 0.3973));\n    p22+=dot(p22,p22.yx+15.434);\n    vec2 result2 = fract((p22.xy+p22.yx + 0.523)*p22.yx +n);\n\n    return mix(result1, result2, fract(evol)) * 2.0 - 1.0;\n}\n\n\n\nfloat interpolation(vec2 uv, vec2 seed)\n{\n    vec2 ratio = vec2(720.0);\n    vec2 _uv = floor(uv * ratio.xy / 100.0);\n    vec2 _fuv = fract(uv * ratio.xy / 100.0);\n    vec2 ofs = vec2(0.0, 1.0);\n    vec2 n4 = random2(_uv + ofs.xx, seed);\n    vec2 n7 = random2(_uv + ofs.yx, seed);\n    vec2 n10 = random2(_uv + ofs.xy, seed);\n    vec2 n13 = random2(_uv + ofs.yy, seed);\n    vec2 factor = vec2(0.0);\n    factor = _fuv;\n    factor = _fuv * _fuv * _fuv * (_fuv * (_fuv * 6.0 - 15.0) + 10.0);\n    float ret = mix(\n        mix(dot(n4, _fuv - ofs.xx), dot(n7, _fuv - ofs.yx), factor.x),\n        mix(dot(n10, _fuv - ofs.xy), dot(n13, _fuv - ofs.yy), factor.x),\n        factor.y\n    );\n    return ret * 0.5 + 0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col1 = texture(iChannel0, uv);\n    vec4 col2 = texture(iChannel1, uv);\n    vec4 col3 = texture(iChannel2, uv);\n    fragColor = abs(col2 - col1) * 0.7;\n    //fragColor = 1. - (1. - col3) * (1. - fragColor);\n    fragColor = col3;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"vec2 rotate(vec2 uv, float theta){\n    uv -= 0.5;\n    uv.y *= iResolution.y / iResolution.x;\n    mat2 rot = mat2(\n        cos(theta), sin(theta),\n        -sin(theta), cos(theta)\n    );\n    uv = rot * uv;\n    uv.y *= iResolution.x / iResolution.y;\n    uv += 0.5;\n    return uv;\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sigma = 4.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    const float u_Step = 4.0;\n    float u_WarpRed = 1.0;\n    float u_WarpBlue = -1.0;\n    vec4 noise = texture(iChannel1, vec2(fract(iTime * 0.0075))) * 2.0 - 1.0;\n    float n = 4. / 180.0 * 3.1415926 + noise.z * 0.05;\n    vec4 resColor = vec4(0.0);\n    vec4 sum_weight = vec4(0.0);\n    \n    for(float i = 0.0; i < u_Step; i += 1.0)\n    {\n        float ip = i / max(1.0, u_Step - 1.0);\n        float ofs = mix(u_WarpRed * n, u_WarpBlue * n, ip);\n        vec4 red_weight = vec4(1.0, 0.0, 0.0, 1.0);\n        vec4 green_weight = vec4(0.0, 1.0, 0.0, 1.0);\n        vec4 blue_weight = vec4(0.0, 0.0, 1.0, 1.0);\n        vec4 color_weight = vec4(1.0);\n        float halfs = (u_Step - 1.0) * 0.5;\n        if (i < halfs)\n            color_weight = mix(red_weight, green_weight, i / floor(halfs)) * normpdf((halfs - i) / floor(halfs) * 15.0, sigma);\n        else\n            color_weight = mix(blue_weight, green_weight, (u_Step - i - 1.0) / floor(halfs)) * normpdf((halfs - u_Step + i + 1.0) / floor(halfs) * 15.0, sigma);\n        vec2 tmp_uv = rotate(uv, ofs);\n        vec2 uvp = step(vec2(0.0), tmp_uv) * step(tmp_uv, vec2(1.0));\n        vec4 color = texture(iChannel0, (tmp_uv)) * color_weight;\n        resColor += color;\n        sum_weight += color_weight;\n    }\n    \n    resColor = resColor / sum_weight;\n    fragColor = resColor;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 rotate(vec2 uv, float theta){\n    uv -= 0.5;\n    uv.y *= iResolution.y / iResolution.x;\n    mat2 rot = mat2(\n        cos(theta), sin(theta),\n        -sin(theta), cos(theta)\n    );\n    uv = rot * uv;\n    uv.y *= iResolution.x / iResolution.y;\n    uv += 0.5;\n    return uv;\n}\nvec4 rgbToHmmd(vec3 rgb) {\n  float cmax = max(rgb.x, max(rgb.y, rgb.z));\n  float cmin = min(rgb.x, min(rgb.y, rgb.z));\n  float cdelta = (cmax - cmin);\n  vec3 dc = (vec3((rgb.y - rgb.z), (rgb.z - rgb.x), (rgb.x - rgb.y)) / max(cdelta, 0.001));\n  float hue = (dc.z + 4.0);\n  float hue12 = mix(hue, (dc.y + 2.0), step(cmax, rgb.y));\n  float hue13 = mix(hue12, dc.x, step(cmax, rgb.x));\n  float hue14 = mod((hue13 / 6.0), 1.0);\n  return vec4(hue14, cmin, cmax, cdelta);\n}\nvec3 stdrgbToHsv(vec3 rgb15) {\n  vec4 hmmd = rgbToHmmd(rgb15);\n  return vec3(hmmd.x, (hmmd.w / max(hmmd.z, 0.001)), hmmd.z);\n}\nvec3 stdhueToRgb(float hue16) {\n  float _tmp0 = (hue16 * 6.0);\n  float r = (abs((_tmp0 - 3.0)) - 1.0);\n  float g = ((- abs((_tmp0 - 2.0))) + 2.0);\n  float b = ((- abs((_tmp0 - 4.0))) + 2.0);\n  return clamp(vec3(r, g, b), vec3(0.0), vec3(1.0));\n}\nvec3 stdhsvToRgb(vec3 hsv) {\n  vec3 rgb17 = stdhueToRgb(hsv.x);\n  return (mix(vec3(1.0), rgb17, vec3(hsv.y)) * hsv.z);\n}\nfloat hash21(vec2 p){\n    vec2 p2 = fract(p*1324.518);\n    p2+=dot(p2,p2.yx+22.541);\n    return fract((p2.x+p2.y)*p2.y);\n}\nvec2 random2(vec2 p, vec2 seed){\n    float n = hash21((p.xy));\n    float n2 = 4.412;\n    float evol = seed.x + n;\n    float evol0 = floor(evol);\n    float evol1 = evol0+1.0;\n    vec2 p2 = fract((p.xy)*(34.532+evol0*n2 + (seed.y) * 0.3973)) ;\n    p2+=dot(p2,p2.yx+15.434);\n    vec2 result1 = fract((p2.xy+p2.yx + 0.523)*p2.yx +n);\n\n    vec2 p22 = fract((p.xy)*(34.532+evol1*n2 + (seed.y) * 0.3973));\n    p22+=dot(p22,p22.yx+15.434);\n    vec2 result2 = fract((p22.xy+p22.yx + 0.523)*p22.yx +n);\n\n    return mix(result1, result2, fract(evol)) * 2.0 - 1.0;\n}\n\n\n\nfloat interpolation(vec2 uv, vec2 seed)\n{\n    vec2 ratio = vec2(720.0);\n    vec2 _uv = floor(uv * ratio.xy / 100.0);\n    vec2 _fuv = fract(uv * ratio.xy / 100.0);\n    vec2 ofs = vec2(0.0, 1.0);\n    vec2 n4 = random2(_uv + ofs.xx, seed);\n    vec2 n7 = random2(_uv + ofs.yx, seed);\n    vec2 n10 = random2(_uv + ofs.xy, seed);\n    vec2 n13 = random2(_uv + ofs.yy, seed);\n    vec2 factor = vec2(0.0);\n    factor = _fuv;\n    factor = _fuv * _fuv * _fuv * (_fuv * (_fuv * 6.0 - 15.0) + 10.0);\n    float ret = mix(\n        mix(dot(n4, _fuv - ofs.xx), dot(n7, _fuv - ofs.yx), factor.x),\n        mix(dot(n10, _fuv - ofs.xy), dot(n13, _fuv - ofs.yy), factor.x),\n        factor.y\n    );\n    return ret * 0.5 + 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col1 = texture(iChannel0, uv);\n    vec4 noise = texture(iChannel2, vec2(fract(iTime * 0.0075))) * 2.0 - 1.0;\n    vec3 tmp_col = stdrgbToHsv(col1.rgb);\n    //tmp_col.r += noise.x;\n    //tmp_col.g = clamp(tmp_col.g + (noise.w * 0.5 + 0.5) * 0.25, 0.0, 1.0);\n    //tmp_col.b = clamp(tmp_col.b + (noise.z * 0.5 + 0.5) * 0.25, 0.0, 1.0);\n    col1.rgb = stdhsvToRgb(tmp_col);\n    vec2 uv1 = rotate(uv + noise.xy * 0.0025, 0.01 + noise.z * 0.01);\n    uv1 = (uv1 - 0.5) * (0.97) + 0.5;\n    vec4 col2 = texture(iChannel1, uv1);\n    vec2 nuv = uv + noise.xy * 0.75;\n    vec2 seed = vec2(5.0, 6.0);\n    float n1 = interpolation(nuv, seed);\n    float n2 = interpolation(nuv.yx, seed);\n    float n3 = interpolation(-nuv, seed);\n    \n    vec4 noise1 = texture(iChannel2, nuv * 0.08);\n    fragColor = mix(col1, col2, vec4(n1, n2, n3, 0.33333 * (n1 + n2 + n3)) * 0.3 + 0.68);\n    fragColor = mix(col1, col2, (noise1) * 0.1 + 0.9);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col1 = texture(iChannel0, uv);\n    vec4 col2 = texture(iChannel1, uv);\n    vec4 col3 = texture(iChannel2, uv);\n    fragColor = (col2 - col1) * 0.75;\n    //fragColor = 1. - (1. - col3) * (1. - fragColor);\n    fragColor += col1;\n    fragColor = col1 * 0.5 + col2 * 0.5;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"vec2 rotate(vec2 uv, float theta){\n    uv -= 0.5;\n    uv.y *= iResolution.y / iResolution.x;\n    mat2 rot = mat2(\n        cos(theta), sin(theta),\n        -sin(theta), cos(theta)\n    );\n    uv = rot * uv;\n    uv.y *= iResolution.x / iResolution.y;\n    uv += 0.5;\n    return uv;\n}\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sigma = 4.0;\n    vec2 uv = fragCoord/iResolution.xy;\n    const float u_Step = 8.0;\n    float u_WarpRed = 1.0;\n    float u_WarpBlue = -1.0;\n    vec4 noise = texture(iChannel1, vec2(fract(iTime * 0.0075))) * 2.0 - 1.0;\n    float n = 4. / 180.0 * 3.1415926 + noise.z * 0.05;\n    vec4 resColor = vec4(0.0);\n    vec4 sum_weight = vec4(0.0);\n    \n    for(float i = 0.0; i < u_Step; i += 1.0)\n    {\n        float ip = i / max(1.0, u_Step - 1.0);\n        float ofs = mix(u_WarpRed * n, u_WarpBlue * n, ip);\n        vec4 red_weight = vec4(1.0, 0.0, 0.0, 1.0);\n        vec4 green_weight = vec4(0.0, 1.0, 0.0, 1.0);\n        vec4 blue_weight = vec4(0.0, 0.0, 1.0, 1.0);\n        vec4 color_weight = vec4(1.0);\n        float halfs = (u_Step - 1.0) * 0.5;\n        if (i < halfs)\n            color_weight = mix(red_weight, green_weight, i / floor(halfs)) * normpdf((halfs - i) / floor(halfs) * 15.0, sigma);\n        else\n            color_weight = mix(blue_weight, green_weight, (u_Step - i - 1.0) / floor(halfs)) * normpdf((halfs - u_Step + i + 1.0) / floor(halfs) * 15.0, sigma);\n        vec2 tmp_uv = rotate(uv, ofs);\n        vec2 uvp = step(vec2(0.0), tmp_uv) * step(tmp_uv, vec2(1.0));\n        vec4 color = texture(iChannel0, (tmp_uv)) * color_weight;\n        resColor += color;\n        sum_weight += color_weight;\n    }\n    \n    resColor = resColor / sum_weight;\n    fragColor = resColor;\n}","name":"Buffer D","description":"","type":"buffer"}]}