{"ver":"0.1","info":{"id":"wlByzh","date":"1594141346","viewed":69,"name":"playaround circles","username":"ninifox16","description":"some circle shader","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["circle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//vec2 uv = fragCoord.xy / iResolution.xy; // b-left 0,0 t-right 1,1\n    vec2 uv = (fragCoord - .5 * iResolution.xy ) / iResolution.y;\n\tvec4 col = vec4(0.);\n    \n    // **** BACKGROUND ****\n    vec4 bg1 = vec4(1.,1.,1.,1.);\n    vec4 bg2 = vec4(0.,0.,0.,1.);\n    col = LinearGradient(bg1, bg2, uv, vec2(0), 0.);\n    \n    // **** FOREGROUND ****\n    \n    // Circle Parameters\n    vec2 center = vec2(0.5,0.5); // not implemented\n    float scale = 0.5;\n    \n    // Gradient\n    vec3 g1 = vec3(0.,1.,.6);\n    vec3 g2 = vec3(1.,1.,1.);    \n\t\n    // Animation\n    float loop = PI,minSca = .0,maxSca = 1.;    \n    float curSca = mix (minSca, maxSca, sin(mod(iTime,loop )));\n    \t\t\t\t\t\t\t\t\t\t\t\t\t\t\n    \t\t\t\t\t\t\t\t\t\t//fract :return input - floor(input);\n    // Circle\n\t/*\n\tfloat circleGrad = GradientCircle(center,curSca * scale,uv);\n    float circleMask = clamp01(OneMinus(floor(circleGrad))); //1.9 -> 1 0.1 -> 0 ceil 1.9 -> 2\n    vec4 circle = vec4(min(mix(g1,g2,circleGrad),circleMask),circleMask);\n    col = AlphaBlend(circle, col);\n    */\n    \n    // Rect\n    vec4 rectCol = vec4(.98,.34,.02,1.);\n    vec4 rect = Rect(vec2(0.,0.),vec2(.2,.8),uv *Rot(45.) *Sca(curSca)) * rectCol;\n    vec4 rect2 = Rect(vec2(0.,0.),vec2(.2,.8),uv *Rot(-45.) *Sca(curSca)) * rectCol;\n    \n    col = AlphaBlend(rect,col);\n    col = AlphaBlend(rect2,col);\n    // Output\n    fragColor = col;\n    \n    //vec4(SmoothGradient(bg1,bg2,0.4,.6,uv.x*3.,(uv + Mov(0.0,0.0)) *1.));                                      \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// **** Params ****\n#define PI 3.1415\n#define S smoothstep\n\n// **** Extentions ****\nfloat clamp01(float o){return clamp(o,0.,1.);}\nvec2 clamp01(vec2 o){return clamp(o,vec2(0),vec2(1)); }\nvec3 clamp01(vec3 o){return clamp(o,vec3(0.),vec3(1)); }\n\nfloat OneMinus(float value){return 1.-value;}\n\n// 1Rad = 180d/PI. so \nfloat r2d (float rad){return rad * 180. /PI;}\nfloat d2r (float degree){return degree /180. * PI;}\n\nvec4 AlphaBlend(vec4 src, vec4 dst)\n{\n    // src rgb * src A + dst rgb * (1 - src A)\n    float srcAlpha = clamp01(src.a);\n    return vec4 (src.xyz * srcAlpha + dst.xyz * (OneMinus(srcAlpha)), clamp01(src.z + dst.z));\n}\n\nvec2 Mov(vec2 d){ return vec2(d.y,d.x);}\nvec2 Mov(float x, float y) {return vec2(-x,-y);}\n\nmat2 Rot(float d)\n{    \n    float a = d2r(d);\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\nfloat Sca(float d){return 1./d;}\nvec2 Sca(float x,float y){return vec2(1./x,1./y);}\n\n// **** Functions ****\nfloat GradientCircle(vec2 center, float scale, vec2 uv)\n{\n    return length((uv)) / scale ;\n}\n\nfloat Rect(vec2 center, vec2 scale, vec2 uv)\n{\n\treturn ceil(clamp01(min(scale.x/2. - abs(uv.x), scale.y/2. - abs(uv.y)))) ;\n}\n\nvec4 LinearGradient(vec4 col1, vec4 col2, vec2 uv)\n{\n    return mix(col1,col2,uv.y +.5);\n}\nvec4 SmoothGradient(vec4 col1, vec4 col2,float s1,float s2, float offset, vec2 uv)\n{\n    return mix(col1,col2, S(s1,s2,uv.x +0.5 + offset));\n}\nvec4 LinearGradient(vec4 col1, vec4 col2, vec2 uv, vec2 center, float angle)\n{\n    uv *= Rot(angle);\n    return mix(col1,col2,uv.y +.5);\n    //     mix(1, 2, 0.5)\n    // Lerp = Linear Interporlation\n}","name":"Common","description":"","type":"common"}]}