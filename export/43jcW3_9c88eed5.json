{"ver":"0.1","info":{"id":"43jcW3","date":"1727800900","viewed":27,"name":"mariolover999","username":"mariolover999","description":"mariolover999","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["mariolover999"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GROUND_OFFSET 0.25f\n#define ROTATION_SPEED iTime / 3.0f\n#define GLOW 0.7f\n#define SKY_SIZE 4.0f\n#define SKY_SMOOTH -0.3f\n#define GRASS_HEIGHT 0.8f\n#define GRASS_SMOOTH -0.05f\n#define ORBIT_PATH 1.5f\n#define CRESCENT_OFFSET 0.2f\n\n// sourced from https://iquilezles.org/articles/distfunctions2d/ by Inigo Quilez\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// math functions included: sin, cos, distance, step, smoothstep\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // fixing aspect ratio for uv coordinates to be -1 to 1, and to not stretch shapes\n    uv = (uv * 2.0f) - 1.0f;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // rotation matrix for the sky\n    mat2 rotMat = mat2(cos(-ROTATION_SPEED), -sin(-ROTATION_SPEED), sin(-ROTATION_SPEED), cos(-ROTATION_SPEED));\n    // constants added to  control the center that is rotated around\n    vec2 rotation = rotMat * vec2(uv.x, uv.y + (GRASS_HEIGHT + GRASS_SMOOTH));\n    // geometry\n    \n        // sun\n        // sin and cos used for circular motion\n    vec2 centerSun = vec2(sin(ROTATION_SPEED) * ORBIT_PATH, cos(ROTATION_SPEED) - GROUND_OFFSET);\n    \n    float sun = distance(uv, centerSun);\n    sun = step(0.3, sun);\n    \n        // sun glow\n    float sunGlow = distance(uv, centerSun);\n    // smooth step used to create a glow effect rather than hard lines\n    sunGlow = smoothstep(-0.1, GLOW, sunGlow);\n    \n        // moon    \n    vec2 centerMoon = vec2(-sin(ROTATION_SPEED) * ORBIT_PATH, -cos(ROTATION_SPEED) - GROUND_OFFSET);\n    \n    float moon = distance(uv, centerMoon);\n    moon = step(0.3, moon);\n    \n        // hole in moon for crescent\n    vec2 centerMoonHole = vec2(-sin(ROTATION_SPEED) * ORBIT_PATH - CRESCENT_OFFSET, -cos(ROTATION_SPEED) - GROUND_OFFSET); // offset by 0.2f and blending in with background\n    \n    float moonHole = distance(uv, centerMoonHole);\n    moonHole = step(0.3, moonHole);\n    \n        // moon glow\n    float moonGlow = distance(uv, centerMoon);\n    moonGlow = smoothstep(-0.1, GLOW, moonGlow);\n    \n    \n        // night bg\n    float night = sdBox(vec2(rotation.x, (rotation.y + (SKY_SIZE + SKY_SMOOTH))), vec2(SKY_SIZE, SKY_SIZE));\n    night = smoothstep(SKY_SMOOTH, 0.0f, night);\n        // day bg\n    float day = sdBox(vec2(rotation.x, (rotation.y - (SKY_SIZE + SKY_SMOOTH))), vec2(SKY_SIZE, SKY_SIZE));\n    day = smoothstep(SKY_SMOOTH, 0.0f, day);\n    \n        // grass\n    float grass = sdBox(vec2(uv.x, uv.y + GRASS_HEIGHT), vec2(2.0f, 0.3f));\n    grass = smoothstep(GRASS_SMOOTH, 0.0f, grass);\n    \n    vec3 colA = vec3(1.0f, 0.9f, 0.0f); // sun and moon color\n    vec3 colB = vec3(0.7f, 1.0f, 0.9f); // day color\n    vec3 colC = vec3(1.0f, 1.0f, 1.0f); // sun glow color\n    vec3 colD = vec3(0.1f, 0.6f, 0.0f);  // grass color\n    vec3 colE = vec3(0.2f, 0.4f, 0.4f); // night color\n    \n    vec3 col; // temp line\n    \n    col = mix(colB, col, day); // render the daylight bg\n    col = mix(colE, col, night); // render the nighttime bg\n    col = mix(colA, col, sun); // render sun\n    col = mix(colC, col, sunGlow); // render sun glow\n    col = mix(colA, col, moon); // render moon\n    col = mix(colE, col, moonHole); // render hole over moon to give crescent appearance\n    col = mix(colC, col, moonGlow); // render moon glow\n    col = mix(colD, col, grass); // render grass\n    fragColor = vec4(col, 1.0f);\n}\n\n// 2d sdf functions","name":"Image","description":"","type":"image"}]}