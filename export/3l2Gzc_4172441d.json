{"ver":"0.1","info":{"id":"3l2Gzc","date":"1560554998","viewed":599,"name":"Music Visualizer #3 (Bokeh)","username":"jaszunio15","description":"Experimenting - creating bokeh particles with voronoi noise.\n\nWait for music drop in 27s ;)\n\nSync with song:\nVorso & Opiuo — Photonics\nhttps://soundcloud.com/inspected/vorso-opiuo-photonics\n","likes":15,"published":1,"flags":64,"usePreview":0,"tags":["music","bokeh","particles","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xts3zj","filepath":"https://soundcloud.com/inspected/vorso-opiuo-photonics","previewfilepath":"https://soundcloud.com/inspected/vorso-opiuo-photonics","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n//1/512\n#define FREQ_STEP (0.001953125 * 3.0)\n\n#define PI 3.1415927\n#define TWO_PI 6.283185\n\nfloat hash1_2(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(52.127, 61.2871))) * 521.582);   \n}\n\nvec2 hash2_2(vec2 x)\n{\n    return fract(sin(x * mat2x2(20.52, 24.1994, 70.291, 80.171)) * 492.194);\n}\t\n\n//Simple interpolated noise\nvec2 noise2_2(vec2 uv)\n{\n    vec2 f = smoothstep(0.0, 1.0, fract(uv));\n    \n \tvec2 uv00 = floor(uv);\n    vec2 uv01 = uv00 + vec2(0,1);\n    vec2 uv10 = uv00 + vec2(1,0);\n    vec2 uv11 = uv00 + 1.0;\n    vec2 v00 = hash2_2(uv00);\n    vec2 v01 = hash2_2(uv01);\n    vec2 v10 = hash2_2(uv10);\n    vec2 v11 = hash2_2(uv11);\n    \n    vec2 v0 = mix(v00, v01, f.y);\n    vec2 v1 = mix(v10, v11, f.y);\n    vec2 v = mix(v0, v1, f.x);\n    \n    return v;\n}\n\n//Average band volume from nearest bands, more steps - smoother spectrum\nfloat getAvgVolume(float v, int steps)\n{\n    float sum = 0.0;\n    float x = 0.0;\n\tfor (int i = 0; i < steps; i++)\n    {\n        x = fract(v + float(i) * FREQ_STEP);\n        \t\t\t\t\t\t\t\t//pow for non linear spectrum\n        sum += texture(iChannel0, vec2(pow3(x), 0.0)).r * pow(x, 0.08) * (1.0 + v * 0.5); \n    }\n    \n    return (sum / float(steps));\n}\n\nvec3 myHue(float hue)\n{\n    hue = fract(hue);\n \treturn clamp(vec3(sin(hue * TWO_PI), \n                      sin(hue * TWO_PI + TWO_PI * 0.33), \n                      sin(hue * TWO_PI + TWO_PI * 0.66)), 0.0, 1.0);   \n}\n\n//Cell center from point on the grid\nvec2 voronoiPointFromRoot(vec2 root, float deg)\n{\n  \tvec2 point = hash2_2(root) - 0.5;\n    float s = sin(deg);\n    float c = cos(deg);\n    point = mat2x2(s, c, -c, s) * point;\n    point += root + 0.5;\n    return point;\n}\n\nfloat degFromRootUV(vec2 uv, float animationOffset)\n{\n \treturn (iTime + animationOffset) * (hash1_2(uv) + 0.2);   \n}\n\nvec2 rotate(vec2 point, float deg)\n{\n \tfloat s = sin(deg);\n    float c = cos(deg);\n    return mat2x2(s, c, -c, s) * point;\n}\n\n//Main circle sync\nfloat intensiveMomentSoft()\n{\n \tfloat introMod = smoothstep(0.0, 27.5, iChannelTime[0]);\n    float introMod4 = pow2(introMod); \n    \n    float silence = 1.0 - smoothstep(120.0, 137.0, iChannelTime[0]);\n    float drop = smoothstep(158.0, 165.5, iChannelTime[0]);\n    drop = pow4(drop);\n    float silence2 = 1.0 - smoothstep(260.5, 274.25, iChannelTime[0]);\n\n    return introMod4 * silence + drop * silence2;\n}\n\n//Particle movment speed sync\nfloat intensiveMomentMove()\n{\n    float intro = smoothstep(25.5, 27.6, iChannelTime[0]);\n    float intro2 = smoothstep(81.5, 82.5, iChannelTime[0]);\n    float silence = 1.0 - smoothstep(120.0, 137.0, iChannelTime[0]);\n    float drop = smoothstep(164.5, 166.5, iChannelTime[0]);\n    float drop2 = smoothstep(218.5, 219.5, iChannelTime[0]);\n    float silence2 = 1.0 - smoothstep(260.5, 274.25, iChannelTime[0]);\n    return (intro + intro2 * 0.5) * silence + (drop + drop2 * 0.5) * silence2;\n    \n}\n\n//Particle zoom sync\nfloat intensiveMomentZoom()\n{\n    float introMod = smoothstep(0.0, 27.5, iChannelTime[0]);\n    float introMod2 = smoothstep(81.5, 82.5, iChannelTime[0]);\n    float silence = 1.0 - smoothstep(120.0, 137.0, iChannelTime[0]);\n    float drop = smoothstep(158.0, 165.5, iChannelTime[0]);\n    float drop2 = smoothstep(218.5, 219.5, iChannelTime[0]);\n    float silence2 = 1.0 - smoothstep(260.5, 274.25, iChannelTime[0]);\n\n    return 1.0 - ((introMod + introMod2 * 0.5) * silence + (drop + drop2 * 0.5) * silence2);\n}\n\n//x - voronoi coordinates (grid step = 1)\nfloat voronoi(vec2 uv, vec2 distProportions, float distRotation, float animationOffset)\n{\n    vec2 rootUV = floor(uv);\n    float deg = degFromRootUV(rootUV, animationOffset);\n    vec2 pointUV = voronoiPointFromRoot(rootUV, deg);\n    \n    vec2 tempRootUV;\t//Used in loop only\n    vec2 tempPointUV;\t//Used in loop only\n    vec2 closestPointUV = pointUV;\n    float minDist = 2.0;\n    float dist = 2.0;\n    for (float x = -1.0; x <= 1.0; x+=1.0)\n    {\n     \tfor (float y = -1.0; y <= 1.0; y+=1.0)   \n        {\n         \ttempRootUV = rootUV + vec2(x, y);\n            deg = degFromRootUV(tempRootUV, animationOffset);\n            tempPointUV = voronoiPointFromRoot(tempRootUV, deg);\n            tempPointUV = mix(tempPointUV, tempRootUV + 0.5, animationOffset);\n            \n            dist = length(rotate(uv - tempPointUV, distRotation) * distProportions);\n            if(dist < minDist)\n            {\n             \tclosestPointUV = tempPointUV;\n               \tminDist = dist;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\n//Bokeh from voronoi\nfloat bokehParticles(vec2 uv, float radius, vec2 dotProportions, float dotRotation, float animationOffset)\n{\n \tfloat voro = voronoi(uv, dotProportions, dotRotation, animationOffset);\n    float particles = 1.0 - smoothstep(radius, radius * (2.0), voro);\n    return particles;\n}\n\n//Layering particles to imitate 3D view\nvec3 layeredParticles(vec2 uv, float radiusMod, float sizeMod, float alphaMod, int layers, vec2 dotProportions, float dotRotation, float animationOffset) \n{ \n    vec3 particles = vec3(0);\n    float size = 1.0;\n    float alpha = 1.0;\n    float radius = 0.04;\n    vec2 offset = vec2(0.0);\n    vec3 startColor = myHue(iTime * 0.05 + animationOffset * 0.5) + 0.3;\n    vec3 endColor = myHue(iTime * 0.05 + 0.3 + animationOffset * 0.5) + 0.3 + animationOffset;\n    vec3 color = startColor;\n    for (int i = 0; i < layers; i++)\n    {\n\t\tparticles += bokehParticles(\n            (uv * size + vec2(sin(iTime * 0.3), cos(iTime * 0.3)) * 6.0 * intensiveMomentMove() - animationOffset * 0.3) + offset,\n            radius, \n            dotProportions, \n            dotRotation + offset.x, \n            animationOffset\n        \t) * alpha * color;\n        color = mix(startColor, endColor, float(i+1) / float(layers));\n        offset += hash2_2(vec2(alpha, alpha)) * 10.0;\n        alpha *= alphaMod;\n        size *= sizeMod;\n        radius *= radiusMod;\n    }\n    return particles;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float intensivity = intensiveMomentSoft();\n    \n    vec3 col = vec3(0);\n    \n    //Gathering the kick from the song\n    float kick = getAvgVolume(0.08, 50);\n    kick = sqrt(smoothstep(0.25, 0.5, pow4(kick))) * intensivity;\n    \n    //uv 0.0 at the screen center\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.x;\n    uv *= 2.0;\n    \n    //Fish eye\n    uv *= 1.0 - length(uv) * 0.2;\n    \n    //Displacement\n    uv += (noise2_2(uv * 3.0 + iTime + kick) - 0.5) * 0.1 * kick;\n    \n    //Dots shape\n    vec2 dotProportions = mix(vec2(1.0), vec2(0.07, 10.0), kick);\n    \n    //Particles\n    vec3 particles = layeredParticles(\n        uv, \n        0.99 + kick * 0.01, //RadiusMod\n        1.08 - kick * 0.02 - intensiveMomentZoom() * 0.1, //SizeMod\n        0.93, //AlphaMod\n        20, //Layers\n        dotProportions, \n        PI * 0.5 + (iTime - kick), //Dots rotation\n        kick * 0.5\t//Animation offset\n    \t) * 0.75;    \n    col += particles;\n    \n    //Coloring the darkness\n    col += 0.05 * myHue(kick + iTime * 0.1);\n    \n  \t//Center circle\n    float circle = 1.0 - smoothstep(0.1 + (1.0 - intensivity) + kick * kick * 0.5, 0.1 + (1.0 - intensivity) + kick * kick * 0.5 + 0.01 + kick * 0.001, length(uv) * intensivity);\n    \n \t//Placing the circle\n    col += circle * intensivity;\n    \n    //Inverting colors in the circle\n    col = mix(col, (1.3 + kick * 0.4) - col, circle * intensivity);\n    \n    //Vigniete and addtitional lighting\n    float vignete = 1.0 - smoothstep(1.0, 1.8, length(uv * vec2(1.0, iResolution.x / iResolution.y)));\n    float lighting = 1.0 - smoothstep(0.0, 2.0, length(uv));\n    float lighting2 = 1.0 - smoothstep(0.3, 0.8, length(uv));\n\n    //Postrpocess\n    col = smoothstep(-0.1, 0.9, col);\n    \n    //Vignete\n    col *= vignete;\n    \n    //Lighting\n    col += (lighting * kick * 0.1) + lighting2 * kick * 0.15;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float pow2(in float x)\n{\n \treturn x*x;   \n}\n\nfloat pow3(in float x)\n{\n \treturn x*x*x;   \n}\n\nfloat pow4(in float x)\n{\n \treturn x*x*x*x;   \n}\n","name":"Common","description":"","type":"common"}]}