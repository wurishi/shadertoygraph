{"ver":"0.1","info":{"id":"WlcyRj","date":"1609437198","viewed":306,"name":"Day 379 - Wythoff & Dual Tilings","username":"jeyko","description":"potate","likes":12,"published":3,"flags":0,"usePreview":0,"tags":["tiling","wythoff","mdtmjvm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Black Lines are the main tiling\n// White lines are the dual \n\n// Honestly, the code isn't a very tidy read, so you might want to look at some other resources\n// if you'd like to do this yourself.\n\n// Here's some other takes on Wythoff tiling:\n// by fizzer: https://www.shadertoy.com/view/3tyXWw\n// by mla: https://www.shadertoy.com/view/ttGSRy\n\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pal(a,b,c,d,e) ((a) + (b)*sin((c)*(d) + (e)))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\nfloat id = 0.;\n\nvec2 refl(vec2 p, vec2 reflectionPlane, float offs){\n    float dotReflectionPlane = dot(p + reflectionPlane*offs,reflectionPlane);\n    dotReflectionPlane = max(abs(dotReflectionPlane),0.)*sign(dotReflectionPlane);\n    p -= min(dotReflectionPlane,0.)*2.*reflectionPlane;\n    id+= float(dotReflectionPlane<0.)*4. + float(dotReflectionPlane<0.)*dotReflectionPlane*.84;\n    return p;\n}\n\nvec3 get(vec2 fragCoord){\n    vec3 col = vec3(0);\n    id = 0.;\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 3. + sin(iTime*0.4)*0.2;\n    float cntSides = 3.;\n    \n    if(iMouse.x/iResolution.x<0.33){\n        cntSides = 3.;\n    } else if(iMouse.x/iResolution.x<0.66){\n        cntSides = 4.;\n    } else {\n        cntSides = 6.;\n    } \n    \n    float cntIters = 20.;\n    \n    vec2 p = uv;\n    \n    \n    float radiusInscribedCircle = 0.4;\n    \n    for(float iter = 0.; iter < cntIters; iter++){\n        vec2 sidePlane = vec2(1.,0.);\n        \n        for(float side = 0.; side < cntSides; side++){\n            sidePlane *= rot(tau/cntSides);\n            \n            p = refl( p,sidePlane,radiusInscribedCircle);\n\n        }\n        vec2 reflectionPlane = vec2(1.,0.);\n        for(float side = 0.; side < cntSides; side++){\n            \n            \n            p = refl( p, reflectionPlane, 0.);\n            \n            \n            reflectionPlane *= rot(pi/cntSides);\n\n        }\n\n    }\n    \n    \n    float hexCircumCircleRadius = radiusInscribedCircle/(sqrt(3.)/2.);\n    float triangleRadius = radiusInscribedCircle*1.44;\n    \n    col += pal(0.5,vec3(0.5,.3,0.1),vec3(1.5,2.6,4.4),1.,id + iTime );\n    \n    float d = length(p.y - radiusInscribedCircle * (\n                + 1.*float(cntSides == 4.)\n                + triangleRadius*float(cntSides == 3.)\n                ) \n            );\n            \n    \n    vec2 dualness = mix(vec2(0),\n        0.7 + 0.1*vec2(sin(iTime), cos(iTime)),\n        0. + iMouse.y/iResolution.y\n    );\n\n    if (cntSides == 6.){\n        d = length((p*rot(pi/6.)).y - hexCircumCircleRadius*0.85);                \n    }\n\n    // Positioning duals\n    if(cntSides == 3.){\n        // some number crunching here\n        p.x += 0.175*triangleRadius;\n        p = refl( p, -vec2(0,1.), hexCircumCircleRadius*0.5 );\n        p.x -= 0.175*triangleRadius;\n        \n        \n        p.y -= dualness.y*0.5*hexCircumCircleRadius;\n        \n        p.x -= 0.5*dualness.x*0.7*triangleRadius;\n        \n        //p.x -= 0.01\n        //p.x -= 0.7*dualness.x*0.66*triangleRadius;\n        //p.y += -0.5*dualness.y*0.45*triangleRadius;\n        \n        \n    } else if(cntSides == 6.){    \n        p.y -= 1.5*dualness.y*0.6*hexCircumCircleRadius;\n        p.x -= 1.5*dualness.x*0.15*radiusInscribedCircle;\n    \n        p *= rot(0.666*pi*float(cntSides==6.));  // the number of the beast .-.\n\n    }  else if(cntSides == 4.) {\n        p.x -= dualness.x*0.4*radiusInscribedCircle;\n        p.y -= dualness.y*0.9*radiusInscribedCircle;\n    }\n    \n    \n    float dDual = max(length(p.x), - p.y );\n    dDual = min( dDual, \n            max( length(p.y), p.x)\n        );\n        \n    p *= rot(0.325*pi*float(cntSides==3. || cntSides==6.));\n    p *= rot(0.25*pi*float(cntSides==4.));\n    \n    \n    dDual = min( dDual, \n            max( length(p.y), -p.x)\n        );\n    if (cntSides == 6.){\n        //dDual = d + 0.*(d = dDual); // oh my, not the prettiest line of code, haha.  \n    }\n    \n    \n    d = min(d, length(p) - 0.03);\n    \n    d -= 0.01;\n    dDual -= 0.007;\n    \n    col = mix(col,vec3(1.), smoothstep(dFdx(uv.x), 0., dDual));\n    col = mix(col,vec3(0.), smoothstep(dFdx(uv.x), 0., d));\n    \n    \n    col = max(col,0.);\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    \n    float aa = 3.;\n    \n    for(float i =0.; i < aa*aa + min(float(iFrame),0.)   ; i++){\n    \tcol += get(fragCoord + 0.66*vec2(mod(i,aa),floor(i/aa))/aa);\n    }\n    col /= aa*aa;    \n    \n    //col = mix(col, smoothstep(0.,1.,col*vec3(1.6,1.2,1.4)),0.5);\n    \n    col = pow(col,vec3(0.8545));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}