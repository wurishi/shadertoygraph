{"ver":"0.1","info":{"id":"fdVGDz","date":"1631365249","viewed":283,"name":"Volumetric Integration","username":"LisWind","description":"Learning volumetric rendering from SebH\nhttps://www.shadertoy.com/view/XlBSRz","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","participatingmedia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/XlBSRz\n// SebH - VolumetricIntegration\n\n// Settings\n#define VOLUME_SHADOW_ENABLED 1\n#define MAX_STEP_LENGTH_ENABLED 1\n#define DETAILED_WALLS 1\n#define UPDATE_TRANSMITTANCE_FIRST 1\n\n#define FOG_NOISE 0\n#define FOG_STRONG_FOG 0.0\n\n// Consts\n#define PI 3.141592657\n#define Epsilon 0.00001\n\nstruct Ray {\n    vec3 o;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float r;\n};\n\nstruct Light {\n    vec4 posOrDir;\n    vec3 color;\n};\n\nstruct RayPayload {\n    vec3 p;\n    vec3 n;\n    vec3 albedo;\n    vec4 scatTrans;\n};\n\nfloat sdSphere (vec3 pos, Sphere s) {\n    return length(pos - s.pos) - s.r;\n}\n\nfloat DisplacementSimple (vec2 p) {\n    float f = 0.0;\n    \n    f  = 0.5000 * textureLod(iChannel0, p, 0.0).x; p *= 2.0;\n    f += 0.2500 * textureLod(iChannel0, p, 0.0).x; p *= 2.0;\n    f += 0.1250 * textureLod(iChannel0, p, 0.0).x; p *= 2.0;\n    f += 0.0625 * textureLod(iChannel0, p, 0.0).x; p *= 2.0;\n    \n    return f;\n}\n\nvec3 GetSceneColor (vec3 p, int materialId) {\n    if (materialId == 1)\n        return vec3(1.0, 0.5, 0.5);\n    else if (materialId == 2)\n        return vec3(0.5, 1.0, 0.5);\n    else if (materialId == 3)\n        return vec3(0.5, 0.5, 1.0);\n    \n    return vec3(0.0, 0.0, 0.0);\n}\n\nvoid GetParticipatingMedia (in vec3 pos, out float sigmaS, out float sigmaE) {\n    // 0 Global HeightFog\n    float height = clamp(DisplacementSimple(pos.xz * 0.005), 0.0, 1.0);\n    float heightFog = 7.0 + 3.0 * height;\n    heightFog = 0.3 * clamp((heightFog - pos.y), 0.0, 1.0);\n    \n    const float fogFactor = 1.0 + FOG_STRONG_FOG * 5.0;\n    \n    // 1 SphereFog\n    Sphere fogSphere;\n    fogSphere.pos = vec3(20.0, 19.0, -17.0);\n    fogSphere.r = 5.0;\n    float ds = clamp(-sdSphere(pos, fogSphere), 0.0, 1.0);\n    float sphereFog = ds / fogSphere.r;\n    \n    // 2 ConstFog\n    const float constantFog = 0.02;\n    \n    sigmaS = constantFog + heightFog * fogFactor + sphereFog;\n    const float sigmaA = 0.0;\n    sigmaE = max(sigmaS + sigmaA, Epsilon); // to avoid division by 0 extinction\n}\n\nfloat PhaseFunction (float theta) { // atm theta unused!\n    return 1.0 / (4.0 * PI);\n}\n\nvec3 EvaluateLight (vec3 p, Light l) {\n    vec3 L = l.posOrDir.xyz - l.posOrDir.w * p;\n    return l.color * 1.0 / dot(L, L);\n}\n\nvec3 EvaluateLight (vec3 p, vec3 normal, Light l) {\n    vec3 L = l.posOrDir.xyz - l.posOrDir.w * p;\n    L = normalize(L);\n    return max(dot(L, normal), 0.0) * EvaluateLight(p, l);\n}\n\nfloat VolumetricShadow (in vec3 from, in vec3 to) {\n#if VOLUME_SHADOW_ENABLED\n    const float N = 16.0;\n    float shadow = 1.0;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    \n    vec3 vd = to - from;\n    vec3 stepVec = vd / N;\n    float len = length(vd);\n    vec3 dir = vd / (len + Epsilon);\n    float stepSize = len / N;\n    for (float i = 0.0; i < N; ++i) {\n        vec3 p = from + (float(i) + 0.5) * stepVec; // offset 0.5 to sample at the center of integral part\n        GetParticipatingMedia(p, sigmaS, sigmaE);\n        // TODO: calc opticalDepth first\n        shadow *= exp(-sigmaE * stepSize);\n    }\n    return shadow;\n#else \n    return 1.0;\n#endif\n}\n\nfloat GetClosestDistance (vec3 p, out int materialId) {\n    float d = 0.0;\n#if MAX_STEP_LENGTH_ENABLED\n    float minD = 1.0; // restrict max step for better scattering evaluation\n#else\n    float minD = 10000000.0;\n#endif\n\n    float xNoise = 0.0, yNoise = 0.0, zNoise = 0.0;\n#if DETAILED_WALLS\n    yNoise = 1.0 * clamp(DisplacementSimple(p.xz * 0.005), 0.0, 1.0);\n    xNoise = 2.0 * clamp(DisplacementSimple(p.zy * 0.005), 0.0, 1.0);\n    zNoise = 0.5 * clamp(DisplacementSimple(p.xy * 0.01 ), 0.0, 1.0);\n#endif\n    \n    d = max(0.0, p.y - yNoise);\n    if (d < minD) {\n        minD = d;\n        materialId = 2;\n    }\n    \n    d = max(0.0, p.x - xNoise);\n    if (d < minD) {\n        minD = d;\n        materialId = 1;\n    }\n    \n    d = max(0.0, 40.0 - p.x - xNoise);\n    if (d < minD) {\n        minD = d;\n        materialId = 1;\n    }\n    \n    d = max(0.0, -p.z - zNoise);\n    if (d < minD) {\n        minD = d;\n        materialId = 3;\n    }\n    \n    return minD;\n}\n\nvec3 CalcNormal (in vec3 p) {\n    int materialId = 0;\n    vec3 eps = vec3(0.3, 0.0, 0.0);\n    return normalize(vec3(\n        GetClosestDistance(p + eps.xyy, materialId) - GetClosestDistance(p - eps.xyy, materialId),\n        GetClosestDistance(p + eps.yxy, materialId) - GetClosestDistance(p - eps.yxy, materialId),\n        GetClosestDistance(p + eps.yyx, materialId) - GetClosestDistance(p - eps.yyx, materialId) ));\n        \n}\n\nRayPayload TraceScene(Ray r, Light l, bool improvedScattering) {\n    const int N = 64;    \n    \n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    \n    // initialize volumetric scattering integration (to view)\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n    float d = 1.0; // always have a first step of 1 unit to go further\n    float dClosest = 0.0; // == deltaD\n    int materialId = 0;\n    \n    vec3 p = vec3(0.0);\n    for (int i = 0; i < N; ++i) {\n        p = r.o + d * r.dir;\n        GetParticipatingMedia(p, sigmaS, sigmaE);\n        \n        if (improvedScattering) {\n            // slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n            vec3 S = sigmaS * PhaseFunction(0.0) * EvaluateLight(p, l) * VolumetricShadow(p, l.posOrDir.xyz); // incoming light\n            // integrate along the current step segment\n            vec3 Sint = (S - S * exp(-sigmaE * dClosest)) / sigmaE;\n            // accumulate and also take into account the transmittance from previous steps\n            scatteredLight += transmittance * Sint;\n            \n            // evaluate transmittance to view independently\n            transmittance *= exp(-sigmaE * dClosest);\n        }\n        else {\n            // basic scattering/transmittance integration\n        #if UPDATE_TRANSMITTANCE_FIRST\n            transmittance *= exp(-sigmaE * dClosest);\n        #endif // UPDATE_TRANSMITTANCE_FIRST\n        \n            scatteredLight += transmittance * (\n                sigmaS * PhaseFunction(0.0) * EvaluateLight(p, l) * VolumetricShadow(p, l.posOrDir.xyz));\n                \n        #if !UPDATE_TRANSMITTANCE_FIRST\n            transmittance *= exp(-sigmaE * dClosest);\n        #endif // UPDATE_TRANSMITTANCE_FIRST\n        }\n        \n        dClosest = GetClosestDistance(p, materialId);\n        if (dClosest < 0.2)\n            break; // give back a lot of performance without too much visual loss\n        d += dClosest;\n    }\n    \n    RayPayload payload;\n    payload.p = p;\n    payload.n = CalcNormal(p);\n    payload.albedo = GetSceneColor(p, materialId);\n    payload.scatTrans = vec4(scatteredLight, transmittance);\n    \n    return payload;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 screenUV = fragCoord.xy / iResolution.xy;\n    float whRatio = iResolution.x / iResolution.y;\n        \n    vec2 ndcUV = screenUV * 2.0 - 1.0;\n    ndcUV.x *= whRatio;\n    \n    vec3 camPos = vec3(20.0, 18.0, -50.0);\n    vec3 camX = vec3(1.0, 0.0, 0.0);\n    vec3 camY = vec3(0.0, 1.0, 0.0);\n    vec3 camZ = vec3(0.0, 0.0, 1.0);\n    \n    float fovV = 90.0;\n    float d = 1.0 / tan(radians(0.5 * fovV));\n    vec3 ro = camPos;\n    vec3 rd = normalize(ndcUV.x * camX + ndcUV.y * camY + d * camZ);\n    \n    Ray r;\n    r.o = ro;\n    r.dir = rd;\n    \n    Light l;\n    l.posOrDir = vec4(20.0 + 15.0 * sin(iTime), 15.0 + 12.0 * cos(iTime), -20.0, 1.0);\n    l.color = 600.0 * vec3(1.0, 0.9, 0.5);\n    \n    RayPayload payload = TraceScene(r, l, \n        fragCoord.x > 0.5 * iResolution.x\n        );\n    \n    // lighting\n    vec3 color = payload.albedo / PI * EvaluateLight(payload.p, payload.n, l) * VolumetricShadow(payload.p, l.posOrDir.xyz);\n    // apply scattering/transmittance\n    color = color * payload.scatTrans.w + payload.scatTrans.xyz;\n    \n    // Gamma correction\n    color = pow(color, vec3(1.0/2.2));\n    \n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}