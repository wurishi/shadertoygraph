{"ver":"0.1","info":{"id":"NdfSzX","date":"1619264055","viewed":147,"name":"River in Mountains","username":"xiaodi1043","description":"River in Mountains,the camera follows the river.Some ray matching problems need to be fixed.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymarch","3dnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FAR 500.\n#define CASTTERRIAN 3.\n#define CASTRIVER 4.\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nconst mat2 rotate2D = mat2(1.12, 0.1531, -.1131, 1.1623);\nconst mat2 rotateCloud = mat2(1.12, 0.3531, -.2131, 1.4623);\nvec2 add = vec2(1.0, 0.0);\n\nfloat Hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 Hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nfloat Noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    float res = mix(mix( Hash12(p),          Hash12(p + add.xy),f.x),\n                    mix( Hash12(p + add.yx), Hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\nfloat rand(vec2 n) { \n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n \n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat snoise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n \n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n \n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n \n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n \n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n \n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n\n\nfloat terrain(vec2 st){\n    const float LOOP=5.;\n    float atm=2.;\n    float f=.3;\n    float offset=2.4;\n    float h=0.;\n    for(float i=0.;i<LOOP;i++){\n        h+=atm*Noise(f*st+offset);\n        st=rotate2D*st;\n        atm*=.5;\n        f*=2.5;\n        offset*=2.;\n    }\n    // float ff=snoise(st*.2);\n    //h+=pow(abs(ff),3.)*2.;\n    return h;\n}\n\nfloat water(vec2 st){\n    const float LOOP=5.;\n    float atm=.1;\n    float f=1.15;\n    float offset=2.4;\n    float h=0.;\n    for(float i=0.;i<LOOP;i++){\n        h+=atm*noise(f*st+offset+.8*iTime);\n        atm*=.5;\n        f*=2.;\n        offset*=2.;\n    }\n    return h;\n}\n\nfloat cloud(vec3 p){\n    vec2 st=p.xz;\n    const float LOOP=3.;\n    float atm=.15;\n    float f=.55;\n    float offset=2.4;\n    float h=0.;\n    for(float i=0.;i<LOOP;i++){\n        h+=atm*noise(f*st+offset+.0*iTime);\n        atm*=.5;\n        f*=2.;\n        offset*=2.;\n        st=rotateCloud*st;\n    }\n    return h;\n}\n\n\nfloat random(float f){\n    return fract(sin(3212.23*f+5866.56)+4343.232);\n}\nfloat curve(float x){\n    float frequency=.8;\n    float atm=.9;\n    float value=0.;\n    for(float i=0.;i<2.;i++){\n        value+=atm*sin(frequency*x+3.);\n        atm*=.5;\n        frequency*=2.;\n    }\n    return value;\n}\n\n\n\nfloat calcCurveDif(float x){\n    //if use central differential,it will shake \n    return 0.9*cos(.8*x+3.)*.8+.9*.5*cos(.8*2.*x+3.)*2.*.8;\n}\n\nfloat nearestRiver(float low,float high,float x,float width){\n    float nearset=FAR;\n    for(float i=0.;i<3.;i++){\n        float z=low+(high-low)/50.*i;\n        float dist=length(vec2(x-curve(z),high-z));\n        nearset=min(nearset,dist-width);\n        if(nearset<0.){\n           return nearset;\n        }\n    }\n    return nearset;\n}\n\nfloat intersectRiver(vec3 pos){\n    float z=pos.z;\n    float fw=.1*sin(z)+.05*sin(.5*z)+.6;\n    float width=fw;\n    float nearset=nearestRiver(z-width,z,pos.x,width);\n    return nearset;\n}\n\n\n\nvec2 map(vec3 pos){\n    float castRiver=intersectRiver(pos);\n    float tH=terrain(pos.xz);\n    float type=CASTTERRIAN;\n\n    float abX=castRiver;\n    tH=smoothstep(0.3,1.5,abX)*tH;\n    if(tH<0.001){\n        type=CASTRIVER;\n        tH=water(pos.xz);\n    }\n   // tH=max(tH,.1);\n    return vec2(\n            //height\n            tH,\n            //type\n            type\n        );\n}\n\nvec2 mapT(vec3 pos){\n    float castRiver=intersectRiver(pos);\n    float tH=terrain(pos.xz);\n    float type=CASTTERRIAN;\n    float abX=castRiver;\n    tH=smoothstep(0.3,1.5,abX)*tH;\n    if(tH<0.001){\n        return vec2(\n            //height\n            0.,\n            //type\n            CASTRIVER\n        );\n    }\n    return vec2(\n            //height\n            tH,\n            //type\n            type\n        );\n}\n\nvec3 calcNormal(vec3 pos,float type){\n    vec3 result=vec3(0.);\n    vec2 delta=vec2(1.,-1.)*0.5773*0.0005;\n    vec2 res=vec2(FAR);\n    return normalize(\n        delta.xyy*map(pos+delta.xyy).x+\n        delta.yyx*map(pos+delta.yyx).x+\n        delta.yxy*map(pos+delta.yxy).x+\n        delta.xxx*map(pos+delta.xxx).x\n    );\n}\n\nvec4 castTerrain(vec3 or,vec3 rd){\n    const float CASTLOOP=50.;\n    float dist=0.01;\n    vec4 result=vec4(0.);\n    for(float i=0.;i<CASTLOOP;i++){\n        vec3 target=or+dist*rd;\n        vec2 map=mapT(target);\n        float h=map.x;\n        float delta=target.y-h;\n        if(delta<.01){\n            return vec4(\n                //dist\n                dist,\n                //type\n                map.y,\n                //casted\n                1.,\n                //h\n                h\n            );\n        };\n        if(dist>FAR){\n            result= vec4(\n                //dist\n                dist,\n                //type\n                map.y,\n                //casted\n                0.,\n                0.\n            );\n            break;\n        };\n        dist+=.27*abs(delta)+max(.002*abs(dist),.05);\n    }\n    return result;\n\n}\n\nvec4 castObjects(vec3 or,vec3 rd){\n    const float CASTLOOP=150.;\n    float dist=0.;\n    vec4 result=vec4(0.);\n    for(float i=0.;i<CASTLOOP;i++){\n        vec3 target=or+dist*rd;\n        vec2 map=map(target);\n        float h=map.x;\n        float delta=target.y-h;\n        if(delta<.02){\n            return vec4(\n                //dist\n                dist,\n                //type\n                map.y,\n                //casted\n                1.,\n                //h\n                h\n            );\n        };\n        if(dist>FAR){\n            result= vec4(\n                //dist\n                dist,\n                //type\n                map.y,\n                //casted\n                0.,\n                0.\n            );\n            break;\n        };\n        dist+=.19*abs(delta)+max(.002*abs(dist),.001);\n    }\n    return result;\n\n}\n\nvec3 drawSky(vec3 rd){\n    float baseN=.45;\n    float sm=.1;\n    vec3 col= vec3(0.4431, 0.6353, 0.9882);\n    float cloudV=cloud(rd);\n    col+=vec3(1.)*cloudV;\n    return col;\n}\n\nvec3 getTerrainCol(vec3 p){\n    vec3 res=vec3(0.4863, 0.451, 0.3765);\n    vec3 baseCoord=p.xyz*11.76;\n   // float ks=.1;\n    // baseCoord=rotate2D*baseCoord;\n\n    float rn=snoise(baseCoord);\n    rn=rn;\n    float rockn=snoise(p.xyz);\n    float baseN=.5;\n    float stepN=0.1;\n    float heightFromWater=p.y;\n    \n    float hasTree=1.-smoothstep(rn+.4,rn+.4+.8*rn,heightFromWater);\n    \n    float darkWater=1.-smoothstep(.01+.1*rn,.01+.1*rn+.08,heightFromWater);\n    float dark=snoise(p.xyz);\n    res+=darkWater*vec3(0.6471, 0.5333, 0.3686);\n    res+=(1.-darkWater)*hasTree*vec3(0.0078, 0.2392, 0.0078);\n    float snow=smoothstep(2.5,2.5+.5,heightFromWater);\n    res+=snow*vec3(1. );\n    float nl=(1.-snow)*(1.-darkWater)*smoothstep(.7,.7+.01,rockn);\n    return res;\n}\n\n\n\nvec3 render(vec3 or,vec3 rd){\n    vec4 castResult=castObjects(or,rd);\n    vec3 lin=vec3(0.);\n    vec3 res=vec3(0.4863, 0.451, 0.3765);\n    vec3 normal=vec3(0.,0.,0.);\n    float dist=FAR;\n    vec3 speNormal=normal;\n    float ks=1.;\n    float br=1.;\n    float difR=0.4;\n    float waterR=0.;\n    vec3 p=or+castResult.x*rd;\n    if(castResult.z>0.){\n        normal=calcNormal(p,castResult.y);\n        speNormal=normal;\n        dist=castResult.x;\n    }\n    if(abs(castResult.y-CASTRIVER)<0.01){\n        res=vec3(0.1608, 0.3804, 0.3569);\n        br=40.;\n        difR=.7;\n        waterR=1.;\n        ks=2.;\n        speNormal=vec3(0.,1.,0.);\n        vec3 red=rd+vec3(0.,-(rd.y)*2.,0.);\n        red=normalize(red);\n        vec3 from=p+.1*normal;\n        vec4 castRes=castTerrain(from,red);\n        if(castRes.z>0.){\n            if(abs(castRes.y-CASTTERRIAN)<0.01){\n                vec3 rP=from+castRes.x*red;\n                vec3 reCol=getTerrainCol(rP);\n                res=res*.8+.2*reCol;\n            }\n        }else{\n            res=res*.7+.3*drawSky(red);\n           // res=drawSky(red);\n        }\n        float castRiver=intersectRiver(p);\n        float width=-castRiver;\n        res-=vec3(.4)*smoothstep(0., 0.6,width );\n        \n\n    }\n    else if(abs(castResult.y-CASTTERRIAN)<0.01){\n        ks=0.1;\n        res=getTerrainCol(p);\n    }\n    {\n    \n        vec3 light=normalize(vec3 (-0.02,0.2,0.3));\n        vec3 hal=normalize(light-rd);\n        float dif=clamp(dot(normal,light),0.,1.);\n        float spe=pow(\n            clamp(dot(speNormal,hal),0.,1.),\n            br\n\n        );\n        spe*=dif;\n        spe*=0.14+0.96*pow(\n            clamp(1.-dot(hal,light),0. ,1. ),\n            5.\n        );\n        vec3 suncol=vec3(0.9686, 0.9216, 0.7922);\n        lin+=difR*res+res*.7*dif*suncol+.7*res*waterR*(1.-dif)*.75*suncol;\n        \n        lin+=5.*spe*vec3(1.3,1.0,0.7)*ks;\n        lin=step(0.1,castResult.z)*lin+(1.-step(0.1,castResult.z))*drawSky(rd);\n       \n        //  lin = mix( lin, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*height*height*height ) );\n\n    }\n    vec3 fogCol=vec3(0.9529, 0.9804, 0.9804);\n    float fogRatio = smoothstep(1.,10. ,dist );\n    lin=(1.-fogRatio)*lin+fogRatio*fogCol;\n    float skyRatio=smoothstep(.2,1.,abs(rd.y))*(1.-castResult.z);\n    lin=skyRatio*drawSky(rd)+(1.-skyRatio)*lin;\n    return lin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \n    st.y*=iResolution.y/iResolution.x;\n    st-=.5;\n    st.y+=.2;\n    \n    st*=5.;\n    float z=.5*iTime+2.;\n    float x=curve(z);\n    float dXZ=calcCurveDif(z);\n    vec3 cameraPosition=vec3(x,.5,z);\n    vec3 dP=normalize(vec3(dXZ,0.,1.));\n    vec3 lookAt=normalize(dP+vec3(0.,-.1,0.));\n    vec3 rightLook=cross(lookAt,vec3(0.,1.,0.));\n    rightLook=normalize(rightLook);\n    vec3 upLook=cross(rightLook,lookAt);\n    upLook=normalize(upLook);\n    vec3 direction=lookAt+st.x*rightLook+st.y*upLook;\n    direction=normalize(direction);\n\n    vec3 res=render(cameraPosition,direction);\n\n    fragColor=vec4(res,1.);\n\n}","name":"Image","description":"","type":"image"}]}