{"ver":"0.1","info":{"id":"4cSfzG","date":"1725055882","viewed":61,"name":"Drop 01 - Bricks blocks","username":"Elsio","description":"Colorir shaders desse tipo não é uma coisa trivial. Você tem que escolher IDs e eles tem de ser coerentes em todo o trajeto do objeto. Mas, o número de cores possíveis depende do número de ids. Então, colorir passa a ser um algoritmo a mais pra se pensar.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["grid","tutorial","mobius","polar","block","shape"],"hasliked":0,"parentid":"lcSBz1","parentname":"Drop 01a - colors"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define cor(a) (cos(6.3 * vec4(h11(a), h11(a + 1.), h11(a + 2.), 0)) * .3 + .5)\n#define h11(k) fract(sin(k * 453.2734) * 994.3434)\n#define t iTime\n\nfloat box(vec2 p, float b) {\n    p = abs(p) - b;\n    return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - .16;\n}\n\nvoid mainImage(out vec4 o, vec2 u) {\n    float colorID, \n          T = smoothstep(-.25, .25, cos(t * .2));\n          \n    vec4 col;\n    \n    vec2 h = vec2(1, 100. - 75. * T),\n         r = iResolution.xy, q,\n         p = 8. * vec2(u + u - r) / r.y;\n         \n         p = mix(\n                 p *= 71. / dot(p, p),              // morbius transf\n                 p = 3. * vec2( log(length(p)),\n                                atan(p.y, p.x)  ),  // log polar\n                 T\n             );\n          \n    float k = floor(p.x),\n          t = h.y * h11(k) * .004 + t;\n\n     p.y += sin(k * .4 + t) * .8 + fract(t);\n\n             colorID = min(floor(p.y), 0.) + floor(t);\n             col = cor(h11(k + h11(colorID)));\n\n     p.y < 0.\n         ? h.y = 1.\n         : 0.;\n\n     p.y += (h.y - 1.) / 2. * fract(t);\n\n     p = fract(p / h) - .5;\n     \n     o = smoothstep(24. / r.y, .0, box(p * h, .3)) * col;\n}","name":"Image","description":"","type":"image"}]}