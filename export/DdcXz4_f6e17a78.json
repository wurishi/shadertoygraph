{"ver":"0.1","info":{"id":"DdcXz4","date":"1680961851","viewed":141,"name":"Another segment sdf method","username":"Poisson","description":"Another segment sdf method using a rotation matrice and an extrusion.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","raymarching","sdf","line","antialiasing","raymarcher","distance","aa","rotation","segment","isoline","capsule","matrice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#if 0\n// iq's method\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\n    return length(pa - ba*h) - r;\n}\n\n#elif 0\n// my method, bad but interesting\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b, float r) { \n    vec2 q = p - (a+b)*.5; // middle point\n    \n    float h = length(b-a); // distance between a and b\n    vec2 d = (b-a)/h; // direction of the capsule\n    q *= mat2( d.x,d.y, // rotation\n              -d.y,d.x);\n    \n    q = abs(q) - vec2(h*.5,0); // extrusion\n    return length(max(q,0.)) - r;\n}\n\n#else\n// iq's improved method, single square root\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b, float r) { \n    vec2 q = p - (a+b)*.5; // middle point\n    \n    vec2 d = b-a; // direction of the capsule\n    q *= mat2( d.x,d.y, // rotation\n              -d.y,d.x);\n    \n    float h2 = dot(d,d);\n    q = max(abs(q) - vec2(h2*.5,0), 0.); // extrusion\n    return sqrt(dot(q,q) / h2) - r;\n}\n\n#endif\n\n// circle sdf\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// sdf antialiasing function\nfloat antialias(float x) {\n    // derivates\n    float dx = dFdx(x),\n          dy = dFdy(x);\n    \n    float df = length(vec2(dx,dy));\n    return clamp(.5-x/df, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 m = (iMouse.xy - .5*iResolution.xy) / iResolution.y;\n    p *= 2.3;\n    m *= 2.3;    \n    \n    // two points + radius\n    vec2 a = cos(iTime*.5 + vec2(0,1));\n\tvec2 b = cos(iTime*.5 + vec2(0,3) + 1.5);\n    float ra = .15+.15*cos(iTime);\n    \n    float d = sdSegment(p, a, b, ra);\n    \n    vec3 col = d>0. ? vec3(.35) : vec3(.75,1.1,.3); // base color\n    col *= 1.-.7*exp(-5.*abs(d)); // shadow\n    col *= .8+.2*antialias(sin(128.*d)); // isolines\n    col = mix(col, vec3(1), antialias(abs(d)-.008)); // outline\n    \n    // distance circle\n    if (iMouse.z>0.) {\n        d = sdSegment(m, a, b, ra);\n        \n        col = mix(col, vec3(.8,0,1), antialias(abs(sdCircle(p-m, abs(d)))-.007));\n        col = mix(col, vec3(.8,0,1), antialias(sdCircle(p-m, .025)));\n    }\n            \n    // vignette\n    vec2 q = fragCoord/iResolution.xy;\n    col *= .5+.5*pow(16. * q.x*q.y*(1.-q.x)*(1.-q.y), .1);    \n    \n    // output\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}