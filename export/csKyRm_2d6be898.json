{"ver":"0.1","info":{"id":"csKyRm","date":"1696008452","viewed":376,"name":"pixel outlines","username":"UltimateBurrito","description":"sdf pixel art shader with outlines, dithering and palette limit.","likes":42,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","pixels","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec4 palette[]=vec4[](vec4(0.0235,0.0235,0.0314,1),vec4(0.0784,0.0627,0.0745,1),vec4(0.2314,0.0902,0.1451,1),vec4(0.451,0.0902,0.1765,1),vec4(0.7059,0.1255,0.1647,1),vec4(0.8745,0.2431,0.1373,1),vec4(0.9804,0.4157,0.0392,1),vec4(0.9765,0.6392,0.1059,1),vec4(1.0,0.8353,0.2549,1),vec4(1.0,0.9882,0.251,1),vec4(0.8392,0.949,0.3922,1),vec4(0.6118,0.8588,0.2627,1),vec4(0.349,0.7569,0.2078,1),vec4(0.0784,0.6275,0.1804,1),vec4(0.102,0.4784,0.2431,1),vec4(0.1412,0.3216,0.2314,1),vec4(0.0706,0.1255,0.1255,1),vec4(0.0784,0.2039,0.3922,1),vec4(0.1569,0.3608,0.7686,1),vec4(0.1412,0.6235,0.8706,1),vec4(0.1255,0.8392,0.7804,1),vec4(0.651,0.9882,0.8588,1),vec4(1.0,1.0,1.0,1),vec4(0.9961,0.9529,0.7529,1),vec4(0.9804,0.8392,0.7216,1),vec4(0.9608,0.6275,0.5922,1),vec4(0.9098,0.4157,0.451,1),vec4(0.7373,0.2902,0.6078,1),vec4(0.4745,0.2275,0.502,1),vec4(0.251,0.2,0.3255,1),vec4(0.1412,0.1333,0.2039,1),vec4(0.1333,0.1098,0.102,1),vec4(0.1961,0.1686,0.1569,1),vec4(0.4431,0.2549,0.2314,1),vec4(0.7333,0.4588,0.2784,1),vec4(0.8588,0.6431,0.3882,1),vec4(0.9569,0.8235,0.6118,1),vec4(0.8549,0.8784,0.9176,1),vec4(0.702,0.7255,0.8196,1),vec4(0.5451,0.5765,0.6863,1),vec4(0.4275,0.4588,0.5529,1),vec4(0.2902,0.3294,0.3843,1),vec4(0.2,0.2235,0.2549,1),vec4(0.2588,0.1412,0.2,1),vec4(0.3569,0.1922,0.2196,1),vec4(0.5569,0.3216,0.3216,1),vec4(0.7294,0.4588,0.4157,1),vec4(0.9137,0.7098,0.6392,1),vec4(0.8902,0.902,1.0,1),vec4(0.7255,0.749,0.9843,1),vec4(0.5176,0.6078,0.8941,1),vec4(0.3451,0.5529,0.7451,1),vec4(0.2784,0.4902,0.5216,1),vec4(0.1373,0.4039,0.3059,1),vec4(0.1961,0.5176,0.3922,1),vec4(0.3647,0.6863,0.5529,1),vec4(0.5725,0.8627,0.7294,1),vec4(0.8039,0.9686,0.8863,1),vec4(0.8941,0.8235,0.6667,1),vec4(0.7804,0.6902,0.5451,1),vec4(0.6275,0.5255,0.3843,1),vec4(0.4745,0.4039,0.3333,1),vec4(0.3529,0.3059,0.2667,1),vec4(0.2588,0.2235,0.2039,1));\nconst int paletteCount = 64;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ditherCoord = fract((fragCoord / float(pixelSize)) / 8.0);\n    vec4 inColor = texture(iChannel1,fragCoord/iResolution.xy);\n    vec4 nearestColor = vec4(0);\n    float nearestDistance = 5.0;\n    for(int i = 0; i < paletteCount; i++)\n    {\n        float dist = length(inColor - palette[i]);\n        if(dist < nearestDistance + texture(iChannel2,ditherCoord).x*0.03)\n        {\n            nearestDistance = dist;\n            nearestColor = palette[i];\n        }\n    }\n    fragColor = nearestColor;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 pixelateCoord(vec2 coord)\n{\n    vec2 c = floor(coord / float(pixelSize)) * float(pixelSize) / iResolution.xy;\n    c.y = 1.0 - c.y;\n    return c;\n}\n\nfloat SDFBox(vec3 p, Box b)\n{\n    mat3 basis = b.basis;\n    if(basis == customSpinRotation)\n    {\n        basis = yRotation(iTime*90.0) * xRotation(iTime*90.0);\n    }\n    vec3 d = abs((b.pos - p)*basis) - b.size*0.5;\n    return min(max(d.x, max(d.y,d.z)), 0.0) + length(max(d, 0.0));\n}\nfloat SDFScene(vec3 p)\n{\n    float dist = farPlane;\n    for(int i = 0; i<boxCount; i++)\n    {\n        dist = min(SDFBox(p,boxes[i]),dist);\n    }\n    return dist;\n}\nMaterial SceneMaterial(vec3 p)\n{\n    float nearestDist = farPlane;\n    Material m;\n    for(int i = 0; i<boxCount; i++)\n    {\n        float dist = SDFBox(p,boxes[i]);\n        if(dist < nearestDist){\n            nearestDist = dist;\n            m = materials[boxes[i].materialIndex];\n        }\n    }\n    return m;\n}\nBox SceneBox(vec3 p)\n{\n    float nearestDist = farPlane;\n    Box b;\n    for(int i = 0; i<boxCount; i++)\n    {\n        float dist = SDFBox(p,boxes[i]);\n        if(dist < nearestDist){\n            nearestDist = dist;\n            b = boxes[i];\n        }\n    }\n    return b;\n}\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\nfloat rayMarch(vec3 origin, vec3 direction, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < maxIterations; i++) {\n        float dist = SDFScene(origin + depth * direction);\n        if (dist < epsilon) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p)\n{\n    return normalize(vec3(\n        SDFScene(vec3(p.x + epsilon, p.y, p.z)) - SDFScene(vec3(p.x - epsilon, p.y, p.z)),\n        SDFScene(vec3(p.x, p.y + epsilon, p.z)) - SDFScene(vec3(p.x, p.y - epsilon, p.z)),\n        SDFScene(vec3(p.x, p.y, p.z  + epsilon)) - SDFScene(vec3(p.x, p.y, p.z - epsilon))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 posMod = vec3((iMouse.x/ iResolution.x)*40.0-20.0,0.0,(iMouse.y/ iResolution.y)*40.0-20.0);\n    vec3 cameraPos = vec3(0.0,-12.0,0.0) + posMod;\n    vec3 cameraLook = vec3(0,-2,0);\n    \n    vec2 screenPos = pixelateCoord(fragCoord);\n\n    mat4 cameraMatrix = viewMatrix(cameraPos,cameraLook,vec3(0,1,0));\n    vec3 rayOrigin = (cameraMatrix * vec4((screenPos - 0.5) * vec2(1,iResolution.y/iResolution.x) * orthographicSize*2.0,0,1)).xyz + cameraPos;\n    vec3 rayDirection = (cameraMatrix * vec4(0,0,-1,1)).xyz;\n    float depth = rayMarch(rayOrigin, rayDirection, nearPlane, farPlane);\n    vec3 position = rayOrigin + depth * rayDirection;\n    vec3 normal = estimateNormal(position);\n    if(depth < farPlane)\n    {\n        Material mat = SceneMaterial(position);\n        Box box = SceneBox(position);\n        vec3 albedo = mat.albedo;\n        float lambert = (dot(normal,lightDir) + 1.0)*0.5;\n        if(dot(normal,lightDir) > 0.0)\n        {\n            float shadowDepth = rayMarch(position, lightDir, nearPlane, farPlane);\n            if(shadowDepth < farPlane) lambert *= 0.5;\n        }\n        \n        vec3 color = albedo * (lambert * sunColor);\n        for(int i = 0; i < lightCount; i++) // iterate lights\n        {\n            float dist;\n            vec3 pos;\n            if(lights[i].linkedBoxIndex == -1)\n            {\n                dist = distance(position,lights[i].pos);\n                pos = lights[i].pos;\n            }\n            else\n            {\n                dist = SDFBox(position,boxes[lights[i].linkedBoxIndex]);\n                pos = normalize(boxes[lights[i].linkedBoxIndex].pos-position)*dist; //boxes[lights[i].linkedBoxIndex].pos;\n            }\n            float facing = (dot(normal,normalize(pos-position)) + 1.0)*0.5;\n            if(box == boxes[lights[i].linkedBoxIndex]) facing = 1.0;\n            color += clamp(1.0 - (dist / lights[i].dist),0.0,1.0) * lights[i].color * facing;\n        }\n        fragColor = vec4(color,depth);\n    }\n    else\n    {\n        vec3 color = vec3(0.5,0.5,0.5);\n        fragColor = vec4(color,depth);\n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float orthographicSize = 10.0;\nconst float nearPlane = 0.1;\nconst float farPlane = 100.0;\nconst int maxIterations = 128;\nconst int pixelSize = 3;\nconst float epsilon = 0.001;\nconst mat3 identity = mat3(\nvec3(1,0,0),\nvec3(0,1,0),\nvec3(0,0,1));\nconst mat3 customSpinRotation = mat3(\nvec3(100,0,0),\nvec3(0,0,0),\nvec3(0,0,0));\nconst float pi = 3.14159;\nconst float deg2Rad = pi / 180.0;\nmat3 xRotation(float theta)\n{\n\n    return mat3(\n    vec3(1,0,0),\n    vec3(0,cos(theta*deg2Rad),-sin(theta*deg2Rad)),\n    vec3(0,sin(theta*deg2Rad),cos(theta*deg2Rad))\n    );\n}\nmat3 yRotation(float theta)\n{\n\n    return mat3(\n    vec3(cos(theta*deg2Rad),0.0,-sin(theta*deg2Rad)),\n    vec3(0.0,1.0,0.0),\n    vec3(sin(theta*deg2Rad),0.0,cos(theta*deg2Rad))\n    );\n}\n\nstruct Box\n{\n    vec3 pos;\n    vec3 size;\n    int materialIndex;\n    mat3 basis;\n};\nstruct Material\n{\n    vec3 albedo;\n};\nstruct PointLight\n{\n    vec3 pos;\n    vec3 color;\n    float dist;\n    int linkedBoxIndex;\n};\n\nconst vec3 lightDir = normalize(vec3(3,-4,2));\nconst vec3 sunColor = vec3(1.0,1.0,0.9);\n\nconst Material materials[] = Material[](\n    Material(vec3(1,1,1)),\n    Material(vec3(0.5,1,0.5)),\n    Material(vec3(0.7,0.7,0.7))\n);\n\nconst Box boxes[] = Box[](\n    Box(vec3(0,1,0),vec3(50,1,50),1,identity), // floor\n    Box(vec3(0,0,0),vec3(10,1,10),2,identity), // platform\n    Box(vec3(0,0.5,0),vec3(12,1,12),2,identity),\n    Box(vec3(-5,-2,-5),vec3(2,5,2),2,identity), // pillars\n    Box(vec3(5,-2,-5),vec3(2,5,2),2,identity),\n    Box(vec3(-5,-2,5),vec3(2,5,2),2,identity),\n    Box(vec3(5,-2,5),vec3(2,5,2),2,identity),\n    Box(vec3(2,-2,2),vec3(1,1,1),0,customSpinRotation), // magic cube\n    Box(vec3(-2,-2,2),vec3(1,1,1),0,customSpinRotation),\n    Box(vec3(0,-2,-2),vec3(1,1,1),0,customSpinRotation)\n);\nconst int boxCount = 10;\n\nconst PointLight lights[] = PointLight[](\n    PointLight(vec3(0,-2,0),vec3(0.0,1.0,0.0),5.0,7),\n    PointLight(vec3(0,-2,0),vec3(0.0,0.5,1.0),5.0,8),\n    PointLight(vec3(0,-2,0),vec3(1.0,0.0,0.0),5.0,9)\n);\n\nconst int lightCount = 3;\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nfloat depthOutline(vec2 fragCoord)\n{\n    float centerDepth = texture(iChannel0,fragCoord / iResolution.xy).w;\n    float diff = 0.0;\n    \n    diff += (texture(iChannel0,(fragCoord + vec2(pixelSize,0)) / iResolution.xy).w-centerDepth);\n    diff += (texture(iChannel0,(fragCoord + vec2(-pixelSize,0)) / iResolution.xy).w-centerDepth);\n    diff += (texture(iChannel0,(fragCoord + vec2(0,pixelSize)) / iResolution.xy).w-centerDepth);\n    diff += (texture(iChannel0,(fragCoord + vec2(0,-pixelSize)) / iResolution.xy).w-centerDepth);\n    \n    return diff > 0.6 ? 1.0 : 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 inColor = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    float outline = depthOutline(fragCoord);\n    if(outline == 1.0)\n    {\n        fragColor = vec4(inColor*0.5,1.0);\n    }\n    else\n    {\n        fragColor = vec4(inColor,1.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}