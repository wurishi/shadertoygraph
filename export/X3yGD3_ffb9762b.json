{"ver":"0.1","info":{"id":"X3yGD3","date":"1719926461","viewed":123,"name":"gears world","username":"totan","description":" ","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv=fragCoord/iResolution.xy;\n    /*\n    fragColor=1.5*texture(iChannel0,uv,.5);\n    fragColor+=1.*texture(iChannel0,uv,2.5);\n    fragColor+=.75*texture(iChannel0,uv,4.5);\n    \n    fragColor.xyz/=3.25;\n    */\n    \n    fragColor=texture(iChannel0,uv);\n        \n    fragColor.w=1.;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define Res iResolution\n#define iMAX 100.0\n#define REACH 0.001\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define Mod(p,a) mod(p-a/2.,a)-a/2.\n#ifndef PI2\n#define PI2 6.28318530718\n#endif\n#define GEAR_W .27\n\nvec3 lightCol = vec3(1.1,1.,.9);\nvec3 ambCol   = vec3(.2,.6,1.)*.25;\nvec3 diffCol  = vec3(1.,.85,.7);\nvec3 lightDir = normalize(vec3(.12,.1,.12));\n\nstruct RAY{\n    vec3 p;\n    vec3 dir;\n    vec3 Ndir;\n    vec2 tex;\n    float obj;\n    float total_d;\n    vec3 tCol;\n    float i;\n};RAY ray;\n\nfloat hash(float n){return fract(sin(n)*432.123);}\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdBox2( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    float F= length(max(q.xy,0.0)) + min(max(q.x,q.y),0.0);\n    float G= length(max(q.yz,0.0)) + min(max(q.y,q.z),0.0);\n    float H= length(max(q.xz,0.0)) + min(max(q.x,q.z),0.0);\n    return min(min(F,G),H);\n    //return F;\n}\n//#define size 0.75\n//#define len 0.1\nfloat gear(vec3 p, int numTeeth, float size, float len, float angle){\n    \n    float lpxy=length(p.xy);\n    \n    float ang=atan(p.y,p.x);\n    float d=length(p+vec3(p.xy/lpxy,0)*0.1*sin(ang*float(numTeeth)+angle*size))-0.25-size;\n    d=max(d,abs(p.z)-GEAR_W*0.4);\n    d=max(d,size-len-lpxy);\n    return d;\n}\n#define cut 5.5\nfloat MAP(in vec3 q){\n    //q.zy*=rot(iTime*0.3);\n    float id=q.x;\n    id-=q.x=mod(q.x,cut)-cut*0.5;\n    q.z+=id*0.385;\n    q.x+=0.6;\n    float time = iTime*7.3 * (mod(id/3.5,4.)>2. ? -1.:1.);\n    q.z=mod(q.z,6.)-3.;\n    q.y=mod(q.y,4.)-2.;\n    \n    float d = gear(q    -vec3(0.0,0.0,0.0)    , 16, 0.75, 0.0, time);\n    d = min(d,gear(q    -vec3(2.0,0.0,0.0)    , 16, 0.75, 0.0, -time));\n    d = min(d,gear(q    -vec3(0.0,0.0,0.5)    , 32, 1.5, 0.4, time));\n    d = min(d,gear((q-vec3(-1.85,0.0,1.55)).yzx, 16, 0.75, 0.0, time*-2.));\n    //d = min(d,gear((q-vec3(-2.,0.0,1.55)).yzx, 8, 0.375, 0.0, time*-2.));\n    d = min(d,gear((q-vec3(3.15,0.0,-0.65)).yzx, 8, 0.375, 0.0, time*2.));\n    return d*0.6;\n}\nvec3 getNormal(float d){\n    //vec3 p=ray.p;\n    const vec2 e = vec2(0.001,0.0);\n    #if 0\n    return normalize(\n        vec3(MAP(ray.p + e.xyy) - MAP(ray.p - e.xyy),\n             MAP(ray.p + e.yxy) - MAP(ray.p - e.yxy),\n             MAP(ray.p + e.yyx) - MAP(ray.p - e.yyx)));\n    #else   \n    return normalize(\n        vec3(MAP(ray.p + e.xyy),\n             MAP(ray.p + e.yxy),\n             MAP(ray.p + e.yyx) )-MAP(ray.p));\n    #endif\n            \n}\nvec3 getReflect(vec3 dir,vec3 n){\n    //vec3 n = getNormal(d);\n    return reflect(dir,n);\n}\nbool RM(){\n    vec3 dir = ray.dir;\n    ray.i = 0.0;\n    for(float t_d=0.0,d;ray.i++<iMAX;){\n        t_d += d = MAP(ray.p);\n        ray.p+=dir*d;\n        if(d<REACH){\n            ray.Ndir=getNormal(d);\n            if(ray.obj<5.0){\n                ray.total_d=t_d;\n                return true;\n            }\n            dir = getReflect(dir,ray.Ndir);\n        }\n    }\n    return false;\n}\n\n\nvec4 myenv(vec3 pos, vec3 dir, float period){    \n    return texture(iChannel0,dir.xzy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-Res.xy*0.5)/Res.y;\n    vec3 dir=normalize(vec3(uv,0.7)),\n         pos=vec3(-2.5,1.5-iTime,-5.);\n    dir.yz*=rot(-2.1);\n    dir.xz*=rot(-.7);\n    ray.dir=dir;\n    ray.p=pos;\n    ray.obj=1.0;\n    ray.tCol=vec3(0.0);\n    ray.total_d=0.0;\n    //do raymarch\n    RM();\n    \n    //get color\n    vec3 bg=mix(ambCol,lightCol,clamp(dot(ray.p-pos,lightDir)*.2,-.5,1.5));\n    \n    // reflection\n    vec3 n=getNormal(1.);\n    vec3 R=normalize(reflect(ray.p-pos,n));\n    vec4 refl=myenv(ray.p,R,1.);\n    \n    vec3 col=vec3(1);\n    \n    // ambient occlusion\n    float ao=1.;\n    ao=min(ao,MAP(ray.p+n*.08)/.08);\n    ao=min(ao,MAP(ray.p+n*.04)/.04);\n    ao=min(ao,MAP(ray.p+n*.02)/.02);\n    ao=ao*.8+.2;\n    //\n    \n    \n    float diff=clamp(dot(n,lightDir),0.,1.);\n    \n    // mix diffuse, ambient, ao\n    col *= diffCol-.1+.1*(n*.5+.5);\n    col *= ao;\n    col *= lightCol*diff*(1.-ambCol)+ambCol;\n    \n    \n    col+=.2*refl.zyx;\n    \n    // depth fog\n    col = mix(bg,col,exp(-length(ray.p-pos)/32.));\n    fragColor.xyz=col*2.;\n        \n    fragColor.w=1.;\n}","name":"Buffer A","description":"","type":"buffer"}]}