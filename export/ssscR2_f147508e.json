{"ver":"0.1","info":{"id":"ssscR2","date":"1642409769","viewed":111,"name":"Subdivision flow","username":"sinoguro","description":"First post on shadertoy.\nAn object being divided using ifs.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// reference https://qiita.com/kaneta1992/items/21149c78159bd27e0860#polar-mod%E3%81%AB%E3%82%88%E3%82%8B%E8%A4%87%E8%A3%BD\n\n\nprecision highp float;\n\nconst float PI = 3.14159265;\nconst float PI2 = PI*2.0;\nconst float angle = 60.0;\nconst float fov = angle * 0.5 * PI / 180.0;\nconst float EPS = 0.001;\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat box(vec3 p, float s) {\n\tp = abs(p) - s;\n\treturn max(max(p.x, p.y), p.z);\n}\n\nvec2 pmod(vec2 p, float r) {\n\tfloat a = PI/r-atan(p.x, p.y);\n\tfloat n = PI2/r;\n\ta = floor(a/n)*n;\n\treturn p*rot(a);\n}\n\nmat3 rot3z(float a) {\n    float c = cos(a), s = sin(a);\n    return mat3(c,-s,0.,s,c,0.,0.,0.,1.);\n}\n\nfloat fbm(float x) { return sin(x) + 0.5 * sin(2. * x) + 0.25 * sin(4. * x); }\n\nfloat map(vec3 p){\n    p.y  += sin(p.z*0.1)*5.0;\n    vec3 q = p;\n    const int iterations = 9;\n    q.z = mod(q.z-20.0, 40.0)-20.0;\n    q.yx = pmod(q.xy, 24.0)-2.0;\n    q.xz = pmod(q.xz, 30.0);\n\n\n    q.z = mod(q.z-5.0 ,10.0) - 5.0;\n    q.x = abs(q.x) - 3.0;\n    q.y -= 4.;\n    \n    // ifs\n    for(int i=1; i<iterations; i++) {\n        q = abs(q) - vec3(1.0+sin(iTime)*0.3, 2.0+sin(iTime)*0.2, 1.0 + sin(iTime*float(i) - p.z*0.15 - p.y*0.3)*0.5);\n        q = abs(q) - vec3(0.0, cos(iTime*0.2)*0.1,0.7+sin(iTime)*0.3);\n        q.xz *= rot(float(i)*PI*0.75);\n        q.z += 0.3 / dot(q, q);\n    }\n    return box(q, sin(iTime)* 0.1 + 0.9);\n}\n\nvec3 getNormal(vec3 p){\n    float d = 0.001;\n    return normalize(vec3(\n        map(p + vec3(  d, 0.0, 0.0)) - map(p + vec3( -d, 0.0, 0.0)),\n        map(p + vec3(0.0,   d, 0.0)) - map(p + vec3(0.0,  -d, 0.0)),\n        map(p + vec3(0.0, 0.0,   d)) - map(p + vec3(0.0, 0.0,  -d))\n    ));\n}\n\nvec3 hsv(float h, float s, float v) {\n    return ((clamp(abs(fract(h+vec3(0,2,1)/3.)*6.-3.)-1.,0.,1.)-1.)*s+1.)*v;\n}\n\nvec3 onRep(vec3 p, float interval) {\n  return mod(p, interval) - interval * 0.5;\n}\n\nfloat getShadow( vec3 ro, vec3 rd ) {\n\n    float h = 0.0;\n    float c = 0.0;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n\n    for ( float t = 0.0; t < 50.0; t++ ) {\n\n        h = map( ro + rd * c );\n\n        if ( h < 0.001 ) return shadowCoef;\n\n        r = min( r, h * 16.0 / c );\n        c += h;\n\n    }\n\n    return 1.0 - shadowCoef + r * shadowCoef;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float time3 = iTime * 30.0;\n    vec3 cPos  = vec3( 0.0, 2.5 + sin(iTime*2.0), time3 );\n    vec3 cDir  = normalize( vec3( 0.0, 0.4*sin(iTime)*cos(iTime*0.3)+ 0.01 * fbm(iTime * PI2 * 0.2), 1.0));\n    vec3 cSide = cross( cDir, vec3(0.0, 1.0 ,-0.0 ) );\n    vec3 cUp   = cross( cSide, cDir );\n    float targetDepth = 1.3;\n    vec3 ray = normalize( cSide * p.x + cUp * p.y + cDir * targetDepth ) * rot3z(iTime*0.1);\n        \n    vec3 lightDir = vec3(1.0,1.0,-2.0);\n\n    float distance = 00.0;\n    float rLen = 0.0;\n    vec3  rPos = cPos;\n    float ac = 0.0;\n    for(int i = 0; i < 128; i++){\n        rPos = cPos + ray * rLen;\n        distance = map(rPos);\n        float d2 = max(abs(distance), 0.04 + 0.3*(exp(3.0*sin(iTime))/ exp(3.0)));\n        ac += exp(-30. * d2) + exp(-5. *distance);\n        rLen += distance;\n        \n        if (abs(rLen) < EPS) break;\n    }\n    \n    vec3 color;\n    if(abs(distance) < 0.001){\n        vec3 normal = getNormal(rPos);\n        float diff = dot(normal, normalize(vec3(1, 1, 1)));\n        float specular = pow(clamp(dot(reflect(normalize(vec3(1, 1, 1)), normal), ray), 0.0,1.0), 10.0);\n        color =  vec3(1.0) * mix(diff, specular, 0.8);\n    }else{\n        color = vec3(0.0);\n    }\n    color +=  hsv(rPos.z*0.003, 1.0, 1.0)* ac*0.008;\n    color = color + 0.01 * rLen;\n    fragColor = vec4(color, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}