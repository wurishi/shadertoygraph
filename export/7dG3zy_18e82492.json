{"ver":"0.1","info":{"id":"7dG3zy","date":"1631734213","viewed":212,"name":"The Expanse Ring Gate","username":"wouterdek","description":"Reproduction of the ring gate shot as seen in the credits of The Expanse season 4. An experiment in procedural textures and spectral refraction.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["space","wormhole","theexpanse","ringgate","warpgate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\nconst vec3 BACKGROUND_COLOR_1 = vec3(0., .247, .286);\nconst vec3 BACKGROUND_COLOR_2 = vec3(0., .014, .045);\n\nconst vec3 RING_COLOR_1 = vec3(.000, .051, .094);\nconst vec3 RING_COLOR_2 = vec3(.094, .447, .604);\n\nconst float RING_MIN_SIZE = 0.39;\nconst float RING_MAX_SIZE = .8;\nconst float RING_MIN_EDGE_SIZE = 0.014;\nconst float ZOOM_SPEED = 1./50.;\n\nconst float LENS_HEIGHT_MULTIPLIER = 0.05;\nconst vec3 LENS_IOR = vec3(2.286543164, 2.420857286, 2.435478974);\nconst vec3 LENS_TINT = vec3(1.00, 0.98, 0.94);\n\nconst float RING_HALO_INTENSITY = .005;\nconst vec3 RING_HALO_COLOR = vec3(0., .25, .3);\nconst vec3 RING_HIGHLIGHT_COLOR = vec3(0, .145, .212);\n\nfloat noise2(vec2 uv)\n{\n    float v = dot(uv, vec2(101.9364, 96.45418));\n    return fract(sin(v)*100000.0);\n}\n\nfloat rand(float x)\n{\n    return fract(sin(x)*10000.0);\n}\n\nfloat valueNoise1(float x)\n{\n    float i = floor(x);\n    float f = fract(x);\n    \n    float bl = rand(i + 0.);\n    float br = rand(i + 1.);\n    \n    return mix(bl, br, f);\n}\n\nfloat valueNoise(vec2 x)\n{\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n    \n    float bl = noise2(i + vec2(0., 0.));\n    float br = noise2(i + vec2(1., 0.));\n    float tl = noise2(i + vec2(0., 1.));\n    float tr = noise2(i + vec2(1., 1.));\n    \n    return mix(bl, br, f.x) + \n            (tl - bl) * f.y * (1. - f.x) + \n            (tr - br) * f.y * f.x;\n}\n\n#define FBM_OCTAVES 3\nfloat fbm(vec2 x)\n{\n    float v = 0.;\n    float a = 0.5;\n\n    float am = 0.5;\n    float fm = 2.0;\n    \n    for(int i = 0; i < FBM_OCTAVES; ++i)\n    {\n        v += a * valueNoise(x);\n        x *= fm;\n        a *= am;\n    }\n    \n    return v;\n}\n\nfloat gradientNoise(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    float bl = noise2(i + vec2(0, 0));\n    float br = noise2(i + vec2(1, 0));\n    float tl = noise2(i + vec2(0, 1));\n    float tr = noise2(i + vec2(1, 1));\n    \n    return mix(bl, br, f.x) +\n        (tl - bl) * (1. - f.x) * f.y + \n        (tr - br) * f.x * f.y;\n}\n\nfloat voronoi(vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float d = 64.;\n    for(int y = -1; y <= 1; ++y)\n    {\n        for(int x = -1; x <= 1; ++x)\n        {\n            vec2 b = vec2(x, y);\n            vec2 c = b+noise2(i+b)-f;\n            d = min(d, dot(c, c));\n        }\n    }\n    return sqrt(d);\n}\n\nfloat smoothVoronoi(vec2 uv, float smoothing)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float d = 0.;\n    for(int y = -1; y <= 1; ++y)\n    {\n        for(int x = -1; x <= 1; ++x)\n        {\n            vec2 b = vec2(x, y);\n            vec2 c = b+noise2(i+b)-f;\n            float l = length(c);\n            d += exp(-smoothing * l);\n        }\n    }\n    return -1./smoothing*log(d);\n}\n\nfloat powerRemap(float x, float head, float tail)\n{\n    return pow(1.0 - pow(x, head), tail);\n}\n\nfloat speckles(vec2 uv, float maxSize, float sizeVariation)\n{\n    float intensity = 16./maxSize + pow(smoothstep(1., 0.,  cos(sqrt(uv.x)*24.0) * sin(sqrt(uv.y)*15.0) * cos(uv.x*uv.y*64.0)), .9)*sizeVariation;\n    return powerRemap(voronoi(uv*50.), 1.5, intensity);\n}\n\nvec3 grid(vec2 uv)\n{\n    uv = 80. * uv;\n    return vec3(sin(uv.x), sin(uv.y), 0);\n}\n\nvec3 calcRefract(vec3 vIn, vec3 n, float iorA, float iorB, out float fresnel)\n{\n    float iorRel = iorA/iorB;\n\n    vIn *= -1.;\n    float cosI = dot(vIn, n);\n    float sinI = sqrt(1. - cosI * cosI);\n    float sinT = sinI * iorRel;\n    float cosT = sqrt(1. - sinT * sinT);\n    \n    float rPar = 0.;\n    {\n        float a = iorB * cosI;\n        float b = iorA * cosT;\n        rPar = (a - b) / (a + b);\n    }\n    float rPer = 0.;\n    {\n        float a = iorA * cosI;\n        float b = iorB * cosT;\n        rPer = (a - b) / (a + b);\n    }\n    fresnel = 0.5 * (rPar * rPar + rPer * rPer);\n    \n    return iorRel * -vIn + (iorRel * cosI - cosT) * n;\n}\n\nfloat lensHeight(vec2 uv)\n{\n    float v = length(uv);\n    float isNotCenter = (v/(v+0.05));\n    float a = LENS_HEIGHT_MULTIPLIER * (1.0 + sin(v*59.0)) * isNotCenter;\n    float b = LENS_HEIGHT_MULTIPLIER * (1.0 + sin(v*59.0*cos(0.075*iTime))) * isNotCenter;\n    return mix(b, a, min(1., v/0.3));\n}\n\n#define RAYMARCH_ITER 500\n#define RAYMARCH_STEP 0.001\n\nvec3 lensSurface(vec2 uv, float scale, out vec3 dIn, out vec3 normal)\n{\n    const float lensZPos = 1.0;\n    \n    vec3 p = vec3(0.0,0.0, 0);\n    vec3 d = normalize(vec3(uv.x, uv.y, 1.0) - p);\n    p += d * .7;\n    float tDepth = 0.;\n    \n    for(int i = 0; i < RAYMARCH_ITER; ++i)\n    {\n        p += d * RAYMARCH_STEP;\n        tDepth = lensZPos - lensHeight(p.xy / scale);\n        if(tDepth < p.z)\n        {\n            break;\n        }\n    }\n    \n    vec3 v1l = p + vec3(-.0001, 0, 0);\n    v1l.z = lensZPos - lensHeight(v1l.xy / scale);\n    vec3 v1r = p + vec3(.0001, 0, 0);\n    v1r.z = lensZPos - lensHeight(v1r.xy / scale);\n    vec3 v2t = p + vec3(0, -.0001, 0);\n    v2t.z = lensZPos - lensHeight(v2t.xy / scale);\n    vec3 v2b = p + vec3(0, .0001, 0);\n    v2b.z = lensZPos - lensHeight(v2b.xy / scale);\n    \n    normal = normalize(cross(v1r - v1l, v2t - v2b));\n    dIn = d;\n    return p;\n}\n\nvec2 lens(vec3 p, vec3 dIn, vec3 n, float ior, out float fresnel)\n{\n    const float bgPlaneZPos = 1.0;\n\n    vec3 refractDir = calcRefract(dIn, n, 1.0, ior, fresnel);\n    vec3 reflectDir = reflect(dIn, n);\n    \n    for(int i = 0; i < RAYMARCH_ITER; ++i)\n    {\n        p += refractDir * RAYMARCH_STEP;\n        if(bgPlaneZPos < p.z)\n        {\n            break;\n        }\n    }\n    return p.xy;\n}\n\nvec3 background(vec2 uv)\n{\n    float mixVal = smoothVoronoi(uv*2., 16.);\n    vec3 col = mix(BACKGROUND_COLOR_1, BACKGROUND_COLOR_2, mixVal);\n    \n    float stringy1 = pow(voronoi(uv*4.)*.6, 3.);\n    float stringy2 = pow(voronoi((uv+vec2(3,3))*5.)*.75, 3.);\n    float stringy = mix(stringy1, stringy2, 0.8 + .5*sin(iTime*0.1));\n    col += BACKGROUND_COLOR_1 * stringy;\n\n    const float scanFreq = 1.8;\n    const float scanIntensity = 0.05;\n    float scanVal = 0.5 * (1.0 + sin(uv.y*iResolution.y*scanFreq));\n    scanVal = scanIntensity*(scanVal-1.0)+1.0;\n    col *= scanVal;\n\n    return col;\n}\n\nfloat remapEdgeWrap(float x)\n{\n    x *= 200.;\n    return x+(valueNoise1(x*0.1)*PI*2.8);\n}\n\nvec3 ringEdge(vec2 uv, vec2 edgeSpaceUV, vec3 inCol, vec3 outCol, float aspect)\n{\n    float edgePLateral = edgeSpaceUV.x;\n    float edgePTransverse = edgeSpaceUV.y;\n\n    float wrap = max(0., sin(remapEdgeWrap(edgePLateral) + edgePTransverse*6.)); \n    wrap = wrap;\n    \n    float q = sin(edgePTransverse*PI*.8);\n    q *= q * q * q * q;\n    q = q * q * q * q;\n    q = q * q;\n    float r = max(0., dot(normalize(vec3(uv, 1.)), normalize(vec3(-10,-30,0.))))*.3*(0.5+wrap*.5);\n    \n    \n    float colMixCoef = fbm(uv*aspect*200.);\n    colMixCoef *= 1. - wrap*.33;\n    float v = gradientNoise(uv*5.);\n    colMixCoef *= 0.5 + 1.5 * v * v;\n    \n    vec3 c = mix(RING_COLOR_1, RING_COLOR_2, colMixCoef);\n    c = mix(mix(inCol, outCol*.8, edgePTransverse), c, sin(edgePTransverse*PI));\n    c = mix(c, RING_HIGHLIGHT_COLOR * 10., q*r);\n    \n    float speckFact = 1.0 + 0.5*sin(iTime*.5 * edgeSpaceUV.x);\n    c += pow(speckles(uv*1.0, 10., 30.), 0.2) * max(-.2, sin(edgeSpaceUV.x*9.0)) * RING_COLOR_2 * sin(edgePTransverse*PI) * speckFact;\n    c += pow(speckles(uv*1.5, .1, 100.), 0.2) * max(-.2, sin(edgeSpaceUV.x*8.0)) * RING_COLOR_2 * sin(edgePTransverse*PI) * speckFact;\n    \n    float k = max(0., dot(normalize(vec3(uv, 1.)), normalize(vec3(10,30,0.)))) * cos(edgePTransverse);\n    k = pow(k, 1.2);\n    c = mix(c, inCol, min(0.8, k));\n\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float aspect = iResolution.x/iResolution.y;\n    vec2 ringUV = uv;\n    ringUV.x *= aspect;\n    vec2 ringCenteredUV = ringUV - vec2(0.5*aspect, 0.5);\n\n    const float ringTimeFac = (PI*0.5) * ZOOM_SPEED;\n    float ringSize = RING_MIN_SIZE + (RING_MAX_SIZE-RING_MIN_SIZE)*(1.0 - 0.5*(1.+cos(iTime*ringTimeFac)));\n    float ringScaleFactor = ringSize / RING_MIN_SIZE;\n    float ringEdgeSize = RING_MIN_EDGE_SIZE * ringScaleFactor;\n    float centerDist = length(ringCenteredUV);\n    \n    vec3 bg = background(ringCenteredUV)*.4;\n\n    vec3 col = vec3(0,0,0);\n    \n    if(centerDist < ringSize)\n    {\n        float fresnel;\n        vec3 normal;\n        vec3 dIn;\n        vec3 p = lensSurface(ringCenteredUV, ringScaleFactor, dIn, normal);\n\n        vec2 fgUvR = lens(p, dIn, normal, LENS_IOR.r, fresnel);\n        vec2 fgUvG = lens(p, dIn, normal, LENS_IOR.g, fresnel);\n        vec2 fgUvB = lens(p, dIn, normal, LENS_IOR.b, fresnel);\n        vec3 fg = vec3(\n            pow(voronoi((fgUvR+vec2(1,1))*180.), 8.)*voronoi((fgUvR+vec2(3,3))*10.),\n            pow(voronoi((fgUvG+vec2(1,1))*180.), 8.)*voronoi((fgUvG+vec2(3,3))*10.),\n            pow(voronoi((fgUvB+vec2(1,1))*180.), 8.)*voronoi((fgUvB+vec2(3,3))*10.)\n        );\n        fg *= LENS_TINT;\n        fg *= (1. + sin(100.*voronoi(fgUvR*10.) + iTime))*.5;\n        fg *= 1. - fresnel;\n        fg += fresnel * bg * pow(centerDist / ringSize, 8.0);\n        col = fg;\n    }\n    else if(centerDist < ringSize + ringEdgeSize)\n    {\n        float edgePLateral = atan(ringCenteredUV.y, ringCenteredUV.x);\n        float edgePTransverse = (centerDist - ringSize) / ringEdgeSize;\n        col = ringEdge(ringCenteredUV / ringScaleFactor, vec2(edgePLateral, edgePTransverse), vec3(0,0,0), bg, aspect);\n    }\n    else\n    {\n        col = bg;\n        col += ((ringSize + ringEdgeSize)/pow(centerDist, 5.0)) * RING_HALO_INTENSITY * RING_HALO_COLOR;\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}