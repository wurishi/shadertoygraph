{"ver":"0.1","info":{"id":"lXfyzB","date":"1728103246","viewed":71,"name":"Polygon!","username":"Nieb","description":"Click & drag points to move them.\nClick on lines to insert new points.\nNow with triangulation!","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["polygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//######################################################################################################################\n//######################################################################################################################\nint  GetPointCount()     { return int( round(texelFetch(iChannel0, ivec2(256,4), 0).r * 255.0) ); }\nvec2 GetPointPos(int iP) { return  DecodePnt(texelFetch(iChannel0, ivec2( iP,4), 0))            ; }\nvec4 GetTriangle(int iT) { return  DecodeTri(texelFetch(iChannel0, ivec2( iT,6), 0))            ; }\n\n//######################################################################################################################\n//######################################################################################################################\nvec3 cPnt = vec3(0.87, 0.87, 0.00);\nvec3 cLin = vec3(0.00, 0.79, 0.79);\nvec3 cTri = vec3(0.45, 0.35, 0.40);\n\nvec2 DrawRds; //  X: Point    Y: Line\n\nvec3 DrawPoint(vec2 Pnt, vec3 Clr) {\n    float V = smoothstep(DrawRds.x, DrawRds.x - DrawRds.y, length(ScrnPos - Pnt));\n    return Clr * V;\n}\n\nvec3 DrawLine(vec2 A, vec2 B, vec3 Clr) {\n    vec2 dAP = ScrnPos - A;\n    vec2 dAB = B - A;\n\n    float V = abs(length( dAP - dAB * clamp( dot(dAB,dAP)/dot(dAB,dAB), 0.0, 1.0 ) ));\n\n    V = smoothstep(DrawRds.y, 0.0, V);\n\n    return Clr * V;\n}\n\n//######################################################################################################################\n//######################################################################################################################\nvoid mainImage(out vec4 FragColor, in vec2 FragCoord) {\n    ViewAspect = iResolution.x/iResolution.y;\n    ViewRatio  = ViewSizeY/iResolution.y;\n    ViewSizeX  = ViewSizeY * ViewAspect;\n    ScrnPos = (FragCoord.xy/iResolution.xy - 0.5) * vec2(ViewSizeX, ViewSizeY); //  Center = (0,0)\n    DrawRds = vec2(5.6, 2.0) * ViewRatio;\n\n\n    vec3 cPolygon = vec3(0);\n    int Pnt_Count = GetPointCount();\n    for (int iP = 0; iP < Pnt_Count; ++iP) {\n        vec2 PntA = GetPointPos(iP);\n        vec2 PntB;\n        if (iP+1 < Pnt_Count)\n            PntB = GetPointPos(iP+1);\n        else\n            PntB = GetPointPos(0);\n\n        cPolygon = max(cPolygon, DrawLine(PntA, PntB, cLin));\n        cPolygon = max(cPolygon, DrawPoint(PntA, cPnt));\n    }\n\n\n    vec3 cTriangulation = vec3(0);\n    #if 1\n        int Tri_Count = Pnt_Count-2;\n        for (int iT = 0; iT < Tri_Count; ++iT) {\n            vec4 Tri = GetTriangle(iT);\n\n            vec2 PntA = GetPointPos(int(Tri.r));\n            vec2 PntB = GetPointPos(int(Tri.g));\n            vec2 PntC = GetPointPos(int(Tri.b));\n\n            cTriangulation = max(cTriangulation, DrawLine( PntA, PntB, cTri ));\n            cTriangulation = max(cTriangulation, DrawLine( PntB, PntC, cTri ));\n            cTriangulation = max(cTriangulation, DrawLine( PntC, PntA, cTri ));\n\n            cTriangulation = max(cTriangulation, DrawPoint( avg(PntA, PntB, PntC), cTri*0.5 ));\n        }\n    #endif\n\n\n    vec3 cGrid = vec3(0);\n    #if 1\n        cGrid.x = mod(ScrnPos.x+16.0, 32.0)-16.0;\n        cGrid.y = mod(ScrnPos.y+16.0, 32.0)-16.0;\n        cGrid.z = 0.14 * max(smoothstep(DrawRds.y, 0.0, abs(cGrid.x  )), smoothstep(DrawRds.y, 0.0, abs(cGrid.y  )));\n        cGrid.x = 0.27 * max(smoothstep(DrawRds.y, 0.0, abs(ScrnPos.x)), smoothstep(DrawRds.y, 0.0, abs(ScrnPos.y)));\n        cGrid = vec3(max(cGrid.x, cGrid.z));\n    #endif\n\n\n    vec3 cBufferA = vec3(0);\n    #if 1\n        vec2 FC = FragCoord * 0.125;\n        if (FC.y >= 6.0 || FC.x >= 256.0)\n            cBufferA = texture(iChannel0, FC/iResolution.xy).rgb * 4.0;\n        else\n            cBufferA = texture(iChannel0, FC/iResolution.xy).rgb * 0.5;\n    #endif\n\n\n    FragColor = vec4( max(max(max(cPolygon, cTriangulation), cBufferA), cGrid), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//######################################################################################################################\n//######################################################################################################################\nconst float ViewSizeY =  256.0;\nconst float ViewMinY  = -128.0;\nconst float ViewMaxY  =  128.0;\n\nfloat ViewAspect = 0.0;\nfloat ViewRatio  = 0.0;\nfloat ViewSizeX  = 0.0;\n\nvec2 ScrnPos = vec2(0);\n\n//######################################################################################################################\n//######################################################################################################################\nvec4 EncodePnt(vec2 V) {\n    V += 2048.0;\n    return vec4(\n        (V.x < 0.0) ? 0.0 : mod(V.x, 256.0)/255.0,\n        (V.y < 0.0) ? 0.0 : mod(V.y, 256.0)/255.0,\n        (V.x < 0.0) ? 0.0 : (V.x >= 256.0) ? floor(V.x / 256.0)/255.0 : 0.0,\n        (V.y < 0.0) ? 0.0 : (V.y >= 256.0) ? floor(V.y / 256.0)/255.0 : 0.0\n    );\n}\n\nvec2 DecodePnt(vec4 V) {\n    return vec2(\n        (V.r*255.0 + V.b*255.0*256.0) - 2048.0,\n        (V.g*255.0 + V.a*255.0*256.0) - 2048.0\n    );\n}\n\n//======================================================================================================================\nvec4 EncodeTri(int A, int B, int C) {\n    return vec4(\n        float(A) / 255.0,\n        float(B) / 255.0,\n        float(C) / 255.0,\n        1.0\n    );\n}\n\nvec4 DecodeTri(vec4 V) {\n    return vec4(\n        round(V.x * 255.0),\n        round(V.y * 255.0),\n        round(V.z * 255.0),\n        0.0\n    );\n}\n\n//######################################################################################################################\n//######################################################################################################################\nvec2 avg(vec2 A, vec2 B, vec2 C) {\n    return vec2((A.x+B.x+C.x) * 0.33333333,  (A.y+B.y+C.y) * 0.33333333);\n}\n\n//======================================================================================================================\nfloat cross2(vec2 A, vec2 B) {\n    return (A.x*B.y - A.y*B.x);\n}\n\n//######################################################################################################################\n//######################################################################################################################\nbool PointVsCircle(vec2 P, vec2 Cp, float Cr) {\n    vec2 d = P - Cp;\n    return (d.x*d.x + d.y*d.y < Cr*Cr);\n}\n\n//======================================================================================================================\nbool PointVsLine(vec2 P, vec2 La, vec2 Lb, float Tolerance) {\n    vec2 dAP =  P - La;\n    vec2 dAB = Lb - La;\n\n    float DotPB           = (dAP.x * dAB.x) + (dAP.y * dAB.y);\n    float Line_LengthSqrd = (dAB.x * dAB.x) + (dAB.y * dAB.y);\n\n    float Scaler = DotPB / Line_LengthSqrd;\n\n    if (Scaler < 0.0 || Scaler >= 1.0) return false;\n\n    vec2 dPP = dAP - (dAB * Scaler);\n\n    return (dPP.x*dPP.x + dPP.y*dPP.y < Tolerance*Tolerance);\n}\n\n//======================================================================================================================\nbool PointVsTriangle(vec2 P, vec2 Ta, vec2 Tb, vec2 Tc) {\n    vec2 dPA = Ta - P;\n    vec2 dPB = Tb - P;\n    vec2 dPC = Tc - P;\n    return ( dPA.x*dPC.y <= dPC.x*dPA.y\n        &&   dPB.x*dPA.y <= dPA.x*dPB.y\n        &&   dPC.x*dPB.y <= dPB.x*dPC.y );\n}\n\n//######################################################################################################################\n//######################################################################################################################\nbool Delaunay(vec2 P, vec2 Ta, vec2 Tb, vec2 Tc) {\n    vec2 dAB = Tb - Ta;\n\n    vec2 dBC = Tc - Tb;\n\n    float Determinant = 2.0 * (dAB.x*dBC.y - dAB.y*dBC.x);\n\n    vec2 d;\n    vec2 CCp; //  CircumCircle's center position.\n    if (abs(Determinant) < 0.000001) {\n        vec2 Min = min(min(Ta, Tb), Tc);\n        vec2 Max = max(max(Ta, Tb), Tc);\n        CCp = (Min + Max) * 0.5;\n        d = CCp - Min;\n\n    } else {\n        vec2 dAC = Tc - Ta;\n\n        float AB_AB = dAB.x*(Ta.x + Tb.x) + dAB.y*(Ta.y + Tb.y);\n        float AC_AC = dAC.x*(Ta.x + Tc.x) + dAC.y*(Ta.y + Tc.y);\n\n        CCp.x = (dAC.y*AB_AB - dAB.y*AC_AC) / Determinant;\n        CCp.y = (dAB.x*AC_AC - dAC.x*AB_AB) / Determinant;\n\n        d = CCp - Ta;\n    }\n\n    float CC_RdsSqrd = d.x*d.x + d.y*d.y;\n\n    d.x = CCp.x - P.x;\n    d.y = CCp.y - P.y;\n\n    return ((d.x*d.x + d.y*d.y) < CC_RdsSqrd);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//######################################################################################################################\n//######################################################################################################################\n#define PNT_MAX 256\n#define TRI_MAX 254\n\n//======================================================================================================================\n#define INITIALIZE iFrame <= 1\n\n#define UPDATE_INPUT_PRESSED        FragCoord.y == 0.5\n#define UPDATE_INPUT_RELEASED       FragCoord.y == 1.5\n#define UPDATE_INPUT_STATE          FragCoord.y == 2.5\n\n#define UPDATE_MOUSE_CLICK          FragCoord.x == 0.5\n#define UPDATE_KEY_xxx              FragCoord.x == 1.5\n\n#define UPDATE_ACTION               FragCoord.y == 3.5 && FragCoord.x == 0.5\n#define UPDATE_TRIANGULATION_STEP   FragCoord.y == 3.5 && FragCoord.x == 1.5\n\n#define UPDATE_POLYGON              FragCoord.y == 4.5 && FragCoord.x <  256.0\n#define UPDATE_PNT_COUNT            FragCoord.y == 4.5 && FragCoord.x == 256.5\n#define UPDATE_POLYCOPY             FragCoord.y == 5.5 && FragCoord.x <  256.0\n\n#define UPDATE_TRIANGULATION        FragCoord.y == 6.5 && FragCoord.x <  254.0\n#define OPTIMIZE_TRIANGULATION      FragCoord.y == 7.5 && FragCoord.x <  254.0\n\n//######################################################################################################################\n//######################################################################################################################\nbool GetMousePressed()  { return texelFetch(iChannel0, ivec2(0,0), 0).r > 0.5; }\nbool GetMouseReleased() { return texelFetch(iChannel0, ivec2(0,1), 0).r > 0.5; }\nbool GetMouseState()    { return texelFetch(iChannel0, ivec2(0,2), 0).r > 0.5; }\nvec2 GetMousePos() {\n    ViewAspect = iResolution.x/iResolution.y;\n    ViewSizeX  = ViewSizeY * ViewAspect;\n    return (iMouse.xy/iResolution.xy - 0.5) * vec2(ViewSizeX, ViewSizeY);\n}\n\n//======================================================================================================================\nvec4 GetAction()            { return texelFetch(iChannel0, ivec2(0,3), 0)           ; }\nbool GetActionTaken()       { return texelFetch(iChannel0, ivec2(0,3), 0) != vec4(0); }\nbool GetActionTakenInsert() { return texelFetch(iChannel0, ivec2(0,3), 0).g > 0.5   ; }\n\n//======================================================================================================================\nvec4 GetPointRaw(int iP)      { return            texelFetch(iChannel0, ivec2( iP,4), 0)             ; }\nvec4 GetPointRawCopy(int iP)  { return            texelFetch(iChannel0, ivec2( iP,5), 0)             ; }\n\nvec2 GetPointPos(int iP)      { return  DecodePnt(texelFetch(iChannel0, ivec2( iP,4), 0))            ; }\n\nvec4 GetPointCountRaw()       { return            texelFetch(iChannel0, ivec2(256,4), 0)             ; }\nint  GetPointCount()          { return int( round(texelFetch(iChannel0, ivec2(256,4), 0).r * 255.0) ); }\nvec4 SetPointCount(int Count) { return vec4((float(Count)/255.0),0,0,0); }\n\n//======================================================================================================================\nvec4 GetTriangleRaw(int iT) { return            texelFetch(iChannel0, ivec2( iT,6), 0)             ; }\nvec4 GetTriangle(int iT)    { return  DecodeTri(texelFetch(iChannel0, ivec2( iT,6), 0))            ; }\n\nbool PointUsed(int iT_Max, int iP) {\n    for (int iT = 0; iT < iT_Max; ++iT) {\n        vec4 Tri = texelFetch(iChannel0, ivec2(iT,6), 0);\n\n        if (Tri.a < 0.5)\n            return false;\n\n        int iTb = int( round(Tri.g * 255.0) );\n        if (iP == iTb)\n            return true;\n    }\n    return false;\n}\n\n//######################################################################################################################\n//######################################################################################################################\nvoid mainImage(out vec4 DATA, in vec2 FragCoord) {\n    //==================================================================================================================\n    if (INITIALIZE) {\n        if      (FragCoord.xy == vec2(0.5, 4.5)) DATA = EncodePnt(vec2(  0, 96));\n        else if (FragCoord.xy == vec2(1.5, 4.5)) DATA = EncodePnt(vec2(-91, 30));\n        else if (FragCoord.xy == vec2(2.5, 4.5)) DATA = EncodePnt(vec2(-56,-78));\n        else if (FragCoord.xy == vec2(3.5, 4.5)) DATA = EncodePnt(vec2( 56,-78));\n        else if (FragCoord.xy == vec2(4.5, 4.5)) DATA = EncodePnt(vec2( 91, 30));\n        else if (UPDATE_PNT_COUNT)               DATA = SetPointCount(5);\n        else if (FragCoord.xy == vec2(0.5, 6.5)) DATA = EncodeTri(0,1,4);\n        else if (FragCoord.xy == vec2(1.5, 6.5)) DATA = EncodeTri(1,2,4);\n        else if (FragCoord.xy == vec2(2.5, 6.5)) DATA = EncodeTri(2,3,4);\n        else                                     DATA = vec4(0);\n        return;\n    //==================================================================================================================\n    } else if (UPDATE_INPUT_PRESSED) {\n        if      (UPDATE_MOUSE_CLICK) DATA = (iMouse.z > 0.5 && !GetMouseState()) ? vec4(1) : vec4(0);\n        else DATA = vec4(0);\n        return;\n    } else if (UPDATE_INPUT_RELEASED) {\n        if      (UPDATE_MOUSE_CLICK) DATA = (iMouse.z < 0.5 &&  GetMouseState()) ? vec4(1) : vec4(0);\n        else DATA = vec4(0);\n        return;\n    } else if (UPDATE_INPUT_STATE) {\n        if      (UPDATE_MOUSE_CLICK) DATA = (iMouse.z > 0.5) ? vec4(1) : vec4(0);\n        else DATA = vec4(0);\n        return;\n    //==================================================================================================================\n    } else if (UPDATE_ACTION) {\n        DATA = vec4(0);\n\n        if (GetMousePressed()) {\n            int Pnt_Count = GetPointCount();\n            vec2 MousePos = GetMousePos();\n            float SelRds = 6.0 * (ViewSizeY/iResolution.y);\n\n            if (PointVsCircle(MousePos, GetPointPos(0), SelRds)) { //  Prevent janky selection of Point[0]\n                DATA = vec4(1,0,0,0);\n            } else {\n                for (int iP = 1; iP <= Pnt_Count; ++iP) {\n                    vec2 PntA = GetPointPos(iP-1);\n                    vec2 PntB = (iP == Pnt_Count) ? GetPointPos(0) : GetPointPos(iP);\n\n                    if (PointVsCircle(MousePos, PntB, SelRds)) {\n                        DATA = vec4(1,0,0, float(iP)/255.0);\n                        break;\n                    }\n                    if (PointVsLine(MousePos, PntA, PntB, SelRds)) {\n                        if (Pnt_Count < 256)\n                            DATA = vec4(0,1,0, float(iP)/255.0);\n                        break;\n                    }\n                }\n            }\n\n        } else if (GetMouseState() && GetActionTaken()) {\n            DATA = GetAction(); //  Persist-ish\n            DATA.r = 1.0; //  If action was Insert,\n            DATA.g = 0.0; //  transition to Move.\n        }\n        return;\n    //==================================================================================================================\n    } else if (UPDATE_POLYGON) {\n        int iP = int(FragCoord.x);\n\n        vec4 Action = GetAction();\n        int iAct = int(round(Action.a * 255.0));\n\n        if (Action.r > 0.5 && iP == iAct) {\n            DATA = EncodePnt(GetMousePos()); //  Move Point.\n\n        } else if (Action.g > 0.5 && iP >= iAct) {\n            if (iP == iAct) DATA = EncodePnt(GetMousePos()); //  Insert Point.\n            else            DATA = GetPointRawCopy(iP-1);    //  Shift Points after Inserted Point.\n\n        } else {\n            DATA = GetPointRaw(iP); //  Persist\n        }\n        return;\n    //==================================================================================================================\n    } else if (UPDATE_PNT_COUNT) {\n        if (GetActionTakenInsert())\n            DATA = SetPointCount(GetPointCount() + 1);\n        else\n            DATA = GetPointCountRaw(); //  Persist\n        return;\n    //==================================================================================================================\n    } else if (UPDATE_POLYCOPY) {\n        DATA = GetPointRaw( int(FragCoord.x) ); //  Reverse order of pixels, no need for a copy...\n        return;\n    //==================================================================================================================\n    } else if (UPDATE_TRIANGULATION_STEP) {\n        //  Everything is delayed by 1 frame.\n        //  The buffer texture doesn't update until the renderpass is complete.\n\n        if      (GetActionTaken() && GetMouseState()   ) DATA = vec4(1,0,0,0); //  UPDATE_POLYGON & UPDATE_PNT_COUNT\n        else if (GetActionTaken() && GetMouseReleased()) DATA = vec4(0,1,0,0); //  UPDATE_TRIANGULATION\n        else {\n            DATA = texelFetch(iChannel0, ivec2(1,3), 0);\n            DATA = (DATA.b > 0.5 && DATA.a >= 1.0) ? vec4(0,0,0,0)                    //  Optimization complete.\n                 : (DATA.b > 0.5                 ) ? vec4(0,0,1,(DATA.a + 1.0/255.0)) //  OPTIMIZE\n                 : (DATA.g > 0.5 && DATA.a >= 1.0) ? vec4(0,0,1,0)                    //  Triangulation complete.\n                 : (DATA.g > 0.5                 ) ? vec4(0,1,0,(DATA.a + 1.0/255.0)) //  TRIANGULATE\n                 :                                   vec4(0);\n        }\n        return;\n    //==================================================================================================================\n    } else if (UPDATE_TRIANGULATION) {\n        int iT = int(FragCoord.x);\n\n        vec4 Step = texelFetch(iChannel0, ivec2(1,3), 0);\n        if (GetActionTaken()) {\n            DATA = vec4(0); //  Clear Triangles.\n\n        } else if (Step.g > 0.5 && int(round(Step.a*255.0)) == iT) {\n            DATA = vec4(0);\n            int Pnt_Count = GetPointCount();\n\n            if (iT < Pnt_Count-2) {\n                int Iterations = 1;\n                int Iterations_MAX = Pnt_Count;\n\n                int iStart = (iT == 0) ? 0 : int(GetTriangle(iT-1).g) + 1;\n\n                for (int iA = iStart; true; ++iA) {\n                    if (iA >= Pnt_Count) {\n                        if (Iterations >= Iterations_MAX) break;\n                        ++Iterations;\n                        iA = 0;\n                    }\n\n                    if (PointUsed(iT, iA))\n                        continue;\n\n                    //------------------------------------------------------------------------------------------------------\n                    //  Find next unused Point:\n                    int iB;\n                    for (iB = (iA+1 < Pnt_Count) ? iA+1 : 0; true; iB = (iB+1 < Pnt_Count) ? iB+1 : 0){\n                        if (PointUsed(iT, iB) == false)\n                            break;\n                    }\n\n                    //  Find next-next unused Point:\n                    int iC;\n                    for (iC = (iB+1 < Pnt_Count) ? iB+1 : 0; true; iC = (iC+1 < Pnt_Count) ? iC+1 : 0){\n                        if (PointUsed(iT, iC) == false)\n                            break;\n                    }\n\n                    vec2 PntA = GetPointPos(iA);\n                    vec2 PntB = GetPointPos(iB);\n                    vec2 PntC = GetPointPos(iC);\n\n                    //------------------------------------------------------------------------------------------------------\n                    bool BadTriangle = false;\n\n                    if (cross2(PntA-PntB, PntC-PntB) > 0.0) {\n                        BadTriangle = true;\n                    } else {\n                        for (int iP = 0; iP < Pnt_Count; ++iP) {\n                            if (iP == iA || iP == iB || iP == iC)\n                                continue;\n\n                            if (PointVsTriangle(GetPointPos(iP),  PntA,PntB,PntC)) {\n                                BadTriangle = true;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (BadTriangle == false) {\n                        DATA = EncodeTri(iA, iB, iC);\n                        return;\n                    }\n                }\n            }\n        } else {\n            DATA = GetTriangleRaw(iT); //  Persist\n            return;\n        }\n    //==================================================================================================================\n    //} else if (OPTIMIZE_TRIANGULATION) {\n    //    int iT = int(FragCoord.x);\n    //    vec4 Step = texelFetch(iChannel0, ivec2(1,3), 0);\n    //    if (Step.b > 0.5 && int(round(Step.a*255.0)) == iT) {\n    //        DATA = vec4(\n    //            sin(Step.a*55.5),\n    //            sin(Step.a*77.7),\n    //            sin(Step.a*33.3),\n    //            1.0\n    //        );\n    //        return;\n    //    } else {\n    //        DATA = vec4(0);\n    //        return;\n    //    }\n    //==================================================================================================================\n    } else {\n        DATA = vec4(0);\n        return;\n    }\n    //==================================================================================================================\n}\n","name":"Buffer A","description":"","type":"buffer"}]}