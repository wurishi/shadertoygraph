{"ver":"0.1","info":{"id":"tlSfzh","date":"1601647159","viewed":320,"name":"Raymarching in jump flood","username":"wilsnat","description":"https://www.shadertoy.com/view/lsKGDV & https://www.shadertoy.com/view/lltcRN\nIdea from https://www.reddit.com/r/godot/comments/ief8xc/working_on_2d_global_illumination_for_godot/\n\nupdated 10/13/2020 with texelFetch","likes":14,"published":1,"flags":48,"usePreview":0,"tags":["raymarch","lighting","jumpflood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float c_gamma = 2.2;\n\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\nvec3 Linear2sRGB(vec3 color){\n    vec3 x = color * 12.92;\n    vec3 y = 1.055 * pow(clamp(color,0.,1.),vec3(0.4166667)) - 0.055;\n    vec3 clr = color;\n    clr.r = (color.r < 0.0031308) ? x.r : y.r;\n    clr.g = (color.g < 0.0031308) ? x.g : y.g;\n    clr.b = (color.b < 0.0031308) ? x.b : y.b;\n    return clr;\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the data for this pixel\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture( iChannel0, uv);\n\n    // decode this pixel\n\tvec2 seedCoord;\n    vec3 seedColor;\n    DecodeData(data, seedCoord, seedColor);\n    \n    // if the 1 key is pressed, show distance info instead\n    if (texture(iChannel2, vec2(KEY_1,0.25)).x > 0.1)\n    {\n        float dist = length(seedCoord - fragCoord) / 25.0;\n        //seedColor = vec3(seedCoord-fragCoord,0);\n        seedColor = vec3(dist);\n\n    } \n    else if (texture(iChannel2, vec2(KEY_2,0.25)).x > 0.1)\n    {\n    \t    // highlight the seeds a bit\n            if (length(fragCoord-seedCoord) > 5.0)\n                seedColor *= 0.75;\n    }\n    else\n    {\n        vec2 uv = fragCoord/iResolution.xy;\n    \tseedColor = Linear2sRGB(texture(iChannel1, uv).rgb);\n    }\n    \n    // gamma correct\n\tseedColor = pow(seedColor, vec3(1.0/c_gamma));\n    fragColor = vec4(seedColor, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//chance of a pixel being a seed, assuming rand() is a good rng\nconst float c_seedChance = 0.0004;\n\n// how many frames between steps.  1.0 = full speed.\nconst float c_frameStepDelay = 7.0;\n\n// how many JFA steps to do.  2^c_maxSteps is max image size on x and y\nconst float c_maxSteps = 10.0;\n\n//============================================================\n// Hash without sine from https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//============================================================\n// returns 0..1\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342);\n    co.y += fract(iDate.w * 11.214);\n    return hash12(co);\n}\n\n//============================================================\nvec3 RandColor (vec2 co)\n{\n    return vec3\n    (\n        Rand(co),\n        Rand(co*2.143),\n        Rand(co*3.163)\n\t);\n}\n\n//============================================================\nvec4 EncodeData (in vec2 coord, in vec3 color)\n{\n    vec4 ret = vec4(0.0);\n    ret.xy = coord;\n    ret.z = floor(color.x * 255.0) * 256.0 + floor(color.y * 255.0);\n    ret.w = floor(color.z * 255.0);\n    return ret;\n}\n\n//============================================================\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\n//============================================================\nvec4 StepJFA (in vec2 fragCoord, in float level)\n{\n    level = clamp(level, 0.0, c_maxSteps);\n    float stepwidth = floor(exp2(c_maxSteps - level)+0.5);\n    \n    float bestDistance = 9999.0;\n    vec2 bestCoord = vec2(0.0);\n    vec3 bestColor = vec3(0.0);\n    \n    for (int y = -1; y <= 1; ++y) {\n        for (int x = -1; x <= 1; ++x) {\n            vec2 sampleCoord = fragCoord + vec2(x,y) * stepwidth;\n            \n            vec4 data = texture( iChannel0, sampleCoord / iChannelResolution[0].xy);\n            vec2 seedCoord;\n            vec3 seedColor;\n            DecodeData(data, seedCoord, seedColor);\n            float dist = length(seedCoord - fragCoord);\n            if ((seedCoord.x != 0.0 || seedCoord.y != 0.0) && dist < bestDistance)\n            {\n                bestDistance = dist;\n                bestCoord = seedCoord;\n                bestColor = seedColor;\n            }\n        }\n    }\n    \n    return EncodeData(bestCoord, bestColor);\n}\n\n//============================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize random seed locations and colors\n    if (iFrame == 0) {\n        if (Rand(fragCoord) > (1.0 - c_seedChance))\n           fragColor = EncodeData(fragCoord, RandColor(fragCoord));\n        else\n           fragColor = vec4(0.0);\n        return;\n    }\n    \n    //fragColor = StepJFA(fragCoord, floor(float(iFrame-1)));\n    \n    // periodic steps\n\tif (mod(float(iFrame), c_frameStepDelay) == 0.0)\n        fragColor = StepJFA(fragCoord, floor(float(iFrame) / c_frameStepDelay));\n    else\n        fragColor = texture( iChannel0, fragCoord.xy / iChannelResolution[0].xy);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//#define WEIGHTED 1\nconst float KEY_3 = 51.5/256.0;\n#define RATIO iResolution.x/iResolution.xy\n#define EPSILON .5/iResolution.x\n#define PI 3.141596\nconst float RAYS_PER_PIXEL = 10.;\n\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat Rand(vec2 co)\n{\n    co.x += fract(iDate.w * 5.342);\n    co.y += fract(iDate.w * 11.214);\n    return hash12(co);\n}\n\nvoid DecodeData (in vec4 data, out vec2 coord, out vec3 color)\n{\n    coord = data.xy;\n    color.x = floor(data.z / 256.0) / 255.0;\n    color.y = mod(data.z, 256.0) / 255.0;\n    color.z = mod(data.w, 256.0) / 255.0;\n}\n\nfloat sdSphere( vec2 p, float s )\n{\n  return length(p*iResolution.xy)/iResolution.x-s;\n}\n\nvec2 seedCoord;\nvec3 seedColor;\nfloat seedSize = .01;\n\nstruct Material{\n\tfloat emission;\n    vec3 color;\n};\n\n#define lightTime iTime * 0.6\n//define LIGHT_DIST sdSphere((uv+1.)*.5 - vec2(sin(lightTime),cos(lightTime)*(sin(lightTime*1.2123341) + 1.)*0.5), 0.1)\n#define LIGHT_DIST sdSphere(uv - iMouse.xy/iResolution.xy, 0.01)\n\nMaterial getSeedMaterial(vec2 uv)\n{\n    float test = EPSILON;\n    vec2 st = uv;\n    st.x *= iResolution.y / iResolution.x;\n    DecodeData(texelFetch( iChannel0, ivec2(uv*iResolution.xy),0), seedCoord, seedColor);\n\tif(LIGHT_DIST < test)\n    {\n        return Material(1., vec3(1.));\n    }\n    else if(length((floor(seedCoord)-floor(uv*iResolution.xy))/iResolution.x)-seedColor.z/60. < 4.)\n    {\n        return Material(0., seedColor);\n    }\n    else\n    {\n    \treturn Material(0., vec3(1.));\n    }\n}\n\nfloat mapSeed(vec2 uv)\n{\n    //uv = (uv + 1.)/2.;\n    DecodeData(texelFetch( iChannel0, ivec2(uv*iResolution.xy),0), seedCoord, seedColor);\n    return min(LIGHT_DIST, length((floor(seedCoord)-floor(uv*iResolution.xy))/iResolution.x)-seedColor.z/60.);\n    //return length(seedCoord/iResolution.xy-uv)-seedSize;\n}\n\nfloat mapSeedEmitter(vec2 uv){\n    DecodeData(texelFetch( iChannel0, ivec2(uv*iResolution.xy),0), seedCoord, seedColor);\n    return length(seedCoord/iResolution.xy-uv)-seedSize;\n}\n\nvec2 mapSeedt(vec2 uv)\n{\n    //uv = (uv + 1.)/2.;\n    DecodeData(texelFetch( iChannel0, ivec2(uv*iResolution.xy),0), seedCoord, seedColor);\n    //return LIGHT_DIST;\n    return seedCoord/iResolution.xy-uv;\n}\n\n\nfloat getEmissionFromBuffer(vec2 st)\n{\n    \n    vec2 pix = 1./iResolution.xy;\n    float e = max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(-1,1))*iResolution.xy),0).a,0.);\n    e = max(max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(0,1))*iResolution.xy),0).a,0.),e);\n    e = max(max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(1,1))*iResolution.xy),0).a,0.),e);\n    e = max(max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(-1,0))*iResolution.xy),0).a,0.),e);\n    e = max(max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(1,0))*iResolution.xy),0).a,0.),e);\n    e = max(max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(-1,-1))*iResolution.xy),0).a,0.),e);\n    e = max(max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(0,-1))*iResolution.xy),0).a,0.),e);\n    e = max(max(texelFetch(iChannel1, ivec2(((st) + pix * vec2(1,-1))*iResolution.xy),0).a,0.),e);\n    return e;\n\t\n    //vec4 bufferVals = texture(iChannel1, st, 0.);\n    //return texture(iChannel1, (st)).a;\n    //vec2 blur = vec2(100.,100.);\n    //return textureLod(iChannel1, (st), 100.).a;\n}\n\nbool traceSeed(vec2 origin, vec2 ray, out vec2 hitPos, out float d)\n{\n    float t = 0.;\n    float dist;\n    vec2 samplePoint;\n    for(int i = 0; i < 32; i++)\n    {\n        samplePoint = origin + ray * t;\n        if(samplePoint.x < 0. || samplePoint.x >1.) return false;\n        if(samplePoint.y < 0. || samplePoint.y > 1.) return false;\n        dist = mapSeed(samplePoint);\n        t += dist;\n        d = t;\n        if(dist < EPSILON)\n        {\n            hitPos = samplePoint;\n            return true;\n        }   \n    }\n    return false;\n}\n\nvec2 estimateNormal(vec2 p) {\n    return normalize(vec2(\n        mapSeed(vec2(p.x + EPSILON, p.y)) - mapSeed(vec2(p.x - EPSILON, p.y)),\n        mapSeed(vec2(p.x, p.y + EPSILON)) - mapSeed(vec2(p.x, p.y - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    \n    //setupSurfaces();\n    //uv = uv * 2.0 - 1.0;\n    //float aspect = iResolution.x / iResolution.y;\n    float invAspect = iResolution.y / iResolution.x;\n    //uv.x *= aspect;\n    \n    vec3 col = vec3(0.);\n    float emis = 0.;\n    \n    DecodeData(texelFetch(iChannel0,ivec2(fragCoord),0), seedCoord, seedColor);\n    \n    vec2 time = vec2(iTime * 0.923213456123, -iTime *0.99584367);\n    float rand02pi = Rand(seedCoord*time*uv)*2.*PI;//Noise sample\n    float golden_angle = PI * (3. - sqrt(5.));\n    \n    Material mat;\n    for(float i = 0.; i < RAYS_PER_PIXEL; i++)\n    {\n        vec2 hitPos;\n        float dist;\n        float curAngle = rand02pi + golden_angle * i;\n        vec2 randDirection = vec2(cos(curAngle),sin(curAngle))/iResolution.xy*iResolution.x;\n        //vec2 randDirection = vec2(cos(iTime*1000.),sin(iTime*1000.));\n        //vec2 randDirection = vec2(cos(rand02pi +(i/RAYS_PER_PIXEL)*2.0*PI),sin(rand02pi+(i/RAYS_PER_PIXEL)*2.0*PI));\n        //bool hit = traceSeed(uv, randDirection, hitPos, dist);\n        bool hit = traceSeed(uv, randDirection, hitPos, dist);\n        if(hit)\n        {\n            mat = getSeedMaterial(hitPos);\n            float d = max(dist,0.);\n            vec2 st = hitPos;\n            //st.x *=  invAspect;\n            //st = (st + 1.0)*0.5;\n            \n            float lastEmission = 0.;\n            if(mat.emission <= EPSILON)\n            {\n                \n            \tlastEmission = getEmissionFromBuffer(st);\n                #ifdef WEIGHTED\n                vec2 normal = estimateNormal(hitPos);\n            \tfloat c = clamp(dot(-randDirection,normal),0.,1.);\n                lastEmission *= c;\n                #endif\n            }\n            if( iFrame==0 || d < EPSILON) lastEmission = 0.0;\n            \n            float emission = mat.emission + lastEmission;\n            float r = 2.;\n            float att = pow(max(1.0 - (d*d)/(r*r),0.),2.);\n            emis += emission*att;\n            col += (mat.emission + lastEmission)*mat.color*att;\n        }\n    }\n    col *= (1./RAYS_PER_PIXEL);\n    emis *= (1./RAYS_PER_PIXEL);\n    \n    vec2 st = fragCoord/iResolution.xy;\n    vec3 oldCol  = texture(iChannel1, st).rgb;\n    vec3 total = col;\n    \n    if( iFrame==0 ) oldCol = vec3(0.0);\n\n    float integ = 4.;\n    //fragColor = vec4(total,emis);\n    fragColor = vec4( (1.-(1./integ))*oldCol +total*(1./integ), emis );\n    //fragColor = vec4(vec3(mapSeed(fragCoord.xy)),1.);\n    if (texture(iChannel2, vec2(KEY_3,0.25)).x > 0.1)\n    {\n    \tfragColor = vec4(vec3(mapSeed(uv)),1.);\n    }\n\n}","name":"Buffer B","description":"","type":"buffer"}]}