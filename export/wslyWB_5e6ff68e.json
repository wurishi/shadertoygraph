{"ver":"0.1","info":{"id":"wslyWB","date":"1585521114","viewed":272,"name":"Interference Blobs 2","username":"KJK","description":"just messing around","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["interferencepattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float getBrightness(vec2 uv);\nvec2 polar(float angle, float r);\nvec2 hsv2rgb(vec3 c);\n\nfloat TAU = 2.0 * 3.14159;\nfloat speed = 6.0;\nfloat range = 100.0;\nfloat waveFrequency = 1.5;\nfloat waveSmoothness = 1.0;\nfloat invScale = 80.0;\nfloat dropletCount = 5.0;\nfloat aberration = 0.25;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    uv *= invScale + 10.0 * sin(iTime);\n    \n    // This twists the domain, doing so more near the center.\n    float angle = sin(iTime) * TAU / (length(uv) + 1.0);\n    float ct = cos(angle);\n    float st = sin(angle);\n    uv = vec2(ct * uv.x + st * uv.y, st * uv.x - ct * uv.y);\n    \n    //float aberration = sin(iTime * 0.3247) * 0.25;\n\n    float r = getBrightness(uv + polar(TAU * 0.0 / 3.0, aberration));\n    float g = getBrightness(uv + polar(TAU * 1.0 / 3.0, aberration));\n    float b = getBrightness(uv + polar(TAU * 2.0 / 3.0, aberration));\n    \n    fragColor = vec4(r, g, b, 1.0);\n}\n\nfloat getBrightness(vec2 uv) {\n    float brightness = 0.0;\n    for (float i = 0.0; i < dropletCount; i++) {\n        float angle = TAU * i / dropletCount;\n        float dist = (0.5 + 0.5 * sin(iTime * speed / range)) * range;\n        vec2 pos = vec2(sin(angle), cos(angle)) * dist;\n        float distFromDrop = length(uv.xy - pos);\n        float height = 0.5 + 0.5 * cos(waveFrequency * distFromDrop);\n        brightness += height;\n    }\n    brightness /= dropletCount;\n    \n    vec2 gradient = vec2(dFdx(brightness), dFdy(brightness));\n    float slope = length(gradient);\n    \n    // If the wave is steep here, compensate by smoothing the step.\n    float r = waveSmoothness * slope;\n    \n    // The larger r is, the wider the interpolation region is and the smoother the step is.\n    brightness = smoothstep(0.5 - r, 0.5 + r, brightness);\n    \n    return brightness;\n}\n\nvec2 polar(float angle, float r) {\n    return vec2(cos(angle) * r, sin(angle) * r);\n}\n","name":"Image","description":"","type":"image"}]}