{"ver":"0.1","info":{"id":"dtBcWV","date":"1692289843","viewed":59,"name":"Analytical sphere light","username":"saalty","description":"Hold mouse for controls. MouseX controls surface roughness, MouseY controls sphere radius. Any radius works for this custom diffuse and Phong-based specular lighting! Isn't totally accurate, but a really good approximation that looks nice.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float EPSILON = 0.000001;\n    \nfloat raySphereIntersect(vec3 r0, vec3 rd, vec3 s0, float sr) \n{\n    float a = dot(rd, rd);\n    vec3 s0_r0 = r0 - s0;\n    float b = 2.0 * dot(rd, s0_r0);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (b*b - 4.0*a*c < 0.0) {\n        return 1000.0;\n    }\n    return (-b - sqrt((b*b) - 4.0*a*c))/(2.0*a);\n}\n\nfloat rayTriangleIntersect(vec3 r0, vec3 rd, vec3 v0, vec3 v1, vec3 v2) {\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross(rd, e2);\n    float a = dot(e1, h);\n\n    if (a > -EPSILON && a < EPSILON) {\n        return 1000.0; // Ray is parallel to the triangle\n    }\n\n    float f = 1.0 / a;\n    vec3 s = r0 - v0;\n    float u = f * dot(s, h);\n\n    if (u < 0.0 || u > 1.0) {\n        return 1000.0; // Intersection lies outside the triangle\n    }\n\n    vec3 q = cross(s, e1);\n    float v = f * dot(rd, q);\n\n    if (v < 0.0 || u + v > 1.0) {\n        return 1000.0; // Intersection lies outside the triangle\n    }\n\n    float t = f * dot(e2, q);\n\n    if (t <= EPSILON) {\n        return 1000.0; // Ray intersection is behind the starting point\n    }\n\n    return t < 0.0 ? 1000.0 : t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    vec3 LightPos = vec3(0.0, 0.0, 8.0);\n    \n    float LightRad = 1.0;\n    float SurfRoughness = iMouse.y / iResolution.y;\n    \n    vec3 RayPos = vec3(0.0);\n    vec3 RayDir = normalize(vec3(uv, 1.0));\n    \n    float ObjRad = iMouse.x / iResolution.x * 8.0;\n    vec3 ObjPos = vec3(0.0, ObjRad + 1.0, 8.0);\n    \n    RayDir.y *= -1.0;\n    \n    float SphereDist = raySphereIntersect(RayPos, RayDir, LightPos, LightRad);\n    float Sphere2Dist = raySphereIntersect(RayPos, RayDir, ObjPos, ObjRad);\n    \n    fragColor = vec4(0.5, 0.5, 1.0, 1.0);\n    if (Sphere2Dist != 1000.0 || SphereDist != 1000.0)\n    {\n        fragColor = vec4(1.0);\n\n        if (Sphere2Dist < SphereDist)\n        {\n            RayPos += RayDir * Sphere2Dist;\n            vec3 normal = normalize(RayPos - ObjPos);\n            RayDir = reflect(RayDir, normal);\n            \n            /* Area calc */\n            float area = 3.141 * LightRad * LightRad;\n            area /= max(length(LightPos - RayPos) - LightRad, EPSILON);\n            float origArea = area;\n            area = area;\n            \n            /* Lighting calc */\n            vec3 comp = (1.0 - SurfRoughness) * RayDir + SurfRoughness * normal;\n            float useArea = (1.0 - SurfRoughness) * area + SurfRoughness * origArea;\n            float specular = dot(normalize(LightPos - RayPos), normalize(comp)) - (useArea);\n            float diffuse = (specular + useArea) * useArea;\n            float lums = tanh(max(specular, 0.0) + max(diffuse, 0.0));\n            lums /= SurfRoughness + EPSILON;\n            fragColor = vec4(lums, lums, lums, 1.0);\n        }\n    }\n}","name":"Image","description":"","type":"image"}]}