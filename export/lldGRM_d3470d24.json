{"ver":"0.1","info":{"id":"lldGRM","date":"1468470504","viewed":4359,"name":"Orthonormal basis via H","username":"MBR","description":"normal to orthonormal basis using quaternion similarity","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["tangent","orthonormal","basis","binormal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// HACK OF: https://www.shadertoy.com/view/4sSSW3\n\n// Create an orthonormal basis from a normal:\n//   http://marc-b-reynolds.github.io/quaternions/2016/07/06/Orthonormal.html\n// TL;DR version\n//   1) The method of Frisvad can be reduced to 2 products\n//   2) The math generalizes.  Second example (method 2) uses\n//      two instead of one reference directions.  Instead of a\n//      cowlick at -z there's a part at z=0\n\n//#define METHOD_2\n\nvoid basis(in vec3 n, out vec3 xp, out vec3 yp)\n{\n#if defined(METHOD_2)\n  // method 2a variant\n  float sz = n.z >= 0.0 ? 1.0 : -1.0;\n  float a  =  n.y/(1.0+abs(n.z));\n  float b  =  n.y*a;\n  float c  = -n.x*a;\n    \n  xp = vec3(n.z+sz*b, sz*c, -n.x);\n  yp = vec3(c, 1.0-b, -sz*n.y);\n#else\n    \n  // method 1: ignoring n approaching -z\n#if 1\n  float a =  n.y/(1.0+n.z);\n  float b =  n.y*a;\n  float c = -n.x*a;\n    \n  xp = vec3(n.z+b, c, -n.x);\n  yp = vec3(c, 1.0-b, -n.y);\n    \n#else\n    \n  // nimitz's impl of frisvad\n  float a = 1./(1. + n.z);\n  float b = -n.x*n.y*a;\n  xp = vec3(1. - n.x*n.x*a, b, -n.x);\n  yp = vec3(b, 1. - n.y*n.y*a , -n.y);\n#endif\n#endif\n}\n\n\n//------ below here is original\n\n\n//Cheap orthonormal basis by nimitz\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\n//via: http://psgraphics.blogspot.pt/2014/11/making-orthonormal-basis-from-unit.html\n\n//I doubt this is needed on gpu, let me know if you need this for it to work.\n//#define HANDLE_SINGULARITY\n\n\n#define ITR 80\n#define FAR 10.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\n\nfloat map(vec3 p)\n{\n  p.x += sin(p.z*5.+sin(p.y*5.))*0.3;\n  return (length(p)-1.)*0.7;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n  float precis = 0.001;\n  float h=precis*2.0;\n  float d = 0.;\n  for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n\n#if 0\n\n//http://orbit.dtu.dk/fedora/objects/orbit:113874/datastreams/file_75b66578-222e-4c7d-abdf-f7e255100209/content\nvoid basis(in vec3 n, out vec3 f, out vec3 r)\n{\n    #ifdef HANDLE_SINGULARITY\n    if(n.z < -0.999999)\n    {\n        f = vec3(0 , -1, 0);\n        r = vec3(-1, 0, 0);\n    }\n    else\n    {\n    \tfloat a = 1./(1. + n.z);\n    \tfloat b = -n.x*n.y*a;\n    \tf = vec3(1. - n.x*n.x*a, b, -n.x);\n    \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    }\n    #else\n    float a = 1./(1. + n.z);\n    float b = -n.x*n.y*a;\n    f = vec3(1. - n.x*n.x*a, b, -n.x);\n   \tr = vec3(b, 1. - n.y*n.y*a , -n.y);\n    #endif\n}\n\n#endif\n\n\n\n//from iq (https://www.shadertoy.com/view/4slGz4)\nvec3 dLine(in vec3 ro, in vec3 rd, in vec3 a, in vec3 b)\n{\n\tvec3 ba = b - a;\n\tvec3 oa = ro - a;\n\tfloat oad  = dot( oa,  rd );\n\tfloat dba  = dot( rd, ba );\n\tfloat baba = dot( ba, ba );\n\tfloat oaba = dot( oa, ba );\n\t\n\tvec2 th = vec2( -oad*baba + dba*oaba, oaba - oad*dba ) / (baba - dba*dba);\n\t\n\tth.x = max(th.x, 0.);\n\tth.y = clamp(th.y, 0., 1.);\n\t\n\tvec3 p = a + ba*th.y;\n\tvec3 q = ro + rd*th.x;\n\t\n\treturn vec3( length( p-q ), th );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.8,0.1):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\t//camera\n\tvec3 ro = vec3(0.,0.,4.5);\n    vec3 rd = normalize(vec3(p,-1.5));\n    vec3 rd2 = vec3(0,0.,-1);\n    mat2 mx = mm2(mo.x*6.);\n    mat2 my = mm2(mo.y*6.); \n    ro.xz *= mx;rd.xz *= mx;rd2.xz *= mx;\n    ro.xy *= my;rd.xy *= my;rd2.xy *= my;\n\t\n    vec3 ligt = normalize( vec3(-.5, 0.2, -0.2) );\n    vec3 lcol = vec3(1.00,0.90,0.75);\n    float rdl = clamp(dot(rd,ligt),0.,1.);\n    vec3 col = lcol*pow(rdl,50.) + vec3(0.1,0.2,0.3)*0.5;\n    \n\tfloat rz = march(ro,rd);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        float dif = clamp( dot(nor, ligt), 0., 1. );\n        float bac = clamp( dot(nor, -ligt),0., 1.);\n        float spe = pow(clamp(dot(reflect(rd,nor), ligt), 0., 1.),100.);\n        float fre = 0.6*pow( clamp(1. + dot(nor,rd),0.0,1.0), 2.);\n        vec3 brdf = 1.0*vec3(0.10,0.11,0.13);\n        brdf += 2.*bac*vec3(0.15,0.15,0.15);\n        brdf += 1.50*dif*lcol;\n        col = vec3(0.3,0.3,0.3);\n        col = col*brdf + col*spe + fre*col;\n    }\n    \n    \n    vec3 pdir = vec3(0.5773);\n    pdir.xz *= mm2(time*0.3);\n    pdir.zy *= mm2(time*.44);\n    float rz2 = march(pdir*3.,-pdir);\n    vec3 bpos = pdir*3.+rz2*-pdir;\n\t\n    vec3 nor= normal(bpos);\n    vec3 r = vec3(0);vec3 f = vec3(0);\n    basis(nor,f,r);\n    \n    vec3 g = dLine(ro,rd,bpos,bpos+nor);\n    float occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.3,.3,1)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+f);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(1.,.2,.2)*(1.-smoothstep(0.0,.03,g.x)));\n\n    g = dLine(ro,rd,bpos,bpos+r);\n    occ = step(g.y, rz)*0.5+0.5;\n    col = max(col,smoothstep(-2.5,1.,sin(g.z*120.))*occ*vec3(.2,1,.2)*(1.-smoothstep(0.0,.03,g.x)));\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}