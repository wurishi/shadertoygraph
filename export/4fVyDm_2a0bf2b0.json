{"ver":"0.1","info":{"id":"4fVyDm","date":"1732045580","viewed":52,"name":"UV and Normal of a Sphere","username":"AndreiDespinoiu","description":"The concepts from this shader can be adapted to the \"Pixel Shader\" node in Substance Designer.\nCombined with the (in-built) \"UV Mapper\" nodes it allows creating cool things like rotating eyeballs, maybe some Christmas tree globes.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["uv","sphere","normal","mathematicalsphere"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Uniforms\"\nconst float radius = 0.8;\nconst float intensity = 1.0; // Normal intensity\n\nvoid mainImage( out vec4 oFragColor, in vec2 fragCoord )\n{\n    // Step 1: Normalize fragment coordinates to range [-1, 1]\n    vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n    uv = uv * 2.0 - 1.0; // Normalized device coordinates (NDC)\n\n    uv.x *= iResolution.x / iResolution.y; // Scale X by the aspect ratio of the viewport resolution. Not needed if your texture is always square\n    uv.y *= -1.0;\n    \n    // Step 2: Map screen coordinates to a sphere\n    float x = uv.x; // X in NDC\n    float y = uv.y; // Y in NDC\n    float z2 = radius * radius - x * x - y * y; // Solve for z^2 (sphere equation x^2 + y^2 + z^2 = radius^2)\n\n    if (z2 < 0.0)\n    {\n        // Outside the sphere, discard the fragment or set it to a background color\n        oFragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n\n    float z = sqrt(z2); // Positive z value for the front face of the sphere\n\n    // Step 3: Compute normal for the sphere\n    vec3 normal = normalize(vec3(x, y, z)); // Sphere's surface normal\n    normal.xy *= intensity;\n    normal = normalize(normal);\n\n    // Step 4: Compute UV coordinates\n    float u = 0.5 + atan(normal.z, normal.x) / (2.0 * 3.14159265359);  // Azimuthal angle\n    float v = 0.5 - asin(normal.y) / 3.14159265359;           // Polar angle\n    vec2 sphereUV = vec2(u, v);\n\n    // Step 5: Output the UV as color for visualization\n    //oFragColor = vec4(sphereUV, 0.0, 1.0);                     // Output UV as RGB\n    //oFragColor = vec4(vec3(normal * 0.5 + 0.5).xy, 0.0, 1.0);  // Preview \"UV\" based on normal\n    oFragColor = vec4(normal * 0.5 + 0.5, 1.0);                  // Preview normal\n}","name":"Image","description":"","type":"image"}]}