{"ver":"0.1","info":{"id":"fsGGzh","date":"1631027887","viewed":175,"name":"Piecewise Linear Simplex Terrain","username":"harry7557558","description":"Demonstrate a noise generated by interpolating hash values on a simplex grid.\nSee Common tab for 2D and 3D noise functions and their analytical gradient.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["noise","terrain","simplex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// I attempted to find a combination of simplex noise and value noise\n// but failed to produced one with continuous gradient.\n\n// The idea is to interpolate hash values on a simplex grid.\n// The noise (2D+3D) and their analytical gradient can be found in the Common tab.\n\n// The 3D noise seems to be cheaper than 3D Perlin noise\n// and about the same cost as 3D value noise.\n// The 2D noise is more expensive than most common 2D noise functions\n// but cheaper than standard 2D simplex noise.\n\n// I created this shader to demonstrate this piecewise linear simplex noise.\n\n\n// scene\nfloat map(in vec3 p) {\n    float base = p.z - 0.1*SimplexValueNoise2D(p.xy);\n    float top = p.z - (0.05 * 2.0*SimplexValueNoise2D(0.5*p.xy) + 3.0);\n    float blob = 0.6*5.0*SimplexValueNoise3D(0.2*p) + 0.2*SimplexValueNoise3D(p);\n    return min(max(blob, top), base);\n}\n\n// to show that analytical gradient works\nvec3 mapNormal(vec3 p) {\n    vec3 t = SimplexValueNoise2Dg(p.xy);\n    vec4 base = vec4(0, 0, 1, p.z) - 0.1*vec4(t.xy, 0.0, t.z);\n    t = 2.0 * vec3(0.5,0.5,1)*SimplexValueNoise2Dg(0.5*p.xy);\n    vec4 top = vec4(0, 0, 1, p.z) - (0.05 * vec4(t.xy, 0.0, t.z) + vec4(vec3(0), 3.0));\n    vec4 blob = 0.6*5.0*vec4(vec3(0.2),1)*SimplexValueNoise3Dg(0.2*p) + 0.2*SimplexValueNoise3Dg(p);\n    vec4 r = blob.w > top.w ? blob : top;\n    r = r.w < base.w ? r : base;\n    return normalize(r.xyz);\n}\n\n\n\n#define ZERO min(int(iTime),0)\n\nconst vec3 sundir = normalize(vec3(0.5, 0.5, 1.0));\n\nbool raymarch(vec3 ro, inout vec3 rd, inout float t) {\n    float t0 = 0.01, t1 = 120.0;\n    for (int i=ZERO; i<120; i++) {\n        float dt = map(ro+rd*t);\n        t += dt;\n        if (abs(dt) < 1e-2) break;\n        if (t > t1) {\n            return false;\n        }\n        rd = normalize(rd + vec3(0, 0, .001*dt));\n    }\n    return true;\n}\n\nfloat calcShadow(vec3 ro) {\n    float t = 0.1;\n    for (int i=ZERO; i<20; i++) {\n        float dt = map(ro+sundir*t);\n        if (dt < 0.) return 0.1;\n        t += max(dt, 0.1);\n    }\n    return 1.0;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    float rx = iMouse.z>0. ? 1.8*(iMouse.y/iResolution.y)-0.2 : 0.28;\n    float rz = iMouse.z>0. ? -iMouse.x/iResolution.x*4.0*3.14 : 0.5+0.1*iTime;\n    float ry = iMouse.z>0. ? 0.0 : 0.1;\n\n    vec3 u = vec3(-sin(rz),cos(rz),0);\n    vec3 v = vec3(-sin(rx)*vec2(cos(rz),sin(rz)), cos(rx));\n    vec3 w = cross(u, v);\n    u = cos(ry)*u + sin(ry)*v;\n    v = cross(w, u);\n\n    vec3 ro = vec3(2.0*iTime, 0, 2.5) + 14.0*w;\n    vec2 uv = 2.0*fragCoord.xy/iResolution.xy - vec2(1.0);\n    vec3 rd = mat3(u,v,-w)*vec3(uv*iResolution.xy, 2.0*length(iResolution.xy));\n    rd = normalize(rd);\n\n    float t = 0.0;\n    vec3 col;\n    if (raymarch(ro, rd, t)) {\n        ro += rd * t;\n        vec3 n = mapNormal(ro);\n        vec3 basecol = 0.5+0.4*(1.0-abs(n.z))*hash33(n);\n        float shadow = calcShadow(ro);\n        vec3 sunlight = basecol * shadow * max(dot(n, sundir), 0.0) * vec3(1.2,1.1,0.8);\n        vec3 skylight = basecol * max(n.z, 0.0) * vec3(0.6,0.6,0.8);\n        vec3 indirect = basecol * max(-dot(n, sundir), 0.0) * vec3(0.6) + 0.2*max(-n.z, 0.0);\n        col = sunlight + skylight + indirect;\n    }\n    else {\n        t = 1e12;\n    }\n    col = mix(vec3(0.5, 0.6, 0.7)-0.3*max(rd.z, 0.0), col, exp(-0.015*t));\n    col += vec3(0.8, 0.6, 0.4) * pow(max(dot(rd, sundir), 0.0), 1.5);\n    col = 1.1*pow(col, vec3(1.2));\n    fragColor = vec4(vec3(col), 1.0);\n    return;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// hash functions from https://www.shadertoy.com/view/4djSRW by David Hoskins\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash13(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// for solving interpolation\nfloat det(vec2 a, vec2 b) {\n    return a.x*b.y - a.y*b.x;\n}\nfloat det(vec3 a, vec3 b, vec3 c) {\n    return dot(a, cross(b, c));\n}\n\n// noise functions and their analytical gradient\n\nfloat SimplexValueNoise2D(vec2 xy) {\n\t// simplex grid\n\tconst float K1 = 0.3660254038;  // (sqrt(3)-1)/2\n\tconst float K2 = 0.2113248654;  // (-sqrt(3)+3)/6\n\tvec2 p = xy + (xy.x + xy.y)*K1;\n\tvec2 p1 = floor(p);\n\tvec2 s = xy.x-p1.x < xy.y-p1.y ? vec2(0., 1.) : vec2(1., 0.);\n\tvec2 p2 = p1 + s;\n\tvec2 p3 = p1 + 1.0;\n\tfloat v1 = 2.0 * hash12(p1) - 1.0;\n\tfloat v2 = 2.0 * hash12(p2) - 1.0;\n\tfloat v3 = 2.0 * hash12(p3) - 1.0;\n\t// interpolation\n\tvec2 f = p - p1, c = -s + 1.0;\n\tfloat m = 1.0 / det(s, c);\n\tfloat u = m * det(f, c);\n\tfloat uv = m * det(s, f);\n\treturn v1 + u * (v2 - v1) + uv * (v3 - v2);  // mix(v1, mix(v2, v3, v), u)\n}\n\nvec3 SimplexValueNoise2Dg(vec2 xy) {\n\t// simplex grid\n\tconst float K1 = 0.3660254038;  // (sqrt(3)-1)/2\n\tconst float K2 = 0.2113248654;  // (-sqrt(3)+3)/6\n\tvec2 p = xy + (xy.x + xy.y)*K1;\n\tvec2 p1 = floor(p);\n\tvec2 s = xy.x-p1.x < xy.y-p1.y ? vec2(0., 1.) : vec2(1., 0.);\n\tvec2 p2 = p1 + s;\n\tvec2 p3 = p1 + 1.0;\n\tfloat v1 = 2.0 * hash12(p1) - 1.0;\n\tfloat v2 = 2.0 * hash12(p2) - 1.0;\n\tfloat v3 = 2.0 * hash12(p3) - 1.0;\n\t// interpolation\n\tvec2 f = p - p1, c = -s + 1.0;\n\tfloat m = 1.0 / det(s, c);\n\tfloat u = m * det(f, c);\n\tfloat uv = m * det(s, f);\n\tvec2 grad_u = m * vec2(c.y, -c.x);\n\tvec2 grad_uv = m * vec2(-s.y, s.x);\n\tfloat val = v1 + u * (v2 - v1) + uv * (v3 - v2);\n\tvec2 grad = grad_u * (v2 - v1) + grad_uv * (v3 - v2);\n\treturn vec3(grad + (grad.x + grad.y)*K1, val);\n}\n\nfloat SimplexValueNoise3D(vec3 xyz) {\n\t// simplex grid\n\tconst float K1 = 0.3333333333;\n\tconst float K2 = 0.1666666667;\n\tvec3 p = xyz + (xyz.x + xyz.y + xyz.z)*K1;\n\tvec3 i = floor(p), f = p - i;\n\tvec3 f0 = xyz - (i - (i.x + i.y + i.z)*K2);\n\t//vec3 e = step(f0.yzx, f0);  // possibly result in degenerated simplex\n\tvec3 e = vec3(f0.y > f0.x ? 0.0 : 1.0, f0.z >= f0.y ? 0.0 : 1.0, f0.x > f0.z ? 0.0 : 1.0);\n\tvec3 i1 = e * (vec3(1.0) - e.zxy);\n\tvec3 i2 = vec3(1.0) - e.zxy * (vec3(1.0) - e);\n\tvec3 p0 = i;\n\tvec3 p1 = i + i1;\n\tvec3 p2 = i + i2;\n\tvec3 p3 = i + 1.0;\n\tfloat v0 = 2.0 * hash13(p0) - 1.0;\n\tfloat v1 = 2.0 * hash13(p1) - 1.0;\n\tfloat v2 = 2.0 * hash13(p2) - 1.0;\n\tfloat v3 = 2.0 * hash13(p3) - 1.0;\n\t// interpolation\n\tvec3 p01 = p1 - p0, p12 = p2 - p1, p23 = p3 - p2;\n\tfloat m = 1.0 / det(p01, p12, p23);\n\tfloat w = m * det(f, p12, p23);\n\tfloat uw = m * det(p01, f, p23);\n\tfloat uvw = m * det(p01, p12, f);\n\treturn v0 + (v1 - v0) * w + (v2 - v1) * uw + (v3 - v2) * uvw;  // mix(v0, mix(mix(v1, v2, u), mix(v1, v3, u), v), w)\n}\n\nvec4 SimplexValueNoise3Dg(vec3 xyz) {\n\t// simplex grid\n\tconst float K1 = 0.3333333333;\n\tconst float K2 = 0.1666666667;\n\tvec3 p = xyz + (xyz.x + xyz.y + xyz.z)*K1;\n\tvec3 i = floor(p), f = p - i;\n\tvec3 f0 = xyz - (i - (i.x + i.y + i.z)*K2);\n\tvec3 e = vec3(f0.y > f0.x ? 0.0 : 1.0, f0.z >= f0.y ? 0.0 : 1.0, f0.x > f0.z ? 0.0 : 1.0);\n\tvec3 i1 = e * (vec3(1.0) - e.zxy);\n\tvec3 i2 = vec3(1.0) - e.zxy * (vec3(1.0) - e);\n\tvec3 p0 = i;\n\tvec3 p1 = i + i1;\n\tvec3 p2 = i + i2;\n\tvec3 p3 = i + 1.0;\n\tfloat v0 = 2.0 * hash13(p0) - 1.0;\n\tfloat v1 = 2.0 * hash13(p1) - 1.0;\n\tfloat v2 = 2.0 * hash13(p2) - 1.0;\n\tfloat v3 = 2.0 * hash13(p3) - 1.0;\n\t// interpolation\n\tvec3 p01 = p1 - p0, p12 = p2 - p1, p23 = p3 - p2;\n\tfloat m = 1.0 / det(p01, p12, p23);\n\tfloat w = m * det(f, p12, p23);\n\tfloat uw = m * det(p01, f, p23);\n\tfloat uvw = m * det(p01, p12, f);\n\tvec3 grad_w = m * cross(p12, p23);\n\tvec3 grad_uw = m * cross(p23, p01);\n\tvec3 grad_uvw = m * cross(p01, p12);\n\tfloat val = v0 + (v1 - v0) * w + (v2 - v1) * uw + (v3 - v2) * uvw;\n\tvec3 grad = (v1 - v0) * grad_w + (v2 - v1) * grad_uw + (v3 - v2) * grad_uvw;\n\treturn vec4(grad + (grad.x + grad.y + grad.z)*K1, val);\n}\n\n","name":"Common","description":"","type":"common"}]}