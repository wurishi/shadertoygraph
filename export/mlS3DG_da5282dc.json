{"ver":"0.1","info":{"id":"mlS3DG","date":"1673827972","viewed":136,"name":"PBR cube!","username":"ianertson","description":"Another PBR cube, rotate the cube by dragging around with the mouse.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","ray","cube","normalmapping","fakepbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 noise(vec3 uv) { return textureLod(iChannel2, uv/64.0, 0.).xyz; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    \n    vec3 mouseControl = controller(vec3(1.0, 1.0, 1.0), iMouse, iResolution.xy);\n    \n    Box box = makeBox(\n        vec3(-0.5, -0.5, -1.5),                                // position\n        vec3(1.0, 1.0, 1.0),                                   // size\n        vec4(mouseControl.xyz, 1.0)                            // rotation\n    );\n    vec3 focusPoint = box.pos+(box.size*0.5);\n    \n    float T = iTime*0.5;\n    vec3 origin = vec3(cos(T), 0.0, sin(T)) * M_PI;\n    Ray ray = getPrimaryRay(\n        origin,                                                // origin\n        fc,                                                    // fragCoord\n        iResolution.xy,                                        // resolution\n        normalize(origin - focusPoint),                        // look\n        60.0,                                                  // fov\n        0.1,                                                   // near\n        400.0                                                  // far\n    );\n    \n    vec3 rand0 = noise(ray.dir*4.0);\n    vec3 rand = noise((ray.dir+vec3(cos((T*0.2)+rand0.x), sin((T*0.2)+rand0.y), cos((T*0.2)+rand0.z)))*20.0);\n    \n    Light light = Light(\n        vec3(0.3, 4.9, -0.5) + vec3(sin(T), cos(T)*0.5, cos(T)),\n        16.0,\n        vec3(0.4, 0.9, 0.8)\n     );\n    \n    float depth = ray.far;\n    bool hit = false;\n\n    if (rayAABBIntersection(\n        ray,\n        box\n    )) {\n        hit = true;\n        col += PBR(\n            ray,\n            light,\n            iChannel1,\n            extractBump(ray.result.rot, iChannel0, ray.result.uv, ray.result.normal),\n            iChannel0\n        );\n        depth = ray.result.dist;\n    }\n    \n    vec3 dirbox = normalize((box.pos+(rand*0.89)) - ray.origin);\n    vec3 dirlight = normalize(ray.origin - light.pos+(rand*0.89));\n    depth = (depth+ray.near) / ray.far;\n    float bgdist = 0.0;\n    vec3 bg = shadeBackground(getBackground(iChannel1, ray.origin, ray.dir), ray.origin, ray.dir, light, extractBump3D(vec4(0.0), iChannel1, ray.origin, ray.dir, 0.033), bgdist);\n    bg += 4.0*(bg*pow(dot(bg, light.color), 2.0));\n    bg = mix(bg, bg*bg, 0.6*max(0.0, 1.0-pow(luma(bg), 2.0)));\n    depth += bgdist/ray.far;\n    float mag = length(col)+float(hit);\n    float imag = clamp(1.0 - (mag*ray.far), 0.0, 1.0);\n    col = mix(col, bg, smoothstep(0.0, 1.0, imag));\n    col += 0.2*pow((1.0 - pow(length(cross(dirbox, ray.dir)), 4.0)), 4.0) * light.color * max(0.0, dot(ray.dir*-1.0,dirlight));\n    col += (col*luma(col));\n    col *= M_PI;\n    col = vec3(1.0) - exp(-col * luma(col));\n    col = pow(col, vec3(1.0 / 1.9));\n    fragColor = vec4(mix(col, smoothstep(0.0, 1.0, col), 0.39),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float M_PI = 3.14159265359;\n\nstruct Light {\n    vec3 pos;\n    float strength;\n    vec3 color;\n};\n\nstruct Box {\n  vec3 pos;\n  vec3 size;\n  vec4 rotation;\n};\n\nvec3 getBoxCenter(in Box box) {\n  vec3 boxMin = box.pos;\n  vec3 boxMax = boxMin+box.size;\n  vec3 center = (boxMin+boxMax)*0.5;\n  center -= box.pos;\n  center *= -1.0;\n  return center;\n}\n\nBox makeBox(vec3 pos, vec3 size, vec4 rotation) { return Box(pos, size, rotation); }\n\nvec2 rot2D(vec2 p, float angle) {\n  angle = radians(angle);\n  float s = sin(angle);\n  float c = cos(angle);\n  return p * mat2(c, s, -s, c);\n}\n\nvec3 controller(vec3 dir, vec4 c, vec2 res) {\n    \n    vec2 m = ((c.xy == vec2(0.) ? vec2(.5) : (c.xy / res.xy)) * 2. - 1.) * vec2(360.,90.);\n    dir.yz = rot2D(dir.yz, m.y);\n    dir.xz = rot2D(dir.xz, m.x);\n    return dir;\n}\n\nmat4 rotationX(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(1, 0, 0, 0), vec4(0, c, -s, 0), vec4(0, s, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationY(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, 0, s, 0), vec4(0, 1, 0, 0), vec4(-s, 0, c, 0),\n              vec4(0, 0, 0, 1));\n}\n\nmat4 rotationZ(float angle) {\n  float c = cos(angle);\n  float s = sin(angle);\n  return mat4(vec4(c, -s, 0, 0), vec4(s, c, 0, 0), vec4(0, 0, 1, 0),\n              vec4(0, 0, 0, 1));\n}\n\nvec3 rotate3D(vec3 vertex, vec3 center, vec3 axis, float angle, bool inv, out mat4 matrix) {\n  matrix = (rotationX(angle * axis.x) * rotationY(angle * axis.y) * rotationZ(angle * axis.z));\n  matrix = inv ? inverse(matrix) : matrix;\n  return (matrix * vec4(vertex - center, 1.0)).xyz + center;\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = lookAtPoint;\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nmat4 proj(float fovy, float aspect, float nearZ, float farZ) {\n\n  mat4 dest = mat4(0.0);\n  float f = 1.0f / tan(fovy * 0.5f);\n  float fn = 1.0f / (nearZ - farZ);\n\n  dest[0][0] = f / aspect;\n  dest[1][1] = f;\n  dest[2][2] = -farZ * fn;\n  dest[2][3] = 1.0f;\n  dest[3][2] = nearZ * farZ * fn;\n  return dest;\n}\n\nmat4 look(vec3 eye, vec3 center, vec3 up) {\n  mat4 dest = mat4(0.0);\n  vec3 f = vec3(0.0);\n  vec3 u = vec3(0.0);\n  vec3 s = vec3(0.0);\n\n  f = normalize(center - eye);\n\n  s = cross(up, f);\n  u = cross(f, s);\n\n  dest[0][0] = s[0];\n  dest[0][1] = u[0];\n  dest[0][2] = f[0];\n  dest[1][0] = s[1];\n  dest[1][1] = u[1];\n  dest[1][2] = f[1];\n  dest[2][0] = s[2];\n  dest[2][1] = u[2];\n  dest[2][2] = f[2];\n  dest[3][0] = -dot(s, eye);\n  dest[3][1] = -dot(u, eye);\n  dest[3][2] = -dot(f, eye);\n  dest[0][3] = dest[1][3] = dest[2][3] = 0.0f;\n  dest[3][3] = 1.0f;\n\n  return dest;\n}\n\nstruct RayResult {\n  vec3 normal;\n  vec3 point;\n  vec2 uv;\n  float dist;\n  vec3 color;\n  vec4 rot;\n  float id;\n  int iid;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 dir;\n  float near;\n  float far;\n  int skip_id;\n  bool is_any;\n  RayResult result;\n};\n\nRay getPrimaryRay(vec3 origin, vec2 coord, vec2 res, vec3 lookDir, float fov,\n                  float near, float far) {\n  Ray ray;\n  ray.near = near;\n  ray.far = far;\n  ray.skip_id = -1;\n  ray.origin = origin;\n  ray.dir = normalize((inverse(proj(radians(fov), res.x / res.y, near, far) *\n                               look(lookDir, vec3(0.0), vec3(0, 1, 0))) *\n                       vec4(vec2(((coord.x - res.x / 2.0)) / res.x,\n                                 ((coord.y - res.y / 2.0)) / res.y) /\n                                0.5,\n                            1.0, 1.0))\n                          .xyz);\n  return ray;\n}\n\nvec3 cubenormal(vec3 v) {\n  vec3 s = sign(v);\n  vec3 a = abs(v);\n  return mix(mix(vec3(0.0, 0.0, s.z), vec3(s.x, 0.0, 0.0), step(a.z, a.x)),\n             mix(vec3(0.0, s.y, 0.0), vec3(s.x, 0.0, 0.0), step(a.y, a.x)),\n             step(a.z, a.y));\n}\n\nbool rayAABBIntersection(inout Ray ray, in Box box) {\n  box.rotation.xyz = normalize(box.rotation.xyz);\n  vec3 boundsMin = min(box.pos, box.pos+box.size);\n  vec3 boundsMax = max(box.pos, box.pos+box.size);\n  vec3 rayDir = ray.dir;\n  vec3 rayOrigin = ray.origin;\n  \n  vec3 center = getBoxCenter(box);\n  mat4 matrix = mat4(1.);\n  \n  vec3 pos = box.pos;\n\n  pos = rotate3D(box.pos, center, box.rotation.xyz, box.rotation.w, false, matrix);\n  boundsMin = pos;\n  boundsMax = boundsMin+box.size;\n  rayDir = (matrix * vec4(ray.dir, 1.0)).xyz;\n  rayOrigin = (matrix * vec4(ray.origin, 1.0)).xyz;\n  center = (boundsMin + boundsMax) / 2.0;\n  \n  \n  vec3 tMin = (boundsMin - rayOrigin) / rayDir;\n  vec3 tMax = (boundsMax - rayOrigin) / rayDir;\n  vec3 t1 = min(tMin, tMax);\n  vec3 t2 = max(tMin, tMax);\n  float tNear = max(max(t1.x, t1.y), t1.z);\n  float tFar = min(min(t2.x, t2.y), t2.z);\n  float tClosest = tFar;\n  \n  \n  box.rotation = normalize(box.rotation);\n  \n\n  if ((tNear < tFar && tNear > ray.near)) {\n    tClosest = tNear;\n    ray.result.point = rayOrigin + rayDir * tNear;\n    ray.result.dist = abs(distance(rayOrigin, ray.result.point));\n    vec3 halfextent = boundsMax - center;\n    vec3 relpos = ray.result.point - center;\n    vec2 bounds = boundsMax.xy - boundsMin.xy;\n    vec3 uv3 = relpos.xyz / (boundsMax - boundsMin);\n    ray.result.normal = normalize(cubenormal(relpos / (halfextent)));\n\n    vec3 n = ray.result.normal;\n\n    if (n.y > 0. || n.y < 0.) {\n      ray.result.uv = vec2(uv3.x, uv3.z-1.0);\n    } else if (n.x < 0. || n.x > 0.) {\n      ray.result.uv = vec2(uv3.z, uv3.y);\n    } else {\n      ray.result.uv = vec2(uv3.x, uv3.y);\n    }\n    \n    \n    ray.result.point = (inverse(matrix) * vec4(ray.result.point, 1.0)).xyz;\n    ray.result.normal = (inverse(matrix) * vec4(ray.result.normal, 1.0)).xyz;\n    ray.result.normal = normalize(ray.result.normal);\n    ray.result.normal.y *= -1.0;\n    ray.result.rot = box.rotation;\n      \n  }\n  \n  \n\n  return tClosest != tFar;\n}\n\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\nvec3 reinhard2(vec3 x) {\n  const float L_white = 4.0;\n  return (x * (1.0 + x / (L_white * L_white))) / (1.0 + x);\n}\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\nvec3 fixBump(in vec3 worldnormal, in vec3 map_n) {\n  vec3 t = cross(worldnormal, vec3(0.0, 1.0, 0.0));\n  vec3 b = vec3(0);\n  if (length(t) == 0.0) t = cross(worldnormal, vec3(0.0, 0.0, 1.0));\n  t = normalize(t);\n  b = normalize((cross(worldnormal, t)));\n  map_n = (map_n *  2.0) - vec3(1.0, 1.0, 1.0);\n  mat3  tbn = mat3(t, b, worldnormal);\n  return normalize(tbn * map_n);\n}\n\nfloat notzero(float v) {\n  return (abs(v) <= 0.0 ? 0.001 : v);\n}\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a = roughness*roughness;\n    float a2 = a*a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\n    float nom   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = M_PI * denom * denom;\n\n    return nom / notzero(max( denom, 0.000001 ));\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n  const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n  vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n  return specularColor * AB.x + AB.y;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\nfloat microfacetDistribution(float roughness, float NdotH)\n{\n    float roughnessSq = roughness * roughness;\n    float f = (NdotH * roughnessSq - NdotH) * NdotH + 1.0;\n    return roughnessSq / notzero((M_PI * f * f) + 0.00001);\n}\nfloat GeometrySchlickGGX(float NdotV, float k)\n{\n    float nom   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return nom / notzero(denom);\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float k)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx1 = GeometrySchlickGGX(NdotV, k);\n    float ggx2 = GeometrySchlickGGX(NdotL, k);\n\n    return ggx1 * ggx2;\n}\nfloat goldness(vec3 color) {\n    vec3 gold = vec3(1.0, 0.8, 0.4);\n    float distance = length(color - gold);\n    return 1.0 - distance;\n}\n\nfloat grayness(vec3 color) {\n  float luminance = dot(vec3(0.2126, 0.7152, 0.0722), color);\n  float gray = (luminance + color.r + color.g + color.b) / 3.0;\n  return abs(luminance - gray);\n}\n\nfloat copperness(vec3 color) {\n    vec3 copper = vec3(0.9, 0.6, 0.4);\n    float distance = length(color - copper);\n    return 1.0 - distance;\n}\nvec3 getBackground(samplerCube tex, vec3 origin, vec3 dir) {\n    return texture(tex, camera(origin, dir) * vec3(0.0, 0.0, -1.0)).rgb;\n}\nvec3 fromLinear(vec3 linearRGB)\n{\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 toLinear(vec3 sRGB)\n{\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB/vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\nvec3 shadeBackground(vec3 col, vec3 origin, vec3 dir, in Light light, vec3 normal, out float dist) {\n    col /= M_PI;\n    vec3 L = normalize(light.pos);\n    float dp = max(0.0, pow(max(0.06, dot(dir, L)), 2.0));\n    float NdotL = max(0.001, dot(normal, L));\n    float far = pow(1.0 + (2.0 * (length(normal) + luma(col))), 2.0) * (1.0 - NdotL);\n    vec3 point = origin + (dir*far);\n    dist = abs(distance(light.pos, point));\n    float att = smoothstep(0.0, 1.0, (NdotL+dp)*(light.strength+(dp*light.strength*2.0)) / max(0.001, pow(dist, 1.5)));\n    col = mix(col, col*light.color, smoothstep(0.0, 1.0, dp+(1.0/max(dist, 0.001))));\n    return mix(col, col*att*light.color, 0.5);\n}\n\nvec3 extractBump3D(vec4 rot, samplerCube tex, vec3 origin, vec3 dir, float softness) {\n    vec3 color = getBackground(tex, origin, dir).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0)).xy;\n    vec3 dx = getBackground(tex, origin, dir + vec3(texelSize.x, 0., 0.)).rgb - color;\n    vec3 dy = getBackground(tex, origin, dir + vec3(0, texelSize.y, 0.)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, softness));\n\n    return normalize(n);\n}\nvec3 extractBump(vec4 rot, sampler2D tex, vec2 uv, vec3 normal) {\n    vec3 color = texture(tex, uv).rgb;\n    vec2 texelSize = 1.0 / vec2(textureSize(tex, 0)).xy;\n    vec3 dx = texture(tex, uv + vec2(texelSize.x, 0)).rgb - color;\n    vec3 dy = texture(tex, uv + vec2(0, texelSize.y)).rgb - color;\n    float l = (abs(dy.r - dx.r) + abs(dx.g - dy.g)) / 2.0;\n    vec3 n = normalize(vec3(dy.r - dx.r, dx.g - dy.g, 0.033));\n    return normalize(mix(normal, n, 0.22*smoothstep(0.0, 1.0, (l+length(abs(n)) / 2.0))));\n}\n\nfloat extractRough(vec3 color, vec2 uv, sampler2D tex) {\n    float avg = pow((color.r + color.g + color.b) / 3.0, 2.0);\n    float a = max(0.0001, 1.0 - avg);\n    vec2 tsize = vec2(textureSize(tex, 0).xy);\n    vec2 texel = 1.0 / tsize;\n    vec3 left = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 right = texture(tex, uv+(texel*vec2(-1.0, 0.0))).rgb;\n    vec3 up = texture(tex, uv+(texel*vec2(0.0, 1.0))).rgb;\n    vec3 down = texture(tex, uv+(texel*vec2(0.0, -1.0))).rgb;\n    vec3 avgAround = (left+right+up+down) / 4.0;\n    float r = (a+(distance(color, avgAround)*3.0));\n    r *= max(0.001, 1.0 - pow(0.99*luma(color), 2.0));\n    return max(0.0004, smoothstep(0.0, 1.0, r));\n}\n\nfloat extractMetallic(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    return pow((gold + copper + gray) / 3.0, 2.0);\n}\nvec3 extractSpec(vec3 color) {\n    float gold = goldness(color);\n    float copper = copperness(color);\n    float gray = grayness(color);\n    vec3 goldColor = vec3(1.0, 0.8, 0.4);\n    vec3 copperColor = vec3(0.9, 0.6, 0.4);\n    vec3 grayColor = vec3(0.2126, 0.7152, 0.0722);\n    vec3 spec = ((goldColor * gold) + (copperColor * copper) + (grayColor * gray)) / 3.0;\n    spec += (((vec3(1.0) - color) / M_PI) + luma(color)) / (M_PI*2.0);\n    return smoothstep(0.0, 1.0, pow(spec, vec3(2.1)));\n}\n\nvec3 PBR(\n    Ray ray,\n    Light light,\n    samplerCube envtex,\n    vec3 normal,\n    sampler2D tex\n) {\n  vec3 albedo = texture(tex, ray.result.uv).rgb;\n  vec3 diffuse = albedo / M_PI;\n  vec3 col = vec3(0.0);\n  float metallic = extractMetallic(albedo);\n  float roughness = extractRough(albedo, ray.result.uv, tex);\n  vec3 spec = extractSpec(albedo);\n  vec3 f0 = mix(vec3(0.04), diffuse, smoothstep(0.0, 1.0, metallic*2.0));\n  vec3 viewdir = normalize(ray.origin - ray.result.point);\n  vec3 reflection_dir = normalize(reflect(viewdir, normal) * -1.);\n  vec3 env = texture(envtex, reflection_dir).rgb;\n  float NdotV = abs(dot(normal, viewdir)) + 0.000001;\n  vec3 envBRDF = EnvBRDFApprox(spec/M_PI, pow(roughness, 2.0), NdotV);\n  vec3 F = fresnelSchlickRoughness(NdotV, f0, roughness);\n  vec3 indirectSpecular = env * (F * envBRDF.x + envBRDF.y);\n  col += indirectSpecular;\n  float glossy = max(0.0, 1.0 - (roughness*1.1));\n  \n  // light\n  vec3 L = normalize(ray.result.point - light.pos);\n  vec3 H = normalize(L + viewdir);\n  float HdotV = clamp(dot(H, viewdir),0.000001, 1.0);\n  float NdotH = clamp(dot(normal, H), 0.000001, 1.0);\n  float NdotL = max(0.0, dot(normal, L));\n  float dist = abs(distance(ray.result.point, light.pos));\n  float att = NdotL*max(0.000001, (pow(light.strength, 2.0) / max(0.0001, pow(dist, 2.0))));\n  att /= M_PI*(0.5+smoothstep(0.0, 1.0, att));\n  vec3 light_reflect_dir = reflect(-L, normal);\n  float VdotR = max(dot(viewdir, light_reflect_dir), 0.0);\n  float specFres = (glossy * pow(VdotR, 64.0)) / M_PI;\n  vec3 fresnel = fresnelSchlick(HdotV, f0);\n  float D = microfacetDistribution(roughness, NdotH);\n  float S = DistributionGGX(normal, H, roughness);\n  float G = GeometrySmith(normal, viewdir, L, roughness);\n  float Fsd = (4.0 * NdotV * NdotL);\n  vec3 specularity = ((fresnel * S * G * D) / notzero(Fsd)) / M_PI;\n  vec3 kd = (vec3(1.0) - specularity) * (1.0 - metallic);\n  col += (kd * diffuse + specularity + specFres) * ((light.color * att));;\n  return max(vec3(0.0), col);\n}","name":"Common","description":"","type":"common"}]}