{"ver":"0.1","info":{"id":"sltBDH","date":"1663102209","viewed":276,"name":"Drawing markers","username":"Alpaga","description":"Drawing with drying ink.","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"slKyz3","parentname":"Drawing markers constant thickne"},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Click to erase, for instance when resizing.\n\n#define STEPS 150\n#define FAR 30.0\n//#define AA\n\nconst float fov = 35.0;\nconst float cameraSpeed = 0.25;\n\nint lightNumber = 3;\nvec3 ambient = vec3(0.1);\nvec3 lightPosition[3] = vec3[](\n    vec3(4.0,6.0,-1.0),\n    vec3(-2.0,1.0,-2.0),\n    vec3(-3.0,4.0,6.0));\nvec3 lightColor[3] = vec3[](\n    vec3(1.0,1.0,0.8),\n    vec3(1.0,1.0,0.9),\n    vec3(1.0));\n\nvec2 delta = vec2(0.0,0.001);\n\nfloat sdTable(vec3 p) {\n    return p.y + 0.2 + 0.03*texture(iChannel1, 0.2*p.xz).r;\n}\n\n// sdBox from https://iquilezles.org/articles/distfunctions/\nfloat sdCanvas(vec3 p) {\n    p.y += 0.1;\n    vec3 q = abs(p) - vec3(canvasSize,0.07,canvasSize);\n    float d = length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - 0.03;\n    p.z+=p.y;\n    vec2 uv = 0.5*(p.xz/canvasSize+1.0);\n    float noise = texture(iChannel2, uv).r;\n\n    return d + 0.001*noise;\n}\n\n// sdRoundedCylinder and sdCapsule from \n// https://iquilezles.org/articles/distfunctions/\nfloat sdPen(vec3 p, int id) {\n    p.xz -= penPositions[id].xy;\n    p.y -= penRadius + penPositions[id].z;\n    p = penTransforms[id]*p;\n    \n    // Rounded cylinder\n    vec2 d = vec2(length(p.xz) - penRadius + 0.01,\n        abs(p.y-0.25-brushOut) - 0.25);\n    float dCyl = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - .025;\n    \n    // Capsule\n    float noise = 0.005 * texture(iChannel2,0.1*(p.xz+p.y)).r;\n    p.y -= clamp(p.y, 0.0, 0.5);\n    float dCap = length(p)-penRadius-noise;\n    \n    return min(dCyl, dCap);\n}\n\nfloat sdPens(vec3 p, out int id) {\n    float minD = 1000.0;\n    for(int i=0; i<penNumber; i++) {\n        float tmp = sdPen(p, i);\n        if(tmp<minD) {\n            minD = tmp;\n            id = i;\n        }\n    }\n    return minD;\n}\nfloat sd(vec3 p, out int id) {\n    float minD = 10000.0;\n    float d;\n    \n    d = sdTable(p);\n    if(d<minD) {\n        minD = d;\n        id = -2;\n    }\n    d = sdCanvas(p);\n    if(d<minD) {\n        minD = d;\n        id = -1;\n    }\n    int penId;\n    d = sdPens(p, penId);\n    if(d<minD) {\n        minD = d;\n        id = penId;\n    }\n    \n    return minD;\n}\n\n// albedo in .rgb channels\n// reflectivity in .a channel\nvec4 material(vec3 p, int id) {\n    switch(id) {\n        case -2: //Table\n            vec4 tex = texture(iChannel1, 0.2*p.xz);\n            vec3 col = tex.rgb;\n            col = col*col;// Gamma\n            return vec4(col,0.3*tex.b);\n        case -1: //Canvas\n            vec2 uv = 0.5*(p.xz/canvasSize+1.0);\n            vec4 ink = texture(iChannel0, uv);\n            return ink;\n        default: //Pens\n            p.xz -= penPositions[id].xy;\n            p.y -= penRadius + penPositions[id].z;\n            p = penTransforms[id]*p;\n            vec3 c = penColors[id].rgb;\n            if(p.y<brushOut-0.02) {\n                // Brush\n                return vec4(c,0.01);\n            } else {\n                // Body\n                float a = atan(p.z,p.x);\n                float b = cos(6.0*a);\n                b = 1.0+0.5*b*b*b;\n                return vec4(b*c.rgb,0.2);\n            }\n    }\n}\n\nvec3 normal(vec3 p) {\n    int id;\n    float d = sd(p,id);\n    return normalize(vec3(\n        sd(p+delta.yxx,id),\n        sd(p+delta.xyx,id),\n        sd(p+delta.xxy,id))-d);\n}\n\nfloat march(vec3 start, vec3 dir, out int id) {\n\tfloat total = 0.0, d = 1.0;\n    float epsilon = 0.5/iResolution.y;\n    int i=0;\n    for(; i<STEPS; i++) {\n        if(d<epsilon || total>FAR) break;\n        d = sd(start + total*dir,id);\n        total += d;\n    }\n    if(total>FAR || i==STEPS) id = -100;\n    return total;\n}\n\nfloat lightMarch(vec3 start, vec3 dir, float dist) {\n\tfloat d = 1.0, total = 0.0;\n    float epsilon = 0.5/iResolution.y;\n    float minD = 1000.0;\n    int id;\n    for(int i=0; i<STEPS; i++) {\n        if(d<epsilon || total>dist) break;\n        d = sd(start + total*dir,id);\n        total += d;\n        minD = min(minD,d);\n    }\n    return minD;\n}\nfloat shadow(vec3 p, vec3 toLight, float distToLight) {\n    float minD = lightMarch(p+0.1*toLight, toLight, distToLight-0.1);\n    return smoothstep(0.0,0.05,minD);\n}\n\nvec3 rayColor(vec3 start, vec3 dir) {\n    vec3 coef = vec3(1.0);\n\n    int id;\n    float d = march(start, dir,id);\n        \n    if(id == -100) {//No ray intersection\n        return vec3(0.0);\n    } else {\n     \tvec3 p = start + d * dir;\n        \t            \n        vec3 normal = normal(p);\n        vec3 toEye = normalize(start - p);\n        vec4 mat = material(p,id);\n        \n        vec3 col = ambient*mat.rgb;\n        \n        for(int i=0; i<lightNumber; i++) {\n            vec3 toLight = lightPosition[i]-p;\n            float toLightDist = length(toLight);\n            vec3 toLightNorm = toLight / toLightDist;\n\n            // Diffuse\n            vec3 diff = mat.rgb * max(dot(toLightNorm, normal), 0.0);\n            // Specular\n            vec3 h = normalize(toEye + toLightNorm);\n            float spec = mat.a * pow(max(dot(h,normal),0.0), 100.0);\n\n            // Shadow\n            float sh = shadow(p, toLightNorm, toLightDist);\n\n            col += sh*(diff + spec)*lightColor[i]/(1.0+0.2*toLightDist*toLightDist)*2.;\n        }\n        \n        // Reflection of sky light\n        vec3 ref = reflect(-toEye, normal);\n        float sh = shadow(p, ref, 10.0);\n        col += sh * vec3(mat.a);\n        \n        return col * exp(-0.01*d*d);\n    }\n}\n\nmat3 setupCamera(vec3 cam, vec3 center, vec3 up) {\n \tvec3 w = normalize(cam-center);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n    return mat3(u,v,w);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    initPenColors();\n    initPenPositions(iTime);\n    initPenTransforms(iTime);\n    \n    vec3 cam = vec3(\n        cos(cameraSpeed*iTime),\n        2.0 + 1.5*sin(cameraSpeed*iTime),\n        2.5+0.5*sin(cameraSpeed*iTime));\n    mat3 m = setupCamera(cam, vec3(0.0,0.0,0.5), vec3(0.0,1.0,0.0));\n    \n    vec3 color = vec3(0.0);\n\n    #ifdef AA\n    for(float i=-0.25; i<0.5; i+=0.5) {\n        for(float j=-0.25; j<0.5; j+=0.5) {\n            vec2 uv = 2.0*(fragCoord + vec2(i,j) - 0.5 * iResolution.xy)/iResolution.y;\n            vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    \n            vec3 dir = normalize(m*pix);\n    \n            color += rayColor(cam, dir);\n        }\n    }\n    color /= 4.0;\n    #else\n    vec2 uv = 2.0*(fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(tan(0.5*fov*0.01745)*uv,-1.0);\n    vec3 dir = normalize(m*pix);\n\n    color = rayColor(cam, dir);\n    #endif\n    \n    color = pow(color, vec3(0.45));\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// The drawing on canvas happens here.\n// fragColor.rgb stores the color, fragColor.a stores the reflectivity\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initPenColors();\n    initPenPositions(iTime);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    if(iFrame==0 || iMouse.w>0.0) {\n        // Paper\n        fragColor = vec4(vec3(1.0),0.02);\n    } else {\n        vec2 pos = canvasSize*(2.0*uv-1.0);\n\n        // Color at previous frame\n        fragColor = texture(iChannel0,uv);\n        \n        // Update color if a pen is there\n        for(int i=0; i<penNumber; i++) {\n            vec3 pen = penPositions[i];\n            float d = length(pos-pen.xy);\n            fragColor = mix(penColors[i],fragColor,\n            min(1.0,d/(max(0.0,-pen.z/maxSinking)*penRadius)));\n        }\n        \n        // Ink dries\n        fragColor.a = max(fragColor.a*0.98, 0.02);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Palettes from coolors.co\n#define PALETTE palette4\nconst int palette1[5] = int[](0x390099,0x9e0059,0xff0054,0xff5400,0xffbd00);\nconst int palette2[5] = int[](0xef476f,0xffd166,0x06d6a0,0x118ab2,0x073b4c);\nconst int palette3[5] = int[](0xd7263d,0xf46036,0x2e294e,0x1b998b,0xc5d86d);\nconst int palette4[5] = int[](0xa9e5bb,0xfcf6b1,0xf7b32b,0xf72c25,0x2d1e2f);\nconst int palette5[5] = int[](0x07beb8,0x3dccc7,0x68d8d6,0x9ceaef,0xc4fff9);\n\nconst float canvasSize = 1.5;\n\nconst float loopRadius = 0.4;\nconst float loopNumber = 5.0;\n\nconst int penNumber = 4;\n\nconst float speed = 0.3;\nconst float brushOut = 0.1;\nconst float penRadius = .08;\nconst float maxSinking = 0.02;\n\nvec4 penColors[penNumber];\nvec3 penPositions[penNumber];\nmat3 penTransforms[penNumber];\n\n// Position of pen with index *id* at given *time*\nvec3 penPosition(int id, float time) {\n    float t = speed*time;\n    float f = 6.2832 * float(id)/float(penNumber);\n    \n/************************************************/\n/* Play here to change the drawing.             */\n/* Negative thickness means that the pen is up. */\n    vec2 position = vec2(\n        (1.0-loopRadius)*cos(t + 2.0*f) + loopRadius*cos((loopNumber+1.0)*(t+f) + f),\n        (1.0-loopRadius)*sin(t + 2.0*f) + loopRadius*sin((loopNumber+1.0)*(t+f) + f));\n        \n    float thickness = .5+0.5*cos(3.0*loopNumber*(t+f));\n//  float thickness = .5+0.45*cos(3.0*loopNumber*(t+f+1.5));\n/************************************************/\n    \n    float elevation = -min(maxSinking,min(thickness,maxSinking*thickness));\n    return vec3((canvasSize - 0.2)*position,elevation);\n}\n\n// Rotation of pen so that it is slanted\n// towards its moving direction.\nmat3 penTransform(int id, float time) {\n    vec2 u = (penPosition(id, time+0.4) - penPosition(id, time)).yx;\n    float u2 = dot(u,u);\n    float c = 1.0/sqrt(1.0+u2);\n    float k = (1.-c)/u2;\n    return mat3(\n        c+k*u.x*u.x, c*u.y,  -k*u.x*u.y,\n             -c*u.y,     c,      -c*u.x,\n         -k*u.x*u.y, c*u.x, c+k*u.y*u.y);\n}\n\nvec4 htmlToRgb(int c) {\n    vec3 col = vec3(float((c >> 16) & 0xff), float((c >> 8) & 0xff), float(c & 0xff))/255.0;\n    col = col*col;// Gamma\n    return vec4(col, 0.8);\n}\nvoid initPenColors() {\n    for(int i=0; i<penNumber; i++) {\n        penColors[i] = htmlToRgb(PALETTE[i]);\n    }\n}\nvoid initPenPositions(float time) {\n    for(int i=0; i<penNumber; i++) {\n        penPositions[i] = penPosition(i,time);\n    }\n}\nvoid initPenTransforms(float time) {\n    for(int i=0; i<penNumber; i++) {\n        penTransforms[i] = penTransform(i,time);\n    }\n}","name":"Common","description":"","type":"common"}]}