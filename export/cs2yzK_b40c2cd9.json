{"ver":"0.1","info":{"id":"cs2yzK","date":"1690006356","viewed":86,"name":"Game of Life thing","username":"evpevdev","description":"Press space to pause and c to clear the canvas. The background will turn purple when paused.\n\nAll parameters that you can change are in common.","likes":1,"published":3,"flags":48,"usePreview":0,"tags":["cellularautomaton"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nfloat grid(float size, float width, vec2 uv){\n    return min(step(mod(uv.x, size), width) + step(mod(uv.y, size), width), 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.x / iResolution.y;\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    float pixSize = 1.0 / iResolution.y;\n    float pixSizeScaled = pixSize / canvasScale;\n    \n    bool isPaused = texelFetch(iChannel1, ivec2(KEY_SPACE, 2), 0).x == 1.0;\n    \n    float gridVal = grid(pixSizeScaled, pixSize*2.0,  uv);\n    vec3 bgCol = isPaused ? bgColourPaused : vec3(0.0);\n    vec3 bg = bgCol + vec3(gridVal * 0.1);\n    \n    vec3 cellCol = texture(iChannel0, st * canvasScale).rgb; \n    vec3 col =  mix(bg, cellCol, cellCol.g);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float isCellAlive(vec2 st){\n    // Allows for cells to loop\n    st = mod(st, canvasScale);\n    return float(texture(iChannel0, st).g + texture(iChannel0, st).b + texture(iChannel0, st).r > 0.0);\n}\n\nint getNeighbours(vec2 st, vec2 pixSize){\n    // Get adjacent and diagonal neighbours\n    // Account for aspect ratio\n    pixSize.x /= iResolution.x/iResolution.y;\n    int neighbours = int(isCellAlive(vec2(st.x-pixSize.x, st.y-pixSize.y))\n                   + isCellAlive(vec2(st.x, st.y-pixSize.y))\n                   + isCellAlive(vec2(st.x+pixSize.x, st.y-pixSize.y))\n                   + isCellAlive(vec2(st.x+pixSize.x, st.y))\n                   + isCellAlive(vec2(st.x+pixSize.x, st.y+pixSize.y))\n                   + isCellAlive(vec2(st.x, st.y+pixSize.y))\n                   + isCellAlive(vec2(st.x-pixSize.x, st.y+pixSize.y))\n                   + isCellAlive(vec2(st.x-pixSize.x, st.y))\n                   );\n    \n    return neighbours;\n    \n}\n\n\nint getNeighbours(vec2 st, vec2 pixSize, int radius){\n    // Account for aspect ratio\n    pixSize.x /= iResolution.x/iResolution.y;\n    int neighbours = 0;\n    for (int x=-radius; x <= radius; x++){\n        for (int y=-radius; y <= radius; y++){\n            neighbours += int(isCellAlive(vec2(st.x + pixSize.x*float(x), st.y + pixSize.y*float(y))));\n        }\n    }\n    // Don't include yourself as a neighbour\n    neighbours -= int(isCellAlive(st));\n    return neighbours;\n}\n\n\nbool maze(vec2 st, vec2 pixSize){\n    int neighbours = getNeighbours(st, pixSize, 2);\n    return (bool(isCellAlive(st)) && (neighbours<13 && neighbours>0)) || (neighbours<5 && neighbours>0);\n}\n\nbool plant(vec2 st, vec2 pixSize){\n    int neighbours = getNeighbours(st, pixSize);\n    return (bool(isCellAlive(st)) && (neighbours>1)) || neighbours==3 ;\n}\n\nbool conway(vec2 st, vec2 pixSize){\n    // Alive cell will stay alive if it has 2 or 3 live neighbours.\n    // Dead cell will come to life if it has 3 neighbours.\n    // All other cells will be dead.\n    int neighbours = getNeighbours(st, pixSize);\n    return (bool(isCellAlive(st)) && (neighbours==2 || neighbours==3)) || neighbours==3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord/iResolution.xy;\n    vec2 uv = fragCoord/iResolution.y;\n    vec2 pixSize = vec2(1.0) / iResolution.yy;\n    vec2 canvasResolution = iResolution.xy * canvasScale;\n    \n    vec2 m = iMouse.xy/iResolution.y * canvasScale;\n    m = m - mod(m, pixSize);\n    \n    bool isPaused = texelFetch(iChannel1, ivec2(KEY_SPACE, 2), 0).x == 1.0;\n    bool clearPressed = texelFetch(iChannel1, ivec2(KEY_C, 0), 0).x == 1.0;\n    bool shiftPressed = texelFetch(iChannel1, ivec2(KEY_SHIFT, 0), 0).x == 1.0;\n    bool ctrlPressed = texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x == 1.0;\n\n    \n    vec3 col = vec3(0.0); \n    // Only render inside of the canvas resolution\n    if (!(fragCoord.x > canvasResolution.x || fragCoord.y > canvasResolution.y) && !clearPressed){\n    \n        col.g = texture(iChannel0, st).g;\n\n        // is true if we are switching to next generation this frame\n        // If generationTime is below 0, it will run as fast as it can.\n        bool doNextGeneration = mod(iTime - iTimeDelta, generationTime) >= mod(iTime, generationTime)\n                                || generationTime < 0.0;\n        doNextGeneration = doNextGeneration && !isPaused;\n\n        if (doNextGeneration){\n            \n            bool isAlive = conway(st, pixSize);\n            col.g = float(isAlive);\n        }\n        \n        // Handle drawing\n        bool isMouseDown = iMouse.z > 0.0;\n        \n        // Will be -1 if erasing\n        float eraseMultiplier = (float(shiftPressed) - 0.5) * -2.0;\n        float drawAmount = step(length(m-uv+pixSize/2.0), brushSize*pixSize.y) * float(isMouseDown);\n        drawAmount *= eraseMultiplier;\n        col.g = col.g + drawAmount;\n        col = clamp(col , 0.0, 1.0);\n    }\n    \n    \n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define brushSize 2.0\n#define canvasScale 1.0\n// If this is below 0, the simulation will run as fast as it can\n#define generationTime -1.0\n\nconst int KEY_SPACE = 32;\nconst int KEY_C = 67;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL = 17;\n\n\n\n// Background colour cannot have any green because green is treated as a cell.\nconst vec3 bgColourPaused = vec3(0.1, 0.0, 0.1);","name":"Common","description":"","type":"common"}]}