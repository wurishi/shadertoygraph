{"ver":"0.1","info":{"id":"flSfzG","date":"1652406103","viewed":129,"name":"Interactive Mandelbrot Infinite","username":"kugge","description":"Zoom with up/down keys\nUse mouse to change position\nInfinite precision","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["test","julia","mandelbrot","complex"],"hasliked":0,"parentid":"NtjBDm","parentname":"Interactive Mandelbrot set zoom"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxIter 16.*25.\n#define MAX_NORM 10\n\n#define ZOOM_SPEED 0.1\n#define ROT_SPEED 0.1\n#define SPEED 0.1\n\n#ifdef GL_ES\nprecision highp int;\n#endif\n\n\n///// NEEDED FOR COMPUTATION\nint real[vals];\nint imaginary[vals];\nint maxNorm[vals];\n/////\n\n// Color palette\nvec3 color(float v) {\n    vec3 co;\n    if(v == 1.)       co = vec3(25, 7, 26);\n    else if(v == 2.)  co = vec3(9, 1, 47);\n    else if(v == 3.)  co = vec3(4, 4, 73);\n    else if(v == 4.)  co = vec3(0, 7, 100);\n    else if(v == 5.)  co = vec3(12, 44, 138);\n    else if(v == 6.)  co = vec3(24, 82, 177);\n    else if(v == 7.)  co = vec3(57, 125, 209);\n    else if(v == 8.)  co = vec3(134, 181, 229);\n    else if(v == 9.)  co = vec3(211, 236, 248);\n    else if(v == 10.) co = vec3(241, 233, 191);\n    else if(v == 11.) co = vec3(248, 201, 95);\n    else if(v == 12.) co = vec3(255, 170, 0);\n    else if(v == 13.) co = vec3(204, 128, 0);\n   \telse if(v == 14.) co = vec3(153, 87, 0);\n    else if(v == 15.) co = vec3(106, 52, 3);\n    return co / 256.0;;\n}\n\n\n// Complex multiplication\nvoid cMul(int x[vals], int y[vals], int a[vals], int b[vals]) {\n\tint mul1[vals];\n    int mul2[vals];\n    /// REAL PART\n    mul(x, a);\n\tassign(mul1, result);\n    mul(y, b);\n\tassign(mul2, result);\n    negate(mul2);\n    add(mul1, mul2);\n\tassign(real, result);\n    /// IMAGINARY PART\n    mul(x, b);\n\tassign(mul1, result);\n    mul(y, a);\n\tassign(mul2, result);\n    add(mul1, mul2);\n    assign(imaginary, result);\n}\n\n// Iterate mandelbrot sequence z² + c\nfloat iterMandelbrot(int x[vals], int y[vals]) { \n    float i = 0.;\n    int zr[vals]; // Re(u_0)\n    int zi[vals]; // Im(u_0)\n    int h[vals]; // placeholder\n    zero(zr, vals);\n    zero(zi, vals);\n    for (i = 0.; i<maxIter; ++i) {\n        dotp(zr, zi, zr, zi); // |z|²\n        if (compare(result, maxNorm)) break;\n        // real = Re(z²), Imaginary = Re(z²)\n        cMul(zr, zi, zr, zi);\n        // Re(u_1) = Re(u_0²) + Re(c)\n        add(real, x);\n        assign(zr, result);\n        // Im(u_1) = Im(u_0²) + Im(c)\n        add(imaginary, y);\n        assign(zi, result);\n    }\n\n    return i;\n}\n\nint[vals] zoom;\nint[vals] px; // pos x\nint[vals] py; // pos y\nfloat rot;\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    maxNorm[vals-1] = MAX_NORM;\n    vec2 uv = fragCoord/iResolution.xy; // Normalize\n    uv -= 0.5; // Center\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 2.5;\n    \n    // Rotation\n    rot = texelFetch(iChannel0, ivec2(0, 0), 0).y;\n    mat2 rotmat = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n    uv *= rotmat;\n    \n    // Load vals\n    // Zoom\n    loadFloat(texelFetch(iChannel0, ivec2(0, 0), 0).x);\n    assign(zoom, result);\n    // Center\n    loadFloat(texelFetch(iChannel0, ivec2(0, 0), 0).z);\n    assign(px, result);\n    loadFloat(texelFetch(iChannel0, ivec2(0, 0), 0).w);\n    assign(py, result);\n\n\n    // Here we need to use improved int[vals] floats.\n    int[vals] uvx;\n    int[vals] uvy;\n    loadFloat(uv.x);\n    assign(uvx, result);\n    loadFloat(uv.y);\n    assign(uvy, result);\n    // Zoom\n    mul(uvx, zoom);\n    assign(uvx, result);\n    mul(uvy, zoom);\n    assign(uvy, result);\n    // Center\n    add(uvx, px);\n    assign(uvx, result);\n    add(uvy, py);\n    assign(uvy, result);\n\n\n    float d = iterMandelbrot(uvx, uvy);\n    vec3 col = color(mod(d, 16.));\n    \n    fragColor = vec4(col, 1.);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define maxIter 256.\n#define maxNorm 1000.\n\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define ZOOM_SPEED 0.99\n#define ROT_SPEED 0.01\n#define SPEED 0.05\n\nfloat zoom;\nfloat rot;\nvec2 pos;\n\nvoid handleKeyboard() {\n    if (texelFetch(iChannel1, ivec2(KEY_UP, 0), 0).x == 1.) zoom *= ZOOM_SPEED;\n    if (texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x == 1.) zoom /= ZOOM_SPEED;\n    rot += texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * ROT_SPEED;\n    rot -= texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * ROT_SPEED;   \n}\n\nvoid handleMouse() {\n    vec2 uv = iMouse.xy/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    if(iMouse.z > 0.0) pos += uv * SPEED* zoom;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    zoom = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    rot = texelFetch(iChannel0, ivec2(0, 0), 0).y;\n    pos.x = texelFetch(iChannel0, ivec2(0, 0), 0).z;\n    pos.y = texelFetch(iChannel0, ivec2(0, 0), 0).w;\n    if (zoom == 0.) zoom = 1.;\n   \n    handleKeyboard();\n    handleMouse();\n    \n    fragColor = vec4(zoom, rot, pos);\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"////////////////////////////////////////////\n// https://github.com/alexozer/glsl-arb-prec/blob/master/arb-precision.glsl\n////////////////////////////////////////////\n\n/* integers per arbitrary-precision number */\n#define vals 6\n\n/* power of 10 one larger than maximum value per int\n   A value of 10000 seems to work the best\n   */\n#define limit 20000\n\nconst float limitFlt = float(limit);\n\nint result[vals];\n\n#define zero(x, len) for(int i=0;i<len;i++){x[i]=0;}\n#define assign(x, y) for(int i=0;i<vals;i++){x[i]=y[i];}\n#define negate(x) for(int i = 0; i < vals; i++) { x[i] = -x[i]; }\n\nbool signp(int[vals] a) {\n\treturn (a[vals-1] >= 0);\n}\n\nint keepVal, carry;\n\nvoid roundOff(int x) {\n\tcarry = x / limit;\n\tkeepVal = x - carry * limit;\n}\n\nvoid add(int[vals] a, int[vals] b) {\n\tbool s1 = signp(a), s2 = signp(b);\n\n\tcarry = 0;\n\n\tfor(int i = 0; i < vals-1; i++) {\n\t\troundOff(a[i] + b[i] + carry);\n\n\t\tif(keepVal < 0) {\n\t\t\tkeepVal += limit;\n\t\t\tcarry--;\n\t\t}\n\n\t\tresult[i] = keepVal;\n\t}\n\troundOff(a[vals-1] + b[vals-1] + carry);\n\tresult[vals-1] = keepVal;\n\t\n\tif(s1 != s2 && !signp(result)) {\n\t\tnegate(result);\n\n\t\tcarry = 0;\n\n\t\tfor(int i = 0; i < vals; i++) {\n\t\t\troundOff(result[i] + carry);\n\n\t\t\tif(keepVal < 0) {\n\t\t\t\tkeepVal += limit;\n\t\t\t\tcarry--;\n\t\t\t}\n\n\t\t\tresult[i] = keepVal;\n\t\t}\n\n\t\tnegate(result);\n\t}\n}\n\nvoid mul(int[vals] a, int[vals] b) {\n\tbool toNegate = false;\n\n\tif(!signp(a)) {\n\t\tnegate(a);\n\t\ttoNegate = !toNegate;\n\t}\n\tif(!signp(b)) {\n\t\tnegate(b);\n\t\ttoNegate = !toNegate;\n\t}\n\n\tconst int lenProd = (vals-1)*2+1;\n\tint prod[lenProd];\n\tzero(prod, lenProd);\n\n\tfor(int i = 0; i < vals; i++) {\n\t\tfor(int j = 0; j < vals; j++) {\n\t\t\tprod[i+j] += a[i] * b[j];\n\t\t}\n\t}\n\n\tcarry = 0;\n\tconst int clip = lenProd - vals;\n\tfor(int i = 0; i < clip; i++) {\n\t\troundOff(prod[i] + carry);\n\t\tprod[i] = keepVal;\n\t}\n\n\tif(prod[clip-1] >= limit/2) {\n\t\tcarry++;\n\t}\n\n\tfor(int i = clip; i < lenProd; i++) {\n\t\troundOff(prod[i] + carry);\n\t\tprod[i] = keepVal;\n\t}\n\n\tfor(int i = 0; i < lenProd - clip; i++) {\n\t\tresult[i] = prod[i+clip];\n\t}\n\n\tif(toNegate) {\n\t\tnegate(result);\n\t}\n}\n\nvoid loadFloat(float f) {\n\tfor(int i = vals - 1; i >= 0; i--) {\n\t\tint fCurr = int(f);\n\t\tresult[i] = fCurr;\n\t\tf -= float(fCurr);\n\t\tf *= limitFlt;\n\t}\n}\n\n///////////////////////////////////////////////\n// Made by Kugge\n//////////////////\n// Dot product\nvoid dotp(int x[vals], int y[vals], int a[vals], int b[vals]) {\n    int mul1[vals];\n    int mul2[vals];\n    mul(x, a);\n\tassign(mul1, result);\n    mul(y, b);\n\tassign(mul2, result);\n    add(mul1, mul2);\n}\n\n// x >= y ?\nbool compare(int x[vals], int y[vals]) {\n    return x[vals-1] > y[vals-1];\n}\n","name":"Common","description":"","type":"common"}]}