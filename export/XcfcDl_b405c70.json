{"ver":"0.1","info":{"id":"XcfcDl","date":"1721738158","viewed":475,"name":"Painting with Fluids","username":"chronos","description":"Combining my Mixbox Pigment Pain Mixing shader with a fluid simulation brush.\nMixbox library: https://scrtwpns.com/mixbox/","likes":38,"published":1,"flags":32,"usePreview":0,"tags":["simulation","interactive","fluid","color","paint","draw","colour","drawing","buffer","pigment","mixbox"],"hasliked":0,"parentid":"4X2SDd","parentname":"Mixbox Pigment Paint Mixing"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Painting with Fluids by chronos\n    ---------------------------------------------------\n    \n    Combining my Mixbox Pigment Pain Mixing shader with a fluid simulation brush.\n    \n    Wrote the fluid simulation myself, but it is closely based on the implementation in\n    \"simple detailed fluid\" by lomateron : https://www.shadertoy.com/view/sl3Szs\n    \n    The code modifications from the forked shader are currently very hacked together, so the code quality isn't great, sorry! :/\n    \n    The added fluid simulation is in Buffer C\n    \n    There are some glitches remaining still :)\n\n\n    Forked shader description:\n    -------------------------------------------------------------\n    \n        Mixbox Pigment Paint Mixing by chronos\n\n        -------------------------------------------------------------\n\n        I tried to make use of the Mixbox library.\n        Unfortunately it includes a LUT texture that I cannot easily import to shadertoy,\n        so I just made my own by linearly interpolating the corners.\n        Unfortunately, that's not a very good approximation, so it is way off.\n        But at least it kindof works, so now it should just be a matter of improving the hardcoded LUT :)\n\n\n        https://scrtwpns.com/mixbox/\n        https://github.com/scrtwpns/mixbox/tree/master/shaders\n        https://github.com/scrtwpns/mixbox/blob/master/shaders/mixbox_lut.png\n\n        -------------------------------------------------------------\n\n        IMPORTANT NOTE!\n\n        This shader includes the \"mixbox.glsl\" shader code\n        which is under its own license (Creative Commons Attribution-NonCommercial 4.0), \n        which is included along with the code in Buffer D.\n\n        The original authors (Sarka Sochorova and Ondrej Jamriska) are credited,\n        there is an indication that the code has been modified,\n        and the code is not used for commercial purposes.\n\n\n        -------------------------------------------------------------\n\n\n\n        Please excuse the poor code quality (mine, not theirs), it was just hastily thrown together :)\n\n*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float mouse_down = float(iMouse.z > 0.);\n    \n    vec3 color = vec3(0.075);\n    \n    if(uv.x < palette_edge)\n    {\n        color = texture(iChannel1, fragCoord/iResolution.xy).rgb;\n        \n        {\n            float height = texture(iChannel3, uv).w;\n            float splash_alpha = texture(iChannel3, fragCoord/iResolution.xy).z;// * float(height > 0.75);\n\n\n            vec4 paint = texelFetch(iChannel2, ivec2(fragCoord), 0).rgba;\n            vec3 splash_color = pigments[int(paint.a)].linRGB;\n            if(int(paint.a) == 13) // rainbow brush\n            {\n                vec3 C = mix(pigments[int(iTime)%12].linRGB, pigments[(int(iTime)+1)%12].linRGB, fract(iTime));\n                splash_color = C;\n            }\n            color = mix(color, splash_color, splash_alpha);\n        }\n    }\n    \n    for(float i = 0.; i < 7.; i++)\n    {\n        float y = 0.8-(3.5*i)/13.;\n        float x = 1.5;\n        float r = 0.075;\n        color = mix(color, vec3(0.01), smoothstep(0.01, 0., length(uv-vec2(x,y))-r*1.1));\n\n        if(texture(iChannel2, vec2(0)).a == i)\n            color = mix(color, vec3(1), smoothstep(0.01, 0., length(uv-vec2(x,y))-r));\n\n        color = mix(color, pigments[int(i)].linRGB, smoothstep(0.01, 0., length(uv-vec2(x,y))-r*0.9));\n    }\n    \n    for(float i = 0.; i < 6.; i++)\n    {\n        float y = 0.65-(3.5*i)/13.;\n        float x = 1.675;\n        float r = 0.075;\n        color = mix(color, vec3(0.01), smoothstep(0.01, 0., length(uv-vec2(x,y))-r*1.1));\n\n        if(texture(iChannel2, vec2(0)).a == i+7.)\n            color = mix(color, vec3(1), smoothstep(0.01, 0., length(uv-vec2(x,y))-r));\n\n        color = mix(color, pigments[int(i+7.)].linRGB, smoothstep(0.01, 0., length(uv-vec2(x,y))-r*0.9));\n    }\n    \n    {\n        float y = 0.65-(3.5*5.75)/13.;\n        float x = 1.675;\n        float r = 0.075;\n        color = mix(color, vec3(0.01), smoothstep(0.01, 0., length(uv-vec2(x,y))-r*1.1));\n\n        if(texture(iChannel2, vec2(0)).a == 6.+7.)\n            color = mix(color, vec3(1), smoothstep(0.01, 0., length(uv-vec2(x,y))-r));\n\n        float k = ((dot(uv-vec2(x,y), vec2(sqrt(2.))))/r + sqrt(2.)) * 3.;\n        vec3 C = mix(pigments[int(k)].linRGB, pigments[int(k)+1].linRGB, fract(k));\n\n        color = mix(color, C, smoothstep(0.01, 0., length(uv-vec2(x,y))-r*0.9));\n    }\n\n    color = sRGBencode(color);\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\nconst float palette_edge = 1.35;\n\nstruct Pigment\n{\n    vec3 sRGB256;\n    vec3 sRGB;\n    vec3 linRGB;\n};\n\n// Pigment\t\t                               RGB\t             Float RGB\t                           Linear RGB\nconst Pigment Cadmium_Yellow\t\t = Pigment(vec3(254, 236, 0)\t, vec3(0.996, 0.925, 0.0)\t      , vec3(0.991, 0.839, 0.0));\nconst Pigment Hansa_Yellow\t\t = Pigment(vec3(252, 211, 0)\t, vec3(0.988, 0.827, 0.0)\t      , vec3(0.973, 0.651, 0.0));\nconst Pigment Cadmium_Orange\t\t = Pigment(vec3(255, 105, 0)\t, vec3(1.0, 0.412, 0.0)\t      , vec3(1.0, 0.141, 0.0));\nconst Pigment Cadmium_Red\t\t     = Pigment(vec3(255, 39, 2)\t, vec3(1.0, 0.153, 0.008)\t      , vec3(1.0, 0.02, 0.001));\nconst Pigment Quinacridone_Magenta = Pigment(vec3(128, 2, 46)\t, vec3(0.502, 0.008, 0.18)      , vec3(0.216, 0.001, 0.027));\nconst Pigment Cobalt_Violet\t\t = Pigment(vec3(78, 0, 66)\t    , vec3(0.306, 0.0, 0.259)\t      , vec3(0.076, 0.0, 0.054));\nconst Pigment Ultramarine_Blue\t = Pigment(vec3(25, 0, 89)\t    , vec3(0.098, 0.0, 0.349)\t      , vec3(0.01, 0.0, 0.1));\nconst Pigment Cobalt_Blue\t\t     = Pigment(vec3(0, 33, 133)\t, vec3(0.0, 0.129, 0.522)\t      , vec3(0.0, 0.015, 0.235));\nconst Pigment Phthalo_Blue\t\t = Pigment(vec3(13, 27, 68)\t, vec3(0.051, 0.106, 0.267)     , vec3(0.004, 0.011, 0.058));\nconst Pigment Phthalo_Green\t\t = Pigment(vec3(0, 60, 50)\t    , vec3(0.0, 0.235, 0.196)\t      , vec3(0.0, 0.045, 0.032));\nconst Pigment Permanent_Green\t\t = Pigment(vec3(7, 109, 22)\t, vec3(0.027, 0.427, 0.086)\t  , vec3(0.002, 0.153, 0.008));\nconst Pigment Sap_Green\t\t     = Pigment(vec3(107, 148, 4)\t, vec3(0.42, 0.58, 0.016)\t      , vec3(0.147, 0.296, 0.001));\nconst Pigment Burnt_Sienna\t\t = Pigment(vec3(123, 72, 0)\t, vec3(0.482, 0.282, 0.0)\t      , vec3(0.198, 0.065, 0.0));\n\n\nconst Pigment pigments[13] = Pigment[13](\n    Cadmium_Yellow,\n    Hansa_Yellow,\n\n    Cadmium_Orange,\n    Cadmium_Red,\n\n    Quinacridone_Magenta,\n    Cobalt_Violet,\n\n    Ultramarine_Blue,\n    Cobalt_Blue,\n    Phthalo_Blue,\n\n    Phthalo_Green,\n    Permanent_Green,\n    Sap_Green,\n\n    Burnt_Sienna\n);\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\nfloat sRGBdecode(float C_sRGB) { return C_sRGB > 0.04045 ? (pow((C_sRGB + 0.055)/1.055, 2.4) ) : (C_sRGB / 12.92); }\nvec3 sRGBdecode(vec3 C_sRGB) { return vec3(sRGBdecode(C_sRGB.x), sRGBdecode(C_sRGB.y), sRGBdecode(C_sRGB.z)); }\n\nvec3 from_hex(int hex)\n{\n    return sRGBdecode(vec3( (hex >> 16)&0xFF, (hex >> 8)&0xFF, hex & 0xFF)/255.);\n}\n\nvec3 replacement_lut(vec2 uv)\n{\n    uv = clamp(uv, 0., 1.);\n    uv.x = 1.-uv.x;\n    vec3 uvw = vec3(fract(uv * 8.), (floor(uv.x*8.) + floor(uv.y*8.)*8.) / 64.);\n\n    vec3 bot_left_start  = from_hex(0x538D00);\n    vec3 top_left_start  = from_hex(0x7C433F);\n    vec3 bot_right_start = from_hex(0x01D300);\n    vec3 top_right_start = from_hex(0x003EBF);\n    vec3 bot_left_end    = from_hex(0x6E0900);\n    vec3 top_left_end    = from_hex(0xB0000F);\n    vec3 bot_right_end   = from_hex(0x000000);\n    vec3 top_right_end   = from_hex(0x1B005F);\n    \n    uvw.xz = 1.-uvw.xz;\n\n    vec3 bot_start = mix(bot_left_start, bot_right_start, uvw.x);\n    vec3 top_start = mix(top_left_start, top_right_start, uvw.x);\n    \n    vec3 bot_end = mix(bot_left_end, bot_right_end, uvw.x);\n    vec3 top_end = mix(top_left_end, top_right_end, uvw.x);\n    \n    vec3 start = mix(bot_start, top_start, uvw.y);\n    vec3 end = mix(bot_end, top_end, uvw.y);\n    \n    vec3 final = mix(start, end, uvw.z);\n    \n    final = pow(final, vec3(1./1.2)); // fudge it a bit, idk xD\n    \n    return final;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame == 0) fragColor = vec4(1,0,0,13);\n    else fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    float mouse_down = float(iMouse.z > 0.);\n    if(mouse_down>0. && (length(mouse-vec2(1.6,0.5))-0.1) < 0.) fragColor = vec4(1,0,0,1);\n    if(mouse_down>0. && (length(mouse-vec2(1.6,0))-0.1) < 0.) fragColor = vec4(0,1,0,1);\n    if(mouse_down>0. && (length(mouse-vec2(1.6,-0.5))-0.1) < 0.)  fragColor = vec4(0,0,1,1);\n    \n    \n    for(float i = 0.; i < 7.; i++)\n    {\n        float y = 0.8-(3.5*i)/13.;\n        float x = 1.5;\n        float r = 0.075;\n\n        if( mouse_down > 0. && (length(mouse-vec2(x,y)) < r) )\n            fragColor.a = i;\n    }\n    \n    for(float i = 0.; i < 7.; i++)\n    {\n        float y = 0.65-(3.5*i)/13.;\n        float x = 1.675;\n        float r = 0.075;\n        if( mouse_down > 0. && (length(mouse-vec2(x,y)) < r) )\n            fragColor.a = i+7.;\n    }\n    \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Start mixbox code ( modified to work on shadertoy ) \n//////////////////////////////////////////////////////////////////////////////////////////////\n\n// ==========================================================\n//  MIXBOX 2.0 (c) 2022 Secret Weapons. All rights reserved.\n//  License: Creative Commons Attribution-NonCommercial 4.0\n//  Authors: Sarka Sochorova and Ondrej Jamriska\n// ==========================================================\n//\n//   BASIC USAGE\n//\n//      vec3 rgb = mixbox_lerp(rgb1, rgb2, t);\n//\n//   MULTI-COLOR MIXING\n//\n//      mixbox_latent z1 = mixbox_rgb_to_latent(rgb1);\n//      mixbox_latent z2 = mixbox_rgb_to_latent(rgb2);\n//      mixbox_latent z3 = mixbox_rgb_to_latent(rgb3);\n//\n//      // mix 30% of rgb1, 60% of rgb2, and 10% of rgb3\n//      mixbox_latent z_mix = 0.3*z1 + 0.6*z2 + 0.1*z3;\n//\n//      vec3 rgb_mix = mixbox_latent_to_rgb(z_mix);\n//\n//   PIGMENT COLORS\n//\n//      Cadmium Yellow              0.996, 0.925, 0.000\n//      Hansa Yellow                0.988, 0.827, 0.000\n//      Cadmium Orange              1.000, 0.412, 0.000\n//      Cadmium Red                 1.000, 0.153, 0.008\n//      Quinacridone Magenta        0.502, 0.008, 0.180\n//      Cobalt Violet               0.306, 0.000, 0.259\n//      Ultramarine Blue            0.098, 0.000, 0.349\n//      Cobalt Blue                 0.000, 0.129, 0.522\n//      Phthalo Blue                0.051, 0.106, 0.267\n//      Phthalo Green               0.000, 0.235, 0.196\n//      Permanent Green             0.027, 0.427, 0.086\n//      Sap Green                   0.420, 0.580, 0.016\n//      Burnt Sienna                0.482, 0.282, 0.000\n//\n//   LICENSING\n//\n//      If you want to obtain commercial license, please\n//      contact us at: mixbox@scrtwpns.com\n//\n\n#ifndef MIXBOX_INCLUDED\n#define MIXBOX_INCLUDED\n\n//#ifndef MIXBOX_LUT\n//  #if __VERSION__ <= 120\n//    #define MIXBOX_LUT(UV) texture2D(mixbox_lut, UV)\n//  #else\n//    #define MIXBOX_LUT(UV) textureLod(mixbox_lut, UV, 0.0)\n//  #endif\n//#endif\n\n#define MIXBOX_LUT(UV) replacement_lut(UV)\n\n#define mixbox_latent mat3\n\n#define MIXBOX_COLORSPACE_LINEAR\n\nvec3 mixbox_eval_polynomial(vec3 c)\n{\n  float c0 = c[0];\n  float c1 = c[1];\n  float c2 = c[2];\n  float c3 = 1.0 - (c0 + c1 + c2);\n\n  float c00 = c0 * c0;\n  float c11 = c1 * c1;\n  float c22 = c2 * c2;\n  float c01 = c0 * c1;\n  float c02 = c0 * c2;\n  float c12 = c1 * c2;\n  float c33 = c3 * c3;\n\n  return (c0*c00) * vec3(+0.07717053, +0.02826978, +0.24832992) +\n         (c1*c11) * vec3(+0.95912302, +0.80256528, +0.03561839) +\n         (c2*c22) * vec3(+0.74683774, +0.04868586, +0.00000000) +\n         (c3*c33) * vec3(+0.99518138, +0.99978149, +0.99704802) +\n         (c00*c1) * vec3(+0.04819146, +0.83363781, +0.32515377) +\n         (c01*c1) * vec3(-0.68146950, +1.46107803, +1.06980936) +\n         (c00*c2) * vec3(+0.27058419, -0.15324870, +1.98735057) +\n         (c02*c2) * vec3(+0.80478189, +0.67093710, +0.18424500) +\n         (c00*c3) * vec3(-0.35031003, +1.37855826, +3.68865000) +\n         (c0*c33) * vec3(+1.05128046, +1.97815239, +2.82989073) +\n         (c11*c2) * vec3(+3.21607125, +0.81270228, +1.03384539) +\n         (c1*c22) * vec3(+2.78893374, +0.41565549, -0.04487295) +\n         (c11*c3) * vec3(+3.02162577, +2.55374103, +0.32766114) +\n         (c1*c33) * vec3(+2.95124691, +2.81201112, +1.17578442) +\n         (c22*c3) * vec3(+2.82677043, +0.79933038, +1.81715262) +\n         (c2*c33) * vec3(+2.99691099, +1.22593053, +1.80653661) +\n         (c01*c2) * vec3(+1.87394106, +2.05027182, -0.29835996) +\n         (c01*c3) * vec3(+2.56609566, +7.03428198, +0.62575374) +\n         (c02*c3) * vec3(+4.08329484, -1.40408358, +2.14995522) +\n         (c12*c3) * vec3(+6.00078678, +2.55552042, +1.90739502);\n}\n\nfloat mixbox_srgb_to_linear(float x)\n{\n  return (x >= 0.04045) ? pow((x + 0.055) / 1.055, 2.4) : x/12.92;\n}\n\nfloat mixbox_linear_to_srgb(float x)\n{\n  return (x >= 0.0031308) ? 1.055*pow(x, 1.0/2.4) - 0.055 : 12.92*x;\n}\n\nvec3 mixbox_srgb_to_linear(vec3 rgb)\n{\n  return vec3(mixbox_srgb_to_linear(rgb.r),\n              mixbox_srgb_to_linear(rgb.g),\n              mixbox_srgb_to_linear(rgb.b));\n}\n\nvec3 mixbox_linear_to_srgb(vec3 rgb)\n{\n  return vec3(mixbox_linear_to_srgb(rgb.r),\n              mixbox_linear_to_srgb(rgb.g),\n              mixbox_linear_to_srgb(rgb.b));\n}\n\nmixbox_latent mixbox_rgb_to_latent(vec3 rgb)\n{\n#ifdef MIXBOX_COLORSPACE_LINEAR\n  rgb = mixbox_linear_to_srgb(clamp(rgb, 0.0, 1.0));\n#else\n  rgb = clamp(rgb, 0.0, 1.0);\n#endif\n\n  float x = rgb.r * 63.0;\n  float y = rgb.g * 63.0;\n  float z = rgb.b * 63.0;\n\n  float iz = floor(z);\n\n  float x0 = mod(iz, 8.0) * 64.0;\n  float y0 = floor(iz / 8.0) * 64.0;\n\n  float x1 = mod(iz + 1.0, 8.0) * 64.0;\n  float y1 = floor((iz + 1.0) / 8.0) * 64.0;\n\n  vec2 uv0 = vec2(x0 + x + 0.5, y0 + y + 0.5) / 512.0;\n  vec2 uv1 = vec2(x1 + x + 0.5, y1 + y + 0.5) / 512.0;\n\n  if (MIXBOX_LUT(vec2(0.5, 0.5) / 512.0).b < 0.1)\n  {\n    uv0.y = 1.0 - uv0.y;\n    uv1.y = 1.0 - uv1.y;\n  }\n\n  vec3 c = mix(MIXBOX_LUT(uv0).rgb, MIXBOX_LUT(uv1).rgb, z - iz);\n\n  return mixbox_latent(c, rgb - mixbox_eval_polynomial(c), vec3(0.0));\n}\n\nvec3 mixbox_latent_to_rgb(mixbox_latent latent)\n{\n  vec3 rgb = clamp(mixbox_eval_polynomial(latent[0]) + latent[1], 0.0, 1.0);\n\n#ifdef MIXBOX_COLORSPACE_LINEAR\n  return mixbox_srgb_to_linear(rgb);\n#else\n  return rgb;\n#endif\n}\n\nvec3 mixbox_lerp(vec3 color1, vec3 color2, float t)\n{\n  return mixbox_latent_to_rgb((1.0-t)*mixbox_rgb_to_latent(color1) + t*mixbox_rgb_to_latent(color2));\n}\n\nvec4 mixbox_lerp(vec4 color1, vec4 color2, float t)\n{\n  return vec4(mixbox_lerp(color1.rgb, color2.rgb, t), mix(color1.a, color2.a, t));\n}\n\n#endif\n\n/////////////////////////////////////////////////////////////////////////////\n// End mixbox code\n//////////////////////////////////////////////////////////////////////////////////////////////\n\n/*\nvec3 mix_three(vec3 rgb1, vec3 rgb2, vec3 rgb3, vec2 fragCoord)\n{\n    mixbox_latent z1 = mixbox_rgb_to_latent(rgb1);\n    mixbox_latent z2 = mixbox_rgb_to_latent(rgb2);\n    mixbox_latent z3 = mixbox_rgb_to_latent(rgb3);\n\n    vec4 paint = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    paint.rgb = (paint.rgb / dot(paint.rgb, vec3(1)));\n    \n    mixbox_latent z_mix = paint.x*z1 + paint.y*z2 + paint.z*z3;\n\n    vec3 rgb_mix = mixbox_latent_to_rgb(z_mix);\n    \n    rgb_mix *= paint.a;\n\n    return rgb_mix;\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   if(iFrame == 0) { \n        float canvas_grain = -0.05+0.025*texture(iChannel0, fragCoord/iResolution.xy).r;// * texture(iChannel3, fragCoord/iResolution.xy).r;\n        fragColor = vec4(vec3(0.75 + canvas_grain), 1);\n        return;\n   }\n\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    float mouse_down = float(iMouse.z > 0.);\n    \n    vec3 color = texelFetch(iChannel2, ivec2(fragCoord), 0).rgb;\n\n    vec4 paint = texelFetch(iChannel1, ivec2(fragCoord), 0).rgba;\n\n    const float PI = 3.14159265;\n\n    float rcp_std = 14. * PI;\n    //float c = cos(sin(iTime/8.)), s = sin(sin(iTime/8.));\n    float c = cos(iTime/8.), s = sin(iTime/8.);\n    mat2 R = mat2(c,s, -s, c);\n    //float brush = exp(-.5 * rcp_std * length(mouse-uv)) * texture(iChannel3, 0.5 + (uv-mouse)).r * texture(iChannel3, 0.5 + R*(uv-mouse) + 0.3 * vec2(c,s)).r;\n\n    vec4 bufC = texture(iChannel3, fragCoord.xy/iResolution.xy);\n    float height = bufC.w;\n    float brush = smoothstep(0.7, 0.725, height) * smoothstep(0.75, 0.725, height) * bufC.z;\n\n    vec3 rgb = \n        Cadmium_Red.linRGB * paint.r +\n        Hansa_Yellow.linRGB * paint.g +\n        Cobalt_Blue.linRGB * paint.b;\n        \n    rgb = pigments[int(paint.a)].linRGB;\n    \n    if(int(paint.a) == 13) // Rainbow brush\n    {\n        vec3 C = mix(pigments[int(iTime)%12].linRGB, pigments[(int(iTime)+1)%12].linRGB, fract(iTime));\n        rgb = C;\n    }\n\n    float t = 0.9 * brush\n     //* mouse_down // uncomment if you wanted the old (buggy) behavior where it only catches the paint when mouse button is down\n    ;\n\n    color = mixbox_lerp(color, rgb, t);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 velocity = vec2(0);\n    \n    float mass = 0.;\n    \n    float height = 1.;\n\n    if(iFrame == 0) { fragColor = vec4(velocity, mass, height); return; }\n    \n    float N = 4.;\n    \n    height = 0.;\n    vec2 new_velocity = vec2(0);\n    \n    const float PI = 3.14159265;\n    \n    float W = 0.;\n    for(float i = -N; i <= N; i++)\n    {\n        for(float j = -N; j <= N; j++)\n        {\n            vec2 pos = fragCoord + vec2(i,j);\n            vec4 bufA = texelFetch(iChannel0, ivec2(pos), 0);\n            \n            // n for neighbor in this case\n            vec2 n_velocity = bufA.xy;\n            float n_mass = bufA.z;\n            float n_height = bufA.w-0.01;\n            \n            n_velocity -= vec2(0, .05); // gravity\n                        \n            vec2 neighbor_destination = n_velocity + vec2(i,j);\n            \n            float kernel = exp(-dot(neighbor_destination,neighbor_destination))/PI;\n            \n            vec2 fluid_forces = -neighbor_destination * (n_mass - 0.8); // not really forces I guess, but whatever\n            \n            float mass_transport = n_mass * kernel;\n            \n            mass += mass_transport;\n            \n            new_velocity += (n_velocity + fluid_forces) * mass_transport;\n            \n            height += n_height * mass_transport;\n        }\n    }\n    \n    new_velocity *= mass == 0. ? 0. : 1./mass;\n    height = mass == 0. ? 1. : height/mass;\n    \n    new_velocity = clamp(new_velocity, -N*.95, N*.95);\n    \n    // mouse drawing\n    \n    float mouse_down = float(iMouse.z > 0.);\n    float mouse_on_canvas = float((2.*iMouse.x-iResolution.x)/iResolution.y  < palette_edge);\n    \n    vec4 noise = texture(iChannel2, 0.5 + 0.5 * (2. * (fragCoord.xy-iMouse.xy) - iResolution.xy)/iResolution.y);\n    \n    vec2 m = (fragCoord.xy - iMouse.xy) / iResolution.y;\n    velocity += mouse_on_canvas * mouse_down * ( 10. * (noise.xy-.5)) * exp(-32.*dot(m,m));\n    \n    mass += noise.z * noise.z * 0.5*smoothstep(40., 35., length(iMouse.xy-fragCoord.xy)) * mouse_down * mouse_on_canvas;\n    height = mix(height, 1., smoothstep(40., 35., length(iMouse.xy-fragCoord.xy)) * mouse_down * mouse_on_canvas);\n        \n    mass *= smoothstep(0.65, 0.75, height);\n\n    fragColor = vec4(new_velocity, mass, max(height, 0.0));\n}","name":"Buffer C","description":"","type":"buffer"}]}