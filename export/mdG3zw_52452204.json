{"ver":"0.1","info":{"id":"mdG3zw","date":"1678330806","viewed":198,"name":"House tour!","username":"ianertson","description":"Use the mouse to look around :)\nHowever, I would recommend going to the top of the \"Image\" tab, and enable the \"WALK\" define, then you can move around using\nWASD and the mouse.\nI don't really like the shadows here, any suggestions are appreciated!\nCheers!","likes":25,"published":1,"flags":48,"usePreview":1,"tags":["3d","raymarching","raymarch","materials","textures","house"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define WALK 0\n\n#define NEAR 0.003\n#define FAR 64.\n#define STEPS 86\n\n#define CAMERA_ORIGIN vec3(0, 0, -6)\n#define CAMERA_Y 0.5\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_ROOM 2\n#define ID_ROOM_FLOOR 3\n#define ID_ROOM_DOOR 4\n#define ID_CEIL_LAMP 5\n#define ID_KITCHEN_BENCH 6\n#define ID_FRIDGE 7\n#define ID_BATH_TUB 8\n#define ID_KITCHEN_TABLE 9\n#define ID_BATHROOM_BENCH 10\n#define ID_TRASHCAN 11\n\n#define ROOM_H 2.0\n#define LAMP_1_POS vec3(-4, ROOM_H/2., 4)\n#define LAMP_2_POS vec3(-4, ROOM_H/2., -4)\n#define LAMP_3_POS vec3(4, ROOM_H/2., -4)\n\nfloat rand(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= (s ^ ((~p.x << s) + (~p.y << s)));\n    \n    p ^= (p << 17U);\n    p ^= ((p ^ s) >> 13U);\n    p ^= (p << 5U);\n    p ^= ((s + (s&(p.x^p.y))) >> 3U);\n    \n    uint n = (p.x*s+p.y)+((p.x ^ p.y) << ~p.x ^ s) + ((p.x ^ p.y) << ~p.y ^ s);\n    return float(n*50323U) / float(0xFFFFFFFFU);\n}\n\nvec3 trand(in vec2 p, in float seed, in float lod) {\n    return textureLod(iChannel3, (p + (seed*1.90928382))/256., lod).xyz;\n}\n\nfloat xnoise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(rand(id, seed), rand(id+vec2(1, 0), seed), lv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n}\n\nfloat xnoise(in vec2 p, in float seed, in float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    float n = 0.0;\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*xnoise(p*freq, seed); div += amp; amp /= 2.0; freq *= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(trand(id, seed, lod), trand(id+vec2(1, 0), seed, lod), lv.x),\n        mix(trand(id + vec2(0, 1), seed, lod), trand(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    \n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, in float warp, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = 0; i < levels; i++) {\n        n += amp*snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n        p += ((n.xy*(0.5+(0.5*n.z)))*2.0-1.0)*warp; \n    }\n    \n    return n / div;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat cdist(vec3 a, vec3 b) {\n    vec3 c = a - b;\n    return dot(c, c);\n}\n\nfloat ceilLampSDF(in vec3 p) {\n    return cylSDF(p, vec3(0.0, 0.0, 0.0), vec3(0.0, 0.22, 0.0), 0.5);\n}\n\nfloat benchSDF(in vec3 p, vec3 size) {\n    vec3 pSink = vec3(p.x, p.y+0.1, p.z/2.);\n    float sink = length(pSink) - 0.5;\n    float sinkInside = length(pSink - vec3(0, 0.1, 0)) - 0.48;\n    \n    float d = boxSDF(p, size)-0.016;\n    \n    \n    d  = smin(d, sink, 0.1);\n    d = smax(d, -sinkInside, 0.1);\n    return d;\n}\n\nfloat fridgeSDF(in vec3 p, vec3 size) {\n    return boxSDF(p, size)-0.016;\n}\n\n\n\nfloat roomSDF(in vec3 p, float h, in int skip, inout int id) {\n    id = ID_ROOM;\n    float dist = FAR;\n    float sm = 0.02;\n    vec3 roomSize = vec3(8.0, h, 8.0);\n    float room = boxSDF(p, roomSize);\n    float roomInside = boxSDF(p-vec3(0, -0.5, 0), roomSize*0.9);\n    room = max(room, -roomInside)-sm;\n    \n    vec3 winSize = vec3(1.1, 0.7, 0.8);\n    float winY = (winSize.y/2.)-roomSize.y/6.;\n    float winThick = 1.1;\n    \n    float win1 = boxSDF(\n        vec3(abs(p.x), p.y, (p.z)) - \n        vec3(abs(roomSize.x), winY, -((roomSize.z/2.)+winSize.z)), winSize)-sm;\n        \n    float win2 = boxSDF(\n        vec3(abs(p.x), p.y, abs(p.z)) - \n        vec3(abs(roomSize.x-(winThick*0.5)), winY, (roomSize.z/2.)+winSize.z).zyx, winSize.zyx)-sm;\n    \n    float roomFloor = boxSDF(p - vec3(0, -roomSize.y, 0), vec3(roomSize.x*0.9, 0.2, roomSize.z*0.9));\n\n    \n    \n    vec3 doorHoleSize = vec3(1.1, 1.2, 0.8);\n    float doorHole = \n        boxSDF(p - vec3(roomSize.x, (-h/2.)+doorHoleSize.y/3., roomSize.z/2.), doorHoleSize)-sm;\n    \n    \n    \n    vec3 doorSize = vec3(doorHoleSize.x*0.04, doorHoleSize.y*0.98, doorHoleSize.z*0.99);\n    \n    \n    \n    vec3 doorP = p - vec3(roomSize.x, (-h/2.)+doorHoleSize.y/3., roomSize.z/2.);\n    \n    doorP.xz += doorSize.xz;\n    doorP.xz *= rot(radians(40.));\n    doorP.z += 0.6;\n  \n    float door = boxSDF(doorP, doorSize)-sm;\n\n    room = max(room, -win1);\n    room = max(room, -win2);\n    room = max(room, -doorHole);\n    \n    float ceilLamp1 = skip != 0 ? FAR: ceilLampSDF(p - LAMP_1_POS);\n    float ceilLamp2 = skip != 0 ? FAR: ceilLampSDF(p - LAMP_2_POS);\n    float ceilLamp3 = skip != 0 ? FAR: ceilLampSDF(p - LAMP_3_POS);\n    float ceilLamp = min(min(ceilLamp1, ceilLamp2), ceilLamp3);\n    \n    vec3 benchSize = vec3(0.7, 0.1, 2.5);\n    float kitchenBench = benchSDF(p - vec3((-roomSize.x*0.90)+benchSize.x, -roomSize.y/2., (-roomSize.z*0.90) + benchSize.z), benchSize);\n  \n    float middleWall = boxSDF(p, vec3(roomSize.x, roomSize.y, 0.1));\n    float sepWall = boxSDF(p - vec3(0, 0, -roomSize.z/2.), vec3(0.1, roomSize.y, roomSize.z/2.));\n    \n    float wallDoor1 = boxSDF(vec3(abs(p.x), p.y, p.z) - vec3(3.5, -0.5, 0.), vec3(0.9, roomSize.y-0.5, 1.));\n\n    middleWall = max(middleWall, -wallDoor1);\n    float wall = min(middleWall, sepWall);\n    \n    SAMPLE(wall, ID_ROOM);\n    SAMPLE(ceilLamp, ID_CEIL_LAMP);\n    SAMPLE(door, ID_ROOM_DOOR);\n    SAMPLE(room, ID_ROOM);\n    SAMPLE(roomFloor, ID_ROOM_FLOOR);\n    SAMPLE(kitchenBench, ID_KITCHEN_BENCH);\n\n\n    return dist;\n}\n\nfloat bathTubSDF(in vec3 p) {\n    float k = 1.5;\n    \n    p.y -= smoothstep(0.1, 1.1, max(0.0, length(vec2(p.x/1.7, p.z)) - max(0.0, -p.y+0.7)))*1.2;\n    float d = length(vec3(p.x/1.7, p.y*1.1, p.z)) - 0.9;\n    d += smoothstep(0.2, 1.0, max(0.0, -p.y+0.2));\n    d = max(d, -p.y*0.5);\n    return d/2.1;\n}\n\nfloat roundTableSDF(in vec3 p, in float boardH, in float h, in float r) {\n    float board = cylSDF(p - vec3(0, h, 0), vec3(0, 0, 0), vec3(0, boardH, 0.), r);\n    \n    float d = board;\n    \n    float leg1 = cylSDF(vec3(abs(p.x), p.y, p.z) - vec3((r/2.)+0.1, 0, 0), vec3(0, 0, 0), vec3(0, h, 0), 0.1);\n    float leg2 = cylSDF(vec3(p.x, p.y, abs(p.z)) - vec3(0, 0, (r/2.)+0.1), vec3(0, 0, 0), vec3(0, h, 0), 0.1);\n\n    float leg  = min(leg1, leg2);\n    \n    d = min(d, leg);\n    \n    return d;\n\n}\n\nfloat trashcanSDF(in vec3 p, in float r) {\n    float d = cylSDF(p, vec3(0, 0, 0), vec3(0, 1, 0), r);\n    float inside = cylSDF(p - vec3(0, 0.31, 0), vec3(0, 0, 0), vec3(0, 1, 0), r*0.89);\n    d = smax(d, -inside, 0.02);\n    return d;\n}\n\n\nfloat sdf(inout Data data, in vec3 p) {\n    float dist = FAR;\n    int skip = data.skip;\n    int id = ID_NONE;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n\n    int roomId = 0;\n    float room = roomSDF(p - vec3(0, ROOM_H, 0), ROOM_H, skip, roomId);\n    SAMPLE(room, roomId);\n    \n      \n    vec3 fridgeSize = vec3(0.5, 1.25, 0.8);\n    float fridge = fridgeSDF(p - vec3((-8.*0.9)+fridgeSize.x+0.1, fridgeSize.y+0.2, -(fridgeSize.z+0.3)), fridgeSize);\n    SAMPLE(fridge, ID_FRIDGE);\n    \n    float tub = bathTubSDF(p - vec3(4.9, -0.5, -5.5));\n    SAMPLE(tub, ID_BATH_TUB);\n    \n    float kitTable = roundTableSDF(p - vec3(-2.7, 0.0, -4.), 0.1, 1., 1.1);\n    SAMPLE(kitTable, ID_KITCHEN_TABLE);\n    \n    vec3 benchSize = vec3(0.7, 0.1, 2.5);\n    float bathBench = benchSDF(p - vec3(benchSize.x+0.1, 0.9, -(7.19)+(benchSize.z)), benchSize);\n    SAMPLE(bathBench, ID_BATHROOM_BENCH);\n    \n    float bathTrashCan = trashcanSDF(p - vec3(benchSize.x+0.25, 0.0, -1.15), 0.5);\n    \n    SAMPLE(bathTrashCan, ID_TRASHCAN);\n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    \n    return true;\n}\n\nfloat getAO(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float d = NEAR*12.;\n    float t = 0.01;\n    float r = 1.0;\n    float k = 0.007;\n    for (int i = ZERO; i < 3; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next+0.05;\n        r = min(r, k*d/t);\n        t += (r*0.04);\n    }\n    r = clamp(r, AMBIENT, 1.0);\n    return pow(clamp(r+r/0.19, AMBIENT*0.7, 1.0), 2.);\n}\n\n\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip)\n{\n    ro += rd*0.19;\n    float d = 0.009;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    float t = 0.01;\n    float r = 1.0;\n    float f = 0.33;\n    float fw = f;\n    \n    const int steps = STEPS / 3;\n    for (int i = ZERO; i < steps; i++) {\n        float j = float(i) / float(steps);\n        fw = mix(f, 1., max(0.0, 1.0 - (j*j)));\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/(t));\n        t += clamp(next, 0.1, 0.5);\n        d += next*fw*0.5;\n        if (r < -1. || t > (far*2.) || d >= far) break;\n    }\n\n    return clamp(((r/(0.001+fw))+((d*fw)*0.5))+(cdot(n, rd)*0.003), AMBIENT, 1.0);\n}\n\n\nvec3 asphaltTexture(in vec2 uv, in vec3 p, inout Material m, in vec3 pos) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(27, 30, 41);\n    vec3 c2 = rgb(61, 59, 57);\n    vec3 c3 = rgb(81, 84, 82);\n    vec3 c4 = rgb(46, 50, 55);\n    \n    vec3 y1 = rgb(191, 165, 79);\n    vec3 y2 = rgb(168, 145, 81);\n    vec3 y3 = rgb(221, 191, 87);\n    \n    vec3 grain = textureLod(iChannel3, uv/2., 0.0).xyz;\n    vec3 hf = snoise(uv, 1.0019231, 0., 16.0, 6);\n    \n    vec3 asphalt = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    vec3 yellow = mix(mix(y1, y2, hf.x), y3, hf.y);\n    \n    col += asphalt;\n    \n    float cracks = max(0.0, 1.0-smoothstep(0.03, 0.1, abs(hf.x-hf.y)));\n    \n    \n    col = mix(col, ((0.5*c3)+(0.5*grain.x)), 0.5*cracks*cracks*(0.2+(0.5*grain.y)));\n    \n    p = p - pos;\n    \n\n    float rad = (0.5 + (cracks*0.1))*0.36;\n    float fe = (rad*(0.2));\n    float x = p.x;\n    float line1 = smoothstep(rad-(fe*2.), rad+(fe*2.), (-p.x)) *\n        smoothstep(rad+(fe*2.), rad-(fe*2.), (-p.x));\n    float line2 = smoothstep(rad-(fe*2.), rad+(fe*2.), max(0.0, p.x-rad/2.)) *\n        smoothstep(rad+(fe*2.), rad-(fe*2.), max(0.0, p.x-rad/2.));\n    float line = max(line1, line2);\n    col = mix(col, yellow*2., line);\n    \n    float specF = clamp((1.0-smoothstep(3.9, 4.6, abs(p.x)))*2., 0.0, 1.0);\n\n    m.spec = (pow(hf.x, 2.0) * max(0.0, 1.0 - cracks) * max(0.0, 1.0 - (line*2.)))*0.5 *\n        specF;\n\n    return col;\n}\n\n\nfloat checkerTexture(in vec2 uv, in float s) {\n    vec2 d = max(abs(dFdx(uv)), abs(dFdy(uv))) + s;\n    vec2 t1 = vec2(1.-2.0*abs(fract((uv.x+.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y+.5*d.y)*.5)-0.5));\n    vec2 t2 = vec2(1.-2.0*abs(fract((uv.x-.5*d.x)*0.5)-0.5), 1.-2.0*abs(fract((uv.y-.5*d.y)*.5)-0.5));\n    return 0.5 - 0.5*((t1.x-t2.x)/d.x)*(t1.y-t2.y)/d.y;\n}\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n\n    float hf1 = xnoise(uv*4., 0.329125, 10.0, 4);\n    vec3 hf2 =  snoise(uv*4., 0.329125, 0.9, 10.0, 4);\n    vec3 lf1 = snoise(uv*0.5,  1.772734, 0.3, 2.9, 6);\n\n    \n    vec3 c1 = rgb(188, 121, 71);\n    vec3 c2 = rgb(170, 146, 118);\n    vec3 c3 = rgb(156, 116, 77);\n    vec3 c4 = rgb(131, 76, 35);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf2.x), c3, hf2.y), c4, hf2.z);\n    col += col1;\n    \n    float tile = 4.0;\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x)*10.*lf1.y, sin((uv.y)*TAU)*2.));\n    \n    vec2 k = fract((uv+0.25)*(tile/2.));\n    k = abs(k*2.0-1.0);\n    float g = max(0.0, 1.0-round(k.y+0.45));\n    \n    float sg = smoothstep(0.33-0.05, 0.4+0.05, max(0.0, 1.0-k.y-0.6));\n    \n    float w = w2;\n    float edge = abs(w*2.0-1.0);\n    edge = max(0.0, 1.0 - smoothstep(0.02, 0.29, edge));\n    \n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    vec3 col2 = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    \n    col = mix(col, mix(col2, c2, lf1.x), w);\n    col = mix(col, col*col, edge*lf1.y);\n    \n    col = mix(col, col*col*col, clamp(sg*(0.5+(hf2.z*0.5))*1.25, 0.0, 1.0));\n    \n    m.spec = clamp((sg-(g*0.5))+max(0.0, (grain.x*lf1.x)-edge), 0.0, 1.0);\n\n    return col;\n}\n\nvec3 dirtyMetalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoiseWarp(uv, 0.0328125, 0.9, 16.0, 0.25, 6);\n    vec3 hf2 = snoise(uv, 2.3456767, 0.9, 64.0, 2);\n    vec3 hf3 = clamp(abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0))), 0.0, 1.0);\n    vec3 lf1 = snoiseWarp(uv, 5.55939123, 0.9, 8.0, 0.25, 6);\n    vec3 lf2 = snoise(uv, 10.02931925, 0.0, 2.5, 4);\n  \n    vec3 grain = textureLod(iChannel3, uv*0.5, 0.0).xyz;\n    vec3 hf4 = clamp(abs(normalize(cross(reflect((hf3)*2.0-1.0, grain*2.0-1.0), hf1*2.0-1.0))), 0.0, 1.0);\n    \n    vec3 m1 = rgb(134, 145, 151);\n    vec3 m2 = rgb(89, 91, 97);\n    vec3 m3 = rgb(175, 175, 175);\n    vec3 m4 = rgb(203, 203, 203);\n    vec3 m5 = rgb(92, 92, 92);\n    \n    vec3 col1 = mix(mix(mix(m1, m2, hf1.x), m3, hf1.y), m4, hf1.z);\n    \n    col += col1;\n    \n    vec3 d1 = rgb(103, 80, 71);\n    vec3 d2 = rgb(118, 92, 57);\n    vec3 d3 = rgb(71, 55, 40);\n    vec3 d4 = rgb(181, 106, 50);\n    \n    vec3 d5 = rgb(52, 51, 56);\n    vec3 d6 = rgb(69, 64, 56);\n    vec3 d7 = rgb(109, 94, 88);\n    vec3 d8 = rgb(82, 78, 80);\n    \n    vec3 dirtCol1 = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n    vec3 dirtCol2 = mix(mix(mix(d5, d6, hf3.x), d7, hf3.y), d8, hf3.z);\n    \n    vec3 dirtCol = mix(dirtCol1, dirtCol2, smoothstep(0.34, 0.5, lf1.x));\n    \n    float dirtReg = clamp(pow(lf2.x, 3.)*6., 0.0, 1.0);\n    col = mix(col, dirtCol, 0.5);\n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, hf4.z*lf2.y*grain.x*grain.y);\n    \n    m.spec = clamp(lf1.x*max(0.0, 1.0-(dirtReg*hf3.y)), 0.0, 1.0);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE metalTexture\n\nvec3 metalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoiseWarp(uv, 0.0328125, 0.9, 16.0, 0.25, 6);\n    vec3 hf2 = snoise(uv, 2.3456767, 0.9, 64.0, 2);\n    vec3 hf3 = clamp(abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0))), 0.0, 1.0);\n    vec3 lf1 = snoiseWarp(uv, 5.55939123, 0.9, 8.0, 0.25, 6);\n    vec3 lf2 = snoise(uv, 10.02931925, 0.0, 2.5, 4);\n  \n    vec3 grain = textureLod(iChannel3, uv*0.5, 0.0).xyz;\n    vec3 hf4 = clamp(abs(normalize(cross(reflect((hf3)*2.0-1.0, grain*2.0-1.0), hf1*2.0-1.0))), 0.0, 1.0);\n    \n    vec3 m1 = rgb(134, 145, 151);\n    vec3 m2 = rgb(89, 91, 97);\n    vec3 m3 = rgb(175, 175, 175);\n    vec3 m4 = rgb(203, 203, 203);\n    vec3 m5 = rgb(92, 92, 92);\n    \n    vec3 col1 = mix(mix(mix(m1, m2, hf1.x), m3, hf1.y), m4, hf1.z);\n    \n    col += col1;\n\n    \n    vec3 d5 = rgb(52, 51, 56);\n    vec3 d6 = rgb(69, 64, 56);\n    vec3 d7 = rgb(94, 94, 94);\n    vec3 d8 = rgb(82, 78, 80);\n    \n\n    vec3 dirtCol = mix(mix(mix(d5, d6, hf3.x), d7, hf3.y), d8, hf3.z);\n\n    \n    float dirtReg = clamp(pow(lf2.x, 3.)*6., 0.0, 1.0)*0.1;\n    col = mix(col, dirtCol, 0.5);\n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, hf4.z*lf2.y*grain.x*grain.y);\n    \n    \n    \n   vec2 lv = fract((uv-0.5+0.5)*2.);\n   vec2 alv = abs(lv*2.0-1.0);\n   float lines = smoothstep(0.0, 1., cos(length(vec2(alv.x*5., alv.y/5.))*TAU*TAU+grain.x+hf4.x+lf1.x));\n  //  col = mix(col, col+col, lines*lf2.x*hf1.y*grain.x);\n    col = mix(col, vec3(lf1.x), 0.6);\n    m.spec = clamp(lf1.x*lf1.x, max(hf2.z, lines), 1.0);\n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    uv += 0.;\n    vec3 hf1 = snoise(uv, 0.03982213, 0.0, 140.0, 3);\n    vec3 hf2 = fract(hf1*102.392981523);\n    vec3 lf1 = snoise(uv, 1.29392152, 0.3, 3.0, 4);\n    vec3 hf3 = fract(2.029812*reflect(cross(hf1*2.0-1.0, fract(hf1*11.9238123)*2.0-1.0), lf1*2.0-1.0));\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    \n    vec3 g1 = rgb(62, 76, 20);\n    vec3 g2 = rgb(99, 100, 59);\n    vec3 g3 = rgb(111, 144, 65);\n    vec3 g4 = rgb(89, 85, 61);\n    vec3 g5 = rgb(62, 60, 25);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    grassCol = mix(grassCol, g5, hf2.x*lf1.x);\n    col += grassCol;\n    \n    vec3 d1 = rgb(68, 50, 38);\n    vec3 d2 = rgb(113, 98, 79);\n    vec3 d3 = rgb(102, 78, 56);\n    vec3 d4 = rgb(118, 102, 83);\n    \n    vec3 dirtCol = mix(mix(mix(d1, d2, hf3.x), d3, hf3.y), d4, hf3.z);\n    \n    float dirtReg = lf1.y*lf1.z;\n    \n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, lf1.z*lf1.z*lf1.z);\n    col = mix(col, col*col, grain.x*hf3.y*lf1.z);\n    \n    float tile = 64.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    \n    float seed = 2.20931;\n    float r = mix(\n        mix(rand(id, seed), rand(id + vec2(1, 0), seed), slv.x),\n        mix(rand(id + vec2(0, 1), seed), rand(id + vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    r += lf1.x-grain.x;\n    float an = radians(mix(0.0, 90.0, r));\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(cos(an), sin(an))*0.5+0.5;\n    vec2 pp = abs(lv*2.0-1.0);\n    vec2 pa = pp - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    float l = clamp(1.0-length(pa - ba * h) / 0.2, 0.0, 1.0);\n    \n    col = mix(col, mix(col*col, g2, grain.y*grain.z*grain.z), (l*grain.y)*max(0.0, 1.0-(dirtReg*2.)));\n    \n    m.spec = clamp((dirtReg*hf1.z)*(0.5+(grain.x*0.5)), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 rockTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    float h = xnoise(uv, 203.231, 16.0, 4);\n    grain = (grain+h)/2.;\n    vec3 lf1 = snoiseWarp(uv, 0.032123, 0.5, 4.5, 1.5, 4);\n    vec3 lf2 = snoise(uv, 1.1112312, 0.01, 16.0, 4);\n    \n    vec3 c1 = rgb(106, 104, 105);\n    vec3 c2 = rgb(120, 114, 109);\n    vec3 c3 = rgb(133, 113, 92);\n    vec3 c4 = rgb(83, 81, 75);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, grain.x), c3, grain.y), c4, grain.z);\n    col1 = mix(col1, vec3(1.), lf1.x*lf1.x*h*grain.x);\n    col += col1;\n    \n    float edge = abs(lf2.x*2.0-1.0);\n    edge = max(0.0, 1.0-smoothstep(0.02, 0.09, edge));\n    \n    float scratchReg = edge*lf1.y*h*grain.y;\n    col = mix(col, col*col, scratchReg);\n    \n    m.spec = clamp((1.0-scratchReg)*grain.x, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 marbleTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoiseWarp(uv, 2.244234, 1., 24.0, 0.3, 4);\n    vec3 hf2 = snoiseWarp(uv, 8.727231, 0.3, 20.0, 0.03, 6);\n    vec3 hf3 = snoise(uv, 11.83772244, 0.2, 18.0, 4);\n    \n    vec3 hf4 = snoise(uv, 0.00392123, 0.09, 32.0, 6);\n     \n    vec3 w1 = rgb(247, 247, 247);\n    vec3 w2 = rgb(219, 218, 224);\n    vec3 w3 = rgb(211, 207, 207);\n    vec3 w4 = rgb(217, 207, 195);\n    \n    vec3 bg = mix(mix(mix(w1, w2, hf1.x), w3, hf1.y), w4, hf1.z);\n    col += bg;\n    \n    float edges = max(0.0, 1.0-smoothstep(0.02, 0.1, abs(hf2.x*2.0-1.0)));\n    float edges2 = max(0.0, 1.0-smoothstep(0.02, 0.1, abs(hf3.z*2.0-1.0)));\n    \n    vec3 c1 = rgb(196, 169, 127);\n    vec3 c2 = rgb(247, 178, 191);\n    vec3 c3 = rgb(158, 155, 149);\n    vec3 c4 = rgb(80, 77, 72);\n    \n    float edgeReg = edges2*smoothstep(0.39, 0.8, hf4.x);\n    vec3 pCol = mix(mix(mix(c1, c2, hf3.x), c3, hf3.y), c4, hf3.z);\n    col = mix(col, pCol, edgeReg);\n    col = mix(col, col*col, edges*hf4.z*hf4.y*(0.33+hf1.z));\n    \n    m.spec = clamp((1.0-edgeReg)*hf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 2.3339281, 0., 60., 4);\n    vec3 lf1 = snoise(uv, 0.9288737, 0., 20., 4);\n    float grain = textureLod(iChannel3, uv/2., 0.0).r;\n    \n    vec3 w1 = rgb(133, 107, 82);\n    vec3 w2 = rgb(143, 110, 78);\n    vec3 w3 = rgb(99, 58, 36);\n    vec3 w4 = rgb(171, 102, 61);\n    \n    vec3 woodCol = mix(mix(mix(w1, w2, hf1.x), w3, hf1.y), w4, hf1.z);\n    col += woodCol;\n    \n    vec2 id = floor(uv);\n    vec2 lv = fract(uv);\n    vec2 lvs = lv*lv*(3.0-2.0*lv);\n    vec2 lvc = lv*2.0-1.0;\n    vec2 alv = abs(lvc);\n    \n    const float seed = 3.3928195;\n    float idr = mix(mix(rand(id, seed), rand(id+vec2(1, 0), seed), lvs.x),\n                mix(rand(id+vec2(0, 1), seed), rand(id+vec2(1, 1), seed), lvs.x), lvs.y);\n    \n    \n\n    \n    float ra = max(0.0, 0.4 + 0.2*((0.5-idr)*0.5));\n    float fe = ra*(0.9*mix(1.0, 0.5, idr*idr*idr*0.7));\n    lvc += vec2(cos(idr*6.), sin(idr*6.))*0.5*idr;\n    col = mix(col, mix(col*col, col*idr, idr), smoothstep(0.6-0.3, 0.6+0.3, idr) * max(0.0, 1.0-smoothstep(ra-fe, ra+fe, length(lvc))));\n    \n    \n    \n    float s = pow(exp((cos((idr*idr*idr*(9.21223*(0.5+length(lvc))))*(lvc.x-((0.1+(idr*2.))*\n        sin((lvc.y-sin(lvc.x*M_PI*(0.5+(idr))))*M_PI)))*TAU)) - 1.), 3.0);\n    \n    col = mix(col, mix(w3, w4, hf1.x*lf1.z)*col, clamp(s*lf1.x*hf1.z*2., 0.0, 1.0));\n    col = mix(col, col*col, grain*grain);\n    \n    m.spec = clamp(s*s*grain, grain*lf1.x, 1.0);\n    \n    return col;\n}\n\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    float roadSize = 4.0;\n    \n    vec3 roadPos = vec3(10.0+roadSize, 0.0, 0.0);\n    Material mAsphalt = NEW_MATERIAL;\n    vec3 asphalt = asphaltTexture(uv, p, mAsphalt, roadPos);\n    \n    Material mGrass = NEW_MATERIAL;\n    vec3 grass = grassTexture(uv, p, mGrass);\n    \n    vec3 col = vec3(0.0);\n    \n    \n    col = grass;\n    \n    float am = smoothstep(0.0, 1.0, max(0.0, p.x-(roadPos.x-roadSize))) *\n        smoothstep(0.0, 1.0, max(0.0, -p.x+(roadPos.x+roadSize)));\n    col = mix(col, asphalt, am);\n    materialMix(mGrass, mAsphalt, am, data.m);\n   // if (p.x > roadPos.x-roadSize && p.x < (roadPos.x+roadSize)) {\n     //   col = asphalt;\n    //}\n    \n    return col;\n}\n\nvec3 getAlbedoRoom(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n\n        col = rockTexture(uv, p, data.m);\n   \n    return col;\n}\n\nvec3 getAlbedoRoomFloor(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = vec3(0.0);\n\n    \n    vec2 id = floor(uv/8.0)*4.0;\n    \n    if (id.x < 0.0 && id.y < 0.) {\n        col += checkerTexture(uv*3., 0.03);\n    } else if (id.y >= 0.0) {\n        col = plankTexture(uv*1.5, p, data.m);\n    } else {\n        col = marbleTexture(uv, p, data.m);\n    }\n   \n    return col;\n}\n\nvec3 getAlbedoCeilLamp(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = vec3(1.);\n\n    data.m.lum = 1.0;\n   \n    return col;\n}\n\nvec3 getAlbedoDoor(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    vec3 col = woodTexture(uv, p, data.m);\n   \n    return col;\n}\n\nvec3 getAlbedoKitchenTable(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    vec3 col = woodTexture(uv, p, data.m);\n   \n    return col;\n}\n\nvec3 getAlbedoKitchenBench(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv*0.5;\n    \n    vec3 col = marbleTexture(uv, p, data.m);\n   \n    return col;\n}\n\nvec3 getAlbedoFridge(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv*0.5;\n    \n    vec3 col = metalTexture(uv, p, data.m);\n   \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_ROOM: return getAlbedoRoom(data); break;\n        case ID_ROOM_FLOOR: return getAlbedoRoomFloor(data); break;\n        case ID_CEIL_LAMP: return getAlbedoCeilLamp(data); break;\n        case ID_ROOM_DOOR: return getAlbedoDoor(data); break;\n        case ID_KITCHEN_TABLE: return getAlbedoKitchenTable(data); break;\n        case ID_KITCHEN_BENCH: return getAlbedoKitchenBench(data); break;\n        case ID_BATHROOM_BENCH: return getAlbedoKitchenBench(data); break;\n        case ID_FRIDGE: return getAlbedoFridge(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    vec2 uv = rd.xz / rd.y;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    vec3 blue = vec3(0.29, 0.59, 0.9);\n    vec3 col = pow(blue*blue, vec3(1.0 + dotup));\n    \n    return col;\n}\n\nvec3 forEachLight(inout Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float NdotL = cdot(n, L);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = (NdotL > 0.000009 && data.id != ID_ROOM_DOOR) ? getShadow(p + (n*NEAR*2.), L, n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id == ID_ROOM ? -1 : data.id) : 1.0;\n        \n        \n    float ao = data.id == ID_ROOM_DOOR ? 1.0 : getAO(p + (n*NEAR*2.0), L, n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n    \n\n    shadow = max(shadow, data.m.lum);\n    ao = max(ao, data.m.lum);\n    att += data.m.lum;\n\n    return (diffuse + spec) * att * shadow * ao;\n}\n\n#define NUM_LIGHTS 4\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.79, 0.71), 2.0, LIGHT_AMBIENT);\n    lights[1] = Light(LAMP_1_POS + vec3(0, 1.4, 0), vec3(0.0), vec3(0.97, 0.79, 0.71), 3.0, LIGHT_POINT);\n    lights[2] = Light(LAMP_2_POS + vec3(0, 1.4, 0), vec3(0.0), vec3(0.97, 0.79, 0.71), 3.0, LIGHT_POINT);\n    lights[3] = Light(LAMP_3_POS + vec3(0, 1.4, 0), vec3(0.0), vec3(0.97, 0.79, 0.71), 3.0, LIGHT_POINT);\n\n    \n    if (march(data, ro, rd)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        \n        for (int i = ZERO; i < NUM_LIGHTS; i++) {\n            Light light = lights[i];\n            col += forEachLight(data, light, ro, rd, diffuse);\n        }\n    } else {\n        col += getSky(rd);\n    }\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -2.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if WALK\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    \n    ro = vec3(4, 1.5, 16).zyx;\n    ro += walk;\n    ro.y += fly.y;\n    \n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    #else\n    \n    if (length(m.xy) > 0.0001 && m.z > 0.001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n        ro += vec3(-4., 1.2, -4.);\n    } else {\n        \n        ro = vec3(4, 1.5, 16).zyx;\n        \n        vec3 oRo = ro;\n        vec3 oP = vec3(0, 0, 0);\n        vec3 lookP = oP;\n        \n        float nrSteps = 17.0;\n        float transTime = 0.9;\n        float time = T*0.7;\n        float frame = 1.0;\n        \n        ro = onCycle(ro, vec3(4, 1.5, 8).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0., 1.5, 0).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(4, 2., 3).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(0., 1.5, 0).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(-3., 2., 2.9).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-4, 1.5, 5.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(-3., 2., 2.9).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-2, 1.5, 7.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(-1., 2., 2.9).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(4., 1.5, 4.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(1., 2., 2.9).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(4., 1.5, 4.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(2., 2., 1.).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(2., 1.5, -3.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(2., 2., -3.).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(2., 1.5, -4.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(2., 2., -3.8).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-2., 1.5, -4.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(-3., 2., -3.8).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-4., 1.5, -4.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(-3.2, 2., -3.8).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-4., 1.5, -2.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(-2.5, 2., -3.8).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(-3., 1.5, -1.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(-1.1, 2., -3.8).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(2., 1.5, -1.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(1., 2., -3.8).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(4., 1.5, -1.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(2., 1.5, 0).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(2.2, 1.5, 5.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, vec3(4., 1.1, 4).zyx, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, vec3(3.5, 1.5, 16.).zyx, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        ro = onCycle(ro, oRo, time, nrSteps, transTime, frame);\n        lookP = onCycle(lookP, oP, time, nrSteps, transTime, frame);\n        frame += 1.;\n        \n        \n        rd = look(uv, lookP, ro);\n    }\n    #endif\n    \n    ro.y += CAMERA_Y;\n    ro.y = max(CAMERA_Y, ro.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    col += (col*luma(col));\n    col /= 1.0 + max(col-0.5, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    O = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iFrame <= 1 || iTime <= 0.0002 ? 12.75 : iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (skip != id_ && var < dist) { id = id_; dist = var; }\n#define AMBIENT 0.06\nfloat luma(in vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; float lum; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0)\n\nvoid materialMix(in Material a, in Material b, float f, inout Material c) {\n    c.rough = mix(a.rough, b.rough, f);\n    c.spec = mix(a.spec, b.spec, f);\n    c.metallic = mix(a.metallic, b.metallic, f);\n    c.lum = mix(a.lum, b.lum, f);\n}\n\nstruct Data { vec3 p; vec3 n; vec2 uv; float d; int id; int skip; Material m; };\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n        light.type == LIGHT_POINT ? normalize(light.p - p) : normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, distance(light.p, p))); break;\n        case LIGHT_DIR: {\n            vec3 L2 = normalize(light.p - p);\n            return light.c * NdotL * light.s * smoothstep(0.8, 1.0, dot(L2, L));\n        }; break;\n    }\n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.xz, round(adot(n, vec3(0, 1, 0)))), p.zy, round(adot(n, vec3(1, 0, 0))));\n}\n\nvec3 fixNormal(vec3 wn, vec3 n, float th, float mixf) {\n    vec3 t = cross(wn, vec3(0, 1, 0));\n    vec3 b = vec3(0.0);\n    if (abs(length(t)) == 0.0) t = cross(wn, vec3(0, 0, 1));\n    t = normalize(t);\n    b = normalize(cross(wn, t));\n    mat3 tbn = mat3(t, b, -wn);\n    n = normalize((tbn)*n);\n    return normalize(mix(wn, n, mixf*max(th, dot(wn, n))));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\nvec3 onCycle(vec3 from, vec3 to, float time, float nrSteps, float transTime, float frame) {\n    float cycle = mod(time, nrSteps + transTime);\n    return mix(from, to, smoothstep(frame - transTime, frame + transTime, cycle));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,0.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"}]}