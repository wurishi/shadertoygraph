{"ver":"0.1","info":{"id":"Ds3fR2","date":"1697446077","viewed":72,"name":"Dx12-NotSure","username":"vince5287","description":"Testing stuff and Mixing a 2D effect with a raymarching ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["mix"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define TMIN 1e-6\n#define TMAX 40.0\n\n// https://iquilezles.org/articles/distfunctions/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n// Lights\nvec3 blinnPhong(vec3 nor, vec3 pos, vec3 ro, vec3 lpos, vec3 lcol)\n{\n    // Light direction\n    vec3 ldir = normalize(lpos - pos);\n    \n    // diffuse\n    float diff = max(dot(ldir, nor), 0.);\n    vec3 diffuse = diff * lcol;\n    \n    // specular\n    vec3 vdir = normalize(ro -pos);\n    vec3 ref = reflect(-ldir, nor);\n    float spec = 0.0;\n    // Get half vector\n    vec3 ha = normalize(ldir + vdir);\n    spec = pow(max(dot(nor, ha), .0), 128.);    \n    vec3 specular = spec*lcol;\n    \n    // Attenuation\n    float maxd = 1.5;\n    float dis = length(lpos - pos);\n    float att = 1.0 / dis*dis;\n    \n    diffuse *= att;\n    spec *= att;\n    \n    return diffuse + specular;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 res = vec2(-1.0, -1.0);\n    vec3 q = p;\n    \n    // Plane\n    float d = p.y + .12;\n    res = vec2(d, 1.0); \n    \n    // Little guys\n    if (abs(q.z) < .95)\n    {\n        q.z = fract(4.0*q.z) -.5;\n        q.z *= .2;\n    }\n            \n    // Shpere\n    float d1 = length(q) - .025;\n    // cone\n    float d2 = sdCappedCone(q + vec3(0.0, 0.1, 0.0), .075, .035, .015);\n    d1 = min(d1, d2);\n    \n    res = d1 < d ? vec2(d1, 2.0) : res;\n\n    return res;\n    \n}\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    float mat = -1.0;\n    for(int i = 0; i < 256; i++)\n    {\n        vec3 de = ro + t*rd;\n        vec2 h = map(de);\n        mat = h.y;\n        if(h.x < TMIN) break;\n        t += h.x;\n        if(t > TMAX) return vec2(-1.0, -1.0);\n    }\n    return vec2(t, mat);\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float k)\n{\n    float t = 0.0001;\n    float res = 1.0;\n    \n    for (int i = 0; i < 128; i++)\n    {\n        vec3 de = ro + t*rd;\n        float h = map(de).x;\n        \n        res = min(res, (k*h)/t);\n        if (h < TMIN) break;\n        t += h;\n        if (t > TMAX) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 calcNor(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(p + e.xyy).x - map(p - e.xyy).x,\n        map(p + e.yxy).x - map(p - e.yxy).x,\n        map(p + e.yyx).x - map(p -e.yyx).x\n    ));\n}\n\nvec3 palette(float t)\n{\n    vec3 a = vec3(.5);\n    vec3 b = vec3(.5);\n    vec3 c = vec3(1.);\n    vec3 d = vec3(0.234, 0.345, 0.678);\n    \n    return a + b*cos(2.0*PI*(t*c+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n       vec2 p = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n       vec3 col = vec3(0.0, 0.1, 0.2);\n       \n       //BackGround ---------------------------------------------\n        \n       // Set up \n       if ( -.5*p.y*(p.x*p.x) < 0.1 || p.x < 0.0){\n           // Take upper right part of this\n           vec2 q = 1.5 + 0.5*p;\n           q = fract(6.0 * q*q.y*(q.x*q.x) ) - .5;\n       \n           // Make it inifite scroll\n           q.y = fract(0.5*iTime+q.y) - 0.5;\n       \n           // Shape    \n           float d = length(q) - .4;\n           d = smoothstep(0.0, 0.05, -d);\n       \n       \n           vec3 dotCol = palette(-0.25*length(p+1.5));\n           col = dotCol * d;\n       }\n       else if ( -0.5*p.y*(p.x*p.x) > 0.12 || p.x < 0.0)\n       {   \n           // Ray Marching -------------------------------\n            vec3 ro = vec3(0.0, 0.5, 1.0);\n            vec3 ta = vec3(-1.1, 0.1, -0.1);\n           \n           vec3 ww = normalize(ta - ro);\n           vec3 up = vec3(0.0, 1.0, 0.0);\n           vec3 uu = normalize(cross(ww, up));\n           vec3 vv = normalize(cross(uu, ww));\n           \n           vec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww);\n           \n           vec2 t = castRay(ro, rd);\n           \n           if(t.x > 0.0)\n           {\n               vec3 pos = ro+t.x*rd;\n               vec3 nor = calcNor(pos);\n               vec4 mate = vec4(0.0);\n               \n               if (t.y < 1.5)\n               {\n                    mate = 0.5*texture(iChannel0, vec2(t))\n                       +0.5*texture(iChannel0, vec2(t));\n                    mate = mate*mate;\n               }\n               \n               vec3 dotCol = palette(-0.55*length(0.9*p+3.05));               \n               \n               vec3 lp = vec3(-1.8,2.2, 0.);\n               vec3 bf = blinnPhong(nor, pos, ro, lp, dotCol);\n               float sha = calcShadow(pos+nor*.01, lp, 16.0);\n               \n               col = mate.xyz+dotCol*bf*sha;\n               \n           }\n            \n       }\n       else\n       {\n           col = vec3(0.05);\n       }\n       \n        \n       fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}