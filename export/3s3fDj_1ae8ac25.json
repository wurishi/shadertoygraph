{"ver":"0.1","info":{"id":"3s3fDj","date":"1672260588","viewed":133,"name":"Light Intensity - Function 3D","username":"wagyx","description":"Rendering of different light intensity profiles from convex shapes with closed form solutions and meshes.\nThis is the actual directional function.\nUse mouse to navigate: x axis changes the shape.\nPlease check https://www.shadertoy.com/view/DlXGzX","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["light","intensity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\n\n//taken from https://www.shadertoy.com/view/WlfXRN\n// t must be between 0 and 1 otherwise the color will saturate\nvec3 inferno(float t) {\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// taken from https://www.shadertoy.com/view/WtjcDt\nmat4 rotationMatrix(vec3 axis, float cosAngle, float sinAngle) {\n    float s = sinAngle;\n    float c = cosAngle;\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle) {\n    // taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    // angle = radians(angle);\n    //axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    return rotationMatrix(axis, c, s);\n}\n\n//taken from https://www.shadertoy.com/view/WtjcDt\nvec3 apply_rot(mat4 r, vec3 p) {\n    return (r*vec4(p, 1.)).xyz;\n}\n\nfloat sphereAppSurface(float radius){\n    return PI*radius*radius;\n}\n\n// view is the direction from which the object is observed, must be normalized\n// normal is the normal of the falt surface, must be normalized\n// area is the area of the object\n// isSingleFaced indicates whether the surface emits from the normal side (true) or both sides false.\nfloat flatAppSurface(vec3 view, vec3 normal, float area, bool isSingleFaced) {\n    float res = dot(view,normal);\n    //when negative, take absolute value if not single faced and zero else\n    if (res < 0.f) {\n        res*= sign(res)*float(!isSingleFaced); \n    }\n\treturn res*area;\n}\n//widths are the side lengths of the rectangle\nfloat rectAppSurface(vec3 view, vec3 normal, vec2 widths, bool isSingleFaced){\n\treturn flatAppSurface(view, normal, widths.x*widths.y, isSingleFaced);\n}\n\nfloat triangleAppSurface(vec3 view, vec3 p0, vec3 p1, vec3 p2, bool isSingleFaced){\n\tvec3 normal = cross(p1-p0,p2-p0);\n    float area = length(normal);\n    normal/=area;\n    area*=0.5;\n    return flatAppSurface(view, normal, area, isSingleFaced);\n}\n\n// halfWidths are the half widths of the minor and major axis of the ellipse\nfloat ellipseAppSurface(vec3 view, vec3 normal, vec2 halfWidths, bool isSingleFaced){\n\treturn flatAppSurface(view, normal, PI*halfWidths.x*halfWidths.y, isSingleFaced);\n}\nfloat diskAppSurface(vec3 view, vec3 normal, float radius, bool isSingleFaced){\n\treturn ellipseAppSurface(view, normal, vec2(radius), isSingleFaced);\n}\n\nfloat alignedBoxAppSurface(vec3 view, vec3 widths){\n    const vec3 xaxis = vec3(1.f,0.f,0.f);\n    const vec3 yaxis = vec3(0.f,1.f,0.f);\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n\tfloat res= rectAppSurface(view, zaxis, widths.xy, false);\n    res+= rectAppSurface(view, xaxis, widths.yz, false);\n    res+= rectAppSurface(view, yaxis, widths.xz, false);\n    return res;\n}\n\nfloat vertTubeAppSurface(vec3 view, float radius, float height){\n    const vec3 zaxis= vec3(0.f,0.f,1.f);\n    float res= length(cross(view,zaxis));\n    return res*radius*height*2.f;\n}\n\nfloat vertCylinderAppSurface(vec3 view, float radius, float height){\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n\tfloat res= diskAppSurface(view, zaxis, radius, false);\n    res+= vertTubeAppSurface(view, radius, height);\n    return res;\n}\n\n\nfloat complementTrig(float value){\n\treturn clamp(sqrt(1.f-value*value),-1.f,1.f);\n}\n    \nvec3 rotateVectorFromZenith(vec3 view, vec3 direction) {\n    const vec3 zaxis = vec3(0.f,0.f,1.f);\n    vec3 axis = cross(zaxis,direction);\n    float sinAngle = length(axis);\n    float cosAngle = dot(zaxis,direction);\n    axis /= sinAngle;\n    mat4 mat = rotationMatrix(axis, cosAngle, sinAngle);\n    return apply_rot(mat,view);\n}\n\nfloat tubeAppSurface(vec3 view, vec3 axis, float radius, float height){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return vertTubeAppSurface(newView, radius, height);\n}\n    \nfloat cylinderAppSurface(vec3 view, vec3 axis, float radius, float height){\n    float res=0.f;\n\tres+= diskAppSurface(view, axis, radius, false);\n\tres+= tubeAppSurface(view, axis, radius, height);\n    return res;\n}\n\nfloat boxAppSurface(vec3 view ,vec3 axis, vec3 widths){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return alignedBoxAppSurface(newView, widths);\n}\n\n// could not compute the analytical form of the integral\n// instead, doing a numerical integration by discretizing the ellipse\n// not a 100% sure the computation is okay\nfloat vertEllipticTubeAppSurface(vec3 view, vec2 radiuses, float height){\n    float N=100.f;\n    float s = sin(PI/N);\n    float sum=0.f;\n    for(float i=0.f; i<N; ++i){\n    \tfloat t= i*2.f*PI/N;\n        vec2 normal = vec2(cos(t),sin(t));\n        vec2 edge= radiuses * s * 2.f * vec2(-normal.y,normal.x);\n        normal*=radiuses.yx;\n        normal= normalize(normal);\n        sum += rectAppSurface(view, vec3(normal,0.f), vec2(length(edge),height),true);\n    }\n    return sum;\n}\n\nfloat vertEllipticCylinderAppSurface(vec3 view, vec2 radiuses, float height){\n    float res=0.f;\n    vec3 zAxis=vec3(0,0,1);\n\tres+= ellipseAppSurface(view, zAxis, radiuses, false);\n\tres+= vertEllipticTubeAppSurface(view, radiuses, height);\n    return res;\n}\n\nfloat ellipticTubeAppSurface(vec3 view, vec3 axis, vec2 radiuses, float height){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    return vertEllipticTubeAppSurface(newView, radiuses, height);\n}\n\nfloat ellipticCylinderAppSurface(vec3 view, vec3 axis, vec2 radiuses, float height){\n    float res = 0.f;\n\tres+= ellipseAppSurface(view, axis, radiuses, false);\n\tres+= ellipticTubeAppSurface(view, axis, radiuses, height);\n    return res;\n}\n    \nvec2 uvToInclinationAzimuth(vec2 uv) {\n\treturn vec2((1.f-uv.y),2.f*uv.x)*PI;\n}\n\n// radius, inclination from z, azimuth from x\nvec3 sph2cart(vec3 ria){\n    float z= cos(ria.y);\n    float x= sin(ria.y);\n    float y= x*sin(ria.z);\n    x=x*cos(ria.z);\n    return ria.x*vec3(x,y,z);\n}\n\n////////////////////////////////////////////////////////////////////////\n// FOR CONVEX TRIANGULAR MESHES\n#define meshMaxNbFaces 30\n#define meshMaxNbVert 30\n\nstruct TriMesh {\n    int nbVert;\n    int nbFaces;\n\tvec3 vert[meshMaxNbVert];\n\tivec3 faces[meshMaxNbFaces];    \n};\n\nconst float C0 = 0.35355339059328;\nTriMesh genTetrahedron() {\n    TriMesh mesh;\n    mesh.nbVert=4;\n    mesh.vert[0] = vec3( C0, -C0,  C0);\n    mesh.vert[1] = vec3( C0,  C0, -C0);\n    mesh.vert[2] = vec3(-C0,  C0,  C0);\n    mesh.vert[3] = vec3(-C0, -C0, -C0);\n    mesh.nbFaces=4;\n    mesh.faces[0] = ivec3( 0, 1, 2 );\n    mesh.faces[1] = ivec3( 1, 0, 3 );\n    mesh.faces[2] = ivec3( 2, 3, 0 );\n    mesh.faces[3] = ivec3( 3, 2, 1 );\n    return mesh;\n}\n\n\nfloat triMeshAppSurface(vec3 view, vec3 axis, TriMesh mesh){\n    vec3 newView= rotateVectorFromZenith(view,axis);\n    float res=0.f;\n    for(int i=0; i<mesh.nbFaces; ++i){\n        ivec3 face = mesh.faces[i];\n        res+=triangleAppSurface(newView, mesh.vert[face.x], mesh.vert[face.y], mesh.vert[face.z], true);\n    }\n    return res;\n}\n\n\n/**\nRAYMARCHING ALGORITHM\nfrom  Ray Marching: Part 2 by jfwong : https://www.shadertoy.com/view/lt33z7\nfrom  Raymarching - Primitives by iq : https://www.shadertoy.com/view/Xds3zN\n*/\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 samplePoint, float lightID, vec3 axis) {\n    float appSurf=0.f;\n    float d = length(samplePoint);\n    vec3 view = samplePoint/d;\n\n    //Sphere\n    if (lightID == 2.0)\n        appSurf = sphereAppSurface(1.f)*0.3;\n    \n    // Rectangle and Box\n    else if (lightID == 1.0)\n        appSurf = rectAppSurface(view,axis,vec2(1.f,1.f),false);\n    else if (lightID == 0.0)\n        appSurf = boxAppSurface(view, axis, vec3(1.f, 1.f, 1.f))/2.;\n    \n    //Disk, Tube and Cylinder\n    else if (lightID == 3.0)\n        appSurf = diskAppSurface(view, axis, 1.f, false)/PI;\n    else if (lightID == 4.0)\n        appSurf = tubeAppSurface(view, axis, 1.f, 1.f)/2.f;\n    else if (lightID == 5.0)\n        appSurf = cylinderAppSurface(view, axis, 1.f, 1.f)/3.8f;\n\t\n    // Ellipse, Elliptic Tube and Cylinder\n    else if (lightID == 6.0)\n        appSurf = ellipseAppSurface(view, axis, vec2(1.f,2.f), false)/(2.f*PI);\n    else if (lightID == 7.0)\n        appSurf = ellipticTubeAppSurface(view, axis, vec2(1,2), 1.f)/3.8f;\n    else if (lightID == 8.0)\n        appSurf = ellipticCylinderAppSurface(view, axis, vec2(1,2), 1.f)/8.f;\n        \n    // mesh\n    else if (lightID == 9.0)\n        appSurf = triMeshAppSurface(view, axis, genTetrahedron())*1.9;\n    \n    return d - appSurf;\n}\n\n        \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    // compute ray direction\n    vec3 dir = rayDirection(25.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(0,0,-10);\n\n    // compute intersection     \n    float lightID = floor(iMouse.x*10./iResolution.x);\n    vec3 lightAxis = normalize(vec3(cos(iTime),sin(iTime),cos(2.*iTime)));\n    float dist = MAX_DIST;\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float d = sceneSDF(eye + depth * dir, lightID, lightAxis);\n        if (d < EPSILON) {\n\t\t\tdist = depth;\n            break;\n        }\n        depth += d;\n        if (depth >= MAX_DIST) {\n            break;\n        }\n    }\n    \n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = 0.3*vec4(1.0,1.0,1.0, 0.0);\n        return;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * dir;\n    float d = length(p);\n    \n    \n    // compute color\n    vec3 color= inferno(clamp(d, 0., 1.));\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}