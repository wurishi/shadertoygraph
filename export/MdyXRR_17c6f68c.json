{"ver":"0.1","info":{"id":"MdyXRR","date":"1462395783","viewed":253,"name":"Simple 2D distance functions","username":"psonice","description":"A simple 2D distance function example. See comments in the shader - more complex bits are commented out to keep it simple initially.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","tutorial","distancefunction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Define a circle\nstruct Circle {\n    vec2 origin;\n    float radius;\n};\n    \n// Find the distance from a circle (SDF)\nfloat dist2circle (in Circle c, in vec2 uv) {\n    return length(c.origin - uv) - c.radius;\n}\n\n// Find the distance to the nearest surface in the scene\nfloat dist2scene (in vec2 uv) {\n    float dist;\n    \n    // Minimum distance to one of these circles:\n    float c1 = dist2circle(\n        \t\t\tCircle(vec2(0.0), 0.5),\n        \t\t\tuv);\n    float c2 = dist2circle(\n        \t\t\tCircle(vec2(0.5, 0.2), 0.35),\n        \t\t\tuv);\n    dist = min(c1, c2);\n    \n    // Subtract another circle, animated this time:\n    float c3 = dist2circle(\n        \t\t\tCircle(\n                        // Circle origin is animated:\n                        vec2(sin(iTime) * 0.5, sin(iTime * 0.7) * 0.3),\n                        0.45),\n        \t\t\tuv);\n    // Uncomment to enable:\n    //dist = max(dist, -c3);\n    \n    // Add a repeated circle:\n    float c4 = dist2circle(\n        \t\t\t// Circle is inside 0..0.5 area\n        \t\t\tCircle(vec2(0.25, 0.25), 0.1),\n        \t\t\t// Use mod to \"loop\" the coordinates between 0..0.5. \n        \t\t\t// This way anything inside this area gets repeated.\n        \t\t\tmod(uv, 0.5));\n    // Uncomment to enable:\n    //dist = min(dist, c4);\n    \n    // Subtract another repeated circle:\n    float c5 = dist2circle(\n        \t\t\tCircle(vec2(0.25, 0.25), 0.05),\n        \t\t\tmod(uv, 0.5));\n    // Uncomment to enable:\n    //dist = max(dist, -c5);\n    \n \treturn dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; // 0..1\n    uv = uv * 2. - 1.; // -1..1\n    uv.y /= iResolution.x/iResolution.y; // corrects the aspect ratio\n    \n    // Get the distance to the scene\n    float dist = dist2scene(uv);\n    \n    // Find out if point is inside or out\n    bool inside = dist <= 0.0;\n    \n    // Set the output colour:\n    vec4 innerColour = vec4(0.5, 0.5, 0.85, 1.0);\n    vec4 outerColour = vec4(vec3(1. * (1. - dist)), 1.0);\n\tfragColor = inside ? innerColour : outerColour;\n}","name":"Image","description":"","type":"image"}]}