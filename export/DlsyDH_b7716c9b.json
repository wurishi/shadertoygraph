{"ver":"0.1","info":{"id":"DlsyDH","date":"1690699925","viewed":88,"name":"Region uniform color","username":"kastorp","description":"applying uniform color to connected pixels, using JFA distance to shape border as an acceleration info\nuse mouse to view the current lead pixel for each position, space bar to reset","likes":12,"published":1,"flags":48,"usePreview":0,"tags":["area","connected"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Region uniform color by Kastorp\n//-------------------------------\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    ivec4 c=T(I);\n    \n    if(iMouse.z>0. && abs(length(vec2(I2C(T(iMouse.xy).w))-I)-15.)<2.){\n     O=vec4(0); return;        \n    }      \n    \n    if(c.x==0) {O=vec4(1); return;}\n    \n    O= .5+ .5*cos(vec4(0,2,4,0) + float(c.w)/R.x/60.);\n    if(length(vec2(I2C(c.w))-I)<3.) O=vec4(0);\n    O=pow(O,vec4(.4));\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const int maxSteps = 10;\n#define ACCELERATE\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    if(iFrame==0|| T(R-vec2(1))==ivec4(0) ||texelFetch(iChannel3,ivec2(32,0),0).x>.5 ) {\n        O=step(.3,(snoise(I/R.y*8. +iTime)*.8+ .2*snoise(I/R.y*40. +iTime*5.5 )))*vec4(1,0,0,0);\n        O.y=  O.x==0.? float(C2I(I)):0.;\n        if(ivec2(I)==ivec2(R)-ivec2(1)) O=vec4(1,0,iFrame,0);\n        \n    }   \n    else {\n        ivec4 c= T(I);\n                \n        if(c.x>0){\n            if(c.w==0) c.w=C2I(I);\n            for(int i=0;i<4;i++){\n                ivec2 d =ivec2(i>1? i*2-5: 0,i<2? i*2-1: 0);\n                ivec4 n=T(ivec2(I)+d);\n                if(n.x>0){\n                    if(n.w>c.w) c.w=n.w;               \n                }\n            }\n        }\n                \n      //JFA CYCLE \n      int f = iFrame % maxSteps;\n      int best =c.y;\n      float bestd2 = length(vec2(I2C(best))-I), w = float(1 << (maxSteps-f));   \n      for(int i=0;i<4;i++){\n           vec2 d =vec2(i>1? i*2-5: 0,i<2? i*2-1: 0);\n          \n          vec2 n=I+d*w;\n          int seed = T(n).y;\n\n          if (seed>0 &&n.x<R.x && n.y<R.y && n.x>=0. && n.y>=0.){ \n              vec2 p=vec2(I2C(seed));\n              float d2 = length(p - I);\n              if (bestd2 > d2 ) {\n                  bestd2 = d2;\n                  best = seed;\n              }\n          }\n      }\n      c.y=best;\n\n#ifdef ACCELERATE\n        int frames=iFrame-T(R-vec2(1)).z;\n        if(c.x>0 && c.y>0 && frames>maxSteps){\n            if(c.w==0) c.w=C2I(I);\n            for(int i=0;i<4;i++){\n                ivec2 d =ivec2(i>1? i*2-5: 0,i<2? i*2-1: 0);\n                ivec4 n=T(ivec2(I)+d*int(bestd2-1.));\n                if(n.x>0){\n                    if(n.w>c.w) c.w=n.w;               \n                }\n            }\n        }\n#endif        \n      O=vec4(c);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define T(c) ivec4(texelFetch(iChannel0,ivec2(c),0))\n#define R iResolution.xy\n#define I2C(f)  ivec2(int(f)%4096,int(f)/8192)\n#define C2I(c)  (int(c.y)*8192+int(c.x))\n\n// Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\nlowp vec3 permute(in lowp vec3 x) { return mod( x*x*34.+x, 289.); }\nlowp float snoise(in lowp vec2 v) {\n  lowp vec2 i = floor((v.x+v.y)*.36602540378443 + v),\n      x0 = (i.x+i.y)*.211324865405187 + v - i;\n  lowp float s = step(x0.x,x0.y);\n  lowp vec2 j = vec2(1.0-s,s),\n      x1 = x0 - j + .211324865405187, \n      x3 = x0 - .577350269189626; \n  i = mod(i,289.);\n  lowp vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))+ i.x + vec3(0, j.x, 1 )   ),\n       m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n       x = fract(p * .024390243902439) * 2. - 1.,\n       h = abs(x) - .5,\n      a0 = x - floor(x + .5);\n  return -0.278 + .5 + 65. * dot( pow(m,vec3(4.))*(- 0.85373472095314*( a0*a0 + h*h )+1.79284291400159 ), a0 * vec3(x0.x,x1.x,x3.x) + h * vec3(x0.y,x1.y,x3.y));\n}","name":"Common","description":"","type":"common"}]}