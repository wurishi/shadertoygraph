{"ver":"0.1","info":{"id":"msGBWy","date":"1698591514","viewed":57,"name":"Optimization: ADAM","username":"chronos","description":"\"ADAptive Moment estimation\" optimization method.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["gradient","derivative","plot","optimization","estimation","numerical","adaptive","moment","descent","adam"],"hasliked":0,"parentid":"dsyfWG","parentname":"Optimization: RMS Propagation"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nhttps://en.wikipedia.org/wiki/Stochastic_gradient_descent#Adam\n*/\n\nconst float PI = 3.14159265;\n\nfloat func(float x)\n{\n    return \n         .33*cos(x * PI + 0.4) +\n         .1*(.5 + 0.5 * sin(x * PI*8. + 0.4))\n         ;\n}\n\n\nfloat func_derivative(float x)\n{\n    return \n        -.33*sin(x * PI + 0.4) * PI\n        +\n        .1*(0.5 * cos(x * PI*8. + 0.4))* PI*8.\n        ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    if(length(iMouse.xy) < 10.) mouse = vec2(0.1, 0);\n\n    float pix_size = 2. / iResolution.y;\n    vec3 color = vec3(0);\n    \n    \n    float axes = .25 * smoothstep(1.5*pix_size, pix_size/2., min(abs(uv.x), abs(uv.y)) );\n    color = mix(color, vec3(1), axes);\n    \n    float X = uv.x;\n    float Y = func(X);\n    \n    \n    float d = distance(uv, vec2(X, Y));\n    float f = smoothstep(2. * pix_size, pix_size*.75, d);\n    \n    color = mix(color, vec3(1), f);\n    \n    \n    // tangent check\n    vec2 mousepoint = vec2(mouse.x, func(mouse.x));\n    float mousedist = distance(mousepoint, uv);\n    float mousealpha = smoothstep(5. * pix_size, pix_size*4., mousedist);\n    \n    vec2 tangent = vec2(1., func_derivative(mouse.x));\n    \n    vec2 normal = normalize( vec2(1,-1) * tangent.yx );\n    \n    float tangent_dist = abs(dot((uv - mousepoint), normal));\n    float tangent_alpha = smoothstep(1.5 * pix_size, pix_size*1., tangent_dist) * .5;\n    tangent_alpha *= float(mousedist < 1.);\n    color = mix(color, vec3(0,.5,.5), tangent_alpha);\n    color = mix(color, vec3(0,1,0), mousealpha);\n    \n    // Forgetting factors\n    float beta1 = 0.9;\n    float beta2 = 0.999;\n    \n    \n    const float eps = 1e-7;\n    \n    float r = 5. * pix_size;\n    int numsteps = 100;\n    float x = mouse.x;\n    float y = func(x);\n    float dydx = func_derivative(x);\n    float stepsize = 3./float(numsteps);\n    \n    float m = 0.;\n    float v = 0.;\n    \n    for(int stp = 0; stp < numsteps; stp++)\n    {\n        float t = float(stp)/float(numsteps-1);\n        \n        float t_max = fract(iTime);\n        \n        if(t > t_max) break;\n        \n        vec3 particle_color = mix(vec3(0,0,1), vec3(0, 1, 0), t);\n        particle_color /= length(particle_color);\n        \n        vec2 pos = vec2(x, y);\n        float dist = distance(uv, pos);\n        float alpha = smoothstep(r+pix_size/2., r-pix_size/2., dist);\n        color = mix(color, particle_color, alpha);\n        \n        // Can use mix(..., ..., beta) here\n        m = beta1 * m + (1.-beta1) * dydx;\n        v = beta2 * v + (1.-beta2) * dydx * dydx;\n        \n        float m_hat = m / (1.-pow(beta1, float(stp+1))); // Beta_1 to the power \"t\" in the paper, which is t=stp+1 here.\n        float v_hat = v / (1.-pow(beta2, float(stp+1)));\n        \n        x = x - stepsize * (m_hat / (sqrt(v_hat)+eps));\n        \n        y = func(x);\n        dydx = func_derivative(x);\n    }\n    \n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}