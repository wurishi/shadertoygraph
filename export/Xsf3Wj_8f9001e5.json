{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"texture","id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// messing around with simple motion, the camera, and trying to create an analog look.\n\n// the weird lines are from marching through a distance field and accumulating samples\n// from the textile image along the way. the wood texture looks interesting as well.\n\n#define MAX_ITERS 19\n\n#define LARGE_FLOAT 10000.0\n#define INTERSECT_DIST 0.001\n#define FEATHER_DIST .1\n#define SEQUENCE_LENGTH 24.0\n\n// sphere signed dist\nfloat sdSphere( vec3 p, vec4 sph )\n{\n\treturn length(p-sph.xyz) - sph.w;\n}\n// plane signed dist. assumes planeN is normalised.\nfloat sdPlane( in vec3 p, in vec3 planeP, vec3 planeN )\n{\n\treturn dot(p-planeP, planeN);\n}\n\nfloat easeIn(float t0, float t1, float t)\n{\n\treturn 2.0*smoothstep(t0,2.*t1-t0,t);\n}\n\nfloat easeOut(float t0, float t1, float t)\n{\n\tfloat dt = t1 - t0;\n\treturn 2.*(smoothstep(t0-dt,t1,t)-.5);\n\t\n\t//return max(0.,2.0*(smoothstep(t0,2.*t1-t0,t)-.5));\n}\n\n// this doesnt look great but does the job\nfloat filmDirt( vec2 pp, float time )\n{\n\tfloat aaRad = 0.1;\n\tvec2 nseLookup2 = pp + vec2(.5,.9) + time*100.;\n\tvec3 nse2 =\n\t\ttextureLod(iChannel1,.1*nseLookup2.xy,0.).xyz +\n\t\ttextureLod(iChannel1,.01*nseLookup2.xy,0.).xyz +\n\t\ttextureLod(iChannel1,.004*nseLookup2.xy+0.4,0.).xyz\n\t\t;\n\tfloat thresh = .4;\n\tfloat mul1 = smoothstep(thresh-aaRad,thresh+aaRad,nse2.x);\n\tfloat mul2 = smoothstep(thresh-aaRad,thresh+aaRad,nse2.y);\n\tfloat mul3 = smoothstep(thresh-aaRad,thresh+aaRad,nse2.z);\n\t\n\tfloat seed = textureLod(iChannel1,vec2(time*.35,time),0.).x;\n\t\n\t// this makes the intensity of the overall image flicker 30%, and\n\t// gradually ramp up over the coarse of the sequence to further unsettle\n\t// the viewer\n\tfloat result = clamp(0.,1.,seed+.7) + .3*smoothstep(0.,SEQUENCE_LENGTH,time);\n\t\n\t// add even more intensity for the wide eyed moment before the exp\n\tresult += .06*easeIn(19.2,19.4,time);\n\n\tfloat band = .05;\n\tif( 0.3 < seed && .3+band > seed )\n\t\treturn mul1 * result;\n\tif( 0.6 < seed && .6+band > seed )\n\t\treturn mul2 * result;\n\tif( 0.9 < seed && .9+band > seed )\n\t\treturn mul3 * result;\n\treturn result;\n}\n\n// returns the pos and radius of the sphere, which change over the sequence\nvec4 sphere( float time )\n{\n\tfloat amp = 3.;\n\tfloat riseTime = 16.0;\n\tfloat y = amp*clamp(0.,1.,1.2* smoothstep(0.,1.,smoothstep(0.,1.,clamp(0.,1.,time/riseTime)))) - .5;\n\t\n\tfloat explode = smoothstep(20.6,20.70,time);\n\tfloat rad = 0.3 + 10.*explode;\n\t\n\tfloat rage = clamp(0.,1.,1.3*smoothstep(riseTime-4.,riseTime-4.+2.25,time));\n\t\n\t// starts to pulse and then eventually swells before exploding\n\tfloat pulseMult = min(1.,2.*(smoothstep( 19., 18., time )));\n\t\n\trad += rage*.05*pulseMult*sin(15.*max(0.,time-riseTime));\n\t\n\t// contract\n\trad -= .1* 2.*(-.5+smoothstep(17.25,20.5,time));\n\t//rad -= .1* 2.*(-.5+smoothstep(17.25,19.25,time));\n\t\n\tfloat shakeMult = smoothstep(19.25,18.25,time);\n\tvec3 shake = shakeMult*rage*.5*(textureLod(iChannel1,vec2(time*.35,time),0.).xyz-.5);\n\tvec3 pos = vec3(0.,y,0.) + shake;\n\treturn vec4( pos, rad );\n}\n\n// abrupt changes in time and position to unsettle the viewer\nvec4 jumpCut( float seqTime )\n{\n\t// jump cut\n\tfloat toffset = 0.;\n\tvec3 camoffset = vec3(0.);\n\t\n\tfloat jct = seqTime;\n\tfloat jct1 = 7.7;\n\tfloat jct2 = 8.2;\n\tfloat jc1 = step( jct1, jct );\n\tfloat jc2 = step( jct2, jct );\n\t\n\tcamoffset += vec3(.8,.0,.0) * jc1;\n\tcamoffset += vec3(-.8,0.,.0) * jc2;\n\t\n\t// add constant offset if passed first jc time\n\ttoffset += 0.8 * jc1;\n\t// accelerate time if between jcs\n\ttoffset -= (jc2-jc1)*(jct-jct1);\n\t// step back again if passed second jc\n\ttoffset -= 0.9 * jc2;\n\t\n\treturn vec4(camoffset, toffset);\n}\n\n// converts pixel coord to 3d ray. this contains the camera controller.\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos, in vec4 sph, in float time, in float time_offset )\n{\n    // camera position\n\t\n    float camRadius = 3.8;\n\t// use mouse x coord\n\tfloat a = 0.;\n\tif( iMouse.z > 0. )\n\t\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * sin(theta);\n    float zoff = camRadius * cos(theta);\n    cameraPos = vec3(xoff,1.+0.*.005*sin(5.*time/2.+2.),zoff);\n\t\n    // camera target - halfway between floor and sphere\n    vec3 target = vec3(sph.x,max(sph.y,0.)*.7,sph.z);\n\t// at some point loosen coupling between camera and sphere\n\tfloat coupling = smoothstep(19.,16.5,time);\n\tcoupling = max(0.1,coupling);\n\ttarget = coupling* target + (1.-coupling)*vec3(0.,.7*3.,0.);\n\t\n\t// at the beginning, idly look around\n\ttarget.x += -1.5+ 3.5*smoothstep(4.8,2.,time);\n\t// then focus on object\n\ttarget.x += 1.5*smoothstep(4.2,4.8,time);\n\t\n\t// look down at a certain time after the sphere has risen\n\tfloat lookdown = smoothstep( 13., 14., time ) - smoothstep( 14.75, 15.35, time );\n\ttarget.y -= lookdown * 2.;\n\t\n\t// start off looking level but look at sphere when it appears\n\tfloat levelLook = 1. - smoothstep( 4.25, 4.75, time );\n\ttarget.y += levelLook;\n\t\n\t// finally add a subtle recoil for the explosion\n\ttarget.y += .35*easeIn(20.47,20.55,time);\n\t\n\t// camera shake\n\tfloat camShakeAmp = 0.02;\n\t// if sphere has emerged, get scared and shake it more\n\tcamShakeAmp += 0.2*smoothstep(-.05, -.0, sph.y);\n\tvec3 shakeOff = camShakeAmp*(textureLod(iChannel1,vec2(time*.005,time*.015),0.).xyz - .5);\n\tfloat pulseMult = 1.0-easeIn(19.2,19.4,time);\n    target += shakeOff * pulseMult;\n\t\n\t// if we're between jump cuts we're gonna mess with the camera frame\n\tfloat right_y = -0.01;\n\tif( time_offset > 0. )\n\t{\n\t\tright_y = 0.025;\n\t}\n\t\n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, right_y, -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n    \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t// reduce fov when cam starts shaking, but fade this off to restore the frame\n\tfov -= camShakeAmp*.5 * (1.-smoothstep(0.5,0.9,sph.y));\n\t\n\t// if we're between jupm cuts we're gonna mess with the fov\n\tif( time_offset > 0. )\n\t{\n\t\tfov -= .05;\n\t}\n\t\n\t// add some wide eyed fov at the very end\n\tfov += .1*easeIn(19.2,19.4,time);\n\t// tried a dolly zoom to add some intensity but it doesnt work because\n\t// there are no reference points visible during the zoom :(\n\t//cameraPos += (target-cameraPos) * .25*easeIn(19.2,19.4,time);\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\nfloat sdPebbles( in vec3 p, in float t )\n{\n\tfloat fally = -3.*easeIn(19.,20.,t);\n\t\n\tfloat startRise = 14.;\n\tfloat endRise = 18.;\n\t\n\tfloat dt1 = .9;\n\tfloat y1 = -1. + 2.5 * easeOut( startRise, endRise, t+dt1 ) + fally;\n\tfloat dt2 = -.12;\n\tfloat y2 = -1. + 2.5 * easeOut( startRise, endRise, t+dt2 ) + fally;\n\tfloat dt3 = -.9;\n\tfloat y3 = -1. + 2.5 * easeOut( startRise, endRise, t+dt3 ) + fally;\n\tfloat dt4 = -.5;\n\tfloat y4 = -1. + 2.5 * easeOut( startRise, endRise, t+dt4 ) + fally;\n\t\n\treturn min( sdSphere(p, vec4(1.,y1,-1.3,.01)),\n\t\t\t   min( sdSphere(p, vec4(0.,y2,-2.5,.01)),\n\t\t\t\t   min( sdSphere(p, vec4(2.5,y3,.5,.01)),\n\t\t\t\t\t   sdSphere(p, vec4(-2.,y4,.5,.01))\n\t\t\t\t\t   )\n\t\t\t\t   )\n\t\t\t   );\n}\n\n// shade that pixel!\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0*q;\n    pp.x *= iResolution.x / iResolution.y;\n    \n\t// loop time\n\tfloat sequenceTime = mod(iTime, SEQUENCE_LENGTH);\n\t// force low fps to unsettle viewer\n\tfloat fps = 15.;\n\tfloat frameTime = 1./fps;\n\tsequenceTime = floor(sequenceTime/frameTime)*frameTime;\n\t\n\tvec4 jumpCutData = jumpCut(sequenceTime);\n\t\n\t// world time\n\tfloat time = sequenceTime + jumpCutData.w;\n\t\n\t// sphere position and radius\n\tvec4 sph = sphere( time );\n\t\n\t// evaluate camera\n\tvec3 cameraPos;\n    vec3 rayDir = computePixelRay( pp, cameraPos, sph, time, jumpCutData.w );\n\t\n\t// ray pos with dither (resolution independent i hope)\n\tvec3 p = cameraPos + 0.05*textureLod(iChannel1,iResolution.x*q.xy/400.,0.).x*rayDir;\n\t\n\t// alpha and col\n\tfloat a = 0.0;\n\tvec3 col = vec3(0.);\n\t\n\t// background intensity\n\tfloat bg = textureLod(iChannel1,vec2(time/60.,0.),0.).x;\n\tbg *= bg; bg *= bg; bg *= bg;\n\tfloat inten = .1 + .05*bg;\n\tfloat t = 0.;\n\tfor( int i = 0; i < MAX_ITERS; i++ )\n\t{\n\t\t// get distances to objects\n\t\tfloat dSphere1 = sdSphere(p, sph);\n\t\tfloat dPlane   = sdPlane(p, vec3(0.,0.,0.), vec3(0.,1.,0.));\n\t\tfloat dRock1   = sdSphere(p, vec4(2.3,.15,0.7,.1));\n\t\tfloat dRock2   = sdSphere(p, vec4(-2.,.15,-2.,.1));\n\t\tfloat dRock3   = sdSphere(p, vec4(-1.9,.15,-2.3,.1));\n\t\tfloat dPebs    = sdPebbles(p,time);\n\t\t\n\t\t// union\n\t\tfloat d = min(dSphere1,dPlane);\n\t\td = min(dRock1, d);\n\t\td = min(dRock2, d);\n\t\td = min(dRock3, d);\n\t\td = min(dPebs, d);\n\t\t\n\t\t// intersection, done marching\n\t\tif( d < 0.001 )\n\t\t\tcontinue;\n\t\t\n\t\t// ramp off alpha near surfaces\n\t\tfloat alpha = smoothstep( 0.1, 0.100+FEATHER_DIST, d );\n\t\t\n\t\t// acummulate samples\n\t\tcol += inten*alpha * textureLod(iChannel0,1.*p.xz,t/2.).xyz;\n\t\t\n\t\t// advance ray\n\t\tp += rayDir * d;\n        t += d;\n\t}\n\t\n\t// start with accum colour\n\tfragColor.xyz = col;\n\t\n\t// fade in at beginning of sequence\n\tfloat fadein = clamp(0.,1.,sequenceTime/1.2);\n\tfadein *= fadein;\n\tfragColor.xyz *= fadein;\n\t\n\t// contrast and brightness\n\tfragColor.xyz = 1.4*(0.5*fragColor.xyz + 0.5*smoothstep(0.,1.,fragColor.xyz));\n\t\n\t// vignette\n\tvec2 uv =  q.xy-0.5;\n\tfloat distSqr = dot(uv, uv);\n\tfragColor.xyz *= 1.0 - distSqr;\n\t\n\t// film grain (and another brightness adjustment)\n\tfragColor.xyz *= filmDirt(pp, time);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xsf3Wj","date":"1379171355","viewed":1629,"name":"The Occurrence","username":"huwb","description":"My attempt to tell a simple story.\n","likes":63,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","analog","film"],"hasliked":0,"parentid":"","parentname":""}}