{"ver":"0.1","info":{"id":"DtcyDN","date":"1699194663","viewed":180,"name":"Remix: dark star + fluid post-FX","username":"MV10","description":"Demonstrates rendering a high-overhead shader to lower resolution allows up-scaling to very high res, but also leaves \"room\" for the application of post-processing effects. See Image tab comments for credits, links and discussion.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["postprocessing","cfd","resolution","upscaling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of my own \"Upscaling: dark star\" https://shadertoy.com/view/Dl3yD8, which was a\n// resolution-limited fork of FabriceNeyret2's \"dark star\" https://shadertoy.com/view/DtBSWw,\n// and combined with cornusammonis' \"Faster Multiscale MIP Fluid\" https://www.shadertoy.com/view/wdVSR3\n// which I experimented with previously in \"BFD\" https://www.shadertoy.com/view/DddBRj.\n\n// This demonstrates that rendering the \"primary\" shader (dark star) at a lower resolution\n// also makes it feasible to introduce complex post-processing effects. From a Shadertoy standpoint,\n// this looks like \"just another pass\", but in my stand-alone music-visualization program, post-FX\n// like the MIP fluid effect are sometimes randomly applied to other stand-alone shaders like\n// \"dark star\" -- this wouldn't be possible (at any smooth looking frame rate) if high-overhead\n// shaders were rendered at full resolution before feeding into the post-FX shaders (and in fact,\n// \"dark star\" all by itself doesn't run smoothly at high res, which is the point of the earlier\n// upscale demo this was forked from). Using these techniques, my program can produce hundreds of\n// entertaining combinations from about 50 shaders without worrying about poor frame rate quality.\n\n// It's interesting to me that the high-brightness areas flicker on WebGL. In my stand-alone program\n// on desktop API OpenGL 4.6 those areas dim a little and the fluid shader makes them ripple, but\n// there isn't the extreme black/white change on every other frame. Also that program doesn't develop\n// the solid color areas at the edges over time. Maybe this has to do with buffer pixel format, as my\n// program uses float storage. The initial frames, however, look a lot like what my program maintains\n// over longer run times. I'll work on it, but interesting-enough to share anyway, I think.\n\n\n// Set rendering resolution definitions here and in Common.\n#define MAXRES 1920.0\n\n\n// From Faster Multiscale MIP Fluid and BFD\n// https://www.shadertoy.com/view/wdVSR3\n// https://www.shadertoy.com/view/DddBRj\n\n\nfloat getVal(vec2 uv)\n{\n    return length(texture(iChannel0, uv).xyz);\n}\n    \nvec2 getGrad(vec2 uv, float delta)\n{\n    vec2 d=vec2(delta, 0);\n    return vec2(\n        getVal(uv + d.xy) - getVal(uv - d.xy),\n        getVal(uv + d.yx) - getVal(uv - d.yx)\n    ) / delta;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 n = vec3(getGrad(uv, 1.0 / iResolution.y), 120.0);\n    n=normalize(n);\n    fragColor=vec4(n, 1);\n    vec3 light = normalize(vec3(1, 1, 2));\n    float diff = clamp(dot(n, light), 0.5, 1.0);\n    float spec = clamp(dot(reflect(light, n), vec3(0, 0, -1)), 0.0, 1.0);\n    spec = pow(spec, 36.0) * 1.0;\n\tfragColor = texture(iChannel0, uv) * vec4(diff) + vec4(spec);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// From dark star and upscaling demo:\n// https://shadertoy.com/view/DtBSWw\n// https://shadertoy.com/view/Dl3yD8\n// See Image tab comments for details.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // declared in Common\n    res = iResolution.xy;\n    time = iTime;\n\n    vec4 color;\n    fragColor = Image(color, fragCoord, iChannel0);\n    fragColor = clamp(fragColor, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// From dark star and upscaling demo:\n// https://shadertoy.com/view/DtBSWw\n// https://shadertoy.com/view/Dl3yD8\n// See Image tab comments for details.\n\n// Should match value set in BufferC.\n#define MAXRES 1920.0\n\n// Buffer tabs must set these before calling Image()\nvec2 res;\nfloat time;\n\n#define R(a) mat2(cos(a + vec4(0, 11, 33, 0)))\n\nvec4 Image(out vec4 color, vec2 fragCoord, sampler2D tex)\n{\n    float aspect = res.y / res.x;\n    vec2 orig_res = res;\n    if(res.x > MAXRES)\n    {\n        res = vec2(MAXRES, MAXRES * aspect); \n        if(fragCoord.y >= res.y || fragCoord.x >= res.x)\n        {\n            color = vec4(0);\n            return color;\n        }\n    }\n\n    vec2 p = (fragCoord + fragCoord - res) / res.y,\n        q = vec2(0),\n        n = vec2(0);\n    \n    float S = 6.0,\n        a = 0.0,\n        i = 0.0,\n        d = dot(p, p), \n        s = 0.0,\n        e = 50.0;\n    \n    p = p / (0.7 - d) + time / 3.14;\n    \n    for(color *= 0.0; i++ < e; color += texture(tex, fract((fragCoord / res - 0.5) * i / e + 0.5) * res / orig_res) / e)\n        p *= R(5.0), \n        n *= R(5.0),\n        q = p * S + i - abs(n) * R(time * 0.2),\n        a += dot(sin(q) / S, res / res),\n        n += cos(q), \n        S *= 1.1;\n    \n    a = max(s, 0.9 - a * 0.2 - d);\n    \n    return pow(a + a * vec4(8, 4, 1, 0) / e, color + 15.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// From dark star and upscaling demo:\n// https://shadertoy.com/view/DtBSWw\n// https://shadertoy.com/view/Dl3yD8\n// See Image tab comments for details.\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    // declared in Common\n    res = iResolution.xy;\n    time = iTime;\n\n    vec4 color;\n    fragColor = Image(color, fragCoord, iChannel0);\n    fragColor += color;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// From Upscaling: dark star\n// https://shadertoy.com/view/Dl3yD8\n\n// Set rendering resolution definitions here and in Common.\n#define MAXRES 1920.0\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\t\n    float scaling = (iResolution.x > MAXRES)\n        ? MAXRES / iResolution.x\n        : 1.0;\n\nvec2 uv = (fragCoord.xy / iResolution.xy) * scaling;\n    fragColor = texture(iChannel0, uv);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// From Faster Multiscale MIP Fluid and BFD\n// https://www.shadertoy.com/view/wdVSR3\n// https://www.shadertoy.com/view/DddBRj\n\nvec3 YCbCr (vec3 rgb) {\n\treturn vec3(\n        dot(rgb, vec3(.299, .587, .114)), // y\n        .5 + dot(rgb, vec3(-.169, -.331, .5)), // Cb\n\t\t.5 + dot(rgb, vec3(.5, -.419, -.081)) // Cr\n    );\n}\n\nvec4 CK (vec3 f, vec3 b, vec3 k) {\n    vec3 v = YCbCr(f);\n    float l = length((v - YCbCr(k)).gb);\n    float m = 1. - smoothstep(.075, .225, l);\n    vec3 s = (1. - m) * vec3(v.r);\n    return vec4(mix(s, f - m * k, smoothstep(.125, .275, l)) + m * b, 1.);\n}\n\n#define C(x,y) textureLod(iChannel0, t * (fragCoord + float(1<<s) * vec2(x, y)), float(s))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = fragColor - fragColor;\n    \n    vec2 t = 1. / iResolution.xy, q = fragCoord * t - .5;\n    \n    int s = 10;\n    for (; s > 0; s--)\n        fragColor.xy -= 2.0 * vec2(C(0, 1).x + C(0, -1).x, C(1, 0).y + C(-1, 0).y)\n            -4.0 * C(0, 0).xy + (C(1, -1) - C(1, 1) - C(-1, -1) + C(-1, 1)).yx;\n    \n    fragColor = (C(fragColor.x, fragColor.y) + vec4(5e-4 * q / (dot(q,q) + 0.01), 0, 0));\n    \n    // mix in some new content every other frame\n    if(iFrame % 2 == 0)\n    {\n        vec3 key_rgb = vec3(0);\n        vec3 fluid = texture(iChannel0, fragCoord * t).rgb;\n        vec3 dark_star = texture(iChannel1, fragCoord * t).rgb;\n        fragColor = CK(dark_star, fluid, key_rgb);\n    }\n}\n","name":"Buffer D","description":"","type":"buffer"}]}