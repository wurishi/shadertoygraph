{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float EPS = 0.001; // this defines \"close enough\", because raymarching doesn't actually hit\nconst int MAXI = 100;\t // how much work we are willing to do (speed vs. accuracy)\nconst float MAXD = 30.; // if we are this far away from everything, we are lost in the skies of eternity\n\n// OK NOW YOU SHOULD GO SCROLL DOWN TO MAIN AND FOLLOW THE FUNCTION CALLS FROM THERE OK\n\nvec3 hsv(float h,float s,float v) { // this is just a hue/saturation/luminance to RGB conversion\n\treturn mix(vec3(1.),clamp((abs(fract(h+vec3(3.,2.,1.)/3.)*6.-3.)-1.),0.,1.),s)*v;\n}\n\nfloat scenedist(vec3 p){ // this defines what is actually in the scene\n\tfloat s1 = length(p)-1.; \t\t\t\t// this is just a sphere\n\tfloat s2 = length(p-vec3(1.,0.,0.))-0.3;// this is a smaller sphere, shifted x-wards\n\treturn min(s1,s2); // add them together (like boolean OR)\n\t// other fun mixes are max(s1,s2) (boolean AND) and max(s1,-s2) (volume subtraction)\n}\n\nvec3 getNormal(vec3 pos){ // this gets the normal\n\t\t\t\t\t\t  // if you understand, good. if not, not much I can do.\n\tvec2 eps = vec2(0.0, EPS);\n\treturn normalize(vec3( // always normalise directions godammit\n\t\t\tscenedist(pos + eps.yxx) - scenedist(pos - eps.yxx),\n\t\t\tscenedist(pos + eps.xyx) - scenedist(pos - eps.xyx),\n\t\t\tscenedist(pos + eps.xxy) - scenedist(pos - eps.xxy)));\n}\n\nvec3 renderworld(vec2 uv, float screen){ // this is where we do everything\n\t\n\t// put the camera somewhere\n\t// sin and cos are useful for making circles, so we spin around\n\tvec3 camPos = vec3(4.*sin(iTime),4.*cos(iTime),1.)-vec3(.0,.0,.0);\n\t// what to look at (the center for now)\n\tvec3 camTarg = vec3(0.);\n\t// which way is up? I like Z. This is world-relative for now.\n\tvec3 camUp = normalize(vec3(0.,0.,1.));\n\t\n\t// camera points to target from camera\n\t// remember that all directions must be normalised, or shit goes craycray\n\tvec3 camDir = normalize(camTarg - camPos);\n\t// right is perpendicular to up and forwards\n\tvec3 camRight = normalize(cross(camUp,camDir));\n\t// change UP to be relative to camera\n\tcamUp = normalize(cross(camDir,camRight));\n    \n    // shift camera for MAD 3D OCULUS RIFTING BRO\n    camPos += camRight*screen*0.1;\n\t\n\t// This pixel will cast ray in the camera direction, but a bit up/down and sidewise\n\tvec3 rayDir = normalize(camDir+uv.x*camRight+uv.y*camUp);\n\t\n\t// the first distance we will jump\n\tfloat dist = scenedist(camPos);\n\t// must maintain the total or we will not know where we hit when we do\n\tfloat total = dist;\n\t\n\t// now we march along the ray a lot\n\tfor(int i = 0;i<MAXI;i++){\n\t\tdist = scenedist(camPos+rayDir*total); // distance to closest thing (safe jump distance)\n\t\ttotal += dist;\t\t\t\t\t\t   // add it to our progress\n\t\tif(dist<EPS || dist>MAXD){continue;}   // quit if we hit something or are lost\n\t}\n\tvec3 dest = camPos+rayDir*total; // this is where we ended up\n\tvec3 c;\t\t\t\t\t\t\t // this will be our pixel colour\n\tif(dist<EPS){\t\t\t\t\t // if we score a hit\n\t\tc = getNormal(dest);         // we make colours\n\t\t\t\t\t\t\t\t\t // this is where your material and lighting shit goes when you are pro\n\t}else{\t\t\t\t\t\t\t // no hit, we are lost in the sky\n\t\tc = hsv(.55,smoothstep(-1.5,1.,uv.y),1.); // make teh pretty blue skies\n\t}\n\t\t\n\treturn c; // give the colour back\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) // IS LIKE C(++), you start with the main\n{\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\t// the usual screen position thing\n    float screen = sign(uv.x-.5);\t\t\t\t// -1 for left eye, +1 for right eye\n    uv.x = mod(uv.x,0.5)*2.;\t\t\t\t\t// actually split the screen into two 0..1 ranges\n    uv = (uv-.5);\t\t\t\t\t\t\t\t// centre the coordinate system\n    uv.y /= (iResolution.x/2.)/iResolution.y;\t// add vertical space for aspect ratio thing\n    \n\t// step 1: figure out where you are\n\t// step 2: do everything else\n\tvec3 c = renderworld(uv,screen);\n\t\n\t// you can insert screen-space code here if you want. Blurs and shit are really expensive though.\n\t\n\tfragColor = vec4(c,1.0);// make this pixel pretty colours\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ls2SWD","date":"1412329622","viewed":548,"name":"Raymarch Tut Thingy - Oculus","username":"squeakyneb","description":"My simple raymarching shader with tutorial comments now with OCULUS SUPPORT!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","example","simple","raymarched","tutorial","sample","oculus","rift","dk2"],"hasliked":0,"parentid":"","parentname":""}}