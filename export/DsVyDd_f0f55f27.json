{"ver":"0.1","info":{"id":"DsVyDd","date":"1696753523","viewed":39,"name":"pigeon of universe","username":"nayk","description":"creation, copypast, universe, stars,  love and peace","likes":0,"published":1,"flags":1,"usePreview":0,"tags":["stars","universe","creation","copypast","loveandpeace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* originals https://www.shadertoy.com/view/lslyRn and https://www.shadertoy.com/view/cljyWc */\n\n#define iterations 17\n#define formuparam 0.53\n\n#define volsteps 20\n#define stepsize 0.1\n\n#define zoom   0.800\n#define tile   0.850\n#define speed  0.000 \n\n#define brightness 0.0015\n#define darkmatter 0.300\n#define distfading 0.730\n#define saturation 0.750\n\n\n#define MAX_STEPS 250\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,normalize(n)) + h;\n}\n\nfloat sdSphere( vec3 p, vec3 c, float r )\n{\n    return length(p-c) - r;\n}\n\nfloat sdEllipsoid( vec3 po, vec3 c, vec3 r )\n{\n    vec3 p = po-c;\n\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdCutSphere( vec3 po, vec3 c, float r, float h )\n{\n    vec3 p = po-c;\n    float w = sqrt(r*r-h*h);\n    \n    vec2 q = vec2( length((p).xz), p.y );\n    \n    float s = max( (h-r)*q.x*q.x+w*w*(h+r-2.0*q.y), h*q.x-w*q.y );\n\n    return (s<0.0) ? length(q)-r :\n           (q.x<w) ? h - q.y     :\n                     length(q-vec2(w,h));\n}\n\n\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x * 2.*TAU);\n    //p = rotX(p, -m.y*PI - PI / 2.0);\n    return p;\n}\n\n\n\nvec2 map(vec3 po) {\n    // Mouse\n    vec2 m = (2.*iMouse.xy-iResolution.xy)/iResolution.y;  \n    vec3 p = orbitControls(po);\n    //vec3 p = po;\n    vec3 pSym = vec3(abs(p.x), p.y, p.z);\n    vec2 res;\n    \n    // body + head\n    float s1 = sdEllipsoid(p, vec3(0., -0.3, 0.),vec3(0.65, 0.54, 0.7));\n    float s2 = sdEllipsoid(p, vec3(0., -0.4, 0.4),vec3(0.4, 0.3, 0.4));\n    res = vec2(s1, 1.0); // id to track color\n    float h = sdCapsule(p, vec3(0.0, 0., -0.35), vec3(0.0, 0.7, -0.4), 0.3);\n    h += 0.07 * p.y;\n    res.x = opSmoothUnion(s1, h, 0.2);\n    \n    // tail\n    float s31 = sdEllipsoid(p, vec3(0., -0.4, 1.),vec3(0.15, 0.06, 0.4));\n    \n    res.x = opSmoothUnion(res.x, s2, 0.2);\n\n    // wings\n    vec3 psw = vec3(pSym.x, pSym.y * (1.0 + 0.6 * pSym.z) + 0.2 * pSym.z, pSym.z);\n    vec3 prw = rotZ(rotY(psw, 0.15), 0.4);\n    float w = sdEllipsoid(prw, vec3(0.45, -0.48, 0.1), vec3(0.1, 0.35, 0.45));\n    \n    res.x = opSmoothUnion(res.x, w, 0.05);\n    \n    // eyelids\n    float lidAngle = 0.3;\n    vec3 pre = rotX(pSym-vec3(0.135, 0.65, -0.6), lidAngle); // translate then rotate\n    pre = rotZ(pre, 0.3);\n    float el = sdCutSphere(pre, vec3(0.0), 0.08\n    , 0.02)-0.01;\n    res.x = opSmoothUnion(res.x, el, 0.02);\n    if (el < res.x+SURF_DIST) res.y = .0;\n    \n    // eyes\n    float e = sdSphere(pSym, vec3(0.135, 0.65, -0.6), 0.07);\n    res.x = opSmoothUnion(res.x, e, 0.);\n    if (e < res.x+SURF_DIST) res.y = 2.0;\n    \n    float pupil = sdSphere(pSym, vec3(0.16, 0.66, -0.63), 0.045);\n    pupil = opIntersection(pupil, e);\n    res.x = opSmoothUnion(res.x, pupil, 0.);\n    if (pupil < res.x+SURF_DIST) res.y = 5.0;\n    \n    \n    // beak\n    float bk = sdEllipsoid(p, vec3(0., 0.55, -0.65), vec3(0.11, 0.06, 0.12));\n    float bkb = sdEllipsoid(p, vec3(0., 0.53, -0.65), vec3(0.09, 0.06, 0.07));\n    bk = opSmoothUnion(bk, bkb, 0.0);\n    \n    res.x = opSmoothUnion(res.x, bk, 0.0);\n    if (bk < res.x+SURF_DIST) res.y = 3.0;\n    \n    float bkc = sdEllipsoid(p, vec3(0., 0.575, -0.65), vec3(0.09, 0.06, 0.05));\n    if (bkc < res.x+SURF_DIST) res.y = 2.0;\n    res.x = opSmoothUnion(res.x, bkc, 0.0);\n    \n    \n    \n    // foots\n    \n    vec3 heel = vec3(0.25, -1.1, -0.);\n    vec3 hip = vec3(0.25, -0.75, -0.);\n    res.x = opSmoothUnion(res.x, sdSphere(pSym, hip-vec3(0.02,0.,0.), 0.125), 0.06);\n    \n    \n    float l = sdCapsule(pSym, hip, heel + vec3(0., 0.02, 0.), 0.04);\n    float t1 = sdCapsule(pSym, heel, heel + vec3(0., 0., -0.15), 0.04);\n    float t2 = sdCapsule(pSym, heel, heel + vec3(0.1, 0., -0.15), 0.04);\n    float t3 = sdCapsule(pSym, heel, heel + vec3(-0.1, 0., -0.15), 0.04);\n    float toes = opUnion(t1, opUnion(t2, t3));\n    \n    l = opSmoothUnion(l, toes, 0.02);\n    \n    \n    res.x = opSmoothUnion(res.x, l, 0.);\n    if (l < res.x+SURF_DIST) res.y = 3.0;\n\n\n    return res;\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += ds.x;\n        mat = ds.y;\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n        i++;\n    }\n    return vec2(d, mat);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vw+= vec3(0.1*sin(iTime),0.1*cos(iTime),0.1*sin(iTime));\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(30.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n\n    return normalize(rd);\n}\n\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd )\n{\n\t//get coords and direction\n\tvec3 dir=rd;\n\tvec3 from=ro;\n\t\n\t//volumetric rendering\n\tfloat s=0.1,fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<volsteps; r++) {\n\t\tvec3 p=from+s*dir*.5;\n\t\tp = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n\t\tfloat pa,a=pa=0.;\n\t\tfor (int i=0; i<iterations; i++) { \n\t\t\tp=abs(p)/dot(p,p)-formuparam; // the magic formula\n\t\t\ta+=abs(length(p)-pa); // absolute sum of average change\n\t\t\tpa=length(p);\n\t\t}\n\t\tfloat dm=max(0.,darkmatter-a*a*.001); //dark matter\n\t\ta*=a*a; // add contrast\n\t\tif (r>6) fade*=1.-dm; // dark matter, don't render near\n\t\t\n\t\tv+=fade;\n\t\tv+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n\t\tfade*=distfading; // distance fading\n\t\ts+=stepsize;\n\t}\n\tv=mix(vec3(length(v)),v,saturation); //color adjust\n\tfragColor = vec4(v*.03,1.);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*zoom,iTime*0.02);\n\tfloat time=iTime*speed+.25;\n\n    \n \n    float shift = min(10. , 6.5);\n    \n    vec3 rt = vec3(0., -0.05, -10.5);\n    vec3 ro = vec3(0., -0.05, -20. + shift);\n    \n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec2 d = rayMarch(ro, rd);\n\n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n\n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 pr = orbitControls(p);\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n        vec3 c1 = vec3(1.2,0.8,1.);\n        vec3 c2 = vec3(0.8,0.2,1.);\n        \n        vec3 color = c1;\n        \n        if (d.y == 2.) color.xyz = vec3(1.);        \n        if (d.y == 3.) color.xyz = vec3(1., 0.9, 0.4);        \n        if (d.y == 4.) color.xyz = vec3(1.);        \n        if (d.y == 5.) color.xyz = vec3(0.);        \n        \n        \n        \n        color *= illumination; \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0),10.0);\n                \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45 + specular * 0.08;\n       \n\t//mouse rotation\n\tfloat a1=.5+iMouse.x/iResolution.x*2.;\n\tfloat a2=.8+iMouse.y/iResolution.y*2.;\n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,0.5)+color;\n\tfrom+=vec3(time*2.,time,-2.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\tmainVR(fragColor, fragCoord, from, dir);\t\n}}\n","name":"Image","description":"","type":"image"}]}