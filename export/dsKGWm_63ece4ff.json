{"ver":"0.1","info":{"id":"dsKGWm","date":"1678687754","viewed":112,"name":"Simple railroad","username":"ianertson","description":"Just wanted to test if I could make an \"infinite\" railroad that goes into various directions, and have the camera follow the railroad as well as face the direction it's heading.\n\n(Description continues as a comment in \"Image\")","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","raymarch","sdf","railroad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Just wanted to test if I could make an \"infinite\" railroad\n    that goes into various directions, and have the camera follow the railroad\n    as well as face the direction it's heading.\n    \n    Some problems:\n    \n    1. Couldn't make the thing infinite because \"cos\" and \"sin\" breaks after a while.\n       So I ended up just using fract() of time.\n    \n    2. I'm not sure why, but I can't for the life of me make the camera properly face\n       the direction it's heading.\n       The current solution is just some hack I came up with.\n       \n   ---------------\n\n   Anyways, use the mouse to look around :)\n\n*/\n\n#define WALK 0\n\n#define NEAR 0.003\n#define FAR 100.0\n#define STEPS 84\n#define SHADOW_STEPS 33\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_PLANK 3\n#define ID_RAIL 4\n\n#define NOISE(P, SEED, LOD) (textureLod(iChannel3, ((P) + ((SEED)*1.98277215))/256., LOD).rgb)\n\n\nfloat rand(in vec2 p, in float seed) {\n    p += fract(seed*10.2381892);\n    vec3 p1 = vec3(fract(seed*33.6625281283), fract(p.yx*11.773332613));\n    vec3 p2 = vec3(fract(p.xy*10.89271842), fract(seed*10.99277733)) * 2.0 - 1.0;\n    vec3 p3 = fract(cross(p1, p2)*10.87827733);\n    vec3 p4 = refract(p3, p1, fract(dot(p1, p2)*10.33928187));\n    return fract(10.33828*dot(vec3(p.xy, fract(length(p)+seed))-p4, p3));\n    \n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, float freq, float warp, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n        p += (n.xz+n.y)*warp;\n    }\n    return n / div;\n}\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    };\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat railSDF(in vec3 p, in float maxLen, in int skip, inout int id) {\n\n    float len = 4.0;\n   // if (floor(abs(p.z)-len) >= maxLen) return FAR;\n    p.z = mod(p.z, len)-0.2015;\n    \n    id = ID_PLANK;\n    float dist = FAR;\n    \n    vec3 plankSize = vec3(0.9, 0.06, 0.2);\n    float plank = boxSDF(p - vec3(0, plankSize.y, 0), plankSize);\n    \n    float r = 0.05;\n    \n    \n    \n    float rail = cylSDF(vec3(abs(p.x), p.y, p.z) - vec3(plankSize.x+r, r + plankSize.y, -plankSize.z), vec3(0, 0, 0), vec3(0, 0, len), r);\n    \n    \n    SAMPLE(plank, ID_PLANK);\n    SAMPLE(rail, ID_RAIL);\n    \n    return dist/1.3;\n}\n\n\n\nfloat getRailYaw(in vec3 p) {\n    return radians(cos(fract(p.z*0.01)*TAU));\n}\n\nmat2 getRailRot(in vec3 p) {\n    float s = getRailYaw(p);\n    return rot((s));\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n    \n\n   // vec3 roadPos = vec3(0.0);\n    //float path = roadPath(p, roadPos);\n    \n    int railId = 0;\n   // p.xz += roadPos.xz;\n    p.xz *= getRailRot(p);\n    float rail = railSDF(p, 16., skip, railId);\n    SAMPLE(rail, railId);\n    \n    //float box = boxSDF(p - vec3(0, 1, 0), vec3(1.0));\n    //SAMPLE(box, ID_BOX);\n    \n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    data.skip = skip;\n\n    float d = 0.0;\n    float r = 1.0;\n    float avg = 0.0;\n    float c = 0.0;\n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.13;\n        avg += next;\n        c += 1.0;\n        if (abs(next) <= (NEAR * (1.0 + d))) break;\n        if (abs(d) >= FAR) break;\n    }\n    \n    avg /= c;\n    \n    return clamp(avg + r, AMBIENT, 1.0);\n}\n\nvec3 plankTexture(in vec2 uv, in vec3 p, inout Material m, in float tile) {\n    vec3 col = vec3(0.0);\n    \n    vec3 hf1 = snoise(uv, 0.0321122, 0.33, 128.0, 6);\n    vec3 hf2 = snoise(uv, 1.0928325, 0.5, 128.0, 6);\n    \n    vec3 lf1 = snoise(uv, 4.3092911, 0.1, 4.0, 6);\n    \n    vec3 c1 = rgb(159, 112, 90);\n    vec3 c2 = rgb(204, 131, 74);\n    vec3 c3 = rgb(156, 126, 108);\n    vec3 c4 = rgb(99, 54, 30);\n    vec3 c5 = rgb(230, 192, 141);\n    \n    vec3 col1 = mix(mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z), c5, hf2.x*hf2.x);\n    col += col1;\n    \n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float lines = mod(length(vec2(alv.x/2., alv.y)), 0.4*cos(alv.y*(TAU-(alv.x/2.+hf2.y)))*hf2.z);\n    lines = max(0.002, 1.0-max(0.0, 0.5-lines));\n    \n    col = mix(col, col*col*col, lines);\n    \n    float x = 1.0+fract(uv.x/2.);\n    \n    float w2 = fract(mod((x*tile)*10.*lf1.y, sin((uv.y*tile)*TAU)*2.));\n    col = mix(col, mix(c1, c5, hf1.z), w2*0.6);\n    \n    float t2 = fract(uv.y*tile*2.);\n    float gs = smoothstep(0.5-0.25, 0.5+0.25, abs(t2*2.0-1.0)-0.5);\n    col = mix(col, col*col, gs);\n    \n    m.z = clamp((w2*lf1.x)*max(0.0, 0.5-gs), 0.0, 1.0);\n    m.spec = clamp(w2*lf1.y, 0.0, 1.0);\n    \n    return col;\n}\n\n//#define DEBUG_TEXTURE grassTexture\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 g1 = rgb(113, 125, 86);\n    vec3 g2 = rgb(139, 134, 104);\n    vec3 g3 = rgb(95, 99, 18);\n    vec3 g4 = rgb(79, 102, 29);\n    \n    vec3 d1 = rgb(131, 129, 111);\n    vec3 d2 = rgb(108, 103, 91);\n    vec3 d3 = rgb(141, 114, 85);\n    vec3 d4 = rgb(87, 66, 56);\n    \n    vec3 warp = snoiseWarp(uv, 0.3333821, 1.0, 32.0, 0.22, 6);\n    vec3 hf1 = snoise(uv, 2.2233884, 0.5, 100.0, 6);\n    vec3 hf2 = abs(normalize(cross(warp*2.0-1.0, hf1*2.0-1.0)));\n    vec3 hf3 = snoise(uv, 4.44287815, 0.3, 116.0, 6);\n    vec3 hf4 = abs(normalize(reflect(cross(hf3*2.0-1.0, warp*2.0-1.0), hf2*2.0-1.0)));\n    vec3 lf1 = snoise(uv, 9.2388854, 0.2, 6.0, 6);\n    vec3 lf2 = abs(normalize(cross(warp*2.0-1.0, lf1*2.0-1.0)));\n    vec3 hf5 = abs(normalize(reflect(cross(hf4*2.0-1.0, lf2*2.0-1.0), hf1*2.0-1.0)));\n    \n    \n    float tile = 16.0;\n    vec2 id = floor(uv*tile);\n    float seed = 3.392812;\n    vec2 lv = fract(uv*tile);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    vec2 alv = abs(lv*2.0-1.0);\n    float idr = mix(\n    mix(rand(id, seed), rand(id+vec2(1, 0), seed), slv.x),\n    mix(rand(id+vec2(0, 1), seed), rand(id+vec2(1, 1), seed), slv.x),slv.y);\n    uv *= rot(idr);\n    lv = fract(uv*tile);\n    slv = lv*lv*(3.0-2.0*lv);\n    alv = abs(lv*2.0-1.0);\n    float line1 = line2D(lv, vec2(0.0), vec2(1, 1), 0.05);\n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    vec3 dirtCol = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n    \n    float dirtReg = smoothstep(0.39, 0.89, lf1.x);\n    float grain = clamp((hf5.x*warp.x*lf1.y)+(hf4.z*warp.z*warp.z), 0.0, 1.0);\n    \n    \n    col += grassCol;\n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, grain);\n    \n    m.spec = clamp(pow(dirtReg*lf1.x*warp.y, 2.)+(grain*warp.y*0.3*grain), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 dirtyMetalTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(131, 131, 131);\n    vec3 c2 = rgb(172, 173, 176);\n    vec3 c3 = rgb(103, 113, 125);\n    vec3 c4 = rgb(192, 192, 192);\n    \n    vec3 d1 = rgb(87, 78, 76);\n    vec3 d2 = rgb(59, 53, 44);\n    vec3 d3 = rgb(178, 118, 83);\n    vec3 d4 = rgb(176, 80, 70);\n    \n    vec3 warp = snoiseWarp(uv, 0.0288231, 1., 32.0, 0.2, 6);\n    vec3 hf1 = snoise(uv, 2.8981819, 1.0, 100.0, 6);\n    float w = wnoise(uv*12., 6, 1.);\n    vec3 hf2 = abs(normalize(cross(vec3(warp.z*2.0-1.0, hf1.x*2.0-1.0, w*2.0-1.0), hf1-warp)));\n    vec3 lf1 = snoise(uv, 5.54828155, 0.5, 8.0, 6);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    vec3 dirtCol = mix(mix(mix(d1, d2, hf2.x), d3, hf2.y), d4, hf2.z);\n \n    float dirtReg = smoothstep(0.3 + (hf2.x*0.09), 1.0, lf1.y);\n    float wear = smoothstep(0.0+hf2.z, 1.-(lf1.y*0.2), abs(hf2.x*2.0-1.0));\n    wear = wear*lf1.z*warp.y;\n    float bulge = w*warp.x*hf2.y;\n    float scratch = max(0.0, 1.0-smoothstep(0.02, 0.04, abs(lf1.x*2.0-1.0)));\n    scratch = scratch*bulge*lf1.z;\n    \n    col += col1;\n    \n    col = mix(col, dirtCol, dirtReg);\n    col = mix(col, col*col, wear);\n    col = mix(col, col*col, bulge);\n    col = mix(col, dirtCol, scratch);\n    \n    m.rough = clamp((wear+scratch+bulge)*1.9, 0.0, 1.0);\n    m.metallic = clamp(1.0-((wear+bulge)*3.), 0.0, 1.0);\n    m.spec = clamp(1.0-((wear+scratch)*3.), 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = grassTexture(uv, p, data.m);\n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    return texture(iChannel3, uv).rgb;\n}\n\nvec3 getAlbedoPlank(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    mat2 railrot = getRailRot(p);\n    \n    p.xz *= railrot;\n    vec3 n2 = n;\n    n2.xz *= railrot;\n    \n    uv = boxUv(p, n2);\n    \n    vec3 col = plankTexture(uv+0.5*0.5, p, data.m, 1.);\n    return col;\n}\n\nvec3 getAlbedoRail(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    vec3 col = dirtyMetalTexture(uv+0.5*0.5, p, data.m);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_PLANK: return getAlbedoPlank(data); break;\n        case ID_RAIL: return getAlbedoRail(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = vec3(pow(vec3(0.29, 0.61, 0.9), vec3(1.0 + dotup)));\n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.), L, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.81, 0.75), 2.0, LIGHT_AMBIENT);\n    \n    vec3 mixf = vec3(1.0);\n    float dist = FAR;\n    \n    for (int j = ZERO; j < 2; j++) {\n        if (march(data, ro, rd)) {\n            if (j <= 0) {\n                dist = data.d;\n            }\n            vec3 albedo = getAlbedo(data);\n            vec3 diffuse = albedo / M_PI;\n\n            col += forEachLight(data, light, ro, rd, diffuse) * mixf;\n            \n            float rough = data.m.rough;\n            \n            if (rough >= 0.999) break;\n            \n            \n            float metallic = data.m.metallic;\n            vec3 p = data.p;\n            vec3 n = data.n;\n            float NdotV = dot(n,-rd);\n            vec3 f0 = mix(vec3(0.04), diffuse, metallic);\n            \n            vec3 F = fresnelSchlickRoughness(NdotV, f0, rough*rough);\n            mixf = F;\n            \n            rd = reflect(rd, n);\n            ro = p + (n*NEAR*2.);\n            //data.skip = data.id;\n            \n        } else {\n            col += getSky(rd) * mixf;\n            break;\n        }\n    }\n    \n    float depth = dist / FAR;\n    \n    col += smoothstep(0.05, 1.0, depth) * max(0.0, 1.0 - smoothstep(-0.02, 0.15, dotup));\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -6.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    #if WALK\n    \n    ro.z = 0.;\n    vec3 walk = texelFetch(iChannel0, ivec2(0, 0), 0).xyz;\n    vec3 fly = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    ro += walk;\n    ro.y += fly.y;\n    \n    rd.yz *= rot(m.y*TAU);\n    rd.xz *= rot(m.x*TAU);\n    \n    return;\n    #endif\n    \n    \n    if (length(m.xy) > 0.001 && iFrame > 1 && iTime > 0.0003 && m.z > 0.01) {\n     //   ro.yz *= rot(m.y*TAU);\n   //     ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    }\n    ro.z = 0.;\n    float tt = 100.0+(fract(T*0.01)*1000.);\n    \n    mat2 railrot = getRailRot(vec3(0, 0, tt));\n    float pitch = getRailYaw(vec3(0, 0, tt));\n    ro.z += tt;\n    \n    ro.xz *= inverse(railrot);\n    float dp = dot(normalize(ro), vec3(-1., 0, 0.));\n    float sig = sign(dp);\n    dp = pow(abs(dp), 2.)*sig*2.;\n   \n    ro.xz -= vec2(sin(45.*dp), cos(45.*dp))*0.5;\n    rd.xz *= rot(4.0*sin(45.0*dp));\n    rd.xy *= rot(M_PI*sin(70.0*dp));\n    \n    float y = 1.1;\n    ro.y += y;\n    ro.y = max(y, ro.y);\n\n}\n\nvec4 shade(in vec2 fc)\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd);\n    col = aces(col);\n    //col /= 1.0 + max(col-0.5, 0.0);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    O = vec4(0);\n    float samples = 2.0;\n    float siz = 1.0/samples;\n    float x = 0.0;\n    float y = 0.0;\n    for (x =- 0.5; x < 0.5; x += siz) {\n        for (y= - 0.5; y < 0.5; y += siz) {\n            O += min(shade(vec2(x,y)+fc), 1.0);\n        }\n    }\n\tO /= samples*samples;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\n\n#define AMBIENT 0.05\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) : \n        light.type == LIGHT_POINT ? normalize(light.p - p) :\n            normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.xz, round(adot(n, vec3(0, 1, 0)))), p.zy, round(adot(n, vec3(1, 0, 0))));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nvec3 aces(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n    float bumpScale = s;\n    vec3 normal = normalize(cross(vec3(dx, bumpScale), vec3(dy, bumpScale)));\n    normal += bumpScale * normalize(normal);\n    \n   \n    vec3 next = (wn+normal);\n    float dp = clamp(dot(wn, next), 0.0, 1.0);\n   \n    \n    return normalize(mix(wn, next, mx*dp*length(next)));\n    \n}\n\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return max(0.0, 1.0-length(pa - ba * h)/t);\n}\n\nvec3 look(vec2 uv, vec3 point, vec3 ro) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 lookDir(vec2 uv, vec3 camForward, in vec3 ro) {\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * 1.;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// taken from https://www.shadertoy.com/view/ldGGzV\n\n#define MOVE_SPEED 10.\n#define PI 3.14159\n\nconst float KEY_W = 87.5 / 256.0;\nconst float KEY_A = 65.5 / 256.0;\nconst float KEY_S = 83.5 / 256.0;\nconst float KEY_D = 68.5 / 256.0;\nconst float KEY_SHIFT = 16.0;\nconst float KEY_SPACE = 32.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 pos = texture(iChannel1, vec2(0.)).xyz;\n    if(iFrame == 0) pos = vec3(0.,3.,0.);\n    \n    switch (int(fragCoord.x)) {\n        case 0: {\n            float mx = iMouse.xy == vec2(0.) ? 0. : ((iMouse.x / iResolution.x) * 2. - 1.) * 360.;\n            float speed = MOVE_SPEED * iTimeDelta;\n\n            float forwardBackward =\n            texture(iChannel0, vec2(KEY_W, 0.)).r -\n            texture(iChannel0, vec2(KEY_S, 0.)).r;\n\n            float leftRight =\n            texture(iChannel0, vec2(KEY_A, 0.)).r -\n            texture(iChannel0, vec2(KEY_D, 0.)).r;\n\n            float s = sin(radians(mx));\n            float c = cos(radians(mx));\n\n            pos.x += speed * (forwardBackward * s - leftRight * c);\n            pos.z += speed * (forwardBackward * c + leftRight * s);\n        \n        }; break;\n        case 1: {\n            pos = texelFetch(iChannel1, ivec2(1, 0), 0).xyz;\n            float space = texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).r;\n            float shift = texelFetch(iChannel0, ivec2(KEY_SHIFT, 0), 0).r;\n            \n            pos.y += space * 0.2;\n            pos.y -= shift * 0.2;\n           \n        \n        }; break;\n    }\n    \n    \n    fragColor = vec4(pos, 0.);\n}","name":"Buffer D","description":"","type":"buffer"}]}