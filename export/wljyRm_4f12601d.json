{"ver":"0.1","info":{"id":"wljyRm","date":"1614867707","viewed":32,"name":"Triangle Mesh Colours","username":"Reynolds","description":"With quartic and linear interpolation.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["triangle","barycentric","interpolation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int res = 4;\n\nfloat area(vec2 p0, vec2 p1, vec2 p2) {\n\treturn (\n        (p1.x - p0.x)*(p2.y - p0.y) - (p2.x - p0.x)*(p1.y - p0.y)\n        );\n}\n                        \nvec3 cols2[10] = vec3[10](\n    \t\t\t\t\tvec3(1.0, 0.0, 0.0) ,\n    \t\t\t\t\tvec3(0.75, 0.25, 0.0),\n\t\t\t\t\t\tvec3(0.5, 0.0, 1.0),\n\t\t\t\t\t\t\n                        \n    \t\t\t\t\tvec3(0.0, 1.0, 0.0),\n                        vec3(0.75, 0.0, 0.25),\n                        vec3(0.5, 0.25, 0.25),\n                        vec3(0.25, 0.75, 0.0),\n                        \n                        vec3(0.25, 0.5, 1.0),\n                        vec3(0.0, 0.75, 1.0),\n                        \n    \t\t\t\t\tvec3(0.5, 0.0, 0.5)\n                        );\n\nint idx(int i, int j) {\n    return i + (j * res - j*(j-1)/2);\n}\n\n\nvec3 meshColor(int x, int y) {\n    return cols2[(idx(x,y) + int(iTime)) % 10];\n}\n\nvec3 quartic_interpolation(vec3 luvw, vec3 c0, vec3 c1, vec3 c2) {\n\tvec3 luvw2 = luvw*luvw;\n\tvec3 luvw3 = luvw2*luvw;\n\n\tvec3 quvw = vec3(luvw.x*luvw3.x + 4.0*luvw3.x*(luvw.y + luvw.z) + 12.0*luvw2.x*luvw.y*luvw.z,\n\t                 luvw.y*luvw3.y + 4.0*luvw3.y*(luvw.x + luvw.z) + 12.0*luvw.x*luvw2.y*luvw.z,\n\t                 luvw.z*luvw3.z + 4.0*luvw3.z*(luvw.x + luvw.y) + 12.0*luvw.x*luvw.y*luvw2.z);\n    \n\tvec3 qedge = 6.0*vec3(luvw2.x*luvw2.y,\n\t                      luvw2.y*luvw2.z,\n\t                      luvw2.z*luvw2.x);\n                \n\treturn quvw.x*c0 + quvw.y*c1 + quvw.z*c2 + 0.5*(c0+c1) * qedge.x + 0.5*(c1+c2) * qedge.y + 0.5*(c2+c0) * qedge.z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    vec3 uvw = vec3(area(uv, vec2(1.,0.), vec2(0., 1.)),\n                    area(uv, vec2(0.,1.), vec2(0., 0.)),\n                    area(uv, vec2(0.,0.), vec2(1., 0.)));\n                    \n    float u = uvw[0];\n\tfloat v = uvw[1];\n\tfloat w = uvw[2];      \n    \n    \n    float fres = float(res - 1);\n    float fresrecp = 1.0 / fres;\n    \n    bool upper = (mod(v, fresrecp) + mod(w, fresrecp)) > fresrecp;\n\n\tint x = int(floor(fres * v));\n\tint y = int(floor(fres * w));\n    \n    vec3 luvw = fract(fres*vec3(u, v, w));\n    \n    vec3 c0, c1, c2;\n    \n\n    if(upper) {\n        luvw = vec3(1.0) - luvw;\n        \n        c2 = meshColor(x+1, y);\n        c0 = meshColor(x+1, y+1);\n        c1 = meshColor(x, y+1);\n    } else {\n        c0 = meshColor(x, y);\n        c1 = meshColor(x+1, y);\n        c2 = meshColor(x, y+1);\n    }\n    \n\n    vec3 col = quartic_interpolation(luvw, c0, c1, c2);\n    //or use simple linear interpolation.\n    //vec3 col = luvw.x*c0 + luvw.y*c1 + luvw.z*c2;\n    \n    //uncomment next line to see parametrisation.\n    //col = luvw;\n    col = (uv.x + uv.y > 1.) ? vec3(0.0, 0.0, 0.0) : col;\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}