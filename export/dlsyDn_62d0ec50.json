{"ver":"0.1","info":{"id":"dlsyDn","date":"1690893436","viewed":166,"name":"Triangle Synth","username":"User228","description":"Triangle neon lofi","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["triangle","reflect","ground","neon","synth"],"hasliked":0,"parentid":"Dlfyz8","parentname":"Triangle Neon"},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Includes and constants\n#define HSV2RGB_K  vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0)\n#define HSV2RGB(c) (c.z * mix(HSV2RGB_K.xxx, clamp(abs(fract(c.xxx + HSV2RGB_K.xyz) * 6.0 - HSV2RGB_K.www) - HSV2RGB_K.xxx, 0.0, 1.0), c.y))\n\nvec4 Noise(in ivec2 x) {\n    return texture(iChannel0, (vec2(x) + 0.5) / 256.0, -100.0);\n}\n\n// Sun direction and color\nvec3 sunDir = normalize(vec3(0.0, -2.0, 20.0));\nconst vec3 sunCol = HSV2RGB(vec3(0.01, 0.5, 0.002));\n\n// Function for rendering the outer sky\nvec3 outerSkyRender(vec3 ro, vec3 rd) {\n    vec3 col = HSV2RGB(vec3(1.0, 0.00, 0.008));\n\n  // Sun settings\n    col += sunCol / pow((1.002 - dot(sunDir, rd)), 1.9);\n\n  // Horizon light modifier\n    vec3 gcol = HSV2RGB(vec3(1.0, 0.4, 0.008));\n    gcol = gcol * 0.3;\n\n  // Atmosphere air color\n    col += HSV2RGB(vec3(0.97, 0.0, 0.1));\n  // add glow to sky\n    col += gcol / max(abs(rd.y), 0.0);\n    \n  // add stars to sky\n    vec3 ray = vec3(2.0 * ro.xy, 1.0);\n    float offset = iTime * 0.1;\n    float speed = 0.2;\n    vec3 stp = ray / max(abs(ray.x), abs(ray.y));\n    vec3 pos = stp + 0.5;\n    for (int i = 0; i < 10; i++) {\n        vec2 noise = Noise(ivec2(pos.xy)).xy;\n        float z = fract(noise.x - offset);\n        float d = 20.0 * z - pos.z;\n        float w = pow(max(0.0, 1.0 - 2.0 * length(fract(pos.xy) - 0.5)), 15.0);\n        vec3 c = max(vec3(0), vec3(1.0 - abs(d + speed * 0.5) / speed, 1.0 - abs(d) / speed, 1.0 - abs(d) / speed));\n        col += (1.0 - z) * c * w;\n        pos += stp;\n    }\n    \n    return col;\n}\n\n// Function for finding the intersection of a ray with a plane\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\n// Function to calculate the value of an equilateral triangle\nfloat equilateralTriangle(vec2 p) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0 / k;\n    if(p.x + k * p.y > 0.0)\n        p = vec2(p.x - k * p.y, -k * p.x - p.y) / 2.0;\n    p.x -= clamp(p.x, -2.0, 0.0);\n    return -length(p) * sign(p.y);\n}\n\n// Function for rendering the triangle\nvec3 triRender(vec3 col, vec3 ro, vec3 rd) {\n  // Triangle fill color\n    vec3 fillColor = vec3(0.005, 0.0, 0.0);\n\n  // Triangle calculations\n    const vec4 tpdim = vec4(0.0, 0.0, 1.0, -2.0);\n    float tpd = rayPlane(ro, rd, tpdim);\n    vec3 pp = ro + rd * tpd;\n    vec2 p = pp.xy;\n\n  // Triangle resize\n    p *= 0.5;\n\n  // Triangle y offset\n    p.y -= 0.58;\n\n  // Triangle inner glow factor\n    float hoff = dot(cos(0.7),p.y);\n    vec3 gcol = HSV2RGB(vec3(clamp(0.1+hoff, 0.0, 0.02), 0.8, 0.005));\n\n  // Triangle displacement\n    float dt = equilateralTriangle(p);\n\n  // Triangle to scene visibility ratio\n    col -= 10.0 * gcol;\n    col = dt < 0.0 ? fillColor : col;\n\n  // Triangle edge glow modification\n    col += (gcol / max(abs(dt), 0.002));\n    return col;\n}\n\n// Function for rendering the ground\nvec3 groundRender(vec3 col, vec3 ro, vec3 rd) {\n    const vec3 gpn = normalize(vec3(0.0, 1.0, 0.0));\n    const vec4 gpdim = vec4(gpn, 0.0);\n    float gpd = rayPlane(ro, rd, gpdim);\n\n    if(gpd < 0.0) {\n        return col;\n    }\n\n  // Tiles reflection modifier\n    vec3 gp = ro + rd * gpd;\n    float gpfre = 1.15 + dot(rd, gpn);\n    gpfre *= gpfre;\n    gpfre *= gpfre;\n\n    vec3 grr = reflect(rd, gpn);\n\n    vec2 ggp = gp.xz;\n    ggp.y += iTime;\n    float dfy = dFdy(ggp.y);\n    float gcf = sin(ggp.x) * sin(ggp.y);\n    vec2 ggn;\n\n  // Calculate the modulus\n    vec2 c = floor(ggp);\n    ggp = mod(ggp + vec2(0.5), vec2(1.0)) - vec2(0.5);\n    ggn = c;\n\n    float ggd = min(abs(ggp.x), abs(ggp.y));\n\n  // Tiles lines color modifier\n    vec3 gcol = HSV2RGB(vec3(0.01 * gcf, 0.7, 0.005));\n\n    vec3 rcol = outerSkyRender(grr, grr);\n    rcol = triRender(rcol, gp, grr);\n\n  // Tiles calculations\n    col = gcol / max(ggd, 0.0 + 0.25 * dfy) * exp(-0.25 * gpd);\n\n  // Ground horizon reflection color filter\n    rcol += HSV2RGB(vec3(0.0, 0.0, 0.0));\n  // Ground reflection factor\n    col += rcol * gpfre / 2.0;\n\n    return col;\n}\n\n// Main image rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    const float fov = 2.0;\n    vec3 ro = 1.0 * vec3(0.0, 0.5, -5.0);  // Camera location\n    vec3 la = vec3(0.0, 1.5, 0.0);          // Camera look at\n    vec3 up = vec3(0.0, 1.0, 0.0);           // Up vector\n\n  // Calculate camera coordinate system\n    vec3 ww = normalize(la - ro);\n    vec3 uu = normalize(cross(up, ww));\n    vec3 vv = cross(ww, uu);\n\n  // Convert and adjust pixel coordinates\n    vec2 q = (fragCoord / iResolution.xy - 0.5) * 2.0;\n    vec2 p = q * vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 pp = p;\n\n  // Calculate ray direction\n    vec3 rd = normalize(-p.x * uu + p.y * vv + fov * ww);\n\n  // Rendering process\n    vec3 col = outerSkyRender(rd, rd);\n    col = groundRender(col, ro, rd);\n    col = triRender(col, ro, rd);\n\n  // Set the final pixel color\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}