{"ver":"0.1","info":{"id":"cslfWn","date":"1688860661","viewed":183,"name":"inversion sets","username":"TGlad","description":"Classification table of recursive structures.\n    https://sites.google.com/site/simplextable/\nClick on a square for each example, or drag to slide through the parameter space.\n ","likes":7,"published":1,"flags":0,"usePreview":1,"tags":["fractal","tree","sponge","foam","shell","void","cluster","classification"],"hasliked":0,"parentid":"-1","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by Thomas Lowe, using ray trace method of evilryu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// camera stuff \nfloat stime, ctime;\n// camera motion code\nvoid ry(inout vec3 p, float a){  \n  float c,s;vec3 q=p;  \n  c = cos(a); s = sin(a);  \n  p.x = c * q.x + s * q.z;  \n  p.z = -s * q.x + c * q.z; \n}  \n\n#define pi 3.1415926535897932384 \n#define FASTER // faster render, but longer compile time\n// forward declarations: \nfloat sphereTree(vec3 p, int Iterations, float PackRatio, bool Rotated); \n\n// constants\nconst int Iterations = 15;\n\n// globals to allow a single setup prior to iterating each ray along its length\n// these are not constants, they will be changed as you click in different areas\nvec3 ns[12]; \nvec3 face;\nvec3 corner;\nvec3 edge;\nvec3 n0;\nfloat bend_mult = 1.0;\nfloat tree_connectivity = 0.5; // 0-1, 1 self-connects\nint Children = 3; // 1: tetra 2: octa 3: cube 4: dodec 5: icos \n// 1: void 2: cluster 3: tree 4: sponge 5: shell 6: foam 7: solid \nint MaterialStructure = 2; \nint ConnectiveStructure = 2;\nint mat_struct;\nint con_struct;\nfloat connectivity = 0.85;\n// for treeCluster()\nbool run_tree_cluster = true;\nbool shell_tree = false;\nbool is_cluster = false;\nbool is_void = false;\nfloat j_scale = 1.0;\nfloat k_scale = 1.0;\n// for sphereCluster()\nbool run_sphere_cluster = false;\nbool void_foam = false;\nbool foam_cluster = false;\nbool cluster_foam = false;   \nbool invert = false;\n// for sphereTree()\nbool run_sphere_tree = false;\n// for void shell\nbool run_void_shell = false;\n\n// simple reflection function, which reflects the curvature vector K aswell\nvoid reflection(inout vec3 p, inout vec3 K, vec3 n)\n{\n  float dt = dot(p, n);\n  if (dt < 0.0)\n  {\n    p -= (2.0*dt) * n;\n    K -= (2.0*dot(K, n)) * n;\n  }\n}\n\n// each iteration ends with this distance to sphere call\n// it undoes the accumulated curvature K in the transformations, to give a world-frame distance\nfloat distanceToSphere(vec3 p, vec3 K, float scale, vec3 target, float radius)\n{\n  bool negate = false;\n  float den = dot(K,K);\n  if (den > 0.0001)\n  {\n    vec3 offset = K / den;\n    offset *= scale; // since K is normalised to the scale     \n    float rad = length(offset);\n    offset += p;\n\n    target -= offset;\n    float mag = length(target);\n    // it is possible for the sphere to be inverted when you undo the curvature, so negate the distance\n    if (abs(radius/mag) > 1.0) \n      negate = true;\n    vec3 t1 = target * (1.0 - radius/mag);\n    vec3 t2 = target * (1.0 + radius/mag); \n    t1 *= rad*rad / dot(t1, t1);\n    t2 *= rad*rad / dot(t2, t2);\n    vec3 mid = (t1 + t2)/2.0;\n    radius = length(t1 - t2)/2.0;\n    target = mid + offset;    \n  }    \n  float dist = (length(p - target) - radius)/scale;\n  if (negate)\n    dist = -dist;\n  return dist;\n}\n\n// ns are the plane normals used to move the point into a single part of the face of the polyhedron\nvoid setCoxeterPlanes(int num_children)\n{\n  float phi = (1.0+sqrt(5.0))/2.0;\n  \n  // Define the Platonic solids and their Coxeter planes\n  if (num_children == 4)\n  {\n    vec3 t0 = vec3(1.0,1.0,-1.0);\n    vec3 t1 = vec3(1.0, -1.0, 1.0);\n    vec3 t2 = vec3(-1.0, 1.0, 1.0);\n         n0 = -normalize(cross(t0,t1));\n    vec3 n1 = -normalize(cross(t1,t2));\n    vec3 n2 = -normalize(cross(t2,t0));\n    vec3 n3 = -normalize(cross(t1, t0+t2));\n    vec3 n4 = normalize(cross(t2, t1+t0));\n    ns = vec3[](n0, n1, n2, n3, n4, n0, n0, n0, n0, n0, n0, n0);\n    face = (t0 + t1 + t2)/3.0;\n    corner = t0;\n    edge = (t0 + t1)/2.0;\n  } \n  else if (num_children == 6)\n  {\n    // Octahedral geometry\n         n0 = vec3(1.0,0.0,0.0);\n    vec3 n1 = vec3(0.0,1.0,0.0);\n    vec3 n2 = vec3(0.0,0.0,1.0);\n    vec3 n3 = normalize(vec3(0.5, 0.0, -0.5)); // cross(vec3(0.0,1.0,0.0), vec3(0.5,0.0,0.5)));\n    vec3 n4 = normalize(vec3(0.5, -0.5, 0.0)); // cross(vec3(0.0,0.0,1.0), vec3(0.5,0.5,0.0)));\n    ns = vec3[](n0, n1, n2, n3, n4, n0, n0, n0, n0, n0, n0, n0);\n    float inv3 = 1.0/3.0;\n    face = vec3(inv3, inv3, inv3);\n    corner = vec3(1.0,0.0,0.0);\n    edge = vec3(0.5,0.5,0.0);\n  } \n  else if (num_children == 8)\n  {\n    // Cubic geometry\n    float roothalf = sqrt(0.5);\n         n0 = vec3(roothalf,-roothalf,0.0);\n    vec3 n1 = vec3(roothalf,roothalf,0.0);\n    vec3 n2 = vec3(roothalf,0.0,-roothalf);\n    vec3 n3 = vec3(roothalf,0.0,roothalf);\n    vec3 n4 = vec3(0.0,1.0,0.0);\n    vec3 n5 = vec3(0.0,0.0,1.0);\n    ns = vec3[](n0, n1, n2, n3, n4, n5, n0, n0, n0, n0, n0, n0);\n    face = vec3(1.0,0.0,0.0);\n    corner = vec3(1.0, 1.0, 1.0);\n    edge = vec3(1.0,0.0,1.0);\n  }\n  else if (num_children == 12)\n  {\n    // Dodecahedral geometry\n    vec3 t0 = vec3(1.0/phi,0.0,phi);\n    vec3 t1 = vec3(1.0,-1.0,1.0);\n    vec3 t2 = vec3(phi,-1.0/phi,0.0);\n    vec3 t3 = vec3(phi,1.0/phi,0.0);\n    vec3 t4 = vec3(1.0,1.0,1.0);\n         n0 = normalize(cross(t0,t1));\n    vec3 n1 = normalize(cross(t1,t2));\n    vec3 n2 = normalize(cross(t2,t3));\n    vec3 n3 = normalize(cross(t3,t4));\n    vec3 n4 = normalize(cross(t4,t0));\n    face = (t0+t1+t2+t3+t4)/5.0;\n    vec3 n5 = -normalize(cross(face, t4+t0));\n    vec3 n6 = -normalize(cross(t4+t3, face));\n    ns = vec3[](n0, n1, n2, n3, n4, n0, n1, n2, n3, n5, n6, n5);\n    corner = t4;\n    edge = (t4 + t0)/2.0;\n  } \n  else if (num_children == 20)\n  {\n    // Isocahedral geometry\n    vec3 t0 = normalize(vec3(0.0,1.0,phi));\n    vec3 t1 = normalize(vec3(0.0,-1.0,phi));\n    vec3 t2 = normalize(vec3(phi,0.0,1.0));\n         n0 = normalize(cross(t0,t1));\n    vec3 n1 = normalize(cross(t1,t2));\n    vec3 n2 = normalize(cross(t2,t0));\n    face = (t0 + t1 + t2)/3.0;\n    vec3 n3 = -normalize(cross(face,t0+t2));\n    vec3 n4 = normalize(cross(face,t1+t2));\n    ns = vec3[](n0, n1, n2, n0, n1, n2, n0, n1, n2, n3, n4, n0);\n    corner = t2;\n    edge = (t2 + t0)/2.0;\n  }\n}\n\n// for the cluster-cluster, void-foam, foam-cluster and cluster-foam classes\nfloat sphereCluster(vec3 p, int Iterations, float PackRatio, int Children, bool void_foam, bool foam_cluster, bool cluster_foam)\n{\n  // platonic solids and their schlafi symbols\n  int childnums[5] = int[](4,6,8,12,20); \n  vec3 schlaflis[5] = vec3[](vec3(3.0,3.0,6.0), vec3(3.0,4.0,4.0), vec3(4.0,3.0,5.0), vec3(5.0, 3.0, 4.0), vec3(3.0,3.0,3.0));\n  int num_children = childnums[Children-1];\n  vec3 schlafli = schlaflis[Children-1];\n\n  float phi = (1.0+sqrt(5.0))/2.0;\n  \n  if (cluster_foam && Children > 3)\n    schlafli.y += 1.0;\n    \n  vec3 corner_dir = normalize(corner);\n  vec3 dir = normalize(face);\n \n  float mid_to_edge = asin(dot(n0, dir));\n  float sec = 1.0 / cos(pi/schlafli.z);\n  float csc = 1.0 / sin(mid_to_edge);\n  float r = sec / sqrt(csc*csc - sec*sec);  \n  float l = sqrt(1.0 + r*r);\n  float minr = l-r;  \n  float theta = asin(r * sin(pi - pi/schlafli.y) / l);\n  float R = l * sin(pi/schlafli.y - theta)/sin(pi - pi/schlafli.y);\n\n\n  float k = PackRatio;\n  float scale = 1.0;\n  vec3 K = vec3(0.0, 0.0, 0.0);\n  \n  // just size the shapes a bit better depending on the shape\n  if (void_foam)\n  {\n    p *= 0.7;\n    scale *= 0.7;\n  }\n  else if (foam_cluster)\n  {\n    p *= 0.5;\n    scale *= 0.5;\n  }\n\n  bool flip = false;\n  bool recurse = true;\n  float min_dist = 1e10;\n  for (int i = 0; i < Iterations; i++)\n  {\n    if (recurse) // each time you recurse down a level\n    {\n      min_dist = min(min_dist, (length(p) - minr)/scale);\n      float rad = minr;\n      if (void_foam)\n      {\n        rad = R*R;\n      }\n      float sc = rad/dot(p, p);\n      scale *= sc;\n      // these K changes are to match the transformation on p\n      K += p*scale/rad;\n      K -= 2.0*p*dot(K,p)/dot(p,p);\n      p *= sc;\n      \n      if (foam_cluster && length(p) > 1.0)\n      {\n        sc = 1.0 / dot(p,p);\n        scale *= sc;\n        K += p*scale/1.0;\n        K -= 2.0*p*dot(K,p)/dot(p,p);\n        p *= sc;\n        flip = !flip;\n      }\n      recurse = false;\n    }\n    #if defined FASTER\n    reflection(p, K, ns[0]);\n    reflection(p, K, ns[1]);\n    reflection(p, K, ns[2]);\n    reflection(p, K, ns[3]);\n    reflection(p, K, ns[4]);\n    reflection(p, K, ns[5]);\n    reflection(p, K, ns[6]);\n    reflection(p, K, ns[7]);\n    reflection(p, K, ns[8]);    \n    #else\n    for (int j = 0; j<9; j++)\n      reflection(p, K, ns[j]);\n    #endif\n\n    float dist = length(p - dir*l);\n    if (dist < r || i==Iterations-1)\n    {\n      p -= dir*l;\n      float sc = r*r / dot(p, p);\n      scale *= sc;\n      K += p*scale/(r*r);\n      K -= 2.0*p*dot(K,p)/dot(p,p);\n      p *= sc;\n      p += dir*l;\n\n      float m = minr*k;\n      if (length(p) < minr*(1.0+k)/2.0 && !void_foam)\n      {\n        p /= m;\n        scale /= m;\n        recurse = true;\n      }\n    }\n    if (void_foam && length(p) < R)\n    {\n      recurse = true;\n    }\n  }\n  if (void_foam)\n  {\n    float len = length(p);\n    float midlen = (1.0 + R*R)/2.0;\n    float width = (1.0 - R*R)/2.0;\n    return (abs(len - midlen)-width)/scale;\n  }\n\n// for some reason this more accurate distance estimate doesn't work as well\n// I think it just makes it look darker, which doesn't look as good\n//  float dist = distanceToSphere(p, K, scale, vec3(0.0, 0.0, 0.0), minr*0.9*min(1.0,k));\n\n  float dist = min(min_dist, (length(p) - minr*0.9*min(1.0,k))/scale);\n  if (flip)\n    dist = -dist; \n  return dist;\n}\n\n// renders most classes including trees, shells and cluster-like objects\nfloat treeCluster(vec3 p, int Iterations, float tree_connectivity, bool shell_tree, bool Cluster, bool Void, int Children, float j_scale, float k_scale) \n{   \n   int N = 2; // affects size of boundary between domes on trees\n   int childnums[5] = int[](4,6,8,12,20); // platonic solids\n   int num_children = childnums[Children-1];\n   \n   float bend_scales[5];\n   float bend_scale = 1.0;\n   if (N==2)\n     bend_scales = float[](0.72, 0.9, 0.642, 0.731, 1.342);\n   else if (N==3)\n     bend_scales = float[](0.54, 0.702, 0.462, 0.492, 0.956);\n   float bend_angle = tree_connectivity * bend_scales[Children-1];\n   \n   // Block below is for the tree sphere inversions\n   // TODO: how do I find these values procedurally?\n   float ratios_ico[5] = float[](1.238, 1.225, 1.162, 1.119, 1.092);   \n   float ratios_dod[5] = float[](2.0, 1.527, 1.288, 1.18, 1.129);\n   float ratios_cube[5] = float[](2.0, 1.438, 1.26, 1.177, 1.132);\n   float ratios_oct[5] = float[](1.41, 1.269, 1.189, 1.143, 1.113);\n   float ratios_tet[7] = float[](2.0, 1.51, 1.336, 1.240, 1.182, 1.145, 1.1);\n   float PackRatio = ratios_cube[N-1];\n   if (num_children == 6)\n     PackRatio = ratios_oct[N-1];\n   else if (num_children == 4)\n     PackRatio = ratios_tet[N-1];\n   else if (num_children == 12)\n     PackRatio = ratios_dod[N-1];\n   else if (num_children == 20)\n     PackRatio = ratios_ico[N-1];\n  \n  float r = PackRatio * length(corner - edge)/length(edge);\n  float L = sqrt(1.0 + r*r);\n  float Lscale = length(face)/length(corner);\n  float d = L * Lscale;\n  vec3 corner_dir = normalize(corner);\n  vec3 face_dir = normalize(face);\n\n  float R = sqrt(1.0 - d*d);\n  float omega = asin(R);\n  float bend_sign = 1.0;\n  if (shell_tree)\n    bend_sign = -1.0;\n \n  float scale = 1.0;\n  vec3 K = vec3(0.0, 0.0, 0.0);\n  \n\n  // Block below (and b suffix) is for the cluster sphere inversions\n  float Rb = 1.0 / (1.0 + length(corner)/length(corner - edge));  \n  float kb = k_scale; // 1 allows cluaters to meet in a sponge \n  float jb = j_scale; // <1 is separtion to a cluster\n  float rb = 1.0 - 2.0*Rb*kb;\n  Rb = (1.0 - rb)/2.0;\n  float Lb = 2.0*rb*Rb/(Rb-rb);\n  bool do_cluster = Cluster;\n  if (!do_cluster)\n  {\n    p *= 2.0;\n    scale *= 2.0;\n  }\n  bool leave_out_centre = Cluster && Void && k_scale == 1.0;\n   \n   for (int i = 0; i < Iterations; i++)\n   {\n     float Lx = L;\n     if (do_cluster)\n     {\n       Lx = Lb - rb;\n     }\n     d = Lx * Lscale;    \n\n     float phi = bend_angle + omega;\n     float e = R * tan(phi);\n     float D = d + e;\n     float s = sqrt(e*e + R*R);\n\n     #if defined FASTER\n     reflection(p, K, ns[0]);\n     reflection(p, K, ns[1]);\n     reflection(p, K, ns[2]);\n     reflection(p, K, ns[3]);\n     reflection(p, K, ns[4]);\n     reflection(p, K, ns[5]);\n     reflection(p, K, ns[6]);\n     reflection(p, K, ns[7]);\n     reflection(p, K, ns[8]);\n     reflection(p, K, ns[9]);\n     reflection(p, K, ns[10]);\n     reflection(p, K, ns[11]);\n     #else\n     for (int j = 0; j<12; j++)\n       reflection(p, K, ns[j]);\n     #endif\n    \n     vec3 dome_offset = D * face_dir;\n     vec3 corner_offset = Lx * corner_dir;\n\n     if (do_cluster) // inversion around the corners\n     {\n       p += corner_offset;\n       float mag = length(p);\n       if (leave_out_centre || (Lb > 0.0 && mag > Lb) || mag < -Lb)\n       {\n         float sc = Lb*Lb/dot(p,p);\n         scale = scale * sc;\n         K += p*scale/(Lb*Lb);\n         K -= 2.0*p*dot(K,p)/dot(p,p);\n         p *= sc;\n       }\n       else if (!Void)\n       {\n         do_cluster = false;\n       }\n       p -= corner_offset;\n       p /= rb*jb;\n       scale /= rb*jb;\n       if (!do_cluster)\n       {\n         p *= 2.0;\n         scale *= 2.0;\n       }\n     }\n     else\n     {\n       if (length(p - dome_offset) < s) // inversion of the face (making the dome)\n       {\n         // This block helps the distance estimate, the above condition is on the higher bend angle, but\n         // it recalculates here based on the potentially lower bend angle (bend_sign <= 1.0)\n         if (shell_tree || bend_mult != 1.0) \n         {\n           float phi = bend_angle*bend_sign + omega;\n           float e2 = R * tan(phi);\n           float D2 = d + e2;\n           s = sqrt(e2*e2 + R*R);\n           dome_offset = D2 * face_dir;\n         }\n         p -= dome_offset;\n         float sc = s*s/dot(p,p);\n         scale *= sc;\n         K += p*scale/(s*s);\n         K -= 2.0*p*dot(K,p)/dot(p,p);\n         p *= sc;\n         p += dome_offset;\n         if (!shell_tree)\n           bend_sign = bend_mult;\n       }\n       else if (length(p - corner_offset) < r)\n       {\n         p -= corner_offset;\n         float sc = r*r/dot(p,p);\n         scale *= sc;\n         K += p*scale/(r*r);\n         K -= 2.0*p*dot(K,p)/dot(p,p);\n         p *= sc;\n         p += corner_offset;\n         if (!shell_tree)\n           bend_sign = 1.0;\n       }\n       if (shell_tree)\n         bend_sign = -bend_sign; // TODO: we can't negate sign here, it depends on order of above conditions\n     }\n  }\n  return distanceToSphere(p, K, scale, vec3(0.0, 0.0, 0.0), 1.0);\n}\n\n// simple code for the non sphere-inversion shapes, i.e. the void-, cluster- and tree-shells\nfloat shells(vec3 p, int Iterations, int Children)\n{\n  float scale = 1.0;\n  p *= 3.0;\n  scale *= 3.0;\n  float min_dist = 100000.0;\n  for (int i = 0; i<Iterations; i++) \n  {\n    p.x = abs(p.x);\n    p.y = abs(p.y);\n    p.z = abs(p.z);\n    if (p.y > p.x)\n    {\n      float temp = p.x;\n      p.x = p.y;\n      p.y = temp;\n    }\n    if (p.z > p.x)\n    {\n      float temp = p.x;\n      p.x = p.z;\n      p.z = temp;\n    }    \n    vec3 q = vec3(1.0,0.0,0.0);\n    if (Children >= 3 || mat_struct==3)\n      q = vec3(1.0,1.0,1.0);\n    vec3 p1 = p - q;\n    vec3 p2 = p - vec3(1.0,0.0,1.0); \n    vec3 p3 = p - vec3(1.0,1.0,0.0); \n    vec3 p4 = p; \n    if (mat_struct==3)\n    {\n      if (p.x <= 1.5)\n        return (p.x - 1.5) / scale;\n      p4 = p - vec3(2.0,0.0,0.0);\n    }\n\n\n    float d1 = dot(p1,p1);\n    float d2 = dot(p2,p2);\n    float d3 = dot(p3,p3);\n    float d4 = dot(p4,p4);\n    if (d1 < d2 && d1 < d3 && d1 < d4)\n      p = p1;\n    else if (d2 < d1 && d2 < d3 && d2 < d4)\n      p = p2;\n    else if (d3 < d1 && d3 < d2 && d3 < d4)\n      p = p3;\n    else if (mat_struct >= 2)\n    {\n      p = p4;\n      if (mat_struct == 2)\n      {\n        p *= 3.0;\n        scale *= 3.0;\n        break;\n      }\n    }\n    p *= 3.0;\n    scale *= 3.0;\n  }\n  return min(min_dist, (max(abs(p.x), max(abs(p.y), abs(p.z))) - 1.5)/scale);\n}\n\n// this is the distance estimate function, mysteriously named f\nvec3 f(vec3 p)\n{ \n   ry(p, iTime*0.3);\n   float dist = 0.0f;\n   // we have earlier set the general type of shape, and the parameters to fix a single style for that type\n   if (run_sphere_tree)\n     dist = sphereTree(p, Iterations, connectivity, Children > 2); \n   else if (run_tree_cluster)\n     dist = treeCluster(p, Iterations, tree_connectivity, shell_tree, is_cluster, is_void, Children, j_scale, k_scale);\n   else if (run_sphere_cluster)\n     dist = sphereCluster(p, Iterations, connectivity, Children, void_foam, foam_cluster, cluster_foam);\n   else if (run_void_shell)\n     dist = shells(p, Iterations, Children);\n\n   if (invert)\n   {\n     float w = 2.0;\n     // we are looking at this internally, so add cubic walls\n     dist = min(dist,  w + dot(p, vec3(1.0, 0.0, 0.0)));\n     dist = min(dist,  w + dot(p, vec3(0.0, 1.0, 0.0)));\n     dist = min(dist,  w + dot(p, vec3(0.0, 0.0, 1.0)));\n     dist = min(dist,  w + dot(p, vec3(-1.0, 0.0, 0.0)));\n     dist = min(dist,  w + dot(p, vec3(0.0, -1.0, 0.0)));\n     dist = min(dist,  w + dot(p, vec3(0.0, 0.0, -1.0)));\n   }\n   \n   return vec3(dist,0,0); \n} \n\n// a nasty but nessessary merging of the soft shadow and the normal calculation\n// in order to only use a single call of f() in the code.\n// why? because functions are inlined in glsl, so too many separate calls makes compilation really slow\n float softshadow_andnormal(vec3 pos, vec3 rd, float k, inout vec3 n )\n { \n    n = vec3(0.0);\n    float akuma=1.0,h=0.0; \n    float t = 0.01;\n   \n    for( int i=0; i<14; i++ )\n    {\n      vec3 e;\n      vec3 point;\n      if (i < 4)\n      {\n        e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        point = pos + 0.001*e;\n      }\n      else  \n      {\n        point = pos + rd*t;\n      }\n      float dist = f(point).x;\n      if (i < 4)\n      {\n        n += e*dist;\n      }\n      else\n      {\n         if(dist<0.001)\n           return 0.02; \n         akuma = min(akuma, k*dist/t); \n \t\t t += clamp(dist,0.01,2.0); \n      }\n    }\n    n = normalize(n);\n    return akuma; \n } \n\n\n// calculate intersection of ray with the geometry\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 14.0;\n    \n    float t = tmin;\n    vec3 res = vec3(-1.0);\n    for( int i=0; i<100; i++ )\n    {\n        vec3 h = f(ro + rd*t);\n\t\tif( h.x<0.002 || t>tmax ) \n          break;\n        res = vec3(t,0.0,0.0);\n        t += h.x * 0.4;\n    }\n\tif( t>tmax ) \n      res=vec3(-1.0);\n    return res;\n}\n\n// called once per ray at the start\nvoid setupGlobals()\n{\n   // set up the class based on the mouse location\n   float mat = 1.0 + 5.999 * iMouse.x / iResolution.x;  \n   MaterialStructure = int(mat);\n   float con = 2.0 + 4.999 * (1.0 - iMouse.y / iResolution.y);\n   ConnectiveStructure = int(con);\n   connectivity = sqrt(con - float(ConnectiveStructure));\n   tree_connectivity = sqrt(con - float(ConnectiveStructure));\n   Children = 1 + int(5.0 * (mat - float(MaterialStructure)));     \n   \n   mat_struct = MaterialStructure;\n   con_struct = ConnectiveStructure;\n   invert = mat_struct + con_struct > 8 && \n          !(mat_struct == 5 && con_struct == 5) &&\n          !(mat_struct == 4 && con_struct == 5);   // special cases\n   if (invert)\n   {\n     mat_struct = 8 - con_struct;\n     con_struct = 8 - MaterialStructure;\n   }\n   \n   // So there are 49 of these in total, but we leave out the top and bottom rows (voids and solids)\n   // and the solid- final column, leaving 30 classes:\n   if (mat_struct == 1 && con_struct == 1) // void-void\n     run_tree_cluster = false; \n   else if (mat_struct == 1 && con_struct == 2) // void-cluster\n   {\n     is_cluster = true;\n     is_void = true;\n     j_scale = connectivity;\n     k_scale = connectivity;\n   }\n   else if (mat_struct == 1 && con_struct == 3) // void-tree\n   {\n     is_cluster = true;\n     is_void = true;\n     k_scale = connectivity;     \n   }\n   else if (mat_struct == 1 && con_struct == 4) // void-sponge\n   {\n     is_cluster = true;\n     is_void = true;\n   }\n   else if (mat_struct == 1 && con_struct == 5) // void-shell - would like to find a sphere-inversion example here\n   {\n     run_tree_cluster = false;\n     run_void_shell = true;\n   }\n   else if (mat_struct == 1 && con_struct == 6) // void-foam\n   {\n     run_tree_cluster = false;\n     run_sphere_cluster = true;\n     void_foam = true;\n     Children = max(Children, 4); // doesn't currently work on lower number\n   } \n\n   else if (mat_struct == 2 && con_struct == 2) // cluster-cluster\n   {\n     run_tree_cluster = false;\n     run_sphere_cluster = true;\n   }\n   else if (mat_struct == 2 && con_struct == 3) // cluster-tree\n   {\n     run_tree_cluster = false;\n     run_sphere_tree = true;\n   }\n   else if (mat_struct == 2 && con_struct == 4) // cluster-sponge\n   {\n     run_tree_cluster = false;\n     run_sphere_cluster = true;\n     connectivity = 1.0;\n   }\n   else if (mat_struct == 2 && con_struct == 5) // cluster-shell - would like to find a sphere-inversion example\n   {\n     run_tree_cluster = false;\n     run_void_shell = true;\n   }\n   else if (mat_struct == 2 && con_struct == 6) // cluster-foam\n   {\n     run_tree_cluster = false;\n     run_sphere_cluster = true;\n     void_foam = true;\n     cluster_foam = true;\n   }\n\n   else if (mat_struct == 3 && con_struct == 2) // tree-cluster\n   {\n     is_cluster = true;\n     j_scale = connectivity;\n     k_scale = connectivity;\n   }\n   else if (mat_struct == 3 && con_struct == 3) // tree-tree\n   {\n   }\n   else if (mat_struct == 3 && con_struct == 4) // tree-sponge\n   {\n     tree_connectivity = 1.0;\n   }\n   else if (mat_struct == 3 && con_struct == 5) // tree-shell - would like to find a sphere-inversion example\n   {\n     run_tree_cluster = false;\n     run_void_shell = true;\n   }\n   else if (mat_struct == 4 && con_struct == 2) // sponge-cluster\n   {\n     is_cluster = true;\n     tree_connectivity = 1.0 + 0.24*tree_connectivity;\n     j_scale = connectivity;\n     k_scale = connectivity;\n   }\n   else if (mat_struct == 4 && con_struct == 3) // sponge-tree  (not a super-clear example, must be something better out there)\n   {\n     float connectivities[] = float[](1.11, 1.1, 1.125, 1.125, 1.04);\n     tree_connectivity = connectivities[Children-1];\n     bend_mult = 0.85;\n   }\n   else if (mat_struct == 4 && con_struct == 4) // sponge-sponge\n   {\n     tree_connectivity = 1.0 + 0.24*tree_connectivity;\n   }\n   else if (mat_struct == 4 && con_struct == 5) // sponge-shell\n   {\n     tree_connectivity = -1.0;\n   }\n\n   else if (mat_struct == 5 && con_struct == 2) // shell-cluster\n   {\n     is_cluster = true;\n     tree_connectivity *= -1.0;\n     j_scale = connectivity;\n     k_scale = connectivity;\n   }\n   else if (mat_struct == 5 && con_struct == 3) // shell-tree\n   {\n     shell_tree = true;\n     tree_connectivity *= -0.5;\n   }\n   else if (mat_struct == 5 && con_struct == 5) // shell-shell\n   {\n     tree_connectivity *= -1.0;\n   }\n \n   else if (mat_struct == 6 && con_struct == 2) // foam-cluster\n   {\n     run_tree_cluster = false;\n     run_sphere_cluster = true;\n     foam_cluster = true;\n   }\n   else\n   {\n     run_tree_cluster = false;\n   }\n   \n   int childnums[5] = int[](4,6,8,12,20); // platonic solids\n   setCoxeterPlanes(childnums[Children-1]);\n}\n\n// this is just text for naming the classes\nint tvoid[8]    = int[](22,15,9,4,0,0,0,0); \nint tcluster[8] = int[](3,12,21,19,20,5,18,0); \nint ttree[8]    = int[](20,18,5,5,0,0,0,0); \nint tsponge[8]  = int[](19,16,15,14,7,5,0,0); \nint tshell[8]   = int[](19,8,5,12,12,0,0,0); \nint tfoam[8]    = int[](6,15,1,13,0,0,0,0); \nint tsolid[8]   = int[](19,15,12,9,4,0,0,0); \n\n// draw a character on the screen\nfloat char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return 0.0;\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                        dFdx, dFdy ).x;\n}\n\n// draw text on the screen\nfloat text(inout vec2 p, int string[8], int add)\n{\n  float shade = 0.0;\n  int i = 0;\n  while (string[i] > 0)\n  {\n    shade += char(p, 64+32+string[i]);\n    i++;\n    p.x -= 0.4;\n  }\n  if (add>0)\n  {\n    shade += char(p, add);\n    p.x -= 0.4;\n  }\n  return shade;\n}\n\n// print the fractal class\nfloat printClass(vec2 p, int mat, int con)\n{\n  float shade = 0.0;\n  int cls[2] = int[](mat, con);\n  for (int i = 0; i<2; i++)\n  {\n    int clss = cls[i];\n    int string[8];\n    if (clss == 1)\n      string = tvoid;\n    else if (clss == 2)\n      string = tcluster;\n    else if (clss == 3)\n      string = ttree;\n    else if (clss == 4)\n      string = tsponge;\n    else if (clss == 5)\n      string = tshell;\n    else if (clss == 6)\n      string = tfoam;\n    int add= 0;\n    if (i==0)\n      add = 45; // dash\n    shade += text(p, string, add);\n  }\n  return shade;\n}\n\n// called once per pixel\n void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n { \n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y; \n\n   setupGlobals();\n   vec2 text_pos = (uv + vec2(0.7,1.0))*4.0;\n   float txt = printClass(text_pos, MaterialStructure, ConnectiveStructure);\n   bool render_overlays = true;\n   // render the grid\n   if (render_overlays)\n   {\n     float mat = 1.0 + 5.9999 * fragCoord.x / iResolution.x;  \n     float con = 2.0 + 4.9999 * (1.0 - fragCoord.y / iResolution.y);\n     float w = 0.01;\n     float modx = mod(mat, 1.0);\n     float mody = mod(con, 1.0);\n     if (modx <= w || modx >= (1.0-w) || mody <= w || mody >= (1.0-w))\n     {\n       vec4 red = vec4(0.7, 0.1, 0.1, 0.0);\n       vec4 blue = vec4(0.1, 0.1, 0.7, 0.0);\n       if (int(mat) == MaterialStructure && int(con) == ConnectiveStructure)\n         fragColor = vec4(1.0, 1.0, 1.0, 0.0);\n       else if ((int(mat)-int(con)) == 0)\n         fragColor = red;\n       else if (int(mat-w)==1 || int(mat+w)==1)\n         fragColor = blue;\n       else if ((int(mat+w) - int(con+w) == 0) || (int(mat+w) - int(con-w) == 0) || \n           (int(mat-w) - int(con+w) == 0) || (int(mat-w) - int(con-w) == 0))\n         fragColor = red;\n       else\n         fragColor = vec4(0.25, 0.25, 0.25, 0.0);\n         \n       fragColor.x = max(fragColor.x, txt);\n       fragColor.y = max(fragColor.y, txt);\n       fragColor.z = max(fragColor.z, txt);     \n       return;\n     }\n   }\n \n     \n\t// camera\n \tstime=0.7+0.3*sin(iTime*0.4); \n \tctime=0.7+0.3*cos(iTime*0.4); \n\n \tvec3 ta=vec3(0.0,0.0,0.0); \n\tvec3 ro = vec3(0.0, 3.*stime*ctime, 3.*(1.-stime*ctime));\n\n \tvec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n \tvec3 rd = normalize(uv.x*cs + uv.y*cu + 3.0*cf);  // transform from view to world\n\n    vec3 sundir = normalize(vec3(0.3, 0.8, 0.6)); \n    vec3 sun = vec3(1.64, 1.27, 0.99); \n    vec3 skycolor = vec3(0.6, 1.5, 1.0); \n\n\tvec3 bg = exp(uv.y-2.0)*vec3(0.4, 1.6, 1.2);\n\n    float halo=clamp(dot(normalize(vec3(-ro.x, -ro.y, -ro.z)), rd), 0.0, 1.0); \n    vec3 col=bg+vec3(1.0,0.8,0.4)*pow(halo,17.0); \n\n\n    float t=0.0;\n    vec3 p=ro; \n    \n    // find the intersection (the important bit)\n\tvec3 res = intersect(ro, rd);\n    \n    // some lighting\n\tif(res.x > 0.0)\n    {\n       p = ro + res.x * rd;\n       float clarity = 1.0;\n       if (invert)\n       {\n         clarity = exp(-0.1*res.x); \n       }\n       invert = false;\n       vec3 n;\n       float shadow = softshadow_andnormal(p, sundir, 4.0, n);\n\n       float dif = max(0.0, dot(n, sundir)); \n       float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n       float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n       float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n       vec3 lin = 4.5 * sun * dif * shadow; \n       lin += 0.8 * bac * sun; \n       lin += 0.6 * sky * skycolor*shadow; \n       lin += 3.0 * spe * shadow; \n\n       res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n       vec3 tc0 = 0.5 + 0.5 * sin(3.0 + 4.2 * res.y + vec3(0.0, 0.5, 1.0));\n       col = lin *vec3(0.9, 0.8, 0.6) *  0.2 * tc0;\n       col=mix(col,bg, 1.0-exp(-0.001*res.x*res.x)); \n       \n       col = mix(vec3(1.0, 0.7, 0.4), col, clarity);\n    } \n\n    // post-effects\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // saturation\n    col*=0.5+0.5*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n \tfragColor = vec4(col.xyz, smoothstep(0.55, .76, 1.-res.x/5.)); \n\n    if (render_overlays)\n    {  \n      fragColor.x = max(fragColor.x, txt);\n      fragColor.y = max(fragColor.y, txt);\n      fragColor.z = max(fragColor.z, txt);    \n    }\n }\n \n// special-case for the sphere-tree class\nfloat sphereTree(vec3 p, int Iterations, float PackRatio, bool Rotated)\n{    \n float root3 = sqrt(3.0);\n vec3 t0 = vec3(0.0,1.0,0.0);\n vec3 t1 = vec3(root3/2.0, -0.5,0.0);\n vec3 t2 = vec3(-root3/2.0, -0.5,0.0);\n vec3 n0 = vec3(1.0,0.0,0.0);\n vec3 n1 = vec3(-0.5, -root3/2.0,0.0);\n vec3 n2 = vec3(-0.5, root3/2.0,0.0);\n\n float scale = 1.0;\n float k = PackRatio;\n\n float scl = Rotated ? root3 : 1.0;\n float innerScale = k*scl/(k*k + scl);\n float innerScaleB = innerScale*innerScale*0.25;\n float shift = (k*k + scl)/(k*(1.0 + scl));\n float mid = 0.5*(k+1.0)/2.0;\n float bufferRad = 0.6*k;\n vec3 K = vec3(0.0,0.0,0.0);\n \n // orient the shape nicely\n float tmp = p.z;\n p.z = p.y;\n p.y = tmp;\n p.z += 0.85*k;\n p /= 2.0;\n scale /= 2.0;\n\n for (int i = 0; i < Iterations; i++)\n {\n    vec3 pB = p-vec3(0,0,innerScale*0.5);\n    if (dot(pB, pB) < innerScaleB)\n      break; // definitely inside\n    float maxH = 0.4;\n    if (i==0)\n      maxH = -100.0;\n    vec3 pC = p-vec3(0,0,bufferRad);\n    if (p.z > maxH && dot(pC, pC) > bufferRad*bufferRad)\n      break; // definitely outside\n    vec3 pD = p-vec3(0,0,mid);\n    float sc = dot(p,p);\n    if (p.z < maxH && dot(pD, pD) > mid*mid)\n    {\n      // needs a sphere inverse\n      scale /= sc;       \n      K += p*scale/1.0;\n      K -= 2.0*p*dot(K,p)/dot(p,p);\n      p /= sc; \n    }\n    else \n    {\n      // stretch onto a plane at zero \n      scale /= sc;\n      K += p*scale/1.0;\n      K -= 2.0*p*dot(K,p)/dot(p,p);\n      p /= sc;\n      p.z -= shift;\n      p.z *= -1.0;\n      K.z *= -1.0;\n      p *= scl;\n      scale *= scl;\n      p.z += shift;\n      if (Rotated)\n      {\n        // and rotate it a twelfth of a revolution\n        float a = pi/6.0;\n        float cosA = cos(a);\n        float sinA = sin(a);\n        float xx = p.x*cosA + p.y*sinA;\n        float yy = -p.x*sinA + p.y*cosA;\n        p.x = xx; \n        p.y = yy;\n        \n        float kx = K.x*cosA + K.y*sinA;\n        float ky = -K.x*sinA + K.y*cosA;\n        K.x = kx;\n        K.y = ky;\n      }\n    }\n    // now modolu the space so we move to being in just the central hexagon, inner radius 0.5\n    float h = p.z;\n    float kz = K.z;\n    float x = dot(p, -n2) * 2.0/root3;\n    float y = dot(p, -n1) * 2.0/root3;  \n    float kx = dot(K, -n2);\n    float ky = dot(K, -n1);\n    x = mod(x, 1.0);\n    y = mod(y, 1.0);\n    if (x + y > 1.0)\n    {\n      x = 1.0-x;\n      y = 1.0-y;\n      kx = -kx;\n      ky = -ky;\n    }\n    p = x*t1 - y*t2;\n    K = kx*t1 - ky*t2;\n\n    // fold the space to be in a kite\n    float l0 = dot(p,p);\n    float l1 = dot(p-t1, p-t1);\n    float l2 = dot(p+t2,p+t2);\n    if (l1 < l0 && l1 < l2)\n    {\n      p -= t1 * (2.0*dot(t1, p) - 1.0);\n      K -= t1 * 2.0*dot(t1, K);\n    }\n    else if (l2 < l0 && l2 < l1)\n    {\n      p -= t2 * (2.0 * dot(p, t2) + 1.0);\n      K -= t2 * 2.0*dot(t2, K);\n    }\n    p.z = h;\n    K.z = kz;\n  }\t\n  return distanceToSphere(p, K, scale, vec3(0.0,0.0,0.5*k), 0.5*k);\n}\n","name":"Image","description":"","type":"image"}]}