{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":" \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n};\n\nstruct Plan{\n   vec3 ori;\n   vec3 ab;\n   vec3 ord;\n};\n\nconst int NUM_LIGHTS = 3;\nconst int NUM_SPHERES = 2;\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n    Camera C;\n    C.Obs = Obs;\n    C.View = normalize(LookAt - Obs);\n    C.Horiz = normalize(cross(vec3(0, 0, 1), C.View));\n    C.Up = normalize(cross(C.View, C.Horiz));\n    C.H = iResolution.y;\n    C.W = iResolution.x;\n    C.z = C.H/2.0/tan(aperture * 3.1415 / 180.0 /2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   Ray r;\n   r.Origin = C.Obs;\n   r.Dir = C.z*C.View + (XY.x - C.W/2.0)*C.Horiz + (XY.y - C.H/2.0)*C.Up;\n   return r;\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    float a = dot(R.Dir,R.Dir);\n    float b = 2.0*dot(R.Dir,(R.Origin - S.Center));\n    float c = dot(R.Origin - S.Center, R.Origin - S.Center) - S.R*S.R;\n    float delta = b*b - 4.0*a*c;   \n    if (delta > 0.0) {\n        t = (-b - sqrt(delta)) / (2.0*a);\n    }\n    return delta > 0.0;\n}\n\n \n \nvec3 getcolor(vec3 color, Sphere S, float t, Light L[NUM_LIGHTS], Ray R){\n    vec3 inter = R.Origin+R.Dir*t;\n    vec3 normal = inter-S.Center;\n    vec3 finalColor = vec3(0.,0.,0.);\n    \n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        vec3 lightDir = normalize(L[i].pos - inter); \n        float angle = max(dot(normal, lightDir)/(length(normal)*length(lightDir)), 0.0);\n        finalColor += color * L[i].color * angle; \n    }\n    \n    \n    return finalColor;\n}\n\nbool interplan(in Ray R,out float t){\n    t = -1.0*R.Origin.z/R.Dir.z;\n    return t>0.0;\n}\n\nbool isInShadowFromLight(Sphere s, Light L, vec3 inter) {\n    vec3 lightDirection = L.pos - inter;\n\n    // Shadow ray starting at the intersection point and pointing toward the light\n    Ray shadowRay;\n    shadowRay.Origin = inter + lightDirection * 1e-4; // Offset to avoid self-intersection\n    shadowRay.Dir = lightDirection; // Ensure the direction is normalized\n\n    float t;\n    // Check if the shadow ray intersects the sphere between the intersection and the light\n    return intersect_sphere(shadowRay, s, t) && (t > 0.0 && t < 1.0);\n}\n\nvec3 planshadow(vec3 color, float t, vec3 normal, Light L[NUM_LIGHTS], Ray R, Sphere S[NUM_SPHERES]) {\n    vec3 inter = R.Origin + R.Dir * t; // Intersection point\n    vec3 finalColor = vec3(0.0, 0.0, 0.0); // Accumulated light color\n\n    for (int i = 0; i < NUM_LIGHTS; i++) {\n        bool show = true;\n\n        // Check if the light is blocked by any sphere\n        for (int j = 0; j < NUM_SPHERES; j++) {\n            if (isInShadowFromLight(S[j], L[i], inter)) {\n                show = false;\n                break; // No need to check other spheres\n            }\n        }\n\n        if (show) {\n            // Calculate light contribution\n            vec3 lightDir = normalize(L[i].pos - inter); \n            float angle = max(dot(normal, lightDir), 0.0);\n            finalColor += color * L[i].color * angle; // Add light's contribution\n        }\n    }\n\n    return finalColor; // Return the final color\n}\n\n\nbool intersect_plan(Ray R, Plan P, out float t, out vec2 uv) {\n    // Compute the normal of the plane\n    vec3 normal = normalize(cross(P.ab, P.ord)); // Plane normal from two vectors on the plane\n\n    // Compute the denominator for the ray-plane intersection\n    float denom = dot(R.Dir, normal);\n    \n    // If the denominator is close to 0, the ray is parallel to the plane\n    if (abs(denom) < 1e-6) {\n        t = -1.0; // No intersection\n        return false;\n    }\n\n    // Compute the intersection distance t\n    vec3 originToPlane = P.ori - R.Origin;\n    t = dot(originToPlane, normal) / denom;\n\n    // Check if the intersection is in the forward direction of the ray\n    if (t <= 0.0) {\n        return false; // Intersection is behind the ray origin\n    }\n\n    // Compute the intersection point in world coordinates\n    vec3 intersectionPoint = R.Origin + R.Dir * t;\n\n    // Transform the intersection point to the plane's referential\n    vec3 planeOffset = intersectionPoint - P.ori; // Offset from plane origin\n    uv.x = dot(planeOffset, normalize(P.ab));     // Projection onto P.ab\n    uv.y = dot(planeOffset, normalize(P.ord));    // Projection onto P.ord\n\n    return true; // Intersection exists\n}\n\n\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Initialize the camera\n    Camera C = camera(\n        vec3(0.0, 6.0, 8.0),\n        vec3(0.0, 0.0, 0.0),\n        70.0\n    );\n\n    // Define lights\n    Light lights[NUM_LIGHTS];\n    lights[0] = Light(vec3(0.0, 0.0, 6.0), vec3(1.0, 0.0, 0.0));\n    lights[1] = Light(4.0*vec3(sin(iTime), 4.0*cos(iTime), 2.0), vec3(0., 1.0, 0.0));\n    lights[2] = Light(vec3(0., 4., 4.), vec3(0., 0., 1.0));\n\n    vec3 col = vec3(0.0, 0.3, 0.8); // Default background color\n\n    // Initialize the ray\n    Ray r = launch(C, fragCoord);\n\n    // Define the spheres\n    Sphere spheres[NUM_SPHERES];\n    spheres[0] = Sphere(vec3(0.0, 0.0, 2.0), 0.5);\n    spheres[1] = Sphere(spheres[0].Center + vec3(cos(iTime), sin(iTime) , 0.), 0.2);\n    \n    float tClosest = 1e10; // Start with a large number for the closest intersection\n    vec3 closestColor = col; // Start with the background color\n\n    // Intersection variables\n    float t1, t2;\n    bool b1 = intersect_sphere(r, spheres[0], t1);\n    bool b2 = intersect_sphere(r, spheres[1], t2);\n\n    // Test intersection with the first sphere\n    if (b1 && t1 > 0.0 && t1 < tClosest) {\n        tClosest = t1;\n        closestColor = getcolor(vec3(1.0, 1.0, 1.0), spheres[0], t1, lights, r);\n    }\n\n    // Test intersection with the second sphere\n    if (b2 && t2 > 0.0 && t2 < tClosest) {\n        tClosest = t2;\n        closestColor = getcolor(vec3(1.0, 1.0, 1.0), spheres[1], t2, lights, r);\n    }\n\n    // Test intersection with the plane z=0\n    float tplan;\n    if (interplan(r, tplan) && tplan > 0.0 && tplan < tClosest) {\n        vec3 intersectionPoint = r.Origin + r.Dir * tplan;\n        if (mod(intersectionPoint.x,2.0)<1.0 || mod(intersectionPoint.y, 2.0) < 1.0){\n            if (mod(intersectionPoint.x,2.0)<1.0 && mod(intersectionPoint.y, 2.0) < 1.0){\n               closestColor = planshadow(vec3(0.0, 0.0, 0.0), tplan, vec3(0.,0.,1.), lights, r, spheres);\n            }else{\n        closestColor = planshadow(vec3(1.0, 1.0, 1.0), tplan, vec3(0.,0.,1.), lights, r, spheres);\n        }\n        } else{\n        closestColor = planshadow(vec3(0.0, 0.0, 0.0), tplan, vec3(0.,0.,1.), lights, r, spheres);\n\n        }\n\n        tClosest = tplan; // Update the closest intersection\n    }\n    \n    float tplan2;\n    Plan plan2 = Plan(vec3(0.,0.,2.),vec3(0.,-1.,1.),vec3(1.,0.,0.));\n    vec2 uv;\n    if (intersect_plan(r,plan2, tplan2,uv) && tplan2 > 0.0 && tplan2 < tClosest) {\n        vec3 intersectionPoint = r.Origin + r.Dir * tplan2;\n        if (uv.x<2. && uv.x >-2. && uv.y < 2. && uv.y>-2.){\n            if (mod(uv.x,2.0)<1.0 || mod(uv.y, 2.0) < 1.0){\n                if (mod(uv.x,2.0)<1.0 && mod(uv.y, 2.0) < 1.0){\n                   closestColor = planshadow(vec3(0.0, 0.0, 0.0), tplan,normalize(cross(plan2.ab, plan2.ord)), lights, r, spheres);\n                }else{\n                    closestColor = planshadow(vec3(1.0, 1.0, 1.0), tplan,normalize(cross(plan2.ab, plan2.ord)), lights, r, spheres);\n                }\n            } else{\n                closestColor = planshadow(vec3(0.0, 0.0, 0.0), tplan,normalize(cross(plan2.ab, plan2.ord)), lights, r, spheres);\n\n            }\n\n            tClosest = tplan2; // Update the closest intersection\n        }\n    }\n\n    // Output the final color\n    fragColor = vec4(closestColor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XfyBDV","date":"1734446210","viewed":21,"name":"color bubble 2","username":"Junper","description":"bubblegum ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["lancderayon"],"hasliked":0,"parentid":"tsGBDR","parentname":"Correction tp2"}}