{"ver":"0.1","info":{"id":"McKczc","date":"1732215491","viewed":94,"name":"Raymarching 1 - DJ","username":"DjBlueBear","description":"Why do the frames drop if all the objects don't have the same SDF, even when they are off the screen. (I think it's related to lighting)\nHow do I do the math to determine ray direction given camera rotation and position.","likes":2,"published":3,"flags":32,"usePreview":0,"tags":["rendering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 buffer0 = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    \n    fragColor = buffer0;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nconst float Deg2Rad = PI / 180.0;\n\nconst float root2 = sqrt(2.0);\n\n\n\nstruct Material {\n    vec3 color;\n};\n\nstruct Object {\n    vec3 position;\n    uint shape;\n    vec4 size;\n    Material material;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n    float brightness;\n};\n\nuint hash(inout uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\n\nfloat rand(inout uint seed)\n{\n    return fract(float(hash(seed))/ 4294967296.0);//4294967296 2 ^ 32 / 32 bit unsigned integer limit\n}\n\nfloat randNorm(inout uint seed)\n{   \n    float theta = 2.0 * rand(seed) * PI;\n    float rho = sqrt( -2.0 * log(rand(seed)));\n    return rho * cos(theta);\n}\n\nvec3 randVec3(inout uint seed)\n{\n    float rand0 = rand(seed);\n    float rand1 = rand(seed);\n    float rand2 = rand(seed);\n\n    return vec3(rand0, rand1, rand2);\n}\n\nvec3 randVec3Norm(inout uint seed)\n{\n    float rand0 = randNorm(seed);\n    float rand1 = randNorm(seed);\n    float rand2 = randNorm(seed);\n\n    return normalize(vec3(rand0, rand1, rand2));\n}\n\nvec3 randAlongAxis(in vec3 axis, inout uint seed)\n{\n    vec3 value = randVec3Norm(seed);\n\n    value *= sign(dot(axis, value));\n\n    return value;\n}\n\nfloat sdSphere(in vec3 p, in vec3 c, in float r)\n{\n    vec3 q = p - c;\n    return length(q) - r;\n}\n\nfloat sdBox(in vec3 p, in vec3 c,in vec3 b )\n{\n  vec3 q = abs(p - c) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus(in vec3 p, in vec3 c, in vec2 t )\n{\n  p -= c;\n\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opXor(float d1, float d2 )\n{\n    return max(min(d1,d2),-max(d1,d2));\n}\n\n\nvec3 opRepetition( in vec3 p, in vec3 s)\n{\n    vec3 q = p - s*round(p/s);\n    return q;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dX3Rr","filepath":"/media/a//media/previz/cubemap00.png","previewfilepath":"/media/ap//media/previz/cubemap00.png","type":"cubemap","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const Material defaultMaterial = Material(vec3(0.9,0.9,0.9));\nconst Material red = Material(vec3(1.0,0.5,0.5));\nconst Material green = Material(vec3(0.5,1.0,0.5));\nconst Material blue = Material(vec3(0.5,0.5,1.0));\n\nconst Object[4] objectList = Object[](\n    Object(vec3(0.0,1.0,0.0), 2u, vec4(3.0,0.0,0.0,0.0), defaultMaterial),\n    Object(vec3(6.0,-1.0,2.0), 0u, vec4(2.0,1.0,1.0,0.0), defaultMaterial),\n    Object(vec3(-3.0,-2.0,1.0), 1u, vec4(1.0,1.0,1.0,1.0), red),\n    Object(vec3(1.0,2.0,0.0), 1u, vec4(1.0,5.0,1.0,1.0), blue)\n);\n\nconst Light[1] lightList = Light[](\n    Light(vec3(2.5,-1.0,0.5), vec3(0.0,0.0,1.0), 20.0)\n    //Light(vec3(70.7,100.0,-70.7), vec3(1.0,0.0,0.0), 20000.0),\n    //Light(vec3(-70.7,100.0,-70.7), vec3(0.0,1.0,0.0), 20000.0)/*,\n    //Light(vec3(0.0,0.0,0.0), vec3(1.0,1.0,1.0), 8.0)/*,\n    //Light(vec3(-8.0,-5.0,1.0), vec3(0.0,0.0,1.0), 32.0),\n    //Light(vec3(4.0,-2.0,-1.0), vec3(0.0,1.0,1.0), 8.0)*/\n);\n\nconst vec3 shadowColor = vec3(0.1,0.1,0.2) * 0.0;\n\nconst float RAYMARCH_MAX_DISTANCE = 1000.0;\nconst float RAYMARCH_MIN_DISTANCE = 0.01;\nconst int RAYMARCH_MAX_ITERATIONS = 256;\n\nconst float BOUNDING_SPHERE_MIN_DIST = 1.0;\n\nfloat mapObject(vec3 point, Object obj)\n{\n    switch(obj.shape)\n    {\n        case 0u:\n        {\n            return sdSphere(point, obj.position, obj.size.x);\n        }\n        case 1u:\n        {\n            float boundingSphere = sdSphere(point, obj.position, max(max(obj.size.x,obj.size.y),obj.size.z) * 2.0);\n            //since the SDF of a sphere is much cheaper than that of a box or other shape\n            //instead of calculating the SDF of the original object it calculates the SDF of the sphere\n            //that contains that object when the ray is far enough away\n            if(boundingSphere < BOUNDING_SPHERE_MIN_DIST)\n            {\n                return sdBox(point, obj.position, obj.size.xyz);\n            }\n            else\n            {\n                return boundingSphere;\n            }\n            break;\n        }\n        case 2u:\n        {\n            return sdPlane(point, obj.position, obj.size.x);\n        }\n        case 3u:\n        {\n            float boundingSphere = sdSphere(point, obj.position, obj.size.x + obj.size.y);\n            \n            if(boundingSphere < BOUNDING_SPHERE_MIN_DIST)\n            {\n                return sdTorus(point, obj.position, obj.size.xy);\n            }\n            else\n            {\n                return boundingSphere;\n            }\n        }\n        case 4u:\n        {\n            float boundingSphere = sdSphere(point, obj.position, obj.size.x);\n            \n            if(boundingSphere < BOUNDING_SPHERE_MIN_DIST)\n            {\n                return sdOctahedron(point - obj.position, obj.size.x);\n            }\n            else\n            {\n                return boundingSphere;\n            }\n        }\n    }\n    \n    return RAYMARCH_MAX_DISTANCE;\n}\n\nfloat mapWorld(in vec3 point)\n{\n    float minDist = RAYMARCH_MAX_DISTANCE;\n    \n    for(int i=0; i<objectList.length(); i++)\n    {\n        float objDist = mapObject(point, objectList[i]);\n        \n        if(objDist < minDist)\n        {\n            minDist = objDist;\n            \n            if(objDist < RAYMARCH_MIN_DISTANCE)\n            {\n                break;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nfloat mapWorld(in vec3 point, out Object obj)\n{\n    float minDist = RAYMARCH_MAX_DISTANCE;\n    \n    for(int i=0; i<objectList.length(); i++)\n    {\n        float objDist = mapObject(point, objectList[i]);\n        \n        if(objDist < minDist)\n        {\n            minDist = objDist;\n            obj = objectList[i];\n            \n            if(objDist < RAYMARCH_MIN_DISTANCE)\n            {\n                break;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nfloat mapWorldExclude(in vec3 point, in Object obj)\n{\n    float minDist = RAYMARCH_MAX_DISTANCE;\n    \n    for(int i=0; i<objectList.length(); i++)\n    {\n        if(objectList[i] == obj)\n        {\n            continue;\n        }\n        \n        float objDist = mapObject(point, objectList[i]);\n        \n        if(objDist < minDist)\n        {\n            minDist = objDist;\n            \n            if(objDist < RAYMARCH_MIN_DISTANCE)\n            {\n                break;\n            }\n        }\n    }\n    \n    return minDist;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n  const vec3 small_step = vec3(0.0001, 0.0, 0.0);\n  \n  float grad_x = mapWorld(p + small_step.xyy) - mapWorld(p - small_step.xyy);\n  float grad_y = mapWorld(p + small_step.yxy) - mapWorld(p - small_step.yxy);\n  float grad_z = mapWorld(p + small_step.yyx) - mapWorld(p - small_step.yyx);\n\n  vec3 normal = vec3(grad_x, grad_y, grad_z);\n\n  return normalize(normal);\n}\n\nvec3 raymarch(in vec3 origin, in vec3 direction, in float maxDist, out bool hit)\n{\n    hit = false;\n    \n    float totalDistance = 0.0;\n    \n    vec3 position = origin;\n    \n    direction = normalize(direction);\n    \n    for(int i=0; i<RAYMARCH_MAX_ITERATIONS; i++)\n    {\n        float dist = mapWorld(position);\n        \n        if(dist < RAYMARCH_MIN_DISTANCE)\n        {\n            hit = true;\n            \n            return position;\n        }\n        else if(dist > RAYMARCH_MAX_DISTANCE || totalDistance + dist >= maxDist)\n        {\n            break;\n        }\n        \n        totalDistance += dist;\n        \n        position += direction * dist;\n    }\n    \n    return position;\n}\n\nvec3 raymarch(in vec3 origin, in vec3 direction, out bool hit)\n{\n    hit = false;\n    \n    float totalDistance = 0.0;\n    \n    vec3 position;\n    \n    for(int i=0; i<RAYMARCH_MAX_ITERATIONS; i++)\n    {\n        position = origin + normalize(direction) * totalDistance;\n        \n        float dist = mapWorld(position);\n        \n        if(dist < RAYMARCH_MIN_DISTANCE)\n        {\n            hit = true;\n            \n            return position;\n        }\n        else if(dist > RAYMARCH_MAX_DISTANCE)\n        {\n            break;\n        }\n        \n        totalDistance += dist;\n    }\n    \n    return position;\n}\n\nvec3 calcLighting(in vec3 point,in vec3 cameraPosition, in Object obj)\n{\n    \n    vec3 color = shadowColor;\n    \n    vec3 normal = calcNormal(point);\n    \n    vec3 surfacePoint = point+normal*RAYMARCH_MIN_DISTANCE;\n    \n    vec3 cameraDir = normalize(cameraPosition-point);\n    \n    for(int i=0; i<lightList.length(); i++)\n    {\n        Light light = lightList[i];\n        \n        vec3 lightDir = light.position - surfacePoint;\n        \n        float lightNormal = dot(normal, normalize(lightDir));\n        \n        if(lightNormal <= 0.0)\n        {//skip if allready in self shadow\n            continue;\n        }\n                \n        float lightDist = distance(surfacePoint, light.position);\n        \n        bool inShadow;\n        \n        raymarch(surfacePoint,lightDir, lightDist, inShadow);\n        \n        if(!inShadow)\n        {\n            color += obj.material.color * light.brightness * light.color * max(lightNormal,0.0) / pow(lightDist, 2.0);\n        }\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 cameraPosition = vec3(0.0,1.0,-12.0);//vec3(REALLYSILLY * cos(iTime) - 2.0,REALLYSILLY * sin(iTime) + 1.0,-12.0);\n    \n    vec2 uv = fragCoord / iResolution.y - 0.5;\n    \n    bool hit;\n    \n    vec3 rayOrigin = cameraPosition;\n    vec3 rayDir = normalize(vec3(uv,1.0));\n    \n    vec3 point = raymarch(rayOrigin, rayDir, hit);\n    \n    vec3 color = vec3(0.0);\n    \n    if(hit)\n    {\n        Object obj;\n        mapWorld(point, obj);\n        \n        color = calcLighting(point,cameraPosition, obj);\n        \n        color += obj.material.color * texture(iChannel1,reflect(rayDir, calcNormal(point))).xyz / 2.0;\n    } else {\n        color = texture(iChannel1, rayDir).xyz;\n    }\n    \n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"4dX3Rr","channel":0}],"code":"const vec3 sunDir = normalize(vec3(0.0,10.0,300.0));\nconst vec3 SUN_COLOR = vec3(1.0,0.98,0.96);\nconst float SUN_RADIUS = 0.10;\n\nconst float ATMOSPHERE_HEIGHT = 400.0;\n\nconst float PLANET_RADIUS = 1000.0;\n\nconst float scatterStrength = 1.0;\n\nconst vec3 wave = vec3(700,530,440);\nconst vec3 scatter = pow(400.0 / wave, vec3(4.0)) * scatterStrength;\n\n//.y returns the length of the line between the intersection point of the ray(point, dir) with the sphere(center, radius)\nvec2 raySphere(in vec3 center, in float radius, in vec3 origin, in vec3 dir)\n{\n\n    vec3 offset = origin - center;\n    float a = dot(dir,dir);\n    float b = 2.0 * dot(offset, dir);\n    float c = dot(offset, offset) - radius * radius;\n    \n    float discriminant = b*b-4.0*a*c;\n    \n    \n    if(discriminant > 0.0)\n    {\n        float s = sqrt(discriminant);\n        float distToSphereNear = max(0.0, (-b - s) / (2.0 * a));\n        float distToSphereFar = (-b + s) / (2.0 * a);\n        \n        if(distToSphereFar >= 0.0) \n        {\n            return vec2(distToSphereNear, distToSphereFar - distToSphereNear);\n        }\n     }\n     \n     //ray did not intersect sphere\n     return vec2(10000.0,0.0);\n}\n\nvec3 distance2color(in float dist)\n{\n    return dist * scatter / PLANET_RADIUS;\n}\n\nvoid mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    fragColor = vec4(0.0);\n    //return;\n    float atmosphere = raySphere(vec3(0.0,-PLANET_RADIUS,0.0),PLANET_RADIUS+ATMOSPHERE_HEIGHT,vec3(0.0),rayDir).y;\n    vec3 color = distance2color(atmosphere);\n    vec3 sun = SUN_COLOR / (1.0 + pow(distance(normalize(sunDir), rayDir),2.0) * 4.0 / SUN_RADIUS) / atmosphere * 400.0;\n    color += sun;\n    fragColor = vec4(color, 1.0);\n}","name":"Cube A","description":"","type":"cubemap"}]}