{"ver":"0.1","info":{"id":"ls2Bzd","date":"1501900848","viewed":2611,"name":"Tiny Planet: Vulcan","username":"morgan3d","description":"A volcanic planet","likes":52,"published":1,"flags":0,"usePreview":0,"tags":["space","planet","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Tiny Planet: Vulcan\n// by Morgan McGuire @CasualEffects\n//\n// Texturing inspired by Paul Malin https://www.shadertoy.com/view/ldBfDR\n//\n// I intentionally left the aliasing on the bright locations in...\n// it looks like heat distortion.\n\nconst bool autoRotate = true;\n\n/////////////////////////////////////////////////////////////////////////\n// Morgan's standard Shadertoy helpers\n#define Vector2      vec2\n#define Point2       vec2\n#define Point3       vec3\n#define Vector3      vec3\n#define Color3       vec3\n#define Radiance3    vec3\n#define Irradiance3  vec3\n#define Power3       vec3\n#define Biradiance3  vec3\n\nconst float pi          = 3.1415926535;\nconst float degrees     = pi / 180.0;\nconst float inf         = 1.0 / 1e-10;\n\nfloat square(float x) { return x * x; }\nfloat pow3(float x) { return x * square(x); }\nvec3 square(vec3 x) { return x * x; }\nvec3 pow3(vec3 x) { return x * square(x); }\nfloat pow4(float x) { return square(square(x)); }\nfloat pow5(float x) { return x * square(square(x)); }\nfloat pow8(float x) { return square(pow4(x)); }\nfloat infIfNegative(float x) { return (x >= 0.0) ? x : inf; }\n\nstruct Ray { Point3 origin; Vector3 direction; };\t\nstruct Material { Color3 color; float metal; float smoothness; };\nstruct Surfel { Point3 position; Vector3 normal; Material material; };\nstruct Sphere { Point3 center; float radius; Material material; };\n   \n/** Analytic ray-sphere intersection. */\nbool intersectSphere(Point3 C, float r, Ray R, inout float nearDistance, inout float farDistance) { Point3 P = R.origin; Vector3 w = R.direction; Vector3 v = P - C; float b = 2.0 * dot(w, v); float c = dot(v, v) - square(r); float d = square(b) - 4.0 * c; if (d < 0.0) { return false; } float dsqrt = sqrt(d); float t0 = infIfNegative((-b - dsqrt) * 0.5); float t1 = infIfNegative((-b + dsqrt) * 0.5); nearDistance = min(t0, t1); farDistance  = max(t0, t1); return (nearDistance < inf); }\n\n///////////////////////////////////////////////////////////////////////////////////\n// The following are from https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\nfloat noise(float x) { float i = floor(x); float f = fract(x); float u = f * f * (3.0 - 2.0 * f); return mix(hash(i), hash(i + 1.0), u); }\nfloat noise(vec2 x) { vec2 i = floor(x); vec2 f = fract(x); float a = hash(i); float b = hash(i + vec2(1.0, 0.0)); float c = hash(i + vec2(0.0, 1.0)); float d = hash(i + vec2(1.0, 1.0)); vec2 u = f * f * (3.0 - 2.0 * f); return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y; }\nfloat noise(vec3 x) { const vec3 step = vec3(110, 241, 171); vec3 i = floor(x); vec3 f = fract(x); float n = dot(i, step); vec3 u = f * f * (3.0 - 2.0 * f); return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x), mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y), mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x), mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z); }\n\n#define DEFINE_FBM(name, OCTAVES) float name(vec3 x) { float v = 0.0; float a = 0.5; vec3 shift = vec3(100); for (int i = 0; i < OCTAVES; ++i) { v += a * noise(x); x = x * 2.0 + shift; a *= 0.5; } return v; }\nDEFINE_FBM(fbm3, 3)\nDEFINE_FBM(fbm5, 5)\nDEFINE_FBM(fbm6, 6)\n\n///////////////////////////////////////////////////////////////////////////////////\n\n// The red channel defines the height, but all channels\n// are used for color.\n#define elevationMap iChannel0\n#define colorMap iChannel1\n\nconst float       verticalFieldOfView = 25.0 * degrees;\n\n// Directional light source\nconst Vector3     w_i             = Vector3(1.0, 1.0, -0.8) / 1.6248076;\nconst Biradiance3 B_i             = Biradiance3(4);\n\nconst Point3      planetCenter    = Point3(0);\n\n// Including mountains\nconst float       planetMaxRadius = 1.0;\nconst float       maxMountain = 0.13;\n\n\nconst float planetMinRadius = planetMaxRadius - maxMountain;\n\nmat3 planetRotation;\n\n/** Returns color, coverage under world-space point wsPoint.\n    e is the relative height of the surface. \n    k is the relative height of the ray\n*/\nColor3 samplePlanet(Point3 osPosition, out float e, out float k) {\n\tPoint3 s = normalize(osPosition);    \n    \n    // Cylindrical map coords\n    Point2 cylCoord = vec2(atan(s.z, -s.x) / pi, s.y * 0.5 + 0.5);\n\n    // Length of osPosition = elevation\n    float sampleElevation  = length(osPosition);//dot(osPosition, s);\n    \n    // Relative height of the sample point [0, 1]\n    k = (sampleElevation - planetMinRadius) * (1.0 / maxMountain);\n\n    // Use explicit MIPs, since derivatives\n    // will be random based on the ray marching\n    float lod = (iResolution.x > 800.0) ? 1.0 : 2.0;\n    \n    // Relative height of the surface [0, 1]\n    e = mix(textureLod(elevationMap, cylCoord, lod).r, textureLod(elevationMap, s.xz, lod).r, abs(s.y));\n    e = square((e - 0.2) / 0.8) * 0.5;\n    \n    // Soften glow at high elevations, using the mip chain\n    // (also blurs \n    lod += k * 6.0;\n    \n    // Planar map for poles mixed into cylindrical map\n    Color3 material = mix(textureLod(colorMap, cylCoord * vec2(2.0, 2.0), lod).rgb,\n                          textureLod(colorMap, s.xz, lod).rgb, abs(s.y));\n\n    // Increase contrast\n    material = pow3(material);\n    \n    \n    // Object space height of the surface\n    float surfaceElevation = mix(planetMinRadius, planetMaxRadius, e);\n\n    return material;\n}\n\n\n/** Relative to mountain range */\nfloat elevation(Point3 osPoint) {\n    float e, k;\n    samplePlanet(osPoint, e, k);\n    return e;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Rotate over time\n\tfloat yaw   = -((iMouse.x / iResolution.x) * 2.5 - 1.25) + (autoRotate ? -iTime * 0.02 : 0.0);\n\tfloat pitch = ((iMouse.y > 0.0 ? iMouse.y : iResolution.y * 0.3) / iResolution.y) * 2.5 - 1.25;\n \tplanetRotation = \n    \tmat3(cos(yaw), 0, -sin(yaw), 0, 1, 0, sin(yaw), 0, cos(yaw)) *\n    \tmat3(1, 0, 0, 0, cos(pitch), sin(pitch), 0, -sin(pitch), cos(pitch));\n\n    \n    Vector2 invResolution = 1.0 / iResolution.xy;\n\t\n\t// Outgoing light\n\tRadiance3 L_o;\n\t\n\tSurfel surfel;\t\n\t\n\tRay eyeRay = Ray(Point3(0.0, 0.0, 5.0), normalize(Vector3(fragCoord.xy - iResolution.xy / 2.0, iResolution.y / (-2.0 * tan(verticalFieldOfView / 2.0)))));\n\t    \n    Point3 hitPoint;    \n    float minDistanceToPlanet, maxDistanceToPlanet;\n    \n    bool hitBounds = intersectSphere(planetCenter, planetMaxRadius, eyeRay, minDistanceToPlanet, maxDistanceToPlanet);\n\n    // Stars\n    L_o = vec3(1) * max(0.0, hash(fragCoord * 0.5 + 10.0) - 0.999) / 0.0001 +\n        pow5(fbm3(fragCoord.xyy * -0.007 + iTime * 0.1)) * square(texture(iChannel1, fragCoord * invResolution.x).rbr) * max(0.0, hash(fragCoord * 0.1) - 0.99) / 0.0003;\n        \n    // Background wash gradient\n    float gradCoord = (fragCoord.x + fragCoord.y) * (invResolution.x * 0.5);\n    L_o += mix(Color3(0.025, 0, 0.02), Color3(0.11, 0.06, 0.0), gradCoord) * 1.5 *\n         (0.15 + smoothstep(0.0, 1.0, 2.5 * abs(gradCoord - 0.4)));\n    \n    // Background glow (\"atmosphere\")\n    L_o += Color3(0.6, 0.06, 0.01) * (17.0 * pow8(max(0.0, 1.0 - length((fragCoord - iResolution.xy * 0.5) * invResolution.y))));\n\n    // Sun\n    Point2 sunCoord = vec2(-0.7, -0.5) + (fragCoord - iResolution.xy * 0.5) * invResolution.y;\n    float sunDist = max(0.0,  1.0 - length(sunCoord));\n    L_o += Color3(15, 9, 6) * (pow(sunDist, 12.0) * (1.0 + 0.25 * noise(sin(iTime * 0.1) + iTime * 0.1 + 20.0 * atan(sunCoord.x, -sunCoord.y))));\n    \n    \n    if (hitBounds) {\n        Color3 glow = Color3(0);\n        // Planet surface + atmospherics\n        \n        // March to surface\n        const int NUM_STEPS = 250;\n        \n        // Total traversal should be either 25% of the thickness of the planet,\n        // the distance between total, or the max mountain height\n        float dt = (maxDistanceToPlanet - minDistanceToPlanet) / float(NUM_STEPS);\n        Color3 material = Color3(0);\n        Vector3 wsNormal = Vector3(0);\n        Color3 p;\n        float coverage = 0.0;\n        float e = 1.0, k = 0.0;\n\n        // Take the ray to the planet's object space\n        eyeRay.origin = (eyeRay.origin - planetCenter) * planetRotation;\n        eyeRay.direction = eyeRay.direction * planetRotation;\n        \n        Point3 X;\n        for (int i = 0; (i < NUM_STEPS) && (coverage < 1.0); ++i) {\n            // Point on the ray in object space\n            X = eyeRay.origin + eyeRay.direction * (dt * float(i) + minDistanceToPlanet);\n            \n            // color, coverage\n\t        p = samplePlanet(X, e, k);\n            if (e > k) {\n                // Hit the surface\n                material = p;\n                coverage = 1.0;\n                \n                // Surface emission\n\t            glow += pow(p, p * 2.5 + 7.0) * 3e3;\n            } else {\n                // Passing through atmosphere above lava; accumulate glow\n\t            glow += pow(p, p + 7.0) * square(square(1.0 - k)) * 25.0;\n            }\n        }\n\n        // Planetary sphere normal\n        Vector3 sphereNormal = normalize(planetRotation * X);\n            \n        // Surface normal\n        const float eps = 0.01;\n        wsNormal = planetRotation *\n            normalize(Vector3(elevation(X + Vector3(eps, 0, 0)), \n                              elevation(X + Vector3(0, eps, 0)), \n                              elevation(X + Vector3(0, 0, eps))) - \n                              e);\n        \n        \n        wsNormal = normalize(mix(wsNormal, sphereNormal, 0.95));\n                \n        // Lighting and compositing\n        L_o =  mix(L_o, material * \n                   // Sun\n                   (max(dot(wsNormal, w_i) + 0.1, 0.0) * B_i + \n                    \n                    \n                    // Rim light\n                    square(max(0.8 - sphereNormal.z, 0.0)) * Color3(2.0, 1.5, 0.5)), coverage);\n        L_o += glow;\n        \n         \n        if (false && coverage > 0.0) {\n            // Show normals\n\t      //  L_o = wsNormal * 0.5 + 0.5;\n          //  L_o = max(0.0, dot(wsNormal, w_i)) * vec3(1);\n        }\n    }\n    \n\tfragColor.xyz = sqrt(L_o);\n    fragColor.a   = 1.0;//maxDistanceToPlanet;\n\n}","name":"Image","description":"","type":"image"}]}