{"ver":"0.1","info":{"id":"MdSczy","date":"1492549665","viewed":419,"name":"3D Metaballs","username":"Helpfully","description":"Metaball algorithm implemented with vertex shader only","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** VARIABLES **/\n\nconst vec3 light_pos = vec3(-2.0, 4.0, -1.0);\nconst vec3 c_light_pos = vec3(2.0, -4.0, -0.0);\n\nconst int \tTRACE_STEPS \t\t= 248;\nconst float TRACE_EPSILON \t\t= 0.00000000001; // 0.00000001;\nconst float REFLECT_EPSILON \t= 100.0;\nconst float TRACE_DISTANCE\t\t= 50.0;\nconst float NORMAL_EPSILON\t\t= 1.0;\nconst int   REFLECT_DEPTH\t\t= 50;\nconst int \tNUM_BALLS\t\t\t= 10;\n\n\nvec3 balls[NUM_BALLS];\n\n\n\n\n/* FUNCTIONS */\nvoid update_balls_position() {\n    \n\tfloat t = iTime * 0.1;\n\tfor (int i = 0; i < NUM_BALLS; ++i) {\n\t\tballs[i] = 3. * vec3(\n\t\t\tsin(2.3+float(i+2)*t),\n\t\t\tcos(1.7+float(-5+i)*t),\n\t\t\t1.1*sin(3.0+float(i+7)*t));\n\t}\n}\n\n\nfloat metaballs_field(in vec3 at) {\n\tfloat sum = 0.;\n\tfor (int i = 0; i < NUM_BALLS; ++i) {\n\t\tfloat r = length(balls[i] - at);\n\t\t\n\t\tsum += 1.0 / ( r * r * r * (r * (r * 6.0 - 15.0) + 10.0));\n\t    // sum += 1.0 / ( r * r * r * r - r * r + 0.25);\n\t}\n\treturn 1. - sum;\n}\n\n\n\nvec3 normal(in vec3 at) {\n\tvec2 e = vec2(0.0, NORMAL_EPSILON);\n\treturn normalize(vec3(metaballs_field(at+e.yxx)-metaballs_field(at), \n\t\t\t\t\t\t  metaballs_field(at+e.xyx)-metaballs_field(at),\n\t\t\t\t\t\t  metaballs_field(at+e.xxy)-metaballs_field(at)));\n}\n\nvec4 raymarch(in vec3 pos, in vec3 dir, in float maxL) {\n\tfloat l = 0.;\n\tfor (int i = 0; i < TRACE_STEPS; ++i) {\n\t\tfloat d = metaballs_field(pos + dir * l);\n\t\tif (d < TRACE_EPSILON*l)\n\t\t\tbreak;\n\t\tl += d;\n\t\tif (l > maxL) break;\n\t}\n\treturn vec4(pos + dir * l, l);\n}\n\nvec3 lookAtDir(in vec3 dir, in vec3 pos, in vec3 at) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0.,1.,0.));\n\tvec3 u = cross(r, f);\n\treturn normalize(dir.x * r + dir.y * u + dir.z * f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tupdate_balls_position();\n\t\n\tfloat t = iTime * 0.1;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(aspect, 1.);\n\t\n\tvec3 pos = vec3(cos(2.+4.*cos(t))*10., 2.+8.*cos(t*.8), 10.*sin(2.+3.*cos(t)));\n\tvec3 dir = lookAtDir(normalize(vec3(uv, 2.)), pos.xyz, vec3(balls[0]));\n\t\n\tvec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n\t\n\tfor (int reflections = 0; reflections < REFLECT_DEPTH; ++reflections) {\n\t\tvec4 tpos = raymarch(pos, dir, TRACE_DISTANCE);\n\t\tif (tpos.w >= TRACE_DISTANCE) {\n\t\t\tcolor += vec4(0.0, 0.0, 0.0, 0.0);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t// color \n\t\tvec3 norm = normal(tpos.xyz);\n\t\tvec3 light_norm = normalize(light_pos - tpos.xyz); \n\t\tvec4 diffuse = max(dot(norm, light_norm), 0.0) * vec4(0.5, 0.0, 0.0, 1.0); \n\t\tvec3 r_light = normalize(reflect(light_norm, norm));\n\t\tvec4 specular = vec4(1.0) * pow(max(dot(r_light, -dir), 0.0), 4.0);\n\t\tvec3 c_light_normal = normalize(c_light_pos - tpos.xyz);\n\t\tvec3 c_r_light = normalize(reflect(c_light_normal, norm));\n\t\tvec4 c_specular = vec4(0.0, 0.0, 0.7, 1.0) * pow(max(dot(c_r_light, -dir), 0.0), 4.0);\n\t\t\n\t\t\n\t   \n\t\tcolor = vec4(0.1, 0.0, 0.0, 0.0) + diffuse + specular + c_specular;\n\t\t\n\t\tcolor -= color.w * 0.004;\n\n\t\tdir = normalize(reflect(dir, normal(tpos.xyz)));\n\t\tpos = tpos.xyz + dir * REFLECT_EPSILON;\n\t}\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}