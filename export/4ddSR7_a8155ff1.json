{"ver":"0.1","info":{"id":"4ddSR7","date":"1458396831","viewed":560,"name":"Fast convex shape raymarching","username":"OneManBand","description":"Each step of ray marching is accelerated knowing that the shape is convex. This solution avoids slow ray marching along edges and while \"leaving\" a surface.<br/>Every 3 seconds, the visualization switches from the classic solution to the accelerated one.","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\nBased on 2D SDG Toy by hughsk\nhttps://www.shadertoy.com/view/XsyGRW\n\n*/\n\n#define TRACE_STEPS 20\n#define TRACE_RAY\n\n// 0 = Distance Field Display\n// 1 = Raymarched Edges\n// 2 = Resulting Solid\n// 3 = Distance Field Polarity\n#define DISPLAY 0\n\n\n  #define SAMPLER(p) min(shape_circle( p, vec2(0.5) ), shape_circle( p, -vec2(0.4) ) )\n  #define SAMPLER_B(p) min(sdf_circle( p, vec2(0.5) ), sdf_circle( p, -vec2(0.4) ) )\n\n\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nconst float PI = 3.14159265359;\nconst float zero = 0.00001;\nfloat time, boost;\nvec2 rd;\n\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {\n  return a + b * cos(6.28318 * (c * t + d));\n}\n\n// r^2 = x^2 + y^2\n// r = sqrt(x^2 + y^2)\n// r = length([x y])\n// 0 = length([x y]) - r\nfloat sdf_circle(vec2 p, vec2 center) {\n  float d = length(p - center) - 0.5;\n  vec2 N = -normalize(p-center); \n  d /= max(dot(rd, N), zero);\n  return d;\n}\n\nfloat shape_circle(vec2 p, vec2 center) {\n  float d = length(p - center) - 0.5;\n  return d;\n}\n\n// y = sin(5x + t) / 5\n// 0 = sin(5x + t) / 5 - y\nfloat shape_sine(vec2 p) {\n  return p.y - sin(p.x * 5.0 + time) * 0.2;\n}\n\nfloat shape_box2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat shape_line(vec2 p, vec2 a, vec2 b) {\n  vec2 dir = b - a;\n  return abs(dot(normalize(vec2(dir.y, -dir.x)), a - p));\n}\n\nfloat shape_segment(vec2 p, vec2 a, vec2 b) {\n  float d = shape_line(p, a, b);\n  float d0 = dot(p - b, b - a);\n  float d1 = dot(p - a, b - a);\n  return d1 < 0.0 ? length(a - p) : d0 > 0.0 ? length(b - p) : d;\n}\n\nfloat shape_circles_smin(vec2 p, float t) {\n  return smin(shape_circle(p, vec2(cos(t))), shape_circle(p, -vec2(sin(t), 0)), 0.8);\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_polarity(float d, vec2 p) {\n  p += iTime * -0.1 * sign(d) * vec2(0, 1);\n  p = mod(p + 0.06125, 0.125) - 0.06125;\n  float s = sign(d) * 0.5 + 0.5;\n  float base = draw_solid(d);\n  float neg = shape_box2d(p, vec2(0.045, 0.0085) * 0.5);\n  float pos = shape_box2d(p, vec2(0.0085, 0.045) * 0.5);\n  pos = min(pos, neg);\n  float pol = mix(neg, pos, s);\n\n  float amp = abs(base - draw_solid(pol)) - 0.9 * s;\n\n  return vec3(1.0 - amp);\n}\n\nvec3 draw_distance(float d, vec2 p) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvec3 draw_trace(float d, vec2 p, vec2 ro, vec2 rd_old) {\n  vec3 col = vec3(0);\n  vec3 line = vec3(1, 1, 1);\n  vec2 _ro = ro;\n  float t;\n  for (int i = 0; i < TRACE_STEPS ; i++) {\n    if(mod(time, 6.0)>3.0)  {t = SAMPLER_B(ro); line = vec3(0.8, 1.0, 1.0);}\n    else {t = SAMPLER(ro); line = vec3(1.0, 0.8, 1.0);}\n\n      \n    col += 0.8 * line * (1.0 - draw_line(length(p.xy - ro) - abs(t), 0.));\n    if(t<1.0) col += 0.2 * line * (1.0 - draw_solid(length(p.xy - ro) - abs(t) + 0.02));\n    col += line * (1.0 - draw_solid(length(p.xy - ro) - 0.015));\n\n    t = min(t, 20.0);\n    ro += rd * t;\n    if (t < 0.01) break;\n    if (t >= 20.0) break;\n  }\n\n  #ifdef TRACE_RAY\n    col += (1.0 - line * draw_line(shape_segment(p, _ro, ro), 0.));\n    //col += shape_line(p, vec2(-0.7, 0.0), _ro);\n  #endif\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = iTime * 0.5;\n  time = iTime;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  rd = normalize(-ro);\n\n  d = SAMPLER(uv);\n\n  #if DISPLAY == 0\n    col = vec3(draw_distance(d, uv.xy));\n    col -= (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(draw_trace(d, uv.xy, ro, rd));\n  #endif\n  #if DISPLAY == 1\n    col += 1.0 - vec3(draw_line(d));\n    col += (iMouse.z > 0.0 ? 1.0 : 0.0) * vec3(1, 0.25, 0) * vec3(draw_trace(d, uv.xy, ro, rd));\n    col = 1. - col;\n  #endif\n  #if DISPLAY == 2\n    col = vec3(draw_solid(d));\n  #endif\n  #if DISPLAY == 3\n    col = vec3(draw_polarity(d, uv.xy));\n  #endif\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"}]}