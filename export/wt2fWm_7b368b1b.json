{"ver":"0.1","info":{"id":"wt2fWm","date":"1599142566","viewed":116,"name":"esfera-fbm","username":"jorge2017a1","description":"esfera-fbm","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["esferafbm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///----Autor desconocido\n///----18865.2\n\nvec2 hash(vec2 uv) {\n\tmat2 m = mat2(15.32, 35.68, 75.42, 153.93);\n\treturn fract(sin(m * uv) * 43258.21);\n}\n\nvec3 hash(vec3 p) {\n\tmat3 m = mat3(15.32, 35.68, 75.42, 153.93, 18.23, 85.75, 254.63, 384.64, 712.98);\n\treturn fract(sin(m * p) * 43258.21);\n}\n\nvec2 shash(vec2 uv) {\n\treturn hash(uv) * 2.0 - 1.0;\n}\n\nvec3 shash(vec3 p) {\n\treturn hash(p) * 2.0 - 1.0;\n}\n\nfloat noise(vec2 uv) {\n\tvec2 g = floor(uv);\n\tvec2 f = fract(uv);\n\tvec2 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n\tfloat lb = dot(\tshash(g + vec2(0.0, 0.0)), f - vec2(0.0, 0.0));\n\tfloat rb = dot(\tshash(g + vec2(1.0, 0.0)), f - vec2(1.0, 0.0));\n\tfloat lt = dot(\tshash(g + vec2(0.0, 1.0)), f - vec2(0.0, 1.0));\n\tfloat rt = dot(\tshash(g + vec2(1.0, 1.0)), f - vec2(1.0, 1.0));\n\t\n\tfloat b = mix(lb, rb, k.x);\n\tfloat t = mix(lt, rt, k.x);\n\treturn 0.5 + 0.5 * mix(b, t, k.y);\n}\n\nfloat noise(vec3 p)\n{\n\tvec3 g = floor(p);\n\tvec3 f = fract(p);\n\tvec3 k = f*f*f*(6.0*f*f - 15.0*f + 10.0);\n\tfloat lbu = dot(shash(g + vec3(0.0, 0.0, 0.0)), f - vec3(0.0, 0.0, 0.0));\n\tfloat rbu = dot(shash(g + vec3(1.0, 0.0, 0.0)), f - vec3(1.0, 0.0, 0.0));\n\tfloat ltu = dot(shash(g + vec3(0.0, 1.0, 0.0)), f - vec3(0.0, 1.0, 0.0));\n\tfloat rtu = dot(shash(g + vec3(1.0, 1.0, 0.0)), f - vec3(1.0, 1.0, 0.0));\n\tfloat lbd = dot(shash(g + vec3(0.0, 0.0, 1.0)), f - vec3(0.0, 0.0, 1.0));\n\tfloat rbd = dot(shash(g + vec3(1.0, 0.0, 1.0)), f - vec3(1.0, 0.0, 1.0));\n\tfloat ltd = dot(shash(g + vec3(0.0, 1.0, 1.0)), f - vec3(0.0, 1.0, 1.0));\n\tfloat rtd = dot(shash(g + vec3(1.0, 1.0, 1.0)), f - vec3(1.0, 1.0, 1.0));\n\t\n\tfloat bu = mix(lbu, rbu, k.x);\n\tfloat tu = mix(ltu, rtu, k.x);\n\tfloat bd = mix(lbd, rbd, k.x);\n\tfloat td = mix(ltd, rtd, k.x);\n\tfloat u = mix(bu, tu, k.y);\n\tfloat d = mix(bd, td, k.y);\n\treturn 0.5 + 0.5 * mix(u, d, k.z);\n}\n\nfloat fbm(vec2 uv) {\n\tfloat v = 0.0;\n\tmat2 m = mat2(0.8, -0.6, 0.6, 0.8);\n\tv += noise(uv) / 2.0; uv = m * uv * 2.01;\n\tv += noise(uv) / 4.0;  uv = m * uv * 2.03;\n\tv += noise(uv) / 8.0;  uv = m * uv * 2.02;\n\tv += noise(uv) / 16.0;\n\treturn v * 1.3385;\n}\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\n\nfloat sdSphere(vec3 p, float r) \n{\n\treturn length(p) - r + noise(p * 50.0) * 0.1;\n}\n\nfloat scene(vec3 p) {\n\tfloat d = sdPlane(p);\n\td = min(d, sdSphere(p - vec3(0.1 * cos(iTime * 0.9), 0.5, 0.1 * sin(iTime)), 0.5));\n\treturn d;\n}\n\nvec3 calcNormal(vec3 p) {\n\tvec3 e = vec3(0.00001, 0.0, 0.0);\n\tvec3 nor = vec3(scene(p + e.xyy) - scene(p - e.xyy),\n\t\t\tscene(p + e.yxy) - scene(p - e.yxy),\n\t\t\tscene(p + e.yyx) - scene(p - e.yyx));\n\treturn normalize(nor);\n}\n/*\nfloat calcAO(vec3 pos, vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n*/\n\nfloat calcAO(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\tfloat h = 0.0;\n\tfloat sh = 1.0;\n\tfor(int i = 0; i < 5; i++) {\n\t\tt += 0.01 + 0.05 * float(i);\n        \th = scene(ro + rd * t);\n\t\tsh = min(sh, h * 6.0 / t);\n\t}\n\treturn clamp(sh, -1.0, 1.0) * 0.05 + 0.95;\n}\nfloat shadow(vec3 ro, vec3 rd, float mint, float maxt) {\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfloat sh = 1.0;\n\tfor(int i = 0; i < 30; i++) {\n\t\tif(t > maxt) continue;\n\t\th = scene(ro + rd * t);\n\t\tsh = min(sh, h * 6.0 / t);\n\t\t//sh = h < 0.1 ? 0.0 : 1.0;\n\t\tt += h;\n\t}\n\treturn sh;\n}\n\nfloat castRay(vec3 ro, vec3 rd, float maxt) {\n\tfloat precis = 0.00001;\n\tfloat t = precis * 2.0;\n\tfor(int i = 0; i < 60; i++) {\n\t\tif(t < precis || t > maxt) continue;\n\t\tfloat h = scene(ro + rd * t);\n\t\tt += h;\n\t}\n\treturn t;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n\tvec3 color = vec3(1.0);\n\tfloat t = castRay(ro, rd, 20.0);\n\tvec3 p = ro + rd * t;\n\tcolor = vec3(0.6) + 0.4*sin( vec3(0.05,0.08,0.10)*(p.x * 10.0 -1.0) );\n\tvec3 lig = normalize(vec3(-0.2, 0.5, 0.3));\n\tvec3 nor = calcNormal(p);\n\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tfloat sh = shadow(p, lig, 0.02, 20.0);\n\tfloat ao = calcAO(p, nor);\n\tcolor = color * (dif * ao + spec) * (0.2 + 0.8 * sh);\n\tcolor *= exp(-0.01 * t * t);\n\treturn color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = ( fragCoord.xy / iResolution.xy );\n\tuv = uv * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = vec3(0.0, 1.0, 3.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = cross(cw, up);\n\tvec3 cv = cross(cu, cw);\n\tvec3 rd = normalize(uv.x * cu + uv.y * cv + 2.0 * cw);\n\t\n\tvec3 color = render(ro, rd);\n\n\tfragColor = vec4( color, 1.0 );\n\n}\n\n","name":"Image","description":"","type":"image"}]}