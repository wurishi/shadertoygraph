{"ver":"0.1","info":{"id":"stBGW3","date":"1624906559","viewed":106,"name":"Types of Voronoi","username":"DrDesten","description":"Different Types of Voronoi / Worley Noise\n\n1: Normal Voronoi Noise\n2: Difference between Worley and Voronoi\n3: Worley Noise, 2nd closest\n4: Worley Noise, 4th closest","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","noise","random","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Controls (Play with these)\n//////////////////////////////////////////////////////////////////\n\n// Increase PROXIMITY_CHECK if you see grid lines\n#define PROXIMITY_CHECK 2\n#define GRID_SIZE 25.\n\n#define ANIMATE\n#define ANIMATION_SPEED 2.\n\n#define RANDOMNESS 1. \n\n//#define COLORIZE\n\nfloat N21(vec2 c) {\n    return fract(sin(c.x*38.+c.y*367.) * 43891.1791);\n}\nvec2 N22(vec2 c) {\n    return vec2(N21(c-5.), N21(c+5.));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Make UVs Aspect Ratio independant and center at (0,0)\n    vec2 uv  = (fragCoord - iResolution.xy * .5)/iResolution.x;\n    \n    // Calculate Grid UVs (Also center at (0,0))\n    vec2 guv = fract(uv * GRID_SIZE) - .5;\n    vec2 gid = floor(uv * GRID_SIZE);\n \n    vec3 col = vec3(0);\n    \n    float md1 = 1e3;\n    float md2 = 2e3;\n    float md3 = 3e3;\n    float md4 = 4e3;\n    \n    // Check neighboring Grid cells\n    for (int x = -PROXIMITY_CHECK; x <= PROXIMITY_CHECK; x++) {\n        for (int y = -PROXIMITY_CHECK; y <= PROXIMITY_CHECK; y++) {\n        \n            vec2 offset = vec2(x, y);\n            \n            // Get the id of current cell (pixel cell + offset by for loop)\n            vec2 id         = gid + offset;\n            // Get the uv difference to that cell (offset has to be subtracted)\n            vec2 relativeUV = guv - offset;\n            \n            // Get Random Point (adjust to range (-.5, .5))\n            vec2 p          = N22(id) - .5;\n            \n            #ifdef ANIMATE\n                p = vec2(sin(iTime * p.x * ANIMATION_SPEED), cos(iTime * p.y * ANIMATION_SPEED)) * .5;\n            #endif\n            \n            p *= RANDOMNESS;\n            \n            // Calculate Distance bewtween point and relative UVs)\n            float d         = distance(p, relativeUV);\n            \n            \n            if (md1 > d) {\n                md4 = md3;\n                md3 = md2;\n                md2 = md1;\n                md1 = d;\n            } else if (md2 > d) {\n                md4 = md3;\n                md3 = md2;\n                md2 = d;\n            } else if (md3 > d) {\n                md4 = md3;\n                md3 = d;\n            } else if (md4 > d) {\n                md4 = d;\n            }\n            \n        \n        }\n    }\n    \n    vec2 screenUV = (fragCoord / iResolution.xy) - .5;\n    if (uv.x < 0. && uv.y > 0.) {\n    \n        // Normal Voronoi Noise\n        col = vec3(md1 / 1.225);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x - .5), sin(col.x), sin(col.x + 1.1));\n        #endif\n        \n    } else if (screenUV.x > 0. && screenUV.y > 0.) {\n    \n        // Difference between closest and second-closest point\n        col = vec3(md2 - md1);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x + .3), sin(col.x + .05), sin(col.x - .3));\n        #endif\n        \n    } else if (screenUV.x < 0. && screenUV.y < 0.) {\n        \n        // Worley Noise (2nd)\n        col = vec3(md2 / 1.414);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x + .24), sin(col.x + .2), sin(col.x + .1));\n        #endif\n    \n    } else if (screenUV.x > 0. && screenUV.y < 0.) {\n        \n        // Worley Noise (4th)\n        col = vec3(md4 / 1.732);\n        \n        #ifdef COLORIZE\n            col = vec3(sin(col.x - .3), sin(col.x + .2), sin(col.x + .6));\n        #endif\n    \n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}