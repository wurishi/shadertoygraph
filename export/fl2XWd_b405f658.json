{"ver":"0.1","info":{"id":"fl2XWd","date":"1628883828","viewed":74,"name":"Globe Spin","username":"falconXYZ","description":"3D Globe spinning with ray marching\n\nPaste the code at the top of the file into the browser console to make it work!\n(This is to load the correct textures)\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","globe"],"hasliked":0,"parentid":"stSSDd","parentname":"Quick raymarch"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n//Paste the next line of code (without the // at the beginning to the browser console:\n//gShaderToy.SetTexture(0, {mSrc:'https://images-wixmp-ed30a86b8c4ca887773594c2.wixmp.com/f/adca15fb-d12c-4e70-b302-168c35dbd9d6/d9xqfwv-ce81ba6a-7e9f-4c6f-b458-b041871d6ef1.png?token=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ1cm46YXBwOjdlMGQxODg5ODIyNjQzNzNhNWYwZDQxNWVhMGQyNmUwIiwiaXNzIjoidXJuOmFwcDo3ZTBkMTg4OTgyMjY0MzczYTVmMGQ0MTVlYTBkMjZlMCIsIm9iaiI6W1t7InBhdGgiOiJcL2ZcL2FkY2ExNWZiLWQxMmMtNGU3MC1iMzAyLTE2OGMzNWRiZDlkNlwvZDl4cWZ3di1jZTgxYmE2YS03ZTlmLTRjNmYtYjQ1OC1iMDQxODcxZDZlZjEucG5nIn1dXSwiYXVkIjpbInVybjpzZXJ2aWNlOmZpbGUuZG93bmxvYWQiXX0.U-jCS-E1Uia13FljIGwkkf7TNRPnSrEwxIIZ7po_rZ0', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});gShaderToy.SetTexture(1, {mSrc:'https://i.imgur.com/j85d3gz.jpg', mType:'texture', mID:1, mSampler:{ filter: 'mipmap', wrap: 'repeat', vflip:'true', srgb:'false', internal:'byte' }});\n//\n//\n\n\nfloat map(vec3 ray) {\n    float map = distance(ray, vec3(0,0,0)) - 0.35;\n    return map;\n\n\n}\n\nvec3 getNormal (vec3 p) {\n    vec2 e = vec2(0.01, 0.0);\n    float d = map(p);\n    vec3 n = d - vec3( map(p-e.xyy) , map(p-e.yxy) , map(p-e.yyx) );\n    return normalize(n);\n}\n\nvec3 diffuseLighting(vec3 pos,vec3 lightPos,vec3 Color, float power) {\n    vec3 light = normalize(lightPos - pos);\n    vec3 normal = getNormal(pos);\n    \n    float diffuse = clamp(dot(normal, light),0.0,1.0);\n    return diffuse * Color * power;\n}\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = getNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(-2.0,\n                           2.0,\n                          -3.0);\n    vec3 light1Intensity = vec3(0.2, 0.2, 0.2);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(-2,\n                          2.,\n                          -3);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x /= iResolution.y/iResolution.x;\n    \n    vec3 ro = vec3(0,0,-1);\n    vec3 rd = vec3(uv, 1.);\n    vec3 diffuseWhite;\n    float dist = 0.;\n    float distTo;\n    bool collide = false; \n    vec3 ray;\n    vec3 text = vec3(0);\n    for (int i = 0; i < 128; i++) {\n        ray = ro + rd * dist;\n        distTo = map(ray);\n        dist += distTo;\n        if (distTo < 0.001) {\n            collide = true;\n            break;\n        }\n        \n       \n    }\n     diffuseWhite = diffuseLighting(ray,vec3(0,1,-5),vec3(1,1,1), 0.5);\n     \n     vec3 K_a = vec3(0.2, 0.2, 0.2);\n    vec3 K_d = vec3(0.3, 0.2, 0.2);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 2.;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, ray, ro);\n    \n    if (collide) {\n        uv = ray.xy * 1.1;\n        uv.y += 0.54;\n        uv.x -= iTime / 5.0;\n        text = texture(iChannel0, uv).rgb;\n    } else {\n    \n        text = texture(iChannel1, uv/4.-0.12).rgb;\n    }\n     \n    //if (!collide)\n   //         diffuseWhite = vec3(1,1,1);\n   text *= color * 5.0;\n    fragColor = vec4(text,1.0);\n  //  fragColor = vec4(distTo,0,0,1.0);\n}","name":"Image","description":"","type":"image"}]}