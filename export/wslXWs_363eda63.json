{"ver":"0.1","info":{"id":"wslXWs","date":"1552596053","viewed":1899,"name":"Ray Marching Surface Normals","username":"drichardson","description":"Surface Normal portion of https://www.youtube.com/watch?v=PGtv-dBi2wE\n\nhttps://iquilezles.org/articles/normalsSDF/normalsSDF.htm\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","normals"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Surface Normal computation. Visualized in world space.\n// Taken from Ray Marching for Dummies\n// https://www.youtube.com/watch?v=PGtv-dBi2wE\n\n// scene description\nconst vec3 CAMERA_POSITION = vec3(0,1,0);\nconst vec3 SPHERE_POSITION = vec3(0, 1, 6);\nconst float SPHERE_RADIUS = 1.;\nconst float PLANE_POSITION_Y = 0.;\n\n// GetDistanceNearestSurface is hard coded for our scene, which is comprised\n// of a plane and a sphere.\n// The plane is axis aligned with the camera and below the camera.\nfloat GetDistanceToNearestSurface(vec3 point)\n{\n    float distanceToSphere = length(point-SPHERE_POSITION)-SPHERE_RADIUS;\n    float distanceToPlane = point.y - PLANE_POSITION_Y;\n    float distanceToNearestSurface = min(distanceToSphere, distanceToPlane);\n    return distanceToNearestSurface;\n}\n\nconst int MAX_STEPS = 50;\nconst float MAX_DIST = 100.;\nconst float SURFACE_DIST = 0.1;\n\n// Ray Marching using a Sphere Trace algorithm.\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float distanceFromOrigin = 0.;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = rayOrigin + distanceFromOrigin * rayDirection;\n        float distanceToScene = GetDistanceToNearestSurface(p);\n        distanceFromOrigin += distanceToScene;\n        bool foundSurface = distanceToScene < SURFACE_DIST;\n        bool exceededMax = distanceFromOrigin > MAX_DIST;\n        if (foundSurface || exceededMax)\n            break;\n    }\n    return distanceFromOrigin;\n}\n\n// Get the normal of the surface at point p.\n// For more information to see how this works, see:\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetSurfaceNormal(vec3 p)\n{\n    float d0 = GetDistanceToNearestSurface(p);\n    const vec2 epsilon = vec2(.0001,0);\n    vec3 d1 = vec3(\n        GetDistanceToNearestSurface(p-epsilon.xyy),\n        GetDistanceToNearestSurface(p-epsilon.yxy),\n        GetDistanceToNearestSurface(p-epsilon.yyx));\n    return normalize(d0 - d1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // uv is the fragCoord with (0,0) in the center of the screen.\n    // The division by minres uses the same scaling on both\n    // axis to avoid distortion. The min is not strictly necessary in\n    // ShaderToy, since the aspect ratio is such that the min\n    // is always iResolution.y.\n    float minres = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - .5*iResolution.xy) / minres;\n    \n    // Camera Model\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n    // Compute Distance\n    vec3 rayOrigin = CAMERA_POSITION;\n    float distanceToSurface = RayMarch(rayOrigin, rayDirection);\n    \n    // Get the surface normal of the point.\n    vec3 pointOnSurface = rayOrigin + rayDirection * distanceToSurface;\n    vec3 surfaceNormal = GetSurfaceNormal(pointOnSurface);\n    \n    // Visualize surfaceNormal. surfaceNormal can point in any direction\n    // but has length one. Map the values from [(-1,-1,-1), (1,1,1)] to\n    // [(0,0,0), (1,1,1)].\n    vec3 visualized = (1. + surfaceNormal) / 2.;\n    \n    // Flip through xyz, x, y, and z visualizations.\n    const float CYCLE_SPEED_HZ = 1.;\n    float v = mod(CYCLE_SPEED_HZ* iTime, 4.) / 4.;\n    if (v > .75)\n    \tfragColor = vec4(visualized, 1);\n    else if (v > .5)\n    \tfragColor = vec4(visualized.xxx, 1);\n    else if (v > .25)\n    \tfragColor = vec4(visualized.yyy, 1);\n    else\n        fragColor = vec4(visualized.zzz, 1);\n}\n","name":"Image","description":"","type":"image"}]}