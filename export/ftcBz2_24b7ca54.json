{"ver":"0.1","info":{"id":"ftcBz2","date":"1663336787","viewed":144,"name":"Sphere Ocean Structure w Effects","username":"jt","description":"Building on [url=https://www.shadertoy.com/view/NlVcWV]Sphere Ocean Basic Structure[/url]\nadded refraction and (specular) reflection.\nUse mouse to rotate camera, lower left corner for demo mode (left border / lower border for partial demo).\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","grid","refraction","water","sphere","voxel","ocean","specular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/ftcBz2\n// Sphere Ocean Structure w Effects (c) 2022 by Jakob Thomsen is licensed under CC BY 4.0\n\n// based on https://www.shadertoy.com/view/NtKcWV Sphere Ocean Basic Structure\n// based on https://www.shadertoy.com/view/NstSR8 Cast Voxels March Sub-Objects\n\n// My attempt of recreating a \"sphere-ocean\" as seen in other shadertoy shaders.\n// Basically animated Worley noise subtracted from a half-space - using DDA (voxel raycasting) for speedup.\n\n// Added refraction and (specular) reflection.\n\n// tags: grid, water, sphere, voxel, ocean, specular, reflection, refraction\n\n//#define BOUNDING_BOX_FROM_DDA // there seems to be no speedup either way (or maybe a little?)\n\n#ifdef BOUNDING_BOX_FROM_DDA\n#else\nvec2 boxIntersection( vec2 ro, vec2 rd, vec2 boxSize ) // https://iquilezles.org/articles/intersectors\n{\n    vec2 m = 1.0/rd;\n    vec2 n = m*ro;\n    vec2 k = abs(m)*boxSize;\n    vec2 t1 = -n - k;\n    vec2 t2 = -n + k;\n    float tN = max( t1.x, t1.y );\n    float tF = min( t2.x, t2.y );\n    if( tN>tF || tF<0.0) return vec2(-1.0);\n    return vec2( tN, tF );\n}\n#endif\n\nfloat opSmoothUnion( float d1, float d2, float k ) // https://iquilezles.org/articles/distfunctions/\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n#define MAX_DIST 1000.0\n\nvec2 hash22(vec2 p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sdSphere(vec3 p, float d) // https://iquilezles.org/articles/distfunctions\n{\n    return length(p) - d;\n}\n\nfloat sdSphereR(ivec2 mapPos, vec3 p, float d)\n{\n    vec2 r = hash22(vec2(mapPos));\n    float c = cos(iTime * r.y + r.x) * 0.5/*tweak*/;\n    float s = sin(iTime * r.y + r.x) * 0.5/*tweak*/;\n    vec3 offset = vec3(c, s, 0.0);\n    return sdSphere(p + offset, d);\n}\n\nfloat sdSphere9(ivec2 mapPos, vec3 p, float r)\n{\n    float d = MAX_DIST;\n    for(int y = -1; y <= +1; y++)\n        for(int x = -1; x <= +1; x++)\n            d = min(d, sdSphereR(mapPos - ivec2(x, y), p + vec3(x, y, 0), r));\n            //d = opSmoothUnion(d, sdSphereR(mapPos - ivec2(x, y), p + vec3(x, y, 0), r), 0.01);\n    return d;\n}\n\nfloat scene(ivec2 mapPos, vec3 p)\n{\n    float pd = p.z; // base plane\n    p -= vec3(mapPos, 0.0);\n    return max(pd, -sdSphere9(mapPos, p, 1.2/*tweak*/));\n}\n\n#define pi 3.1415926\n\nfloat checker(vec3 p)\n{\n    return step(0.0, sin(pi * p.x + pi/2.0)*sin(pi *p.y + pi/2.0)*sin(pi * p.z + pi/2.0));\n}\n\nvec3 sky(vec3 lightdir, vec3 d)\n{\n    //float sun = max(0.0, dot(d,-lightdir)) > 0.99 ? 1.0 : 0.0;\n    float sun = 10.0*smoothstep(0.99, 1.0, 1.0*dot(d, lightdir));\n    float v = 0.5*abs(d.z)+0.5;\n    return sun + vec3(pow(1.0-v,2.0),1.0-v,v); // no particular meaning - just tweaked until it looks skyish\n}\n\nmat2 rotate(float t)\n{\n    return mat2(vec2(cos(t), sin(t)), vec2(-sin(t), cos(t)));\n}\n\n#define EPSILON 0.001\n\n// raymarch subobject\nfloat march(ivec2 mapPos, vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    for(float t = tmin; t < tmax;)\n    {\n        float h = scene(mapPos, ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return MAX_DIST;\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(ivec2 mapPos, vec3 p)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * scene(mapPos, p + k.xyy * h) +\n                     k.yyx * scene(mapPos, p + k.yyx * h) +\n                     k.yxy * scene(mapPos, p + k.yxy * h) +\n                     k.xxx * scene(mapPos, p + k.xxx * h));\n}\n\n// (could also be named process_voxel or process_cell)\nvec4 process_subobject(ivec2 mapPos, vec3 ro, vec3 rd, float tmin, float tmax)\n{\n    float d = march(mapPos, ro, rd, tmin, tmax);\n    vec3 n = normal(mapPos, ro + rd * d);\n\n    d = d < tmax ? d : MAX_DIST; // should not be necessary - just in case...\n    return vec4(n, d);\n}\n\n// https://en.wikipedia.org/wiki/Digital_differential_analyzer_(graphics_algorithm)\n// \"The [voxel] raycasting code is somewhat based around a 2D raycasting tutorial found here:\n//  http://lodev.org/cgtutor/raycasting.html\" (fb39ca4)\n\n#define MAX_RAY_STEPS 32\n\nvec4 intersect_sea(vec3 ro, vec3 rd)\n{\n    vec4 result = vec4(-rd, MAX_DIST); // default: sky sphere\n\n    vec2 deltaDist = 1.0 / abs(rd.xy);\n    ivec2 rayStep = ivec2(sign(rd));\n    ivec2 mapPos = ivec2(floor(ro));\n    vec2 sideDist = (sign(rd.xy) * (vec2(mapPos) - ro.xy) + (sign(rd.xy) * 0.5) + 0.5) * deltaDist;\n#ifdef BOUNDING_BOX_FROM_DDA\n    float tmin = length(vec2(lessThanEqual(sideDist.xy, sideDist.yx)) * sideDist) / length(rd);\n#endif\n    for (int i = 0; i < MAX_RAY_STEPS; i++)\n    //for (int i = min(iFrame,0); i < MAX_RAY_STEPS; i++) // prevent unrolling loop to prevent crash\n    {\n        {\n#ifdef BOUNDING_BOX_FROM_DDA\n            // try to reconstruct far distance to bounding box from DDA:\n            float tmax = length(vec2(lessThanEqual(sideDist.xy, sideDist.yx)) * sideDist) / length(rd); // hopefully this is correct...\n#else\n            // It appears to be safer to just do the box-intersection here (potential for optimization).\n            vec2 bounds = boxIntersection(ro.xy - vec2(mapPos) - 0.5, rd.xy, vec2(0.5)); // bounding box\n            float tmin = bounds.x; float tmax = bounds.y;\n#endif\n            if(min(ro + rd * tmin,ro + rd * tmax).z < .5) // thanks to kastorp for optimization ideas\n            {\n                result = process_subobject(mapPos, ro - 0.5, rd, tmin, tmax);\n                if(rd.z >.0)\n                    break;\n            }\n#ifdef BOUNDING_BOX_FROM_DDA\n            tmin = tmax;\n#endif\n            if(result.w > 0.0 && result.w < MAX_DIST)\n            {\n                break;\n            }\n        }\n        // Core of https://www.shadertoy.com/view/4dX3zl Branchless Voxel Raycasting\n        bvec2 mask = lessThanEqual(sideDist.xy, sideDist.yx);\n        sideDist += vec2(mask) * deltaDist;\n        mapPos += ivec2(vec2(mask)) * rayStep;\n    }\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //float t = iTime * 0.01;\n    float t = iTime * 0.02;\n    vec2 ndc = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n    vec2 m;\n    m.x = iMouse.x <= 10. // click in lower left corner...\n           ? pi * 2.0 * fract(t) // ...for demo mode\n           : pi * 2.0 * iMouse.x / iResolution.x; // mouse look\n    m.y = iMouse.y <= 10. // click in lower left corner...\n           ? pi * (0.75 - 0.25 * cos(4.0 * t * pi)) // ...for demo mode\n           : pi * (0.5 + 0.5 * iMouse.y / iResolution.y); // mouse look\n\n    mat2 R = mat2(cos(m.x), sin(m.x), -sin(m.x), cos(m.x));\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    mat2 S = mat2(cos(m.y), sin(m.y), -sin(m.y), cos(m.y));\n    ro.yz = S * ro.yz;\n    ro.xy = R * ro.xy;\n    ro.z += 0.0;\n\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz = S * rd.yz;\n    rd.xy = R * rd.xy;\n\n    vec4 result = intersect_sea(ro, rd);\n\n    //vec3 lightdir = vec3(0.0, 1.0, 0.0);\n    //vec3 lightdir = normalize(vec3(0.0,-1.0, 0.25));\n    vec3 lightdir = normalize(vec3(0.0,-1.0, 0.5));\n    //vec3 lightdir = vec3(0.0, 0.0, 1.0);\n    //vec3 lightdir = normalize(vec3(3.0, 2.0, 1.0));\n    vec3 color = vec3(0.0);\n    if(result.w > 0.0 && result.w < MAX_DIST)\n    {\n        color = vec3(1.0);\n\n        vec3 dst = ro + rd * result.w;\n        vec3 n = result.xyz;\n\n        vec3 refraction = vec3(0.0);\n        {\n            vec3 rd2 = refract(rd, n, 1.0/1.5); // refract: last parameter is air index / water index?\n            float t = (-2.0-dst.z)/rd2.z; // intersection with ground plane\n            vec3 dst2 = t * rd2 + dst;\n            refraction = vec3(0.5 + 0.5 * checker(dst2));\n            //refraction = vec3(0.0);\n            //refraction = vec3(0.0,0.0,0.5);\n        }\n\n        vec3 reflection = vec3(0.0);\n        {\n            vec3 rd2 = reflect(rd, n);\n            reflection = sky(lightdir, rd2);\n        }\n\n        //color = refraction + reflection;\n        color = mix(reflection, refraction, pow(abs(rd.z), 2.0)); // pow used get a bit more reflections\n\n        vec3 ambient = vec3(0.1);\n        color *= mix(ambient, vec3(1.0), clamp(dot(lightdir, result.xyz), 0.0, 1.0));\n        \n        vec3 h = normalize(-rd + lightdir);\n        float specular = pow(max(dot(n, h), 0.0), 100.0/*shininess*/);\n        color += specular;\n    }\n    else\n    {\n        color = sky(lightdir, rd);\n    }\n\n    //vec3 fogcolor = vec3(0.25, 0.4, 0.5); // fog\n    //color *= mix(fogcolor, color, exp(-result.w * result.w / 200.0)); // fog for depth impression & to suppress flickering\n\n    fragColor.rgb = sqrt(color);\n}\n","name":"Image","description":"","type":"image"}]}