{"ver":"0.1","info":{"id":"csKBzG","date":"1698396455","viewed":36,"name":"Floating Pyramid","username":"smlk0","description":"getting used to shaders","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float distance_to_hit(vec3 point) {\n\n    point.xy = rotation_2d(point.xy, sin(iTime*0.3) + cos(iTime*0.4));\n    point.zx = rotation_2d(point.zx, iTime * 0.2);\n\treturn sdf_pyramid(point)*0.5;\n}\n\nvec3 calculate_normal(vec3 point, float current_distance) {\n\n\tconst float epsilon = 0.001;\n\t\n\tfloat gradient_x =\n\tcurrent_distance - distance_to_hit(vec3(point.x - epsilon, point.y, point.z));\n\tfloat gradient_y =\n\tcurrent_distance - distance_to_hit(vec3(point.x, point.y - epsilon, point.z));\n\tfloat gradient_z =\n\tcurrent_distance - distance_to_hit(vec3(point.x, point.y, point.z - epsilon));\n\t\n\treturn normalize(vec3(gradient_x, gradient_y, gradient_z));\n}\n\nconst vec3 directional_light = vec3(0.0, 0.0, -0.5);\nfloat light_distance = 5.0;\n\nint max_steps = 100;\nfloat max_distance = 100.0;\nfloat tolerance = 0.0001;\n\nvec3 ray_march(vec3 origin, vec3 direction, vec2 uv) {\n\t\n\tfloat total_distance = 0.0;\n\t\n\tfor (int i = 0; i < max_steps; ++i) {\n\t\t\n\t\tvec3 current_position = origin + total_distance * direction;\n\t\tfloat current_distance = distance_to_hit(current_position);\n\t\t\n\t\tif (current_distance < tolerance) {\n\t\t\t\n\t\t\tvec3 normal = calculate_normal(current_position, current_distance);\n            float period = (sin(iTime * PI - 3.0) + 1.0) * 0.5;\n\t\t\tvec3 color = RED * dot(normal, directional_light * period);\n\t\t\t\n\t\t\treturn color;\n\t\t}\n\t\t\n\t\tif (total_distance > max_distance) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotal_distance += current_distance;\n\t}\n    \n    float intensity = 0.0;\n    \n    float time_fraction = fract(iTime);\n    \n    int max_triangles = 3;\n    float time_scale = 0.5;\n    float triangle_spacing = 9.0;\n    \n    \n    for(int counter = 0; counter < max_triangles; counter++) {\n        \n        \n        float size = fract((iTime * time_scale + float(counter)) * (1.0/float(max_triangles))) * triangle_spacing;\n        intensity += glow(sdf_triangle(uv, size)) * (size * 0.5);\n    }\n\t\n\treturn RED * intensity;\n}\n\nfloat uv_plane_distance = 1.0;\nvec3 camera_position = vec3(0.0, 0.0, -2.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = center_uv(fragCoord, iResolution.xy);\n    \n\tvec3 camera_ray_direction = vec3(uv, uv_plane_distance);\n\t\n\tfragColor = vec4(ray_march(camera_position, camera_ray_direction, uv), 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const vec3 BLACK = vec3(0.0, 0.0, 0.0);\nconst vec3 RED = vec3(1.0, 0.0, 0.0);\nconst float PI = 3.1415926;\n\nvec2 center_uv(vec2 original_uv, vec2 resolution) {\n   \n   return (original_uv * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n}\n\nvec2 rotation_2d(vec2 point, float angle) {\n\t\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\treturn point * mat2(vec2(c, -s),\n\t\t\t\t\t\tvec2(s, c));\n}\n\nfloat sdf_triangle(vec2 point, float size)\n{\n    point.y -= 0.5;\n    return abs(point.x) + abs(point.y * 1.25 + abs(point.x)) - size;\n}\n\nfloat glow(float value) {\n\n    return 0.085/(0.085 + value * value * 11.0);\n}\n\nfloat sdf_pyramid(vec3 point)\n{\n  vec3 q = abs(point);\n  \n  float prism_straight = max(q.z - 1.0, max(q.x + point.y * 0.5, -point.y) - 0.5);\n  float prism_sideway = max(q.x - 1.0, max(q.z + point.y * 0.5, -point.y) - 0.5);\n  \n  return max(prism_straight, prism_sideway);\n}","name":"Common","description":"","type":"common"}]}