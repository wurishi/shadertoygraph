{"ver":"0.1","info":{"id":"lttczf","date":"1533569117","viewed":473,"name":"Bilinear warping","username":"lycium","description":"test of bilinear distribution sampling.","likes":10,"published":3,"flags":0,"usePreview":0,"tags":["warping","sampling","distribution"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float warp1d(float x, float a, float b)\n{\n    float s = b - a;\n    if (abs(s) < 2e-5) return x; // check for flat distribution\n\n\tfloat D = a*a + (b*b - a*a) * x;\n\treturn (sqrt(max(0.0, D)) - a) / s; // max with 0 to prevent -ve sqrt\n}\n\n// Data points are arranged as follows:\n//\n// a -- b\n// |    |\n// c -- d\n//\n// p_in is a point in [0,1] to be warped to this bilinear distribution.\nvec2 warp2d(vec2 p_in, float a, float b, float c, float d)\n{\n\tfloat y = warp1d(p_in.y, a + b, c + d);\n\n\tfloat x0 = a + (c - a) * y;\n\tfloat x1 = b + (d - b) * y;\n\tfloat x = warp1d(p_in.x, x0, x1);\n\n\treturn vec2(x, y);\n}\n\nfloat sint(float a, float b) { float v = sin(iTime * 0.1 * a + b); return 1.0 - v * v; }\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 pixel_scale = vec2(1.0 / iResolution.x, -aspect / iResolution.y) * 2.0;\n\tvec2 pixel = (fragCoord - iResolution.xy * 0.5) * pixel_scale;\n\n\tfloat pixel_bright = 0.0;\n    \n    if (pixel.x < -0.5 || pixel.x >= 0.5 ||\n\t\tpixel.y < -0.5 || pixel.y >= 0.5)\n    {\n        pixel_bright += 0.0125;\n    }\n    else\n    {\n        float a = sint(5.4534, 1.421); float b = sint(9.9531, 0.492);\n        float c = sint(7.1511, 1.119); float d = sint(2.3593, 1.122);\n\n        const float samples = float(144);\n        const float norm = 1.0 / samples;\n        for (float z = 0.0; z < samples; z += 1.0)\n        {\n            float x = (z + 0.5) * norm;\n            float y = mod(x * 89.0, 1.0);\n            vec2 u = vec2(x, y);\n\n            vec2 warped = warp2d(u, a, b, c, d);\n\n            vec2 d = (warped - 0.5) - pixel;\n            float thresh = 0.000081;\n            float falloff = 0.00003;\n            pixel_bright += smoothstep(thresh, thresh - falloff, dot(d, d));\n        }\n    }\n\n\tvec3 colour_sRGB = vec3(sqrt(pixel_bright));\n    fragColor = vec4(colour_sRGB, 1.0);\n}","name":"Image","description":"","type":"image"}]}