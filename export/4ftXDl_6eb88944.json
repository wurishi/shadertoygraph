{"ver":"0.1","info":{"id":"4ftXDl","date":"1714625432","viewed":56,"name":"i don't want him to be kinky","username":"floopfloop","description":"how do i make him not kinky","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HES_KINKY 1\n\n#define SHAPE_BOX 0.0\n#define SHAPE_SPHERE 1.0\nstruct curve_control_point_t {\n    vec2 position;\n    float radius;\n    float shape; // square: 0 -> circle: 1\n    vec3 color;\n};\n\nstruct curve_t {\n    curve_control_point_t start;\n    curve_control_point_t control;\n    curve_control_point_t end;\n};\n\n// cubic polynomial\nfloat smin( float a, float b, float k ) {\n    k *= 6.0;\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}\n\n// s = side length\n// r = corner radius\nfloat sdf_round_square( in vec2 p, in float s, in float r ) {\n    vec2 q = abs(p)-s+r;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat remap(float value, float low1, float high1, float low2, float high2) {\n    return low2 + (high2 - low2) * ((value - low1) / (high1 - low1));\n}\n\n// Convenient implementation of cubic polynomial solver\n// https://www.shadertoy.com/view/ltXSDB by Adam Simmons, T21 and others\n// Additionally: returns number of roots\nvec4 solve_cubic(float a, float b, float c)\n{\n    float p = b - a*a / 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n    float d = q*q + 4.0*p3 / 27.0;\n    float offset = -a / 3.0;\n    if(d >= 0.) {\n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        return vec4(vec3(offset + uv.x + uv.y), 1.0);\n    }\n    float v = acos(-sqrt(-27.0 / p3) * q / 2.0) / 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec4(vec3(m + m, -n - m, n - m) * sqrt(-p / 3.0) + offset, 3.0);\n}\n\n// returns distance and t\n// adapted from https://www.shadertoy.com/view/MdXBzB\nfloat sdf_curve(in vec2 point, curve_t curve, out vec3 color) {\n    // This is to prevent 3 colinear points, but there should be better solution to it.\n    curve.control.position = mix(curve.control.position + vec2(1e-4), curve.control.position, abs(sign(curve.control.position * 2.0 - curve.start.position - curve.end.position)));\n\n    // calculate t and roots (nearest points on bezier). (note: 3rd root is unnecessary)\n    vec4 t; vec2 point1; vec2 point2;\n    {\n        vec2 a = curve.control.position - curve.start.position;\n        vec2 b = curve.start.position - curve.control.position * 2.0 + curve.end.position;\n        vec2 c = a * 2.0;\n        vec2 d = curve.start.position - point;\n        vec3 k = vec3(3.*dot(a,b), 2.0*dot(a,a) + dot(d,b), dot(d,a))/dot(b,b);\n        vec4 sc = solve_cubic(k.x, k.y, k.z);\n        t = vec4(clamp(sc.xyz, 0.0, 1.0), sc.w);\n        point1 = d + (c + b*t.x)*t.x;\n        point2 = d + (c + b*t.y)*t.y;\n    }\n\n    float radius1 = mix(curve.start.radius, curve.end.radius, t.x);\n    float radius2 = mix(curve.start.radius, curve.end.radius, t.y);\n\n    float dist1 = sdf_round_square(point1, radius1, remap(mix(curve.start.shape, curve.end.shape, t.x), 0.0, 1.0, 0.7, 1.0)*radius1);\n    float dist2 = sdf_round_square(point2, radius2, remap(mix(curve.start.shape, curve.end.shape, t.y), 0.0, 1.0, 0.7, 1.0)*radius2);\n\n    vec3 color1 = mix(curve.start.color, curve.end.color, t.x);\n    vec3 color2 = mix(curve.start.color, curve.end.color, t.y);\n    \n    #if HES_KINKY\n        float dist = (dist1 < dist2) ? dist1 : dist2;\n        color = (dist1 < dist2) ? color1 : color2;\n    #else\n        // imagine him but not kinky\n    #endif\n\n    return dist;\n}\n\nvoid mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 canvas_resolution = iResolution.xy;\n    float frame_count = iTime;\n    \n    vec2 p = (2.0*frag_coord-iResolution.xy)/iResolution.y;\n\n    curve_t curve = curve_t(\n        curve_control_point_t(\n            vec2(-0.5, 0.0),\n            0.25,\n            SHAPE_SPHERE,\n            vec3(1.0, 0.0, 0.0)\n        ),\n        curve_control_point_t(\n            vec2(0.0),\n            0.15,\n            SHAPE_SPHERE,\n            vec3(0.0, 0.0, 1.0)\n        ),\n        curve_control_point_t(\n            vec2(0.5*cos(frame_count), 0.5*sin(frame_count)),\n            0.15,\n            SHAPE_SPHERE,\n            vec3(0.0, 1.0, 0.0)\n        )\n    );\n    vec3 background_color = vec3(1.0);\n    frag_color = vec4(background_color, 1.0);\n    \n    vec3 curve_color;\n    float sdf = sdf_curve(p, curve, curve_color);\n    frag_color = mix(frag_color, vec4(curve_color, 1.0), smoothstep(1.5, -1.5, canvas_resolution.y * sdf));\n}","name":"Image","description":"","type":"image"}]}