{"ver":"0.1","info":{"id":"tdsGDj","date":"1547563480","viewed":616,"name":"Quadratic Bezier as Parabola","username":"astiopin","description":"Calculation of arc length and distance to a quadratic Bezier curve by converting it to a parabolic segment.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","bezier"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://astiopin.github.io/2019/01/04/qbez-parabola.html\n\n// Parabolic segment parameters\nmat2  pmat;    // Basis (unscaled)\nvec2  xlimits; // Starting and ending points\nvec2  vertex;  // Vertex coordinates\nfloat pscale;  // Basis scale\n\nvoid qbezierToParabola( in vec2 p0, in vec2 p1, in vec2 p2 ) \n{\n    vec2  pc = mix( p0, p2, 0.5f );\n    float d = dot( normalize( p0 - p1 ), normalize( p2 - p1 ) );\n    float dmax = 1.0 - 1e-6f;\n    \n    // One or two line segments\n    if ( d >= dmax || d <= -dmax ) { \n        float prec    = 0.000001;\n        vec2   xaxis  = normalize( p2 - p0 );\n        float  ldir   = length( p2 - p0 );\n        vec2   yaxis  = vec2( -xaxis.y, xaxis.x );\n        float  ylen   = ldir * prec;\n        float  xlen   = sqrt( prec );\n\t\t\n        vertex  = pc + ylen * yaxis;\n        xlimits = vec2( -xlen, xlen );\n        pscale  = 0.5f * ldir / xlen;\n        pmat    = mat2( xaxis, yaxis );\n\n        return;\n    }\n    \n    // Parabolic segment\n    \n    vec2 yaxis = normalize( pc - p1 );\n    vec2 xaxis = vec2( yaxis.y, -yaxis.x );\n\n    vec2 p01 = normalize( p1 - p0 );\n    vec2 p12 = normalize( p2 - p1 );\n    float cx0 = dot( xaxis, p01 );\n    float sx0 = dot( yaxis, p01 );\n    float cx2 = dot( xaxis, p12 );\n    float sx2 = dot( yaxis, p12 );\n\n    float x0 = sx0 / cx0 * 0.5;\n    float x2 = sx2 / cx2 * 0.5;\n    float y0 = x0*x0;\n\n    float p02x = dot( p2 - p0, xaxis );\n    pscale = p02x / ( x2 - x0 );\n    vertex = p0 - vec2( y0 * pscale ) * yaxis - vec2( x0 * pscale ) * xaxis;\n    pmat   = mat2( xaxis, yaxis );\n\t\n    if ( x0 < x2 ) {\n        xlimits = vec2( x0, x2 );\n    } else {\n        xlimits = vec2( x2, x0 );\n    }\n}\n\nvec2 worldToParabolaSpace( in vec2 pos ) {\n    float  is   = 1.0 / pscale;\n    vec2   dpos = pos - vertex;\n    vec2   r0 = dpos * pmat[0];\n    vec2   r1 = dpos * pmat[1];\n    float  v0 = is * ( r0.x + r0.y );\n    float  v1 = is * ( r1.x + r1.y );\n    return vec2( v0, v1 );\n}\n\n\nvoid nearestPointOnParabola( vec2 ppos, out float res_x, out float res_dist ) {\n    float p = 0.5 - ppos.y;\n    float q = -0.5 * ppos.x;\n    \n    // Solving  x^3 + p*x + q = 0\n\n    float sigx = ppos.x > 0.0 ? 1.0 : -1.0;\n    float sq = 27.0*q*q;\n    float cp = 4.0*p*p*p;\n    float tp = -p * 0.33333333;\n\n    if ( sq >= -cp ) {\n        // Point below evolute - single root        \n        float a = pow( 0.5 * ( abs( q ) + sqrt( ( sq + cp ) / 27.0 ) ), 0.33333333 );\n        float x0 = sigx * ( a + tp / a );\n        float cx0 = clamp( x0, xlimits.x, xlimits.y );\n        \n        res_x     = cx0;\n        res_dist  = length( vec2( cx0, cx0*cx0 ) - ppos );\n    } else {\n        // Point above evolute - three roots\n\n        float a2   = abs( sq / cp );\n        float a    = sqrt( a2 ); \n\n        // Exact solution\n        // float dacs = 2.0 * cos( acos( a ) / 3.0 );\n        \n        // Approximation with cubic\n        float dacs = a2 * ( 0.01875324 * a - 0.08179158 ) + ( 0.33098754 * a + 1.7320508 );\n\n        float rsp = sqrt( abs( tp ) );\n        float x0 = sigx * rsp * dacs;\n        \n        // Vietta's method for second root\n        float dx = sigx * sqrt( -0.75 * x0*x0 - p );\n        float x1 = -0.5 * x0 - dx;\n\n        //Third root is never the closest\n        //float x2 = -0.5 * x0 + dx;        \n\n        float cx0 = clamp( x0, xlimits.x, xlimits.y );        \n        float cx1 = clamp( x1, xlimits.x, xlimits.y );\n\t\t\n        vec2 ddir0 = vec2( cx0, cx0*cx0 ) - ppos;\n        vec2 ddir1 = vec2( cx1, cx1*cx1 ) - ppos;\n        float sd0 = dot( ddir0, ddir0 );\n        float sd1 = dot( ddir1, ddir1 );\n\t\t\n\t\tres_x    = sd0 < sd1 ? cx0 : cx1;\n        res_dist = sd0 < sd1 ? sqrt( sd0 ) : sqrt( sd1 );\n    }\t\n}\n\nfloat parabolaArclen( float x ) {\n    float ax = abs( x );\n    float sq = sqrt( 4.0*ax*ax + 1.0 );\n    return sign( x ) * ( 0.25 * log( 2.0 * ax + sq ) + 0.5 * ax * sq ); \n}\n\nfloat cross2d( vec2 a, vec2 b ) {\n \treturn a.x * b.y - a.y * b.x;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 xy = fragCoord.xy;\n\t\n    // Quadratic Bezier control points\n\tvec2 p0 = vec2( 0.25, 0.5 ) * iResolution.xy;\n    vec2 p1 = iMouse.xy;\n\tvec2 p2 = vec2( 0.75, 0.5) * iResolution.xy;\n    bool winding = cross2d( p0 - p1, p2 - p1 ) > 0.0;\n    \n    // Parabola parameters calculation\n    // Better be done on the CPU\n    qbezierToParabola( p0, p1, p2 );\n    vec2 par_pos = worldToParabolaSpace( xy );\n    \n\tfloat px;    // Nearest point on the parabola\n    float pdist; // Distance to it\n    nearestPointOnParabola( par_pos, px, pdist );\n    \n    // Arc length calculation\n    float l0 = parabolaArclen( xlimits.x );\n    float l1 = parabolaArclen( xlimits.y );\n    float lx = parabolaArclen( px );\n    float lt = clamp( ( lx - l0 ) / ( l1 - l0 ), 0.0, 1.0 );\n    lt = winding ? 1.0 - lt : lt;\n    \n    // Fast and dirty variable width (incorrect near the evolute)\n    float width0 = iResolution.y * 0.2;\n    float width1 = width0 * 0.3;\n    float width = mix( width0, width1, lt ); \n    \n    float rd = pdist * pscale;\n    float dgrad = rd / width;\n    \n    float alpha  = clamp( width - rd, -0.5, 0.5 ) + 0.5;\n    \n\tvec3  color  = vec3( 0.5, lt, dgrad );\n    vec3  bg     = vec3( 0.3, 0.3, 0.3 );\n    \n    fragColor = vec4( mix( bg, color, alpha ), 1.0 );\n}","name":"Image","description":"","type":"image"}]}