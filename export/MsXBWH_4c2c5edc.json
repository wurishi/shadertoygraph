{"ver":"0.1","info":{"id":"MsXBWH","date":"1495895653","viewed":203,"name":"SDF animation fun","username":"wutzhuhn","description":"The shape is built with a signed distance field and its parts are moved and scaled with time. Then some normal and light calculations are applied for the looks.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","animation","signeddistancefield","normalmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14\n#define roundnes 0.025\n\nfloat animationTime = 1.0;\n\nfloat merge(float a, float b) {\n\treturn max(min(a, b), roundnes) - length(max(vec2(roundnes) - vec2(a, b), vec2(0.0)));\n}\n\nfloat subtract(float a, float b) {\n\treturn min(max(a, -b), -roundnes) + length(max(vec2(roundnes) + vec2(a, -b), vec2(0.0)));\n}\n\nfloat intersect(float a, float b) {\n\treturn min(max(a, b), -roundnes) + length(max(vec2(roundnes) + vec2(a, b), vec2(0.0)));\n}\n\nvec2 rotate(vec2 p, float a) {\n    float sa = sin(a), ca = cos(a);\n\treturn p * mat2(ca, -sa, sa, ca);\n}\n\nfloat circle(vec2 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat box(vec2 p, vec2 size) {\n\tvec2 d = abs(p) - size + roundnes;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - roundnes;\n}\n\nfloat shapeDist(vec2 p) {\n    return\n      subtract(\n        intersect(\n          merge(\n            circle(p, 1.0),\n            min(min(\n              box(rotate(p,  PI / 6.0), vec2(0.125, 1.25 * (1.0 - animationTime))),\n              box(rotate(p, -PI / 6.0), vec2(0.125, 1.25 * (1.0 - animationTime)))),\n              box(p, vec2(0.125, 1.25 * (1.0 - animationTime))))),\n          circle(p + vec2(0.0, 1.25), 1.0)),\n        circle(p + vec2(0.0, 0.625 * animationTime), 0.75 - 0.6 * animationTime));\n}\n\nfloat maskSharp(vec2 p) {\n    return clamp(shapeDist(p - vec2(0.0, 0.5 - 0.25 * animationTime)) * 400.0, 0.0, 1.0);\n}\n\nfloat maskBlurry(vec2 p) {\n    return clamp((shapeDist(p - vec2(0.0, 0.5 - 0.25 * animationTime)) + 0.003) * 75.0, 0.0, 1.0);\n}\n\nvec3 normalAt(vec2 p) {\n    float ps = 1.0 / iResolution.x;\n    float x = maskBlurry(p - vec2( ps, 0.0)) - maskBlurry(p + vec2( ps, 0.0));\n    float y = maskBlurry(p - vec2(0.0,  ps)) - maskBlurry(p + vec2(0.0,  ps));\n    return normalize(vec3(x, y, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec2 p = fragCoord * 2.0 / iResolution.xx - 1.0;\n    \n    animationTime = sin(iTime / 5.0) * 0.5 + 0.5;\n\n    vec3 lightPos = vec3(0.0, -animationTime, 1.0);\n    vec3 toLight = lightPos - vec3(p, 0.0);\n    vec3 normal = normalAt(p);\n    float shade = 0.3 + maskSharp(p) * 0.7;\n    vec3 color = vec3(clamp(dot(normalize(toLight), normal), 0.0, 1.0) / length(toLight)) * shade;\n\n\tfragColor = vec4(color + texture(iChannel0, fragCoord).r * 2.0 - 1.0, 1.0);\n}","name":"Image","description":"","type":"image"}]}