{"ver":"0.1","info":{"id":"dslGDM","date":"1666249687","viewed":102,"name":"Pixel extrusion","username":"Envy24","description":"Hold LMB and drag to change pixel size.\n\nBased on this shader:\nhttps://www.shadertoy.com/view/Dsl3Rn","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["pixelization","extrusion"],"hasliked":0,"parentid":"DslGzn","parentname":"Temporal blur __"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 grad(vec2 TC, float d)\n{\n    vec2 delta = vec2(d, 0);\n    return \n        vec2(TEX0(TC + delta.xy).x - TEX0(TC - delta.xy).x,\n             TEX0(TC + delta.yx).x - TEX0(TC - delta.yx).x);\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    /*Calculate diffuse light.*/\n    vec3 light_dir = normalize(vec3(1,-1,1));\n    vec2 gradient = grad(TO_TEX_COORDS(SC), 0.5/R.y);    \n    vec3 normal = normalize(vec3(gradient, 1.0));\n    float diffuse = dot(normal, light_dir);\n    /**/\n    float saturation = 3.;  \n    vec3 color = mix(vec3(0.5), vec3(0.6,0.7,0), TEXF0(SC).rgb * saturation);  \n    \n    O = vec4(color * diffuse, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, in vec2 SC )\n{\n    float pixel_size = 25.;\n    SC = PIXELATE(SC);\n    O = vec4( hash1to1(uint(SC.y * R.y + SC.x + iTime*0.5)) < 0.1 );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R                         ( iResolution )\n#define AR                        ( R.x / R.y )\n#define UNIT                      ( 2.0 / R.y )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n#define PIXEL_SIZE                ( LMB_IS_HOLD ? floor(iMouse.y / (R.y / 40.)) : 8. )\n#define PIXELATE(SC)              ( floor( (SC) / (PIXEL_SIZE) ) * (PIXEL_SIZE) )\n#define TEX0(TC)                  ( texture(iChannel0, (TC)) )\n#define TEXF0(SC)                 ( texelFetch(iChannel0, ivec2(PIXELATE(SC)), 0) )  // (channel, integer coordinates, mipmap level)\n#define TO_TEX_COORDS(SC)         ( (SC) / (R.xy) )                        // in range x=[0.0; 1.0], y=[0.0; 1.0]\n\n/*  \n    Returns hash in range [0.0; 1.0].\n*/\nfloat hash1to1(uint value)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint entropy0 = 12345u;\n    const uint entropy1 = 67890u;\n\n    // Calculate hash.\n\tvalue += entropy1;\n\tvalue *= 445593459u;\n\tvalue ^= entropy0;\n\n    // 1.0f / 4294967295.0f = 2.32830644e-10\n    \n    return float(value * value * value) * 2.32830644e-10;\n}","name":"Common","description":"","type":"common"}]}