{"ver":"0.1","info":{"id":"7lBBR3","date":"1652481394","viewed":2834,"name":"Normal Mapping Shadows (NMS)","username":"BorisVorontsov","description":"Normal Mapping Shadow effect implementation. Cast shadow using just normal map and no height data.","likes":47,"published":1,"flags":32,"usePreview":1,"tags":["shadow","normalmap","normal","nms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Normal Mapping Shadow (NMS)\n// Based on paper http://enbdev.com/doc_normalmappingshadows.htm\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define iSampleCount\t\t\t15\n#define SampleCount\t\t\t\t(float(iSampleCount))\n#define HeightScale\t\t\t\t1.5\n#define ShadowHardness\t\t\t2.0\n#define ShadowLength\t\t\t0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3\tlightposition = vec3(0.0, 0.0, 0.1);\n\tvec3\tplaneposition = vec3(fragCoord.xy / iResolution.y, 0.0);\n\n\tvec2\tcursorposition = iMouse.xy / iResolution.y;\n\tlightposition.xy = cursorposition;\n\tif (iMouse.z <= 0.0)\n\t{\n\t\tlightposition.x = (sin(iTime * 1.0) + 1.0);\n\t\tlightposition.y = (cos(iTime * 2.5) + 1.0);\n\t}\n\n\tfloat\tsamplecount = SampleCount;\n\tfloat\tinvsamplecount = 1.0 / samplecount;\n\n\tfloat\thardness = HeightScale * ShadowHardness;\n\n\tvec3\tlightdir = lightposition - planeposition;\n\n\tvec2\tdir = lightdir.xy * HeightScale;\n\n\tlightdir = normalize(lightdir.xyz);\n\n\tvec2\tuv = fract(fragCoord.xy / iResolution.y);\n\tvec3\tnormal = texture(iChannel0, uv).xyz;\n\tnormal = normal * 2.0 - 1.0;\n\n\t//lighting with flat normals (from vertex or depth generated)\n\tfloat\tlighting = clamp(dot(lightdir, normal), 0.0, 1.0);\n\n\tfloat\tstep = invsamplecount * ShadowLength;\n\n\t//randomization\n\tvec2\tnoise = fract(fragCoord.xy * 0.5);\n\tnoise.x = (noise.x*0.5 + noise.y)*(1.0/1.5 - 0.25);\n\n\tfloat\tpos = step * noise.x;\n\n\t//do not compute on back faces/pixels //disabled cause while() not supported in Shadertoy\n\t//pos = (-lighting >= 0.0) ? 1.001 : pos;\n\n\tfloat\tslope = -lighting;\n\tfloat\tmaxslope = 0.0;\n\tfloat\tshadow = 0.0;\n\tfor (int i=0; i<iSampleCount; i++)\n\t{\n\t\tvec3\ttmpNormal = texture(iChannel0, uv + dir * pos).xyz;\n\t\ttmpNormal = tmpNormal * 2.0 - 1.0;\n\n\t\tfloat\ttmpLighting = dot(lightdir, tmpNormal);\n\n\t\tfloat\tshadowed = -tmpLighting;\n\n\t\t//for g-buffer normals of deferred render insert here depth comparison to occlude objects, abstract code example:\n\t\t//vec2\tcropminmax = clamp(1.0 - (depth - tmpDepth) * vec2(4000.0, -600.0), 0.0, 1.0);\n\t\t//cropminmax.x = cropminmax.x * cropminmax.y;\n\t\t//shadowed *= cropminmax.x;\n\n\t\tslope += shadowed;\n\n\t\t//if (slope > 0.0) //cheap, but not correct, suitable for hard shadow with early exit\n\t\tif (slope > maxslope) //more suitable for calculating soft shadows by distance or/and angle\n\t\t{\n\t\t\tshadow += hardness * (1.0-pos);\n\t\t}\n\t\tmaxslope = max(maxslope, slope);\n\n\t\tpos += step;\n\t}\n\n\tshadow = clamp(1.0 - shadow * invsamplecount, 0.0, 1.0);\n\n\t//disable shadow on click\n\t//if (iMouse.w > 0.0) shadow = 1.0;\n\n\t//coloring\n\tvec3\tambientcolor = vec3(0.15, 0.4, 0.6) * 0.7;\n\tvec3\tlightcolor = vec3(1.0, 0.7, 0.3) * 1.2;\n\tfloat\tao = clamp(normal.z, 0.0, 1.0);\n\tfragColor.xyz = shadow * lighting * lightcolor;\n    //v1\n\t//fragColor.xyz+= ambientcolor * (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5);\n    //v2\n\tfragColor.xyz+= ambientcolor;\n\tfragColor.xyz*= (clamp(normal.z, 0.0, 1.0) * 0.5 + 0.5); //kinda diffuse\n\tfragColor.w = 1.0;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n// Prepass generates normal map from picture\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++\n#define invNormalMapScale\t\t5.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tuv;\n\tvec2\toffset;\n\tvec3\tnormal;\n\tvec3\theight;\n\toffset = 1.0 / iResolution.xy;\n\tuv = fract(fragCoord.xy / iResolution.xy);\n\theight.x = texture(iChannel0, uv).x;\n\theight.y = texture(iChannel0, uv + vec2(offset.x, 0.0)).x;\n\theight.z = texture(iChannel0, uv + vec2(0.0, offset.y)).x;\n\tnormal.xy = (height.x - height.yz);\n\tnormal.xy /= offset;\n\tnormal.z = invNormalMapScale;\n\tnormal = normalize(normal);\n\tnormal = normal * 0.5 + 0.5;\n\tfragColor = vec4(normal, 1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"}]}