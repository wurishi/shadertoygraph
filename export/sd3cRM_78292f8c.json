{"ver":"0.1","info":{"id":"sd3cRM","date":"1653151325","viewed":297,"name":"mecanical screens","username":"FabriceNeyret2","description":"Pixels flap with image intensity.\nmouse controls camera\nreference: http://zarfoubo.blogspot.com/2007/11/etranges-miroirs-et-drole-decrans.html","likes":15,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","short","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// variant of https://shadertoy.com/view/7d3yRM\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation                  \n\nvoid mainImage_(out vec4 O, vec2 U)\n{\n    float t=9.; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),         // ray direction\n          p = 60./R, q,a,                                 // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(15,5,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(-6.*M.y),                             // rotations\n        q.xz *= rot(-6.*M.x);\n        a = abs(q);\n        if ( q.z < -1. ) { O-=O;  break; }\n        if ( a.z<2. && max(a.x,a.y) > 15. ) continue;\n        for(int i=0; i<4; i++) \n          a = q,\n          a.xy = fract(a.xy) - vec2(i%2,i/2),\n          a.xz *= rot(1.57-1.57*texture(iChannel0,round(q.xy)/30.+.5,0.).r ),\n          a = abs(a),\n          t = min(t, max(max(a.x-.4,a.y-.45),a.z-.02) ); \n          \n       p += .5*t*D;                                       // step forward = dist to obj          \n   }\n  O*=O*O*2.;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U)                        // --- smart oversampling\n{\n    mainImage_(O,U);\n    if ( fwidth(O.x) > .1 ) {\n        vec4 O_; \n        for(int i=0; i<9; i+=i==3?2:1) {\n            mainImage_(O_,U+vec2(i%3-1,i/3-1)/3. );\n            O += O_;\n        }\n        O /= 9.;  // O.r++;   // uncomment to see oversampled pixels\n    }\n}","name":"Image","description":"","type":"image"}]}