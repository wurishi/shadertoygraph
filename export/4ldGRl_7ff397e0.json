{"ver":"0.1","info":{"id":"4ldGRl","date":"1470895290","viewed":181,"name":"float Pack diff multiPass","username":"kuranes","description":"Click and Drag to change vizualizations areas.\n\nClear and simple code demonstrating error by diffing.\nEncode in one buffer / decode in another\n\n(now keep in mind that output being 8bits, it's hard to visualize error)","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["utility","pack","unpack","diff","flaot","halffloat"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// encode in one buffer / decode in another\n// no more simulation, but buffer is float, so still not the real thing\n// (need 8bits RTT for exact test)\n\n// DIFF * 10 000.0 of various pack/unpack float code\nconst float diffy = 10000000.0;\n\n// uncomment to check 0 to 1 from lower left to top right\n// so that error zone spread are clear\n// but don't forget to maximize the \"viewport\" you're checking\n//#define CHECK_ERROR_SPREAD\n// want to test [0, 1] ?\n//#define RANGE_BOUND_ONE_INCLUDED\n\n// single pass version here https://www.shadertoy.com/view/ltc3zl\n\n\n// BLACK == no difference\n// WHITE == huge difference\n//\n// A big decision in to do [0, 1[ or [0, 1]\n// here testing [0, 1[\n//\n//-------------------------------------------------------------------------\n// another error graphing tech: https://www.shadertoy.com/view/XssXR4\n\n//-------------------------------------------------------------------------\n// aras_p\n// http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n// w/o the aras typo 255.0*255.0*255.0 != 160581375 it's 16581375\n\nvec4 EncodeFloatRGBA_aras( const in float v ) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n  return enc;\n}\n\nfloat DecodeFloatRGBA_aras(const in vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );\n}\n/// \n\n\n//-------------------------------------------------------------------------\n// the correct one\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/ldj3zG\n// the classic 1-32-bit-float to 4-8-bit-vec4 packing and unpacking functions that \n// have been floating around the internet for 10 years now. Unkown source, but\n// common sense.\n\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\n\nvec4 pack_F1_UB4( const in float value )\n{\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz/256.0;\n\treturn res;\n}\n\nfloat unpack_F1_UB4( const in vec4 value )\n{\n    return dot( value, bitShR );\n}\n\n//-------------------------------------------------------------------------\n// half float precision, when you pack 2-16-bit-float to 4-8-bit-vec4 \n\nvec4 encodeHalfFloatRGBA( const in vec2 v ) {\n    const vec2 bias = vec2(1.0 / 256.0, 0.0);\n    vec4 enc;\n    enc.xy = vec2(v.x, fract(v.x * 256.0));\n    enc.xy = enc.xy - (enc.yy * bias);\n\n    enc.zw = vec2(v.y, fract(v.y * 256.0));\n    enc.zw = enc.zw - (enc.ww * bias);\n    return enc;\n}\n\nvec2 decodeHalfFloatRGBA( const in vec4 rgba ) {\n    \n    return vec2(rgba.x + (rgba.y / 256.0), rgba.z + (rgba.w / 256.0));\n}\n\n//-------------------------------------------------------------------------\n\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\n// packing a float in glsl with multiplication and fract\n// wip  as not clear for now what the blog post is saying\n\n// \"fract is the problem\"\nvec4 packFloat_gradientstudios_problem( const in float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = fract( depth * bit_shift );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\n\n// packing a float in glsl with multiplication and mod\nvec4 packFloat_gradientstudios( float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 255 ) ) / vec4( 255 );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\nfloat unpackFloat_gradientstudios( vec4 depth ) {\n\n\tvec4 bitSh = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(depth, bitSh);\n}\n\n//-------------------------------------------------------------------------\n// the diff code    \n//-------------------------------------------------------------------------\n\n// pa : packed float to 8 bit vec4\n// unpa: ready rgba 8 bits to be unpacke from an 8nit vec4, to a float\t \n// as said above [0,1[ \nvec4 buffer8bits(const in vec4 pa){\n\n   const float bit8 = 256.0;\n     //const float bit8 = 255.0;// to \"test\" [0,1]\n\n    // simulate that we are writing to a 8 bit color buffer\t\n    vec4 buff = floor( bit8*pa );\n    \n    // simulate that we are reading from a 8 bit color buffer\n    vec4 unpa = buff / bit8;\n    \n    return unpa;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 step = 1.0 / iResolution.xy;\n    \n    vec2 mouse = all(lessThanEqual(iMouse.xy, vec2(0.0, 0.0))) ? iResolution.xy*0.5:  iMouse.xy ;\n    \n    float splitX = uv.x - mouse.x * step.x;\n    float splitY = uv.y - mouse.y * step.y;\n\t\n    // between [0,1[\n\tvec4 signalEncoded = texture(iChannel0, uv);\n    \n    // between [0,1[\n\tfloat signal = 0.5 + 0.5*sin(uv.x*50.0 + sin(uv.y*50.0) )*sin(uv.y*40.0 + sin(uv.x*40.0+iTime) );\n   \n    // here to check where on 0,1 errors are\n    // but don't forget to maximize the \"viewport\" you're checking\n#ifdef CHECK_ERROR_SPREAD\n\tsignal = cos(uv.x*uv.y*1.57079632679);\n#endif\n    \n    \n#ifndef RANGE_BOUND_ONE_INCLUDED    \n    // between [0,1[\n    signal = (signal == 1.0) ? 0.9999999999 : signal ;    \n#endif    \n    \n\tfloat diff = 0.5;\n    if (splitX < 0.0 && splitY < 0.0  )\n    {\n        //LOWER LEFT: IQ        \n        float f = unpack_F1_UB4( signalEncoded );\n        \n        diff = abs(signal -f) * diffy; \n\n    }\n    else if (splitX < 0.0 && splitY > 0.0  )\n    {\n        // UPPER LEFT: gradient studios\n        \n        float f = unpackFloat_gradientstudios( signalEncoded );                \n        diff = abs(signal -f) * diffy; \n       \n    }\n     else if (splitX > 0.0 && splitY < 0.0  )\n    {\n        // LOWER RIGHT: ARAS_P\n        \n        float f = DecodeFloatRGBA_aras( signalEncoded );\n        \n        diff = abs(signal -f) * diffy; \n      \n    }\n    else if (splitX > 0.0 && splitY > 0.0  )\n    {\n        // UPPER RIGHT: HALF FLOAT\n        \n        vec2 f2 = decodeHalfFloatRGBA( signalEncoded );\n        \n        //float f = (f2.x + f2.y) * 0.5;\n        float f = f2.x;\n        \n        diff = abs(signal - f) * diffy; \n    }\n         \n    vec3 diff3 = vec3(diff);\n    float splitBar = (abs(splitX - 0.001) < 0.001) || (abs(splitY - 0.001) < 0.001) ? 0.0: 1.0;\n\tfragColor = vec4(diff3, 1.0)  - vec4(0.0, 1.0 - splitBar, 1.0 - splitBar, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n// uncomment to check 0 to 1 from lower left to top right\n// so that error zone spread are clear\n// but don't forget to maximize the \"viewport\" you're checking\n//#define CHECK_ERROR_SPREAD\n// want to test [0, 1] ?\n//#define RANGE_BOUND_ONE_INCLUDED\n\n// ^^ changes need to be done in both buffer\n\n\n\n// BLACK == no difference\n// WHITE == huge difference\n//\n// A big decision in to do [0, 1[ or [0, 1]\n// here testing [0, 1[\n//\n//-------------------------------------------------------------------------\n// another error graphing tech: https://www.shadertoy.com/view/XssXR4\n\n//-------------------------------------------------------------------------\n// aras_p\n// http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n// w/o the aras typo 255.0*255.0*255.0 != 160581375 it's 16581375\n\nvec4 EncodeFloatRGBA_aras( const in float v ) {\n  vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * v;\n  enc = fract(enc);\n  enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n  return enc;\n}\n\nfloat DecodeFloatRGBA_aras(const in vec4 rgba ) {\n  return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/16581375.0) );\n}\n/// \n\n\n//-------------------------------------------------------------------------\n// the correct one\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://www.shadertoy.com/view/ldj3zG\n// the classic 1-32-bit-float to 4-8-bit-vec4 packing and unpacking functions that \n// have been floating around the internet for 10 years now. Unkown source, but\n// common sense.\n\nconst vec4 bitShL = vec4(16777216.0, 65536.0, 256.0, 1.0);\nconst vec4 bitShR = vec4(1.0/16777216.0, 1.0/65536.0, 1.0/256.0, 1.0);\n\nvec4 pack_F1_UB4( const in float value )\n{\n    vec4 res = fract( value*bitShL );\n\tres.yzw -= res.xyz/256.0;\n\treturn res;\n}\n\nfloat unpack_F1_UB4( const in vec4 value )\n{\n    return dot( value, bitShR );\n}\n\n//-------------------------------------------------------------------------\n// half float precision, when you pack 2-16-bit-float to 4-8-bit-vec4 \n\nvec4 encodeHalfFloatRGBA( const in vec2 v ) {\n    const vec2 bias = vec2(1.0 / 256.0, 0.0);\n    vec4 enc;\n    enc.xy = vec2(v.x, fract(v.x * 256.0));\n    enc.xy = enc.xy - (enc.yy * bias);\n\n    enc.zw = vec2(v.y, fract(v.y * 256.0));\n    enc.zw = enc.zw - (enc.ww * bias);\n    return enc;\n}\n\nvec2 decodeHalfFloatRGBA( const in vec4 rgba ) {\n    \n    return vec2(rgba.x + (rgba.y / 256.0), rgba.z + (rgba.w / 256.0));\n}\n\n//-------------------------------------------------------------------------\n\n// http://blog.gradientstudios.com/2012/08/23/shadow-map-improvement\n// packing a float in glsl with multiplication and fract\n// wip  as not clear for now what the blog post is saying\n\n// \"fract is the problem\"\nvec4 packFloat_gradientstudios_problem( const in float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = fract( depth * bit_shift );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\n\n// packing a float in glsl with multiplication and mod\nvec4 packFloat_gradientstudios( float depth ) {\n\n  const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n  const vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\n  vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 255 ) ) / vec4( 255 );\n\n  res -= res.xxyz * bit_mask;\n  return res;\n}\n\nfloat unpackFloat_gradientstudios( vec4 depth ) {\n\n\tvec4 bitSh = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(depth, bitSh);\n}\n\n//-------------------------------------------------------------------------\n\n\n\n\n\n\n//-------------------------------------------------------------------------\n// the encode usage\n//-------------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 step = 1.0 / iResolution.xy;\n    \n    vec2 mouse = all(lessThanEqual(iMouse.xy, vec2(0.0, 0.0))) ? iResolution.xy*0.5:  iMouse.xy ;\n    \n    float splitX = uv.x - mouse.x * step.x;\n    float splitY = uv.y - mouse.y * step.y;\n\t\n    // between [0,1[\n\tfloat signal = 0.5 + 0.5*sin(uv.x*50.0 + sin(uv.y*50.0) )*sin(uv.y*40.0 + sin(uv.x*40.0+iTime) );\n   \n    // here to check where on 0,1 errors are\n    // but don't forget to maximize the \"viewport\" you're checking\n#ifdef CHECK_ERROR_SPREAD\n\tsignal = cos (uv.x*uv.y*1.57079632679);\n#endif\n    \n#ifndef RANGE_BOUND_ONE_INCLUDED    \n    // between [0,1[\n    signal = (signal == 1.0) ? 0.9999999999 : signal ;    \n#endif          \n\t\nvec4 encoded = vec4(0.6, 0.0, 0.6, 1.0);\n    \n    if (splitX < 0.0 && splitY < 0.0  )\n    {\n        //LOWER LEFT: IQ        \n        encoded = pack_F1_UB4( signal );\n        \n    }\n    else if (splitX < 0.0 && splitY > 0.0  )\n    {\n        // UPPER LEFT: gradient studios        \n        encoded = packFloat_gradientstudios( signal );\n       \n    }\n     else if (splitX > 0.0 && splitY < 0.0  )\n    {\n        // LOWER RIGHT: ARAS_P            \n        encoded = EncodeFloatRGBA_aras( signal );\n      \n    }\n    else if (splitX > 0.0 && splitY > 0.0  )\n    {\n        // UPPER RIGHT: HALF FLOAT        \n        encoded = encodeHalfFloatRGBA(vec2( signal )); \n       \n    }\n         \n\tfragColor = encoded;\n}","name":"Buf A","description":"","type":"buffer"}]}