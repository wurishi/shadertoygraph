{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define BIG_FLOAT 1e10\n#define SMALL_FLOAT 1e-5\n#define PI 3.14159\n\n#define STATIC_TEXTURE 1\n#define ANIMATED_NOISE 2\n#define SLIDING_PROJECTION 3\n\n#define PROJECTION_TYPE ANIMATED_NOISE\n\n//----------------------------------------------------------------------------------------\n// Thanks to Dave Hoskins\nvec3 hash32(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy +  vec2(21.5351, 14.3137));\n\treturn fract(vec3(p.x * p.y * 95.4337, p.x * p.y * 97.597, p.x * p.y * 93.8365));\n}\n\n// XXX: To get around a case where a number very close to zero can result in \n// eradic behavior with sign, we assume a positive sign when a value is \n// close to 0.\nfloat ztsign(float value)\n{\n    float s = 1.;\n    if (abs(value) > SMALL_FLOAT) {\n        s = sign(value);\n    }\n    return s;   \n}\n\n// intersection for an enclosing sphere with a ray.\n// Returns a vec3 where:\n//  result.x = number of intersections taking place\n//  result.y = tmin\n//  result.z = tmax\n\nvec3 intersect_sphere(vec3 ro,                 \n                             vec3 rd, \n                             float r,\n                             vec3 sc)\n{\n    // Calculate the ray origin in object space of the sphere\n    vec3 oro = ro - sc;\n\n    // We don't consider an intersection if the ray is inside the sphere\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (dot(ospaceRayOrigin, ospaceRayOrigin) < radius*radius) {\n    //     return vec3(0.);\n    // }\n    float inside = step(dot(oro, oro), r*r);\n    \n    float a = dot(rd, rd);\n    float b = dot(oro, rd);\n    float c = dot(oro, oro) - r*r;\n    float discr = b*b - a*c; // discriminant\n\n    // DEBRANCH\n    // Equivalent to:\n    // if (discr > 0.) {\n    //     ...\n    // }\n\n    float isdiscrgtZero = step(0., discr);\n\n    // Real root of disc, so intersection\n    float sdisc = sqrt(abs(discr));\n    float tmin = (-b - sdisc)/a;\n    float tmax = (-b + sdisc)/a; \n\n    float hit = step(0., tmin) + step(0., tmax);\n\n    return step(0., isdiscrgtZero) * vec3(hit, tmin, tmax);\n}\n\n\n// Returns a vec2 where:\n//   result.x = 1. or 0. if there is a hit\n//   result.y = t such that origin + t*dir = hit point\nvec2 intersect_plane(vec3 ro,\n                     vec3 rd,\n                     vec3 pn,\n                     vec3 po)\n{\n    float rddotpn = dot(rd, pn);\n    // if the ray direction is parallel to the plane, let's just treat the \n    // ray as intersecting *really* far off, which will get culled as a\n    // possible intersection.\n\n    float denom = ztsign(rddotpn) * max(abs(rddotpn), SMALL_FLOAT);\n    float t = min(BIG_FLOAT, -dot(pn, (ro - po)) / denom);    \n    return vec2(step(SMALL_FLOAT, t), t);\n}\n\nvec3 rotate_look(vec3 l)\n{\n    float y = .05 * iTime;\n    if (iMouse.y/iResolution.y > .1)\n    {\n        y = -PI * iMouse.x/iResolution.x;\n    }\n    return l * mat3(cos(y), 0., sin(y),\n                    0.,     1., 0.,\n                   -sin(y), 0., cos(y));\n}\n\nvec3 texture_cube(vec3 usphp, float scale)\n{\n    // cheap way of turning a 2D texture into a cube\n    // map lookup by ray casting sphere intersection direction \n    // to the appropriate plane of the surrounding cube and then\n    // using the uv of that plane intersection as a 2d vector.\n    \n    vec3 p = usphp;\n#if PROJECTION_TYPE == SLIDING_PROJECTION\n    p.y -= sin(.1 * iTime);\n#endif\n    \n    float ml = max(abs(p.x), max(abs(p.y), abs(p.z)));\n    vec3 ansphp = abs(p/ml); \n    \n    // select the plane offset of a unit cube\n    vec3 upo = sign(p) * step(vec3(1. - SMALL_FLOAT), ansphp);\n    \n    // scale the plane we are intersecting by the offset\n    vec2 pr = intersect_plane(vec3(0.), p, -upo, scale * upo);\n    vec3 pp = pr.y * p;\n\n    // get the uv lookup of the plane intersection.\n    vec2 uv = step(1. - SMALL_FLOAT, ansphp.x) * pp.yz;\n    uv += step(1. - SMALL_FLOAT, ansphp.y) * pp.xz;\n    uv += step(1. - SMALL_FLOAT, ansphp.z) * pp.xy;\n\n#if PROJECTION_TYPE == STATIC_TEXTURE | PROJECTION_TYPE == SLIDING_PROJECTION\n    \n    // filter texture lookup more when unit cube is closer to\n    // unit sphere - cheap hack to compensate for the fact\n    // that the texture lookup is more stretched near the\n    // corners.\n    float f = 1.2 * (1. - length(pp/scale - p));\n    \n    return texture(iChannel0, .5 * uv + .5, f).rgb;\n#elif PROJECTION_TYPE == ANIMATED_NOISE\n    \n    return hash32(.5 * uv + .5);\n    \n#endif\n\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nfloat spheredf( vec3 p, float r )\n{\n    return length(p) - r;    \n}\n\nfloat yplanedf( vec3 p, float offset )\n{\n    return abs(p.y - offset);\n}\n\nfloat cyldf( vec3 p, float r)\n{\n    return - (length(p.xz) - r);\n}\n\nfloat scenedf( vec3 pos )\n{\n    float dist = BIG_FLOAT;\n\n    for (float i = 0.; i < 12.; i += 1.)\n    {\n        float s = PI * i/6.;\n        float r = 5. + 5. * (.5 * cos(PI * i/2. + .2 * iTime) + .5);\n        vec3 sphc = vec3(r * cos(s), .7, r * sin(s));\n        dist = min(spheredf(pos - sphc, 1.), dist);\n    }\n\n    dist = min(yplanedf(pos, -1.3), dist);\n\tdist = min(cyldf(pos, 15.), dist);\n    return dist;\n}\n\n#define DISTMARCH_STEPS 50\n#define DISTMARCH_MAXDIST 20.\n\nvec3 surface_normal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scenedf(p + epsilon.xyy) - scenedf(p - epsilon.xyy),\n        scenedf(p + epsilon.yxy) - scenedf(p - epsilon.yxy),\n        scenedf(p + epsilon.yyx) - scenedf(p - epsilon.yyx) );\n    return normalize( n );\n}\n\n\n#define SOFTSHADOW_STEPS 30\n#define SOFTSHADOW_STEPSIZE .3\n\nfloat soft_shadow( vec3 ro, \n                   vec3 rd, \n                   float mint, \n                   float maxt, \n                   float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scenedf( ro + rd * t );\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\n#define AO_NUMSAMPLES 5\n#define AO_STEPSIZE .3\n#define AO_STEPSCALE .7\n\nfloat ambient_occ( vec3 p, \n\t\t          vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi < AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scenedf( aop );\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n\nvec2 dist_march( vec3 ro, vec3 rd, float maxd )\n{\n    \n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || t > maxd ) break;\n        t += dist;\n        dist = scenedf( ro + t * rd );\n    }\n\n\n    float objhit = 0.;\n    if( t < maxd ) \n    {\n        objhit = 1.;\n    }\n\n    return vec2(objhit, t);\n}\n\nvec3 shade_scene( vec3 ip, vec3 ro, vec3 rd )\n{\n    vec3 lpos = 4. * vec3(0., 1., 0.);\n    vec3 n = surface_normal( ip );\n    vec3 ldir = normalize(lpos - ip);\n    \n    float s = soft_shadow( ip, ldir, .02, 10., 10.);\n    float ao = ambient_occ( ip, n );\n    \n    float mody = mod(4. * ip.y, 1.);\n    float stripes = step(length(ip.xz), 14.) * (smoothstep(0., .05, mody) - smoothstep(.5, .55, mody));\n    vec3 scol =  mix(vec3(.5, .6, 1.), vec3(.2, .2, .4), stripes);\n\n    float falloff = pow(max(0., 1. - length(lpos - ip)/19.), 2.);\n\n    vec3 diff = 5. * scol * max(0., dot(ldir, n));\n    vec3 spec = vec3(2.) * pow(max(0., dot(ldir, reflect(rd, n))), 8.);\n    vec3 amb = scol * .8 * (1. - ao);\n    vec3 bnc = scol * .6 * pow(ip.y + 1.3,2.) * max(0., dot(n, normalize(ro - ip + vec3(0., -8., 0.))));\n    \n    return falloff * (s * (diff + spec) + \n           \t\t      (amb + bnc));\n}\n\nvec3 renderEye( in vec3 fragRayOri, in vec3 fragRayDir, in vec2 uv )\n{\n    vec3 scol = vec3(0.);\n    \n    vec3 ro = fragRayOri;\n    vec3 rd = fragRayDir;\n    vec2 dr = dist_march(ro, rd, DISTMARCH_MAXDIST);\n    \n    // shade\n    if (dr.x > 0.5)\n    {\n\t    vec3 ip = ro + rd * dr.y;\n        scol = shade_scene(ip, ro, rd);\n    \n        // post effect projection\n        vec3 sphc = vec3(0.);\n        vec3 sphr = intersect_sphere(ro, rd, 1. * length(ip), sphc);     \n        vec3 sphp = ro + sphr.z * rd;\n\n        scol *= .5 + .5 * texture_cube(normalize(sphp - sphc), 5.);\n\t\t//scol = pow(scol, vec3(1.) + .5 * texture_cube(normalize(sphp - sphc), 5.));\n            \n        // gamma\n\t    scol = pow(scol, vec3(.5));\n    }    \n            \n    // spherical vignette\n    scol *= pow(max(1. - length(uv),0.), 1.);\n\n    return scol;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    // camera\n    vec3 f = rotate_look(vec3(0., 0., 1.));\n    vec3 u = vec3(0., 1., 0.);\n\n    vec3 cx = normalize(cross(f, u));\n    vec3 cy = cross(cx, f);\n    vec3 cz = f;\n    \n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(uv.x * cx + uv.y * cy + 1. * cz);\n    \n    vec3 scol = vec3(0.);\n\n    ro = 1. * vec3(2. * pow((.5 * sin(.5 * iTime) + .5), 4.) - 1., \n                   1. * pow((.5 * cos(.8 * iTime + 1.) + .5), 4.), \n\t\t\t        0.);\n    \n    vec3 scene_color = renderEye(ro, rd, uv);\n    \n    fragColor.rgb = scene_color;\n    fragColor.a = 1.;\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    vec3 col = renderEye( fragRayOri + vec3(0.,1.,0.), fragRayDir, uv );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":true,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdjXDV","date":"1416202263","viewed":684,"name":"VR Post FX Projection","username":"mplanck","description":"A post process that modulates the final color using a 2D texture lookup but sticks to the environment as head position changes in 3d - an interesting depth/sphere/cubemap trick.  Camera origin moves around to simulate VR.  Spheres are moving in and out.","likes":11,"published":1,"flags":1,"usePreview":0,"tags":["posteffect","vr"],"hasliked":0,"parentid":"","parentname":""}}