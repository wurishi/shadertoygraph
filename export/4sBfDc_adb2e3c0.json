{"ver":"0.1","info":{"id":"4sBfDc","date":"1502403477","viewed":258,"name":"360 video rendered on gpu [Rays]","username":"mjdr","description":"360 video rendered on gpu","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","vr","360"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592\n\n\nstruct Light {\n    vec3 pos;\n    vec3 color;\n    vec3 distKoef;\n    float power;\n};  \nstruct Material {\n    vec3 color;\n    float reflectionFactor;\n};\n\nint entry = -1;\n\n\n//Setup lights\n#define LIGTHS 2\nLight getLight(int i){\n    \n  float a = iTime /2.;\n    if(i == 0)\n        return Light(\n      \t\tvec3(5.0*cos(a),5.0,5.0*sin(a)),\n      \t\tvec3(1.),\n      \t\tvec3(.5,1.,1.),\n      \t\t1.0);\n    a += PI;\n    if(i == 1)\n        return Light(\n      \t\tvec3(5.0*cos(a),5.0,5.0*sin(a)),\n      \t\tvec3(1.),\n      \t\tvec3(.5,1.,1.),\n      \t\t1.0);\n}\n//Setup materials\nMaterial getMaterial(int i){\n    if(i == -1)//default\n        return Material(vec3(0.0),0.);\n    if(i == 0)//walls\n        return Material(vec3(0.5,0.5,0.9),0.0);\n    if(i == 1)//colls\n        return Material(vec3(0.,1.,0.),0.5);\n    if(i == 2)// sphere\n        return Material(vec3(1.,0.,0.),0.0);\n}\n\n\n//Track current shape\nint shapeId = -1;\nvoid resetShape(){\n  shapeId = -1;\n}\nfloat track(float D, float d, int index){\n    if(D > d){\n        D = d;\n        shapeId = index;\n    }\n    return D;\n}\n    \n//Building geomery\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\nfloat box(vec3 p, vec3 b){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 repeat(vec3 p, vec3 d){\n    return mod(p,d)- d / 2.; \n}\n\nfloat room(vec3 p){\n  float d = 1.0e10;\n  \n  float walls =\n    max(\n      -box(p,vec3(40.0,7.,40.)),\n       box(p,vec3(45.0,10.,45.))\n    );\n  \n  float colls = box(\n      repeat(p, vec3(13.)),\n      vec3(0.8,10.,0.8)\n  );\n    \n  d = track(d,walls,0);\n  d = track(d,colls,1);\n  d = track(d,sphere(p-vec3(0.,0.,5.0),1.5 * (1.5 + sin(1.0+p.y + 2.0*iTime)/2.)),2);\n  \n  return d;\n}\n\n\nfloat world(vec3 p){\n    float d = 1.0e10;\n    \n    d = min(d,room(p));\n    \n    return d;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,0.01);\n    float d = world(p);\n    return normalize(\n        vec3(\n        \tworld(p + e.yxx) - d,\n        \tworld(p + e.xyx) - d,\n        \tworld(p + e.xxy) - d\n            )\n    );\n}\n\n\nfloat tracer(vec3 O, vec3 D,float N){\n    \n    for(int i = 0;i < 512;i++){\n        float w = world(O + D*N);\n        \n        if(w < .005)\n            return N;\n        \n        N += w * 0.5;\n    }\n    return -1.0;\n}\n//Lighting\nvec3 applyLight(vec3 p, vec3 n,vec3 c, Light l){\n  \tvec3 toLight = l.pos - p;\n    float emb = 0.04;\n  \tvec3 lightDir = normalize(toLight);\n  \tfloat d = length(toLight);\n    \n  \tfloat k = dot(n,lightDir) * l.power;\n    if(k < 0.)\n    \treturn c * emb;\n    \n    //Shadow\n    float lightTrace = tracer(p,lightDir,0.3);\n    if(lightTrace != -1. && lightTrace <= d)\n    \treturn c * emb;\n    //\n    \n    float g = dot(vec3(k*k,k,1.0),1.0/(d*l.distKoef));\n        \n  \treturn c*l.color*g + c * emb;\n    \n}\n\n\nvec3 lighting(vec3 p, vec3 n, vec3 c){\n \n  vec3 color = vec3(0.0);\n    \n  for(int i = 0;i < LIGTHS;i++)\n  \tcolor += applyLight(p,n,c,getLight(i));\n    \n  return color;\n}\n\n\n\n\n\n//Cameras\nvec3 camera(vec2 fragCoord){\n    vec2 uv = 2.0 * (fragCoord.xy / iResolution.xy) - 1.;\n    vec2 p = uv * vec2(1.,iResolution.y/iResolution.x);\n    return normalize(vec3(p,1.0));\n}\n\nvec3 camera360(vec2 fragCoord){\n    vec2 uv = (2.0 * fragCoord / iResolution.xy) - 1.;\n    vec2 a = vec2(uv.x * PI,uv.y * PI/2.);\n    vec3 vec = vec3(sin(a.x) * cos(a.y),sin(a.y),cos(a.y)*cos(a.x));\n    return vec;\n}\n\n\n\nvec3 getColor(vec3 O, vec3 D , out vec3 pos , out vec3 out_n, out int shape){\n    resetShape();\n    float t = tracer(O,D,0.4);\n    shape = shapeId;\n    vec3 color = vec3(0.0);\n    pos = O + D * t;\n    vec3 n = normal(pos);\n    \n    out_n = reflect(D,n);\n    \n    float ttt = float(shape+1);\n    if(t > 0.0)\n        color = lighting(pos,n,getMaterial(shape).color);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 o = vec3(0.,1.,-3.);\n    vec3 d = camera360(fragCoord);\n    \n    vec3 \n        tN1 = vec3(0.0),\n        tN2 = vec3(0.0),\n        tP1 = vec3(0.0),\n        tP2 = vec3(0.0),\n        color = vec3(0.0);\n    \n    tN1 = d;\n    tP1 = o;\n    \n    float k = 1.;\n    int shape = -1;\n    for(int i = 0;i < 2;i++){\n        color += getColor(tP1,tN1,tP2,tN2,shape) * k;\n        k *= getMaterial(shape).reflectionFactor;\n        if(k == 0.) break;\n        \n            \n        tP1 = tP2;\n        tN1 = tN2;\n    }\n    \n    \n    \n\tfragColor = vec4(sqrt(color),1.0);\n}","name":"Image","description":"","type":"image"}]}