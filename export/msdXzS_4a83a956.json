{"ver":"0.1","info":{"id":"msdXzS","date":"1680050017","viewed":188,"name":"Fountain and Bushes","username":"ianertson","description":"Use the mouse to look around :)","likes":16,"published":1,"flags":0,"usePreview":1,"tags":["3d","raymarching","raymarch","sdf","water","materials","textures","fountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ID_GROUND 1\n#define ID_BUSH 2\n#define ID_FOUNTAIN 3\n#define ID_WATER 4\n#define ID_BENCH 5\n\nfloat groundSDF(in vec3 p) { return p.y; }\nfloat bushSDF(in vec3 p) {\n    vec3 v = p;\n    vec3 n1 = vec3(cos(v.x), sin(v.y), sin(v.z));\n    vec3 n2 = vec3(sin(v.x), cos(v.y), cos(v.x));\n    vec3 n3 = cross(n1, n2);\n    vec3 n4 = vec3(cos(n3.x), sin(n3.y), sin(n3.z));\n    vec3 n5 = vec3(sin(v.x+n4.x), cos(v.y+n4.y), cos(v.z+n4.z));\n    vec3 n6 = reflect(n5, n3);\n    \n    vec3 n = (n1+n2+n3+n4+n5+n6)/6.;\n    p.xz += n.yx*0.25;\n    p.y += abs(n.z)*0.25;\n    \n    float r = 1.0;\n    \n    float len = 16.0;\n    p.z += len/2.;\n    float dx = lineSDF(vec3(p.x, p.y, abs(p.z-len/2.)) - vec3(-len/2., r, len/2.), vec3(0., 0, 0), vec3(len, 0, 0), r);\n    float dz = lineSDF(vec3(abs(p.x), p.y, p.z) - vec3(len/2., r, 0), vec3(0., 0, 0.), vec3(0., 0, len), r);\n    float k = 0.5;\n    float d = smin(dx, dz, k);\n    \n    return d/1.1;\n}\n\n#define SDF_SIG inout int id, in int skip, inout Object o\n\nfloat fountainSDF(in vec3 p, SDF_SIG) {\n    id = ID_FOUNTAIN;\n    float dist = FAR;\n    \n    float r = 4.0;\n    float h = 0.7;\n    float base = max(length(p.xz)-r, p.y-h)-0.05;\n    float baseInside = max(max(length(p.xz)-(r*0.85), (p.y)-h*2.)-0.03, -p.y+0.15)-0.02;\n    base = smax(base, -baseInside, 0.3)-0.01;\n    \n    float pedHeight = h*0.9;\n    float pedR = r*0.4;\n    float ped = cylSDF(p, vec3(0, 0, 0), vec3(0, pedHeight, 0), pedR)-0.04;\n    \n    base = smin(base, ped, 0.25);\n    \n    dist = min(dist, base);\n    \n    float poleHeight = 4.5;\n    float poleR = pedR*0.33;\n    float pole = cylSDF(p - vec3(0, pedHeight, 0), vec3(0, 0, 0), vec3(0, poleHeight, 0), poleR);\n    \n    float box = boxSDF(p - vec3(0, (poleHeight/2.)+pedHeight, 0), vec3(poleR, poleHeight/2., poleR));\n    float box2 = boxSDF(pointRot(p - vec3(0, (poleHeight/2.)+pedHeight, 0), vec3(0, radians(45.), 0)), vec3(poleR, poleHeight/2., poleR));\n    box = min(box, box2);\n    pole = mix(pole, box, 0.8*smoothstep(0.0, 1.0, length(p.xz)));\n    dist = min(dist, pole);\n    \n    if (p.y < 3.3 && skip != ID_WATER)\n    {\n       // vec3 n1 = snoise(p.xz, 0.03921, 0.1, 0.1, 6);\n        \n        float water = max(max(length(p.xz)-(r*0.85), (p.y)-h/1.5)-0.03, -p.y+0.15)-0.02;\n        float waterInside = (max(length(p.xz)-(r*0.85*0.98), (p.y-0.01)-h/2.2)-0.03)-0.02;\n        \n        if (p.y > 0.02 && water < 2.) {\n            vec2 shift = vec2(cos(T*0.25), sin(T*0.25))*0.8;\n            vec2 uv = p.xz+(sin(shift));\n            uv *= rot(sin(((T*0.5)+0.2*(shift.x-shift.y))*0.1));\n           // uv *= mat2(6.28, 8.0, -6.28, 8.0)*0.1;\n            vec3 n1 = sineNoise((uv+shift)*0.55, 0.0329212, 0.9);\n            uv *= rot(cos(((T*0.5)+n1.z*2.)*0.03)+3.*(0.2+(0.5*(n1.x-n1.y+n1.z))));\n            n1 = n1.xzy;\n            uv += shift-vec2(cos(shift.x+n1.x), sin(shift.y+n1.y))*n1.z;\n          //  uv *= mat2(6.28, 8.0, -6.28, 8.0)*0.1;\n            vec3 n2 = exp(vec3(sin(uv.y), cos(uv.x), sin(n1.y+n1.z+n1.x+(uv.x*3.32921+uv.y)))-1.);\n            n2 = n2.zxy;\n            vec3 n3 = exp(vec3(cos(n1.z-uv.y), sin(n2.y-uv.x), sin(n2.z*uv.y))-1.);\n            \n            \n            float wh = (n1.x+n1.y+n1.z)/3.;\n            wh += (n2.x+n2.y+n2.z)/3.;\n            wh += 0.45-(n3.x+n3.y+n3.z)/3.;\n            wh *= 0.49;\n            wh -= 0.1;\n            float ra = r;\n            float fe = ra*0.5;\n            float ra2 = ra*0.5;\n            float fe2 = ra2*0.5;\n            wh *= (1.0-smoothstep(ra-fe, ra+fe, length(p.xz)));\n            wh *= smoothstep(ra2-fe2, ra2+fe2, length(p.xz));\n            wh = sclamp(wh, -0.23, 1.0, 0.7);\n            wh *= 0.96;\n            float hh = sclamp(p.y-0.4, 0.0, 1.0, 1.7)*wh;\n            water -= hh;\n            waterInside -= hh;\n        }\n        water = smax(water, -waterInside, 0.05);\n        SAMPLE(water, o, ID_WATER);\n    }\n    return dist;\n}\n\nfloat benchSDF(in vec3 p) {\n    float dist = FAR;\n    float h = 0.7;\n    vec3 seatSize = vec3(1, 0.05, 0.3);\n    float seat = boxSDF(p - vec3(0, seatSize.y + h, 0), seatSize)-0.01;\n    dist = min(dist, seat);\n    \n    float legLen = (h-seatSize.y)+0.1;\n    float legR = 0.09;\n    float leg = cylSDF(vec3(abs(p.x), p.y, abs(p.z)) - vec3((seatSize.x/2.)+legR*2., 0, seatSize.z/2.), vec3(0, 0, 0), vec3(0, legLen, 0), legR) -0.01;\n    \n    vec3 backSize = vec3(seatSize.x, 0.35, seatSize.y);\n    float back = boxSDF(p - vec3(0, backSize.y+seatSize.y+h, seatSize.z), backSize)-0.01;\n    dist = min(dist, back);\n    \n    dist = min(dist, leg);\n    \n    return dist;\n    \n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    Object o = NEW_OBJECT;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, o, ID_GROUND);\n    \n    float bush = bushSDF(p);\n    SAMPLE(bush, o, ID_BUSH);\n    \n    float bench = benchSDF(vec3(p.x, p.y, abs(p.z)) - vec3(0, 0., 6.3));\n    SAMPLE(bench, o, ID_BENCH);\n    \n    int fountainId = 0;\n    Object oFountain = NEW_OBJECT;\n    float fountain = fountainSDF(p, fountainId, skip, oFountain);\n    SAMPLE(fountain, oFountain, fountainId);\n    \n    data.id = id;\n    data.o = o;\n    return dist;\n}\n\nvec3 leaf(in vec2 uv, in vec2 id, in float ra, inout Material m) {\n    float ra0 = fract(((ra-id.x)*44.4929811)+id.y*3.3921);\n    if (floor(ra0+ra+0.1) <= 0.) { return vec3(0.0); }\n    float v = 0.0;\n    float len = 0.9;\n    float s = smoothstep(len/2., 0.0, abs(uv.y))*smoothstep(len/3., 0.1, -uv.y+0.01);\n    vec2 start = vec2(0,-len/2.);\n    vec2 end = vec2(0, len/2.);\n    start.x += 0.1*s;\n    end.x += 0.1*s;\n    v += line2D(abs(uv), start, end, 0.01);\n    v += smoothstep(0.0, 0.01, dot(vec2(abs(uv.x)-(0.1*s), uv.y), (start-end).yx));\n    m.z += v;\n    vec3 col = mix(vec3(0.3, 0.33, 0.1), vec3(0.9, 0.9, 0.5), s*s*s);\n    vec3 c1 = vec3(0.3, 0.33, 0.2);\n    vec3 c2 = vec3(0.8, 0.8, 0.3);\n    vec3 c3 = vec3(0.2, 0.5, 0.04);\n    vec3 c4 = vec3(0.0, 0.4, 0.02);\n    vec3 n = hash23(id, ra);\n    vec3 a = mix(c1, c2, n.x);\n    vec3 b = mix(c3, c4, n.y);\n    vec3 c = mix(a, b, n.z);\n    col = mix(col, c, ra*ra);\n    float ra2 = fract((ra*10.98938281)+(id.x*3.392912+id.y));\n    col = mix(col, (col*c3)+(c2*c3*s), ra2*ra2*0.39);\n    m.z += 0.5-s;\n    return col*v;\n}\n\nvec3 leafsTexture(in vec2 uv, in float iseed, inout Material m) {\n    vec3 col = vec3(0.0);\n    float tile = 4.0;\n    float seed = 3.329291 + iseed;\n    float div = 1.0;\n    for (int i = ZERO; i < 24; i++) {\n        vec2 id = floor(uv*tile);\n        vec2 lv = fract(uv*tile);\n        vec2 slv = lv*lv*(3.0-2.0*lv);\n        float n = hash21(id, seed);\n        float n2 = hash21(id, seed+id.x+id.y+0.329812);\n        lv = fract(uv*tile);\n        lv = (0.5-lv)*rot(n*6.28);\n        col = max(col, leaf(lv, id, fract((n+n2+id.x+id.y)*10.4992), m)/div);\n        seed += 13.937272;\n        tile += 1.;\n        uv *= mat2(6.28, 8.0, -6.28, 8.)*0.1;\n        div += 0.2;\n    }\n    m.z /= 24.;\n    col = col / (1.0 + max(col-0.56, 0.0));\n    \n   // m.ior = mix(0.0, 1.500, smoothstep(0.02, 0.0, length(col)));\n    \n    return col;\n}\n//#define DEBUG_TEXTURE woodTexture\nvec3 woodTexture(in vec2 uv, in vec3 p, inout Material m) {\n    uv += 0.5928312;\n    float tile = 2.0;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    lv = lv*lv*(3.0-2.0*lv);\n    float seed = 0.392812;\n    float rid = mix(\n        mix(hash21Fast(id, seed), hash21Fast(id+vec2(1, 0), seed), lv.x),\n        mix(hash21Fast(id+vec2(0, 1), seed), hash21Fast(id+vec2(1, 1), seed), lv.x),\n        lv.y\n    );\n    uv *= rot(rid*0.5);\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(142, 107, 94);\n    vec3 c2 = rgb(79, 53, 57);\n    vec3 c3 = rgb(174, 109, 69);\n    vec3 c4 = rgb(232, 186, 128);\n    vec3 hf1 = sineNoise2(uv, 0.3292123, 2.);\n    uv *= rot(hf1.z*0.5);\n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 col2 = mix4(c4, c3, c2, c1, hf1);\n    col += (col1+col2)*0.5;\n    float cracks = max(0.0, 1.0-smoothstep(0.02, 0.1, abs(hf1.y-rid)));\n    float cracks2 = exp((sin((uv.x*4.928931+uv.y)*4.28*2.+cos((uv.y*4.203921)-(uv.x*0.59291))))-1.);\n    cracks = mix(cracks, cracks2, clamp(hf1.z+hf1.y, 0.0, 1.0));\n    cracks = mix(cracks, fract(cracks*3.3), 0.7*smoothstep(0.4, 0.7, hf1.x));\n    cracks *= 0.5;\n    col = mix(col, col*col, cracks);\n    m.rough = clamp(cracks*2., 0.7, 1.0);\n    m.spec = max(0.0, 0.3-cracks*2.);\n    m.spec += hf1.y*0.5;\n    m.z = 0.3-cracks*0.6;\n    return col;\n}\n\n//#define DEBUG_TEXTURE stoneTexture\n\nvec3 stoneTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(84, 90, 90);\n    vec3 c2 = rgb(198, 194, 178);\n    vec3 c3 = rgb(100, 104, 90);\n    vec3 c4 = rgb(111, 75, 35);\n    \n    vec3 warp = snoiseWarp(uv, 0.092831, 0.9, 16.0, 6, 0.5);\n    vec3 lf1 = snoise(uv, 4.494983, 0.2, 8.0, 6);\n    vec3 hf1 = snoise(uv, 9.998255, 0.3, 32.0, 6);\n    vec3 col1 = mix4(c1, c2, c3, c4, warp);\n    vec3 col2 = mix4(c4, c3, c2, c1, warp);\n    vec3 col3 = mix4(c1, c2, c3, c4, hf1);\n    vec3 col4 = mix4(c4, c3, c2, c1, hf1);\n    vec3 crackCol = (col3+col4)/2.;\n    crackCol = clamp(crackCol*(0.25+crackCol), 0.0, 1.0);\n    float dirtReg = smoothstep(0.4, 0.7, lf1.x);\n    col = mix(col2, col1, dirtReg);\n    \n    float cracks = 1.0-smoothstep(0.0, 0.05, abs(hf1.x-lf1.z));\n    cracks *= smoothstep(0.4, 0.7, warp.z);\n    col = mix(col, crackCol, cracks);\n    \n    m.spec = clamp(1.0-0.2*((dirtReg+cracks)*(0.5*(dirtReg+cracks))),0.25, 1.0);\n    m.rough = clamp((dirtReg+cracks)/2., 0.6, 1.0);\n    \n    m.z = 0.5 - 0.5*(dirtReg+cracks);\n    \n    return col;\n}\n//#define DEBUG_TEXTURE stoneBrickTexture\n\nvec3 stoneBrickTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 c1 = rgb(143, 134, 121);\n    vec3 c2 = rgb(130, 128, 124);\n    vec3 c3 = rgb(71, 67, 62);\n    vec3 c4 = rgb(164, 145, 122);\n    \n    vec3 g1 = rgb(58, 76, 39);\n    vec3 g2 = rgb(77, 75, 54);\n    vec3 g3 = rgb(107, 102, 72);\n    vec3 g4 = rgb(85, 107, 44);\n    \n    vec3 lf1 = snoise(uv, 0.0392219, 0.2, 16.0, 6);\n    vec3 lf2 = snoise(uv, 7.7777793, 0.2, 8.0, 6);\n    vec3 hf1 = snoise(uv, 5.5598393, 0.5, 64.0, 6);\n    vec3 hf2 = snoise(uv, 16.956838, 0.0, 128., 6);\n    vec3 grain = abs(normalize(cross(hf1*2.0-1.0, hf2*2.0-1.0)));\n    \n    float cracks = 1.0-smoothstep(0.04, 0.1, abs((lf2.y+(lf1.y*2.0-1.0))*2.0-1.0));\n    cracks *= smoothstep(0.4, 0.7, lf2.z);\n    \n    \n    vec3 grassCol1 = mix4(g1, g2, g3, g4, smoothstep(0.19, 0.3, hf2*lf1));\n    vec3 grassCol2 = mix4(g4, g3, g2, g1, hf2);\n    vec3 grassCol = mix(grassCol1, grassCol2, lf2.x);\n    float grassGrain = grain.x*0.4;\n    grassCol = mix(grassCol, grassCol*grassCol, grassGrain);\n    \n    vec3 col1 = mix4(c1, c2, c3, c4, hf1);\n    vec3 col2 = mix4(c4, c3, c2, c1, hf1);\n    vec3 colA = (col1+col2)*0.5;\n    \n    vec3 col3 = mix4(c1, c2, c3, c4, smoothstep(0.4, 0.7, lf1));\n    vec3 col4 = mix4(c4, c3, c2, c1, smoothstep(0.4, 0.7, lf1));\n    vec3 colB = (col3+col4)*0.5;\n    \n    col = mix(colA, colB, smoothstep(0.4, 0.7, lf2.x));\n    \n    \n    float tile = 4.0;\n    float idy = floor(uv.y*tile);\n    vec2 uuv = uv;\n    uuv.x += idy/tile/2.;\n    vec2 id = floor(uuv*tile);\n    vec2 lv = fract(uuv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    \n    float idr = hash21Fast(id*4.492921, 3.32092912+id.x+id.y);\n    float idr2 = hash21Fast(id*6.694912, 7.7779894+id.x-id.y+idr);\n    float idr3 = hash21Fast(id*10.293123, 0.0923811+idr+idr2);\n    \n    vec3 idf = vec3(idr, idr2, idr3);\n    vec3 idcol1 = mix4(c1, c2, c3, c4, idf);\n    vec3 idcol2 = mix4(c4, c3, c2, c1, idf);\n    vec3 idcol = (idcol1+idcol2)*0.5;\n    \n    float stoneR = mix(1.4, 0.5, smoothstep(0.4, 0.7, lf1.x));\n    float stoneRX = mix(-0.01, 0.2, idr);\n    float stoneRY = mix(-0.01, 0.2, idr2);\n    stoneR = max(0.02, stoneR-0.5);\n    float stoneArea = clamp((1.0-max(\n        smoothstep(0.48-stoneR, 0.55, alv.x-(0.5-stoneRX)),\n        smoothstep(0.48-stoneR, 0.55, alv.y-(0.5-stoneRY))))*3., 0.0, 1.0);\n\n    float grassArea = max(0.0, 1.0-stoneArea);\n    cracks *= stoneArea;\n    \n    float stoneGrain = grain.y*0.4*stoneArea*max(0.25, smoothstep(0.4, 0.7, lf2.z));\n    \n    col = mix(col, idcol, stoneArea);\n    \n    float edge = 1.0-smoothstep(-0.1, 0.9, abs(stoneArea - grassArea));\n    \n    grassArea *= smoothstep(0.2, 0.7, lf1.z);\n    col = mix(col, grassCol, grassArea);\n    \n    col = mix(col, col*col, edge);\n    float corner = (edge+stoneR*0.05)*max(smoothstep(0.33, 0.54, lv.x-(0.3-stoneRX)),\n                            smoothstep(0.33, 0.54, lv.y-(0.3-stoneRY)));\n    corner = corner*corner;\n    col = mix(col, clamp(col+col+col, 0.0, 1.0), corner*0.8);\n    col = mix(col, colA*colB, cracks);\n    col = mix(col, col*col*col, stoneGrain);\n    \n    m.spec = max(0.0, 1.0-(grassArea+cracks));\n    m.z = (stoneArea-grassArea)-(cracks*0.15);\n    m.rough = clamp(((grassArea+cracks)*2.)+(stoneGrain*2.), 0.56, 1.0);\n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    uv *= 0.5;\n    vec3 col = stoneBrickTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.23, 0.009);\n    return col;\n}\n\nvec3 getAlbedoBench(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = woodTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.17, 0.001);\n    return col;\n}\n\nvec3 getAlbedoBush(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    uv *= 0.5;\n    vec3 col = leafsTexture(uv, 0.32123, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.6, 0.1);\n    return col;\n}\n\nvec3 getAlbedoWater(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = vec3(0.15, 0.43, 0.59);\n    col = ((col*col)+(col*col))*0.25;\n    data.m.ior = 1.33;\n    data.m.rough = 0.1;\n    data.m.metallic = 0.8934;\n    return col;\n}\n\nvec3 getAlbedoFountain(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = boxUv(p, n);\n    vec3 col = stoneTexture(uv, p, data.m);\n    data.n = makeNormal(data.n, data.m.z, 0.23, 0.009);\n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BENCH: return getAlbedoBench(data); break;\n        case ID_BUSH: return getAlbedoBush(data); break;\n        case ID_WATER: return getAlbedoWater(data); break;\n        case ID_FOUNTAIN: return getAlbedoFountain(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(COLOR_SKY, vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    depth = 1.0;\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light lights[NUM_LIGHTS];\n    lights[0] = LIGHT_SUN; \n    \n    raycast(data, lights, col, ro, rd);\n    \n    depth = data.d / FAR;\n    \n    col += smoothstep(0.01, 1.0, depth) * max(0.0, 1.0-smoothstep(0.0, 0.25, dotup));\n    \n    return col;\n}\n\nRay getRay(in vec2 uv, in vec4 m) {\n    vec3 ro = vec3(0, 0, -10.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n    \n    if (m.z > 0.001 && length(m.xy) > 0.0001 && iFrame > 1 && iTime > 0.0001) {\n        ro.yz *= rot(m.y*TAU);\n        ro.xz *= rot(m.x*TAU);\n        \n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n    } else {\n        ro.y += 2.5;\n        ro.xz = vec2(cos(T*0.33), sin(T*0.33))*10.;\n        rd = look(uv, vec3(0, 0, 0), ro, 1.);\n    }\n    \n    float y = 1.5;\n    ro.y += y;\n    ro.y = max(max(ro.y, y), 3.3);\n    \n    return Ray(ro, rd);\n}\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    Ray ray = getRay(uv, m);\n    vec3 ro = ray.ro;\n    vec3 rd = ray.rd;\n    Data data = NEW_DATA;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col = max(col, 0.0);\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    O = vec4(clamp(col, 0.0, 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R (iResolution.xy)\n#ifndef HW_PERFORMANCE\n#define iTime (0.0)\n#define iFrame (0)\nuniform sampler2D iChannel3;\n#define iResolution vec2(0.0)\n#define iMouse vec4(0.0)\n#endif\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n\n#define FORWARD_DECL\\\n    float sdf(inout Data data, in vec3 p) { return FAR; }\\\n    vec3 getAlbedo(inout Data data) { return vec3(0.0); }\\\n    vec3 getSky(in vec3 rd) { return vec3(0.0); }\n\n#define SAMPLE(var, OBJ, id_) if (id_ != skip && var < dist) { id = id_; dist = var; o = OBJ; }\n// Ray marcher constants\n\n#define NEAR 0.003\n#define FAR 90.0\n#define STEPS 60\n#define SHADOW_STEPS 33\n#define FAR_LOD 1.0\n#define NORMAL_RANGE 0.001\n#define AMBIENT 0.25\n#define NUM_LIGHTS 1\n#define ID_NONE -1\n\n// Colors\n\n#define COLOR_SKY vec3(0.29, 0.61, 0.9)\n#define COLOR_SUN vec3(0.97, 0.81, 0.79)\n\n// Render constants\n\n#define SPECULAR_AMPLITUDE 64.0\n#define SHADOW_NDOTL_EPSILON 0.000003\n\n// Default sun light\n\n#define LIGHT_SUN Light(vec3(1, 2, -3), vec3(0.0), COLOR_SUN, 2.0, LIGHT_AMBIENT)\n\nstruct Object {\n    vec3 p;\n    vec3 q;\n};\n\n#define NEW_OBJECT Object(vec3(0.0), vec3(0.0))\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; float ior; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 q;\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    float d;\n    int skip;\n    int id;\n    float sig;\n    Material m;\n    Object o;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0),vec3(0.0), vec3(0.0), vec3(0.0), FAR, ID_NONE, ID_NONE, 1., NEW_MATERIAL, NEW_OBJECT)\n\n\nstruct Ray {\n    vec3 ro;\n    vec3 rd;\n};\n\n#ifndef HW_PERFORMANCE\nfloat sdf(inout Data data, in vec3 p) { return FAR; }\nvec3 getAlbedo(inout Data data) { return vec3(0.0); }\nvec3 getSky(in vec3 rd) { return vec3(0.0); }\n#else\nfloat sdf(inout Data data, in vec3 p);\nvec3 getAlbedo(inout Data data);\nvec3 getSky(in vec3 rd);\n#endif\n\n\n// Utilities\n\nvec3 mix4(vec3 c1, vec3 c2, vec3 c3, vec3 c4, vec3 m) {\n    return mix(mix(mix(c1, c2, m.x), c3, m.y), c4, m.z);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sclamp(in float v, in float mi, in float ma, in float k) {\n    return smin(smax(v, mi, k), ma, k);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.0000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0001);\n    vec2 dy = vec2(0.0001, dFdy(z));\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.00002) return wn;\n    cp = normalize(cp);\n    mx *= max(0.0, 1.0 - max(0.0, dot(cp, -wn)));\n    vec3 next = normalize(mix(wn, normalize(wn+cp), mx));\n    if (length(next) <= 0.0001) return wn;\n    return next;\n}\n\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\nvec3 look(in vec2 uv, in vec3 point, in vec3 ro, in float zoom) {\n    vec3 camForward = normalize(point - ro);\n    vec3 camRight = -normalize(cross(camForward, vec3(0, 1, 0)));\n    vec3 camUp = -normalize(cross(camRight, camForward));\n    vec3 screenCenter = ro + camForward * zoom;\n    vec3 screenIntersection = screenCenter + uv.x * camRight + uv.y * camUp;\n    return normalize(screenIntersection - ro);\n}\n\nvec3 pointRot(in vec3 p, in vec3 r) {\n    p.yz *= rot(r.x);\n    p.xz *= rot(r.y);\n    return p;\n}\n\n// UV functions\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xy, p.yz, round(adot(n, vec3(1, 0, 0)))), p.xz, round(adot(n, vec3(0, 1, 0))));\n}\n\nvec2 sphereUv(in vec3 p) {\n    float u = acos(p.y);\n    float v = atan(p.x, p.z);\n    u = 0.5 - u / M_PI;\n    v = 0.5 + v / M_PI;\n    return vec2(u, v);\n}\n\n// Distance functions\n\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, in float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return clamp(01.0-length(pa - ba * h)/t, 0.0, 1.0);\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    return length(pa - ba * (clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0))) - r;\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\n// Noise functions\n\nuint hash21u(in vec2 ip, in float seed) {\n    uvec2 p = uvec2(floatBitsToUint(ip.x), floatBitsToUint(ip.y));\n    uint s = floatBitsToUint(seed);\n    s ^= ~s >> 3U;\n    p ^= (p << 17U);\n    s ^= (~p.x);\n    s ^= (~p.y);\n    p ^= (p >> 11U);\n    p ^= (p << 5U);\n    p ^= (s << 3U);\n    return ((p.x + p.y) ^ (p.x * s + p.y))*293U;\n}\n\nfloat hash21(in vec2 ip, in float seed) { return float(hash21u(ip, seed)) / float(0xFFFFFFFFU); }\n\nvec3 hash23(in vec2 ip, in float seed) {\n    uint n = hash21u(ip, seed);\n    n ^= (n >> 13U);\n    return vec3(float((n >> 16U) & 0xFFU), float((n >> 8U) & 0xFFU), float(n & 0xFFU)) / float(0xFFU);\n}\n\nfloat hash21Fast(in vec2 p, in float seed) {\n    float ma = 64.092391;\n    float x = mod(p.x*4.0291, ma) / ma;\n    float y = mod(p.y*5.5920, ma) / ma;\n    vec2 p2 = mix(vec2(x,y), vec2(y, x), fract(seed*10.29891231))*2.0-1.0;\n    float r1 = mod(100.2891382*fract(seed+(dot(p, p2)*16.2099123)), ma)/ma;\n    float r2 = fract((p.x*3.392912+p.y)*distance(p2, p-seed));\n    return fract(dot(p, vec2(r1, r2)));\n}\n\nfloat noise(in vec2 p, in float seed) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p);\n    lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(hash21(id, seed), hash21(id+vec2(1,0), seed), lv.x),\n        mix(hash21(id+vec2(0, 1), seed), hash21(id+vec2(1,1), seed), lv.x),\n        lv.y\n    );\n}\n\n#define NOISE(p, seed, lod) (textureLod(iChannel3, (p + (seed*1.9287827185))/256.0, lod).rgb)\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    p += 0.99288124;\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, in float freq, const in int octaves) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, in float freq, const in int octaves, in float warp) {\n    p += 0.99288124;\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = ZERO; i < octaves; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; lod /= 2.0; freq *= 2.0;\n        p += (n.xy*n.z)*warp;\n    }\n    return n / div;\n}\n\nvec3 sineMut(in vec2 p, in float seed) {\n    vec3 r = vec3(0.001);\n    for (int i = ZERO; i < 4; i++) {\n        r += vec3(cos(p.x+r.x), sin(p.y+r.y), sin((r.z+seed)*6.28));\n        p *= mat2(6.28, 8.0, -6.28, 8.0)*0.1;\n       // r.xz *= mat2(6.28, 8.0, -6.28, 8.0)*0.1;\n    }\n    \n    float l = dFdx(length(p-r.xy+r.z));\n    return clamp((r*l)/2., 0.0, 1.0);\n}\n\nvec3 sineNoise(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = ZERO; i < 4; i++) {\n        n += amp*sineMut(p*freq, seed); div += amp; amp /= 2.; freq *= 2.0;\n        p *= mat2(6.28, 8.0, -6.28, 8.0)*0.1;\n    }\n    \n    return clamp(n/div, 0.0, 1.0);\n}\n\n\nvec3 sineMut2(in vec2 p, in float seed) {\n    vec2 s1 = vec2(sin(p.x+seed), cos(p.y+seed));\n    float r1 = dot(s1, p);\n    s1 *= rot(r1);\n    vec2 s2 = vec2(cos(r1+seed), sin(r1+seed));\n    float r2 = dot(s2, p);\n    s2 *= rot(r2);\n    \n    vec3 v = vec3(s1.x, s1.y, s2.x);\n    v.xz *= rot(s2.y);\n    return exp(v-1.);\n}\n\nvec3 sineNoise2(in vec2 p, in float seed, in float freq) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    \n    for (int i = ZERO; i < 4; i++) {\n        n += amp*sineMut2(p*freq, seed); div += amp; amp /= 2.; freq *= 2.0;\n        p += (n.xz*n.y)*amp;\n    }\n    \n    return n/div;\n}\n\n// Shading & Colors\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\n\nvec3 aces(vec3 x) {return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14); }\n\nvec3 fresnelSchlickRoughness(float NdotV, vec3 F0, float rough) {\n  return F0 + (max(vec3(1.0 - rough), F0) - F0) * pow(max(1.0 - NdotV, 0.0), 5.0);\n}\n\nvec3 fresnelSchlick(vec3 F0, float cosTheta) {\n\treturn F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat ndfGGX(float cosLh, float roughness) {\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (cosLh * cosLh) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float cosTheta, float k) {\n\treturn cosTheta / (cosTheta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float cosLi, float cosLo, float roughness) {\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(cosLi, k) * gaSchlickG1(cosLo, k);\n}\n\nvec3 EnvBRDFApprox(vec3 specularColor, float roughness, float ndotv) {\n    const vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);\n    const vec4 c1 = vec4(1, 0.0425, 1.04, -0.04);\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * ndotv)) * r.x + r.y;\n    vec2 AB = vec2(-1.04, 1.04) * a004 + r.zw;\n    return specularColor * AB.x + AB.y;\n}\n\n// Marching\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    float sig = data.sig;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sig*sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d / FAR_LOD)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    Data tmp = NEW_DATA;\n    vec3 p = ro+rd*d;\n    vec2 e = vec2(NORMAL_RANGE, 0.0);\n    vec3 n = normalize(sdf(tmp, p) - vec3(\n        sdf(tmp, p - e.xyy),\n        sdf(tmp, p - e.yxy),\n        sdf(tmp, p - e.yyx)\n    ));\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    \n    return true;\n}\n\n// Modified version of iq's https://www.shadertoy.com/view/lsKcDD\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    Data data = NEW_DATA;\n    float NdotL = dot(n, rd);\n    float res = 1.0;\n    float ep = 1e20;\n    float t = NEAR;\n    float ss = (far/FAR);\n    float bb = 1.0;\n    for(int i = ZERO; i < SHADOW_STEPS && t < far; i++){\n        vec3 p = ro + rd*t;\n        float j = float(i);\n        \n        // Move point away from surface\n        // This solves some ugly banding issues\n        p += n*clamp(pow(dot(normalize(rd+p), n), 2.)*3., 0.0, 0.93); \n        \n        float h = sdf(data, p);\n        \n        float y = h*h / (2.9 * ep);\n        float d = sqrt(h*h-y*y);\n        res = min(res, d/(ss*max(0.0, t-y)));\n        bb = max(0.0, min(bb, float(data.id == 4)/d/(ss*max(0.0, t-y))));\n        ep = h;\n        t += h;\n    }\n    \n    // Fixes issues with sharp corners & edges\n    float ra = far*0.5; // radius\n    float fe = ra*0.77; // feather\n    res = max(res, 0.);\n    res = max(mix(res*res,\n        (1.0-smoothstep(ra-fe, ra+fe, far-t)),\n        smoothstep(0.0, 0.6, res+smoothstep(0.0, 0.9, t / (1.0+t*6.)))\n    ), 0.);\n    res += clamp(0.25*AMBIENT*max(0.02, t/far), 0.001, AMBIENT);\n    //////////////////////////////////////////\n    \n    return clamp(res+(bb*0.35), AMBIENT, 1.);\n}\n\n\n// Lighting\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) :\n           light.type == LIGHT_POINT ? normalize(light.p - p) :\n           normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * light.s * NdotL * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec3 forEachLight(in Light light, in Data data, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, SPECULAR_AMPLITUDE);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.0), L, n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    float metallic = data.m.metallic;\n    float rough = data.m.rough;\n    float specF = data.m.spec;\n    \n    vec3 LH = normalize(L + -rd);\n    float cosLi = max(0.0001, dot(n, L));\n\tfloat cosLh = max(0.0001, dot(n, LH));\n    float cosLo = max(0.0001, dot(n, -rd));\n    vec3 F0 = mix(vec3(0.04), diffuse, metallic);\n    vec3 F  = fresnelSchlick(F0, max(0.0, dot(LH, -rd)));\n    float D = ndfGGX(cosLh, rough);\n    float G = gaSchlickGGX(cosLi, cosLo, rough);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), metallic);\n    vec3 diffuseBRDF = kd * diffuse;\n    vec3 specularBRDF = (F * D * G) / max(0.00003, 4.0 * cosLi * cosLo);\n    \n        \n    return (diffuseBRDF + specF*specularBRDF) * att * shadow; \n}\n\nbool rayGetColor(inout Data data, in Light lights[NUM_LIGHTS],\n    in bool with_sky, inout vec3 col, in vec3 ro, in vec3 rd, inout vec3 diffuse) {\n    if (!march(data, ro, rd)) {\n        if (with_sky) {\n            col += getSky(rd);\n        }\n        return false;\n    }\n    vec3 albedo = getAlbedo(data);\n    diffuse = albedo / M_PI;\n    for (int i = ZERO; i < NUM_LIGHTS; i++) {\n        Light light = lights[i];\n        col += forEachLight(light, data, ro, rd, diffuse);\n    }\n    col = max(col, 0.0);\n    return true;\n}\n\nbool raycast(\n    inout Data data,\n    in Light lights[NUM_LIGHTS],\n    inout vec3 col,\n    in vec3 ro,\n    in vec3 rd\n ) {\n    bool withSky = true;\n    float dist = FAR;\n    for (int i = ZERO; i < 3; i++) {\n        vec3 diffuse = vec3(0.0);\n        if (!rayGetColor(data, lights, withSky, col, ro, rd, diffuse)) return i <= 0 ? false : true;\n        if (i <= 0) { dist = data.d; }\n        \n        float rough = data.m.rough;\n        float metallic = data.m.metallic;\n        float ior = data.m.ior;\n        vec3 n = data.n;\n        vec3 p = data.p;\n\n        if (rough < 0.993) {\n            vec3 F0 = mix(vec3(0.04), diffuse, metallic);\n            float NdotV = max(0.0, dot(n, -rd));\n            vec3 F = fresnelSchlickRoughness(NdotV, F0, rough);\n            \n            if (length(F) > 0.01) { \n                Data reflectData = NEW_DATA;\n                reflectData.sig = data.sig;\n                vec3 reflectRo = p + (n*NEAR*3.);\n                vec3 reflectDir = reflect(rd, n);\n                vec3 reflectDiffuse = vec3(0.0);\n                vec3 reflectColor = vec3(0.0);\n                vec3 env = EnvBRDFApprox(mix(vec3(0.77), diffuse, metallic*metallic*0.15), rough*rough, NdotV);\n                reflectData.skip = data.id;\n                rayGetColor(reflectData, lights, true, reflectColor, reflectRo, reflectDir, reflectDiffuse);\n                col += reflectColor * (F * env);\n            }\n        }\n\n        if (ior > 0.00019) {\n            vec3 enterDir = refract(rd, n, 1.0/ior);\n            \n            if (length(enterDir) <= 0.00003) {\n                break;\n            }\n            \n            Data enterData = NEW_DATA;\n            enterData.skip = data.skip;\n            enterData.sig = -data.sig;\n            \n            vec3 enterP = p+(n*enterData.sig*NEAR*16.);\n            vec3 refractDiffuse = vec3(0.0);\n\n            rayGetColor(enterData, lights, false, col, enterP, enterDir, refractDiffuse);\n            \n            rd = refract(enterDir, enterData.n*enterData.sig, ior);\n            data = NEW_DATA;\n            if (length(rd) <= 0.0001) {\n               // rd = reflect(enterDir, enterData.n*enterData.sig);\n               // data.skip = -1;\n               // data.sig = -1.;\n                //withSky = false;\n                break;\n            } else {\n                data.sig = 1.;\n                withSky = i > 0;\n               // data.skip = enterData.id;\n            }\n            ro = enterP+(enterData.n*NEAR*64.*data.sig);\n        } else {\n            break;\n        }\n        col = max(col, 0.0);\n    }\n    data.d = dist;\n    return true;\n}\n","name":"Common","description":"","type":"common"}]}