{"ver":"0.1","info":{"id":"WljyRm","date":"1594002922","viewed":163,"name":"Littlewood polynomials 2","username":"rory618","description":"Continuation of https://www.shadertoy.com/view/WtByRm\nSelect viewport by dragging mouse, press w to zoom into it while dragging. R to reset.","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["2d","fractal","bvh"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\n/*vec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    vec2 p = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    fragColor = texture(iChannel1, uv);\n    \n    fragColor /= fragColor.z;\n    float v0 = pow(log(1.+fragColor.x),.6)/8.;\n    float v1 = pow(log(1.+fragColor.y),.2)*1.;\n    \n    fragColor = vec4(pow(v0+v1,1.2));\n    \n    vec2 nup = mouse.xy - mouse.zw;\n    vec2 nright = vec2(nup.y, -nup.x) * iResolution.x / iResolution.y;\n    \n\t\n    \n    vec2 o = (fragCoord - mouse.zw);\n    \n    float z = max(0.0, min(1.0, 1.0-\n    abs(max(\n    \tmax(\n        \t( dot(o, nup)/length( nup) - length( nup)) , \n            ( dot(o,-nup)/length(-nup) - length(-nup)) \n        ), max(\n            ( dot(o, nright)/length( nright) - length( nright)) ,\n         \t( dot(o,-nright)/length(-nright) - length(-nright)) \n        )\n    ))));\n    \n    if(iMouse.z>.1 && mouse.z != 0.0)\n        fragColor += z;//*fragColor + (z);\n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n\nint IHash(int a){\n\ta = (a ^ 61) ^ (a >> 16);\n\ta = a + (a << 3);\n\ta = a ^ (a >> 4);\n\ta = a * 0x27d4eb2d;\n\ta = a ^ (a >> 15);\n\treturn a;\n}\n\nfloat Hash(int a){\n\treturn float(IHash(a)) / float(0x7FFFFFFF);\n}\nvec4 rand4(int seed){\n    return vec4(Hash(seed^0x34F85A93),\n                Hash(seed^0x85FB93D5),\n                Hash(seed^0x6253DF84),\n                Hash(seed^0x25FC3625));\n}\nvec3 rand3(int seed){\n    return vec3(Hash(seed^0x348CD593),\n                Hash(seed^0x8593FD5),\n                Hash(seed^0x62A5D384));\n}\nvec2 rand2(int seed){\n    return vec2(Hash(seed^0x348C5F93),\n                Hash(seed^0x8593D5BB));\n}\n\n#define R iResolution\n\n\nvec2 coord2viewport(vec2 coord, vec2 s, vec2 center, vec2 scale) {\n    return center + mat2(scale, -scale.y, scale.x) * (coord-s/2.)/max(s.x,s.y);\n}\n\n\n\nvec2 randn(vec2 randuniform){\n    vec2 r = randuniform;\n    r.x = sqrt(-2.*log(1e-9+abs(r.x)));\n    r.y *= 6.28318;\n    r = r.x*vec2(cos(r.y),sin(r.y));\n    return r;\n}\n\n\n\n\n\n//Distance to mandelbrot set orbit\nfloat orbitDist(vec2 start, vec2 c, vec2 p, int iters){\n    //return length(c-p);\n    float d = 1e9;\n    vec2 z = start;\n    int j = 0;\n    for(j = 0;  j < iters; j++) {\n        z = mat2(z, -z.y, z.x) * z + c;\n        d = min(d,length(z-p));\n        //if(dot(z,z)>1e3)\n        //    return d;\n    }\n    return(d);\n    \n}\n\nvec2 Ptoc(vec2 p, vec3 R){\n    return (p-R.xy/2.)/R.y*2. + vec2(-.25,0);\n}\n\nvec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define R iResolution\n#define sf (R.y/1.5)\nvec2 pxToC(vec2 px){\n    px -= R.xy/2.;\n    px /= sf;\n    return px;\n}\n\nconst vec2 viewportLoc = vec2(0.5,0.5);\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\n\nvec2 dfs(vec2 x, vec2 c, int seed, float ds, float g0, bool xx){\n    int depth = 0;\n    int maxDepth = 40;\n    \n    vec2 e = x;\n    \n    vec2 xn = x;\n    \n    //Create a circular bound on around the fractal. Because of self simmilarity, this\n    //bound can be scaled to make a bound around every smaller copy within the fractal.\n    for(int i = 0; i < maxDepth; i++){\n        xn = mat2(x,-x.y,x.x)*xn;\n    \t//Each new branch will either increase or decrease the distance from the origin so always select the branch that increases it\n        if(length(e + xn) > length(e - xn)){\n            e += xn;\n        } else {\n            e -= xn;\n        }\n    }\n    xn = x;\n    vec2 xn_prev = vec2(1,0);\n    float rad = length(e);\n    float f = length(x);\n    \n    vec2 d = vec2(0);\n    vec2 grad = vec2(0);\n    vec2 v = vec2(0.);\n    float p = 1.;\n    if(length(c-d)<rad){\n    \trad *= f;\n    \n        for(int i = 0; i < maxDepth; i++){\n            \n            vec2 A = d + xn;\n            vec2 B = d - xn;\n            vec2 grad_A = grad + xn_prev * float(i+1);\n            vec2 grad_B = grad - xn_prev * float(i+1);\n            xn_prev = xn;\n        \txn = mat2(x,-x.y,x.x)*xn;\n\n            \n            bool A_bound = length(c-A)<rad;\n            bool B_bound = length(c-B)<rad;\n            \n            vec2 oddsAB = 1./vec2(length(c-A),length(c-B));\n            oddsAB /= oddsAB.x+oddsAB.y;\n            \n            rad *= f;\n\t\t\tp = min(p,1e18);\n            v += float(length(A-vec2(1,0)) < 1.5*g0*length(grad_A)*ds)*p*vec2(1,exp(-exp(.2*float(i))));\n            v += float(length(B-vec2(1,0)) < 1.5*g0*length(grad_B)*ds)*p*vec2(1,exp(-exp(.2*float(i))));\n            //v += int(length(B) < 0.01);\n\n            if(A_bound){\n                if(B_bound){\n                    seed = IHash(seed);\n                    if(Hash(seed) < oddsAB.x){\n                        p /= oddsAB.x;\n                        d = A;\n                        grad = grad_A;\n                    }else{\n                        p /= oddsAB.y;\n                        d = B;\n                        grad = grad_B;\n                    }\n                } else {\n            \t\td = A;\n                    grad = grad_A;\n                }\n            } else {\n\t\t\t\tif(B_bound){\n            \t\td = B;\n                    grad = grad_B;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    O = texture(iChannel1, I/R.xy);\n    int seed = iFrame*2000*2000;// + 2000*int(I.x) + int(I.y)  ;\n    vec2 x;\n    I += rand2(seed)-.5;\n    vec2 uv = I/R.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n    \n    \n    vec2 c = uvtoc(center, up, right, 2.0*(uv-vec2(.5)));\n    \n    c *= 2.;\n    float g0 = 1.;\n    if(length(c)>1.){\n        c /= dot(c,c);\n        g0 *= dot(c,c);\n    }\n    O.xy += (dfs(c, vec2(1,0),seed, length(up)/1e3,g0,I.x>R.x/2.));\n    O.z += 1.;\n    \n    if(texelFetch(iChannel3, ivec2(82,1),0).x>.5){O*=0.;}\n    if(texelFetch(iChannel3, ivec2(87,1),0).x>.5){O*=0.;}\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const vec2 viewportLoc = vec2(0.5,0.5);\nconst vec2 mouseLoc = vec2(0.5,1.5);\n\nconst vec2 param1Loc = vec2(0.5,2.5);\nconst vec2 param2Loc = vec2(0.5,3.5);\nconst vec2 param3Loc = vec2(0.5,4.5);\nconst vec2 param4Loc = vec2(0.5,5.5);\nconst vec2 param5Loc = vec2(0.5,6.5);\n\n\nconst float KEY_W  = 87.5/256.0;\nconst float KEY_R  = 82.5/256.0;\n\nconst float KEY_0 = 48.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\n\n\nvec4 load(vec2 a) {\n    return texture( iChannel0, (a) / iChannelResolution[0].xy, -100.0 );\n}\nvec4 save(vec4 v, vec2 a, vec2 c) {\n    return length(c-a)<.5 ? v : vec4(0);\n}\nbool keyIsDown( float key ) {\n    return texture( iChannel1, vec2(key,0.25) ).x > .5;\n}\n/*vec2 uvtoc(vec2 center, vec2 up, vec2 right, vec2 uv ) {\n    return center + right * uv.x + up * uv.y;\n}*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 viewport = load(viewportLoc);\n    vec4 mouse = load(mouseLoc);\n    \n    vec4 param1 = load(param1Loc);\n    vec4 param2 = load(param2Loc);\n    vec4 param3 = load(param3Loc);\n    vec4 param4 = load(param4Loc);\n    vec4 param5 = load(param5Loc);\n    \n    vec2 center = viewport.xy;\n    vec2 up = viewport.zw;\n    vec2 right = vec2(up.y, -up.x) * iResolution.x / iResolution.y;\n        \n    if (iMouse.z < 0.1) {\n        mouse.zw = -iMouse.xy;\n    } else if(mouse.z < 0.0) {\n        mouse.zw = iMouse.xy;\n    }\n    \n    mouse.xy = iMouse.xy;\n    if (iMouse.z > 0.1 && mouse.z != 0.0) {\n    \tif ( keyIsDown(KEY_W) && mouse.xy != mouse.zw ) {\n        \tvec2 ncenter = uvtoc(center, up, right, (mouse.zw / iResolution.xy - vec2(.5))*2.0);\n            vec2 nup = uvtoc(center, up, right, (mouse.xy / iResolution.xy - vec2(.5))*2.0) - ncenter;\n            center = ncenter;\n            up = nup;\n            mouse.z = 0.0;\n    \t}\n    }\n    \n    viewport = vec4(center, up);\n    \n    if ( keyIsDown(KEY_R) || iFrame <= 1) {\n        viewport = vec4(0,0,0,.8);\n        //param1=vec4(1);\n        //param2=vec4(0);\n        //param3=vec4(0);\n        //param4=vec4(0);\n        //param5=vec4(0);\n    }\n    \n    fragColor = vec4(0);\n    \n    if (keyIsDown(KEY_1)){param1.xy=mouse.xy;}\n    if (keyIsDown(KEY_2)){param2.xy=mouse.xy;}\n    if (keyIsDown(KEY_3)){param3.xy=mouse.xy;}\n    if (keyIsDown(KEY_4)){param4.xy=mouse.xy;}\n    if (keyIsDown(KEY_5)){param5.xy=mouse.xy;}\n    \n    fragColor += save(param1,param1Loc,fragCoord);\n    fragColor += save(param2,param2Loc,fragCoord);\n    fragColor += save(param3,param3Loc,fragCoord);\n    fragColor += save(param4,param4Loc,fragCoord);\n    fragColor += save(param5,param5Loc,fragCoord);\n    \n    fragColor += save(viewport,viewportLoc,fragCoord);\n    fragColor += save(mouse,mouseLoc,fragCoord);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}