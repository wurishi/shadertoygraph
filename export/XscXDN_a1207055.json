{"ver":"0.1","info":{"id":"XscXDN","date":"1459299126","viewed":267,"name":"(FIXED) Reflections","username":"Neph","description":"Tbqh honest I barely know the proper way for this.\nThanks to reinder for showing me how to remove artifacts and greatly improve the quality of the reflections!","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","raymarch","lighting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAXITER 128\n#define MAXREFLECTIONS 2\n#define REFLECTIVITY 0.8\n#define CLIP 30.0\nvec4 map(vec3 p){\n    vec3  fcol = vec3(0.0);\n    float fdist = 0.0;\n    {\n    vec3  col = vec3(0.8, 0.2, 0.0);\n    vec3  q = vec3(fract (p.xz), p.y + 0.6)*2.0 - 1.0;\n    float dist = sin(length(q)) - 0.5;  \n    fcol = col;\n    fdist = dist;\n    }\n    {\n    vec2 lw = clamp(vec2(abs(sin(iTime*0.2))), vec2(0.7), vec2(1.0));\n    vec3  col = vec3(0.0, 0.4, 0.6);\n    p.xy += 0.5;\n    p.z -= iTime;\n    vec3  q = vec3(fract (p.xz), p.y+0.8)*2.0 - 1.0;\n    float dist = length(max(abs(q)-vec3(lw, 0.5),0.0)); \n        if (fdist > dist){\n         fcol = col;\n         fdist = dist;\n        }\n    }\n    if (fdist > 1.0){fdist = 1.0;};\n    return vec4(fcol, fdist);\n}\nvec4 march(vec3 o, vec3 r, float q){\n \tvec4 t = vec4(0.0);\n    for (int i = 0; i < MAXITER; i++){\n     \tvec3 p = o + r * t.w;\n        vec4 d = map(p);\n        if (t.w > CLIP) break;\n        t.xyz = d.xyz;\n        t.w += d.w * q;\n    }\n    return t;\n}\nvec3 getNormal( vec3 p ){\n    vec2 e = vec2(0.01, -0.01); \n    return normalize(\n        e.xyy * map(p + e.xyy).w + \n        e.yyx * map(p + e.yyx).w + \n        e.yxy * map(p + e.yxy).w + \n        e.xxx * map(p + e.xxx).w );\n}\nvec3 shade(vec3 n, vec3 pos, vec3 col){\n\tvec3 iFin = vec3(0.0);\n    {\n     vec3  lipos = vec3(sin(iTime), 1.0, iTime*0.5);\n     vec3  licol = vec3(1.0);\n     float lintensity = 2.0;\n     vec3  lidir = normalize(lipos - pos);\n     vec3  libdir = vec3(dot(n, lidir));\n     iFin += col * libdir * lintensity;\n    }\n    return iFin;\n}\nvec3 gloss(vec3 col, vec3 rd, vec3 p, vec3 nor){\n\tvec3 c = col;\n    vec3 r = rd;\n    vec3 pos = p;\n    vec3 n = nor;\n    for (int i = 0; i < MAXREFLECTIONS; i++){\n        r = reflect(n, r);\n\t\tvec4 d = march(pos + r * 0.001, r, 0.3);\n        pos = pos + r * d.w;\n        n = getNormal(pos);\n        vec3 lit = shade(n, pos, d.xyz);\n        lit = clamp(lit, 0.0, 1.0);\n        c = mix(lit, c, REFLECTIVITY);\n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0.0, 0.5, iTime*0.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float tt = iTime*0.2;\n    rd.xz *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    rd.xy *= mat2(cos(tt), -sin(tt), sin(tt), cos(tt));\n    vec4 d = march(ro, rd, 0.2);\n    vec3 pos = ro + rd * d.w;\n    vec3 n = getNormal(pos);\n    vec3 lit = shade (n, pos, d.xyz);\n    vec3 final = gloss(lit, rd, pos, n);\n    col = final - d.w*0.05;\n    col = n;\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}