{"ver":"0.1","info":{"id":"XfjSWV","date":"1706828882","viewed":97,"name":"Rock Paper Scissors - Diffusion","username":"cebo","description":"A simple diffusion reaction of 3 reactants. \nRed beats blue, blue beats green, green beats red.\nThe constant variables in the Common tab can be changed to modify the behavior.\n\nBased on this video: https://www.youtube.com/watch?v=TORwMc2AaRE","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["simulation","rps","rockpaperscissors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 invResolution = 1. / iResolution.xy;\n    fragColor = CELL_AT(fragCoord / ZOOM);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 1/sqrt(2)\nconst float INV_SQRT2 = 0.70710678118;\n// Sum of weights of all neighbors. Cardinal neighbors are 1.0, diagonals are INV_SQRT2, i.e. (4 + 4/sqrt2)\nconst float NEIGHBOR_WEIGHT = 6.82842712475;\n\nvec4 getCellValue(vec2 fragCoord);\nvec4 getBoundaryValue(vec2 fragCoord);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(\n           fragCoord.x == 0.\n        || fragCoord.y == 0.\n        || fragCoord.x == iResolution.x - 1.\n        || fragCoord.y == iResolution.y - 1.\n    )\n    {\n        fragColor = getBoundaryValue(fragCoord);\n    }\n    else\n    {\n        fragColor = getCellValue(fragCoord);\n    }\n    \n    // Init\n    if (iFrame <= 5) fragColor = texture(iChannel1, fragCoord / iResolution.xy);// / 3.;\n}\n\n/** Provides value for the given non-boundary pixel after it is updated based on the rules.\n *  The value is modified by two different rules:\n *      Diffusion: Each value (rgb) spreads out over time, tending towards the average value of itself and its neighbors\n *      Rock-Paper-Scissors Reaction: Each value is decreased by the presence of one of the other values, or increased by its lack thereof.\n */\nvec4 getCellValue(vec2 fragCoord) \n{\n    vec2 invResolution = 1. / iResolution.xy;\n    \n    vec3 thisCell = CELL_AT(fragCoord).xyz;\n    float thisSum = thisCell.x + thisCell.y + thisCell.z;\n    \n    vec3 neighborSum = vec3(0.);\n    for (int dx = -1; dx <= 1; ++dx) {\n        for (int dy = -1; dy <= 1; ++dy) {\n            // Ignore center point (temporarily removed)\n            //if (dx == 0 && dy == 0) continue;\n            vec3 neighborCell = CELL_AT(fragCoord + vec2(dx, dy)).xyz;\n            // Cardinals\n            if (dx == 0 || dy == 0) neighborSum += neighborCell;\n            // Diagonals\n            else neighborSum += neighborCell * INV_SQRT2;\n        }\n    }\n    \n    vec3 diffusion = DIFFUSION_RATE * (neighborSum - thisCell * NEIGHBOR_WEIGHT);\n    vec3 rps = thisCell * (\n        // (1 - thisSum) so that the sum of values will tend towards 1.0\n        vec3(1.) - vec3(thisSum)\n        // For each value in thisCell, subtract it's \"enemy\" value.\n        - RPS_RATE * thisCell.yzx\n    );\n    \n    vec4 result = vec4(thisCell + SIMULATION_SPEED * iTimeDelta * (diffusion + rps), 1.0);\n    \n    return result;\n}\n\n/** Returns the value of the cell 1 unit inwards from the provided boundary cell. Corner cells go 1 unit inwards in both directions.\n *  I.E. The cell at xy = (0, 25) will return the value at (1, 25)\n *   and the cell at xy = (0, 0) will return the value at (1,1)\n *  This ensures that when the other cells are simulated, they are guarenteed to have sensible neighbors.\n */\nvec4 getBoundaryValue(vec2 fragCoord) \n{\n    vec2 dXY = vec2(0.);\n    \n    if (fragCoord.x == 0.)                      dXY.x =  1.;\n    else if (fragCoord.x == iResolution.x - 1.) dXY.x = -1.;\n    \n    if (fragCoord.y == 0.)                      dXY.y =  1.;\n    else if (fragCoord.y == iResolution.y - 1.) dXY.y = -1.;\n    \n    vec2 invResolution = 1. / iResolution.xy;\n    return CELL_AT(fragCoord + dXY);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define CELL_AT(xy) (texture(iChannel0, (xy) * invResolution))\n\n//Playback\nconst float ZOOM = 1.0;\nconst float SIMULATION_SPEED = 1.0; //Faster speeds tend to blow up, <=10 is usually stable\n\n//Simulation Parameters \nconst float DIFFUSION_RATE =  1.0; // How fast colors spread evenly, like gas\nconst float RPS_RATE       = 1.0; // How fast colors consume each other when mixed. ","name":"Common","description":"","type":"common"}]}