{"ver":"0.1","info":{"id":"4ffcW8","date":"1721047271","viewed":107,"name":"Crystal magic ball","username":"zhangrm","description":"A crystal magic ball.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","marble","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//ref:https://www.shadertoy.com/view/MtX3Ws\n\nfloat zoom=1.;\n\nvec2 cmul(vec2 a, vec2 b) { return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }\nvec2 csqr(vec2 a) { return vec2(a.x * a.x - a.y * a.y, 2. * a.x * a.y); }\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec2 iSphere(in vec3 ro, in vec3 rd, in vec4 sph) //from iq\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nfloat map(in vec3 p) {\n    float res = 0.;\n    vec3 c = p;\n    for (int i = 0; i < 10; ++i) {\n        p = 0.7 * abs(p) / dot(p, p) - 0.7;\n        p.yz = csqr(p.yz);\n        p = p.zxy;\n        res += exp(-19. * abs(dot(p, c)));\n    }\n    return res / 2.;\n}\n\nvec3 getColor(float t, float c) {\n    float timeFactor = sin(iTime + t) * 0.5 + 0.5;\n    vec3 baseColor = vec3(0.2, 0.0, 0.5);\n    vec3 colorVariation = vec3(0.8, 0.5, 0.3); \n    return baseColor + colorVariation * c * timeFactor;\n}\n\nvec3 raymarch(in vec3 ro, vec3 rd, vec2 tminmax) {\n    float t = tminmax.x;\n    float dt = .02;\n    int items =  64;\n    vec3 col = vec3(0.);\n    float c = 0.;\n    for (int i = 0; i < items; i++) {\n        t += dt * exp(-2. * c);\n        if (t > tminmax.y) break;\n\n        c = map(ro + t * rd);\n\n        col = 0.99 * col + 0.08 * getColor(t, c);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 m = vec2(0.);\n    if (iMouse.z > 0.0) m = iMouse.xy / iResolution.xy * 3.14;\n    m -= .5;\n\n\n\n    vec3 ro = zoom * vec3(4.);\n    ro.yz *= rot(m.y);\n    ro.xz *= rot(m.x + 0.1 * time);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n    vec3 rd = normalize(p.x * uu + p.y * vv + 4.0 * ww);\n\n    vec2 tmm = iSphere(ro, rd, vec4(0., 0., 0., 2.));\n\n\n    vec3 col = raymarch(ro, rd, tmm);\n    if (tmm.x < 0.) col = texture(iChannel0, rd).rgb;\n    else {\n        vec3 nor = (ro + tmm.x * rd) / 2.;\n        nor = reflect(rd, nor);\n        float fre = pow(.5 + clamp(dot(nor, rd), 0.0, 1.0), 3.) * 1.3;\n        col += texture(iChannel0, nor).rgb * fre;\n    }\n\n    float dist = length(fragCoord.xy - iResolution.xy * 0.5) / (iResolution.y * 0.6);\n    col += smoothstep(0.7, 0.1, dist) * vec3(0.3, 0.4, 1.0) * 1.5;\n\n    for (int i = 0; i < 5; i++) {\n        vec2 particlePos = fract(sin(vec2(float(i) * 43758.5453 + time)) * 0.5 + 0.5) * iResolution.xy;\n        float particleDist = length(fragCoord.xy - particlePos);\n        col += exp(-particleDist * 0.1) * vec3(1.0, 0.6, 0.3) * 0.5;\n    }\n\n    col = .5 * (log(1. + col));\n    col = clamp(col, 0., 1.);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}