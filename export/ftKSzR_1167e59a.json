{"ver":"0.1","info":{"id":"ftKSzR","date":"1643560600","viewed":311,"name":"perspective correct texturing","username":"sylefeb","description":"Illustration of perspective correct interpolation. Hit [space] to enable/disable perspective correct interpolation. ","likes":8,"published":1,"flags":16,"usePreview":0,"tags":["explanation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// @sylefeb\n//\n// use space to enable/disable perspective correct interp.\n//\n// A simple texture mapping demo to see the effect \n// of perspective correct vs non-perspective correct\n// was done for my talk on the Doomchip on-ice, \n// see https://streaming.media.ccc.de/rc3/relive/17\n//\n// The shader emulates software rasterization, checking\n// if screen pixels are within the projected triangle,\n// computing barycentric coordinates and using them to\n// interpolate texture coordinates 'by hand' before lookup\n//\n// Perspective transform is done in transform_perspective\n// texture coordinates are computed in triangle_uv\n\n\n#define PI 3.14159\n#define KEY_SPACE 32\n\nvec3 transform_camera(vec3 p) // transform a point in view space\n{\n  return (p + vec3(0,0,1)) - vec3(0.5,0.5,0.0);\n}\n\nvec3 transform_perspective(vec3 p) // apply a perspective transform to the point\n{\n  return vec3(\n    0.5 + p.x / p.z,\n    0.5 + p.y / p.z,\n    1.0 / p.z\n  );\n}\n\nbool side(vec2 p,vec2 a, vec2 b) // which side of the line a,b are we on?\n{\n  vec2 d0 = p - a;\n  vec2 d1 = b - a;\n  return d0.x*d1.y - d0.y*d1.x > 0.0;\n}\n\nfloat area(vec2 a,vec2 b,vec2 c) // signed area of <a,b,c>\n{\n  return 0.5 * length(cross(vec3(b-a,0.0),vec3(c-a,0.0)));\n}\n\nvec3 triangle_uv(vec2 pix,        // compute uv coordinates from screen pixel coords\n                 vec3 p0,vec3 p1,vec3 p2, // triangle vertices positions ...\n                 vec2 t0,vec2 t1,vec2 t2) // ... and texture coordinates\n{\n    vec3 s0 = transform_perspective(transform_camera(p0));\n    vec3 s1 = transform_perspective(transform_camera(p1));\n    vec3 s2 = transform_perspective(transform_camera(p2));\n\n    bool enable_persp_correct = texelFetch( iChannel0, ivec2(KEY_SPACE,2), 0 ).x > 0.0;\n\n    // pixel in triangle?\n    if ( side(pix,s0.xy,s1.xy) && side(pix,s1.xy,s2.xy) && side(pix,s2.xy,s0.xy)) {\n        // compute barycentric coordinates for interpolation\n        vec3 bar = vec3(\n          area(pix,s1.xy,s2.xy) / area(s0.xy,s1.xy,s2.xy),\n          area(pix,s2.xy,s0.xy) / area(s0.xy,s1.xy,s2.xy),\n          area(pix,s0.xy,s1.xy) / area(s0.xy,s1.xy,s2.xy)\n        );\n        // select which interpolation type to use\n        if (enable_persp_correct) {\n            // corrected perspective\n            \n#if 0 // Select between correcting the texture coords. directly, \n      // or correcting the barycentric coords. first (see notes below for details)\n      \n            // Directly correct texture coordinates\n            // interpolates t/z and 1/z, then divides both per-pixel to obtain correct t\n            vec2  t0_invz = t0 * s0.z; // t0/z0\n            vec2  t1_invz = t1 * s1.z; // t1/z1\n            vec2  t2_invz = t2 * s2.z; // t2/z2\n            vec2  t_invz  = (t0_invz*bar.x + t1_invz*bar.y + t2_invz*bar.z); // interpolates t/z\n            float inv_z   = dot(bar,vec3(s0.z,s1.z,s2.z)); // interpolates 1/z\n            vec2  tuv     = t_invz / inv_z; // per-pixel divide\n\n#else\n\n            // Correct barycentric interpolators first so they can be reused for other attributes\n            //\n            // Note: Thanks to @tom_forsyth for suggesting this, correcting the interpolators\n            //       allows to use them for all quantities to interpolate beyond just the uv coords.\n            //       This is very useful in a more general renderer.\n            //\n            // Note: The computations below could be simplified but I kept the same form as\n            //       for the texture coordinates above, so that one can easily see that\n            //       the exact same computation is performed, simply using unit barycentric\n            //       coordinates for the three vertices: (1,0,0), (0,1,0), (0,0,1)\n            //\n            vec3  b0_invz     = vec3(1.0,0.0,0.0) * s0.z; // (1,0,0)/z0\n            vec3  b1_invz     = vec3(0.0,1.0,0.0) * s1.z;\n            vec3  b2_invz     = vec3(0.0,0.0,1.0) * s2.z;\n            vec3  bar_invz    = (b0_invz*bar.x + b1_invz*bar.y + b2_invz*bar.z);\n            float inv_z       = dot(bar,vec3(s0.z,s1.z,s2.z)); // interpolates 1/z\n            vec3  bar_correct = bar_invz / inv_z;\n            // now use bar_correct to interpolate any per-vertex attributes\n            // here we interpolate the texture coordinates\n            vec2  tuv         = (t0*bar_correct.x + t1*bar_correct.y + t2*bar_correct.z);\n#endif\n            return vec3(tuv,1.0);\n        } else {\n            // incorrect perspective\n            vec2  tuv     = (t0*bar.x + t1*bar.y + t2*bar.z);\n            return vec3(tuv,1.0);\n        }\n   }\n   return vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 pix = fragCoord/iResolution.xy;\n\n    float a  = abs(cos(iTime) * PI / 3.0);\n\n    // each p0,t0 is a pair 3d vertex, texture coordinate\n    // we have four vertices to define a quad (two triangles)\n    vec3 p0  = vec3( 0.2, 0.1,  0);\n    vec2 t0  = vec2( 0.0, 0.0);\n    vec3 p1  = vec3( 0.2, cos(a), sin(a));\n    vec2 t1  = vec2( 0.0, 1.0);\n    vec3 p3  = vec3( 0.8, cos(a), sin(a));\n    vec2 t3  = vec2( 1.0, 1.0);\n    vec3 p2  = vec3( 0.8, 0.1,  0);\n    vec2 t2  = vec2( 1.0, 0.0);\n    \n    fragColor   = vec4(0.0);\n    { // first triangle\n      vec3 tuv    = triangle_uv(pix, p0,p1,p2, t0,t1,t2);\n      if (tuv.z > 0.5) {\n        fragColor   = textureLod( iChannel1, tuv.xy, 0.0);\n      }\n    }\n    { // second triangle\n      vec3 tuv    = triangle_uv(pix, p3,p2,p1, t3,t2,t1);\n      if (tuv.z > 0.5) {\n        fragColor   = textureLod( iChannel1, tuv.xy, 0.0);\n      }\n    }\n}\n","name":"Image","description":"","type":"image"}]}