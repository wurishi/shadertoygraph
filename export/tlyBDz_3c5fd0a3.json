{"ver":"0.1","info":{"id":"tlyBDz","date":"1614171887","viewed":113,"name":"Double sided rasterizer","username":"Epixu","description":"Just testing a double sided rasterizer performance, based on iq's example","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["rasterizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nstruct Triangle\n{\n    vec3 a; vec2 aUV;\n    vec3 b; vec2 bUV;\n    vec3 c; vec2 cUV;\n    vec3 n;\n};\n\n\nTriangle triangles[2];\n\nvoid createCube( void )\n{\n    vec3 verts[4];\n\n    verts[0] = vec3( 0.0, -1.5, -1.0 );\n    verts[1] = vec3( 0.0, -1.5,  1.0 );\n    verts[2] = vec3( 0.0,  1.5, -1.0 );\n    verts[3] = vec3( 0.0,  1.5,  1.0 );\n\n    triangles[0].a = verts[1];\n    triangles[0].aUV = vec2(1.0,0.0);\n    triangles[0].b = verts[2];\n    triangles[0].bUV = vec2(0.0,1.0);\n    triangles[0].c = verts[0];\n    triangles[0].cUV = vec2(0.0,0.0);\n    triangles[0].n = vec3( -1.0, 0.0, 0.0 );\n    \n    triangles[1].a = verts[1]; \n    triangles[1].aUV = vec2(1.0,0.0);\n    triangles[1].b = verts[3]; \n    triangles[1].bUV = vec2(1.0,1.0);\n    triangles[1].c = verts[2]; \n    triangles[1].cUV = vec2(0.0,1.0);\n    triangles[1].n = vec3( -1.0, 0.0, 0.0 );\n}\n\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nvec3 lig = normalize( vec3( 0.3,0.7,0.5) );\n\nvec3 pixelShader( in vec3 nor, in vec2 uv, in float z, in bool material )\n{\n    vec3 normal = material ? nor : -nor;\n    float dif = clamp( dot( normal, lig ), 0.0, 1.0 );\n    float brdf = 0.4 + 0.8*dif;\n    //brdf *= 6.0 * exp( -0.5*abs(z) );\n\t\t\t\n\tvec3 mate = material\n        ? texture( iChannel0, uv ).xyz\n        : texture( iChannel1, uv ).xyz;\n\t\n    vec3 col = brdf * mate;\t\n    \n    vec3 V = vec3(0.0, 0.0, -1.0);\n\tvec3 R = reflect(lig, normal);\n    vec3 H = normalize(lig + V);\n    float NdotH = dot(normal, H);\n    \n    // phong specular\n    float k = pow(max(0.0, dot(R,V)), 2.0);\n    return col + k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n    float animation = sin(0.3 * iTime);\n\tmat4 mdv = setTranslation( 0.0, 0.5, -5.0 ) * \n\t\t       setRotation( 0.0, px.y * animation, 0.0 ) * \n\t\t       setRotation( 0.0, 3.1 * animation, 0.0 );\n\n    createCube();\n\n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n\n    // clear zbuffer\n    float mindist = -1000000.0;\n\n    // render 2 triangles\n    for( int i=0; i<2; i++ )\n    {\n        // transform to eye space\n        vec3 ep0 = (mdv * vec4(triangles[i].a, 1.0)).xyz;\n        vec3 ep1 = (mdv * vec4(triangles[i].b, 1.0)).xyz;\n        vec3 ep2 = (mdv * vec4(triangles[i].c, 1.0)).xyz;\n        vec3 nor = (mdv * vec4(triangles[i].n, 0.0)).xyz;\n\n        // transform to clip space\n        float w0 = 1.0 / ep0.z;\n        float w1 = 1.0 / ep1.z;\n        float w2 = 1.0 / ep2.z;\n\n        vec2 cp0 = 2.0 * ep0.xy * -w0;\n        vec2 cp1 = 2.0 * ep1.xy * -w1;\n        vec2 cp2 = 2.0 * ep2.xy * -w2;\n\n        // fetch vertex attributes, and divide by z\n        vec2 u0 = triangles[i].aUV * w0;\n        vec2 u1 = triangles[i].bUV * w1;\n        vec2 u2 = triangles[i].cUV * w2;\n\n        //-----------------------------------\n        // rasterize\n        //-----------------------------------\n\n        // calculate areas for subtriangles\n        vec3 di = vec3( cross2d( cp1 - cp0, px - cp0 ), \n\t\t\t\t\t    cross2d( cp2 - cp1, px - cp1 ), \n\t\t\t\t\t    cross2d( cp0 - cp2, px - cp2 ) );\n\t\t\n        bool frontFaced = all(greaterThan(di,vec3(0.0)));\n        bool backFaced = all(lessThan(di,vec3(0.0)));\n        \n        if (!frontFaced && !backFaced)\n            continue;      \n        \n        // calc barycentric coordinates\n        vec3 ba = di.yzx / (di.x + di.y + di.z);\n\n        // barycentric interpolation of attributes and 1/z\n        float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n        vec2  uv = ba.x*u0 + ba.y*u1 + ba.z*u2;\n\n        // recover interpolated attributes\n        mindist = 1.0 / iz;\n        uv *= mindist;\n        \n        // perform lighting/shading\n        color = pixelShader( nor, uv, mindist, frontFaced );\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}