{"ver":"0.1","info":{"id":"X33SDB","date":"1719461374","viewed":82,"name":"Expensive 2d Starfield","username":"multiphonic","description":"A starfield used using Buffer A for memory and calculations and Image for rendering. Each dot is calculated independently so it's not very efficient but it is also quite varied.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["basic","retro","starfield","videogame"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define DOT_X_ADDR(idx) ivec2(idx * 2, 0)\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    const float dotSize = 0.001; // Dot size (normalized)\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec2 scaledUv = uv;\n    scaledUv.x *= aspectRatio;\n\n    // Initialize color to black\n    fragColor = vec4(0.0);\n\n    // Iterate through all dots\n    for (int i = 0; i < NUM_DOTS; ++i) {\n        // Fetch the normalized X coordinate of the dot from Buffer A\n        float dotX = fetchData(iChannel0, DOT_X_ADDR(i)).r;\n\n        // Calculate the dot's position\n        float yPos = float(i) / float(NUM_DOTS - 1); // Spread dots vertically\n        vec2 position = vec2(dotX, yPos);\n\n        // Adjust the dot's position for aspect ratio\n        vec2 scaledPosition = position;\n        scaledPosition.x *= aspectRatio;\n\n        // Determine if the current pixel should be part of the dot\n        float distance = length(scaledUv - scaledPosition);\n        bool isDot = distance < dotSize;\n\n        // Set the color if it's part of any dot\n        if (isDot) {\n            fragColor = vec4(1.0); // White dot\n            break; // Stop after finding a dot\n        }\n    }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Common Definitions\n#define NUM_DOTS 70\n\n// Addresses\n#define N 40\nconst ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n\nconst ivec2 SPEED_ADDR1 = ivec2(0, 0); // Address for the first speed value\nconst ivec2 SPEED_ADDR2 = ivec2(1, 0); // Address for the second speed value\n\n// Fetch and store macros\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define DOT_X_ADDR(idx) ivec2(idx * 2, 0) // Address to store the dot's X coordinate\n#define DOT_SPEED_ADDR(idx) ivec2(idx * 2 + 1, 0) // Address to store the dot's speed\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n\n#define SPEED_OFFSET 0.05 // Base speed\n#define SPEED_DEPTH 0.1  // Range of random speed variation\n\n// Function to generate a random float between 0.0 and 1.0 based on a seed\nfloat random(float seed) {\n    return fract(sin(seed) * 43758.5453123);\n}\n\nvoid onEvent(inout float speed, float seed) {\n    // Generate a new random speed\n    float newSpeed = random(seed) * SPEED_DEPTH + SPEED_OFFSET; // Speed range [SPEED_OFFSET, SPEED_OFFSET + SPEED_DEPTH]\n    speed = newSpeed;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    if (iFrame == 0) {\n        // Initialize the dots' positions and speeds on the first frame\n        for (int i = 0; i < NUM_DOTS; ++i) {\n            if (ivec2(fragCoord) == DOT_X_ADDR(i)) {\n                float randomPos = random(float(i) + 0.1) * 1.0; // Random position between 0 and 1\n                fragColor = vec4(randomPos, 0.0, 0.0, 1.0); // Initial randomized X position\n                return;\n            } else if (ivec2(fragCoord) == DOT_SPEED_ADDR(i)) {\n                float randomSpeed = random(float(i) + 0.2) * SPEED_DEPTH + SPEED_OFFSET; // Random speed\n                fragColor = vec4(randomSpeed, 0.0, 0.0, 1.0); // Initial randomized speed\n                return;\n            }\n        }\n        fragColor = vec4(0.0); // Default value for other pixels\n    } else {\n        vec4 color = vec4(0.0);\n        // Update the dots' positions and speeds\n        for (int i = 0; i < NUM_DOTS; ++i) {\n            float dotX = fetchData(iChannel0, DOT_X_ADDR(i)).r;\n            float speed = fetchData(iChannel0, DOT_SPEED_ADDR(i)).r;\n\n            // Update the dot's position using time\n            dotX += speed * iTimeDelta;\n\n            // Check if the dot has reached the right side of the screen\n            if (dotX >= 1.0) {\n                dotX = mod(dotX, 1.0); // Loop back to 0\n                onEvent(speed, iTime + float(i)); // Change the speed\n            }\n\n            // Write the updated positions and speeds back to the buffer\n            if (ivec2(fragCoord) == DOT_X_ADDR(i)) {\n                color = vec4(dotX, 0.0, 0.0, 1.0);\n            } else if (ivec2(fragCoord) == DOT_SPEED_ADDR(i)) {\n                color = vec4(speed, 0.0, 0.0, 1.0);\n            }\n        }\n        fragColor = color;\n    }\n}\n","name":"Buffer A","description":"","type":"buffer"}]}