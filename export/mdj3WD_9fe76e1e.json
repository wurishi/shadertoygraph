{"ver":"0.1","info":{"id":"mdj3WD","date":"1667638398","viewed":54,"name":"Question 2 - Joshua Lim","username":"joshualim007","description":"Starting point for Question 2 - Basic Shading\n\nDrag mouse for orbit camera.\n    \n ","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["shading"],"hasliked":0,"parentid":"XlffR2","parentname":"Question 2 - Basic Shading"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//final stage post process and render output\n\n//Tonemap post process\nvec3 ReinhardTonemapping(in vec3 Color){\n    const float gamma = 2.2;\n    Color = Color / (Color + vec3(1.0));\n    Color = pow(Color, vec3(1.0 / gamma));\n    return Color;\n}\n\n//final image render\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 prePostProcessImage = texture(iChannel0, uv, 0.0).rgb;\n    vec3 bloomBlurImage = texture(iChannel1, uv, 0.0).rgb;\n\n    //add blooming\n    fragColor.rgb = (bloomBlurImage) * 0.5 + prePostProcessImage;\n    \n    //tonemap final color\n    fragColor.rgb = ReinhardTonemapping(fragColor.rgb);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Main render\n//Render scene and objects with lighting and shadows\n\nvec3 g_SunDirection = vec3(0.5);\nvec3 g_SunColor = vec3(5);\nvec3 g_AmbientColor = vec3(0.1);\n\nvec3 g_PointLight = vec3(0.0, 1.2, 0.0);\nvec3 g_PointLightColor = vec3(0);\n\n//=======================================================================================\nbool RayIntersectAABox  (in vec3 boxMin, in vec3 boxMax, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    vec3 boxCenter = (boxMin+boxMax)*0.5;\n\tvec3 roo = rayPos - boxCenter;\n    vec3 rad = (boxMax - boxMin)*0.5;\n\n    vec3 m = 1.0/rayDir;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    vec2 time = vec2( max( max( t1.x, t1.y ), t1.z ),\n                 min( min( t2.x, t2.y ), t2.z ) );\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (time.x > maxTime)\n        return false;\n    \n    // if time invalid or we hit from inside, bail out\n    if (time.y < time.x || time.x < 0.0)\n        return false;\n\t\n    // calculate surface normal\n    hitPos = rayPos + rayDir * time.x;   \n    vec3 hitPosRelative = hitPos - boxCenter;\n    vec3 hitPosRelativeAbs = abs(hitPosRelative);\n    vec3 distToEdge = abs(hitPosRelativeAbs - rad);\n\n    float closestDist = 1000.0;\n    for(int axis = 0; axis < 3; ++axis)\n    {\n        if (distToEdge[axis] < closestDist)\n        {\n            closestDist = distToEdge[axis];\n            normal = vec3(0.0);\n            if (hitPosRelative[axis] < 0.0)\n                normal[axis] = -1.0;\n            else\n                normal[axis] = 1.0;\n        }\n    }        \n\n    // store the collision time as the new max time\n    maxTime = time.x;\n    return true;\n}\n\n//=======================================================================================\nbool RayIntersectSphere (in vec4 sphere, in vec3 rayPos, in vec3 rayDir, out vec3 hitPos, out vec3 normal, inout float maxTime)\n{\n    if (sphere.w <= 0.0)\n        return false;\n    \n\t//get the vector from the center of this circle to where the ray begins.\n\tvec3 m = rayPos - sphere.xyz;\n\n    //get the dot product of the above vector and the ray's vector\n\tfloat b = dot(m, rayDir);\n\n\tfloat c = dot(m, m) - sphere.w * sphere.w;\n\n\t//exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n\tif(c > 0.0 && b > 0.0)\n\t\treturn false;\n\n\t//calculate discriminant\n\tfloat discr = b * b - c;\n\n\t//a negative discriminant corresponds to ray missing sphere\n\tif(discr < 0.0)\n\t\treturn false;\n\n\t//ray now found to intersect sphere, compute smallest t value of intersection\n\tfloat collisionTime = -b - sqrt(discr);\n\n\t//if t is negative, ray started inside sphere so clamp t to zero and remember that we hit from the inside\n\tif(collisionTime < 0.0)\n        return false;\n    \n    // if the time is beyond the maximum allowed bail out (we hit somethign else first!)\n    if (collisionTime > maxTime)\n        return false;\n    \n    // store the collision time as the new max time\n    maxTime = collisionTime;\n    \n\t//compute the point of intersection\n\thitPos = rayPos + rayDir * collisionTime;    \n    \n   \t// calculate the normal\n\tnormal = hitPos - sphere.xyz;\n\tnormal = normalize(normal); \n\n\treturn true;\n}\n\n//=======================================================================================\nbool GetClosestIntersection(in vec3 rayPos, in vec3 rayDir, out vec3 albedo, out float smoothness, out float metalness, out vec3 normal, out vec3 hitPos){\n    float maxRayHitTime = 1000.0;\n    bool hit = false;\n    float prevRayHitTime = maxRayHitTime;\n    vec3 tempNormal;\n    vec3 tempHitPos;\n    \n\t// green box\n    if (RayIntersectAABox(vec3(0.4,-0.3,-0.5), vec3(1.4,0.3,0.5), rayPos, rayDir, tempHitPos, tempNormal, maxRayHitTime))\n    {\n        if(maxRayHitTime < prevRayHitTime){\n            hit = true;\n            albedo = vec3(0.1, 0.9, 0.1);    \n            smoothness = 0.2;\n            metalness = 0.0;\n\n            prevRayHitTime = maxRayHitTime;\n            normal = tempNormal;\n            hitPos = tempHitPos;\n        }\n    }\n\t\n    // red sphere\n    if (RayIntersectSphere(vec4(-0.4, 0.4, 0.5, 0.5), rayPos, rayDir, tempHitPos, tempNormal, maxRayHitTime))\n    {\n        if(maxRayHitTime < prevRayHitTime){\n            prevRayHitTime = maxRayHitTime;\n            hit = true;\n            albedo = vec3(1.0, 0.1, 0.1);\n\n            smoothness = 1.0;\n            metalness = 1.0;\n            \n            normal = tempNormal;\n            hitPos = tempHitPos;\n        }\n    }\n    \n    // blue sphere\n    if (RayIntersectSphere(vec4(-0.8, 0.4, -0.75, 0.25), rayPos, rayDir, tempHitPos, tempNormal, maxRayHitTime))\n    {\n        if(maxRayHitTime < prevRayHitTime){\n            prevRayHitTime = maxRayHitTime;\n            hit = true;\n            albedo = vec3(0.1, 0.1, 0.9);\n\n            smoothness = 0.5;\n            metalness = 0.0;\n\n            normal = tempNormal;\n            hitPos = tempHitPos;\n        }\n    }\n    \n    // grey floor\n    if (RayIntersectAABox(vec3(-5.0, -1.0, -5.0), vec3(5.0, -0.5, 5.0), rayPos, rayDir, tempHitPos, tempNormal, maxRayHitTime))\n    {\n        if(maxRayHitTime < prevRayHitTime){\n            hit = true;\n            albedo = vec3(.5, .5, .5); \n                        \n            smoothness = 1.0;\n            metalness = 0.0;\n\n            prevRayHitTime = maxRayHitTime;\n            \n            \n            //apply random normal noise using world coordinates\n            const float normalMapScale = 0.55;\n            const float normalMapStrength = 0.25;\n            vec3 normalOffset = texture(iChannel1, tempHitPos.xz * normalMapScale).rgb * 2.0 - 1.0;\n            normal = tempNormal + normalOffset * normalMapStrength;\n            normal = normalize(normal);\n            \n            hitPos = tempHitPos;\n        }\n    }\n    \n    // emissive wall\n    if (RayIntersectAABox(vec3(-1.2, -1.0, -1.4), vec3(-0.0, 0.25, -1.3), rayPos, rayDir, tempHitPos, tempNormal, maxRayHitTime))\n    {\n        if(maxRayHitTime < prevRayHitTime){\n            hit = true;\n            albedo = vec3(9, 7, 0); \n                        \n            smoothness = 1.0;\n            metalness = 0.0;\n\n            prevRayHitTime = maxRayHitTime;\n            normal = tempNormal;\n            hitPos = tempHitPos;\n        }\n    }\n    \n    if (!hit)\n\t\treturn false;\n            \n    return true;\n}\n\n//=======================================================================================\nbool GetClosestIntersection(in vec3 rayPos, in vec3 rayDir){\n    vec3 hitPos;    \n    vec3 normal;            \n    vec3 albedo;\n    float smoothness;\n    float metalness;\n    return GetClosestIntersection(rayPos, rayDir, albedo, smoothness, metalness, normal, hitPos);\n}\n\n//=======================================================================================\nvoid ShadePixel (in vec3 albedo, in vec3 normal, in vec3 viewDirection, in vec3 worldPosition, in float smoothness, in float metalness, out vec3 diffuseOut, out vec3 specularOut, out vec3 emissionOut)\n{\n    g_SunDirection = normalize(g_SunDirection);\n    \n    //calculate dot product to directional light for shading\n    float normSunDot = max(dot(normal, g_SunDirection), 0.0);\n    \n    //Phong shading model\n    //uses metalness and smoothenss value to adjust reflection strength and diffuse strength\n    \n    //decode emissive lighting from albedo\n    emissionOut = max(albedo - 1.0, 0.0);   \n\n    //check if in shadow\n    bool inDirectionalLightShadow = false;\n    if(GetClosestIntersection(worldPosition + normal * 0.001, g_SunDirection)){\n        //apply only ambient color when in shadow\n        diffuseOut = g_AmbientColor;\n        inDirectionalLightShadow = true;\n    }\n    else{\n        //apply sun color and ambient when not in shadow\n        diffuseOut = g_SunColor * normSunDot + g_AmbientColor;\n    }\n    \n    \n    //calculate diffuse lighting for point light\n    vec3 pointDir = (g_PointLight - worldPosition);\n    float distToPoint = length(pointDir);\n    float pointDot = max(dot(normalize(pointDir), normal), 0.0);\n    float pointLightFallOff = 1.0 / (distToPoint * distToPoint);\n    diffuseOut += g_PointLightColor * pointDot * pointLightFallOff;\n    \n    //apply albedo to diffuse lighting\n    diffuseOut *= albedo;\n    \n    const float specularPow = 256.0;\n    const float specularSmoothnessPow = 1.3;\n    \n    //calculate specular lighting for directional light, phong shading with slight modification\n    vec3 reflectedViewDir = reflect(viewDirection, normal);\n    float viewNormDot = max(dot(reflectedViewDir, g_SunDirection), 0.0);\n    specularOut = g_SunColor * pow(viewNormDot, specularPow * smoothness) * pow(smoothness, specularSmoothnessPow);\n    \n    //remove any specular shading when in shadow (directional light only)\n    specularOut = inDirectionalLightShadow ? vec3(0,0,0) : specularOut;\n    \n    //calculate specular lighting for point light, phong shading with slight modification\n    reflectedViewDir = reflect(viewDirection, normal);\n    viewNormDot = max(dot(reflectedViewDir, normalize(pointDir)), 0.0);\n    specularOut += g_PointLightColor * pow(viewNormDot, specularPow * smoothness) * pow(smoothness, specularSmoothnessPow) * pointLightFallOff; \n    \n    //diffuseOut : contains final diffuse color\n    //specularOut : contains final specular color\n    //emissionOut : contains final emission color    \n}\nvec3 GetReflections(in vec2 screenPos, in vec3 diffuse, in vec3 viewOrigin, in vec3 viewDirection, in vec3 normal, in float smoothness, in float metalness){\n\n    vec3 reflectedViewDir = reflect(viewDirection, normal);\n\n    //environmental reflections\n    vec3 envReflection = texture(iChannel0, reflectedViewDir, (1.0 - smoothness) * 10.0).rgb;\n    \n    \n    vec3 rhitPos;    \n    vec3 rnormal;            \n    vec3 ralbedo;\n    float rsmoothness;\n    float rmetalness;\n    vec3 dynamicReflectionCol = vec3(0.0);\n        \n    //calculate dynamic reflection\n    //single bounce reflection\n    if(GetClosestIntersection(viewOrigin + normal * 0.0001, reflectedViewDir, ralbedo, rsmoothness, rmetalness, rnormal, rhitPos)){\n        vec3 diffuseOut;\n        vec3 specularOut;\n        vec3 emissionOut;\n        //shade the reflected pixel\n        ShadePixel(ralbedo, rnormal, reflectedViewDir, rhitPos, rsmoothness, rmetalness, diffuseOut, specularOut, emissionOut);\n        \n        //compose reflected color\n        envReflection = diffuseOut + specularOut + emissionOut;\n    }\n    \n    \n    \n    //mix diffuse and reflections result 10:1 ratio\n    float mixFactor = max(metalness, 0.1); \n    vec3 diffuseReflection = diffuse * (1.0 - mixFactor) + envReflection * mixFactor;\n    return diffuseReflection;\n}\n//=======================================================================================\nvoid TraceRay (in vec2 screenPos, in vec3 rayPos, in vec3 rayDir, inout vec3 pixelColor)\n{   \n  \n    vec3 hitPos;    \n    vec3 normal;            \n    vec3 albedo;\n    float smoothness;\n    float metalness;\n    \n    //get scene intersection\n    if(GetClosestIntersection(rayPos, rayDir, albedo, smoothness, metalness, normal, hitPos)){\n        vec3 diffuse;\n        vec3 specular;\n        vec3 emission;\n        \n        //get diffuse, specular and emission color\n        ShadePixel(albedo, normal, rayDir, hitPos, smoothness, metalness, diffuse, specular, emission);\n        \n        //add reflection to diffuse color\n        diffuse = GetReflections(screenPos, diffuse, hitPos, rayDir, normal, smoothness, metalness);\n        \n        //compose color into final pixel color\n        pixelColor = diffuse + specular + emission;\n\n    }\n\n}\n\n//=======================================================================================\nvoid ReinhardTonemapping(inout vec3 Color){\n    const float gamma = 2.2;\n    Color = Color / (Color + vec3(1.0));\n    Color = pow(Color, vec3(1.0 / gamma));\n}\n\n//=======================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    //----- camera setup\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 cameraAt \t= vec3(0.0,0.0,0.0);\n\n    float angleX = iMouse.z > 0.0 ? 6.28 * mouse.x : 0.0;\n    float angleY = iMouse.z > 0.0 ? (mouse.y * 6.28) : 0.0;\n\n    vec3 cameraPos\t= (vec3(sin(angleX)*cos(angleY), sin(angleY), cos(angleX)*cos(angleY))) * 4.0;\n\n    vec3 cameraFwd  = normalize(cameraAt - cameraPos);\n    vec3 cameraLeft  = normalize(cross(normalize(cameraAt - cameraPos), vec3(0.0,sign(cos(angleY)),0.0)));\n    vec3 cameraUp   = normalize(cross(cameraLeft, cameraFwd));\n\n    float cameraViewWidth\t= 9.0;\n    float cameraViewHeight\t= cameraViewWidth * iResolution.y / iResolution.x;\n    float cameraDistance\t= 6.0;  // intuitively backwards!    \n    \n\tvec2 rawPercent = (fragCoord.xy / iResolution.xy);\n\tvec2 percent = rawPercent - vec2(0.5,0.5);\n\t\n\tvec3 rayPos;\n\tvec3 rayTarget;\n\t   \n\t// if the mouse button is down do orbit camera\n\tif( iMouse.z > 0.0 ) {\n\t\trayTarget = (cameraFwd * cameraDistance)\n\t\t\t\t  + (cameraLeft * percent.x * cameraViewWidth)\n\t\t          + (cameraUp * percent.y * cameraViewHeight);\n\t\t\n\t\trayPos = cameraPos;\n\t}\n\t// else handle the case of the mouse button not being down\n\telse {\n\t\trayPos = vec3(sin(iTime * 0.1) * 4.0, 2.0, cos(iTime * 0.1) * 4.0);\n\t\tvec3 f = normalize(cameraAt - rayPos);\n\t\tvec3 l = normalize(cross(f,vec3(0.0,1.0,0.0)));\n\t\tvec3 u = normalize(cross(l,f));\n\t\t\n\t\trayTarget = (f * cameraDistance)\n\t\t\t\t  + (l * percent.x * cameraViewWidth)\n\t\t          + (u * percent.y * cameraViewHeight);\t\t\n\t}\n    \n\t//----- ray trace\n\tvec3 rayDir = normalize(rayTarget);\n    \n    // initialze ray color to the cube map\n    vec3 pixelColor = texture(iChannel0, rayDir).rgb;\n    \n    g_PointLight.x += sin(iTime) * 2.0;\n    g_PointLight.z += cos(iTime) * 2.0;\n    g_SunDirection.x = cos(iTime * 0.2);\n    g_SunDirection.z = sin(iTime * 0.2);\n    \n    g_PointLightColor.x = abs(sin(iTime * 0.25 + 3.14/3.0)) * 9.0;\n    g_PointLightColor.y = abs(sin(iTime * 0.25)) * 9.0;\n    g_PointLightColor.z = abs(sin(iTime * 0.25 + (2.0 * 3.14)/3.0)) * 9.0;\n\n    g_SunColor = max(mix(vec3(8.0), vec3(-1.0), (sin(iTime * 0.2) + 1.0) * 0.5), 0.0);\n\n        \n    // ray trace\n\tTraceRay(fragCoord, rayPos, rayDir, pixelColor);\n            \n\tfragColor = vec4(pixelColor, 1.0);\n}\n\n/*\n    Changelog:\n    + point light and directional light (Phong lighting model slightly modified)\n    + ambient lighting\n    + emissive lighting\n    + environment mapped reflections\n    + directoinal light shadows\n    + raytraced reflections\n    + reinhard post process tonemapping\n    + animated camera and lights\n    + proper rendering of objects, further objects wont be rendered over closer objects\n*/\n\n/*\n\nAdd:\n* point light and directional light (diffuse + specular. Doesn't need to be PBR. Lambert / phong is ok!)\n* ambient lighting\n* emissive lighting\n* environment mapped reflections\n\n* One other feature to make it unique / show off your stuff. Some ideas:\n * shadows\n * Normal or bump mapping\n * ray based reflections\n * anti aliasing\n * lens effects\n * post processing effects\n * warping geometry, more complex geometry\n * animating the camera, lights or geometry.\n * refraction or transparency\n * anything else you can think of\n\n*/","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float threshold = 5.5;\n\n//bloom threshold mask pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = vec2(fragCoord.x, fragCoord.y) / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    if(length(col) < threshold){\n        fragColor.rgb = vec3(0.0);\n    }\n    else{\n        fragColor.rgb = col;\n    }\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const float bloomSize = 128.0;\nconst float stepSize = 2.0;\nfloat kernalSize = ((bloomSize) * 0.25);\n\n//https://en.wikipedia.org/wiki/Gaussian_blur\n//get normal distrubution based on kernal size\nfloat GetGauss(in float x){\n\n    float frac = 1.0 / sqrt(2.0 * 3.14 * kernalSize * kernalSize);\n    float p = pow(2.718, -x*x / (2.0 * kernalSize * kernalSize));\n    float g = frac * p;\n    return g;\n}\n\n//vertical bloom pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 avgCol = vec3(0.0);\n    \n    //vertical gaussian blur\n    for(float i = -bloomSize; i < bloomSize; i++){\n        vec2 uv = vec2(fragCoord.x, fragCoord.y + i * stepSize) / iResolution.xy;\n        vec3 col = texture(iChannel0, uv).rgb;\n        float g = GetGauss(abs(i));\n        avgCol += col * g;\n    }\n    //avgCol /= (bloomSize * 2.0);\n    fragColor.rgb = avgCol;\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\nconst float bloomSize = 128.0;\nconst float stepSize = 2.0;\nfloat kernalSize = ((bloomSize) * 0.25);\n\n//https://en.wikipedia.org/wiki/Gaussian_blur\n//get normal distrubution based on kernal size\nfloat GetGauss(in float x){\n\n    float frac = 1.0 / sqrt(2.0 * 3.14 * kernalSize * kernalSize);\n    float p = pow(2.718, -x*x / (2.0 * kernalSize * kernalSize));\n    float g = frac * p;\n    return g;\n}\n\n//horizontal bloom pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 avgCol = vec3(0.0);\n    \n    //horizontal gaussian blur\n    for(float i = -bloomSize; i < bloomSize; i++){\n        vec2 uv = vec2(fragCoord.x + i * stepSize, fragCoord.y) / iResolution.xy;\n        vec3 col = texture(iChannel0, uv).rgb;\n        float g = GetGauss(abs(i));\n        avgCol += col * g;\n    }\n    //avgCol /= (bloomSize * 2.0);\n    fragColor.rgb = avgCol;\n}","name":"Buffer D","description":"","type":"buffer"}]}