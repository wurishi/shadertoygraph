{"ver":"0.1","info":{"id":"wldGzs","date":"1577339704","viewed":158,"name":"dancy bonsais ","username":"mrpawel","description":"derived from Dancy Tree Doodle 3D by wyatt https://www.shadertoy.com/view/4lVyzh\n\ncreating a binary int id for each branch then scaling length / shifting branch positions based on the id. now with perlin distortion.\n","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["ifs","tree","kifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//derived from Dancy Tree Doodle 3D by wyatt https://www.shadertoy.com/view/4lVyzh\n#define pi 3.1415926\nvec3 light;\n\n//perlin noise from https://www.shadertoy.com/view/4lB3zz\nconst int firstOctave = 3;\nconst int octaves = 3;\nconst float persistence = 0.6;\n\n//Not able to use bit operator like <<, so use alternative noise function from YoYo\n//\n//https://www.shadertoy.com/view/Mls3RS\n//\n//And it is a better realization I think\nfloat noise(int x,int y)\n{   \n    float fx = float(x);\n    float fy = float(y);\n    \n    return 2.0 * fract(sin(dot(vec2(fx, fy) ,vec2(12.9898,78.233))) * 43758.5453) - 1.0;\n}\n\nfloat smoothNoise(int x,int y)\n{\n    return noise(x,y)/4.0+(noise(x+1,y)+noise(x-1,y)+noise(x,y+1)+noise(x,y-1))/8.0+(noise(x+1,y+1)+noise(x+1,y-1)+noise(x-1,y+1)+noise(x-1,y-1))/16.0;\n}\n\nfloat COSInterpolation(float x,float y,float n)\n{\n    float r = n*3.1415926;\n    float f = (1.0-cos(r))*0.5;\n    return x*(1.0-f)+y*f;\n    \n}\n\nfloat InterpolationNoise(float x, float y)\n{\n    int ix = int(x);\n    int iy = int(y);\n    float fracx = x-float(int(x));\n    float fracy = y-float(int(y));\n    \n    float v1 = smoothNoise(ix,iy);\n    float v2 = smoothNoise(ix+1,iy);\n    float v3 = smoothNoise(ix,iy+1);\n    float v4 = smoothNoise(ix+1,iy+1);\n    \n   \tfloat i1 = COSInterpolation(v1,v2,fracx);\n    float i2 = COSInterpolation(v3,v4,fracx);\n    \n    return COSInterpolation(i1,i2,fracy);\n    \n}\n\nfloat PerlinNoise2D(float x,float y)\n{\n    float sum = 0.0;\n    float frequency =0.0;\n    float amplitude = 0.0;\n    for(int i=firstOctave;i<octaves + firstOctave;i++)\n    {\n        frequency = pow(2.0,float(i));\n        amplitude = pow(persistence,float(i));\n        sum = sum + InterpolationNoise(x*frequency,y*frequency)*amplitude;\n    }\n    \n    return sum;\n}\n\n\n\nfloat ln (vec3 p, vec3 a, vec3 b, float R, float accum) { \n    float r = dot(p-a,b-a)/dot(b-a,b-a);\n    r = clamp(r,0.,1.);\n\tp.x+=((clamp(1.0-2.0*abs(0.5-r),0.,1.))*PerlinNoise2D(accum+p.y,iTime/10.0)) / (accum+5.);\n   //p.x+= 0.2*sqrt(R)*smoothstep(1.,0.,abs(r*2.-1.))*cos(pi*(2.*iTime));\n    return length(p-a-(b-a)*r)-R*(1.5-0.4*r);\n}\nmat2 ro (float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n\nfloat hash(int branchid){\n    int treeNumber = int(iTime/3.0);\n\n    int factor = treeNumber%15+1;\n\treturn 1.0-float(branchid%factor)/float(factor)/2.0;\n}\n\nfloat hash2(int branchid){\n    int treeNumber = int(iTime/3.0);\n    int factor = treeNumber%5+1;\n\treturn 1.0-float(branchid%factor)/float(factor);\n}\n\nfloat hash3(int branchid){\n    int treeNumber = int(iTime/3.0);\n    int factor = treeNumber%13+1;\n\treturn 1.0-float(branchid%factor)/float(factor);\n}\n\nfloat map (vec3 p) {\n    float l = length(p-light)-1e-2;\n    l = min(l,abs(p.y+0.4)-1e-2);\n    l = min(l,abs(p.z-0.4)-1e-2);\n    l = min(l,abs(p.x-0.7)-1e-2);\n    p.y += 0.4;\n    p.z += 0.1;\n    float accum = 0.0;\n    int branchid = 1;\n    //p.zx *= ro(.5*iTime);\n    vec2 rl = vec2(0.02,.3);\n    for (int i = 1; i <14; i++) {\n        \n        l = min(l,ln(p,vec3(0),vec3(0,rl.y,0),rl.x, accum));\n    \tp.y -= rl.y*0.9;\n        //p.xy *= ro(iTime*1.);\n        if(p.x>0.0){\n        \tbranchid*=2;\n            p.y += rl.y*hash2(branchid); //shift branch position based on id\n        }else{\n            branchid*=2;\n            branchid++;\n        }\n        \n        accum+=p.y;\n        \n        p.x = abs(p.x);\n       \n        float per = PerlinNoise2D(p.x,p.y);\n        \n        p.xy+=sign(p.xy)*per*length(p.xy);\n\n        p.xy *= ro(0.6+0.4*sin(iTime)*sin(0.871*iTime/4.0)+0.05*float(i)*sin(2.*iTime/3.0));\n        p.zx *= ro(0.5*pi+0.2*sin(0.5278*iTime/5.0)+0.8*float(i)*(sin(0.1*iTime/3.0)*(sin(0.1*pi*iTime/4.5)+sin(0.333*iTime/6.0)+0.2*sin(1.292*iTime/4.0))));\n        \n        \n        p.xz *= ro(p.y*hash3(branchid)); //twirl\n        \n        rl *=0.8;\n        \n        rl.y*=hash(branchid); //scale branch down based on id\n        \n        l=min(l,length(p)-0.04*sqrt(rl.y));\n    }\n\treturn l;\n}\n\nvec3 march (vec3 p, vec3 d) {\n    float o = 1e3;\n    for (int i = 0; i < 24; i++) {\n        float l = map(p);\n    \tp += l*d;\n        if (l < 1e-3)break;\n    }\n    return p;\n}\nvec3 norm (vec3 p) { // iq\n\t\tvec2 e = vec2 (.001,0.);\n\t\treturn normalize(vec3(\n\t\t\t\tmap(p+e.xyy) - map(p-e.xyy),\n\t\t\t\tmap(p+e.yxy) - map(p-e.yxy),\n\t\t\t\tmap(p+e.yyx) - map(p-e.yyx)\n\t\t\t));\n\t}\nvoid mainImage( out vec4 C, in vec2 U )\n{   vec2 R = iResolution.xy;\n    light = vec3(0.2*sin(iTime),0.5,-.5);\n    if (iMouse.z > 0.) light = vec3(vec2(-0.5,0.5)*0.+0.7*(iMouse.xy-0.5*R)/R.y,-.3);\n    \n    U = (U-0.5*R)/R.y;\n    vec3 p = vec3(0,0,-1);\n    vec3 d = normalize(vec3(U,1));\n    p =  march(p,d);\n    vec3 n = norm(p);\n\tC = 0.6+0.4*sin(1.1*vec4(1,2,3,4)*dot(d,n));\n    vec3 D = light-p;\n    d = normalize(D);\n    vec3 lp = march(p+d*1e-2,d);\n    C *= 2.5*(dot(d,n))*(.3+0.7*length(lp-p)/length(light-p));\n    C = atan(C)/pi*2.;\n}","name":"Image","description":"","type":"image"}]}