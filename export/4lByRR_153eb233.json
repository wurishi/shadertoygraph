{"ver":"0.1","info":{"id":"4lByRR","date":"1507054549","viewed":186,"name":"snowy mountain","username":"avant_bard","description":"Still learning raymarching! Would love to figure out what the rippling artifact is coming from.","likes":1,"published":1,"flags":8,"usePreview":0,"tags":["shaderaday"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define lerp mix\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( vec3 x )\n{\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f       = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    //Sure I guess, do this shit.\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n           lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n           lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\nfloat f( vec2 v ){\n\tvec3 p = vec3(v.x,v.y,0.0)* 0.3;\n\n    float mountains = 0.1 + 10.0 *sin(p.z*35.1)+ 3.0 * noise(p) + 8.0 * noise(p * 0.1);;// + sin(x * 0.5) + sin(y * sin(-iTime*0.1) * 0.5)+ 1.5+0.5 *sin(x*0.01)*6.0;\n\treturn mountains;\n}\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir,\n               float altitude)  // sun light direction\n{\n    float b = 0.01;\n    float fogAmount = (1.0 - exp( -distance*b )) ;\n        float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n\n    \n        vec3  fogColor  = mix( vec3(0.9,0.6,0.9), // bluish\n                           vec3(0.3,0.6,0.9), // yellowish\n                           pow(sunAmount,8.0) );\n    \n    return mix( rgb, fogColor, fogAmount - altitude * 0.1 );\n}\n\n\n\n\nvec3 calcNormal( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.01,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           f(pos.xz+eps.xz) - f(pos.xz-eps.xz),\n           f(pos.xz+eps.zx) - f(pos.xz-eps.zx),\n           f(pos.xz+eps.zz) - f(pos.xz-eps.zz) ) );\n\n}\n\nvec3 castRay( const vec2 uv, const vec3 ro, const vec3 rd )\n{\t\n\n    const float delt = 0.05f;\n    const float mint = 2.1f;\n    const float maxt = 160.0f;\n    for( float t = mint; t < maxt; t += delt )\n    {\n        vec3 p = ro + rd*t;\n        float h = f(p.xz);\n        if( p.y <  h )\n        {\n            vec3 rgb = texture(iChannel0,  vec2(p.x * 0.5,p.z*0.5 )).rrr * 0.4;\n            \n\t\t\trgb += texture(iChannel0,  vec2(p.x * 0.2,p.z * 0.2)).rrr * 0.5;\n            \n            //Make the texture look more \"snowy\", reduce the dynamic range, brighten\n            rgb = clamp(rgb + p.y * 0.03, 0.4,1.0);\n            rgb *= (0.4+ p.y * 0.3);\n            \n\t\t\t//Use IQ's calcNormal function\n\t\t\tvec3 normal = calcNormal( p,t);\n\t\t\tvec3 lightDirection = normalize(vec3( -10.0, 30.0, p.z + 30.0) - p);\n  \t\t\tfloat cos_angle = dot(normal, lightDirection);\n  \t\t\tcos_angle = clamp(cos_angle, 0.0, 1.0);\n\t\t\trgb = rgb * cos_angle * 0.2 + rgb * 0.4;\n\t\t\trgb = applyFog( rgb, t, rd, lightDirection, p.y * 0.2);\n\n\t\t\t return rgb;\n        }\n    }\n    return vec3(0.3 + uv.y * 0.5, 0.6, 0.9) ;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 fp = 0.5-(uv-0.5);\n\tvec4 m = iMouse / iResolution.xxxx;\n\n\tvec2 oxz = vec2(0.0 + cos(iTime*0.14) * 5.0,-3.0 - iTime * 16.6 );\n\tvec3 o = vec3(oxz.x, f(oxz)*0.5 + 15.0  ,oxz.y);\n    \n\tvec3 ct = vec3(25.0 + cos(iTime) * 1.0, o.y,10.0 - iTime);\n    vec3 wup = vec3(sin(iTime) * 0.01, 1.0, 0.0);\n\tvec3 cr = normalize(cross(wup, o));\n    vec3 cd = normalize(ct - o);\n\tvec3 cu = cross(cd, cr);\n    vec3 rayDir = normalize(cr * fp.x + cu * fp.y + cd);\n\n\n\tvec3 rc = castRay(uv, o,rayDir);\n\n\tfragColor = vec4(rc, 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 mainSound( in int samp, float time )\n{\n\tfloat n1 = ( 0.3 + abs(sin(time))) * 0.3 * fract(time* 55.4);\n\tfloat n2 = ( 0.3 + abs(sin(time))) * 0.3 * fract(time* 110.4);\n\tfloat n3 = ( 0.5 + abs(sin(time* 0.5))) * 0.6 * abs(0.5-fract(time* 440.4 + (220.0*smoothstep(0.1, 0.3,fract(time)))));\n\tfloat pan = 0.5 + sin(time*0.1) * 0.9;\n    return vec2( n1 + n2 + n3 * (1.0-pan) , n1 + n2 + n3 * pan) ;\n}","name":"Sound","description":"","type":"sound"}]}