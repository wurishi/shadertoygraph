{"ver":"0.1","info":{"id":"MfcBz7","date":"1732888737","viewed":199,"name":"Square Box Truchet Tiles","username":"byt3_m3chanic","description":"Square Box Truchet Tiles","likes":23,"published":3,"flags":0,"usePreview":0,"tags":["raymarching","truchet","pattern","tile"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** \n\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n    \n    Square Box / No Turn Tile Truchets\n    11/29/2024  @byt3_m3chanic\n    \n    Unsure if it can be called a truchet without turning the tile\n    but this is two simple tiles, with an optional center shape.\n    \n    2D Version\n    https://www.shadertoy.com/view/XfcfzN\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MIN_DIST 1e-4\n#define MAX_DIST 90.\n\nvec3 hit,hp;\nfloat speed,glow = 0.;\nconst float size = 4.;\nconst float hlf = size/2.;\n  \nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21( vec2 p ) { return fract(sin(dot(p,vec2(23.43,84.21))) *4832.3234); }\nfloat box(vec2 p, vec2 b) {vec2 d = abs(p)-b; return length(max(d,0.)) + min(max(d.x,d.y),0.);}\n\n//@iq hsv\nvec3 hsv( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*2.+vec3(0,4,2),6.)-3.)-1., 0., 1.0 );\n    return c.z * mix( vec3(1), rgb, c.y);\n}\n//@iq extrude sdf \nfloat opx(in float d, in float z, in float h){\n    vec2 w = vec2( d, abs(z) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\nvec3 pattern(vec2 p, float sc) {\n    vec2 uv = p,\n         id = floor(p*sc);\n          p = fract(p*sc)-.5;\n\n    float rnd = hash21(id);\n    float ck = mod(id.x+id.x,2.)*2.-1.;\n\n    float cv=.15;\n    float d = box(abs(p)-vec2(0,.65),vec2(.10,.25))-cv;\n    float l = box(abs(p)-vec2(.5,0),vec2(.10,.10))-cv;\n\n    if (rnd<.22) d = min(d,length(p)-(cv*.7));\n  \n    if(rnd>.4) {\n        d = box(abs(p)+vec2(.5,-.65),vec2(.10,.25))-cv;\n        l = box(abs(p)-vec2(.5,.65),vec2(.10,.25))-cv;\n    }\n    if (rnd>.75) d = rnd<.9?min(d,length(p)-(1.-rnd)):min(d,box(p,vec2(.1))-cv);\n\n    d=min(d,l);\n    if(rnd>.4^^ck>.5)d=-d;\n    return vec3(d,ck,rnd);\n}\n\n// the scene\nvec2 map(vec3 p) {\n    vec2 res = vec2(1e5,0);\n\n    vec3 q = p;\n    vec3 d = pattern(q.xz,.35);\n    \n    float fw = .35+.25*sin(p.x*.5);\n         fw += .35+.25*cos(p.z*.4);\n        \n    float k = opx(d.x,q.y,fw);\n    if(k<res.x) {\n        res=vec2(k,1);\n        hit=p;\n    }\n    \n    float j = opx(abs(d.x-.01)-.01,q.y-(fw+.35),.1);\n    if(j<res.x) {\n        res=vec2(j,3);\n        hit=p;\n    }\n    float tx=.05;//+.05*sin(p.z*.95);\n    float m = opx(abs(abs(d.x+tx)-.02)-.01,q.y-(fw+.4),.15);\n    if(m<res.x) {\n        res=vec2(m,4);\n        hit=p;\n    }\n    \n    float f = p.y;\n    if(f<res.x) {\n        res=vec2(f,2);\n        hit=p;\n    }\n    return res;\n}\n// get surface normal\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec4 FC = vec4(0.306,0.337,0.353,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n  \n    //ray marcher\n    for(int i=0;i<164;i++) {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.25: ray.x*.9;\n        m  = ray.y;\n    } \n    hp = hit;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(8,8,-5);\n             lpos.xz += speed;\n        vec3 l = normalize(lpos-p);\n        \n        float diff = clamp(dot(n,l),0.,1.), shdw = 1.;\n        for( float t=.01; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 h = hsv(vec3(hp.x*.1,.8,.65));\n\n        if(m==1.) h=vec3(.1);\n        if(m==2.) {\n            vec2 f = fract(hp.xz*1.5)-.5;\n            if(f.x*f.y>0.) h*=.2;\n         }\n        if(m==3.) h=h;\n        if(m==4.) h=vec3(.05);\n\n        ref=h;\n        C = h*diff;\n\n        ro = p+n*.001;\n        rd = reflect(rd,n);\n    \n    }else{\n        C = FC.rgb;\n    } \n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    speed=T*.23;\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n\n    vec3 ro = vec3(0,0,8);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    // mouse - camera\n    float x = M.xy==vec2(0) || M.z<0. ? 0. : -(M.y/R.y * .3-.15)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? 0. : -(M.x/R.x * 1.-.5 )*PI;\n    mat2 rx =rot(-1.2-x), ry =rot(.68-y);\n    \n    ro.zy*=rx, ro.xz*=ry;\n    rd.zy*=rx, rd.xz*=ry;\n    ro.xz += speed;\n    \n    vec3 C = vec3(0),ref=vec3(0),fil=vec3(1);\n    \n    float d = 0., a = 0., numBounces = 2.;\n    \n    for(float i=0.; i<numBounces; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n        if(i==0.) a = d;\n    }\n\n    C = mix(FC.rgb,C,  exp(-.000075*a*a*a));\n    C=clamp(C,vec3(.03),vec3(.9));\n    \n    // gamma / output\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}