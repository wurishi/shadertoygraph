{"ver":"0.1","info":{"id":"WtVfDt","date":"1617545210","viewed":208,"name":"Tesseract (4k exe gfx)","username":"slerpy","description":"I found yet another interesting way to render placeholder geometry :D\n\n[url]https://www.pouet.net/prod.php?which=88576[/url]","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["4k","gfx","exe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution\n\nfloat sinmix(vec2 p) {\n    float l=length(p),s=sqrt(.5),r=.25+.5*s-l;\n    mat2 m=mat2(s,s,-s,s);p=abs(m*p)*m;\n    //return min(max(max(l-1.,r),length(max(p-vec2(1,0),0.))+min(p.y,0.)),-min(r,p.y));\n    return min(max(max(l-1.,r),p.y),-min(r,p.y));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 u = ivec2(fragCoord);\n    vec4 col = texelFetch(iChannel0, u, 0);\n    col = max(col, 0.0);\n    col = 500.0 * col / col.w;\n    col /= col + 1.0;\n    col = pow(1.3 * col, vec4(1) / 2.2);\n    \n    float size = round(R.y / 67.0);\n    vec2 v = (fragCoord - vec2(R.x - 2.0 * size, 2.0 * size)) / size;\n    float s = 1.0 - smoothstep(-0.5, 0.5, size * sinmix(v));\n    fragColor = col + sqrt(0.5) * s;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define R iResolution\n\nconst float pi = acos(-1.0);\nconst float tau = pi + pi;\n\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 rv;\nvoid shuffle() {\n    rv = fract(sin(1e4*rv)+rv.wxyz+0.5);\n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat map(vec3 p) {\n#if 1\n    p.yz *= rot(-pi / 8.0);\n    p.xz *= rot( pi / 6.0);\n    vec3 q = abs(fract(p)-.5);\n    q = max(q, q.zxy);\n    return min(min(q.x, q.y), q.z) - 0.14;\n#else\n    p.yz *= rot(-0.4);\n    p.xz *= rot(0.6);\n    return length(fract(0.5*p)-0.5)-0.3;\n#endif\n}\n\nfloat point_cloud(vec3 p) {\n    const float scale = 80.0;\n    const float subdivides = 8.0;\n\n    for(int i=0; i<4; i++) {\n        vec3 a = sin(round(subdivides * p) + 2.0);\n        p.xy *= rot(a.x); p.yz *= rot(a.y); p.xz *= rot(a.z);\n    }\n    \n    return 1.0 - smoothstep(0.2, 0.3, length(fract(scale * p)-0.5));\n}\n\nvec2 hex() {\n    int i = int(3.0 * rv.z);\n    float s = sqrt(3.0) / 2.0, f = round(rv.w) * 2.0 - 1.0;\n    mat3x2 a = mat3x2(-1, 0, 0.5, s, 0.5, -s);\n    return mat2(a[i], a[(i+1)%3]) * pow(fract(tau*rv.xy), vec2(0.8)) * f;\n}\n\nvec3 cam_sample(vec2 coord) {\n    const float dof = 0.016;\n    const float fov = 10.0;\n    const float size = 2.0;\n    const float thickness = 16.0;\n    \n    //float a = rv.y * tau * 8.0;\n    //vec2 jd = dof * pow(rv.x, 0.43) * vec2(cos(a), sin(a));\n    vec2 jd = dof * hex() * rot(0.2);\n    \n    shuffle();\n    shuffle();\n    shuffle();\n    \n    vec2 aa = 2.0 * rv.xy - 1.0;\n    float st = R.y * fov / size;\n    vec3 rd = normalize(vec3(2.0 * coord - R.xy + aa - jd * st, st));\n    vec3 ro = fov * vec3(jd, -1);\n    float t = fov + thickness * (rv.z - 0.5);\n    \n    shuffle();\n    \n    for(int i=0; i<6; i++) {\n        t -= 1e-2;\n        t += abs(map(ro + rd * t));\n    }\n    \n    return ro + rd * t;\n}\n\nvec3 gay(float x) {\n    //return max(vec3(sin(16.0*x), 0, 1), 0.0);\n    x = x * 3.0 - 1.5;\n    return clamp(vec3(-x, 1.0-abs(x), x), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    rv = vec4(fragCoord.xy, iTime, 1);\n    for(int i=0; i<8; i++)shuffle();\n    \n    vec4 acc = vec4(0);\n    \n    const int white = 32;\n    for(int s=0; s<white; s++) {\n        rv = hash44(vec4(fragCoord.xy, iTime, 1 + s));\n    \n        vec3 p = cam_sample(fragCoord.xy);\n        \n        float l = length(p);\n        vec3 rd = p / l;\n        float m, t = 0.0;\n\n        for(int i=0; i<50; i++)\n        if (t += m = map(rd * t), m < 0.001) break;\n        if (t < l && fract(p.z) > 0.003) continue;\n        \n        float b = point_cloud(p);\n        b *= 1.0 - smoothstep(0.0, 0.01, abs(map(p)));\n        b *= 1.0 - 0.8 * smoothstep(0.0, 1.0, abs(p.z));\n        vec3 col = mix(vec3(1.0), 3.0 * gay(sqrt(max(l-1.0, 0.0)) / 2.5), 0.9);\n        acc.xyz += max(b * col, 0.0);\n    }\n    \n    acc /= float(white);\n    acc.w = 1.0;\n    \n    if (iFrame > 3) {\n        acc += texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n\n    fragColor = acc;\n}","name":"Buffer A","description":"","type":"buffer"}]}