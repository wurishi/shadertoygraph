{"ver":"0.1","info":{"id":"lssyWn","date":"1487755588","viewed":98,"name":"GRAPROG - Midterm","username":"Gracefrnandz","description":"10 different patterns Simplicity, order, unity","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["midterm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define PATTERN 10\n\nvec3 colorPink = vec3(1., .68, .79 );\nvec3 white = vec3(1., 1., 1.);\nvec3 peach = vec3(.78, .56, .47);\nvec3 darkpeach = vec3(0.83, 0.47, 0.40);\nvec3 color1 = vec3(0.38, 0.34, 0.32 );\nvec3 color2 = vec3(.52, .45, .41);\nvec3 color3 = vec3(.65, .58, .51);\n\nfloat createShape(vec2 position, float numOfCorners)\n{\n    float a = atan(position.x, position.y) + PI;\n\tfloat r = TWO_PI/float(numOfCorners);\n    \n    float dist = cos(floor(.5+a/r)*r-a)*length(position);\n    return dist;\n}\n\nmat2 rotate2d(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat2 scale2d(float value)\n{\n    return mat2(value, 0, 0,value);\n}\n\nfloat circle(vec2 uv, vec2 center, float radius)\n{\n    float bilog = step(distance(center,uv), radius);\n    return bilog;\n}\n\nfloat rectangle(vec2 uv, vec2 position, vec2 size, float border)\n{\n    float leftSide = position.x;\n    float rightSide = position.x + size.x;\n    float bottom = position.y;\n    float top = position.y + size.y;\n    \n    //Border\n    float rect = step(leftSide, uv.x) - step(rightSide, uv.x); \n    float rect2 = step(bottom, uv.y) - step(top, uv.y);\n    \n    float rect3 = step(leftSide + border , uv.x) - step(rightSide - border, uv.x); \n    float rect4 = step(bottom + border, uv.y) - step(top - border, uv.y);\n    \n    return (rect * rect2) - (rect3 * rect4);\n}\n\nfloat rectangle2(vec2 uv, vec2 position, vec2 size, float border)\n{\n    float leftSide = position.x;\n    float rightSide = position.x + size.x;\n    float bottom = position.y;\n    float top = position.y + size.y;\n    \n    float rect = step(leftSide, uv.x) - step(rightSide, uv.x); \n    float rect2 = step(bottom, uv.y) - step(top, uv.y);\n    \n    return (rect * rect2);\n}\n\n#if PATTERN == 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv.x *= 5.;\n    uv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n   \tvec2 position = vec2(.5, .5);\n    vec2 position2 = vec2(.6, .6);\n    float size = 0.4;\n    \n\tfloat hexagon = createShape((uv - position), 6.);\n    hexagon = step(hexagon, size);\n    \n    float hexagon2 = createShape((uv - position2), 6.);\n    hexagon = step(hexagon, size);\n\n    fragColor = vec4(vec3((hexagon * hexagon2) * sin(iTime * 2.) + 1.) / 3. * colorPink,1.0);\n}\n\n#elif PATTERN == 2\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= 8.;\n    uv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n    vec2 position = vec2(0., 0.);\n    vec2 position2 = vec2(0.5, 0.0);\n    \n    vec2 position3 = vec2(0.0, 0.0);\n    vec2 position4 = vec2(0.0, 0.25);\n    vec2 position5 = vec2(0.0, 0.50);\n    vec2 position6 = vec2(0.0, 0.75);\n    \n    vec2 size = vec2(0.5, 1.0);\n    vec2 size2 = vec2(1.0, 0.25);\n    float border = 0.02;\n   \n    float shape = rectangle(uv, position, size, border);\n    float shape2 = rectangle(uv, position2, size, border);\n    \n    float shapes = shape + shape2;\n    \n    if (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv *= scale2d(abs(sin(iTime)));\n    \tfloat shape3 = rectangle(uv, position3, size2, border); \n    \tfloat shape4 = rectangle(uv, position4, size2, border);\n    \tfloat shape5 = rectangle(uv, position5, size2, border);\n    \tfloat shape6 = rectangle(uv, position6, size2, border);\n    \tshapes = shape3 + shape4 + shape5 + shape6;\n    }\n    fragColor = vec4(vec3(shapes),1.0);\n}\n\n#elif PATTERN == 3\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= 1.;\n    uv *= 5.;\n    uv = fract(uv);\n    \n    vec2 center = vec2(0.5 * 1. , 0.5);\n    float dist = distance(center,uv)*2.;\n    \n    uv -= center;\n    \n    float angle = atan(uv.y, uv.x);\n    float radius = cos(3. * angle);\n    \n    radius = cos(angle * 5000. + iTime) * cos(angle * 2000. + iTime) * cos(angle * 10. + iTime); \n    float value = 1.-step(radius, dist);\n    \n    vec3 color = vec3(value);\n\tfragColor = vec4(color * colorPink, 1.0);\n}\n\n#elif PATTERN == 4\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= 7.;\n   \tuv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n        \n    float size = .1;\n   \tfloat size2 = .12;\n    \n    vec2 position = vec2(0.5 , 0.2);\n    vec2 position2 = vec2(0.5 , 0.5);\n    vec2 position5 = vec2(0.5 , 0.8);\n    \n\tvec2 position3 = vec2(0.5 , 0.21);\n    vec2 position4 = vec2(0.5 , 0.6);\n    \n    vec2 positions = position + position2 + position3 + position4;\n    uv -= positions;\n    uv *= rotate2d(sin(iTime) / 4.);\n    uv += positions;\n    \n    float createPolygon1 = createShape(-(uv - position), 3.);\n    createPolygon1 = step(createPolygon1, size);\n   \n    float createPolygon2 = createShape(-(uv - position2), 3.);\n    createPolygon2 = step(createPolygon2, size);\n    \n    float createPolygon5 = createShape(-(uv - position5), 3.);\n    createPolygon5 = step(createPolygon5, size);\n    \n    vec3 polygon = vec3(createPolygon1) * color1;\n    vec3 polygon2 = vec3(createPolygon2) * color2;\n    vec3 polygon5 = vec3(createPolygon5) * color3;\n\n    vec3 polygons = polygon + polygon2 + polygon5;\n    \n    if (tile.x == 1. || tile.x == 3. || tile.x == 5.)\n    {\n        float createPolygon3 = createShape(uv - position3, 3.);\n    \tcreatePolygon3 = step(createPolygon3, size2);\n        \n        float createPolygon4 = createShape(uv - position4, 3.);\n    \tcreatePolygon4 = step(createPolygon4, size);\n        \n        vec3 polygon3 = vec3(createPolygon3) * peach;\n    \tvec3 polygon4 = vec3(createPolygon4) * darkpeach;\n        polygons = polygon3 + polygon4;\n    }\n    fragColor = vec4(polygons, 1.0);\n}\n\n#elif PATTERN == 5\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n   \tuv.x *= 7.;\n   \tuv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    float N = 3.0;\n    float size = .5;\n    float size2 = .2;\n    \n    vec2 position2 = vec2(0.5 , 0.5);\n    \n    uv -= position2;\n    uv *= rotate2d(iTime);\n    uv += position2;\n    \n    float createPolygon2 = createShape(uv - position2, 8.);\n    createPolygon2 = step(createPolygon2, size);\n    \n    float createPolygon1 = createShape(uv - position2, 2.);\n    createPolygon1 = step(createPolygon1, size2);\n    \n   vec3 polygon1 = createPolygon1 * white;\n   vec3 polygon2 = createPolygon2 * white;\n    \n   vec3 polygons = polygon1 + 1.-polygon2;\n   \n    fragColor = vec4(vec3( polygons ), 1.0);\n}\n\n#elif PATTERN == 6\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n   \tuv.x *= 7.;\n   \tuv.y *= 7.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n    float size = .5;\n    float size2 = .2;\n    float size3 = .15;\n    \n    vec2 position2 = vec2(0.5 , 0.5);\n    \n  \tuv -= position2;\n    uv *= scale2d(sin(iTime));\n    uv += position2;\n    \n    float createPolygon2 = createShape(uv - position2, 8.);\n    createPolygon2 = step(createPolygon2, size);\n    \n    float createPolygon1 = createShape(uv - position2, 2.);\n    createPolygon1 = step(createPolygon1, size2);\n    \n    vec3 polygon1 = createPolygon1 * color1;\n   \tvec3 polygon2 = createPolygon2 * white;\n    \n   \tvec3 polygons = polygon1 + 1.-polygon2;\n    \n    if (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        float createPolygon2 = createShape(uv - position2, 8.);\n   \t\tcreatePolygon2 = step(createPolygon2, size);\n        \n    \tuv -= position2;\n    \tuv *= rotate2d(1.57);\n    \tuv+= position2; \n    \n    \tfloat createPolygon1 = createShape(uv - position2, 2.);\n    \tcreatePolygon1 = step(createPolygon1, size3);\n        \n        polygon1 = createPolygon1 * color2;\n   \t\tpolygon2 = createPolygon2 * white;\n        \n        polygons = polygon1 + 1.-polygon2;\n    }\n    fragColor = vec4(vec3( polygons ), 1.0);\n}\n\n#elif PATTERN == 7\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \tuv.x *= 5.;\n   \tuv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.5, 0.65);\n\tvec2 position2 = vec2(0.5, 0.5);\n    vec2 position3 = vec2(0.5 , 0.37);\n    vec2 position4 = vec2(0.38, 0.57);\n    vec2 position5 = vec2(.62, 0.57);\n    vec2 position6 = vec2(0.38 , 0.44);\n    vec2 position7 = vec2(.62, 0.44);\n\t\n   \tuv -= position2;\n    uv *= rotate2d(iTime);\n    uv += position2;\n    \n    if (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv -= position2;\n    \tuv *= scale2d(sin(iTime));\n    \tuv += position2;\n    }\n    \n   \tfloat circleOne = circle(uv, position, .15);\n    float circleTwo = circle(uv, position2, .15);\n    float circleThree = circle(uv, position3, .15);\n    float circleFour = circle(uv, position4, .15);\n    float circleFive = circle(uv, position5, .15);\n    float circleSix = circle(uv, position6, .15);\n    float circleSeven = circle(uv, position7, .15);\n    \n    float circle1 = circle(uv, position, .13);\n    float circle2 = circle(uv, position2, .13);\n    float circle3 = circle(uv, position3, .13);\n    float circle4 = circle(uv, position4, .13);\n    float circle5 = circle(uv, position5, .13);\n    float circle6 = circle(uv, position6, .13);\n    float circle7 = circle(uv, position7, .13);\n    \n    float minusCircle = circleOne - circle1 ;\n    float minusCircle2 = circleTwo - circle2;\n    float minusCircle3 = circleThree - circle3;\n    float minusCircle4 = circleFour - circle4;\n    float minusCircle5 = circleFive - circle5;\n    float minusCircle6 = circleSix - circle6;\n    float minusCircle7 = circleSeven - circle7;\n    \n    vec3 circles = (minusCircle + minusCircle2 + minusCircle3 + minusCircle4 + minusCircle5 + \n        minusCircle6 + minusCircle7) * colorPink;\n    fragColor = vec4(vec3(circles), 1.0);\n}\n\n#elif PATTERN == 8\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv.x *= 5.;\n   \tuv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.5, 1.25);\n    vec2 position2 = vec2(0.5, -.25);\n \tvec2 position3 = vec2(01.25, .5);\n    vec2 position4 = vec2(-0.25, .5);\n    vec2 position5 = vec2(.35, .355);\n    \n\tvec2 size = vec2(0.3, 0.3);\n    float border = 0.1;\n    \n\tif (mod(tile.x, 2.) == mod(tile.y, 2.))\n    {\n        uv -= position2;\n    \tuv *= scale2d(sin(iTime));\n    \tuv += position2;\n    \n    }\n    \n   \tfloat circle1 = circle(uv, position, 0.5);\n   \tfloat circle2 = circle(uv, position2,.5);\n    float circle3 = circle(uv, position3, .5);\n    float circle4 = circle(uv, position4,0.5);\n    \n    float rect = rectangle2(uv, position5, size, border); \n   \n    vec3 circles = circle1 + circle2 + circle3 + circle4 * white;\n\n    fragColor = vec4(vec3( 1. -circles - rect) * (sin(iTime * 2.) + 1.) / 2., 1.0);\n}\n\n#elif PATTERN == 9\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    uv.x *= 5.;\n   \tuv.y *= 5.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.5, 1.);\n    vec2 position2 = vec2(0.5, .0);\n \tvec2 position3 = vec2(01., 0.5);\n    vec2 position4 = vec2(0., .5);\n    \n    vec2 positions = position + position2 + position3 + position4;\n    \n\tif (mod(tile.x, 4.) == mod(tile.y, 4.))\n    {\n        uv -= positions;\n    \tuv *= rotate2d(iTime);\n    \tuv += positions;\n    }\n   \tfloat circleOne = circle(uv, position, 0.5);\n   \tfloat circleTwo = circle(uv, position2,0.5);\n    float circleThree = circle(uv, position3, .5);\n    float circleFour = circle(uv, position4,0.5);\n    \n    float circle1 = circle(uv, position, 0.45);\n   \tfloat circle2 = circle(uv, position2, 0.45);\n    float circle3 = circle(uv, position3, 0.45);\n    float circle4 = circle(uv, position4, 0.45);\n    \n    float minusCircle = circleOne - circle1;\n   \tfloat minusCircle2 = circleTwo - circle2;\n    float minusCircle3 = circleThree - circle3;\n    float minusCircle4 = circleFour - circle4;\n    \n    vec3 circles = minusCircle + minusCircle2 + minusCircle3 + minusCircle4 * white;\n\n    fragColor = vec4(vec3( circles), 1.0);\n}\n\n#elif PATTERN == 10\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n  \tfloat ratio = iResolution.x / iResolution.y;\n    uv.x *= 6.;\n   \tuv.y *= 6.;\n    vec2 tile = floor(uv);\n    uv = fract(uv);\n    \n   \tvec2 position = vec2(0.1, .9);\n    vec2 position2 = vec2(1., .0);\n   \n   \tfloat circleOne = circle(uv, position, 0.5);\n   \tfloat circleTwo = circle(uv, position2,0.5);\n    \n    float circle1 = circle(uv, position, 0.4);\n   \tfloat circle2 = circle(uv, position2, 0.4);\n    \n    float minusCircle = circleOne - circle1;\n   \tfloat minusCircle2 = circleTwo - circle2;\n    \n    float circles = minusCircle + minusCircle2;\n\n    fragColor = vec4(uv,0.5+0.5*sin(iTime) * circles,1.0);\n}\n\n#endif","name":"Image","description":"","type":"image"}]}