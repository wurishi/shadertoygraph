{"ver":"0.1","info":{"id":"ltc3Rf","date":"1470522845","viewed":186,"name":"Woobly Fuzzard","username":"Dude","description":"raymarching fuzz\n\n//based on  https://www.shadertoy.com/view/lltGRj By user Shau","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//based on  https://www.shadertoy.com/view/lltGRj By user Shau\n//Raymarching with displacement found here: https://iquilezles.org/articles/distfunctions\n\n\n#define MAXIMUM_STEPS 20\n#define DISTANCE_THRESHOLD 0.0001\n#define FAR_CLIP 40.0\n\nconst vec3 gwp = vec3(0., -6., 0.); //gravity well position\n\n/* ROTATIONS */\n\nvoid rX(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.y = c * q.y - s * q.z;\n    p.z = s * q.y + c * q.z;\n}\n\nvoid rY(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x + s * q.z;\n    p.z = -s * q.x + c * q.z;\n}\n\nvoid rZ(inout vec3 p, float a) {\n    vec3 q = p;\n    float c = cos(a);\n    float s = sin(a);\n    p.x = c * q.x - s * q.y;\n    p.y = s * q.x + c * q.y;\n}\n\n\n/*DISTANCE FUNCTIONS */\n\nfloat sdTorus(vec3 rp, vec2 t )\n{\n   \n  vec2 q = vec2(length(rp.xz)-t.x,rp.y);   \n    \n        \n  return length(q)-t.y;\n}\n\n\nfloat opDisplace( vec3 p, vec2 t )\n{\n    float d1 = sdTorus(p, t);\n    float d2 = sin(2.*p.x)*sin(2.*p.y)*sin(2.*p.z);\n    return d1+d2;\n}\n\nfloat nearestSurface(vec3 rp) {\n    \n    float msd = 99999.;\n\tfloat gs = abs(sin(iTime)) * 12.;\n\n    \n    for (int x = 0; x < 6; x++) {\n        int z=0;\n        /* Would be nice to do this as a 3 dimensional grid (as seen on telly), \n        but performance falls through the floor */\n\n        vec3 sp = vec3(float(x) + sin(iTime), 0., float(z) + .5); //sphere position\n\n        vec2 R = vec2(2.2,.3) + vec2(x*1, 0.);\n\n        float period = iTime * 2. * 3.1415 * 0.1;\n\n        rX(rp,period+3.1415/2.*float(x) + float(z));\n        rZ(rp,period-3.1415*float(x) + float(z));\n\n        msd = min(msd, opDisplace(rp, R)); \n        \n    }\n    \n    return msd;\n}\n\n/* RAY MARCHING */\n\n//march a single ray\nvec4 marchRay(vec3 ro, vec3 rd) {\n\n    float d = 0.0; //distance marched\n    vec4 pc = vec4(0.); //pixel colour\n\n    for (int i = 0; i < MAXIMUM_STEPS; ++i) {\n        \n        vec3 rp = ro + rd * d; //ray position\n        float ns = nearestSurface(rp);\n        d += ns;\n        \n        if (ns < DISTANCE_THRESHOLD) {\n            //hit scene\n            //set colour\n            rp.xyz += 6.;\n            rp.xyz /= 2.;\n            \n            vec3 clr = vec3(0.2, 0.2, 1.);\n            \n            rp = clr * rp;\n            \n            pc = vec4(rp.x, rp.y, rp.z, 1);\n            break;\n        }\n        \n        if (d > FAR_CLIP) {\n            //miss as we've gone past rear clip\n            break;\n        }\n    }\n\n    return pc;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    //camera\n    vec3 rd = normalize(vec3(uv, 2.));\n    vec3 ro = vec3(0, 0, -20);\n    \n\tfragColor = marchRay(ro, rd);\n}\n\n","name":"Image","description":"","type":"image"}]}