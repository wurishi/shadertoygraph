{"ver":"0.1","info":{"id":"MX3SR7","date":"1718791286","viewed":67,"name":"smoke effect","username":"cyj1116","description":"smoke effect\n","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","raymaching"],"hasliked":0,"parentid":"7syyWG","parentname":"Colorful Smoke Tunnel"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// rotation matrix for fbm octaves\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n              \n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453123);\n}\n\n// 3d noise function\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n// iq's fbm noise for 2-4 octaves including rotation per octave\nfloat fbm( vec3 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p );\n\tp = m*p*2.02;\n    f += 0.2500*noise( p ); \n\tp = m*p*2.03;\n    f += 0.1250*noise( p );\n\treturn f/0.875;\n}\n\n// create a foggy world with a tunnel along the z-axis with 0.8 radius\nfloat world( vec3 pos )\n{\n    return fbm(pos * 4.) - clamp(0.8 - length(pos.xy), 0., 1.);\n}\n\nfloat raymarch( in vec3 ro, in vec3 rd )\n{    \n    float density = 0.;    \n    // we march 20 times to get the density\n    int steps = 17;\n    // each step we move 0.1 unit\n    float t = 0.1;\n    // we start from ro (ray origin)\n    vec3 pos = ro;\n    for(int i=0; i<steps; i++)\n    { \n        pos = pos + t*rd; // move one step\n \n        float den = world( pos ); // get the density of that pos\n        if( den>0.01 )  \n        { \n            density += den * 0.02; // increase the density\n        } \n    }\n    return density;\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) \n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3\n    (\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // (0,0) is at the center of screen, and y-axis range is from [1, -1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y*.8;\n\n    // ray origin, we move forward the origin by time\n    vec3 ro = - vec3(0.,0.,-iTime*0.1);\n\n    // ray direction, we rotate the screen by time\n    vec3 rd = normalize( rotateZ(iTime*.02) * vec3(uv,1.5) );\n    \n    // get the density\n    float density = raymarch( ro, rd );\n    \n    // add some random color just for fun\n    fragColor = vec4(density) * vec4(0.24098039215686274, 0.3943137254901961, 0.5292156862745098, 1.) * 5.;\n}\n","name":"Image","description":"","type":"image"}]}