{"ver":"0.1","info":{"id":"XcBSDm","date":"1706399739","viewed":50,"name":"Better 2d triangle","username":"Legendized","description":"This is an improvement of my previous shader, which used dot products and cosines n stuff. This one just checks if the point is on the right side of each edge, and by right side i mean pointing towards the center point, if all 3 check out then YIPPEEEE!","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["simple","triangle"],"hasliked":0,"parentid":"Mc2SDh","parentname":"Simple 2d Triangle"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Triangle {\n    vec2 a;\n    vec2 b;\n    vec2 c; \n};\n\nvec2 Perpendicular(vec2 vector) {\n    return vec2(-vector.y, vector.x);\n}\n\n//Function to check if point is within bounds of triangle\n//Currently is  only slightly faster in triangle is REALLY small, will optimize in future!\nbool IsInBounds(vec2 p, Triangle tri) {\n    float minX = min(min(tri.a.x, tri.b.x), tri.c.x);\n    float maxX = max(max(tri.a.x, tri.b.x), tri.c.x);\n    float minY = min(min(tri.a.y, tri.b.y), tri.c.y);\n    float maxY = max(max(tri.a.y, tri.b.y), tri.c.y);\n    \n    //This is laid out because if you do an || thing, it checks ALL conditions before returning false...\n    if (p.x < minX) return false;\n    if (p.x > maxX) return false;\n    if (p.y < minY) return false;\n    if (p.y > maxY) return false;\n    \n    return true;\n}\n\nbool IsPointInTriangle(vec2 p, Triangle tri) { \n    \n    //if (!IsInBounds(p, tri)) return false;\n    \n    vec2 ab = 0.5*(tri.a + tri.b);\n    vec2 ac = 0.5*(tri.c + tri.a);\n    vec2 bc = 0.5*(tri.b + tri.c);\n    \n    vec2 middle = (tri.a+tri.b+tri.c)/3.000;\n    \n    vec2 normA = Perpendicular(tri.b-tri.a);\n    if (dot(normA,middle-ab)<0.0) normA *= -1.0; //flip if offside\n    \n    vec2 normB = Perpendicular(tri.a-tri.c);\n    if (dot(normB,middle-ac)<0.0) normB *= -1.0; //flip if offside\n    \n    vec2 normC = Perpendicular(tri.c-tri.b);\n    if (dot(normC,middle-bc)<0.0) normC *= -1.0; //flip if offside\n    \n    vec2 dirToA = normalize(p-ab);\n    vec2 dirToB = normalize(p-ac);\n    vec2 dirToC = normalize(p-bc);\n\n    if (dot(dirToA, normA) < 0.0) return false;\n    if (dot(dirToB, normB) < 0.0) return false;\n    if (dot(dirToC, normC) < 0.0) return false;\n    \n    return true;\n    \n} \n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { \n    // pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n    // basic uv color\n    vec3 col = vec3(uv, 0.0);\n    \n    //Uncomment for \"performance test\"\n    //for (int i = 0; i < 20000; i++)\n    {\n    Triangle triangle;\n    triangle.a = vec2(-0.5, -0.5);\n    triangle.b = vec2(0.5, -0.5);\n    triangle.c = vec2(0.0, 0.5);\n    \n    if (IsPointInTriangle(uv, triangle)) col = vec3(1.0); \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}