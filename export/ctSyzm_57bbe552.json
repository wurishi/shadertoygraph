{"ver":"0.1","info":{"id":"ctSyzm","date":"1691574203","viewed":32,"name":"Random color2","username":"SanyaBer","description":"Random color","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["randomcolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Установка размеров сетки\n    float GRID_SIZE = .01 - .2*sin(iTime*0.03)-10.*0.2-40.;\n    \n    float q = GRID_SIZE*sin(iTime*0.03);\n  \n    // Получение размеров канвы\n    vec2 resolution = iResolution.xy+sin(iTime)*q/0.2;\n  \n    // Вычисление размеров каждой части кадра\n    vec2 cellSize = resolution / GRID_SIZE;\n  \n    // Вычисление индексов текущей части в сетке\n    vec2 cellIndex = floor(fragCoord/ cellSize);\n  \n    // Генерация случайного порядка\n    int randomOrder = int(mod(float(cellIndex.y * GRID_SIZE + cellIndex.x) * 345.0, GRID_SIZE * GRID_SIZE));\n  \n    // Перестановка индексов\n    vec2 randomCellIndex = vec2(mod(float(randomOrder), GRID_SIZE), floor(float(randomOrder) / GRID_SIZE));\n  \n    // Смещение текущего фрагмента, основанного на случайном порядке\n    vec2 offset = (randomCellIndex - cellIndex) * cellSize*sin(q);\n    vec2 uv = (fragCoord + offset) / resolution;\n  \n  \n  \n    // Установка цвета для каждой части\n    fragColor = vec4(offset, uv);\n}\n","name":"Image","description":"","type":"image"}]}