{"ver":"0.1","info":{"id":"WdcBRS","date":"1605353452","viewed":111,"name":"visualizing noise in hell","username":"Carandiru","description":"messing around turned into an interesting look at noise, try different noise textures! ( iChannel0 )\nburn city burn!","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","noise","blue"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3d2BW1\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n\n// Fork of \"Learning Brief Ray Marching\" by benjm. https://shadertoy.com/view/wsVyD3\n// 2020-11-14 10:14:08\n\n// BASIC Ray Marching following along with tutorial \n//by Doug James :\n//https://www.shadertoy.com/view/wdKyD3\nfloat mess(vec3 p, float radius){\n    \n    vec3 a = p;\n    float bn = textureLod(iChannel0, (p.xz + vec2(0.,iTime)) / 384.0f, 0.0f).r;\n    return min(a.x,a.y + abs(sin(bn * iTime))) / (a.z - 1.0f) + bn * 1.25f;\n}\n    \n//SDF implementation\nfloat map(in vec3 p){//0 0 -5 is position of sphere\n     return mess(p - vec3((iTime + 120.0f) * -0.1f, 0., -25.), 1.0);\n\n}\n \n//returns t* value of surface or big value in which case we missed\nfloat raymarch(in vec3 ro, in vec3 rd){\n    float t = 0.;\n    for(int i = 0; i< 260; i++){//render between us and the camera\n        vec3 rt = ro + rd*t;\n        float d = map(rt);\n        if(d < 0.005){// if we hit a surface based on signed distance field\n            return t;\n        } else{ //keep marching\n            t += d * 0.55f; //you could do if t > a big value then we missed it as below\n        }\n    }\n    return -1.;\n}\n\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float eps = 0.0001; // or some other value\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float bn = textureLod(iChannel1, (uv * iResolution.xy) / 1024.0, 0.0f).r * (13.0f/255.0f);\n    vec3 ro = vec3(-0.333, 0.55, 2.); //camera is 5 units away from screen\n    \n    float t = 0.0f;\n    vec3 rd = vec3(0);\n    \n    vec2 offset = 0.5f / iResolution.xy;\n    \n    vec2 uv_offset[4] = vec2[]( vec2(-offset.x,0.), vec2(offset.x,0.), vec2(0., -offset.y), vec2(0.,offset.y) );\n        \n    for ( uint i = 0u ; i < 4u ; ++i ) {    \n    \n        vec3 pix = vec3(uv + uv_offset[i],bn); //pixel on screen at z = 0\n    \n    \tvec3 rd0 = normalize(pix - ro); //unit ray at pixel from camera\n    \trd += rd0;\n        \n    \tt += raymarch(ro,rd0); //compute distance along ray to surface\n    }\n    t *= 0.25f;\n    rd *= 0.25f;\n    \n\tvec3 col = vec3(0);\n    \n    if(t > 0.0) { //i.e it hit a surface\n        vec3 p = ro + rd*t;\n        vec3 N = calcNormal(p);\n               vec3  L = normalize(ro+50.*vec3(0.5, 0.15,0.) - p);// light at eye (safe!)\n        float LdotN = dot(L,N);\n        col = inferno(1.0f / (1.0f + t*t) * 0.5f + abs(LdotN)) * max(0.0f, LdotN);\n     }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3d2BW1\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// viridis palette function port //             \n#define fma(a,b,c) (a*b+c)\n\nvec3 viridis(float t) \n{\n\tconst vec3 _c0 = vec3( 0.2777273272234177, 0.005407344544966578, 0.3340998053353061 );\n\tconst vec3 _c1 = vec3( 0.1050930431085774, 1.404613529898575, 1.384590162594685 );\n\tconst vec3 _c2 = vec3( -0.3308618287255563, 0.214847559468213, 0.09509516302823659 );\n\tconst vec3 _c3 = vec3( -4.634230498983486, -5.799100973351585, -19.33244095627987 );\n\tconst vec3 _c4 = vec3( 6.228269936347081, 14.17993336680509, 56.69055260068105 );\n\tconst vec3 _c5 = vec3( 4.776384997670288, -13.74514537774601, -65.35303263337234 );  \n    const vec3 _c6 = vec3( -5.435455855934631, 4.645852612178535, 26.3124352495832 );  \n\n\tvec3 xmT = vec3(t);\n    \n    vec3 x;\n\n    // c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))))\n    x = fma(xmT, _c6, _c5);\n    x = fma(x, xmT, _c4);\n    x = fma(x, xmT, _c3);\n    x = fma(x, xmT, _c2);\n    x = fma(x, xmT, _c1);\n    x = fma(x, xmT, _c0);\n\n    return(x);\n}\n\n// https://www.shadertoy.com/view/WlfXRN\n\nvec3 inferno(float t) {\n\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}","name":"none","description":"","type":"common"}]}