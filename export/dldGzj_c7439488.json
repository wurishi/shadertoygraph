{"ver":"0.1","info":{"id":"dldGzj","date":"1682958024","viewed":412,"name":"Transcendental Cube","username":"gam0022","description":"Transcendental Cube by @gam0022 & @sadakkey\nFirst shown at GLSL Graphics Compo, SESSIONS in C4 LAN 2023 SPRING","likes":17,"published":1,"flags":96,"usePreview":1,"tags":["raymarching","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dt3R8","filepath":"https://soundcloud.com/dakkey_yng/transcendentalcube?si=921de000b85549fdb1cba25bae672929&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","previewfilepath":"https://soundcloud.com/dakkey_yng/transcendentalcube?si=921de000b85549fdb1cba25bae672929&utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  ______                                          __           __        __   ______      __       \n /_  __/________ _____  _____________  ____  ____/ /__  ____  / /_____ _/ /  / ____/_  __/ /_  ___ \n  / / / ___/ __ `/ __ \\/ ___/ ___/ _ \\/ __ \\/ __  / _ \\/ __ \\/ __/ __ `/ /  / /   / / / / __ \\/ _ \\\n / / / /  / /_/ / / / (__  ) /__/  __/ / / / /_/ /  __/ / / / /_/ /_/ / /  / /___/ /_/ / /_/ /  __/\n/_/ /_/   \\__,_/_/ /_/____/\\___/\\___/_/ /_/\\__,_/\\___/_/ /_/\\__/\\__,_/_/   \\____/\\__,_/_.___/\\___/ \n\n    Transcendental Cube by @gam0022 & @sadakkey\n    First shown at GLSL Graphics Compo, SESSIONS in C4 LAN 2023 SPRING\n\n    Graphics: @gam0022\n    Music: @sadakkey\n\n    NOTE: Added music from the Compo submitted version and made minor modifications to fit the music.\n*/\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float TAU = 6.28318530718;\n#define BPM 120.0\n#define saturate(x) clamp(x, 0., 1.)\n#define tri(x) (1. - 4. * abs(fract(x) - .5))\n#define phase(x) (floor(x) + .5 + .5 * cos(TAU * .5 * exp(-5. * fract(x))))\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\n// Hash without Sine by David Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash23(vec3 p3) {\n    p3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// hemisphere hash function based on a hash by Slerpy\nvec3 hashHs(vec3 n, vec3 seed) {\n    vec2 h = hash23(seed);\n    float a = h.x * 2. - 1.;\n    float b = TAU * h.y * 2. - 1.;\n    float c = sqrt(1. - a * a);\n    vec3 r = vec3(c * cos(b), a, c * sin(b));\n    return r;\n}\n\n// global vars\nvec3 ro, target;\nfloat fov;\nvec3 scol;\nfloat beat, beatTau, beatPhase;\nvec3 boxPos;\n\n// Timeline\nfloat prevEndTime = 0., t = 0.;\n#define TL(end) if (t = beat - prevEndTime, beat < (prevEndTime = end))\n\n// Material Types\n#define VOL 0.\n#define SOL 1.\n\nvoid opUnion(inout vec4 m, float d, float type, float roughness_or_emissive, float hue) {\n    if (d < m.x) m = vec4(d, type, roughness_or_emissive, hue);\n}\n\nvec3 pal(vec4 m) {\n    // Integer part: Blend ratio with white (0-10)\n    // Decimal part: Hue (0-1)\n    vec3 col = vec3(.5) + .5 * cos(TAU * (vec3(0., .33, .67) + m.w));\n    return mix(col, vec3(.5), .1 * floor(m.w));\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n    vec2 q = abs(p) - b;\n    return length(max(q, 0.)) + min(max(q.x, q.y), 0.);\n}\n\n// Hexagons - distance by iq\n// https://www.shadertoy.com/view/Xd2GR3\n// return: { 2d cell id (vec2), distance to border, distnace to center }\n#define INV_SQRT3 0.5773503\nvec4 hexagon(inout vec2 p) {\n    vec2 q = vec2(p.x * 2. * INV_SQRT3, p.y + p.x * INV_SQRT3);\n\n    vec2 pi = floor(q);\n    vec2 pf = fract(q);\n\n    float v = mod(pi.x + pi.y, 3.);\n\n    float ca = step(1., v);\n    float cb = step(2., v);\n    vec2 ma = step(pf.xy, pf.yx);\n\n    // distance to borders\n    float e = dot(ma, 1. - pf.yx + ca * (pf.x + pf.y - 1.) + cb * (pf.yx - 2. * pf.xy));\n\n    // distance to center\n    p = vec2(q.x + floor(.5 + p.y / 1.5), 4. * p.y / 3.) * .5 + .5;\n    p = (fract(p) - .5) * vec2(1., .85);\n    float f = length(p);\n\n    return vec4(pi + ca - cb * ma, e, f);\n}\n\nfloat warning(vec2 p) {\n    vec4 h = hexagon(p);\n\n    float f = fract(hash12(h.xy) + beatPhase);\n    f = mix(f, saturate(sin(h.x - h.y + 4. * beatPhase)), .5 + .5 * sin(beatTau / 16.));\n    float hex = smoothstep(.1, .11, h.z) * f;\n\n    float mark = 1.;\n    float dice = fract(hash12(h.xy) + beatPhase / 4.);\n\n    if (dice < .25) {\n        float d = sdBox(p, vec2(.4, dice));\n        float ph = phase(beat / 2. + f);\n        float ss = smoothstep(1., 1.05, mod(p.x * 10. + 10. * p.y + 8. * ph, 2.));\n        mark = saturate(step(0., d) + ss);\n    } else {\n        vec4[] param_array = vec4[](vec4(140., 72., 0., 0.), vec4(0., 184., 482, 0.), vec4(0., 0., 753., 0.), vec4(541., 156., 453., 0.), vec4(112., 0., 301., 0.),  // 0-3\n                                    vec4(311., 172., 50., 0.), vec4(249., 40., 492., 0.), vec4(0.));                                                       // 4-7\n\n        vec4 param = param_array[int(mod(dice * 33.01, 8.))] / vec2(1200., 675.).xyxy;\n        // param = PU;\n        vec2 p1 = p - param.xy;\n        for (int i = 0; i < 3; i++) {\n            p1 = abs(p1 + param.xy) - param.xy;\n            rot(p1, TAU * param.z);\n        }\n\n        float d = sdBox(p1, vec2(.2, .05));\n        mark = saturate(smoothstep(0., .01, d));\n    }\n\n    return saturate(hex * mark);\n}\n\nvec4 map(vec3 pos, bool isFull) {\n    vec4 m = vec4(2, VOL, 0, 0);\n    // x: Distance\n    // y: MaterialType (VOL or SOL)\n    // z: Roughness in (0-1), Emissive when z>1\n    // w: ColorPalette\n\n    float roughness = 0.05;\n    float a = .1;\n    float W = 16.;\n    float H = 8.;\n    float D = 30.;\n\n    vec3 p1 = pos;\n\n    float boxEmi;\n\n    if (mod(beat, 8.) > 2. + step(56., beat) * 2.) {\n        boxEmi = 2.2 * saturate(sin(beatTau * 4.));\n    } else {\n        boxEmi = 2.2 * abs(cos((beatTau - p1.y) / 4.));\n    }\n\n    vec4 _IFS_Rot = vec4(0.34 + beatPhase / 2.3, -0.28, 0.03, 0.);\n    vec4 _IFS_Offset = vec4(1.36, 0.06, 0.69, 1.);\n    float _IFS_Iteration = phase(tri(beat / 16.) + 2.);\n    vec4 _IFS_BoxBase = vec4(1, 1, 1, 0);\n    vec4 _IFS_BoxEmissive = vec4(0.05, 1.05, 1.05, 0);\n\n    float hue = 0.5;\n    bool emi2 = false;\n\n    TL(40.) {\n        _IFS_Rot *= 0.;\n        _IFS_Offset *= 0.;\n        _IFS_Iteration = 1.;\n    }\n    else TL(56.) {\n        float fade = saturate(phase((beat - 56.) / 4.));\n        _IFS_Iteration = 1. + fade;\n        _IFS_Offset = vec4(1.36, 0.06, 0.69, 1.) * fade;\n    }\n    else TL(84.) {\n    }\n    else TL(96.) {\n        emi2 = true;\n    }\n    else TL(128.) {\n        emi2 = true;\n        hue = fract(.12 * beatPhase);\n    }\n    else TL(140.) {\n        emi2 = true;\n        hue = fract(beatPhase * .1 + pos.z) + 1.;\n        boxEmi *= 1.7;\n    }\n    else TL(152.) {\n        hue = 0.;\n    }\n    else TL(200.) {\n        emi2 = true;\n        hue = smoothstep(191., 192., beat) * 0.65;\n        _IFS_Iteration = 3. + phase(min(t / 4., 2.)) - phase(clamp((beat - 184.) / 4., 0., 2.));\n        _IFS_Rot = vec4(.3 + .1 * sin(beatPhase * TAU / 8.), .9 + .1 * sin(beatPhase * TAU / 8.), .4, 0.);\n        _IFS_Offset = vec4(1.4, 0.66, 1.2, 1.);\n    }\n    else TL(280.) {\n        emi2 = true;\n        hue = fract(beat * .12);\n        _IFS_Offset = vec4(2., 0.3, 0.3 + 0.3 * sin(beatTau / 8.), 1.);\n        _IFS_Rot = vec4(0.4 + phase(beat) / 2.3, -0.28 + phase(beat) / 2., 0.05, 0.);\n    }\n    else TL(296.) {\n    }\n    else TL(304.) {\n        emi2 = (beat < 296.);\n        _IFS_Iteration = 4. - phase(min(t / 8., 2.));\n    }\n    else TL(320.) {\n        float a = phase(saturate(t / 8.));\n        _IFS_Iteration = 2. - a;\n        _IFS_Rot *= (1. - a);\n        _IFS_Offset *= (1. - a);\n    }\n\n    p1 -= (boxPos + _IFS_Offset.xyz);\n\n    vec3 pp1 = p1;\n\n    for (int i = 0; i < int(_IFS_Iteration); i++) {\n        pp1 = p1 + _IFS_Offset.xyz;\n        p1 = abs(p1 + _IFS_Offset.xyz) - _IFS_Offset.xyz;\n        rot(p1.xz, TAU * _IFS_Rot.x);\n        rot(p1.zy, TAU * _IFS_Rot.y);\n        rot(p1.xy, TAU * _IFS_Rot.z);\n    }\n\n    vec4 mp = m;\n    opUnion(m, sdBox(p1, _IFS_BoxBase.xyz), SOL, roughness, 0.5);\n    opUnion(m, sdBox(p1, _IFS_BoxEmissive.xyz), SOL, roughness + boxEmi, hue);\n    if (emi2) opUnion(m, sdBox(p1, _IFS_BoxEmissive.yzx), SOL, roughness + boxEmi, hue + 0.5);\n    opUnion(mp, sdBox(pp1, _IFS_BoxBase.xyz), SOL, roughness, 0.5);\n    opUnion(mp, sdBox(pp1, _IFS_BoxEmissive.xyz), SOL, roughness + boxEmi, hue);\n    if (emi2) opUnion(mp, sdBox(pp1, _IFS_BoxEmissive.yzx), SOL, roughness + boxEmi, hue + 0.5);\n\n    m = mix(mp, m, fract(_IFS_Iteration));\n\n    // room\n    vec3 p2 = abs(pos);\n    float hole = sdBox(pos - vec3(0., -H - 0.5, 0.), vec3(1.1) * smoothstep(18., 24., beat));\n\n    // floor and ceil\n    opUnion(m, max(sdBox(p2 - vec3(0, H + 4., 0), vec3(W, 4., D)), -hole), SOL, roughness, 10.);\n\n    // door\n    float emi = step(p2.x, 2.) * step(p2.y, 2.);\n    if (mod(beat, 2.) < 1. && (beat < 48. || beat > 300.)) emi = 1. - emi;\n    opUnion(m, sdBox(p2 - vec3(0, 0, D + a), vec3(W, H, a)), SOL, roughness + emi * 2., 10.0);\n\n    // wall\n    if (isFull) {\n        float id = floor((pos.z + D) / 4.);\n        hue = 10.;\n\n        TL(18.) { emi = step(1., mod(id, 2.)) * step(id, mod(beat * 4., 16.)); }\n        else TL(32.) {\n            emi = step(1., mod(id, 2.));\n        }\n        else TL(126.) {\n            emi = step(1., mod(id, 2.)) * step(id, mod(beat * 4., 16.));\n            emi = mix(emi, step(.5, hash12(floor(pos.yz) + 123.23 * floor(beat * 2.))), saturate(beat - 112. - pos.y));\n        }\n        else TL(140.) {\n            emi = step(.5, hash12(floor(pos.yz) + 123.23 * floor(beat * 2.)));\n        }\n        else TL(202.) {\n            hue = 0.;\n            float fade1 = smoothstep(140., 144., beat);\n            float fade2 = smoothstep(200., 202., beat);\n            float pw = mix(10., 0.6, fade1);\n            pw = mix(pw, 20., fade2);\n            emi = pow(warning(pos.zy / 2.), pw) * mix(1., step(0., sin(t * 15. * TAU)), fade1 * fade2);\n            emi = step(0.5, emi) * emi * 1.05;\n        }\n        else TL(224.) {\n            emi = pow(hash12(floor(pos.yz) + 123.23 * floor(beat * 2.)), 4.) * smoothstep(0., 4., t);\n            hue = 3.65;\n        }\n        else TL(280.) {\n            float fade1 = smoothstep(276., 280., beat);\n            float fade2 = smoothstep(274., 280., beat);\n\n            emi = pow(hash12(floor(pos.yz * mix(1., 16., fade1)) + 123.23 * floor(beat * 2.)), 4.);\n            emi = mix(emi, step(.0, emi) * step(3., mod(floor((pos.z + D) / 2.), 4.)), fade1);\n\n            hue = hash12(floor(pos.yz) + 123.23 * floor(beat * 8.));\n            hue = mix(hue, 10., fade2);\n        }\n        else TL(320.) {\n            emi = step(3., mod(floor((pos.z + D) / 2.), 4.)) * step(1., mod(floor(pos.y - pos.z - 4. * beatPhase), 2.));\n        }\n    }\n\n    opUnion(m, sdBox(p2 - vec3(W + a, 0, 0), vec3(a, H, D)), SOL, roughness + emi * 2., hue);\n\n    return m;\n}\n\nvec3 normal(vec3 p) {\n    vec2 e = vec2(0, .05);\n    return normalize(map(p, false).x - vec3(map(p - e.yxx, false).x, map(p - e.xyx, false).x, map(p - e.xxy, false).x));\n}\n\n// Based on EOT - Grid scene by Virgill\n// https://www.shadertoy.com/view/Xt3cWS\nvoid madtracer(vec3 ro1, vec3 rd1, float seed) {\n    scol = vec3(0);\n    vec2 rand = hash23(vec3(seed, iTime, iTime)) * .5;\n    float t = rand.x, t2 = rand.y;\n    vec4 m1, m2;\n    vec3 rd2, ro2, nor2;\n    for (int i = 0; i < 130; i++) {\n        m1 = map(ro1 + rd1 * t, true);\n        // t += m1.y == VOL ? 0.25 * abs(m1.x) + 0.0008 : 0.25 * m1.x;\n        t += 0.25 * mix(abs(m1.x) + 0.0032, m1.x, m1.y);\n        ro2 = ro1 + rd1 * t;\n        nor2 = normal(ro2);\n        rd2 = mix(reflect(rd1, nor2), hashHs(nor2, vec3(seed, i, iTime)), saturate(m1.z));\n        m2 = map(ro2 + rd2 * t2, true);\n        // t2 += m2.y == VOL ? 0.15 * abs(m2.x) : 0.15 * m2.x;\n        t2 += 0.15 * mix(abs(m2.x), m2.x, m2.y);\n        scol += .015 * (pal(m2) * max(0., m2.z - 1.) + pal(m1) * max(0., m1.z - 1.));\n\n        // force disable unroll for WebGL 1.0\n        if (t < -1.) break;\n    }\n}\n\nvoid raymarching(vec3 ro1, vec3 rd1) {\n    scol = vec3(0);\n    float t = 0.;\n    vec4 m;\n    for (int i = 0; i < 160; i++) {\n        vec3 p = ro1 + rd1 * t;\n        m = map(p, true);\n        t += m.x;\n\n        if (m.x < 0.01) {\n            vec3 light = normalize(vec3(1, 1, -1));\n            vec3 albedo = vec3(0.3);\n            if (m.z > 1.) albedo = pal(m);\n            scol = albedo * (0.5 + 0.5 * saturate(dot(normal(p), light)));\n            break;\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    beat = iTime * BPM / 60.0;\n    beat = mod(beat, 330.);\n    beatTau = beat * TAU;\n    beatPhase = phase(beat / 2.);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    boxPos = vec3(0);\n    boxPos.y = mix(-12., 0., smoothstep(20., 48., beat));\n    boxPos.y = mix(boxPos.y, -12., smoothstep(304., 320., beat));\n\n    // Camera\n    vec2 noise = hash23(vec3(iTime, fragCoord)) - .5;  // AA\n    vec2 uv2 = (2. * (fragCoord.xy + noise) - iResolution.xy) / iResolution.x;\n\n    // 通常時カメラ\n    float dice = hash11(floor(beat / 8. + 2.) * 123.);\n    if (dice < .8)\n        ro = vec3(8. * cos(beatTau / 128.), mix(-6., 6., dice), 8. * sin(beatTau / 128.));\n    else\n        ro = vec3(9.5 - dice * 20., 1., -12.3);\n\n    target = boxPos;\n    fov = 120.;\n\n    // Timeline\n    TL(8.) {\n        ro = vec3(0, -1.36, -12.3 + t * .3);\n        target = vec3(0., -2.2, 0.);\n        fov = 100.;\n    }\n    else TL(16.) {\n        ro = vec3(9.5, -1.36, -12.3 + t * .3);\n        target = vec3(0., -2.2, 0.);\n        fov = 100.;\n    }\n    else TL(20.) {\n        ro = vec3(5.5, -5, -1.2);\n        target = vec3(0., -8., -0.);\n        fov = 100.0 + t;\n    }\n    else TL(32.) {\n        ro = vec3(5.5, -5, -1.2);\n        target = vec3(0., -8., -0.);\n        fov = 60.0 + t;\n    }\n    else TL(40.) {\n        ro = vec3(10.8, -4.2, -7.2 + t * .1);\n        fov = 93.;\n    }\n    else TL(64.) {\n        ro = vec3(0., 1., -12.3);\n        target = vec3(0);\n        fov = 100. - t;\n    }\n    else TL(80.) {\n        ro = vec3(8. * cos(beatTau / 128.), 1., 8. * sin(beatTau / 128.));\n        fov = 80.;\n    }\n    else TL(104.) {\n    }\n    else TL(110.) {\n        ro = vec3(-5., 1., 18.);\n        target = vec3(5.0, -1., 16.);\n        fov = 100. - t;\n    }\n    else TL(124.) {\n    }\n    else TL(130.) {\n        ro = vec3(0., 1., -12.3);\n        fov = 70. - t;\n    }\n    else TL(138.) {\n    }\n    else TL(148.) {\n        ro = vec3(-5., 1., 18.);\n        target = vec3(5.0, -1., 16.);\n        fov = 100. - t;\n    }\n    else TL(160.) {\n        ro *= 1.6;\n    }\n    else TL(178.) {\n        ro = vec3(0, 0, 7. + t / 4.);\n    }\n    else TL(198.) {\n        ro = vec3(8. * cos(beatTau / 128.), -3. + t / 4., 8. * sin(beatTau / 128.));\n    }\n    else TL(208.) {\n        ro = vec3(-5., 1., 18.);\n        target = vec3(5.0, -1., 16.);\n        fov = 100. - t;\n    }\n    else TL(274.) {\n    }\n    else TL(284.) {\n        ro = vec3(-5., 1., 18.);\n        target = vec3(5.0, -1., 16.);\n        fov = 100. - t;\n    }\n    else TL(304.) {\n    }\n    else TL(320.) {\n        ro = vec3(0., 1., -12.3);\n        target = vec3(0);\n        fov = 90. + t;\n    }\n\n    vec3 up = vec3(0, 1, 0);\n    vec3 fwd = normalize(target - ro);\n    vec3 right = normalize(cross(up, fwd));\n    up = normalize(cross(fwd, right));\n    vec3 rd = normalize(right * uv2.x + up * uv2.y + fwd / tan(fov * TAU / 720.));\n\n// #define DEBUG_SCENE\n#ifdef DEBUG_SCENE\n    raymarching(ro, rd);\n    fragColor = vec4(scol, 1.);\n#else\n    madtracer(ro, rd, hash12(uv2));\n    vec3 bufa = texture(iChannel0, uv).xyz;\n\n    // fade out\n    scol = mix(scol, vec3(0), smoothstep(316., 320., beat));\n    fragColor = saturate(vec4(0.7 * scol + 0.7 * bufa, 1.));\n#endif\n}","name":"Buffer A","description":"","type":"buffer"}]}