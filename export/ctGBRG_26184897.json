{"ver":"0.1","info":{"id":"ctGBRG","date":"1702175661","viewed":33,"name":"grass.   ","username":"BearKirb","description":"grass","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf","grass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float line( vec3 p, vec3 a, vec3 b, float r )\n{\n  \n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat box( vec3 p, vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) ;\n}\n\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+10.0)*x);\n}\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \nfloat noise(vec2 v)\n  {\n  v=v/2.0;\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\nfloat sdf(vec3 p, vec2 id){\nfloat noise1 = noise((p.xy+id+vec2(iTime*4.0,0.0))/16.0)/6.0;\nfloat noise2 = noise((p.zy+id+vec2(iTime*4.0,1000.0))/16.0)/6.0;\nvec3 po=vec3(noise1,-0.5,noise2);\nfloat f3 =line(p,vec3(0.0,0.0,0.0),po*2.0,0.01+p.y/26.0);\n  f3=min(f3,box(p,vec3(0.2,0.001,0.2)));\n  return f3;\n}\n\nfloat Scene( vec3 p )\n{\nfloat s=0.05;\n     vec2 rid = round(p.xz/s);\n    vec2  o = sign(p.xz-s*rid); // neighbor offset direction\n    \n    float d = 1e20;\n   \n        \n        vec2 r = p.xz - s*rid;\n        d = min( d, sdf(vec3(r.x,p.y,r.y),rid) );\n    \n    return d;\n}\nvoid Rotate( inout vec3 vector, vec2 angle )\n{\n\tvector.yz = cos(angle.y)*vector.yz\n\t\t\t\t+sin(angle.y)*vec2(-1,1)*vector.zy;\n\tvector.xz = cos(angle.x)*vector.xz\n\t\t\t\t+sin(angle.x)*vec2(-1,1)*vector.zx;\n}\nvec3 calcNormal( in vec3 p ) // for function f(p)\n{\n    const float h = 0.00001;      // replace by an appropriate value\n    #define ZERO (min(iFrame,0)) // non-constant zero\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*Scene(p+e*h);\n    }\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    \n   vec2 uv = 8.0*(fragCoord.xy-iResolution.xy*0.5)/-iResolution.x;\n vec3 ray = normalize( vec3(\n\t\t\t\t-uv.x/5.0,-uv.y/5.0, \n\t\t\t\t1 ) ); \n    vec3 pos = vec3(0.0,-1.4,-0.0); \n    \n  \n vec3 cameraPos = pos; \n   vec2 angle = (vec2(iMouse.x,-iMouse.y)/iResolution.xy-.5)*3.14;\n //Rotate(pos,angle);\n \n\tRotate(ray,angle);\n  //  Rotate(cameraPos,angle);\n     for ( int i=0; i < 55; i++ )\n    {\n        float h = Scene(pos);\n   \n        if ( h < 0.001 )\n        {\n          \n            break;\n        }\n        pos += ray*(h);\n    }\n  \n \n      vec3 lightSource = vec3(10.0,10.0,10.0);\n      \n    fragColor.rgb = vec3(0.0,0.0,0.0);\n  \n     \n\n   \n        vec3 normal;\n      \n  \n        normal = calcNormal(pos);\n\n\n\n\t\t\n    \n        vec3 ballColor= vec3(0.1,0.1,0.1);\n       \n        vec3 lightCol = vec3(0.9,0.9,0.9);\n        vec3 ambient = vec3(0.2,0.5,0.1)/2.0;\n        if(dot(normal,vec3(0.0,-1.0,0.0))>0.99){\n         ambient = vec3(0.4,0.25,0.1);\n         normal.xz+=vec2(noise(pos.xz*10.0)/6.0,noise(pos.xz*10.0+vec2(10000.0,2000.0))/2.0);\n          normalize(normal);\n        }\n       float light = max(dot(normal,normalize(cameraPos-pos)),dot(normal,-normalize(cameraPos-pos)));\n        vec3 spec =lightCol;\n        vec3 total =  ((1.0*light*lightCol) +min( pow(light,64.0)*spec,5.0)/20.0);\n       \n          fragColor.rgb = ambient*2.0; \n        fragColor.rgb *= (total)/1.5+0.25;\n        fragColor.rgb /= max(pow(distance(cameraPos,pos),2.0)/100.0,1.0);\n      \n      fragColor = vec4(fragColor.r,fragColor.g,fragColor.b,1.0);\n     }","name":"Image","description":"","type":"image"}]}