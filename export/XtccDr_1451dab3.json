{"ver":"0.1","info":{"id":"XtccDr","date":"1532174929","viewed":217,"name":"Ant","username":"TLC123","description":"exoskeleton wit special blend and normal driven noise bumps.\nvery low fps - dropped the bump texture\nI wish it was black","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["bug","ant"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Raycaster code credit to Inigo Quilez\n\n vec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\n \n    \nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n\n\nfloat fromTo(vec3 p,vec3 q)\n{\nreturn acos(dot(p,q));\n\n}\n\nvec4 quatLookAt(vec3 forward,vec3 up){\n    forward=normalize(forward);\n    up=normalize(up);\nreturn BuildQuat(cross(forward,up),fromTo(forward,up));\n}\n\n\nfloat   arandom (float aseed) {return mod( mod(aseed*43758.5453123, 1.9)+aseed* 78.233 ,1.0);}\n\nfloat value_at (float x,float y,float z) {return arandom(arandom(arandom(x)+y)+z);}\n\n\nfloat noise3d(vec3 p) {\n\t  float  px= floor (p.x); \t   float    py= floor (p.y); \t   float    pz= floor (p.z);\n  \t\tfloat\tlbx= smoothstep(0.0,1.0,p.x-px);\t\n  \t\tfloat  lby= smoothstep(0.0,1.0,p.y-py);\t \n \t\t float  lbz= smoothstep(0.0,1.0,p.z-pz);\n\t  \t  float    p0 = value_at (px,  py,  pz);    float    p1 = value_at (px+1.0,py,  pz);\n      \t  float    p2 = value_at (px+1.0,py+1.0,pz);    float    p3 = value_at (px,  py+1.0,pz);\t\t\n      \t  float    p4 = value_at (px,  py,  pz+1.0);  float      p5 = value_at (px+1.0,py,  pz+1.0);\n      \t  float    p6 = value_at (px+1.0,py+1.0,pz+1.0);  float      p7 = value_at (px,  py+1.0,pz+1.0);   \t     \n          float  p01 =mix(p0,p1,lbx);\t\t\t  float  p32 =mix(p3,p2,lbx);\n    \t  float  \tp45 =mix(p4,p5,lbx);\t\t  float  \tp76 =mix(p7,p6,lbx);\n\t\t  float  \tp0132=mix(p01,p32,lby);\t\t  float  \tp4576=mix(p45,p76,lby);  \t \n    float   c1=mix(p0132,p4576,lbz);\n    return    (c1);}\n\n\n\nfloat  synmin(float a,float  b,float  r) {\n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*e*0.75*(exp(1.0-(e*2.5 ))))/max(a,b)*0.5)\n \n            ;}\n\nfloat conecapsule (vec3 p, vec4 p1 ,vec4 p2,float w,float z ) {\nvec3 a=mix(p1.xyz,p2.xyz,0.1);\nvec3 b=mix(p1.xyz,p2.xyz,0.9);\nfloat\t\td1=p1.w;\nfloat\t\td2=p2.w*0.9;\nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\n//float conecapsule (vec3 p, vec4 p1 ,vec4 p2 ,float w, float z) {\n\n    \n    \n     // vec3 n=normalize(vec3 (\n     // conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.001,0.0,0.0) ,p1,p2),\n    //  conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.001,0.0),p1,p2 ),\n   //   conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.0,0.001),p1,p2 )\n           //   ));\n \n    \n //float bumpb=noise3d(n*w)*z;\n     \n//return conecapsule2 (p,p1,p2) \n //   ; \n//}\n\nfloat antbody(vec3 p)\n{\n    \n    //body defines as basically a string of sticks and spheres. little more to it ofc\nvec4[] body= vec4[](vec4(-5,0,0,1),vec4(-4,0,1,2),vec4(-2,0,2,3),vec4(0,0,2,3),vec4(3,0,2,1),vec4(4,0,1,1),vec4(7,0,4,3),vec4(9,0,5,3),vec4(12,0,4,1),vec4(14,0.5,4,3),vec4(15,2,2,1),vec4(16,0.7,-0.5,0.5));\n\n    \n float oddbod=   \n            min(conecapsule (p, body[1] , body[2] ,2.0,0.125  ),\n            min(conecapsule (p, body[3] , body[4] ,2.0,0.125),\n            min(conecapsule (p, body[5] , body[6] ,2.0,0.125),\n                     min(conecapsule (p, body[9] , body[10] ,2.0,0.125),\n            conecapsule (p, body[7] , body[8] ,2.0,0.25) \n  ))))         ; \n     float evebod=  \n           min(conecapsule (p, body[0] , body[1] ,2.0,0.125),\n            min(conecapsule (p, body[2] , body[3] ,2.0,0.125),\n            min(conecapsule (p, body[4] , body[5] ,2.0,0.125),\n            min(conecapsule (p, body[6] , body[7] ,2.0,0.125),\n            min(conecapsule (p, body[8] , body[9] ,2.0,0.125),\n       \n\n              conecapsule (p, body[10] , body[11] ,2.0,0.125)\n  )))))        ; \n    \n return synmin (oddbod,evebod,0.60);\n\n}\n\n\nfloat antenna(vec3 p)\n{\nvec4[] ant1= vec4[](vec4(14.4062,0.35,5.21244,0.525),vec4(16.4468,1.52811,7.89352,0.49),vec4(18.9311,2.96244,8.66218,0.525),vec4(20.728,3.99987,6.65596,0.525),vec4(21.4749,4.43109,5.34974,0.52));\n float oddant1=   \n            min(conecapsule (p, ant1[1] , ant1[2] ,1.0,0.06),\n             (conecapsule (p, ant1[3] , ant1[4] ,1.0,0.06)\n       ))         ; \n     float eveant1=  \n           min(conecapsule (p, ant1[0] , ant1[1] ,1.0,0.06),\n             (conecapsule (p, ant1[2] , ant1[3] ,1.0,0.06) \n  ))        ; \n    \n    \n\n  return  synmin  (oddant1,eveant1,0.30);\n}\n\nfloat antleg1(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(5.5,0.0,2.5,0.5),vec4(7.03209,1.28558,0.5,0.75),vec4(11.8623,6.49951,2.0,1.0),vec4(11.8623,4.49951,-3.5,0.75),vec4(13.944,5.78509,-5.75,0.65),vec4(15,6.42788,-6,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\nfloat antleg2(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(4.75,0,1.75,0.5),vec4(4.75,2.31691,0.127681,0.75),vec4(4.75,6.89365,2.96554,1),vec4(4.75,7.93554,-2.94331,0.75),vec4(4.75,10.4261,-5.55044,0.75),vec4(4.75,11.4977,-5.86919,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\nfloat antleg3(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(3.5,0.2,0.25,0.5),vec4(1.72499,3.691,-0.26813,0.75),vec4(-3.8651,6.7605,2.8302,1),vec4(-4.66323,6.43022,-3.07865,0.75),vec4(-7.02376,8.41093,-5.58159,0.75),vec4(-8.071,9.28967,-5.84825,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\n\n\nfloat legasm(vec3 p)\n{\n\nreturn\n    min(antenna(p),\n    min(antleg1(p),\n    min(antleg2(p),\n           antleg3(p)\n          \n          )));\n\n}\n        \n\nfloat ant(vec3 p)\n{\n    p=vec3(p.x,abs(p.y),p.z);\n  \n\n      \n    return synmin(antbody(p) ,legasm(p) ,0.60);\n    \n} \n\nvec4 map(vec4 r0)\n{  \n    vec3 p=r0.xyz ;\n    vec4 Q1 = quatLookAt(vec3(sin(iTime),1.,cos(iTime)),vec3(0,1,0));    \n    vec4 Q2 =quatLookAt(vec3(sin(2.*iTime),1.,cos(3.*iTime)),vec3(0,1,0));    \n    vec4 Q=MulQuat(Q1,Q2);\n    p=Rotate(Q, p);\n    \n    \n\n    //  vec3 n=normalize(vec3 (\n      //ant(p )-ant(p+vec3(0.001,0.0,0.0)  ),\n      //ant(p )-ant(p+vec3(0.0,0.001,0.0) ),\n    //ant(p )-ant(p+vec3(0.0,0.0,0.001)  )\n        //     ));\n \n    float bumpb=noise3d(p.yzx*4.5)*0.1;\n    return vec4(ant(p)\n                +abs(bumpb)\n                ,0.047/max( 1.,abs(p.z/4.)), 0.037/max( 1.,abs(p.z/3.)), 0.032/max( 1.,abs(p.x/2.)));\n }\n\n\n\n//Raycaster code credit to Inigo Quilez\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.12)*0.34;\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig1 = normalize( vec3(-0.8, 0.3, 0.5) );\n        vec3  lig2 = normalize( vec3(0.8, 0.3, 0.5) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif1 = clamp( dot( nor, lig1 ), 0.0, 1.0 );\n        float dif2 = clamp( dot( nor, lig2 ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig1.x,lig1.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe1 = pow(clamp( dot( ref, lig1 ), 0.0, 1.0 ),32.0);\n        float spe2 = pow(clamp( dot( ref, lig2 ), 0.0, 1.0 ),32.0);\n        \n        vec3 lin = vec3(0.0);\n        lin += 4.30*dif1*vec3(1.00,0.80,0.55);\n        lin += 4.30*dif2*vec3(1.00,0.80,0.55);\n        lin += 14.00*spe1*vec3(1.00,0.90,0.70)*dif1;\n        lin += 14.00*spe2*vec3(0.50,0.90,1.0)*dif2;\n        lin += 0.9*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.20*bac*vec3(0.935,0.935,0.935)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.64);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n \n      vec2 mouse = iMouse.xy / iResolution.xy;\n      //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\nvec3 eye = vec3(sin( 2.)*26., cos( 3.)*20., cos( 5.)*4.+4.);\n    vec3 centre = vec3(-1.0, 0.0, 1.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 1.0);\n\t \n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}