{"ver":"0.1","info":{"id":"4tXyDn","date":"1504669395","viewed":378,"name":"The ollj (fast, simple) arrow","username":"etale_cohomology","description":"Fork of ollj's https://www.shadertoy.com/view/XsBBRd\n\nThe fastest arrow SDF in the west. Draws 28000 arrows at 60 fps with a Titan XM (tested offline in OpenGL). About 20x faster than the other arrow SDF I had found: https://www.shadertoy.com/view/XtlcRM","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","sdf","fast","optimized","distance","field","arrow","signed","ollj"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of ollj's https://www.shadertoy.com/view/XsBBRd\n\n// Arrow-shaped distance field, by ollj. Made for performance.\n// The head is computed with a single dot().\n// The stem distance field is good enough for most cases.\n\n// ------------------------------------------------------------------------------------------------\nfloat m_stretch(float point, float stretch){\n    return .5 * (sign(point) * stretch - point) * (sign(abs(point) - stretch) + 1.);\n}\n\n#define m_stretch_neg(p, st) (.5 * m_stretch(2. * p + st, st))  /* Stretch-negative: positive values are fixed */\n#define m_stretch_pos(p, st) (.5 * m_stretch(2. * p, st))  /* Stretch-positive: negative values are fixed */\n\n// A fast \"manual\" lossy rotate function by ollj.\n// Control the angle of rotation by specifying the ROTATE_PARAM constants.\n// https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\nfloat ollj_rotate(vec2 uv){\n    const float ROTATE_PARAM0 = sqrt(1.);  // Try changing these!\n    const float ROTATE_PARAM1 = sqrt(.0);\n    return dot(uv, vec2(ROTATE_PARAM0 + ROTATE_PARAM1, ROTATE_PARAM0 - ROTATE_PARAM1));\n}\n\n// Optimized arrow SDF, by ollj\n// @head_len isn't actual uv units, but the unit size depends on ROTATE_PARAMs\nfloat sdf_arrow(vec2 uv, float norm, float angle, float head_height, float stem_width){\n    uv = vec2(cos(angle) * uv.x + sin(angle) * uv.y, -sin(angle) * uv.x + cos(angle) * uv.y);\n\n    norm -= head_height;  // Make sure the norm INCLUDES the arrow head\n    uv.x -= norm;  // Place the arrow's origin at the stem's base!\n\n    uv.y = abs(uv.y);\n    float head = max(ollj_rotate(uv) - head_height, -uv.x);\n\n    uv.x = m_stretch_neg(uv.x, norm);\n    uv.y = m_stretch_pos(uv.y, stem_width);\n    float stem = length(uv);\n\n    return min(head, stem);  // Join head and stem!\n}\n\n// ------------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float SCALE = 8. * (1.1 + sin(.4 * iTime));\n    vec2 uv = SCALE * (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2  arrow_uv = uv + .5 * vec2(2. * cos(iTime), sin(.5 * iTime));\n    float arrow_norm = 1. * (1. + sin(iTime));  // Actual uv units PLUS a small constant!\n    float arrow_angle = iTime;\n    float arrow_head_height = .1;  // Actual uv units under suitable ROTATE_PARAMs\n    float arrow_stem_width = .04;  // Actual uv units PLUS a small constant!\n    float arrow_aa = 4. * SCALE / iResolution.y;\n    float arrow;\n\n    //for(float i=0.; i<28000.; i += 1.){  // This is a good way to benchmark, right? Right...? =D\n        arrow = sdf_arrow(arrow_uv, arrow_norm, arrow_angle, arrow_head_height, arrow_stem_width);\n        arrow = smoothstep(arrow_aa, 0., arrow);\n    //}\n\n    fragColor.rgb = vec3(arrow);\n}\n","name":"Image","description":"","type":"image"}]}