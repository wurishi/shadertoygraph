{"ver":"0.1","info":{"id":"4d3yR7","date":"1518132948","viewed":132,"name":"Speedy spin","username":"sidsuk","description":"speedy spin, case study\nanimation reference: https://camo.githubusercontent.com/42bb3030573acf8ab4373f3d82a5833f0ee34d4e/68747470733a2f2f692e696d6775722e636f6d2f414930306d48752e676966","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","motionblur"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// CIS566 Speedy Spin\n// reference: https://iquilezles.org/articles/distfunctions\n\n#define DEPTH 30\n#define END 1000.0\n#define EPSILON 0.001\n#define PI 3.14159265359\n\n\nfloat sphereSDF(vec3 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat unionSDF(float a, float b) {\n    return min(a, b);\n}\n\nmat4 rotateY(float a) {\n    float c = cos(radians(a));\n    float s = sin(radians(a));\n    return mat4(\n        c, 0.0, -s, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        s, 0.0, c, 0.0,\n        0.0, 0.0, 0.0, 1.0);  \n}\n\nmat4 rotateX(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\t1.0, 0.0, 0.0, 0.0,   // first column\n\t\t0.0, cost, sint, 0.0, // second column\n\t\t0.0, -sint, cost, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 rotateZ(float t) {\n\tfloat cost = cos(radians(t));\n\tfloat sint = sin(radians(t));\n\treturn mat4(\n\t\tcost, sint, 0.0, 0.0,   // first column\n\t\t-sint, cost, 0.0, 0.0, // second column\n\t\t0.0, 0.0, 1.0, 0.0, // third column\n\t\t0.0, 0.0, 0.0, 1.0\n\t);\n}\n\nmat4 translate(vec3 t) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        t.x, t.y, t.z, 1.0\n        );\n}\n\nfloat ringSDF(vec3 p, float time) {\n    mat4 t = translate(vec3(0.0, 0.0, 0.8));\n    \n    int num = 4;\n    \n    float dist = END;\n    \n    float gap = 360.0 / float(num);\n    \n    float scale = 0.8;\n    \n    int blurNum = 30;\n    \n    for(int k = 0; k < blurNum; ++k) {\n        \n    }\n    \n    float offset = (sin(time/ scale) + time / scale);\n    \n    for(int i = 0; i < num; ++i) {\n        \n        mat4 r = rotateY(gap / 2.0 + float(i) * gap + offset * 360.0);\n        \n        mat4 transform = r * t;\n        \n        float s = sphereSDF(vec3(inverse(transform) * vec4(p, 1.0)), 0.02);\n        \n        dist = unionSDF(dist, s);\n    }\n    \n    return dist;\n}\n\n\nfloat scene(vec3 p, float time) {\n    \n    int num = 3; \n    float gap = 180.0 / float(num);\n    \n    mat4 tr = rotateY(360.0 * iTime / 2.0 / PI);\n    \n    float dist = END;\n    \n    for(int i = 0; i < num; ++i) {\n        mat4 r = rotateZ(gap * float(i));\n        \n        float s = ringSDF(vec3(inverse(tr * r) * vec4(p, 1.0)), time);\n        \n        dist = unionSDF(dist, s);\n        \n    }  \n    \n    return dist;\n}\n\n\nfloat rayMarching(vec3 origin, vec3 dir, float start, float time) {\n    float t = start;\n\tfor(int i = 0; i < DEPTH; ++i) {\n\t\tvec3 curP = origin + dir * t;\n\t\tfloat step = scene(curP, time);\n\t\tt += step;\n\t\tif(step < EPSILON) {\n\t\t\treturn t;\n\t\t}\n\t\tif(t >= END){\n\t\t\treturn END;\n\t\t}\t\n\t}\n\treturn END;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // orthographic\n    vec2 spos = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 eye = vec3(3.0, 4.0, 8.0);\n    vec3 target = vec3(0.0, 0.0, 0.0);\n    vec3 dir = normalize(target - eye);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(dir, up);\n    up = cross(right, dir);\n    \n    vec3 pos = eye + right * spos.x + up * spos.y;\n    \n    int blurNum = 40;\n    vec3 sumCol = vec3(0.0);   \n    \n    for(int i = 0; i < blurNum; ++i) {\n        float delta = (float(i) / (float(blurNum) - 1.0) - 0.5) * 0.08;\n        float time = iTime + delta;\n        float t = rayMarching(pos, dir, 0.01, time);\n        vec3 col;\n        if(t >= END) {\n        \tcol = vec3(0.03, 0.03, 0.05);\n        } else {\n            col = vec3(1.0);\n        }\n        sumCol += col;\n    }\n    sumCol *= 1.5;\n    \n    fragColor =vec4(pow(sumCol / float(blurNum), vec3(1.0 / 1.5)), 1.0);\n    \n    \n}","name":"Image","description":"","type":"image"}]}