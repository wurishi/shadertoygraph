{"ver":"0.1","info":{"id":"lccyDn","date":"1730475272","viewed":23,"name":"shadertoy_beadando","username":"monkeysoop","description":"Controls: WASDEQ for movement T for placing the ray (at the direction of the camera)\nUse SPHERE_TRACING_MODE macro in BufferB for selecting the sphere tracing mode (naive, relaxed, enhanced)\nTo run in VSC comment out IN_SHADERTOY macros","likes":0,"published":3,"flags":48,"usePreview":0,"tags":["beadando"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IN_SHADERTOY\n\n#ifndef IN_SHADERTOY\n\n#include \"Common.glsl\"\n\n#iChannel0 \"BufferC.glsl\"\n\n#endif\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(texelFetch(iChannel0, ivec2(fragCoord), 0).rgb, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A common shader included (as is) in all Buffers\n\nstruct Value {\n    float d; \n    int id;\n};\n\nstruct Material {\n    vec3 color;              // [0,1/pi]\n    float roughness;         // [0,~7]\n    float emission_strength; // [0, inf]\n    float metalness;         // 0.02-0.05 for non-metals, 0.6-0.9 for metals\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct Ray {\n    vec3 P;\n    float Tmin;\n    vec3 V;\n    float Tmax;\n};\n\nstruct SphereTraceDesc {\n    float epsilon;  // Stopping distance to surface\n    int maxiters;   // Maximum iteration count\n};\n\nstruct TraceResult {\n    float T;    // Distance taken on ray\n    int flags;  // flags bit 0:   distance condition: true if travelled to far t > t_max\n                // flags bit 1:   surface condition:  true if distance to surface is small < error threshold\n                // flags bit 2:   max. iter. condition:  true if none of the above, exited the loop because i > maxsteps\n                // bit 2+: material id bits\n    int steps;\n};  \n\nconst float pi = 3.1415926535897932384626433832795;\n\nconst vec3 EyeStartPosition = vec3(2.0, 2.0, 2.0);\n\n\n#define MAX_DIST 1000.0\n\n\n// common useful functions\nfloat min3(float a, float b, float c) {\n    return min(min(a, b), c);\n}\nfloat max3(float a, float b, float c) {\n    return max(max(a, b), c);\n}\nfloat max3(vec3 a) {\n    return max(max(a.x, a.y), a.z);\n}\nfloat min3(vec3 a) {\n    return min(min(a.x, a.y), a.z);\n}\nfloat dot2(vec3 a) {\n    return dot(a, a);\n}\n\n// union on the original sdf representation\nfloat Unite(float a, float b) { \n    return min(a, b);\n}\n// same union but also carrying mat id\nValue Unite(Value a, Value b) {\n    if (b.d < a.d) {\n        return b;\n    } \n    return a;\n}\n// creates a Value from the (float,int)\nValue Unite(Value a, float b_d, int b_id) {\n    if (b_d < a.d) {\n        return Value(b_d, b_id);\n    } \n    return a;\n}\n// pairs and calls Unite(Value,Value)\nValue Unite(float a_d, Value b, int b_id) {\n    return Unite(Value(a_d, b_id), b);\n}\n\n\nValue Intersect(Value a, Value b) {\n    if (b.d > a.d) {\n        return b;\n    }\n    return a;\n}\n\nValue Substraction(Value a, Value b) {\n    if (b.d > -a.d) {\n        return b;\n    }\n    return a;\n}\n\n\n\n// SDF Primitives (more on https://iquilezles.org/articles/distfunctions/)\nfloat sdRoundBox(vec3 p, vec3 b, float r) {\n    vec3 q = abs(p) - b + r;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;\n}\nfloat sdBoxFrame(vec3 p, vec3 b, float e) {\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n    return min(min(length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0), length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)), length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0)) + min(max3(d.x, d.y, d.z), 0.0);\n}\n\n\n\n// SDF Operations\nvec3 opRepLim(vec3 p, float c, in vec3 l) {\n    return p - c * clamp(round(p / c), -l, l);\n}\nvec3 opRep(vec3 p, float s) {\n    return mod(p + s * 0.5, s) - s * 0.5;\n}\nvec3 opSymX(vec3 p) {\n    return vec3(abs(p.x), p.y, p.z);\n}\nvec3 opRepZ(vec3 p, float sz, float lo, float up) {\n    return vec3(p.x, p.y, p.z - sz * clamp(round(p.z / sz), lo, up));\n}\nvec3 opRepXZ(vec3 p, float sx, float sz) {\n    return vec3((mod(p.x + sx * 0.5, sx) - sx * 0.5), p.y, (mod(p.z + sz * 0.5, sz) - sz * 0.5));\n}\nfloat intersectPlane(Ray ray, vec3 q, vec3 n) {\n    return dot(q - ray.P, n) / dot(ray.V, n);\n}\n\n\n\nfloat pendulum(float t) {\n    // const float q = 0.0;                   // initial angle: 0\n    // const float q = 0.0004765699168668419; // initial angle: 10\n    // const float q = 0.0019135945901703004; // initial angle: 20\n    // const float q = 0.004333420509983138;  // initial angle: 30\n    // const float q = 0.007774680416441802;  // initial angle: 40\n    // const float q = 0.01229456052718145;   // initial angle: 50\n    const float q = 0.017972387008967222;  // initial angle: 60\n    // const float q = 0.02491506252398093;   // initial angle: 70\n    // const float q = 0.03326525669557733;   // initial angle: 80\n    // const float q = 0.04321391826377224;   // initial angle: 90\n\n    float theta = 8.0 * (pow(q, 0.5) / (1.0 + pow(q, 1.0))) * cos(1.0 * t) \n                + -2.6666666666666665 * (pow(q, 1.5) / (1.0 + pow(q, 3.0))) * cos(3.0 * t) \n                + 1.6 * (pow(q, 2.5) / (1.0 + pow(q, 5.0))) * cos(5.0 * t);\n    //s            + -1.1428571428571428 * (pow(q, 3.5) / (1.0 + pow(q, 7.0))) * cos(7.0 * t)\n    //            + 0.8888888888888888  * (pow(q, 4.5) / (1.0 + pow(q, 9.0))) * cos(9.0 * t)\n    //            + -0.7272727272727273 * (pow(q, 5.5) / (1.0 + pow(q, 11.0))) * cos(11.0 * t);\n\n    return theta;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define IN_SHADERTOY\n\n#ifdef IN_SHADERTOY\n\nbool isKeyDown(int k) {\n    return (texelFetch(iChannel1, ivec2(k, 0), 0).x > 0.0);\n}\n\nconst int KeyLeft = 65;  //'A'\nconst int KeyRight = 68;\nconst int KeyUp = 87;\nconst int KeyDown = 83;\nconst int KeyE = 69;\nconst int KeyQ = 81;\nconst int KeyT = 84;\n\n#else\n\n#include \"Common.glsl\"\n\n#iChannel0 \"self\"\n#iChannel0::MinFilter \"Linear\"\n#iChannel0::MagFilter \"Linear\"\n#iChannel0::WrapMode \"Clamp\"\n\n#iKeyboard  // exposes isKeyPressed, isKeyReleased, isKeyDown, isKeyToggled functions\n\nconst int KeyLeft = Key_A;  //'A'\nconst int KeyRight = Key_D;\nconst int KeyUp = Key_W;\nconst int KeyDown = Key_S;\nconst int KeyE = Key_E;\nconst int KeyQ = Key_Q;\nconst int KeyT = Key_T;\n\n\n#endif\n\n\n\n\n// Handles camera only\n\n\nvec4 UpdateCamera(vec2 fragCoord) {\n    /*  \n    We will use the first 2 pixels of the buffer to store the information we need.\n    Every pixel contains 4 channels (floats), for RGBA. We can exploit this in the following way:\n        pixel0 = (cameraX, cameraY, cameraZ, U)\n        pixel1 = (wX, wY, wZ, V)\n    where\n        cameraX, cameraY and cameraZ describe the position of the camera respectively\n        U,V give the current rotation of the camera in spherical coordinates\n        wX, wY, wZ is the forward vector\n    */\n\n    vec4 data1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 data2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 eye = data1.xyz + EyeStartPosition;\n    vec2 uv = abs(vec2(data1.w, data2.w));\n\n    if (iMouse.z > 0. || data1.w >= 0.) {  // mouse held or was held last frame\n        float du = (abs(iMouse.z) - abs(iMouse.x)) * 0.01;\n        float dv = (abs(iMouse.y) - abs(iMouse.w)) * 0.01;\n        if (data1.w >= 0.0) {\n            uv = vec2((uv.x + du), clamp((uv.y + dv), 1.571, 4.712)); // 0.5 pi and 1.5 pi\n        } else {\n            uv = vec2((uv.x + du), clamp((uv.y + dv), -4.713, -1.570)); // -1.5 pi and -0.5 pi\n        }\n    }\n\n    vec3 w = vec3(cos(uv.x) * cos(-uv.y), sin(-uv.y), sin(uv.x) * cos(-uv.y));\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n\n    // Keyboard and mouse handling:\n\n    float speed = 0.2;\n    if (isKeyDown(KeyLeft)) {\n        eye -= u * speed;\n    }\n    if (isKeyDown(KeyRight)) {\n        eye += u * speed;\n    }\n    if (isKeyDown(KeyUp)) {\n        eye += w * speed;\n    }\n    if (isKeyDown(KeyDown)) {\n        eye -= w * speed;\n    }\n    if (isKeyDown(KeyE)) {\n        eye.y += speed;\n    }\n    if (isKeyDown(KeyQ)) {\n        eye.y -= speed;\n    }\n\n    vec4 data3 = texelFetch(iChannel0, ivec2(0, 1), 0);\n    vec4 data4 = texelFetch(iChannel0, ivec2(1, 1), 0);\n    vec3 ray_p = data3.xyz;\n    vec3 ray_v = data4.xyz;\n    if (isKeyDown(KeyT)) {\n        ray_p = eye;\n        ray_v = normalize(w);\n    }\n\n    vec2 outdata = vec2(data1.w, data2.w);\n    if (iMouse.z >= 0.0) {\n        outdata = abs(vec2(outdata));  // mouse held\n    } else if (data1.w >= 0.0) {\n        outdata = -mod(uv, 2.0 * pi);  // mouse released\n    }\n\n    vec4 fragColor;\n    if (fragCoord.x == 0.5 && fragCoord.y == 0.5) { // pixel (0,0)\n        fragColor = vec4(eye - EyeStartPosition, outdata.x);\n    }\n    if (fragCoord.x == 1.5 && fragCoord.y == 0.5) { // pixel (1,0)\n        fragColor = vec4(w, outdata.y);\n    }\n    if (fragCoord.x == 0.5 && fragCoord.y == 1.5) { // pixel (0,1)\n        fragColor = vec4(ray_p, 0.0);\n    }\n    if (fragCoord.x == 1.5 && fragCoord.y == 1.5) { // pixel (1,1)\n        fragColor = vec4(ray_v, 0.0);\n    }\n\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    //Generate ray from pixel\n    if (fragCoord.x > 1.5 || fragCoord.y > 1.5) { \n        discard;\n    }\n\n    fragColor = UpdateCamera(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define IN_SHADERTOY\n\n#ifndef IN_SHADERTOY\n\n#include \"Common.glsl\"\n\n#iChannel0 \"BufferA.glsl\"\n\n#iChannel1 \"self\"\n#iChannel1::MinFilter \"Linear\"\n#iChannel1::MagFilter \"Linear\"\n#iChannel1::WrapMode \"Clamp\"\n\n#iChannel2 \"../skybox_{}.png\"\n#iChannel2::Type \"CubeMap\"\n\n#endif\n\n#define NUM_OF_REFLECTIONS 6\n\n#define IMAGE_MAX_ITERS 150\n#define SHADOW_MAX_ITERS 40\n#define VIS_RAY_MAX_ITERS 10\n\n#define NUM_OF_MATERIALS 6\n#define NUM_OF_LIGHTS 3\n\n// 0 for naive 1 for relaxed and 2 for enhanced\n#define SPHERE_TRACING_MODE 2\n\n\nconst Material materials[NUM_OF_MATERIALS] = Material[](\n    Material(vec3(10.2, 0.0, 0.0), 0.2, 0.0, 0.02),     // Plastic\n    Material(vec3(0.95, 0.93, 0.88), 0.1, 0.0, 0.95),   // Silver\n    Material(vec3(1.0, 0.71, 0.29), 0.05, 0.0, 0.9),    // Polished Gold\n    Material(vec3(0.8, 0.85, 0.88), 0.5, 0.0, 0.7),     // Brushed Aluminum\n    Material(vec3(0.95, 0.64, 0.54), 0.3, 0.0, 0.75),   // Copper\n    Material(vec3(0.56, 0.57, 0.58), 1.0, 0.0, 0.75)    // Rough Iron\n);\n\nconst Light lights[NUM_OF_LIGHTS] = Light[](\n    Light(vec3(10.0, 10.0, 0.0), vec3(10.0, 0.0, 0.0)), \n    Light(vec3(0.0, 10.0, 0.0), vec3(0.0, 10.0, 0.0)), \n    Light(vec3(0.0, 10.0, 10.0), vec3(0.0, 0.0, 1.0))\n);\n\n\n\n\n\n// stolen from: https://learnopengl.com/PBR/Lighting\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float NdotH = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH * NdotH;\n\n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = pi * denom * denom;\n\n    return num / denom;\n}\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r * r) / 8.0;\n\n    float num = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\n    return num / denom;\n}\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n\n    return ggx1 * ggx2;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}\n\n\n\n// Buffer A handels camera movement. Here we only read it\nRay ReadCamera(vec2 fragCoord, out float diagInv) {\n    vec4 data1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 data2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec3 eye = data1.xyz + EyeStartPosition;\n\n    vec3 w = data2.xyz;\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n\n    // vec2 px = (fragCoord/iResolution.xy*2.-1.)*1.*normalize(iResolution.xy);\n    diagInv = 1.0 / length(iResolution.xy);\n    vec2 px = (2.0 * fragCoord - iResolution.xy) * diagInv * 1.0;\n\n    return Ray(eye, 0.0, normalize(w + px.x * u + px.y * v), MAX_DIST);\n}\n\nRay ReadVisRay() {\n    vec4 data1 = texelFetch(iChannel0, ivec2(0, 1), 0);\n    vec4 data2 = texelFetch(iChannel0, ivec2(1, 1), 0);\n    Ray ray = Ray(data1.xyz, 0.0, data2.xyz, MAX_DIST);\n    return ray;\n}\n\n\n//float RaySphereIntersect(Ray ray, vec3 o, float r) {\n//    // rax.V should be normalized\n//    float b = dot(ray.V, (ray.P - o));\n//    float c = dot((ray.P - o), (ray.P - o)) - r * r;\n//    float d = b * b - c;\n//\n//    float t1 = -b - sqrt(max(d, 0.0));\n//\n//    return (d < 0.0 || t1 < 0.0) ? MAX_DIST : t1; \n//}\n//\n//Value sdfSpheres(Ray ray, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n//    Value v = Value(MAX_DIST, 0);\n//    for (int i = 0; i < VIS_RAY_MAX_ITERS; i++) {\n//        vec3 pos = vis_spheres[i].xyz;\n//        float r = vis_spheres[i].w;\n//        v = Unite(v, Value(RaySphereIntersect(ray, pos, r), (i % NUM_OF_MATERIALS)));\n//    }\n//    return v;\n//}\n//\n//float RaySphereMinDist(Ray ray, vec3 o , float r)  {\n//    return max(0.0, length(o - ray.P + dot((o - ray.P), ray.V) * ray.V) - r);\n//}\n//\n//float SphereMinDist(Ray ray, vec4 vis_spheres[VIS_RAY_MAX_ITERS], float penumbra) {\n//    float min_d = 1.0;\n//    for (int i = 0; i < VIS_RAY_MAX_ITERS; i++) {\n//        vec3 pos = vis_spheres[i].xyz;\n//        float r = vis_spheres[i].w;\n//        float d = RaySphereMinDist(ray, pos , r);\n//        min_d = min(min_d, (d * penumbra) / (dot((pos - ray.P), ray.V)))\n//    }\n//    return min_d;\n//}\n\n\nValue SceneSDF(vec3 p) {\n    const float freq = 2.0;\n\n    float first_sphere_angle = pendulum(clamp(mod(freq * iTime, 2.0 * pi), 0.5 * pi, 1.5 * pi) + pi);\n    float last_sphere_angle = pendulum(clamp(mod(freq * iTime + pi, 2.0 * pi), 0.5 * pi, 1.5 * pi));\n\n    vec3 first_sphere_pos =    vec3(0.0, -13.0 + 7.0 * cos(first_sphere_angle), -4.0 - 7.0 * sin(first_sphere_angle));\n    vec3 last_sphere_pos =     vec3(0.0, -13.0 + 7.0 * cos(last_sphere_angle),   4.0 - 7.0 * sin(last_sphere_angle));\n    vec3 first_cable_end_pos = vec3(0.0, -13.0 + 6.0 * cos(first_sphere_angle), -4.0 - 6.0 * sin(first_sphere_angle));\n    vec3 last_cable_end_pos =  vec3(0.0, -13.0 + 6.0 * cos(last_sphere_angle),   4.0 - 6.0 * sin(last_sphere_angle));\n\n    p = vec3(p.x, p.y + 10.0, p.z);\n\n    float d = MAX_DIST;\n    Value v = Value(MAX_DIST, 0);\n    v = Unite(v, Value(sdBoxFrame(p + vec3(0.0, -8.0, 0.0), vec3(3.0, 5.0, 6.0), 0.1), 1));\n    v = Unite(v, Value(max(sdRoundBox(p + vec3(0.0, -3.0, 0.0), vec3(4.0, 1.0, 7.0), 0.5), -(p.y - 2.99)), 0));\n    v = Unite(v, Value(sdSphere(p + first_sphere_pos, 1.0), 2));\n    v = Unite(v, Value(sdSphere(p + last_sphere_pos, 1.0), 2));\n    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + first_cable_end_pos, p + vec3(3.0 - 0.1, -13.0 + 0.1, -4.0), 0.05), 4));\n    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + first_cable_end_pos, p + vec3(-3.0 + 0.1, -13.0 + 0.1, -4.0), 0.05), 4));\n    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + last_cable_end_pos, p + vec3(3.0 - 0.1, -13.0 + 0.1, 4.0), 0.05), 4));\n    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p + last_cable_end_pos, p + vec3(-3.0 + 0.1, -13.0 + 0.1, 4.0), 0.05), 4));\n    vec3 p_rep_z = opRepZ(p, 2.0, -1.0, 1.0);\n    vec3 p_rep_sym_x = opSymX(p_rep_z);\n    v = Unite(v, Value(sdSphere(p_rep_z + vec3(0.0, -6.0, 0.0), 1.0), 2));\n    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p_rep_z + vec3(0.0, -7.0, 0.0), p_rep_z + vec3(3.0 - 0.1, -13.0 + 0.1, 0.0), 0.05), 4));\n    v = Unite(v, Value(sdCapsule(vec3(0.0, 0.0, 0.0), p_rep_z + vec3(0.0, -7.0, 0.0), p_rep_z + vec3(-3.0 + 0.1, -13.0 + 0.1, 0.0), 0.05), 4));\n\n    return v;\n}\n\n\n// Signed Distance Function\nValue sdf(vec3 p, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    Value v = SceneSDF(p);\n    for (int i = 0; i < VIS_RAY_MAX_ITERS; i++) {\n        vec3 pos = vis_spheres[i].xyz;\n        float r = vis_spheres[i].w;\n        v = Unite(v, Value(sdSphere(p - pos, r), (i % NUM_OF_MATERIALS)));\n    }\n    return v;\n}\n\n// symmetric differential\nvec3 normal(vec3 p, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    const vec2 eps0 = vec2(0.001, 0);\n    vec3 m0 = vec3(sdf(p - eps0.xyy, vis_spheres).d, sdf(p - eps0.yxy, vis_spheres).d, sdf(p - eps0.yyx, vis_spheres).d);\n    vec3 m1 = vec3(sdf(p + eps0.xyy, vis_spheres).d, sdf(p + eps0.yxy, vis_spheres).d, sdf(p + eps0.yyx, vis_spheres).d);\n    return normalize(m1 - m0);\n}\n\n\n\nvoid enhanced_sphere_trace_vis_ray(Ray ray, SphereTraceDesc params, inout vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    TraceResult tr = TraceResult(ray.Tmin, 0, 0);\n    const float w = 0.9;\n\n    float prev_d;\n\n    float s;\n    float d;\n    Value v;\n\n    float next_d;\n    Value next_v;\n    float next_t;\n    float next_s;\n\n    v = SceneSDF(ray.P + tr.T * ray.V); \n    d = abs(v.d);\n\n    // this makes first next_s to be equal to d (makes the numerator 0 and the denominator non 0)\n    prev_d = -1.0 * d;\n    s = -2.0 * d;\n    while (tr.T < ray.Tmax &&            // Stay within bound box\n           d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n           tr.steps < params.maxiters    // Stop if too many iterations)\n    ) {\n        next_s = d + w * d * ((-1.0 * prev_d + d + s) / (prev_d - d + s));\n        \n        next_s = clamp(next_s, d, 10.0 * d);\n        next_t = tr.T + next_s;\n        next_v = SceneSDF(ray.P + next_t * ray.V);\n        next_d = abs(next_v.d);\n        if ((d + next_d + 0.000001) < next_s) {\n            next_s = d;\n            next_t = tr.T + next_s; \n            next_v = SceneSDF(ray.P + next_t * ray.V);\n            next_d = abs(next_v.d);       \n        }\n        vis_spheres[tr.steps] = vec4((ray.P + tr.T * ray.V), d);\n        tr.T = next_t;\n        s = next_s;\n        v = next_v;\n        prev_d = d;\n        d = next_d;\n        tr.steps++;\n    }    \n}\n\nvoid enhanced_sphere_trace(Ray ray, SphereTraceDesc params, vec4 vis_spheres[VIS_RAY_MAX_ITERS], inout TraceResult tr) {\n    const float w = 0.9;\n\n    float prev_d;\n\n    float s;\n    float d;\n    Value v;\n\n    float next_d;\n    Value next_v;\n    float next_t;\n    float next_s;\n\n    v = sdf(ray.P + tr.T * ray.V, vis_spheres);\n    d = abs(v.d);\n\n    // this makes first next_s to be equal to d (makes the numerator 0 and the denominator non 0)\n    prev_d = -1.0 * d;\n    s = -2.0 * d;\n    while (tr.T < ray.Tmax &&            // Stay within bound box\n           d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n           tr.steps < params.maxiters    // Stop if too many iterations)\n    ) {\n        next_s = d + w * d * ((-1.0 * prev_d + d + s) / (prev_d - d + s));\n        \n        next_s = clamp(next_s, d, 10.0 * d);\n        next_t = tr.T + next_s;\n        next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n        next_d = abs(next_v.d);\n        if ((d + next_d + 0.000001) < next_s) {\n            next_s = d;\n            next_t = tr.T + next_s; \n            next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n            next_d = abs(next_v.d);       \n        }\n        tr.T = next_t;\n        s = next_s;\n        v = next_v;\n        prev_d = d;\n        d = next_d;\n        tr.steps++;\n    }    \n    tr.flags = int(tr.T >= ray.Tmax) | (int(d <= params.epsilon * tr.T) << 1) | (int(tr.steps >= params.maxiters) << 2) | (int(v.id << 3));\n}\n\nfloat enhanced_sphere_trace_shadow(Ray ray, SphereTraceDesc params, float penumbra, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    TraceResult tr = TraceResult(ray.Tmin, 0, 0);\n    const float w = 0.9;\n\n    float min_d = 1.0;\n\n    float prev_d;\n\n    float s;\n    float d;\n    Value v;\n\n    float next_d;\n    Value next_v;\n    float next_t;\n    float next_s;\n\n    v = sdf(ray.P + tr.T * ray.V, vis_spheres);\n    d = abs(v.d);\n\n    // this makes first next_s to be equal to d (makes the numerator 0 and the denominator non 0)\n    prev_d = -1.0 * d;\n    s = -2.0 * d;\n    while (tr.T < ray.Tmax &&            // Stay within bound box\n           d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n           tr.steps < params.maxiters    // Stop if too many iterations)\n    ) {\n        next_s = d + w * d * ((-1.0 * prev_d + d + s) / (prev_d - d + s));\n        \n        next_s = clamp(next_s, d, 10.0 * d);\n        next_t = tr.T + next_s;\n        next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n        next_d = abs(next_v.d);\n        if ((d + next_d + 0.000001) < next_s) {\n            next_s = d;\n            next_t = tr.T + next_s; \n            next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n            next_d = abs(next_v.d);       \n        }\n        min_d = min(min_d, ((d * penumbra) / tr.T));\n        tr.T = next_t;\n        s = next_s;\n        v = next_v;\n        prev_d = d;\n        d = next_d;\n        tr.steps++;\n    }    \n    return min_d;\n}\n\nvoid relaxed_sphere_trace_vis_ray(Ray ray, SphereTraceDesc params, inout vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    TraceResult tr = TraceResult(ray.Tmin, 0, 0);\n    const float w = 1.6;\n\n    float d;\n    Value v;\n\n    float next_d;\n    Value next_v;\n    float next_t;\n\n    v = SceneSDF(ray.P + tr.T * ray.V);\n    d = abs(v.d);\n    while (tr.T < ray.Tmax &&            // Stay within bound box\n           d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n           tr.steps < params.maxiters    // Stop if too many iterations)\n    ) {\n        next_t = tr.T + w * d;\n        next_v = SceneSDF(ray.P + next_t * ray.V);\n        next_d = abs(next_v.d);\n        if ((d + next_d) < w * d) {\n            next_t = tr.T + d; \n            next_v = SceneSDF(ray.P + next_t * ray.V);\n            next_d = abs(next_v.d);       \n        }\n        vis_spheres[tr.steps] = vec4((ray.P + tr.T * ray.V), d);\n        tr.T = next_t;\n        v = next_v;\n        d = next_d;\n        tr.steps++;\n    }    \n}\n\nvoid relaxed_sphere_trace(Ray ray, SphereTraceDesc params, vec4 vis_spheres[VIS_RAY_MAX_ITERS], inout TraceResult tr) {\n    const float w = 1.6;\n\n    float d;\n    Value v;\n\n    float next_d;\n    Value next_v;\n    float next_t;\n\n    v = sdf(ray.P + tr.T * ray.V, vis_spheres);\n    d = abs(v.d);\n    while (tr.T < ray.Tmax &&            // Stay within bound box\n           d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n           tr.steps < params.maxiters    // Stop if too many iterations)\n    ) {\n        next_t = tr.T + w * d;\n        next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n        next_d = abs(next_v.d);\n        if ((d + next_d) < w * d) {\n            next_t = tr.T + d; \n            next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n            next_d = abs(next_v.d);       \n        }\n        tr.T = next_t;\n        v = next_v;\n        d = next_d;\n        tr.steps++;\n    }    \n    tr.flags = int(tr.T >= ray.Tmax) | (int(d <= params.epsilon * tr.T) << 1) | (int(tr.steps >= params.maxiters) << 2) | (int(v.id << 3));\n}\n\nfloat relaxed_sphere_trace_shadow(Ray ray, SphereTraceDesc params, float penumbra, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    TraceResult tr = TraceResult(ray.Tmin, 0, 0);\n    const float w = 1.6;\n\n    float min_d = 1.0;\n    float d;\n    Value v;\n\n    float next_d;\n    Value next_v;\n    float next_t;\n\n    v = sdf(ray.P + tr.T * ray.V, vis_spheres);\n    d = abs(v.d);\n    while (tr.T < ray.Tmax &&            // Stay within bound box\n           d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n           tr.steps < params.maxiters    // Stop if too many iterations)\n    ) {\n        next_t = tr.T + w * d;\n        next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n        next_d = abs(next_v.d);\n        if ((d + next_d) < w * d) {\n            next_t = tr.T + d; \n            next_v = sdf(ray.P + next_t * ray.V, vis_spheres);\n            next_d = abs(next_v.d);       \n        }\n        min_d = min(min_d, ((d * penumbra) / tr.T));\n        tr.T = next_t;\n        v = next_v;\n        d = next_d;\n        tr.steps++;\n    }    \n    return min_d;\n}\n\nvoid naive_sphere_trace_vis_ray(Ray ray, SphereTraceDesc params, inout vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    TraceResult tr = TraceResult(ray.Tmin, 0, 0);\n    float d;\n    Value v;\n    do {\n        v = SceneSDF(ray.P + tr.T * ray.V);\n        d = abs(v.d);\n        vis_spheres[tr.steps] = vec4((ray.P + tr.T * ray.V), d);\n        tr.T += d;\n        tr.steps++;\n    } while (tr.T < ray.Tmax &&             // Stay within bound box\n             d > params.epsilon * tr.T &&   // Stop if cone is close to surface\n             tr.steps < params.maxiters     // Stop if too many iterations\n    );\n}\n\nvoid naive_sphere_trace(Ray ray, SphereTraceDesc params, vec4 vis_spheres[VIS_RAY_MAX_ITERS], inout TraceResult tr) {\n    float d;\n    Value v;\n    do {\n        v = sdf(ray.P + tr.T * ray.V, vis_spheres);\n        d = abs(v.d);\n        tr.T += d;\n        tr.steps++;\n    } while (tr.T < ray.Tmax &&            // Stay within bound box\n             d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n             tr.steps < params.maxiters    // Stop if too many iterations\n    );\n    tr.flags = int(tr.T >= ray.Tmax) | (int(d <= params.epsilon * tr.T) << 1) | (int(tr.steps >= params.maxiters) << 2) | (int(v.id << 3));\n}\n\nfloat naive_sphere_trace_shadow(Ray ray, SphereTraceDesc params, float penumbra, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    TraceResult tr = TraceResult(ray.Tmin, 0, 0);\n    float min_d = 1.0;\n    float d;\n    Value v;\n    do {\n        v = sdf(ray.P + tr.T * ray.V, vis_spheres);\n        d = abs(v.d);\n        min_d = min(min_d, ((d * penumbra) / tr.T));\n        tr.T += d;\n        tr.steps++;\n    } while (tr.T < ray.Tmax &&            // Stay within bound box\n             d > params.epsilon * tr.T &&  // Stop if cone is close to surface\n             tr.steps < params.maxiters    // Stop if too many iterations\n    );\n    return min_d;\n}\n\nvoid sphere_trace_vis_ray(Ray ray, SphereTraceDesc params, inout vec4 vis_spheres[VIS_RAY_MAX_ITERS]) { \n    switch (SPHERE_TRACING_MODE) {\n        case 0: naive_sphere_trace_vis_ray(ray, params, vis_spheres); break;\n        case 1: relaxed_sphere_trace_vis_ray(ray, params, vis_spheres); break;\n        case 2: enhanced_sphere_trace_vis_ray(ray, params, vis_spheres); break;\n    }\n}\n\nvoid sphere_trace(Ray ray, SphereTraceDesc params, vec4 vis_spheres[VIS_RAY_MAX_ITERS], inout TraceResult tr) { \n    switch (SPHERE_TRACING_MODE) {\n        case 0: naive_sphere_trace(ray, params, vis_spheres, tr); break;\n        case 1: relaxed_sphere_trace(ray, params, vis_spheres, tr); break;\n        case 2: enhanced_sphere_trace(ray, params, vis_spheres, tr); break;\n    }\n}\n\nfloat sphere_trace_shadow(Ray ray, SphereTraceDesc params, float penumbra, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    switch (SPHERE_TRACING_MODE) {\n        case 0: return naive_sphere_trace_shadow(ray, params, penumbra, vis_spheres);\n        case 1: return relaxed_sphere_trace_shadow(ray, params, penumbra, vis_spheres);\n        case 2: return enhanced_sphere_trace_shadow(ray, params, penumbra, vis_spheres);\n    }\n\n}\n\n\nfloat SoftShadow(vec3 pos, vec3 light_pos, vec4 vis_spheres[VIS_RAY_MAX_ITERS]) {\n    const float penumbra = 10.0;\n    const float intensity = 1.0;\n    \n    SphereTraceDesc params = SphereTraceDesc(0.00001, SHADOW_MAX_ITERS);\n    Ray ray = Ray(pos, 0.0, normalize(light_pos - pos), min(MAX_DIST, length(light_pos - pos)));\n\n    float min_d = sphere_trace_shadow(ray, params, penumbra, vis_spheres);\n\n    \n    return pow(min_d, intensity);\n}\n\n// stolen from: https://learnopengl.com/PBR/Lighting\nvec3 BRDF(vec3 camPos, vec3 WorldPos, vec3 Normal, int mat_id, bool with_shadow, vec4 vis_spheres[VIS_RAY_MAX_ITERS], inout vec3 refl) {\n    vec3 albedo = materials[mat_id].color;\n    float roughness = materials[mat_id].roughness;\n    float emission_strength = materials[mat_id].emission_strength;\n    float metallic = materials[mat_id].metalness;\n\n\n    const float ao = 0.1;\n    const float reflection_attenuation = 1.0;\n\n    vec3 N = normalize(Normal);\n    vec3 V = normalize(camPos - WorldPos);\n\n    vec3 F0 = vec3(0.04);\n    F0 = mix(F0, albedo, metallic);\n\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n    for (int i = 0; i < NUM_OF_LIGHTS; ++i) {\n        vec3 lightPosition = lights[i].position;\n        vec3 lightColor = lights[i].color;\n        // calculate per-light radiance\n        vec3 L = normalize(lightPosition - WorldPos);\n        vec3 H = normalize(V + L);\n        float dist = length(lightPosition - WorldPos);\n        float attenuation = 1.0 / (dist * dist);\n        vec3 radiance = lightColor * attenuation;\n\n        // cook-torrance brdf\n        float NDF = DistributionGGX(N, H, roughness);\n        float G = GeometrySmith(N, V, L, roughness);\n        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n\n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= (1.0 - metallic);\n\n        vec3 numerator = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n        vec3 specular = numerator / denominator;\n\n        // add to outgoing radiance Lo\n        float NdotL = max(dot(N, L), 0.0);\n\n        if (with_shadow) {\n            float shadow = SoftShadow((WorldPos + Normal * 0.0001), lightPosition, vis_spheres);\n            Lo += (kD * albedo / pi + specular) * radiance * NdotL * shadow;\n        } else {\n            Lo += (kD * albedo / pi + specular) * radiance * NdotL;\n        }\n\n    }\n\n    vec3 ambient = vec3(0.03) * albedo * ao;\n    vec3 color = ambient + Lo + albedo * emission_strength * max(dot(V, N), 0.0);\n\n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0 / 2.2));\n\n    color *= refl;\n    refl *= fresnelSchlick(max(dot(V, N), 0.0), F0) * reflection_attenuation;\n\n    return color;\n}\n\n\n\nvec3 Render(Ray ray, Ray vis_ray, SphereTraceDesc params) {\n    vec3 col = vec3(0.0);\n    vec3 refl = vec3(1.0);\n\n    vec4 vis_spheres[VIS_RAY_MAX_ITERS];\n    for (int i = 0; i < VIS_RAY_MAX_ITERS; i++) {\n        vis_spheres[i] = vec4(0.0);\n    }\n    SphereTraceDesc vis_params = SphereTraceDesc(0.001, VIS_RAY_MAX_ITERS);\n    sphere_trace_vis_ray(vis_ray, vis_params, vis_spheres);\n \n\n    TraceResult tr = TraceResult(ray.Tmin, 0, 0);\n    for (int i = 0; i < (NUM_OF_REFLECTIONS + 1); i++) {\n        sphere_trace(ray, params, vis_spheres, tr);\n        \n\n        if (bool(tr.flags & 1)) {\n            col += refl * texture(iChannel2, ray.V).rgb;\n            break;\n        } else if (bool(tr.flags & 2)) {\n            int mat_id = (tr.flags >> 3) & 0xFF;\n            vec3 pos = ray.P + ray.V * tr.T;\n            vec3 norm = normal(pos, vis_spheres);\n            col += BRDF(ray.P, pos, norm, mat_id, (i == 0), vis_spheres, refl);\n\n            ray.P = pos + 0.0001 * norm; // small offset so next sdf doesn't return 0\n            ray.V = reflect(ray.V, norm);\n\n        } else if (bool(tr.flags & 4)) {\n            //col = vec3(1.0, 0.0, 0.0);\n            break;\n        } else {\n            // this shouldn't happen\n            //col = vec3(0.0, 0.0, 1.0);\n            break;\n        }\n\n        tr.T = 0.0;\n        tr.flags = 0;\n    }\n\n\n\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float epsilon;\n    Ray ray = ReadCamera(fragCoord, epsilon);\n\n    Ray vis_ray = ReadVisRay();\n\n    SphereTraceDesc params = SphereTraceDesc(epsilon, IMAGE_MAX_ITERS);\n\n    vec3 color = Render(ray, vis_ray, params);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}