{"ver":"0.1","info":{"id":"XdlXDn","date":"1471516059","viewed":453,"name":"Irradiance Envmap (SHO3)","username":"xwize","description":"Experimenting with generating SH03 from MATLAB and testing with glsl. Implementation of http://www.cs.berkeley.edu/~ravir/papers/envmap/envmap.pdf.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sphericalharmonics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/****\nclear all;\n\n% Load cubemap faces as images\ncubeMapFacePosX = hdrread('cubemap/egposx.hdr');\ncubeMapFacePosY = hdrread('cubemap/egposy.hdr');\ncubeMapFacePosZ = hdrread('cubemap/egposz.hdr');\ncubeMapFaceNegX = hdrread('cubemap/egnegx.hdr');\ncubeMapFaceNegY = hdrread('cubemap/egnegy.hdr');\ncubeMapFaceNegZ = hdrread('cubemap/egnegz.hdr');\n\ncubeMapFaceWidth = size(cubeMapFacePosX,1);\ncubeMapFaceHeight = size(cubeMapFacePosX,2);\n\n% Setup a list to iterate through\ncubeMap = {cubeMapFacePosX; cubeMapFacePosY; cubeMapFacePosZ;\n    cubeMapFaceNegX; cubeMapFaceNegY; cubeMapFaceNegZ};\n\n% Coordinate system\ncubeMapFaceNormal   = {[1,0,0];     [0,1,0];    [0,0,1];    [-1,0,0];   [0,-1,0];   [0,0,-1]};\ncubeMapFaceTangent  = {[0,0,-1];    [1,0,0];    [1,0,0];    [0,0,1];    [1,0,0];    [-1,0,0]};\ncubeMapFaceBinormal = {[0,-1,0];    [0,0,1];    [0,-1,0];   [0,-1,0];   [0,0,-1];   [0,-1,0]};\n\n% Basis functions for SH O3\ny_0_p0 = 0.282095;\n\ny_1_n1 = @(y) y .* 0.488603;\ny_1_p0 = @(z) z .* 0.488603;\ny_1_p1 = @(x) x .* 0.488603;\n\ny_2_n2 = @(x,y) x.*y .* 1.092548;\ny_2_n1 = @(y,z) y.*z .* 1.092548;\ny_2_p0 = @(z) (3.*z.^2 - 1) .* 0.315392;\ny_2_p1 = @(x,z) x.*z .* 1.092548;\ny_2_p2 = @(x,y) (x.^2 - y.^2) .* 0.546274;\n\n% Accumlators\nacc = zeros(9,3);\naccWeight = 0.0;\n\n% Peform the projection\nfor faceIndex = 1:6\n    cubeMapFace = cubeMap{faceIndex};\n    for col = 1:cubeMapFaceWidth\n        for row = 1:cubeMapFaceHeight\n            u = double(col);\n            v = double(row);\n            u_scale = 1.0 / double(cubeMapFaceWidth);\n            v_scale = 1.0 / double(cubeMapFaceHeight);\n            u = 2.0 .* (u .* u_scale - 0.5);\n            v = 2.0 .* (v .* v_scale - 0.5);\n            cubeMapDir = cubeMapFaceNormal{faceIndex};\n            cubeMapDir = cubeMapDir + cubeMapFaceTangent{faceIndex} .* u;\n            cubeMapDir = cubeMapDir + cubeMapFaceBinormal{faceIndex} .* v;\n            cubeMapDir = cubeMapDir ./ norm(cubeMapDir);\n            cubeMapFace = cubeMap{faceIndex};\n            funcEvalRGB = [cubeMapFace(row,col,1),cubeMapFace(row,col,2),cubeMapFace(row,col,3)];\n            % Tone mapping (couldn't match the whitepaper values without this)\n            funcEvalRGB = funcEvalRGB ./ 10;\n            \n            % Convolve with each basis function\n            integrand = zeros(9,3);\n            integrand(1,:) = funcEvalRGB .* y_0_p0; \n            \n            integrand(2,:) = funcEvalRGB .* y_1_n1(cubeMapDir(2)); \n            integrand(3,:) = funcEvalRGB .* y_1_p0(cubeMapDir(3)); \n            integrand(4,:) = funcEvalRGB .* y_1_p1(cubeMapDir(1)); \n            \n            integrand(5,:) = funcEvalRGB .* y_2_n2(cubeMapDir(1),cubeMapDir(2)); \n            integrand(6,:) = funcEvalRGB .* y_2_n1(cubeMapDir(2),cubeMapDir(3)); \n            integrand(7,:) = funcEvalRGB .* y_2_p0(cubeMapDir(3)); \n            integrand(8,:) = funcEvalRGB .* y_2_p1(cubeMapDir(1),cubeMapDir(3)); \n            integrand(9,:) = funcEvalRGB .* y_2_p2(cubeMapDir(1),cubeMapDir(2)); \n            \n            % Wouldn't mind an explanation of why this works\n            % It's something to do with the differential solid angle of a texel\n            factor = 1 + u^2+v^2;\n            weight = 4.0/(sqrt(factor) .* factor); \n            acc = acc + integrand .* weight;\n            accWeight = accWeight + weight;\n        end\n    end\nend\n\nnumSamples = 6 * cubeMapFaceWidth * cubeMapFaceHeight;\nacc = 4.0 * pi * acc / accWeight\n\n% Print out glsl shader code for coefficients\ns1 = sprintf('vec3 l_0_p0 = vec3(%f,%f,%f);',acc(1,1),acc(1,2),acc(1,3));\n\ns2 = sprintf('vec3 l_1_n1 = vec3(%f,%f,%f);',acc(2,1),acc(2,2),acc(2,3));\ns3 = sprintf('vec3 l_1_p0 = vec3(%f,%f,%f);',acc(3,1),acc(3,2),acc(3,3));\ns4 = sprintf('vec3 l_1_p1 = vec3(%f,%f,%f);',acc(4,1),acc(4,2),acc(4,3));\n\ns5 = sprintf('vec3 l_2_n2 = vec3(%f,%f,%f);',acc(5,1),acc(5,2),acc(5,3));\ns6 = sprintf('vec3 l_2_n1 = vec3(%f,%f,%f);',acc(6,1),acc(6,2),acc(6,3));\ns7 = sprintf('vec3 l_2_p0 = vec3(%f,%f,%f);',acc(7,1),acc(7,2),acc(7,3));\ns8 = sprintf('vec3 l_2_p1 = vec3(%f,%f,%f);',acc(8,1),acc(8,2),acc(8,3));\ns9 = sprintf('vec3 l_2_p2 = vec3(%f,%f,%f);',acc(9,1),acc(9,2),acc(9,3));\n\nsprintf('%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n%s\\n',s1,s2,s3,s4,s5,s6,s7,s8,s9)\n***/\n\nhighp float Time;\n\nconst highp float PI = 3.1415926;\nconst highp float INV_PI = 1.0/PI;\nconst highp float PI_2 = PI * 2.0;\n\nconst highp float MARCH_EPS = 0.065;\nconst highp float GRAD_EPS = 0.005;\n\nstruct sdv\n{\n    highp float d;\n    highp int idx;\n};\n\nstruct rayHit\n{\n    highp vec3 p;\n    highp int idx;\n};\n\nsdv combine(sdv a, sdv b)\n{\n    if(a.d < b.d)\n    {  \n        return a;\n    }\n    \n    return b;\n}\n\nconst int IDX_ROOM = 1;\nconst int IDX_ROOM_BOTTOM = 2;\nconst int IDX_SPHERE = 3;\n\nsdv scene(highp vec3 p)\n{\n    sdv sphere;\n    sphere.idx = IDX_SPHERE;\n\n\tvec3 c = vec3(0.0,0.0,0.0);\n\tfloat r = 24.0 + 0.5*(sin(0.05*p.x*p.y+iTime*5.0));\n\tsphere.d = length(p-c) - r;\n\t\n    return sphere;\n}\n\nhighp vec3 sceneGrad(highp vec3 p)\n{\n    const highp float h = GRAD_EPS;\n    highp vec3 g;\n    g.x = scene(p+vec3(h,0.0,0.0)).d - scene(p-vec3(h,0.0,0.0)).d;\n    g.y = scene(p+vec3(0.0,h,0.0)).d - scene(p-vec3(0.0,h,0.0)).d;\n    g.z = scene(p+vec3(0.0,0.0,h)).d - scene(p-vec3(0.0,0.0,h)).d;\n    return g / (2.0*h);\n}\n\nrayHit rayQuery(highp vec3 start, highp vec3 dir)\n{\n    highp float d = 0.0;\n    const highp float eps = MARCH_EPS;\n    const int numIter = 76;\n    \n    for(int i = 0; i < numIter; ++i)\n    {\n        highp vec3 p = start + dir * d;\n        sdv v = scene(p);\n        if(v.d < eps)\n        {\n            rayHit ret;\n            ret.idx = v.idx;\n            ret.p = p;\n            return ret;\n        }\n        \n        d += v.d;\n    }\n    \n    rayHit ret;\n    ret.idx = -1;\n    ret.p = vec3(0.0);\n    return ret;\n}\n\nhighp vec3 sceneEmittance(highp int idx)\n{\n    return vec3(0.0);\n}\n\nhighp float computeAO(highp vec3 p, highp vec3 normal)\n{\n    highp float ao = 0.0;\n    highp vec3 k = p;\n    const int numSamps = 20;\n    const highp float h = 1.0 / float(numSamps);\n    const highp float d = 0.15;\n    \n    for(int i = 0; i < numSamps; ++i)\n    {\n        ao += h * exp(scene(k).d);\n        k += normal * d;\n    }\n    return clamp(ao*0.125,0.0,1.0);\n}\n\nhighp vec3 computeIrradiance(highp vec3 n)\n{\n\t// Coefficients for SH 03\n\tvec3 l_0_p0 = vec3(0.379727,0.427857,0.452654);\n\tvec3 l_1_n1 = vec3(0.288207,0.358230,0.414330);\n\tvec3 l_1_p0 = vec3(0.039812,0.031627,0.012003);\n\tvec3 l_1_p1 = vec3(-0.103013,-0.102729,-0.087898);\n\tvec3 l_2_n2 = vec3(-0.060510,-0.053534,-0.037656);\n\tvec3 l_2_n1 = vec3(0.008683,-0.013685,-0.045723);\n\tvec3 l_2_p0 = vec3(-0.092757,-0.124872,-0.152495);\n\tvec3 l_2_p1 = vec3(-0.059096,-0.052316,-0.038539);\n\tvec3 l_2_p2 = vec3(0.022220,-0.002188,-0.042826);\n\t\t\n\thighp vec3 irr = vec3(0.0);\n\t\n\tfloat c1 = 0.429043;\n\tfloat c2 = 0.511664;\n\tfloat c3 = 0.743125;\n\tfloat c4 = 0.886227;\n\tfloat c5 = 0.247708;\n\t\n\tirr += c1 * l_2_p2 * (n.x*n.x - n.y*n.y);\t\n\tirr += c3 * l_2_p0 * (n.z*n.z);\n\tirr += c4 * l_0_p0;\n\tirr -= c5 * l_2_p0;\n\tirr += 2.0 * c1 * (l_2_n2*n.x*n.y + l_2_p1*n.x*n.z + l_2_n1*n.y*n.z);\n\tirr += 2.0 * c2 * (l_1_p1*n.x + l_1_n1*n.y + l_1_p0*n.z);\n\t\n\treturn vec3(irr);\n}\n\nhighp vec3 computeRadiance(highp vec3 camPos, highp vec3 camDir)\n{\n    rayHit q = rayQuery(camPos,camDir);\n    if(q.idx >= 0)\n    {\n        highp vec3 normal = normalize(sceneGrad(q.p));\n        highp vec3 ambient = vec3(0.0);\n    \n        highp vec3 radiance = ambient;\n        radiance += sceneEmittance(q.idx) +\n           \tcomputeIrradiance(normal);\n            \n        return radiance;\n    }\n\t\n    return texture(iChannel0,camDir).rgb;\n}\n\nhighp mat4 lookAtInv(highp vec3 eyePos, highp vec3 targetPos, highp vec3 upVector)\n{\n    highp vec3 forward = normalize(targetPos - eyePos);\n    highp vec3 right = normalize(cross(forward,upVector));\n    upVector = normalize(cross(right,forward));\n    \n    highp mat4 r;\n    r[0] = vec4(right,0.0);\n    r[1] = vec4(upVector,0.0);\n    r[2] = vec4(-forward,0.0);\n    r[3] = vec4(eyePos,1.0);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tTime = iTime;\n\t\n\thighp vec2 uv = fragCoord.xy / vec2(iResolution.x,iResolution.y);\n\t\n\tfloat r = 120.0;\n\tfloat s = 0.5;\n\thighp mat4 m = lookAtInv(vec3(r*cos(Time*s),sin(Time*s)*50.0,r*sin(Time*s)),vec3(0.0,0.0,0.0),vec3(0.0,1.0,0.0));\n\thighp float sw = 0.0;\n\t\n\tconst highp float aspect = 2.0;\n\thighp vec3 camPos = vec3((uv.x-0.5)*aspect,uv.y-0.5,0.0);\n\thighp vec3 camDir = normalize(vec3(aspect*(uv.x-0.5),uv.y-0.5,-1.5-sw));\n\n    camPos = ( m * vec4(camPos,1.0) ).xyz;\n    camDir = ( m * vec4(camDir,0.0) ).xyz;\n    \n\thighp vec3 radiance = vec3(0.0);\n    radiance += computeRadiance(camPos,camDir);\n\n\tfragColor = vec4(pow(vec3(radiance),vec3(1.0/2.2)),0.0);\n}\n","name":"Image","description":"","type":"image"}]}