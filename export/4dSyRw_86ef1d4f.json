{"ver":"0.1","info":{"id":"4dSyRw","date":"1491272465","viewed":155,"name":"Chrome Texture Bug","username":"schuylermartin45","description":"Simple shader used to test out the bug I found while working on a class project, documented here: https://bugs.chromium.org/p/chromium/issues/detail?id=707759","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["texturebug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n** File:        Chrome Texture Bug Test\n**\n** Author:      Schuyler Martin <sam8050@rit.edu>\n**\n** Description:  Simplified version of this texture: https://www.shadertoy.com/view/Xdsczs\n**               Used to debug this issue: https://bugs.chromium.org/p/chromium/issues/detail?id=707759\n**\n*/\n\n/*** Macros ***/\n\n/*** Abstract Types ***/\n\n// describes Phong illumination model parameters\nstruct Phong {\n    // reflection params\n    // ambient light\n    vec3 ka;\n    // kd + ks < 1\n    // diffuse (Lambertian reflection)\n    vec3 kd;\n    // specular (mirror-like relfection)\n    vec3 ks;\n    // expontent; size of specular highlight\n    float ke;\n};\n\n/*** Objects in scene ***/\n\n// properties belonging to the whole world\n// (in his hands, he's got the whole world in his hands)\nstruct World {\n    vec3 clr;\n    vec3 ka;\n};\nconst World world = World(\n\t// background color; cornflower blue, of course\n\tvec3(0.39, 0.58, 0.93),\n\t// world ambient light\n\tvec3(0.9, 0.9, 0.9)\n);\n\n// Plane struct\nstruct Plane {\n    // coefficients of plane equation\n    // also describes the normal\n    vec3 coef;\n    // color, 2 for the checkerboard\n    vec3 clr0;\n    vec3 clr1;\n    // specular highlights\n    vec3 spec;\n    // phong information\n    Phong ph;\n    // two bounding points (upper right, lower left) in the x-z plane\n    vec2 ur;\n    vec2 ll;\n};\n\n// back sky plane; this is a special plane\nPlane sky_plane = Plane(\n    // this gets set to be parallel to the camera\n    // later on\n    vec3(0.0, 0.0, 1.0),\n    // primary color is the blue sky\n    world.clr,\n    // secondary stores a hint of orange\n    vec3(255.0/255.0, 140.0/255.0, 0.0/255.0),\n    vec3(0.7, 0.7, 0.7),\n    Phong(\n    \tvec3(0.5, 0.5, 0.5),\n        // diffuse is orange\n        vec3(255.0/255.0, 140.0/255.0, 0.0/255.0),\n        vec3(0.75, 0.75, 0.75),\n        100.0\n    ),\n    vec2(0.0, 0.0),\n    vec2(0.0, 0.0)\n);\n\n// a boat is just 5 planes, bottom plus 4 sides\nstruct Boat {\n\tPlane bt;\t// bottom\n};\n// all the boat sides have the same phong properties\nconst Phong boat_phong = Phong(\n\tvec3(0.9, 0.9, 0.9),\n    vec3(0.7, 0.7, 0.7),\n    vec3(0.2, 0.2, 0.2),\n    1.0\n);\n// da boat\nBoat the_boat = Boat(\n    Plane(\n    \tvec3(0.0, 1.0, 0.0),\n      \t// \"EVERYTHING'S BROWN!\" - Regular Car Reviews\n        // (will be replaced with the texture color later)\n        vec3(105.0/256.0, 21.0/256.0, 0.0),\n    \tvec3(0.9, 0.9, 0.9),\n    \tvec3(0.8, 0.8, 0.8),\n\t\tboat_phong,\n    \tvec2( 5.0, 3.0),\n    \tvec2(-5.0,-3.0)\n    )\n);\n\n\n/*** Non-visible objects ***/\n\n// representation of a ray, a drop of golden sun\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};   \n\n// Camera struct\nstruct Camera {\n    // position\n    vec3 pos;\n    // look at vector\n    vec3 look_at;\n    // up vector; forms the ground-plane assumption\n    vec3 up;\n    // camera ray\n    Ray ry;\n};\n// Cambot, Gypsy, Tom Servo, CROOOOOOOOOOOOOW!\nCamera cambot = Camera(\n    vec3(5.0, 2.0, 5.0),\n    //vec3(7.0, 1.5, 2.3),\n    vec3(0.0, 0.0, -1.0), \n    vec3(0.0, 1.0, 0.0),\n    // initialized later\n    Ray(\n        vec3(0.0, 0.0, 0.0),\n        vec3(0.0, 0.0, 0.0)\n    )\n); \n\n// Light struct\nstruct Light {\n    vec3 pos;\n   \t// \"radiance\" of the light\n    vec3 clr;\n};\n\n// Lights; light 0 will be the \"sun\"\nLight sun_light = Light(\n    vec3(0.0, 5.0, 0.0),\n    vec3(247.0/255.0, 211.0/255.0, 82.0/255.0)\n);\n\n/*\n** Check if a ray intersects a bounded plane\n**\n** @param ry Ray structure\n** @param pl Plane structure\n**\n** @return Distance to plane\n*/\nfloat int_plane(Ray ry, Plane pl)\n{\n    // Basic Ray Tracer, pg. 32\n\tfloat omega = (-1.0 * (dot(pl.coef, ry.pos))\n        / dot(pl.coef, ry.dir)\n    );\n    // skip bounds checking if all plane boundries are zeroed-out\n    if (dot(pl.ur, pl.ll) != 0.0)\n    {\n        // cut the plane by emitting negative distance by calculating\n        // and comparing against a solution point; this effectively\n        // cuts out some plane calculations\n        vec3 bound_pt = ry.pos + (omega * ry.dir);\n        if ((bound_pt.x < pl.ll.x) || (bound_pt.x > pl.ur.x)\n            || ((bound_pt.z < pl.ll.y) || (bound_pt.z) > pl.ur.y))\n            return -42.0;\n    }\n    return omega;\n}\n\n/*\n** Check if a ray intersects a bounded plane\n** (Overload that just calculates the distance)\n**\n** @param ry Ray structure\n** @param pl Plane structure\n**\n** @return Distance to plane\n** @out int_pt Intersection pt\n** @out n Surface normal\n*/\nfloat int_plane(Ray ry, Plane pl, out vec3 int_pt, out vec3 n)\n{\n\tfloat omega = int_plane(ry, pl);\n    int_pt = ry.pos + (ry.dir * omega);\n    n = pl.coef.xyz;\n    return omega;\n}\n\n/*\n** Calculates the color of something, based on the Phong illumination model\n**\n** @param pl Plane placeholder object\n** @param lights Array of lights in the scene\n** @param int_pt Intersection point, seen by the camera\n** @param n Normal to that intersection point\n** @return Color of point to shade\n*/\nvec3 calc_phong(Plane pl, Light light, vec3 int_pt, vec3 n)\n{\n    // retrieve the values based on the object type\n    vec3 obj_clr, obj_spec;\n    Phong obj_ph;\n\n    if (mod(int_pt.x, 2.0) > 1.0)\n        obj_clr = pl.clr0;\n    obj_spec = pl.spec;\n    obj_ph = pl.ph;\n    \n    // calculate the ambient portion first\n    // I just use the object's ambience setting and the object's color\n    vec3 ambi_clr = obj_ph.ka * obj_clr;\n\n    // if the light is visible, sum the other light sources\n    // diffuse and specular calculations require running through each light\n    vec3 diff_sum = vec3(0.0, 0.0, 0.0);\n    vec3 spec_sum = vec3(0.0, 0.0, 0.0);\n\n    // calculate light vectors\n    // source vector\n    vec3 s = normalize(light.pos - int_pt);\n    // V (view vector) is the reverse of S\n    vec3 v = normalize(-1.0 * s);\n    // reflection vector\n    vec3 r = reflect(normalize(v), n);\n\n    // Here's where we branch from the notes, b/c this implementation\n    // uses a moving camera\n    // Find vectors that point to things used in the lighting\n    vec3 v_cam = normalize(cambot.pos - int_pt);\n    vec3 v_light = normalize(light.pos - int_pt);\n\n    // Angle directions. These are clamped do prevent some kind of\n    // weird \"overflow\" problem described by other ShaderToy users.\n    // Without the clamp, the balls emit light from the \"dark side\n    // of the ball\" *queues synth*\n\n    // diffuse angle points to the light source\n    float light_theta = clamp(dot(v_light, n), 0.0, 1.0);\n    // specular angle points to the camera\n    float cam_theta = clamp(dot(r, v_cam), 0.0, 1.0);\n\n    diff_sum += light.clr * obj_clr * light_theta;\n    spec_sum += light.clr * obj_spec * pow(cam_theta, obj_ph.ke);\n\n    // put it all together\n    return ambi_clr + (obj_ph.kd * diff_sum) + (obj_ph.ks * spec_sum);\n}\n\n/*\n** Read color from the wood texture to use in the boat wood\n**\n** **Note: See file header for more information about texture loading\n** issues\n**\n** @param pt Vector position to use to pull data from the texture\n** @return Color from the wood texture\n*/\nvec3 boat_color(vec3 pt)\n{\n    vec2 pt2D = (pt.xy + (vec2(128.0, 32.0) * (pt.z + 1.0))) + pt.xy;\n    pt2D.x = clamp(pt2D.x, 0.0, 1024.0);\n    pt2D.y = clamp(pt2D.y, 0.0, 1024.0);\n    //-1.0 + 2.0 * mix(rgb.r, rgb.g, rgb.b);\n    // load the RGB color value from the position in the texture\n    vec3 color = texture(iChannel0, pt2D / 1024.0).rgb;\n    // lighten the wood color\n    color = mix(vec3(0.5, 0.5, 0.5), color, 0.8);\n    return color;\n}\n\n/********** END Object Drawing **********/\n\n/*\n** Main routine\n**\n** @in fragCoord Fragment location\n** @out fragColor Color of fragment to shade\n*/\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)   \n{   \n    // uv describes the viewport in terms of some xy amount from 0-1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    // convert to a cambot-friendly viewport window\n    uv = -1.0 + (2.0 * uv);\n    // account for widescreen (16:9?) ratio\n    uv.x *= iResolution.x / iResolution.y;\n    \n    /***** Cambot control *****/\n    \n    // use the mouse screen position to move the camera a little bit in 3D\n    // fixed to look towards the center of the image\n    vec2 mouse_pos = (iMouse.xy / iResolution.xy);\n\n    // reset the camera to the default position on frame reset\n    if ((iFrame != 0) && (mouse_pos.x != 0.0) && (mouse_pos.y != 0.0))\n    {\n        cambot.pos *= (2.0 * normalize(\n            vec3(sin(mouse_pos.x), 0.75 * mouse_pos.y, cos(mouse_pos.x))\n        ));\n    }\n\n    // get vector out of the camera positioning\n    vec3 in_front = normalize(cambot.look_at - cambot.pos);\n    // ray spawns from camera\n    vec3 right = normalize(cross(cambot.up, in_front));\n    cambot.up = normalize(cross(in_front, right));\n    // build the camera transformation matrix\n    mat3 cambot_trans = mat3(right, cambot.up, in_front);\n    \n    \n    // assume ray is coming from the camera, which means\n    // we need to define it after our calculations\n    cambot.ry  = Ray(\n        cambot.pos,\n        // adjusting the 3rd parameter streches the creen and causes a cool fish-eye\n        // lensing effect. Set it too low, and you get the acid trip from 2001\n        normalize(cambot_trans * normalize(vec3(uv, 1.0)))\n    );\n\n    // calculated color from illumination model\n    vec3 color;\n    // calculate the intersection point from the camera; which spawns\n    // the other rays\n    vec3 int_pt;\n    // surface normal\n    vec3 n;\n    \n    // sides of the boat\n    if (int_plane(cambot.ry, the_boat.bt, int_pt, n) > 0.0)\n\t{\n        // texture the boat plane using the ray intersection\n        // to seed the texture look-up\n        the_boat.bt.clr0 = boat_color(int_pt);\n    \tcolor = calc_phong(the_boat.bt, sun_light, int_pt, n);\n\t}\n    else\n        color = world.clr;\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}