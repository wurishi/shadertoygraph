{"ver":"0.1","info":{"id":"3lG3DK","date":"1579822725","viewed":490,"name":"espejitos","username":"bitnenfer","description":"Another small path tracing test, mostly testing making a scene composition.\nYou can use the mouse to rotate the scene.","likes":20,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf","pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(acesFilm(texture(iChannel0, uv).rgb),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_DIST 20.0\n#define MIN_DIST 0.001\n#define PI 3.14159265359\n#define TAU (PI * 2.0)\n\nstruct Hit\n{\n    float dist;\n    float diffuse;\n    float specular;\n    float isLight;\n    vec3 color;\n};\n\nconst Hit kInvHit = Hit(MAX_DIST + 1.0, 0.0, 0.0, 1.0, vec3(1.0, 0.0, 1.0));\n\nfloat gSeed = 0.0;\nvec2 gUV;\n\nfloat hash( float n )\n{\n    return fract(sin(n + gSeed)*43758.5453);\n}\n\nfloat random() {\n\n    return hash(fract(sin(dot(gUV, vec2(12.9898, 78.233)) * (gSeed += 1.0)) * 43758.5453));\n}\n\nvec3 randomHemispherePoint()\n{\n    float theta = random() * (PI*2.0);\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\nmat2 rot(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat sdBox(vec3 p, vec3 s)\n{\n    vec3 d = abs(p) - s;\n    return length(max(d, 0.0)) + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdPyramid( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nHit opMin(Hit a, Hit b)\n{\n    if (a.dist < b.dist)\n    {\n        return a;\n    }\n    return b;\n}\n\nvec3 opRep(vec3 p, vec3 r)\n{\n    return mod(p, r) - r * 0.5;\n}\n\nHit map(vec3 p)\n{\n    Hit scene = kInvHit;\n    vec3 lightP = p;\n    lightP.y -= 0.1;\n    lightP.z += 0.5;\n    lightP.yz *= rot(0.9);\n    float lightBoxSDF = sdBox(lightP, vec3(1.9, 1.5, 0.01));\n    float lightBoxSplit = sdBox(opRep(lightP, vec3(0.7, 0.0, 0.0)), vec3(0.2, 10.0, 1.0));\n    lightBoxSDF = max(lightBoxSDF, -lightBoxSplit);\n    Hit lightBoxHit = Hit(lightBoxSDF, 1.0, 0.0, 1.0, vec3(2.0, 1.5, 2.0));\n    vec4 t = texture(iChannel2, p.xz * 0.1);\n    float floorSDF = (p.y + 1.0 - t.r * 0.05) * 0.7;\n    Hit floorHit = Hit(floorSDF, 1.0, 0.95, 0.0, vec3(0.1, 0.2, 0.4));\n    vec3 offset = vec3(0.0, 0.60, 1.65);\n    \n    Hit boxHit = Hit(sdBox(p + offset, vec3(0.3)), 1.0, 1.0, 0.0, vec3(2.0, 0.0, 0.0));\n    Hit sphereHit = Hit(length(p + offset + vec3(1.0, -0.04, 0.0)) - 0.35, 1.0, 1.0, 0.0, vec3(0.0, 2.0, 0.0));\n    vec3 pp = p + offset + vec3(-0.9, 0.3, 0.0);\n    pp.x *= 1.2;\n    Hit pyrHit = Hit(sdPyramid(pp, 0.6), 1.0, 1.0, 0.0, vec3(0.0, 0.0, 2.0));\n\n    float frameSDF = sdBox(vec3(abs(p.x) - 1.4, p.y, p.z + 1.6), vec3(0.03, 1.00, 0.03)) * 0.5;\n    Hit frameHit = Hit(frameSDF, 1.0, 0.0, 0.0, vec3(0.0));\n    \n    float platformSDF = sdBox(p + vec3(0.0, 1.1, 1.0), vec3(1.5, 0.2, 1.8));\n   \tHit platformHit = Hit(platformSDF, 1.0, 1.0, 0.0, vec3(0.0));\n    \n    scene = opMin(lightBoxHit, floorHit);\n    scene = opMin(scene, boxHit);\n    scene = opMin(scene, sphereHit);\n    scene = opMin(scene, pyrHit);\n    scene = opMin(scene, frameHit);\n    scene = opMin(scene, platformHit);\n    \n    return scene;\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 e = vec2(0.0, 0.001);\n    return normalize(vec3(\n        map(p + e.yxx).dist - map(p - e.yxx).dist,\n        map(p + e.xyx).dist - map(p - e.xyx).dist,\n        map(p + e.xxy).dist - map(p - e.xxy).dist\n    ));\n}\n\nHit raymarch(vec3 ro, vec3 rd, out bool hitSurface)\n{\n    float t = 0.0;\n    hitSurface = false;\n    for (int i = 0; i < 400; ++i)\n    {\n        Hit hit = map(ro + rd * t);\n        if (hit.dist < MIN_DIST)\n        {\n            hit.dist = t;\n            hitSurface = true;\n            return hit;\n        }\n        t += hit.dist;\n        if (t > MAX_DIST)\n        {\n            break;\n        }\n    }\n    return kInvHit;\n}\n\nvec3 tpm(sampler2D tex, vec3 p, vec3 n)\n{\n    float sc = 0.5;\n    vec4 colX = texture(tex, p.zy * sc);\n    vec4 colY = texture(tex, p.xz * sc);\n    vec4 colZ = texture(tex, p.xy * sc);\n    vec3 n2 = n;\n    vec3 bw = abs(n2);\n    bw = bw / (bw.x + bw.y + bw.z);\n    vec3 c = colX.rgb * bw.x + colY.rgb * bw.y + colZ.rgb * bw.z;\n    return c * ((colX.a + colY.a + colZ.a) / 3.0);\n}\n\n#define BOUNCE_COUNT 4\n#define SAMPLE_COUNT 1\n#define SPECULAR 1\n#define DIFFUSE 1\n#define ATTEN_FACTOR 0.5\n#define DEBUG 0\n\nvec3 trace(vec2 uv)\n{\n    vec3 finalColor = vec3(0.0);\n    vec2 offsetSize = 4.0 / iResolution.xy;\n    for (int sampleIndex = 0; sampleIndex < SAMPLE_COUNT; sampleIndex++)\n    {\n\n        vec2 jitter = (vec2(random(), random()) * (offsetSize));\n        vec3 ro = vec3(0.5, -0.5, -10.0);\n        vec3 rd = normalize(vec3(uv.xy + jitter, 5.0));\n        vec3 colorAccum = vec3(0.0);\n        float hitLight = 0.0;\n        float mx = -(iMouse.x / iResolution.x * 2.0 - 1.0) * TAU;\n        \n        mx -= 0.8;\n        ro.z -= 0.8;\n        ro.xz *= rot(mx);\n        rd.xz *= rot(mx);\n        \n        #if DEBUG\n        {\n            \n        \n            bool hitSurface = false;\n            Hit debugHit = raymarch(ro, rd, hitSurface);\n            if (hitSurface)\n            {\n                vec3 p = ro + rd * debugHit.dist;\n                vec3 n = normal(p);\n                return n;\n            }\n            return vec3(0.0);\n        }\n        #endif\n        \n        // Diffuse\n        #if DIFFUSE\n        {\n\t        float colorAtten = 1.0;\n            vec3 diffRO = ro;\n            vec3 diffRD = rd;\n            for (int bounceIndex = 0; bounceIndex < BOUNCE_COUNT; bounceIndex++)\n            {\n                bool hitSurface = false;\n                vec2 jit = vec2(0.0, 0.0);\n                Hit bounceHit = raymarch(diffRO, diffRD + vec3(jit, 0.0), hitSurface);\n                if (hitSurface)\n                {\n                    vec3 p = diffRO + diffRD * bounceHit.dist;\n                    vec3 n = normal(p);\n                    colorAccum += (bounceHit.color * colorAtten);\n                    hitLight += bounceHit.isLight;\n                    colorAtten *= ATTEN_FACTOR * 2.0;\n                    diffRD = n + randomHemispherePoint() * bounceHit.diffuse;\n                    diffRO = p + diffRD * 0.1;\n                    continue;\n                }\n                break;\n            }\n        }\n        #endif\n        \n        // Specular\n        #if SPECULAR\n        {\n\t        float colorAtten = 1.0;\n            vec3 specRO = ro;\n            vec3 specRD = rd;\n            for (int bounceIndex = 0; bounceIndex < BOUNCE_COUNT; bounceIndex++)\n            {\n                bool hitSurface = false;\n                Hit bounceHit = raymarch(specRO, specRD, hitSurface);\n                if (hitSurface)\n                {\n                    vec3 p = specRO + specRD * bounceHit.dist;\n                    vec3 n = normal(p);\n                    colorAccum += (bounceHit.color * colorAtten);\n                    hitLight += bounceHit.isLight;\n                    colorAtten *= ATTEN_FACTOR;\n                    specRD = normalize(reflect(specRD, n)) + randomHemispherePoint() *  clamp(1.0-bounceHit.specular, 0.0, 1.0);\n                    specRO = p + specRD * 0.1;\n                }\n            }\n        }\n        #endif\n        \n        if (hitLight > 0.0)\n        {\n            finalColor += colorAccum;\n        }\n    }\n    \n    return finalColor / float(SAMPLE_COUNT);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 ar = vec2(iResolution.x / iResolution.y, 1.0);\n    vec2 uv = (fragCoord.xy / iResolution.xy * 2.0 - 1.0) * ar;\n    vec4 prev = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\tfloat ss = 0.96;\n    gSeed = iTime;\n    gUV = uv;\n    \n    float iframe = mix(prev.a, 0.0, clamp(iMouse.z, 0.0, 1.0));\n    {\n    \tss += mix(0.00, 0.1, clamp(iframe / 400.0, 0.0, 1.0));\n        ss = clamp(ss, 0.0, 0.999);\n    }\n    \n    vec3 color = trace(uv);\n    fragColor = vec4(mix(color, prev.rgb, mix(ss, 0.0, clamp(iMouse.z, 0.0, 1.0))), iframe + 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}