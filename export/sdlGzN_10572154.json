{"ver":"0.1","info":{"id":"sdlGzN","date":"1615836039","viewed":1214,"name":"Tiled Map (WFC)","username":"kastorp","description":"Minimalistic implementation of Wave Function Collapse with brute force.\nWait about 30 seconds to have collapse 99% completed.\nHex version here [url]https://www.shadertoy.com/view/Nsj3Rz[/url]","likes":36,"published":1,"flags":32,"usePreview":0,"tags":["map","tiles","generation","wfc"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// TILE MAP (WFC) by kastorp 2021\n/*\nRULES:\ngrass has higher probability\nforest can be next to grass and has medium probability\nsea can be next to grass and has medium probability\nfarms can be next to grass and has lower probability\nhouses can exist on grass\nmines and mountains can exist on forest\nroads connect houses or mines,  cannot cross sea, can have sometime a junction\nlakes (disabled) can exist on forest and farm\nrivers (disabled) connect lakes or sea, and cross roads\n\n*/\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 i = floor(x), f = fract(x);\n    f = f*f*(3.0-2.0*f);\t\n    return mix(mix( hash(i+vec2(0,0)),hash(i+vec2(1,0)),f.x),mix( hash(i+vec2(0,1)),hash(i+vec2(1,1)),f.x),f.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 Q )\n{\n    vec2 p=(Q)/Z +M.xy , d= fract(p)-.5;\n    O=vec4(1);\n    ivec4 tx = TX(p);   \n    int m =tx.x; \n    if(m>=0){\n        float br1= noise(p*3.)*.2+.8,br2= noise(p*10.)*.1+.9,br3= noise(p*10.)*.4+.6,br4=mod(floor(d.x*4.)+floor(d.y*4.),2. )*.1+.9;\n\n        //terrain\n        for(int i=-1;i<=7;i++) {\n            int k= (m & (1<<(2*i))*3)>>(2*i);\n            O = mix(O,vec4(k==1?vec3(.3,.5,0)*br1:k==2?vec3(0,.5,.5)*br2:k==3?vec3(.7,.6,0)*br4:vec3(0,.3,0)*br3,0),slice(i,d));\n        }\n\n        //roads & rivers\n        for(int i=0;i<4;i++) {        \n             int k= (m & (1<<(2*i +16))*3)>>(2*i+16);\n            if(k>0) O = mix(O,vec4(k==1?vec3(.6,.3,.1):k==2?vec3(.1,.3,.6):vec3(.2,.2,.2),0),stripe(i,d));\n        }\n\n        //building\n        int k= (m & (1<<24)*15)>>24;\n        if(k==1) {\n            //house\n            O = mix(O,vec4(1,1,1,0),box((d-vec2(0,d.x)) ,vec2(.09,-.08),vec2(.05,.1)));\n            O = mix(O,vec4(0),box((d-vec2(0,d.x))       ,vec2(.09,-.08),vec2(.02,.02)));\n            O = mix(O,vec4(1,1,1,0),box(d               ,vec2(-.05,-.04),vec2(.1,.1)));\n            O = mix(O,vec4(0),box(d                     ,vec2(-.05,-.08),vec2(.02,.07)));\n            O = mix(O,vec4(.8,.6,0,0),box((d   -vec2(d.y,0))    ,vec2(-.11,.1),vec2(.1,.05)));\n        } \n        if(k==2) {\n            //mountain\n            O = mix(O,vec4(0.5,0.4,0.3,0)*br3,slice(6,(d/vec2(1,2)-vec2(0,.2))));\n            O = mix(O,vec4(0.5,0.4,0.3,0)*br3,slice(7,(d/vec2(1,2)-vec2(0,.2))));\n        }\n        if(k==3) {\n            //mine\n             O =mix(O,vec4(1.-br1),circle(d ,vec2(.0),.2));    \n        }\n        if(k==4) {\n            //lke\n             O =mix(O,vec4(0.1,0.3,0.6,0)*br3,circle(d ,vec2(.0),.25));    \n        }\n        // border:\n        O =mix(O,vec4(.3,.3,.3,0),1.-box(d ,vec2(.0),vec2(.49)));        \n     \n    } \n    //check\n    if(tx.z>0) O =mix(O,vec4(.8,.8,0,0),1.-box(d ,vec2(.0),vec2(.4)));      \n    if(tx.y>COLLAPSE-5) O =mix(O,vec4(1.,.0,0,0),1.-box(d ,vec2(.0),vec2(.4)));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define R iResolution\n#define T iTime\n#define MZ 3. \n#define Z (R.x<600.?20.: 40.) \n#define M (iMouse.x<=0.?R.xy/6.:iMouse.xy/Z*MZ)\n#define TX(p) floatBitsToInt(texelFetch(iChannel0, ivec2(p)%ivec2(R.xy),0))\n#define DIRS(d,d2) ivec2[4] (ivec2(-d,d2),ivec2(d2,d),ivec2(d,-d2),ivec2(-d2,-d)) \n#define NX(p)  ivec4[4] (TX(p+ivec2(-1,0)),TX(p+ivec2(0,1)),TX(p+ivec2(1,0)),TX(p+ivec2(0,-1))) \n#define B 16 //inizialition cell range \n#define COLLAPSE 25\n#define RETRY 50\n#define RANGE 2\n\n#define TH1 0.05\n#define TH2 0.01\n#define slice(n,d) (smoothstep(-TH1,0.,(d.x-d.y)*(n>=4?1.:-1.)) *smoothstep(-TH1,0.,(d.x+d.y)*(n>=2 && n<=5?1.:-1.))*smoothstep(-TH1,0.,d.x*(n>=3&&n<=6?1.:-1.))*smoothstep(-TH1,0.,-d.y*(n>=5||n==0?1.:-1.)) ) \n#define stripe(n,d) ((n%2)==1? smoothstep(-TH2,TH2,min(.05-abs(d.x), d.y*((n&2)==0?1.:-1.)) ):smoothstep(-TH2,TH2,min(.05-abs(d.y), d.x*((n&2)==2?1.:-1.)) ))       \n#define box(d,c,b) smoothstep(-TH2,TH2,-max(abs(d.x-c.x) - b.x,abs(d.y-c.y) - b.y) )\n#define circle(d,c,b) smoothstep(-TH2,TH2,-length(d-c) + b )\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//each tile is defined by 28bit mask: \n//  16 (terrain) + 8 (connections) + 4 (building) = 28 bits\n//terrain = 8 slices, value=0-3:    0=forest, 1=grass, 2=water,  3=farm,   \n//connection = 4 sides value=0-3:   0=none 1=road,  2=river*, 3=wall* \n//building value=0-15:  0=none, 1=house, 2=mountain, 3=mine, 4=source* ... \n\n//get rotated mask r=0..7\nint rotateMask(int m, int r0){\n    int mm =m;\n    int r=(r0%8);\n    \n    //uncomment next line to get Horizontal tiles (slow collapse)\n    //r=(r&6)+1;\n    \n    //uncomment next line to get hybrid pattern (not collapsing...)\n    //r=(r0%48);if(r<40) r=(r&6)+1; else r=r&8;\n    \n    int terr= m & ((1<<16)-1),\n        conn = (m>>16)& ((1<<8)-1),\n        bui = (m>>24)& ((1<<4)-1);\n    terr = (terr>>(2*r))+ ((terr&((1<<(2*r)) -1   ))<<(16-2*r));\n    conn = (conn>>(2*(r%4)))+ ((conn&((1<<(2*(r%4))) -1   ))<<(8-2*(r%4)));\n      \n    return terr+ (conn<<16) + (bui<<24);\n}\n\nfloat hash( in vec3 p ) {\n    p = fract( p * vec3( 19.191, 53.733, 73.761 ) );\n    p += dot( p, p + vec3( 41.557, 23.929, 37.983 ) );\n    return fract( ( p.x +  p.y ) * p.z );\n}\n//get Random mask \nint getMask(vec3 seed) {\n    \n    //needs tuning\n    bool river =false; \n    \n    //road\n    int rm=0;\n    int j=int(hash(seed*3.)*(40. + (river?40.:0.)));\n    if(j<8) rm=rotateMask(0x050000, j);\n    else if(j<16) rm=rotateMask(0x110000, j);\n    else if(j<20) rm=rotateMask(0x150000, j);\n    else if(j<28 &&river) rm=rotateMask(0x0A0000, j);\n    else if(j<36 &&river) rm=rotateMask(0x220000, j); \n    else if(j<48 &&river) rm=rotateMask(0x2A0000, j);\n    else if(j<56 &&river) rm=rotateMask(0x660000, j); //cross river\n    \n    //terrain  5=grass,A=sea, F=farm,0=forest\n    int i=int(hash(seed)*830.);\n    int k= int(hash(seed*2.)*100.);\n    if( i <40) return rotateMask(0x55AA, i)+(k<30 && river? rotateMask(0x20000, j) :0  ); //50% Grass - 50% sea\n    else if(i <80) return rotateMask(0x5AAA, i); //25% Grass - 75% sea\n    else if(i <120) return rotateMask(0x555A, i)+(k<10 && river? rotateMask(0x20000, j) :0  ); //75% Grass - 25% sea    \n    else if(i <200) return rotateMask(0x555F, i)+rm; //75% Grass - 25% farm\n    else if(i <240) return rotateMask(0x55FF, i)+rm; //50% Grass - 50% farm\n    else if(i <280) return rotateMask(0x5FFF, i)+rm; //25% Grass - 75% farm\n    else if(i <360) return rotateMask(0x5550, i)+rm; //75% Grass - 25% forest \n    else if(i <400) return rotateMask(0x5500, i)+rm; //50% Grass - 50% forest\n    else if(i <440) return rotateMask(0x5000, i)+rm; //25% Grass - 75% forest\n    \n    //else if(i <460) return rotateMask(0xAAA0, i); //75% sea - 25% forest \n    //else if(i <480) return rotateMask(0xAA00, i); //50% sea - 50% forest\n    //else if(i <500) return rotateMask(0xA000, i); //25% sea - 75% forest    \n    //else if(i <505) return rotateMask(0xA550, i); //25% sea - 50% grass  - 25% forest\n    //else if(i <510) return rotateMask(0x055A, i); //25% sea - 25% forest - 50% grass\n    //else if(i <515) return rotateMask(0xAA50, i); //50% sea - 25% grass  - 25% forest\n    //else if(i <520) return rotateMask(0xAA05, i); //50% sea - 25% forest - 25% grass\n\n    else if(i<600) return 0x0005555 + (k<5? 0x1000000 +rotateMask(0x10000, j) :rm  ); //grass\n    else if(i<650) return 0x000AAAA ; //sea\n    else if(i<750) return 0x0000000+  (k<10?0x2000000:k<20? 0x3000000 +rotateMask(0x10000, j) :k<30 && river ? 0x4000000 +rotateMask(0x20000, j): rm  ); //forest\n    else if(i<1000) return 0x000FFFF+ (k<5 && river? 0x4000000 +rotateMask(0x20000, j) :rm  );; //farm\n    \n}\n\n//check if mask m is compatible (connection ad terrain) with n mask n on side i\nbool check(int m, int n, int i){\n    int \n        bm1= (m & (1<<(4*i))*3)>>(4*i),\n        bm2= (m & (1<<(4*i+2))*3)>>(4*i+2),\n        c1= (m & (1<<(2*i+16))*3)>>(2*i+16),\n        j=(2+i)%4,\n        bn1= (n & (1<<(4*j+2))*3)>>(4*j+2),\n        bn2= (n & (1<<(4*j))*3)>>(4*j),\n        c2= (n & (1<<(2*j+16))*3)>>(2*j+16);\n    \n    return bm1==bn1 && bm2==bn2 && c1==c2;  \n}\n\nvoid mainImage( out vec4 O, in vec2 Q )\n{\n    ivec2 c = ivec2(Q);\n    ivec4 s=ivec4(0);\n    ivec4 tx= TX(c);\n    if(any(greaterThan(Q,R.xy/MZ))) discard;\n    //initialize some cells (one every BxB block) with random value\n    if(iFrame==0 || tx.a==0){\n       s=  ivec4(max(c.x% B,c.y %B)<1 ?getMask(vec3(Q,T)):-1 ,0,0,1);\n    } \n    else\n    {       \n        int m=tx.x, //current mask, -1= void \n            try=tx.y ; //current number of failed tentatives\n        ivec4[4] N = NX(c) ; //neighbours on 4 sides; order: Left Up Right Bottom\n        \n        int mm, //candidate mask\n            b; //number of non void neighbours\n        bool ch; //=true if candidate matches neghbours\n        for(int j=0;j<RETRY;j++){ //each frame, iterate candidate mask search\n            b=0; ch=true;\n            mm=  m<0?getMask(vec3(Q,T)+float(j)*3.111) :m; //set candidate mask if void\n            for(int i = 0;i<4 ;i++) { \n               if(N[i].x>=0) {\n                   b++;                   \n                   ch= ch && check(mm,N[i].x,i); //verify compatibility on current side\n                }\n                // if a neighbour as reached the try limit, invalidate current cell\n                if(N[i].x<0 &&m>=0 && N[i].y > COLLAPSE ) {ch=false;}\n                \n                // 2-nd and 3-rd order neightbour invalidatiom\n                if(RANGE==2 && (iFrame%30)==0 && TX(c+DIRS(2,0)[i]).x<0 &&m>=0 && TX(c+DIRS(2,0)[i]).y > COLLAPSE ) ch=false;\n                if(RANGE==2 && (iFrame%30)==0 && TX(c+DIRS(1,1)[i]).x<0 &&m>=0 && TX(c+DIRS(1,1)[i]).y > COLLAPSE ) ch=false;\n                if(RANGE==3 && (iFrame%30)==0 && TX(c+DIRS(2,1)[i]).x<0 &&m>=0 && TX(c+DIRS(2,2)[i]).y > COLLAPSE ) ch=false;\n                if(RANGE==3 && (iFrame%30)==0 && TX(c+DIRS(1,2)[i]).x<0 &&m>=0 && TX(c+DIRS(2,2)[i]).y > COLLAPSE ) ch=false;\n                if(RANGE==3 && (iFrame%30)==0 && TX(c+DIRS(3,0)[i]).x<0 &&m>=0 && TX(c+DIRS(2,2)[i]).y > COLLAPSE ) ch=false;\n\n            }\n            if( ch ) break; // skip if succesfull mask search\n            if( m>=0) break;// if cell is already initialized, skip after first iteration          \n        }\n       \n         \n        if(b>0 && ch) { m=mm; } //if compatible and connected, set candidate mask       \n        float db= ((!ch) &&m>=0 )?1.:0. ; //set debug bit if neghbour is invalid or not compatible   \n        if(b>0 &&!ch) {m=-1;} //invalidate if not compatible  \n        \n        //retry counter\n        if( b>2 && m<0) try=(try+1)&1023; \n        if(m>=0 && ch) try=0; \n        if(b==0) try=0;\n        \n        s=ivec4(m,try,db,1);\n    }\n\n\n    O = intBitsToFloat(s);\n} ","name":"Buffer A","description":"","type":"buffer"}]}