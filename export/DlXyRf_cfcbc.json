{"ver":"0.1","info":{"id":"DlXyRf","date":"1690989665","viewed":23,"name":"Euler Fractal","username":"Burinir","description":"Inspired by 3Blue1Browns Video about the Euler Fractal , written in http://editor.thebookofshaders.com/\nI later embedded the shader in a small SFML C++ program where you could move around the zeros of the complex polynomials. Here, they just move around.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Burinir\n// Title:  Euler Fractal\n\n\nvec2 mul(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 div(vec2 a, vec2 b){\n    float c2d2 = b.x*b.x+b.y*b.y;\n    return vec2((a.x*b.x + a.y*b.y)/c2d2, (a.y*b.x - a.x*b.y)/c2d2);\n    \n}\n\nvec2 f(vec2 x, vec2 z1, vec2 z2, vec2 z3, vec2 z4){\n    // (x-z1)(x-z2)(x-z3)(x-z4)\n    return mul(mul(x-z1, x-z2), mul(x-z3, x-z4));\n}\n\nvec2 df(vec2 x, vec2 z1, vec2 z2, vec2 z3, vec2 z4){\n    // (x - a) (x - b) (x - c) + (x - a) (x - b) (x - d) + (x - a) (x - c) (x - d) + (x - b) (x - c) (x - d)\n    return mul(mul(x-z1, x-z2), x-z3+x-z4)+ mul(x-z1+x-z2, mul(x-z3, x-z4));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    //Zeros\n    /*vec2 z1 = vec2(0.90,0.90);\n    vec2 z2 = vec2(-0.9,0.9);\n    vec2 z3 = vec2(0.9,-0.9);\n    vec2 z4 = vec2(-0.90,-0.90);*/\n    vec2 z1 = vec2(0.9*cos(0.9*iTime), 0.9 + 0.2 * sin(0.73*iTime));\n    vec2 z2 = vec2(-0.9 - 0.2 * sin(0.8*iTime), 0.9*cos(0.54*iTime));\n    vec2 z3 = vec2(0.9+ 0.4 * sin(0.7*iTime), -0.9*cos(0.59*iTime) );\n    vec2 z4 = vec2(-0.9*cos(0.6*iTime), -0.9+ 0.1*sin(0.43*iTime));\n    \n    \n    \n    const int iterations = 40;\n    \n    vec2 st = fragCoord.xy;\n\n    st.y = iResolution.y - st.y;\n    st /= iResolution.xy;\n    \n    if(iResolution.x > iResolution.y) st.x *= iResolution.x/iResolution.y;\n    else st.y *= iResolution.y/iResolution.x;\n    \n    //map point to a number on c plane\n    vec2 nr = (st- vec2(0.5, 0.5))*(3. +2.*cos(0.2*iTime));\n    \n    float distToZero = min(length(nr - z1), length(nr - z2));\n    distToZero = min(distToZero, length(nr - z3));\n    distToZero = min(distToZero, length(nr - z4));\n    \n    \n    for(int i = 0; i < iterations; i++){\n        nr = nr - div(f(nr, z1, z2, z3, z4), df(nr, z1, z2, z3, z4));\n    }\n        \n    float l1 = dot(nr-z1, nr-z1);\n    float l2 = dot(nr-z2, nr-z2);    \n    float l3 = dot(nr-z3, nr-z3);\n    float l4 = dot(nr-z4, nr-z4);\n    float lmin = min(min(l1,l2), min(l3,l4));\n    \n    vec4 c1 = vec4(vec3(0.214,0.590,0.324), 1.0);\n    vec4 c2 = vec4(vec3(0.489,0.836,0.990), 1.0);\n    vec4 c3 = vec4(vec3(0.001,0.047,1.000), 1.0);\n    vec4 c4 = vec4(vec3(0.101,0.748,0.905), 1.0);\n    \n    if(l1 <= lmin)      fragColor = c1;\n    else if(l2 <= lmin) fragColor = c2;\n    else if(l3 <= lmin) fragColor = c3;\n    else if(l4 <= lmin) fragColor = c4;\n    else fragColor = vec4(0,0,0,1);\n    \n   \n    //draw zeros as small red dots\n    \n    if(distToZero < 0.02) fragColor = vec4(1,0,0,1);\n    \n    \n\n    //else gl_FragColor = vec4(color,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}