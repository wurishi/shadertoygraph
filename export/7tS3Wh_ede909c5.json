{"ver":"0.1","info":{"id":"7tS3Wh","date":"1623795232","viewed":333,"name":"Simple Spherical Harmonics","username":"weasel","description":"Very simple viewer for spherical harmonics of any degree l, m. Use Mouse to move.\n\nIn the code I have some superpositions of the functions to explore for interested students.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","sphere","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Plot Spherical Harmonics (in the simplest way possible on GPU)\n\n/*** math heavy part for spherical harmonics ***/\n\n//#define PI 3.14159265359\n#define SQRT2PI 2.506628274631\n\n// factorial\nfloat fac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i--)\n        res *= float(i);\n    return res;\n}\n\n// double factorial\nfloat dfac(int n) {\n    float res = 1.0;\n    for (int i = n; i > 1; i-=2)\n        res *= float(i);\n    return res;\n}\n\n// fac(l-m)/fac(l+m) but more stable\nfloat fac2(int l, int m) {\n    int am = abs(m);\n    if (am > l)\n        return 0.0;\n    float res = 1.0;\n    for (int i = max(l-am+1,2); i <= l+am; i++)\n        res *= float(i);\n    if (m < 0)\n        return res;\n    return 1.0 / res;\n}\n\n// complex exponential\nvec2 cexp(vec2 c) {\n    return exp(c.x)*vec2(cos(c.y), sin(c.y));\n}\n\n// complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// complex conjugation\nvec2 conj(vec2 c) { return vec2(c.x, -c.y); }\n\n// complex/real magnitude squared\nfloat sqr(float x) { return x*x; }\nfloat sqr(vec2 x) { return dot(x,x); }\n\n// associated legendre polynomials\nfloat legendre_poly(float x, int l, int m) {\n    if (l < abs(m))\n        return 0.0;\n    if (l == 0)\n        return 1.0;\n    float mul = m >= 0 ? 1.0 : float((~m&1)*2-1)*fac2(l,m);\n    m = abs(m);\n    // recursive calculation of legendre polynomial\n    float lp1 = 0.0;\n    float lp2 = float((~m&1)*2-1)*dfac(2*m-1)*pow(1.0-x*x, float(m)/2.0);\n    for (int i = m+1; i <= l; i++) {\n        float lp = (x*float(2*i-1)*lp2 - float(i+m-1)*lp1)/float(i-m);\n        lp1 = lp2; lp2 = lp;\n    }\n    return lp2 / mul;\n}\n\n// spherical harmonics function\nvec2 sphere_harm(float theta, float phi, int l, int m) {\n    float abs_value = 1.0/SQRT2PI*sqrt(float(2*l+1)/2.0*fac2(l,m))\n                        *legendre_poly(cos(theta), l, m);\n    return cexp(vec2(0.0,float(m)*phi))*abs_value;\n}\n\n/*** now all the rendering ***/\n\nvec3 rotateX(vec3 pos, float angle) {\n    return vec3(pos.x, cmul(pos.yz, cexp(vec2(0.,-angle))));\n}\n\nvec3 rotate(vec3 pos, float phi, float theta) {\n    return rotateX(rotateX(pos, theta).yzx, phi).zxy;\n}\n\nvec3 colormap(float v) {\n    return vec3(1.0) - smoothstep(0., 1., sqrt(abs(v)))*(v > 0.0 ? vec3(1,1,0) : vec3(0,1,1));\n}\n\nvec3 sphere(vec2 uv, float phi, float theta, int l, int m) {\n    if (length(uv) < 1.0 && abs(m) <= l) {\n        vec3 pos = vec3(uv, sqrt(1.0-dot(uv,uv)));\n        float z = pos.z;\n        \n        // rotate sphere\n        pos = rotate(pos, phi, theta);\n        \n        // get spherical coordinates\n        float sin_theta = length(pos.xz);\n        float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.z) : 0.0;\n        float ball_theta = atan(sin_theta, pos.y);\n        \n        // evaluate spherical harmonics\n        float off = m == 0 ? 0.0 : iTime/float(m);\n        vec2 sph_harm = sphere_harm(ball_theta, ball_phi + off, l, m);\n        \n        // normalization for visual purposes\n        sph_harm *= SQRT2PI/2.0;\n        \n        // return color mapped real part of the function (.x)\n        return colormap(sph_harm.x) * sqrt(sqrt(z));\n    }\n    return vec3(0.0);\n}\n\nvec3 sphere_superposition(vec2 uv, float phi, float theta) {\n    if (length(uv) < 1.0) {\n        vec3 pos = vec3(uv, sqrt(1.0-dot(uv,uv)));\n        float z = pos.z;\n        \n        // rotate sphere\n        pos = rotate(pos, phi, theta);\n        \n        // get spherical coordinates\n        float sin_theta = length(pos.xz);\n        float ball_phi = sin_theta > 0.0 ? atan(pos.x, pos.z) : 0.0;\n        float ball_theta = atan(sin_theta, pos.y);\n        \n        // evaluate spherical harmonics\n        vec2 tmul = cexp(vec2(0.0,iTime));\n        \n        vec2 Y00 = sphere_harm(ball_theta, ball_phi, 0, 0);\n        vec2 Y10 = sphere_harm(ball_theta, ball_phi, 1, 0);\n        vec2 Y11 = sphere_harm(ball_theta, ball_phi, 1, 1);\n        vec2 Y1n1 = sphere_harm(ball_theta, ball_phi, 1, -1);\n        \n        vec2 s = Y00; // s orbit\n        vec2 px = 1.0/sqrt(2.0)*(Y11+conj(Y11)); // px orbit\n        vec2 py = -cmul(vec2(0,1),1.0/sqrt(2.0)*(Y11-conj(Y11))); // py orbit\n        vec2 pz = Y10; // pz orbit\n        \n        vec2 sph_harm = cmul(tmul, 0.25*(s + px + py + pz)); // sp3 hybrid\n        //vec2 sph_harm = cmul(tmul, (Y11 + Y1n1) / sqrt(2.0));\n        //vec2 sph_harm = vec2(sqr(Y10) + sqr(Y11) + sqr(Y1n1)) / 3.0 - sqr(Y00); // zero\n        \n        // normalization for visual purposes\n        sph_harm *= SQRT2PI/2.0;\n        \n        // return color mapped real part of the function (.x)\n        return colormap(sph_harm.x) * sqrt(sqrt(z));\n    }\n    return vec3(0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // This value selects the visible region\n    float zoom = 5.0;\n    vec2 move = iMouse.z > 0.0 ? vec2(2.0, 3.0)*(m-vec2(0.8, 0.5)) : vec2(0.0);\n    vec2 uv2 = (uv - move - vec2(0.0, 0.5))*zoom-vec2(0.5,0.0);\n    uv = uv * 2.0 - 1.0;\n    \n    m = m * 2.0 - 1.0;\n    \n\tm.x *= iResolution.x/iResolution.y;\n    uv.x *= iResolution.x/iResolution.y;\n    uv2.x *= iResolution.x/iResolution.y;\n    \n    // draw grid of all spherical harmonics\n    ivec2 cell = ivec2(floor(uv2 + 0.5));\n    vec2 cell_local = fract(uv2 + 0.5) * 2.0 - 1.0;\n    vec3 col = sphere(cell_local, m.x, -m.y*0.6, cell.x, cell.y);\n    \n    // superposition of spherical harmonics for atomic orbits\n    //vec3 col = sphere_superposition(uv, m.x, -m.y);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}