{"ver":"0.1","info":{"id":"WtjBDc","date":"1600031945","viewed":57,"name":"Differentiable Rendering","username":"rrika","description":"work-in-progress implementation of\nReparameterizing Discontinuous Integrands for Differentiable Rendering\nhttps://www.youtube.com/watch?v=9XyK5rhHrPk\n\n<- finite differences | this approach ->","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["differentiable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// work-in-progress implementation of\n//\n// Reparameterizing Discontinuous Integrands for Differentiable Rendering\n// https://www.youtube.com/watch?v=9XyK5rhHrPk\n//\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0;\n    return -b - sqrt( h );\n}\n\n\nvec4 sphIntersect_( vec3 ro, vec3 rd, vec4 sph, vec3 ro_, vec3 rd_, vec4 sph_ )\n{\n    vec3 oc  = ro  - sph.xyz;\n    vec3 oc_ = ro_ - sph_.xyz;\n    float b  = dot( oc, rd  );\n    float b_ = dot( oc, rd_ ) + dot( oc_, rd );\n    \n    float c  = dot( oc, oc ) - sph.w*sph.w;\n    float c_ = 2.0*dot( oc, oc_ ) - 2.0*sph.w*sph_.w;\n    \n    float h  = b*b - c;\n    float h_ = 2.0*b*b_ - c_;\n\n    if( h<0.0 ) return vec4(-1.0, -1.0, 0.0, 0.0);\n    \n    float t  = -b -sqrt(h);\n    float t_ = -b_-h_/(2.0*sqrt(h));\n    return vec4(t, t_,\n\t\t// debug:\n\t\t-1.0*t,\n\t\t-1.0*t_\n\t);\n}\n\n\nstruct Hit {\n    vec3 point;\n    vec3 normal;\n    float time;\n    vec3 debug;\n    vec3 debug_;\n};\n\nHit raySphereIntersect(vec3 r0, vec3 rd, vec4 sph) {\n    vec4 data = sphIntersect_(r0, rd, sph, vec3(0, 0, 0), vec3(0, 0, 0), vec4(0, 0, 0, 0));\n    float hittime = data.x;\n    vec3 debug = data.zzz;\n    vec3 debug_ = data.www;\n    vec3 hitpoint = r0 + rd * hittime;\n    vec3 normal = normalize(hitpoint - sph.xyz);\n    return Hit(hitpoint, normal, hittime, debug, debug_);\n}\n\nvec4 derivativeQuaternion(vec3 p, vec3 q) {\n    // quaternion rotating p around origin to p+q*x\n\n    if (q == vec3(0.0, 0.0, 0.0))\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    float scale = length(p);\n    vec3 n = normalize(cross(p, q));\n    vec3 q90 = normalize(cross(n, q));\n    float a = dot(q90, p) / scale;\n    float b = length(q) / scale;\n\n    float angle = b/(1.0+a*a);\n    \n    return vec4(n*sin(angle/2.0), cos(angle/2.0));\n}\n\nvec3 rotatePoint(vec3 v, vec4 q)\n{\n    return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\nstruct SceneEval {\n    float color;\n    float color_;\n};\n\nSceneEval scene(vec3 r0, vec3 rd, vec4 sph, vec3 r0_, vec3 rd_, vec4 sph_, vec2 pixelCenter, float pixelSize) {\n    \n    float skyfreq = 15.0;\n\n    vec4 data = sphIntersect_(r0, rd, sph, r0_, rd_, sph_);\n    float t = data.x;\n    float t_ = data.y;\n    vec3 hitpoint = r0 + rd * t;\n    vec3 hitpoint_ = rd * t_ + rd_ * t;\n    vec3 normal = normalize(hitpoint-sph.xyz);\n\n    vec3  op  = hitpoint - sph.xyz;\n    vec3  op_ = hitpoint_;\n    float ov  = dot(op, op);\n    float ov_ = 2.0*dot(op, op_);\n    float ol = sqrt(ov);\n    float ol_ = ov_ / (2.0*sqrt(ov));\n    // normal = op / ol\n    vec3 normal_ = (ol*op_-op*ol_) / (ol*ol); // should always be zero\n\n    vec3 up = normalize(vec3(0, 1, -0.8));\n    vec3 right = vec3(1, 0, 0);\n    vec3 back = cross(up, right);\n    vec3 p  = hitpoint - sph.xyz;\n    vec3 p_ = hitpoint_;\n    vec2 skyspace  = skyfreq * vec2(dot(p,  right), dot(p,  back));\n    vec2 skyspace_ = skyfreq * vec2(dot(p_, right), dot(p_, back));\n\n    float diffuse  = max(dot(normal, up), 0.0);\n    float shadowX = cos(skyspace.x);\n    float shadowY = cos(skyspace.y);\n    float shadow  = shadowX * shadowY * 0.5 + 0.5;\n\n    float diffuse_ = diffuse != 0.0 ? dot(normal_, up) : 0.0; // whoops, discontinuity\n    float shadowX_ = skyspace_.x * -sin(skyspace.x);\n    float shadowY_ = skyspace_.y * -sin(skyspace.y);\n    float shadow_ = (shadowX*shadowY_ + shadowY*shadowX_) * 0.5;\n\n    float sky  = diffuse * shadow;\n    float sky_ = diffuse * shadow_ + shadow * diffuse_;\n\n    // now consider the pixel footprint\n    vec2 projSample  = hitpoint.xy / hitpoint.z;\n    vec2 projSample_ = (hitpoint.z * hitpoint_.xy - hitpoint.xy * hitpoint_.z) / (hitpoint.z * hitpoint.z);\n\n    // useless right now since all the samples are taken at the center of the gaussian\n    // where the derivative is zero\n    vec2 rel  = (projSample - pixelCenter) * pixelSize;\n    vec2 rel_ = projSample_ * pixelSize;\n\n    vec2 rel2  = -rel*rel;\n    vec2 rel2_ = -2.0*rel*rel_;\n    \n    vec2 tmp  = exp(rel2);\n    vec2 tmp_ = tmp * rel2_;\n\n    float weight  = tmp.x * tmp.y;\n    float weight_ = tmp.x * tmp_.y + tmp.y * tmp_.x;\n    \n    float weightedPixel  = sky * weight;\n    float weightedPixel_ = sky * weight_ + sky_ * weight;\n    \n    return SceneEval(weightedPixel, weightedPixel_);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centered = fragCoord - iResolution.xy/2.0;\n    vec2 rdreal = centered / iResolution.xx;\n    float pixelSize = iResolution.x;\n    \n    float wobble = fragCoord.x+fragCoord.y;\n    fragCoord += vec2(sin(wobble), cos(wobble)) * 0.0;\n    \n    centered = fragCoord - iResolution.xy/2.0;\n    vec2 pos = centered / iResolution.xx;\n\n    float loop = 3.0;\n    float t = fract(iTime/loop)*loop;\n    \n    vec3 r0 = vec3(0.0, 0.0, 0.0);\n    vec3 r0_ = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(pos, 1.0));\n    vec4 sph = vec4(0.0, 0.0, 5.0, 0.97); // xyz + radius\n    vec4 sph_ = vec4(0.0, 0.0, 0.0, 0.05*t);\n\n    \n    Hit intersection = raySphereIntersect(\n        r0, rd, sph);\n\n    Hit intersectionDelta = raySphereIntersect(\n        r0, rd, sph+sph_);\n\n    Hit intersectionNegDelta = raySphereIntersect(\n        r0, rd, sph-sph_);\n\n    float sgrid = 10.0;\n    vec2 vgrid = sgrid * pos;\n    vec2 mgrid = mod(vgrid, 1.0);\n\n    vec2 mg = (mgrid-0.5);\n    float gauss = exp(-mg.x*mg.x) * exp(-mg.y*mg.y);\n\n    if (false)\n        fragColor = vec4(gauss, gauss, gauss, 1.0);\n    else\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    if (false) {\n        // inner sphere: normals\n        if (intersection.time != -1.0)\n            fragColor.xy = intersection.normal.xy * 0.5 + 0.5;\n\n    } else if (false) {\n        // inner sphere: naive skylight\n        if (intersection.time != -1.0)\n        {\n            vec3 up = normalize(vec3(0, 1, -0.8));\n            vec3 right = vec3(1, 0, 0);\n            vec3 back = cross(up, right);\n            vec3 p = intersection.point - sph.xyz;\n            vec2 skyspace = 15.0 * vec2(dot(p, right), dot(p, back));\n            float sky =\n                max(dot(intersection.normal, up), 0.0) *\n                (cos(skyspace.x)*cos(skyspace.y)*0.5+0.5)\n            ;\n            fragColor = vec4(sky, sky, sky, 1.0);\n        }\n    }\n\n    // blue halo\n\tif (intersection.time == -1.0 && intersectionDelta.time != -1.0)\n            fragColor.xyz = vec3(0.5, 0.5, 1.0);\n    \n\n    vec2 samplePosition[4];\n    samplePosition[0] = vec2(0.2, 0.4);\n    samplePosition[1] = vec2(0.4, 0.8);\n    samplePosition[2] = vec2(0.8, 0.6);\n    samplePosition[3] = vec2(0.6, 0.2);\n\n\n    vec4 avgquat = vec4(0.0, 0.0, 0.0, 1.0);\n    int avgweight = 0;\n    \n    vec2 igrid = floor(vgrid);\n    \n    for (int i=0; i<4; i++) {\n        vec2 sp = samplePosition[i];\n        vec2 p = (igrid+sp) / sgrid;\n        vec3 rdx = normalize(vec3(p, 1.0));\n\n        float hittime = sphIntersect(r0, rdx, sph);\n        if (hittime != -1.0)\n        {\n            vec3 hitpoint = r0 + rdx * hittime;\n            vec3 normal = normalize(hitpoint - sph.xyz);\n            vec4 quat = derivativeQuaternion(hitpoint, normal * sph_.w);\n            avgquat += quat;\n            avgweight += 1;\n        }\n    }\n    \n    if (avgweight >= 2)\n    {\n        avgquat /= float(avgweight);\n        avgquat = normalize(avgquat);\n    }\n    else\n    {\n        avgquat = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    float skyfreq = 15.0;\n    \n    if (true && intersection.time != -1.0)\n    {\n        float t = sphIntersect(r0, rd, sph);\n        vec3 hitpoint = r0 + rd * t;\n        vec3 normal = normalize(hitpoint - sph.xyz);\n        vec4 quat = derivativeQuaternion(hitpoint, normal * sph_.w);\n        vec3 rd2 = rotatePoint(rd,\n\t\t\tquat\n\t\t\t//avgquat\n\t\t);\n        vec3 rd_ = vec3(0, 0, 0); // don't move sample\n        //rd_ = rd2-rd;            // move sample by rotating around camera\n\t\t//rd_ = sph_.w * vec3((hitpoint.z * normal.xy - hitpoint.xy * normal.z) / (hitpoint.z * hitpoint.z), 0);\n        \t\t\t\t\t     // move sample by shifting in camera plane\n        \n\n\t\tSceneEval se = scene(r0, rd, sph, r0_, rd_, sph_, rdreal, pixelSize);\n        float sky = se.color;\n        float sky_ = se.color_;\n\n\n        // right:  derivative\n        // left:   render\n        // middle: finite difference\n        \n        float amplify = 4.0;\n        //float amplify = sph_.w == 0.0 ? 1.0 : 0.3/sph_.w;\n        \n        if (pos.x > 0.05) {\n            //fragColor.xyz = amplify * hitpoint_ * vec3(-1.0, 1.0, 1.0);\n            fragColor.xyz = amplify * vec3(sky_, 0.0, -sky_);\n            //fragColor.xyz = amplify * vec3(-t_, -t_, -t_);\n            //fragColor.xyz = amplify * data.www;\n        } else if (pos.x < -0.05) {\n            // finite difference\n            SceneEval seNeg = scene(r0, rd, sph-sph_, vec3(0, 0, 0), vec3(0, 0, 0), vec4(0, 0, 0, 0), rdreal, pixelSize);\n            SceneEval sePos = scene(r0, rd, sph+sph_, vec3(0, 0, 0), vec3(0, 0, 0), vec4(0, 0, 0, 0), rdreal, pixelSize);\n\n            float sky1 = seNeg.color;\n            float sky2 = sePos.color;\n            \n            float delta = (sky2 - sky1)*0.5; // f(x+d) - f(x-d)\n            fragColor.xyz = amplify * vec3(delta, 0.0, -delta);\n            //fragColor.xyz = vec3(sky2, sky2, sky2);\n            //fragColor.xyz = amplify*(intersectionDelta.point - intersectionNegDelta.point);\n            //fragColor.xyz = amplify*(intersectionDelta.debug - intersectionNegDelta.debug)*0.5;\n            //fragColor.xyz = amplify*(pPos-pNeg)*0.5;\n            \n        } else {\n        \tfragColor.xyz = vec3(sky, sky, sky);\n        }\n    }\n    \n    if (false)\n    {\n        for (int i=0; i<4; i++) {\n            vec2 sp = samplePosition[i];\n            vec2 p = (igrid+sp) / sgrid;\n            vec3 rdx = normalize(vec3(p, 1.0));\n\n            float hittime = sphIntersect(r0, rdx, sph);\n            vec3 hitpoint = r0 + rdx * hittime;\n            vec3 normal = normalize(hitpoint - sph.xyz);\n            vec4 quat = derivativeQuaternion(hitpoint, normal * sph_.w);\n\n            if (true)\n                quat = avgquat;\n\n            if (hittime != -1.0)\n            {\n                vec3 newp;\n                if (false)\n                    newp = hitpoint + normal*sph_.w; // use world space derivative of position\n                else\n                    newp = rotatePoint(hitpoint, quat); // use camera space derivative of angle\n                p = (newp.xy / newp.z);\n            }\n\n            vec2 r = pos-p;\n\n            vec2 rs = p*sgrid-igrid-0.5;\n            float gauss = exp(-rs.x*rs.x) * exp(-rs.y*rs.y);\n            gauss *= gauss; // exaggerate effect\n\n            if (sqrt(dot(r, r))<gauss*0.04/sgrid)\n            {\n                if (hittime == -1.0)\n                    fragColor = vec4(0.0, 1.0, 0.0, 1.0);\n                else\n                {\n                    fragColor = vec4(0.2, 0.9, 1.0, 1.0);\n                }\n            }\n        }\n        if (iResolution.x / sgrid >= 10.0) // don't bother if grid is too small\n        {\n            float w = 0.007;\n            if (mgrid.x < w || mgrid.x > 1.0-w)\n                fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            if (mgrid.y < w || mgrid.y > 1.0-w)\n                fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n        }\n\n    }\n}\n","name":"Image","description":"","type":"image"}]}