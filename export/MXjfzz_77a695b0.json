{"ver":"0.1","info":{"id":"MXjfzz","date":"1729161175","viewed":240,"name":"clickable star in fractalic","username":"nayk","description":"moving with mouse click","likes":11,"published":3,"flags":0,"usePreview":0,"tags":["distortion","star","move"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R(p,a,r)mix(a*dot(p,a),p,cos(r))+sin(r)*cross(p,a)\n#define H(h)(cos((h)*6.3+vec3(0,23,21))*.5+.5)\n#define n1Q(p) p *= 2.*ri(round(atan(p.x, p.y) * 4.) / 4.)\n#define ri(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\nfloat dotSize = .35;\nfloat dotSpacing = .026;\nvec4 dotColor = vec4(.2, .12, 1., 1.);\nfloat dotSoftness = 0.02;\nfloat effectStrength = -.45;\nfloat effectRadius = 1.;\nfloat waveFrequency = 5.0;\nfloat waveAmplitude = 1.69;\nfloat radialSpeed = 2.0;\nvec4 backgroundColor = vec4(1., 1., 1., 1.);\n\nfloat dot_grid(vec2 uv, float size, float spacing, float softness) {\n    vec2 grid = fract(uv / spacing + 0.5) - 0.5;\n    float dist = length(grid);\n    return 1.0 - smoothstep(size * 0.5 - softness, size * 0.5 + softness, dist);\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvec2 pinch_bulge(vec2 uv, vec2 center, float strength, float radius) {\n    vec2 delta = uv - center;\n    float dist = length(delta);\n    float factor = 1.0 - smoothstep(0.0, radius, dist);\n    return uv + delta * factor * strength;\n}\n\nfloat radial_pulse(vec2 uv, vec2 center, float time, float freq, float speed) {\n    float dist = length(uv - center);\n    return sin(dist * freq - time * speed) * 0.5 + 0.5;\n}\nvoid mainImage(out vec4 O, vec2 C)\n{\n    O=vec4(0);\n    vec3 n1,q,r=iResolution,\n    d=normalize(vec3((C*2.-r.xy)/r.y,1));\n      vec2 uv = (C - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 cPos = -1.0 + 2.0 * C.xy / iResolution.xy;\n     vec2 uv2 = ( C- .5*iResolution.xy ) / iResolution.y;\n    // distance of current pixel from center\n\tfloat cLength = length(cPos);\n\n\t\n\t\n    // Normalize mouse coordinates\n    vec2 mouseUV = (iMouse.xy - 0.5 * iResolution.xy) / min(iResolution.x, iResolution.y);\n    if (iMouse.x == 0. && iMouse.y == 0.) {\n        mouseUV = vec2(0.0, 0.0);\n    }\n    uv2-=mouseUV;\nuv*=4.;\nmouseUV+=(cPos/cLength)*cos(cLength*12.0-iTime*4.0) * 0.03;\n    // Apply pinch/bulge effect\n    vec2 distortedUV = pinch_bulge(uv, mouseUV*4., effectStrength, effectRadius);\n    distortedUV*=2.;\n    // Calculate radial pulse from mouse position\n    float pulse = radial_pulse(uv, mouseUV, iTime, waveFrequency, radialSpeed);\n    \n    // Apply pulsing effect to dot size\n    float currentDotSize = dotSize * (1.0 + pulse * waveAmplitude);\n    \n    // Create dot grid\n    float dot = dot_grid(distortedUV, currentDotSize, dotSpacing, dotSoftness);\n    \n    // Add a color variation based on pulse and distance from mouse\n    float distFromMouse = length(uv - mouseUV);\n    vec3 colorVariation = vec3(\n        sin(distFromMouse * 3.14159 * 2.0 + pulse * 2.0) * 0.1 + 0.9,\n        sin(distFromMouse * 3.14159 * 2.0 + pulse * 2.2) * 0.1 + 0.9,\n        sin(distFromMouse * 3.14159 * 2.0 + pulse * 2.4) * 0.1 + 0.9\n    );\n    \n    // Mix dot color with background color and apply color variation\n    vec3 color = mix(backgroundColor.rgb, dotColor.rgb * colorVariation, dot);\n    \n    for(float i=0.,a,s,e,g=0.;\n        ++i<70.;\n        O.xyz+=mix(vec3(1),H(g*.1),.8)*2./e/8e3\n    )\n    {\n        n1=g*d;\n        \nn1.z+=iTime*2.1;\nn1.y+=iTime*2.1;\n        a=50.;\n        n1.y+=iTime*2.1;\n        n1=mod(n1-a,a*2.)-a;\n        s=1.5;\n\n       n1.xz*=mat2(-.1,0,0,-.1);\n       \n        n1.xy+=distortedUV;\n         n1Q(n1.xy);\n                \n        for(int i=0;i++<8;){\n            \n            n1=.3-abs(n1);\n            n1.x<n1.z?n1=n1.zyx:n1;\n            n1.z<n1.y?n1=n1.xzy:n1;\n            s*=e=1.7+sin(iTime*.003)*.1;\n            n1=abs(n1)*e-\n                vec3(\n                    5.*3.,\n                    120,\n                    8.*5.\n                 );\n         }\n         g+=e=length(n1.yzzz)/s;\n    }\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n   O*= vec4(happy_star(uv2, anim) * vec3(0.35,0.2,0.75), 1.0);\n}","name":"Image","description":"","type":"image"}]}