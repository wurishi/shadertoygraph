{"ver":"0.1","info":{"id":"sdcfWf","date":"1657316932","viewed":138,"name":"RGB VS CIE-L*AB GRADIENT","username":"loni852","description":"Comparison between 2 diferent types of gradients. Mouse integrated for color swaping\nTOP LAB BOTTOM RGB","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["color","gradient","colorspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//TOP IS CIEL*AB BOTTOM IS RGB\n//Functions taken from https://www.easyrgb.com/en/math.php\nvec3 XYZTORGB(vec3 xyz){\n    //X, Y and Z input refer to a D65/2° standard illuminant.\n    //sR, sG and sB (standard RGB) output range = 0 ÷ 255\n\n    float var_X = xyz.x / 100.;\n    float var_Y = xyz.y / 100.;\n    float var_Z = xyz.z / 100.;\n\n    float var_R = var_X *  3.2406 + var_Y * -1.5372 + var_Z * -0.4986;\n    float var_G = var_X * -0.9689 + var_Y *  1.8758 + var_Z *  0.0415;\n    float var_B = var_X *  0.0557 + var_Y * -0.2040 + var_Z *  1.0570;\n\n    if ( var_R > 0.0031308 ) var_R = 1.055 * ( pow(var_R , ( 1. / 2.4 )) ) - 0.055;\n    else                     var_R = 12.92 * var_R;\n    if ( var_G > 0.0031308 ) var_G = 1.055 * ( pow(var_G , ( 1. / 2.4 )) ) - 0.055;\n    else                     var_G = 12.92 * var_G;\n    if ( var_B > 0.0031308 ) var_B = 1.055 * ( pow(var_B , ( 1. / 2.4 )) ) - 0.055;\n    else                     var_B = 12.92 * var_B;\n\n    vec3 rgb;\n    rgb.r = var_R;\n    rgb.g = var_G;\n    rgb.b = var_B;\n    \n    return rgb;\n    }\n    \nvec3 RGBTOXYZ(vec3 rgb){\n    //sR, sG and sB (Standard RGB) input range = 0 to 1\n    //X, Y and Z output refer to a D65/2° standard illuminant.\n\n    float var_R = (rgb.r);\n    float var_G = (rgb.g);\n    float var_B = (rgb.b);\n\n    if ( var_R > 0.04045 ) var_R = pow(( ( var_R + 0.055 ) / 1.055 ) , 2.4);\n    else                   var_R = var_R / 12.92;\n    if ( var_G > 0.04045 ) var_G = pow(( ( var_G + 0.055 ) / 1.055 ) , 2.4);\n    else                   var_G = var_G / 12.92;\n    if ( var_B > 0.04045 ) var_B = pow(( ( var_B + 0.055 ) / 1.055 ) , 2.4);\n    else                   var_B = var_B / 12.92;\n\n    var_R = var_R * 100.;\n    var_G = var_G * 100.;\n    var_B = var_B * 100.;\n\n    vec3 xyz;\n    \n    xyz.x = var_R * 0.4124 + var_G * 0.3576 + var_B * 0.1805;\n    xyz.y = var_R * 0.2126 + var_G * 0.7152 + var_B * 0.0722;\n    xyz.z = var_R * 0.0193 + var_G * 0.1192 + var_B * 0.9505;\n    \n    return xyz;\n}\n\nvec3 XYZTOLAB(vec3 xyz){\n    //Reference-X, Y and Z refer to specific illuminants and observers.\n\n    float var_X = xyz.x / 109.850;\n    float var_Y = xyz.y / 100.000;\n    float var_Z = xyz.z / 35.585;\n\n    if ( var_X > 0.008856 ) var_X = pow(var_X , ( 1./3. ));\n    else                    var_X = ( 7.787 * var_X ) + ( 16. / 116. );\n    if ( var_Y > 0.008856 ) var_Y = pow(var_Y , ( 1./3. ));\n    else                    var_Y = ( 7.787 * var_Y ) + ( 16. / 116. );\n    if ( var_Z > 0.008856 ) var_Z = pow(var_Z , ( 1./3. ));\n    else                    var_Z = ( 7.787 * var_Z ) + ( 16. / 116. );\n\n    vec3 LAB;\n\n    LAB.x = ( 116. * var_Y ) - 16.;\n    LAB.y = 500. * ( var_X - var_Y );\n    LAB.z = 200. * ( var_Y - var_Z );\n    \n    return LAB;\n}\n\nvec3 LABTOXYZ(vec3 LAB){\n    //Reference-X, Y and Z refer to specific illuminants and observers.\n\n    float var_Y = ( LAB.x + 16. ) / 116.;\n    float var_X = LAB.y / 500. + var_Y;\n    float var_Z = var_Y - LAB.z / 200.;\n\n    if ( pow(var_Y,3.)  > 0.008856 ) var_Y = pow(var_Y,3.);\n    else                       var_Y = ( var_Y - 16. / 116. ) / 7.787;\n    if ( pow(var_X,3.)  > 0.008856 ) var_X = pow(var_X,3.);\n    else                       var_X = ( var_X - 16. / 116. ) / 7.787;\n    if ( pow(var_Z,3.)  > 0.008856 ) var_Z = pow(var_Z,3.);\n    else                       var_Z = ( var_Z - 16. / 116. ) / 7.787;\n\n    vec3 xyz;\n\n    xyz.x = var_X * 109.850\t;\n    xyz.y = var_Y * 100.000;\n    xyz.z = var_Z * 35.585;\n    \n    return xyz;\n}\n\n\nfloat Hue_2_RGB(float v1,float v2,float vH )             //Function Hue_2_RGB\n{\n       if ( vH < 0. ) vH += 1.;\n       if( vH > 1. ) vH -= 1.;\n       if ( ( 6. * vH ) < 1. ) return ( v1 + ( v2 - v1 ) * 6. * vH );\n       if ( ( 2. * vH ) < 1. ) return ( v2 );\n       if ( ( 3. * vH ) < 2. ) return ( v1 + ( v2 - v1 ) * ( ( 2. / 3. ) - vH ) * 6. );\n       return ( v1 );\n}\n\nvec3 HSLTORGB(vec3 HSL){\n   //H, S and L input range = 0 ÷ 1.0\n    //R, G and B output range = 0 ÷ 255\n\nfloat L = HSL.z;\nfloat S = HSL.y;\nfloat H = HSL.x;\nvec3 rgb;\n    if ( S == 0. )\n    {\n\n       float R = L * 255.;\n       float G = L * 255.;\n       float B = L * 255.;\n    }\n    else\n    {\n    float var_2;\n    float var_1;\n       if ( L < 0.5 )  var_2 = L * ( 1. + S );\n       else           var_2 = ( L + S ) - ( S * L );\n\n       var_1 = 2. * L - var_2;\n\n       rgb.r = Hue_2_RGB( var_1, var_2, H + ( 1. / 3. ) );\n       rgb.g =  Hue_2_RGB( var_1, var_2, H );\n       rgb.b =  Hue_2_RGB( var_1, var_2, H - ( 1. / 3. ) );\n    }\n    \n    return rgb;\n\n\n}\n\n\nfloat Remap ( float value, float from1, float to1, float from2, float to2) {\n    return (value - from1) / (to1 - from1) * (to2 - from2) + from2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mousepos = iMouse.xy / iResolution.xy;\n\n\n    //Color pallete\n    vec3 col1 = vec3(fract(mousepos.x + fract(iTime*0.1)),1.,0.5);\n    vec3 col2 = vec3(fract(fract(mousepos.y+0.5) + fract(iTime*0.1)),1.,0.5);\n    \n     col1 = HSLTORGB(col1);\n     col2 = HSLTORGB(col2);\n    \n    //Mix with rgb\n    vec3 finalcolorRGB = pow(mix(pow(col1,vec3(2.2)), pow(col2,vec3(2.2)),uv.x),vec3(1.0/2.2));\n    \n    \n    //Mix with L*AB\n    col1 = RGBTOXYZ(col1);\n    col2 = RGBTOXYZ(col2);\n    col1 = XYZTOLAB(col1);\n    col2 = XYZTOLAB(col2);\n    vec3 finalcolor = mix(col1,col2,uv.x);\n    finalcolor = LABTOXYZ(finalcolor);\n    finalcolor = XYZTORGB(finalcolor);\n    \n    \n    vec3 showcolor = finalcolorRGB * step(uv.y,0.49) + finalcolor * step(0.51,uv.y);\n    \n    //Middle diffuse mix between top and bottom\n    showcolor += (0.*mix(finalcolorRGB,finalcolor,Remap(uv.y,0.49,0.51,0.,1.))) * step(0.49,uv.y) * step(uv.y,0.51);\n    \n    showcolor *= step(0.01,uv.x) ;\n    showcolor *= 1.0-step(0.99,uv.x);\n    showcolor *= step(0.02,uv.y) ;\n    showcolor *= 1.0-step(0.98,uv.y);\n    \n\n    // Output to screen\n    fragColor = vec4(showcolor,1.0);\n}","name":"Image","description":"","type":"image"}]}