{"ver":"0.1","info":{"id":"WsSGDy","date":"1550374778","viewed":143,"name":"Environment Setpiece","username":"clemendeng","description":"Assignment","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Modeled from\n//https://static.altchar.com/live/media/images/950x633_ct/12584_Gris_Main_14fc95a9fef14e6387b2652bf4aea33d.jpg\n//Resources\n//https://www.shadertoy.com/view/ldfGWH\n//https://iquilezles.org/articles/distfunctions\n//https://iquilezles.org/articles/distfunctions2d\n//https://iquilezles.org/articles/rmshadows\n//https://www.shadertoy.com/view/MdXSWn\n\nfloat getScale(int id) {\n  \t//insert ids here if using scale\n  \tif(id == 0) {\n    \treturn 1.f;\n  \t}\n  \treturn 1.f;\n}\n\nmat4 getTransform(int id) {\n  \tif(id == 0) {\n        return translate(0.f, -4.f, 0.f);\n    } else if(id == 1) {\n        return translate(0.f, 0.5, 0.f);\n    } else if(id == 2) {\n        return translate(0.f, -1.1, 0.f);\n    }\n}\n\nfloat getSDF(int id, vec3 p) {\n  \tif(id == 0) {\n        //base structure\n        float leg1 = sdCappedCylinder(translatep(p, .9, 2.0, 0.f), vec2(0.2, 0.5));\n        float leg2 = sdCappedCylinder(translatep(p, -.9, 2.0, 0.f), vec2(0.2, 0.5));\n        float base = sdCappedCylinder(translatep(p, 0.f, 1.0, 0.f), vec2(1.1, 0.5));\n        float body = sdTorus(translatep(p, 0.f, 0.1, 0.f), vec2(.9, .6));\n        float cap = sdSphere(translatep(p, 0.f, -.42, 0.f), 1.1);\n        float top = sdCappedCylinder(translatep(p, 0.f, -1.05, 0.f), vec2(.6, .5));\n        cap = opSmoothUnion(cap, top, 0.2);\n        float legs = min(leg1, leg2);\n        float bottom = min(legs, base);\n        body = min(bottom, body);\n        return min(body, cap);\n    } else if(id == 1) {\n        //top\n        float leg1 = sdCappedCylinder(translatep(p, .38, 0.f, 0.f), vec2(0.17, 0.25));\n        float leg2 = sdCappedCylinder(translatep(p, -.38, 0.f, 0.f), vec2(0.17, 0.25));\n        float legs = min(leg1, leg2);\n        float base = sdCappedCylinder(translatep(p, 0.f, -.18, 0.f), vec2(.4, .2));\n        base = opSmoothUnion(legs, base, 0.4);\n        float rise = sdCappedCone(vec3(translate(0.f, 0.4, 0.f) * rotate(180.f, 0.f, 0.f)\n                                 * vec4(p, 1)), 0.15, 0.8, 0.6);\n        float cap = sdSphere(translatep(scalep(p, 0.39, 1.f, 0.39), 0.f, -0.6, 0.f), 0.3);\n        cap = min(rise, cap);\n        float top = sdSphere(translatep(scalep(p, 1.f, 1.1, 1.f), 0.f, -1.65, 0.f), 0.7);\n        float bound = sdBox(translatep(p, 0.f, -1.1, 0.f), vec3(0.7, 0.35, 0.7));\n        top = max(bound, top);\n        top = min(cap, top);\n        base = min(base, top);\n        return base;\n    } else if(id == 2) {\n        //supports\n        float leg1 = sdCappedCylinder(translatep(p, .4, 0.f, 0.f), vec2(0.17, 1.35));\n        float leg2 = sdCappedCylinder(translatep(p, -.4, 0.f, 0.f), vec2(0.17, 1.35));\n        float legs = min(leg1, leg2);\n        return legs;\n    }\n}\n\nvec3 getBoundDimensions(int id) {\n    if(id == 0) {\n        return vec3(1.3, 2.0, 1.3);\n    } else if(id == 1) {\n        return vec3(1, 1.5, 1);\n    } else if(id == 2) {\n        return vec3(0.6, 1.4, 0.2);\n    }\n}\n\nvec3 getColor(int id) {\n    vec3 target = vec3(255, 255, 255);\n    if(id == 0) {\n        target = vec3(124, 216, 243);\n    } else if(id == 1) {\n        target = vec3(124, 216, 243);\n    } else if(id == 2) {\n        target = vec3(200, 200, 220) * 0.5;\n    }\n    return target / 255.f;\n}\n\nvec3 getMinBound(int id) {\n    vec3 p = getBoundDimensions(id);\n\n    vec3 ooo = vec3(getTransform(id) * vec4(p * vec3(-1, -1, -1), 1));\n    vec3 ooi = vec3(getTransform(id) * vec4(p * vec3(-1, -1, 1), 1));\n    vec3 oio = vec3(getTransform(id) * vec4(p * vec3(-1, 1, -1), 1));\n    vec3 oii = vec3(getTransform(id) * vec4(p * vec3(-1, 1, 1), 1));\n    vec3 ioo = vec3(getTransform(id) * vec4(p * vec3(1, -1, -1), 1));\n    vec3 ioi = vec3(getTransform(id) * vec4(p * vec3(1, -1, 1), 1));\n    vec3 iio = vec3(getTransform(id) * vec4(p * vec3(1, 1, -1), 1));\n    vec3 iii = vec3(getTransform(id) * vec4(p * vec3(1, 1, 1), 1));\n\n    vec3 target;\n    for(int i = 0; i < 3; i++) {\n        float minI = min(min(min(ooo[i], ooi[i]), min(oio[i], oii[i])), \n                         min(min(ioo[i], ioi[i]), min(iio[i], iii[i])));\n        target[i] = minI;\n    }\n    return target;\n}\n\nvec3 getMaxBound(int id) {\n    vec3 p = getBoundDimensions(id);\n\n    vec3 ooo = vec3(getTransform(id) * vec4(p * vec3(-1, -1, -1), 1));\n    vec3 ooi = vec3(getTransform(id) * vec4(p * vec3(-1, -1, 1), 1));\n    vec3 oio = vec3(getTransform(id) * vec4(p * vec3(-1, 1, -1), 1));\n    vec3 oii = vec3(getTransform(id) * vec4(p * vec3(-1, 1, 1), 1));\n    vec3 ioo = vec3(getTransform(id) * vec4(p * vec3(1, -1, -1), 1));\n    vec3 ioi = vec3(getTransform(id) * vec4(p * vec3(1, -1, 1), 1));\n    vec3 iio = vec3(getTransform(id) * vec4(p * vec3(1, 1, -1), 1));\n    vec3 iii = vec3(getTransform(id) * vec4(p * vec3(1, 1, 1), 1));\n\n    vec3 target;\n    for(int i = 0; i < 3; i++) {\n        float maxI = max(max(max(ooo[i], ooi[i]), max(oio[i], oii[i])), \n                         max(max(ioo[i], ioi[i]), max(iio[i], iii[i])));\n        target[i] = maxI;\n    }\n    return target;\n}\n\n//Returns range of t [min, max] in bounding box, -1000 if doesn't hit\nvec2 testObjBox(int id, vec3 origin, vec3 dir) {\n    vec3 minp = getMinBound(id);\n    vec3 maxp = getMaxBound(id);\n    float mins[3];\n    float maxes[3];\n    for(int i = 0; i < 3; ++i) {\n        mins[i] = (minp[i] - origin[i]) / dir[i];\n        maxes[i] = (maxp[i] - origin[i]) / dir[i];\n        if(mins[i] > maxes[i]) {\n            float tmp = mins[i];\n            mins[i] = maxes[i];\n            maxes[i] = tmp;\n        }\n    }\n    float minT = max(mins[0], max(mins[1], mins[2]));\n    float maxT = min(maxes[0], min(maxes[1], maxes[2]));\n    if(minT > maxT) {\n        return vec2(-1000.f, -1000.f);\n    }\n    return vec2(minT, maxT);\n}\n\nvec3 getNormal(int id, vec3 p) {\n    float EPSILON = 0.01;\n    return normalize(vec3(\n        getSDF(id, vec3(p.x + EPSILON, p.y, p.z)) - getSDF(id, vec3(p.x - EPSILON, p.y, p.z)),\n        getSDF(id, vec3(p.x, p.y + EPSILON, p.z)) - getSDF(id, vec3(p.x, p.y - EPSILON, p.z)),\n        getSDF(id, vec3(p.x, p.y, p.z + EPSILON)) - getSDF(id, vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nfloat hitsObj(vec3 ro, vec3 rd, float maxT) {\n    //Parameters\n    int steps = 3000;\n    const int numPrimitives = 3;\n    //-1000 if ray won't hit object, else holds minT value (bounding box)\n    float testObjs[numPrimitives] = float[](-1000.f, -1000.f, -1000.f);\n\n    float t = 0.00001;\n    vec3 curr = ro;\n    float dist;\n    float res = 1.f;\n    float k = 30.f;\n\n    for(int id = 0; id < numPrimitives; id++) {\n        vec2 minMax = testObjBox(id, ro, rd);\n        if(minMax[0] > -900.f) {\n            //hits bounding box\n            testObjs[id] = minMax[0];\n        }\n    }\n\n    do {\n        dist = 10000.f;\n        for(int id = 0; id < numPrimitives; id++) {\n            //Check if hits object's bounding box\n            if(testObjs[id] > -900.f) {\n                //Test ray with untransformed object\n                vec3 temp = vec3(inverse(getTransform(id)) * vec4(curr, 1));\n                float currDist = getSDF(id, temp) * getScale(id);\n                if(currDist < dist) {\n                    dist = currDist;\n                }\n                //Intersects object id\n                if(currDist < 0.0005) {\n                    return 0.f;\n                }\n                //Soft shadows\n                res = min( res, k*currDist/t );\n            }\n        }\n        steps = steps - 1;\n        t += dist;\n        curr = ro + rd * t;\n    } while(dist >= 0.0001 && steps > 0 && t < maxT);\n\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 /iResolution.xy) - vec2(1, 1);\n    vec2 uv01 = (fragCoord/iResolution.xy);\n    \n   \tvec3 u_Eye = vec3(0, 0, -10);\n    vec3 u_Ref = vec3(0, 0, 0);\n    vec3 u_Up = vec3(0, 1, 0);\n    float fovy = 45.f;\n    float aspect = iResolution.x / iResolution.y;\n    float len = length(u_Ref - u_Eye);\n    vec3 F = normalize(u_Ref - u_Eye);\n    vec3 R = normalize(cross(u_Up, F));\n    vec3 V = vec3(u_Up * len * tan(fovy / 2.f));\n    vec3 H = vec3(R * len * aspect * tan(fovy / 2.f));\n    vec3 world = u_Ref + uv.x * H + uv.y * V;\n    //Calculating ray\n    vec3 ray_origin = u_Eye;\n    vec3 ray_direction = normalize(world - u_Eye);\n\n    //Background\n    vec3 col = vec3(texture(iChannel0, uv01));\n\n    //Parameters\n    int steps = 300;\n    float maxT = 200.f;\n    const int numPrimitives = 3;\n    //-1000 if ray won't hit object, else holds minT value (bounding box)\n    float testObjs[numPrimitives] = float[](-1000.f, -1000.f, -1000.f);\n\n    vec3 curr = ray_origin;\n    float t = 0.f;\n    float dist;\n    //What we want\n    int minObject = -1;\n    vec3 intersection;\n    vec3 normal;\n\n    t = 10000.f;\n    for(int id = 0; id < numPrimitives; id++) {\n        vec2 minMax = testObjBox(id, ray_origin, ray_direction);\n        if(minMax[0] > -900.f) {\n            //hits bounding box\n            if(minMax[0] < t) {\n                //closest bounding box hit\n                t = minMax[0];\n            }\n            testObjs[id] = minMax[0];\n        }\n    }\n    curr = ray_origin + t * ray_direction;\n\n    do {\n        dist = 10000.f;\n        for(int id = 0; id < numPrimitives; id++) {\n            //Check if hits object's bounding box\n            if(testObjs[id] > -900.f) {\n                //Test ray with untransformed object\n                vec3 temp = vec3(inverse(getTransform(id)) * vec4(curr, 1));\n                float currDist = getSDF(id, temp) * getScale(id);\n                if(currDist < dist) {\n                    dist = currDist;\n                }\n                //Intersects object id\n                if(currDist < 0.001) {\n                    minObject = id;\n                    intersection = temp;\n                    normal = normalize(mat3(inverse(transpose(getTransform(id)))) * getNormal(id, intersection));\n                    intersection = vec3(getTransform(id) * vec4(intersection, 1));\n                }\n            }\n        }\n        steps = steps - 1;\n        t += dist;\n        curr = ray_origin + ray_direction * t;\n    } while(dist >= 0.001 && steps > 0 && t < maxT);\n\n    if(minObject > -1) {\n        vec3 color = getColor(minObject);\n        vec3 toEye = normalize(u_Eye - intersection);\n        float k = 80.f;\n        \n        if(minObject != 2) {\n            float rFactor = worley(vec2(intersection.xy) * 0.8, 1.4893);\n            color.r += rFactor;\n        }\n        //Green light\n        vec3 greenCol = vec3(0.2, 0.7, 0.2);\n        vec3 greenPos = vec3(-3, 0, -5);\n        vec3 toGreen = normalize(greenPos - intersection);\n        float intensityGreen = dot(toGreen, normal);\n        float specIntensityGreen = pow(clamp(dot(normal, (toGreen + toEye) / 2.f), 0.f, 1.f), k);\n        //Blue light\n        vec3 blueCol = vec3(0.2, 0.2, 0.7);\n        vec3 bluePos = vec3(3, 0, -5);\n        vec3 toBlue = normalize(bluePos - intersection);\n        float intensityBlue = dot(toBlue, normal);\n        float specIntensityBlue = pow(clamp(dot(normal, (toBlue + toEye) / 2.f), 0.f, 1.f), k);\n        //Lamp\n        vec3 lampCol = vec3(248, 218, 114) / 255.f;\n        vec3 lampPos = vec3(0, 0.15, 0);\n        vec3 toLamp = normalize(lampPos - intersection);\n        float intensityLamp = clamp(dot(toLamp, normal), 0.f, 1.f);\n        float lamp = hitsObj(intersection + normal * 0.01, toLamp, length(lampPos - intersection));\n        //ambient + diffuse\n        color = color * 0.25 + \n                greenCol * color * intensityGreen * 0.3 + \n                blueCol * color * intensityBlue * 0.3 + \n                lamp * lampCol * color * intensityLamp * 1.f;\n        if(minObject == 1) {\n            color += greenCol * color * specIntensityGreen * 20.f + \n                \t blueCol * color * specIntensityBlue * 20.f;\n        }\n        color = clamp(color, 0.f, 1.f);\n        // post\n        color=pow(color,vec3(0.5)); \n        //color=color*0.0+1.f*color*color*(3.0-2.0*color);  // contrast\n        color=mix(color, vec3(dot(color, vec3(0.33))), -0.3);  // satuation\n        //transparent\n        if(minObject == 2) {\n            color = pow(color, vec3(0.2));\n            col = 0.15 * color + 0.85 * col;\n        } else {\n        \tcol = 0.7 * color + 0.3 * col;\n        }\n    }\n    \n    //---------------------------------------------------------------------------------\n    \n    //AntiAliasing for path\n    vec2 uv2d = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n    float pixelLength = 1.f / min(iResolution.x, iResolution.y);\n    float delta = pixelLength / 8.f;\n    vec3 targetPath = vec3(0);\n    for(float i = 0.f; i < 4.f; i++) {\n        for(float j = 0.f; j < 4.f; j++) {\n            vec2 uvaa = uv2d - vec2(delta * 3.f) + vec2(2.f * delta * i, 2.f * delta * j);\n            vec3 pathCol = col;\n            vec3 add = vec3(0.f);\n            //Bottom two\n            if(uvaa.y < -0.4 && uvaa.x > 0.3 && uvaa.x < 1.1) {\n                float f = sdLine(uvaa, vec2(0, -1.2), vec2(1, -0.8));\n                if(f < 0.015) {\n                    add = max(add, lineCol(f, 0.003, 0.02));\n                }\n                f = sdLine(uvaa, vec2(1, -0.8), vec2(0.4, -0.45));\n                if(f < 0.015) {\n                    add = max(add, lineCol(f, 0.003, 0.02));\n                }\n                f = sdCircle(uvaa - vec2(1, -0.8), 0.015);\n                if(f < 0.04) {\n                    add = max(add, lineCol(f, 0.001, 0.04));\n                }\n            }\n            if(uvaa.x > -0.6 && uvaa.x < 0.5) {\n            \t//Middle segments\n                if(uvaa.y > -0.5 && uvaa.y < -0.3) {\n                    float f = sdLine(uvaa, vec2(0.4, -0.45), vec2(-0.25, -0.35));\n                    if(f < 0.015) {\n                        add = max(add, lineCol(f, 0.003, 0.02));\n                    }\n                    f = sdCircle(uvaa - vec2(0.4, -0.45), 0.015);\n                    if(f < 0.04) {\n                        add = max(add, lineCol(f, 0.001, 0.04));\n                    }\n                    f = sdLine(uvaa, vec2(-0.25, -0.35), vec2(-0.5, -0.33));\n                    if(f < 0.015) {\n                        add = max(add, lineCol(f, 0.003, 0.02));\n                    }\n                    f = sdCircle(uvaa - vec2(-0.25, -0.35), 0.008);\n                    if(f < 0.02) {\n                        add = max(add, lineCol(f, 0.001, 0.02));\n                    }\n                }\n                //Lamp\n                if(uvaa.y > -0.5 && uvaa.y < 1.f) {\n                    float f = sdCircle(uvaa / vec2(1, 1.5) - vec2(0, 0.015), 0.015);\n                    if(f < 0.001) {\n                        add = max(add, lampCol(f, 0.001, 0.5));\n                    }\n                    f = sdCircle(uvaa - vec2(0, 0.019), 0.008);\n                    if(f < 0.06) {\n                        add += max(add, lampCol(f, 0.0, 0.06));\n                    }\n                }\n            }\n            //Left part\n            if(uvaa.x > -1.1 && uvaa.x < -0.4) {\n                if(uvaa.y > -0.4 && uvaa.y < 0.1) {\n                    float f = sdLine(uvaa, vec2(-0.5, -0.33), vec2(-1, -0.05));\n                    if(f < 0.015) {\n                        add = max(add, lineCol(f, 0.003, 0.02));\n                    }\n                    f = sdCircle(uvaa - vec2(-0.5, -0.33), 0.015);\n                    if(f < 0.04) {\n                        add = max(add, lineCol(f, 0.001, 0.04));\n                    }\n                }\n                if(uvaa.y > -0.15 && uvaa.y < 0.2) {\n                    float f = sdLine(uvaa, vec2(-1, -0.05), vec2(-0.625, 0.12));\n                    if(f < 0.015) {\n                        add = max(add, lineCol(f, 0.003, 0.02));\n                    }\n                    f = sdCircle(uvaa - vec2(-1, -0.05), 0.015);\n                    if(f < 0.04) {\n                        add = max(add, lineCol(f, 0.001, 0.04));\n                    }\n                }\n                if(uvaa.y > 0.f && uvaa.y < 0.3) {\n                    float f = sdLine(uvaa, vec2(-0.625, 0.12), vec2(-0.49, 0.23));\n                    if(f < 0.015) {\n                        add = max(add, lineCol(f, 0.003, 0.02));\n                    }\n                    f = sdCircle(uvaa - vec2(-0.625, 0.12), 0.008);\n                    if(f < 0.02) {\n                        add = max(add, lineCol(f, 0.001, 0.02));\n                    }\n                }\n            }\n            //Top\n            if(uvaa.y > 0.2 && uvaa.y < 0.4 && uvaa.x > -0.6 && uvaa.x < -0.1) {\n                float f = sdLine(uvaa, vec2(-0.49, 0.23), vec2(-0.18, 0.34));\n                if(f < 0.015) {\n                    add = max(add, lineCol(f, 0.003, 0.02));\n                }\n                f = sdCircle(uvaa - vec2(-0.49, 0.23), 0.008);\n                if(f < 0.02) {\n                    add = max(add, lineCol(f, 0.001, 0.02));\n                }\n                f = sdCircle(uvaa - vec2(-0.18, 0.34), 0.015);\n                if(f < 0.04) {\n                    add = max(add, lineCol(f, 0.001, 0.04));\n                }\n            }\n            pathCol += add;\n            targetPath += pathCol;\n        }\n    }\n    col = targetPath / 16.f;\n    col*=0.5+0.7*pow(16.0*uv01.x*uv01.y*(1.0-uv01.x)*(1.0-uv01.y),0.5);  // vigneting\n    col = clamp(col, 0.f, 1.f);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float random(vec2 ab) {\n\tfloat f = (cos(dot(ab ,vec2(21.9898,78.233))) * 43758.5453);\n\treturn fract(f);\n}\n\nfloat noise(in vec2 xy) {\n\tvec2 ij = floor(xy);\n\tvec2 uv = xy-ij;\n\tuv = uv*uv*(3.0-2.0*uv);\n\t\n\n\tfloat a = random(vec2(ij.x, ij.y ));\n\tfloat b = random(vec2(ij.x+1., ij.y));\n\tfloat c = random(vec2(ij.x, ij.y+1.));\n\tfloat d = random(vec2(ij.x+1., ij.y+1.));\n\tfloat k0 = a;\n\tfloat k1 = b-a;\n\tfloat k2 = c-a;\n\tfloat k3 = a-b-c+d;\n\treturn (k0 + k1*uv.x + k2*uv.y + k3*uv.x*uv.y);\n}\n\nfloat getScale(int id) {\n  \t//insert ids here if using scale\n  \tif(id == 0) {\n    \treturn 1.f;\n  \t}\n  \treturn 1.f;\n}\n\nmat4 getTransform(int id) {\n  \tif(id == 0) {\n    \tmat4 target = mat4(1);\n        target[1][1] = 0.4;\n        target = translate(0.0, -11.5, 10.0) * target;\n    \treturn target;\n    }\n}\n\nfloat getSDF(int id, vec3 p) {\n  \tif(id == 0) {\n    \treturn sdSphere(p, 8.f);\n    }\n}\n\nvec3 getBoundDimensions(int id) {\n    if(id == 0) {\n        return vec3(8, 8, 8);\n    }\n}\n\nvec3 getColor(int id, vec3 p) {\n    vec3 target = vec3(255, 255, 255);\n    if(id == 0) {\n        //bright part: 251, 244, 200\n        target = vec3(153, 185, 172) * 1.f;\n    }\n    return target / 255.f;\n}\n\nvec3 getMinBound(int id) {\n    vec3 p = getBoundDimensions(id);\n\n    vec3 ooo = vec3(getTransform(id) * vec4(p * vec3(-1, -1, -1), 1));\n    vec3 ooi = vec3(getTransform(id) * vec4(p * vec3(-1, -1, 1), 1));\n    vec3 oio = vec3(getTransform(id) * vec4(p * vec3(-1, 1, -1), 1));\n    vec3 oii = vec3(getTransform(id) * vec4(p * vec3(-1, 1, 1), 1));\n    vec3 ioo = vec3(getTransform(id) * vec4(p * vec3(1, -1, -1), 1));\n    vec3 ioi = vec3(getTransform(id) * vec4(p * vec3(1, -1, 1), 1));\n    vec3 iio = vec3(getTransform(id) * vec4(p * vec3(1, 1, -1), 1));\n    vec3 iii = vec3(getTransform(id) * vec4(p * vec3(1, 1, 1), 1));\n\n    vec3 target;\n    for(int i = 0; i < 3; i++) {\n        float minI = min(min(min(ooo[i], ooi[i]), min(oio[i], oii[i])), \n                         min(min(ioo[i], ioi[i]), min(iio[i], iii[i])));\n        target[i] = minI;\n    }\n    return target;\n}\n\nvec3 getMaxBound(int id) {\n    vec3 p = getBoundDimensions(id);\n\n    vec3 ooo = vec3(getTransform(id) * vec4(p * vec3(-1, -1, -1), 1));\n    vec3 ooi = vec3(getTransform(id) * vec4(p * vec3(-1, -1, 1), 1));\n    vec3 oio = vec3(getTransform(id) * vec4(p * vec3(-1, 1, -1), 1));\n    vec3 oii = vec3(getTransform(id) * vec4(p * vec3(-1, 1, 1), 1));\n    vec3 ioo = vec3(getTransform(id) * vec4(p * vec3(1, -1, -1), 1));\n    vec3 ioi = vec3(getTransform(id) * vec4(p * vec3(1, -1, 1), 1));\n    vec3 iio = vec3(getTransform(id) * vec4(p * vec3(1, 1, -1), 1));\n    vec3 iii = vec3(getTransform(id) * vec4(p * vec3(1, 1, 1), 1));\n\n    vec3 target;\n    for(int i = 0; i < 3; i++) {\n        float maxI = max(max(max(ooo[i], ooi[i]), max(oio[i], oii[i])), \n                         max(max(ioo[i], ioi[i]), max(iio[i], iii[i])));\n        target[i] = maxI;\n    }\n    return target;\n}\n\n//Returns range of t [min, max] in bounding box, -1000 if doesn't hit\nvec2 testObjBox(int id, vec3 origin, vec3 dir) {\n    vec3 minp = getMinBound(id);\n    vec3 maxp = getMaxBound(id);\n    float mins[3];\n    float maxes[3];\n    for(int i = 0; i < 3; ++i) {\n        mins[i] = (minp[i] - origin[i]) / dir[i];\n        maxes[i] = (maxp[i] - origin[i]) / dir[i];\n        if(mins[i] > maxes[i]) {\n            float tmp = mins[i];\n            mins[i] = maxes[i];\n            maxes[i] = tmp;\n        }\n    }\n    float minT = max(mins[0], max(mins[1], mins[2]));\n    float maxT = min(maxes[0], min(maxes[1], maxes[2]));\n    if(minT > maxT) {\n        return vec2(-1000.f, -1000.f);\n    }\n    return vec2(minT, maxT);\n}\n\nvec3 getNormal(int id, vec3 p) {\n    float EPSILON = 0.01;\n    return normalize(vec3(\n        getSDF(id, vec3(p.x + EPSILON, p.y, p.z)) - getSDF(id, vec3(p.x - EPSILON, p.y, p.z)),\n        getSDF(id, vec3(p.x, p.y + EPSILON, p.z)) - getSDF(id, vec3(p.x, p.y - EPSILON, p.z)),\n        getSDF(id, vec3(p.x, p.y, p.z + EPSILON)) - getSDF(id, vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 /iResolution.xy) - vec2(1, 1);\n    \n   \tvec3 u_Eye = vec3(0, 0, -10);\n    vec3 u_Ref = vec3(0, 0, 0);\n    vec3 u_Up = vec3(0, 1, 0);\n    float fovy = 45.f;\n    float aspect = iResolution.x / iResolution.y;\n    float len = length(u_Ref - u_Eye);\n    vec3 F = normalize(u_Ref - u_Eye);\n    vec3 R = normalize(cross(u_Up, F));\n    vec3 V = vec3(u_Up * len * tan(fovy / 2.f));\n    vec3 H = vec3(R * len * aspect * tan(fovy / 2.f));\n    vec3 world = u_Ref + uv.x * H + uv.y * V;\n    //Calculating ray\n    vec3 ray_origin = u_Eye;\n    vec3 ray_direction = normalize(world - u_Eye);\n\n    //Background\n    vec3 col = vec3(17, 15, 39) / 255.f;\n    float stars = clamp(pow(noise(fragCoord), 40.f) * 10.f, 0.f, 0.8);\n    col = clamp(col + vec3(stars), 0.f, 1.f);\n\n    //Parameters\n    int steps = 300;\n    float maxT = 200.f;\n    const int numPrimitives = 1;\n    //-1000 if ray won't hit object, else holds minT value (bounding box)\n    float testObjs[numPrimitives] = float[](-1000.f);\n\n    vec3 curr = ray_origin;\n    float t = 0.f;\n    float dist;\n    //What we want\n    int minObject = -1;\n    vec3 intersection;\n    vec3 normal;\n\n    t = 10000.f;\n    for(int id = 0; id < numPrimitives; id++) {\n        vec2 minMax = testObjBox(id, ray_origin, ray_direction);\n        if(minMax[0] > -900.f) {\n            //hits bounding box\n            if(minMax[0] < t) {\n                //closest bounding box hit\n                t = minMax[0];\n            }\n            testObjs[id] = minMax[0];\n        }\n    }\n    curr = ray_origin + t * ray_direction;\n\n    do {\n        dist = 10000.f;\n        for(int id = 0; id < numPrimitives; id++) {\n            //Check if hits object's bounding box\n            if(testObjs[id] > -900.f) {\n                //Test ray with untransformed object\n                vec3 temp = vec3(inverse(getTransform(id)) * vec4(curr, 1));\n                float currDist = getSDF(id, temp) * getScale(id);\n                if(currDist < dist) {\n                    dist = currDist;\n                }\n                //Intersects object id\n                if(currDist < 0.001) {\n                    minObject = id;\n                    intersection = temp;\n                    normal = normalize(mat3(inverse(transpose(getTransform(id)))) * getNormal(id, intersection));\n                    intersection = vec3(getTransform(id) * vec4(intersection, 1));\n                }\n            }\n        }\n        steps = steps - 1;\n        t += dist;\n        curr = ray_origin + ray_direction * t;\n    } while(dist >= 0.001 && steps > 0 && t < maxT);\n\n    if(minObject > -1) {\n        vec3 lightCol = vec3(1, 1, 1);\n        vec3 color = getColor(minObject, intersection);\n        vec3 lightPos = vec3(3, 0, -5);\n        vec3 toLight = normalize(lightPos - intersection);\n        float intensity = dot(toLight, normal);\n        //ambient + diffuse\n        col = vec3(color * 0.5 + lightCol * color * intensity * 0.5);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Clouds and 2d circles\n\nfloat bias(float b, float t) {\n    return pow(t, log(b) / log(0.5f));\n}\n\nfloat gain(float g, float t) {\n    if(t < 0.5f) {\n        return bias(1.f-g, 2.f*t) / 2.f;\n    } else {\n        return 1.f - bias(1.f-g, 2.f - 2.f * t) / 2.f;\n    }\n}\n\nfloat falloff(float t) {\n    return t*t*t*(t*(t*6.f - 15.f) + 10.f);\n}\n\nfloat lerp(float a, float b, float t) {\n    return (1.0 - t) * a + t * b;\n}\n\n//ix and iy are the corner coordinates\nfloat dotGridGradient(int ix, int iy, float x, float y, float seed) {\n    vec2 dist = vec2(x - float(ix), y - float(iy));\n    vec2 rand = (random2(vec2(ix, iy), vec2(seed, seed * 2.139)) * 2.f) - 1.f;\n    return dist[0] * rand[0] + dist[1] * rand[1];\n}\n\n//Perlin returns a value in [-1, 1]\nfloat perlin(vec2 pos, float seed) {\n    //Pixel lies in (x0, y0)\n    int x0 = int(floor(pos[0]));\n    int x1 = x0 + 1;\n    int y0 = int(floor(pos[1]));\n    int y1 = y0 + 1;\n\n    float wx = falloff(pos[0] - float(x0));\n    float wy = falloff(pos[1] - float(y0));\n\n    float n0, n1, ix0, ix1, value;\n    n0 = dotGridGradient(x0, y0, pos[0], pos[1], seed);\n    n1 = dotGridGradient(x1, y0, pos[0], pos[1], seed);\n    ix0 = lerp(n0, n1, wx);\n    n0 = dotGridGradient(x0, y1, pos[0], pos[1], seed);\n    n1 = dotGridGradient(x1, y1, pos[0], pos[1], seed);\n    ix1 = lerp(n0, n1, wx);\n    value = lerp(ix0, ix1, wy);\n\n    return value;\n}\n\nfloat dampen(float t) {\n    if(t < 0.4) {\n        return pow(t / 0.4, 3.f) * 0.4;\n    }\n    return t;\n}\n\nfloat fbmPerlin(vec2 pos, float octaves, float seed) {\n    float total = 0.f;\n    float persistence = 0.5;\n\n    for(float i = 0.f; i < octaves; i++) {\n        float freq = pow(2.f, i);\n        //divide by 2 so that max is 1\n        float amp = pow(persistence, i) / 2.f;\n        total += ((perlin(pos * float(freq), seed) + 1.f) / 2.f) * amp;\n    }\n\n    return clamp(total, 0.f, 1.f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    vec3 col = vec3(texture(iChannel0, uv));\n    \n    vec2 uv1 = uv + vec2(iTime / 100.f, 0);\n    vec2 uv2 = uv + vec2(iTime / 20.f, 0);\n\n    float noise = dampen(gain(0.98, fbmPerlin(uv1 * 2.f, 10.f, 1.328)));\n    vec3 clouds1 = vec3(60, 56, 147) * noise / 255.f;\n    \n    noise = dampen(gain(0.98, fbmPerlin(uv1 * 2.f, 10.f, 1.89)));\n\tvec3 clouds2 = vec3(80, 80, 160) * noise / 255.f;\n    \n    noise = smoothstep(0.50, 0.7, fbmPerlin(uv2 * 2.f, 10.f, 4.945));\n    vec3 clouds3 = vec3(217, 93, 159) * noise / 255.f;\n    \n    vec3 clouds = clouds1 + clouds2;\n    col = clouds * 0.2 + col * 0.8;\n    col = clamp(col + clouds3 * 0.3, 0.f, 1.f);\n    \n    //AntiAliased 2d circles\n    vec2 uv2d = (2.0*fragCoord.xy-iResolution.xy)/min(iResolution.x,iResolution.y);\n    float pixelLength = 1.f / min(iResolution.x, iResolution.y);\n    float delta = pixelLength / 8.f;\n    vec3 targetPath = vec3(0);\n    \n    float time = fract(iTime / 4.f);\n    float scaleTime = clamp((1.f - time) * 1.4, 0.f, 1.f);\n    float time2 = fract(fract(iTime / 4.f) + 0.5);\n    float scaleTime2 = clamp((1.f - time2) * 1.4, 0.f, 1.f);\n    float scale = 1.5;\n    \n    for(float i = 0.f; i < 4.f; i++) {\n        for(float j = 0.f; j < 4.f; j++) {\n            vec2 uvaa = uv2d - vec2(delta * 3.f) + vec2(2.f * delta * i, 2.f * delta * j);\n            vec3 pathCol = col;\n            \n            float f = abs(sdCircle(uvaa - vec2(0, 0.98), time * scale));\n            if(f < 0.03) {\n                pathCol += lineCol(f, 0.003, 0.03) * scaleTime;\n            }\n            f = abs(sdCircle(uvaa - vec2(0, 0.98), 0.03 + time * scale));\n            if(f < 0.015) {\n                pathCol += lineCol(f, 0.001, 0.01) * scaleTime;\n            }\n            f = abs(sdCircle(uvaa - vec2(0, 0.98), time2 * scale));\n            if(f < 0.03) {\n                pathCol += lineCol(f, 0.003, 0.03) * scaleTime2;\n            }\n            f = abs(sdCircle(uvaa - vec2(0, 0.98), 0.03 + time2 * scale));\n            if(f < 0.015) {\n                pathCol += lineCol(f, 0.001, 0.01) * scaleTime2;\n            }\n            f = abs(sdCircle(uvaa - vec2(0, 0.98), 0.03 + 1.5));\n            if(f < 0.015) {\n                pathCol += lineCol(f, 0.001, 0.01) * 0.2;\n            }\n            targetPath += pathCol;\n        }\n        \n    }\n    col = targetPath / 16.f;\n    fragColor = vec4(col, 1);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Color for 2d sdfs\nvec3 lineCol(float f, float a, float b) {\n    vec3 col = mix(vec3(139, 97, 130) * 0.8 / 255.f, vec3(0), smoothstep(0.f, b, f));\n    if(f < a) {\n        col = vec3(254, 241, 250) / 255.f;\n    }\n    return col;\n}\n\nvec3 lampCol(float f, float a, float b) {\n    vec3 col = mix(vec3(248, 218, 114) * 0.8 / 255.f, vec3(0), smoothstep(0.f, b, f));\n    if(f < a) {\n        col = vec3(248, 218, 114) / 255.f;\n    }\n    return col;\n}\n\nvec2 random2( vec2 p , vec2 seed) {\n    return fract(sin(vec2(dot(p + seed, vec2(311.7, 127.1)), dot(p + seed, vec2(269.5, 183.3)))) * 85734.3545);\n}\n\nvec2 worleyPoint(int x, int y, float seed) {\n  //The random point inside grid cell (x, y)\n  return random2(vec2(13.72 * float(x) * seed, 2.38 * float(y) * seed), vec2(0.28, 0.328));\n}\n\nfloat worley(vec2 pos, float seed) {\n  //Calculating which unit the pixel lies in\n  int x = int(floor(pos[0]));\n  int y = int(floor(pos[1]));\n  //Calculating closest distance\n  float dist = 100000.f;\n  for(int i = x - 1; i < x + 2; i++) {\n    for(int j = y - 1; j < y + 2; j++) {\n      vec2 point = vec2(float(i) + worleyPoint(i, j, seed)[0], float(j) + worleyPoint(i, j, seed)[1]);\n      if(distance(pos, point) < dist) {\n        dist = distance(pos, point);\n      }\n    }\n  }\n  return clamp(dist, 0.f, 1.f);\n}\n\nfloat fbmWorley(vec2 pos, float octaves, float seed) {\n  float total = 0.f;\n  float persistence = 0.5f;\n\n  for(float i = 0.f; i < octaves; i++) {\n    float freq = pow(2.f, i);\n    //divide by 2 so that max is 1\n    float amp = pow(persistence, i) / 2.f;\n    total += worley(pos * float(freq), seed) * amp;\n  }\n\n  return total;\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdSphere(vec3 p, float r) {\n  \treturn length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,max(d.y,d.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 ) {\n    vec2 q = vec2( length(p.xz), p.y );\n\n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nmat4 translate(float x, float y, float z) {\n    mat4 m = mat4(1);\n    m[3] = vec4(x, y, z, 1);\n   \treturn m;\n}\n\nvec3 translatep(vec3 p, float x, float y, float z) {\n    mat4 m = mat4(1);\n    m[3] = vec4(x, y, z, 1);\n    return vec3(m * vec4(p, 1));\n}\n\nmat4 rotate(float x, float y, float z) {\n    vec3 r = vec3(x, y, z);\n    r = radians(r);\n    mat4 xr = mat4(1, 0, 0, 0, \n                  0, cos(r[0]), sin(r[0]), 0,\n                  0, -sin(r[0]), cos(r[0]), 0,\n                  0, 0, 0, 1);\n    mat4 yr = mat4(cos(r[1]), 0, -sin(r[1]), 0,\n                  0, 1, 0, 0,\n                  sin(r[1]), 0, cos(r[1]), 0,\n                  0, 0, 0, 1);\n    mat4 zr = mat4(cos(r[2]), sin(r[2]), 0, 0,\n                  -sin(r[2]), cos(r[2]), 0, 0,\n                  0, 0, 1, 0,\n                  0, 0, 0, 1);\n    return xr * yr * zr;\n}\n\nvec3 rotatep(vec3 p, float x, float y, float z) {\n    vec3 r = vec3(x, y, z);\n    r = radians(r);\n    mat4 xr = mat4(1, 0, 0, 0, \n                  0, cos(r[0]), sin(r[0]), 0,\n                  0, -sin(r[0]), cos(r[0]), 0,\n                  0, 0, 0, 1);\n    mat4 yr = mat4(cos(r[1]), 0, -sin(r[1]), 0,\n                  0, 1, 0, 0,\n                  sin(r[1]), 0, cos(r[1]), 0,\n                  0, 0, 0, 1);\n    mat4 zr = mat4(cos(r[2]), sin(r[2]), 0, 0,\n                  -sin(r[2]), cos(r[2]), 0, 0,\n                  0, 0, 1, 0,\n                  0, 0, 0, 1);\n    mat4 rotate = xr * yr * zr;\n\treturn vec3(rotate * vec4(p, 1));\n}\n\nvec3 scalep(vec3 p, float x, float y, float z) {\n    mat4 m = mat4(1);\n    m[0][0] = x;\n    m[1][1] = y;\n    m[2][2] = z;\n    return vec3(m * vec4(p, 1));\n}","name":"Common","description":"","type":"common"}]}