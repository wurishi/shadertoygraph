{"ver":"0.1","info":{"id":"wlSfWR","date":"1598645825","viewed":621,"name":"Simple Voxel Cone Tracing 3D","username":"Carandiru","description":"3D version","likes":6,"published":3,"flags":32,"usePreview":0,"tags":["voxelconetracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// Fork of \"Simple Voxel Cone Tracing\" by jojendersie. https://shadertoy.com/view/tdlBDs\n// 2020-08-28 17:57:18\n\n#define R (iResolution.xy)\n\n\nvec2 lensDistort(vec2 c, float factor)\n{\n    // [0;1] -> [-1;1]\n    c = (c - 0.5) * 2.0;\n    // [-1;1] -> film frame size\n    c.y *= 3.0/4.0;\n    // distort\n    c /= 1.0 + dot(c, c) * -factor + 1.6 * factor;\n    // film frame size -> [-1;1]\n    c.y *= 4.0/3.0;\n    // [-1;1] -> [0;1]\n    c = c * 0.5 + 0.5;\n    return c;\n}\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    vec2 uv = U/R;\n    \n    uv = lensDistort(uv, 0.1)*R/min(R,R.yx);\n    uv.y = 1.0 - uv.y;\n    uv = uv / R.x * R.y + vec2(0.0,0.2);\n    \n    float bw = texture(iChannel0, uv).r;\n    \n    vec3 color = crt(iChannel0, viridis(bw), uv, R);\n    \n    float outside = float(abs(U.y/R.y*2.0-1.0) > (R.x / R.y / 2.35));\n    color = mix(color, vec3(0), outside);\n    \n    \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n#define LUMA vec3(0.2126f, 0.7152f, 0.0722f)\n\n\n// viridis palette function port //             \n#define fma(a,b,c) (a*b+c)\n\nvec3 viridis(float t) \n{\n\tconst vec3 _c0 = vec3( 0.2777273272234177, 0.005407344544966578, 0.3340998053353061 );\n\tconst vec3 _c1 = vec3( 0.1050930431085774, 1.404613529898575, 1.384590162594685 );\n\tconst vec3 _c2 = vec3( -0.3308618287255563, 0.214847559468213, 0.09509516302823659 );\n\tconst vec3 _c3 = vec3( -4.634230498983486, -5.799100973351585, -19.33244095627987 );\n\tconst vec3 _c4 = vec3( 6.228269936347081, 14.17993336680509, 56.69055260068105 );\n\tconst vec3 _c5 = vec3( 4.776384997670288, -13.74514537774601, -65.35303263337234 );  \n    const vec3 _c6 = vec3( -5.435455855934631, 4.645852612178535, 26.3124352495832 );  \n\n\tvec3 xmT = vec3(t);\n    \n    vec3 x;\n\n    // c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))))\n    x = fma(xmT, _c6, _c5);\n    x = fma(x, xmT, _c4);\n    x = fma(x, xmT, _c3);\n    x = fma(x, xmT, _c2);\n    x = fma(x, xmT, _c1);\n    x = fma(x, xmT, _c0);\n\n    return(x);\n}\n\n// https://www.shadertoy.com/view/WlfXRN\n\nvec3 inferno(float t) {\n\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\n// backup of good crt shader technique\nvec3 bleed(in sampler2D colorTex, in vec3 color, in vec2 uv, in vec2 invR, in float strength)\n{\n\tvec4 uv_offset = vec4(uv + (0.5f * invR), uv - (0.5f * invR));\n    return( mix( color, max(color,\tmax(max( textureLodOffset(colorTex, uv_offset.xy, 0.0, ivec2( 1,  1)).rgb, \n\t\t\t\t\t\t\t\t\t\t\t textureLodOffset(colorTex, uv_offset.xy, 0.0, ivec2( 1, -1)).rgb), \n\t\t\t\t\t\t\t\t\t\tmax( textureLodOffset(colorTex, uv_offset.zw, 0.0, ivec2( -1, 1)).rgb, \n\t\t\t\t\t\t\t\t\t\t\t textureLodOffset(colorTex, uv_offset.zw, 0.0, ivec2( -1,-1)).rgb) ) ), strength) );\n}\n\nconst float bleedStr \t\t= 0.75f;\nconst float rgbMaskSub \t\t= 96.0f / 255.0f;\nconst float rgbMaskSep\t\t= 1.5f;\nconst float rgbMaskStr\t\t= 0.15f;\nconst float rgbMaskPix\t\t= 7.0f;\nconst float hardScan\t\t= 0.1f;\nconst float scanPix\t\t\t= 5.0f;\n\nvec3 crt( in sampler2D colorBleedTex, in vec3 color, in vec2 uv, in vec2 R )\n{\n\t//\n\tvec2 modulo = floor(mod(uv * R, vec2(rgbMaskPix, scanPix)));\n\n\tfloat luminance = dot(color, LUMA);\n\tfloat maskLuma = (rgbMaskSub + (0.5f - rgbMaskSub) * -(luminance * 2.0f - 1.0f));\n\tfloat maskStrength = (rgbMaskStr - (1.0f - rgbMaskStr) * 0.5f * luminance);\n\n\t// apply rgb mask\n\t// vertical //\n\tvec3 color_crt = mix(color,\n\t\t\t\tcolor - mix(vec3(0, maskLuma * rgbMaskSep * 0.5f, maskLuma * rgbMaskSep),\n\t\t\t\t\t\tmix(vec3(maskLuma * rgbMaskSep * 0.5f, 0, maskLuma * rgbMaskSep * 0.5f),\n\t\t\t\t\t\t\tvec3(maskLuma * rgbMaskSep, maskLuma * rgbMaskSep * 0.5f, 0),\n\t\t\t\t\t\t\tmodulo.x * 0.5f),\n\t\t\t\t\t\tmodulo.x * 0.5f),\n\t\t\t\t\tmaskStrength);\n\t// horizontal //\n\tcolor_crt = mix(color_crt, mix(color,\n\t\t\t\tcolor - mix(vec3(0, maskLuma * rgbMaskSep * 0.5f, maskLuma * rgbMaskSep),\n\t\t\t\t\t\tmix(vec3(maskLuma * rgbMaskSep * 0.5f, 0, maskLuma * rgbMaskSep * 0.5f),\n\t\t\t\t\t\t\tvec3(maskLuma * rgbMaskSep, maskLuma * rgbMaskSep * 0.5f, 0),\n\t\t\t\t\t\t\tmodulo.y * 0.5f),\n\t\t\t\t\t\tmodulo.y * 0.5f),\n\t\t\t\t\tmaskStrength), 0.5f);\n\n\t// apply adaptive scanlines with color bleeding them\n\t//color_crt = mix(color_crt, color_crt * hardScan, modulo.y * (hardScan / scanPix));\n\n\t// bleed into adjacent pixels\n\tcolor_crt = mix(color_crt, max(color, bleed(colorBleedTex, color, uv, 1.0f/R, bleedStr)), bleedStr);\n\n\treturn color_crt;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// http://bit.ly/supersinfulsilicon\n\n// shader by Jason Tully is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/3ljczy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// Fork of \"Simple Voxel Cone Tracing\" by jojendersie. https://shadertoy.com/view/tdlBDs\n// 2020-08-28 17:57:18\n\n#define DISTANCE 1.0f\n#define SPEED 0.5f\n#define tT (0.5f * fract(iTime*0.25f))\n#define DITHER 17.0f\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float LIGHT_RADIUS = 0.005;\n    const float DENSITY_SCALE = 5.0;\n    const float BRIGHTNESS = 1.0;\n    const float START_OFFSET = 0.0025; // Should be smaller than light size\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / float(iResolution.y);\n    \n    uv = uv * 2.0f - 1.0f;\n\n    float sT = sin(iTime);\n    vec3 center = DISTANCE*(abs(sT*SPEED) + 0.5f) * vec3(uv - vec2(cos(iTime),sT) * SPEED - 0.5f, sT*tT*1.25f);\n    \n    if (dot(center, center) < LIGHT_RADIUS * LIGHT_RADIUS * LIGHT_RADIUS) {\n        fragColor = vec4(BRIGHTNESS, BRIGHTNESS, 0.0, 1.0);\n        return;\n    }\n    \n    vec3 start = vec3(uv, tT); \n    vec3 tracingDir = -normalize(center);\n    float dist = length(center);\n    float coneTan = LIGHT_RADIUS / dist;\n    \n    float transmittance = 1.0;\n    float t = texture(iChannel1, tracingDir.xy).x * START_OFFSET + START_OFFSET;\n    float st = START_OFFSET;\n    vec3 currentPos = start + tracingDir * t;\n    while (t < dist) {\n        float level = log(st * dot(vec3(iChannelResolution[0].xyz), tracingDir) + 1.0);\n        float visibility = textureLod(iChannel0, currentPos, level).x;\n        transmittance *= exp(-st * (1.0 - visibility) * DENSITY_SCALE);\n        \n        st = t * coneTan * 0.5;\n        t += st;\n        currentPos = start + tracingDir * t;\n    }\n    \n    float color = transmittance * BRIGHTNESS;\n    //color += pow(coneTan, transmittance);\n    \n    float bn = textureLod(iChannel1, uv, 0.0f).r;\n    \n    color = mix(color - bn / DITHER, color + bn / DITHER, transmittance);\n    \n    float diff = step(0.1, color);\n    \n    diff = abs(diff - color);\n    \n    float nott = 1.0f - diff;\n    \n    color = diff;\n    \n    vec3 final = viridis(color);\n    \n    float shade = 20.0f * transmittance * transmittance;\n    \n    final = final * diff + nott * transmittance * 2.0f;\n        \n    float luma = dot(final, LUMA) * nott;\n    \n    // Output to screen\n    fragColor = vec4(clamp(luma, 0.0f, 1.0f));\n}\n","name":"Buf A","description":"","type":"buffer"}]}