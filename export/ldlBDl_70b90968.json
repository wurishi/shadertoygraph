{"ver":"0.1","info":{"id":"ldlBDl","date":"1498907273","viewed":610,"name":"Yet Another Torus","username":"jTobergte","description":"Basically, this is a quick conversion of a torus, I used for the 'Yet Another 4KB Intro' on ATARI ST - released at Outline 2012.","likes":12,"published":1,"flags":64,"usePreview":0,"tags":["oldschool","dots"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dlXRX","filepath":"https://soundcloud.com/j-tobergte/floating","previewfilepath":"https://soundcloud.com/j-tobergte/floating","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---------------------------------------------------------------------\n//\tYet Another Torus\n//\tby Joerg Tobergte (mr.coke)\n//\n//\tMy first released Shadertoy :D\n//\tBasically, this is a quick conversion of\n//\ta torus, I used for the 'Yet Another 4KB Intro'\n//\ton the ATARI ST - releaed at Outline 2012\n//\n//\tThanks to Tetane for https://www.shadertoy.com/view/ldtGDn\n//\t..this was _very_ helpful to me!\n//---------------------------------------------------------------------\n\n//---------------------------------------------------------------------\n//\tUsing less dots due to better performance.\n//---------------------------------------------------------------------\n#define pi 3.14159\n#define pi2 6.28318\nconst float dotsnb = 720.0 * 0.125;\n\nvec3 hsv2rgb (vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (pi2 * (hsv.x + vec3(0.0, 0.666, 0.333))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx * 0.5;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 0.002;\t\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset\n    float stepp = 1.0 / dotsnb;\n    float hue = 0.0;\n        \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\n        hue += stepp;\n        float mANGLE = pi2*hue;\n        float SX = mANGLE * 26.0;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );\n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n        \n        // Better 3D to 2D conversion by Bastian Schick\n        float DZ = CAMZ / ( CAMZ + pos3D.z ) * 0.185;\n        pos2D = vec2( pos3D.x, pos3D.y );\n        pos2D *= DZ;\n        \n        // Better distance code by Bastian Schick\n        pos2D += scrs;\n        float dx = abs( uv.x - pos2D.x );\n        float dy = abs( uv.y - pos2D.y );\n        float dist = 0.3 * ( dx + dy ) + 0.4 * max( dx, dy );\n                \n\t\tcol += hsv2rgb( vec3( hue, dist / intensity, intensity / ( dist * 2.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n/*\n//---------------------------------------------------------------------\n//\t3rd Optimization - Got some help! Thanks to Bastian Schick\n//---------------------------------------------------------------------\n#define pi 3.14159\n#define pi2 6.28318\nconst float dotsnb = 720.0;\n\nvec3 hsv2rgb (vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (pi2 * (hsv.x + vec3(0.0, 0.666, 0.333))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx * 0.5;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 0.002;\t\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset\n    float stepp = 1.0 / dotsnb;\n    float hue = 0.0;\n        \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\n        hue += stepp;\n        float mANGLE = pi2*hue;\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );\n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n        \n        // Better 3D to 2D conversion by Bastian Schick\n        float DZ = CAMZ / ( CAMZ + pos3D.z ) * 0.185;\n        pos2D = vec2( pos3D.x, pos3D.y );\n        pos2D *= DZ;\n        \n        // Better distance code by Bastian Schick\n        pos2D += scrs;\n        float dx = abs( uv.x - pos2D.x );\n        float dy = abs( uv.y - pos2D.y );\n        float dist = 0.3 * ( dx + dy ) + 0.4 * max( dx, dy );\n                \n\t\tcol += hsv2rgb( vec3( hue, dist / intensity, intensity / ( dist * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n/*\n//---------------------------------------------------------------------\n//\t2nd Optimization - Lost a lot divisions & multiplies! :D\n//\t\t\t\t\t   Edit: Looking for a better way to convert a\n//\t\t\t\t\t\t\t vec3 pos into a vec2 pos\n//\t\t\t\t\t\t\t PLZ - contact me, or write a comment!\n//---------------------------------------------------------------------\n#define pi 3.14159\n#define pi2 6.28318\nconst float dotsnb = 720.0;\n\nvec3 hsv2rgb (vec3 hsv) {\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (pi2 * (hsv.x + vec3(0.0, 0.666, 0.333))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 0.002;\t\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset    \n    \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\n        float hue = i/dotsnb;\n        float mANGLE = pi2*hue;\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );\n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n                \n        float DZ = CAMZ + pos3D.z;\n        pos2D = vec2( CAMZ*pos3D.x/DZ, CAMZ*pos3D.y/DZ );\n        pos2D *= 0.185;\n        \n        float dist = distance( uv, scrs * 0.5 + pos2D );\n\t\tcol += hsv2rgb( vec3( hue, dist / intensity, intensity / ( dist * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n/*\n//---------------------------------------------------------------------\n//\t1st Optimization - Got rid of sqrt & atan!! :D\n//---------------------------------------------------------------------\n#define pi 3.14159\nconst float dotsnb = 720.0*4.0; // Number of dots\n\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec3 pos3D = vec3(0.0);\t\t\t// 3D Position \n    vec2 pos2D = vec2(0.0); \t\t// 2D Position\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 1.0/500.0;\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset    \n    \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\t\t\n        float hue = i/dotsnb;\n        float mANGLE = 2.0*pi*hue;\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n\n        pos3D = vec3( sin(SX)*SY, cos(mANGLE)*0.35, cos(SX)*SY );        \n        pos3D.y += sin( iTime ) * 0.5;\n        \n        float t=iTime*0.5, S=sin(t),C=cos(t);\n        pos3D *= mat3( C,0,S, 0,1,0, -S,0,C );\n                \n        float DZ = CAMZ + pos3D.z;\n        pos2D = vec2( CAMZ*pos3D.x/DZ*0.185, CAMZ*pos3D.y/DZ*0.185 );\n        \n        vec2 shift = scrs / 2.0 + pos2D;\n\t\tcol += hsv2rgb( vec3( hue,\n                        distance( uv,shift ) * ( 1.0 / intensity ),\n                        intensity / ( distance( uv, shift ) * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/\n\n\n/*\n//---------------------------------------------------------------------\n//\tFirst Version\n//---------------------------------------------------------------------\nvec3 hsv2rgb (vec3 hsv) { // from HSV to RGB color vector\n\thsv.yz = clamp (hsv.yz, 0.0, 1.0);\n\treturn hsv.z * (1.0 + 0.63 * hsv.y * (cos (2.0 * 3.14159 * (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0))) - 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 scrs = iResolution.xy/mx;\n\tvec2 uv = vec2(fragCoord.x, iResolution.y-fragCoord.y)/mx;\n\t\n    vec2 pos  = vec2(0.0); \t\t\t// Position of the dots\n\tvec3 col = vec3(0.0); \t\t\t// Color of the dots\n\tfloat intensity = 1.0/500.0;\t// Light intensity\t\n    float CAMZ = 1.44;\t\t\t\t// Camera offset\n    \n\tfor( float i=0.0; i<dotsnb; i++ ) {\n\t\t\n\t\tfloat mANGLE = 2.0*pi*i/dotsnb;\n\n        float SX = mANGLE * 51.50;\n        float SY = 1.0 + sin( mANGLE ) * 0.25;\n        float SZ = cos( mANGLE ) * 0.35;\n                        \n        float X = sin( SX ) * SY;\n        float Y = SZ;\n        float Z = cos( SX ) * SY;\n\n        Y += sin( iTime ) * 0.5;\t// add Y-swing\n                \n        float RLEN = sqrt( Z*Z + X*X );\n        float WTST = atan( X, Z );\n        X = sin( WTST + iTime * 0.5 ) * RLEN;\n        Z = cos( WTST + iTime * 0.5 ) * RLEN;\n        \n        float DZ = CAMZ + Z;\n        float XX = CAMZ * X / DZ * 0.185;\n        float YY = CAMZ * Y / DZ * 0.185;\n        \n        pos = vec2( XX, YY );\n\n        float hue = 0.8;\t\t\t\t// classic colors\n        //float hue = i / dotsnb;\t\t// more colorful version\n        \n\t\tcol += hsv2rgb( vec3( hue,\n                        distance( uv,scrs / 2.0 + pos ) * ( 1.0 / intensity ),\n                        intensity / ( distance( uv, scrs / 2.0 + pos ) * 12.0 ) ) );\n\t}\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n/**/","name":"Image","description":"","type":"image"}]}