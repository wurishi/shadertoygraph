{"ver":"0.1","info":{"id":"XdcyRX","date":"1519638768","viewed":658,"name":"Hyperspace explosion","username":"BenWheatley","description":"Perlin noise based explosion; each pulse is slightly different","likes":23,"published":1,"flags":0,"usePreview":0,"tags":["procedural","perlinnoise","explosion","scifi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * \"Hyperspace explosion\" by Ben Wheatley - 2018\n * License MIT License\n * Contact: github.com/BenWheatley\n */\n\n// constants\nconst int MIN_OCTAVE = 3;\nconst int MAX_OCTAVE = 8;\nconst float PI = 3.14159265359;\nconst float centerToCorner = sqrt((0.5*0.5) + (0.5*0.5));\nconst float tangentScale = PI / (2.0*centerToCorner);\nconst float thetaToPerlinScale = 2.0 / PI;\n\nfloat cosineInterpolate(float a, float b, float x) {\n\tfloat ft = x * PI;\n\tfloat f = (1.0 - cos(ft)) * 0.5;\n\t\n\treturn a*(1.0-f) + b*f;\n}\n\nfloat seededRandom(float seed) {\n    int x = int(seed);\n    x = x << 13 ^ x;\n    x = (x * (x * x * 15731 + 789221) + 1376312589);\n    x = x & 0x7fffffff;\n    return float(x)/1073741824.0;\n}\n\n// The magic constants are essentially arbitary:\n// they define the scale of the largest component of the Perlin noise\nfloat perlinNoise(float perlinTheta, float r, float time) {\n    float sum = 0.0;\n    for (int octave=MIN_OCTAVE; octave<MAX_OCTAVE; ++octave) {\n        float sf = pow(2.0, float(octave));\n        float sf8 = sf*64.0; // I can't remember where this variable name came from\n        \n\t\tfloat new_theta = sf*perlinTheta;\n        float new_r = sf*r + time; // Add current time to this to get an animated effect\n\t\t\n        float new_theta_floor = floor(new_theta);\n\t\tfloat new_r_floor = floor(new_r);\n\t\tfloat fraction_r = new_r - new_r_floor;\n\t\tfloat fraction_theta = new_theta - new_theta_floor;\n        \n        float t1 = seededRandom( new_theta_floor\t+\tsf8 *  new_r_floor      );\n\t\tfloat t2 = seededRandom( new_theta_floor\t+\tsf8 * (new_r_floor+1.0) );\n        \n        new_theta_floor += 1.0;\n        float maxVal = sf*2.0;\n        if (new_theta_floor >= maxVal) {\n            new_theta_floor -= maxVal; // So that interpolation with angle 0-360° doesn't do weird things with angles > 360°\n        }\n        \n        float t3 = seededRandom( new_theta_floor\t+\tsf8 *  new_r_floor      );\n\t\tfloat t4 = seededRandom( new_theta_floor\t+\tsf8 * (new_r_floor+1.0) );\n        \n\t\tfloat i1 = cosineInterpolate(t1, t2, fraction_r);\n\t\tfloat i2 = cosineInterpolate(t3, t4, fraction_r);\n        \n        sum += cosineInterpolate(i1, i2, fraction_theta)/sf;\n    }\n    return sum;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float dx = 0.5 - uv.x;\n    float dy = 0.5 - uv.y;\n    dy *= iResolution.y / iResolution.x;\n    \n    float perlinTheta = (PI+atan(dy, -dx))/PI;\n    float r = sqrt((dx*dx) + (dy*dy));\n    r = centerToCorner - r;\n    \n    float perlin = perlinNoise(perlinTheta, r, iTime);\n    \n    float timeMod = mod(-iTime, 1.5);\n    float scale = 2.0*(timeMod-r);\n    float glowRing = cos(pow(1.0-scale, 0.1));\n    glowRing -= 0.5;\n    glowRing *= 2.0;\n    if (scale>1.0) {\n        scale = 0.0;\n    }\n    float c = scale*perlin*2.0;\n    \n    fragColor = vec4(glowRing+c, glowRing, glowRing*0.5+(c*2.0), 0);\n}","name":"Image","description":"","type":"image"}]}