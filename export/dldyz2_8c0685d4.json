{"ver":"0.1","info":{"id":"dldyz2","date":"1699450567","viewed":167,"name":"LiveCoding@AirPort AnimeFes 2023","username":"gam0022","description":"GLSL Live Coding at the 10th New Chitose Airport International Animation Film Festival.\n\nhttps://airport-anifes.jp/programs/live_demoscene/\nhttps://twitter.com/gam0022/status/1721024192278409556","likes":11,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","fractal","ifs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ldc3z2","filepath":"https://soundcloud.com/niko_14/gw3-arc-1","previewfilepath":"https://soundcloud.com/niko_14/gw3-arc-1","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Original Bonzomatic Shader\n// https://gist.github.com/gam0022/362ed76ec245c2f418e8450b612dd7b0\n\n#define time iTime\n#define PI acos(-1.)\n#define TAU (2. * PI)\n#define saturate(x) clamp(x, 0., 1.)\n#define VOL 0.0\n#define SOL 1.0\n#define phase(x) (floor(x) + .5 + .5 * cos(TAU * .5 * exp(-5. * fract(x))))\n\nfloat beat, beatTau, beatPhase;\nvec3 pos, light;\n\nvec4 map(vec3 p);\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.)) + min(0., max(q.x, max(q.y, q.z)));\n}\n\nvoid U(inout vec4 m, float d, float a, float b, float c) {\n  if (d < m.x) m = vec4(d, a, b, c);\n}\n\nvoid rot(inout vec2 p, float a) { p *= mat2(cos(a), sin(a), -sin(a), cos(a)); }\n\nvoid pmod(inout vec2 p, float s) {\n  float n = TAU / s;\n  float a = PI / s - atan(p.x, p.y);\n  a = floor(a / n) * n;\n  rot(p, a);\n}\n\nfloat fft(float d) { return texture(iChannel0, vec2(fract(d), 0)).r; }\n\nfloat minRadius2 = 0.5;\nfloat fixedRadius2 = 1.0;\nfloat foldingLimit = 1.0;\n\nvoid sphereFold(inout vec3 z, inout float dz) {\n  float r2 = dot(z, z);\n  if (r2 < minRadius2) {\n    float temp = (fixedRadius2 / minRadius2);\n    z *= temp;\n    dz *= temp;\n  } else if (r2 < fixedRadius2) {\n    float temp = fixedRadius2 / r2;\n    z *= temp;\n    dz *= temp;\n  }\n}\n\nvoid boxFold(inout vec3 z, inout float dz) { z = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z; }\n\nvec3 normal(vec3 p) {\n  vec2 e = vec2(0, .0005);\n  return normalize(map(p).x - vec3(map(p - e.yxx).x, map(p - e.xyx).x, map(p - e.xxy).x));\n}\n\n\nvec3 pal(float h) {\n  vec3 col = vec3(0.5) + 0.5 * cos(TAU * (vec3(0.0, 0.33, 0.67) + h));\n  return mix(col, vec3(1), 0.1 * floor(h));\n}\n\n#define FLT_EPS 5.960464478e-8\nfloat roughnessToExponent(float roughness) {\n  return clamp(2.0 * (1.0 / (roughness * roughness)) - 2.0, FLT_EPS, 1.0 / FLT_EPS);\n}\n\nvec3 evalLight(vec3 p, vec3 normal, vec3 view, vec3 baseColor, float metallic, float roughness) {\n  vec3 ref = mix(vec3(0.04), baseColor, metallic);\n  vec3 h = normalize(light + view);\n  vec3 diffuse = mix(1.0 - ref, vec3(0.0), metallic) * baseColor / PI;\n  float m = roughnessToExponent(roughness);\n  vec3 specular = ref * pow(max(0.0, dot(normal, h)), m) * (m + 2.0) / (8.0 * PI);\n  return (diffuse + specular) * max(0.0, dot(light, normal));\n}\n\nvec4 dMenger(vec3 z0, vec3 offset, float scale, int iteration) {\n  vec4 z = vec4(z0, 1.0);\n  for (int n = 0; n < iteration; n++) {\n    z = abs(z);\n\n    if (z.x < z.y) z.xy = z.yx;\n    if (z.x < z.z) z.xz = z.zx;\n    if (z.y < z.z) z.yz = z.zy;\n\n    z *= scale;\n    z.xyz -= offset * (scale - 1.0);\n\n    if (z.z < -0.5 * offset.z * (scale - 1.0)) {\n      z.z += offset.z * (scale - 1.0);\n    }\n  }\n\n  float d1 = sdBox(z.zxy, vec3(1)) / z.w;\n  float d2 = sdBox(z.zxy, vec3(0.1, 1.2, 0.8)) / z.w;\n  vec4 m = vec4(d1, SOL, 1, 10);\n  float hue = 2. + fract(pos.z * 2. + length(pos.xy) * 0.2);\n  U(m, d2, VOL, saturate(cos(pos.z / 4. * TAU + beatTau / 2.)), hue);\n  return m;\n}\n\nfloat dMandel(vec3 z, float scale, int n) {\n  vec3 offset = z;\n  float dr = 1.0;\n  for (int i = 0; i < n; i++) {\n    boxFold(z, dr);\n    sphereFold(z, dr);\n    z = scale * z + offset;\n    dr = dr * abs(scale) + 1.0;\n  }\n  float r = length(z);\n  return r / abs(dr);\n}\n\nvec4 map(vec3 p) {\n  pos = p;\n  vec4 m = vec4(1, 1, 1, 1);\n  float a = 3.3;\n\n  if (beat < 16.) {\n    a = 10.;\n    p = pos;\n    rot(p.xz, beatTau / 32.);\n    rot(p.xy, beatTau / 64.);\n    p -= 0.5 * a;\n    p = mod(p, a) - 0.5 * a;\n    return vec4(dMandel(p, -3.3 + 1.5 * fft(0.2), 10), SOL, 8., 5. + fract(length(p)));\n  } else if (beat < 16. * 2.) {\n    a = 20.;\n    p = pos;\n    rot(p.xz, beatTau / 32.);\n    p -= 0.5 * a;\n    p = mod(p, a) - 0.5 * a;\n    return vec4(dMandel(p, 2.78 + 1.5 * fft(0.2), 10), SOL, 8., 4.7);\n  } else if (beat < 16. * 3.) {\n    a = 4.;\n    p = pos;\n    p -= 0.5 * a;\n    p = mod(p, a) - 0.5 * a;\n    pmod(p.xy, 8.);\n    return dMenger(p, vec3(1.5, 2.2, 0.7 + 2.5 * (0.5 + 0.5 * cos(beatTau / 16.))), 2.2, 4);\n  }\n\n  p = mod(pos, a) - 0.5 * a;\n  float s = 1.;\n  for (int i = 0; i < 4; i++) {\n    p = abs(p) - 0.5;\n    rot(p.xy, -0.5);\n    p = abs(p) - 0.4;\n    rot(p.yz, -0.1);\n\n    float b = 1.4;\n    p *= b;\n    s *= b;\n  }\n\n  U(m, sdBox(p, vec3(0.5, 0.05, 0.05)) / s, SOL, 1., 10.);\n  U(m, sdBox(p, vec3(0.1 + 0.5 * cos(beatTau / 8.), 0.06, 0.05)) / s, VOL, 0.1, 1.9);\n  U(m, sdBox(p, vec3(0.2, 0.1, 0.1)) / s, VOL, saturate(cos(beatTau / 2. + TAU * pos.z / 8.)), 5.5);\n\n  return m;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0);\n  float t = 0.;\n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + rd * t;\n    vec4 m = map(p);\n    float d = m.x;\n\n    if (m.y == SOL) {\n      t += d;\n      if (d < t * 0.001) {\n        vec3 n = normal(p);\n        float diffuse = saturate(dot(n, light));\n        col += evalLight(p, n, -rd, vec3(1), 0.7, 0.5) * pal(m.w) * m.z;\n        t += d;\n        break;\n      }\n    } else {\n      t += abs(d) * 0.5 + 0.01;\n      col += saturate(0.001 * pal(m.w) * m.z / abs(d));\n    }\n  }\n  col = mix(vec3(0), col, exp(-0.01 * t));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  beat = time * 140. / 60.;\n  beat = mod(beat, 16. * 4.);\n  beatTau = beat * TAU;\n  beatPhase = phase(beat / 2.);\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 ro = vec3(0, 0, 0.5 * time);\n  if (beat < 16.)\n    ro = vec3(0, 0, -8);\n  else if (beat < 16. * 2.)\n    ro = vec3(0, 0, -15);\n\n  vec3 rd = vec3(uv, 1.1);\n  rd = normalize(rd);\n  light = normalize(vec3(1, 1, -1));\n  vec3 col = render(ro, rd);\n  // col += texture(texSessions, saturate(vec2(0.5 + uv.x, 0.5 - uv.y * 2))).rgb * 100 * fft(0.2);\n  fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}