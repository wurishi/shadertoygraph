{"ver":"0.1","info":{"id":"MtSGWm","date":"1429460020","viewed":436,"name":"Cheap-ish clouds","username":"Daedelus","description":"Trying to do some basic clouds to fill up any future skies...\nMouse enabled!\n\nInspired by this awesome picture:\nhttps://www.shadertoy.com/view/XdBSWd","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["cloudsnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define APPROXIMATE_NORMAL\n\n// cloud layer thickness, upscale for softer clouds\n#define CLOUD_SPREAD 0.002\n// increase as thickness increases to avoid visible stepping\n#define CLOUD_STEPS 6.0\n// noise tiling scale, decrease for larger cloud areas\n#define CLOUD_STRETCH 0.0045\n// add value to make scene overall scene more hazy / cloudy\n#define CLOUD_BIAS -0.1\n// additional fuzz\n#define PERLIN 0.05\n    \n\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n\t\n    float n = p.x + p.y*157.0;\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\nconst mat2 brownian_transform = mat2(0.8, 0.6, -0.6, 0.8);\nfloat brownian(in vec2 x)\n{\n    float o = noise(x);\n    x *= 2.0;\n    x *= brownian_transform;\n    o += noise(x) * 0.5;\n    x *= 2.0;\n    x *= brownian_transform;\n    o += noise(x) * 0.25;\n    x *= 2.0;\n    x *= brownian_transform;\n    o += noise(x) * 0.125;\n    return o / 1.875;\n}\n\nfloat Perlin(vec2 p)\n{\n    float perlin = noise(p) * 0.5;\n    perlin += noise(p * 2.0) * 0.25;\n    perlin += noise(p * 4.0) * 0.125;\n    perlin += noise(p * 8.0) * 0.0625;\n    return perlin;\n}\n\nvoid Rotate(inout vec2 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    p *= mat2(ca, -sa, sa, ca);\n}\n\n\nfloat Clouds(vec3 dir, out float dist)\n{\n    const float sky_height = 90.0;\n    dist = -sky_height / dir.y;\n    vec3 clouds_intersection = dir * dist;\n    \n    float tw = 0.0;\n    float clouds = 0.0;\n    const float s = 1.0 / CLOUD_STEPS;\n    for(float i = 0.0 ; i < 1.0 ; i += s)\n    {\n    \tclouds += brownian(clouds_intersection.xz * (CLOUD_STRETCH + CLOUD_SPREAD * i)) * (1.0 - i);\n        tw += 1.0 - i;\n    }\n    clouds /= tw;\n    \n    #ifdef PERLIN\n    float perlin = Perlin(clouds_intersection.xz * 0.1);\n    clouds = clouds - perlin * PERLIN;\n    #endif\n    \n    clouds = max(0.0, pow(clouds - 0.2, 2.0) * 6.0 + CLOUD_BIAS);\n    return clouds;\n}\n\n\nvec3 Ray(vec2 uv)\n{\n    vec3 dir = normalize(vec3(uv, 2.5));\n    Rotate(dir.yz, iMouse.y * -0.004);\n    Rotate(dir.xz, iMouse.x * -0.008);\n    return dir;\n}\n\n\nvec3 Sky(vec3 dir)\n{\n    vec3 sun_direction = normalize(vec3(-1.0, -0.4, -1.0));\n    \n    \n    vec3 cl = vec3(0.4, 0.6, 0.8);\n    // add gradient to atmosphere\n    cl = mix(vec3(0.8, 0.9, 1.0), cl, pow(dir.y, 0.45));\n    // add sun to atmosphere\n    float sun = pow(max(0.0, dot(dir, -sun_direction)), 600.0);\n    cl = mix(cl, vec3(2.5, 1.8, 0.6), sun);\n    \n    \n    // compute cloud layers\n    float p;\n    float clouds = Clouds(dir, p);\n    \n    #ifdef APPROXIMATE_NORMAL\n    \n    float dt = 0.025;\n    \n    vec3 right = cross(vec3(0.0, 1.0, 0.0), dir);\n    vec3 up = cross(right, dir);\n    \n    float clouds_right = Clouds(normalize(dir + right * dt), p);\n    float clouds_above = Clouds(normalize(dir - up * dt), p);\n    \n    vec2 n = vec2(clouds_right - clouds, clouds - clouds_above) * 2.0;\n    vec3 normal = normalize(n.x * right + n.y * up + dir);\n    \n    // lighting\n    float o = dot(normal, sun_direction) * 0.6 + 0.3;\n    #else\n    float o = dot(dir, sun_direction) * 0.6 + 0.3;\n    #endif\n    o = mix(1.0, o, clamp(clouds * 0.125, 0.0, 1.0));\n    \n    // add clouds to atmosphere\n    cl = mix(cl, vec3(o, o, o), clamp(clouds, 0.0, 1.0));\n    \n    return cl;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 dir = Ray(uv);\n    float d = 2.0 / dir.y;\n    \n    \n    vec3 sun_direction = normalize(vec3(-1.0, -0.4, -1.0));\n    \n    vec3 cl = Sky(dir);\n    \n    // render floor, fog\n    if(dir.y < 0.0) { cl = vec3(0.4, 0.3, 0.1); }\n    float p;\n    Clouds(dir, p);\n    d = -min(d, p);\n    cl = mix(cl, vec3(0.8, 0.9, 1.0), pow(1.0 - abs(dir.y), 30.0));\n\tfragColor = vec4(cl, 1.0);\n}","name":"","description":"","type":"image"}]}