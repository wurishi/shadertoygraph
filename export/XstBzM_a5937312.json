{"ver":"0.1","info":{"id":"XstBzM","date":"1524518388","viewed":5766,"name":"Broken  pathtracing","username":"romasm","description":"Art?\n\nThis is a copy of https://www.shadertoy.com/view/4scfz4 but with broken random function.","likes":83,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// By Roman Smirnov\n// License Creative Commons Attribution 4.0 International\n\nvec3 tonemapping(vec3 color, float exposure)\n{\n\tcolor *= exposure;\n    \n    float A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.10;\n\tfloat E = 0.015;\n\tfloat F = 0.40;\n\tfloat W = 11.2;\n\tcolor = ((color * (A * color + C * B) + D * E) / (color * (A * color + B) + D * F)) - E / F;\n\tfloat white = ((W * (A * W + C * B) + D * E) / (W * (A * W + B) + D * F)) - E / F;\n\tcolor /= white;\n    \n    return color;\n}\n\nvec3 LinearToSRGB(vec3 color )\n{\n\tvec3 sRGBLo = color * 12.92;\n    const float powExp = 1.0/2.4;\n\tvec3 sRGBHi = ( pow( abs ( color ), vec3(powExp, powExp, powExp)) * 1.055) - 0.055;\n\tvec3 sRGB;\n    sRGB.x = ( color.x <= 0.0031308) ? sRGBLo.x : sRGBHi.x;\n    sRGB.y = ( color.y <= 0.0031308) ? sRGBLo.y : sRGBHi.y;\n    sRGB.z = ( color.z <= 0.0031308) ? sRGBLo.z : sRGBHi.z;\n\treturn sRGB;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{    \n    const float exposure = 2.0;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = tonemapping(texture(iChannel0, uv).xyz, exposure);\n    \n\tfragColor = vec4(LinearToSRGB(color), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// By Roman Smirnov\n// License Creative Commons Attribution 4.0 International\n\n#define RAND_PERIOD_SCALE 78.233\n#define RAND_SEED_SCALE 3758.5453\n\n#define PI 3.14159265359\n#define PI_2 2.0 * PI\n#define INV_PI 1.0 / PI\n#define MAX_RAY_DISTANCE 999.9\n#define EPSILON 0.00001\n\n#define EDGE_SIZE 0.0025\n#define BOUNCES 8\n#define NO_SPEC_ORDER 3\n#define ITERATIONS 6\n\n#define CHECKER_FADE 0.5\n#define DIELECTRIC_SPEC vec3(0.04,0.04,0.04)\n#define MIN_ROUGHNESS 0.001\n\nstruct Ray\n{\n\tvec3 pos;\n\tvec3 dir;\n    int order;\n    vec3 medium;\n\tfloat ior;\n};\n\nstruct Camera\n{\n\tvec3 pos;\n\tvec3 dir;\n\t\n    vec3 orbitPoint;\n    float orbitDist;\n    \n\tfloat focusDist;\n\tfloat fstop;\n\tfloat focalLength;\n\tfloat sensorSize;\n\t\n\tfloat aspect;\n};\n\n#define MAT_COMMON 0\n#define MAT_EMISSIVE 1\n#define MAT_REFRACT 2\n#define MAT_CHECKER 3\nstruct Material\n{\n\tvec3 albedo;\n\tfloat roughness;\n\tvec3 specular;\n\tfloat ior;\n\t\n\tint type;\n};\n\nstruct HitInfo\n{\n\tfloat t;\n\tvec3 pos;\n\tvec3 normal;\n\tMaterial mat;\n};\n\nstruct Sphere\n{\n\tvec3 pos;\n\tfloat radius;\n\t\n\tMaterial mat;\n};\n\nstruct Box\n{\n\tvec3 pos;\n\tvec3 ext;\n\t\n\tMaterial mat;\n};\n\n#define SCENE_SPHERE_COUNT 12\nSphere sceneSpheres[SCENE_SPHERE_COUNT];\n#define SCENE_BOX_COUNT 14\nBox sceneBoxes[SCENE_BOX_COUNT];\n\nCamera CreateScene()\n{    \n    Camera cam;\n\tcam.sensorSize = 0.024;\n\tcam.focalLength = 0.035;\n\tcam.fstop = 3.5;\n\tcam.focusDist = 7.0;\n    \n    cam.orbitPoint = vec3(0.0, 2.0, 0.0);\n    cam.orbitDist = 4.3;\n    \n\tsceneSpheres[0] = Sphere(vec3(0,0,0), 15.0, Material(vec3(10.0,13.0,16.0), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));\n\tsceneSpheres[1] = Sphere(vec3(3.0,0.8,-3.0), 0.8, Material(vec3(0.0,0.0,0.0), 0.3, vec3(1.0,0.7655,0.336), 1.0, MAT_COMMON));\n\tsceneSpheres[2] = Sphere(vec3(4,1.0,-4), 1.0, Material(vec3(0.99,0.01,0.01), 0.5, DIELECTRIC_SPEC, 1.0, MAT_COMMON));    \n    sceneSpheres[3] = Sphere(vec3(1.5,1.0,1.0), 1.0, Material(vec3(0.8,0.99,0.95), 0.2, DIELECTRIC_SPEC, 1.33, MAT_REFRACT));    \n\tsceneSpheres[4] = Sphere(vec3(-4,0.5,1), 0.5, Material(vec3(70,15,6), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));\t\n    sceneSpheres[5] = Sphere(vec3(4,0.8,-2), 0.8, Material(vec3(0.9,0.3,0.7), 0.9, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n\tsceneSpheres[6] = Sphere(vec3(4,0.7,0), 0.7, Material(vec3(0.99,0.1,0.01), 0.4, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n\tsceneSpheres[7] = Sphere(vec3(-4,0.8,-1.4), 0.8, Material(vec3(0.1,0.99,0.01), 0.8, DIELECTRIC_SPEC, 1.0, MAT_COMMON));    \n    sceneSpheres[8] = Sphere(vec3(-3.5,1,-3), 1.0, Material(vec3(0.1,0.1,1.0), 0.3, DIELECTRIC_SPEC, 1.2, MAT_REFRACT));\t\n    sceneSpheres[9] = Sphere(vec3(2.5,0.6,-4.2), 0.6, Material(vec3(0.0,0.0,0.0), 0.4, vec3(0.6724,0.6373,0.5855), 1.0, MAT_COMMON));\n    sceneSpheres[10] = Sphere(vec3(-3.5,1,3), 1.0, Material(vec3(1.0,0.1,0.5), 0.5, DIELECTRIC_SPEC, 1.2, MAT_REFRACT));\n    sceneSpheres[11] = Sphere(vec3(-1,0.7,-0.7), 0.7, Material(vec3(0,0,0), 0.5, vec3(1.0,0.7655,0.336), 1.0, MAT_COMMON));\n\t\n\tsceneBoxes[0] = Box(vec3(5.49,2.5,0), vec3(0.5,2.5,5), Material(vec3(0.8,0.9,0.1), 0.9, DIELECTRIC_SPEC, 1.0, MAT_CHECKER));\n    sceneBoxes[1] = Box(vec3(-5.49,2.5,0), vec3(0.5,2.5,5), Material(vec3(0.9,0.1,0.4), 0.9, DIELECTRIC_SPEC, 1.0, MAT_CHECKER));\n    sceneBoxes[2] = Box(vec3(0,2.5,5.5), vec3(5,2.5,0.5), Material(vec3(0.1,0.9,0.4), 0.4, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n    sceneBoxes[3] = Box(vec3(0,2.5,-5.5), vec3(5,2.5,0.5), Material(vec3(0.1,0.4,0.9), 0.4, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n    sceneBoxes[4] = Box(vec3(0,-0.49,0), vec3(5,0.5,5), Material(vec3(0.7,0.7,0.7), 0.3, DIELECTRIC_SPEC, 1.0, MAT_CHECKER));\n    sceneBoxes[5] = Box(vec3(2.5,5.5,0), vec3(4.0,0.5,5), Material(vec3(0.8,0.8,0.8), 0.9, DIELECTRIC_SPEC, 1.0, MAT_COMMON));    \n    sceneBoxes[6] = Box(vec3(4.5,2.5,0), vec3(0.2,0.2,2.2), Material(vec3(100,50,35), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));\n    sceneBoxes[7] = Box(vec3(4.0,1.0,1.5), vec3(0.5,1.0,0.5), Material(vec3(1.0,0.2,0.01), 0.35, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n    sceneBoxes[8] = Box(vec3(3.0,2.0,3.5), vec3(0.5,2.0,0.5), Material(vec3(0.2,0.02,1.0), 0.6, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n    sceneBoxes[9] = Box(vec3(-4,2.0,4.8), vec3(0.2,1.0,0.2), Material(vec3(10,10,50), 1.0, DIELECTRIC_SPEC, 1.0, MAT_EMISSIVE));\n    sceneBoxes[10] = Box(vec3(-3,2.0,-4.5), vec3(0.8,2.0,0.3), Material(vec3(0,0,0), 0.35, vec3(0.913, 0.921, 0.925), 1.0, MAT_COMMON));\n\tsceneBoxes[11] = Box(vec3(0,0.7,-4), vec3(0.8,0.7,0.5), Material(vec3(0,0,0), 0.5, vec3(0.955, 0.637, 0.538), 1.0, MAT_COMMON));\t\n    sceneBoxes[12] = Box(vec3(-1.3,2.5,-1.5), vec3(0.1,2.5,0.1), Material(vec3(0.5,1.0,0.2), 0.7, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n    sceneBoxes[13] = Box(vec3(-1.3,2.5,1.5), vec3(0.1,2.5,0.1), Material(vec3(1.0,0.6,0.2), 0.7, DIELECTRIC_SPEC, 1.0, MAT_COMMON));\n    \n    return cam;\n}\n\nfloat seed = 0.0;\n\nvec2 fragUV = vec2(0.0);\nvec2 pixelSize = vec2(0.0);\n\nfloat Rand() \n{\n\tfloat r = fract(sin(seed) * RAND_SEED_SCALE);\n\tseed += 43758.5453;\n    return r;    \n}\n\n// wrong, fixed version in: https://www.shadertoy.com/view/4scfz4 \nvec3 RandDirectionSize(vec3 normal, float size) \n{\n\tfloat theta = Rand() * PI_2;\n    float cosT = Rand() * 2.0 - 1.0;\n    float sinT = sqrt(1.0 - cosT * cosT);\n    vec3 randomUnitVector = vec3(sinT * cos(theta), sinT * sin(theta), cosT) * sqrt(Rand());\n    return normalize(normal + randomUnitVector * size);\n}\n\nvec3 RandDirection(vec3 normal) \n{\n    return RandDirectionSize(normal, 1.0 - EPSILON);\n}\n    \nvec3 PointFromRay(Ray r, float t)\n{\n\treturn r.pos + t * r.dir;\n}\n\nvec3 GetSensorPoint(Camera cam, vec2 uv)\n{        \n\tvec2 wh = vec2(cam.sensorSize * cam.aspect, cam.sensorSize);\n\tfloat z = 1.0 / ((1.0 / cam.focalLength) - (1.0 / cam.focusDist));\n\tvec2 xy = (uv - vec2(0.5, 0.5)) * wh;\n        \n\treturn vec3(-xy.x, xy.y, z);\t\n}\n\nvec3 GetAperturePoint(Camera cam)\n{\n\tfloat d = cam.focalLength / cam.fstop;\n\tfloat theta = 2.0 * PI * Rand();\n\tfloat r = sqrt(Rand()) * d * 0.5;\n\treturn vec3(r * cos(theta), r * sin(theta), 0.0);\n}\n\nRay GetRayFromCamera(Camera cam)\n{\n    const vec3 up = vec3(0,1,0);\n    \n    vec3 dirF = normalize(cam.dir);\n    vec3 dirT = -normalize(cross(dirF, up));\n    vec3 dirU = normalize(cross(dirF, dirT));\n\t\n\tvec2 jitteredUV = fragUV.xy + vec2(EDGE_SIZE, cam.aspect * EDGE_SIZE) * 2.0 * vec2(Rand() - 0.5, Rand() - 0.5);\n\t\n\tvec3 sensor = GetSensorPoint(cam, jitteredUV);\t\n\tvec3 focalPoint = normalize(sensor) * cam.focusDist;\n\t\n\tvec3 lensPoint = GetAperturePoint(cam);\n\tvec3 refractLocalRay = normalize(focalPoint - lensPoint);\n\t\n\tvec3 rayPos = cam.pos + (dirT * lensPoint.x + dirU * lensPoint.y + dirF * lensPoint.z);\n\tvec3 rayDir = normalize(dirT * refractLocalRay.x + dirU * refractLocalRay.y + dirF * refractLocalRay.z);\n\t\n    return Ray(rayPos, rayDir, 0, vec3(1,1,1), 1.0);\n}\n\nbool RayBoxIntersection(Ray r, Box b, out HitInfo hitInfo)\n{\n\tvec3 invdir = 1.0 / (r.dir * MAX_RAY_DISTANCE);\n    vec3 minC = b.pos - b.ext;\n    vec3 maxC = b.pos + b.ext;\n\t\n\tvec3 p0Int = (minC - r.pos) * invdir;\n\tvec3 p1Int = (maxC - r.pos) * invdir;\n\t\n\tvec3 closest = min(p0Int, p1Int);\n\tvec3 furthest = max(p0Int, p1Int);\n\n\tfloat minT = max(closest.x, max(closest.y, closest.z));\n\tfloat maxT = min(furthest.x, min(furthest.y, furthest.z));\n\t\t\n    if (maxT < 0.0 || minT > maxT)\n    {\n        return false;\n    }\n    \n\thitInfo.t = minT * MAX_RAY_DISTANCE;\n\thitInfo.pos = PointFromRay(r, hitInfo.t);\n\thitInfo.mat = b.mat;\n    \n    if(minT == p0Int.x)\n        hitInfo.normal = vec3(-1,0,0);     \n    else if(minT == p1Int.x)\n        hitInfo.normal = vec3(1,0,0);\n    else if(minT == p0Int.y)\n        hitInfo.normal = vec3(0,-1,0);\n    else if(minT == p1Int.y)\n        hitInfo.normal = vec3(0,1,0);\n    else if(minT == p0Int.z)\n        hitInfo.normal = vec3(0,0,-1);\n    else// if(minT == p1Int.z)\n        hitInfo.normal = vec3(0,0,1);        \n        \n\treturn true;\n}\n\nbool RaySphereIntersection(Ray r, Sphere s, out HitInfo hitInfo)\n{\n\tvec3 k = r.pos - s.pos;\n    float b = dot(k, r.dir);\n\tfloat c = dot(k, k) - s.radius * s.radius;\n\tfloat d = b * b - c;\n\t \n\tif(d < 0.0)\n\t{\n\t\treturn false;\n\t}\n\t\t\n\tfloat sqrtfd = sqrt(d);\n\n\tfloat t1 = -b + sqrtfd;\n\tfloat t2 = -b - sqrtfd;\n\n\tfloat minT = min(t1,t2);\n\tfloat maxT = max(t1,t2);\n\n\tfloat t = (minT >= 0.0) ? minT : maxT;\n\n\thitInfo.t = t;\n\thitInfo.pos = PointFromRay(r, t);\n\thitInfo.normal = (c < 0.0 ? -1.0 : 1.0) * normalize(hitInfo.pos - s.pos);\n\thitInfo.mat = s.mat;\n\t\n\treturn (t > 0.0);\n}\n\nbool RayTraceScene(Ray ray, out HitInfo hitInfo)\n{\n    hitInfo.t = MAX_RAY_DISTANCE;\n\t\n\tbool isHit = false;\n\tfor (int i = 0; i < SCENE_SPHERE_COUNT; i++) \n    {\n\t\tHitInfo tempInfo;\n\t\tif(RaySphereIntersection(ray, sceneSpheres[i], tempInfo))\n\t\t{\n\t\t\tif(hitInfo.t > tempInfo.t)\n\t\t\t{\n\t\t\t\tisHit = true;\n\t\t\t\thitInfo = tempInfo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < SCENE_BOX_COUNT; i++) \n    {\n\t\tHitInfo tempInfo;\n\t\tif(RayBoxIntersection(ray, sceneBoxes[i], tempInfo))\n\t\t{\n\t\t\tif(hitInfo.t > tempInfo.t)\n\t\t\t{\n\t\t\t\tisHit = true;\n\t\t\t\thitInfo = tempInfo;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn isHit;\n}\n\nfloat FSchlickDiffuse(float F90, float NoX )\n{ \n\treturn 1.0 + ( F90 - 1.0 ) * pow(1.0 - NoX, 5.0);\n}\n\nvec3 DiffuseBurley( vec3 albedo, float roughness, float NoV, float NoL, float VoH )\n{\n\tfloat energyBias = mix(0.0, 0.5, roughness );\n\tfloat energyFactor = mix(1.0, 1.0 / 1.51, roughness );\n\tfloat FD90 = energyBias + 2.0 * VoH * VoH * roughness;\n\tfloat FdV = FSchlickDiffuse(FD90, NoV);\n\tfloat FdL = FSchlickDiffuse(FD90, NoL);\n\treturn albedo * FdV * FdL * energyFactor * INV_PI;\n}\n\nvec3 FSchlick(vec3 specular, float VoH)\n{ \n\treturn specular + ( vec3(1,1,1) - specular ) * pow(1.0 - VoH, 5.0);\n}\n\nfloat D_GGX( float roughness, float NoH )\n{\n\tfloat a = roughness * roughness;\n    float denomn = ( NoH * a * a - NoH ) * NoH + 1.0;\n    if(denomn < EPSILON)\n    {\n        return 1.0;\n    }\n\tfloat d = a / denomn;\n\treturn INV_PI * d * d;\t\t\n}\n\nfloat G_GGX(float roughness, float NoX)\n{\n\tfloat a = roughness * roughness;\n\tfloat NoXsqr = NoX * NoX;\n\tfloat G = 2.0 / (1.0 + sqrt(1.0 + a * a * (1.0 - NoXsqr) / NoXsqr));\n\treturn G;\n}\nfloat GG_GGX(float NoL, float NoV, float roughness)\n{\n\treturn G_GGX(roughness, NoV) * G_GGX(roughness, NoL);\n}\n\nfloat IORtoR0( float IOR )\n{\n\tfloat R0 = (IOR - 1.0) / (IOR + 1.0);\n\tR0 *= R0;\n\treturn R0;\n}\n\nvec3 BRDF(Material mat, vec3 normal, vec3 view, vec3 lightDir)\n{\n\tvec3 H = normalize(view + lightDir);\n\tfloat NoV = clamp(dot(normal, view), EPSILON, 1.0);\n\tfloat NoL = clamp(dot(normal, lightDir), EPSILON, 1.0);\n\tfloat VoH = clamp(dot(view, H), EPSILON, 1.0);\n\tfloat NoH = clamp(dot(normal, H), EPSILON, 1.0);\n\t\n    float clampedRoughness = max(mat.roughness, MIN_ROUGHNESS);\n    vec3 specular = mat.specular;\n    if(mat.type == MAT_REFRACT)\n    {\n        specular = vec3(IORtoR0(mat.ior));\n    }\n    \n\treturn D_GGX(clampedRoughness, NoH) * GG_GGX(NoL, NoV, clampedRoughness) * FSchlick(specular, VoH);\n}\n\nvec3 Diffuse(Material mat, vec3 normal, vec3 view, vec3 lightDir, vec3 wpos)\n{\n\tvec3 H = normalize(view + lightDir);\n\tfloat NoV = clamp(dot(normal, view), EPSILON, 1.0);\n\tfloat NoL = clamp(dot(normal, lightDir), EPSILON, 1.0);\n\tfloat VoH = clamp(dot(view, H), EPSILON, 1.0);\n\t\n    vec3 albedo = mat.albedo;\n    if(mat.type == MAT_CHECKER)\n    {\n        vec3 sq = floor(wpos.xyz) * 0.5;\n        if(fract(sq.x + sq.y + sq.z) < 0.1)\n        {\n        \talbedo *= CHECKER_FADE; \n        }\n    }\n    \n\treturn DiffuseBurley(albedo, max(mat.roughness, MIN_ROUGHNESS), NoV, NoL, VoH);\n}\n\nbool IsPureSpec(Material mat)\n{\n\treturn (mat.albedo.x + mat.albedo.y + mat.albedo.z == 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = sin(iTime * RAND_PERIOD_SCALE);\n    \n    fragUV = fragCoord / iResolution.xy;\n\tpixelSize = vec2(1.0, 1.0) / iResolution.xy;\n\t\n    Camera cam = CreateScene();\t\n\tcam.aspect = float(iResolution.x) / float(iResolution.y);\n    \n   \t// input                \n    if(iMouse.x != 0.0 || iMouse.y != 0.0)\n    {\n\t\tfloat xIn = 2.0 * PI * (iMouse.x / iResolution.x);\n     \tfloat yIn = -PI * (iMouse.y / iResolution.y - 0.5);\n        xIn *= 2.0;\n        \n        vec3 tempDir = vec3(sin(xIn), sin(yIn), cos(xIn));\n        cam.pos = tempDir * cam.orbitDist + cam.orbitPoint;\n        cam.dir = -tempDir;\n    }\n    else\n    {\n\t\tcam.pos = cam.orbitPoint - vec3(cam.orbitDist, 0, 0);\n\t\tcam.dir = vec3(1, 0, 0);\n    }\n    \n\tvec3 currentFrame = vec3(0,0,0);\n    for(int k = 0; k < ITERATIONS; k++)\n\t{\n\t\tvec3 colorAcc = vec3(0,0,0);\n\t\tvec3 falloffAcc = vec3(1,1,1);\n        \n\t\tRay currentRay = GetRayFromCamera(cam);\n        \n        for(int i = 0; i < BOUNCES; i++)\n        {\t\t\n            HitInfo hitInfo;\n            bool isHit = RayTraceScene(currentRay, hitInfo);\n\t\t\tif(!isHit)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t// Beer-Lambert law\n\t\t\tfalloffAcc *= exp(-hitInfo.t * (vec3(1,1,1) - currentRay.medium));\n\t\t\t\n            if(hitInfo.mat.type == MAT_EMISSIVE)\n            {\n                colorAcc = hitInfo.mat.albedo * falloffAcc;\n                break;\n            }\n            else\n            {\n                vec3 view = -currentRay.dir;\n\n                vec3 randDir;\n                if( IsPureSpec(hitInfo.mat) || (Rand() < 0.5 && currentRay.order < NO_SPEC_ORDER) )\n                {\n                    vec3 reflected = reflect(currentRay.dir, hitInfo.normal);\n\t\t\t\t\t\n\t\t\t\t\t// Hack for mirror surfaces\n                    if(hitInfo.mat.roughness == 0.0) \n\t\t\t\t\t{\n                    \trandDir = reflected;\n\t\t\t\t\t}\n                    else\n\t\t\t\t\t{\n                    \trandDir = RandDirection(reflected);\n\t\t\t\t\t}\n\n                    if(dot(randDir, hitInfo.normal) < 0.0)\n                    {\n                        continue;\n                    }\n\n                    currentRay = Ray(hitInfo.pos + randDir * EPSILON, randDir, currentRay.order + 1, currentRay.medium, currentRay.ior);\n                    falloffAcc *= BRDF(hitInfo.mat, hitInfo.normal, view, currentRay.dir);\n                }\n                else\n                {\n\t\t\t\t\tif(hitInfo.mat.type == MAT_REFRACT)\n\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tfloat NoV = dot(hitInfo.normal, view);\n\t\t\t\t\t\tvec3 nextMedium = hitInfo.mat.albedo;\t\t\t\t\t\t\n\t\t\t\t\t\tfloat nextIor = hitInfo.mat.ior;\t\t\t\t\t\n\t\t\t\t\t\tfloat iorRatio = 1.0 / hitInfo.mat.ior;\n\t\t\t\t\t\tif(currentRay.ior != 1.0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(currentRay.ior == iorRatio)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiorRatio = 1.0 / currentRay.ior;\n\t\t\t\t\t\t\t\tnextMedium = vec3(1,1,1);\n\t\t\t\t\t\t\t\tnextIor = 1.0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tiorRatio = hitInfo.mat.ior / currentRay.ior;\n\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\tfloat refractCos = 1.0 - iorRatio * iorRatio * ( 1.0 - NoV * NoV );\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(refractCos < 0.0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Total internal reflection\n\t\t\t\t\t\t\tvec3 refractDir = reflect(currentRay.dir, hitInfo.normal);\n\t\t\t\t\t\t\tvec3 randRefractDir = RandDirection(refractDir);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(dot(randRefractDir, hitInfo.normal) < 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n                            \n\t\t\t\t\t\t\tcurrentRay = Ray(hitInfo.pos + randRefractDir * EPSILON, randRefractDir, currentRay.order + 1, currentRay.medium, currentRay.ior);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n                            refractCos = sqrt(refractCos);\n                            \n\t\t\t\t\t\t\tvec3 refractDir = iorRatio * (-view) + ( iorRatio * NoV - refractCos ) * hitInfo.normal;\n\t\t\t\t\t\t\tvec3 randRefractDir = RandDirectionSize(refractDir, hitInfo.mat.roughness * hitInfo.mat.roughness);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(dot(randRefractDir, hitInfo.normal) >= 0.0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tcurrentRay = Ray(hitInfo.pos + randRefractDir * EPSILON, randRefractDir, currentRay.order + 1, nextMedium, nextIor);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\trandDir = RandDirection(hitInfo.normal);\n\n\t\t\t\t\t\tcurrentRay = Ray(hitInfo.pos + randDir * EPSILON, randDir, currentRay.order + 1, currentRay.medium, currentRay.ior);\n\t\t\t\t\t\tfalloffAcc *= Diffuse(hitInfo.mat, hitInfo.normal, view, currentRay.dir, hitInfo.pos);\n\t\t\t\t\t}\t\t\t\t\t\n                }\t\t\t\n            }\t\t\n        }\n        \n        currentFrame += colorAcc;\n    }\n    currentFrame = currentFrame / vec3(ITERATIONS, ITERATIONS, ITERATIONS);\n\t\t\n    vec3 prevFrame = texture(iChannel0, fragUV).rgb;        \n    int lastFrame = int(texture(iChannel1, fragUV).r);\n    \n    float blendFactor = 1.0 / float(iFrame - lastFrame + 1);\n    if(iMouse.z > 0.0) \n    {        \n        blendFactor = 1.0;\n    }\n    \n    currentFrame = mix(prevFrame, currentFrame, blendFactor);\n    \n    fragColor = vec4(currentFrame, 1);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// By Roman Smirnov\n// License Creative Commons Attribution 4.0 International\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iMouse.z > 0.0) \n    {\n        fragColor = vec4(iFrame, 0, 0, 1.0);\n    }\n    else\n    {\n        discard;\n    }\n}\n","name":"Buf B","description":"","type":"buffer"}]}