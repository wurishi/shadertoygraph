{"ver":"0.1","info":{"id":"tdfBRr","date":"1587610710","viewed":71,"name":"Noise Functions Practice","username":"fakeljl","description":"Perlin Noise, Worley Noise, Fractal Brownian Motion","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["fbm","perlin","worley"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int RAY_STEPS = 256;\nconst float FOV = 45.0 * 3.14159 / 180.0;\n\nconst vec3 boxT = vec3(6.0, -1.0, 5.75);\nconst vec3 boxR = vec3(0.0, -17.5, 0.0);\nconst vec3 boxS = vec3(3, 3, 3);\n\nconst vec3 pA = vec3(0.5, 0.5, 0.5);\nconst vec3 pB = vec3(0.5, 0.5, 0.5);\nconst vec3 pC = vec3(1.0, 1.0, 1.0);\nconst vec3 pD = vec3(0.0, 0.1, 0.2);\n\nconst vec3 pA2 = vec3(0.7, 0.5, 0.2);\nconst vec3 pB2 = vec3(0.2, 0.3, 0.2);\nconst vec3 pC2 = vec3(2.0, 1.0, 1.0);\nconst vec3 pD2 = vec3(0.0, 0.25, 0.5);\n\nvec3 palette(float t) {\n    return clamp(pA + pB * cos(2.0 * 3.14159 * (pC * t + pD)), 0.0, 1.0);\n}\n\nvec3 palette2(float t) {\n    return clamp(pA2 + pB2 * cos(2.0 * 3.14159 * (pC2 * t + pD2)), 0.0, 1.0);\n}\n\nstruct Intersection {\n    float t;\n    vec3 color;\n    vec3 p;\n    int object;\n};\n    \nmat4 scale(vec3 s){\n    return mat4(\n        vec4(s.x,   0.0, 0.0, 0.0),\n        vec4(0.0, s.y,   0.0, 0.0),\n        vec4(0.0, 0.0, s.z,   0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nmat4 translate(vec3 t){\n    return mat4(\n        vec4(1.0, 0.0, 0.0, 0.0),\n        vec4(0.0, 1.0, 0.0, 0.0),\n        vec4(0.0, 0.0, 1.0, 0.0),\n        vec4(t.x,   t.y,   t.z,   1.0)\n    );\n}\n\nmat4 rotateX(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(1.,0.,0.,0),\n        vec4(0.,cos(theta),-sin(theta),0.),\n        vec4(0.,sin(theta),cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateY(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),0.,-sin(theta),0),\n        vec4(0.,1.,0.,0.),\n        vec4(sin(theta),0.,cos(theta),0.),\n        vec4(0.,0.,0.,1.));\n}\n\nmat4 rotateZ(float theta){\n    theta *= 3.14159 / 180.0;\n    return mat4(\n        vec4(cos(theta),-sin(theta),0.,0),\n        vec4(sin(theta),cos(theta),0.,0.),\n        vec4(0.,0.,1.,0.),\n        vec4(0.,0.,0.,1.));\n}\n\nfloat plane(vec3 p, vec4 n) {\n    return dot(p, n.xyz) + n.w;\n}\n    \nfloat sphere(vec3 p, float r, vec3 c) {\n    return distance(p, c) - r;\n}\n\nfloat box(vec3 pos, vec3 t, vec3 r, vec3 s) {\n    mat4 worldInverse = inverse(translate(t) * rotateX(r.x) * rotateY(r.y) * rotateZ(r.z) * scale(s));\n    vec3 p = vec3(worldInverse * vec4(pos, 1));\n    float sFactor = min(min(abs(s.x), abs(s.y)), abs(s.z));\n    float dX = 0.0;\n    float dY = 0.0;\n    float dZ = 0.0;\n    if (p.x > 0.5) {\n        dX = p.x - 0.5;\n    }\n    else if (p.x < -0.5) {\n        dX = -0.5 - p.x;\n    }\n    if (p.y > 0.5) {\n        dY = p.y - 0.5;\n    }\n    else if (p.y < -0.5) {\n        dY = -0.5 - p.y;\n    }\n    if (p.z > 0.5) {\n        dZ = p.z - 0.5;\n    }\n    else if (p.z < -0.5) {\n        dZ = -0.5 - p.z;\n    }\n    if (dX == 0.0 && dY == 0.0 && dZ == 0.0) {\n        float xmin = min(0.5 - p.x, p.x + 0.5);\n        float ymin = min(0.5 - p.y, p.y + 0.5);\n        float zmin = min(0.5 - p.z, p.z + 0.5);\n        return -min(min(xmin, ymin), zmin) * sFactor;\n    }\n    else {\n        return sqrt(dX * dX + dY * dY + dZ * dZ) * sFactor;\n    }\n}\n\nvoid rayCast(vec2 uv, out vec3 dir, out vec3 eye, out vec3 ref) {\n    eye = vec3(15.0 * sin(0.3 * iTime), 5.0, 15.0 * cos(0.3 * iTime));\n    ref = vec3(0.0, 0.0, 0.0);\n    \n    float len = tan(FOV * 0.5) * distance(eye, ref);\n    vec3 H = normalize(cross(ref - eye, vec3(0.0, 1.0, 0.0)));\n    vec3 V = normalize(cross(H, ref - eye));\n    V *= len;\n    H *= len * iResolution.x / iResolution.y;\n    vec3 p = ref + uv.x * H + uv.y * V;\n    dir = normalize(p - eye);\n}\n\nvec3 random3(vec3 p) {\n    return fract(sin(vec3(dot(p,vec3(127.1, 311.7, 191.999)),\n                          dot(p,vec3(269.5, 183.3, 765.54)),\n                          dot(p, vec3(420.69, 631.2,109.21))))\n                 *43758.5453);\n}\n\nvec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(127.1, 311.7)),\n                          dot(p,vec2(269.5, 765.54))))\n                 *43758.5453);\n}\n\nfloat random1(vec2 p) {\n    return fract(sin(dot(p,vec2(420.69,987.654)))*85734.3545);\n}\n\nvec2 randomVector2(vec2 p) {\n    return normalize(2.0 * fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) - 1.0);\n}\n    \n\nfloat perlin3D(vec3 pos, vec3 t, vec3 r, vec3 s) {\n    vec3 center = t;\n    vec3 xAxis = vec3(rotateX(r.x) * rotateY(r.y) * rotateZ(r.z) * scale(s) * vec4(0.5, 0.0, 0.0, 0.0));\n    vec3 yAxis = vec3(rotateX(r.x) * rotateY(r.y) * rotateZ(r.z) * scale(s) * vec4(0.0, 0.5, 0.0, 0.0));\n    vec3 zAxis = vec3(rotateX(r.x) * rotateY(r.y) * rotateZ(r.z) * scale(s) * vec4(0.0, 0.0, 0.5, 0.0));\n    vec3 corner[8];\n    float dist[8];\n    int idx = 0;\n    float distSum = 0.0;\n    for (float i = -1.0; i <= 1.0; i += 2.0) {\n        for (float j = -1.0; j <= 1.0; j += 2.0) {\n            for (float k = -1.0; k <= 1.0; k += 2.0) {\n                corner[idx] = xAxis * i + yAxis * j + zAxis * k + center;\n                dist[idx] = distance(corner[idx], pos);\n                distSum += dist[idx];\n                idx++;\n            }\n        }\n    }\n    idx = 0;\n    float result = 0.0;\n    for (idx = 0; idx < 8; idx++) {\n        result += (1.0 - dist[idx] / distSum) * dot(normalize(pos - corner[idx]), normalize(random3(corner[idx])));\n    }\n    return result;\n}\n\nfloat noise2D(vec2 v) {\n    return fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453);\n}\n              \nfloat interpNoise2D(float x, float y) {\n    float intX = floor(x);\n    float fractX = fract(x);\n    float intY = floor(y);\n    float fractY = fract(y);\n    float v1 = noise2D(vec2(intX, intY));\n    float v2 = noise2D(vec2(intX + 1.0, intY));\n    float v3 = noise2D(vec2(intX, intY + 1.0));\n    float v4 = noise2D(vec2(intX + 1.0, intY + 1.0));\n    fractX = fractX * fractX * (3.0 - 2.0 * fractX);\n    float i1 = mix(v1, v2, fractX);\n    float i2 = mix(v3, v4, fractX);\n    fractY = fractY * fractY * (3.0 - 2.0 * fractY);\n    return mix(i1, i2, fractY);\n}\n\nfloat fbm(float x, float y) {\n    float total = 0.0;\n    float persistence = 0.5;\n    int octaves = 4;\n    for (int i = 1; i <= octaves; i++) {\n        float freq = pow(2.0, float(i));\n        float amp = pow(persistence, float(i));\n        total += interpNoise2D(x * freq, y * freq) * amp;\n    }\n    return total;\n}\n\nfloat worleyNoiseInefficient(vec2 uv) {\n    uv = uv /25.0 * 4.0;\n    float minDist = 1.0;\n    for(float i = 0.0; i < 100.0; ++i) {\n        vec2 bufB_UV = vec2(i / float(iResolution.x), 0.0);\n        vec2 particlePos = texture(iChannel0, bufB_UV).xy;\n        \n        float dist = length(particlePos - uv);\n        minDist = min(dist, minDist);\n    }\n    return minDist;\n}\n\nfloat worleyNoise2D(vec2 p) {\n    vec2 pInt = floor(p);\n    vec2 pFract = fract(p);\n    float minDist = 1.0;\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 neighbor = vec2(float(i), float(j));\n            vec2 point = random2(pInt + neighbor);\n            float dist = length(neighbor + point - pFract);\n            minDist = min(minDist, dist);\n        }\n    }\n    return minDist;\n}\n\nvec2 sphereUV(vec3 p, vec3 c) {\n    vec3 diff = normalize(p - c);\n    float v = diff.y;\n    diff.y = 0.0;\n    float t1 = dot(normalize(diff), vec3(1.0, 0.0, 0.0));\n    float angle = acos(t1);\n    return vec2(angle, v);\n}\n\nvec3 computeMaterial(int hitObj, vec3 p, vec3 d, vec3 n) {\n    switch(hitObj) {\n        case 0: // Floor\n        return palette(worleyNoiseInefficient(vec2(p.x, p.z)));\n        break;\n        case 1: // Sphere Red\n        vec2 suv = sphereUV(p, vec3(0.0, 3.5 * abs(sin(1.15 * iTime)), 0.0));\n        return palette2(iTime * 0.5 + 5.0 * fbm((suv.x), suv.y));\n        break;\n        case 2: // Short Cube\n        return palette2(perlin3D(p, boxT, boxR, boxS));\n        break;\n        case -1:\n        return vec3(0.0);\n        break;\n    }\n    return vec3(0.0);\n}\n\nvoid sceneMap3D(vec3 pos, out float t, out int obj) {\n    t = plane(pos, vec4(0.0, 1.0, 0.0, 2.5));\n    obj = 0; // Floor\n    float t2;\n    \n    if ((t2 = sphere(pos, 2.5, vec3(0.0, 3.5 * abs(sin(1.15 * iTime)), 0.0))) < t) {\n        t = t2;\n        obj = 1; // Sphere Red\n    }\n    if ((t2 = box(pos, boxT, boxR, boxS)) < t) {\n        t = t2;\n        obj = 2; // Short Cube\n    }\n}\n\nfloat sceneMap3D(vec3 pos) {\n    float t;\n    int o;\n    sceneMap3D(pos, t, o);\n    return t;\n}\n\nvoid march(vec3 origin, vec3 dir, out float t, out int hitObj) {\n    t = 0.001;\n    for(int i = 0; i < RAY_STEPS; ++i)\n    {\n        vec3 pos = origin + t * dir;\n    \tfloat m;\n        sceneMap3D(pos, m, hitObj);\n        if(m < 0.01)\n        {\n            return;\n        }\n        t += m;\n    }\n    t = -1.0;\n    hitObj = -1;\n}\n\nvec3 computeNormal(vec3 pos) {\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize( vec3( sceneMap3D(pos + epsilon.yxx) - sceneMap3D(pos - epsilon.yxx),\n                            sceneMap3D(pos + epsilon.xyx) - sceneMap3D(pos - epsilon.xyx),\n                            sceneMap3D(pos + epsilon.xxy) - sceneMap3D(pos - epsilon.xxy)));\n}\n\nIntersection sdf3D(vec3 dir, vec3 eye) {\n    float t;\n    int hitObj;\n    march(eye, dir, t, hitObj);\n    if (t == -1.0) {\n        return Intersection(t, vec3(0.0), eye + 1000.0 * dir, -1);\n    }\n    vec3 isect = eye + t * dir;\n    vec3 nor = computeNormal(isect);\n    vec3 material = computeMaterial(hitObj, isect, dir, nor);\n    vec3 light = vec3(10.0, 7.45, 10.0);\n    float lambert = dot(normalize(light - isect), nor);\n    \n    vec3 col = (lambert + 0.8) * material;\n    col = mix(col, vec3(0.0, 0.0, 0.0), clamp(t, 0.0, 55.0) / 55.0);\n    \n    return Intersection(t, col, isect, hitObj);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // [-1, 1]\n    uv = 2.0 * uv - vec2(1.0);\n    \n    vec3 dir, eye, ref;\n    rayCast(uv, dir, eye, ref);\n    vec3 col = sdf3D(dir, eye).color;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float random1( vec2 p ) {\n    return fract(sin(dot(p,vec2(420.69,987.654)))*85734.3545);\n}\n\nvec2 randomVector2( vec2 p ) {\n    return normalize(2.0 * fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453) - 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 origin = vec2(0.0, 0.0);\n    vec2 dir = randomVector2(fragCoord.xy);\n    float timeOffset = sin(random1(fragCoord.xx * 0.01) * 3.14159 * 0.5) * 12.0;\n    float t = mod(iTime + timeOffset, 6.0);\n    \n    vec2 pos = origin + t * dir;\n    \n    fragColor = vec4(pos, 0.0, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}