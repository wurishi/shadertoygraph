{"ver":"0.1","info":{"id":"ddSSRD","date":"1669965490","viewed":149,"name":"ChatGPT Test","username":"scry","description":"https://chat.openai.com/chat\n\"Write me a GLSL shader function for some red, green, and blue repeating boxes, like pixels.\"\nhttps://twitter.com/Scrygl/status/1598576823910080512","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Write me a GLSL shader function for some red, green, and blue repeating boxes, like pixels.\nvec4 pixelShader_try1(vec2 uv) {\n    // Calculate the grid position of the current pixel\n    vec2 gridPos = floor(uv * vec2(16.0, 16.0));\n\n    // Calculate the color of the current pixel based on its grid position\n    if (mod(gridPos.x, 3.0) == 0.0 && mod(gridPos.y, 3.0) == 0.0) {\n        // Red\n        return vec4(1.0, 0.0, 0.0, 1.0);\n    } else if (mod(gridPos.x, 3.0) == 1.0 && mod(gridPos.y, 3.0) == 1.0) {\n        // Green\n        return vec4(0.0, 1.0, 0.0, 1.0);\n    } else if (mod(gridPos.x, 3.0) == 2.0 && mod(gridPos.y, 3.0) == 2.0) {\n        // Blue\n        return vec4(0.0, 0.0, 1.0, 1.0);\n    } else {\n        // White\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n//That works pretty well! except there are white diagonal stripes. Can it instead be repeating sets of red, green, and blue boxes like pixels?\nvec4 pixelShader_try2(vec2 uv) {\n    // Calculate the grid position of the current pixel\n    vec2 gridPos = floor(uv * vec2(16.0, 16.0));\n\n    // Calculate the color of the current pixel based on its grid position\n    if (mod(gridPos.x + gridPos.y, 3.0) == 0.0) {\n        // Red\n        return vec4(1.0, 0.0, 0.0, 1.0);\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 1.0) {\n        // Green\n        return vec4(0.0, 1.0, 0.0, 1.0);\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 2.0) {\n        // Blue\n        return vec4(0.0, 0.0, 1.0, 1.0);\n    } else {\n        // White\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n//Cool! Now can there be black lines between the boxes? And with the option to choose thickness?\nvec4 pixelShader_try3(vec2 uv, float lineThickness) {\n    // Calculate the grid position of the current pixel\n    vec2 gridPos = floor(uv * vec2(16.0, 16.0));\n\n    // Calculate the color of the current pixel based on its grid position\n    if (mod(gridPos.x + gridPos.y, 3.0) == 0.0) {\n        // Red\n        return vec4(1.0, 0.0, 0.0, 1.0);\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 1.0) {\n        // Green\n        return vec4(0.0, 1.0, 0.0, 1.0);\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 2.0) {\n        // Blue\n        return vec4(0.0, 0.0, 1.0, 1.0);\n    } else {\n        // Black\n        // Check if the current pixel is within the line thickness distance from a grid line\n        if (abs(mod(uv.x * 16.0, 1.0) - 0.5) < lineThickness || abs(mod(uv.y * 16.0, 1.0) - 0.5) < lineThickness) {\n            return vec4(0.0, 0.0, 0.0, 1.0);\n        } else {\n            // White\n            return vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }\n}\n\n//It appears the lineThickness variable in this does not actually result in any black lines. Can you try again and make it so the boxes have black borders?\nvec4 pixelShader_try4(vec2 uv, float lineThickness) {\n    // Calculate the grid position of the current pixel\n    vec2 gridPos = floor(uv * vec2(16.0, 16.0));\n\n    // Calculate the color of the current pixel based on its grid position\n    if (mod(gridPos.x + gridPos.y, 3.0) == 0.0) {\n        // Red\n        // Check if the current pixel is within the line thickness distance from a grid line\n        if (abs(mod(uv.x * 16.0, 1.0) - 0.5) < lineThickness || abs(mod(uv.y * 16.0, 1.0) - 0.5) < lineThickness) {\n            return vec4(0.0, 0.0, 0.0, 1.0);\n        } else {\n            return vec4(1.0, 0.0, 0.0, 1.0);\n        }\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 1.0) {\n        // Green\n        // Check if the current pixel is within the line thickness distance from a grid line\n        if (abs(mod(uv.x * 16.0, 1.0) - 0.5) < lineThickness || abs(mod(uv.y * 16.0, 1.0) - 0.5) < lineThickness) {\n            return vec4(0.0, 0.0, 0.0, 1.0);\n        } else {\n            return vec4(0.0, 1.0, 0.0, 1.0);\n        }\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 2.0) {\n        // Blue\n        // Check if the current pixel is within the line thickness distance from a grid line\n        if (abs(mod(uv.x * 16.0, 1.0) - 0.5) < lineThickness || abs(mod(uv.y * 16.0, 1.0) - 0.5) < lineThickness) {\n            return vec4(0.0, 0.0, 0.0, 1.0);\n        } else {\n            return vec4(0.0, 0.0, 1.0, 1.0);\n        }\n    } else {\n        // White\n        return vec4(1.0, 1.0, 1.0, 1.0);\n    }\n}\n\n//This is closer, but the lines are in the middle of the boxes. Can they instead be segmenting each set of 3 (red, green, and blue) boxes?\nvec4 pixelShader(vec2 uv, float lineThickness) {\n    // Calculate the grid position of the current pixel\n    vec2 gridPos = floor(uv * vec2(16.0, 16.0));\n\n    // Calculate the color of the current pixel based on its grid position\n    if (mod(gridPos.x + gridPos.y, 3.0) == 0.0) {\n        // Red\n        return vec4(1.0, 0.0, 0.0, 1.0);\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 1.0) {\n        // Green\n        return vec4(0.0, 1.0, 0.0, 1.0);\n    } else if (mod(gridPos.x + gridPos.y, 3.0) == 2.0) {\n        // Blue\n        return vec4(0.0, 0.0, 1.0, 1.0);\n    } else {\n        // Black\n        // Check if the current pixel is within the line thickness distance from a grid line\n        // that separates the sets of red, green, and blue boxes\n        if (abs(mod(gridPos.x, 3.0) - 1.5) < lineThickness || abs(mod(gridPos.y, 3.0) - 1.5) < lineThickness) {\n            return vec4(0.0, 0.0, 0.0, 1.0);\n        } else {\n            // White\n            return vec4(1.0, 1.0, 1.0, 1.0);\n        }\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Calculate the UV coordinates of the current pixel\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    // Set the line thickness\n    float lineThickness = 0.9;\n\n    // Call the pixelShader function to calculate the color of the current pixel\n    fragColor = pixelShader(uv, lineThickness);\n}","name":"Image","description":"","type":"image"}]}