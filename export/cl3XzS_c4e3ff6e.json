{"ver":"0.1","info":{"id":"cl3XzS","date":"1685496690","viewed":202,"name":"Croissant by IBL & PBR","username":"guhcalm","description":"SDF's used\n- Croissant by iq: https://www.shadertoy.com/view/lsl3W2\n- Tower by snolot: https://www.shadertoy.com/view/ssKcWW\n- Monster by iq: https://www.shadertoy.com/view/4sX3R2\n\nPost-Processing\n- Chromatic aberration;\n- Vignetting;\n- ACES Tone Mapping;","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","ibl","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 Render(Ray camera) {  \n  Geometry geometry = getGeometry(camera);\n  if (geometry.depth == 1.) return GammaExpansion(texture(iChannel0, camera.direction));\n  float ao;\n  vec3 ambient = IBL(camera, geometry, ao, iChannel0);\n  //return ambient;\n  const Light light = Light(normalize(vec3(1)), vec3(1));\n  float shadow = getSoftShadow(geometry, light);\n  vec3 direct = PBR(camera, geometry, light, shadow, ao);\n  return ambient + direct;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  //time = iTime;\n  vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n  float a = - m.x * PI * 2. - 1.5;\n  vec3 origin = 4.5 * vec3(sin(a), mix(1., m.y, .7), cos(a));\n  vec3 target;\n  const float AA = 2.;\n  vec3 color;\n  for (float i; i < AA; i++) {\n    vec2 uv = (vec2(random(), random()) - .5 + fragCoord - .5 * iResolution.xy) / iResolution.y;\n    color += Render(getCamera(uv, origin, target));\n  }\n  fragColor = vec4(GammaCompression(color / AA), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 PincushionDistortion(vec2 uv, float strength) {\n  vec2 st = uv - 0.5;\n  float uvA = atan(st.x, st.y);\n  float uvD = dot(st, st);\n  return 0.5 + vec2(sin(uvA), cos(uvA)) * sqrt(uvD) * (1.0 - strength * uvD);\n}\nvec3 ChromaticAbberation(vec2 uv, sampler2D sampler) {\n  float amount = .5;\n  return vec3(\n    texture(sampler, PincushionDistortion(uv, 0.3 * amount)).r,\n    texture(sampler, PincushionDistortion(uv, 0.15 * amount)).g,\n    texture(sampler, PincushionDistortion(uv, 0.075 * amount)).b\n  );\n}\n#define ACESFilmic(color) (color * (2.51 * color + .03)) / (color * (2.43 * color + .59) + .14)\n#define Contrast(color) color * color * (3. -2. * color)\n#define HighlightRolloff(color) 1.85 * color / (1. + color)\nvec3 FilmGrain(vec2 uv, vec3 color) {\n  float seed = dot(uv, vec2(12.9898, 78.233));\n  float noise = .7978845608028654 * exp(-(pow(fract(sin(seed) * 43758.5453), 2.) / .5));\n  vec3 grain = vec3(noise) * (1.0 - color);\n  return color + noise * .075;\n}\n#define Vignetting(uv, color) color * (.5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .25))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 color = ChromaticAbberation(uv, iChannel0);\n  color = Vignetting(uv, color);\n  color = ACESFilmic(color);\n  color = FilmGrain(uv, color);\n  color = Contrast(color);\n  color = HighlightRolloff(color);\n  fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct Ray { vec3 origin; vec3 direction; };\nstruct Material { vec3 albedo; float roughness; float metalness; float reflectance; };\nstruct Geometry { float depth; vec3 position; vec3 normal; Material material; };\nstruct Light { vec3 direction; vec3 color; };\n\n#define saturate(value) clamp(value, 0., 1.)\n#define GammaExpansion(color) pow(vec3(color), vec3(2.2))\n#define GammaCompression(color) pow(vec3(color), vec3(1. / 2.2))\n\nconst float PI = 3.14159265359;\nconst float EPSILON = .001;\nconst float NEAR = .001;\nconst float FAR = 20.;\n\nfloat time;\nfloat seed;\n#define random() fract(sin(seed += .1) * 4568.7564)\nvec3 getRandomVectorOnHemisphere(vec3 normal) {\n  float u = random();\n  float v = random();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 random = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  return normalize(random * sign(dot(normal, random)));\n}\n\n/* Thermal Gradient Color | by Turbo */\nvec3 getThermalColor(float t) {\n  t = clamp(0., 1., t);\n  const vec3 c0 = vec3(0.1140890109226559, 0.06288340699912215, 0.2248337216805064);\n  const vec3 c1 = vec3(6.716419496985708, 3.182286745507602, 7.571581586103393);\n  const vec3 c2 = vec3(-66.09402360453038, -4.9279827041226, -10.09439367561635);\n  const vec3 c3 = vec3(228.7660791526501, 25.04986699771073, -91.54105330182436);\n  const vec3 c4 = vec3(-334.8351565777451, -69.31749712757485, 288.5858850615712);\n  const vec3 c5 = vec3(218.7637218434795, 67.52150567819112, -305.2045772184957);\n  const vec3 c6 = vec3(-52.88903478218835, -21.54527364654712, 110.5174647748972);\n  return c0 + t * (c1 + t * (c2 + t * (c3 + t * (c4 + t * (c5 + t * c6)))));\n}\n\n/* SDF's */\n#define qSquare(a) vec4(a.x * a.x - dot(a.yzw, a.yzw), 2. * a.x * a.yzw)\n#define qCube(a) (a * (4. * a.x * a.x - dot(a, a) * vec4(3, 1, 1, 1)))\n#define lengthSquared(a) dot(a, a)\nfloat Croissant(in vec3 p) {\n  vec4 c = vec4(-.1, .6, .9, -.3) + .1 * sin(vec4(3, 0, 1, 2) + .5 * vec4(1, 1.3, 1.7, 2.1) * time);\n  vec4 z = vec4(p, .2);\n  float m2 = 0.;\n  float dz2 = 1.;\n  for(int i = 0; i< 10; i++) {\n\tdz2 *= 9. * lengthSquared(qSquare(z));\n\tz = qCube(z) + c;\n\tm2 = dot(z, z);\t\t\n    if(m2 > 10000.) break;\n  }\n  float t = .25 * log(m2) * sqrt(m2/dz2);\n  return t;\n}\nfloat Terrain(vec3 p) { return (p.y + 3. - sin(p.x) * sin(p.z)) * .5; }\nfloat Sphere(vec3 p) { return length(p) - 1.; }\nfloat Tower(in vec3 pos) {\n  const float RADIUS = .3492;\n  const float SCALE = 2.04348;\n  const int ITERATIONS = 10;\n  vec3 p = pos * mix(.5, 2., smoothstep(0., 1., sin(time) * .5 + .5));\n  float s = 2.;\n  for (int i; i < ITERATIONS; i++) {\n    p = abs(p);\n    p += vec3(0.0365, -1.8613, 0.0365);\n    float r2 = dot(p, p);\n    float k = clamp(max(RADIUS / r2, RADIUS), 0., 1.);\n\tp *= k;\n    s *= k;\n    p = p * SCALE / RADIUS;\n    s *= abs(SCALE) / RADIUS;\n    p += vec3(-.5, -1.3028, -.5);\n  }\n  return (length(p) - abs(SCALE - 1.0)) / s - pow(abs(SCALE), float(1 - ITERATIONS));\n}\nfloat Mandelbulb(in vec3 position) {\n  vec3 p = position * .5;\n  float power = 7. + 5. * sin(time / 3.);\n  vec3 z = p;\n  float dr = 1.;\n  float r = 0.;\n  for (int i = 0; i < 15; i++) {\n    r = length(z);\n    if (r > 1.5) break;\n    float theta = acos(z.z / r) * power;\n    float phi = atan(z.y, z.x) * power;\n    dr = pow(r, power - 1.) * power * dr + 1.;\n    float zr = pow(r, power);\n    z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n    z += p;\n  }\n  return .5 * log(r) * r / dr;\n}\nfloat Monster(in vec3 p) {\n  float k = 1.0;\n  float rtime = time * 3.;\n  float time = rtime;\n  time += 15. * smoothstep(15., 25., rtime);\n  time += 20. * smoothstep(65., 80., rtime);\n  time += 35. * smoothstep(105., 135., rtime);\n  time += 20. * smoothstep(165., 180., rtime);\n  time += 40. * smoothstep(220., 290., rtime);\n  time += 5. * smoothstep(320., 330., rtime);\n  float time1 = (time-10.0)*1.5 - 167.0;\n  vec3 xyz = (\n    vec3(.4, .1, 3.4)\n    + .15 * sin(.1 * vec3(.40, .30, .61) * time1)\n    + .15 * sin(.1 * vec3(.11, .53, .48) * time1)\n  );\n  mat4 mm;\n  {\n    vec3 s = sin(xyz);\n    vec3 c = cos(xyz);\n    mm = mat4(\n      c.y * c.z,                   c.y * s.z,                   -s.y,      0.,\n      s.x * s.y * c.z - c.x * s.z, s.x * s.y * s.z + c.x * c.z, s.x * c.y, 0.,\n      c.x * s.y * c.z + s.x * s.z, c.x * s.y * s.z - s.x * c.z, c.x * c.y, 0.,\n      0.,                          0.,                          0.,        1.\n    );\n  }\n  const float s = 1.1;\n  mm[0].xyz *= s;\t\n  mm[1].xyz *= s;\n  mm[2].xyz *= s;\t\n  mm[3].xyz = (vec3(.15, .05, -.07) + .05 * sin(vec3(0, 1, 2) + .2 * vec3(.31, .24, .42) * time1));\n  for(int i; i < 22; i++) { p = (mm * vec4(abs(p), 1.)).xyz; k *= s; }\n  return (length(p) - .25) / k;\n}\n\nvec2 rotate(vec2 p, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return p * mat2(c, s, -s, c);\n}\n\nfloat Blob(vec3 p) {\n    float angle = time * 0.05 * (0.2) + sin(time * 0.2) * 0.0;\n    for (int i = 0; i < 12; ++i) {\n        float t = angle;\n        p.xz = rotate(p.xz, t * 10.666);\n        p.xy = rotate(p.xy, t * 40.666);\n        p.xz = rotate(p.xz, t * 10.666);\n        p.xy = rotate(p.xy, t * 50.666);\n        p.xz = abs(p.xz);\n        p.xz -= 0.5;\n    }\n    return length(p) - (0.5 + 0.1);\n}\n\nfloat getSignedDistance(in vec3 position) {\n  //return Terrain(position * .5);\n  //return Sphere(position * .5);\n  //return Tower(position * .6);\n  //return Monster(position * .5);\n  //return Mandelbulb(position * 1.2);\n  //return Blob(position);\n  return Croissant(position * .5);\n}\n\n/* Ray Cast | by Ray Marching  */\nfloat RayCast(in Ray ray, const int STEPS, const float NEAR, const float FAR) {\n  float distance;\n  for(int step; step < STEPS; step++) {\n    float march = getSignedDistance(ray.origin + ray.direction * distance);\n    if (abs(march) <= NEAR) return distance;\n    distance += march;\n    if (distance >= FAR) break;\n  }\n  return FAR;\n}\n\n/* Geometry Pass */\nGeometry getGeometry(Ray camera) {\n  float distance = RayCast(camera, 500, EPSILON, FAR);\n  Geometry geometry;\n  geometry.depth = clamp(0., FAR, distance) / FAR;\n  geometry.position = camera.origin + camera.direction * geometry.depth * FAR;\n  if (geometry.depth < 1.) {\n    vec3 p = geometry.position;\n    const vec2 e = vec2(EPSILON, 0);\n    geometry.normal = normalize(vec3(\n      getSignedDistance(p + e.xyy) - getSignedDistance(p - e.xyy),\n      getSignedDistance(p + e.yxy) - getSignedDistance(p - e.yxy),\n      getSignedDistance(p + e.yyx) - getSignedDistance(p - e.yyx)\n    ));\n    geometry.material = Material(vec3(1), 0., 0., .16);\n  }\n  return geometry;\n}\n\n/* Ambient Occlusion Pass | by SDF */\nfloat getAmbientOcclusion(const Geometry geometry, const vec3 N, const float FAR) {  \n  float distance = RayCast(Ray(geometry.position + N * .002, N), 150, .001, FAR);\n  float ao = distance >= FAR ? 1. : pow(distance / FAR, 2.);\n  const float STEPS = 8.;\n  for (float i; i < STEPS; ++i) {\n    float distance = RayCast(Ray(geometry.position + N * .002, getRandomVectorOnHemisphere(N)), 150, .001, FAR);\n    ao += distance >= FAR ? 1. : pow(distance / FAR, 2.);\n  }\n  return ao / (1. + STEPS);\n}\n\n/* Image Based Lightning */\nvec3 getDiffuseRadiance(const vec3 N, const samplerCube environment) {\n  const float STEPS = 199.;\n  vec3 color = GammaExpansion(texture(environment, N));\n  for (float i; i < STEPS; i++) {\n    vec3 random = normalize(getRandomVectorOnHemisphere(N));\n    color += GammaExpansion(texture(environment, random)) * saturate(dot(N, random));\n  };\n  return color / (1. + STEPS);\n}\nvec3 IBL(const Ray camera, const Geometry geometry, inout float ao, const samplerCube environment) {\n  vec3 V = -camera.direction;\n  vec3 N = geometry.normal;\n  vec3 R = reflect(-V, N);\n  vec3 albedo = geometry.material.albedo;\n  float metalness = saturate(geometry.material.metalness);\n  float roughness = clamp(geometry.material.roughness, .1, 1.);\n  float reflectance = geometry.material.reflectance;\n  vec3 Fo = mix(vec3(reflectance), albedo, metalness);\n  vec3 F = mix(vec3(pow(1. - saturate(dot(N, V)), 5.)), vec3(1), Fo);\n  ao = getAmbientOcclusion(geometry, mix(N, R, F), 2.);\n  vec3 diffuse = (1. - metalness) * albedo * getDiffuseRadiance(mix(N, R, F), environment);\n  vec3 specular = GammaExpansion(texture(environment, R, mix(0., 6., roughness)));\n  return mix(diffuse, specular, F) * ao;\n}\n\n/* Soft Shadow Pass | by SDF */\nfloat getSoftShadow(Geometry geometry, Light light) {\n  float k = 16.;\n  float res = 1.;\n  float t = .01;\n  float ph = 1e10;\n  for(int i = 0; i < 64; i++) {\n\tfloat h = getSignedDistance(geometry.position + light.direction * t);\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, k * d / max(0., t - y));\n    ph = h;    \n    t += h;\n    if(res < .001 || t > 16.) break;\n  }\n  res = clamp(res, 0., 1.);\n  return res * res * (3. - 2. * res);\n}\n\n/* Direct Lighting | by BRDF */\nvec3 PBR(const Ray camera, const Geometry geometry, const Light light, float shadow, float ao) {\n  vec3 V = - camera.direction;\n  vec3 N = geometry.normal;\n  vec3 albedo = geometry.material.albedo;\n  float metalness = saturate(geometry.material.metalness);\n  float roughness = mix(.1, 1., geometry.material.roughness);\n  float reflectance = clamp(geometry.material.reflectance, 0., .16);\n  float alpha = pow(roughness, 2.);\n  float a2 = pow(alpha, 2.);\n  float k = saturate(alpha / 2.);\n  vec3 Fo = mix(vec3(reflectance), albedo, metalness);  \n  vec3 diffuse = (1. - metalness) * albedo / PI; \n  vec3 Lo;\n  {// direct\n    vec3 L = normalize(light.direction);\n    vec3 H = normalize(V + L);\n    float D = a2 / (PI * pow(pow(saturate(dot(N, H)), 2.) * (a2 - 1.) + 1., 2.));\n    float G = 1. / mix(saturate(dot(N, L)), 1., k) * mix(saturate(dot(N, V)), 1., k);\n    vec3 F = mix(vec3(pow(1. - saturate(dot(L, H)), 5.)), vec3(1), Fo);\n    vec3 radiance = light.color * shadow * mix(ao, 1., .8);\n    Lo += mix(diffuse, vec3(D * G / 4.), F) * radiance * saturate(dot(N, L));\n  }\n  {// bouncing\n    vec3 L = normalize(-light.direction);\n    vec3 H = normalize(V + L);\n    float D = a2 / (PI * pow(pow(saturate(dot(N, H)), 2.) * (a2 - 1.) + 1., 2.));\n    float G = 1. / mix(saturate(dot(N, L)), 1., k) * mix(saturate(dot(N, V)), 1., k);\n    vec3 F = mix(vec3(pow(1. - saturate(dot(L, H)), 5.)), vec3(1), Fo);\n    vec3 radiance = .2 * light.color * mix(1. - shadow, 0., .8) * ao * (1. - ao);\n    Lo += mix(diffuse, vec3(D * G / 4.), F) * radiance * saturate(dot(N, L));\n  }\n  return Lo;\n}\n\n/* View Projection | Camera */\nRay getCamera(vec2 uv, vec3 origin, vec3 target) {\n  vec3 w = normalize(target - origin);\n  vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n  vec3 v = normalize(cross(u, w));\n  return Ray(origin, normalize(mat3(u, v, w) * vec3(uv, 1.5)));\n}","name":"Common","description":"","type":"common"}]}