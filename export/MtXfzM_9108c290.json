{"ver":"0.1","info":{"id":"MtXfzM","date":"1511354871","viewed":628,"name":"ellipse try","username":"cailuming","description":"elipse ring,some problems,but finally is does work","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926\n\n// draw a line segment\nvoid drawLine(out vec4 fragColor, in vec2 fragCoord,vec2 startP,vec2 endP,float linWidth){\n   vec2 lineDir=endP-startP;\n   \n   vec2 fragDir=fragCoord-startP;\n   \n   // keep the line coefficient bewteen [0,1] so that the projective dir on the \n   // lineDir will not exceed or we couldn't get a line segment but a line.\n   float lineCoe=clamp(dot(lineDir,fragDir)/dot(lineDir,lineDir),0.,1.);\n                       \n   vec2 projDir=lineCoe*lineDir;\n    \n   vec2 fragToLineDir= fragDir- projDir;\n    \n   \n   float dis=length(fragToLineDir);\n   \n   dis=linWidth/dis;\n   \n   fragColor += vec4(dis,dis,dis,dis);\n    \n}\n\n//draw a point which move along with an ellipse\nvoid ellipseTrack(out vec4 fragColor, in vec2 fragCoord,vec2 center,vec2 radius,vec3 color,float freq){\n \n    \n    vec2 fragDir=normalize(fragCoord-center);\n    \n    \n    float fragTheta = freq>0.?freq:iTime;\n    \n    float rate = radius.x/radius.y;\n    \n    float elipTheta= atan(rate*tan(fragTheta));\n    \n    if(fragDir.x<0.){\n        elipTheta+=PI;\n    }\n    \n    vec2 ellipsePos;\n    //if(sync){\n   //    ellipsePos=vec2(radius.x*cos(elipTheta)+center.x,radius.y*sin(elipTheta)+center.y);\n   // }else{\n       ellipsePos=vec2(radius.x*cos(fragTheta)+center.x,radius.y*sin(fragTheta)+center.y);\n   // }\n    \n  \n    float disToElipse=length(fragCoord-ellipsePos);\n    \n    \n    disToElipse=.01/disToElipse;\n\tfragColor += vec4(mix(color*disToElipse,vec3(disToElipse,disToElipse,0.),.5),disToElipse);\n    \n    drawLine(fragColor,fragCoord,center,ellipsePos,0.002);\n}\n\n\n// draw an ellipse ring\nvoid ellipseRing( out vec4 fragColor, in vec2 fragCoord,vec2 center,vec2 radius,vec3 color){\n    \n    vec2 fragDir=normalize(fragCoord-center);\n    \n    // thanks to FabriceNeyret2, I can evolute the angle just by one simple func\n    float fragTheta =atan(fragDir.y,fragDir.x);\n    \n    float rate = radius.x/radius.y;\n    // Also, the theta in circle is different from the ellipse,if you want evaluate the \n    // ellipse point with the same angle as circle, they have the following relationship.\n    // As in ellipse,epos={a*cos(theta),b*sin(theta)},so the tangent is b*sin(theta)/a*cos(theta);\n    // but in circle,cPos={a*cos(alpha),a*sin(alpha)},so the tangent is sin(alpha)/cos(alpha)\n    // so as you can see,the true angle we want is :\n    // given an angle, let tan(angle)=b*sin(theta)/a*cos(theta);\n    // then we can get theta=atan(a/b*tan(angle)),that it!\n    \n    float elipTheta= atan(rate*tan(fragTheta));\n    \n    // make some correction\n    if(fragDir.x<=0.){\n       elipTheta+=PI;\n    }\n    \n    vec2 ellipsePos=vec2(color.y*radius.x*cos(elipTheta)+center.x,color.y*radius.y*sin(elipTheta)+center.y);\n    \n    float disToElipse=length(fragCoord-ellipsePos);\n    \n    disToElipse=0.005/disToElipse;\n\tfragColor += vec4(mix(color*disToElipse,vec3(disToElipse,disToElipse,0.),.5),disToElipse);\n}\n\nvoid drawMisc1(out vec4 fragColor,vec2 uv, float freqs){\n     // the angle is different.\n\t // ellipse when radius components are not equal\n     vec2 pos=vec2(-0.2,0.);\n     vec2 radius=vec2(0.2,0.1);\n    \n     ellipseTrack(fragColor,uv,pos,radius,vec3(1.,.4,.1),0.);\n     ellipseRing(fragColor,uv,pos,radius,vec3(0.4,1,.1));\n   \n     // circle when radius components do be equal\n     ellipseTrack(fragColor,uv,pos,vec2(radius.x),vec3(0.,.4,1),0.);\n     ellipseRing(fragColor,uv,pos,vec2(radius.x),vec3(0.4,1,.1));\n}\n\nvoid drawMisc2(out vec4 fragColor,vec2 uv, float freqs){\n     vec2 pos=vec2(0.4,0.);\n     vec2 radius=vec2(0.3,0.15);\n    \n     ellipseTrack(fragColor,uv,pos,radius,vec3(1.,.4,.1),freqs);\n     ellipseRing(fragColor,uv,pos,radius,vec3(0.4,freqs,.1));\n   \n     // circle when radius components do be equal\n     ellipseTrack(fragColor,uv,pos,vec2(radius.x),vec3(0.,.4,1),freqs);\n     ellipseRing(fragColor,uv,pos,vec2(radius.x),vec3(0.4,freqs,.1));\n}\n\nvoid drawSin(out vec4 fragColor,vec2 uv, float freqs){\n     float disToSin=length(uv-vec2(uv.x,.3*freqs*sin(uv.x*freqs*20.)-.3));\n     disToSin=.006/disToSin;\n    \n     fragColor += vec4(disToSin,.1*freqs*disToSin,0.,disToSin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv= fragCoord/iResolution.y-vec2(0.5,0.5);\n     \n     // sampler for sound ,just for test,never used before\n     float freqs= smoothstep(0.,1.,texture( iChannel0, vec2( sin(iTime), 0.5 ) ).y);\n     vec4 col = vec4(0);\n     drawMisc1(col,uv,freqs);\n     drawMisc2(col,uv,freqs);\n     drawSin(col,uv,freqs);\n     \n     fragColor = col; \n}\n","name":"Image","description":"","type":"image"}]}