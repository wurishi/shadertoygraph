{"ver":"0.1","info":{"id":"ttGcWy","date":"1611669630","viewed":49,"name":"Draggable Handle","username":"desmarkie","description":"A quick example of how to use shaders for UI elements.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["simple","ui","twocolor"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n// draw a circle at pos x, of given size.\nfloat circle( float pos, float size, vec2 uv )\n{\n    \n    return 1.0 - step(size, distance(vec2(pos,0.5), uv));\n    \n}\n\n// draw a centered rectangle at given size\nfloat rect( vec2 size, vec2 uv )\n{\n    \n    float left = 1.0 - step(size.x, uv.x);\n    float right = 1.0 - step(size.x, 1.0-uv.x);\n    float top = 1.0 - step(size.y, uv.y);\n    float bottom = 1.0 - step(size.y, 1.0-uv.y);\n    \n    return clamp(top+bottom+left+right,0.0,1.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // book of shaders covers this\n    // it normalises the incoming UV coords so you don't stretch the image\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st.y *= iResolution.y/iResolution.x;\n\n    \n    // Progress in the app is set via the material/code. \n    //Here I've mapped it to the x coord / resolution so you can play\n    float progress = iMouse.x / iResolution.x;\n    //uncomment this line to update progress with time\n    //progress = mod(iTime / 3.0, 1.0);\n    \n    // this would also be a uniform or property set on the material\n    vec3 yellow = vec3(0.9960784, 0.8784314, 0.0);\n    \n    \n    // size of the handle\n    float handleRadius = 0.02;\n    // the outer cirlce has a radius of 0.02, so to keep it inside the shader\n    // we remap the progress values from [ 0 -> 1 ] to [ radius -> 1 - radius ]\n    float handleProgress = handleRadius + (progress * 0.96);\n    \n    // start with the middle rectangle and remove the handle radius from the width\n    float rectMid = 1.0 - rect( vec2( handleRadius, 0.495), st );\n    // the design had round ends, so add a couple of circles at each end (handleRadius & 1.0 - handleRadius)\n    // but we use the line height as the radius for these two\n    rectMid += circle( handleRadius, 0.005, st );\n    rectMid += circle( 1.0 - handleRadius, 0.005, st );\n    //finally clamp the values between 0-1\n    rectMid = clamp(rectMid, 0.0, 1.0);\n    \n    // now we need to split this value at the progress position \n    // so we can color the left hand side separately\n    float splitValue = step(st.x, handleProgress);\n    float rectLeft = rectMid * splitValue;\n    float rectRight = rectMid * ( 1.0 - splitValue );\n    \n    \n    // The main handle is a yellow circle with a black outline\n    // outer black circle\n    float circleOuter = circle( handleProgress, handleRadius, st );\n    // inner yellow circle\n    float circleInner = circle( handleRadius + (progress * 0.96), handleRadius - 0.0025, st);\n    \n    \n    // now put it all together!\n    \n    // start with the middle bar, multiply left part by chosen color, then add the right hand part\n    vec3 color = ( yellow * rectLeft ) + rectRight;\n    \n    // now multiply all of that by the outer circle so we 'cut out' that area\n    // using 1.0 - circleOuter here because the circle is value 1 and the edge is 0\n    // and we want the reverse :)\n    color *= 1.0 - circleOuter;\n    //and finally add the inner circle multiplied by our color\n    color += yellow * circleInner;\n    \n    fragColor = vec4(color,1.0);\n    \n}\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}