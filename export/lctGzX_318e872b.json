{"ver":"0.1","info":{"id":"lctGzX","date":"1711995907","viewed":92,"name":"Mean blending interpolation","username":"mrboggieman","description":"Interpolate 1d values (0:1). Try different interpolation modes by pressing:\n1 = Mean blending\n2 - 4 = Inverse distance mapping (power = 1, 2, 10)\n5 = Linear","likes":5,"published":1,"flags":16,"usePreview":0,"tags":["blending","interpolation","mean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float SQRT_2PI = 2.50662827463;\nconst float TAU = 6.28318530718;\nconst float E = 2.718281828;\nconst float EPSILON = 0.00001;\n\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_4 = 52;\nconst int KEY_5 = 53;\n\nfloat normal_dist(in float x, in float m, in float s) {\n    return pow(E, -0.5*pow((x-m)/s, 2.0)) / (s*SQRT_2PI);\n}\n\n// define two functions that we will interpolate (in 0:1 range)\nfloat from(in float t) {\n    float x = 4.0*(t - 0.5);\n    //return (normal_dist(x, -0.5, 0.1) + normal_dist(x, 0.5, 0.1)) / 4.0;\n    return (normal_dist(x, -0.9, 0.3) + normal_dist(x, 0.9, 0.3)) / 2.0;\n    //return (sin(t * TAU * 4.0) + 1.0) / 2.0;\n}\n\nfloat to(in float t) {\n    float x = 4.0*(t - 0.5);\n    //return normal_dist(x, 0.0, 1.0);\n    return (normal_dist(x, -1.0, 0.1) + normal_dist(x, 0.0, 0.1) + normal_dist(x, 1.0, 0.1)) / 4.0;\n}\n\n// linear interpolation\nfloat linear(vec2 uv) {\n    float from_value = from(uv.y);\n    float to_value = to(uv.y);\n\n    return mix(from_value, to_value, uv.x);\n}\n\n// inverse distance averaging interpolation\nfloat inverse_distance_averaging(vec2 uv, float power) {\n    float inv_dist_sum = 0.0;\n    float mean = 0.0;\n    \n    const int NUM_SAMPLES = 256;\n\n    for (int i=0; i<NUM_SAMPLES; i++) {\n        float sample_pos = (float(i) / float(NUM_SAMPLES));\n\n        float from_inv_dist = 1.0 / pow(max(EPSILON, distance(uv, vec2(0.0, sample_pos))), power);                           \n        inv_dist_sum += from_inv_dist;\n        mean += from(sample_pos) * from_inv_dist;\n        \n        float to_inv_dist = 1.0 / pow(max(EPSILON, distance(uv, vec2(1.0, sample_pos))), power);                           \n        inv_dist_sum += to_inv_dist;\n        mean += to(sample_pos) * to_inv_dist;\n    }\n\n    return mean / inv_dist_sum;\n}\n\nfloat mean_blending(vec2 uv) {\n    //only a subset of the inputs and outputs would cross our uv coord, we can compute the ranges\n    float from_start = clamp(uv.y - ((1.0 - uv.y) / (1.0 - uv.x)) * uv.x, 0.0, 1.0);\n    float from_end = clamp(uv.y - (-uv.y / (1.0 - uv.x)) * uv.x, 0.0, 1.0);\n\n    float to_start = clamp(uv.y/uv.x, 0.0, 1.0);\n    float to_end = clamp(((uv.y - 1.0)/uv.x) + 1.0, 0.0, 1.0);\n    \n    //sample the input and outputs that would go through the coord and average them\n    const int NUM_SAMPLES = 30;\n    float mean = 0.0;\n    float mean_samples = 0.0;\n    \n    for (int i=0; i<=NUM_SAMPLES; i++) {\n        float sample_pos = (float(i) / float(NUM_SAMPLES));\n\n        float from_pos = mix(from_start, from_end, sample_pos);\n        float to_pos = mix(to_start, to_end, sample_pos);\n        \n        //weight each sample to be gaussian so center samples have a larger impact\n        //float contribution = normal_dist(4.0*(sample_pos - 0.5), 0.0, 1.0);\n        float contribution = 1.0;\n        \n        mean_samples += contribution;\n        mean += mix(from(from_pos), to(to_pos), uv.x) * contribution;\n    }\n\n    return mean / mean_samples;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // scroll through the interpolation methods over time\n    int mode = 0; //int(iTime / 2.0) % 5;\n    \n    // if a key is down then show the selected interpolation\n    if (texelFetch(iChannel0, ivec2(KEY_1, 0), 0).x == 1.0) {\n        mode = 0;\n    } else if (texelFetch(iChannel0, ivec2(KEY_2, 0), 0).x == 1.0) {\n        mode = 1;\n    } else if (texelFetch(iChannel0, ivec2(KEY_3, 0), 0).x == 1.0) {\n        mode = 2;\n    } else if (texelFetch(iChannel0, ivec2(KEY_4, 0), 0).x == 1.0) {\n        mode = 3;\n    } else if (texelFetch(iChannel0, ivec2(KEY_5, 0), 0).x == 1.0) {\n        mode = 4;\n    }\n    \n    float mag = 0.0;\n\n    switch (mode) {\n        case 0: {\n            mag = mean_blending(uv);\n            break;\n        }\n        case 1: {\n            mag = inverse_distance_averaging(uv, 1.0);\n            break;\n        }\n        case 2: {\n            mag = inverse_distance_averaging(uv, 2.0);\n            break;\n        }\n        case 3: {\n            mag = inverse_distance_averaging(uv, 10.0);\n            break;\n        }\n        case 4: {\n            mag = linear(uv);\n            break;\n        }\n    }\n \n    fragColor = vec4(vec3(mag),1.0);\n}","name":"Image","description":"","type":"image"}]}