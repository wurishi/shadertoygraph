{"ver":"0.1","info":{"id":"MsByDm","date":"1492345629","viewed":328,"name":"Deform ray","username":"Loeizd","description":"yes","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["ray"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.141592653589\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    //vec3 offset = vec3(0.,0.,0.);\n    //c = c+offset;\n    vec3 q = mod(p,c)-0.5*c;\n    //return sdTorus( q , vec2(0.1, 0.05));\n    \n    float s = 0.1;\n    //s=  (1.-fract(iDate.w*2.))*0.01 + 0.09;\n    return sdBox( q , vec3(s));//vec3(0.1, 0.1, 0.1));\n}\n\n// Raymarching\nconst float rayEpsilon = 0.01;\nconst float rayMin = 0.1;\nconst float rayMax = 1000.0;\nconst int rayCount = 16;\n\n// Camera\n\nvec3 right = vec3(1, 0, 0);\nvec3 up = vec3(0, 1, 0);\n\n// Colors\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\nvec3 skyColor = vec3(0, 0, 0.);\nvec3 shadowColor = vec3(0, 0, 0);\n\nvec2 kaelidoGrid(vec2 p) { return vec2(step(mod(p, 2.0), vec2(1.0))); }\nvec3 rotateY(vec3 v, float t) { \n\tfloat cost = cos(t); float sint = sin(t);\n  \treturn vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost); }\nvec3 rotateX(vec3 v, float t) { \n\tfloat cost = cos(t); float sint = sin(t);\n  \treturn vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost); }\nvec3 rotateZ(vec3 p, float angle) { \n\tfloat c = cos(angle); float s = sin(angle);\n  \treturn vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z); }\n\n\nvec2 rotation(vec2 p, float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * p;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0., 0., -10);\n\tvec3 front = vec3(0.5,0.5,1.);//vec3(0, 0, 1.);//iTime+2.);   \n    \n    // Ray from UV\n\tvec2 uv = fragCoord.xy * 2.0 / iResolution.xy - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ray = normalize(front + right * uv.x + up * uv.y);\n    \n    // Color\n    vec3 color = vec3(0.);\n    \n    // Animation\n    //float translationTime = iTime * 0.5;\n    \n    // Raymarching\n    float t = 0.0;\n    for (int r = 0; r < rayCount; ++r)\n    {\n        //vec3 dist = float(r)*0.1*vec3(sin(iDate.w)*0.01,0., 0.);\n        // Ray Position\n        vec3 p = eye + ray * t;\n        //p.xy = rotation(p.xy, t*0.8*sin(iTime));\n        //p.yz = rotation(p.yz, t*0.08*sin(iTime*2.));\n        //p.z = p.z + iDate.w*1.5;\n        //p.y = p.y + sin(iDate.w*.2)*3.;\n        \n        // Distance to Sphere\n        float d = opRep(p,vec3(0.5,0.5,0.5));\n        \n        //d = sdBox( vec3(0.1,1.2010,1.20), vec3(1.2) );\n        \n        // Distance min or max reached\n        //if (d < rayEpsilon || t > rayMax)\n        if (d < rayEpsilon )\n        {\n            // Shadow from ray count\n            color = vec3(1. - float(r) / float(rayCount));\n            \n            // Sky color from distance\n            //color = mix(color, skyColor, smoothstep(rayMin, rayMax, t));\n            break;\n        }\n        \n        // Distance field step\n        t += d;\n    }\n    \n    // Hop\n    //fragColor = vec4(uv, 0., 0.);\n\tfragColor = 1.-vec4(color, 1);\n    //fragColor = 1.-vec4(t);\n}","name":"Image","description":"","type":"image"}]}