{"ver":"0.1","info":{"id":"lcSfW1","date":"1724882433","viewed":98,"name":"Pentagonal radial tiling","username":"shadertoyjiang","description":"from: jt's [url=https://www.shadertoy.com/view/lcBfWR]dodecagon triangle square tiling [/url]\n\ngolf it: [url=https://www.shadertoy.com/view/lcjBWz ]hexagon golf 352(299) chars[/url]\n\nWhen the mouse is on the right, there is no color.\n","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["spiral","tiling","pentagon","filling","setting"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 2024年8月29日\n//\n// 用全等的五边形无限平铺平面。\n\n// Use a pentagon to tile the plane\n//\n// Discovered from ：jt's - dodecagon triangle square tiling\n// www.shadertoy.com/view/lcBfWR\n//\n// golf:\n// www.shadertoy.com/view/lcjBWz\n//\n// Code collation： \n// https://beautifier.io/\n//\n// other:\n// \n// Shane's\n// https://www.shadertoy.com/view/NlcBRs\n//\n// FabriceNeyret2's\n// https://www.shadertoy.com/view/stcBRj\n\n\n\n\n\n// As far as I know, there are only 15 types of single pentagonal tiles (tessellations) in the world.\n// This can also tile the plane without leaving gaps, I don't know if it's one of them?\n// This distribution is a bit strange: it is not a complete \"parallelogram\" of tiles, but radial tiles, and it has and only one \"world\" center.\n// Fifteen structures can find a single smallest element that can be translated to fill the entire plane.\n// The hexagon in this figure has a total of 6 orientations(12 sector-shaped areas), which cannot be achieved by moving in parallel alone.\n// Pentagon: Use two regular triangles and a square to form a hexagon, then split the hexagon from the middle and divide it into two identical pentagons. All pentagons are congruent. \n// If you find these wrong, please let me know, thank you.\n//\n// This structure comes from JT's work \"Dodecagon Triangle Square Tiling\" ( www.shadertoy.com/view/lcBfWR )\n\n\n\n\n\n#define time ((iTime+7.6-10.) * .5)\n\nconst float PI = 3.14159265358979;\nconst float sq3 = sqrt(3.) * .5;\nconst vec2 cs30 = vec2(sq3, .5);\n\nvec3 hash2to3(vec2 p) { // Dave_Hoskins: www.shadertoy.com/view/4djSRW\n        vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n        p3 += dot(p3, p3.yxz + 33.33);\n        return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec2 center(vec2 p) {\n        vec2 t = vec2(1. + sq3, 1), // vec2(1.866,1),\n                k = vec2(.5, sq3),  // vec2(.5,.866), // cs30.yx,\n                f, s, a, i;\n        p /= t;\n        i = round(p); \n        if (mod(i.x, 2.) > .5) {\n                i.y += (p.y > i.y ? .5 : -.5);\n        }\n        f = p - i; \n        f *= t;\n        a = abs(f), s = sign(f);\n        a = a - .5; // 顶点 \n        if (dot(a, k) > 0.) i += vec2(1., .5) * s;\n        return i * t;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n        O = vec4(0);\n        vec2 R = iResolution.xy,\n                p = 7. * (U + U + .1 - R) / R.y,\n                k = vec2(-.5, sq3),               // 30 度角的正弦，余弦   vec2(-.5, .866),\n                m = normalize(vec2(1, 0) - cs30), // 15 度角的正弦，余弦   vec2(.2588,-.9659),\n                ofs = vec2(.5 + sq3, 0),\n                c5 = ofs * .4,                    // 五边形的中心，弄个假的\n                i, f, g;\n        float nvg = 1., dcnt, dedg;\n        if (p.x < 0.) nvg = -nvg;\n        if (p.y < 0.) nvg = -nvg;\n        p = abs(p);\n        if (dot(p, k) > 0.) nvg = -nvg, p = reflect(p, k);\n        if (p.x < 0.) nvg = -nvg;\n        if (p.y < 0.) nvg = -nvg;\n        p = abs(p);\n        if (dot(p, m) < 0.) nvg = -nvg, p = reflect(p, m), p.x -= 1.; // 15 度\n        p -= ofs;\n        i = center(p);\n        if (dot(i + ofs, m) < 0.) {\n                p = reflect(p + ofs, m) - ofs + cs30;\n                i = center(p);\n                nvg = -nvg;\n        }\n        f = p - i;\n        //float alf = clamp(sin(time)*1.2, -1.9,1.9);\n        float alf = clamp(sin(time)*1.2, -.9,.9);      \n        f.x *= nvg;\n        g = f;\n        f = abs(f);\n        f -= .5;\n        if (dot(f, m.yx) < 0.) f = reflect(f, m.yx);\n        dcnt = abs(dot(g, vec2(cos(alf), sin(alf))));\n        dedg = abs(f.y);\n        O += smoothstep(.45, .5, vec4(exp(-20. * min(dcnt, dedg))));\n        //\n        if(iMouse.x<R.x*.6){\n                O += exp(-12. * length(g - c5)) * (hash2to3(1. + c5).rgbb * .5 + .5);\n                O += exp(-12. * length(g + c5)) * (hash2to3(2. - c5).rgbb * .5 + .5);\n                O += .6 * hash2to3(i + 3. +0.* floor(iTime)).rgbb;\n        } else {\n                O = .8 - .3 * O;\n        }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}