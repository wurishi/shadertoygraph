{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"video","id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\n//\n// TEMPORAL DITHERING TEST IN LINEAR\n//\n\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return vec3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return vec3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\nF3 photoLuma=F3(0.2126,0.7152,0.0722);\nF1 PhotoLuma(F3 c){return dot(c,photoLuma);}\n\nF1 Noise(F2 n,F1 x){n+=x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Step1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Step2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0-c))*(\n  Step1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Step1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Step1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Step1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Step1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Step1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Step1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Step1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Step1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Used for stills.\nF3 Step3(F2 uv){\n F1 a=Step2(uv,0.07);    \n F1 b=Step2(uv,0.11);    \n F1 c=Step2(uv,0.13);\n #if 0\n  // Monochrome can look better on stills.\n  return F3(a);\n #else\n  return F3(a,b,c);\n #endif\n}\n\n// Used for temporal dither.\nF3 Step3T(F2 uv){\n F1 a=Step2(uv,0.07*fract(iTime));    \n F1 b=Step2(uv,0.11*fract(iTime));    \n F1 c=Step2(uv,0.13*fract(iTime));\n return F3(a,b,c);}\n\n#define STEPS 8.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n F2 uv=fragCoord.xy;\n F2 uv2=fragCoord.xy/iResolution.xy;F2 uv3=F2(uv2.x,1.0-uv2.y); \n F3 color=texture(iChannel0,uv2).rgb;\n F3 color2=texture(iChannel1,uv3*2.0).rgb;\n // BOTTOM: Show bands.\n if(uv2.y<0.1){color=F3(uv2.x);color=floor(color*STEPS+Step3(uv)*4.0)*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.2){color=F3(uv2.x);color=floor(color*STEPS)*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.3){color=F3(uv2.x);color=floor(color*STEPS+Step3T(uv)*4.0)*(1.0/(STEPS-1.0));}   \n // Show video and texture.\n else if(uv2.y<0.9){\n  if(uv2.x<0.3)color=color2;\n  color=Linear3(color);\n  // Add grain in linear space.\n  #if 0\n   // Slow more correct solutions.\n   #if 1\n    // Too expensive.\n    // Helps understand the fast solutions.\n    F3 amount=Linear3(Srgb3(color)+(4.0/STEPS))-color;\n   #else\n    // Less too expensive.\n    F1 luma=PhotoLuma(color);\n    // Implement this as a texture lookup table.\n    F1 amount=Linear1(Srgb1(luma)+(4.0/STEPS))-luma;\n   #endif\n  #else\n   // Fast solutions.\n   #if 1\n    // Hack 1 (fastest).\n    // For HDR need saturate() around luma.\n    F1 luma=PhotoLuma(color);\n    F1 amount=mix(\n     Linear1(4.0/STEPS),\n     Linear1((4.0/STEPS)+1.0)-1.0,\n     luma);\n   #else\n    // Hack 2 (slower?).\n    // For HDR need saturate() around color in mix().\n    F3 amount=mix(\n     F3(Linear1(4.0/STEPS)),\n     F3(Linear1((4.0/STEPS)+1.0)-1.0),\n     color);\n   #endif\n  #endif\n  color+=Step3T(uv)*amount;\n  // The following represents hardware linear->sRGB xform\n  // which happens on sRGB formatted render targets,\n  // except using a lot less bits/pixel.\n  color=max(F3(0.0),color);\n  color=Srgb3(color);\n  color=floor(color*STEPS)*(1.0/(STEPS-1.0));}\n // TOP: Show dither texture.\n else{color=Step3(uv)*1.0+0.5;}    \n fragColor=F4(color,1.0);}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Md2XWw","date":"1412834259","viewed":2004,"name":"LinearDitherForSRGB","username":"TimothyLottes","description":"Showing how to dither in linear for output in sRGB","likes":18,"published":1,"flags":0,"usePreview":1,"tags":["dithering"],"hasliked":0,"parentid":"","parentname":""}}