{"ver":"0.1","info":{"id":"clfcWn","date":"1691435262","viewed":354,"name":"Relativistic Tunnel Paradox ","username":"Amirk","description":"Too long a rocket to fit through a rotating cork screw tunnel by moving fast enough. The shift in planes of simultaneity will make the tail of the tunnel catch up the front, thus unscrewing it. Made a video about this: https://youtu.be/dmKo74CWdps","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["relativity","lorentz","eventhorizon","acceleration","retardation","hyperbolicmotion","rinddler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Relativistic Space Drive\" by Amirk. https://shadertoy.com/view/7sKBzz\n// 2023-07-28 16:10:39\n\n\n\n#define MAX_ITER 1500.\n#define MAX_DIST 30.\n#define SURF .0001\n\n\nvec4 fourvel = vec4(0,0,0,1);\nvec4 position =vec4(0);\nvec4 boost=vec4(0,0,0,0);\nvec3 orientation=vec3(1,0,0);\n\n\nvec3 SIZE= vec3(.1); \n\n//retardation effect ON/OFF:\nbool RETARD = false;\n//ray origin in the moving coords.\nvec4 RO, rd;\nvec2 m;\nmat4 TransformMat;\n\nvec3 col = vec3(0);\nfloat vv;\n\nfloat halo=0.;\nfloat cylinder,rocketD=MAX_DIST;   \n\nvec3 camPos=vec3(-6,1.5,0);\n\n\nvoid angularRepeat(const float a, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nvoid angularRepeat(const float a, const float offset, inout vec2 v)\n{\n    float an = atan(v.y,v.x);\n    float len = length(v);\n    an = mod(an+a*.5,a)-a*.5;\n    an+=offset;\n    v = vec2(cos(an),sin(an))*len;\n}\n\nfloat mBox(vec3 p, vec3 b)\n{\n\treturn max(max(abs(p.x)-b.x,abs(p.y)-b.y),abs(p.z)-b.z);\n}\n\n\n\n\nfloat dfRocketBody(vec3 p)\n{\n        \n    vec3 p2 = p;\n   \n    angularRepeat(PI*.25,p2.zy);\n    float d = p2.z;\n    d = max(d, (rot(PI*-.125)*( p2.xz+vec2(-.7,0))).y);\n    d = max(d, (rot(PI*-.25*.75)*(p2.xz+vec2(-0.95,0))).y);\n    d = max(d, (rot(PI*-.125*.5)*( p2.xz+vec2(-0.4,0))).y);\n    d = max(d, (rot(PI*.125*.25)*( p2.xz+vec2(+0.2,0))).y);\n    d = max(d, (rot(PI*.125*.8)*( p2.xz+vec2(.4,0))).y);\n    \n    d = max(d,-.8-p.x);\n    \n    d -= .5;\n    \n  \treturn d*.5;\n}\n\nfloat dfRocketFins(vec3 p)\n{\n    \n    p.yz*=rot(t*(1.+10.*boost.w));\n    vec3 pFins = p;\n    angularRepeat(PI*.5,pFins.zy);\n    pFins -= vec3(-1.0+cos(p.x+.3)*.8,.0,.0);\n    pFins.xz*=rot(-PI*.25);\n    float scale = 1.1-pFins.z*.6;\n    float d =mBox(pFins,vec3(.17,.03,3.0)*scale)*.5;\n    return d*.5;\n}\n\nfloat Jet(vec3 p)\n{\n    float d= length(p.yz);\n    if(p.x>0.2)d=20.;\n    \n    return d-p.x*.05;\n}\n\nfloat df(vec3 p)\n{           \n    p.x/=3.;\n    if(boost.xz!=vec2(0)){\n        p.xz*=rot(-atan(orientation.z,orientation.x));\n        }\n     \n    \n        \n    float proxy = length(p*vec3(2,1,1))-1.;// mBox(p,vec3(4.5,.8,.8));\n    if (proxy>10.)\n    \treturn proxy;\n    float dRocketBody=   dfRocketBody(p);\n    float dRocketFins=   dfRocketFins(p);\n    float dJet=  Jet(p);\n    if(boost.w==1.&&dJet<dRocketFins*5.&&dJet<.3){\n    halo+=.7;\n    }\n    \n    \n    halo+=.01/fourvel.w;\n    \n    return min(dRocketBody,dRocketFins);\n}\n\nvec3 nf(vec3 p)\n{\n    \n    vec2 e = vec2(0,0.005);\n    return normalize(vec3(df(p+e.yxx),df(p+e.xyx),df(p+e.xxy)));\n}\n\n\nvec3 rocket (vec3 pos) {\n     \n    vec3 normal = nf(pos);\n    \n    float ao = df(pos+normal*.125)*8.0 +\n        df(pos+normal*.5)*2.0 +\n    \tdf(pos+normal*.25)*4.0 +\n    \tdf(pos+normal*.06125)*16.0;\n    \n    ao=ao*.125+.5;\n    pos/=3.;\n    \n    if(boost.xz!=vec2(0)){\n        pos.xz*=rot(-atan(orientation.z,orientation.x));\n    }    \n    \n    \n        \n    vec3 materialColor = vec3(0);\n    vec3 blueColor = vec3(.1,.4,.9);\n    \n    float dRocketBody = dfRocketBody(pos);\n    float dRocketFins = dfRocketFins(pos);\n    float dRocket = min(dRocketBody, dRocketFins);\n       \n    \n    float r = dot(pos.yz,pos.yz);\n   \n    \n    if (dRocketBody<dRocketFins)\n    {\n    \n        if (pos.x<-.85)\n            if (pos.x<-1.2&&length(pos.yz)<.1)\n                materialColor = blueColor + vec3(0.005 / (r));\n            else\n                materialColor = vec3(.7,.1,.7);\n            else\n            {\n                if (pos.x>1.0)\n                    materialColor = vec3 (.7,.1,.7) ;\n                else\n                    materialColor = vec3(.6);\n            }\n    }\n    else\n    {\n        materialColor = vec3(.7,.1,.7);\n        if (length (pos - 0.3 * vec3(0.0, normal.yz)) > length (pos)*2.) { \n\n            materialColor -= vec3(.9,.3,1.5) * min(0.2, pos.x + 1.) / r;\n        }\n    }   \n    \n     return ao*materialColor;\n    \n}\n\n\n\nvec3 color( float s){\n    return vec3(1) - vec3(1.,1.,0)*smoothstep(.0,1., s)-\n            vec3(0.,.6,.6)*smoothstep(0.,1., -s);\n}\n\nvoid updateVel(){\n    // Fetch the fourvelocity from the Buffer A\n    boost= texelFetch( iChannel0, ivec2(5,5), 0);\n    orientation=texelFetch( iChannel0, ivec2(6,6), 0).xyz;\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n}\n\nvoid updatePos(){\n    // Fetch the fourposition from the Buffer B\n    \n    position =texelFetch( iChannel1, ivec2(0,0), 0 );\n}\n\n\n\nfloat sdBox(vec4 p , vec3 s){\n    \n    p.xyz=fract(p.xyz*.25)*4.-2.; //this creates the grid of reference cubes\n    p.yz*=rot(p.w*.5);\n    p.xyz= abs(p.xyz)-s;\n    return length(max(p.xyz,0.))+ min(max(p.x,max(p.y,p.z)),0.);  \n}\n\nfloat sdCylinder( vec4 p, vec2 h )\n{\n    \n    p.z-=4.;\n    p.xz*=rot(p.y*.3-p.w*.3-30.);\n    p.z+=4.;\n    \n    \n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    float outer= min(max(d.x,d.y),.0) + length(max(d,0.0));\n    vec2 d2 = abs(vec2(length(p.xz),p.y)) - (h+vec2(-.1,.1));\n    float inner= min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    return max(outer,-inner)*.5;\n}\n\n\nfloat getDist(vec4 q){\n    float dist= sdBox(q,SIZE);\n    \n   \n    \n    //the cylinders:\n    float len= 6.;\n    float d= 19.;\n    float rad=1.5;\n    q.x-=d;\n    cylinder= sdCylinder(q.zxyw, vec2(rad,len));\n    q.x+=1.*d;\n    \n    \n    dist = min(dist,cylinder);\n    q.xyz+=-position.xyz;\n    q.x/=fourvel.w;\n    \n    q.xyz*=3.;\n    rocketD=df(q.xyz)/3.;\n    dist= min(dist, rocketD);\n    \n    \n    if(RETARD){\n        return dist/(1.+.23*vv*c);\n    }else{\n        return dist/(1.+.35*vv*c);\n    }\n     //step size could probably be further optimized\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n\n    //the w-component determines how we look into past/future/present.\n}\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    float dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\nvoid getMaterial(vec4 q){\n    if(cylinder<50.*SURF){\n        //p.yz*=rot(p.w*.5);\n        col=vec3(2,0,.2);//*sin(atan(p.y,p.z)*10.)*sin(atan(p.y,p.z)*10.)*sin(p.x*2.)*sin(p.x*2.);\n    }\n    else if(rocketD<50.*SURF){\n        q.xyz-=position.xyz;\n        q.x/=gamma(fourvel.x/fourvel.w);\n        q.xyz*=3.;\n        col=rocket(q.xyz)*4.;\n        \n    }    \n   // else col= vec3(1);\n}\n\nmat4 getTransform(){\n    mat4 M= mat4(1,0,0,0,\n                 0,1,0,0,\n                 0,0,1,0,\n                 0,0,0,1);\n    if(iFrame>10){\n           for(int j=1; j<=4; j++)\n              M[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n    }\n    return M;\n}\n\n\n\n#define C(c) U.x-=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 text( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 position = vec2(.0,.85);\n    float FontSize = 6.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n   \n   \n   C(32);C(32);C(32);C(32);\n   \n   float gam = fourvel.w/c;\n   C(115);C(112);C(101);C(101);C(100);C(32)\n   ;C(46);C(48+int(floor(10.*length(fourvel.xyz)/gam)));\n   C(48+int(10.*fract(10.*length(fourvel.xyz)/gam))); C(99);\n   return O.xxxx;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    \n    updateVel();\n    //coordinate transform:  \n    TransformMat=getTransform();\n    updatePos();\n    \n    //ray's spacetime origin represented in \"stationary coordinates\":\n    if(m!=vec2(0)){\n        camPos.xy*=rot((m.y-.5)*PI);\n        camPos.xz*=rot(-(m.x-.5)*2.*PI);    \n    }\n    RO=position+TransformMat*vec4(camPos,0);\n    float zoom= 1.;\n    \n    //four-direction in our moving coords:\n    vec4 lookAt;\n    if(RETARD) //what we actually see as light reaches our eyes:\n        lookAt = vec4(c, 0, 0, -1);\n    else //the \"instantaneous geometry\" of spacetime/coordinates: \n        lookAt = vec4(c, 0, 0, 0);\n        \n    if(m!=vec2(0)){\n        lookAt.xy*=rot((m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n      \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n    \n    \n    \n    \n    //ray direction from moving coords to stationary coords:\n    rd= TransformMat*ray; \n    \n    \n    //just some helpful scaling factors for raymarching:\n    if(RETARD){\n         vv= max(0., -dot(fourvel.xyzw, rd.xyzw));\n    }else{\n         vv= abs(dot(fourvel.xyzw, rd.xyzw));\n    }\n    \n    \n    \n    //RAYMARCH IN SPACETIME calculated in stationary coordinates:\n    vec4 p=RO;          \n    \n    float d= RayMarch(p, rd, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*rd;\n          \n          col=color(dot(normalize(rd.xyz), fourvel.xyz));\n          getMaterial(p);\n\n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(-3,2,1)))*.5+.5;\n          col/=length(d)*.2;\n          col*=dif*dif;            \n      \n    }\n\n    col.xyz+=text(fragColor, fragCoord).xyz;\n\n\n    fragColor = vec4(col,1.0)+.3*halo*halo*vec4(.4,.2,1,1);\n    \n   \n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n\n//t is the proper time in rockets moving frame (counted in frames so\n//fps would not affect the physics)\n#define t float(iFrame)/frames\n#define PI 3.14159265359\n\n//SET AUTOBOOST TO 0. TO BOOST THE ROCKET YOURSELF\n#define AUTOBOOST 1.; \n\nconst float c=1.;//Not sure if everything works if you change c.\n\nfloat gamma(float b){\n\n    return pow(1.-b*b,-.5);\n}\n\n//for infinitesimal lorentz transforms it is faster to use this generator:\nmat4 LorentzGenerator(vec3 e){\n     float cc=c*c;\n        \n     return mat4(0 ,0  , 0 , -e.x/cc ,\n                0,   0,  0 ,  -e.y/cc ,\n                 0, 0,   0,   -e.z/cc  , \n                 -e.x, -e.y  , -e.z ,0);                            \n}\n\nmat4 Lorentz(vec3 v){\n     float beta= length(v)/c;\n     float gamma = gamma(beta);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n                 (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c,   gamma);                            \n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\nconst float dt = .007;\n\nvec2 m;\n\nvec3 handleKeyboard() {     \n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    vec3 acceleration=( up +  down) ;\n   \n    // steer with mouse\n   //     acceleration.xy*=rot((m.y-.5)*PI);\n     //   acceleration.xz*=rot(-(m.x-.5)*2.*PI);\n    \n    return acceleration*c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinates of the boost are in rockect coordinates\n    vec3  boost=vec3(0,0,0);\n    vec3 orientation=vec3(1,0,0);\n    \n    boost = handleKeyboard();\n    boost.x+=step(.02,t-10.5)*(1.- step(8.5,t-10.5))*AUTOBOOST;\n    orientation = texelFetch( iChannel0, ivec2(6, 6), 0).rgb;\n    \n    \n    //orientation is for the rockets alignment\n    orientation +=(boost-orientation)*.1;\n    if(ivec2(fragCoord)==ivec2(6,6))\n             fragColor= vec4(orientation,0);\n             \n    //this will transform coordinates from rockets frame to stationary\n    mat4 TransformMat = mat4(1,0,0,0,\n                        0,1,0,0,\n                        0,0,1,0,\n                        0,0,0,1);\n                                           \n    \n    if(boost==vec3(0)){ //if no keys are pressed we just copy from the previous frame\n        \n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(texelFetch( iChannel0, ivec2(5, 5), 0).rgb,0);\n        }\n        if(iFrame<10){\n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 vec4 fourvel = TransformMat*vec4(0,0,0,1); \n                 fragColor= fourvel;          \n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(boost,0);\n            }else if(ivec2(fragCoord)==ivec2(6,6)){\n            fragColor= vec4(orientation,0);\n            }\n            for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(0,j))\n                    fragColor=TransformMat[j-1];\n        }\n    }else{\n        boost/= texelFetch( iChannel0, ivec2(0, 0), 0).w; //to scale boost according to speed\n        //next the boost transform\n        mat4 NextBoost= Lorentz(-boost*dt);//mat4(1)+LorentzGenerator(-boost*dt); // \n                        \n        if(iFrame>10){\n                for(int j=1; j<=4; j++){\n                     TransformMat[j-1]=texelFetch( iChannel0, ivec2(0, j), 0);\n                 }  \n        }\n    \n        //how to transform to stationary coords\n        TransformMat*=NextBoost;\n\n        \n        if(ivec2(fragCoord)==ivec2(0,0)){\n             vec4 fourvel =TransformMat*vec4(0,0,0,1); \n             fragColor= fourvel;          \n        }else if(ivec2(fragCoord)==ivec2(5,5)){\n             fragColor= vec4(boost,1);\n        }else{\n            //StoreMatrix:\n            for(int j=1; j<=4; j++)\n                if(ivec2(fragCoord)==ivec2(0,j))\n                    fragColor=TransformMat[j-1];\n        }\n     }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//this buffer keeps track of rockets four-position\n//represented in \"stationary coordinates\"\n\n//proper time -step:\nconst float dt=.007;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // four position represented in stationary coords:\n    vec4 pos = texelFetch( iChannel1, ivec2(0, 0), 0);\n   \n    // fourvel represented in stationary coords:\n    vec4 fourvel = texelFetch( iChannel0, ivec2(0, 0), 0);\n    \n   // float gamma=fourvel.w/c;\n    \n    \n    \n    //four position represented in stationary coordinates:\n    pos += fourvel*dt;\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = pos;\n}","name":"Buffer B","description":"","type":"buffer"}]}