{"ver":"0.1","info":{"id":"wd2XDD","date":"1555418035","viewed":98,"name":"Bubbles' gravity","username":"linlin64","description":"Rays passing through the bubbles","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","physic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DIST_EPSILON 0.005\n\nstruct Plane {\n    vec3 o;\n    vec3 n;\n};\n\nstruct Sphere {\n    vec3 o;\n    float r;\n};\n\nstruct RayMarchingResult {\n    vec3 color;\n    float dist;\n    bool ground;\n    Sphere sphere;\n};\n    \nfloat sdPlane( vec3 p ) {return p.y;}    \n\nfloat sdSphere( vec3 p, float radius) {return (length(p)-radius);}\n\nRayMarchingResult opU (RayMarchingResult d1, RayMarchingResult d2) {\n    if (d1.dist < d2.dist) \n        return d1;\n    else \n        return d2;\n}\n\nvec3 getNormalFromMaterial(in vec2 UV)\n{\n    float scale = 0.05;\n    vec2 eps = vec2(0.001, 0.0);\n\n     float hx1 = texture(iChannel0, UV + eps.xy).x;\n     float hx2 = texture(iChannel0, UV - eps.xy).x;    \n     float hz1 = texture(iChannel0, UV + eps.yx).x;\n     float hz2 = texture(iChannel0, UV - eps.yx).x;    \n    \n    float z1;\n    float z2;\n    \n    z1 = hx1-hx2;\n    z2 = hz1-hz2;\n    \n    vec3 i = normalize(vec3(eps.x, 0.0, z1*scale));\n    vec3 j = normalize(vec3(0.0, eps.x, z2*scale));\n\n    return normalize(cross(i, j));\n}\n\nbool plane(Plane p, vec3 eye, vec3 ray, out vec3 color) {\n    float h = dot(eye - p.o, p.n);\n    float rh = dot(p.n, -ray);\n    \n    vec3 hp = eye + ray * (h/rh);\n    /*if(rh < 0.0) {\n    \tcolor = vec3(0.0, 0.0, 0.0);\n        return false;\n    }*/\n    \n    float t = iTime;\n  \n    vec3 i = vec3(1.0, 0.0, 0.0);\n    vec3 j = p.n;\n    vec3 k = vec3(0.0, 0.0, 1.0);\n    \n    mat3 mat = mat3(i,j,k);\n    \n    vec3 normal = mat * getNormalFromMaterial(hp.xz*0.1);\n    vec3 light = vec3(20.0, 11.0, 2.0);\n    vec3 lightRay = normalize(hp - light);\n    \n    float diffuse = -dot(lightRay, normal);\n    float ambiant = 0.8;       \n    vec3 reflectedLight  = reflect(lightRay, normal);\n    float hilight = pow(max(-dot(reflectedLight, ray),0.0), 2.0) * 0.25;\n    vec3 textureColor = texture( iChannel1, 0.1 * hp.xz ).xyz;\n    color = textureColor * (diffuse + ambiant) + hilight;\n    \n    return true;\n}\n\nfloat radius = 1.9;\n\nfloat modulos(float value, float modulo) {\n    return value - floor(value/modulo) * modulo;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nRayMarchingResult world(in vec3 m) {\n    RayMarchingResult res = RayMarchingResult(vec3(0.0, 0.0, 0.0), sdPlane(m), true, Sphere(vec3(1.0), 1.0));\n    \n    for(float i = 0.0; i < 16.0; ++i) {\n        vec3 pos = texture (iChannel3, vec2 (1.0 + i * 8.0, 1.0 + i * 8.0) / iResolution.xy).rgb;    \n        RayMarchingResult sphere = RayMarchingResult(vec3(modulos(i,2.0), modulos(i,3.0), modulos(i,5.0)), sdSphere(m-pos,radius), false, Sphere(pos, radius));\n        res = opU(res, sphere);\n    }\n    \n    \n \treturn res;\n}\n\nconst float zNear = 1.0;\nconst float zFar  = 400.0;\n\nvec3 computeNormal(in vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t     world(pos+eps.xyy).dist - world(pos-eps.xyy).dist,\n\t     world(pos+eps.yxy).dist - world(pos-eps.yxy).dist,\n\t     world(pos+eps.yyx).dist - world(pos-eps.yyx).dist);\n\treturn normalize(nor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float px = (-iResolution.x + 2.0 * fragCoord.x) / iResolution.y;\n    float py = (-iResolution.y + 2.0 * fragCoord.y) / iResolution.y;\n\n    vec2 p = vec2(px, py);\n\n    // camera movement\t\n    vec3 ro = vec3(13.0*sin(iTime*0.3),13.0 + 7.0*cos(iTime*0.1), 13.0*cos(iTime*0.3));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + ww );\n\n    vec3 planeNormal = vec3(0.0,1.0,0.0);\n    Plane plane1 = Plane(vec3(0.0,0.0,0.0), planeNormal);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float global = 0.0;\n    \n    float mixcolor = 0.25;\n    \n    float a1 = 1.33;\n    float a2 = 1.0 / 1.33;\n    \n    for(int i = 0; i < 3; ++i) {\n        float marchingDist = 0.0;\n        float nbIter = 0.0;\n        vec3 m;\n\n        RayMarchingResult result;\n        for(int i = 0; i < 50; i++) {\n            m = ro + rd * marchingDist;    \n            result = world(m);\n            if(result.dist < DIST_EPSILON || result.dist >= zFar) {\n                break;\n            }\n            global += result.dist;\n            marchingDist += result.dist;\n        }\n\n        if(result.ground) {\n        \tbreak;\n        }\n        \n        color = mix(color, result.color, mixcolor);\n        mixcolor = (1.0 - mixcolor) / 4.0;\n\n        vec3 i1 = normalize(refract(rd, m - result.sphere.o, a1));\n        float h = dot(i1, result.sphere.o - m);\n        ro = m + 2.0 * h * i1;\n        rd = normalize(refract(i1, result.sphere.o - ro, a2));\n        ro += rd * 0.1;\n    }\n    \n    vec3 colorplane;\n    if(plane(plane1, ro, rd, colorplane)) {\n        color = mix(color, colorplane, 0.5);\n    } else {\n        color = vec3(0.0, 0.0, 0.0); \n    }\n    \n    fragColor = vec4(color.x, color.y, color.z, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    for(float j = 0.0; j < 4.0; ++j) {\n        for(float index = 0.0; index < 4.0; ++index) {\n            float i = j * 4.0 * 8.0 + index * 8.0;\n\n            vec4 pos = texture (iChannel3, vec2(i + 1.0, i + 1.0) / iResolution.xy);\n            float speed = texture (iChannel3, vec2(i + 3.0, i + 3.0) / iResolution.xy).r;\n            float lastTime = texture (iChannel3, vec2(i + 5.0, i + 5.0) / iResolution.xy).r;\n            float init = texture (iChannel3, vec2(i + 7.0, i + 7.0) / iResolution.xy).r;\n\n            if(init < 1.0) {\n                pos = vec4(-2.0 * 4.0 + index * 4.0, 2.0 + random(vec2(1.0 + i)) * 5.0, -2.0 * 4.0 + j * 4.0, 0.0);\n                speed = 9.0;\n                lastTime = 0.0;\n                init = 1.0;\n            }\n\n            float deltaTime = iTime - lastTime;\n            if(deltaTime > 0.50) {\n            \tdeltaTime = 0.50;\n            }\n\n            float a = 9.81;\n            speed -= a * deltaTime;\n            pos.y += speed * deltaTime;\n\n            if(pos.y < 2.0) {\n                speed = -speed * 0.75;\n                pos.y = 2.0;\n                \n                if(speed < 1.0) {\n\t            \tspeed = 5.0 + random(vec2(1.0 + i)) * 10.0;\n    \t        }\n\t\t    }\n            \n            // pos\n            if(fragCoord.x >= i && fragCoord.x < i + 2.0\n               && fragCoord.y >= i && fragCoord.y < i + 2.0) {\n                fragColor = pos;\n            // speed\n            } else if(fragCoord.x >= i + 2.0 && fragCoord.x < i + 4.0\n               && fragCoord.y >= i + 2.0 && fragCoord.y < i + 4.0) {\n                fragColor = vec4(speed, 0.0, 0.0, 0.0);\n            // time\n            } else if(fragCoord.x >= i + 4.0 && fragCoord.x < i + 6.0\n               && fragCoord.y >= i + 4.0 && fragCoord.y < i + 6.0) {\n                fragColor = vec4(iTime, 0.0, 0.0, 0.0);\n            // init    \n            } else if(fragCoord.x >= i + 6.0 && fragCoord.x < i + 8.0\n               && fragCoord.y >= i + 6.0 && fragCoord.y < i + 8.0) {\n                fragColor = vec4(1.0, 0.0, 0.0, 0.0);\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}