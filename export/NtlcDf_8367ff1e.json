{"ver":"0.1","info":{"id":"NtlcDf","date":"1648826211","viewed":28,"name":"CGFS Ch 5","username":"mnopqr1","description":"Computer Graphics from Scratch Ch 5\nAdapted from https://gabrielgambetta.com/computer-graphics-from-scratch/","likes":1,"published":1,"flags":16,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFTY 99999.99\n\nstruct Ray { vec3 origin; vec3 direction; };\n\nstruct Sphere { vec3 center; float radius; vec3 color; float specular; };\n\n#define POINT 1 \n#define AMBIENT 2 \n#define DIRECTIONAL 3\n\nstruct Light { int type; float intensity; vec3 vector;};\n\nstruct Scene { Sphere[4] spheres; Light[3] lights; vec3 bgcolor; };\n\nstruct Intersection { int obj_id; float t; };\n\nfloat[2] intersectRaySphere(Ray ray, Sphere sphere) {\n    float[2] ts = float[2](INFTY,INFTY);\n    float r = sphere.radius;\n    vec3 CO = ray.origin - sphere.center;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0f * dot(CO, ray.direction);\n    float c = dot(CO, CO) - r * r;\n    float D = b * b - 4.0f * a * c;\n    if (D < 0.0f) return ts;\n    ts[0] = (-b + sqrt(D)) / (2.0f * a);\n    ts[1] = (-b - sqrt(D)) / (2.0f * a);\n    return ts;\n}\n\nIntersection closestIntersection(Scene scene, Ray ray, float t_min, float t_max) {\n    float closest_t = INFTY;\n    int closest_sphere_id = -1;\n    for (int i = 0; i < scene.spheres.length(); i++) {\n        float[2] ts = intersectRaySphere(ray, scene.spheres[i]);\n        for (int k = 0; k < 2; k++) {\n            if (t_min < ts[k] && ts[k] < t_max && ts[k] < closest_t) {\n                closest_t = ts[k];\n                closest_sphere_id = i;\n            }\n        }\n    }\n    return Intersection(closest_sphere_id, closest_t);\n}\n\nfloat lightIntensity(vec3 P, vec3 N, Scene scene, vec3 V, float s) {\n    float its = 0.0;\n    vec3 L = vec3(0,0,0);\n    float t_max;\n    for (int i = 0; i < scene.lights.length(); i++) {\n        Light light = scene.lights[i];\n        if (light.type == AMBIENT) {\n            its += light.intensity;\n        } else {\n            if (light.type == POINT) {\n                L = light.vector - P;\n                t_max = 1.0f;\n            } else {\n                L = light.vector; \n                t_max = INFTY;\n            }\n\n            // shadow check\n            Intersection shadow = closestIntersection(scene, Ray(P, L), 0.001, t_max);\n            if (shadow.obj_id != -1) {\n               continue;\n            }\n            // diffuse\n            float N_dot_L = dot(N,L);\n            if (N_dot_L > 0.0) {\n                its += light.intensity * N_dot_L / (length(N) * length(L));\n            }\n\n            // specular\n            if (s != -1.0) {\n                vec3 R = 2.0 * N * N_dot_L - L;\n                float R_dot_V = dot(R, V);\n                if (R_dot_V > 0.0f) {\n                    its += light.intensity * pow((R_dot_V) / (length(R) * length(V)), s);\n                }\n            }\n        }\n    }\n\n    return its;\n}\n\nvec3 traceRay(Scene scene, Ray ray, float t_min, float t_max) {\n    Intersection inters = closestIntersection(scene, ray, t_min, t_max);\n\n    if (inters.obj_id == -1) {\n        return scene.bgcolor;\n    }\n\n    Sphere closest = scene.spheres[inters.obj_id];\n    vec3 P = ray.origin + inters.t * ray.direction;\n    vec3 N = P - closest.center;\n    N = N / length(N);\n    return closest.color * lightIntensity(P, N, scene, -ray.direction, closest.specular);\n}\n\nvec2 canvasToWorld(vec2 v) {\n     vec2 uv = v / iResolution.xy - vec2(0.5);\n     vec2 ab = uv * vec2((iResolution.x)/(iResolution.y), 1.0);\n     return ab;\n }\n \n\nfloat buzz(float amp) {\n    return amp * cos(iTime);\n}\n     \nScene initScene() {\n    Sphere sp1 = Sphere(vec3(0,-1.0 + buzz(1.0),3.0), 1.0f, vec3(0.7333, 0.1412, 0.1412), 500.0);\n    Sphere sp2 = Sphere(vec3(2.0+buzz(0.3),0,4.0), 1.0f, vec3(0.6549, 0.6549, 0.9922), 500.0);\n    Sphere sp3 = Sphere(vec3(-2.0,0.5,4.0), 0.5f, vec3(0.1843, 0.3333, 0.1843), 10.0);\n    Sphere sp4 = Sphere(vec3(0,-5001,0), 5000.0f, vec3(0.8549, 0.8549, 0.8549), 1000.0);\n    Light li1 = Light(AMBIENT, 0.2, vec3(0,0,0));\n    Light li2 = Light(POINT, 0.6, vec3(2.0, 1.0, 0.0));\n    Light li3 = Light(DIRECTIONAL, 0.2, vec3(1.0,4.0,4.0));\n    return Scene(Sphere[4](sp1,sp2,sp3,sp4), \n               Light[3](li1, li2, li3),\n               vec3(0.0275, 0.2039, 0.4314));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 abc = vec3(canvasToWorld(fragCoord), 1.0);\n    Scene scene = initScene();\n    vec2 mouse = canvasToWorld(iMouse.xy);\n    Ray ray = Ray(vec3(0.0,5.0*mouse.y, 5.0*mouse.x), abc);\n    vec3 col = traceRay(scene, ray, 1.0f, INFTY);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}