{"ver":"0.1","info":{"id":"sdjyRh","date":"1643111881","viewed":77,"name":"Just a simple project for TN","username":"Vincent_Castronovo","description":"Just a simple project for Telecom Nancy \"graphisme par ordinateur\".","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cube","sphere","couleurs","miroir","telecom","nancy","tn","lampadaire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float FARAWAY = 1e30;\nconst float EPSILON = 1e-4;\n\nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\n/** TRUCS UTILES **/\n\n// Couleurs\nconst vec3 blanc = vec3(1, 1, 1);\nconst vec3 noir = vec3(0, 0, 0);\nconst vec3 rouge = vec3(0.9, 0.08, 0.08);\nconst vec3 bleu = vec3(0.1, 0.2, 0.9);\nconst vec3 jaune = vec3(1, 1, 0);\nconst vec3 orange = vec3(1, 0.5, 0);\nconst vec3 vert = vec3(0.1, 0.7, 0.3);\nconst vec3 mauve = vec3(0.8, 0.2, 0.8);\nconst vec3 rose = vec3(1.0, 0.4, 0.6);\nconst vec3 vertClair = vec3(0.7, 1.0, 0.7);\nconst vec3 bleuClair = vec3(0.5, 0.7, 1.0);\nconst vec3 blancLumiere = vec3(1.0, 1.0, 0.9);\nvec3 greyScale(in float level) {\n    return vec3(level, level, level);\n}\n\n// Zeros\nconst vec2 zero2 = vec2(0.0, 0.0);\nconst vec3 zero3 = vec3(0.0, 0.0, 0.0);\nconst vec3 ones3 = vec3(1.0, 1.0, 1.0);\n\n\n/** FIN TRUCS UTILES **/\n\nstruct Sphere {\n    vec3 Center;\n    float R;\n};\n\nstruct Box {\n    vec3 min;\n    vec3 max;\n};\n\n// Creates a Box with a given Center, hafh_width, half_height, and half_depth\nBox BoxWHD(in vec3 Center, in float half_w, in float half_h, in float half_d) {\n    vec3 offset = vec3(half_d, half_w, half_h);\n    vec3 min = Center - offset;\n    vec3 max = Center + offset;\n    return Box(min, max);\n}\n\n// Creates a Box with a given radius\nBox Cube(in vec3 Center, in float radius) {\n    vec3 offset = vec3(radius, radius, radius);\n    vec3 min = Center - offset;\n    vec3 max = Center + offset;\n    return Box(min, max);\n}\n\nstruct Material {\n    vec3 Kd; // diffuse color\n    vec3 Ke; // emissive color\n    vec3 Kr; // reflective material\n};\n\nstruct SphereObject {\n    Sphere sphere;\n    Material material;\n};\n\nstruct BoxObject {\n    Box box;\n    Material material;\n};\n\nMaterial diffuse(in vec3 Kd) {\n    return Material(Kd, zero3, zero3);\n}\n\nMaterial light(in vec3 Ke) {\n    return Material(zero3, Ke, zero3);\n}\n\nMaterial smallLight(in vec3 Ke) {\n    return Material(-ones3, Ke, zero3);\n}\n\nMaterial mirror(in vec3 Kd, in vec3 Kr) {\n   return Material(Kd, zero3, Kr);\n}\n\nconst int SPHERES_COUNT = 6;\nconst int BOXES_COUNT = 22;\nSphereObject spheres[SPHERES_COUNT];\nBoxObject boxes[BOXES_COUNT];\nint sphereIndex = 0;\nint boxIndex = 0;\n\nvoid init_scene(vec2 uv) {\n    float beta = float(iFrame) / 50.0;\n    mat3 rot3Z = mat3(cos(2.0*beta), -sin(2.0*beta),0.0 , \n                    sin(2.0*beta), cos(2.0*beta),0.0 ,\n                    0.0, 0.0, 1.0);\n                    \n    // Floor (1b)\n    boxes[boxIndex++] = BoxObject(\n        //Box(vec3(-5, 5, -1), vec3(5, -5, -10)),\n        Cube(vec3(0.0, 0.0, -6.0), 5.0),\n        diffuse(greyScale(0.8)));\n    \n    // Soleil (1s)\n    spheres[sphereIndex++] = SphereObject(\n        Sphere(vec3(0.0, 0.0, 0.15+0.2*cos(beta)), 0.24),\n        //diffuse(jaune));\n        diffuse(mix(texture(iChannel1, uv).rgb,jaune,0.7)));\n\n    // Terre (1s)\n    vec3 centreTerre = vec3(0.7, 0.7, 0.15+0.2*cos(beta))*vec3(cos(beta), sin(beta), 1.0);\n    spheres[sphereIndex++] = SphereObject(\n        Sphere(centreTerre, 0.1),\n        diffuse(bleu));\n\n    // Lune (1s)\n    vec3 centreLune = centreTerre + rot3Z*vec3(0.18, 0.0, 0.0);\n    vec4 texL = texture(iChannel0, uv);\n    spheres[sphereIndex++] = SphereObject(\n        Sphere(centreLune, 0.05),\n        //diffuse(greyScale(0.5)));\n        diffuse(texL.rgb));\n        \n    // Sphere miroir (1s)\n    vec3 centreMiroir = vec3(0.6, 0.6, 0.15+0.5*cos(beta))*vec3(-cos(beta+2.0), sin(beta+2.0), 1.0);\n    spheres[sphereIndex++] = SphereObject(\n        Sphere(centreMiroir, 0.12),\n        mirror(vec3(0.2, 0.2, 0.2), vec3(0.8, 0.8, 0.8)));\n        \n    // Lampadaire (8b, 1s)\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-1.0, 1.0, -0.3), .03, 0.7, .03),\n        diffuse(greyScale(0.1)));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-1.0, 1.0, 0.4), .12, 0.01, .12),\n        diffuse(greyScale(0.1)));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-1.0, 1.0, 0.6), .12, 0.01, .12),\n        diffuse(greyScale(0.1)));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-1.11, 1.11, 0.5), .01, 0.1, .01),\n        diffuse(greyScale(0.1)));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-1.11, 0.89, 0.5), .01, 0.1, .01),\n        diffuse(greyScale(0.1)));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-0.89, 1.11, 0.5), .01, 0.1, .01),\n        diffuse(greyScale(0.1)));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-0.89, 0.89, 0.5), .01, 0.1, .01),\n        diffuse(greyScale(0.1)));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(-1.0, 1.0, 0.45), .01, 0.05, .01),\n        diffuse(greyScale(0.1)));\n    spheres[sphereIndex++] = SphereObject(\n        Sphere(vec3(-1.0, 1.0, 0.5), 0.05),\n        smallLight(vert * (cos(beta + 10.0) + 1.1)));        \n\n    // Cube rouge (1b)\n    vec3 centreCR = vec3(0.4, -0.9, -0.8);\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(centreCR, .2, .2, .2),\n        diffuse(rouge));\n        \n    // Tour d'enfant (12b)\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.4, 1.0, -0.9), .1, .1, .1),\n        diffuse(mauve));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.7, 1.0, -0.9), .1, .1, .1),\n        diffuse(bleuClair));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.4, 1.3, -0.9), .1, .1, .1),\n        diffuse(noir));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.7, 1.3, -0.9), .1, .1, .1),\n        diffuse(vert));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.55, 1.3, -0.7), .08, .08, .08),\n        diffuse(rose));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.55, 1.0, -0.7), .08, .08, .08),\n        diffuse(blanc));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.4, 1.15, -0.7), .08, .08, .08),\n        diffuse(jaune));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.7, 1.15, -0.7), .08, .08, .08),\n        diffuse(vertClair));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.55, 1.15, -0.53), .09, .09, .09),\n        diffuse(rouge));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.53, 1.16, -0.37), .06, .06, .06),\n        diffuse(noir));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.56, 1.15, -0.24), .06, .06, .06),\n        diffuse(vert));\n    boxes[boxIndex++] = BoxObject(\n        BoxWHD(vec3(0.58, 1.12, -0.13), .05, .05, .05),\n        diffuse(blanc));\n\n    // Light (1s)\n    spheres[sphereIndex++] = SphereObject(\n        Sphere(vec3(10.0, 10.0, 25.0), EPSILON),\n        light(blanc));\n\n}\n\nvec3 boxCenter(in BoxObject boxObj) {\n    return (boxObj.box.min + boxObj.box.max) / 2.0;\n}\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t) {\n    vec3 CO = R.Origin - S.Center;\n    float a = dot(R.Dir, R.Dir);\n    float b = 2.0 * dot(R.Dir, CO);\n    float c = dot(CO, CO) - S.R * S.R;\n    float delta = b * b - 4.0 * a * c;\n    if (delta < 0.0) {\n        return false;\n    }\n    t = (-b - sqrt(delta)) / (2.0 * a);\n    return true;\n}\n\nvoid swap(inout float a, inout float b) {\n    float temp = a;\n    a = b;\n    b = temp;\n}\n\nbool intersect_box(in Ray R, in Box C, out float t) {\n    float tmin = (C.min.x - R.Origin.x) / R.Dir.x;\n    float tmax = (C.max.x - R.Origin.x) / R.Dir.x;\n\n    if (tmin > tmax)\n        swap(tmin, tmax);\n\n    float tymin = (C.min.y - R.Origin.y) / R.Dir.y;\n    float tymax = (C.max.y - R.Origin.y) / R.Dir.y;\n\n    if (tymin > tymax)\n        swap(tymin, tymax);\n\n    if ((tmin > tymax) || (tymin > tmax))\n        return false;\n\n    if (tymin > tmin)\n        tmin = tymin;\n\n    if (tymax < tmax)\n        tmax = tymax;\n\n    float tzmin = (C.min.z - R.Origin.z) / R.Dir.z;\n    float tzmax = (C.max.z - R.Origin.z) / R.Dir.z;\n\n    if (tzmin > tzmax)\n        swap(tzmin, tzmax);\n\n    if ((tmin > tzmax) || (tzmin > tmax))\n        return false;\n\n    if (tzmin > tmin)\n        tmin = tzmin;\n\n    if (tzmax < tmax)\n        tmax = tzmax;\n\n    t = tmin;\n    return true;\n}\n\nRay reflect_vector(in Ray I, in vec3 P, in vec3 N) {\n    return Ray(\n        P,\n        -2.0*dot(N,I.Dir)*N + I.Dir\n    );\n}\n\nbool shadow(in Ray R) {\n    for (int i = 0; i < spheres.length(); ++i) {\n        float t;\n        if (\n            spheres[i].material.Ke == zero3 &&\n            intersect_sphere(R, spheres[i].sphere, t) &&\n            t > EPSILON && t < 1.0)\n        {\n            return true;\n        }\n    }\n    for (int i = 0; i < boxes.length(); ++i) {\n        float t;\n        if (\n            boxes[i].material.Ke == zero3 &&\n            intersect_box(R, boxes[i].box, t) &&\n            t > EPSILON && t < 1.0)\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\nconst vec3 shadowVec3 = vec3(0.2, 0.2, 0.2);\n\nvec3 lighting(in vec3 P, in vec3 N, in Material material, in vec3 baseColor) {\n    if (material.Ke != zero3) {\n        return material.Ke;\n    }\n\n    vec3 result = baseColor;\n\n    for (int i = 0; i < spheres.length(); ++i) {\n        if (spheres[i].material.Ke != zero3) {\n            vec3 Center = spheres[i].sphere.Center;\n            Ray R2 = Ray(P, Center);\n\n            vec3 E = Center - P;\n            float lamb = max(0.0, dot(E, N) / length(E));\n            \n            // if small light\n            if (spheres[i].material.Kd == -ones3) {\n                result += 0.5*lamb * material.Kd * spheres[i].material.Ke;\n            } else { // if normal light\n                result += lamb * material.Kd * spheres[i].material.Ke;\n            }\n\n            if (shadow(R2)) {\n                result -= shadowVec3;\n            }\n        }\n    }\n\n    for (int i = 0; i < boxes.length(); ++i) {\n        if (boxes[i].material.Ke != zero3) {\n            vec3 Center = boxCenter(boxes[i]);\n            Ray R2 = Ray(P, Center);\n\n            vec3 E = Center - P;\n            float lamb = max(0.0, dot(E, N) / length(E));\n            //result += lamb * material.Kd * boxes[i].material.Ke;\n            // if small light\n            if (boxes[i].material.Kd == -ones3) {\n                result += 0.5*lamb * material.Kd * boxes[i].material.Ke;\n            } else { // if normal light\n                result += lamb * material.Kd * boxes[i].material.Ke;\n            }\n\n            if (shadow(R2)) {\n                result -= shadowVec3;\n            }\n        }\n    }\n\n    return result;\n}\n\nbool nearest_intersection(\n    in Ray R, \n    out vec3 P, out vec3 N, out Material material\n) {\n    const float FARAWAY=1e30; \n    float t = FARAWAY;\n\n    for(int i=0; i<spheres.length(); ++i) {\n        float cur_t;\n        if(\n            intersect_sphere(R, spheres[i].sphere, cur_t) \n            && cur_t < t && cur_t > EPSILON && cur_t > 0.0\n        ) {\n            t = cur_t;\n            P = R.Origin + t*R.Dir;\n            N = normalize(P - spheres[i].sphere.Center);\n            material = spheres[i].material;\n        } \n    }\n    for(int i=0; i<boxes.length(); ++i) {\n        float cur_t;\n        if(\n            intersect_box(R, boxes[i].box, cur_t) \n            && cur_t < t && cur_t > EPSILON && cur_t > 0.0\n       ) {\n            t = cur_t;\n            P = R.Origin + t*R.Dir;\n            N = normalize(P - boxCenter(boxes[i]));\n            material = boxes[i].material;\n       } \n    }\n    return (t != FARAWAY);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    init_scene(uv);\n\n    float beta = sin(float(iFrame) / 100.0);\n    float s = (sin(beta));\n    float c = (cos(beta));\n\n    Camera C = camera(\n        vec3(2.0 * c, 3.0 * s, 0.5 * c), // Obs en mouvement\n        //vec3(2.0, 0.0, 0.5), // Obs fixe\n        vec3(0.0, 0.0, -0.4),            // LookAt\n        60.0);                           // Aperture\n\n    Ray R = launch(C, fragCoord);\n\n    fragColor = vec4(0.5, 0.75, 0.9, 1.0);\n\n    float t = FARAWAY;\n\n    vec3 P;            // Point courant\n    vec3 N;            // Normale\n    Material material; // Couleur\n\n    if(nearest_intersection(R, P, N, material)) {\n        fragColor.rgb = lighting(P,N,material, vec3(0.1, 0.1, 0.1));\n        if(material.Kr != zero3) {\n            vec3 Kr = material.Kr;\n            R = reflect_vector(R, P, N);   \n            if(nearest_intersection(R, P, N, material)) {\n                fragColor.rgb = \n                    Kr*lighting(P,N,material, vec3(0.1, 0.1, 0.1));\n            } else {\n                fragColor = vec4(0.5, 0.75, 0.9, 1.0)*0.95;\n            }\n\n        }\n    } \n\n}\n","name":"Image","description":"","type":"image"}]}