{"ver":"0.1","info":{"id":"slByDR","date":"1649447123","viewed":171,"name":"Simple3dFlower","username":"NtFreX","description":"a simple 3d flower, part of my intro to ray marching learning path","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","helloworld","flower"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.001\n#define EPSILON 0.000001\n#define UNDERSTEP 0.7\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nvec4 smoothUnionSDF(vec4 d1, vec4 d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec4( mix( d2.x, d1.x, h ) - k*h*(1.0-h), mix(d2.yzw, d1.yzw, h));\n}\n\nfloat sdPlane(vec3 p, float h) {\n    return p.y - h;\n}\n\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec4 cp(vec4 sd1, vec4 sd2) {\n    return (sd1.x < sd2.x) ? sd1 : sd2;\n}\n\nmat4 lookAt(vec3 eye, vec3 target, vec3 up) {\n\tvec3 z = normalize(eye - target);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n    mat4 translation = mat4(\n        vec4(1.0, 0.0, 0.0, eye.x),\n    \tvec4(0.0, 1.0, 0.0, eye.y),\n        vec4(0.0, 0.0, 1.0, eye.z),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n    mat4 rotation = transpose(\n        mat4(\n            vec4(x, 0.0),\n            vec4(y, 0.0),\n            vec4(z, 0.0),\n            vec4(0.0, 0.0, 0.0, 1.0)\n        )\n    );\n    return translation * rotation;\n}\n\nvec3 getRayDir(mat4 camera, float fov, vec2 pixel) {\n    vec2 p = 2.0 * ((pixel / iResolution.xy) - vec2(0.5, 0.5));\n    vec2 h = vec2(\n        tan(fov / 2.0) * (iResolution.x / iResolution.y), \n        tan(fov / 2.0)\n    );\n    vec3 pCam = vec3(p * h, -1.0);\n\treturn normalize((inverse(camera) * vec4(pCam, 0.0)).xyz);\n}\n\nvec4 sdFlower(vec3 p, float phaseShift) {\n    float phase = abs(sin((iTime + phaseShift)*.2)) *  3.;\n    vec4 dStem = vec4(sdCappedCylinder(p - vec3(sin(p.y*10.) * .1, 0., cos(p.y*10.) * .1), clamp(.2 * phase / 3., .04, 1.), phase), .1, .7, .1);\n    \n    float leave1Phase = clamp(phase, 1., 2.) - 1.;\n    float dLeave1 = min(\n            sdEllipsoid(rotateX(.8) * (p - vec3(0, 1., .5 * leave1Phase)), vec3(sin(p.y) * .6, .6, sin(p.y) * .2) * leave1Phase),\n            sdEllipsoid(rotateX(-.8) * (p - vec3(0, 1., -.5 * leave1Phase)), vec3(sin(p.y) * .6, .6, sin(p.y) * .2) * leave1Phase));\n    \n    float leave2Phase = clamp(phase, 2., 3.) - 2.;\n    float dLeave2 = min(\n            sdEllipsoid(rotateZ(.8) * (p - vec3(-.5 * leave2Phase, 2., 0)), vec3(sin(p.y-1.) * .2, .6, sin(p.y - 1.) * .6) * leave2Phase),\n            sdEllipsoid(rotateZ(-.8) * (p - vec3(.5 * leave2Phase, 2., 0)), vec3(sin(p.y-1.) * .2, .6, sin(p.y - 1.) * .6) * leave2Phase));\n    \n    float flowerR = .9;\n    float flowerPhase = clamp(phase, 3. - flowerR, 3.) -3. + flowerR;\n    float dFlower = sdSphere(p - vec3(sin(p.y*10.)* .1, 3. - flowerR + flowerPhase * 1.2, cos(p.y*10.) * .1), abs(sin(p.y*20.))*.1*flowerPhase+ flowerR * flowerPhase);\n    \n    vec4 hit = dStem;\n    hit = cp(smoothUnionSDF(dStem, vec4(dLeave1, .5, .7, .1), .05), hit);\n    hit = cp(smoothUnionSDF(dStem, vec4(dLeave2, .5, .7, .1), .05), hit);\n    hit = cp(smoothUnionSDF(dStem, vec4(dFlower, .7, .2, .3), .1), hit);\n    return hit;\n}\n\nvec4 getDist(vec3 p) {\n    vec4 dPlane = vec4(sdPlane(p, 0.), .2, .2, .2);\n    //vec4 dFlower = sdFlower(rotateY(mod(p.x, 6.) / mod(p.z, 6.)) * vec3(mod(p.x, 20.) - 3., p.y, mod(p.z, 20.) - 3.), sin(p.z/p.x)*5.);\n    vec4 dFlower = sdFlower(p, 0.);\n    \n    vec4 hit = dPlane;\n    hit = cp(dFlower, hit);\n    return hit;\n}\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n float dO = 0.;\n vec4 dS = vec4(0);\n for(int i = 0; i < MAX_STEPS; i++) {\n     vec3 p = ro + dO * rd;\n     dS = getDist(p);\n     dO += dS.x * UNDERSTEP;\n     if(dS.x < SURFACE_DIST || dO > MAX_DIST) break;\n }\n return vec4(dO, dS.y, dS.z, dS.w);\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p).x;\n    vec2 e = vec2(EPSILON, 0);\n    vec3 n = d - vec3(\n        getDist(p - e.xyy).x,\n        getDist(p - e.yxy).x,\n        getDist(p - e.yyx).x);\n    return normalize(n);\n}\n\nvec3 getPointLight(vec3 p, vec3 lightPos, vec3 n, vec3 fragToLight, vec3 fragToCam, vec3 texColor, vec3 lightColor) {\n    float valDiffuse = max(0.0, dot(n, fragToLight));\n    \n    float d = rayMarch(p + n * SURFACE_DIST, fragToLight).x;\n    if(d < length(lightPos-p)) {\n        return valDiffuse * texColor * lightColor * .1;\n    }\n    \n    vec3 blinnH = normalize(fragToLight + fragToCam);\n    float valSpecular = pow(max(0.0, dot(n, blinnH)), 50.);\n    return valDiffuse*texColor*lightColor + valSpecular*lightColor;\n}\n\nvec3 getLight(vec3 p, vec3 cam, vec3 col) {\n    vec3 lightPos = vec3(-5, 2.+abs(sin(iTime*.1))*2., 0);\n    vec3 lightPos1 = vec3(5, 2.+abs(sin(iTime*.1))*2., 0);\n    vec3 lightPos2 = vec3(0, 2.+abs(sin(iTime*.1))*2., -5);\n    vec3 lightPos3 = vec3(0, 2.+abs(sin(iTime*.1))*2., 5);\n    vec3 ln = normalize(lightPos - p);\n    vec3 ln1 = normalize(lightPos1 - p);\n    vec3 ln2 = normalize(lightPos2 - p);\n    vec3 ln3 = normalize(lightPos3 - p);\n    \n    \n    vec3 lightCol = vec3(.7, .7, .7);\n    vec3 n = getNormal(p);\n    vec3 cn = normalize(cam - p);\n    \n    return \n        getPointLight(p, lightPos, n, ln, cn, col, lightCol) + \n        getPointLight(p, lightPos1, n, ln1, cn, col, lightCol) +\n        getPointLight(p, lightPos2, n, ln2, cn, col, lightCol) +\n        getPointLight(p, lightPos3, n, ln3, cn, col, lightCol);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //vec3 ro = vec3(0., 2.5, 10.);\n    vec3 ro = vec3(sin(iTime*.5) * 10., 4.5, cos(iTime*.5) * 10.);\n    vec3 target = vec3(0.0, 2.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    float fov = radians(45.0 + sin(iTime*.04) * 10.);\n    \n    mat4 camera = lookAt(ro, target, up); \n    vec3 rd = getRayDir(camera, fov, fragCoord);\n    vec4 d = rayMarch(ro, rd);\n    if(d.x <= MAX_DIST) {//sqrt(pow(MAX_DIST, 2.) + pow(length(ro - target - rd), 2.))) {\n        vec3 p = ro + rd * d.x;\n        vec3 dif = getLight(p, ro, d.yzw);\n        fragColor = vec4(dif, 1.0);\n        //fragColor = vec4(vec3(d.x * .05), 1.);\n    } else {\n        vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n        vec3 col =  -vec3(.5, .5, 0.) * uv.y + 0.5;\n        fragColor = vec4(col, 1.0);\n    }\n}","name":"Image","description":"","type":"image"}]}