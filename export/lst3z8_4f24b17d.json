{"ver":"0.1","info":{"id":"lst3z8","date":"1448173812","viewed":188,"name":"Sky n Plane","username":"AkshayDhok","description":"Simple Ray marched sphere. Also added sky and ground to make the scene somewhat prettier.\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sun","sphere","sky","plane"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"\nvec2 sun_position_shift = vec2( 1.0,-0.5);\n\nvec4 SkyColor = vec4(0.3, 0.3, 0.5, 1.0);\n\nvec4 GroundColor = vec4(0.4, 0.3, 0.1, 1.0);\n\nfloat Brightness = 0.5; \n\n//more steps you take more accurate will be the results\n// less steps color gets fadded\nconst int maxSteps = 10;\n\nfloat sphereRadius = 0.15;\n\n//min considerable distance to break marching \nfloat epsilon = 0.01;\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n//returns distance of point p from sphere of given radius \nfloat distSphere(vec3 p, float radius)\n{\n    //if point is outside the radius it will return +ve\n    // else it will return -ve value\n    return length(p) - radius;\n}\n\n//Standard ray march implementation\nfloat raymarch(vec3 rayOrigin, vec3 rayDirection)\n{\n    float t = 0.0;\n    for(int i = 0; i < maxSteps; ++i)\n    {\n        //pick a point p from origin along rayDirection\n        //at distance step t. (addition of 2 vectors)\n        vec3 p = rayOrigin + rayDirection * t; \n        \n        //calculate distance of p from sphere\n        float d = distSphere(p, sphereRadius);\n        \n        \n        //increment the step value by distance\n        t += d;\n        \n        //if we are close enough to target pixel. break\n        if(d < epsilon)\n        {\n            break;\n        }\n    }\n    return t;\n}\n\n//Function returns the groung and sky shade besed on uv.y \nvec4 DrawSkyNplane(vec2 uv)\n{\n    vec4 color;\n    // above 0 is sky below is ground\n    if(uv.y > 0.0)\n    {\n        //adding gradient by adding uv.y value.\n        color = SkyColor + (uv.y * Brightness); //multiply by brightness\n        \n        //if brightness is high, change in y will be more giving bright color\n    }\n    else\n    {\n        color = GroundColor + (-uv.y * Brightness);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //map uv in 0-1 range\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    //shift uv to -1 to 1 range\n    uv = uv * 2.0 - 1.0;\n    //correct aspect ratio\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //screen goes from 0 to 1 in x and y\n    // eye (camera) is at center\n    vec3 eye   = vec3(0, 0, -1);\n    \n    //ray vector starts from origin in direction of uv \n    //as uv covers all the pixels on screen thus ray\n    //goes in all direction in +ve z axis. \n    vec3 ray = normalize(vec3(uv + sun_position_shift,1.0));\n    \n    //origin of ray should be eye position\n    vec3 rayOrigin = normalize(eye);\n\n    \n    float t = raymarch(rayOrigin, ray);\n    \n    vec4 color = vec4(1.0/t) + DrawSkyNplane(uv);\n    \n    fragColor = color;\n}","name":"","description":"","type":"image"}]}