{"ver":"0.1","info":{"id":"XstcRS","date":"1519369626","viewed":201,"name":"Gradient Perlin FBM 2D","username":"Aethersong","description":"Gradient Perlin FBM Noise\n\nLeft - No FBM\nRight - FBM","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","perlin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// References\n// https://thebookofshaders.com/11/\n// https://thebookofshaders.com/13/\n// http://flafla2.github.io/2014/08/09/perlinnoise.html\n// http://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch05.html\n// https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter26.html\n\n// Random\nvec2 Random2( vec2 xy )\n{\n    xy = vec2( dot( xy, vec2( 127.1, 311.7 ) ),\n              dot( xy, vec2( 269.5,183.3 ) ) );\n    \n    return -1.0 + 2.0 * fract( sin( xy ) * 43758.5453123 );\n}\n\n// Perlin Noise\nfloat Noise( vec2 xy )\n{\n    vec2 i = floor( xy );\n    vec2 f = fract( xy );\n          \n    // Cubic Hermine Curve ( Smoothstep( 0.0, 1.0, f )\n    //vec2 t = f * f * ( 3.0 - 2.0 * f );\n    \n    // Fifth Degree Interpolator\n    // Remove Artifacts ( eg. when bumpmapping )\n    vec2 t = f * f * f * ( f * ( f * 6.0 - 15.0 ) + 10.0 ); \n    \n    // Four Gradients of 2D Tile\n    vec2 g1 = Random2( i + vec2( 0.0, 0.0 ) );\n    vec2 g2 = Random2( i + vec2( 1.0, 0.0 ) );\n    vec2 g3 = Random2( i + vec2( 0.0, 1.0 ) );\n    vec2 g4 = Random2( i + vec2( 1.0, 1.0 ) );\n\n    \n    // Calculate Influence Values\n    // ( Influence Value is Dot between Gradient and Distance Vec )\n    float iv1 = dot( g1, f - vec2( 0.0, 0.0 ) );\n    float iv2 = dot( g2, f - vec2( 1.0, 0.0 ) );\n    float iv3 = dot( g3, f - vec2( 0.0, 1.0 ) );\n    float iv4 = dot( g4, f - vec2( 1.0, 1.0 ) );\n    \n    // Interpolate Between Influence Values\n    return( mix( mix( iv1, iv2, t.x ), mix( iv3, iv4, t.x ), t.y ) );\n}\n\n// FBM\nfloat FBM( vec2 xy )\n{\n    // Step Propertiees\n    const int OCTAVES = 4;\t\t// Number of Steps\n    float lacunarity = 2.0;\t\t// Affects Frequency ( x > 1.0, increases noise )\n\tfloat gain = 0.5;\t\t\t// Affects Amplitude ( x < 1.0, blurs )\n    \n    // Initial Values\n    float value = 0.0;\n    float amplitude = 1.5;\n    float frequency = 1.0;\n    \n    // FBM Loop\n    for( int i = 0; i < OCTAVES; i++ )\n    {\n        value += amplitude * Noise( xy * frequency );\n        frequency *= lacunarity;\n        amplitude *= gain;\n    }\n    \n    value = clamp( value, -1.0, 1.0 );\n    return value;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float aspectRatio = iResolution.x / iResolution.y;   \n    vec3 col = vec3( 0.0 );\n    vec2 tileCount = vec2( 10.0, 10.0 );\n    vec2 noisePos = ( uv * vec2( aspectRatio, 1.0 ) + vec2( iTime * 0.05, 0.0 ) ) * tileCount;\n\n    // Left ( Standard Perlin Noise )\n    if( uv.x < 0.5 )\n    \tcol = vec3( Noise( noisePos ) * 0.5 + 0.5 );\n    \n    // Right ( Perlin FBM Noise )\n    else\n    \tcol = vec3( FBM( noisePos ) * 0.5 + 0.5 );\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}