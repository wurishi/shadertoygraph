{"ver":"0.1","info":{"id":"ddl3z2","date":"1668079487","viewed":231,"name":"Uni_Star_Shader","username":"EnjoyWorld","description":"Star shader for university assignment","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float Hash21(vec2 uv){ //function that takes 2 values and \"randomizes\" it to one\n    return fract(sin(uv.x * 3204. + uv.y * 1241.2) * 57439.857);\n    //There are random math operations to create pseudo random\n}\nfloat noise(vec2 uv){\n    vec2 fl = floor(uv);\n    vec2 fr = fract(uv);\n    \n    float a = Hash21(fl);\n    float b = Hash21(fl + vec2(0,1));\n    float c = Hash21(fl + vec2(1,1));\n    float d = Hash21(fl + vec2(1,0));\n    \n    vec2 u = smoothstep(0.,1.,fr); \n    float AD = mix(a,d,u.x); \n    float BC = mix(b,c,u.x);\n    float v = mix(AD,BC,u.y);\n    \n    \n    return v;\n}\n#define OCTAVES 6\nfloat fBm(vec2 uv){\n    \n    float value;\n    float amplitude = .1;\n    float frequency = 2.;\n    \n    for (int i = 0; i < OCTAVES; i++){\n        value += noise(uv * frequency) * amplitude;\n        amplitude *= .3;\n        frequency *= 3.;\n        //uv *= 2.;\n    }\n    \n    return value;\n}\n\nvec3 Star(vec2 uv, float val, vec2 id){\n\n    vec2 offset = vec2(Hash21(id),Hash21(id+vec2(421.1,51.)));\n    offset = offset -.5; //creating offset and mapping for it to not go further\n    //then one of the neighbours\n\n    float d = length(uv + offset);\n    float star = val/d;\n    star *= smoothstep(.7,.1,d);\n    //Star \"brightness\" calculation, values from 0 to 1 to see if pixel is \n    //being \"lighen\" by the star\n    \n    \n    vec3 res;\n    vec3 colour = sin(vec3(9.,5.,6.) * fract(offset.x + offset.y)) * .5 + .5;\n    res = vec3(star) * colour;\n    //Assigning colour to every star based on offset(because this value is different for every star)\n    \n    return res;\n}\n\n//StarLayer function returns layer of stars with star light affecting each other\nvec3 StarLayer(vec2 uv){\n    \n    vec2 id = floor(uv);\n    \n    vec2 gv = fract(uv)-.5;\n    vec3 res;\n    float brightness = 0.015;\n    \n    for(float x = -1.;x <= 1.;x++){\n        for(float y = -1.;y <= 1.;y++){\n        \n            vec2 rId = vec2(x,y);\n            \n            vec3 star = Star(gv + rId,brightness,id - rId);\n            res += star;\n            \n        }\n    }\n    \n\n    res += fBm(uv) * vec3(1,0,1) *.6;\n    \n    \n    //res += vec3(1,0,1)*.03;\n    \n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv *= 5.;\n    float layersCount = 5.;\n    \n    vec3 col = vec3(0);\n    float t = iTime*.1; //slowed time value\n    \n        for (float n = 0.; n < 1. ;n+=1./layersCount){\n        \n        float s = fract(t + n); //getting value from 0 to 1 different per every\n        //layer in the system\n        \n        \n        float depth = mix(4.,.01,s); // depth determine how \"far\" layer is to\n        //create feeling like stars are moving\n        \n        col += StarLayer(uv* depth + n* 823.) * s;\n        \n    }\n\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}