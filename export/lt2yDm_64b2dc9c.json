{"ver":"0.1","info":{"id":"lt2yDm","date":"1508916762","viewed":2818,"name":"hash: visualising bitplanes","username":"hornet","description":"visualises the individual bitplanes of a couple of hashfunctions\nxor-hash by MBR https://www.shadertoy.com/view/4dlcR4 (int-bitplanes)\ntwo float-hashes https://www.shadertoy.com/view/4djSRW (float-bitplanes)\nLMB selects hashing-function","likes":40,"published":1,"flags":0,"usePreview":0,"tags":["xor","hash","wang","bitplanes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//note: SEE ALSO https://www.shadertoy.com/view/XlGcRh\n//////////////////////////////////////////////////////\n\n#define MAX_HASH 9.0\n//#define VIS_HASH 2\n\n//#define ANIMATE\n\n//note: remaps v to [0;1] in interval [a;b]\nfloat remap( float a, float b, float v )\n{\n\treturn clamp( (v-a) / (b-a), 0.0, 1.0 );\n}\n//note: quantizes in l levels\nfloat truncate( float a, float l )\n{\n\treturn floor(a*l)/l;\n}\n\n// ==========================================================\n\n//Fowler–Noll–Vo hash function\n//https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function#FNV-1a_hash\n//from https://www.shadertoy.com/view/WtdfRX\nuvec4 fnv(uvec4 seed) {\n    uvec4 h = (0x6A7F8FAAu^seed)*0x01000193u;\n    h = ((h.wxyz>>11u)^h^seed.yzwx)*0x01000193u;\n    h = ((h.zwxy>>7u)^h^seed.yxwz)*0x01000193u;\n    return h;\n}\n#define I2F (1./float(0xFFFFFFFFu))\n\n\n//note: from comments in https://www.shadertoy.com/view/WttXWX\n//note: see also https://arxiv.org/abs/2001.05304v1\nuint lcg(uint value)\n{\n    //static uint value = 1;\n    //value *= 1664525U;\n    //value += 1013904223U;\n    value *= 0xae3cc725u;\n    value += 0x9fe72885u;\n    return value;\n}\n\n//note: src https://www.shadertoy.com/view/4dlcR4\nuint hash12_xor_int(uint x, uint y)\n{\n\t//note: improved constants by MBR, https://twitter.com/marc_b_reynolds/status/924771187070308352\n    #define W0 0x3504f335u    // 15 | 101 | 41*79*274627\n\t#define W1 0x8fc1ecd5u  // 18 | 101 | 5*482370193\n    \n\t#define M  741103597u    // 13*83*686843\n\n    x *= W0;   // x' = Fx(x)\n    y *= W1;   // y' = Fy(y)\n\n    //note: hash2-improvement from MBR\n    //x += W1;   // some odd constant\n    //y += W0;   // some odd constant\n\n    x ^= y;    // combine\n    x *= M;    // MLCG constant\n\n    //note: murmur-like finalizer, suggestion: https://twitter.com/funny_falcon/status/923270464394481664\n\tx ^= x >> 16; //note: this appears to be enough?\n\t//x *= M;\n\t//x ^= x >> 16;\n    \n  \treturn x;\n}\nfloat hash12_xor_float( vec2 seed )\n{\n    uint hi = hash12_xor_int( uint(seed.x), uint(seed.y) );\n    return float(hi) * (1.0/4294967296.0);\n}\n\nuint wang_hash_ui( uint seed )\n{\n    seed = (seed ^ 61u) ^ (seed >> 16);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2du;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat wang_hash_f(inout uint seed)\n{\n    float r = float(wang_hash_ui(seed)) * (1.0 / 4294967296.0);\n    //seed += 10u;\n    return r;\n}\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint JenkinsHash( uint x)\n{\n    x += (x << 10u);\n    x ^= (x >>  6u);\n    x += (x <<  3u);\n    x ^= (x >> 11u);\n    x += (x << 15u);\n    return x;\n}\n// Compound versions of the hashing algorithm.\nuint JenkinsHash( uvec2 v)\n{\n    return JenkinsHash(v.x ^ JenkinsHash(v.y));\n}\n\nuint baseHash(uvec2 p)\n{\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\n//note: from https://www.shadertoy.com/view/WttXWX\n// bias: 0.020888578919738908 = minimal theoretic limit\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\n//note: from https://www.shadertoy.com/view/XlGcRh\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\nuvec4 pcg4d(uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v.x += v.y*v.w;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n    v.w += v.y*v.z;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec4 pcg4d_f( vec4 v )\n{\n    return (1.0/float(0xffffffffu)) * vec4(pcg4d( uvec4(floatBitsToUint(v.x),\n                  \t\t\t \t\t\t\t\t\t\tfloatBitsToUint(v.y),\n                  \t\t\t \t\t\t\t\t\t\tfloatBitsToUint(v.z),\n                  \t\t\t \t\t\t\t\t\t\tfloatBitsToUint(v.w)) ));\n}\n\n//note: src https://www.shadertoy.com/view/llGSzw\nuint hashIQ(uint n)\n{\n    // integer hash copied from Hugo Elias\n    n = (n << 13U) ^ n;\n    return n * (n * n * 15731U + 789221U) + 1376312589U;\n}\n// Integer Hash - III\n// - Inigo Quilez, Integer Hash - III, 2017\n//   https://www.shadertoy.com/view/4tXyWN\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    n = n ^ (n>>16u); //note: nimitz finalizer\n    return n;\n}\nfloat hashIQf(uint n)\n{\n    n = hashIQ( n );\n    return float(n & 0x7fffffffU) / float(0x7fffffff);\n}\n\n\n//note: src https://www.shadertoy.com/view/4djSRW\nfloat hash12_float(vec2 p)\n{\n    #define HASHSCALE1 .1031\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat hash12_float_classic(vec2 p)\n{\n    // Two typical hashes...\n\treturn fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This one is better, but it still stretches out quite quickly...\n    // But it's really quite bad on my Mac(!)\n    //return fract(sin(dot(p, vec2(1.0,113.0)))*43758.5453123);\n}\n\n\n// ====================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n    int idx = int( floor( 8.0 * uv.x ) + 8.0 * floor( 4.0 * uv.y ) );\n    //fragColor = vec4( vec3(idx)/(8.0*4.0), 1.0 ); return; //DBG\n    \n    //vec2 seed = fragCoord.xy;\n    vec2 seed = mod( fragCoord.xy, vec2(iResolution.x/8.0, iResolution.y/4.0) );\n    //fragColor = vec4(seed/iResolution.xy,0.0,1.0); return; //DBG\n\n    #if defined( ANIMATE )\n    seed += 100.0 * iTime;\n    #endif //ANIMATE\n    \n    int hashindex = int( mod( 0.5*iTime, (MAX_HASH+1.0) ) );\n    #if defined( VIS_HASH )\n    hashindex = VIS_HASH; //DBG\n    #endif\n\n    if ( iMouse.z > 0.5 )\n        hashindex = int( iMouse.x / iResolution.x * (MAX_HASH+1.0) );\n    \n    vec3 dbgcol = vec3(0.0,0.0,0.0);\n    vec3 c = vec3(0.0);\n    if ( hashindex <= 4 )\n    {\n        uint hi;\n        if ( hashindex == 0 )\n        {\n            hi = hash12_xor_int( uint(seed.x), uint(seed.y) ); //32b hash\n            \n            //hi = baseHash( uvec2(seed) ); //from https://www.shadertoy.com/view/Xt3cDn\n            dbgcol = vec3(1,0,0);\n        }\n        else if ( hashindex == 1 )\n        {\n            uint wang_seed = uint(fragCoord.y * iResolution.x + fragCoord.x);\n            hi = wang_hash_ui( wang_seed*100u ); //32b hash\n            \n            //hi = JenkinsHash( uvec2(seed)*100u );\n            dbgcol = vec3(0,1,0);\n        }\n        else if ( hashindex == 2 )\n        {\n\n            //hi = iqint3( uvec2(seed) );\n        \thi = triple32( uint(seed.x) + triple32( uint(seed.y) ) ); //note: from https://www.shadertoy.com/view/WttXWX\n            dbgcol = vec3(0,0,1);\n        }\n        else if ( hashindex == 3 )\n        {\n        \thi = lcg( uint(seed.x) + lcg( uint(seed.y) ) );    \n            dbgcol = vec3(1,1,0);\n        }\n        else if ( hashindex == 4 )\n        {\n            //hi = pcg2d( uvec2(seed) ).x;\n            hi = fnv( uvec4(seed.x, seed.y, 1, 1) ).x;\n            dbgcol = vec3(0.1,0.5,0.75);\n        }\n\n        uint bit = uint(idx);\n        uint bitmask = 1u<<bit;\n        float bitplane = float( (hi & bitmask)>>bit );\n        c = vec3(bitplane);\n    }\n    else if ( hashindex <= 8 )\n    {\n        float hf;\n        if ( hashindex == 5) {\n        \thf = hash12_float( seed );\n            dbgcol = vec3(1,0,1);\n        }\n        else if ( hashindex == 6 )\n        {\n            hf = hash12_float_classic(seed);\n        \t\n            dbgcol = vec3(0,1,1);\n        }\n        else if ( hashindex == 7 )\n        {\n            hf = hashIQf( uint(seed.x) + uint(hashIQ(uint(seed.y))) );\n            dbgcol = vec3(1,1,1);\n        }\n        else if ( hashindex == 8 )\n        {\n            hf = hash12_xor_float( seed );\n            dbgcol = vec3(0.5,0.5,0.5);\n        }\n            \n        //fragColor = vec4( vec3(hf), 1.0 ); return; //DBG\n        \n        //uint hi = uint(hf * 4294967296.0); //32b\n        //uint hi = uint(hf * 16777216.0); //24b\n        //uint hi = uint(hf * 65536.0); //16b\n        uint hi = floatBitsToUint( hf ); //note: vis float-representation directly\n        \n        uint bit = uint(idx);\n        uint bitmask = 1u<<bit;\n\t\tfloat bitplane = float( (hi & bitmask)>>bit );\n        c = vec3( bitplane );\n        \n        //note: mark floatbits sign, exp, frac\n        if ( bit==31u)\n            c *= vec3(0.5, 0.6, 0.7 );\n        else if ( bit > 22u ) //sign\n            c *= vec3(0.6, 0.7, 0.5); //exp\n        else\n            c *= vec3(0.7, 0.6, 0.5); //frac\n    }\n    else if ( hashindex == 9 )\n    {\n        //TODO: hmm....\n\n        //note: vis each of the 8bit bitplanes in the blue-noise texture\n        float hf = texelFetch( iChannel0, ivec2(seed.xy), 0 ).r; //8bit \"hash\", [0;1]\n        uint hi = uint( 255.0 * hf ); //8bit, [0;255]\n\n        uint bit = uint( idx );\n        uint bitmask = 1u<<bit;\n        float bitplane = float( (hi & bitmask)>>bit );\n\n        c = vec3(bitplane, bitplane, bitplane);\n        //c = vec3(hf);\n        //c = vec3( float(hi)/255.0 );\n        \n        dbgcol = vec3(0.7,0.6,0.5);\n    }\n\n    \n    fragColor = vec4( vec3(c), 1.0 );\n\n    //lines\n    float ll = step( 10.0/iResolution.x, 1.0-abs(2.0*fract(8.0*uv.x)-1.0))\n    \t\t * step( 10.0/iResolution.y, 1.0-abs(2.0*fract(4.0*uv.y)-1.0));\n    \n    fragColor.rgb = mix( dbgcol, fragColor.rgb, ll );\n}\n\n\n// proper random-test\n// http://webhome.phy.duke.edu/~rgb/General/dieharder.php\n","name":"Image","description":"","type":"image"}]}