{"ver":"0.1","info":{"id":"wsVBWd","date":"1608270484","viewed":48,"name":"Northstar with images","username":"fYnch","description":"northstar calibration shader modified for images","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["northstar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// North Star Calibration Utilities\n// Screen UV to Rectilinear Coefficients\nfloat[]  left_uv_to_rect_x  = float[16]( \n        -0.3918020292449689, \n        0.791726372376561, \n        0.02591239355192218, \n        0.008744176234740858, \n        -0.1649396274675502, \n        1.1322196641737434, \n        -1.6680166890954886, \n        1.1111176447492517, \n        0.022465281991214114, \n        -0.5592109301783784, \n        1.2491291544547116, \n        -1.0106240324173925, \n        0.024315551711530076, \n        0.1376384240364291, \n        -0.2794945988695832, \n        0.4312289910744763\n);\nfloat[]  left_uv_to_rect_y  = float[16](\n        -0.48483901971731497, \n        0.8436046130439113, \n        -1.5344824413858302, \n        0.6363390913416581, \n        1.6547936786784772, \n        -4.384180406205411, \n        7.7915686694894655, \n        -4.220901786436406, \n        -1.457810848874982, \n        6.964123630769752, \n        -12.684181276394497, \n        7.008807438460474, \n        0.8613499925234189, \n        -3.4912086566752447, \n        6.377673982274766, \n        -3.553628890326528\n);\nfloat[] right_uv_to_rect_x  = float[16](\n        -0.4737128758923168, \n        1.4649436844802932, \n        -0.7553118407330873, \n        0.6099424065922888, \n        -0.14897075215988165, \n        0.12337332203550583, \n        -0.518082807931264, \n        -0.0835306043611555, \n        0.39388715053254497, \n        -1.1921035802457454, \n        1.7719210173097018, \n        -0.4673150206420599, \n        -0.22070020854179537, \n        0.6082587245625171, \n        -0.7477905364328414, \n        0.1271200278978482\n);\nfloat[] right_uv_to_rect_y  = float[16](\n        -0.2923919185959319, \n        0.06574524585875302, \n        -0.14988749177037142, \n        0.3340301177397963, \n        1.147052066869174, \n        -1.2383306428246972, \n        2.6815786756701687, \n        -1.6671682035913102, \n        -0.9614391076254426, \n        4.167373142383415, \n        -8.547136809524465, \n        5.26722400936779, \n        0.8486137275741139, \n        -3.820204624149136, \n        7.603654981275493, \n        -4.561358936006921\n);\n\n// Evaluate a 2D polynomial from its coefficients\nfloat polyval2d(float X, float Y, float[16] C) {\n  float X2 = X * X; float X3 = X2 * X;\n  float Y2 = Y * Y; float Y3 = Y2 * Y;\n  return (((C[ 0]     ) + (C[ 1]      * Y) + (C[ 2]      * Y2) + (C[ 3]      * Y3)) +\n          ((C[ 4] * X ) + (C[ 5] * X  * Y) + (C[ 6] * X  * Y2) + (C[ 7] * X  * Y3)) +\n          ((C[ 8] * X2) + (C[ 9] * X2 * Y) + (C[10] * X2 * Y2) + (C[11] * X2 * Y3)) +\n          ((C[12] * X3) + (C[13] * X3 * Y) + (C[14] * X3 * Y2) + (C[15] * X3 * Y3)));\n}\n\n// Calculate the direction a ray takes exiting the eye on its way towards this screen UV\nvec3 uvToRayDirection(vec2 uv, float[16]  left_uv_to_rect_x, float[16]  left_uv_to_rect_y, \n                               float[16] right_uv_to_rect_x, float[16] right_uv_to_rect_y) {\n    vec2 screenUV = vec2(mod((2.0 * (1.0-uv.x)), 1.0), uv.y); // Calculate the Screen-Space UV\n    float[16] xCoeffs = left_uv_to_rect_x; if(uv.x < 0.5) { xCoeffs = right_uv_to_rect_x; }\n    float[16] yCoeffs = left_uv_to_rect_y; if(uv.x < 0.5) { yCoeffs = right_uv_to_rect_y; }\n    return vec3(polyval2d(screenUV.x, screenUV.y, xCoeffs),\n                polyval2d(screenUV.x, screenUV.y, yCoeffs), 1.0);\n}\n\n// Calculate the origin of a ray given a shader UV\nvec3 uvToRayOrigin(vec2 uv) { \n    return vec3(0.032 * ((uv.x > 0.5) ? -1.0 : 1.0), 0.0, 0.0); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates (from 0 to 1 across both screens)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Calculate the ray origin and direction\n\tvec3 ray_origin = uvToRayOrigin(uv);\n\tvec3 ray_dir    = uvToRayDirection(uv, left_uv_to_rect_x, \n                                           left_uv_to_rect_y, \n                                           right_uv_to_rect_x, \n                                           right_uv_to_rect_y);\n    // Get the point on a virtual plane 15cm away\n    vec3 plane_pos = ray_origin + ray_dir * 0.15;\n    \n    // Create a Checkerboard Pattern\n    vec2 Pos = (-plane_pos.yx * 6.0) - 0.35;\n    //float PatternMask = mod(Pos.x + mod(Pos.y, 2.0), 2.0);\n\n    // Output to screen\n    fragColor = texture(iChannel0, Pos);\n}\n","name":"Image","description":"","type":"image"}]}