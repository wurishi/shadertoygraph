{"ver":"0.1","info":{"id":"4l2fWG","date":"1534590042","viewed":106,"name":"Tiling Pattern #0","username":"TinyTexel","description":"shader","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.141593;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2 = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat Root4(float x) {return rsqrt(rsqrt(x));}\n\nfloat Length4(vec2 vec) {return Root4(Pow4(vec.x) + Pow4(vec.y));}\nfloat Length4(vec3 vec) {return Root4(Pow4(vec.x) + Pow4(vec.y) + Pow4(vec.z));}\n\nvec2 CosSin(float ang) {return vec2(cos(ang), sin(ang));}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat sRGB_NonlinearEncode(float c) {return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;}\nfloat sRGB_NonlinearDecode(float c) {return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;}\nvec3 sRGB_NonlinearEncode(vec3 rgb) {return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);}\nvec3 sRGB_NonlinearDecode(vec3 rgb) {return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);}\n\n\nfloat CheapHash(float v) {return fract(sin(v + 0.371) * 43758.5453) * 2.0 - 1.0;}\nfloat CheapHash(vec2 v) {return CheapHash(v.y + v.x * 12.9898);}\n\n//=======================================================================//\n///////////////////////////////////////////////////////////////////////////\n\n/*\n{\nvec2 o_uv, o_s, o_id;\nPattern_RectCircBricks(uv, /*out:/ o_uv, o_s, o_id);\n\nk = o_uv; s = o_s; n = o_id; \n}\n*/\nvoid Pattern_RectCircBricks(vec2 uv, out vec2 o_uv, out vec2 o_s, out vec2 o_id)\n{\n    uv.x = -uv.x+1.0;\n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n    \n    o_uv = uvf;\n    o_id = uvi;\n    o_s = vec2(1.0);\n\n    uint m = mod(uvi.x + uvi.y, 2.0) == 0.0 ? 0u : 2u;// brick wall tiling\n\n    if(uvi.y >= uvi.x && -uvi.y >  uvi.x) { m += 1u; }\n    if(uvi.y <  uvi.x && -uvi.y >= uvi.x) { m += 2u; }\n    if(uvi.y <= uvi.x && -uvi.y <  uvi.x) { m += 3u; }\n   \n    //if(mod(dim, 2.0) == 1.0 && -uvi.y == uvi.x) m += 1u;\n    //if(-uvi.y == uvi.x) m += 1u;\n \n    m &= 3u;// m % 4\n    \n    if(uvi.y == uvi.x && -uvi.y == uvi.x) return;// center brick\n        \n    \n    if(m == 0u) { o_s.x = 2.0;                                       }// right\n    if(m == 1u) { o_s.y = 2.0;                                       }// up\n    if(m == 2u) { o_s.x = 2.0; o_id.x -= 1.0; o_uv.x = 1.0 - o_uv.x; }// left\n    if(m == 3u) { o_s.y = 2.0; o_id.y -= 1.0; o_uv.y = 1.0 - o_uv.y; }// down\n}\n\n struct Pattern_RectCircBricks_Out { vec2 id; vec2 uv; vec2 s; };\n#define PATTERN_RectCircBricks(name, p) Pattern_RectCircBricks_Out name; Pattern_RectCircBricks(p, /*out:*/ name.uv, name.s, name.id);\n\n    \nfloat SMax_Norm2(float a, float b, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   \n   float inner = max(ap, bp); \n   \n   float box = (inner < 0.0 ? inner : length(max(vec2(ap, bp), 0.0))) - r;\n    \n   return box;\n    \n   //return max(max(a, b), length(vec2(ap, bp)) - r);//cylinder, sphere, torus\n   //return ap > 0.0 && bp > 0.0 ? length(vec2(ap, bp)) - r : max(a, b); \n}\n\nfloat SMax_Norm4(float a, float b, float r)\n{\n   float ap = a + r;\n   float bp = b + r;\n   \n   float inner = max(ap, bp); \n   \n   float box = (inner < 0.0 ? inner : Length4(max(vec2(ap, bp), 0.0))) - r;\n    \n   return box;\n}\n\nfloat SMin_Norm2(float a, float b, float r) {return -SMax_Norm2(-a, -b, r);}\nfloat SMin_Norm4(float a, float b, float r) {return -SMax_Norm4(-a, -b, r);}\n\n     \nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\tvec2 tex = uv0 / iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    col = vec3(tex, sin(iTime) * 0.5 + 0.5);\n\n    uv *= 0.125*0.25;\n    \n    float v = 0.0;\n    \n    float dim = 10.0;\n    uv -= floor(dim*0.5);   \n\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n    \n    vec2 k = uvf;\n    vec2 n = uvi;\n\tvec2 s = vec2(1.0);\n    \n    /*/   \n    uint m = mod(uvi.x + uvi.y, 2.0) == 0.0 ? 0u : 2u;// brick wall tiling\n\n    if(uvi.y >= uvi.x && -uvi.y >  uvi.x) { m += 1u; }\n    if(uvi.y <  uvi.x && -uvi.y >= uvi.x) { m += 2u; }\n    if(uvi.y <= uvi.x && -uvi.y <  uvi.x) { m += 3u; }\n   \n    //if(mod(dim, 2.0) == 1.0 && -uvi.y == uvi.x) m += 1u;\n    //if(-uvi.y == uvi.x) m += 1u;\n \n    m &= 3u;// m % 4\n    \n    if(uvi.y == uvi.x && -uvi.y == uvi.x) { m = 4u; }\n        \n    if(m == 0u) {                              s.x = 2.0; }// right\n    if(m == 2u) { n.x -= 1.0; k.x = 1.0 - k.x; s.x = 2.0; }// left\n    if(m == 1u) {                              s.y = 2.0; }// up\n    if(m == 3u) { n.y -= 1.0; k.y = 1.0 - k.y; s.y = 2.0; }// down\n\t/*/\n    {\n        vec2 o_uv, o_s, o_id;\n        Pattern_RectCircBricks(uv, /*out:*/ o_uv, o_s, o_id);\n\n        k = o_uv; s = o_s; n = o_id; \n        \n        \n        PATTERN_RectCircBricks(o, uv);\n        //k = o.uv; n = o.id; s = o.s;\n    }\n    //*/\n    \n    //k = s - vec2(2.0) * abs(k - s*0.5);\n    k = abs(k * 2.0 - s) - s;\n    v = -max(k.x, k.y);\n    v = -SMax_Norm4(k.x, k.y, 0.75);\n    //v = k.y;\n    \n    #if 0\n    v=1.0;\n\n    if(uvi.y >= uvi.x && -uvi.y >  uvi.x) v = 0.01;\n    if(uvi.y <  uvi.x && -uvi.y >= uvi.x) v = 0.1;\n    if(uvi.y <= uvi.x && -uvi.y <  uvi.x) v = 0.2;\n    if(uvi.y >  uvi.x && -uvi.y <= uvi.x) v = 0.3;\n    \n    //if(mod(uvi.x - uvi.y, 2.0) == 0.0) v = 1.0;\n    #endif\n    \n    #if 0\n    v=1.0;\n\t//uvi.y += 0.5;\tuvi.x += 0.25;\n\tif(uvi.y<0.0) uvi.y+=0.5;\n    //if(uvi.x>=0.0) uvi.x-=0.5;\n\n    if(uvi.y > uvi.x) v *= 0.5;\n    if(uvi.y >= -uvi.x) v *= 0.25;    \n    //if(uvi.y == uvi.x && uvi.y < -uvi.x) v *= 0.5;    \n    //if(uvi.y == -uvi.x && uvi.y < uvi.x) v = 1.0;\n\n    //if(mod(uvi.x - uvi.y, 2.0) == 0.0) v = 1.0;\n    #endif\n    \n    col = vec3(v);\n    if(false)\n    {\n        vec2 u = vec2(n);\n    col = clamp01(v*8.0) * vec3(n.x, 0.0, n.y) / float(dim);\n    col = clamp01(v*8.0) * vec3(CheapHash(vec2(n))*0.5+0.5);\n    col = vec3(1.0)* (CheapHash(vec2(n))>0.0?1.0-v:v+1.0)*0.5;// * (CheapHash(vec2(n))>0.0?1.0:-1.0);\n        \n    //col = vec3(mod(uvi.x + uvi.y, 2.0) == 0.0 ? 0.0 : 1.0);\n        //col = vec3(v);\n    //col = vec3(n.y == -.0 && n.x == -1.0 ? 1.0 : 0.0);\n    //col = vec3(1.0) * float(n.x+n.y*(dim+1u)) / float((dim+1u)*(dim+1u));\n    //col = vec3(1.0) * float(n.x^(n.y+2u)) * 0.05;    \n    //col = vec3(abs(dFdx(v))!=0.0?1.0:0.0);\n    }   \n        \n    if(uvi.x > dim*0.5 || uvi.y > dim*0.5) col *= 0.01;\n    \n    \n\toutCol = vec4(GammaEncode(clamp01(col)), 1.0);\n    //fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}