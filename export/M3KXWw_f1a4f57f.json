{"ver":"0.1","info":{"id":"M3KXWw","date":"1720046874","viewed":28,"name":"Fastaro Paradox Fractal","username":"robfast","description":"The noneuclidean quantom godel russel pythagorean reimann wormhole","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","beautiful","fastaro"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ShaderToy shader code\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat customIterationFunction(float x, float log_p, float log_q) {\n    float term1 = (-1.0 + floor((x * log_p) / log_q)) * floor((x * log_p) / log_q) * log_q;\n    float term2 = (2.0 * log_p);\n    float term3 = floor((x * log_p) / log_q) * (x - (log_q / log_p) * floor((x * log_p) / log_q));\n    return (term1 / term2) + term3;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Introduce a dynamic zoom based on time\n    float zoom = 1.0+sin(iTime/22.0)/333.0; // Adjusted zoom effect\n    float rotation = iTime * 0.001; // Slow rotation effect\n    mat2 rot = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));\n    vec2 baseC = (uv * rot) / zoom; // Apply zoom and rotation to fractal view\n    \n    float slowTime = iTime * 0.2;\n    float context =  sin(slowTime) * 0.5;\n    float truthDegree =  cos(slowTime) * 0.5;\n    \n    // Oscillating parameters for q and p\n    float n1 = -0.09993406684822648;\n    float n2 = -12.0 * 3.141592653589793 + sin(slowTime * 0.001) * 12.0 * 3.141592653589793;\n    float q = pow(2.0, n1);\n    float p = exp(n2);\n    float log_p = log(p);\n    float log_q = log(q);\n    \n    vec2 z = baseC;\n    vec2 c = vec2(0.355, 0.355);\n    int maxIter = 50;\n    float iter = 0.0;\n    \n    for(int i = 0; i < maxIter; i++)\n    {\n        float x = z.x * z.x - z.y * z.y + c.x;\n        float y = 2.0 * z.x * z.y + c.y;\n        z = vec2(x, y);\n        \n        float euclidean = customIterationFunction(length(z), log_p, log_q) * truthDegree;\n        float nonEuclidean = customIterationFunction(length(z), log_p, log_q) * context;\n        \n        float val = mix(euclidean-float(i)* slowTime, nonEuclidean+float(i)*0.5,float(i) + sin(slowTime));\n        \n        if(val > 2000.0 * (sin(context * slowTime)))\n        {\n            iter = float(i) / 88.0*abs(n2)*float(maxIter);\n          \n        }\n    }\n    \n    float sg = iter;\n    \n   float truthValue = iter;\n    vec3 euclideanColor = vec3(0.5 * sin(truthValue * 6.28 + slowTime) + 0.5,\n                               0.5 * cos(truthValue * 6.28 + slowTime) + 0.5,\n                               0.5);\n    vec3 nonEuclideanColor = vec3(sin(truthValue * 6.28 + slowTime),\n                                  cos(truthValue * 6.28 + slowTime),\n                                  sin(truthValue * 3.14 - slowTime));\n    vec3 finalColor = mix(euclideanColor, nonEuclideanColor, context * 0.5);\n    \n    fragColor = vec4(finalColor, 1.0);\n   \n}\n","name":"Image","description":"","type":"image"}]}