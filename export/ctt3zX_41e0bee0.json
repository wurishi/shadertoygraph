{"ver":"0.1","info":{"id":"ctt3zX","date":"1682862818","viewed":1586,"name":"[SESSIONS] Syobon's Lobby","username":"Kamoshika","description":"GLSL Graphics Compo @ SESSIONS 2023 Shizuoka, Japan\nhttps://sessions.frontl1ne.net/\n\nThankfully, it won 3rd place out of 15 entries!","likes":45,"published":1,"flags":40,"usePreview":1,"tags":["game","raycasting","globalillumination","pathtracing","backrooms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ショボンから逃げ回るゲームです。\n// 生き延びた時間が得点となります。\n// This is a game in which you run away from Syobon.\n// Survival time is your score.\n\n\n// 元のシェーダーはtwiglで動作するものであり、マウスの押下の入力はありません。\n// このシェーダーでは、マウスを押下していないときに立ち止まるような変更が加えられています。\n// 元のシェーダーはサウンドもありません。\n// Original shader works on twigl, and does not have a mouse press input.\n// This shader has been modified to stand still when the mouse is not pressed down.\n// Original shader has no sound.\n\n// Original shader (twigl link):\n// https://twigl.app?ol=true&ss=-NUH6X_5lvRnUYhwSX3F\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FC fragCoord\n#define o fragColor\n\n// vをPI/4.だけ回転\n#define rotpi4(v) (vec2((v).x + (v).y, -(v).x + (v).y) / sqrt(2.))\n\n// オブジェクトの種類\n#define FLOOR   1\n#define WALL    2\n#define CEILING 3\n#define SYOBON  4\n\n// 壁の配置（マップ）は、対角線のTruchet tilesをベースとしています。\n// すべての壁の法線ベクトルは(±1, 0, ±1)の４種類。\n// ※ミニマップは45°傾いており、斜め右下がx軸の正方向、斜め左下がz軸の正方向となっています。\n\n// 壁（タイル）の種類\n// 四隅のみ\n#define FOURCORNERS   11.0\n// 四隅と対角線(平面x=z)\n#define DIAGPLUS      12.0\n// 四隅と対角線(平面x=-z)\n#define DIAGMINUS     13.0\n\n// Change according to the processing capability of the GPU.\n//----------GPUの処理能力に応じて変更してください。----------\nconst int numSamples = 50;  // パストレーシングのサンプル数\n//------------------------------------------------------------\n\nconst int maxDepth = 3;     // レイの経路の深さの最大値（反射回数+1の値）\n\nconst float sceneTime1 = 5.;  // 画面ノイズの終了時間\nconst float sceneTime2 = 8.;  // グリッチの終了時間\nconst float sceneTime3 = 10.; // HUDの開始時間\nconst float sceneTime4 = 11.; // タイマー、プレイヤー（カメラ）の移動の開始時間\nconst float sceneTime5 = 14.; // ショボンの追跡の開始時間\n//const float sceneTime5 = 1e5; // ショボンの追跡の開始時間\n\nconst float PI = acos(-1.); // 円周率\nconst float PI2 = acos(-1.) * 2.;\n\nconst float EPS = 0.0001;           // レイトレースなどに使う微小量\nconst float FOV = 60. / 360. * PI;  // 視野角(ラジアン) 範囲：(0./360.*PI, 180./360.*PI)\nconst float wallRate = 0.7;         // 壁の割合　範囲：[0., 1.]\nconst float wallWidth = 0.1;        // 壁の厚さ　範囲：(0., 0.5)\n//const float mapSeed = 5.;           // マップ生成に使う乱数のシード\nconst float mapSeed = 4.;           // マップ生成に使う乱数のシード\nconst float ceilHeight = 0.5;       // 天井の高さ\nconst float damageRate = 0.01;      // 1フレームあたりのダメージ量\nconst float enemySize = 0.2;        // ショボン（敵）の大きさ（球の半径）\nvec3 enemyPos;                      // ショボンの位置\nfloat enemyDirA;                    // ショボンの向き(ラジアン)\nfloat pathSeed = 0.;                // パストレーシングで使う乱数のシード\n\n// 1Dの乱数\nfloat hash11(float p)\n{\n    return fract(sin(p) * 43758.5453);\n}\n\n// 2Dの乱数\nfloat hash12(vec2 p)\n{\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    // return fract(sin(dot(p + 0.2, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\n// 1Dの乱数(シードを更新)\nfloat random() {\n    return hash11(pathSeed++);\n}\n\n// 2次元の回転行列\nmat2 rotate2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nconst float segScale = 0.03; // セグメント数字の大きさ\n// 数字のセグメントの距離関数\nfloat sdSeg(vec2 p) {\n    p = abs(p);\n    return max(p.x - segScale / 3., p.x + p.y - segScale);\n}\n\n// \"0\"の距離関数\nfloat sd0(vec2 p) {\n    p = abs(p);\n    p.y -= segScale;\n    p = p.y > p.x ? p.yx : p;\n    p.x -= segScale;\n    return sdSeg(p);\n}\n\n// \"1\"の距離関数\nfloat sd1(vec2 p) {\n    p.y = abs(p.y);\n    p -= segScale;\n    return sdSeg(p);\n}\n\n// \"2\"の距離関数\nfloat sd2(vec2 p) {\n    p = p.y < 0. ? -p : p;\n    p.y = abs(p.y - segScale);\n    p = p.y > p.x ? p.yx : p;\n    p.x -= segScale;\n    return sdSeg(p);\n}\n\n// \"3\"の距離関数\nfloat sd3(vec2 p) {\n    p.y = abs(abs(p.y) - segScale);\n    p = p.y > p.x ? p.yx : p;\n    p.x -= segScale;\n    return sdSeg(p);\n}\n\n// \"4\"の距離関数\nfloat sd4(vec2 p) {\n    float d = sdSeg(p - vec2(-segScale, segScale));\n    p.y = abs(p.y) - segScale;\n    p = p.y < -p.x ? -p.yx : p;\n    p.x -= segScale;\n    return min(d, sdSeg(p));\n}\n\n// \"5\"の距離関数\nfloat sd5(vec2 p) {\n    p = p.y < 0. ? -p : p;\n    p.y = abs(p.y - segScale);\n    p = p.y > -p.x ? -p.yx : p;\n    p.x += segScale;\n    return sdSeg(p);\n}\n\n// \"6\"の距離関数\nfloat sd6(vec2 p) {\n    float d = sdSeg(p - vec2(segScale, -segScale));\n    p.y = abs(abs(p.y) - segScale);\n    p = p.y > -p.x ? -p.yx : p;\n    p.x += segScale;\n    return min(d, sdSeg(p));\n}\n\n// \"7\"の距離関数\nfloat sd7(vec2 p) {\n    float d = sdSeg(p - vec2(segScale, -segScale));\n    p.y -= segScale;\n    p = p.y > p.x ? p.yx : p;\n    p.x -= segScale;\n    return min(d, sdSeg(p));\n}\n\n// \"8\"の距離関数\nfloat sd8(vec2 p) {\n    p = abs(p);\n    p.y = abs(p.y - segScale);\n    p = p.y > p.x ? p.yx : p;\n    p.x -= segScale;\n    return sdSeg(p);\n}\n\n// \"9\"の距離関数\nfloat sd9(vec2 p) {\n    float d = sdSeg(p - vec2(-segScale, segScale));\n    p.y = abs(abs(p.y) - segScale);\n    p = p.y > p.x ? p.yx : p;\n    p.x -= segScale;\n    return min(d, sdSeg(p));\n}\n\n// 数字N（0～9）の距離関数\nfloat sdDigit(vec2 p, int N) {\n    if(N == 0) return sd0(p);\n    if(N == 1) return sd1(p);\n    if(N == 2) return sd2(p);\n    if(N == 3) return sd3(p);\n    if(N == 4) return sd4(p);\n    if(N == 5) return sd5(p);\n    if(N == 6) return sd6(p);\n    if(N == 7) return sd7(p);\n    if(N == 8) return sd8(p);\n    if(N == 9) return sd9(p);\n    return 1e5;\n}\n\n// タイマーの色\nvec3 colTimer(vec3 col, vec2 uv, vec2 pos, float size, float Time) {\n    uv -= pos;\n    uv /= size;\n    vec2 uvp = uv;\n    uv.x -= uv.y * 0.2;\n\n    float segGap = 0.002;\n    float interval = 0.09;\n    float interval2 = interval * 1.3;\n    float ra = 0.01;\n\n    float hundredths = fract(Time) * 100.;\n    float seconds = mod(Time, 60.);\n    float minutes = mod(Time / 60., 60.);\n    float hours = mod(Time / 3600., 100.);\n\n    int digit1 = int(mod(hundredths, 10.));\n    int digit2 = int(hundredths / 10.);\n    int digit3 = int(mod(seconds, 10.));\n    int digit4 = int(seconds / 10.);\n    int digit5 = int(mod(minutes, 10.));\n    int digit6 = int(minutes / 10.);\n    int digit7 = int(mod(hours, 10.));\n    int digit8 = int(hours / 10.);\n\n    float d = length(uvp - vec2(-0.159, -0.06)) - ra; // ピリオド\n    uvp -= vec2(-interval * 5.1, 0);\n    uvp.x -= sign(uvp.y) * 0.007;\n    uvp = abs(uvp) - vec2(interval * 1.15, 0.035);\n    d = min(d, length(uvp) - ra); // コロン\n\n    vec2 uv12 = (uv - vec2(-0.036, -0.021)) * 1.5;\n    d = min(d, sdDigit(uv12, digit1));\n\n    uv.x += interval;\n    uv12.x += interval;\n    d = min(d, sdDigit(uv12, digit2));\n\n    uv.x += interval2;\n    d = min(d, sdDigit(uv, digit3));\n\n    uv.x += interval;\n    d = min(d, sdDigit(uv, digit4));\n\n    uv.x += interval2;\n    d = min(d, sdDigit(uv, digit5));\n\n    uv.x += interval;\n    d = min(d, sdDigit(uv, digit6));\n\n    uv.x += interval2;\n    d = min(d, sdDigit(uv, digit7));\n\n    uv.x += interval;\n    d = min(d, sdDigit(uv, digit8));\n\n    col = mix(vec3(0.2), col, smoothstep(0.009, 0.0091, d + segGap)); // 枠\n    col += smoothstep(0.001, 0., d + segGap);\n\n    return col;\n}\n\nconst float serifThin = 4.; // 文字のセリフの細さ\n// 文字のセリフの距離関数\nfloat sdSerif(vec2 p, vec2 pos, float width, float height) {\n    p -= pos;\n    p.x = abs(p.x);\n    float d = p.x - exp(-p.y * p.y * serifThin) - width;\n    d = max(d, -p.y);\n    return max(d, p.y - height);\n}\n\n// \"Y\"の距離関数\nfloat sdCY(vec2 p) {\n    float d = sdSerif(p, vec2(0, -5.), 0.7, 4.5);\n    p.y = -p.y;\n    vec2 q = p;\n    q.x += q.y * 0.6 - 0.8;\n    d = min(d, sdSerif(q, vec2(0, -5.), 0.45, 6.));\n    q = p;\n    q.x -= q.y * 0.6 - 0.5;\n    return min(d, sdSerif(q, vec2(0, -5.), 0.7, 5.8));\n}\n\n// \"O\"の距離関数\nfloat sdCO(vec2 p) {\n    p.x *= 1.1;\n    float d = length(p) - 5.;\n    p.x *= 1.4;\n    return max(d, 4.5 - length(p));\n}\n\n// \"U\"の距離関数\nfloat sdCU(vec2 p) {\n    vec2 q = p;\n    q.y += 2.2;\n    q.y *= 1.2;\n    float r1 = 3.7;\n    float r2 = 2.6;\n    float of = 0.25;\n    q.y -= max(q.y, 0.);\n    float d = length(q) - r1;\n    q.x -= of;\n    d = max(d, r2 - length(q));\n    d = max(d, p.y - 5.);\n    q = p;\n    q.y = 5. - q.y;\n    float temp = of - r2;\n    d = min(d, sdSerif(q, vec2((temp - r1) * 0.5, 0), (temp + r1) * 0.5, 3.));\n    temp = of + r2;\n    return min(d, sdSerif(q, vec2((r1 + temp) * 0.5, 0), (r1 - temp) * 0.5, 3.));\n}\n\n// \"D\"の距離関数\nfloat sdCD(vec2 p) {\n    p.y = abs(p.y);\n    vec2 q = p;\n    q.x -= min(q.x, 0.2);\n    float d = length(q) - 5.;\n    d = max(d, -p.x - 2.5);\n    q = p;\n    q.x += 1.;\n    d = max(d, 4.5 - length(q));\n    q.y = 5. - q.y;\n    return min(d, sdSerif(q, vec2(-1.7, 0), 0.7, 6.));\n}\n\n// \"I\"の距離関数\nfloat sdCI(vec2 p) {\n    p.y = 5. - abs(p.y);\n    return sdSerif(p, vec2(0, 0), 0.7, 6.);\n}\n\n// \"E\"の距離関数\nfloat sdCE(vec2 p) {\n    vec2 q = vec2(p.y, -p.x);\n    float d = sdSerif(q, vec2(0.5, -4.), 0.42, 6.);\n    q = p;\n    q.y = 5. - abs(q.y);\n    d = min(d, sdSerif(q, vec2(-1.5, 0), 0.7, 6.));\n    q = vec2(p.y - 5., 4.5 - p.x);\n    q.y -= q.x *.1;\n    d = min(d, sdSerif(q, vec2(0, 0), 0.7, 6.));\n    q = vec2(p.y + 5., 4.5 - p.x);\n    q.y += q.x *.3;\n    d = min(d, sdSerif(q, vec2(0, 0), 0.7, 6.));\n    return max(d, abs(p.y) - 5.);\n}\n\n// 死亡時のメッセージの色\nvec3 colDeathMsg(vec3 col, vec2 uv, vec2 pos, float size) {\n    uv -= pos;\n    uv /= size * 0.05;\n    uv.x += 30.;\n\n    float d = sdCY(uv); // Y\n    uv.x -= 10.;\n    d = min(d, sdCO(uv)); // O\n    uv.x -= 10.5;\n    d = min(d, sdCU(uv)); // U\n    uv.x -= 14.5;\n    d = min(d, sdCD(uv)); // D\n    uv.x -= 8.5;\n    d = min(d, sdCI(uv)); // I\n    uv.x -= 6.5;\n    d = min(d, sdCE(uv)); // E\n    uv.x -= 11.;\n    d = min(d, sdCD(uv)); // D\n\n    col *= mix(0.2, 1., smoothstep(5., 14., abs(uv.y)));\n    col = mix(vec3(0.7,0.,0.) + col, col, smoothstep(0., 0.01, d));\n\n    return col;\n}\n\n// 壁の種類\nvec2 wallType(vec2 ID) {\n    float hash = hash12(ID + mapSeed * PI);\n\n    if(hash > wallRate) {\n        return vec2(FOURCORNERS, 1.);\n    }\n\n    if(hash > wallRate * 0.5) {\n        return vec2(DIAGPLUS, 1.);\n    }\n\n    return vec2(DIAGMINUS, -1.);\n}\n\n// 壁の距離関数（2次元）\n// 対角線のTruchet tilesをベースとしています。\nfloat sdWall(vec2 p) {\n    vec2 ID = floor(p);\n    vec2 q = fract(p) - 0.5;\n    vec2 wType = wallType(ID);\n\n    q.y *= wType.y;\n\n    if(wType.x != FOURCORNERS) {\n        // DIAGMINUS or DIAGPLUS\n        return (0.5 - wallWidth - abs(fract(q.y - q.x) - 0.5)) / sqrt(2.);\n    }\n\n    // FOURCORNERS\n    q = abs(q);\n    return (1. - q.x - q.y - wallWidth) / sqrt(2.);\n}\n\n// 壁の法線ベクトル（2次元）\nvec2 wallNormal(vec2 p) {\n    vec2 e = vec2(0, 0.1);\n    return normalize(vec2(sdWall(p + e.yx) - sdWall(p - e.yx),\n                          sdWall(p + e.xy) - sdWall(p - e.xy)));\n}\n\n// 画面上のミニマップの色\nvec3 colMiniMap(vec3 col, vec2 uv, vec2 pos, float size, vec2 ro, float dirA) {\n    uv -= pos;\n    uv /= size;\n\n    float L = length(uv);\n    float R = 0.4;\n\n    col = mix(vec3(0.5), col, smoothstep(0., 0.02, abs(L - R))); // 丸い枠\n    if(L < R) {\n        vec3 mapCol = vec3(0.7, 0.7, 0.9);\n        uv.y = -uv.y;\n        uv = rotpi4(uv); // PI/4.だけ回転\n        uv *= 15.;\n\n        col = mix(vec3(1.), col * mapCol, smoothstep(0., 0.01, sdWall(uv + ro))); // 壁\n\n        col =  mix(vec3(1, 1, 0), col, smoothstep(0.2, 0.25, length(uv))); // プレイヤー\n\n        vec2 q = uv * rotate2D(dirA);\n        float width = 0.02;\n        float a = abs(atan(q.y, q.x));\n        if(a < FOV + width && col.x < 0.99) {\n            float cFOV = smoothstep(1., 6., length(q)) * smoothstep(0., width, abs(a - FOV));\n            col = mix(vec3(0.6, 0.6, 0), col, cFOV); // 視界\n        }\n    }\n\n    return col;\n}\n\n// HPバーの色\nvec3 colHPBar(vec3 col, vec2 uv, vec2 pos, vec2 size, float HP) {\n    uv -= pos;\n\n    vec2 uvb = uv;\n    uv = abs(uv) - size;\n    uvb /= size * 2.;\n    uvb += 0.5;\n\n    float d = max(uv.x, uv.y);\n\n    if(d < 0.) {\n        col = mix(vec3(0), col, 0.4);\n        if(uvb.x < HP) {\n            col = vec3(1, .0, .0);\n            col += uvb.y * 1.5 - 0.75;\n        }\n    }\n\n    col = mix(vec3(0.8), col, smoothstep(0., 0.01, abs(d))); // 枠\n\n    return col;\n}\n\n// HUDの色\nvec3 colHUD(vec3 col, vec2 uv, vec2 ro, float dirA, float HP) {\n    col = colMiniMap(col, uv, vec2(0.8, -0.55), 1., ro, dirA); // ミニマップを表示\n    col = colHPBar(col, uv, vec2(0, 0.85), vec2(0.8, 0.05),  HP); // HPバーを表示\n\n    float Time = max(iTime - sceneTime4, 0.);\n    col = colTimer(col, uv, vec2(1.18, -0.03), 1., Time); // タイマーを表示\n\n    if(HP >= damageRate) { // 生きている間は死亡時のメッセージを表示しない\n        return col;\n    }\n\n    return colDeathMsg(col, uv, vec2(0, 0.4), 0.6); // 死亡時のメッセージを表示\n}\n\n// 物体の表面上の座標rpにおける法線ベクトル\nvec3 objNormal(vec3 rp, out int objType) {\n    vec3 n = vec3(0, 1, 0);\n\n    if(rp.y > ceilHeight - EPS) {\n        objType = CEILING;\n        return vec3(0, -1, 0);\n    }\n    if(rp.y < EPS) {\n        objType = FLOOR;\n        return vec3(0, 1, 0);\n    }\n\n    vec3 ep = rp - enemyPos;\n    if(dot(ep, ep) < (enemySize + EPS) * (enemySize + EPS)) {\n        objType = SYOBON;\n        return ep / enemySize; // 球体なので半径で割ると法線ベクトルになる\n    }\n\n    vec2 frp = fract(rp.xz) - 0.5;\n    vec2 ID = floor(rp.xz);\n    vec2 wType = wallType(ID);\n\n    objType = WALL;\n    n.y = 0.;\n    n.xz = -sign(frp) / sqrt(2.);\n\n    if(wType.x == FOURCORNERS) {\n        return n;\n    }\n\n    // DIAGMINUS or DIAGPLUS\n    float temp = frp.y - wType.y * frp.x;\n    float signNormal = sign(temp);\n    n.xz = (abs(temp) < wallWidth + EPS) ? vec2(-wType.y * signNormal, signNormal) / sqrt(2.) : n.xz;\n\n    return n;\n}\n\n// レイと球の表面の交差判定関数\n// ref: sphIntersect() by iq\n// https://iquilezles.org/articles/intersectors/\nfloat sphIntersect(vec3 ro, vec3 rd, vec3 ce, float ra) {\n    vec3 oc = ro - ce;\n    float e = dot(oc, rd);\n    float c = dot(oc, oc) - ra * ra;\n    float h = e * e - c;\n    if(h < 0.) {\n        return -1.0;\n    }\n    return -e - sqrt(h);\n}\n\n// エミッションの色\nvec3 emission(vec3 rp, int objType, out float ceilPattern) {\n    if(objType != CEILING) { // 光源は天井のみ\n        return vec3(0);\n    }\n\n    // 光源のタイルの端を壁に合わせる\n    vec2 uv = rp.xz;\n    uv /= wallWidth * sqrt(2.);\n    uv = rotpi4(uv);\n    uv -= 0.5;\n\n    float hash = hash12(floor(uv));\n    uv = abs(fract(uv) - 0.5);\n\n    ceilPattern = smoothstep(0.5, 0.43, max(uv.x, uv.y));\n    if(fract(hash + iTime * 0.05) < 0.05) { // 点滅\n        return vec3(ceilPattern * 10.);\n    }\n\n    return vec3(0);\n}\n\n// ショボンの目の距離関数\nfloat sdSyobonEye(vec2 p, vec2 pos, float radius) {\n    p.x = abs(p.x);\n    return length(p - pos) - radius;\n}\n\n// ショボンの眉毛の距離関数\nfloat sdSyobonEyebrow(vec2 p, vec2 pos, float L, float angle) {\n    p.x = abs(p.x);\n    p -= pos;\n    p *= rotate2D(angle);\n    p.x -= clamp(p.x, -L, L);\n    return length(p);\n}\n\n// ショボンの口の距離関数\n// reference: \"Arc - exact\" by iq\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSyobonMouth(vec2 p, float posY, float radius) {\n    p.x = abs(p.x);\n    p.y -= posY;\n    p *= rotate2D(0.5);\n\n    float a = 1.1;\n    float s = sin(a);\n    float c = cos(a);\n    vec2 cp = vec2(s, c) * radius;\n    p -= vec2(cp.x, -cp.y);\n\n    p.x = abs(p.x);\n\n    if(p.y * s > p.x * c) {\n        return length(p - cp);\n    }\n    return abs(length(p) - radius);\n}\n\n// ショボンの顔の距離関数\nfloat sdSyobon(vec2 p) {\n    float d;\n    d = sdSyobonEye(p, vec2(0.5, 0), 0.06);\n    d = min(d, sdSyobonEyebrow(p, vec2(0.8, 0.3), 0.13, -0.5));\n    return min(d, sdSyobonMouth(p, -0.3, 0.1));\n}\n\n// 物体の色\nvec3 objColor(vec3 rp, int objType, float ceilPattern) {\n    if(objType == FLOOR) { // 床\n        return vec3(0.7, 0.4, 0.2);\n    }\n\n    if(objType == CEILING) { // 天井\n        return vec3(mix(0.5, 1.0, ceilPattern));\n    }\n\n    if(objType == WALL) { // 壁\n        if(abs(rp.y - ceilHeight * 0.5) > ceilHeight * 0.47) {\n            return vec3(1.0);\n        }\n        rp.x = abs(fract(rp.x / wallWidth * 5. - 0.5) - 0.5); // 縦の縞模様にする\n        return mix(vec3(0.95), vec3(0.1, 0.6, 0.3), smoothstep(0., 0.2, rp.x));\n    }\n\n    vec3 p = rp - enemyPos;\n    if(objType == SYOBON) { // ショボン\n        p.xz *= rotate2D(enemyDirA);\n        if(p.x < 0.) {\n            return vec3(1);\n        }\n        vec2 uv = p.zy;\n        uv *= 1.3 / enemySize;\n        float d = sdSyobon(uv);\n        return vec3(smoothstep(0.05, 0.1, d));\n    }\n\n    return vec3(0);\n}\n\n// vを天頂として極座標phi, thetaだけ回転させたベクトル\n// ※引数vは長さ1のベクトルである必要あり\nvec3 jitter(vec3 v, float phi, float sinTheta, float cosTheta) {\n    vec3 xAxis = normalize(cross(v.yzx, v));\n    vec3 yAxis = cross(v, xAxis);\n    vec3 zAxis = v;\n    return (xAxis * cos(phi) + yAxis * sin(phi)) * sinTheta + zAxis * cosTheta;\n}\n\n// roから物体表面まで飛ばしたレイの長さ\n// 2DのVoxel Traversalをベースとしています。\nfloat castRay(vec3 ro, vec3 rd, const int itr) {\n    float t = 0.; // レイの長さ\n    vec2 ri = 1.0 / rd.xz;\n    vec2 rs = sign(rd.xz);\n\n    // 壁を無視したレイの長さ\n    float tLimit = (rd.y > 0.) ? (ceilHeight - ro.y) : -ro.y;\n    tLimit = (rd.y == 0.) ? 1e5 : tLimit / rd.y; // 天井または床までのレイの長さ\n\n    // ショボンまでのレイの長さ\n    float tEnemy = sphIntersect(ro, rd, enemyPos, enemySize);\n    tLimit = (tEnemy > 0.) ? min(tLimit, tEnemy) : tLimit; // レイがショボンに衝突したらtLimitを更新\n\n    vec2 ID = floor(ro.xz); // セルのID（レイの座標の整数部分）\n\n    for(int i = 0; i < itr; i++) {\n        vec2 rp = ro.xz + rd.xz * t;  // レイの先端の座標\n        vec2 wType = wallType(ID);    // 壁の種類\n        vec2 frp = rp - ID - 0.5;     // レイの先端の座標の小数部分-0.5\n        float tWall = 1e5;            // 次の壁までのレイの長さ\n\n        vec2 v = (0.5 * rs - frp) * ri; // 次のセルの境界までのレイの長さ(X方向とZ方向)\n        vec2 vCell = vec2(step(v.x, v.y), step(v.y, v.x)); // X方向とZ方向のうち、どちらのセルに進むか\n        float tCell = dot(v, vCell); // 次のセルの境界までのレイの長さ（v.x or v.y）\n\n        vec2 normal = -sign(frp + tCell * rd.xz); // 長さを計算式に反映済みのためnormalize()は不要\n        float tWallFourCorners = (wallWidth - 1. - dot(frp, normal)) / dot(rd.xz, normal); // 四隅の壁までのレイの長さ\n        tWall = (tWallFourCorners > 0.) ? tWallFourCorners : tWall; // tWallを更新する\n\n        float signNormal = sign(frp.y - wType.y * frp.x);\n        normal = vec2(-wType.y * signNormal, signNormal); // 長さを計算式に反映済みのためnormalize()は不要\n        float tWallDiag = (wallWidth - dot(frp, normal)) / dot(rd.xz, normal); // 対角線の壁までのレイの長さ\n        tWall = (tWallDiag > 0. && wType.x != FOURCORNERS) ? min(tWall, tWallDiag) : tWall; // 壁の種類が対角の場合はtWallを更新する\n\n        if(tWall < tCell) { // 次のセルの境界よりも、壁の方が近い\n            return min(t + tWall, tLimit);\n        }\n\n        // 次のセルの境界に進む\n        t += tCell;\n        ID += vCell * rs;\n\n        if(t >= tLimit) { // 次のセルの境界よりも、天井 or 床 or ショボンの方が近い\n            return tLimit;\n        }\n    }\n\n    return -1.0;\n}\n\n// ref: \"パストレーシング - Computer Graphics - memoRANDOM\" by Shocker_0x15\n// (Japanese article)\n// https://rayspace.xyz/CG/contents/path_tracing/\n\n// ref: \"GLSL smallpt\" by Zavie\n// https://www.shadertoy.com/view/4sfGDB\n// ※参考にはしているがコードは異なる\n\n// パストレーシングで得られる色\nvec3 pathTrace(vec3 ro, vec3 rd) {\n    vec3 acc = vec3(0);\n    vec3 mask = vec3(1);\n\n    // 最初にカメラからレイを飛ばす\n    float t = castRay(ro, rd, 20);\n    if(t < 0.) { // レイが物体に衝突しなかった\n        return vec3(0.1, 0.6, 0.3) * 0.1;\n    }\n    ro += t * rd; // レイの原点を物体表面まで進める\n    int objType;\n    float ceilPattern;\n    vec3 n = objNormal(ro, objType);\n    // ※本来はサンプル数の分だけカメラからレイを飛ばすため、numSamplesをかける\n    acc += mask * emission(ro, objType, ceilPattern) * float(numSamples);\n    mask *= objColor(ro, objType, ceilPattern);\n\n    // 次に、物体表面からランダムにレイを飛ばす\n    vec3 ro0 = ro + n * EPS;\n    vec3 n0 = n;\n    vec3 mask0 = mask;\n    for(int i = 0; i < numSamples; i++) {\n        ro = ro0;\n        n = n0;\n        mask = mask0;\n        for(int depth = 1; depth < maxDepth; depth++) {\n            float ur = random(); // 一様乱数\n            // 重点的サンプリングを行うため、半球面内cos分布を使用する\n            rd = jitter(n, random() * PI2, sqrt(1. - ur), sqrt(ur)); // 次のレイの方向\n\n            t = castRay(ro, rd, 4);\n            if(t < 0.) { // レイが物体に衝突しなかった\n                break;\n            }\n            ro += t * rd;\n            n = objNormal(ro, objType);\n            acc += mask * emission(ro, objType, ceilPattern);\n            mask *= objColor(ro, objType, ceilPattern);\n            ro += n * EPS; // 現在の物体表面を避けるために、少し浮かせる\n        }\n    }\n\n    acc /= float(numSamples);\n    acc = clamp(acc, 0., 1.);\n\n    return acc;\n}\n\n// カメラの位置と向きを初期化・更新する\nvoid doCamera(in vec2 uv, out vec3 ro, out float dirA, out float dirY, out vec3 dir, out vec3 rd) {\n    // カメラの座標を初期化\n    ro = vec3(wallWidth + 0.2, ceilHeight * 0.5, 0.);\n\n    // カメラの向きを初期化\n    dir.y = 0.;\n    dirA = 0.;\n    dir.xz = vec2(cos(dirA), sin(dirA));\n\n    if(iTime > sceneTime4) {\n        // 前フレームのカメラの位置・向きを取得\n        vec4 camInfo = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy);\n        vec2 mouse = (iMouse.xy - abs(iMouse.zw)) / iResolution.x * vec2(20., 10.);\n        //dir.y = (mouse.y - 0.5) * 2.;\n        dirA = camInfo.z;\n        dirY = camInfo.w;\n        if(iMouse.z > 0.) {\n            // カメラの向きをマウスで変える\n            //dirA = mouse.x * PI2 * 4.;\n            dirA = mouse.x;\n            dirY = mouse.y;\n        }\n        dir.xz = vec2(cos(dirA), sin(dirA));\n        dir.y = dirY;        \n        \n        //ro.xz = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).rg;\n        ro.xz = camInfo.xy;\n\n        // カメラを移動させる\n        vec2 v = dir.xz;\n        vec2 n = wallNormal(ro.xz);\n        float d = sdWall(ro.xz);\n        if(d < 0.) { // 壁に埋まっているので法線方向に進んで抜け出す\n            v = n;\n        } else if(d < 0.15 && dot(v, n) < 0.) { // 壁に近い場合、壁と平行にしか進めないようにする\n            vec2 nv = vec2(n.y, -n.x);\n            v = nv * dot(nv, v);\n        }\n        \n        if(iMouse.z > 0.) {\n            ro.xz += v * 0.01;\n            ro.y += abs(sin(fract(iTime * 4.) * PI) * 0.01); // プレイヤーが走っているように、カメラを上下に揺らす\n        }\n    }\n\n    // 画面のuv座標とカメラの向きからレイベクトルを求める\n    dir = normalize(dir);\n    vec3 side = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 up = cross(side, dir);\n    rd = normalize(vec3(uv.x * side + uv.y * up + dir / tan(FOV)));\n}\n\n// ショボンの位置と向きを初期化・更新する\nvoid doEnemy() {\n    enemyPos.y = abs(sin(iTime * 3.)) * 0.1 + enemySize; // 床の上で跳ねる\n    enemyPos.xz = vec2(1e5);\n    enemyDirA = 0.;\n    if(iTime > sceneTime5) { // プレイヤーを追跡\n        vec3 texE = texture(iChannel0, vec2(200.5, 0.5) / iResolution.xy).rgb; // プレイヤーの過去の位置・向きを取得\n        enemyPos.xz = texE.rg;\n        enemyDirA = texE.b;\n    }\n}\n\n// uvをずらしてグリッチ\nvec2 glitch(vec2 uv, float rate) {\n    float T = fract(iTime / 10.) * 10.;\n    float vx = hash12(vec2(floor(uv.y * 20.), T));\n    float vy = hash12(vec2(floor(uv.y * 20.), T + 500.));\n    float v = floor(hash12(vec2(floor(uv.y * 6. - T * 3.))) * 6.) - 2.5;\n    vec2 shift = vec2(vx, vy) * v / 2.5;\n    uv -= shift * rate;\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (FC.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y); // 座標の正規化\n\n    // HPが0になったら画面を停止して、全ての処理を終了する\n    float HP = 1.; // HPを初期化\n    if(iTime > sceneTime5) {\n        HP = texture(iChannel0, vec2(0.5, 1.5) / iResolution.xy).a;\n        //HP = texture(iChannel0, (iResolution.xy / 2. + 0.5) / iResolution.xy).a;\n        if(HP < damageRate) {\n            o = texture(iChannel0, FC.xy / iResolution.xy);\n            return;\n        }\n    }\n\n    float T = fract(iTime / 10.) * 500.;\n    // 最初の時間は画面にノイズを表示する\n    if(iTime + hash11(T) * 2.5 < sceneTime1) {\n        vec2 i = floor(uv * 100.);\n        i += hash12(i) * 500.;\n        o = vec4(vec3(hash12(i + T)), 1.);\n        return;\n    }\n    // グリッチのエフェクトをかける\n    uv = glitch(uv, smoothstep(sceneTime2 + EPS, sceneTime1, iTime));\n\n    vec3 ro;  // カメラの位置（レイの原点）\n    vec3 rd;  // レイの向き\n    vec3 dir; // カメラの向き\n    float dirA; // カメラの向き（XZ平面内での角度（ラジアン））\n    float dirY;\n    //doCamera(uv, ro, dirA, dir, rd); // カメラの位置・向きを初期化・更新する\n    doCamera(uv, ro, dirA, dirY, dir, rd); // カメラの位置・向きを初期化・更新する\n    doEnemy(); // ショボンの位置・向きを初期化・更新する\n\n    // パストレーシングで使う乱数のシードを初期化する\n    pathSeed = hash12(FC.xy * PI) * 500.;\n    pathSeed += hash12(FC.xy + pathSeed + T) * 500.;\n\n    // パストレーシングをする\n    vec3 col = vec3(0);\n    col = pathTrace(ro, rd);\n    col = pow(col, vec3(1. / 2.2)); // ガンマ補正\n\n    // パストレーシングで得られた色の分散を低減するために前のフレームの色を合成する\n    float tex = 0.7;\n    //col *= 1. - tex;\n    //col += texture(iChannel0, FC.xy / iResolution.xy).rgb * tex;\n    col = mix(col, texture(iChannel0, FC.xy / iResolution.xy).rgb, tex);\n\n    // ダメージの処理\n    if(iTime > sceneTime5) {\n        // 敵に接近するとダメージを受ける\n        if(length(enemyPos - ro) < enemySize + 0.2) {\n            HP = max(HP - damageRate, 0.); // HP減少\n            col = mix(col, vec3(1, 0, 0), 0.15); // ダメージエフェクト\n        }\n    }\n\n    // HUDを表示\n    if(iTime > sceneTime3) {\n        col = colHUD(col, uv, ro.xz, dirA, HP);\n    }\n\n    col = clamp(col, 0., 1.);\n    o.rgb = col;\n\n    // プレイヤー（カメラ）の位置・向き・HPを保存\n    if(FC.y < 0.6) {\n        if(FC.x < 0.6) {\n            //o.rgb = vec3(ro.xz, dirA); // プレイヤーの位置と向きを保存\n            o = vec4(ro.xz, dirA, dirY); // プレイヤーの位置と向きを保存\n        } else {\n            // プレイヤーの過去の状態をショボンの状態として使うため、ずらして過去の状態を保持する\n            o.rgb = texture(iChannel0, vec2(FC.x - 1., 0.5) / iResolution.xy).rgb;\n        }\n    }\n    if(FC.x < 0.6 && FC.y > 0.6 && FC.y < 1.6) {\n        o.a = HP; // HPを保存\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define hash(x) fract(sin(x) * 43758.5453)\nconst float PI2 = acos(-1.) * 2.;\nconst float sceneTime2 = 8.;  // グリッチの終了時間\n\nvec2 mainSound( int samp, float time )\n{\n    float res = 0.;\n    float T = fract(time / 10.) * 500.;\n    \n    if(time + hash(floor(T) * 20.) * 5.5 < sceneTime2) {\n        return vec2(hash(T) - 0.5) * 0.2;\n    }\n    \n    res = (fract(-time * 50.) - 0.5) * 0.04;\n    res += (fract(-time * 100.) - 0.5) * 0.04;\n    \n    float N = 15.;\n    for(float i = 0.; i < N; i++) {\n        float T = time + i / N;\n        float I = floor(T);\n        float F = fract(T);\n        float ID = i + I * N;\n        float h = hash(ID);\n        if(h < 0.2) {\n            res += sin(F * PI2 * 50. * 140.) * exp(-F * 15.) * h * 0.3;\n        }\n    }\n    \n    return vec2(res);\n}","name":"Sound","description":"","type":"sound"}]}