{"ver":"0.1","info":{"id":"XsVSDD","date":"1464631620","viewed":282,"name":"Everywhere","username":"dila","description":"Demo of camera movement. I suck at actually shading the surfaces, sorry.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float t)\n{\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat tunnel(vec3 p)\n{\n\tfloat d = 0.0;\n    float k = 1.0;\n    d = 0.5 + k - abs(p.x);\n    d = min(d, -0.1 + k - abs(p.y));\n    return d;\n}\n\nfloat map(vec3 p)\n{    \n\tfloat d = 1000.0;\n    \n    vec3 q = p;\n    q.x = mod(p.x - 2.0, 4.0) - 2.0;\n    q.y = mod(p.y - 2.0, 4.0) - 2.0;\n    d = tunnel(q);\n    \n    q = p;\n    q.y = mod(p.y - 2.0, 4.0) - 2.0;\n    q.z = mod(p.z, 4.0) - 2.0;\n    d = max(d, tunnel(q.zyx));\n    \n    q = p;\n    q.y = mod(p.y, 4.0) - 2.0;\n    q.z = mod(p.z - 2.0, 4.0) - 2.0;\n    d = max(d, tunnel(q.zyx));\n    \n    q = p;\n    q.x = mod(p.x - 2.0, 4.0) - 2.0;\n    q.z = mod(p.z - 2.0, 4.0) - 2.0;\n    d = max(d, tunnel(q.xzy));\n    \n    q = p;\n    q.x = mod(p.x, 4.0) - 2.0;\n    q.z = mod(p.z, 4.0) - 2.0;\n    d = max(d, tunnel(q.xzy));\n    \n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n    }\n    return t;\n}\n\nfloat axis(float t, float k)\n{\n    float n = t / 4.0;\n    float m = n * log2(n);\n    float a = clamp(t - k + m, 0.0, 1.0);\n    float b = clamp(t - k - m, 0.0, 1.0);\n    float r = mix(a, b, 0.5);\n\tfloat s = 1.0-smoothstep(0.0, 1.0, 1.0-r);\n    return s;\n}\n\nfloat ptime()\n{\n    return iTime * 0.2;\n}\n\nvec3 path(float to)\n{\n    float r = fract(ptime());\n\tfloat t = r * 4.0 - to * r * log2(r);\n    float cx = axis(t, 2.0) * 4.0;\n    float cy = axis(t, 1.0) * 2.0 + axis(t, 3.0) * 2.0;\n    float cz = axis(t, 0.0) * 4.0;\n    return vec3(cx, cy, cz);\n}\n\nvec3 _texture(vec3 p)\n{\n\tvec3 ta = texture(iChannel0, p.yz).xyz;\n    vec3 tb = texture(iChannel0, p.xz).xyz;\n    vec3 tc = texture(iChannel0, p.xy).xyz;\n    return ta*ta + tb*tb + tc*tc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.33));\n    \n    float ft = fract(ptime());\n\tfloat g = ft * 4.0;\n    float fl = floor(ptime());\n    r.xy *= rot(fl * 3.14159 * cos(fl * 3.14) + sin(iTime * 0.5) * 2.0);\n    r.yz *= rot(axis(g, 3.0) * -1.57);\n    r.xz *= rot(axis(g, 2.0) * -1.57);\n    r.yz *= rot(axis(g, 0.0) * 1.57);\n    r.xy *= rot(axis(g, 1.0) * 1.57);\n    \n    vec3 o = path(0.0);\n    vec3 fc = vec3(0.0);\n    float lf = 1.0;\n    float gt = 0.0;\n    \n    for (int i = 0; i < 2; ++i) {\n    \n        float t = trace(o, r);\n        gt += t;\n        \n        vec3 w = o + r * t;\n        vec3 sn = normal(w);\n\n        float fd = map(w);\n        vec3 tw = vec3(w.xy * rot(fl * 3.14159), w.z);\n        vec3 tex = _texture(tw * 0.5).xyz;\n\n        float fog = 1.0 / (1.0 + gt * gt * 0.1);\n        float fh = 1.0 / (1.0 + fd * 100.0);\n        \n        float nf = abs(dot(r, sn));\n        nf = mix(nf, 1.0, 1.0-fh);\n        \n        float rs = - ft * log2(ft);\n        vec3 lof = vec3(0.1);\n        lof.xy *= rot(fl * 3.14159);\n        vec3 lp = path(0.0) + lof;\n        vec3 lv = lp - w;\n        float ld = length(lv);\n        lv /= ld;\n\t\tfloat lr = max(dot(lv, sn), 0.0);\n        vec3 lx = reflect(lv, sn);\n        float spec = pow(max(dot(r, lx), 0.0), 128.0);\n        float ly = 1.0 / (1.0 + ld * ld * 0.01);\n        \n        float lt = trace(lp + sn * 0.1, -lv);\n        float lm = max(sign(lt - ld), 0.0);\n        \n\t\tfc += (tex * lf * nf * lr) * ly * fog * lm;\n        \n        lf = 1.0 - nf;\n        \n        r = reflect(r, sn);\n        o = w + sn * 0.1;\n    }\n    \n\tfragColor = vec4(sqrt(fc), 1.0);\n}","name":"Image","description":"","type":"image"}]}