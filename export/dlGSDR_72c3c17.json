{"ver":"0.1","info":{"id":"dlGSDR","date":"1686034006","viewed":34,"name":"shader_z","username":"maria_s","description":"1","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"bool InTriangle(vec3 v0, vec3 v1, vec3 v2, vec2 p)\n{\n    float area = 0.5 * (-v1.y * v2.x + v0.y * (-v1.x + v2.x) + v0.x * (v1.y - v2.y) + v1.x * v2.y);\n    float s = 1.0 / (2.0 * area) * (v0.y * v2.x - v0.x * v2.y + (v2.y - v0.y) * p.x + (v0.x - v2.x) * p.y);\n    float t = 1.0 / (2.0 * area) * (v0.x * v1.y - v0.y * v1.x + (v0.y - v1.y) * p.x + (v1.x - v0.x) * p.y);\n    float w = 1.0 - s - t;\n    return (s >= 0.0 && t >= 0.0 && w >= 0.0);\n}\n\nbool InCyrcle(vec2 uv, float r, float offsetx, float offsety) {\n  float x = uv.x -offsetx;\n  float y = uv.y - offsety;\n  float d = length(vec2(x, y)) - r;\n  if(d>0.) return false; else return true;\n}\n\nfloat getZ(vec2 uv, float r, float offsetx, float offsety, float offsetx_0, float offsety_0){\n     float z=sqrt(r*r-(offsetx-offsetx_0)*(offsetx-offsetx_0)-(offsety-offsety_0)*(offsety-offsety_0));\n    return z;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n     uv.x *= iResolution.x / iResolution.y;\n     //move\n     vec2 offset2 = vec2(cos(iTime*2.)*0.2, cos(iTime*2.)*0.2);\n     float offset = (mod(iTime * .3, 2.5));\n     //float offset1 = (mod(1.2, iTime * .3));\n     // tr1\n    vec3 v0_1 = vec3(0.1+offset2.x, 0.4+offset2.y, -5.0);\n    vec3 v1_1 = vec3(0.8+offset2.x, 0.2+offset2.y, 0.0);\n    vec3 v2_1 = vec3(0.5+offset2.x, 0.8+offset2.y, -1.0);\n     // tr 2 (str)\n    vec3 v0_2 = vec3(0.1-offset2.x, 1.0-offset2.y, 0.);\n    vec3 v1_2 = vec3(1.9-offset2.x, 0.6-offset2.y, 0.);\n    vec3 v2_2 = vec3(1.2-offset2.x, 0.2-offset2.y, 0.);\n    \n    // create figures\n    bool Triangle1 = InTriangle(v0_1, v1_1, v2_1, uv);\n    bool Triangle2 = InTriangle(v0_2, v1_2, v2_2, uv);\n    bool Cyrcle1 = InCyrcle(uv, .2, 0.3+offset, 0.5);\n    bool Cyrcle2 = InCyrcle(uv, .15, .6, 0.3);\n    bool Cyrcle3 = InCyrcle(uv, .3, .5, 0.7);\n    // figures ar\n    bool arr[5];\n    arr[0]=Triangle1;\n    arr[1]=Triangle2;\n    arr[2]=Cyrcle1;\n    arr[3]=Cyrcle2;\n    arr[4]=Cyrcle3;\n    //creating str\n    float stripes = floor(uv.x * 35.0); //stripes\n    vec3 col_y = vec3(1.0, 1.0, 0.62); // жёлтый\n    vec3 col_p = vec3(0.8, 0.64, 0.87); //фиол-й\n    vec3 col_gr = vec3(0.62, 0.88, 0.62);//зел-й\n    vec3 col_r = vec3(0.98,0.7,0.83);//розовый\n    vec3 stripesColor3 = mix(col_y, col_gr, mod(cos(stripes), 2.0));\n    vec3 stripesColor1 = mix(col_p, col_r, mod(floor(sin((uv.x+offset2.x))*25.0), 2.0));\n    // colours vec\n    vec4 col[5];\n    col[0]=vec4(0.8, 0.64, 0.87,1.0);\n    col[1]=vec4(stripesColor1, 1.0);\n    col[2]=vec4(1.0, 1.0, 0.62, 1.0);\n    col[3]=vec4(0.46, 0.86,0.9, 1.0);\n    col[4]=vec4(stripesColor3, 1.0);\n    \n    vec4 col_bg=vec4(1.0, 0.81, 0.67, 1.0);// background\n    float m=-1000.0;\n    // z coord\n    float z[5];\n    z[0] = v0_1.z+(v1_1.z-v0_1.z)*uv.x+(v2_1.z-v0_1.z)*uv.y;\n    z[1] = v0_2.z+(v1_1.z-v0_2.z)*uv.x+(v2_2.z-v0_2.z)*uv.y;\n    z[3] = -0.5;\n    z[2] = 0.7;\n    z[4] = getZ(uv,.3, .5, 0.7,uv.x,uv.y);\n    int i;\n    for(i=0; i<5; i++){\n        if(arr[i]){// красит по области\n            if(z[i]>m){//красит по z\n            col_bg=col[i];\n            m=z[i];\n            }\n        }\n    }\n    fragColor = vec4(col_bg);\n}","name":"Image","description":"","type":"image"}]}