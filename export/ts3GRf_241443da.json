{"ver":"0.1","info":{"id":"ts3GRf","date":"1568999607","viewed":116,"name":"Yellow Blob","username":"j0","description":"A first attempt at raymarching :) There's probably a bunch of mistakes but i'm not rly expecting anyone to point them out cos my code is a huge mess woop","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 1000\n#define MAX_DISTANCE 100.\n#define MIN_DISTANCE 0.02\n\n//https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k ){\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdSphere(vec3 p, vec4 s){ return length(s.xyz-p) - s.w; }\n\nfloat Distance(vec3 p){\n    vec4 s1 = vec4(0., 1.+sin(iTime*0.564)*0.1, 0., 1.);\n    vec4 s2 = vec4(2.*sin(iTime), 1., 0., 0.4);\n    vec4 s3 = vec4(0., 1., 0.2, 1.);\n    \n    float sd = sdSphere(p, s1);\n    sd = max(-sdSphere(p, s3), sd);\n    sd = smin(sd, sdSphere(p, s2), 5.);\n    float pd = abs(p.y);\n    \n    float d = smin(sd, pd, 5.);\n    return d;\n}\n\nfloat CastRay(vec3 o, vec3 dir){\n    float d = 0.;\n    for(int i = 0; i<MAX_STEPS; ++i){\n        float dist = Distance(o+dir*d);\n        d += dist;\n        if(dist < MIN_DISTANCE || d > MAX_DISTANCE) break;\n    }\n    return d;\n}\n\nvec3 GetNormal(vec3 p){\n\tfloat d = Distance(p);\n    vec2 e = vec2(.01, 0.);\n    vec3 n = d - vec3(Distance(p-e.xyy), Distance(p-e.yxy), Distance(p-e.yyx));\n    return normalize(n);\n}\n\nfloat Light(vec3 p, vec3 lightPos){\n    vec3 toLight = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n   \tfloat diffuse = dot(n, toLight);\n    \n    float distToLight = CastRay(p + n * MIN_DISTANCE * 2., n) / length(lightPos-p);\n    diffuse *= clamp(distToLight, 0., 1.);\n    \n    return clamp(diffuse, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    vec3 cameraPos = vec3(sin(iTime*0.291)*0.5, 1., 6.);\n    vec3 cameraFwd = vec3(0., 0., -1.);\n    vec3 cameraUp = vec3(0., 1., 0.);\n    vec3 cameraRight = vec3(1., 0., 0.);\n    float zoom = 1.5+sin(iTime*0.347)*0.2;\n    \n    vec3 rayOrigin = cameraPos + cameraFwd*zoom + cameraUp*uv.y + cameraRight*uv.x;\n    vec3 rayDirection = normalize(rayOrigin-cameraPos);\n    \n    float d = CastRay(rayOrigin, rayDirection);\n    vec3 point = rayOrigin + rayDirection * d;\n    \n \tvec3 lightPos = vec3(0., 0.5, 0.);\n    lightPos.xz += vec2(sin(iTime), cos(iTime)) * 1.;\n    col += Light(point, lightPos * 1.5) * vec3(1., 0., 0.);\n    \n    lightPos = vec3(0., 3., cos(iTime*0.87))*(3.+sin(iTime*2.));\n    col += Light(point, lightPos) * vec3(1., 1., 0.);\n    \n    col += vec3(0., 0., 0.35);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}