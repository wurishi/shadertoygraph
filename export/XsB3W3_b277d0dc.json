{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n// **************************************************************************\n// CONSTANTS\n\n#define PI 3.14159\n#define TWO_PI 6.28318\n\n#define EPSILON 0.0001\n#define BIG_FLOAT 1000000.\n\n// Increase this to 5 to anti-alias and to warm up your GPU\n#define NUM_AA_SAMPLES 1.\n\n// **************************************************************************\n// DEFINES\n\n#define PLANE_MATL 1.\n#define ELLINGTON_BODY_MATL 2.\n#define ELLINGTON_SCLERA_MATL 3.\n#define ELLINGTON_PUPIL_MATL 4.\n\n// http://www.webonweboff.com/tips/js/event_key_codes.aspx\n#define KEY_SHIFT ((16.0 + .5)/256.0)\n\n// **************************************************************************\n// GLOBALS\n\nvec3  g_camPointAt   = vec3(0.);\nvec3  g_camOrigin    = vec3(0.);\n\nfloat g_time         = 0.;\nvec4  g_debugcolor   = vec4(0.);\n\nvec3  g_ellingtonLookingAt = vec3(0.);\n\n// **************************************************************************\n// UTILITIES\n\nfloat close(float a, float b) { return step(abs(a-b), EPSILON); }\n\nmat3 invert_mat3( mat3 m )\n{\n    mat3 invm = mat3(1.);\n    float invd = 1./(m[0][0]*m[1][1]*m[2][2] - m[0][0]*m[2][1]*m[1][2] +\n                     m[1][0]*m[2][1]*m[0][2] - m[1][0]*m[0][1]*m[2][2] +\n                     m[2][0]*m[0][1]*m[1][2] - m[2][0]*m[1][1]*m[0][2]);\n\n    // Needs optimization\n    invm[0][0] = (m[1][1]*m[2][2] - m[2][1]*m[1][2]) * invd;\n    invm[1][0] = - (m[1][0]*m[2][2] - m[2][0]*m[1][2]) * invd;\n    invm[2][0] = (m[1][0]*m[2][1] - m[2][0]*m[1][1]) * invd;\n\n    invm[0][1] = - (m[0][1]*m[2][2] - m[2][1]*m[0][2]) * invd;\n    invm[1][1] = (m[0][0]*m[2][2] - m[2][0]*m[0][2]) * invd;\n    invm[2][1] = - (m[0][0]*m[2][1] - m[2][0]*m[0][1]) * invd;\n\n    invm[0][2] = (m[0][1]*m[1][2] - m[1][1]*m[0][2]) * invd;\n    invm[1][2] = - (m[0][0]*m[1][2] - m[1][0]*m[0][2]) * invd;\n    invm[2][2] = (m[0][0]*m[1][1] - m[1][0]*m[0][1]) * invd;\n\n    return invm;\n}\n\nvec3 orient_to_y( vec3 p, vec3 v )\n{\n    // assume v is a normalized vector that we will use to\n    // orient with the y-axis\n\n    // if v is pointing exactly in the positive or negative\n    // y direction, then we can return the positive or negative\n    // identity respectively.\n    if (close(abs(v.y), 1.) > .5) return sign(v.y) * p;\n\n    vec3 v1 = v;\n    vec3 up = vec3(0., 1., 0.); // assuming up vector in world is y\n    vec3 v3 = normalize(cross(v1, up));\n    vec3 v2 = cross(v3, v1);\n    \n    // Align the y-axis with the src vector\n    mat3 m = mat3(v2, v1, v3);\n\n    // invert the 3x3 matrix and apply it to p\n\t// TODO - this is overkill! - I know this matrix is \n\t// orthogonal, just take the transpose\n    return invert_mat3(m) * p;\n}\n\nvec2 merge_objs(vec2 a, vec2 b) { return mix(b, a, step(a.x, b.x)); }\n\nfloat union_df(float a, float b) { return min(a, b); }\nfloat inters_df(float a, float b) { return max(a, b); }\nfloat diff_df(float a, float b) { return max(a, -b); }\n\n// Periodic saw tooth function that repeats with a period of \n// 4 and ranges from [-1, 1].\n// The function starts out at 0 for x=0,\n//  rises to 1 for x=1,\n//  drops to 0 for x=2,\n//  continues to -1 for x=3,\n//  and then rises back to 0 for x=4\n// to complete the period\n\nfloat sawtooth( float x )\n{\n    float xmod = mod(x+3.0, 4.);\n    return abs(xmod-2.0) - 1.0;\n}\n\n// returns \"very pseudo\" random number between -1 and 1 based on seed\nfloat noise1f( float seed ) { return sin(28.41 * seed); }\n\n// returns power perlin noise between -1 and 1 based on seed. Increase\n// p to accentuate the contrast between noise samples.\nvec2 ppnoise2v( float seed, float p )\n{\n    float ni = floor( seed );\n    float nf = fract( seed );\n    nf = nf*nf*(3.0-2.0*nf);\n\n    float x = ni;\n    float y = 13. * ni;\n    \n    nf = pow(nf, p);\n    return vec2(mix(noise1f(x + 0.), noise1f(x + 1.),  nf),\n                mix(noise1f(y + 0.), noise1f(y + 13.), nf));\n}\n\n// **************************************************************************\n// DISTANCE FIELDS\n\n\nfloat sphere_df( vec3 p, float r ) { return length(p) - r; }\nfloat plane_df( vec3 p, float o ) { return p.y - o; }\n\n#define EVENT_DURATION 15.\n\nvec2 ellington_df( vec3 pos ) \n{\n    vec3 bodyp = pos;\n\n    vec2 ellingtonobj = vec2(BIG_FLOAT, ELLINGTON_BODY_MATL);\n\n    // ellington is enjoying himself\n    bodyp = orient_to_y(bodyp, normalize(vec3(10. + .8 * cos(7. * g_time), 100., -0.1)));\n        \n    float event_t  = mod(g_time, EVENT_DURATION);\n    float enter_t  = event_t + 0.1;\n    float exit_t   = event_t - (EVENT_DURATION - 2.);\n    \n    // reflect in the yz plane\n    bodyp.x += 1.25 * noise1f(.01 * floor(g_time/EVENT_DURATION));\n    float bodyside = sign(bodyp.x);\n    bodyp.x = abs(bodyp.x);    \n    bodyp.y += .1;\n    \n    // squetch into screen\n    float squash_stretch_enter = step(0., enter_t) * sin(14. * enter_t) * exp(-4.8 * enter_t);\n    bodyp.y -= 1.7 * squash_stretch_enter - step(0., enter_t) * 5. * sin(14. * enter_t) * exp(-4. * enter_t);\n    bodyp.y *= 1. + .8 * squash_stretch_enter;\n    bodyp.x *= 1. - .9 * squash_stretch_enter;\n\n    // squetch off screen\n    float squash_stretch_exit = step(0., exit_t) * sin(10. * exit_t) * exp(-4. * exit_t);\n    bodyp.y -= 1.7 * squash_stretch_exit + step(0., exit_t) * 10. * max(-1., -exit_t * exit_t);\n    bodyp.y *= 1. - .5 * squash_stretch_exit;\n    bodyp.x *= 1. + .5 * squash_stretch_exit;\n\n    // shape ellington's body\n    bodyp.xz *= vec2(.89, 1.);    \n    ellingtonobj.x = sphere_df( bodyp, 1. );\n\n    // place ellington's eyes\n    vec2 eyeobj = vec2(BIG_FLOAT, ELLINGTON_SCLERA_MATL);\n    vec3 eyep = bodyp - vec3(.42, -.05, .85);\n    \n    // orient the eyes \n    eyep = orient_to_y(eyep, normalize(vec3(-.14, .9, -.3))); \n    eyep.yz *= vec2(.48, .5);\n    eyep.y *= -1.; eyep.y += .2;\n\n    // shape ellington's sclera\n    eyeobj.x = sphere_df( eyep, .2 );\n\n    // shape ellington's pupils\n    vec2 pupilobj = vec2(BIG_FLOAT, ELLINGTON_PUPIL_MATL);    \n    vec3 pupildir = vec3(0.2 , 0.01, -.155); // neutral pupil position\n\n    // have his eyes dart around\n    // he's got a bit of a lazy eye since I'm too lazy to do this math\n    // correctly.\n    vec3 lookdir = g_ellingtonLookingAt - vec3(0., -.1, 0.);\n    vec3 viewdir = g_camOrigin - g_camPointAt;\n    pupildir += .065 * vec3(bodyside, 1., 1.) * (viewdir - lookdir);\n\n    vec3 pupilp = eyep - .2 * normalize( pupildir );\n    pupilobj.x = inters_df( sphere_df( pupilp, .06 ), sphere_df( eyep, .21 ) );\n\n    // shape ellington's eye lids and time blinks\n    vec2 lidsobj = vec2(BIG_FLOAT, ELLINGTON_BODY_MATL);  \n    float bt = mod(g_time, 5.);\n    float bdur = .26;\n    float bstart = (5.-bdur) * (.5 * noise1f( floor(g_time/5.) ) + .5);\n    float blink = -.22 + .43 * (step(bstart, bt) - step(bstart + bdur, bt)) * sin((PI/bdur) * (bt - bstart));\n    lidsobj.x  = inters_df( sphere_df( eyep, .212 ),  plane_df( eyep, blink ) );\n\n    // merge ellington all together\n    ellingtonobj = merge_objs(ellingtonobj, eyeobj);\n    ellingtonobj = merge_objs(ellingtonobj, pupilobj);\n    ellingtonobj = merge_objs(ellingtonobj, lidsobj);\n\n    return ellingtonobj;\n}\n\nvec2 plane_df( vec3 pos ) \n{\n    return vec2(abs( pos.y + 1. ), PLANE_MATL);\n}\n\n// **************************************************************************\n// SCENE MARCHING\n\nvec2 scene_df( vec3 pos )\n{\n    vec2 obj = vec2(BIG_FLOAT, -1.);\n\n    obj = merge_objs(obj, ellington_df( pos ));    \n    obj = merge_objs(obj, plane_df( pos ));\n\n    return obj;\n}\n\n#define DISTMARCH_STEPS 50\n#define DISTMARCH_MAXDIST 50.\n\nvec2 dist_march( vec3 ro, vec3 rd, float maxd )\n{\n    \n    float epsilon = 0.001;\n    float dist = 10. * epsilon;\n    float t = 0.;\n    float material = 0.;\n    for (int i=0; i < DISTMARCH_STEPS; i++) \n    {\n        if ( abs(dist) < epsilon || t > maxd ) continue;\n        // advance the distance of the last lookup\n        t += dist;\n        vec2 dfresult = scene_df( ro + t * rd );\n        dist = dfresult.x;\n        material = dfresult.y;\n    }\n\n    if( t > maxd ) material = -1.0; \n    return vec2( t, material );\n}\n\n// **************************************************************************\n// SHADOWING & NORMALS\n\n#define SOFTSHADOW_STEPS 30\n#define SOFTSHADOW_STEPSIZE .2\n\nfloat soft_shadow( vec3 ro, \n                      vec3 rd, \n                      float mint, \n                      float maxt, \n                      float k )\n{\n    float shadow = 1.0;\n    float t = mint;\n\n    for( int i=0; i < SOFTSHADOW_STEPS; i++ )\n    {\n        if( t < maxt )\n        {\n            float h = scene_df( ro + rd * t ).x;\n            shadow = min( shadow, k * h / t );\n            t += SOFTSHADOW_STEPSIZE;\n        }\n    }\n    return clamp( shadow, 0.0, 1.0 );\n\n}\n\nvec3 calc_normal( vec3 p )\n{\n    vec3 epsilon = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\n        scene_df(p + epsilon.xyy).x - scene_df(p - epsilon.xyy).x,\n        scene_df(p + epsilon.yxy).x - scene_df(p - epsilon.yxy).x,\n        scene_df(p + epsilon.yyx).x - scene_df(p - epsilon.yyx).x );\n    return normalize( n );\n}\n\n#define AO_NUMSAMPLES 6\n#define AO_STEPSIZE .1\n#define AO_STEPSCALE .3\n\nfloat calc_ao( vec3 p, \n              vec3 n )\n{\n    float ao = 0.0;\n    float aoscale = 1.0;\n\n    for( int aoi=0; aoi< AO_NUMSAMPLES ; aoi++ )\n    {\n        float step = 0.01 + AO_STEPSIZE * float(aoi);\n        vec3 aop =  n * step + p;\n        \n        float d = scene_df( aop ).x;\n        ao += -(d-step)*aoscale;\n        aoscale *= AO_STEPSCALE;\n    }\n    \n    return clamp( ao, 0.0, 1.0 );\n}\n\n// **************************************************************************\n// SHADING\n\nstruct SurfaceData\n{\n    float id;\n    vec3 point;\n    vec3 normal;\n    vec3 vdir;\n};\n\n\nvec3 shade_surface(SurfaceData surf)\n{\n\n    vec3 surfcol = vec3(1.);\n    if (close(surf.id, PLANE_MATL) > .5) {\n        surfcol = vec3(0.9, 0.9, 1.);    \n    } else if (close(surf.id, ELLINGTON_BODY_MATL) > .5) {\n        surfcol = vec3(255., 51., 0.)/255.;\n    } else if (close(surf.id, ELLINGTON_SCLERA_MATL) > .5) {\n        surfcol = vec3(1., 1., 1.);\n    }else if (close(surf.id, ELLINGTON_PUPIL_MATL) > .5) {\n        surfcol = vec3(0.05);\n    }\n    \n    // ambient occlusion is amount of occlusion.  So 1 is fully occluded\n    // and 0 is not occluded at all.  Makes math easier when mixing \n    // shadowing effects.\n    float ao = calc_ao(surf.point, surf.normal);\n    vec3 keydir = normalize( vec3(4., 5.,3.) );\n    float diff = clamp( dot( surf.normal, keydir ), 0., 1.);\n    float amb = .35;\n\n    vec3 rimdir = normalize( vec3(-5., 4., -4.) );\n    vec3 hdir = normalize(rimdir + surf.vdir);\n    float rim = 3. * clamp( dot(hdir, surf.normal), 0., 1.);\n\n\t// shadowing is reverse of occlusion where a shadow value of 1 is\n\t// no shadow.  confusing... I should fix this.\n    float sshad = 1.;\n    if ( diff > 0.02 )\n    {\n        sshad = soft_shadow( surf.point, keydir, 0.02, 10., 7.);\n    }\n    \n    return surfcol * (rim + diff * sshad + amb * (1. - 3.5 * ao)); \n\n}\n\n// **************************************************************************\n// CAMERA & GLOBALS\n\nstruct CameraData\n{\n    vec3 origin;\n    vec3 dir;\n    vec2 st;\n};\n\nCameraData setup_camera( vec2 aaoffset, vec2 fragCoord )\n{\n\n    float invar = iResolution.y / iResolution.x;\n    vec2 st = (fragCoord.xy + aaoffset) / iResolution.xy - .5;\n    st.y *= invar;\n\n    // calculate the ray origin and ray direction that represents\n    // mapping the image plane towards the scene for a pinhole\n\t// camera\n    vec3 iu = vec3(0., 1., 0.);\n\n    vec3 iz = normalize( g_camPointAt - g_camOrigin );\n    vec3 ix = normalize( cross(iz, iu) );\n    vec3 iy = cross(ix, iz);\n\n    vec3 dir = normalize( st.x*ix + st.y*iy + 1.0 * iz );\n\n    return CameraData(g_camOrigin, dir, st);\n\n}\n\nvoid animate_globals()\n{\n    // remap the mouse click ([-1, 1], [-1/ar, 1/ar])\n    float invar = iResolution.y/iResolution.x;\n    vec2 click = iMouse.xy / iResolution.xy - .5;    \n    click *= 2.;  click.y *= invar;\n    \n    g_time = max(0., iTime - 2.);\n\n    // camera position\n    g_camOrigin = vec3(0.0, 0.5, 5.0);    \n    g_ellingtonLookingAt = vec3(0.0, 0.5, 5.0);\n\n    float shift_pressed = texture( iChannel0, vec2(KEY_SHIFT, .25)).x;\n    float seed = 100. * sawtooth(.01 * g_time);\n    g_ellingtonLookingAt.xy += mix( vec2(1., invar) * ppnoise2v(.7 * seed, 4.),\n                                    click,\n                                    shift_pressed );\n\n    g_camPointAt   = vec3(0., .6, 0.);\n\n}\n\n// **************************************************************************\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    \n    // ----------------------------------\n    // Animate globals\n\n    animate_globals();\n\n\n    vec3 scenecol = vec3(0.);\n    float denom = TWO_PI/max(1., NUM_AA_SAMPLES-1.);\n\t// The first sample does not have any aa offset, but the subsequent\n\t// samples are offset onto a circle that's a pixel wide.\n    for (float aa = 0.; aa < NUM_AA_SAMPLES; aa += 1.) \n    {\n\n        vec2 aaoffset = step(.5, aa) * .5 * vec2( cos((aa-1.) * denom ),\n                                                  sin((aa-1.) * denom ) );\n\n\t\t// ----------------------------------\n\t\t// SETUP CAMERA\n\t\t\n        CameraData cam = setup_camera( aaoffset, fragCoord);\n\n        // ----------------------------------\n        // SCENE MARCHING\n\n        vec2 scenemarch = dist_march( cam.origin, \n                                      cam.dir, \n                                      DISTMARCH_MAXDIST );\n        \n        // ----------------------------------\n        // SHADING\n        if (scenemarch.y > 0.)\n        {\n            vec3 mp = cam.origin + scenemarch.x * cam.dir;\n            vec3 mn = calc_normal( mp );\n\n            SurfaceData currSurf = SurfaceData(scenemarch.y,\n                                               mp, mn, normalize(mp - cam.origin));\n\n            // fall off exponentially into the distance (as if there is a spot light\n            // on the point of interest).\n            scenecol += shade_surface( currSurf ) * exp( -0.01*scenemarch.x*scenemarch.x );\n        }\n    \n    }\n\n    scenecol /= NUM_AA_SAMPLES;\n\n    // ----------------------------------\n    // POST PROCESSING\n\n    // Gamma correct\n    scenecol = pow(scenecol, vec3(.45));\n\n    // Contrast adjust - cute trick learned from iq\n    // scenecol = mix( scenecol, vec3(dot(scenecol,vec3(0.333))), 0. );\n\n    // color tint\n    // scenecol = .5 * scenecol + .5 * scenecol * vec3(1., 1., 1.);\n    \n    if (g_debugcolor.a > 0.) \n    {\n        fragColor.rgb = g_debugcolor.rgb;\n    } else {\n        fragColor.rgb = scenecol;\n    }\n\n    fragColor.a = 1.;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsB3W3","date":"1393952577","viewed":980,"name":"Ellington visits ShaderToy","username":"mplanck","description":"Ellington from ToyTalk visits Shadertoy.   He's an engineer at heart so he's excited to be in WebGL.  Hold shift to control Ellington's eyes.","likes":11,"published":1,"flags":16,"usePreview":0,"tags":["antialias","distancemarching","ellington"],"hasliked":0,"parentid":"","parentname":""}}