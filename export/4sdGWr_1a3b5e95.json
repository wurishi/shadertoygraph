{"ver":"0.1","info":{"id":"4sdGWr","date":"1465379908","viewed":223,"name":"Schottky Mountain","username":"soma_arc","description":"Kissing Schottky groups + Terrain raymarching\nReference: Terrain raymarching by iq\nhttps://iquilezles.org/articles/terrainmarching/terrainmarching.htm","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","schottkygroups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nCreated by soma_arc - 2016\nThis work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported.\n*/\n\nconst float PI = 3.14159265;\nvec2 circleInverse(vec2 pos, vec2 circlePos, float circleR){\n\treturn ((pos - circlePos) * circleR * circleR)/(length(pos - circlePos) * length(pos - circlePos) ) + circlePos;\n}\n\nfloat LINE_THRESHOLD = 0.0001;\nvec3 getLine(vec2 p1, vec2 p2){\n  float xDiff = p2.x - p1.x;\n  float yDiff = p2.y - p1.y;\n  if(abs(xDiff) < LINE_THRESHOLD){\n    //x = c\n    return vec3(1, 0, p1.x);\n  }else if(abs(yDiff) < LINE_THRESHOLD){\n    //y = c\n    return vec3(0, 1, p1.y);\n  }else{\n    //y = ax + b\n    return vec3(yDiff / xDiff, p1.y - p1.x * (yDiff / xDiff), 0);\n  }\n}\n\nfloat calcX(vec3 line, float y){\n  if(line.z == 0.){\n    return (y - line.y) / line.x;\n  }else{\n    return line.z;\n  }\n}\n\nfloat calcY(vec3 line, float x){\n  if(line.z == 0.){\n    return line.x * x + line.y;\n  }else{\n    return line.z;\n  }\n}\n\nvec2 calcIntersection(vec3 line1, vec3 line2){\n  if(line1.z == 0. && line2.z == 0.){\n    float x1 = 1.;\n    float x2 = 5.;\n    float y1 = calcY(line1, x1);\n    float y2 = calcY(line1, x2);\n\n    float x3 = 4.;\n    float x4 = 8.;\n    float y3 = calcY(line2, x3);\n    float y4 = calcY(line2, x4);\n\n    float ksi   = ( y4-y3 )*( x4-x1 ) - ( x4-x3 )*( y4-y1 );\n    float eta   = ( x2-x1 )*( y4-y1 ) - ( y2-y1 )*( x4-x1 );\n    float delta = ( x2-x1 )*( y4-y3 ) - ( y2-y1 )*( x4-x3 );\n\n    float lambda = ksi / delta;\n    float mu    = eta / delta;\n    return vec2(x1 + lambda*( x2-x1 ), y1 + lambda*( y2-y1 ));\n  }else{\n    if(line1.x == 1.){\n      return vec2(line1.z, calcY(line2, line1.z));\n    }else if(line1.y == 1.){\n      return vec2(calcX(line2, line1.z), line1.z);\n    }else if(line2.x == 1.){\n      return vec2(line2.z, calcY(line1, line2.z));\n    }\n    return vec2(calcX(line1, line2.z), line2.z);\n  }\n}\n\nconst vec2 commonCirclePos = vec2(0, 0);\nconst float commonCircleR = 10.;\nconst vec2 p = commonCirclePos + vec2(0, commonCircleR);\nconst vec2 q = commonCirclePos + vec2(-commonCircleR, 0);\nconst vec2 r = commonCirclePos + vec2(0, -commonCircleR);\nconst vec2 s = commonCirclePos + vec2(commonCircleR, 0);\n\nvec2 c1Pos, c2Pos, c3Pos, c4Pos;\nfloat c1R, c2R, c3R, c4R;\n\nvoid calcContactCircles(vec2 commonCirclePos, float commonCircleR){\n  vec2 pqMid = (p + q)/2.;\n  vec2 u = (pqMid - commonCirclePos)/distance(commonCirclePos, pqMid);\n  vec2 a = u * commonCircleR * (sin(iTime) * 6. + 6.72) + commonCirclePos;\n  c1Pos = a;\n  c1R = distance(a, p);\n\n  vec3 aq = getLine(a, q);\n  vec3 qrMidPer = getLine(commonCirclePos, (q + r) / 2.);\n  vec2 b = calcIntersection(aq, qrMidPer);\n  c2Pos = b;\n  c2R = distance(b, q);\n\n  vec3 br = getLine(b, r);\n  vec3 rsMidPer = getLine(commonCirclePos, (r + s) / 2.);\n  vec2 c = calcIntersection(br, rsMidPer);\n  c3Pos = c;\n  c3R = distance(c, r);\n\n  vec3 cs = getLine(c, s);\n  vec3 spMidPer = getLine(commonCirclePos, (s + p) / 2.);\n  vec2 d = calcIntersection(cs, spMidPer);\n  c4Pos = d;\n  c4R = distance(d, s);\n}\n\nfloat loopNum = 0.;\nconst int ITERATIONS = 6;\nfloat IIS(vec2 pos){\n    loopNum = 0.;\n\tbool cont = false;\n\tfor(int i = 0 ; i < ITERATIONS ; i++){\n\t\tcont = false;\n\t\tif(distance(pos, c1Pos) < c1R){\n\t\t\tpos = circleInverse(pos, c1Pos, c1R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c2Pos) < c2R){\n\t\t\tpos = circleInverse(pos, c2Pos, c2R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c3Pos) < c3R){\n\t\t\tpos = circleInverse(pos, c3Pos, c3R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}else if(distance(pos, c4Pos) < c4R){\n\t\t\tpos = circleInverse(pos, c4Pos, c4R);\n\t\t\tcont = true;\n            loopNum++;\n\t\t}\n\t\tif(cont == false) break;\n\t}\n\tif(length(pos) < commonCircleR)\n        return float(ITERATIONS) + abs(loopNum - float(ITERATIONS));\n\treturn loopNum;\n}\n\nfloat calcHeight(vec2 p){\n    return IIS(p) * 1.3;\n}\n\nconst vec3 BLACK = vec3(0);\nfloat march(vec3 rayOrigin, vec3 rayDir){\n    const float delt = 0.04;\n    const float mint = 3.;\n    const float maxt = 100.;\n    for( float t = mint; t < maxt; t += delt ) {\n        vec3 p = rayOrigin + rayDir * t;\n        if( p.y < calcHeight(p.xz)) {\n            return t - 0.5 * delt;\n        }\n    }\n    return maxt;\n}\n\nconst vec2 d = vec2(0.1, 0.);\nvec3 calcNormal(const vec3 p){\n  return normalize(vec3(calcHeight(p.xz - d.xy) - calcHeight(p.xz + d.xy),\n                     \t2. * d.x,\n                     \tcalcHeight(p.xz - d.yx) - calcHeight(p.xz + d.yx)));\n}\n\nconst float PI_4 = 12.566368;\nvec3 diffuseLighting(const vec3 p, const vec3 n, const vec3 diffuseColor,\n                     const vec3 lightPos, const vec3 lightPower){\n  \tvec3 v = lightPos - p;\n  \tfloat d = dot(n, normalize(v));\n  \tfloat r = length(v);\n  \treturn (d > 0. ) ?\n    \t(lightPower * (d / (PI_4 * r * r))) * diffuseColor\n    \t: vec3(0.);\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst vec3 lightPos = vec3(0, 100, 0);\nconst vec3 lightPower = vec3(50000.);\nvec3 calcColor(vec3 eye, vec3 ray){\n  \tvec3 l = BLACK;\n  \tfloat coeff = 1.;\n    float t = march(eye, ray);\n  \t\n    //if(t > 0.){\n        vec3 intersection = eye + ray * t;\n        vec3 normal = calcNormal(intersection);\n        vec3 matColor = vec3(hsv2rgb(vec3(loopNum / 10. ,1., 1.)));\n   \t\tl += diffuseLighting(intersection, normal, matColor, lightPos, lightPower);\n    //}\n  \treturn l;\n}\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const float width, const float height, const vec2 coord){\n\tfloat imagePlane = (height * .5) / tan(fov * .5);\n  \tvec3 v = normalize(target - eye);\n \tvec3 xaxis = normalize(cross(v, up));\n  \tvec3 yaxis =  normalize(cross(v, xaxis));\n  \tvec3 center = v * imagePlane;\n  \tvec3 origin = center - (xaxis * (width  *.5)) - (yaxis * (height * .5));\n  \treturn normalize(origin + (xaxis * coord.x) + (yaxis * (height - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec3 gammaCorrect(vec3 rgb) {\n\treturn vec3((min(pow(rgb.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgb.b, DISPLAY_GAMMA_COEFF), 1.)));\n}\n\nconst vec3 target = vec3(0., 0, 0);\nconst vec3 up = vec3(0, 1, 0);\nfloat fov = radians(60.);\n\nconst float sampleNum = 50.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    calcContactCircles(commonCirclePos, commonCircleR);\n    vec3 eye = vec3(15. * cos(iTime/2.) , 25. + 15. * (sin(iTime)), 15. *sin(iTime/2.));\n    const vec2 coordOffset = vec2(0.5);\n  \tvec3 ray = calcRay(eye, target, up, fov,\n    \t               iResolution.x, iResolution.y,\n        \t           gl_FragCoord.xy + coordOffset);\n\n  \tfragColor = vec4(gammaCorrect(calcColor(eye, ray)), 1.);\n\n}","name":"Image","description":"","type":"image"}]}