{"ver":"0.1","info":{"id":"4l2SRz","date":"1441082005","viewed":351,"name":"Scale2x - Branchless ","username":"gtoknu","description":"A branchless version of the scale2x algorithm. Inspired by  the implementation found at http://www.scale2x.it/algorithm.html .\nBranchless bc: The challenge of working with values instead of boolean is quite cool, also, some mobile devices don't like ifs.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["branchless","algorithm","pixelart"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rn","filepath":"/media/a/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","previewfilepath":"/media/ap/cbcbb5a6cfb55c36f8f021fbb0e3f69ac96339a39fa85cd96f2017a2192821b5.png","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"float vec4Equal(vec4 a, vec4 b)\n{\n    const vec4 epsilon = vec4(1.0/255.0); //should be considered other values\n    vec4 deltaAB = step(abs(a-b), epsilon);\n    return deltaAB.x * deltaAB.y * deltaAB.z * deltaAB.w;\n}\n// This is a branchless (no ifs) version of Scale2x algorithm to scale up pixel art.\n// I make shaders branchless because some unreliant mobile devices (Galaxy tab 2, I'm looking at you!) simply crash with ifs.\n// Made by Gustavo (Gtoknu) Maciel\n// based on http://www.scale2x.it/algorithm.html\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float t = iDate.w;\n    float frame = floor(fract(t * 9.423456 / 6.0) * 6.0);\n    //float frame = 1.0;\n    vec2 xCoordinate = vec2(frame/6.4, (frame+1.0)/6.4);\n    vec2 yCoordinate = vec2(1.0, 0.0);\n    uv.x = xCoordinate.s + (xCoordinate.t - xCoordinate.s) * uv.x * 1.1;\n    uv.y = yCoordinate.s + (yCoordinate.t - yCoordinate.s) * uv.y;\n    //boxing to first frame only\n    \n    vec2 o = (1.0/1.0) / iChannelResolution[0].xy;\n    \n\t// A B C\n\t// D E F\n\t// G H I\n\tvec4 B = texture(iChannel0, uv + vec2(  0.0,  o.y));\n\tvec4 D = texture(iChannel0, uv + vec2( -o.x,  0.0));\n\tvec4 E = texture(iChannel0, uv + vec2(  0.0,  0.0));\n\tvec4 F = texture(iChannel0, uv + vec2(  o.x,  0.0));\n\tvec4 H = texture(iChannel0, uv + vec2(  0.0, -o.y));\n\tvec2 p = uv * iChannelResolution[0].xy;\n    \n    //0 1\n    //2 3\n    vec4 E0, E1, E2, E3;\n    float BdfH = 1.0-vec4Equal(B, H);\n    float DdfF = 1.0-vec4Equal(D, F);\n    float master = BdfH * DdfF;\n    E0 = mix(E, D, vec4Equal(D, B) * master);\n    E1 = mix(E, F, vec4Equal(B, F) * master);\n    E2 = mix(E, D, vec4Equal(D, H) * master);\n    E3 = mix(E, F, vec4Equal(H, F) * master);\n    /*\n    E0 = D == B && B != H && D != F ? D : E;\n\tE1 = B == F && B != H && D != F ? F : E;\n\tE2 = D == H && B != H && D != F ? D : E;\n\tE3 = H == F && B != H && D != F ? F : E;\n    */\n\t// p = the position within a pixel [0...1]\n\tp = p - floor(p);\n    fragColor =\n    mix(\n        mix(\n            E2,\n            E0,\n        step(0.5, p.y)),\n        mix(\n            E3,\n            E1,\n        step(0.5, p.y)),\n    step(0.5, p.x));\n\t/*if (p.x > .5) {\n\t\tif (p.y > .5) {\n\t\t\t// Top Right\n\t\t\tfragColor = B == F && B != D && F != H ? F : E;\n\t\t} else {\n\t\t\t// Bottom Right\n\t\t\tfragColor = H == F && D != H && B != F ? F : E;\n\t\t}\n\t} else {\n\t\tif (p.y > .5) {\n\t\t\t// Top Left\n\t\t\tfragColor = D == B && B != F && D != H ? D : E;\n\t\t} else {\n\t\t\t// Bottom Left\n\t\t\tfragColor = D == H && D != B && H != F ? D : E;\n\t\t}\n\t}*/    \n    if(fract(floor(iDate.w) / 2.0) == 0.0)\n    \tfragColor = E;\n}","name":"","description":"","type":"image"}]}