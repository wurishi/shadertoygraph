{"ver":"0.1","info":{"id":"slB3zz","date":"1623256528","viewed":182,"name":"signed vector field marching","username":"hpx","description":"While writing my first ray marcher, I wondered why we don't use vector field instead of signed distance field.\n\nI think their best use is alongside SDF: march with SDF and compute the surface normal with SVF, but the benefit is still too small to bother.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","svf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Just like with distance fields, we need a sign to define whether we're inside or outside of the volume.\n// Unlike a float, vec3 doesn't have any free bit, so we are going to use vec4 with 'xyz' for position and 'w' for the sign\n// Having a whole float for just one bit is quite wasteful and because we often use the distance to the surface,\n// we can store the distance along with the sign, which comes in cheap as we usually already computed it anyway.\n// This means we have a full SDF with a vec3 on top.\n// The main reason why this isn't much more useful than SDF alone is because we're marching along a line and cannot\n// really do much with the directional information. \n// I think the main benefit of SVF is surface normal computation, but the added complexity doesn't really seem to pay off.\n\n// The field should always satisfy constraint length(SVF(x).xyz) = abs(SVF(x).w) = abs(SDF(x)).\n// Current implementation allows one exception to this rule:\n// We allow a point in the field that has the same magnitude in every direction to be encoded as\n// length(SVF(x).xyz) = 0 and SVF(x).w != 0\n// This case happens in the middle of a sphere, but maybe picking one direction would be just as good?\n\n// You can rotate around the scene with the mouse.  Color is encoded surface normal.\n\n#define M_PI 3.14159265359\n\nfloat vmax(vec2 v) { return max(v.x, v.y); }\nfloat vmax(vec3 v) { return max(v.x, vmax(v.yz)); }\n\nvec4 svSphere(float radius, vec3 point)\n{\n    float len = length(point);\n    \n    // The vector is 0 when point = vec3(0.).\n    // 0 means that we can pick the vector direction at our convenience, because all of them are valid\n    // and having a length in .w is suddenly mandatory to handle this situation later.\n    return vec4(-point + radius * point/len, len - radius);\n}\n\n// the svf construction is very similar to sdf\nvec4 svBox(vec3 bounds, vec3 point)\n{\n    vec3 q = abs(point) - bounds;\n    \n    if (vmax(q) >= 0.) { // we're outside of the box\n        vec3 outside = max(q, 0.0);\n        return vec4(-outside * sign(point), length(outside));\n    }\n    \n    return vec4(0.); // the interior of the box should be derived as well, but I don't care enough to do it\n    \n    // interior is going to be slightly problematic, because it has points where the vector field should have\n    // multiple values (e.g. diagonals from edges are the same distance to multiple surfaces)\n    // and there isn't a simple enconding like the one we used for the sphere.\n    // Picking just one of them is the simplest resolution and the only one feasible one for generic shapes.\n    // If we stuck with a small amount of primitives, a structure could be added to handle all the possible\n    // directional constraints.\n    // Or we could pass the ray direction and decide which one to pick from that. (Move the logic from march())\n    // I think that the simple handling of this case should not make a noticeable difference.\n}\n\nvec4 svUnion(vec4 a, vec4 b)\n{\n    return a.w > b.w ? b : a;\n    // can this be written branchlessly in a way that would also execute faster? No.\n    // ollj pointed out that the compiler almost always produces better better code when the source\n    // uses branches instead of binary mix().  The difference estimate is a few cycles.\n}\n\nvec4 svSubtraction(vec4 a, vec4 b)\n{\n    return a.w > -b.w ? a : vec4(b.xyz, -b.w);\n}\n\nvec4 svScene(vec3 point)\n{\n    return svUnion(svSphere(1., point + vec3(1.5,.0,.0)),\n                   svSubtraction(svBox(vec3(1.), point),\n                                 svSphere(1.3, point)));\n}\n\nvec3 march(vec3 canvas_point, vec3 ray_origin)\n{\n    float dist = 0.;\n    const float eps = .00001; // 1e-5 gives two orders of magnitude leeway for float rounding errors\n                              // and is also two magnitudes below the value where I can't perceive the difference anymore\n    \n    vec3 ray_direction = normalize(canvas_point - ray_origin);\n\n    for (;;) {\n        float closest = abs(svScene(canvas_point + ray_direction * dist).w); // take the length of the vector field\n        if (closest <= eps * max(1., dist)) // sphere marching\n            break;\n        \n        dist = dist + closest;\n        if (isinf(dist)) // waiting for inf will take 145 steps in the worst case (with 1e-5 eps): ceil(log_2((2 - 2^-23) * 2^127 / eps))\n            return vec3(.8);\n    }\n    \n    // sample the field a bit above surface, because the vector field has 0 length on the surface itself\n    vec4 normal = svScene(canvas_point + ray_direction * (dist - eps));\n    \n    // when the vector is zero, but is supposed to have a nonzero magnitude, it means that it can point anywhere,\n    // we conveniently pick it to point towards us.\n    // Ignoring it and doing nothing shouldn't really make a difference either.\n    if (normal.xyz == vec3(0.) && normal.w != 0.)\n        normal.xyz = ray_direction * normal.w;\n    \n    return (normalize(-normal.xyz) + 1.) * 0.5; // debug display of the hit surface\n}\n\n// compute a rotator plane from bit-coded excluded axes (1 = x, 2 = y, 4 = z, 8 = w, ...)\n// dropping the branchless version from previous shader made it much more readable\nmat3 rotator(float angle, int axes)\n{\n    mat3 rot;\n\n    for (int row = 0; row < 3; row++)\n        for (int column = 0; column < 3; column++) {\n            if ((axes & (1 << row | 1 << column)) == 0)\n                rot[row][column] = row == column ? cos(angle) : sin(angle) * float(sign(column - row));\n            else\n                rot[row][column] = float(row == column);\n        }\n    \n    return rot;\n}\n\n// rotate with xz and yz planes\nvec3 mouse_rotator(vec3 vector)\n{\n    vec2 angle = 2. * M_PI * iMouse.xy / iResolution.xy;\n    \n    return rotator(angle.x + iTime * 0.2, 1 << 1) *\n           rotator(angle.y + .3, 1 << 0) *\n           vector;\n}\n\nvec3 canvas_projection(vec2 point)\n{\n    vec2 unit = point / iResolution.xy;\n                        \n    return mouse_rotator(vec3(unit.x - 0.5, unit.y - 0.5, -8.2) * vec3(iResolution.x / iResolution. y, 1., 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // the point from which rays originate (eye/camera)\n    vec3 ray_origin = mouse_rotator(vec3(0., .0, -12.));\n    \n    // canvas is a rectangle that the rays pass through and can be freely trasnformed in 4d\n    vec3 canvas_pass_through_point = canvas_projection(fragCoord);\n\n    vec3 hit = march(canvas_pass_through_point, ray_origin);\n    \n    // Output to screen\n    fragColor = vec4(hit, 1.);\n}","name":"Image","description":"","type":"image"}]}