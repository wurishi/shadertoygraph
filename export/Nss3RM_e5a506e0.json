{"ver":"0.1","info":{"id":"Nss3RM","date":"1615707234","viewed":96,"name":"Note: polar coordinates","username":"I_am_6r1d","description":"A little note on polar coordinate function use.\nI was looking around, saw a rotating circle by guowei and decided to both record the function and play with it.\n(Pardon for the messy UV init, I left it stored locally for more than a year.)","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["normals","polarcoordinates","coloring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// guowei's calPolar function from\n// https://www.shadertoy.com/view/XsGfWw\nvec2 cal_polar(vec2 uv){\n  float TWO_PI = 3.1415926 * 2.0;\n  float angleUv = atan(uv.x, uv.y) / TWO_PI;\n  float lengthUv = length(uv);\n  return vec2(angleUv, lengthUv);\n}\n\n// A function to display normal map colors\n// I have used here just for fun\nvec3 normal_color(float nx, float ny, float nz) {\n    return vec3(\n        nx * 0.5 + 0.5,\n        ny * 0.5 + 0.5,\n        nz * 0.5 + 0.5\n    );\n}\n\nvec3 trans_color(float x) {\n    float third_in_radians = 2.0944;\n    return normal_color(\n        cos(x),\n        cos(x + third_in_radians),\n        cos(x - third_in_radians)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // UV init\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = 2.0 * uv - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    // Time shift for animation\n    float shift = sin(iTime * 0.5) + 1.0;\n    // Calculating polar coordinates\n    vec2 polars = cal_polar(uv);\n    // Shifting X polar for animation\n    polars.x += 1.5 * shift;\n    float polar_intensity = polars.x + polars.y;\n    // Generating output color\n    fragColor.rgb = \n        vec3(polar_intensity) *\n        trans_color(\n            // Shifting the color further\n            polar_intensity*(3.0 * shift)\n        );\n}\n","name":"Image","description":"","type":"image"}]}