{"ver":"0.1","info":{"id":"3syGzW","date":"1569772296","viewed":273,"name":"test #123141213121","username":"dtoadq","description":"i'm finished with this i suppose...","likes":0,"published":3,"flags":32,"usePreview":0,"tags":["1231"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 tex = texture(iChannel0, uv).rgb;\n\t\n\n    // vignette\n    tex *= 0.25f+0.75f*pow(8.0f*uv.x*uv.y*(1.0f-uv.x)*(1.0f-uv.y), 1.0f/2.2f);\n    \n    \n    tex *= 1.0/16000.0f;\n    vec3 x = max(vec3(0.0f), tex - 0.004f);\n    tex = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    \n    fragColor = vec4(tex, 1.0f);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nstruct Ray { vec3 ori, dir; };\n\n#define TIME (iTime * 25.0f)\n#define Slider (iMouse.w/288.0f)\n#define SliderHi (iMouse.z/512.0f)\n#define SunDir vec3(0.7f, 1.0f, 0.3f)\n#define SunColor vec3(0.88f, 0.68f, 0.68f) * 1550.0f\n#define AtmosphereColor vec3(0.8f, 0.6f, 0.65f) * 500.0f\n\nfloat saturate(float x) { return clamp(x, 0.0f,       1.0f);       }\nvec2 saturate(vec2  x) { return clamp(x, vec2(0.0f), vec2(1.0f)); }\nvec3 saturate(vec3  x) { return clamp(x, vec3(0.0f), vec3(1.0f)); }\n\nvec2 Map(vec3 o);\n\n// inigo quilez\nfloat planeIntersect(vec3 ro, vec3 rd, vec4 p) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec2 March (in Ray ray) {\n  vec2 res = vec2(0.0f);\n  const float MaxDistance = 312.0f;\n  const int MaxIter = 512;\n  int i = 0;\n  for (i = 0; i != MaxIter; ++ i) {\n    vec2 cur = Map(ray.ori + ray.dir*res.x);\n    if (cur.x <= 0.005f || res.x > MaxDistance) break;\n    res.x += cur.x;\n    res.y = cur.y;\n  }\n  if (res.x > MaxDistance || res.x < 0.0) return vec2(-1.0);\n  return res;\n}\n\nvec3 Normal ( vec3 p ) {\n  vec2 e = vec2(1.0, -1.0)*0.001;\n  return\n    normalize(\n      e.xyy*Map(p + e.xyy).x +\n      e.yyx*Map(p + e.yyx).x +\n      e.yxy*Map(p + e.yxy).x +\n      e.xxx*Map(p + e.xxx).x\n    );\n}\n\n// -----------------------------------------------------------------------------\n// ------- SAMPLERS ------------------------------------------------------------\n// -----------------------------------------------------------------------------\n\n// -- camera --\nRay LookAt ( vec2 uv ) {\n  vec2 M = vec2((iMouse.x/iResolution.x), (iMouse.y/iResolution.y))*2.0-1.0;\n  //M.x = -0.3f;\n  //M.y = 0.2f;\n  M.x = clamp(M.x, -0.3f, 0.3f);\n  vec3 ori = vec3(cos(M.x - 0.3f)*1.0f, 0.2f+M.y*0.51f, sin(M.x)*1.0f);\n  //----etc\n\n  vec3 ww = normalize(-ori),\n       uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0))),\n       vv = normalize(cross(uu, ww));\n  mat3 LA = mat3(uu, vv, ww);\n  return Ray(vec3(38.0f, 0.0f, 38.0f), normalize((LA)*vec3(uv.x, uv.y, 1.0f)));\n}\n\nvoid Union(inout vec2 t, float d, in float ID) {\n  if (t.x > d) t = vec2(d, ID);\n}\n\nfloat fbmWorleyWorld (in vec3 ori) {\n  const int Octaves = 8;\n  float value = 0.0f;\n  float\n  , amplitude = 0.5f\n  , frequency = 0.0f;\n\n  for (int i = 0; i < Octaves; ++ i) {\n      value += amplitude * (worley(ori, 1.0f, false).r);\n      ori *= 2.0f;\n      amplitude *= 0.5f;\n  }\n  return value;\n}\n\nfloat fbmWorley (in vec3 ori) {\n  const int Octaves = 6;\n  float value = 0.0f;\n  float\n  , amplitude = 0.5f\n  , frequency = 0.0f;\n\n  for (int i = 0; i < Octaves; ++ i) {\n      value += amplitude * (worley(ori, 1.0f, false).r);\n      ori *= 2.0f;\n      amplitude *= 0.5f;\n  }\n  return value;\n}\n\nfloat fbmWorleyInverse (in vec3 ori) {\n  const int Octaves = 6;\n  float value = 0.0f;\n  float\n  , amplitude = 0.5f\n  , frequency = 0.0f;\n\n  for (int i = 0; i < Octaves; ++ i) {\n      value += amplitude * (1.0f-worley(ori, 1.0f, false).r);\n      ori *= 2.0f;\n      amplitude *= 0.5f;\n  }\n  return value;\n}\n\nfloat sdWorld(vec3 ori) {\n  float t = dot(ori, vec3(0.0f, 1.0f, 0.0f));\n  t += 10.0f;\n  t += mix(-15.0f, 5.0f, fbmWorleyWorld(ori*0.01f));\n  t += mix(-10.0f, 10.0f, fbmWorleyInverse(ori*0.05f));\n  return t*0.5f;\n}\n// iquilez\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n// iquilez\nvec2 opRepLim( in vec2 p, in float c, in vec2 l )\n{\n    vec2 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\n// iquilez\nvec3 opRep( in vec3 p, in vec3 c )\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return q;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nvoid pR(inout vec2 p, float a) { // hg sdf\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlanet(vec3 ori) {\n  float t = 99999.0f;\n  float W = 0.0f;\n  pR(ori.xz, TIME*0.0015f);\n  ori -= vec3(-10.0f, 50.0f, 40.0f);\n  pR(ori.zy, TIME*0.015f);\n  pR(ori.xy, TIME*0.015f);\n  W += fbmWorleyWorld(ori*0.005f) * 0.75f;\n  W += fbmWorleyWorld(ori*0.02f) * 0.25f;\n  t = length(ori) - (20.0f);\n  t += mix(-20.0f, 15.0f, (W));\n  return t*0.15f;\n}\n\nvec2 Map (vec3 ori) {\n  vec2 l = vec2(9999.0f);\n\n  Union(l, sdWorld(ori), 2.0f);\n  Union(l, sdPlanet(ori), 3.0f);\n\n  return l;\n}\n\nvoid CloudIntegrate(\n  inout vec4 sum\n, float density\n, float lightDensityRough\n, float lightDensityPrecise\n, float upDensity\n, float dist\n) {\n  vec4 color =\n    vec4(\n      mix(\n        vec3(1.0f)\n      , vec3(0.5f)\n      , density\n      )\n    , density\n    );\n\n  float sunContribution =\n    clamp(\n      2.0f*density - lightDensityRough*1.5f - lightDensityPrecise*1.5f\n    , 0.0f\n    , 1.0f\n    );\n\n  color.rgb *=\n    AtmosphereColor*5.0f\n  + SunColor * 15.0f\n  * sunContribution\n  ;\n\n  color.rgb *=\n    vec3(1.0f)\n  + clamp(pow(density - lightDensityPrecise, 3.5f), 0.0f, 1.0f)*205050.0f\n  ;\n\n  color.rgb *=\n    vec3(1.0f)\n  + clamp(pow(density - lightDensityPrecise, 1.5f), 0.0f, 1.0f)*150.0f * vec3(1.0f, 0.5f, 1.0f)\n  ;\n\n  color.rgb *=\n    vec3(1.0f)\n  + clamp(density - lightDensityPrecise, 0.0f, 1.0f)*25.0f * vec3(1.0f, 0.2f, 0.8f)\n  ;\n\n    color.rgb *=\n    vec3(1.0f)\n  + clamp(density - lightDensityRough, 0.0f, 1.0f)*5.0f * vec3(1.0f, 0.8f, 0.9f)\n  ;\n\n color.rgb *=\n    vec3(1.0f)\n  + clamp(upDensity, 0.0f, 1.0f) * AtmosphereColor * 0.01f\n  ;\n\n  color.rgb *= clamp(AtmosphereColor*exp(-0.05f*dist*dist), 0.5f, 1.0f);\n\n  color.a *= 0.4f;\n  color.rgb *= color.a;\n  sum += color*(1.0f - sum.a);\n}\n\n\nfloat CloudDensity(vec3 ori) {\n  float worleyI = fbmWorleyInverse(ori*0.1f);\n  float worley = fbmWorley(ori*0.5f + vec3(TIME*0.2f));\n  float worleyI3 =\n    fbmWorleyInverse(\n      (ori+vec3(4934.0f, -843.0f, 493.0f))*2.5f\n    + vec3(TIME, 0.0f, TIME*2.0f)*0.25f\n    );\n  float layer = 1.0f - smoothstep(-0.25f, 25.0f, ori.y);\n  return -0.65f + layer*0.2f + worleyI + worleyI3*0.05f - worley*0.086f;\n}\n\nvec4 CloudMarch(in Ray ray, float primitiveDistance, out float pdist) {\n  pdist = 999999.0f;\n  float t = planeIntersect(ray.ori, ray.dir, vec4(0.0f, -1.0f, 0.0f, 1.0f));\n  if (t <= 0.0f || t >= 74.0f) return vec4(0.0f);\n  vec4 sum = vec4(0.0f);\n  ray.ori.xz += vec2(TIME*0.2f);\n  for (int i = 0; i < 128; ++ i) {\n    if (t >= primitiveDistance) break;\n    vec3 ori = ray.ori + t*ray.dir;\n    float density = CloudDensity(ori);\n    if (density > 0.1f) {\n      pdist = min(t, pdist);\n      vec3 sunDir = SunDir;\n      float lightDensityRough   = CloudDensity(ori + sunDir*0.8f);\n      float lightDensityPrecise = CloudDensity(ori + sunDir*0.2f);\n      float upDensity = CloudDensity(ori + vec3(0.0f, 1.0f, 0.0f)*0.5f);\n      CloudIntegrate(\n        sum\n      , density\n      , lightDensityRough\n      , lightDensityPrecise\n      , upDensity\n      , t\n      );\n       t += clamp(density, 0.5f, 1.0f)*0.01f;\n      t += 0.01f;\n    } else\n    {\n      t += 0.15f;\n    }\n    if (sum.a > 0.99f) break;\n  }\n  return sum;\n}\n\nfloat FogDensity(vec3 ori) {\n  float layer = smoothstep(-1.0f, 0.5f, ori.y);\n  ori += vec3(934.03483f, 243.4f, 392.0439f);\n  ori.xz += vec2(TIME*0.1f) * 1.5f;\n  ori *= 0.5f;\n  float worleyI = fbmWorleyInverse(ori*0.2f);\n  return -0.3f + worleyI - layer*0.5f;\n}\n\nvoid FogIntegrate(\n  inout vec4 sum\n, float density\n, float dist\n) {\n  vec4 color =\n    vec4(\n      mix(\n        vec3(0.5f, 0.55f, 0.55f)\n      , vec3(0.25f, 0.2f, 0.2f)\n      , density\n      )\n    , density * 0.33f\n    );\n\n  color.a *= 0.4f;\n  color.rgb *= color.a;\n  sum += color*(1.0f - sum.a);\n}\n\nvec4 FogMarch(in Ray ray, float primitiveDistance) {\n  float t = 0.0f;\n  vec4 sum = vec4(0.0f);\n  for (int i = 0; i < 64; ++ i) {\n    if (t >= primitiveDistance) break;\n    vec3 ori = ray.ori + t*ray.dir;\n    float density = FogDensity(ori);\n    if (density > 0.1f) {\n      FogIntegrate(\n        sum\n      , density\n      , t\n      );\n    }\n\n    t += 0.25f;\n\n    if (sum.a > 0.99f) break;\n  }\n  return sum;\n}\n\nfloat AmbientOcclusion(vec3 ori, vec3 normal) {\n  float occ = 0.0f;\n  float sca = 1.0f;\n  for (int i = 0; i < 5; ++ i) {\n    float h = 0.001f + 0.15f*float(i)/4.0f;\n    float d = Map(ori + h*normal).x;\n    occ += (h-d)*sca;\n    sca *= 0.95f;\n  }\n  return clamp(1.0f - 1.5f*occ, 0.0f, 1.0f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec3 ocol = vec3(0.0);\n  float primitiveDistance = 5000.f;\n  vec2 uv = 2.0*fragCoord.xy;\n  uv.x += -0.5f*2.0;\n  uv.y += -0.5f*2.0;\n  uv = -1.0+ uv/iResolution.xy;\n  uv.x *= iResolution.x/iResolution.y;\n  Ray eye = LookAt(uv);\n  fragColor = vec4(0.0);\n    \n      vec3 atmoColor =\n    mix(\n      vec3(0.9f, 0.6f, 0.8f)*2000.0f,\n      vec3(1.7f, 0.6f, 1.3f)*10200.0f,\n      saturate(eye.dir.y*1.5f)\n    );\n    \n  atmoColor += smoothstep(0.0f, 0.1f, eye.dir.y) * vec3(0.9f, 0.2f, 0.2f) * 5000.0f;\n  atmoColor += smoothstep(0.4f, 0.7f, eye.dir.y) * vec3(0.6f, 0.5f, 1.2f) * 5000.0f;\n\n /* { // -- scene\n    vec2 res = March(eye);\n    primitiveDistance = res.x >= 0.0f ? res.x : 99999.0f;\n    if (res.x >= 0.0f) { // -- primitive march\n      vec3\n        O  = eye.ori + eye.dir*res.x\n      , N  = Normal(O)\n      , wi = eye.dir;\n\n      float ambientOcclusion = AmbientOcclusion(O, N);\n\n      float brdf = clamp(dot(N, SunDir), 0.0f, 1.0f);\n\n       if (res.y == 2.0f) {\n         vec3 col =\n           saturate(smoothstep(-5.0f, 10.0f, O.y)) * vec3(0.88f, 0.58f, 0.58f)\n         * vec3(0.6f, 0.6f, 0.9f)\n         // + vec3(0.01f, 0.01f, 0.05f)\n         // + saturate(smoothstep(-15.0f, 5.0f, O.y)) * vec3(8.2f, 0.6f, 0.2f)\n         ;\n         brdf +=\n           saturate(smoothstep(-5.0f, 0.0f, O.y)) * 2.0f\n         * pow(clamp(dot(N, SunDir), 0.0f, 1.0f), 50.0f)\n         + saturate(smoothstep(-1.0f, 0.0f, O.y)) * 2.0f\n         * pow(clamp(dot(N, normalize(wi+SunDir)), 0.0f, 1.0f), 500.0f)\n         + 0.05f;\n         ocol += col * SunColor * 100.0f * brdf + col * ambientOcclusion * 0.2f;\n         float y = (O.y + 50.0f)*(O.y + 50.0f);\n         ocol += 0.5f * exp(-0.0005f*y) * vec3(0.3f, 0.3f, 0.5f);\n       }\n\n      if (res.y == 3.0f) {\n        float dotNFloor = saturate(dot(N, vec3(0.0f, -1.0f, 0.0f)));\n        float dotNSun = saturate(dot(N, SunDir));\n         ;\n        float dotNWi = saturate(dot(N, -wi));\n            \n        vec3 col = vec3(0.0f);\n        col += vec3(pow(dotNWi, 5.0f)) * 3000.0f * vec3(1.0f, 0.9f, 0.95f);\n        col += vec3(pow(dotNWi, 55.0f)) * 5000.0f * vec3(1.0f, 0.9f, 0.95f);\n        col += vec3(pow(dotNFloor, 2.0f)) * vec3(1000.0f);\n        col += vec3(pow(dotNSun, 2.0f)) * vec3(0.8f, 0.7f, 0.75f) * 10000.0f;\n        col += vec3(pow(dotNSun, 25.0f)) * vec3(0.8f, 0.7f, 0.75f) * 250000.0f;\n        col *= ambientOcclusion;\n        col = mix(atmoColor, col, 0.55f);\n        ocol += col;\n      }\n    }\n  }*/\n\n  // atmosphere\n    \n  if (primitiveDistance >= 1000.0f) {\n    ocol = atmoColor;\n  }\n\n//  { // -- fog / clohttps://www.shadertoy.com/img/themes/dark/play.pngud march\n//    float pdist;\n//    vec4 cloud = CloudMarch(eye, primitiveDistance, pdist);\n//    ocol = mix(ocol, cloud.rgb, cloud.a);//\n\n //   vec4 fog = FogMarch(eye, primitiveDistance) * vec4(SunColor*2.0f, 1.0f) * vec4(uv+vec2(1.0f), 1.0f, 1.0f);\n //   ocol = mix(ocol, fog.rgb, fog.a);\n //     \n //   primitiveDistance = min(pdist, primitiveDistance);\n // }\n  fragColor.xyz = ocol;\n    \n // fragColor = vec4(primitiveDistance / 100.0f);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}