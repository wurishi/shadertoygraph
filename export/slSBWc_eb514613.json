{"ver":"0.1","info":{"id":"slSBWc","date":"1653070764","viewed":260,"name":"Art : Stereographic Projection","username":"Gijs","description":"toying about.","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["projection","stereographic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PHI = 1.61803398875;\nconst float IPHI = 1.0 - PHI;\nconst float PI = 3.14159265359;\n\nconst float griddensity = 3.0;\nconst float animationspeed = 0.5;\n\nconst float gridradius = 4.0;\n\nvec3 pos;\nvec3 look;\nvec3 forward;\nvec3 right;\nvec3 upward;\nfloat focus;\nfloat zoom;\n\nbool raysphere(vec3 p, vec3 d, inout float t)\n{\n    float term = dot(d, p);\n    float discriminant = term*term - dot(p,p) + 1.0;\n    t = -term - sqrt(discriminant);\n    return discriminant >= 0.0;\n}\n\n//maps the unit sphere to y=-1 stereographically\nvec2 stereographic(vec3 p)\n{\n    return 2.0 * p.xz / (1.0 - p.y);\n}\n\n//maps y=-1 to the unit sphere stereographically\nvec3 stereographicinverse(vec2 p)\n{\n    p *= 0.5;\n    float r2 = dot(p, p);\n    return vec3(2.0 * p.x, -1.0 + r2, 2.0 * p.y)/(1.0 + r2);\n}\n\n//\nvec2 closestGridPoint(vec2 p)\n{\n    return round(griddensity*p)/griddensity;\n}\n\nvoid toScreen(inout vec3 col, vec3 p, vec2 uv)\n{\n    float dist = distance(p, pos);\n    \n    //project onto camera frame\n    vec3 delta = p - pos;\n    vec3 projected = vec3(dot(delta, right), dot(delta, upward), dot(delta, forward));\n    vec2 x = vec2(projected.x, projected.y);\n\n    //zoom\n    x /= zoom;\n\n    float d = distance(x, uv);\n    float r = 0.003 * (2.0 + abs(projected.z-focus));\n    float s = smoothstep(r*2.0, r, d) / (1.0 + abs(projected.z-focus)) ;\n    \n    col = smoothstep(col, vec3(1), vec3(s));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n\n    vec2 uv = (fragCoord*2.0 - iResolution.xy)/iResolution.y;\n\n    float time = iTime * animationspeed;\n    pos = vec3(2.0 * cos(time), 1.0 + cos(time)*.5, 2.0 * sin(time));\n    look = vec3(0.0, 0.0, 0.0);\n    forward = normalize(look - pos);\n    right = normalize(cross(forward, vec3(0,1,0)));\n    upward = cross(right, forward);\n    focus = distance(pos, look)*1.0;\n    zoom = 2.0;\n\n    vec3 origin = pos + uv.x*zoom*right + uv.y*zoom*upward;\n\n    float t;\n    bool b = raysphere(origin, forward, t);\n    if(b)\n    {\n        vec3 intersect = origin + forward * t;\n        vec2 stereo = stereographic(intersect);\n        vec2 gridpoint = closestGridPoint(stereo);\n\n\n        if(length(gridpoint) < gridradius) \n        {\n            vec3 sphere = stereographicinverse(gridpoint);\n\n            toScreen(col, sphere, uv);\n        }\n    }\n    else\n    {\n        float t = (-1.0 - origin.y)/forward.y;\n        vec3 plane = origin + t * forward;\n\n        vec2 gridpoint = closestGridPoint(plane.xz);\n\n        if(length(gridpoint) < gridradius) \n        {\n            vec3 gridpoint3d = vec3(gridpoint.x, -1.0, gridpoint.y);\n            toScreen(col, gridpoint3d, uv);\n        }\n    }\n    \n    fragColor = vec4(pow(col,vec3(1.0/2.2)),1.0);\n}","name":"Image","description":"","type":"image"}]}