{"ver":"0.1","info":{"id":"3tKSWw","date":"1582843843","viewed":199,"name":"[phreax] the children","username":"phreax","description":"Attempt to animate an artwork of my friend","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Creative Commons Licence Attribution-NonCommercial-ShareAlike \n * phreax 2020\n\n * Attempt to animate an artwork of my friend Martin.\n*/\n\n#define PI 3.141592\n#define TAU PI*2.\n#define SIN(x) (sin(x)*.5+.5)\n\n#define hue(v) ( .6 + .6 * cos( 6.3*(v) + vec3(0,23,21) ) )\n\n#define BEND .8     \n#define COUNT 10.\n#define DISTORT 0.0\n\nvec3[] palette = vec3[](vec3(1.0, .2, 0), vec3(.0, .9, .4), vec3(.1, .7, .9), vec3(1, .9, 0));\nfloat tt, fid, id;\nint mat;\nvec3 inter;\n\n\nmat2 rot(float a) { return mat2(cos(a), sin(a), -sin(a), cos(a));}\n\nfloat hash11(float x) {\n\treturn fract(sin(437765.44*x)*345.63);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(2434.423,23.34)))*3228324.345);\n}\n\n\nvec2 kalei(vec2 uv) { \n\n    float n = 4.;\n    float r = TAU/n;\n    \n    for(float i=0.; i<n; i++) {     \n    \tuv = abs(uv);\n        uv.x -= .2*i+.2;\n    \tuv *= rot(r*i-.09*tt);\n    }\n    \n    uv = abs(uv) - (sin(.15*tt)+1.2);\n\n    return uv;\n}\n\n// Draw a triangle\nfloat triangle(vec2 uv) {\n    \n  int N = 3;\n  float a = atan(uv.x,uv.y)+PI;\n  float r = TAU/float(N);\n\n  float d = cos(floor(.5+a/r)*r-a)*length(uv);\n\n  return 1.0-smoothstep(.5,.6, d);\n}\n\n\n// Draw a hollow frame\nfloat triangle_frame(vec2 uv, float r) {\n    \n    float d;\n    d += triangle(uv);\n    d -= triangle(uv/(1.-r));\n    return d;\n    \n}\n\nvec3 spiral(vec2 uv, float i) {  \n    uv *= rot(i*3.14+tt);\n    uv += DISTORT*sin(vec2(5)*uv.yx);\n\treturn triangle_frame(uv, .04)*hue(i+tt*.2);\n}\n\n// From my Electric Sheep: https://www.shadertoy.com/view/wlV3zy\nvec3 dream( vec2 uv )\n{\n\n    vec3 col = vec3(0);\n    tt = iTime;\n    \n    uv *= 5.;\n    uv = kalei(uv);\n\n    float s = 1./COUNT;\n\t\n    for(float i=0.; i<1.; i+=s) {   \n        float z = fract(i-.1*tt);\n        vec2 UV = uv;\n        col += spiral(UV*z, i)*3.;\n    }\n    col +=  0.5/(abs(uv.x)+abs(uv.y))*(.8+.2*hue(.2*tt)); \n \n    return col;\n}\n\nvec2 moda(vec2 p, float repetitions, float offs, out float id) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2. +offs;\n    id = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n    if (abs(id) >= (repetitions/2.)) id = abs(id);\n\treturn vec2(cos(a), sin(a))*length(p);\n}\n\nfloat box(vec2 p, vec2 s)\n{\n  p = abs(p);\n  return max(p.x-s.x, p.y-s.y);\n}\n\nfloat bo(vec3 p, vec3 s) {\n\tvec3 q = abs(p) - s;   \n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\n// single leaf shape\nfloat leaf(vec2 uv, float r, float cp) {\n\n    float f = uv.y < 0. ? 1.2 : .7;\n    float  rp = uv.y < 0. ? 2.3 : 1.8;\n    float x = length(vec2(uv.x, pow(uv.y * f, cp)));\n    float y = r - pow(uv.y * f, rp);\n    float v = smoothstep(x, x + 16. / iResolution.y, y);\n    v *= pow(length(uv-vec2(.1, -.25))+.5,1.3); // bit of 3d look\n    return clamp(0., 1.5, v);\n}\n\nvec2 repeat(vec2 p, vec2 s, out vec2 id) {\n\tid = floor(p*s);\n    return fract(p*s)-.5;\n}\n\nfloat repeat(float p, float s, out float id) {\n\tid = floor(p*s);\n    return fract(p*s)-.5;  \n}\n\n// blinking dots\nfloat dots(vec2 uv, float r, float s) {\n    uv.x *= s;\n    \n    float did;\n\tuv.y = repeat(uv.y, s, did);\n\n    float d = length(uv) - r;\n    return smoothstep(16./iResolution.y, 0., d)*SIN(-tt*4.+did*.9);\n}\n\n// From shadertoy user curena: https://www.shadertoy.com/view/Mlj3zc\nvec2 inversion(vec2 p) {\n\n    vec2 bp = p;\n    float r    = sqrt(length( p ));\n   \n    bp.y += 0.4*(p.x*p.x)-.03;\n    return normalize(p)/(r*0.05) \n              + vec2(1.,-sign(bp.y)*4.5*tt);\n}\n\nvec3 leaf_pattern(vec2 uv, vec2 off) {\n\tvec2 id;\n    uv = repeat(uv, vec2(.14), id);\n    uv *= 1.2;\n    id += off;\n    float h = hash21(id);\n    uv *= rot(h*.4*sin(tt));\n    vec3 col = vec3(0);\n    col += leaf(uv-vec2(.3, 0), .2, 8.)*palette[int(4.*SIN(id.x*8.+mod(id.y, 4.)))];\n    // blinking leafs\n    col *= mix(1., 3., step(.6, SIN(id.x*.3+mod(id.y, 5.)+tt*.5)*h));\n    col += leaf(uv+vec2(.3, 0), .2, 8.)*palette[int(4.*SIN(id.x*8.-4.+mod(id.y, 4.)))];\n    return col;\n}\n\nvec3 overlay(vec3 c1, vec3 c2) {\n    return mix(c1, c2, (1.-step(dot(c2, vec3(1)), 0.))); \n}\n\nvec3 leaf_layers(vec2 uv) {\n    vec2 uvb = uv;\n    uv = inversion(uv);\n    uv += sin(uv.yy*vec2(0.5, 0.24))*.2;\n    \n    uv.y *= sign(uvb.y);\n\tvec3 c1 = leaf_pattern(uv, vec2(0));\n    vec3 c2 =leaf_pattern(uv+vec2(.1, 2.2), vec2(3,3)); \n    vec3 c3 =leaf_pattern(uv+vec2(2.3, 4.24), vec2(4,4));\n    vec3 c4 =leaf_pattern(uv+vec2(1.9, 1.3), vec2(6,2));\n    \n    return overlay(c1*.7, overlay(c2*.8, overlay(c3*.9, c4)))*1.-pow(length(uvb)+.4, 4.);          \n}\n\nfloat mask_texture(vec2 p) {\n    vec2 bp = p;\n    float d = box(p-vec2(0, .4), vec2(.02, .9));\n    p.x = abs(p.x);\n    d = min(d, box(p-vec2(0.3, .65), vec2(.09, .03)));\n    d = min(d, box(p-vec2(0.33, .5), vec2(.12, .03)));\n    d = min(d, box(p-vec2(0.36, .35), vec2(.14, .03)));\n    d = max(d, -box(p*rot(.3)-vec2(0.58, .4), vec2(.03, .26)));\n    d = min(d, box(p-vec2(0.25, -.05), vec2(.03, .25)));\n    d = min(d, box(p-vec2(0.36, -.33), vec2(.14, .03)));\n    d = min(d, box(p*rot(-.25)-vec2(0.35-sin((p.y-.02)*2.6)*.25, -.5), vec2(.02, .3)));\n    float c = smoothstep(0., 5./iResolution.y, d);\n\n    d = length(p-vec2(0, -.7)) -.2;\n    c *=  smoothstep(0., 5./iResolution.y, abs(d-.01)-.02);\n    return c;\n}\n\n\nfloat box(vec3 p, vec3 r) {\n\tvec3 d = abs(p) - r;\n    return length(max(d, 0.0)) + \n        min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\n\nfloat mask(vec3 p) {\n\n    vec3 bp = p;\n    \n    p.y /= 1.5;\n    p.z *= 1.5;\n\n    float d = length(p) - .8;\n\n    float b = box(abs(bp)-vec3(0.7, 0, 0), vec3(.2, .2, 1.));\n    d = max(max(d, -p.z), -b);\n    return d*.64;\n}\n\n// capped cylinder\nfloat cylc( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 transform_mask(vec3 p) {\n    p.xz = moda(p.xz,12., tt*.8, id);\n    p.y += .3*sin(tt*sin(id*14.523)*5.);\n    p.x = abs(p.x)-3.8;\n    p.xz *= rot(PI*1.5);\n    return p;\n    \n}\n\nvec3 transform_box1(vec3 p) {\n    vec3 bp = p;\n    p.x = abs(p.x) - 1.5;\n    p.x += sin(p.y*.2+PI*.5)*5.-5.;\n    p.x += sin(p.y*2.-PI/2.)*.4;\n    p.xz *= rot(bp.y*PI*.2-tt);\n    return p;\n}\n\n\nvec3 transform_box2(vec3 p) {\n    p.x = abs(p.x)-5.;\n    p.xy += .01*(p.z*p.z)-.3;\n    return p;\n}\n\n\nfloat map(vec3 p) {\n \tvec3 mp = transform_mask(p);\n    \n    vec3 pc = p;\n    vec3 pb1 = p;\n    vec3 pb2 = p;\n    float m = mask(mp);\n    \n\n    pb1 = transform_box1(pb1);\n\n\tpb2 = transform_box2(pb2);\n  \n    float b = box(pb1, vec3(.2, 9., .2))-.1;\n    float b2 = box(pb2, vec3(.1, .1, 100))-.1;\n\n\n    mat = m < b ? 0 : 1 ;\n    mat = b2 < m ? 2 : mat ;\n\n    inter = b < b2 ? pb1 : pb2;\n    \n    pc += vec3(0, -4.5, 0);\n    \n \n    pc.yz *= rot(-.5);\n    vec3 pf = pc;\n\n    pc.yz *= rot(PI*.5);\n\n    float c=  cylc(pc, 1.5, .2); \n    float ci = cylc(pc, 1.4, .3);\n    float cd = cylc(pc+vec3(0., -.3, -.1), 1.5, .1);\n    c = max(c, -ci);\n\n    pf.xy = moda(pf.xy, 7., 0., fid);\n    pf.x = abs(pf.x) - 3.4*SIN(tt*.5);\n    \n    float f = box(pf-vec3(0, 0, fid/200.), vec3(1.9,1.9, .1))*.6;\n    \n    f = min(max(c, -ci), max(f, ci));\n    if(f < b && f < m) mat = 3;\n    inter = f < b ? pc : inter;\n    float d = min(min(min(m, b), b2), f);\n    \n\tmat = cd < d ? 4 : mat;\n    d = min(d, cd);\n    return d;\n    \n\n}\n\n\nfloat ldist(vec2 p, float m) {\n\treturn pow(pow(p.x, m)+pow(p.y, m), 1./m);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    tt = iTime;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.x;\n    \n    vec3 ro = vec3(0, 0, -16),\n         rd = normalize(vec3(uv,.7)),\n         lp = vec3(-1., 1., -8.);\n    vec3 col;\n    float i, t, d = 0.1;\n\n\n    vec3 p = ro;\n    \n    for(i=0.; i<50.; i++) {\n    \n        d = map(p);\n        \n        if(d < 0.001 || t > 40.) break;\n        \t\n        p += rd*d;\n        t += d;\n    }\n    \n    vec2 e = vec2(0.0035, -0.0035);\n    vec3 base_color;\n    int cmat  = mat;\n    bool no_dream = cmat == 4 && fract(tt/(8.*PI)) < .5;\n    \n    if(d < 0.001 && p.z < 3.3 && !no_dream) {\n        vec3 n = normalize( e.xyy*map(p+e.xyy) + e.yyx*map(p+e.yyx) +\n                            e.yxy*map(p+e.yxy) + e.xxx*map(p+e.xxx));\n        \n        vec3 l = normalize(lp-p);\n        float dif = max(dot(n, l), .0);\n        float spe = pow(max(dot(reflect(-rd, n), -l), .0), 50.);\n        float sss = smoothstep(0.0, 1.0, map(p + l*0.4));\n        \n\t\tfloat fr = pow(1.+dot(n, rd), 2.);\n\n        float sssf = .2;\n    \n        if(cmat == 0 && p.z < 0.) {\n            base_color = vec3(1);   \n            p = transform_mask(p);\n       \t\tbase_color *= mask_texture(p.xy);\n        \n            if(mod(id, 2.) == 0.) {\n          \t    base_color = 1.-base_color;\n       \t    }\n        } else if(cmat == 1){\n            p = transform_box1(p);\n            base_color = vec3(.01+dots(p.xy, .3, 2.));\n        } else if( mat == 2) {\n            p = transform_box2(p);\n\n           base_color = vec3(dots(p.yz, .15, 1.2));\n        } else if (cmat ==3){\n        \tbase_color = vec3(.6);\n            sssf = .5;\n        }\n        col += base_color*dif+.5*spe+sssf*sss;\n        col *= 1.3;\n        \n        if(cmat == 4 && fract(tt/(8.*PI)) > .5) {\n            col = dream(inter.xz);\n        }\n\n\n    } else {\n\t\n      // Background is a pseudo 3d torus\n      col = leaf_layers(uv)*.6;\n      col += 1.5*pow((1.-ldist(abs(uv), .8)), 10.);\n      \n    }\n    \n\t//col = vec3(dots(uv));\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}