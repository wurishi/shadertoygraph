{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/* created by okanovic dragan (abstract algorithm) */\n\n// mushroom texture sampler\n//----------------------------------------------------------------------\n#define WW 0.0\n#define OO 1.0\n#define cc 2.0\n#define _i 3.0\n\n#define MKNum(a,b,c,d,e,f,g,h) (a+4.0*(b+4.0*(c+4.0*(d+4.0*(e+4.0*(f+4.0*(g+h*4.0)))))))\n\n// as suggested by iq and movAX13h\nfloat samplef(in vec2 uv) {\n\tivec2 p = ivec2(0.0);\n\tp.x = int( uv.x*16.);\n\tp.y = int( uv.y*16.);\n    p.x = (p.x>7) ? 15-p.x : p.x;\n\n    float rr=0.0;\n\n    if(p.y== 0) rr=MKNum( _i,_i,_i,_i,_i,WW,WW,WW);\n    if(p.y== 1) rr=MKNum( _i,_i,_i,WW,WW,WW,OO,cc);\n    if(p.y== 2) rr=MKNum( _i,_i,WW,WW,OO,OO,OO,cc);\n    if(p.y== 3) rr=MKNum( _i,WW,WW,cc,OO,OO,cc,cc);\n    if(p.y== 4) rr=MKNum( _i,WW,OO,cc,cc,cc,cc,cc);\n    if(p.y== 5) rr=MKNum( WW,WW,OO,OO,cc,cc,OO,OO);\n    if(p.y== 6) rr=MKNum( WW,OO,OO,OO,cc,OO,OO,OO);\n    if(p.y== 7) rr=MKNum( WW,OO,OO,OO,cc,OO,OO,OO);\n    if(p.y== 8) rr=MKNum( WW,OO,OO,cc,cc,OO,OO,OO);\n    if(p.y== 9) rr=MKNum( WW,cc,cc,cc,cc,cc,OO,OO);\n    if(p.y==10) rr=MKNum( WW,cc,cc,WW,WW,WW,WW,WW);\n    if(p.y==11) rr=MKNum( WW,WW,WW,WW,_i,_i,WW,_i);\n    if(p.y==12) rr=MKNum( _i,WW,WW,_i,_i,_i,WW,_i);\n    if(p.y==13) rr=MKNum( _i,_i,WW,_i,_i,_i,_i,_i);\n    if(p.y==14) rr=MKNum( _i,_i,WW,WW,_i,_i,_i,_i);\n    if(p.y==15) rr=MKNum( _i,_i,_i,WW,WW,WW,WW,WW);\n\n    return mod( floor(rr / pow(4.0,float(p.x))), 4.0 )/3.0;\n}\n\n// distance field formulas by inigo quilez\n//----------------------------------------------------------------------\nfloat sdPlane( vec3 p ) {\n\treturn p.y;\n}\nfloat sdCube( vec3 p, float a ) {\n  return length(max(abs(p) - vec3(a),0.0));\n}\nvec2 opU( vec2 d1, vec2 d2 ) {\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\nfloat smin( float a, float b) {\n\tfloat k=3.1;\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n\tk = 0.9;\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\nvec2 map( in vec3 pos ) {\n\tfloat d= smin( sdPlane(pos), sdCube(pos-vec3( 0.0, 0.5, 0.0), 0.5 ) );\n\treturn vec2(d,1.);\n}\n//----------------------------------------------------------------------\nvec3 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\tfloat precis = 0.001;\t// when to call a hit\n    float h=precis*2.0;\t\t// howmuch to move along the ray\n    float t = 0.0;\t\t\t// moved already\n    vec2 m = vec2(-1.0);\t// color/uv, depends on use, here - uv\n    vec3 pos = vec3(0.0);\t// 3d position\n    for( int i=0; i<60; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) break;\t// voila\n        t += h;\t\t\t\t\t//  move\n        pos = ro+rd*t;\t\t\t// update current 3d position\n\t    vec2 res = map( pos );\t// get de\n        h = res.x;\t\t\t\t// get de\n\t    m = vec2(res.y);\t\t// uv/color\n    }\n    // corrections of uv\n    if( abs(pos.x)<0.5 && pos.y>0.99 && abs(pos.z)<0.5) { m= vec2(.5+pos.x, .5+pos.z); }\n    else {\tm = vec2(pos.x/10.5+1.5, pos.z/10.5+1.5);\t}\n    // it was a good day :)\n    return vec3( t, m );\n}\n// approximate shadow :: https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<60; i++ )\n    {\n\t\tif( t<maxt )\n\t\t{\n\t        float h = map( ro + rd*t ).x;\n\t        res = min( res, k*h/t );\n\t        t += 0.02;\n\t\t}\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n// approximate normal :: http://code4k.blogspot.com/2009/10/potatro-and-raymarching-story-of.html\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n// code by inigo quilez\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n// brdf thingy, mostly inigo's code\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n    vec3 res = castRay(ro,rd,20.0);\n    float t = res.x;\n\tvec2 uv = res.yz;\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n    float ao = calcAO( pos, nor );\n\n    // sampling the mushroom \"texture\" and coloring\n\tcol = (uv.x>1.) ? vec3( (uv-vec2(1.))*clamp(0.8+0.3*sin(iTime), 0.0, 1.0), 1.) : vec3(samplef(uv));\n\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\t// light direction (0., 1., 0.)\n\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n    float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\tfloat sh = 1.0;\n\tif( dif>0.02 ) { sh = softshadow( pos, lig, 0.02, 10.0, 7.0 ); dif *= sh; }\n\n\tvec3 brdf = vec3(0.0);\n\tbrdf += 0.20*amb*vec3(0.10,0.11,0.13)*ao;\n    brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n    brdf += 1.20*dif*vec3(1.00,0.90,0.70);\n\n\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\tfloat spe = sh*pow(pp,16.0);\n\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\tcol = col*brdf + vec3(1.0)*col*spe + 0.2*fre*(0.5+0.5*col);\n\n\tcol *= exp( -0.01*t*t );\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\n\tfloat time = 5.0 + 4.*iTime + 20.0*iMouse.x/iResolution.x;\n\n\t// camera\t\n\tvec3 ro = vec3( 2.*cos(0.2*time),\n\t\t\t\t\t2.0 + sin(0.2*time),\n\t\t\t\t\t2.*sin(0.2*time) );\t\t// camera position aka ray origin\n\n\tvec3 ta = vec3( 0.0, 0.5, 0.0 );\t\t// camera look-at position\n\t\n\t// camera tx\n\tvec3 eye = normalize( ta-ro );\t\t\t\t\t\t// eye vector\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\t\t\t\t\t// \"up\" vector\n\tvec3 hor = normalize( cross(eye, cp) );\t\t\t\t// horizontal vector\n\tvec3 up = normalize( cross(hor, eye) );\t\t\t\t// up vector\n\tvec3 rd = normalize( p.x*hor + p.y*up + 2.5*eye );\t// ray direction\n\t\n\t// main thing\n\tvec3 col = sqrt(render( ro, rd ));\n\t\n\t// vignette\n    col *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\n\t// ta-da!\n    fragColor=vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XsS3zW","date":"1384121067","viewed":399,"name":"rise of shroom","username":"Abstract_Algorithm","description":"Literally first try with distance field. :)\nI still use \"embedded texture\" because I'm not sure how to solve texture swimming problem...","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefield","mushroom"],"hasliked":0,"parentid":"","parentname":""}}