{"ver":"0.1","info":{"id":"cs33R2","date":"1677589608","viewed":209,"name":"Triplanar Normal Mapping","username":"enuyeel","description":"Triplanar Normal Mapping by Yune '23 (twitter: @yuneismyname / website: https://yuneismyname.com)\n\nA proof of concept for triplanar normal mapping (UDN Blend), inspired by Ben Golus’s article.","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["displacement","triplanar","blending","heightmap","bumpmapping","normal","orthographic","boxmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Triplanar Normal Mapping \n// by Yune 2023 (twitter: @yuneismyname / website: https://yuneismyname.com)\n// https://www.shadertoy.com/view/cs33R2\n\n/*\n    A proof of concept for triplanar normal mapping (UDN Blend), inspired by\n    Ben Golus’s article. Now off to implement this feature on Unreal Engine ;)\n    \n    References:\n        - [https://bgolus.medium.com/normal-mapping-for-a-triplanar-shader-10bf39dca05a#cd11]\n        - [https://github.com/bgolus/Normal-Mapping-for-a-Triplanar-Shader/blob/master/TriplanarUDN.shader]\n        \n    TODO:\n        - AO?\n        \n    Updated:\n*/\n\nvec3 tpnm( vec3 p, vec3 mt /*mesh tangent*/ )\n{\n    vec3 bF = pow(abs(mt), vec3(4.));\n    bF /= dot(bF, vec3(1.));\n    \n    vec3 sgn = step(vec3(0.), mt) * 2. - 1.;\n    \n    vec2 uvX = p.zy;\n    uvX.x *= -sgn.x;\n    vec2 uvY = p.xz;\n    uvY.y *= -sgn.y;   \n    vec2 uvZ = p.xy;\n    uvZ.x *= sgn.z;\n\n    vec3 x = 2. * (texture(iChannel0, uvX).rgb - 0.5);\n    x.x *= -sgn.x;  \n    vec3 y = 2. * (texture(iChannel0, uvY).rgb - 0.5);\n    y.y *= -sgn.y;\n    vec3 z = 2. * (texture(iChannel0, uvZ).rgb - 0.5);\n    z.x *= sgn.z;\n\n    //x = normalize(vec3(x.xy + mt.zy, mt.x)); \n    //y = normalize(vec3(y.xy + mt.xz, mt.y));\n    //z = normalize(vec3(z.xy + mt.xy, mt.z));\n    \n    x = vec3(x.xy + mt.zy, mt.x); \n    y = vec3(y.xy + mt.xz, mt.y);\n    z = vec3(z.xy + mt.xy, mt.z);\n \n    return normalize(x.zyx * bF.x + y.xzy * bF.y + z.xyz * bF.z);\n}\n\nfloat tpdm( vec3 p, vec3 mt )\n{\n    vec3 sgn = step(vec3(0.), mt) * 2. - 1.;\n    \n    vec2 uvX = p.zy;\n    uvX.x *= -sgn.x;\n    vec2 uvY = p.xz;\n    uvY.y *= -sgn.y;   \n    vec2 uvZ = p.xy;\n    uvZ.x *= sgn.z;\n\n    float x = 2. * (texture(iChannel0, uvX).a - 0.5);\n    float y = 2. * (texture(iChannel0, uvY).a - 0.5);\n    float z = 2. * (texture(iChannel0, uvZ).a - 0.5);\n\n    vec3 bF = pow(abs(mt), vec3(4.));\n    bF /= dot(bF, vec3(1.));\n\n    return dot(vec3(x, y, z), bF); \n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdf( vec3 re )\n{\n    float s0 = sdSphere( re - vec3(-3., 0., 0.), 1.25 ) \n        - tpdm( re, normalize(re - vec3(-3., 0., 0.)) );\n        \n    float s1 = sdSphere( re - vec3( 0., 0., 0.), 1.25 )\n        - tpdm( re, normalize(re - vec3( 0., 0., 0.)) );\n    \n    float s2 = sdSphere( re - vec3( 3., 0., 0.), 1.25 );\n    \n    return min(min(s0, s1), s1);\n}\n\nfloat sdfid( vec3 re, out float id )\n{\n    float s0 = sdSphere( re - vec3(-3., 0., 0.), 1.25 ) \n        - tpdm( re, normalize(re - vec3(-3., 0., 0.)) );\n        \n    float s1 = sdSphere( re - vec3( 0., 0., 0.), 1.25 )\n        - tpdm( re, normalize(re - vec3( 0., 0., 0.)) );\n    \n    float s2 = sdSphere( re - vec3( 3., 0., 0.), 1.25 );\n    \n    float d = s0;\n    id = 0.;\n    \n    float b = 1. - step(s0, s1); //if left is smaller, b = 0.\n    id = /*(1. - b) * id + */b * 1.;    \n    d = (1. - b) * d + b * s1; \n    \n    b = 1. - step(d, s2);\n    id = (1. - b) * id + b * 2.;   \n    d = (1. - b) * d + b * s2;\n\n    return d;\n}\n\nvec3 nn( vec3 p )\n{\n    const vec2 k = vec2(1.,-1.)*EPS;\n    return normalize( k.xyy*sdf( p + k.xyy ) + \n                      k.yyx*sdf( p + k.yyx ) + \n                      k.yxy*sdf( p + k.yxy ) + \n                      k.xxx*sdf( p + k.xxx ) );\n}\n\nvec3 render( vec3 ro, vec3 rd )\n{\n    vec3 color = vec3(0.0);\n\n    float id;\n    float t = 0.;\n    vec3 re = ro + t * rd;\n    \n    for (int i = 0; i < 128; ++i)\n    {\n        float th = t * 0.001;\n\n        float h = sdfid(re, id);\n\n        if (h < th) break;\n\n        //t += h * 0.25;\n        t += h * 0.5;\n        if (t > 1000.)\n        {\n            t = -1.;\n            break;\n        }\n        \n        re = ro + t * rd;\n    }\n    \n    if (t > 0.)\n    {\n        vec3 N = id == 0. ?\n        nn(re) : tpnm( re, normalize( re - vec3(id * 3.0 - 3.0, 0.0, 0.0) ) );\n\n        vec3 V = -rd;\n        vec3 L = normalize(vec3(cos(iTime), sin(iTime), 0.0));\n        //vec3 L = normalize(vec3(-1., -1., 1.));\n        vec3 H = normalize(V + L);\n\n        float NoV = clamp(dot(N, V), 0.0, 1.0);\n        float NoL = clamp(dot(N, L), 0.0, 1.0);\n        float VoH = clamp(dot(V, H), 0.0, 1.0);\n\n        vec3 F = vec3(pow(1.0 - VoH, 5.0));\n        vec3 Fr = (1. / PI) * (0.5 / (NoL + NoV)) * F;\n        vec3 Fd = (1. / PI) * vec3(1.0) * (vec3(1.0) - F);\n\n        color = max(NoL, 0.0) * (Fr + Fd);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord / iResolution.xy - 0.5) * 2.;\n    \n    vec3 ro = vec3(uv * 3.0 * vec2(ar, 1.), 4.);\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n\n    vec3 px = render(ro, rd);\n    \n    px = px / (px + vec3(1.0));\n    px = pow(px, vec3(0.4545454545454545));\n    \n    res = iResolution.xy / DOWN_SCALE;\n    px += text(floor(fragCoord.xy / DOWN_SCALE));\n    \n    fragColor = vec4(px, 1.0);\n    \n    //vec4 up = 2.0 * (texture(iChannel0, fragCoord / iResolution.xy) - 0.5);\n    //fragColor = vec4(up.rgb, 1.0);\n    //fragColor = vec4(up.aaa, 1.0) * 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//displacement multiplier\n#define DMULT 0.1\n\n//It could be done simpler ways, but it's what I can think of off top of my head ;)\nfloat v(vec2 p)\n{\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    \n    float h = 0.;\n    \n    for (int i = -1; i <= 1; ++i)\n    for (int j = -1; j <= 1; ++j)\n    {\n        vec2 pp = fp - vec2(i, j);\n        float t = pp.x * pp.x + pp.y * pp.y;\n        float b = step(t, 0.125); //0.353553^2\n        h += sqrt( b * (0.125 - t) );\n    }\n    \n    return h; //[0, r]; 0 <= r <= 0.5\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    //[https://www.shadertoy.com/view/ldtGWj]\n    //'Precalculated Voronoi Heightmap' by @Shane\n    if(floor(hash22(uv + iTime).x * 8.) < 1. || iFrame==0)\n    {   \n        float uvScale = 7.;\n        float uvOffset = .5;\n        uv *= uvScale;\n        uv += uvOffset;\n    \n        float h = v(uv);\n        vec2 st = (1. / iResolution.xy) * uvScale;\n        vec2 dxy = h - vec2( v(uv + vec2(st.x, 0.)), v(uv + vec2(0., st.y)) );\n        vec3 n = normalize(vec3(dxy / st * DMULT, 1.));\n    \n        //texture format issue; map [-1, 1] to [0, 1]\n        fragColor = vec4(n, h * DMULT) * 0.5 + 0.5;\n    }\n    else\n        fragColor = texture(iChannel0, uv);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define EPS 0.0001\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\n\n//[https://www.shadertoy.com/view/4djSRW]\n//'Hash without Sine' by @Dave_Hoskins\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//[https://www.shadertoy.com/view/Mt2GWD]\n//'96-bit 8x12 Font' by @Flyguy\n\n#define DOWN_SCALE 1.0\n\n#define MAX_INT_DIGITS 4\n\n#define CHAR_SIZE vec2(8, 12)\n#define CHAR_SPACING vec2(8, 12)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n#define NORMAL 0\n#define INVERT 1\n#define UNDERLINE 2\n\nint TEXT_MODE = NORMAL;\n\n/*\n--------\n-###----\n##-##---\n##-##---\n-###----\n#####-#-\n##-####-\n##--##--\n##-###--\n-###-##-\n--------\n--------\n\n00000000\n01110000\n11011000\n11011000\n01110000\n11111010\n11011110\n11001100\n11011100\n01110110\n00000000\n00000000\n\n//Broken up into 4 8x3 (24 bit) chunks for each component of the vec4.\n//Hexadecimal is being used to reduce clutter in the code but decimal still works.\n\n00000000\n01110000 -> 00000000 01110000 11011000 -> 0x0070D8\n11011000\n\n11011000\n01110000 -> 11011000 01110000 11111010 -> 0xD870FA\n11111010\n\n11011110\n11001100 -> 11011110 11001100 11011100 -> 0xDECCDC\n11011100\n\n01110110\n00000000 -> 01110110 00000000 00000000 -> 0x760000\n00000000\n\nvec4(0x0070D8,0xD870FA,0xDECCDC,0x760000)\n*/\n\n//Automatically generated from the 8x12 font sheet here:\n//http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n\nvec4 ch_spc = vec4(0x000000,0x000000,0x000000,0x000000);\nvec4 ch_exc = vec4(0x003078,0x787830,0x300030,0x300000);\nvec4 ch_quo = vec4(0x006666,0x662400,0x000000,0x000000);\nvec4 ch_hsh = vec4(0x006C6C,0xFE6C6C,0x6CFE6C,0x6C0000);\nvec4 ch_dol = vec4(0x30307C,0xC0C078,0x0C0CF8,0x303000);\nvec4 ch_pct = vec4(0x000000,0xC4CC18,0x3060CC,0x8C0000);\nvec4 ch_amp = vec4(0x0070D8,0xD870FA,0xDECCDC,0x760000);\nvec4 ch_apo = vec4(0x003030,0x306000,0x000000,0x000000);\nvec4 ch_lbr = vec4(0x000C18,0x306060,0x603018,0x0C0000);\nvec4 ch_rbr = vec4(0x006030,0x180C0C,0x0C1830,0x600000);\nvec4 ch_ast = vec4(0x000000,0x663CFF,0x3C6600,0x000000);\nvec4 ch_crs = vec4(0x000000,0x18187E,0x181800,0x000000);\nvec4 ch_com = vec4(0x000000,0x000000,0x000038,0x386000);\nvec4 ch_dsh = vec4(0x000000,0x0000FE,0x000000,0x000000);\nvec4 ch_per = vec4(0x000000,0x000000,0x000038,0x380000);\nvec4 ch_lsl = vec4(0x000002,0x060C18,0x3060C0,0x800000);\nvec4 ch_0 = vec4(0x007CC6,0xD6D6D6,0xD6D6C6,0x7C0000);\nvec4 ch_1 = vec4(0x001030,0xF03030,0x303030,0xFC0000);\nvec4 ch_2 = vec4(0x0078CC,0xCC0C18,0x3060CC,0xFC0000);\nvec4 ch_3 = vec4(0x0078CC,0x0C0C38,0x0C0CCC,0x780000);\nvec4 ch_4 = vec4(0x000C1C,0x3C6CCC,0xFE0C0C,0x1E0000);\nvec4 ch_5 = vec4(0x00FCC0,0xC0C0F8,0x0C0CCC,0x780000);\nvec4 ch_6 = vec4(0x003860,0xC0C0F8,0xCCCCCC,0x780000);\nvec4 ch_7 = vec4(0x00FEC6,0xC6060C,0x183030,0x300000);\nvec4 ch_8 = vec4(0x0078CC,0xCCEC78,0xDCCCCC,0x780000);\nvec4 ch_9 = vec4(0x0078CC,0xCCCC7C,0x181830,0x700000);\nvec4 ch_col = vec4(0x000000,0x383800,0x003838,0x000000);\nvec4 ch_scl = vec4(0x000000,0x383800,0x003838,0x183000);\nvec4 ch_les = vec4(0x000C18,0x3060C0,0x603018,0x0C0000);\nvec4 ch_equ = vec4(0x000000,0x007E00,0x7E0000,0x000000);\nvec4 ch_grt = vec4(0x006030,0x180C06,0x0C1830,0x600000);\nvec4 ch_que = vec4(0x0078CC,0x0C1830,0x300030,0x300000);\nvec4 ch_ats = vec4(0x007CC6,0xC6DEDE,0xDEC0C0,0x7C0000);\nvec4 ch_A = vec4(0x003078,0xCCCCCC,0xFCCCCC,0xCC0000);\nvec4 ch_B = vec4(0x00FC66,0x66667C,0x666666,0xFC0000);\nvec4 ch_C = vec4(0x003C66,0xC6C0C0,0xC0C666,0x3C0000);\nvec4 ch_D = vec4(0x00F86C,0x666666,0x66666C,0xF80000);\nvec4 ch_E = vec4(0x00FE62,0x60647C,0x646062,0xFE0000);\nvec4 ch_F = vec4(0x00FE66,0x62647C,0x646060,0xF00000);\nvec4 ch_G = vec4(0x003C66,0xC6C0C0,0xCEC666,0x3E0000);\nvec4 ch_H = vec4(0x00CCCC,0xCCCCFC,0xCCCCCC,0xCC0000);\nvec4 ch_I = vec4(0x007830,0x303030,0x303030,0x780000);\nvec4 ch_J = vec4(0x001E0C,0x0C0C0C,0xCCCCCC,0x780000);\nvec4 ch_K = vec4(0x00E666,0x6C6C78,0x6C6C66,0xE60000);\nvec4 ch_L = vec4(0x00F060,0x606060,0x626666,0xFE0000);\nvec4 ch_M = vec4(0x00C6EE,0xFEFED6,0xC6C6C6,0xC60000);\nvec4 ch_N = vec4(0x00C6C6,0xE6F6FE,0xDECEC6,0xC60000);\nvec4 ch_O = vec4(0x00386C,0xC6C6C6,0xC6C66C,0x380000);\nvec4 ch_P = vec4(0x00FC66,0x66667C,0x606060,0xF00000);\nvec4 ch_Q = vec4(0x00386C,0xC6C6C6,0xCEDE7C,0x0C1E00);\nvec4 ch_R = vec4(0x00FC66,0x66667C,0x6C6666,0xE60000);\nvec4 ch_S = vec4(0x0078CC,0xCCC070,0x18CCCC,0x780000);\nvec4 ch_T = vec4(0x00FCB4,0x303030,0x303030,0x780000);\nvec4 ch_U = vec4(0x00CCCC,0xCCCCCC,0xCCCCCC,0x780000);\nvec4 ch_V = vec4(0x00CCCC,0xCCCCCC,0xCCCC78,0x300000);\nvec4 ch_W = vec4(0x00C6C6,0xC6C6D6,0xD66C6C,0x6C0000);\nvec4 ch_X = vec4(0x00CCCC,0xCC7830,0x78CCCC,0xCC0000);\nvec4 ch_Y = vec4(0x00CCCC,0xCCCC78,0x303030,0x780000);\nvec4 ch_Z = vec4(0x00FECE,0x981830,0x6062C6,0xFE0000);\nvec4 ch_lsb = vec4(0x003C30,0x303030,0x303030,0x3C0000);\nvec4 ch_rsl = vec4(0x000080,0xC06030,0x180C06,0x020000);\nvec4 ch_rsb = vec4(0x003C0C,0x0C0C0C,0x0C0C0C,0x3C0000);\nvec4 ch_pow = vec4(0x10386C,0xC60000,0x000000,0x000000);\nvec4 ch_usc = vec4(0x000000,0x000000,0x000000,0x00FF00);\nvec4 ch_a = vec4(0x000000,0x00780C,0x7CCCCC,0x760000);\nvec4 ch_b = vec4(0x00E060,0x607C66,0x666666,0xDC0000);\nvec4 ch_c = vec4(0x000000,0x0078CC,0xC0C0CC,0x780000);\nvec4 ch_d = vec4(0x001C0C,0x0C7CCC,0xCCCCCC,0x760000);\nvec4 ch_e = vec4(0x000000,0x0078CC,0xFCC0CC,0x780000);\nvec4 ch_f = vec4(0x00386C,0x6060F8,0x606060,0xF00000);\nvec4 ch_g = vec4(0x000000,0x0076CC,0xCCCC7C,0x0CCC78);\nvec4 ch_h = vec4(0x00E060,0x606C76,0x666666,0xE60000);\nvec4 ch_i = vec4(0x001818,0x007818,0x181818,0x7E0000);\nvec4 ch_j = vec4(0x000C0C,0x003C0C,0x0C0C0C,0xCCCC78);\nvec4 ch_k = vec4(0x00E060,0x60666C,0x786C66,0xE60000);\nvec4 ch_l = vec4(0x007818,0x181818,0x181818,0x7E0000);\nvec4 ch_m = vec4(0x000000,0x00FCD6,0xD6D6D6,0xC60000);\nvec4 ch_n = vec4(0x000000,0x00F8CC,0xCCCCCC,0xCC0000);\nvec4 ch_o = vec4(0x000000,0x0078CC,0xCCCCCC,0x780000);\nvec4 ch_p = vec4(0x000000,0x00DC66,0x666666,0x7C60F0);\nvec4 ch_q = vec4(0x000000,0x0076CC,0xCCCCCC,0x7C0C1E);\nvec4 ch_r = vec4(0x000000,0x00EC6E,0x766060,0xF00000);\nvec4 ch_s = vec4(0x000000,0x0078CC,0x6018CC,0x780000);\nvec4 ch_t = vec4(0x000020,0x60FC60,0x60606C,0x380000);\nvec4 ch_u = vec4(0x000000,0x00CCCC,0xCCCCCC,0x760000);\nvec4 ch_v = vec4(0x000000,0x00CCCC,0xCCCC78,0x300000);\nvec4 ch_w = vec4(0x000000,0x00C6C6,0xD6D66C,0x6C0000);\nvec4 ch_x = vec4(0x000000,0x00C66C,0x38386C,0xC60000);\nvec4 ch_y = vec4(0x000000,0x006666,0x66663C,0x0C18F0);\nvec4 ch_z = vec4(0x000000,0x00FC8C,0x1860C4,0xFC0000);\nvec4 ch_lpa = vec4(0x001C30,0x3060C0,0x603030,0x1C0000);\nvec4 ch_bar = vec4(0x001818,0x181800,0x181818,0x180000);\nvec4 ch_rpa = vec4(0x00E030,0x30180C,0x183030,0xE00000);\nvec4 ch_tid = vec4(0x0073DA,0xCE0000,0x000000,0x000000);\nvec4 ch_lar = vec4(0x000000,0x10386C,0xC6C6FE,0x000000);\n\nvec2 res = vec2(0);\nvec2 print_pos = vec2(0);\n\n//Extracts bit b from the given number.\n//Shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n    b = clamp(b,-1.0,24.0);\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n//Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(vec4 spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0))) && all(lessThan(uv,size));\n    \n    float pixels = 0.0;\n    pixels += extract_bit(spr.x, bit - 72.0);\n    pixels += extract_bit(spr.y, bit - 48.0);\n    pixels += extract_bit(spr.z, bit - 24.0);\n    pixels += extract_bit(spr.w, bit - 00.0);\n    \n    return bounds ? pixels : 0.0;\n}\n\n//Prints a character and moves the print position forward by 1 character width.\nfloat char(vec4 ch, vec2 uv)\n{\n    if( TEXT_MODE == INVERT )\n    {\n      //Inverts all of the bits in the character.\n      ch = pow(2.0,24.0)-1.0-ch;\n    }\n    if( TEXT_MODE == UNDERLINE )\n    {\n      //Makes the bottom 8 bits all 1.\n      //Shifts the bottom chunk right 8 bits to drop the lowest 8 bits,\n      //then shifts it left 8 bits and adds 255 (binary 11111111).\n      ch.w = floor(ch.w/256.0)*256.0 + 255.0;  \n    }\n\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\n//Returns the digit sprite for the given number.\nvec4 get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return vec4(0.0);\n}\n\n//Prints out the given number starting at pos.\nfloat print_number(float number, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= -1;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n        \n        if(i == -1) //Add a decimal point.\n        {\n            result += char(ch_per,uv);\n        }\n        \n        if(abs(number) > pow(10.0, float(i)) || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat print_integer(float number, int zeros, vec2 uv)\n{\n    float result = 0.0;\n    \n\tfor(int i = MAX_INT_DIGITS;i >= 0;i--)\n    {\n        float digit = mod( number / pow(10.0, float(i)) , 10.0);\n\n        if(abs(number) > pow(10.0, float(i)) || zeros > i  || i == 0) //Clip off leading zeros.\n        {\n        \tresult += char(get_digit(digit),uv);\n        }\n    }   \n    return result;\n}\n\nfloat text(vec2 uv)\n{\n    float col = 0.0;\n    \n    vec2 center = res/4.0;\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(2.0));\n    \n    TEXT_MODE = INVERT;\n    \n    col += char(ch_L,uv);\n    col += char(ch_e,uv);\n    col += char(ch_f,uv);\n    col += char(ch_t,uv);\n    \n    col += char(ch_spc,uv);\n    col += char(ch_spc,uv);\n    \n    TEXT_MODE = NORMAL;\n    \n    col += char(ch_col,uv);\n    \n    col += char(ch_T,uv);\n    col += char(ch_r,uv);\n    col += char(ch_i,uv);\n    col += char(ch_p,uv);\n    col += char(ch_l,uv);\n    col += char(ch_a,uv);\n    col += char(ch_n,uv);\n    col += char(ch_a,uv);\n    col += char(ch_r,uv);\n\n    col += char(ch_spc,uv);\n\n    col += char(ch_D,uv);\n    col += char(ch_i,uv);\n    col += char(ch_s,uv);\n    col += char(ch_p,uv);\n    col += char(ch_l,uv);\n    col += char(ch_a,uv);\n    col += char(ch_c,uv);\n    col += char(ch_e,uv);\n    col += char(ch_m,uv);\n    col += char(ch_e,uv);\n    col += char(ch_n,uv);\n    col += char(ch_t,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_M,uv);\n    col += char(ch_a,uv);\n    col += char(ch_p,uv);\n    col += char(ch_p,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_g,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_crs,uv);  \n    \n    col += char(ch_spc,uv); \n    \n    col += char(ch_N,uv);\n    col += char(ch_u,uv);\n    col += char(ch_m,uv);\n    col += char(ch_e,uv);\n    col += char(ch_r,uv);\n    col += char(ch_i,uv);\n    col += char(ch_c,uv);\n    col += char(ch_a,uv);\n    col += char(ch_l,uv);\n\n    col += char(ch_spc,uv);\n\n    col += char(ch_N,uv);\n    col += char(ch_o,uv);\n    col += char(ch_r,uv);\n    col += char(ch_m,uv);\n    col += char(ch_a,uv);\n    col += char(ch_l,uv);\n    \n    print_pos = vec2(2, 2.0 + STRHEIGHT(1.0));\n    \n    TEXT_MODE = INVERT;\n    \n    col += char(ch_C,uv);\n    col += char(ch_e,uv);\n    col += char(ch_n,uv);\n    col += char(ch_t,uv);\n    col += char(ch_e,uv);\n    col += char(ch_r,uv);\n    \n    TEXT_MODE = NORMAL;\n    \n    col += char(ch_col,uv);\n    \n    col += char(ch_T,uv);\n    col += char(ch_r,uv);\n    col += char(ch_i,uv);\n    col += char(ch_p,uv);\n    col += char(ch_l,uv);\n    col += char(ch_a,uv);\n    col += char(ch_n,uv);\n    col += char(ch_a,uv);\n    col += char(ch_r,uv);\n\n    col += char(ch_spc,uv);\n\n    col += char(ch_D,uv);\n    col += char(ch_i,uv);\n    col += char(ch_s,uv);\n    col += char(ch_p,uv);\n    col += char(ch_l,uv);\n    col += char(ch_a,uv);\n    col += char(ch_c,uv);\n    col += char(ch_e,uv);\n    col += char(ch_m,uv);\n    col += char(ch_e,uv);\n    col += char(ch_n,uv);\n    col += char(ch_t,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_M,uv);\n    col += char(ch_a,uv);\n    col += char(ch_p,uv);\n    col += char(ch_p,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_g,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_crs,uv);  \n    \n    col += char(ch_spc,uv); \n    \n    col += char(ch_T,uv);\n    col += char(ch_r,uv);\n    col += char(ch_i,uv);\n    col += char(ch_p,uv);\n    col += char(ch_l,uv);\n    col += char(ch_a,uv);\n    col += char(ch_n,uv);\n    col += char(ch_a,uv);\n    col += char(ch_r,uv);\n\n    col += char(ch_spc,uv);\n\n    col += char(ch_N,uv);\n    col += char(ch_o,uv);\n    col += char(ch_r,uv);\n    col += char(ch_m,uv);\n    col += char(ch_a,uv);\n    col += char(ch_l,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_M,uv);\n    col += char(ch_a,uv);\n    col += char(ch_p,uv);\n    col += char(ch_p,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_g,uv);\n\n    col += char(ch_spc,uv);\n\n    col += char(ch_lbr,uv);\n\n    col += char(ch_U,uv);\n    col += char(ch_D,uv);\n    col += char(ch_N,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_B,uv);\n    col += char(ch_l,uv);\n    col += char(ch_e,uv);\n    col += char(ch_n,uv);\n    col += char(ch_d,uv);\n    \n    col += char(ch_rbr,uv);\n\n    print_pos = vec2(2, 2.0 + STRHEIGHT(0.0));\n    \n    TEXT_MODE = INVERT;\n    \n    col += char(ch_R,uv);\n    col += char(ch_i,uv);\n    col += char(ch_g,uv);\n    col += char(ch_h,uv);\n    col += char(ch_t,uv);\n    \n    col += char(ch_spc,uv);\n    \n    TEXT_MODE = NORMAL;\n    \n    col += char(ch_col,uv);\n    \n    col += char(ch_T,uv);\n    col += char(ch_r,uv);\n    col += char(ch_i,uv);\n    col += char(ch_p,uv);\n    col += char(ch_l,uv);\n    col += char(ch_a,uv);\n    col += char(ch_n,uv);\n    col += char(ch_a,uv);\n    col += char(ch_r,uv);\n\n    col += char(ch_spc,uv);\n\n    col += char(ch_N,uv);\n    col += char(ch_o,uv);\n    col += char(ch_r,uv);\n    col += char(ch_m,uv);\n    col += char(ch_a,uv);\n    col += char(ch_l,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_M,uv);\n    col += char(ch_a,uv);\n    col += char(ch_p,uv);\n    col += char(ch_p,uv);\n    col += char(ch_i,uv);\n    col += char(ch_n,uv);\n    col += char(ch_g,uv);\n\n    col += char(ch_spc,uv);\n\n    col += char(ch_lbr,uv);\n\n    col += char(ch_U,uv);\n    col += char(ch_D,uv);\n    col += char(ch_N,uv);\n    \n    col += char(ch_spc,uv);\n    \n    col += char(ch_B,uv);\n    col += char(ch_l,uv);\n    col += char(ch_e,uv);\n    col += char(ch_n,uv);\n    col += char(ch_d,uv);\n    \n    col += char(ch_rbr,uv);\n    \n    return col;\n}","name":"Common","description":"","type":"common"}]}