{"ver":"0.1","info":{"id":"DlSyDt","date":"1692398108","viewed":27,"name":"00GraphicsClassLesson02_ex2","username":"foodini","description":"I'm teaching an intro to computer graphics. This is one of the class examples. I just wanted to show a quick example of how to put together a (slightly) complex object with a set of progressive mathematical functions. It's a prelude to pathtracing.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["graphicsintro"],"hasliked":0,"parentid":"dljyWK","parentname":"00GraphicsClassLesson02_ex1"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.141592653589793;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // fragCoord comes in as the x,y index into the pixel array of the screen. In other\n    // words, its scale depends upon the screen resolution. It's most convenient to think\n    // of pixels' locations in terms of their relative positions. This scales the screen\n    // to range from 0.0 to 1.0 in both dimensions.\n    vec2 uv = fragCoord/(iResolution.xy - vec2(1.0, 1.0));\n\n    // Rescale so our screen center is at (0.0, 0.0)\n    uv *= 2.0;\n    uv -= 1.0;\n    \n    // The pixels in the image now go from <0.0, 0.0> at the bottom left to\n    // <1.0, 1.0> at the top right. This means our pixels are squashed. Going up\n    // by one pixel incrases y by more than going right by one increases x. Rescale\n    // in the y direction to compensate. This means that the top right is no\n    // longer <1.0, 1.0>. It's more like <1.0, 0.65>, though it depends on your screen\n    // resolution.\n    float aspect_ratio = iResolution.y/iResolution.x;\n    uv.y *= aspect_ratio;\n \n    // ROTATION {\n        float cTime = cos(iTime);\n        float sTime = sin(iTime);\n\n        mat2x2 rot = mat2x2(\n            cTime, -sTime,\n            sTime,  cTime);\n\n        uv = uv * rot;\n    // } END OF ROTATION\n \n    // set the default background color, black:\n    fragColor.rgb = vec3(0.0);\n    \n    float size = 0.3 + 0.15 * pow(sin(iTime), 2.0);\n    float slash_leg_width = 0.06 * size;\n    float backslash_leg_width = 0.25 * size;\n    float slash_leg_slant = 1.1;\n    float backslash_leg_slant = 1.3;\n    float border_size = 0.06 * size;\n    \n    if(abs(uv.y) < size) {\n        // make the slash (from top-right to bottom-left)\n        if(abs(slash_leg_slant * uv.x - uv.y) < slash_leg_width) {\n            fragColor.xyz = vec3(1.0);\n        }\n        \n        // make the backslash (from bottom-right to top-left)\n        if(abs(backslash_leg_slant * uv.x + uv.y) < backslash_leg_width) {\n            fragColor.xyz = vec3(1.0);\n        }\n        \n        // We're now just going to make a second backslash, but this one is a \n        // little narrower and doesn't go all the way from y=(-size) to y=(size):\n        if(abs(backslash_leg_slant * uv.x + uv.y) < backslash_leg_width - 2.0 * border_size &&\n           abs(uv.y) < size - border_size) {\n            fragColor.xyz = vec3(0.0);\n        }\n    }   \n}","name":"Image","description":"","type":"image"}]}