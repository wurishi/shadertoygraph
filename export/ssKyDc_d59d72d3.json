{"ver":"0.1","info":{"id":"ssKyDc","date":"1655761375","viewed":67,"name":"OpenAI generated Shader","username":"GeorgMethner","description":"This shader was completely generated by OpenAIs AI. Truly a powerful tool. I wanted to add reflections but it didnt let me because of recursion. If anyone has an idea how to fix this please write a comment. ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raycast","openai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float raycast(vec3 eye, vec3 dir, float groundPlane)\n{\n\t// distance to ground plane\n\treturn (eye.y - groundPlane) / dir.y;\n}\n\nfloat intersectSphere(vec3 eye, vec3 dir, vec3 center, float radius)\n{\n\tvec3 toEye = eye - center;\n\tfloat a = dot(dir, dir);\n\tfloat b = 2. * dot(toEye, dir);\n\tfloat c = dot(toEye, toEye) - radius*radius;\n\tfloat discriminant = b*b - 4.*a*c;\n\tif (discriminant > 0.)\n\t{\n\t\t// ray hits sphere!\n\t\tfloat t = (-b - sqrt(discriminant)) / (2. * a);\n\t\tif (t > 0.)\n\t\t{\n\t\t\treturn t;\n\t\t}\n\t}\n\t\n\t// no hit\n\treturn -1.;\n}\n\nfloat shadowRay(vec3 eye, vec3 toLight)\n{\n\tfloat shadow = 1.0;\n\t\n\t// add a sphere\n\tfloat sphere = intersectSphere(eye, toLight, vec3(0.5, 0.5, 1.), 0.5);\n\tif (sphere > 0.)\n\t{\n\t\tshadow = 0.5;\n\t}\n\t\n\treturn shadow;\n}\n\nvec3 render(vec3 eye, vec3 dir)\n{\n\tvec3 color = vec3(0.1);\n\t\n\t// add some light\n\tvec3 lightDir = normalize(vec3(1., 1., -1.));\n\tfloat lightIntensity = clamp(dot(lightDir, dir), 0., 1.);\n\tcolor += lightIntensity * vec3(1., 1., 1.);\n\t\n\t// add background color\n\tcolor += vec3(0.1, 0.1, 1.0);\n\t\n\t// add a sphere\n\tfloat sphere = intersectSphere(eye, dir, vec3(0.5, 0.5, 1.), 0.5);\n\tif (sphere > 0.)\n\t{\n\t\tcolor = mix(color, vec3(1., 0., 0.), sphere);\n\t}\n\t\n\t// add a point light\n\tvec3 lightPos = vec3(0.25, 0.25, 1.0);\n\tvec3 toLight = lightPos - eye;\n\tfloat lightDistance = length(toLight);\n\ttoLight /= lightDistance; // normalize\n\t\n\tfloat lightAttenuation = 1.0 / (1.0 + lightDistance);\n\tcolor += lightAttenuation * vec3(1., 1., 1.);\n\t\n\t// add shadows\n\tfloat shadow = shadowRay(eye, toLight);\n\tif (shadow < 1.0)\n\t{\n\t\tcolor *= shadow;\n\t}\n\t\n\t// add ambient occlusion\n\tfloat ambientOcclusion = 1.0 - shadowRay(eye, toLight);\n\tcolor *= ambientOcclusion;\n\t\n\treturn color;\n}\n\nfloat groundPlane = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 eye = vec3(0., 0., -1.);\n\tvec3 dir = normalize(vec3(uv.xy, 1.));\n\t\n\t// render scene\n\tfragColor = vec4(render(eye, dir), 1);\n\t\n\t// shade ground plane\n    float ground = raycast(eye, dir, groundPlane);\n\tif (ground > 0.)\n\t{\n\t\tfragColor = mix(fragColor, vec4(0.1, 0.5, 0.1, 1.), ground);\n\t}\n}","name":"Image","description":"","type":"image"}]}