{"ver":"0.1","info":{"id":"ltGXRD","date":"1483214404","viewed":109,"name":"Primitives","username":"wikiemol","description":"Trying out raymarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * I just learned about ray marching. I've done raytracing before, \n * but the idea of using distance functions and raymarching seems really fascinating! \n * I heard about this website a year or two ago but never really did anything with it.\n * I saw that Inigo Quilez (seems pretty ubiquitous on this site)\n * had an article about distance functions,\n * https://iquilezles.org/articles/distfunctions \n * but I wanted to see if I could figure them out without looking at the code by\n * just looking at the pictures.\n *\n * The goal is to show that they are all 0 on the surface of the\n * object. Not very rigorous, but good enough!\n *\n * Here they are with explanations!\n **/\n\n/*\nThis first one was introduced to me\nas an example of raymarching. \n(https://www.youtube.com/watch?v=yxNnRSefK94)\nSo I didn't figure this one out on my own.\n\nThe explanation is fairly straight forward,\nwhen the point is 1 unit away from the origin\nthis will return 0 because 1 - 1 is 0. \nThus, the set of points that make this function 0\nis the set of points that are distance 1 from the origin\nWhich is the definition of a sphere\n\n(note that 1 can be changed to any number without\nloss of generality, so 1.0 can be any radius.\nAlternatively, you could increase or decrease\nthe radius by scaling the point).\n*/\nfloat sphere(vec3 point) {\n    return length(point) - 0.5;\n}\n\n\nfloat prism(vec3 point) {\n    float width = 0.3;\n    float height = 0.3;\n    float depth = 0.3;\n    return max(abs(point.x) - width, max(abs(point.z) - depth, abs(point.y) - height));\n}\n\nfloat quad(vec3 point) {\n\tfloat width = 0.3;\n    float depth = 0.3;\n    return max(abs(point.x) - width, max(abs(point.z) - depth, abs(point.y)));\n}\n\nfloat triangle(vec3 point) {\n\tfloat width = 0.3;\n    float depth = 0.3;\n    return max(abs(point.x) - width, max(abs(point.z) - depth - point.x * 1.0, abs(point.y)));\n}\n\nfloat torus(vec3 point) {\n    float centerRadius = 0.5;\n    float tubeRadius = 0.1;\n    return length(vec2(length(point.xy) - centerRadius, point.z)) - tubeRadius;\n}\nfloat cylinder(vec3 point) {\n    float radius = 0.5;\n    float height = 0.6;\n    return max(length(point.xz) - radius, abs(point.y) - height);\n}\n\nfloat cone(vec3 point) {\n\treturn length(point.xz) + 0.5 * point.y;\n}\n\nfloat march(vec3 origin, vec3 ray) {\n\tfloat t = 0.0;\n    for (int i = 0; i < 200; i++) {\n        vec3 point = origin  + ray * t;\n        point = fract(point) * 2.0 - 1.0;\n        switch (int(iTime) / 2 % 7) {\n            case 0: t += sphere(point) * 0.3; break;\n            case 1: t += prism(point) * 0.3; break;\n            case 2: t += quad(point) * 0.3; break;\n            case 3: t += triangle(point) * 0.3; break;\n            case 4: t += torus(point) * 0.3; break;\n            case 5: t += cylinder(point) * 0.3; break;\n            case 6: t += cone(point) * 0.3; break;\n\n        }\n\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    // vec3 origin = vec3(0.0, 0.0, -3.0);\n    vec3 origin = vec3(0.1 * iTime + iMouse.x * 0.01, \n                       0.1 * iTime + iMouse.y * 0.01, \n                       -3.0);\n    vec3 ray = (vec3(uv, 1.0));\n\tfragColor = vec4(vec3(1.0/march(origin, ray)),1.0);\n}","name":"Image","description":"","type":"image"}]}