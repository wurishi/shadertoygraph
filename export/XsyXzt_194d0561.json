{"ver":"0.1","info":{"id":"XsyXzt","date":"1465920515","viewed":211,"name":"Circularly Inversed Tiling","username":"Ultraviolet","description":"inspired from http://images.math.cnrs.fr/Sur-l-inversion-conique.html\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["2d","geometry","tiling","inversion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define AA 4.0\n\nvec2 circularInvert(in vec2 p, in vec2 omega, in float k)\n{\n    vec2 diff = p-omega;\n    return k*diff/dot(diff, diff);\n}\n\nfloat checkerTexture(in vec2 pos)\n{\n    pos = .5-fract(pos);\n    return .5 + .5*sign(pos.x*pos.y);\n}\n\nfloat triTexture(in vec2 pos)\n{\n    vec2 pos2 = pos;\n    pos2.x = pos.x  - pos.y * 0.5;\n    pos2.y = pos.y / sqrt(3.0) / 0.5;\n    \n    float ind = 1.0;\n    \n    if(mod(pos2.x, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    if(mod(pos2.y, 1.0) > 0.5)\n        ind *= -1.0;\n    \n    if(mod(pos2.y, 1.0) > 1.0 - mod(pos2.x, 1.0))\n        ind *= -1.0;\n    \n    ind = max(ind, 0.0);\n    \n    return ind;\n}\n\n\nfloat hexaTexture(vec2 uv)\n{\n    float t = 1.0;\n    \n    uv.y = uv.y * 0.866 + uv.x*0.5;\n    uv = mod(uv, vec2(3.0));\n    \n    if(uv.y>0.0 && uv.x > 0.0 && uv.y < uv.x+1.0 && uv.y > uv.x-1.0 && uv.y<2.0 && uv.x < 2.0)\n        t=0.0;\n    else if(uv.y > 1.0 && (uv.y < uv.x || uv.x < 1.0))\n        t = 0.5;\n    \n    return t;\n}\n\n\n\nfloat perlinTexture(in vec2 pos)\n{\n    const float N = 5.0;\n    \n    vec2 pos2 = pos;\n    \n    float ind = 0.0;\n    float ampl = 1.0;\n    \n    for(float n = 0.0; n < N; n ++)\n    {\n    \tind += texture(iChannel0, pos / iChannelResolution[0].x).x * ampl;\n    \n        ampl *= 0.5;\n        pos *= 2.0;\n    }\n    \n    return ind / (1.0 - pow(0.5, N+1.0)) * 0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    for(float aaX=.0; aaX < AA; aaX++)\n    {\n    \tfor(float aaY=.0; aaY < AA; aaY++)\n        {\n            vec2 uv = (fragCoord.xy + vec2(aaX, aaY)/AA) / iResolution.y;\n            uv = uv - 0.5*vec2(iResolution.x/iResolution.y, 1.0);\n            //uv = uv * 10.0;\n\n            //vec2 omega = vec2(0.5)+0.5*vec2(cos(iTime), sin(iTime));\n            vec2 omega = iMouse.xy / iResolution.y;\n            omega = omega - 0.5*vec2(iResolution.x/iResolution.y, 1.0);\n            \n            if(any(lessThan(iMouse.xy, vec2(0.1))))\n            {\n                omega = 0.5*vec2(cos(0.5*iTime), 0.5*sin(iTime));\n            }\n\n            float k = 1.0;\n\n            uv = circularInvert(uv-omega, vec2(0.0), k);\n\t\t\tfragColor += vec4(vec3(checkerTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += vec4(vec3(triTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += vec4(vec3(perlinTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += vec4(vec3(hexaTexture(uv+omega*5.0)),1.0);\n\t\t\t//fragColor += texture( iChannel1, uv+omega*5.0);\n        }\n    }\n\tfragColor = fragColor / AA / AA;\n}","name":"Image","description":"","type":"image"}]}