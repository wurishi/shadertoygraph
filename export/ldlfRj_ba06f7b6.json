{"ver":"0.1","info":{"id":"ldlfRj","date":"1497910383","viewed":1195,"name":"Bubbly sphere artifacts demo","username":"advecticity","description":"Demonstrates artifacts caused by overstepping, see digitalfreepen.com/2017/06/20/consistent-distance-fields.html","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distanceestimation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 4.\n#define EPSILON 0.0005\n#define ITERATIONS 256\n\n// Uncomment to plot the distance to the object\n// instead of using regular light-based shading\n// #define RENDER_DISTANCE\n\n// Uncomment to artificially magnify differences\n// between the left side with artefacts and the\n// reference right side by five times\n// #define MAKE_OBVIOUS\n\n#define NOISE_PROPORTION 0.75\n#define NOISE_FREQUENCY 50.\n//#define NOISE_GRADIENT_MAGNITUDE (1. * NOISE_FREQUENCY) // max\n#define NOISE_GRADIENT_MAGNITUDE (0.88 * NOISE_FREQUENCY) // 95th percentile\n#define SPHERE_GRADIENT_MAGNITUDE 1.\n#define OVERSTEP_FACTOR 1.25\n\n// Distance to a sphere centered at the origin\nfloat sdSphere(vec3 pos, float radius) {\n    return length(pos) - radius;\n}\n\nfloat noise(vec3 pos) {\n    return sin(pos.x)*sin(pos.y)*sin(pos.z);\n}\n\n// Distance to a sphere with sinusoidal perturbations\n// centered at the origin.\n// Copied over from https://www.shadertoy.com/view/Xds3zN\nfloat sdWeirdSphere(vec3 pos) {\n\treturn mix(sdSphere(pos, 0.2) / SPHERE_GRADIENT_MAGNITUDE,\n               noise(pos * NOISE_FREQUENCY) / NOISE_GRADIENT_MAGNITUDE,\n               NOISE_PROPORTION);\n}\n\nfloat distanceFn(vec3 pos, bool artefacts) {\n    if (artefacts) {\n    \treturn OVERSTEP_FACTOR * sdWeirdSphere(pos);\n    } else {\n    \treturn sdWeirdSphere(pos);\n    }\n}\n\n// Copied over from https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos, bool artefacts) {\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*distanceFn( pos + e.xyy, artefacts ) + \n\t\t\t\t\t  e.yyx*distanceFn( pos + e.yyx, artefacts ) + \n\t\t\t\t\t  e.yxy*distanceFn( pos + e.yxy, artefacts ) + \n\t\t\t\t\t  e.xxx*distanceFn( pos + e.xxx, artefacts ) );\n}\n\n// Ray marching using distance-estimation\n// Adapted from https://www.shadertoy.com/view/Xds3zN\nfloat castRay(vec3 pos, vec3 rayDir, bool artefacts) {\n    float dist = 0.;\n    \n    for (int i = 0; i < ITERATIONS; i++)\n    {\n        // More precision when the object is closer\n\t    float precis = EPSILON * dist;\n\t    float res = distanceFn(pos + rayDir * dist, artefacts);\n        if (res < precis || dist > MAX_DIST) break;\n        dist += res;\n    }\n    \n    return dist;\n}\n\n// Copied over from https://www.shadertoy.com/view/Xds3zN\n// setCamera(origin, target, rotation)\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Copied over from https://www.shadertoy.com/view/Xds3zN\nvec3 shade(vec3 camera, vec3 rayDir, float dist, bool artefacts) {\n    vec3 rayPos = camera + rayDir * dist;\n    vec3 normal = calcNormal(rayPos, artefacts);\n    vec3 ref = reflect(rayDir, normal);\n    \n    float m = 65.;\n    vec3 col = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n    \n    // Lighting\n    vec3  lig = normalize( vec3(-0.4, 0.7, -0.6) );\n    float amb = clamp( 0.5+0.5*normal.y, 0.0, 1.0 );\n    float dif = clamp( dot( normal, lig ), 0.0, 1.0 );\n    float bac = clamp( dot( normal, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-rayPos.y,0.0,1.0);\n    float dom = smoothstep( -0.1, 0.1, ref.y );\n    float fre = pow( clamp(1.0+dot(normal,rayDir),0.0,1.0), 2.0 );\n    float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n    vec3 lin = vec3(0.3);\n    lin += 1.30*dif*vec3(1.00,0.80,0.55);\n    lin += 2.00*spe*vec3(1.00,0.90,0.70);\n    lin += 0.40*amb*vec3(0.40,0.60,1.00);\n    lin += 0.50*dom*vec3(0.40,0.60,1.00);\n    lin += 0.50*bac*vec3(0.25,0.25,0.25);\n    lin += 0.25*fre*vec3(1.00,1.00,1.00);\n    col = col*lin;\n\n    col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*dist*dist*dist ) );\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvec3 distanceShade(float dist, float minDist, float maxDist) {\n    float normalized = (dist - minDist) / (maxDist - minDist);\n    if (normalized < 1. / 4.) {\n        float inRange = normalized * 4.;\n        return vec3(inRange, 0., 0.);\n    } else if (normalized < 2. / 4.) {\n        float inRange = (normalized - 1. / 4.) * 4.;\n        return vec3(1. - inRange, inRange, 0.);\n    } else if (normalized < 3. / 4.) {\n        float inRange = (normalized - 2. / 4.) * 4.;\n        return vec3(0., 1. - inRange, inRange);\n    } else {\n        float inRange = (normalized - 3. / 4.) * 4.;\n        return vec3(0., 0., 1. - inRange);\n    }\n}\n\nvec4 render(vec2 uv, bool artefacts) {\n    vec3 camera = vec3(cos(iTime / 4.), 0.0, sin(iTime / 4.)) * 0.75;\n    vec3 target = vec3(0.0);\n    \n    // Camera-to-world transformation\n    mat3 transform = setCamera(camera, target, 0.0);\n    \n    // Origin is now at the center of the screen (given camera position);\n    vec3 rayDirection = transform * normalize(vec3(uv, 2.0));\n    \n    float dist = castRay(camera, rayDirection, artefacts);\n    \n    if (dist > MAX_DIST) {\n\t\treturn vec4(uv, 0., 1.0);\n    } else {\n        #ifdef RENDER_DISTANCE\n            return vec4(distanceShade(dist, 0.475, 0.8), 1.0);\n        #else\n        \treturn vec4(shade(camera, rayDirection, dist, artefacts), 1.0);\n        #endif\n    }\n}\n\n// fragColor: 0 to 1, starting at bottom-left corner\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Divide by two since we split the screen\n    vec2 splitResolution = vec2(iResolution.x / 2., iResolution.y);\n    float minDimension = min(splitResolution.x, splitResolution.y);\n    vec2 uv = (fragCoord - splitResolution / 2.) / minDimension * 2.;\n    if (fragCoord.x < iResolution.x / 2.) {\n        #if defined(MAKE_OBVIOUS) && !defined(RENDER_DISTANCE)\n        \tvec4 wrong = render(uv, true);\n        \tvec4 correct = render(uv, false);\n        \tfragColor = wrong + (wrong - correct) * 5.;\n        #else\n        \tfragColor = render(uv, true);\n        #endif\n    } else {\n        fragColor = render(uv - vec2(iResolution.x / minDimension, 0.0), false);\n    }\n}","name":"Image","description":"","type":"image"}]}