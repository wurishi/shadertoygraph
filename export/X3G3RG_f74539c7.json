{"ver":"0.1","info":{"id":"X3G3RG","date":"1717767747","viewed":41,"name":"Skia Blend Modes & Composite Ops","username":"2xAA","description":"This shader ports the Skia blend modes to WebGL which are directly compatible with JavaScript's Canvas2D blend modes. One day in modV I'll move the compositing away from Canvas2D to WebGL, this is for that.\nhttps://skia.org â€¢ http://modv.vcync.gl","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["blending","compositing","skia"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRr","filepath":"/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","previewfilepath":"/media/ap/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 blend_clear(vec4 src, vec4 dst) { return vec4(0.0); }\n\nvec4 blend_src(vec4 src, vec4 dst) { return src; }\n\nvec4 blend_dst(vec4 src, vec4 dst) { return dst; }\n\nvec4 blend_src_over(vec4 src, vec4 dst) { return src + (1.0 - src.a) * dst; }\n\nvec4 blend_dst_over(vec4 src, vec4 dst) { return (1.0 - dst.a) * src + dst; }\n\nvec4 blend_src_in(vec4 src, vec4 dst) { return src * dst.a; }\n\nvec4 blend_dst_in(vec4 src, vec4 dst) { return dst * src.a; }\n\nvec4 blend_src_out(vec4 src, vec4 dst) { return (1.0 - dst.a) * src; }\n\nvec4 blend_dst_out(vec4 src, vec4 dst) { return (1.0 - src.a) * dst; }\n\nvec4 blend_src_atop(vec4 src, vec4 dst) { return dst.a * src + (1.0 - src.a) * dst; }\n\nvec4 blend_dst_atop(vec4 src, vec4 dst) { return (1.0 - dst.a) * src + src.a * dst; }\n\nvec4 blend_xor(vec4 src, vec4 dst) { return (1.0 - dst.a) * src + (1.0 - src.a) * dst; }\n\nvec4 blend_plus(vec4 src, vec4 dst) { return min(src + dst, 1.0); }\n\n///\n\nvec4 blend_darken(float mode /* darken: 1.0, lighten: -1.0 */, vec4 src, vec4 dst) {\n  vec4 a = blend_src_over(src, dst);\n  vec3 b = (1.0 - dst.a) * src.rgb + dst.rgb; // DstOver.rgb\n  a.rgb = mode * min(a.rgb * mode, b.rgb * mode);\n  return a;\n}\n\nvec4 blend_multiply(vec4 src, vec4 dst) {\n  return vec4((1.0 - src.a) * dst.rgb + (1.0 - dst.a) * src.rgb + src.rgb * dst.rgb, src.a + (1.0 - src.a) * dst.a);\n}\n\nfloat color_burn_component(vec2 s, vec2 d) {\n  if (d.y == d.x) {\n    return s.y * d.y + s.x * (1.0 - d.y) + d.x * (1.0 - s.y);\n  } else if (s.x == 0.0) {\n    return d.x * (1.0 - s.y);\n  } else {\n    float delta = max(0.0, d.y - ((d.y - d.x) * s.y / s.x));\n    return delta * s.y + s.x * (1.0 - d.y) + d.x * (1.0 - s.y);\n  }\n}\n\nvec4 blend_color_burn(vec4 src, vec4 dst) {\n  return vec4(color_burn_component(src.ra, dst.ra),\n    color_burn_component(src.ga, dst.ga),\n    color_burn_component(src.ba, dst.ba),\n    src.a + (1.0 - src.a) * dst.a);\n}\n\nvec4 blend_lighten(vec4 src, vec4 dst) {\n  vec4 result = blend_src_over(src, dst);\n  result.rgb = max(result.rgb, (1.0 - dst.a) * src.rgb + dst.rgb);\n  return result;\n}\n\nfloat color_dodge_component(vec2 s, vec2 d) {\n  if (d.x == 0.0) {\n    return s.x * (1.0 - d.y);\n  } else {\n    float delta = s.y - s.x;\n    if (delta == 0.0) {\n      return s.y * d.y + s.x * (1.0 - d.y) + d.x * (1.0 - s.y);\n    } else {\n      delta = min(d.y, d.x * s.y / delta);\n      return delta * s.y + s.x * (1.0 - d.y) + d.x * (1.0 - s.y);\n    }\n  }\n}\n\nvec4 blend_color_dodge(vec4 src, vec4 dst) {\n  return vec4(color_dodge_component(src.ra, dst.ra),\n    color_dodge_component(src.ga, dst.ga),\n    color_dodge_component(src.ba, dst.ba),\n    src.a + (1.0 - src.a) * dst.a);\n}\n\nfloat blend_overlay_component(vec2 s, vec2 d) {\n  return (2.0 * d.x <= d.y) ? 2.0 * s.x * d.x\n    : s.y * d.y - 2.0 * (d.y - d.x) * (s.y - s.x);\n}\n\nvec4 blend_overlay(vec4 src, vec4 dst) {\n  vec4 result = vec4(blend_overlay_component(src.ra, dst.ra),\n    blend_overlay_component(src.ga, dst.ga),\n    blend_overlay_component(src.ba, dst.ba),\n    src.a + (1.0 - src.a) * dst.a);\n  result.rgb += dst.rgb * (1.0 - src.a) + src.rgb * (1.0 - dst.a);\n  return result;\n}\n\nfloat soft_light_component(vec2 s, vec2 d) {\n  if (2.0 * s.x <= s.y) {\n    return (d.x * d.x * (s.y - 2.0 * s.x) / d.y) + (1.0 - d.y) * s.x + d.x * (-s.y + 2.0 * s.x + 1.0);\n  } else if (4.0 * d.x <= d.y) {\n    float DSqd = d.x * d.x;\n    float DCub = DSqd * d.x;\n    float DaSqd = d.y * d.y;\n    float DaCub = DaSqd * d.y;\n    return (DaSqd * (s.x - d.x * (3.0 * s.y - 6.0 * s.x - 1.0)) + 12.0 * d.y * DSqd * (s.y - 2.0 * s.x)\n      - 16.0 * DCub * (s.y - 2.0 * s.x) - DaCub * s.x / DaSqd);\n  } else {\n    return d.x * (s.y - 2.0 * s.x + 1.0) + s.x - sqrt(d.y * d.x) * (s.y - 2.0 * s.x) - d.y * s.x;\n  }\n}\n\nvec4 blend_soft_light(vec4 src, vec4 dst) {\n  return (dst.a == 0.0) ? src : vec4(soft_light_component(src.ra, dst.ra),\n    soft_light_component(src.ga, dst.ga),\n    soft_light_component(src.ba, dst.ba),\n    src.a + (1.0 - src.a) * dst.a);\n}\n\nvec4 blend_hard_light(vec4 src, vec4 dst) {\n  return blend_overlay(dst, src);\n}\n\nvec4 blend_difference(vec4 src, vec4 dst) {\n  return vec4(src.rgb + dst.rgb - 2.0 * min(src.rgb * dst.a, dst.rgb * src.a),\n    src.a + (1.0 - src.a) * dst.a);\n}\n\nvec4 blend_exclusion(vec4 src, vec4 dst) {\n  return vec4(dst.rgb + src.rgb - 2.0 * dst.rgb * src.rgb, src.a + (1.0 - src.a) * dst.a);\n}\n\nfloat blend_color_luminance(vec3 color) { return dot(vec3(0.3, 0.59, 0.11), color); }\n\nvec3 blend_set_color_luminance(vec3 hueSatColor, float alpha, vec3 lumColor) {\n  float lum = blend_color_luminance(lumColor);\n  vec3 result = lum - blend_color_luminance(hueSatColor) + hueSatColor;\n  float minComp = min(min(result.r, result.g), result.b);\n  float maxComp = max(max(result.r, result.g), result.b);\n  if (minComp < 0.0 && lum != minComp) {\n    result = lum + (result - lum) * (lum / (lum - minComp));\n  }\n  if (maxComp > alpha && maxComp != lum) {\n    result = lum + ((result - lum) * (alpha - lum) / (maxComp - lum));\n  }\n  return result;\n}\n\nfloat blend_color_saturation(vec3 color) {\n  return max(max(color.r, color.g), color.b) - min(min(color.r, color.g), color.b);\n}\n\nvec3 blend_set_color_saturation(vec3 color, vec3 satColor) {\n  float mn = min(min(color.r, color.g), color.b);\n  float mx = max(max(color.r, color.g), color.b);\n\n  return (mx > mn) ? ((color - mn) * blend_color_saturation(satColor)) / (mx - mn)\n    : vec3(0.0);\n}\n\nvec4 blend_hslc(vec2 flipSat, vec4 src, vec4 dst) {\n  float alpha = dst.a * src.a;\n  vec3 sda = src.rgb * dst.a;\n  vec3 dsa = dst.rgb * src.a;\n  vec3 l = bool(flipSat.x) ? dsa : sda;\n  vec3 r = bool(flipSat.x) ? sda : dsa;\n  if (bool(flipSat.y)) {\n    l = blend_set_color_saturation(l, r);\n    r = dsa;\n  }\n  return vec4(blend_set_color_luminance(l, alpha, r) + dst.rgb - dsa + src.rgb - sda,\n    src.a + dst.a - alpha);\n}\n\nvec4 blend_hue(vec4 src, vec4 dst) {\n  return blend_hslc(vec2(0.0, 1.0), src, dst);\n}\n\nvec4 blend_saturation(vec4 src, vec4 dst) {\n  return blend_hslc(vec2(1.0), src, dst);\n}\n\nvec4 blend_color(vec4 src, vec4 dst) {\n  return blend_hslc(vec2(0.0), src, dst);\n}\n\nvec4 blend_luminosity(vec4 src, vec4 dst) {\n  return blend_hslc(vec2(1.0, 0.0), src, dst);\n}\n\nvec4 blendSkia(int id, vec4 src, vec4 dest) {\n  if (id == 0) return blend_darken(1.0, src, dest);\n  if (id == 1) return blend_multiply(src, dest);\n  if (id == 2) return blend_color_burn(src, dest);\n  if (id == 3) return blend_lighten(src, dest);\n  if (id == 4) return blend_color_dodge(src, dest);\n  if (id == 5) return blend_overlay(src, dest);\n  if (id == 6) return blend_soft_light(src, dest);\n  if (id == 7) return blend_hard_light(src, dest);\n  if (id == 8) return blend_difference(src, dest);\n  if (id == 9) return blend_exclusion(src, dest);\n  if (id == 10) return blend_hue(src, dest);\n  if (id == 11) return blend_color(src, dest);\n  if (id == 12) return blend_saturation(src, dest);\n  if (id == 13) return blend_luminosity(src, dest);\n\n  if (id == 14) return blend_src_over(src, dest);\n  if (id == 15) return blend_src_in(src, dest);\n  if (id == 16) return blend_src_out(src, dest);\n  if (id == 17) return blend_src_atop(src, dest);\n  if (id == 18) return blend_dst_over(src, dest);\n  if (id == 19) return blend_dst_in(src, dest);\n  if (id == 20) return blend_dst_out(src, dest);\n  if (id == 21) return blend_dst_atop(src, dest);\n  if (id == 22) return blend_plus(src, dest);\n  if (id == 23) return src; // this is \"copy\"\n  if (id == 24) return blend_xor(src, dest);\n\n  return vec4(0., 0., 0., 1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord / iResolution.xy;\n\n  int currentBlendMode = int(iMouse.x / 24.0);\n\n  // destination texture (lower layer)\n  vec4 d = texture(iChannel0, uv).rgba;\n\n  // source texture (upper layer)\n  vec4 s = texture(iChannel1, uv).rgba;\n\n  vec4 c;\n\n  s = blendSkia(currentBlendMode, s, d);\n\n  if (currentBlendMode < 14) {\n    c = blend_src_over(s, d);\n  } else {\n    c = s;\n  }\n\n  // Output to screen\n  fragColor = c;\n}\n","name":"Image","description":"","type":"image"}]}