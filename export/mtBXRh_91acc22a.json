{"ver":"0.1","info":{"id":"mtBXRh","date":"1687047151","viewed":72,"name":"Rod Refracted Noise","username":"westgarthb","description":"Emulation of optic refraction through glass rods","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","refraction","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 x )\n{\n    // grid\n    x = x * 1.5;\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n\n    \n    // gradients\n    vec3 ga = hash( p+vec3(0.0,0.0,0.0) );\n    vec3 gb = hash( p+vec3(1.0,0.0,0.0) );\n    vec3 gc = hash( p+vec3(0.0,1.0,0.0) );\n    vec3 gd = hash( p+vec3(1.0,1.0,0.0) );\n    vec3 ge = hash( p+vec3(0.0,0.0,1.0) );\n    vec3 gf = hash( p+vec3(1.0,0.0,1.0) );\n    vec3 gg = hash( p+vec3(0.0,1.0,1.0) );\n    vec3 gh = hash( p+vec3(1.0,1.0,1.0) );\n    \n    // projections\n    float va = dot( ga, w-vec3(0.0,0.0,0.0) );\n    float vb = dot( gb, w-vec3(1.0,0.0,0.0) );\n    float vc = dot( gc, w-vec3(0.0,1.0,0.0) );\n    float vd = dot( gd, w-vec3(1.0,1.0,0.0) );\n    float ve = dot( ge, w-vec3(0.0,0.0,1.0) );\n    float vf = dot( gf, w-vec3(1.0,0.0,1.0) );\n    float vg = dot( gg, w-vec3(0.0,1.0,1.0) );\n    float vh = dot( gh, w-vec3(1.0,1.0,1.0) );\n\t\n    // interpolation\n    return va + \n           u.x*(vb-va) + \n           u.y*(vc-va) + \n           u.z*(ve-va) + \n           u.x*u.y*(va-vb-vc+vd) + \n           u.y*u.z*(va-vc-ve+vg) + \n           u.z*u.x*(va-vb-ve+vf) + \n           u.x*u.y*u.z*(-va+vb+vc-vd+ve-vf-vg+vh);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec3 rd = vec3(0.0, 0.0, -1.0);\n\n    // define  \"glass rods\" and normals\n    float rod_x = fract(p.x * 5.0) * 2.0 - 1.0;\n    float rod_z = sqrt(1.0 - rod_x*rod_x);\n    vec3 n = vec3(rod_x, 0.0, -rod_z);\n    \n    // refracted position extrapolation\n    float refractive_index = 0.4;\n    vec3 refracted_ray = mix(n, rd, refractive_index);\n    float z_dist = 0.4 / (refracted_ray.z + 0.00001);\n    vec3 pos = vec3(p, 0.0) + z_dist*refracted_ray;\n\n    // color lookup\n    vec3 refract_col = 1.0 - mix(vec3(0.0), vec3(1.0), smoothstep(-0.05, 0.0, noise(vec3(pos.xy, iTime*0.2))));\n    //vec3 refract_col = 1.0 - mix(vec3(0.0), vec3(1.0), 0.3+3.3*noise(vec3(pos.xy, iTime*0.2)));\n    \n    // glass shading\n    float g = 1.0 - abs(n.z);\n    g = g * 0.4 / (g * 0.4 - g + 1.0);\n    float glass = (1.0-0.3*g);\n    \n    // composite image\n    vec3 col = vec3(glass) - refract_col;\n    vec3 unrefracted = mix(vec3(0.0), vec3(1.0), smoothstep(-0.05, 0.0, noise(vec3(p, iTime*0.2))));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}