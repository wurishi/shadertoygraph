{"ver":"0.1","info":{"id":"XXS3zz","date":"1708094496","viewed":63,"name":"rough FBM terrain tests","username":"int_45h","description":"basic fBm, based on https://thebookofshaders.com/13/","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define STEPS 200\n#define MIN_DIST .001\n#define MAX_DIST 100.\n#define FOV 60.\n#define f (FOV*PI/180.)\n#define ar iResolution.y/iResolution.x\n\nfloat get_dist(vec3 p)\n{\n    float offset = fbm(p.xz / 4. + vec2(0., iTime));\n    \n    // plane sdf\n    vec3 d = vec3(0.,1.,0.);\n    return dot(normalize(d), p)+5.+offset;\n    \n}\n\n// Taken from https://iquilezles.org/articles/normalsSDF/\nvec3 get_normal(vec3 p)\n{\n    float e = 0.001; // replace by an appropriate value\n    vec2 k = vec2(e,-e);\n    //k = max(k*(length(p)/iResolution.y), e);\n    \n    return normalize( k.xyy*get_dist(p + k.xyy) + \n                      k.yyx*get_dist(p + k.yyx) + \n                      k.yxy*get_dist(p + k.yxy) + \n                      k.xxx*get_dist(p + k.xxx));\n}\n\nvec4 raymarch(vec2 uv)\n{\n    vec3 o = vec3(0.);\n    vec3 d = normalize(vec3(vec2((uv*2.-1.)*vec2(1.,ar)*tan(f*.5)),1.));\n    float t = 0.;\n    float m = MAX_DIST;\n    \n    vec4 col = mix(\n        vec4(190, 241, 250, 0) / 255.99,\n        vec4(35, 46, 99, 0) / 255.99,\n        d.y*3.\n    );\n    \n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 p = o+d*t;\n        float dist = get_dist(p);\n        t += dist;\n        \n        if (t > MAX_DIST)\n            break;\n        \n        if (dist < MIN_DIST)\n        {\n            vec3 n = get_normal(p);\n            vec3 l = vec3(\n                cos(iTime) + 5., \n                5., \n                sin(iTime) + 5.);\n                \n            float a = length(l);\n            a = 10. / (a*a);\n            \n            vec3 k_D = vec3(1., .5, .3)*max(dot(l,n),0.)*a;\n            vec3 k_A = col.xyz / 5.;\n            return vec4(k_D + k_A, 1.);\n        }\n        \n        if (dist < m)\n            m = dist;\n    }\n    \n    m /= 6.;\n    m = sqrt(m);\n    vec4 glow = mix(\n        1.-vec4(1.,0.,0.,1.),\n        1.-vec4(1.,.8,.2,1.),\n        vec4(m)\n    )*max(1.-(m), 0.);\n    \n    return (col / 1.2) + glow;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    /*\n    vec2 uv_prime = vec2(\n        fbm(uv + iTime*.04),\n        fbm(uv + iTime*.02*vec2(1., 1.))\n    );\n    vec4 color = vec4(fbm(uv_prime)*.5+.5);\n    */\n    fragColor = raymarch(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n\n// https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n/*\nuint iqint3(uvec2 x)\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n\n    return n;\n}\n\nfloat hash12(vec2 p)\n{\n    return float(iqint3(uvec2(p))) / float(1103515245U);\n}\n*/\nvec2 rand_direction(vec2 seed)\n{\n    float t = hash12(seed)*2.*PI;\n    return vec2(cos(t), sin(t));\n}\n\nfloat fade(float x)\n{\n    float x_3 = x*x*x;\n    return x_3*(6.*x*x-15.*x+10.); //6t5-15t4+10t3\n}\n\nfloat perlin(vec2 uv)\n{\n    vec2 uv_grid = floor(uv);\n    vec2 uv_cell = fract(uv);\n    \n    vec2 tl = uv_grid + vec2(0., 0.);\n    vec2 tr = uv_grid + vec2(0., 1.);\n    vec2 bl = uv_grid + vec2(1., 0.);\n    vec2 br = uv_grid + vec2(1., 1.);\n    \n    float g0 = dot(rand_direction(tl), uv_cell - vec2(0., 0.));\n    float g1 = dot(rand_direction(tr), uv_cell - vec2(0., 1.));\n    float g2 = dot(rand_direction(bl), uv_cell - vec2(1., 0.));\n    float g3 = dot(rand_direction(br), uv_cell - vec2(1., 1.));\n    \n    uv_cell.x = fade(uv_cell.x);\n    uv_cell.y = fade(uv_cell.y);\n    \n    float noise = mix(\n        mix(g0, g2, uv_cell.x), \n        mix(g1, g3, uv_cell.x),\n        uv_cell.y\n    );\n    \n    return noise;\n}\n\nfloat fbm(vec2 uv)\n{\n    int octaves = 4;\n    float noise = 0.;\n    float amp = 1.;\n    vec2 uv_prime = uv;\n    \n    for (int i = 0; i < octaves; i++)\n    {\n        noise += amp * perlin(uv_prime);\n        amp *= .5;\n        uv_prime *= 2.;\n    }\n    \n    return noise;\n}\n","name":"Common","description":"","type":"common"}]}