{"ver":"0.1","info":{"id":"dscyRf","date":"1695324223","viewed":45,"name":"texture sphere 2","username":"tintingai","description":"test texture sphere 1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["texture"],"hasliked":0,"parentid":"sdScDG","parentname":"texture sphere 1"},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* src:\nhttps://inspirnathan.com/posts/52-shadertoy-tutorial-part-6\n*/\n\nconst float RAYMIN = 0.0;\nconst float RAYMAX = 100.0;\nconst int RAYSTEP = 255;\nconst float PREC_RAY = 0.001; //precision of the ray\n\nconst vec3 BACK_COLOR = vec3(0.5); //should never appear\nconst vec3 LIGHT_POS = vec3(2., 2., 4.);\nconst float GI_SIM = 0.4; //global illumination simulation (between 0. and 1.)\nconst int REC_RAY = 2;\n\n\n\nstruct Material{\n    vec3 color;\n    float transparency;\n};\n\n\nstruct HitRecord{\n    vec3 p;\n    vec3 normal;\n    float dist;\n    Material mat;\n};\n\nHitRecord getHitBackground(vec3 ro, vec3 rd)\n{\n    HitRecord hit;\n    hit.p = ro + RAYMAX * rd * 200.;\n    hit.normal = -rd;\n    //hit.normal = vec3(1.,0.,0.);\n    hit.dist = 0.;\n    Material matBackground;\n    matBackground.color = texture(iChannel1, rd).xyz;\n    matBackground.transparency = 0.;\n    hit.mat = matBackground;\n    return hit;\n}\n\n\n\nfloat cubic_interpolation(float t) {\n  return t*t*t*( t*(t*6.0 - 15.0) + 10.0);\n}\nvec4 color_noise(vec4 p){\n    const float twidth = 10.0;\n    vec4 v = texture(iChannel0, vec3((p.x+p.w)/twidth, (p.y+p.w)/twidth, (p.z+p.w)/twidth) );\n    return normalize( v*2.0 - vec4(1.0) );\n}\nfloat perlin_noise_4D(vec4 p){\n    \n    /*get 8 nearest interger points*/\n    vec4 p0  = floor(p);\n    vec4 p1  = p0 + vec4(1., 0., 0., 0.);\n    vec4 p2  = p0 + vec4(0., 1., 0., 0.);\n    vec4 p3  = p0 + vec4(1., 1., 0., 0.);\n    vec4 p4  = p0 + vec4(0., 0., 1., 0.);\n    vec4 p5  = p0 + vec4(1., 0., 1., 0.);\n    vec4 p6  = p0 + vec4(0., 1., 1., 0.);\n    vec4 p7  = p0 + vec4(1., 1., 1., 0.);\n    \n    vec4 p8  = p0 + vec4(0., 0., 0., 1.);\n    vec4 p9  = p0 + vec4(1., 0., 0., 1.);\n    vec4 p10 = p0 + vec4(0., 1., 0., 1.);\n    vec4 p11 = p0 + vec4(1., 1., 0., 1.);\n    vec4 p12 = p0 + vec4(0., 0., 1., 1.);\n    vec4 p13 = p0 + vec4(1., 0., 1., 1.);\n    vec4 p14 = p0 + vec4(0., 1., 1., 1.);\n    vec4 p15 = p0 + vec4(1., 1., 1., 1.);\n    \n    /*get color of this points*/\n    vec4 cp0  = color_noise(p0);\n    vec4 cp1  = color_noise(p1);\n    vec4 cp2  = color_noise(p2);\n    vec4 cp3  = color_noise(p3);\n    vec4 cp4  = color_noise(p4);\n    vec4 cp5  = color_noise(p5);\n    vec4 cp6  = color_noise(p6);\n    vec4 cp7  = color_noise(p7);\n    \n    vec4 cp8  = color_noise(p8);\n    vec4 cp9  = color_noise(p9);\n    vec4 cp10 = color_noise(p10);\n    vec4 cp11 = color_noise(p11);\n    vec4 cp12 = color_noise(p12);\n    vec4 cp13 = color_noise(p13);\n    vec4 cp14 = color_noise(p14);\n    vec4 cp15 = color_noise(p15);\n        \n    /*compute cubic_interpolation of the decimal part*/\n    vec4 inter;\n    inter.x = cubic_interpolation(p.x-p0.x);\n    inter.y = cubic_interpolation(p.y-p0.y);\n    inter.z = cubic_interpolation(p.z-p0.z);\n    inter.w = cubic_interpolation(p.w-p0.w);\n    \n    /* Calculate dot products and interpolate.*/\n    float p0p1   = (1.0 - inter.x) * dot(cp0, (p - p0)) + inter.x * dot(cp1, (p - p1));\n    float p2p3   = (1.0 - inter.x) * dot(cp2, (p - p2)) + inter.x * dot(cp3, (p - p3));\n    float p4p5   = (1.0 - inter.x) * dot(cp4, (p - p4)) + inter.x * dot(cp5, (p - p5));\n    float p6p7   = (1.0 - inter.x) * dot(cp6, (p - p6)) + inter.x * dot(cp7, (p - p7));\n    \n    float p8p9   = (1.0 - inter.x) * dot(cp8, (p - p8)) + inter.x * dot(cp9, (p - p9));\n    float p10p11 = (1.0 - inter.x) * dot(cp10, (p - p10)) + inter.x * dot(cp11, (p - p11));\n    float p12p13 = (1.0 - inter.x) * dot(cp12, (p - p12)) + inter.x * dot(cp13, (p - p13));\n    float p14p15 = (1.0 - inter.x) * dot(cp14, (p - p14)) + inter.x * dot(cp15, (p - p15));\n    \n    float t1 = (1.0 - inter.y) * p0p1 + inter.y * p2p3;\n    float t2 = (1.0 - inter.y) * p4p5 + inter.y * p6p7;\n    float t3 = (1.0 - inter.y) * p8p9 + inter.y * p10p11;\n    float t4 = (1.0 - inter.y) * p12p13 + inter.y * p14p15;\n    \n    float u1 = (1.0 - inter.z) * t1 + inter.z * t2;\n    float u2 = (1.0 - inter.z) * t3 + inter.z * t4;\n\n    return (1.0 - inter.w) * u1 + inter.w * u2;\n}\n\n\nHitRecord dist_bubble(vec3 p, vec3 center, float r, vec3 color_low, vec3 color_high)\n{\n    float dist_sphere = length(p - center) - r;\n    float dist_altitude = dist_sphere + perlin_noise_4D(vec4(p, iTime*1.)*1.)/2.;\n    //float dist_altitude = dist_sphere;\n    vec3 color_surface = mix(color_low, color_high, dist_sphere * 2. + 0.5);\n    \n    Material mat; mat.color = color_surface; mat.transparency = 0.7;\n    HitRecord hit; hit.p = p; hit.dist = dist_altitude; hit.mat = mat;\n    \n    //return vec4(dist_altitude , color_surface);\n    return hit;\n}\n\n\nHitRecord sdScene(vec3 p)\n{\n    HitRecord hr = dist_bubble(p, vec3(0., 0., -3.), 2., vec3(0., 1., 1.), vec3(1., 0., 1.));\n    //HitRecord hr = dist_bubble(p, vec3(0., 0., -3.), 2., vec3(0.), vec3(0.5));\n    return hr;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).dist +\n      e.yyx * sdScene(p + e.yyx).dist +\n      e.yxy * sdScene(p + e.yxy).dist +\n      e.xxx * sdScene(p + e.xxx).dist );\n}\n\n\nHitRecord traceRay(vec3 ro, vec3 rd)\n{\n    vec3 p;\n    float depth = RAYMIN;\n    HitRecord hit;\n    \n    for(int i=0; i<RAYSTEP; i++)\n    {\n        p = ro + depth*rd;\n        hit = sdScene(p);\n        depth += hit.dist;\n        if(hit.dist < PREC_RAY) {\n            hit.normal = calcNormal(hit.p);\n            return hit;\n        }\n        else if(depth > RAYMAX) return getHitBackground(ro, rd);\n    }\n    return getHitBackground(ro, rd);\n}\n\nHitRecord throwRay(vec3 ro, vec3 rd)\n{\n    int rec=0;\n    HitRecord hitArray[REC_RAY+1];\n    hitArray[rec] = traceRay(ro, rd);\n    \n    for(; rec<REC_RAY; rec++)\n    {\n        HitRecord hit = hitArray[rec];\n        if(hit.mat.transparency == 0.){\n            break;\n        }\n\n        vec3 newRo = hit.p + hit.normal * 0.1;\n        //vec3 newRd = refract( rd, hit.normal, 1.3 );\n        vec3 newRd = reflect( rd, hit.normal );\n        HitRecord hitRefract = traceRay(newRo, newRd);\n        hitArray[rec+1] = hitRefract;\n    } \n    \n    vec3 finalCol = vec3(0.);\n    finalCol = hitArray[rec].mat.color;\n    for(; rec>0; rec--)\n    {\n        finalCol = mix(hitArray[rec-1].mat.color, finalCol, hitArray[rec-1].mat.transparency);\n    }\n    \n    hitArray[0].mat.color = finalCol;\n    return hitArray[0];\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 color_final = BACK_COLOR;\n    \n    //create and throw ray\n    vec3 ro = vec3(0., 0., 5.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n    HitRecord hit = throwRay(ro, rd);\n    //HitRecord hit = traceRay(ro, rd);\n    \n    //get point hit and color \n    vec3 color_obj = hit.mat.color;\n    vec3 pi = ro + distance(ro, hit.p) * rd;\n\n    //compute shadows\n    vec3 lightdir = normalize(LIGHT_POS - pi);\n    float difuse_light = clamp(dot(hit.normal, lightdir), 0., 1.);\n    color_final = mix(color_obj*GI_SIM, color_obj, difuse_light);\n    \n    fragColor = vec4(color_final, 1.);\n    //fragColor = vec4(color_obj, 1.);\n}","name":"Image","description":"","type":"image"}]}