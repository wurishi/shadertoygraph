{"ver":"0.1","info":{"id":"7tdfzS","date":"1663303071","viewed":210,"name":"Bifurcation Diagram Demo","username":"Desdenova","description":"A demo for showing bifurcation diagrams and their Lyapunov Exponents. Change the map on line 23. My favorite is the Gauss Map :)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["bifurcationdiagram"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float scaleColor(float falloff, float col);\n//maps\nvec2 logisticMap(float x, float r);\nvec2 gaussMap(float x, float alpha, float beta);\nvec2 tentMap(float x, float mu);\nvec2 quadraticMap(float x, float c);\nvec2 circleMap(float theta, float omega, float kappa);\nvec2 dyadicTransform(float x, float r);\nvec2 sine(float x, float r);\nvec2 discontinuousLogisticMap(float x, float r, float alpha);\nvec2 sinc(float x, float r, float alpha);\nvec2 collatz(float x, float alpha);\n\nfloat oscillate(vec2 range, float period);\nconst float pi = acos(-1.0);\nconst int numOfMaps = 10; //the number of maps to choose from\n\nconst int maxN = 6000;//1200;\nint threshold = 500; //ignore the first this many iterates\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int map = 0;    //0=logistic, 1=gauss, 2=tent, 3=quadratic\n                    //4=circle, 5=dyadic transform, 6=sine\n                    //7=discontinuous logistic map, 8=sinc, 9=collatz\n    \n    bool showAxes = true;\n    float tickDist = 1.0;\n    bool showLE = true; //overlays Lyapunov Exponent plot\n    bool centerLEplot = false; //centers LE plot in window\n    bool showLEAxis = true; //shows a separate horizontal axis for the overlayed LE plot so you can tell when it's >0 or <0\n    float scaleLE = 5.0; //squishes the LE graph by this factor so it fits on the screen better\n\n        float x; //x0\n    vec2 pRange; //horizontal axis range\n    vec2 xRange; //vertical axis range\n    \n    switch(clamp(map,0,numOfMaps-1)){\n            case 0: //Logistic Map\n                x = 0.5;\n                pRange = vec2(-2.0,4.0);\n                xRange = vec2(-0.5,1.5);\n                \n                //square grid:\n                //pRange = vec2(-2.0,4.0) + 0.0 * 6.0/1920.0;\n                //xRange = vec2(-27.0,81.0)/32.0;\n                \n                //uncomment for zoom-in:\n                /*\n                pRange = vec2(2.5,4.0);\n                xRange = vec2(0.0,1.0);\n                centerLEplot = true;\n                showLEAxis = true;\n                */\n            break;\n            \n            case 1: //Gauss Map (AKA Mouse Map)\n                x = 0.0;\n                scaleLE = 7.0;\n                pRange = vec2(-1.0,1.0);\n                xRange = vec2(-0.4,1.06);\n                /*\n                pRange = vec2(-1.4,0.6);\n                xRange = vec2(-1.4,1.06);\n                */\n            break;\n            \n            case 2: //Tent Map\n                x = 0.5;\n                pRange = vec2(-2.0,2.0);\n                xRange = vec2(-1.0,2.0);\n                scaleLE = 2.0;\n                \n                //uncomment for zoom-in:\n                //pRange = vec2(1.0,2.0);\n                //xRange = vec2(0.0,1.0);\n                \n                //pRange = vec2(1.0,1.2);\n                //xRange = vec2(0.478,0.6);\n            break;\n            \n            case 3: //Quadratic Map\n                x = 0.0;\n                pRange = vec2(-2.0,0.25);\n                xRange = vec2(-2.0,2.0);\n                scaleLE = 1.5;\n                \n            break;\n            case 4: //Circle Map\n                x = 0.5;\n                pRange = vec2(0.0,4.0*pi);//kappa\n                xRange = vec2(0.0,1.0);//theta\n                showAxes = false;\n                scaleLE = 25.0;\n                centerLEplot = true;\n            break;\n            case 5: //Dyadic Transform\n                x = 0.5;\n                pRange = vec2(-1.0/sqrt(2.0),1.0);\n                xRange = vec2(-1.0/sqrt(2.0),1.0);\n            break;\n            case 6: //Sine\n                x = 0.5;\n                pRange = vec2(-2.0,2.0);\n                xRange = vec2(-2.0,2.0);\n            break;\n            case 7: //Discontinuous Logistic Map\n                x = 0.5;\n                pRange = vec2(-2.0,4.0);\n                xRange = vec2(-0.5,1.5);\n                \n                //uncomment for zoom-in:\n                //pRange = vec2(2.5,4.0);\n                //xRange = vec2(0.0,1.0);\n                //centerLEplot = true;\n                //showLEAxis = true;\n            break;\n            case 8: //Sinc\n                scaleLE = 3.0;\n                x = oscillate(vec2(0.0,4.5),10.0);\n                //x = 0.0;\n                pRange = vec2(-0.5,7.0);\n                xRange = vec2(-0.5,7.0);\n                                \n                //xRange = vec2(-2.0,8.0);                \n                //pRange = vec2(pRange.x,pRange.x+abs(xRange.y-xRange.x)*iResolution.x/iResolution.y);\n            break;\n            case 9: //Collatz\n                scaleLE = 3.0;\n                x = 0.0;\n                pRange = vec2(-2.0,2.0);\n                xRange = vec2(-100.0,100.0);\n                \n                pRange = vec2(0.0,10.0);\n                xRange = vec2(0.0,100.0);\n            break;\n            default:\n            x = 0.5;\n            pRange = vec2(-2.0,2.0);\n            xRange = vec2(-2.0,2.0);\n        }\n    /*\n    vec2 pan = vec2(0,0);\n    float gridSize = 2.0;\n    pRange = pRange.x + (pan.x + vec2(0.0, 1.0))*(pRange.y-pRange.x)/gridSize;\n    xRange = xRange.x + (pan.y + vec2(0.0, 1.0))*(xRange.y-xRange.x)/gridSize;\n    */\n\n    // pixel coord\n    vec2 resolution = vec2(pRange.y-pRange.x, xRange.y-xRange.x) / iResolution.xy;\n    vec2 px = vec2(pRange.x,xRange.x) + resolution * fragCoord;\n    \n    if(map == 9)\n        x = px.x;\n    \n    //background color\n    vec3 col = vec3(0);\n    //col = vec3(0.15);  \n    \n    \n    //draw LE plot axes\n    if(showLEAxis && showLE && centerLEplot && abs(px.y - (xRange.x+xRange.y)/2.0) <= resolution.y)\n        col = vec3(0.5,0.8,0.5);\n    \n    /*\n    //draw grid\n    float gridDist = 1.0;\n    if(showAxes && (abs(mod(px.x,gridDist)) <= resolution.x || abs(mod(px.y,gridDist)) <= resolution.y))\n        col = vec3(0.2);\n    */\n    \n    //draw tickmarks\n    if(showAxes &&\n        (abs(mod(px.x,tickDist)) <= resolution.x && abs(px.y) <= 5.0*resolution.y\n      || abs(mod(px.y,tickDist)) <= resolution.y && abs(px.x) <= 5.0*resolution.x))\n        col = vec3(0.5);\n    \n    \n    //draw axes\n    if(showAxes && (abs(px.x) <= resolution.x || abs(px.y) <= resolution.y))\n        col = vec3(0.5);\n    \n    \n    int count = 0;\n    float lambda = 0.0;\n    float maxLambda = pow(10.0,5.0);    \n    vec2 info = vec2(x,0.0);\n    \n    for(int n=0;n<=maxN;n++){\n        switch(clamp(map,0,numOfMaps-1)){\n            case 0:\n                info = logisticMap(info.x,px.x);\n                break;\n            case 1:\n                info = gaussMap(info.x,4.9,px.x);\n                //info = gaussMap(info.x,oscillate(vec2(1.0,20.0),15.0),px.x);\n                break;\n            case 2:\n                info = tentMap(info.x,px.x);\n                break;\n            case 3:\n                info = quadraticMap(info.x,px.x);\n                break;\n            case 4:\n                info = circleMap(info.x,1.0/3.0,px.x);\n                //info = circleMap(info.x,oscillate(vec2(0.1,0.5),15.0),px.x);\n                break;\n            case 5:\n                info = dyadicTransform(info.x,px.x);\n                break;\n            case 6:\n                info = sine(info.x,px.x);\n                break;\n            case 7:\n                info = discontinuousLogisticMap(info.x,px.x,oscillate(vec2(1.0,0.0),10.0));//default alpha is 0.0\n                break;\n            case 8:\n                //info = sinc(info.x,px.x,0.0);//default alpha is 0.0\n                info = sinc(info.x,px.x,oscillate(vec2(0.0,4.5),10.0));//default alpha is 0.0\n            break;\n            case 9:\n                info = collatz(info.x,px.x);\n                break;\n        }\n        \n        if(showLE && n>=threshold)\n            lambda += clamp(  log(abs(info.y))/float(maxN),  -maxLambda,maxLambda);\n                \n        if(abs(px.y - clamp(info.x,xRange.x-1.0,xRange.y+1.0)) < 1.0*resolution.y && n>=threshold)\n            count++;\n    }\n    \n    float normC = float(count-1)/float(maxN-threshold); //normalize the count\n    \n    \n    if(count > 0){\n        //col = vec3(pow(normC,0.2));\n        \n        //col = vec3(1.0-clamp(float(count)/30.0,0.0,1.0));\n        \n        //col = vec3(pow(normC,0.26),pow(1.0-normC,100.0),1.0-pow(normC,0.15));\n        \n        col = vec3( scaleColor(87.33654409999,normC), clamp(normC+(1.0-clamp(float(count)/12.0,0.0,1.0)),0.0,1.0), pow(1.0-normC,50.0) );\n        \n        //col = vec3(1.0-scaleColor(87.33654409999,normC),0.0,0.0);\n        //col = vec3(1.0-clamp(float(count)/10.0,0.0,1.0),0.0,0.0);\n        \n        //col = vec3(1.0- pow(normC,0.26), (1.0-clamp(float(count)/5.0,0.0,1.0)), pow(normC,0.15));\n        /*\n        vec3 colA = vec3(1);\n        vec3 colB = vec3(1,0.15,0.15);\n        vec3 colC = vec3(1,0.5,0);\n        float scaledCount = float(count)/float(maxN);\n        \n        if(scaledCount <= 0.5)\n            col = colA + (colB-colA)*2.0*scaledCount;\n        else\n            col = colB + (colC-colB)*(2.0*scaledCount-1.0);\n        */\n    }\n    \n    if(showLE)\n        if(centerLEplot){                \n            if(abs((px.y - (xRange.x+xRange.y)/2.0 ) - lambda/scaleLE) < resolution.y)\n                col = vec3(0.0,1.0,0.0);\n        }\n        else if(abs(px.y - lambda/scaleLE) < resolution.y)\n            col = vec3(0.0,1.0,0.0);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nfloat scaleColor(float falloff, float col){\n    if(falloff == 0.0)\n        return col;\n    else\n        return 1.0-(1.0-exp(falloff*(1.0-col)))/(1.0-exp(falloff));\n}\n\nvec2 logisticMap(float x, float r){\n    x = r*x*(1.0-x);\n    float dx = r*(1.0-2.0*x);\n    return vec2(x,dx);\n}\n\n//as seen in the paper \"Chaos in Maps with Continuous and Discontinuous Maxima\":\nvec2 discontinuousLogisticMap(float x, float r, float alpha){\n    if(x > 0.5)\n        x = r*x*(1.0-x);\n    else\n        x = r*x*(1.0-x) + 0.25*(alpha-1.0)*(r-2.0);\n    float dx = r*(1.0-2.0*x);\n    return vec2(x,dx);\n}\n\nvec2 gaussMap(float x, float alpha, float beta){\n    x = exp(-alpha*x*x) + beta;\n    float dx = -2.0*x*alpha*exp(-alpha*x*x);\n    return vec2(x,dx);\n}\n\nvec2 tentMap(float x, float mu){\n    x = mu*min(x,1.0-x);\n    float dx;\n    if(x<0.5)\n        dx = mu;\n    else\n        dx = -mu;       \n    \n    return vec2(x,dx);\n}\n\nvec2 quadraticMap(float x, float c){\n    x = x*x+c;\n    float dx = 2.0*x;\n    return vec2(x,dx);\n}\n\nvec2 circleMap(float theta, float omega, float kappa){\n    theta = mod(theta + omega - kappa*sin(2.0*pi*theta)/(2.0*pi),1.0);\n    float dtheta = 1.0-kappa*cos(2.0*pi*theta);\n    return vec2(theta,dtheta);\n}\n/*\nfloat dyadicTransform(float x, float r){\n    float dx;\n    if(x >= 0.0 && x <= 0.5){\n        x = r*2.0*x;\n        dx = 2.0*r;\n    }\n    else if(x > 0.5 && x < 1.0){\n        x = r*(2.0*x-1.0);\n        dx = 2.0*r;\n    }\n    else{\n        x = 0.0;\n        dx = 0.0;\n    }\n    return vec2(x,dx);\n}\n*/\nvec2 dyadicTransform(float x, float r){\n    float dx;\n    if(x <= 0.5){\n        x = r*2.0*x;\n        dx = 2.0*r;\n    }\n    else{\n        x = r*(2.0*x-1.0);\n        dx = 2.0*r;\n    }\n    return vec2(x,dx);\n}\n\nvec2 sine(float x, float r){\n    x = r*sin(pi*x);\n    float dx = r*pi*cos(pi*x);\n    return vec2(x,dx);\n}\n\nvec2 sinc(float x, float r, float alpha){\n    float dx = 0.0;\n    if(x-alpha == 0.0)\n        x = r;\n    else{\n        x = r*sin(pi*(x-alpha))/(pi*(x-alpha));\n        dx = r*(  cos(pi*(x-alpha))/(x-alpha) - sin(pi*(x-alpha))/(pi*pow(x-alpha,2.0))  );\n    }\n    return vec2(x,dx);\n}\n\nvec2 collatz(float x, float alpha){\n    x = (2.0 + 7.0*x - (2.0 + 5.0*x)*cos(pi*x))/4.0;\n    float dx = (7.0 - 5.0*cos(pi*x) + pi*(2.0+5.0*x)*sin(pi*x))/4.0;\n    return vec2(x,dx);\n}\n\nfloat oscillate(vec2 range, float period){\n    return (range.y+range.x - (range.y-range.x)*cos(pi*iTime/period))/2.0;\n}","name":"Image","description":"","type":"image"}]}