{"ver":"0.1","info":{"id":"XdlfR4","date":"1495062584","viewed":135,"name":"HSLUV test","username":"heisters","description":"test HSLUV rainbow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nHSLUV-GLSL v4.1\nHSLUV is a human-friendly alternative to HSL. ( http://www.hsluv.org )\nGLSL port by William Malo ( https://github.com/williammalo )\nPut this code in your fragment shader.\n*/\n\nvec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {\n    return (line1y - line2y) / (line2x - line1x);\n}\n\nvec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {\n    return sqrt(pointx*pointx + pointy*pointy);\n}\n\nvec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {\n    vec3 len = y / (sin(theta) - x * cos(theta));\n    if (len.r < 0.0) {len.r=1000.0;}\n    if (len.g < 0.0) {len.g=1000.0;}\n    if (len.b < 0.0) {len.b=1000.0;}\n    return len;\n}\n\nfloat hsluv_maxSafeChromaForL(float L){\n    mat3 m2 = mat3(\n        vec3( 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609),\n        vec3(-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ),\n        vec3(-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  )\n    );\n    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bounds0x = top1 / bottom;\n    vec3 bounds0y = top2 / bottom;\n\n    vec3 bounds1x =              top1 / (bottom+126452.0);\n    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );\n    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );\n\n    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );\n    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_maxChromaForLH(float L, float H) {\n\n    float hrad = radians(H);\n\n    mat3 m2 = mat3(\n        vec3( 3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609),\n        vec3(-1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ),\n        vec3(-0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  )\n    );\n    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;\n    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;\n\n    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;\n    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;\n    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;\n\n    vec3 bound0x = top1 / bottom;\n    vec3 bound0y = top2 / bottom;\n\n    vec3 bound1x =              top1 / (bottom+126452.0);\n    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);\n\n    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );\n    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );\n\n    return  min(lengths0.r,\n            min(lengths1.r,\n            min(lengths0.g,\n            min(lengths1.g,\n            min(lengths0.b,\n                lengths1.b)))));\n}\n\nfloat hsluv_fromLinear(float c) {\n    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\n\nfloat hsluv_toLinear(float c) {\n    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;\n}\n\nvec3 hsluv_toLinear(vec3 c) {\n    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );\n}\n\nfloat hsluv_yToL(float Y){\n    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;\n}\n\nfloat hsluv_lToY(float L) {\n    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);\n}\n\nvec3 xyzToRgb(vec3 tuple) {\n    return vec3(\n        hsluv_fromLinear(dot(vec3( 3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ), tuple.rgb )),//r\n        hsluv_fromLinear(dot(vec3(-0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613), tuple.rgb )),//g\n        hsluv_fromLinear(dot(vec3( 0.055630079696993609,-0.20397695888897657, 1.0569715142428786  ), tuple.rgb )) //b\n    );\n}\n\nvec3 rgbToXyz(vec3 tuple) {\n    vec3 rgbl = hsluv_toLinear(tuple);\n    return vec3(\n        dot(vec3(0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ), rgbl ),//x\n        dot(vec3(0.21263900587151036 , 0.71516867876775593, 0.072192315360733715), rgbl ),//y\n        dot(vec3(0.019330818715591851, 0.11919477979462599, 0.95053215224966058 ), rgbl ) //z\n    );\n}\n\nvec3 xyzToLuv(vec3 tuple){\n    float X = tuple.x;\n    float Y = tuple.y;\n    float Z = tuple.z;\n\n    float L = hsluv_yToL(Y);\n\n    return vec3(\n        L,\n        13.0 * L * ( (4.0 * X) / (X + (15.0 * Y) + (3.0 * Z)) - 0.19783000664283681),\n        13.0 * L * ( (9.0 * Y) / (X + (15.0 * Y) + (3.0 * Z)) - 0.468319994938791  )\n    );\n}\n\nvec3 luvToXyz(vec3 tuple) {\n    float L = tuple.x;\n\n    float varU = tuple.y / (13.0 * L) + 0.19783000664283681;\n    float varV = tuple.z / (13.0 * L) + 0.468319994938791;\n\n    float Y = hsluv_lToY(L);\n    float X = 0.0 - (9.0 * Y * varU) / ((varU - 4.0) * varV - varU * varV);\n    float Z = (9.0 * Y - (15.0 * varV * Y) - (varV * X)) / (3.0 * varV);\n\n    return vec3(X, Y, Z);\n}\n\nvec3 luvToLch(vec3 tuple) {\n    float L = tuple.x;\n    float U = tuple.y;\n    float V = tuple.z;\n\n    float C = sqrt(pow(U, 2.0) + pow(V, 2.0));\n    float H = degrees(atan(V, U));\n    if (H < 0.0) {\n        H = 360.0 + H;\n    }\n    \n    return vec3(L, C, H);\n}\n\nvec3 lchToLuv(vec3 tuple) {\n    float hrad = radians(tuple.b);\n    return vec3(\n        tuple.r,\n        cos(hrad) * tuple.g,\n        sin(hrad) * tuple.g\n    );\n}\n\nvec3 hsluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * 100.0;\n    return tuple.bgr;\n}\n\nvec3 hsluvToLchFIXED(vec3 tuple) {\n    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) / 100.0;\n    return tuple.bgr;\n}\n\nvec3 lchToHsluv(vec3 tuple) {\n    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * 100.0;\n    return tuple.bgr;\n}\n\nvec3 lchToHsluvFIXED(vec3 tuple) {\n    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) / 100.0;\n    return tuple.bgr;\n}\n\nvec3 hpluvToLch(vec3 tuple) {\n    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * 100.0;\n    return tuple.bgr;\n}\n\nvec3 lchToHpluv(vec3 tuple) {\n    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * 100.0;\n    return tuple.bgr;\n}\n\nvec3 lchToRgb(vec3 tuple) {\n    return xyzToRgb(luvToXyz(lchToLuv(tuple)));\n}\n\nvec3 rgbToLch(vec3 tuple) {\n    return luvToLch(xyzToLuv(rgbToXyz(tuple)));\n}\n\nvec3 hsluvToRgb(vec3 tuple) {\n    return lchToRgb(hsluvToLch(tuple));\n}\n\nvec3 hsluvToRgbFIXED(vec3 tuple) {\n    return lchToRgb(hsluvToLchFIXED(tuple));\n}\n\nvec3 rgbToHsluv(vec3 tuple) {\n    return lchToHsluv(rgbToLch(tuple));\n}\n\nvec3 rgbToHsluvFIXED(vec3 tuple) {\n    return lchToHsluvFIXED(rgbToLch(tuple));\n}\n\nvec3 hpluvToRgb(vec3 tuple) {\n    return lchToRgb(hpluvToLch(tuple));\n}\n\nvec3 rgbToHpluv(vec3 tuple) {\n    return lchToHpluv(rgbToLch(tuple));\n}\n\nvec3 luvToRgb(vec3 tuple){\n    return xyzToRgb(luvToXyz(tuple));\n}\n\n\n/*\nEND HSLUV-GLSL\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 scale = vec3( 360., 100., 100. );\n    vec3 c = vec3( uv.y, 0.9, 0.6 ) * scale;\n    \n    // test drawing all hues -- FAILS\n    if ( uv.x < 0.25 ) {\n        fragColor = vec4( hsluvToRgb( c ), 1. );\n    }\n    \n    // test drawing all hues -- PASSES\n    else if ( uv.x < 0.5 ) {\n        fragColor = vec4( hsluvToRgbFIXED( c ), 1. );\n    }\n    \n    // test drawing all hues, with roundtrip through HSLuv -- FAILS\n    else if ( uv.x < 0.75 ) {\n        fragColor = vec4( hsluvToRgb( rgbToHsluv( hsluvToRgb( c ) ) ), 1. );\n    }\n    \n    // test drawing all hues, with roundtrip through HSLuv -- PASSES\n    else {\n        fragColor = vec4( hsluvToRgbFIXED( rgbToHsluvFIXED( hsluvToRgbFIXED( c ) ) ), 1. );\n    }\n}","name":"Image","description":"","type":"image"}]}