{"ver":"0.1","info":{"id":"ddBGDm","date":"1667680644","viewed":205,"name":"SDF wavey noise","username":"antovsky","description":"Gradient-ish noise but trying to be a real sdf (it isn't cause of smoothmin, but maybe with more work...)","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["noise","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// can use any hash function, but this works well enough\nfloat hash( in vec2 p )  \n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat sdCircle(in vec2 pos, float rad) {\n\treturn length(pos) - rad;\n}\n\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nvec3 field(vec2 pos_in_world) {\n    // scale of the starfield\n    float s = 8.0;\n    pos_in_world*=s;\n    \n    float d_ret = 10000.0; // any huge number\n    vec3 col_ret = vec3(1.0);\n    \n    const int r = 2;\n    for (int x = -r; x <= +r; ++x)\n    for (int y = -r; y <= +r; ++y) {\n        vec2 c = fract((pos_in_world+vec2(x,y)));\n        vec2 i = floor((pos_in_world+vec2(x,y)));\n        vec2 j = vec2(hash(i),hash(i+vec2(7.0,13.0)))*2.0 - 1.0;\n        const float jitter_amount = 0.5; // how jittery the stars are\n        vec2 star_in_world = (i+0.5+j*jitter_amount);\n        \n        vec2 pos_in_shape = pos_in_world-star_in_world;\n        float shape_size = mix(0.1,0.3,hash(i));\n        \n        // signed distance field of star shape\n        // you can use anything from:\n        // https://iquilezles.org/articles/distfunctions2d\n        \n        float d = sdCircle(pos_in_shape, shape_size);\n        //float d = sdStar5(pos_in_shape, shape_size, shape_size*2.0);\n        \n        //d_ret = d;\n        d_ret = sminCubic(d, d_ret, 1.25);\n    }\n    vec2 i = floor((pos_in_world));\n    //col_ret = vec3(d_ret > 0.0 ? 1.0 : 0.0);\n    col_ret = vec3(fract(d_ret*10.5));\n    if (d_ret < 0.0)\n        col_ret *= vec3(0.6,0.6,1);\n    // uncomment this to see the underlying jitter grid\n    //col_ret += vec3((int(i.x)^int(i.y))&1)*0.25;\n    \n    return col_ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n\n    // Evaluate star field\n    vec3 col = field(uv);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}