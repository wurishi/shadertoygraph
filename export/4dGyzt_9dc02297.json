{"ver":"0.1","info":{"id":"4dGyzt","date":"1523031219","viewed":463,"name":"Spiny poly","username":"Michael_Manning","description":"The shimmer effect is by Pr0fed https://www.shadertoy.com/view/XdyyRK .\n\nUnlike my last shader, this uses just 1 shape per layer for the drop shadow. The color is based on the shape layer number.  I couldn't get anti aliasing to work because of this.","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["noise","rotation","polygon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Time simplification and easier overall speed control.\n#define speed 0.6\n#define scaleCo 0.25\n#define rotation 1.4\n#define angleOffset 0.0\n#define intensity 2.1\n#define polygonSides 5\n#define staticShadows true\n//the result of the offset it affected by the speed\n#define outerOffset 1.5 \n\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n\n//controlls the transition state from static to warped shadows\nint shadowToggle = 1;\n\n//delays the shimmer effect in time between polygon layers to create contrast\nfloat timeOffset = 0.0;\n\n//the polygon being worked on (0 - 20)\nfloat shapeI = 0.0;\n\n\n//Most of the shimmer pattern code is by Pr0fed https://www.shadertoy.com/view/XdyyRK\nconst mat2 m = mat2( 1.40,  1.00, -1.00,  1.40 );\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    return smoothstep(0.0, 1.35, -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y))));\n}\n\n// 2D gradient noise\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    } \n    return 1.0 - dis;\n}\n\n// Four octave worley FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * worley2D( p ); p = p * 2. * m;\n    f += 0.2500 * worley2D( p ); p = p * 2. * m;\n    f += 0.1250 * worley2D( p ); p = p * 2. * m;\n    f += 0.0625 * worley2D( p );\n    return f;\n}\n\n// Six octave perlin FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.250000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.125000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.062500 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.031250 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.015625 * (0.5 + 0.5 * noise2D( p ));\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron, out vec2 rk)\n{\n    // First layer.\n    vec2 o = vec2(fbm4(q + fbm6( vec2(2.0 * q + vec2(6.)))));\n\n    // Second layer.\n    vec2 n = vec2(fbm6(q + fbm4( vec2(2.0 * o + vec2(2.)))));\n    \n    //The shimmer transition is controlled by white circles that expand outwards   \n    vec2 k  = vec2( 0.55* sin(1.0 * (length(q) + 1.9* -(iTime - shapeI * 0.7)) + 1.0));\n    \n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 6.0 * n + 8.0 * k ;\n    float f = 0.5 + 0.5 * fbm6( p ) ;\n\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    f *= 1.0 - 0.55 * pow( f, 8.0 );\n    \n\tron = vec4( o, n );\n    \n    rk = vec2(k);\n\n    return f;\n}\n\n// I made this, monochrome, but the original settings are still the best \nfloat GetShimmer(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    vec2 k = vec2(0.0);\n    \n    float f = GetFBM(p, on, k);\n    \n    vec3 col = vec3(0.0);\n    \n    // Our 'background' bluish color.\n    col = mix( vec3(1.0), vec3(0.0), f );\n    \n    // Dark orange front layer.\n    col = mix( col, vec3( 0.0), dot(on.xy, on.zw));\n    \n    \n   \n    col = (col * col * 7. * 0.4545);\n    return col.x;\n}\n\n//from thebookofshaders.com/07/\nfloat polygon (vec2 st, float radius, int sides , float angle, float blur) {\n    \n      // Angle and radius from the current pixel\n      float a = atan(st.x,st.y)+PI;\n      float r = TWOPI/float(sides);\n\n      // Shaping function that modulate the distance\n      float d = cos(floor(.5+a/r)*r-a)*length(st);\n      float temp = 1.0-smoothstep(radius, radius + blur ,d);\n      //temp +=  1.0-smoothstep(radius, radius - blur ,d);\n      return (temp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\t\n\tvec2 twistedUV;   \n\tvec3 pixel;\n    \n    float warpedTerm = length(uv) * -cos(speed * (iTime - outerOffset)) * intensity;\n    float originalAngle = PI * rotation * sin(speed * iTime) + warpedTerm;\n \t\n    //using the warped term instead makes a different effect\n    if(originalAngle < 0.1){\n        if(shadowToggle == 1){\n        shadowToggle = 0;\n        }\n        else{\n            shadowToggle = 1;\n        }\n    }\n    \n    //finds the polygon being worked on and stores it in shapeI\n    //this is faster because it avoides calculating the shimmer 20 times\n    for(float j = 20.0; j > 0.0; j-= 1.0)\n    {    \n        float scale = (j * scaleCo);\n        float angle = originalAngle+  angleOffset * j;\n        twistedUV.x =   cos(angle)*uv.x + sin(angle)*uv.y;\n\t\ttwistedUV.y = - sin(angle)*uv.x + cos(angle)*uv.y;\n       // twistedUV = uv;\n        \n        //updates shapeI too find the smallest polgon the pixel might be in\n        if(polygon(twistedUV, 0.4 * scale, polygonSides, 0.0, 0.065) > 0.0){\n            shapeI = j;\n        }\n    }  \n    \n    //The angle and twisted UVs need to be calculated one extra time now that we know the shapeI value\n    float angle = originalAngle + angleOffset * shapeI;\n    float scale = (shapeI * scaleCo);\n    vec3 changingColor =0.7 + 0.5*cos(2.0*iTime+  (12.0-shapeI) * 0.4 +vec3(0,2,4));     \n    twistedUV.x =   cos(angle)*uv.x + sin(angle)*uv.y;\n    twistedUV.y = - sin(angle)*uv.x + cos(angle)*uv.y;\n\t\n    //Using another UV variable to toggle the static shadow effect\n    vec2 shadowUV = (staticShadows && shadowToggle == 1) ? uv : twistedUV;\n  \n    float shimmer = GetShimmer(shadowUV * 3.0); //3.0 is the shimmer effect scale\n    \n    //gets the polygon pixel again which is basically just the shadow value\n    float t = polygon(shadowUV, (0.40 - 0.055/scale) * scale, polygonSides, 0.0, 0.13);\t\n\tpixel =changingColor -(sqrt(20.0 * shapeI) *0.03);\n\t\n    if(shapeI != 1.0){\n        pixel = mix(pixel, vec3(0.004), t );        \n    }\n  //  pixel = pow(pixel, vec3(1.0/1.01));\n    //don't want the shimmer to apear ontop of shadow pixels\n    shimmer *= -t + 1.0;\n    pixel+=0.1;\n    pixel = (pixel+ 0.4 *(shimmer));\n    fragColor = vec4(pixel, 1.0);\n}","name":"Image","description":"","type":"image"}]}