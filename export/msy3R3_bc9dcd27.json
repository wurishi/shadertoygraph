{"ver":"0.1","info":{"id":"msy3R3","date":"1678866839","viewed":113,"name":"GPT4 test","username":"joekr07","description":"GPT4 generated","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["gpt4"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n// Rotation functions\nmat3 rotationX(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c, s,\n        0.0, -s, c\n    );\n}\n\nmat3 rotationY(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n}\n\n// Ray-sphere intersection\nbool intersectSphere(vec3 rayOrigin, vec3 rayDirection, vec3 sphereCenter, float sphereRadius, out float distance) {\n    vec3 oc = rayOrigin - sphereCenter;\n    float b = dot(oc, rayDirection);\n    float c = dot(oc, oc) - sphereRadius * sphereRadius;\n    float h = b * b - c;\n    \n    if (h < 0.0) {\n        return false;\n    }\n    \n    distance = -b - sqrt(h);\n    return true;\n}\n\n// Ray-box intersection\nbool intersectBox(vec3 rayOrigin, vec3 rayDirection, vec3 boxMin, vec3 boxMax, out float distance) {\n    vec3 tMin = (boxMin - rayOrigin) / rayDirection;\n    vec3 tMax = (boxMax - rayOrigin) / rayDirection;\n    vec3 t1 = min(tMin, tMax);\n    vec3 t2 = max(tMin, tMax);\n    float tNear = max(max(t1.x, t1.y), t1.z);\n    float tFar = min(min(t2.x, t2.y), t2.z);\n    distance = tNear;\n    return tNear <= tFar && tFar >= 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -3.0);\n    vec3 rayDirection = normalize(vec3(uv, 1.0));\n\n    // Box and sphere parameters\n    vec3 boxMin = vec3(-0.5);\n    vec3 boxMax = vec3(0.5);\n    vec3 sphereCenter = vec3(1.0, 0.0, 0.0);\n    float sphereRadius = 0.3;\n\n    // Rotate the sphere\n    float angle = iTime;\n    mat3 rot = rotationY(angle) * rotationX(angle * 0.5);\n    sphereCenter = rot * sphereCenter;\n\n    float boxDist, sphereDist;\n    bool hitBox = intersectBox(rayOrigin, rayDirection, boxMin, boxMax, boxDist);\n    bool hitSphere = intersectSphere(rayOrigin, rayDirection, sphereCenter, sphereRadius, sphereDist);\n\n    vec3 color;\n\n    if (hitBox || hitSphere) {\n        if (hitSphere && (!hitBox || sphereDist < boxDist)) {\n            vec3 hitPoint = rayOrigin + rayDirection * sphereDist;\n            vec3 normal = normalize(hitPoint - sphereCenter);\n            color = 0.5 * normal + 0.5;\n        } else {\n            vec3 hitPoint = rayOrigin + rayDirection * boxDist;\n            vec3 normal = vec3(0.0);\n\n            if (hitPoint.x < boxMin.x + 0.01) normal = vec3(-1.0, 0.0, 0.0);\n            else if (hitPoint.x > boxMax.x - 0.01) normal = vec3(1.0, 0.0, 0.0);\n            else if (hitPoint.y < boxMin.y + 0.01) normal = vec3(0.0, -1.0, 0.0);\n            else if (hitPoint.y > boxMax.y - 0.01) normal = vec3(0.0, 1.0, 0.0);\n            else if (hitPoint.z < boxMin.z + 0.01) normal = vec3(0.0, 0.0, -1.0);\n            else if (hitPoint.z > boxMax.z - 0.01) normal = vec3(0.0, 0.0, 1.0);\n\n            color = 0.5 * (1.0 + sin(iTime * 2.0 + hitPoint));\n        }\n    } else {\n        color = vec3(0.1, 0.1, 0.1);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}