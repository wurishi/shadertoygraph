{"ver":"0.1","info":{"id":"MfdfWf","date":"1733592830","viewed":90,"name":"bnjhnjfvndc","username":"TestCoder","description":"dsjfjdsnf","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["dsfjsdnf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Function to generate pseudo-random noise\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// Smooth noise using interpolation\nfloat smoothNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    float a = noise(i);\n    float b = noise(i + vec2(1.0, 0.0));\n    float c = noise(i + vec2(0.0, 1.0));\n    float d = noise(i + vec2(1.0, 1.0));\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\n// Generate fractal Brownian motion noise\nfloat fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    for (int i = 0; i < 5; i++) {\n        value += amplitude * smoothNoise(p * frequency);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n    }\n    return value;\n}\n\n// Main fragment shader\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Center UV coordinates and add a swirl effect\n    vec2 p = uv - 0.5;\n    float t = iTime * 0.05;\n    float angle = fbm(p * 2.0 + t) * 6.28318;\n    float radius = length(p);\n    p = vec2(\n        cos(angle) * p.x - sin(angle) * p.y,\n        sin(angle) * p.x + cos(angle) * p.y\n    );\n\n    // Create a swirling effect with FBM noise\n    float liquidPattern = fbm(p * 4.0 + t);\n\n    // Combine noise and texture sample\n    vec2 texCoord = uv / -liquidPattern * 0.02;\n    texCoord.y = 1.0 - texCoord.y; // Flip Y-coordinate for proper texture mapping\n    vec4 textureColor = texture(iChannel0, texCoord);\n\n    // Modulate texture with swirling noise\n    float colorModulation = 0.5 + 0.5 * sin(liquidPattern * 10.0 + t);\n    fragColor = vec4(textureColor.rgb * colorModulation, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}