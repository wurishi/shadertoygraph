{"ver":"0.1","info":{"id":"XtfXDj","date":"1439594718","viewed":210,"name":"disco cubes","username":"fgsfds","description":"a simple raymarching thing.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cube"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"float dist_box(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b; // a box\n  return min(max(d.x, max(d.y, d.z)), 0.0) +\n         length(max(d, 0.0));\n}\n\nvec3 op_repeat(vec3 p, vec3 dp) {\n  return mod(p, dp) - 0.5*dp; // repeat endlessly at distance dp from p\n}\n \nvec3 map(in vec3 at) {\n  // put all your surfaces in ret\n  vec3 ret = vec3(dist_box(op_repeat(at+vec3(0.25, 0, 0), vec3(1.1)), vec3(0.25)), 533.0, 0.25);\n  return ret;\n}\n\nvec3 ray(in vec3 ro, in vec3 rd) {\n  float tmin = 0.01;\n  float tmax = 20.0;\n  float precis = 0.001;\n  float t = tmin;\n  float m = -1.0;\n  float z = 0.0;\n  for(int i = 0; i < 90; i++) {\n    vec3 res = map(ro + rd*t);\n    if (res.x < precis || t > tmax) break;\n    t += res.x;\n    m = res.y;\n    z = res.z;\n  }\n  if (t > tmax) m = -1.0;\n  return vec3(t, m, z);\n}\n \nvec3 get_n(in vec3 pos) {\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  vec3 nor = vec3(\n    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n    map(pos+eps.yyx).x - map(pos-eps.yyx).x\n  );\n  return normalize(nor); // normal (low precision) to map at point pos\n}\n\nvec3 get_color(in vec3 pos, float h) {\n    // put some cool texture generating shit here\n    vec3 col = 0.5*vec3(sin(iTime), cos(iTime), sin(iTime)*cos(iTime)) + \n               0.5*vec3(sin(pos.x), cos(pos.y), sin(pos.z)*cos(pos.x));\n    return col;\n}\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 dcol = vec3(0.0);\n    float kr = 1.0; // current reflectance\n    // when this becomes lower than a visible threshold, abort tracing\n    // otherwise trace rays and reflect them off of shit\n    for (int i = 0; i < 8; ++i) {\n    \tvec3 res = ray(ro, rd); // x = distance, y = diffuse, z = reflectance\n    \tfloat d = res.x;\n    \tfloat h = res.y;\n    \tfloat r = res.z;\n        vec3 col = vec3(0.8, 0.9, 1.0);\n        vec3 pos = ro + d*rd;\n        vec3 n = get_n(pos);\n        vec3 rrd = reflect(rd, n);\n    \tif (h > -0.5) {\n\t\t    // intersection with something that isn't sky\n            vec3 ld = normalize(vec3(-0.6, 0.7, -0.5));\n            float diffuse = clamp(dot(n, ld), 0.0, 1.0);\n            float spec = pow(clamp(dot(rrd, ld), 0.0, 1.0), 16.0);\n            float brdf = (0.1 + diffuse + spec);\n            col = get_color(pos, h);\n            col *= brdf;\n        }\n        dcol += kr * (1.0 - r)*col;\n        kr *= r;\n        if (kr < 0.001) break;\n        rd = rrd;\n        ro = pos;\n    }\n    return vec3(clamp(dcol, 0.0, 1.0));\n}\n \nmat3 cam_set(in vec3 ro, in vec3 ta, float cr) {\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize(cross(cw, cp));\n  vec3 cv = normalize(cross(cu, cw));\n  return mat3(cu, cv, cw);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord.xy / iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x / iResolution.y;\n  vec2 mo = iMouse.xy / iResolution.xy;    \n  vec3 ta = vec3(-0.5, -0.4, 0.5);\n   \n  vec3 ro = vec3(0, 0, -iTime);\n  mat3 cm = cam_set(ro, ta, iTime*0.0314);\n  vec3 rd = cm * normalize(vec3(p.xy, 2.5));\n   \n  vec3 col = render(ro, rd);\n       col = pow(col, vec3(0.4545));\n  fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}