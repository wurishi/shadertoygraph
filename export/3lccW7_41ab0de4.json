{"ver":"0.1","info":{"id":"3lccW7","date":"1609289025","viewed":127,"name":"the more you know (vlllll)","username":"valalalalala","description":"Follows mouse drag. \nYou can turn down the number or particles in the \"Common\" tab.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["particle","persistence"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"the more you know\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// Learning how to use a buffer for persistence. The persistence is managed \n// in \"Buffer A\". The particle code is in \"Common\" along with some utility\n// functions and scene definitions.\n//\n/////////////////////////////////////////////////////////////////////////////\n\nvec3 colorClosestParticle( vec2 closest ) {\n    float age = closest.y;  \n    float c = distanceToShape( closest.x, .11 * age + .0 );\n    return vec3( c * age, c * abs(.5-age)*2., c * (1.-age) );    \n}\n\nvec3 lessParticular( in vec2 fragCoord ) {\n    return vec3( .0 );\n}\n\nvec2 getClosest( int i, vec2 uv, vec2 closest ) {\n    ivec2 st = fromIndex( i, iResolution );\n    vec4 particle = texelFetch( iChannel0, st, 0 );\n    \n    vec2 ad = abs( uv - particle.xy );\n    float q = ad.x + ad.y  - .001;\n\n    return ( q < closest.x ) ? vec2( q, ageOfParticle( particle ) ) : closest;\n}\n\nvec3 drawParticles( in vec2 fragCoord ) {\n    vec2 uv = rezzo( fragCoord, iResolution ); \n    vec2 closest = vec2( 1e33, 1e33 );\n    vec3 background = vec3( .0 );\n    \n    // curious if unrolling the loop will help performance...\n    // still slow...\n    for ( int i = 0 ; i < COUNT ; i += 33 ) {\n        closest = getClosest( i + 0, uv, closest );\n        closest = getClosest( i + 1, uv, closest );\n        closest = getClosest( i + 2, uv, closest );\n        closest = getClosest( i + 3, uv, closest );\n        closest = getClosest( i + 4, uv, closest );\n        closest = getClosest( i + 5, uv, closest );\n        closest = getClosest( i + 6, uv, closest );\n        closest = getClosest( i + 7, uv, closest );\n        closest = getClosest( i + 8, uv, closest );\n        closest = getClosest( i + 9, uv, closest );\n        closest = getClosest( i + 10, uv, closest );\n        closest = getClosest( i + 11, uv, closest );\n        closest = getClosest( i + 12, uv, closest );\n        closest = getClosest( i + 13, uv, closest );\n        closest = getClosest( i + 14, uv, closest );\n        closest = getClosest( i + 15, uv, closest );\n        closest = getClosest( i + 16, uv, closest );\n        closest = getClosest( i + 17, uv, closest );\n        closest = getClosest( i + 18, uv, closest );\n        closest = getClosest( i + 19, uv, closest );\n        closest = getClosest( i + 20, uv, closest );\n        closest = getClosest( i + 21, uv, closest );\n        closest = getClosest( i + 22, uv, closest );\n        closest = getClosest( i + 23, uv, closest );\n        closest = getClosest( i + 24, uv, closest );\n        closest = getClosest( i + 25, uv, closest );\n        closest = getClosest( i + 26, uv, closest );\n        closest = getClosest( i + 27, uv, closest );\n        closest = getClosest( i + 28, uv, closest );\n        closest = getClosest( i + 29, uv, closest );\n        closest = getClosest( i + 30, uv, closest );\n        closest = getClosest( i + 31, uv, closest );\n        closest = getClosest( i + 32, uv, closest );\n    }\n    \n    float age = closest.y;  \n    return age <  1e-33 ? background : colorClosestParticle( closest ) ;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = vec4( drawParticles( fragCoord ), 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"the more you know\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// This is the buffer where the particle state is maintained. I guess\n// if you need more than 4 floats to represent state need some additional\n// offset tricks.\n//\n/////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n#if 0\n    fragColor = vec4( .0 ); \n#else\n    ivec2 st = toIVec( fragCoord );\n    if ( COUNT <= toIndex( st, iResolution ) ) discard;\n    \n    vec4 particle = texelFetch( iChannel0, st, 0 );\n    \n    fragColor = (\n        isParticleDead( particle ) \n        ? newParticle( fragCoord, iMouse, iTime, iResolution ) \n        : moveParticle( particle )\n    );\n#endif\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/////////////////////////////////////////////////////////////////////////////\n//\n// \"the more you know\" \n//\n// by Val \"valalalalala\" GvM - 2020\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//\n// This is where the scene values are defined, some utility functions and the\n// particle functions. \n//\n/////////////////////////////////////////////////////////////////////////////\n\n#define COUNT    33 * 10\n#define TOO_OLD  clamp( float( COUNT ) * .25, 13., 29. )\n#define GRAVITY  .0007\n#define VELOCITY .030\n\n/////////////////////////////////////////////////////////////////////////////\n// utility\n\nvec2 rezzo( in vec2 p, in vec3 resolution ) {\n     return ( 2. * p - resolution.xy ) / resolution.y;\n}\n\nivec2 toIVec( in vec2 p ) {\n    return ivec2( int( p.x ), int( p.y ) );\n}\n\nint toIndex( in ivec2 p, in vec3 resolution ) {\n    return p.x + p.y * int( resolution.x );\n}\n\nivec2 fromIndex( in int index, in vec3 resolution ) {\n    int row = int( resolution.x );\n    return ivec2( index % row, index / row );\n}\n\nfloat distanceToShape( float d, float t ) {\n    return 1. - smoothstep( .0, t, d );\n}\n\nfloat random(in vec2 st, float time) {\n    return .9 * ( -1.0 + 2.0* fract(sin(cos(time*.03)*dot(st.xy+3.3, vec2(12.9898,78.233))) * 43758.5453123) );\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// \n// The particle is stored as a vec4 with the xy as the position and zw as the\n// the velocity. The integer portion of the z value stores the age of the \n// particle and the fractional portion is the velocity in the x plane.\n//\n// At creation, a particle has an age of 1. Particles age 0 or over the\n// TOO_OLD threshold are reinitialized. This handles initiale state nicely.\n//\n//\n/////////////////////////////////////////////////////////////////////////////\n\nvec4 ageParticle( in vec4 particle ) {\n    particle.z += sign( particle.z ) * 1.; // integer portion is age...\n    return particle;\n}\n\nfloat ageOfParticle( in vec4 particle ) {\n    return 1. - abs( floor( particle.z ) / TOO_OLD );\n}\n\nbool isParticleDead( in vec4 particle ) {\n    float age = abs( floor( particle.z ) );\n    return age < .1 || age > TOO_OLD;\n}\n\nvec4 newParticle( in vec2 p, vec4 iMouse, float iTime, vec3 iResolution ) {\n    vec2 mx = rezzo( iMouse.xy, iResolution );    \n    float x = iMouse.z > .0 ? mx.x : cos( iTime );\n    float y = iMouse.z > .0 ? mx.y : sin( iTime );\n    float dx = VELOCITY * random( .33 * +p.xy + .0, iTime );\n    float dy = VELOCITY * random( .44 * -p.yx + .1, iTime );        \n    return ageParticle( vec4( x, y, dx, dy ) );\n}\n\nvec4 moveParticle( in vec4 particle ) {\n    float dx = fract( particle.z ) * sign( particle.z ); // fractional portion is velocity\n    dx = clamp( dx, -VELOCITY, +VELOCITY ); // idk... \n    particle.x += dx;\n    particle.y += particle.w;\n    particle.w -= GRAVITY;\n    particle = ageParticle( particle );\n    particle.z += sign( particle.z ) * floor( 3. * random( particle.xy, 33. ) );\n    return particle;\n    return ageParticle( particle );\n}\n\n// EOF\n/////////////////////////////////////////////////////////////////////////////","name":"Common","description":"","type":"common"}]}