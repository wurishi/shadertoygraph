{"ver":"0.1","info":{"id":"Xst3zS","date":"1450482408","viewed":302,"name":"raymarch test 4","username":"megaloler","description":"more testing, more experimenting, more learning\ni'm playing with shapes and spherical lenses! :3","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["test","raymarch","lens","experiment","sphere","camera","learning","shapes","geometry","spherical"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323846264338327\n\nfloat dSphere(vec3 p, vec3 p2, float r)\n{\n    return distance(p, p2) - r;\n}\n\nfloat dPlane(vec3 p, vec3 p2, vec3 n)\n{\n    return dot(n, (p - p2));\n}\n\nfloat dBox(vec3 p, vec3 p2, vec3 r)\n{\n    vec3 d = abs(p - p2) - r;\n    return length(max(vec3(0.0), d)) + min(0.0, max(max(d.x, d.y), d.z));\n}\n\nfloat opUnion(float d1, float d2)\n{\n    return min(d1, d2);\n}\n\nfloat opSubtract(float d1, float d2)\n{\n    return max(d1, -d2);\n}\n\nfloat opIntersect(float d1, float d2)\n{\n    return max(d1, d2);\n}\n\nfloat map(vec3 p)\n{\n    float d = dBox(p, vec3(2.0, 0.0, 2.0), vec3(0.5, 0.5, 0.5));\n    d = opUnion(d, dBox(p, vec3(0.0, 0.0, 2.0), vec3(0.5, 0.5, 0.5)));\n    d = opUnion(d, dPlane(p, vec3(0.0, -1.0, 0.0), vec3(0.0, 1.0, 0.0)));\n    d = opUnion(d, dSphere(p, vec3(-2.0, 0.0, 4.0), 1.0));\n    d = opSubtract(d, dSphere(p, vec3(-1.9, 0.2, 3.5), 0.8));\n    d = opSubtract(d, dBox(p, vec3(sin(0.0) * 2.0, -1.25, cos(0.0)), vec3(0.5, 0.5, 0.5)));\n    return d;\n}\n\nvec3 normal(vec3 p)\n{\n    vec3 e = vec3(0.00001, 0.0, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                          map(p + e.yxy) - map(p - e.yxy),\n                          map(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat shadow(vec3 p, vec3 lp, float k)\n{\n    vec3 dir = normalize(lp - p);\n    float ld = distance(p, lp);\n    float e = 0.00001;\n    const int maxIts = 32;\n    float res = 1.0;\n    float t = 0.1;\n    for(int i = 0; i < maxIts; i++)\n    {\n        if(t > ld) break;\n        vec3 pp = p + dir * t;\n        float d = map(pp);\n        if(d <= e) return 0.0;\n        res = min(res, k * d / t);\n        t += d;\n    }\n    return res;\n}\n\nvec3 light(vec3 p, vec3 lp, vec3 col, float i, float k)\n{\n    vec3 n = normal(p);\n    vec3 dir = normalize(lp - p);\n    float dp = dot(n, dir);\n    float d = distance(lp, p);\n    float at = pow(d, 2.0);\n    float s = shadow(p, lp, k);\n    return col * max(0.0, dp) * i * s / at;\n}\n\nvec3 lighting(vec3 p)\n{\n    vec3 l = vec3(0.1, 0.1, 0.1);\n    l += light(p, vec3(2.0, 1.0, -2.0), vec3(1.0, 0.95, 0.7), 10.0, 8.0);\n    l += light(p, vec3(-4.0, 2.0, 2.0), vec3(0.7, 0.85, 1.0), 10.0, 4.0);\n    return l;\n}\n\nvec3 castRay(vec3 ro, vec3 rd)\n{\n    float e = 0.00001;\n    const int maxIts = 128;\n    float t = 0.0;\n    for(int i = 0; i < maxIts; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if(d <= e) return p;\n        t += d;\n    }\n    return vec3(0.0);\n}\n\nvec4 interpolate(vec4 v1, vec4 v2, float weight)\n{\n    vec4 d = v2 - v1;\n    vec4 o = d * weight;\n    return v1 + o;\n}\n\nvec4 render(vec3 ro, vec3 rd)\n{\n    vec4 skyCol = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 sceneCol = vec4(1.0, 1.0, 1.0, 1.0);\n    float fogNear = 2.0;\n    float fogFar = 12.0;\n    \n    vec3 p = castRay(ro, rd);\n    if(p == vec3(0.0)) return skyCol;\n    vec4 col = sceneCol;\n    col *= vec4(lighting(p), 1.0);\n    float d = length(p);\n    if(d > fogNear)\n    {\n        float fogRng = fogFar - fogNear;\n        float fogOff = d - fogNear;\n        float fogPrc = fogOff / fogRng;\n        col = interpolate(col, skyCol, fogPrc);\n    }\n    return col;\n}\n\nvec2 pix2unit(vec2 coord)\n{\n    coord /= iResolution.xy;\n    coord *= 2.0;\n    coord -= 1.0;\n    float ratio = iResolution.x / iResolution.y;\n    coord.x *= ratio;\n    return coord;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 coord = pix2unit(fragCoord.xy);\n    vec2 mouse = pix2unit(iMouse.xy);\n    \n    /*vec3 camPos = vec3(-sin(-mouse.x * PI * 0.5), 0.0, -cos(-mouse.x * PI * 0.5));\n    vec3 camXDir = vec3(cos(-mouse.x * PI * 0.5), 0.0, -sin(-mouse.x * PI * 0.5));\n    vec3 camYDir = vec3(0.0, 1.0, 0.0);\n    float focalLength = 1.0;\n    \n    vec3 ro = camPos;\n    vec3 forward = normalize(cross(camXDir, camYDir));\n    vec3 px = camXDir * coord.x;\n    vec3 py = camYDir * coord.y;\n    vec3 pz = forward* focalLength;\n    vec3 pixPos = px + py + pz;\n    vec3 rd = normalize(pixPos - ro);*/\n    \n    // spherical lens!\n    vec3 ro = vec3(sin(iTime) * 4.0, sin(iTime / 1.824)*0.6 + 0.4, cos(iTime) * 4.0 + 4.0);\n    \n    vec3 pxp = ro + normalize(vec3(sin(coord.x + mouse.x * 3.0 - 4.0 + iTime), sin(coord.y + mouse.y * 3.0 - 3.5), cos(coord.x + mouse.x * 3.0 - 4.0 + iTime) * cos(coord.y + mouse.y * 3.0 - 3.5)));\n    vec3 rd = normalize(pxp - ro);\n    \n    fragColor = render(ro, rd);\n}","name":"","description":"","type":"image"}]}