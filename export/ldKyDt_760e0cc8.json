{"ver":"0.1","info":{"id":"ldKyDt","date":"1523989940","viewed":1608,"name":"2D Adventures #3 - Better Hex","username":"bombshell93","description":"The purpose behind this shader was a cleaner hex pattern than my previous attempt and I figured while I was at it a truchet pattern, overall I'm happy with this shader, its looking cleaner than my previous and the result is certainly more interesting.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//// ABSTRACT\n//\n//\tThe purpose behind this shader was a cleaner hex pattern than my previous\n//\tattempt and I figured while I was at it a truchet pattern, through some trial\n//\tand error and a bit of intuition I managed to find a way to get coordinates\n//\tfor the lines which seemed to flow from one tile to the other.\n//\n//\tOverall I'm happy with this shader, its looking cleaner than my previous\n//\tand the result is certainly more interesting, \n//\n//// AUTHOR\n//\n//\tScott R Howell (Bombshell93)\n\n\n#define SCALE .25\n\n// hex axes\n\nconst vec2 X = vec2(1., 0.);\nconst vec2 Y = vec2(.5, .866);\nconst vec2 Z = vec2(-.5, .866);\n\n// handy dandy pi bros\n\nconst float pi = 3.14;\nconst float pi2 = 6.28;\n\n// used when finding hex coordinates and hex corners\n\nconst float sqrt3 = sqrt(3.);\nconst float sqrtc = sqrt3 / 3. * .5;\n\n//// axial\n//\n//\tfinds axial coordniates via dot products of\taxis vectors, effectively the\n//\tmatrix multiplication I was using before albeit minimalized, based on the\n//\t\"branchless method\" found here:\n//\t\thttps://www.redblobgames.com/grids/hexagons/more-pixel-to-hex.html\n\nvec2 axial(vec2 p) {\n    \n    float y3 = p.y * sqrt3;\n    return floor((\n        floor(vec2(p.x * 2., y3 - p.x) + 1.)\n        + (y3 + 1. + p.x)) / 3.);\n}\n\n//// pixel\n//\n//\tfinds pixel coordinates via axial coordinates\n\nvec2 pixel(vec2 a) {\n    \n    return vec2(a.x - a.y * .5, a.y * sqrt3 * .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n    vec2 uv = iTime * .33 + fragCoord / iResolution.y / SCALE;\n    \n    // get axial coordinates\n    \n    vec2 a = axial(uv);\n    \n    // find pixel coordinates of hex tile and distance from center\n    \n    vec2 h = pixel(a);\n    vec2 d = uv - h;\n    float da =  atan(d.y, d.x);\n    d = abs(vec2(dot(d, X), dot(d, Y)));\n    \n    // find arbitrary index and use it to decide whether to use fipped corners\n    \n    float i = mod(mod(h.x, 3.) - mod(h.y * 2., 16.), 3.);\n    float flip = step(1.5, i) * 2. - 1.;\n    \n    //find distance to corners\n    \n    vec2 dta = (pixel(a) + (X + Y) * flip / 3.) - uv\n    \t, dtb = (pixel(a) - (Y + Z) * flip / 3.) - uv\n    \t, dtc = (pixel(a) - (X - Z) * flip / 3.) - uv;\n    float lta = dot(dta, dta)\n        , ltb = dot(dtb, dtb)\n        , ltc = dot(dtc, dtc);\n    \n    // find distance from nearest tile corner and mask the truchet pattern line\n    \n    float len = sqrt(min(lta, min(ltb, ltc)));\n    float m = 1.;\n    m *= step(0., len - sqrtc + .1) \n        - step(0., len - sqrtc - .1);\n    \n    // find the angle of the truchet pattern line\n    \n    vec2 dt = lta < ltb ? (lta < ltc ? dta : dtc) : (ltb < ltc ? dtb : dtc);\n    vec3 pcol = vec3(1., mod(flip * atan(dt.x, dt.y) + iTime, pi / 3.), 0.);\n    \n    // find cube-like color and mix it with the truchet pattern respecting its mask\n    \n    float bgl = floor(mod(da - .52359, pi2) / (pi2 / 3.)) * .5;\n    vec3 col = mix(vec3(0., 0., 1.) * (1. - bgl) + vec3(1.) * bgl, pcol, m);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}