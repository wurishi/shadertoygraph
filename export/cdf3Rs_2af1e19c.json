{"ver":"0.1","info":{"id":"cdf3Rs","date":"1667347565","viewed":96,"name":"Radial Number Wheel","username":"ChunderFPV","description":"The number line on a circle.  The Z key toggles autozoom.  Mouse x to transform between cartesian & polar unit circle. \n\nThe blue number is the radius of the purple circle which is either the sine or cosecant length.","likes":6,"published":1,"flags":16,"usePreview":0,"tags":["wave","sine","trig","polar","infinity","transform","unit"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R iResolution.xy\n#define M iMouse\n#define PI 3.14159265358979\n#define L(eq,w) smoothstep(w*min(fwidth(eq), 1.0), 0.0, abs(eq)) // line\n#define CL(r) step(max(0., r), min(r, 1.)) // clamp line\n#define P(xy,r) max(0., 1.-length(xy/fwidth(xy)/r)) // point\n#define KT(i) texelFetch(iChannel1, ivec2(i, 2), 0).x // key toggle\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    vec3 c = vec3(0);\n    vec2 m = M.xy/R*2.-1.;           // mouse coords\n    float s = 5.,                    // scale\n          lw = 1.5,                  // line width\n          snap = round(m.x*4.)/4.,   // round near int\n          t = mod(iTime, PI*2.0)-PI, // time (arc)\n          rnw = pow(abs(sin(t)), sign(cos(t)))*sign(t); // sine or cosecant\n    if (mod(snap, 1.) < .01) m.x = snap; // snap to int when close\n    vec2 uv = (XY-.5*R)/R.y, // screen coords\n         u = uv*s;           // with scale\n    if (KT(90) < 1.) u *= abs(rnw); // zoom with radius\n    \n    // cartesian to polar\n    u = u*(1.-abs(m.x))+vec2(atan(u.x, u.y*sign(m.x))*abs(m.x), length(u)*m.x);\n    \n    vec2 g = abs(fract(u+.5)-.5)/fwidth(u); // grid\n    c += max(0., 1.-min(g.x, g.y))*.25;     // grid lines\n    c += max(0., 1.-max(g.x, g.y));         // grid points\n    \n    float x = u.x,\n          y = u.y,\n          eq = pow(abs(sin(x)), sign(cos(x)))*sign(sin(x)); // rnw\n    \n    c.r += L(abs(y)-abs(eq), lw)*CL(abs(x)/PI);     // sin/csc graphs\n    c +=   L(abs(y)-abs(rnw), lw)*vec3(.5, 0., 1.); // radial number wheel\n    c.b += L(t-x, lw)*CL(abs(y/rnw));               // rnw radius (sin/csc length)\n    c +=   P(vec2(t-x, abs(y)-abs(rnw)), 3.)*2.;    // point\n    c.g += L(abs(y)-1., lw)*CL(x/t);                // arc length\n    \n    c.b += digit(iChannel0, uv-vec2(0.0, -0.48), rnw, .1, 4., 4.).x; // number\n    \n    RGBA = vec4(c, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// digit code from https://www.shadertoy.com/view/7tV3zK\nvec4 char(sampler2D ic, vec2 p, int c)\n{\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad(ic, p/16. + fract( vec2(c, 15-c/16)/16.), dFdx, dFdy );\n}\nvec4 pInt(sampler2D ic, vec2 p, float n, float d)\n{\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(ic, p - vec2(-.5,0), 45 ),\n        n = -n;\n    for (float i = d; i>0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(ic, p - .5*vec2(i-1.,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// texture, screen coords, value, size, num left digits, num right digits\nvec3 digit(sampler2D ic, vec2 uv, float v, float s, float l, float r)\n{\n    float numleft = min(log2(abs(v))/log2(10.), l-1.);\n    l = max(floor(numleft), 0.)+1.;\n    uv /= s; // size\n    if (isinf(abs(v))) return vec3(char(ic, uv*.7+vec2(.5, .3), 153).x); // infinity symbol\n    uv += vec2((l+1.)/2., .28); // center on decimal\n    vec3 d = vec3(0);\n    d += pInt(ic, uv, v, l).x; // left of decimal\n    uv.x -= l/2.;\n    d += char(ic, uv, 46).x; // decimal point\n    uv.x -= .5;\n    d += pInt(ic, uv, floor(abs(v)*pow(10., r)), r).x; // right of decimal\n    return d;\n}\n","name":"Common","description":"","type":"common"}]}