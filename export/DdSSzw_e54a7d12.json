{"ver":"0.1","info":{"id":"DdSSzw","date":"1670015701","viewed":134,"name":"sdf soft  shadow","username":"fufeng","description":"sdf soft shadow","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define _Color vec3(0.44,0.39,1.0)\n#define _BackgroundColor vec4(0.16,0.16,0.16, 1.0)\n#define _ShadowColor vec4(0.16,0.16,0.16, 1.0)\n\nfloat sdfCircle(vec2 coord, vec2 center, float radius)\n{\n    vec2 offset = coord - center;\n    return sqrt((offset.x * offset.x) + (offset.y * offset.y)) - radius;\n}\n\nfloat sdfBox(vec2 coord, vec2 center, float width, float height)\n{\n\tvec2 d = abs(coord - center) - vec2(width, height);\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdfUnion(const float a, const float b) {\n\treturn min(a, b);\n}\n\nfloat smooth_merge(float dist_f_, float dist2_f_, float k_f) {\n\tfloat h_f = clamp(0.5 + 0.5 * (dist2_f_ - dist_f_) / k_f, 0.0, 1.0);\n\treturn mix(dist2_f_, dist_f_, h_f) - k_f * h_f * (1.0 - h_f);\n}\n\nvec2 translate(vec2 render_v2_, vec2 move_v2_) {\n\treturn render_v2_ - move_v2_;\n}\n\nvec2 rotate_ccw(vec2 render_v2_, vec2 center_v2_, float radian_f_) {\n\tmat2 m = mat2(cos(radian_f_), sin(radian_f_), -sin(radian_f_), cos(radian_f_));\n\treturn m * (render_v2_ - center_v2_) + center_v2_;\n}\n\nvec2 rotate_cw(vec2 render_v2_, vec2 center_v2_, float radian_f_) {\n\tmat2 m = mat2(cos(radian_f_), -sin(radian_f_), sin(radian_f_), cos(radian_f_));\n\treturn m * (render_v2_ - center_v2_) + center_v2_;\t\n}\n\nvec4 render(float d, vec3 color, float stroke) \n{\n    float anti = fwidth(d) * 1.0;\n    vec4 colorLayer = vec4(color, 1.0 - smoothstep(-anti, anti, d));\n    if (stroke < 0.000001) {\n        return colorLayer;\n    }\n    vec4 strokeLayer = vec4(vec3(1.0,0.9,0.36), 1.0 - smoothstep(-anti, anti, d - stroke));\n    return vec4(mix(strokeLayer.rgb, colorLayer.rgb, colorLayer.a), strokeLayer.a);\n}\n\nvec4 outerGlow(float dist_f_, vec3 color, vec3 outer_color, float radius_f_) {\n\tfloat a_f = abs(clamp(dist_f_ / radius_f_, 0.0, 1.0) - 1.0);\n\tfloat anti = fwidth(dist_f_) * 1.0;\n\tvec4 colorLayer = vec4(color, 1.0 - smoothstep(-anti, anti, dist_f_));\n\tvec4 outerLayer = vec4(outer_color, pow(a_f, 3.0));\n\treturn vec4(mix(outerLayer.rgb, colorLayer.rgb, colorLayer.a), min(outerLayer.a + colorLayer.a, 1.0));\n}\n\nfloat scene_dist(vec2 scalePos){\n\tvec2 circlePos = scalePos;\n\tcirclePos = translate(circlePos, vec2(0, 0.06 * cos(iTime)));\n\tfloat circle = sdfCircle(circlePos, vec2(0.8, 0.43), 0.02);\n\n\tvec2 boxPos = scalePos;\n\tboxPos = translate(boxPos, vec2(0.2 * cos(iTime), 0));\n\tboxPos = rotate_cw(boxPos, vec2(0.6, 0.18), iTime * 2.0);\n\tfloat box = sdfBox(boxPos, vec2(0.6, 0.18), 0.05, 0.05);\n\t\n\tfloat circle1 = sdfCircle(scalePos, vec2(0.5 + abs(0.1 * cos(iTime)), 0.48), 0.05);\n\tfloat circle2 = sdfCircle(scalePos, vec2(0.5 - abs(0.1 * cos(iTime)), 0.48), 0.05);\n\tfloat smoothResult = smooth_merge(circle1 , circle2, 0.09);\n\n\tvec2 boxPos2 = scalePos;\n\tboxPos2 = rotate_ccw(boxPos2, vec2(0.8, 0.2), iTime);\n\tfloat box2 = sdfBox(boxPos2, vec2(0.8, 0.2), 0.1, 0.02);\n\n\tfloat unionResult = sdfUnion(circle, box);\n\tunionResult = sdfUnion(unionResult, box2);\n\tunionResult = sdfUnion(unionResult, smoothResult);\n\treturn unionResult;\n}\n\nfloat soft_shadow(vec2 render_v2_, vec2 light_v2_, float hard_f_) {\n    vec2 render_to_light_dir_v2 = normalize(light_v2_ - render_v2_);\n    float render_to_light_dist_f = length(render_v2_ - light_v2_);\n    float brightness_f = hard_f_ * render_to_light_dist_f;\n    float travel_dist_f = 0.0001;\n    for (int k_i = 0; k_i < 999; ++k_i) {\n        float dist_f = scene_dist(render_v2_ + render_to_light_dir_v2 * travel_dist_f);\n        if (dist_f < -hard_f_) {\n            return 0.0;\n        }\n        brightness_f = min(brightness_f, dist_f / travel_dist_f);\n        travel_dist_f += max(0.0001, abs(dist_f));\n        if (travel_dist_f > render_to_light_dist_f) {\n            break;\n        }\n    }\n    brightness_f = clamp((brightness_f * render_to_light_dist_f + hard_f_) / (2.0 * hard_f_), 0.0, 1.0);\n    brightness_f = smoothstep(0.0, 1.0, brightness_f);\n    return brightness_f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scalePos = uv;\n    scalePos.y = scalePos.y * iResolution.y / iResolution.x;\n    \n\tvec2 lightPos = vec2(0.5 - 0.05 * cos(iTime), 0.33);\n\tfloat lightCircle = sdfCircle(scalePos, lightPos, 0.02);\n\tvec4 lightLayer = outerGlow(lightCircle, vec3(0.99, 0.8, 0.3), vec3(0.99, 0.79, 0.19), 1.0);\n\t\n\tfloat unionResult = scene_dist(scalePos);\n\tvec4 unionLayer = render(unionResult, _Color, fwidth(unionResult) * 1.0);\n\n\tfloat shadowValue = 1.0 - soft_shadow(scalePos, lightPos, 0.03);\n\n\tvec4 col = mix(_BackgroundColor, lightLayer, lightLayer.a);\n\tcol = mix(col, _ShadowColor, shadowValue);\n\tcol = mix(col, unionLayer, unionLayer.a);\n\t\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}