{"ver":"0.1","info":{"id":"DlKBDK","date":"1702504712","viewed":50,"name":"Rec.709 Whitepoint Adjust","username":"serioux666","description":"Convert (presumably) sRGB data to Rec.709 and transform it back. During the back transform, alter the Rec.709 whitepoint based on mouse Y position. \n\nLeft: back transform with D65, right with CCT based on mouse Y. Top bar shows reference white.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["colorspace","ycbcr","whitepoint","ypbpr","rec709"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Copyright (C) 2023  Gregor Vollmer <gpl@dynamic-noise.net>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nstruct primaries {\n    vec2 red;\n    vec2 green;\n    vec2 blue;\n};\n\nstruct csTransforms {\n    mat3 RGB_to_XYZ;\n    mat3 XYZ_to_RGB;\n    mat3 RGBprime_to_YPbPr;\n    mat3 YPbPr_to_RGBprime;\n    vec3 K;\n    vec2 white_xy;\n};\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst vec2 WHITEPOINT_sRGB = vec2(0.3127, 0.3290);\nconst vec2 WHITEPOINT_Rec709 = vec2(0.312713, 0.329016);\n\nconst primaries PRIMARIES_sRGB = primaries(vec2(0.64, 0.33), vec2(0.30, 0.60), vec2(0.15, 0.06));\nconst primaries PRIMARIES_Rec709 = primaries(vec2(0.64, 0.33), vec2(0.30, 0.6), vec2(0.15, 0.06));\n\nvec2 getChromaticityByCCT(float cct);\ncsTransforms calculateColorspaceTransforms(primaries p, vec2 white_xy);\nvec3 xy_to_XYZ(vec2 pc);\nvec3 OETF_sRGB(vec3 col);\nvec3 EOTF_sRGB(vec3 col);\nvec3 OETF_Rec709(vec3 col);\nvec3 EOTF_Rec709(vec3 col);\nfloat OETF_Rec709(float col);\nfloat EOTF_Rec709(float col);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord / iResolution.xy;\n    vec3 col = texture(iChannel0, pos).rgb;\n    vec2 mouseRel = iMouse.xy / iResolution.xy;\n    if(iMouse.xy == c.yy) {\n        mouseRel = vec2(0.5, 0.8);\n    }\n    vec2 white_xy = WHITEPOINT_Rec709;\n    if(pos.x > mouseRel.x) {\n        white_xy = getChromaticityByCCT(mix(2700., 10000., mouseRel.y));\n    }\n    csTransforms cs_sRGB = calculateColorspaceTransforms(PRIMARIES_sRGB, WHITEPOINT_sRGB);\n    csTransforms cs_Rec709 = calculateColorspaceTransforms(PRIMARIES_Rec709, WHITEPOINT_Rec709);\n    csTransforms cs_Rec709CCT = calculateColorspaceTransforms(PRIMARIES_Rec709, white_xy);\n    \n    // Convert sRGB image data into absolute XYZ space\n    vec3 XYZ_real = cs_sRGB.RGB_to_XYZ * EOTF_sRGB(col);\n    \n    // Transform XYZ color coordinates into Rec.709 compatible RGB space\n    vec3 RGB_709 = OETF_Rec709(cs_Rec709.XYZ_to_RGB * XYZ_real);\n    \n    // Convert from RGB space to YPbPr space (non-offset YCbCr)\n    vec3 YPbPr_709 = cs_Rec709.RGBprime_to_YPbPr * RGB_709;\n    \n    // Transform back to XYZ coords using different witepoint\n    vec3 XYZ_adjusted = cs_Rec709CCT.RGB_to_XYZ * EOTF_Rec709(cs_Rec709CCT.YPbPr_to_RGBprime * YPbPr_709);\n    \n    // Convert adjusted XYZ coords back to sRGB for displaying.\n    // Should do some gamut compression here...\n    vec3 RGB = OETF_sRGB(cs_sRGB.XYZ_to_RGB * XYZ_adjusted);\n    \n    col = RGB * step(0.004, abs(pos.x - mouseRel.x));\n    col /= max(1.0, max(col.r, max(col.g, col.b))); // desaturate\n    \n    // Show color of whitepoint of the back-transform on the top of the image.\n    if(pos.y > 0.97) {\n        col = OETF_sRGB(cs_sRGB.XYZ_to_RGB * xy_to_XYZ(white_xy));\n    } else if(pos.y > 0.96) {\n        col = c.yyy;\n    }\n\n    // Output to screen\n    fragColor = vec4(col * step(0.004, abs(pos.x - mouseRel.x)), 1.0);\n}\n\nvec2 getChromaticityByCCT(float cct)\n{\n    float cct2 = cct*cct;\n    float u = (0.860117757 + 1.54118254e-4 * cct + 1.28641212e-7 * cct2) / (1. + 8.42420235e-4 * cct + 7.08145163e-7 * cct2);\n    float v = (0.317398726 + 4.22806245e-5 * cct + 4.20481691e-8 * cct2) / (1. - 2.89741816e-5 * cct + 1.61456053e-7 * cct2);\n    return vec2(3.*u, 2.*v) / (2.*u - 8.*v + 4.);\n}\n\ncsTransforms calculateColorspaceTransforms(primaries p, vec2 white_xy)\n{\n    csTransforms cs;\n    mat3 P = (mat3(xy_to_XYZ(p.red), xy_to_XYZ(p.green), xy_to_XYZ(p.blue)));\n    mat3 M = inverse(P);\n    cs.K = M * xy_to_XYZ(white_xy);\n    cs.white_xy = white_xy;\n    cs.RGB_to_XYZ = (mat3(xy_to_XYZ(p.red) * cs.K.r, xy_to_XYZ(p.green) * cs.K.g, xy_to_XYZ(p.blue) * cs.K.b));\n    cs.XYZ_to_RGB = inverse(cs.RGB_to_XYZ);\n    cs.RGBprime_to_YPbPr = transpose(mat3(cs.K,\n                     -0.5 * cs.K.r / (1. - cs.K.b), -0.5 * cs.K.g / (1. - cs.K.b), 0.5,\n                     0.5, -0.5 * cs.K.g / (1. - cs.K.r), -0.5 * cs.K.b / (1. - cs.K.r)));\n    cs.YPbPr_to_RGBprime = inverse(cs.RGBprime_to_YPbPr);\n    return cs;\n}\n\nvec3 xy_to_XYZ(vec2 pc)\n{\n    return vec3(pc.x / pc.y, 1., (1. - pc.x - pc.y) / pc.y);\n}\n\nvec3 OETF_sRGB(vec3 col)\n{\n    return pow(col, 1./2.2 * c.xxx);\n}\n\nvec3 EOTF_sRGB(vec3 col)\n{\n    return pow(col, 2.2 * c.xxx);\n}\n\nvec3 OETF_Rec709(vec3 col)\n{\n    return vec3(\n        OETF_Rec709(col.x),\n        OETF_Rec709(col.y),\n        OETF_Rec709(col.z));\n}\n\nvec3 EOTF_Rec709(vec3 col)\n{\n    return vec3(\n        EOTF_Rec709(col.x),\n        EOTF_Rec709(col.y),\n        EOTF_Rec709(col.z));\n}\n\nfloat OETF_Rec709(float E)\n{\n\n    const float alpha = 1.09929682680944;\n    const float beta = 0.018053968510807;\n    return E <= beta ? 4.5 * E : alpha * pow(E, 0.45) - (alpha - 1.);\n}\n\nfloat EOTF_Rec709(float V)\n{\n    const float L_W = 1.0;\n    const float L_B = 0.0;\n    const float gamma = 2.4;\n    const float inv_gamma = 1. / gamma;\n    const float a = pow(pow(L_W, inv_gamma) - pow(L_B, inv_gamma), gamma);\n    const float b = pow(L_B, inv_gamma) / (pow(L_W, inv_gamma) - pow(L_B, inv_gamma));\n    return a * pow(clamp(V + b, 0.0, 1e9), gamma);\n}","name":"Image","description":"","type":"image"}]}