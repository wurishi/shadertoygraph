{"ver":"0.1","info":{"id":"WtGBRd","date":"1614833825","viewed":106,"name":"My RayMarching for Dummies","username":"shellshear","description":"My version of https://www.youtube.com/watch?v=PGtv-dBi2wE&t=318s","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["theartofcode"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST .01\n\n// Looking at a scene containing a sphere above a ground plane\nfloat GetDist(vec3 p)\n{\n    vec4 s = vec4(0,1,6,1); // sphere is at (0,1,6) and with radius 1\n    float sphereDist = length(p-s.xyz)-s.w+sin(iTime); // distance between our position and the closest point on sphere (sphere centroid - radius)\n\n    float planeDist = p.y; // camera is p.y above the ground plane\n    float d = min(sphereDist, planeDist);\n    \n    return d;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p); // closest distance between the point and an item in the world (in this case, sphere or plane)\n    \n    // Now find a point very close by\n    vec2 e = vec2(.01, 0);\n    \n    // Calculate the normal by doing x=GetDist(p)-GetDist(p-delta_x), y=GetDist(p)-GetDist(p-delta_y), z=GetDist(p)-GetDist(p-delta_z)\n    // the xyy xyy etc. are what's called a \"swizzle\". We're just making (.01,0,0), (0,.01,0) and (0,0,.01)\n    vec3 n = d - vec3(GetDist(p-e.xyy), GetDist(p-e.yxy), GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// Repeatedly move along the ray until we hit it (or too many iterations, or we've gone past)\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    float dOrigin=0.;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + dOrigin * rd;\n        float dScene = GetDist(p);\n        dOrigin += dScene;\n        \n        // Check whether we are super close, or if we've gone way past the object\n        if (dScene < SURFACE_DIST || dOrigin > MAX_DIST)\n            break;\n    }\n    \n    return dOrigin;\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6); // Source of light \n    \n    // Move the light around in a circle\n    lightPos.xz += vec2(sin(iTime*2.)*2., cos(iTime*2.)*2.);\n    \n    // Direction vector of the light relative to the point\n    vec3 l = normalize(lightPos - p);\n    \n    // Normal of the surface that we hit\n    vec3 n = GetNormal(p);\n    \n    // Simple lighting model: use the dot product to say that if the light and surface normal are the same direction, \n    // we get maximum light, and if they are perpendicular we get no light\n    float dif = clamp(dot(n,l), 0., 1.);\n    \n    // Add shadow\n    // Ray march from the point to the light source. \n    // If the point doesn't make it all the way to the light source, we know it's in shadow\n    // The point is already very close to a surface (we know that because p is already the result of a raymarch)\n    // so it would normally exit right away from a raymarch test, so we have to move it a little away from the \n    // surface. To do that, we go a bit further than the raymarch surface distance, and we go in the direction of \n    // the surface normal (which will be in the correct direction).\n    float d = RayMarch(p+n*SURFACE_DIST*2., l);\n    \n    // Alternately, can start at the light position and raymarch towards p. But this makes some weird artifacts!\n    //d = RayMarch(lightPos, normalize(p-lightPos));\n    if (d < length(lightPos-p))\n    {\n        // We're in shadow\n        dif *= .1;\n    }\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.,1.,0.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro+rd*d; // position in the world that we're looking at\n    float diffuseLighting = GetLight(p);\n    \n    col = vec3(diffuseLighting);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}