{"ver":"0.1","info":{"id":"mdyGzm","date":"1678335276","viewed":215,"name":"Windows Pipe Dream 3D Rotation","username":"gunthern","description":"This is a version of a previous shader (https://www.shadertoy.com/view/dsGGRw) with rotation. All voxels are redrawn every frame to allow for rotation, unlike the other version which uses a depth buffer to only update new segments. Rotation by @morimea","likes":12,"published":1,"flags":32,"usePreview":1,"tags":["screen","windows","screensaver","dream","microsoft","saver","xp","pipe","pipes","pipes","windows95","95","y2k","pipedream","2000","windows98"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// 3D version of the classic Microsoft \"Pipe Dream\" screensaver\n// Big thanks to @morimea for many tips on improving the first \n// version of this shader, specifically using voxels for each \n// pipe point instead of a very slow for loop when drawing the pipes,\n// and for the camera rotation script.\n\nvoid getFade(out float fade, out int iter) {\n\n    iter = iFrame / (duration + fadeDuration);\n    \n    fade = 1.0 - (float(max((iFrame - (duration+fadeDuration)*iter) - duration, 0)) / float(fadeDuration));\n\n}\n\nSurface getDist(vec3 p, vec3 rd) {\n    \n    p += vec3(vec2(float(gridSize)/2.0), float(gridSize) * -1.0);\n    p = clamp(p, vec3(0.0), vec3(gridSize));\n    \n    int iter = iFrame / (duration + fadeDuration);\n    \n    // 3D repetition from iquilezles.org/articles/distfunctions/\n    vec3 q = fract(p)-0.5;\n    \n    // Overstep correction\n    vec2 rC = ((2.0 * step(0.0, rd.xz) - 1.0) * vec2(0.5) - q.xz) / rd.xz; // ray to cell boundary\n    float dC = min(rC.x, rC.y) + 0.01; // distance to cell just past boundary\n    if (p.x >= float(gridSize) || p.x <= 0.0\n     || p.y >= float(gridSize) || p.y <= 0.0\n     || p.z >= float(gridSize) || p.z <= 0.0 ) \n    { dC += MAX_DIST; }\n    Surface dCS = Surface(dC, vec3(0.0));\n   \n    // Get point state from buffer\n    int x = int(p.x) + int(p.z)*gridSize;\n    int y = int(p.y);\n    vec3 state = texelFetch(iChannel0, ivec2(x,y), 0).rgb;\n    \n    int id = int(state.r * float(numPipes));\n   \n    if (id != 0) {\n    \n        // Get point attributes\n        bool pipeJoint = fract(state.g) == 0.5;\n        \n        int reachDir = int(state.b * 0.1);\n        vec3 rd = reachDir == 1 ? vec3(0.0, 1.0, 0.0) :\n        reachDir == 2 ? vec3(0.0, -1.0, 0.0) : \n        reachDir == 3 ? vec3 (-1.0, 0.0, 0.0) :\n        reachDir == 4 ? vec3(1.0, 0.0, 0.0) :\n        reachDir == 5 ? vec3(0.0, 0.0, -1.0) :\n        reachDir == 6 ? vec3(0.0, 0.0, 1.0) : vec3(0.0);\n        \n        int joinDir = int(mod(state.b, 10.0));\n        vec3 jd = joinDir == 1 ? vec3(0.0, -1.0, 0.0) :\n        joinDir == 2 ? vec3(0.0, 1.0, 0.0) : \n        joinDir == 3 ? vec3 (1.0, 0.0, 0.0) :\n        joinDir == 4 ? vec3(-1.0, 0.0, 0.0) :\n        joinDir == 5 ? vec3(0.0, 0.0, 1.0) :\n        joinDir == 6 ? vec3(0.0, 0.0, -1.0) : vec3(0.0);\n        \n        vec3 col = color(state.r, iter);\n        \n        Surface rc = sdCapsule(q, vec3(0.0), rd, pipeRadius, col);\n        Surface jc = sdCapsule(q, vec3(0.0), jd, pipeRadius, col);\n        \n        if (pipeJoint) {\n        \n            Surface sphere = sdSphere(q, capRadius, col);\n        \n            return surfaceMin(surfaceMin(sphere, surfaceMin(rc, jc)), dCS);\n            \n        }\n        \n        return surfaceMin(surfaceMin(rc, jc), dCS);\n        \n    }\n     \n    return surfaceMin(Surface(float(gridSize) * 0.05, vec3(0.0)), dCS);\n    //return surfaceMin(sdSphere(q, pipeRadius, vec3(0.0)), dCS);\n  \n}\n\n// Raymarch\nSurface rayMarch(vec3 ro, vec3 rd){\n\n    float dO = 0.0;\n    \n    vec3 col = vec3(0.0);\n    vec3 p;\n    Surface distColor;\n    \n    for (int i=0; i<MAX_STEPS; i++){\n    \n        p = ro + rd*dO;\n        \n        distColor = getDist(p, rd);\n        float dS = distColor.dist;\n        \n        dO += dS;\n        if (dO>MAX_DIST || dS<SURFACE_DIST) break;\n    }\n    \n    col = distColor.col;\n    \n    return Surface(dO, col);\n    \n}\n\n// Get normal\nvec3 getNormal(vec3 p, vec3 rd) {\n\n    float d = getDist(p, rd).dist;\n    vec2 e = vec2(.01, 0.0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy, rd).dist,\n        getDist(p-e.yxy, rd).dist,\n        getDist(p-e.yyx, rd).dist);\n        \n    return normalize(n);\n    \n}\n\n// Get light\nvec3 getLight(vec3 p, vec3 c, vec3 lp, vec3 rd) {\n\n    vec3 l = normalize(lp - p);\n    vec3 n = getNormal(p, rd); \n    \n    float diff = dot(n, l);\n    float d = rayMarch(p+n*SURFACE_DIST*2.0, l).dist;\n    if (d<length(lp-p)) diff *= 0.01;\n    \n    return diff * c;\n      \n}\n\n#ifdef AA\nvoid mainImageRaw(out vec4 fragColor, in vec2 fragCoord)\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n#endif\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    // Fade amount and iteration\n    float fade;\n    int iter;\n    getFade(fade, iter);\n    \n    vec3 col = vec3(0.0);\n    \n    // Ray origin\n    vec3 ro = vec3(0.0);\n    // Ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    ro = vec3(0.0, 0.0, float(gridSize) * 1.5); \n    vec2 m = (iMouse.xy/iResolution.xy-0.5)*3.14159265*vec2(2.0,1.0); // mouse\n    \n    float timer = fract(iTime / 30.0);\n    //moving cam\n    ro += 0.75*float(gridSize) * vec3(sin(timer * (3.1415926 * 2.0)), 0.0, cos(timer  *(3.1415926 * 2.0)));\n    //static cam\n    //ro += float(gridSize) * vec3(0.75, 0.0, 0.0);\n    \n    if(iMouse.z < 1.0)\n    {\n        // anim\n        m = vec2(3.1415926, 0.0);\n        m.x *= -cos(0.5 * timer * (3.1415926 * 2.0));\n    }\n    \n    m.y = -m.y;\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    rd = (rotY * rotX) * rd;\n    \n    // Raymarch and get diffuse color\n    Surface rs = rayMarch(ro, rd);\n    float d = rs.dist;\n    col = rs.col;\n    \n    vec3 p = (ro + rd * d);\n    \n    // Diffuse lighting\n    /*vec3 diffuse = getLight(p, vec3(1.0), vec3(2.0), rd);\n    diffuse = clamp(diffuse, 0.15, 1.0);\n    diffuse = d == 0.0 ? vec3(0.0) : diffuse;\n    \n    vec3 color = vec3(clamp(diffuse * col, 0.0, 1.0));*/\n    \n    // Normal lighting\n    vec3 normal = getNormal(p, rd);\n    float normalLight = clamp((normal.r)*0.33 + (1.0-normal.b)*0.33 + normal.g*0.33, 0.25, 1.0);\n    if (d > float(gridSize)*3.0) normalLight = 0.0;   \n    \n    vec3 color = vec3(clamp(normalLight * col + normalLight * 0.25, 0.0, 1.0));\n    \n    //fragColor = vec4(d*0.03);\n    //fragColor = vec4(vec3(diffuse), 1.0);\n    //fragColor = vec4(vec3(normalLight), 1.0);\n    //fragColor = vec4(col, 1.0);\n    fragColor = vec4(color * fade, 1.0);\n    \n    // Buffer debug\n    //fragColor = texture(iChannel0, fragCoord/iResolution.xy * 0.1);\n    \n}\n\n#ifdef AA\n// Antialiasing \"module\" by FabriceNeyret2 https://www.shadertoy.com/view/WlfyW8\nvoid mainImage(out vec4 O, vec2 U) {\n    vec4 T;  \n    O = vec4(0);                                          \n    for (int k=0; k<AA*AA; k++, O+=T) {              \n        mainImageRaw(T, U + 0.33 * vec2(k%AA - AA/2, k/AA - AA/2));\n    }\n    O /= float(AA*AA);\n}\n#endif","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Global Variables //\n\n// Max FPS\n#define fps 60\n// Cube grid size\n#define gridSize 10\n// Random seed (for start positions, directions, and colors)\n#define randomSeed 44.24\n// Number of pipes\n#define numPipes 5\n// Speed (frames between updates)\n#define speed int(3.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Duration (length of one arrangement in frames)\n#define duration int(160.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Fade (length of fade out)\n#define fadeDuration int(30.0 * max((float(iFrame) / max(iTime, 0.01)) / float(fps), 1.0))\n// Pipe radius\n#define pipeRadius 0.1\n// Cap radius\n#define capRadius 0.15\n\n// Raymarching Globals //\n\n#define MAX_STEPS 100\n#define  MAX_DIST 100.0\n#define SURFACE_DIST 0.005\n\n// Antialiasing level (uncomment to enable) //\n\n//#define AA 4\n\n// Global Functions //\n\n// Random function from the Book of Shaders - returns random value between 0 and 1\nfloat random (in vec2 uv) {\n    \n    return fract(sin(dot(uv.xy, vec2(12.98,78.23))) * randomSeed);\n    \n}\n\n// Randomly generate colors\nvec3 color(in float p, in int iter) {\n    \n    float ti = float(iter) * random(vec2(p+1.));\n    \n    float r = random(vec2(p+ti,p+ti+1.));\n    float g = random(vec2(p+ti+2.,p+ti+3.));\n    float b = random(vec2(p+ti+4.,p+ti+5.));\n    \n    vec3 col = vec3(r,g,b);\n    return col;\n    \n}\n\n// Raymarched surface constructor\nstruct Surface {\n\n    float dist;\n    vec3 col;\n    \n};\n\n// Surface min\nSurface surfaceMin(Surface a, Surface b) {\n    \n    vec3 c = a.dist > b.dist ? b.col : a.col;\n    \n    return Surface(min(a.dist, b.dist), c);\n    \n}\n\n// Raymarched sphere (iquilezles.org/articles/distfunctions)\nSurface sdSphere(vec3 p, float r, vec3 col) {\n    \n    return Surface(length(p)-r, col);\n    \n}\n\n// Raymarched capsule (iquilezles.org/articles/distfunctions)\nSurface sdCapsule(vec3 p, vec3 a, vec3 b, float r, vec3 col)\n{\n\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return Surface(length(pa - ba*h) - r, col);\n  \n}\n\n// Rotate\nvec3 rotateY (vec3 point, vec3 pivot, float angle) {\n\n  vec3 direction = point - pivot;\n  float cosTheta = cos(angle);\n  float sinTheta = sin(angle);\n  \n  mat3 rotationMatrix = mat3(\n    cosTheta, 0, sinTheta,\n    0, 1, 0,\n    -sinTheta, 0, cosTheta\n  );\n  \n  return pivot + rotationMatrix * direction;\n  \n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Initialize grid and start points\nvoid initGrid(inout vec4 fragColor, in ivec2 ipx, in int iter) {\n    \n    fragColor = vec4(0.0);\n    \n    vec3 point;\n    \n    // Unique start points, one per pipe\n    int startPoints[numPipes];\n    const int maxPoints = int(gridSize*gridSize*gridSize);\n    int allPoints[maxPoints];\n    \n    for (int i=0; i < maxPoints; i++) {\n        allPoints[i] = i;\n    }\n    \n    for (int i=0; i < numPipes; i++) {\n        int randomStart = int(floor(random(vec2(1.0 + float(i) + float(iter) * randomSeed)) * float(maxPoints - i)));\n        startPoints[i] = allPoints[randomStart];\n        allPoints[randomStart] = allPoints[maxPoints - (1+i)];\n    }\n    \n    int pointIncrement = 0;\n    \n    // Populate grid with available points and start points\n    for (int i=0; i < gridSize*gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = int(floor(float(i) / float(gridSize * gridSize)));\n        int z = int(floor((float(i) - float(y * gridSize * gridSize)) / float(gridSize)));\n        \n        int startPoint = 0;\n\n        for (int i=0; i < numPipes; i++) {\n            if (pointIncrement == startPoints[i]) {\n                startPoint = i + 1;\n            }\n        }\n\n        if (\n            int(mod(float(ipx.x), float(gridSize))) == x\n            && ipx.y == y\n            && ipx.x / gridSize == z\n            && startPoint != 0\n        )\n        {\n            point = vec3(float(startPoint) / float(numPipes), 1.5, 0.0);\n        }\n\n        pointIncrement++;\n\n    }\n    \n    fragColor = vec4(point, 1.0);\n    \n}\n\n// Possible directions for next point\nconst ivec3 up = ivec3(0, 1, 0);\nconst ivec3 down = ivec3(0, -1, 0);\nconst ivec3 left = ivec3(-1, 0, 0);\nconst ivec3 right = ivec3(1, 0, 0);\nconst ivec3 back = ivec3(0, 0, -1);\nconst ivec3 front = ivec3(0, 0, 1);\n\nconst int directionCount = 6;\n\nconst ivec3 directions[directionCount] = ivec3[](up, down, left, right, back, front);\n\n// Update grid points\nvoid updateGrid(inout vec4 fragColor, in ivec2 ipx) {\n    \n    // Get point states\n    bool pointStates[int(gridSize*gridSize*gridSize)];\n    \n    for (int i=0; i < int(gridSize*gridSize*gridSize); i++) {\n        pointStates[i] = true;\n    }\n\n    ivec3 nextPoint;\n    \n    // Find active points\n    for (int i=0; i < gridSize*gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = int(floor(float(i) / float(gridSize * gridSize)));\n        int z = int(floor((float(i) - float(y * gridSize * gridSize)) / float(gridSize)));     \n        \n        vec3 state = texelFetch(iChannel0, ivec2(float(x+z*gridSize)+0.5, float(y)+0.5), 0).rgb;\n\n        if (state.g > 0.5) {\n\n            int randomDirIter = 0;\n\n            int directionKey = 0;\n\n            // Generate next point\n            ivec3 dirDynamic[directionCount] = directions;\n            if (y == gridSize - 1) dirDynamic[0] = down;\n            if (y == 0) dirDynamic[1] = up;\n            if (x == 0) dirDynamic[2] = right;\n            if (x == gridSize - 1) dirDynamic[3] = left; \n            if (z == 0) dirDynamic[4] = front;\n            if (z == gridSize - 1) dirDynamic[5] = back;\n            \n            bool validNextPoint = false;\n\n            for (int i=0; i < directionCount; i++) {\n                float newRandom = random(vec2(x + y + randomDirIter + iFrame)) * 0.999;\n                int randomDir = int(floor(newRandom*float(directionCount-i-1)));\n                nextPoint = ivec3(x,y,z) + dirDynamic[randomDir];\n                vec3 nextPointState = texelFetch(iChannel0, ivec2(float(nextPoint.x + nextPoint.z*gridSize)+0.5, float(nextPoint.y)+0.5), 0).rgb;\n                // Check point availability\n                if (nextPointState.r == 0.0 && pointStates[int(nextPoint.x + nextPoint.y*gridSize + nextPoint.z*gridSize*gridSize)]) {\n                    validNextPoint = true;\n                    // Mark point as taken\n                    pointStates[int(nextPoint.x + nextPoint.y*gridSize + nextPoint.z*gridSize*gridSize)] = false;\n                    directionKey = dirDynamic[randomDir] == up ? 1 :\n                       dirDynamic[randomDir] == down ? 2 :\n                       dirDynamic[randomDir] == left ? 3 :\n                       dirDynamic[randomDir] == right ? 4 : \n                       dirDynamic[randomDir] == back ? 5 : \n                       dirDynamic[randomDir] == front ? 6 : 0;\n                    break;\n                }\n\n                dirDynamic[randomDir] = dirDynamic[directionCount-i-1];\n                randomDirIter++;\n\n            }\n\n            // Update next point\n            if (\n                validNextPoint\n                && ipx.xy == ivec2(nextPoint.x + nextPoint.z*gridSize, nextPoint.y)\n            )\n            {\n\n                fragColor = vec4(state.r, 1.0, directionKey, 1.0);\n            }\n\n            // Update this point\n            if (\n                ipx.xy == ivec2(x+z*gridSize, y)\n            )\n            {\n                fragColor = vec4(state.r, 0.5, state.b, 1.0);\n                if (validNextPoint) {\n                    float thisPointDir = mod(state.b, 10.0) + float(directionKey)*10.0;\n                    fragColor = vec4(state.r, fract(state.g), thisPointDir, 1.0);\n                    if (directionKey != int(state.b) && random(vec2(nextPoint.xy + nextPoint.xz + nextPoint.yz)) > 0.5) {\n                        fragColor = vec4(state.r, 0.5, thisPointDir, 1.0);\n                    }\n                } \n            }\n\n        }\n\n    }\n\n}\n\n// Stop all pipes\nvoid stopPipes(inout vec4 fragColor, in ivec2 ipx) {\n    \n    // Find active points\n    for (int i=0; i < gridSize*gridSize*gridSize; i++) {\n    \n        int x = int(mod(float(i), float(gridSize)));\n        int y = int(floor(float(i) / float(gridSize * gridSize)));\n        int z = int(floor((float(i) - float(y * gridSize * gridSize)) / float(gridSize)));\n        \n        vec3 state = texelFetch(iChannel0, ivec2(float(x+z*gridSize)+0.5, float(y)+0.5), 0).rgb;\n\n        if (\n            int(mod(float(ipx.x), float(gridSize))) == x\n            && ipx.y == y\n            && ipx.x / gridSize == z\n            && state.g > 0.5\n        )\n        {\n            fragColor = vec4(state.r, 0.5, state.b, 1.0);\n        }\n\n    }\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n    if (fragCoord.x > float(gridSize*gridSize) || fragCoord.y > float(gridSize)) discard;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Current iChannel0\n    vec4 previousTex = texture(iChannel0, uv);\n    \n    // Iteration\n    int iter = iFrame / (duration + fadeDuration);\n    \n    // Draw buffer texture\n    fragColor = previousTex;\n    \n    bool stopCondition = false;\n    \n    // Int fragCoord\n    ivec2 ipx = ivec2(fragCoord);\n    \n    // Initialize\n    if (iFrame == 0 || iFrame % (duration + fadeDuration) == 0) {\n        \n    \tinitGrid(fragColor, ipx, iter);\n        \n        stopCondition = true;\n        \n    }\n    \n    // Stop pipes at duration\n    if ((iFrame - iter*fadeDuration) % duration == 0 && !stopCondition) {\n        \n        stopPipes(fragColor, ipx);\n        \n        stopCondition = true;\n    \n    }\n    \n    // Update every s frames\n    if (iFrame % speed == 0 && !stopCondition) {\n    \n        updateGrid(fragColor, ipx);\n    \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}