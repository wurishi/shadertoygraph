{"ver":"0.1","info":{"id":"mtlSDl","date":"1675501563","viewed":33,"name":"phong_shading","username":"zmyyy","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n#define AA 3\nvec2 opU(vec2 a, vec2 b){\n    return a.x<b.x?a:b;\n}\nmat3 setcamera(vec3 ta, vec3 p, vec3 up){\n    vec3 z = normalize(ta-p);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = normalize(cross(z,x));\n    return mat3(x,y,z);\n}\nfloat sdfrect(vec3 p){\n    \n    vec3 b = vec3(.5,.8,.5);\n    vec3 d = abs(p-vec3(.0,.0,1.0))-b;\n    return length(max(d,0.))+min(0.,max(d.x,max(d.y,d.z)));\n}\nfloat sdfcircle(vec2 p, float r){\n    return length(p)-r;\n}\n\nfloat sdfplane(vec3 p){\n    return p.y;\n}\n\nfloat sdfsphere(vec3 p){\n    return length(p-vec3(0.,0.3,0.0))-.3;\n}\n\nvec2 map(vec3 p){\n    return opU(vec2(sdfrect(p),2.),opU(vec2(sdfsphere(p),1.),vec2(sdfplane(p),0.)));\n}\n\nfloat calcAO(vec3 p, vec3 n){\n    float res=0.0;\n    float exdecay = .5;\n    float k = 1.0;\n    for(int i =0 ; i<5;i++){\n        float d = 0.01+0.03*float(i);\n        vec3 np = p + d * n;\n        float dis = map(np).x;\n        res += exdecay*(d - dis);\n        exdecay *= .5;\n    }\n    return clamp(1.-k*res,0.,1.);\n}\nvec2 raymarch(vec3 ori, vec3 dir){\n    float t = .1;\n    vec2 res=vec2(-1.);\n    for(int i=0;i<128&&t<20.;i++){\n        vec3 p = ori + t*dir;\n        vec2 d = map(p);\n        if(d.x<0.0001){\n            res.y=d.y;\n            break;\n        }else\n            t+=d.x;\n    }\n    res.x = t;\n    return res;\n}\nvec3 calcNormalsphere(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdfsphere(p + k.xyy * h) +\n        k.yyx * sdfsphere(p + k.yyx * h) +\n        k.yxy * sdfsphere(p + k.yxy * h) +\n        k.xxx * sdfsphere(p + k.xxx * h));\n}\nvec3 calcNormalplane(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdfplane(p + k.xyy * h) +\n        k.yyx * sdfplane(p + k.yyx * h) +\n        k.yxy * sdfplane(p + k.yxy * h) +\n        k.xxx * sdfplane(p + k.xxx * h));\n}\n\nvec3 calcNormalrect(in vec3 p) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1, -1);\n    return normalize(k.xyy * sdfrect(p + k.xyy * h) +\n        k.yyx * sdfrect(p + k.yyx * h) +\n        k.yxy * sdfrect(p + k.yxy * h) +\n        k.xxx * sdfrect(p + k.xxx * h));\n}\nvec3 calcNormal(in vec3 p, float id){\n    if(id>0.9&&id<1.1)\n        return calcNormalsphere(p);\n    else if(id>1.9&&id<2.1)\n        return calcNormalrect(p);\n    else\n        return calcNormalplane(p);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat tri( in float x )\n{\n    float h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\n\nvec3 render(vec2 uv, vec3 camera){\n    mat3 cat = setcamera(vec3(0.,.5,0.),camera,vec3(0.,1.,0.));\n    vec3 color = vec3(.0);\n    vec3 dir = normalize(cat*vec3(uv,1.)-camera);\n    vec2 res = raymarch(camera,dir);\n    float t= res.x;\n    float id = res.y;\n    vec3 light = vec3(0.0, 5., -15.);\n    vec3 ambient_intensity = vec3(50.);\n    vec3 light_intensity = vec3(200);\n    if(t<20.){\n        vec3 p = camera + t * dir;\n        float d = length(light-p);\n        vec3 light_dir = normalize(light-p);\n        float k = 10.0;\n        float vis = softshadow(p,light_dir,.1,20.,k);\n        vec3 n = calcNormal(p,id);\n        vec3 h = normalize(light_dir-dir);\n        if(id>0.1){\n            float ka = 0.005, kd = .5, ks =0.7;\n            float coeff = kd*clamp(dot(n,light_dir),.0,1.)/d/d + ks*pow(clamp(dot(n,h),.0,1.),150.)/d/d;\n            color = vis*coeff*light_intensity+ka*ambient_intensity;\n        }else{\n            vec2 grid = floor(4.*p.xz);\n            float ka = 0.005, kd = 0.23 + .2 * mod(grid.x+grid.y,2.), ks =0.;\n            float coeff = kd*clamp(dot(n,light_dir),.0,1.)/d/d + ks*pow(clamp(dot(n,h),.0,1.),150.)/d/d;\n            color = vis*coeff*light_intensity+ka*ambient_intensity;\n        }\n        float ao = calcAO(p,n);\n        color *= ao; \n        \n    }\n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n\n    // Time varying pixel color\n    /*\n    float d = sdfcircle(uv,.7);\n    vec3 col= 1.-sign(d)*vec3(.5,.5,.5);\n    col *= 1.0 - exp(-3.0*abs(d));\n    col *= 0.8 + 0.2*sin(150.0 *abs(d));\n    */\n    // Output to screen\n    vec3 col = vec3(.0);\n    for(int i=0;i<AA;i++){\n        for(int j=0;j<AA;j++){\n            vec2 offset= 2.*(vec2(float(i),float(j))/float(AA)-.5);\n            vec2 uv = ((fragCoord+offset)/iResolution.xy-0.5)*2.0;\n            col += render(uv,vec3(5.*sin(0.2*iTime),2.0,5.*cos(.2*iTime)));\n        }\n    }\n    fragColor = vec4(col/float(AA*AA),1.0);\n}","name":"Image","description":"","type":"image"}]}