{"ver":"0.1","info":{"id":"tls3Rr","date":"1560450590","viewed":239,"name":"Voronoi texture tunnel","username":"lz","description":"Experiment with applying voronoi texture (with bump maps) to tunnel.\n\n","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","tunnel","normalmaps"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Leon. \n\n   Applied some basic smoothing for anti-aliasing, mostly cosed by normals on edges.\n */\n\nvec3 smoothCol(vec2 uv)\n{\n    vec4 smcol = vec4(vec3(0.), 1.);\n    for (float r = -1.; r < 1.01; r+=1.) {\n        for (float c = -1.; c < 1.01; c += 1.) {\n            \tsmcol += texture(iChannel0, uv + vec2(r, c)/iResolution.xy);\n        }\n    }\n    \n    return smcol.xyz/9.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).xyz;\n    vec3 scol = smoothCol(uv);\n    \n    float lcol = length(scol - col);\n    col = mix(col, scol, lcol*lcol);\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n Tunnel scene calculation.\n\n All hash functions were taken from other shaders.\n */\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\n//uniform sampler2D noise;\nuniform vec2 resolution;\nuniform float time;\n\n\n#define PI 3.14159265359\n#define PI2 6.28318530718\n\n#define red vec3(1.,0.,0.)\n#define yellow vec3(1.,1.,0.)\n#define blue vec3(0.,0.,1.)\n#define white vec3(1.,1.,1.)\n#define ocean vec3(0.,0.6,0.93)\n#define orange vec3(0.9,0.6,0.1)\n\n#define NTS(I,M) texture2D(noise, mod(I,M)/256.).r;\n#define CTR(I,M) (I+vec2(hash(I),hash(I+vec2(3.,23.))))/M\n#define CTC(I) vec2(hash(I),hash(I+vec2(3.,23.)))\n\nfloat hash(in vec2 st) {\nreturn fract(sin(dot(st.xy,\nvec2(12.9898,78.233)))\n* 43758.5453123);\n}\nfloat hash(in float s) {\n  return fract(sin(s*43758.5453123));\n}\n\nfloat hash(in vec3 p)\n{\nreturn fract(sin(dot(p,\nvec3(12.6547, 765.3648, 78.653)))*43749.535);\n}\n\nvec2 ctrr(in vec2 I, in vec2 M) {\nvec2 hix = vec2(I.x,mod(I.y,M.y));\n//https://iquilezles.org/articles/bandlimiting\nvec2 K = (I+vec2(hash(hix)*smoothstep(1.0, 0.5, hix.x),\nhash(hix+vec2(3.,23.))*smoothstep(1.0, 0.5, hix.y)))/M;\n\nreturn K;\n}\n\n\nvec3 getGridCol(vec2 uv) {\n\nfloat rad = length(uv);\nfloat ang = atan(uv.y,uv.x);\n\n  vec2 ar = vec2(rad,ang);\n  float minf[9];\n  vec2 genp[9];\n  vec2 gs = vec2(2.,2.);\n  float gt = 16.;\n\n  vec2 grid = uv*gs;\n  //vec2 angrid = vec2(rad,ang)*gt;\n\n  vec2 fgr = fract(grid);\n  vec2 igr = floor(grid);\n\n  //rg = noise(vec2(rg,rg2));\n  genp[0] = ctrr(igr,gs);\n  minf[0] = length(uv - genp[0]);\n  float pf = smoothstep(0.9,1.,1.-minf[0]);\n\n  genp[1] = ctrr(igr - vec2(-1.,1.),gs);\n  minf[1] = length(uv - genp[1]);\n  genp[2] = ctrr(igr - vec2(-1.,0.),gs);\n  minf[2] = length(uv - genp[2]);\n  genp[3] = ctrr(igr - vec2(-1.,-1.),gs);\n  minf[3] = length(uv - genp[3]);\n  genp[4] = ctrr(igr - vec2(0.,1.),gs);\n  minf[4] = length(uv - genp[4]);\n  genp[5] = ctrr(igr - vec2(0.,-1.),gs);\n  minf[5] = length(uv - genp[5]);\n  genp[6] = ctrr(igr - vec2(1.,1.),gs);\n  minf[6] = length(uv - genp[6]);\n  genp[7] = ctrr(igr - vec2(1.,0.),gs);\n  minf[7] = length(uv - genp[7]);\n  genp[8] = ctrr(igr - vec2(1.,-1.),gs);\n  minf[8] = length(uv - genp[8]);\n\n  float mm = 2.,smm = 2.;\n  vec2 mp, sp;\n  int mini = -1;\n  for (int ip = 0;ip < 9;ip++) {\n    if (minf[ip] < mm) {\n      mm = minf[ip];\n      mp = genp[ip];\n      mini = ip;\n    }\n  }\n\n  float bright = hash(fract(mp));\n\n  for (int ip = 0;ip < 9;ip++) {\n    if (minf[ip] < smm && ip != mini) {\n      smm = minf[ip];\n      sp = genp[ip];\n    }\n  }\n\n  float eps = 0.1;\n  float df = length(uv - sp)-length(uv - mp);\n  float vbeam = step(eps,sqrt(df));\n  float nbeam = smoothstep(0.,eps,(df));\n\n\n  vec3 ccol = vec3((.2*sin(rad*0.4)+0.5),\n    bright*vbeam,nbeam);\n  //vec3 ccol = vec3(mm, 0., 0.);\n\n  return vec3(ccol);\n}\n\n\nfloat noise (in vec2 st, in vec2 m) {\nvec2 i = floor(st);\nvec2 f = fract(st);\n\n// Four corners in 2D of a tile\nfloat a = hash(mod(i,m));\nfloat b = hash(mod(i + vec2(1.0, 0.0),m));\nfloat c = hash(mod(i + vec2(0.0, 1.0),m));\nfloat d = hash(mod(i + vec2(1.0, 1.0),m));\n\n// Smooth Interpolation\n\n// Cubic Hermine Curve. Same as SmoothStep()\nvec2 u = f*f*(3.0-2.0*f);\n// u = smoothstep(0.,1.,f);\n\n// Mix 4 coorners porcentages\nreturn mix(a, b, u.x) +\n(c - a)* u.y * (1.0 - u.x) +\n(d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p,in vec2 m) {\n\n  float f = 0.;\n  float ampl = 0.5;\n  float freq = 1.;\n  float off = 0.;\n\n  for (int i = 0; i < 4; i++) {\n    f += ampl*noise(p*freq + off,m);\n    ampl*= 0.5;\n    freq *= 2.;\n    off += 123.274739;\n  }\n\n  return f;\n}\n\n\nvec3 hsv2rgb(vec3 c) {\n\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n\n}\n\nfloat sdBox( vec3 p, vec3 b, in float r )\n{\n   vec3 d = abs(p) - b;\nreturn length(max(d,0.0)) - r;\n  + min(max(d.x,max(d.y,d.z)),0.0);\n// remove this line for an only partially signed sdf }\n}\n\nfloat circle(in float r, in float s,\n             in float t, in float e) {\n  return r - t;\n}\n\nfloat planet(in vec3 p, out vec3 orig) {\n  vec3 grid = vec3(2.);\n  vec3 q = mod(p - .5*grid,grid) - .5*grid;\n  vec3 fo = floor((p - grid*0.5)/grid);\n  orig = (fo-0.5)*grid;\n  return (length(q) - .5);\n}\n\nvec3 tunnel(in vec3 p) {\n  p.x = 3.*sin(0.0899*p.z)+sin(0.2*p.z);\n  p.y = 5.*sin(0.1*p.z) + sin(0.5*p.z);\n  p.z = 0.;\n\n  return p;\n}\n\n\nfloat tnc(in vec3 p) {\n  vec3 op = p + tunnel(p);\n  return 0.7*(3. - length(op.xy));\n}\n\nvec3 tunnelN(in vec3 p, in float t) {\n  vec3 n;\n  vec2 e = vec2(0.001*t,0.);\n  vec3 op = p;// + tunnel(p);\n  n.x = tnc(op + e.xyy) - tnc(op - e.xyy);\n  n.y = tnc(op + e.yxy) - tnc(op - e.yxy);\n  n.z = tnc(op + e.yyx) - tnc(op - e.yyx);\n\n  return normalize(n);\n}\n\n#define W1 -60.6\n#define W2 -100.\n\n#define W3 -180.\n#define W4 -210.\n\nvec2 fl0(in float d, in float y1,\n  in float y2, in float x1, in float x2) {\n  float ins = abs(step(x1,d) -\n     step(x2,d));\n  float sl = (y2-y1)/(x2 - x1);\n  //float f = abs(sl*d-sl*x1 - y2) + y2;\n  float sgn = sign(x2 - x1);\n  float it = (d*sgn-x1*sgn)/abs(x2 - x1);\n  float f = y1 + it*(y2-y1);\n  float df = sl;\n  return vec2(ins*f,df);\n}\n\nvec2 fl1(in float d, in float y1,\n  in float y2, in float x1, in float x2) {\n  float ins = abs(step(x1,d) -\n     step(x2,d));\n  float sl = (y2-y1)/(x2 - x1);\n  //float f = abs(sl*d-sl*x1 - y2) + y2;\n  float sgn = sign(x2 - x1);\n  float it = smoothstep(x1*sgn,x2*sgn,d*sgn);\n  float f = y1 + it*(y2-y1);\n  float df = sl;\n  return vec2(ins*f,df);\n}\n\n\nvec2 fup(in float d, in float k,\n  in float x1, in float x2) {\n  float diff = x2 - x1;\n  float a = PI2/diff;\n  float b = PI*(x2 - 3.*x1)/diff;\n  float ins = abs(step(x1,d) - step(x2,d));\n  return vec2( k*cos(a*d+b)*ins,-k*a*sin(a*d+b));\n}\n\nvec2 fside(in float d, in float k,\n  in float x1, in float x2) {\n  float diff = x2 - x1;\n  float a = PI2/diff;\n  float b = -PI2*x1/diff;\n  float ins = abs(step(x1,d) - step(x2,d));\n  return vec2(k*sin(a*d+b)*ins,\n               k*a*cos(a*d+b));\n}\n\nvec2 fsidec(in float d, in float k,\n  in float x1, in float x2) {\n  float diff = x2 - x1;\n  float a = PI/diff;\n  float b = -PI*x1/diff;\n  float ins = abs(step(x1,d) - step(x2,d));\n  return vec2(k*cos(a*d+b)*ins,-k*a*sin(a*d+b));\n}\n\nfloat ipl(in float y1, in float y2,\n  in float dy1, in float dy2,\n  in float k, in float x)\n{\n  // x must be relative to intersection\n  // point of y1 and y2, such that x = 0\n  // at intersection.\n\n  float ksq = k*k;\n  float b = (dy2 - dy1)/(4.*k);\n  float d = (y1 + y2)*0.5 - b*ksq;\n\n\n  float aa = (dy1+dy2-(y2-y1)/k)*0.25;\n\n  float a = aa/ksq;\n  float c = (dy1 + dy2)*0.5 - 3.*aa;\n\n  float poly = a*x*x*x + b*x*x + c*x + d;\n\n  float fsec = step(-k,x)*step(0.,k) +\n    step(x,-k)*step(k,0.);\n  float ssec = step(k,x)*step(0.,k) +\n    step(x,k)*step(k,0.);\n\n  float f = poly*(fsec - ssec);\n\n  return f;\n}\n\nfloat ringBump(in vec3 p, out float id) {\n  vec3 bcsys = vec3(0.,-3.,.0);\n  vec3 op = p + tunnel(p);\n\n   //op.z -= 0.3*abs(op.x-bcsys.x);\n   float w1 = op.z - W3;\n   float w2 = W4- op.z;\n   float n = .25;\n   id = (floor((w1 - n)/(5.*n)));\n   op.z = mod(w1 - n,5.*n) - n;\n\n   float r1 = length(op.xy) - 2.9;\n   float f = length(vec2(r1,op.z)) - .3;\n\n   float minb = step(0.,max(w1,w2));\n   f = max(0.,minb + f);\n\n   return 0.7*f;\n}\n\nfloat speedBump(in vec3 p, out float id) {\n  vec3 bcsys = vec3(0.,-3.,.0);\n  vec3 op = p + tunnel(p);\n\n   op.z -= 0.3*abs(op.x-bcsys.x);\n   float w1 = op.z - W1;\n   float w2 = W2 - op.z;\n   float n = .2;\n   id = (floor((w1 - n)/(2.*n+1.)));\n   op.z = mod(w1 - n,2.*n) - n;\n\n  float box = sdBox(op-bcsys,vec3(.8,.2,.1), 0.03);\n  float minb = step(0.,max(w1,w2));\n  float f = max(0.,minb + 0.7*box);\n  return 0.7*f;\n}\n\nfloat spinBump(in vec3 p, in vec4 x,\n  out float id) {\n  float alpha = fl1(p.z,0.,PI2,x.y,x.z).x;\n  vec3 tup = mix(vec3(0.,1.,0.),\n    vec3(-sin(alpha),cos(alpha),0.)\n         ,abs(step(x.y,p.z)-step(x.z,p.z)));\n\n  vec3 bcsys = -3.*vec3(tup);\n  vec3 op = p + tunnel(p);\n   float w1 = op.z - x.y;\n   float w2 = x.z - op.z;\n   float n = .3;\n   id = (floor((w1 - n)/(2.*n)));\n   op.z = mod(w1 - n,2.*n) - n;\n   vec3 v1 = normalize(bcsys);\n   vec3 v2 = cross(vec3(0.,0.,1.),v1);\n   mat3 mtl = mat3(vec3(0.,0.,1.),v2,v1);\n  vec3 opp = op - bcsys;\n  opp = opp*mtl;\n  float box = sdBox(opp,vec3(.2,.8,.1), 0.03);\n  float minb = step(0.,max(w1,w2));\n  float f = max(0.,minb + 0.7*box);\n  return 0.8*f;\n}\n\nfloat tcyl(in vec3 p) {\n  return 0.7*(3.-length(p.xy));\n}\n\nfloat geom(in vec3 p) {\n  //vec3 cyl = p + tunnel(p);\n  float spid;\n  float spd = speedBump(p,spid);\n  float spinid;\n  float spind = spinBump(p,vec4(0.,-120.5,-140.5,0.),\n  spinid);\n  //return min(planet(p,og), 3.-length(cyl.xy));\n  float tun = tnc(p);\n  float rid;\n  float rpd = ringBump(p,rid);\n  return min(min(tun,min(spd,spind)),rpd);\n}\n\nvec3 planetN(in vec3 p, out vec3 orig) {\n  vec3 grid = vec3(2.);\n  vec3 q = mod(p - .5*grid,grid) - .5*grid;\n  vec3 fo = floor((p - grid*0.5)/grid);\n  orig = (fo-0.5)*grid;\n  //orig = fo;\n  return normalize(q);\n}\n\nvec3 tunnelMtl(in float t, in vec3 cyl,\n                   in vec3 p, out vec4 mtl)\n{\n    mtl.w = 1.;\n    vec2 uv = vec2(p.z,.5*atan(p.y,p.x)/PI+0.5);\n    vec3 cl = getGridCol(uv);\n    mtl.rgb = cl.r*hsv2rgb(vec3(0.02+(cl.g-0.5)*0.01,1.,1.-0.5*cl.g));\n    mtl.rgb = mix(mtl.rgb,mtl.gbr,0.5 + 0.5*sin(p.z*0.01));\n    mtl.w = 1.;\n    vec3 tn = tunnelN(mix(cyl, p, 0.5 + 0.5*sin(p.z*0.12)), t);\n    \n    return normalize(tn);\n}\n\nfloat fLightOn(in float z)\n{\n    float ws1 = abs(W1);\n    float we1 = abs(W4);\n    float az = abs(z);\n    \n    float lo = 1. - (smoothstep(ws1 - 25., ws1 - 5., az) - smoothstep(we1 + 5., we1 + 25., az));\n    \n    return lo;\n}\n\n// normal and color.\nvec3 gnorm(in float t, in vec3 o,\n  in vec3 p, out vec4 mtl, out float p_dist) {\n  vec3 cyl = p + tunnel(p);\n  vec3 og;\n  float spid;\n  //float b = planet(p,og);\n  float spd = speedBump(p,spid);\n  float spinid;\n  float spind = spinBump(p,vec4(0.,-120.5,-140.5,0.),\n    spinid);\n  float c = tcyl(cyl);\n  float rid;\n  float rpd = ringBump(p,rid);\n\n  float f = min(min(min(spd,spind),c),rpd);\n   if (f == spd) {\n    mtl.w = 2.;\n    mtl.rgb = clamp(vec3(0.,0.03,.15)*abs(spid)*0.1,0.,1.);\n    float oid;\n    float of = speedBump(o, oid);\n    float viewDist = 8.;\n    //mtl.r += 1.-(clamp(3.*step(viewDist - 3.,\n    //  floor(abs(oid - spid)))*0.3,0.,1.));\n    mtl.rgb *= (1.+3.*float(int(oid) == int(spid+4.)));\n    p_dist = oid - spid;\n  } else if (f == spind) {\n    mtl.w = 3.;\n    mtl.rgb = clamp(vec3(0.,0.03,.15),0.,1.);\n    float oid;\n    float of = spinBump(o,vec4(0.,-120.5,-140.5,0.), oid);\n    float viewDist = 8.;\n    //mtl.r += 1.-(clamp(3.*step(viewDist - 3.,\n    //  floor(abs(oid - spid)))*0.3,0.,1.));\n    mtl.r *= (1.+3.*float(int(oid) == int(spinid+3.)));\n    p_dist = oid - spinid;\n  } else if (f == rpd) {\n    mtl.w = 2.;\n    mtl.rgb = clamp(vec3(0.1,0.03,.25),0.,1.);\n    float oid;\n    float of = ringBump(o, oid);\n    float viewDist = 8.;\n    //mtl.r += 1.-(clamp(3.*step(viewDist - 3.,\n    //  floor(abs(oid - spid)))*0.3,0.,1.));\n    mtl.rgb *= (1.+6.*float(int(oid) == int(rid+3.)));\n\tp_dist = oid - rid;\n  }\n\n  // tunnel normal and color calculation.\n  if (f == c) {\n    vec2 uv = vec2(cyl.z,.5*atan(cyl.y,cyl.x)/PI+0.5);\n    vec3 tn = tunnelMtl(t, cyl, p, mtl);\n    float lightOn = fLightOn(o.z);\n    mtl.rgb *= lightOn;\n    vec2 e = vec2(0.00001*t, 0.);\n    float exptt = exp(-t*t*0.05);\n\t\n    vec3 an;\n    an.x += (getGridCol(uv + e).b - getGridCol(uv - e).b);\n    an.y += (getGridCol(uv + e.yx).b - getGridCol(uv - e.yx).b);\n    an.z += 2.*e.x;\n\n    an = normalize(an);\n\n\n    vec3 ttv = cross(tn,vec3(0.,0.,1.));\n    vec3 tv = normalize(cross(tn,ttv));\n    vec3 tu = normalize(cross(tv,tn));\n\n    tn = mix(tn,mat3(tu,tv,tn)*an,smoothstep(0., 1.,exptt));\n\n    tn = normalize(tn);\n    //mtl.rgb += vec3(1.)*clamp(pow(1.-tn.z*tn.z,32.),0.,1.);\n    return tn;\n  } else {\n    vec3 norm;\n    vec3 e = vec3(0.005*t, 0.0, 0.0);\n    norm.x = geom(p + e.xyy) - geom(p - e.xyy);\n    norm.y = geom(p + e.yxy) - geom(p - e.yxy);\n    norm.z = geom(p + e.yyx) - geom(p - e.yyx);\n      \n    norm = normalize(norm);\n    return norm;\n  }\n}\n\nfloat semax(in float a,\n  in float b, in float c, in float k)\n{\n  float eka = exp(k*a);\n  float ekb = exp(k*b);\n  float ekc = exp(k*c);\n\n  float f = (a*eka + b*ekb + c*ekc)/(eka + ekb + ekc);\n\n  return f;\n}\n\n// c1 interpolation.\nfloat ipl(in float ypre, in float ypost,\n  in float y1, in float y2,\n  in float dy1, in float dy2,\n  in float k, in float x)\n{\n  // x must be relative to intersection\n  // point of y1 and y2, such that x = 0\n  // at intersection.\n\n  float ksq = k*k;\n  float b = (dy2 - dy1)/(2.*k);\n  float d = (y1 + y2)*0.5 - b*ksq;\n\n\n  float aa = (dy1+dy2-y2+y1)*0.25;\n\n  float a = aa/ksq;\n  float c = (y2 - y1)*0.5/k - aa;\n\n  float poly = a*x*x*x + b*x*x + c*x + d;\n\n  float fsec = step(-k,x);\n  float ssec = step(k,x);\n\n  float f = (fsec)*ypre +\n      -(fsec - ssec)*poly + (1.-ssec)*ypost;\n  return f;\n}\n\n\nfloat smoothSin(in float x, in float h,in float x1,\n  in float x2) {\n  float y0 = 0.;\n\n  float py[2];\n  py[0] = x1;\n  py[1] = x2;\n\n  float k = 1.5*sign(py[1]-py[0]);\n  float b = py[0]+k;\n\n  vec2 y1 = fside(x,h,py[0],py[1]);\n  vec2 yk = fside(b,h,py[0],py[1]);\n  vec2 yk2 = fside(py[1]-k,h,py[0],py[1]);\n\n  float fp = ipl(0.,yk.x,0.,yk.y,k,x-py[0]);\n  fp += ipl(yk2.x,0.,yk2.y,0.,k,x-py[1]);\n  fp += y1.x*(step(x,py[0]+k)-step(x,py[1]-k));\n  return fp;\n}\n\nfloat smoothCos(in float x,in float h,in float x1,\n  in float x2) {\n  float y0 = 0.;\n\n  float py[2];\n  py[0] = x1;\n  py[1] = x2;\n\n  float k = 2.5*sign(py[1]-py[0]);\n  float b = py[0]+k;\n\n  vec2 y1 = fsidec(x,h,py[0],py[1]);\n  vec2 yk = fsidec(b,h,py[0],py[1]);\n  vec2 yk2 = fsidec(py[1]-k,h,py[0],py[1]);\n\n  float fp = ipl(1.,yk.x,0.,yk.y,k,x-py[0]);\n  fp += ipl(yk2.x,1.,yk2.y,0.,k,x-py[1]);\n  fp += y1.x*abs(step(x,py[0]+k)-step(x,py[1]-k));\n  fp += step(py[0] - k,x) + step(x,py[1] + k);\n\n  return fp;\n}\n\nfloat downjump(in float z, in vec4 sp1) {\n  float h = 2.5;\n  float k = 3.1*sign(sp1.y-sp1.x);\n  vec2 a = fl1(z,0.,-h,sp1.x,sp1.y);\n  vec2 ak = fl1(sp1.y - k,0.,-h,sp1.x,sp1.y);\n  vec2 b = fup(z,h,sp1.y,sp1.z);\n  vec2 bk = fup(sp1.y + k,h,sp1.y,sp1.z);\n  vec2 ck = fup(sp1.z - k,h,sp1.y,sp1.z);\n  vec2 c =  fl1(z,-h,0.,sp1.z,sp1.w);\n  vec2 dk = fl1(sp1.z + k,-h,0.,sp1.z,sp1.w);\n\n  float f;\n\n  if (z > sp1.y - k)\n     f = a.x;\n  else if (z <= sp1.y + k && z > sp1.z - k)\n     f = b.x;\n  else if (z <= sp1.z + k)\n     f = c.x;\n\n  f += ipl(ak.x,bk.x,ak.y,bk.y,k,z-sp1.y);\n  f += ipl(ck.x,dk.x,ck.y,dk.y,k,z-sp1.z);\n\n  return f;\n}\n\nvec3 motion(in float z) {\n  vec2 op1 = vec2(0.);\n  float k = -1.;\n  float h = 2.5;\n  vec4 sp1 = vec4(-110.,-120.,-140.,-150.);\n\n  //op1.y = downjump(z, sp1);\n  //op1.x = smoothSin(z,2.5,sp1.y,sp1.z);\n\n  return vec3(op1,0.);\n}\n\nvec3 camera(in vec3 o, in vec3 oo,\n            in vec3 d) {\n  vec3 tar = vec3(oo.xy, oo.z - 7.5);\n  tar -= tunnel(tar);\n\n  vec3 dir = normalize(o - tar);\n  vec3 right = cross(vec3(0.,1.,0.),dir);\n  vec3 up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\n\n// trace tunnel only.\nvec2 traceTn(in vec3 o, in vec3 d) {\n  float t = 0.0;\n  float mint = 10.0;\n    \n  for (int i=0;i<256;i++)\n  {\n   vec3 p = o + t*d;\n\n    mint = tnc(p);\n    t += mint;\n\n   if (mint < 0.0001*t || t > 50.) break;\n  }\n    \n  return vec2(t, mint);\n}\n\nvec2 trace(in vec3 o, in vec3 d) {\n  float t = 0.0;\n  float mint = 10.0;\n    \n  for (int i=0;i<512;i++)\n  {\n   vec3 p = o + t*d;\n\n    mint = geom(p);\n    t += mint;\n\n   if (mint < 0.0001*t || t > 50.) break;\n  }\n    \n  return vec2(t, mint);\n}\n\n// adjusting the target and the up vectors.\nvec3 cameraSpin(in vec3 o, in float x1,\n            in float x2, in vec3 oo,\n            in vec3 d) {\n  vec3 tar = vec3(oo.xy, oo.z - 10.);\n  tar -= tunnel(tar);\n  float k = -1.5;\n  float alpha = fl1(o.z,0.,PI2,x1-k,x2+k).x;\n  vec3 tup = mix(vec3(0.,1.,0.),vec3(-sin(alpha),cos(alpha),0.)\n                  ,step(x2+k,o.z)-step(x1-k,o.z));\n\n//  tup = vec3(0.,1.,0.);\n  vec3 dir = normalize(o - tar);\n  vec3 right = cross(normalize(tup),dir);\n  vec3 up = cross(dir,right);\n\n  mat3 view = mat3(right,up,dir);\n  return view*d;\n}\n\n\nconst vec2[] offsets = vec2[4](vec2(.5, .5), vec2(.5, -.5), vec2(-.5, .5), vec2(-.5, -.5));\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    vec2 cnt = vec2(uv - vec2(0.5,0.5));\n    vec3 move;\n    \n\n    uv.x *= ratio;\n\n    \n\tfloat ttime = iTime + 0.0;\n    \n    // basic position\n    float basePos = 3.-ttime*3.2;\n    \n    // velocity change\n    float vel = 1.*smoothstep(0.,1.,(basePos - W1)/(W2 - W1));\n    \n    // origin\n    vec3 o = vec3(0.,0.,basePos - vel*ttime);\n    vec3 oo = o;\n    \n    // tunnel move of the origin.\n    o -= tunnel(o);\n    \n    // camera motion\n    //o += motion(o.z);\n\n\n    vec3 d = normalize(vec3(-1. +2.*uv,-1.));\n\n    d = cameraSpin(o,-120.,-140.,oo,d);\n\n    vec3 l = normalize(vec3(0.,-1.,-1.));\n\tvec3 scol = vec3(0.);\n    for (int i_sample = 0; i_sample < 4; i_sample++)\n    {\n        d.xy += offsets[i_sample] / iResolution.xy;\n        vec2 t = trace(o, d);\n        float t_sum = t.x;\n\t\tvec3 col = vec3(0.);\n        if (t.y < 0.0001*t.x)\n        {\n           vec3 norm;\n           vec3 e = vec3(0.01, 0.0, 0.0);\n           vec3 p = o + t.x*d;\n           vec4 mtl;\n           float p_dist;\n            norm = gnorm(t.x,o,p,mtl, p_dist);\n            col = mtl.rgb;\n            col *= dot(-norm, normalize(d));\n            col += (1.-step(1.5,mtl.w))*clamp(pow(1.-norm.z*norm.z,128.),0.,1.);\n\n            // This is the pattern coloring (arrows, spin and rings).\n            if (bool(step(1.5,mtl.w))) {\n                vec4 smtl;\n                vec3 od = p + d*0.0001*2.;\n                t = traceTn(od, d);\n                t_sum += t.x;\n                p = od + t.x*d;\n                vec2 uv = vec2(p.z,.5*atan(p.y,p.x)/PI+0.5);\n                vec3 cl = getGridCol(uv);\n                vec3 snorm = tunnelMtl(t.x,p + tunnel(p),p,smtl);\n                vec3 scol = smtl.rgb;\n                scol *= dot(-norm, l);\n                scol += clamp(pow(dot(reflect(l,norm),d),8.),0.,1.);\n                float sfact = 4.*pow(clamp(abs(12. - abs(p_dist))/12.,0.,1.),2.);\n                //scol = vec3(pow(clamp(abs(12. - abs(p_dist))/12.,0.,1.),2.));\n                col = mix(scol*sfact, col, clamp(sfact, 0., .45));\n                //col = scol;\n            }\n\n\n        }\n        \n        scol += col;\n    }\n    \n    scol /= 4.;\n    \n    fragColor = vec4(scol, 1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}