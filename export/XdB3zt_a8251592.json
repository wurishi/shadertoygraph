{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct ray_t\n\n{\n\n    vec3 origin;\n\n    vec3 direction;\n\n};\n\n    \n\nstruct sphere_t\n\n{\n\n    vec3 origin;\n\n    float radius;\n\n};\n\n    \n\nstruct plane_t\n\n{\n\n    vec3  normal;\n\n    float offset;\n\n    vec3 orientation;\n\n};\n\n    \n\nstruct light_t\n\n{\n\n    vec3  direction;\n\n    float contribution;\n\n};\n\n \n\nstruct surface_t\n\n{\n\n    int  identifier;\n\n    vec3 position;\n\n    vec3 normal;\n\t\n\tvec2 uv;\n\n};\n\n    \n\nconst int NONE   = 0;\n\nconst int PLANE  = 1;\n\nconst int SPHERE = 2;\n\n    \n\nconst float PI = 3.14;\n\nconst float max_distance = 1e5;\n\n    \n\nfloat intersect_sphere( const in sphere_t sphere, const in ray_t ray, out surface_t surface )\n\n{\n\n    mat4 world_to_object = mat4(\n\n        1.0, 0.0, 0.0, -sphere.origin.x,\n\n        0.0, 1.0, 0.0, -sphere.origin.y,\n\n        0.0, 0.0, 1.0, -sphere.origin.z,\n\n        0.0, 0.0, 0.0, 0.0\n\n    );\n\n    \n\n    vec3 position = vec3( vec4( ray.origin, 1.0 ) * world_to_object );\n\n    \n\n    const float a = 1.0;\n\n    float b = 2.0 * dot( position, ray.direction );\n\n    float c = dot( position, position ) - pow( sphere.radius, 2.0 );\n\n    float h = pow( b, 2.0 ) - 4.0 * a * c;\n\n    \n\n    if( h < 0.0 ) return max_distance; //no intersection\n\n    \n\n    float square_root = sqrt( h );\n\n    float t1 = (-b + square_root) / ( 2.0 * a );\n\n    float t2 = (-b - square_root) / ( 2.0 * a );\n\n    \n\n    if( t1 < t2 )\n\n    {\n\n        surface.position = ray.origin + ray.direction * t1;\n\n    }\n\n    else\n\n    {\n\n        surface.position = ray.origin + ray.direction * t2;\n\n    }\n\n    \n\n    surface.normal = normalize( ( surface.position - sphere.origin ) / sphere.radius );\n\n    \n\n    surface.identifier = SPHERE;\n\t\n\t//float phi = asin(surface.position.y/sphere.radius);\n\t\n\tfloat phi=0.0;\n\t\n\t//phi = acos(surface.position.z /(sqrt(pow(surface.position.x,2.0)+pow(surface.position.z,2.0))));\n\t/*\n\tif(surface.position.x>=0.) phi = acos(surface.position.z /(sqrt(pow(surface.position.x,2.0)+pow(surface.position.z,2.0))));\n\telse if(surface.position.x<0.){\n\tphi=2.*3.14-acos(surface.position.z /(sqrt(pow(surface.position.x,2.0)+pow(surface.position.z,2.0))));\n\t}\t\n\t*/\n\tfloat rho = sphere.radius;\n\tfloat theta = atan(surface.position.x,surface.position.z);\n\tphi= acos(surface.position.y/rho);\n\t\n\t\n\tsurface.uv= vec2((theta+3.14/2.)/3.14,phi/3.14);\n\n    return min( t1, t2 );\n\n}\n\n \n\nfloat intersect_plane( const in plane_t plane, const in ray_t ray, out surface_t surface )\n\n{\n\n    vec3 c = cos( plane.orientation ), s = sin( plane.orientation );\n\n    \n\n    mat3 rotation_x = mat3(\n\n        1.0, 0.0, 0.0,\n\n        0.0, c.x,-s.z,\n\n        0.0, s.x, c.x\n\n    );\n\n    \n\n    mat3 rotation_y = mat3(\n\n        c.y, 0.0,  s.y,\n\n        0.0, 1.0,  0.0,\n\n       -s.y, 0.0,  c.y\n\n    );\n\n    \n\n    mat3 rotation_z = mat3(\n\n        c.z,-s.z,  0.0,\n\n        s.z, c.z,  0.0,\n\n        0.0, 0.0,  1.0\n\n    );\n\n    \n\n    vec3 plane_normal = normalize( plane.normal ) * rotation_x * rotation_y * rotation_z;\n\n    \n\n    vec3 /* normal_by_origin */ no = plane_normal * ray.origin;\n\n    vec3 /* normal_by_direction */ nd = plane_normal * ray.direction;\n\n    float distance_from_origin = ( - no.x - no.y - no.z - plane.offset ) / ( nd.x + nd.y + nd.z );\n\n    \n\n    surface.position = ray.origin + ray.direction * distance_from_origin;\n\n    surface.normal   = plane_normal;\n\n    \n\n    surface.identifier = PLANE;\n\t\n\tsurface.uv = vec2(0.0);\n\n    return distance_from_origin < 0.0 ? max_distance : distance_from_origin;\n\n}\n\n \n\nfloat intersect( const in ray_t ray, out surface_t surface, const in int avoid, in vec4 fragColor )\n\n{\n\n    const sphere_t sphere1 = sphere_t( vec3( 0.0, 0.0, 0.0 ), 1.2 );\n\t\n    const plane_t  plane   = plane_t( vec3( 0.0, 1.0, 0.0 ), 0.6, vec3( PI / 12.0, 0.0, 0.0 ) );\n\n    \n\n    surface_t surface_sphere,surface_plane;\n\n    float distance_from_sphere = intersect_sphere( sphere1, ray, surface_sphere );\n\n    float distance_from_plane  = intersect_plane( plane, ray, surface_plane );\n\t\n\t\n\n    if( ( distance_from_sphere < distance_from_plane ) && ( avoid != SPHERE ) )\n\n    {\n\n        surface = surface_sphere;\n\t\t//fragColor = texture(iChannel0,surface.uv);\n\t\tfragColor=texture(iChannel2,surface.normal);\n    }\n\n    else if( ( distance_from_plane < max_distance ) && ( avoid != PLANE ) )\n\n    {\n\n        surface = surface_plane;\n\t\tsurface.uv.x=surface.position.x;\n\t\tsurface.uv.y=-surface.position.y;\n\t\tfragColor = texture(iChannel1,surface.uv);\n    }\n\t\n\t\n\n    else\n\n    {\n\n        surface.identifier = NONE;\n\n        surface.position   = vec3( 0.0 );\n\n        surface.normal     = vec3( 0.0 );\n\n    }\n\n    \n\n    return min( distance_from_sphere, distance_from_plane );\n\n}\n\n\n\n\nvoid light0_information( const in surface_t surface, out light_t light )\n\n{\n\n          vec3  directional_direction    = vec3( 1.0, 1.0,-0.3 );\n\n    const float directional_contribution = 1.0;\n\n    \n\n    light.direction    = normalize( directional_direction );\n\n    light.contribution = directional_contribution;\n\n}\n\n \n\nvoid light1_information( const in surface_t surface, out light_t light )\n\n{\n\n    const vec3  point_position              = vec3( 0.0, 0.5, 20.0 );\n\n    const float point_contribution_modifier = 0.6;\n\n    \n\n    light.direction    = normalize( point_position - surface.position );\n\n    light.contribution = length( light.direction ) * point_contribution_modifier;\n\n}\n\n \n\nfloat illumination( const in ray_t ray, const in surface_t surface, const in light_t light )\n\n{\n\n    float diffuse = max( 0.0, dot( surface.normal, light.direction ) );\n\n    //vec3 reflected = reflect(ray.direction,surface);\n\t//float specular = pow(dot(normalize(reflected),surface),5000.);\n\n    float contribution = diffuse * light.contribution;\n\n    \n\n    return contribution;\n\n}\n\n \n\nfloat shadow( const in surface_t surface, const in light_t light, in vec4 fragColor )\n\n{\n\n    ray_t shadow_ray;\n\n    shadow_ray.origin    = surface.position;\n\n    shadow_ray.direction = light.direction;\n\n    \n\n    surface_t hitted_surface;\n\n    float distance_from_object = intersect( shadow_ray, hitted_surface, surface.identifier, fragColor );\n\n    \n\n    return ( hitted_surface.identifier != NONE ) ? distance_from_object : max_distance;\n\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n\n    vec2 screen_coordinate          = fragCoord.xy / iResolution.xy;\n\n    vec2 screen_coordinate_centered = 2.0 * screen_coordinate - 1.0;\n\t\n\t//vec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\n    \n\n    \n\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n    vec2  screen_coordinate_lens_corrected = vec2( aspect_ratio, 1.0 ) * screen_coordinate_centered;\n\n    \n\n    ray_t primary_ray;\n\n    primary_ray.origin    = vec3( 0.0, 0.0, mix( 2.0, 3.0, 0.5 + 0.5 * sin( iTime ) ) );\n\n    primary_ray.direction = normalize( vec3( screen_coordinate_lens_corrected, -1.0 ) );\n\n    \n\n    surface_t surface;\n\n    float distance_from_origin = intersect( primary_ray, surface, NONE, fragColor );\n\t\n\n    \n\t\t\t\t\t\t\t\t   \n\n    const vec3 background_color = vec3( 0.3, 0.3, 0.5 );\n\n    if( ( distance_from_origin < max_distance ) && surface.identifier != NONE )\n\n    {\n\n        light_t light;\n\n        float illumination_from_light = float( 0.0 );\n\n        \n\n        light0_information( surface, light );\n\n        float illumination_light0 = illumination( primary_ray, surface, light ); \n\n        //float shadow_cast_light0  = shadow( surface, light ); \n\n        illumination_from_light += illumination_light0; //* clamp( shadow_cast_light0, 0.0, 1.0 );\n\n        \n\n        light1_information( surface, light );\n\n        float illumination_light1 = illumination( primary_ray, surface, light ); \n\n       // float shadow_cast_light1  = shadow( surface, light ); \n\n        illumination_from_light += illumination_light1; //* clamp( shadow_cast_light1, 0.0, 1.0 );\n\n            \n\n        //fragColor = vec4( vec3( illumination_from_light ), 1.0 );\n\t\t//fragColor = vec4(vec3(surface.uv.x,surface.uv.y,0.0),1.0 );\n\t\t  //fragColor = texture(iChannel0,surface.uv);\n\t\t  \n\t\t  \n    }\n\n    else\n\n    {\n\n       // fragColor = vec4( vec3( background_color ), 1.0 );\n\t\tfragColor = texture(iChannel3,surface.uv);\n    } \n\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdB3zt","date":"1399048630","viewed":138,"name":"TestTexture","username":"Cochi","description":"Ras","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["texture"],"hasliked":0,"parentid":"","parentname":""}}