{"ver":"0.1","info":{"id":"ttKfRV","date":"1614714635","viewed":44,"name":"pipe thing","username":"rjeli","description":"pipe thing","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float HFOV = 90.0;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPS = 0.0001;\n\nfloat sphereSDF(vec3 p)\n{\n    return length(p) - 1.2;\n}\n\nfloat cubeSDF(vec3 p)\n{\n    vec3 d = abs(p) - vec3(1.0, 1.0, 1.0);\n    float insideDist = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDist = length(max(d, 0.0));\n    return insideDist + outsideDist;\n}\n\nfloat cylSDF(vec3 p)\n{\n    return length(p.xz) - 0.5;\n}\n\nvec2 smin(float a, float b, float k)\n{\n    float h = max(k-abs(a-b), 0.0) / k;\n    float m = h*h*0.5;\n    float s = m*k*0.5;\n    return (a<b) ? vec2(a-s,m) : vec2(b-s,m-1.0);\n}\n\nfloat sceneSDF(vec3 p)\n{\n    float pipe = smin(cubeSDF(p), cylSDF(p), 0.5).x;\n    float moon = sphereSDF(p - vec3(3.0, 0.0, 0.0));\n    return min(pipe, moon);\n}\n\nvec3 sceneNormal(vec3 p)\n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x+EPS,p.yz)) - sceneSDF(vec3(p.x-EPS,p.yz)),\n        sceneSDF(vec3(p.x,p.y+EPS,p.z)) - sceneSDF(vec3(p.x,p.y-EPS,p.z)),\n        sceneSDF(vec3(p.xy,p.z+EPS)) - sceneSDF(vec3(p.xy,p.z-EPS))\n    ));\n}\n\nfloat distToSurface(vec3 cam, vec3 ray, float start, float end)\n{\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(cam + depth * ray);\n        if (dist < EPS) return depth;\n        depth += dist;\n        if (depth >= end) return end;\n    }\n    return end;\n}\n\n// k_d: diffuse color\n// k_s: specular color\n// alpha: shininess coefficient\n// intensity: color/intensity of the light\nvec3 phongLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 cam, vec3 light, vec3 intensity)\n{\n    vec3 N = sceneNormal(p);\n    vec3 L = normalize(light - p);\n    vec3 V = normalize(cam - p);\n    vec3 R = normalize(reflect(-L, N));\n    // light to surface\n    float dotLN = dot(L, N);\n    // reflection towards viewer\n    float dotRV = dot(R, V);\n    if (dotLN < 0.0) {\n        // light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    }\n    if (dotRV < 0.0) {\n        // reflection is opposite to viewer, apply only diffuse component\n        return intensity * (k_d * dotLN);\n    }\n    return intensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nmat4 lookAt(vec3 cam, vec3 p, vec3 up)\n{\n    vec3 f = normalize(p - cam);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1.0)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.x / tan(radians(HFOV) / 2.0);\n    vec3 ray = normalize(vec3(xy, -z));\n    vec3 cam = vec3(5.0*sin(iTime/5.0), 3.0, 5.0*cos(iTime/5.0));\n    \n    mat4 camToWorld = lookAt(cam, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec3 worldRay  = (camToWorld * vec4(ray, 1.0)).xyz;\n    \n    float dist = distToSurface(cam, worldRay, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPS) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n        return;\n    }\n    \n    vec3 p = cam + dist * worldRay;\n    \n    vec3 k_d = vec3(0.7, 0.2, 0.2);\n    vec3 k_s = vec3(1.0, 1.0, 1.0);\n    \n    // ambient light\n    vec3 color = 0.1 * vec3(1.0, 1.0, 1.0);\n    \n    vec3 light0Pos = vec3(4.0*sin(iTime*2.0), 0.1, 4.0*cos(iTime*2.0));\n    vec3 light0Intensity = vec3(0.4, 0.4, 0.4);\n    color += phongLight(k_d, k_s, 10.0, p, cam, light0Pos, light0Intensity);\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}