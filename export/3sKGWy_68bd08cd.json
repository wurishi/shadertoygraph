{"ver":"0.1","info":{"id":"3sKGWy","date":"1570874670","viewed":500,"name":"making minmax quadtree for free","username":"FabriceNeyret2","description":"right: luminance.\n\nleft: green = min in #LOD cells, \n        blue = max in #LOD cells.\n       red = average.\n -> colored blocks where max-min is large.\n\n( should better store video at source resolution, for big MIPmap levels yield num issue in fullscreen)","likes":8,"published":3,"flags":32,"usePreview":0,"tags":["minmax","gpmipmap","bbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LOD 4.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O.ra = texture(iChannel0, U/R).ra;\n    \n    if (U.x < R.x/2.) {\n        //O.gb = texture(iChannel0, U/R, LOD+log2(R.y/O.a)).gb;\n        int l = int(max(0.,LOD+log2(R.y/O.a)));\n        O.gb = texelFetch(iChannel0, ivec2(U)>>l, l).gb;\n        O.gb *= exp2(2.*float(l));                    // convert MIPmap average to sum \n        \n        O.g = pow( O.g,-1./POW );                     // this approximates MIN\n        O.b = pow( O.b, 1./POW );                     // this approximates MAX\n      //O.g *= exp2(-2.*float(l)/POW);                    // convert MIPmap average to sum \n      //O.b *= exp2( 2.*float(l)/POW);                    // convert MIPmap average to sum \n        O.r = (O.g+O.b)/2.;\n    }\n    else O = O.rrrr;                                  // right: luminance only\n    \n    O = pow( O, vec4(1./2.2) );                       // back to sRGB\n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 O, vec2 U )\n{\n    O.r = length( texture(iChannel0, U/R).rb ) / 1.3;\n    O.r = pow( O.r, 2.2 );            // sRGB to flat (was it necessary ?)\n    O.g = pow( O.r,-POW );            // this approximates MIN\n    O.b = pow( O.r, POW );            // this approximates MAX\n    O.a = iChannelResolution[0].y;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define POW 10.  // the larger the better min/max, but more bigfloats precision issues\n\n#define R  (iResolution.xy)\n","name":"Common","description":"","type":"common"}]}