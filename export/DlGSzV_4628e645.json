{"ver":"0.1","info":{"id":"DlGSzV","date":"1686195416","viewed":127,"name":"A LiveWallpaper","username":"MartinRGB","description":"a simple test,normal map shader from https://www.shadertoy.com/view/4ss3W7.my article about this effect:https://martinrgb.github.io/blog/#/Namedrop_Animation","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["livewallpaper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//---------------------------------------------------------------------------------\n\n\n#define ENABLE_LIGHTING\n#define ENABLE_SPECULAR\n\n#define OFFSET_X 2\n#define OFFSET_Y 2\n#define DEPTH\t 4.\n\nvec3 texsample(const int x, const int y, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy ;\n\tuv = (uv + vec2(x, y)) / u_resolution.xy;\n\treturn texture(iChannel0, uv).xyz;\n}\n\nfloat luminance(vec3 c)\n{\n\treturn dot(c, vec3(.2126, .7152, .0722));\n}\n\nvec3 normal(in vec2 fragCoord)\n{\n\tfloat R = abs(luminance(texsample( OFFSET_X,0, fragCoord)));\n\tfloat L = abs(luminance(texsample(-OFFSET_X,0, fragCoord)));\n\tfloat D = abs(luminance(texsample(0, OFFSET_Y, fragCoord)));\n\tfloat U = abs(luminance(texsample(0,-OFFSET_Y, fragCoord)));\n\n\tfloat X = (L-R) * .5;\n\tfloat Y = (U-D) * .5;\n\n\treturn normalize(vec3(X, Y, 1. / DEPTH));\n}\n\n\nvec3 mainImage(in vec2 fragCoord)\n{\n\tvec3 n = normal(fragCoord);\n\n#ifdef ENABLE_LIGHTING\n    bool mousePressed = iMouse.z > 0.0;\n    vec2 lp_pos;\n    if(mousePressed)\n    {\n        lp_pos = iMouse.xy;\n    }\n    else{\n        lp_pos = vec2(iResolution.x*(0.25 + (cos(iTime)+1.)/2. * 0.5),iResolution.y*((sin(iTime)+1.)/2. * 1.));\n    }\n\tvec3 lp = vec3(lp_pos, 200.);\n\tvec3 sp = vec3(fragCoord.xy, 0.);\n\n\tvec3 c = texsample(0, 0, fragCoord) * dot(n, normalize(lp - sp));\n\n#ifdef ENABLE_SPECULAR\n    float e = 64.;\n    vec3 ep = vec3(fragCoord.xy, 100.);\n\tc += pow(clamp(dot(normalize(reflect(lp - sp, n)),\n\t\t\t\t\t   normalize(sp - ep)), 0., 1.), e);\n#endif /* ENABLE_SPECULAR */\n\n#else\n\tvec3 c = min(0.0,n);\n\n#endif /* ENABLE_LIGHTING */\n\n\treturn c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec2 uv = fragCoord/iResolution.xy;\n    if(uv.x > 0.25 && uv.x<0.75){\n        fragColor = vec4(mainImage(vec2(fragCoord.x,fragCoord.y)),1.0);\n    }\n    else{\n        fragColor = vec4(0.);\n    }\n    \n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//###################Utils###################\n\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),sin(_angle),cos(_angle));\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,0.0,_scale.y);\n}\n\nfloat easeOutCubic(float t) {\n    return (t = t - 1.0) * t * t + 1.0;\n}\n\n\nfloat noise(vec2 uv) {\n  return fract(sin(dot(uv.xy ,vec2(532.1231,1378.3453))) * 53211.1223);\n}\n//###################Shaping Function###################\nfloat circle(in vec2 mFragCoord,in vec2 mPosition, in float mRadius){\n\n    vec2 dist = (mFragCoord - mPosition) ;\n\n\n    float circleShape = (1.-smoothstep(mRadius-(mRadius*0.01),\n                         mRadius+(mRadius*0.01),\n                         dot(dist,dist)*2.0) );\n\n\n    float circle1stAlpha = circleShape ;\n\n\n    return smoothstep(0.,0.1,circle1stAlpha);\n}\n\nfloat circleBlur(in vec2 _st, vec2 p,in float _radius,in float _radius2){\n    vec2 dist = _st-p;\n\treturn 1.-smoothstep(_radius-1.120,\n                         _radius+0.232,\n                         dot(dist,dist)*_radius2);\n}\n\nfloat circleShadow(in vec2 mFragCoord,in vec2 mPosition, in float mRadius,in float mShadowZ){\n\n    vec2 dist = (mFragCoord - mPosition) ;\n\n\n    float circleShape = smoothstep(mRadius+(mRadius*(mShadowZ*(mFragCoord.x))),\n                         mRadius-(mRadius*0.01),\n                         dot(dist,dist)*2.0);\n\n\n    float circle1stAlpha = circleShape;\n\n    //Circle Blur\n    //method 1\n    return smoothstep(0.,0.9,circle1stAlpha);\n\n    //method 2\n    //return length(mFragCoord-mPosition);\n}\n\n\nvec3 circleColor(in vec2 mFragCoord,in vec2 mPosition,vec3 mStartColor,vec3 mEndColor,float mAngle){\n\n\n    mFragCoord -= mPosition;\n    mFragCoord = rotate2d( (mAngle/180.)*PI ) * mFragCoord;\n    mFragCoord += mPosition;\n\n    float mColorX = (mFragCoord.x - mPosition.x + 0.5 );\n    float mColorY = (mFragCoord.y - mPosition.y + 0.5 );\n    vec3 startColor = mStartColor/255.;\n    vec3 endColor = mEndColor/255.;\n\n    vec3 circleColor = vec3(startColor.r*(1.-mColorX)+mColorX*endColor.r,startColor.g*(1.-mColorX)+mColorX*endColor.g,startColor.b*(1.-mColorX)+mColorX*endColor.b);  //渐变跟随\n\n    return circleColor;\n}\n\n\n\nfloat rect(in vec2 mFragCoord,in vec2 mPosition,in vec2 mSize,in float mAngle) {\n\n\n  vec2 d = abs((mFragCoord-mPosition) * rotate2d( (mAngle/180.)*PI )) - mSize;\n\n\n\n  float fd = min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n\n  return smoothstep(0.000001,0.,fd);\n}\n\nfloat rectBlur(in vec2 mFragCoord,in vec2 mPosition,in vec2 mSize,in float mAngle,in float mBlur) {\n\n\n  vec2 d = abs((mFragCoord-mPosition) * rotate2d( (mAngle/180.)*PI )) - mSize;\n\n\n\n  float fd = min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n\n  return smoothstep(mBlur, -0.99 / u_resolution.x, fd);\n}\n\nfloat rectShadow(in vec2 mFragCoord,in vec2 mPosition,in vec2 mSize,in float mAngle,in float mBlurZ){\n\n    vec2 d = abs((mFragCoord-mPosition) * rotate2d( (mAngle/180.)*PI )) - mSize;\n\n\n    float fd = min(max(d.x, d.y), 0.) + length(max(d,0.0));\n\n    //Shadow Blur\n    return smoothstep(mBlurZ, -0.21 / u_resolution.x, fd);\n}\n\n\nvec3 rectColor(in vec2 mFragCoord,in vec2 mPosition,vec3 mStartColor,vec3 mEndColor,float mAngle){\n\n    mFragCoord -= mPosition;\n    mFragCoord = rotate2d( (mAngle/180.)*PI ) * mFragCoord;\n    mFragCoord += mPosition;\n\n    float mColorX = (mFragCoord.x - mPosition.x + 0.5 );\n    float mColorY = (mFragCoord.y - mPosition.y + 0.5 );\n    vec3 startColor = mStartColor/255.;\n    vec3 endColor = mEndColor/255.;\n\n    vec3 circleColor = vec3(startColor.r*(1.-mColorX)+mColorX*endColor.r,startColor.g*(1.-mColorX)+mColorX*endColor.g,startColor.b*(1.-mColorX)+mColorX*endColor.b);  //渐变跟随\n\n    return circleColor;\n}\n\nvec3 multipleColor(in vec2 mFragCoord,in vec2 mPosition,in vec2 mSize,in vec3 mColor1,in vec3 mColor2,vec3 mColor3,vec3 mColor4,in float mAngle){\n    mFragCoord -= mPosition;\n    mFragCoord = rotate2d( (mAngle/180.)*PI ) * mFragCoord;\n    mFragCoord += mPosition;\n\n    mFragCoord = mFragCoord - mPosition + mSize.y ;\n    vec3 color1 = mColor1/255.;\n    vec3 color2 = mColor2/255.;\n    vec3 color3 = mColor3/255.;\n    vec3 color4 = mColor4/255.;\n\n    //method 1\n    vec3 gradientColor = vec3(color1 +  (mFragCoord.y/(1.7*mSize.y*1.132))  *(color2 - color1) + (mFragCoord.y/(1.7*mSize.y*1.132))  *(color3 - color2)  + (mFragCoord.y/(1.7*mSize.y*1.132))  *(color4 - color3)   );\n    gradientColor = max(vec3(0.),min(vec3(1.),gradientColor));\n\n    vec3 rectColor = vec3( gradientColor);\n\n\n    return rectColor;\n\n}\n\n\n\nfloat rect(vec2 p, vec2 size) {\n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\n\n vec3 vectorColor(vec2 mFragCoord,vec2 mResolution,vec2 startP,vec2 endP,vec3 startColor,vec3 endColor){\n  \tvec2 Start = startP*mResolution;\n     vec2 End = endP*mResolution;\n     vec2 V = End - Start;\n\n     float s = dot(mFragCoord.xy-Start, V) / dot(V, V); // Vector projection.\n     s = clamp(s, 0.0, 1.0); // Saturate scaler.\n     vec3 color = mix(startColor, endColor, s); // Gradient color interpolation.\n     //color = pow(color, vec3(1.0/2.2)); // sRGB gamma encode.\n\n     return color;\n\n }\n\n//###################Draw Function###################\nvec3 drawShape(in vec2 uv) {\n    vec2 st = uv;\n    float convertUnit = u_resolution.x;\n\n    float u_screen_value2 = u_screen_value -1.;\n    vec2 real_mouse=iMouse.xy/iResolution.xy;\n    vec2 u_mouse;\n    if(real_mouse.x > 0.25 && real_mouse.x<0.75){\n        u_mouse.x = real_mouse.x*2.-1.;\n        u_mouse.y = real_mouse.y;\n    }\n\n    //1.Attribute\n    float bXPosition = 0.202 +(0.328-0.202)*u_screen_value -u_mouse.x/12.; //0.488 //+ u_screen_value //-.680 //+ (-0.680+0.904)*u_screen_value\n    float bYPosition = -1.284 + (-0.546 + 1.284)*u_screen_value + u_mouse.y/10.; //0.5 //+(0.5 - 0.356)*u_screen_value\n    float bXShadowPosition = 0.202 + (0.2- 0.202)*u_screen_value  -u_mouse.x/16.;  //+ u_screen_value //-.680\n    float bYShadowPosition = -1.084 +(-0.546 + 1.084)*u_screen_value + u_mouse.y/14.; //0.5\n    float bAngle = -50. + (-41.+50.)*u_screen_value + 0.25*sin(0.); //-42.\n    float bShadowAngle = -50. + (-41.+50.)*u_screen_value + 0.25*sin(0.); //-42.\n    float bZScale = 20.;\n\n    float rXPosition = -1.544 + (-0.18+1.544)*u_screen_value  -u_mouse.x/13.; //+0.5 -0.5 * u_screen_value //-0.24\n    float rYPosition = 0.79+ (0.925-0.79)*u_screen_value + u_mouse.y/11.; //0.925\n    float rXShadowPosition = -1.544 + (-0.2+1.544)*u_screen_value  -u_mouse.x/26.; //+0.5 -0.5 * u_screen_value //-0.24\n    float rYShadowPosition = 0.69+ (0.925-0.69)*u_screen_value +  u_mouse.y/22.;  //0.925\n    float rAngle = 16. + (27.-16.)*u_screen_value + 1.*sin(0.) - u_mouse.y  + u_mouse.x; //30.\n    float rShadowAngle = 15. +(27.-10.)*u_screen_value + 1.*sin(0.) + u_mouse.y -u_mouse.x; //35.\n    float rBlurFix = 0.14 + (0.105 - 0.14)*u_screen_value;\n    float rZScale = 20.;\n\n    float mColorAngle = -0.;\n\n    float mShadowZ = max(0.06,min(0.5,0.5  - u_mouse.x/5.+u_mouse.y/5.));\n    float mShadowAlpha = min(0.25,max(0.05,0.08  + u_mouse.x/7.-u_mouse.y/7.))  ;\n\n    float rShadowZ = max(0.06,min(0.3,0.08  +u_mouse.x/8.+u_mouse.y/8.));\n    float rShadowAlpha = min(0.22,max(.05,.15 -u_mouse.x/6.-u_mouse.y/6.)) ; //0.1\n\n    float bShadowZ = max(0.06,min(0.3,0.18  -u_mouse.x/6.+u_mouse.y/6.)); //0.06\n    float bShadowAlpha = min(0.18,max(.05,.08  -u_mouse.x/6.+u_mouse.y/6.))  ; //+ abs(u_sensor_x*0.05) + abs(u_sensor_y*0.05)\n\n    float blurSize = 0.06; //0.05\n    float noiseSize = 0.25; //0.2\n\n    float bAlpha = 1.;\n    float rAlpha = 0.7; //0.6\n    float mCircleAlpha = 0.7; // 0.7\n    float lAlpha = 1.0;\n\n\n    float mBorderAlpha = 0.2 ;\n    float rBorderAlpha = 0.15 ;\n    float bBorderAlpha = 0.15 ;\n\n\n    float mXPosition,mYPosition,mXShadowPosition,mYShadowPosition;\n\n    //入场  //1.440 2.281\n    float mStartX = 1.240; //1.540\n    float mStartY = 2.581; //2.581\n\n    if(u_orig_orientation == 0  ){\n\n        //####正常的圆\n        mXPosition = mStartX + (0.729-mStartX)*u_screen_value ; // - u_sensor_x/10. //0.537  //\n        mYPosition = mStartY+ (1.997-mStartY)*u_screen_value +0.01 + 0.01*sin(0.) ; // - u_sensor_y/10. //1.948\n        mXShadowPosition = mStartX + (0.729-mStartX)*u_screen_value +0.01*sin(0.); //  //0.537\n        mYShadowPosition = mStartY + (1.997-mStartY)*u_screen_value - 0.01 *sin(0.); //  //1.948\n\n    }\n    //拖动\n    else if(u_orig_orientation == 1){\n\n        u_screen_value2 *= 1.2;\n        //####相切滚动的圆\n        float mXXPosition = (0.729-mStartX)*u_screen_value2   ;\n        float mYYPosition = (1.997-mStartY)*u_screen_value2    ; //1.947-2.531\n        float changeVector=  mYYPosition*sin((90.+bAngle)/180.*PI)+ mXXPosition*cos((90.+bAngle)/180.*PI) ;\n        vec2 mVectorChangedValue = vec2(changeVector*sin((90.+bAngle)/180.*PI),-changeVector*cos((90.+bAngle)/180.*PI));\n\n        mXPosition = mStartX + (0.729-mStartX) + (.328-.202)*u_screen_value2 - mVectorChangedValue.x*1.-u_mouse.x/14.;\n        mYPosition = mStartY+ (1.997-mStartY) + (-.546+1.084)*u_screen_value2 - mVectorChangedValue.y*1.+0.01 +0.01*sin(0.) + u_mouse.y/12.;\n\n        float mXXShadowPosition = (0.729-mStartX)*u_screen_value2 ;\n        float mYYShadowPosition = (1.997-mStartY)*u_screen_value2    ;\n        float changeVector2=  mYYShadowPosition*sin((90.+bAngle)/180.*PI)+ mXXShadowPosition*cos((90.+bAngle)/180.*PI) ;\n        vec2 mVectorChangedValue2 = vec2(changeVector2*sin((90.+bAngle)/180.*PI),-changeVector2*cos((90.+bAngle)/180.*PI));\n\n        mXShadowPosition = mStartX + (0.729-mStartX) + (.328-.202)*u_screen_value2 - mVectorChangedValue2.x*1. +0.01*sin(0.) -u_mouse.x/18.; //  //0.537\n        mYShadowPosition = mStartY+ (1.997-mStartY) + (-.546+1.084)*u_screen_value2 - mVectorChangedValue2.y*1. -0.01*sin(0.)  + u_mouse.y/16.; //  //1.948\n\n    }\n\n    float pxStart= 0.354;  //1.754\n    float pxEnd = .78;\n    float pyStart =-1.104;\n    float pyEnd = -.204;\n    float pHeight = 3.2;\n    float paStart = 20.;\n    float paEnd = 14.;\n\n    vec2 circleBlurPosition;\n    //vec2 circleBlurPosition = vec2(1.99+(1.29-1.99)*u_screen_value,1.07+(0.870-1.07)*u_screen_value); //vec2(1.290,0.870)\n    float circleBlurRadius = 1.6 + (2. - 1.6)* u_screen_value; //2.\n\n    float mPositionX,mPositionY,mRectAngle,mRectWidth;\n\n    mPositionX = pxStart + (pxEnd-pxStart)*u_screen_value;\n    mPositionY = pyStart + (pyEnd-pyStart)*u_screen_value;\n    mRectAngle = paStart+ (paEnd-paStart)*u_screen_value;\n    circleBlurPosition = vec2(-1.99+(1.29+1.99)*u_screen_value,-1.07+(0.870+1.07)*u_screen_value); //vec2(1.290,0.870)\n\n    mRectWidth = 1.25;\n\n    float mRectHeight = pHeight;\n\n    float mRectShape = rect(st,vec2(mPositionX,mPositionY),vec2(mRectWidth,mRectHeight),mRectAngle);\n    float mCircleBlur = circleBlur(st,circleBlurPosition,.9,circleBlurRadius);\n\n    vec3 mColor1 = vec3(220,68,68); // 220 68 68\n    vec3 mColor2 = vec3(235,94,94);\n    vec3 mColor3 = vec3(251,121,121);\n    vec3 mColor4 = vec3(177,50,50); //255 127 127\n    vec3 mRectColor = multipleColor(st,vec2(mPositionX,mPositionY),vec2(mRectWidth,mRectHeight),mColor1,mColor2,mColor3,mColor4,-mRectAngle-90.);\n\n\n    //2.中\n    //Construct\n    vec2 bPosition = vec2(bXPosition,bYPosition);\n    vec2 bSize = vec2((3000.+bZScale*sin(0.))/3000.,2000./1080.);\n\n    vec3 bEndColor = vec3(1.,0.77,0.5)*255.;\n    vec3 bStartColor = vec3(0.99,0.19,0.17)*255.;\n\n    float bRectTop = rect(st,bPosition,bSize,bAngle);\n    vec3 bRectColor = rectColor(st,bPosition*0.01,bStartColor,bEndColor,bAngle);\n\n    //Border\n    vec3 bBorderColor = vec3(1.,1.,1.);\n    float bBorderWidth = 1.5;\n\n    float bRectTopBorder = rect(st,bPosition,bSize - vec2(bBorderWidth/u_resolution.x),bAngle);\n    bRectTopBorder = bRectTop - bRectTopBorder;\n\n    //Shadow\n    vec3 bShadowColor = vec3(0.,0.,0.);\n    //float bShadowAlpha = .15;\n\n    float bRectShadow = rectShadow(st,vec2(bXShadowPosition+0.04,bYShadowPosition+0.04),bSize,bShadowAngle,bShadowZ*1.5);\n    vec3 bRectShadowColor = rectColor(st,vec2(bXShadowPosition-0.028,bYShadowPosition-0.057),bShadowColor,bShadowColor,0.);\n\n    //3.上\n    //Construct\n    vec2 rPosition = vec2(rXPosition,rYPosition);\n    vec2 rSize = vec2((2000.+rZScale*sin(0.))/3000.,1800./1080.);\n    vec3 rStartColor = vec3(0.,0.27,0.91)*255.;\n    vec3 rEndColor = vec3(0.36,0.48,1.)*255.;\n\n    float rRectTop = rect(st,rPosition,rSize,rAngle);\n    vec3 rRectColor = rectColor(st,rPosition,rStartColor,rEndColor,rAngle-90.);\n\n    //Border\n    vec3 rBorderColor = vec3(1.,1.,1.);\n    float rBorderWidth = 1.5;\n\n    float rRectTopBorder = rect(st,rPosition,rSize - vec2(rBorderWidth/u_resolution.x),rAngle);\n    rRectTopBorder = rRectTop - rRectTopBorder;\n\n    //Shadow\n    vec3 rShadowColor = vec3(255.,43.,43.);\n    //float rShadowAlpha = 0.1; //0.1\n\n    float rRectShadow = rectShadow(st,vec2(rXShadowPosition-0.00,rYShadowPosition-0.057),rSize,rShadowAngle,rShadowZ);\n    vec3 rRectShadowColor = rectColor(st,vec2(rXShadowPosition-0.028,rYShadowPosition-0.057),rShadowColor,rShadowColor,0.);\n\n    //4.圆\n\n    //Construct\n    float mRadius = 2015./1080.*1.;\n    vec2 mPosition = vec2(mXPosition,mYPosition);\n\n    vec3 mEndColor = vec3(0.,0.95,0.48)*255.;\n    vec3 mStartColor = vec3(0.,0.8,0.84)*255.;\n\n\n    float mCircle = circle(st,mPosition,mRadius) ;\n    vec3 mCircleColor = circleColor(st,mPosition+vec2(0.2,0.1),mStartColor,mEndColor,mColorAngle);\n\n    //Border\n    vec3 mBorderColor = vec3(1.,1.,1.);\n    float mBorderWidth = 8.;\n\n    float mCircleBorder = circle(st,mPosition,mRadius - mBorderWidth/u_resolution.x);\n    mCircleBorder = mCircle - mCircleBorder;\n\n    //Shadow\n    vec3 mShadowColor = vec3(0.,0.,0.);\n    //float mShadowAlpha = 0.15;\n\n    float mCircleShadow = circleShadow(st,vec2(mXShadowPosition-0.01,mYShadowPosition),mRadius,mShadowZ) ;\n    vec3 mCircleShadowColor = circleColor(st,vec2(mXShadowPosition-0.028,mYShadowPosition-0.161),mShadowColor,mShadowColor,0.);\n\n    //5.Clip\n    float blurPartTop = rRectTop * mCircle;\n    float blurPartBottom = rRectTop *bRectTop;\n    float blurPartTopShadow = rRectShadow *mCircle;\n    float blurPartBottomShadow = bRectShadow *rRectTop;\n    float blurPartTopBoder = rRectTopBorder * mCircle;\n    float blurPartBottomBorder = rRectTop *bRectTopBorder;\n\n    float blurTop = rectBlur(st,rPosition+vec2(blurSize/2.,rBlurFix+0.04),rSize,rAngle,blurSize) * mCircle ;\n    float blurBottom = rectBlur(st,bPosition+vec2(blurSize/2.,-0.06),bSize,bAngle,blurSize-0.015) * rRectTop;\n\n    bRectTopBorder -= blurPartBottomBorder;\n    rRectTopBorder -= blurPartTopBoder;\n    bRectTop -= blurPartBottom;\n    rRectTop -= blurPartTop;\n    rRectShadow -= blurPartTopShadow;\n    bRectShadow -= blurPartBottomShadow;\n\n    mRectShape = mRectShape - mRectShape*bRectTop;\n\n    //noise\n    mRectShape += mRectShape*noise(st)*noiseSize*0.2;\n    mCircleBlur += mCircleBlur*noise(st)*0.2;\n\n    mCircle += mCircle*noise(st)*noiseSize*0.3;\n    mCircleShadow += mCircleShadow*noise(st)*0.2 ;\n\n    rRectTop += rRectTop*noise(st)*noiseSize*0.3;\n    rRectShadow += rRectShadow*noise(st)*0.2;\n\n    bRectTop += bRectTop*noise(st)*noiseSize*0.2;\n    blurTop += blurTop*noise(st)*noiseSize*0.3;\n    bRectShadow += bRectShadow*noise(st)*0.2;\n\n    //Redefine Red Shadow\n    //bRectShadow -= bRectShadow*lRectTop;\n    //rRectShadow = rRectShadow * bRectTop;\n    //mCircleShadow = mCircleShadow * rRectTop;\n\n    //s1.\n    float rRectShadow2 = rectShadow(st,vec2(rXShadowPosition+0.04,rYShadowPosition),rSize,rShadowAngle,rShadowZ*2.);\n    float rRedDeleteShadow = rRectShadow - rRectShadow*bRectTop -rRectTop;\n    rRectShadow -= rRedDeleteShadow;\n\n    //s2.\n    float rRedShadow = rRectShadow2 - rRectShadow2*bRectTop - rRectTop - mCircle;\n    float rRedShadowAlpha = rShadowAlpha *1.5;\n\n    //s13\n    float mCircleShadow2 = circleShadow(st,vec2(mXShadowPosition,mYShadowPosition),mRadius,mShadowZ*2.) ;\n    float mRedDeleteShadow = mCircleShadow - mCircleShadow*rRectTop -mCircle;\n    mCircleShadow -= mRedDeleteShadow;\n\n    float mRedShadow = mCircleShadow2 - mCircleShadow2*rRectTop-mCircle ;\n    float mRedShadowAlpha = mShadowAlpha *1.5;\n\n    rRectShadow2 += rRectShadow2*noise(st)*0.4;\n    rRedShadow += rRedShadow*noise(st)*0.4;\n    mCircleShadow += mCircleShadow*noise(st)*0.4;\n    mRedShadow += mRedShadow*noise(st)*0.4;\n\n    //6.Mix\n\n    vec3 color;\n\n    vec3 blurBottomColor = vec3(1.150,0.43,0.197);\n    vec3 blurTopColor = vec3(0.029,0.097,0.400); //vec3(0.041,0.117,0.400)\n\n    vec3 newShadowColor = vec3(150./255.,26./255.,18./255.);\n\n    color = vec3(0.);\n\n    color = mix(color,mRectColor,mRectShape  );\n\n\n    color = mix(color,vec3(255./255.,161./255.,161./255.),  mCircleBlur * 0.47);\n    color = mix(color,newShadowColor,rRedShadow*rRedShadowAlpha );\n    color = mix(color,newShadowColor,mRedShadow*mRedShadowAlpha);\n\n    color = mix(color,newShadowColor,bRectShadow*bShadowAlpha * 1.5);\n    color = mix(color,bRectColor,bRectTop*bAlpha );\n\n    vec3 vecColor = vectorColor(gl_FragCoord.xy,u_resolution.xy,vec2(0.),vec2(0.5,0.5),vec3(90./255.,35./255.,23./255.),vec3(255./255.,80./255.,63./255.)*1.2);\n\n    vecColor = pow(vecColor, vec3(2.4/2.2)); // sRGB gamma encode.\n\n    color = mix(color,vecColor,blurBottom*1.2); //* min(1.2,st.x*1.8)*1.5\n    color = mix(color,blurBottomColor* st.x*1.5,blurBottom * 0.8 );\n    color = mix(color,bBorderColor,bRectTopBorder*bBorderAlpha );\n\n    color = mix(color,rRectShadowColor,rRectShadow*rShadowAlpha );\n    color = mix(color,vec3(0.,0.,0.),rRectShadow *0.1 );\n    color = mix(color,rRectColor,rRectTop*rAlpha);\n    color = mix(color,blurTopColor,blurTop*0.9 );\n    color = mix(color,rBorderColor,rRectTopBorder*rBorderAlpha );\n\n    color = mix(color,mShadowColor,mCircleShadow*mShadowAlpha );\n\n    mCircleColor = pow(mCircleColor, vec3(2.0/2.2));\n    color = mix(color,mCircleColor,mCircle*mCircleAlpha);\n    color = mix(color,mBorderColor,mCircleBorder*mBorderAlpha );\n    color = mix(color,bRectShadowColor,bRectShadow*bShadowAlpha   *u_total_alpha*u_total_alpha);\n\n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float totalAlpha = u_total_alpha;\n    vec3 shape;\n    vec2 uv = fragCoord/iResolution.xy;\n    //if(fragCoord.x > 0.33* iResolution.x && fragCoord.x < 0.66* iResolution.x)\n    //shape = drawShape(vec2(fragCoord.x*3.+iResolution.x,fragCoord.y/3.)) ;\n\n    //fragColor =  vec4(shape*totalAlpha,1.0);\n    if(uv.x > 0.25 && uv.x<0.75){\n        //fragColor = vec4(vec2((uv.x*3.-1.),uv.y),1.,1.);\n        shape = drawShape(vec2((uv.x*3.-0.75),uv.y*u_resolution.x/u_resolution.y)) ;\n    }\n    //fragColor = vec4(uv,1.,1.);\n    fragColor =  vec4(shape*totalAlpha,1.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define u_resolution iResolution\n#define u_time iTime\n#define u_screen_value 1.\n#define u_total_alpha 1.\n#define u_orig_orientation 1\n\n#define PI 3.14159265359","name":"Common","description":"","type":"common"}]}