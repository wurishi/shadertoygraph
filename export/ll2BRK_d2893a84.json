{"ver":"0.1","info":{"id":"ll2BRK","date":"1516585892","viewed":126,"name":"Dabbling with reflection","username":"Axioplase","description":"Raytracer with reflections.\nI'm not sure why there's noise on the sphere when I increase the number of times my ray bounces.\nI also unsuccessfully tried to make the reflection go away as the ball was far away from the plane.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SPHERE 0\n#define PLANE 1\n    \nstruct sphere_t {\n    // int id;\n    vec3 center;\n    float radius;\n    vec3 colour;\n    float reflectivity;\n};\n\nstruct plane_t {\n    vec3 p0;\n    vec3 normal;\n    vec3 colour;\n    float reflectivity;\n\n};\n\nstruct hit_t {\n    vec3 hitPos;\n    vec3 normal;\n    int hitKind; // SPHERE or PLANE\n};\n\nsphere_t sphere;\nplane_t plane;\nfloat pi = 3.14159265;\n\nvoid castRay(in vec3 orig, in vec3 direction, in plane_t plane, inout hit_t store) {  \n    float distanceFromOrigin = dot((plane.p0 - orig), plane.normal) / dot(direction, plane.normal);\n    if (distanceFromOrigin > 0.) {\n        if (distanceFromOrigin < length(store.hitPos - orig)) {\n            store.hitKind = PLANE;\n            store.hitPos = orig + direction*distanceFromOrigin;\n            store.normal = plane.normal;\n        }\n    }\n}\n\nvoid castRay(in vec3 orig, in vec3 direction, in sphere_t sphere, inout hit_t store) {  \n    vec3 l = sphere.center - orig;\n    float ta = dot(l, direction);\n    \n    if (ta <= 0.) { //sphere.radius) {\n        return; // we're inside the sphere, or it's behind us. Let's ignore.\n    }\n    \n    float d = sqrt(dot(l,l) - ta*ta);\n        \n    if (d >= sphere.radius) {\n        return; // no intersection\n    }\n    \n    vec3 proj = orig + direction*ta; // This is the projection of center on ray.\n    \n    float distFromProjSoThatOnSphere = sqrt(sphere.radius * sphere.radius - d*d);\n    vec3 vectorsToIntersections = direction*distFromProjSoThatOnSphere;\n    vec3 intersection1 = proj - vectorsToIntersections; // closer\n    vec3 intersection2 = proj + vectorsToIntersections;\n    vec3 bestHit;\n  \tbestHit = intersection1;\n    \n    float distanceToOrigin = length(bestHit - orig);\n    if (distanceToOrigin < length(store.hitPos - orig)) {\n        store.hitKind = SPHERE;\n        store.hitPos = bestHit;\n        store.normal = normalize(bestHit - sphere.center);\n    }\n}\n\nvec3 colourAt(in vec3 direction, in hit_t hit) {\n    switch (hit.hitKind) {\n        case SPHERE:\n        // return sphere.colour * exp(dot(direction, hit.normal)); // cool too.\n        return sphere.colour * -min(0., dot(direction, hit.normal));\n        case PLANE:\n        return texture(iChannel0,vec2(sin(iTime)+hit.hitPos.z/10., cos(iTime)+hit.hitPos.x/10.)).rgb;\n    }\n}\n\nfloat lerp(float a, float b, float x) {\n    return (1.-x)*a + x*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= .5; // center\n    uv.x *= iResolution.x / iResolution.y;\n    \n    fragColor = vec4(0.);\n    fragColor.w = 1.;\n    \n    vec3 camera = vec3(2.*sin(iTime), 10.+4.*sin(iTime), 8.+2.*cos(iTime));\n    vec3 lookAt = vec3(0., 2., 2.);\n    vec3 f = normalize(lookAt - camera);\n    vec3 r = cross(vec3(0.,1.,0.), f);\n    vec3 u = cross(f, r);\n    float zoom = 2.0;\n    vec3 center = camera + f * zoom;\n    vec3 i = center + uv.x*r + uv.y*u;\n    vec3 direction = normalize(i - camera);\n\n    ///////////////////////////\n    sphere.radius=1.;\n     sphere.colour=vec3(lerp(0.3, 0.5, (1.+cos(iTime/2.))), lerp(0.2,0.7, 0.6*(1.+sin(iTime))), lerp(0.3, .8, 0.4*(1.+sin(iTime))));\n    //sphere.colour=vec3(.7);\n    sphere.center=vec3(0., sin(iTime*2.)+1.+sphere.radius, 1.0);\n    sphere.reflectivity=.7;\n\n    plane.p0 = vec3(0., 0., 0.);\n    plane.normal = vec3(0., 1., 0.);\n    plane.colour=vec3(0., 0., 1.);\n    plane.reflectivity=.4;\n\n    ///////////////////////////\n    \n    hit_t closest;\n    closest.hitPos = vec3(1e3); // far away    \n    castRay(camera, direction, plane, closest);\n    castRay(camera, direction, sphere, closest);\n    \n    // there was no hit, so return the backgroud\n    if (closest.hitPos == vec3(1e3)) {\n        return;\n    }\n\n    // there was a hit\n    vec3 hitPos = closest.hitPos;\n    vec3 normal = closest.normal;\n    \n    // ambient?\n    fragColor.xyz = colourAt(direction, closest);\n    \n    // add a reflection. Light can bounce 'bounce' times!\n    hit_t origin = closest;\n    vec3 lastDirection = direction;\n    vec3 lastNormal = normal;\n    float runningDistance = length(hitPos - camera);\n    \n    int bounce;\n    for (bounce = 0; bounce < 4; bounce++) {\n    \n        hit_t refHit;\n        refHit.hitPos=vec3(1e3);\n        vec3 reflection = lastDirection - 2.*dot(lastDirection, lastNormal) * lastNormal;\n        if (closest.hitKind == SPHERE) {\n            castRay(origin.hitPos, reflection, plane, refHit);\n        } else {\n            castRay(origin.hitPos, reflection, sphere, refHit);\n        }\n\n        // there was no hit, so return the background\n        if (refHit.hitPos == vec3(1e3)) {\n            return;\n        }\n\n        vec3 colourAt1 = colourAt(reflection, refHit);\n        runningDistance += length(refHit.hitPos - origin.hitPos);\n        colourAt1 *= 22./runningDistance;\n\n        // There must be a way to reduce reflection of stuff that's far, but I couldn't get that to work...\n        vec3 addition = (origin.hitKind == SPHERE ? sphere.reflectivity : plane.reflectivity) *\n            .2 * colourAt1 ;\n        // float dist = length(refHit.hitPos - origin.hitPos);\n        fragColor.xyz += addition/float((bounce+1)*(bounce+1));     \n        \n        origin = refHit;\n        lastDirection = reflection;\n        lastNormal = refHit.normal;\n    }    \n}","name":"Image","description":"","type":"image"}]}