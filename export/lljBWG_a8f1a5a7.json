{"ver":"0.1","info":{"id":"lljBWG","date":"1517063867","viewed":653,"name":"LessWrongUnormBoxFilter","username":"TimothyLottes","description":"less wrong unorm box filter","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["filter","box"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//\n// EXAMPLE OF LESS-BAD UNORM BOX FILTER (AKA STANDARD MSAA RESOLVE)\n//\n// Usage case\n//  - Having traditional LDR RGB output for MSAA into RGBA8 UNORM surface\n//  - Want a 4xMSAA or 8xMSAA box filter (say because users want the traditional \"look\")\n//  - Want to avoid the worst non-linear average artifacts (false extra edge)\n//  - While preserving the perceptual 4 or 8 step edge gradient\n//\n// Left side is \"less-bad\" box resolve\n//  - Read from an sRGB view of the RGBA8 UNORM surface\n//  - Write to an sRGB view of the RGBA8 UNORM output\n//  - Use a custom resolve kernel\n//  - Which darkens the linear box average to something similar to the perceptual box average\n//  - While maintaining the linear box average's correct color\n//\n// Right side is standard MSAA resolve for RGBA8 UNORM data (non-linear average)\n//  - See artifact of dark line where red and green meet\n//\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n//--------------------------------------------------------------\nF1 Linear1(F1 c){return(c<=0.04045)?c/12.92:pow((c+0.055)/1.055,2.4);}\nF3 Linear3(F3 c){return F3(Linear1(c.r),Linear1(c.g),Linear1(c.b));}\nF1 Srgb1(F1 c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nF3 Srgb3(F3 c){return F3(Srgb1(c.r),Srgb1(c.g),Srgb1(c.b));}\n\n\n#define XX 64.0\n#define YY (XX*(iResolution.y/iResolution.x))\n\n// Raster one sample with output in linear color-space.\nF3 Raster(F2 uv2){\n // Rotate\n F1 ang=(iTime*(1.0/75.0))*2.0*3.14159;\n uv2.xy=F2(dot(uv2.xy,F2(cos(ang), sin(ang))),\n           dot(uv2.xy,F2(sin(ang),-cos(ang))));\n // Edge\n F1 scale=8.0;\n F1 which=fract(iTime*(1.0/4.0));\n // Switch colors over time\n F3 color0=F3(1.0,0.0,0.0);\n F3 color1=F3(0.0,1.0,0.0);\n if(which<0.25){\n  color0=F3(0.0,0.0,0.0);\n  color1=F3(1.0,1.0,1.0);}\n else if(which<0.5){\n  color0=F3(1.0,1.0,0.0);\n  color1=F3(0.0,0.0,1.0);}\n else if(which>0.75){\n  color0=F3(1.0,0.5,0.25);\n  color1=F3(0.124,0.25,0.5);}\n return fract(uv2.x*scale)>0.5?color0:color1;}\n\n// 4xMSAA box filter done the wrong way (standard MSAA resolve)\nF3 RasterP(F2 uv2){\n // Samples as generated in linear-space\n F3 c0=Raster(uv2+(F2(-2.0,-6.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c1=Raster(uv2+(F2( 6.0,-2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c2=Raster(uv2+(F2(-6.0, 2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c3=Raster(uv2+(F2( 2.0, 6.0)/F2(16.0,16.0))/F2(XX,YY));\n // As stored to sRGB render target\n c0=Srgb3(c0);\n c1=Srgb3(c1);\n c2=Srgb3(c2);\n c3=Srgb3(c3);\n // Return box filter average of non-linear\n return c0*0.25+c1*0.25+c2*0.25+c3*0.25;}\n \n    \n    \n// 4xSGSSAA box filter done the \"less wrong\" way\nF3 RasterP2(F2 uv2){\n // Samples as generated in linear-space\n // Stored to sRGB target then loaded from sRGB target\n // Meaning getting back linear data from LoadSample\n F3 c0=Raster(uv2+(F2(-2.0,-6.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c1=Raster(uv2+(F2( 6.0,-2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c2=Raster(uv2+(F2(-6.0, 2.0)/F2(16.0,16.0))/F2(XX,YY));\n F3 c3=Raster(uv2+(F2( 2.0, 6.0)/F2(16.0,16.0))/F2(XX,YY));\n // Get luma\n // Using a quick approximation here {0.5,0.25,0.25}\n // Can also use a proper metric\n F1 l0=c0.g*0.5+c0.r*0.25+c0.b*0.25;   \n F1 l1=c1.g*0.5+c1.r*0.25+c1.b*0.25;   \n F1 l2=c2.g*0.5+c2.r*0.25+c2.b*0.25;   \n F1 l3=c3.g*0.5+c3.r*0.25+c3.b*0.25;\n // Linear box of luma * 4 (removes a 0.25 scale factor later)\n F1 ll=l0+l1+l2+l3;\n // Convert sample luma's to perceptual   \n // Using gamma 2.0 here because it is fast\n // Can also use the proper color space transform (slower)\n l0=sqrt(l0);\n l1=sqrt(l1);\n l2=sqrt(l2);\n l3=sqrt(l3);\n // Get perceptual box\n F1 lb=l0*0.25+l1*0.25+l2*0.25+l3*0.25;\n // Convert back to linear (undo prior gamma 2.0 conversion)\n lb*=lb;\n // Scale output linear box average by adjustment factor (0.25 scale factored prior)\n F1 s=lb/ll;\n F3 cc=c0*s+c1*s+c2*s+c3*s;\n // Shadertoy is RGBA8UNORM (instead of sRGB format) so do conversion.\n return Srgb3(cc);}\n\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n fragColor.a=1.0;\n F2 uv=fragCoord.xy/iResolution.xy;\n // Make \"low res\"\n F2 uv2=uv;\n uv2.x*=XX;\n uv2.y*=YY;\n uv2.x=floor(uv2.x)+0.25;\n uv2.y=floor(uv2.y)+0.25;\n uv2.x/=XX;\n uv2.y/=YY;\n // Line\n if(abs(uv.x-0.5)<0.01){fragColor.rgba=F4(0.0,0.0,0.0,1.0);}\n // Split screen\n else if(uv.x<0.5){\n  fragColor.rgb=RasterP2(uv2);  \n }else{\n  fragColor.rgb=RasterP(uv2);}}","name":"Image","description":"","type":"image"}]}