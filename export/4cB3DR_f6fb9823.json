{"ver":"0.1","info":{"id":"4cB3DR","date":"1704217080","viewed":186,"name":"WFC Key Dungeon 3D","username":"spalmer","description":"prototype for idea suggested by ollj:\na procedural map (wavefunctioncollapse 'dungeon' in this case) that has 3 (color coded) keys that fit 3 locked doors.\n3D prototype.  Multi-level-capable map.  ESDF+arrows.\nearly WIP.  Stairs don't really work yet.","likes":24,"published":1,"flags":48,"usePreview":0,"tags":["procedural","3d","game","key","firstperson","dungeon","door","lock","wfc"],"hasliked":0,"parentid":"4fS3Rh","parentname":"WFC Key Dungeon 2D"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// by spalmer 2024\n\n// early WIP\n// I plan to do more but it's at feature parity\n// with 2D toy now, perfectly functional,\n// may as well public, can improve with forks.\n// stairs are next!\n\n// try ESDF or arrows to move\n// spacebar or mouse for map\n// backspace or escape if you get really stuck\n\n// be sure to start the Soundcloud in Buffer B iChannel3, for mood!\n// pick any song you like.\n\n// riffing on an idea ollj suggested in a comment somewhere\n// that has stuck with me:  random dungeon with keys to\n// locked doors!  Now, this *should* be fairly interesting,\n// compared to simple 'maze' or whatever.  More fun!\n// So idk absolute best way to proceed, might try few things.\n// But the initial idea for this toy is to take ollj's idea,\n// generate 3 key locations (R,G,B) maybe keycode can be\n// some rgb bitmask here, to support more keys in future.\n// but plan on only using 3 of them for now.\n// Probably generate using WFC wavefunctioncollapse algorithm.\n// That seems to do well with these sort of problems.\n// My plan is to place the keys (& locks?) in a way that the dungeon\n// generates outwardly from the keys (& locks).\n// There will be constraints that navigable floorspace\n// may only be connected by similarly color-coded paths.\n// and such paths can only connect to other colors at the\n// corresponding lock which joins those colors.\n// I have more ideas about the toy.  I would like there\n// to be at least two, possibly four, layers to the dungeon,\n// connected by stairs.  Extra confusing.  Muwahahah.\n// not simply color coding the layers, though.\n// perhaps keys might be distributed through the layers somehow.\n// just having the floors isolated just seems weak.\n\n// Should also be first-person traversable.\n\n// I've seen some really cool WFC examples so should be able to \n// make some interesting sort of dungeon to explore.\n// this one isn't so great yet.  WFC Great Wall looks more interesting.\n\n// can start with something like Crumby Maze or maybe\n// Plumbing Maze but probably need 3D toy.  Walk Camera maybe.\n// Hedges Maze.  I did lots of early maze toys, some never\n// saw light of day.  Walk Camera is probably furthest along.\n// Still needs work on the collision though.\n\n// So would need a buffer for the player camera controls,\n// a buffer for the dungeon, an 'image' tab to show it all.\n// could render offscreen and use postprocessing, probably good idea,\n// to use something to make fullscreen performant.  Like upscaling from\n// Lights, Camera, Action!\n// the player must keep track of which keys have been obtained!\n\n// this one will have a much more complicated tileset,\n// with 3D connectivity, walls and floors that have color coding,\n// doors (some locked!) and flights of stairs.\n// doors must switch from 'locked' to 'unlocked'/'open' state.\n\n// Ideally would utilize some sort of stacking of 'bricks' like\n// http://shadertoy.com/view/7tVBWw (private) for the rendering of walls/floors.\n// and it seems a good idea to do some sort of ray-voxel DDA\n// traversal to trace the scene, maybe start with http://shadertoy.com/view/wdsfWn\n\n// does not wait for the dungeon to be fully constructed before allowing exploration;\n// any 'invalid' areas will behave unpredictably.\n// rn if you go there you'll probably go into limbo or get launched!\n\n// post-processing; Buffer B has rendering, state\n\n#define Source iChannel1\n#define SRes iChannelResolution[1]\n\nconst float blursize = .09;\n\n// FIXME something wrong with aspect ratio in fullscreen\nvec4 T(vec2 uv)\n{\n    const vec4 bgCol = vec4(vec3(.02), 1);\n    if (!all(greaterThanEqual(uv, vec2(0))) || !all(lessThan(uv, vec2(1)))) return bgCol;\n    vec4 c = texture(Source, uv);\n    //c = vec4(pow(c.rgb, vec3(useGamma)), c.a);\n    return c;\n}\n\n// anamorphic diffraction spike bloom\n// from Sparkly Britney http://shadertoy.com/view/ct3fDs\n// make bright stuff glow more\n\n// lateral filter blur of image\n// ch is which texture channel to use\n// uv is texcoord of query\n// v should be the axis the filter applies along (usually vec2(1,0) or vec2(0,1))\n// w is blur width\nvec4 lateral(vec2 uv, vec2 v, float w)\n{\n    // n is half number of taps (not counting center tap)\n    int n = int(.9 * blursize * min(maxRes, SRes.y));\n    vec4 t = T(uv);\n    for (int i = n; i > 0; --i) {\n        float f = float(i)/float(n);\n        float s = exp2(-24. * f * f);\n        vec2 m = f * w * v;\n     \tt = max(t, T(uv + m) * s);\n        t = max(t, T(uv - m) * s);\n    }\n\n    t.rgb = pow(clamp(1. * (t.rgb - vec3(.45,.31,.09)), 0., 1.), vec3(2.)); // threshold\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 r = iResolution.xy, or = SRes.xy;\n    r *= min(r.y, maxRes) / r.y; // limit\n    if (all(lessThan(fragCoord, vec2(1)))) fragCoord = vec2(1.5); // use neighbor of data pixel instead\n    vec2 uv = fragCoord * r / or;\n    //uv = floor(uv) + smoothstep(0., 1., fract(uv)); // 'bicubic'\n    uv /= or;\n    vec3 c = textureLod(Source, uv, 0.).rgb; // bilinear upscale\n    //vec3 c = T(fc).rgb;\n #if 0\n    vec2 ra = iResolution.xy        \n    , rs = SRes.xy;\n    rs *= min(rs.y, maxRes) / rs.y; // limit\n    // carefully unstretch to preserve aspect ratio (borked in fullscreen)\n    vec2 fc = (fragCoord - .5*ra) * vec2(rs.y / rs.x,1.) * 1. / ra.y + .5;\n\n    vec3 bloom; // sum 3 spikes\n    bloom = lateral(fc\n        , vec2(1,0)\n        , blursize\n        ).rgb;\n    bloom += lateral(fc\n        , vec2(.5, .866)\n        , blursize * .8\n        ).rgb;\n    bloom += lateral(fc\n        , vec2(.5, -.866)\n        , blursize * .8\n        ).rgb;\n    c += .5 * bloom;\n #endif\n    // TODO further post-processing; maybe dirt mask or ...\n    c *= 1.15 / (c + .18); // Reinhard tonemap, gamma OETF\n    c -= .02 * texelFetch(iChannel2, ivec2(fragCoord) & 1023, 0).g; // blue noise dither hardcoded size to 1023 not iChannelResolution[2].xy-1\n    fragColor = vec4(c, 1);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float kb(int kc) \n{ \n    return step(.5, texelFetch(iChannel3, ivec2(kc,0), 0).x);\n}\n// consult keyboard in iChannel3 // http://keyjs.dev \n\nTile LoadTile(ivec3 p)\n{\n    return LoadTile(iChannel0, iChannelResolution[0].xy, p);\n}\n\nbool Match(ivec3 a, ivec3 b)\n{\n    //return a.y == b.y; // ignore the corners, only check edges\n    //return a == b.zyx;\n    return (a & 1) == (b.zyx & 1); // ignore door flag\n}\n\nbool Fits(Tile c, in Tile[4] n)\n{\n    if (c.def == tBlank || c.def == tInvalid)\n        return false;\n    //if (c.def == tDeadEnd || c.def == tBars) \n    //    return false; // HACK exclude whichever tile,\n        // but dead ends break the connectivity of the game way too frequently.\n        // some might prefer the maze without bars, as it was originally.\n        // they're fairly chaotically placed.\n    bool r = true, anyconnectionvalid = false;\n    // prevent spontaneously generates cells with 'new' colors\n    // just, whereever it's allowed to on far side of walls.\n    // the colors must flood fill from existing colors, not just be 'made up'\n    // so now we check anyconnectionvalid\n    for (int j = 0; j < 4; ++j) {\n        Tile nj = n[j];\n        if (nj.def == tInvalid || nj.def == tBlank) \n            continue; // ignore these\n        ivec3 ec = Edge(c.def, j + c.rot), en = Edge(nj.def, j + nj.rot + 2);\n        if (!Match(ec, en)) {\n            r = false;\n            break;\n        }\n        if (c.def == tDoorLock || c.def == tDoorOpen) {\n            // doors have different color connectivity constraints,\n            // allow 1 color higher on one side\n            if (ec.y == 2) { // side with door connects to next area\n                if (nj.col != (c.col == 4 ? 7 : (c.col << 1))) {\n                    r = false;\n                    break;\n                } else anyconnectionvalid = true;\n            }\n            else if (ec.y == 0) {\n                // locked side neighbor must be the same color\n                if (c.col != nj.col) {\n                    r = false;\n                    break;\n                } else anyconnectionvalid = true;\n            }\n        } else { \n            // don't care about where walls are, but where floors connect,\n            if (ec.y == 0) {\n                // the neighbor must be the same color\n                // unless it's a door!\n                if (en.y == 2) {\n                    if (c.col <= nj.col) {\n                        r = false;\n                        break;\n                    }\n                    else anyconnectionvalid = true;\n                } else\n                if (c.col != nj.col) {\n                    r = false;\n                    break;\n                } else anyconnectionvalid = true;\n            }\n        }\n        // if we can't determine a color because there's no connectivity,\n        // should not really be placing this tile anyway, so just say doesn't fit.\n    }\n    if (!anyconnectionvalid)\n        return false;\n    return r;\n}\n\nvoid WaveFunctionCollapse(inout Tile t, ivec3 p)\n{\n    if (isSeed(t.def))\n        return; // can't change it!\n    uint h = hash(uint((p.x + 71*p.y)^p.z^iFrame*777^int(iDate.w)));\n    // load neighbor tiles\n    Tile n[4]; // TODO [6] also vertical!\n    n[0] = LoadTile(p + ivec3(-1,0,0));\n    n[1] = LoadTile(p + ivec3(0,0, 1));\n    n[2] = LoadTile(p + ivec3( 1,0,0));\n    n[3] = LoadTile(p + ivec3(0,0,-1));\n    \n    if (n[0].def == tInvalid \n     || n[1].def == tInvalid \n     || n[2].def == tInvalid \n     || n[3].def == tInvalid)\n             if (~h*17u >  232333771u)\n            t.def = tBlank; // if any neighbor is tInvalid, there's a chance we can change back to tBlank\n        //else if (h*7u < 0x00000fffu)\n        //    t.def = tInvalid; // smaller chance of even becoming invalid ourselves thus spreading the reset\n    // first must determine whether can leave existing tile as is\n    bool invalid = t.def == tInvalid || t.def == tBlank;\n    if (!invalid) {\n        if (!Fits(t, n))\n           invalid = true;\n    }\n    if (!invalid)\n        return; // all good!\n    if (true && invalid /*&& t.def != tBlank*/ && (h&(15u << 5)) == 0u) { //h*61u < 56280999u) {\n        t.def = tInvalid; return;\n    }\n    // doors can only connect same or lesser color codes somehow\n    // the red key is found in the red area, etc.\n    // doors then simply let you into the 'next color' area.\n    \n    if (!invalid)\n        if (t.def != tInvalid)\n            return; // we already generated a tile, and it's valid, so done here!  hopefully!\n    if (n[0].def <= tInvalid \n     && n[1].def <= tInvalid \n     && n[2].def <= tInvalid \n     && n[3].def <= tInvalid)\n        return; // can only update if at least some of the neighbors are valid/non-blank\n    // starting with a random kind and rotation, find the first tile that fits here if there is one\n    int zero = min(0, iFrame);\n    for (int k = zero + 4 * 8 * tTotal; k-- > 0; ) {\n        int j = int((uint(k) + h) % uint(4 * 8 * tTotal));\n        Tile tj = FromFloat(float(j));\n        if (//tj.col != 0 && \n            tj.col != 1 && tj.col != 2 && tj.col != 4 && tj.col != 7)\n            continue; // allow only certain colors for now\n        if (tj.def != tInvalid && tj.def != tBlank)\n            if (!isSeed(tj.def)) {\n                if (Fits(tj, n))\n                    t = tj;\n                    //t.col = 0; // temp no colors for now\n            }\n    }\n    // if couldn't find any match, probably should switch to invalid\n    // else probably just stay invalid or blank\n    //if (invalid)\n    if (t.def == tBlank)\n        t.def = tInvalid; // switch to invalid to flag neighbors that they may want to change\n}\n// FIXME be aware that tInvalid can result in destruction and rewriting\n// of the passages in a way that makes getting to the exit impossible.\n// It's also possible for the generation to proceed in such a way that\n// one color gets blocked in by another and cannot reach its corresponding key\n// or something; in anything real, this would need to be detected and corrected somehow,\n// some rejection/failure/timeout handling, make it start over until gets it right.\n// or just cheat and carve a valid path through afterwards somehow.\n\nvec4 LoadState()\n{\n    return texelFetch(iChannel0, ivec2(0), 0);\n}\n\nvoid TileLogic(inout Tile t, ivec3 p) // TODO maybe just track tile id as 3D ivec3\n{\n    vec4 gamestate = LoadState();\n    vec3 playerpos = gamestate.xyz;    // player location from Buffer B\n    int haskeys = int(gamestate.w);\n    bool nearplayer = length(playerpos - vec3(p) - .5) < .7; // TODO optimize\n    bool hasthiskey = (t.col & haskeys) == t.col;\n    if (nearplayer) {\n        // game logic:\n        // if you go to where a key is, you acquire it, it changes to an empty floor.\n        // if you go to where a door is, if you have the proper key, it changes to a open door state \n        // (hall didn't work because caused invalid color connection)\n        switch (t.def) {\n            case tKey:\n                if (hasthiskey) // wait for key to be taken first\n                    t.def = tFloor;\n                break;\n            case tDoorLock:\n                if (hasthiskey) // only if have required key\n                    t.def = tDoorOpen; \n                break;\n        }\n        if (kb(8) > .5)\n            t.def = tInvalid; // must be stuck, redo this part\n    }\n//    if (p.x < 3 && p.z < 3)\n//        t.def = tStairs, t.col = 1 << p.y; // HACK\n}\n// keys don't get used up, there could be multiple doors of a color, \n// but only one guards another key or leads to another color floor.\n\nTile Init(ivec3 p)\n{\n    Tile t;\n    t.def = tBlank; //tInvalid;\n    t.col = 0;\n    int scramble = p.x * 127 + p.z * 49 + p.y * 65535;\n    // FIXME uh, I have a hash() function!\n    t.rot = int(256. * sin(float(scramble))) & 3;\n    // init 3 key locations and 3 locked door locations,\n    // one for each color code.  those are the dungeon seeds.\n    // TODO might need a 'win' exit location too.\n    // And a start.\n    // so at the start you need no keys, color for that area is now red (1)\n    ivec2 seeds[8];\n    //for (int i = seeds.length(); i-- > 0; ) seeds[i] = random2() % ivec2(iChannelResolution[0]);\n    // TODO ensure all 5 are unique and not right next to each other or duplicated\n    // HACK to get started, I'll just pick some locations by hand:\n    seeds = ivec2[8] ( \n        ivec2(20, 15), // the start\n        ivec2(25, 10), // red key\n        ivec2(30, 20), // red door\n        ivec2(40, 25), // green key\n        ivec2(55, 40), // green door\n        ivec2(75, 15), // blue key\n        ivec2(85, 44), // blue door\n        ivec2(98, 48)  // the end\n    );\n    #if 0\n    // randomize the seed locations (slightly) but not the start location, or I'd have to match elsewhere\n    // idk why but it kills my doors!! FIXME\n    for (int j = seeds.length() - 1; j-- > 1; )\n        seeds[j] = seeds[j] + ivec2(3. * sin(vec2(acos(0.), 0) + float(hash(uint(scramble + j)) & 0xfffffu)));\n    #endif\n    ivec2 mz = MazeSize(iChannelResolution[0].xy);\n    for (int j = seeds.length(); j-- > 0; )\n        seeds[j] = seeds[j] * mz / ivec2(100,50);\n    // lame hacky logic, wah\n         if (p.xz == seeds[0]) t = Tile(tFloor,1<<0, t.rot);\n    else if (p.xz == seeds[1]) t = Tile(tKey,  1<<0, t.rot);\n    else if (p.xz == seeds[2]) t = Tile(tDoorLock, 1<<0, 3);\n    else if (p.xz == seeds[3]) t = Tile(tKey,  1<<1, t.rot);\n    else if (p.xz == seeds[4]) t = Tile(tDoorLock, 1<<1, 3);\n    else if (p.xz == seeds[5]) t = Tile(tKey,  1<<2, t.rot);\n    else if (p.xz == seeds[6]) t = Tile(tDoorLock, 1<<2, 0);\n    else if (p.xz == seeds[7]) t = Tile(tExit, 7, t.rot);\n    return t;\n}\n\nvoid Update(inout Tile t, ivec3 p)\n{\n    int f = iFrame;\n    bool won = false;\n    //const int slow = 0; //5; //\n    //if ((~f % (1 << slow)) != 0) return;\n    //f >>= slow;\n    if (((p.x ^ p.y ^ p.z ^ f) & 1) != 0) { // neighbors take turns updating on alternate ticks\n        WaveFunctionCollapse(t, p);\n        TileLogic(t, p);\n        won = LoadState().w < 0.; // TODO check iResolution changes\n    }\n    if (iFrame < 2 || won) \n        t = Init(p);\n}\n\nvoid PlayerMove(inout vec4 state, vec4 mouse, float dt)\n{\n    // ESDF or arrow keys\n    vec2 mv = vec2(max(kb(70), kb(39)) - max(kb(83), kb(37)), \n                   max(kb(69), kb(38)) - max(kb(68), kb(40)));\n    mat3 cam = Camera(iMouse, iResolution.xy, iTime);\n    if (iMouse == vec4(0))\n        mv = vec2(0,.2); // attract mode    \n    mv = (cam * vec3(mv,0).xzy).xz;\n    float keys = state.w;\n    vec3 pos = state.xyz;\n    float ehb = .2;\n    pos.y -= ehb;\n    // TODO should be able to navigate with either keyboard or mouse\n    const float speed = 3.;\n    pos.xz += speed * mv * dt;\n    pos.y -= .3 * dt; // 'gravity' without velocity\n    // need collision\n    for (int i = IZERO + 2; i-- > 0; ) {\n        vec3 q = pos;\n        vec3 gs = gScene1(iChannel0, iChannelResolution[0].xy, q, 2e-2, IZERO);\n        float d = dScene1(iChannel0, iChannelResolution[0].xy, q).x;\n        if (dot(gs, gs) > 1e-8)\n            q -= min(0., d - 1.*playerradius) * normalize(gs);\n        pos = q;\n    }\n    pos.y = max(pos.y, .25);\n    pos.y = min(pos.y, 3.5);\n    pos.y += ehb;\n    // TODO lowpass filter to put camera at eye height above floor\n    //pos.y = mix(pos.y, floorpos.y + eyeheight, exp2(-6.*dt));\n    if (length(state - vec4(pos, keys)) > 1e-3) // only if state changed measurably (prevent sliding around due to collision/normal numerical imprecision)\n        state = vec4(pos, keys);\n}\n\n// manage key inventory\nvoid GameLogic(inout vec4 state)\n{\n    // acquire any key we get near\n    vec3 playerpos = state.xyz;\n    int haskeys = int(state.w);\n    // must only enter the cell with the key to acquire it\n    Tile tilehere = LoadTile(ivec3(floor(playerpos)));\n    bool hasthiskey = (tilehere.col & haskeys) == tilehere.col;\n    switch (tilehere.def) {\n        case tKey:\n            haskeys |= tilehere.col;\n            break;\n        case tExit:\n            //if (tilehere.col == 7) // you got the magic thingy! ok, it's a white key, for now.\n            // TODO start a countdown instead so we can animate victory\n            { haskeys = -1; } // you win!  yay!\n            break;\n    }\n    // kb(27) esc resets the game, generates a new dungeon;\n    if (kb(27) > .5)\n        haskeys = -1; //7; // reset with esc key\n    state.w = float(haskeys);\n}\n// if you go to where a key is, you acquire it, it changes to an empty floor.\n// Must ensure we record that we've taken it, before it disappears!\n// tiles will wait for us to take the key before removing it.\n// if you go to where a door is, if you have the proper key, it changes to an open door.\n\n\nbool mainState(out vec4 fragColor, vec2 fragCoord)\n{\n    if (fragCoord.x > 1. || fragCoord.y > 1.) \n        return false;\n    vec4 state = LoadState();\n    bool init = iFrame < 2 || state.w < 0.;\n    if (init) {\n        state.xyz = //vec3(15, 0,  12) + .5; // start position (HACK manually scaled, doesn't match tile init)\n            vec3(vec2(ivec2(20, 15) * MazeSize(iChannelResolution[0].xy) / ivec2(100,50)), 0).xzy + .5;\n        state.w = 0.; // have keys? or bits 0, 1, 2.  should start with none.\n    }\n    PlayerMove(state, iMouse, clamp(iTimeDelta, 1./144., 1./30.));\n    GameLogic(state);\n    fragColor = state;\n    return true;\n}\n\n// 'dungeon' WFC\nbool mainWFC(out vec4 fragColor, vec2 fragCoord)\n{\n    if (!all(lessThan(uvec2(fragCoord), uvec2(MazeSize(iChannelResolution[0].xy)))))\n        return false;\n    ivec2 i = ivec2(fragCoord);\n    Tile tiles[nlayers] = LoadTiles(iChannel0, iChannelResolution[0].xy, i);\n    for (int l = 0 + IZERO; l < nlayers; ++l)\n        Update(tiles[l], ivec3(i.x, l, i.y));\n    fragColor = StoreTiles(tiles, i);\n    return true;\n}\n    \nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    if (!mainState(fragColor, fragCoord))\n        if (!mainWFC(fragColor, fragCoord))\n            discard;\n}\n\n// TODO could generate dijkstra field for various features like keys,\n// to enable some automatic traversal, solving of the dungeon, key puzzle thing.\n// Or for giving player hints.","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// fullscreen, high resolutions can be problematic; just upscale instead.\n// player experience trumps most all!\nconst float maxRes = 720.; //1080.; //512.; //1440.; //320.; //2160.; //\n\nconst float playerradius = .2;\n\nconst float tau = 2. * acos(-1.);\n\n#define IZERO min(0, iFrame)\n\n// the buffers can get really large; you will definitely get lost if increase this!\nivec2 MazeSize(vec2 chres)\n{\n    return min(ivec2(chres), ivec2(2,1) << 6);\n}\n\nstruct TileDef\n{\n    int id;\n};\n\n// tiledef ids\nconst int\n    tBlank = 0, // everything starts as tBlank, it means nothing is here yet\n    tInvalid = 1, // if a tBlank gets stuck unable to find a valid tile, might switch to tInvalid to get neighbors to reset\n    tFloor = 2,\n    tDoorLock = 3,\n    tDoorOpen = 4,\n    tKey = 5,\n    tExit = 6,\n    // most of those are somewhat special, can only be part of larger rooms if placed manually\n    tWall = 7, // side of room\n    tHall = 8,\n    tTurn = 9, // inside corner of room\n    tTurn2 = 10, // of narrow passageway \n    tTurn3 = 11, // outside corner of building\n    tRound = 12, // outside round corner\n    tPosts = 13,\n    tDiag = 14,\n    tJunct = 15,\n    tSolid = 16, // dungeon often has hard time generating without something to fill odd gaps\n    tStairs = 17,\n    tStairTop = 18,\n    //tBars = 17,\n    //tDeadEnd = 18,\n    //tEmpty = 19, // unwalkable empty space like a pit or chasm or top of a tall room or stairs down\n    tTotal = 19;\n    \n// seems need some sort of \"is seed\" flag;\n// I suppose classifying certain tiledefs will do.\n// to prevent wiping out important features during generation\n// when it has trouble finding a valid configuration.\n// seed tiles should never be 'erased' even when the neighbors don't match.\nbool isSeed(int def)\n{\n    return def == tStairTop\n        || def == tStairs \n        || def == tKey \n        || def == tFloor \n        || def == tDoorLock\n        || def == tDoorOpen\n        || def == tExit;\n}           \n// seeds are special in that they never get deleted or created automatically.\n// tFloor is where player start etc. happen, just a safe place player can be.\n// they connect to regular walls and form larger rooms, but generally don't\n// get generated automatically.  mostly because of this!\n    \n// 'material' ids for inter-cell connection parts\nconst int\n    mEmpty = 0, // nothing has been generated here yet\n    mSolid = 1,\n    mDoorway = 2,\n    mTotal = 3;\n// my intention for these seems to have wandered and\n// now it's kind of a 'is solid' flag with special case haxx\n// that could be checked for elsewhere easier.  oh well.\n\n// iq http://iquilezles.org/www/articles/smin/smin.htm\nfloat smin(float a, float b, float k)\n{\n\tfloat h = a - b;\n    return .5 * (a + b - sqrt(h * h + k));\n}\n// the sqrt version is apparently the best\n\n// following iq method\nfloat dBox(vec3 q, vec3 e)\n{\n    q = abs(q) - e;\n    float g = max(q.x, max(q.y, q.z));\n    return g <= 0. ? g : length(max(q, 0.));\n}\n\n// signed distance to unrotated tiledef centered at origin\n// extending 0.5 in each direction.\n// ideally I'd let some features extend into neighboring cells somehow\n// but for now probably CSG with some cube for the cell\n// so that these don't need to consider it.\n// failure to use dBox is why collision sucks!\nfloat Distance(TileDef def, vec3 q)\n{\n    vec3 a = abs(q); // many shapes need symmetry\n    float d = 2e4; //3.4e38; // big number rekt by smin\n    float w = .3; // passage width (inverse of wall thickness)\n    float cl = w - q.y, fl = w + q.y;\n    float hol = -dBox(q, vec3(w,1.5,w)); // vertical hole\n    float ch = max(cl, hol), fh = max(fl, hol);\n    float cv = max(cl, .5-.5*w-length(q)); // TODO a vaulted ceiling, so square holes aren't everywhere.\n    // TODO could put lights in the ceiling somehow\n    float fc = min(cv, fl); //min(ch, fl); //min(ch, fh); //w - a.y; //min(fl, cl); //\n    float ks = .2; // key scale\n    float dots = (length(fract(q * 17. + .5) - .5) - .17) / 17.;\n    float f = .02; // fillet r\n    switch (def.id)\n    {\n        default: \n        case tInvalid: break; //d = dots; fc = min(ch,fh); break;\n        case tBlank: break; //d = dots; fc = min(ch,fh); break; //d = .5 + 1e-6 - min(a.x, min(a.y, a.z)); break;\n        case tFloor: fc = min(ch, fl); break; //d = w - a.y; break;\n        case tDoorLock:  d = min(w - a.x, a.z - w); break;\n        case tDoorOpen:  d = min(d = w - a.x, dBox(vec3(a.x,0,a.z) - vec3(.5,0,0), vec3(.6-w,.5,w))); fc = min(cl,fl); break;\n        // TODO should spin keys; no iTime in Common\n        case tKey:   d = max(a.x - .03*ks, min(min(length(max(vec2(0), abs(q.yz - vec2(.06125,.25)*ks) - vec2(.06125, 0)*ks)), length(max(vec2(0), abs(q.yz - vec2(0, .125)*ks) - vec2(0, .125)*ks))), abs(length(q.yz + vec2(0, .125)*ks) - .125*ks)) - .075*ks); break;\n        case tExit:  d = length(vec2(q.x, abs(length(q.yz) - .17))) - .02; fc = min(ch, fl); break; //d = length(q) - .19; fc = min(cl,fl); break; // TODO better torus\n        case tWall:  d = w - q.z; break;\n        case tHall:  d = w - a.x; break;\n        case tTurn:  d = smin(w + q.x, w + q.z, 1e-4); break; //d = .5 - dBox(q - vec3(.25,0,.25), vec3(.5,.4,.5)); break; //\n        case tTurn2:  d = min(smin(w + q.x, w + q.z, 1e-4), dBox(vec3(q.x,0,q.z) - vec3(.5,0,.5), vec3(.5-w,.5,.5-w) - f) - f); break; //d = min(max(w - q.x, w - q.z), min(w + q.x, w + q.z)); break;\n        case tTurn3:  d = dBox(vec3(q.x,0,q.z) - vec3(.5,0,.5), vec3(.5-w,.5,.5-w) - f) - f; break; //d = max(w - q.x, w - q.z); break;\n        case tRound:  d = length(q.xz - .5) - .5 + w; break;\n        case tPosts:  d = dBox(vec3(a.x,0,q.z) - vec3(.5,0,-.5), vec3(.5-w,.5,.5-w) - f) - f; break; //d = max(w - a.x, q.z + w); break;\n        case tDiag:  d = sqrt(.5) * (.5 + w - abs(q.x + q.z)); break; //d = min(dBox(q - vec3(.5,0,.5), vec3(.5-w,.5,.5-w)), dBox(q + vec3(.5,0,.5), vec3(.5-w,.5,.5-w))); break; //d = min(max(w - q.x, w - q.z), max(q.x + w, q.z + w)); break;\n        case tJunct: d = min(w - q.z, dBox(vec3(a.x,0,q.z) - vec3(.5,0,-.5), vec3(.5-w,.5,.5-w) - f) - f); break; //d = min(max(w - a.x, q.z + w), w - q.z); break; //d = q.z + w; break; //\n        //case tBars:  d = length(vec2(a.x, q.z) - vec2(.5,1)) - .25; break;\n        //case tDeadEnd: d = min(w - a.x, .75 - q.z); break;\n        case tSolid: d = max(a.x, max(a.y, a.z)) - 1e-6 - .5; fc = min(cl,fl); break;\n        //case tEmpty: d = .5 + 1e-6; break; // 'empty' = distance to next cell\n        case tStairs: { \n            fc = min(ch, fh) + .5; //.9 - max(a.x, max(a.y, a.z)); //fc = min(ch, fl); //\n            d = min(w - a.x, abs((q.y * .5 - q.z * .866) - .2) - .07);\n            break;\n            //fc = min(ch, fl); d = min(w - a.x, (q.y - q.z) * sqrt(.5) - .3); break;\n            float rep = 32.;\n            //float sl = (round(sqrt(.5) * (q.y+q.z) * rep) + .5) / rep; \n            float sl = (floor(mix(q.y, q.z + .95/rep, .5) * rep) + .5) / rep; float f = .025;\n            d = min(w - a.x, dBox(vec3(a.x, q.yz - sl), vec3(.5,.04,.1) - f) - f); \n            break; \n        } // TODO some box domain repetition\n        case tStairTop: fc = min(cl, fh); break;\n    }\n    // TODO some kind of 'texture'\n    //d = 99.;\n    d = smin(d, fc, 2e-5); // every cell has a floor and ceiling for now\n    //d = .4 - a.y;\n    //d = min(d, .515 - max(a.x, max(a.y, a.z))); // could do a better estimate if we knew which way ray was headed (sign)\n    //can't do it here or it breaks collision\n    return d;\n}\n\n// connectivity for an edge of a tiledef if rotated, starting with 0 = west, then 1 = north, 2 = east, 3 = south \n// why I picked this way?  idk, I think it was the keyboard support in Buffer B\n// anyway it's contrary to my other toy, must do something different for 3D anyway\nivec3 Edge(int def, int rot)\n{\n    rot &= 3;\n    ivec3 m;\n    switch (def)\n    {\n        default:\n        //case tInvalid: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tBlank: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tFloor: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tDoorLock: m = ivec3[4](ivec3(1,1,1),ivec3(1,2,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break; // FIXME must match 'next' area somehow\n        case tDoorOpen: m = ivec3[4](ivec3(1,1,1),ivec3(1,2,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break; // FIXME must match 'next' area somehow\n        // like there might need to be a 'back of the door' to connect to the other color with\n        case tKey:   m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tExit:  m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tWall:  m = ivec3[4](ivec3(0,0,1),ivec3(1,1,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        case tHall:  m = ivec3[4](ivec3(1,1,1),ivec3(1,0,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break;\n        case tTurn:  m = ivec3[4](ivec3(1,1,1),ivec3(1,0,0),ivec3(0,0,1),ivec3(1,1,1))[rot]; break;\n        case tTurn2: m = ivec3[4](ivec3(1,1,1),ivec3(1,0,1),ivec3(1,0,1),ivec3(1,1,1))[rot]; break;\n        case tTurn3: m = ivec3[4](ivec3(0,0,0),ivec3(0,0,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        case tRound: m = ivec3[4](ivec3(0,0,0),ivec3(0,0,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        case tPosts: m = ivec3[4](ivec3(1,0,0),ivec3(0,0,0),ivec3(0,0,1),ivec3(1,0,1))[rot]; break;\n        case tDiag:  m = ivec3[4](ivec3(1,0,0),ivec3(0,0,1),ivec3(1,0,0),ivec3(0,0,1))[rot]; break;\n        case tJunct: m = ivec3[4](ivec3(1,0,1),ivec3(1,1,1),ivec3(1,0,1),ivec3(1,0,1))[rot]; break;\n        //case tBars: m = ivec3[4](ivec3(0,0,1),ivec3(1,1,1),ivec3(1,0,0),ivec3(0,0,0))[rot]; break;\n        //case tDeadEnd:  m = ivec3[4](ivec3(1,1,1),ivec3(1,1,1),ivec3(1,1,1),ivec3(1,0,1))[rot]; break;\n        case tSolid:  m = ivec3[4](ivec3(1),ivec3(1),ivec3(1),ivec3(1))[rot]; break;\n        //case tEmpty: m = ivec3[4](ivec3(0),ivec3(0),ivec3(0),ivec3(0))[rot]; break;\n        case tStairs:  m = ivec3[4](ivec3(1),ivec3(1),ivec3(1),ivec3(1,0,1))[rot]; break; // TODO need 3D connectivity\n        case tStairTop:  m = ivec3[4](ivec3(1),ivec3(1,0,1),ivec3(1),ivec3(1))[rot]; break;\n    }\n    return m;\n}\n\nmat2 Rot(int rot)\n{\n    const mat2 rots[4] = mat2[] ( \n        mat2(1,0,0,1),\n        mat2(0,1,-1,0),\n        mat2(-1,0,0,-1),\n        mat2(0,-1,1,0)\n        );\n    return rots[rot & 3];\n}\n\n\n// Wellons lowbias32 from http://nullprogram.com/blog/2018/07/31\nuint hash(uint x)\n{\n    x ^= x >> 16;\n    x *= 0x7feb352du;\n    x ^= x >> 15;\n    x *= 0x846ca68bu;\n    return x ^ (x >> 16);\n}\n\n\nstruct Tile \n{\n    int def; // tile def id\n    int col; // color code bits; could also be considered a 'zone id' of sorts\n    int rot; // rotation\n};\n\n// emission in alpha; TODO more (gloss etc.)\nvec4 Material(Tile tile, vec3 q)\n{\n    vec3 tint = vec3((ivec3(tile.col) >> ivec3(0,1,2)) & 1);\n    //tint.b *= 3.; // HACK why blue so dim?\n    bool seed = isSeed(tile.def);\n    float factor = seed ? .0 : .8;\n    tint = mix(tint, vec3(.2), factor);\n    if (tile.def == tInvalid) tint = vec3(1,0,1);\n    return vec4(tint, seed ? all(lessThan(abs(q-.5), vec3(.2))) ? .5 : .04 : 0.);\n}\n\n// requires q to provide signed coordinates from -.5 to .5\n// to describe an entire cell.\nfloat Distance(Tile tile, vec3 q)\n{\n    q.xz *= Rot(tile.rot);\n    return Distance(TileDef(tile.def), q);\n}\n\nvec4 FetchTiles(sampler2D ch, ivec2 p)\n{\n    return texelFetch(ch, p, 0);\n}\n// simple packing/unpacking\nTile FromFloat(float x)\n{\n    int c = int(x),\n        def = c >> 5,  // n leftover bits at offset 5\n        col = (c >> 2) & 7,  // 3 bits at offset 2 for color code\n        rot = c & 3;   // 2 bits at offset 0 for rotation\n    return Tile(def, col, rot);\n}\n\nfloat ToFloat(Tile t)\n{\n    int i = (t.def << 5)\n        | ((t.col & 7) << 2)\n        | (t.rot & 3);\n    return float(i);\n}\n\nTile LoadTile(sampler2D ch, vec2 chr, ivec3 p)\n{\n    vec4 layers = FetchTiles(ch, p.xz);\n    Tile t = FromFloat(layers[p.y]);\n    if (!all(lessThan(uvec2(p.xz), uvec2(MazeSize(chr))))) t.def = tSolid;\n    if (all(lessThan(uvec2(p.xz), uvec2(1)))) t.def = tSolid; // pretend state pixel is solid so gets walled in\n    return t;\n}\n\n\n// compile times get really bad with 4 layers\nconst int nlayers = 1; //2; //4; //\n\nTile[nlayers] LoadTiles(sampler2D ch, vec2 chr, ivec2 p)\n{\n    vec4 v = FetchTiles(ch, p);\n    Tile tiles[nlayers];\n    for (int l = 0; l < nlayers; ++l) {\n        tiles[l] = FromFloat(v[l]); //LoadTile(BufA, p, l);\n        if (!all(lessThan(uvec2(p), uvec2(MazeSize(chr))))) tiles[l].def = tSolid;\n        if (all(lessThan(uvec2(p), uvec2(1)))) tiles[l].def = tSolid; // pretend state pixel is solid so gets walled in\n    }\n    return tiles;\n}\n\nvec4 StoreTiles(in Tile t[nlayers], ivec2 p)\n{\n    vec4 o;\n    for (int i = 0; i < nlayers; ++i) \n        o[i] = ToFloat(t[i]);\n    return o;\n}\n\n// dumb idea to avoid needing any more state or camera logic:\nmat3 Camera(vec4 mouse, vec2 rz, float time)\n{\n    mat3 v = mat3(1);\n    vec2 l = abs(mouse.xy) / rz - .5;\n    if (mouse == vec4(0)) //mouse = rz.xyxy * .5;\n        l = vec2(fract(.03 / tau * time) + .1 * sin(.2*time), .05 * sin(.3*time)); // attract mode    \n    vec2 cs = vec2(.25, 0),\n      s = sin((l.x * 2.  + cs) * tau),\n      y = sin((l.y * .49 + cs) * tau);\n    v = mat3(s.x, 0, -s.y, 0, 1, 0, s.y, 0, s.x)\n      * mat3(1, 0, 0, 0, y.x, -y.y, 0, y.y, y.x);\n    return v;\n}\n\n\nvec2 dScene1(sampler2D ch, vec2 chres, vec3 p)\n{\n    ivec3 i = ivec3(floor(p));\n    vec3 f = p - vec3(i); // relative to closest cell\n    Tile t = LoadTile(ch, chres, i);\n    return vec2(Distance(t, f - .5), isSeed(t.def) ? 1. : 0.);\n}\n \n// from http://shadertoy.com/view/NscXR4 variant of Thomas Hooper's looped variant of iq's simplex gradient\nvec3 gScene1(sampler2D ch, vec2 chres, vec3 q, float h, int zero)\n{\n\tvec3 n; // = vec3(0);\n\tfor (int i = zero; i < 4; ++i) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += dScene1(ch, chres, q + e * h).x * e;\n\t}\n\treturn n;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// main rendering \n\n// only the rendering needs these details.\n\n// Voronoi by Shane from http://shadertoy.com/view/Mld3Rn\n// converted to 3D by spalmer\nfloat Voronoi(vec3 p)\n{    \n\tvec3 g = floor(p), o; p -= g;\t\n\tvec3 d = vec3(1.4); //1); //  d.z = distance comparison value, y = 2nd closest, x = closest\n\tfor (int z = -1; z < 2; ++z)\n\t  for (int y = -1; y < 2; ++y)\n\t\tfor (int x = -1; x < 2; ++x) {\n\t\t\to = vec3(x, y, z);\n            o += fract(vec3(262144, 32768, 7137) * sin(dot(g + o, vec3(41, 289, 733)))) - p;\n\t\t\td.z = dot(o, o); \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n\t\t}\n    float f = 5./6.;\n\treturn max(d.y * f - d.x, 0.) * f;\n}\n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n    //return d.y - d.x; // return 1.-d.x; // etc.\nfloat dSceneVorocksShane(sampler2D ch, vec2 chres, vec3 p, float flats, int zero)\n{\n  \tvec2 l0d = dScene1(ch, chres, p);\n    if (l0d.y > 0.) return l0d.x;\n    if (abs(l0d.x) > .075) return l0d.x - .07; // LOD is poofed non-rocky surface\n    float s = 12., iso = .005 * (1. + 11. * (1.-flats) * (1.-flats)); // I retuned it with a soft cap to make it look more like flagstones than random rocks.\n    return (l0d.x - .5 * smin(Voronoi(p * s) / s, iso, 1e-5)) * .8; // the voronoi makes the SDF imperfect, so underestimate a bit\n}\n// that works, really well, with only one 'layer', awesome!\n// btw, converting it to 2x2x2 breaks it pretty much the same as mine is broken\n// the 2x2x2 strategy requires slightly different scheme iirc, (and I don't, obviously)\n/*\n// not yet working\nfloat dSceneVorocks(sampler2D ch, vec2 chres, vec3 p, int zero)\n{\n  \tfloat l0d = dScene1(ch, chres, p);\n    if (abs(l0d) > .1) return l0d - .09; // LOD is poofed non-rocky surface\n    // add some voronoise for 'rocky' surfaces.\n    float grid = 15., dvr = .25/grid/grid; //l0d + .1;\n    vec3 ip = floor(p * grid);\n    for (int k = 8 + zero; k-- > 0; ) {              // visit 2x2x2 neighborhood\n        vec3 p0 = ip + vec3(k&1, (k>>1)&1, k>>1), // cell id\n            c = (p0 + .25 + .5*hash33(p0)) / grid;     // vector-dist to cell sample\n    \t//float l = dScene1(ch, chres, c); //\n\t\t//if (l < 0. || l > 2.*size) continue; // only consider cells close enough to surface!\n        c -= p; \n        float d0 = dot(c, c);\n        if (d0 < dvr)\n            dvr = d0;   // keep closest\n    }\n    return l0d + .25 * sqrt(dvr); //l0d + sqrt(dvr); //\n}\n*/\n/*\n// http://shadertoy.com/view/wsjfWK\nfloat dSceneDetails(sampler2D ch, vec2 chres, vec3 p, int zero) //, inout vec3 C, inout vec3 id)  // return dist; C=pos, id=detail 3D id\n{\n    vec3 C, id;\n    float d = 1e15;\n    d = min(d, dScene1(ch, chres, p)); //dShapeMain(p));\n    const float grid = 11., size = .24 / grid; // detail scale\n    vec3 ip = floor(p * grid) - 0.;\n    // TODO detail 'bricks' somehow\n  #if 1\n    for (int k=0; k<8; ++k) {              // visit 2x2x2 neighborhood - FIXME compile time\n        vec3 p0 = ip + .5 + vec3(k%2,k/2%2,k/2), // cell id\n            c = (p0 + .2*hash33(p0)) / grid;     // vector-dist to cell sample\n    \tfloat l = dScene1(ch, chres, c); //dShapeMain(c);\n\t\tif (l < 0. || l > 2.*size) continue; // only consider cells close enough to surface!\n        vec3 m = vec3(l),\n        n = normalize(gScene1(ch, chres, p, 4e-3, zero));\n        c -= m * n;     // snap to surface - will be very expensive\n        // need to know that normal to know how to orient the box, anyway\n        m -= size * n * n;\n        float d0 = dBox(c - p, m) - .16 / grid;  // hardcoded box shape TODO generalize to function TODO bricks\n        if (d0 < d)\n            d=d0, C=c, id = p0;             // keep closest sample info\n    }\n    d *= .7; // borks SDF\n  #endif\n  // 3x3x3 is extraordinarily expensive - don't bother\n    return d;\n}\n*/\n// TODO maybe try http://shadertoy.com/view/slVfWD (private)\nfloat dScene(sampler2D ch, vec2 chres, vec3 p, float rough, int zero)\n{\n    //return dScene1(ch, chres, p);\n    return dSceneVorocksShane(ch, chres, p, rough, zero);\n    //return dSceneVorocks(ch, chres, p, zero);\n    //return dSceneDetails(ch, chres, p, zero);\n}\n\nfloat dScene(vec3 p, float flats)\n{\n    return dScene(iChannel0, iChannelResolution[0].xy, p, flats, IZERO);\n}\nfloat dScene(vec3 p)\n{\n    return dScene(p, 1. - fract(p.y));\n}\nfloat dScene1(vec3 p)\n{\n    return dScene1(iChannel0, iChannelResolution[0].xy, p).x;\n}\n\n// from http://shadertoy.com/view/NscXR4 variant of Thomas Hooper's looped variant of iq's simplex gradient\nvec3 gScene(vec3 q, float h, float flats)\n{\n\tvec3 n; // = vec3(0); // GLSL inits locals to zero\n\tfor (int i = IZERO; i < 4; ++i) {\n\t\tvec3 e = vec3((ivec3(i+3, i, i+i)&2) - 1);\n\t\tn += dScene(q + e * h, flats) * e;\n\t}\n\treturn n;\n}\n\n\n// returns distance only (TODO for secondary rays)\n/*float March(vec3 ro, vec3 rd, float tol, float maxt, int iters)\n{\n    int i = iters;\n    float t, tnear, covnear; // = 0.;\n    float ho = maxt;\n    while (i-- > 0 && t < maxt) {\n        vec3 p = t * rd + ro, dC, did;\n        float d;\n        d = dScene(p); //, dC, did);\n        //d = .5 - abs(p.y);\n        //d = length(fract(p) - .5) - .3;\n        if (d < tol) {\n            break;\n        }\n        vec3 a = abs(fract(p) - .5);\n        // this whole style of cell-based ray marching\n        // is what Shane was suggesting, talking about.\n        // I had done it before, somewhere, I think,\n        // but yeah, it works great!  Thanks!\n        //d = min(d, .515 - max(a.x, max(a.y, a.z)));  // limit to cell - too conservative\n        // better estimate using sign of direction ray heading\n        //vec3 X = abs(max(sign(rd), 0.) - fract(p)) / (abs(rd) + 1e-8);\n        vec3 X = (max(sign(rd), 0.) - fract(p)) / rd; // apparently the abs aren't necessary, and the NaN gets handled gracefully\n        // dividing by rd inside the loop allows rd to vary,\n        // so we can later do reflection etc.\n        float dl = min(X.x, min(X.y, X.z)) + tol; // go few mm into next cell\n        d = min(d, dl);  // limit to cell\n        t += max(tol, d);\n        ho = d;\n    }\n    t -= .5 * tol; // back off!  --elenzil\n    return clamp(t, 0., maxt);\n}*/\n\n// returns (distance, material, 2nd distance, 2nd coverage)\n// so far the core SDF doesn't distinguish materials, so... material always 0. rn\nvec4 March2(vec3 ro, vec3 rd, float sa, float maxt, int iters)\n{\n    vec4 c;\n    int i = iters;\n    const float minstep = 1e-4;\n    float t, tnear, covnear; // = 0.;\n    float ho = maxt;\n    while (i-- > 0 && t < maxt) {\n        vec3 p = t * rd + ro;//, dC, did;\n        float d;\n        d = dScene(p);\n        if (d > ho && tnear == 0. && covnear < .5 && ho < 1. * t * sa) {\n            tnear = t - .9 * ho;\n            covnear = clamp(1. - ho / max(t * sa, 1e-9), 0., 1.);\n        }\n        if (d < 0. * t * sa) {\n            break;\n        }\n        ho = d;\n        vec3 a = abs(fract(p) - .5);\n        // Thanks Shane!\n        // limit to cell using sign of direction ray heading\n        //vec3 X = abs(max(sign(rd), 0.) - fract(p)) / (abs(rd) + 1e-8);\n        vec3 X = (max(sign(rd), 0.) - fract(p)) / rd; // apparently the abs aren't necessary, and the NaN gets handled gracefully\n        float dl = min(X.x, min(X.y, X.z)) + .5 * t * sa; // go few mm into next cell\n        d = min(d, dl);  // limit to cell\n        t += max(minstep, d);\n    }\n    t -= 1.95 * minstep; // back off!  --elenzil\n    t = min(t, maxt);\n    c.x = t;\n    c.z = tnear;\n    c.w = covnear;\n    return c;\n}\n\nTile LoadTile(ivec3 p)\n{\n    return LoadTile(iChannel0, iChannelResolution[0].xy, p);\n}\n\nvec4 LoadState()\n{\n    return texelFetch(iChannel0, ivec2(0), 0);\n}\n\n\n// XT95 http://shadertoy.com/view/4sdGWN\nfloat ambientOcclusion(vec3 p, vec3 n, float maxDist, float falloff, bool rough, float flats)\n{\n\tconst int nbIte = 12;\n    const float nbIteInv = 1. / float(nbIte);\n    const float rad = 1. - nbIteInv; // Hemispherical factor (self occlusion correction)\n\tfloat ao = 0.;    \n    for (int i = 0 + IZERO; i < nbIte; ++i) {\n        float l = sqrt(float(hash(uint(i+iFrame)) & 0x7fffffu) * exp2(-23.)) * maxDist;\n        vec3 rd = normalize(2. * n + sin(fract(vec3(99,999,9999) * l) * 777.) * rad) * l;\n        float d = rough ? dScene(p + rd, flats) : dScene1(p + rd);\n        ao += (l - max(d, 0.)) / maxDist * falloff;\n    }\n    return clamp(1. - ao * nbIteInv, .04, 1.);\n}\n\n// feeble attempt to pick out beat from soundcloud in iChannel3 for flickering lamp\nfloat beat(sampler2D ch)\n{\n    // http://shadertoy.com/view/XsG3R3\n    // soundcloud texture is 512x2\n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n\treturn mix(pow(texelFetch(ch, ivec2(7,0), 0).x, 2.),\n               pow(texelFetch(ch, ivec2(133,0), 0).x, 4.), .3);\n}\n\nvec3 Shade(vec3 p, vec3 v, float focus, float range)\n{\n    float gtol = .5 * sqrt(max(0., 1. - focus*focus)) * range; //1e-3; //\n    vec4 hc = Material(LoadTile(ivec3(floor(p))), fract(p));\n    bool rough = hc.a < 1e-4;\n    float flats = rough ? 1. - fract(p.y) : 1.;\n    vec3 n = rough\n        ? gScene (p, gtol, flats)\n        : gScene1(iChannel0, iChannelResolution[0].xy, p, gtol, IZERO);\n    n = normalize(n);\n    float ao = ambientOcclusion(p, n, .5, 1.6, rough, flats);\n   #define chBM iChannel2\n    if (rough) {\n        vec3 tc = p * 11.1;  // fakie triplanar bump mapping\n        n.zy -= .7*(texture(chBM, tc.zy).r - .5) * n.x*n.x;\n        n.xz += .7*(texture(chBM, tc.xz).r - .5) * n.y*n.y;\n        n.xy -= .7*(texture(chBM, tc.xy).r - .5) * n.z*n.z;\n    }\n    vec3 l = v; //-rd; //normalize(ro - hp);\n    //n -= v * min(dot(v, n), 0.); // trying to figure out the black edges; normals need to back off!  think the edges are just too sharp.\n    n = normalize(n);\n    if (!(dot(n, n) > 1e-8)) n = vec3(0,1,0); // HACK for jarble\n    float nl = dot(n, l);\n    nl = max(.02, mix(nl, 1., .4 * ao)); // HACK for jarble\n    // fake specular\n    vec3 h = l; //normalize(mix(l, v, .5)); // but l and v are currently the same\n    float nh = max(dot(n, h), 0.) * nl;\n    nl *= exp2(-.75 * range); // attenuation - darken in distance\n    nh *= exp2(-.04 * range);\n    nl = mix(nl, 1., hc.a);\n    //nl *= ao;\n    //nh *= ao;\n    vec3 lite = vec3(nl);\n    lite *= mix(1. - beat(iChannel3), 1., .5);\n    float sp = 4.; // how shiny? rocks aren't wet\n    float spec = .4 * sp * .038 * pow(nh, sp);\n    return \n        spec +\n        lite *\n        hc.rgb;\n    // TODO other fog? maybe\n}\n\nvec3 DrawRay(vec3 ro, vec3 rd, float focus)\n{\n    vec4 mr = March2(ro, rd, sqrt(1. - focus*focus), 1e2, 128 + IZERO);\n    mr.x = max(mr.x, 0.);\n    vec3 c = Shade(mr.x * rd + ro, -rd, focus, mr.x);\n    if (mr.w > 0.) { // mix 2nd fragment for cone tracing antialiasing\n        vec3 c1 = Shade(mr.z * rd + ro, -rd, focus, mr.z);\n        c = mix(c, c1, mr.w);\n    }\n    return c;\n}\n    //vec2 mr = vec2(March(ro, rd, 1e-3, 1e2, 96 + IZERO));\n\nvec3 DrawTile(Tile tile, vec2 f, float aa)\n{\n    if (tile.def == tInvalid) return vec3(.5,0,.5);\n    if (tile.def == tBlank) return vec3(.02,.02,.05);\n    //tile.rot = 0;\n    vec2 s = f - .5;\n    vec3 q = vec3(s.x, 0, s.y);\n    float d = Distance(tile, q); \n    float cov = clamp(.5 - d * aa, 0., 1.);\n    return mix(.4, 1., cov) * Material(tile, q).rgb;\n}\n\n// TODO maybe move UI to Image tab?\nvec4 DrawUI(vec2 fc, vec2 rz, int haskeys, vec2 fw)\n{\n    vec2 q = fc;\n    q -= .5 * rz;\n    vec4 ui;\n    ui = mix(ui, vec4(vec3(0,0,1) * float((haskeys >> 2) & 1), 1), clamp(.5 - (abs(length(q - vec2(-.52,-.3) * rz) - rz.y*.14) - rz.y*.02), 0., 1.));\n    ui = mix(ui, vec4(vec3(0,1,0) * float((haskeys >> 1) & 1), 1), clamp(.5 - (abs(length(q - vec2(-.52, .0) * rz) - rz.y*.14) - rz.y*.02), 0., 1.));\n    ui = mix(ui, vec4(vec3(1,0,0) * float((haskeys >> 0) & 1), 1), clamp(.5 - (abs(length(q - vec2(-.52, .3) * rz) - rz.y*.14) - rz.y*.02), 0., 1.));\n    if (fc.x > rz.x*.875 && fc.y < rz.y * .25) { // minimap\n        vec2 mc = fc - vec2(.9375,.125)*rz;\n        vec2 p = mc/6.;\n        p += LoadState().xz;\n        ui = vec4(DrawTile(LoadTile(ivec3(floor(vec3(p.x, 0, p.y)))), fract(p), 3.), 1);\n        // mark current location with dot 'arrow'\n        float ad = length(mc) - 3.;\n        ad = min(ad, length(mc + 2.5 * fw) - 2.);\n        ad = max(ad, 1. - length(mc - 2.5 * fw));\n        vec4 d = vec4(vec3(.01), clamp(.5 - ad, 0., 1.));\n        ui = mix(ui, vec4(d.rgb,1), d.a); \n    }\n    return ui;\n}\n\nvec3 Render(vec2 fc, vec2 rz)\n{\n    // TODO temporal reprojection / upsampling?\n    float aa = min(rz.x, rz.y);\n    vec4 gamestate = LoadState();\n    vec3 playerpos = gamestate.xyz;\n    //playerpos = vec3(3,2,3)+.5; // force camera somewhere\n    mat3 cam = Camera(iMouse, iResolution.xy, iTime); // I bet my whole matrix is backward somehow.\n    vec2 fw2d = -normalize(cam[2].xz); // for ui di arrow // FIXME how can possibly be backward?!\n    float hfovy = sin(tau/12.); // tan? dc rn\n    vec3 rd = vec3((fc - .5 * rz) / aa, .8); // FIXME use hfovy\n    rd = cam * rd;\n    rd = normalize(rd);\n    int haskeys = int(gamestate.w);\n    vec3 c = DrawRay(playerpos, rd, cos(2.*hfovy/aa));\n    vec4 u = DrawUI(fc, rz, haskeys, fw2d);\n    c = mix(c, u.rgb, u.a);\n    return c;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 r = iResolution.xy, or = r, p = fragCoord, op = p;\n    float sa = 1. / min(r.x, r.y);\n    r *= min(r.y, maxRes) * sa;\n    if (any(lessThan(r, p))) discard; // limit resolution\n    vec3 c = Render(p, r);    \n    fragColor = vec4(c, 1); // leave linear gamma\n}\n","name":"Buffer B","description":"","type":"buffer"}]}