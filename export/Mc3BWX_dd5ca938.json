{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"XdfGR8","filepath":"/media/previz/buffer03.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"#define DENOISE_RADIUS 16\n\nvec3 denoise(sampler2D tex, ivec2 coord) {\n    vec4 center = texelFetch(tex, coord, 0);\n    \n    vec3 res = vec3(0.0);\n    float weight = 0.0;\n    for (int i = -DENOISE_RADIUS; i < DENOISE_RADIUS; i++) {\n        for (int j = -DENOISE_RADIUS; j < DENOISE_RADIUS; j++) {\n            if (i == 0 && j == 0) {\n                res += center.rgb;\n                weight += 1.0;\n                continue;\n            }\n            ivec2 offs = ivec2(i,j);\n            ivec2 c = coord+offs;\n            \n            float x = length(vec2(offs)) / float(DENOISE_RADIUS);\n            \n            float gaussWeight = exp(-4.0 * x * x);\n            if (gaussWeight < 0.02) continue;\n            \n            vec4 col = texelFetch(tex, c, 0);\n            \n            float depthWeight = exp(-pow(8.0*(col.w-center.w), 2.0));\n            \n            res += col.rgb * gaussWeight*depthWeight;\n            weight += gaussWeight * depthWeight;\n        }\n    }\n    return res / weight;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(denoise(iChannel0, ivec2(fragCoord)), 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"#define PI 3.14159265\n\n#define MARCH_STEPS 512\n#define MARCH_SURF 0.001\n#define MARCH_MISS 1000.\n\n#define CPDS_ITERATIONS 64\n\n#define UP vec3(0,0,1)\n\n#define LIGHT_POS vec3(3, -3, 3) * 2.0\n#define LIGHT_SIZE 2.0\n#define LIGHT_COL vec3(10, 10, 10) * 8.0\n\n#define SKY_TOP vec3(.46, .84, .92)*0.3\n#define SKY_BOTTOM (SKY_TOP * 0.6)\n#define SKY_HORIZ vec3(.9, .2, .2)\n\n    // integrate the sky function\n#define SKY_AMBIENCE ((SKY_BOTTOM - SKY_TOP + PI*SKY_TOP/2.0 + SKY_HORIZ/9.0) * (2.0 / PI))\n\n#define N_PARTICLES 512\n#define PARTICLE_MIN_RANGE (-4.0)\n#define PARTICLE_MAX_RANGE   4.0\n\n#define CAM_ORG vec3(0,-4,0)\n#define CAM_LOOKAT vec3(0,0,0)\n#define CAM_FOV 60.0\n\nstruct Ray {\n    vec3 origin, direction;\n};\n\nstruct Material {\n    vec3 diffuseColor;\n};\n\nstruct SurfaceInfo {\n    vec3 pos;\n    Material mat;\n};\n\nstruct ONB {\n    vec3 forward, right, up;\n};\n\nfloat opUnion(out Material mat, float a, Material mA, float b, Material mB) {\n    if (a < b) {\n        mat = mA;\n        return a;\n    }\n    mat = mB;\n    return b;\n        \n}\n\nfloat time;\n\nfloat map(vec3 p, out Material m) {\n    Material mGround = Material(vec3(0.9, 0.8, 0.8));\n    float dGround = p.z + 1.0;\n    \n    Material mSphere = Material(vec3(0.9, 0.1, 0.1));\n    float dSphere = length(p - vec3(0, 0, sin(time)+1.0)) - 1.0;\n    \n    return opUnion(m, dGround, mGround, dSphere, mSphere);\n}\n\nfloat map(vec3 p) {\n    Material _;\n    return map(p, _);\n}\n\nfloat march(Ray r, inout SurfaceInfo surf) {\n    float t = 0.0;\n    vec3 pos = r.origin;\n    float s = map(pos, surf.mat);\n    float minS = 1.0e30;\n    \n    for (int i = 0; i < MARCH_STEPS; i++) {\n        if (abs(s) < MARCH_SURF) {\n            surf.pos = pos;\n            return s;\n        }\n        \n        if (s > MARCH_MISS) {\n            return s;\n        }\n        if (t > MARCH_MISS) {\n            return MARCH_MISS + 1.;\n        }\n        if (s < 0.0) i++; // take less steps if we're inside a surface\n        t += s;\n        pos += r.direction * s;\n        \n        if (s < minS) {\n            minS = s;\n            surf.pos = pos;\n        }\n        \n        s = map(pos, surf.mat);\n    }\n    return s;\n}\n\nvec3 normal(in vec3 pos) {\n    float epsilon = 0.01;\n    return normalize(\n        vec3(\n            map(pos + vec3(epsilon, 0, 0)) - map(pos - vec3(epsilon, 0, 0)),\n            map(pos + vec3(0, epsilon, 0)) - map(pos - vec3(0, epsilon, 0)),\n            map(pos + vec3(0, 0, epsilon)) - map(pos - vec3(0, 0, epsilon))\n        )\n    );\n}\n\nfloat shadow(vec3 shadedPos, vec3 lightPos, float lightSize, inout SurfaceInfo surf) {\n    float res = 1.0;\n    float t = 0.005;\n    vec3 toLight = normalize(lightPos - shadedPos);\n    float maxt = distance(shadedPos, lightPos);\n    \n    for( int i=0; i<MARCH_STEPS && t<maxt; i++ ) {\n        float h = map(shadedPos + toLight * t, surf.mat);\n        res = min( res, h/(lightSize*t) );\n        t += min(h, 0.005);\n        if(res<-1.0) break;\n    }\n    res = max(res,-1.0);\n    if (res != res) return 1.0;\n    float final = 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n    return final;\n}\n\nfloat shadow(vec3 shadedPos, vec3 lightPos, float lightSize) {\n    SurfaceInfo _;\n    return shadow(shadedPos, lightPos, lightSize, _);\n}\n\nfloat estimateSolidAngleOfHemisphere(vec3 point, vec3 norm, inout SurfaceInfo surf) {\n    return shadow(point, point + norm * 1000.0, 1.0, surf);\n}\n\nfloat estimateSolidAngleOfHemisphere(vec3 point, vec3 norm) {\n    SurfaceInfo _;\n    return estimateSolidAngleOfHemisphere(point, norm, _);\n}\n\nfloat march(Ray r) {\n    SurfaceInfo _;\n    return march(r, _);\n}\n\n\nONB lookAt(vec3 lookfrom, vec3 lookat) {\n    vec3 forward = normalize(lookat - lookfrom);\n    vec3 right = normalize(cross(forward, UP));\n    vec3 up = cross(forward, right);\n    up *= sign(dot(up, UP));\n    \n    return ONB(forward, right, up);\n}\n\nRay cameraRay(vec2 acdc, vec3 ro, ONB onb, float vfov) {\n    float focal = 1.0 / (2.0*tan(radians(vfov) / 2.0));\n    Ray r;\n    r.origin = ro;\n    r.direction = normalize(onb.right * acdc.x + onb.up * acdc.y + onb.forward * focal);\n    return r;\n}\n\nvec2 reprojectCameraRay(Ray r, ONB onb, float vfov) {\n    float focal = 1.0 / (2.0 * tan(radians(vfov) / 2.0));\n    \n    vec3 localDir;\n    localDir.x = dot(r.direction, onb.right);\n    localDir.y = dot(r.direction, onb.up);\n    localDir.z = dot(r.direction, onb.forward);\n    \n    localDir /= localDir.z;\n    \n    vec2 acdc = vec2(localDir.x, localDir.y) * focal;\n    \n    return acdc;\n}\n\n\nvec3 directLighting(SurfaceInfo inf, vec3 norm, vec3 lightPos, float lightSize, vec3 lightColor) {\n    vec3 toL = lightPos - inf.pos;\n    float dstL = length(toL);\n    vec3 nL = toL / dstL;\n    \n    float lambert = max(0.0, dot(norm, nL));\n    float occlusion = shadow(inf.pos, lightPos, (lightSize / dstL));\n    float light = lambert * occlusion;\n    \n    return inf.mat.diffuseColor * lightColor * light / dot(toL, toL);\n}\n\nvec3 skyColor(vec3 rd) {\n    float upc = dot(rd, UP);\n    vec3 atmos = mix(SKY_BOTTOM, SKY_TOP, upc);\n    atmos += SKY_HORIZ * pow(1.0 - upc, 8.0);\n    \n    vec3 col = atmos * step(-0.1, upc);\n    \n    return col;\n}\n\nvec3 zeroBounceLighting(SurfaceInfo inf, vec3 norm) {\n    vec3 direct = directLighting(inf, norm, LIGHT_POS, LIGHT_SIZE, LIGHT_COL);\n    \n    float occlusion = estimateSolidAngleOfHemisphere(inf.pos + norm * MARCH_SURF * 10.0, UP);\n    vec3 sky = inf.mat.diffuseColor * SKY_AMBIENCE * occlusion;\n    \n    return direct + sky;\n}\n\nvec4 sampleParticle(sampler2D tex, int id) {\n    int w = textureSize(tex, 0).x;\n    \n    int x = id % w;\n    int y = id / w;\n    \n    return texelFetch(tex, ivec2(x, y), 0);\n}\n\nfloat packHDR10(vec3 rgb) {\n    vec3 tonemapped = clamp(rgb / (rgb + 1.0), 0.0, 1.0);\n    \n    uvec3 integer = uvec3(tonemapped * 1023.0);\n    uint packed = integer.x | integer.y << 10u | integer.z << 20u;\n    \n    return uintBitsToFloat(packed);\n}\n\nvec3 unpackHDR10(float packedFloat) {\n    uint packed = floatBitsToUint(packedFloat);\n    \n    uint r = packed & 0x3FFu;\n    uint g = (packed >> 10u) & 0x3FFu;\n    uint b = (packed >> 20u) & 0x3FFu;\n    \n    vec3 rgb = vec3(r, g, b) / 1023.0;\n\n    rgb = rgb / (1.0 - rgb);\n    \n    return rgb;\n}\n\n// https://www.shadertoy.com/view/wts3RX\n#define NEWTON_ITER 1\n#define HALLEY_ITER 1\n\nfloat cbrt( float x )\n{\n\tfloat y = sign(x) * uintBitsToFloat( floatBitsToUint( abs(x) ) / 3u + 0x2a514067u );\n\n\tfor( int i = 0; i < NEWTON_ITER; ++i )\n    \ty = ( 2. * y + x / ( y * y ) ) * .333333333;\n\n    for( int i = 0; i < HALLEY_ITER; ++i )\n    {\n    \tfloat y3 = y * y * y;\n        y *= ( y3 + 2. * x ) / ( 2. * y3 + x );\n    }\n    \n    return y;\n}\n\nvec4 textureVoxel(sampler2D tex, vec3 uvw) {\n    if (any(lessThan(uvw, vec3(0.0))) || any(greaterThan(uvw, vec3(1.0)))) {\n        return vec4(0.0);\n    }\n    \n    ivec2 size = textureSize(tex, 0);\n    \n    int dim = int(floor(cbrt(float(size.x*size.y))));\n    ivec3 vox = ivec3(floor(uvw*float(dim)));\n    int index = vox.x + dim*(vox.y + dim*vox.z);\n    \n    int x = index % size.x;\n    int y = index / size.x;\n    \n    return texelFetch(tex, ivec2(x,y), 0);\n}\n\n/*\n * FBCT - Fred's Basic Color Transform\n */\n \nconst float FBCT_DESATURATION = 0.02;\nconst float FBCT_EXPOSURE = 1.0;\n\nconst float FBCT_RED_BIAS = 1.1;\nconst float FBCT_GRN_BIAS = 1.0;\nconst float FBCT_BLU_BIAS = 0.9;\n\nconst mat4 fbct_color_matrix = \nmat4(\n    FBCT_RED_BIAS, FBCT_GRN_BIAS*FBCT_DESATURATION, FBCT_BLU_BIAS*FBCT_DESATURATION, 0.00,\n    FBCT_RED_BIAS*FBCT_DESATURATION, FBCT_GRN_BIAS, FBCT_BLU_BIAS*FBCT_DESATURATION, 0.00,\n    FBCT_RED_BIAS*FBCT_DESATURATION, FBCT_GRN_BIAS*FBCT_DESATURATION, FBCT_BLU_BIAS, 0.00,\n    0.0, 0.0, 0.0, FBCT_EXPOSURE\n\n);\n\nvec3 fbct_transform(vec3 color) {\n    vec4 mmr = (vec4(color, 1) * fbct_color_matrix);\n    vec3 cc = mmr.xyz * mmr.w;\n    \n    cc = cc / (cc + 1.0);\n    \n    cc = pow(cc, vec3(1.0 / 2.2));\n\n    return cc;\n}\n\n// End FBCT\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}","name":"Common","description":"","type":"common"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// particles\n#define REPULSION 10.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time=iTime;\n    ivec2 iFragCoord = ivec2(fragCoord);\n    ivec2 iResolution = ivec2(iResolution.xy);\n\n    vec3 position;\n    vec3 radiance = vec3(1.0);\n    \n    int particleId = iFragCoord.x + iFragCoord.y * iResolution.x;\n    \n    if (particleId > N_PARTICLES) discard;\n    \n    // give the voronoi buffer a bit to self-sort\n    if (iFrame < 2) {\n        position = mix(vec3(PARTICLE_MIN_RANGE), vec3(PARTICLE_MAX_RANGE), hash32(fragCoord));\n    } else {\n        vec4 lastData = texelFetch(iChannel0, iFragCoord, 0);\n        \n        position = lastData.xyz;\n        \n        ivec4 nearParticles = ivec4(textureVoxel(iChannel1, (position-PARTICLE_MIN_RANGE)/(PARTICLE_MAX_RANGE-PARTICLE_MIN_RANGE)));\n        \n        vec3 vel = vec3(0);\n        for (int i = 1; i < 4; ++i) {\n            vec3 nearestPosition = sampleParticle(iChannel0, nearParticles[i]).xyz;\n            float dist = distance(position, nearestPosition);\n\n            float repulsionFac = exp(-16.0*sqrt(dist));\n\n            vel += normalize(position - nearestPosition) * REPULSION * repulsionFac;\n        \n        }\n        \n        //position += vel;\n        \n        Material mat;\n        vec3 norm = normal(position);\n        float scene = map(position, mat);\n        position -= norm * scene;\n        position = clamp(position, vec3(PARTICLE_MIN_RANGE), vec3(PARTICLE_MAX_RANGE));\n        \n        radiance = zeroBounceLighting(SurfaceInfo(position, mat), norm);\n    }\n    \n    fragColor = vec4(position, packHDR10(radiance));\n}","name":"Buffer A","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XsXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// voronoi particle tracking\n\nvec2 projectParticle(vec4 particle) {\n    ONB camTransform = lookAt(CAM_ORG, CAM_LOOKAT);\n    vec2 acdc = reprojectCameraRay(\n        Ray(\n            CAM_ORG,\n            particle.xyz-CAM_ORG\n        ),\n        camTransform, CAM_FOV\n    );\n    vec2 ndc = vec2(acdc.x, acdc.y * (iResolution.x / iResolution.y));\n    return ndc * 0.5 + 0.5;\n}\n\nivec4 fetchParticleList(ivec2 c) {\n    return ivec4(texelFetch(iChannel0, ivec2(c), 0));\n}\n\nint rPartId(vec2 c) {\n    return int(float(N_PARTICLES) * hash12(c));\n}\nint rPartId(int c) {\n    return int(float(N_PARTICLES) * hash11(float(c)));\n}\n\nfloat particleScore(int particleId, vec2 uv) {\n    vec4 particle = sampleParticle(iChannel1, particleId);\n    vec2 puv = projectParticle(particle);\n    \n    return dot(uv-puv, uv-puv);\n}\n\nvoid sort(inout ivec4 particleIds, vec2 uv) {\n    for (int i = 1; i < 4; ++i) {\n        int key = particleIds[i];\n        float keyScore = particleScore(key, uv);\n        int j = i - 1;\n        while (j >= 0 && particleScore(particleIds[j], uv) < keyScore) {\n            particleIds[j + 1] = particleIds[j];\n            j--;\n        }\n        particleIds[j + 1] = key;\n    }\n}\n\nvoid mergeArrays(\n    out ivec4 result,          // Output sorted array\n    ivec4 a,                   // Input array 1 (sorted)\n    ivec4 b,                   // Input array 2 (sorted)\n    vec2 uv                    // Additional parameter for particleScore\n) {\n    int i = 0, j = 0, k = 0;\n\n    while (k < 4) {\n        // Get the score for particles in both arrays\n        float scoreA = (i < 4)? particleScore(a[i], uv) : 1e30;\n        float scoreB = (j < 4)? particleScore(b[j], uv) : 1e30;\n\n        // Compare and merge particles, skipping duplicates\n        if (scoreA < scoreB) {\n            if (a[i] != result[k-1]) {  // Check for duplicates\n                result[k++] = a[i];\n            }\n            i++;\n        } else {\n            if (b[j] != result[k-1]) {  // Check for duplicates\n                result[k++] = b[j];\n            }\n            j++;\n        }\n\n        // Stop merging when the result array is filled\n        if (i >= 4 || j >= 4) break;\n    }\n}\n\n\nivec4 mergeArrays(ivec4 a, ivec4 b, vec2 uv) {\n    ivec4 res;\n    mergeArrays(res, a, b, uv);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time=iTime;\n    vec2 uv = fragCoord / iResolution.xy;\n    ivec2 ifragCoord = ivec2(fragCoord);\n\n    ivec4 old = fetchParticleList(ifragCoord + ivec2( 0,  0));\n    \n    ivec4 new;\n    if (iFrame < 2) {\n        new.x = rPartId(fragCoord);\n        new.y = rPartId(new.x);\n        new.z = rPartId(new.y);\n        new.w = rPartId(new.z);\n        \n        sort(new, uv);\n    } else {\n        ivec4 north = fetchParticleList(ifragCoord + ivec2( 0,  1));\n        ivec4 south = fetchParticleList(ifragCoord + ivec2( 0, -1));\n        ivec4 east  = fetchParticleList(ifragCoord + ivec2( 1,  0));\n        ivec4 west  = fetchParticleList(ifragCoord + ivec2(-1,  0));\n        \n        ivec4 rand = ivec4(float(N_PARTICLES) * hash43(vec3(fragCoord, iFrame)));\n        \n        new = old;\n        new = mergeArrays(new, north, uv);\n        new = mergeArrays(new, south, uv);\n        new = mergeArrays(new, east , uv);\n        new = mergeArrays(new, west , uv);\n        new = mergeArrays(new, rand , uv);\n    }\n    \n    fragColor = vec4(new);\n}","name":"Buffer B","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"4sXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"ivec4 fetchParticleList(ivec3 c) {\n    ivec2 size = textureSize(iChannel0, 0);\n    float dim = floor(cbrt(float(size.x*size.y)));\n    return ivec4(textureVoxel(iChannel0, vec3(c)/dim));\n}\n\nint rPartId(vec3 c) {\n    return int(float(N_PARTICLES) * hash13(c));\n}\nint rPartId(int c) {\n    return int(float(N_PARTICLES) * hash11(float(c)));\n}\n\nfloat particleScore(int particleId, vec3 xyz) {\n    vec4 particle = sampleParticle(iChannel1, particleId);\n    vec3 pxyz = particle.xyz;\n    \n    return dot(xyz-pxyz, xyz-pxyz);\n}\n\nvoid sort(inout ivec4 particleIds, vec3 xyz) {\n    for (int i = 1; i < 4; ++i) {\n        int key = particleIds[i];\n        float keyScore = particleScore(key, xyz);\n        int j = i - 1;\n        while (j >= 0 && particleScore(particleIds[j], xyz) < keyScore) {\n            particleIds[j + 1] = particleIds[j];\n            j--;\n        }\n        particleIds[j + 1] = key;\n    }\n}\n\n// fix me!\nvoid mergeArrays(\n    out ivec4 result,          // Output sorted array\n    ivec4 a,                   // Input array 1 (sorted)\n    ivec4 b,                   // Input array 2 (sorted)\n    vec3 xyz                   // Additional parameter for particleScore\n) {\n    int i = 0, j = 0, k = 0;\n\n    while (k < 4) {\n        // Get the score for particles in both arrays\n        float scoreA = (i < 4)? particleScore(a[i], xyz) : 1e30;\n        float scoreB = (j < 4)? particleScore(b[j], xyz) : 1e30;\n\n        // Compare and merge particles, skipping duplicates\n        if (scoreA < scoreB) {\n            if (a[i] != result[k-1]) {  // Check for duplicates\n                result[k++] = a[i];\n            }\n            i++;\n        } else {\n            if (b[j] != result[k-1]) {  // Check for duplicates\n                result[k++] = b[j];\n            }\n            j++;\n        }\n\n        // Stop merging when the result array is filled\n        if (i >= 4 || j >= 4) break;\n    }\n}\n\n\nivec4 mergeArrays(ivec4 a, ivec4 b, vec3 xyz) {\n    ivec4 res;\n    mergeArrays(res, a, b, xyz);\n    return res;\n}\n\nvoid mainSpatial( out vec4 fragColor, in vec3 voxUVW )\n{\n    time=iTime;\n    \n    // todo - cache this dim\n    ivec2 size = textureSize(iChannel0, 0);\n    float dim = floor(cbrt(float(size.x*size.y)));\n    ivec3 ifragCoord = ivec3(floor(voxUVW*dim));\n    vec3 voxXYZ = mix(vec3(PARTICLE_MIN_RANGE), vec3(PARTICLE_MAX_RANGE), voxUVW);\n\n    ivec4 old = fetchParticleList(ifragCoord);\n    \n    ivec4 new;\n    if (iFrame < 2) {\n        new.x = rPartId(voxUVW*float(iFrame));\n        new.y = rPartId(new.x);\n        new.z = rPartId(new.y);\n        new.w = rPartId(new.z);\n        \n        sort(new, voxUVW);\n    } else {\n        ivec4 north = fetchParticleList(ifragCoord + ivec3( 0,  1,  0));\n        ivec4 south = fetchParticleList(ifragCoord + ivec3( 0, -1,  0));\n        ivec4 east  = fetchParticleList(ifragCoord + ivec3( 1,  0,  0));\n        ivec4 west  = fetchParticleList(ifragCoord + ivec3(-1,  0,  0));\n        ivec4 up    = fetchParticleList(ifragCoord + ivec3( 0,  0,  1));\n        ivec4 down  = fetchParticleList(ifragCoord + ivec3( 0,  0, -1));\n        \n        \n        ivec4 rand = ivec4(float(N_PARTICLES) * hash44(vec4(voxUVW, iFrame)));\n        \n        new = old;\n        new = mergeArrays(new, north, voxXYZ);\n        new = mergeArrays(new, south, voxXYZ);\n        new = mergeArrays(new, east , voxXYZ);\n        new = mergeArrays(new, west , voxXYZ);\n        new = mergeArrays(new, up   , voxXYZ);\n        new = mergeArrays(new, down , voxXYZ);\n        new = mergeArrays(new, rand , voxXYZ);\n    }\n    \n    fragColor = vec4(new);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 size = textureSize(iChannel0, 0);\n    int dim = int(floor(cbrt(float(size.x*size.y))));\n    \n    int index = int(floor(fragCoord.x)) + int(floor(fragCoord.y))*size.x;\n    if (index > dim*dim*dim) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    int x = index % dim;\n    int y = (index/dim) % dim;\n    int z = index / (dim*dim);\n\n    vec3 uvw = vec3(x,y,z)/float(dim);\n    \n    mainSpatial(fragColor, uvw);\n}","name":"Buffer C","description":"","type":"buffer"},{"outputs":[{"channel":0,"id":"XdfGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"XsXGR8","filepath":"/media/previz/buffer01.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"buffer","id":"4sXGR8","filepath":"/media/previz/buffer02.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec2 projectParticle(vec4 particle) {\n    ONB camTransform = lookAt(CAM_ORG, CAM_LOOKAT);\n    vec2 acdc = reprojectCameraRay(\n        Ray(\n            CAM_ORG,\n            particle.xyz-CAM_ORG\n        ),\n        camTransform, CAM_FOV\n    );\n    vec2 ndc = vec2(acdc.x, acdc.y * (iResolution.x / iResolution.y));\n    return ndc * 0.5 + 0.5;\n}\n\n// squared distance\nfloat d2(vec3 a, vec3 b) {\n    return dot(a-b, a-b);\n}\n\n#if 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    vec2 acdc = vec2(ndc.x, ndc.y * (iResolution.y / iResolution.x));\n    \n    ONB camTransform = lookAt(CAM_ORG, CAM_LOOKAT);\n    Ray cam = cameraRay(acdc, CAM_ORG, camTransform, CAM_FOV);\n    \n    SurfaceInfo inf;\n    \n    float d = march(cam, inf);\n    \n    vec3 col;\n    float depth;\n    if (d < MARCH_MISS) {\n        depth = distance(inf.pos, CAM_ORG);\n            // hit\n        vec3 norm = normal(inf.pos);\n        col = vec3(0.0);\n        \n        col += zeroBounceLighting(inf, norm);\n        \n        SurfaceInfo binf;\n        float d = march(Ray(inf.pos+norm*.001, norm), binf);\n        \n        vec3 bounceLight = vec3(0);\n\n        ivec4 lightParticles = ivec4(textureVoxel(iChannel2, clamp((binf.pos-PARTICLE_MIN_RANGE)/(PARTICLE_MAX_RANGE-PARTICLE_MIN_RANGE), vec3(0.0), vec3(1.0))));\n        if (lightParticles != ivec4(0)) {\n\n            int n = 1;\n            for (int i = 0; i < n; i++) {\n                vec4 particle = sampleParticle(iChannel0, lightParticles[i]);\n\n                vec3 pos = particle.xyz;\n                vec3 pnorm = normal(pos);\n\n                float inv_sq = 1.0 / sqrt(dot(pos-inf.pos, pos-inf.pos));\n                float lambert0 = max(dot(normalize(pos-inf.pos),  norm), 0.0);\n                float lambert1 = max(dot(normalize(inf.pos-pos), pnorm), 0.0);\n\n                bounceLight += inf.mat.diffuseColor * lambert0 * lambert1 * inv_sq * unpackHDR10(particle.w) / float(n);\n            }\n        }\n        col += bounceLight;\n        \n    } else {\n        depth = 1.0e30;\n            // miss\n        col = skyColor(cam.direction);\n    }\n    \n    //col = fbct_transform(col);\n    col = pow(col, vec3(1.0/2.2));\n\n    // Output to screen\n    fragColor = vec4(col, depth);\n}\n#else\n\nvoid _mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //vec3 pcl = unpackHDR10(sampleParticle(iChannel0, int(data.x)).w);\n    vec3 pcl = data.xyz;\n    fragColor = vec4(pow(pcl, vec3(1.0/2.2)), 0.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    time = iTime;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= iResolution.y / iResolution.x;\n    \n    ONB camTransform = lookAt(CAM_ORG, CAM_LOOKAT);\n\n    ivec4 data = ivec4(texelFetch(iChannel1, ivec2(fragCoord), 0));\n    \n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 4; ++i) {\n        vec4 particle = sampleParticle(iChannel0, data[i]);\n\n        \n        if (dot(particle.xyz-CAM_ORG, camTransform.forward) > 0.0) {\n            vec2 loc = projectParticle(particle);\n            loc.y *= iResolution.y / iResolution.x;\n\n            vec3 val = unpackHDR10(particle.w)*exp(-dot(loc-uv,loc-uv)*iResolution.x*32.0) / 4.0;\n            \n            col += val;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}\n#endif","name":"Buffer D","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"Mc3BWX","date":"1733772689","viewed":20,"name":"Distributed Particle GI","username":"FrederickAmpsUp","description":"aaaaaaanother attempt at making fast-ish GI without path tracing","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","template"],"hasliked":0,"parentid":"M33Sz2","parentname":"Raymarching template v2"}}