{"ver":"0.1","info":{"id":"sdGXzK","date":"1634914245","viewed":135,"name":"Angular Distance","username":"spalmer","description":"a way to measure distance to points relative to ray cheaply such that you get basically free perspective correction","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["intersection","distance","perspective","cross","point"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// even more primitive idea than \n// AngularSeg from http://shadertoy.com/view/ssyXzy\n// I discovered this little trick first,\n// and only after much banging of my head\n// against the problem did I manage to \n// come up with AngularSeg.\n// my apologies for the naming, I had no idea what to call this.\n\n// iirc I started with a simple angularly-computed disc\n// then noticed \"hey, I can get perspective correction\n// by removing a sqrt\" and wound up with this!\n\n// after much consideration of the issue\n// I have come to the conclusion that this simply\n// exploits the sine proportionality properties\n// of the cross product to measure perpendicular distance.\n// but using cross product to do this turns out not\n// to be the optimal way after all, but converting\n// back to more optimal dot product formulation\n// requires some noodling.\n// see angularDistanceSquaredDotted!\n\n// view vector d is assumed unit length\n\n// original version for posterity\nfloat angularDistance(vec3 d, vec3 a)\n{\n\treturn length(cross(d, a));\n}\n\n// just verifying that one may compute this way alternatively,\n// just the length of the rejection of a by d\nfloat angularDistanceVerification(vec3 d, vec3 a)\n{\n    return length(a - d * dot(d, a));\n}\n// yep it's exactly the same\n// iq has apparently been doing it this way somehow\n\nconst float pi = acos(-1.), tau = 2.*pi;\n\n// when doing multiple shapes, sqrt should be\n// factored to the end for efficiency.\nfloat sqr(vec3 v) { return dot(v,v); }\n// square but keep sign\nfloat ssqr(float x) { return x*abs(x); }\n\n// squared cross product way is not most efficient\nfloat angularDistanceSquared(vec3 d, vec3 a)\n{\n    return sqr(cross(d, a));\n}\n //vec3 v = cross(d, a); return dot(v, v); // inline sqr\n\n\n// ok so Maxima can't help here.\n// the key insight is that I use the fact that the\n// cross product of a and b gives a vector \n// perpendicular to both, and with length equal to\n// the length of a times length of b times the sine\n// of the angle between the vectors.\n// but it's pretty expensive to calculate that way.\n// I saw iq do it with just dot products! here  http://shadertoy.com/view/4slGz4\n// so I know it can be done.  SO\n// what if we just use the fact that the dot product\n// of a and b gives the length of a times length of b times\n// the cosine of the angle between the vectors.\n// then using trigonometry, we may reconstruct the sine from the cosine\n// (after removing the length) then putting it back in?\n// maybe can just do all at once somehow.\n// but currently I only know how to convert cosines to sines when normalized.\n// ok so dot(a,b) = |a|*|b|*cos(a,b), in my case b = my d vector which is unit length\n// so I'd already have |a|*cos\n// so if divide out |a| we have just cosine\n// then s = sqrt(1-c*c)\n// then multiply |a| again\n// so something like:\n    //, g = dot(d, d), // but we assume g == 1\n          //h = sqrt(f),\n          //c = e / h\n          //,s = sqrt(1. - c*c)\n    //return s * h;\n    // well duh that's just\n    //return sqrt(f * (1. - c*c));\n    // and since c * c == e * e / sqrt(f) / sqrt(f),\n    //return sqrt(f * (1. - e * e / f));\n          //, f = dot(a, a); return sqrt(f - e * e); // inline sqr\n// wow.  just, wow.  I did it!!  yay!!\n\nfloat angularDistanceDotted(vec3 d, vec3 a)\n{\n    float e = dot(d, a);\n    return sqrt(sqr(a) - e * e);\n}\n\nfloat angleApprox(vec3 d, vec3 a)\n{\n    float e = dot(d, a), l = sqr(a);\n    return sqrt((l - e * e) / l);\n    float c = e / (length(a) + 1e-7);\n    float s = sqrt(max(0., 1. - c * c));\n    return s;\n}\n    //return asin(s); // yeah but we don't want the exact angle here, we want the sine, which is a good approximation when angle is small\n\nfloat angleExact(vec3 d, vec3 a)\n{\n    float e = dot(d, a);\n    // so e here is |a| times some cosine between d and a vectors\n    // c = e / length(a);\n    float c = e / (length(a) + 1e-7); // / length(d)\n    //c = min(1., c);\n    // angle in radians using acos\n    return acos(c);\n    // sine is s = sqrt(1 - c * c)\n    //float s = sqrt(max(0., 1. - c * c));\n    // the actual angle would be asin(s)\n    //return asin(s);\n    // there's probably a clever way using atan ..\n    //return atan(s, c); //atan(s / c); //\n}\n\nfloat angularDistanceSquaredDotted(vec3 d, vec3 a)\n{\n    float e = dot(d, a); return sqr(a) - e * e;\n}\n\n    //float e = dot(d, a); return dot(a, a) - e * e; // inline sqr\n\n// none of this helped:\n//float angularDistanceSquaredInlined(vec3 d, vec3 a)\n//{\n//    return (d.y*a.z - d.z*a.y)*(d.y*a.z - d.z*a.y) + (d.z*a.x - d.x*a.z)*(d.z*a.x - d.x*a.z) + (d.x*a.y - d.y*a.x)*(d.x*a.y - d.y*a.x);\n//}\n//float angularDistanceSquaredExpanded(vec3 d, vec3 a)\n//{\n//    vec3 v = vec3(\n//        d.y*a.z - d.z*a.y,\n//        d.z*a.x - d.x*a.z,\n//        d.x*a.y - d.y*a.x);\n//    return v.x*v.x + v.y*v.y + v.z*v.z;\n//}\n\n// going for cosines instead? it's an idea!\n//float angd2(vec3 d, vec3 a)\n//{\n//    return dot(d, a) / length(a);\n//}\n\n// attempting to fix the result scale depending on length of vector a problem\n//float angularDSq(vec3 d, vec3 a)\n//{\n//    float e = dot(d, a),\n//        f = sqr(a) - e * e;\n//    return f / sqr(a);\n//}\n// well it fixes it!  squared distances from different balls come out the same scale now... pretty much, anyway\n// but unfortunately it loses the perspective on the 'spheres'\n// there's still a bit of 'lens distortion' or something, maybe perspective correction will help\n//\n/*\n// trying taking the radius into account up front, so we measure from the edge properly from the start!\nfloat angularBallDSq(vec3 d, vec3 a, float r)\n{\n    float e = dot(d, a),\n    // e = cosine_between(d, a) * length(a)\n        f = sqr(a) - e * e; // wait, isn't this some approximation to the sine of the angle?\n        // because sine would be sqrt(1 - sqr(e / length(a))) or sqrt(1 - e * e / sqr(a)) or sqrt((sqr(a) - e * e)/sqr(a)) !!\n// now asin is just ridiculous, but I'm trying to understand what problem I'm actually seeing\n    return 1.*asin(f / sqr(a)) - asin(r/length(a));\n    // so I've now returned the actual sine of the angle\n    // aha, I just need a asin()!\n}\n// getting to the point where I'm like confused by the squared thing,\n// perhaps I should try stuff unsquared first\nfloat angularBallD(vec3 d, vec3 a, float r)\n{\n    float l = length(a),\n        e = dot(d, a) / l;\n    return sqrt(e); // TODO WIP\n}\n*/\n\n// minimum is not the best operator to use to combine them!\n// ok and that since it's just radial distances, it's not very good for lighting!\n// can maybe fake some rounded appearance by reshaping the distances near 0.\n// or by use of auto derivatives in more clever ways than I know.\n\n// another problem with this technique is that it also projects\n// in the backwards direction; nothing guards against projecting points\n// that are in fact behind the camera, and the length of their cross\n// products are the same.  So what we really need in practice is more of\n// a \"distance squared to ray\" function, instead of \"to infinite line\"\n// so must also limit somehow; getting into clamping line segments is\n// overkill for this toy, but should note that if the dot product\n// of the ray direction w the direction to point is negative, \n// the point is behind the camera and drawing of it should be skipped.\n// That never happens in this toy, or any of these example toys\n// of mine here, so it's not coded.\n\nfloat angularDShim(vec3 d, vec3 a)\n{\n    return \n        angularDistance\n        //angularDistanceVerification\n        //angularDistanceDotted\n        (d, a)\n        / length(a);\n}\n\nfloat chooseAngularDSq(vec3 d, vec3 a)\n{\n #if 1\n    return\n        //angularDistanceSquared\n        angularDistanceSquaredDotted\n        //angularDistanceSquaredInlined\n        //angularDistanceSquaredExpanded\n        (d, a)\n        / sqr(a);\n #else\n    return ssqr(\n        //angularDShim\n        //angleApprox\n        angleExact\n        (d, a));\n #endif\n}\n\nvoid mainImage(out vec4 o, vec2 p)\n{\n    vec2 r = iResolution.xy;\n    vec3 d = normalize(vec3(p - .5*r, r.y)); // got idea from coyote\n    float n = 5., h = 9e9, k = h, z = .5, poof = 1.;\n    for (float i = 1.; i > 0.; i -= 1./n) {\n        vec3 a = vec3(0,0,8) + vec3(3.*sin(vec3(0,11,7) + .3*iTime + vec3(3,4,5) * .1*iTime + 6.*i));\n        float dd = chooseAngularDSq(d, a);\n        // poof inside the loop while we still have access to vector a\n        // not quite as slick as what I had originally\n        dd = ssqr(sqrt(dd) - poof / length(a)); // but slowly and awkwardly because dd is squared\n        h = min(h, dd);\n    }\n    h = sqrt(abs(h)) * sign(h); //h = sqrt(h); //ssqrt\n        // if I don't actually scale the perp distances by the range,\n        // we can't do it outside the loop anymore\n  #if 0\n    // visualizes as a linear ramp, gamma close enough\n    // distance relative to poof = white\n    h /= poof; // exhibit linear gradient center to poof radius\n  #elif 0\n    h = h - poof;\n  #endif\n    h *= 6.;\n    bool inside = h < 0.;\n    // when using exact angle to edge,\n    // can see that the isolines near edge\n    // of viewport are more distorted.\n    // this division corrects for such perspective distortion.\n    h /= d.z;\n  #if 1\n    h = sin(.1 * r.y * h) * .05 + .5; // isoline vis\n  #elif 1\n    // alternate display: antialiasing mask\n    h = .5 + .2 * r.y * h;\n    //h *= r.y;\n  #endif\n    o = vec4(sqrt(h));  //pow(h, .45); // gamma\n    if (inside) o.rb *= .5;\n}\n        //float l = length(a), s = dd;\n        //if (s + l < h + k) h = s, k = l; // TODO combine taking perspective into account - favors closer - needs apparent radius?       \n        //k = max(k, angd2(d, a));\n        \n/*\n// stole quadratic solver from Orbit Camera just to verify this http://shadertoy.com/view/WlVGD1\nfloat Root(vec3 f) // first zero crossing of polynomial quadric function\n{\n    float dsc = .25 * f.y * f.y - f.x * f.z;\n    if (dsc < 0.) return -1.; // no intersection\n\tfloat d = sqrt(dsc);\n\tif (f.y * f.z < 0.) d = -d;\n\treturn (d - .5 * f.y) / f.z;\n}\n*/\n        // simple sphere intersection to verify perspective\n        //if (Root(vec3(dot(a, a) - 1., -2. * dot(a, d), 1.)) >= 0.) z = 0.; // sure enough!  looked exactly the same\n\n// trig would even suffice (see acos above) - could work out the sphere with tangents instead,\n// idk how many ways I need to verify the same thing!\n\n// the entire point though is to avoid trigonometric transcendental computations\n\n// I've been using this trick for *years*, the length of cross product trick anyway.\n// I must have discovered this myself at least 10, 15 years ago.\n// But recently someone posted a toy tkasch http://shadertoy.com/view/stc3zN\n// which is based on The Art Of Code youtube tutorial http://youtube.com/watch?v=PBxuVlp7nuM\n// BigWIngs toy http://shadertoy.com/view/4dfBRf\n// BigWIngs simpler toy http://shadertoy.com/view/XdsfW8\n// corresponding video where he explains a bit more about the\n// projection technique, how the math behind it works,\n// which is cool, because it means I don't have to \n// explain cross products to you!  :D\n// http://youtube.com/watch?v=dKA5ZVALOhs\n// This explains the lack of excitement about the\n// technique, everyone here has seen it before!  ;)\n// apparently iq knows about it too, uses a dot product\n// version apparently since like 2013 or before.\n// http://shadertoy.com/view/4slGz4\n// But I bet nobody did splines with it yet!  haha  http://shadertoy.com/view/flt3Rr\n// except bloxard!  ;)  http://shadertoy.com/view/3sjXDm\n// but not entirely sure he's doing it the same way.\n","name":"Image","description":"","type":"image"}]}