{"ver":"0.1","info":{"id":"XdyyRK","date":"1522522073","viewed":378,"name":"Gas giant.","username":"Pr0fed","description":"Really just a worley-perlin noise with another layer of worley noise which controls overall \"chunks\" animation with the help of cycling vertical line. I suppose i must switch some other noises as well :)","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["noise","fbm","perlin","vorno"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Rotation matrix, it does a big impact, as usual.\nconst mat2 m = mat2( 1.40,  1.00, -1.00,  1.40 );\n\n// Time simplification and easier overall speed control.\n#define time iTime * 0.35\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    return smoothstep(0.0, 1.35, -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y))));\n}\n\n// 2D gradient noise\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat r(float n)\n{\n \treturn fract(cos(n*72.42)*173.42);\n}\n\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*63.62-234.0+n.y*84.35),r(n.x*45.13+156.0+n.y*13.89)); \n}\n\nfloat worley2D(in vec2 n)\n{\n    float dis = 2.0;\n    for (int y= -1; y <= 1; y++) \n    {\n        for (int x= -1; x <= 1; x++) \n        {\n            // Neighbor place in the grid\n            vec2 p = floor(n) + vec2(x,y);\n\n            float d = length(r(p) + vec2(x, y) - fract(n));\n            if (dis > d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    \n    return 1.0 - dis;\n}\n\n// Four octave worley FBM.\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000 * worley2D( p ); p = p * 2. * m;\n    f += 0.2500 * worley2D( p ); p = p * 2. * m;\n    f += 0.1250 * worley2D( p ); p = p * 2. * m;\n    f += 0.0625 * worley2D( p );\n    return f;\n}\n\n// Six octave perlin FBM.\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.250000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.125000 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.062500 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.031250 * (0.5 + 0.5 * noise2D( p )); p = m * p * 2.;\n    f += 0.015625 * (0.5 + 0.5 * noise2D( p ));\n    return f;\n}\n\nfloat GetFBM( vec2 q, out vec4 ron, out vec2 rk)\n{\n    // Base motion.\n    float ql = length( q * m );\n    q += 0.05 * (0.5 + 0.5 * sin(time + ql * 1.05));\n\n    // First layer.\n    vec2 o;\n    \n    // Vice versing fbm's addition for points gives nice result.\n    o = vec2(fbm4(q + fbm6( vec2(2.0 * q + vec2(6.)))));\n\n    // Second layer.\n    vec2 n;\n    n = vec2(fbm6(q + fbm4( vec2(2.0 * o + vec2(2.)))));\n    \n    // Third layer.\n    vec2 k;\n    \n    // Line movement.\n    k = sin(0.25 * q.x - time) * vec2(fbm4(q * fbm4( vec2(2.0 * n + vec2(2.)))));\n    \n    // Sum of points with increased sharpness. \n    vec2 p = 4.0 * o + 6.0 * n + 8.0 * k ;\n    float f = 0.5 + 0.5 * fbm6( p ) ;\n\n    // I have seen that cubic mixing a couple of times\n    // is it just gives a nice result, or there is something\n    // behind it? Anyone?\n    f = mix( f, f * f * f * 3.5, f * abs(n.y));\n\n    f *= 1.0 - 0.55 * pow( f, 8.0 );\n    \n\tron = vec4( o, n );\n    rk = vec2(k);\n\n    return f;\n}\n\n// Main color mixing function.\nvec3 GetColor(vec2 p)\n{\n    vec4 on = vec4(0.0);\n    vec2 k = vec2(0.0);\n    \n    float f = GetFBM(p, on, k);\n    \n    vec3 col = vec3(0.0);\n    \n    // Our 'background' bluish color.\n    col = mix( vec3(0.18, 0.45, 0.86), vec3(0.0, 0.0, 0.41), f );\n    \n    // Dark orange front layer.\n    col = mix( col, vec3( 0.91, 0.55, 0.0), dot(on.xy, on.zw));\n    \n    // Touch of cyan.\n    col = mix( col, vec3(0.0, 0.33, 0.62), 0.2 * smoothstep(0.8, 1.6, abs(k.x) + abs(k.y)));\n    \n    return col * col * 7. * 0.4545;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Aspect ratio - UV normalization.\n   \tvec2 p = (2. * fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // Zoom level.\n    p*= 4.;\n    \n    vec3 col = GetColor( p );\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}