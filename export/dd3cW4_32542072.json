{"ver":"0.1","info":{"id":"dd3cW4","date":"1695056576","viewed":31,"name":"draw cubic with texture","username":"tomcat7479","description":"draw cubic with texture","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n    绘制带有纹理的正方体\n*/\n\n#define N 3\n#define PI 3.1415926\n#define min_iter_distance 0.1\n#define max_iter_distance 200.0\n#define iter_count 200\n#define iter_precision 1e-4\n#define plane_id 1.0\n#define cubic_id 2.0\n\n\nvec2 fix(in vec2 fragCoord) {\n    return (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n}\n\nmat3 setCamera(vec3 lookAt, vec3 ro, float theta) {\n    vec3 z = normalize(lookAt - ro);\n    vec3 y_dir = vec3(sin(theta), cos(theta), 0.0);\n    vec3 x = normalize(cross(z, y_dir));\n    vec3 y = normalize(cross(x, z));\n    return mat3(x, y, z);\n}\n\nfloat sdfPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdfCubic(vec3 p, vec3 center, vec3 edge) {\n    p -= center;\n    vec3 q = abs(p) - edge / 2.0;\n    return length(max(q, 0.0)) + min(max(max(q.x, q.y), q.z), 0.0);\n}\n\nvec2 union_map(vec3 p, vec3 center, vec3 edge) {\n    float d_plane = sdfPlane(p) + edge.y * 2.0;\n    float d_cubic = sdfCubic(p, center, edge);\n    float d = min(d_cubic, d_plane);\n    float id = d_plane < d_cubic ? plane_id : cubic_id;\n    return vec2(id, d);\n}\n\nvec3 calNormal(vec3 p, vec3 center, vec3 edge) {\n    const float h = 1e-4;\n    const vec2 k = vec2(1.0, -1.0);\n    vec3 part1 = k.xyy * union_map(p + k.xyy * h, center, edge).y;\n    vec3 part2 = k.yyx * union_map(p + k.yyx * h, center, edge).y;\n    vec3 part3 = k.yxy * union_map(p + k.yxy * h, center, edge).y;\n    vec3 part4 = k.xxx * union_map(p + k.xxx * h, center, edge).y;\n    return normalize(part1 + part2 + part3 + part4);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, vec3 center, vec3 edge) {\n    float t = min_iter_distance;\n    vec2 res = vec2(-1.0);\n    for (int i = 0; i < iter_count; i++) {\n        vec3 p = ro + t * rd;\n        vec2 unionMap = union_map(p, center, edge);\n        if (unionMap.y < iter_precision) {\n            res = vec2(unionMap.x, t);\n            break;\n        }\n        t += unionMap.y;\n        res.y = t;\n    }\n    return res;\n}\n\nvec3 render(in vec2 uv) {\n    vec3 lookAt = vec3(0.0, 0.0, 0.0);\n    float foucs_distance = 1.5;\n    vec3 ro = vec3(4.0 * sin(iTime / 8.0 * PI), 1.0, 4.0 * cos(iTime / 8.0 * PI));\n    if (iMouse.z > 0.1) {\n        float theta = iMouse.x / iResolution.x * 2.0 * PI;\n        ro = vec3(4.0 * cos(theta), 2.0 * (-2.0 * iMouse.y / iResolution.y + 1.), 4.0 * sin(theta));\n    }\n    mat3 camera = setCamera(lookAt, ro, 0.0);\n    vec3 rd = normalize(camera * vec3(uv, foucs_distance));\n    vec3 cubic_center = vec3(0.0);\n    vec3 cubic_edge = vec3(2.0);\n    vec2 rayMarch = rayMarch(ro, rd, cubic_center, cubic_edge);\n    float id = rayMarch.x;\n    vec3 plane_color = vec3(0.77);\n    vec3 cubic_color = vec3(0.61, 0.96, 0.47);\n    vec3 color = vec3(0.0);\n    if (rayMarch.y < max_iter_distance) {\n        if (id < 1.1) {\n            color = plane_color;\n        } else if (id < 2.1) {\n            color = cubic_color;\n            vec3 p = ro + rayMarch.y * rd;\n            vec3 n = normalize(calNormal(p, cubic_center, cubic_edge));\n            vec3 texColorXY = texture(iChannel0, p.xy * 0.5 + 0.5).rgb;\n            vec3 texColorYZ = texture(iChannel0, p.yz * 0.5 + 0.5).rgb;\n            vec3 texColorXZ = texture(iChannel0, p.xz * 0.5 + 0.5).rgb;\n            // texColorXY *= abs(n.z); // xoy平面的外法向量朝向z轴，所以这里只能显示xoy正反两面的纹理，其余完全是黑色\n            // 同理可得其余xoz平面和yoz平面\n            n = abs(n);\n            color = texColorXY * n.z + texColorYZ * n.x + texColorXZ * n.y;\n        }\n    }\n    return color;\n}\n\nvec3 after_smooth(in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 offset = 2.0 * (vec2(float(i), float(j)) / float(N) - 0.5);\n            vec2 uv = fix(fragCoord + offset);\n            color += render(uv);\n        }\n    }\n    return color / float(N * N);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(after_smooth(fragCoord), 1.0);\n}","name":"Image","description":"","type":"image"}]}