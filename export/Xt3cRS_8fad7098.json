{"ver":"0.1","info":{"id":"Xt3cRS","date":"1718965653","viewed":62,"name":"ray marching phantom test","username":"waltmannz","description":"ray marching phantom test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarchingmouse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\n\n//------------------------------------------------------------\n// Scene setup\n//------------------------------------------------------------\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nmat4 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(1, 0, 0, 0),\n        vec4(0, c, -s, 0),\n        vec4(0, s, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, -s, 0, 0),\n        vec4(s, c, 0, 0),\n        vec4(0, 0, 1, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nvec3 opRepLim(vec3 p, float c, vec3 l){\n    vec3 q = p - c*clamp(round(p/c),-l,l);\n    return q; }\n\nfloat sceneSDF(vec3 p){\n\n    float mx = iMouse.x - iResolution.x / 2.0;\n    mx = mx/iResolution.x*10.0;\n    float my = iMouse.y - iResolution.y / 2.0;\n    my = my/iResolution.y*5.0;\n    //head\n    vec3 head = p-vec3(-0.094,1.04,-0.03);\n    float sphere = length(head)-0.21;\n    float sphere2 = length(p-vec3(-0.028,0.8,-0.03))-0.25;\n    //float sphere3 = length(p-vec3(0.012,0.2,-0.03  ))-0.55;\n    vec3 body = p-vec3(0.02,0.28,0.01);\n    float sphere3 = sdEllipsoid(body, vec3(0.5,0.6,0.45));\n    float body2 = sdEllipsoid(body-vec3(0,-0.25,0), vec3(0.5,0.4,0.45));\n\n    //eyes\n    float eyeL = sdSphere(head-vec3(-0.04,0.01,0.18), 0.05);\n    float dist = opSmoothSubtraction(eyeL,sphere,0.01);\n\n    float eyeR = sdSphere(head-vec3(0.085,0.04,0.18), 0.051);\n    dist = opSmoothSubtraction(eyeR,dist,0.01);\n\n    dist = opSmoothUnion(dist,sphere2,0.11);\n    dist = opSmoothUnion(dist,sphere3,0.15);\n    dist = opSmoothUnion(dist,body2,0.15);\n\n    float sphere4 = length(p-vec3(0.2,0.5,-0.03  ))-0.30;\n    dist = opSmoothUnion(dist,sphere4,0.2);\n\n    float sphere5 = length(p-vec3(-0.2,0.3,-0.03 ))-0.30;\n    dist = opSmoothUnion(dist,sphere5,0.3);\n\n    //left leg (from camera)\n    vec3 lL = p-vec3(-0.36,-1.07,0);\n    lL = (rotateZ(-0.16) * vec4(lL, 1.0)).xyz;\n    float legL = sdRoundCone( lL,  0.05,  0.3,  1.0);\n    dist = opSmoothUnion(dist,legL,0.15);\n\n    lL = (rotateZ(0.05) * vec4(lL, 1.0)).xyz;\n    legL = sdRoundCone( lL-vec3(-0.02,0.07,0),  0.05,  0.3,  1.0);\n    dist = opSmoothUnion(dist,legL,0.1);\n\n    //right leg (from camera)\n    vec3 rL = p-vec3(0.39,-1.2,0);\n    rL = (rotateZ(0.13) * vec4(rL, 1.0)).xyz;\n    float legR = sdRoundCone( rL,  0.05,  0.31,  1.1);\n    dist = opSmoothUnion(dist,legR,0.2);\n\n    rL = (rotateZ(-0.01) * vec4(rL, 1.0)).xyz;\n    legR = sdRoundCone( rL-vec3(0,0.07,0),  0.05,  0.31,  1.1);\n    dist = opSmoothUnion(dist,legR,0.1);\n\n\t//left arm (from camera)\n    vec3 lA = p-vec3(-0.55,-0.15,0);\n    lA = (rotateZ(-0.4) * vec4(lA, 1.0)).xyz;\n    float armL = sdRoundCone( lA,  0.05,  0.1,  0.6);\n    dist = opSmoothUnion(dist,armL,0.2);\n\n    float lA2 = sdEllipsoid(lA-vec3(-0.02,0.4,0), vec3(0.15,0.3,0.15));\n    dist = opSmoothUnion(dist,lA2,0.2);\n\n    //right arm (from camera)\n    vec3 rA = p-vec3(0.6,-0.1,0);\n    rA = (rotateZ(0.3) * vec4(rA, 1.0)).xyz;\n    float armR = sdRoundCone( rA,  0.05,  0.1,  0.6);\n    dist = opSmoothUnion(dist,armR,0.2);\n\n    float rA2 = sdEllipsoid(rA-vec3(-0.05,0.35,0), vec3(0.15,0.3,0.15));\n    dist = opSmoothUnion(dist,rA2,0.2);\n    \n    float mouse = length(p-vec3(mx,my,0.0))-0.5;\n    dist = opSmoothUnion(mouse,dist,0.5);\n\n\n    return dist;\n}\n\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n* Return the shortest distance from the eyepoint to the scene surface along\n* the marching direction. If no part of the surface is found between start and end,\n* return end.\n* \n* eye: the eye point, acting as the origin of the ray\n* marchingDirection: the normalized direction to march in\n* start: the starting distance away from the eye\n* end: the max distance away from the ey to march before giving up\n*/\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\n/**\n * Return a transformation matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction.\n */\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\tvec3 f = normalize(center - eye);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(45.0) / 2.0);\n    vec3 viewDir = normalize(vec3(xy,-z)); \n    \n\tvec3 eye = vec3(0.0, 0.0, 12.0);\n \tmat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    vec3 light_position = vec3(2.0, -5.0, -3.0);\n    vec3 p = eye + dist * worldDir; \n    vec3 direction_to_light = normalize(p - light_position);\n    vec3 normal = estimateNormal(p);\n    float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\tvec3 colourOut = vec3(44.0/255.0, 253.0/255.0, 201.0/255.0) * diffuse_intensity;\n\t\n    \n    fragColor = vec4(colourOut, 1.0);\n}","name":"Image","description":"","type":"image"}]}