{"ver":"0.1","info":{"id":"3dScRR","date":"1585916179","viewed":94,"name":"Flower-like Fractal","username":"kruzifix","description":"Fractal created by folding space multiple times along different normals and then applying the sdf of a box.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Source Material:\n// Great source for all kinds of computer graphics stuff: https://iquilezles.org/\n// Fractals: http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n\n// Videos:\n// Ray marching setup and HDR colors: https://www.youtube.com/watch?v=Cfe5UQ-1L9Q\n// SDF maths: https://www.youtube.com/watch?v=sl9x19EnKng\n\nfloat boxSDF(in vec3 p, in vec3 r)\n{\n    return length(max(abs(p) - r, 0.0));\n}\n\nvec3 fold3(in vec3 p, in vec3 n)\n{\n    return p - 2.0 * min(0.0, dot(p, n)) * n;\n}\n\n// Signed distance function that describes the scene\nfloat sceneSDF(in vec3 pos)\n{    \n    for (int i = 0; i < 15; ++i)\n    {\n        float t = float(i) * 1.0 + cos(iTime) * 0.18;\n        vec3 n = normalize(vec3(cos(t), sin(t), sin(t)));\n        \n        pos = fold3(pos, n);\n        \n        if (mod(float(i), 2.0) < 1.0)\n        {\n            float x = n.x;\n            n.x = n.z;\n            n.z = x;\n            pos = fold3(pos, n);\n        }\n    }\n    \n    vec3 off = vec3(1.8, 0, 0);\n    return boxSDF(pos - off, vec3(2.7, 0.2, 0.3)) - 0.3;\n}\n\n// Approximates the normal of the surface at the given position\n// by calculating the gradient of the scene SDF\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    \n    return normalize(vec3(\n        sceneSDF(pos + e.xyy) - sceneSDF(pos - e.xyy),\n        sceneSDF(pos + e.yxy) - sceneSDF(pos - e.yxy),\n        sceneSDF(pos + e.yyx) - sceneSDF(pos - e.yyx)));\n}\n\n// Returns the distance to scene surface.\n// If the ray hit nothing this returns -1.0\nfloat rayMarchScene(in vec3 rayOrigin, in vec3 rayDir)\n{\n    float t = 0.0;\n    for (int i = 0; i < 100; ++i)\n    {\n        vec3 pos = rayOrigin + rayDir * t;\n        \n        float dist = sceneSDF(pos);\n        t += dist;\n        if (dist < 0.00001)\n            break;\n        if (t > 100.0)\n            return -1.0;\n    }\n    \n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    //vec2 mouse = vec2(0.5, 1.0);\n    float time = mouse.x * 6.28;//iTime * 0.2;\n    float cameraDist = 2.6;\n    float upDownAngle = mouse.y-0.6;\n    \n    vec3 rayOrigin = vec3(cos(time), sin(upDownAngle)*1.2, sin(time)) * cameraDist;\n    vec3 lookAtPos = vec3(0.0, 0.6, 0.0);\n    \n    vec3 forward = normalize(lookAtPos - rayOrigin);\n    vec3 right = cross(forward, vec3(0.0, 1.0, 0.0));\n    vec3 up = cross(right, forward);\n    \n    vec3 rayDir = normalize(forward + right * uv.x + up * uv.y);\n    \n    float t = rayMarchScene(rayOrigin, rayDir);\n    \n    // Skybox color\n    vec3 skyCol = vec3(0.5, 0.2, 0.1) + rayDir.y * 0.1;\n    vec3 col = skyCol;\n    if (t > 0.0)\n    {\n        vec3 surfacePos = rayOrigin + rayDir * t;\n        vec3 normal = calcNormal(surfacePos);\n        \n        col = normal;\n        col.x = abs(col.x);\n        col.z = -abs(col.z);\n        col *= 0.5;\n        col += 0.5;\n    }\n    \n    // Gamma correction\n    col = pow(col, vec3(0.4545));    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}