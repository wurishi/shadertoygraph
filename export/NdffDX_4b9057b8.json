{"ver":"0.1","info":{"id":"NdffDX","date":"1677672417","viewed":49,"name":"Anti-aliased Line","username":"altaha","description":"anti-aliasing line shader","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["line","aliasing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x/iResolution.y;\n    //vec3 col1 = vec3(255., 235., 59.)/255.;\n    //vec3 col2 = vec3(3., 169., 244.)/255.;\n    vec3 buffer = texture(iChannel0,uv).rgb;\n    float t = clamp(buffer.r,0.0,1.5);\n    vec3 col1 = vec3(178., 255., 89.)/255.;\n    vec3 col2 = vec3(255., 235., 59.)/255.;\n    vec3 final = mix(col1,(t)*col2,t);\n    //final = uv.y>0.9?col1:final;\n    //final = uv.y<0.1?col2:final;\n    //final = uv.y>0.5?buffer:final;\n    fragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float lineY(float yPos, float width, vec2 modUV){\n    float noise = sin(fract(modUV.x+iTime*0.15)*6.28*3.)*0.005;\n    float line = smoothstep(1.5,-1.5, iResolution.y*(modUV.y-(yPos+width)+noise))\n                *smoothstep(-1.5,1.5, iResolution.y*(modUV.y-(yPos)+noise));\n    return line;\n}\n\nfloat lineX(float xPos, float width, vec2 modUV){\n    float noise = sin(fract(modUV.y+iTime*0.15)*6.28*3.)*0.005;\n    float line = smoothstep(1.5,-1.5, iResolution.y*(modUV.x-(xPos+width)+noise))\n                *smoothstep(-1.5,1.5, iResolution.y*(modUV.x-(xPos)+noise));\n    return line;\n}\n\nfloat circle(vec2 center, float radius, vec2 uv,float aspect){\n    uv *= vec2(aspect,1.0);\n    center.x *= aspect;\n    float c = smoothstep(radius, radius - 0.01, distance(uv, center)) *\n              smoothstep(radius - 0.001 - 0.01, radius - 0.001, distance(uv, center));\n    return c;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n    float aspect = iResolution.x/iResolution.y;\n    vec2 v= fragCoord / iResolution.y;\n    float t = fract(iTime*0.06);\n    float lineYPos = t*aspect;\n    float lineWidth = 0.005;\n    float line = texture(iChannel0,uv).r/1.04;\n    \n    line += lineX(lineYPos, lineWidth, v);\n    line += lineY(lineYPos/aspect, lineWidth, v);\n    line += lineX(1.*aspect-lineYPos, lineWidth, v);\n    line += lineY(1.-lineYPos/aspect, lineWidth, v);\n    /*vec2 center = vec2(0.5,0.5);\n    float radius = 0.25*abs(cos(fract(iTime*0.06)*6.28*0.5));\n    line += circle(center,radius,uv,aspect);*/\n    float heart_size = t*10.0 + (1.0-t)*1.0;\n    float heart = smoothstep(0.005,0.00,sdHeart(p*heart_size+vec2(0.0,0.5)));\n    //line += heart;\n    fragColor = vec4(vec3(line),1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}