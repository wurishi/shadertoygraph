{"ver":"0.1","info":{"id":"DstGW7","date":"1677397155","viewed":36,"name":"Half-melted snowy lake","username":"MaGetzUb","description":"It's the time of the year; be aware of fragile ice.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float Pi = 3.141592653589;\n\n//Perform ray -> sphere trace\nvec3 RaySphere(vec3 o, vec3 d, vec4 s);\n//Perform ray -> plane trace\nvec3 RayPlane(vec3 o, vec3 d, vec4 p);\n\n//Does surface material calculations with Lambertian diffuse model and Cook-Torrence specular model.\nvec3 CalculateColor(vec3 baseColor, vec4 lightColor, float metallic, float roughness, vec3 position, vec3 normal, vec3 view, vec3 light);\n\n//Fractional Brownian motion noise function\nfloat fbm6(vec2 uv, float mul);\n\nvec3 ACES(vec3 c);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    //Ground plane\n    vec4 plane = vec4(vec3(0., 1., 0.0), 0.0);\n    \n    //This variable is being used to update light positions\n    float ang = iTime*.2;\n    \n    //These effectively do nothing, because they are modified later.\n    float metalness = 0.;\n    float roughness = 0.;\n    \n    //Moonlight direction\n    vec3 moonDir = normalize(vec3(0., 2., 3.));\n    \n    //The number of lights in the scene.\n    #define NUM_LIGHTS 6\n    \n    //Ensure even spacing of lights, by precalculating this constant\n    const float TauOverN = 2.*Pi/float(NUM_LIGHTS);\n    \n    //Light positions:\n    vec3 lights[NUM_LIGHTS] = vec3[](\n        vec3(cos(ang + 0.*TauOverN)*100.0, 10.+sin(ang*.5  + 0.*TauOverN)*9.0, sin(ang*2. + 0.*TauOverN)*100.0),\n        vec3(cos(ang + 1.*TauOverN)*100.0, 10.+sin(ang*.5  + 1.+TauOverN)*9.0, sin(ang*2. + 1.*TauOverN)*100.0),\n        vec3(cos(ang + 2.*TauOverN)*100.0, 10.+sin(ang*.5  + 2.*TauOverN)*9.0, sin(ang*2. + 2.*TauOverN)*200.0),\n        vec3(cos(ang + 3.*TauOverN)*100.0, 10.+sin(ang*.5  + 3.*TauOverN)*9.0, sin(ang*2. + 3.*TauOverN)*100.0),\n        vec3(cos(ang + 4.*TauOverN)*100.0, 10.+sin(ang*.5  + 4.*TauOverN)*9.0, sin(ang*2. + 4.*TauOverN)*100.0),\n        vec3(cos(ang + 5.*TauOverN)*100.0, 10.+sin(ang*.5  + 5.*TauOverN)*9.0, sin(ang*2. + 5.*TauOverN)*100.0)\n    );\n    \n    //Light colors:\n    vec3 lightCol[NUM_LIGHTS] = vec3[](\n        vec3(1.0,0.0,0.0),\n        vec3(0.0,1.0,0.0),\n        vec3(0.0,0.0,1.0),\n        vec3(1.0,0.0,1.0),\n        vec3(1.0,1.0,0.0),\n        vec3(0.0,1.0,1.0)\n    );\n    \n    //Rays that are shot from the virtual camera\n    vec3 rayDir = vec3(uv*tan(45.*Pi/180.), 1.);\n    vec3 rayOri = vec3(0.,1.8,0.);\n    \n    rayOri.xz += vec2(cos(ang*.1), sin(ang*.1))*100.;\n\n    //Camera yaw and pitch are dependent on mouse position\n    float yaw = iMouse.x / iResolution.x * Pi*2.;\n    float pitch = (.5-(iMouse.y / iResolution.y))  * Pi;\n    \n    float ycs = cos(yaw);\n    float yss = sin(yaw);\n    \n    float pcs = cos(pitch);\n    float pss = sin(pitch);\n    \n   \n    //Rotate the ray direction to camera direction\n    rayDir = (\n        mat3( //Yaw rotation matrix\n          ycs, 0., yss,\n           0., 1., 0., \n          yss, 0.,-ycs\n        ) * \n        mat3( //Pitch rotation matrix\n            1., 0.,   0., \n            0., pcs, pss, \n            0.,-pss, pcs\n         ) \n    ) * rayDir;\n\n    vec3 rayRight = normalize(cross(vec3(0., 1., 0.), rayDir));\n    vec3 rayUp = cross(rayRight, rayDir);\n    \n    //Normalize ray dir\n    rayDir = normalize(rayDir);\n\n    //Result color for this fragment\n    vec3 color = vec3(0.);\n  \n    color = vec3(smoothstep(0.99955, .9996, dot(rayDir, moonDir))*fbm6(rayDir.xy*100., 1.));\n    \n    //\"Depth buffer\"\n    float depth = 1e38;\n    \n    //Add in point lampsto the scene and update the \"Depth buffer\" value\n    for(int i = 0; i < NUM_LIGHTS; i++) {\n        \n        //Check if ray hit's the light bulb\n        vec3 test = RaySphere(rayOri, rayDir, vec4(lights[i], .5));\n        \n        //If test succeeds\n        if(test.x > 0.0 && test.y > 0.) {\n            //If test depth is closer than existing depth, \n            //update the color and depth\n            if(test.x < depth) {\n                color = lightCol[i]*1000.;\n                depth = test.x;\n            }\n        }\n    } \n\n    //Perform ray plane test\n    vec3 test = RayPlane(rayOri, rayDir, plane);\n    \n    if(test.x > 0.0) {\n    \n        if(test.x < depth) {\n        \n            //Result color \n            color = vec3(0.);\n            \n            //Update depth\n            depth = test.x;\n            \n            //\"Intersection point\"\n            vec3 ip = rayOri+rayDir*test.y;\n            \n            #define NUM_LAYERS 64\n            const float InvNumLayers = 1.0 / float(NUM_LAYERS);\n            //As ground is hit by ray, scan the ground texture to\n            //to sample depth\n  \n            for(int i = 0; i < NUM_LAYERS; i++) {\n                if(ip.y < (-fbm6(ip.xz, 1.))) {\n                    break;\n                } else {\n                    ip += rayDir*(ip.y+(-1.+fbm6(ip.xz, 1.)));\n                }\n            }\n           \n\n            //Initial surface normal\n            vec3 surfN = vec3(0., 1., 0.);\n            \n            //Surface to view normal\n            vec3 surfToV = normalize(rayOri - ip);\n            \n            //Sampling coordinate\n            vec2 uv = ip.xz;\n              \n            //Calculate sample weights\n            const float muls[25] = float[](\n                 1.,  1.,  2., 1., 1.,\n                 1.,  2.,  4., 2., 1.,\n                 2.,  4., 32., 4., 2.,\n                 1.,  2.,  4., 2., 1.,\n                 1.,  1.,  2., 1., 1.\n            );\n                \n            //Pat will contain final texture sample\n            float pat = 0.f;\n            \n            vec2 ddx = dFdx(uv);\n            vec2 ddy = dFdy(uv);\n   \n            //Sample ground texture and filter it\n            int n = 0;\n            float sum = 0.;\n            for(float sx =-2.; sx <= 2.0; sx+=1.)\n            for(float sy =-2.; sy <= 2.0; sy+=1.) \n            {\n                vec2 c = (uv+ddx*float(sx)+ddy*float(sy));\n                ivec2 p = ivec2(c*255.);\n                pat += fbm6(uv, 1.);\n                sum += muls[n];\n                n++;\n            }\n            \n            //Calculate ground normal\n            float l = fbm6(uv-ddx, 1.);\n            float r = fbm6(uv+ddx, 1.);\n           \n            float t = fbm6(uv-ddy, 1.);\n            float b = fbm6(uv+ddy, 1.);\n            \n            //Form the surface normal\n            surfN = normalize(vec3(r - l, 1., t - b));\n            \n            pat /= sum;\n           \n            //calculate roughness from the ground texture sample\n            roughness = smoothstep(0.2, 0.1, pat)*.9+.1;\n            \n            //Point lights\n            for(int i = 0; i < NUM_LIGHTS; i++) {\n\n                //Keep light hights on level\n                lights[i].y = 5.;\n                \n                \n                //Surface distance to light\n                vec3 surfToLightVec = lights[i] - ip;\n                \n                float d = length(surfToLightVec);\n                \n                //Surface to light normal:\n                vec3 surfToL = surfToLightVec / d;\n                \n                //Add up lamp colors\n                color += CalculateColor(vec3(smoothstep(0.2, 0.1, pat)*.6+.2), vec4(lightCol[i], test.x*1000./(d*d)), metalness, roughness, ip, surfN, surfToV, surfToL);\n            }\n            \n            //Moonlight\n            color += CalculateColor(vec3(smoothstep(0.2, 0.1, pat)*.6+.2), vec4(vec3(.8,.9,1.), 0.25), metalness, roughness, ip, surfN, surfToV, moonDir);\n        }\n\n        \n    }\n\n    //Tone map:\n    //color = (color / (color + 1.));\n    color = ACES(color);\n     \n \n    //Gamma correction:\n    color = pow(color, vec3(1./2.2));\n    \n    //Spit out the final color\n    fragColor = vec4(color, 1.);\n}\n\nfloat noise(vec2 v) {\n    const vec2 div = 1./vec2(129., 167.);\n    v *= div;\n\treturn fract(cos((v.x+v.y)*6.28)*5231.1267);\n}\n\nfloat snoise(vec2 v) {\n\tvec2 iv = floor(v);\n\tvec2 fv = fract(v);\n\n\tfv = fv * fv * (3.0 - 2.0*fv);\n\n\tfloat a = noise(iv);\n\tfloat b = noise(iv + vec2(1.0, 0.0));\n\tfloat c = noise(iv + vec2(0.0, 1.0));\n\tfloat d = noise(iv + vec2(1.0, 1.0));\n\n\treturn a + (b - a) * fv.x + (c - a) * fv.y * (1.0 - fv.x) + (d - b) * fv.x * fv.y;\n}\n\nfloat fbm6(vec2 uv, float mul) {\n    return \n        snoise(uv * mul*1.0)*0.5 +\n        snoise(uv * mul*2.0)*0.25 +\n        snoise(uv * mul*4.0)*0.125 +\n        snoise(uv * mul*8.0)*0.0625 + \n        snoise(uv * mul*16.0)*0.03125 +\n        snoise(uv * mul*32.0)*0.015625\n    ;\n}\n\n\nvec3 RayPlane(vec3 o, vec3 d, vec4 p) {\n    \n    float dp = dot(d, p.xyz);\n    float op = dot(-o, p.xyz) + p.w;\n    \n    \n    return vec3(float(dp < 0.f), op/dp, 0.f);\n    \n}\n\nvec3 RaySphere(vec3 o, vec3 d, vec4 s) {\n\n    vec3 raySphere = s.xyz - o;\n\n    float a = 1.0 / dot(d, d);\n    float b = dot(raySphere, d)*a;\n    float c = (dot(raySphere, raySphere) - s.w*s.w) * a;\n    float D = b*b-c;\n\n    float f = sqrt(D);\n    float front = b - f;\n    float back = b + f;\n\n    return vec3(float(D>=0.), front, back);\n}\n\n\nvec3 F(vec3 f0, vec3 view, vec3 halfVec) {\n    \n    float x = (1.0 - max(dot(view, halfVec), 0.0));\n    float x2 = x*x;\n    float x4 = x2*x2;\n    \n    return f0 + (vec3(1.0) - f0) * (x4*x);\n    \n}\n\n\nfloat D(float alpha, vec3 normal, vec3 halfVec) {\n    \n    float numerator = alpha*alpha;\n    \n    float normalDotHalf = max(dot(normal, halfVec), 0.0);\n    \n    float denominator = normalDotHalf*normalDotHalf * ((alpha*alpha)-1.0) + 1.0;\n    \n    denominator = 1.0 / max(Pi * denominator * denominator, 1e-6);\n    \n    return numerator * denominator; \n    \n}\n\nfloat G1(float alpha, vec3 normal, vec3 x) {\n    \n    float numerator = max(dot(normal, x), 0.);\n    \n    float k = alpha*.5;\n    float denominator = numerator * (1.0 - k) + k;\n    denominator = 1.0 / max(denominator, 1e-6);\n    \n    return numerator * denominator;\n    \n}\n\nfloat G(float alpha, vec3 normal, vec3 view, vec3 light) {\n    return G1(alpha, normal, view) * G1(alpha, normal, light);\n}\n\nvec3 CalculateColor(vec3 baseColor, vec4 lightColor, float metallic, float roughness, vec3 position, vec3 normal, vec3 view, vec3 light) {\n    \n   \n    vec3 halfVec = normalize(view + light);\n   \n    const vec3 F0 = vec3(0.1);\n   \n    vec3 Ks = F(F0, view, halfVec);\n    vec3 Kd = (1.0 - Ks) * (1.0 - metallic);\n     \n    vec3 lambert = baseColor / Pi;\n     \n    float alpha = roughness*roughness;\n    \n    float cookTorranceNumerator = D(alpha, normal, halfVec) * G(alpha, normal, view, light);\n    \n    float cookTorranceDenominator = 4.0 * (max(dot(view, normal), 0.5) * max(dot(light, normal), 0.5));\n    cookTorranceDenominator = 1./max(cookTorranceDenominator, 1e-6);\n    \n    float cookTorrance = cookTorranceNumerator * cookTorranceDenominator;\n    \n    vec3 BRDF = Kd * lambert + baseColor*cookTorrance;\n    //vec3 BRDF = OrenNayar(baseColor, alpha, normal, view, light, halfVec) + baseColor*cookTorrance;\n    vec3 result = BRDF * lightColor.rgb * max(dot(light, normal), 0.) * max(lightColor.w, 0.0);\n     \n    return result;\n}\n\nvec3 ACES(vec3 x)\n{\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0., 1.);\n}\n","name":"Image","description":"","type":"image"}]}