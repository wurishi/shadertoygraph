{"ver":"0.1","info":{"id":"4sKSzR","date":"1462481020","viewed":5331,"name":"Muddy Cavern","username":"zackpudil","description":"A muddy tunnel.  Using Shane's distance formula for a tunnel, and adding noise to it. Just bored in a meeting.","likes":46,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","attenuation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float hash(float n) {\n\treturn fract(sin(n)*43578.4545);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\t\n\tf = f*f*(3.0 - 2.0*f);\n\t\n\tfloat n = p.x + p.y*57.0 + p.z*113.0;\n\t\n\treturn mix(\n\t\tmix(\n\t\t\tmix(hash(n + 000.0), hash(n + 001.0), f.x),\n\t\t\tmix(hash(n + 057.0), hash(n + 058.0), f.x),\n\t\t\tf.y),\n\t\tmix(\n\t\t\tmix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\tmix(hash(n + 170.0), hash(n + 171.0), f.x),\n\t\t\tf.y),\n\t\tf.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\t\n\tf += 0.500*noise(p); p *= 2.01;\n\tf += 0.250*noise(p); p *= 2.04;\n\tf += 0.125*noise(p);\n\t\n\tf /= 0.875;\n\treturn f;\n}\n\nvec2 path(float z) {\n\treturn vec2(sin(0.5*z), 2.0*cos(0.12*z));\n}\n\nvec3 camPath() {\n\tvec3 ro = vec3(0, 0, 2.0*iTime);\n\tro.xy = path(ro.z);\n\t\n\treturn ro;\n}\n\nvec3 lookat(vec3 ro) {\n\tvec3 la = ro + vec3(0, 0, 1);\n\tla.xy = path(la.z);\n\t\n\treturn la;\n}\n\nvec3 lightPath(vec3 la) {\n\tvec3 lp = la;\n\tlp.xy += 0.2*vec2(sin(iTime), cos(iTime));\n\t\n\t\n\treturn lp;\n}\n\nfloat map(vec3 p) {\n\tfloat r = 0.6*smoothstep(0.3, 1.0, noise(1.5*p));\n\tfloat f = 0.1*smoothstep(0.0, 1.0, fbm(6.0*p + 3.0*vec3(0, iTime, 0)));\n\t\n\tfloat l = length(p - lightPath(lookat(camPath()))) - 0.01;\n\tvec2 tun = abs(p.xy - path(p.z))*vec2(.6, 3);\n\tfloat t = 1.0 - max(tun.x, tun.y);\n\treturn min(l, t - (r + f));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\tfloat t = 0.0;\n\t\n\tfor(int i = 0; i < 150; i++) {\n\t\tfloat h = map(ro + rd*t);\n\t\tif(abs(h) < 0.0001 || t >= 30.0) break;\n\t\tt += h*0.5;\n\t}\n\t\n\treturn t;\n}\n\nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.01, 0.0);\n\t\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy) - map(p - h.xyy),\n\t\tmap(p + h.yxy) - map(p - h.yxy),\n\t\tmap(p + h.yyx) - map(p - h.yyx)\n\t);\n\t\n\treturn normalize(n);\n}\n\n\nmat3 camera(vec3 e, vec3 l) {\n\tvec3 f = normalize(l - e);\n\tvec3 r = normalize(cross(vec3(0, 1, 0), f));\n\tvec3 u = normalize(cross(f, r));\n\t\n\treturn mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*(fragCoord.xy/iResolution.xy))*vec2(iResolution.x/iResolution.y, 1.0);\n\t\n\tvec3 ro = camPath();\n\t\n\tvec3 la = lookat(ro);\n\t\n\tvec3 rd = camera(ro, la)*normalize(vec3(uv, 1.97));\n\t\n\tvec3 col = vec3(0);\n\t\n\tfloat i = march(ro, rd);\n\t\n\tif(i < 30.0) {\n\t\tvec3 pos = ro + rd*i;\n\t\tvec3 nor = normal(pos);\n\t\t\n\t\tvec3 rig = lightPath(la);\n\t\tvec3 lig = normalize(rig - pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat dis = max(length(pos - rig), 0.001);\n\t\tif(dis <= 0.015) {\n\t\t\tcol = vec3(1);\n\t\t} else {\n\t\t\tfloat att = 1.0/(1.0 + 1.5*dis + 2.0*dis*dis);\n\t\t\t\n\t\t\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\t\t\tfloat spe = pow(clamp(dot(lig, ref), 0.0, 1.0), 32.0);\n\t\t\t\n\t\t\tcol =  0.7*dif*vec3(1);\n\t\t\tcol *= vec3(0.8, 0.6, 0.2);\n\t\t\tcol += spe*vec3(1)*dif;\n\t\t\t\n\t\t\tcol *= att;\n\t\t}\n\t}\n\t\n\tcol = pow(col, vec3(.4545));\n\t\n\tfragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}