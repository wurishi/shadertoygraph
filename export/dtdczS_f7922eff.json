{"ver":"0.1","info":{"id":"dtdczS","date":"1699384239","viewed":55,"name":"Fork Vinyl Visu borzsonyir 568","username":"borzsonyir","description":"inspired by the logo of [url=https://www.facebook.com/hostelCulturePub]a bar[/url]\n\nmusic by [url=https://www.youtube.com/channel/UC_hXu1_lUOqWZUzk2Ps2Y1w]Fleece[/url]","likes":7,"published":1,"flags":64,"usePreview":0,"tags":["2d","visualizer","minimal","hostel","vinyl"],"hasliked":0,"parentid":"XlcXDX","parentname":"Vinyl Visualizer"},"renderpass":[{"inputs":[{"id":"4s23DD","filepath":"https://soundcloud.com/fleecemusic/rise","previewfilepath":"https://soundcloud.com/fleecemusic/rise","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define BARS 10. //a mozgó csíkok számát definiáljuk\n\n#define PI 3.14159265359\n\n// rotation transform\nvoid tRotate(inout vec2 p, float angle) { // a p pont 2D forgatása adott szöggel\n    float s = sin(angle), c = cos(angle);\n\tp *= mat2(c, -s, s, c);\n}\n\n// circle distance\nfloat sdCircle(vec2 p, float r) { //p távolsága egy kör közepétől\n    return length(p) - r;\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// distance function of half of an ark\n// parameters: inner radius, outer radius, angle\nfloat sdArk(vec2 p, float ir, float or, float a) {\n    \n    // add outer circle\n    float d = sdCircle(p, or);\n        \n    // substract inner circle\n    d = opS(d, sdCircle(p, ir));\n    \n    // rotate with angle\n    tRotate(p, -a * PI / 2.);\n    \n    // clip the top\n    d = opS(d, -p.y);\n    \n    // add circle to the top\n    d = opU(d, sdCircle(p - vec2((or + ir) / 2., 0.), (or - ir) / 2.));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \n    // I wanted it to look good on my phone vertically :P\n    if (iResolution.x > iResolution.y) uv.x *= iResolution.x / iResolution.y; else uv.y *= iResolution.y / iResolution.x;\n    \n    // little white padding\n    uv *= 1.05; //kép szélétől vett távolság\n    \n    // add circles\n    float d = sdCircle(uv, 1.); //fekete kör mérete\n    d = opS(d, sdCircle(uv, .34 * sin(iTime * 2.))); //belső fehér kör, változik a méret\n    d = opU(d, sdCircle(uv, .07 * cos(iTime * 2.))); // legbelső pici fekete kör, változik a méret\n    \n    // calculate position of the bars\n    float barsStart = .37;//hol kezdődnek a vonalak\n    float barsEnd = .94; //meddig tartanak a vonalak\n    float barId = floor((length(uv) -barsStart) / (barsEnd - barsStart) * BARS);\n    \n    // only go forward if we're in a bar\n    if (barId >= 0. && barId < BARS) {//végig a vonalakon\n        \n        float barWidth = (barsEnd - barsStart) / BARS;\n        float barStart = barsStart + barWidth * (barId + .25);\n        float barAngel = texture(iChannel0, vec2(1. - barId / BARS, .25)).x * .7;\n        // add a little rotation to completely ruin the beautiful symmetry\n        tRotate(uv, -barAngel * .2 * (barId + iTime)); //hardcore verzió, szinusz nélkül, megfejelve egy zárójellel\n        //tRotate(uv, -barAngel * .2 * barId + iTime); //nyugisabb alternatíva\n        \n        // mirror everything\n    \tuv = abs(uv);\n        \n        // add the bars\n        d = opS(d, sdArk(uv, barStart, barStart + barWidth / 2., barAngel));\n    }\n    \n    // use the slope to render the distance with antialiasing\n    float w = min(fwidth(d), .01);\n\tfragColor = vec4(vec3(smoothstep(-w, w, d)),1.0);\n}","name":"Image","description":"","type":"image"}]}