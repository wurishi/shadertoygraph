{"ver":"0.1","info":{"id":"mlt3Ds","date":"1683433897","viewed":253,"name":"Conduit (Path tracing&Fractal)","username":"sjz1","description":"A fractal Minecraft conduit","likes":6,"published":1,"flags":32,"usePreview":1,"tags":["3d","fractal","reflection","sdf","4k","bloom","pathtracing","intersect","ggx","reality"],"hasliked":0,"parentid":"dltGDs","parentname":"Path Tracing v3 (Bloom)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float gamma=2.2;\n\n\nvec3 ACESFilm( vec3 x )\n{\n    float tA = 2.51;\n    float tB = 0.03;\n    float tC = 2.43;\n    float tD = 0.59;\n    float tE = 0.14;\n    return clamp((x*(tA*x+tB))/(x*(tC*x+tD)+tE),0.0,1.0);\n}\n\nvec2 uv00;\nvec4 Load(){\n    return texture(iChannel0,uv00);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv00=uv;\n    vec3 tc=Load().xyz;\n    tc=ACESFilm(tc);tc=pow(tc,vec3(1./gamma));\n    fragColor=vec4(tc,1);\n   \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI=3.1415926535;\nstruct object{\n    float d;float d2;int id;int i_id;int s;\n};\nstruct material{\n    vec3 Cs;vec3 Cd;vec2 S;vec4 R;vec3 light;\n};\n\nivec2 lp;\nvoid F(float x,float y);\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 = fract(tan(dot(p3,p3)*20.*atan(p3))) ;\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 = fract(tan(dot(p3,p3)*20.*atan(p3))) ;\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 = fract(tan(dot(p4,p4)*20.*atan(p4))) ;\n\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n\n\n\nfloat luma(vec3 c){\n    return dot(c,vec3(0.299,0.587,0.114));\n}\nvec4 rColor(vec3 c,float cosA){\n    cosA=abs(cosA);\n    vec3 A0=1.-sqrt(c);vec3 A1=1.+sqrt(c);\n    vec3 B=sqrt(4.*sqrt(c)+cosA*cosA*pow(A0,vec3(2)));\n    vec3 s0=(cosA*A0-B)/max(cosA*A0+B,1e-5);\n    vec3 s1=(B*A0-cosA*A1*A1)/max(B*A0+cosA*A1*A1,1e-5);\n    vec3 R=0.5*(s0*s0+s1*s1);\n    return vec4(R,luma(R));\n}\nfloat mixp(float F,float S){\n    return F*S/max(1.+(S-1.)*F,1e-5);\n}\nfloat fresnel(vec3 v,vec3 n,float rs){\n    float cosa=dot(v,n);\n    float cosb=sqrt(max(1.-(1.-cosa*cosa)/(rs*rs),0.));\n    return 0.5*(pow((cosa-rs*cosb)/max(cosa+rs*cosb,1e-4),2.)+pow((cosb-rs*cosa)/max(cosb+rs*cosa,1e-4),2.));\n}\n\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb2hsv(vec3 c){\n\n    const vec4 k=vec4(0.0,-1.0/3.0,2.0/3.0,-1.0);\n    vec4 p=mix(vec4(c.bg,k.wz),vec4(c.gb,k.xy),step(c.b,c.g));\n    vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));\n    float d=q.x-min(q.w,q.y);\n    return vec3(abs(q.z+(q.w-q.y)/(6.*d+0.001)),d/(q.x+0.001),q.x);\n\n}\nvec2 rot(vec2 a,float theata){\n    return a.xx*vec2(cos(theata),sin(theata))+a.yy*vec2(-sin(theata),cos(theata));\n}\nvec3 rot(vec3 a,vec3 range){\n    a.yz=rot(a.yz,range.x);\n    a.xz=rot(a.xz,range.y);\n    a.xy=rot(a.xy,range.z);\n    return a;\n}\nfloat mix2(float A,float B,float x){\n    return (B-A)*x+A;\n}\nfloat mix2(int A,float B,float x){\n    return (B-float(A))*x+float(A);\n}\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\nfloat sdBox(vec3 p,vec3 a);\n\nobject newObj(float d,float d2,int id,int i_id,int s){\n    object o;o.d=d;o.d2=d2;o.id=id;o.i_id=i_id;o.s=s;\n    return o;\n}\nobject near(object A,vec3 B){\n    object c;\n    c.d2=A.d>abs(B.y)?B.y:A.d2;\n    float tmp=mix2(A.i_id,B.z,float(B.y<0.));\n    c.s=A.s+int(B.y<0.);\n    B.y=abs(B.y);\n    c.id=int(mix2(A.id,B.x,float(A.d>B.y)));\n    c.d=min(A.d,B.y);\n    c.i_id=int(tmp);\n    return c;\n}\n\n\nvec2 rotClamp(vec2 pos,int n){\n    float alpha=-atan(pos.x,pos.y);\n    float tmp=PI/float(n);\n    return abs(rot(pos,-alpha+mod(alpha,2.*tmp)-tmp));\n}\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdSphere(vec3 p,float r){\n    return length(p)-r;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p=abs(p)-b;\n  vec3 q=abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat dSphere(vec3 p,vec3 rd,float r){\n    float d0=sdSphere(p,r);\n    float b=dot(p,rd);\n    float c=dot(p,p)-r*r;\n    float h=b*b-c;\n    h = h>=0.?sqrt( h ):1e20;\n    float d1=abs(-b-sign(d0)*h);\n    d1-=1e-5;\n    d1=max(d1,0.);\n    d1*=sign(d0);\n    return rd==vec3(0)?d0:d1;\n}\nfloat dPlane(vec3 p,vec3 rd,vec4 n){\n    float d0=dot(n,vec4(p,1))/length(n.xyz);\n    float d1=-abs(d0)/dot(rd,normalize(n.xyz));\n    d1=d1>=0.?d1:1e20;\n    d1-=1e-5;\n    d1*=sign(d0);\n    return rd==vec3(0)?d0:d1;\n}\nfloat dBox(vec3 ro,vec3 rd,vec3 boxSize){\n    float d0=sdBox(ro,boxSize);    \n    vec3 m = 1.0/rd; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*ro;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    float d1=d0>=0.?tN:tF;//vec2( tN, tF );\n    d1=tN>tF || tF<0.0?1e20:d1;\n    d1-=1e-5;\n    d1*=sign(d0);\n    return rd==vec3(0)?d0:d1;\n}\nfloat hash( float n )\n{\n    return fract( n*17.5*fract( n*0.3183099 ) );\n}\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\n\n\nvec4 fbm3D( in vec3 x ,int n)\n{\n    const float scale  = 1.5;\n\n    float a = 0.0;\n    float b = 0.5;\n\tfloat f = 1.0;\n    vec3  d = vec3(0.0);\n    for( int i=0; i<n; i++ )\n    {\n        vec4 n = noised(f*x*scale);\n        a += b*n.x;           // accumulate values\t\t\n        d += b*n.yzw*f*scale; // accumulate derivatives\n        b *= 0.5;             // amplitude decrease\n        f *= 1.8;             // frequency increase\n    }\n\n\treturn vec4( a, d );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//#define SphereProjection\n#define FixCaustics\nconst float EPSILONS = 0.0001;\nconst float EPSILONS_MIN = 0.001;\nconst int MaxReflect=5;//change it if your computer is too slow\nconst int MaxRayStep=200;\nconst float Far=500.0;\nconst float FogS=0.125;\nconst float FogStart=400.0;\nconst float AA=16.;\nconst float ShadowOffset=0.;\nconst vec2 DOF_Pos=vec2(0);\nconst float DOF_R=0.05;\nconst float FOV=0.5;\nconst float Marching_S=1.;\nconst float cut=16.;//change it if your computer is too slow\nconst int Type_Smoke=1;\nconst vec3 lightDir=normalize(vec3(0.5,-0.15,-0.5));//Sun light direction\n#define EnableObjectLight\n//#define EnableVoxel\n\n#ifdef EnableObjectLight\nvec4 centers[1]=vec4[1](vec4(0,0,0,1));\nint ids[1]=int[1](2);\n#endif\n\nvec3 Position_00;\n\nvec3 colors[MaxReflect];\nvec3 LightColors[MaxReflect];\nvec3 fog0[MaxReflect+1];\nvec3 ro0s[MaxReflect];\nvec3 rd0s[MaxReflect+1];\nvec3 rd1s[MaxReflect+1];\nvec4 rdinfo[MaxReflect+1];\nfloat distance0s[MaxReflect+1];\nfloat roughness0[MaxReflect];\nvec3 directLight0[MaxReflect];\nvec3 n0s[MaxReflect+1];\nvec3 n1s[MaxReflect+1];\nvec3 fog1_p[MaxReflect+1];\nvec3 fog1_n[MaxReflect+1];\nfloat fog1_s[MaxReflect+1];\n\nfloat iFrame_;\nobject hit;\nvec3 pos_0;\n\n\n\n\nbool enablewater=true;\nvec4 ObjectLight(vec3 ro,vec3 rd,vec3 n,vec3 center,float R,int id);\nvec3 VoxelMap(vec3 pos);\nobject Voxel(object hit,vec3 p,vec3 rd);\nfloat Smoke(vec3 p,vec3 rd,float density);\n\nvec3 VoxelMap(vec3 pos){\n    //inside voxel,voxel id,voxel inside material id\n    return vec3(float(false),0,0);\n}\nvec4 orbitTrap=vec4(1,1,1,1);\n\nconst bool CycleColors=false;\nconst float Cycles=1.5;\n\nconst vec3 BaseColor=vec3(0.75098,0.75098,0.75098);\n// Determines the mix between pure light coloring and pure orbit trap coloring\nconst float OrbitStrength=0.8;\n\n// Closest distance to YZ-plane during orbit\nconst vec4 X=vec4(0.,0.6,1,0.3885);\n\n// Closest distance to XZ-plane during orbit\nconst vec4 Y=vec4(0.1,0.3,1,0.3168);\n\n// Closest distance to XY-plane during orbit\nconst vec4 Z=vec4(0.1,0.3,1,0.6141);\n\n// Closest distance to  origin during orbit\nconst vec4 R=vec4(102./255.,1,1,0.05);\n\nvec3 cycle(vec3 c, float s) {\n\treturn vec3(0.5)+0.5*vec3(cos(s*Cycles+c.x),cos(s*Cycles+c.y),cos(s*Cycles+c.z));\n}\n\n\nvec3 getColor() {\n   \n\torbitTrap.w = sqrt(orbitTrap.w);\n\n\tvec3 orbitColor;\n\tif (CycleColors) {\n\t\torbitColor = cycle(X.xyz,orbitTrap.x)*X.w*orbitTrap.x +\n\t\tcycle(Y.xyz,orbitTrap.y)*Y.w*orbitTrap.y +\n\t\tcycle(Z.xyz,orbitTrap.z)*Z.w*orbitTrap.z +\n\t\tcycle(R.xyz,orbitTrap.w)*R.w*orbitTrap.w;\n\t} else {\n\t\torbitColor = X.xyz*X.w*orbitTrap.x +\n\t\tY.xyz*Y.w*orbitTrap.y +\n\t\tZ.xyz*Z.w*orbitTrap.z +\n\t\tR.xyz*R.w*orbitTrap.w;\n\t}\n\tvec3 color = mix(BaseColor, 3.0*orbitColor,  OrbitStrength);\n\treturn clamp(color,0.,1.);\n}\nconst float Scale=2.;\n\n// Scaling center\nconst vec3 Offset=vec3(2.5);\nconst vec3 Scale2=vec3(1.23);\n\nconst float fixedRadius2=0.5;\nconst float minRadius2=0.1;\n\n\nvoid sphereFold(inout vec3 z, inout mat3 dz) {\n\tfloat r2 = dot(z,z);\n\tif (r2< minRadius2) {\n\t\tfloat temp = (fixedRadius2/minRadius2);\n\t\tz*= temp; dz*=temp;\n\t} else if (r2<fixedRadius2) {\n\t\tfloat temp =(fixedRadius2/r2);\n\t\tz*=temp; dz*=temp;\n\t}\n}\n\n\n\nconst float foldingLimit=0.5;\nvoid boxFold(inout vec3 z, inout mat3 dz) {\n\tvec3 a = (1.0-2.0*step(vec3(foldingLimit),abs(z)));\n\tdz[0]*=a; dz[1]*=a; dz[2]*=a;\n\tz = clamp(z, -foldingLimit, foldingLimit) * 2.0 - z;\n}\nconst int Iterations=10;\nconst int ColorIterations=2;\n\nconst float Power=2.;\nvoid powN2(inout vec3 z, inout mat3 dz) {\n\tvec3 s=sign(z);\n\tvec3 z0=z;\n\tz=pow(abs(z0),vec3(Power));\n\tvec3 dz0=s*pow(abs(z0),vec3(Power-1.))*Power;\n\tdz[0][0]*=dz0.x;\n\tdz[1][1]*=dz0.y;\n\tdz[2][2]*=dz0.z;\n\t\n}\nfloat DE0(vec3 z)\n{\n   z=vec3(-1,-1,-1)*abs(z);\n   if(length(z)>9.) return sdSphere(z,8.);\n\tmat3 dz = mat3(1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0);\n\torbitTrap=vec4(1);\n\tvec3 c = z;\n\tmat3 dc = dz;\n   powN2(c,dc);\n\tdz=dc;\n\tfor (int n = 0; n < Iterations; n++) {\n\t\tboxFold(z,dz);\n\t\tsphereFold(z,dz);\n\t\tz*=(Scale*Scale2);\n\t\tdz=mat3(dz[0]*Scale*Scale2,dz[1]*Scale*Scale2,dz[2]*Scale*Scale2);\n\t\tz += c*Offset;\n\t\tdz += dc*mat3(Offset,Offset,Offset);\n\t\tif (length(z)>1000.0) break;\n\t\tif (n<ColorIterations) orbitTrap = min(orbitTrap, (vec4(abs(z),dot(z,z))));\n\t}\n\treturn dot(z,z)/length(z*dz)*0.9;\n}\nobject DE(vec3 pos,vec3 rd) {\n    object hit0=newObj(Far,Far,-1,-1,0);\n    vec3 pos0=pos;\n\n    hit0=near(hit0,vec3(1,dPlane(pos,rd,vec4(0,1.0,0,1)),2));\n    hit0=near(hit0,vec3(3,dSphere(pos,rd,0.7),1));\n    hit0=near(hit0,vec3(2,DE0(pos),1));\n\n    return hit0;\n}\nmaterial newMaterial(vec3 Cs,vec3 Cd,vec2 S,vec4 R,vec3 light){\n    material a;a.Cs=Cs;a.Cd=Cd;a.S=S;a.R=R;a.light=light;return a;\n}\nmaterial Material(vec3 pos,vec3 nor,object o){\n    if(o.id==2) return newMaterial(vec3(0.01),getColor(),vec2(0,0),vec4(0,1,2,1.9),vec3(0));\n    if(o.id==1) return newMaterial(vec3(0.025),texture(iChannel1,pos.xz*0.3).rgb,vec2(1,0),vec4(0,1,2,1.9),vec3(0));\n    if(o.id==3) return newMaterial(vec3(0.1),vec3(1,0.5,0.3),vec2(0,0),vec4(0,1,2,1.9),vec3(5,10,30));\n\n    return newMaterial(vec3(0.1),vec3(0.9,0.9,0.9),vec2(1,0),vec4(0,1,2,1),vec3(0));\n}\n\nvec4 InsideMaterial(vec3 pos,object o){\n    if(o.i_id==1) return vec4(1.331,0,0,0);\n    if(o.i_id==2) return vec4(1.331,0,0,0);\n\n    return vec4(1,vec3(0));\n}\nvec4 InsideFog(vec3 pos,object o){\n    if(o.i_id==1) return vec4(1.331,0,0,0);\n    if(o.i_id==2) return vec4(1.331,0.01,0.01,0.01);\n\n    return vec4(0);\n}\n\nfloat Smoke(vec3 pos,vec3 rd,float density){\n    float s=0.01+hash13(pos+float(iFrame)+rd)*0.99;\n    float d=-log(s)/density;\n    return d;\n}\nobject Voxel(object hit0,vec3 pos,vec3 rd){    \n    object hit1=hit0;\n    if(dot(rd,rd)<0.5){\n        hit1=near(hit1,vec3(1,-sdBox(fract(pos)-0.5,vec3(0.5)),1));\n    }else{\n\n        vec3 lpos=fract(pos);\n        vec3 rd0=max(abs(rd),1e-5)*sign(rd);\n        vec3 A=min(max(-lpos/rd0,(1.-lpos)/rd0),1e5);\n        float d=min(A.x,min(A.y,A.z));\n        const float E=0.0025;\n        vec3 map=VoxelMap(floor(pos+(d+E)*rd));\n        d+=E*(map.x>0.?-1.:1.);\n        d=max(0.,d);\n        hit1=near(hit0,vec3(map.y,d,map.z));\n    }\n    return hit1;\n}\nfloat rand_i=0.;\nfloat rand(vec3 p3)\n{\n    rand_i += 0.4;\n    p3=rot(p3,vec3(rand_i));\n    p3 += rand_i+float(iFrame);\n    p3  = fract(p3 * .1031);\n    //p3 = fract(tan(dot(p3,p3)*20*atan(p3))) ;\n\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec4 getObjectLight(vec3 ro,vec3 rd,vec3 n){\n#ifdef EnableObjectLight\n    vec4 color=vec4(0);\n    int id=int(clamp(floor(rand(ro+float(iFrame))*float(ids.length())),0.,float(ids.length())));\n    color+=ObjectLight(ro,rd,n,centers[id].xyz,centers[id].w,ids[id]);\n    color.w*=float(ids.length());\n    return max(color,0.);\n#else\n    return vec4(0);\n#endif\n}\n\nconst vec3 b_P=vec3(30000);//atmosphere thickness\nconst float b_k=0.25;//mix\n\n \nconst vec3 Mie=vec3(0.2);\n\nconst vec3 Rayleigh=5e10*pow(vec3(1./700.,1./520.,1./450.),vec3(4));\n  \nconst vec3 b_k0=mix(Rayleigh,Mie,b_k);\n\nconst vec3 b_Q=b_k0/(b_P*b_P);//absorption\nconst vec3 b_Sun=0.8*vec3(10,10,10);//sun color\nconst vec3 b_g0=mix(Rayleigh*0.01,vec3(0.9),b_k);//single scatter\nvec4 background(in vec3 pos, in vec3 n,in vec3 lightDir ) {\n    vec3 n0=n;\n\n    n.y=max(n.y,1e-5);\n    vec3 g=3./(8.*PI)*(1.+pow(dot(n,lightDir),2.))*(1.-b_g0*b_g0)/(2.+b_g0*b_g0)/pow(1.+b_g0*b_g0-2.*b_g0*dot(lightDir,n),vec3(1.5));\n    vec3 t=b_Q*0.5*(b_P-pos.y)*(b_P-pos.y);\n    vec3 c=b_Sun*g*(exp(-t/n.y)-exp(-t/lightDir.y))/(n.y-lightDir.y)*max(lightDir.y,0.);\n\n    c+=exp(-t/n.y)*b_Sun*smoothstep(0.997,0.9975,dot(n0,lightDir));\n\t return vec4(clamp(c,0.,50.),1);\n}\nvec4 background(in vec3 pos, in vec3 n,in vec3 lightDir,float s,vec3 col ) {\n    vec3 n0=n;\n    if(n.y>0.) s=min((b_P.x-pos.y)/n.y,s);\n    vec3 g=3./(8.*PI)*(1.+pow(dot(n,lightDir),2.))*(1.-b_g0*b_g0)/(2.+b_g0*b_g0)/pow(1.+b_g0*b_g0-2.*b_g0*dot(lightDir,n),vec3(1.5));\n    vec3 t=b_Q*0.5*(b_P-pos.y)*(b_P-pos.y);\n    vec3 s1=exp(b_Q*s*(0.5*s*n.y-(b_P-pos.y))*(1.-n.y/lightDir.y));\n    vec3 c=b_Sun*g*exp(-t/lightDir.y)*(1.-s1)/(-n.y+lightDir.y)*max(lightDir.y,0.);\n    c=abs(c);\n    c=clamp(c,0.,50.);\n    c+=exp(b_Q*0.5*n.y*s*s-b_Q*(b_P-pos.y)*s)*col;\n\t return vec4(c,1);\n}\n\nfloat rand3(vec3 p3)\n{\n    rand_i += 0.4;\n    p3 += rand_i+float(iFrame_);\n    p3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat rand(vec2 p)\n{\n    rand_i += 0.4;\n    p += rand_i+float(iFrame_);\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 = fract(tan(dot(p3,p3)*20.*atan(p3))) ;\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rndS(vec3 pos){\n    return normalize(tan(vec3(rand(pos)-0.5,rand(pos)-0.5,rand(pos)-0.5)))*rand(pos);\n}\nvec3 estimateNormal(vec3 pos) {\n    float EPSILON=EPSILONS*distance(pos,pos_0);\n    vec2 e = vec2(1.0,-1.0)*0.5773*EPSILON;\n    vec3 rd=vec3(0,0,0);\n    return normalize( e.xyy*DE( pos + e.xyy ,rd).d2 + \n\t\t\t\t\t  e.yyx*DE( pos + e.yyx ,rd).d2 + \n\t\t\t\t\t  e.yxy*DE( pos + e.yxy ,rd).d2 + \n\t\t\t\t\t  e.xxx*DE( pos + e.xxx ,rd).d2 );\n}\n\n\nvec3 raycast(vec3 ro,vec3 rd,out float distance_,float alpha,out bool ifSmoke){\n    float lastd0=0.;\n    bool hit00=false;\n    vec3 ro0=ro;\n    vec3 rd0=rd;\n    bool a=false;\n    ifSmoke=false;\n    float t=0.;\n    float Marching_S_2=1.;\n    int sgn =DE(ro,rd).s;\n    for(int i=0;i<MaxRayStep;i++){\n        object o=DE(ro,rd);\n        if(o.s!=sgn){\n            ro=ro0;rd=rd0;\n            Marching_S_2*=0.75;\n            continue;\n        }\n        ro0=ro;rd0=rd;\n        float d0=o.d;\n        float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n        bool b=a&&int(InsideMaterial(ro,o).y)==Type_Smoke;\n        bool c=d0<=EPSILON&&d0<lastd0||Marching_S_2<=EPSILONS_MIN||b;\n        if(c||distance(ro,Position_00)>Far){\n            ifSmoke=b;hit00=c; break;\n        }\n        a=true;\n        if(distance(ro,Position_00)>Far) break;\n        float d_d=d0*Marching_S*Marching_S_2;\n        float rnd_d=sqrt(-log(rand(ro))/max(alpha,1e-10));\n        float no_rnd=float(rnd_d>d_d||alpha==0.);\n        rd=mix(rndS(ro),rd,no_rnd);\n        d_d=no_rnd==0.?rnd_d:d_d;\n        lastd0=d0;ro+=d_d*rd;t+=d_d;\n\n    }\n    distance_=mix2(-1.,t,float(hit00));\n    return ro;\n}\n\n/*\nThis distribution was inspired by GGX function\n\nI replaced the denominator of the GGX distribution with a general quadratic function,then I got it\n\nThis distribution can be written in anisotropic form\n\nReplace the roughness parameter \"a\" if you want the anisotropic distribution\n*/\n\nfloat HGGX_Lamda(float VoN,float a,vec2 g){\n    float tan2=1./(VoN*VoN)-1.;\n    vec2 A=sqrt(1.+g*a*a*tan2);\n    return (log((1.+A.y)/(1.+A.x))-A.y+A.x)/log(g.x/g.y);\n}\n\nfloat HGGX_G2(float VoN,float LoN,float a,vec2 g){\n    float L1=HGGX_Lamda(VoN,a,g);float L2=HGGX_Lamda(LoN,a,g);\n    return clamp((1.+L1)/(1.+L2+L1),0.,1.);\n}\nvec3 HGGXNormal(vec3 normal,float roughness,vec2 g,vec3 pos){\n    vec3 randN0;randN0.y=-length(normal.xz);\n    if(length(normal.xz)<=0.)\n        randN0.xz=vec2(1,0);\n    else\n        randN0.xz=normalize(normal.xz)*normal.y;\n    vec3 randN1=cross(normal,randN0);\n    float alpha=rand(pos)*2.*PI;\n    float tmp=rand(pos);\n    vec2 A=pow(g,vec2(tmp-1.));\n    float beta=roughness*atan(dot(A,vec2(-g.x,g.y))/(A.x-A.y));\n    \n    return (cos(beta))*normal+sin(beta)*(cos(alpha)*randN0+sin(alpha)*randN1);\n}\nfloat HGGXdf(float theta,float fai,float a,vec2 g){\n    float a2=a*a;\n    float cos2=cos(theta);cos2*=cos2;\n    vec2 A=1.+(g*a2-1.)*cos2;\n    return 1.-log(A.x/A.y)/log(g.x/g.y);\n}\nfloat HGGXpdf(float theta,float fai,float a,vec2 g){\n    float a2=a*a;\n    float cos2=cos(theta);cos2*=cos2;\n    vec2 A=1.+(g*a2-1.)*cos2;\n    return a2*(g.x-g.y)*cos(theta)/(log(g.x/g.y)*PI*A.x*A.y);\n}\n\n\n\n//sample direct light\nvec4 ObjectLight(vec3 ro,vec3 rd,vec3 n,vec3 center,float sR,int id){\n    object thit=hit;\n    float d=distance(ro,center);\n    vec3 tnor;\n    float cosD_S;\n\n    if(d<=sR){\n        cosD_S=-1.;\n        tnor=reflect(rd,n);\n    }else{\n        float RDivd=sR/d;\n        cosD_S=1./sqrt(1.+RDivd*RDivd);\n        tnor=normalize(center-ro);\n    }\n    \n\n    float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n    object oA=DE(ro,vec3(0));\n    object oB=DE(ro-n*EPSILON*2.,vec3(0));\n    vec4 MaterialA=InsideMaterial(ro,oA);vec4 MaterialB=InsideMaterial(ro-n*EPSILON*2.,oB);\n    float rs=MaterialB.x/MaterialA.x;\n    material mt=Material(ro,n,oA);\n    \n    \n    vec3 randN=HGGXNormal(n,mt.R.x,mt.R.zw,ro);\n    float k=fresnel(-n,randN,rs);\n    vec4 rC=rColor(mt.Cs,max(dot(-rd,randN),0.));\n    float p=mixp(rC.w,mt.S.x);\n    float spec=float(rand(ro)<p);\n    float R=mix(mt.R.y,mt.R.x,spec);\n    \n    float S=0.;    \n    float r1=rand(ro);\n    float alpha=rand(ro)*2.*PI;\n    float beta=acos(1.-r1*(1.-cosD_S));\n\n    vec3 lD=tnor;\n    //local axis\n    vec3 randN0;randN0.y=-length(lD.xz);\n    if(length(lD.xz)<=0.)\n        randN0.xz=vec2(1,0);\n    else\n        randN0.xz=normalize(lD.xz)*lD.y;\n    vec3 randN1=cross(lD,randN0);\n    \n    vec3 rnd=(cos(beta))*lD+sin(beta)*(cos(alpha)*randN0+sin(alpha)*randN1);\n\n    lD=n;\n    randN0;randN0.y=-length(lD.xz);\n    if(length(lD.xz)<=0.)\n        randN0.xz=vec2(1,0);\n    else\n        randN0.xz=normalize(lD.xz)*lD.y;\n    randN1=cross(lD,randN0);\n    beta=acos(clamp(-dot(normalize(-rnd+rd),n),0.,1.));\n    alpha=0.;\n\n    float t=0.;\n    vec4 fog=InsideFog(ro,oA);\n    bool ifSmoke;\n    vec3 tp=raycast(ro+rnd*ShadowOffset,rnd,t,fog.x,ifSmoke);\n    if(t<-0.5) return vec4(0);\n\n\n    oA=DE(tp,vec3(0));\n    vec3 pos=tp;\n    vec3 normal=estimateNormal(pos);\n    mt=Material(pos,normal,oA);\n    hit=thit;\n\n    S=HGGXpdf(beta,alpha,R,mt.R.zw);\n    \n    vec3 sampleColor=mt.light;\n    rC=rColor(mt.Cs,max(dot(rd,normalize(-rnd+rd)),0.));\n    sampleColor*=mt.Cd*(1.-mt.S.x*rC.rgb)+mt.S.x*rC.rgb;\n\n    float G1=max(dot(rnd,n),0.);\n    float IoN=abs(dot(rd,n));\n    float OoN=abs(dot(rnd,n));\n    float IoH=abs(dot(rd,randN));\n    float NoH=abs(dot(n,randN));\n    float G2=HGGX_G2(IoN,OoN,R,mt.R.zw);\n    spec*=G2;\n    sampleColor*=mix2(G1,G2*0.25/IoH,spec);\n   \n    return max(vec4(0),vec4(sampleColor,S*(1.-cosD_S)*50.));\n\n}\n\nvec4 SunLight(vec3 ro,vec3 rd,vec3 n){\n    const float S_R=0.125;\n    float cosD_S=1./sqrt(1.+S_R*S_R);\n\n    float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n    object oA=DE(ro,vec3(0));\n    object oB=DE(ro-n*EPSILON*2.,vec3(0));\n    vec4 MaterialA=InsideMaterial(ro,oA);vec4 MaterialB=InsideMaterial(ro-n*EPSILON*2.,oB);\n    float rs=MaterialB.x/MaterialA.x;\n    material mt=Material(ro,n,oA);\n    \n    \n    vec3 randN=HGGXNormal(n,mt.R.x,mt.R.zw,ro);\n    float k=fresnel(-n,randN,rs);\n    vec4 rC=rColor(mt.Cs,max(dot(-rd,randN),0.));\n    float p=mixp(rC.w,mt.S.x);\n    float spec=float(rand(ro)<p);\n    float R=mix(mt.R.y,mt.R.x,spec);\n    \n    float S=0.;    \n    float r1=rand(ro);\n    float alpha=rand(ro)*2.*PI;\n    float beta=acos(1.-r1*(1.-cosD_S));\n\n    vec3 lD=lightDir;\n    //local axis\n    vec3 randN0;randN0.y=-length(lD.xz);\n    if(length(lD.xz)<=0.)\n        randN0.xz=vec2(1,0);\n    else\n        randN0.xz=normalize(lD.xz)*lD.y;\n    vec3 randN1=cross(lD,randN0);\n    \n    vec3 rnd=(cos(beta))*lD+sin(beta)*(cos(alpha)*randN0+sin(alpha)*randN1);\n\n    lD=n;\n    randN0;randN0.y=-length(lD.xz);\n    if(length(lD.xz)<=0.)\n        randN0.xz=vec2(1,0);\n    else\n        randN0.xz=normalize(lD.xz)*lD.y;\n    randN1=cross(lD,randN0);\n    beta=acos(clamp(-dot(normalize(rnd+rd),n),0.,1.));\n    alpha=0.;\n\n    float t=0.;\n    vec4 fog=InsideFog(ro,oA);\n    bool ifSmoke;\n    vec3 tp=raycast(ro-rnd*ShadowOffset,-rnd,t,fog.x,ifSmoke);\n    if(t>-0.5) return vec4(0);\n    vec4 tmp=background(ro,-rnd,-lightDir);\n\n    S=HGGXpdf(beta,alpha,R,mt.R.zw);\n    \n    vec3 sampleColor=tmp.xyz;\n    rC=rColor(mt.Cs,max(dot(rd,normalize(rnd+rd)),0.));\n    sampleColor*=mt.Cd*(1.-mt.S.x*rC.rgb)+mt.S.x*rC.rgb;\n\n    float G1=max(dot(-rnd,n),0.);\n    float IoN=abs(dot(rd,n));\n    float OoN=abs(dot(rnd,n));\n    float IoH=abs(dot(rd,randN));\n    float NoH=abs(dot(n,randN));\n    float G2=HGGX_G2(IoN,OoN,R,mt.R.zw);\n    spec*=G2;\n    sampleColor*=mix2(G1,G2*0.25/IoH,spec);\n    return max(vec4(0),vec4(sampleColor,S)*(dot(rnd,lightDir)-0.997>0.?1.:0.));\n}\n\nfloat calcS(vec4 r1,vec4 r2,vec3 n,float K,float u){//an interesting equation\n    float t1=dot(r1.xyz,n);\n    float t2=dot(r2.xyz,n);\n    return (K*dot(r1.xyz*r1.w+r2.xyz*r2.w,n)-u*r1.w*t1*t1)/max(r2.w*t2*t2,1e-4);\n}\n\nfloat calcK(vec3 ro,vec3 n){//calculate the normal curvature of an sdf\n    float EPSILON=max(EPSILONS*distance(ro,pos_0),EPSILONS_MIN);\n\n    vec3 p[4];\n    p[0]=normalize(vec3(1,1,1))*EPSILON;\n    p[1]=normalize(vec3(1,-1,-1))*EPSILON;\n    p[2]=normalize(vec3(-1,-1,1))*EPSILON;\n    p[3]=normalize(vec3(-1,1,-1))*EPSILON;\n    #define z0 vec3(0)\n    float s[10];\n    int i0=0;\n    for(int i=0;i<4;i++){\n        for(int j=i;j<4;j++){\n            s[i0]=DE(ro+p[i]+p[j],z0).d2;\n            i0++;\n        }\n    }\n        \n    vec3 dDE=s[0]*p[0]+s[4]*p[1]+s[7]*p[2]+s[9]*p[3];\n    vec3 N=cross(n,dDE);\n    float t1=dot(p[0],N);\n    float t2=dot(p[1],N);\n    float t3=dot(p[2],N);\n    float t4=dot(p[3],N);\n    \n    float k=2./(dot(p[0],p[0])*pow(length(N),3.));\n    k*=s[0]*t1*t1+s[4]*t2*t2+s[7]*t3*t3+s[9]*t4*t4\n        +2.*(s[1]*t1*t2+s[2]*t1*t3+s[3]*t1*t4+s[5]*t2*t3+s[6]*t2*t4+s[8]*t3*t4);\n    return k*0.75;\n}\nvec2 Projection(vec2 p,float S){\n    #ifdef SphereProjection\n        if(length(p)==0) return p;\n        return normalize(p)*tan(length(p)*S);\n    #else\n        return p*S;\n    #endif\n}\nvec4 frag_0;\nvoid Store(vec4 c){\n    frag_0=c;\n}\nvec2 uv00;\nvec4 Load(){\n    return texture(iChannel0,uv00);\n}\n\nvec3 bloom(vec2 pos){\n    vec2 p0=pos;\n    vec3 c=vec3(0);\n    const int amount=4;\n    for(int i=0;i<amount;i++){\n        pos=p0;\n        float a=2.*PI*rand(pos*50.+float(iFrame));\n        float b=sqrt(-log(0.975*rand(pos*50.+float(iFrame)+10.)+0.075));\n        pos+=b*vec2(cos(a),sin(a));\n        pos-=p0;\n        pos=normalize(pos)*pow(length(pos),6.)*10e-3;\n        vec4 A=texture(iChannel0,clamp(vec2(0,0.5)+(pos+p0-vec2(0,0.5))*vec2(1,iResolution.x/iResolution.y),0.,1.));\n        if(iFrame_==0.)\n            c+=vec3(0);\n        else\n            c+=max(A.xyz,0.);\n    }\n    c/=float(amount);\n    float l=luma(c);\n    return c*smoothstep(0.25,2.,l);\n}\nvoid F(float x,float y,vec3 Eye_Direction,vec3 Position){\n    if(abs(y)>9.0/16.) {Store(Load());return;}\n    iFrame_=floor(float(iFrame)/cut);\n    float divCut=1.0/cut;\n    float iFrame_offset=mod(float(iFrame),cut)*divCut;\n    if(0.5*y+0.5<iFrame_offset||0.5*y+0.5>=iFrame_offset+divCut||float(iFrame_)>AA*AA) {Store(Load());return;}\n    float x0=mod(float(iFrame_),AA)/AA;\n    float y0=floor(float(iFrame_)/AA)/AA;\n    float iW=iResolution.x;\n    x+=1.0/iW*x0;\n    y+=1.0/iW*y0;\n    \n    vec3 n=normalize((rot(vec3(Projection(vec2(x,y),FOV),1),Eye_Direction)).xyz);\n    vec3 n_m=normalize((rot(vec3(Projection(DOF_Pos,FOV),1),Eye_Direction)).xyz);\n\n    vec3 pos=Position;\n    float DOF=0.1;\n    bool ifSmoke;\n    if(DOF_R>0.) raycast(pos,n_m,DOF,0.,ifSmoke);\n    if(DOF<-0.5) DOF=Far;\n    vec3 Q=pos+n*DOF;\n    vec3 X;X.y=-length(n.xz);\n    vec3 Y;Y.xz=(float(length(n.xz)==0.)*vec2(1,0)+normalize(n.xz))*n.y;\n    Y=cross(n,X);float tmp_1=rand(pos+vec3(x,iFrame,y))*2.*PI;\n    float tmp_2=rand(pos+vec3(x,iFrame,y+5.));\n    n=normalize(n+tmp_2*DOF_R/DOF*(X*sin(tmp_1)+Y*cos(tmp_1)));\n    pos=Q-DOF*n;\n    \n    vec3 pos00=pos;\n    pos_0=pos00;\n    vec3 tcolor=vec3(0);\n    for(int i=0;i<=MaxReflect;i++) {\n        fog0[i]=vec3(1);\n        rdinfo[i]=vec4(0,0,0,1);\n    }\n\n    int reflectstep=0;\n    bool hit0=false;\n    float depth=Far;\n    vec3 back=background(pos,n,-lightDir).xyz;\n\n    object oA0=DE(pos,vec3(0));\n    vec3 fogS_=InsideFog(pos,oA0).yzw;\n\n    vec3 n_0=n;\n    vec4 fog=InsideFog(pos,oA0);\n\n    for(reflectstep=0;reflectstep<MaxReflect;reflectstep++){\n        float t=0.;\n        bool ifSmoke;\n        vec3 nextpos=raycast(pos,n,t,fog.x,ifSmoke);\n        if(t<-0.5) break;\n        distance0s[reflectstep]=t;\n        pos=nextpos;\n        float EPSILON=max(EPSILONS*distance(pos,pos_0),EPSILONS_MIN);\n        object oA=DE(pos,vec3(0));\n        vec3 normal=ifSmoke?rndS(pos):estimateNormal(pos);\n        n1s[reflectstep]=normal; \n        normal=faceforward(normal,normal,n);\n        n0s[reflectstep]=normal;\n        object oB=DE(pos-normal*EPSILON*2.,vec3(0));\n        vec4 MaterialA=InsideMaterial(pos,oA);\n        vec4 MaterialB=InsideMaterial(pos-normal*EPSILON*2.,oB);\n        vec4 FogA=InsideFog(pos,oA);\n        vec4 FogB=InsideFog(pos-normal*EPSILON*2.,oB);\n        float rs=MaterialB.x/MaterialA.x;\n        material material=Material(pos,normal,oA);\n\n\n        fog0[reflectstep]=exp(-t*fogS_);\n        fog1_s[reflectstep]=t;\n        fog1_p[reflectstep]=pos;\n        fog1_n[reflectstep]=n;\n        LightColors[reflectstep]=material.light;\n \n        rd0s[reflectstep]=n;\n        ro0s[reflectstep]=pos;\n        \n        vec3 I_=vec3(1);int i=0;\n        float R;\n        vec4 rdinfo_;\n        rdinfo_.w=1.;\n        rdinfo_.y=MaterialA.x;\n        vec3 n0,randN;\n        float spec;\n        bool refract_;\n        #if 0\n        do{//this code has some weird bugs on several platforms \n            i++;refract_=false;\n            n0=n;\n            randN=HGGXNormal(normal,material.R.x,material.R.zw,pos);\n            float F=fresnel(-n,randN,rs);\n            \n            vec4 rC=rColor(material.Cs,max(dot(-n,randN),0.));\n            roughness0[reflectstep]=material.R.x;\n            \n            float p=mixp(rC.w,material.S.x);\n            bool b0=rand(pos)<p;\n            R=mix(material.R.y,material.R.x,float(b0));\n            spec=float(b0);\n            if(b0){\n                I_*=rC.rgb*(1.+(material.S.x-1.)*rC.w)/max(rC.w,1e-5);\n                refract_=false;\n            }else{\n                I_*=material.Cd*(1.+(material.S.x-1.)*rC.w)/max(1.-rC.w,1e-5)*(1.-material.S.x*rC.rgb);\n                randN=HGGXNormal(normal,material.R.y,material.R.zw,pos);\n                refract_=rand(pos)<material.S.y*(1.-F);\n                roughness0[reflectstep]=material.R.y;\n            \n            }\n            vec3 v0=mix(reflect(n,randN),refract(n,randN,1./rs),float(refract_));\n            bool a; fogS_=FogA.yzw;\n            rdinfo_.z=MaterialA.x;\n            if(refract_){\n                if(v0==vec3(0)){\n                    v0=reflect(n,randN);a=dot(normal,v0)>0.;\n                    refract_=false;\n                }else{\n                    rdinfo_.z=MaterialB.x;\n                    pos-=2.*EPSILON*normal;a=dot(normal,v0)<0.;\n                    fogS_=FogB.yzw;\n                }\n            }else{a=dot(normal,v0)>0.;rdinfo_.w*=float(b0);}\n            n=v0;if(a) break;\n        }while(i<16);\n        #else\n        {\n            do{\n                  randN=HGGXNormal(normal,material.R.x,material.R.zw,pos);\n                  vec3 n00=reflect(randN,n);\n                  if(dot(n00,normal)>0.) break;\n                  i++;\n            }while(i<16);\n            \n            \n            n0=n;\n            float F=fresnel(-n,randN,rs);\n            \n            vec4 rC=rColor(material.Cs,max(dot(-n,randN),0.));\n            roughness0[reflectstep]=material.R.x;\n            \n            float p=mixp(rC.w,material.S.x);\n            bool b0=rand(pos)<p;\n            R=mix(material.R.y,material.R.x,float(b0));\n            spec=float(b0);\n            if(b0){\n                I_*=rC.rgb*(1.+(material.S.x-1.)*rC.w)/max(rC.w,1e-5);\n                refract_=false;\n            }else{\n                I_*=material.Cd*(1.+(material.S.x-1.)*rC.w)/max(1.-rC.w,1e-5)*(1.-material.S.x*rC.rgb);\n                randN=HGGXNormal(normal,material.R.y,material.R.zw,pos);\n                refract_=rand(pos)<material.S.y*(1.-F);\n                roughness0[reflectstep]=material.R.y;\n            \n            }\n            vec3 v0=mix(reflect(n,randN),refract(n,randN,1./rs),float(refract_));\n            bool a; fogS_=FogA.yzw;\n            rdinfo_.z=MaterialA.x;\n            if(refract_){\n                if(v0==vec3(0)){\n                    v0=reflect(n,randN);a=dot(normal,v0)>0.;\n                    refract_=false;\n                }else{\n                    rdinfo_.z=MaterialB.x;\n                    pos-=2.*EPSILON*normal;a=dot(normal,v0)<0.;\n                    fogS_=FogB.yzw;\n                }\n            }else{a=dot(normal,v0)>0.;rdinfo_.w*=float(b0);}\n            n=v0;\n            \n        }\n        \n        #endif\n        \n        float IoN=abs(dot(n0,normal));\n        float OoN=abs(dot(n,normal));\n        float IoH=abs(dot(n0,randN));\n        float NoH=abs(dot(normal,randN));\n        float G0=HGGX_G2(IoN,OoN,R,material.R.zw);\n        float G2=G0;\n        spec*=G2;\n        float G1=(refract_?1.:max(dot(n,normal),0.));\n\n        I_*=mix2(G1,G2,spec);\n\n        colors[reflectstep].xyz=I_;\n        rd1s[reflectstep]=n;\n        #ifdef FixCaustics\n        vec3 td=cross(n,rd0s[reflectstep]);\n        td=td==vec3(0,0,0)?cross(rd0s[reflectstep].yzx,rd0s[reflectstep]):td;\n        rdinfo_.x=calcK(pos,normalize(td));\n        rdinfo[reflectstep]=rdinfo_;\n        #endif\n\n        if(!hit0) {depth=distance(pos,pos00);}\n        hit0=true;\n        oA=DE(pos,vec3(0));\n        fog=FogA;\n\n        if(distance(pos,pos00)>Far) break;\n    }\n    fog0[reflectstep]=exp(-1e10*fogS_);\n    enablewater=false;\n\n    tcolor=background(pos,n,-lightDir).xyz;\n    if(!hit0) tcolor*=fog0[reflectstep];\n    enablewater=false;\n    int j0=-1,j1=-1;float p_0=0.,p_1=0.;\n    float A=0.;\n    for(int i=reflectstep-1;i>=0;i--) {\n        A+=roughness0[i]*roughness0[i];\n        directLight0[i]=vec3(0);\n    }\n    float A_0=A;\n    //sample Sun and Objects\n\n    if(A>0.){\n        bool a=true;\n        bool c0=true,c1=true;\n        for(int i=reflectstep-1;i>=0&&a;i--){\n            float p=roughness0[i]*roughness0[i]/A;\n            bool b0=rand(pos)<p&&c0;\n            j0=b0?i:j0;p_0=b0?p:p_0;\n            c0=b0?false:c0;\n            b0=rand(pos)<p&&c1;\n            j1=b0?i:j1;p_1=b0?p:p_1;\n            c1=b0?false:c1;\n            a=c0||c1;\n            A-=roughness0[i]*roughness0[i];\n        }\n    }\n\n    if(j0>=0){\n        vec4 sunL=SunLight(ro0s[j0],rd0s[j0],n0s[j0]);\n        directLight0[j0]+=sunL.xyz*sunL.w/p_0;\n    }\n    if(j1>=0){\n        vec4 objL=getObjectLight(ro0s[j1],rd0s[j1],n0s[j1]);\n        directLight0[j1]+=objL.xyz*objL.w/p_1;\n    }\n    \n    float L_S=1.;\n    \n    for(int i=reflectstep-1;i>=0;i--){\n        vec3 a=tcolor;\n        a=background(fog1_p[i+1],fog1_n[i+1],lightDir,fog1_s[i+1],a).xyz;\n        bool diffuse=rdinfo[i].w==0.;\n        tcolor=mix2(L_S,1.,rdinfo[i].w)*a*fog0[i+1]*colors[i]+directLight0[i]+LightColors[i];\n        #ifdef FixCaustics\n        if(diffuse) L_S=1.;\n        else{\n            float b=rdinfo[i].z*dot(rd1s[i],n0s[i])/(rdinfo[i].y*dot(rd0s[i],n0s[i]));\n            L_S*=b*b;\n        }\n        #endif\n\n    }\n    if(hit0) tcolor=fog0[0]*background(fog1_p[0],fog1_n[0],-lightDir,fog1_s[0]*FogS,tcolor).xyz;\n\n\n    tcolor=!hit0?back:tcolor;\n    tcolor=clamp(tcolor,0.,4.);\n\n    //bloom\n    vec3 bloom=bloom(vec2(x,y)*0.5+0.5);\n    tcolor=max(tcolor,bloom);\n    \n    if(iFrame_<=0.){\n        Store(vec4(tcolor,0.));\n    }else{\n        vec4 temp0=Load();\n        Store((temp0*float(iFrame_)+vec4(tcolor,0))/(float(iFrame_)+1.));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv00=uv;\n    vec3 m=vec3(0.4,-22.59,0);//camera rotation\n    vec3 p=vec3(3.67,2.18,5.19);//camera position\n\n    F(2.*uv.x-1.,(2.*uv.y-1.)/iResolution.x*iResolution.y,m,p);\n\n    fragColor = frag_0;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}