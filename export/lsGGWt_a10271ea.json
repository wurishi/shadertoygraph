{"ver":"0.1","info":{"id":"lsGGWt","date":"1456975960","viewed":292,"name":"Stars over sphere","username":"vamoss","description":"Sphere over star","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["sphere","stars","pattern","astroid","hypocycloid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nOriginal work:\nhttp://gif.flrn.nl/post/140050674884\n*/\n\n/*\nOriginal sphere code from tenderfoot\nhttps://www.shadertoy.com/view/XdXXRj\n*/\n\nvec3 light = vec3(-1, -1, 1.5);\nvec3 light_color = vec3(1, 1, 1);\n\nvec3 sphere = vec3(0, 0, 2);\nfloat sphere_size = 1.3;\nvec3 sphere_color = vec3(1, 1, 1);\n\nfloat raySphere(vec3 rpos, vec3 rdir, vec3 sp, float radius, inout vec3 point, inout vec3 normal) {\n\tradius = radius * radius;\n\tfloat dt = dot(rdir, sp - rpos);\n\tif (dt < 0.0) {\n\t\treturn -1.0;\n\t}\n\tvec3 tmp = rpos - sp;\n\ttmp.x = dot(tmp, tmp);\n\ttmp.x = tmp.x - dt*dt;\n\tif (tmp.x >= radius) {\n\t\treturn -1.0;\n\t}\n\tdt = dt - sqrt(radius - tmp.x);\n\tpoint = rpos + rdir * dt;\n\tnormal = normalize(point - sp);\n\treturn dt;\n}\n\n#define TWO_PI 6.28318530718\n\nvec3 texture2(vec2 uv){\n    vec2 st = uv;\n    \n    float radius = 0.8;\n    \n    //tile\n    vec2 frequency = vec2(8.0, 8.0);\n    vec2 index = floor(frequency * st)/frequency;\n    float centerDist = 1.0-length(index-0.5);\n    vec2 nearest = 2.0 * fract(frequency * st) - 1.0;\n    \n    //movement\n    float velocity = 10.0;\n    nearest.x += cos(iTime * velocity + centerDist * TWO_PI)*(1.0-radius)/2.0;\n    nearest.y += sin(iTime * velocity + centerDist * TWO_PI)*(1.0-radius)/2.0;\n    \n    //astroid\n    float astroid = length(nearest)<radius ? 1.0 : 0.0;\n    float dist = length(nearest-vec2(radius, radius));\n    astroid *= step(radius, dist);\n    dist = length(nearest-vec2(-radius, radius));\n    astroid *= step(radius, dist);\n    dist = length(nearest-vec2(-radius, -radius));\n    astroid *= step(radius, dist);\n    dist = length(nearest-vec2(radius, -radius));\n    astroid *= step(radius, dist);\n    astroid = 1.0 - astroid;\n    \n    //colors\n    vec3 bgColor = vec3(0.1, 0.1, 0.1);\n    \n    float totalColors = 8.0;\n    float cIndex = floor((index.x+(index.y*4.0))*totalColors);\n    cIndex = mod(cIndex, totalColors);\n    vec3 color = vec3(0.0);\n    if(cIndex==0.0) color = vec3(0.92, 0.35, 0.20);\n    else if(cIndex==1.0) color = vec3(0.50, 0.77, 0.25);\n    else if(cIndex==2.0) color = vec3(0.00, 0.63, 0.58);\n    else if(cIndex==3.0) color = vec3(0.08, 0.45, 0.73);\n    else if(cIndex==4.0) color = vec3(0.38, 0.18, 0.55);\n    else if(cIndex==5.0) color = vec3(0.76, 0.13, 0.52);\n    else if(cIndex==6.0) color = vec3(0.91, 0.13, 0.36);\n    else if(cIndex==7.0) color = vec3(0.96, 0.71, 0.17);\n    \n    color = mix(color, bgColor, astroid);\n    \n    return color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tlight.xy = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n\tlight.y = -light.y;\n    \n    vec3 point; \n\tvec3 normal;\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tuv.y = -uv.y;\n    \n\tvec3 ray = vec3(uv.x, uv.y, 1.0);\n\tray = normalize(ray);\n\tfragColor = vec4(vec3(0.1), 1.0);\n\t\n\tfloat dist = raySphere(vec3(0.0), ray, sphere, sphere_size, point, normal);\n\t\n\tif (dist > 0.0) {\n\t\tvec3 tmp = normalize(light - sphere);\n\t\tfloat u = atan(normal.z, normal.x) / 3.1415*2.0 + iTime / 5.0;\n\t\tfloat v = asin(normal.y) / 3.1415*2.0 + 0.5;\n\t    fragColor.xyz = vec3(dot(tmp, normal)) * light_color * sphere_color * texture2(vec2(u, v));\n\t}\n}","name":"Image","description":"","type":"image"}]}