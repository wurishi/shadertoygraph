{"ver":"0.1","info":{"id":"XsdSz4","date":"1461345882","viewed":344,"name":"Metal stone container","username":"TambakoJaguar","description":"A bumped golden container with greenish water in it and a red stick to show the refraction. This is from a test I made with Blender some time ago. You can rotate it with the mouse.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["noise","reflection","refraction","water","bump","metal","stone","container","stick"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Metal stone container\" by Emmanuel Keller aka Tambako - April 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n*/\n\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define bumped_metal\n#define specular\n//#define shadow\n#define reflections\n//#define ambocc\n#define show_water\n#define water_transparent\n#define show_stick\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n  \tint objnr;\n};\n   \n// Every object of the scene has its ID\n#define SKY_OBJ         0\n#define METAL_OBJ       1\n#define WATER_OBJ       2\n#define STICK_OBJ       3\n\nLamp lamps[3];\n\n// Campera options\nvec3 campos = vec3(0., 0., 10.);\nvec3 camdir = vec3(0., 0., -1.);\nfloat fov = 5.5;\nfloat angle;\nfloat angle2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(0.3);\nconst float ambientint = 0.;\n\n// Color options\nconst vec3 waterColor = vec3(0.912, 0.98, 0.918);\nconst vec3 waterColor2 = vec3(0.4, 0.7, 1.0);\nconst vec3 stickColor = vec3(1., 0., 0.);\nconst vec3 metalColor = vec3(0.9, 0.78, 0.4);\nconst float metalref = 0.73;\n\n// Shading options\nconst float specint = 0.4;\nconst float specshin = 45.;\nconst float aoint = 0.55;\nconst float shi = 2.85;\nconst float shf = 1.4;\n    \n// Tracing options\nconst float normdelta = 0.001;\nconst float maxdist = 40.;\nconst int nbref = 5;\nconst float water_ior = 1.33;\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\nconst float aawidth = 0.8;\nconst int aasamples = 1;\n\n// How bumpy the metal stone\nconst float bumpfactor = 0.85;\n\n// Union operation from iq\nvec2 opU(vec2 d1, vec2 d2)\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\nvec3 rotateVec2(vec3 posr)\n{\n    posr = vec3(posr.x, posr.y*cos(angle2) + posr.z*sin(angle2), posr.y*sin(angle2) - posr.z*cos(angle2));\n    posr = vec3(posr.x*cos(angle) + posr.z*sin(angle), posr.y, posr.x*sin(angle) - posr.z*cos(angle)); \n    \n    return posr;\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*753.5453123);\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise(vec3 x)\n{\n    //x.x = mod(x.x, 0.4);\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise2(vec3 pos)\n{\n    #ifdef bumped_metal\n    vec3 q = pos;\n    float f = 0.7000*noise(q); q = m*q*8.;\n    f += 0.070*noise(q); q = m*q*2.75;\n    f += 0.008*noise(q); //q = m*q*2.35;\n    //f += 0.005*noise(q);\n    return f;\n    #else\n    return 0.3;\n    #endif\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat sdCylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat map_stone(vec3 pos)\n{\n   pos = rotateVec2(pos);\n   pos.y-= 0.3;\n    \n   float n1 = bumpfactor*noise2(normalize(pos));\n   float df1 = length(pos) - 1.90 + n1;\n   float df2 = length(pos) - 1.86 + n1;\n   float df = max(df1, -df2);\n   if (pos.y>0.)\n      df+= smoothstep(0.15, 0.35, pos.y);\n   df = max(df, pos.y - 0.3);\n   return df;\n}\n\n#ifdef show_water\nfloat map_water(vec3 pos)\n{\n   pos = rotateVec2(pos);\n   pos.y-= 0.3;\n    \n   float n1 = bumpfactor*noise2(normalize(pos));\n   float df = length(pos) - 1.864 + n1;\n   float be = 1./(0.07 + 4.*pow(abs(df), 0.35));\n   df = max(df, pos.y + 0.3 - 0.06*be);\n   return df;\n}\n#endif\n\n#ifdef show_stick\nfloat map_stick(vec3 pos)\n{\n   pos = rotateVec2(pos);\n   pos.xy = rotateVec(pos.xy, 0.33); \n\n   return sdCylinder(pos, vec2(0.09, 1.5));   \n}\n#endif\n\nvec2 map(vec3 pos, bool inside)\n{\n   vec2 res;\n   float stone = map_stone(pos);\n   #ifdef show_water\n   float water = map_water(pos);\n   if (inside)\n       water = -water;\n   res = opU(vec2(stone, METAL_OBJ), vec2(water, WATER_OBJ));\n   #else\n   res = vec2(stone, METAL_OBJ);\n   #endif\n   #ifdef show_stick\n   float stick = map_stick(pos);\n   return opU(vec2(stick, STICK_OBJ), res);\n   #else\n   return res;\n   #endif\n}\n\n// Main tracing function\nvec2 trace(vec3 cam, vec3 ray, float maxdist, bool inside) \n{\n    float t = 0.02;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    float dist2;\n    \n  \tfor (int i = 0; i < 115; ++i)\n    {\n    \tpos = ray*t + cam;\n        vec2 res = map(pos, inside);\n        dist = res.x;\n        if (dist>maxdist || abs(dist)<0.00005)\n            break;\n        t+= dist*0.3;\n        objnr = abs(res.y);\n  \t}\n  \treturn vec2(t, objnr);\n}\n\n// From https://www.shadertoy.com/view/MstGDM\n// Here the texture maping is only used for the normal, not the raymarching, so it's a kind of bump mapping. Much faster\nvec3 getNormal(vec3 pos, float e, bool inside)\n{  \n    vec2 q = vec2(0, e);\n    return normalize(vec3(map(pos + q.yxx, inside).x - map(pos - q.yxx, inside).x,\n                          map(pos + q.xyx, inside).x - map(pos - q.xyx, inside).x,\n                          map(pos + q.xxy, inside).x - map(pos - q.xxy, inside).x));\n}\n\n// Gets the color of the sky\nvec3 sky_color(vec3 ray)\n{\n\tvec3 rc = 1.5*texture(iChannel0, ray).rgb;\n    return rc;\n}\n\nvec3 getMetalColor(vec3 pos)\n{\n    return metalColor;\n}\n\nvec3 getStickColor(vec3 pos)\n{\n    return stickColor;\n}\n\nvec3 getWaterColor(vec3 pos)\n{\n    #ifdef water_transparent\n    return vec3(0.);\n    #else\n    return waterColor2;\n    #endif\n}\n    \n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, int objnr)\n{\n   return objnr==METAL_OBJ?getMetalColor(pos):\n         (objnr==STICK_OBJ?getStickColor(pos):getWaterColor(pos));\n}\n\n// From https://www.shadertoy.com/view/Xds3zN, but I changed the code\nfloat softshadow(vec3 ro, vec3 rd, float mint, float tmax)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i=0; i<50; i++)\n    {\n    \tfloat h = map(ro + rd*t, false).x;\n        res = min(res, 10.0*h/t + 0.02*float(i));\n        t += 0.8*clamp(h, 0.01, 0.35);\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// From https://www.shadertoy.com/view/Xds3zN\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<6; i++)\n    {\n        float hr = 0.01 + 0.12*float(i)/9.0;\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos, false).x;\n        occ+= -(dd - hr)*sca;\n        sca*= 0.85;\n    }\n    occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n// Fresnel reflectance factor through Schlick's approximation: https://en.wikipedia.org/wiki/Schlick's_approximation\nfloat fresnel(vec3 ray, vec3 norm, float n2)\n{\n   float n1 = 1.; // air\n   float angle = acos(-dot(ray, norm));\n   float r0 = dot((n1-n2)/(n1+n2), (n1-n2)/(n1+n2));\n   float r = r0 + (1. - r0)*pow(1. - cos(angle), 5.);\n   return r;\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int objnr, int lampnr)\n{\n\tvec3 pl = normalize(lamp.position - pos);\n    float dlp = distance(lamp.position, pos);\n    vec3 pli = pl/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*lamp.color*lamp.intensity*clamp(dot(norm, pli), 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamp.position - pos) > 0.0)\n        col+= lamp.color*lamp.intensity*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - campos))), specshin);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*softshadow(pos, normalize(vec3(lamp.position.x, 4.9, lamp.position.z) - pos), shf, 100.) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol, int objnr)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<3; l++) // lamps.length()\n        col+= lampShading(lamps[l], norm, pos, ocol, objnr, l);\n    \n    return col;\n}\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist, bool inside)\n{\n    vec2 tr = trace(tpos, ray, maxdist, inside);\n    float tx = tr.x;\n    int objnr = int(tr.y);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    lamps[0] = Lamp(vec3(-2., 12., 20.), vec3(1., 1., 1.), 1.8, 0.01);\n    lamps[1] = Lamp(vec3(-5., 3, -12.), vec3(1., .95, .75), 0.9, 0.01);\n    lamps[2] = Lamp(vec3(16., 5., -8.), vec3(1., .6, .5), 0.7, 0.01);\n    \n    if (tx<maxdist*0.95)\n    {\n        norm = getNormal(pos, normdelta, inside);\n        col = getColor(norm, pos, objnr);\n      \n        // Shading\n        col = ambientColor*ambientint + lampsShading(norm, pos, col, objnr);\n        \n        // Ambient occlusion\n        #ifdef ambocc\n        col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n        //col = vec3(calcAO(pos, norm));\n        #endif\n    }\n    else\n    {\n        objnr = SKY_OBJ;\n        col = vec3(0.);sky_color(ray);\n    }\n    return RenderData(col, pos, norm, objnr);\n}\n\nvec3 getWaterAbsColor(float dist)\n{\n    return pow(waterColor, vec3(1.5 + pow(dist, 2.5)*10.));\n}\n\n// Main render function with reflections and refractions\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv = fragCoord.xy / iResolution.xy; \n  \tuv = uv*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n\n  \tvec3 ray0 = GetCameraRayDir(uv, camdir, fov);\n    vec3 ray = ray0;\n  \tRenderData traceinf0 = trace0(campos, ray, maxdist, false);\n    RenderData traceinf = traceinf0;\n  \tvec3 col = traceinf.col;\n    vec3 col0 = vec3(0.);\n    if (traceinf.objnr==WATER_OBJ)\n        col0 = traceinf.col;\n  \tbool inside = false;\n  \tfloat cior = water_ior;\n  \tvec3 glassf = vec3(1.);\n    vec3 refray;\n    int i2;\n    \n  \tfor (int i=0; i<nbref; i++)\n \t{\n      \t#ifdef reflections\n  \t  \tif (traceinf.objnr==METAL_OBJ)\n      \t{\t   \n            refray = reflect(ray, traceinf.norm);\n          \tRenderData traceinf_ref = trace0(traceinf.pos, refray, 20., inside);\n            glassf*= metalref*getMetalColor(traceinf.pos);\n            col*= (1.- metalref)+metalref*col0;\n          \tcol+= metalref*glassf*traceinf_ref.col;\n          \tray = refray;\n          \ttraceinf = traceinf_ref;\n      \t}\n  \t\t#endif\n  \t\t#ifdef water_transparent\n  \t\tif (traceinf.objnr==WATER_OBJ)\n  \t\t{\n            \n            vec3 ray_r = refract(ray, traceinf.norm, 1./cior);\n            if (length(ray_r)!=0.)\n            {\n                inside = !inside;\n                cior = 1./cior;\n            }\n            else\n                ray_r = reflect(ray, traceinf.norm);            \n\n        \tvec3 pos = traceinf.pos;\n\n            traceinf = trace0(traceinf.pos, ray_r, 20., inside);\n            if (inside && i<2)\n                glassf*= getWaterAbsColor(distance(pos, traceinf.pos));\n\n            col+= traceinf.col*glassf;\n            \n            ray = ray_r;\n            \n    \t}\n        #endif\n        if (traceinf.objnr==SKY_OBJ)\n        {\n            col+= sky_color(ray)*glassf;\n            break;\n        }\n        i2 = i;\n  \t}\n  \t\n    //if (i2==nbref-1)\n    //\tcol = vec3(1., 0., 1.);\n   \n    #ifdef reflections\n    // Outer reflection\n    if (traceinf0.objnr==WATER_OBJ)\n    {\n    \tfloat r = 1.5*fresnel(ray0, traceinf0.norm, water_ior);\n    \tcol = mix(col, sky_color(reflect(ray0, traceinf0.norm)), r);\n    }\n\t#endif\n  \treturn vec4(col, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec2 iMouse2;\n    if (iMouse.x==0. && iMouse.y==0.)\n       iMouse2 = iResolution.xy*vec2(0.5, 0.5);\n    else\n       iMouse2 = iMouse.xy;\n    angle = 2.*pi*(iMouse2.x/iResolution.x - 0.5);\n    angle2 = -2.*pi*(iMouse2.y/iResolution.y - 0.5);\n    \n    // Antialiasing.\n    vec4 vs = vec4(0.);\n    for (int j=0;j<aasamples ;j++)\n    {\n       float oy = float(j)*aawidth/max(float(aasamples-1), 1.);\n       for (int i=0;i<aasamples ;i++)\n       {\n          float ox = float(i)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    fragColor = vs/vec4(aasamples*aasamples);\n}","name":"Image","description":"","type":"image"}]}