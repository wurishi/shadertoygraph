{"ver":"0.1","info":{"id":"slKGWW","date":"1637768328","viewed":223,"name":"paperplane","username":"skaplun","description":"Paperplane on steroids. The engines are actually work\nVoronoi and  its derivative calc give the most performance hit in the scene.\nCan somebody point me to more efficient voronoi derivatives? ","likes":26,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define LIGHT_DIR normalize(vec3(1., 2., .3))\n\nfloat paperplane(vec3 pos, PaperPlane paperPlane){\n    pos -= paperPlane.boundingSphere.o + vec3(.2, .1, 0.);\n    pos *= paperPlane.rotMat;\n    pos.z = abs(pos.z);\n    vec3 originalPos = pos;\n    \n    float res = MAX_FLOAT;\n    {\n        float base = plane(pos, vec3(-.17, .75, -1.5), -.13, .005);\n        base = max(base, pos.y);\n        base = max(base, sdPlane(pos, normalize(vec3(-1., 0., 0.)), -.75));\n        res = min(base, res);\n    }\n    \n    {\n        float wings = plane(pos, vec3(0., 1., 0.), 0., .001);\n        wings = max(wings, sdPlane(pos, normalize(vec3(1., 0., 2.)), -.35));\n        wings = max(wings, sdPlane(pos, normalize(vec3(-1., 0., 0.)), -.75));\n        wings = max(wings, sdPlane(pos, normalize(vec3(-1., 0., -9.)), .085));\n        res = min(wings, res);\n    }\n    \n    {\n        float h = sdBox(pos + vec3(.3, 0., -.4), vec3(.2, .1, .01));\n        h = max(h, pos.y);\n        vec3 mpos = pos + vec3(.6, .15, -.4);\n        float eng = sdCapsule(mpos, .5, .15 + .15 * pos.x * step(pos.x, 0.));\n        h = max(h, -eng);\n        float innerCyl = sdCappedCylinder(mpos, .1 + .05 * pos.x * step(pos.x, 0.), 1.);\n        eng = max(eng, -innerCyl);\n        res = min(res, eng);\n        res = min(res, h);\n        \n        pos = pos + vec3(.05, .125, -.4);\n        pos *= rx(iTime * 5.);\n        vec2 pol = vec2(length(pos.zy), atan(pos.z, pos.y));\n        pol.y = mod(pol.y, PI * .15);\n        mpos.zy = pol.x * vec2(sin(pol.y), cos(pol.y));\n        mpos.x -= .55;\n        mpos *= 2.;\n        \n        float e = sdBox(mpos, vec3(.02, .2, .02));\n        res = min(e, res);\n        res = min(sdEllipsoid(originalPos + vec3(.3, .15, -.4), vec3(.35, .065, .065)), res);\n    }\n    \n    return res;\n}\n\n\nfloat trail(vec3 pos, PaperPlane paperPlane){\n    pos -= paperPlane.boundingSphere.o + vec3(.2, .1, 0.);\n    pos *= paperPlane.rotMat;\n    pos.z = abs(pos.z);\n    \n    vec3 mpos = pos + vec3(5.2, .15, -.4);\n    float innerCyl = sdCappedCylinder(mpos, .1 - .05 * pos.x * step(pos.x, 0.), 5.);\n    \n    return innerCyl;\n}\n\nfloat marchTrail(in Ray r, PaperPlane paperPlane){\n    float t = .01;\n    for(int i = 0; i <= 64; i++){\n        vec3 p = r.o + r.dir * t;\n        float dst = trail(p, paperPlane);\n        if(abs(dst) < .01)\n            return t;\n        t += dst;\n    }\n    return -1.;\n}\n\n\nvec3 normals(vec3 pos, PaperPlane paperPlane){\n    vec2 eps = vec2(0.0, EPSILON);\n    vec3 n = normalize(vec3(\n        paperplane(pos + eps.yxx, paperPlane) - paperplane(pos - eps.yxx, paperPlane),\n        paperplane(pos + eps.xyx, paperPlane) - paperplane(pos - eps.xyx, paperPlane),\n        paperplane(pos + eps.xxy, paperPlane) - paperplane(pos - eps.xxy, paperPlane)));\n    return n;\n}\n\nconst int MAX_MARCHING_STEPS = 256;\nfloat march(in Ray r, PaperPlane paperPlane, float minDst, float maxDst){\n    float t = minDst;\n    for(int i = 0; i <= MAX_MARCHING_STEPS; i++){\n        vec3 p = r.o + r.dir * t;\n        float dst = paperplane(p, paperPlane);\n        if(dst < .0001)\n            return t;\n        t += dst * .5;\n        if(t > maxDst)\n            break;\n    }\n    return -1.;\n}\n\nvec4 getPaperPlane(PaperPlane pl, Ray r){\n    vec2 dst = vec2(MAX_FLOAT);\n    float planeHit = MAX_FLOAT;\n    if(sphere_hit(pl.boundingSphere, r, dst)){\n        planeHit = march(r, pl, dst[0], dst[1]);\n        if(planeHit >= 0.){\n            vec3 pos = r.o + r.dir * planeHit;\n            return vec4(vec3(1.) * max(dot(normals(pos, pl), LIGHT_DIR), .1), planeHit);\n        }else\n            return vec4(MAX_FLOAT);\n    }\n    \n    return vec4(planeHit);\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftShadow(PaperPlane pl, Ray r, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (-r.o.y)/r.dir.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<32; i++ )\n    {\n\t\tfloat h = paperplane(r.o + r.dir*t, pl);\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.005, 0.025 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat shadow(PaperPlane pl, Ray r, float maxDst){\n    //float e = .005;\n    return step(maxDst, getPaperPlane(pl, r).w);\n    \n    //+ step(maxDst, getPaperPlane(pl, Ray(r.o, normalize(r.dir + vec3(0., 0., e)))).w)\n    //+ step(maxDst, getPaperPlane(pl, Ray(r.o, normalize(r.dir + vec3(e, 0., 0.)))).w)\n    //+ step(maxDst, getPaperPlane(pl, Ray(r.o, normalize(r.dir + vec3(0., 0., -e)))).w)\n    //+ step(maxDst,getPaperPlane(pl, Ray(r.o, normalize(r.dir + vec3(-e, 0., 0.)))).w);\n    //return n/5.;\n}\n\nfloat groundClr(vec2 pos){\n    const vec2 size = vec2(.15, 0.);\n\n    float s11 = smoothstep(.2, 0., voronoi(pos).x);\n    float s01 = smoothstep(.2, 0., voronoi(pos + vec2(-.01, 0.)).x);\n    float s21 = smoothstep(.2, 0., voronoi(pos + vec2(.01, 0.)).x);//noised(uv + off.zy).x + trail(groundPos.xz + vec2(-.4, 0.));\n    float s10 = smoothstep(.2, 0., voronoi(pos + vec2(0., -.01)).x);//noised(uv + off.yx).x + trail(groundPos.xz + vec2(.0, .4));\n    float s12 = smoothstep(.2, 0., voronoi(pos + vec2(0., .01)).x);//noised(uv + off.yz).x + trail(groundPos.xz + vec2(.0, -.4));\n    vec3 va = normalize(vec3(size.xy, s21-s01));\n    vec3 vb = normalize(vec3(size.yx, s12-s10));\n    vec4 bump = vec4( cross(va,vb), s11 );\n    vec3 nor =  bump.xzy;\n    \n    return dot(nor, LIGHT_DIR);\n}\n\nfloat time;\nconst PaperPlane staticPlane = PaperPlane(Sphere(vec3(0.), 1.), mat3(1.));\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime * .5;\n    vec3 lookAt = vec3(0.);\n    //float a = iMouse.x/iResolution.x * 5.;\n    float a = noised(vec2(iTime + 317.) * .1).x * 10.;\n    vec3 eye = vec3(12. * sin(a), 2., 12. * cos(a));\n    vec3 viewDir = rayDirection(30., iResolution.xy, fragCoord);\n    vec3 worldDir = viewMatrix(eye, lookAt, vec3(0., 1., 0.)) * viewDir;\n\n    Ray r = Ray(eye, worldDir);\n    vec3 color = vec3(0.);\n    \n    PaperPlane pl = staticPlane;\n    vec3 horNoise = noised(vec2(time));\n    vec3 vertNoise = noised(vec2(time * .5) + 1037.23);\n    pl.boundingSphere.o.z += horNoise.x * 3.;\n    pl.rotMat *= rx(-horNoise.y);\n    pl.boundingSphere.o.y += vertNoise.x * 2.;\n    pl.rotMat *= rz(-vertNoise.y * .25);\n    \n    vec4 planeHit = getPaperPlane(pl, r);\n    if(planeHit.w < MAX_FLOAT){\n        vec3 planePos = r.o + r.dir * planeHit.w;\n        color = planeHit.rgb\n              * max(calcSoftShadow(pl, Ray(planePos, LIGHT_DIR), EPSILON, 1.), .25);\n    }\n    \n    float trail = marchTrail(r, pl);\n    if(trail >= 0.){\n        vec3 trailPos = r.o + r.dir * trail;\n        vec3 pr = noised(trailPos.xy * vec2(15., 10.) + vec2(iTime * .2));\n        r.dir = normalize(r.dir + vec3(pr.y, pr.z, 0.) * .01);\n    }\n    \n    float hitFloor = (-1.5-r.o.y)/r.dir.y;\n    if(hitFloor < planeHit.w){\n        vec3 floorPos = r.o + r.dir * hitFloor;\n        color = vec3(0.051,0.400,0.447)\n              * max(shadow(pl, Ray(floorPos, LIGHT_DIR), MAX_FLOAT - MIN_FLOAT), .25);\n              \n        color = mix(vec3(0.898,0.804,0.604), color * groundClr((floorPos.xz + vec2(time * 20., 0.)) * .5), smoothstep(50., 15., distance(floorPos.xz, vec2(0., 0.))));\n              \n    }\n    \n    fragColor =  vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define ZERO (min(iFrame,0))\n#define MAX_FLOAT 1e6\n#define MIN_FLOAT 1e-6\n#define EPSILON 1e-4\n#define UP vec3(0., 1., 0.)\n#define rx(a) mat3(1.0, 0.0, 0.0, 0.0, cos(a),-sin(a), 0.0, sin(a), cos(a))\n#define ry(a) mat3(cos(a), 0.0,-sin(a), 0.0, 1.0, 0.0, sin(a), 0.0, cos(a))\n#define rz(a) mat3(cos(a),-sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0)\n#define saturate(x) clamp(x, 0., 1.)\n\nconst float PI = acos(-1.);\n\nstruct Ray{vec3 o, dir;};\nstruct Sphere{vec3 o; float rad;};\nstruct Box{ vec3 o; vec3 size;};\nstruct PaperPlane{ Sphere boundingSphere; mat3 rotMat; };//TODO merge into single mat4\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nmat4 rotationMatrix(vec3 axis, float angle){\n    // taken from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    angle = radians(angle);\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nfloat sphere_hit(const in Sphere sphere, const in Ray inray) {\n    vec3 oc = inray.o - sphere.o;\n    float a = dot(inray.dir, inray.dir);\n    float b = dot(oc, inray.dir);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        return (-b - sqrt(discriminant))/a;\n    }\n    return -1.;\n}\n\nbool sphere_hit(const in Sphere sphere, const in Ray inray, out vec2 dst) {\n    vec3 oc = inray.o - sphere.o;\n    float a = dot(inray.dir, inray.dir);\n    float b = dot(oc, inray.dir);\n    float c = dot(oc, oc) - sphere.rad*sphere.rad;\n    float discriminant = b*b - a*c;\n    if (discriminant > 0.) {\n        dst = (-b + vec2(-sqrt(discriminant), sqrt(discriminant)))/a;//(-b - sqrt(discriminant))/a;\n        return true;\n    }\n    return false;\n}\n\n#define MIN x\n#define MAX y\nbool box_hit(const in Box inbox, in Ray inray){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.o.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.o.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.o.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0.){\n    \treturn true;\n    }\n        \n    return false;\n}\n\nbool box_hit(const in Box inbox, in Ray inray, out vec2 dst){\n    vec2 tx, ty, tz;\n    vec3 maxbounds = inbox.o + vec3( inbox.size);\n    vec3 minbounds = inbox.o + vec3(-inbox.size);\n    tx = ((inray.dir.x >= 0.?vec2(minbounds.x, maxbounds.x):vec2(maxbounds.x, minbounds.x)) - inray.o.x) / inray.dir.x;\n\tty = ((inray.dir.y >= 0.?vec2(minbounds.y, maxbounds.y):vec2(maxbounds.y, minbounds.y)) - inray.o.y) / inray.dir.y;\n    if ((tx.MIN > ty.MAX) || (ty.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, ty.MIN), min(tx.MAX, ty.MAX));\n\ttz = ((inray.dir.z >= 0.?vec2(minbounds.z, maxbounds.z):vec2(maxbounds.z, minbounds.z)) - inray.o.z) / inray.dir.z;\n    if ((tx.MIN > tz.MAX) || (tz.MIN > tx.MAX))\n        return false;\n    tx = vec2(max(tx.MIN, tz.MIN), min(tx.MAX, tz.MAX));\n    \n    if(tx.MIN >= 0. || tx.MAX >= 0.){\n        dst = vec2(tx.MIN, tx.MAX);\n        return true;\n    }\n        \n    return false;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r){\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRoundBox(vec3 p, vec3 b, float r){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdPlane(vec3 p, vec3 n, float h ) {\n    return dot(p,n) + h;\n}\n\n//const float CUTOFF_PLANES_THICKNESS = .05;\nfloat plane(vec3 pos, vec3 nrm, float dist, float thickness){\n    return max(-sdPlane(pos, nrm, -dist + thickness),\n               -sdPlane(pos, nrm * -1., dist + thickness));\n}\n\nfloat sdCapsule(vec3 p, float h, float r)\n{\n  p.x -= clamp( p.x, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.yz),p.x)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\n//by iq\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvec3 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash( n + g );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( iTime + 6.2831*o );\n        #endif\t\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec3( md, mr );\n}","name":"Common","description":"","type":"common"}]}