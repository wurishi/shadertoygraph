{"ver":"0.1","info":{"id":"Mf2fW3","date":"1725596477","viewed":25,"name":"Simple shaded Torus","username":"jeremyjohnson143","description":"Simple Torus shape used from https://iquilezles.org/articles/distfunctions/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Signed distance function for a torus from https://iquilezles.org/articles/distfunctions/\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n// make the normal\nvec3 getNormal(vec3 p, vec2 t) {\n    const float epsilon = 1e-5; // this is used to find the surface gradient for shading, want it small but not too small\n    vec3 n;\n    n.x = sdTorus(p + vec3(epsilon, 0.0, 0.0), t) - sdTorus(p - vec3(epsilon, 0.0, 0.0), t);\n    n.y = sdTorus(p + vec3(0.0, epsilon, 0.0), t) - sdTorus(p - vec3(0.0, epsilon, 0.0), t);\n    n.z = sdTorus(p + vec3(0.0, 0.0, epsilon), t) - sdTorus(p - vec3(0.0, 0.0, epsilon), t);\n    return normalize(n);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // coords\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; // Aspect ratio correction\n\n    vec3 backgroundcol = vec3(0.0);\n\n    // Distance along ray\n    float t = 0.0;\n\n    // Position and size of torus\n    vec3 torusPos = vec3(0.0, 0.0, 5.0); // Position of the torus\n    vec2 torusParams = vec2(1.0, 0.2); // Major radius Minor radius\n\n    // Starting point of the ray and the direction it follows\n    vec3 pt = vec3(uv, 0.0);\n    vec3 dir = normalize(vec3(0.0, 0.0, 1.0)); // Looking towards +z direction\n    //vec3 col = vec3(1);\n    // trace the ray\n    for (int i = 0; i < 100; i++) {\n        // Calc the pos along ray\n        vec3 pos = pt + dir * t;\n\n        //dist from pos from shape\n        float dist = sdTorus(pos - torusPos, torusParams);\n        //add another shape and try to comb or use diff\n      //  backgroundcol += texture(iChannel0, uv).rgb;\n        if (dist < 0.01) { // hit the surface\n            //make the normal\n            vec3 normal = getNormal(pos - torusPos, torusParams);\n            \n            //lighting\n            vec3 lightDir = normalize(vec3(50, 20, -200)); // Direction of the light, not sure how this works\n            float diff = max(dot(normal, lightDir), 0.0);\n            \n            \n            // add noise \n            backgroundcol = vec3(1.0, 0.0, 0.0) * diff; // Color of the torus with simple diffuse lighting\n          backgroundcol += texture(iChannel0, uv+iTime).rgb;\n          break; // Exit the loop if hit\n        }\n        // Update distance along the ray\n        t += dist;\n    }\n\n    // Output color to the screen\n    fragColor = vec4(backgroundcol, 2.0);\n    //fragColor = vec4(texture(iChannel0, uv).rgb);\n    vec3 col = vec3(1);\n}\n","name":"Image","description":"","type":"image"}]}