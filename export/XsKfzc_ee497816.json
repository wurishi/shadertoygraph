{"ver":"0.1","info":{"id":"XsKfzc","date":"1529851601","viewed":341,"name":"Nuclino","username":"Pr0fed","description":"Just a simple raytraced piece lol. I wonder if this could eventually be an art :D","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = pow(texture(iChannel0, uv), vec4(0.4545));\n    \n\tfragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Set it bigger to less noise and accurate render.\n#define MAX_WEIGHT 150.0\n\n#define MAX_DISTANCE 25.0\n\n#define SAMPLES 10\n#define MAX_BOUNCES 7\n#define NUM_SPHERES 14\n\n#define PI  3.14159265359\n#define PI2 6.28318530717\n\n// Materials\n#define LAMB 0\n#define DIEL 1\n#define EMISSIVE 2\n\n\nconst float GAMMA = 2.2;\n\n///-- Scene Objects -------------------------------------------------------\n\nstruct Material\n{\n\tint type;\n    vec3 albedo;\n    \n    // Refract index for dielectrics.\n    float v; \n};\n    \nstruct Sphere\n{\n\tvec3 c;\n    float r;\n    Material mat;\n};\n  \n// XZ-aligned rect on z distance.\nstruct xzRect\n{\n    float x0;\n    float x1; \n    float z0;\n    float z1;\n    float y;\n    Material mat;\n};\n\n// Just for the sake of simplicity.\nstruct Ray \n{\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct bBox3\n{\n    vec3 pMin;\n    vec3 pMax;\n};\n    \n// Spheres on scene declaration.\nSphere scene[NUM_SPHERES];\n\n\n///-- Helper Functions -----------------------------------------------------\n    \nfloat seed = 0.0;\nvec2 UV = vec2(0.0);\n\nfloat random() \n{\n\treturn fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);\n}\n\n// We use it for ray scattering.\nvec3 randomUnitVector() \n{\n\tfloat theta = random() * PI2;\n    float z = random() * 2.0 - 1.0;\n    float a = sqrt(1.0 - z * z);\n    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);\n    return vector * sqrt(random());\n}\n\n// Shlick's formula for transparent materials like glass.\nfloat schlick(float cosine, float IOR) \n{\n \tfloat r0 = (1.0 - IOR) / (1.0 + IOR);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow(1.0 - cosine, 5.0);\n}\n\nvec2 hash( vec2 x )  \n{\n    const vec2 k = vec2( 0.318653, 0.3673123 );\n    x = x * k + k.yx;\n    return -1.0 + 2.0 * fract( 16.0 * k * fract( x.x * x.y * (x.x + x.y)));\n}\n\n// Simple 2D gradient noise taken from you know where: https://www.shadertoy.com/view/XdXGW8\n// Thx IQ :)\nfloat noise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n// Function uses 3d coordinate to covert them to polar.\n// Usefull to map 2d textures on a sphere.\nvec2 GetSphereUV(vec3 p)\n{\n    float phi = atan(p.z, p.x);\n    float theta = asin(p.y);\n    float u = 1. - (phi + PI) / PI2;\n    float v = (theta + PI / 2.) / PI;\n    \n    return vec2(u, v);\n}\n\n///-- INTERSECT FUNCTIONS -----------------------------------------------------\n\n\n// The point where we intersected something.\nvec3 getHitPoint(Ray ray, float t) \n{\n \treturn ray.origin + t * ray.direction;   \n}\n\n// XZ plane intersection.\nbool xzIntersect(Ray ray, xzRect rect, float tMin, float tMax, out float t)\n{\n    t = (rect.y - ray.origin.y) / ray.direction.y;\n    \n    // Checking for min max clamp.\n    if(t < tMin || t > tMax) return false;\n    \n    float x = ray.origin.x + t * ray.direction.x;\n    float z = ray.origin.z + t * ray.direction.z;\n    \n    // Checking if we are inside rect 2d bounds.\n    if(x < rect.x0 || x > rect.x1 || z < rect.z0 || z > rect.z1) return false;\n    \n    return true;\n}\n\n///-- MAIN FUNCTIONS --------------------------------------------------------\n\n// Ray tracing function.\nbool hitScene(Ray ray, float tMin, float tMax,\n              out vec3 position, out vec3 normal, out Material material, out Sphere sphere)\n{\n    // By default we assume that we are at max distance\n    // and didn't hit anything.\n    float closestSoFar = tMax;\n    bool isHit = false;\n    float t;\n\n    \n    // Upper light panel.\n    xzRect xzrect = xzRect(-2.5, 2.5, -2.5, 2.5, 6.0, Material(EMISSIVE, vec3(1.0), 1.25));\n    if(xzIntersect(ray, xzrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n        \tisHit = true;\n        \tvec3 p = getHitPoint(ray, t);\n            position = p;\n        \tnormal = vec3(0, -1, 0) + randomUnitVector();\n        \tmaterial = xzrect.mat;\n        }\n    }\n    \n    xzrect = xzRect(-2.5, 2.5, -2.5, 2.5, -4.0, Material(EMISSIVE, vec3(1.0), 1.25));\n    if(xzIntersect(ray, xzrect, tMin, tMax, t))\n    {\n        if (t > tMin && t < closestSoFar)\n        {\n            closestSoFar = t;\n        \tisHit = true;\n        \tvec3 p = getHitPoint(ray, t);\n            position = p;\n        \tnormal = vec3(0, 1, 0) + randomUnitVector();\n        \tmaterial = xzrect.mat;\n        }\n    }\n    \n    // Intersection with spheres.\n    // Looping through all, caching the closest 't' point.\n    // which is a distance from ray origin and later used to get hit point.\n    for (int i = 0; i < NUM_SPHERES; i++) \n    {\n        Sphere sphere = scene[i];\n        \n        // Sphere intersection formula.\n        vec3 oc = ray.origin - sphere.c;\n        float a = dot(ray.direction, ray.direction);\n        float b = dot(oc, ray.direction);\n        float c = dot(oc, oc) - sphere.r * sphere.r;\n        float discriminant = b * b - a * c;\n        \n        if (discriminant > 0.0001) \n        {\n            // We only need the closer side of a sphere.\n\t\t\tfloat t = (-b - sqrt(discriminant)) / a;\n            \n            if (t < tMin) \n            {\n                t = (-b + sqrt(discriminant)) / a;\n            }\n            \n            // If we hit sphere, which is closest so far,\n            // we set it to closest, and re-set output\n            // materials and other stuff.\n            if (t > tMin && t < closestSoFar) \n            {\n                closestSoFar = t;\n                isHit = true;\n                \n                vec3 p = getHitPoint(ray, t);\n                position = p;\n                normal = (p - sphere.c) / sphere.r;\n                material = sphere.mat;\n            }\n        }\n    }\n        \n    return isHit;\n}\n\n// Main tracing function.\nvec3 trace(Ray ray, vec2 fragCoord) \n{\n    vec3 normal, position;\n    Material material;\n    Sphere sphere;\n    \n    vec3 color = vec3(1.0);\n    vec3 attenuation = vec3(1.0);\n         \n    // So for each bounce, we try to hit anything\n    // on the scene (spheres only yet), and then we \n    // apply the material of that object to properly\n    // color it. After all (when the bounce hit nothing)\n    // we multiply the rest of attenuation by \"sky\" color.\n    for (int b = 0; b < MAX_BOUNCES; b++) \n    {       \n        if (hitScene(ray, 0.001, MAX_DISTANCE, position, normal, material, sphere)) \n        {\n            // Lambertian material.\n            if (material.type == LAMB) \n            {\n                vec3 direction = normal + randomUnitVector();\n                ray = Ray(position, direction);\n                color *= material.albedo * attenuation;\n                attenuation *= material.albedo;\n            }\n            \n            // Dielectric material.\n            else if (material.type == DIEL)\n            {\n                 vec3 outward_normal;\n                 vec3 reflected = reflect(ray.direction, normal);\n                 float ni_over_nt;\n\n                 vec3 refracted;\n                 \n                 attenuation = vec3(1.0, 1.0, 1.0); \n                \n                 float reflect_prob;\n                 float cosine;\n\n                 if (dot(ray.direction, normal) > 0.) \n                 {\n                      outward_normal = -normal;\n                      ni_over_nt = material.v;\n                      cosine = dot(ray.direction, normal) / length(ray.direction);\n                      cosine = sqrt(1. - material.v * material.v * (1. - cosine * cosine));\n                 }\n                \n                 else \n                 {\n                      outward_normal = normal;\n                      ni_over_nt = 1.0 / material.v;\n                      cosine = -dot(ray.direction, normal) / length(ray.direction);\n                 }\n\n                 refracted = refract(normalize(ray.direction), normalize(outward_normal), ni_over_nt);\n                 if (length(refracted) > 0.0) \n                 {\n                     reflect_prob = schlick(cosine, material.v);\n                 }\n\n\n                 else reflect_prob = 1.0;\n\n                 if (random() < reflect_prob)\n                    ray = Ray(position, reflected);\n\n                 else ray = Ray(position, refracted);\n\n                 color *= material.albedo * attenuation;\n                 attenuation *= color;\n            }\n            \n            // Emissive material.\n            else if (material.type == EMISSIVE )\n            {\n                vec3 direction = normal + randomUnitVector();\n                ray = Ray(ray.origin, ray.direction);\n                color *= material.albedo * material.v;\n               \tattenuation *= color;\n            }\n        }\n        \n        // At the end we mix with \"sky\" color.\n        else \n        {\n            vec3 skyColor = vec3(0.901, 0.674, 0.901) + vec3(0.225) * fragCoord.y;\n            skyColor = pow(skyColor, vec3(GAMMA));\n            color = attenuation * skyColor;\n        }\n    }\n    \n    return color;\n}\n\n///-------------------------------------------------------------------------\n\n// Putting it all somewhere on the scene.\nvoid SceneFill() \n{\n    // Spheres. The second sphere in each pair is made to give that glossy look.\n    scene[0] = Sphere(vec3(-1.0, 1.0, 0.0), 2.0, Material(LAMB, vec3(0.674, 0.901, 0.901), 1.0));\n    scene[1] = Sphere(vec3(-1.0, 1.0, 0.0), 2.02, Material(DIEL, vec3(0.674, 0.901, 0.901),  1.2));\n    \n    scene[2] = Sphere(vec3(-0.75, 1.0, -2.5), 0.75, Material(LAMB, vec3(0.901, 0.674, 0.788), 1.0));\n    scene[3] = Sphere(vec3(-0.75, 1.0, -2.5), 0.752, Material(DIEL, vec3(0.901, 0.674, 0.788), 1.2));\n    \n    scene[4] = Sphere(vec3(0.35, 0.6, -1.8), 0.6, Material(LAMB, vec3(0.674, 0.788, 0.901), 1.0));\n    scene[5] = Sphere(vec3(0.35, 0.6, -1.8), 0.602, Material(DIEL, vec3(0.674, 0.788, 0.901), 1.2));\n    \n    scene[6] = Sphere(vec3(0.3, 0.7, 2.0), 0.4, Material(LAMB, vec3(0.674, 0.901, 0.788), 1.0));\n    scene[7] = Sphere(vec3(0.3, 0.7, 2.0), 0.402, Material(DIEL, vec3(0.674, 0.901, 0.788), 1.2));\n    \n\tscene[8] = Sphere(vec3(-1.4, 2.8, 1.56), 0.4, Material(LAMB, vec3(0.674, 0.901, 0.788), 1.0));\n    scene[9] = Sphere(vec3(-1.4, 2.8, 1.56), 0.402, Material(DIEL, vec3(0.674, 0.901, 0.788), 1.2));\n    \n    scene[10] = Sphere(vec3(-2.15, -1.2, 1.0), 0.75, Material(LAMB, vec3(0.901, 0.674, 0.788), 1.0));\n    scene[11] = Sphere(vec3(-2.15, -1.2, 1.0), 0.752, Material(DIEL, vec3(0.901, 0.674, 0.788), 1.2));\n    \n    scene[12] = Sphere(vec3(-3.15, -2.2, -4.0), 0.6, Material(LAMB, vec3(0.674, 0.901, 0.788), 1.0));\n    scene[13] = Sphere(vec3(-3.15, -2.2, -4.0), 0.602, Material(DIEL, vec3(0.674, 0.901, 0.788), 1.2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Initialization and seed.\n    SceneFill();\n    seed = iTime;\n\n    // Basic normalization.\n    UV = fragCoord / iResolution.xy;\n    vec2 pixelSize = vec2(1.0) / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    // Camera stuff taken from https://www.shadertoy.com/view/ldtSR2.\n    const float fov = 80.0;\n    float halfWidth = tan(radians(fov) * 0.5);\n    float halfHeight = halfWidth / aspect;\n    \n    const float dist = 7.5;\n    vec2 mousePos = iMouse.xy / iResolution.xy;  \n    \n    if (all(equal(mousePos, vec2(0.0)))) \n    {\n        mousePos = vec2(0.62, 0.08); // Default position.\n    }\n    \n    float x = cos(mousePos.x * 10.0) * dist;\n    float z = sin(mousePos.x * 10.0) * dist;\n    float y = mousePos.y * 10.0;\n        \n    vec3 origin = vec3(x, y, z);\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    vec3 upVector = vec3(0.0, 1.0, 0.0);\n    \n    vec3 w = normalize(origin - lookAt);\n    vec3 u = cross(upVector, w);\n    vec3 v = cross(w, u);\n    \n    vec3 lowerLeft = origin - halfWidth * u - halfHeight * v - w;\n    vec3 horizontal = u * halfWidth * 2.0;\n    vec3 vertical = v * halfHeight * 2.0;\n    \n    vec3 color = vec3(0.0);\n    \n    // We add random amount for a better AA. More samples - smoother.\n    for (int s = 0; s < SAMPLES; s++) \n    {        \n     \tvec3 direction = lowerLeft - origin;\n        direction += horizontal * (pixelSize.x * random() + UV.x);\n        direction += vertical * (pixelSize.y * random() + UV.y);\n        color += trace(Ray(origin, direction), UV);\n    }\n    \n    color /= float(SAMPLES);\n       \n    vec3 previousColor = texture(iChannel0, UV).rgb;\n    \n    float weight = min(float(iFrame + 1), float(MAX_WEIGHT));\n    \n    // Resetting weight on mouse change.\n    if (!all(lessThanEqual(iMouse.zw, vec2(0.0)))) \n    {\n        weight = 1.0;\n    }\n    \n    vec3 newColor = mix(previousColor, color, 1.0 / weight);\n    \n    fragColor = vec4(newColor, 1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}