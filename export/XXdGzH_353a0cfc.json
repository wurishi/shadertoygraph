{"ver":"0.1","info":{"id":"XXdGzH","date":"1716094291","viewed":39,"name":"Heat Equation Hayden","username":"HaydenS","description":"2D Heat Equation solved for with convolution matrix for Laplacian.\nClick to add heat.\n","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["simple","interactive","pde","heatequation","partialdifferentialequation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n// RENDER IN FANCY COLORS\nvec3 blueRed( in float t )\n{\n\n    // blue red palette\n    vec3 a = vec3(0.660, 0.560, 0.680);\n    vec3 b = vec3(0.718, 0.438, 0.520);\n    vec3 c = vec3(0.520, 0.800, 0.520);\n    vec3 d = vec3(-0.430, -0.397, -0.083);\n\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 inferno(float t) {\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvec4 heatColor( in vec4 redFragColor ) {\n    vec4 heatColor;\n    \n    float redHeat = redFragColor.r;\n    \n    vec3 color = inferno(redHeat);\n    \n    heatColor = vec4(color, 1.0);\n    \n    return heatColor;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get frame data from buffer A\n    \n    vec4 frameData = texture(iChannel0, uv);\n    \n    vec4 redFragColor = vec4(frameData.rgb, 1.0);\n    \n    fragColor = heatColor(redFragColor);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 convolute(in mat3 filterKernel, in float divisionScalar , in vec2 uvCoord){\n        \n    // Offset for the neighboring pixels\n    float Xoffset = 1.0 / iResolution.x;\n    float Yoffset = 1.0 / iResolution.y;\n    \n    vec3 colorSum = vec3(0.0);\n    \n    // Loop over the kernel\n    for (int i = -1; i <= 1; i++) {\n        for (int j = -1; j <= 1; j++) {\n            vec2 offsetCoord = uvCoord + vec2(float(i) * Xoffset, float(j) * Yoffset);\n            vec3 pixelColorAtCoord = texture(iChannel0, offsetCoord).rgb;\n            float scalar = float(filterKernel[i+1][j+1]);\n            \n            vec3 addend = pixelColorAtCoord*scalar;\n            colorSum += addend;\n            \n        }\n    }\n\n    // Average the sum\n    vec3 color = colorSum / divisionScalar;\n    \n    return color;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // get previousData\n    vec4 previousFrameData = texture(iChannel0,uv);\n    \n    \n    // Initial Condition\n    if(iFrame == 0) {\n        \n        fragColor = initialize(uv, iResolution);\n        \n        return;\n    }\n    \n    // Find color of next frame\n\n    // set filer kernel here\n    \n    vec3 color = previousFrameData.rgb + lambda*convolute(laplacian, divisionFactor, uv);\n\n    // Add Heat at mouse hold\n\n    float mouseDistance = pow(iMouse.x - fragCoord.x, 2.0) + pow(iMouse.y - fragCoord.y, 2.0);\n\n    if( mouseDistance < 14.0 && iMouse.z > 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n\n    \n    \n    fragColor = vec4(color, 1.0);\n\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n// CONFIGURABLES\n\n// Laplacian Kernel\n\nmat3 laplacian = mat3(\n    1.0, 4.0, 1.0,\n    4.0, -20.0, 4.0,\n    1.0, 4.0, 1.0\n);\n\nfloat divisionFactor = 6.0;\n\n// Diffusion Factor\n// This can affect the stability of the simulation\n\nfloat lambda = 0.1;\n\n//Initial Condition\n\nvec4 initialize(in vec2 uvCoord, in vec3 resolution) {\n    \n    // aspect ratio\n    \n    uvCoord.x *= resolution.x / resolution.y;\n    \n    vec4 fragColor;\n\n    //PRESETS\n    \n    #define Annulus\n    //#define Half\n\n    #ifdef Annulus\n        float radius = (uvCoord.y-0.5)*(uvCoord.y-0.5) + (uvCoord.x-0.88)*(uvCoord.x-0.88);\n        bool condition = radius < 0.1 && radius > 0.05;\n    #endif\n    #ifdef Half\n        bool condition = uvCoord.y < 0.5;\n    #endif\n    \n    if (condition) {\n        fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    \n            \n    return fragColor;\n}\n","name":"Common","description":"","type":"common"}]}