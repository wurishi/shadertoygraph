{"ver":"0.1","info":{"id":"sd2BDm","date":"1646462064","viewed":78,"name":"ball_phongRender","username":"xuxu1702","description":"ball_phongRender","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20.0;\nconst float EPSILON = 0.0001;\n\n/**\n * 从摄像机eye中心位于centerPoint半径为radiance的球体的符号距离函数定义\n */\nfloat ballDist(vec3 centerPoint,vec3 eye,float radiance){\n    return length(centerPoint-eye) - radiance;\n\n}\n\n/**\n * 返回最短距离函数\n * eye: 射线的起点，可理解为相机\n * marchingDirection: 射线的标准化方向向量\n * start: 从相机开始的最短距离\n * end: 最远距离\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist=ballDist(vec3(0.,0.,0.),eye + depth * marchingDirection,1.0);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * 返回相机的标准化方向向量\n * fieldOfView: 垂直视野的角度\n * size: 输出图像的分辨率\n * fragCoord: 输出图像中的像素坐标\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //基础变量\n    vec3 vDir = rayDirection(45.0, iResolution.xy, fragCoord);//视线方向,指向物体\n    vec3 camPos = vec3(0.0, 0.0,10.0);//相机位置\n    vec3 lPos=vec3(10.0,10.0,10.0);//光源位置\n    vec3 d_col=vec3(0.5,0.6,0.7);//漫反射颜色\n    vec3 a_col=vec3(0.1,0.0,0.0);//环境颜色\n    //运动与变换\n    float cam_rotate=iTime;\n    mat4 trans_rotate=mat4(cos(cam_rotate),0.,sin(cam_rotate),0.0,\n                            0.0,1.0,0.0,0.0,\n                            -sin(cam_rotate),0.,cos(cam_rotate),0.,\n                            0.0,0.0,0.0,1.0\n    );\n    vDir=(trans_rotate*vec4(vDir,1.0)).xyz;\n    camPos=(trans_rotate*vec4(camPos,0.0)).xyz;\n    //计算过程向量\n    float dist = shortestDistanceToSurface(camPos, vDir, MIN_DIST, MAX_DIST);//和相机距离\n    if (dist > MAX_DIST - EPSILON) {//没有物体的像素颜色变为黑色\n        vec3 col = vec3(0.0, 0.0, 0.0);\n        fragColor = vec4(col, 1.0);\n\t\treturn;\n    }\n    vec3 p=camPos+vDir*dist;//看到的物体上的点\n    vec3 nDir=p-vec3(0.,0.,0.);\n    vec3 lDir=normalize(lPos-p);//光方向，指向光源\n    vec3 lrDir=normalize(reflect(lDir,nDir));//反射光方向\n    //着色模型\n    float lambert=clamp(dot(nDir,lDir),0.0,1.0);\n    float phong=pow(dot(-lrDir,-vDir),50.0);\n    phong=clamp(phong,0.01,1.0);\n    vec3 diffuse=lambert*d_col;//漫反射光\n\n    vec3 col=vec3(diffuse+phong)+a_col;\n \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}