{"ver":"0.1","info":{"id":"WdSSRt","date":"1554627491","viewed":147,"name":"evankh_PRNG","username":"evankh","description":"Implements a public-domain PseudoRandom Number Generator, seeded by pixel location.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Implements xorshift64** PRNG by David Blackman and Sebastiano Vigna (2018)\n// http://xoshiro.di.unimi.it/xoroshiro64starstar.c\n\nuint state[2];\n\nuint rot(uint x, int k) {\n    return (x << k) | (x >> (32 - k));\n}\n\nfloat noise() {\n    uint s0 = state[0];\n    uint s1 = state[1];\n    uint result = rot(s0 * 0x9e3779bbu, 5) * 5u;\n    s1 ^= s0;\n    state[0] = rot(s0, 26) ^ s1 ^ (s1 << 9);\n    state[1] = rot(s1, 13);\n    // Not sure this is actually the best way to get evenly-distributed floats -\n    // precision will be lost converting from int to float, but how much depends on the order of magnitude\n    // I could use bit magic to build the bits of a float directly, then use uintBitsToFloat,\n    // but that also loses precision - just in a different way.\n    // I guess precision loss is inevitable, since if we want floats in the range 0.0 <= r <= 1.0 then\n    // there's only so many bits to work with. It's just a matter of how they're distributed.\n    return float(result) / float(0xffffffffu);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Seed the PRNG with the pixel location\n    vec2 uv = fragCoord/iResolution.xy;\n    // Not sure if it's my imagination but using pixel location directly seems to result in artifacts\n    // Taking the inverse seems to remove them nicely\n    state[0] = floatBitsToUint(uv.x);\n    state[1] = floatBitsToUint(uv.y);\n    // Necessary to shuffle the y-coordinate into the first slot,\n    // and to scramble the x-coordinate\n    // Shuffling twice is enough to remove artifacts caused by using fragCoord instead of uv\n    noise();\n\n    // Draw noise color\n    vec3 col = vec3(noise(), noise(), noise());\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}