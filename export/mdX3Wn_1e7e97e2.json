{"ver":"0.1","info":{"id":"mdX3Wn","date":"1666452132","viewed":756,"name":"just a cornell box :)","username":"Poisson","description":"A simple pathtracer with reflection, refraction, lights and bloom.","likes":49,"published":1,"flags":32,"usePreview":1,"tags":["3d","raytracing","reflection","raytracer","ray","refraction","cornellbox","glass","bloom","glow","pathtracing","pathtracer","box","cornell","montecarlo","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// iChannel0: image\n// iChannel1: blurred image\n\n#define BLOOM\n//#define SEPIA // old photograph style\n\nvec3 filmic(vec3 x) {\n    float a = 2.51;\n    float b =  .03;\n    float c = 2.1;\n    float d =  .7;\n    float e =  .12;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 data = texture(iChannel0, uv);\n    vec3 col = data.rgb/data.w;\n    \n    // post-processing effects\n    col = pow(col, vec3(.4545)); // gamma correction\n    col = 2.*col/(1.+col);\n        \n    // bloom (glow)\n    #ifdef BLOOM\n    vec4 blur = texture(iChannel1, uv);\n    vec3 bloom = blur.rgb / blur.w;\n    col += .5*bloom;\n    #endif\n        \n    // sepia color\n    #ifdef SEPIA\n    col = vec3(1)*dot(col,vec3(1))/3.;\n    col = col*vec3(1.5,1.2,1)-vec3(.25,.125,.05);\n    col = col*1.1-.05; // contrast\n    col = round(col*24.)/24.; // posterise\n    col *= 1.+.2*texture(iChannel2, uv*.4).rgb; // noise\n    #endif\n    \n    // output\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.141592\n#define TAU 6.283185\n#define PATH_LENGTH 12 // max ray bounces\n#define MAX_FLOAT 1e10 // just a big number\n#define SAMPLES 16 // antialiasing\n\n// 0 - basic noisy render\n// 1 - improved version\n\n#define SAMPLING_METHOD 1\n\n// hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nuint uhash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat seed;\n\nfloat hash1(inout float seed) {\n    uint n = uhash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = uhash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = uhash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n// rotation function\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// intersection functions by iq\n// https://iquilezles.org/articles/intersectors/\n\n// sphere intersection\nfloat iSphere(vec3 ro, vec3 rd, vec3 p, float r, int id, float tmax, \n              inout vec3 outn, inout int outid) {\n    vec3 oc = ro - p;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r*r;\n    float h = b*b - c;\n    if (h<0.) return MAX_FLOAT;\n\n\th = sqrt(h);\n\tfloat t1 = -b - h;\n\tfloat t2 = -b + h;\n\t\n\tfloat t = t1<.0001 ? t2 : t1;\n    if (t<tmax && t>.0001) {\n        outn = normalize(oc + rd * t);\n        outid = id;\n\t    return t;\n    }\n    return MAX_FLOAT;\n}\n\n// plane intersection\nfloat iPlane(vec3 ro, vec3 rd, vec3 n, float h, int id, float tmax, \n             inout vec3 outn, inout int outid) {\n    float t = (h - dot(ro, n)) / dot(rd, n);\n    \n    if (t<tmax && t>.0001) {\n        outn = n;\n        outid = id;\n        return t;\n    }\n    return MAX_FLOAT;\n}\n\n// box intersection\nfloat iBox(vec3 ro, vec3 rd, vec3 p, vec3 s, vec2 a, int id, float tmax, \n           inout vec3 outn, inout int outid) {\n    vec3 oc = ro - p;\n    \n    // rotate the box\n    oc.yz *= rot(a.y);\n    oc.xz *= rot(a.x);\n    rd.yz *= rot(a.y);\n    rd.xz *= rot(a.x);\n    \n    vec3 m = 1./rd;\n    vec3 n = m*oc;\n    vec3 k = abs(m)*s;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max(max(t1.x, t1.y), t1.z);\n\tfloat tF = min(min(t2.x, t2.y), t2.z);\n\t\n\tif(tN>tF || tF<0.) return MAX_FLOAT;\n    \n    float t = tN<.0001 ? tF : tN;\n    if (t<tmax && t>.0001) {\n\t\toutn = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        outid = id;\n\t    return t;\n    }\n    return MAX_FLOAT;\n}\n\n#define LIGHT_YELLOW 0\n#define LIGHT_BLUE 1\n#define LIGHT_PINK 2\n#define LIGHT_GREEN 3\n#define LIGHT_PURPLE 4\n#define WHITE 5\n#define BLUE 6\n#define RED 7\n#define METAL 8\n#define TRANSPARENT 9\n\n// intersect the scene\nfloat intersect(vec3 ro, vec3 rd, out vec3 n, out int id) {\n    float t = MAX_FLOAT;\n    \n    // bounding box of lights\n    float b = iBox(ro, rd, vec3(0,1,0), vec3(.9,0,.9), vec2(0), WHITE, t, n, id);\n    \n    // y planes\n    t = min(t, iBox(ro, rd, vec3(0,1,0), vec3(1,0,1), vec2(0), WHITE, t, n, id));\n    t = min(t, iBox(ro, rd, vec3(0,-1,0), vec3(1,0,1), vec2(0), WHITE, t, n, id));\n    \n    // x planes\n    t = min(t, iBox(ro, rd, vec3(1,0,0), vec3(0,1,1), vec2(0), BLUE, t, n, id));\n    t = min(t, iBox(ro, rd, vec3(-1,0,0), vec3(0,1,1), vec2(0), RED, t, n, id));\n    \n    // z plane\n    t = min(t, iBox(ro, rd, vec3(0,0,1), vec3(1,1,0), vec2(0), WHITE, t, n, id));\n    \n    // ceilling lights\n    if (b<MAX_FLOAT) {\n        float R = 1./3.; // third\n        vec3 c = vec3(1.-R,.999,1.-R); // center of lights\n        vec3 s = vec3(R,0,R); // size of lights\n        vec2 a = vec2(.3*PI,0); // angle of lights\n        \n        t = min(t, iBox(ro, rd, c, s, a, LIGHT_PURPLE, t, n, id));\n        t = min(t, iBox(ro, rd, c*vec3(-1,1,1), s, a, LIGHT_BLUE, t, n, id));\n        t = min(t, iBox(ro, rd, c*vec3(-1,1,-1), s, a, LIGHT_PINK, t, n, id));\n        t = min(t, iBox(ro, rd, c*vec3(1,1,-1), s, a, LIGHT_GREEN, t, n, id));\n        t = min(t, iBox(ro, rd, c*vec3(0,1,0), s, a, LIGHT_YELLOW, t, n, id));\n    }\n    \n    // spheres\n    t = min(t, iSphere(ro, rd, vec3(.4,-.6,0), .4, METAL, t, n, id));\n    t = min(t, iSphere(ro, rd, vec3(-.5,-.7,0), .3, TRANSPARENT, t, n, id));\n    \n    // mirror\n    t = min(t, iBox(ro, rd, vec3(.99,-.3,-.3), vec3(.01,.5,.5), vec2(0), METAL, t, n, id));\n    \n    // light sphere\n    t = min(t, iSphere(ro, rd, vec3(.4,-.7,.5), .3, LIGHT_YELLOW, t, n, id));\n          \n    return t;\n}\n\n// diffuse ray BRDF\nvec3 cosineDirection(vec3 n) {\n  \tvec2 r = hash2(seed);\n    \n\tvec3 uu = normalize(cross(n, vec3(0,1,1)));\n\tvec3 vv = cross(uu, n);\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(TAU*r.x); \n\tfloat ry = ra*sin(TAU*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\treturn normalize(rx*uu + ry*vv + rz*n);\n}\n\n// refracted ray BRDF\nvec3 refraction(vec3 rd, vec3 n, float ior) {\n    float fre = dot(rd, n);\n    float k;\n    if (fre>0.) {\n        k = sqrt(1.-ior*ior*(1.-fre*fre));\n    } else {\n        k = -fre;\n    }\n    float s = sign(fre);\n    vec3 m = -n*s;\n    float v = (.5-.5*s)/ior+ior*(.5+.5*s);\n    \n    fre = dot(rd, m);\n    float h = 1.-v*v*(1.-fre*fre);\n    float refProb;\n    vec3 refr;\n    if (h>0.) {\n        h = sqrt(h);\n        refr = v*(rd - m*fre) - m*h;\n        float r0 = (1.-ior)/(1.+ior);\n        r0 = r0*r0;\n        refProb = r0 + (1.-r0)*pow((1.-k),5.);\n    } else {\n        refProb = 1.;\n    }\n        \n    return hash1(seed)<refProb ? reflect(rd, n) : refr;\n}\n\n// rendering function\nvec3 render(vec3 ro, vec3 rd) {\n    vec3 col = vec3(1);\n    \n    // pathtrace\n    for (int i=0; i<PATH_LENGTH; i++) {\n        vec3 n;\n        int id;\n        float t = intersect(ro, rd, n, id);\n    \tif (t<MAX_FLOAT) {\n            ro += rd*t; // move the ray\n            \n            vec3 dif;\n            if (id == LIGHT_YELLOW) {\n                return col*vec3(1,.5,.3);\n            } else if (id == LIGHT_BLUE) {\n                return col*vec3(.3,.5,1);\n            } else if (id == LIGHT_PINK) {\n                return col*vec3(1,.3,.5);\n            } else if (id == LIGHT_GREEN) {\n                return col*vec3(.5,1,.3);\n            } else if (id == LIGHT_PURPLE) {\n                return col*vec3(.5,.3,1);\n            } else if (id == WHITE) {\n                dif = vec3(1);\n                rd = cosineDirection(n);\n            } else if (id == BLUE) {\n                dif = vec3(.05,.05,1);\n                rd = cosineDirection(n);\n            } else if (id == RED) {\n                dif = vec3(1,.05,.05);\n                rd = cosineDirection(n);\n            } else if (id == METAL) {\n                dif = vec3(1);\n                rd = reflect(rd, n);\n            } else if (id == TRANSPARENT) {\n                dif = vec3(1);\n                rd = refraction(rd, n, 2.4);\n            }\n            col *= dif;\n\t    } else {\n            return vec3(0); // background\n    \t}\n    }\n    return vec3(0); // return black if the ray stop\n}\n\n// simple camera system\nvec3 setCamera(vec2 p, vec3 ro, vec3 ta, float z) {\n    vec3 w = normalize(ta - ro);\n    vec3 u = normalize(cross(vec3(0,1,0), w));\n    vec3 v = cross(w, u);\n    \n    return normalize(w*z + p.x*u + p.y*v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 tot = vec3(0);\n    for (int i=0; i<SAMPLES; i++) {\n        #if SAMPLING_METHOD == 0\n        // basic noisy render\n        seed = float(uhash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime+float(i);\n        #else\n        // improved version\n        // the seed does not depend on the pixel coordinates\n        seed = iTime+float(i);\n        #endif\n                \n        vec2 o = hash2(seed)-.5;\n        vec2 p = (fragCoord+o - .5*iResolution.xy) / iResolution.y;\n        \n        vec3 ro = vec3(0,0,-3);\n        vec3 ta = vec3(0);\n        \n        vec3 rd = setCamera(p, ro, ta, 1.);\n\n        vec3 col = render(ro, rd);    \n        tot += col;\n    }\n    tot /= float(SAMPLES);\n    \n    // output\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    data += vec4(tot,1);\n    \n    fragColor = data;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 col = vec4(0);\n    for(int i=-2; i<=2; i++) {\n    for(int j=-2; j<=2; j++) {\n\t\tcol += texture(iChannel0, uv+vec2(i,j)*2./iResolution.xy);\n    }\n    }\n    col /= 25.;\n    \n\tfragColor = col;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 col = vec4(0);\n    for(int i=-2; i<=2; i++) {\n    for(int j=-2; j<=2; j++) {\n\t\tcol += texture(iChannel0, uv+vec2(i,j)*4./iResolution.xy);\n    }\n    }\n    col /= 25.;\n    \n\tfragColor = col;\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec4 col = vec4(0);\n    for(int i=-2; i<=2; i++) {\n    for(int j=-2; j<=2; j++) {\n\t\tcol += texture(iChannel0, uv+vec2(i,j)*8./iResolution.xy);\n    }\n    }\n    col /= 25.;\n    \n\tfragColor = col;\n}","name":"Buffer D","description":"","type":"buffer"}]}