{"ver":"0.1","info":{"id":"lfccD2","date":"1731258914","viewed":238,"name":"JosLeysKleinian_UX","username":"kosalos","description":"ray marching fractal\n","likes":10,"published":3,"flags":48,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"4fcyRB","parentname":"SolarFlare_UX"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nThis sketch has two phases:\n1. User Interface mode, where you alter the fractal parameters via the arrows keys and the mouse.\n   At any time you can capture the settings and save them in the source code as keyframes.\n2. Keyframe display mode, where the settings are interpolated between the keyframes.\n\nUserInterface mode:\nEnable \"#define USER_INTERFACE\" at the top of the Common tab.\nThe interface is described just below.\nNote the color bar drawn at screen bottom (when settings are displayed).\nFollow the instructions in the \"Console Transmit\" sketch:   https://www.shadertoy.com/view/4XVGR3\nto acquire the settings to raw text you can add to the keyframe array storage (Common tab, line #52).\nA little tedious, but I don't know of any other way to get the settings out of the shader.\n\nOption #2: width a small dataset such as this fractal I just type in values by hand.\n\n\nKeyframe display mode:\nComment out \"#define USER_INTERFACE\" at the top of the Common tab.\nNo user interface except: click the mouse on left/right 95% side of the screen to disable/enable cross eyed stereo.\nThe speed of keyframe transistion is set via the \"iFramesPerKeyFrame\" on line 416 of this tab.\n\nHope you find this technique useful in your experiments.\n\nJos leys' Kleinian:\nhttps://www.shadertoy.com/view/lstyR4\nhttps://www.shadertoy.com/view/Ns2fzy\n\n*/\n\n/* USER_INTERFACE -----------------------\nKey Commands:\n<Up,Dn Arrows> : select widget focus. PgUp,PgDn hop by 5 entries.\n<Lt,Rt Arrows> : alter value of focused widget\n<0>   : focused value -> 0.0\n<1> ... <9>   load keyFrame dataset 0 ... 8\n<Spc> : reset\n\nNote: hold down <Shift> then drag mouse to affect camera.xy regardless of focus.\nNote: hold down <Alt><Shift> then drag mouse to affect aim.xy regardless of focus.\n\nDrag mouse on X axis to alter focused widget value.\nNote: mouse X affects focused value, mouse Y affects next entry\n\nAccelerated changes while holding down arrow keys or moving the mouse:\nHold down <A> for change Amount * 0.1\nHold down <Z> for change Amount * 10.\nHold down both <A><Z> for change Amount * 50.\n\nClick the mouse on left/right side of the screen to disable/enable cross eyed stereo.\n\n*/\n\n// --------------------------------------------------------------------\n// given 0..1, output ease in/out rendition 0..1\n// https://stackoverflow.com/questions/13462001/ease-in-and-ease-out-animation-formula\n\nfloat parametricBlend(float ratio) {\n\tfloat sqt = ratio * ratio;\n\treturn sqt / (2.0 * (sqt - ratio) + 1.);\n}\n\nfloat bezierBlend(float ratio) {\n\treturn ratio * ratio * (3. - 2. * ratio);\n}\n\nfloat parabolicBlend(float ratio) {\n\tfloat y = 2. * ratio * ratio;\n\n\tif (ratio > 0.5) {\n\t\tratio -= 1.;\n\t\ty = -2. * ratio * ratio + 1.;\n\t}\n\n\treturn y;\n}\n\nvoid loadKeyFrame(int keyFrameIndex,float mixRatio) {\n    int index1 = keyFrameIndex * keyframeEntryLength;\n    int index2 = ((keyFrameIndex+1) % keyFrameCount) * keyframeEntryLength;\n\n    float r = parametricBlend(mixRatio);\n    \n    for(int i=0;i<QSIZE;++i)   // vec4 q[] index\n        for(int j=0;j<4;++j)   // x,y,z,w field index\n            q[i][j] = mix(keyFrame[index1++],keyFrame[index2++],r);\n}\n\n// --------------------------------------------------------\n\n#define CRYSTAL_EFFECT\n\nconst int maxSteps = 2;\nconst float epsilon = 0.0001;\nconst float fogDistance =  -1.5; // set to 0.0 to disable fog\nconst float fogAmount = 0.12;\nconst float fogColor = 0.32;\n    \nconst float parallax = 0.02; // use smaller values when viewing closeup objects\n\nfloat ambient,contrast,vibrant,dim;\nfloat Ostrength; // 0.0 -> disable orbit trapping\nfloat Ocycle;\nfloat OXwt,OXcr; // weight, color code\nfloat OYwt,OYcr;\nfloat OZwt,OZcr;\nfloat OWwt,OWcr;\nvec3  Ocenter;   // origin offset\n\n// calculated params\nvec3 direction;\nvec3 normal;\nvec3 position;\nvec3 color;\nfloat depth;\nint iter;\nvec4 orbitTrap;\n\nint focus,row,displayCount;\nbool stereoEnable;\nvec3 viewVector,sideVector,topVector;\n\n// --------------------------------------------------------\n\nfloat dot2(vec3 z) { return dot(z,z);}\n\nvec3 wrap(vec3 x, vec3 a, vec3 s) {\n    x -= s;\n    return (x-a*floor(x/a)) + s;\n}\n\nvec2 wrap(vec2 x, vec2 a, vec2 s) {\n    x -= s;\n    return (x-a*floor(x/a)) + s;\n}\n\nvoid TransA(inout vec3 z, inout float DF, float a, float b) {\n    float iR = 1. / dot2(z);\n    z *= -iR;\n    z.x = -b - z.x;\n    z.y =  a + z.y;\n    DF *= iR;\n}\n\nfloat DE(vec3 z) {\n    vec3 lz = z + vec3(1.);\n    vec3 llz = z + vec3(-1.);\n    float DE = 1e10;\n    float DF = 1.0;\n    float a = qkleinR, b = qkleinI;\n    float f = sign(b);\n    vec3 ot;\n\n    orbitTrap = vec4(10000.);\n\n    for (int i = 0; i < 100; ++i)    {\n        if(i >= int(qbiter)) break;\n\n        z.x = z.x + b/a * z.y;\n        z.xz = wrap(z.xz, vec2(2. * qbox.x, 2. * qbox.y), vec2(-qbox.x, -qbox.y));\n        z.x = z.x - b/a * z.y;\n        \n        if(z.y >= a * (0.5 +  f * 0.25 * sign(z.x + b * 0.5)* (1. - exp( - 3.2 * abs(z.x + b * 0.5)))))\n            z = vec3(-b, a, 0.) - z;\n        \n        TransA(z, DF, a, b);\n        \n        if(dot2(z-llz) < 1e-12) break;\n        \n        llz=lz; lz=z;\n    \n        ot = z.xyz - orbit4;\n        orbitTrap = min(orbitTrap, vec4(abs(ot), dot(ot,ot)));\n    }\n    \n    for (int i = 0; i < 100; ++i)    {\n        if(i >= int(qfiter)) break;\n        \n        float y = min(z.y, a-z.y);\n        DE = min(DE,min(y,qclampy) / max(DF,qclampdf));\n        TransA(z, DF, a, b);\n    }\n    \n    float y = min(z.y, a-z.y);\n    return min(DE,min(y,qclampy) / max(DF,qclampdf));\n}\n\n// --------------------------------------------------------\n\nvec3 generateColor(float weight,float x) {\n    if(weight == 0.0) return vec3(0.0);\n\n    x = cos(x);\n    //x=abs(sin(x)); // limits colors\n\n    // bezier, you can rearange the functions for different color combos but this one is best\n    float r = (1.0-x)*(1.0-x);\n    float g = x*x;\n    float b = 2.0*(1.0-x)*x;\n    return vec3(r,g,b);\n}\n\nvec3 orbitTrapCycle(float cycle,vec3 c, float s) {\n    float ss = s * cycle;\n    return vec3(0.5) + 0.5 * vec3( cos(ss + c.x), cos(ss + c.y), cos(ss + c.z));\n}\n\nvec3 getOrbitColor() {\n    vec3 orbitColor;\n    \n    if (Ocycle > 0.0) {\n        orbitColor =\n        orbitTrapCycle(Ocycle,generateColor(OXwt,OXcr), orbitTrap.x) * OXwt * orbitTrap.x +\n        orbitTrapCycle(Ocycle,generateColor(OYwt,OYcr), orbitTrap.y) * OYwt * orbitTrap.y +\n        orbitTrapCycle(Ocycle,generateColor(OZwt,OZcr), orbitTrap.z) * OZwt * orbitTrap.z +\n        orbitTrapCycle(Ocycle,generateColor(OWwt,OWcr), orbitTrap.w) * OWwt * orbitTrap.w;\n    } else {\n        orbitColor =\n            generateColor(OXwt,OXcr) * OXwt * orbitTrap.x +\n            generateColor(OYwt,OYcr) * OYwt * orbitTrap.y +\n            generateColor(OZwt,OZcr) * OZwt * orbitTrap.z +\n            generateColor(OWwt,OWcr) * OWwt * orbitTrap.w;\n    }\n    \n    return orbitColor;\n}\n\n// --------------------------------------------------------\n// phongParam = diffuse,spec,ambient\n\nvoid phongLight() {\n    vec3 L = normalize(phongPosition - position);\n    float dotLN = dot(L, normal);\n    if (dotLN < 0.) return;\n        \n    float t1 = phongParam.x * dotLN;\n    vec3 V = normalize(qcamera.xyz - position);\n    vec3 R = normalize(reflect(-L, normal));\n    float dotRV = dot(R, V);\n\n    if (dotRV < 0.0) {\n        color += phongColor * t1;\n        return;\n    }\n\n    float t2 = phongParam.y * pow(abs(dotRV), phongParam.z);\n    color += phongColor * (t1 + t2);\n}\n\n// spotLightParam = strength,x,y,exp\nconst float PI = acos(-1.);\n\nvoid spotLight() {\n    float a1 = spotLightParam.y * PI;\n    float a2 = spotLightParam.z * PI * 0.5;\n    float s1 = sin(a1);\n    vec3 spotDir = normalize(vec3(s1 * cos(a2), s1 * sin(a2), cos(a1)));\n    vec3 halfVector = normalize(spotDir - direction);\n\n    float nDotL = max(0., dot(normal, spotDir));\n    float hDotN = max(0., dot(normal, halfVector));\n\n    vec3 c = spotLightColor;// * spotLightParam.x;\n    float sexp = spotLightParam.w;\n\n    color += c * ((sexp + 2.) / 2.) * pow(hDotN, sexp)\n        * (sexp + (1. - sexp) * pow(1. - hDotN, 5.)) * nDotL * spotLightParam.x;\n}\n\n#define animate(v,v1,v2,speed) v = mix(v1,v2,0.5 + sin(iTime * speed) * 0.5)\n#define animate2(v,base,delta,speed) v = mix(base-delta,base+delta,0.5 + sin(iTime * speed) * 0.5)\n#define animate3(v,base,delta,speed) v = mix(base - base*delta,base + base*delta,0.5 + sin(iTime * speed) * 0.5)\n\nvoid lighting() {\n    animate2(phongParam.x,0.2,0.3,0.3);\n    animate2(phongParam.y,0.,0.1,0.35);\n    animate2(phongParam.z,8.,2.,0.4);\n    animate2(phongColor.x,0.5,0.5,0.3);\n    animate2(phongColor.y,0.5,0.5,0.7);\n    animate2(phongColor.z,0.5,0.5,0.9);\n    animate2(phongPosition.x,0.,2.,0.01);\n    animate2(phongPosition.y,0.,2.,0.05);\n    animate2(phongPosition.z,-5.,2.,0.07);\n\n    animate2(spotLightParam.x,1.,0.5,0.3);\n    animate2(spotLightParam.y,0.,1.5,0.03);\n    animate2(spotLightParam.z,0.,1.5,0.035);\n    animate2(spotLightParam.w,0.7,0.2,0.4);\n    animate2(spotLightColor.x,0.5,0.5,0.1);\n    animate2(spotLightColor.y,0.5,0.5,0.2);\n    animate2(spotLightColor.z,0.5,0.5,0.4);\n\n    animate(ostrength,0.,0.062,0.1);\n    animate(ocycle,0.,3.,0.18);\n    animate(orbit2.x,-0.,3.,0.011);  // X wt,color\n    animate(orbit2.y,-3.,3.,0.013);\n    animate(orbit2.z,-0.,3.,0.015);  // Y wt,color\n    animate(orbit2.w,-3.,3.,0.017);\n    animate(orbit3.x,-0.,3.,0.019);  // Z wt,color\n    animate(orbit3.y,-3.,3.,0.021);\n    animate(orbit4.x,-3.,3.,0.023);  // center\n    animate(orbit4.y,-3.,3.,0.025);\n    animate(orbit4.z,-3.,3.,0.027);\n\n    color += vec3(ambient) + vec3(1.0 - (normal * vibrant + sqrt(float(iter) * dim)));\n    color = vec3(0.5) + (color - vec3(0.5)) * contrast;\n\n    phongLight();\n    spotLight();\n    \n    if(ostrength > 0.0) {\n        vec3 oColor = getOrbitColor();\n        color = mix(color, oColor, ostrength);\n    }\n}\n\n// --------------------------------------------------------\nconst float MIN_DIST = 0.001;\nconst float MAX_DIST = 25.0;\nconst float EPSILON = 0.0001; \n\nvoid rayMarch() {\n    float distance;\n    position = qcamera.xyz;\n    iter = 0;\n    depth = MIN_DIST;\n    \n    orbitTrap = vec4(10000.);\n    \n    for(int i = 0;i < 50;++i) {\n        distance = DE(position);\n        if(abs(distance) < EPSILON || depth > MAX_DIST) break;\n        iter += 1;\n        \n        depth += distance;\n        position += direction * distance;\n    }\n}\n\n// --------------------------------------------------------\n// https://iquilezles.org/articles/normalsSDF\nvoid calcNormal() {\n    float d0 = DE(position);\n    const vec2 epsilon = vec2(.001,0);\n    vec3 d1 = vec3(\n        DE(position-epsilon.xyy),\n        DE(position-epsilon.yxy),\n        DE(position-epsilon.yyx));\n    normal = normalize(d0 - d1);\n}\n\n// --------------------------------------------------------\n// viewVectors already calculated in Buffer A\n\nvoid setDirection(vec2 fragCoord) {\n    // cross eyed stereo ------------------------------------\n    vec2 srcP = fragCoord;        // copy of pixel coordinate; x is altered for stereo\n    float xsize = iResolution.x;  // copy of window size; x is altered for stereo\n    \n    if(stereoEnable) {\n        vec3 soffset = sideVector * parallax;\n        xsize *= 0.5;             // window x size adjusted for 2 views side by side\n        if(srcP.x >= xsize) {     // right side of stereo pair?\n            srcP.x -= xsize;      // base 0  X coordinate\n            qcamera.xyz -= soffset;// adjust for right side parallax\n        }\n        else {\n            qcamera.xyz += soffset;// adjust for left side parallax\n        }\n    }\n    \n    vec2 vPos = (srcP - iResolution.xy * 0.5)/iResolution.y;\n    direction = normalize(viewVector + vPos.x * sideVector + vPos.y * topVector);\n}\n\n#ifdef USER_INTERFACE // ==========================================\n\nvoid loadDEParams() {\n    for(int i=0;i<QSIZE;++i)\n       q[i] = fetchData(iChannel0, storeAddr[i]);\n    \n    vec3 sd = fetchData(iChannel0, FOCUS_ADDR).xyz;\n    focus = int(sd.x);\n    displayCount = int(sd.y);\n\n    sd = fetchData(iChannel0, UNIFORM_1).xyz;\n    stereoEnable = bool(sd.x > 0.);\n\n    viewVector = fetchData(iChannel0, VV_1).xyz;\n    sideVector = fetchData(iChannel0, VV_2).xyz;\n    topVector = fetchData(iChannel0, VV_3).xyz;\n}\n\n#else // ==========================================================\n\nconst int iFramesPerKeyFrame = 300;  // # image frames between keyframes (for me: 30 == 1 second)\n\nvoid loadDEParams() {\n    int keyFrameIndex = (iFrame/iFramesPerKeyFrame) % keyFrameCount;\n    float ratio = float(iFrame % iFramesPerKeyFrame) / float(iFramesPerKeyFrame);\n    \n    loadKeyFrame(keyFrameIndex,ratio);\n    \n    \n    // fudge the data a little:  +-5% from keyframe value\n    for(int i=0;i<QSIZE;++i) {\n        float fi = float(i);\n        q[i] += sin(iTime * (0.1 + fi * 0.2)) * q[i] * 0.05;\n    }\n    \n    viewVector = normalize(q[3].xyz);  // aim\n    sideVector = normalize(cross(vec3(0.,1.,0.),viewVector));\n    topVector = cross(viewVector,sideVector);\n}\n\n#endif // USER_INTERFACE ============================================\n\n\n#ifdef CRYSTAL_EFFECT\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 1.28318*(c*t) );\n}\n\nvec3 doPalette( in float val , in mat4 pType) {\n  return palette( val ,  pType[0].xyz , pType[1].xyz , pType[2].xyz , pType[3].xyz );\n}\n\n#endif\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n    loadDEParams();    \n    \n    ambient = 0.145;\n    contrast = 1.3;\n    vibrant = 0.1;\n    dim = 0.075;\n    \n    color = vec3(0.);\n    stereoEnable = iMouse.x > iResolution.x * 0.95;\n    \n    setDirection(U);\n    rayMarch();\n    \n    if(depth < MAX_DIST) {\n        calcNormal();\n \n#ifdef CRYSTAL_EFFECT\n        vec3 refr = refract(direction,normal, 1./1.1);\n        vec3 refl = normalize(reflect(vec3(0.,3.,0.),normal));\n \n        // when using 3D cubemaps \n        //vec3 refrCol = texture(iChannel2,refr).xyz;\n        //vec3 reflCol = texture(iChannel2,refl).xyz;\n        \n        // when using 2D textures\n        vec3 refrCol = texture(iChannel2,refr.xy).xyz;\n        vec3 reflCol = texture(iChannel2,refl.xy).xyz;\n        \n        float reflectVal = pow( max( 0., dot(refl,direction)), 20.);\n\n        const  mat4  paletteVal = mat4( .5 , .5 , .5 , 0.\n                 , .5 , .5 , .5 , 0.\n                 , 2. , 1. , 0. , 0.\n                 , .5 , .2 , .25 , 0.);\n        \n        vec3 palCol = doPalette(sin(iTime * .002) * 0.002, paletteVal);\n        vec3 refCol = doPalette( reflectVal , paletteVal ) * reflectVal;\n        color = refCol + (palCol * refrCol);\n#else\n        ambient = 0.;\n        contrast = 1.2;\n        vibrant = 0.1;\n        dim = 0.04;\n#endif\n   \n        lighting();\n    }\n    \n    if(fogDistance != 0.0) {\n        float f = depth - fogDistance;\n        if(f > 0.0) {\n            f = min(1.0,f * fogAmount);\n            color = mix(color, vec3(0.2 + f * fogColor),f);\n        }\n    }\n\n    O.xyz = color;\n\n    if(stereoEnable && abs(U.x - iResolution.x * 0.5) < 1.5) O = vec4(1.0);\n    \n#ifdef USER_INTERFACE    \n    if(displayCount > 0) {\n        displayData(iChannel3,iResolution.xy,focus,O,U);\n        console(O,U);\n    }\n#endif\n\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//#define USER_INTERFACE\n\nfloat ostrength = 0.;\nfloat ocycle = 0.;\nvec4 orbit2 = vec4( 0.38347405, 1.86336986, -0.01788503, -2.71105793);\nvec4 orbit3 = vec4(0.87534959, 1.04847687, 0.03234359, 0.00505466);\nvec3 orbit4 = vec3(-2.19183836, 1.41098694, 1.56200985);\nvec3 phongColor =  vec3(0.6,0.2,0.);\nvec3 phongPosition = vec3(1.,-2.,6.);\nvec3 phongParam = vec3(1.1,0.2,1.1);\nvec4 spotLightParam = vec4(0.,2.1,-4.,0.09);\nvec3 spotLightColor = vec3(0.783,0.422,0.0056);\n\n#define qfiter   q[0].x\n#define qbiter   q[0].y\n#define qbox     q[0].zw\n#define qkleinR  q[1].x\n#define qkleinI  q[1].y\n#define qclampy  q[1].z\n#define qclampdf q[1].w\n#define qcamera  q[2]\n#define qaim     q[3]\n\nconst int QSIZE =  4;\nvec4 q[QSIZE];\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeDataAddr(buf_pos, addr) ivec2(buf_pos) == addr\n\n// --------------------------------------------------------\n\nconst float keyFrame[] = float[](\n\n//  q0-------------------  q1---------------------------  //camera ----------------- //aim --------------------\n    21.,17.,0.6319,1.384,  1.9324,0.04583,0.22129,0.0099, 1.3385,0.4097,-1.4039,0.,  1.3429,-0.1999,-2.699,0.,\n    21.,17.,0.171,1.184,   1.9324,0.04583,0.22129,0.0099, 1.3385,0.4097,-1.4039,0.,  1.3429,2.23,-2.699,0.,\n    21.,17.,0.73,1.4,      1.9324,0.04583,0.22129,0.0099, 1.3385,0.4097,-1.4039,0.,  -0.637,0.139,2.11,0.,\n    21.,17.,0.73,0.87,     1.8324,0.24,0.22129,0.0099,    1.3385,1.159,-0.284,0.,    1.3429,1.78,2.11,0.\n);\n\nconst int keyframeEntryLength = QSIZE * 4;    // vec4 for each q[] entry\nconst int keyFrameCount = keyFrame.length() / keyframeEntryLength; // # q[] datasets in storage\n\n\n// ========================================================================\n#ifdef USER_INTERFACE\n\nconst vec4  qq0 = vec4(21.,17.,0.6319,1.384);\nconst vec4  qq1 = vec4(1.9324,0.04583,0.22129,0.00999);\nconst vec4  qqcamera = vec4(1.3385,0.4097,-1.4039,0.);\nconst vec4  qqaim    = vec4(1.3429,-0.1999,-2.699,0.);\n\nstruct ParamData {\n    float start,vmin,vmax,delta;\n};\n\n// leave room for future entries without having to adjust hardwired array positions\n#define UNUSED  9.9\n#define UNUSEDP ParamData(UNUSED,UNUSED,UNUSED,UNUSED)\n\nconst ParamData[] pData = ParamData[]( \n    //  0 p0 ---------------\n    ParamData(qq0.x, 1.,30.,1.),\n    ParamData(qq0.y, 1.,30.,1.),\n    ParamData(qq0.z, -10.,10.,0.01),\n    ParamData(qq0.w, -10.,10.,0.01),\n    //  4 p1 ---------------\n    ParamData(qq1.x, -10.,10.,0.01),\n    ParamData(qq1.y, -10.,10.,0.01),\n    ParamData(qq1.z, -10.,10.,0.01),\n    ParamData(qq1.w, -10.,10.,0.01),\n    //  8 p2 camera ---------------\n    ParamData(qqcamera.x, -20., 20., 0.01), \n    ParamData(qqcamera.y, -20., 20., 0.01), \n    ParamData(qqcamera.z, -20., 20., 0.01), \n    UNUSEDP,\n    // 12 p3 aim ---------------\n    ParamData(qqaim.x, -20., 20., 0.01), \n    ParamData(qqaim.y, -20., 20., 0.01), \n    ParamData(qqaim.z, -20., 20., 0.01), \n    UNUSEDP\n); \n\nconst int PDATA_SIZE = 15;\n\nconst int indexCamera = 8;\nconst int indexAim = 12;\n\nconst ivec2 FOCUS_ADDR = ivec2(1, 0);\nconst ivec2 P0_ADDR =  ivec2(2, 0);\nconst ivec2 P1_ADDR =  ivec2(3, 0);\nconst ivec2 P2_ADDR =  ivec2(4, 0); // camera\nconst ivec2 P3_ADDR =  ivec2(5, 0); // aim\nconst ivec2 UNIFORM_1= ivec2(6, 0); // booleans\nconst ivec2 VV_1     = ivec2(7, 0); // view vectors\nconst ivec2 VV_2     = ivec2(8, 0);\nconst ivec2 VV_3     = ivec2(9, 0);\n\nconst ivec2[] storeAddr = ivec2[](P0_ADDR,P1_ADDR,P2_ADDR,P3_ADDR);\n\n// =======================================================================\n// font display technique I learned from cmgz's \"The Chaos factory\".  Thank you sir.\n// https://www.shadertoy.com/view/XfdyRX\n\nfloat drawChar(sampler2D chan,vec2 char_p, int char_id) { // https://www.shadertoy.com/view/llySRh\n    if (char_p.x < .0 || char_p.x>1. || char_p.y<0. || char_p.y>1.) return 0.;\n    vec2 p = char_p/16.; \n    return textureGrad(chan, p + fract(vec2(char_id,15-char_id/16)/16.), dFdx(p), dFdy(p)).x;\n}\n\nvoid printChar(sampler2D chan,inout vec2 position,int ascii,inout float result) {\n    result = max(result, drawChar(chan,position,ascii));\n    position.x -= 0.5;\n}\n\n#define printString(chan,position,asciiArray,result) for(int i=0;i< asciiArray.length();i++) printChar(chan,position,asciiArray[i],result);\n\nvoid printInt(sampler2D chan,inout vec2 position,int value, inout float result) {\n    int[8] digits;\n    int count = 0;\n    if(value < 0) { printChar(chan,position,45,result);  value = -value; }\n    \n    for(;;) {\n        digits[count] = value % 10;        \n        if(++count >= 8) break;\n        \n        value /= 10;        \n        if(value == 0) break;\n    }\n    \n    for(int i = count-1; i >= 0; i--)\n        printChar(chan,position,48+digits[i],result);\n}\n\nvoid printFloat(sampler2D chan,inout vec2 position,float value, inout float result) {\n    if(value < 0.) { printChar(chan,position,45,result); value = -value; }        \n    int i = int(value);\n    printInt(chan,position,i,result);\n    printChar(chan,position,46,result);\n    i = int(fract(value) * 10000.);\n    printInt(chan,position,i,result);\n}\n\n// 0123456789 +-.[]  48..57,  43,45,46,91,92\n// A65,B66,C67,D68, E69, F70, G71, H72, I73, J74, K75, L76, M77, N78, O79, P80, Q81, R82, S83, T84, U85, V86, W87, X88, Y89, Z90\n// a97,b98,c99,d100,e101,f102,g103,h104,i105,j106,k107,l108,m109,n110,o111,p112,q113,r114,s115,t116,u117,v118,w119,x120,y121,z122\n\nconst int tfiter[] = int[](70,105,110,97,108,73,116,101,114);\nconst int tbiter[] = int[](66,111,120,73,116,101,114);\nconst int tboxx[] = int[](66,111,120,32,88);\nconst int tboxy[] = int[](66,111,120,32,89);\nconst int tkleinR[] = int[](75,108,101,105,110,32,82);\nconst int tkleinI[] = int[](75,108,101,105,110,32,73);\nconst int tclampy[] = int[](67,108,97,109,112,32,89);\nconst int tclampdf[] = int[](67,108,97,109,112,32,68,102);\nconst int tCameraX[] = int[](67,97,109,101,114,97,88);\nconst int tCameraY[] = int[](67,97,109,101,114,97,89);\nconst int tCameraZ[] = int[](67,97,109,101,114,97,90);\nconst int tAimX[] = int[](65,105,109,88);\nconst int tAimY[] = int[](65,105,109,89);\nconst int tAimZ[] = int[](65,105,109,90);\n\nconst float textSize = 9.; // smaller value -> larger text   \nconst vec2 textUL = vec2(1.78,-0.88);\n\n#define Entry(legend,value) \\\n    printString(channel,p2,legend,char_d); \\\n    printChar(channel,p2,32,char_d); \\\n    printFloat(channel,p2,value,char_d); \\\n    entry = true;\n\nvoid displayData(sampler2D channel, vec2 R, int focusIndex, inout vec4 O, vec2 U) {\n    vec2 uv = (2.0 * U - R.xy)/R.y;   // screen resolution\n    vec2 p2,p = textSize * (textUL + uv);\n    vec3 col = vec3(0.);\n    bool entry;\n    float char_d = 0.;\n    \n    for(int i=0;i< PDATA_SIZE;++i) {\n        entry = false;\n        p2 = p;\n        \n        switch(i) {\n            case  0 : Entry(tfiter,q[0].x); break;\n            case  1 : Entry(tbiter,q[0].y); break;\n            case  2 : Entry(tboxx,q[0].z); break;\n            case  3 : Entry(tboxy,q[0].w); break;\n            case  4 : Entry(tkleinR,q[1].x); break;\n            case  5 : Entry(tkleinI,q[1].y); break;\n            case  6 : Entry(tclampy,q[1].z); break;\n            case  7 : Entry(tclampdf,q[1].w); break;\n            case  8 : Entry(tCameraX,qcamera.x); break;\n            case  9 : Entry(tCameraY,qcamera.y); break;\n            case 10 : Entry(tCameraZ,qcamera.z); break;\n            case 12 : Entry(tAimX,qaim.x); break;\n            case 13 : Entry(tAimY,qaim.y); break;\n            case 14 : Entry(tAimZ,qaim.z); break;\n        }\n\n        if(entry) {\n            if(char_d > 0.5) {\n                col = (i == focusIndex) ? vec3(1.,1.,0.) : vec3(0.8);    \n                O = vec4(col,1.0);\n                return;\n            }\n        \n            p.y += 0.84;\n        }\n    }\n}\n\n// COLOR CODED CONSOLE =============================================================\n#define _MINUS   10\n#define _DECIMAL 11\n#define _COMMA   12\n#define _CR      13\n#define _SPC     14\n#define _END     15\n#define DP_MAXLENGTH 500\n\nstruct Chars {\n    int[DP_MAXLENGTH+1] data;\n    int index;\n}; \n\nbool printFloat2(inout Chars c,float val,int fCount) {\n    if(c.index >= DP_MAXLENGTH - 15) return false; // nearing buffer overflow\n        \n    // truncate digits\n    int t = int(val * 1000.0);\n    val = float(t) * 0.001;    \n    \n    if(val < 0.) {\n        c.data[c.index++] =_MINUS;\n        val = -val;\n    }\n    \n    int[8] digits;\n    int count = 0;\n    \n    int iVal = int(val);\n    val -= float(iVal);\n    \n    for(;;) {\n        digits[count++] = iVal % 10;\n        if(count >= 8) break;\n        iVal /= 10;\n        if(iVal == 0) break;\n    }    \n    for(int i = count-1; i >= 0; i--)\n        c.data[c.index++] = digits[i];\n        \n    if(fCount == 0) return true;\n    \n    c.data[c.index++] = _DECIMAL;\n        \n    for(int i = 0; i < fCount;++i) {\n        val *= 10.0;\n        int digit = int(val);\n        c.data[c.index++] = digit;\n        val -= float(digit);\n        if(val <= 0.0) break;\n    }\n    \n    return true; \n}\n\nbool printFloat(inout Chars c,float val) { return printFloat2(c,val,2); }\nbool printInt(  inout Chars c,int val)   { return printFloat2(c,float(val),0); }\n\nvoid console(inout vec4 fragColor, vec2 fragCoord) {\n\n    if(fragCoord.y >= 10.) return;\n\n    Chars chr;\n    chr.index = 0;\n\n    // encode your data in the buffer ----------\n    for(int i=0;i<QSIZE;++i) {\n        for(int j=0;j<4;++j) {\n            if(!printFloat(chr,q[i][j])) break;\n            chr.data[chr.index++] = _COMMA;\n            chr.data[chr.index++] = _SPC;\n        }\n    }\n\n    for(int i=0;i<3;++i) \n        chr.data[chr.index++] = _END;  // signal console to stop parsing the pixels\n\n    // ------------------------------------------\n    // all data is encoded in the buffer.\n    // now grab the value assigned to the current pixel \n    fragColor = vec4(0.,0.,0.,1.);\n\n    int index = int(fragCoord.x) / 3;       // each character cell is drawn 3 pixel wide\n\n    if(index < chr.index) {                \n        int v = chr.data[index];            // 0 ... 15\n        fragColor.z = float(v & 3) * 0.25;  // low 2 bits\n        v >>= 2;\n        fragColor.y = float(v & 3) * 0.25;  // high 2 bits        \n    }\n}\n\n#endif // USER_INTERFACE","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#ifdef USER_INTERFACE\n\nvoid initializeStorage(inout vec4 O,vec2 U) {\n    if (storeDataAddr(U, FOCUS_ADDR)) O.xyz = vec3(0.);\n    \n    int pIndex = 0;\n    for(int i=0;i<QSIZE;++i) {\n        if(storeDataAddr(U, storeAddr[i])) {\n            O = vec4(0.);\n            if(pIndex+0 < PDATA_SIZE) O.x = pData[pIndex+0].start;\n            if(pIndex+1 < PDATA_SIZE) O.y = pData[pIndex+1].start;\n            if(pIndex+2 < PDATA_SIZE) O.z = pData[pIndex+2].start;\n            if(pIndex+3 < PDATA_SIZE) O.w = pData[pIndex+3].start;\n        }\n        \n        pIndex += 4;\n    }\n}\n\n// --------------------------------------------------------\n// determine these values as seldom as possible to save work for image shader\n\nvoid updateViewVectors(inout vec4 fragColor,vec2 fragCoord) {\n    if (storeDataAddr(fragCoord, VV_1) || storeDataAddr(fragCoord, VV_2) || storeDataAddr(fragCoord, VV_3)) {\n        vec3 viewVector = normalize(fetchData(iChannel0, P3_ADDR).xyz);  // aim\n        vec3 sideVector = normalize(cross(vec3(0.,1.,0.),viewVector));\n        vec3 topVector = cross(viewVector,sideVector);\n        \n        if(storeDataAddr(fragCoord, VV_1)) fragColor = vec4(viewVector,1.);\n        if(storeDataAddr(fragCoord, VV_2)) fragColor = vec4(sideVector,1.);\n        if(storeDataAddr(fragCoord, VV_3)) fragColor = vec4(topVector,1.);\n    }\n}\n\n// --------------------------------------------------------\n// keyboard: https://www.shadertoy.com/view/lsXGzf\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT  = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT  = 18;\nconst int KEY_PGUP  = 33;\nconst int KEY_PGDN  = 34;\n\nbool keyClick(int ascii) {\n\treturn (texture(iChannel1,vec2((.5+float(ascii))/256.,0.25)).x > 0.);\n}\n\nbool getKeyState(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,0), 0).x != 0.);\n}\nbool getKeyClick(int keyCode){\n    return bool(texelFetch(iChannel1, ivec2(keyCode,1), 0).x != 0.);\n}\n\nvoid acceleratedValue(inout float value) {\n    bool aKey = getKeyState(65);\n    bool zKey = getKeyState(90);\n    \n    if(aKey && zKey) value *= 50.; else\n    if(aKey) value *= 0.1; else\n    if(zKey) value *= 10.0;    \n}\n\n// --------------------------------------------------------\n\nbool alterFocusedVariable(int focus,int axis) {\n    if(focus > PDATA_SIZE-1) return false;\n    float changeAmount = 0.;\n    int focusIndex = focus / 4;  // memory index\n    int focusField = focus % 4;  // x,y,z,w field within\n\n    if(getKeyClick(48)) {  // '0' sets value to 0.\n        q[focusIndex][focusField] = 0.;\n        changeAmount = 1.;   // so function returns true\n    }\n    else {\n        if(getKeyState(69)) { // 'E'\n            changeAmount = sin(iTime) * 0.001;\n        }\n        else {\n            if(axis == 0) { // arrow keys affect only focused variable \n                if(getKeyState(KEY_LEFT))  changeAmount = -pData[focus].delta; else\n                if(getKeyState(KEY_RIGHT)) changeAmount = +pData[focus].delta;\n            }\n\n            // mouse affects focused variable and also next one --------------\n            if(iMouse.z > 0.0) { // left mouse button down\n                vec2 delta = (iMouse.xy - abs(iMouse.zw)) * 0.01 * pData[focus].delta;\n                if(axis == 0) changeAmount = delta.x;\n                if(axis == 1) changeAmount = -delta.y; // flip Y axis\n             }\n        }\n\n        if(changeAmount != 0.) {\n            acceleratedValue(changeAmount);\n            q[focusIndex][focusField] += changeAmount;\n        }\n    }\n       \n    q[focusIndex][focusField] = clamp(q[focusIndex][focusField],pData[focus].vmin,pData[focus].vmax);\n    \n    return changeAmount != 0.;\n}\n\n// --------------------------------------------------------\n\nvoid loadKeyFrameDataset(int index, inout vec4 O, vec2 U) {\n    int base = index * QSIZE * 4;\n    for(int i=0;i<QSIZE;++i) {\n        for(int j=0;j<4;++j) \n            q[i][j] = keyFrame[base++];\n        if (storeDataAddr(U, storeAddr[i])) \n            O = q[i];\n    }       \n}\n\n// --------------------------------------------------------\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = vec4(0.); \n    if(U.x > 30.0 || U.y > 1.0) return; // skip unused storage locations\n    \n    if(iFrame < 2 || keyClick(32)) {  // reset settings on coldstart or <Spc> keypress\n        initializeStorage(O,U);\n        return; \n    }\n           \n    updateViewVectors(O,U);\n\n    // ==========================================================       \n    // direct load keyframe datasets via '1'...'9'\n    for(int i=49;i<=57;++i)\n        if(getKeyClick(i)) {\n            loadKeyFrameDataset(i-49, O,U);\n            return;\n        }\n\n    // ==========================================================       \n    // keyboard & mouse alter focused data (mouse also affects next entry)\n           \n    // fetch current values\n    for(int i=0;i<QSIZE;++i) {\n        q[i] = fetchData(iChannel0, storeAddr[i]);\n      \n      // animate\n      //if(i < QSIZE - 2) // not camera,aim\n      //    q[i] *= (1. + sin(iTime * float(i) * 0.03) * (0.00003 + float(i) * 0.00001));\n    }\n    \n    bool resetDisplayCount = false; \n    int focus = int(fetchData(iChannel0, FOCUS_ADDR).x);\n\n    //-------------\n    // if <Alt><Shift> alter target position.xy regardless of focus    \n    if(getKeyState(KEY_SHIFT) && getKeyState(KEY_ALT)) \n        focus = indexAim;\n    else\n    \n    // if <Shift> alter camera position.xy regardless of focus\n    if(getKeyState(KEY_SHIFT)) \n        focus = indexCamera;\n    //-------------\n    \n    if(alterFocusedVariable(focus,  0)) resetDisplayCount = true;\n    if(alterFocusedVariable(focus+1,1)) resetDisplayCount = true;\n    \n    // output possibly altered values0-----------\n    for(int i=0;i<QSIZE;++i)\n        if (storeDataAddr(U, storeAddr[i])) \n            O = q[i];\n    // ==========================================================       \n\n    // alter focus.  update displayCount --------\n    if (storeDataAddr(U, FOCUS_ADDR)) {\n        O = fetchData(iChannel0, FOCUS_ADDR);\n        float focusChange = 0.;\n        if(getKeyClick(KEY_UP))   focusChange = -1.;\n        if(getKeyClick(KEY_DOWN)) focusChange = +1.;\n        if(getKeyClick(KEY_PGUP)) focusChange = -5.;\n        if(getKeyClick(KEY_PGDN)) focusChange = +5.;\n\n        if(focusChange == 0. && (iFrame % 12 == 0)) { // slow down auto repeat of up/dn arrows\n            if(getKeyState(KEY_UP))   focusChange = -1.;\n            if(getKeyState(KEY_DOWN)) focusChange = +1.;\n        }\n\n        if(focusChange != 0.) {\n        \n            //skip past UNUSED rows\n            while(true) {\n                O.x += focusChange;\n                if(O.x < 0.0) O.x = float(PDATA_SIZE-1); else\n                if(O.x >= float(PDATA_SIZE)) O.x = 0.0;\n                \n                if(pData[int(O.x)].start != UNUSED) break;\n            }\n            \n            resetDisplayCount = true; \n        }\n        \n        if(resetDisplayCount) O.y = iFrameRate * 2.; else\n        if(--O.y < 0.0) O.y = 0.0;  // so widget display times out \n    }   \n      \n    // ---------------------------------------------------\n    if (storeDataAddr(U, UNIFORM_1)) {\n        O = fetchData(iChannel0, UNIFORM_1); \n        if(iFrame < 10) \n            O.xyz = vec3(0.);\n        else {\n            if(getKeyClick(83)) O.x = (O.x == 0.) ? 1. : 0.; // S\n        }\n    }\n    \n    \n}\n\n#else\n\nvoid mainImage(out vec4 O, vec2 U) {\n    O = vec4(0.); \n}\n \n#endif // USER_INTERFACE","name":"Buffer A","description":"","type":"buffer"}]}