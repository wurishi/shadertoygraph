{"ver":"0.1","info":{"id":"lcyyWV","date":"1732389516","viewed":87,"name":"tungsten cube hell","username":"Swifter","description":"whuh huh wha","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["reflections","recursion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_DIST 10.0\n#define MAX_LOOPS 20\n#define EPSILON 0.01\n#define PROJECTION_DIST 1.5\n\n// https://www.shadertoy.com/view/ldl3Dl\nvec3 hash( vec3 x )\n{\n\treturn texture( iChannel0, (x.xy+vec2(3.0,1.0)*x.z+0.5)/256.0, -100.0 ).xyz;\n}\n\n// https://www.shadertoy.com/view/ldl3Dl\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\nvec3 rotateX(vec3 p, float a) {\n   float c = cos(a);\n   float s = sin(a);\n   mat3 m = mat3(\n       1, 0, 0,\n       0, c, -s,\n       0, s, c\n   );\n   return m * p;\n}\n\nvec3 rotateY(vec3 p, float a) {\n   float c = cos(a);\n   float s = sin(a);\n   mat3 m = mat3(\n       c, 0, s,\n       0, 1, 0,\n       -s, 0, c\n   );\n   return m * p;\n}\n\nvec3 rotateZ(vec3 p, float a) {\n   float c = cos(a);\n   float s = sin(a);\n   mat3 m = mat3(\n       c, -s, 0,\n       s, c, 0,\n       0, 0, 1\n   );\n   return m * p;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat map(vec3 p, float t) \n{\n    vec3 boxPos = vec3(0, 0, 0.5);\n    p -= boxPos;\n    p = rotateX(p, pow(1.0 - t, 3.0) * sin(iTime));\n    p = rotateZ(p, iTime * 0.6);\n    return sdBox(p, vec3(0.5));\n}\n\nvec3 getNormal(vec3 p, float sceneDist, float t) \n{\n    float xDistance = map(p + vec3(EPSILON, 0, 0), t);\n    float yDistance = map(p + vec3(0, EPSILON, 0), t);\n    float zDistance = map(p + vec3(0, 0, EPSILON), t);\n    return (vec3(xDistance, yDistance, zDistance) - sceneDist) / EPSILON;\n}\n\nvec4 skybox(vec3 dir) \n{\n    vec3 v = voronoi(dir * 2.0 + iTime * 0.3);\n    float vx = v.x;\n    vec4 col = mix(vec4(-dir, 1), vec4(dir, 1), max(vx, 0.5));\n    col += vec4(dir, 1) * v.y * v.y * 0.3;\n    col = abs(col);\n    return col;\n}\n\nvec3 viewToWorldDir(vec3 dir, float t) \n{\n    float invT = 1.0 - t;\n    float invT3 = invT * invT * invT;\n    dir = rotateY(dir, invT * sin(iTime * 0.5) * 3.0);\n    return dir;\n}\n\nvec3 viewToWorldPos(vec3 p, float t) \n{\n    p.z -= (1.0 - t) * 5.0;\n    p = viewToWorldDir(p, t);\n    return p;\n}\n\nvec4 marchReflection(vec3 p, vec3 dir, float t) {\n    float d = 0.0;\n    \n    for (int i = 0; i < MAX_LOOPS && d < MAX_DIST; i++) \n    {\n        float sceneDist = map(p, t);\n        \n        if (sceneDist < EPSILON) \n        {\n            vec3 normal = getNormal(p, sceneDist, t);\n            vec3 reflection = reflect(dir, normal);\n            \n            t -= 1.0;\n            reflection.z *= -1.0;\n            vec3 transformedRef = viewToWorldDir(reflection, 0.0);\n            \n            return skybox(transformedRef);\n        }\n        \n        d += sceneDist;\n        p += dir * sceneDist;\n    }\n    \n    return skybox(dir);\n}\n\nvec4 march(vec3 p, vec3 dir, float t) \n{\n    float d = 0.0;\n    \n    for (int i = 0; i < MAX_LOOPS && d < MAX_DIST; i++) \n    {\n        float sceneDist = map(p, t);\n        \n        if (sceneDist < EPSILON) \n        {\n            vec3 normal = getNormal(p, sceneDist, t);\n            vec3 reflection = reflect(dir, normal);\n            \n            t -= 1.0;\n            reflection.z *= -1.0;\n            vec3 transformedRef = viewToWorldDir(reflection, 0.0);\n            \n            vec3 reflectionPos = viewToWorldPos(vec3(0), t);\n            \n            return marchReflection(reflectionPos, transformedRef, t);\n        }\n        \n        d += sceneDist;\n        p += dir * sceneDist;\n    }\n    \n    return skybox(dir);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.y/iResolution.x;\n    \n    vec2 camUV = uv * 2.0 - 1.0;\n    camUV.x /= aspect;\n    \n    float t = mod(iTime * 0.5, 1.0);\n    vec3 camDir = normalize(vec3(camUV, PROJECTION_DIST));\n    \n    vec3 p = viewToWorldPos(vec3(0), t);\n    vec3 dir = viewToWorldDir(camDir, t);\n  \n    fragColor = march(p, dir, t);\n}","name":"Image","description":"","type":"image"}]}