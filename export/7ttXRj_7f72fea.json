{"ver":"0.1","info":{"id":"7ttXRj","date":"1639444370","viewed":88,"name":"Merry Chrysler","username":"funnbot","description":"Move with mouse and wasd,\n\nraymarching from the art of code and a mess of other tutorials.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"tlyGR3","parentname":"RayMarch - Test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define NORMAL_EPS 0.01\n\n#define MAX_STEPS 100\n#define MAX_DIST 60.\n#define SURF_DIST .003\n\n\n\nstruct PointLight {\n\tvec3 position;\n    \n    float intensity;\n    float attenuation;\n    vec3 color;\n};\n\n#define SKY_COLOR vec3(.3, .36, .6)\n    \n#define AMBIENT 0.01\n#define AMBIENT_COLOR vec3(1, .9, .7)\n    \n#define SHADOW_FALLOFF .01\n#define SOFT_SHADOWS 0\n    \nfloat Scene(vec3 p, out vec3 color) {\n    float d = sdPlane(p, -1.);\n    color = vec3(0, 0, 0);\n    \n    // trunk\n    {\n        float cyl = sdCapCylinder(opTransformPos(p, vec3(0, -0.75, 0)), vec2(0.25, 0.2));\n        color = cyl > d ? color : rgb(54, 36, 24);\n        d = min(cyl, d);\n    }\n    // tree\n    {\n        float t1 = (sin(iTime)+1.0)/2.0;\n        float s1 = smoothstep(0.0, 5.0, t1)/100.0;\n        const int layers = 10;\n        for (int l = 0; l < layers; l++) {\n            float scale = float(1+layers - l) / float(layers);\n            float layer = sdCapCone(opTransformPos(p, vec3(0, float(l)*0.2+scale*0.4-0.4, 0)), vec3(scale*1.1, (l==layers-1?0.0:scale*0.2) + s1, (scale * 0.4) + s1));\n            color = layer > d ? color : vec3(0, 1, 0);\n            d = min(layer, d);\n        }\n    }\n    // star thing\n    {\n        float sph = sdSphere(opTransformPos(p, vec3(0, 1.64, 0)), 0.08);\n        color = sph > d ? color : rgb(255, 208, 0);\n        d = min(sph, d);\n    }\n    \n    return d;\n\t//vec3 sphere = vec3(1, 0.3, 1);\n    //float distSphere = sdCapCone(point, sphere);\n    \n    //vec3 boxPos = vec3(4, 4, 0);\n    //vec3 boxRot = vec3(45. * DEG_RAD, 45. * DEG_RAD, 0);\n    //vec3 boxSize = vec3(.2);\n    \t\n   //float distBox = sdBox(opTransform(point, boxPos, boxRot), boxSize);\n    \n    //float plane = -1.;\n    //float distPlane = point.y - plane;\n   \n    //return distBox;\n    //return min(distPlane, min(distBox, distSphere));\n}\n\n\nvec3 GetNormal(vec3 point, out vec3 color) {\n    // Get the distance from this point to the scene\n    float dist = Scene(point, color);\n    // error to swizzle and get the individual errors of dist\n    vec2 eps = vec2(NORMAL_EPS, 0);\n    vec3 _col;\n    vec3 closePoint = vec3(\n        // dist on x plane\n    \tScene(point - eps.xyy, _col),\n        // dist on y plane\n        Scene(point - eps.yxy, _col),\n        // dist on z plane\n        Scene(point - eps.yyx, _col));\n    \n    vec3 normal = dist - closePoint;\n    \n    // normlize, length is known -> eps.x\n    return normal / eps.x;\n}\n\nfloat RayMarch(vec3 orig, vec3 dir) {\n    vec3 color;\n    // Final distance to the scene\n\tfloat dist = 0.;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Move in direction by dist from origin\n    \tvec3 pos = orig + dir * dist;\n        float sceneDist = Scene(pos, color);\n        dist += sceneDist;\n        if (dist > MAX_DIST) return -1.;\n        \n        if (sceneDist < SURF_DIST) break;\n    }\n    \n    return dist;\n}\n\nfloat GetShadow(vec3 point, vec3 normal, vec3 lightDir, vec3 viewDir, float lightDist) {\n\tfloat shadow = 0.0;\n    int shadowRays = 0;\n    \n    #if SOFT_SHADOWS == 0\n    \n    float dist = RayMarch(point + normal * 0.1, lightDir);\n    if (dist > 0.0) {\n        shadow = step(dist, lightDist);\n    }\n    shadowRays = 1;\n    \n    #else\n    \n    int rays = 5;\n    for (int i = 0; i < rays; i++) {\n        vec3 shadowOrig = point + normal * 0.1;\n        float rn = rand(viewDir.xy + float(i)) * 2.0 - 1.0;\n        vec3 shadowDir = lightDir + (rn * SHADOW_FALLOFF);\n        float dist = RayMarch(shadowOrig, shadowDir);\n        if (dist > 0.0) {\n            shadow += (lightDist - dist) / lightDist;\n        }\n    }\n    shadowRays += rays;\n    \n    #endif\n\t\n    return shadow / float(shadowRays);\n}\n\nvec3 GetLight(vec3 point, vec3 viewDir, const in PointLight pointLight) {    \n    //normals\n    vec3 color;\n    vec3 normal = GetNormal(point, color);\n    \n    // ambient\n    vec3 ambient = AMBIENT * AMBIENT_COLOR * color;\n    \n    // attenuation?\n    float lightDist = length(pointLight.position - point);\n    float attenuation = clamp(pointLight.intensity / pow(lightDist*pointLight.attenuation, 2.), 0.0, 1.0);\n    \n    // diffuse \n    vec3 lightDir = normalize(pointLight.position - point);\n    float diffuseIntensity = max(0.0, dot(lightDir, normal));\n    vec3 diffuse = attenuation * diffuseIntensity * mix(pointLight.color, color, 0.5);\n    \n    // specular\n    float specularStrength = 0.85;\n    float specularIntensity = 0.0;\n    // http://ogldev.atspace.co.uk/www/tutorial19/tutorial19.html\n    vec3 lightReflect = normalize(reflect(lightDir, normal));\n    float specularFactor = max(0.0, dot(viewDir, lightReflect));\n    specularFactor = pow(specularFactor, 32.);\n    vec3 specular = attenuation * specularStrength * specularFactor * pointLight.color;\n    \n    // shadow\n\tfloat shadow = GetShadow(point, normal, lightDir, viewDir, lightDist);\n\t\n    vec3 light = ambient + (diffuse + specular) * (1. - shadow);\n    return clamp(light, 0.0, 1.0);\n}\n\n#define MOUSE_TO_SCREEN(v2) (((v2) - 0.5 * iResolution.xy) / iResolution.y)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Center the UV\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    vec4 mouseInp = texelFetch(iChannel0, ivec2(0, 1), 0);\n    vec4 keyInp = texelFetch(iChannel0, ivec2(0, 2), 0);\n    \n    const vec2 camRotOrig = vec2(0, -0.1);\n    const vec3 camPosOrig = vec3(0, 1, -10);\n    \n    mat3 camRot = RotationMatrix(vec3(0, 1, 0), -mouseInp.x + camRotOrig.x) * \n                      RotationMatrix(vec3(1, 0, 0), mouseInp.y + camRotOrig.y);\n    vec3 camDir = camRot * normalize(vec3(uv, FOCAL_LENGTH));\n    \n    vec3 camPos = vec3(keyInp.x, keyInp.y, keyInp.z);\n    vec3 camOrig = vec3(0, 1, -6) + camPos;\n    \n    \n   \tfloat dist = RayMarch(camOrig, camDir);\n    \n    vec3 col = vec3(0);\n    if (dist < -0.5) col = SKY_COLOR - (camDir.y * 0.6);\n    else {\n        float t1 = (sin(iTime*4.0)+1.0)*0.5;\n        float t2 = (sin(iTime*4.3)+1.0)*0.5;\n        \n        vec3 r = mix(vec3(0, 1, 0), vec3(1, 0, 0), t1);\n        vec3 g = mix(vec3(1, 0, 0), vec3(0, 1, 0), t2);\n    \n    \tvec3 point = camOrig + camDir * dist;\n        PointLight pl = PointLight(vec3(4., 3, -3), 30., 0.7, r);\n        PointLight p2 = PointLight(vec3(-4., 2, -5), 30., 0.7, g);\n    \tcol = clampAdd(GetLight(point, camDir, pl), GetLight(point, camDir, p2));\n       \n        float fog = dist / MAX_DIST;\n        col = mix(col, SKY_COLOR, fog);\n    }\n    \n    // Gamma correction\n    col = LinearToGamma(col);\n    fragColor = vec4(col, 1);\n    //fragColor = vec4(step((uv.x+1.0)*0.5, , step(uv.y, mouseInp.y), 0, 1);\n    //fragColor = vec4(mouseInp.xy, 0, 1);\n    //fragColor = vec4(MOUSE_TO_SCREEN(iMouse.xy), 0, 1);\n    //fragColor = texture(iChannel0, fragCoord.xy/iChannelResolution[0].xy);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265359\n#define DEG_RAD 0.01745329252\n\n#define FOCAL_LENGTH 1.7\n\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat dot2(vec2 v) {\n    return dot(v.xy, v.xy);\n}\nvec3 clampAdd(vec3 a, vec3 b) {\n    return clamp(a + b, 0.0, 1.0);\n}\nvec3 rgb(int r, int g, int b) {\n    return vec3(r, g, b)/255.;\n}\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat3 RotationMatrix(vec3 axis, float angle) {\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    vec3 as = axis * sin(angle);\n    \n    return mat3(oc * axis.xxz * axis.xyx + vec3(c, -as.z, as.y),\n                oc * axis.xyy * axis.yyz + vec3(as.z, c, -as.x), \n                oc * axis.zyz * axis.xzz + vec3(-as.y, as.x, c));\n}\nvec3 LinearToGamma(vec3 rgb) {\n    return pow(rgb, vec3(0.454545));\n}\n\n// sphere -> (x, y, z, w) -> (xPos,  yPos, zPos, radius)\nfloat sdSphere(vec3 p, vec4 sphere) {\n\treturn length(sphere.xyz - p) - sphere.w;\n}\nfloat sdSphere(vec3 p, float rad) {\n    return length(p) - rad;\n}\nfloat sdPlane(vec3 p, float planeY) {\n\treturn p.y - planeY;\n}\nfloat sdBox(vec3 p, vec3 size) {\n\tvec3 q = abs(p) - size;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n// https://iquilezles.org/articles/distfunctions\n// size -> (r1, r2, height)\nfloat sdCapCone(vec3 p, vec3 size) {\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(size.y,size.z);\n  vec2 k2 = vec2(size.y-size.x,2.0*size.z);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?size.x:size.y), abs(q.y)-size.z);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n// size -> (radius, height)\nfloat sdCapCylinder(vec3 p, vec2 size) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(size.y,size.x);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 opTransform(vec3 p, vec3 pos, vec3 angles) {\n\treturn p * RotationMatrix(vec3(1, 0, 0), angles.x) *\n        \t   RotationMatrix(vec3(0, 1, 0), angles.y) *\n               RotationMatrix(vec3(0, 0, 1), angles.z) - pos;\n}\nvec3 opTransformPos(vec3 p, vec3 pos) {\n    return p - pos;\n}\nvec3 opRep(out vec3 p, vec3 period) {\n\treturn mod(p + 0.5 * period, period) - 0.5 * period;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Camera Controller\n\n#define LOOK_SPEED 0.02\n#define MOVE_SPEED 5.\n\n#define THIS_BUFFER_CHANNEL iChannel0\n#define KEYBOARD_CHANNEL iChannel1\n\n#define KEY_DOWN(idx) (texelFetch(KEYBOARD_CHANNEL, ivec2((idx), 0), 0).x)\n\n#define IS_COORD(x, y) (floor(fragCoord.xy) == vec2((x), (y)))\n#define COORD_DATA(x, y) (texelFetch(THIS_BUFFER_CHANNEL, ivec2((x), (y)), 0))\n\n#define MOUSE_DOWN() (step(0.5, iMouse.z))\n#define MOUSE_TO_SCREEN(v2) (((v2) - 0.5 * iResolution.xy) / iResolution.y)\n\nconst int KEY_W = 87, KEY_A = 65, KEY_S = 83,\n          KEY_D = 68, KEY_SPACE = 32, KEY_SHIFT = 16;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Rotation\n    if (IS_COORD(0, 1)) {\n        vec4 lookData = COORD_DATA(0, 1);\n        \n        vec2 offsetData = lookData.zw;\n        \n        \n        lookData.xy += MOUSE_TO_SCREEN(iMouse.xy) * iTimeDelta * step(1.0, iMouse.z);\n        fragColor = lookData;\n    } else if (IS_COORD(0, 2)) {\n        vec4 lookData = COORD_DATA(0, 1);\n    \tvec4 posData = COORD_DATA(0, 2);\n        vec3 move = vec3(KEY_DOWN(KEY_D) - KEY_DOWN(KEY_A), 0,\n                         KEY_DOWN(KEY_W) - KEY_DOWN(KEY_S))\n\t\t\t\t      * MOVE_SPEED * iTimeDelta;\n        \n        mat3 camRot = RotationMatrix(vec3(0, 1, 0), -lookData.x) * \n                      RotationMatrix(vec3(1, 0, 0), lookData.y);\n        \n        posData += vec4(camRot * move, 1);\n        posData += vec4(0, KEY_DOWN(KEY_SPACE) - KEY_DOWN(KEY_SHIFT), 0, 0) \n            \t\t* MOVE_SPEED * iTimeDelta;\n        \n        fragColor = posData;\n    } else fragColor = vec4(0);\n}","name":"Buffer A","description":"","type":"buffer"}]}