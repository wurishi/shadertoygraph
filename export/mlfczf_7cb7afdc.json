{"ver":"0.1","info":{"id":"mlfczf","date":"1691005158","viewed":37,"name":"Cubic Bezier degree reduction","username":"Envy24","description":"https://ttnghia.github.io/pdf/QuadraticApproximation.pdf\nMouse.x changes split parameter value (gamma in paper).\nRed - cubic Bezier,\nBlue - approximation with two quadratic Bezier curves.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["bezier","approximation","cubic","quadratic","catmull","rom","reduction","degree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SCENE_SCALE               ( 4.0 )\n#define UNIT                      ( (SCENE_SCALE*4.0) / iResolution.y  )\n#define SMAA(d)                   ( smoothstep(UNIT, 0., d) )\n//#define SMAA(d, unit)             ( smoothstep(unit, 0., d) )\n#define CLAA(d)                   ( clamp(0.5 - 0.5 * d, 0.0, 1.0) )\n\n/* https://www.shadertoy.com/view/DdsGDj */\n#define MOUSE_OFFSET ( iMouse.z > 0. ? iMouse.xy - iResolution.xy * 0.5 : vec2(0) )\nvec2 map_to_centered_ndc(in vec2 SC, in float scale, in vec2 origin, in bool mouse_drag)\n{\n    vec2 M = MOUSE_OFFSET * (mouse_drag == true ? 1. : 0.);\n    return ((2. * (SC - M) - iResolution.xy) / iResolution.y) * scale + origin;\n}\n\n// Cubic Bezier knots.\nvec2 cP[4] = vec2[4]( vec2(-1,0.5), vec2(0.1,0.2), vec2(-0.5,-0.5), vec2(1,0.5) );\n// Quadratic Bezier knots.\nvec2 qP[5];\n\nvec2 cubicBezier(float t, vec2 A, vec2 B, vec2 C, vec2 D)\n{\n    float f = (1. - t);\n    return f*f*(A*f + 3.*B*t) + t*t*(3.*C*f + D*t);\n}\nvec2 qudraticBezier(float t, vec2 A, vec2 B, vec2 C)\n{\n    float f = (1. - t);\n    return f*(A*f + 2.*B*t) + C*t*t;\n}\nvec2 approximateBezier(float t, float g, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    g = iMouse.z > 0. ? g : 0.5;\n    vec2 R0 = P0,\n         R1 = P0 + (3./2.) *       g  * (P1 - P0),\n         R3 = P3 + (3./2.) * (1. - g) * (P2 - P3),\n         R2 = (1. - g) * R1 + g * R3,\n         R4 = P3;\n    qP[0] = R0; qP[1] = R1; qP[2] = R2; qP[3] = R3; qP[4] = R4; // only for drawing\n    float a = linear_remap(t, vec2(0, g), vec2(0, 1)),\n          b = linear_remap(t, vec2(g, 1), vec2(0, 1));\n    return t >= 0. && t < g ?\n        qudraticBezier(a, R0, R1, R2) :\n        qudraticBezier(b, R2, R3, R4);\n}\nvoid CatmullRom_to_Bezier(inout vec2 P0, inout vec2 P1, inout vec2 P2, inout vec2 P3)\n{\n    float alpha = 1./2.,\n          d12 = pow(length(P1 - P0), 2.*alpha), d1 = pow(length(P1 - P0), alpha),\n          d22 = pow(length(P2 - P1), 2.*alpha), d2 = pow(length(P2 - P1), alpha),\n          d32 = pow(length(P3 - P2), 2.*alpha), d3 = pow(length(P3 - P1), alpha);\n    vec2 B0 = P1,\n         B1 = P1 + ( d12 * (P2 - P1) + d22 * (P1 - P0) ) / ( 3.*d1*(d1+d2) ),\n         B2 = P2 + ( d32 * (P1 - P2) + d22 * (P2 - P3) ) / ( 3.*d3*(d3+d2) ),\n         B3 = P2;\n    P0 = B0; P1 = B1; P2 = B2; P3 = B3;\n}\nvec2 approximateCatmullRom(float t, float g, vec2 P0, vec2 P1, vec2 P2, vec2 P3)\n{\n    //CatmullRom_to_Bezier(P0, P1, P2, P3); // because i directly use Bezier knots\n    g = iMouse.z > 0. && iMouse.xy != vec2(0) ? g : 0.5;\n    vec2 R0 = P0,\n         R1 = P0 + (3./2.) *       g  * (P1 - P0),\n         R3 = P3 + (3./2.) * (1. - g) * (P2 - P3),\n         R2 = (1. - g) * R1 + g * R3,\n         R4 = P3;\n    qP[0] = R0; qP[1] = R1; qP[2] = R2; qP[3] = R3; qP[4] = R4; // only for drawing\n    float a = linear_remap(t, vec2(0, g), vec2(0, 1)),\n          b = linear_remap(t, vec2(g, 1), vec2(0, 1));\n    return t >= 0. && t < g ?\n        qudraticBezier(a, R0, R1, R2) :\n        qudraticBezier(b, R2, R3, R4);\n}\nint func_id = 0;\nvec2 parametric(float t) \n{ \n    if (func_id == 0)\n        return cubicBezier(t, cP[0], cP[1], cP[2], cP[3]);\n    else if (func_id == 1)\n        return approximateBezier(t, iMouse.x/iResolution.x, cP[0], cP[1], cP[2], cP[3]);\n    else\n        return approximateCatmullRom(t, iMouse.x/iResolution.x, cP[0], cP[1], cP[2], cP[3]);\n}\n\n// https://www.shadertoy.com/view/NtVfWG\nfloat parametric_sdf(\n    in vec2 NDC,\n    in vec2 from, // NDC.x range\n    in vec2 to,   // t range\n    in float count)\n{\n    float dt = (from.y - from.x) / (count - 1.);\n    \n    float minimal_distance = 99.;\n    vec2 B = parametric(linear_remap(from.x, from, to));\n      \n    for (float i = 1.; i < count; i += 1.)\n    {\n        float t = linear_remap(from.x + dt * i, from, to);\n    \n        vec2 E = parametric(t);\n        minimal_distance = \n            min(minimal_distance, segmentSDF(NDC, B, E, 0.));\n        B = E;\n    }\n    \n    const float thickness = 0.02;\n    return minimal_distance - thickness;\n}\n\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    float AR = iResolution.x/iResolution.y;\n    vec2 NDC = map_to_centered_ndc(SC, SCENE_SCALE, vec2(0), false);\n    \n    cP[0] = vec2(2.0, 0.0) * 0.65; \n    cP[1] = vec2(8.0, -3.0);\n    cP[2] = vec2(-3.0, 6.0);\n    cP[3] = vec2(-2.0, 0.0) * 0.65;\n    \n    float offs = sinOSC(-1.5, 0.5, iTime * 0.5);\n    cP[0] = rotateAroundZ(cP[0], iTime * 0.3) + vec2(2.*offs, -offs);\n    cP[1] = rotateAroundZ(cP[1], iTime * 0.9) + vec2(-3.*offs, 0.0);\n    cP[2] = rotateAroundZ(cP[2], iTime * 0.9) + vec2(-8.*offs, 3.*offs);\n    cP[3] = rotateAroundZ(cP[3], iTime * 0.1) + vec2(-2.*offs, offs);\n\n    vec3 color = vec3(1);\n         color = mix( color, vec3(0.5), SMAA(cellsSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(x_axisSDF(NDC)) );\n         color = mix( color, vec3(0), SMAA(y_axisSDF(NDC)) );\n         \n    /* Parametric function (x,y)=f(t) */\n    vec2 from = vec2(-AR*SCENE_SCALE, AR*SCENE_SCALE), to = vec2(0, 1);\n    func_id = 0;\n    color = mix( color, vec3(1,0,0), SMAA(parametric_sdf(NDC, from, to, 64.)) );\n    func_id = 1;\n    color = mix( color, vec3(0,0,1), SMAA(parametric_sdf(NDC, from, to, 64.)) );\n    /* Cubic Bezier knots */\n    color = mix( color, vec3(1,0,0), SMAA(diskSDF(NDC, cP[0], 0.08)) );\n    color = mix( color, vec3(1,0,0), SMAA(diskSDF(NDC, cP[1], 0.08)) );\n    color = mix( color, vec3(1,0,0), SMAA(diskSDF(NDC, cP[2], 0.08)) );\n    color = mix( color, vec3(1,0,0), SMAA(diskSDF(NDC, cP[3], 0.08)) );\n    /* Qudratic Bezier knots */\n    color = mix( color, vec3(0,0,1), SMAA(diskSDF(NDC, qP[0], 0.04)) );\n    color = mix( color, vec3(0,0,1), SMAA(diskSDF(NDC, qP[1], 0.04)) );\n    color = mix( color, vec3(1,0,1), SMAA(diskSDF(NDC, qP[2], 0.04)) ); // shared knot\n    color = mix( color, vec3(0,1,0), SMAA(diskSDF(NDC, qP[3], 0.04)) );\n    color = mix( color, vec3(0,1,0), SMAA(diskSDF(NDC, qP[4], 0.04)) );\n    /**/\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float y_axisSDF(vec2 NDC) { return abs(NDC.x); }\nfloat x_axisSDF(vec2 NDC) { return abs(NDC.y); }\nfloat vertical_lineSDF(vec2 NDC, float x0) { return abs(NDC.x-x0); }\nfloat horizontal_lineSDF(vec2 NDC, float y0) { return abs(NDC.y-y0); }\nfloat cellsSDF(vec2 NDC)\n{\n    NDC = fract(NDC);\n    NDC = fract(min(NDC, 1. - NDC));\n    return\n        min(vertical_lineSDF(NDC, 0.), horizontal_lineSDF(NDC, 0.));\n}\nfloat diskSDF(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\nfloat segmentSDF(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\nvec2 rotateAroundZ(vec2 p, float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n\n    return vec2(\n        p.x * c - p.y * s,\n        p.y * c + p.x * s);\n}\nfloat linear_remap(float val, vec2 from, vec2 to)\n{\n    // inverse linear map from [from.x; from.y] to [0; 1].\n    val = (val - from.x) / (from.y - from.x);\n    // linear map from [0; 1] to [to.x; to.r].\n    return val * (to.y - to.x) + to.x;        \n}","name":"Common","description":"","type":"common"}]}