{"ver":"0.1","info":{"id":"Nl33Rl","date":"1636503105","viewed":142,"name":"SDF Visualizer 3D","username":"playbyan1453","description":"3D SDF visualizer inspired by iq's work!, completely reworked probably still a bit buggy.\n","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["sdf","visualizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tmax 1e2\n#define eps 1e-8\n#define steps 1024\n#define show 1\n#define detail 1.0 // Higher more detail\n// #define norm // Uncomment for visualizing normal\n\n// Ray intersection Function\nfloat plane(vec3 ro, vec3 rd, float h, vec3 n) {\n    float d = dot(rd, n);\n    float t = -(dot(ro, n) - h) / d;\n    return t;\n}\n\n// Signed distance function\n// Box defined by 2 points\nfloat boxSDF(vec3 p, vec3 a, vec3 b) {\n    vec3 q = max(a - p, p - b);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// This is your scene\nfloat map(vec3 p) {\n    return length(p) - 1.0;\n}\n\nvec3 normal(vec3 p, float ep) {\n    vec2 h = vec2(1,-1) * ep;\n    return normalize(h.xyy*map(p + h.xyy)+\n                     h.yyx*map(p + h.yyx)+\n                     h.yxy*map(p + h.yxy)+\n                     h.xxx*map(p + h.xxx));\n}\n\nfloat adDist(float t, float fov, float de) {\n    float d = de * fov;\n    return max(t / max(iResolution.x, iResolution.y) / d + eps, eps);\n}\n\nfloat raymarch(vec3 ro, vec3 rd, float fov) {\n    float t = 0.0;\n    for(int i = 0; i < steps; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        t += d;\n        if(t > tmax || abs(d) < adDist(t, fov, detail)) break;\n    }\n    return t;\n}\n\nmat3 cam(vec3 at, vec3 ro) {\n    vec3 z = normalize(at - ro);\n    vec3 x = normalize(cross(vec3(0, 1, 0), z));\n    vec3 y = cross(z, x);\n    return mat3(x, y, z);\n}\n\nmat3 ArbitraryTBN(vec3 n) {\n    float s = sign(n.z);\n    float a = -1.0f / (s + n.z);\n    float ba = n.x * n.y * a;\n    vec3 t = vec3(1.0f + s * n.x * n.x * a, s * ba, -s * n.x);\n    vec3 b = vec3(ba, s + n.y * n.y * a, -n.y);\n    return mat3(t, b, n);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (2.0*fragCoord.xy-iResolution.xy)/max(iResolution.x, iResolution.y);\n    vec3 at = vec3(0, 0, 0);\n    vec3 ro = texelFetch(iChannel0, ivec2(0.5, 1.5), 0).xyz;\n    mat3 ca = cam(at, ro);\n    float fov = 1.0;\n    vec3 rd = ca * normalize(vec3(uv, fov));\n\n    vec3 col, albedo;\n    float opacity = 0.75;\n    float mask = texelFetch(iChannel1, ivec2(fragCoord) % 8, 0).x;\n    \n    vec3 nor = rd;\n    float tmin = tmax;\n    float t;\n    vec3 p0N = normalize(vec3(cos(iTime*0.75), sin(iTime*0.35), -cos(iTime*0.15)));\n    t = plane(ro, rd, -sin(iTime*0.5)*1.5, p0N);\n    vec3 p = ro+rd*t;\n    mat3 matNor = ArbitraryTBN(p0N);\n    if(t > eps && tmin > t && all(lessThan(abs((p*matNor).xy), vec2(1.5))) && mask < opacity) {\n        tmin = t;\n        nor = p0N;\n        float fi = adDist(t, fov, 1.0 * opacity);\n        float d = map(p);\n        #ifdef norm\n        vec3 viz = normal(p, fi) * ca * 0.5 + 0.5;\n        #else\n        vec3 viz = mix(vec3(0.05, 0.35, 0.95), vec3(0.95, 0.35, 0.05), smoothstep(eps-fi, eps+fi, d));\n        #endif\n        viz *= vec3(smoothstep(0.5-fi*10.0, 0.55+fi*10.0, abs(sin(d*3.1415926*4.0*fov)))*.4+.6);\n        viz *= smoothstep(0.0, 0.5, abs(d))*0.8+0.2;\n        viz = mix(viz, vec3(0.95), smoothstep(-fi, fi, 1.0 - abs(d * fov - fi) - (1.0 - fi)));\n        albedo = viz;\n    }\n    #if show\n    t = tmin < eps ? tmax : raymarch(ro, rd, fov);\n    if(t > eps && tmin > t) {\n        tmin = t;\n        nor = normal(ro+rd*t, adDist(t, fov, detail));\n        albedo = nor*ca * 0.5 + 0.5;\n    }\n    #endif\n    if(tmin > eps && tmin < tmax) {\n        col = albedo;\n    } else col = rd * 0.5 + 0.5;\n    \n    col = pow(col, vec3(0.4545));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Mouse By Alro : https://www.shadertoy.com/view/7dVGzz\n#define eps 1e-4\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    // Work with just the first four pixels.\n    if((fragCoord.x == 0.5) && (fragCoord.y < 4.0)) {\n        vec4 oldMouse = texelFetch(iChannel0, ivec2(0.5), 0);\n        vec4 mouse = iMouse / iResolution.xyxy; \n        vec4 newMouse = vec4(0);\n        float mouseDownLastFrame = texelFetch(iChannel0, ivec2(0.5, 3.5), 0).x;\n        \n        // If mouse button is down and was down last frame\n        if(iMouse.z > 0.0 && mouseDownLastFrame > 0.0) {\n            // Difference between mouse position last frame and now.\n            vec2 mouseMove = mouse.xy - oldMouse.zw;\n            newMouse = vec4(oldMouse.xy + vec2(6.2831853, 3.1415927) * mouseMove, mouse.xy);\n        } else {\n            newMouse = vec4(oldMouse.xy, mouse.xy);\n        }\n        newMouse.x = mod(newMouse.x, 6.2831853);\n        newMouse.y = clamp(newMouse.y,-1.5707963 + eps, 1.5707963 - eps);\n\n        // Store mouse data in the first pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 0.5)) {\n            // Set value at first frames\n            if(iFrame < 0) {\n                newMouse = vec4(0);\n            }\n            fragColor = newMouse;\n        }\n\n        // Store camera position in the second pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 1.5)) {\n            // Set camera position from mouse information.\n            vec2 mouse_rotation = newMouse.xy;\n            vec2 yawpitch = vec2(mouse_rotation.x, -mouse_rotation.y);\n            \n            vec3 cameraPos = vec3(0, 0,-4);\n            cameraPos = erot(cameraPos, vec3(1, 0, 0), yawpitch.y);\n            cameraPos = erot(cameraPos, vec3(0, 1, 0), yawpitch.x);\n            \n            fragColor = vec4(cameraPos, 1.0);\n        }\n        \n        // Store resolution change data in the third pixel of Buffer A.\n        if(fragCoord == vec2(0.5, 2.5)) {\n            float resolutionChangeFlag = 0.0;\n            // The resolution last frame.\n            vec2 oldResolution = texelFetch(iChannel0, ivec2(0.5, 2.5), 0).yz;\n            \n            if(iResolution.xy != oldResolution) {\n            \tresolutionChangeFlag = 1.0;\n            }\n        \tfragColor = vec4(resolutionChangeFlag, iResolution.xy, 1.0);\n        }\n           \n        // Store whether the mouse button is down in the fourth pixel of Buffer A\n        if(fragCoord == vec2(0.5, 3.5)) {\n            if(iMouse.z > 0.0) {\n            \tfragColor = vec4(vec3(1), 1.0);\n            } else {\n            \tfragColor = vec4(vec3(0), 1.0);\n            }\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}