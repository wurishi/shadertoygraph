{"ver":"0.1","info":{"id":"M3jfW1","date":"1729428383","viewed":96,"name":"Angels have vector souls","username":"pali6","description":"This tweet has been stuck in my head so I made a thing vaguely inspired by it. I'm not entirely happy with it but oh well.\nhttps://x.com/ctrlcreep/status/1845202450246234593","likes":3,"published":3,"flags":0,"usePreview":0,"tags":["monochrome","art","angel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159263589\n#define WING_COUNT 6\n#define MAX_WING_ANGLE PI * 0.1\n#define WING_SPEED 0.5\n#define FRACT_ANGLE_COVERED 0.3\n#define HALO_RADIUS 0.05\n#define HALO_THICKNESS 0.02\n#define HALO_NUM_PARTS 6\n#define HALO_COVER_FRACT 0.5\n#define HALO_SPEED 0.5\n#define BODY_SIDES 6\n#define BODY_SPEED 0.1\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n#define hash2(p) fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123)\n\nfloat bumpf(float x) { return sin(x * PI); }\n\nfloat wingCurve(float time, float x) {\n\tfloat pix = (x + 1.) * PI;\n\treturn sin(pix + time * 0.32) + sin(pix * 3.78 - time) * 0.2;\n}\n\nbool inWing(float time, vec2 pos) {\n\tfloat top = wingCurve(time, pos.x) * 0.4 + 0.6;\n\tfloat bottom = wingCurve(time, pos.x) * 0.4 - 0.6;\n\tfloat bump = bumpf(pos.x / 2. + 0.5);\n\ttop *= bump;\n\tbottom *= bump;\n\treturn pos.y < top && pos.y > bottom;\n}\n\nvec2 rotate(vec2 v, float a) {\n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.x * sin(a) + v.y * cos(a));\n}\n\nfloat nGon(vec2 pos, int n) {\n\tfloat angle = PI * 2. / float(n);\n\tfloat r = 0.5 / sin(angle / 2.);\n\tfloat a = atan(pos.y, pos.x);\n\tfloat d = cos(mod(a + angle / 2., angle) - angle / 2.) * length(pos);\n\treturn d - r;\n}\n\nfloat angelGon(float time, vec2 pos) {\n\treturn min(\n\t\tnGon(rotate(pos * 2.4, time), BODY_SIDES),\n\t\tnGon(rotate(pos * 2.4, time + PI / float(BODY_SIDES)), BODY_SIDES)\n\t);\n}\n\nfloat angelBody(float time, vec2 pos) {\n\treturn min(\n\t\tangelGon(time, pos),\n\t\tmin(\n\t\t\tangelGon(-time, pos * 2. + vec2(0.0, 1.2)),\n\t\t\tangelGon(-time, pos * 2. - vec2(0.0, 1.2))\n\t\t)\n\t);\n}\n\nfloat grainNoise(vec2 pos, float time, float grain)\n{\n\tconst int N = 4;\n\tconst int M = 1;\n\tconst int K = 20;\n\tvec2 ps[N];\n\tps[0] = floor(pos / grain) * grain;\n\tps[1] = floor(pos / grain) * grain + vec2(0., grain);\n\tps[2] = floor(pos / grain) * grain + vec2(grain, 0.);\n\tps[3] = floor(pos / grain) * grain + vec2(grain, grain);\n\t\n\tfloat result = 0.5;\n\t\n\tfor(int k = 0; k < K; k++)\n\t{\n\t\tfloat kFrac = float(k) / float(K - 1);\n\t\tfor(int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < M; j++)\n\t\t\t{\n\t\t\t\tvec2 p = ps[i] +\n\t\t\t\t\thash2(ps[i] * 0.0123 + float(j) * 0.5321 + time * 0.01123) * grain - vec2(0.5 * grain);\n\t\t\t\tfloat dist = distance(p, pos);\n\t\t\t\tif(dist < grain / 2.)// && hash(ps[i] + 0.53 + float(j) * 0.2121 + time * 0.1) < 0.1)\n\t\t\t\t{\n\t\t\t\t\tfloat g = kFrac * (1. - kFrac) * 4.;\n\t\t\t\t\tresult = result * (1. - g) + g * hash(vec2(0.785 * ps[i].x, 0.123 * ps[i].y) + 485e-5 + float(j) * 1e-2 + vec2(time * 1e-5, time * 3e-4));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttime -= 1.;\n\t}\n\treturn result;\n}\n\nfloat haloTimeFunc(float x) {\n\t// integral of (0.5+(sin (x * 2 * pi)) / 2)**5 normalized so it goes up by 1 in 1\n\treturn (0.246094 * x - 0.018651 * sin(12.5664 * x) + 0.000777124 * sin(25.1327 * x) - 0.0652784 * cos(6.28319 * x) + 0.00466274 * cos(18.8496 * x) - 0.0000621699 * cos(31.4159 * x)) / 0.246094;\n}\n\nfloat haloAngle(float time, vec2 pos, int haloParts, float haloPartsCoverFrac) {\n\tfloat res = 1e20;\n\tfor (int i = 0; i < haloParts; i++) {\n\t\tfloat curTime = time * 0.1 + float(i) / float(haloParts);\n\t\tfloat angleSize = 2. * PI / float(haloParts) * haloPartsCoverFrac;\n\t\tvec2 curPos = pos;\n\t\tcurPos = rotate(curPos, 2. * PI * haloTimeFunc(curTime) * (1. - haloPartsCoverFrac));\n\t\tfloat angle = atan(curPos.y, curPos.x) + angleSize * float(i);\n\t\tres = min(res, abs(angle) - angleSize / 2.);\n\t}\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 scaleFactor = vec2(min(iResolution.x, iResolution.y));\n\tvec2 uv = fragCoord / scaleFactor;\n    uv -= (iResolution.xy / scaleFactor - vec2(1.)) / 2.;\n\n\tvec3 col = vec3(0.12 + 0.15 * grainNoise(uv, floor(iTime * 20.), 0.01));\n\n\tvec2 pos = uv * 2. - 1.;\n\tvec2 opos = pos;\n\n\tpos.x = abs(pos.x);\n\n\tint hitWings = 0;\n\tfor(int i = 0; i < WING_COUNT; i++) {\n\t\tfloat wingFract = float(i) / float(WING_COUNT);\n\t\tfloat rotAngle = sin(iTime * WING_SPEED + wingFract * PI * 2. * FRACT_ANGLE_COVERED) * MAX_WING_ANGLE;\n\t\tvec2 wingPos = pos;\n\t\twingPos = rotate(wingPos, rotAngle);\n\t\twingPos = wingPos * 1.5 - vec2(1.3, 0.2);\n\t\twingPos.y *= 2.;\n\t\tif(inWing(iTime + 0.7 * float(i), wingPos))\n\t\t\thitWings += 1;\n\t}\n\t\n\tfloat wingFract = 0.01;\n    float bod = angelBody(iTime * BODY_SPEED, pos + vec2(0.0, 0.15));\n\tif (bod < 0.0)\n\t\twingFract += clamp(1.0 + bod * 0.7, 0.7, 1.0);\n    else\n        wingFract += float(hitWings) / float(WING_COUNT) * 1.4;\n\n\tvec2 haloPos = opos - vec2(0., 0.8);\n\thaloPos *= vec2(0.2, 1.);\n\tfloat dist = distance(haloPos, vec2(0.));\n\tfloat angleVal = haloAngle(iTime * HALO_SPEED, haloPos, HALO_NUM_PARTS, HALO_COVER_FRACT);\n\tif (angleVal < 0.03) {\n\t\tfloat f = max(\n\t\t\tdist - HALO_RADIUS - HALO_THICKNESS,\n\t\t\t-dist + HALO_RADIUS - HALO_THICKNESS\n\t\t);\n\t\tif (f < 0.001) {\n\t\t\twingFract += 1.0\n\t\t\t\t* (1. - pow(clamp(angleVal / 0.03, 0., 1.), 0.3))\n\t\t\t\t* (1. - pow(clamp(f / 0.001, 0., 1.), 0.3));\n\t\t} else if (dist > HALO_RADIUS) {\n\t\t\twingFract = wingFract * 0.9 - 0.005;\n\t\t}\n\t}\n\t\n\twingFract = clamp(wingFract, 0., 1.);\n\twingFract = pow(wingFract, 0.3);\n\tfragColor = vec4(vec3(1.) * (1. - wingFract) + col * wingFract, 1.);\n\n}","name":"Image","description":"","type":"image"}]}