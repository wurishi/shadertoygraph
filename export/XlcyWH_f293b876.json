{"ver":"0.1","info":{"id":"XlcyWH","date":"1532353265","viewed":229,"name":"D15E45E","username":"Zoz","description":"Party coded 4k intro made at Edison 2018\n\nGroup: FEE1DEAD\nGraphics: Zoz\nMusic: Sigmund Floyd\n","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","4k","spiral"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ld2Xzt","filepath":"https://soundcloud.com/gustav-nelson-schneider/d15e45e-4k","previewfilepath":"https://soundcloud.com/gustav-nelson-schneider/d15e45e-4k","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415\n#define R(p, m) mod(p, m) - m / 2.\n#define ID(p, m) floor(p / m) \n\n#define time mod(iTime, 76.)\n\nmat3 Rotate(vec3 angles)\n{\n    vec3 c = cos(angles);\n    vec3 s = sin(angles);\n    \n    mat3 rotX = mat3( 1, 0, 0, 0,c.x,s.x, 0,-s.x, c.x);\n    mat3 rotY = mat3( c.y, 0,-s.y, 0,1,0, s.y, 0, c.y);\n    mat3 rotZ = mat3( c.z, s.z, 0,-s.z,c.z,0, 0, 0, 1);\n\n    return rotX*rotY*rotZ;\n}\n\n\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat noise( vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\n\n/**********************\n * DISTANCE FUNCTIONS *\n **********************/\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdSphere( vec3 p ) {\n \treturn length(p) - 1.;   \n}\n\n/******\n * OPS\n ******/\n\nvec2 opU(vec2 a, vec2 b) {\n \treturn a.x < b.x ? a : b;   \n}\n\n\nfloat opRep1(inout float p, float m) {\n \tfloat c = ID(p, m);\n    p = R(p, m);\n    return c;\n}\n\nvec2 opRep2(inout vec2 p, float m) {\n    vec2 c = ID(p, m);\n    p = R(p, m);\n    return c;\n}\n\n/*****************\n * MAP Functions\n *****************/\n\nfloat repid1 = 0.;\nfloat spiralRot = .5;\nfloat spiralNoise;\n    \nfloat spiral(vec3 p) {\n    //saving original coordinate space \n    vec3 po = p; \n    \n    repid1 = opRep1(p.x, 0.08); \n    repid1 = mod(repid1, 10.);\n          \n    //Spiral rotation effect\n    p = Rotate(vec3(spiralRot * sin(po.x - p.x + time * PI / 4.), 0, 0)) * p;\n    //spiral noise effect\n    p.z += mix(0., noise(p.xy * 100.) * 0.3, clamp(time - spiralNoise, 0., 1.));\n    return sdBox(p, vec3(.03, .45, .02)) - 0.002;\n}\n\nfloat repid2 = 0.;\n\nfloat frame(vec3 p) {\n \tvec3 p0 = p;\n    \n    repid2 = opRep1(p.x, .5);\n    p *= Rotate(vec3(repid2, 0, 0));\n    \n    p.y -= .25;\n    float d = .4 + 0.2 * sin(repid2);\n    return max(sdBox(p, vec3(0.02, d, d)), -sdBox(p, vec3(0.2, d - 0.02, d - 0.02)));\n}\n\nvoid camera(inout vec3 p) {\n    vec3 p1 = Rotate(vec3(0.7, 0, -PI / 8.)) * p;\n    \n    \n    vec3 p2 = Rotate(vec3(0, PI / 2., 0.)) * p;\n    vec3 p3 = Rotate(vec3(0, PI / 3., 0.)) * p;\n    p2.y -= 0.30;// - 0.25;\n \tp2.x += (time - 15.) * 1.;\n    p3.x += time - 15.;\n    \n    spiralNoise = 40.;\n    \n    if (time < 8.) {\n    \tp = p2; \n    } else if (time < 20.) {\n     \tp = p1;   \n    } else if (time < 28.) {\n     \tspiralRot =  2.;\n        p = p2;\n    } else if (time < 36.) {\n        spiralRot = 2.;\n     \tp = p1;   \n    } else if (time < 56.){\n        spiralRot = 2.;\n     \tp = p2;   \n    } else if (time < 64.) {\n     \tp = p3;   \n    } else {\n     \tp = p2;   \n    }\n   \n}\n\nvec2 map(vec3 p) {\n\n    float d;\n    vec2 t = vec2(100);\n\tvec3 p0 = p;\n    camera(p);\n    \n    \n    t = vec2(spiral(p - vec3(0, .3, 0)), 1.);\n        \n   \t//floor\n    vec3 p1 = p;\n    opRep2(p1.xz, 0.11);\n    float off = noise((p.xz - p1.xz) * 10.) * 0.05;\n\n    d = sdBox(p1 + vec3(0, .5 + off , 0), vec3(0.05)) - 0.005;\n    t = opU(t, vec2(d, 2.));\n       \n    t.x = max(t.x, (p.x - 28.));\n        \n    //frames and stuff\n    vec2 t2 = vec2(frame(p), 3);\n        \t\n    //spiral2\n        \n    vec3 off2 = vec3(-64., 2. * sin(p.x), 2. * cos(p.x));\n    vec2 s = vec2(sdBox(p + off2, \n                            vec3(10, .5, 0.1)), 4.);\n    vec3 p2 = p;\n    float b = sdBox(p2 + off2 - vec3(0, 0., 0.), vec3(12., 0.2, 0.2));\n   \ts.x = max(s.x, -b);\n        \n    t2 = opU(t2, s);\n    \t\n\t\t\n    \n    t2.x = max(t2.x, -p.x + 32.);\n       \tt = opU(t, t2);\n    \n   \n    \t//t = t2;\n\t\t\n    \n    \n    //t = opU(t, vec2(p.y + .25, 2.));\n    return t;\n}\n\nvec3 nor(vec3 p, float prec)\n{\n    vec2 e = vec2(prec, 0.);\n    \n    vec3 n;\n    \n    n.x = map(p+e.xyy).x - map(p-e.xyy).x; \n    n.y = map(p+e.yxy).x - map(p-e.yxy).x; \n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;  \n    \n    return normalize(n); \n}\n\nvec2 render(vec3 o, vec3 r) {\n \tfloat t = 0.;\n    vec2 t0;\n    for (int i = 0; i < 128; i++) {\n        vec3 p = o + r * t;\n        t0 = map(p);\n        \n        if (t0.x < 0.001) break;\n        \n        t += t0.x * 0.55;\n        \n        if (t > 30.) {\n            t0.x = 30.;\n         \tbreak;       \n        }\n    }\n    \n    return vec2(t, t0.y);\n}\n\nvec3 shade(vec2 t) {\n    if (t.y == 0.) return vec3(0., 0., 0);\n    //if (t.y == 2.) return vec3(1, 0, 0);\n    \n    vec3 col = vec3(0);\n    if (t.y == 1.) {\n    \tvec3 c = repid1 == 0. ? vec3(1, 0.5, 0) : vec3(1);\n    \tcol = c;// / (t.x * t.x * .6);\n        \n    }\n    \n    return col;\n}\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance ) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*0.4 );\n    vec3  fogColor  = vec3(0);\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\nvec3 scene1(vec3 o, vec3 r) {\n    vec3 col;\n    vec2 t = render(o, r);\n    \n    vec3 p = o + r * t.x;\n    vec3 n = nor(p, 0.001);\n    \n       \n    vec3 d = normalize(reflect(p - o, n));\n    if (t.y == 2.) {\n                \n   \t\tvec2 t1 = render(p + d * 0.02, d);\n        col = 0.3 * vec3(0.2);\n\n        col += applyFog(0.3 * shade(t1), t1.x);\n        \n    } else if (t.y == 3.) {\n        float add = 1./8. - 1./8.;\n\t  \n      //float x = clamp(floor(4. * time), 0., 8. * floor(time / 2.));\n      float x = floor(time * 4. - add) * mod(floor(time - add), 2.);  \n      col = mod(repid2 - x, 4.) == 0. ? vec3(1, .5, 0) : vec3(1, 1, 1);  \n    } else if (t.y == 4.) {\n     \t//scene 2 spiral\n        col = vec3(1);\n    }else {\n        col = shade(t);        \n    }\n    \n\n   \n    float ao = 1.;\n    for (float i = 0.; i < 6.; i++) {\n   \t\tao -= 0.3 * abs(length(n * i /16.) - map(p + n * i / 16.).x);\n    }\n    col *= ao;\n   \n    \n\tcol = applyFog(col, t.x);\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 o = vec3(0, 0, -1.8);\n    vec3 r = normalize(vec3(uv, 2));\n    \n    vec3 col = mix(scene1(o, r), vec3(0), clamp((time - 75.), 0., 1.));\n\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}","name":"Image","description":"","type":"image"}]}