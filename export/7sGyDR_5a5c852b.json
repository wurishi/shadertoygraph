{"ver":"0.1","info":{"id":"7sGyDR","date":"1654672429","viewed":108,"name":"webgl-operate perlin example","username":"cgcostume","description":"example implementation of value, gradient, and simplex noise using octaves as published in https://webgl-operate.org/examples/\n","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","webgloperate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\nprecision highp int;\n\nconst float scale = 16.0;\nuniform float u_seed;\n\n\nfloat rand(in vec2 uv) {\n    // return mod(uv.x * 12213.231 + uv.y * 32132.567, 1.0);\n    return fract(sin(u_seed + dot(uv, vec2(12.9898, 78.233))) * 4375.5453123);\n}\n\nvec2 rand2(in vec2 uv) {\n    vec2 v = vec2(dot(uv, vec2(127.1, 311.7)), dot(uv, vec2(269.5, 183.3)));\n    return clamp(normalize(-1.0 + 2.0 * fract(sin(u_seed + v) * 43758.5453123)), -1.0, 1.0);\n}\n\nfloat smoothstep3(in float t) {\n    // 3t^2 - 2t^3, same as smoothstep(0.0, 1.0, t);\n    return t * t * (3.0 - 2.0 * t);\n}\nfloat  smoothstep5(in float t) {\n    // 6t^5 - 15t^4 + 10t^3\n    return t * t * t * (t * (6.0 * t - 15.0) + 10.0);\n}\nfloat  smoothstep7(in float t) {\n    // -20x^7 + 70x^6 - 84x^5 + 35x^4\n    return t * t * t * t * (t * (t * (70.0 - 20.0 * t) - 84.0) + 35.0);\n}\nfloat  smoothstep9(in float t) {\n    // 70x^9 - 315x^8 + 540x^7 - 420x^6 + 126x^5\n    return t * t * t * t * t * (t * (t * (t * (70.0 * t - 315.0) + 540.0) - 420.0) + 126.0);\n}\n\nfloat smoothen(in float t) {\n    // return smoothstep(0.0, 1.0, t);\n    // return smoothstep3(t);\n       return smoothstep5(t);\n    // return smoothstep7(t);\n    // return smoothstep9(t);\n}\n\nfloat value_noise(in vec2 st) {\n    ivec2 i = ivec2(floor(st));\n    vec2 f = fract(st);\n\n    vec4 r = vec4(\n        rand(vec2(i + ivec2(0, 0))),\n        rand(vec2(i + ivec2(1, 0))),\n        rand(vec2(i + ivec2(0, 1))),\n        rand(vec2(i + ivec2(1, 1))));\n\n    vec2 fm = vec2(smoothen(f[0]), smoothen(f[1]));\n    return mix(mix(r[0], r[1], fm[0]), mix(r[2], r[3], fm[0]), fm[1]);\n}\n\nfloat gradient_noise(in vec2 st) {\n    ivec2 i = ivec2(floor(st));\n    vec2 f = fract(st);\n\n    vec4 r = vec4(\n        dot(rand2(vec2(i + ivec2(0, 0))), f - vec2(0.0, 0.0)),\n        dot(rand2(vec2(i + ivec2(1, 0))), f - vec2(1.0, 0.0)),\n        dot(rand2(vec2(i + ivec2(0, 1))), f - vec2(0.0, 1.0)),\n        dot(rand2(vec2(i + ivec2(1, 1))), f - vec2(1.0, 1.0)));\n\n    vec2 fm = vec2(smoothen(f[0]), smoothen(f[1]));\n    return mix(mix(r[0], r[1], fm[0]), mix(r[2], r[3], fm[0]), fm[1]) * 0.5 + 0.5;\n}\n\nconst float pi = 3.14159265;\nconst float skewx = cos(30.0 * pi / 180.0);\nconst float iskewx = 1.0 / skewx;\n\nvec2 skew(in vec2 st) {\n    // return st;\n    return vec2(iskewx * st.x, 0.5 * st.x + st.y);\n}\n\nvec2 unskew(in vec2 st) {\n    // return st;\n    return vec2( skewx * st.x, st.y - 0.5 * st.x);\n}\n\nvec3 simplex(in vec2 st_fract_of_skewed) {\n    vec2 f = st_fract_of_skewed;\n    return mix(\n        vec3(1.0 - f[1], f[0], f[1] - f[0]),\n        vec3(1.0 - f[0], f[1], f[0] - f[1]),\n        step(f[1], f[0]));\n}\n\nfloat simplex_noise(in vec2 st) {\n    vec2  st_skewed  = skew(st);\n\n    vec2  f = fract(st_skewed);\n    ivec2 i = ivec2(floor(st_skewed));\n\n    vec3 s = normalize(simplex(f));\n    s = 1.0 - sqrt(1.0 - s * s);\n\n    vec2 p0 = unskew(f - /* skew? */(vec2(0.0, 0.0)));\n    vec2 p1 = unskew(f - /* skew? */(vec2(1.0, 1.0)));\n    vec2 p2 = unskew(f - /* skew? */(step(f.yx, f.xy)));\n\n    vec2 g0 = rand2(vec2(i) + vec2(0, 0));\n    vec2 g1 = rand2(vec2(i) + vec2(1, 1));\n    vec2 g2 = rand2(vec2(i) + step(f.yx, f.xy));\n\n    float r0 = dot(g0, p0) * (s[0]);\n    float r1 = dot(g1, p1) * (s[1]);\n    float r2 = dot(g2, p2) * (s[2]);\n\n    return r0 + r1 + r2 + 0.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    \n    // move the noise a little around \n\n    vec2 uv_scaled = (uv * vec2(aspect, 1.0));\n    uv_scaled -= 0.5;\n    uv_scaled *= 1.0 + sin(iTime * sqrt(2.0)) * 0.1;\n    uv_scaled += 0.5;\n    uv_scaled = uv_scaled * scale + scale / 16.0 * vec2(sin(iTime), cos(iTime));\n    \n\n    vec4 o0, o1;\n\n    // methods from bottom-to-top: value, gradient, simplex\n    int method = int(floor(uv.y * 3.0)); \n\n    switch(method) {\n        case 0: // value noise\n        {\n            o0 = vec4(\n                value_noise(uv_scaled *   1.0),\n                value_noise(uv_scaled *   2.0),\n                value_noise(uv_scaled *   4.0),\n                value_noise(uv_scaled *   8.0));\n            o1 = vec4(\n                value_noise(uv_scaled *  16.0),\n                value_noise(uv_scaled *  32.0),\n                0.0,  //value_noise(uv_scaled *  64.0),\n                0.0); //value_noise(uv_scaled * 128.0));\n        }\n        break;\n\n        case 1: // gradient noise\n        {\n            o0 = vec4(\n                gradient_noise(uv_scaled *   1.0),\n                gradient_noise(uv_scaled *   2.0),\n                gradient_noise(uv_scaled *   4.0),\n                gradient_noise(uv_scaled *   8.0));\n            o1 = vec4(\n                gradient_noise(uv_scaled *  16.0),\n                gradient_noise(uv_scaled *  32.0),\n                0.0,  //gradient_noise(uv_scaled *  64.0),\n                0.0); //gradient_noise(uv_scaled * 128.0));\n        }\n        break;\n\n        case 2: // simplex noise\n        {\n             o0 = vec4(\n                simplex_noise(uv_scaled *   1.0),\n                simplex_noise(uv_scaled *   2.0),\n                simplex_noise(uv_scaled *   4.0),\n                simplex_noise(uv_scaled *   8.0));\n            o1 = vec4(\n                simplex_noise(uv_scaled *  16.0),\n                simplex_noise(uv_scaled *  32.0),\n                0.0,  //simplex_noise(uv_scaled *  64.0),\n                0.0); //simplex_noise(uv_scaled * 128.0));\n        }\n        break;\n\n        default:\n        break;\n    }\n\n    // weights for the eight octaves ...\n    vec4 w0 = vec4(32.0, 16.0, 8.0, 4.0); // vec4(128.0, 64.0, 32.0, 16.0);\n    vec4 w1 = vec4( 2.0,  1.0, 0.0, 0.0); // vec4(8.0, 4.0, 2.0, 1.0);\n\n    // top-to-bottom masking of number of octaves used\n    vec4 se = vec4(0.0, 1.0, 2.0, 3.0) / 6.0; // vec4(0.000, 0.125, 0.250, 0.375);\n    vec4 s0 = step(se + 0.0, vec4(uv.x));\n    vec4 s1 = step(se + 4.0 / 6.0, vec4(uv.x));\n\n    float n = (dot(o0 * w0, s0) + dot(o1 * w1, s1)) / (dot(w0, s0) + dot(w1, s1));\n    fragColor = vec4(vec3(n), 1.0);\n}","name":"Image","description":"","type":"image"}]}