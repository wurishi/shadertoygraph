{"ver":"0.1","info":{"id":"Mdt3Wj","date":"1452275934","viewed":135,"name":"study 5","username":"njazz","description":"learning. reflections, occlusion","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//based on this:\n//https://iquilezles.org/articles/distfunctions\n//https://iquilezles.org/articles/menger\n\nvec3 w2s(vec3 p)\n{\n\tp.xy *= (-1.-1.*p.z);\n    return p;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n    \n   \n}\n//perlin noise:\n//http://www.kamend.com/2012/06/perlin-noise-and-glsl/\nvec4 mod289(vec4 x)\n{\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n//perlin noise:\n//http://www.kamend.com/2012/06/perlin-noise-and-glsl/\n\n\nfloat cnoise(vec2 P)\n{\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod289(Pi); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    \n    vec4 i = permute(permute(ix) + iy);\n    \n    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n    vec4 gy = abs(gx) - 0.5 ;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    \n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    \n    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n    g00 *= norm.x;  \n    g01 *= norm.y;  \n    g10 *= norm.z;  \n    g11 *= norm.w;  \n    \n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    \n    vec2 fade_xy = fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return 2.3 * n_xy;\n}\n\nfloat maxcomp(vec2 v1)\n{\n\treturn max(v1.x,v1.y);\n}\nfloat sdCross( in vec3 p )\n{\n    float inf = 40.;\n    float size = 2.;\n    \n  float da = sdBox(p.xyz,vec3(inf,size,size));\n  float db = sdBox(p.yzx,vec3(size,inf,size));\n  float dc = sdBox(p.zxy,vec3(size,size,inf));\n    \n  //float da = maxcomp(abs(p.xy));\n  //float db = maxcomp(abs(p.yz));\n  //float dc = maxcomp(abs(p.zx));\n    \n  return min(da,min(db,dc));\n    \n  //  return db;\n}\n\n\n//float opScale( vec3 p, float s )\n//{\n//    return primitive(p/s)*s;\n//}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opRep( vec3 p, vec3 c )\n{\n    \n    vec3 p2;\n    \n    p2.x = p.x*cos(iTime/7.)+p.z*sin(iTime/7.);\n    p2.z = p.z*cos(iTime/7.)-p.x*sin(iTime/7.);\n    p2.y = p.y;\n    \n    //res = d;//min(d,e);\n    vec3  q = p2;\n     q.x = mod(p.x,12.)-6.;//-0.5*c;\n     q.y = mod(p.y,12.)-6.;//-0.5*c;\n     q.z = mod(p.z,8.)-4.;//-0.5*c;\n    \n    q = mod(p2,c)-0.5*c;\n    \n    float scale = 7.+3.*cnoise(p.xy/10.);\n    float scale2 = 9.+3.*cnoise(p.yx/10.);\n    float scale3 = 7.+3.*cnoise(p.yx/10.+vec2(iTime*3.,0.));\n    \n    //scale = 14.;\n    \n    float d = udRoundBox(q,vec3(scale,scale2,scale3),1.5);\n    float e = sdSphere(q,10.5);\n    \n    float res;// = (mod(p.x,20.)<19.)?d:e;\n    //float res;\n    \n    \n    \n    if (p.z>0.) {res = d;} else {res = 100.;}\n    //res=d;\n    \n    return res;\n}\n\n\n\n\n\n\nfloat gMix(vec3 p)\n{\n    float z;// = (10.+0.001*sin(iTime*2.9))*iTime;\n    z = -7.-2.75*(1.+cos(iTime/1.));;\n       z = -7.+mod(iTime*3.,20.);\n\treturn opRep(p+vec3(0.,0.,z),vec3(50.,50.,30.));\t\n}\n    \n\n\n\n\nvec2 rM (vec3 ro, vec3 rd)\n{\n\tfloat dist;\n    \n    //ro.xy -= 0.5;\n    //rd.xy -= 0.5;\n    \n    //ro.xy *= (1.-1.5*ro.z);\n    //rd.xy *= (1.-1.5*rd.z);\n    \n    //ro = w2s(ro);\n    //rd = w2s(rd);\n    \n    vec3 rp = ro+rd;\n    \n    float eps = 0.03;\n    \n    float l=1.;\n    \n    for (int i=0;i<70;i++)\n    {\n    \tdist = gMix(ro+rd*l);\n        \n        rp += rd*dist;\n        \n        \n        if (dist<eps)\n        {\n            //l = clamp(l,1.,20.);\n        \treturn vec2(l,1);\n            \n        }\n        \n        l+= dist;\n    }\n    //l = clamp(l,0.,25.);\n\treturn vec2(l,(l>20.)?-1.:1.);\n}\n\n\n\nvec3 gNorm(vec3 p)\n{\n    highp vec3 ret;\n    \n    //p = w2s(p);\n    \n    float eps = 0.0001;\n    \n    ret.r = gMix(p+vec3(eps,0,0.))-gMix(p-vec3(eps,0,0.));\n    ret.g = gMix(p+vec3(0.,eps,0.))-gMix(p-vec3(0,eps,0.));\n    ret.b = gMix(p+vec3(0.,0,-eps))-gMix(p-vec3(0,0,-eps));\n    \n    //ret = normalize(vec3(0,0.00025,0)+(ret));\n\treturn normalize(ret);\n}\n\nfloat gAO(vec3 p, vec3 n)\n{\n    float ao=0.;\n\tfor (int i=0; i<3;i++)\n    {\n        vec3 rd = (n*float(i)/3.);\n        \n    \tao += gMix(p+rd) / (1./float(i));\t\n    }\n    \n    return ao/2.;\n}\n\n\n                        \nfloat gLamb(vec3 norm, vec3 lvec)\n{\n    return  clamp((dot((norm),lvec)),0.,1.);\n}  \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 rd = vec3(0.,0.,0.5)+0.5*vec3(uv.xy,0);\n    //rd = normalize(rd);\n    vec3 ro = vec3(uv,0.);\n    \n    \n    vec2 rm_d = rM(ro,rd);\n    \n    bool v = (rm_d.y>0.);\n    \n    vec3 lv1 = w2s(vec3(-.2,-2.2,1.5));\n    lv1 = normalize(lv1);\n    \n    vec3 lv2 = w2s(vec3(-1.2,1.2,1.2));\n    lv2 = normalize(lv2);\n    \n    vec3 pos1 = vec3(uv.xy,rm_d.x);//vec3(vec2(-1.-1.*rm_d.x)*uv.xy,-rm_d.x);\n   \tpos1 = ro+rd*rm_d.x;\n    \n    vec3 n = (v)?gNorm(pos1):normalize(vec3(0.,0.,-0.));\n    //n = vec3(float(v));\n    //n = clamp(n,-1.,1.);\n    \n    vec3 suv = w2s(vec3(uv.xy,1.0));\n    vec3 hv = suv+lv1;\n    hv /= length(hv);\n    \n    vec3 suv2 = w2s(vec3(uv.xy,1.0));\n    vec3 hv2 = suv2+lv2;\n    hv2 /= length(hv2);\n    \n    float fog = pos1.z/300.;\n    fog = clamp(fog,0.,1.);\n    //fog = 0.;\n    \n    vec3 fogC = vec3(0.75,0.75,0.75);\n    \n    float spec = 1.*clamp(pow(dot((n),(hv)),500.),0.,1.);\n    float spec2 = 1.*clamp(pow(dot((n),(hv2)),300.),0.,1.);\n    \n    \n    //shadows attempt 1\n    float ld = rM(pos1, lv1).x;\n    float ld2 = rM(lv1, pos1).x;\n    float sh = 1. - 0.5*float(ld!=ld2);\n    \n    //ssao attempt\n    float ao = gAO(pos1,n);\n    \n    vec3 diffC = ao*vec3(1.,0.,0.5)*gLamb(n, lv1);\n    diffC*=sh;\n    \n     ld = rM(pos1, lv2).x;\n     ld2 = rM(lv2, pos1).x;\n    \n     sh = 1. - 0.5*float(ld!=ld2);\n    \n    //reflection attempt 1\n    vec3 ref = reflect(pos1,n);\n    float r1 = rM(lv1, ref).x;\n    \n    vec3 nr = gNorm(ref);\n    vec3 refC = vec3(1.,0.,0.5)*gLamb(ref,lv1);\n    \n    diffC += clamp((1.-r1/1.5),0.,1.)*refC;//vec3(.5,.75,1.);\n    \n    \n    \n    //diffC = clamp(diffC,0.,1.);\n    diffC += ao*vec3(0.25,.5,0.)*sh*gLamb(n, lv2);\n\n    //diffC = clamp(diffC,0.,1.);\n    \n    vec3 specC = spec*vec3(1.9,1.8,1.5);\n    specC += spec2*vec3(2.7,2.8,2.9);\n    \n    //\n    \n\n    \n    \n    //float ao = calcAO(pos1,n);\n    \n    fragColor = vec4(mix(diffC+specC,fogC,fog),1);\n    \n    //fragColor = vec4(ao,ao,ao,1.);\n    //fragColor = vec4(rm_d.x*0.001,-rm_d.y,0,1);\n    //fragColor = vec4(n,1);              \n\t//fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}","name":"","description":"","type":"image"}]}