{"ver":"0.1","info":{"id":"sdjSDz","date":"1620237618","viewed":122,"name":"sphere cutter","username":"smjty","description":"A simple algorithm to ninja cut a density function","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["sphere","volumetric","cut"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nfloat rand(float co){\n    return fract(sin(co*12.9898) * 43758.5453);\n}\nvec3 dense( vec3 pos )\n{    \n\n    float m = 1.0;\n    float N=55.0;\n    for(float i=0.;i<N;i+=1.){\n        vec3 d = vec3( rand(i*33.) , rand(i*38. + 1.), rand(i*3. +6.))*2. - 1.;\n        d= normalize(d);\n        float l = clamp(40.*(0.5 + 0.5*cos(iTime*2.*PI/6. + i*PI/N*2. )),0.,1.)  /25.0;\n        float dd = dot(pos,d);\n        if( abs(dd) < l) return vec3(0.0,0.0,0.0);\n        pos = pos - d * sign(dd) * l ;\n        m *= sign(dd);\n    }\n    if(length(pos)<1.0){\n        if(m>0.0)\n            return vec3(0.95,0.2,0.2)*(1. - clamp(length(pos),0.9,1.))*10.0 ;\n        return vec3(0.2,0.2,0.95)*(1. - clamp(length(pos),0.9,1.))*10.0 ;\n    }\n    return vec3(0.,0.,0.);\n\n}\n\nvec3 raycast( in vec3 ro, in vec3 rd )\n{\n    vec3 res = vec3(0.,0.,0.);\n\n    float tmin = 2. ;\n    float tmax = 8.0;\n    float N = 200.;\n    int i;\n    for(i=0 ;i <int(N) ;i++){\n        float t = (tmax - tmin) * float(i) / N + tmin;\n        vec3 p = ro + rd * t;\n        vec3 denss = vec3(0.,0.,0.);\n        if(length(p)<2.)\n         denss = dense(p);\n        vec3 light =vec3(1.,1.,1.);\n        res += vec3(light.x*denss.x , light.y*denss.y , light.z*denss.z);\n    }\n    res /= N/15.;\n    return res;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec3 back = vec3(0,0.,0.);\n    vec3 col = back;\n    \n    vec3 res = raycast(ro,rd);\n    \n    col = res+back;\n    \n\treturn vec3(clamp(col,0.0,1.0));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*2.*PI/30.0;\n\t \n    vec3 ta = vec3(-0.00,0.,0.); ;\n    vec3 ro = ta - 5.*vec3(sin(time),0.00,cos(time));\n    \n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n\n    const float fl = 2.5;\n\n    vec3 rd = ca * normalize( vec3(p,fl) );\n\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = ca * normalize( vec3(px,fl) );\n    vec3 rdy = ca * normalize( vec3(py,fl) );\n\t\n    vec3 col = render( ro, rd, rdx, rdy );\n    tot += col;\n    \n   // tot = floor(tot*7.)/7.;\n    \n    fragColor = vec4( tot, 1.0 );\n}","name":"Image","description":"","type":"image"}]}