{"ver":"0.1","info":{"id":"fsSfzG","date":"1646483628","viewed":136,"name":"growing cube sphere","username":"Gravechest","description":"epic","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["cube","sphere","growing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"uint hash( uint x ) {\n    x += ( x << 10u );\n    x ^= ( x >>  6u );\n    x += ( x <<  3u );\n    x ^= ( x >> 11u );\n    x += ( x << 15u );\n    return x;\n}\nuint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\nuint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\nuint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu;\n    const uint ieeeOne      = 0x3F800000u;\n\n    m &= ieeeMantissa;                 \n    m |= ieeeOne;                    \n\n    float  f = uintBitsToFloat( m );  \n    return f - 1.0;                       \n}\nfloat random( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\nfloat random( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\nfloat random( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 angle = vec2(0.0,0.0);\n    vec3 pos   = vec3(iTime*3.0,0.5,28.5);\n    vec4 dir = vec4(cos(angle.x),sin(angle.x),sin(angle.y),cos(angle.y));\n    vec2 pixelOffset = fragCoord.xy/iResolution.xy*2.0-1.0;\n    pixelOffset.x *= 1.69;\n    vec3 vec;\n    vec.x = (dir.x * dir.w - dir.x * dir.z * pixelOffset.y) - dir.y * pixelOffset.x;\n    vec.y = (dir.y * dir.w - dir.y * dir.z * pixelOffset.y) + dir.x * pixelOffset.x;\n    vec.z = dir.z + dir.w * pixelOffset.y;\n    vec3 ang = normalize(vec);\n    vec3 delta = abs(1.0/ang);\n    vec3 st,si,bp;\n    if(ang.x < 0.0){\n\t\tst.x = -1.0;\n\t\tsi.x = fract(pos.x) * delta.x;\n\t}\n\telse{\n\t\tst.x = 1.0;\n\t\tsi.x = (floor(pos.x) + 1.0 - pos.x) * delta.x;\n\t}\n\tif(ang.y < 0.0){\n\t\tst.y = -1.0;\n\t\tsi.y = fract(pos.y) * delta.y;\n\t}\n\telse{\n\t\tst.y = 1.0;\n\t\tsi.y = (floor(pos.y) + 1.0 - pos.y) * delta.y;\n\t}\n\tif(ang.z < 0.0){\n\t\tst.z = -1.0;\n\t\tsi.z = fract(pos.z) * delta.z;\n\t}\n\telse{\n\t\tst.z = 1.0;\n\t\tsi.z = (floor(pos.z) + 1.0 - pos.z) * delta.z;\n\t}\n    bp = floor(pos);\n    int side;\n    for(int i = 0;i < 200;i++){\n        if(si.x < si.y){\n            if(si.x < si.z){\n\t\t\t\tbp.x += st.x;\n\t\t\t\tsi.x += delta.x;\n\t\t\t\tside = 0;\n            }\n            else{\n\t\t\t\tbp.z += st.z;\n\t\t\t\tsi.z += delta.z;\n\t\t\t\tside = 2;\n            }\n        }\n        else if(si.y < si.z){\n\t\t\tbp.y += st.y;\n\t\t\tsi.y += delta.y;\n\t\t\tside = 1;\n        }\n        else{\n\t\t\tbp.z += st.z;\n\t\t\tsi.z += delta.z;\n\t\t\tside = 2;\n        }\n        if(bp.z > 30.0){\n            return;\n        }\n        if(bp.y < 2.0 && bp.y > -2.0){\n            if(bp.z > 20.0){\n                continue;\n            }\n            else{\n                fragColor.rgb = vec3(1.0);\n                return;\n            }\n        }\n        float s = random(bp.xy);\n        if(s>bp.z/30.0){\n            vec2 wall;\n            vec3 sc;\n            switch(side){\n            case 0:\n                wall.x = pos.y + (si.x - delta.x) * ang.y;\n\t\t\t\twall.y = pos.z + (si.x - delta.x) * ang.z;\n                if(ang.x > 0.0){\n                    sc = vec3(fract(wall),0.0);\n                }\n                else{\n                    sc = vec3(fract(wall),1.0);\n                }\n\n                fragColor.rgb = vec3(0.5,0.5,0.5) * (bp.z+fract(wall.y)+s*15.0-35.0)/5.0;\n                return;\n            case 1:\n                wall.x = pos.x + (si.y - delta.y) * ang.x;\n\t\t\t\twall.y = pos.z + (si.y - delta.y) * ang.z;\n                fragColor.rgb = vec3(0.5,0.5,0.5) * (bp.z+fract(wall.y)+s*15.0-35.0)/5.0;\n                return;\n            case 2:\n                wall.x = pos.y + (si.z - delta.z) * ang.y;\n\t\t\t\twall.y = pos.x + (si.z - delta.z) * ang.x;\n                fragColor.rgb = vec3(0.5,0.5,0.5) *(bp.z+fract(wall.y)+s*15.0-35.0)/5.0;\n                return;\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}