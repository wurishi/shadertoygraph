{"ver":"0.1","info":{"id":"7lj3zw","date":"1623710463","viewed":574,"name":"MC World","username":"kastorp","description":"Marching Cubes adaptation of Voxel  Game Evolution.\npress SPACE to start walking.\n\n","likes":16,"published":1,"flags":48,"usePreview":1,"tags":["mc"],"hasliked":0,"parentid":"wsByWV","parentname":"Voxel game Evolution"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*---------------------------------------------------------\n\tfork of Voxel Game Evolution \t\n    \nTIPS:    \n\twhen switching to full screen press L until you get better performance (K for higher resolution)\n   \nCONTROLS:\n    WASD or arrows move\n    space          jump or fly up\n    shift          fly down\n    Q              add blocks\n    E              dig\n    I              inventory\n    F6             decrease rendering distance\n    M              marching cubes on/off\n    page up/down   zoom +/-\n    L/K            pixel size +/-\n    T              random teleport\n    \nTODO:   \n    smooth surface\n    octtree\n    triplanar blending\n\n//-----------------------------------------------------*/\n\n\nvec4 drawSelectionBox(vec2 c) {\n\tvec4 o = vec4(0.);\n    float d = max(abs(c.x), abs(c.y));\n    if (d > 6. && d < 9.) {\n        o.a = 1.;\n        o.rgb = vec3(0.9);\n        if (d < 7.) o.rgb -= 0.3;\n        if (d > 8.) o.rgb -= 0.1;\n    }\n    return o;\n}\n\nmat2 inv2(mat2 m) { return mat2(m[1][1],-m[0][1], -m[1][0], m[0][0]) / (m[0][0]*m[1][1] - m[0][1]*m[1][0]);}\n\nvec4 drawInventory(vec2 c) {\n    \n    float h= (load(_inventory).r>1.?NUM_ITEM_ROWS:1.);\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    vec4 o = vec4(0);\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    float selected = load(_selectedInventory).r;\n    vec2 p = (fract(c / 16.) - .5) * 3.;\n    vec2 u = vec2(sqrt(3.)/2.,.5);\n    vec2 v = vec2(-sqrt(3.)/2.,.5);\n    vec2 w = vec2(0,-1);\n    if (c.x < NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.* h ) {\n        float slot = floor(c.x / 16.) + NUM_ITEMS*floor(c.y / 16.) ;\n    \to = getTexture(48., fract(c / 16.));\n        vec3 b = vec3(dot(p,u), dot(p,v), dot(p,w));\n        vec2 texCoord;\n        //if (all(lessThan(b, vec3(1)))) o = vec4(dot(p,u), dot(p,v), dot(p,w),1.);\n        float top = 0.;\n        float right = 0.;\n        if (b.z < b.x && b.z < b.y) {\n        \ttexCoord = inv2(mat2(u,v)) * p.xy;\n            top = 1.;\n        }\n        else if(b.x < b.y) {\n        \ttexCoord = 1. - inv2(mat2(v,w)) * p.xy;\n            right = 1.;\n        }\n        else {\n        \ttexCoord = inv2(mat2(u,w)) * p.xy;\n            texCoord.y = 1. - texCoord.y;\n        }\n        if (all(lessThanEqual(abs(texCoord - .5), vec2(.5)))) {\n            float id = getInventory(slot);\n            if (id == 3.) id += top;\n            o.rgb = getTexture(id, texCoord).rgb * (0.5 + 0.25 * right + 0.5 * top);\n            o.a = 1.;\n        }\n    }\n    vec4 selection = drawSelectionBox(c - 8. - vec2(16. * mod(selected,NUM_ITEMS), 16.* floor(selected/NUM_ITEMS)));\n    o = mix(o, selection, selection.a);\n    return o;\n}\n\n//--------------------------------------------------------------\n// based on SSAO (Screen Space AO) - by moranzcw - 2021\n// https://www.shadertoy.com/view/WtyfR1\n\n#define PI 3.14159265359\n\n// --------------------------------------\n// oldschool rand() from Visual Studio\n// --------------------------------------\nint   seed = 1;\nvoid  srand(int s ) { seed = s; }\nint   rand(void)  { seed=seed*0x343fd+0x269ec3; return (seed>>16)&32767; }\nfloat frand(void) { return float(rand())/32767.0; }\n// --------------------------------------\n// hash by Hugo Elias\n// --------------------------------------\nint hash( int n ) { n=(n<<13)^n; return n*(n*n*15731+789221)+1376312589; }\nfloat radicalInverse_VdC(uint bits) \n{\n     bits = (bits << 16u) | (bits >> 16u);\n     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n     return float(bits) * 2.3283064365386963e-10;\n }\n\n vec2 Hammersley(uint i, uint N) \n {\n     return vec2(float(i)/float(N), radicalInverse_VdC(i));\n }\n\nvec3 sphereVolumeRandPoint()\n{\n    vec3 p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    while(length(p)>1.0)\n    {\n        p = vec3(frand(),frand(),frand()) * 2.0 - 1.0;\n    }\n    return p;\n}\nfloat pixelSize;\nfloat depth(vec2 coord)\n{\n    vec2 uv = coord*vec2(iResolution.y/iResolution.x,1.0)/pixelSize;\n    return textureLod(iChannel3, uv,0.).a;\n}\n\nfloat avgdepth(vec2 coord,float lod)\n{\n    vec2 uv = coord*vec2(iResolution.y/iResolution.x,1.0)/pixelSize;\n    return textureLod(iChannel3, uv,lod).a;\n}\n\n#define AOradius 2.\n#define Samples 32.0\n\nfloat SSAO_(vec2 coord)\n{\n    float cd = depth(coord);\n    float screenRadius = 0.5 * (AOradius / cd) / 0.53135;\n        \n    float li = 0.0;    \n    float count = 0.0;\n    for(float i=0.0; i<Samples; i++)\n    {\n    \n        vec2 xi = (Hammersley(uint(i), uint(Samples)) *vec2(2.,1.) -vec2(1.,.5)  )* 3.14;            \n        vec3 p = vec3(sin(xi.x)*cos(xi.y),cos(xi.x)*cos(xi.y),sin(xi.y));\n        //vec3 p = sphereVolumeRandPoint() * frand();\n        vec2 sp = vec2(coord.x + p.x * screenRadius, coord.y + p.y * screenRadius);\n         \n        float d = depth(sp);\n        float at = pow(length(p)-1.0, 2.0);\n        li += step(cd + p.z * AOradius, d) * at;\n        count += at;\n    }\n    li/= count;\n    \n\n    \n    //object border highlight   \n    float li3 =0.,w=0.;\n    \n    for(float lod =1. + step(pixelSize,1.5) ;lod<=4.;lod++){\n        float acd = avgdepth(coord,lod);\n        w+=pow(.5, lod);\n        li3 += smoothstep(0.001,-0.001,cd -acd)  *pow(.5, lod);\n    }   \n    li3/=w;\n    \n     return 1.25*(li*.75 +li3 *.25);\n}\n//----------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n     pixelSize = load(_pixelSize).r;\n    vec2  renderResolution = ceil(iResolution.xy / pixelSize); \n    fragColor = textureLod(iChannel3, fragCoord * renderResolution / iResolution.xy / iResolution.xy,0.);\n#ifdef SSAO    \n        // init random seed\n    ivec2 q = ivec2(fragCoord);\n    srand( hash(q.x+hash(q.y+hash(1117*iFrame))));\n    \n    // coordinate\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 coord = fragCoord/iResolution.y;\n    float d = depth(coord);\n    if(d<60.){\n        float ao=  0.7 + .6* SSAO_(coord);\n        fragColor.xyz*= vec3(mix(1., ao, 1.0 - smoothstep(0.0, 0.99, d/60.)));\n    }\n#endif    \n    if(load(_inventory).r>.0){   \n   \t     vec4 gui = drawInventory(fragCoord);\n   \t    fragColor = mix(fragColor, gui, gui.a);\n    }\n    \n\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* ----------------------------------------------------------\n\tCONFIGURABLE SETTINGS\n//----------------------------------------------------------*/\n\n#define MAX_PICK_DISTANCE 20.\n#define TREE_SIZE 9.\n#define SHADOW 1.\n//#define XRAY_MODE\n#define WATER_LEVEL 45.\n#define BEDROCK_LEVEL 30.\n#define MC 2 //1.=nearest blocks 2.=all blocks\n#define SSAO\n//------------------------------------------------------\n\n//SHARED MACROS\n#define var(name, x, y) const vec2 name = vec2(x, y)\n#define varRow 0.\n#define load( coord)  texture(iChannel0, vec2((floor(coord) + 0.5) / iChannelResolution[0].xy)) \n#define load2( coord, res)  texture(iChannel_A, vec2((floor(coord) + 0.5) / res))\n#define getTexture( id,  c) texture(iChannel0, 16. * (clamp(c,0.001,.999) + vec2(mod(id, 8.), floor(id / 8.)+2.)) / iChannelResolution[0].xy, 0.0)\n\n//shared variables are stored in buffer A where  y=0\nvar(_pos, 0, varRow);//_old _pos\nvar(_angle, 2, varRow);\nvar(_mouse, 3, varRow);\nvar(_loadRange_B, 4, varRow);\nvar(_loadRange_C, 5, varRow);\nvar(_vel, 6, varRow);\nvar(_pick, 7, varRow);//_old _pick\nvar(_pickTimer, 8, varRow);  //_old _pickTimer\nvar(_renderScale, 9, varRow);\nvar(_selectedInventory, 10, varRow);\nvar(_flightMode, 11, varRow);\nvar(_sprintMode, 12, varRow);\nvar(_time, 13, varRow);\nvar(_stats, 14, varRow);\nvar(_rayDistMax,15,varRow);\nvar(_loadDistLimit,16,varRow);\nvar(_rayLimit,17,varRow);\nvar(_mc,18,varRow);\nvar(_pixelSize,19,varRow);\nvar(_inventory,20,varRow);\nvar(_demo,21,varRow);\nvar(_mouseBusy,22,varRow);\nvar(_torch,23,varRow);\n//old value are stored in rows with y=n where n is the iFrame difference\nvar(_old, 0, 1); \n\n//BUFFER B\nconst int  BUFFER_B = 1;\nconst vec2 packedChunkSize_B = vec2(9,6);\nconst float heightLimit_B = packedChunkSize_B.x * packedChunkSize_B.y;\n\n//BUFFER C\nconst int  BUFFER_C = 2;\nconst vec2 packedChunkSize_C = vec2(1,1);\nconst float heightLimit_C = packedChunkSize_C.x * packedChunkSize_C.y ;\n\nconst float PI = 3.14159265359;\n\n//INVENTORY ITEMS FOR EACH ROW\nconst float NUM_ITEMS=8.;\n//INVENTORY ROWS\nconst float NUM_ITEM_ROWS=2.;\n\nfloat getInventory(float slot) {\n\treturn slot + 1. + step(2.5, slot);  \n}\n   \n// VOXEL CACHE FUNCTION\nvec2 unswizzleChunkCoord(vec2 storageCoord) {\n \tvec2 s = floor(storageCoord);\n    float dist = max(s.x, s.y);\n    float offset = floor(dist / 2.);\n    float neg = step(0.5, mod(dist, 2.)) * 2. - 1.;\n    return neg * (s - offset);\n}\n\nvec2 swizzleChunkCoord(vec2 chunkCoord) {\n    vec2 c = chunkCoord;\n    float dist = max(abs(c.x), abs(c.y));\n    vec2 c2 = floor(abs(c - 0.5));\n    float offset = max(c2.x, c2.y);\n    float neg = step(c.x + c.y, 0.) * -2. + 1.;\n    return (neg * c) + offset;\n}\n\n\nfloat calcLoadDist_B(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_B); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_B(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_B(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\n\nfloat calcLoadDist_C(vec2 iResolutionxy) {\n    vec2  chunks = floor(iResolutionxy / packedChunkSize_C); \n    float gridSize = min(chunks.x, chunks.y);    \n    return floor((gridSize - 1.) / 2.);\n}\n\nvec4 calcLoadRange_C(vec2 pos,vec2 iResolutionxy, float border) {\n\tvec2 d = (calcLoadDist_C(iResolutionxy) - border)* vec2(-1,1);\n    return floor(pos).xxyy + d.xyxy;\n}\n\n\nvec3 texToVoxCoord(vec2 textelCoord, vec3 offset,int bufferId) {\n\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n\tvec3 voxelCoord = offset;\n    voxelCoord.xy += unswizzleChunkCoord(textelCoord / packedChunkSize);\n    voxelCoord.z += mod(textelCoord.x, packedChunkSize.x) + packedChunkSize.x * mod(textelCoord.y, packedChunkSize.y);\n    return voxelCoord;\n}\n\nvec2 voxToTexCoord(vec3 voxCoord,int bufferId) {\n\n    vec2 packedChunkSize= bufferId==1?packedChunkSize_B:packedChunkSize_C;\n    vec3 p = floor(voxCoord);\n    return swizzleChunkCoord(p.xy) * packedChunkSize + vec2(mod(p.z, packedChunkSize.x), floor(p.z / packedChunkSize.x));\n}\n\n\nstruct voxel {\n\tfloat id;\n    int value; //1=modified,2=selected,3=falling\n    vec2 light;\n    float life;\n    float ground;\n    float surface;\n    int buffer;\n       \n};\n\n//from https://www.shadertoy.com/view/wsBfzW\nfloat gb(float c, float start, float bits){return mod(floor(c/pow(2.,start)),pow(2.,bits));}//get bits\n\n//lazy version:\n#define sb(f,s,b,v) f+=(v-gb(f,s,b))*pow(2.,s)\n//strict version (use in case of strange behaviours):\n//#define sb(f,s,b,v) f+=(clamp(floor(v+.5),0.,pow(2.,b)-1.)-gb(f,s,b))*pow(2.,s)\n\nvoxel decodeVoxel(vec4 t) {\n\tvoxel o;\n    o.id        = gb(t.r,0., 6.);\n    o.value     = int(gb(t.r,6., 2.));\n    \n    o.light.s   = gb(t.g,0., 4.) ;\n    o.light.t   = gb(t.g,4., 4.);\n    o.life      = gb(t.g,8., 4.);\n       \n    o.ground    = gb(t.a,0., 8.);\n    o.surface   = gb(t.a,8., 8.);\n    return o;\n}\n\nvec4 encodeVoxel(voxel v) {\n\tvec4 t=vec4(0.);\n    sb(t.r,0.,6.,v.id);\n    sb(t.r,6.,2.,float(v.value));\n    \n    sb(t.g,0.,4.,v.light.s);\n    sb(t.g,4.,4.,v.light.t);\n    sb(t.g,8.,8.,v.life); \n    \n    sb(t.a,0.,8.,v.ground);\n    sb(t.a,8.,8.,v.surface);\n    return t;\n}\n\nvoxel newVox(float z){\n    voxel vox;\n    vox.life=0.;\n    vox.value=0;\n    vox.ground=200.;\n    vox.surface=0.;\n\tvox.id=0.;\n    vox.light.t = z>10.? 0.:12.;\n    vox.light.s = 15.;\n \tvox.id=0.;\n    vox.buffer=0;\n    return vox;\n}\n\nvec4 readMapTex(vec2 pos, sampler2D iChannel,vec3 resolution) {\n    //return texture(iChannel, (floor(pos) + 0.5) /  (floor (resolution.xy)), 0.0);   \n    return texelFetch(iChannel, ivec2(pos), 0);   \n \n}\n\n\n\n\nvoxel getCachedVoxel(vec3 p,sampler2D iChannel,vec3 resolution,int bufferId) {\n    if(p.z>heightLimit_B || p.z<0.){voxel vox; vox.id=0.; return vox;}\n    voxel vox= decodeVoxel(readMapTex(voxToTexCoord(p, bufferId),iChannel,resolution));\n    vox.buffer=bufferId;\n    return vox;\n}\n\n\n// WORLD GENERATION \n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n    \nfloat hash2(in vec2 p) { return hash(dot(p, vec2(87.1, 313.7))); }\n\nvec2 hash22(in float p) {\n\tfloat x = hash(p);\n\treturn vec2(x, hash(p+x));\n}\n//vec2 hash22(in vec2 p) { return hash2(dot(p, vec2(87.1, 313.7))); }\n\n\nvec2 hash22( vec2 p ) \n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * HASHSCALE4);\n    p4 += dot(p4, p4.wzxy+19.19);\n    return fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\n\n\nfloat snoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,128.852))) * 43758.5453)*2.0-1.0;\n}\nfloat snoise(vec3 p)\n{\n \t\n\tfloat f3 = 1.0/3.0;\n\tfloat s = (p.x+p.y+p.z)*f3;\n\tint i = int(floor(p.x+s));\n\tint j = int(floor(p.y+s));\n\tint k = int(floor(p.z+s));\n\t\n\tfloat g3 = 1.0/6.0;\n\tfloat t = float((i+j+k))*g3;\n\tfloat x0 = float(i)-t;\n\tfloat y0 = float(j)-t;\n\tfloat z0 = float(k)-t;\n\tx0 = p.x-x0;\n\ty0 = p.y-y0;\n\tz0 = p.z-z0;\n\t\n\tint i1,j1,k1;\n\tint i2,j2,k2;\n\t\n\tif(x0>=y0)\n\t{\n\t\tif(y0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order\n\t\telse if(x0>=z0){ i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order\n\t\telse { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }  // Z X Z order\n\t}\n\telse \n\t{ \n\t\tif(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order\n\t\telse if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order\n\t\telse { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order\n\t}\n\t\n\tfloat x1 = x0 - float(i1) + g3; \n\tfloat y1 = y0 - float(j1) + g3;\n\tfloat z1 = z0 - float(k1) + g3;\n\tfloat x2 = x0 - float(i2) + 2.0*g3; \n\tfloat y2 = y0 - float(j2) + 2.0*g3;\n\tfloat z2 = z0 - float(k2) + 2.0*g3;\n\tfloat x3 = x0 - 1.0 + 3.0*g3; \n\tfloat y3 = y0 - 1.0 + 3.0*g3;\n\tfloat z3 = z0 - 1.0 + 3.0*g3;\t\n\t\t\t\t \n\tvec3 ijk0 = vec3(i,j,k);\n\tvec3 ijk1 = vec3(i+i1,j+j1,k+k1);\t\n\tvec3 ijk2 = vec3(i+i2,j+j2,k+k2);\n\tvec3 ijk3 = vec3(i+1,j+1,k+1);\t\n            \n\tvec3 gr0 = normalize(vec3(noise3D(ijk0),noise3D(ijk0*2.01),noise3D(ijk0*2.02)));\n\tvec3 gr1 = normalize(vec3(noise3D(ijk1),noise3D(ijk1*2.01),noise3D(ijk1*2.02)));\n\tvec3 gr2 = normalize(vec3(noise3D(ijk2),noise3D(ijk2*2.01),noise3D(ijk2*2.02)));\n\tvec3 gr3 = normalize(vec3(noise3D(ijk3),noise3D(ijk3*2.01),noise3D(ijk3*2.02)));\n\t\n\tfloat n0 = 0.0;\n\tfloat n1 = 0.0;\n\tfloat n2 = 0.0;\n\tfloat n3 = 0.0;\n\n\tfloat t0 = 0.5 - x0*x0 - y0*y0 - z0*z0;\n\tif(t0>=0.0)\n\t{\n\t\tt0*=t0;\n\t\tn0 = t0 * t0 * dot(gr0, vec3(x0, y0, z0));\n\t}\n\tfloat t1 = 0.5 - x1*x1 - y1*y1 - z1*z1;\n\tif(t1>=0.0)\n\t{\n\t\tt1*=t1;\n\t\tn1 = t1 * t1 * dot(gr1, vec3(x1, y1, z1));\n\t}\n\tfloat t2 = 0.5 - x2*x2 - y2*y2 - z2*z2;\n\tif(t2>=0.0)\n\t{\n\t\tt2 *= t2;\n\t\tn2 = t2 * t2 * dot(gr2, vec3(x2, y2, z2));\n\t}\n\tfloat t3 = 0.5 - x3*x3 - y3*y3 - z3*z3;\n\tif(t3>=0.0)\n\t{\n\t\tt3 *= t3;\n\t\tn3 = t3 * t3 * dot(gr3, vec3(x3, y3, z3));\n\t}\n\treturn 96.0*(n0+n1+n2+n3);\n\t\n}\n\n\n\nfloat overworld(vec3 p) {\n\tfloat density = 48. - p.z;\n    density += mix(0., 40., pow(.5 + .5 * snoise(p.xy /557. + vec2(0.576, .492)), 2.)) * snoise(p / 31.51 + vec3(0.981, .245, .497));\n\n    return density ;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvoxel getGeneratedVoxel(vec3 voxelCoord,bool caves,int frame){\n        voxelCoord.z+=BEDROCK_LEVEL;\n    \tvoxel vox=newVox(voxelCoord.z);\n    \n    \tbool layer[4];\n        \n        float o= overworld(voxelCoord);\n        layer[0]=o>0.;\n        layer[1]=o>1.;\n        layer[2]=o>3.;\n        layer[3]=o>-1.;\n        if( o> -2.5) vox.surface=1.;\n        \n        /*\n    \tfor (int i =0; i <=3 ; i++) {\n            float h;\n            if(i==1) h=1.; \n            else if(i==2) h=3.; \n            else if(i==3)  h=-1.; \n            else h=0.;\n            \n            float o= overworld(voxelCoord+ vec3(0,0,h));\n            layer[i]= (o>0.);\n            if(i==0 && o> -2.) vox.surface=1.;\n            if(!layer[0]) break;\n        }*/\n         \n    \tbool solid = layer[0];\n    \n   \n        if (solid) {\n            //GRASS\n            vox.id = 3.;\n            \n                             \n            //DIRT\n            if (layer[1]) vox.id = 2.; \n            //ROCK\n            if (layer[2]) vox.id = 1.; \n\n            float h= hash13(voxelCoord) ;\n             //GOLD 1 every 200 \n            if (h> 0.995 && layer[2]) {vox.id = 8.;}\n            //DIAMOND 1 every 1000\n            if (h > 0.999 && o>5.) {vox.id = 17.;}\n            \n            //TREE BASE\n            if (h > 0.994 && !layer[1]) {vox.id = 10.;vox.life = 2.+ TREE_SIZE;}\n            //TORCH\n            if (h > 0.999 && !layer[1]) {vox.id = 6.;vox.light.t = 15.;}\n             // CAVE\n            if(caves){\n                caves=snoise(voxelCoord / 27.99 + vec3(0.981, .245, .497).yzx * 17.) > 1. - (smoothstep(0., 5., voxelCoord.z) - 0.7 * smoothstep(32., 48., voxelCoord.z));\n\t        \tif (caves) {vox.id = 0.;}\n            }\n        } \n \t    \n    \t//WATER\n    \tif(vox.id == 0. && voxelCoord.z < WATER_LEVEL) {\n            vox.id=12.; \n            vox.surface=1.;\n                \n         }\n        //GEMS\n        if (hash13(voxelCoord) > 0.995 && voxelCoord.z < 20.  &&  vox.id!=12. && vox.id!=0. ) {if(hash13(voxelCoord +vec3(1.))>.5) vox.id = 6.; else vox.id=8.;}    \n        //BEDROCK\n        if (voxelCoord.z <= BEDROCK_LEVEL) vox.id = 16.; \n               \t\n        return vox;\n\t\t\n}\n\n\n\n// MIX PROCEDURAL AND MEMORY VOXEL\nbool inRange(vec2 p, vec4 r) {\n\treturn (p.x > r.x && p.x < r.y && p.y > r.z && p.y < r.w);\n}\n\n\nvoxel getVoxelData( vec3 voxelCoord,\n                    sampler2D iChannel_B, \n                    sampler2D iChannel_C, \n                    int frame, \n                    vec3 resolution_B, \n                    vec3 resolution_C,\n                    vec4 range_B,\n                    vec4 range_C,\n                    vec3 offset,\n                    bool caves,\n                    int caller){\n  \n    if (inRange(voxelCoord.xy,range_B) && frame > 0 && voxelCoord.z <heightLimit_B  \n        && (caller!=2)  //comment this line to enable persistence between cache (doesn't handle resolution change)\n       ) {\n        return getCachedVoxel(voxelCoord  - offset,iChannel_B,resolution_B,BUFFER_B); \n        \n    }\n\n    if (inRange(voxelCoord.xy,range_C) && frame > 0){\n         if ( voxelCoord.z >= 0.&& voxelCoord.z <heightLimit_C  && (caller==2) ) {\n            // BUFFER C previous frame\n        \treturn getCachedVoxel(voxelCoord - offset,iChannel_C,resolution_C,BUFFER_C); \n         }\n        if(caller!=2){\n        \tvoxel vo= getCachedVoxel(vec3(voxelCoord.xy,0.) - offset,iChannel_C,resolution_C,BUFFER_C);\n         \tif(vo.ground>0. && vo.ground< heightLimit_B  ){\n                //Above max height of BUFFER C --> air\n                float h=voxelCoord.z-vo.ground;\n                if(h==0. ) { vo.surface=1.; return vo;}\n                \n                voxel vox=newVox(voxelCoord.z);\n                vox.surface=1.;\n             \tif(h>0. && caller==3) { \n                   \t//GRASS\n                    if(h==1. &&vo.id==3.) { vox.life=1.;}\n                    \n                    //TREE TRUNK\n                    if(h<TREE_SIZE+2. && vo.id==10. && vo.ground >= WATER_LEVEL-1.) {vox.id=10.; vox.life=2.+TREE_SIZE-h; ;}                   \n                    else if( vo.id==10. && h<TREE_SIZE+3. && vo.ground >= WATER_LEVEL-1.) {vox.id=11.; vox.life=0.; } \n                    return vox;\n\n                }\n             \t\n                if(h>-3. && h<0. && vo.id==11. && caller==3) {\n                    //TREE LEAFS\n                    vox.id=11.; \n                    \n                    vox.life=0.;\n                    return vox;\n                }\n\t\t\t\t\t\n         \t}\n         }\n    }    \n\n\n    return getGeneratedVoxel(voxelCoord,caves,frame);\n\n}\n\nvec4 gRange_B;\nvec4 gRange_C ;\nvec3 gOffset;\nint gRayLimit;\nfloat gMC;\nvoid init(int id, sampler2D iChannel_A,sampler2D iChannel_B, sampler2D iChannel_C, vec2 res){\n\tvec2 f=(id!=3&&id!=0?_old:vec2(0.) );\n     gRange_B = load2(f+_loadRange_B,res);  \n     gRange_C = load2(f+_loadRange_C,res);  \n     gOffset =(id==0?vec3(0.): floor(vec3(load2(f+_pos,res).xy, 0.)));   \n     gMC= load2(_mc,res).r;\n     gRayLimit= int( load2(_rayLimit,res).r);\n}\n\n//WRAPPERS:\n \n#define getCVoxel(p,v,id) \\\n\t{ v= getCachedVoxel(p-gOffset,iChannel1,iChannelResolution[1],1);}\n\n#define getC2Voxel(p,v,id) \\\n\t{ v= getCachedVoxel(p-gOffset,iChannel2,iChannelResolution[2],2);}\n\n#define getVoxel(p,v,id)  \\\n    {v= getVoxelData(p,iChannel1,iChannel2,iFrame,iChannelResolution[1],iChannelResolution[2],gRange_B,gRange_C,gOffset,true,id);}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEY_FORWARDS 87\n#define KEY_BACKWARDS 83\n#define KEY_LEFT 65\n#define KEY_RIGHT 68\n#define KEY_JUMP 32\n#define KEY_SNEAK 16\n#define KEY_PLACE 81\n#define KEY_DESTROY 69\n#define KEY_MC 77\n#define KEY_DECREASE_ZOOM 33\n#define KEY_INCREASE_ZOOM 34\n#define KEY_DECREASE_PIXELSIZE 75\n#define KEY_INCREASE_PIXELSIZE 76\n#define KEY_INCREASE_TIME_SCALE 80\n#define KEY_DECREASE_TIME_SCALE 79\n#define KEY_STATS 114\n#define KEY_DUMP1 115\n#define KEY_DUMP2 116\n#define KEY_TORCH 118\n#define KEY_FLOW 119\n#define KEY_TELEPORT 84\n#define KEY_INCREASE_PERFORMANCE 117\n#define KEY_WORLD 89\n#define KEY_INVENTORY 73\n\n\n//ACTIONS \n\n\n\nbool inBox(vec2 coord, vec4 bounds) {\n    return coord.x >= bounds.x && coord.y >= bounds.y && coord.x < (bounds.x + bounds.z) && coord.y < (bounds.y + bounds.w);\n}\nvec2 currentCoord;\nvec4 outValue;\nbool store4(vec2 coord, vec4 value) {\n    if (inBox(currentCoord, vec4(coord, 1., 1.))) {\n        outValue = value;\n        return true;\n    }\n    else return false;\n}\nbool store3(vec2 coord, vec3 value) { return store4(coord, vec4(value, 1)); }\nbool store2(vec2 coord, vec2 value) { return store4(coord, vec4(value, 0, 1)); }\nbool store1(vec2 coord, float value) { return store4(coord, vec4(value, 0, 0, 1)); }\n\nfloat keyDown(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., .5/3.), 0.0).r;   \n}\n\nfloat keyPress(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 1.5/3.), 0.0).r;   \n}\n\nfloat keySinglePress(int keycode) {\n    bool now = bool(keyDown(keycode));\n    bool previous = bool(texture(iChannel0, vec2(256. + float(keycode) + 0.5, 0.5) / iResolution.xy, 0.0).r);\n    return float(now && !previous);\n}\n\n\nfloat keyToggled(int keyCode) {\n    return texture(iChannel2, vec2((float(keyCode) + 0.5) / 256., 2.5/3.), 0.0).r;   \n}\n\nfloat rectangleCollide(vec2 p1, vec2 p2, vec2 s) {\n    return float(all(lessThan(abs(p1 - p2), s)));   \n}\n\nfloat horizontalPlayerCollide(vec2 p1, vec2 p2, float h) {\n    vec2 s = (vec2(1) + vec2(.6, h)) / 2.;\n    p2.y += h / 2.;\n    return rectangleCollide(p1, p2, s);\n}\n\n\n\nfloat isSolidVoxel(bool slope,vec3 p) {\n    voxel t;\n    getCVoxel(p,t,0);\n    float solid=  (t.id==0. )?0.:1.;\n    return solid * (!slope ?1.:0.);\n}\n\nstruct rayCastResults {\n    bool hit;\n    vec3 mapPos;\n    vec3 normal;\n};\n\nrayCastResults  getMouseRay(){\n       \n   vec4 mouseRay=  texture(iChannel3, vec2(0.));\n   rayCastResults res;\n   res.hit = mouseRay.a!=0.;\n   res.mapPos = mouseRay.rgb;\n    \n   float eN = mouseRay.a -1.;\n   res.normal=vec3(mod(eN,3.),floor(mod(eN,9.)/3.),floor(eN/9.))- vec3(1.);  \n   return res;\n}\n\nfloat mouseSelect(vec2 c,float h) {\n\tfloat scale = floor(iResolution.y / 128.);\n    c /= scale;\n    vec2 r = iResolution.xy / scale;\n    float xStart = (r.x - 16. * NUM_ITEMS) / 2.;\n    c.x -= xStart;\n    if (c.x <NUM_ITEMS * 16. && c.x >= 0. && c.y < 16.*h) {\n        float slot = floor(c.x / 16.) + NUM_ITEMS*floor(c.y / 16.);\n    \treturn slot;\n    }\n\n    return -1.;\n}\n\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n//From https://www.shadertoy.com/view/4djGRh\nfloat tileableWorley(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n\t\t\tvec2 tp = floor(p) + vec2(xo, yo);\n\t\t\ttp = p - tp - hash22(256. * mod(tp, numCells));\n\t\t\td = min(d, dot(tp, tp));\n\t\t}\n\t}\n\treturn sqrt(d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\nfloat crackingAnimation(vec2 p, float t) {\n    t = ceil(t * 8.) / 8.;\n\tfloat d = 1.0e10;\n    //t *= ;\n    for (float i = 0.; i < 25.; i++) {\n    \tvec2 tp = hash22(p )-.5; //texture(iChannel1, vec2(4, i) / 256.).xy - 0.5;\n        tp *= max(0., (length(tp) + clamp(t, 0., 1.) - 1.) / length(tp));\n        d = min(d, length(tp + 0.5 - p));\n    }\n    return pow(mix(clamp(1. - d * 3., 0., 1.), 1., smoothstep(t - 0.3, t + 0.3, max(abs(p.x - 0.5), abs(p.y - 0.5)) * 2.)), .6) * 1.8 - 0.8;\n}\n\nfloat brickPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x - 4. * step(4., mod(c.y, 8.)), 8.) > 7.) o = 0.;\n    return o;\n}\nfloat woodPattern(vec2 c) {\n\tfloat o = 1.;\n    if (mod(c.y, 4.) < 1.) o = 0.;\n    if (mod(c.x + 2. - 6. * step(4., mod(c.y, 8.)), 16.) > 15.) o = 0.;\n    return o;\n}\n\n\n\n\n//textures from https://www.shadertoy.com/view/4ds3WS by Reinder\nvoid setTexture( out vec4 o, in vec2 fragCoord )\n{\n    \n \tif(fragCoord.x>8.*16. || fragCoord.y >10.*16.) discard;\n    vec2 gridPos = floor((fragCoord -vec2(0.,32.))/ 16.) ;\n    vec2 c = mod(fragCoord, 16.);\n    int id = int(gridPos.x + gridPos.y * 8.);\n \n   \n    vec2 uv = floor( c );\t\n    float h = hash12(uv +vec2(float(id)));\n    float br = 1. - h * (96./255.);\t\t\n\tfloat xm1 = mod((uv.x * uv.x * 3. + uv.x * 81.) / 4., 4.);\n\n    if (iFrame > 10 && iChannelResolution[0].x > 0. && id!=32  ) discard;\n    o.a = 1.;\n    if (id == 0) { //NO TEXTURE\n    \to = vec4(1,0,1,1);\n    }\n    if (id == 1) { //STONE\n       \n        o.rgb =  vec3( 127./255., 127./255., 127./255.) *br;        \n    }\n    if (id == 2) { //DIRT\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n    }\n    if (id == 3) { //GRASS LATERAL\n        \n        o.rgb =  vec3( 150./255., 108./255.,  74./255.) *br;\n        if (c.y  + hash( c.x*2.) *3.  > 14. ) \n         o.rgb =  vec3( 106./255., 177./255.,  79./255.)*br;\n    }\n    if (id == 4) { //GRASS UP\n   \t\t\n        o.rgb = vec3( 106./255., 177./255.,  79./255.)*br;\n    }\n    if (id == 5) { //ROCK\n       \n        o.rgb = vec3( 106./255., 170./255.,  64./255.)*br;\n        o.rgb = vec3(clamp(pow(1. - tileableWorley(c / 16., 4.), 2.), 0.2, 0.6) + 0.2 * tileableWorley(c / 16., 5.));\n \n    }\n    if (id == 6 || id == 26) {//LIGHT OR FIREFLY\n        float w = 1. - tileableWorley(c / 16., 4.);\n        float l = clamp(0.7 * pow(w, 4.) + 0.5 * w, 0., 1.);\n        o.rgb = mix(vec3(.3, .1, .05), vec3(1,1,.6), l);\n        if (w < 0.2) o.rgb = vec3(0.3, 0.25, 0.05);\n    }\n    if (id == 7) { //BRICK\n        o.rgb = vec3( 181./255.,  58./255.,  21./255.)*br; \n\t\tif ( mod(uv.x + (floor(uv.y / 4.) * 5.), 8.) == 0. || mod( uv.y, 4.) == 0.) {\n\t\t\to.rgb = vec3( 188./255., 175./255., 165./255.); \n\t\t}\n        \n    \t//o.rgb = -0.1 * hash12(c) + mix(vec3(.6,.3,.2) + 0.1 * (1. - brickPattern(c + vec2(-1,1)) * brickPattern(c)), vec3(0.8), 1. - brickPattern(c));\n    }\n    if (id == 8) {//GOLD\n    \to.rgb = mix(vec3(1,1,.2), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n        if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(1,.8,.1);\n    }\n    if (id == 9) { //WOOD\n        \n         o.rgb= vec3(0.5,0.4,0.25)*(0.5 + 0.5 * woodPattern(c))*br;        \n    }    \n    if (id == 10) {//TREE\n\t\t\n        if ( h < 0.5 ) {\n\t\t\tbr = br * (1.5 - mod(uv.x, 2.));\n\t\t}\n        o.rgb = vec3( 103./255., 82./255.,  49./255.)*br; \t\t\t\t\n\t}\t\n    if (id == 11) {//LEAF\n\t        o.rgb=  vec3(  20./255., 67./255.,  19./255.)*br;\t\t\n\t}\n    if (id == 12) {//WATER\t\t\n        o.rgb=vec3(  98./255.,  98./255., 236./255.)*br;\t\t\n\t}\t\n    if (id == 13) {//SAND\n\t\t//getMaterialColor(10,c,o.rgb);\n\t\to.rgb= vec3(0.733,0.655,0.365);\n\t}\t\n    if (id == 14) {//RED APPLE\t- MIRROR\t\n\t\to.rgb= vec3(.95,0.,0.05);\n       \n\t}\n    if (id == 15) {//PINK MARBLE\t\n        o.rgb= vec3(.95,0.5,.5)*br;\n    \t//o.rgb = mix(vec3(.2,1,1), vec3(1,.8,.1), sin((c.x - c.y) / 3.) * .5 + .5);\n       // if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n    if (id == 16) { //BEDROcK\n        \n    \n        o.rgb =   .2*vec3( 127./255., 127./255., 127./255.) *br;   \n    }\n    if (id == 17) {//DIAMOND\t\n       \n    \to.rgb = mix(vec3(.2,1,1), vec3(.1,.8,1), sin((c.x - c.y) / 3.) * .5 + .5);\n       if (any(greaterThan(abs(c - 8.), vec2(7)))) o.rgb = vec3(.1,.8,1);\n       \n\t}\n \n    if (id == 32) { //DESTROYING BLOCK ANIMATION\n    \to.rgb = vec3(crackingAnimation(c / 16., load(_pickTimer).r));\n    }\n    if (id == 48) { \n    \to = vec4(vec3(0.2), 0.7);\n        vec2 p = c - 8.;\n        float d = max(abs(p.x), abs(p.y));\n        if (d > 6.) {\n            o.rgb = vec3(0.7);\n            o.rgb += 0.05 * hash12(c);\n            o.a = 1.;\n            if ((d < 7. && p.x < 6.)|| (p.x > 7. && abs(p.y) < 7.)) o.rgb -= 0.3;\n        }\n        o.rgb += 0.05 * hash12(c);\n        \n    }\n    \n}\n\n/*--------------------\n\nx=0 && y<256: global variables\nx=0 &&  256<=y<512: keyboard state for each ascii code with millisecs since laste change\n1<=x<30 y<512: previous values fo variables and keys\n30<=x<32 y<512: Marching cubes tables\nx<= 128 && 16<=y< 140 : textures \n\n*///-------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    currentCoord = fragCoord;\n    if(fragCoord.x>512. || fragCoord.y >160.) discard;\n    vec2 texCoord = floor(fragCoord);\n    if (texCoord.x < 512. && texCoord.y<30.) {\n        if (texCoord.y == varRow) {\n            if (texCoord.x >= 256.) {\n                fragColor.r = texture(iChannel2, (fragCoord - 256.) / vec2(256,3)).r;\n                vec4 old = texture(iChannel0, (_old + fragCoord) / iChannelResolution[0].xy);\n                if (fragColor.r != old.r) old.a = 0.;\n                fragColor.a = old.a + iTimeDelta;\n            }\n            else {\n                vec3 pos = load(_pos).xyz;\n                vec3 oldPos = pos;\n                vec3 offset = vec3(floor(pos.xy), 0.);\n                vec2 angle = load(_angle).xy;\n                vec4 oldMouse = load(_mouse);\n                vec3 vel = load(_vel).xyz;\n                vec4 mouse = iMouse / length(iResolution.xy);\n                float renderScale = load(_renderScale).r;\n                vec2 time = load(_time).rg;\n                vec2 flightMode = load(_flightMode).rg;\n                vec2 sprintMode = load(_sprintMode).rg;\n                float selected = load(_selectedInventory).r;\n                float dt = min(iTimeDelta, .05);\n                float rayDistMax = max(load(_rayDistMax).r,50.);\n                float pixelSize =load(_pixelSize).r;\n                float inventory =load(_inventory).r;\n                float demo =load(_demo).r;\n                float mcube =load(_mc).r;\n                   \n                if (iFrame <2  ) {\n \n                    pos = vec3(2952.8,10140.8,65.-BEDROCK_LEVEL);\n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;\n                    angle = vec2(0.8,2.1 );                   \n                 \n                    demo=1.;\n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -3.;\n                    time = vec2(0.,0);\n                    selected = 0.;\n                    inventory=0.;\n                    rayDistMax=100.;\n                    mcube=1.;\n                    pixelSize=2.;\n                }\n                if(demo>0. && \n                   (keyDown(KEY_JUMP)>.0||keyDown(KEY_FORWARDS)>0. ))\n                {\n              \n                    demo=0.;\n                }\n                \n                if ( bool(keyDown(KEY_TELEPORT))) {\n\t\t\t\t\t\n                    if(hash(iTime) <.5) pos=vec3(3221.5,10159.5,65.-BEDROCK_LEVEL);\n                    else pos =vec3(hash33(pos).xy *10000.,32.); \n                       \n                    offset = vec3(floor(pos.xy), 0.);\n                    oldPos = pos;                \n                    oldMouse = vec4(-1);\n                    vel = vec3(0);\n                    renderScale = -3.;                  \n                    selected = 0.;\n                   \n                }\n                if (oldMouse.z > 0. && iMouse.z > 0. )\n                    if(1==1){\n                        float zoom = pow(10., load(_renderScale).r/10.);\n                        angle += 5.*(mouse.xy - oldMouse.xy) * vec2(-1,-1)/zoom;\n                        angle.y = clamp(angle.y, 0.1, PI - 0.1);\n                    }\n                vec3 dir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n                vec3 dirU = vec3(normalize(vec2(dir.y, -dir.x)), 0);\n                vec3 dirV = cross(dirU, dir);\n                vec3 move = vec3(0);\n\n                \n                vec3 dirFwd = vec3(cos(angle.x), sin(angle.x), 0);;\n                    vec3 dirRight = vec3(dirFwd.y, -dirFwd.x, 0);\n                vec3 dirUp = vec3(0,0,1);\n                \n                float inBlock = 0.;      \n                vec3  vColPos, hColPos;\n                \n                //z of closest  blocks below\n                float minHeight = 0.; \n                \n                //z of closest  blocks above\n                float maxHeight = 1000.;\n                \n                //XY of closest lateral blocks\n                float minX = pos.x - 1000.; \n                float maxX = pos.x + 1000.;\n                float minY = pos.y - 1000.;\n                float maxY = pos.y + 1000.;\n#ifndef XRAY_MODE\n                if(isSolidVoxel(false,pos-offset) >.5)  pos.z+=clamp(3./iTimeDelta,.3,1.);\n                \n                //DOWN\n                for (float i = 0.; i < 4.; i++) {\n                    vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z - 1. - i));\n                    float solid=0.;\n                    for(int j=0;j<4;j++){\n                        solid+=\n                          isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                    }\n                    if ( solid> .5) {\n                        minHeight = vColPos.z + 1.001; \n                        inBlock = 1.;\n                        break;\n                    }\n                }\n\t\t\t\t\n                //UP\n                vColPos = vec3(floor(pos.xy - 0.5), floor(pos.z + 1.8 + 1.));\n                float solidUp=0.;\n                for(int j=0;j<4;j++){\n                 \tsolidUp+= isSolidVoxel(false,vColPos - offset + vec3(j/2,j%2,min(iFrame,0))) * rectangleCollide(vColPos.xy + vec2(0.5 +float(j/2),0.5+float(j%2)), pos.xy, vec2(.8));\n                }\n\t\t\t\tif(  solidUp > .5) {\n                    maxHeight = vColPos.z - 1.8 - .001; \n                    inBlock = 1.;     \n\n                }\n               \n                //LATERAL\n                float solidL[4];\n                for(int i=0;i<4;i++){\n                    vec2 posL;\n                    vec2 hColPosL;\n                    if(i==0) {hColPos = vec3(floor(pos.xy - vec2(.3, .5)) + vec2(-1,0), floor(pos.z)); hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==1) {hColPos = vec3(floor(pos.xy - vec2(-.3, .5)) + vec2(1,0), floor(pos.z));hColPosL=hColPos.yz;posL=pos.yz;}\n                    if(i==2) {hColPos = vec3(floor(pos.xy - vec2(.5, .3)) + vec2(0,-1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    if(i==3) {hColPos = vec3(floor(pos.xy - vec2(.5, -.3)) + vec2(0,1), floor(pos.z));hColPosL=hColPos.xz;posL=pos.xz;}\n                    solidL[i]=0.;\n                    for(int j=0;j<6;j++){\n                        \n       \n                        solidL[i ] += isSolidVoxel(true,hColPos - offset + vec3((i/2)*(j%2),(1-i/2)*(j%2),(j/2)+min(iFrame,0))) \n                            * horizontalPlayerCollide(hColPosL + vec2(0.5+float(j%2), 0.5+float(j/2)), posL, 1.8);\n                    }\n                \n                    if(i==0 && solidL[i]>.5) minX = hColPos.x + 1.301;\n                    if(i==1 && solidL[i]>.5) maxX = hColPos.x - .301;\n                    if(i==2 && solidL[i]>.5) minY = hColPos.y + 1.301;\n                    if(i==3 && solidL[i]>.5) maxY = hColPos.y - .301;\n                }\n                \n\n                \n                if (abs(pos.z - minHeight) < 0.01) flightMode.r = 0.; \n#else\n                flightMode.rg=vec2(.3,1.);\n                if(iFrame==0) pos.z=65.;\n#endif\n                \n                if (bool(keySinglePress(KEY_JUMP))) {\n                    if (flightMode.g > 0.) {\n                        flightMode.r = 1.- flightMode.r;\n                        sprintMode.r = 0.;\n                    }\n                    flightMode.g = 0.3;\n                }\n                flightMode.g = max(flightMode.g - dt, 0.);\n\n                if (bool(keySinglePress(KEY_FORWARDS))) {\n                    if (sprintMode.g > 0.) sprintMode.r = 1.;\n                    sprintMode.g = 0.3;\n                }\n                if (!bool(keyDown(KEY_FORWARDS))) {\n                    if (sprintMode.g <= 0.) sprintMode.r = 0.;\n                }\n                sprintMode.g = max(sprintMode.g - dt, 0.);\n\n                vec3 stats =vec3(\n                    bool(keyToggled(KEY_STATS))?1.:0.,\n                    bool(keyToggled(KEY_DUMP1))?1.:0.,\n                    bool(keyToggled(KEY_DUMP2))?1.:0.\n                );\n                float torch = bool(keyToggled(KEY_TORCH))?1.:0.;\n                float flow = bool(keyToggled(KEY_FLOW))?1.:0.;\n                \n\n                inventory = floor(mod( inventory + keyPress(KEY_INVENTORY),3.));\n                if(inventory<2.) selected=clamp(selected,0., NUM_ITEMS-1.);\n\n\n                mcube = floor(mod( mcube + keyPress(KEY_MC),2.));\n                float loadDistLimit=80.;\n                float rayLimit=350.; \n                if(bool(keyToggled(KEY_INCREASE_PERFORMANCE))){        \n                    pixelSize=max(2.,pixelSize) ;\n                    loadDistLimit=50.;\n                    rayLimit=200.;\n                }\n                pixelSize=clamp( pixelSize  + keyPress(KEY_INCREASE_PIXELSIZE) - keyPress(KEY_DECREASE_PIXELSIZE)  ,1.,4.);\n\n\n                if (bool(flightMode.r)) {\n                    if (length(vel) > 0.) vel -= min(length(vel), 25. * dt) * normalize(vel);\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    vel += 50. * dt * dirUp * sign(keyDown(KEY_JUMP) - keyDown(KEY_SNEAK));\n                    if (length(vel) > 20.) vel = normalize(vel) * 20.;\n                }\n                else {\n                    vel.xy *= max(0., (length(vel.xy) - 25. * dt) / length(vel.xy));\n                    vel += 50. * dt * dirFwd * sign(keyDown(KEY_FORWARDS)-keyDown(KEY_BACKWARDS)+keyDown(38)-keyDown(40));\n                    vel += 50. * dt * dirFwd * 0.4 * sprintMode.r;\n                    vel += 50. * dt * dirRight * sign(keyDown(KEY_RIGHT)-keyDown(KEY_LEFT)+keyDown(39)-keyDown(37));\n                    if (abs(pos.z - minHeight) < 0.01) {\n                        vel.z = 9. * keyDown(32);\n                    }\n                    \n                    else {\n                        vel.z -= 32. * dt;\n                        vel.z = clamp(vel.z, -80., 30.);\n                    }\n\t\t\t\t\t\n                    if (length(vel.xy) > 4.317 * (1. + 0.4 * sprintMode.r)) vel.xy = normalize(vel.xy) * 4.317 * (1. + 0.4 * sprintMode.r);\n                }\n\n                if(demo>0.)vel=dirFwd*20.;\n                pos += dt * vel; \n                if (pos.z < minHeight) {\n                    pos.z = minHeight;\n                    vel.z = 0.;\n                }\n                if (pos.z > maxHeight ) {\n                    pos.z = maxHeight;\n                    vel.z = 0.;\n                }\n                \n                if (pos.x < minX) {\n                    pos.x = minX;\n                    vel.x = 0.;\n                }\n                if (pos.x > maxX) {\n                    pos.x = maxX;\n                    vel.x = 0.;\n                }\n                if (pos.y < minY) {\n                    pos.y = minY;\n                    vel.y = 0.;\n                }\n                if (pos.y > maxY) {\n                    pos.y = maxY;\n                    vel.y = 0.;\n                }\n\n                float timer = load(_old+_pickTimer).r;\n                vec4 oldPick = load(_old+_pick);\n                vec4 pick;\n                float pickAction;\n                           \n                rayCastResults mousePointer = getMouseRay();\n\n                \n                if (iMouse.z > 0. ) {                    \n                    \n                    float h= (inventory>1.?NUM_ITEM_ROWS:1.);\n                    float slot = mouseSelect(iMouse.xy,h);\n                    if(slot>= 0. && inventory>0. ){\n                        selected = slot;\n                    }\n                    else {\t\n                    \n                    if (mousePointer.hit ) {\n                        pick.xyz = mousePointer.mapPos;\n                        if (bool(keyDown(KEY_DESTROY))) {\n                            pick.a = 1.;\n                            store1(_pick,pick.a);\n                            timer += dt / 0.25;\n                        }\n                        \n                         if ( bool(keyDown(KEY_PLACE)) ) {\n                            pick.a = 2.;\n                            //pick.xyz += mousePointer.normal;                           \n                            timer += dt / 0.25;                                                    \n                        }\n                        if (oldPick != pick) timer = 0.;\n                    }\n                    else {\n                        \n                        timer = 0.;\n                    }\n                }\n                }\n\n                renderScale = clamp(renderScale + keySinglePress(KEY_DECREASE_ZOOM) - keySinglePress(KEY_INCREASE_ZOOM), -5., 10.);\n                time.g = clamp(time.g + keySinglePress(KEY_INCREASE_TIME_SCALE) - keyPress(KEY_DECREASE_TIME_SCALE), 0., 8.);\n                time.r = mod(time.r + dt * sign(time.g) * pow(2., time.g - 1.), 1200.);\n\n                bool still= length(pos-oldPos)<0.01 && length(angle -load(_angle).xy )<0.01  &&  iMouse.z<1.;\n                rayDistMax= rayLimit;/*clamp(rayDistMax  \n                                  +(still?10.:0.) \n                                  - ((iTimeDelta>0.03 && !still)?5.:0.)\n                                  -((iTimeDelta>0.1)?1.:0.) \n                                  -((iTimeDelta>0.1  && !still)?50.:0.) \n                                  + ((iTimeDelta<0.03 && still)?20.:0.)\n                                  ,loadDistLimit*2.5,rayLimit);*/\n\n\n                store3(_pos, pos);\n                store2(_angle, angle);\n                store4(_loadRange_B,calcLoadRange_B(pos.xy,iChannelResolution[1].xy,0.));\n                store4(_loadRange_C,calcLoadRange_C(pos.xy,iChannelResolution[1].xy,0.));\n                store4(_mouse, mouse);\n                store3(_vel, vel);\n                store4(_pick, pick);\n                store1(_pickTimer, timer);\n                store1(_renderScale, renderScale);\n                store1(_selectedInventory, selected);\n                store2(_flightMode, flightMode);\n                store2(_sprintMode, sprintMode);\n                store2(_time, time);\n                store3(_stats, stats);\n                store1(_rayDistMax, rayDistMax);\n                store1(_loadDistLimit, loadDistLimit);\n                store1(_rayLimit, rayLimit);\n                store1(_mc, mcube);\n                store1(_pixelSize,pixelSize);\n                store1(_inventory,inventory);\n                store1(_demo,demo);\n                store1(_torch,torch);\n\n                fragColor = outValue;\n            }\n        }  \n        else fragColor = texture(iChannel0, (fragCoord - _old) / iChannelResolution[0].xy);\n    }\n#ifdef MC    \n    else if (texCoord.x < 512. && texCoord.y<32.) {\n            if(iFrame>3) discard;\n            else if(texCoord.y<31.&& texCoord.x<256.)\n            {\n               int _edgeTable[256]= int[256](\n                -1   , 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c, 0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00, \n                0x190, 0x099, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c, 0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90, \n                0x230, 0x339, 0x033, 0x13a, 0x636, 0x73f, 0x435, 0x53c, 0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30, \n                0x3a0, 0x2a9, 0x1a3, 0x0aa, 0x7a6, 0x6af, 0x5a5, 0x4ac, 0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0, \n                0x460, 0x569, 0x663, 0x76a, 0x066, 0x16f, 0x265, 0x36c, 0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60, \n                0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0x0ff, 0x3f5, 0x2fc, 0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0, \n                0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x055, 0x15c, 0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950, \n                0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0x0cc, 0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0, \n                0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc, 0x0cc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0, \n                0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c, 0x15c, 0x055, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650, \n                0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc, 0x2fc, 0x3f5, 0x0ff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0, \n                0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c, 0x36c, 0x265, 0x16f, 0x066, 0x76a, 0x663, 0x569, 0x460, \n                0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, 0x4ac, 0x5a5, 0x6af, 0x7a6, 0x0aa, 0x1a3, 0x2a9, 0x3a0, \n                0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, 0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x033, 0x339, 0x230, \n                0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, 0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x099, 0x190, \n                0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, 0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0\n               );\n               fragColor=vec4(_edgeTable[int(texCoord.x)]);\n           }\n           else if(texCoord.y<32.&& texCoord.x<128.){\n           \n            int  _triTableCompact[512] = int[512](\n                65535,65535,65535,65535, 62336,65535,65535,65535, 63760,65535,65535,65535, 37761,65304,65535,65535,\n                64033,65535,65535,65535, 4992,65442,65535,65535, 2601,65426,65535,65535, 9090,39562,65528,65535,\n                62131,65535,65535,65535, 33456,65291,65535,65535, 8337,65459,65535,65535, 4785,35257,65531,65535,\n                45475,65338,65535,65535, 416 ,47272,65530,65535, 12435,43931,65529,65535, 43657,65464,65535,65535, \n                63604,65535,65535,65535, 28724,65347,65535,65535, 35088,65396,65535,65535, 18708,14103,65521,65535,\n                35361,65396,65535,65535, 14147,8512,65530,65535, 39465,18464,65527,65535, 10658,29305,18803,65535, \n                14152,65323,65535,65535, 46923,578 ,65524,65535, 33033,12916,65531,65535, 39796,47540,4754,65535,\n                12707,34731,65524,65535, 6833,436 ,19316,65535,  39028,47536,12474,65535, 19316,47515,65530,65535, \n                62553,65535,65535,65535, 1113,65336,65535,65535, 5200,65285,65535,65535, 33880,4947,65525,65535,\n                39457,65349,65535,65535, 6147,38050,65525,65535, 23077,1060,65522,65535, 13730,21330,33844,65535,\n                9305,65459,65535, 65535, 688 ,38072,65525,65535, 1104,12881,65531,65535, 9490,33413,22603,65535,\n                43834,22833,65524,65535, 1428,43032,43905,65535, 20549,46512,12474,65535, 22597,35496,65531,65535,\n                22649,65431,65535,65535,36921,30005,65523,65535, 2160,20849,65527,65535, 13137,  65397,65535,65535,\n                39033,6773,65522,65535,  37402,13573,14160,65535, 33288,22610,9639,65535, 9634,21301,65527,65535, \n                30103,45976,65522,65535, 38745,10535,46880,65535, 2866,29057,29976,65535, 45355,6001,65525,65535,\n                34905,6773,45987,65535, 20597,46992,40976,61611, 45227,23088,28800,61557, 30123,65371,65535,65535,\n                62826,65535,65535,65535, 21376,65386,65535,65535, 20745,65386,65535,65535,4993,42377,65526,65535, \n                9569,65302,65535,65535, 5473,866  ,65528,65535, 38249,8288,65526,65535, 22677,9512,33334,65535,\n                43826,65366,65535,65535, 47115,27138,65525,65535, 10512,42419,65526,65535, 5797,47401,47250,65535, \n                27446,5429,65523,65535, 2944,20571,27473,65535, 1715,24675,38149,65535, 26966,39865,65528,65535,\n                18085,65415,65535,65535, 16436,22071,65530,65535, 20625,18538,65527,65535, 5482, 29049,18803,65535,\n                25110,29717,65528,65535, 21793,866 ,29748,65535, 38728,24656,25093,65535, 31031,9033,26969,63842,\n                29363,27208,65525,65535, 18085,9255,46880,65535, 18704,12935,27227,65535, 37161,18731,19323,63141, \n                14152,21339,27473,65535, 23317,363 ,19323,64320, 2384,12374,14006,63304, 26966,29881,39801,65535,\n                26954,65444,65535,65535, 18084,32937,65523,65535, 41226,17926,65520,65535,33080,26721,41316,65535,\n                6465,25154,65524,65535, 6147,17042,17961,65535, 17440,65378,65535,65535, 33336,9282,65526,65535,\n                43338,11078,65523,65535, 8832,38072,27210,65535, 691 ,24673,41316,65535, 24902,33953,45345,61880,\n                37993,6499,14003,65535, 33208,27393,16785,61766, 14003,24582,65524,65535, 47174,65414,65535,65535,\n                30375,39080,65530,65535, 880,36986,42858,65535, 5994,29050,2072,65535, 42858,28951,65523,65535, \n                5665,33158,30345,65535, 10594,30233,14601,63799, 28807,1632,65522,65535, 25143,65319,65535,65535,\n                43826,35462,30345,65535, 9986,37047,42855,63401, 4225,41351,42855,64306, 45355,27249,5985,65535, \n                34456,6518,14006,63025, 45456, 65398,65535,65535, 28807,45920,1712,65535, 63159,65535,65535,65535\n                );\n                int id= int(texCoord.x)*4;\n                fragColor= vec4(_triTableCompact[id],_triTableCompact[id+1],_triTableCompact[id+2],_triTableCompact[id+3] );\n           }\n           else if(texCoord.y<32.&& texCoord.x<256.){\n             \n             int  _triTableCompact[512] = int[512](   \n                64359,65535,65535,65535, 47107,65383,65535,65535, 47376,65383,65535,65535, 35096,31507,65526,65535,\n                25114,65403,65535,65535, 14881,46720,65527,65535, 8338,46746,65527,65535, 10166,35386,35235,65535,\n                25383,65394,65535,65535, 30727,9734,65520,65535, 9842,4211,65529,65535, 4705,37224,26504,65535,\n                42618,12657,65527,65535, 5754,33191,32791,65535, 1840,41127,31337,65535, 31335,43146,65529,65535,\n                46214,65384,65535,65535, 15203,16480,65526,65535, 35688,2404,65521,65535, 38473,14646,25521,65535,\n                25734,41611,65521,65535, 14881,24752,25611,65535, 18612,8374,39465,65535, 41882,18723,25523,62308,\n                33576,25636,65522,65535, 16960,65318,65535,65535, 8337,16963,33606,65535, 5265,16932,65526,65535, \n                33560,18454,6758, 65535, 40986,1632,65524,65535, 17252,42627,37635,62362, 25754,65354,65535,65535, \n                30100,65462,65535,65535, 17280,31577,65526,65535,20741,26372,65531,65535, 34427,21315,20788,65535,\n                42073,26401,65531,65535, 6070,32930,22851,65535, 23399,9380,8266,65535, 14403,9029,9637,63099, \n                29479,17702,65529,65535, 1113,24680,30818,65535, 12899,20839,1104,65535, 26662,4728,22600,63569, \n                42073,29025,29462,65535, 6753,359 ,1927,62553, 18948,12378,31338,64115, 31335,17802,43082,65535,\n                26006,35739,65529,65535, 2915,20534,22790,65535, 2224,4277,46677,65535, 25526,13651,65521,65535, \n                39457,47541,26040,65535, 944 ,37046,38486,64033, 46475,2149,9637,62752, 25526,41555,13731,65535,\n                22917,25986,10290,65535, 38489,24582,65522,65535, 6225,25864,10296,63526, 9809,65377,65535,65535,\n                5681,33702, 38486,63128, 40986,22880,1616,65535, 22576,65446,65535,65535, 63066,65535,65535,65535, \n                31323,65461,65535,65535, 47707,14423,65520,65535, 22453,37306,65520,65535, 42362,35195,4993,65535, \n                45595,22295,65521,65535, 4992,29042,45685,65535, 38265,2418,31522,65535, 29271,38322,33330,62089,\n                10834,29523,65525,65535, 32808,30757,21157,65535, 20745,13626,10807,65535, 37513,30738,21154,62039,\n                13617,65367,65535,65535, 1920,28951,65525,65535, 37641,13651,65527,65535, 22409,65401,65535,65535, \n                21637,47754,65528,65535, 21509,42251,955 ,65535, 35088,43172,21675,65535, 42170,15188,5268,62483, \n                8530,45656,34120,65535, 2880,21563,6955,64277, 1312,45717,34117, 62859, 9545,65339,65535,65535, \n                14930,17189,18485,65535, 21157,9282,65520,65535, 12963,33701,34117,63760, 21157,37186,9362,65535, \n                34120,21301,65521,65535, 5440,65360,65535,65535, 34120,2357,21253,65535, 62793,65535,65535,65535, \n                18356,43449,65531,65535, 17280, 47481,47767,65535, 7073,16715,46192,65535, 13331,41348,46196,62650,\n                38836,10571,8603,65535, 38009,6523,6955,62336, 46203,16932,65520,65535, 46203,14372,16948,65535, \n                10898,12951,38007,65535, 38825,10823,1927,63234, 14963,18218,2586,64004, 33441,65351,65535,65535,\n                16788,6001,65523,65535, 16788,32881,6017,65535, 29444,65332,65535,65535, 63364,65535,65535,65535,\n                43177,65419,65535,65535, 14595,39865,65530,65535, 2576,43146,65531,65535, 47635,65443,65535,65535, \n                6945,47515,65528,65535, 14595,8633,39721,65535, 35616, 65456,65535,65535, 64291,65535,65535,65535,\n                10290,35496,65529,65535, 681 ,65321,65535,65535, 10290,4264,35352,65535, 62113,65535, 65535,65535,\n                38961,65409,65535,65535, 61840,65535,65535,65535, 63536,65535,65535,65535, 65535,65535,65535,65535\n            );\n\n             int id= int(texCoord.x)*4-512;\n             fragColor= vec4(_triTableCompact[id],_triTableCompact[id+1],_triTableCompact[id+2],_triTableCompact[id+3] );\n\n         }\n    }\n#endif    \n    else setTexture(fragColor,fragCoord);\n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void  lightDiffusion(inout voxel vox,in voxel temp ,vec3 rPos){\n    if(vox.id != 6. && vox.id != 26. ){\n \t   vox.light.s =  max( vox.light.s  ,  \ttemp.light.s  -(rPos.z==1.?0.:1.) - (vox.id==0.?0.: vox.id==11.?5.:15.));       \t\n \t   vox.light.t =  max( vox.light.t,   temp.light.t - (temp.id==0.|| vox.id==0.?1.:3.)); \n    \t\n    }        \n}\n const vec3 VertexOffset[8] =vec3[8]\n(\n        vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n        vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\n//VOXEL MEMORY 1 - NEAR BLOCKS\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   init(1, iChannel0 ,iChannel1, iChannel2, iChannelResolution[0].xy);\n   \n    vec2 textelCoord = floor(fragCoord);\n    vec3 pos =load(_pos).xyz;\n    vec3 offset = floor(vec3(pos.xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_B); \n\n    vec4 newRange= calcLoadRange_B(offset.xy,iChannelResolution[1].xy,0.);\n    \n    if(!inRange(voxelCoord.xy, newRange)) {fragColor=vec4(0.);return;}\n    \n    vec4 pick = load(_pick);   \n\n    voxel vox ; \n    getVoxel( voxelCoord,vox,1);\n    \n    float selId = getInventory(load(_selectedInventory).r);\n    bool ch = length(voxelCoord - pick.xyz)<(pick.a == 1.?2.5:1.5);\n    if(selId==9.) ch= abs(pick.z -voxelCoord.z)<.5 && max(abs(pick.x -voxelCoord.x),abs(pick.y -voxelCoord.y))<2.5;\n    if(selId==7.) ch= length(pick.xy -voxelCoord.xy)<1. && abs(pick.z +2. -voxelCoord.z )<2.5  ;\n    if(selId==5.) ch= length(voxelCoord - pick.xyz)<.5;  ;\n        \n  \n    if (ch ){\n             \n        vox.value=1;\n        \n        if (pick.a == 1. &&  vox.id != 16. &&  vox.id != 12.  && load(_pickTimer).r > .05) \n        {       \n            vox.value=1; \n            vox.id = 0.;              \n            vox.light.t=0.;\n            vox.life=0.;\n            vox.ground=0.;\n            vox.surface=0.;\n        }\n        else if (pick.a == 2. && length(voxelCoord-pos.xyz -vec3(0,0,1.8))>2. && load(_pickTimer).r > .05 )\n        {\n            vox.id = selId;\n            if(vox.id==10.) vox.life=3.;\n            else if (vox.id==12.)vox.life=64.;\n            else vox.life=0.;               \n            vox.value=1; \n            vox.surface=1.;\n       \n        } \n    \n    } \n\n   \t// SUN LIGHT SOURCES\n   \n    if (voxelCoord.z >= heightLimit_B - 2.) {\n        vox.light.s = 15.;   \n    } else  {\n        //vox.light.s=0.; //correct but initial value is better oon surface\n        vox.light.s = 15.;       \n    }\n    \n    // TORCH LIGHT SOURCES\n    if(vox.id==12.) vox.light.t=max(2.,vox.light.t);\n    else if(vox.id==6.) vox.light.t=15.;\n    else vox.light.t=clamp(vox.light.t- (hash(iTime)>.5?1.:0.),0.,15.);\n     \n    if(length( load(_pos).xyz + vec3(0,0,3.)- voxelCoord.xyz) <2.) vox.light.t=max( 12.,vox.light.t);\n  \n\n    voxel temp;\n   \n    \n    //NEIGHBOURS 2=ABOVE 5=BELOW, 0-1-3-4= SIDES\n    float iE=0.;\n      \n    \n    voxel next[6];\n    for(int j=0;j<=1;j++){\n        for(int i=0;i<3;i++){\n            vec3 n= vec3(i==0?1.:0. ,i==1?1.:0.,i==2?1.:0.) * vec3((j==0?1.:-1.));\n          \n            voxel temp;\n            getVoxel(voxelCoord + n ,temp,1 );           \n    \t\tnext[i+3*j]= temp;\n    \n            if(voxelCoord.z> 50.) {vox.light.s=15.;vox.light.t=0.;}\n            else  lightDiffusion(vox,temp,n);\n\n            //LEAFS:\n           if(temp.id==11.  && temp.life>0. &&vox.id==0.) {vox.id=11.;  vox.life=max(temp.life-1.-floor(hash13(voxelCoord)*2.5),0.); }  \n           //WATER:\n           if(temp.id==12.  &&vox.id==0. &&(i!=2 || j==0)) {vox.id=12.; vox.surface=1.;}\n        }\n    }\n    \n    //MC SURFACE\n    for(int id=1;id<8;id++)\n    {\n        vec3 p= voxelCoord+VertexOffset[id];\n        voxel temp;\n        getVoxel(p,temp,1 );\n        if(vox.id==0. && (temp.id==10. || temp.id==11. || temp.value==1) ) vox.surface=1.;\n        if((vox.id==11. || vox.id==10.)&& temp.id==0. ) vox.surface=1.;\n    }    \n      \n    \n           \n\tif(sdBox(pos-voxelCoord -vec3(0.,0.,1.),vec3(.5,.5,.5))<=.01 &&vox.id==3.) vox.id=2.;\n       \n    //ABOVE    \n    if(next[2].id==0.  &&  vox.id==2.) {if(hash13(voxelCoord +iTime ) >.95 && hash(iTime)>.99) vox.id=3.;vox.life=0.;}\n    if(next[2].id==0.  &&  vox.id==3.) {if(hash13(voxelCoord +iTime+30.) >.95 && hash(iTime +30.)>.99) vox.life=clamp(vox.life+1.,0.,3.);}\n    if(next[2].id==3.  &&  vox.id==3.) {vox.id=2.;}\n    if(next[2].value==3 && (vox.id==0.|| vox.id==12.)) {vox.id=next[2].id;} \n    \n    //BELOW\n    if(next[5].id==10.  && next[5].life>0. && vox.id==0.) {vox.id=10.;  vox.life=next[5].life-1.; vox.ground=0.;}\n    if(next[5].id==10.  && next[5].life<1.) {vox.id=11.;  vox.life=TREE_SIZE;}\t\n    if((next[5].id!=3.)  &&  vox.id==0.) {vox.life=0.;}\n    if((next[5].id!=0.|| next[5].id==12.)  &&  vox.value==3) {vox.id=0.; vox.value=0;vox.life=0.;}\n\n\n    if(next[5].id==3.  &&  vox.id==0.) {vox.life=1.;}\n    \n    \n    fragColor = encodeVoxel(vox);\n\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"/*\nVOXEL MEMORY 2 - SURFACE \n  mode = 1 it's just a copy of buffer B, working in a limited z range\n  mode = 2 stores onlythe surface block with the height, for a wider area\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    init(2, iChannel0 ,iChannel1, iChannel2, iChannelResolution[0].xy);\n    vec2 textelCoord = floor(fragCoord);\n    vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    vec3 voxelCoord = texToVoxCoord(textelCoord, offset,BUFFER_C); \n\n    vec4 newRange_C= calcLoadRange_C(offset.xy,iChannelResolution[1].xy,0.);\n\n    if(!inRange(voxelCoord.xy, newRange_C)) {fragColor=vec4(0.);return;}\n\n    voxel vox;  \n    getVoxel( voxelCoord,vox,2);\n\n    if(voxelCoord.z==0. && vox.ground >100.){\n    \tvoxel temp;\n        float h= vox.ground-100.;\n        getVoxel(vec3(voxelCoord.xy,h),temp,2);\n        float id = temp.id;\n        if(id !=0.){\n            vox=temp;\n            vox.ground=h;\n        }\n        else vox.ground--;           \n    } \t\n \n    //NEIGHBOURS\n    if(voxelCoord.z==0. && vox.ground<100.){\n       vec3 s = vec3(1.,0.,0. );\n       vec3 t = vec3(0.,1.,0. );    \n       voxel v;    \n       for (int i =-1; i <=1; i++) {\n            for (int j =-1; j <=1  ; j++) {\n               \n                getVoxel(voxelCoord + s* float(i)+t*float(j),v ,2 ); \n                \n                voxel temp =v;\n                if((i !=0|| j!=0) && temp.id==10. && temp.ground <100. && temp.ground> vox.ground -TREE_SIZE -1.) {\n                \tvox.id=11.;vox.ground=temp.ground+TREE_SIZE+2.;vox.life=0.;\n                }\n            }\n        }\n    }\n    vox.surface=1.;\n    fragColor = encodeVoxel(vox);\n\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#ifdef MC\n\n\nint gFrame=0; \n\n//--------------------\n//porting of \"Marching Cubes\" algorithm by Paul Bourke (1994)\n//http://paulbourke.net/geometry/polygonise/ \n struct TRIANGLE {\n   vec3 p[3];\n} ;\n\n\n struct GRIDCELL{\n   vec3 p[8];\n   float val[8];\n} ;\n\n const vec3 VertexOffset[8] =vec3[8]\n(\n        vec3(0,0,0), vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n        vec3(0,0,1), vec3(1,0,1),vec3(1,1,1),vec3(0,1,1)\n);\n\n\n//lookup tables retrieved from BufferA\n#define edgeTable(i) int(texelFetch(confChannel, ivec2(i,30),0).x)\n#define triTableRow(i) ivec4(texelFetch(confChannel, ivec2(i,31),0))\n#define triTableVal(tt,j) int((tt[j>>2]&(15*(1<<((j&3)*4))))>>((j&3)*4))\n\nconst int  vertexTable[24] =int[24](\n   0,1,   1,2,  2,3,   3,0, \n   4,5,   5,6,  6,7,   7,4,   \n   0,4,   1,5,  2,6,   3,7);\n   \n/*\n   Linearly interpolate the position where an isosurface cuts\n   an edge between two vertices, each with their own scalar value\n*/\nfloat  VertexWeight(float isolevel,float valp1, float valp2)\n{  \n   return  (isolevel - valp1) / (valp2 - valp1);\n}\n\n//input: isolevel value at 8 cube vertexs and isolevel threshold\n//output: number of triangles (-1= outside) and list of triangles (up to 5 in worst case)\nuvec4  Polygonise(inout GRIDCELL grid,float isolevel,inout TRIANGLE[5] triangles,sampler2D confChannel)\n{\n \n   /*\n      Determine the index into the edge table which\n      tells us which vertices are inside of the surface\n   */\n   int cubeindex = 0;\n   for(int i=gFrame;i<8;i++) if (grid.val[i] < isolevel) cubeindex |= 1<<i;\n\n   /* Cube is entirely in/out of the surface -1=IN, 0=OUT */\n   int e=edgeTable(cubeindex);\n   if ( e<= 0) return uvec4(e);\n\n   /* Find the vertices where the surface intersects the cube */\n   vec3 vertlist[12];\n   float vertW[12];\n\n\n   for(int i=0;i<12;i++)\n   if ((e & (1<<i))>0)  {\n       vertW[i]= VertexWeight(isolevel,grid.val[vertexTable[i*2]], grid.val[vertexTable[i*2+1]]);\n          \n       vertlist[i]= mix( grid.p[vertexTable[i*2]], grid.p[vertexTable[i*2+1]],vertW[i]);\n   }\n   /* Create the triangle */\n   uvec4 tridata=uvec4(0u); //x=number of triangles, yzw= tritable\n   \n   ivec4 ttr=triTableRow(cubeindex); \n   for (int i=gFrame;triTableVal(ttr,i)!=15 && i<15;i+=3) {\n       \n       for(int j=gFrame;j<3;j++)   {\n           uint k =uint(triTableVal(ttr,(i+j)));\n           int idx =(i+j);\n           if(idx<8) tridata.y +=  k*( 1u<<(idx*4));\n           else tridata.z += k*( 1u<<(idx*4-32));\n        \n           tridata.w+=  uint( floor(vertW[k]*4. )  ) \n                        *( 1u<<(idx*2));\n           triangles[tridata.x].p[j] = vertlist[k];\n       }\n      \n      tridata.x++;\n   }\n\n   return uvec4(tridata);\n}\n//-------------------------------------\n//Iq\nvec2 boxIntersection( in vec3 ro, in vec3 rd, in vec3 rad) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n\t\n    if( tN>tF || tF<0.0) return vec2(-1.0); \n    \n    //vec3 normal = -sign(rd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    return vec2( tN, tF );\n}\n\n\n// triangle degined by vertices v0, v1 and  v2\nvec3 triIntersect( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    \n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = -1.0;\n    return vec3( t, u, v );\n}\n#endif\n//--------------------------\n\nfloat lightLevelCurve(float t) {\n    t = mod(t, 1200.);\n\treturn 1. - ( smoothstep(400., 700., t) - smoothstep(900., 1200., t));\n}\n\nvec3 lightmap(in vec2 light) {\n    light = 15. - light;\n\tif(load(_torch).r>0.5) light.t=13.;\n    \n    return clamp(mix(vec3(0), mix(vec3(0.11, 0.11, 0.21), vec3(1), lightLevelCurve(load(_time).r)), pow(.8, light.s)) + mix(vec3(0), vec3(1.3, 1.15, 1), pow(.75, light.t)), 0., 1.);   \n\n}\n\n\n\n// RENDERING\n\nvec3 rayDirection(vec2 angle, vec2 uv, vec2 renderResolution){\n    vec3 cameraDir = vec3(sin(angle.y) * cos(angle.x), sin(angle.y) * sin(angle.x), cos(angle.y));\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) * renderResolution.y / renderResolution.x;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n\n}\n\nstruct rayCastResults {\n\tbool hit;\n    vec3 rayPos;\n    vec3 mapPos;\n    vec3 normal;\n    vec2 uv;\n   \n    float dist;\n    voxel vox;\n   // float water;\n    //float fog;\n   // bool grass;\n   // bool mirror;\n    vec3 color;\n   // float fresnel;\n\n};\n\n\n\n\nvec4 sun(){\n    float t = load(_time).r;\n    float sunAngle = (t * PI * 2. / 1200.) + PI / 4.;\n    const float risingAngle=PI/6.;\n    return  vec4(cos(sunAngle)*sin(risingAngle), cos(sunAngle)*cos(risingAngle), sin(sunAngle),lightLevelCurve(t));\n}\n\n\n\n//-------------\n\nfloat noise(in vec2 p) {\n\tvec2 F = floor(p), f = fract(p);\n\tf = f * f * (3. - 2. * f);\n\treturn mix(\n\t\tmix(hash2(F), \t\t\t hash2(F+vec2(1.,0.)), f.x),\n\t\tmix(hash2(F+vec2(0.,1.)), hash2(F+vec2(1.)),\t  f.x), f.y);\n}\n\n\n\n//------------------------*/\nvec4 VoxelHitPos(vec3 pos, vec3 ro, vec3 rd){\n    vec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n    vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n    float t=  max ( mini.x, max ( mini.y, mini.z ) );\n    return vec4(t*rd+ro,t);\n}\n\n\nvec3    g_n;\nvec2    g_uv;\n\nrayCastResults rayCast(vec3 rayPos0, vec3 rayDir,int maxRayDist,vec4 range,int rayType) {\n\t   \n    voxel vox;\n    vox.id=0.;\n\n    rayCastResults res;\n    res.hit = false;\n    res.color=vec3(-1.);\n\n    rayCastResults subRes;\n    subRes.hit=false;\n\n    vec3 raySign= sign(rayDir);\n    vec3 rayInv = 1./rayDir;\n\tvec3 rayPos=rayPos0;\n    \n    vec3 mapPos=floor(rayPos);\n    if ( rayPos.z >= heightLimit_B && rayDir.z<0.){\n       \n        //MAP RAY FROM ABOVE\n        float nstep= (rayPos.z - heightLimit_B)*rayInv.z;\n        mapPos = floor(rayPos-rayDir *nstep+ raySign*0.001);\n    }\n    vec3 sideDist = (mapPos-rayPos + 0.5 + sign(rayDir)*0.5) *rayInv;\n    vec3 mask=vec3(0.); \n\n    \n    //vec3 offset = floor(vec3(load(_pos).xy, 0.));\n    voxel currentVoxel;\n    getCVoxel( mapPos,currentVoxel,3);\n\n\tbool xRay=(currentVoxel.id!=0. );\n        \n    for (int i = 0; i < 1000; i++) {\n\n        if(i>0){\n       \t\tmask = step(sideDist.xyz, sideDist.yzx) * step(sideDist.xyz, sideDist.zxy);\n\n        }\n\t\tsideDist += mask *  raySign *rayInv;\n        mapPos += mask *  raySign;\n        \n        if ( mapPos.z < 0. ) break;\n        if ( mapPos.z >= heightLimit_B && rayDir.z > 0.)  break;\n                   \n        getVoxel( mapPos, vox ,3 );\n        \n      \n       \n\n#ifdef MC\n         if(vox.surface!=0. && mapPos.z<heightLimit_B-1.  && vox.id!=7. && gMC >0.){//&& rayType==1){ \n                gFrame=min(iFrame,0);\n                vec3 hitVoxelPos =VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n                if( sdBox( mapPos+vec3(.5) -rayPos,vec3(.5,.5,.5) )< 0.) hitVoxelPos=rayPos;\n                GRIDCELL g;\n                float csz=1.;\n                \n                bool surface=false;\n                for(int id=0;id<8;id++)\n                {\n                    g.p[id]=mapPos+  VertexOffset[id];\n                }\n                float mcid=0.;\n                \n                \n                for(int id=0;id<8;id++)\n                {\n                    voxel temp;\n#if (MC==2)\n                    getVoxel(g.p[id],temp,3  );\n#else\n                    getCVoxel(g.p[id],temp,3  );\n#endif \n                    if(temp.id==3.) temp.id=4.;\n                     if(mcid!=temp.id && mcid!=0. && temp.id==12. ) mcid=13.;\n                    mcid =max(mcid,temp.id);\n                   \n                    g.val[id]= temp.id!=0.?1.:-1.;\n                    surface = surface || ( g.val[id]*g.val[0]<0.);\n                }    \n\n                if(surface ){\n\n                    TRIANGLE[5] triangles;\n\n                        //calculate vertexes & triangles (requires buffer A and B)\n\n                    uvec4 tridata = Polygonise(g,0.,triangles,iChannel0);\n\n                    int ntriangles=int(tridata.x);          \n                    float t = 1000.0; \n                    for(int i=min(iFrame,0);i<ntriangles;i++) {\n                        vec3 tri =triIntersect( hitVoxelPos,rayDir,triangles[i].p[0],triangles[i].p[1],triangles[i].p[2]);\n                        if(tri.x>0.  && tri.x <t) {\n                            t=tri.x;\n                             g_n=-normalize(cross(triangles[i].p[1]-triangles[i].p[0],triangles[i].p[2]-triangles[i].p[0]));\n                             g_uv= tri.yz;\n                         }\n                    }\n                    if(t< 1000. ) {\n                    \n                        subRes.hit = true; \n                        subRes.mapPos = mapPos;\n                        subRes.normal =- g_n;\n                        subRes.uv=g_uv;\n                        subRes.rayPos = hitVoxelPos + rayDir*t;\n                        subRes.dist = length(rayPos0 - subRes.rayPos);\n                        vox.id=mcid;\n                        subRes.vox=vox;\n                        subRes.color = getTexture(mcid, g_uv).rgb *(.6 - .4*dot( sun().xyz,g_n));;             \n\n                        return subRes;\n   \n                    }else vox.id=0.;\n                }\n                \n        }\n#endif       \n\n        if( vox.id !=0.  ){\n        \tif(xRay) continue;\n            else{\n            \tres.hit = true; \n                break;\n            }\n        } \n\n     \n        //NO HIT\n        xRay=false; \n        if(!inRange(mapPos.xy, range) && i> maxRayDist) break;\n\n        if(i > gRayLimit) break;\n\t}\n    \n    if(!res.hit  &&rayDir.z < 0. && !inRange(mapPos.xy, range)){\n        if(mapPos.z>15.) {vox.id = 0.; res.hit=false;}\n        else { vox.id=3.; res.hit = true;}\n    }\n    \n    res.mapPos = mapPos;\n    res.normal = res.hit? -raySign * mask:vec3(0.);\n    res.rayPos = VoxelHitPos(mapPos,rayPos,rayDir).xyz;\n    res.dist =  res.hit?length(rayPos0 - res.rayPos):1000.;\n    res.vox=vox;\n\n    \n    //uv coordinates are relative to block (also with subvoxels)                       \n    if (abs(mask.x) > 0.) {\n        res.uv = fract(res.rayPos.yz);\n    }\n    else if (abs(mask.y) > 0.) {\n        res.uv = fract(res.rayPos.xz);\n    }\n    else {\n        res.uv = fract(res.rayPos.yx);\n    }  \n    if(res.hit ){\n        float textureId = res.vox.id;\n        if (textureId == 3.) textureId += res.normal.z;\n        vec2 uv_txt= res.uv;           \n        res.color = getTexture(textureId, uv_txt).rgb *(.6 - .4*dot( sun().xyz, -res.normal));; ;\n    \n    }   \n    return res;\n}\n\n\nvec3 skyColor(vec3 rayDir) {\n    \n    vec4 s= sun();\n    float lightLevel = s.w;\n\n    vec3 sunDir=s.xyz;\n    vec3 daySkyColor = vec3(.5,.75,1);\n    vec3 dayHorizonColor = vec3(0.8,0.8,0.9);\n    vec3 nightSkyColor = vec3(0.1,0.1,0.2) / 2.;\n    \n    vec3 skyColor = mix(nightSkyColor, daySkyColor, lightLevel);\n    vec3 horizonColor = mix(nightSkyColor, dayHorizonColor, lightLevel);\n    float sunVis = smoothstep(.99, 0.995, dot(sunDir, rayDir));\n    float moonVis = smoothstep(.999, 0.9995, dot(-sunDir, rayDir));\n    return mix(mix(mix(horizonColor, skyColor, clamp(dot(rayDir, vec3(0,0,1)), 0., 1.)), vec3(1,1,0.95), sunVis), vec3(0.8), moonVis);\n    \n}\n\n//----------\n\nfloat hashc(vec2 p)\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noisec(vec2 x)\n{\n    vec2 p = floor(x);\n    vec2 w = fract(x);\n    vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n    \n    float a = hashc(p+vec2(0,0));\n    float b = hashc(p+vec2(1,0));\n    float c = hashc(p+vec2(0,1));\n    float d = hashc(p+vec2(1,1));\n    \n    return -1.0+2.0*(a + (b-a)*u.x + (c-a)*u.y + (a - b - c + d)*u.x*u.y);\n}\nconst mat2 m2 = mat2(  0.80,  0.60,\n                      -0.60,  0.80 );\n                      \n// clouds from EvilRyu's https://www.shadertoy.com/view/Xd3fR7\nfloat cloud(vec2 x)\n{\n    float f = 2.;\n    float s = 0.5;\n    float a = 0.0;\n    float b = 0.5;\n    for(int i=0; i<3+min(0,iFrame); i++)\n    {\n        float n = noisec(x);\n        a += b*n;\n        b *= s;\n        x = f*m2*x;\n    }\n\treturn a;\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\nvoid render( out vec4 fragColor, vec3 rayPos, vec3 rayDir ,int  maxRayDist, int rayType) {\n\n    vec4 range_B = load(_old+_loadRange_B);\n    vec3 sunDir = sun().xyz; sunDir *= sign(sunDir.z);\n      \n    rayCastResults rays[2] ;//0=view,1 =shadow\n    vec3 ro=rayPos;\n    vec3 rd=rayDir;\n    int rt=rayType;\n    for(int i=0; i<=1;i++){\n    \trays[i]=rayCast(ro, rd,maxRayDist,range_B,rt);\n\t\tif(!rays[i].hit) break;\n \t\tif(SHADOW<0.) break;\n        ro=rays[i].rayPos +rays[i].normal*0.001;\n        rd=sunDir;\n        maxRayDist=  25;\n        rt=3;           \n    }\n    \n   rayCastResults res = rays[0];\n\t\n\tvec3 color = vec3(0.);\n    \n    if (res.hit) {\n        \t\t\t\n        float shadow = rays[1].hit?SHADOW:0.;\n        //color=res.color*(1.-shadow*.2);\n       \n        color = res.color *lightmap( vec2(res.vox.light.s*(1.-shadow*.2),res.vox.light.t)   );\n        if(rayType==1 ){\n\t\t\t\n            // SELECTION AND MOUSE OVER\n            vec4 pick = load(_pick);\n            if (res.mapPos == pick.xyz || res.vox.value==2) {\n                if (pick.a == 1.) color *= getTexture(32., res.uv).r;\n                else if (res.vox.value==2) color = mix(color, vec3(1.,0.,0.), 0.5);\n                \n                else color = mix(color, vec3(1), 0.2);\n            }\n        }\n        \n    }\n     else {\n     \n     \n        color = skyColor(rayDir);\n        vec2 skyPos=  rayPos.xy - (rayPos.z - heightLimit_B -50.)/rayDir.z * rayDir.xy;\n        vec2 uv= skyPos-vec2(4710.,235.);\n        float cl=cloud(uv*0.03);\n        float dl=smoothstep(-0.2,0.6,cl) *smoothstep(0., 0.1, rayDir.z);\n        color=mix(color, vec3(1.0), 0.6*dl);\n    }\n    if(rayType==1) {\n        color = pow( color, vec3(0.9) );\n             \n    }\n    fragColor.rgb = color; \n    \n    if(rayType==3 ) {\n        \n        vec3 n1=abs(res.normal),\n             n2=step(n1.xyz, n1.yzx) * step(n1.xyz, n1.zxy)*sign(res.normal);\n        float encodeNormal=14.+ n2.x + n2.y*3. + n2.z*9.;\n        fragColor=vec4(res.mapPos,(res.hit && res.dist >1. && res.dist <MAX_PICK_DISTANCE ? encodeNormal:0.));\n    }  \n     \n    //DEBUG:\n    fragColor.a= res.dist ;\n    //fragColor=vec4( (1.-.5* sign(res.normal))* abs(res.normal) ,1.);\n    //fragColor=vec4( res.uv,max(abs(res.uv -.5).x,abs(res.uv-.5).y)<.5?1:0 ,1.);\n    //if(res.vox.id==12.) fragColor=vec4(vec2(res.vox.life<2. ? .5:0.),1.- res.vox.life/255.,1.);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n \n    float pixelSize = load(_pixelSize).r;\n    vec2 renderResolution = ceil(iResolution.xy / pixelSize); \n    if (any(greaterThan(fragCoord, renderResolution))) {\n        fragColor = vec4(0);\n        return;\n    }\n        \n    vec3 cameraPos;    \n    vec3 cameraDir;\n    int  rayType = 1;\n \n    init(3, iChannel0 ,iChannel1, iChannel2, iChannelResolution[0].xy);\n    \n    if(max(fragCoord.x,fragCoord.y)<1. ) rayType=3;\n    if(rayType==3){\n        //MOUSE RAY\n        float zoom = pow(10., load(_renderScale).r/10.);///pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (iMouse.xy- renderCenter) / renderResolution - (renderCenter/zoom);//  /pixelSize;\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n  \n    }          \n    else if(rayType==1) \n    {    \n        // MAIN CAMERA\n        float zoom = pow(10., load(_renderScale).r/10.)/pixelSize;\n        vec2 renderResolution = iResolution.xy *zoom; \n        vec2 renderCenter=vec2(0.5);\n        vec2 uv = (fragCoord.xy- renderCenter) / renderResolution - (renderCenter/zoom/pixelSize);\n         cameraPos = load(_pos).xyz + vec3(0,0,1.6);    \n         cameraDir = rayDirection(load(_angle).xy,uv,renderResolution);\n     \n      //DEMO VIEW     \n       \n                  \n    }   \n\n    render(fragColor,cameraPos, cameraDir, int(load(_rayDistMax).r),rayType);\n       \n\n}","name":"Buffer D","description":"","type":"buffer"}]}