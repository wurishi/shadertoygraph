{"ver":"0.1","info":{"id":"DlGfWt","date":"1702601448","viewed":19,"name":"Ex2","username":"mizuiro_rivi","description":"Ex2 for toplogy","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["topology"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.1415926535897932384626433832795\nconst float PI = 3.14159265359;\n\n// Transformation and SDF functions provided by you\nvec2 move(vec2 point, vec2 delta){\n    return point - delta;\n}\n\nvec2 rotate(vec2 point, float angle){\n    return mat2(cos(-angle), sin(-angle), -sin(-angle), cos(-angle)) * point;\n}\n\nvec2 scale(vec2 point, vec2 factor){\n    return point / factor;\n}\n\nvec2 transform(vec2 point, vec2 delta, float angle){\n    return rotate(move(point, delta), angle);\n}\n\nfloat sdCircle(vec2 p, float r){\n    return length(p) - r;\n}\n\nfloat sdBox(vec2 p, vec2 b){\n    vec2 d = abs(p) - b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.);\n}\n\nfloat sdSegment(vec2 p, vec2 a, vec2 b ){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n    return length(pa - ba*h);\n}\n\nfloat sdSegment1(vec2 p, vec2 a, vec2 b){\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - (sin(1./(h+1.)*32. + iTime)+2.)*0.05;\n}\n\nfloat sdSegment2( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - 1./(60.*h+4.);\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb){\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\nfloat dot2(vec2 v){\n    return dot(v, v);\n}\n\nfloat sdHeart(vec2 p){\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nfloat cross2d(vec2 v1, vec2 v2){\n    return v1.x * v2.y - v1.y * v2.x;\n}\n\n\n#define WINDING 0\n\nfloat sdPolygon(vec2 p, vec2[48] v){\n    const int num = v.length();\n    float d = dot2(p-v[0]);\n    float s = 1.0;\n    int count = 0;\n    for(int i=0, j=num-1; i<num; j=i, i++){\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w,e)/dot2(e), 0.0, 1.0);\n        d = min(d, dot2(b));\n\n        // winding/crossing number\n        bvec3 cond = bvec3(p.y>=v[i].y, \n                           p.y <v[j].y, \n                           cross2d(e,w)>0.0);\n        #if WINDING\n            if(all(cond)) count++;\n            else if(all(not(cond))) count--;\n        #else\n            if(all(cond) || all(not(cond))) s=-s;\n        #endif\n    }\n    #if WINDING\n        if(count != 0) s = -1.0;\n    #endif\n    return s*sqrt(d);\n}\n\nfloat opRound(float d, float r){\n    return d - r;\n}\n\nfloat opBorder(float d, float r){\n    return abs(d) - r;\n}\n\nfloat opUnion(float d1, float d2){\n    return min(d1, d2);\n}\n\nfloat opIntersection(float d1, float d2){\n    return max(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2){\n    return max(d1, -d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k){\n    float h = max(k-abs(d1-d2), 0.0);\n    return min(d1, d2) - h*h/(4.0*k);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k){\n    return -opSmoothUnion(-d1,-d2,k);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k){\n    return -opSmoothUnion(-d1,d2,k);\n}\n\nvec2 opSmoothUnionMix(float d1, float d2, float k){\n    float h = max(k-abs(d1-d2), 0.0)/k;\n    float m = h*h*0.5;\n    float s = m*k*0.5;\n    return (d1<d2) ? vec2(d1-s, m) : vec2(d2-s, 1.0-m);\n}\n\nfloat opWavify(vec2 point, float d, float freq, float phase, float strength){\n    return d + sin(point.x*freq + phase) * strength;\n}\n\nfloat opDotify(vec2 point, float d, float grain, float bound, float strength){\n    vec2 s = sin(point/grain) * strength;\n    return max(d, bound) + s.x + s.y;\n}\n\nvoid render(inout vec3 col, vec3 newcol, float d, float antialias){\n    col = mix(newcol, col, smoothstep(-antialias, antialias, d));\n}\n\nvec2 normalizeCoords(vec2 p){\n    return (2.0*p-iResolution.xy)/iResolution.y;\n}\n\n// Background gradient function\nvec3 background(vec2 uv) {\n    // Sky colors\n    vec3 colorBottomSky = vec3(0.529, 0.808, 0.980); // Light blue for the horizon\n    vec3 colorMiddleSky = vec3(0.0, 0.478, 0.988);   // Deeper blue for the middle\n    vec3 colorTopSky = vec3(1.0, 1.0, 1.0);          // White for the top\n\n    // Calculate gradient\n    float heightFactor = uv.y * 0.5 + 0.5; // Linear interpolation factor\n    vec3 skyGradient = mix(colorBottomSky, colorMiddleSky, heightFactor);\n\n    // Create a smoother transition to white at the top\n    float whiteFactor = smoothstep(0.7, 1.0, uv.y); // Start blending into white at 70% height\n    skyGradient = mix(skyGradient, colorTopSky, whiteFactor);\n\n    return skyGradient;\n}\n\nconst float TWO_PI = 6.28318530718;\n\n// Function to compute the SDF of a regular polygon\nfloat sdRegularPolygon(vec2 p, float r, int N) {\n    // The angle between each pair of polygon vertices from the center\n    float angleStep = TWO_PI / float(N);\n    \n    // Adjust the point's angle so it's within the first segment's sweep\n    float angle = atan(p.y, p.x);\n    float adjustedAngle = mod(angle + PI, angleStep) - angleStep * 0.5;\n    \n    // Compute the distance to the side of the polygon in this segment\n    float distToSide = r / cos(adjustedAngle);\n    \n    // Return the signed distance to the side\n    return length(p) - distToSide;\n}\n// 疑似乱数を生成するための簡単なハッシュ関数\nfloat hash(float n) {\n    return fract(sin(n) * 1e4);\n}\n\nfloat hash(vec2 p) {\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\n// 2Dの疑似ノイズ関数\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // 四隅のノイズ値\n    float a = hash(i);\n    float b = hash(i + vec2(1.0, 0.0));\n    float c = hash(i + vec2(0.0, 1.0));\n    float d = hash(i + vec2(1.0, 1.0));\n    \n    // 平滑化された補間\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat sdCloud(vec2 p, vec2 cloudPos, float cloudRadius, float spacing, float sizeFactor) {\n    float d = length(p - cloudPos) - (cloudRadius + noise(p * 0.2) * 0.25);\n    \n    // spacing は円の中心間の距離を制御します\n    // sizeFactor は円のサイズを制御します\n    for (int i = 1; i < 10; ++i) {\n        float angle = float(i) * 6.28318530718 / 5.0;\n        float radianSpacing = spacing + noise(vec2(cos(angle), sin(angle)) * 1.5) * 0.1;\n        vec2 pos = cloudPos + vec2(sin(angle), cos(angle)) * radianSpacing;\n        float radius = cloudRadius / (sizeFactor * float(i)) + noise(p * 0.2 + float(i)) * 0.1;\n        d = min(d, length(p - pos) - radius);\n    }\n\n    return d;\n}\n// Main image rendering function\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = normalizeCoords(fragCoord);\n    \n    // Background\n    vec3 col = background(uv);\n\n    // Render the ocean with undulating waves\n    float waveHeight = 0.03; // Height of the waves\n    float waveSpeed = 2.0; // Speed of the wave animation\n    float waveCount = 10.0; // Number of waves\n    float offsetY = sin(uv.x * waveCount + iTime * waveSpeed) * waveHeight;\n    float oceanY = 0.0; // Y coordinate of the ocean level\n    float oceanBorder = smoothstep(-0.1, 0.1, uv.y - oceanY + offsetY);\n    vec3 oceanColor = mix(vec3(0.0, 0.0, 0.5), vec3(0.1, 0.3, 0.7), oceanBorder);\n    col = mix(col, oceanColor, step(uv.y, oceanY + offsetY));\n    uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    \n     vec2 cloudPos = vec2(0.3, 0.3); // 雲の中心位置\n    float cloudRadius = 0.05; // 雲の大きな円の半径\n    float spacing = 0.025; // 円の中心間の距離\n    float sizeFactor = 2.0; // 円のサイズの係数\n\n    // 雲をレンダリング\n    float cloudDist = sdCloud(uv, cloudPos, cloudRadius, spacing, sizeFactor);\n    float cloudBorder = smoothstep(-0.02, 0.02, cloudDist);\n    vec3 cloudColor = vec3(1.0); // 白色\n    col = mix(cloudColor, col, cloudBorder);\n\n// Calculate the signed distance for the sun as a 48-sided polygon\n    float sunDist = sdRegularPolygon(uv - vec2(-0.5, 0.3), 0.15, 48);\n    float sunBorder = smoothstep(0.01, -0.01, sunDist);\n\n    // Cream color for the sun\n    vec3 creamColor = vec3(1.0, 0.98, 0.82); // Cream color\n\n    // Background color\n    vec3 bgColor = vec3(0.2, 0.6, 0.8); // Blue background\n\n    // Mix background and sun color\n    col = mix(col, creamColor, sunBorder);\n\n    // Output the final color\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}