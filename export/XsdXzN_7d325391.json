{"ver":"0.1","info":{"id":"XsdXzN","date":"1458059441","viewed":730,"name":"Implicit Surface Rendering","username":"yvtjp","description":"Rendering implicit surface requires many sampling count, which is not desirable for interactive visualization. By introducing a progressive refinement scheme, the rendering quality can be improved gradually whilst keeping the frame rate high.","likes":12,"published":1,"flags":32,"usePreview":0,"tags":["math","plot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n    fragColor.w = 1.;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const float FarDistance = 16.;\nconst int NumSteps = 16;\t\t// Number of samples per pixel (per frame)\nconst float DerivStep = 0.01;\t// For shading\nconst bool disableProgressiveRefinement = false;\n\nfloat implicitFunc(vec3 pos)\n{\n    pos.y += sin(pos.x * 8. + iTime * 3.) * 0.15;\n    pos.x += sin(pos.y * 8. + iTime * 3.) * 0.15;\n    pos = (fract(pos * 0.2 + 0.5) - 0.5) / 0.2;\n    \n    float v = dot(pos, pos) + .8;\n    v = 5. * dot(pos.xy, pos.xy) - v * v;\n    \n \treturn v;\n}\n\nfloat ditherPattern(vec2 coord)\n{\n \tcoord = fract(coord * 0.5);\n    return dot(coord, vec2(0.25, 0.5));\n}\n\nvec3 computeNormalAt(vec3 pos)\n{\n    vec3 v = vec3(\n    \timplicitFunc(pos - vec3(DerivStep, 0., 0.)),\n    \timplicitFunc(pos - vec3(0., DerivStep, 0.)),\n    \timplicitFunc(pos - vec3(0., 0., DerivStep))\n    );\n    vec3 v2 = vec3(\n    \timplicitFunc(pos + vec3(DerivStep, 0., 0.)),\n    \timplicitFunc(pos + vec3(0., DerivStep, 0.)),\n    \timplicitFunc(pos + vec3(0., 0., DerivStep))\n    );\n    return normalize(v - v2);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid shade(vec3 pos, out vec3 color)\n{\n    vec3 surfNormal = computeNormalAt(pos);\n    \n    float h = pos.x * 0.25;\n    vec3 albedo = hsv2rgb(vec3(h, 1., 1.));\n    \n    float dtLt = dot(surfNormal, normalize(vec3(0.5, 1., 1.)));\n    float dtSky = dot(surfNormal, vec3(0., 0., 1.));\n    float diff = max(0., dtLt) + (dtSky * 0.5 + 0.5) * 0.2;\n    \n    color.xyz = albedo * diff;\n    color.xyz = sqrt(color.xyz); // gamma correction\n}\n\nbool trace(inout vec4 fragColor, vec3 cameraPos, vec3 rayDir, float farDist, float dither)\n{\n    fragColor.w = FarDistance; // reset upper bound\n    \n    // Start sampling\n    float interval = farDist / float(NumSteps + 1);\n    float d = interval * dither;\n    vec3 rayPos = vec3(0.);\n    float fval = implicitFunc(cameraPos + rayDir * d);\n    \n    for (int i = 0; i < NumSteps; ++i) {\n        float lastD = d;\n        // vec3 lastRayPos = rayPos;\n        float lastfval = fval;\n        \n       \td += interval;\n        if (i == NumSteps - 1) {\n         \td = farDist;   \n        }\n     \trayPos = cameraPos + rayDir * d;\n        fval = implicitFunc(rayPos);\n        \n        if (fval > 0.) {\n            // refine\n            for (int k = 0; k < 12; ++k) {\n                float midD = mix(lastD, d, 0.5);\n                vec3 midRayPos = cameraPos + rayDir * midD;\n                float midfval = implicitFunc(midRayPos);\n                if (midfval > 0.) {\n                 \td = midD;   \n                } else {\n                 \tlastD = midD;   \n                }\n                rayPos = midRayPos;\n            }\n         \tfragColor.w = lastD;\n            shade(rayPos, fragColor.xyz);\n            return true;\n        }\n        \n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 lastValue = iFrame == 0 ? vec4(0.) : texture(iChannel0, uv);\n    \n    fragColor = vec4(lastValue.xyz * .9, 1.0);\n    \n    float yaw = iTime * 0.02;\n    float pitch = 0.3;\n    if (iMouse.z > 0.) {\n        vec2 mousePos = iMouse.xy / iResolution.xy - 0.5;\n     \tyaw = mousePos.x * 6.;\n        pitch = mousePos.y * -4.;\n    }\n    vec3 cameraPos = vec3(cos(yaw)*cos(pitch),sin(yaw)*cos(pitch),sin(pitch)) * 8.;\n    vec3 cameraDir = normalize(-cameraPos);\n    vec3 cameraUp = vec3(0., 0., 1.);\n    vec3 cameraU = normalize(cross(cameraUp, cameraDir));\n    vec3 cameraV = cross(cameraDir, cameraU);\n    vec2 cameraUV = (uv - 0.5) * 0.5 * vec2(16./9.,1.);\n    vec3 rayDir = cameraDir + cameraU * cameraUV.x + cameraV * cameraUV.y;\n    \n    float farDist = clamp(lastValue.w * 1.01, 0.01, FarDistance);\n    \n    float dither = ditherPattern(fragCoord);\n    dither = fract(dither + 10. * cos(10. * cos(iTime + dot(fragCoord, vec2(11.4, 51.4)))));\n    \n    if (disableProgressiveRefinement || !trace(fragColor, cameraPos, rayDir, farDist, dither)) {\n        // Fail; reset the upper bound\n        trace(fragColor, cameraPos, rayDir, FarDistance, dither);\n    }\n    \n}","name":"Buf B","description":"","type":"buffer"}]}