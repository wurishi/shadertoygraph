{"ver":"0.1","info":{"id":"XtSczK","date":"1509136549","viewed":352,"name":"Karman Vortex Street","username":"riouxld","description":"Vortex street should start slowly near 30 sec, fast at 45 sec! (60fps)\n\nNote that the geometry of the obstacle, the initial/boundary conditions, small compact support of FD and the fact that we only take 1 iteration during jacobi pollute the simulation.","likes":19,"published":1,"flags":32,"usePreview":0,"tags":["simulation","fluid","multipass","navierstokes","jacobi","multistep"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Karman Vortex Street simulation. Non-dimensional incompressible poiseuille \n//flow with an obstacle. semi-lagrangian scheme.\n//Can accelerate the street formation by left clicking to add perturbation.\n//Beware, perturbation may cause the simulation to fail.\n\n//To be accurate, we should change the boundary condition since we\n//solve using the auxiliary fields of helmholtz-hodge decomposition.\n\n//TODO: Find a way to iterate Jacobi method to solve implicit system of equation.\n//Maybe via RGBA inside the buffer. Don't know how, tough.\n\n//The compactness of the finite difference stencil limit the propagation of \n//boundary in space. Also, it is sensible to large time-step. If we move faster\n//than we propagate, problems arise. \n\n//Also, the non-smoothness of the boundary is not optimal for the simulation,\n//but it's easier to manage the boundary condition, unless we use multiple boundary \n//tangent method to generate goo virtual particles. It's horrible to implement...\n\n//May become unstable or die in the long run. To much energy injected/lost over time \n//by the lost incompressibility, I think. \n//Could also be a mistake somewhere in the code, who knows!\n\n//Just sit and watch! \n//dark blue = fast in + direction.     +++ \n//light blue = slow or in - direction. ---\n\n\n// choose what field to look at by commenting the others\n#define VELOCITY\n//#define PRESSURE\n//#define DIVERGENCE\n//#define VORTICITY\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/300.0;\nconst float reynold = 200.0;\n\nconst int obsRadius = 10;\nconst vec2 obsPos = vec2(5.0,2.0);\n\n\n//macro\n#define GetColor(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).zw\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\n// COLORMAP\n\n\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy/obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n\n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0.5);\n        return;\n    } \n    \n    //to compute finite difference approximaton\n\n    vec2 uv = GetVelocity(0,0); \n    float p = GetPressure(0,0); \n\n    //to compute finite difference approximaton\n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n\n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv; //periodic\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        uvim1j = 2.0*vec2(4.0*uvCoord.y*(1.0-uvCoord.y),0.0)-uv; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv; //dirichlet\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    \n    // set obstable boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvip1j = -uv; //dirichlet\n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvim1j = -uv; //dirichlet\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijp1 = -uv; //dirichlet\n    }\n    \n    float vortiticy = 0.5*(uvijp1.y-uvim1j.y +uvijp1.x-uvijm1.x)/dx;\n    float divervence =  0.5*(uvip1j.x-uvim1j.x+uvijp1.y-uvijm1.y)/dx;\n    \n\n    #ifdef VELOCITY\n    fragColor =vec4(1.0-hot(0.5*(uv.x+1.0)),1);\n    #endif\n    #ifdef PRESSURE\n    fragColor =vec4(1.0-hot(0.01*(p+60.0)),1);\n    #endif\n    #ifdef DIVERGENCE\n    fragColor =vec4(1.0-hot(0.1*(divervence+5.0)),1);\n    #endif\n    #ifdef VORTICITY\n    fragColor =vec4(1.0-hot(0.1*(vortiticy+5.0)),1);\n    #endif\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Set initial condition / perturbation / advection / force\n\n// must be modified in all buffers and image\n// simulation parameters\nconst vec2 force = vec2(2.0, 0.0);\nconst float dt = 1.0/300.0;\nconst float reynold = 200.0;\n\nconst int obsRadius = 10;\nconst vec2 obsPos = vec2(5.0,2.0);\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n#define GetVelocityUV(X,Y) texture( iChannel3, fragCoord.xy/ iResolution.xy+vec2(X,Y)).xy\n\n// constant height bumb function\nconst float radius = 0.01; \nfloat bumbCyl(float p)\n{\n\treturn 1.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy/obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    // initial condition\n    \n    if (iFrame==0) {\n        fragColor = vec4(4.0*uvCoord.y*(1.0-uvCoord.y),0,0,0);\n        return;\n    }\n    \n    \n    // add perturbation with mouse\n    // does not conserve incompressibility\n    float pert = length((fragCoord.xy - iMouse.xy) / iResolution.y);   \n    if(iMouse.z > 0.0 && pert < radius) {\n        vec2 temp = (vec2(fragCoord.y - iMouse.y,-fragCoord.x + iMouse.x)/ iResolution.y)/radius;\n        fragColor = bumbCyl(pert)*vec4(temp,0,0);\n        return;\n    }\n    \n    // advect via semi-lagrangian method\n    vec2 uv = GetVelocity(0,0);\n    vec2 uvAdv = GetVelocityUV( -uv.x*dt,-uv.y*dt);\n    \n    // add driving force\n    // may be problematic with obstacle. can be removed. The simulation will have less energy,\n    // but the inlet boundary condition should be enough.\n    uvAdv += dt*force/reynold;\n    \n    fragColor = vec4(uvAdv, 0, 0); \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// solve for diffusion\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/300.0;\nconst float reynold = 200.0;\n\nconst int obsRadius = 10;\nconst vec2 obsPos = vec2(5.0,2.0);\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy/obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv; //periodic\n    }\n    \n    if(ijCoord.x == 0)\n    {\n        uvim1j = 2.0*vec2(4.0*uvCoord.y*(1.0-uvCoord.y),0.0)-uv; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv; //dirichlet\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    \n    // set obstable boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvip1j = -uv; //dirichlet\n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvim1j = -uv; //dirichlet\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijm1 = -uv; //dirichlet\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijp1 = -uv; //dirichlet\n    }\n    \n    \n    //should use more than 1 iteration...\n    //solve with jacobi for new velocity with laplacian\n    float coef = dt/(dxPow*reynold);\n    vec2 uvDiff = (uv+coef*(uvip1j+uvim1j+uvijp1+uvijm1))/(1.0+4.0*coef);\n \n    \n    fragColor = vec4(uvDiff,0,0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// solve for pressure\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/300.0;\nconst float reynold = 200.0;\n\nconst int obsRadius = 10;\nconst vec2 obsPos = vec2(5.0,2.0);\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy/obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); // texture.x value of u this step\n    vec2 uvip1j = GetVelocity(1,0);\n    vec2 uvim1j = GetVelocity(-1,0);\n    vec2 uvijp1 = GetVelocity(0,1);\n    vec2 uvijm1 = GetVelocity(0,-1);\n    \n    vec2 uvijentry =  GetVelocity(-ijCoord.x,0);\n    vec2 uvijexit =  GetVelocity(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    //to compute finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n    float pijentry =  GetPressure(-ijCoord.x,0);\n    float pijexit =  GetPressure(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        uvip1j = uv; //periodic\n        pip1j = p; //periodic\n    }\n    if(ijCoord.x == 0)\n    {\n        uvim1j =  2.0*vec2(4.0*uvCoord.y*(1.0-uvCoord.y),0.0)-uv; //periodic\n        pim1j = -p; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        uvijp1 = -uv; //dirichlet\n        pijp1 = p;    //neumann\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        uvijm1 =  -uv;//dirichlet\n        pijm1 = p;//neumann\n    }\n    \n    // set obstable boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvip1j = -uv; //dirichlet\n        pip1j = p;//neumann\n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        uvim1j = -uv; //dirichlet\n        pim1j = p;//neumann\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijm1 = -uv; //dirichlet\n        pijm1 = p;//neumann\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        uvijp1 = -uv; //dirichlet\n        pijp1 = p;//neumann\n    }\n    \n    // compute velocity divergence\n    float divergence = 0.5*(uvip1j.x-uvim1j.x+uvijp1.y-uvijm1.y)/dx;\n    divergence*= reynold/dt;\n    \n    // should use more than 1 iteration...\n    // compute pressure (auxiliary) via jacobi iteration... \n    float phi = 0.25*((pip1j+pim1j)+(pijp1+pijm1)-dxPow*divergence);\n        \n        \n    fragColor = vec4(phi,0,0,0);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// project for incompressibility\n\n// must be modified in all buffers and image\n// simulation parameters\nconst float dt = 1.0/300.0;\nconst float reynold = 200.0;\n\nconst int obsRadius = 10;\nconst vec2 obsPos = vec2(5.0,2.0);\n\n//macro\n#define GetVelocity(I,J) texelFetch( iChannel1, ijCoord+ivec2(I,J), 0 ).xy\n#define GetPressure(I,J) texelFetch( iChannel2, ijCoord+ivec2(I,J), 0 ).x\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    float dx = 1.0 / iResolution.y;\n    float dxPow = dx *dx ;\n    vec2 uvCoord = dx*fragCoord.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    // set obstacle\n\tivec2 obsCenter = ivec2(floor(iResolution.xy/obsPos));\n    ivec4 obsCoord = ivec4(obsCenter-obsRadius, obsCenter+obsRadius);\n    \n    if (abs(ijCoord.x - obsCenter.x) <= obsRadius  &&  abs(ijCoord.y - obsCenter.y) <= obsRadius) \n    {\n    \tfragColor = vec4(0,0,0,0);\n        return;\n    } \n    \n    //to compute finite difference approximaton\n    vec2 uv = GetVelocity(0,0); \n    \n    //to compute finite difference approximaton\n    float p = GetPressure(0,0); // texture.x value of u this step\n    float pip1j = GetPressure(1,0);\n    float pim1j = GetPressure(-1,0);\n    float pijp1 = GetPressure(0,1);\n    float pijm1 = GetPressure(0,-1);\n    \n    float pijentry =  GetPressure(-ijCoord.x,0);\n    float pijexit =  GetPressure(-ijCoord.x+int(iResolution.x)-1,0);\n    \n    \n    \n     // set outer boundary conditions\n    if(ijCoord.x ==  int(iResolution.x)-1)\n    {\n        pip1j = p; //periodic\n    }\n    if(ijCoord.x == 0)\n    {\n        pim1j = -p; //periodic\n    }\n    if(ijCoord.y ==  int(iResolution.y)-1)\n    {\n        pijp1 = p;    //neumann\n    }\n    \n    if(ijCoord.y == 0)\n    {\n        pijm1 = p;//neumann\n    }\n    \n    // set obstable boundary conditions\n    if(ijCoord.x == obsCoord.x-1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        pip1j = p;//neumann\n    }\n    if(ijCoord.x == obsCoord.z+1 && ijCoord.y >= obsCoord.y && ijCoord.y <= obsCoord.w )\n    {\n        pim1j = p;//neumann\n    }\n    if(ijCoord.y == obsCoord.w+1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        pijm1 = p;//neumann\n    }\n    if(ijCoord.y == obsCoord.y-1 && ijCoord.x >= obsCoord.x && ijCoord.x <= obsCoord.z )\n    {\n        pijp1 = p;//neumann\n    }\n    \n    \n    //compute gradiant of pressure\n    vec2 pGrad = 0.5*vec2(pip1j-pim1j, pijp1-pijm1)/dx;\n    pGrad*= dt/reynold;\n    \n    //projection (helmholtz-hodge) to obtain divergence free\n    vec2 uvProj = uv-pGrad;\n    \n    vec2 color = GetVelocity(0,0); \n    \n    \n    fragColor = vec4(uvProj,  0,0);\n}","name":"Buf D","description":"","type":"buffer"}]}