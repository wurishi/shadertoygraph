{"ver":"0.1","info":{"id":"4XffDN","date":"1728381919","viewed":76,"name":"Shiny Disco Ballz","username":"tedy02","description":"Upgraded version of 'Shiny Disco Balls' with sphere surface mask, rotation, pass-through logic and tweaks.\nIf its running slowly for you, reduce g_numspheres, up VOLUME_STEP a little, remove rotation.\nNeeds more optimising, will update :)","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["raytracing","music","lighting","sphere","volumetric","reflections","plane","mask","strobe","psychadelic","rave"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Light's Night Out[STROBE][MUSIC]\" by peet. https://shadertoy.com/view/3tsXWH\n// 2024-10-08 10:04:52\n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n// IF YOU GET A BLACK SCREEN YOU WILL NEED TO DISABLE MUSIC TO SEE ANYTHING ///////\n// THE AUDIO DOESNT SEEM TO LOAD PROPERLY ON SOME MACHINES, DONT KNOW WHY /////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define MUSIC \n\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n// IF YOU GET A BLACK SCREEN YOU WILL NEED TO DISABLE MUSIC TO SEE ANYTHING ///////\n// THE AUDIO DOESNT SEEM TO LOAD PROPERLY ON SOME MACHINES, DONT KNOW WHY /////////\n///////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////\n\n#define NO_INTERSECTION 100000.0\n//#define AMBIENT 0.05\n#define EPSILON 0.0001\n#define TEXTURESCALE 0.125/4.0\n#define SPECULAR_POWER 25.0\n#define SPECULAR_AMOUNT 1.0\n#define MSAA 1.0\n#define ITERATIONS 3\n#define HURRY_UP 1.5\n#define LIGHT_ZBIAS 0.0\n\n#define VOLUME_STEP 0.1\t//// SET THIS TO 0.3 OR HIGHER FOR BETTER PERFORMANCE /////\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#define DISCO_LIGHTS\n#define LIGHT_COLOUR_CHANGE\n//#define MODULATE_PLANE_REFLECTANCE\n#define VOLUMETRIC_LIGHTING\n#define ROTATION\n//#define CHECKER_PULSE\n#define ALTERNATIVE_MASK\n\n///////////////////////////////////////////////////////////////////////////////////\n\nfloat AMBIENT=0.0;\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Sphere {\n    vec3 origin;\n    float radius;\n    vec3 colour;\n    float reflectiveness;\n    float stripe;\n    mat3 mat;\n};\n\nstruct Plane {\n    vec3 origin;\n    vec3 normal;\n    vec3 binormal;\n    vec3 binormal2;\n    float reflectiveness;\n};\n    \nstruct Light {\n    vec3 pos;\n    vec3 colour;\n};\n    \nstruct Result {\n    vec3 pos;\n    vec3 normal;\n    float t0,t1;\n    vec3 colour;\n    float reflectiveness;\n};\n\n///////////////////////////////////////////////////////////////////////////////////\n\nconst int g_numlights=3;\nLight g_lights[g_numlights];\n\nconst int g_numplanes=1;\nPlane g_planes[g_numplanes];\n\nconst int g_maxspheres=8;\n\nconst int g_numspheres=4;\n\nSphere g_spheres[g_maxspheres];\nvec3 g_sphererotspeeds[g_maxspheres];\n\nbool music=false;\n\n///////////////////////////////////////////////////////////////////////////////////\n    \nfloat blerp(float x, float y0, float y1, float y2, float y3) {\n\tfloat a = y3 - y2 - y0 + y1;\n\tfloat b = y0 - y1 - a;\n\tfloat c = y2 - y0;\n\tfloat d = y1;\n\treturn a * x * x * x + b * x * x + c * x + d;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat perlin(float x, float h) {\n\tfloat a = floor(x);\n\treturn blerp(mod(x, 1.0),\n\t\trand(vec2(a-1.0, h)), rand(vec2(a-0.0, h)),\n\t\trand(vec2(a+1.0, h)), rand(vec2(a+2.0, h)));\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\nmat3 rotationmatrix(vec3 a)\n{\n    float cp=cos(a.x);\n    float sp=sin(a.x);\n    float cy=cos(a.y);\n    float sy=sin(a.y);\n    float cr=cos(a.z);\n    float sr=sin(a.z);\n    mat3 pitch = mat3(1, 0, 0, 0, cp, sp, 0, -sp, cp);\n    mat3 yaw = mat3(cy, 0, -sy, 0, 1, 0, sy, 0, cy);\n\tmat3 roll = mat3(cr, sr, 0, -sr, cr, 0, 0, 0, 1);\n    mat3 rotation = pitch*yaw*roll;    \n    return roll;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns intersection points in order of increasing t\n\nResult hit_sphere(Ray ray, Sphere sphere)\n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, NO_INTERSECTION, sphere.colour, sphere.reflectiveness);\n    vec3 oc = ray.origin - sphere.origin;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(oc, ray.direction);\n    float c = dot(oc,oc) - sphere.radius*sphere.radius;\n    float discriminant = b*b - 4.0*a*c;\n    if(discriminant < 0.0){\n        return result;\n    }\n    else{\n        float sqrtdsc = sqrt(discriminant);\n\t\tfloat t1 = (-b - sqrtdsc) / (2.0 * a);\n\t\tfloat t2 = (-b + sqrtdsc) / (2.0 * a);   \n        // t2 must be greater than t1\n        if (t2 <= 0.0) \n        {\t//neither can be > 0\n            return result;\t\n        }\n        else if (t1>0.0)\n        {\t// both must be > 0\n            result.t0=t1;\n            result.t1=t2;\n        }\n        else\n        {\t// only t2 is > 0\n            result.t0=t2;\n        }\n                    \n        result.pos = ray.origin + (ray.direction*result.t0);\n        result.normal = result.pos - sphere.origin;\n        result.normal = normalize(result.normal);\n        return result;      \n\t}\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n\n#ifdef ALTERNATIVE_MASK\n    bool classifynormal(vec3 normal, float stripeyness, mat3 rot)\n    {\n    #ifdef ROTATION    \n        normal = rot*normal;\n    #endif //ROTATION    \n        float val = normal.y * (normal.x + normal.z);\n        val = val * stripeyness * 0.5;\n        val -= floor(val);\n\n        if (val>0.5)\n            return true;\n        else\n            return false;\n    }\n#else\n    bool classifynormal(vec3 normal, float stripeyness, mat3 rot)\n    {\n    #ifdef ROTATION    \n        normal = rot*normal;\n    #endif //ROTATION    \n\n        float maxcomponent = max(abs(normal.x), abs(normal.y));\n        maxcomponent = max(maxcomponent, abs(normal.z));\n\n        maxcomponent = maxcomponent * stripeyness;\n        maxcomponent -= floor(maxcomponent);\n\n        if (maxcomponent>0.5)\n            return true;\n        else\n            return false;\n    }\n#endif //ALTERNATIVE_MASK\n\n///////////////////////////////////////////////////////////////////////////////////\n\nResult hit_object(Ray ray, Sphere sphere)\n{\n    Result result = hit_sphere(ray, sphere);\n        \n    if (classifynormal(result.normal, sphere.stripe, sphere.mat))\n    {\n    \treturn result;\n    }\n    else\n    {\n    \tresult.t0 = result.t1;\n        result.pos = ray.origin + ray.direction*result.t0;\n        result.normal = -normalize(result.pos - sphere.origin);\n\t    if (classifynormal(result.normal, sphere.stripe, sphere.mat))\n        {\n        \treturn result;\n        }\n        else\n        {\n            result.t0 = NO_INTERSECTION;\n        \treturn result;\n        }\n    }\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// calcs the intersection with 2 opposite planes in a single test\n\nResult hit_plane(Ray ray, Plane plane) \n{\n    Result result = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, NO_INTERSECTION, vec3(1.0, 1.0, 1.0), plane.reflectiveness);\n        \n    if (dot(plane.normal, ray.direction) > 0.0) \n    {\t// no intersection with the regular plane, check the 'flipped' plane instead\n        plane.normal = -plane.normal;\n        plane.origin = -plane.origin;\n    }\n\n    float t = (dot(plane.normal, plane.origin) - dot(plane.normal, ray.origin)) / dot(plane.normal, ray.direction);\n    if (t<0.0)\n    {\n    \treturn result;    \n    }\n    \n    vec3 inter = ray.origin + ray.direction*t;    \n    result.t0 = t;\n    result.t1 = t;\n    result.pos = inter;\n    result.normal = plane.normal;\n    \n    // sample the texture in the returned colour\n    vec2 tex;\n    tex.x = dot((result.pos - plane.origin), plane.binormal)*TEXTURESCALE;\n    tex.y = dot((result.pos - plane.origin), plane.binormal2)*TEXTURESCALE;\n    result.colour = texture(iChannel0, tex).xyz * texture(iChannel0, tex).xyz;\t// make it mor 'gaudy' ;-)\n    \n#ifdef CHECKER_PULSE    \n    tex.x = tex.x-floor(tex.x);\n    tex.y = tex.y-floor(tex.y);\n    tex.x-=0.2;\n    tex.y-=0.2;\n    if ((tex.x*tex.y) >= 0.0)\n        result.reflectiveness*=0.5;\n#endif //CHECKER_PULSE    \n    \n    return result;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// ray-world query, returning intersection point, normal, surface colour\n\nResult raycast(Ray ray)\n{\n    Result bestresult = Result(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), NO_INTERSECTION, NO_INTERSECTION, vec3(1.0, 1.0, 1.0), 0.0);    \n    \n    for (int i=0; i<g_numspheres; i++)\n    {\n        Result res = hit_object(ray, g_spheres[i]);    \n        if (res.t0 < bestresult.t0)\n            bestresult=res;    \n    }\n    for (int i=0; i<g_numplanes; i++)\n    {\n    \tResult res = hit_plane(ray, g_planes[i]);    \n        if (res.t0 < bestresult.t0)\n            bestresult=res;    \n    }\n    return bestresult;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns the RGB lighting at a given point\n\nvec3 lighting(Result castresult)\n{\n    // light definition\n    vec3 colour = vec3(0.0, 0.0, 0.0);\n                \n    for (int i=0; i<g_numlights; i++)\n    {\n        // evaluate the point light\n        vec3 lightdir = castresult.pos - g_lights[i].pos;\n        lightdir = normalize(lightdir);\n        float brightness = dot(castresult.normal, -lightdir);\n\n        if (brightness>0.0)\n        {        \n            // cast a ray to the lightsource\n            Ray shadowray;\n            shadowray.origin = castresult.pos + castresult.normal*EPSILON;\n            shadowray.direction = g_lights[i].pos - castresult.pos;\t// no need to normalize this\n            Result shadowresult = raycast(shadowray);\n            if ((shadowresult.t0 == NO_INTERSECTION) || (shadowresult.t0 > 1.0f) || (shadowresult.t0 < 0.0f))\n            {\n                float specular = pow(brightness, SPECULAR_POWER) * SPECULAR_AMOUNT;\n                colour += (brightness*g_lights[i].colour*castresult.colour) + (specular*g_lights[i].colour);\n            }        \n        }\n    }\n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// returns the colour at the intersection point, or AMBIENT\n\nvec3 raytrace(Ray inputray)\n{    \n    Ray ray=inputray;\n    vec3 outputcolour = vec3(AMBIENT, AMBIENT, AMBIENT);\n    float rayweight = 1.0;\n    \n    for (int i=0; i<ITERATIONS; i++)\n    {\n        vec3 colour = vec3(0.0, 0.0, 0.0);\n        Result result = raycast(ray);\n\n        if (result.t0 == NO_INTERSECTION)\n        {\n            // no intersection at this stage, return the accumulated colour so far\n            vec3 colour = vec3(AMBIENT, AMBIENT, AMBIENT);\n            outputcolour = (outputcolour*(1.0-rayweight)) + (colour*rayweight);\n            return outputcolour;\n        }\n        else\n        {                        \n            colour=lighting(result);\n            colour.xyz = max(colour, AMBIENT);            \n            outputcolour = (outputcolour*(1.0-rayweight)) + (colour*rayweight);\n\n            if (result.reflectiveness>0.0)\n            {\n                Ray reflectray;\n                reflectray.origin = result.pos + result.normal*EPSILON;\n                reflectray.direction = reflect(ray.direction, result.normal);\n                ray = reflectray;\n                rayweight = rayweight * result.reflectiveness;\n                if (rayweight < 0.1)\n                {\n                    return outputcolour;\n                }\n            }      \n            else\n            {\n            \treturn outputcolour;    \n            }\n        }\n    }\n    \n    outputcolour.xyz = max(outputcolour, AMBIENT);\n    return outputcolour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// initialise all the primitives\n\nvoid setupscene()\n{\n    float pri=1.0f;\n    float sec=0.4;\n    float ter=0.2;\n\n#ifdef LIGHT_COLOUR_CHANGE    \n    pri=1.0;\n    sec=0.4 + sin(iTime*1.0)*0.4;\n    ter=0.2 + sin(iTime*2.0)*0.2;\n    \n    pri*=2.0f;\n    sec*=2.0f;\n    ter*=2.0f;\n#endif //LIGHT_COLOUR_CHANGE    \n    \n    g_lights[0].colour = vec3(sec, ter, pri);\n    g_lights[1].colour = vec3(ter, pri, sec);\n    g_lights[2].colour = vec3(pri, ter, sec);    \n\n#ifdef DISCO_LIGHTS       \n    if (music)\n    {\n       \tfloat fft  = texelFetch( iChannel1, ivec2(1, 0), 0 ).x; \n    \tfft=fft*fft*fft;\n    \tAMBIENT=fft*0.5;\n        g_lights[0].colour *= fft;\n        g_lights[1].colour *= fft;\n        g_lights[2].colour *= fft;        \n    }\n    else\n    {\n        g_lights[0].colour *= 0.5 + perlin(iTime*8.0, 1.0)*0.6;\n        g_lights[1].colour *= 0.5 + perlin(iTime*7.0, 1.27)*0.6;\n        g_lights[2].colour *= 0.5 + perlin(iTime*5.0, 1.72)*0.6;\n    }\n        \n#endif //DISCO_LIGHTS    \n            \n\tfor (int i=0; i<g_numlights; i++)\n    {\n\t\tfloat h = float(i)*4.0;\n\t\tfloat x = perlin(iTime*0.212, h+1.0)*4.0 - 2.0;\n\t\tfloat y = perlin(iTime*0.341, h+2.0)*4.0 - 2.0;\n\t\tfloat z = 4.0+perlin(iTime*0.193, h+3.0)*4.0;\n\t\tg_lights[i].pos = vec3(x, y, z+LIGHT_ZBIAS);\n\t}   \n    \n    // scene definition\n    g_planes[0] = Plane(vec3(0.0, -5, 0.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 1.0);    \n//    g_planes[1] = Plane(vec3(0.0, +5, 0.0), vec3(0.0, -1.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), 1.0);    \n\n#ifdef MODULATE_PLANE_REFLECTANCE    \n    // animate the plane reflectiveness - this has a surprising side-effect :)\n    g_planes[0].reflectiveness = 0.5 + 0.5*sin(iTime);\n#endif //MODULATE_PLANE_REFLECTANCE    \n   \n    g_spheres[0] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 0.2, 0.2), 0.75, 4.0, mat3(0.0));\n    g_spheres[1] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 1.0, 0.2), 0.75, -5.0, mat3(0.0));\n    g_spheres[2] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 0.2, 1.0), 0.75, 6.0, mat3(0.0));\n    g_spheres[3] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 1.0, 0.2), 0.75, -7.0, mat3(0.0));\n    g_spheres[4] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.2, 1.0, 1.0), 0.75, 5.0, mat3(0.0));\n    g_spheres[5] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 0.2, 1.0), 0.75, -4.0, mat3(0.0));\n    g_spheres[6] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(1.0, 1.0, 1.0), 0.75, 7.0, mat3(0.0));\n    g_spheres[7] = Sphere(vec3(0.0, 0.0, 0.0), 1.0, vec3(0.5, 0.5, 0.5), 0.75, -6.0, mat3(0.0));\n\n    g_sphererotspeeds[0]=vec3(1.0, -0.37, 0.77);\n    g_sphererotspeeds[1]=vec3(1.0, -0.37, -0.77);\n    g_sphererotspeeds[2]=vec3(1.0, 0.37, 0.77);\n    g_sphererotspeeds[3]=vec3(1.0, 0.37, -0.77);\n    g_sphererotspeeds[4]=vec3(-1.0, -0.37, 0.77);\n    g_sphererotspeeds[5]=vec3(-1.0, -0.37, -0.77);\n    g_sphererotspeeds[6]=vec3(-1.0, 0.37, 0.77);\n    g_sphererotspeeds[7]=vec3(-1.0, 0.37, -0.77);    \n    \n\tfor (int i=0; i<g_numspheres; i++)\n    {\n\t\tfloat h = float(i)*4.0;\n\t\tfloat size = \t\tperlin(HURRY_UP*iTime*0.251, h+4.0)*1.0 + 1.5;\n\t\tfloat x    = \t\tperlin(HURRY_UP*iTime*0.212, h+1.0)*20.0-10.0;\n\t\tfloat y    = \t\tperlin(HURRY_UP*iTime*0.341, h+2.0)*20.0-10.0;\n\t\tfloat z    = 35.0 + perlin(HURRY_UP*iTime*0.193, h+3.0)*20.0-10.0;\n\t\tg_spheres[i].origin = vec3(x*0.4, y*0.25, z*0.25-1.0);\n        g_spheres[i].radius=size;\n        g_spheres[i].mat = rotationmatrix(iTime*g_sphererotspeeds[i]);\n\t}    \n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// 'volumetric' light rendering\n\nvec3 volumelights( Ray ray )\n{   \n    float castdistance=10.0;\n    float caststep=VOLUME_STEP;\n    float castscale=castdistance/caststep;\n\n    Result occlusionresult = raycast(ray); \n    castdistance = min(occlusionresult.t0, castdistance);\n                \n    vec3 colour = vec3(0.0, 0.0, 0.0);            \n    for (float t=0.0; t<castdistance; t+=caststep)\n    {\n        vec3 pos = ray.origin + ray.direction*t;\n        \n        for (int i=0; i<g_numlights; i++)\n        {\n            vec3 deltapos = g_lights[i].pos-pos;\n            float d2=length(deltapos);\n\n            Ray shadowray;\n            shadowray.origin = pos;\n            shadowray.direction = deltapos;\n            Result shadowresult = raycast(shadowray);\n            if (d2<8.0)\n            {\n                if (shadowresult.t0<0.0 || shadowresult.t0>1.0)            \n                    colour.xyz += g_lights[i].colour/(d2*castscale);\n            }                                \n        }\n    }\n    \n    return colour;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// main loop, iterate over the pixels, doing MSAA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // is there a better way of determining if the preview screen is active ?\n#ifdef MUSIC\n    if (iResolution.x<640.0)\n        music=false;\n    else \n        music=true;\n#endif //MUSIC\n    \n\tsetupscene();\n    \n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    float factor = 1.0/(MSAA*MSAA);\n    \n    for (float x=0.0; x<MSAA; x++)\n    {\n        for (float y=0.0; y<MSAA; y++)\n        {\n            vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n            uv.y *= iResolution.y / iResolution.x;\n\n            uv.x += (1.0/(iResolution.x*MSAA))*x;\n            uv.y += (1.0/(iResolution.y*MSAA))*y;\n            \n            Ray ray;\n            ray.origin = vec3(0.0, 0.0, 0.0);\n            ray.direction = uv.xyx;\n            ray.direction.z = 1.0;\n            ray.direction = normalize(ray.direction);\n\n            fragColor.xyz += raytrace(ray)*factor;\n        }        \n    }\n    \n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y / iResolution.x;\n    Ray ray;\n    ray.origin = vec3(0.0, 0.0, 0.0);\n    ray.direction = uv.xyx;\n    ray.direction.z = 1.0;\n    ray.direction = normalize(ray.direction);\n    \n#ifdef VOLUMETRIC_LIGHTING    \n    fragColor.xyz += volumelights(ray);\n#endif //VOLUMETRIC_LIGHTING\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n","name":"Image","description":"","type":"image"}]}