{"ver":"0.1","info":{"id":"lcdyW4","date":"1730678397","viewed":45,"name":"2D SDF Blending","username":"Tottery","description":"Based on Sébastien Lagarde's cubemap blending algorithm.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["2d","distancefield","sdf","blending"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Originally based on Inigo's \"Disk - distance 2D\" (https://www.shadertoy.com/view/3ltSW2)\n// Reference: Sébastien Lagarde \"Image-based Lighting approaches and parallax-corrected cubemap\"\n\n\n// Normalized and inverted Signed Distance Functions\n// [0.0, 1.0], where 0 is the edge, and 1 is the center\nfloat sdCircle( in vec2 p, in float r ) \n{\n    return -(length(p)-r)/r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = (abs(p)-b)/b;\n    return -length(max(d,0.0)) - min(max(d.x,d.y),0.0);\n}\n\n// The idea is to make sure that sum of distances where shapes overlap\n// must never exceed 1.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    // Smaller Red Circle\n\tfloat d1 = sdCircle(p-vec2(0.5+sin(iTime), 0.),0.25);\n    \n    // Blue Square\n    float d2 = sdBox(p, vec2(0.5,0.5));\n    \n    // Bigger Green Circle\n    float d3 = sdCircle(p-vec2(-0.5, 0.-cos(iTime)*0.5), 0.5);\n    \n    float td1 = 1.0;\n    float td2 = 1.0;\n    float td3 = 1.0;\n    \n    // Ideally, you should iterate over shapes, and make sure to compute\n    // the weights according to what shapes are overlapping for current pixel.\n    // For now, since number of shapes is known (and number is small) just brute force\n    // possible cases\n    if(d1>=0.0 && d2>=0.0)\n    {\n        float total = d1+d2;\n        td1 = d1/total;\n        td2 = d2/total;\n    }\n    if(d1>=0.0 && d3>=0.0)\n    {\n        float total = d1+d3;\n        td1 = d1/total;\n        td3 = d3/total;\n    }\n    if(d2>=0.0 && d3>=0.0)\n    {\n        float total = d2+d3;\n        td2 = d2/total;\n        td3 = d3/total;\n    }\n     if(d1>=0.0 && d2>=0.0 && d3>=0.0)\n    {\n        float total = d1+d2+d3;\n        td1 = d1/total;\n        td2 = d2/total;\n        td3 = d3/total;\n    }\n    \n\t// coloring\n    vec3 col1 = (d1>0.0) ? vec3(1.0,0.,0.) : vec3(0.,0.,0.);\n    vec3 col2 = (d2>0.0) ? vec3(0.,0.,1.0) : vec3(0.,0.,0.);\n    vec3 col3 = (d3>0.0) ? vec3(0.,1.0, 0.) : vec3(0.,0.,0.);\n    \n    // Background Color\n    vec3 col = vec3(0.,0.,0.);\n    \n    if(d1>=0.0 || d2>=0.0 || d3>=0.0) \n    {\n        col = col1*td1 + col2*td2 + col3*td3;\n    }\n\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}