{"ver":"0.1","info":{"id":"Xdc3DH","date":"1449221617","viewed":319,"name":"Moon & sky","username":"Draedrus","description":"An essai of what can be done here. Some functions here are inspired from their ones.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["clouds","sky","stars","moon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"/**\n* author: Pierre-Marie Plans\n* mail: pierre.plans@gmail.com\n**/\n\n#define OCTAVES 8\n\nvec4 cRed = vec4(0.9, 0.5, 0.0, 1.0);\nvec4 cYellow = vec4(0.9, 0.9, 0.0, 1.0);\nvec4 cRing = vec4(1.0, 0.5, 0.4, 1.0);\nvec4 cViolet = vec4(0.5, 0.4, 1.0, 1.0);\n\n/**\n * noise inspired by common knowledge found in internet.\n **/\nfloat noise(float x)\n{\n    return fract(sin(x)*556858.4905705783);\n}\n\n// inspired from TDM code \"Seascape\"\nfloat smoothNoise(vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 n = fract(x);\n    vec3 f = n*n*(3.0-2.0*n);\n    float winy = 157.0;\n    float winz = 113.0;\n    \n    float wx = p.x+winy*p.y+winz*p.z;\n    return mix(\n        \tmix(\n                mix(noise(wx+0.0)     ,      noise(wx+1.0), f.x),\n                mix(noise(wx+0.0+winy), noise(wx+1.0+winy), f.x),\n                f.y),\n        \tmix(\n                mix(noise(wx+0.0+winz)     ,      noise(wx+1.0+winz), f.x),\n                mix(noise(wx+0.0+winy+winz), noise(wx+1.0+winy+winz), f.x),\n                f.y)\n        , f.z);\n}\n\n/**\n * This one is inspired by IQ code \"Clouds\" from this website.\n **/\nfloat perlin(vec3 V)\n{\n    float total = 0.0;\n    for(int i=1;i<OCTAVES+1;i++) {\n        total += (1.0/float(i))*smoothNoise(V);\n        V*=2.0+(float(i)/100.0);\n    }\n    return total;\n}\n\nfloat gaussianGlow(vec2 uv, vec2 c, float p)\n{\n    float d = length(uv-c);\n    return 4.01*pow(2.0, p*d);\n}\n\nvec4 renderMoon(vec2 uv, vec2 center, float gaussian)\n{\n    float d = length(uv-center);\n    float p = perlin(vec3(-uv*uv, -d));\n    vec4 color = vec4(gaussian)+vec4(0.0, 0.0, 0.2*(1.0-gaussian), 1.0);\n    if(gaussian>=0.9) {\n        color=vec4(1.0-smoothNoise(vec3(\n            p-0.2\n        ))\n                  )*(2.0-pow(log2(1.0+4.0*d),8.0));\n    }\n    return color;\n}\n\nvec4 render(vec2 uv, vec2 center)\n{\n    vec4 color = vec4(0.0);\n    float limit = 0.16;\n    float d = length(uv-center);\n    float tf = iTime;\n    float tf100 = iTime/100.0;\n    float tf1000 = iTime/1000.0;\n    float n = noise(d*cos(uv.x)*sin(uv.y));\n    d = d+0.01;\n    float gaussianG = gaussianGlow(uv, center, -16.0);\n\n    // moon\n    color = renderMoon(uv, center, gaussianG);\n    // clouds\n    float e = perlin(vec3(uv.x-tf100, uv.y, (uv.x-uv.y)+tf100));\n    color = mix(color, vec4(e)*vec4(0.6), d);\n    e = perlin(vec3(uv.x-tf1000, uv.y, (uv.x+uv.y)-tf1000));\n    color = mix(color, vec4(e)*vec4(0.42), d);\n    // stars\n    if(n>0.99 && d>0.15) {\n        color = mix(color, vec4(1.0),\n                    max(\n                        cos(noise(d+dot(uv, uv))*tf),\n                        0.0\n                    )*\n                    (\n                        max(cos(uv.x/tf+4.71), 0.0)*\n                        max(sin(uv.y/tf+4.71), 0.0)\n                        +0.5235\n                    )\n                   );\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / vec2(iResolution.x*0.6, iResolution.y);//iResolution.xy;\n    vec2 center = vec2(0.85, 0.5);\n    vec4 color = vec4(0.0);\n\n    color = mix(\n        \t\tmix(render(uv+vec2(-0.001, -0.001), center),\n                    render(uv+vec2(-0.001, 0.001), center), 0.5),\n        \t\tmix(render(uv+vec2(0.001, -0.001), center),\n                    render(uv+vec2(0.001, 0.001), center), 0.5),\n        \t\t0.5);\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}]}