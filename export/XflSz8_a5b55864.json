{"ver":"0.1","info":{"id":"XflSz8","date":"1704949813","viewed":62,"name":"Gravity-mediated hexagons!","username":"megaleo","description":"Just a bunch of particles in a box with gravity and repulsive interactions.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["hexagon","physics","gravity","genuary","genuary2024","genuary10"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////\n// Adapted from https://www.shadertoy.com/view/XdcGWS\n// Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch(iChannel0, vAddr, 0);\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\nParticle LoadParticle(int index)\n{\n    Particle p;\n    vec4 pVec = LoadVec4(ivec2(0, index));\n    p.pos = pVec.xy;\n    p.vel = pVec.zw;\n    \n    return p;\n}\n\nvoid StoreParticle(Particle p, int index, inout vec4 fragColor, in vec2 fragCoord)\n{\n    StoreVec4(ivec2(0, index), vec4(p.pos, p.vel), fragColor, fragCoord);\n}\n\nbool AtParticle( vec2 p, int i ) { return AtAddress(p, ivec2(0, i)); }\n\nbool AtSomeParticle( vec2 p) { return (floor(p.x) == 0.) && (floor(p.y) >= 0.) && ((floor(p.y) < float(N_PARTICLES))); }\n\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0., 0., 0.);\n    vec2 f = vec2(0., 0.);\n    for (int i=0; i<N_PARTICLES; i++)\n    {\n        Particle p = LoadParticle(i);\n        vec2 diff = fragCoord - p.pos;\n        float d = length(diff);\n        f += force(diff);\n        col += clamp(exp(-d*d/200.)*vec3(0., 0., 1.),0.,1.);\n    }\n    //vec2 polar = cx_to_polar(f);\n    //vec3 rgb = hsb2rgb(vec3(polar.y / (2.0*PI), 1.0, tanh(polar.x)));    \n    col = mix(col, tanh(length(f)/10.)*vec3(1.,0.,0.), 0.5);\n    // Output to screen\n    fragColor = vec4(col,1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/////////////////////////\n// Adapted from https://www.shadertoy.com/view/XdcGWS\n// Storage\n\nvec4 LoadVec4( in ivec2 vAddr )\n{\n    return texelFetch( iChannel0, vAddr, 0 );\n}\n\nvec3 LoadVec3( in ivec2 vAddr )\n{\n    return LoadVec4( vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, ivec2 c ) { return all( equal( floor(p), vec2(c) ) ); }\n\nvoid StoreVec4( in ivec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in ivec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\nParticle LoadParticle(int index)\n{\n    Particle p;\n    vec4 pVec = LoadVec4(ivec2(0, index));\n    p.pos = pVec.xy;\n    p.vel = pVec.zw;\n    \n    return p;\n}\n\nvoid StoreParticle(Particle p, int index, inout vec4 fragColor, in vec2 fragCoord)\n{\n    StoreVec4(ivec2(0, index), vec4(p.pos, p.vel), fragColor, fragCoord);\n}\n\nbool AtParticle( vec2 p, int i ) { return AtAddress(p, ivec2(0, i)); }\n\nbool AtSomeParticle( vec2 p) { return (floor(p.x) == 0.) && (floor(p.y) >= 0.) && ((floor(p.y) < float(N_PARTICLES))); }\n\n///////////////////////\n\n// Inside boundary set by v*p.pos + c > 0\nvoid reflectBoundary(inout Particle p, vec2 v, float c)\n{\n    if (dot(v, p.pos) + c < 0.)\n    {\n        p.pos -= 2.*((dot(v, p.pos)+c)/dot(v,v))*v;\n        p.vel -= 2.*((dot(v, p.vel))/dot(v,v))*v;\n    }\n}\n\nvoid reflectFrame(inout Particle p, vec2 res)\n{\n    reflectBoundary(p, vec2(1., 0.), 0.); // left edge\n    reflectBoundary(p, vec2(-1., 0.), res.x); // right edge\n    reflectBoundary(p, vec2(0., -1.), res.y); // top edge\n    reflectBoundary(p, vec2(0., 1.), 0.); // bottom edge\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \n    // If first frame, initialize state\n    if (iFrame == 0) \n    {\n        for (int i=0; i<N_PARTICLES; i++)\n        {\n            //vec2 pos = iResolution.xy*vec2(rand(23.*float(i)), rand(2039.*float(i)));\n            float spacing = 40.1;\n            vec2 pos = vec2(mod(spacing*float(i), iResolution.x), spacing*(1.+floor(spacing*float(i)/iResolution.x)));\n            //vec2 vel = 0.1*(vec2(rand(2389.*float(i)), rand(0.234*float(i))) - vec2(0.5,0.5));\n            vec2 vel = vec2(0.0);\n            Particle p = Particle(pos, vel);\n            StoreParticle(p, i, fragColor, fragCoord);\n        }\n    } else\n    {\n        if (AtSomeParticle(fragCoord))\n        {\n            int i = int(fragCoord.y);\n            vec2 acc = vec2(0., 0.);\n            Particle p = LoadParticle(i);\n            \n            // Interparticle forces\n            for (int j=0; j<N_PARTICLES; j++)\n            {\n                if (j != i)\n                {\n                    Particle pj = LoadParticle(j);\n                    acc += force(pj.pos-p.pos);\n                }\n            }\n            // Gravity\n            acc += -0.005*vec2(0., 1.);\n            \n            // Velocity damping\n            acc += -0.001*p.vel*length(p.vel);\n            \n            p.vel += acc;\n            p.pos += p.vel;\n            // If out of frame, reflect it back\n            reflectFrame(p, iResolution.xy);\n            StoreParticle(p, i, fragColor, fragCoord);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Particle pos is stored at the addresses ivec2(0, y) in the xy coords\n// and its velocity is store in zw coords.\n\n#define PARTICLE_COLOR vec4(1.0, 1.0, 1.0, 1.0)\n#define N_PARTICLES 180\n#define PI 3.141592654\n\nstruct Particle\n{\n    vec2 pos;\n    vec2 vel;\n};\n\n\nfloat rand2 (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat rand (float s) {\n    return fract(sin(dot(vec2(s,s),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nvec2 cx_to_polar(vec2 a) {\n    float phi = atan(a.y, a.x);\n    float r = length(a);\n    return vec2(r, phi); \n}\n\n\n// Force in terms of the difference of positions p2-p1\nvec2 force (vec2 diff)\n{\n    //float k = 2.;\n    //float d = length(diff);\n    //float f = clamp(k/(d*d),0.,5.);\n    //return -f*diff/d;\n    // Lennard-Jones force https://en.wikipedia.org/wiki/Lennard-Jones_potential\n    float d = length(diff);\n    vec2 dVec = normalize(diff);\n    float sigma = 30.;\n    float epsilon = 0.2;\n    vec2 f = 4.*epsilon*(1./sigma)*(6.*pow(sigma/d, 7.) - 12.*pow(sigma/d, 13.))*dVec;\n    return normalize(f)*clamp(length(f),0.,10.);\n}\n\n","name":"Common","description":"","type":"common"}]}