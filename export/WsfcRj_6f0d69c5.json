{"ver":"0.1","info":{"id":"WsfcRj","date":"1585090218","viewed":115,"name":"R11G11B10 Dither Blue Noise","username":"pastasfuture","description":"Original shader toy by Khayzo: https://www.shadertoy.com/view/4slBDl\n\nTriangular blue noise dither by hornet","likes":2,"published":1,"flags":16,"usePreview":0,"tags":["dither","bluenoise","r11g11b10"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define FLOAT32 0\n#define FLOAT16\t1\n#define FLOAT11\t2\n#define FLOAT10\t3\n#define FLOAT8\t4\n\n#define FLOAT_TYPE_COUNT 5\n\n#define EFloatType int\n\n//#define SHOW_RELATIVE_ERROR\n//#define SHOW_DITHER\n\n#define RANGE_LOW 0.0\n\n// 6.50e4 is max value for 11 and 10 bit floats\n#define RANGE_HIGH 6.50e4\n\n#ifndef SHOW_RELATIVE_ERROR\n#define REMAP_RANGE_TO_01\n#endif\n\n// Increase dither size to 2.0 or 4.0 to help visualize noise pattern.\n#define DITHER_SIZE (1.0)\n\nstruct FloatDesc\n{\n\tbool signBit;\n\tint nbitsExponent;\n\tint nbitsMantissa;\n};\n\nconst FloatDesc gFloatDescs[FLOAT_TYPE_COUNT] = FloatDesc[FLOAT_TYPE_COUNT](\n\tFloatDesc(true,  8, 23 ), // FLOAT32\n\tFloatDesc(true,  5, 10 ), // FLOAT16\n\tFloatDesc(false, 5, 6  ), // FLOAT11\n\tFloatDesc(false, 5, 5  ), // FLOAT10\n    FloatDesc(false, 5, 3  )  // FLOAT8\n);\n// Quantize a 32-bit float to a float with 'nbitsMantissa' bits of mantissa\nfloat F32ToFn(float f, const int nbitsMantissa)\n{\n\tint bits = floatBitsToInt(f);\n\n    int s = bits >> 31;\t// sign\n    int expo = (bits & 0x7f800000) >> 23; // exponent\n    int m = bits & 0x007fffff; // mantissa\n\n  \tconst float exponentBias32 = 127.0;\n    float decodedExponent = float(expo) - float(exponentBias32);\n\n    float decodedSignificand = 1.0;\n\n    for(int i = 0; i < nbitsMantissa; ++i)\n    {\n        int bit = (1 << (23 - i - 1));\n        if((m & bit) != 0)\n        {\n            decodedSignificand += exp2(-(float(i)+1.0));\n        }\n    }\n\n    return decodedSignificand * exp2(decodedExponent);\n}\n\n// Quantize a 32-bit float to a float of the given type\nfloat F32To(EFloatType ftype, float f)\n{\n\treturn F32ToFn(f, gFloatDescs[ftype].nbitsMantissa);\n}\n\n\n// Quantum for the float f with 'nbitsMantissa' bits of mantissa\nfloat FnQuantum(float f, const int nbitsMantissa)\n{\n    float e = floor(log2(f));   \n    return exp2(e - float(nbitsMantissa));\n}\n\n// Quantum for the float f of the given type\nfloat FQuantum(EFloatType ftype, float f)\n{\n    return FnQuantum(f, gFloatDescs[ftype].nbitsMantissa);\n}\n\nfloat FQuantumConservativeApproximate11(float f)\n{\n    // return exp2(floor(log2(f)) - float(nbitsMantissa));\n    // Conservatively approximate f's quantum by dropping floor() from the calculation.\n    // return exp2(log2(f) - float(nbitsMantissa));\n    // return f / exp2(float(nbitsMantissa));\n    // return f / exp2(6.0f);\n    return f * (1.0 / 64.0);\n}\n\nfloat FQuantumConservativeApproximate10(float f)\n{\n    // return exp2(floor(log2(f)) - float(nbitsMantissa));\n    // Conservatively approximate f's quantum by dropping floor() from the calculation.\n    // return exp2(log2(f) - float(nbitsMantissa));\n    // return f / exp2(float(nbitsMantissa));\n    // return f / exp2(5.0f);\n    return f * (1.0 / 32.0);\n}\n\n// Low Complexity, High Fidelity: The Rendering of INSIDE\n// https://youtu.be/RdN06E6Xn9E?t=1337\n// Remaps a [0, 1] value to [-0.5, 1.5] range with a triangular distribution.\nvec3 saturate(vec3 x)\n{\n\treturn clamp(x, 0.0, 1.0);\n}\n\nvec3 NoiseDitherRemapTriangularDistribution(vec3 v)\n{\n    vec3 orig = v * 2.0 - 1.0;\n    vec3 c0 = 1.0 - sqrt(saturate(1.0 - abs(orig)));\n    return 0.5 + vec3(\n        (orig.x >= 0.0) ? c0.x : -c0.x,\n        (orig.y >= 0.0) ? c0.y : -c0.y,\n        (orig.z >= 0.0) ? c0.z : -c0.z\n    );\n}\n\nvec3 SampleScreenSpaceBlueNoise(vec2 positionSS)\n{\n    vec2 iChannel1Resolution = iChannelResolution[1].xy;\n    vec2 uv = fract(positionSS / iChannel1Resolution);\n    return texture(iChannel1, uv).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float f = uv.y > 0.5 ? uv.x : uv.x *  (RANGE_HIGH - RANGE_LOW) + RANGE_LOW; // [0.0, 1.0] : [RANGE_LOW, RANGE_HIGH]\n  \n    float r = f;\n    float g = f;\n    float b = f;\n    \n    vec3 dither = SampleScreenSpaceBlueNoise(floor(fragCoord.xy / DITHER_SIZE) + vec2(0.5));\n\n    if (fract(uv.y * 2.0) > 0.5)\n    {\n        // Upper half of the gradients is triangular distributed blue noise.\n        dither = NoiseDitherRemapTriangularDistribution(dither);\n    }\n    else\n    {\n        // Lower half of the gradients is uniform distributed blue noise.\n    }\n\n    // Upper half of each half gradient is exact quantum, lower half is cheap approximate quantum.\n    float fQuantum11 = (fract(uv.y * 4.0) > 0.5) ? FQuantum(FLOAT11, f) : FQuantumConservativeApproximate11(f);\n    float fQuantum10 = (fract(uv.y * 4.0) > 0.5) ? FQuantum(FLOAT10, f) : FQuantumConservativeApproximate10(f);\n\n\n    dither *= vec3(fQuantum11, fQuantum11, fQuantum10);\n\n    // Apply per-component float dithering\n    bool mouseBtnPressed = (iMouse.z >= 1.0);\n    if(mouseBtnPressed)\n    {\n   \t\tr += dither.r;\n        g += dither.g;\n        b += dither.b;\n    }\n    \n    // Quantize 32-bit floats to R11G11B10F\n    r = F32To(FLOAT11, r);\n    g = F32To(FLOAT11, g);\n    b = F32To(FLOAT10, b);\n    \n    vec3 rgb = vec3(r, g, b);\n    \n    #ifdef REMAP_RANGE_TO_01\n    if(uv.y < 0.5)\n    \trgb = (rgb - RANGE_LOW) / (RANGE_HIGH - RANGE_LOW);\n    #endif\n       \n   \t#ifdef SHOW_RELATIVE_ERROR\n    vec3 relativeError = abs((vec3(f) - rgb) / vec3(f));\n    rgb = relativeError * 10.0;\n    #elif defined(SHOW_DITHER)\n    rgb = vec3(dither11, dither11, dither10) * 100.0;\n    #endif\n    \n    // Separator\n    vec2 texelSize = vec2(1.0 / iResolution.xy);\n    float lineWidth = 4.0;\n    if(abs(uv.y - 0.5) < (0.25 * lineWidth * texelSize.y)) rgb = vec3(0);\n    \n\tfragColor = vec4(rgb, 1);\n}","name":"Image","description":"","type":"image"}]}