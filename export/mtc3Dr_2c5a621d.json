{"ver":"0.1","info":{"id":"mtc3Dr","date":"1682229825","viewed":96,"name":"tiny morphing star","username":"tholzer","description":"Fork of 'tiny code star' by flockaroo.\nSpecial thing here is stepping in a narrow spiral in view direction.\nAlso check 1tweet version (no reflection) [url]https://twigl.app/?ol=true&ss=-NTOvYWIEieDpcGD3IMg[/url]","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["normals","spiral","tiny","octahedra","golfed","twigl"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"tiny code star - spiral stepping\" by flockaroo. \n//   https://shadertoy.com/view/dlcGRH   2023-04-23 \n\n// created by florian berger (flockaroo) - 2023-04-23\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// 5 intersecting octahedras\n\n// less than 1 tweet in twigl.app (no cubemap there):\n// https://twigl.app/?ol=true&ss=-NTOvYWIEieDpcGD3IMg\n\n//  explanation of spiral-stepping:\n// ---------------------------------\n//  special thing here is that im stepping in a narrow spiral in view direction\n//  the normal is then calculated from the triangle formed by last 3 step-points\n//  i think it works quite well, and might be even practicable for non-golfed code\n\n#define rotate2D(x) mat2(cos(x-1.57*vec4(0,1,-1,0)))\n#define t 0.5*iTime\n#define r iResolution\n\nvoid mainImage (out vec4 o, in vec2 c)\n{ vec3 z=vec3(0,0,66), q=z, p, u, v;\n  for(float w,d,i=0.; i++<48.;\n    v=u, u=q,\n    q+=(vec3(c,0)*2.-r.xyx)/r.x*d+vec3(sin(i),cos(i),0)) // sin,cos = spiral offs in x,y\n  for(d=w=7.;w>0.;w-=1.26)\n  { p=q;\n    float tw = (iMouse.z > 0.5) ? w : t+w;\n    p.xz*=rotate2D(tw);\n    p.xy*=rotate2D(1.5+sin(t));\n    d=min(d,dot(p+sin(p)*.2,sign(p)*.3)-9.);\n  }\n  u=cross(q-u,q-v); // normal = cross product of 2 triangle edges (last 3 step points u,v,q)\n  o.xyz=texture(iChannel0,reflect(q-z,u)).xyz-u*.1;\n}\n","name":"Image","description":"","type":"image"}]}