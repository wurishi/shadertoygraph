{"ver":"0.1","info":{"id":"Nt2cDc","date":"1650485067","viewed":185,"name":"3D light room","username":"batersy","description":"simulate 3D reflection, refraction and absorption on two type shape: sphere and prism.\nyou can choose light source type from laser, point or parallel light. have fun.","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","reflection","refraction","prism","laser"],"hasliked":0,"parentid":"stjyWK","parentname":"3D light room laser"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * 3D light room by batersy\n * Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n * Contact: seplanely@gmail.com\n */\n\n// you can switch two types of shape: sphere and prism(N-side prism, N >= 3)\n// and three types of light source: laser, point or parallel light source\n// see buffer A for more configuration\n// need to reset time after configuration change because the images are generated cumulatively.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// ------config recommended, need reset time after modification----\n// choose render object type: 1-sphere 2-triangular prism\n#define RENDER_OPJECT_TYPE 1\n// set light will diffuse or only reflect at box room edge, diffuse is more natural\n#define EDGE_LIGHT_DIFFUSE 1\n// set light source type: 1-laser light 2-point light 3-parallel light\n#define LIGHT_SOURCE_TYPE 1\n// light direction when you choose laser light or parallel light\nvec3 laserDirection = normalize(vec3(1.0,0.1,-0.3));\n// coordinate hint: everything in a 2*2*2 box, center at (0,0,0)\n// and right, top, back at default camera view are positive x,y,z axis\n// laser position when you choose laser light or point light\nvec3 initLo = vec3(-0.5,0,0);\n\n// ------some render configs-----------\n// set bigger to accelerate iteration, but will reduce fps\nint sampleCount = 6;\nfloat laserThickness = .003;\nint maxBounceCount = 6;\n// camera distance to center object\nfloat camDis = 0.618;\n// set bigger to be brighter\n#if LIGHT_SOURCE_TYPE == LASER_LIGHT_SOURCE\nint brightness = 6;\n#else\nint brightness = 200;\n#endif\n// transmittance config\n#define ENABLE_ATTENUATION 1\nfloat sigmaAir = 0.01;\nfloat sigmaShape = 0.5;\nfloat transmittanceStop = .1;\n\n// ------shape definition-----------\n// space box\nvec3 box = vec3(2);\n// spheres define as format vec4(x, y, z, radius)\nvec4 sphere = vec4(vec3(0,0,0),0.2);\n// prisms define as format vec3(radius, height, sides)\n// sides = 3 is triangular prism, 4 is cuboid...\nvec3 prism = vec3(0.2,0.2,3);\n// and more to do...\n\n// ------common things-----------\nvec3 drawLine(vec3 ro, vec3 rd, vec3 from, vec3 to, vec3 color, vec2 trans) {\n    float t = iCylinder(ro, rd, from, to, laserThickness);\n    if(t > 0.0) {\n        vec3 pos = ro + t * rd;\n        float dis = getLineDis(ro, rd, from, to);\n        float k = (to.x == from.x) ? 0. : (pos.x - from.x) / (to.x - from.x);\n        float tran = 1.0;\n#if ENABLE_ATTENUATION\n        tran = mix(trans.x, trans.y, k);\n#endif\n        return color * tran * smoothstep(1.0, 0.0, dis / laserThickness);\n    }\n\n    return vec3(0);\n}\n\nfloat getNearestShape(vec3 ro, vec3 rd, out int type, out vec3 normal, float outside, int renderType) {\n    float t = boxIntersect(ro, rd, box, normal);\n    type = TYPE_EDGE;\n\n    float tmp_t;\n    vec3 tmp_normal;\n    \n    if(renderType == TYPE_SPHERE) {\n        tmp_t = raySphIntersect(ro, rd, sphere, tmp_normal);\n        if(tmp_t > 0.0 && tmp_t < t) {\n            type = TYPE_SPHERE;\n            t = tmp_t;\n            normal = tmp_normal;\n        }\n    } else if(renderType == TYPE_PRISM) {\n        vec4 tmp;\n        if(outside > 0.) tmp = iPrismOutside(ro, rd, prism.x, prism.y, int(prism.z));\n        else tmp = iPrismInside(ro, rd, prism.x, prism.y, int(prism.z));\n        tmp_t = tmp.x;\n        if(tmp_t > 0. && tmp_t < MAX_DIST && tmp_t < t) {\n            type = TYPE_PRISM;\n            t = tmp_t;\n            normal = tmp.yzw;\n        }\n    }\n    \n    return t;\n}\n\nvoid paintShape(vec3 ro, vec3 rd, inout vec3 color, int renderType) {\n    float sdf;\n    vec3 normal;\n    float t = boxIntersect(ro, rd, box, normal);\n    color += 0.2 * abs(dot(normal, vec3(.8,.4,.6)));\n\n    if(renderType == TYPE_SPHERE) {\n        if(raySphIntersect(ro, rd, sphere, normal) > 0.)\n            color += 0.2 + 0.4 * dot(-normal, laserDirection);\n    } else if(renderType == TYPE_PRISM) {\n        vec4 tmp = iPrismOutside(ro, rd, prism.x, prism.y, int(prism.z));\n        if(tmp.x > 0. && tmp.x < MAX_DIST) {\n            color += 0.4 * abs(dot(tmp.yzw, vec3(.8,.4,.6)));\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float ratio = iResolution.x / iResolution.y;\n    uint state = uint(fragCoord.x) + uint(fragCoord.y) * uint(iResolution.x) + uint(iFrame) * uint(iResolution.x) * uint(iResolution.y);\n    vec3 color = vec3(0);\n\n    // remember when the mouse moved\n    vec4 persistentState = texelFetch(iChannel0, ivec2(0), 0);\n    if (ivec2(fragCoord) == ivec2(0)) {\n        fragColor = persistentState;\n        if (iFrame == 0) fragColor = vec4(0);\n        if (iMouse.z > 0.) fragColor.w = float(iFrame);\n        return;\n    }\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    // mouse map to screen\n    if(ivec2(iMouse.xy) != ivec2(0)) mo -= vec2(0.5);\n    else mo = vec2(0., -0.5);\n    float angleX = 1.6 + 3.5 * mo.x;\n    float angleY = -3.5 * mo.y;\n    vec3 ro = camDis * vec3(cos(angleX)*cos(angleY), sin(angleY), sin(angleX)*cos(angleY));\n    vec3 ta = vec3(0);\n    mat3 cam2World = LookAt(ro, ta, angleY);\n    vec3 rd = cam2World * normalize(vec3(p.xy, -1.0));\n    \n    float t, f, sigma;\n    vec3 pos, normal;\n    const float A = 1.2280;\n    const float B = 0.09;\n    float n1 = 1.00029;\n\n    for(int i = 0; i < sampleCount; ++i) {\n        float w = mix(380.0, 750.0, pcg(state));\n        vec3 rayColor = xyzToRgb(xyzFit_1931(w));\n        rayColor *= 1e-13 * BlackBody(6000.0, w);\n        \n        // laser position\n        vec3 lo = initLo;\n        if(LIGHT_SOURCE_TYPE == PARALLEL_LIGHT_SOURCE) {\n            lo.y = random(-1.0, 1.0, state);\n            lo.z = random(-1.0, 1.0, state);\n        }\n        // laser direction\n        vec3 ld = laserDirection;\n        if(LIGHT_SOURCE_TYPE == POINT_LIGHT_SOURCE) ld = generateRandomVector(state);\n\n        int count = 0, type;\n        float n2 =  A + B/(w*w*1e-6);\n        float outside = 1.0, transmittance = 1.0, transmittanceNew = 1.0;\n        while(transmittance > transmittanceStop && count < maxBounceCount) {\n            // find nearest sdf\n            t = getNearestShape(lo, ld, type, normal, outside, RENDER_OPJECT_TYPE);\n            if(t < 0.0) break;\n            sigma = (outside > 0.) ? sigmaAir : sigmaShape;\n            transmittanceNew *= exp(-sigma * t);\n\n            // paint path and update transmittance\n            pos = lo + t * ld;\n            color += drawLine(ro, rd, lo, pos, rayColor, vec2(transmittance, transmittanceNew));\n            transmittance = transmittanceNew;\n\n            // update ray\n            lo = pos;\n            if(type == TYPE_EDGE && EDGE_LIGHT_DIFFUSE > 0) {\n                // path tracing, random choose a direction when hit on diffuse surface\n                ld = generateRandomVector(state);\n                if(dot(ld, -normal) < 0.0) ld = -ld;\n            } else {\n                normal = normal * outside;\n                if(type == TYPE_EDGE) {\n                    // only reflect light, means specular surface\n                    f = 1.;\n                } else {\n                    if(outside > 0.) f = fresnel(n1, n2, dot(-ld, normal));\n                    else f = fresnel(n2, n1, dot(-ld, normal));\n                }\n                if(pcg(state) < f) {\n                    ld = reflect(ld, normal);\n                } else {\n                    ld = refract(ld, normal, pow(n2 / n1, -outside));\n                    outside = -outside;\n                }\n            }\n\n            // prevent chaos when checking whether lo inside sdf\n            lo += ld * 0.00001;\n            count++;\n        }\n    }\n\n    color *= float(brightness / sampleCount);\n    paintShape(ro, rd, color, RENDER_OPJECT_TYPE);\n    if( iFrame!=0 ) {\n        vec3 lastColor = texelFetch( iChannel0, ivec2(fragCoord), 0 ).xyz;\n        color = mix(lastColor, color, 1./(float(iFrame) - persistentState.w));\n    }\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define PI 3.1415926535898\n#define MAX_DIST 1e3\n#define TYPE_EDGE 0\n#define TYPE_SPHERE 1\n#define TYPE_PRISM 2\n\n#define LASER_LIGHT_SOURCE 1\n#define POINT_LIGHT_SOURCE 2\n#define PARALLEL_LIGHT_SOURCE 3\n\n// Spectrum to xyz approx function from Sloan\n// Inputs:  Wavelength in nanometers\nfloat xFit_1931( float wave ) {\n    float t1 = (wave-442.0)*((wave<442.0)?0.0624:0.0374),\n          t2 = (wave-599.8)*((wave<599.8)?0.0264:0.0323),\n          t3 = (wave-501.1)*((wave<501.1)?0.0490:0.0382);\n    return 0.362*exp(-0.5*t1*t1) + 1.056*exp(-0.5*t2*t2)- 0.065*exp(-0.5*t3*t3);\n}\n\nfloat yFit_1931( float wave ) {\n    float t1 = (wave-568.8)*((wave<568.8)?0.0213:0.0247),\n          t2 = (wave-530.9)*((wave<530.9)?0.0613:0.0322);\n    return 0.821*exp(-0.5*t1*t1) + 0.286*exp(-0.5*t2*t2);\n}\n\nfloat zFit_1931( float wave ) {\n    float t1 = (wave-437.0)*((wave<437.0)?0.0845:0.0278),\n          t2 = (wave-459.0)*((wave<459.0)?0.0385:0.0725);\n    return 1.217*exp(-0.5*t1*t1) + 0.681*exp(-0.5*t2*t2);\n}\n\n#define xyzFit_1931(w) vec3( xFit_1931(w), yFit_1931(w), zFit_1931(w) ) \nvec3 xyzToRgb(vec3 XYZ) {\n\treturn XYZ * mat3( 3.240479, -1.537150, -0.498535,\n\t                  -0.969256 , 1.875991,  0.041556,\n\t                   0.055648, -0.204043,  1.057311 );\n}\n\nfloat remap(const float originalValue, const float originalMin, const float originalMax, const float newMin, const float newMax) {\n\treturn newMin + (((originalValue - originalMin) / (originalMax - originalMin)) * (newMax - newMin));\n}\n\nfloat fresnelSchlick(float n1, float n2, float cosi) {\n    float sint2 = n1 * n1 / (n2 * n2) * (1.0 - cosi * cosi);\n    // Total Internal Reflection\n    if(sint2 >= 1.0) return 1.0;\n    float cost = sqrt(1.0 - sint2);\n    float R0 = (n1 - n2)/(n1 + n2); R0 *= R0;\n    float cosin = (n1 < n2) ? cosi : cost;\n    return R0 + (1.0 - R0) * pow(1.0 - cosin, 5.0);\n}\nfloat fresnel(float n1, float n2, float cosi) {\n    float sint2 = n1 * n1 / (n2 * n2) * (1.0 - cosi * cosi);\n    // Total Internal Reflection\n    if(sint2 >= 1.0) return 1.0;\n    float cost = sqrt(1.0 - sint2);\n    float n1cosi = n1 * cosi;\n    float n1cost = n1 * cost;\n    float n2cosi = n2 * cosi;\n    float n2cost = n2 * cost;\n    float Rs = (n1cosi - n2cost) / (n1cosi + n2cost); Rs *= Rs;\n    float Rp = (n1cost - n2cosi) / (n1cost + n2cosi); Rp *= Rp;\n    return 0.5 * (Rs + Rp);\n}\n\n// https://www.pcg-random.org/\nfloat pcg(inout uint state)\n{\n\tstate = state * 747796405u + 2891336453u;\n\tuint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n\treturn float((word >> 22u) ^ word) / float(0xffffffffu);\n}\n\nfloat random(float from, float to, inout uint state) {\n    return from + pcg(state) * (to - from);\n}\n\nvec3 generateRandomVector(inout uint state) {\n    // from http://lukas-polok.cz/tutorial_sphere.htm\n    float a = random(-1.0, 1.0, state);\n    float b = random(-1.0, 1.0, state);\n    float c = random(-1.0, 1.0, state);\n    vec3 vector = vec3(a, b, c);\n    // from https://www.shadertoy.com/view/3djyWW\n    //return normalize(tan(vector));\n    vector /= cos(vector);\n    return normalize(vector);\n}\n\nvec2 rotateClockwise2D(vec2 rd, float theta) {\n    float cosin = cos(theta);\n    float sine = sin(theta);\n    mat2 rotate = mat2(cosin, sine,\n                       -sine, cosin);\n    return rotate * rd;\n}\n\n// see https://www.geertarien.com/blog/2017/07/30/breakdown-of-the-lookAt-function-in-OpenGL/\nmat3 LookAt(vec3 eye, vec3 at, float angle) {\n    vec3 zaxis = normalize(eye - at);\n    vec3 up = sign(cos(angle)) * vec3(0,1,0);\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nfloat BlackBody( float t, float w_nm ) {\n    float h = 6.6e-34; // Planck constant\n    float k = 1.4e-23; // Boltzmann constant\n    float c = 3e8;// Speed of light\n\n    float w = w_nm / 1e9;\n\n    // Planck's law https://en.wikipedia.org/wiki/Planck%27s_law\n    \n    float w5 = w*w*w*w*w;    \n    float o = 2.*h*(c*c) / (w5 * (exp(h*c/(w*k*t)) - 1.0));\n\n    return o;    \n}\n\nfloat raySphIntersect( in vec3 ro, in vec3 rd, in vec4 sph, out vec3 normal ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n    float x1 = -b - sqrt( h ), x2 = -b + sqrt( h );\n    float t = (x1 > 0.)? x1 : x2;\n    vec3 pos = ro + t * rd;\n    normal = normalize(pos - sph.xyz);\n\treturn t;\n}\n\n// https://iquilezles.org/articles/boxfunctions\nfloat boxIntersect( in vec3 ro, in vec3 rd, in vec3 rad, out vec3 normal ) {\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN < 0.0 ? tF:tN;\n    \n    vec3 p = ro + t * rd;\n    p /= rad;\n    if(abs(p.x) > abs(p.y)) {\n        if(abs(p.x) > abs(p.z)) {\n            normal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n        }\n        else {\n            normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n        }\n    } else if(abs(p.y) > abs(p.z)) {\n        normal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n    } else {\n        normal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n    }\n\n\treturn t;\n}\n\n// from https://iquilezles.org/articles/intersectors/\n// used for render laser line\nfloat iCylinder( in vec3 ro, in vec3 rd, \n                in vec3 pa, in vec3 pb, float ra ) // extreme a, extreme b, radius\n{\n    vec3 ba = pb-pa;\n\n    vec3  oc = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoc = dot(ba,oc);\n    \n    float k2 = baba            - bard*bard;\n    float k1 = baba*dot(oc,rd) - baoc*bard;\n    float k0 = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t = (-k1-h)/k2;\n\n    // body\n    float y = baoc + t*bard;\n    if( y>0.0 && y<baba ) return t;\n    \n    // caps\n    t = ( ((y<0.0) ? 0.0 : baba) - baoc)/bard;\n    if( abs(k1+k2*t)<h )\n    {\n        return t;\n    }\n\n    return -1.0;\n}\n\n// from https://www.shadertoy.com/view/ssBcDD\n// Reorganized to make it easier to understand\nvec4 iPrismOutside( vec3 ro, vec3 rd, float ra, float he, int si )\n{\n    vec4 tN = vec4(-MAX_DIST, 0, 0, 0);\n    float tF = MAX_DIST;\n    \n    float s = PI * 2. / float(si);\n    float a = PI / 2.;\n    \n    ra = ra * cos(s*0.5);\n    \n    for (int i = 0; i < si + 2; i++)\n    {\n        vec3 nd = i < si ? vec3(cos(a), 0, sin(a)) : vec3(0, float(i - si)*2.-1., 0);\n        float c = (i < si ? ra : he) - dot(ro, nd);\n        float d = dot(rd, nd);\n        // distance to each plane\n        float t = c / d;\n\n        // update tNear to the last position see from outside\n        if (t > 0. && d < 0. && t > tN.x) {\n            tN = vec4(t, nd);\n        }\n\n        // update tfar to first position see from inside\n        // if t > 0, choose the smallest t\n        if(t > 0. && d > 0. && t < tF) {\n            tF = t;\n        }\n        // if t < 0, mean not intersect, set to -MAX_DIST\n        if(t < 0. && d > 0.) {\n            tF = -MAX_DIST;\n        }\n        \n        a += s;\n    }\n    \n    if (tN.x > tF) return vec4(MAX_DIST);\n\n    return tN;\n}\n\n// when a ray emit from the prism, return intersect info\nvec4 iPrismInside( vec3 ro, vec3 rd, float ra, float he, int si )\n{\n    float tmin = -1.0;\n    vec3 normal;\n    \n    float s = PI * 2. / float(si);\n    float a = PI / 2.;\n    \n    ra = ra * cos(s*0.5);\n    \n    for (int i = 0; i < si + 2; i++)\n    {\n        vec3 nd = i < si ? vec3(cos(a), 0, sin(a)) : vec3(0, float(i - si)*2.-1., 0);\n        float c = (i < si ? ra : he) - dot(ro, nd);\n        float d = dot(rd, nd);\n        \n        // distance to each plane\n        float t = c / d;\n        // when point is already inside the prism, direction is always from inside\n        // so just need to find the smallest t\n        if(t > 0. && (t < tmin || tmin < 0.)) {\n            tmin = t;\n            normal = nd;\n        }\n        \n        a += s;\n    }\n\n    return vec4(tmin, normal);\n}\n\nfloat getPointLineDis(vec3 p, vec3 from, vec3 to) {\n    vec3 ab = to - from;\n    vec3 ap = p - from;\n    return length(cross(ab, ap)) / length(ab);\n}\n\nfloat getLineDis(vec3 ro, vec3 rd, vec3 from, vec3 to) {\n    vec3 ab = to - from;\n    vec3 ap = ro - from;\n    vec3 n = normalize(cross(ab, rd));\n    return abs(dot(n, ap));\n}","name":"Common","description":"","type":"common"}]}