{"ver":"0.1","info":{"id":"7dyGDh","date":"1631526440","viewed":294,"name":"Rounded Polyline ","username":"kastorp","description":"Polyline with constant curvature on nodes\nuse mouse to change radius and thickness","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["2d","arc","polyline"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Rounded Polyline by Kastorp\n//----------------------------------\n// I'm having much fun with 2d geometry, arcs, intersections\n// in a simple simulation of gears and belts \n//\n// TODO:\n//  - optimize performances\n//  - configurable radius and rounding algorithm for each node\n//  - 3d version using extrusion\n//------------------------------------\n#define R iResolution\n#define plotBelt(c1,c2, func) { vec3 fn =func;  dist=min(dist,fn.x); ldist+= (fn.x<=0.? fn.y*fn.z : fn.z); if(tdist==0. && fn.x<0.) tdist =ldist; \\\n    col = mix(mix(c1,c2,fn.y),col,smoothstep(0.,.004,fn.x));  }\n#define plotGear(sw, c1,c2,pos, func) {float fn = func; dist=min(dist,fn); \\\n    col = mix((sw?c1:c2)* (sw? angle(pos,vec2(sin(-iTime/r),cos(-iTime/r))): angle(pos,vec2(sin(iTime/r),cos(iTime/r))))/2./PI ,col,smoothstep(0.,.004,fn)); }\n\n#define PI 3.1415\nconst int N= 8; //number of nodes \n//#define RANDOM //randomize nodes\n\n//------------------------------------\n\n// line/line intersection (Iapafoto)\nvec2 intersect(vec2 p0, vec2 n0, vec2 p1, vec2 n1) {\n    float d = n0.x*n1.y-n0.y*n1.x; \n    if(d==0.) return vec2(0);\n    vec2 p = (p0-p1)/d;\n    return vec2(p.y*n1.x-p.x*n1.y, p.y*n0.x-p.x*n0.y); \n}\n\n// line/circle intersection\nvec2 intersect(vec2 p0, vec2 n, vec2 center, float r) {\n    vec2 c=p0-center;\n    float b= dot(n,c),\n          d = sqrt(b*b +r*r - dot(c,c));\n     return vec2( -b+d,-b-d);    \n}\n//angle between normals\nfloat angle(in vec2  p,in  vec2 n){\n    vec2 c= p *mat2(n.x,n.y,-n.y,n.x);\n    float a= atan(c.y,c.x);\n    if(a<0.)  a= 2.*PI +a;  \n    return a;\n}\n\n//based on Iq SDF function\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, in float rb )\n{   \n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    if (scb.y*p.x>scb.x*p.y) {\n        vec2  b = scb*(ra+rb), a=scb*(ra-rb),pa=p-a, ba = b-a;\n        float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        return length( pa - ba*h );\n    }\n    return abs( length(p)-ra) -rb;\n}\n\n// arc with normals as parameters\n//type=0: ordered arc, =1: always shorter, -1= always longer\nvec3 sdArcExt( in vec2 p, in vec2 na, in vec2 nb, in float ra,in float rb,bool swap,bool longer)\n{  \n    if(swap) {vec2 temp=na;na=nb;nb=temp;}\n    float an =  angle(p ,na),at=angle(nb,na) ;      \n    vec2 ta =  normalize(na+nb) *mat2(0,1,-1,0) *sign(na.x*nb.y - na.y*nb.x),  \n         tb =  na *mat2(ta.x,ta.y,-ta.y,ta.x); \n    if(tb.x<0.) tb.x=-tb.x;\n    return vec3(sdArc(p,ta,tb,ra,rb),(swap? 1.-  an /at : an / at), at*ra );\n}\n\nvec3 sdSegmentExt( in vec2 p, in vec2 a, in vec2 b , in float tk)\n{\n    vec2 n=normalize(b-a), l= vec2(length(b-a)*.5,tk);\n    p=(p-a)*mat2(n.x,n.y,-n.y,n.x) -vec2(l.x,0);\n    vec2 d = abs(p)-l;\n    return vec3(length(max(d,0.0)) + min(max(d.x,d.y),0.0),p.x/l.x/2.+.5,l.x*2.);\n}\n\n//segment-arc-segment\nvec4 roundCorner( vec2 a, vec2 b, vec2 c, float r)\n{   \n    //segment ab\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    //parallel ab on c side\n    vec2 a1 = a + pab;\n    \n    //segment bc\n    vec2 nbc= normalize(c-b),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-c,tbc));\n    //parallel bc on a side\n    vec2 b1 = b + pbc;  \n    \n    //intersection\n    vec2 d = a1 + intersect(a1,nab,b1,nbc).x*nab;  //center of inscribed circle\n           \n    //arc-segment intersection\n    vec2 e = d  - pab;  //intersection arc, segment ab\n    vec2 f = d  - pbc;  //intersection arc, segment cb\n    \n    float de= distance(e,b),df=distance(f,b);\n    return vec4(de,df,d);             \n}\n\n//segment-arc-arc-segment\nvec4 roundCorner2( vec2 a, vec2 b, vec2 c, float r){\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    vec2 d = b + pab;\n    vec2 nbc= normalize(b-c),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-c,tbc));\n    vec2 b1 = b -  pbc,\n         e = b1  + nbc*  intersect(b1,nbc,d,2.*r).y;      \n    return vec4( d ,  e);\n}   \n\n//segment-arc-arc-arc-segment\nvec4 roundCorner3( vec2 a, vec2 b, vec2 c, float r){\n    vec2 nab= normalize(b-a),\n         tab=vec2(nab.y,-nab.x),\n         pab=r* tab *sign(dot(c-a,tab));\n    vec2 a1 = b - pab,\n         e = a1  + nab*  intersect(a1,nab,b,2.*r).y; \n    vec2 nbc= normalize(b-c),\n         tbc= vec2(nbc.y,-nbc.x),\n         pbc= r* tbc *sign(dot(a-b,tbc));\n    vec2 c1 = b -  pbc,\n         f = c1  + nbc*  intersect(c1,nbc,b,2.*r).y;     \n    return vec4( e ,  f);\n}  \n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec2 getK(int i){\n        float s= float(i*i)/float(N*N) +.05;\n#ifdef RANDOM        \n        vec2 k =hash21(float(i))*.8-.4;\n#else        \n        const vec2[8] KK = vec2[8](vec2(.4,.4), vec2(0,0), vec2(-.3,.4), vec2(-.4,0),vec2(-.2,-.4), vec2(0,-.4), vec2(0.2,0.1), vec2(.3,-.3)) ;  \n        vec2 k= KK[i];\n#endif        \n        k.x*=R.x/R.y;\n        k +=vec2(sin(iTime*(s-.3) +s  +5.),cos(iTime*(s-.3)+s +5.))*.07 ;\n        return k;\n}\n//----------------------------------------------------------------\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-R.xy*.5 + U)/R.y *1.;\n    vec3 col = vec3(0.25);  \n        \n    float r =iMouse.z>0.? iMouse.y/R.y *.07 +.04 : .08,\n          tk=iMouse.z>0.? iMouse.x/R.x *.02 : .01;\n\n    float dist=1e5,tdist=0.,ldist=0.; //SDF distance, cumulated path distance, local path distance\n    \n    for(int i=min(iFrame,0);i<N;i++)\n    {\n        //b = node, a and c = polyline mid points\n        vec2 b=getK((i+1)%N), a=(getK(i)+b)/2., c=(getK((i+2)%N)+b)/2.;\n       \n        //control point:\n         col = mix(vec3(0),col,smoothstep(0.,.002,-tk+ length(p-b)));\n                 \n        // try to use 1 arc\n        vec4 v = roundCorner(a,b,c, r);      \n        if((i%2==1)&&  v.x<distance(a,b) && v.y < distance(c,b)) {\n            //ok is compatible, draw it                        \n            vec2 nab=normalize(b-a),\n                 ncb=normalize(c-b),\n                 e= b - v.x*nab,\n                 f= b + v.y*ncb,\n                 d=v.zw;\n                 \n            bool swap =nab.x*ncb.y>nab.y*ncb.x ;\n            plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-d, tk-r  + length(p-d));\n            plotBelt(vec3(.8),vec3(8.,0,.8), sdSegmentExt(p,a,e,tk));                      \n            plotBelt(vec3(1,0,1),vec3(1,0,0),  sdArcExt(p-d,normalize(e-d),normalize(f-d),r,tk,!swap,false));           \n            plotBelt(vec3(.8,0,0),vec3(.8), sdSegmentExt(p,f,c,tk));            \n        } else {\n            // try to use 2 arcs \n            //vec2 b=kj, a=(ki+b)/2., c=(km+b)/2.;            \n            //if(  distance(c,b)<distance(a,b)) {a=(ki+b)/2.; c=(km+b)/2.;}\n            \n            vec4 v2 = roundCorner2(  a,b,c,  r);\n            vec2 nab=normalize(b-a),\n                 nbc=normalize(b-c),\n                 a1=v2.xy,\n                 c1=v2.zw,\n                 f=(a1+c1)/2.,\n                 a2=b,\n                 c2=b+ intersect(b,nbc,c1,vec2(nbc.y,-nbc.x)).x*nbc;\n                 \n            if( distance(b,c)>distance(b,c2) ){\n                bool swap = nab.x*nbc.y>nab.y*nbc.x;\n                plotGear(!swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-a1, tk-r  + length(p-a1));\n                plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-c1, tk-r  + length(p-c1));                \n                plotBelt(vec3(.8),vec3(.8,0,.8),  sdSegmentExt(p,a,a2,tk));                                         \n                plotBelt(vec3(1,0,0),vec3(1,0,1), sdArcExt(p-a1,normalize(a2-a1),normalize(f-a1),r,tk,swap,true));\n                plotBelt(vec3(1,0,1), vec3(1,1,0), sdArcExt(p-c1,normalize(f-c1),normalize(c2-c1),r,tk,!swap,false));\n                plotBelt(vec3(.8,.8,0), vec3(.8), sdSegmentExt(p,c2,c,tk));\n       \n            }else{\n                // try to use 3 arcs\n                //vec2 b=kj, a=(ki+b)/2., c=(km+b)/2.;\n                vec4 v2 = roundCorner3(  a,b,c,r);\n                vec2 nab=normalize(b-a),\n                     nbc=normalize(b-c),\n                     e = v2.xy,\n                     f = v2.zw,                \n                     a1=(e+b)/2.,\n                     c1=(f+b)/2.,\n                     a2= b+ intersect(b,nab,e,vec2(nab.y,-nab.x)).x*nab,\n                     c2= b+ intersect(b,nbc,f,vec2(nbc.y,-nbc.x)).x*nbc;       \n\n                  if(distance(a,b)>distance(b,a2) && distance(b,c)>distance(b,c2)){\n                    //ok is compatible, draw it \n                    bool swap = nab.x*nbc.y>nab.y*nbc.x;\n\n                    plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-e, tk-r  + length(p-e));\n                    plotGear(swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-f, tk-r  + length(p-f));\n                    plotGear(!swap, vec3(.2,.3,.7), vec3(.2,.5,.3), p-b, tk-r  + length(p-b));\n                    plotBelt(vec3(.8),vec3(.8,.8,.0), sdSegmentExt(p,a,a2,tk));                               \n                    plotBelt(vec3(1,1,0),vec3(1,0,1), sdArcExt(p-e,normalize(a2-e),normalize(a1-e),r,tk,!swap,false));\n                    plotBelt(vec3(1,0,1),vec3(1,0,0), sdArcExt(p-b,normalize(a1-b),normalize(c1-b),r,tk,swap,false));                               \n                    plotBelt(vec3(1,0,0),vec3(1,1,0), sdArcExt(p-f,normalize(c1-f),normalize(c2-f),r,tk,!swap,false));\n                    plotBelt(vec3(.8,.8,0.),vec3(.8), sdSegmentExt(p,c2,c,tk));                \n                  }else{\n                    //segments too short - skip rounding\n                    plotBelt(vec3(.8),vec3(8.,0,0), sdSegmentExt(p,a,b,tk));\n                    plotBelt(vec3(.8,0,0),vec3(.8), sdSegmentExt(p,b,c,tk));\n                  }\n              }\n        }\n    }\n       \n     if(tdist>0.) col+=  smoothstep(0.1,.15, mod(iTime-tdist, .3));\n     if(tdist==0.) col +=vec3(dist*1.);\n     \n     if(iMouse.z>0.){\n         col = vec3(0.9,0.6,0.3); if(dist<0.) col= vec3(1,1,tdist*10.);\n        col *= 1.0 - exp(-3.0*abs(dist));\n        col *= 0.8 + 0.2*cos(250.0*dist);\n        col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(dist)) );\n     }  \n    // Output to screen\n    O = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}