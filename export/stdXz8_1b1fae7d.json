{"ver":"0.1","info":{"id":"stdXz8","date":"1638735521","viewed":98,"name":"Sphere Fractal","username":"do","description":"fractal","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//sphere fractal\n//2021\n//do\n\nmat2 rot2(float a) {\n\n    float c = cos(a);\n    float s = sin(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nmat3 camOrthographic(vec3 ro,vec3 ta,float r) {\n     \n     vec3 w = normalize(ta - ro); \n     vec3 p = vec3(sin(r),cos(r),0.);           \n     vec3 u = normalize(cross(w,p)); \n     vec3 v = normalize(cross(u,w));\n\n     return mat3(u,v,w); \n} \n\nfloat smou(float d1,float d2,float k) {\n\n    float h = clamp(0.5 + 0.5 * (d2-d1)/k,0.0,1.0);\n    return mix(d2,d1,h) - k * h * (1.0 - h);\n}\n\nfloat sphere(vec3 p,float r) { \n    return length(p)-r;\n}\n\nfloat scene(vec3 p) {\n\n    float d = 0.;     \n    float r = 8.;  \n    \n    d = sphere(p,r);\n\n    for(int i = 0; i < 3; i++) {\n\n        p.xz *= rot2(radians(180.)/2. * iTime * 0.01);\n        p.zy *= rot2(radians(180.));\n        p.xy *= rot2(radians(180.)*2. - 1.);\n\n        p = abs(p) - r * 0.5;\n        r /= 3.;\n  \n        d = smou(d,sphere(p,r),0.1);\n\n    }\n\n    return d;\n\n}\n\nfloat calcAO(vec3 p,vec3 n) {\n\n    float o = 0.;\n    float s = 1.;\n\n    for(int i = 0; i < 15; i++) {\n \n        float h = .01 + .125 * float(i) / 4.; \n        float d = scene(p + h * n);  \n        o += (h-d) * s;\n        s *= .9;\n        if(o > .33) break;\n    \n     }\n     return clamp(1. - 3. * o ,0.0,1.0) * (.5+.5*n.y);   \n}\n\nvec3 calcNormal(vec3 p) {\n\n    vec2 e = vec2(1.0,-1.0) * 0.0001;\n\n    return normalize(vec3(\n    vec3(e.x,e.y,e.y) * scene(p + vec3(e.x,e.y,e.y)) +\n    vec3(e.y,e.x,e.y) * scene(p + vec3(e.y,e.x,e.y)) +\n    vec3(e.y,e.y,e.x) * scene(p + vec3(e.y,e.y,e.x)) + \n    vec3(e.x,e.x,e.x) * scene(p + vec3(e.x,e.x,e.x))\n\n    ));\n    \n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord) {\n\nvec3 color = vec3(0.);\nvec3 ro = vec3(10.,5.,25.);\nvec3 ta = vec3(0.0);\n\nvec3 n;\nvec3 l = normalize(vec3(10.));\nvec3 linear = vec3(0.); \n\nvec2 uv = (2. * (fragCoord.xy) -\niResolution.xy) / iResolution.y; \n\nmat3 cm = camOrthographic(ro,ta,0.);\n\nvec3 rd = cm * normalize(vec3(uv.xy,2.));\n\nfloat dist = 0.;\n\n    for(int i = 0; i < 250; i++) {\n\n         vec3 p = ro + rd * dist;\n         float d = scene(p);\n\n         if(d < 0.001) {\n\n             n = calcNormal(p);\n \n             float amb = clamp(0.5+0.5*n.y,0.,1.);\n\n             float dif = clamp(dot(\n             n,l),0.,1.);\n\n             linear += dif * vec3(float(i)/100.,0.,0.); \n             linear += amb * vec3(0.5);\n             float ao = calcAO(p*1.1,n);\n             color += linear*ao;\n\n             break;\n           \n         }\n         dist += d;\n         color = vec3(1.,\n         smoothstep(-1.,1.,rd.x),smoothstep(-1.,1.,rd.y));\n    }\n\nfragColor = vec4(pow(color,vec3(0.4545)),1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}