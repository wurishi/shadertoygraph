{"ver":"0.1","info":{"id":"4ssBWl","date":"1498838234","viewed":176,"name":"Mandelbulb AO DOF","username":"yumcyawiz","description":"Render mandelbulb with ambient occlusion and depth of field.","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uvt = fragCoord.xy/iResolution.xy;\n    vec3 col = texture(iChannel0, uvt).xyz;\n    fragColor = vec4(4.0*col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nvec3 pointOnDisk(float r, float theta, vec3 n) {\n    vec3 p = vec3(r*cos(theta), r*sin(theta), 0.0);\n    \n    vec3 rotAxis = cross(normalize(p), normalize(n));\n    float rotAng = acos(dot(p, n)/(length(p)*length(n)));\n    mat3 R = mat3(0.0, rotAxis.z, -rotAxis.y, -rotAxis.z, 0.0, rotAxis.x, rotAxis.y, -rotAxis.x, 0.0);\n    mat3 I = mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);\n    mat3 M = I - sin(theta)*R + (1.0 - cos(theta))*R*R;\n    return M*p;\n}\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\n\nconst int maxIter = 100;\nfloat df(vec3 p) {\n    vec3 z = p;\n    float r = 0.0;\n    float dr = 1.0;\n    float power = 8.0;\n    for(int i = 0; i < maxIter; i++) {\n        r = length(z);\n        if(r > 2.0) break;\n        \n        float theta = acos(z.z/r);\n        float phi = atan(z.y, z.x);\n        \n        dr = power*pow(r, power-1.0)*dr + 1.0;\n        \n        r = pow(r, power);\n        theta *= power;\n        phi *= power;\n        \n        z = r*vec3(sin(theta)*cos(phi), sin(theta)*sin(phi), cos(theta));\n        z += p;\n    }\n    float d = 0.5*log(r)*r/dr;\n    \n    //box\n    d = min(d, sdBox(p - vec3(0, -1, 0), vec3(10, 0.01, 10)));\n    \n    //sphere1\n    d = min(d, sdSphere(p - vec3(-2, 0, 5), 1.0));\n    \n    //sphere2\n    d = min(d, sdSphere(p - vec3(-1, 0.2, -5), 1.2));\n    \n    return d;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    float eps = 0.00001;\n    return normalize(vec3(\n        df(p + vec3(eps, 0, 0)) - df(p - vec3(eps, 0, 0)),\n        df(p + vec3(0, eps, 0)) - df(p - vec3(0, eps, 0)),\n        df(p + vec3(0, 0, eps)) - df(p - vec3(0, 0, eps))\n        ));\n}\n\n\nstruct Ray {\n    bool hit;\n    vec3 hitPos;\n    vec3 hitNormal;\n    vec3 rayDir;\n    float t;\n    int steps;\n};\nconst int maxSteps = 200;\nRay trace(vec3 camPos, vec3 rayDir) {\n    vec3 p = vec3(0);\n    vec3 normal = vec3(0);\n    float t = 0.0;\n    int steps = 0;\n    bool hit = false;\n    for(int i = 0; i < maxSteps; i++) {\n        p = camPos + t*rayDir;\n        float d = df(p);\n        if(d < 0.001) {\n            p -= 0.001*rayDir;\n            hit = true;\n            normal = calcNormal(p);\n            steps = i;\n            break;\n        }\n        t += d*0.9;\n    }\n    return Ray(hit, p, normal, rayDir, t, steps);\n}\n\n\n//is point p visible from the light?\nbool isVisible(vec3 p, vec3 lightPos) {\n    Ray tr = trace(lightPos, normalize(p - lightPos));\n    if(distance(tr.hitPos, p) < 0.1) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nbool isVisible2(vec3 p, vec3 lightDir) {\n    Ray tr = trace(p, lightDir);\n    if(tr.hit) {\n        return false;\n    }\n    else {\n        return true;\n    }\n}\n\n\n//shading\nvec3 shading(vec3 from, vec3 rayDir) {\n    Ray tr = trace(from, rayDir);\n    \n    if(!tr.hit) {\n        return vec3(0);\n    }\n    \n    vec3 col = vec3(0);\n    //AO\n    for(int j = 0; j < 20; j++) {       \n        vec3 randDir = vec3(\n            2.0*rand(tr.hitPos.xy + vec2(j)) - 1.0,\n            2.0*rand(tr.hitPos.yz + vec2(j)) - 1.0,\n            2.0*rand(tr.hitPos.zx + vec2(j)) - 1.0\n            );\n        if(isVisible2(tr.hitPos, randDir)) {\n            col += vec3(1) * max(dot(tr.hitNormal, randDir), 0.0)/float(20);\n        }\n    }\n    \n    return col;\n}\n\n\nint maxSample = 100;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec2 uvt = fragCoord.xy/iResolution.xy;\n    \n    float t = 0.0;\n    vec3 camPos = 2.0*vec3(cos(t), 0, sin(t));\n    vec3 camFront = normalize(-camPos);\n    vec3 camUp = vec3(0, 1, 0);\n    vec3 camRight = cross(camFront, camUp);\n    float fov = 1.0;\n    vec3 rayDir = normalize(uv.x*camRight + uv.y*camUp + fov*camFront);\n    \n    //DOF\n    float focus = 2.0;\n    float r = 0.05*rand(vec2(iFrame));\n    float theta = 2.0*3.14*rand(vec2(iFrame*2));\n    vec3 randPoint = camPos + pointOnDisk(r, theta, camFront);\n    vec3 focusPoint = camPos + rayDir*focus;\n    rayDir = normalize(focusPoint - randPoint);\n    \n    if(iFrame < maxSample) {\n        fragColor = vec4(shading(camPos, rayDir)/float(maxSample), 1.0) + texture(iChannel0, uvt);\n    }\n    else {\n        fragColor = texture(iChannel0, uvt);\n    }\n}\n","name":"Buf A","description":"","type":"buffer"}]}