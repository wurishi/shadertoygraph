{"ver":"0.1","info":{"id":"XftyRl","date":"1731023842","viewed":78,"name":"Cumuliform","username":"FiveLimbedCat","description":"Tileable Perlin-Worley 3D noise implementation for modeling volumetric clouds like the ones from Horizon Zero Dawn.  Drag the mouse along y-axis to see different slices.","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["voronoi","noise","clouds","fbm","perlin","gradient","worley"],"hasliked":0,"parentid":"3dVXDc","parentname":"Tileable Perlin-Worley 3D"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\nAn implementation of tileable 3D Perlin-Worley noise for modeling volumetric clouds\ninspired from the chapter Real-Time Volumetric Cloudscapes by Andrew Schneider\n(Guerrilla Games). The first column is the perlin-worley noise generated by remapping\nperlin noise with the lowest frequency worley fbm. The next 3 columns are worley fbms\nwith increasing frequencies, and are used to model the cloud shapes which are rendered\nin the last column. See the common tab for all the noise functions used.\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    float perlinWorley = textureLod(iChannel0, uv * .5 - iTime * 0.018, 0.).x;\n    perlinWorley = mix(-.5, .5, perlinWorley);\n    \n    float wfbm = (textureLod(iChannel0, uv + iTime * 0.00, 0.).y + perlinWorley) * \n        \t\t textureLod(iChannel0, uv + iTime * 0.01, 0.).z * \n                 textureLod(iChannel0, uv + iTime * 0.02, 0.).w;\n                 \n    float cloud = remap(wfbm, .4, 1.0, 0., 1.); // fake cloud coverage\n    \n    col += cloud;\n        \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/**\nThis buffer writes the tileable 3D noise to a texture. \n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec4 col = vec4(0.);\n    \n    float slices = 128.; // number of layers of the 3d texture\n    float freq = 4.;\n    \n    float pfbm= mix(1., perlinfbm(vec3(uv, floor(m.y*slices)/slices), 4., 7), .5);\n    pfbm = abs(pfbm * 2. - 1.); // billowy perlin noise\n    \n    col.g += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq);\n    col.b += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq*2.);\n    col.a += worleyFbm(vec3(uv, floor(m.y*slices)/slices), freq*4.);\n    col.r += remap(pfbm, 0., 1., col.g, 1.); // perlin-worley\n    \n    fragColor = vec4(col);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/**\nThis tab contains all the necessary noise functions required to model a cloud shape.\n*/\n\n// Hash by David_Hoskins\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * vec3(q) * UIF;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\n// Gradient noise by iq (modified to be tileable)\nfloat gradientNoise(vec3 x, float freq)\n{\n    // grid\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n    \n    // quintic interpolant\n    vec3 u = w * w * w * (w * (w * 6. - 15.) + 10.);\n\n    \n    // gradients\n    vec3 ga = hash33(mod(p + vec3(0., 0., 0.), freq));\n    vec3 gb = hash33(mod(p + vec3(1., 0., 0.), freq));\n    vec3 gc = hash33(mod(p + vec3(0., 1., 0.), freq));\n    vec3 gd = hash33(mod(p + vec3(1., 1., 0.), freq));\n    vec3 ge = hash33(mod(p + vec3(0., 0., 1.), freq));\n    vec3 gf = hash33(mod(p + vec3(1., 0., 1.), freq));\n    vec3 gg = hash33(mod(p + vec3(0., 1., 1.), freq));\n    vec3 gh = hash33(mod(p + vec3(1., 1., 1.), freq));\n    \n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\t\n    // interpolation\n    return va + \n           u.x * (vb - va) + \n           u.y * (vc - va) + \n           u.z * (ve - va) + \n           u.x * u.y * (va - vb - vc + vd) + \n           u.y * u.z * (va - vc - ve + vg) + \n           u.z * u.x * (va - vb - ve + vf) + \n           u.x * u.y * u.z * (-va + vb + vc - vd + ve - vf - vg + vh);\n}\n\n// Tileable 3D worley noise\nfloat worleyNoise(vec3 uv, float freq)\n{    \n    vec3 id = floor(uv);\n    vec3 p = fract(uv);\n    \n    float minDist = 10000.;\n    for (float x = -1.; x <= 1.; ++x)\n    {\n        for(float y = -1.; y <= 1.; ++y)\n        {\n            for(float z = -1.; z <= 1.; ++z)\n            {\n                vec3 offset = vec3(x, y, z);\n            \tvec3 h = hash33(mod(id + offset, vec3(freq))) * .5 + .5;\n    \t\t\th += offset;\n            \tvec3 d = p - h;\n           \t\tminDist = min(minDist, dot(d, d));\n            }\n        }\n    }\n    \n    // inverted worley noise\n    return 1. - minDist;\n}\n\n// Fbm for Perlin noise based on iq's blog\nfloat perlinfbm(vec3 p, float freq, int octaves)\n{\n    float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < octaves; ++i)\n    {\n        noise += amp * gradientNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    \n    return noise;\n}\n\n// Tileable Worley fbm inspired by Andrew Schneider's Real-Time Volumetric Cloudscapes\n// chapter in GPU Pro 7.\nfloat worleyFbm(vec3 p, float freq)\n{\n    return worleyNoise(p*freq, freq) * .625 +\n        \t worleyNoise(p*freq*2., freq*2.) * .25 +\n        \t worleyNoise(p*freq*4., freq*4.) * .125;\n}\n\n","name":"Common","description":"","type":"common"}]}