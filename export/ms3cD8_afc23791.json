{"ver":"0.1","info":{"id":"ms3cD8","date":"1694993439","viewed":65,"name":"TestStickmanSdf","username":"Accelerator","description":"sdf stickman test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3  eye      = vec3 ( 0, 0, 5 );\nconst vec3  light    = vec3  ( 0.0, 3.0, 5.0 );\nconst int   maxSteps = 70;\nconst float eps      = 0.01;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nfloat sdSphere ( vec3 p, in vec3 c )\n{\n\treturn length ( p - c ) - 1.0;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat smoothUnion ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat sdf ( in vec3 p, in mat3 m )\n{\n   vec3 q = m * p;\n  \n   float move =  sin(iTime*10.0f)/2.0f;\n   \n   float ball = sdSphere (q, vec3(0.0,-1.8,0.0));\n   \n   float firstLeg = sdCapsule (q,vec3(0.0,0.0,0.0),vec3(-0.3,-0.75,move),0.1);\n   float secondLeg = sdCapsule (q,vec3(0.0,0.0,0.0),vec3(0.3,-0.75,-move),0.1);\n   \n   float body = sdCapsule (q,vec3(0.0,0.0,0.0),vec3(0.0,0.8,0.0),0.1);\n   \n   float firstArm = sdCapsule (q,vec3(0.0,0.8,0.0),vec3(-0.5, 0.45,-move),0.1);\n   float secondArm = sdCapsule (q,vec3(0.0,0.8,0.0),vec3(0.5, 0.45,move),0.1);\n   \n   float head = sdCapsule (q,vec3(0.0,0.8,0.0),vec3(0.0, 1.1, 0.0),0.12);\n   \n   float stickman = smoothUnion (ball, firstLeg, 0.03f);\n   stickman = smoothUnion (stickman, secondLeg, 0.03f);\n   stickman = smoothUnion (stickman, body, 0.07f);\n   stickman = smoothUnion (stickman, firstArm, 0.07f);\n   stickman = smoothUnion (stickman, secondArm, 0.07f);\n   stickman = smoothUnion (stickman, head, 0.07f);\n   \n   return stickman;\n}\n\n\nvec3 trace ( in vec3 from, in vec3 dir, out bool hit, in mat3 m )\n{\n\tvec3\tp         = from;\n\tfloat\ttotalDist = 0.0;\n\t\n\thit = false;\n\t\n\tfor ( int steps = 0; steps < maxSteps; steps++ )\n\t{\n\t\tfloat\tdist = sdf ( p, m );\n        \n\t\tif ( dist < 0.01 )\n\t\t{\n\t\t\thit = true;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\ttotalDist += dist;\n\t\t\n\t\tif ( totalDist > 10.0 )\n\t\t\tbreak;\n\t\t\t\n\t\tp += dist * dir;\n\t}\n\t\n\treturn p;\n}\n\nvec3 generateNormal ( vec3 z, float d, in mat3 m )\n{\n    float e   = max (d * 0.5, eps );\n    float dx1 = sdf(z + vec3(e, 0, 0), m);\n    float dx2 = sdf(z - vec3(e, 0, 0), m);\n    float dy1 = sdf(z + vec3(0, e, 0), m);\n    float dy2 = sdf(z - vec3(0, e, 0), m);\n    float dz1 = sdf(z + vec3(0, 0, e), m);\n    float dz2 = sdf(z - vec3(0, 0, e), m);\n    \n    return normalize ( vec3 ( dx1 - dx2, dy1 - dy2, dz1 - dz2 ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool hit;\n\tvec3 mouse = vec3(iMouse.xy/iResolution.xy - 0.5,iMouse.z-.5);\n    mat3 m     =  rotateY ( 6.0*mouse.x);\n    vec2 scale = 9.0 * iResolution.xy / max ( iResolution.x, iResolution.y ) ;\n    vec2 uv    = scale * ( fragCoord/iResolution.xy - vec2 ( 0.5 ) );\n\tvec3 dir   = normalize ( vec3 ( uv, 0 ) - eye );\n    vec4 color = vec4 ( 0.1, 0.1, 0.1, 1 );\n    vec3 p     = trace ( eye, dir, hit, m );\n\n\n\tif ( hit )\n\t{\n\t\tvec3  l  = normalize        ( light - p );\n        vec3  v  = normalize        ( eye - p );\n\t\tvec3  n  = generateNormal   ( p, 0.001, m );\n\t\tfloat nl = max ( 0.0, dot ( n, l ) );\n        vec3  h  = normalize ( l + v );\n        float hn = max ( 0.0, dot ( h, n ) );\n        float sp = pow ( hn, 150.0 );\n\t\t\n        float r = sin(iTime);\n        float g = cos(iTime);\n\t\tcolor = 0.5*vec4 ( nl ) + 0.5 * sp * vec4 ( r, g, 1, 1 );\n\t} \n\n    fragColor = color;\n}\n","name":"Image","description":"","type":"image"}]}