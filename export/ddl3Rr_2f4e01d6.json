{"ver":"0.1","info":{"id":"ddl3Rr","date":"1665593866","viewed":151,"name":"Artober - Forget","username":"Flopine","description":"Day 12 of artober, experimenting with the command discard... Thanks to realtenfour who got the idea :P \nWARNING : The result is expected to be different based on your GPU!!","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","modeling","animation","everyday","discrad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGRn","filepath":"/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","previewfilepath":"/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan, slerpy, wwrighter \n// BigWings, FabriceNeyret and Blackle for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  \n// https://twitter.com/CookieDemoparty\n\n\n// WARNING\n// This shader experiment around the discard command of GLSL\n// The result is expected to be different based on your GPU!!\n// Show me what you've got :D \n\n#define PI acos(-1.)\n#define TAU (2.*PI)\n#define rot(a) mat2(cos(a),sin(a), -sin(a),cos(a))\n\n#define circle(u,s) (length(u)-s)\n// found in Shane's shader : https://www.shadertoy.com/view/wdBSRm\n#define oct(u,s) (max((abs(u.y) + abs(u.x))/sqrt(2.), max(abs(u.x), abs(u.y)))-s)\n#define AAstep(thre, val) smoothstep(-.7,.7,(val-thre)/min(0.02,fwidth(val-thre)))\n#define xor(a,b) ((1.-b)*a + (1.-a)*b)\n#define sm(t,v) smoothstep(t, t*1.8, v)\n\n#define noise(u) textureLod(iChannel0, u, 0.).xyz\n#define hash21(x) fract(sin(dot(x,vec2(642.1,594.2)))*1684.7)\n\n#define dt(sp) fract(iTime*sp)\n#define swit(sp) floor(sin(dt(sp)*TAU)+1.)\n \nstruct obj \n{\n    float d;\n    int mat;\n    vec3 c;\n};\n\nobj minobj (obj a, obj b)\n{\n    if(a.d < b.d) return a;\n    else return b;\n}\n\nvoid moda (inout vec2 p, float rep)\n{\n    float per = TAU/rep;\n    float a = mod(atan(p.x,p.y), per)-per*.5;\n    p = vec2(cos(a),sin(a))*length(p);\n}\n\nfloat motif (vec2 uv)\n{\n    vec2 uu = uv;\n    uv.y = abs(uv.y)-.9;\n    float m = sm(0.01, circle(uv,0.25));\n    \n    moda(uv,5.);\n    uv.x -= 0.15;\n    float o = sm(0.01, abs(oct(uv, 0.1)));    \n    m = xor(o,m);\n    \n    uv = uu;\n    uv.x += cos(uv.y*6.)*.15;\n    float v = sm(0.02, abs(uv.x));\n    \n    uv = uu;\n    uv.x -= sin((uv.y+.5)*4.)*.1;\n    v *= sm(0.02, abs(uv.x));\n    \n    uv = uu;\n    v *= sm(0.02, abs(uv.x)+abs(uv.y*.05));\n    v = max(v,sm(0.01, abs(uv.y)-0.65));\n    m += (1.-v);\n    \n    return m;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0., max(q.x,max(q.y, q.z)))+length(max(q,0.));\n}\n\nfloat g1 = 0.;\nobj blade (vec3 p)\n{\n    vec3 pp = p;\n    \n    p.xz *= rot(PI/4.);\n    float sxz = (p.y>1.) ? 0.4-(p.y*.4-.4) : .4; \n    sxz = (p.y<1. && p.y>-2.)?  sxz+(1.-abs(p.y))*.06 : sxz;\n    sxz = (p.y<-2.)? sxz+(sin(p.y+1.3)*.5+.25) : sxz;  \n    float blade_d = box(p,vec3(sxz,3.2,sxz));\n    \n    p = pp;\n    p.y += 0.5;\n    p.z = abs(p.z)-.6;\n    p.x = abs(p.x);\n    p.xz *= rot(-PI/4.);\n    float carve = box(p,vec3(.6,1.5,0.2));\n    blade_d = max(-carve, blade_d);\n    \n    p = pp;\n    p.y += 0.5;\n    p.z = abs(p.z)-.25;\n    blade_d = max(-box(p,vec3(.3,1.5,.2)),blade_d);\n    \n    p = pp;\n    p.y += 2.95;\n    p.y += p.x*p.x*.5;\n    p.x = abs(p.x)-.45;    \n    p.xy *= rot(PI/6.);\n    p.yz *= rot(PI/4.);    \n    blade_d = min(blade_d, box(p, vec3(0.8,0.1,0.1)));\n    \n    obj blade_body = obj(blade_d, 1, vec3(.3-abs((pp.y)*.15),0.05,.2));\n    \n    g1 += 0.001/(0.001+blade_d*blade_d);\n    return blade_body;\n}\n\nobj pommel (vec3 p) \n{\n    p.y += 2.95;\n    vec3 pp = p;\n    \n    p.y += p.x*p.x*.5;\n    p.x = abs(p.x)-.45;    \n    p.xy *= rot(PI/6.);\n    p.yz *= rot(PI/4.);   \n    p.y += 0.22;\n    p.x += 0.2;\n    float pom_d = box(p, vec3(0.5,0.1,0.1));\n    \n    p = pp;\n    p.y += 1.;\n    p.xz *= rot(PI/4.);\n    pom_d = min(pom_d, box(p,vec3(0.13,0.8,0.13)));\n    \n    obj pom = obj(pom_d, 1, vec3(0.1,.7,0.));\n    \n    return pom;\n}\n\nobj inside_blade (vec3 p)\n{\n    p.y += 0.5;\n    float ins_d = box(p,vec3(.3,1.5,.06));\n    \n    float mot = clamp(motif(p.xy*.85), 0., 1.);\n    vec3 col = mix(vec3(0.2,.2+abs(p.y*.8),0.15), vec3(0.), mot); \n    \n    return obj(ins_d, 2, col);\n}\n\nobj SDF (vec3 p)\n{\n    p.xy -= vec2(-1.2, 1.2);\n    p.xy *= rot(PI/4.);\n    p.xz *= rot(iTime);\n    \n    obj scene = blade(p);\n    scene = minobj(scene, pommel(p));\n    scene = minobj(scene, inside_blade(p));\n    \n    return scene;\n}\n\nfloat line (vec2 uv, vec2 a, vec2 b, float r)\n{\n    vec2 pa = uv - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r*h;\n}\n\nfloat background (vec2 p)\n{\n    p.y += sin(iTime)*.05+.15;\n    vec2 pp = p;\n    // heart from iq\n    //https://www.shadertoy.com/view/XsfGRn\n    p *= .7;\n    p.y = -0.1 - p.y*1.5 + abs(p.x)*(1.-abs(p.x));\n    float r = length(p);\n    float d = 0.5;\n    float mask = AAstep(1.,r/d);\n    \n    p.x = abs(p.x);\n    mask *= AAstep(0.001, line(p, vec2(0.3,-.8), vec2(0.25, -.2), 0.1));\n    mask *= AAstep(0.001, line(p, vec2(.7,0.25), vec2(0.4, .15), 0.1));\n    mask *= AAstep(0.001, line(p, vec2(.6,0.5), vec2(0.3, .25), 0.09));\n    mask *= AAstep(0.001, line(p, vec2(.45,0.65), vec2(0.2, .35), 0.08));\n    mask *= AAstep(0.001, line(p, vec2(.3,0.75), vec2(0.1, .4), 0.07));\n    \n    p = pp;\n    p.y -= 0.1;\n    p.x = abs(p.x)-0.3;\n    mask += 1.-AAstep(0.001,circle(p, 0.15));\n    \n    return mask;\n}\n\nvec3 gn (vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(SDF(p).d-vec3(SDF(p-eps.xyy).d,SDF(p-eps.yxy).d,SDF(p-eps.yyx).d));\n}\n\nfloat spec (vec3 rd, vec3 l, vec3 n, float pw)\n{\n    return pow( max(dot(n, normalize(l-rd)), 0.), pw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float dither = hash21(uv);\n    \n    if (noise(uv*.3+iTime*.25).x<.5) discard;\n    \n    vec3 ro = vec3(0.001,0.001,-3.25),rd=normalize(vec3(uv,1.)),p=ro,\n    col= (swit(.25)<.5) ? vec3(1.-background(uv*.8)) : vec3(0.), \n    l=vec3(3.,7.,-1.);\n    \n    bool hit=false; obj O;\n    for (float i=0.; i<64.; i++)\n    {\n       O = SDF(p);\n       if (O.d<0.01)\n       {\n           hit=true; break;\n       }\n       O.d *= 0.9+dither*.05;\n       p += O.d*rd;\n    }\n    float t = length(p-ro);\n    \n    if(hit)\n    {\n        vec3 n = gn(p)*.5+.5;\n        float li = max(dot(n,normalize(l)),0.), sp=0.;\n        if (O.mat == 1) sp = spec(rd,l,n, 25.);\n        else if (O.mat == 2) sp = spec(rd,l,n, 15.);\n        col = mix(vec3(0.2,0.,0.3), O.c, li) + sp;\n    }\n    col += g1*vec3(0.3,0.0,0.2)*0.17;\n    \n    fragColor = vec4(sqrt(clamp(col,0.,1.)),1.0);\n}","name":"Image","description":"","type":"image"}]}