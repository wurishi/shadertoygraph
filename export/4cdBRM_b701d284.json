{"ver":"0.1","info":{"id":"4cdBRM","date":"1732962695","viewed":168,"name":"Green Dancer Vacation","username":"dray","description":"(Press Replay for sound synchronization.)\nGoes on vacation, runs out of money, becomes a street performer.\nBut seriously, this motion sequencing is 2x more compact than before.\nThere is a new guitar intro, more vibrato, more tremolo, a dog? and a â€¦","likes":12,"published":1,"flags":8,"usePreview":0,"tags":["mechanics","music","dancer"],"hasliked":0,"parentid":"XXjfzd","parentname":"Exercising Dancers"},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nMore fooling around and experiments with sequencing motion.\nJust as domain repetition folds space, time can be folded.\n*/\n\n// *********************************************************************************\n\n#define PI (3.14159265)\n#define TAU (2.*PI)\n\n#define min3(A,B,C) min(A,min(B,C))\n#define min5(A,B,C,D,E) min(min(A,B),min(C,min(D,E)))\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) // https://www.shadertoy.com/view/Xds3zN from iq\n{\n    vec3 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nmat3 MAT3xz(float ANG) { return mat3( cos(ANG),0,sin(ANG), 0,1,0, -sin(ANG),0,cos(ANG) ); }\nmat3 MAT3zy(float ANG) { return mat3( 1,0,0, 0,cos(ANG),sin(ANG), 0,-sin(ANG),cos(ANG) ); }\nmat3 MAT3xy(float ANG) { return mat3( cos(ANG),sin(ANG),0, -sin(ANG),cos(ANG),0, 0,0,1 ); }\n\n#define rot2d(ang) mat2(cos(ang),-sin(ang),sin(ang),cos(ang))\n\n// *********************************************************************************\n\nstruct DAN {\n    vec2 luarm, ruarm;   // spread arms apart 0-3 radians\n    vec2 lelbow, relbow; // bend elbows arms forward 0-3 radians\n    vec2 lelbowi, relbowi; // bend elbows arms across chest 0-3 radians\n    vec2 lshoulder, rshoulder; // raise arms in front 0-3 radians\n    //float lrota, rrota; // upper arm rotation -1 - 1 radians\n    vec2 lknee, rknee;  // bend knees 0-3 radians\n    vec2 luleg, ruleg;  // spread legs apart 0-1.5 radians\n    vec2 lhip, rhip;    // raise legs in front 0-3 radians\n    vec2 spin;\n    vec2 leanl, leanf;\n    float hop;\n    vec3 offset;\n    // result coordinates\n    vec3 _head, _hips; // body\n    vec3 _lshoulder,_lelbow, _lhand;\n    vec3 _rshoulder, _relbow, _rhand;\n    vec3 _lknee, _lhip, _lfoot;\n    vec3 _rknee, _rhip, _rfoot;\n    float _bottom;\n};\n\n#define DANIni(D) \\\n  D.luarm= D.lelbow= D.lelbowi= D.lshoulder= \\\n  D.ruarm= D.relbow= D.relbowi= D.rshoulder= \\\n  D.lhip= D.luleg= D.lknee= \\\n  D.rhip= D.ruleg= D.rknee= \\\n  D.spin= D.leanl= D.leanf=vec2(0); \\\n  D.hop=0.; D.offset=vec3(0);\n\n#define APPLY(m,MOV) \\\n  MOV(m,luarm) MOV(m,lelbow) MOV(m,lelbowi) MOV(m,lshoulder) \\\n  MOV(m,ruarm) MOV(m,relbow) MOV(m,relbowi) MOV(m,rshoulder) \\\n  MOV(m,lhip) MOV(m,luleg) MOV(m,lknee) \\\n  MOV(m,rhip) MOV(m,ruleg) MOV(m,rknee) \\\n  MOV(m,spin) MOV(m,leanl) MOV(m,leanf)\n\n#define STOP(m,FLD) m.FLD.y=m.FLD.x;\n#define DANstop(D) APPLY(D,STOP)\n\n// *************************************\n\n#define DSZ 12.\n\nvoid CompDancer(inout DAN m,float es) {\n\n#define MOVES(m,FLD) m.FLD.x=mix(m.FLD.y,m.FLD.x,es);\n    APPLY(m,MOVES)\n    \n    m._hips = vec3(0,0,0); // origin !\n    mat3 rott =  MAT3zy(m.leanf.x) * MAT3xz( m.spin.x ) * MAT3xy(m.leanl.x);\n    m._head = m._hips.x + vec3(0,.33,0)*DSZ * rott;\n\n    vec3 shoulders = mix( m._hips, m._head, .8 );\n\n    mat3 sav = rott;\n  \n    // left arm\n    m._lshoulder = shoulders - vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.lshoulder.x ) * MAT3xy( m.luarm.x ) * rott;\n    m._lelbow = m._lshoulder + vec3(0,-.14,0)*DSZ * rott;\n    //rott = MAT3zy( -m.lelbow ) * rott;\n    rott = MAT3zy( -m.lelbow.x ) * MAT3xy( -m.lelbowi.x ) * rott;\n    m._lhand = m._lelbow + vec3(0,-.14,0)*DSZ * rott;\n  \n    rott = sav;\n\n    // right arm\n    m._rshoulder = shoulders + vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.rshoulder.x ) * MAT3xy( -m.ruarm.x ) * rott;\n    m._relbow = m._rshoulder + vec3(0,-.14,0)*DSZ * rott;\n    //rott = MAT3zy( -m.relbow ) * rott;\n    rott = MAT3zy( -m.relbow.x ) * MAT3xy( m.relbowi.x ) * rott;\n    m._rhand = m._relbow + vec3(0,-.14,0)*DSZ * rott;\n\n    rott = sav;\n\n    // left leg\n    m._lhip = m._hips - vec3(.025,0,0)*DSZ * rott;\n    rott =  MAT3xy( m.luleg.x - m.leanl.x ) * MAT3zy( -m.lhip.x -  m.leanf.x ) * rott;\n    m._lknee = m._lhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.lknee.x ) * rott;\n    m._lfoot = m._lknee + vec3(0,-.18,0)*DSZ * rott;\n\n    rott = sav;\n\n    // right leg\n    m._rhip = m._hips + vec3(.025,0,0)*DSZ * rott;\n    rott = MAT3xy( -m.ruleg.x - m.leanl.x ) * MAT3zy( -m.rhip.x  - m.leanf.x ) * rott;\n    m._rknee = m._rhip + vec3(0,-.18,0)*DSZ * rott;\n    rott = MAT3zy( m.rknee.x ) * rott;\n    m._rfoot = m._rknee + vec3(0,-.18,0)*DSZ * rott;\n\n    m._bottom = min5( m._lhand.y, m._rhand.y, m._lfoot.y, m._rfoot.y, m._hips.y-.035*DSZ/3. ) - m.hop /*+ .025*/;\n}\n\n// *************************************\n\nfloat sdDancer(vec3 pt,DAN m,float xz) {\n    //pt.xz *= rot2d(xz);\n    pt += m.offset;\n    pt.y += m._bottom;\n    float dist = sdCapsule( pt, m._head, m._hips, .035*DSZ ); // body\n    float tmp;\n    //tmp = sdCone( pt, m._head.xz, .1 ); if ( tmp < dist ) dist = tmp;\n#define ADD(a,b,r) tmp = sdCapsule( pt, a, b, (r)*DSZ ); if ( tmp < dist ) dist = tmp;\n    ADD(m._lshoulder,m._lelbow,.02)\n    ADD(m._lhand,m._lelbow,.02)\n    ADD(m._rshoulder,m._relbow,.02)\n    ADD(m._rhand,m._relbow,.02)\n    ADD(m._lshoulder,m._rshoulder,.02)\n    ADD(m._lknee,m._lhip,.025)\n    ADD(m._lfoot,m._lknee,.025)\n    ADD(m._rknee,m._rhip,.025)\n    ADD(m._rfoot,m._rknee,.025)\n#undef ADD    \n    return dist;\n}\n\n// *********************************************************************************\n\nvoid CompWalker(inout DAN m,float es) {\n\n#define MOVES(m,FLD) m.FLD.x=mix(m.FLD.y,m.FLD.x,es);\n//    APPLY(m,MOVES)\n    \n    m._hips = vec3(0,0,0); // origin !\n    mat3 rott =  MAT3zy(m.leanf.x) /* * MAT3xz( m.spin.x ) * MAT3xy(m.leanl.x) */ ;\n    m._head = m._hips.x + vec3(0,.33,0)*DSZ * rott;\n\n    vec3 shoulders = mix( m._hips, m._head, .8 );\n\n    mat3 sav = rott;\n  \n    // left arm\n    m._lshoulder = shoulders - vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.lshoulder.x ) /* * MAT3xy( m.luarm.x ) * rott */;\n    m._lelbow = m._lshoulder + vec3(0,-.14,0)*DSZ * rott;\n    //rott = MAT3zy( -m.lelbow ) * rott;\n    //rott = MAT3zy( -m.lelbow.x ) * MAT3xy( -m.lelbowi.x ) * rott;\n    m._lhand = m._lelbow + vec3(0,-.14,0)*DSZ * rott;\n  \n    rott = sav;\n\n    // right arm\n    m._rshoulder = shoulders + vec3(.05,0,0)*DSZ * rott;\n    rott = MAT3zy( -m.rshoulder.x ) /* * MAT3xy( -m.ruarm.x ) * rott */;\n    m._relbow = m._rshoulder + vec3(0,-.14,0)*DSZ * rott;\n    //rott = MAT3zy( -m.relbow ) * rott;\n    //rott = MAT3zy( -m.relbow.x ) * MAT3xy( m.relbowi.x ) * rott;\n    m._rhand = m._relbow + vec3(0,-.14,0)*DSZ * rott;\n\n    rott = sav;\n\n    // left leg\n    m._lhip = m._hips - vec3(.025,0,0)*DSZ * rott;\n    rott =  /* MAT3xy( m.luleg.x - m.leanl.x ) * */ MAT3zy( -m.lhip.x /* -  m.leanf.x */ ) * rott;\n    m._lknee = m._lhip + vec3(0,-.18,0)*DSZ * rott;\n    //rott = MAT3zy( m.lknee.x ) * rott;\n    m._lfoot = m._lknee + vec3(0,-.18,0)*DSZ * rott;\n\n    rott = sav;\n\n    // right leg\n    m._rhip = m._hips + vec3(.025,0,0)*DSZ * rott;\n    rott = /* MAT3xy( -m.ruleg.x - m.leanl.x ) * */ MAT3zy( -m.rhip.x  /* - m.leanf.x */ ) * rott;\n    m._rknee = m._rhip + vec3(0,-.18,0)*DSZ * rott;\n    //rott = MAT3zy( m.rknee.x ) * rott;\n    m._rfoot = m._rknee + vec3(0,-.18,0)*DSZ * rott;\n\n    m._bottom = min5( m._lhand.y, m._rhand.y, m._lfoot.y, m._rfoot.y, m._hips.y-.035*DSZ/3. ) - m.hop /*+ .025*/;\n}\n\n\n// *************************************\n\n#define MOVE(FLD,P,L,H) FLD=vec2( ((.5-.5*cos(P))*((H)-(L))+(L)) );\n#define HOP(D,V0,G,T)  D.hop = max( 0., (V0)*(T) - (G)*(T)*(T) );\n#define STDY(FLD,VAL) FLD = vec2(VAL);\n\n#define FOR(TIME,CODE) \\\n  if ( tim > 0. ) { es = tim / (TIME); CODE; } tim -= (TIME);\n\n#define SRAMP(FLD,END) \\\n  FLD.y = es < 1. ? FLD.x  :END; FLD.x = END;\n\t\t\t\t\n#define REPEAT(TIME,CNT) \\\n  if ( tim > 0. && tim < (TIME)*((CNT)-1.) ) tim = mod(tim,TIME); \\\n  else tim -= (TIME)*((CNT)-1.);\n\n//#define REPEATI(TIME,CNT) \\\n//  if ( tim > 0. && tim < (TIME)*((CNT)-1.) ) iter=floor(tim/TIME), tim = mod(tim,TIME); \\\n//  else tim -= (TIME)*((CNT)-1.);\n\n#define WHEN(TIME,CODE) if ( tim > 0. && tim <= (TIME) ) { CODE; }\n\n// smooth step S curve\n//#define SS(C) ((C)*(C)*(3.-2.*(C)))\nfloat SS(float C) { return ((C)*(C)*(3.-2.*(C))); }\n\n//#define RAMP(S,E)   ((S)+((E)-(S))*es)\n\n#define KneeBend1(D) SRAMP(D.lhip,1.); SRAMP(D.rhip,1.); SRAMP(D.lknee,2.3); SRAMP(D.rknee,2.3);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n#define KneeBend2(D) SRAMP(D.lhip,3.); SRAMP(D.rhip,3.); SRAMP(D.lknee,3.); SRAMP(D.rknee,3.);  SRAMP(D.luleg,0.1); SRAMP(D.ruleg,0.1);\n\n#define KneeBend(D) SRAMP(D.lhip,3.); SRAMP(D.rhip,3.); SRAMP(D.lknee,3.); SRAMP(D.rknee,3.);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n#define StraightLegs(D) SRAMP(D.lhip,0.); SRAMP(D.rhip,0.); SRAMP(D.lknee,0.); SRAMP(D.rknee,0.);  SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.);\n\n#define RelaxArms(D) SRAMP(D.luarm,.1); SRAMP(D.ruarm,.1);  SRAMP(D.lelbow,.6); SRAMP(D.relbow,.6); \n\n#define CrossArmsFace(D) SRAMP(D.luarm,1.); SRAMP(D.ruarm,1.);  SRAMP(D.lelbow,1.8); SRAMP(D.relbow,1.5); SRAMP(D.lshoulder,1.5); SRAMP(D.rshoulder,1.5); \n\n// Now we can do it !!!!!\n#define CrossArms(D) ArmsSame(D,1.5,1.5,.6,.15,.5)\n\n#define ArmsSame(D,EL,ELI,SHO,OFF,OUT) \\\n  SRAMP(D.lelbow,EL); SRAMP(D.relbow,EL); /* out front */ \\\n  SRAMP(D.lelbowi,ELI); SRAMP(D.relbowi,ELI); /* across chest */ \\\n  SRAMP(D.lshoulder,(SHO)+(OFF)); SRAMP(D.rshoulder,(SHO)-(OFF)); /* arms up in front */ \\\n  SRAMP(D.ruarm,OUT); SRAMP(D.luarm,OUT); /* arms out */\n\n#define HandsInFront(D) ArmsSame(D,.6,0.,1.5,0.,1.)\n/*  \nSRAMP(D.luarm,1.); SRAMP(D.ruarm,1.);  SRAMP(D.lelbow,.6); SRAMP(D.relbow,.6);\\\nSRAMP(D.lshoulder,1.5); SRAMP(D.rshoulder,1.5);  */\n\n#define LArmDown(D) SRAMP(D.luarm,.1); SRAMP(D.lelbow,.1); SRAMP(D.lshoulder,.1);\n#define RArmDown(D) SRAMP(D.ruarm,.1); SRAMP(D.relbow,.1); SRAMP(D.rshoulder,.1);\n\n//#define HOP(D,V0,G,T)  STDY( D.hop, max( 0., (V0)*(T) - (G)*(T)*(T) ) )\n\n//#define STDY(FLD,VAL) FLD = tim <= 0. ? FLD : (VAL);\n\n#define WildArmsA(D) \\\n    MOVE(D.lelbow,iTime*1.5,.0,2.); \\\n    MOVE(D.relbow,iTime*2.,.0,2.); \\\n    MOVE(D.lshoulder,iTime*-3.,0.,2.); \\\n    MOVE(D.rshoulder,iTime*-2.5,0.,2.);\n\n#define WildArms(D) \\\n    MOVE(D.luarm,iTime*5.,0.,3.); \\\n    MOVE(D.ruarm,iTime*4.,0.,3.); \\\n    WildArmsA(D); \n    \n#define WildLLeg(D) \\\n    MOVE(D.lhip,iTime*5.,0.,1.); \\\n    MOVE(D.lknee,iTime*-7.,0.,1.); \\\n    MOVE(D.luleg,iTime*3.,0.,1.); \\\n    STDY( D.ruleg, -.075 ); \\\n    STDY( D.spin, iTime*5. );\n    \n#define WildRLeg(D) \\\n    MOVE(D.rhip,iTime*5.,0.,1.); \\\n    MOVE(D.rknee,iTime*-7.,0.,1.); \\\n    MOVE(D.ruleg,iTime*3.,0.,1.); \\\n    STDY( D.luleg, -.075 ); \\\n    STDY( D.spin, -iTime*4. );\n    \n#define StandUp(D) \\\n  SRAMP(D.luarm,0.); SRAMP(D.lelbow,0.); SRAMP(D.lelbowi,0.); SRAMP(D.lshoulder,0.); \\\n  SRAMP(D.ruarm,0.); SRAMP(D.relbow,0.); SRAMP(D.relbowi,0.); SRAMP(D.rshoulder,0.); \\\n  StraightLegs(D); \\\n  SRAMP(D.spin,0.); SRAMP(D.leanl,0.); SRAMP(D.leanf,0.);\n   \n#define LeftStep(D) SRAMP(D.luleg,0.); SRAMP(D.lknee,0.); SRAMP(D.ruleg,0.); SRAMP(D.rknee,0.); SRAMP(D.lhip,0.); SRAMP(D.rhip,0.);   \n\n#define ExtendRLeg(D) SRAMP(D.rhip,1.6) SRAMP(D.rknee,0.) SRAMP(D.ruleg,.5)\n#define ExtendLLeg(D) SRAMP(D.lhip,1.9) SRAMP(D.lknee,0.) SRAMP(D.luleg,.5)\n\n#define RaiseRLeg(D) SRAMP(D.rhip,.2) SRAMP(D.rknee,.5) SRAMP(D.ruleg,.2)\n#define RaiseLLeg(D) SRAMP(D.lhip,.2) SRAMP(D.lknee,.5) SRAMP(D.luleg,.2)\n\n#define RaiseRKnee(D) SRAMP(D.rhip,1.6) SRAMP(D.rknee,1.6) SRAMP(D.ruleg,.5)\n#define RaiseLKnee(D) SRAMP(D.lhip,1.6) SRAMP(D.lknee,1.6) SRAMP(D.luleg,.5)\n\n#define Lotusl(D) SRAMP(D.luleg,1.4) SRAMP(D.ruleg,.4)\n\n#define Lotus(D) SRAMP(D.luleg,1.4) SRAMP(D.ruleg,1.4)\n\n#define Walk1(D) SRAMP(D.luleg,0.); \\\n                 SRAMP(D.lknee,1.); SRAMP(D.lhip,1.); \\\n                  /*SRAMP(D.rshoulder,-.5)*/\n#define Walk2(D) Walk2a(D,-1.)\n#define Walk2a(D,E) SRAMP(D.luleg,0.); \\\n                 SRAMP(D.lknee,0.); SRAMP(D.lhip,.1); \\\n                 SRAMP(D.rknee,0.); SRAMP(D.rhip,E); \\\n                 /*SRAMP(D.ruleg,0.); SRAMP(D.rknee,.0); SRAMP(D.rhip,-.5); \\\n                 SRAMP(D.rshoulder,.5);*/\n#define Walk3(D) SRAMP(D.ruleg,0.); \\\n                 SRAMP(D.rknee,1.); SRAMP(D.rhip,1.);  \\\n                 /*SRAMP(D.lshoulder,-.5)*/\n#define Walk4(D) Walk4a(D,-1.)\n#define Walk4a(D,E) SRAMP(D.ruleg,0.); \\\n                 SRAMP(D.rknee,0.); SRAMP(D.rhip,.1); \\\n                 SRAMP(D.lknee,0.); SRAMP(D.lhip,E); \\\n                 /* SRAMP(D.luleg,0.); SRAMP(D.lknee,.0); SRAMP(D.lhip,-.5); \\\n                  SRAMP(D.lshoulder,.5) */\n\n#define Run1(D) SRAMP(D.leanf,.5) \\\n                SRAMP(D.luleg,0.); SRAMP(D.ruleg,0.); \\\n                \\\n                SRAMP(D.lknee,1.); SRAMP(D.lhip,1.); \\\n                SRAMP(D.rshoulder,-.2) SRAMP(D.relbow,0.); \n#define Run2(D) SRAMP(D.lknee,0.); SRAMP(D.lhip,.1); \\\n                SRAMP(D.rknee,0.); SRAMP(D.rhip,-.3); \\\n                SRAMP(D.lshoulder,1.); SRAMP(D.lelbow,1.); \n#define Run3(D) SRAMP(D.rknee,1.); SRAMP(D.rhip,1.);  \\\n                SRAMP(D.lshoulder,-.2) SRAMP(D.lelbow,0.);\n#define Run4(D) SRAMP(D.rknee,0.); SRAMP(D.rhip,.1); \\\n                SRAMP(D.lknee,0.); SRAMP(D.lhip,-.3); \\\n                SRAMP(D.rshoulder,1.) SRAMP(D.relbow,1.); \n\n#define Bow(D) SRAMP(D.leanf,1.7)\n#define DeepBow(D) SRAMP(D.leanf,2.2)\n\n#define Fours(D) SRAMP(D.leanf,2.15) \\\n                 /*SRAMP(D.lshoulder,2.0) SRAMP(D.rshoulder,2.0)*/\n\n#define HandStand1(D) SRAMP(D.leanf,PI-.2) SRAMP(D.lshoulder,PI-.4) SRAMP(D.rshoulder,PI-.4) \\\n        SRAMP(D.rhip,-PI+.4)\n#define HandStand2(D) SRAMP(D.leanf,PI)    SRAMP(D.lshoulder,PI)    SRAMP(D.rshoulder,PI) \\\n        SRAMP(D.lhip,-PI+.5) \\\n        SRAMP(D.rknee,.7); SRAMP(D.lknee,.6);\n#define HandStand3(D) SRAMP(D.leanf,PI-.2) SRAMP(D.lshoulder,PI-.4) SRAMP(D.rshoulder,PI)    SRAMP(D.rhip,0.)\n#define HandWalk1(D)  SRAMP(D.lshoulder,PI+.4) SRAMP(D.rshoulder,PI-.4) \\\n        SRAMP(D.rknee,.8); SRAMP(D.lknee,.9);\n#define HandWalk2(D)  SRAMP(D.rshoulder,PI+.4) SRAMP(D.lshoulder,PI-.4) \\\n        SRAMP(D.rknee,1.2); SRAMP(D.lknee,1.4);\n\n#define Spin(D,X) SRAMP(D.spin,(X))\n\n// lshoulder here moves elbow forward without moving hand\n#define LHandHead(D) SRAMP(D.lelbowi,-2.6) SRAMP(D.luarm,2.) SRAMP(D.lelbow,0.) SRAMP(D.lshoulder,.5)\n#define RHandHead(D) SRAMP(D.relbowi,-2.6) SRAMP(D.ruarm,2.) SRAMP(D.relbow,0.) SRAMP(D.rshoulder,.5)\n\n#define LHandForehead(D) SRAMP(D.lelbowi,-2.6) SRAMP(D.luarm,2.) SRAMP(D.lelbow,0.) SRAMP(D.lshoulder,0.)\n#define RHandForehead(D) SRAMP(D.relbowi,-2.6) SRAMP(D.ruarm,2.) SRAMP(D.relbow,0.) SRAMP(D.rshoulder,0.)\n\n#define SINM(P,L,H) ((.5-.5*sin(P))*((H)-(L))+(L))\n#define COSM(P,L,H) ((.5-.5*cos(P))*((H)-(L))+(L))\n\n// Ramp from previous to new value\n#define RAMPINSPD 1.\n#define RAMPIN(FLD,VAL) FLD = mix( FLD, vec2(VAL), clamp(tim/RAMPINSPD,0.,1.) );\n// Ramp into circular motion\n#define SINMV(FLD,SPD,L,H) RAMPIN(FLD,SINM(SPD,L,H))\n#define COSMV(FLD,SPD,L,H) RAMPIN(FLD,COSM(SPD,L,H))\n\n#define BendLegs(m) \\\n  m.luleg=m.ruleg=vec2(.2); \\\n  m.rhip = m.lhip = ( m.lknee = m.rknee = vec2(SINM(iTime,.3,1.3) ) * .5);\n  \n#define BendLegs2(m) \\\n  RAMPIN(m.luleg,.2) RAMPIN(m.ruleg,.2) \\\n  { float tmp = SINM(iTime,.3,1.3); \\\n  RAMPIN(m.lknee,tmp) RAMPIN(m.rknee,tmp) \\\n  tmp *= .5; \\\n  RAMPIN(m.rhip,tmp) RAMPIN(m.lhip,tmp) \\\n  }\n\n#define Squat(m) \\\n  SRAMP(m.rhip,2.8) SRAMP(m.lhip,2.8) \\\n  SRAMP(m.rknee,2.8) SRAMP(m.lknee,2.8) \n\n#define Squat1(m) \\\n  SRAMP(m.rhip,PI*.25) SRAMP(m.lhip,PI*.25) \\\n  SRAMP(m.rknee,PI*.75) SRAMP(m.lknee,PI*.75)\\\n  SRAMP(m.leanf,.4) \\\n  SRAMP(m.lelbow,.8) SRAMP(m.relbow,.8) \n#define Squat2(m) \\\n  SRAMP(m.rhip,PI*.5) SRAMP(m.lhip,PI*.25) \\\n  SRAMP(m.rknee,PI*.6) SRAMP(m.lknee,PI*.75)\\\n  SRAMP(m.rshoulder,.1) SRAMP(m.lshoulder,1.)\n#define Squat3(m) \\\n  SRAMP(m.rhip,PI*.25) SRAMP(m.lhip,PI*.5) \\\n  SRAMP(m.rknee,PI*.75) SRAMP(m.lknee,PI*.6)\\\n  SRAMP(m.rshoulder,1.) SRAMP(m.lshoulder,.1)\n\n#define AirGuitar1(D) \\\n  SRAMP(D.ruarm,1.) SRAMP(D.relbow,1.) SRAMP(D.relbowi,-1.) \\\n  SRAMP(D.luarm,.5) SRAMP(D.lshoulder,.8) SRAMP(D.lelbow,0.) SRAMP(D.lelbowi,1.) \\\n  SRAMP(D.leanf,.25) \n\n#define AirGuitarFloor(D) \\\n  SRAMP(D.lhip,PI*.25) SRAMP(D.lknee,PI*.75) \\\n  SRAMP(D.rhip,PI*.25) SRAMP(D.rknee,PI*.75)\n\n#define AirGuitar1A(D) \\\n  SRAMP(D.lhip,.5) SRAMP(D.luleg,.2) SRAMP(D.lknee,1.5) \\\n  SRAMP(D.rhip,.25)SRAMP(D.ruleg,.0) SRAMP(D.rknee,.5) \\\n\n#define AirGuitar1B(D) \\\n  SRAMP(D.lhip,.25) SRAMP(D.luleg,.0) SRAMP(D.lknee,.5) \\\n  SRAMP(D.rhip,.5) SRAMP(D.ruleg,.2) SRAMP(D.rknee,1.5) \\\n\n#define AirGuitar2(D) SRAMP(D.luarm,-.5) SRAMP(D.lelbowi,2.)\n#define AirGuitar3(D) SRAMP(D.luarm,.5) SRAMP(D.lelbowi,1.)\n\n#define Drum1r(D) SRAMP(D.rshoulder,PI*.5) SRAMP(D.relbow,1.)\n#define Drum2r(D) SRAMP(D.rshoulder,PI*.25)  SRAMP(D.relbow,.0)\n#define Drum1l(D) SRAMP(D.lshoulder,PI*.5) SRAMP(D.lelbow,1.)\n#define Drum2l(D) SRAMP(D.lshoulder,PI*.25)  SRAMP(D.lelbow,.0)\n#define Drum1lF(D) SRAMP(D.lknee,1.) SRAMP(D.lhip,1.)\n#define Drum2lF(D) SRAMP(D.lknee,.0) SRAMP(D.lhip,.0)\n\n/*\n#define Drum1(D) \\\n  SRAMP(D.ruarm,2.5) SRAMP(D.rshoulder,1.5) SRAMP(D.relbow,.0) SRAMP(D.relbowi,.0) \\\n  SRAMP(D.luarm,-.2) SRAMP(D.lshoulder,1.) SRAMP(D.lelbow,.0) SRAMP(D.lelbowi,.0)\n#define DrumA(D) \\\n  SRAMP(D.rshoulder,.5) SRAMP(D.lshoulder,1.)\n#define DrumB(D) \\\n  SRAMP(D.rshoulder,1.) SRAMP(D.lshoulder,.5)\n\n#define Drum2(D) \\\n  SRAMP(D.ruarm,.5) SRAMP(D.rshoulder,1.) SRAMP(D.relbow,.5) SRAMP(D.relbowi,.5) \\\n  SRAMP(D.luarm,-.2) SRAMP(D.lshoulder,1.) SRAMP(D.lelbow,.5) SRAMP(D.lelbowi,.25)\n*/\n\n// *********************************************************************************\n\nDAN Jill;\n\nfloat animJill() {\n\t\t \n    DANIni(Jill);\n\n    if ( iTime > 150. ) return 1.;\n\n    float tim = iTime; // + 50.; // mod(iTime,1118.);\n    float es = 1.; // smoothstep s-curve within current motion   \n\n/*\nFOR(.5,Drum1(Jill))\n//REPEAT(1.,1000.)\n\nFOR(.25,DrumB(Jill))\nREPEAT(.5,1000.)\nFOR(.25,DrumA(Jill))\nFOR(.25,DrumB(Jill))\n\nFOR(.5,Drum1(Jill))\n*/\n\n\n// 2w 5h 4w\n//REPEAT(1.5+.5*6.+.25*8.,1000.)\nFOR(1., AirGuitar1(Jill) )\n//FOR(.5, AirGuitar1B(Jill) )\n//FOR(.5, AirGuitarFloor(Jill) )\nFOR(.5, AirGuitar3(Jill) )\nFOR(.5, AirGuitar2(Jill) )\nREPEAT(.5,5.)\nFOR(.1, AirGuitar3(Jill) )\nFOR(.4, AirGuitar2(Jill) )\nREPEAT(1.,4.)\nFOR(.1, AirGuitar3(Jill) )\nFOR(.9, AirGuitar2(Jill) )\n\nFOR(.5,StandUp(Jill))\nFOR(1.,)\n\n#if 1\n\n\n/*\nFOR(1.,StandUp(Jill) Drum1r(Jill); Drum2lF(Jill);)\n//FOR(1000.,)\nREPEAT(.5,12.*100.)\n//FOR(.125,Drum1r(Jill);Drum1lF(Jill);)\n//FOR(.125,Drum2r(Jill);Drum2lF(Jill);)\nFOR(.1,Drum2r(Jill))\nFOR(.15,Drum1r(Jill))\nFOR(.15,Drum2l(Jill))\nFOR(.1,Drum1l(Jill))\n*/\n\n\n\n        /*AirGuitar1B(Jill)*/ \n/*\nREPEAT(.5,1000.)\nFOR(.25,  )\nFOR(.25, AirGuitar1B(Jill) )\n\nREPEAT(.25,16.)\nFOR(.125, AirGuitar2(Jill) AirGuitar1A(Jill) )\nFOR(.125, AirGuitar3(Jill) AirGuitar1B(Jill) )\nFOR(.5,)\nFOR(1., StandUp(Jill) )\n*/\n\n/*\n// drumming\nREPEAT(4.,1000.)\nREPEAT(1.,2.)\nFOR( .5, SRAMP(Jill.luarm,1.) )\nFOR( .5, SRAMP(Jill.luarm,0.) )\nREPEAT(1.,2.)\nFOR( .5, SRAMP(Jill.lshoulder,1.) )\nFOR( .5, SRAMP(Jill.lshoulder,0.) )\n\nFOR( 10., MOVE(Jill.lelbow,tim*1.,.2,1.) )\n*/\n\n    //FOR(8.,)\n    if ( tim >=0. && tim < 8. )\n    {\n    HOP(Jill, 15., 40., fract(tim*2.) )\n    MOVE(Jill.lelbow,tim*1.,.2,1.);\n    MOVE(Jill.relbow,tim*4.,.1,1.);\n    MOVE(Jill.lshoulder,tim*-4.,0.,2.2);\n    MOVE(Jill.rshoulder,tim*-1.,0.,1.8);\n    MOVE(Jill.luarm,tim*1.,0.,.5);\n    MOVE(Jill.ruarm,tim*3.,0.,1.5);\n    MOVE(Jill.rhip,tim*5.,0.,1.);\n    MOVE(Jill.rknee,tim*-7.,0.,1.);\n    MOVE(Jill.ruleg,tim*3.,0.,1.);\n    STDY(Jill.luleg, -.075 );\n    STDY(Jill.spin, -tim*4. );\n    MOVE(Jill.leanf,tim*1.5,-.5,.5);  \n    return es;\n    }\n    tim -= 8.;\n\n    FOR(1., Spin(Jill,1.) )\n/*\nDancers 3\n\tif ((_tim2615 & gt; 0.0)) {\n\t\t(_es2616 = (_tim2615 / 1.0));\n\t\tfloat sa86 = {\n\t\t\t0\n\t\t};\n\t\tif ((_es2616 & lt; 1.0)) {\n\t\t\t(sa86 = _Jill._spin.x);\n\t\t} else {\n\t\t\t(sa86 = 1.0);\n\t\t}\n\t\t(_Jill._spin.y = sa86);\n\t\t(_Jill._spin.x = 1.0);\n\t}\n\t(_tim2615 -= 1.0);\n\n*/    \n/*\nDancers 0\n\tfloat sa86 = {\n\t\t0\n\t};\n\tif ((_tim2616 & lt; 0.0)) {\n\t\t(sa86 = 0.0);\n\t} else {\n\t\tfloat sa87 = {\n\t\t\t0\n\t\t};\n\t\tif ((_tim2616 & gt; 1.0)) {\n\t\t\t(sa87 = 1.0);\n\t\t} else {\n\t\t\t(sa87 = f_SS((_tim2616 / 1.0)));\n\t\t}\n\t\t(sa86 = sa87);\n\t}\n\t(_es2617 = sa86);\n\tif ((_tim2616 & gt; 0.0)) {\n\t\t(_tim2616 -= 1.0);\n\t}\n\t(_Jill._spin = (_Jill._spin + ((1.0 - _Jill._spin) * _es2617)));\n\tfloat sa88 = {\n\t\t0\n\t};\n*/\n\n  \n    FOR(1., HandStand1(Jill) )\n       \n    FOR(1., HandStand2(Jill) )\n\n    FOR(.5, HandWalk1(Jill); )\n    REPEAT(1.,6.)\n\t\t \n    FOR(.5, HandWalk2(Jill) )\n\t\t\t     \n    FOR(.5, HandWalk1(Jill) )\n    \n    FOR(.5, HandWalk2(Jill) )\n\t\t\t     \n    FOR(1., HandStand3(Jill) )\n\t\t\t      \n    FOR(1., StandUp(Jill) )\n\nFOR(1., Spin(Jill,-.3) )\n\t\nFOR(1., Squat1(Jill) )\n\t\t      \nFOR(.5, Squat2(Jill) )\nREPEAT(1.,6.)\n\t     \nFOR(.5, Squat3(Jill) )\n\t\t      \nFOR(.5, Squat2(Jill) )\n\nFOR(.5,\nStandUp(Jill)\nBendLegs2(Jill)\n)\n\nREPEAT(.5*(8.+10.),2.)\n\n//float iter;\n//REPEATI(.5,2000.)\n//FOR(5.)\n//SINMV(Jill.luarm,1.,.3,.8)\n//ArmsSame(Jill,0.,0.,.3+mod(iter,4.),.1,.0);//1.-2.*mod(iter,2.))\n\nFOR(.5,\nArmsSame(Jill,.5,.5,0.4,.1,.5) )\nFOR(.5,\nArmsSame(Jill,.5,.5,0.6,.1,-.5) )\nFOR(.5,\nArmsSame(Jill,.5,.5,0.8,.1,.5) )\nFOR(.5,\nArmsSame(Jill,.5,.5,1.0,.1,-.5) )\nFOR(.5,\nArmsSame(Jill,.5,.5,1.2,.1,.5) )\nFOR(.5,\nArmsSame(Jill,.5,.5,1.4,.1,-.5) )\nFOR(.5,\nArmsSame(Jill,.5,.5,1.6,.1,.5) )\nFOR(.5,\nArmsSame(Jill,.5,.5,1.8,.1,-.5) )\n\nFOR(.5,\nRelaxArms(Jill) )\nFOR(.5, \nLHandHead(Jill) )\n//FOR(.5) CrossArmsFace(Jill)\nFOR(.5,\nCrossArms(Jill) )\nFOR(.5,\nRHandHead(Jill) )\nFOR(.5,\nArmsSame(Jill,0.,0.,.6,.1,.1) )\nFOR(.5,\nArmsSame(Jill,1.,0.,.6,1.2,.4) )\nFOR(.5,\nArmsSame(Jill,1.,2.,.6,.1,.4) )\nFOR(.5,\nArmsSame(Jill,0.,2.,.6,.4,.3) )\nFOR(.5,\nArmsSame(Jill,0.,0.,.6,.1,.1) )\nFOR(.5,\nLArmDown(Jill) )\nFOR(.5,\nRArmDown(Jill) )\nFOR(.5,\nArmsSame(Jill,0.,0.,.0,.0,.0) )\n\n\n    FOR(1.,\n      //Spin(Jill,-1.)\n      StandUp(Jill)\n      Run1(Jill)  \n      WHEN(20.,Spin(Jill,tim/4.))  \n    )\n    REPEAT(.8,12.)\n    FOR(.2,\n    Run2(Jill) )\n    FOR(.2,  \n    Run3(Jill) )\n    FOR(.2,\n    Run4(Jill)  )\n    FOR(.2,\n    Run1(Jill) )\n\n\n    FOR(1.,\n    StandUp(Jill)\n    WHEN(20.,Spin(Jill,tim)) \n    Spin(Jill,-.4) )\n    FOR(.5,\n    Walk1(Jill) )\n    REPEAT(2.,8.)\n    FOR(.5,\n    Walk2(Jill) )\n    FOR(.5,\n    Walk3(Jill) )\n    FOR(.5,\n    Walk4(Jill) )\n    FOR(.5,\n    Walk1(Jill) )\n\n\n    FOR(1.,\n    StandUp(Jill) )\n    FOR(1.,\n    CrossArms(Jill) \n    KneeBend2(Jill)\n    Lotus(Jill)\n    WHEN(10.,WildArms(Jill))  \n    )\n    FOR(1.,\n    Lotus(Jill) )\n    FOR(6., )\n    FOR(1.,\n    KneeBend2(Jill) )\n    FOR(1.,\n    KneeBend1(Jill) )\n    FOR(1.,\n    StandUp(Jill) )\n\n\n    REPEAT(11.,2.)\n    WHEN(11.,WildArms(Jill);)\n    FOR(1.,\n    SRAMP(Jill.leanl,.2) )\n    FOR(1.,\n    SRAMP(Jill.leanl,0.) )\n    FOR(1.,\n    KneeBend1(Jill) )\n    FOR(1.,\n    KneeBend2(Jill) )\n    FOR(1.,\n    KneeBend2(Jill) )\n    FOR(1.,\n    KneeBend1(Jill) )\n    FOR(1.,\n    StraightLegs(Jill) )\n    FOR(.5,\n    HandsInFront(Jill)\n    //ExtendRLeg(Jill);\n    RaiseRKnee(Jill) )\n    FOR(.5,\n    StraightLegs(Jill) )\n    FOR(.5,\n    RaiseLKnee(Jill) )\n    FOR(.5,\n    StraightLegs(Jill) )\n    FOR(1.,\n    RaiseRLeg(Jill)\n    LArmDown(Jill)\n    SRAMP(Jill.spin,6.28*.75)  )\n    FOR(1.,\n    RaiseLLeg(Jill)\n    RArmDown(Jill)\n    SRAMP(Jill.spin,0.) )\n\n\n    //REPEAT(12.,1000.)\n    FOR(1.,\n    StraightLegs(Jill) )\n    //WHEN(1000.,\n      FOR(1.,\n      BendLegs(Jill)\n      SRAMP(Jill.leanl,.3*sin(iTime*PI))\n      SRAMP(Jill.leanf,.3*cos(iTime*PI))\n      ArmsSame(Jill,.2*sin(iTime*2.),.2+.2*sin(iTime*3.),.5+.5*sin(iTime*4.),.1*sin(iTime*5.),.4+.2*sin(iTime*6.))\n      ) \n    FOR(12.,)\n    //FOR(1.)\n    //StraightLegs(Jill);\n    \n/*      \n    FOR(0.)\n    SRAMP(Jill.leanl,-.3)\n    SRAMP(Jill.leanf,-.3)\n    REPEAT(4.,1000.)\n    FOR(1.)\n    SRAMP(Jill.leanl,.3)\n    FOR(1.)\n    SRAMP(Jill.leanf,.3)\n    FOR(1.)\n    SRAMP(Jill.leanl,-.3)\n    FOR(1.)\n    SRAMP(Jill.leanf,-.3)\n*/\n/*\n    Spin(Jill,-.5);\n    REPEAT(2.,1000.)\n    FOR(1.)  \n    Fours(Jill);\n    //SRAMP(Jill.lknee,2.) // SRAMP(Jill.rknee,2.)\n    FOR(1.)  \n    //SRAMP(Jill.lhip,-1.) // SRAMP(Jill.rhip,-1.)\n/*\n    FOR(1.)\n    ExtendRLeg(Jill)\n    //Spin(Jill,PI);\n    FOR(1.)  \n    StraightLegs(Jill);\n    FOR(1.)\n    ExtendLLeg(Jill)\n    Spin(Jill,0.);\n*/    \n/*\n    FOR(1.)  \n    StraightLegs(Jill);\n*/\n\n    FOR(1.,     StandUp(Jill) )\n\t   \n    FOR(.5,    Bow(Jill) )\n\t   \n    FOR(1.,     StandUp(Jill) )\n    \n    FOR(4.,)\n    \n    FOR(1.,\n      Spin(Jill,PI/2.)\n      RelaxArms(Jill)\n    )\n    FOR(10.,)\n\n#endif\n\n    return clamp(SS(es),0.,1.);\n}\n\n// *********************************************************************************\n\nDAN Walker1;\n\n#define RAMP(T,L,H) (mod(T,(H)-(L))+(L))\n\nfloat animWalker(inout DAN m,float time) {\n    float tim = time, es = 1.;\n    DANIni(m);\n    m.lshoulder = - \n     (m.rshoulder=vec2(.5*sin(TAU/1.2*(time-PI*.05))));\n    m.rhip=m.lshoulder;\n    m.lhip=m.rshoulder;\n return 1.;\n}\n\n// *********************************************************************************\n\nfloat time;\n  \nvec2 Dist(vec3 pt) {\n    vec2 hit = vec2(100000,0);\n    float tmp, clr = 0.;\n#define T(SDF,CLR) if ( (tmp = SDF) < hit.x ) hit = vec2(tmp,CLR);\n\n    T( sdDancer(pt-vec3(10,-4,30),Jill,0.) , 0. )\n\n#define wspd 8.    \n    vec3 ptf;\n if ( pt.z < 150. && pt.z > 0. ) {   \n    ptf = pt;\n    ptf.x += ptf.z*-.1;\n    ptf.z = 20.+mod(ptf.z+time*wspd,40.);\n    T( sdDancer((ptf-vec3(-5,-4,30))*vec3(-1,1,1),Walker1,0.) , 1. )\n    \n    ptf = pt;\n    ptf.x += ptf.z*+.1;\n    float k = ptf.z+time*10.+wspd;\n    ptf.z = 20.+mod(k,40.);\n    T( sdDancer( (ptf-vec3(5,-4,30))*vec3(1,1.2,1),Walker1,0.) , 1. )\n\n    ptf = pt;\n    ptf.x += ptf.z*+.0;\n    ptf.z = 20.+mod(ptf.z+time*wspd+10.,30.);\n    T( sdDancer(ptf-vec3(-8,-4,30),Walker1,0.) , 1. )\n    \n    ptf = pt; // kid\n    ptf.x += ptf.z*+.0;\n    ptf.z = 20.+mod(ptf.z+time*wspd+15.,90.);\n    T( sdDancer( (ptf-vec3(-9,-4,30))*vec3(1.3,2,2),Walker1,0.)/2. , 1. )\n}\n    \n    T( pt.y+5., 85. ); \n\n    return hit;\n}\n\n#define ZERO (min(iFrame,0)) // trick to avoid loop unrolling\n\nvec4 March(vec3 beg,vec3 dir) { // return intersection point and object of ray\n    float dist = 0.;\n    vec3 pos;\n    for ( int stps = ZERO; stps < 300+1; ++stps ) {\n        pos = beg + dir * dist;\n        vec2 obj = Dist( pos );\n        dist += obj.x;\n        if ( dist > 200. ) return vec4( pos, 91. );\n        if ( pos.z < -80. ) return vec4( pos, 91. );\n        if ( obj.x < .01 || stps == 300 ) return vec4( pos, obj.y );\n    }\n    return vec4( pos, 90. );\n}\n\nvec3 Normal(vec3 pt) {\n    float delta = .001; // large delta gives rounded corners\n    vec3 norm = Dist(pt).x - vec3(\n        Dist(pt-vec3(delta, 0., 0.)).x, \n        Dist(pt-vec3( 0.,delta, 0.)).x, \n        Dist(pt-vec3( 0., 0.,delta)).x );\n    return normalize( norm );\n}\n\n// *********************************************************************************\n\n#define REWIND4X(START,LENG) \\\n  if ( time >= START && time < START+LENG ) \\\n    time = START-(time-START)*4.;\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    time = iTime;\n    \n    float es = animJill();\n    CompDancer(Jill,es);\n       \n    REWIND4X(130.+8.,8.)\n    \n    es = animWalker(Walker1,time);     CompWalker(Walker1,es);\n    //CompDancer(Walker1,animWalker(Walker1,iTime));\n\n    vec2 R = iResolution.xy;\n    U.y += 100.;\n    vec2 uv = (U+U-R)/R.y;\n    vec3 dir = normalize( vec3( uv, 2.5 ) );\n    //dir.z = -dir.z;\n\t//vec3 back=vec3(dir.xz*rot2d(iTime),dir.y).xzy;\n    //dir = back;\n\tvec3 cam = vec3(0, 0, 0);\n\n    mat2 rot = rot2d(sin(iTime)*.02);//iTime*.2);//SINRAMP(iTime,-1.,1.));\n\t//cam.xz *= rot;\n\tdir.xz *= rot;\n\tdir.yz *= rot2d(cos(iTime)*.02);;\n    \n    vec4 hit = March( cam, dir );\n\n    vec3 back=dir;\n    back.xz *= rot2d(PI/2.);\n    O = texture( iChannel0, back );\n\n\n    vec3 Light = vec3( -200., 100, -300 );\n    //vec3 Light = vec3( sin(iTime)*40., 30, -30 );\n    vec3 ldir = normalize( Light - hit.xyz );\n\n    vec3 norm = Normal(hit.xyz);\n    float difu = dot( norm, ldir );\n    difu = .3 + .7*difu;\n    \n    //vec4 shadow0 = March( hit.xyz+dir*.1, dir );\n   // if ( shadow0.z > -10. ) O *= .5; //difu *= .7;\n\n    #define color4(X) ( .5 + .3 * sin( vec4(0,21,23,0) + (X) ) )\n    \n    if ( hit.w < 80. ) {\n    O = color4(hit.w*.4);\n    \n    O *= max(.5,difu)*.8;\n   \n    O = sqrt(O);\n    }\n\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Lots of the guitar simulation still needs work\n\n#define PI (3.14159265)\n#define TAU (PI*2.)\n\n#define COS(X) cos(mod(X,TAU))\n#define SIN(X) sin(mod(X,TAU))\n#define SINC(X) (SIN(X)/(X))\n\nint inoisei(int a) {\n  a = (a * 54321) ^ (a * 14873);\n  a ^= a >> 16; // graycode\n  a ^= a >> 8;\n  a ^= a >> 4;\n  a ^= a >> 2;\n  a ^= a >> 1;\n  return a & 65535;\n}  \n\nfloat noisei(int a) {\n  return float( inoisei(a) & 65535 ) / 65536. ;\n}\n\nfloat noise(float a) { return noisei(int(a*1234.)); }\n\n#define RND0(L,H,IN) (noisei(IN)*(H-L)+L)\n#define RND(L,H,IN) (noise(IN)*(H-L)+L)\n\n#define FS iSampleRate\n\nfloat tonnos(float t,float f) {\n    float a = t*f;\n    int b = int(a);\n    return mix(noisei(b),noisei(b+1),smoothstep(0.,1.,fract(a))); // crude filter\n}\n\n\n\n#define FMT(FC,VOL,Q) max( 0., VOL - max(FC/har,har/FC) * Q )\n\nfloat voice(float time,float fc,float f1,float v1,float q1,float f2,float v2,float q2/*,float f3,float v3,float q3*/) {\n  float oo = 0.;\n  int cnt = 0;\n  for ( float har = fc; har < 12e3 && cnt++ < 30; har += fc ) {\n    oo += sin(TAU*time*har) * fc/har * ( \n      FMT(f1,v1,q1)  + FMT(f2,v2,q2)  // + FMT(f2,v2,q2)\n    );\n  }\n  return oo;\n}\n\nfloat voiceN3(float time,float fc1,float fc2,float fc3,float f1,float v1,float q1,float f2,float v2,float q2) {\n  return voice(time,fc1,f1,v1,q1,f2,v2,q2)+voice(time,fc2,f1,v1,q1,f2,v2,q2)+voice(time,fc3,f1,v1,q1,f2,v2,q2);\n}\n\n#define OSC(L,H,F) ((sin(TAU*gtime*(F))+1.)*.5*((H)-(L))+(L))\n\nfloat note(float time,float rep,float phs,float att,float dur,float dec) {\n  float t=mod(time-phs-att,rep);\n  return t<att ? t/att : t<att+dur ? 1. : exp(-(t-att-dur)/dec);\n}\n\nfloat rhyt(float time,float rep,float phs,float dec) {\n  return note(time,rep,phs,.0002,.0,dec);\n}\n\nfloat ramp(float time,float rep,float lo,float hi) {\n  return fract(time/rep)*(hi-lo)+lo;\n}\n\nfloat stair(float val,float rise) {\n  return floor(val/rise)*rise;\n}\n\n// ----\n\nfloat rampa(float aa,float bb,float xx) {\n    return clamp( (xx-aa)/(bb-aa), 0., 1. );\n}\n\n// For ramping frequencies\nfloat rampfc(float aa,float bb,float xx,float tm) {\n    bb -= aa;\n    float rr = clamp( (xx-aa)/bb, 0., 1. );\n    return ( rr < 1. ? rr*rr*bb/tm/2. : rr ) + 1.;\n}\n\n// For ramping frequencies\nfloat rampfc(float ratio,float ta,float tb,float tx,float time) {\n    tb -= ta;\n    float rr = clamp( (tx-ta)/tb*ratio, 0., 1. );\n    return ( rr < 1. ? rr*rr*tb/time/2. : ratio ) + 1.;\n}\n\n//return vec2( .2*SIN(TAU*time*200.* rampfc(3./4.,1.5,1.,mod(time,4.),time))  );\n//return vec2( .2*SIN(TAU*time*200.* rampfc(1.,2.5,mod(time,4.),time))  );\n\n// ----\n\n#define ROUNDTO(X,Y) (round((X)/(Y))*(Y))\n\nfloat tonrmp(float time,float f1,float t1,float f2,float t2) {\n  t1=ROUNDTO(t1,f1);\n  t2=ROUNDTO(t2,f2);\n  return time<t1 ? f1 : \n    time<t2 ? f1+(f2-f1)*(time-t1)/(t2-t1)/2. :\n      f2;\n}\n\n// durations\n\n#define w 1.\n#define h .5\n#define q .25\n#define e .125\n#define x (e/2.)\n\n// 12-tone notes\n#define C D f f\n#define D E f f\n#define E F f\n#define F G f f\n#define G A f f\n#define A 440.\n#define B A s s\n#define X 0\n\n// octaves\n#define L * .5\n#define H * 2.\n\n// accidentals\n#define sh 1.05946\n#define fl 0.9438\n#define s * sh\n#define f * fl\n\n// -----------\n\n// A nod here to https://www.shadertoy.com/view/M32fzK - DerShade\n\nstruct GUIT {\n  float f1, f2, f3, f4, f5, f6;\n  float n1, n2, n3, n4, n5, n6;\n  float vol;\n  float fuz;\n  float vamt, vspd, whammy;\n  float tremspd, tremamt;\n};\n\n#define GUITini(G) \\\n  G.f1=G.f2=G.f3=G.f4=G.f5=G.f6=0.; \\\n  G.n1=G.n2=G.n3=G.n4=G.n5=G.n6=0.; \\\n  G.vol=1.; G.fuz=0.; \\\n  G.vamt=0.; G.vspd=1.; \\\n  G.tremspd = G.tremamt = 0.; \\\n  G.whammy=0.;\n\nfloat pow2n(float i,int n) { while ( --n > 0 ) i *= i; return i; }\n\n#define GNOTE(F,V,N) \\\n  (V) * clamp( SIN( TAU*(N)*(F)*1. + \\\n    (trb+pow2n(V,shp))*ndx * SIN( TAU*(N)*(F) \\\n    ) \\\n  ), fuzb, fuzc )\n\n//       * ( 1. - 1.*COS(TAU*N*1.) ) \\\n\n//#define GVOL(N) ( (N)-time <= 0. ? 0. : exp( -1. * ((N)-time) ) )\n#define GVOL(N) ( time-(N) <= 0. ? 0. : exp( -1. * (time-(N)) ) )\n\n//#define GVIB(N) ((N) /**(1.+g.vamt*SINC(TAU*(N)*g.vspd)+g.whammy) */)\n//#define GVIB(N) ((N-time)*(1.+g.vamt*SINC(TAU*(N)*g.vspd)))\n#define GVIB(N) ((time-N)*(1.+g.vamt*SINC(TAU*(N)*g.vspd)))\n\n//float gtime;\n\nfloat GuitSnd(GUIT g,float time) {\n  float o = 0.;\n  float v, n;\n  float fuzc = .6;\n  float fuzb = -1.9;\n  float trb = .24;\n  int shp = 5;\n  float ndx = 2.;\n  v = GVOL(g.n1);   n = GVIB(g.n1);   o += GNOTE(g.f1,v,n);\n  v = GVOL(g.n2);   n = GVIB(g.n2);   o += GNOTE(g.f2,v,n);\n  v = GVOL(g.n3);   n = GVIB(g.n3);   o += GNOTE(g.f3,v,n);\n  v = GVOL(g.n4);   n = GVIB(g.n4);   o += GNOTE(g.f4,v,n);\n  v = GVOL(g.n5);   n = GVIB(g.n5);   o += GNOTE(g.f5,v,n);\n  v = GVOL(g.n6);   n = GVIB(g.n6);   o += GNOTE(g.f6,v,n);\n  return clamp( o / 6. * (1.+g.fuz), -1., 1. ) * g.vol * ( 1. + g.tremamt * sin(TAU*g.tremspd*time) );\n}\n\n// finger placement on fret(less)board\n#define GFNG(G,a,b,c,d,e,f) G.f1=a; G.f2=b; G.f3=c; G.f4=d; G.f5=e; G.f6=f;\n\n// Fret numbers E A D G B E\n#define FRET(GT,a,b,c,d,e,f) \\\n  GT.f1=E L*pow(sh,float(a)); GT.f2=A L*pow(sh,float(b)); GT.f3=D  *pow(sh,float(c)); \\\n  GT.f4=G  *pow(sh,float(d)); GT.f5=B  *pow(sh,float(e)); GT.f6=E H*pow(sh,float(f));\n\n// strumming - downward\n#define GSTR(G,S) \\\n  G.n1=stime+(S)*0.; G.n2=stime+(S)*1.; G.n3=stime+(S)*2.; \\\n  G.n4=stime+(S)*3.; G.n5=stime+(S)*4.; G.n6=stime+(S)*5.;\n\n// strumming - upward\n#define GSTRU(G,S) \\\n  G.n1=stime+(S)*5.; G.n2=stime+(S)*4.; G.n3=stime+(S)*3.; \\\n  G.n4=stime+(S)*2.; G.n5=stime+(S)*1.; G.n6=stime+(S)*0.;\n  \nfloat hand=0.;\n\n// pluck string\n#define PLK1(G,F) G.f1=(F); G.n1=stime; hand=1.;\n#define PLK2(G,F) G.f2=(F); G.n2=stime; hand=2.;\n#define PLK3(G,F) G.f3=(F); G.n3=stime; hand=3.;\n#define PLK4(G,F) G.f4=(F); G.n4=stime; hand=4.; \n#define PLK5(G,F) G.f5=(F); G.n5=stime; hand=5.;\n#define PLK6(G,F) G.f6=(F); G.n6=stime; hand=6.;\n\n// new pitch\n#define BEND1(G,F) G.f1+=(F);\n#define BEND2(G,F) G.f2+=(F);\n#define BEND3(G,F) G.f3+=(F);\n#define BEND4(G,F) G.f4+=(F);\n#define BEND5(G,F) G.f5+=(F);\n#define BEND6(G,F) G.f6+=(F);\n\n// stop string\n#define STP1(G) G.n1=-1000.;\n#define STP2(G) G.n2=-1000.;\n#define STP3(G) G.n3=-1000.;\n#define STP4(G) G.n4=-1000.;\n#define STP5(G) G.n5=-1000.;\n#define STP6(G) G.n6=-1000.;\n\n#define STOP(G) G.n1=G.n2=G.n3=G.n4=G.n5=G.n6=-1000.;\n\n// ---------------------------------------\n\n#define TS (1.1/iSampleRate)\n\n// Trying animation sequencing tools for sound ...\n#define STRT(tt) (tt=<TS)\n\n#define AFTER(T,CODE) if ( tim >= (T) ) { tim-=(T); CODE; tim+=(T); }\n\n#define WHEN(T,CODE) if ( tim >= 0. && tim < (T) ) { CODE; }\n\n//#define FOR(T,CODE) WHEN(T,CODE) tim -= (T);\n\n#define FOR(T,CODE) if ( tim >= 0. ) { stime = time - tim; CODE; } tim -= (T); \n\t\t\t\t\t\t\t\t\t\n//#define REPEAT(DUR,CNT) \\\n//  if ( tim >= 0. && tim < (DUR)*((CNT)-1.) ) tim = mod(tim,DUR); \\\n//  else tim -= (DUR)*((CNT)-1.);\n\n\n#define REPEAT(TIME,CNT) \\\n  if ( tim >= 0. && tim < (TIME)*((CNT)) ) { iter=floor(tim/TIME); tim = mod(tim,TIME); } \\\n  else tim -= (TIME)*((CNT));\n\n//#define REPEAT(TIME,CNT) \\\n//  if ( tim >= 0. ) { if ( tim < (TIME)*((CNT)) ) { iter=floor(tim/TIME); tim = mod(tim,TIME); } } \\\n//  else tim -= (TIME)*((CNT));\n\n#define REPEAT2(TIME,CNT,CODE) \\\n  if ( tim > 0. ) { if ( tim < (TIME)*((CNT)-1.) ) tim = mod(tim,TIME); } \\\n  else tim -= (TIME)*((CNT)-1.);\n\n  \n#define CHANGE(CODE) if ( tim >= 0. ) { CODE; }\n\n// ---------------------------------------\n\nfloat guit(float time) {\n\n  float tim = time;\n  float stime = 0.;\n  float iter = 1.;\n\n  GUIT g1;\n  GUITini(g1);\n  \n  CHANGE(g1.fuz=0.;g1.vol=3.;)\n\n#define STRUM(G,a,b,c,d,e,f,T,S,EX) \\\n  FOR(T, \\\n    GFNG(G,a,b,c,d,e,f); \\\n    GSTR(G,S); \\\n    EX; \\\n  )\n\n//     E A D G B E\n\n  //REPEAT(q,1000.)\n  //float shf=1.+SINC(time*123.); // pow(mod(iter*5.,12.),1. s / 12.) L;\n  //STRUM(g1, G*shf L,B*shf L,D*shf,G*shf,B*shf,G*shf,  q,x/4.,)\n  //STRUM(g1, E L,C,E,G,C H,E H, w,x*.5,)\n\n  //if ( mod(time,64.) > 32. )\n  {\n    g1.tremamt = .25;\n    g1.tremspd = 10.;\n  }\n\n\n/*\n  if ( mod(time,64.) > 32. )\n  {\n    g1.vamt=.015;//.03-.03*cos(TAU*time/8.);\n    g1.vspd=8.;//1.3+.3*SINC(TAU*time/16.);\n  }\n  //g1.whammy=-.5*smoothstep(30.,32.,mod(time*4.,32.));\n*/  \n\n  REPEAT(w*2.,1000.)\n  //REPEAT(w*2.,8.);\n  float shf = mod(iter,8.) > 5. ? 3./4. : 1.;\n  shf *= float[](1.,sh s,3./4.,3./4. s s s)[ int(floor(iter/32.)) % 4 ];\n  FOR(w*2.,\n    GFNG(g1,E L*shf,A L*shf,D*shf,G*shf,B*shf,E H*shf);\n    FOR(q*6., GSTR(g1,q); )\n    FOR(q,)\n    FOR(e, GSTR(g1,0.); )\n    FOR(e, GSTR(g1,0.); g1.vol *= 1.5; )\n  )\n\n  return GuitSnd(g1,time);\n\n}\n\n// ------------ Solo -------------------\n\nfloat Gsolo(float time) {\n\n  float tim = time;\n  float stime = 0.;\n  float iter = 1.;\n\n  GUIT g1;\n  GUITini(g1);\n\n  CHANGE(g1.fuz=10.;g1.vol=.2;)\n\n  //REPEAT(w*3.,1000.)\n#define XX 1e-7  \n#define Ochord FRET(g1,0,0,0,0,0,0)\n#define Emchord FRET(g1,0,2,2,0,0,0)\n#define Echord FRET(g1,0,2,2,1,0,0)\n#define Amchord FRET(g1,0,0,2,2,1,0)\n#define Cchord FRET(g1,0,3,2,0,1,0)\n#define Achord FRET(g1,0,0,2,2,2,0)\n#define Gchord FRET(g1,3,2,0,0,0,3)\n#define Dchord FRET(g1,XX,XX,0,2,3,2)\n#define Dmchord FRET(g1,XX,XX,0,2,3,1)\n#define E7chord FRET(g1,0,2,0,1,0,0)\n#define D7chord FRET(g1,XX,XX,0,2,1,2)\n#define A7chord FRET(g1,0,0,2,0,2,0)\n#define C7chord FRET(g1,0,3,2,3,1,0)\n\n  \n  FOR(w+w,)\n  //REPEAT(h,2.)\n  FOR(h, Cchord GSTR(g1,x/2.) )\n  FOR(h, Gchord GSTR(g1,x/2.) )\n  FOR(h, Achord GSTR(g1,x/2.) )\n  FOR(h, Dchord GSTR(g1,x/4.) )\n  FOR(h, Gchord GSTR(g1,x/4.) )\n  FOR(w, Cchord GSTR(g1,x/4.) )\n  FOR(w, Achord GSTR(g1,x/4.) )\n  FOR(q, Echord GSTR(g1,x/4.) )\n  FOR(q,  WHEN(h,time = stime+tim/(1.+sin(tim/w*PI/1.5)*.2);) )\n  FOR(h, time *= 1.+.03*SINC(TAU*time*5.))\n  FOR(w, Echord GSTRU(g1,x/4.) )\n  /*\n  FOR(q+h,)\n  REPEAT(w,4.)  \n  FOR(w, Echord GSTR(g1,x/4.) )\n  */\n  FOR(w,)\n\n\n/*\nREPEAT(w+w,100.)\n\n  FOR(q,PLUCK1(g1,E L))\n  FOR(q,PLUCK2(g1,A L))\n  FOR(q,PLUCK3(g1,D))\n  FOR(q,PLUCK4(g1,G))\n  FOR(q,PLUCK5(g1,B))\n  FOR(q,PLUCK6(g1,E H))\n  FOR(w*20.,)\n  */\n  \n/*  \n  FOR(w*4.,\n    GFNG(g1,E L,A L,D*1.23,G,B,E H);\n    GSTR(g1,w/8.);\n    //AFTER(w*2., PLUCK3(g1,D*1.2) );\n    AFTER(w*2.+q, BEND3(g1,D*1.15) );\n    AFTER(w*2.+q*2., BEND3(g1,D*1.1) );\n    AFTER(w*2.+q*3., BEND3(g1,D*1.) );\n    AFTER(w*3., GSTR(g1,w/8.); )\n    )\n*/    \n\n/*\nFOR(q, PLUCK3(D*1.07) );\n  FOR(q, PLUCK3(D*1.05) );\n  FOR(q, PLUCK3(D*1.03) );\n  FOR(q, PLUCK3(D*1.00) );\n*/\n  \n  return GuitSnd(g1,time);\n\n\n}\n\n\n\n// ------------\n\n#define Vibro(S,L,A,R) \\\n  if(time>S&&time<S+L) \\\n    time+=A*SINC(time*R);\n\n#define Lupo(S,L,R) if(time>S) \\\n  if(time<S+L) time=S+mod(time,R); \\\n  else time -= S+L;\n\n#define REVERSE(START,LENG) \\\n  if ( time >= START && time < START+LENG ) \\\n    time = 2.*START+LENG-time;\n\n#define REWIND4X(START,LENG) \\\n  if ( time >= START && time < START+LENG ) \\\n    time = START-(time-START)*4.;\n\n\n#define INSERT(START,LENG,CODE) \\\n  if ( time >= START ) if ( time < START+LENG ) { CODE; } else time -= LENG;\n\n/*\nfloat rndq(float i) {\n  return fract( 123.535-23.654*fract(i*535.646));\n}\n\nvec2 Echo(float time) {\n    float snd = 0.;\n    float dly = 0.;\n    for ( int xx = 0; xx < 100; ++xx ) {\n      float tt = time - dly; //1./32.*float(xx);\n      if ( tt >= 0. ) snd += .2 * guit(tt) / pow( float(xx+1), 1.1 );\n         // * exp( -1. * float(xx+1) )\n    }\n      //return vec2( snd / 10000. );\n    return vec2(snd/1.);\n}\n*/\n\n// ------------\n\n\nvec2 mainSound( int samp, float time )\n{\n\n    //gtime = time;\n    \n    float vc = 0.;\n    \n    if ( time < 8.*w)\n      return vec2( .3*Gsolo(time));\n    time -= 8.*w;\n/*    \n    if ( time < 4.*w )\n      return vec2( tonnos(time, mod(time,h)>q?16000.:1000.) * rhyt(time,q,0.,e*.7) );\n    time -= 4.*w;\n*/    \n   // if (time>150.) return vec2(0);\n    \n    REWIND4X(130.,8.)\n\n    if ( mod(time,64.) > 32. )\n      time+=.0006*SIN(TAU*time*5.);\n\n\n\n   \n //Lupo(8.,8.,(1./8.))\n \n //Vibro(8.,32.,.001,1.)\n \n    //INSERT(0.,800.,return Echo(time);)\n  //  REVERSE(24.,16.)\n\n    \n    float xtime = time ;//- 48.;\n    if ( xtime > 0.) {\n        float yy=0.;  \n        if ( xtime > 8.*1. )\n        yy += tonnos(xtime, noisei(int(xtime/e)) > .5 ? 16000. : 2000.) * rhyt(xtime,e,0.,x*.7);\n        if ( xtime > 8.*0. ) {\n        yy += .8*tonnos(xtime, noisei(1+int(xtime/h)) > .5 ? 400. : 8000.) * rhyt(xtime,q,0.,x);\n        if ( xtime > 8.*2. ) {\n        yy += tonnos(xtime, stair(ramp(xtime+2.,w*2.,20000.,120.),2000.)) * rhyt(xtime,h,0.,q);\n        yy += sin(mod(time*TAU*12000.,TAU)) * rhyt(xtime,w,q+q+q,e);\n        if ( xtime > 8.*3. ) {\n\n        \n \n        xtime=mod(xtime,1.);\n        float fc = 880.;\n        float fc1=fc * (1. + SINC(xtime*40.)*.03*note(time,w*4.,0.,h,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc2=fc * (1. + SINC(xtime*30.)*.03*note(time,w*4.,0.,w,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        float fc3=fc * (1. + SINC(xtime*35.)*.03*note(time,w*4.,0.,h+q,q,h)); // RND0(50.,800.,int(time/4.)); // 110.;//floor(2.+6.*noisei(int(time/w)))*55.;\n        yy += .25*voiceN3( xtime,\n                  fc1, fc2*5./4., fc3*1.5,\n                  RND0(200.,1200.,int(time/4.)), //tonnos(time,1./w/8.)*1000.+250.,\n                  4., 3.,\n                  RND0(1200.,4800.,int(time/4.)), //tonnos(time+.1,1./w/8.)*3000.+350.,\n                  4., 3.)\n               * note(time,w*4.,q,q,h,q);\n               \n        } } }\n        vc = mix(vc,yy,1.);//clamp(0.,1.,(time-48.)/6.));\n    }\n\n    if ( time > 64. ) { // woof\n    float sw = PI * rampa(0.,.05,mod(time*.5,1.));\n    if ( noisei(3+int(time/h)) > .5 )\n    vc += .3 * sin(sw) * SIN(TAU*50.*cos(sw)) ;\n    sw = PI * rampa(0.,.05,mod((time+q)*.5,1.));\n    vc += .3 * sin(sw) * SIN(TAU*50.*cos(sw)) ;\n    }\n    \n    //vc *= .6;\n    vc += guit(time);\n    \n    return .15*vec2(vc);\n}\n","name":"Sound","description":"","type":"sound"}]}