{"ver":"0.1","info":{"id":"4lGyRc","date":"1537279078","viewed":106,"name":"CUBE_shadow","username":"Nikipit","description":"cube","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 getEq(vec3 t1, vec3 t2, vec3 t3)\n{\n    vec4 res;\n    //A\n    res.x = t1.y*(t2.z-t3.z) + t2.y*(t3.z-t1.z) + t3.y*(t1.z-t2.z);\n    //B\n    res.y = t1.z*(t2.x-t3.x) + t2.z*(t3.x-t1.x) + t3.z*(t1.x-t2.x);\n    //C\n    res.z = t1.x*(t2.y-t3.y) + t2.x*(t3.y-t1.y) + t3.x*(t1.y-t2.y);\n    //D\n    res.w = 0.0 - t1.x*(t2.y*t3.z-t3.y*t2.z) - t2.x*(t3.y*t1.z-t1.y*t3.z) - t3.x*(t1.y*t2.z-t2.y*t1.z);\n    return res;\n}\n\nstruct triangle\n{\n    vec3 A; vec2 At;\n    vec3 B; vec2 Bt;\n    vec3 C; vec2 Ct;\n    int textId;\n};\n    \ntriangle triangles[14];\n\nvoid create_triangles()\n{\n    vec3 v1 = vec3(0.5,-0.5,1);\n    vec3 v2 = vec3(-0.5,-0.5,1);\n    vec3 v3 = vec3(-0.5,0.5,1);\n    vec3 v4 = vec3(0.5,0.5,1);\n    vec3 v5 = vec3(0.5,-0.5,0);\n    vec3 v6 = vec3(-0.5,-0.5,0);\n    vec3 v7 = vec3(-0.5,0.5,0);\n    vec3 v8 = vec3(0.5,0.5,0);\n    \n    \n    //задаем вершины\n    triangles[0].A = v1;\n    triangles[0].B = v2;\n    triangles[0].C = v3;\n    triangles[0].At = vec2(0.25,0.5);\n    triangles[0].Bt = vec2(0.25,0.25);\n    triangles[0].Ct = vec2(0.5,0.25);\n    triangles[0].textId = 1;\n    \n    triangles[1].A = v1;\n    triangles[1].B = v3;\n    triangles[1].C = v4;\n    triangles[1].At = vec2(0.25,0.5);\n    triangles[1].Bt = vec2(0.5,0.25);\n    triangles[1].Ct = vec2(0.5,0.5);\n    triangles[1].textId = 1;\n    \n    triangles[2].A = v2;\n    triangles[2].B = v6;\n    triangles[2].C = v7;\n    triangles[2].At = vec2(0.25,0.25);\n    triangles[2].Bt = vec2(0.25,0);\n    triangles[2].Ct = vec2(0.5,0);\n    triangles[2].textId = 1;\n    \n    triangles[3].A = v2;\n    triangles[3].B = v7;\n    triangles[3].C = v3;\n    triangles[3].At = vec2(0.25,0.25);\n    triangles[3].Bt = vec2(0.5,0);\n    triangles[3].Ct = vec2(0.5,0.25);\n    triangles[3].textId = 1;\n    \n    triangles[4].A = v5;\n    triangles[4].B = v1;\n    triangles[4].C = v4;\n    triangles[4].At = vec2(0.25,0.75);\n    triangles[4].Bt = vec2(0.25,0.5);\n    triangles[4].Ct = vec2(0.5,0.5);\n    triangles[4].textId = 1;\n    \n    triangles[5].A = v5;\n    triangles[5].B = v4;\n    triangles[5].C = v8;\n    triangles[5].At = vec2(0.25,0.75);\n    triangles[5].Bt = vec2(0.5,0.5);\n    triangles[5].Ct = vec2(0.5,0.75);\n    triangles[5].textId = 1;\n    \n    triangles[6].A = v5;\n    triangles[6].B = v6;\n    triangles[6].C = v2;\n    triangles[6].At = vec2(0,0.5);\n    triangles[6].Bt = vec2(0,0.25);\n    triangles[6].Ct = vec2(0.25,0.25);\n    triangles[6].textId = 1;\n    \n    triangles[7].A = v5;\n    triangles[7].B = v2;\n    triangles[7].C = v1;\n    triangles[7].At = vec2(0,0.5);\n    triangles[7].Bt = vec2(0.25,0.25);\n    triangles[7].Ct = vec2(0.25,0.5);\n    triangles[7].textId = 1;\n    \n    triangles[8].A = v4;\n    triangles[8].B = v3;\n    triangles[8].C = v7;\n    triangles[8].At = vec2(0.5,0.5);\n    triangles[8].Bt = vec2(0.5,0.25);\n    triangles[8].Ct = vec2(0.75,0.25);\n    triangles[8].textId = 1;\n   \n    triangles[9].A = v4;\n    triangles[9].B = v7;\n    triangles[9].C = v8;\n    triangles[9].At = vec2(0.5,0.5);\n    triangles[9].Bt = vec2(0.75,0.25);\n    triangles[9].Ct = vec2(0.75,0.5);\n    triangles[9].textId = 1;\n    \n    triangles[10].A = vec3(-4,-4,0);\n    triangles[10].B = vec3(-4,4,0);\n    triangles[10].C = vec3(4,4,0);\n    triangles[10].At = vec2(0,0);\n    triangles[10].Bt = vec2(0,1);\n    triangles[10].Ct = vec2(1,1);\n    triangles[10].textId = 0;\n    \n    triangles[11].A = vec3(-4,-4,0);\n    triangles[11].B = vec3(4,4,0);\n    triangles[11].C = vec3(4,-4,0);\n    triangles[11].At = vec2(0,0);\n    triangles[11].Bt = vec2(1,1);\n    triangles[11].Ct = vec2(1,0);\n    triangles[11].textId = 0;\n}\n\n//пересечение с треугольником\nvec3 triangle_intersection(vec3 orig, vec3 dir, vec3 v0, vec3 v1, vec3 v2) \n{\n    vec3 result = vec3(0,0,0);\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    \n    vec3 pvec = cross(dir, e2);\n    float det = dot(e1, pvec);\n\n    if (det < 1e-8 && det > -1e-8) {\n\n        return result;\n    }\n\n    float inv_det = 1.0 / det;\n    vec3 tvec = orig - v0;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) {\n        return result;\n    }\n\n    vec3 qvec = cross(tvec, e1);\n    float v = dot(dir, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) {\n        return result;\n    }\n    result[0] = dot(e2, qvec) * inv_det;\n    result[1] = u;\n    result[2] = v;\n    return result;     \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //вычисляем вектор камеры для рендера\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 cam = normalize(vec3((uv.x - 0.5)* iResolution.x / iResolution.y, uv.y - 0.5, -2.0));\n    //vec3 orig = vec3(sin(iTime) * 5.0, cos(iTime) * 5.0, 3.0);\n    //vec3 dir = vec3(sin(iTime) * 1.0,cos(iTime) * 1.0, 1.0);\n    \n    vec3 orig = vec3(5.0, 0.0, 3.0);\n    vec3 dir = vec3(1.0,0.0, 1.0);\n    \n    vec3 d0 = vec3(0,0,3.0);\n    \n    vec3 z1 = normalize(vec3(orig - dir));\n    vec3 y1 = normalize(vec3(d0 - dir));\n    vec3 x1 = normalize(cross(z1, y1));\n    \n    vec3 cam2;\n    cam2.x = cam.x * x1.x + cam.y * y1.x + cam.z * z1.x;\n    cam2.y = cam.x * x1.y + cam.y * y1.y + cam.z * z1.y;\n    cam2.z = cam.x * x1.z + cam.y * y1.z + cam.z * z1.z;\n    \n    vec3 l = vec3(cos(iTime/4.0*3.0)*1.5, sin(iTime/4.0*3.0)*1.5, 1.5);\n    \n    create_triangles();\n    \n    //трасируем лучи!!!\n    float tmin = 99999.0;\n    \n    vec4 texColor;\n    \n    vec3 P;\n    \n    vec4 vnor;\n    \n    for( int i=0; i<12; i++ )\n    {\n        vec3 t = triangle_intersection(orig, cam2, triangles[i].A, triangles[i].B, triangles[i].C);\n        if(t[0] > 0.0 && t[0] < tmin)\n        {\n            vec2 xy;\n            xy.x = t[1]* triangles[i].Bt.x + t[2]* triangles[i].Ct.x + (1.0-t[1]-t[2])* triangles[i].At.x;\n            xy.y = t[1]* triangles[i].Bt.y + t[2]* triangles[i].Ct.y + (1.0-t[1]-t[2])* triangles[i].At.y;\n\n            switch (triangles[i].textId)\n            {\n            case 0: \n            \ttexColor = texture(iChannel0,xy);\n               \tbreak;\n            case 1: \n            \ttexColor = texture(iChannel1,xy);\n               \tbreak;\n            case 2:\n                texColor = vec4(0.8, 0.8, 0.8, 1);\n                break;\n            case 3:\n                texColor = vec4(1, 1, 1, 1);\n                break;\n\t\t\t}\n            tmin = t[0];\n            // Расчет света\n            \n            vnor = normalize(getEq(triangles[i].A, triangles[i].B, triangles[i].C));\n            \n            P.x = t[1]* triangles[i].B.x + t[2]* triangles[i].C.x + (1.0-t[1]-t[2])* triangles[i].A.x;\n            P.y = t[1]* triangles[i].B.y + t[2]* triangles[i].C.y + (1.0-t[1]-t[2])* triangles[i].A.y;\n            P.z = t[1]* triangles[i].B.z + t[2]* triangles[i].C.z + (1.0-t[1]-t[2])* triangles[i].A.z;\n            \n           \t\n        }  \n    }\n    \n    vnor.w = 1.0;\n    \n    float shangle = (vnor.x * (l.x-P.x) + vnor.y * (l.y-P.y) + vnor.z * (l.z-P.z)) / \n        (\n            \tsqrt(pow(vnor.x, 2.0) + pow(vnor.y, 2.0) + pow(vnor.z, 2.0)) \n         \t\t* \n            \tsqrt(pow(l.x-P.x, 2.0) + pow(l.y-P.y, 2.0) + pow(l.z-P.z, 2.0))\n         );\n         \n         \n    float lp = sqrt(pow(l.x-P.x, 2.0)+pow(l.y-P.y, 2.0)+pow(l.z-P.z, 2.0));\n    float isl = lp;\n    \n    for( int il=0; il<12; il++ )\n    {\n        vec3 LL = triangle_intersection(l, normalize(vec3(P-l)), triangles[il].A, triangles[il].B, triangles[il].C);\n        if(LL[0] < isl && LL[0] != 0.0)\n        {\n            isl = LL[0];\n        }\n    }\n    //\n    \n    // чем ближе - тем ярче\n    //texColor = texColor / lp * 3.0;\n    \n    // тень от близкого источника\n    shangle = 0.25 + (0.0 - shangle) / 4.0 * 3.0 ; \n    \n    if(isl + 1e-3 < lp)\n    {\n        texColor.x *= 0.25;\n        texColor.y *= 0.25;\n        texColor.z *= 0.25;\n    }\n    else\n    {\n        texColor.x *= shangle;\n        texColor.y *= shangle;\n        texColor.z *= shangle;\n    }\n    \n    fragColor = texColor;\n}","name":"Image","description":"","type":"image"}]}