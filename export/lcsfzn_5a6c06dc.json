{"ver":"0.1","info":{"id":"lcsfzn","date":"1723274979","viewed":146,"name":"pool room 1","username":"woksan","description":"Some hacked together ray marching stuff. Experimenting with water refraction.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","water"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define SENSITIVITY 0.5\n\n#define M_PI 3.14159265358979323846264338327950288\n#define TILE 8.0\n\n#define MIN_DISTANCE 0.01\n#define MAX_DISTANCE 1000.0\n#define NUM_STEPS 64\n#define PI 3.14159265359\n\nfloat cube(vec3 p, vec3 o, vec3 s)\n{\n  vec3 d = abs(p - o) - s;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat plane(vec3 p, vec3 n, float d)\n{\n  return dot(p, n) - d;\n}\n\nfloat map(vec3 p)\n{\n  return (\n    min(cube(p, vec3(0.0, -1.0, 0.0), vec3(0.5, 1.0, 3.0)),\n    min(cube(p, vec3(-2.0, 0.0, 5.0), vec3(0.5, 4.0, 0.5)),\n    min(cube(p, vec3(+2.0, 0.0, 5.0), vec3(0.5, 4.0, 0.5)),\n    min(cube(p, vec3(0.0, 4.0, 10.0), vec3(5.5, 4.0, 4.0)),\n    min(plane(p, vec3(0.0, 0.0, 1.0), -0.5),\n    min(plane(p, vec3(0.0, 0.0, -1.0), -9.5),\n    min(plane(p, vec3(1.0, 0.0, 0.0), -4.0),\n    min(plane(p, vec3(-1.0, 0.0, 0.0), -4.0),\n    min(plane(p, vec3(0.0, 1.0, 0.0), -1.0),\n    plane(p, vec3(0.0, -1.0, 0.0), -4.0)\n  ))))))))));\n}\n\nvec3 get_axis(vec3 N)\n{\n  if (abs(N.y) > abs(N.x) && abs(N.y) > abs(N.z)) {\n    return vec3(0, 0, 1);\n  } else {\n    return vec3(0, 1, 0);\n  }\n}\n\nmat3 map_TBN(vec3 p)\n{\n  float dp = 0.001;\n  float d = map(p);\n  float dx = map(p + vec3(dp, 0.0, 0.0));\n  float dy = map(p + vec3(0.0, dp, 0.0));\n  float dz = map(p + vec3(0.0, 0.0, dp));\n  \n  vec3 N = normalize(vec3(dx, dy, dz) - d);\n  vec3 a = get_axis(N);\n  vec3 B = normalize(cross(N, a));\n  vec3 T = normalize(cross(N, B));\n  \n  return mat3(T, B, N);\n}\n\nfloat shadow(vec3 pt, vec3 rd, float ld)\n{\n  vec3 p = pt;\n  float td = MIN_DISTANCE;\n  float kd = 1.0;\n  \n  for (int i = 0; i < NUM_STEPS && kd > 0.001; i++) {\n    p = pt + rd * td;\n    \n    float d = map(p);\n    \n    if (td > MAX_DISTANCE || td + d > ld) break;\n    if (d < 0.001) kd = 0.0;\n    else kd = min(kd, 16.0 * d / td);\n    \n    td += d;\n  }\n  \n  return kd;\n}\n\nfloat ray_march(vec3 ro, vec3 rd)\n{\n  float td = 0.0;\n  \n  for (int i = 0; i < NUM_STEPS; i++) {\n    vec3 p = ro + rd * td;\n    \n    float d = map(p);\n    \n    if (d < MIN_DISTANCE) return td;\n    if (td > MAX_DISTANCE) break;\n    \n    td += d;\n  }\n  \n  return 0.0;\n}\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n  return F0 + (1.0 - F0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n  float a      = roughness*roughness;\n  float a2     = a*a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH*NdotH;\n\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n  float r = (roughness + 1.0);\n  float k = (r*r) / 8.0;\n\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nvec3 brdf(vec3 albedo, float metallic, float roughness, vec3 L, vec3 V, vec3 N)\n{\n  vec3 H = normalize(L + V);\n  \n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, albedo, metallic);\n  \n  float NDF = DistributionGGX(N, H, roughness);\n  float G   = GeometrySmith(N, V, L, roughness);\n  vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);\n  \n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - metallic;\n  \n  vec3 numerator    = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n  vec3 specular     = numerator / denominator;\n      \n  float NdotL = max(dot(N, L), 0.0);\n  return (kD * albedo / PI + specular) * NdotL;\n}\n\nvec3 light_pos[] = vec3[](\n  vec3(2.0, 2.0, 3.0),\n  vec3(-2.0, 2.0, 3.0)\n);\n\nvec3 light_color[] = vec3[](\n  vec3(0.5, 1.0, 1.0) * 8.0,\n  vec3(1.0, 0.5, 1.0) * 8.0\n);\n\n#define NUM_LIGHT 2\n\nvec3 calc_point_scatter(vec3 frag_pos, vec3 view_pos)\n{\n  vec3 light = vec3(0.0);\n  \n  for (int i = 0; i < NUM_LIGHT; i++) {\n    vec3 delta_pos = light_pos[i] - frag_pos;\n    vec3 light_dir = normalize(delta_pos);\n    \n    vec3 view_dir = normalize(frag_pos - view_pos);\n    \n    vec3 dir = normalize(light_dir - view_dir * dot(light_dir, view_dir));\n    float h = dot(light_pos[i], dir) - dot(view_pos, dir);\n    float c = dot(light_pos[i], view_dir);\n    float a = dot(view_pos, view_dir) - c;\n    float b = dot(frag_pos, view_dir) - c;\n    float fog = atan(b / h) / h - atan(a / h) / h;\n    \n    light += (0.001 * fog * fog + 0.001 * fog) * light_color[i];\n  }\n  \n  return light;\n}\n\nvec3 calc_point_lighting(vec3 p, vec3 V, vec3 N, vec3 albedo, float metallic, float roughness)\n{\n  vec3 light = vec3(0.0);\n  \n  for (int i = 0; i < NUM_LIGHT; i++) {\n    vec3 L = normalize(light_pos[i] - p);\n    float distance = length(light_pos[i] - p);\n    \n    float attenuation = 1.0 / (distance * distance);\n    vec3 radiance = light_color[i] * attenuation * shadow(p, L, distance);\n    \n    light += brdf(albedo, metallic, roughness, L, V, N) * radiance;\n  }\n  \n  return light;\n}\n\nfloat rand(vec2 co){\n  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec3 get_albedo(vec2 uv)\n{\n  return vec3(1.0 - rand(floor(uv * TILE * 2.0)) * 0.1);\n  float alpha = 0.0;\n  \n  if (fract(uv.y * TILE) > 0.5) {\n    alpha = (fract(uv.x * TILE) > 0.5 ? 1.0 : 0.95);\n  } else {\n    alpha = (fract(uv.x * TILE) < 0.5 ? 1.0 : 0.95);\n  }\n  \n  return vec3(alpha);\n}\n\nfloat get_roughness(vec2 uv)\n{\n  float alpha = 0.0;\n  \n  if (fract(uv.y * TILE) > 0.5) {\n    alpha = (fract(uv.x * TILE) > 0.5 ? 0.7 : 0.5);\n  } else {\n    alpha = (fract(uv.x * TILE) < 0.5 ? 0.7 : 0.5);\n  }\n  \n  return 1.0 - alpha;\n}\n\nfloat get_height(vec2 uv)\n{\n  float alpha = 0.0;\n  alpha += min(cos((uv.x * TILE * 4.0 + 1.0) * M_PI) + 0.95, 0.0);\n  alpha += min(cos((uv.y * TILE * 4.0 + 1.0) * M_PI) + 0.95, 0.0);\n  return alpha;\n}\n\nvec3 get_normal(vec2 uv)\n{\n  float u = get_height(uv);\n  float du_x = get_height(uv + vec2(0.001, 0.0)) - u;\n  float du_y = get_height(uv + vec2(0.0, 0.001)) - u;\n  float s = 0.05;\n  return normalize(cross(vec3(s, 0.0, du_x), vec3(0.0, s, du_y)));\n}\n\nfloat f(vec3 p)\n{\n  float y = -0.5;\n  \n  y += cos((length(p.xz - vec2(10.0, 10.0)) + iTime * 1.0) * 6.0) * 0.015;\n  y += cos((length(p.xz - vec2(-10.0, 10.0)) + iTime * 1.5) * 5.0) * 0.015;\n  y += cos((length(p.xz - vec2(0.0, -10.0)) + iTime * 0.2) * 4.0) * 0.025;\n  \n  return y;\n}\n\nfloat water_map(vec3 p)\n{\n  return p.y - f(p);\n}\n\nfloat water_ray_march(vec3 ro, vec3 rd)\n{\n  float td = 0.0;\n  \n  for (int i = 0; i < NUM_STEPS; i++) {\n    vec3 p = ro + rd * td;\n    \n    float d = water_map(p);\n    \n    if (d < MIN_DISTANCE) return td;\n    if (td > MAX_DISTANCE) break;\n    \n    td += d;\n  }\n  \n  return 0.0;\n}\n\nvec3 water_map_normal(vec3 p)\n{\n  float dp = 0.01;\n  float d = water_map(p);\n  float dx = water_map(p + vec3(dp, 0.0, 0.0));\n  float dy = water_map(p + vec3(0.0, dp, 0.0));\n  float dz = water_map(p + vec3(0.0, 0.0, dp));\n  \n  return normalize(vec3(dx, dy, dz) - d);\n}\n\nmat4 x_rot(float t)\n{\n  return mat4(\n    vec4(1.0, 0.0, 0.0, 0.0),\n    vec4(0.0, cos(t), -sin(t), 0.0),\n    vec4(0.0, sin(t), cos(t), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  );\n}\n\nmat4 y_rot(float t)\n{\n  return mat4(\n    vec4(cos(t), 0.0, -sin(t), 0.0),\n    vec4(0.0, 1.0, 0.0, 0.0),\n    vec4(sin(t), 0.0, cos(t), 0.0),\n    vec4(0.0, 0.0, 0.0, 1.0)\n  );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  \n  vec2 m = abs(iMouse.xy) / iResolution.xy * 2.0 - 1.0;\n  m.x *= iResolution.x / iResolution.y;\n  \n  vec3 view_pos = vec3(0.0, 1.0, 1.0);\n  mat4 view_mat = mat4(1.0) * y_rot(m.x * SENSITIVITY) * x_rot(m.y * SENSITIVITY);\n  \n  vec3 rd = normalize(vec3(view_mat * vec4(uv, 1.0, 1.0)));\n  float td = ray_march(view_pos, rd);\n  float water_td = water_ray_march(view_pos, rd);\n  \n  vec3 p;\n  vec3 frag_N;\n  vec3 frag_V;\n  vec3 frag_albedo;\n  float frag_metallic;\n  float frag_roughness;\n  vec3 light = vec3(0.0);\n  \n  const float tex_scale = 0.35;\n  \n  if (water_td > 0.0 && water_td < td) {\n    p = view_pos + rd * water_td;\n    frag_N = water_map_normal(p);\n    frag_V = normalize(view_pos - p);\n    vec3 frag_R = refract(-frag_V, frag_N, 1.0 / 1.33);\n    \n    td = ray_march(p, frag_R);\n    vec3 q = p + frag_R * td;\n    \n    mat3 q_TBN = map_TBN(q);\n    vec2 q_uv = (inverse(q_TBN) * q).xy * tex_scale;\n    vec3 q_N = normalize(q_TBN * get_normal(q_uv));\n    vec3 q_V = normalize(view_pos - q);\n    \n    vec3 albedo = get_albedo(q_uv);\n    float metallic = 0.1;\n    float roughness = get_roughness(q_uv);\n    \n    light += calc_point_lighting(q, q_V, q_N, albedo, metallic, roughness);\n    frag_albedo = vec3(0.1, 0.4, 0.5);\n    frag_metallic = 0.01;\n    frag_roughness = 0.3;\n  } else {\n    p = view_pos + rd * td;\n    \n    mat3 frag_TBN = map_TBN(p);\n    vec2 frag_uv = (inverse(frag_TBN) * p).xy * tex_scale;\n    frag_N = normalize(frag_TBN * get_normal(frag_uv));\n    frag_V = normalize(view_pos - p);\n    \n    frag_albedo = get_albedo(frag_uv);\n    frag_metallic = 0.01;\n    frag_roughness = get_roughness(frag_uv);\n  }\n  \n  light += calc_point_lighting(p, frag_V, frag_N, frag_albedo, frag_metallic, frag_roughness);\n  \n  vec3 frag_R = reflect(-frag_V, frag_N);\n  td = ray_march(p + 0.01 * frag_R, frag_R);\n  vec3 q = p + frag_R * td;\n  \n  mat3 q_TBN = map_TBN(q);\n  vec2 q_uv = (inverse(q_TBN) * q).xy * tex_scale;\n  vec3 q_N = normalize(q_TBN * get_normal(q_uv));\n  vec3 q_V = normalize(view_pos - q);\n  vec3 q_L = normalize(q - p);\n  \n  vec3 q_albedo = get_albedo(q_uv);\n  float q_metallic = 0.01;\n  float q_roughness = get_roughness(q_uv);\n  light += (\n    brdf(frag_albedo, frag_metallic, frag_roughness, q_L, frag_V, frag_N) *\n    calc_point_lighting(q, q_V, q_N, q_albedo, q_metallic, q_roughness) * (1.0 - frag_roughness) * 0.15\n  );\n  \n  light += calc_point_scatter(p, view_pos);\n  \n  const float gamma = 0.5;\n  const float exposure = 3.1;\n  \n  vec3 color = light;\n  color = vec3(1.0) - exp(-color * exposure);\n  color = pow(color, vec3(1.0 / gamma));\n  \n  fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}