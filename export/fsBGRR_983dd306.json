{"ver":"0.1","info":{"id":"fsBGRR","date":"1616786009","viewed":440,"name":"montecarlo denoise test","username":"dysangel","description":"Fork of https://www.shadertoy.com/view/lsy3WW\n\nThis is one of my first attempts at using GLSL. Attempt to do realtime monte carlo rendering with less noise by using gaussian blur on surfaces","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["3d","reflection","refraction","antialias","pathtracing","montecarlo"],"hasliked":0,"parentid":"lsy3WW","parentname":"glsl smallpt smooth"},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*\n\nThis shader is an attempt at porting smallpt to GLSL.\n\nSee what it's all about here:\nhttp://www.kevinbeason.com/smallpt/\n\nThe code is based in particular on the slides by David Cline.\n\nSome differences:\n\n- For optimization purposes, the code considers there is\n  only one light source (see the commented loop)\n- Russian roulette and tent filter are not implemented\n\nI spent quite some time pulling my hair over inconsistent\nbehavior between Chrome and Firefox, Angle and native. I\nexpect many GLSL related bugs to be lurking, on top of\nimplementation errors. Please Let me know if you find any.\n\n--\nZavie\n\n*/\n\n#define SAMPLES 1\n#define MAXDEPTH 5\n\n// Uncomment to see how many samples never reach a light source\n//#define DEBUG\n\n// Not used for now\n#define DEPTH_RUSSIAN 2\n\n#define PI 3.14159265359\n#define DIFF 0\n#define SPEC 1\n#define REFR 2\n#define NUM_SPHERES 9\n\n#define MOVING_LIGHT 1\n//#define MOVING_SPHERE 1\n//#define DEBUG 1\n\nfloat seed = 0.;\nfloat rand() { return fract(sin(seed*(iTime))*43758.5453123); }\n\nstruct Ray { vec3 o, d; };\nstruct Sphere {\n\tfloat r;\n\tvec3 p, e, c;\n\tint refl;\n};\n\nSphere lightSourceVolume = Sphere(30., vec3(50., 81.6, 81.6), vec3(12.), vec3(0.), DIFF);\nSphere spheres[NUM_SPHERES];\nvoid initSpheres() {\n\tspheres[0] = Sphere(1e5, vec3(-1e5+1., 40.8, 81.6),\tvec3(0.), vec3(0.0, 0.2, .5), DIFF);\n\tspheres[1] = Sphere(1e5, vec3( 1e5+99., 40.8, 81.6),vec3(0.), vec3(.1, .0, 0.7), DIFF);\n\tspheres[2] = Sphere(1e5, vec3(50., 40.8, -1e5),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[3] = Sphere(1e5, vec3(50., 40.8,  1e5+170.),vec3(0.), vec3(0.), DIFF);\n\tspheres[4] = Sphere(1e5, vec3(50., -1e5, 81.6),\t\tvec3(0.), vec3(.75), DIFF);\n\tspheres[5] = Sphere(1e5, vec3(50.,  1e5+81.6, 81.6),vec3(0.), vec3(.75), DIFF);\n\tspheres[6] = Sphere(16.5, vec3(27., 16.5, 47.), \tvec3(0.), vec3(1.), SPEC);\n\tspheres[7] = Sphere(16.5, vec3(73., 16.5, 78.), \tvec3(0.), vec3(.7, 1., .9), REFR);\n\tspheres[8] = Sphere(100., vec3( 50., 175.,46.0),\tvec3(12.), vec3(0.), DIFF);\n    \n    \n    float angle = iTime * PI;\n    vec3 pos1 = vec3(sin(angle * 0.1), 0, cos(angle * 0.1));\n    vec3 pos2 = vec3(sin(angle + 0.5 * 2.0), 0, cos(angle + 0.5 * 2.0));\n    \n    #ifdef MOVING_LIGHT\n        spheres[8].p = vec3( 50.+15.*sin(iTime),175.,46.0 + 1.0 * sin(iTime*1.7) );\n    #endif\n    #ifdef MOVING_SPHERE\n        spheres[7].p += pos2 * 5.0;\n    #endif\n    \n}\n\nfloat intersect(Sphere s, Ray r) {\n\tvec3 op = s.p - r.o;\n\tfloat t, epsilon = 1e-3, b = dot(op, r.d), det = b * b - dot(op, op) + s.r * s.r;\n\tif (det < 0.) return 0.; else det = sqrt(det);\n\treturn (t = b - det) > epsilon ? t : ((t = b + det) > epsilon ? t : 0.);\n}\n\nint intersect(Ray r, out float t, out Sphere s, int avoid) {\n\tint id = -1;\n\tt = 1e5;\n\ts = spheres[0];\n\tfor (int i = 0; i < NUM_SPHERES; ++i) {\n\t\tSphere S = spheres[i];\n\t\tfloat d = intersect(S, r);\n\t\tif (i!=avoid && d!=0. && d<t) { t = d; id = i; s=S; }\n\t}\n\treturn id;\n}\n\nvec3 jitter(vec3 d, float phi, float sina, float cosa) {\n\tvec3 w = normalize(d), u = normalize(cross(w.yzx, w)), v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 radiance(Ray r) {\n\tvec3 acc = vec3(0.);\n\tvec3 mask = vec3(1.);\n\tint id = -1;\n\tfor (int depth = 0; depth < MAXDEPTH; ++depth) {\n\t\tfloat t;\n\t\tSphere obj;\n\t\tif ((id = intersect(r, t, obj, id)) < 0) break;\n\t\tvec3 x = t * r.d + r.o;\n\t\tvec3 n = normalize(x - obj.p), nl = n * sign(-dot(n, r.d));\n\n\t\t//vec3 f = obj.c;\n\t\t//float p = dot(f, vec3(1.2126, 0.7152, 0.0722));\n\t\t//if (depth > DEPTH_RUSSIAN || p == 0.) if (rand() < p) f /= p; else { acc += mask * obj.e * E; break; }\n\n\t\tif (obj.refl == DIFF) {\n\t\t\tfloat r2 = rand();\n\t\t\tvec3 d = jitter(nl, 5.*PI*rand(), sqrt(r2), sqrt(1. - r2));\n\t\t\tvec3 e = vec3(0.);\n\t\t\t//for (int i = 0; i < NUM_SPHERES; ++i)\n\t\t\t{\n\t\t\t\t// Sphere s = sphere(i);\n\t\t\t\t// if (dot(s.e, vec3(1.)) == 0.) continue;\n\n\t\t\t\t// Normally we would loop over the light sources and\n\t\t\t\t// cast rays toward them, but since there is only one\n\t\t\t\t// light source, that is mostly occluded, here goes\n\t\t\t\t// the ad hoc optimization:\n\t\t\t\tSphere s = lightSourceVolume;\n\t\t\t\tint i = 8;\n\n\t\t\t\tvec3 l0 = s.p - x;\n\t\t\t\tfloat cos_a_max = sqrt(1. - clamp(s.r * s.r / dot(l0, l0), 0., 1.));\n\t\t\t\tfloat cosa = mix(cos_a_max, 1., rand());\n\t\t\t\tvec3 l = jitter(l0, 2.*PI*rand(), sqrt(1. - cosa*cosa), cosa);\n\n\t\t\t\tif (intersect(Ray(x, l), t, s, id) == i) {\n\t\t\t\t\tfloat omega = 2. * PI * (1. - cos_a_max);\n\t\t\t\t\te += (s.e * clamp(dot(l, n),0.,1.) * omega) / PI;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloat E = 1.;//float(depth==0);\n\t\t\tacc += mask * obj.e * E + mask * obj.c * e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, d);\n\t\t} else if (obj.refl == SPEC) {\n\t\t\tacc += mask * obj.e;\n\t\t\tmask *= obj.c;\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t} else {\n\t\t\tfloat a=dot(n,r.d), ddn=abs(a);\n\t\t\tfloat nc=1., nt=1.5, nnt=mix(nc/nt, nt/nc, float(a>0.));\n\t\t\tfloat cos2t=1.-nnt*nnt*(1.-ddn*ddn);\n\t\t\tr = Ray(x, reflect(r.d, n));\n\t\t\tif (cos2t>0.) {\n\t\t\t\tvec3 tdir = normalize(r.d*nnt + sign(a)*n*(ddn*nnt+sqrt(cos2t)));\n\t\t\t\tfloat R0=(nt-nc)*(nt-nc)/((nt+nc)*(nt+nc)),\n\t\t\t\t\tc = 1.-mix(ddn,dot(tdir, n),float(a>0.));\n\t\t\t\tfloat Re=R0+(1.-R0)*c*c*c*c*c,P=.25+.5*Re,RP=Re/P,TP=(1.-Re)/(1.-P);\n\t\t\t\tif (rand()<P) { mask *= RP; }\n\t\t\t\telse { mask *= obj.c*TP; r = Ray(x, tdir); }\n\t\t\t}\n\t\t}\n\t}\n\treturn acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tinitSpheres();\n\tseed = sin(iTime + iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y);\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tvec3 camPos = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) / iResolution.xy - 1.) * vec2(48., 40.) + vec2(50., 40.8), 169.);\n\tvec3 cz = normalize(vec3(50., 40., 81.6) - camPos);\n\tvec3 cx = vec3(1., 0., 0.);\n\tvec3 cy = normalize(cross(cx, cz)); cx = cross(cz, cy);\n\tvec3 color = vec3(0.);\n    float distance = 1.0;\n    Ray ray = Ray(camPos, normalize(.53135 * (iResolution.x/iResolution.y*uv.x * cx + uv.y * cy) + cz));\n\tfor (int i = 0; i < SAMPLES; ++i)\n    {\n#ifdef DEBUG\n        vec3 test = radiance(ray);\n        if (dot(test, test) > 0.) color += vec3(1.); else color += vec3(0.5,0.,0.1);\n#else\n\t\tcolor += radiance(ray);\n#endif\n    }\n    \n    int id = -1;\n    float t;\n\tSphere obj;\n\tid = intersect(ray, t, obj, id);\n        \n\tfragColor = vec4(pow(clamp(color/float(SAMPLES), 0., 1.), vec3(0.4545454)), float(id) * 0.1);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n// lower quality, more reactive\n#define SMOOTHING 0.75\n#define GUASSIAN_SAMPLE_WIDTH 5\n#define EXPOSURE 0.9\n#define BLUR_THRESHOLD 0.1\n\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float oldMult = SMOOTHING;\n    float newMult = 1. - SMOOTHING;\n    float fadeMult = EXPOSURE;\n        \n    vec2 main_uv = fragCoord.xy / iResolution.xy;\n                \n\tvec3 c = texture(iChannel0, main_uv).rgb;\n\t{\n\t\t\n        float r = texture(iChannel0, main_uv).r;\n        float g = texture(iChannel0, main_uv).g;\n        float b = texture(iChannel0, main_uv).b;\n        float av = (r + g + b) / 3.0;\n        \n        float low = 0.3;\n        float high = 0.8;\n        \n        if (\n        (r > high && g < low && b < low) ||\n        (r < low && g > high && b < low) ||\n        (r < low && g < low && b > high)\n        )\n        {\n            fragColor =  (texture(iChannel1, main_uv) * (oldMult)) + (texture(iChannel0, main_uv) * newMult) * fadeMult;\n            \n            // debug test\n            //fragColor = vec4(1.0,0.0,0.0, texture(iChannel0, main_uv).a);\n        }\n        else\n        {\n            //declare stuff\n            const int mSize = GUASSIAN_SAMPLE_WIDTH;\n            const int kSize = (mSize-1)/2;\n            float kernel[mSize];\n\n            //create the 1-D kernel\n            float sigma = 7.0;\n            float Z = 0.0;\n\n            for (int j = 0; j <= kSize; ++j)\n            {\n                kernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n            }\n\n            //get the normalization factor (as the gaussian has been clamped)\n            for (int j = 0; j < mSize; ++j)\n            {\n                Z += kernel[j];\n            }\n        \n            //read out the texels\n            vec3 final_colour = vec3(0.0);\n            for (int i=-kSize; i <= kSize; ++i)\n            {\n                for (int j=-kSize; j <= kSize; ++j)\n                {\n                    vec2 uv = (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy;\n                    \n                    float av1 = length(texture(iChannel0, main_uv).rgb);\n                    float av2 = length(texture(iChannel0, uv).rgb);\n                    \n                    if ((abs(texture(iChannel0, main_uv).a - texture(iChannel1, uv).a) < 0.05) &&\n                        abs(av1 - av2) > BLUR_THRESHOLD) {\n                        fragColor = max((texture(iChannel1, uv) * (oldMult)) + (texture(iChannel0, main_uv) * newMult), (texture(iChannel1, uv))) * fadeMult;\n                        //fragColor = max((texture(iChannel1, main_uv) * (oldMult)), (texture(iChannel0, main_uv) * newMult)) * fadeMult;\n                        \n                        final_colour += kernel[kSize+j]*kernel[kSize+i]*fragColor.rgb;\n                    }\n                    else {\n                        //final_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel1, uv).rgb;\n                        //fragColor = max((texture(iChannel1, main_uv) * (oldMult)), (texture(iChannel0, main_uv) * newMult)) * fadeMult;\n                        fragColor = max((texture(iChannel0, main_uv))*oldMult, (texture(iChannel1, main_uv) * oldMult)) * fadeMult;\n                        final_colour += kernel[kSize+j]*kernel[kSize+i]*fragColor.rgb;\n                    }\n                }\n            }\n            \n            fragColor = vec4(final_colour/(Z*Z), texture(iChannel0, main_uv).a);\n        }\n\t\t\n\t}\n}\n","name":"Buffer B","description":"","type":"buffer"}]}