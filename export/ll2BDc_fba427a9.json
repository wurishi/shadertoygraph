{"ver":"0.1","info":{"id":"ll2BDc","date":"1525560148","viewed":114,"name":"sdoriginstar","username":"dahart","description":"A star shape as a signed distance function in polar coordinates, and other shapes too.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["star"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sqr(float x) { return x*x; }\n\nfloat sdFatLine(vec2 p, vec2 a, vec2 b, float ra, float rb, out vec2 n) {\n    vec2 d = b - a;\n    float t = dot(p - a, d) / dot(d, d);\n    t = min(1.0, max(0.0, t));\n    vec2 cp = a + t * d;\n    float cr = ra + t * (rb - ra);\n    n = p - cp;\n    return length(n) - cr;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nconst float pi = 3.14159265;\n\n\nfloat sdOriginStar(vec2 p, float n, float r) \n{\n    switch(int(floor(mod(iTime, 10.f)))) \n    {\n        case 0: \n        {\n            // V-shape grass\n            vec2 norm;\n            float wc = .3*r;\n            float wo = .1*r;\n            float a = 1.;\n            float x = r*cos(a);\n            float y = r*sin(a);\n            float s = (r - wo) / r;\n            return smin(sdFatLine(p, vec2(0.), s*vec2(x, y), wc, wo, norm), \n                       sdFatLine(p, vec2(0.), s*vec2(x, -y), wc, wo, norm),\n                        .03\n                       );\n        }\n        \n        case 1:\n        {\n            // V-shape (grass?)\n            float a = atan(p.y,p.x);\n            float a1 = -.8;\n            float a2 = .8;\n\n            float R = r*(.3 + .7*exp(-sqr(a-a1)*8.) + .7*exp(-sqr(a-a2)*8.));\n            return length(p) - R;\n        }\n        \n        case 2:\n        {\n            // soft star\n            float a = atan(p.y,p.x);\n            float R = r * (.8 + .2 * sin(a*n));\n            return length(p) - R;\n        }\n        \n        case 3:\n        {\n            // hard star\n            float a = atan(p.y, p.x) + iTime;\n            //float r1 = sin(pi/10.) * 1./sin(a + pi/10.);\n\n            float a1 = mod(a, 2.*pi/5.) + pi/10.;\n            float a2 = mod(-a, 2.*pi/5.) + pi/10.;\n\n            return length(p) - r * sin(pi/10.) / min( sin(a1), sin(a2) );\n        }\n\n        case 4:\n        {\n            // ellipse from https://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf\n            float e0 = .2f;\n            float e1 = .1f;\n            float x0, x1;\n            float distance;\n            if (p.y > 0.) {\n                if (p.x > 0.) {\n                  // Compute the unique root tbar of F(t) on(-e1 * e1, +infinity);\n                  x0 = e0 * e0 * p.x / (1. + e0 * e0);\n                  x1 = e1 * e1 * p.y / (1. + e1 * e1);\n                  distance = sqrt((x0 - p.x) * (x0 - p.x) + (x1 - p.y) * (x1 - p.y));\n                } else  // p.x == 0\n                {\n                  x0 = 0.;\n                  x1 = e1;\n                  distance = abs(p.y - e1);\n                }\n            } else  // p.y == 0\n            {\n                if (p.x < (e0 * e0 - e1 * e1) / e0) {\n                  x0 = e0 * e0 * p.x / (e0 * e0 - e1 * e1);\n                  x1 = e1 * sqrt(1. - (x0 / e0) * (x0 / e0));\n                  distance = sqrt((x0 - p.x) * (x0 - p.x) + x1 * x1);\n                } else {\n                  x0 = e0;\n                  x1 = 0.;\n                  distance = abs(p.x - e0);\n                }\n            }\n            return distance - .1;\n        }\n        \n        case 5:\n        {\n            // exact dist pill\n            float d = 0.;\n            if (p.x < -.4) d = length(p - vec2(-0.4, 0.));\n            else if (p.x > .4) d = length(p - vec2(.4, 0.));\n            else d = abs(p.y);\n            d -= 0.1;\n            return d;\n        }\n        \n        case 6:\n        {\n            // exact dist star\n            // float sdFatLine(float2 p, float2 a, float2 b, float ra, float rb, float2& n) {\n            float d = abs(p.x) + abs(p.y);\n            vec2 norm;\n            float ra = 0.4f * r;\n            float rb = 0.01f * r;\n            for (float i = 0.f; i < n; i += 1.f) {\n                float a = pi * 2.f * i / n;\n                d = min(d, sdFatLine(p, vec2(0.), (r - rb) * vec2(cos(a), sin(a)), ra, rb, norm));\n            }\n            return d;\n        }\n\n        case 7:\n        {\n            // ellipse\n            //float ang = atan(p.y, p.x);\n            float a = .05;\n            float b = .5;\n            //float R = a*b / sqrt( sqr(a * cos(ang)) + sqr(b * sin(ang)) );\n            //return length(p) - R;\n            return length(p / vec2(b, a)) - 1.; // simpler version by Fabrice Neyret\n        }\n\n        case 8:\n        {\n            // square in polar coords\n            float a = atan(p.y,p.x);\n            float R = r / sqrt(2.) * min(1./abs(cos(a)), 1./abs(sin(a)));\n            return length(p) - R;\n        }\n\n        case 9:\n        {\n            // square in cartesian\n            vec3 nop = vec3(-1., 0., 1.);\n            vec2 d = vec2(r * sqrt(2.) * .5);\n            float d1 = length(p - d * nop.zz);\n            d1 = min(d1, length(p - d * nop.xx));\n            d1 = min(d1, length(p - d * nop.xz));\n            d1 = min(d1, length(p - d * nop.zx));\n            return min(d1 - r/sqrt(2.), min(abs(p.x) - r/sqrt(2.), abs(p.y) - r/sqrt(2.)));//max(abs(p.x), abs(p.y))-r/sqrt(2.));\n        }\n    }  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 1.5*(fragCoord.xy - iResolution.xy/2.) / iResolution.yy;\n\n    vec3 col = vec3(0.);\n    float d = length(uv - vec2(0.)) - .5;\n    col = vec3(1., 0., 0.) * smoothstep(0., -1.5*fwidth(d), d);\n    d = sdOriginStar(uv - vec2(0.), 5., .5);\n    col += smoothstep(0., -1.5*fwidth(d), d);\n    \n    fragColor = vec4(col,1.0);\n    //fragColor.b = mod(10. * sdOriginStar(uv, 5., .5), 1.);\n\n}","name":"Image","description":"","type":"image"}]}