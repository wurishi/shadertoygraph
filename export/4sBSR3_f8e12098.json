{"ver":"0.1","info":{"id":"4sBSR3","date":"1468358671","viewed":255,"name":"skinketest","username":"syltefar","description":"This is my first attempt at writing a music shader, and dropped a ray marching thing I did earlier into it as a visualizer.","likes":3,"published":1,"flags":8,"usePreview":0,"tags":["simplemusicshader"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* found this on the internets */\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/* Conventions:\n *\n * t  : time in seconds\n * f  : frequency in Hz\n * p  : phase [0;1]\n * pi : instrument phase ~ env progress [0;1]\n *\n */\n\n// Basic stuff\nfloat noise(float t)   { return rand(vec2(t, t)); }\nfloat svin(float p)    { return sin(p * 6.2831); }\nfloat clamp01(float f) { return clamp(f, 0.0, 1.0); }\nfloat saw(float p)     { return fract(p); }\n\n// this does not work\nfloat note(float n) { return 200.0 * exp2(floor(n)/12.0); }\n\nfloat fm(float p, float e)   { return svin(p + svin(p) * e); }\nfloat sub(float pi, float f) { return svin(pi * f) * clamp01(1.0 - pi * 2.0); }\nfloat hh(float pi)           { return noise(pi) * clamp01(1.0 - pi * 4.0); }\n\nfloat bass(float t)\n{\n    float lfo = 1.0 - saw(t * 1.5);\n    return fm(t * 50.0, (1.0-lfo)) * (1.0 - lfo);\n}\n\nfloat bd(float pi, float f)\n{\n    float env = clamp01(1.0 - pi * 4.0); \n    float fr  = f + clamp(100.0 * env, 0.0, 100.0); // pitch sweep\n    float ph  = saw(pi * fr);\n    \n    return svin(ph) * env;\n}\n\nfloat sn(float pi)\n{\n    return hh(pi) * 0.3 + bd(clamp01(pi*2.0), 100.0) * 0.7;\n}\n\nfloat string(float pi, float f)\n{\n    return 0.2 * (\n        saw(pi * f) +\n        saw(pi * f * 1.002) +\n        saw(pi * f * 1.004) +\n        saw(pi * f * 0.998) +\n        saw(pi * f * 0.996)\n    );\n}\n\nfloat track(float time)\n{\n    float pb  = saw(time);        // bar phase\n    float pb4 = saw(time * 0.25); // 4-bar phase\n    \n    return\n        //bass(pb) * 0.1 +\n        \n        bd(saw(pb*8.0/3.0), 25.0) * 0.5 +\n        hh(saw(pb * ceil(pb4 * 1.1) * 8.0)) * 0.1 +     // hh\n        sn(saw(pb * 1.0 + 0.5)) * 0.5 + // sn\n        sub(saw(pb*2.0+0.5), ceil(pb4 * 1.1) * 25.0) * 0.4 +\n        \n//        svin(saw(pb*2.0) * (200.0 + note(pb4 * 4.0))) * 0.1 * (1.0 - saw(pb * 2.0)) +\n        \n        (\n            string(pb4, 200.0) * 0.06 +\n        string(pb4, 400.0) * 0.04 +\n        string(pb4, 800.0) * 0.03 +\n        string(pb4 - 0.1, 1200.0) * 0.02 +\n        string(pb4 - 0.1, 900.0) * 0.02) * 0.0\n        +\n            \n        0.0\n        ;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    const float wobble = 0.0; //0.0003;\n    float speed = 0.8;\n    const float stereo_offset = 100.1;\n    \n    // time offset effects to simulate tape recorder and stereo spread\n    float t = time * speed + sin(time * 20.0) * wobble;                  // tape recorder L\n    float l = track(t) + track(t - 0.375) * 0.2 + track(t - 0.75) * 0.1; // delay\n    t       = time * speed + sin(time * 20.0 + stereo_offset) * wobble;  // tape recorder R\n    float r = track(t) + track(t - 0.375) * 0.2 + track(t - 0.75) * 0.1; // delay\n \n    return vec2( l, r );\n}\n\n\n\n// The shader I wrote for my first attempt at WebGL back in 2012.\n// I copied a shader example and implemented some very basic and probably very\n// buggy ray marching of a signed distance field,\n// based on an explanation by Mikkel GjÃ¸l. \n\nprecision mediump float;\n\nfloat sphere( vec3 p ) { return length(p) - 1.0; }\nfloat box( vec3 p )\n{\n    return max(\n             max(\n               p.x * p.x - 0.4,\n\t           p.y * p.y - 0.4\n\t         ),\n\t       p.z * p.z - 0.4\n\t  );\n}\n\n// basic sdf stuff\nvec3 translate(vec3 p, vec3 v) { return p - v; } \nfloat or( float a, float b ) { return min(a,b); }\nfloat and( float a, float b ) { return max(a,b); }\n\nfloat sdf( vec3 p, float time) {\n    //vec3 c = vec3(8.0, 8.0, 8.0);\n    //vec3 v = p;//mod(p,c)-0.5*c;\n    float ripple = 0.2;\n    //return min( box(p), sphere(p));\n\n    //return box(translate(p, vec3(0., 0., 2.)));\n    //return and( box(p), sphere(p * 1.5) );\n\n    /*\n      return or(\n\t  sphere(translate(p, vec3(-0.5, 0., 2.))),\n\t  sphere(translate(p, vec3(+0.5, 0., 2.)))\n      );\n    */\n\n    vec2 wob1 = mainSound( in int samp,iTime) * 20.0;\n    vec2 wob2 = mainSound( in int samp,iTime-0.4) * 20.0;\n    \n    // Wobbly\n    return distance(p, vec3(\n\t  0.0+sin(p.y* 20.0 * sin(wob1.x*2.) + wob1.y * 10.)*ripple * sin(wob1.x*5.) * 2.,\n\t  0.0+sin(p.x* 20.0 * sin(wob2.x*2.7) + wob2.y* 10.)*ripple * sin(wob2.x*3.) * 2.,\n\t  2.0)) - 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.yy * 2.2;\n    vec3 pos = vec3(uv.x-1.9, uv.y-1.1, 0.0);\n    vec3 direction = pos - vec3(0.0, 0.0, -1.0);\n\n    // ray marching\n    float d = 10.0;\n    for(int i =0; i < 256; i++) {\n\t  d = sdf(pos, iTime );\n\t  pos += direction * d;\n\t  if(d < 0.02 || pos.z > 100.0) break;\n    }\n\n    float r = 0.0, g = 0.0, b = 0.0;\n    \n    if(d<=0.02) {\n\n\t  // estimate normal based on finite difference approx of gradient\n\t  vec3 gradient = sdf(pos, iTime) - vec3(\n\t      sdf(pos + vec3(.001,.000,.000), iTime),\n\t      sdf(pos + vec3(.000,.001,.000), iTime),\n\t      sdf(pos + vec3(.000,.000,.001), iTime)\n\t      );\n      \t  vec3 normal = normalize( gradient );\n\n\t  // red diffuse light\n\t  vec3 l = normalize(vec3(0.5,-0.5,+0.5));\n\t  r = dot( normal, l ) * 1.0;\n\t  //r = normal.x * 0.5 + 0.5;\n\t  //g = normal.y * 0.5 + 0.5;\n\t  //b = normal.z * 0.5 + 0.5;\n\t  // green diffuse light\n\t  g = dot( normal, normalize(vec3(-0.4,0.4,+0.4))) * 0.2;\n\t  // blue diffuse light\n\t  b = dot( normal, normalize(vec3(0.9,-0.3,+0.4))) * 0.3;\n    }\n    fragColor = vec4(r, g, b, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"XsfGRr","channel":0}],"code":"/* found this on the internets */\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/* Conventions:\n *\n * t  : time in seconds\n * f  : frequency in Hz\n * p  : phase [0;1]\n * pi : instrument phase ~ env progress [0;1]\n *\n */\n\n// Basic stuff\nfloat noise(float t)   { return rand(vec2(t, t)); }\nfloat svin(float p)    { return sin(p * 6.2831); }\nfloat clamp01(float f) { return clamp(f, 0.0, 1.0); }\nfloat saw(float p)     { return fract(p); }\n\n// this does not work\nfloat note(float n) { return 200.0 * exp2(floor(n)/12.0); }\n\nfloat fm(float p, float e)   { return svin(p + svin(p) * e); }\nfloat sub(float pi, float f) { return svin(pi * f) * clamp01(1.0 - pi * 2.0); }\nfloat hh(float pi)           { return noise(pi) * clamp01(1.0 - pi * 4.0); }\n\nfloat bass(float t)\n{\n    float lfo = 1.0 - saw(t * 1.5);\n    return fm(t * 50.0, (1.0-lfo)) * (1.0 - lfo);\n}\n\nfloat bd(float pi, float f)\n{\n    float env = clamp01(1.0 - pi * 4.0); \n    float fr  = f + clamp(100.0 * env, 0.0, 100.0); // pitch sweep\n    float ph  = saw(pi * fr);\n    \n    return svin(ph) * env;\n}\n\nfloat sn(float pi)\n{\n    return hh(pi) * 0.3 + bd(clamp01(pi*2.0), 100.0) * 0.7;\n}\n\nfloat string(float pi, float f)\n{\n    return 0.2 * (\n        saw(pi * f) +\n        saw(pi * f * 1.002) +\n        saw(pi * f * 1.004) +\n        saw(pi * f * 0.998) +\n        saw(pi * f * 0.996)\n    );\n}\n\nfloat track(float time)\n{\n    float pb  = saw(time);        // bar phase\n    float pb4 = saw(time * 0.25); // 4-bar phase\n    \n    return\n        //bass(pb) * 0.1 +\n        \n        bd(saw(pb*8.0/3.0), 25.0) * 0.5 +\n        hh(saw(pb * ceil(pb4 * 1.1) * 8.0)) * 0.1 +     // hh\n        sn(saw(pb * 1.0 + 0.5)) * 0.5 + // sn\n        sub(saw(pb*2.0+0.5), ceil(pb4 * 1.1) * 25.0) * 0.4 +\n        \n//        svin(saw(pb*2.0) * (200.0 + note(pb4 * 4.0))) * 0.1 * (1.0 - saw(pb * 2.0)) +\n        \n        (\n            string(pb4, 200.0) * 0.06 +\n        string(pb4, 400.0) * 0.04 +\n        string(pb4, 800.0) * 0.03 +\n        string(pb4 - 0.1, 1200.0) * 0.02 +\n        string(pb4 - 0.1, 900.0) * 0.02) * 0.0\n        +\n            \n        0.0\n        ;\n}\n\nvec2 mainSound( in int samp,float time)\n{\n    const float wobble = 0.0; //0.0003;\n    float speed = 0.8;\n    const float stereo_offset = 100.1;\n    \n    // time offset effects to simulate tape recorder and stereo spread\n    float t = time * speed + sin(time * 20.0) * wobble;                  // tape recorder L\n    float l = track(t) + track(t - 0.375) * 0.2 + track(t - 0.75) * 0.1; // delay\n    t       = time * speed + sin(time * 20.0 + stereo_offset) * wobble;  // tape recorder R\n    float r = track(t) + track(t - 0.375) * 0.2 + track(t - 0.75) * 0.1; // delay\n \n    return vec2( l, r );\n}\n\n","name":"Sound","description":"","type":"sound"}]}