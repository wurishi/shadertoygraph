{"ver":"0.1","info":{"id":"ll2cWt","date":"1511623309","viewed":580,"name":"Volumetric Light Demo","username":"Crow","description":"volume light","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1416\n#define NEAR 0.1\n#define FAR 10.0\n#define CYC 0.5\n#define MOVRADA 0.6\n#define MOVRADB 1.1\n#define EMIRAD 0.2\n#define STEPS 30.0\n\nfloat SdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\nvec2 OpU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat OpS( float d1, float d2 )\n{\n    return max(-d2, d1);\n}\n\nvec2 Map( vec3 pos )\n{    \n    vec3 movPos = vec3(sin(iTime * CYC), 0.0, cos(iTime * CYC)) * MOVRADA\n        \t\t  + vec3(cos(iTime * CYC * 2.0 + PI * 0.5), 0.0, sin(iTime * CYC * 2.0 + PI * 0.5)) * MOVRADB;\n    vec2 res = vec2(SdSphere(pos - (vec3(0, 1.0, 0) + movPos), EMIRAD), 1.0);\n    \n    vec2 res2 = vec2(OpU(vec2(SdSphere(pos - vec3(0.0, 1.0, -1.0), 0.6), 2.0),\n                         OpU(vec2(SdSphere(pos - vec3(0.866, 1.0, 0.5), 0.6), 2.0),\n                             vec2(SdSphere(pos - vec3(-0.866, 1.0, 0.5), 0.6), 2.0))));\n    res = OpU(res, vec2(OpS(SdSphere(pos - vec3(0, 1.0, 0), 1.0), \n                             OpU(vec2(SdSphere(pos - vec3(0, 1.0, 0), 0.8), 2.0), \n                                 res2).x), 2.0));\n\n    return res;\n}\n\nvec2 CastRay( vec3 camPos, vec3 rayDir, float nearClip, float farClip )\n{\n    float dis = nearClip;\n    float mat = -1.0;\n    for(int i = 0; i < 50; i++)\n    {\n\t    vec2 res = Map(camPos + rayDir * dis);\n        if(res.x < 0.001) \n            break;\n        \n        dis += res.x;\n        mat = res.y;\n        if(dis >= farClip)\n        {\n            dis = farClip;\n            mat = -1.0;\n            break;\n        }\n    }\n    \n    return vec2(dis, mat);\n}\n\n//---material--------------------------------------------------\nstruct Mat\n{\n    vec3 basCol;\n    vec3 emiCol;\n    float spe;\n};\n\nMat CreateMat( vec3 basCol, vec3 emiCol, float spe )\n{\n    Mat mat;\n    mat.basCol = basCol;\n    mat.emiCol = emiCol;\n    mat.spe = spe;\n    return mat;\n}\n\nMat GetMat( vec3 pos, float matNumber )\n{\n    if(matNumber < 1.5)\n    {\n        return CreateMat(vec3(0.0), vec3(0.9, 0.4, 0.1) * 1.5, 0.001);\n    }\n    else if(matNumber < 2.5)\n    {\n        float n = step(0.3, mod(pos.x, 0.6));\n        return CreateMat(n * vec3(0.2) + vec3(0.0, 0.8, 0.3), vec3(0.0), 0.25);\n    }\n}\n\n//---light--------------------------------------------------\nstruct Light\n{\n    vec3 lightPos;\n    vec3 lightCol;\n    float lightRan;\n    vec3 amb;\n};\n    \nLight CreateLight( vec3 lightPos, vec3 lightCol, float lightRan, vec3 amb )\n{\n    Light light;\n    light.lightPos = lightPos;\n    light.lightCol = lightCol;\n    light.lightRan = lightRan;\n    light.amb = amb;\n    return light;\n}\n\n//---render-------------------------------------------------\nvec3 GetNormal( vec3 pos )\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(Map(pos + eps.xyy).x - Map(pos - eps.xyy).x,\n                    Map(pos + eps.yxy).x - Map(pos - eps.yxy).x,\n                    Map(pos + eps.yyx).x - Map(pos - eps.yyx).x );\n\treturn normalize(nor); \n}\n\nfloat GetShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float shadow = step(CastRay(ro, rd, mint, maxt).y, 0.0);\n    return shadow;\n}\n\nfloat GetVolumeLight( vec3 camPos, vec3 rayDir, vec3 lightPos, float lightRan, float hit, vec2 screenPos )\n{    \n    float maxDis = min(FAR, hit);\n    float stepDis = (FAR - NEAR) / STEPS;\n    vec3 stepVec = rayDir * stepDis;\n    \n    float noise = texture(iChannel0, screenPos / iChannelResolution[0].xy).r;\n    float dis = NEAR + noise * 0.5;\n    vec3 pos = camPos + rayDir * dis;\n        \n    float sum = 0.0;\n    for(float i = 0.0; i < STEPS; i++)\n    {        \n        vec3 lightVec = lightPos - pos;\n        float lenLightVec = length(lightVec);\n        if(lenLightVec < lightRan)\n        {\n        \tvec3 lightDir = normalize(lightVec);\n            float shadow = GetShadow(pos, lightDir, 0.0, lenLightVec - EMIRAD - 0.03);\n            float atten = max(1.0 - lenLightVec / lightRan, 0.0);\n        \tsum += shadow * atten / STEPS;\n        }\n        \n        dis += stepDis;        \n        if(dis > maxDis)\n        \tbreak;        \n        pos += stepVec;\n    }    \n    \n    return sum;\n}\n\nvec3 Render( vec3 camPos, vec3 rayDir, vec2 screenPos )\n{\n    vec3 movPos = vec3(sin(iTime * CYC), 0.0, cos(iTime * CYC)) * MOVRADA\n        \t\t  + vec3(cos(iTime * CYC * 2.0 + PI * 0.5), 0.0, sin(iTime * CYC * 2.0 + PI * 0.5)) * MOVRADB;\n    Light light = CreateLight(vec3(0, 1.0, 0) + movPos, vec3(0.9, 0.4, 0.1) * 1.5, 4.0, vec3(0.2));\n    \n    vec3 col;    \n    vec3 pos = camPos;\n        \n    vec2 res = CastRay(pos, rayDir, NEAR, FAR);\n    float dis = res.x;\n    float m = res.y;     \n    if(m > 0.0)\n    {\n        pos += rayDir * dis;\n        Mat mat = GetMat(pos, m);\n\n        vec3 viewDir = -rayDir;\n        vec3 lightVec = light.lightPos - pos;\n        vec3 lightDir = normalize(lightVec);\n        float lenLightVec = length(lightVec);\n        \n        vec3 nor = GetNormal(pos);\n        float shadow = GetShadow(pos, lightDir, 0.03, lenLightVec - EMIRAD - 0.03);\n                       \n        float nl = max(dot(nor, lightDir), 0.0);\n        vec3 halfDir = normalize(lightDir + viewDir);\n        float nh = max(dot(nor, halfDir), 0.0);\n        \n        float specular = pow(nh, mat.spe * 128.0);\n        \n        float atten = max(1.0 - lenLightVec / light.lightRan, 0.0);\n        \n        col = (mat.basCol + specular) * light.lightCol * nl * shadow * atten \n               + mat.basCol * light.amb\n               + mat.emiCol;\n    }\n    else\n    {\n        col = vec3(0.03);\n    }\n    \n    //---volume light---\n    col += GetVolumeLight(camPos, rayDir, light.lightPos, light.lightRan, dis, screenPos) * light.lightCol * 0.3;\n    \n    //---halo---\n    vec3 ligVec = camPos - light.lightPos;\n    vec3 ligDir = normalize(ligVec);\n    float lenLigVec = length(ligVec);\n    float depthTest = step(CastRay(light.lightPos + EMIRAD * ligDir, ligDir, 0.03, 5.0).y, 0.0);\n    col += pow(max(dot(-rayDir, ligDir), 0.0), 128.0 * lenLigVec) * light.lightCol * depthTest;\n    \n    return col;\n}\n//--------------------------------------------------------\n\nmat3 SetCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = q * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    \n    vec3 camPos = vec3(3.0 * cos(7.0 * mouse.x), 1.0 + 3.0 * mouse.y, 3.0 * sin(7.0 * mouse.x));\n    vec3 camLookAt = vec3(0.0, 1.0, 0.0);\n    \n    mat3 camMatrix = SetCamera(camPos, camLookAt, 0.0);\n    vec3 rayDir = normalize(camMatrix * vec3(p.xy, 1.5));\n    \n    vec3 col = Render(camPos, rayDir, fragCoord.xy);\n    col = pow(col, vec3(1.0 / 2.2));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}