{"ver":"0.1","info":{"id":"4dc3Rl","date":"1451671476","viewed":163,"name":"Cellquilt","username":"narobins","description":"voronoi cell division","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","test","cellnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"//* Click to set zoom center *//\n\n\nconst vec4 c1 = vec4(0.3, 0.2, 0.7, 1.0); // top left\nconst vec4 c2 = vec4(0.3, 0.1, 0.2, 1.0); // top right\nconst vec4 c3 = vec4(0.8, 0.3, 0.0, 1.0); // bottom right\nconst vec4 c4 = vec4(0.6, 0.7, 0.9, 1.0); // bottom left\n\nconst float shadowStrength = 0.7;\nconst float shadowAmp1 = 8.0; // distance from center of cell\nconst float shadowAmp2 = 3.0; // distance from center of second-closest cell\n\nconst vec2 sections = vec2(4.0, 2.5);\nconst float zs = 0.5; // zoom speed\nconst float za = 2.0; // zoom amount\n\nconst bool drawpts = false;\n\nfloat rand(vec2 co);\nvec2 findPt(vec2 coord);\nvec4 closestPt(vec2 coord);\nvec2 unNorm(vec2 co);\nvec4 lerpColor(vec2 c);\nvec4 randomColor();\nvec2 getTransform();\nvec2 transformCoords(vec2 co);\nvec2 unTransformCoords(vec2 co);\nvec2 getCenter();\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = transformCoords(fragCoord.xy / iResolution.xy);\n    vec2 id = floor(uv);\n    \n    vec4 pt = closestPt(uv.xy);\n    vec2 p1 = unTransformCoords(pt.xy);\n    vec2 p2 = unTransformCoords(pt.zw);\n\n    fragColor = lerpColor(p1) * vec4(0.8, 1.5, 0.9, 1.0);\n    \n    float res = iResolution.x / getTransform().x;\n    vec4 shadow = vec4(1.0) \n        - vec4(shadowStrength) *  \n        (shadowAmp1 * distance(unNorm(p1), fragCoord.xy) - \n        shadowAmp2 * distance(unNorm(p2), fragCoord.xy)) / res;\n\tfragColor *= shadow;\n    \n    if (drawpts && distance(unNorm(p1), unNorm(fragCoord.xy / iResolution.xy)) < 0.9) {\n     \tfragColor = vec4(1.0);   \n    }\n}\n\nvec2 getCenter()\n{\n    return iMouse.xy / iResolution.xy;\n}\n\nvec4 closestPt(vec2 co)\n{\n    vec2 pt1 = vec2(-1000.0, -1000.0);\n    vec2 pt2 = vec2(-1000.0, -1000.0);\n    vec2 pt;\n\n    vec2 id = floor(co * sections);\n\n    const int min = -1;\n    const int max = 1;\n    float dist;\n    \n    for (int xi = min; xi <= max; xi++) {\n        for (int yi = min; yi <= max; yi++) {\n            pt = (findPt(id + vec2(float(xi), float(yi)))) / sections;\n            dist = distance(unNorm(pt), unNorm(co));\n            if (dist < distance(unNorm(pt1), unNorm(co))) {\n\t\t\t\tpt2 = pt1;             \n                pt1 = pt;\n            } else if (dist < distance(unNorm(pt2), unNorm(co))) {\n            \tpt2 = pt;\n            }\n        }\n    }\n    return vec4(pt1.xy, pt2.xy);\n}\n\nvec2 getTransform()\n{\n    return vec2(1.0 + za * \n             (sin(float(iTime) * zs) / 2.0 + 0.5));\n}\n\nvec2 transformCoords(vec2 co)\n{\n    vec2 ctr = getCenter();\n    return (co - ctr) * \n        getTransform()\n        + ctr;\n}\n\nvec2 unTransformCoords(vec2 co)\n{\n    vec2 ctr = getCenter();\n    return (co - ctr) / \n\t\tgetTransform()\n        + ctr;\n}\n\nvec2 unNorm(vec2 co)\n{\n \treturn co * iResolution.xy; \n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 findPt(vec2 coord)\n{\n \treturn coord + vec2(rand(coord), rand(coord + vec2(1.0, 1.0)));     \n}\n\nvec4 lerpColor(vec2 c)\n{\n \treturn (1.0 - c.x) * (c.y * c1 + (1.0 - c.y) * c4) +\n    \t   c.x * (c.y * c2 + (1.0 - c.y) * c3); \n}\n\n","name":"","description":"","type":"image"}]}