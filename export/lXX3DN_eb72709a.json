{"ver":"0.1","info":{"id":"lXX3DN","date":"1708323582","viewed":97,"name":"sRGB gamut clipping test","username":"hasenpfote","description":"When DEBUG_GAMUT_CLIP_COMPARISON is disabled:\n  Left side: RGB clipped, Right side: Gamut clipped.\n\nThe additional details can be found within the Image tab.","likes":4,"published":1,"flags":48,"usePreview":0,"tags":["colorspace","oklab","gamutclipping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * sRGB gamut clipping test\n *\n * Enabling DEBUG_GAMUT_CLIP_COMPARISON in the Common tab allows you to\n * visualize the comparison of gamut clipping.\n *\n * ===\n * What is visible on the screen is as follows.\n *\n *   (1)      | (2)      | (3)      | (4)      | (5)      | (6)      | (7)\n *  ----------+----------+----------+----------+----------+----------+----------\n *   src      | adjusted lab\n *  ----------+----------+----------+----------+----------+----------+----------\n *   rgb clipped         | preserve | project  | project  | adaptive | adaptive\n *                       | chroma   | to 0.5   | to L_cusp| L0 0.5   | L0 L_cusp\n *\n * ===\n * User inputs\n *   [F1] Toggles debug display.\n *   [Space] Toggles to display only colors within the color gamut.\n *   [Mouse drag] Adjusts the filter's application range.\n *   [Left|Right] Changes color gamut clipping method.\n */\n\n//==============================================================================\n\nvec4 load_state(in int id){\n    return load_state(iChannel3, id);\n}\n\nvec3 fetch(in vec2 pos){\n    return texture(iChannel0, pos / iResolution.xy).rgb;\n}\n\n//==============================================================================\n// sRGB gamut clipping\n// https://bottosson.github.io/posts/gamutclipping/\n//==============================================================================\n\n#ifdef ENABLE_PRECOMPUTED_CUSP\nvec2 sample_cusp(in vec2 ab){\n    float hue = atan2(ab.y, ab.x);\n    float index = floor(((hue + 0.5 * TAU) / TAU) * 360. + 0.5);\n    return texture(iChannel1, vec2(index + 0.5, 0.5) / iResolution.xy).rg;\n}\n#endif\n\nvec3 gamut_clip_preserve_chroma(in vec3 lab){\n    vec2 outside = vec2(lab.x, max(1e-10, length(lab.yz)));\n    vec2 ab = lab.yz / outside.y;\n\n\t// Find the cusp of the gamut triangle\n#ifdef ENABLE_PRECOMPUTED_CUSP\n    vec2 cusp = sample_cusp(ab);\n#else\n\tvec2 cusp = find_cusp(ab);\n#endif\n    vec2 projection = vec2(clamp(outside.x, 0., 1.), 0.);\n\n\tfloat t = find_gamut_intersection(ab, cusp, outside.x, outside.y, projection.x);\n\n    vec2 clipped = mix(projection, outside, t);\n\n    return vec3(clipped.x, clipped.y * ab);\n}\n\nvec3 gamut_clip_project_to_0_5(in vec3 lab){\n    vec2 outside = vec2(lab.x, max(1e-10, length(lab.yz)));\n    vec2 ab = lab.yz / outside.y;\n\n\t// Find the cusp of the gamut triangle\n#ifdef ENABLE_PRECOMPUTED_CUSP\n    vec2 cusp = sample_cusp(ab);\n#else\n\tvec2 cusp = find_cusp(ab);\n#endif\n    vec2 projection = vec2(0.5, 0.);\n\n\tfloat t = find_gamut_intersection(ab, cusp, outside.x, outside.y, projection.x);\n\n    vec2 clipped = mix(projection, outside, t);\n\n    return vec3(clipped.x, clipped.y * ab);\n}\n\nvec3 gamut_clip_project_to_L_cusp(in vec3 lab){\n    vec2 outside = vec2(lab.x, max(1e-10, length(lab.yz)));\n    vec2 ab = lab.yz / outside.y;\n\n\t// Find the cusp of the gamut triangle\n#ifdef ENABLE_PRECOMPUTED_CUSP\n    vec2 cusp = sample_cusp(ab);\n#else\n\tvec2 cusp = find_cusp(ab);\n#endif\n    vec2 projection = vec2(cusp.x, 0.);\n\n\tfloat t = find_gamut_intersection(ab, cusp, outside.x, outside.y, projection.x);\n\n    vec2 clipped = mix(projection, outside, t);\n\n    return vec3(clipped.x, clipped.y * ab);\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(in vec3 lab, in float alpha){\n    vec2 outside = vec2(lab.x, max(1e-10, length(lab.yz)));\n    vec2 ab = lab.yz / outside.y;\n\n\t// Find the cusp of the gamut triangle\n#ifdef ENABLE_PRECOMPUTED_CUSP\n    vec2 cusp = sample_cusp(ab);\n#else\n\tvec2 cusp = find_cusp(ab);\n#endif\n    float Ld = outside.x - 0.5;\n    float e1 = 0.5 + abs(Ld) + alpha * outside.y;\n    float L0 = 0.5 * (1. + sign(Ld) * (e1 - sqrt(e1 * e1 - 2. * abs(Ld))));\n    vec2 projection = vec2(L0, 0.);\n\n\tfloat t = find_gamut_intersection(ab, cusp, outside.x, outside.y, projection.x);\n\n    vec2 clipped = mix(projection, outside, t);\n\n    return vec3(clipped.x, clipped.y * ab);\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(in vec3 lab, in float alpha){\n    vec2 outside = vec2(lab.x, max(1e-10, length(lab.yz)));\n    vec2 ab = lab.yz / outside.y;\n\n\t// Find the cusp of the gamut triangle\n#ifdef ENABLE_PRECOMPUTED_CUSP\n    vec2 cusp = sample_cusp(ab);\n#else\n    vec2 cusp = find_cusp(ab);\n#endif\n    float Ld = outside.x - cusp.x;\n    float k = 2. * (Ld >= 0. ? 1. - cusp.x : cusp.x);\n    float e1 = 0.5 * k + abs(Ld) + alpha * outside.y / k;\n    float L0 = cusp.x + 0.5 * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2. * k * abs(Ld))));\n    vec2 projection = vec2(L0, 0.);\n\n\tfloat t = find_gamut_intersection(ab, cusp, outside.x, outside.y, projection.x);\n\n    vec2 clipped = mix(projection, outside, t);\n\n    return vec3(clipped.x, clipped.y * ab);\n}\n\n//==============================================================================\n\nfloat quantize_uniform(in float x, in float quant_min, in float quant_max, in float quant_level){\n    float quant_step = (quant_max - quant_min) / quant_level;\n    return round(x / quant_step) * quant_step;\n}\n\nfloat quantize_uniform(in float x, in float quant_level){\n    return round(x * quant_level) / quant_level;\n}\n\n// You can freely adjust the input here.\n\n#ifdef DEBUG_GAMUT_CLIP_COMPARISON\n#define TEST_PATTERN 0\n#else\n#define TEST_PATTERN 1\n#endif\n\nvec3 adjust_lab(in vec3 lab){\n#ifdef DEBUG_GAMUT_CLIP_COMPARISON\n    const float l_levels = 4.;\n    const float c_levels = 5.;\n    const float h_levels = 8.;\n#else\n    const float l_levels = 10.;\n    const float c_levels = 10.;\n    const float h_levels = 10.;\n#endif\n#if (TEST_PATTERN == 0)\n    // There's meaning in doing nothing.\n#elif (TEST_PATTERN == 1)\n    // For example, about lightness.\n    lab.x = quantize_uniform(lab.x, l_levels);\n#elif (TEST_PATTERN == 2)\n    // For example, about chroma.\n    float chroma = length(lab.yz);\n    if(chroma > 1e-5){\n        float hue = atan2(lab.z, lab.y);\n        chroma = quantize_uniform(chroma / 0.32, c_levels) * 0.32;\n        lab.yz = chroma * vec2(cos(hue), sin(hue));\n    }\n#elif (TEST_PATTERN == 3)\n    // For example, about hue.\n    float chroma = length(lab.yz);\n    if(chroma > 1e-5){\n        float hue = atan2(lab.z, lab.y);\n        hue = (quantize_uniform(hue / TAU + 0.5, h_levels) - 0.5) * TAU;\n        lab.yz = chroma * vec2(cos(hue), sin(hue));\n    }\n#else\n    // It doesn't have a particular meaning, but it's complex.\n    lab.x = quantize_uniform(lab.x, l_levels);\n    float chroma = length(lab.yz);\n    if(chroma > 1e-5){\n        float hue = atan2(lab.z, lab.y);\n        chroma = quantize_uniform(chroma / 0.32, c_levels) * 0.32;\n        hue = (quantize_uniform(hue / TAU + 0.5, h_levels) - 0.5) * TAU;\n        lab.yz = chroma * vec2(cos(hue), sin(hue));\n    }\n#endif\n    return lab;\n}\n\n//==============================================================================\n\n/**\n * Returns the weight of a separator at the specified position.\n */\nfloat vert_separator(in float pos, in float sep){\n    pos -= sep;\n    return pos * pos < 4. ? 0. : 1.;\n}\n\n#ifdef DEBUG_DISPLAY\nint text(in vec2 pos){\n    const float font_scale = 5.;\n\n    float short_side = iResolution.y;\n    vec2 c_size = text_size(short_side, font_scale);\n    vec2 c_spacing = text_spacing(short_side, font_scale);\n    vec2 uv = pos / short_side;\n    vec2 o = text_pos(vec2(0., 1.), c_size.y);\n    vec2 p = o;\n    int res = 0;\n\n#define CRLF text_newline(p, o.x, c_spacing.y)\n#define C(c) do{ res |= font_draw_char(c, p, c_size, uv); text_advance_to(p, c_spacing.x); }while(false)\n#define I(_x) res |= font_draw_decimal(_x, p, c_size, uv, 1)\n#define F(_x) res |= font_draw_decimal(_x, p, c_size, uv, 2)\n\n    // fps:F\n    C(102); C(112); C(115); C(58); F(iFrameRate); CRLF;\n\n    // Precomputed cusp:\n    C(80); C(114); C(101); C(99); C(111); C(109); C(112); C(117); C(116); C(101); C(100); C(32); C(99); C(117); C(115); C(112); C(58);\n#ifdef ENABLE_PRECOMPUTED_CUSP\n    C(79); C(110);\n#else\n    C(79); C(102); C(102);\n#endif\n    CRLF;\n\n    // Colors in gamut:\n    C(67); C(111); C(108); C(111); C(114); C(115); C(32); C(105); C(110); C(32); C(103); C(97); C(109); C(117); C(116); C(58);\n\n    vec4 state_oklab = load_state(SID_OKLAB);\n\n    if(bool(state_oklab.x)){\n        C(79); C(110); CRLF;\n    }else{\n        C(79); C(102); C(102); CRLF;\n    }\n#ifndef DEBUG_GAMUT_CLIP_COMPARISON\n    // Gamut clip:\n    C(71); C(97); C(109); C(117); C(116); C(32); C(99); C(108); C(105); C(112); C(58);\n\n    int mode = int(state_oklab.y);\n\n    if(mode == 0){\n        C(80); C(114); C(101); C(115); C(101); C(114); C(118); C(101); C(32); C(99); C(104); C(114); C(111); C(109); C(97);\n    }else if(mode == 1){\n        C(80); C(114); C(111); C(106); C(101); C(99); C(116); C(32); C(116); C(111); C(32); C(48); C(46); C(53);\n    }else if(mode == 2){\n        C(80); C(114); C(111); C(106); C(101); C(99); C(116); C(32); C(116); C(111); C(32); C(76); C(95); C(99); C(117); C(115); C(112);\n    }else if(mode == 3){\n        C(97); C(100); C(97); C(112); C(116); C(105); C(118); C(101); C(32); C(76); C(48); C(32); C(48); C(46); C(53);\n    }else{\n        C(97); C(100); C(97); C(112); C(116); C(105); C(118); C(101); C(32); C(76); C(48); C(32); C(76); C(95); C(99); C(117); C(115); C(112);\n    }\n#endif\n\n    return res;\n\n#undef F\n#undef I\n#undef C\n#undef CRLF\n}\n#endif\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef DEBUG_GAMUT_CLIP_COMPARISON\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    int id = int(mod(floor(uv.x * 14.), 7.));\n    vec3 color = fetch(fragCoord);\n\n    if(id > 0){\n        vec3 lab = linear_srgb_to_oklab(color);\n        lab = adjust_lab(lab);\n        color = oklab_to_linear_srgb(lab);\n\n        if(is_out_of_gamut(color)){\n            if(id == 1){\n                vec4 state_oklab = load_state(SID_OKLAB);\n                if(bool(state_oklab.x))\n                    lab = vec3(0.628, 0.225, 0.126); // Out of gamut.\n            }else if(id == 2){\n                lab = gamut_clip_preserve_chroma(lab);\n            }else if(id == 3){\n                lab = gamut_clip_project_to_0_5(lab);\n            }else if(id == 4){\n                lab = gamut_clip_project_to_L_cusp(lab);\n            }else if(id == 5){\n                lab = gamut_clip_adaptive_L0_0_5(lab, 0.05);\n            }else{\n                lab = gamut_clip_adaptive_L0_L_cusp(lab, 0.05);\n            }\n            color = oklab_to_linear_srgb(lab);\n        }\n    }\n\n    color = clamp(color, 0., 1.);\n\n    color *= smoothstep(0.006, 0.007, abs(fract(14. * uv.x + 0.5) - 0.5));\n#else\n    float vsep_pos = load_state(SID_SEPARATOR).x * iResolution.x;\n    vec3 color = fetch(fragCoord);\n    vec3 lab = linear_srgb_to_oklab(color);\n\n    lab = adjust_lab(lab);\n    color = oklab_to_linear_srgb(lab);\n\n    if(fragCoord.x > vsep_pos){\n        if(needs_clip(color)){\n            vec4 state_oklab = load_state(SID_OKLAB);\n\n            if(bool(state_oklab.x)){\n                lab = vec3(0.628, 0.225, 0.126); // Out of gamut.\n            }else{\n                int mode = int(state_oklab.y);\n\n                if(mode == 0){\n                    lab = gamut_clip_preserve_chroma(lab);\n                }else if(mode == 1){\n                    lab = gamut_clip_project_to_0_5(lab);\n                }else if(mode == 2){\n                    lab = gamut_clip_project_to_L_cusp(lab);\n                }else if(mode == 3){\n                    lab = gamut_clip_adaptive_L0_0_5(lab, 0.05);\n                }else{\n                    lab = gamut_clip_adaptive_L0_L_cusp(lab, 0.05);\n                }\n            }\n\n            color = oklab_to_linear_srgb(lab);\n        }\n    }\n\n    color = clamp(color, 0., 1.);\n\n    color *= vert_separator(fragCoord.x, vsep_pos);\n#endif\n\n#ifdef DEBUG_DISPLAY\n    vec4 state_debug = load_state(SID_DEBUG);\n    if(state_debug.x > 0.){\n        int txt = text(fragCoord);\n        color = mix(color, vec3(0., 1., 0.), float(txt));\n    }\n#endif\n    fragColor = vec4(linear_to_srgb(color), 1.);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define DEBUG_DISPLAY\n\n/** Enables debug mode for gamut clip comparison. */\n#define DEBUG_GAMUT_CLIP_COMPARISON\n\n#define ENABLE_PRECOMPUTED_CUSP\n\n#define SID_DEBUG     0\n#define SID_SEPARATOR 1\n#define SID_OKLAB     2\n\nconst float TAU = 6.2831853;\n\n//==============================================================================\n\nfloat atan2(in float y, in float x){\n    return x == 0. ? sign(y) * TAU / 4. : atan(y, x);\n}\n\nfloat cbrt(in float x){\n    return sign(x) * pow(abs(x), 1./3.);\n}\n\nvec3 cbrt(in vec3 x){\n    return sign(x) * pow(abs(x), vec3(1./3.));\n}\n\n//==============================================================================\n\nfloat srgb_to_linear(in float x){\n    return x <= 0.04045 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\n\nvec3 srgb_to_linear(in vec3 color){\n    return vec3(srgb_to_linear(color.r), srgb_to_linear(color.g), srgb_to_linear(color.b));\n}\n\nfloat linear_to_srgb(in float x){\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * pow(x, 1./2.4) - 0.055;\n}\n\nvec3 linear_to_srgb(in vec3 color){\n    return vec3(linear_to_srgb(color.r), linear_to_srgb(color.g), linear_to_srgb(color.b));\n}\n\n//==============================================================================\n// Oklab\n// https://bottosson.github.io/posts/oklab/\n//==============================================================================\n\nconst mat3 LINEAR_SRGB_TO_LMS = mat3(\n    0.4122214708, 0.2119034982, 0.0883024619,\n    0.5363325363, 0.6806995451, 0.2817188376,\n    0.0514459929, 0.1073969566, 0.6299787005\n);\n\nconst mat3 LMS_PRIME_TO_OKLAB = mat3(\n     0.2104542553,  1.9779984951,  0.0259040371,\n     0.7936177850, -2.4285922050,  0.7827717662,\n    -0.0040720468,  0.4505937099, -0.8086757660\n);\n\nconst mat3 LMS_TO_LINEAR_SRGB = mat3(\n     4.0767416621, -1.2684380046, -0.0041960863,\n    -3.3077115913,  2.6097574011, -0.7034186147,\n     0.2309699292, -0.3413193965,  1.7076147010\n);\n\nconst mat3 OKLAB_TO_LMS_PRIME = mat3(\n    1.,            1.,            1.,\n    0.3963377774, -0.1055613458, -0.0894841775,\n    0.2158037573, -0.0638541728, -1.2914855480\n);\n\nvec3 linear_srgb_to_lms_prime(in vec3 rgb){\n    vec3 lms = LINEAR_SRGB_TO_LMS * rgb;\n    return cbrt(lms);\n}\n\nvec3 linear_srgb_to_oklab(in vec3 rgb){\n    vec3 lms_prime = linear_srgb_to_lms_prime(rgb);\n    return LMS_PRIME_TO_OKLAB * lms_prime;\n}\n\nvec3 lms_prime_to_linear_srgb(in vec3 lms_prime){\n    vec3 lms = lms_prime * lms_prime * lms_prime;\n    return LMS_TO_LINEAR_SRGB * lms;\n}\n\nvec3 oklab_to_linear_srgb(in vec3 lab){\n    vec3 lms_prime = OKLAB_TO_LMS_PRIME * lab;\n    return lms_prime_to_linear_srgb(lms_prime);\n}\n\n//==============================================================================\n// sRGB gamut clipping\n// https://bottosson.github.io/posts/gamutclipping/\n//\n// ===\n// Important: The related functions have been modified for shader usage,\n// but the behavior adheres to the original.\n//==============================================================================\n\n/**\n * Halley's method\n * https://en.wikipedia.org/wiki/Halley%27s_method\n */\nfloat halley_step(in float f0, in float f1, in float f2){\n    return (f0 * f1) / (f1 * f1 - 0.5 * f0 * f2);\n}\n\nvec3 halley_step(in vec3 f0, in vec3 f1, in vec3 f2){\n    return (f0 * f1) / (f1 * f1 - 0.5 * f0 * f2);\n}\n\n/**\n * Finds the maximum saturation possible for a given hue that fits in sRGB\n * Saturation here is defined as S = C/L\n * a and b must be normalized so a^2 + b^2 == 1\n */\nfloat compute_max_saturation(in vec2 ab){\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    const vec2 r_dir = vec2(-1.88170328, -0.80936493);\n    const vec2 g_dir = vec2(1.81444104, -1.19445276);\n    const vec2 b_dir = vec2(0.13110758, 1.81333944);\n\n    float k0, k1, k2, k3, k4;\n    vec3 w_lms;\n\n    if(dot(r_dir, ab) > 1.){\n        // Red component\n        k0 = 1.19086277; k1 = 1.76576728; k2 = 0.59662641; k3 = 0.75515197; k4 = 0.56771245;\n        w_lms = vec3(LMS_TO_LINEAR_SRGB[0].x, LMS_TO_LINEAR_SRGB[1].x, LMS_TO_LINEAR_SRGB[2].x);\n    }else if(dot(g_dir, ab) > 1.){\n        // Green component\n        k0 = 0.73956515; k1 = -0.45954404; k2 = 0.08285427; k3 = 0.12541070; k4 = 0.14503204;\n        w_lms = vec3(LMS_TO_LINEAR_SRGB[0].y, LMS_TO_LINEAR_SRGB[1].y, LMS_TO_LINEAR_SRGB[2].y);\n    }else /*if(dot(b_dir, ab))*/{\n        // Blue component\n        k0 = 1.35733652; k1 = -0.00915799; k2 = -1.15130210; k3 = -0.50559606; k4 = 0.00692167;\n        w_lms = vec3(LMS_TO_LINEAR_SRGB[0].z, LMS_TO_LINEAR_SRGB[1].z, LMS_TO_LINEAR_SRGB[2].z);\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * ab.x + k2 * ab.y + k3 * ab.x * ab.x + k4 * ab.x * ab.y;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps\n\n    vec3 k_lms_prime = OKLAB_TO_LMS_PRIME * vec3(0., ab);\n\n    // The following is equivalent to `OKLAB_TO_LMS_PRIME * (1, S*ab)`.\n    vec3 lms_prime = 1. + S * k_lms_prime;\n\n    // lms, lms_dS, lms_dS2\n    mat3 lms = mat3(\n        lms_prime * lms_prime * lms_prime,\n        3. * k_lms_prime * lms_prime * lms_prime,\n        6. * k_lms_prime * k_lms_prime * lms_prime\n    );\n    vec3 f = w_lms * lms;\n\n    return S - halley_step(f.x, f.y, f.z);\n}\n\n/**\n * finds L_cusp and C_cusp for a given hue\n * a and b must be normalized so a^2 + b^2 == 1\n */\nvec2 find_cusp(in vec2 ab){\n\t// First, find the maximum saturation (saturation S = C/L)\n\tfloat S_cusp = compute_max_saturation(ab);\n\n\t// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n\tvec3 rgb_at_max = oklab_to_linear_srgb(vec3(1., S_cusp * ab));\n\tfloat L_cusp = cbrt(1. / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n\tfloat C_cusp = L_cusp * S_cusp;\n\n\treturn vec2(L_cusp, C_cusp);\n}\n\n/**\n * Finds intersection of the line defined by \n * L = L0 * (1 - t) + t * L1;\n * C = t * C1;\n * a and b must be normalized so a^2 + b^2 == 1\n */\nfloat find_gamut_intersection(in vec2 ab, in vec2 cusp, in float L1, in float C1, in float L0){\n\t// Find the intersection for upper and lower half seprately\n\tfloat t;\n\tif(((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.){\n\t\t// Lower half\n\t\tt = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n    }else{\n        // Upper half\n\n\t\t// First intersect with triangle\n\t\tt = cusp.y * (L0 - 1.) / (C1 * (cusp.x - 1.) + cusp.y * (L0 - L1));\n\n        // Then one step Halley's method\n\n        vec3 k_lms_prime = OKLAB_TO_LMS_PRIME * vec3(0., ab);\n        vec3 lms_prime = mix(L0, L1, t) + (t * C1) * k_lms_prime;\n        vec3 lms_prime_dt = (L1 - L0) + C1 * k_lms_prime;\n        vec3 lms = lms_prime * lms_prime * lms_prime;\n        vec3 lms_dt = 3. * lms_prime_dt * lms_prime * lms_prime;\n        vec3 lms_dt2 = 6. * lms_prime_dt * lms_prime_dt * lms_prime;\n\n        vec3 f = LMS_TO_LINEAR_SRGB * lms - 1.;\n        vec3 f1 = LMS_TO_LINEAR_SRGB * lms_dt;\n        vec3 f2 = LMS_TO_LINEAR_SRGB * lms_dt2;\n#if 0\n        // Basic approach.\n        vec3 _u = f1 / (f1 * f1 - 0.5 * f * f2);\n        vec3 _t = - f * _u;\n        _t.x = _u.x >= 0. ? _t.x : 3.402823466e+38;\n        _t.y = _u.y >= 0. ? _t.y : 3.402823466e+38;\n        _t.z = _u.z >= 0. ? _t.z : 3.402823466e+38;\n        t += min(_t.x, min(_t.y, _t.z));\n#else\n        vec3 _u = f1 / (f1 * f1 - 0.5 * f * f2);\n        vec3 _t = - f * _u;\n        _t *= 2. * step(0., _u) - 1.;\n        t += min(_t.x, min(_t.y, _t.z));\n#endif\n    }\n\n    return t;\n}\n\nbool is_out_of_gamut(in vec3 rgb){\n    const float eps = 1e-5;\n    return rgb.x < 0. - eps || rgb.y < 0. - eps || rgb.z < 0. - eps\n        || rgb.x > 1. + eps || rgb.y > 1. + eps || rgb.z > 1. + eps;\n}\n\n//==============================================================================\n// State buffer\n//==============================================================================\n\nconst ivec2 STATE_BUFFER_SIZE = ivec2(128);\n\nvec4 load_state(in sampler2D sampler, in int id){\n    ivec2 pos = ivec2(id % STATE_BUFFER_SIZE.x, id / STATE_BUFFER_SIZE.y);\n    return texelFetch(sampler, pos, 0);\n}\n\nint pos_to_sid(in ivec2 pos){\n    int factor = 1 - 2 * int(any(greaterThanEqual(pos, STATE_BUFFER_SIZE)));\n    return (pos.y * STATE_BUFFER_SIZE.x + pos.x) * factor;\n}\n\nbool can_store_state(in int id, in ivec2 pos){\n    return id == pos_to_sid(pos);\n}\n\n//==============================================================================\n\n#ifdef DEBUG_DISPLAY\n//\n// This font is based on the following work:\n// [Simple Bitmap Text - integers - iq] https://www.shadertoy.com/view/4s3fzl\n//\n\n/**\n * The data is based on the following 4x6 font.\n * http://www.massmind.org/techref/datafile/charset/extractor/charset_extractor.htm\n */\nconst int[95] FONT_DATA = int[](\n    0x000000, // \n    0x222020, // !\n    0x550000, // \"\n    0x575750, // #\n    0x236362, // $\n    0x412410, // %\n    0x253570, // &\n    0x640000, // '\n    0x244420, // (\n    0x422240, // )\n    0x527250, // *\n    0x027200, // +\n    0x000064, // ,\n    0x007000, // -\n    0x000020, // .\n    0x112440, // /\n    0x355560, // 0\n    0x262270, // 1\n    0x612470, // 2\n    0x612160, // 3\n    0x157110, // 4\n    0x746160, // 5\n    0x246520, // 6\n    0x713220, // 7\n    0x252520, // 8\n    0x253120, // 9\n    0x002020, // :\n    0x002064, // ;\n    0x124210, // <\n    0x007070, // =\n    0x421240, // >\n    0x612020, // ?\n    0x755470, // @\n    0x257550, // A\n    0x656560, // B\n    0x344430, // C\n    0x655560, // D\n    0x746470, // E\n    0x746440, // F\n    0x345530, // G\n    0x557550, // H\n    0x722270, // I\n    0x111520, // J\n    0x556550, // K\n    0x444470, // L\n    0x577550, // M\n    0x575550, // N\n    0x255520, // O\n    0x656440, // P\n    0x255730, // Q\n    0x656550, // R\n    0x347160, // S\n    0x722220, // T\n    0x555570, // U\n    0x555520, // V\n    0x557750, // W\n    0x552550, // X\n    0x552220, // Y\n    0x712470, // Z\n    0x644460, // [\n    0x442110, // back slash\n    0x622260, // ]\n    0x250000, // ^\n    0x00000F, // _\n    0x620000, // `\n    0x003570, // a\n    0x446560, // b\n    0x003430, // c\n    0x113530, // d\n    0x007630, // e\n    0x127220, // f\n    0x007517, // g\n    0x446550, // h\n    0x202220, // i\n    0x202226, // j\n    0x445650, // k\n    0x222220, // l\n    0x007750, // m\n    0x006550, // n\n    0x002520, // o\n    0x006564, // p\n    0x003531, // q\n    0x006440, // r\n    0x003260, // s\n    0x027230, // t\n    0x005570, // u\n    0x005520, // v\n    0x005770, // w\n    0x005250, // x\n    0x005524, // y\n    0x006230, // z\n    0x326230, // {\n    0x222220, // |\n    0x623260, // }\n    0x5A0000  // ~\n);\n\nconst ivec2 FONT_CELL_SIZE = ivec2(4, 6);\n\nconst int FONT_MAX_INT_DIGITS = 4; // Configure the integer maximum digit count from 1 to 10.\nconst int FONT_MAX_INT_PLACE = 1000; // 10^{MAX_INT_DIGITS-1}\n\nint font_draw_char(in int ascii, in vec2 pos, in vec2 size, in vec2 uv){\n    ascii -= 32;\n    if(ascii < 0 || ascii > 94)\n        return 0;\n\n    // Subtract our position from the current uv so that we can\n    // know if we're inside the bounding box or not.\n    uv -= pos;\n\n    // Divide the screen space by the size, so our bounding box is 1x1.\n    uv /= size;\n\n    // Multiply the UV by the bitmap size so we can work in\n    // bitmap space coordinates.\n    uv *= vec2(FONT_CELL_SIZE);\n\n    // Compute bitmap texel coordinates\n    ivec2 iuv = ivec2(round(uv));\n\n\t// Bounding box check. With branches, so we avoid the maths and lookups    \n    if(iuv.x < 0 || iuv.x >= FONT_CELL_SIZE.x || iuv.y < 0 || iuv.y >= FONT_CELL_SIZE.y)\n        return 0;\n\n    // Compute bit index\n    iuv.x = FONT_CELL_SIZE.x - 1 - iuv.x;\n    int index = FONT_CELL_SIZE.x * iuv.y + iuv.x;\n\n    // Get the appropriate bit and return it.\n    return (FONT_DATA[ascii] >> index) & 0x1;\n}\n\nint font_draw_decimal(in uint x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    uint place = uint(FONT_MAX_INT_PLACE);\n    float spacing = 1.25 * size.x; // 1.25 = (MAP_SIZE.x+1) / MAP_SIZE.x\n\n    for(int i = FONT_MAX_INT_DIGITS - 1; i >= 0; i--){\n        uint quotient = x / place;\n        if(quotient > 0u || i < min_digits){\n            uint digit = quotient % 10u;\n            res |= font_draw_char(int(48u + digit), pos, size, uv);\n            pos.x += spacing;\n        }\n        place /= 10u;\n    }\n\n    return res;\n}\n\nint font_draw_decimal(in int x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n\n    if(x < 0){\n        res |= font_draw_char(45, pos, size, uv);\n        x = -x;\n        pos.x += 1.25 * size.x;\n    }\n\n    res |= font_draw_decimal(uint(x), pos, size, uv, min_digits);\n\n    return res;\n}\n\nint font_draw_decimal(in float x, inout vec2 pos, in vec2 size, in vec2 uv, in int min_digits){\n    int res = 0;\n    float spacing = 1.25 * size.x;\n\n    if(x < 0.){\n        res |= font_draw_char(45, pos, size, uv);\n        x = -x;\n        pos.x += spacing;\n    }\n\n    float fx, ix;\n    fx = modf(x, ix);\n\n    res |= font_draw_decimal(uint(ix), pos, size, uv, 1);\n\n    res |= font_draw_char(46, pos, size, uv);\n    pos.x += spacing;\n\n    res |= font_draw_decimal(uint(pow(10., float(min_digits)) * fx), pos, size, uv, min_digits);\n\n    return res;\n}\n\nvec2 text_size(in float base_dim, in float fs){\n    return fs * vec2(FONT_CELL_SIZE) / base_dim;\n}\n\nvec2 text_spacing(in float base_dim, in float fs){\n    return fs * vec2(FONT_CELL_SIZE + 1) / base_dim;\n}\n\nvec2 text_pos(in vec2 p, in float s){\n    p.y -= s;\n    return p;\n}\n\nvoid text_advance_to(inout vec2 p, in float spacing){\n    p.x += spacing;\n}\n\nvoid text_newline(inout vec2 p, in float left, in float spacing){\n    p.x = left;\n    p.y -= spacing;\n}\n#endif // DEBUG_DISPLAY\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n#define KEY_SPACE   32\n#define KEY_LEFT    37\n#define KEY_UP      38\n#define KEY_RIGHT   39\n#define KEY_DOWN    40\n#define KEY_F1     112\n#define KEY_COMMA  188\n#define KEY_PERIOD 190\n\nvec4 load_state(in int id){\n    return load_state(iChannel0, id);\n}\n\nbool is_mouse_down(){\n    return iMouse.z > 0.;\n}\n\nbool is_key_pressed(int code){\n    return texelFetch(iChannel1, ivec2(code, 1), 0).x > 0.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    ivec2 pos = ivec2(fragCoord);\n    vec4 state;\n\n    if(can_store_state(SID_DEBUG, pos)){\n        state = load_state(SID_DEBUG);\n        if(iFrame > 0){\n            if(is_key_pressed(KEY_F1)){\n                state.x = float(!bool(state.x));\n            }\n        }else{\n            state = vec4(1.);\n        }\n    }else if(can_store_state(SID_SEPARATOR, pos)){\n        state = load_state(SID_SEPARATOR);\n        if(iFrame > 0){\n            if(is_mouse_down()){\n                state.x = iMouse.x / iResolution.x;\n            }\n        }else{\n            state = vec4(0.5, 0., 0., 0.);\n        }\n    }else if(can_store_state(SID_OKLAB, pos)){\n        state = load_state(SID_OKLAB);\n        if(iFrame > 0){\n            if(is_key_pressed(KEY_SPACE)){\n                state.x = float(!bool(state.x));\n            }\n        \n            int mode = int(state.y);\n            if(is_key_pressed(KEY_LEFT)){\n                mode--;\n            }\n            if(is_key_pressed(KEY_RIGHT)){\n                mode++;\n            }\n            state.y = float(clamp(mode, 0, 4));\n        }else{\n            state = vec4(0.);\n        }\n    }else{\n        discard;\n    }\n\n    fragColor = state;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef ENABLE_PRECOMPUTED_CUSP\n    vec2 cusp;\n\n    if(iFrame > 0){\n        cusp = texture(iChannel0, fragCoord / iResolution.xy).rg;\n    }else{\n        if(fragCoord.x < 362. && fragCoord.y < 100.){\n            float angle = mod(floor(fragCoord.x), 361.);\n            float hue = (angle - 180.) / 360. * TAU;\n            cusp = find_cusp(vec2(cos(hue), sin(hue)));\n        }else{\n            discard;\n        }\n    }\n\n    fragColor = vec4(cusp, 0., 0.);\n#else\n    discard;\n#endif\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\nvec3 fetch(in vec2 pos){\n    return srgb_to_linear(texture(iChannel0, pos / iResolution.xy).rgb);\n}\n\n//==============================================================================\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n#ifdef DEBUG_GAMUT_CLIP_COMPARISON\n    vec2 t = fragCoord / iResolution.xy;\n    vec3 l = oklab_to_linear_srgb(mix(vec3(-.1, 0., 0.), vec3(1.1, 0., 0.), t.y));\n    vec3 lch = mix(vec3(0.88, 0.12, 0.), vec3(0.88, 0.12, TAU), t.y);\n    vec3 r = oklab_to_linear_srgb(vec3(lch.x, lch.y * cos(lch.z), lch.y * sin(lch.z)));\n    vec3 color = mix(l, r, step(0.5 * iResolution.x, fragCoord.x));\n#else\n    vec3 color = fetch(fragCoord);\n#endif\n    fragColor = vec4(color, 1.);\n}\n","name":"Buffer C","description":"","type":"buffer"}]}