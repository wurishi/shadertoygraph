{"ver":"0.1","info":{"id":"McK3Dm","date":"1712868801","viewed":42,"name":"FSR Bacchanale","username":"grandevul","description":"my classwork and homework","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fsr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 background_color = vec4(0.0, 0.0, 0.0, 0.0);\n \nvec4 error_color = vec4(0.1, 0.1, 0.2, 1.0);\n \nfloat ball1[4] = float[4](0.4, 0.5, 0.6, 0.2);\nvec4 color1 = vec4(0.9, 0.1, 0.1, 1.0);\n \nfloat tetrahedron2[12] = float[12](0.5, 0.5, 0.15,    0.45, 0.3, 0.2,    0.6, 0.08, 0.3,    0.3, 0.1, 0.4);\nvec4 color2[4] = vec4[4](vec4(0.9, 0.9, 0.04, 1.0), vec4(0.5, 0.9, 0.34, 1.0), vec4(0.9, 0.5, 0.34, 1.0), vec4(0.3, 0.5, 0.04, 1.0));\n\nfloat triangle3[9] = float[9](0.22, 0.3, 0.3,    0.3, 0.65, 0.8,    0.4, 0.4, 0.1);\nvec4 color3 = vec4(0.43, 0.9, 0.8, 1.0);\n\nfloat triangle4[9] = float[9](0.42, 0.43, 0.2,    0.4, 0.95, 1.2,    0.6, 0.6, 0.1);\nvec4 color4 = vec4(0.03, 0.51, 0.6, 1.0);\n\nfloat triangle5[9] = float[9](0.62, 0.63, 0.51,    0.4, 0.25, 0.7,    0.8, 0.02, 1.2);\nvec4 color5 = vec4(0.73, 0.1, 0.9, 1.0);\n \nvoid depth_ball1_update( in float z1 )\n{\n    color1[0] = (((color1[0])/ball1[2]) * (ball1[2]-z1+0.1) * 2.0);\n    color1[1] = (((color1[1])/ball1[2]) * (ball1[2]-z1+0.1) * 2.0);\n    color1[2] = (((color1[2])/ball1[2]) * (ball1[2]-z1+0.1) * 2.0);\n}\n\nvoid depth_triangle4_update( in float z1, out vec4 color )\n{\n    float len = abs(triangle4[2] - ball1[2]);\n    float c0 = 6.0;\n    float c2 = 1.5;\n    color[0] = ((((color[0])/len) * (ball1[2]-z1) / c0)+0.02)*c2;\n    color[1] = ((((color[1])/len) * (ball1[2]-z1) / c0)+0.02)*c2;\n    color[2] = ((((color[2])/len) * (ball1[2]-z1) / c0)+0.52)*c2;\n}\n\nvoid color_triangle_update(out vec4 color, in vec2 uv, in float triangle[9] )\n{\n    float c0 = 0.04;\n    float c1 = 6.0;\n    float c2 = 1.5;\n    float c3 = 7.4;\n    \n    vec3 abc = vec3(0.0, 0.0, 0.0);\n    abc.x = abs(uv.x-triangle[0]);\n    abc.y = abs(uv.y-triangle[1]);\n    \n    float diam = sqrt(abc.x*abc.x + abc.y*abc.y)*12.0;\n    color[0] = floor(abs(sin((color[0]+diam))*c3))/c3+c0;\n    color[1] = floor(abs(sin((color[1]+diam))*c3))/c3+c0;\n    color[2] = floor(abs(sin((color[2]+diam))*c3))/c3+c0;\n}\n \nint leftturn( in float x1, in float y1, in float x2, in float y2, in vec2 c)\n{\n    float tmp = (c.y - y1)*(x2 - x1) - (c.x - x1)*(y2 - y1);\n    if (tmp > 0.0) return 1;\n    else if (tmp < 0.0) return -1;\n    else return 0;\n}\n\nvec3 vector_multi( in vec3 a, in vec3 b )\n{\n    vec3 c = vec3(0, 0, 0);\n    c.x = (a.y*b.z - a.z*b.y);\n    c.y = -(a.x*b.z - a.z*b.x);\n    c.z = (a.x*b.y - a.y*b.x);\n    return c;\n}\n\nfloat depth_triangle( in vec2 uv, in float triangle[9] )\n{\n    float z = 101.0;\n    int ans = 0;\n    for (int i = 0; i < 3; i++)\n    {\n        int j = (i+1)%3;\n        ans += leftturn(triangle[3*i], triangle[3*i+1],\n            triangle[3*j], triangle[3*j+1], uv);\n    }\n    //if (abs(ans) == 3 && triangle[0] == 0.1) return 1.0;\n    if (abs(ans)== 3)\n    {\n        vec3 abc = vector_multi(vec3(triangle[3]-triangle[0], triangle[4]-triangle[1], triangle[5]-triangle[2]),\n                               vec3(triangle[6]-triangle[0], triangle[7]-triangle[1], triangle[8]-triangle[2]));\n        float d = -(abc.x*triangle[0] + abc.y*triangle[1] + abc.z*triangle[2]);\n        //ax + by + cz + d = 0;\n        z = -(abc.x*uv.x + abc.y*uv.y + d)/abc.z;\n    }\n    return z;\n}\n\nvec4 set_color( in vec2 uv )\n{\n    float zb = 14.1;//+sin(iTime)/40.0; // must be less than 100.0\n \n    float z1 = 101.0;\n    if ( (uv.x - ball1[0])*(uv.x - ball1[0]) + (uv.y - ball1[1])*(uv.y - ball1[1]) <= ball1[3]*ball1[3] )\n    {\n        z1 = ball1[3]*ball1[3] - (uv.x - ball1[0])*(uv.x - ball1[0]) - (uv.y - ball1[1])*(uv.y - ball1[1]);\n        z1 = ball1[2] - sqrt(z1);\n    }\n    \n    float z2 = 101.0;\n    int color_face = -1;\n    {\n        float ar[9] = float[9](0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n        for (int i = 0; i < 4; i++)\n        {\n            for (int h = 0; h < 3; h++)\n            {\n                ar[h] = tetrahedron2[i*3+h];\n            }\n            for (int j = i+1; j < 4; j++)\n            {\n                for (int h = 0; h < 3; h++)\n                {\n                    ar[3+h] = tetrahedron2[j*3+h];\n                }\n                for (int g = j+1; g < 4; g++)\n                {\n                    for (int h = 0; h < 3; h++)\n                    {\n                        ar[6+h] = tetrahedron2[g*3+h];\n                    }\n                    float ff = depth_triangle(uv, ar);\n                    if (z2 > ff)\n                    {\n                        color_face = i+j+g-3;\n                        //if (color_face == 1 && ff < z2) return color2[0];\n                    }\n                    z2 = min(z2, ff);\n                }\n            }\n        }\n    }\n    //if (z2 < 101.0) return color2[0];\n    \n    float z3 = depth_triangle(uv, triangle3);\n    color_triangle_update(color3, uv, triangle3);\n    \n    float z4 = depth_triangle(uv, triangle4);\n    depth_triangle4_update(z4, color4);\n    \n    float z5 = depth_triangle(uv, triangle5);\n    color_triangle_update(color5, uv, triangle5);\n    \n    float mn = 0.0;\n    {\n        mn = min(z1, z2);\n        mn = min(mn, z3);\n        mn = min(mn, z4);\n        mn = min(mn, z5);\n        mn = min(mn, zb);\n    }\n    \n    if (z1 == mn)\n    {\n        depth_ball1_update(z1);\n        return color1;\n    }\n    else if (z2 == mn)\n    {\n        return color2[color_face];\n    }\n    else if (z3 == mn)\n    {\n        return color3;\n    }\n    else if (z4 == mn)\n    {\n        return color4;\n    }\n    else if (z5 == mn)\n    {\n        return color5;\n    }\n    else if (z1 > 100.0 && z2 > 100.0 && z3 > 100.0 && z4 > 100.0 && z5 > 100.0) return background_color;\n    else return error_color;\n}\n\nvoid update_triangle( out float triangle[9] , in float c2, in float shift )\n{\n    float x = iTime + shift;\n    triangle[0] += sin(x)/c2;\n    triangle[1] += cos(x)/c2;\n    triangle[3] += sin(x)/c2;\n    triangle[4] += cos(x)/c2;\n    triangle[6] += sin(x)/c2;\n    triangle[7] += cos(x)/c2;\n}\n\nvoid update_tetrahedron( out float tetrahedron[12] , in float c2, in float shift )\n{\n    float x = iTime + shift;\n    tetrahedron[0] += sin(x)/c2;\n    tetrahedron[1] += cos(x)/c2;\n    tetrahedron[2] += cos(x)/c2;\n    tetrahedron[3] += 3.0*sin(x)/c2;\n    tetrahedron[4] += 3.0*cos(x)/c2;\n    tetrahedron[5] += sin(x)/c2/2.0;\n    tetrahedron[6] += sin(x)/c2;\n    tetrahedron[7] += cos(x)/c2;\n    tetrahedron[8] += cos(x)/c2;\n    tetrahedron[9] += sin(x)/c2;\n    tetrahedron[10] += cos(x)/c2;\n    tetrahedron[11] += cos(x)/c2;\n}\n\nvoid update()\n{\n    float c1 = 20.0;\n    ball1[0] += cos(iTime)/c1;\n    ball1[1] += sin(iTime)/c1;\n    ball1[2] += sin(iTime)/c1*2.0;\n    \n    update_tetrahedron(tetrahedron2, 6.0, 0.0);\n    \n    update_triangle(triangle3, 6.0, 0.0);\n    update_triangle(triangle4, 8.0, 7.0);\n    update_triangle(triangle5, 10.0, 1.0);\n    triangle4[5] += cos(iTime+12.0);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n \n    // Output to screen\n    \n    update();\n    \n    fragColor = vec4(set_color(uv));\n}","name":"Image","description":"","type":"image"}]}