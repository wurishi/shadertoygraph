{"ver":"0.1","info":{"id":"4fXcD2","date":"1721581465","viewed":18,"name":"Kirby on chessboard","username":"zhangrm","description":"ref: https://www.shadertoy.com/view/lt2Bz3\n     https://www.shadertoy.com/view/7sBGzK\n     https://www.shadertoy.com/view/lt2fD3\n     https://www.shadertoy.com/view/lclcW8\n    ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","kirby"],"hasliked":0,"parentid":"lclcW8","parentname":"[ARTS1308] Reflection Refraction"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HORN 2.\nconst int MAX_MARCHING_STEPS = 255;\nconst int MAX_SHADOW_STEPS = 15;\nconst vec3 pink = vec3(0.917,0.482,0.663);\nconst vec3 red = vec3(0.825,0.142,0.111);\nconst vec3 beige = vec3(0.905, 0.670, 0.235);\nconst vec3 blue = vec3(0.058, 0.074, 0.560);\nconst vec3 blueSky = vec3(0.741, 0.941, 1);\nconst vec3 green1 = vec3(0.298,0.830,0.153);\nconst vec3 green2 = vec3(0.038,0.260,0.047);\nconst vec3 gold = vec3(1, 0.858, 0.058);\nvoid rot2d(inout vec2 p, float t)\n{\n    float ct = cos(t), st = sin(t);\n    vec2 q = p;\n    p.x = ct * q.x + st * q.y;\n    p.y = -st * q.x + ct * q.y;\n}\n\nconst float PRECISION = 1e-4;\nconst float MAX_DIST = 100.0;\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sabs(float x, float k)\n{\n    if (x <= 0.)\n        return sqrt(x * x + k) - 0.1;\n    else return x;\n}\n\nfloat smax(float a, float b, float k)\n{\n    return -smin(-a, -b, k);\n}\n\nmat2 rotmat(float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n//ref:https://www.shadertoy.com/view/lt2fD3\nfloat shoesDist(vec3 p)\n{\n    vec3 op = p;\n    float d = 1e4;\n    p.y -= .5;\n\n    // right shoe\n    op = p;\n    p -= vec3(-.45, -.9, -.6);\n    p.yz = rotmat(-.7) * p.yz;\n    p.xz = rotmat(0.1) * p.xz;\n    d = min(d, -smin(p.y, -(length(p * vec3(1.6, 1, 1)) - .64), .2));\n    p = op;\n\n    // left shoe\n    op = p;\n    p -= vec3(.55, -.8, 0.4);\n    p.x = -p.x;\n    p.yz = rotmat(1.4) * p.yz;\n    d = min(d, -smin(p.y, -(length(p * vec3(1.6, 1, 1)) - .73), .2));\n    p = op;\n\n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat torusDist(vec3 p, float size)\n{\n    vec3 op = p;\n    float d = 1e4;\n    p.y -= .5;\n    p.yz = rotmat(.2) * p.yz;\n    float horn = sdTorus(p, vec2(size, 0.1));\n    d = min(d, horn);\n\n    return min(d, 10.);\n}\n//ref:https://www.shadertoy.com/view/lt2fD3\nfloat bodyDist(vec3 p)\n{\n    vec3 op = p;\n    float d = 1e4;\n    p.y -= .5;\n\n    // torso\n    d = min(d, length(p) - 1.);\n\n    // left arm\n    op = p;\n    p -= vec3(.75, .2, 0);\n    d = smin(d, (length(p * vec3(1, 1.5, 1)) - .54), .03);\n    p = op;\n\n    // right arm\n    op = p;\n    p -= vec3(-.75, 0.2, 0);\n    d = smin(d, (length(p * vec3(1, 1.5, 1)) - .54), .03);\n    p = op;\n\n    // mouth\n    p.y += .2;\n    float md = smax(p.z + .84, smax(smax(p.x - .2, p.y - .075, .2), dot(p, vec3(.7071, -.7071, 0)) - .1, .08), .04);\n    p.x = -p.x;\n    md = smax(md, smax(p.z + .84, smax(smax(p.x - .2, p.y - .075, .2), dot(p, vec3(.7071, -.7071, 0)) - .1, .08), .01), .13);\n    d = smax(d, -md, .012);\n\n    // tongue\n    p = op;\n    d = smin(d, length((p - vec3(0, .03, -.75)) * vec3(1, 1, 1)) - .16, .01);\n\n    return min(d, 10.);\n}\n\nfloat roundCone(vec3 p, float r1, float r2, float h)\n{\n    vec2 q = vec2(length(p.xz), p.y);\n    float b = (r1 - r2) / h;\n    float a = sqrt(1. - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if (k < 0.) return length(q) - r1;\n    if (k > a * h) return length(q - vec2(.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\n//ref:https://www.shadertoy.com/view/7sBGzK\nfloat hornDist(vec3 p)\n{\n    vec3 op = p;\n    float d = 1e4;\n    p.y -= .5;\n\n    float rotationAngle = 1.5707963268; \n\n    p.xy = rotmat(rotationAngle) * p.xy;\n    p.yz = rotmat(rotationAngle) * p.yz;\n    p.xy = rotmat(1.) * p.xy;\n    op = p;\n    op.x -= 1.;\n    p = op + vec3(2.45, .1, 0);\n    rot2d(p.xy, .1);\n    p.z = sabs(p.z, .1) - .7;\n    rot2d(p.xz, 1.);\n    p.x += .3 * sin(p.z * 5. + 7.5);\n    p.y -= .06 * sin(p.z * 7.);\n    float horn = roundCone(vec3(p.x, -p.z, p.y + .1), .013, .15, .9) / 2.5;\n    d = min(d, horn) / 1.5;\n\n    return min(d, 10.);\n}\n\nstruct Material {\n    vec3 ambientColor; // k_a * i_a\n    vec3 diffuseColor; // k_d * i_d\n    vec3 specularColor; // k_s * i_s\n    float alpha; // shininess\n};\n\nstruct Surface {\n    int id; // id of object\n    float sd; // signed distance\n    Material mat;\n};\n\nMaterial shoesMaterial() {\n    vec3 aCol = 0.3 * vec3(0.8, 0.1, 0.1);\n    vec3 dCol = 0.7 * vec3(1.0, 0.2, 0.2); \n    vec3 sCol = 0.6 * vec3(1.0, 0.6, 0.6); \n    float a = 32.0; \n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial hornMaterial() {\n    vec3 aCol = 0.2 * vec3(0.2, 0.1, 0.05);\n    vec3 dCol = 0.5 * vec3(0.4, 0.2, 0.1); \n    vec3 sCol = 0.3 * vec3(0.5, 0.4, 0.3); \n    float a = 16.0;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial bodyMaterial() {\n    vec3 aCol = 0.3 * vec3(1.0, 0.4, 0.7); \n    vec3 dCol = 0.7 * vec3(1.0, 0.6, 0.8); \n    vec3 sCol = 0.9 * vec3(1.0, 0.8, 0.9);\n    float a = 32.0;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial haloMaterial() {\n    vec3 aCol = 0.8 * vec3(1.0, 0.9, 0.6); \n    vec3 dCol = 0.9 * vec3(1.0, 0.9, 0.7); \n    vec3 sCol = 1.0 * vec3(1.0, 1.0, 0.9); \n    float a = 128.0; \n\n    return Material(aCol, dCol, sCol, a);\n}\n\nMaterial checkerboard(vec3 p) {\n    vec3 aCol = 0.5 + 0.5 * vec3(-1. + mod(floor(p.x) + floor(p.z), 2.0));\n    vec3 dCol = vec3(0.3);\n    vec3 sCol = vec3(0);\n    float a = 1.;\n\n    return Material(aCol, dCol, sCol, a);\n}\n\nSurface opUnion(Surface obj1, Surface obj2) {\n    if (obj2.sd < obj1.sd) return obj2;\n    return obj1;\n}\n\nSurface scene(vec3 p) {\n    Surface sFloor = Surface(1, p.y + 1., checkerboard(p));\n    Surface shoes = Surface(2, shoesDist(p), shoesMaterial());\n    Surface body = Surface(3, bodyDist(p), bodyMaterial());\n    Surface horn = Surface(4, hornDist(p), hornMaterial());\n    float timeFactor = 0.25 * sin(iTime) + 0.75; \n    Surface halo = Surface(5, torusDist(p-vec3(0.,1.4,0.), timeFactor), haloMaterial());\n    //Surface eye = Surface(6,length(mp - vec3(.8, 2.4, -2.3)) - .7, hornMaterial());\n    Surface co = opUnion(sFloor, shoes); // closest object\n    co = opUnion(co, body);\n    co = opUnion(co, horn);\n    co = opUnion(co, halo);\n    //co = opUnion(co, eye);\n    return co;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n    float depth = 0.0;\n    Surface co; // closest object\n\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = scene(p);\n        depth += co.sd;\n        if (co.sd < PRECISION || depth > MAX_DIST) break;\n    }\n\n    co.sd = depth;\n\n    return co;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005;\n    return normalize(\n        e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n    vec3 cd = normalize(lookAtPoint - cameraPos); // camera direction\n    vec3 cr = normalize(cross(vec3(0, 1, 0), cd)); // camera right\n    vec3 cu = normalize(cross(cd, cr)); // camera up\n\n    return mat3(-cr, cu, -cd);\n}\n\nvec3 phong(vec3 lightDir, float lightIntensity, vec3 normal, vec3 rd, Surface co) {\n    // background\n    vec3 bgColor = vec3(.9, .5, .6);\n    //bgColor = vec3(0.5);\n    if (co.sd > MAX_DIST) return bgColor;\n\n    // ambient\n    vec3 ambient = co.mat.ambientColor;\n\n    // diffuse\n    float dotLN = clamp(dot(-lightDir, normal), 0., 1.);\n    vec3 diffuse = co.mat.diffuseColor * dotLN;\n\n    // specular\n    float dotRV = clamp(dot(reflect(lightDir, normal), -rd), 0., 1.);\n    vec3 specular = co.mat.specularColor * pow(dotRV, co.mat.alpha);\n\n    vec3 col = lightIntensity * (ambient + diffuse + specular);\n\n    // fog\n    col = mix(col, bgColor, 1.0 - exp(-0.0002 * co.sd * co.sd * co.sd));\n    return col;\n}\n\n//from iq\nfloat softShadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).sd;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s );\n        t += clamp( h, 0.01, 0.2 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0);\n\n    vec3 lp = vec3(0); // lookat point (aka camera target)\n    vec3 ro = vec3(1. * cos(0.2*iTime), .5+.5*cos(0.5*-iTime), -5. +.5 * sin(.7*-iTime));\n\n    vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n    Surface co = rayMarch(ro, rd); // closest object\n\n    vec3 p = ro + rd * co.sd; // point on surface found by ray marching\n    vec3 normal = calcNormal(p); // surface normal\n    if (co.id == 5) {\n        float timeFactor = 0.5 * sin(iTime) + 0.5; \n        float glow = exp(-4.0 * co.sd) * timeFactor; \n        vec3 rainbowColor = 0.5 + 0.5 * vec3(sin(iTime + 0.0), sin(iTime + 2.0), sin(iTime + 4.0)); // Rainbow effect\n        col += rainbowColor * glow; \n    }\n    // light\n    vec3 lightPosition = 4. * vec3(cos(-iTime), 3., -3.+1.*sin(-iTime));\n    vec3 lightDirection = normalize(p - lightPosition);\n    float lightIntensity = 0.8;\n\n    // phong light model\n    col = phong(lightDirection, lightIntensity, normal, rd, co);\n\n    // Soft shadow from iq\n    if (co.id == 1 && co.sd < 0.2 * MAX_DIST) {\n        float shadowFactor = softShadow(p, -lightDirection, PRECISION, length(p - lightPosition));\n        col *= shadowFactor;\n    }\n\n    //ref:https://www.shadertoy.com/view/lt2Bz3\n    //eyes\n    vec3 pos = p;\n    p.y -= .7;\n    p.y *= 1./smoothstep(.0,.1,abs(sin(iTime)));\n    p.x = abs(p.x) - .2;\n    p.x *= 2.;\n    p.y *= .75;\n    col = mix(col, vec3(0), step(length(p.xy), .2));\n    p.y -= .1;\n    p.y *= 1.6;\n    col = mix(col, vec3(1), step(length(p.xy), .1));\n    p.y += .2;\n    p.x *= .75;\n    p.y *= .4;\n    col = mix(col, blue, clamp(-p.y*10.,0.,1.)*step(length(p.xy), .1));\n    //cheeks\n    p = pos;\n    p.y-=0.4;\n    p.x = abs(p.x) - .5;\n    p *= 6.;\n    p.x *= .75;\n    col = mix(col, red, .75*(1.-smoothstep(0.5,1.,length(p.xy))));\n\n\n    col = pow(col, vec3(1.0 / 2.2)); // Gamma correction\n    fragColor = vec4(col, 1.0); // Output to screen\n}\n\n","name":"Image","description":"","type":"image"}]}