{"ver":"0.1","info":{"id":"MtVfRt","date":"1545593425","viewed":154,"name":"Nanoforge","username":"mensab","description":"Returning to raymarching stuff for a bit and trying to get creative with the mandelbox. This shader has been gathering dust in my drafts for a couple of weeks now so I figured I'd just polish it now and submit it.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST .2\n#define MAX_DIST 20.\n#define MAX_MARCHING_STEPS 400\n#define EPS .001\n\nfloat mbox(vec3 p) {\n    //  params\n    float s = -2.2;\n    float f = 1.1;\n    float r = 3.;\n    float r_min = 0.;\n    \n    float dr = 1.;\n    vec3 off = p;\n    for (float i = 0.; i < 10.; i++) {\n        \n        //  box fold\n        p = clamp(p, -f, f) * 2. - p;\n        \n        // sphere fold\n        float p2 = dot(p, p);\n        if (p2 < r_min)\n        {\n            p *= r / r_min;\n            dr *= r / r_min;\n        }\n        else if (p2 < r)\n        {\n            p *= r / p2;\n            dr *= r / p2;\n        }\n            \n        p = s * p + off;\n        dr = dr * abs(s) + 1.;\n    }\n    return length(p) / abs(dr);\n}\n\nfloat scene(vec3 p) {\n    //  mirror\n    p.xz = abs(p.xz);\n    \n    //  repeat\n    float c = 4.4;\n    p = mod(p, c) - .5 * c;\n    \n    //  rotate\n    float theta = .051 * iTime;\n    mat4 rot = mat4(cos(theta), 0., sin(theta), 0.,\n                    0., 1., 0., 0.,\n                    -sin(theta), 0., cos(theta), 0.,\n                    0., 0., 0., 1.);\n    p = vec3(rot * vec4(p, 0.));\n\n    return mbox(p);\n}\n\nfloat raymarch(vec3 cam_pos, vec3 march_dir) {\n    float depth = MIN_DIST;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = scene(cam_pos + depth * march_dir);\n        if (dist < EPS) {\n            return depth;\n        }\n        depth += dist;\n        if (depth >= MAX_DIST) {\n            return MAX_DIST;\n        }\n    }\n    return MAX_DIST;\n}\n\nvec3 normal(vec3 p) {\n    vec2 eps = vec2(EPS, 0.);\n    return normalize(vec3(scene(p + eps.xyy) - scene(p - eps.xyy),\n                          scene(p + eps.yxy) - scene(p - eps.yxy),\n                          scene(p + eps.yyx) - scene(p - eps.yyx)));\n}\n\nvec3 cam_dir(float fov, vec2 uv) {\n    vec2 xy = (uv * iResolution.xy) - iResolution.xy / 2.0;\n    float z = iResolution.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 dir = cam_dir(120., uv);\n    vec3 cam_pos = vec3(0., 0., 0.);\n    float dist = raymarch(cam_pos, dir);\n    \n\tvec3 p = cam_pos + dist * dir;\n    vec3 n = normal(p);\n    float i = pow(1. - pow(dot(n, dir), 2.), 6.);\n    float v = dist / MAX_DIST;\n    \n    //  diffuse\n    vec3 col = vec3(0.);\n    \n    //  pulse\n    float pf = 4. * iTime;\n    float pd = .15;\n    float pw = 250.;\n    \n    vec3 pulse1 = vec3(0., 1., 5.) * 1. - pow(v, 4.);\n    float pc1 = pow(pow(sin((p.z - pf) * pd), 2.), 4. * pw);\n    col = mix(col, pulse1, pc1);\n    \n    vec3 pulse2 = vec3(5., .75, 0.);\n    float pc2 = pow(pow(sin((p.z - pf) * pd), 2.), pw);\n    col = mix(col, pulse2, i * pc2);\n    \n    //  fog/distance field\n    vec3 dist_col = vec3(.3 * pow(1. - v, 2.), .7 * (1. - v), 2. * (1. - v));\n    col = mix(col, dist_col, v);\n    \n    //  screen flash\n    col = mix(col, pulse2, pow(pow(sin((pf) * pd), 2.), 2. * pw));\n    col = mix(col, pulse1, pow(pow(sin((pf) * pd), 2.), 8. * pw));\n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}