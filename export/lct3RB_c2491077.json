{"ver":"0.1","info":{"id":"lct3RB","date":"1711859090","viewed":45,"name":"Fastaro Fractal","username":"robfast","description":"fractal I discovered I wanted to look more into","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["floor","fraction","pythagorean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Scale and translate the coordinate system to fit the fractal\n    vec2 baseC = (uv - 0.5) * vec2(4.0, 4.0) + vec2(0.0, 0.0);\n\n    // Initialize variables for averaging color\n    vec3 avgColor = vec3(0.7);\n    int samples = 12; // Number of samples for anti-aliasing\n    float offset = 2.0 / iResolution.x; // Small offset for sampling neighboring pixels\n\n    // Loop over a small grid around the pixel to average the results\n    for(int dx = -1; dx <= 2; dx += 2) {\n        for(int dy = -1; dy <= 2; dy += 2) {\n            vec2 c = baseC + vec2(float(dx), float(dy)) * offset;\n            vec2 z = vec2(0.0, 0.0);\n\n            // Parameters for the fractal\n            float p = 2.0 + sin(iTime) * -0.5; // Oscillate p over time\n            float q = 3.0 + cos(iTime) * -0.5; // Oscillate q over time\n            int maxIter = 6;\n            float threshold = 2000.0; // Adjusted escape radius\n\n            int iter;\n            for(iter = 0; iter < maxIter; ++iter)\n            {\n                float x = z.x;\n                float y = z.y;\n\n                // Real and imaginary parts of the function\n                float realPart = pow(p, x) / pow(q, floor((x * log(p)) / log(q)));\n                float imagPart = pow(p, y) / pow(q, floor((y * log(p)) / log(q)));\n\n                z.x = realPart - imagPart + c.x;\n                z.y = 2.0 * x * y + c.y;\n\n                if(dot(z, z) > threshold)\n                    break;\n            }\n\n            // Adjusted color calculation for each sample\n            float smoothIter = iter == maxIter ? 0.0 : float(iter) / float(maxIter);\n            smoothIter = smoothIter + 1.0 - log(log(length(z))) / log(2.0);\n            vec3 color = mix(vec3(0.5, 0.5, 0.5), vec3(sin(smoothIter * 6.28 + iTime), cos(smoothIter * 6.28 + iTime), sin(smoothIter * 6.28 - iTime)), smoothIter);\n            \n            avgColor += color;\n        }\n    }\n\n    // Average the color by the number of samples\n    avgColor /= 0.5*float(samples);\n\n    // Output the averaged color\n    fragColor = vec4(avgColor, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}