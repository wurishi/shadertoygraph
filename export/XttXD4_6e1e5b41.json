{"ver":"0.1","info":{"id":"XttXD4","date":"1479635002","viewed":283,"name":"My Rasterizer","username":"VoidChicken","description":"I made a rasterizer for fun. ","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["2d","3d","distancefield","rasterizer","projection","distance","field","raster"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI acos(-1.)\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c\n               );\n}\n//iq's distance fields\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nfloat trid( vec2 p, vec2 a, vec2 b, vec2 c) {\n\treturn udTriangle(vec3(p,0), vec3(a,0), vec3(b,0), vec3(c,0));    \n}\nfloat line( vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 c = vec3(0);\n    float df = 1.;\n    float S = 5.;\n    vec3 A = vec3 (0, .5, 0)*S;\n    vec3 B = vec3 (-.5, 0., 0.)*S;\n    vec3 C = vec3 (.5, 0,0)*S;\n    mat3 RMX = rotationMatrix(vec3(sin(iTime),1,cos(iTime)),iTime*3.1415);\n    A*=RMX;\n    B*=RMX;\n    C*=RMX;\n    A+=vec3(0,0,15);\n    B+=vec3(0,0,15);\n    C+=vec3(0,0,15);\n    vec2 PA,PB,PC;\n    float TANHFOV = tan(PI/4.);\n    float DVA = A.z*TANHFOV;\n    float DVB = B.z*TANHFOV;\n    float DVC = C.z*TANHFOV;\n    PA=(A/DVA).xy;\n    PB=(B/DVB).xy;\n    PC=(C/DVB).xy;\n    PA+=.5;\n    PB+=.5;\n    PC+=.5;\n    float r = .0002;\n    bool OLIN=fract(iTime/5.)>.5;\n    if (OLIN) {\n        df=line(uv,PA,PB,r);\n        df=min(df,line(uv,PB,PC,r));\n        df=min(df,line(uv,PC,PA,r));\n    } else {\n    \tdf = trid(uv, PA, PB, PC);    \n    }\n    if (df<.02) c=pow(vec3(1.-df/.02), vec3(5.));\n\tfragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}