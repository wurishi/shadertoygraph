{"ver":"0.1","info":{"id":"4tyyDD","date":"1536182168","viewed":122,"name":"Homework 1","username":"clayton_redmon7","description":"Hw1","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["simple","eku"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rotate(a)  mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float PI = 3.14159265359; //a tasty dinner meal\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //setup for circle positions and size later\n    vec2 p = (2.0 *fragCoord.xy - iResolution.xy)/iResolution.y;\n    vec2 m = (2.0 *iMouse.xy - iResolution.xy)/iResolution.y;\n    float dist = distance(p*1.5,m*1.5);\n    float rad = 2.0f;\n    \n  /*  colors  */\n    \n    vec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 col = black;\n    vec3 rainbow = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 checkCol = black; //checker color\n    \n  /*  https://www.shadertoy.com/view/llsXzn  */\n    \n    //Triangle barycentric coordinates defined on screen space\n    vec2 t0 = vec2(0.75+(cos(iTime+(2.0*PI/3.0))/5.0), 0.25+(sin(iTime+(2.0*PI/3.0))/5.0));\n\tvec2 t1 = vec2(0.75+(cos(iTime+(4.0*PI/3.0))/5.0), 0.25+(sin(iTime+(4.0*PI/3.0))/5.0));\n\tvec2 t2 = vec2(0.75+(cos(iTime-(6.0*PI/3.0))/5.0), 0.25+(sin(iTime-(6.0*PI/3.0))/5.0));   \n    \n    //Compute UV coordinates\n    \n    vec2 v0 = t2 - t0; vec2 v1 = t1 - t0; vec2 v2 = uv - t0;\n\t\n    //Compute barycentric coordinates \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0/(dot00 * dot11 - dot01 * dot01);\n    float baryX = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float baryY = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \n    if((baryX >= 0.0) && (baryY >= 0.0) && (baryX + baryY <= 1.0))\n    \tfragColor = vec4(rainbow, 1.0);\n    else\n        fragColor = vec4(black, 0.0);\n    \n  /*  circles from https://www.shadertoy.com/view/llGcWz  */\n    \n    //bigger first circle\n    if(dist > rad)\n        col = texture(iChannel0, uv).xyz;\n    \n    //setup for funky changing color for checker\n    uv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n\tuv.y = sin(((uv.x+iTime)*10.0)*0.1);\n\n\tvec3 p1 = black; //color positioning magic\n \n\tp1.x = uv.x-cos(iTime)/10.0;\n\tp1.y = uv.y-sin(iTime)/20.0;\n\tp1.z = uv.x-tan(iTime)/30.0;\n    \n    // changing checkerboard\n    float checker = max(max(cos(iTime/4.0)*20.0,-cos(iTime/4.0)*20.0),5.0);\n    \n    //revolving circle\n    p = ((2.0 *fragCoord.xy - iResolution.xy)/iResolution.xy)*vec2(16, 9); //fix size\n    dist = distance(p,vec2(sin(iTime)*16.0,cos(iTime)*9.0));\n    rad = 4.0f;\n    \n    //checker checker adapted from https://www.shadertoy.com/view/Mts3D7\n    if(int(fragCoord.x/checker) % 2 == 0)\n        if(int(fragCoord.y/checker) % 2 == 0) checkCol = -p1;\n        else checkCol = p1;\n    else if (int(fragCoord.x/checker) % 2 == 1)\n    \tif(int(fragCoord.y/checker) % 2 == 1) checkCol = -p1;\n        else checkCol = p1;\n    else checkCol = p1;\n    \n       if(dist < rad)\n        col = checkCol;\n    \n    // repeating rectangle drawing\n    float size = 0.05;\n    float smoothness = 1.0/iResolution.x;\n    for (int i = 1;i<10;i++){\n        int j = i%3+1;\n        //really funky line that controls size and rotation variation\n        uv = abs(((fragCoord.xy -vec2(0.1*float(i),0.1*float(i)) * iResolution.xy) * rotate(iTime*sin(float(i)))/(iResolution.xy/sin(float(i*6)))));\n        float d = max(uv.x, uv.y);\n        if (i%3 == 1) fragColor += vec4(smoothstep(size, size - smoothness, d)/float(j),0,0,0);\n        if (i%3 == 2) fragColor += vec4(0.0,smoothstep(size, size - smoothness, d)/float(j),0,0);\n        if (i%3 == 0) fragColor += vec4(0.0,0.0,smoothstep(size, size - smoothness, d)/float(j),0);\n    }\n    fragColor += vec4(col,0.0);\n}","name":"Image","description":"","type":"image"}]}