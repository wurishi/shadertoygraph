{"ver":"0.1","info":{"id":"WlXXWf","date":"1564504764","viewed":1742,"name":"SVO Rendering (fix 1.0.0)","username":"Ecter","description":"Fork of \"Sparse Voxel Octree Raytracing\" by warvstar. https://shadertoy.com/view/MlBfRV.  Replaces wasted space voxels by more compact format resulting in a couple orders of magnitude speed improvement. ","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["voxels","octree"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of \"Sparse Voxel Octree Raytracing\" by warvstar. https://shadertoy.com/view/MlBfRV\n// 2019-07-29 19:55:54\n// wastes a whole lot less space and is a whole lot more fast!\n\n#define BUNNY\n//#define SPHERE\n\n//bunny 32sq\n#ifdef BUNNY\nuint voxels[230] = uint[230](66046u,196352u,719365u,1111306u,1504267u,1798287u,2010960u,2383776u,2760672u,3081212u,3244159u,3317855u,3448927u,3604224u,4127237u,4521728u,4997311u,5075087u,5308160u,5821483u,6094592u,6583690u,6924885u,7205389u,7533324u,7879365u,8190469u,8581900u,8917486u,9045243u,9153109u,9436928u,9961216u,10485504u,10945277u,11012853u,11206400u,11685298u,11992832u,12474280u,12782835u,12914672u,13238016u,13729664u,14169036u,14418430u,14484221u,14565312u,14946798u,33023u,57599u,12543u,52479u,41727u,51455u,52479u,8447u,65535u,52479u,52479u,65535u,65535u,57599u,61695u,35071u,65535u,43775u,65535u,61695u,65535u,62207u,65535u,65535u,65535u,65535u,65535u,49407u,61695u,20735u,12543u,52479u,50431u,65535u,65535u,52479u,52479u,65535u,65535u,20735u,50431u,65535u,54783u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,62975u,28927u,65535u,12543u,65535u,33023u,61695u,56831u,14335u,12543u,60159u,65535u,47871u,65535u,61695u,61695u,65535u,65535u,29695u,12543u,65535u,511u,8447u,47103u,49407u,63743u,65535u,19711u,8959u,1535u,61695u,61695u,65535u,65535u,13311u,12799u,4351u,30719u,5631u,35071u,35071u,35071u,767u,52479u,52479u,65535u,65535u,52479u,52479u,8191u,49151u,35583u,65535u,44031u,65535u,2303u,36863u,2815u,45055u,65535u,65535u,65535u,65535u,53247u,61439u,65535u,65535u,3327u,2815u,767u,52479u,52479u,65535u,65535u,52479u,52479u,65535u,65535u,52479u,65535u,56831u,19967u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,65535u,13311u,65535u,24575u,24575u,3327u,1279u,4095u,3583u,4095u,511u,61183u,65535u,65535u,65535u,61183u,57343u,49151u,32767u,65535u,65535u,22527u,1023u,4095u,4095u,511u,13311u,13311u,767u,1023u,4607u,1279u,65535u,65535u,13311u,13311u,16383u,8191u,30719u,511u);\n\n//small test to understand the layout\n#elif defined(SPHERE)\nuint voxels[60] = uint[60](130816u,649239u,916483u,1309189u,1701640u,2158097u,2547488u,2998080u,3473152u,61695u,52479u,43775u,65535u,61695u,16639u,52479u,16639u,65535u,65023u,61695u,8447u,43775u,65535u,8447u,64511u,61951u,20735u,12543u,65535u,65535u,65535u,4607u,52479u,43775u,65535u,2303u,2303u,61439u,52735u,17663u,65535u,65535u,3327u,65535u,1535u,44031u,65535u,8959u,65535u,2815u,65535u,1023u,65535u,65535u,65535u,4607u,65535u,1535u,1023u,511u);\n\n#else\nuint voxels[6] = uint[6](129526u,197373u,312318u,1791u,329726u,1023u);\n#endif\nconst vec3 PPP = vec3(1, 1, 1);\nconst vec3 PNP = vec3(1, -1, 1);\nconst vec3 PNN = vec3(1, -1, -1);\nconst vec3 NPN = vec3(-1, 1, -1);\nconst vec3 NNN = vec3(-1, -1, -1);\nconst vec3 NNP = vec3(-1, -1, 1);\nconst vec3 NPP = vec3(-1, 1, 1);\nconst vec3 PPN = vec3(1, 1, -1);\nconst vec3 POS[8] = vec3[8](PNN, PNP, PPN, PPP, NNN, NNP, NPN, NPP);\nstruct Ray { vec3 o, d, invDir; };\nstruct Hit {\n\tvec3 p;\n\tfloat t;\t// solution to p=o+t*d\n\tfloat tmax;    //distance to exit point?\n\tfloat tmin;    // distance to enter point?\n\tvec3 n;\t\t// normal\n};\nbool BBoxIntersect(const vec3 boxMin, const vec3 boxMax, const Ray r, out Hit hit) {\n\tvec3 tbot = r.invDir * (boxMin - r.o);\n\tvec3 ttop = r.invDir * (boxMax - r.o);\n\tvec3 tmin = min(ttop, tbot);\n\tvec3 tmax = max(ttop, tbot);\n\tvec2 t = max(tmin.xx, tmin.yz);\n\tfloat t0 = max(t.x, t.y);\n\tt = min(tmax.xx, tmax.yz);\n\tfloat t1 = min(t.x, t.y);\n\thit.tmin = t0;\n\thit.tmax = t1;\nreturn t1 > max(t0, 0.0);\n}\nvec4 trace(Ray ray, inout Hit hit) {\n\tvec3 center = vec3(0.0f);\n    float scale = 1.0f;\n\tvec3 minBox = center - scale;\n\tvec3 maxBox = center + scale;\n\tvec4 f = vec4(1.0f);\n    struct Stack {\n\t\tuint index;\n\t\tvec3 center;\n\t\tfloat scale;\n\t};\n    Stack stack[10];\n    int stackPos = 1;\n    if (!BBoxIntersect(minBox, maxBox, ray, hit)) return f;\n    uint index = 0u;\n    scale *= 0.5f;\n    stack[0] = Stack( 0u, center, scale);\n    while(stackPos-- > 0) {\n        f = vec4(0.1f);\n        center = stack[stackPos].center;\n\t\tindex = stack[stackPos].index;\n\t\tscale = stack[stackPos].scale;\n        uint voxel_node = voxels[index];\n        uint voxel_group_offset = voxel_node >> 16;\n        uint voxel_child_mask = (voxel_node & 0x0000FF00u) >> 8u;\n        uint voxel_leaf_mask = voxel_node & 0x000000FFu;\n        uint accumulated_offset = 0u;\n        for (uint i = 0u; i < 8u; ++i) {\n            bool empty = (voxel_child_mask & (1u << i)) == 0u;\n            bool is_leaf = (voxel_leaf_mask & (1u << i)) != 0u;\n            if (empty){ //empty\n                continue;\n            }\n            \n            vec3 new_center = center + scale * POS[i];\n            vec3 minBox = new_center - scale;\n            vec3 maxBox = new_center + scale;\n            \n\n            if (!BBoxIntersect(minBox, maxBox, ray, hit)){\n                if(!is_leaf){\n                   accumulated_offset +=1u;\n                }\n                continue;\n            }\n            if (is_leaf){ //not empty, but a leaf\n                return vec4(1.0f,0.0f,0.0f,1.0f);\n            } else { //not empty and not a leaf\n            \tstack[stackPos++] = Stack(voxel_group_offset+accumulated_offset, new_center, scale*0.5f   );\n            \tf.z += 0.4f;\n                accumulated_offset+=1u;\n            }\n        }\n    }\n\treturn f;\n}\nvec2 rotate2d(vec2 v, float a) {\n\tfloat sinA = sin(a);\n\tfloat cosA = cos(a);\n\treturn vec2(v.x * cosA - v.y * sinA, v.y * cosA + v.x * sinA);\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.8);\n\tvec3 cameraPlaneU = vec3(1.0, 0.0, 0.0);\n\tvec3 cameraPlaneV = vec3(0.0, 1.0, 0.0) * iResolution.y / iResolution.x;\n    vec3 rayDir = cameraDir + screenPos.x * cameraPlaneU + screenPos.y * cameraPlaneV;\n\tvec3 rayPos = vec3(0.0, 0.25 * sin(iTime * 2.7), -3.4);\n    rayPos.xz = rotate2d(rayPos.xz, iTime);\n   \trayDir.xz = rotate2d(rayDir.xz, iTime);\n\tRay ray;\n\tHit hit;\n\tray.o = rayPos;\n\tray.d = rayDir;\n\tray.invDir = 1.0f/rayDir;\n\tvec4 color = trace(ray, hit);\n    if (length(color) > 0.5f) {\n     fragColor = color;\n\t}\n\n}","name":"Image","description":"","type":"image"}]}