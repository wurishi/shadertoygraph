{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"const int MAX_RAY_STEPS = 32;\nconst float PI_VALUE = 3.14159265359;\nconst float MIN_THRESHOLD = 1e-3;\n#define NORMAL_EPS (0.1 / iResolution.x)\n//#define ENABLE_AA\n\nconst int GEO_ITERATIONS = 3;\nconst int FRAG_ITERATIONS = 5;\nconst float OCEAN_AMPLITUDE = 0.6;\nconst float OCEAN_CHOPINESS = 4.0;\nconst float OCEAN_SPEED_FACTOR = 0.8;\nconst float OCEAN_BASE_FREQ = 0.16;\nconst vec3 OCEAN_COLOR_BASE = vec3(0.0, 0.09, 0.18);\nconst vec3 OCEAN_REFLECTION_COLOR = vec3(0.8, 0.9, 0.6) * 0.6;\n#define CURRENT_TIME (1.0 + iTime * OCEAN_SPEED_FACTOR)\nconst mat2 FOLD_MATRIX = mat2(1.6, 1.2, -1.2, 1.6);\n\nmat3 eulerRotationMatrix(vec3 angles) {\n    vec2 sinCosX = vec2(sin(angles.x), cos(angles.x));\n    vec2 sinCosY = vec2(sin(angles.y), cos(angles.y));\n    vec2 sinCosZ = vec2(sin(angles.z), cos(angles.z));\n    mat3 rotation;\n    rotation[0] = vec3(\n        sinCosX.y * sinCosZ.y + sinCosX.x * sinCosY.x * sinCosZ.x, \n        sinCosX.y * sinCosY.x * sinCosZ.x + sinCosZ.y * sinCosX.x, \n        -sinCosY.y * sinCosZ.x\n    );\n    rotation[1] = vec3(\n        -sinCosY.y * sinCosX.x, \n        sinCosX.y * sinCosY.y, \n        sinCosY.x\n    );\n    rotation[2] = vec3(\n        sinCosZ.y * sinCosX.x * sinCosY.x + sinCosX.y * sinCosZ.x, \n        sinCosX.x * sinCosZ.x - sinCosX.y * sinCosZ.y * sinCosY.x, \n        sinCosY.y * sinCosZ.y\n    );\n    return rotation;\n}\n\nfloat generateHash(vec2 coord) {\n    float hashed = dot(coord, vec2(127.1, 311.7));\n    return fract(sin(hashed) * 43758.5453123);\n}\n\nfloat perlinNoise(vec2 point) {\n    vec2 integerPart = floor(point);\n    vec2 fractionalPart = fract(point);\n    vec2 smoothStepVec = fractionalPart * fractionalPart * (3.0 - 2.0 * fractionalPart);\n    \n    float n00 = generateHash(integerPart + vec2(0.0, 0.0));\n    float n10 = generateHash(integerPart + vec2(1.0, 0.0));\n    float n01 = generateHash(integerPart + vec2(0.0, 1.0));\n    float n11 = generateHash(integerPart + vec2(1.0, 1.0));\n    \n    float mix1 = mix(n00, n10, smoothStepVec.x);\n    float mix2 = mix(n01, n11, smoothStepVec.x);\n    \n    return mix(mix1, mix2, smoothStepVec.y) * 2.0 - 1.0;\n}\n\nfloat calculateDiffuse(vec3 normal, vec3 lightDir, float power) {\n    return pow(max(dot(normal, lightDir) * 0.4 + 0.6, 0.0), power);\n}\n\nfloat calculateSpecular(vec3 normal, vec3 lightDir, vec3 viewDir, float shininess) {    \n    float normalization = (shininess + 8.0) / (PI_VALUE * 8.0);\n    return pow(max(dot(reflect(viewDir, normal), lightDir), 0.0), shininess) * normalization;\n}\n\nvec3 computeSkyColor(vec3 direction, float time) {\n    float starMovement = sin(time) * 0.5 + 0.5;\n    vec3 starPos = normalize(vec3(cos(time * 0.2) * 0.5, 0.9, sin(time * 0.2) * 0.5));\n    float starIntensity = smoothstep(0.995, 1.0, dot(direction, starPos));\n    vec3 starGlow = vec3(1.0, 0.9, 0.7) * starIntensity;\n\n    direction.y = (max(direction.y, 0.0) * 0.8 + 0.2) * 0.8;\n    vec3 skyBase = vec3(pow(1.0 - direction.y, 2.0), 1.0 - direction.y, 0.6 + (1.0 - direction.y) * 0.4) * 1.1;\n\n    return mix(skyBase, vec3(0.0, 0.0, 0.1), starMovement) + starGlow;\n}\n\nfloat generateWave(vec2 uv, float choppy) {\n    uv += perlinNoise(uv);        \n    vec2 waveVector = 1.0 - abs(sin(uv));\n    vec2 secondaryWave = abs(cos(uv));    \n    waveVector = mix(waveVector, secondaryWave, waveVector);\n    return pow(1.0 - pow(waveVector.x * waveVector.y, 0.65), choppy);\n}\n\nfloat oceanHeight(vec3 position) {\n    float frequency = OCEAN_BASE_FREQ;\n    float amplitude = OCEAN_AMPLITUDE;\n    float choppiness = OCEAN_CHOPINESS;\n    vec2 uv = position.xz * 0.75;\n    \n    float displacement, totalHeight = 0.0;    \n    for(int i = 0; i < GEO_ITERATIONS; i++) {        \n        displacement = generateWave((uv + CURRENT_TIME) * frequency, choppiness);\n        displacement += generateWave((uv - CURRENT_TIME) * frequency, choppiness);\n        totalHeight += displacement * amplitude;        \n        uv *= FOLD_MATRIX; \n        frequency *= 1.9; \n        amplitude *= 0.22;\n        choppiness = mix(choppiness, 1.0, 0.2);\n    }\n    return position.y - totalHeight;\n}\n\nfloat oceanHeightDetail(vec3 position) {\n    float frequency = OCEAN_BASE_FREQ;\n    float amplitude = OCEAN_AMPLITUDE;\n    float choppiness = OCEAN_CHOPINESS;\n    vec2 uv = position.xz * 0.75;\n    \n    float displacement, totalHeight = 0.0;    \n    for(int i = 0; i < FRAG_ITERATIONS; i++) {        \n        displacement = generateWave((uv + CURRENT_TIME) * frequency, choppiness);\n        displacement += generateWave((uv - CURRENT_TIME) * frequency, choppiness);\n        totalHeight += displacement * amplitude;        \n        uv *= FOLD_MATRIX; \n        frequency *= 1.9; \n        amplitude *= 0.22;\n        choppiness = mix(choppiness, 1.0, 0.2);\n    }\n    return position.y - totalHeight;\n}\n\nfloat waveDisturbance(vec2 uv, vec2 origin, float time) {\n    float dist = length(uv - origin);\n    return exp(-dist * 10.0) * sin(time * 5.0 + dist * 20.0) * 0.2;\n}\n\nvec3 computeOceanColor(vec3 position, vec3 normal, vec3 lightDir, vec3 viewDir, vec3 distanceVec, vec2 uv, float time) {  \n    float fresnelEffect = clamp(1.0 - dot(normal, -viewDir), 0.0, 1.0);\n    fresnelEffect = pow(fresnelEffect, 3.0);\n    \n    vec3 starPos = normalize(vec3(cos(time * 0.2) * 0.5, 0.9, sin(time * 0.2) * 0.5));\n    vec3 starReflection = computeSkyColor(reflect(viewDir, normal), time);\n    float starInfluence = smoothstep(0.9, 1.0, dot(normal, starPos)) * 0.6;\n    \n    vec3 waveColor = OCEAN_COLOR_BASE + calculateDiffuse(normal, lightDir, 80.0) * OCEAN_REFLECTION_COLOR * 0.15;\n    waveColor += starReflection * starInfluence;\n    waveColor += computeSkyColor(viewDir, time) * fresnelEffect;\n\n    if (iMouse.z > 0.0) {\n        vec2 mousePos = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n        mousePos.x *= iResolution.x / iResolution.y;\n        waveColor += vec3(0.3, 0.5, 0.8) * waveDisturbance(uv, mousePos, time);\n    }\n\n    float attenuation = max(1.0 - dot(distanceVec, distanceVec) * 0.001, 0.0);\n    waveColor += OCEAN_REFLECTION_COLOR * (position.y - OCEAN_AMPLITUDE) * 0.15 * attenuation;\n\n    waveColor += calculateSpecular(normal, lightDir, viewDir, 60.0);\n    waveColor = mix(waveColor, vec3(0.0, 0.05, 0.2), smoothstep(0.0, 1.0, position.y / 5.0));\n\n    return waveColor;\n}\n\nvec3 calculateNormal(vec3 position, float epsilon) {\n    vec3 normal;\n    normal.y = oceanHeightDetail(position);    \n    normal.x = oceanHeightDetail(vec3(position.x + epsilon, position.y, position.z)) - normal.y;\n    normal.z = oceanHeightDetail(vec3(position.x, position.y, position.z + epsilon)) - normal.y;\n    normal.y = epsilon;\n    return normalize(normal);\n}\n\nfloat traceHeightMap(vec3 origin, vec3 direction, out vec3 hitPoint) {  \n    float lowerBound = 0.0;\n    float upperBound = 1000.0;    \n    float heightAtUpper = oceanHeight(origin + direction * upperBound);\n    if(heightAtUpper > 0.0) {\n        hitPoint = origin + direction * upperBound;\n        return upperBound;   \n    }\n    float heightAtLower = oceanHeight(origin);    \n    for(int i = 0; i < MAX_RAY_STEPS; i++) {\n        float midT = mix(lowerBound, upperBound, heightAtLower / (heightAtLower - heightAtUpper));\n        hitPoint = origin + direction * midT;\n        float heightAtMid = oceanHeight(hitPoint);        \n        if(heightAtMid < 0.0) {\n            upperBound = midT;\n            heightAtUpper = heightAtMid;\n        } else {\n            lowerBound = midT;\n            heightAtLower = heightAtMid;\n        }        \n        if(abs(heightAtMid) < MIN_THRESHOLD) break;\n    }\n    return mix(lowerBound, upperBound, heightAtLower / (heightAtLower - heightAtUpper));\n}\n\nvec4 calculatePixelColor(in vec2 fragCoord, float time) {    \n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    vec3 angles = vec3(sin(time * 3.0) * 0.1, sin(time) * 0.2 + 0.3, time);    \n    vec3 cameraOrigin = vec3(0.0, 3.5, time * 5.0);\n    vec3 rayDir = normalize(vec3(uv.xy, -2.0));\n    rayDir.z += length(uv) * 0.14;\n    rayDir = normalize(eulerRotationMatrix(angles) * rayDir);\n    \n    vec3 intersectionPoint;\n    traceHeightMap(cameraOrigin, rayDir, intersectionPoint);\n    vec3 distanceVec = intersectionPoint - cameraOrigin;\n    vec3 normal = calculateNormal(intersectionPoint, dot(distanceVec, distanceVec) * NORMAL_EPS);\n    vec3 lightDirection = normalize(vec3(0.0, 1.0, 0.8)); \n    \n    return vec4(mix(\n        computeSkyColor(rayDir, time),\n        computeOceanColor(intersectionPoint, normal, lightDirection, rayDir, distanceVec, uv, time),\n        pow(smoothstep(0.0, -0.02, rayDir.y), 0.2)\n    ), length(distanceVec));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime * 0.3 + iMouse.x * 0.01;\n\n#ifdef ENABLE_AA\n    vec4 accumulatedColor = vec4(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n            vec2 sampleCoord = fragCoord + vec2(i, j) / 3.0;\n            accumulatedColor += calculatePixelColor(sampleCoord, time);\n        }\n    }\n    accumulatedColor /= 9.0;\n#else\n    vec4 accumulatedColor = calculatePixelColor(fragCoord, time);\n#endif\n    \n    fragColor.rgb = vec3(pow(accumulatedColor.rgb, vec3(1.0 / 2.2)));\n    fragColor.a = 5.0/accumulatedColor.a;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MX3czM","date":"1734885960","viewed":226,"name":"Seascape Fork","username":"erpprog","description":"https://www.cineshader.com/view/MX3czM","likes":5,"published":3,"flags":0,"usePreview":0,"tags":["procedural","noise","waves","sea","water","subsurface","cineshader"],"hasliked":0,"parentid":"Ms2SD1","parentname":"Seascape"}}