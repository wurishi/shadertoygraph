{"ver":"0.1","info":{"id":"Nd2BWt","date":"1647398099","viewed":113,"name":"Mandelbrot & Julia Set Explorer","username":"amcombs","description":"A simple visualization of the Julia Sets.\n\nTo explore:\nW - move up\nA - move left\nS - move down\nD - move right\nQ - zoom in\nE - zoom out\nZ - change base left\nX - change base right\n\nX and Z will change which coordinates the fractal is based on","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    fragColor = vec4(col.rgb, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPS 512\n#define EVSPEED 0.01\n#define ESCAPE 2048.\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel1, re, 0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // State data\n    vec4 data = texelFetch(iChannel0, ivec2(0, 0), 0);\n    data.w *= EVSPEED;\n\n    // Control parameters\n    float zoom = 1.5/pow(zconvergence, data.z);\n    vec2 scl = vec2(-zoom, zoom);\n    vec2 offset = data.xy;\n    float timescl = 5.;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;  // Same as the coordinates of the set\n    \n    // Colors\n    vec3 rgb1 = vec3(0.0,0.0,0.0);\n    vec3 rgb2 = vec3(0.970,0.513,0.344);\n    vec3 rgb3 = vec3(0.0,0.0,0.0);\n\n    // Aspect ration correction\n    float aspect = iResolution.x/iResolution.y;\n    uv.x *= aspect;\n    \n    // Fitting between scale min and scale max (including aspect ratio)\n    uv *= scl.y - scl.x;\n    uv += vec2(scl.x*aspect, scl.x);\n    uv += offset;\n    \n    vec2 mev = vec2(0., 0.);  \t// Z component of mandelbrot set\n    vec2 jev = uv;\t\t\t\t// Z component of julia set\n    vec2 c = vec2(0.);\n    float divergence = 0.;\n    float offsetW = data.w + 0.5623;\n    \n    // Creating the actual set\n    for (int i=0; i<STEPS; i++) {\n    \n        /*UNCOMMENT FOR MANDELBROT SET*/\n        \n        // divergence += (1./float(STEPS)) * float((mev.x*mev.x)+(mev.y*mev.y) <= 4.);\n        // divergence += float((mev.x*mev.x)+(mev.y*mev.y) <= ESCAPE*ESCAPE);\n        /* \n        if ((mev.x*mev.x)+(mev.y*mev.y) <= ESCAPE*ESCAPE) {\n            mev = mandelbrot(uv, mev);\n            divergence += 1.;\n        }*/\n        \n        \n        /*UNCOMMENT FOR JULIA SETS*/\n        \n        c = vec2(cos(offsetW)*sin(offsetW/2.), \n                 sin(offsetW)*cos(offsetW/2.));\n        /*        \n        c = vec2(cos(data.w), \n                 sin(data.w));*/\n        /*         \n        c = vec2(tan(0.1*data.w)*cos(4.*data.w), \n                 sin(2.*data.w));*/\n        \n        if ((jev.x*jev.x)+(jev.y*jev.y) <= ESCAPE*ESCAPE) {\n            jev = julia(c, jev);\n            divergence += exp(-((jev.x*jev.x)+(jev.y*jev.y)));\n        }\n    }\n    \n    // Mandelbrot Smoothing\n    // float smoothing = divergence - log2(log2(dot(mev, mev))) + 4.0;\n    //smoothing /= float(STEPS);\n    \n    // Output to screen\n    // vec3 color = tri_rgb_lerp(rgb1, rgb2, rgb3, smoothing / float(STEPS));\n    // vec3 color = vec3(divergence);\n    // vec3 color = rgb_scheme(divergence);\n    vec3 color = blue_scheme(divergence);\n    fragColor = vec4(color, 1.0);\n    \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float zconvergence = 1.03;\n\nvec2 mandelbrot(vec2 uv, vec2 ev) {\n    float r = (ev.x*ev.x - ev.y*ev.y);   // Real \n    float j = (2.*ev.x*ev.y);            // Imaginary\n    \n    vec2 nev = vec2(r, j) + uv;\n    \n    return nev;\n}\n\nvec2 julia(vec2 c, vec2 uv) {\n    float r = (uv.x*uv.x - uv.y*uv.y);   // Real \n    float j = (2.*uv.x*uv.y);            // Imaginary\n    \n    vec2 nev = vec2(r, j) + c;\n    \n    return nev;\n}\n\nvec3 tri_rgb_lerp(vec3 c1, vec3 c2, vec3 c3, float a) {\n    float f = float(a>=0.5);\n    vec3 final = c1*(1.-f) + c2*(f);\n    final += (c1 + ((c2-c1)/0.5)*(a*2.))*(1.-f);\n    final += (c2 + ((c3-c2)/0.5)*((a-0.5)*2.))*f;\n    return final;\n}\n\nvec3 blue_scheme(float divergence) {\n    vec3 base_color = vec3(-0.8,0.1,0.8);\n    return 0.5 + 0.5*cos( 3.0 + divergence*0.25 + base_color);;\n}\n\nvec3 rgb_scheme(float divergence) {\n    float a = 0.1;\n    return vec3(\n    .5*sin(a+divergence)+.5,\n    .5*sin(a+divergence + 2.094)+.5,\n    .5*sin(a+divergence + 4.188)+.5\n    );\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"/*\nKeyboard Codes\n\nQ/E     = Zoom in/out\nZ/X     = Evolve fractal\nW/A/S/D = Navigate fractal\n*/\n#define W 87\n#define A 65\n#define S 83\n#define D 68\n\n#define Q 81\n#define E 69\n\n#define Z 90\n#define X 88\n\n\nfloat get_key(int key) {\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x;\n}\n\nvec4 handle_inputs(vec2 offset, float zoom, float evolution) {\n    // Evolution\n    evolution += (get_key(Z) - get_key(X))/pow(zconvergence, zoom);\n    \n    // Zoom\n    zoom += get_key(Q) - get_key(E);\n    zoom = clamp(zoom, 1., 10000.);\n    \n    // Navigation\n    float velocity = 0.01;\n    \n    vec2 up = get_key(W) * vec2(0., 1.);\n    vec2 left = get_key(A) * vec2(-1., 0.);\n    vec2 down = get_key(S) * vec2(0., -1.);\n    vec2 right = get_key(D) * vec2(1., 0.);\n    \n    offset += (up+left+down+right)*velocity/pow(zconvergence, zoom);\n    \n    return vec4(offset, zoom, evolution);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec2 offset = data.xy;\n    float zoom = data.z;\n    float evolution = data.w;\n    \n    data = handle_inputs(offset, zoom, evolution);\n\n    fragColor = data;\n    \n    if (iTime == 0.) {\n        fragColor = vec4(0., 0., 1., 170.0);\n    }\n}","name":"Buffer B","description":"","type":"buffer"}]}