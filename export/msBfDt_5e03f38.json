{"ver":"0.1","info":{"id":"msBfDt","date":"1691461041","viewed":120,"name":"Follow You Explode","username":"kirickiri","description":"Forked from https://www.shadertoy.com/view/WsVcRt from Khrebtov_M \nchanged a bit on the interaction","likes":1,"published":1,"flags":34,"usePreview":0,"tags":["tracing","webcam","motion","movement"],"hasliked":0,"parentid":"dsBfRG","parentname":"Follow You Waterfall"},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cheap(ish) scrolling nebula effect (just noise mixing)\n// https://store.steampowered.com/app/1751970/A_Blast_From_The_Past/\n\n// noise, IQ - https://www.shadertoy.com/view/4sfGzS\n// (somewhat jigged)\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n//#define UI3 uvec3(UI0, UI1, 2798796415U)\n//#define UI4 uvec4(UI3, 1979697957U)\n#define UIF (1.0 / float(0xffffffffU))\n\n#define PI 3.14159265359\n\n// alternate the direction of rotation along a checker pattern\n#define CHECKERED\n\n\nmat2 rot(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nfloat checkersign(vec2 uv) {\n#ifdef CHECKERED\n    uv = floor(uv);\n    return sign(mod(uv.x + uv.y, 2.) - .5);\n#else\n    return 1.;\n#endif\n}\n\n\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\n// https://github.com/ashima/webgl-noise/blob/master/src/noise3Dgrad.glsl\n// modified to allow for rotation \nfloat snoise(vec3 v, out vec3 gradient, float time)\n{\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n    \n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// add rotation\n  x0.xy *= rot(time*checkersign(a0.xy));\n  x1.xy *= rot(time*checkersign(a0.zw));\n  x2.xy *= rot(time*checkersign(a1.xy));\n  x3.xy *= rot(time*checkersign(a1.zw));\n    \n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  vec4 m2 = m * m;\n  vec4 m4 = m2 * m2;\n  vec4 pdotx = vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3));\n\n// Determine noise gradient\n  vec4 temp = m2 * m * pdotx;\n  gradient = -8.0 * (temp.x * x0 + temp.y * x1 + temp.z * x2 + temp.w * x3);\n  gradient += m4.x * p0 + m4.y * p1 + m4.z * p2 + m4.w * p3;\n  gradient *= 42.0;\n\n  return 420.0 * dot(m4, pdotx);//origin 42->420 Kiri\n}\n\nfloat get_mask(vec2 uv) {\n    uv.y *= 4.;\n    uv.y -= 1.;\n    uv.x *= .6;\n    uv.x *= pow(uv.y, .15);\n    uv.x = abs(uv.x);\n\treturn (smoothstep(0.65, 1., uv.x) * step(0., uv.y));\n}\n\nfloat fbm(vec3 p, inout vec3 gradient) {\n\t// Initial values\n\tfloat value = 0.;\n\tfloat amplitude = .3;\n\tfloat frequency = 1.;\n\tfloat rotation = 1.5;\n\tvec3 grad;\n\t// Loop of octaves\n\tfor (int i = 0; i < 4; i++) {\n        value += amplitude * snoise(frequency*p - gradient, grad, iTime*rotation);\n\t\tgrad.z = 0.;\n\t\tgradient += amplitude*grad*.3;\n        frequency *= 2.;\n\t\tamplitude *= .5;\n\t\trotation *= 2.;\n\t}\n\treturn value;\n}\n\n\n#define SCALE 20.\n#define SPEED 9.\n#define FREQUENCY .93\n\nfloat d;\n#define C(p)  min(1., sqrt(10.*abs(length(p-.5)-.4)))\n#define D(p,o)  ( (d=length(p-o)*5.)<=.6 ? d:1. )\n\n\n\nvec2 distort(vec2 uv) {\n    vec2 a0 = vec2(0.5, 0.2);\n    vec2 a1 = vec2(0.6, -0.4);\n    vec2 a2 = vec2(0.2, 0.9);\n    vec2 a3 = vec2(-0.7, 0.9);\n    vec2 d = sin(17.4 * uv + 1.5 * sin(14.7 * uv.yx + 0.5 + a0 * iTime) + a1 * iTime);\n    d += sin(16.4 * uv.yx + 1.3 * sin(15.7 * uv + 0.8 + a2 * iTime) - a3 * iTime);\n    d.y -= 2.5;\n    return uv * 0.995 + d * 0.003;\n}\n// The min and max sizes of the circles (in pixels) over time.\n#define MIN_SIZE 2.0\n#define MAX_SIZE 150.0\n\n// Compute the relative distance to the circle, where < 0.0 is outside the feathered border,\n// and > 1.0 is inside the feathered border.\nfloat ComputeCircle(vec2 pos, vec2 center, float radius, float feather)\n{\n    // Determine the distance to the center of the circle.\n\tfloat dist = length(center - pos);\n    \n    // Use the distance and the specified feather factor to determine where the distance lies\n    // relative to the circle border.\n    float start = radius - feather;\n    float end   = radius + feather;\n    return smoothstep(start, end, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n\n\n    vec3 colorvec=vec3(.0);\n    vec2 pvec = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.x * 1000.0;\n    vec2 pv = fragCoord.xy / iResolution.xy;\n    pv.x = 1.0-pv.x;//uv.x=1.-uv.x;//(invert)\n\tvec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n\tfragColor=(textureLod(iChannel0,pv,0.0).xxxw+texture(iChannel2,pv))*0.01;\n    pv.y/=iResolution.x/iResolution.y;\n      // Prepare the circle parameters, cycling the circle size over time.\n     float cycle=1.;\n     if(distance(pv.x,pos.x)>.35*cos(PI*abs(abs(.5-abs(pos.x/iResolution.x))-pos.x)))\n     cycle = clamp(cos(iTime* (.5*abs(.5-abs(pos.x/iResolution.x))+1.)/ 2.0) * 0.6 + 0.7, 0.0, 1.0);\n\n    float diameter = mix(MAX_SIZE, MIN_SIZE, cycle);\n    float radius = diameter / 2.0;\n    vec2  center = vec2(0.0);\n    \n    // Compute the relative distance to the circle, using mod() to repeat the circle across the display.\n    // A feather value (in pixels) is used to reduce aliasing artifacts when the circles are small.\n    // The position is adjusted so that a circle is in the center of the display.\n    vec2 screenPos = fragCoord.xy - (iResolution.xy / 2.0) - vec2(radius);\n    vec2 posd = mod(screenPos, vec2(diameter)) - vec2(radius);\n    float d = ComputeCircle(posd, center, radius, 0.5);\n    \n    // Compute \"pixelated\" (stepped) texture coordinates using the floor() function.\n    // The position is adjusted to match the circles, i.e. so a pixelated block is at the center of the\n    // display.\n    vec2 count = iResolution.xy / diameter;\n    vec2 shift = vec2(0.5) - fract(count / 2.0);\n    vec2 uv = floor(count * fragCoord.xy / iResolution.xy + shift) / count;\n    \n\t// Sample the texture, using an offset to the center of the pixelated block.\n    // NOTE: Use a large negative bias to effectively disable mipmapping, which would otherwise lead\n    // to sampling artifacts where the UVs change abruptly at the pixelated block boundaries.\n    uv += vec2(0.5) / count;\n    uv = clamp(uv, 0.0, 0.99);\n    uv.y = uv.y;\n    uv.x=1.-uv.x;\n    vec3 texColor = texture(iChannel3, uv, -32.0).rgb;    \n\n\n    //Plasma\n    float time = iTime *0.2;\n\n    float color1, color2, color;\n\t\n\tcolor1 = (sin(dot(fragCoord.xy,vec2(sin(time*3.0),cos(time*3.0)))*0.02+time*3.0)+1.0)/2.0;\n\t\n\tvec2 centerP = vec2(640.0/2.0, 360.0/2.0) + vec2(640.0/2.0*sin(-time*3.0),360.0/2.0*cos(-time*3.0));\n\t\n\tcolor2 = (cos(length(fragCoord.xy - centerP)*0.03)+1.0)/2.0;\n\t\n\tcolor = (color1+ color2)/2.0;\n\n\tfloat red\t= (cos(PI*color/0.5+time*3.0)+1.0)/2.0;\n\tfloat green\t= (sin(PI*color/0.5+time*3.0)+1.0)/2.0;\n\tfloat blue\t= (sin(+time*3.0)+1.0)/2.0;\n\t\n\n\t// Calculate the color based on the circle shape, mixing between that color and a background color.\n    // NOTE: Set the mix factor to 0.0 to see the pixelating effect directly, without the circles.\n    \n    \n    vec3 bg  = vec3(red, green, blue);\n    vec3 col = mix(texColor, bg, d);\n        \n\tfragColor = vec4(col, 1.0);\n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/* Buffer b stores camera image from the previous frame, and this buffer outputs \ndifference between previous frame and current frame, so,for pixels that moved\nthe output pixel is bright*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n\n\nfragColor = textureLod( iChannel0, uv,1.0 )-textureLod( iChannel1, uv,1.0);    \n}\n\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Thit is the buffer that stores current image from the camera\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\n    fragColor = texture( iChannel1, uv);\n}\n\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"\n/*this buffer is used to calculate the center of pixels from \nbuffer A  that are  bright enough  (those are the pixels that moved)\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //we want pixel(0;0) to output position of the center of bright pixels\n    \n    if( fragCoord.x>0.5) return;\n    if( fragCoord.y>0.5) return;\n    \n  /*we will calculate the sum of bright pixels'coordinates \n  and then divide it by the number of these pixels*/\n    \n    vec2 sum=vec2(0.0);\n    float g=0.0;\n    float threshold = 0.15;\n    for(float i=0.0;i<1.0;i+=0.01) for(float j=0.0;j<1.0;j+=0.01)\n \t    {\n            vec3 diff = textureLod(iChannel0,vec2(i,j)  ,3.0).xyz;\n            if(diff.r >= threshold || diff.g >= threshold || diff.b >= threshold)\n            {\n\t\t\t\tsum+=vec2(i,j);\n \t  \t        g++;\n \t        }\n  \t     \n\t   }\n    float  td= iTimeDelta;\n    \n    /*camera is not  a precise tool for tracking movement, so, if we just output\n     calculated center, it will be jittery. Instead, we can move cursor towards\n    the calculated center buy calculating the difference between this position\n   and previous position, and multiply this difference by some constant value*/\n\n\tvec4 te =texture(iChannel1,vec2(0.0,0.0));//xy-current coordinates;zw-desired coordinates;\n    vec2 delta = te.zw-te.xy;\n\tif(g<15.0) fragColor = te+vec4(3.0*delta*td,0.0,0.0);\n    else\n    {\n        te.zw =sum/g;\n    \tdelta = te.zw-te.xy;\n     \tfragColor =  te+vec4(3.0*delta*td,0.0,0.0);\n    }\n   \n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//this buffer if for the line that cursor traces \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor=.97*texture(iChannel0,uv);\n   \n    vec2 pos = textureLod(iChannel1,vec2(0.0),0.0).xy;\n    if(distance(uv,pos)<0.2)   fragColor =vec4(1.);\n    \n    \n\n}","name":"Buffer C","description":"","type":"buffer"}]}