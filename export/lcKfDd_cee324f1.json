{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const vec2 quiltSize = vec2(8., 5.);\n\n\nconst float numViews = quiltSize.x * quiltSize.y;\n\n#define TMOD (mod(iTime, 10.0))\n\n#define USE_PERSPECTIVE_X (TMOD >= 3.0 && TMOD < 5.0)\n#define USE_PERSPECTIVE_Y (TMOD < 8.0)\n\nconst float lineNumber = 19.6401;\nconst float obliquity = 0.10516;\nconst float screenWidth = 1440.0;\nconst float screenHeight = 2560.0;\n\n\nconst float pitch  = (screenWidth * 3. ) / lineNumber;\nconst float slope  = -obliquity * (screenHeight / screenWidth);\n// const float center = -(1.0 / 40. * 8.);\nconst float center = 0.;\n\n//强迫症发病中\nconst float invView = 0.0;\n\n#define RENDER_AS_QUILT 0\n\n//原版texarr\n//vec2 texArr(vec3 uvz) {\n//    float z = floor(uvz.z * numViews);\n//    float x = (mod(z, quiltSize.x) + uvz.x) / quiltSize.x;\n//    float y = (floor(z / quiltSize.x) + uvz.y) / quiltSize.y;\n//    return vec2(x, y);\n//}\n\nvec2 texArr(vec3 uvz) {\n    float z = floor((1.0 - uvz.z) * numViews);\n    float x = (mod(z, quiltSize.x) + uvz.x) / quiltSize.x;\n    float y = mod((quiltSize.y - floor(z / quiltSize.x) + uvz.y) / quiltSize.y, 1.);\n    return vec2(x, y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float subp = 1.0 / (iResolution.x * 3.0);\n\n#if RENDER_AS_QUILT\n    fragColor = textureLod(iChannel0, fragCoord / iResolution.xy, 0.);\n#else\n    vec3 rgb;\n    vec2 uv = fragCoord / iResolution.xy;\n    for (int chan = 0; chan < 3; ++chan) {\n        float z = (uv.x + float(chan) * subp + uv.y * slope) * pitch - center;\n        z = mod(z + ceil(abs(z)), 1.0);\n        z = (1.0 - invView) * z + invView * (1.0 - z);\n        \n        vec2 iuv = texArr(vec3(uv, z));\n        rgb[chan] = textureLod(iChannel0, iuv, 0.)[chan];\n    }\n    fragColor = vec4(rgb, 1.0);\n#endif\n\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[],"code":"\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n    vStringCharCoords.y = 1.0 - vStringCharCoords.y;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize the fragment coordinates and adjust for screen aspect ratio.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y = 1.0 - uv.y; // Flip Y axis to match top-left origin.\n\n    // Define grid dimensions.\n    const int cols = 8;\n    const int rows = 5;\n\n    // Calculate the size of each cell.\n    vec2 cellSize = 1.0 / vec2(float(cols), float(rows));\n\n    // Determine which cell this fragment belongs to.\n    vec2 cellPos = floor(uv / cellSize);\n    int index = int(cellPos.y) * cols + int(cellPos.x);\n\n    // Ensure index is within bounds.\n    if (index >= 0 && index < cols * rows)\n    {\n        // Calculate the number to display in this cell.\n        int numberToShow = index + 1;\n\n        // Convert the number to a color for rendering.\n        float hue = mod(float(numberToShow) / 40.0 * 360.0, 360.0);\n        float s = 0.5, v = 0.9; // Saturation and Value\n\n        // Convert HSV to RGB.\n        float C = v * s;\n        float X = C * (1.0 - abs(mod(hue / 60.0, 2.0) - 1.0));\n        float m = v - C;\n        vec3 rgb;\n\n        if      (hue < 60.0) rgb = vec3(C, X, 0.0);\n        else if (hue < 120.0) rgb = vec3(X, C, 0.0);\n        else if (hue < 180.0) rgb = vec3(0.0, C, X);\n        else if (hue < 240.0) rgb = vec3(0.0, X, C);\n        else if (hue < 300.0) rgb = vec3(X, 0.0, C);\n        else                  rgb = vec3(C, 0.0, X);\n\n        rgb = clamp((rgb + m), 0.0, 1.0); // Add the m component and clamp the values.\n\n        // Draw the colored cell as background.\n        fragColor = vec4(rgb, 1.0);\n\n        // Calculate the normalized position inside the current cell.\n        vec2 localUV = fract(uv / cellSize) - 0.5;\n\n        // Draw dots inside the cell.\n        for (int dotIndex = 0; dotIndex < numberToShow; ++dotIndex)\n        {\n            // Calculate the angle and radius for each dot.\n            float angle = 2.0 * 3.141592 * float(dotIndex) / float(numberToShow);\n            float radius = 0.4 * sqrt(float(dotIndex + 1) / float(numberToShow)); // Adjust the radius as needed.\n\n            // Calculate the position of the dot relative to the center of the cell.\n            vec2 dotPos = vec2(cos(angle), sin(angle)) * radius;\n\n            // Check if the current pixel is close enough to the dot position.\n            float distToDot = length(localUV - dotPos);\n            float dotRadius = 0.05; // Dot size, can be adjusted.\n            if (distToDot < dotRadius)\n            {\n                // Color of the dot.\n                fragColor = vec4(0.0, 0.0, 0.0, 1.0); // Black dots.\n            }\n        }\n        \n        // float PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n        float fIsDigit1 =  PrintValue(uv, uv - localUV, cellSize, float(numberToShow), 2., 0.);\n        fragColor = mix( fragColor, vec4(0.0, 1.0, 1.0, 1.0), fIsDigit1);\n        \n    }\n    else\n    {\n        // If outside the grid, color the pixel black.\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n\n    // Draw grid lines.\n    float lineWidth = 0.005;\n    if (fract(uv.x * float(cols)) < lineWidth || fract(uv.y * float(rows)) < lineWidth)\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lcKfDd","date":"1734604104","viewed":16,"name":"Fork C1 test xioxin 154","username":"xioxin","description":"Fork C1 test xioxin 154","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"lfyfD3","parentname":"C1 test"}}