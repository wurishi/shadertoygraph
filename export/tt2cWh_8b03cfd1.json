{"ver":"0.1","info":{"id":"tt2cWh","date":"1594353261","viewed":548,"name":"Make Fun With Volumetric Cloud","username":"shicz86","description":"a modified version of volumetric cloud for learning purpose,inspired by kaneta、Keyaki、Sebastian Lague(Youtube).\nhttps://www.shadertoy.com/view/WdXGRj\nhttps://www.shadertoy.com/view/Wsf3Dl\nhttps://shaderbits.com/blog/creating-volumetric-ray-marcher/","likes":20,"published":1,"flags":0,"usePreview":0,"tags":["volumetriccloudraymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ENABLE_JITTER 1\n#define ENABLE_SDF_SPHERE 1\nfloat jitter;\n#define MAX_STEPS 48\n#define SHADOW_STEPS 8\n#define VOLUME_LENGTH 15.\n#define SHADOW_LENGTH 2.\n\n// shift vec3\nmat3 m = mat3(0.,0.8,0.6,\n              -0.8,0.36,-0.48,\n              -0.6,-0.48,0.64);\n\n// 1d noise function\nfloat hash11(float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\n// value noise function\nfloat noise31(in vec3 n)\n{\n\tvec3 p = floor(n);\n    vec3 f = fract(n);\n    f = f*f*(3.-2.*f);\n    float q = p.x+p.y*57.+p.z*113.;\n    float r = mix(mix(mix(hash11(q+0.),hash11(q+1.),f.x),\n                      mix(hash11(q+57.),hash11(q+58.),f.x),f.y),\n                  mix(mix(hash11(q+113.),hash11(q+114.),f.x),\n                      mix(hash11(q+170.),hash11(q+171.),f.x),f.y),f.z);\n    return r;\n}\n\nfloat fbm(vec3 p)\n{\n\tfloat f;\n    f = 0.5*noise31(p);p = m*p*2.02;\n    f += 0.25*noise31(p);p = m*p*2.03;\n    f += 0.125*noise31(p);p = m*p*2.01;\n    f += 0.0625*noise31(p);\n    return f;\n}\n\n// sdf of torus\nfloat sdfTorus(vec3 p,vec2 r)\n{\n\tvec2 q = vec2(length(p.xz)-r.x,p.y);\n    return length(q)-r.y;\n}\n\n// sdf of sphere\nfloat sdfSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\n// contructive solid geometry\nfloat intersectSdf(float distA,float distB)\n{\n\treturn max(distA,distB);\n}\n\nfloat unionSdf(float distA,float distB)\n{\n\treturn min(distA,distB);\n}\n\nfloat differenceSdf(float distA,float distB)\n{\n\treturn max(distA,-distB);\n}\n\nfloat sdfScene(vec3 p,vec2 r1,float r2)\n{\n\tfloat distA = sdfTorus(p,r1);\n    float distB = sdfSphere(p,r2);\n    return unionSdf(distA,distB);\n}\n\nfloat map(in vec3 p)\n{\n    // shift vec3 p to make more random\n\tvec3 q = p - vec3(0.,.5,1.);\n    float f = fbm(q);\n    \n    // params of torus\n    float sdfLevel = 1.;vec2 r1 = vec2(7.,.75);float r2 = .5;float pScaleFator = 1.85;float fScaleFator = 3.;\n    float d = 0.;\n#if ENABLE_SDF_SPHERE\n    d = sdfLevel-sdfScene(p*pScaleFator,r1,r2)+f*fScaleFator;\n#else\n    d = sdfLevel-sdfTorus(p*pScaleFator,r1)+f*fScaleFator;\n#endif\n    //min(max(0.,d),1.);\n    return clamp(d,0.,1.);\n}\n\nvec4 cloudRayMarching(vec3 camPos,vec3 viewRay,vec3 lightDir,float index)\n{\n    lightDir = normalize(lightDir);\n    vec3 lightEnergy = vec3(0.);\n    \n    vec3 ambientColor = vec3(0.15,0.45,1.1);\n    vec3 ambientSampleOffset = vec3(0.,0.2,0.);\n    float ambientSampleScaleFator = 1.;\n    \n    float stepSize = VOLUME_LENGTH/float(MAX_STEPS);\n    float shadowStepSize = SHADOW_LENGTH/float(SHADOW_STEPS);\n    \n    float curDensity = 0.;\n    float transmittance = 1.;\n    \n    // params 1:index < 0.5,you can change the density of three channel\n    float volumeDensity = 0.633;\n    float redChannelDensity = 0.5+0.4*sin(iTime*.5);\n    float shadowDensityScaleFator = 0.75;\n    vec3 shadowDensity = vec3(redChannelDensity,0.3,0.2)*shadowDensityScaleFator; // reference value of redChannelDensity:vec3(.9,0.1,0.3)\n    \n    // param 2:index >= 0.5,fixed density for three channel\n    float densityMultiply = 20.0;\n    float denstiyScaleFator = 0.75;\n    float shadowTermMultiply = 3.;\n    \n    if(index < 0.5) {ambientSampleScaleFator = .5;}else {ambientSampleScaleFator = .2;}   \n    \n    vec3 pos = camPos+viewRay*jitter*stepSize;\n    for(int i = 0;i < MAX_STEPS;i++)\n    {\n        float curSample = map(pos);\n        if(curSample > 0.001)\n        {\n            vec3 lPos = pos;\n            float shadowDist = 0.;\n            for(int s = 0;s < SHADOW_STEPS;s++)\n            {\n                lPos += lightDir*shadowStepSize;\n                float lSample = map(lPos);\n                shadowDist += lSample;\n            }\n            if(index < 0.5)\n            {\n\t\t\t\tcurDensity = clamp(curSample*volumeDensity,0.,1.);\n                vec3 shadowTerm = exp(-shadowDist*shadowDensity);\n                lightEnergy += shadowTerm*curDensity*transmittance;\n            }\n            else\n            {\n            \tcurDensity = clamp((curSample/float(MAX_STEPS))*densityMultiply,0.,1.)*denstiyScaleFator;\n                float shadowTerm = exp(-shadowDist/float(SHADOW_STEPS)*shadowTermMultiply);\n                lightEnergy += shadowTerm*curDensity*transmittance;\n            }\n\n            transmittance *= 1.-curDensity;\n\n            // ambient color\n            lightEnergy += exp(-map(pos+ambientSampleOffset)*ambientSampleScaleFator)*curDensity*transmittance*ambientColor;\n        }\n        pos += viewRay*stepSize;\n    }\n    \n    return vec4(lightEnergy,transmittance);\n}\n\n// view matrix\nmat3 camera(vec3 camPos,vec3 lookAtPos,float rollDegree)\n{\n\tvec3 w = normalize(lookAtPos - camPos);\n    vec3 up = vec3(sin(rollDegree),cos(rollDegree),0.);\n    vec3 u = normalize(cross(w,up));\n    vec3 v = normalize(cross(u,w));\n    return mat3(u,v,w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// [-iResolution.xy,iResolution.xy]/min(iResolution.x,iResolution.y)\n    // so x = [-iResolution.x/iResolution.y,iResolution.x/iResolution.y]\n    // and y = [-1,1]\n    vec2 uv = (fragCoord.xy*2.0-iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n#if ENABLE_JITTER\n    jitter = hash11(uv.x+uv.y*57.+iTime);\n#endif\n    \n    vec3 lightDir = vec3(-1.,2.,-1.);\n    vec3 lightColor = vec3(1.,.7,.3);\n    \n    // camera pos\n    float camRotateRadius = 8.0;\n    float camRotateSpeed = 0.333;\n    float camPosY = -5.5;\n    vec3 camPos = vec3(cos(iTime*camRotateSpeed)*camRotateRadius,camPosY,sin(iTime*camRotateSpeed)*camRotateRadius);\n    \n    // lookat pos\n    float lookAtPosY = -.5;\n    vec3 lookAtPos = vec3(0.,lookAtPosY,0.);\n    \n    // pitch degree\n    float pitchDegree = 0.;\n    mat3 viewMat = camera(camPos,lookAtPos,pitchDegree);\n    \n    float planeZ = 1.75;\n    vec3 rayDir = vec3(uv,planeZ);\n    vec3 viewRay = viewMat * normalize(rayDir);\n \n    // change cloud color\n    float uvMovingSpeed = 1.25;\n    float uvMovingScaleFator = 1.5;\n    float uvMoving = uv.x+sin(iTime*uvMovingSpeed)*uvMovingScaleFator;\n    \n    float index = 0.;\n    vec4 col = vec4(0.);\n    // volumetric cloud\n    if(uvMoving < 0.)\n    {\n    \tcol = cloudRayMarching(camPos,viewRay,lightDir,0.);\n    }\n    else\n    {\n    \tcol = cloudRayMarching(camPos,viewRay,lightDir,1.);\n    }\n    \n    // color blending with the sky\n    vec3 skyColorBottom = vec3(.3,.6,1.);\n    vec3 skyColorTop = vec3(.05,.35,1.);\n    float skyColorOffsetY  = 0.75;\n    vec3 result = col.rgb + mix(skyColorBottom,skyColorTop,uv.y+skyColorOffsetY)*col.a;\n    \n    float sunDot = clamp(dot(viewRay,normalize(lightDir)),0.,1.);\n    // sun power\n    float sunDotPower = 4.;\n    float lightMultiply = .25;\n    result += lightColor*pow(sunDot,sunDotPower)*lightMultiply;\n    \n    result *= vec3(smoothstep(0.0,0.02,abs(uvMoving)));\n    \n    //gamma correction\n    result = pow(result,vec3(1./2.2));\n    \n    fragColor = vec4(result,1.0);\n}","name":"Image","description":"","type":"image"}]}