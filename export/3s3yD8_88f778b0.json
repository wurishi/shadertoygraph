{"ver":"0.1","info":{"id":"3s3yD8","date":"1600881570","viewed":697,"name":"Cloud Ray March","username":"rockmanx","description":"Volumetric Ray Marching\n\nTheory: https://disigns.wordpress.com/portfolio/shadertoy-glsl-demos/","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","cloud","volumetric"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////// Learning reference ////////////////////////////\n// https://www.shadertoy.com/view/lss3zr\n// https://www.shadertoy.com/view/3sXSRX\n// Fractal Brownian Motion: https://thebookofshaders.com/13/\n// Theory: https://www.youtube.com/watch?v=8OrvIQUFptA\n// Theory: https://shaderbits.com/blog/creating-volumetric-ray-marcher\n// Theory: https://web.cs.wpi.edu/~matt/courses/cs563/talks/powwie/p1/ray-cast.htm\n// Theory: https://www.seas.upenn.edu/~cis565/LECTURES/VolumeRendering.pdf\n// Drebin: https://dl.acm.org/doi/pdf/10.1145/54852.378484\n\n// what to do: \n// 1. generate a 3D noise using fbm\n// 2. ray marching thru this 3D noise\n// 3. at each sample point calculate light scattering. \n\n#define NEAR_PLANE -1.5\n\n// Cloud density function\n// A Inverse Sphere adding a 3D fbm noise\nfloat cloud_sdf(vec3 p)\n{\n    float sphere_size = 1.5;\n    float noise_size = 0.7;\n    float noise_freq = 2.5;\n    float sphere_space_scale = 0.3;\n    vec3 cloud_shape = vec3(0.8,1.0,0.8);\n    \n    float sph = sphere_size - length(p*cloud_shape) + fbm(p*noise_freq )*noise_size;\n    return sph*sphere_space_scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates\n    vec2 p = (2.0*fragCoord -iResolution.xy)/iResolution.y;   \n    \n    // camera settings\n    // float camera_y = 1.0-iMouse.y/iResolution.y;\n    // float camera_x = 0.5-iMouse.x/iResolution.x;\n    // vec3 camera_pos = 3.0*vec3(2.0*camera_x, 2.0*camera_y , 1.3);  \n    vec3 camera_pos = 3.0*vec3(cos(0.2*iTime), 0.9 + 0.2*sin(0.1*iTime) , sin(0.2*iTime));\n    \n    vec3 camera_tar = 3.0*vec3(0.0, 0.0, 0.0);\n    \n    // camera space\n    vec3 camera_w = normalize(camera_tar- camera_pos);\n    vec3 camera_u = normalize(cross(camera_w, vec3(0.0, 1.0, 0.0)));\n    vec3 camera_v = normalize(cross(camera_u,camera_w));\n    \n    // world space to camera space projection.\n    vec3 ray_hit = normalize(p.x*camera_u + p.y*camera_v + NEAR_PLANE*(-camera_w));  \n    vec3 ray_dir = normalize(ray_hit);\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    ////////// VOLUMETRIC SETTINGS //////////\n    // Transmittance that is initialized to 1.\n    // Total Color = Accumulation (Sampled Colors x Sampled Transmissivities)\n    // Linear Density = ray_distance/sample_points. \n    \n    const int sample_steps = 64;\n    const int light_steps = 6;\n    \n    // cloud attributes\n    float Transmittance = 1.0;\n    float Absorbtion = 90.0;\n    float ZDepth = 40.0;    \n    float StepSize = ZDepth/float(sample_steps); \n    vec3 cloud_color = vec3(1.3);\n    vec3 sample_pos = camera_pos; \n    \n    // sun attributes\n    float LightZDepth= 1.0;\n    float LightStepSize = LightZDepth/float(light_steps);\n    vec3 sun_dir = normalize(vec3(0.0, 0.1, 0.0));\n    vec3 sun_col = vec3 (1.0, 0.7, 0.5);\n    \n    // marching to the cloud sphere\n    for (int iter = 0; iter < sample_steps; iter++)\n    {\n    \tfloat depth = cloud_sdf(sample_pos);\n        \n        // ray is inside the cloud, start sampling.\n        if (depth > 0.0)\n        {\n            // Sample Density and Opacity\n            // Distance Traveled within media (depth) represents linear density. \n            // Opacity is adjusted by Absorbtion. \n            float current_density = depth / float(sample_steps); \n            float Opacity = current_density * Absorbtion; \n            \n            // Transmissivity = 1 - Opacity\n            Transmittance *= 1.0 - Opacity; \n        \tif (Transmittance<=0.01) break;\n            \n            // Light shadowing and scattering\n            float Light_Transmittance = 1.0;\n            for (int j=0; j<light_steps; j++)\n            {\n                vec3 light_sample_pos = sample_pos + sun_dir*LightStepSize*float(j);\n            \tfloat light_depth = cloud_sdf(light_sample_pos);\n                if (light_depth  > 0.0)\n                {\n                    float light_density = light_depth/float(sample_steps);\n                    float light_opacity = light_density * Absorbtion; \n                \tLight_Transmittance *= 1.0 - light_opacity;\n                    if (Light_Transmittance<=0.01) break;\n                }\n            }\n            \n            // color function: Color(x) = cloud_color * density\n            vec3 cur_cloud_col = cloud_color*Opacity*Transmittance;    \n            vec3 cur_light_col = sun_col*Opacity*Light_Transmittance*Transmittance;\n            col += cur_cloud_col + cur_light_col ;\n        }\n        sample_pos += ray_dir*StepSize;\n    }    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//-----------------------------------------------------------------------------\n// Maths utils\n//-----------------------------------------------------------------------------\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return res;\n}\n\n\nfloat fbm( in vec3 pos )\n{    \n    // properties\n    const int octaves = 2;\n    float lacunarity = 2.0;\n\tfloat gain = 0.5;\n    mat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n    \n    // initial values\n    float value = 0.0;\n    float amp = 0.5;\n    float frq = 0.0;\n    \n    // loop of octaves\n    for (int i = 0; i < octaves; i++)\n    {\n    \tvalue += amp*noise(pos);\n        pos = m*pos*lacunarity;\n        amp *= gain;\n        lacunarity += 0.01;\n    }\n    return value;\n}","name":"Common","description":"","type":"common"}]}