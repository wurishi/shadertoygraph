{"ver":"0.1","info":{"id":"dtsyDn","date":"1690629204","viewed":40,"name":"Raymarch Prototype","username":"Runar","description":"First time trying out raymarching. WIP\n\n(My linear algebra has improved a lot since my first projects lol)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 1e-2\n#define pi 3.1415\n#define tau 2.0*pi\n\n// calc_dist has a 'out vec3 col'.\n// Store unused colors here\nvec3 no_col = vec3(0.0);\n\nmat3 rot_mat(float theta) {\n    return mat3(\n        cos(theta), 0.0, sin(theta),\n        0.0, 1.0, 0.0,\n        -sin(theta), 0.0, cos(theta)\n    );\n}\n\nfloat calc_dist(vec3 pos, out vec3 col) {\n    float dist = MAX_DIST;\n    col = vec3(0.0);\n    \n    // Distance to sphere centered at O\n    float sphere_dist = length(pos) - 0.75;\n    vec3 sphere_col = vec3(1.0, 0.0, 0.0);\n    dist = sphere_dist;\n    col = sphere_col;\n    \n    // Waves centered at y = -0.5 with amplitude 0.1 and frequency 5.0\n    float plane_dist = pos.y + (sin((iTime-pos.x)*5.0)*0.1+0.5);\n    vec3 plane_col = vec3(0.0, 1.0, 0.0);\n    if (dist > plane_dist) {\n        dist = plane_dist;\n        col = plane_col;\n    }\n    \n    // Box with center at (0, -0.25, 1.5) with side lengths = 0.5\n    float box_dist = length(max(abs(pos - vec3(0.0, -0.25, 1.5)) - vec3(0.25), 0.0));\n    vec3 box_col = vec3(0.0, 0.0, 1.0);\n    if (dist > box_dist) {\n        dist = box_dist;\n        col = box_col;\n    }\n    \n    // Capsule \"originally\" at (0, 0, -2) but translated with time\n    float sin_time = sin(pow(iTime, abs(cos(iTime))/2.0));\n    float capsule_dist = length(pos - vec3(clamp(pos.x - sin_time, 0.0, 0.5), 0.0, 0.0) - vec3(sin_time, 0.0, -2.0)) - 0.05;\n    vec3 capsule_col = vec3(0.9, 0.9, 0.0);\n    if (dist > capsule_dist) {\n        dist = capsule_dist;\n        col = capsule_col;\n    }\n    \n    return dist;\n}\n\nfloat raymarch(vec3 ro, vec3 rd, out vec3 col) {\n    // Distance from origin, distance to scene (surface)\n    float dO = 0.0, dS;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        // Current raymach iter position\n        vec3 pos = ro + rd * dO;\n        \n        // Calculate distance to scene from this position\n        dS = calc_dist(pos, col);\n        \n        // Add dS to dO\n        dO += dS;\n        \n        // Break if under right conditions\n        if (dS < SURF_DIST || dO > MAX_DIST)\n            break;\n            \n    }\n    \n    // Return distance from origin\n    return dO;\n}\n\nfloat raymarch_light(vec3 ro, vec3 rd, vec3 light_pos) {\n    // Same raycast function as above but also calculating distance to light\n    float dO = 0.0, dS, dL;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 pos = ro + rd * dO;\n        dL = length(light_pos - pos);\n        dS = calc_dist(pos, no_col);\n        dO += min(dS, dL);\n        if (dL < SURF_DIST || dS < SURF_DIST || dO > MAX_DIST)\n            break;\n    }\n    // Return final distance to light\n    return dL;\n}\n\nvec3 calc_norm(vec3 pos) {\n    // Offset variable (as vector for use of offs.xyy etc.)\n    vec2 offs = vec2(1e-5, 0.0);\n    \n    // Approximated surface normal at position using central difference \n    vec3 normal = vec3(\n        calc_dist(pos + offs.xyy, no_col),\n        calc_dist(pos + offs.yxy, no_col),\n        calc_dist(pos + offs.yyx, no_col)) - vec3(\n        calc_dist(pos - offs.xyy, no_col),\n        calc_dist(pos - offs.yxy, no_col),\n        calc_dist(pos - offs.yyx, no_col)\n    );\n    \n    return normalize(normal);\n}\n\nfloat calc_light(vec3 pos, vec3 norm) {\n    // Light at (5, 5, 5)\n    // (And moving around O with time)\n    vec3 light_pos = vec3(5.0, 7.0, 5.0) * rot_mat(iTime + 2.5);\n    \n    // Direction from the light to the position\n    vec3 light_vec = light_pos - pos;\n    vec3 light_dir = normalize(light_vec);\n    \n    // Diffuse light recieved is equal to positive value of dot product\n    // (Negative values means position is \"pointing\" away from the light)\n    float light_diff = max(dot(light_dir, norm), 0.0);\n    \n    // Also check if in shadow, i.e. something blocks the light view\n    // This is done by raymarching from a position slightly away following normal\n    // to the light.\n    vec3 start_pos = pos + norm*1e-2*2.0;\n    float light_dist = raymarch_light(start_pos, normalize(light_pos-start_pos), light_pos);\n    \n    // Return diff_light if you can see the light, 0.05 (shadow) if not\n    if (light_dist <= SURF_DIST) {\n        return light_diff;\n    }\n    \n    return 0.05;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Coordinate system with origin at center\n    vec2 uv = ( fragCoord - .5*iResolution.xy ) / iResolution.y;\n\n    // Camera rotation matrix\n    float sensitivity = 1.5;\n    vec2 mouse = vec2(iMouse.x/iResolution.x-0.5, iMouse.y/iResolution.y-0.5) * sensitivity;\n    mat3 cam_rot_mat = rot_mat(mouse.x * tau);\n    \n    // Ray origin and direction (shortened by convention)\n    vec3 ro = vec3(0, 0, -3) * cam_rot_mat;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1) * cam_rot_mat);\n    \n    vec3 hit_col = vec3(0.0);\n    \n    // Raymarch to scene\n    float dist = raymarch(ro, rd, hit_col);\n    \n    vec3 col = vec3(0.0);\n    if (dist < MAX_DIST) {\n        vec3 pos = ro + rd * dist;\n        \n        // Find normal at point\n        vec3 norm = calc_norm(pos);\n        \n        // Calculate and set color to light recieved\n        float light = calc_light(pos, norm);\n        col = light * hit_col;\n    }\n    \n    \n    // Add some simple fog\n    float fog_intensity = 0.5;\n    vec3 fog_col = vec3(0.2, 0.4, 0.6);\n    col = mix(fog_col, col, exp(dist * -fog_intensity/10.0));\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}