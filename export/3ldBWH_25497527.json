{"ver":"0.1","info":{"id":"3ldBWH","date":"1613167984","viewed":250,"name":"Threaded Connection","username":"UnstableLobster","description":"Caught in vortices, we forget who we are.","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["fluid","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 normals(vec2 pos, sampler2D sampler)\n{\n    float c = texel(sampler, pos).z;\n    float l = texel(sampler, pos + vec2(-1.0, 0.0)).z;\n    float r = texel(sampler, pos + vec2(1.0, 0.0)).z;\n    float d = texel(sampler, pos + vec2(0.0, -1.0)).z;\n    float u = texel(sampler, pos + vec2(0.0, 1.0)).z;\n    \n    \n    vec3 va = normalize(vec3(vec2(2.0, 0.0), r-l));\n    vec3 vb = normalize(vec3(vec2(0.0, 2.0), u-d));\n    //return cross(va,vb);\n    \n    float ld = texel(sampler, pos + vec2(-1.0, -1.0)).z;\n    float ru = texel(sampler, pos + vec2(1.0, 1.0)).z;\n    float rd = texel(sampler, pos + vec2(1.0, -1.0)).z;\n    float lu = texel(sampler, pos + vec2(-1.0, 1.0)).z;\n    \n    float me = (l+r+u+d+ld+ru+rd+ld)/8.0;\n    me = l * 0.25\n        +r * 0.25\n        +d * 0.25\n        +u * 0.25;\n\n    return normalize(vec3(l-r, d-u, c*0.5));\n    //return normalize(vec3(l-r, d-u, c/c) * vec3(c, c, 1.0));\n    //return normalize(vec3(l-r, d-u, saturate(me-c)+c*0.1) * vec3(c, c, 1.0));\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    vec2 V = P.V*0.4;\n    V *= rot(iTime*0.1 + 2.0);\n    //V *= rot(2.8 - PI);\n    \n    //color\n    vec3 cv = vec3(V*0.5+0.5, length(min(V*rot(0.0), 0.0)) );\n    cv = pow(cv, vec3(1.1));\n\n    //mixing\n    cv = mix(vec3(1.0), cv, pow(saturate(length(V)*1.0), 0.8) );\n    O.xyz = cv;\n\n    //shade\n    O.xyz *= pow(P.M*0.6, mix(0.75, 0.9, saturate(length(P.V)*1.0)) );\n\n    //shine\n    O.xyz += vec3( abs(texel(ch1, pos).w*0.15) ) * -sign(P.T-0.5);\n\n    //mix fog\n    O.xyz = mix(vec3(P.T), O.xyz, saturate( length(P.V)*1.0 +0.1) );\n\n    //a bit of depth\n    O.xyz *= vec3( saturate( pow( normals(pos, ch1).y *0.5 + 0.5, 0.2)+0.1) );\n\n    //\n    O.xyz = pow(O.xyz, vec3(1.0/2.2));\n\n    //2d shadows test\n    /*float depth = 0.1;\n    vec3 o = vec3(pos, abs(texel(ch1, pos).z * depth));\n    vec3 d = normalize(vec3(1.0, 1.0, 0.001));\n    float t = 0.0;\n    \n    float s = 1.0;\n    \n    loop(i, 20)\n    {\n        vec3 now = o + d*t;\n        if (abs(texel(ch1, now.xy).z * depth) > now.z)\n        {\n            s = 0.0;\n            break;\n        }\n        t += 0.5;\n    }\n    O.xyz = saturate( vec3(t*0.1)+0.0 );*/\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define texel(a, p) texelFetch(a, ivec2(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define snormalize(x) ((length(x) > 0.0) ? normalize(x) : x)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define G(x) exp(-dot(x*2.0,x*2.0))\n#define GS(x) exp(-length(x*2.0))\n#define dot2(x) dot(x,x)\n\n#define sinT(x) (sin((x-0.5)*PI)*0.5+0.5)\n\n#define dt 1.0\n#define MASS_REST 0.8\n#define fluid_rho 1.0\n#define particle_rad 3.0\n\n\n\n#define SET_GLOBALS R = iResolution.xy; time = iTime; Mouse = iMouse;\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n\nmat2 rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(rot(1.0*time-0.0)*(p - R*vec2(0.5, 0.5)) , R*vec2(0.15, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 0.5));\n    return bound - 5.0;\n    return min(bound, box);\n    return max(drain,min(bound, box));\n}\n\n#define hh 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-hh,0,hh);\n    vec4 idx = vec4(-1./hh, 0., 1./hh, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x); \n    \n    //return unpackSnorm2x16(X);\n    return unpackHalf2x16(X);\n}\n\nfloat encode(vec2 x)\n{\n    //uint X = packSnorm2x16(x);\n    uint X = packHalf2x16(x);\n   \n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    float T;\n    float M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.T = data.z;\n    P.M = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = P.X - pos;\n    return vec4(encode(P.X), encode(P.V), P.T, P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n/*float ify(float x, float y, bool b)\n{\n    return mix(y, x, float(b));\n}*/\n\n#define pixel_scale 1.0\nfloat W(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n\treturn (x >= 0.0 && h >= x) ? //>=\n        ( 4.0 / (PI * pow(h, 8.0))) * pow(h*h - dot2(r), 3.0 ) :\n\t\t0.0;\n}\nvec2 WS(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n\treturn (x > 0.0 && h >= x) ?\n        -(30.0 / (PI * pow(h, 5.0)))  * pow(h - x, 2.0) * normalize(r) :\n\t\tvec2(0.0);\n}\nfloat WV(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n\treturn (x > 0.0 && h >= x) ?\n        (20.0 / (PI * pow(h, 5.0)))  * (h - x) :\n\t\t0.0;\n}\n\nfloat WTest(vec2 r, float h)\n{\n\treturn (length(r) >= 0.0 && h >= length(r)) ? //>=\n        ( 4.0 / (PI * pow(h, 5.7))) * pow(h*h - dot2(r), 3.0 ) :\n\t\t0.0;\n}\n\nfloat WC(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float a = 32.0 / (PI * pow(h, 9.0));\n    \n\tif (length(r)*2.0 > h && length(r) <= h)\n        return a * ( pow(h - length(r), 3.0) * pow(length(r), 3.0) );\n    if (length(r) > 0.0 && length(r)*2.0 <= h)\n        return a * ( pow(h - length(r), 3.0) * 2.0 - (pow(h, 6.0)/64.0) );\n\treturn 0.0;\n}\n\nfloat WA(vec2 r, float h)\n{\n    r /= pixel_scale;\n    float x = length(r);\n    if (x*2.0 > h && x <= h)\n        return pow(-(4.0*x*x/h) + 6.0*x - 2.0*h, 1.0/4.0) * 0.007/pow(h, 3.25);\n    return 0.0;\n}\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// michael0884Â´s thing\n// https://www.shadertoy.com/view/wsVcRK\n\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec2 omin = clamp(x - K*0.5, p - 0.5, p + 0.5);\n    vec2 omax = clamp(x + K*0.5, p - 0.5, p + 0.5); \n    return vec3(0.5*(omin + omax), (omax.x - omin.x)*(omax.y - omin.y)/(K*K));\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    float dy = 0.0;\n\n    int I = 5; \n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n        \n        P0.X += P0.V*dt;\n\n        vec3 D = distribution(P0.X, pos, 2.0);\n        vec3 Dy = distribution(P0.X, pos, 1.01+saturate(iTime*0.04)*0.8 );\n        float m = P0.M*D.z; //the deposited mass into this cell\n\n        //add weighted by mass\n        P.X += mix(P0.X, D.xy, 0.5)*m;\n        P.V += P0.V*m;\n        P.T += P0.T*P0.M*Dy.z;\n        \n        //add mass\n        P.M += m;\n        dy += P0.M*Dy.z;\n    }\n    \n    //normalization\n    if (P.M != 0.0)\n    {\n        P.X /= P.M;\n        P.V /= P.M;\n    }\n    if (dy != 0.0)\n        P.T /= dy;\n    \n    //----- \n    //if (border(pos) > 7.0)\n    if (P.M != 0.0)\n    {\n        float prevM = P.M;\n        //P.M.x = mix(P.M.x, MASS_REST, saturate( 0.1 - length(P.V)*0.075) ); //0.05 //0.1\n        \n        float s = saturate( 0.1 - length(P.V)*0.075);\n        float ss = mix(0.1, s, saturate( pow(P.M/MASS_REST, 0.01) ) );\n        \n        P.M = mix(P.M, MASS_REST, ss );\n        \n        P.V = P.V * prevM/P.M;\n    }  \n}\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n    \n    particle P;     \n    Reintegration(ch0, P, pos);\n\n    if (iFrame == 0)\n    {\n        vec3 rand = hash32(pos);\n        \n        P.X = pos;\n        P.V = pos*0.0;\n        P.M = 0.6;\n        P.T = 0.5;\n    }\n    \n    O = saveParticle(P, pos);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//smoothed density, pressure and curl\n\nfloat cross2d(vec2 a, vec2 b) { return a.x*b.y - a.y*b.x; }\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    float den = 0.0;\n    float curl = 0.0;\n    \n    int I = int(ceil(particle_rad));\n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch0, tpos);\n        particle P0 = getParticle(data, tpos);\n        \n        //density\n        den += W(P.X - P0.X, particle_rad) * P0.M;\n\n        //curl\n        vec2 u = P.V - P0.V;\n        vec2 v = WS(P.X - P0.X, particle_rad);    \n        curl += cross2d(u, v) * P0.M;// * (1.0+abs(P.T - P0.T)*50.0 * (1.0-length(P.V)));\n    }\n\n    //pressure\n    float Y = 2.0;\n    float C = 0.01;\n    float pr = ((fluid_rho*C)/Y) * (pow(den/fluid_rho, Y) - 1.0);\n    \n    pr /= den*den;\n\n    //gas\n    //pr = den*0.1;\n    \n    O = vec4(den, pr, P.M, curl);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    vec4 pr = texel(ch1, pos);\n    vec3 n = vec3(0.0);\n    vec2 F = vec2(0.);\n\n    int I = int(ceil(particle_rad));\n    range(i, -I, I) range(j, -I, I)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n   \n        vec2 dx = P0.X - P.X;\n        float d = length(dx);         \n  \n        //fluid\n        vec4 pr0 = texel(ch1, tpos); \n        float pf = pr.y + pr0.y;\n\n        F += WS(dx, particle_rad)\n        //* P0.M.x\n        //* pf\n        * pr0.x\n        * 1.0;    \n            \n        //vort   \n        n -= vec3(WS(dx, particle_rad) * abs(pr0.w) * P0.M, 0.0);\n        \n        //viscosity\n        F -= WV(dx, particle_rad) * (P.V-P0.V) * 0.05;       \n    }\n    \n    //vort\n    if (length(n) > 0.0)\n    {\n        vec3 vf = cross(normalize(n), vec3(0.0, 0.0, pr.w));\n        F += vf.xy * 0.2;// / (1.0 + length(getV(P)));\n    }\n\n    if (iMouse.z > 0.)\n    {\n        vec2 dm = snormalize((iMouse.xy - iMouse.zw)/20.);\n        dm = vec2(0.0, 1.0);\n        /*float d = distance(iMouse.xy, P.X)/25.0;\n        F += 0.15*dm*exp(-d*d);*/     \n        if (length(P.X - iMouse.xy) < 25.0/600.0*R.x)\n        {\n            P.V += 0.1*snormalize(dm) * 600.0/R.x;\n            P.T = mix(P.T, 0.5, G(length(P.X - iMouse.xy)));\n        }\n    }  \n    \n    // border\n    //if (border(P.X) <= 0.0) F -= bN(P.X).xy * border(P.X);\n \n    //integrate\n    P.V += F;\n}\n\nvoid mainImage( out vec4 O, in vec2 pos )\n{\n    SET_GLOBALS\n\n    vec4 data = texel(ch0, pos);   \n    particle P = getParticle(data, pos);\n   \n    if (P.M != 0.0) //not vacuum\n        Simulation(ch0, P, pos);\n    \n    if (true)\n    {   \n        if (length(P.X - R*vec2(0.9, 0.5)) < 25.0/600.0*R.x) \n        {\n            P.V += 0.125*dir(PI + 0.0*sin(0.4*time)) * 600.0/R.x;\n            P.T = 1.0;\n        }\n        if (length(P.X - R*vec2(0.1, 0.5)) < 25.0/600.0*R.x) \n        {\n            P.V += 0.125*dir(-PI*0.0 + 0.0*sin(0.3*time)) * 600.0/R.x;\n            P.T = 0.0;\n        }\n    }\n    \n    O = saveParticle(P, pos);\n}","name":"Buffer C","description":"","type":"buffer"}]}