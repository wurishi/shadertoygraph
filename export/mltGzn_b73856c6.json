{"ver":"0.1","info":{"id":"mltGzn","date":"1681900927","viewed":111,"name":"Gyroid Orb","username":"dansh0","description":"Playing with gyroids, time animation, glowy things. Just having fun. Maybe it grants wishes or something.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["orb","gyroid","tpms"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n\nfloat gyroid(vec3 point) {\n    return cos(point.x) * sin(point.y) + cos(point.y) * sin(point.z) + cos(point.z) * sin(point.x);\n}\n\nfloat sphereDepth(vec2 position) {\n    return sqrt(1.0 - length(position)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // try: gyroidDivisor = 15.0, margin = -iResolution.y\n    // try: gyroidDivisor = 5.0, margin = 20.0\n\n    // input parameters\n    float gyroidDivisor = 5.0; // changes gyroid periodicity\n    float margin = 20.0; // margin of screen, determines sphere size (try negative for massive)\n    float timeConstant = 20.0; // controls animation speed (higher is slower)\n    float gyroidPeriodSwing = 0.1; // how much the period size changes (higher is more drastic change, try to avoid crossing 1.0 or else it gets weird)\n    float glowPower = 0.75; // general glow (higher increases overall sphere glow)\n    float edgeGlowPower = 5.0; // edge glow parameter 1 (higher increases fall-off from edge to center)\n    float edgeGlowStrength = 5.0; // edge glow parameter 2 (higher makes edge glow brighter)\n    float backgroundBrightness = 0.75; // 0.0-1.0 for background brightness\n    \n    // animated\n    float timePhase = sin(iTime/timeConstant);\n    \n    // inits\n    vec3 col;\n\n    // solve depth\n    float minScreenEdge = min(iResolution.y, iResolution.x);\n    float sphereRadiusPix = minScreenEdge/2.0 - margin;\n    vec2 fragCoordCentered = fragCoord - (0.5*iResolution.xy);\n    float depth = sphereDepth(fragCoordCentered/sphereRadiusPix);\n    float inverseDepth = 1.0-depth;\n    \n    // inside sphere\n    if (depth > 0.0) {\n    \n        // position and \"normal\"\n        vec3 position = vec3(fragCoordCentered/sphereRadiusPix, depth) + timePhase;\n        vec3 normal = abs(position);\n        \n        // solve gyroid\n        float gyroidDivisorAnimated = gyroidDivisor*(1.0-(gyroidPeriodSwing/2.0)+timePhase/(1.0/gyroidPeriodSwing));\n        float gyroidFactor = gyroid(position*2.0*PI*gyroidDivisorAnimated);\n        float inverseGyroidAbs = 1.5-abs(gyroidFactor);\n        \n        // solve glow\n        float edgeGlow = pow(inverseDepth, edgeGlowPower) * edgeGlowStrength;\n        float glow = glowPower + edgeGlow;\n        \n        // color\n        col = vec3(normal*glow*inverseGyroidAbs);\n    } \n    \n    // background \n    else {\n        \n        float maxScreenEdge = max(iResolution.y, iResolution.x);\n        float cornerRadius = sqrt(pow(minScreenEdge/2.0, 2.0) + pow(maxScreenEdge/2.0, 2.0))*1.25;\n        float backgroundGradient = sphereDepth(fragCoordCentered/cornerRadius);\n        col = vec3(backgroundGradient*backgroundBrightness);\n    }\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}