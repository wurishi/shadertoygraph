{"ver":"0.1","info":{"id":"ssj3WK","date":"1617988123","viewed":64,"name":"Noise and UV Mapping","username":"Drysmall","description":"Noise and UV Mapping","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cis561hw9"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Intersection{\n    float t;\n    vec3 color;\n    vec3 position;\n    int objectIdx;\n};\n\nvec3 rotateAroundY(vec3 p, float a){\n    return vec3(cos(a) * p.x + sin(a) * p.z, p.y, -sin(a) * p.x + cos(a) * p.z);\n}\n\nfloat plane(vec3 pos, vec4 nor){\n  return dot(pos, nor.xyz) + nor.w;\n}\n\nfloat box(vec3 pos, vec3 b){\n  return length(max(abs(pos) - b, 0.0));\n}\n\nfloat sphere(vec3 pos, float radius, vec3 c){\n    return distance(pos, c) - radius;\n}\n\nvec2 planeUV(vec3 origin, vec3 nor, vec3 pos){\n    vec3 u = normalize(cross(vec3(0., 1., 0.), nor));\n    vec3 v = normalize(cross(nor, u));\n    return vec2(dot(pos - origin, u), dot(pos - origin, v));\n}\n\nvec2 sphereUV(vec3 origin, float radius, vec3 pos){\n    vec3 direction = normalize(pos - origin);\n    float phi = acos(dot(normalize(vec3(direction.x, 0., direction.z)), vec3(1., 0., 0.)));\n    if (direction.z < 0.0){\n        phi += 3.1415926;\n    }\n    return vec2(acos(dot(direction, vec3(0., 1., 0.))) / 3.1415926, phi / (2. * 3.1415926));\n}\n\nfloat worleyNoise(vec2 uv) {\n    float result = 1.;\n    uv = uv * 0.5;\n\n    for(int x = -1; x < 2; x++) {\n        for(int y = -1; y < 2; y++) {\n            vec2 pos = floor(uv) + vec2(x, y);\n\t\t\tpos = 0.3 * sin(iTime + 5. * fract(sin(vec2(dot(pos, vec2(300., 300.)),\n                  dot(pos, vec2(100., 100.))))));\n            result = min(result, length(vec2(x, y) + pos - fract(uv)));\n        }\n    }\n    \n    return result;\n}\n\nfloat smoothStep(float n1, float n2, float t) {\n    return mix(n1, n2, pow(t, 3.) * (t * (t * 6. - 18.) + 13.));\n}\n\nfloat brownianVal(vec2 uv) {\n    vec2 lowerLeft = floor(uv);\n    vec2 lowerRight = floor(uv) + vec2(1, 0);\n    vec2 upperLeft = floor(uv) + vec2(0, 1);\n    vec2 upperRight = floor(uv) + vec2(1, 1);\n    \n    return smoothStep(smoothStep(fract(sin(dot(lowerLeft, vec2(2., 1.)))),\n           fract(sin(dot(lowerRight, vec2(2., 1.)))), fract(uv).x),\n           smoothStep(fract(sin(dot(upperLeft, vec2(2., 1.)))),\n           fract(sin(dot(upperRight, vec2(2., 1.)))), fract(uv).x), fract(uv).y);\n}\n\nfloat fbm(vec2 uv) {\n    float total = 0.;\n    float amplitude = 0.3;\n    float frequency = 10.;\n    \n    for(int i = 0; i < 4; i++) {\n        total += brownianVal(uv * frequency) * amplitude;\n        amplitude *= 0.3;\n        frequency *= 3.0;\n    }\n    \n    return total;\n}\n\nfloat surflet(vec3 pos, vec3 grid){\n    vec3 tempT = abs(pos - grid);\n    vec3 t = vec3(0.5 - 5. * pow(tempT.x, 5.) - 10. * pow(tempT.x, 4.) + 5. * pow(tempT.x, 3.),\n             0.5 - 5. * pow(tempT.y, 5.) - 10. * pow(tempT.y, 4.) + 5. * pow(tempT.y, 3.),\n             0.5 - 5. * pow(tempT.z, 5.) - 10. * pow(tempT.z, 4.) + 5. * pow(tempT.z, 3.));\n\n    return dot(pos - grid, fract(sin(vec3(dot(grid, vec3(1, 3, 1)),\n           dot(grid, vec3(2, 2, 8)), dot(grid, vec3(4, 4, 1)))))) * t.x * t.y * t.z;\n}\n\nfloat PerlinNoise(vec3 pos){\n    float total_surflet = 0.;\n    \n    for (int x = 0; x < 2; x++){\n        for (int y = 0; y < 2; y++){\n            for (int z = 0; z < 2; z++){\n                total_surflet += surflet(pos, floor(pos) + vec3(x, y, z));\n            }\n        }\n    }\n    \n    return total_surflet;\n}\n\nconst int RAY_STEPS = 512;\nconst float FOVY = 3.14156926 * 0.25;\nconst vec3 a = vec3(0.3, 0.6, 0.3);\nconst vec3 b = vec3(0.7, 0.5, 0.7);\nconst vec3 c = vec3(0.5, 1.0, 1.0);\nconst vec3 d = vec3(0.35, 0.45, 0.55);\n\nvec3 cosineColor(float t){\n    return a + b * cos(7. * (t * c + d));\n}\n\n#define BACKWALL_SDF plane(pos, vec4(0., 0., -1., 5.))\n#define BACKWALL_ID 0\n\n#define LEFTWALL_SDF plane(pos, vec4(1., 0., 0., 5.))\n#define LEFTWALL_ID 1\n\n#define RIGHTWALL_SDF plane(pos, vec4(-1., 0., 0., 5.))\n#define RIGHTWALL_ID 2\n\n#define CEILING_SDF plane(pos, vec4(0., -1., 0., 7.5))\n#define CEILING_ID 3\n\n#define FLOOR_SDF plane(pos, vec4(0., 1., 0., 2.5))\n#define FLOOR_ID 4\n\n#define BOX1_SDF box(rotateAroundY(pos + vec3(-2., 0.5, -3.), -30. * 3.1415926 / 180.0), vec3(1.5, 3., 1.5))\n#define BOX1_ID 5\n\n#define BOX2_SDF sphere(pos, 1., vec3(-2., 1., -0.75))\n#define BOX2_ID 6\n\nfloat mySceneT(vec3 pos){\n    float t = BACKWALL_SDF;\n    \n    t = min(t, LEFTWALL_SDF);\n    t = min(t, RIGHTWALL_SDF);\n    t = min(t, CEILING_SDF);\n    t = min(t, FLOOR_SDF);\n    t = min(t, BOX1_SDF);\n    t = min(t, BOX2_SDF);\n    \n    return t;\n}\n\nvec3 computeNormal(vec3 pos){\n    vec3 epsilon = vec3(0.0, 0.001, 0.0);\n    return normalize(vec3(mySceneT(pos + epsilon.yxx) - mySceneT(pos - epsilon.yxx),\n                          mySceneT(pos + epsilon.xyx) - mySceneT(pos - epsilon.xyx),\n                          mySceneT(pos + epsilon.xxy) - mySceneT(pos - epsilon.xxy)));\n}\n\nvoid myScene(vec3 pos, out float t, out int obj){\n    t = BACKWALL_SDF;\n    obj = BACKWALL_ID;\n    float tempT;\n    \n    if ((tempT = LEFTWALL_SDF) < t){\n        t = tempT;\n        obj = LEFTWALL_ID;\n    }\n    if ((tempT = RIGHTWALL_SDF) < t){\n        t = tempT;\n        obj = RIGHTWALL_ID;\n    }\n    if ((tempT = FLOOR_SDF) < t){\n        t = tempT;\n        obj = FLOOR_ID;\n    }\n    if ((tempT = CEILING_SDF) < t){\n        t = tempT;\n        obj = CEILING_ID;\n    }\n    if ((tempT = BOX1_SDF) < t){\n        t = tempT;\n        obj = BOX1_ID;\n    }\n    if ((tempT = BOX2_SDF) < t){\n        t = tempT;\n        obj = BOX2_ID;\n    }\n}\n\nvoid rayMarch(vec3 origin, vec3 dir, out float t, out int objHit){\n    t = 0.001;\n    \n    for (int i = 0; i < RAY_STEPS; i++){\n        float m;\n        vec3 pos = origin + t * dir;\n        \n        myScene(pos, m, objHit);\n        if (m < 0.01){\n            return;\n        }\n        t += m;\n    }\n    \n    t = -1.;\n    objHit = -1;\n}\n\nvec3 computeMaterials(int objHit, vec3 pos, vec3 nor, vec3 lightVec, vec3 view){\n    float lambert = dot(-lightVec, nor);\n    \n    switch(objHit){\n        case BOX1_ID:\n        float t = PerlinNoise(vec3(pos.x + 0.5 * sin(iTime),\n                               pos.y + 0.5 * sin(iTime), pos.z + 0.5 * sin(iTime)));\n        return cosineColor(t) * lambert;\n        break;\n        case BOX2_ID:\n        vec2 uv = sphereUV(vec3(-2., 1., -0.75), 1., pos);        \n        uv.x = uv.x + 0.5 * sin(iTime);\n        uv.y = uv.y + 0.5 * sin(iTime);               \n        return cosineColor(fbm(uv)) * lambert;        \n        break;\n        case BACKWALL_ID:\n        return cosineColor(0.6 + worleyNoise(planeUV(vec3(0.), vec3(0., 0., -1.), pos))) * lambert;\n        break;\n        case LEFTWALL_ID:\n        return vec3(0., 1., 0.) * lambert;\n        break;\n        case RIGHTWALL_ID:\n        return vec3(1., 0., 0.) * lambert;\n        break;\n        case CEILING_ID:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case FLOOR_ID:\n        return vec3(1., 1., 1.) * lambert;\n        break;\n        case -1:\n        return vec3(0., 0., 0.);\n        break;\n    }\n}\n\nIntersection sdf(vec3 dir, vec3 eye){\n    float t;\n    int objHit;\n    \n    rayMarch(eye, dir, t, objHit);\n\n    vec3 m_intersection = eye + t * dir;\n    vec3 nor = computeNormal(m_intersection);\n    vec3 lightPos = vec3(0., 4., -2.);\n    vec3 lightDir = normalize(m_intersection - lightPos);\n    vec3 color = computeMaterials(objHit, m_intersection, nor,\n                        lightDir, normalize(eye - m_intersection));\n\n    return Intersection(t, color, m_intersection, objHit);\n}\n\n\nvec3 rayCast(vec3 eye, vec3 ref, vec2 ndc){\n    vec3 F = ref - eye;\n    vec3 R = normalize(cross(F, vec3(0., 1., 0.)));\n    vec3 U = normalize(cross(R, F));\n    vec3 V = U * length(F) * tan(FOVY * 0.5);\n    vec3 H = R * length(F) * tan(FOVY * 0.5) * float(iResolution.x) / iResolution.y;\n    \n    return normalize(ref + ndc.x * H + ndc.y * V - eye);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - vec2(1.0, 1.0);\n    \n    vec3 eye = vec3(0, 3, -15);\n    vec3 ref = vec3(0, 2, 0);\n    \n    vec3 rayDir = rayCast(eye, ref, uv);\n    Intersection m_intersection = sdf(rayDir, eye);\n \n    fragColor = vec4(m_intersection.color, 1.0);\n}","name":"Image","description":"","type":"image"}]}