{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"nearest","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"// inspired from https://www.shadertoy.com/view/MdjGWy#\n\n\n// for faster eval, you can decrease proportionnaly NB and GAUSS_F to keep coverage\nfloat GAUSS_F = .1;    // size of gabor blobs\n#define NB 100.        // number or gabor blobs\n\n#define SCALE 30.      // SCALING FACTOR for superimposing signal and fourier spaces\n\n#define PI 3.14159265358979\n\n// --- key toggles -----------------------------------------------------\n\nbool keyToggle(int ascii) {\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n\n// --- util math func  -----------------------------------------------------\n\n#if 0  // 1: texture-based noise  0: function-based noise\nfloat rnd(vec2 uv, int z) \n{\n\tif      (z==0) return texture(iChannel1,uv).r;\n\telse if (z==1) return texture(iChannel1,uv).g;\n\telse if (z==2) return texture(iChannel1,uv).b;\n\telse           return texture(iChannel1,uv).a;\n}\nfloat rndi(float i, float j)\n{\n\tvec2 uv = vec2(.5+i,.5+j)/ iChannelResolution[1].x;\n\treturn texture(iChannel1,uv).r;\n}\n#else\nfloat rndi(float i, float j)\n{\n\treturn fract(sin(i+9876.*j)*12345.678);\n}\n#endif\n\nfloat gauss(float x, float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(float x) {\n    return exp(-.5*x*x); \n}\nfloat gauss(float s,vec2 D) {\n\tfloat d = dot(D,D)/(s*s);\n\treturn exp(-.5*d); \n}\n\n#define SQR(x) ((x)*(x))\n\nfloat gabor(vec2 pos, vec2 k, float gaussF, float phi) {\n\tfloat g = gauss(length(pos), 1./gaussF);\n    float s = .5*sin(2.*PI*dot(pos,k) - phi);\n\treturn g*s;\n}\n\n// -----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.85,.5));\n\n\t// --- tuning \n\t\n\tvec4 mouse; \n\tmouse.xy = 2.*(iMouse.xy/  iResolution.y - vec2(.85,.5));\n\tmouse.zw = 2.*(abs(iMouse.zw)/  iResolution.y - vec2(.85,.5));\n\tif (iMouse.x+iMouse.y==0.) mouse = vec4(.5);\n\tvec3 col;\n\tfloat vS=0.,vF=0.,A=0.;\n\t\n\tvec2 k = mouse.xy; // wave number\n\t\n\tif (!keyToggle(65)) { // tune angular spread\n\t\tA = PI/2.* .5*(1.+mouse.y);\n\t\tk.y = mouse.w;\n\t}\n\tif (keyToggle(84)) { // tune angular spread\n\t\tGAUSS_F *= 4.*iMouse.x/iResolution.x;\n\t\tk.x = abs(mouse.z);\n\t}\n\t\n\t\n\t// --- display\n\t\n\tvec2 k_ortho = vec2(-k.y,k.x);\n\t\n\t// in Fourier space, Gabor = Gauss(s)*F(sin) = 2 Gaussians at k and -k\n\t// in signal space, Gabor = Gauss(1/s).sin(kx)  * white\n\n\tfor (float i=0.; i<NB; i++) { \n\t\t\n\t\t// random sample within angular spread\n\t\tfloat a = A*(2.*i/NB-1.);\n\t\tvec2 Rk = cos(a)*k + sin(a)*k_ortho;\n\n\t\t// signal space:  white := Poisson point distrib -> sum random pos\n\t\tvec2 pos =2.*vec2(1.5*rndi(i,0.),rndi(i,1.))-1.;\t\t\n\t\tvS += gabor(SCALE*(uv-pos), Rk, GAUSS_F, 10.*iTime +float(i));\n\t\t// Fourier: (dirac+ + dirac-)*gauss\n\t\tvF += \t\t gauss(    GAUSS_F,uv-Rk) + gauss(    GAUSS_F,uv+Rk)\n\t\t\t - 10.*( gauss(.02*GAUSS_F,uv-Rk) + gauss(.02*GAUSS_F,uv+Rk) );\n\t}\n\t\n\tvF *= max(1., length(k)*2.*A/(PI*GAUSS_F)) /float(NB); // normalization\n\tvS = (1.-vF)*(vS*sqrt(3.*GAUSS_F)+1.)/2.;\n\n\tfragColor = vec4(vF,vS,vS,1.);\n}\n                  \n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsfXzM","date":"1398340227","viewed":2246,"name":"Gabor3","username":"FabriceNeyret2","description":"mouse: freq and dir of Gabor.\nA: mouse.y tunes angular spread instead.\nT: mouse.x tunes gaussian thickness instead.\nRed: Fourier representation of the Gabor function.\nCyan: Signal representation of the Gabor function.","likes":18,"published":3,"flags":0,"usePreview":0,"tags":["gabor"],"hasliked":0,"parentid":"","parentname":""}}