{"ver":"0.1","info":{"id":"mdVyDh","date":"1696075534","viewed":139,"name":"Tower by IBL & PBR","username":"guhcalm","description":"SDF's used\n- Tower by snolot: https://www.shadertoy.com/view/ssKcWW\n\nPost-Processing\n- Chromatic aberration;\n- Vignetting;\n- ACES Tone Mapping;","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","fractal","ibl","pbr"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 PincushionDistortion(vec2 uv, float strength) {\n  vec2 st = uv - 0.5;\n  float uvA = atan(st.x, st.y);\n  float uvD = dot(st, st);\n  return 0.5 + vec2(sin(uvA), cos(uvA)) * sqrt(uvD) * (1.0 - strength * uvD);\n}\nvec3 ChromaticAbberation(vec2 uv, sampler2D sampler) {\n  float amount = .5;\n  return vec3(\n    texture(sampler, PincushionDistortion(uv, 0.3 * amount)).r,\n    texture(sampler, PincushionDistortion(uv, 0.15 * amount)).g,\n    texture(sampler, PincushionDistortion(uv, 0.075 * amount)).b\n  );\n}\n#define ACESFilmic(color) (color * (2.51 * color + .03)) / (color * (2.43 * color + .59) + .14)\n#define Contrast(color) color * color * (3. -2. * color)\n#define HighlightRolloff(color) 1.85 * color / (1. + color)\nvec3 FilmGrain(vec2 uv, vec3 color) {\n  float seed = dot(uv, vec2(12.9898, 78.233));\n  float noise = .7978845608028654 * exp(-(pow(fract(sin(seed) * 43758.5453), 2.) / .5));\n  vec3 grain = vec3(noise) * (1.0 - color);\n  return color + noise * .075;\n}\n#define Vignetting(uv, color) color * (.5 + .5 * pow(16. * uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .25))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 color = ChromaticAbberation(uv, iChannel0);\n  color = Vignetting(uv, color);\n  color = ACESFilmic(color);\n  color = FilmGrain(uv, color);\n  color = Contrast(color);\n  color = HighlightRolloff(color);\n  fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec3 Render(Ray camera) {  \n  Geometry geometry = getGeometry(camera);\n  if (geometry.depth == 1.) return GammaExpansion(texture(iChannel0, camera.direction));\n  float ao;\n  vec3 ambient = IBL(camera, geometry, ao, iChannel0);\n  //return ambient;\n  const Light light = Light(normalize(vec3(1, 1, -1)), vec3(1));\n  float shadow = getSoftShadow(geometry, light);\n  vec3 direct = PBR(camera, geometry, light, shadow, ao);\n  return ambient + direct;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  //time = iTime;\n  vec2 m = (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n  float a = - m.x * PI * 2. - 1.5;\n  vec3 origin = 4.5 * vec3(sin(a), mix(1., m.y, .7), cos(a));\n  vec3 target;\n  const float AA = 2.;\n  vec3 color;\n  for (float i; i < AA; i++) {\n    vec2 uv = (vec2(random(), random()) - .5 + fragCoord - .5 * iResolution.xy) / iResolution.y;\n    color += Render(getCamera(uv, origin, target));\n  }\n  fragColor = vec4(GammaCompression(color / AA), 1.);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"struct Ray { vec3 origin; vec3 direction; };\nstruct Material { vec3 albedo; float roughness; float metalness; float reflectance; };\nstruct Geometry { float depth; vec3 position; vec3 normal; Material material; };\nstruct Light { vec3 direction; vec3 color; };\n\n#define saturate(value) clamp(value, 0., 1.)\n#define GammaExpansion(color) pow(vec3(color), vec3(2.2))\n#define GammaCompression(color) pow(vec3(color), vec3(1. / 2.2))\n\nconst float PI = 3.14159265359;\nconst float EPSILON = .001;\nconst float NEAR = .001;\nconst float FAR = 20.;\n\nfloat time;\nfloat seed;\n#define random() fract(sin(seed += .1) * 4568.7564)\nvec3 getRandomVectorOnHemisphere(vec3 normal) {\n  float u = random();\n  float v = random();\n  float a = 6.283185 * v;\n  float b = u * 2. - 1.;\n  vec3 random = vec3(sqrt(1. - b * b) * vec2(cos(a), sin(a)), b);\n  return normalize(random * sign(dot(normal, random)));\n}\n\n/* SDF's */\nfloat getSignedDistance(in vec3 position) {\n  vec3 pos = .5 * position;\n  const float RADIUS = .3492;\n  const float SCALE = 2.04348;\n  const int ITERATIONS = 10;\n  vec3 p = pos * mix(.5, 2., smoothstep(0., 1., sin(time) * .5 + .5));\n  float s = 2.;\n  for (int i; i < ITERATIONS; i++) {\n    p = abs(p);\n    p += vec3(0.0365, -1.8613, 0.0365);\n    float r2 = dot(p, p);\n    float k = clamp(max(RADIUS / r2, RADIUS), 0., 1.);\n\tp *= k;\n    s *= k;\n    p = p * SCALE / RADIUS;\n    s *= abs(SCALE) / RADIUS;\n    p += vec3(-.5, -1.3028, -.5);\n  }\n  return (length(p) - abs(SCALE - 1.0)) / s - pow(abs(SCALE), float(1 - ITERATIONS));\n}\n\n/* Ray Cast | by Ray Marching  */\nfloat RayCast(in Ray ray, const int STEPS, const float NEAR, const float FAR) {\n  float distance;\n  for(int step; step < STEPS; step++) {\n    float march = getSignedDistance(ray.origin + ray.direction * distance);\n    if (abs(march) <= NEAR) return distance;\n    distance += march;\n    if (distance >= FAR) break;\n  }\n  return FAR;\n}\n\n/* Geometry Pass */\nGeometry getGeometry(Ray camera) {\n  float distance = RayCast(camera, 500, EPSILON, FAR);\n  Geometry geometry;\n  geometry.depth = clamp(0., FAR, distance) / FAR;\n  geometry.position = camera.origin + camera.direction * geometry.depth * FAR;\n  if (geometry.depth < 1.) {\n    vec3 p = geometry.position;\n    const vec2 e = vec2(EPSILON, 0);\n    geometry.normal = normalize(vec3(\n      getSignedDistance(p + e.xyy) - getSignedDistance(p - e.xyy),\n      getSignedDistance(p + e.yxy) - getSignedDistance(p - e.yxy),\n      getSignedDistance(p + e.yyx) - getSignedDistance(p - e.yyx)\n    ));\n    geometry.material = Material(vec3(1), 0., 0., .16);\n  }\n  return geometry;\n}\n\n/* Ambient Occlusion Pass | by SDF */\nfloat getAmbientOcclusion(const Geometry geometry, const vec3 N, const float FAR) {  \n  float distance = RayCast(Ray(geometry.position + N * .002, N), 150, .001, FAR);\n  float ao = distance >= FAR ? 1. : pow(distance / FAR, 2.);\n  const float STEPS = 8.;\n  for (float i; i < STEPS; ++i) {\n    float distance = RayCast(Ray(geometry.position + N * .002, getRandomVectorOnHemisphere(N)), 150, .001, FAR);\n    ao += distance >= FAR ? 1. : pow(distance / FAR, 2.);\n  }\n  return ao / (1. + STEPS);\n}\n\n/* Image Based Lightning */\nvec3 getDiffuseRadiance(const vec3 N, const samplerCube environment) {\n  const float STEPS = 199.;\n  vec3 color = GammaExpansion(texture(environment, N));\n  for (float i; i < STEPS; i++) {\n    vec3 random = normalize(getRandomVectorOnHemisphere(N));\n    color += GammaExpansion(texture(environment, random)) * saturate(dot(N, random));\n  };\n  return color / (1. + STEPS);\n}\nvec3 IBL(const Ray camera, const Geometry geometry, inout float ao, const samplerCube environment) {\n  vec3 V = -camera.direction;\n  vec3 N = geometry.normal;\n  vec3 R = reflect(-V, N);\n  vec3 albedo = geometry.material.albedo;\n  float metalness = saturate(geometry.material.metalness);\n  float roughness = clamp(geometry.material.roughness, .1, 1.);\n  float reflectance = geometry.material.reflectance;\n  vec3 Fo = mix(vec3(reflectance), albedo, metalness);\n  vec3 F = mix(vec3(pow(1. - saturate(dot(N, V)), 5.)), vec3(1), Fo);\n  ao = getAmbientOcclusion(geometry, mix(N, R, F), 2.);\n  vec3 diffuse = (1. - metalness) * albedo * getDiffuseRadiance(mix(N, R, F), environment);\n  vec3 specular = GammaExpansion(texture(environment, R, mix(0., 6., roughness)));\n  return mix(diffuse, specular, F) * ao;\n}\n\n/* Soft Shadow Pass | by SDF */\nfloat getSoftShadow(Geometry geometry, Light light) {\n  float k = 16.;\n  float res = 1.;\n  float t = .01;\n  float ph = 1e10;\n  for(int i = 0; i < 64; i++) {\n\tfloat h = getSignedDistance(geometry.position + light.direction * t);\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, k * d / max(0., t - y));\n    ph = h;    \n    t += h;\n    if(res < .001 || t > 16.) break;\n  }\n  res = clamp(res, 0., 1.);\n  return res * res * (3. - 2. * res);\n}\n\n/* Direct Lighting | by BRDF */\nvec3 PBR(const Ray camera, const Geometry geometry, const Light light, float shadow, float ao) {\n  vec3 V = - camera.direction;\n  vec3 N = geometry.normal;\n  vec3 albedo = geometry.material.albedo;\n  float metalness = saturate(geometry.material.metalness);\n  float roughness = mix(.1, 1., geometry.material.roughness);\n  float reflectance = clamp(geometry.material.reflectance, 0., .16);\n  float alpha = pow(roughness, 2.);\n  float a2 = pow(alpha, 2.);\n  float k = saturate(alpha / 2.);\n  vec3 Fo = mix(vec3(reflectance), albedo, metalness);  \n  vec3 diffuse = (1. - metalness) * albedo / PI; \n  vec3 Lo;\n  {// direct\n    vec3 L = normalize(light.direction);\n    vec3 H = normalize(V + L);\n    float D = a2 / (PI * pow(pow(saturate(dot(N, H)), 2.) * (a2 - 1.) + 1., 2.));\n    float G = 1. / mix(saturate(dot(N, L)), 1., k) * mix(saturate(dot(N, V)), 1., k);\n    vec3 F = mix(vec3(pow(1. - saturate(dot(L, H)), 5.)), vec3(1), Fo);\n    vec3 radiance = light.color * shadow * mix(ao, 1., .8);\n    Lo += mix(diffuse, vec3(D * G / 4.), F) * radiance * saturate(dot(N, L));\n  }\n  {// bouncing\n    vec3 L = normalize(-light.direction);\n    vec3 H = normalize(V + L);\n    float D = a2 / (PI * pow(pow(saturate(dot(N, H)), 2.) * (a2 - 1.) + 1., 2.));\n    float G = 1. / mix(saturate(dot(N, L)), 1., k) * mix(saturate(dot(N, V)), 1., k);\n    vec3 F = mix(vec3(pow(1. - saturate(dot(L, H)), 5.)), vec3(1), Fo);\n    vec3 radiance = .2 * light.color * mix(1. - shadow, 0., .8) * ao * (1. - ao);\n    Lo += mix(diffuse, vec3(D * G / 4.), F) * radiance * saturate(dot(N, L));\n  }\n  return Lo;\n}\n\n/* View Projection | Camera */\nRay getCamera(vec2 uv, vec3 origin, vec3 target) {\n  vec3 w = normalize(target - origin);\n  vec3 u = normalize(cross(w, vec3(0, 1, 0)));\n  vec3 v = normalize(cross(u, w));\n  return Ray(origin, normalize(mat3(u, v, w) * vec3(uv, 1.5)));\n}","name":"Common","description":"","type":"common"}]}