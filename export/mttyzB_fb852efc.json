{"ver":"0.1","info":{"id":"mttyzB","date":"1699383295","viewed":83,"name":"Archimedean Spiral - Distance","username":"nr4","description":"Archimedean Spiral  distance.\nThis uses iq's distance visualization code.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["2d","sdf","spiral","approximation","distance","quartic","signed","archimedean"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n * Distance to Archimedean Spiral\n * Copyright (C) 2023 NR4 <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1,0,-1);\nconst float pi = 3.14159;\n\n// Determine zeros of k.x*x^2+k.y*x+k.z\nvec2 quadratic_zeros(vec3 k)\n{\n    if(k.x == 0.) return -k.z/k.y*c.xx;\n    float d = k.y*k.y-4.*k.x*k.z;\n    if(d<0.) return vec2(1.e4);\n    return (c.xz*sqrt(d)-k.y)/(2.*k.x);\n}\n\n// Determine zeros of k.x*x^3+k.y*x^2+k.z*x+k.w\nvec3 cubic_zeros(vec4 k)\n{\n    if(k.x == 0.) return quadratic_zeros(k.yzw).xyy;\n    \n    // Depress\n    vec3 ai = k.yzw/k.x;\n    \n    //discriminant and helpers\n    float tau = ai.x/3., \n        p = ai.y-tau*ai.x, \n        q = -tau*(tau*tau+p)+ai.z, \n        dis = q*q/4.+p*p*p/27.;\n        \n    //triple real root\n    if(dis > 0.) {\n        vec2 ki = -.5*q*c.xx+sqrt(dis)*c.xz, \n            ui = sign(ki)*pow(abs(ki), c.xx/3.);\n        return vec3(ui.x+ui.y-tau);\n    }\n    \n    //three distinct real roots\n    float fac = sqrt(-4./3.*p), \n        arg = acos(-.5*q*sqrt(-27./p/p/p))/3.;\n    return c.zxz*fac*cos(arg*c.xxx+c*pi/3.)-tau;\n}\n\n// Determine zeros of a*x^4+b*x^3+c*x^2+d*x+e\nvec4 quartic_zeros(float a, float b, float cc, float d, float e) {\n    if(a == 0.) return cubic_zeros(vec4(b, cc, d, e)).xyzz;\n    \n    if(b == 0. && d == 0.) {\n        vec2 ta = quadratic_zeros(vec3(a, cc, e));\n        return vec4(sqrt(ta), -sqrt(ta));\n    }\n    \n    // Depress\n    float _b = b/a,\n        _c = cc/a,\n        _d = d/a,\n        _e = e/a;\n        \n    // Helpers\n    float p = (8.*_c-3.*_b*_b)/8.,\n        q = (_b*_b*_b-4.*_b*_c+8.*_d)/8.,\n        r = (-3.*_b*_b*_b*_b+256.*_e-64.*_b*_d+16.*_b*_b*_c)/256.;\n        \n    // Determine available resolvent zeros\n    vec3 res = cubic_zeros(vec4(8.,8.*p,2.*p*p-8.*r,-q*q));\n    \n    // Find nonzero resolvent zero\n    float m = res.x;\n    if(m == 0.) m = res.y;\n    if(m == 0.) m = res.z;\n    \n    // Apply newton iteration to fix numerical artifacts;\n    // Credit goes to NinjaKoala / epoqe :)\n    for(int i=0; i < 2; i++) {\n        float a_2 = p + m;\n        float a_1 = p*p/4.-r + m * a_2;\n        float b_2 = a_2 + m;\n\n        float f = -q*q/8. + m * a_1;\n        float f1 = a_1 + m * b_2;\n\n        m -= f / f1; // Newton iteration step\n    }\n    \n    // Apply Ferrari method\n    return vec4(\n        quadratic_zeros(vec3(1.,sqrt(2.*m),p/2.+m-q/(2.*sqrt(2.*m)))),\n        quadratic_zeros(vec3(1.,-sqrt(2.*m),p/2.+m+q/(2.*sqrt(2.*m))))\n    )-_b/4.;\n}\n\nvec2 xarchimedianspiral(float t, float a, float b) {\n    return vec2(cos(t), sin(t)) * (a + b * t);\n}\n\nfloat darchimedianspiral(vec2 x, float a, float b) {\n    /* Original working implementation */\n    /*\n    float t0 = atan(x.y, x.x);\n    float t0ptpn = t0 + 2. * round((length(x) - a - b * t0) / 2. / pi / b) * pi;\n    vec2 cs = vec2(cos(t0ptpn), sin(t0ptpn));\n    vec2 cso = cs * c.xz;\n    float bs = b * b;\n    \n    // I did the super heavy lifting to obtain the expression below,\n    // but there is a small error here that affects the quality of\n    // the sdf near the center of the spiral. Well, shit. :/\n    // It's quite a decent approximation anyways.\n    vec4 t = quartic_zeros(\n        dot((cso     * t0ptpn + 5. * cs.yx    ) * b + cso     * a, x.yx) / 24.,\n        dot((cs.yx   * t0ptpn + 4. * cs * c.zx) * b + cs.yx   * a, x.yx) / 6.,\n       -dot((cso     * t0ptpn + 3. * cs.yx    ) * b + cso     * a, x.yx) / 2.,\n       -dot((cs.yx   * t0ptpn + 2. * cso      ) * b + cs.yx   * a, x.yx) - bs,\n        dot((cso     * t0ptpn +      cs.yx    ) * b + cso     * a, x.yx) - a * b - t0ptpn * bs\n    ) + t0ptpn;\n    */\n    \n    // Transformed to obtain a much cleaner form of the coefficients.\n    float t0 = atan(x.y, x.x);\n    float w = b / length(x);\n    float s = a / b;\n    float tau = 2. * pi;\n    float r = t0 + tau * round((1. / w - s - t0) / tau);\n    float q = r + s;\n    vec4 t = quartic_zeros(\n        5. / 24.,\n        q / 6.,\n        -1.5,\n        -w - q,\n        1. - w * q\n    ) + r;\n\n    return min(\n        length(x),\n        min(\n            min(\n                length(x - xarchimedianspiral(t.x, a, b)),\n                length(x - xarchimedianspiral(t.y, a, b))\n            ),\n            min(\n                length(x - xarchimedianspiral(t.z, a, b)),\n                length(x - xarchimedianspiral(t.w, a, b))\n            )\n        )\n    );\n}\n\nfloat scene(vec2 uv) {\n    return darchimedianspiral(uv, 1. + .95*sin(iTime + 3.*pi/2.), 1. + .95*sin(.5 * (iTime + 3.*pi/2.)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    float scale = 12.;\n    vec2 uv = scale * (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 mouse = scale * (iMouse.xy - .5 * iResolution.xy) / iResolution.y;\n    float px = 1.0 / iResolution.y;\n    float d = scene(uv)/scale;\n    vec3 col = (d > 0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65, 0.85, 1.0);\n\tcol *= 1.0 - exp2(-12.0 * abs(d));\n\tcol *= 0.7 + 0.2 * cos(150.0 * d);\n\tcol = mix( col, vec3(1.0), 1.0 - smoothstep(0.0, 3.0 * px, abs(d)));\n    d = scene(mouse);\n    float l = length(uv - mouse);\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, abs(l - abs(d))-.001 * scale));\n    col = mix(col, vec3(1.0, 1.0, 1.0), 1.0 - smoothstep(0.0, 2.0 * px, l - px*3.0));\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}