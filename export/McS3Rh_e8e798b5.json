{"ver":"0.1","info":{"id":"McS3Rh","date":"1703796944","viewed":34,"name":"Old Film Dirt Flash Effect","username":"nonlogical","description":"Accidental film dirt shader, the imperfections you see on the old film when projected.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["film","grain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/NlSGDz\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a \n// single unsigned integer.\n\nuint hash(uint x, uint seed) {\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process input\n    uint k = x;\n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n// implementation of MurmurHash (https://sites.google.com/site/murmurhash/) for a  \n// 2-dimensional unsigned integer input vector.\n\nuint hash(uvec2 x, uint seed){\n    const uint m = 0x5bd1e995U;\n    uint hash = seed;\n    // process first vector element\n    uint k = x.x; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n    // process second vector element\n    k = x.y; \n    k *= m;\n    k ^= k >> 24;\n    k *= m;\n    hash *= m;\n    hash ^= k;\n\t// some final mixing\n    hash ^= hash >> 13;\n    hash *= m;\n    hash ^= hash >> 15;\n    return hash;\n}\n\n\nvec2 gradientDirection(uint hash) {\n    switch (int(hash) & 3) { // look at the last two bits to pick a gradient direction\n    case 0:\n        return vec2(1.0, 1.0);\n    case 1:\n        return vec2(-1.0, 1.0);\n    case 2:\n        return vec2(1.0, -1.0);\n    case 3:\n        return vec2(-1.0, -1.0);\n    }\n}\n\nfloat interpolate(float value1, float value2, float value3, float value4, vec2 t) {\n    return mix(mix(value1, value2, t.x), mix(value3, value4, t.x), t.y);\n}\n\nvec2 fade(vec2 t) {\n    // 6t^5 - 15t^4 + 10t^3\n\treturn t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat perlinNoise(vec2 position, uint seed) {\n    vec2 floorPosition = floor(position);\n    vec2 fractPosition = position - floorPosition;\n    uvec2 cellCoordinates = uvec2(floorPosition);\n    float value1 = dot(gradientDirection(hash(cellCoordinates, seed)), fractPosition);\n    float value2 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 0)), seed)), fractPosition - vec2(1.0, 0.0));\n    float value3 = dot(gradientDirection(hash((cellCoordinates + uvec2(0, 1)), seed)), fractPosition - vec2(0.0, 1.0));\n    float value4 = dot(gradientDirection(hash((cellCoordinates + uvec2(1, 1)), seed)), fractPosition - vec2(1.0, 1.0));\n    return interpolate(value1, value2, value3, value4, fade(fractPosition));\n}\n\nfloat perlinNoise(vec2 position, int frequency, int octaveCount, float persistence, float lacunarity, uint seed) {\n    float value = 0.0;\n    float amplitude = 1.0;\n    float currentFrequency = float(frequency);\n    uint currentSeed = seed;\n    for (int i = 0; i < octaveCount; i++) {\n        currentSeed = hash(currentSeed, 0x0U); // create a new seed for each octave\n        value += perlinNoise(position * currentFrequency, currentSeed) * amplitude;\n        amplitude *= persistence;\n        currentFrequency *= lacunarity;\n    }\n    return value;\n}\n\n// https://www.shadertoy.com/view/tdjyRz\n\nfloat dRemap(float minInput, float maxInput, float minOutput, float maxOutput, float domain)\n{\n    //normalize domain (put it into the 0-1 range)\n    float normalizedDomain = (domain - minInput) / (maxInput - minInput);\n    \n    //use lerp\n    return minOutput * (1. - normalizedDomain) + maxOutput * normalizedDomain;\n    \n    //I found a new method today thay requires less calculations, very interesting!\n    //return normalizedDomain * (maxOutput - minOutput) + minOutput;  \n}\n\n// ------------------------------------------------------------------------------------\n\n\nvec4 limitColor(float s) {\n    if (s < 1.0 && s > 0.0) {\n       return vec4(s, s, s, 1.0);\n    } \n    return vec4(1.0, 0.0, 0.0, 1.0);\n}\n\nbool mouseImage(out vec4 fragColor, in vec2 uv, in vec2 mv) {\n    if (uv.y < 0.01) {\n        if (uv.x < 0.5) {\n            fragColor = limitColor(mv.x);\n        } else {\n            fragColor = limitColor(mv.y);\n        }\n        return true;\n    }\n    return false;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float sr = iResolution.x/iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mv = iMouse.xy/iResolution.xy;\n    \n    vec2 np = uv;\n    np.x *= sr;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    if (mouseImage(fragColor, uv, mv)) return;\n    \n    // can be set to something else if you want a different set of random values\n    int noiseFreq          = 5;\n    int noiseOctaveCnt     = 6;\n    float noisePersistance = 0.8;\n    float noiseLacunarity  = 2.0;\n\n    \n    vec2 npR = np;\n    //npR.x += 0.5 + 0.5*cos(iTime*0.5);\n    //npR.y += 0.5 + 0.5*sin(iTime*20.0);\n    float seedRT = iTime*5.0; // vary this for speed of grain flashes\n    float seedRTF = float(uint(seedRT)) - seedRT;\n    uint seedR1 = 0x578437adU+uint(seedRT);\n    uint seedR2 = 0x578437adU+uint(seedRT)+uint(1);\n    \n    float valueR1 = dRemap(-1.0,1.0,0.0,1.0,\n        perlinNoise(npR, noiseFreq, noiseOctaveCnt, noisePersistance, noiseLacunarity, seedR1));\n    float valueR2 = dRemap(-1.0,1.0,0.0,1.0,\n        perlinNoise(npR, noiseFreq, noiseOctaveCnt, noisePersistance, noiseLacunarity, seedR2));\n        \n    float valueR = smoothstep(valueR1, valueR1, seedRTF);\n    \n    fragColor = vec4(valueR, valueR, valueR, 1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}