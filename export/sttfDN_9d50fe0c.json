{"ver":"0.1","info":{"id":"sttfDN","date":"1663133475","viewed":68,"name":"lyapunov fractals modifications","username":"eebmagic","description":"Modifications on shader found here: https://www.shadertoy.com/view/fldBWr\nwhich was made for the YT video found here: https://www.youtube.com/watch?v=yGwy2WyQCQE","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//returns lambda given x0, a, b, and c\nfloat getLambda(vec4 coord);\n\n//returns r for current n given n, a, b, and c\nfloat getR(int n, vec4 coord);\n\n//returns color corresponding to lambda according to a color scheme\nvec3 getColor(float lambda);\n\nfloat pi = acos(-1.0);\n\n//global inputs\nfloat x0 = 0.5;\nint maxN = 2000;\nint colorScheme = 0; //(0=yellow-blue, 1=silvery)\n\n\n//S sequences (0=A, 1=B,2=C - leave only one uncommented and feel free to make your own!)\n\n//AB\n//int s[2] = int[](0,1);\n\n//BA\n//int s[2] = int[](1,0);\n\n//BBBBBBAAAAAA (A.K.A. Zircon City)\n//int s[12] = int[](1,1,1,1,1,1,0,0,0,0,0,0);\n\n//ABBBCA\n//int s[6] = int[](0,1,1,1,2,0);\n\n//ABC\n//int s[3] = int[](0,1,2);\n\n//ABBA\n//int s[4] = int[](0,1,1,0);\n\n//ABACAB\n//int s[6] = int[](0,1,0,2,0,1);\n\n//ABCDABCD\n//int s[8] = int[](0, 1, 2, 3, 0, 1, 2, 3);\n\n//ABCDDCBA\nint s[8] = int[](0, 1, 2, 3, 3, 2, 1, 0);\n\n//DCDBADBACD\n//int s[10] = int[](3,2,3,1,0,3,1,0,2,3);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 bottomLeftCorner = vec2(0.0,0.0); //coords of bottom left corner (B,A) (B is the 'x-axis' and A is the 'y-axis')\n    float height = 4.0; //height of image\n\n    vec2 cRange = vec2(0.0, 4.0); //if S contains a C, C will vary in time, bouncing between these 2 numbers\n    //float t = 15.0; //time in seconds it takes for C to get from its min value to its max value\n    float t = 120.0;\n    \n    vec2 dRange = vec2(0.0, 4.0);\n    \n\n    //calculate (A,B,C)\n    vec2 ab = height * fragCoord/iResolution.y + bottomLeftCorner;\n    float c = (cRange.y+cRange.x - (cRange.y-cRange.x)*cos(pi*iTime/t))/2.0;\n    float d = (dRange.y+dRange.x - (dRange.y-dRange.x)*sin(pi*iTime/t))/2.0;\n    //float d = 0.0;\n\n    //calculate lambda and get corresponding color\n    //vec3 col = getColor(getLambda(vec3(ab.x, ab.y, c)));\n    vec3 col = getColor(getLambda(vec4(ab.x, ab.y, c, d)));\n\n    // Output to screen\n    fragColor = vec4(col,0.0);\n}\n\n\n\nfloat getLambda(vec4 coord){\n    float lambda = 0.0;\n    float maxLambda = pow(10.0,5.0);\n    int n0=600;//ignore the first 600 iterates (ignore the inital transient behavior)\n    float x = x0;\n    float r;\n    \n    n0 = clamp(min(n0,maxN-n0),1,maxN); //make n0 smaller is maxN is small\n    \n    for(int n=1; n<=maxN && abs(lambda)<=maxLambda; n++){\n        r = getR(n, coord);\n        \n        x = r*x*(1.0-x);\n        \n        if(n>=n0)        \n            lambda += log(abs(r*(1.0-2.0*x)))/float(maxN);\n    }\n    \n    return lambda;\n}\n\n\n\nfloat getR(int n, vec4 coord){\n    n = int(mod(float(n), float(s.length())));\n    \n    switch(s[n]){\n        case 0: return coord.x; break;  //A\n        case 1: return coord.y; break;  //B\n        case 2: return coord.z; break;  //C\n        case 3: return coord.w; break;  //D\n        default: return 0.0;\n    }\n}\n\n\n\nvec3 getColor(float lambda){\n    int numOfColorSchemes = 2;\n    colorScheme = clamp(colorScheme, 1, numOfColorSchemes-1);\n    float negScale = 1.0;\n    float posScale = 1.0;\n    \n    \n    switch(colorScheme){\n        case 0: //yellow-blue color scheme\n            //color goes from black to yellow as lambda goes from -inf to 0\n            negScale = 0.65; //this controls how quickly the color goes from black to yellow (bigger = faster)\n            \n            //color goes from blue to black as lambda goes from 0 to inf\n            posScale = 2.0; //this controls how quickly the color goes from blue to black (bigger = faster)\n            \n            \n            if(lambda<=0.0){ //stable color\n                lambda = exp(abs(negScale) * lambda);\n                if(lambda <= 0.95){\n                    return vec3(1.0/0.95, 0.8/0.95, 0) * lambda;\n                }else\n                    return vec3(1.0, (1.0-0.8)/(0.0-0.95)*(lambda-0.95)+0.8, (1.0-0.4)/(1.0-0.95)*(lambda-0.95));\n            \n            }else{ //chaotic color\n                lambda = exp(-abs(posScale) * lambda);\n                return vec3(0.0, 0.0, lambda);\n            }\n        break;\n        \n        case 1: //silvery color scheme\n            posScale = 2.0;         \n            \n            if(lambda<=0.0){ //stable color\n                lambda = (1.0 - exp(0.5 * lambda))/0.35;\n                return (0.5 + 0.5*sin(vec3(0.0,0.4,0.7) + 2.5 * lambda)) * pow(lambda, 0.25);\n            \n            }else{ //chaotic color\n                lambda = exp(-abs(posScale) * lambda);\n                return vec3(0.0, 0.0, lambda);\n            }\n        break;\n        \n        default:\n        return vec3(0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}