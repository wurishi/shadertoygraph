{"ver":"0.1","info":{"id":"msccDl","date":"1698228163","viewed":38,"name":"M1_TP_project","username":"JulieM","description":"source code for Image 2023 assignement\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["graded"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Disc{\n    vec3 c;// Center\n    vec3 n;// Normal\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct Rectangle{\n    vec3 c;// Center\n    vec3 n;//Normal\n    vec3 x1;//Principal semiaxes\n    vec3 y1;\n    int i;//Texture Id\n};\n\nstruct Ellipsoid{\n    vec3 c;//Center\n    vec3 x1;//Principal semiaxes\n    vec3 y1;\n    vec3 z1;\n    int i;//Texture Id\n};\n\nstruct Box{\n    vec3 c;//Center\n    vec3 x1;//Principal semiaxes\n    vec3 y1;\n    vec3 z1;\n    int i;//Texture Id\n};\n\nstruct Cylinder {\n    vec3 c;     // Center of the base\n    vec3 n;     // Normal to the base\n    float r;    // Radius\n    float h;    // Height\n    int i;      // Texture Id\n};\n\nstruct Capsule{\n    vec3 c;     // Center of the base\n    vec3 n;     // Normal to the base\n    float r;    // Radius\n    float h;    // Height\n    int i;      // Texture Id\n};\n\nstruct Torus{\n    vec3 c;//Center\n    vec3 n;//Normal\n    float r1;//Radius\n    float r2;//Thickness\n};\n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 d;// Diffuse\n    vec3 s;// Speculaire\n    vec3 a;// Ambiant\n};\n\n\n\n\n\n// All the material functions\nMaterial Uniform(){\n    return Material(vec3(.8,.5,.4), vec3(0.), vec3(0.));\n}\n\nfloat Checkers(in vec3 p, float c)\n{\n    // Filter kernel\n    vec3 w=fwidth(c*p)+.001;\n    // Box box filter\n    vec3 i=2.*(abs(fract((c*p-c*w)*.5)-.5)-abs(fract((c*p+c*w)*.5)-.5))/w;\n    // xor pattern\n    return .5-.5*i.x*i.y*i.z;\n}\n\nvec3 TypeCheckers(in vec3 p, float c)\n{\n    // Filter kernel\n    vec3 w=fwidth(c*p)+.001;\n    // Box box filter\n    vec3 i=2.*(abs(fract((c*p-c*w)*.5)-.5)-abs(fract((c*p+c*w)*.5)-.5))/w;\n    // xor pattern\n    float t = .5-.5*i.x*i.y*i.z;\n    return vec3(t,-t,0.);\n}\n\nfloat ConcentricPoint(in vec3 p, float c)\n{\n    float i = mod(floor(length(p)/c),2.);\n    // concentric pattern\n    return i;\n}\n\n\n\n\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,int i)\n{\n    if(i==1)\n    {\n        return Uniform();\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        float f=Checkers(p,0.5);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col,vec3(0.),vec3(0.));\n    }\n    else if(i==3)\n    {\n        // compute checkboard\n        vec3 f=TypeCheckers(p,0.5);\n        vec3 col1=vec3(.4,.5,.7)*f.x;\n        vec3 col2=vec3(.2,.3,.6)*f.y;\n        return Material(col1,col2,vec3(0.));\n    }\n    else if(i==2)\n    {\n        // compute concentric\n        float f=ConcentricPoint(p,0.3);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col,vec3(0.),vec3(0.));\n    }\n    return Material(vec3(0.),vec3(0.),vec3(0.));\n}\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n}\n\n// Ellipsoid intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectEllipsoid(Ray ray,Ellipsoid ell,out Hit x)\n{\n    mat3 A = mat3(ell.x1,ell.y1,ell.z1);\n    mat3 A_1 = inverse(A);\n    \n    Ray ray2 = Ray(A_1*(ray.o-ell.c),normalize(A_1*ray.d));\n    \n    if (IntersectSphere(ray2,Sphere(vec3(0.,0.,0.),1.,ell.i),x))\n    {\n    \n        x = Hit(x.t/length(A_1*ray.d),A*x.n,x.i);\n        return true;\n    }\n    return false;\n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n    {\n        x=Hit(t,pl.n,pl.i);\n        return true;\n    }\n    return false;\n}\n\n// Disc intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectDisc(Ray ray,Disc d,out Hit x)\n{\n    float t=-dot(ray.o-d.c,d.n)/dot(ray.d,d.n);\n    if(t>0.)\n        if(length(d.c-Point(ray,t))<d.r)\n        {\n            x=Hit(t,d.n,d.i);\n            return true;\n        }\n    return false;\n}\n\n//Rectangle intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IsInRec(vec3 x, vec3 x1, vec3 y1, float eps)\n{\n        //A grand coup de projection sur les demi grands axes\n    vec3 ux = normalize(x1);\n    vec3 uy = normalize(y1);\n    float s = dot(x,ux);\n    float t = dot(x,uy);\n    return (abs(s)<length(x1))&&(abs(t)<length(y1));\n}\n\nbool IntersectRectangle(Ray ray,Rectangle r,out Hit x)\n{\n    float t=-dot(ray.o-r.c,r.n)/dot(ray.d,r.n);\n    if(t>0.)\n    {\n        if(IsInRec(r.c-Point(ray,t),r.x1,r.y1,0.0001))\n        {\n            x=Hit(t,r.n,r.i);\n            return true;\n        }\n    }\n    return false;\n}\n\nbool IntersectBox(Ray ray,Box b,out Hit x)\n{\n    Hit current;\n    bool ret=false;\n    if(IntersectRectangle(ray,Rectangle(b.c+b.x1,b.x1,b.y1,b.z1,b.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectRectangle(ray,Rectangle(b.c-b.x1,-b.x1,b.y1,b.z1,b.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectRectangle(ray,Rectangle(b.c+b.y1,b.y1,b.x1,b.z1,b.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectRectangle(ray,Rectangle(b.c-b.y1,-b.y1,b.x1,b.z1,b.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectRectangle(ray,Rectangle(b.c+b.z1,b.z1,b.y1,b.x1,b.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectRectangle(ray,Rectangle(b.c-b.z1,-b.z1,b.y1,b.x1,b.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    return ret;\n}\n\n// Cylinder intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectCylinderBody(Ray ray, Cylinder cyl, out Hit x)\n{\n    float tmin = 1000.0;\n    vec3 normal;\n    \n    vec3 oc = ray.o - cyl.c;\n    vec3 ab = cyl.n*cyl.h;\n    \n    float ab2 = dot(ab, ab);\n    float aboc = dot(ab, oc);\n    float a = dot(ray.d, ray.d) - dot(ray.d, ab) * dot(ray.d, ab) / ab2;\n    float b = 2.0 * (dot(ray.d, oc) - dot(ray.d, ab) * dot(oc, ab) / ab2);\n    float c = dot(oc, oc) - dot(oc, ab) * dot(oc, ab) / ab2 - cyl.r * cyl.r;\n    \n    float discriminant = b * b - 4.0 * a * c;\n    \n    //Body of the cylinder\n    if (discriminant >= 0.0)\n    {\n        float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n        \n        \n        if (t1 > 0.0)\n        {\n            vec3 p = Point(ray,t1);\n            float h = dot(p - cyl.c, ab) / ab2;\n            \n            if (h >= 0.0 && h <= 1.0 )\n            {\n                normal = normalize(p - (cyl.c + ab * h));\n                tmin = t1;\n                x = Hit(tmin, normal, cyl.i);\n            }\n        }\n        if (t2 > 0.0 && t2<tmin)\n        {\n            vec3 p = Point(ray,t2);\n            float h = dot(p - cyl.c, ab) / ab2;\n            \n            if (h >= 0.0 && h <= 1.0 )\n            {\n                normal = normalize(p - (cyl.c + ab * h));\n                tmin = t2;\n                x = Hit(tmin, normal, cyl.i);\n            }\n        }\n    }\n    \n    if (tmin < 1000.0) {\n        return true;\n    }\n    return false;\n}\n\nbool IntersectCylinder(Ray ray, Cylinder cyl, out Hit x)\n{ \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectDisc(ray,Disc(cyl.c,-cyl.n,cyl.r,cyl.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinderBody(ray,cyl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectDisc(ray,Disc(cyl.c+cyl.n*cyl.h,cyl.n,cyl.r,cyl.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    return ret;\n}\n\n// Capsule intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectCapsule(Ray ray, Capsule caps, out Hit x)\n{ \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,Sphere(caps.c,caps.r,caps.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinderBody(ray,Cylinder(caps.c,caps.n,caps.r,caps.h,caps.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,Sphere(caps.c+caps.n*caps.h,caps.r,caps.i),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    return ret;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n    // Spheres\n    const Sphere sph1=Sphere(vec3(0.,0.,1.),1.,1);\n    const Sphere sph2=Sphere(vec3(2.,2.,2.),1.,0);\n    const Plane pl=Plane(vec3(0.,0.,1.),vec3(-0.1,0.1,0.1),3);\n    const Cylinder cyl1=Cylinder(vec3(3., 0., 1.),vec3(1.,1.,1.),1., 4., 2);\n    const Capsule caps1=Capsule(vec3(-3., 0., 1.),vec3(-1.,-1.,1.),1., 4., 1);\n    const Rectangle rec1=Rectangle(vec3(0.,0.,2.01),vec3(0.,0.,1.),vec3(1.,0.,0.),vec3(0.,1.,0.),0);\n    const Box box1=Box(vec3(-2.,2.,1.),vec3(0.,0.,0.6),vec3(0.3,0.3,0.),vec3(-0.3,0.3,0.),0);\n    const Ellipsoid ell1=Ellipsoid(vec3(0.,0.,4.),vec3(1.,0.,0.),vec3(0.,1.,1.),vec3(0.,2.,-2.),0);\n    \n    x=Hit(1000.,vec3(0),-1);\n    Hit current;\n    bool ret=false;\n    if(IntersectSphere(ray,sph1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylinder(ray,cyl1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCapsule(ray,caps1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectRectangle(ray,rec1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectBox(ray,box1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoid(ray,ell1,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.8,.8,.9),vec3(.7,.7,.8),rd.z);\n}\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Apply color model\n// m : Material\n// n : normal\nvec3 Color(Material m,vec3 n)\n{\n    vec3 light=normalize(vec3(1,1,1));\n    \n    float diff=clamp(dot(n,light),0.,1.);\n    vec3 col=m.d*diff+m.s*diff+vec3(.2,.2,.2);\n    return col;\n}\n\n// Rendering\nvec3 Shade(Ray ray)\n{\n    // Intersect contains all the geo detection\n    Hit x;\n    bool idx=Intersect(ray,x);\n    \n    if(idx)\n    {\n        vec3 p=Point(ray,x.t);\n        Material mat=Texture(p,x.i);\n        \n        return Color(mat,x.n);\n    }\n    else\n    {\n        return Background(ray.d);\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=12.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}