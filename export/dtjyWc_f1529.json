{"ver":"0.1","info":{"id":"dtjyWc","date":"1692380338","viewed":104,"name":"BumpToNormals","username":"MrHAX00","description":"Tried making something that can convert bump maps to normal maps.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["mouse","lighting","normalmap","bumpmap"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define pi 3.14159\n//from https://www.shadertoy.com/view/Nl33W8\nmat3 AxisAngle(vec3 Axis, float Angle) {\n    float Sin = cos(Angle + pi * .5);\n    float Cos = cos(Angle);\n    return mat3(\n        Axis * Axis.x * (1. - Cos) + vec3(Cos, Axis.z * Sin, -Axis.y * Sin),\n        Axis * Axis.y * (1. - Cos) + vec3(-Axis.z * Sin, Cos, Axis.x * Sin),\n        Axis * Axis.z * (1. - Cos) + vec3(Axis.y * Sin, -Axis.x * Sin, Cos)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // cam movement\n    vec2 Mouse = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    if (iMouse.x == 0. && iMouse.y == 0.) Mouse = vec2(0., -.2);\n\n    // calculate cam pos\n    float CamRot = iTime * pi * .2 + Mouse.x * pi;\n    mat3 CamAngle = AxisAngle(vec3(0., 1., 0.), CamRot + pi *.5);\n    CamAngle *= AxisAngle(vec3(1., 0., 0.), Mouse.y * pi);\n    \n    vec3 CamPos = CamAngle * vec3(0., 0., -20.) + vec3(12.5, 0., 12.5);\n    \n    // calculate light pos\n    vec3 LightPos = vec3(cos(iTime * pi * .6), cos(iTime * pi * .2) * .5 + .5, cos(iTime * pi * .8)) * 10.;\n    LightPos += vec3(-12.5, 15., -12.5);\n    \n    // calculate ray normal\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 RayNormal = CamAngle * normalize(vec3(uv, 1));\n    \n    // calculate ray hit\n    vec3 RayHit = RayNormal / RayNormal.y * CamPos.y - vec3(CamPos.x, 0., CamPos.z);\n    vec2 TextureCoord = vec2(RayHit.xz * -20.);\n    \n    // calculate surface normal using cross\n    float Height = texelFetch(iChannel0, ivec2(TextureCoord), 0).r;\n    float HeightX = texelFetch(iChannel0, ivec2(TextureCoord + vec2(1., 0.)), 0).r;\n    float HeightZ = texelFetch(iChannel0, ivec2(TextureCoord + vec2(0., 1.)), 0).r;\n    \n    vec3 NormalX = normalize(vec3(.1, Height - HeightX, 0.));\n    vec3 NormalZ = normalize(vec3(0., Height - HeightZ, .1));\n    \n    vec3 SurfaceNormal = normalize(cross(NormalZ, NormalX) * vec3(1., 1. / NormalStrength, 1.));\n    \n    // calculate lighting\n    float LightStrength = smoothstep(0., .7, clamp(LightDistance / length(LightPos - RayHit), 0., 1.));\n    vec3 LightNormal = normalize(LightPos - RayHit);\n    fragColor = vec4(dot(SurfaceNormal, LightNormal) * LightStrength);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define NormalStrength 5.\n#define LightDistance 8.","name":"Common","description":"","type":"common"}]}