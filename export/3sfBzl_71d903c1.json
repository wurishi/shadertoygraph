{"ver":"0.1","info":{"id":"3sfBzl","date":"1588926684","viewed":132,"name":"Perlin Noise Derivative","username":"patgleeson101","description":"Perlin noise lit according to its analytical derivative.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlinnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 gradient(vec2 cell)\n{\n\tvec3 p3  = fract(vec3(cell.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    float theta = 6.2831853072 * fract((p3.x + p3.y) * p3.z);\n    return vec2(cos(theta), sin(theta));\n}\n\nvec3 perlin2(vec2 r) //Returns perlin value + gradient\n{\n    //Useful vector\n    vec2 zo = vec2(0.0, 1.0);\n    \n    //Coordinates & vertices\n    vec2 v00 = floor(r);\n    vec2 v01 = v00 + zo.xy;\n    vec2 v10 = v00 + zo.yx;\n    vec2 v11 = v00 + zo.yy;\n    vec2 xy = r - v00; //Local coordinate\n    \n    //Get gradients\n    vec2 g00 = gradient(v00);\n    vec2 g01 = gradient(v01);\n    vec2 g10 = gradient(v10);\n    vec2 g11 = gradient(v11);\n    \n    //Get influence values\n    float G00 = dot(xy, g00);\n    float G01 = dot(r - v01, g01);\n    float G10 = dot(r - v10, g10);\n    float G11 = dot(r - v11, g11);\n    vec4 G = vec4(G00, G01, G10, G11);\n    \n    //Calculate noise value\n    vec2 W = xy*xy*xy*(10.0+xy*(6.0*xy-15.0)); //Weighted local coordinates\n    vec2 C = G.xy + W.x*(G.zw - G.xy);\n    float P = C.x + W.y*(C.y - C.x);\n    P = P * 0.7071067812 + 0.5;\n    \n    //First derivatives (vectors)\n    vec2 delW = 30.0*xy*xy*(xy*(xy-2.0)+1.0);\n    vec2 delG0 = g00 + W.x*(g10-g00) + vec2(delW.x*(G10-G00), 0.0);\n    vec2 delG1 = g01 + W.x*(g11-g01) + vec2(delW.x*(G11-G01), 0.0);    \n    vec2 delP = delG0 + W.y*(delG1-delG0) + vec2(0.0, delW.y*(C.y-C.x));\n    \n    return vec3(P, delP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy; //Normalized pixel\n    vec3 noisedata = vec3(0.0);\n    float sTot = 0.0;\n    vec3 rs = vec3(5.0 * uv * vec2(1.0, iResolution.y/iResolution.x), 1.0);\n    for (int i = 0; i < 4; i++) {\n        rs.xy *= 1.5;\n        rs.z *= 0.7;\n        rs.xy += vec2(1.5, 1.8);\n        sTot += rs.z;\n        noisedata += perlin2(rs.xy) * rs.z;\n    }\n    noisedata /= sTot;\n    noisedata.x *= 1.2; //Since statistically the values become increasingly uniform\n    vec2 delP = noisedata.yz;\n    float P = noisedata.x;\n    \n    //Lighting\n    vec3 normal = normalize(vec3(-delP, 1.0)); //Normal \n    vec3 col = vec3(0.8,0.8,0.6); //Colour\n    vec3 light = normalize(vec3(cos(iTime),sin(iTime),0.5)); //Direction to light\n    col *= 0.5*dot(light, normal)+0.5;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}