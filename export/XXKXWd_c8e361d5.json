{"ver":"0.1","info":{"id":"XXKXWd","date":"1720662315","viewed":60,"name":"Infinity Cubes","username":"coproduto","description":"Playing with simple (fake) reflections.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fakereflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define ASPECT_RATIO (iResolution.x / iResolution.y)\n\nvec2 normalizeCoords(vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 nuv = 2. * (uv - vec2(.5));\n    return vec2(nuv.x * ASPECT_RATIO, nuv.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdRepeatBox(vec3 p, vec3 s,vec3 l, vec3 b) {\n    vec3 q = p - s * clamp(round(p/s), -l, l);\n    return sdBox(q, b); \n}\n\n#define FOCAL_DISTANCE 1.8\n#define EYE_DISTANCE 1.5\n#define RADIUS 0.3\n#define MAX_T 30.0\n#define DELTA_T 0.01\n#define TOLERANCE 0.001\n#define OUTLINE 0.0011\n#define EPSILON 0.001\n#define ITERATIONS 10\n#define BASE_SCALE 2.0\n\nvec3 ray(float fd, vec2 normalizedCoord) {\n    return normalize(vec3(normalizedCoord, fd));\n}\n\nfloat sdScene(vec3 samplePoint) {\n    return sdRepeatBox(samplePoint, vec3(2.), vec3(5.), vec3(RADIUS));\n}\n\n// https://iquilezles.org/articles/normalsSDF/\nvec3 sdNormal(vec3 p) {\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h ) + \n                      k.yyx*sdScene( p + k.yyx*h ) + \n                      k.yxy*sdScene( p + k.yxy*h ) + \n                      k.xxx*sdScene( p + k.xxx*h ) );\n}\n\n#define LIGHTDIR vec3(0., 50., 0.)\n#define BG vec3(0., 0.6, 0.9)\n#define DARKEN vec3(-.1)\n\nvec3 glow(vec3 dir) {\n    vec3 factor = clamp(vec3(1. - dir.y), 0., .97);\n    return factor * factor * factor;\n}\n\nvec3 march(vec3 camera, vec3 dir) {\n    float d = DELTA_T;\n    for (float t = 0.; t < MAX_T; t += d) {\n        vec3 s = camera + dir * t;\n        float dist = sdScene(s);\n        if (dist < TOLERANCE) {\n            vec3 lv = camera - s;\n            vec3 la = vec3(lv.x, -.5, lv.z);\n            float diffuse = dot(la, sdNormal(s));\n            float intensity = diffuse;\n            return vec3(0.3 + intensity);\n        }\n        d = dist;\n    }\n    return BG + glow(dir);\n}\n\nmat3 cameraRotation(float angle) {\n  return mat3(\n      cos(angle),  0., -sin(angle),\n      0.,          1., 0.,\n      sin(angle),  0., cos(angle)\n  );\n}\n\nmat4 cameraTransform(vec3 tr, float angle) {\n  mat4 translate = mat4(\n      1.,   0.,   0.,   0.,\n      0.,   1.,   0.,   0.,\n      0.,   0.,   1.,   0.,\n      tr.x, tr.y, tr.z, 1.\n  );\n  \n  mat4 rotate = mat4(cameraRotation(angle));\n  \n  return rotate * translate;\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nfloat noise3(vec3 coord, vec3 resolution, float scale)\n{\n    // Cell height\n    float ch = 1./scale * resolution.y;\n    \n    // Normalized X/Y coordinate\n    vec2 nc = 1./ch * coord.xy;\n    \n    // Time\n    float t = coord.z;\n    \n    // Cell coordinates\n    vec2 tl = trunc(nc);\n    \n    // Within-cell coordinates\n    vec2 cuv = fract(nc);\n    \n    \n    // Time coordinates\n    float t0 = floor(t);\n    float t1 = ceil(t);\n    float tw = fract(t);\n\n    \n    // Corners\n    vec3 tl0 = vec3(tl, t0);\n    vec3 tr0 = vec3(tl + vec2(1., 0.), t0);\n    vec3 bl0 = vec3(tl + vec2(0., 1.), t0);\n    vec3 br0 = vec3(tl + vec2(1., 1.), t0);\n    \n    // Next cell corners\n    vec3 tl1 = vec3(tl, t1);\n    vec3 tr1 = vec3(tl + vec2(1., 0.), t1);\n    vec3 bl1 = vec3(tl + vec2(0., 1.), t1);\n    vec3 br1 = vec3(tl + vec2(1., 1.), t1);\n    \n    // Corner vectors\n    vec3 tlv0 = hash33(tl0);\n    vec3 trv0 = hash33(tr0);\n    vec3 blv0 = hash33(bl0);\n    vec3 brv0 = hash33(br0);\n    \n    vec3 tlv1 = hash33(tl1);\n    vec3 trv1 = hash33(tr1);\n    vec3 blv1 = hash33(bl1);\n    vec3 brv1 = hash33(br1);\n    \n    \n    // Displacements\n    vec3 tldv0 = vec3(nc - tl0.xy, tw);\n    vec3 trdv0 = vec3(nc - tr0.xy, tw);\n    vec3 bldv0 = vec3(nc - bl0.xy, tw);\n    vec3 brdv0 = vec3(nc - br0.xy, tw);\n    \n    vec3 tldv1 = vec3(nc - tl1.xy, tw - 1.);\n    vec3 trdv1 = vec3(nc - tr1.xy, tw - 1.);\n    vec3 bldv1 = vec3(nc - bl1.xy, tw - 1.);\n    vec3 brdv1 = vec3(nc - br1.xy, tw - 1.);\n\n    float tlr0 = dot(tlv0, tldv0);    \n    float trr0 = dot(trv0, trdv0);  \n    float blr0 = dot(blv0, bldv0);\n    float brr0 = dot(brv0, brdv0);\n    \n    float tlr1 = dot(tlv1, tldv1);\n    float trr1 = dot(trv1, trdv1);\n    float blr1 = dot(blv1, bldv1);\n    float brr1 = dot(brv1, brdv1);\n    \n    return mix(\n        mix(\n            mix(tlr0, trr0, cuv.x),\n            mix(blr0, brr0, cuv.x),\n            cuv.y\n        ),\n        mix(\n            mix(tlr1, trr1, cuv.x),\n            mix(blr1, brr1, cuv.x),\n            cuv.y\n        ),\n        tw\n    );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 nc = normalizeCoords(fragCoord);\n    \n    float angle = 0.05 * iTime;\n    vec3 cameraTranslation = vec3(0., 2. * sin(0.5 * iTime), -EYE_DISTANCE);\n    mat4 cameraMatrix = cameraTransform(cameraTranslation, angle);\n    \n    vec2 fnc = nc * (nc.y < 0. ? vec2(1., -1.) : vec2(1.));\n    float offset = 0.;\n    if(nc.y < 0.) {\n        for (int i = 1; i <= ITERATIONS; ++i) {\n            offset += noise3(\n                vec3(0., 20. * nc.y * nc.y, iTime),\n                iResolution,\n                pow(2., float(i)) * BASE_SCALE\n            );\n        }\n    }\n    fnc.x += 0.02 * clamp(offset, nc.y, -nc.y);\n    \n    vec3 rayDir = cameraRotation(angle) * ray(FOCAL_DISTANCE, fnc);\n    vec4 origin4 = vec4(vec3(0.), 1.);\n    vec3 cameraPosition = vec3(cameraMatrix * origin4);\n    vec3 color = march(cameraPosition, rayDir);\n    \n    \n    if (nc.y < 0.) {\n        fragColor = vec4(color + DARKEN, 1.);\n    } else {\n        fragColor = vec4(color, 1.);\n    }\n}","name":"Image","description":"","type":"image"}]}