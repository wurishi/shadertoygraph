{"ver":"0.1","info":{"id":"WtXSRs","date":"1563846553","viewed":251,"name":"FractalSmeritySpin","username":"Smerity","description":"FractalSmeritySpin","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fractalsmerityspin"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Based upon my earlier fractal:\n// https://www.shadertoy.com/view/ttlSRj\n\n// Hashing from https://www.shadertoy.com/view/lds3z7\nfloat hash( float n )\n{\n\treturn fract(sin(n) * 54671.57391);\n}\n\nfloat noise( vec2 p )\n{\n\treturn 2.0 * hash( iTime * p.x + p.y * 57.1235 ) - 1.0;\n}\n\n// Rotation (thanks for saving me from doing math!) from:\n// https://gist.github.com/yiwenl/3f804e80d0930e34a0b33359259b556c\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ratio = iResolution.y / iResolution.x;\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y *= ratio;\n    vec2 center = vec2(0.5, 0.5 * ratio);\n    uv -= center;\n    \n    // Anti-aliasing samples\n    float samples = 4.0;\n    \n    float finalCol = 0.0;\n    \n    for (int a = 0; a < int(samples); ++a) {\n        vec2 uv = fragCoord / iResolution.xy;\n       \tfloat noiseScale = 0.25;\n        uv.x += noiseScale * noise(float(a) * uv) / iResolution.x;\n        uv.y += noiseScale * noise(float(a) * uv) / iResolution.y;\n        uv.y *= ratio;\n        vec2 center = vec2(0.5, 0.5 * ratio);\n        uv -= center;\n        \n        vec2 coord = uv;\n\n        for (int i = 0; i < 5; ++i) {\n            // Causes the swipe to the bottom / top left\n            float yfuzz = sin(0.005 * iTime) * 0.001;\n            float xfuzz = cos(0.005 * iTime) * 0.4;\n            xfuzz -= 1.0;\n            yfuzz *= 1.0;\n            // Dictates the mirroring of the coordinates once it passes a threshold\n            // Smaller fstop means brighter image\n            float fstop = 0.38;\n            // If you want a hyperbola version centered around origin \n            fstop /= iMouse.z > 0.0 ? 28.0 * (uv.x * uv.y): 1.0;\n            coord = fract(coord * fstop * sin(0.4 * iTime) * xfuzz + 0.5 + yfuzz) * 2.0 - 1.0;\n            // Mirrored\n            float len = (2.0 - sin(0.3 * iTime)) * dot(coord, coord);\n            // Mirrorlen produces a scanline like effect\n            //float mirrorlen = (2.0 - sin(0.75 * iTime) - cos(uv.x * iTime)) * dot(coord, coord);\n            //coord = coord / len + 0.05 * coord / mirrorlen;\n            coord = coord / len;\n            coord = 0.04 * cos(iTime * 0.7) * coord + sin(0.3 * iTime) * rotate(coord, 100.0 * length(1.0 * uv));\n        }\n\n        //float circle = length(coord);\n        // Elongate the circle to form odd distorted smooth boxes\n        // See unit circles in various norms:\n        // https://en.wikipedia.org/wiki/Lp_space#/media/File:Vector-p-Norms_qtl1.svg\n        float circle = length(coord * coord * coord);\n\n        // The radius of the circle we're interested in shifts over time\n        float radius = 1.5 + sin(iTime);\n        // Otavio's neat-o trick for signed distance function\n        float scale = dFdx(uv.x);\n\n        float col = float((circle - radius) / scale > 0.0 ? 1.0 : 0.0);\n        finalCol += col;\n    }\n    \n    finalCol /= samples;\n    \n    // Debug mode makes it easy to see the circle start and end\n    //col = texture(iChannel0, coord).xyz;\n    \n    fragColor = vec4(finalCol, finalCol, finalCol, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}