{"ver":"0.1","info":{"id":"DsKcRw","date":"1695913064","viewed":73,"name":"Disco chess","username":"boyar","description":"Simple shader with chessboard, but now it's disco","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["3d","beginner","shader","disco","chess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int MAX_MARCHING_STEPS = 128;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.001;\nconst float PI = 3.14159265359;\n\nfloat smoothUnion ( float d1, float d2, float k ) \n{\n    //return min(d1, d2);\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubtraction ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nfloat smoothIntersection ( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\n\nmat2 rotate2d(float theta) {\n  float s = sin(theta), c = cos(theta);\n  return mat2(c, -s, s, c);\n}\n\n\n//float sdSphere (vec3 p, vec3 offset, float r )\n//{\n//  return length(p - offset) - r;\n//}\n\nfloat sdSphere (vec3 p, vec3 offset, vec3 size, float r )\n{\n  vec3 v = p - offset;\n  v = vec3(v.x / size.x, v.y / size.y, v.z / size.z);\n  return length(v) - r;\n}\n\nfloat sdPawn (in vec3 p, in vec3 origin ) \n{\n  float pawn = smoothUnion(\n      sdSphere(p, vec3(origin.x, 0.5 + origin.y, origin.z), vec3(1, 1, 1), 0.1),\n      sdSphere(p, vec3(origin.x, 0.3 + origin.y, origin.z), vec3(0.5, 1, 0.5), 0.1),\n      0.1);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.15 + origin.y, origin.z), vec3(0.6, 1, 0.6), 0.1),\n      0.2);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.1 + origin.y, origin.z), vec3(1.5, 0.7, 1.5), 0.1),\n      0.2);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.1 + origin.y, origin.z), vec3(1, 0.2, 1), 0.1),\n      0.2);\n  pawn = smoothUnion(\n      pawn,\n      sdSphere(p, vec3(origin.x, 0.35 + origin.y, origin.z), vec3(0.6, 0.2, 0.6), 0.1),\n      0.2);\n  return pawn;\n}\n\nfloat sdPawn (in vec3 p, in vec2 coords ) \n{\n  float pawn = sdPawn (p, vec3(coords.x * .5 - 1.75, +0. + sin(iTime + 5.) / 10., coords.y * .5 - 1.75) );\n  return pawn;\n}\n\nfloat sdBox ( in vec3 pos, in vec3 size, in vec3 origin )\n{\n    vec3 pt = abs ( pos - origin) - size;\n    return length ( max ( pt, 0.0 ) ) + min ( max ( pt.x, max ( pt.y, pt.z ) ), 0.0 );\n}\n\nfloat sdPlane ( vec3 p, vec4 n )\n{\n    return dot ( p, n.xyz ) + n.w;\n}\n\nfloat sdScene(vec3 p)\n{\n  float board = sdBox(p, vec3(2.1, 0.1, 2.1), vec3(0., -0.1, 0.));\n  board = min(board, sdPawn(p, vec2(int(iTime) % 8, 0)));  \n  board = min(board, sdPawn(p, vec2(int(iTime + 1.) % 8, 3))); \n  board = min(board, sdPawn(p, vec2(int(iTime + 2.) % 8, 6)));  \n  board = min(board, sdPawn(p, vec2(int(iTime + 3.) % 8, 1))); \n  board = min(board, sdPawn(p, vec2(int(iTime + 4.) % 8, 4)));  \n  board = min(board, sdPawn(p, vec2(int(iTime + 5.) % 8, 7))); \n  board = min(board, sdPawn(p, vec2(int(iTime + 6.) % 8, 2)));  \n  board = min(board, sdPawn(p, vec2(int(iTime + 7.) % 8, 5))); \n  return board;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float start, float end) {\n  float depth = start;\n\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 p = ro + depth * rd;\n    float d = sdScene(p);\n    depth += d;\n    if (d < PRECISION || depth > end) break;\n  }\n\n  return depth;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * sdScene(p + e.xyy) +\n      e.yyx * sdScene(p + e.yyx) +\n      e.yxy * sdScene(p + e.yxy) +\n      e.xxx * sdScene(p + e.xxx));\n}\n\n\nmat3 camera(vec3 cameraPos, vec3 lookAtPoint) {\n\tvec3 cd = normalize(lookAtPoint - cameraPos);\n\tvec3 cr = normalize(cross(vec3(0, 1, 0), cd));\n\tvec3 cu = normalize(cross(cd, cr));\n\t\n\treturn mat3(-cr, cu, -cd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n  vec2 mouseUV = iMouse.xy/iResolution.xy;\n  vec3 backgroundColor = vec3(0.835, 1, 1);\n\n  vec3 col = vec3(0);\n  vec3 ro = vec3(0, 1.5, 6); // ray origin that represents camera position\n  vec3 lp = vec3(0);\n  \n  float cameraRadius = 1.0;\n  ro.yz = ro.yz * cameraRadius * rotate2d(mix(-PI/2., PI/2., mouseUV.y));\n  ro.xz = ro.xz * rotate2d(mix(-PI, PI, mouseUV.x)) + vec2(lp.x, lp.z);\n  \n  vec3 rd = camera(ro, lp) * normalize(vec3(uv, -1)); // ray direction\n\n  float d = rayMarch(ro, rd, MIN_DIST, MAX_DIST); // distance to sphere\n\n  if (d > MAX_DIST) {\n    col = texture(iChannel3, rd).rgb;\n\n    //col = backgroundColor; // ray didn't hit anything\n  } else {\n    vec3 p = ro + rd * d;\n\n    vec3 normal = calcNormal(p);\n    vec3 lightPosition = vec3(0, 5, 0);\n    vec3 lightDirection = normalize(lightPosition - p);\n\n    float dif = clamp(dot(normal, lightDirection), 0.3, 1.);\n    col = dif * vec3(1, 1, 1) + backgroundColor * .2;\n    \n    if (length(p.y) < PRECISION && length(p.x) < 2.0 -PRECISION && length(p.z) < 2.0 - PRECISION ) {\n        int position = int(floor(p.x * 2.) + floor(p.z * 2.)) + 100;\n        \n        col = texture(iChannel0, vec2((-p.x+2.0)/iResolution.x*2.0, (-p.z+2.0)/iResolution.y*2.0)).rgb;\n        /*if (position - position/2*2 == 1) {\n            col = texture(iChannel0, p.xz/10.0 + vec2(0.0, 0.0)).rgb;\n        } else {\n            col = texture(iChannel0, p.xz/10.0 + vec2(0.0, 0.0)).rgb;\n        }\n        */\n    } else if (p.y > PRECISION) {\n        col = texture(iChannel0, vec2(0., (p.z+2.0)/iResolution.y*2.0)).rgb;\n        col = dif * col;\n    } else {\n        col = texture(iChannel1, vec2((p.x+2.0+p.y)/iResolution.x*100.0, (p.z+2.0)/iResolution.y*100.0)).rgb;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float hash1( float n ) { return fract(sin(n)*437518.56453)+0.1; }\n\n\n// translate color from HSB space to RGB space\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\nfloat fbm (in vec2 st) {\n\tfloat value = (sin(iTime*5.*hash1(st.x+hash1(st.y)))+4.0)*0.25;\n    return max(0.75,pow(value,3.));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / 2.0;\n    if (uv.x < 8.0 && uv.y < 8.0) {\n    //fragColor = vec4(0.0,0.0,fragCoord.x / 500.0,1.0);\n    //hash1(uv.x + hash1(uv.y) + hash1(round(iTime)))\n    float h = hash1(uv.x + hash1(uv.y)) + iTime / 10.0;\n    float h2 = hash1(uv.y + hash1(uv.x));\n    float color = h - round(h);\n    //float bright_faze = (h2 - round(h2)) * 2.0 * 3.1415;\n    float bright_faze = float(int(uv.y + uv.x) % 2) * 3.1415;\n    fragColor.xyz = hsb2rgb(vec3(color, 1.0, 0.98 + sin(iTime + bright_faze) / 5.0));\n    \n    //fragColor.x = hash1(uv.x + hash1(uv.y) + hash1(round(iTime)));\n    //fragColor.y = hash1(uv.y + hash1(uv.x) + hash1(round(iTime)));\n    //fragColor.z = hash1(uv.x + hash1(uv.y + uv.x) + hash1(round(iTime)));\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}