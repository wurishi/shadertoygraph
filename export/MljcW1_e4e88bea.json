{"ver":"0.1","info":{"id":"MljcW1","date":"1508523998","viewed":878,"name":"Gray Scott Model Explorer","username":"riouxld","description":"Wait a little bit (50sec), then left-click on the screen to choose which behavior you want to simulate. \n(The interesting parts are on the front)\nThen, left-click, again and again, to add perturbation to the simulation by left-clicking.","likes":13,"published":1,"flags":32,"usePreview":0,"tags":["simulation","pattern","multipass","turing","pde","grayscott","reacton","dffusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Multipass explorer of the Gray Scott Model of Reaction Diffusion\n// Wait a little bit, then right-click on the screen to choose which behavior you want to simulate.\n// Then, right-click, again and again, to add perturbation to the simulation. \n// inspiration: https://www.shadertoy.com/view/MdVGRh\n\n//Change colormap by de/commenting #define \n//#define JET\n//#define GRAY\n//#define WHEEL\n//#define HOT\n#define COOL\n//#define BLACKBODY\n\n#define GET_TEXTURE(I,J) texelFetch( iChannel3, ijCoord+ivec2(I,J), 0 ).xy\n\n// COLORMAP\nvec3 jet(float t)\n{\n    return smoothstep(0.5,0.75,t) * vec3(1,0,0)\n         + (smoothstep(0.0,0.25,t)-(smoothstep(0.75,1.0,t))) * vec3(0,1,0)\n        + (1.0-smoothstep(0.25,0.5,t)) * vec3(0,0,1);\n}\n// Rest of colormaps by https://www.shadertoy.com/view/4dXXDX\n\nvec3 gray(float t)\n{\n    return vec3(t);\n}\nvec3 wheel(float t)\n{\n    return clamp(abs(fract(t + vec3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) -1.0, 0.0, 1.0);\n}\n\nvec3 hot(float t)\n{\n    return vec3(smoothstep(0.00,0.33,t),\n                smoothstep(0.33,0.66,t),\n                smoothstep(0.66,1.00,t));\n}\nvec3 cool(float t)\n{\n    return mix( vec3(0.0,1.0,1.0), vec3(1.0,0.0,1.0), t);\n}\n\n// for testing purpose, https://www.shadertoy.com/view/4dlczB\nvec3 blackbody(float t)\n{\n\tfloat Temp = t*7500.0;\n    vec3 col = vec3(255.);\n    col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n   \tcol.y = 100.04 * log(Temp) - 623.6;\n   \tif (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n   \tcol.z = 194.18 * log(Temp) - 1448.6;\n   \tcol = clamp(col, 0., 255.)/255.;\n    if (Temp < 1000.) col *= Temp/1000.;\n   \treturn col;\n}\n\n// Coloring\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    //set grid\n    vec2 uvCoord = fragCoord.xy/ iResolution.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n    \n    vec2 uv = GET_TEXTURE(0,0);\n    \n    #ifdef JET\n    \tvec3 color = jet(uv.y);\n\t#endif\n    #ifdef GRAY\n    \tvec3 color = gray(uv.x);\n\t#endif\n    #ifdef WHEEL\n    \tvec3 color = wheel(uv.x);\n\t#endif\n    #ifdef HOT\n    \tvec3 color = hot(uv.x);\n\t#endif\n    #ifdef COOL\n    \tvec3 color = cool(uv.x);\n\t#endif\n    #ifdef BLACKBODY\n    \tvec3 color = blackbody(uv.y);\n\t#endif\n    \n    fragColor = vec4(color,1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float radius = 0.02; // compact support of perturbation\n\n// Constant height bumb function\nfloat bumbCyl(float p)\n{\n\treturn 1.0;\n}\n\n// Triangular bumb function\nfloat bumbTri(float p)\n{\n\treturn 1.0-abs(p/radius);\n}\n\n// Smooth bumb function\nfloat bumbGauss(float p)\n{\n\treturn exp(-radius/(radius-p*p));\n}\n\n\n// Action depending on mouse input\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uvCoord = fragCoord.xy/iResolution.xy;\n    \n    \n    // init simulation with noise. 10 because sometime it dosent register on pageload4\n    float p = length((fragCoord.xy - vec2(0.5,0.5*iResolution.y)) / iResolution.x);\n    if (iFrame<15 && p < radius) {\n        fragColor = vec4(0,bumbCyl(p),0,0);\n        return;\n    }\n    else if (iFrame<15&& p > radius) {\n        fragColor = vec4(1,0,0,0);\n        return;\n    }\n    \n    // set choice of feed and kill via mouse\n    p = length((fragCoord.xy - iResolution.xy/2.0) / iResolution.x);   \n    if((iMouse.z > 0.0) && (texture(iChannel0, uvCoord).w == 0.0) )\n       {\n    \tvec2 mouseCoord = iMouse.xy/iResolution.xy;\n        float feed = mouseCoord.y*0.05;\n        float kill = mouseCoord.x*0.05+0.025;\n        if (p < 0.05) fragColor = vec4(0,1,feed,kill);\n        else fragColor = vec4(1,0,feed,kill);\n        return;\n    }\n    \n    // add perturbation with mouse\n    p = length((fragCoord.xy - iMouse.xy) / iResolution.x);   \n    if(iMouse.z > 0.0 && p < radius) {\n        fragColor = vec4(0,bumbCyl(p),texture(iChannel0, uvCoord).zw);\n        return;\n    }\n    \n    // return value of uv, feed and kill\n    fragColor =  vec4(texture(iChannel1, uvCoord).xy,texture(iChannel0, uvCoord).zw);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Comment if you do not want to use 9 point stencil for laplacian\n//don't forget to change in other buffers\n//Also did not do bdr condition for 9 point\n//#define USE_NINE\n\n#define GET_TEXTURE(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n\nconst vec2 diff = vec2(0.08,0.03); // difusion coefficients of uv\n// the problem is non-dimensionnal.\nconst float dt = 2.0; //unstable for greater dt.\nconst float dx = 1.0; \n\n// Compute Laplacian Centered Finite Difference\n// five point stencil\nfloat lap(float u,vec4 uplus) \n{\n\treturn (dot(uplus,vec4(1.0))-4.0*u)/(dx*dx);\n}\n\n// nine point stencil\nfloat lapnine(float u, vec4 uplus, vec4 ucross) {\n    return (dot(ucross,vec4(1.0))+4.0*dot(uplus,vec4(1.0))-20.0*u)/(6.0*dx*dx);\n}\n\n// SOLVE Gray Scott System\n// u_t = diffu*lap(u) - u*v*v + feed*(1 - u)\n// v_t = diffv*lap(v) + u*v*v - (feed+kill)*v\nvec2 solveGrayScott(float feed, float kill, vec2 uv, vec4 uplus, vec4 ucross, vec4 vplus, vec4 vcross) \n{\n\n    vec2 duv;\n\n    #ifdef USE_NINE\n    duv.x = diff.x*lapnine(uv.x, uplus, ucross);\n    duv.y = diff.y*lapnine(uv.y, vplus, vcross);\n    #else \n    duv.x = diff.x*lap(uv.x, uplus);\n    duv.y = diff.y*lap(uv.y, vplus);\n    #endif\n    duv.x += - uv.x*uv.y*uv.y + feed*(1.0 - uv.x);\n    duv.y += uv.x*uv.y*uv.y - (feed+kill)*uv.y;\n\n    return uv + dt*duv;;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    vec2 uvCoord = fragCoord.xy/iResolution.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    \n\n    // set feed, kill depending on choice could be done in buffer A only\n    float feed;\n    float kill;\n    if (texture(iChannel0, uvCoord).z != 0.0)\n    {\n    \tfeed = texture(iChannel0, uvCoord).z;\n        kill = texture(iChannel0, uvCoord).w;\n    }\n    else\n    {\n    \tfeed = uvCoord.y*0.05;\n    \tkill = uvCoord.x*0.05+0.025;\n    }\n    \n    //to compute finite difference approximaton\n    vec2 uv = GET_TEXTURE(0,0); // texture.x value of u this step\n    vec2 uvip1 = GET_TEXTURE(1,0);\n    vec2 uvim1 = GET_TEXTURE(-1,0);\n    vec2 uvjp1 = GET_TEXTURE(0,1);\n    vec2 uvjm1 = GET_TEXTURE(0,-1);\n    \n    \n    vec2 uvip1jp1 = GET_TEXTURE(1,1);\n    vec2 uvim1jp1 = GET_TEXTURE(-1,1);\n    vec2 uvim1jm1 = GET_TEXTURE(-1,-1);\n    vec2 uvip1jm1 = GET_TEXTURE(1,-1);\n    \n    //for periodic boundary not adjusted for 9 point stencil\n    vec2 uvijentry =  GET_TEXTURE(-ijCoord.x,0);\n    vec2 uvijexit =  GET_TEXTURE(-ijCoord.x+int(iResolution.x)-1,0);\n    vec2 uvijdown =  GET_TEXTURE(0,-ijCoord.y);\n    vec2 uvijtop =  GET_TEXTURE(0,-ijCoord.y+int(iResolution.y)-1);\n    \n    \n    \n    //Set boundary condition (image method) \n    if (ijCoord.x <= 0) // Left boundary\n    {\n        //uvim1 = uv;\n        uvim1 = uvijexit;\n    }\n    if (ijCoord.x >= int(iResolution.x)-1)  // Right boundary\n    {\n        //uvip1 = uv;\n        uvip1 =  uvijentry;\n    }\n    if (ijCoord.y <= 0)  // Down boundary\n    {\n        //uvjm1 = uv;\n        uvjm1 =  uvijtop;\n    }\n    if (ijCoord.y >=int(iResolution.y)-1) // Up boundary\n    {\n        //uvjp1 = uv;\n        uvjp1 =  uvijdown;\n    }\n    \n    \n    vec4 uplus = vec4(uvip1.x, uvim1.x, uvjp1.x, uvjm1.x);\n    vec4 ucross = vec4(uvip1jp1.x, uvim1jp1.x, uvim1jm1.x, uvip1jm1.x);\n    \n    vec4 vplus = vec4(uvip1.y, uvim1.y, uvjp1.y, uvjm1.y);\n    vec4 vcross = vec4(uvip1jp1.y, uvim1jp1.y, uvim1jm1.y, uvip1jm1.y);\n    \n    uv = solveGrayScott(feed, kill, uv, uplus, ucross, vplus, vcross);\n\n    // return new value of uv feed kill to next buffer.\n    fragColor = vec4(uv.xy, feed, kill);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Comment if you do not want to use 9 point stencil for laplacian\n//don't forget to change in other buffers\n//Also did not do bdr condition for 9 point\n//#define USE_NINE\n\n#define GET_TEXTURE(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n\nconst vec2 diff = vec2(0.08,0.03); // difusion coefficients of uv\n// the problem is non-dimensionnal.\nconst float dt = 2.0; //unstable for greater dt.\nconst float dx = 1.0; \n\n// Compute Laplacian Centered Finite Difference\n// five point stencil\nfloat lap(float u,vec4 uplus) \n{\n\treturn (dot(uplus,vec4(1.0))-4.0*u)/(dx*dx);\n}\n\n// nine point stencil\nfloat lapnine(float u, vec4 uplus, vec4 ucross) {\n    return (dot(ucross,vec4(1.0))+4.0*dot(uplus,vec4(1.0))-20.0*u)/(6.0*dx*dx);\n}\n\n// SOLVE Gray Scott System\n// u_t = diffu*lap(u) - u*v*v + feed*(1 - u)\n// v_t = diffv*lap(v) + u*v*v - (feed+kill)*v\nvec2 solveGrayScott(float feed, float kill, vec2 uv, vec4 uplus, vec4 ucross, vec4 vplus, vec4 vcross) \n{\n\n    vec2 duv;\n\n    #ifdef USE_NINE\n    duv.x = diff.x*lapnine(uv.x, uplus, ucross);\n    duv.y = diff.y*lapnine(uv.y, vplus, vcross);\n    #else \n    duv.x = diff.x*lap(uv.x, uplus);\n    duv.y = diff.y*lap(uv.y, vplus);\n    #endif\n    duv.x += - uv.x*uv.y*uv.y + feed*(1.0 - uv.x);\n    duv.y += uv.x*uv.y*uv.y - (feed+kill)*uv.y;\n\n    return uv + dt*duv;;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    vec2 uvCoord = fragCoord.xy/iResolution.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    \n\n    // set feed, kill depending on choice could be done in buffer A only\n    float feed;\n    float kill;\n    if (texture(iChannel0, uvCoord).z != 0.0)\n    {\n    \tfeed = texture(iChannel0, uvCoord).z;\n        kill = texture(iChannel0, uvCoord).w;\n    }\n    else\n    {\n    \tfeed = uvCoord.y*0.05;\n    \tkill = uvCoord.x*0.05+0.025;\n    }\n    \n    //to compute finite difference approximaton\n    vec2 uv = GET_TEXTURE(0,0); // texture.x value of u this step\n    vec2 uvip1 = GET_TEXTURE(1,0);\n    vec2 uvim1 = GET_TEXTURE(-1,0);\n    vec2 uvjp1 = GET_TEXTURE(0,1);\n    vec2 uvjm1 = GET_TEXTURE(0,-1);\n    \n    \n    vec2 uvip1jp1 = GET_TEXTURE(1,1);\n    vec2 uvim1jp1 = GET_TEXTURE(-1,1);\n    vec2 uvim1jm1 = GET_TEXTURE(-1,-1);\n    vec2 uvip1jm1 = GET_TEXTURE(1,-1);\n    \n    //for periodic boundary not adjusted for 9 point stencil\n    vec2 uvijentry =  GET_TEXTURE(-ijCoord.x,0);\n    vec2 uvijexit =  GET_TEXTURE(-ijCoord.x+int(iResolution.x)-1,0);\n    vec2 uvijdown =  GET_TEXTURE(0,-ijCoord.y);\n    vec2 uvijtop =  GET_TEXTURE(0,-ijCoord.y+int(iResolution.y)-1);\n    \n    \n    \n    //Set boundary condition (image method) \n    if (ijCoord.x <= 0) // Left boundary\n    {\n        //uvim1 = uv;\n        uvim1 = uvijexit;\n    }\n    if (ijCoord.x >= int(iResolution.x)-1)  // Right boundary\n    {\n        //uvip1 = uv;\n        uvip1 =  uvijentry;\n    }\n    if (ijCoord.y <= 0)  // Down boundary\n    {\n        //uvjm1 = uv;\n        uvjm1 =  uvijtop;\n    }\n    if (ijCoord.y >=int(iResolution.y)-1) // Up boundary\n    {\n        //uvjp1 = uv;\n        uvjp1 =  uvijdown;\n    }\n    \n    \n    vec4 uplus = vec4(uvip1.x, uvim1.x, uvjp1.x, uvjm1.x);\n    vec4 ucross = vec4(uvip1jp1.x, uvim1jp1.x, uvim1jm1.x, uvip1jm1.x);\n    \n    vec4 vplus = vec4(uvip1.y, uvim1.y, uvjp1.y, uvjm1.y);\n    vec4 vcross = vec4(uvip1jp1.y, uvim1jp1.y, uvim1jm1.y, uvip1jm1.y);\n    \n    uv = solveGrayScott(feed, kill, uv, uplus, ucross, vplus, vcross);\n\n    // return new value of uv feed kill to next buffer.\n    fragColor = vec4(uv.xy, feed, kill);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"//Comment if you do not want to use 9 point stencil for laplacian\n//don't forget to change in other buffers\n//Also did not do bdr condition for 9 point\n//#define USE_NINE\n\n#define GET_TEXTURE(I,J) texelFetch( iChannel0, ijCoord+ivec2(I,J), 0 ).xy\n\nconst vec2 diff = vec2(0.08,0.03); // difusion coefficients of uv\n// the problem is non-dimensionnal.\nconst float dt = 2.0; //unstable for greater dt.\nconst float dx = 1.0; \n\n// Compute Laplacian Centered Finite Difference\n// five point stencil\nfloat lap(float u,vec4 uplus) \n{\n\treturn (dot(uplus,vec4(1.0))-4.0*u)/(dx*dx);\n}\n\n// nine point stencil\nfloat lapnine(float u, vec4 uplus, vec4 ucross) {\n    return (dot(ucross,vec4(1.0))+4.0*dot(uplus,vec4(1.0))-20.0*u)/(6.0*dx*dx);\n}\n\n// SOLVE Gray Scott System\n// u_t = diffu*lap(u) - u*v*v + feed*(1 - u)\n// v_t = diffv*lap(v) + u*v*v - (feed+kill)*v\nvec2 solveGrayScott(float feed, float kill, vec2 uv, vec4 uplus, vec4 ucross, vec4 vplus, vec4 vcross) \n{\n\n    vec2 duv;\n\n    #ifdef USE_NINE\n    duv.x = diff.x*lapnine(uv.x, uplus, ucross);\n    duv.y = diff.y*lapnine(uv.y, vplus, vcross);\n    #else \n    duv.x = diff.x*lap(uv.x, uplus);\n    duv.y = diff.y*lap(uv.y, vplus);\n    #endif\n    duv.x += - uv.x*uv.y*uv.y + feed*(1.0 - uv.x);\n    duv.y += uv.x*uv.y*uv.y - (feed+kill)*uv.y;\n\n    return uv + dt*duv;;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //set grid\n    vec2 uvCoord = fragCoord.xy/iResolution.xy;\n    ivec2 ijCoord = ivec2(floor(fragCoord.xy));\n\n    \n\n    // set feed, kill depending on choice could be done in buffer A only\n    float feed;\n    float kill;\n    if (texture(iChannel0, uvCoord).z != 0.0)\n    {\n    \tfeed = texture(iChannel0, uvCoord).z;\n        kill = texture(iChannel0, uvCoord).w;\n    }\n    else\n    {\n    \tfeed = uvCoord.y*0.05;\n    \tkill = uvCoord.x*0.05+0.025;\n    }\n    \n    //to compute finite difference approximaton\n    vec2 uv = GET_TEXTURE(0,0); // texture.x value of u this step\n    vec2 uvip1 = GET_TEXTURE(1,0);\n    vec2 uvim1 = GET_TEXTURE(-1,0);\n    vec2 uvjp1 = GET_TEXTURE(0,1);\n    vec2 uvjm1 = GET_TEXTURE(0,-1);\n    \n    \n    vec2 uvip1jp1 = GET_TEXTURE(1,1);\n    vec2 uvim1jp1 = GET_TEXTURE(-1,1);\n    vec2 uvim1jm1 = GET_TEXTURE(-1,-1);\n    vec2 uvip1jm1 = GET_TEXTURE(1,-1);\n    \n    //for periodic boundary not adjusted for 9 point stencil\n    vec2 uvijentry =  GET_TEXTURE(-ijCoord.x,0);\n    vec2 uvijexit =  GET_TEXTURE(-ijCoord.x+int(iResolution.x)-1,0);\n    vec2 uvijdown =  GET_TEXTURE(0,-ijCoord.y);\n    vec2 uvijtop =  GET_TEXTURE(0,-ijCoord.y+int(iResolution.y)-1);\n    \n    \n    \n    //Set boundary condition (image method) \n    if (ijCoord.x <= 0) // Left boundary\n    {\n        //uvim1 = uv;\n        uvim1 = uvijexit;\n    }\n    if (ijCoord.x >= int(iResolution.x)-1)  // Right boundary\n    {\n        //uvip1 = uv;\n        uvip1 =  uvijentry;\n    }\n    if (ijCoord.y <= 0)  // Down boundary\n    {\n        //uvjm1 = uv;\n        uvjm1 =  uvijtop;\n    }\n    if (ijCoord.y >=int(iResolution.y)-1) // Up boundary\n    {\n        //uvjp1 = uv;\n        uvjp1 =  uvijdown;\n    }\n    \n    \n    vec4 uplus = vec4(uvip1.x, uvim1.x, uvjp1.x, uvjm1.x);\n    vec4 ucross = vec4(uvip1jp1.x, uvim1jp1.x, uvim1jm1.x, uvip1jm1.x);\n    \n    vec4 vplus = vec4(uvip1.y, uvim1.y, uvjp1.y, uvjm1.y);\n    vec4 vcross = vec4(uvip1jp1.y, uvim1jp1.y, uvim1jm1.y, uvip1jm1.y);\n    \n    uv = solveGrayScott(feed, kill, uv, uplus, ucross, vplus, vcross);\n\n    // return new value of uv feed kill to next buffer.\n    fragColor = vec4(uv.xy, feed, kill);\n}","name":"Buf D","description":"","type":"buffer"}]}