{"ver":"0.1","info":{"id":"DsBGWG","date":"1668060976","viewed":215,"name":"Transmittance LUT","username":"hzh98","description":"The transmittance LUT of [Ebruneton08] Precomputed Atmosphere Scattering (https://ebruneton.github.io/precomputed_atmospheric_scattering)","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["transmittance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// origin at left-bottom, \n// mu for x-axis, r for y-axis\n\n// 0: new imlementation in 2017 \n// 1: original implementation in 2008\n// 2: linear-mapping of (mu, r)\n#define LINEAR_MAPPING 0\n\nconst int  TRANSMITTANCE_TEXTURE_WIDTH  = 256;\nconst int  TRANSMITTANCE_TEXTURE_HEIGHT = 64;\nconst vec2 TRANSMITTANCE_TEXTURE_SIZE   = vec2(TRANSMITTANCE_TEXTURE_WIDTH, TRANSMITTANCE_TEXTURE_HEIGHT);\n\nconst int   kSampleCount       = 500;\nconst float kEarthRadius       = 6360.0;  \nconst float kAtmopsphereRadius = 6420.0;  \n\nconst float kHeightR = 8.0; // scale height for rayleigh \nconst float kHeightM = 1.2; // scale height for mie\nconst vec3  kBetaR   = vec3(5.802, 13.558, 33.100) * 1e-3; // Rayleigh scattering coeffcient\nconst vec3  kBetaM   = vec3(0.0044); // Mie extinction\nconst vec3  kBetaOzone  = vec3(0.000650,0.001881,0.000085); // absorption_extinction\n\n// Utilities\nfloat ClampCosine(float mu) {\n    return clamp(mu, -1.0, 1.0);\n}\nfloat ClampDistance(float d) {\n    return max(d, 0.0);\n}\nfloat ClampRadius(float r) {\n    return clamp(r, kEarthRadius, kAtmopsphereRadius);\n}\nfloat SafeSqrt(float a) {\n    return sqrt(max(a, 0.0));\n}\n\nfloat DistanceToTopAtmosphereBoundary(float r, float mu) {\n    float discriminant = r*r*(mu*mu - 1.0) + kAtmopsphereRadius * kAtmopsphereRadius;\n    return ClampDistance(-r * mu + SafeSqrt(discriminant));\n}\n\nvoid GetRMuFromTransmittanceTextureUvLinear(in vec2 uv, out float r, out float mu) {\n    mu = uv.x;\n    r  = mix(kEarthRadius, kAtmopsphereRadius, uv.y);\n}\n\nvoid GetRMuFromTransmittanceTextureUv_original08(in vec2 uv, out float r, out float mu) {\n    mu = uv.x;\n    mu = -0.15 + tan(1.5 * mu) / tan(1.5) * (1.0 + 0.15);\n    r = kEarthRadius + pow(uv.y, 2.0) * (kAtmopsphereRadius - kEarthRadius);\n}\n\nvoid GetRMuFromTransmittanceTextureUv_new17(in vec2 uv, out float r, out float mu) {\n    float H = sqrt(kAtmopsphereRadius * kAtmopsphereRadius - kEarthRadius * kEarthRadius);\n    float x_mu = uv.x;\n    float x_r = uv.y;\n    float rho = H * x_r;\n    r = sqrt(rho * rho + kEarthRadius * kEarthRadius);\n    float d_min = kAtmopsphereRadius - r;\n    float d_max = rho + H;\n    float d = d_min + x_mu * (d_max - d_min);\n    mu = d <= 0.0 ? float(1.0) : (H * H - rho * rho - d * d) / (2.0 * r * d);\n    mu = ClampCosine(mu);\n}\n\n// total optical length of rayleigh and mie\nfloat ComputeOpticalLengthToTopAtmosphereBoundary(float h_scale, float r, float mu) {\n    float dx = DistanceToTopAtmosphereBoundary(r, mu) / float(kSampleCount);\n    float result = 0.0;\n    for (int i = 0; i <= kSampleCount; ++i) {\n        float d_i = float(i) * dx;\n        float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);\n        float y_i = clamp(exp(-(r_i - kEarthRadius) / h_scale), 0.0, 1.0);\n        result += y_i * dx;\n    }\n    return result;\n}\n\n// total optical length of Ozone\nfloat ComputeOpticalLengthToTopAtmosphereBoundary_O3(float r, float mu) {\n    float dx = DistanceToTopAtmosphereBoundary(r, mu) / float(kSampleCount);\n    float result = 0.0;\n    for (int i = 0; i <= kSampleCount; ++i) {\n        float d_i = float(i) * dx;\n        float r_i = sqrt(d_i * d_i + 2.0 * r * mu * d_i + r * r);\n        float height = r_i - kEarthRadius;\n        float linear_term = 0.0, constant_term = 0.0;\n        // 2 Ozone layers\n        linear_term = height < 25.0 ? 0.066667 : -0.066667;\n        constant_term = height < 25.0 ? -0.66667 : 2.666667;\n        float y_i = linear_term * height + constant_term;\n        y_i = clamp(y_i, 0.0, 1.0);\n        result += y_i * dx;\n    }\n    return result;\n}\n\nvec3 ComputeTransmittanceToTopAtmosphereBoundary(float r, float mu) {\n    vec3 attenuation_rayleigh = kBetaR * ComputeOpticalLengthToTopAtmosphereBoundary(kHeightR, r, mu);\n    vec3 attenuation_mie = kBetaM * ComputeOpticalLengthToTopAtmosphereBoundary(kHeightM, r, mu);\n    vec3 attenuation_total = attenuation_rayleigh + attenuation_mie;\n    #if(LINEAR_MAPPING==0)\n    attenuation_total += kBetaOzone * ComputeOpticalLengthToTopAtmosphereBoundary_O3(r, mu);\n    #endif\n    return exp(-attenuation_total);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    float r, mu;\n    #if(LINEAR_MAPPING==0)\n        GetRMuFromTransmittanceTextureUv_new17(uv, r, mu);\n    #elif(LINEAR_MAPPING==1)\n        GetRMuFromTransmittanceTextureUv_original08(uv, r, mu);\n    #elif(LINEAR_MAPPING==2)\n        GetRMuFromTransmittanceTextureUvLinear(uv, r, mu);\n    #endif\n    vec3 col = ComputeTransmittanceToTopAtmosphereBoundary(r, mu);\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}