{"ver":"0.1","info":{"id":"4tyGDD","date":"1474575002","viewed":4627,"name":"2D Catmull-Rom in 4 samples","username":"gdecarp","description":"Applies 2D Catmull-Rom interpolation to a texture, optimized from 16 loads to only 4 bilinear samples. This is only possible if you prepare the input texture for it (once), as done in Buf A. Catmull-Rom on the left, bilinear on the right. Based on /MtVGWz","likes":37,"published":1,"flags":32,"usePreview":1,"tags":["texture","filtering","sampling","interpolation","catmullrom","catmull","rom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////////////////////\n// Applies 2D Catmull-Rom interpolation to a texture, optimized from 16 loads to 4 bi-linear samples. \n// This assumes the input texture has been preprocessed (once) to have negated values for 50% of \n// its texels, applied in a checkerboard-like pattern. If the texture format doesn't support  \n// negative values, then pack this using 0.5 * signed_value + 0.5 at the cost of losing a bit in \n// precision. The texture preprocessing is done in Buf A. Only this preprocessing and the actual\n// 4-sample implementation is my work. The rest of the code has been copied from the 9-tab \n// implementation on https://www.shadertoy.com/view/MtVGWz.\n//\n// A full derivation and explanation is available at: \n// http://www.decarpentier.nl/2d-catmull-rom-in-4-samples.\n//\n// Giliam de Carpentier, 2016.\n// www.decarpentier.nl\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n// Uncomment the next line to use the original 9-sample implementation.\n//#define USE_ORIGINAL_9_SAMPLE_IMPLEMENTATION_INSTEAD\n\n// Uncomment the following to use only positive colors. (And do this in 'Buf A' as well).\n//#define PACK_SIGNED_TO_UNSIGNED\n\nvec4 SampleTextureBilinearlyAndUnpack(sampler2D tex, vec2 uv)\n{\n    vec4 sample_color = texture(tex, uv, 0.0);\n#ifdef PACK_SIGNED_TO_UNSIGNED\n    sample_color = 2.0 * sample_color - 1.0;\n#endif // PACK_SIGNED_TO_UNSIGNED\n    return sample_color;\n}\n \nvec4 SampleTextureCatmullRom4Samples(sampler2D tex, vec2 uv, vec2 texSize)\n{\n    // Based on the standard Catmull-Rom spline: w1*C1+w2*C2+w3*C3+w4*C4, where\n    // w1 = ((-0.5*f + 1.0)*f - 0.5)*f, w2 = (1.5*f - 2.5)*f*f + 1.0,\n    // w3 = ((-1.5*f + 2.0)*f + 0.5)*f and w4 = (0.5*f - 0.5)*f*f with f as the\n    // normalized interpolation position between C2 (at f=0) and C3 (at f=1).\n \n    // half_f is a sort of sub-pixelquad fraction, -1 <= half_f < 1.\n    vec2 half_f     = 2.0 * fract(0.5 * uv * texSize - 0.25) - 1.0;\n \n    // f is the regular sub-pixel fraction, 0 <= f < 1. This is equivalent to\n    // fract(uv * texSize - 0.5), but based on half_f to prevent rounding issues.\n    vec2 f          = fract(half_f);\n \n    vec2 s1         = ( 0.5 * f - 0.5) * f;            // = w1 / (1 - f)\n    vec2 s12        = (-2.0 * f + 1.5) * f + 1.0;      // = (w2 - w1) / (1 - f)\n    vec2 s34        = ( 2.0 * f - 2.5) * f - 0.5;      // = (w4 - w3) / f\n \n    // positions is equivalent to: (floor(uv * texSize - 0.5).xyxy + 0.5 +\n    // vec4(-1.0 + w2 / (w2 - w1), 1.0 + w4 / (w4 - w3))) / texSize.xyxy.\n    vec4 positions  = vec4((-f * s12 + s1      ) / (texSize * s12) + uv,\n                           (-f * s34 + s1 + s34) / (texSize * s34) + uv);\n \n    // Determine if the output needs to be sign-flipped. Equivalent to .x*.y of\n    // (1.0 - 2.0 * floor(t - 2.0 * floor(0.5 * t))), where t is uv * texSize - 0.5.\n    float sign_flip = half_f.x * half_f.y > 0.0 ? 1.0 : -1.0;\n \n    vec4 w          = vec4(-f * s12 + s12, s34 * f); // = (w2 - w1, w4 - w3)\n    vec4 weights    = vec4(w.xz * (w.y * sign_flip), w.xz * (w.w * sign_flip));\n \n    return SampleTextureBilinearlyAndUnpack(tex, positions.xy) * weights.x +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zy) * weights.y +\n           SampleTextureBilinearlyAndUnpack(tex, positions.xw) * weights.z +\n           SampleTextureBilinearlyAndUnpack(tex, positions.zw) * weights.w;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// What follows is a copy of https://www.shadertoy.com/view/MtVGWz#, modified to call\n// SampleTextureCatmullRom4Samples() instead.\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec4 sampleLevel0( vec2 uv )\n{\n    return texture( iChannel0, uv, -10.0 );\n}\n\n// note: entirely stolen from https://gist.github.com/TheRealMJP/c83b8c0f46b63f3a88a5986f4fa982b1\n// Samples a texture with Catmull-Rom filtering, using 9 texture fetches instead of 16.\n// See http://vec3.ca/bicubic-filtering-in-fewer-taps/ for more details\nvec4 SampleTextureCatmullRom( vec2 uv, vec2 texSize )\n{\n    // We're going to sample a a 4x4 grid of texels surrounding the target UV coordinate. We'll do this by rounding\n    // down the sample location to get the exact center of our \"starting\" texel. The starting texel will be at\n    // location [1, 1] in the grid, where [0, 0] is the top left corner.\n    vec2 samplePos = uv * texSize;\n    vec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\n    // Compute the fractional offset from our starting texel to our original sample location, which we'll\n    // feed into the Catmull-Rom spline function to get our filter weights.\n    vec2 f = samplePos - texPos1;\n\n    // Compute the Catmull-Rom weights using the fractional offset that we calculated earlier.\n    // These equations are pre-expanded based on our knowledge of where the texels will be located,\n    // which lets us avoid having to evaluate a piece-wise function.\n    vec2 w0 = f * ( -0.5 + f * (1.0 - 0.5*f));\n    vec2 w1 = 1.0 + f * f * (-2.5 + 1.5*f);\n    vec2 w2 = f * ( 0.5 + f * (2.0 - 1.5*f) );\n    vec2 w3 = f * f * (-0.5 + 0.5 * f);\n    \n    // Work out weighting factors and sampling offsets that will let us use bilinear filtering to\n    // simultaneously evaluate the middle 2 samples from the 4x4 grid.\n    vec2 w12 = w1 + w2;\n    vec2 offset12 = w2 / (w1 + w2);\n\n    // Compute the final UV coordinates we'll use for sampling the texture\n    vec2 texPos0 = texPos1 - vec2(1.0);\n    vec2 texPos3 = texPos1 + vec2(2.0);\n    vec2 texPos12 = texPos1 + offset12;\n\n    texPos0 /= texSize;\n    texPos3 /= texSize;\n    texPos12 /= texSize;\n\n    vec4 result = vec4(0.0);\n    result += sampleLevel0( vec2(texPos0.x,  texPos0.y)) * w0.x * w0.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos0.y)) * w12.x * w0.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos0.y)) * w3.x * w0.y;\n\n    result += sampleLevel0( vec2(texPos0.x,  texPos12.y)) * w0.x * w12.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos12.y)) * w12.x * w12.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos12.y)) * w3.x * w12.y;\n\n    result += sampleLevel0( vec2(texPos0.x,  texPos3.y)) * w0.x * w3.y;\n    result += sampleLevel0( vec2(texPos12.x, texPos3.y)) * w12.x * w3.y;\n    result += sampleLevel0( vec2(texPos3.x,  texPos3.y)) * w3.x * w3.y;\n\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 sample_uv = uv;\n    sample_uv.x = mod( sample_uv.x, 0.5 );\n   \tsample_uv += 0.01 * vec2( cos(iTime), sin(iTime) );\n    sample_uv *= (iMouse.z>0.0)? iMouse.x * 0.001 : 0.06125;\n    sample_uv += 0.01;\n    \n    vec4 sample_color;\n    if ( uv.x < 0.5 )\n#ifndef USE_ORIGINAL_9_SAMPLE_IMPLEMENTATION_INSTEAD        \n    {   \n \t\tsample_color = SampleTextureCatmullRom4Samples(iChannel1, sample_uv * iChannelResolution[0].xy / iChannelResolution[1].xy, iChannelResolution[1].xy );\n    }\n#else\n    {\n    \tsample_color = SampleTextureCatmullRom( sample_uv, iChannelResolution[0].xy );\n    }\n#endif\n    else\n        sample_color = sampleLevel0( sample_uv );\n\n    fragColor = sample_color;\n    fragColor -= step(abs(uv.x-0.5), 0.001);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"///////////////////////////////////////////////////////////////////////////////////////////////////\n// Preprocess the input texture by alternating the sign of the texels in a checkerboard-like \n// pattern and pack that into an unsigned output. For static textures, this could be\n// done using an offline tool, as it only needs to be done once. For dynamic textures (as may\n// be useful of tempororal reprojections, for example), this could probably be done as part of  \n// rendering of the texture itself, instead of having this as a separate pass. The\n// signed-to-unsigned packing is only necessary for unsigned output textures/render targets.\n//\n// Giliam de Carpentier, 2016.\n// www.decarpentier.nl\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n// Uncomment the following to use only positive colors. (And do this in 'Image' as well).\n//#define PACK_SIGNED_TO_UNSIGNED\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec4 sample_color\t = texture(iChannel0, fragCoord / iChannelResolution[0].xy, -10.0);\n    vec2 half_f \t\t = 2.0 * fract(0.5 * fragCoord.xy) - 1.0;\n    sample_color = half_f.x * half_f.y > 0.0 ? sample_color : -sample_color;\n#ifdef PACK_SIGNED_TO_UNSIGNED\n    sample_color = sample_color * 0.5 + 0.5;\n#endif // PACK_SIGNED_TO_UNSIGNED\n \tfragColor \t = sample_color;   \n}\n\n","name":"Buf A","description":"","type":"buffer"}]}