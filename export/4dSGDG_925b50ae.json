{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","sampler":{"filter":"nearest","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":3,"type":"texture","id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct quadrique_t{\n    vec3 origin;\n    float radius; \n\tfloat a;\n\tfloat b;\n\tfloat c;\n};\n\nstruct ray_t{\n    vec3 origin;\n    vec3 direction;   \n};\n\t\n\nstruct plane_t{\n    vec3 normal;\n\tvec3 orientation;\n    float offset;   \n};\n\t\nstruct light_t{\n\tvec3 direction;\n\tfloat contribution;\t\n};\n\nstruct surface_t{\n\tint identifier;\n\tvec3 position;\n\tvec3 normal;\n\tvec2 uv;\t\n};\n\t\nstruct material_t{\n\tvec3  color;\n\tfloat roughness;\n};\n\t\nconst int NONE   = 0;\nconst int PLANE  = 1;\nconst int ELLIPSOIDE = 2;\nconst int HYPERBOLOIDE = 3;\n\t\nconst float PI = 3.14;\nconst float max_distance = 1e5;\n\nfloat intersect_hyperboloide(const in ray_t ray,const in quadrique_t quadrique, out surface_t surface){\n\tfloat a = -(ray.direction.x * ray.direction.x / (quadrique.a * quadrique.a) )\n            +(ray.direction.y * ray.direction.y / (quadrique.b * quadrique.b))\n            +(ray.direction.z* ray.direction.z / (quadrique.c * quadrique.c));\n   \n    float b = -((ray.origin.x-quadrique.origin.x)*ray.direction.x / (quadrique.a * quadrique.a))\n            +((ray.origin.y-quadrique.origin.y)*ray.direction.y / (quadrique.b * quadrique.b))\n            +((ray.origin.z-quadrique.origin.z)*ray.direction.z / (quadrique.c * quadrique.c));\n   \n    b *= 2.0;\n\n    float c = -((ray.origin.x-quadrique.origin.x) * (ray.origin.x-quadrique.origin.x) / (quadrique.a * quadrique.a))\n            +((ray.origin.y-quadrique.origin.y) * (ray.origin.y-quadrique.origin.y) / (quadrique.b * quadrique.b))\n            +((ray.origin.z-quadrique.origin.z) * (ray.origin.z-quadrique.origin.z) / (quadrique.c * quadrique.c)) \n\t\t- (quadrique.radius * quadrique.radius);\n\t\n\tfloat delta = b * b - 4.0 * a * c;\n   \tif(delta < 0.0) return max_distance;\n\t\t\n\tfloat dist = (- b + sqrt( delta )) / ( 2.0 * a );\n\tfloat dist2 = (- b - sqrt( delta )) / ( 2.0 * a );\n\t\n\tif(dist > dist2) surface.position = ray.origin + dist2 * ray.direction;\n\telse surface.position = ray.origin + dist * ray.direction;\n\tsurface.normal = normalize( (surface.position - quadrique.origin) );\n\tsurface.identifier = HYPERBOLOIDE;\n\tvec3 local_pos = vec3(surface.position - quadrique.origin);\n\tfloat rho   = quadrique.radius;\n\tfloat theta = (atan( local_pos.x, local_pos.z ) + PI / 2.0 ) / PI;\n\tfloat phi   = acos( local_pos.y / rho ) / PI;\n\tsurface.uv = vec2( theta, phi );\n\t\n\treturn min(dist,dist2);\n}\n\nfloat intersect_ellipsoide(const in ray_t ray,const in quadrique_t quadrique, out surface_t surface){\n   \n    float a = (ray.direction.x * ray.direction.x / (quadrique.a * quadrique.a) )\n            +(ray.direction.y * ray.direction.y / (quadrique.b * quadrique.b))\n            +(ray.direction.z* ray.direction.z / (quadrique.c * quadrique.c));\n   \n    float b = ((ray.origin.x-quadrique.origin.x)*ray.direction.x / (quadrique.a * quadrique.a))\n            +((ray.origin.y-quadrique.origin.y)*ray.direction.y / (quadrique.b * quadrique.b))\n            +((ray.origin.z-quadrique.origin.z)*ray.direction.z / (quadrique.c * quadrique.c));\n   \n    b *= 2.0;\n\n    float c = ((ray.origin.x-quadrique.origin.x) * (ray.origin.x-quadrique.origin.x) / (quadrique.a * quadrique.a))\n            +((ray.origin.y-quadrique.origin.y) * (ray.origin.y-quadrique.origin.y) / (quadrique.b * quadrique.b))\n            +((ray.origin.z-quadrique.origin.z) * (ray.origin.z-quadrique.origin.z) / (quadrique.c * quadrique.c)) \n\t\t- (quadrique.radius * quadrique.radius);\n   \n    float delta = b * b - 4.0 * a * c;\n   \tif(delta < 0.0) return max_distance;\n\t\t\n\tfloat dist = (- b + sqrt( delta )) / ( 2.0 * a );\n\tfloat dist2 = (- b - sqrt( delta )) / ( 2.0 * a );\n\t\n\tif(dist > dist2) surface.position = ray.origin + dist2 * ray.direction;\n\telse surface.position = ray.origin + dist * ray.direction;\n\tsurface.normal = normalize( (surface.position - quadrique.origin) );\n\tsurface.identifier = ELLIPSOIDE;\n\tvec3 local_pos = vec3(surface.position - quadrique.origin);\n\tfloat rho   = quadrique.radius;\n\tfloat theta = (atan( local_pos.x, local_pos.z ) + PI / 2.0 ) / PI;\n\tfloat phi   = acos( local_pos.y / rho ) / PI;\n\tsurface.uv = vec2( theta, phi );\n\t\n\treturn min(dist,dist2);\n}\n\nfloat intersect_plane(const in ray_t ray,const in plane_t plane, out surface_t surface){\t\n\tfloat a = plane.normal.x;\n\tfloat b = plane.normal.y;\n\tfloat c = plane.normal.z;\n    float distance_from_origin = -(plane.offset +\n\t\t\t\t\t a * ray.origin.x + \n\t\t\t\t\t b * ray.origin.y + \n\t\t\t\t\t c * ray.origin.z) / (a * ray.direction. x + b * ray.direction.y + c * ray.direction.z);\n    \n\tsurface.position = ray.origin + ray.direction * distance_from_origin;\n\tsurface.normal = plane.normal;\n\tsurface.identifier = PLANE;\n\tsurface.uv = vec2( surface.position.x, surface.position.z );\n\t\n\treturn distance_from_origin > 0.0 ? distance_from_origin : max_distance;\t   \n}\n\nfloat intersect(const in ray_t ray, out surface_t surface, out material_t material, const in int avoid ){\n\t\n\tquadrique_t spheres[2];\n\tspheres[0] = quadrique_t( vec3( -2.0, mix( 1.5, 4.5, 0.5+0.5*cos(iTime)), mix( 2.5, 5.5, 0.5+0.5*sin(iTime))), 1.2, 1.0, 0.5, 0.5 );\n\tspheres[1] = quadrique_t( vec3( 2.0, mix( 1.1, 4.9, 0.5+0.5*cos(-iTime)), mix( 2.1, 5.9, 0.5+0.5*sin(-iTime))), 1.0, 1.0, 1.0, 1.0 );\n\tquadrique_t hyperboloide = quadrique_t( vec3( 0.0, 3.0, 4.0), 1.0, 100.0, 0.8, 1.0 );\n\t\n\tplane_t plane;\n\tplane.normal = vec3(0.0, 0.9, 0.04);\n\tplane.offset= 0.1;\n\t\n\tsurface_t surfaces[4];\n\t\n\tvec4 distances;\n\tdistances.x = intersect_hyperboloide(ray, hyperboloide, surfaces[0]);\n\tdistances.y = intersect_plane(ray, plane, surfaces[1]);\n\tdistances.z = intersect_ellipsoide(ray, spheres[0], surfaces[2]);\n\tdistances.w = intersect_ellipsoide(ray, spheres[1], surfaces[3]);\n\t\n\tfloat d = min( min(distances.x, distances.y), min(distances.z,distances.w));\n\n\t\t\n\tif( ( d == distances.x ) && ( avoid != HYPERBOLOIDE ) ){\n\t\tsurface = surfaces[0];\n\t\tsurface.uv *= 10.0;\n\t\tmaterial.color = texture( iChannel0, surface.normal ).rgb;\n\t\tmaterial.roughness = 0.8;\n\t}\n\telse if(( d == distances.y ) && ( avoid != PLANE )){\n\t\tsurface = surfaces[1];\n\t\tsurface.uv *= 0.5;\n\t\tmaterial.color = texture( iChannel1, surface.uv ).rgb;\n\t\tmaterial.roughness = 0.8;\n\t}\n\telse if( ( d == distances.z ) && ( avoid != ELLIPSOIDE )){\n\t\tsurface = surfaces[2];\n\t\tsurface.uv *= 0.5;\n\t\tmaterial.color = texture( iChannel2, surface.uv ).rgb;\n\t\tmaterial.roughness = 0.8;\n\t}\n\telse if( ( d == distances.w ) && ( avoid != ELLIPSOIDE )){\n\t\tsurface = surfaces[3];\n\t\tsurface.uv *= 0.5;\n\t\tmaterial.color = texture( iChannel3, surface.uv ).rgb;\n\t\tmaterial.roughness = 0.8;\n\t}\n\telse{\n\t\tsurface.identifier = NONE;\n\t\tsurface.position   = vec3( 0.0 );\n\t\tsurface.uv         = vec2( 0.0 );\n\t\tsurface.normal     = vec3( 0.0 );\n\t\t\n\t\tmaterial.color     = vec3( 1.0, 0.4, 0.3 );\n\t\tmaterial.roughness = 0.0;\n\t}\n\tif(d == max_distance){\n\t\tsurface.identifier = NONE;\n\t\tsurface.position   = vec3( 0.0 );\n\t\tsurface.uv         = vec2( 0.0 );\n\t\tsurface.normal     = vec3( 0.0 );\n\t\t\n\t\tmaterial.color     = vec3( 1.0, 0.4, 0.3 );\n\t\tmaterial.roughness = 0.0;\n\t}\n\treturn d;\n\t\t\n}\n\nvoid light_information(const in surface_t surface, out light_t light){\n\tlight.direction = vec3(0.0, 1.0, -2.0);\n\tlight.contribution = 1.0;\t\n}\n\nvec3 illumination( in ray_t ray, const in surface_t surface, const in light_t light, const material_t material ){\n\t\n\tfloat diffuse = max(0.0, dot(surface.normal, light.direction));\n\tvec3 half_vector = normalize( -ray.direction + light.direction );\n\tfloat specular = max(0.0, pow( dot(half_vector,surface.normal), 100.0)); \n\t\n\tvec3 contribution_diffuse  = vec3( diffuse * light.contribution * material.color );\n\tvec3 contribution_specular = vec3( specular * light.contribution );\n\t\n\tvec3 contribution = contribution_diffuse + contribution_specular;\n\t\n\treturn\tcontribution;\n}\n\nfloat shadow( const in surface_t surface, const in light_t light ){\n\tray_t shadow_ray;\n\tshadow_ray.origin = surface.position;\n\tshadow_ray.direction = light.direction;\n\t\n\tsurface_t hitted_surface;\n\tmaterial_t hitted_material;\n\tfloat distance_from_object = intersect( shadow_ray, hitted_surface, hitted_material, surface.identifier );\n\t\n\treturn ( hitted_surface.identifier != NONE ) ? distance_from_object : max_distance;\n}\n\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 screen_coordinate = fragCoord.xy /iResolution.xy;\n    vec2 screen_coordinate_centered = 2.0 * screen_coordinate - 1.0;\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tvec2  screen_coordinate_cor = vec2(aspect_ratio, 1.0) * screen_coordinate_centered;\n   \n    ray_t primary_ray;\n    primary_ray.origin = vec3( 0.0, 1.0, -3.0);\n\n    primary_ray.direction = normalize(vec3(screen_coordinate_cor , 1.0));\n   \n    surface_t surface;\n\tmaterial_t material;\n    float distance_from_origin = intersect(primary_ray, surface, material, NONE);\n   \t\n\tvec3 background_color = vec3(  screen_coordinate_cor, 1.0 );\n\tif( ( distance_from_origin < max_distance ) && surface.identifier != NONE )\n\t{\n\t\tlight_t light;\n\t\tlight_information(surface, light);\n\t\tvec3 illumination_from_light =  illumination(primary_ray, surface, light, material);\n\t\tfloat shadow_cast_light = shadow( surface, light ); \n\t\tillumination_from_light *= clamp( shadow_cast_light, 0.0, 1.0 );\n\n\t\tfragColor = vec4( vec3(illumination_from_light), 1.0 );\n\t\t\n\t}\n\telse\n\t{\n\t\tfragColor = vec4( vec3( background_color ), 1.0 );\n\t}\n   \n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSGDG","date":"1392638092","viewed":167,"name":"ellispoide+plane+hyperboloide","username":"bobpool","description":"ellispoide","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ellispoide"],"hasliked":0,"parentid":"","parentname":""}}