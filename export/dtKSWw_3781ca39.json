{"ver":"0.1","info":{"id":"dtKSWw","date":"1686191571","viewed":106,"name":"Transmission Hologram","username":"Quazi","description":"Exposes a holographic film that modulates plane wave phase to reproduce light field. This integrates over time+montecarlo positions to sim hologram. There's probably still be some mistakes in my assumptions but its better than the last try.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv_buff = fragCoord/iResolution.xy;\n    vec4 buffA = texture(iChannel0, uv_buff);\n    \n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    float mag_disp = buffA.x;\n    col.r = log(10.0*mag_disp);\n    col.g = log(1.5*mag_disp);\n    col.b = log(30.0*mag_disp);\n    //col.b = holo_mag;\n    /*\n    if(abs(uv.x-holo_pos.x) < holo_thickness * psz.x){ \n        col.rgb = mix(vec3(0.,0.,0.), vec3(1.,1.,1.), pow(1.0-length(holo_surf),0.1));\n    }\n    */\n    //col.rgb *= 0.0;\n    if(abs(uv_buff.x-0.5)<0.01){\n        col.rgb = vec3(1.0,1.0,1.0)*buffA.y;\n    }\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323846264338327950288;\nconst float S =50.0; //scale factor (what does 1 unit equal (e.g. 100 pixels = 1 unit -> S=100.0))\n\n//////////////////////////////////////////////////////////////////\n//https://www.shadertoy.com/view/wltcRS\n//internal RNG state \nuvec4 s0, s1; \nivec2 pixel;\n\nvoid rng_initialize(vec2 p, int frame)\n{\n    pixel = ivec2(p);\n\n    //white noise seed\n    s0 = uvec4(p, uint(frame), uint(p.x) + uint(p.y));\n    \n    //blue noise seed\n    s1 = uvec4(frame, frame*15843, frame*31 + 4566, frame*2345 + 58585);\n}\n\n// https://www.pcg-random.org/\nvoid pcg4d(inout uvec4 v)\n{\n\tv = v * 1664525u + 1013904223u;\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n    v = v ^ (v>>16u);\n    v.x += v.y*v.w; v.y += v.z*v.x; v.z += v.x*v.y; v.w += v.y*v.z;\n}\n\nfloat rand()\n{\n    pcg4d(s0); return float(s0.x)/float(0xffffffffu);\n}\n\nvec2 rand2()\n{\n    pcg4d(s0); return vec2(s0.xy)/float(0xffffffffu);\n}\n\nvec3 rand3()\n{\n    pcg4d(s0); return vec3(s0.xyz)/float(0xffffffffu);\n}\n\nvec4 rand4()\n{\n    pcg4d(s0); return vec4(s0)/float(0xffffffffu);\n}\n\n//random blue noise sampling pos\nivec2 shift2()\n{\n    pcg4d(s1); \n    return (pixel + ivec2(s1.xy%0x0fffffffu))%1024;\n}\n////////////////////////////////////////////\n\n\nvec2 get_psz(vec3 iResolution)\n{\n    return S*vec2(1.0, 1.0)/iResolution.x;\n}\n\nvec2 get_dxy(vec3 iResolution)\n{\n    return S*(rand2())/iResolution.x;\n}\n\nvec2 plane_wave( vec2 uv, vec2 dxy, float time, float freq, float amp, float phase, vec2 dir )\n{\n    float w= dot(uv+dxy, dir);\n    float t=((w - time) * freq + phase) * 2.0 * PI;    \n    return amp*vec2(sin(t), cos(t));\n}\n\nvec2 point_wave( vec2 uv, vec2 dxy, float time, float freq, float amp, float phase, vec2 pos )\n{\n    //this represents a column into Z rather than a point, hence like field around wire.\n    float w = length(uv+dxy-pos);\n    float r_sqd = w;\n    float t=((w - time) * freq + phase )* 2.0 * PI;\n    return amp*vec2(amp*sin(t),amp*cos(t))/r_sqd;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fork of \"Zoneplate\" by Quazi. https://shadertoy.com/view/DtKSDW\n// 2023-06-07 13:18:40\n\nfloat freq = 10.0;\nconst float amp = 1.1;\nconst float ang = PI*0.35;\nconst vec2 dir= vec2(cos(ang), sin(ang));\n\nvec2 ref_beam( vec2 uv, vec2 dxy, float t)\n{\n    return plane_wave(uv, dxy, t, freq*1.0, amp, 0.0, dir);\n}\n\nvec2 hologram( vec2 uv, vec2 dxy, float t, vec2 pos)\n{   \n    vec2 wave = vec2(0.0, 0.0);\n    //the ref beam has to do some weird stuff like flip and reverse direction to work with angled plate.\n    // i probably have a bug somewhere...\n    wave += plane_wave(uv, dxy, t, freq*1.0, amp, 0.0, dir*vec2(1.0,-1.0));\n    wave += point_wave(uv, dxy, t, freq, amp, 0.0, pos);\n    //wave += point_wave(uv, dxy, t, freq, amp*0.5, 0.0, vec2(0.25,0.25)*S);\n    return wave;\n}\n\nfloat hologram_exposure(vec2 hologram){\n    // simulate exposing the holographic film and the non-linear effects it can have.\n    // exposure is ultimately what modulates incoming wave.\n    // there's a sweet spot for mapping the hologram to an exposure to maximize the spike\n    //float exposure = 1.0*float(length(hologram)>1.00);\n    float exposure = 5.0*(length(hologram)-amp)+0.5;\n    return clamp(exposure, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    rng_initialize(fragCoord, iFrame);\n    \n    vec2 dxy = get_dxy(iResolution);\n    vec2 psz = get_psz(iResolution);\n    \n    vec2 uv = fragCoord * psz;\n    float t = rand();\n    \n\t// first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n    vec2 uv_buff = fragCoord/iResolution.xy;\n    vec4 buffA = texture(iChannel0, uv_buff);\n    float mix_eps = 0.05;\n    \n    // Hologram consts\n    float holo_thickness = 10.0;\n    float holo_height = iResolution.y * psz.y;\n    vec2 holo_pos = vec2(iResolution.x * psz.x *0.5, holo_height*0.5);\n    \n    vec2 mouse_uv = iMouse.xy*psz;\n    if(length(iMouse.zw - vec2(0.0,0.0))<40.0){\n        //float ang = fract(iTime*200.0+t*PI*2.0)*(0.1+(sin(iTime*0.05)*0.5+0.5)*0.1)*PI+iTime*0.1;\n        float ang = sign(t-0.5)+iTime*0.5;\n        float ring_amp = 0.25+sin(ang*3.0)*0.1;\n        mouse_uv = vec2(holo_pos.x*0.5, holo_pos.y)+(ring_amp*vec2(cos(ang), sin(ang)))/psz;\n        buffA.w = 0.1;\n    }\n    \n    // Time varying pixel color\n    \n    vec2 wave = vec2(0.0, 0.0);\n    \n    // Draw a the hologram film\n    vec2 holo = hologram(uv, dxy, t, mouse_uv);\n   \n    if(uv.x < holo_pos.x){\n        // draw the left hand side (reference beam)\n        wave += holo;\n    }else{\n        // draw the right hand side (interference from hologram film)\n        const int N = 1000;\n        float E_chunk = (holo_height) / float(N);\n        vec2 wave_chunk = vec2(0.0 ,0.0);\n        for (int i = 0; i < N; i++) {\n            // need total energy of the wavefront???\n            // Scale factor is important.\n\n            vec2 integral_uv = vec2(holo_pos.x, ((float(i)+rand())/float(N))*holo_height);\n            //float integral_holo_mag = length(hologram_exposure(hologram(integral_uv, t, mouse_uv)));\n            float integral_holo_mag = hologram_exposure(hologram(integral_uv, vec2(0.0, 0.0), t, mouse_uv));\n            float integral_phase = dot(integral_uv, dir) * freq + integral_holo_mag * 0.5;\n            wave_chunk += point_wave(uv, dxy, t, freq, amp, integral_phase, integral_uv);\n        }\n        wave += wave_chunk * E_chunk;\n    }  \n\n    if(sign(iMouse.z)>0.0){\n        buffA = vec4(0.0, 0.0, 0.0, 1.0-mix_eps);\n    }\n    vec2 holo_plate = hologram(vec2(holo_pos.x, uv.y), vec2(0.0, dxy.y), t, mouse_uv);\n    fragColor = mix(buffA, vec4(length(wave), hologram_exposure(holo_plate), 0.0, buffA.w*0.9), buffA.w+mix_eps);\n    \n}","name":"Buffer A","description":"","type":"buffer"}]}