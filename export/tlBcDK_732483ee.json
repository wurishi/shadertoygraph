{"ver":"0.1","info":{"id":"tlBcDK","date":"1595453861","viewed":325,"name":"simple soft shadow","username":"x33ch0u","description":"soft shadow of objects","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","shadow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define M_PI 3.141592653\n#define MAX_STEPS 100\n#define EPSILON 1e-3\n\nstruct Ray { vec3 o, d; };\n\n\n//we need a better ray function that can take camera pos, fov.\nRay getRay(vec2 uv, vec3 ori, vec3 dir, float len)\n{\n    dir = normalize(dir);\n    \n    vec3 right = normalize(cross(dir, vec3(0.0, 1.0, 0.0)));\n    vec3 up = normalize(cross(right, dir));\n    vec3 center = ori + dir * len;\n    vec3 intersect = center + right * uv.x + up * uv.y;    \n     \n    return Ray(ori, normalize(intersect-ori));  \t\n}\n\nfloat sphereSDF(vec3 p, float s)\n{    \n    return length(p) - s;\n}\n\n\nfloat floorSDF(vec3 p)\n{\n    return p.y;\n}\n\nfloat boxSDF(vec3 p, vec3 b)\n{\n    vec3 q = abs(p) - b;\n    //length(max(q, 0.0) represents the ouside of the distance\n    //min(0.0, maxcomp(q)) represents the inner of distance.    \n    return length(max(q,0.0)) + min(0.0, max(q.x,max(q.y,q.z)));\n}\n\nfloat sceneSDF(vec3 p)\n{\n    //return sphereSDF(p - vec3(-10.0, 0.0, -20.0), 4.0);\n    return min(floorSDF(p - vec3(0.0, -0.0, 0.0)),\n               boxSDF(p - vec3(sin(iTime) * 3.0, 3.0, -5.0), \n                      vec3(1.0, 2.0, 1.0)));\n    vec3 qos = vec3( fract(p.x+0.5)-0.5, p.yz );\n    return min( floorSDF(p.xyz-vec3( 0.0,0.00, 0.0)),\n                boxSDF(qos.xyz-vec3( 0.0,0.25, -1.5), \n                       vec3(0.2,0.4,0.2) ) );\n    \n    \n}\n\nvec3 normal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*sceneSDF( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*sceneSDF( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*sceneSDF( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*sceneSDF( pos + e.xxx ) );\n}\n\n\nfloat rayMarching(in Ray ray, out vec3 p)\n{\n    //a tradtional ray marching method\n\tfloat dist, depth = 0.0;\n    const float dfar = 500.0;      \n  \n    for (int i = 0; i < MAX_STEPS; i++) {\n\t\tp = ray.o + ray.d * depth;\n        dist = sceneSDF(p);\n        if (dist < EPSILON)\n            return dist;\n        depth += dist;\n        if (depth > dfar)\n            return dfar;\n    }       \n    return dfar;\n}\n\n\nfloat shadow(vec3 p, vec3 lo, float k)\n{\n    vec3 d = normalize(lo-p);\n    float mint = 0.1, maxt = length(lo-p);  \n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 30; i++) {\n        float h = sceneSDF(p+t*d);\n        res = min(res, k * h / t);\n        t += h;    \n        if (res < EPSILON || t > maxt)\n            return res;\n    }    \n    return res;\n}\n\nfloat AO(vec3 pos, vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        float d = sceneSDF( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\n\n\nfloat lighting(vec3 p)\n{\n    vec3 n = normal(p);\n\tvec3 lightPos = vec3(7.0, 10.0, 0.0);\n    vec3 lightDir = normalize(lightPos - p);\n    \n    float amb = AO(p, n);\n    float intensity = max(0.0, dot(lightDir, n));\n    \n    return shadow(p, lightPos, 8.0) * intensity + amb * 0.2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec3 col;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 origin = vec3(-3.0, 2.0, 1.0);\n    vec3 dir = vec3(-0.0, 0.0, -1.0);\n    Ray ray = getRay(uv, origin, dir, 1.0);\n    vec3 p;\n    \n    float dist = rayMarching(ray, p);\n    if (dist >= 500.0) {\n    \tcol = vec3(0.0);    \n    } else {\n    \tcol = vec3(lighting(p));    \n    }        \n\t    \n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}