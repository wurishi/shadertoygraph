{"ver":"0.1","info":{"id":"XtjGzc","date":"1430995649","viewed":205,"name":"a_raytracer_test","username":"AmbBAI","description":"yes, raytracer.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"        const int MAX_REFLECT = 5;\n        const vec3 black = vec3(0.,0.,0.);\n        const vec3 white = vec3(1.,1.,1.);\n        const vec3 red = vec3(1.,0.,0.);\n        const vec3 blue = vec3(0.,0.,1.);\n\n        struct Ray {\n            vec3 origin;\n            vec3 direction;\n        };\n\n        struct Light {\n            int type;\n \n            vec3 position;\n            vec3 direction;\n            float range;\n\n            vec3 color;\n            float intensity;\n        };\n\n        struct Sphere {\n            vec3 center;\n            float radius;\n\n            int material;\n            vec3 color;\n            float reflectiveness;\n        };\n\n        struct Plane {\n            vec3 normal;\n            float distance;\n\n            int material;\n            vec3 color;\n            float reflectiveness;\n        };\n        \n        struct IntersectionResult {\n            float distance;\n            vec3 position;\n            vec3 normal;\n\n            int material;\n            vec3 color;\n            float reflectiveness;\n        };\n\n        vec3 theEye = vec3(0, 0, 0);\n        \n        Light theLight = Light(3, vec3(5.,5.,0.), normalize(vec3(-5.,-7.,5.)), 50., white, 1.);\n        //Light theLight = Light(2, vec3(0.,5.,5.), normalize(vec3(0.,-1.,0.)), 50., white, 1.);\n\n        float spotLightCosHalfPhi = cos(radians(60.));\n        float spotLightCosHalfTheta = cos(radians(10.));\n        float spotLightFalloff = 2.;\n\n\n        Sphere redSphere = Sphere(vec3(-2.5, 0, 5), 2., 11, red, 0.25);\n        Sphere blueSphere = Sphere(vec3(2.5, 0, 5), 2., 11, blue, 0.25);\n        Plane thePlane = Plane(vec3(0.,1.,0.), -2., 1, white, 0.5);\n\n        vec3 specColor = white;\n        float shininess = 10.;\n\n\n        IntersectionResult minIntersection(IntersectionResult a, IntersectionResult b)\n        {\n            if (a.distance < 0.) return b;\n            if (b.distance < 0.) return a;\n           \tif (a.distance < b.distance) return a; else return b;\n        }\n\n        float intersectPlane(Ray ray, Plane plane) {\n            float a = dot(ray.direction, plane.normal);\n            if (a >= 0.0) return -1.;\n            \n            vec3 position = plane.normal * plane.distance;\n            float b = dot(plane.normal, ray.origin - position);\n            if (b <= 0.0) return -1.;\n            \n            return -b / a;\n        }\n\n        float intersectSphere(Ray ray, Sphere sphere) {\n            vec3 co = ray.origin - sphere.center;\n            float discriminant = dot(co, ray.direction) * dot(co, ray.direction)\n                    - (dot(co, co) - sphere.radius * sphere.radius);\n\n            if (discriminant >= 0.0)\n                return -dot(ray.direction, co) - sqrt(discriminant);\n            else\n                return -1.;\n        }\n\n        IntersectionResult intersectScene(Ray ray)\n        {\n            float dis = -1.;\n\n            dis = intersectSphere(ray, redSphere);\n            IntersectionResult redSphereIntersection;\n            redSphereIntersection.distance = dis;\n            if (dis >= 0.)\n            {\n                redSphereIntersection.position = ray.origin + redSphereIntersection.distance * ray.direction;\n                redSphereIntersection.normal = normalize(redSphereIntersection.position - redSphere.center);\n                redSphereIntersection.material = redSphere.material;\n                redSphereIntersection.color = redSphere.color;\n                redSphereIntersection.reflectiveness = redSphere.reflectiveness;\n            }\n\n            dis = intersectSphere(ray, blueSphere);\n            IntersectionResult blueSphereIntersection;\n            blueSphereIntersection.distance = dis;\n            if (dis >= 0.)\n            {\n                blueSphereIntersection.position = ray.origin + blueSphereIntersection.distance * ray.direction;\n                blueSphereIntersection.normal = normalize(blueSphereIntersection.position - blueSphere.center);\n                blueSphereIntersection.material = blueSphere.material;\n                blueSphereIntersection.color = blueSphere.color;\n                blueSphereIntersection.reflectiveness = blueSphere.reflectiveness;\n            }\n\n            dis = intersectPlane(ray, thePlane);\n            IntersectionResult planeIntersection;\n            planeIntersection.distance = dis;\n            if (dis >= 0.)\n            {\n                planeIntersection.position = ray.origin + planeIntersection.distance * ray.direction;\n                planeIntersection.normal = thePlane.normal;\n                planeIntersection.material = thePlane.material;\n                planeIntersection.color = thePlane.color;\n                planeIntersection.reflectiveness = thePlane.reflectiveness;\n            }\n\n            IntersectionResult ret = minIntersection(redSphereIntersection, blueSphereIntersection);\n            ret = minIntersection(planeIntersection, ret);\n            return ret;\n        }\n\n        float calcShadow(vec3 position, vec3 lightDir)\n        {\n            Ray shadowRay = Ray(position, lightDir);\n            IntersectionResult ret = intersectScene(shadowRay);\n            if (ret.distance >= 0.) return 0.;\n            else return 1.;\n        }\n\n        void calcLight(out vec3 lightDir, out vec3 lightColor, vec3 position)\n        {\n            float intensity = theLight.intensity;\n            if (theLight.type == 1)\n            {\n                lightDir = -theLight.direction;\n                lightColor = theLight.color * intensity;\n            }\n            else if (theLight.type == 2 || theLight.type == 3)\n            {\n                lightDir = theLight.position - position;\n                float distance = length(lightDir);\n                lightDir /= distance;\n\n                float atten = theLight.range / (0.5 * distance * distance + 2. * distance + 1.);\n\n                if (theLight.type == 3)\n                {\n                    float rio = dot(-theLight.direction, lightDir);\n                    float factor = 1.;\n                    if (rio <= spotLightCosHalfPhi) factor = 0.;\n                    else if (rio > spotLightCosHalfTheta) factor = 1.;\n                    else\n                    {\n                        factor = (rio - spotLightCosHalfPhi) / (spotLightCosHalfTheta - spotLightCosHalfPhi);\n                        factor = clamp(pow(factor, spotLightFalloff), 0., 1.);\n                    }\n                    intensity *= factor;\n                }\n\n                lightColor = theLight.color * (intensity * atten);\n            }\n\n            lightColor *= calcShadow(position, lightDir);\n        }\n\n        vec3 calcColor(int material, vec3 position, vec3 normal, vec3 color)\n        {\n            if (material == 0) return black;\n\n            vec3 lightDir;\n            vec3 lightColor;\n            calcLight(lightDir, lightColor, position);\n\n            if (material == 1)\n            {\n                float tmp = abs(floor(position.x * 1.) + floor(position.z * 1.));\n                return ((mod(tmp, 2.) < 1.) ? black : white) * lightColor;\n            }\n            else if (material == 2)\n            {\n                vec2 texCoord = vec2(position.x * 0.2, position.z * 0.2);\n                return texture(iChannel0, texCoord).xyz * lightColor;\n            }\n            else if (material == 10)\n            {\n                return color * (max(0.0, dot(normal, lightDir)) * .8 + .2) * lightColor;\n            }\n            else if (material == 11)\n            {\n                float lambertian = max(0.0, dot(normal, lightDir));\n                float specular = 0.0;\n                if (lambertian > 0.0)\n                {\n                    vec3 reflectDir = normalize(normal * dot(normal, lightDir) * 2. - lightDir);\n                    float specAngle = max(dot(reflectDir, normalize(theEye - position)), 0.);\n                    specular = pow(specAngle, shininess);\n                }\n                \n                return (color * lambertian + specColor * specular) * lightColor;\n            }\n            else if (material == 12)\n            {\n                float lambertian = max(0.0, dot(normal, lightDir));\n                float specular = 0.0;\n                if (lambertian > 0.0)\n                {\n                    vec3 halfDir = normalize(lightDir + normalize(theEye - position));\n                    float specAngle = max(dot(halfDir, normal), 0.);\n                    specular = pow(specAngle, shininess * 4.);\n                }\n                \n                return (color * lambertian + specColor * specular) * lightColor;\n            }\n            return black;\n        }\n\n        vec3 rayTrace(Ray ray)\n        {\n            vec3 color = black;\n            float reflectiveness = 1.0;\n            for (int i=0; i<MAX_REFLECT; ++i)\n            {\n                IntersectionResult ret = intersectScene(ray);\n                if (ret.distance >= 0.)\n                {\n                    vec3 sampleColor = calcColor(ret.material, ret.position, ret.normal, ret.color);\n                    color += sampleColor * (1. - ret.reflectiveness) * reflectiveness;\n                    reflectiveness *= ret.reflectiveness;\n\n                    if (reflectiveness > 0.)\n                    {\n                        vec3 reflectDir = normalize(ret.normal * (-2. * dot(ret.normal, ray.direction)) + ray.direction);\n                        ray = Ray(ret.position, reflectDir);\n                    }\n                    else break;\n                }\n                else break;\n            }\n            return color;\n        }\n\n        void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n            float posPixelX = fragCoord.x / iResolution.x * 2.0 - 1.0;\n            float posPixelY = fragCoord.y / iResolution.y * 2.0 - 1.0;\n            float radio = iResolution.x / iResolution.y;\n\n            theEye = vec3(sin(iTime*0.2) * 0.2, sin(iTime*0.3) * 0.2, -1.);\n            vec3 rayDir = normalize(vec3(posPixelX * radio, posPixelY, 0) - theEye);\n            Ray theRay = Ray(theEye, rayDir);\n\n            fragColor.xyz = rayTrace(theRay);\n        }","name":"Image","description":"","type":"image"}]}