{"ver":"0.1","info":{"id":"NtXGRH","date":"1621484859","viewed":98,"name":"SDF chopper","username":"shyuriken","description":"joetech's \"SDF Editor\" is prototype. There are still few functions, but it can be designed visually.\nI made a converter  form \"SDF Editor output\" to shadertoy code.\nhttps://github.com/ultrahamlet/cnvSDF2","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","modeling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Adapted from original shader: https://www.shadertoy.com/view/ldcyW4\n// modeled by https://joetech.itch.io/sdf-editor\n// converted by https://github.com/ultrahamlet/cnvSDF2\n//----------------------------------------------------------------\n// Processed by 'GLSL Shader Shrinker' (Shrunk by 1,985 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n#define LIGHT\tnormalize(vec3(1, 1, 0))\n\nmat3 rotateMat(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle),\n\t      c = cos(angle),\n\t      r = 1. - c;\n\treturn mat3(a.x * a.x * r + c, a.y * a.x * r + a.z * s, a.z * a.x * r - a.y * s, a.x * a.y * r - a.z * s, a.y * a.y * r + c, a.z * a.y * r + a.x * s, a.x * a.z * r + a.y * s, a.y * a.z * r - a.x * s, a.z * a.z * r + c);\n}\n\nvec3 mTranslation(vec3 inv_translation, vec3 p) { return p + inv_translation; }\n\nvec3 mRotation(mat3 inv_rotation, vec3 p) { return inv_rotation * p; }\n\nfloat pEllipsoid(vec3 r, vec3 p) {\n\tfloat k0 = length(p / r);\n\treturn k0 * (k0 - 1.) / length(p / (r * r));\n}\n\nfloat oUnion(float d1, float d2) { return min(d1, d2); }\n\nfloat sdf(vec3 p0) {\n\tfloat d2, d3, d4, d5, d6, d7, d8,\n\t      d1 = pEllipsoid(vec3(2), p0);\n\t{\n\t\tvec3 p1 = mTranslation(vec3(-3, -1, 0), p0);\n\t\t{ d2 = pEllipsoid(vec3(4, 1, .5), mRotation(mat3(.96592583, -.25881905, 0, .25881905, .96592583, 0, 0, 0, 1), p1)); }\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(vec3(-7, -2, -.3), p0);\n\t\t{ d3 = pEllipsoid(vec3(.9, .9, .1), mRotation(mat3(1, 0, 0, 0, 1, 0, 0, 0, 1), p1)); }\n\t}\n\t{\n\t\tvec3 p1 = mTranslation(vec3(0, -2.6, 0), p0);\n\t\t{\n\t\t\tmat3 mt = rotateMat(p1, iTime, vec3(0, 1, 0));\n\t\t\tvec3 p2 = mRotation(mt, p1);\n\t\t\td4 = pEllipsoid(vec3(5, .1, .2), p2);\n\t\t\td5 = pEllipsoid(vec3(.2, .1, 5), p2);\n\t\t}\n\t}\n\t{ d6 = pEllipsoid(vec3(.2, 2, .2), mTranslation(vec3(0, -1.1, 0), p0)); }\n\t{ d7 = pEllipsoid(vec3(2, .6, .6), mTranslation(vec3(0, .9, -1.8), p0)); }\n\t{ d8 = pEllipsoid(vec3(2, .6, .6), mTranslation(vec3(0, .9, 1.8), p0)); }\n\treturn oUnion(d1, oUnion(d2, oUnion(d3, oUnion(d5, oUnion(d4, oUnion(d6, oUnion(d7, d8)))))));\n}\n\nvec3 RayMarch(vec3 rayDir, vec3 cameraOrigin) {\n\tfloat dist = .01,\n\t      totalDist = 0.,\n\t      itter = 0.;\n\tvec3 pos = cameraOrigin;\n\tfor (int i = 0; i < 128; i++) {\n\t\tdist = sdf(pos);\n\t\titter++;\n\t\ttotalDist += dist;\n\t\tpos += dist * rayDir;\n\t\tif (dist < .01 || totalDist > 30.) break;\n\t}\n\n\treturn vec3(dist, totalDist, itter / 128.);\n}\n\nfloat AO(vec3 pos, vec3 n) {\n\tfloat res = 0.;\n\tvec3 aopos = pos;\n\tfor (int i = 0; i < 3; i++) {\n\t\taopos = pos + n * .2 * float(i);\n\t\tfloat d = sdf(aopos);\n\t\tres += d;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\nmat3 SetCamera(vec3 ro, vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro),\n\t     cu = normalize(cross(cw, vec3(sin(cr), cos(cr), 0)));\n\treturn mat3(cu, normalize(cross(cu, cw)), cw);\n}\n\nvec4 NorCurv(vec3 p) {\n\tconst vec2 e = vec2(-.01, .01);\n\tfloat t1 = sdf(p + e.yxx),\n\t      t2 = sdf(p + e.xxy),\n\t      t3 = sdf(p + e.xyx),\n\t      t4 = sdf(p + e.yyy);\n\treturn vec4(normalize(e.yxx * t1 + e.xxy * t2 + e.xyx * t3 + e.yyy * t4), .25 / e.y * (t1 + t2 + t3 + t4 - 4. * sdf(p)));\n}\n\nvec3 Lighting(vec3 n, vec3 rayDir, vec3 reflectDir, vec3 pos) { return vec3(max(0., dot(LIGHT, n)), pow(max(0., dot(reflectDir, LIGHT)), 10.), 1. - max(0., dot(-n, rayDir))) * .5; }\n\nfloat TriplanarTexture(vec3 pos, vec3 n) { return 0.; }\n\nfloat BackGround(vec3 rayDir) { return smoothstep(1., 0., clamp(length(rayDir - LIGHT), 0., 1.)) * .5; }\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 cameraOrigin = vec3(0);\n\tif (iMouse.z > 0.) {\n\t\tcameraOrigin.x = sin(iMouse.x * .01) * 5.;\n\t\tcameraOrigin.y = iMouse.y * .05 - 10.;\n\t\tcameraOrigin.z = cos(iMouse.x * .01) * 5.;\n\t}\n\telse {\n\t\tcameraOrigin.x = sin(iTime * .25 + 2.) * (6. + sin(iTime * .1));\n\t\tcameraOrigin.y = sin(iTime * .3) - .5;\n\t\tcameraOrigin.z = cos(iTime * .25 + 2.) * (6. + sin(iTime * .15)) - 15.;\n\t}\n\n\tvec2 screenPos = uv * 2. - 1.;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\tmat3 cam = SetCamera(cameraOrigin, vec3(0, .25, -1), sin(iTime * .15) * .5);\n\tvec3 rayDir = cam * normalize(vec3(screenPos, 2)),\n\t     dist = RayMarch(rayDir, cameraOrigin);\n\tfloat res,\n\t      backGround = BackGround(rayDir);\n\tif (dist.x < .01) {\n\t\tvec3 l,\n\t\t     pos = cameraOrigin + dist.y * rayDir;\n\t\tvec4 n = NorCurv(pos);\n\t\tfloat col,\n\t\t      ao = AO(pos, n.xyz);\n\t\tl = Lighting(n.xyz, rayDir, reflect(rayDir, n.xyz), pos);\n\t\tcol = TriplanarTexture(pos, n.xyz);\n\t\tcol *= n.w * .5 + .5;\n\t\tcol *= ao;\n\t\tcol += ao * (l.x + l.y);\n\t\tcol += l.z * .75;\n\t\tcol += BackGround(n.xyz) * .25;\n\t\tres = col;\n\t}\n\telse res = backGround;\n\n\tfragColor = vec4(vec3(res), 1);\n}","name":"Image","description":"","type":"image"}]}