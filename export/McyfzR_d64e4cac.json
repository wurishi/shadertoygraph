{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"cubemap","id":"4sX3zn","filepath":"/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png","sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//INSPIRATION: https://bsky.app/profile/mamassian.bsky.social/post/3lcs2pyniwk2k\n//https://hal.science/hal-03984071/\n\n#define SHADOW_RADI 0.8\n#define SHADOW_X 0.7\n#define SHADOW_Z -0.4\n#define SHADOW_INTENS 0.9\n#define SHADOW_SOFTNESS 1.0\n#define CAM_ANGLE 2.0 \n#define CAM_ZOOM 7.0\n#define STOP_TIME 3.0\n#define ORBIT_TIME 5.0\n#define CYCLE_TIME (STOP_TIME + ORBIT_TIME)\n#define BASE_HEIGHT 0.5\n#define REFLECTION_STRENGTH 3.3\n#define CAM_GROUND 1.7 //this seems important on illusion so I added\n\nmat2 rot2D(float a) { float s = sin(a), c = cos(a); return mat2(c, -s, s, c); }\nfloat bal(vec3 p, float r) { return length(p) - r; }\nfloat plane(vec3 p) { return p.y; }\nfloat hash(vec2 p) {\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);\n}\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 3.0 * f);\n    return mix(\n        mix(hash(i), hash(i + vec2(1.0, 0.0)), f.x),\n        mix(hash(i + vec2(0.0, 1.0)), hash(i + vec2(1.0, 1.0)), f.x),\n        f.y\n    );\n}\nvec3 wod(vec2 p) {\n    float gr = noise(p * 8.0);\n    float r = sin(length(p) * 3.0 + gr * 2.0) * 0.5 + 0.5;\n    vec3 d = vec3(0.25, 0.12, 0.08);\n    vec3 lw = vec3(0.45, 0.25, 0.15);\n    return mix(d, lw, r);\n}\n\nvec3 enmap(vec3 rd) {\n    vec3 col = texture(iChannel0, rd).rgb;\n    return col;\n}\n\nvec3 sky(vec3 rd) {\n    return enmap(rd);\n}\n\nfloat map(vec3 p) {\n    vec3 ballPos = vec3(0.0, BASE_HEIGHT, 0.0);\n    return min(plane(p), bal(p - ballPos, 0.5));\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float d = 0.0;   \n    float t = 0.0;\n    const float MAX_DIST = 100.1;\n    const float PRECISION = 0.001;\n    const int MAX_STEPS = 128;\n    for(int i = 0; i < MAX_STEPS; i++) {\n        d = map(ro + rd * t);\n        if(d < PRECISION) return t;\n        if(t > MAX_DIST) return MAX_DIST;\n        t += d * 0.9;\n    }\n    \n    return MAX_DIST;\n}\nvec3 normal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    float d = map(p);\n    vec3 n = d - vec3(\n        map(p - e.xyy),\n        map(p - e.yxy),\n        map(p - e.yyx));\n    return normalize(n);\n}\n\nfloat shadow(vec2 p) {\n    float d = length(p - vec2(SHADOW_X, SHADOW_Z));\n    return mix(1.0 - SHADOW_INTENS, 1.0, \n              smoothstep(0.0, SHADOW_RADI * SHADOW_SOFTNESS, d));\n}\n\nfloat angl(float time) {\n    float cPerT = mod(time, CYCLE_TIME);\n    if(cPerT < STOP_TIME) {\n        return CAM_ANGLE;\n    }\n    float orbitp = (cPerT - STOP_TIME) / ORBIT_TIME;\n    float orbitA = 2.0 * 3.14159 * orbitp;\n    return CAM_ANGLE + orbitA;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = 0.5*(fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float angle = iMouse.z > 0.0 ? -6.28318 * (iMouse.x / iResolution.x) \n                                : angl(iTime);\n    vec3 ro = vec3(CAM_ZOOM * sin(angle),CAM_GROUND, CAM_ZOOM * cos(angle));\n    vec3 lookAt = vec3(0, 0.3, 0);\n    vec3 f = normalize(lookAt - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 rd = normalize(f + r * uv.x + cross(f, r) * uv.y);\n    \n    float d = march(ro, rd);\n    vec3 p = ro + rd * d;\n    vec3 n = normal(p);\n    vec3 col;\n    \n    if(d > 100.0) {\n        col = sky(rd);\n    } else if(p.y < 0.001) {\n        vec2 tableUV = p.xz / 4.0;\n        float checker = mod(floor(tableUV.x) + floor(tableUV.y), 2.0);\n        vec3 woodCol = wod(tableUV);\n        vec3 daksq = woodCol * 0.3;\n        vec3 lsq = woodCol * 1.2;\n        col = mix(daksq, lsq, checker);\n        \n        vec3 reflect = enmap(reflect(rd, n));\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 5.0);\n        col = mix(col, reflect, fresnel * REFLECTION_STRENGTH);\n        col *= shadow(p.xz) * (1.0 - smoothstep(5.0, 20.0, length(p.xz)));\n        float vignette = 1.0 - length(p.xz) * 0.05;\n        col *= max(0.0, vignette);\n    } else {\n        vec3 balc = vec3(0.7, 0.3, 0.2);\n        vec3 l = normalize(vec3(0, 1, 0));\n        float diff = dot(n, l) * 0.6 + 0.6;\n        \n        vec3 reflection = enmap(reflect(rd, n));\n        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 3.0);\n        \n        col = balc * diff;\n        col = mix(col, reflection, fresnel * 0.5);\n        float spec = pow(max(dot(reflect(rd, n), l), 0.0), 32.0);\n        col += vec3(0.5) * spec;\n    }\n    \n    col = pow(col, vec3(0.4545));\n    col = mix(col, col * col * (3.0 - 2.0 * col), 0.2); \n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"McyfzR","date":"1733680917","viewed":59,"name":"Cast Shadow illusion","username":"altunenes","description":"tried to reproduce this illusion with raymarching. on my perception, the ball seems to be in the air. Try it with your mouse or play with the shadow defs maybe work better :-)\ninspiration:\nhttps://bsky.app/profile/mamassian.bsky.social/post/3lcs2pyniwk2k","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["illusion","vision","perception"],"hasliked":0,"parentid":"","parentname":""}}