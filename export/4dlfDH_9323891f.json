{"ver":"0.1","info":{"id":"4dlfDH","date":"1496022628","viewed":249,"name":"Book of Shaders Notes 1","username":"psygnisfive","description":"This is an implementation of the first two shaders found in Book of Shaders Ch. 5, intended as notes to help understand what they do, how, and what the techniques are for achieving the effect.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["bookofshaders"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//*\n\n\n// The simplePlot function is used to draw a curve. The general way it functions is\n// as a kind of boolean predicate function to decide if a y coordinate of a point in\n// space is \"on\" the curve to be drawn. The first argument is the y coordinate of\n// the point we're rendering, and the second is the y coordinate of the curve. If\n// the render coordinate is above the target coordinate, then the function returns\n// true, or rather, 1.0, otherwise it returns false, or rather 0.0. These values\n// will then be used later to act as masks for compositing different images together.\n//\n// This particular function is not actually used in the example from the Book of\n// Shaders, but it's useful to have as a learning aid, because the principles used\n// here are related to the ones in the BoS example, but are simpler.\n\nfloat simplePlot(float renderY, float targetY) {\n    return renderY > targetY ? 1.0 : 0.0;\n}\n\n\n\n\n\n// The fadePlot function works similar to the simplePlot function, but rather than simply\n// doing a hard transition from the points below the target coordinate to the points\n// above it, we use a smooth step that gradually transitions. The target coordinate is\n// used to define the center of the transitional region, which is 0.04 units wide in total.\n\nfloat fadePlot(float renderY, float targetY) {\n    return smoothstep(targetY - 0.02, targetY + 0.02, renderY);\n}\n\n\n\n\n\n\n// The plot function is similar to the fadePlot function, but rather than returning a\n// value that represents whether or not the render coordinate is above the target\n// coordinate, we composite together two variants of the fadePlot using subtraction, to\n// create a region around the target coordinate. This has the effect of create a fuzzy\n// spot at the target coordinate position which acts as the plot of the coordinate.\n\nfloat plot(float renderY, float targetY) {\n    return smoothstep(targetY - 0.02, targetY, renderY) -\n           smoothstep(targetY, targetY + 0.02, renderY);\n}\n\n\n\n\n\n// The curve functions computes the y coordinate of the curve from the x coordinate.\n// For curve1, the equation is y(x) = x. For curve2, it's y(x) = x^5.\n\nfloat curve1(float x) {\n    return x;\n}\n\nfloat curve2(float x) {\n    return pow(x,5.0);\n}\n\n\n\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n \t\n    \n    // We want to think about the coordinate in terms of its fractional position\n    // in the shader's view, rather than in terms of its absolute position, so\n    // we'll normalize it by the resolution of the shader's view.\n    \n    vec2 fractionalCoordXY = fragCoord.xy/iResolution.xy;\n    \n    \n    \n    // The background gradient in the example is created by setting the color of the\n    // x coordinate of the position being rendered. We use that uniformly for each\n    // color value to make a greyscale gradient.\n    \n    vec3 backgroundGradient = vec3(fractionalCoordXY.x);\n    \n    \n    \n    // These are demos to be used for understanding the utility functions.\n    \n    //vec3 color = backgroundGradient;\n    //vec3 color = vec3(simplePlot(fractionalCoordXY.y, fractionalCoordXY.x));\n    //vec3 color = vec3(fadePlot(fractionalCoordXY.y, fractionalCoordXY.x));\n    //vec3 color = vec3(plot(fractionalCoordXY.y, fractionalCoordXY.x));\n    \n    \n    \n    // This is the actual rendering of the curve. We need a mask for the green\n    // curve itself, which will be just a plot of the function y(x) = x. We'll\n    // also need a mask for the gradient which is the inverted mask for the curve.\n    // We'll then composite together the green line (a masked off green color) with\n    // the masked gradient to produce the color of the current render point.\n    \n    vec3 maskForGreenLine = vec3(plot(fractionalCoordXY.y,\n                                      curve2(fractionalCoordXY.x)));\n    vec3 maskForGradient = vec3(1.0) - maskForGreenLine;\n    vec3 color = maskForGreenLine * vec3(0.0, 1.0, 0.0) +\n                 maskForGradient * backgroundGradient;\n    \n    \n    \n    \n    \n    // The fragColor requires alpha information as well, so we add that in.\n    \n    fragColor = vec4(color, 1.0);\n    \n}\n\n//*/\n\n\n\n\n/*\n\n// This is the original code as defined in the book of shaders, modulo some minor\n// formatting and naming issues related to using Shadertoy. This version is somewhat\n// hard to understand because the parts and their relation to one another are not\n// well-explained.\n\nfloat plot(vec2 st, float pct) {\n    \n    return smoothstep(pct - 0.02, pct, st.y) -\n           smoothstep(pct, pct + 0.02, st.y);\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \n    float y = st.x;\n    \n    vec3 color = vec3(y);\n    \n    \n    // Plot a line\n    float pct = plot(st,y);\n    color = (1.0 - pct)*color + pct*vec3(0.0, 1.0, 0.0);\n    \n    fragColor = vec4(color, 1.0);\n    \n}\n\n//*/","name":"Image","description":"","type":"image"}]}