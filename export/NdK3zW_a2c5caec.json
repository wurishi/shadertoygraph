{"ver":"0.1","info":{"id":"NdK3zW","date":"1631195707","viewed":291,"name":"First time messing with sound","username":"Peace","description":"MUSIC!","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["sound"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rn","filepath":"/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","previewfilepath":"/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159\n#define TWO_PI 6.28318\n#define LINE_WIDTH 12\n#define LINE_HEIGHT 200\n#define LINE_PLACE (LINE_WIDTH + LINE_OFFSET)\n#define LINE_OFFSET 4\n#define FREQ 512.0\n\nvec3 rectangle(int x, int y, int width, int height, ivec2 fragCoord)\n{\n    if(fragCoord.x >= x && fragCoord.y >= y && fragCoord.x <= x + width && fragCoord.y <= y + height)\n        return vec3(1);\n    return vec3(0);\n}\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nfloat frequency(int x)\n{\n    return texelFetch(iChannel0, ivec2(x, 0), 0).r;\n}\n\nfloat lerp4(const float[4] points, float inBetween) \n{ \n\tfloat scaledInBetween = inBetween * 3.0;\n\tfloat newInBetween = scaledInBetween - floor(scaledInBetween);\n\tfloat start = points[min(int(scaledInBetween), 3)];\n    float end = points[min(int(scaledInBetween + 1.0f), 3)];\n\treturn mix(start, end, newInBetween);\n}\n\nfloat smoothFrequency(int x, int smoothness)\n{\n    float f = 0.0;\n    int accumulated = 0;\n    for(int i = 0; i <= smoothness; ++i)\n    {\n        if(x + i > int(FREQ) || x + i < 0) continue;\n        f += frequency(x + i);\n        ++accumulated;\n    }\n    return f / float(accumulated);\n}\n \n\n// All components are in the range [0â€¦1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float d = FREQ / iResolution.x;\n    float f = iResolution.x / float(LINE_PLACE);\n    int numLines = int(f);\n    float multiplier = FREQ / f;\n\n    vec3 col = vec3(0);\n    int x = int(float(int(uv.x * f)) * multiplier);\n    float freq = smoothFrequency(x, int(float(LINE_PLACE) * d));\n    \n    int freqHeight = int(freq * float(LINE_HEIGHT));\n    \n    for(int i = 0; i <= numLines; ++i)\n    col += rectangle(i * LINE_PLACE, 0, LINE_WIDTH, freqHeight, ivec2(fragCoord));\n    \n    col *= hsv2rgb(vec3(float(x) / FREQ, 1.0, 1.0));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}