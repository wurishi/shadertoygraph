{"ver":"0.1","info":{"id":"7lBXWR","date":"1628273397","viewed":1358,"name":"Hexagonal spiral","username":"felipetovarhenao","description":"Reflecting hexagonal spiral, using shapers, modular distortion, and value quantization.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["spiral","sdfs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Author: Felipe Tovar-Henao [www.felipe-tovar-henao.com]\n    Description: Reflecting hexagonal spiral, using shapers, modular distortion, and value quantization.\n*/\n\n#define PI 3.14159265359\n#define u_time iTime\n#define u_resolution iResolution\n\nfloat quantize(in float x, in float d) {\n    return floor(x/d)*d;\n}\n\nfloat fold(in float x) {\n    return abs(mod(x+1.0,2.0)-1.0);\n}\n\nvec2 rotate2D(in vec2 vUV, in float theta) {\n    vec2 r = vec2(cos(theta), sin(theta));\n    return vUV * mat2(r.x, -r.y, r.y, r.x);\n}\n\nfloat relu_ramp(in float x, in float s) {\n    return floor(x) + clamp((max(1.0, s)*(fract(x) - 0.5)) + 0.5, 0.0, 1.0);\n}\n\nfloat cosine_ramp(in float x, in float s) {\n    float y = cos(fract(x)*3.14159265359);\n    return floor(x) + 0.5 - (0.5*pow(abs(y), 1.0/s)*sign(y));\n}\n\nfloat sine_ramp(in float x, in float s) {\n    float y = fract(x);\n    float h = abs(0.5 - (0.5/max(1.0, s*s)));\n    return floor(x) + y + h*sin(6.28318530718*y);\n}\n\nfloat bump_ramp(in float x, in float s) {\n    float y = fract(x);\n    return floor(x) + pow(y, exp(s*y));\n}\n\nfloat polygonSDF(in vec2 vUV, in int V) {\n    float N = max(1.0, float(V));\n    float rot = floor(N*(atan(-vUV.x,-vUV.y) / 6.28318530718 + 0.5));\n    float offset = 3.14159265359*(N+2.0)/(2.0*N);\n    float theta = (6.28318530718/N) * rot + offset;\n    float side = tan(3.14159265359/max(N, 3.0));\n    vUV *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    float scl = 0.5 * (float(N==2.0)*(0.25/sqrt(3.0)) + step(2.0,N)) / (step(1.0,N) + step(N, 2.0));\n    vec2 r = vec2(step(3.0, N), side) * scl;\n    vec2 P = abs(vUV)-r;\n    return length(max(vec2(0.0), P)) + min(0.0, max(P.x, P.y/side));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord.xy / u_resolution.xy;\n    vUV -= 0.5;\n    vUV.x *= u_resolution.x / u_resolution.y;\n\n    float r = polygonSDF(vUV * 1.5, 6)*20.0;\n    float res = fold(bump_ramp(u_time*0.1, 5.0)) / 1500.0;\n    float a = atan(vUV.x, vUV.y) / PI + (u_time*r*res);\n    float theta = relu_ramp((r + a - sine_ramp(u_time*0.1, 1.7)), 8.0);\n\n    vUV = rotate2D(vUV, quantize(fold(theta), 1.0) + u_time * 0.025);\n\n    float t = cosine_ramp(u_time*0.23, 1.5) + sine_ramp(-u_time*0.12, 4.0);\n\n    float vx = fold(fract(vUV.x+vUV.y - t*0.013));\n    float vy = fold(fract(vUV.y-vUV.x + t*0.023));\n\n    float qx = fract(vUV.x*3.13 + t*0.131);\n    float qy = fract(vUV.y*2.329 - t*0.151);\n    float lim = 0.1;\n    float mx = fold(quantize(vx, max(lim, qx) + lim));\n    float my = fold(quantize(vy, max(lim, qy) + lim));\n    float x = mod(vx, mx);\n    float y = mod(vy, my);\n\n    vec3 color = vec3(0.0);\n\n    float c = abs(fold(x*y*2.0));\n    c = quantize(sqrt(c), 0.2) * fold(quantize(theta+a, 0.125));\n\n    vec3 c1a = vec3(0.502, 0.4863, 0.4118) * sin(sine_ramp(u_time*0.25, 4.0))*0.5 + 0.5;\n    vec3 c1b = vec3(0.302, 0.4549, 0.5333);\n    vec3 c2a = vec3(0.102, 0.0863, 0.0863);\n    vec3 c2b = vec3(0.1412, 0.1725, 0.1882);\n\n    color += clamp(c, 0.0, 1.0) * mix(c1a, c1b, fold(theta*3.0));\n    vec3 shadow= clamp(1.0-color, 0.0, 1.0) * mix(c2a, c2b, fold(theta*4.32));\n    color = clamp(color-shadow, 0.0, 1.0) + shadow + color;\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}