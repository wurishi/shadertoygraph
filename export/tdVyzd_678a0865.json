{"ver":"0.1","info":{"id":"tdVyzd","date":"1603550646","viewed":132,"name":"first 2d basic-v2","username":"jorge2017a1","description":"first 2d basic-v2","likes":1,"published":1,"flags":8,"usePreview":0,"tags":["first2dbasicv2"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define saturate(x) clamp(x, 0.0, 1.0)\nconst float LineWidth=0.01;\n\n\n\n\n//https://www.shadertoy.com/view/4djSRW\n//  1 out, 1 in...  Creado por Dave_Hoskins\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat hash1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    //float k = hash(uint(i));\n\n    float k = hash11(i);\n    \n    //float k = 0.5+0.5*sin(i);\n   //float k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    //uint  i = uint(floor(p));\n    float  i = (floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    //float g0 = hash(i+0u)*2.0-1.0;\n    float g0 = hash11(i)*2.0-1.0;\n    \n    //float g1 = hash(i+1u)*2.0-1.0;\n\tfloat g1 = hash11(i)*2.0-1.0;\n    \n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\n////////////////////////////////////\n\nfloat fbm( in float x )\n{    \n    float n = 0.0;\n    float s = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        n += s*bnoise(x);\n        s *= 0.5;\n        x *= 2.0;\n        x += 0.131;\n    }\n    return n;\n}\n\n\nfloat DistToLine(vec2 p, vec2 a, vec2 b)\n{\n        vec2 pa = p - a;\n        vec2 ba = b - a;\n        \n        float frac = saturate(dot(pa, ba) / dot(ba, ba));\n        \n        return length(pa - (ba * frac));\n}\n\nfloat Sharpen(float dist, float thickness, float blur)\n{\n    float r = (1.0 / min(800.0, 600.0)) * blur;\n\treturn smoothstep(r, -r, dist - thickness);\n}\n\nfloat Line(vec2 a, vec2 b, vec2 uv)\n{\n        return Sharpen(DistToLine(uv.xy, a, b), LineWidth, 1.0);\n}\n\n\nvec4 mountains(vec2 uv)\n{\n    uv.y -= .12;\n    vec3 col = vec3(0);\n    float a = 0.;\n    float snow = 0.;\n    \n    for(float i = 0.; i < 1.; i++){ \n        uv.x += iTime*.35;\n        \n        //float ht = texture(iChannel0, uv*16.).x;\n        float ht =0.5;\n        \n        float nse = cos(uv.x*14. + i*345.)*.01 + cos(uv.x*44. + i*123.)*.003\n            + cos(uv.x*2. + i*654.)*.01;\n        \n        //nse=fbm(nse);\n        \n        vec2 p = uv + nse;\n        float t = (1.3-i*.02)*p.x*.8 + i*9.;\n        float h = .06*asin(sin(6.*t + 2.5*i)*0.999);\n        float c = ss(.104,.1, p.y - h - i*.01 + .02);\n    \ta = mix(a, 1., c);\n        \n    \tcol = mix(col, mix(vec3(.2, .23, .3),1.3*vec3(0.13, 0.26, 0.18),i), c);\n        col +=ht*.06;\n    \tsnow = ss(.66, .674, (uv.y + 0.522)+nse*1.84);\n    \tcol = mix(col, vec3(1.0), snow); \n    }\n    return vec4(col, a);\n}\n\nvec4 mountainsv2(vec2 uv, vec3 pcolor)\n{\n    uv.y -= .12;\n    vec3 col = vec3(0);\n    float a = 0.;\n    float snow = 0.;\n    \n    \n    \n    for(float i = 0.; i < 1.; i++){ \n        uv.x += iTime*.35;\n        \n        //float ht = texture(iChannel0, uv*16.).x;\n        float ht =0.5;\n        \n        float nse = cos(uv.x*14. + i*345.)*.01 + cos(uv.x*44. + i*123.)*.003\n            + cos(uv.x*2. + i*654.)*.01;\n        \n        nse=fbm(nse);\n        \n        vec2 p = uv + nse;\n        float t = (1.3-i*.02)*p.x*.8 + i*9.;\n        float h = .06*asin(sin(6.*t + 2.5*i)*0.999);\n        float c = ss(.104,.1, p.y - h - i*.01 + .02);\n    \ta = mix(a, 1., c);\n        \n    \tcol = mix(col, pcolor, c);\n        col +=ht*.06;\n    \t\n        snow = ss(.66, .674, (uv.y + 0.522)+nse*1.84);\n    \tcol = mix(col, vec3(1.0), snow); \n    }\n    return vec4(col, a);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col=vec3(0.2,0.478,.13);\n    \n     vec2 p = (2.*fragCoord-R)/R.y;\n    \n\n    vec2 ap= abs(p);\n    p.y-=.25;\n    vec2 mp = vec2(abs(p.x),p.y);\n    \n      // Mountains\n    vec4 mnt = mountains(p);\n    col = mix(col, mnt.rgb, mnt.a);\n    \n    vec4 mnt2 = mountainsv2(p-vec2(0.0,-0.2),vec3(0.4));\n    col = mix(col, mnt2.rgb, mnt2.a);\n\n    vec4 mnt3 = mountainsv2(p-vec2(0.0,-0.4),vec3(0.6));\n    //col = mix(col, mnt3.rgb, mnt3.a);\n    \n    \n    p.x+=1.0*sin(iTime);\n    \n    float sp11A = circ(p-vec2(.23,-.27),.165);\n    float sdb1=box( p-vec2(0.0,0.0), vec2(0.4,0.2)); //grande\n    float sdb2=box( p-vec2(-0.25,0.12), vec2(0.1,0.06)); //ladrillos\n    float sdb3=box( p-vec2( 0.0,0.12), vec2(0.1,0.06));\n    float sdb4=box( p-vec2( 0.25,0.12), vec2(0.1,0.06));\n    \n    float sdb5=box( p-vec2( 0.25,-0.1), vec2(0.1,0.06));\n    float sdb5h1=box( p-vec2( 0.26,-0.05), vec2(0.09,0.01));\n    float sdb5v1=box( p-vec2( 0.16,-0.1), vec2(0.01,0.06));\n    \n    float sdb5h2=box( p-vec2( 0.26,-0.155), vec2(0.08,0.005));\n    float sdb5v2=box( p-vec2( 0.34,-0.11), vec2(0.01,0.036));\n    \n    \n    float sp11=circ(p-vec2(.23,-.27),.045);\n    \n    float sp12A = circ(p-vec2(-0.23,-.27),.165);\n    float sp12=   circ(p-vec2(-0.23,-.27),.045);\n    \n    \n    //piso \n    float sdb6=box( p-vec2( 0.0,-0.45), vec2(2.9,0.016));\n    \n    \n    \n        \n    sdb1 = SS(sdb1);\n    sdb2 = SS(sdb2);\n    sdb3 = SS(sdb3);\n    sdb4 = SS(sdb4);\n    \n    sp11A = SS(sp11A);\n    sp11 = SS(sp11);\n    \n    sp12A= SS(sp12A);\n    sp12 = SS(sp12);\n    \n    \n    sdb5 = SS(sdb5);\n    sdb5h1 = SS(sdb5h1);\n    sdb5v1 = SS(sdb5v1);\n    \n    sdb5h2 = SS(sdb5h2);\n    sdb5v2 = SS(sdb5v2);\n    \n    sdb6 = SS(sdb6);\n    \n    \n   // l1= SS(l1);    \n    \n    \n    col = mix(col, vec3(0.2,0.8,0.3), sp11A);\n    col = mix(col, vec3(1.0), sdb1);\n    col = mix(col, vec3(1.0,0.1,0.2), sdb2);\n    col = mix(col, vec3(1.0,0.1,0.2), sdb3);\n    col = mix(col, vec3(1.0,0.1,0.2), sdb4);\n    \n    col = mix(col, vec3(0.6,0.6,0.6), sdb5);\n    col = mix(col, vec3(0.8,0.8,0.8), sdb5h1);\n    col = mix(col, vec3(0.8,0.8,0.8), sdb5v1);\n    \n    col = mix(col, vec3(0.7,0.7,0.7), sdb5h2);\n    col = mix(col, vec3(0.7,0.7,0.7), sdb5v2);\n    \n    \n    \n    col = mix(col, vec3(0.5,0.5,0.2), sp11);\n    \n    col = mix(col, vec3(0.2,0.8,0.3), sp12A);\n    col = mix(col, vec3(0.5,0.5,0.2), sp12);\n    \n    \n    \n    col = mix(col, noiseFuego(uv, iTime), mnt3.a);\n    \n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Referencia  BC: Straw Hat Pirates\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\n\n#define SS(U) smoothstep(3./R.y,0.,U)\n\nfloat box(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat circ(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n///-----------------------NOISE--------------------------\n///-----------------------NOISE--------------------------\n///-----------------------NOISE--------------------------\nvec3 mod289(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t)\n{\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n\nvec3 noiseFuego(vec2 uv, float piTime)\n{\n  vec2 position = uv;\n  float noise = pnoise(vec3(position * vec2(30.0, 2.0) - vec2(0, piTime * 3.0), piTime / .50), vec3(100.0, 100.0, 100.0));\n\tnoise *= 2.;\n\tnoise += 1.2+sin(piTime)*0.5;\n\tnoise *=(1.0 - position.y);\n\tnoise = noise * noise * noise;\n\tvec3 fc = vec3(noise/2.0,noise / 3.4, noise / 5.0);\n    \n\t\n     return vec3(fc );\n}\n\n///-----------------------NOISE--------------------------\n///-----------------------NOISE--------------------------\n///-----------------------NOISE--------------------------\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[],"code":"//modificado por Jorge Flores... jorge2017a1\n// Referencia de Funciones Noise .....Inigo Quilez\n\n//https://www.shadertoy.com/view/4djSRW\n//  1 out, 1 in...  Creado por Dave_Hoskins\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nfloat hash1(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\n\n\n// Basic noise\nfloat bnoise( in float x )\n{\n    // setup    \n    float i = floor(x);\n    float f = fract(x);\n    float s = sign(fract(x/2.0)-0.5);\n    \n    // use some hash to create a random value k in [0..1] from i\n    //float k = hash(uint(i));\n\n    float k = hash11(i);\n    \n    //float k = 0.5+0.5*sin(i);\n  //float k = fract(i*.1731);\n\n    // quartic polynomial\n    return s*f*(f-1.0)*((16.0*k-4.0)*f*(f-1.0)-1.0);\n}\n\n// Traditional gradient noise\nfloat gnoise( in float p )\n{\n    //uint  i = uint(floor(p));\n    float  i = (floor(p));\n    float f = fract(p);\n\tfloat u = f*f*(3.0-2.0*f);\n\n    //float g0 = hash(i+0u)*2.0-1.0;\n    float g0 = hash11(i)*2.0-1.0;\n    \n    //float g1 = hash(i+1u)*2.0-1.0;\n\tfloat g1 = hash11(i)*2.0-1.0;\n    \n    return 2.4*mix( g0*(f-0.0), g1*(f-1.0), u);\n}\n\n////////////////////////////////////\n\nfloat fbm( in float x )\n{    \n    float n = 0.0;\n    float s = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        n += s*bnoise(x);\n        s *= 0.5;\n        x *= 2.0;\n        x += 0.131;\n    }\n    return n;\n}\n\nbool funcTime(float t1,float t2,float ptime )\n{\n    bool resp=false;\n    if(ptime>t1 &&  ptime<t2)\n \t{\n        resp=true;\n\t}    \n    return resp;\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    time=mod(time,26.0);\n    \n    float nota;\n    if (time<0.5)\n\t nota= fbm( sin(6.2831*440.0*time))*exp(-3.0*time) ;\n    else if(time>0.5 &&  time<1.0)\n     nota=fbm( sin(6.2831*220.0*time))*exp(-3.0*time) ;\n    else if(time>1.0 &&  time<1.5)\n         nota=20.0*fbm( sin(6.2831*120.0*time))*exp(-3.0*time) ;\n    else if(time>1.5 &&  time<2.0)\n         nota=20.0*fbm( sin(6.2831*600.0*time))*exp(-3.0*time) ;\n    else if(time>2.0 &&  time<10.0)\n \t{       \n         float tt=mod(time,0.5);\n         nota=1.0*fbm( sin(6.2831*120.0*tt))*exp(-3.0*tt) ;\n    }\n\telse if(time>10.0 &&  time<14.0)\n \t{       \n         float tt=mod(time,0.5);\n         nota=1.0*fbm( sin(6.2831*140.0*tt))*exp(-3.0*tt) ;\n    }\n    else if(funcTime(14.0 ,18.0, time) )\n \t{       \n         float tt=mod(time,0.5);\n         \n        nota=1.0*fbm( sin(6.2831*240.0*tt+sin(2.0* tt)) )*exp(-3.0*tt) ;\n        \n    }\n\n    else if(funcTime(18.0 ,22.0, time) )\n \t{       \n         float tt=mod(time,0.5);\n         \n        nota=1.0*fbm( sin(6.2831*240.0*tt) )*exp(-3.0*tt) ;\n\t\tnota+=1.0*fbm( sin(6.2831*340.0*tt) )*exp(-3.0*tt) ;\n        \n    }\n\telse if(funcTime(22.0 ,26.0, time) )\n \t{       \n         float tt=mod(time,0.5);\n         \n        nota=1.0*fbm( sin(6.2831*240.0*tt) )*exp(-3.0*tt) ;\n\t\tnota+=1.0*fbm( sin(6.2831*340.0*tt) )*exp(-3.0*tt) ;\n        nota+=1.0*fbm( sin(6.2831*440.0*tt) )*exp(-3.0*tt) ;\n        \n    }\n    \n    \n     return vec2(nota);\n    \n    \n}\n","name":"Sound","description":"","type":"sound"}]}