{"ver":"0.1","info":{"id":"ssKBRD","date":"1657805171","viewed":113,"name":"Cubic Solvers","username":"Envy24","description":"Based on this shader: https://www.shadertoy.com/view/fsB3Wt\nFormulas for factoring terms: https://www.desmos.com/calculator/uh9mtw2wiw\n\nOther implementatoins:\nhttps://www.shadertoy.com/view/flyGDD\nhttps://www.shadertoy.com/view/fsB3Wt","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["approximation","solver","cubic","newton","raphson","halley","numeric","secant","regulafalsi"],"hasliked":0,"parentid":"fdVBzD","parentname":"Quadratic solvers"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )                      // Aspect ratio (AR > 1.0).\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  6.0 / R.y  )\n#define SM(x)                     ( smoothstep(UNIT, 0., x) )\n#define LMB_IS_HOLD               ( iMouse.z > 0.0 )\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat x_axis(vec2 NDC) { return SM(abs(NDC.x)); }\nfloat y_axis(vec2 NDC) { return SM(abs(NDC.y)); }\nfloat cubic(vec2 NDC, float a, float b, float c, float d)\n{\n    float df   = NDC.y - (((a * NDC.x  + b) * NDC.x + c) * NDC.x + d),\n          dfdx = (3.0 * a * NDC.x + 2.0 * b) * NDC.x + c;\n    return SM(abs(df) / sqrt(1.0 + dfdx * dfdx));\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 NDC = \n        //LMB_IS_HOLD ?\n            //2.*TO_CENTERED_NDC(SC-(iMouse.xy-R.xy*0.5)) :\n            2.*TO_CENTERED_NDC(SC);\n\n    //float a = 0.8, b = 1.4, c = 0.8, d = 0.1;\n    float Time = iTime;\n    /* Cubic */\n    float a = sinOSC(-1.25, 1.25, Time * 0.15), b = sinOSC( -2.0,  2.0, Time * 0.6), \n          c = sinOSC( -1.0,  1.0, Time * 0.45), d = sinOSC( -1.0,  1.0, Time * 0.25);\n    /* Quadratic *\n    float a =                               0.0, b = sinOSC( -2.0,  2.0, iTime * 0.6), \n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25);\n    /* Linear *\n    float a =                               0.0, b =                               0.0,\n          c = sinOSC( -1.0,  1.0, iTime * 0.45), d = sinOSC( -1.0,  1.0, iTime * 0.25);\n    /* Identity 0 == 0 *\n    float a =                               0.0, b =                              0.0,\n          c =                               0.0, d =                              0.0;\n    /**/\n\n    // Cauchy's roots bounds.\n    float upper_bound = max(0.0, 1.0 + max(-a/a, max(-b/a, max(-c/a, -d/a))));\n    float lower_bound = max(0.0, 1.0 + max( a/a, max( b/a, max( c/a,  d/a))));\n\n    vec3 color = (NDC.x <= upper_bound && NDC.x >= -lower_bound) ? vec3(.9,.9,.9) : vec3(1.);\n         color -= cubic(NDC, a, b, c, d);\n         color -= x_axis(NDC); color -= y_axis(NDC);\n\n    vec2 roots[3];\n      \n    // Non-numeric solvers.\n    int num = solve3(roots, a, b, c, d);\n    \n    // Numeric solvers.\n    //int num = solve3n(roots, a, b, c, d);\n\n    for (int r=0; r < num; ++r) \n    {\n        float x = roots[r].x;\n        color = mix(color, vec3(1, 0, 0), SM(diskSDF_L2(NDC, vec2(x, 0.0), 0.03)));\n    }\n\n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Returns number of real roots.\n*/\nint solveQuadraticForReal(\n    inout vec2[2] roots,\n    float a, float b, float c)\n{\n    float discriminant = b * b - 4.0 * a * c;;\n    float INVa = 1.0 / (2. * a);\n    float SQRT = sqrt(discriminant);\n\n    roots[0].x = (SQRT - b) * INVa;  roots[0].y = 0.0;\n    roots[1].x = (-b - SQRT) * INVa; roots[1].y = 0.0;\n\n    return \n        discriminant < 0.0 ? // No real roots?\n        0 : 2;\n}\n\n/*\n    Solves ax^3+bx^2+cx+d=0.\n\n    Return value:\n        0 - no roots when A==0, B==0, C==0;\n        1 - one real, two complex roots;\n        2 - three real roots, but root[1] == root[2];\n        3 - three real roots.\n*/\nint solveCubicVieta(\n    inout vec2[3] roots,\n    float a, float b, float c, float d)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / a;\n    float A = b * inv;\n    float B = c * inv;\n    float C = d * inv;\n\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - A * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - A * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - A * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(Q);\n        float Re = signR * sqrtQ * cosh(phi);\n        float Im = sqrtQ * sinh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - A * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - A * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - A * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        float sqrtQ = sqrt(abs(Q));\n        float Re = signR * sqrtQ * sinh(phi);\n        float Im = sqrtQ * cosh(phi);\n        float sqrt3 = 1.7320508075688772;\n\n        roots[0].x = -2.0 * Re - A * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re - A * oneThird;\n        roots[1].y = sqrt3 * Im;\n        roots[2].x = Re - A * oneThird;\n        roots[2].y = -sqrt3 * Im;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        float Re = -pow(C - A * A * A / 27.0, oneThird) - A * oneThird;\n        float Im = sqrt(abs(A - 3.0 * Re) * (A + Re) - 4.0 * B) * 0.5;\n\n        roots[0].x = Re;\n        roots[0].y = 0.0;\n        roots[1].x = -(A + Re) * 0.5;\n        roots[1].y = Im;\n        roots[2].x = -(A + Re) * 0.5;\n        roots[2].y = Im;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - A * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - A * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\nint solveCubicVietaForReal(\n    inout vec2[3] roots,\n    float aa, float bb, float cc, float dd)\n{\n    const float oneThird = 0.33333333333333331;\n    const float TAU = 6.2831853071795862;\n\n    float inv = 1.0 / aa;\n    float A = bb * inv;\n    float B = cc * inv;\n    float C = dd * inv;\n\n    float Q = (A * A - 3.0 * B) / 9.0;\n    float R = (2.0 * A * A * A - 9.0 * A * B + 27.0 * C) / 54.0;\n    float S = Q * Q * Q - R * R;\n\n    if (S > 0.0)\n    {\n        float phi = oneThird * acos(R / sqrt(Q * Q * Q));\n        float Re = -2.0 * sqrt(Q);\n\n        roots[0].x = Re * cos(phi) - A * oneThird;\n        roots[0].y = 0.0;\n        roots[1].x = Re * cos(phi + TAU * oneThird) - A * oneThird;\n        roots[1].y = 0.0;\n        roots[2].x = Re * cos(phi - TAU * oneThird) - A * oneThird;\n        roots[2].y = 0.0;\n\n        return 3;\n    }\n\n    if (S < 0.0 && Q > 0.0)\n    {\n        float phi = oneThird * acosh(abs(R) / sqrt(Q * Q * Q));\n        float signR = R < 0.0 ? -1.0 : 1.0;\n\n        roots[0].x = -2.0 * sign(R) * sqrt(Q) * cosh(phi) - A * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    if (S < 0.0 && Q < 0.0)\n    {\n        float phi = oneThird * asinh(abs(R) / sqrt(abs(Q * Q * Q)));\n\n        roots[0].x = -2.0 * sign(R) * sqrt(abs(Q)) * sinh(phi) - A * oneThird;\n        roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    if (Q == 0.0)\n    {\n        roots[0].x = -pow(C - A * A * A / 27.0, oneThird) - A * oneThird; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    float signR = R < 0.0 ? -1.0 : 1.0;\n    float Re = signR * sqrt(Q);\n\n    roots[0].x = -2.0 * Re - A * oneThird;\n    roots[0].y = 0.0;\n    roots[1].x = Re - A * oneThird;\n    roots[1].y = 0.0;\n    roots[2] = roots[1];\n\n    return 2;\n}\n// Source : https://www.shadertoy.com/view/3tyczd\nint solveCubicOneShade(out vec2 roots[3], in float a, in float b, in float c, in float d) {\n    const vec2 eta = vec2(-0.5, sqrt(0.75));\n    float h = 18.0 * a * b * c * d - 4.0 * b * b * b * d + b * b * c * c - 4.0 * a * c * c * c - 27.0 * a * a * d * d;\n\n    b /= a, c /= a, d /= a;\n    float d0 = b * b - 3.0 * c;\n    float d1 = (2.0 * b * b - 9.0 * c) * b + 27.0 * d;\n    float q = d1 * d1 - 4.0 * d0 * d0 * d0, j = sqrt(abs(q));\n\n    vec2 C = q < 0.0 ? vec2(d1, j) : vec2(d1 + j, 0.0);\n    if (abs(C.x) + abs(C.y) < 1e-3) C = vec2(d1 - j, 0.0);\n    float t = atan(C.y, C.x) / 3.0, r = pow(0.25 * dot(C, C), 1.0 / 6.0);\n    C = vec2(cos(t), sin(t));\n\n    float w = -d0 / r - r;\n    roots[0].x = (C.x * w - b) / 3.0;\n    roots[1].x = (dot(vec2(C.x, -C.y), eta) * w - b) / 3.0;\n    if (h > 0.0) roots[2].x = (dot(C, eta) * w - b) / 3.0;\n    else if (abs(dot(C.yx, eta)) < abs(C.y)) roots[0].x = roots[1].x;\n\n    return h < 0.0 ? 1 : 3;\n}\n\n\n/* \n    Returns number of real roots.       \n*/\nint solve3(\n    inout vec2[3] roots,\n    float a, float b, float c, float d)\n{\n    // Cubic equation?\n    if (a != 0.0)\n    {\n        //return solveCubicOneShade(roots, a, b, c, d);\n        //return solveCubicVieta(roots, a, b, c, d);\n        return solveCubicVietaForReal(roots, a, b, c, d);\n    }\n    \n    // Quadratic equation?\n    if (b != 0.0)\n    {\n        vec2 roots_[2];\n\n        int num = solveQuadraticForReal(roots_, b, c, d);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (c != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -d/c; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (c == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}\n\n/* Numeric solvers. */\nfloat findCubicRootNewtonRaphson(\n    float x, float a, float b, float c, float d)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float dfdx = (3.0 * a * x + 2.0 * b) * x + c;\n    bool quit = abs(dfdx) <= EPSILON;\n    \n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float f = ((a * x + b) * x + c) * x + d;\n        x -= f / dfdx;          \n        dfdx = (3.0 * a * x + 2.0 * b) * x + c;\n        quit = (abs(f) <= tolerance) || (abs(dfdx) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findCubicRootSecant(\n    float x, float a, float b, float c, float d)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n\n    float x_p = x;\n    float f_p = (a * x + b) * x + c;\n          x = x_p - (f_p / ((3.0 * a * x + 2.0 * b) * x + c));\n\n    bool quit = false;\n\n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {\n        float f = ((a * x + b) * x + c) * x + d;\n        float df = f - f_p; f_p = f;\n        float dx = x - x_p; x_p = x;\n\n        //x -= f / (df / dx);\n        x -= (f*dx) / df;\n\n        quit = (abs(f) <= tolerance) || (abs(dx) <= EPSILON || (abs(df) <= EPSILON));         \n    }\n\n    return x;\n}\nfloat findCubicRootHalley(\n    float x, float a, float b, float c, float d)\n{\n    const float tolerance = 1e-7; /* Desired precision. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitly small values. */\n    \n    float f = ((a * x + b) * x + c) * x + d,\n          dfdx = (3. * a * x + 2. * b) * x + c,\n          ddfddx = 6. * a * x + 2. * b,\n          denom = 2.*dfdx*dfdx - f * ddfddx;\n          \n    bool quit = abs(denom) <= EPSILON;\n    \n    for (int i = 0; (i < 16) && (quit == false); ++i)\n    {       \n        x -= (2.*f*dfdx) / denom;\n        \n        f = ((a * x + b) * x + c) * x + d;\n        dfdx = (3. * a * x + 2. * b) * x + c;\n        ddfddx = 3. * a * x + 2. * b;\n        denom = 2.*dfdx*dfdx - f * ddfddx;\n        \n        quit = (abs(f) <= tolerance) || (abs(denom) <= EPSILON);\n    }\n\n    return x;\n}\nfloat findCubicRootBisection(\n    float xl, float xr, float a, float b, float c, float d)\n{\n    const float tolerance = 1e-7; /* Desired precision */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        ((a * xl + b) * xl + c) * xl + d,  // f(xl)\n        ((a * xr + b) * xr + c) * xr + d); // f(xr)\n        \n    float f = 0.5;\n        \n    for (int i = 0; (i < 24) && (abs(f) > tolerance); ++i)\n    {\n        // Make step of bisection method.\n        float x = X[0] + (X[1] - X[0]) * 0.5;\n              f = ((a * x + b) * x + c) * x + d;\n\n        int w_idx = int(sign(F[0]) != sign(f));\n        \n        F[w_idx] = f; X[w_idx] = x;\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findCubicRootHybrid(\n    float xl, float xr, float a, float b, float c, float d)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        ((a * xl  + b) * xl + c) * xl + d,  // f(xl)\n        ((a * xr  + b) * xr + c) * xr + d); // f(xr)\n        \n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        float x = (X[0] * F[1] - X[1] * F[0]) / (F[1] - F[0]);\n        float f = ((a * x  + b) * x + c) * x + d;\n    \n        int w_idx = int(abs(f - F[0]) < abs(f - F[1]));\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return X[0] + (X[1] - X[0]) * 0.5;\n}\nfloat findCubicRootRegulaFalsi(\n    float xl, float xr, float a, float b, float c, float d)\n{\n    const float tolerance = 1e-7; /* Desired presicion. */\n    const float EPSILON = 1e-14;  /* Treshold for infinitely small values. */\n\n    float X[2] = float[2]( xl, xr );\n    float F[2] = float[2](\n        ((a * xl  + b) * xl + c) * xl + d,   // f(xl)\n        ((a * xr  + b) * xr + c) * xr + d ); // f(xr)\n\n    float x = 0.0, f = 0.0;\n\n    bool quit = abs(F[1] - F[0]) <= EPSILON;\n\n    for (int i = 0; (i < 24) && (quit == false); ++i)\n    {\n        x = X[0] -  F[0] * ((X[1] - X[0]) / (F[1] - F[0]));\n        f = ((a * x  + b) * x + c) * x + d;\n\n        int w_idx = int(f * F[1] > 0.);\n\n        F[w_idx] = f; X[w_idx] = x;\n\n        quit = (abs(f) <= tolerance) || (abs(F[1] - F[0]) <= EPSILON);\n    }\n\n    return x;\n}\n/* Numeric solvers. */\n\n/* \n    Returns number of real roots.       \n*/\nint solve3n(\n    inout vec2[3] roots,\n    float a, float b, float c, float d)\n{\n    // Cubic equation?\n    if (a != 0.0)\n    {\n        // Find first root.\n        //roots[0].x = findCubicRootNewtonRaphson(0.01, a, b, c, d);\n        //roots[0].x = findCubicRootSecant(1.01, a, b, c, d);\n        roots[0].x = findCubicRootBisection(-10.1, 10.0, a, b, c, d);\n        //roots[0].x = findCubicRootRegulaFalsi(-10.1, 10., a, b, c, d);\n        //roots[0].x = findCubicRootHalley(0.01, a, b, c, d);\n        //roots[0].x = findCubicRootHybrid(-10.1,10., a, b, c, d);\n\n        // Convert equation to form: (x-r0)(a0*x*x+b0*x+c0)=0\n        vec2 roots_[2];\n\n        float a0 = a;\n        float b0 = b + a * roots[0].x;\n        float c0 = c + b * roots[0].x + a * roots[0].x * roots[0].x;\n\n        int num = solveQuadraticForReal(roots_, a0, b0, c0);\n\n        roots[1] = roots_[0]; roots[2] = roots_[1];\n\n        return num + 1;\n    }\n    \n    // Quadratic equation?\n    if (b != 0.0)\n    {\n        vec2 roots_[2];\n\n        int num = solveQuadraticForReal(roots_, b, c, d);\n\n        roots[0] = roots_[0]; roots[1] = roots_[1];\n        \n        return num;\n    }\n\n    // Linear equation?\n    if (c != 0.0)\n    {\n        // Solve linear equation.\n        roots[0].x = -d/c; roots[0].y = 0.0;\n\n        return 1;\n    }\n\n    // Identity 0 == 0? Infinitely many roots?\n    if (d == 0.0) \n    { \n        // Pick zero root.\n        roots[0].x = 0.0; roots[0].y = 0.0;\n\n        return 1;\n    }\n    \n    return 0;\n}","name":"Common","description":"","type":"common"}]}