{"ver":"0.1","info":{"id":"WllfDf","date":"1598990282","viewed":1114,"name":"Pendulum simulation","username":"zduny","description":"Pendulum motion simulated with simple Euler integration.\nIt's not as accurate as other more advanced methods, but it produces otherwise visually convincing and chaotic trajectories.\n\nPress SPACE to reset simulation.\nCLICK to attract end of pendulum.","likes":29,"published":3,"flags":48,"usePreview":0,"tags":["simulation","interactive","physics","pendulum","euler"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void drawPendulum(in vec2 fragCoord, inout vec4 outColor) {\n  float totalMass = 0.0;\n  for (int i = 0; i < rods; i++) {\n    totalMass += masses[i];\n  }\n\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  vec2 previous = anchor;\n  for (int i = 0; i <= rods; i++) {\n    vec2 position;\n    if (i < rods) {\n      position = anchor + ballData(STORAGE, i).xy * scale;\n      drawSegment(fragCoord, previous, position, 0.1 * scale,\n                  vec4(vec3(0.0), 1.0), outColor);\n    }\n\n    float radius = i == 0 ? 0.05 : 0.4 * pow(masses[i - 1] / totalMass, 0.6);\n    vec3 color = i == 0 || black ? vec3(0.0) : palette[(i - 1) % colors];\n\n    drawDisk(fragCoord, previous, (radius + 0.1) * scale, vec4(vec3(0.0), 1.0),\n             outColor);\n    drawDisk(fragCoord, previous, radius * scale, vec4(color, 1.0), outColor);\n\n    previous = position;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  fragColor = texture(iChannel1, uv);\n\n  drawPendulum(fragCoord, fragColor);\n\n  fragColor = vec4(toSRGB(fragColor.rgb), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEYBOARD iChannel1\n\nconst float pi = 3.1416;\n\nbool saveResolutionData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == resolutionDataLocation) {\n    vec4 previousResolutionData = texelFetch(STORAGE, fragCoord, 0);\n    vec2 oldResolution = previousResolutionData.xy;\n    fragColor = vec4(iResolution.xy, oldResolution);\n\n    return true;\n  }\n\n  return false;\n}\n\nbool isMousePressed() { return iMouse.z > 0.0; }\n\nfloat potentialEnergy(in vec4 data, in float mass) {\n  float m = mass;\n  float g = length(g);\n  float h = data.y + 10000.0;\n  return m * g * h;\n}\n\nfloat kineticEnergy(in vec4 data, in float mass) {\n  float m = mass;\n  float v = length(data.zw);\n  return 0.5 * m * v * v;\n}\n\nfloat totalEnergy(in vec4 data, in float mass) {\n  return potentialEnergy(data, mass) + kineticEnergy(data, mass);\n}\n\nvoid euler(inout vec4 current, in float timeDelta) {\n  current.zw += g * timeDelta;\n  current.xy += (current.zw + 0.5 * g * timeDelta) * timeDelta;\n}\n\nbool initialization(in ivec2 fragCoord, out vec4 fragColor) {\n  if (iFrame > 0 && !isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    return false;\n  }\n\n  if (fragCoord.x > rods + 1 || fragCoord.y > 1) {\n    return false;\n  }\n\n  float energy = 0.0;\n  vec2 position = vec2(0.0);\n  float angle = pi / 2.0;\n  for (int i = 0; i < rods; i++) {\n    angle += angles[i] * pi / 180.0;\n    position += vec2(sin(angle), cos(angle)) * lengths[i];\n    vec4 data = vec4(position, vec2(0.0));\n    energy += totalEnergy(data, masses[i]);\n    if (fragCoord.x == i) {\n      fragColor = data;\n    }\n  }\n\n  if (fragCoord.x == rods) {\n    fragColor = vec4(energy, vec3(0.0));\n  }\n\n  return true;\n}\n\nbool simulation(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord.x > rods + 1 || fragCoord.y > 1) {\n    return false;\n  }\n\n  if (fragCoord.y == 1) {\n    fragColor = ballData(STORAGE, fragCoord.x);\n    return true;\n  }\n\n  if (fragCoord.x == rods) {\n    if (isMousePressed()) {\n      // Calculate new energy\n      if (fragCoord.x == rods) {\n        float energy = 0.0;\n        for (int i = 0; i < rods; i++) {\n          vec4 data = ballData(STORAGE, i);\n          energy += totalEnergy(data, masses[i]);\n        }\n        fragColor = vec4(energy, vec3(0.0));\n        return true;\n      }\n    } else {\n      fragColor = vec4(energyBefore(STORAGE), vec3(0.0));\n    }\n    return true;\n  }\n\n  vec4[rods] data;\n  for (int i = 0; i < rods; i++) {\n    data[i] = ballData(STORAGE, i);\n  }\n\n  for (int s = 0; s < iterations; s++) {\n    float timeDelta = min(iTimeDelta, 0.1) / float(iterations);\n\n    for (int i = 0; i < rods; i++) {\n      euler(data[i], timeDelta);\n    }\n\n    // Constraints\n    for (int i = 0; i < rods; i++) {\n      vec2 previous = i > 0 ? data[i - 1].xy : vec2(0.0);\n\n      vec2 toPrevious = normalize(previous - data[i].xy);\n      vec2 constrained = previous - toPrevious * lengths[i];\n      vec2 impulse = (constrained - data[i].xy) / timeDelta;\n\n      data[i].xy = constrained;\n      data[i].zw += impulse;\n\n      if (i > 0 && dot(toPrevious, impulse) > 0.0) {\n        data[i - 1].zw -= impulse * masses[i] / masses[i - 1];\n      }\n    }\n  }\n\n  float damp = damping;\n  if (isMousePressed()) {\n    float scale = iResolution.y / 20.0;\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.0) / scale - center;\n    vec2 toMouse = mouse - data[rods - 1].xy;\n    float magnitude = length(toMouse);\n    if (magnitude > 0.1) {\n      data[rods - 1].zw += normalize(toMouse) * magnitude;\n      damp = 0.96;\n    }\n  }\n\n  if (damp < 1.0) {\n    for (int i = 0; i < rods; i++) {\n      data[i].zw *= damp;\n    }\n  } else {\n    // Compensate for energy drift\n    float potential = 0.0;\n    float kinetic = 0.0;\n    for (int i = 0; i < rods; i++) {\n      potential += potentialEnergy(data[i], masses[i]);\n      kinetic += kineticEnergy(data[i], masses[i]);\n    }\n    if (kinetic > 0.0) {\n      float scale = sqrt((energyBefore(STORAGE) - potential) / kinetic);\n      for (int i = 0; i < rods; i++) {\n        data[i].zw *= scale;\n      }\n    }\n  }\n\n  int i = fragCoord.x;\n  fragColor = data[i];\n\n  return true;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  fragColor = vec4(0.0);\n  ivec2 iFragCoord = ivec2(fragCoord);\n\n  if (saveResolutionData(iFragCoord, fragColor)) {\n    return;\n  }\n\n  if (initialization(iFragCoord, fragColor)) {\n    return;\n  }\n\n  simulation(iFragCoord, fragColor);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int rods = 3;\nconst vec2 center = vec2(0.0, 5.3);\nconst float[] lengths = float[](5.0, 5.0, 5.0, 2.5, 3.0, 4.0);\nconst float[] angles = float[](-20.0, -3.0, -2.0, 0.0, 0.0, 0.0);\nconst float[] masses = float[](1.0, 1.0, 1.0, 1.0, 1.0, 1.0);\nconst bool continuous = true;\nconst bool black = false;\nconst int colors = 6;\nconst vec3[] palette =\n    vec3[](vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0),\n           vec3(1.0, 0.0, 1.0), vec3(0.0, 1.0, 1.0), vec3(1.0, 1.0, 0.0));\nconst float fade = 0.03;\nconst int iterations = 30;\nconst float damping = 1.0;\nconst vec2 g = vec2(0.0, -20.0);\n\n#define STORAGE iChannel0\nconst ivec2 resolutionDataLocation = ivec2(0, 2);\n\n#define KEY_SPACE 32\nbool isKeyPressed(in sampler2D keyboard, in int keyCode) {\n  return texelFetch(keyboard, ivec2(keyCode, 1), 0).x > 0.0;\n}\n\nvec4 ballData(in sampler2D storage, in int index) {\n  return texelFetch(storage, ivec2(index, 0), 0);\n}\n\nvec2 previousBallPosition(in sampler2D storage, int index) {\n  return texelFetch(storage, ivec2(index, 1), 0).xy;\n}\n\nfloat energyBefore(in sampler2D storage) {\n  return texelFetch(storage, ivec2(rods, 0), 0).x;\n}\n\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\nvoid drawDisk(in vec2 fragmentCoordinates, in vec2 center, in float radius,\n              in vec4 color, inout vec4 outputColor) {\n  float d = distance(fragmentCoordinates, center);\n  float a = 1.0 - clamp(d - radius + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}\n\nfloat sdSegment(in vec2 point, in vec2 a, in vec2 b) {\n  vec2 pa = point - a;\n  vec2 ba = b - a;\n\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\n  return length(pa - ba * h);\n}\n\nvoid drawSegment(in vec2 fragmentCoordinates, in vec2 p0, in vec2 p1,\n                 in float thickness, in vec4 color, inout vec4 outputColor) {\n  float d = sdSegment(fragmentCoordinates, p0, p1);\n  float a = 1.0 - clamp(d - thickness / 2.0 + 0.5, 0.0, 1.0);\n\n  outputColor = mix(outputColor, color, a * color.a);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define KEYBOARD iChannel2\n\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid drawTrials(in vec2 fragCoord, inout vec4 outColor) {\n  float scale = iResolution.y / 20.0;\n  vec2 anchor = iResolution.xy / 2.0 + center * scale;\n\n  for (int i = 0; i < rods; i++) {\n    vec2 position = anchor + ballData(STORAGE, i).xy * scale;\n    vec3 color = black ? vec3(0.0) : palette[i % colors];\n    if (continuous) {\n      vec2 previous = anchor + previousBallPosition(STORAGE, i).xy * scale;\n      drawSegment(fragCoord, position, previous, 0.14 * pow(scale, 0.7),\n                  vec4(color, 1.0), outColor);\n    } else {\n      drawDisk(fragCoord, position, 0.11 * pow(scale, 0.7), vec4(color, 1.0),\n               outColor);\n    }\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n  vec4 background = vec4(vec3(0.85), 1.0);\n  if (iFrame == 0 || resolutionChanged() || isKeyPressed(KEYBOARD, KEY_SPACE)) {\n    fragColor = background;\n  } else {\n    fragColor = mix(texture(iChannel1, uv), background, fade);\n  }\n  drawTrials(fragCoord, fragColor);\n}","name":"Buffer B","description":"","type":"buffer"}]}