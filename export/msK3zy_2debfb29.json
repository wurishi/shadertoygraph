{"ver":"0.1","info":{"id":"msK3zy","date":"1678754609","viewed":195,"name":"Procedural forest","username":"ianertson","description":"Use the mouse to look around :)\nAnti Aliasing can be enabled in the \"Common\" tab.","likes":17,"published":1,"flags":32,"usePreview":1,"tags":["procedural","3d","raymarching","raymarch","sdf","forest","trees"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 boxBlur(vec2 uv, in float f) {\n    vec3 col = vec3(0.0);\n    const int filterSize = 8;\n    const int halfFilterSize = filterSize / 2;\n\n    const int start = -halfFilterSize;\n    const int end = -halfFilterSize + filterSize;\n\n    float shadow = 0.0;\n    vec2 texelSize = clamp(1.0+f, 1.0, 2.5) / vec2(textureSize(iChannel0, 0).xy);\n    int count = 0;\n    for(int x = start; x < end; ++x)\n    {\n        for(int y = start; y <= end; ++y)\n        {\n            vec3 next = texture(iChannel0, uv + (vec2(x, y) * texelSize)).rgb;\n            col += next;\n            count += 1;\n        }\n    }\n\n    col /= float(count);\n    return col;\n}\n\nvec4 shade(in vec2 fc )\n{\n    vec2 uv = fc/R.xy;\n    \n    vec4 rgba = texture(iChannel0, uv).rgba;\n    vec3 col = rgba.rgb;\n    float depth = rgba.a;\n    \n    vec3 blurred = boxBlur(uv, depth);\n    col = mix(col, blurred, depth);\n    \n    return vec4(col, 1.0);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    O = shade(fc);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define AA_ENABLED 0\n#define AMBIENT 0.05\n\n#define R (iResolution.xy)\n#define T (iTime)\n#define M_PI (3.14159265359)\n#define TAU (M_PI * 2.0)\n#define ZERO (min(0, int(iTime)))\n#define adot(a,b) (abs(dot(a, b)))\n#define cdot(a,b) (max(0.0, dot(a, b)))\n#define rgb(a,b,c) (vec3(a, b, c) / 255.0)\n#define SAMPLE(var, id_) if (id_ != skip && var < dist) { id = id_; dist = var; }\n\n\n\nfloat luma(vec3 color) { return dot(color, vec3(0.299, 0.587, 0.114)); }\nmat2 rot(in float a) { float c = cos(a); float s = sin(a); return mat2(c, s, -s, c); }\n\n\nstruct Material { float rough; float spec; float metallic; float lum; float z; };\n#define NEW_MATERIAL Material(1.0, 1.0, 0.0, 0.0, 0.0)\n\nstruct Data {\n    vec3 ro;\n    vec3 rd;\n    vec3 p;\n    vec3 n;\n    vec2 uv;\n    float d;\n    int id;\n    int skip;\n    Material m;\n};\n#define NEW_DATA Data(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0), vec2(0.0), FAR, 0, 0, NEW_MATERIAL)\n\nstruct Light { vec3 p; vec3 d; vec3 c; float s; int type; };\n#define LIGHT_AMBIENT 0\n#define LIGHT_POINT 1\n#define LIGHT_DIR 2\n\nvec3 getLightDir(in Light light, in vec3 p) {\n    return light.type == LIGHT_AMBIENT ? normalize(light.p) : \n        light.type == LIGHT_POINT ? normalize(light.p - p) :\n            normalize(light.d);\n}\n\nvec3 getLightAtt(in Light light, in vec3 p, in vec3 n) {\n    vec3 L = getLightDir(light, p);\n    float NdotL = max(AMBIENT, dot(n, L));\n    \n    switch (light.type) {\n        case LIGHT_AMBIENT: return light.c * light.s * NdotL; break;\n        case LIGHT_POINT: return light.c * NdotL * (\n            pow(light.s, 2.0) / max(0.0001, pow(distance(light.p, p), 2.0))\n        ); break;\n        case LIGHT_DIR: return light.c * NdotL * light.s * smoothstep(0.8, 1.0, dot(\n            normalize(light.p - p),\n            L\n        )); break;\n    }\n    \n    return vec3(0.0);\n}\n\nvec2 boxUv(in vec3 p, in vec3 n) {\n    return mix(mix(p.xz, p.xy, round(adot(n, vec3(0, 0, 1)))), p.zy, round(adot(n, vec3(1, 0, 0))));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat smax(float a, float b, float k) {\n    return smin(a, b, -k);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n    vec3 h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nvec3 smax(vec3 a, vec3 b, float k) {\n    return smin(a, b, -k);\n}\n\nfloat sabs(in float v, in float k) {\n    return smax(-v, v, k);\n}\n\nvec3 aces(vec3 x) {\n    return x*(2.51*x + .03) / (x*(2.43*x + .59) + .14);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) *\n                  pow(max(1.0 - cosTheta, 0.0), 5.0);\n}\n\nvec3 makeNormal(in vec3 wn, in float z, in float mx, in float s) {\n    if (abs(z) <= 0.000000001) return wn;\n    vec2 dx = vec2(dFdx(z), 0.0);\n    vec2 dy = vec2(0.0, dFdy(z));\n\n    float bumpScale = s;\n    vec3 cp = cross(vec3(dx, bumpScale), vec3(dy, bumpScale));\n    if (length(cp) <= 0.0001) return wn;\n    \n    cp = normalize(cp);\n    \n \n    \n    return normalize(mix(wn, normalize(wn+cp), mx));\n   \n}\n\nfloat line2D(in vec2 p, in vec2 a, in vec2 b, float t) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return max(0.0, 1.0-length(pa - ba * h)/t);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n#define NEAR 0.003\n#define FAR 90.0\n#define STEPS 70\n#define SHADOW_STEPS 33\n\n#define ID_NONE 0\n#define ID_GROUND 1\n#define ID_BOX 2\n#define ID_TREE 3\n#define ID_TREE_LEAF 4\n\n#define NOISE(P, SEED, LOD) (textureLod(iChannel3, ((P) + ((SEED)*1.98277215))/256., LOD).rgb)\n\n\nfloat rand(in vec2 p, in float seed) {\n    p += fract(seed*10.2381892)*2.293921;\n    vec3 p1 = vec3(fract(seed*33.6625281283), fract(p.yx*11.773332613));\n    vec3 p2 = vec3(fract(p.xy*10.89271842), fract(seed*10.99277733)) * 2.0 - 1.0;\n    vec3 p3 = fract(cross(p1, p2)*10.87827733);\n    vec3 p4 = refract(p3, p1, fract(dot(p1, p2)*10.33928187));\n    return fract(10.33828*dot(vec3(p.xy, fract(length(p)+seed))-p4, p3));\n}\n\nfloat randLod(in vec2 p, in float seed, in float lod) {\n    float fseed = fract(seed*10.2381892);\n\n    if (lod <= 0.01) return fseed;\n    \n    p += fseed*2.293921;\n    vec3 p1 = vec3(fract(seed*33.6625281283), fract(p.yx*11.773332613));\n    \n    if (lod <= 0.020) return fract(dot(p1.xy, p));\n    \n    vec3 p2 = vec3(fract(p.xy*10.89271842), fract(seed*10.99277733)) * 2.0 - 1.0;\n    \n    if (lod <= 0.025) return fract(dot(p2.xy, p));\n    \n    vec3 p3 = fract(cross(p1, p2)*10.87827733);\n    \n    if (lod <= 0.03) return fract(dot(p3.xy, p));\n    \n    vec3 p4 = refract(p3, p1, fract(dot(p1, p2)*10.33928187));\n    return fract(10.33828*dot(vec3(p.xy, fract(length(p)+seed))-p4, p3));\n}\n\n\nvec3 snoise(in vec2 p, in float seed, in float lod) {\n    vec2 id = floor(p);\n    vec2 lv = fract(p); lv = lv*lv*(3.0-2.0*lv);\n    return mix(\n        mix(NOISE(id, seed, lod), NOISE(id + vec2(1, 0), seed, lod), lv.x),\n        mix(NOISE(id + vec2(0, 1), seed, lod), NOISE(id + vec2(1, 1), seed, lod), lv.x),\n        lv.y\n    );\n}\n\nvec3 snoise(in vec2 p, in float seed, in float lod, float freq, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n    }\n    return n / div;\n}\n\nvec3 snoiseWarp(in vec2 p, in float seed, in float lod, float freq, float warp, const in int levels) {\n    float div = 0.0;\n    float amp = 1.0;\n    vec3 n = vec3(0.0);\n    for (int i = 0; i < levels; i++) {\n        n += amp * snoise(p*freq, seed, lod); div += amp; amp /= 2.0; freq *= 2.0; lod /= 2.0;\n        p += (n.xz+n.y)*warp;\n    }\n    return n / div;\n}\n\nfloat wnoise(in vec2 uv, in int iter, float dim) {\n    vec2 k = uv*2.0-1.0;\n    vec2 r = vec2(0.0);\n    float f = 1.0;\n    for (int i = 0; i < iter; i++) {\n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;     \n        r += sin( k*f +(float(i)/float(iter))*2.5) / f;\n        k = k * mat2(8.0, 6.28, -8.0, 6.28)*.1 + r*.29;\n    };\n    float n = 1.0-dFdx(length(r)*dim);\n    return clamp(exp(n-1.5)*n, 0.0, 1.0);\n}\n\nfloat cylSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    float t = dot(ab, ap) / dot(ab, ab);\n    vec3 c = a + t * ab;\n    float x = length(p - c) - r;\n    float y = (abs(t - 0.5) - 0.5) * length(ab);\n    float e = length(max(vec2(x, y), 0.0));\n    float i = min(max(x, y), 0.0);\n    return e + i;\n}\n\nfloat lineSDF(in vec3 p, in vec3 a, in vec3 b, in float r) {\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h)-r;\n}\n\nfloat torusSDF(in vec3 p, in float r1, float r2) {\n    p = p.yzx;\n    float ll = length(p.yz)-r1;\n    return length(vec2(ll,p.x))-r2;\n}\n\nfloat boxSDF(in vec3 p, in vec3 s) {\n    p = abs(p) - s;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sphereSDF(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat groundSDF(in vec3 p) {\n    return p.y;\n}\n\nfloat treeSDF(in float lod, in vec3 p, in float seed, in int skip, inout int id) {\n    id = ID_TREE;\n    float dist = FAR;\n    \n    \n    float h = 2.5 + (fract(seed*10.28931)*4.);\n    \n    if (p.y > ((h*3.)+1.)) return FAR;\n    \n    float ra = randLod(vec2(seed, seed+392.91)*2.0-1.0, 3.299188+seed, lod);\n    float ra2 = fract(ra*45.0989828912);\n    float crust1 = exp(cos(p.y*6.28)-1.);\n    float crust2 = exp(sin((p.y+0.9282771+seed)*6.28)-1.);\n    float crust = /*distRo > 50.0 ? 0.0 : */mix(crust1, crust2, 0.5+(0.5*sin((p.y-(p.x*3.929123+p.z))*6.28)));\n    \n    float w = 0.4;\n    crust *= 0.05;\n    w += crust;\n    w -= smoothstep((0.2+ra), 3.5 - (ra), max(0.0,p.y/h));\n    w += smoothstep(0.5, 1.9, max(0.0, -p.y+1.));\n    float base = lineSDF(p, vec3(0, 0, 0), vec3(0, h, 0), w);\n    \n    base /= (1.1 + crust);\n    \n    \n    float leafs = FAR;\n    \n    /*if (distRo > 50.)  {\n        leafs = sphereSDF(p - vec3(0, h+1.5, 0), 1.5);\n    }\n    else*/ {\n        float lx = exp(cos(p.x*2.)-1.);\n        float lz = exp(sin(p.z*2.)-1.);\n        float ly = exp(sin((p.y-((lx-lz)-(p.y*0.1)))*4.)-1.);\n        float sp = length(p - vec3(lz-0.5, h+1.5, lx-0.5))-((1.3+((ra2*ra)*0.8))+(ly*0.4));\n        vec3 p = p;\n        \n        float jy = randLod(floor(p.xz*7.), 0.0923123 + seed, lod);\n        float jx = randLod(floor(p.zy*7.), 4.9284444 + seed, lod);\n        float jz = randLod(floor(p.xy*7.), 9.9987766 + seed, lod);\n        p.x = fract(p.x*6.*jx)-0.56;\n        p.z = fract(p.z*6.+jz)-0.56;\n        p.y = fract(abs(p.y)*6.+jy)-0.56;\n        \n        p.z += exp(cos(p.x*6.)-1.)*0.5;\n        p.y += exp(cos(p.z*6.)-1.)*0.5;\n        p.x += exp(cos(p.y*6.)-1.)*0.5;\n        \n      \n        \n       // p.x = mod(p.x, 2.)-1.;\n      //  p.z = mod(p.z, 2.)-1.;\n      //  p.y = mod(abs(p.y), 5.);\n        \n        leafs = sphereSDF(p - vec3(0., 0.0, 0), 0.2+(jy*0.2));//length(p - vec3(lz-0.5, h+1.5, lx-0.5))- (1.2+(ly*0.4));\n        leafs = max(leafs, sp);\n        leafs = min(leafs, max(sp, -(leafs-0.46)));\n        \n        \n        float rr = rand(vec2(jy, jx)*jz, 3.3928912 + seed);\n        leafs += rr*0.09;\n        \n        leafs  /= (1.0 + (lod*2.));\n       //leafs += exp(sin(ly*6.-(lx*lz))*cos((p.x-(lz-ly))*TAU*TAU)-1.)*rand(vec2(p.x, p.z), 0.032812);\n    }\n   \n    \n    float idx = floor(p.x*0.1);\n    float rx = randLod(vec2(idx)*30.2021, 0.09398221, lod);\n    float rx2 = fract(rx*33.77278491);\n    \n    float idz = floor(p.z*0.1);\n    float rz = randLod(vec2(idz)*30.2021, 1.1021555, lod);\n    float rz2 = fract(rz*4.8928782);\n    \n\n    {\n        vec3 p = p;\n        p.xz *= rot(rx2);\n        float branchW = 0.15;\n        branchW *= mix(0.5, 1.1, exp(cos(p.x*4.5)-1.));\n        float branchLen = 1.5 + rx + (ra2*0.5);\n        vec3 branchDir = vec3(1, 0, 0);\n        branchDir = mix(branchDir, normalize(vec3(1., (crust*0.5)+0.8, 0)), 0.5 + (rx*exp(cos(p.y*2.)-1.)));\n        branchDir = normalize(branchDir);\n        float branch = lineSDF(vec3(abs(p.x), p.y, p.z) - vec3(0, h+((ra*2.0-1.0)*0.5), 0), vec3(0, 0, 0), branchDir*branchLen, branchW);\n        branch /= (1.6);\n        base = smin(base, branch, 0.3);\n    }\n    \n    {\n        vec3 p = p;\n        p.xz *= rot(rz2);\n        float branchW = 0.15;\n        branchW *= mix(0.5, 1.1, exp(cos(p.z*4.5)-1.));\n        float branchLen = 1.5 + rz + (ra2*0.5);\n        vec3 branchDir = vec3(0, 0, 1);\n        branchDir = mix(branchDir, normalize(vec3(0, (crust*0.5)+0.8, 1)), 0.5 + (rz*exp(cos(p.y*2.)-1.)));\n        branchDir = normalize(branchDir);\n        float branch = lineSDF(vec3(p.x, p.y, abs(p.z)) - vec3(0, h+((ra2*2.0-1.0)*0.5), 0), vec3(0, 0, 0), branchDir*branchLen, branchW);\n        branch /= (1.6);\n        base = smin(base, branch, 0.3);\n    }\n    \n    \n    SAMPLE(leafs, ID_TREE_LEAF);\n    SAMPLE(base, ID_TREE);\n    \n    \n    return (dist-0.001)/(1.005 + clamp(lod*lod, 0.0, 2.2));\n}\n\nfloat sdf(inout Data data, in vec3 p) {\n    int skip = data.skip;\n    int id = ID_NONE;\n    float dist = FAR;\n    \n    float ground = groundSDF(p);\n    SAMPLE(ground, ID_GROUND);\n    \n    vec3 p1 = p;\n    \n    float k = 8.;\n    float k2 = 4.0;\n  \n    vec2 treeGridId = floor((p.xz-k2)/k);\n    float treeSeed = rand(treeGridId*103.28231, 3.398212);\n    p.x = mod(p.x-k2, k)-k2;\n    p.z = mod(p.z-k2, k)-k2;\n    \n    \n    \n    p.xz += vec2(cos(treeSeed*TAU*2.), sin(treeSeed*TAU*2.))*1.1;\n    float distRo = distance(data.ro+p, p1);\n    float lod = 1.0/max(0.0001, distRo);\n    int treeId = 0;\n    float tree = treeSDF(lod, p, treeSeed, skip, treeId);\n    SAMPLE(tree, treeId);\n    \n  //  float box = boxSDF(p - vec3(0, 1, 0), vec3(1.0));\n    //SAMPLE(box, ID_BOX);\n    \n    data.id = id;\n    return dist;\n}\n\nbool march(inout Data data, in vec3 ro, in vec3 rd) {\n    float d = 0.0;\n    data.ro = ro;\n    data.rd = rd;\n    for (int i = ZERO; i < STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        d += next;\n        if (abs(next) <= (NEAR * (1.0 + (d*2.)))) break;\n        if (abs(d) >= FAR) return false;\n    }\n    \n    vec3 p = ro+rd*d;\n    vec2 e = vec2(0.001, 0.0);\n    vec3 n = normalize(sdf(data, p) - vec3(\n        sdf(data, p - e.xyy),\n        sdf(data, p - e.yxy),\n        sdf(data, p - e.yyx)\n    ));\n    vec2 uv = boxUv(p, n);\n    \n    data.d = d;\n    data.p = p;\n    data.n = n;\n    data.uv = uv;\n    \n    return true;\n}\n\nfloat getShadow(in vec3 ro, in vec3 rd, in vec3 n, in float near, in float far, in int skip) {\n    float NdotL = cdot(n, rd);\n    if (NdotL <= 0.00009) return 1.0;\n    Data data = NEW_DATA;\n    data.skip = skip;\n    data.ro = ro;\n    data.rd = rd;\n    float d = 0.0;\n    \n    float r = 1.0;\n    \n    for (int i = ZERO; i < SHADOW_STEPS; i++) {\n        vec3 p = ro+rd*d;\n        float next = sdf(data, p);\n        r = min(r, next/0.44);\n        d += next*0.44;\n        if (abs(next) <= (NEAR * (1.0 + (d*2.)))) break;\n        if (abs(d) >= far) break;\n    }\n\n    \n    return clamp(pow(mix((d / (1.0+d)), r, 0.2), 2.), AMBIENT, 1.0);\n}\n\n//#define DEBUG_TEXTURE leafTexture\n\n\nvec3 leafTexture(in vec2 uv, in vec3 p, inout Material m) {\n    vec3 col = vec3(0.0);\n    vec3 g1 = rgb(63, 104, 26);\n    vec3 g2 = rgb(68, 80, 33);\n    vec3 g3 = rgb(123, 142, 23);\n    vec3 g4 = rgb(92, 105, 44);\n    \n    vec3 warp = snoiseWarp(uv, 0.00001, 0.6, 16.0, 0.5, 6);\n    vec3 hf1 = snoise(uv, 1.8287181, 0.6, 100.0, 6);\n    vec3 grain = snoise(uv, 4.4929099, 0.1, 200.0, 4);\n    \n    \n    vec3 col1 = mix(mix(mix(g1, g2, hf1.x), g3, hf1.y), g4, hf1.z);\n    col += col1;\n    \n    col = mix(col, col*col, smoothstep(0.4+(grain.y*0.2), (0.8-(grain.z*0.6)), warp.y)*grain.x);\n    col = mix(col, col*col, clamp(grain.y*2., 0.0, 1.0));\n    \n    m.spec = clamp(hf1.x*warp.y*warp.z, 0.0, 1.0);\n    \n    return col;\n}\n\nvec3 barkTexture(in vec2 uv, in vec3 p, inout Material m, in float lod) {\n    vec3 col = vec3(0.0);\n    \n    vec3 c1 = rgb(117, 98, 81);\n    vec3 c2 = rgb(81, 68, 52);\n    vec3 c3 = rgb(101, 71, 62);\n    vec3 c4 = rgb(124, 110, 88);\n    \n    vec3 hf1 = snoise(uv, 0.08782812, 0.44, 120.0, 6);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).rgb;\n    vec3 grain2 = abs(normalize(cross(hf1*2.0-1.0, grain*2.0-1.0)));\n    vec3 lf1 = snoise(uv * vec2(2., 0.5), 3.3029184, 0.44, 8.0, 6);\n    vec3 lf2 = lod < 0.02 ? lf1 : snoise((uv * vec2(2., 0.5))+0.0987231, 9.111223344, 0.44, 16.0, 6);\n    \n    vec3 col1 = mix(mix(mix(c1, c2, hf1.x), c3, hf1.y), c4, hf1.z);\n    col += col1;\n    \n    float cracks = max(0.0, 1.0-smoothstep(0.02, 0.09, abs(lf1.x*2.0-1.0)));\n    cracks *= grain2.x;\n    \n    float cracks2 = max(0.0, 1.0-smoothstep(0.02, 0.09, abs(lf2.x*2.0-1.0)));\n    cracks2 *= grain2.y;\n    \n    float detail = abs(grain2.x-hf1.x);\n    detail *= lf1.y;\n    \n    float detail2 = abs(grain.x-grain2.z);\n    detail2 = clamp(detail2*lf1.z*4., 0.0, 1.0);\n    \n    float detail3 = grain.z*lf1.y;\n    \n    col = mix(col, col*c4, cracks2);\n    col = mix(col, col*col, cracks);\n    col = mix(col, col+col, detail);\n    col = mix(col, col*col, detail2);\n    col = mix(col, c3*c3, detail3);\n    \n    m.spec = clamp(((detail+cracks2)/2.)*lf2.z, 0.0, 1.0);\n    \n    m.z = (1.0-clamp(cracks + cracks2, 0.0, 1.0))*0.5;\n    \n    \n    return col;\n}\n\nvec3 grassTexture(in vec2 uv, in vec3 p, inout Material m, in float dirtF, in float lod) {\n    vec3 col = vec3(0.0);\n    \n    vec3 g1 = rgb(99, 101, 28);\n    \n    if (lod <= 0.01) return g1;\n    \n    vec3 g2 = rgb(105, 100, 59);\n    vec3 g3 = rgb(91, 91, 31);\n    vec3 g4 = rgb(128, 129, 53);\n   \n    vec3 d1 = rgb(101, 84, 72);\n    vec3 d2 = rgb(153, 138, 106);\n    vec3 d3 = rgb(136, 129, 108);\n    vec3 d4 = rgb(134, 105, 78);\n    vec3 warp = snoiseWarp(uv, 0.0288213, 0.5, 24.0, 0.5, 6);\n    vec3 hf1 = snoise(uv, 3.392812, 0.5, 120.0, 6);\n    vec3 hf2 = lod < 0.02 ? hf1 : snoise(uv, 7.727111, 0.5, 100.0, 6);\n    vec3 hf3 = normalize(abs(cross(hf1*2.0-1.0, hf2*2.0-1.0)));\n    vec3 lf1 = snoise(uv, 10.883337, 0.2, 8.0, 6);\n    vec3 lf2 = normalize(abs(cross(lf1*2.0-1.0, warp*2.0-1.0)));\n    vec3 lf3 = snoise(uv, 16.228380, 0.1, 8.0, 6);\n    vec3 lf4 = snoise((uv*0.5)+4.9281, 0.0999281, 0.4, 0.5, 4);\n    vec3 grain = textureLod(iChannel3, uv, 0.0).xyz;\n    vec3 grain2 = normalize(abs(reflect(grain, hf3)));\n   \n    \n    vec3 grassCol = mix(mix(mix(g1, g2, hf3.x), g3, hf3.y), g4, hf3.z);\n    vec3 dirtCol1 = mix(mix(mix(d1, d2, lf2.x), d3, lf2.y), d4, lf2.z);\n    vec3 dirtCol2 =  mix(mix(mix(d1, d2, hf1.x), d3, hf1.y), d4, hf1.z);\n    vec3 dirtCol = mix(dirtCol1, dirtCol2, hf2.x);\n    dirtCol = mix(dirtCol, dirtCol*dirtCol, clamp((hf3.x*hf3.y*hf3.z)*3., 0.0, 1.0));\n    \n    float dirtReg1 = smoothstep(0.38 + (grain2.x*0.1), (0.5 + grain2.y*0.02), lf4.y);\n    dirtReg1 = mix(dirtReg1, dirtReg1*smoothstep(0.38, 0.5, lf3.x), lf4.z);\n   float dirtReg2 = smoothstep(0.38 + (grain2.x*0.07), 0.9 - (grain2.y*0.2), lf3.x);\n     dirtReg2 = clamp(dirtReg2*1.5, 0.0, 1.0);\n    dirtReg2 *= smoothstep(0.41, 0.49, lf4.x);\n    \n    float dirtReg = mix(dirtReg1, dirtReg2, lf4.z);\n    dirtReg = clamp((dirtReg * (1.0 + dirtF)) + (dirtF*0.5), 0.0, 1.0);\n    float dark = clamp((warp.x*grain2.y*lf1.x*lf1.y)*1.6, 0.0, 1.0);\n    \n    col += grassCol;\n    col = mix(col, dirtCol, dirtReg);\n    \n    col = mix(col, col*col, dark);\n    \n    if (lod < 0.015) return col;\n    \n    float tile = (32.0 * (0.5+(lf1.x*0.5)))*6.;\n    vec2 id = floor(uv*tile);\n    vec2 lv = fract(uv*tile);\n    vec2 alv = abs(lv*2.0-1.0);\n    vec2 slv = lv*lv*(3.0-2.0*lv);\n    \n    float seed = 0.3887276;\n    float idr = lod < 0.3 ? 0.0828711 : mix(\n        mix(rand(id, seed), rand(id+vec2(1, 0), seed), slv.x),\n        mix(rand(id+vec2(0, 1), seed), rand(id+vec2(1, 1), seed), slv.x),\n        slv.y\n    );\n    \n    vec2 off = vec2(cos(idr*2.), sin(idr*2.));\n    \n    float line = line2D(alv, vec2(0.0), off, 0.1 + (hf3.x*0.1));\n    col = mix(col, clamp((col+col)*lf1.z, 0.0, 1.0), line);\n    \n    float crust = fract(dot(off, alv)*TAU);\n    crust = smoothstep(0.5, 1., crust)*warp.x;\n    \n    col = mix(col, d2, crust);\n    col = mix(col, col*col, smoothstep(0.2, 0.8, lf4.x)*lf4.y);\n    \n    m.spec = clamp((pow(dirtReg*lf1.x*warp.z, 2.5)*0.8)+pow(lf2.x*lf1.x*lf1.y*lf1.z, 1.6), 0.0, 1.0);\n    \n    float z = (dirtReg*0.0009);\n    m.z = z;\n    return col;\n}\n\nvec3 getAlbedoGround(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n\n    float lod = 1.0/max(0.0001, data.d);\n    vec3 col = grassTexture(uv, p, data.m, 0.1, lod);\n    \n    data.n = makeNormal(data.n, data.m.z, 0.7, 0.5);\n    \n    return col;\n}\n\nvec3 getAlbedoBox(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    vec3 col = texture(iChannel3, uv).rgb;\n    \n    return col;\n}\n\nvec3 getAlbedoTree(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    float lod = 1.0/max(0.0001, data.d);\n    \n    vec3 col = barkTexture(uv, p, data.m, lod);\n    \n    data.n = makeNormal(data.n, data.m.z, 0.7, 0.5);\n    \n    return col;\n}\n\nvec3 getAlbedoTreeLeaf(inout Data data) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec2 uv = data.uv;\n    \n    vec3 col = leafTexture(uv, p, data.m);\n    \n    return col;\n}\n\nvec3 getAlbedo(inout Data data) {\n    switch (data.id) {\n        case ID_GROUND: return getAlbedoGround(data); break;\n        case ID_BOX: return getAlbedoBox(data); break;\n        case ID_TREE: return getAlbedoTree(data); break;\n        case ID_TREE_LEAF: return getAlbedoTreeLeaf(data); break;\n    }\n    \n    return vec3(0.77);\n}\n\nvec3 getSky(in vec3 rd) {\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    vec3 col = pow(vec3(0.29, 0.61, 0.9), vec3(1.0 + dotup));\n    return col;\n}\n\nvec3 forEachLight(in Data data, in Light light, in vec3 ro, in vec3 rd, in vec3 diffuse) {\n    vec3 p = data.p;\n    vec3 n = data.n;\n    vec3 L = getLightDir(light, p);\n    vec3 ref = reflect(L, n);\n    float VdotR = cdot(rd, ref);\n    float spec = data.m.spec * pow(VdotR, 64.0);\n    vec3 att = getLightAtt(light, p, n);\n    float shadow = getShadow(p + (n*NEAR*2.), L, data.n, data.d, light.type == LIGHT_AMBIENT ? FAR :\n        distance(light.p, p), data.id);\n        \n    return (diffuse + spec) * att * shadow;\n}\n\nvec3 render(inout Data data, in vec3 ro, in vec3 rd, inout float depth) {\n    vec3 col = vec3(0.0);\n    float dotup = cdot(rd, vec3(0, 1, 0));\n    \n    Light light = Light(vec3(1, 2, -3), vec3(0.0), vec3(0.97, 0.89, 0.79), 2.0, LIGHT_AMBIENT);\n    \n    if (march(data, ro, rd)) {\n        vec3 albedo = getAlbedo(data);\n        vec3 diffuse = albedo / M_PI;\n        \n        col += forEachLight(data, light, ro, rd, diffuse);\n    } else {\n        col += getSky(rd);\n    }\n    \n    depth = data.d / FAR;\n    \n    col += smoothstep(0.1, 0.9, depth)*depth*max(0.0, 1.0-smoothstep(0.0, 0.5, dotup))*light.c;\n    \n    return col;\n}\n\nvoid getRay(in vec2 uv, in vec4 m, inout vec3 ro, inout vec3 rd) {\n    ro = vec3(0, 0, -7.0);\n    rd = normalize(vec3(uv.xy, 1.0));\n    \n    \n    float time = T*0.5;\n    ro.z = 0.;\n    ro.y = 2.0 + (sin(time));\n    ro.x += cos(time*2.)*3.;\n    ro.z += (time*6.3)-0.5;\n\n   \n   \n\n    if (length(m.xy) > 0.001 && m.z > 0.01 && iFrame > 1 && iTime > 0.00003) {\n      //  ro.yz *= rot(m.y*TAU);\n       // ro.xz *= rot(m.x*TAU);\n\n        rd.yz *= rot(m.y*TAU);\n        rd.xz *= rot(m.x*TAU);\n\n    } else {\n        rd.xz *= rot(cos(time*0.5)*0.2);\n    }\n}\n\nvec4 shade(in vec2 fc )\n{\n    vec3 col = vec3(0.0);\n    vec2 uv = (fc-0.5*R.xy)/R.y;\n    vec4 m = vec4((iMouse.xy-0.5*R.xy)/R.y, iMouse.zw);\n    \n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    getRay(uv, m, ro, rd);\n    Data data = NEW_DATA;\n    data.ro = ro;\n    data.rd = rd;\n    float depth = 1.0;\n    \n    #ifdef DEBUG_TEXTURE\n    Material ma = NEW_MATERIAL;\n    col += DEBUG_TEXTURE(fc.xy/R.xy, ro+rd, ma);\n    #else\n    col += render(data, ro, rd, depth);\n    col += (col*luma(col));\n    col = aces(col);\n    col = pow(col, vec3(1.0 / 2.2));\n    #endif\n    \n    \n    return vec4(clamp(col, 0.0, 1.0), depth);\n}\n\n\nvoid mainImage( out vec4 O, in vec2 fc )\n{\n    #if AA_ENABLED\n    O = vec4(0);\n    float samples = 2.0;\n    float siz = 1.0/samples;\n    float x = 0.0;\n    float y = 0.0;\n    for (x =- 0.5; x < 0.5; x += siz) {\n        for (y= - 0.5; y < 0.5; y += siz) {\n            O += min(shade(vec2(x,y)+fc), 1.0);\n        }\n    }\n\tO /= samples*samples;\n    #else\n    O = shade(fc);\n    #endif\n}\n","name":"Buffer A","description":"","type":"buffer"}]}