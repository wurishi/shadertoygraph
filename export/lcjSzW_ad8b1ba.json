{"ver":"0.1","info":{"id":"lcjSzW","date":"1706113536","viewed":271,"name":"Pool Rooms VHS","username":"FrederickAmpsUp","description":"Pool rooms with post-processing and sound.","likes":5,"published":1,"flags":40,"usePreview":0,"tags":["liminal","backrooms"],"hasliked":0,"parentid":"lcSXz1","parentname":"Pool Rooms"},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// thanks to https://www.shadertoy.com/view/ls3GWS\n\n#define FXAA_SPAN_MAX 8.0\n#define FXAA_REDUCE_MUL   (1.0/FXAA_SPAN_MAX)\n#define FXAA_REDUCE_MIN   (1.0/128.0)\n#define FXAA_SUBPIX_SHIFT (1.0/4.0)\n\nvec3 FxaaPixelShader( vec4 uv, sampler2D tex, vec2 rcpFrame) {\n    \n    vec3 rgbNW = textureLod(tex, uv.zw, 0.0).xyz;\n    vec3 rgbNE = textureLod(tex, uv.zw + vec2(1,0)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSW = textureLod(tex, uv.zw + vec2(0,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbSE = textureLod(tex, uv.zw + vec2(1,1)*rcpFrame.xy, 0.0).xyz;\n    vec3 rgbM  = textureLod(tex, uv.xy, 0.0).xyz;\n\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    float dirReduce = max(\n        (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL),\n        FXAA_REDUCE_MIN);\n    float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n    \n    dir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n          max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n          dir * rcpDirMin)) * rcpFrame.xy;\n\n    vec3 rgbA = (1.0/2.0) * (\n        textureLod(tex, uv.xy + dir * (1.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (2.0/3.0 - 0.5), 0.0).xyz);\n    vec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) * (\n        textureLod(tex, uv.xy + dir * (0.0/3.0 - 0.5), 0.0).xyz +\n        textureLod(tex, uv.xy + dir * (3.0/3.0 - 0.5), 0.0).xyz);\n    \n    float lumaB = dot(rgbB, luma);\n\n    if((lumaB < lumaMin) || (lumaB > lumaMax)) return rgbA;\n    \n    return rgbB; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rcpFrame = 1./iResolution.xy;\n  \tvec2 uv2 = fragCoord.xy / iResolution.xy;\n    \n    vec4 uv = vec4( uv2, uv2 - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));\n    vec3 col = FxaaPixelShader( uv, iChannel0, 1./iResolution.xy );\n    \n    fragColor = vec4( col, 1. );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define STEPS 25\n\n#define MISS 1000.0\n#define SURF 0.01\n\n#define SQRT_SAMPLES sqrt(4.0)\n#define GI_STRENGTH 1.0\n#define GI_MAX_DST 10.0\n\n#define FOG_COLOR vec3(0.2)\n#define FOG_START 5.0\n#define FOG_END 15.0\n\n#define CAM_POS vec3(0.0, 0.7, iTime)\n\nstruct Material {\n    vec3 colDiffuse;\n    vec3 colEmission;\n    \n    vec3 colSpecular;\n    vec3 colRefraction;\n};\n\nstruct Light {\n    vec3 pos;\n    vec3 col;\n    \n    float size;\n};\n\n#define N_LIGHTS 3\nLight lights[N_LIGHTS] = Light[N_LIGHTS](\n    Light(vec3(0.0, 2.0, 10.0), vec3(0.12, 0.1, 0.1), 0.25),\n    Light(vec3(0.0, 2.0,  5.0), vec3(0.12, 0.1, 0.1), 0.25),\n    Light(vec3(0.0, 2.0,  0.0), vec3(0.12, 0.1, 0.1), 0.25)\n);\nstruct SDF3d {\n    float dist;\n    Material mat;\n};\n\nfloat gaussian(float x, float mu, float sigma) {\n    return exp(-0.5 * pow((x - mu) / sigma, 2.0)) / (sigma * sqrt(2.0 * 3.14159265359));\n}\n\nfloat gaussian(float x) {\n    return gaussian(x, 0.0, 0.3);\n}\n\nstruct Hit {\n    bool hit;\n    vec3 pos;\n    float dst;\n    float surf;\n    vec3 norm;\n    \n    Material mat;\n};\n\nstruct Ray {\n    vec3 org;\n    vec3 dir;\n};\n\nSDF3d sdSphere(vec3 p, vec3 c, float r, Material mat) {\n    SDF3d sdf;\n    sdf.dist = length(p - c) - r;\n    sdf.mat = mat;\n    \n    return sdf;\n}\n\nSDF3d sdBox( vec3 p, vec3 b, Material mat ) {\n    vec3 q = abs(p) - b;\n    return SDF3d(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), mat);\n}\n\nSDF3d sdBox( vec3 p, vec3 b ) {\n    return sdBox(p,b,Material(vec3(1), vec3(0), vec3(0), vec3(0)));\n}\n\nSDF3d sdSphere(vec3 p, vec3 c, float r) {\n    return sdSphere(p, c, r, Material(vec3(1), vec3(0), vec3(0), vec3(0)));\n}\n\nMaterial mix(Material m1, Material m2, float t) {\n    return Material(mix(m1.colDiffuse, m2.colDiffuse, t), mix(m1.colEmission, m2.colEmission, t), mix(m1.colSpecular, m2.colSpecular, t), mix(m1.colRefraction, m2.colRefraction, t));\n}\n\nSDF3d mix(SDF3d d1, SDF3d d2, float t) {\n    return SDF3d(mix(d1.dist, d2.dist, t), mix(d1.mat, d2.mat, t));\n}\n\nSDF3d opUnion(SDF3d obj1, SDF3d obj2) {\n    return mix(obj2, obj1, float(obj1.dist < obj2.dist));\n}\n\nvec3 rotateY(in vec3 p, in float t) {\n    float cosT = cos(t), sinT = sin(t);\n    return vec3(p.x * cosT - p.z * sinT, p.y, p.x * sinT + p.z * cosT);\n}\n\nfloat tilePattern(vec3 position, float sharpness) {\n    vec3 fractionalPart = fract(position);\n    vec3 smoothstepValues = smoothstep(0.0, sharpness, fractionalPart);\n    \n    return smoothstepValues.x * smoothstepValues.y * smoothstepValues.z;\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\nfloat lerp(float a, float b, float k) { return mix(a,b,k); }\n\nfloat noise( vec3 x ) {\n    // The noise function returns a value in the range -1.0f -> 1.0f\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    return lerp(lerp(lerp( hash(n+0.0), hash(n+1.0),f.x),\n        lerp( hash(n+57.0), hash(n+58.0),f.x),f.y),\n        lerp(lerp( hash(n+113.0), hash(n+114.0),f.x),\n        lerp( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\nfloat time;\nSDF3d map(vec3 p, bool shadow, bool norm) {\n    // cornell box scene to demonstrate global illumination\n    SDF3d scene;\n    \n    scene.dist = p.y + 0.5;\n    scene.dist -= 0.005 * tilePattern(vec3(p.xz, 0.1) * 5.0, 0.05);\n    \n    scene.dist = min(scene.dist, p.x + 2.0);\n    scene.dist = min(scene.dist,-p.x + 2.0);\n    \n    scene.dist -= 0.005 * tilePattern(vec3(p.zy, 0.1) * 5.0, 0.05);\n    scene.mat.colSpecular = vec3(0.4);\n    scene.mat.colDiffuse = vec3(0.9);\n    \n    SDF3d ceiling = SDF3d(-p.y + 2.0, Material(vec3(1.0), vec3(0), vec3(0), vec3(0)));\n    scene = opUnion(scene, ceiling);\n    \n    SDF3d water;\n    if (p.y < 1.0)\n        water = SDF3d(p.y + 0.1*noise(vec3(p.xz * 2.0, time*1.5)) - 0.2, Material(vec3(0), vec3(0), vec3(0.2), vec3(0.0, 0.5, 0.8)));\n    else \n        water = SDF3d(p.y, Material(vec3(0), vec3(0), vec3(0.2), vec3(0.0, 0.5, 0.8)));\n    if (((water.dist > 0.0) || (norm && water.dist > -10.0 * SURF)) && !shadow)\n        scene = opUnion(scene, water);\n\n    if (!shadow)\n    for (int light = 0; light < N_LIGHTS; light++) {\n        Light l = lights[light];\n        scene = opUnion(scene, sdBox(p - l.pos - vec3(0.0, 0.05, 0.0), vec3(0.5, 0.1, 0.5), Material(vec3(0), l.col * 10.0, vec3(0), vec3(0))));\n    }\n    \n    return scene;\n}\nSDF3d map(vec3 p, bool shadow) {\n    return map(p, shadow, false);\n}\n\nvec3 normal(vec3 pos, float dist) {\n    float epsilon = SURF*2.0;\n    return normalize(\n        vec3(\n            dist - map(pos - vec3(epsilon, 0, 0), false, true).dist,\n            dist - map(pos - vec3(0, epsilon, 0), false, true).dist,\n            dist - map(pos - vec3(0, 0, epsilon), false, true).dist\n        )\n    );\n}\n\n    // https://iquilezles.org/articles/rmshadows/\nvec3 shadow(Ray r, float maxt, float w )\n{\n    vec3 ro = r.org;\n    vec3 rd = r.dir;\n\n    float res = 1.0;\n    float t = 2.0 * SURF;\n    for( int i=0; i<STEPS && t<maxt; i++ )\n    {\n        float h = map(ro + t*rd, true, false).dist;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return vec3(0.25*(1.0+res)*(1.0+res)*(2.0-res));\n}\n\nHit march(Ray r) {\n    float t = 0.0;\n    vec3 pos;\n    \n    Hit hit;\n    SDF3d scene;\n    \n    for (int i = 0; i < STEPS; i++) {\n        pos = r.org + r.dir * t;\n        scene = map(pos, false);\n        scene.dist = abs(scene.dist);\n        \n        if (scene.dist < SURF || scene.dist > MISS || t > MISS) break;\n        t += scene.dist;\n    }\n    hit.hit = scene.dist < MISS;\n    hit.pos = pos;\n    hit.dst = t;\n    hit.surf = scene.dist;\n    if (!hit.hit) hit.dst = -1.0;\n    if (hit.hit) hit.norm = normal(pos, scene.dist);\n    hit.mat = scene.mat;\n    \n    return hit;\n}","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// GI buffer\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    lights[0].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 15.0;\n    lights[1].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 10.0;\n    lights[2].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 5.0;\n\n    time = iTime;\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= iResolution.x / iResolution.y;\n\n    Ray cam = Ray(CAM_POS, normalize(vec3(ndc, 1.0)));\n    Hit hit = march(cam);\n    \n    vec3 gi = vec3(0.0);\n    float samples = 0.0;\n\n    if (hit.hit && hit.dst < GI_MAX_DST)\n    for (float x = -1.0; x <= 1.0; x += 2.0 / SQRT_SAMPLES) {\n        for (float y = -1.0; y <=  1.0; y += 2.0 / SQRT_SAMPLES) {\n            vec3 N = hit.norm;\n            vec3 tan0 = normalize(cross(N, normalize(vec3(0.1,0.2,0.3))));\n            vec3 tan1 = normalize(cross(N, tan0)); // https://www.desmos.com/3d/5f2b601762\n\n            vec3 sampleD = tan0*x + tan1*y + (1.0 - length(vec2(x,y))/sqrt(2.0)) * N;\n            if (dot(sampleD, hit.norm) < 0.0) continue;\n\n            Ray coneRay = Ray(hit.pos + hit.norm * 2.0 * SURF, normalize(sampleD));\n            Hit cHit = march(coneRay);\n            if (!cHit.hit) continue;\n\n            vec3 cDirect = vec3(0.0);\n\n            for (int cLight = 0; cLight < N_LIGHTS; cLight++) {\n                Light cL = lights[cLight];\n                vec3 cDirToLight = normalize(cL.pos - cHit.pos);\n                float cDiffuse = max(0.0, dot(cHit.norm, cDirToLight));\n                cDiffuse /= dot(cL.pos - cHit.pos, cL.pos - cHit.pos);\n                vec3 cShadowT = shadow(Ray(cHit.pos, cDirToLight), length(cL.pos - cHit.pos), cL.size);\n\n                cDirect += cHit.mat.colDiffuse * cL.col * max(vec3(0.3), cShadowT);\n            }\n            cDirect *= float(cHit.hit);\n            vec3 cEmitted = cHit.mat.colEmission;\n            cEmitted *= float(cHit.hit);\n            samples += 1.0;\n            gi += hit.mat.colDiffuse * cDirect;\n            gi += hit.mat.colDiffuse * cEmitted;\n        }\n    }\n    else {\n        samples = 1.0;\n        gi = vec3(0.3);\n    }\n    gi /= samples;\n    gi += hit.mat.colEmission;\n    gi *= float(hit.hit) * GI_STRENGTH;\n    \n    fragColor = vec4(max(gi, vec3(0.0)), 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Diffuse/specular buffer\n\n#define BLUR_SIZE 5\n\n    // https://www.shadertoy.com/view/Xltfzj\nvec4 blur(sampler2D textureSampler, vec2 uv, float Size) {\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 32.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 8.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    // Pixel colour\n    vec4 Color = texture(iChannel0, uv);\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tColor += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i);\t\t\n        }\n    }\n    \n    // Output to screen\n    Color /= Quality * Directions - 15.0;\n    return Color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 ndc = 2.0 * uv - 1.0;\n    float rat = iResolution.x / iResolution.y;\n    ndc.x *= rat;\n    \n    time = iTime;\n    lights[0].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 15.0;\n    lights[1].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 10.0;\n    lights[2].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 5.0;\n\n    Ray cam = Ray(CAM_POS, normalize(vec3(ndc, 1.0)));\n    Hit hit = march(cam);\n    \n    vec3 direct = vec3(0.0);\n\n    for (int light = 0; light < N_LIGHTS; light++) {\n        Light l = lights[light];\n        vec3 dirToLight = normalize(l.pos - hit.pos);\n        float diffuse = max(0.0, dot(hit.norm, dirToLight));\n        diffuse /= dot(l.pos - hit.pos, l.pos - hit.pos);\n        vec3 shadowT = shadow(Ray(hit.pos, dirToLight), length(l.pos - hit.pos), l.size);\n\n        direct += hit.mat.colDiffuse * shadowT * diffuse * l.col;\n    }\n    direct *= float(hit.hit);\n        \n        // get blurred GI data to help with some artifacts of low samplerate\n    vec3 gi = blur(iChannel0, uv, 32.0).xyz*(hit.mat.colDiffuse + hit.mat.colEmission);\n\n    vec3 emitted = hit.mat.colEmission;\n    emitted *= float(hit.hit);\n    \n    Hit orig = hit;\n    \n    vec3 refracted = orig.mat.colRefraction * float(orig.hit);\n    vec3 directRefr = vec3(0.0);\n    cam.org = orig.pos - orig.norm * orig.surf * 1.1;\n    cam.dir = refract(cam.dir, orig.norm, 1.0/1.05);\n    hit = march(cam);\n    for (int light = 0; light < N_LIGHTS; light++) {\n        Light l = lights[light];\n        vec3 dirToLight = normalize(l.pos - hit.pos);\n        float diffuse = max(0.0, dot(hit.norm, dirToLight));\n        vec3 shadowT = shadow(Ray(hit.pos+hit.norm*SURF*2.0, dirToLight), length(l.pos - hit.pos), l.size);\n        \n        directRefr += hit.mat.colDiffuse * shadowT * diffuse * l.col * 2.0;\n    }\n    directRefr *= float(hit.hit);\n    refracted *= directRefr + hit.mat.colEmission;\n    refracted *= float(hit.hit);\n    \n    vec3 color = direct + emitted + refracted + gi;\n    \n    fragColor = vec4(color, orig.dst);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 ndc = uv * 2.0 - 1.0;\n    float rat = iResolution.x / iResolution.y;\n    ndc.x *= rat;\n    \n    time = iTime;\n    lights[0].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 15.0;\n    lights[1].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 10.0;\n    lights[2].pos.z = floor((CAM_POS.z - 1.0)/5.0)*5.0 + 5.0;\n    \n    vec4 data = texture(iChannel0, uv);\n    vec3 color = data.xyz;\n    float depth = data.w;\n    \n    Ray cam = Ray(CAM_POS, normalize(vec3(ndc, 1.0)));\n    vec3 pos = cam.org + cam.dir * depth;\n    \n    SDF3d sdf = map(pos, false, true);\n    Hit hit = Hit(\n        depth > 0.0,\n        pos,\n        depth,\n        sdf.dist,\n        normal(pos, sdf.dist),\n        \n        sdf.mat\n    );\n    \n    Hit orig = hit;\n    \n    vec3 specular = hit.mat.colSpecular * float(hit.hit);\n    vec3 directRefl = vec3(0.0);\n    cam.org = hit.pos + hit.norm * 2.0 * SURF;\n    cam.dir = reflect(cam.dir, hit.norm);\n    hit = march(cam);\n    vec3 camSpace = hit.pos - CAM_POS;\n    vec2 hitNdc = camSpace.xy / camSpace.z;\n    if (hitNdc.x/rat > -1.0 && hitNdc.x/rat < 1.0 && hitNdc.y > -1.0 && hitNdc.y < 1.0) {\n        // Screenspace for higher quality\n        specular *= texture(iChannel0, hitNdc * 0.5 + 0.5).xyz;\n        //specular = vec3(hitNdc * 0.5 + 0.5, 0.0);\n    } else {\n        for (int light = 0; light < N_LIGHTS; light++) {\n            Light l = lights[light];\n            vec3 dirToLight = normalize(l.pos - hit.pos);\n            float diffuse = max(0.0, dot(hit.norm, dirToLight));\n            diffuse /= dot(l.pos - hit.pos, l.pos - hit.pos);\n            vec3 shadowT = shadow(Ray(hit.pos, dirToLight), length(l.pos - hit.pos), l.size);\n\n            directRefl += hit.mat.colDiffuse * max(vec3(0.3), shadowT * diffuse) * l.col;\n        }\n        directRefl *= float(hit.hit);\n        specular *= directRefl + hit.mat.colEmission + 0.3*hit.mat.colRefraction;\n        specular *= float(hit.hit);\n        specular *= 0.0;\n    }\n    \n    color += specular;\n    \n        // distance fog\n    color = mix(color, FOG_COLOR, smoothstep(FOG_START, FOG_END, depth));\n    color = pow(color, vec3(1.0 / 2.2));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// post-processing for that VHS look\n\nfloat random(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv.y += 0.5*pow(1.0-0.8*abs(uv.x-random(vec2(iFrame/int(random(vec2(iFrame))*10.0), uv.x))), 500.0);\n    uv.x += 0.001*sin((uv.y+iTime)*314.1);\n\n    // Sample the input texture\n    vec3 color = vec3(0.0);\n    vec3 offset = vec3(1.0,-1.0,0.0) / iResolution.xyx;\n    color += texture(iChannel0, uv+offset.yy).xyz;\n    color += texture(iChannel0, uv+offset.zy).xyz;\n    color += texture(iChannel0, uv+offset.xy).xyz;\n    color += texture(iChannel0, uv+offset.yz).xyz;\n    color += texture(iChannel0, uv+offset.zz).xyz;\n    color += texture(iChannel0, uv+offset.xz).xyz;\n    color += texture(iChannel0, uv+offset.yx).xyz;\n    color += texture(iChannel0, uv+offset.zx).xyz;\n    color += texture(iChannel0, uv+offset.xx).xyz;\n    color /= 8.0;\n\n    // Simulate film grain\n    float grain = 0.03 * (0.5 - random(uv));\n    color += grain;\n    \n    color += vec3(0.02, 0.0, 0.0);\n    float scareFactor = pow(random(vec2(iTime/1250.0)), 50.0);\n    color *= vec3(1.0, 1.0-scareFactor, 1.0-scareFactor);\n    color -= mod(color, 1.0 / 16.0);\n\n    fragColor = vec4(color, 1.0);\n}","name":"Buffer D","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat random(vec2 seed)\n{\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float sound = random(vec2(mod(float(samp), 500.0)*2.0))*0.05;\n    \n    float scareFactor = pow(random(vec2(time/1250.0)), 50.0);\n    vec2 scare = vec2(sin(6.28*1200.0*(1.0-scareFactor)*time));\n    return vec2(sound) + scare;\n}","name":"Sound","description":"","type":"sound"}]}