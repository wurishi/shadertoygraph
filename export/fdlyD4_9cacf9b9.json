{"ver":"0.1","info":{"id":"fdlyD4","date":"1642165364","viewed":158,"name":"Julia Over Water","username":"drcd1","description":"A Julia Set, rendered over a body of water","likes":7,"published":1,"flags":32,"usePreview":0,"tags":["sdf","juliaset","reflections"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float toSRGB(float d){\n\tif(d <=  0.0031308\t)\n        return d*12.92;\n    else\n        return pow(d, (1.0/2.4))*1.055-0.055;\n}\n\n#define M_PI 3.14159\n\nvec3 convertToACES(vec3 x){\n\t\n\tx.x = toSRGB(x.x);\n\tx.y = toSRGB(x.y);\n\tx.z = toSRGB(x.z);\n/*\n\tx = ACESInputMat*x;\n\tvec3 a = x * (x + 0.0245786f) - 0.000090537f;\n    vec3 b = x * (0.983729f * x + 0.4329510f) + 0.238081f;\n\tx =  a / b;\n\t\n\tx = ACESOutputMat*x;\n*/\treturn clamp(x,0.0f,1.0f);\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n\n    // Output to screen\n    fragColor = vec4(convertToACES(col.rgb/col.a),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define M_PI 3.14159\n\nvec3 ortho(vec3 v) {\n    //  See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n    return abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)  : vec3(0.0, -v.z, v.y);\n}\n\nint t = 2;\n\n//see https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat random (vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 fragPos;\n\nfloat getRandom(){\n\tt++;\n\treturn random(fragPos.xy + vec2(t,mod(float(iFrame),400.0)));\t\n}\n\nstruct Ray{\nvec3 o;\nvec3 d;\nfloat t;\n};\n\nRay create_ray(vec3 o, vec3 d){\n    Ray tmp;\n  tmp.o = o;\n  tmp.d = d;\n  tmp.t= 1000.0; \n  return tmp;\n}\n\n\nstruct Camera{\n    vec3 origin;\n    mat3 rotation;\n\n};\n\nCamera create_camera(vec3 origin, vec3 lookAt, vec3 up){\n    vec3 z = normalize(-lookAt);\n    vec3 x = normalize(cross(up,z));\n    vec3 y = normalize(cross(z,x));\n    \n    Camera c;\n    c.origin = origin;\n    c.rotation = transpose(mat3(x.x,y.x,z.x,\n                      x.y,y.y,z.y,\n                      x.z,y.z,z.z));\n    return c;\n\n}\nRay generate_ray(vec2 uv, Camera c){\n    vec3 direction = vec3(uv.x,uv.y,-1.0);\n    vec3 origin = c.origin;\n    direction = normalize(c.rotation*direction);\n    return create_ray(origin,direction);\n}\n\nfloat plane_sdf(vec3 p, vec3 center, vec3 normal){\n    vec3 n = normalize(normal);\n    return dot(p-center,n);\n}\n\n\n\n\nfloat direction[20] = float[](1.0,0.2,\n                             1.0,-1.0,\n                             -2.0,-4.0,\n                             -5.0,2.0,\n                             -1.0,-2.0,\n                             \n                             -1.0,3.0,\n                             1.0,-4.0,\n                             -3.0,4.0,\n                             5.0,-1.0,\n                             -3.0,-2.0);\n                             \n                             \n                             \nfloat speed[10] = float[](0.01,0.01,0.01,1.0,1.0,\n                         1.0,1.0,1.0,1.0,1.2);\nfloat freq[10] = float[](0.05,0.05,0.05,2.5,1.4,\n                        5.0,6.2,9.2,5.2,10.34);\nfloat amp[10] = float[](0.02, 0.02,0.02,0.0,0.0,\n                       0.00, 0.00,0.0,0.0,0.0);\n#define N_WAVES 3\n\nfloat sdf2(vec3 p){\n    \n    \n    float def = 0.0;//cos(dot(p.xy,dir)*freq[i]+ iTime*speed[i]);\n    for(int i = 0; i<3; i++){\n        vec2 dir = normalize(vec2(direction[2*i],direction[2*i+1]));\n        vec2 uv_n = p.xy*freq[i]+dir*iTime*speed[i];\n        \n        uv_n = fract(uv_n*0.5)*1.9+0.05;\n        uv_n.x = uv_n.x>1.0? 2.0-uv_n.x:uv_n.x;\n        uv_n.y = uv_n.y>1.0? 2.0-uv_n.y:uv_n.y;\n\n         //somehow, if calling texture and not textureLod, everything breaks, but only if I also add\n         // the sine term below\n         \n         //also: waves are just overlays of the texture in channel 1 :)\n         def = textureLod(iChannel1,uv_n,0.0).r*2.0;\n\n        p.z = p.z + def*amp[i];\n    }\n    \n    //radial waves\n    float len_sq = dot(p.xy,p.xy);\n    float helper_sin = sin(len_sq*10.0-iTime*3.0);\n    p.z = p.z + exp(-len_sq*2.0)*(helper_sin*0.5+0.5)*0.2;\n    \n    return plane_sdf(p, vec3(0.0),vec3(0.0,0.0,1.0))*0.8;\n}\n/*\n\nvec4 qMult(vec4 q1, vec4 q2){\n    return vec4(\n    q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y,\n    q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x,\n    q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w,\n    q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n    \n\n}*/\n\n\n/* copied from https://www.shadertoy.com/view/MsfGRr*/\nvec4 qmul( in vec4 a, in vec4 b)\n{\n    return vec4(\n        a.x * b.x - a.y * b.y - a.z * b.z - a.w * b.w,\n        a.y * b.x + a.x * b.y + a.z * b.w - a.w * b.z, \n        a.z * b.x + a.x * b.z + a.w * b.y - a.y * b.w,\n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y );\n\n}\nfloat julia_sdf(vec3 p){\n\n\n    p.z = p.z-1.3;\n    float w_coord = 0.0;\n    vec4 c = vec4 (0.1+ sin(iTime*0.7)*0.5,cos(iTime*0.9)*0.5+0.5,0.7+cos(iTime*1.3)*0.5,0.0);\n    vec4 q  = vec4(p,w_coord);\n    float dq = 1.0;\n    float lq = dot(q,q);\n    for(int i = 0; i<7; i++){\n        q = qmul(q,q) + c;\n        lq = dot(q,q);\n        dq = 2.0*dq*lq;\n        if(lq > 4.0){\n            break;\n        }\n        \n    }\n    \n    return  0.25*sqrt(lq/dq)*log(sqrt(lq));\n    \n\n}\n\n\nfloat sdf(vec3 p){\n   return min(sdf2(p), julia_sdf(p));\n}\n\n\nvec3 albedo_sdf(vec3 p){\n    float d1 = sdf2(p);\n    if(d1>0.1){\n        return vec3(0.8,0.8,0.8);\n    } else {\n        //code for water\n        return vec3(-1.0,0.0,0.0);\n    }\n}\n\n#define EPS 0.01\n#define STEPS 200\nint sphere_march(vec3 o, vec3 d, inout vec3 p){\n        p = o;float dist = 1000.0;\n        int i = 0;\n        while(i<STEPS){\n            dist= sdf(p);\n            p+=d*dist;\n            if(dist<EPS){\n                break;\n            }\n            \n            if(dist<0.01){\n                p+=d*0.01;\n            }\n            i++;\n        }\n        if(dist<EPS){\n            return i;\n        } else {\n            return -1;\n        }\n}\n\n\n//we could and should do this analitically...\n// but we don't\nvec3 compute_gradient(vec3 p){\n    float a = sdf(p);\n    float b = sdf(p+vec3(EPS,0.0,0.0));\n    float c = sdf(p+vec3(0.0,EPS,0.0));\n    float d = sdf(p+vec3(0.0,0.0,EPS));\n    return normalize(vec3(b-a,c-a,d-a));\n}\n\n\n//sky is just two lerped colors\nvec3 sky(vec3 d){\n    vec3 top = vec3(0.4,0.6,0.9);\n    vec3 bottom = vec3(1.0,1.0,1.0);\n    float t = clamp(d.z,0.0,1.0);\n    t= pow(t,0.5);\n    return top*(t) + bottom*(1.0-t);\n}\n\n\n\nvec3 solid_angle(float u1, float u2, vec3 normal, float angle){\nvec3 tan = ortho(normal);\n\tvec3 cotan = cross(normal, tan);\n\tmat3 m;\n\tm[0] = tan;\n\tm[1] = cotan;\n\tm[2] = normal;\n\t\n\t\n\tfloat phi = angle*u1;\n\tfloat theta = M_PI*2.0f*u2;\n    return m*vec3(sin(phi)*cos(theta), sin(phi)*sin(theta), cos(phi));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord + vec2(getRandom(),getRandom()))/iResolution.xy;\n    fragPos.xy = uv;\n    uv= uv*2.0-1.0;\n    uv = uv*0.5;\n    \n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 orig = vec3(vec2(cos(iTime*0.5),sin(iTime*0.5))*4.0,1.0);\n    vec3 at = normalize(vec3(0.0,0.0,1.0)-orig);\n    \n    Camera c = create_camera(orig,at, vec3(0.0,0.0,1.0));\n    Ray r = generate_ray(uv, c);\n    \n    vec3 p;\n    vec3 col = vec3(0.0);\n      \n    //stochastic soft shadows\n    //vec3 ld = solid_angle(getRandom(),getRandom(), normalize(vec3(-3.0,3.0,3.0)),0.001);\n    \n    vec3 ld = normalize(vec3(-3.0,3.0,3.0));\n    \n    int iter = sphere_march(r.o,r.d,p);\n    \n    vec3 mul = vec3(1.0);\n    \n    \n    //let's allow for one interreflection in the water\n    for(int k = 0; k<3; k++) {\n        \n    int iter = sphere_march(r.o,r.d,p);\n    if(iter!=-1){\n        vec3 albedo = albedo_sdf(p);\n        vec3 n = compute_gradient(p);\n        if(dot(n,r.d)>0.0){\n            n = -n;\n        }\n        \n        if(albedo.r>=0.0){\n            Ray shadow_ray = create_ray(p+(ld)*0.02,(ld));\n            vec3 p2;\n            if(-1==sphere_march(shadow_ray.o,shadow_ray.d,p2)){\n             col += vec3(albedo*clamp(dot(n,ld),0.0,1.0))*vec3(1.0,0.9,0.7)*2.0;\n            }\n            \n            //t1 is supposed to be ~AO, will update this\n            float t1 = clamp((float(STEPS-iter-1)/float(STEPS-1)),0.0,1.0);\n            \n            //fake GI\n            float t2 = n.z*2.0+1.0;\n                               //fake GI color1        fake GI color 2   \n            col += t1*(t2*vec3(0.5,0.64,0.7) + (1.0-t2)*vec3(0.5,0.5,0.5));\n            break;\n        }\n       // \n       // vec3 p2;\n       // if(!sphere_march(shadow_ray.o,shadow_ray.d,p2)){\n       //     col += vec3(albedo*clamp(dot(n,ld),0.0,1.0))*vec3(1.0,0.9,0.7)*2.0;\n       // }\n        \n        vec3 r_dir = r.d - dot(r.d,n)*n*2.0;\n        vec3 o = p + n*0.05;\n        r = create_ray(o,r_dir);\n        \n        //do this if just reflecting the sky\n        //col = mul*sky(r_dir);\n        \n        //let's pretend this is fresnel + underwater light scattering\n        // (but it really is just: it's darker if I look straight at it)\n        mul = vec3(1.0-abs(dot(r.d,n)));\n \n    } else {\n        col += mul*sky(r.d);\n        break;\n    }\n    \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n   }","name":"Buffer A","description":"","type":"buffer"}]}