{"ver":"0.1","info":{"id":"XcdSzS","date":"1714073825","viewed":532,"name":"Progressive Raymarch","username":"Xor","description":"I wanted to see what it would look like if I removed the raymarch loop and marched one step per frame.","likes":43,"published":1,"flags":32,"usePreview":0,"tags":["test","raymarch","temporal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    \"Progressive Raymarch\" by @XorDev\n    \n    I wanted to see what it would look like if I removed the\n    raymarch loop and marched one step per frame.\n\n    Apologies for the dense code. I used \"Dust\" as a base and I\n    find it much faster to prototype with shorter code.\n    Feel free to come up with your own example or even de-golf\n    this one and I'll probably leave the link below.\n\n*/\nM;\n    //Use position derivatives for coloring\n    O = 1.-tanh(r.y/1e2*fwidth(T));\n    O *= O;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Fractal from \"Dust\"\n//https://www.shadertoy.com/view/cdG3Wd\n\nM,\n    //Ray direction (rounded for consistent derivatives)\n    d = vec3(roundEven(I)*2.,r)-r,\n    //Transformation vector and raymarch step size\n    v, s;\n    \n    //1-FPS\n    //if (floor(iTime) == floor(iTime+iTimeDelta)) {O=T; return;}\n    \n    \n    //Rotate pitch downward .2 radians\n    d.yz *= R-.2));\n    \n    //Reinitialize position every 400 frames\n    O = iFrame%400<1?iTime/r.zxzz-6.:T;\n    \n    //Set vars for fractal\n    v = s = O.rgb;\n    //Fractal loop (not necessary for raymarching)\n    for(float i=1e2; i>.1; i*=.4)\n        //Rotate octave\n        v.xz*=R-.8)),\n        //Cut out blocks\n        s = max(s,min(min(v=i*.8-abs(mod(v,i+i)-i),v.x),v.z));\n    \n    //Step forward\n    O.rgb+=d/length(d)*s.y;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//Rotation matrix trick learned from FabriceNeyret2\n#define R mat2(cos(vec4(0,11,33,0)//\n//\n//Shortened main function with resolution\n#define M void mainImage(out vec4 O, vec2 I) {vec3 r = iResolution//\n//\n//Sample texture0 using screen uvs.\n#define T texture(iChannel0,I/r.xy)","name":"Common","description":"","type":"common"}]}