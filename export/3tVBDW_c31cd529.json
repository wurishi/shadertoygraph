{"ver":"0.1","info":{"id":"3tVBDW","date":"1614341195","viewed":230,"name":"Taurus Wire","username":"Patate1er","description":"Done for a limited time (3h) shader exercise after a week of shader formation in my school (ATI)","likes":14,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sound","fft","visualization","reactive","music","audio","animation","ati"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Thanks Rémi and Florine (ATI), and my mom\n//wireframes method was adapted from this pjkarlik's code :\n//https://www.shadertoy.com/view/WsVyRc (so thanks too)\n//please spam play in buffer A sound channel if the sound doesn't load\n//change MO value to true for mirror version\n#define MO          false\n\n#define R           iResolution\n#define M           iMouse\n#define T           iTime\n#define PI          3.1415926\n#define TAU         6.2831853\n\n#define dt(speed) fract(iTime*speed)\n#define looptime(speed) abs(-1.+2.*dt(speed))\n\n#define MINDIST     .001\n#define MAXDIST     20.\n\n#define r2(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\nconst float ns = 3.;//nombre de spheres dans le taurus\nconst float cs = 0.6;//circles speed\n\n//change MO value at line 6 to use it\nvoid mo (inout vec2 p, vec2 d){\n    p = abs(p)-d;\n    if(p.y>p.x)p=p.yx;\n}\n\n//cercle 2D\nfloat easeInOutExpo(float x){\nreturn x == 0.0\n  ? 0.0\n  : x == 1.0\n  ? 1.0\n  : x < 0.5 ? pow(2.0, 20.0 * x - 10.0) / 2.0\n  : (2.0 - pow(2.0, -20.0 * x + 10.0)) / 2.0;\n\n}\n\nfloat procedural_2d(vec2 uv, float r){\n    const float hw = .05;\n    const float s = .01;\n    float size = r;\n    float circle = smoothstep(hw-s,hw,\n                        abs(length(uv)-size)\n                        );\n    return circle;\n}\n\n//formes 3D\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//opérateur 3D\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n//globals//\nfloat glow;\n\nfloat map(vec3 p){\n    float spec = texelFetch( iChannel0, ivec2(iResolution.x-1.,iResolution.y-1.), 0 ).x;\n    float s = 0.6+spec;\n    \n    float d = p.z+4.;\n    float res = d;\n    \n    p.xz *= r2(iTime);\n    if(MO){\n        mo(p.xz,vec2(0.5));\n    }\n    p.xy *= r2(iTime);\n    \n    \n    //strange taurus\n    d = sdTorus(p/s, vec2(2.0,0.7))*s;\n    d = min(d, sdSphere(p+vec3(0.0,sin(dt(cs/2.)*TAU)*2.,0.0),0.3));\n    for(float i = 0.;i<ns;++i){\n        float a = i*TAU/ns;\n        d = opSmoothUnion(d, sdSphere((p+2.0*s*vec3(sin(a),0.0,cos(a)))/s,.9+cos(a+iTime*3.)*.4)*s,.5);\n    }\n\n    glow += (.00095)/(.000015+pow(d,2.));\n    //res = d;\n    return d;\n}\n\nvoid ray(vec3 ro, vec3 rd,  int maxstep){\n        float d =  .0;\n        int i = 0;\n        for(i=0;i<maxstep;i++){\n            vec3 p = ro + rd * d;\n            float t = map(p);\n            if(abs(t)<d*MINDIST||d>MAXDIST)break;\n            d += (1.1+(sin(iTime)*0.4));\n        }\n}\n\n//camera setup\nvec3 camera(vec3 lp, vec3 ro, vec2 uv) {\n    vec3 f=normalize(lp-ro),\n         r=normalize(cross(vec3(0,1,0),f)),\n         u=normalize(cross(f,r)),\n         c=ro+f*.75,\n         i=c+uv.x*r+uv.y*u,\n         rd=i-ro;\n    return rd;\n}\n\nvoid mainImage( out vec4 O, in vec2 F ) {\n    // pixel screen coordinates\n    vec2 uv = (F.xy - R.xy*0.5)/R.y;\n    vec3 C = vec3(0.);\n\n    vec3 lp = vec3(0.,0.,0.);\n    vec3 ro = lp + vec3(0.,0.,5.5);\n\n    vec3 rd = camera(lp,ro,uv);\n    \n    ray(ro,rd, 250);\n    \n    C = vec3(glow*0.4); \n    C = mix(1.-C,C,procedural_2d(uv,easeInOutExpo(looptime(cs))*0.4));\n    O = vec4(vec3(sqrt(C)),1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//ranges to split\nvec2 spec_split = vec2(0.0,0.01);\nint steps = 1;//possibility to skip values for performance if steps > 1\n\nfloat f_range = 0.475;\nfloat a_range = 0.1;\n\n// return 1 value at the time\nfloat spectrum(vec2 spec_split, int steps){\n    float ret = 0.0;\n    int splitStart = int(floor(spec_split.x*512.0));\n    int splitEnd = int(floor(spec_split.y*512.0));\n    for(int i = splitStart; i<=splitEnd;i+=steps){\n        // first row is frequency data (48Khz/4 in 512 texels, meaning 23 Hz per texel)\n        float fft  = texelFetch( iChannel0, ivec2(i,0), 0 ).x;\n        ret+=fft;\n    }\n    if(splitStart!=splitEnd){\n        ret/=floor(float((splitEnd-splitStart)/steps));\n    }\n    return smoothstep(0.5-a_range,0.5+a_range,f_range*ret);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(ceil(fragCoord.x) == iResolution.x && ceil(fragCoord.y) == iResolution.y){//only on last texel\n        fragColor.r = spectrum(spec_split,steps);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}