{"ver":"0.1","info":{"id":"ldXBR7","date":"1495302773","viewed":136,"name":"pruebas_05 ","username":"ps","description":"raymarching","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// recursos interesantes \n// elevated de iq https://www.shadertoy.com/view/MdX3Rr\n// raymarching de iq https://iquilezles.org/articles/rmshadows\n// iluminación de iq https://iquilezles.org/articles/outdoorslighting\n// (buena explicación de raymarching) tutorial para esfera con iluminacion phong mediante raymarching http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/\n// la base del codigo parte de esta https://www.youtube.com/watch?v=RGmgHfbU0hU\n\n// Constantes.\n#define STEPS 64\n#define EPS 0.002\n#define FAR 1000.0\n#define PI 3.14159265359\n\n#define SC (250.0)\n\n//función de ruido extraida de https://www.shadertoy.com/view/MlfXWH\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    // Quintic because everyone else is using the cubic! :D\n    vec2 df = 30.0*f*f*(f*(f-2.0)+1.0);\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    float a = texture(iChannel0, (i+vec2(0.5, 0.5))/256., -100.0).r;\n    float b = texture(iChannel0, (i+vec2(1.5, 0.5))/256., -100.0).r;\n    float c = texture(iChannel0, (i+vec2(0.5, 1.5))/256., -100.0).r;\n    float d = texture(iChannel0, (i+vec2(1.5, 1.5))/256., -100.0).r;\n    \n    float k = a-b-c+d;\n    float n = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    \n    return vec3(n, vec2(b-a+k*f.y, c-a+k*f.x)*df);\n}\n\nmat2 m = mat2(0.8,-0.6,0.6,0.8);\n\nfloat escala=1.55; // creo que con esto se controla la escala del terreno o algo\n// fractal brownian motion, hace 4 repeticiones de la función de ruido, a mas pasadas mas detalles\n// en este caso no necesitamos mucho detalle para la geometría general\nfloat fbmM(vec2 p) {\n    vec2 df = vec2(0.0);\n    float f = 2.0, w = 0.5;\n    \n    for (int i = 0; i < 4; ++i) {\n        vec3 n = noise(p);\n        df += n.yz;\n        f += abs(w * n.x/ (1.0 + dot(df, df)));\n        w *= 0.5; p = 2.*m*p;\n    }\n    return escala*f;\n}\n// lo utilizaremos para calcular las normales por lo que le daremos mas detalle (mas pasadas)\nfloat fbmH(vec2 p) {\n    vec2 df = vec2(0.0);\n    float f = 2.0, w = 0.5;\n    \n    for (int i = 0; i < 10; ++i) {\n        vec3 n = noise(p);\n        df += n.yz;\n        f += abs(w * n.x/ (1.0 + dot(df, df)));\n        w *= 0.4; p = 2.*m*p;\n    }\n    return escala*f;\n}\n/*\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\nfloat fbmH( in vec2 p )\n{\n\t//vec2  p = x*0.003/SC;\n    float a = 2.0;\n    float b = 0.5;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<8; i++ )\n    {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn escala*a;\n}\n    \nfloat fbmM( in vec2 p)\n{\n\t//vec2  p = x*0.003/SC;\n    float a = 2.0;\n    float b = 0.5;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 n = noise(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn escala*a;\n}\n\n*/\n// map lo usaban el ejemplo https://www.shadertoy.com/view/MlfXWH para calcular las normales\n// pero se podría omitir como he hecho en el codigo de intersect\nfloat map(vec3 p) {\n    return p.y - fbmM(p.xz);\n}\nfloat mapH(vec3 p) {\n    return p.y - fbmH(p.xz);\n}\n\n/*\n// escena donde se guardara la composición de objetos de la escena\nfloat scene(vec2 posxz){\n  return fbmM(posxz);\n}*/\n\n// modificado de la demo de elevated https://www.shadertoy.com/view/MdX3Rr\nfloat intersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax )\n{\n    vec3 pos;\n    float t = 0.0;\n\t\tfor( int i=0; i<256; i++ )\n\t{\n         pos = ro + t*rd;\n\t\tfloat h = pos.y - fbmM( pos.xz);\n\t\tif( h<(EPS*t) || t>tmax ) break;\n\t\tt += 0.25*h;\n\t}\n\n\treturn t;\n}\n\n\n// extraido de https://www.shadertoy.com/view/MlfXWH\nvec3 calcNormal(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(mapH(p+q.yxx) - mapH(p-q.yxx),\n                \t\t  mapH(p+q.xyx) - mapH(p-q.xyx),\n                \t\t  mapH(p+q.xxy) - mapH(p-q.xxy)));\n}\n\nvec3 makeFog(in vec3 realColor, vec3 fogColor, float distancia, float fogDensity){\n    float theE = 2.718281828459045235360;\n\tfloat res = 1.0/(pow(theE,((distancia*fogDensity)*(distancia*fogDensity)*(distancia*fogDensity))));\n    return mix(fogColor,realColor,res);\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = calcNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye, vec3 nor, vec3 ro) {\n \n    vec3 ambientLight = 0.5 * k_d;\n    vec3 color = ambientLight * k_a;\n   // vec3 light1Pos = vec3(10.0, 1.0, 10.0);\n    // hacemos que se mueva para que quede mas interesante\n    vec3 light1Pos = vec3(ro.x+10.0 * sin(iTime),\n                          ro.y+2.0,\n                          ro.z+10.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    \n    vec3 pointToLight = light1Pos - p; // Vector foco-vértice\n\tfloat distanceToLight = length(pointToLight);\n\tvec3 L = normalize(pointToLight);\n\tvec3 power = k_d;// * atenuate(distanceToLight,omniLights[i].fade);// Fade de distancia\n\tvec3 diff = power * k_d * dot(nor, L);\n\tcolor+=clamp(diff,0.0,1.0);\n\n    // Especular\n    vec3 R = reflect(-L,nor);\n    vec3 V=pointToLight;\n    float Sfactor = max(dot(R,V),0.0001);\n\n    //Sfactor=pow(Sfactor,length(nor));\n    Sfactor = max(dot(R,V),0.0001)*0.001;\n    vec3 spec = power * k_s * Sfactor;\n    color+=clamp(spec,0.0,1.0);\n    return color;\n}\n\nfloat fogAngleFixer(vec3 angle){\n\treturn clamp(-angle.y*2.0+0.1,0.0,1.0);   \n}\nvec3 getBackground(vec3 angle){\n    float heigh = clamp(angle.y*2.0+0.2,0.0,1.0);\n    return vec3(0.3*(1.0-heigh),0.5*heigh*0.5+0.5,1.0*heigh/2.0+0.5);\n}\nvec3 getColor(vec3 pos, vec3 norm){\n    float col1=0.0,col2 = 0.0, col3 = 0.0;\n    col1 = clamp((pos.y-3.6) * 10.0, 0.0, 1.0);\n    col2 = (clamp(abs((pos.y-3.6) * 10.0), 0.0, 1.0) * -1.0) + 1.0;\n    col3 = 1.0 - col1 - col2;\n    return\n        col1 * vec3(1.0,1.0,1.0) +\n        col2 * vec3(0.2,0.9,0.3) +\n        col3 * vec3(0.7,0.5,0.1);\n}\nvec4 render ( vec3 ro, in vec3 rd){\n    vec3 light1 = normalize( vec3(4.8,10.4,4.3) );\n\tfloat tmin = 1.0;\n    float tmax = 100.; // distancia maxima del rayo\n\tvec3 col;\n\tvec3 colorGround=vec3(0.474, 0.313, 0.086);\n    vec3 colorBackground=vec3(0.1,0.1,0.8);\n    float fogDensity = 0.1;\n    fogDensity*=fogAngleFixer(rd);\n    vec3 fogColor = vec3(1.0,1.0,1.0);\n    //return vec4(fogDensity);\n \n    \n    \n\tfloat t = intersect( ro, rd, tmin, tmax );\n    if (t>tmax){\n\n        //draw background\n        col = getBackground(rd);// colorBackground;\n        t = -1.0;\n        col = makeFog(col, fogColor, tmax, fogDensity);\n        \n    \n    }else{\n        //draw terrain\n        vec3 pos = ro + t*rd;\n        //vec3 matGround=colorGround;\n        vec3 nor = calcNormal( pos );\n        vec3 matGround=getColor(pos,nor);\n        // return vec4 (nor,1. ); //descomentar para mostrar las normales\n        vec3 ref = reflect( rd, nor );\n\n        vec3 K_a = vec3(0.5, 0.5, 0.5);\n        //vec3 K_d = vec3(0.7, 0.2, 0.2);\n        vec3 K_d = matGround;\n        vec3 K_s = vec3(0.2, 0.2, 0.2);\n        float shininess = 1.0;\n\n        vec3 p=pos;\n        vec3 eye=ro;\n        vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye, nor,ro);\n        //return vec4(color,1.0);\n      //  col=color;\n\t\tcol = makeFog(color, fogColor, t*3.0, fogDensity); // descomentar para generar niebla en la zona de abajo\n        \n    }\n\treturn vec4(col,t);\n}\nvec2 rot2D(vec2 p, float angle) {\n \n    angle = radians(angle);\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return p * mat2(c,s,-s,c);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Pixeles de la imagen\n\t//vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n    //vec2 uv = (fragCoord.xy - iResolution.xy * .5) / iResolution.y;\n   \n    vec2  m = (iMouse.xy / iResolution.xy) * 2. - 1.;\n    \n    vec3 dir = vec3(uv, 1.);\n    dir.yz = rot2D(dir.yz,  90. * m.y);\n\tdir.xz = rot2D(dir.xz, 180. * m.x);\n    \n    vec3 ro = vec3(0.0, 4.8, +2.5-iTime); // inicio de rayo\n    vec3 rd = normalize(vec3(uv, -1.0)); // direccion de rayo\n    vec4 res= render(ro,dir); //funcion que nos devolverá el color del fragmento\n\t\n\tfragColor = vec4(res.xyz,1.0);\n}","name":"Image","description":"","type":"image"}]}