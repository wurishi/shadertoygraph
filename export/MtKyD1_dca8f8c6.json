{"ver":"0.1","info":{"id":"MtKyD1","date":"1545302087","viewed":220,"name":"IQs-Raytraced Shapes","username":"gPlatl","description":"A collection of IQs basic Raytracer shapes (3d intersection functions).     \nmouse: y=shape selection, x=rotationZ\n\nVersion 1.4 with 7 shapes having now unified return values ...","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracer","torus","sphere","cone","ellipsoid","cylinder","capsule","collection","intersectors"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-----------------------------------------------------------------\n// IQ_Raytracer.glsl     https://www.shadertoy.com/view/MtKyD1   \n//\n//   v1.0  2018-12-20  initial release\n//   v1.1  2018-12-27  current version\n//   v1.2  2019-01-18  ellipsoid & axis added\n//   v1.3  2020-03-16  corrected CappedCone & RoundedCone\n//   v1.4  2020-09-28  iRoundedCone corrected\n//         2021-12-27  working on...\n//\n// Collection of raytracing different basic geometric shapes designed by Inigo Quilez.\n//   The MIT License   Copyright © 2018 Inigo Quilez\n//\n// infos:\n//   https://iquilezles.org/articles/intersectors\n//   https://iquilezles.org/articles/distfunctions\n//   https://iquilezles.org/articles/diskbbox\n//\n// basic shapes intersection:\n//   Sphere           https://www.shadertoy.com/view/4d2XWV\n//   Sphere AA        https://www.shadertoy.com/view/MsSSWV\n//   Ellipsoid        https://www.shadertoy.com/view/ltsSzn\n//   Cylinder         https://www.shadertoy.com/view/MtcXRf\n//   Capped Cylinder  https://www.shadertoy.com/view/4lcSRn\n//   Capsule          https://www.shadertoy.com/view/Xt3SzX\n//   Rounded Cone     https://www.shadertoy.com/view/MlKfzm\n//   Capped Cone      https://www.shadertoy.com/view/llcfRf\n//   Torus            https://www.shadertoy.com/view/4sBGDy\n//\n// tags: 3d, collection, intersectors, raytracer, sphere, cone, cylinder, capsule, ellipsoid, torus \n//\n// not included in this collection:\n//   Cone (no base)   https://www.shadertoy.com/view/MtcXWr\n//   Rounded Cone     https://www.shadertoy.com/view/MlKfzm\n//-----------------------------------------------------------------\n\n// antialiasing level... \n#define AA 2\n\n#define SHAPES 7.\n\n/* test objects:   \n\n         Torus\n      Ellipsoid\n        Sphere\n      Rounded Cone \n      Capped Cone\n        Capsule\n    Capped Cylinder\n*/\n\n// result = sqr(v) = v^2\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sqr ( in vec3 v ) { return dot(v,v); }\n\n//=================================================================\n// sphere distance, normal & intersection\n//=================================================================\n\n// get distance of ray - sphere intersection\nfloat sdSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot (oc, rd);\n  float c = dot (oc, oc) - sph.w*sph.w;\n  float h = b*b - c;\n  if (h<0.0) return -1.0;\n  return -b -sqrt(h);\n}\n\n// sphere normal\nvec3 sphereNormal( in vec3 pos, in vec4 sph )\n{\n  return normalize(pos - sph.xyz);\n}\n\n// ray-sphere intersection, return.xyz=normal, return.w=distance\nvec4 iSphere( in vec3 ro, in vec3 rd, in vec3 M, in float radius)\n{\n  vec4 sph = vec4(M,radius);  \n  float t = sdSphere(ro,rd,sph);\n  if (t<0.0)    return vec4(-1);         //===>\n  vec3 pos = ro + t * rd;\n  vec3 n = sphereNormal (pos, sph);\n  return vec4(n,t);\n}\n\n//=================================================================\n// ellipse distance & intersection     https://www.shadertoy.com/view/ltsSzn\n//=================================================================\nstruct Ellipsoid { vec3 center; vec3 radius; };\n\n// get distance of ray - ellipsoid intersection\nfloat sdEllipsoid (in vec3 ro, in vec3 rd\n                  ,in Ellipsoid sph)\n{\n  vec3 oc = ro - sph.center;\n  vec3 ocn = oc / sph.radius;\n  vec3 rdn = rd / sph.radius;\n    \n  float a = dot( rdn, rdn );\n  float b = dot( ocn, rdn );\n  float c = dot( ocn, ocn );\n  float h = b*b - a*(c-1.0);\n  if (h <= 0.0)    return h;         //===>\n  return (-b -sqrt(h))/a;\n}    \n            \n// ellipsoid normal\nvec3 ellipsoidNormal( in vec3 pos, in Ellipsoid sph )\n{\n  return normalize((pos-sph.center) / sph.radius);\n}\n\n// ray - ellipsoid intersection, return.xyz=normal, return.w=distance\nvec4 iEllipsoid (in vec3 ro, in vec3 rd, in vec3 center, in vec3 radii)\n{\n  Ellipsoid ellipsoid = Ellipsoid(center, radii);\n  float t = sdEllipsoid (ro,rd,ellipsoid);\n  if (t<0.0)    return vec4(-1);         //===>\n    \n  vec3 pos = ro + t * rd;\n  vec3 n = ellipsoidNormal (pos, ellipsoid);\n  return vec4(n,t);\n}\n\n//=================================================================\n// cylinder distance & intersection\n//=================================================================\n\n//-----------------------------------------------------------------\n// get distance of ray - cylinder intersection\n//   cylinder distance:  https://www.shadertoy.com/view/wdXGDr\n//-----------------------------------------------------------------\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    return sign(d)*sqrt(abs(d))/baba;\n}\n//-----------------------------------------------------------------\n// ray - cylinder intersection, return.xyz=normal, return.w=distance\n//   https://www.shadertoy.com/view/MtcXRf\n//-----------------------------------------------------------------\nvec4 iCylinder( in vec3 ro, in vec3 rd  // ray origin & direction\n               ,in vec3 pa, in vec3 pb  // point a, point b\n               ,in float ra )           // radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);\n    vec3 ab = pb - pa;\n    float ch = length(ab);\n    vec3 ca = ab / ch;\n    ch *= 0.5;\n\n    vec3  oc = ro - cc;\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if( h<0.0 )         return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a;  \n    //float t2 = (-b+h)/a; // exit point\n\n    float y = caoc + t1*card;\n\n    // body\n    if( abs(y)<ch )\n        return vec4( normalize( oc+t1*rd - ca*y ), t1 );\n    \n    // caps\n    float sy = sign(y);\n    float tp = (sy*ch - caoc)/card;\n   \n    if( abs(b+a*tp) < h)  return vec4(ca*sy, tp);\n\n    return vec4(-1.0);\n}\n\n//=================================================================\n// endless cylinder intersection\n//=================================================================\n\n//-----------------------------------------------------------------\n// ray - endless cylinder intersection, return.xyz=normal, return.w=distance\n//   https://www.shadertoy.com/view/MtcXRf\n//-----------------------------------------------------------------\nvec4 iEndlessCylinder( in vec3 ro, in vec3 rd  // ray origin & direction\n                      ,in vec3 pa, in vec3 pb  // point a, point b\n                      ,in float ra )           // radius\n{\n    // center the cylinder, normalize axis\n    vec3 cc = 0.5*(pa+pb);   // center point \n    vec3 ab = pb - pa;       // axis direction from A -> B\n    float axisLen = length(ab);\n    vec3 ca = ab / axisLen;  // identity axis vector\n\n    vec3  oc = ro - cc;   // origin to center vector\n\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    \n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - ra*ra;\n    float h = b*b - a*c;\n    if (h <= 0.0)         return vec4(-1.0);\n    h = sqrt(h);\n    float t1 = (-b-h)/a; // nearest distance \n  //float t2 = (-b+h)/a; // exit point distance\n\n    float y = caoc + t1*card;\n\n    vec3 normal = normalize(oc+t1*rd - ca*y);\n    return vec4 (normal, t1);\n}\n\n//=================================================================\n// capsule distance, normal & intersection\n//=================================================================\n\n// get distance of ray - capsule intersection\nfloat sdCapsule(in vec3 ro, in vec3 rd,   // ray origin & direction\n                in vec3 pa, in vec3 pb,   // position of A & B\n                in float r )              // radius\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h<0.0 ) return -1.0;      //===>\n\n    float t = (-b-sqrt(h))/a;\n    float y = baoa + t*bard;\n        \n    // body\n    if( y>0.0 && y<baba ) return t;\n\n    // sphere caps\n    vec3 oc = (y<=0.0) ? oa : ro - pb;\n    b = dot(rd,oc);\n    c = dot(oc,oc) - r*r;\n    h = b*b - c;\n//    if( h>0.0 ) \n        return -b - sqrt(h);\n    return -1.0;\n}\n\n// get capsule normal\nvec3 capsuleNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  u = b - a;\n    vec3  v = pos - a;\n    float h = clamp(dot(v,u)/dot(u,u), 0.0, 1.0);\n    return (v - h*u) / r;\n}\n\n// ray-capsule intersection,  return.xyz=normal, return.w=distance \nvec4 iCapsule( in vec3 ro, in vec3 rd, \n               in vec3 pa, in vec3 pb,   // Endpunkte\n               in float r )              // Radius\n{\n  float t = sdCapsule(ro,rd, pa,pb,r);\n  if (t<0.0)    return vec4(-1);         //===>\n  vec3 pos = ro + t * rd;\n  vec3 n = capsuleNormal (pos, pa,pb, r);\n  return vec4(n,t);\n}\n\n//=================================================================\n//  capped cone intersection  \n//     https://www.shadertoy.com/view/llcfRf of 2019-04-04\n//=================================================================\nvec4 iCappedCone( in vec3  ro, in vec3  rd,   // ray origin & direction \n                  in vec3  pa, in vec3  pb,   // end points A & B\n                  in float ra, in float rb )  // disc radii of A & B\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    \n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(ob,ba); \n    float m3 = dot(rd,ba);\n\n    //caps\n    if     ( m1 < 0.0 )\n    { if( dot2(oa*m3-rd*m1)<(ra*ra*m3*m3) ) \n        return vec4(-ba*inversesqrt(m0), -m1/m3); \n    }\n    else if( m2 > 0.0 ) \n    { if( dot2(ob*m3-rd*m2)<(rb*rb*m3*m3) ) \n        return vec4(ba*inversesqrt(m0), -m2/m3); \n    }\n    \n    // body\n    float m4 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    \n    float k2 = m0*m0    - m3*m3*hy;\n    float k1 = m0*m0*m4 - m1*m3*hy + m0*ra*(rr*m3*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return vec4(-1.0);         //===>\n\n    float t = (-k1-sqrt(h))/k2;\n\n    float y = m1 + t*m3;\n    if( y>0.0 && y<m0 ) \n    {\n        return vec4(normalize(m0*(m0*(oa+t*rd)+rr*ba*ra)-ba*hy*y), t);\n    }\n    \n    return vec4(-1.0);\n}\n\n//=================================================================\n// rounded cone (distance), intersection\n//=================================================================\n\n// rounded cone distance see https://www.shadertoy.com/view/tdXGWr\nfloat sdRoundedCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\n// rounded cone intersection  https://www.shadertoy.com/view/MlKfzm\nvec4 iRoundedCone( in vec3  ro, in vec3  rd,   // ray origin & direction\n                   in vec3  pa, in vec3  pb,   // end points A & B\n                   in float ra, in float rb )  // sphere radii of A & B\n{\n  vec3  ba = pb - pa;\n  vec3  oa = ro - pa;\n  vec3  ob = ro - pb;\n  float rr = ra - rb;\n  float m0 = dot(ba,ba);\n  float m1 = dot(ba,oa);\n  float m2 = dot(ba,rd);\n  float m3 = dot(rd,oa);\n  float m5 = dot(oa,oa);\n  float m6 = dot(ob,rd);\n  float m7 = dot(ob,ob);\n    \n  float d2 = m0    - rr*rr;\n  float k2 = d2    - m2*m2;\n  float k1 = d2*m3 - m1*m2 + m2*rr*ra;\n  float k0 = d2*m5 - m1*m1 + m1*rr*ra*2.0 - m0*ra*ra;\n    \n  float h = k1*k1 - k0*k2;\n  if (h < 0.0) return vec4(-1.0);   //===>\n  float t = (-sqrt(h)-k1)/k2;\n\n  float y = m1 - ra*rr + t*m2;\n  if (y>=0.0 && y<=d2)        // coat hit ?\n    return vec4(normalize( d2*(oa + t*rd)-ba*y), t);\n\n  // Caps. I feel this can be done with a single square root instead of two\n  float h1 = m3*m3 - m5 + ra*ra;\n  float h2 = m6*m6 - m7 + rb*rb;\n  if (max(h1,h2) < 0.0)       // no sphere hit?   \n    return vec4(-1.0);        //===>\n\n  vec4 r = vec4(1e20);\n  if (h1 > 0.0)\n  {                           // sphere-1 hit\n    t = -m3 - sqrt(h1);\n    r = vec4((oa+t*rd)/ra, t);\n  }\n  if (h2 > 0.0)\n  {                           // sphere-2 hit\n    t = -m6 - sqrt(h2);\n    if(t < r.w)               // nearer?\n      r = vec4((ob+t*rd)/rb, t);\n  }\n  return r;                   // distance\n}\n\n//=================================================================\n// ray - torus distance, normal & intersection\n// https://www.shadertoy.com/view/4sBGDy\n// f(x) = (|x|² + R² - r²)² - 4·R²·|xy|² = 0\n//=================================================================\n\n// get distance of ray - torus intersection\nfloat sdTorus( in vec3 ro, in vec3 rd, in vec2 torus )\n{\n\tfloat Ra2 = torus.x*torus.x;\n\tfloat ra2 = torus.y*torus.y;\n\t\n\tfloat m = dot(ro,ro);\n\tfloat n = dot(ro,rd);\n\t\t\n\tfloat k = (m - ra2 - Ra2)/2.0;\n\tfloat a = n;\n\tfloat b = n*n + Ra2*rd.z*rd.z + k;\n\tfloat c = k*n + Ra2*ro.z*rd.z;\n\tfloat d = k*k + Ra2*ro.z*ro.z - Ra2*ra2;\n\t\n    //----------------------------------\n\n\tfloat p = -3.0*a*a     + 2.0*b;\n\tfloat q =  2.0*a*a*a   - 2.0*a*b   + 2.0*c;\n\tfloat r = -3.0*a*a*a*a + 4.0*a*a*b - 8.0*a*c + 4.0*d;\n\tp /= 3.0;\n\tr /= 3.0;\n\tfloat Q = p*p + r;\n\tfloat R = 3.0*r*p - p*p*p - q*q;\n\t\n\tfloat h = R*R - Q*Q*Q;\n\tfloat z = 0.0;\n\tif( h < 0.0 )\n\t{\n\t\tfloat sQ = sqrt(Q);\n\t\tz = 2.0*sQ*cos( acos(R/(sQ*Q)) / 3.0 );\n\t}\n\telse\n\t{\n\t\tfloat sQ = pow( sqrt(h) + abs(R), 1.0/3.0 );\n\t\tz = sign(R)*abs( sQ + Q/sQ );\n\t}\n\t\n\tz = p - z;\n\t\n    //----------------------------------\n\t\n\tfloat d1 = z   - 3.0*p;\n\tfloat d2 = z*z - 3.0*r;\n\n\tif( abs(d1)<1.0e-4 )\n\t{\n\t\tif( d2<0.0 ) return -1.0;\n\t\td2 = sqrt(d2);\n\t}\n\telse\n\t{\n\t\tif( d1<0.0 ) return -1.0;\n\t\td1 = sqrt( d1/2.0 );\n\t\td2 = q/d1;\n\t}\n\n    //----------------------------------\n\t\n\tfloat result = 1e20;\n\n\th = d1*d1 - z + d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = -d1 - h - a;\n\t\tfloat t2 = -d1 + h - a;\n\t\t     if( t1>0.0 ) result=t1;\n\t\telse if( t2>0.0 ) result=t2;\n\t}\n\n\th = d1*d1 - z - d2;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt(h);\n\t\tfloat t1 = d1 - h - a;\n\t\tfloat t2 = d1 + h - a;\n\t\t     if( t1>0.0 ) result=min(result,t1);\n\t\telse if( t2>0.0 ) result=min(result,t2);\n\t}\n\treturn result;\n}\n\n// torus normal:  df(x)/dx\nvec3 nTorus( in vec3 pos, vec2 tor )\n{\n\treturn normalize( pos*(dot(pos,pos)- tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n}\n\n// ray-torus intersection,  return.xyz=normal, return.w=distance \nvec4 iTorus( in vec3 ro, in vec3 rd, in vec2 torusRadii )\n{\n    float t = sdTorus (ro,rd,torusRadii);\n    if (t <= 0.0)    return vec4(-1);    //===>\n    vec3 pos = ro + t * rd;\n    vec3 n = nTorus (pos, torusRadii);\n    return vec4(n,t);\n}\n\n//=================================================================\n// please set AA level for antialiasing... \n//=================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 tot = vec3(0.0);\n  vec2 mpos = iMouse.xy / iResolution.xy;  // 0 .. 1\n  int selection = int (SHAPES*mpos.y);     // 0 .. shapes-1\n\n#if AA>1\n  for( int m=0; m<AA; m++ )\n  for( int n=0; n<AA; n++ )\n  {\n    // pixel coordinates\n    vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n    vec2 p = (2.0*(fragCoord+o) - iResolution.xy) / iResolution.y;\n#else                                // p.y:  -1 .. 1\n    vec2 p = (2.0* fragCoord    - iResolution.xy) / iResolution.y;\n#endif                                      \n\n    // camera position\n    float an = 0.5*iTime + 6.4*mpos.x;\n    vec3 ro = vec3( cos(an), 0.3, sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    // create view ray\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // animate point A,B and radius\n    vec3 pA =  0.2 + 0.3*sin(iTime*vec3(1.11,1.27,1.47)+vec3(2.0,5.0,6.0));\n    vec3 pB = -0.2 + 0.3*sin(iTime*vec3(1.23,1.41,1.07)+vec3(0.0,1.0,3.0));\n    vec3 center = 0.5*(pA+pB);\n    float radius  = 0.2 + 0.02*sin(iTime*1.3+0.5);\n    float radius2 = 0.2 + 0.04*sin(iTime*2.3+0.5);\n\n    // background color\n    vec3 col = vec3(0.4)*(1.0-0.3*length(p));\n\n    vec3 ellipsoidRadii = radius * vec3(0.5, 1, 2);\n        \n    // raytrace\n    vec4 nt = vec4(-1.0);  // nt.xyz=normal, nt.w=distance \n    if      (selection == 0) nt = iCylinder   (ro,rd, pA,pB, radius);\n    else if (selection == 1) nt = iCapsule    (ro,rd, pA,pB, radius);\n    else if (selection == 2) nt = iCappedCone (ro,rd, pA,pB, radius, radius2);\n    else if (selection == 3) nt = iRoundedCone(ro,rd, pA,pB, radius, radius2);\n    else if (selection == 4) nt = iSphere     (ro,rd, center, 2.0*radius);\n    else if (selection == 5) nt = iEllipsoid  (ro,rd, center, ellipsoidRadii);\n    else                     nt = iTorus      (ro,rd, 2.0*vec2(radius, 0.2*radius));\n    float t = nt.w;   // distance\n\n    vec3 surfaceColor = vec3(1.0, 0.7, 0.3);\n    // draw axis through point A an B\n    if (selection < 5)\n    { \n      vec4 nt2 = iEndlessCylinder (ro,rd, pA,pB, 0.01);\n      if (nt2.w > 0.0)     // hit endless line axis ?  \n      {\n        if ((t < 0.0)      // no object intersection  \n        ||  (nt2.w < t))   // or axis distance nearer ?\n        {\n          surfaceColor = vec3(0.7);  // set axis color\n          nt = nt2;        // set normal  \n          t = nt2.w;       // set distance\n        }\n      } \n    }\n            \n    if (t > 0.0)      // intersection?\n    {\n      vec3 pos = ro + t*rd;\n      vec3 normal = nt.xyz;\n  \n      // shading/lighting\n      float dif = clamp( dot(normal,vec3(0.5, 0.7, 0.2)), 0.0, 1.0 );\n      float amb = 0.5 + 0.5*dot(normal,vec3(0.0, 1.0, 0.0));\n      const vec3 ambientColor = vec3(0.2, 0.3, 0.4);\n      const vec3 diffuseColor = vec3(0.8, 0.7, 0.5);\n      col = sqrt (ambientColor*amb + diffuseColor*dif);\n      col *= surfaceColor;\n    }\n    tot += col;\n#if AA>1\n  }\n  tot /= float(AA*AA);\n#endif\n\n  fragColor = vec4( tot, 1.0 );\n    \n  // draw selection marker\n  if (fragCoord.x < 8. || fragCoord.x > iResolution.x-8.)\n  {\n    int spos = int (SHAPES * fragCoord.y / iResolution.y);  // 0 .. shapes-1\n    if (selection == spos)\n      fragColor += vec4(0.4,0.4,0,1);\n  }\n}","name":"Image","description":"","type":"image"}]}