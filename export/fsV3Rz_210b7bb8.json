{"ver":"0.1","info":{"id":"fsV3Rz","date":"1632185756","viewed":112,"name":"SSAO-TEST","username":"qiub","description":"SSAO and simple blur","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["ssao"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":2,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int TIME_INTERVAL = 2;\nconst int INTERVAL_COUNT = 3;\nconst int TIME_ALL = TIME_INTERVAL * INTERVAL_COUNT;\nvec3 phongshading(vec3 eye, vec3 pos, vec3 dir, vec2 uv, int mode) {\n  vec3 objetColor = vec3(0.0, 1.0, 1.0);\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  float shininess = 16.0;\n\n  vec3 ka = vec3(0.8);\n  if (mode == 1) {\n    ka = 0.8 * texture(iChannel1, uv).rgb;\n  }\n  vec3 ks = vec3(0.2);\n  vec3 kd = vec3(0.5);\n\n  vec3 light1Pos = vec3(3.0);\n  vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n\n  vec3 ambientLight = 0.5 * lightColor;\n  vec3 ambient = ambientLight * ka;\n\n  vec3 N = estimateNormal(pos);\n  vec3 L = normalize(light1Pos - pos);\n  vec3 V = normalize(eye - pos);\n  vec3 R = normalize(reflect(-L, N));\n\n  float NdotL = max(dot(L, N), 0.0);\n  float VdotR = max(dot(R, V), 0.0);\n  vec3 diffuse = kd * NdotL * lightColor;\n\n  float spec = pow(VdotR, shininess);\n  vec3 specular = ks * spec * lightColor;\n\n  vec3 ref = reflect(dir, N);\n  //objetColor = texture( iChannel0, ref ).rgb;\n\n  return (ambient + diffuse + specular) * objetColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n  vec3 eye = vec3(2.0 * sin(0.37 * iTime),\n    1.0,\n    2.0 * cos(0.37 * iTime));\n\n  mat4 cameraToworldMatrix = getCameraToWorldMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n  vec3 dirWorld = (cameraToworldMatrix * vec4(dir, 0.0)).xyz;\n\n  float depth = CLIP_NEAR;\n  if (!rayMarching(eye, dirWorld, depth, CLIP_FAR)) {\n    // hit nothing\n    fragColor = texture(iChannel2, vec3(dirWorld.x, dirWorld.y, dirWorld.z));\n    return;\n  }\n\n  vec3 pos = eye + dirWorld * depth;\n  int timeNow = int(iTime) % TIME_ALL;\n  if (timeNow < TIME_INTERVAL * 1) {\n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n  } else if (timeNow < TIME_INTERVAL * 2) {\n    fragColor = vec4(phongshading(eye, pos, dirWorld, uv, 0), 1.0);\n  } else {\n    fragColor = vec4(phongshading(eye, pos, dirWorld, uv, 1), 1.0);\n  }\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 localNormal = vec3(0.0,0.0,0.0);\n    render(fragColor, localNormal, fragCoord, iResolution, iTime);\n    fragColor.xyz = localNormal;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const int MAX_MARCHING_STEPS = 255;\nconst float CLIP_NEAR = 0.0;\nconst float CLIP_FAR = 10.0;\nconst float EPSILON = 0.001;\n\nfloat sdfIntersect(float distA, float distB) {\n  return max(distA, distB);\n}\n\nfloat sdfUnion(float distA, float distB) {\n  return min(distA, distB);\n}\n\nfloat sdfDifference(float distA, float distB) {\n  return max(distA, -distB);\n}\n\nfloat sdfBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdfPlane(vec3 p, vec3 n, float h) {\n  // n must be normalized\n  return dot(p, n) + h;\n}\n\nfloat sdfSphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\nfloat sdfRoundBox(vec3 p, vec3 b, float r) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - r;\n}\n\nfloat opUnion(float d1, float d2) {\n  return min(d1, d2);\n}\n\nfloat opSubtraction(float d1, float d2) {\n  return max(-d1, d2);\n}\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\nfloat opSmoothUnion(float d1, float d2, float k) {\n  float h = max(k - abs(d1 - d2), 0.0);\n  return min(d1, d2) - h * h * 0.25 / k;\n  //float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n  //return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n  float h = max(k - abs(-d1 - d2), 0.0);\n  return max(-d1, d2) + h * h * 0.25 / k;\n  //float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n  //return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n  float h = max(k - abs(d1 - d2), 0.0);\n  return max(d1, d2) + h * h * 0.25 / k;\n  //float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n  //return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdfVerticalCapsule(vec3 p, float h, float r) {\n  p.y -= clamp(p.y, 0.0, h);\n  return length(p) - r;\n}\n\nfloat sdfScene(vec3 pos) {\n  //union\n  float d = 1e10;\n  float d1 = sdfSphere(pos - vec3(0.0, 0.6, 0.0), 0.55);\n  float d2 = sdfRoundBox(pos, vec3(0.6, 0.2, 0.6), 0.1);\n  float dt = opSmoothUnion(d1, d2, 0.25);\n  d = sdfUnion(d, dt);\n\n  //VerticalCapsule\n  vec3 basePoint = pos + vec3(0.8, 0.3, 0.0);\n  dt = sdfVerticalCapsule(basePoint, 2.0, 0.2);\n  d = sdfUnion(d, dt);\n\n  basePoint = pos + vec3(-0.8, 0.3, 0.0);\n  dt = sdfVerticalCapsule(basePoint, 2.0, 0.2);\n  d = sdfUnion(d, dt);\n\n  //sphere\n  dt = sdfSphere(pos - vec3(0.0, -1000.0, 0.0), 1000.0);\n  d = sdfUnion(d, dt);\n\n  return d;\n}\n\nvec3 estimateNormal(vec3 p) {\n  return normalize(vec3(\n      sdfScene(vec3(p.x + EPSILON, p.y, p.z)) - sdfScene(vec3(p.x - EPSILON, p.y, p.z)),\n      sdfScene(vec3(p.x, p.y + EPSILON, p.z)) - sdfScene(vec3(p.x, p.y - EPSILON, p.z)),\n      sdfScene(vec3(p.x, p.y, p.z + EPSILON)) - sdfScene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nbool rayMarching(vec3 eye, vec3 dir, inout float depth, float end) {\n  for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    float dist = sdfScene(eye + depth * dir);\n    if (dist < EPSILON) {\n      return true;\n    }\n    depth += dist;\n    if (depth >= end - EPSILON) {\n      return false;\n    }\n  }\n  return false;\n}\n\nmat3 rotationXY(vec2 angle) {\n  vec2 c = cos(angle);\n  vec2 s = sin(angle);\n\n  return mat3(\n    c.y, 0.0, -s.y,\n    s.y * s.x, c.x, c.y * s.x,\n    s.y * c.x, -s.x, c.y * c.x\n  );\n}\n\nvec3 phongShading(vec3 pos, vec3 eye, vec3 dir) {\n  vec3 objetColor = vec3(1.0, 1.0, 1.0);\n  vec3 lightColor = vec3(1.0, 1.0, 1.0);\n  float shininess = 16.0;\n\n  vec3 ka = vec3(0.8);\n  vec3 ks = vec3(0.2);\n  vec3 kd = vec3(0.5);\n\n  vec3 light1Pos = vec3(3.0);\n  vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n\n  vec3 ambientLight = 0.5 * lightColor;\n  vec3 ambient = ambientLight * ka;\n\n  vec3 N = estimateNormal(pos);\n  vec3 L = normalize(light1Pos - pos);\n  vec3 V = normalize(eye - pos);\n  vec3 R = normalize(reflect(-L, N));\n\n  float NdotL = max(dot(L, N), 0.0);\n  float VdotR = max(dot(R, V), 0.0);\n  vec3 diffuse = kd * NdotL * lightColor;\n\n  float spec = pow(VdotR, shininess);\n  vec3 specular = ks * spec * lightColor;\n\n  vec3 ref = reflect(dir, N);\n  //objetColor = texture( iChannel0, ref ).rgb;\n\n  return (ambient + diffuse + specular) * objetColor;\n}\n\nmat4 getCameraToWorldMatrix(vec3 camPosition, vec3 lookAt, vec3 up) {\n  vec3 f = normalize(lookAt - camPosition);\n  vec3 s = normalize(cross(f, up));\n  vec3 u = cross(s, f);\n  return mat4(\n    vec4(s, 0.0),\n    vec4(u, 0.0),\n    vec4(-f, 0.0),\n    vec4(0.0, 0.0, 0.0, 1)\n  );\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y * 0.5 / tan(radians(fov));\n  return normalize(vec3(xy, -z));\n}\n\nvoid render(out vec4 fragColor, out vec3 localNormal, in vec2 fragCoord, in vec3 iResolution, in float iTime) {\n  vec3 dir = rayDirection(45.0, iResolution.xy, fragCoord);\n  vec3 eye = vec3(2.0 * sin(0.37 * iTime),\n    1.0,\n    2.0 * cos(0.37 * iTime));\n\n  mat4 cameraToworldMatrix = getCameraToWorldMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n  vec3 dirWorld = (cameraToworldMatrix * vec4(dir, 0.0)).xyz;\n\n  float depth = CLIP_NEAR;\n  if (!rayMarching(eye, dirWorld, depth, CLIP_FAR)) {\n    // hit nothing\n    fragColor = vec4(vec3(0.0), 1.0);\n    return;\n  }\n\n  vec3 pos = eye + dirWorld * depth;\n  vec3 color = phongShading(pos, eye, dirWorld);\n  //get local normal\n  localNormal = (inverse(cameraToworldMatrix) * vec4(estimateNormal(pos), 0.0)).xyz;\n\n  float zDepth = -dir.z * depth / CLIP_FAR;\n  fragColor = vec4(color, zDepth);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"const int SAMPLE_COUNT = 10;\nconst float SAMPLE_RADIUS = 0.05;\nconst float BIAS = 0.3;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  //https://www.shadertoy.com/view/4ltSz2\n  //https://learnopengl.com/Advanced-Lighting/SSAO\n  //https://www.cnblogs.com/wickedpriest/p/13219981.html\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec4 normalZDepth = texture(iChannel0, uv);\n  vec3 normal = normalZDepth.xyz;\n  // depth in cameraView\n  float depth = normalZDepth.w * CLIP_FAR;\n\n  float scale = SAMPLE_RADIUS / depth;\n  int count = SAMPLE_COUNT;\n\n  float occlusion = 0.0;\n  for (int i = 0; i < count; i++) {\n    for (int j = 0; j < count; j++) {\n      //Focus on sampling point\n      vec2 randomUv = (fragCoord.xy + 23.71 * vec2(i, j)) / iChannelResolution[1].xy;\n      vec3 randomDirection = texture(iChannel1, randomUv).xyz * 2.0 - 1.0;\n      //the positive z direction.\n      if (dot(randomDirection, normal) < 0.0)\n        randomDirection = -1.0 * randomDirection;\n\n      vec2 uvOffset = randomDirection.xy * scale;\n      vec4 sampleNormalZDepth = texture(iChannel0, uv + uvOffset);\n\n      vec3 sampleNormal = sampleNormalZDepth.xyz;\n\n      float sampleDepth = depth - sampleNormalZDepth.w * CLIP_FAR;\n\n      vec3 sampleDir = vec3(randomDirection.xy * SAMPLE_RADIUS, sampleDepth);\n\n      occlusion += max(0.0, dot(normalize(normal), normalize(sampleDir)) - BIAS) / (length(sampleDir) + 1.0);\n\n      /*\n       float sampleDepth = sampleNormalZDepth.w * CLIP_FAR; \n      float rangeCheck = smoothstep(0.0, 1.0, SAMPLE_RADIUS / abs(depth - sampleDepth));\n      occlusion += (sampleDepth <= depth + 0.001 ? 1.0 : 0.0) * rangeCheck; \n      */\n    }\n  }\n\n  float ao = clamp(1.0 - occlusion / float(SAMPLE_COUNT * SAMPLE_COUNT), 0.0, 1.0);\n\n  fragColor = vec4(vec3(ao), 1.0);\n  //fragColor = vec4(vec2(randomUv.xy),0.0, 1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"const int KERNEL_RADIUS = 6;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;    \n    vec2 texelSize = ( 1.0 / iResolution.xy );\n    vec4 result = vec4(0.0);\n    int weight = 0;\n    vec4 centerNormalDepth  = texture (iChannel0, uv).rgba;\n    for ( int i = - KERNEL_RADIUS; i <= KERNEL_RADIUS; i ++ ) {\n        for ( int j = - KERNEL_RADIUS; j <= KERNEL_RADIUS; j ++ ) {\n            vec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n            vec4 neighborNormalDepth = texture (iChannel0, uv + offset ).rgba;\n            //Screening sampling point\n            if (dot(neighborNormalDepth.xyz, centerNormalDepth.xyz) < 0.6f ||\n\t\t\tabs(neighborNormalDepth.a - centerNormalDepth.a) > 0.2f) continue;\n            result += texture( iChannel1, uv + offset ).rgba;\n            weight++;\n         }\n     }\n     fragColor = result / float(weight);\n}","name":"Buffer C","description":"","type":"buffer"}]}