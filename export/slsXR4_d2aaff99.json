{"ver":"0.1","info":{"id":"slsXR4","date":"1625281840","viewed":156,"name":"Experiment 1001","username":"kibitz9","description":"More experimentation with using a mandelbox for surface textures.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//***************************************************************//\n// More Fractal Surface Experiments by CMiller (kibitz9)\n// I am experimenting with using fractals for surface detail (greebles). \n// This one I think hides the underlying mandelbox fractal rather well.\n//***************************************************************// \n\nconst float GLOBAL_EPSILON = .0005;\nconst vec2 GLOBAL_PN = vec2(1,-1);\nconst vec3 GLOBAL_PN_XYY=GLOBAL_PN.xyy;\nconst vec3 GLOBAL_PN_YYX=GLOBAL_PN.yyx;\nconst vec3 GLOBAL_PN_YXY=GLOBAL_PN.yxy;\nconst vec3 GLOBAL_PN_XXX=GLOBAL_PN.xxx;\n\nconst vec3 GLOBAL_PN_XYY_EPS=GLOBAL_PN_XYY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YYX_EPS=GLOBAL_PN_YYX*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_YXY_EPS=GLOBAL_PN_YXY*GLOBAL_EPSILON;\nconst vec3 GLOBAL_PN_XXX_EPS=GLOBAL_PN_XXX*GLOBAL_EPSILON;\nconst float MAX_DIST = 10.0;\n\n\n\n\nfloat map7(vec3 p){\n\n\tfloat scale1=3.0;\n\tvec3 sp1=p/scale1;\n\tfloat rp1=4.000400010000001;\n\tfloat r1=2.0;\n\tfloat d1;\n\tif (length(sp1)>rp1){\n\t\td1=length(sp1)-r1;\n\t}\n\telse{\n\t\tfloat sectorSize1=0.31415926536;\n\t\tfloat sectorNumber1=round(atan(sp1.y,sp1.x)/sectorSize1);\n\t\tfloat angleOffset1=-sectorNumber1*sectorSize1;\n\t\tfloat cos1=cos(angleOffset1);\n\t\tfloat sin1=sin(angleOffset1);\n\t\tvec3 q1=vec3(\n\t\t\tsp1.x*cos1-sp1.y*sin1,\n\t\t\tsp1.y*cos1+sp1.x*sin1,\n\t\t\tsp1.z\n\t\t);\n\t\t//float sectorSize2=0.31415926536;\n\t\tfloat sectorNumber2=round(atan(q1.x,q1.z)/sectorSize1);\n\t\tfloat angleOffset2=-sectorNumber2*sectorSize1;\n\t\tfloat cos2=cos(angleOffset2);\n\t\tfloat sin2=sin(angleOffset2);\n\t\tvec3 q2=vec3(\n\t\t\tq1.x*cos2+q1.z*sin2,\n\t\tq1.y,\n\t\t\tq1.z*cos2-q1.x*sin2\n\t\t);\n\t\t//float sectorSize3=0.31415926536;\n\t\tfloat sectorNumber3=round(atan(q2.y,q2.x)/sectorSize1);\n\t\tfloat angleOffset3=-sectorNumber3*sectorSize1;\n\t\tfloat cos3=cos(angleOffset3);\n\t\tfloat sin3=sin(angleOffset3);\n\t\tvec3 q3=vec3(\n\t\t\tq2.x*cos3-q2.y*sin3,\n\t\t\tq2.y*cos3+q2.x*sin3,\n\t\t\tq2.z\n\t\t);\n\t\tfloat cosTheta1=0.70710677;\n\t\tfloat sinTheta1=0.70710677;\n\t\tvec3 rot1=vec3(q3.x,q3.y*cosTheta1+q3.z*sinTheta1,q3.z*cosTheta1+q3.y*-sinTheta1);\n\t\tfloat scale2=0.75;\n\t\tvec3 sp2=rot1/scale2;\n\t\tvec4 q4=vec4(sp2,1.0);\n\t\tvec4 c1=vec4(sp2,1.0);\n\t\tfloat s1=-2.5;//+sin(iTime/7.)*2.;\n\t\tfloat r2=0.5+sin(iTime/3.)*.5;\n\t\tint itr1=10;\n\t\tfloat f1=1.0;\n\t\tfor (int a1=0;a1<itr1;a1++){\n\t\t\tq4.xyz=f1*(clamp(q4.xyz,-1.0,1.0)*2.0-q4.xyz);\n\t\t\tq4 *=s1/clamp(dot(q4.xyz,q4.xyz),r2,1.0);\n\t\t\tq4 +=c1;\n\t\t}\n\t\td1=(length(q4.xyz)/abs(q4.w))*scale2;\n\t}\n\t//Sphere1\n\tfloat radius1 =1.97;\n\tfloat unionleft1=d1;\n\tfloat unionRight1=length(sp1)-radius1;\n\treturn (min(unionleft1,unionRight1))*scale1;\n}\n\nfloat map(in vec3 q){\n\n    float time = iTime/8.5;\n    //return 1.0;\n    vec3 p=q;\n\n    float lookDown=.2;\n    float cosld=cos(lookDown);\n    float sinld=sin(lookDown);\n    p=vec3(p.x,p.y*cosld+p.z*-sinld,p.z*cosld+p.y*sinld);\n    p =vec3(\n        p.x*cos(time)+p.z*-sin(time),\n        p.y\n        ,p.z*cos(time)+p.x*sin(time)\n    );\n    p=p+vec3(0.,-2.+sin(time*2.)*.125,0.);\n    \n    float ang2 = sin(iTime/4.)*.25;\n    p = vec3(p.x*cos(ang2)-p.y*sin(ang2),p.y*cos(ang2)+p.x*sin(ang2),p.z);\n\n    float m;\n    float mb=0.;\n\n    bool bound = false;\n    //float outer = (length(vec3(p.x,p.y*5.,p.z))-1.90);\n   // float t=.008;\n    //if (outer>2.*t){\n\n    //    m=outer-t;\n    //}\n    //else{\n        m= map7(p*5.);\n        m/=5.;\n    //}\n   \n   \n    //m=max(m,outer);\n\n    //float inner=length(vec3(p.x,p.y*6.,p.z))-1.890;\n    //float sub = length(p)-1.4;\n    //sub = abs(sub)-.15;\n    \n    //inner = max(inner,-sub);\n    \n    //inner +=mb/10.;\n    \n  \n    \n    //m=min(m,inner);\n    \n   \n    \n    m/=4.;\n    //float n=m;\n \n    m=min(m,q.y-.1);\n    m=min(m,-q.z+3.);\n   \n    \n    return m;\n }\n    \n    \n    \n \n    \n\n\nvec3 getSurfaceNormal( in vec3 p, float epsilon ) // for function f(p)\n{\n  \n    return normalize(\n        GLOBAL_PN_XYY*map(p+GLOBAL_PN_XYY_EPS) +\n        GLOBAL_PN_YYX*map(p+GLOBAL_PN_YYX_EPS) +\n        GLOBAL_PN_YXY*map(p+GLOBAL_PN_YXY_EPS) +\n        GLOBAL_PN_XXX*map(p+GLOBAL_PN_XXX_EPS) \n    \n    );\n}\n\n\nvoid rayMarch(\n    in vec3 origin, \n    in vec3 ray, \n    in float epsilon,\n    in float maxSteps,\n   \n    out vec3 marchPoint,\n    out float marchPointDist,\n    out float stepsTaken\n\n\n){\n    \n  \n    \n    stepsTaken = 0.0;\n    marchPoint=origin;\n    float h = map(marchPoint);\n    while (h>epsilon&&stepsTaken++<maxSteps&&h<MAX_DIST){\n        marchPoint+=ray*h;       \n        h=map(marchPoint);\n    }   \n    marchPointDist=h;\n}\n\nfloat softShadowBalanced(vec3 surface, vec3 light, float radius, float maxDist){\n   \n    \n  \n    vec3 surfaceToLight = light-surface;\n    float distanceToLight=length(surfaceToLight);\n    float maxDist2 = min(maxDist,distanceToLight);\n    vec3 ray =normalize(surfaceToLight);\n    float artifactCompensation = 1.0;\n    float minDist = 0.2;//think about this.\n    \n    float travelled = minDist;\n    float xx=1.0;\n    while (travelled < maxDist2){\n    \n        float ratioTravelled=travelled/distanceToLight;\n        \n       \n        float relativeRadius=ratioTravelled*radius;\n        \n        float dist=map(surface+ray*travelled);\n         \n        if (dist<-relativeRadius){\n            return 0.0;\n        }\n        float relativeDiameter=relativeRadius*2.0;\n        \n        float dist2=dist+relativeRadius;\n        xx = min(xx,dist2/relativeDiameter);\n        \n       \n        float artifatCompensation2 = artifactCompensation*clamp(relativeRadius/dist,0.,1.);\n        travelled +=max(abs(dist/artifactCompensation),minDist);\n        \n        \n    }\n       \n   return xx;\n    \n\n    \n}\n\nvec3 power(vec3 vec, float power){\n    return vec3(pow(vec.x,power),pow(vec.y,power),pow(vec.z,power));\n}\n\n\n\nvoid calcLight(\n    in vec3 surfacePoint, \n    in float shineAtPosition,\n    in vec3 lightPosition,\n    in vec3 observationPosition,\n    in vec3 lightColor,\n    in float lightBrightness,\n    in vec3 surfaceNormal,\n    in float epsilon,\n    in float lightRadius,\n    out vec3 diffuse, \n    out vec3 specular){\n    \n \n     \n    vec3 col0 = lightColor;\n    \n    \n    vec3 surfaceToLight=lightPosition-surfacePoint;\n    vec3 normalToLight=normalize(surfaceToLight);\n    \n    float oneOverDistToLightSquared = lightBrightness/dot(surfaceToLight,surfaceToLight);\n    \n    \n    \n    float dp = dot(normalToLight,surfaceNormal);\n \n    dp=max(dp,0.0);\n\n    \n    diffuse=dp*lightColor*oneOverDistToLightSquared;\n    \n    \n    vec3 rayToObs=normalize(observationPosition-surfacePoint);\n    vec3 avg = normalize(normalToLight+rayToObs);\n    float spec = dot(avg,surfaceNormal);\n    spec = max(spec,0.0);\n    \n    spec = pow(spec,shineAtPosition);\n\n    specular=lightColor*spec*oneOverDistToLightSquared;\n    \n    float shadowAdjust = 1.0;\n    \n\n    if (true){\n        float s = softShadowBalanced(surfacePoint,lightPosition,lightRadius, 500.); \n        diffuse*=s*shadowAdjust;\n        specular*=s*shadowAdjust;\n    }\n \n}\n\n\nvoid mainImage1( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n    vec3 eye = vec3(0.0,0.0,-.5);\n    vec3 lense = vec3(0.0,0.0,.5);\n    float xxx = 0.;\n    vec3 cameraPosition = vec3(0.,2.,-(5.+xxx)+sin(iTime/10.)*xxx);\n    float specAmt = 0.0;\n\n    vec2 uv = fragCoord/iResolution.xy;\n    float epsilon1 = .002;\n    \n   \n    vec3 objColor=vec3(1,1,1);\n  \n    vec2 ar = (fragCoord/iResolution.x)\n        -vec2(.5,iResolution.y/(2.0*iResolution.x));\n    vec3 lenseIntersection = vec3(ar,lense.z);\n    \n    vec3 ray = normalize(lenseIntersection-eye);\n   \n    \n    float stepsTaken;\n    vec3 finalPosition;\n    float finalDistance;\n\n    float maxSteps = 4000.0;\n    \n    rayMarch(eye+cameraPosition,ray,epsilon1,maxSteps,finalPosition,finalDistance,stepsTaken);\n    \n  \n    \n    float objectShine=14.;\n    \n    \n    vec3 diffuse1;\n    vec3 specular1;\n\n    vec3 diffuse2;\n    vec3 specular2;\n\n    vec3 diffuse3;\n    vec3 specular3;\n\n    vec3 diffuse4;\n    vec3 specular4;\n    if (finalDistance<epsilon1){\n    \n\n        finalPosition = finalPosition+(ray*epsilon1*-2.0);\n        vec3 normal = getSurfaceNormal(finalPosition,epsilon1);\n        \n       \n        \n        float lightBrightness = 1400.;\n        float specMult = 2.0;\n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(30.0,40.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.25,.25,1.),//light color\n            lightBrightness*1.55,//light bright\n       \n            normal,\n            epsilon1,\n            1.,\n            diffuse1,\n            specular1\n        );\n        \n        \n         calcLight(\n            finalPosition,\n            objectShine,\n            vec3(-30.0,40.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.7,.325,0.)*.5,//light color\n            lightBrightness*1.5,//light bright\n            normal,\n            epsilon1,\n            1.,\n            diffuse2,\n            specular2\n        );\n        \n        \n        \n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,30.0,-40.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(.25,.9,.1)*.5,//light color\n            lightBrightness*.75,//light bright\n            normal,\n            epsilon1,\n            .5,\n            diffuse3,\n            specular3\n        );\n        \n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(130.0,30.0,-480.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.9,.3)*.5,//light color\n            lightBrightness*5.,//light bright\n            normal,\n            epsilon1,\n            diffuse3,\n            specular3\n        );\n        */\n        \n        \n        /*\n        calcLight(\n            finalPosition,\n            objectShine,\n            vec3(0.0,10.0,-5.0),//lightposition\n            eye+cameraPosition,//observation position\n            vec3(1.,.8,.5)*.5,//light color\n            lightBrightness/20000.,//light bright\n            normal,\n            epsilon1,\n            diffuse4,\n            specular4\n        );\n    */\n    \n    \n        \n    \n        vec3 col1=objColor*max(diffuse1,0.0);\n        col1+=specular1*specMult;\n        \n        vec3 col2=objColor*max(diffuse2,0.0);\n        col2+=specular2*specMult;\n        \n        vec3 col3=objColor*max(diffuse3,0.0);\n        col3+=specular3*specMult;\n        \n        //vec3 col4=objColor*max(diffuse4,0.0);\n        //col4+=specular4*specMult;\n        \n        \n      \n       \n        \n        //vec3 colFinal = min(col1+col2,1.0);\n        //vec3 colFinal = min(col1+col2+col3+col4,1.);\n        vec3 colFinal = min(col1+col2+col3,1.);\n        colFinal=power(colFinal,.9);\n        \n     \n        \n        colFinal = pow(colFinal,vec3(.75,.74,.73));\n        \n        fragColor = vec4(colFinal,1.0);\n        \n    }\n    else{\n        fragColor = vec4(.2,0,0,1.0);\n\n    }\n    \n\n    \n    \n}\n\nvoid AntiAlias3( out vec4 fragColor, in vec2 fragCoord, float aaLevel){\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float subPixel = 1.0/aaLevel;\n    vec4 result = vec4(0,0,0,1);\n    for (float x=fragCoord.x;x<fragCoord.x+1.0;x+=subPixel){\n        for (float y=fragCoord.y;y<fragCoord.y+1.0;y+=subPixel){\n            vec4 temp;\n            mainImage1(temp,vec2(x,y));\n            result+=temp;\n        }\n    }\n    \n    //vec3 r = vec3(0);\n    //vec3 x = vec3(1);\n    //vec3 t = clamp(r,x,x);\n    \n    \n    fragColor = result/(aaLevel*aaLevel);\n   \n    \n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord){\n    if (false){\n        AntiAlias3(fragColor, fragCoord,2.);\n    }\n    else{\n        vec4 result = vec4(0,0,0,1);\n        mainImage1(result,fragCoord);\n        fragColor=result;\n    }\n\n}\n","name":"Image","description":"","type":"image"}]}