{"ver":"0.1","info":{"id":"tsBGRV","date":"1549559681","viewed":141,"name":"Interreflection Glow","username":"valler","description":"Trace reflections and add some emission","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["reflection","ray","distance","march","trace","emission"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time (.5*iTime)\n\n    const int spp = 4;\nconst float focalLength = 2.4;\nconst float tMax = 5.;\nconst float dMin = 1.e-3;\nconst float oMin = 1.e-3;\nconst float tMin = 1.e-3;\nconst float inv2PI = 0.15915494309189535;\n\n// https://www.shadertoy.com/view/4lVcRm\nvec2 R2seq(int n)\n{\n\treturn fract(vec2(n) * vec2(0.754877666246692760049508896358532874940835564978799543103, 0.569840290998053265911399958119574964216147658520394151385));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n// https://www.shadertoy.com/view/Ml3Gz8\nfloat smin(float a, float b, float k) {\n    float h = clamp(.5+.5*(a-b)/k,0.,1.);\n    return mix(a,b,h)-k*h*(1.-h);\n}\n\nfloat D (vec3 ro)\n{\n    vec3 c0 = vec3(.2,0,1.5);\n    vec3 c1 = vec3(-.325,0,1.5);\n    float t = .5*time;\n    mat3 m = mat3(1,0,0,0,cos(t),sin(t),0,-sin(t),cos(t));\n    float d0 = sdBox(m*(ro-c0),vec3(.2))-.01;\n\tfloat d1 = length(ro-c1)-.2;\n    return smin(d0,d1,sin(time)*.35+.35);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 N( vec3 p, float t )\n{\n    float e = 1.e-3*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*D( p + h.xyy*e ) + \n\t\t\t\t\t  h.yyx*D( p + h.yyx*e ) + \n\t\t\t\t\t  h.yxy*D( p + h.yxy*e ) + \n\t\t\t\t\t  h.xxx*D( p + h.xxx*e ));\n}\n\nvoid T (inout vec3 col, inout vec3 emi, inout float t, inout vec3 ro, inout vec3 rd)\n{\n\tfloat sd = D(ro);\n    float ud = abs(sd);\n \tif (ud < dMin)\n    {\n        vec3 n = sign(sd)*N(ro,t);\n        rd = reflect(rd,n);\n        emi *= col;\n        ro += rd*ud+oMin*n;\n        emi += 100.*vec3(1.,.1,.01)*smoothstep(.15,.2,ro.x-.05*sin(50.*ro.y-3.*time));\n        float a = 1.0-abs(dot(n,-rd));\n        col *= a*a*a*a*a*.96+.04;\n        ud = dMin;\n    }\n    else ro += rd*ud;\n    t += max(ud,tMin);\n}\n\nvec3 Env(vec3 rd)\n{\t\n    vec2 ruv = vec2(atan(rd.z,rd.x)*inv2PI,rd.y*0.5)+0.5;\n    ruv = vec2(.01*time,rd.y-.05*sin(20.*rd.x+5.*time));\n    vec3 t0 = round(10.*texture(iChannel0,ruv).xxx)*.1;\n    return 10.*pow(fract(t0),vec3(5));\n}\n\nvoid C (inout vec3 color, int i, vec3 ro, vec2 uv, float dt)\n{\n    vec3 rd = vec3(normalize(vec3(uv*dt+(R2seq(i)-.5)*dt,focalLength)));\n    rd.x *= -1.;\n    vec3 col = vec3(1);\n    vec3 emi = vec3(0);\n    for (float t = 1.; t < tMax; T(col,emi,t,ro,rd));\n\tcolor += col*Env(rd)+emi;\n}\n\nvoid mainImage (out vec4 _, vec2 coord)\n{\n    vec3 color = vec3(0);\n    float dt = 1./max(iResolution.x,iResolution.y);\n    vec2 uv = -iResolution.xy+2.*coord;\n    vec3 ro = vec3(0,0,-.5);\n    for (int i = 0; i < spp; C(color,i++,ro,uv,dt));\n\t_ = vec4(sqrt(color/float(spp)),1);\n}","name":"Image","description":"","type":"image"}]}