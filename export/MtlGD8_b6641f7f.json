{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define SQUARE_PATH\n#define CAM_MOVING\n\n#define MAX_STEPS 64\n#define EPSILON .001\n\n#define M_PI 3.14159265358979\n\n//#define ANTIALIASING\n//#define AA5\nconst float AADist = 0.25;\n\nconst float MaxDistance = 80.;\nconst vec3 FadeLightSource = vec3(4., 4., -2.);\nconst vec3 LightSource2 = vec3(-10., 10., 10.);\n\nconst vec3 TableColor = vec3(0.42, 0.57, 0.14);\nconst vec3 BarrierColor = vec3(0.55, 0.27, 0.08);\nconst vec3 RoomColor = vec3(0.37, 0.36, 0.21);\nconst vec3 DoorColor = vec3(0.);\nconst vec3 WinColor = vec3(2.);\n\nconst float BallRadius = 1.0;\nconst float BallReflectivity = 0.3;\nconst vec2 StartBallPos = vec2(0, 1);\n\nconst float TableHeight = 0.0;\nconst float BarrierThickness = 0.8;\nconst float RoomRadius = 20.0;\n\nconst float CamRotSpeed =  1.0 / 25.0;\n\n#ifdef SQUARE_PATH\nconst float TableSize = 2.0 * BallRadius * (2.0 * M_PI / sqrt(2.0) + 1.0);\nvec2 StartVel = normalize(vec2(1, 1));\nconst float EyePosRadius = 9.0;\n#else\nfloat TableSize = 2.0 * BallRadius * (2.0 * M_PI * 10.0 / sqrt(101.0) + 1.0);\nvec2 StartVel = normalize(vec2(0.1, 1));\nconst float EyePosRadius = 11.0;\n#endif\n\nconst float HalfSizeTable = TableSize / 2.0;\n\nfloat TableSurface(vec3 a) {\n\tvec3 sz = vec3(HalfSizeTable, 0, HalfSizeTable);\n\treturn length(max(abs(a) - sz, 0.));\n}\n\nfloat Box(vec3 a, vec3 sz) {\n\treturn length(max(abs(a) - sz, 0.));\n}\n\nfloat sBox(vec3 a, vec3 sz) {\n  vec3 d = abs(a) - sz;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat Barrier(vec3 a) {\n\tfloat ht = BarrierThickness / 2.0;\n\tfloat bx1 = sBox(a + vec3(HalfSizeTable + ht, -ht, 0), vec3(ht, ht, HalfSizeTable + BarrierThickness));\n\tfloat bx2 = sBox(a + vec3(-HalfSizeTable - ht, -ht, 0), vec3(ht, ht, HalfSizeTable + BarrierThickness));\n\tfloat bx3 = sBox(a + vec3(0, -ht, HalfSizeTable + ht), vec3(HalfSizeTable + BarrierThickness, ht, ht));\n\tfloat bx4 = sBox(a + vec3(0, -ht, -HalfSizeTable - ht), vec3(HalfSizeTable + BarrierThickness, ht, ht));\n\treturn min(min(bx1, bx2), min(bx3, bx4));\n}\n\nfloat Room(vec3 a) {\n\tfloat wallSize = 60.0;\n\tfloat hs = wallSize / 2.0;\n\tfloat floorDist = wallSize / 8.0;\n \tfloat wl1 = sBox(a + vec3(RoomRadius, -hs + floorDist, 0), vec3(0.1, hs, hs));\n\tfloat wl2 = sBox(a + vec3(-RoomRadius, -hs + floorDist, 0), vec3(0.1, hs, hs));\n\tfloat wl3 = sBox(a + vec3(0, -hs + floorDist, RoomRadius), vec3(hs, hs, 0.1));\n\tfloat wl4 = sBox(a + vec3(0, -hs + floorDist, -RoomRadius), vec3(hs, hs, 0.1));\n\tfloat cl = sBox(a + vec3(0, -wallSize + floorDist, 0), vec3(hs, 0.1, hs));\n\tfloat fl = sBox(a + vec3(0, floorDist, 0), vec3(hs, 0.1, hs));\n\treturn min(min( min(wl1, wl2), min(wl3, wl4) ), min(cl, fl));\n}\n\nfloat Doors(vec3 a) {\n\tfloat size = 25.0;\n\tfloat floorDist = 10.0;\n\tfloat hs = size / 2.0;\n    vec3 sz = vec3(hs / 4.0, hs, 0.2);\n\tfloat dr1 = Box(a + vec3(0.0, -hs + floorDist, RoomRadius), sz);\n\tfloat dr2 = Box(a + vec3(0.0, -hs + floorDist, -RoomRadius), sz);\n\treturn min(dr1, dr2);\n}\n\nfloat Windows(vec3 a) {\n\tfloat size = 20.0;\n    float floorDist = 1.0;\n\tfloat hs = size / 2.0;\n    vec3 sz = vec3(0.15, hs, hs / 6.0);\n\tfloat w1 = Box(a + vec3(RoomRadius, -hs - floorDist, 0.0), sz);\n\tfloat w2 = Box(a + vec3(-RoomRadius, -hs - floorDist, 0.0), sz);\n\treturn min(w1, w2);\n}\n\nfloat Amplitude = (TableSize / 2.0 - BallRadius);\n\nfloat GetPos(float dist, float startPos) {\n\treturn Amplitude * (mod(dist - startPos, 2.0) - 1.0) * sign(mod(dist - startPos, 4.0) - 2.0);\n}\n\nvec2 GetBallPos(float time) {\n\treturn vec2(GetPos(StartVel.x * time, StartBallPos.x), GetPos(StartVel.y * time, StartBallPos.y));\n}\n\nvec3 ballCenter;\n\nfloat Ball(vec3 a) {\n\treturn length(a - ballCenter) - 1.;\n}\n\nfloat Scene(vec3 a) {\n\treturn min( min( min(Ball(a), TableSurface(a)), min(Room(a), Barrier(a)) ), min(Doors(a), Windows(a)));\n}\n\nconst vec4 CanvasColor = vec4(247.0 / 255.0, 242.0 / 255.0, 212.0 / 255.0, 1.0);\nconst vec4 DigitColor = vec4(0.0, 0.0, 0.0, 1);\n\nvec4 DrawCircle(vec2 pos, vec2 center, vec4 color) {\n\tfloat radius = 0.133;\n\t\n\tfloat k = 2.0; // w/h = 2\n\t\n\tvec2 cPos = pos - center;\n\tcPos.x *= k;\n\t\n\tif (length(cPos) < radius)\n\t\tcolor = CanvasColor;\n\t\t\n\t// digits\n\tfloat h_2 = 0.052;\n\tfloat w = 0.022;\n\tfloat dc1 = -0.030;\n\t\n\tif ((dc1 - w < cPos.x) && (cPos.x < dc1) && (-h_2 < cPos.y) && (cPos.y < h_2))\n\t\tcolor = DigitColor;\n\t\t\n\tfloat r = 0.054;\n\tfloat dc0 = 0.05;\n\tvec2 zcPos = vec2(cPos.x * 1.5 - dc0, cPos.y);\n\t\n\tvec2 zcPos2 = vec2((cPos.x - dc0 / 1.5) * 2.0, cPos.y);\n\n\tif ( ( (r - w) < length(zcPos2) ) && (length(zcPos) < r) )\n\t\tcolor = DigitColor;\n\t\t\n\treturn color;\n}\n\nvec4 DrawTex(vec2 pos) {\n\tconst float stripWidth = 0.45;\n\t\n\tconst vec4 stripColor = vec4(20.0 / 255.0, 50.0 / 255.0, 80.0 / 255.0, 1.0);\n\t\n\tvec4 res = CanvasColor;\n\n\t// draw strip\n\tif ( (pos.y > (0.5 - stripWidth / 2.0)) && (pos.y < (0.5 + stripWidth / 2.0)) )\n\t\tres = stripColor;\n\t\t\n\t// draw circles with digits\n\tres = DrawCircle(pos, vec2(0.245, 0.5), res);\n\tres = DrawCircle(pos, vec2(0.755, 0.5), res);\n\t\t\n\treturn res;\n}\n\n// Rotate around axis\nvec4 Quat(vec3 axis, float angle) {\n\tvec4 quat;\n\tquat.xyz = axis * sin(angle * 0.5);\n\tquat.w = cos(angle / 2.0);\n\treturn quat;\n}\n\n// Multiply quaternion by vector\nvec3 Transform(vec4 q, vec3 v) {\n\tvec3 uv = 2.0 * cross(q.xyz, v);\n\tvec3 uuv = cross(q.xyz, uv);\n\treturn v + uv * q.w + uuv;\n}\n\nvec3 uVec, rVec; // transformed BallUpVec and BallRightVec\n\nvec3 BallTextureColor(vec3 a) {\n\tvec3 eVec = normalize(cross(rVec, uVec)); // eye vec\n\n\tvec3 radVec = normalize(a - ballCenter);\n\t\n\tfloat angle1 = acos(-dot(radVec, uVec)) / M_PI;\n\n\tvec3 N = uVec;    // plane normal\n\tfloat K = -dot(N, radVec);\n\tvec3 prRadVec = radVec + K * N;  // equator plan projection\n\tvec3 equatorRadVec = normalize(prRadVec);\n\n\tfloat semiSphere = dot(equatorRadVec, eVec);\n\tfloat angle2 =  acos(-dot(equatorRadVec, rVec)) / M_PI / 2.0;\n\tif (semiSphere < 0.0)\n\t\tangle2 = acos(dot(equatorRadVec, rVec)) / M_PI / 2.0 + 1.0/2.0;\n\n\treturn DrawTex(vec2(angle2, angle1)).rgb;\n}\n\nstruct MaterialInfo {\n\tvec3 Kd;\n\tfloat Shininess;\n};\n\nbool ballReflection = false;\n\nMaterialInfo Material(vec3 a) {\n\tMaterialInfo m = MaterialInfo(vec3(0.), 0.);\n\tfloat closest = MaxDistance;\n\n\tfloat roomDistance = Room(a);\n\tif (roomDistance < closest) {\n\t\tm.Kd = RoomColor;\n\t\tm.Shininess = 20.;\n\t\tclosest = roomDistance;\n\t}\n\n\tfloat doorDistance = Doors(a);\n\tif (doorDistance < closest) {\n\t\tm.Kd = DoorColor;\n\t\tm.Shininess = 0.;\n\t\tclosest = doorDistance;\n\t}\n\n\tfloat winDistance = Windows(a);\n\tif (winDistance < closest) {\n\t\tm.Kd = WinColor;\n\t\tm.Shininess = 0.;\n\t\tclosest = winDistance;\n\t}\n\t\n\tfloat tableDistance = TableSurface(a);\n\tif (tableDistance < closest) {\n\t\tm.Kd = TableColor;\n\t\tm.Shininess = 20.;\n\t\tclosest = tableDistance;\n\t}\n\n\tfloat barrierDistance = Barrier(a);\n\tif (barrierDistance < closest) {\n\t\tm.Kd = BarrierColor;\n\t\tm.Shininess = 80.;\n\t\tclosest = barrierDistance;\n\t}\n\n\tfloat ballDistance = Ball(a);\n\tif ((ballDistance < closest) && (!ballReflection)) {\n\t\tm.Kd = BallTextureColor(a);\n\t\tm.Shininess = 150.;\n\t\tballReflection = true;\t\n\t}\n\treturn m;\n}\n\nvec3 Normal(vec3 a) {\n\tvec2 e = vec2(.001, 0.);\n\tfloat s = Scene(a);\n\treturn normalize(vec3(\n\t\tScene(a+e.xyy) - s,\n\t\tScene(a+e.yxy) - s,\n\t\tScene(a+e.yyx) - s));\n}\n\nfloat Occlusion(vec3 at, vec3 normal) {\t\n\tfloat b = 0.;\n\tfor (int i = 1; i <= 4; ++i) {\t\t\n\t\tfloat L = .06 * float(i);\n\t\tfloat d = Scene(at + normal * L);\n\t\tb += max(0., L - d);\n\t}\n\treturn min(b, 1.);\n}\n\nvec3 LookAt(vec3 pos, vec3 at, vec3 rDir) {\n\tvec3 f = normalize(at - pos);\n\tvec3 r = cross(f, vec3(0., 1., 0.));\n\tvec3 u = cross(r, f);\n\treturn mat3(r, u, -f) * rDir;\n}\n\nfloat Trace(vec3 rPos, vec3 rDir, float distMin) {\n\tfloat L = distMin;\n\tfor (int i = 0; i < MAX_STEPS; ++i) {\n\t\tfloat d = Scene(rPos + rDir * L);\n\t\tL += d;\n\t\tif (d < EPSILON * L) break;\n\t}\n\treturn L;\n}\n\nvec3 Lighting(vec3 at, vec3 normal, vec3 eye, MaterialInfo m, vec3 lColor, vec3 lPos) {\n\tvec3 lDir = lPos - at;\n\t\n\tvec3 lDirN = normalize(lDir);\n\tfloat t = Trace(at, lDirN, EPSILON*2.);\n\tif (t < length(lDir)) {\n\t\treturn vec3(0.);\n\t}\n\tvec3 color = m.Kd * lColor * max(0., dot(normal, normalize(lDir)));\n\t\n\tif (m.Shininess > 0.) {\n\t\tvec3 h = normalize(normalize(lDir) + normalize(eye - at));\n\t\tcolor += lColor * pow(max(0., dot(normal, h)), m.Shininess) * (m.Shininess + 8.) / 25.;\n\t}\n\treturn color;\n}\n\nvec3 FadeLighting(vec3 at, vec3 normal, vec3 eye, MaterialInfo m) {\t\n\tvec3 color = Lighting(at, normal, eye, m, vec3(1.2), FadeLightSource);\n\tvec3 lDir = FadeLightSource - at;\n\treturn 5.0 * color / dot(lDir, lDir);\n}\n\nvec3 Shade(vec3 rpos, vec3 rdir, float t, vec3 pos, vec3 nor)\n{\t\n\tMaterialInfo mat = Material(pos);\n\n\t// ambient light\n\tvec3 color = .11 * (1. - Occlusion(pos, nor)) * mat.Kd;\n\n\t// light from light source\n\tcolor += FadeLighting(pos, nor, rpos, mat);\n\tcolor += Lighting(pos, nor, rpos, mat, vec3(0.6), LightSource2);\n\n\treturn color;\n}\n\n\nvec3 ShadeAndReflect(vec3 rpos, vec3 rdir, float t)\n{\n\tvec3 pos = rpos + rdir * t;\n\tvec3 nor = Normal(pos);\n\n\tvec3 color = Shade(rpos, rdir, t, pos, nor);\n\n\tif (ballReflection)\n\t{\n\t\trdir = normalize(reflect(rdir, nor));\n\t\trpos = pos + rdir * EPSILON * 2.;\n\t\t\n\t\tfloat t = Trace(rpos, rdir, 0.);\n\n\t\tpos = rpos + rdir * t;\n\t\tnor = Normal(pos);\n\t\tcolor += Shade(rpos, rdir, t, pos, nor) * BallReflectivity;\n\n\t\tballReflection = false;\n\t}\n\t\n\treturn color;\n}\n\nvec3 Camera(vec2 px) {\n    #ifdef CAM_MOVING\n\tvec3 camPos = vec3(EyePosRadius * sin(CamRotSpeed * iTime), 3., EyePosRadius * cos(CamRotSpeed * iTime));\n\t#else\n\tvec3 camPos = vec3(0., 3., EyePosRadius);\n\t#endif\n    \n\tvec2 uv = px / iResolution.xy * 2. - 1.;\t\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 rayStart = camPos;\n\tvec3 rayDirection = LookAt(rayStart, vec3(0, -1, 0), normalize(vec3(uv, -2.)));\n\tfloat path = Trace(rayStart, rayDirection, 0.);\t\n\treturn ShadeAndReflect(rayStart, rayDirection, path);\n}\n\nvoid CreateBall() {\n\tvec2 ballPos = GetBallPos(iTime);\n\tballCenter = vec3(ballPos.x, TableHeight + BallRadius, ballPos.y);\n\t\n\tconst float deltaTime = 0.001;\n\tvec2 ballPosPrev = GetBallPos(iTime - deltaTime);\n\tvec2 moveVec = ballPos - ballPosPrev;\n\n\t// Rotate aroung path normal\n\tvec4 quat = Quat(normalize(vec3(moveVec.y, 0, -moveVec.x)), length(Amplitude * iTime * StartVel));\n\t\n\tconst vec3 BallUpVec = vec3(0.0, 1.0, 0.0);\n\tconst vec3 BallRightVec = vec3(1.0, 0.0, 0.0);\n\t\n\tuVec = normalize(Transform(quat, BallUpVec));\n\trVec = normalize(Transform(quat, BallRightVec));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tCreateBall();\n\tvec3 col = vec3(0.0);\n\t\n\t#ifdef ANTIALIASING\n    \n    \t#ifdef AA5\n\t\tcol = Camera(fragCoord.xy);\n\t\tcol += Camera(vec2(fragCoord.x + AADist, fragCoord.y + AADist));\n\t\tcol += Camera(vec2(fragCoord.x - AADist, fragCoord.y + AADist));\n\t\tcol += Camera(vec2(fragCoord.x + AADist, fragCoord.y - AADist));\n\t\tcol += Camera(vec2(fragCoord.x - AADist, fragCoord.y - AADist));\n\t\tcol /= 5.0;\n    \t#else\n\t\tcol = Camera(vec2(fragCoord.x, fragCoord.y + AADist));\n\t\tcol += Camera(vec2(fragCoord.x + AADist * sqrt(3.0) / 2.0, fragCoord.y - AADist / 2.0));    \t\n\t\tcol += Camera(vec2(fragCoord.x - AADist * sqrt(3.0) / 2.0, fragCoord.y - AADist / 2.0));\n\t\tcol /= 3.0;\n    \t#endif\n    \n    #else\n\tcol = Camera(fragCoord.xy);\n\t#endif\n\n\tfragColor = vec4(col, 0.);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MtlGD8","date":"1421783178","viewed":940,"name":"Perpetual rolling","username":"AlexPer76","description":"Billiard table and ball","likes":16,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}