{"ver":"0.1","info":{"id":"ts23RK","date":"1549485223","viewed":188,"name":"tinykaboom (Shadertoy port)","username":"trevortheblack","description":"See header, A direct port of tinykaboom to shadertoy","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* LICENSE - There Ain't One\n\n * Shadertoy port of ssloy's tinykaboom\n *  see https://github.com/ssloy/tinykaboom\n * tinykaboom license:\n\nDO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n                   Version 2, December 2004\n \nCopyright (C) 2004 Sam Hocevar <sam@hocevar.net>\n\nEveryone is permitted to copy and distribute verbatim or modified\ncopies of this license document, and changing it is allowed as long\nas the name is changed.\n \n           DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE\n  TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n\n 0. You just DO WHAT THE FUCK YOU WANT TO.\n\n\n*/\n\nconst float sphereRadius = 1.5;\nconst float noiseAmplitude = 1.0;\n\n#define M_PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062\nconst float vFov = M_PI/3.0;\n\nfloat lerp(in float f0, in float f1, float t)\n{\n    return f0 + (f1-f0)*max(0.0, min(1.0, t));   \n}\n\nvec3 lerp(in vec3 v0, in vec3 v1, float t)\n{\n    return v0 + (v1-v0)*max(0.0, min(1.0, t));   \n}\n\n\n\n// lol what\nfloat hash(const float n)\n{\n    float x = sin(n)*43758.5453;\n    return x-floor(x);\n}\n\nfloat noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = x - p;\n    f = f * dot(f, vec3(3.0,3.0,3.0)-2.0*f);\n    float n = dot(p, vec3(1.0, 57.0, 113.0));\n    return lerp(lerp(\n                   lerp(hash(n + 0.0), hash(n + 1.0), f.x),\n                   lerp(hash(n + 57.0), hash(n + 58.0), f.x),\n                   f.y\n               ),\n               lerp(\n                   lerp(hash(n + 113.0), hash(n + 114.0), f.x),\n                   lerp(hash(n + 170.0), hash(n + 171.0), f.x),\n                   f.y                   \n               ), \n               f.z);\n}\n\nvec3 rotate(in vec3 v)\n{\n    return vec3(dot(v, vec3( 0.0,  0.8,   0.6)),\n                dot(v, vec3(-0.8,  0.36, -0.48)),\n                dot(v, vec3(-0.6, -0.48,  0.64))\n               );\n}\n\n// ssloy explicitly wishes to replace this function\nfloat fractalBrownianMotion(in vec3 x)\n{\n    vec3 p = rotate(x);\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.32;\n    f += 0.2500*noise(p); p = p*3.03;\n    f += 0.1250*noise(p); p = p*2.61;\n    f += 0.0625*noise(p);\n    return f/0.9375;    \n}\n\n// Play with this for varying fire effects\nvec3 paletteFire(in float d)\n{\n    const vec3 yellow = vec3(1.7, 1.3, 1.0); // Hot value\n    const vec3 orange = vec3(1.0, 0.6, 0.0);\n    const vec3 red = vec3(1.0, 0.0, 0.0);\n    const vec3 darkgray = vec3(0.2, 0.2, 0.2);\n    const vec3 gray = vec3(0.4, 0.4, 0.4);\n    \n    float x = max(0.0, min(1.0, d));\n    if (x<.25f)\n        return mix(gray, darkgray, x*4.f);\n    else if (x<.5f)\n        return mix(darkgray, red, x*4.f-1.f);\n    else if (x<.75f)\n        return mix(red, orange, x*4.f-2.f);\n    return mix(orange, yellow, x*4.f-3.f);\n}\n\nfloat signedDistance(in vec3 p)\n{\n    float displacement = -fractalBrownianMotion(p*3.4 + vec3(0.1, 0.1, 0.1)*iTime)*noiseAmplitude;\n    return length(p) - (sphereRadius + displacement) * (0.1 + 0.9*sin(mod(iTime*(2./M_PI), M_PI/2.)));\n}\n\nbool sphereTrace(in vec3 orig, in vec3 dir, out vec3 pos)\n{\n    if ( dot(orig, orig) - (dot(orig,dir)*dot(orig,dir)) > (sphereRadius*sphereRadius))\n        return false;\n        \n    pos = orig;\n    for(int i = 0; i < 128; i++)\n    {\n        float d = signedDistance(pos);\n        if (d < 0.0) return true;\n        pos = pos + dir*max(d*0.1, 0.01);\n    }\n    return false;\n}\n\n\nvec3 distanceFieldNormal(in vec3 pos)\n{\n    const float eps = 0.1;\n    float d = signedDistance(pos);\n    float nx = signedDistance(pos + vec3(eps, 0.0, 0.0)) - d;\n    float ny = signedDistance(pos + vec3(0.0, eps, 0.0)) - d;\n    float nz = signedDistance(pos + vec3(0.0, 0.0, eps)) - d;\n    return normalize(vec3(nx, ny, nz));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dirX = (fragCoord.x + 0.5) - iResolution.x/2.0;\n    float dirY = -(fragCoord.y + 0.5) + iResolution.y/2.0;\n    float dirZ = -iResolution.y/(2.0*tan(vFov/2.0));\n    \n    vec3 hit;\n    if(sphereTrace(vec3(0.0,0.0,3.0), normalize(vec3(dirX, dirY, dirZ)), hit))\n    {\n        float noiseLevel = (sphereRadius - length(hit))/noiseAmplitude;\n        vec3 lightDir = normalize((vec3(10.0, 10.0, 10.0) - hit));\n        float lightIntensity = max(0.4, dot(lightDir,distanceFieldNormal(hit)));\n        fragColor = vec4(paletteFire(2.0*(-0.2+noiseLevel))*lightIntensity, 1.0);\n    }\n    else\n        fragColor = vec4(0.2, 0.7, 0.8, 1.0);\n\n}","name":"Image","description":"","type":"image"}]}