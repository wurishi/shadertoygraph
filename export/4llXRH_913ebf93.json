{"ver":"0.1","info":{"id":"4llXRH","date":"1434489258","viewed":1386,"name":"Path Traced Ice Cube","username":"revers","description":"Simple path traced ice cube.","likes":39,"published":1,"flags":0,"usePreview":0,"tags":["cube","pathtracing","ice"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/**\n * Created by Kamil Kolaczynski (revers) - 2015\n * Licensed under Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n *\n * This shader uses code written by: \n * - iq (hash, noise, intersection routines, raymarching, and probably something else I forgot about :) )\n * - reinder (part of path tracing routines, https://www.shadertoy.com/view/4tl3z4)\n * - Syntopia (other part of path tracing routines, http://blog.hvidtfeldts.net/index.php/2015/01/path-tracing-3d-fractals/)\n * - Dave_Hoskins (hash without sine, https://www.shadertoy.com/view/4djSRW)\n * Thanks for sharing it guys!\n * \n * The shader was created and exported from Synthclipse (http://synthclipse.sourceforge.net/)\n */\n\n//#define QUALITY_LOW\n//#define QUALITY_MEDIUM\n#define QUALITY_HIGH\n//#define QUALITY_VERY_HIGH\n\n//#define AA_CHECKERBOARD_TEXTURE\n\n#ifdef QUALITY_VERY_HIGH\nconst int SamplesPerPixel = 10;\nconst int RayDepth = 8;\n#elif defined(QUALITY_HIGH)\nconst int SamplesPerPixel = 6;\nconst int RayDepth = 4;\n#elif defined(QUALITY_MEDIUM)\nconst int SamplesPerPixel = 6;\nconst int RayDepth = 4;\n#else /* if defined(QUALITY_LOW) */\nconst int SamplesPerPixel = 2;\nconst int RayDepth = 4;\n#endif\n\nconst float MarchDumping = 0.84999996;\nconst float Far = 60.0;\nconst int MaxSteps = 64;\nconst float IceCubeGlossiness = 0.0;\nconst float IceCubeFresnel = 1.45;\nconst float CubeLength = 3.0;\nconst float ScaleFactor = 0.2873;\nconst vec3 IceCubeColor = vec3(1.0, 1.0, 1.0);\nconst bool DirectLight = true;\nconst bool EnableCaustics = false;\nconst bool CosWeighted = true;\nconst float CosWeightedExp = 1.0;\nconst float FOV = 0.228;\n\nconst bool ShowLight = false;\nconst float LightRadius = 2.5574498;\nconst float LightIntensity = 5.218;\nconst vec3 LightPosition = vec3(-14.599998, 18.400002, 13.199997);\nconst vec3 LightColor = vec3(1.0, 1.0, 1.0);\n\nconst mat3 Rotation = mat3(-0.5036228, -0.86392355, -2.0861626E-7, -0.22534683, 0.1313659, -0.9653816, 0.83401597, -0.4861882, -0.26084125);\n\n#define PI 3.14159265359\n#define PI_INV 0.31830988618\n#define TWO_PI 6.28318530718\n\n#define MAT_NONE -1.0\n#define MAT_CHECKER_PLANE 1.0\n#define MAT_ICE_CUBE 2.0\n#define MAT_MIRROR 3.0\n#define MAT_MAIN_LIGHT 4.0\n\n#define DISTANCE(v) v.x\n#define MATERIAL(v) v.y\n\n// Schlick approximation gives poor quality of refraction.\n//#define USE_SCHLICK_APPROX\n\n#define AIR_INDEX_OF_REFRACTION 1.0\n\nconst float EPS = 0.0001;\nconst float MAX_DIST = 1e10;\n\n// Random variable seed.\nfloat seed = 0.0;\n\nstruct Material {\n\tbool isReflective;\n\tbool isTransmissive;\n\tfloat fresnel;\n\tfloat glossiness;\n};\n\n/*************************************************************************\n * Intersection routines\n *************************************************************************/\n\nfloat iPlane(vec3 ro, vec3 rd, vec4 pla) {\n\treturn (-pla.w - dot(pla.xyz, ro)) / dot(pla.xyz, rd);\n}\n\nvec3 nPlane(vec3 ro, vec4 obj) {\n\treturn obj.xyz;\n}\n\nvec3 nSphere(vec3 pos, vec3 sphPos, float sphRadius) {\n\treturn (pos - sphPos) / sphRadius;\n}\n\nfloat iSphere(vec3 ro, vec3 rd, vec3 sphPos, float sphRadius) {\n\tvec3 oc = ro - sphPos;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sphRadius * sphRadius;\n\tfloat h = b * b - c;\n\n\tif (h < 0.0) {\n\t\treturn -1.0;\n\t}\n\treturn -b - sqrt(h);\n}\n\n/*************************************************************************\n * Raymarching\n *************************************************************************/\n\nvec2 minx(vec2 a, vec2 b) {\n\t// return a.x < b.x ? a : b;\n\treturn mix(a, b, step(b.x, a.x));\n}\n\nfloat hash(float n) {\n\treturn fract(sin(n) * 43758.5453123);\n}\n\nfloat noise(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\tp += ScaleFactor * noise(p);\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nvec2 map(vec3 p) {\n\tp.y -= 6.5;\n\tp = Rotation * p;\n\n\treturn vec2(udRoundBox(p, vec3(CubeLength), 0.5), MAT_ICE_CUBE);\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n\tfloat tmin = 0.0;\n\tfloat tmax = Far;\n\n\tfloat precis = 0.0002;\n\tfloat t = tmin;\n\tfloat m = MAT_NONE;\n\n\tfor (int i = 0; i < MaxSteps; i++) {\n\t\tvec2 res = abs(map(ro + rd * t));\n\n\t\tif (res.x < precis || t > tmax) {\n\t\t\tbreak;\n\t\t}\n\t\tt += res.x * MarchDumping;\n\t\tm = res.y;\n\t}\n\n\tif (t > tmax) {\n\t\tm = MAT_NONE;\n\t}\n\treturn vec2(t, m);\n}\n\nvec3 getNormal(vec3 p) {\n\tvec2 q = vec2(0.0, 0.002);\n\n\tfloat x = map(p + q.yxx).x - map(p - q.yxx).x;\n\tfloat y = map(p + q.xyx).x - map(p - q.xyx).x;\n\tfloat z = map(p + q.xxy).x - map(p - q.xxy).x;\n\n\treturn normalize(vec3(x, y, z));\n}\n\n/*************************************************************************\n * Scene\n *************************************************************************/\n\nbool intersect(vec3 ro, vec3 rd, out vec3 hitPoint, out vec3 hitNormal,\n\t\tout float materialId) {\n\tfloat dist = MAX_DIST;\n\tmaterialId = MAT_NONE;\n\tfloat t;\n\n\tt = iPlane(ro, rd, vec4(0.0, 1.0, 0.0, 0.0));\n\tif (t > EPS && t < dist) {\n\t\tdist = t;\n\t\tmaterialId = MAT_CHECKER_PLANE;\n\t\thitNormal = vec3(0.0, 1.0, 0.0);\n\t\thitPoint = ro + dist * rd;\n\t}\n\n\tvec2 res = raymarch(ro, rd);\n\tif (MATERIAL(res) != MAT_NONE && DISTANCE(res) > EPS\n\t\t\t&& DISTANCE(res) < dist) {\n\t\tdist = DISTANCE(res);\n\t\tmaterialId = MATERIAL(res);\n\t\thitPoint = ro + DISTANCE(res) * rd;\n\t\thitNormal = getNormal(hitPoint);\n\t}\n\n\tif (dist < MAX_DIST) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*************************************************************************\n * Materials and background\n *************************************************************************/\n\nvec3 getBackground(vec3 ro, vec3 rd) {\n\trd.y -= 0.03;\n\trd = normalize(rd);\n\treturn texture(iChannel0, rd).xyz;\n}\n\n#ifdef AA_CHECKERBOARD_TEXTURE\n\n/**\n * Anti-aliased checkerboard pattern\n * http://www.yaldex.com/open-gl/ch17lev1sec5.html\n */\nvec3 getCheckerboardTexture(vec2 uv) {\n\tvec3 color;\n\tvec3 color1 = vec3(0.118, 0.525, 0.729);\n\tvec3 color2 = vec3(1.0);\n\tvec3 avgColor = (color1 + color2) * 0.5;\n\n\tconst float frequency = 0.2;\n\n\tvec2 fw = fwidth(uv);\n\tvec2 fuzz = fw * frequency * 2.0;\n\tfloat fuzzMax = max(fuzz.s, fuzz.t);\n\n\tvec2 checkPos = fract(uv * frequency);\n\n\tif (fuzzMax < 0.5) {\n\t\tvec2 p = smoothstep(vec2(0.5), fuzz + vec2(0.5), checkPos)\n\t\t\t\t+ (1.0 - smoothstep(vec2(0.0), fuzz, checkPos));\n\n\t\tcolor = mix(color1, color2, p.x * p.y + (1.0 - p.x) * (1.0 - p.y));\n\t\tcolor = mix(color, avgColor, smoothstep(0.125, 0.5, fuzzMax));\n\t} else {\n\t\tcolor = avgColor;\n\t}\n\treturn color;\n}\n\n#else\n\nvec3 getCheckerboardTexture(vec2 uv) {\n\tvec3 color1 = vec3(0.118, 0.525, 0.729);\n\tvec3 color2 = vec3(1.0);\n\n\tconst float freq = 0.5;\n\tconst float phase = 300.0;\n\tint x = int(uv.x * freq + phase);\n\tint y = int(uv.y * freq + phase);\n\n\treturn mix(color1, color2, mod(float(x + y), 2.0));\n}\n\n#endif\n\nMaterial getMaterial(float materialID) {\n\tMaterial material;\n\tmaterial.isReflective = false;\n\tmaterial.isTransmissive = false;\n\n\tif (materialID == MAT_MIRROR) {\n\t\tmaterial.isReflective = true;\n\t\tmaterial.glossiness = IceCubeGlossiness;\n\t\tmaterial.fresnel = IceCubeFresnel;\n\t} else if (materialID == MAT_ICE_CUBE) {\n\t\tmaterial.isTransmissive = true;\n\t\tmaterial.glossiness = IceCubeGlossiness;\n\t\tmaterial.fresnel = IceCubeFresnel;\n\t}\n\treturn material;\n}\n\n/*************************************************************************\n * BRDF\n *************************************************************************/\n\nvec3 getBRDF(vec3 viewDir, vec3 lightDir, vec3 hitNormal, vec3 hitPoint, float materialID) {\n\tif (materialID == MAT_MIRROR) {\n\t\t// http://www.codinglabs.net/article_physically_based_rendering.aspx\n\t\t// \"For a perfectly specular reflection, like a mirror, the BRDF function is 0 for every\n\t\t// incoming ray apart for the one that has the same angle of the outgoing ray, in which\n\t\t// case the function returns 1 (the angle is measured between the rays and the surface normal).\"\n\t\treturn vec3(1.0);\n\t}\n\tif (materialID == MAT_ICE_CUBE) {\n\t\t// Should be vec3(1.0), as refraction is also perfect specular phenomenon,\n\t\t// but setting it to some color gives nice variation.\n\t\treturn IceCubeColor;\n\t}\n\t//\tif (materialID == MAT_PHONG) {\n\t//\t\treturn phongShading(viewDir, ligthDir, hitNormal, hitPoint, materialID);\n\t//\t}\n\t// Simple lambertian BRDF: albedo / PI\n\treturn getCheckerboardTexture(hitPoint.xz) * PI_INV;\n}\n\n/*************************************************************************\n * Path tracing\n *************************************************************************/\n\nfloat hash11(float p) {\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n\tp2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvec2 hash21(float p) {\n\tvec2 p2 = fract(p * vec2(5.3983, 5.4427));\n\tp2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(vec2(p2.x * p2.y * 95.4337, p2.x * p2.y * 97.597));\n}\n\nfloat hash1() {\n\treturn hash11(seed += 1.03751);\n}\n\nvec2 hash2() {\n\treturn hash21(seed += 1.03751);\n}\n\nvec3 ortho(vec3 v) {\n\t// See : http://lolengine.net/blog/2013/09/21/picking-orthogonal-vector-combing-coconuts\n\treturn mix(vec3(-v.y, v.x, 0.0), vec3(0.0, -v.z, v.y), step(abs(v.x), abs(v.z)));\n}\n\nvec3 getSampleBiased(vec3 dir, float power) {\n\tdir = normalize(dir);\n\t// create orthogonal vector\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\n\t// Convert to spherical coords aligned to dir;\n\tvec2 r = hash2();\n\tr.x = r.x * 2. * PI;\n\n\t// This is  cosine^n weighted.\n\t// See, e.g. http://people.cs.kuleuven.be/~philip.dutre/GI/TotalCompendium.pdf\n\t// Item 36\n\tr.y = pow(r.y, 1.0 / (power + 1.0));\n\n\tfloat oneminus = sqrt(1.0 - r.y * r.y);\n\treturn normalize(cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir);\n}\n\nvec3 getConeSample(vec3 dir, float extent) {\n\t// Create orthogonal vector (fails for z,y = 0)\n\tdir = normalize(dir);\n\tvec3 o1 = normalize(ortho(dir));\n\tvec3 o2 = normalize(cross(dir, o1));\n\n\t// Convert to spherical coords aligned to dir\n\tvec2 r = hash2();\n\n\tr.x = r.x * 2. * PI;\n\tr.y = 1.0 - r.y * extent;\n\n\tfloat oneminus = sqrt(1.0 - r.y * r.y);\n\treturn normalize(cos(r.x) * oneminus * o1 + sin(r.x) * oneminus * o2 + r.y * dir);\n}\n\nvec3 getCosWeightedSample(vec3 dir) {\n\treturn getSampleBiased(dir, CosWeightedExp);\n}\n\nvec3 getHemisphereUniformSample(vec3 dir) {\n\treturn getConeSample(dir, 1.0);\n}\n\nvec3 getHemisphereDirection(vec3 n) {\n\tif (CosWeighted) {\n\t\t// Biased sampling (cosine weighted):\n\t\t// PDF = CosAngle / PI, BRDF = Albedo / PI\n\t\treturn getCosWeightedSample(n);\n\t} else {\n\t\t// Unbiased sampling:\n\t\t// PDF = 1 / (2 * PI), BRDF = Albedo / PI\n\t\treturn getHemisphereUniformSample(n);\n\t}\n}\n\nvec3 getOutgoingDirection(vec3 n, vec3 rd, float materialID, out bool specularBounce) {\n\tMaterial material = getMaterial(materialID);\n\n\tif (!material.isReflective && !material.isTransmissive) {\n\t\tspecularBounce = false;\n\t\treturn getHemisphereDirection(n);\n\t}\n\tspecularBounce = true;\n\n\tfloat NdotR = dot(rd, n);\n\tfloat n1;\n\tfloat n2;\n\n\tif (NdotR > 0.0) {\n\t\tn = -n;\n\t\tn1 = AIR_INDEX_OF_REFRACTION;\n\t\tn2 = material.fresnel;\n\t} else {\n\t\tn1 = material.fresnel;\n\t\tn2 = AIR_INDEX_OF_REFRACTION;\n\t}\n\tvec3 refr = refract(rd, n, n2 / n1);\n\n#ifdef USE_SCHLICK_APPROX\n\tfloat r0 = (n1 - n2) / (n1 + n2);\n\tr0 *= r0;\n\tfloat fresnel = r0 + (1.0 - r0) * pow(1.0 - abs(NdotR), 5.0);\n#else\n\t// full Fresnel equation:\n\t// https://en.wikipedia.org/?title=Fresnel_equations#Power_or_intensity_equations\n\tfloat cosI = dot(rd, n);\n\tfloat costT = dot(n, refr);\n\n\tfloat Rs = (n1 * cosI - n2 * costT) / (n1 * cosI + n2 * costT);\n\tRs = Rs * Rs;\n\tfloat Rp = (n1 * costT - n2 * cosI) / (n1 * costT + n2 * cosI);\n\tRp = Rp * Rp;\n\tfloat fresnel = (Rs + Rp) * 0.5;\n#endif\n\tvec3 dir;\n\n\tif (material.isReflective || hash1() < fresnel) {\n\t\tdir = reflect(rd, n);\n\t\treturn normalize(dir + material.glossiness * getHemisphereDirection(n));\n\t} else {\n\t\tdir = refr;\n\t}\n\treturn dir;\n}\n\nvec3 randomSphereDirection() {\n\tvec2 r = hash2() * TWO_PI;\n\treturn vec3(sin(r.x) * vec2(sin(r.y), cos(r.y)), cos(r.x));\n}\n\nvec3 getLightColor() {\n\treturn LightColor * 21.61 * 1.3 * LightIntensity;\n}\n\nvec3 sampleLight() {\n\tvec3 n = randomSphereDirection() * LightRadius;\n\treturn LightPosition + n;\n}\n\nfloat distanceSqr(vec3 a, vec3 b) {\n\tvec3 k = a - b;\n\treturn dot(k, k);\n}\n\nbool intersectIncludingLight(vec3 ro, vec3 rd, out vec3 hitPoint, out vec3 hitNormal,\n\t\tout float materialID) {\n\tbool result = intersect(ro, rd, hitPoint, hitNormal, materialID);\n\n\tif (!ShowLight) {\n\t\treturn result;\n\t}\n\tfloat t = iSphere(ro, rd, LightPosition, LightRadius);\n\tif (t < 0.0) {\n\t\treturn result;\n\t}\n\n\tif (result && distanceSqr(hitPoint, ro) <= t * t) {\n\t\treturn result;\n\t}\n\tvec3 pos = ro + t * rd;\n\thitPoint = pos;\n\thitNormal = nSphere(pos, LightPosition, LightRadius);\n\tmaterialID = MAT_MAIN_LIGHT;\n\n\treturn true;\n}\n\nbool isShadowed(vec3 ro, vec3 rd, vec3 point) {\n\tvec3 pos;\n\tvec3 nor;\n\tfloat m;\n\n\tif (!intersect(ro, rd, pos, nor, m)) {\n\t\treturn false;\n\t}\n\treturn distanceSqr(point, ro) > distanceSqr(pos, ro);\n}\n\nvec3 color(vec3 ro, vec3 rd) {\n\tvec3 hitPoint = vec3(0.0);\n\tvec3 hitNormal = vec3(0.0);\n\tfloat materialID = 0.0;\n\n\tvec3 totalColor = vec3(0.0);\n\tvec3 luminance = vec3(1.0);\n\n\tbool specularBounce = true;\n\tconst float eps = EPS * 8.0;\n\n\tfor (int i = 0; i < RayDepth; i++) {\n\n\t\tif (!intersectIncludingLight(ro, rd, hitPoint, hitNormal, materialID)) {\n\t\t\treturn totalColor + luminance * getBackground(ro, rd);\n\t\t}\n\n\t\tif (materialID == MAT_MAIN_LIGHT) {\n\t\t\tif (DirectLight) {\n\t\t\t\tif (i == 0 || (EnableCaustics && specularBounce)) {\n\t\t\t\t\ttotalColor += luminance * getLightColor();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttotalColor += luminance * getLightColor();\n\t\t\t}\n\t\t\treturn totalColor;\n\t\t}\n\t\tro = hitPoint;\n\t\tvec3 viewDir = -rd;\n\t\trd = getOutgoingDirection(hitNormal, rd, materialID, specularBounce);\n\n\t\tluminance *= getBRDF(viewDir, rd, hitNormal, hitPoint, materialID);\n\n\t\tif (!CosWeighted && !specularBounce) {\n\t\t\t// modulate color with: BRDF * CosAngle / PDF\n\t\t\tluminance *= 2.0 * max(0.0, dot(rd, hitNormal));\n\t\t}\n\n\t\t // Direct lighting\n\t\tif (DirectLight && !specularBounce) {\n\t\t\tvec3 lightPoint = sampleLight();\n\t\t\tvec3 ld = normalize(lightPoint - ro);\n\n\t\t\tif (!isShadowed(hitPoint + rd * eps, ld, lightPoint)) {\n\t\t\t\tvec3 lo = LightPosition - ro;\n\t\t\t\tfloat weight = LightRadius * LightRadius / dot(lo, lo);\n\n\t\t\t\ttotalColor += (luminance * getLightColor()) * weight\n\t\t\t\t\t\t* max(dot(ld, hitNormal), 0.0);\n\t\t\t}\n\t\t}\n\t\tro = hitPoint + rd * eps;\n\t}\n\treturn totalColor;\n}\n\nmat3 rotateX(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn mat3(1.0, 0.0, 0.0, 0.0, ca, sa, 0.0, -sa, ca);\n}\n\nmat3 rotateY(float a) {\n\tfloat sa = sin(a);\n\tfloat ca = cos(a);\n\treturn mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0.0, ca);\n}\n\nmat3 getCameraRotation() {\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (mouse.x != 0.0 && mouse.y != 0.0) {\n        mouse -= vec2(0.5, 0.6);\n    }\n    mouse.y = clamp(mouse.y, -1.0, 0.0);\n    mouse *= vec2(4.0, 3.0);\n    \n\treturn rotateX(mouse.y) * rotateY(mouse.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\n\tmat3 rot = getCameraRotation();\n\tvec3 dir = rot * vec3(0.0, 0.0, -1.0);\n\tvec3 up = rot * vec3(0.0, 1.0, 0.0);\n\tvec3 upOrtho = normalize(up - dot(dir, up) * dir);\n\tvec3 right = normalize(cross(dir, upOrtho));\n\n\tvec3 totalColor = vec3(0.0);\n\tfor (int a = 0; a < SamplesPerPixel; a++) {\n\t\tvec4 rr = texture(iChannel1,\n\t\t\t\t(fragCoord.xy + floor(256.0 * hash2())) / iChannelResolution[1].xy);\n\t\tvec2 p = -1.0 + 2.0 * (fragCoord.xy + rr.xz) / iResolution.xy;\n\t\tp.x *= iResolution.x / iResolution.y;\n\t\tp *= FOV;\n\n\t\tvec3 ro = rot * vec3(0.0, 6.0, 29.0);\n\t\tvec3 rd = normalize(dir + p.x * right + p.y * upOrtho);\n\n\t\ttotalColor += color(ro, rd);\n\t}\n\ttotalColor /= float(SamplesPerPixel);\n\n\t// Gamma correction\n\ttotalColor = pow(clamp(totalColor, 0.0, 1.0), vec3(0.4545));\n    \n\tfragColor = vec4(totalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}