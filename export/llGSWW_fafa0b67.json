{"ver":"0.1","info":{"id":"llGSWW","date":"1484311565","viewed":151,"name":"Sea waves with function","username":"Teurkidosh","description":"Essayer de \"jouer\" sur les paramètres constants et sur la position de la souris en y","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["waves","sea","sinusoide"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float hauteurEcranM = 0.22;\nconst vec4 couleurPremierPlan = vec4(0.2,0.0,0.6,0.1);\nconst vec4 couleurArrierePlan = vec4(0.53,0.81,0.92,0.1);\n\n\nvoid convertirMtoP(out float val){\n    \n    val = iResolution.y * val / hauteurEcranM;\n}\n\nvoid traceWave(out vec4 color, in vec2 pixCoords, in float distanceM)\n{   \n    \n    float distanceOeilEcranM = 0.3;\n    \n    /*\n\t\tLe décalage en Y devrait etre calculé grace au théorème de Thalès, \n\t\tc'est en fait la hauteur du milieu des vagues dans l'ecran\n\t\tle calcul doit tenir compte de \n\n\t\tla distance entre \"l'oeil\" (ou la \"caméra\") et \"l'ecran\" (tout ça est virtuel...)\n\t\tla distance entre l'oeil et la vague\n\t\tl'altitude de l'oeil par rapport à la vague\n\t\tl'altitude de l'ecran par rapport à la vague\n\t\t\tles deux valeurs précédentes sont redondantes etant donné la valeur suivante :\n\t\tl'altitude de l'oeil par rapport au centre de l'ecran \n\t\t\t(c'est une constante, qui peut dans un premier temps être conidérée comme nulle)\n\t\tLa taille réelle de l'ecran doit être aussi prise en compte\n\n\t\tOn peut considérer que ces distances sont exprimées en metres.\n\t*/\n    \n    \n    \n    const float amplitudeBaseVagueM = 0.3;\n    float amplitudeVagueM = amplitudeBaseVagueM / distanceM;\n    convertirMtoP(amplitudeVagueM);\n    float amplitudeVagueP = amplitudeVagueM;\n    \n    \n    \n    const float periodeBaseVagueM = 2.0;\n    float periodeVagueM = periodeBaseVagueM / distanceM;\n    convertirMtoP(periodeVagueM);\n    float periodeVagueP = periodeVagueM;\n    \n    const float vitesseDefilementBaseVagueMs = 0.01;\n    float vitesseDefilementVagueMs = vitesseDefilementBaseVagueMs / distanceM;\n    convertirMtoP(vitesseDefilementVagueMs);\n    float vitesseDefilementVaguePs = vitesseDefilementVagueMs;\n    \n    const float altitudeOeilMaxM = 100.0;\n    float altitudeOeilM = cos(periodeVagueP + iTime*vitesseDefilementVaguePs)*amplitudeVagueP;\n    //On redefini parce que sinon c'est pas super joli\n    altitudeOeilM = iMouse.y/iResolution.y * altitudeOeilMaxM;\n    \n    //y'a un truc qui foire ici ou à la ligne d'après..., bon, bah en fait non...\n    float hauteurMilieuVagueObservableM = (distanceM - distanceOeilEcranM)/distanceM * altitudeOeilM;\n    float decalageYM = hauteurMilieuVagueObservableM - (altitudeOeilM - (hauteurEcranM / 2.0));\n    convertirMtoP(decalageYM);\n    float decalageYP = decalageYM;\n    \n    //TestPreliminaire pour savoir si on va voir au moins un pixel de la vague\n    if((amplitudeVagueP + decalageYP)< 0.0) return;\n    \n    /*\n\til faut trouver un moyen d'avoir un filtre qui assombrit la couleur du ciel tel que\n\n\tplus la vague est \"loin\", plus sa couleur est proche de celle du ciel\n\tplus la vague est proche, plus elle est assombrie, mais jusqu'à un certain point.\n\n\tEn fait, il faut juste prendre la différence entre la couleur sombre et la couleur claire\n\tpuis ajouter cette différence à la couleur claire en appliquant un coefficient...\n\t*/\n    \n  \n    vec4 filtre = couleurPremierPlan - couleurArrierePlan;\n    \n    \n    //Ligne\n    /*\n\tif(pixCoords.y < decalageYP){\n     \t  color = vec4(0.0,0.5,1.0,1.0) * filtre;\n    }\n\t*/\n    //Vague\n    if(pixCoords.y < cos(pixCoords.x/periodeVagueP + iTime*vitesseDefilementVaguePs)*amplitudeVagueP + decalageYP){\n        color = couleurArrierePlan + filtre / pow(distanceM, (1.0/9.0));\n    }\n}\n                                                       \n\n\nvoid mainImage( out vec4 color, in vec2 pixCoords )\n{\n\t//dessine le ciel\n    color = couleurArrierePlan;\n    \n    for(float i = 480.0; i>0.0; i -= 10.0)\n    {\n        traceWave(color, pixCoords, i);\n    }\n}","name":"Image","description":"","type":"image"}]}