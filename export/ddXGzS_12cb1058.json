{"ver":"0.1","info":{"id":"ddXGzS","date":"1666383312","viewed":92,"name":"Truchet study 1","username":"Alpaga","description":"Drag the mouse horizontally to stay on one of the 6 patterns.\n\nPress G to see the boundaries of the cells: they form a simple periodic pattern.","likes":9,"published":1,"flags":16,"usePreview":0,"tags":["truchet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Thanks to BigWings - The Art of Code for explaining Truchet tilings:\n// https://www.shadertoy.com/view/3lBXWK\n// https://www.youtube.com/watch?v=2R7h76GoIJM&ab_channel=TheArtofCode\n\n// This study is an attempt to understand how to make consistent tilings\n// when the tiles are assymmetric.\n\n// In each pattern, there are 4 possibles tiles, split into 2 sets of 2 tiles:\n// 2 \"even\" tiles and 2 \"odd\" tiles. Any even tile matches with any\n// odd tile, when put side to side. We split the cells into the \"even\" cells and\n// the \"odd\" cells, like the white and black cells on a checkerboard, and for\n// each cell we choose at random one of the 2 tiles of the same parity as the cell.\n//\n// Tiles with the same parity have the same boundary. Therefore in each pattern,\n// what happens at the boundary of the cells never changes, i.e. does not depend\n// on the random choices.\n\n// There are 6 patterns.\n\n// Durations\nconst float pause = 2., transition = 1.;\nconst float scale = 4.;\nconst float cameraSpeed = .2;\n\nconst int patterns = 6;\n\nconst vec3 yellow = vec3(1,1,0);\nconst vec3 orange = vec3(1,.5,0);\nconst vec3 blue = vec3(0,0,1);\nconst vec3 cyan = vec3(0,.5,1);\nconst vec3 black = vec3(0);\n\nconst float pi = 3.14159;\n\n// Hash function from Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat rdBit(vec2 p) {\n    return step(.5,hash12(p));\n}\n// Reflection around vertical axis.\n// (note that all the tiles are symmetric around their centers,\n//  so a reflection around the horizontal axis would be equivalent)\nvoid flip(inout float x, float bit) {\n    x = mix(x,1.-x,bit);\n}\n// Clockwise rotation by 90 deg around center.\n// (again, because of the central symmetry, anticlockwise\n//  rotation by 90 deg would be equivalent)\nvoid rotate(inout vec2 p, float bit) {\n    p = mix(p, vec2(p.y,1.-p.x), bit);\n}\n\n// Change col to targetColor if l>=threshold.\n// The change is smooth for antialiasing.\nvoid setColor(inout vec3 color, float l, float threshold, vec3 targetColor) {\n    float e = 2.*scale/iResolution.y;\n    color = mix(color,targetColor,smoothstep(threshold-e,threshold+e,l));\n}\n\n// All the tiles are symetric around the center.\n\n// Plain arc\nvec3 basicTile(vec2 p, float bit) {\n    flip(p.x,bit);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n\n    float l = length(p);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n    a = max(abs(mod(.6*a,.2)-.1)-.04,0.);\n    \n    vec3 col = black;\n    setColor(col,l,.35,orange);\n    setColor(col,l,.5-a,black);\n    setColor(col,l,.5+a,orange);\n    setColor(col,l,.65,black);\n    \n    return col;\n}\n\n// Arc with colored sides\nvec3 sidesTile(vec2 p, float parity, float bit) {\n    flip(p.x,bit);\n    float xor = mod(parity+bit,2.);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float l = length(p);\n    \n    vec3 inside = mix(yellow,cyan,xor);\n    vec3 outside = mix(cyan,yellow,xor);\n    \n    vec3 col = black;\n    setColor(col,l,.35,inside);\n    setColor(col,l,.4,orange);\n    setColor(col,l,.6,outside);\n    setColor(col,l,.65,black);\n    \n    return col;\n}\n\n// Arc with filled sides\nvec3 filledSidesTile(vec2 p, float parity, float bit) {\n    flip(p.x,bit);\n    float xor = mod(parity+bit,2.);\n\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float l = length(p);\n\n    vec3 inside = mix(yellow,blue,xor);\n    vec3 outside = mix(blue,yellow,xor);\n    \n    vec3 col = inside;\n    setColor(col,l,.35,orange);\n    setColor(col,l,.65,outside);\n    \n    return col;\n}\n\n// Arc with oriented arrows\nvec3 arrowsTile(vec2 p, float parity, float bit) {\n    flip(p.x,bit);\n    p = mix(p,p.yx,parity);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float l = abs(length(p)-.5);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n        \n    // Arrows pattern\n    a = smoothstep(0.03,0.07,abs(mod(a+2.*l-.2*iTime,.2)-.1));\n    vec3 arrows = a * orange;\n    \n    vec3 col = arrows;\n    setColor(col,l,.15,black);\n\n    return col;\n}\n\n// Arc with peaks moving in a direction\nvec3 peaksTile(vec2 p, float parity, float bit) {\n    flip(p.x,bit);\n    p = mix(p,p.yx,parity);\n// Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float l = length(p);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n    \n    // 3 peaks inside\n    float b = abs(mod(.6*a-.2*iTime,.2)-.1);\n    // 5 peaks outside\n    float c = abs(mod(   a-.2*iTime,.2)-.1);\n    \n    vec3 col = black;\n    setColor(col,l,.4-b,orange);\n    setColor(col,l,.6+c,black);\n\n    return col;\n}\n\n// Arc with oriented arrows + colored sides\n// (combination of arrowsTile and sidesTile)\nvec3 arrowsSidesTile(vec2 p, float parity, float bit) {\n    vec3 arrows = arrowsTile(p,parity,bit);\n    float xor = mod(parity+bit,2.);\n\n    flip(p.x,bit);\n    p = mix(p,p.yx,parity);\n    vec3 inside = mix(yellow,cyan,xor);\n    vec3 outside = mix(cyan,yellow,xor);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float l = length(p);\n    \n    vec3 col = inside;\n    setColor(col,l,.35,arrows);\n    setColor(col,l,.65,outside);\n    \n    return col;\n}\n\n// Arc with moving peaks. The peaks inside and\n// outside move in opposite directions.\nvec3 oppositePeaksTile(vec2 p, float parity, float bit) {\n    rotate(p,bit);\n    // Central symmetry\n    if(p.x+p.y>1.)\n        p = 1.-p;\n    \n    float xor = mod(parity+bit,2.);\n    vec3 inside = mix(yellow,cyan,xor);\n    vec3 outside = mix(cyan,yellow,xor);\n    \n    float l = length(p);\n    float a = atan(p.y,p.x)*2./pi;// From 0 to 1\n\n    // 3 peaks inside\n    float b = abs(mod(.6*a+.2*iTime,.2)-.1);\n    // 5 peaks outside\n    float c = abs(mod(   a-.2*iTime,.2)-.1);\n    \n    vec3 col = black;\n    setColor(col,l,.4-b,inside);\n    setColor(col,l,.49,black);\n    setColor(col,l,.51,outside);\n    setColor(col,l,.6+c,black);\n\n    return col;\n}\n\nvec3 tile(vec2 p, int n, float parity, float bit) {\n    n = n%patterns;\n    switch(n) {\n        case 0:\n            return sidesTile(p,parity,bit);\n        case 1:\n            return filledSidesTile(p,parity,bit);\n        case 2:\n            return arrowsTile(p,parity,bit);\n        case 3:\n            return peaksTile(p,parity,bit);\n        case 4:\n            return arrowsSidesTile(p,parity,bit);\n        case 5:\n            return oppositePeaksTile(p,parity,bit);\n    }\n}\nvec3 color(vec2 p, int n) {\n    vec2 g = floor(p);\n    vec2 f = fract(p);\n    \n    // A. Cell parity\n    float parity = mod(g.x+g.y,2.);\n    // B. Random bit\n    float bit = rdBit(g);\n        \n    return tile(f, n, parity, bit);\n}\n\n// From https://www.shadertoy.com/view/4sBfRd\n#define C(c) O+= char(U,64+c); U.x-=.5\n#define SPACE U.x-=.5\nfloat char(vec2 p, int c) \n{\n    if (p.x<=.2|| p.x>=.8 || p.y<=.2|| p.y>=1.) return 0.;\n\treturn texture( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. )).r;//, dFdx(p/16.),dFdy(p/16.) ).r;\n}\n\nconst int EVEN = 0, ODD = 1, TILE0 = 2, TILE1 = 3;\n\nvec3 text(vec2 uv, vec2 pos, int t) {\n    float O = 0.;\n    uv /= iResolution.y;\n    vec2 position = pos/iResolution.y;\n    float FontSize = 5.;\n    vec2 U = uv *64.0/FontSize - pos;\n    switch(t) {\n        case EVEN:\n            C(5);C(54);C(37);C(46);\n            break;\n        case ODD:\n            C(15);C(36);C(36);\n            break;\n        case TILE0:\n            C(52);C(41);C(44);C(37);SPACE;C(-16);\n            break;\n        case TILE1:\n            C(52);C(41);C(44);C(37);SPACE;C(-15);\n            break;\n    }\n    return vec3(O);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col;\n    float size = iResolution.y/4.;\n    float margin = iResolution.y/20.;\n    \n    float leftpanel = 2.*size+3.*margin;\n\n    float t = mod(iTime, pause+transition);\n    // Pattern number\n    int n = int(floor(iTime/(pause+transition)));\n    vec2 p;\n    float parity, bit;\n    \n    if(fragCoord.x < leftpanel) {\n        p = fragCoord;\n        p.y -= 0.5*(iResolution.y-leftpanel);\n        vec2 g = floor(p/(size+margin));\n        p = mod(p,size+margin);\n        \n        if(g.y >=0. && g.y<2. && p.x>=margin && p.y>=margin) {\n            // Tile set\n            p = (p-margin)/size;\n        \n            parity = mod(g.x+g.y,2.);\n            bit = g.x;\n        \n            col = tile(p, n, parity, bit);\n        } else {\n            // Text\n            col = vec3(.5,0,0);\n            col += text(fragCoord, vec2(.9,1.5), EVEN);\n            col += text(fragCoord, vec2(.5,.5), TILE0);\n            col += text(fragCoord, vec2(5,1.5), ODD);\n            col += text(fragCoord, vec2(4.5,.5), TILE1);\n            col += text(fragCoord, vec2(.9,11.3), ODD);\n            col += text(fragCoord, vec2(.5,10.3), TILE0);\n            col += text(fragCoord, vec2(5,11.3), EVEN);\n            col += text(fragCoord, vec2(4.5,10.3), TILE1);\n            \n            fragColor = vec4(col,1.);\n            return;\n        }\n    } else {\n        vec2 center = 0.5+iResolution.xy;\n        center.x += leftpanel;\n    \n        p = (fragCoord-center)/iResolution.y;\n\n        p *= scale;\n        p += cameraSpeed * iTime;\n\n        vec2 g = floor(p);\n        p = fract(p);\n\n        // A. Cell parity\n        parity = mod(g.x+g.y,2.);\n        // B. Random bit\n        bit = rdBit(g);\n    }\n    \n    if(iMouse.z > 0.) {\n        n = int(floor(float(patterns)*iMouse.x/iResolution.x));\n        col = tile(p,n,parity,bit);\n    } else {\n        if(t<pause) { // Pause on a pattern\n            col = tile(p,n,parity,bit);\n        } else { // Transition between patterns\n            float x = (t-pause)/transition;\n            col = mix(tile(p,n,parity,bit),tile(p,n+1,parity,bit),x);\n        }\n    }\n    const int KEY_G = 71;\n\n    if(texelFetch(iChannel0, ivec2(KEY_G,0), 0).x > 0.) {\n        vec2 q = abs(mod(p+.5,1.)-.5);\n        setColor(col,min(q.x,q.y),5.*scale/iResolution.y,vec3(0,0,0));\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}