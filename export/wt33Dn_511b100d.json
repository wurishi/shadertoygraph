{"ver":"0.1","info":{"id":"wt33Dn","date":"1576007238","viewed":88,"name":"SimpValNoise","username":"foran","description":"SimpValNoise","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["simpvalnoise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat2 rot(float a){float c=cos(a),s=sin(a);return mat2(c,-s,s,c);}\n//----------\nfloat Value2D(vec2 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/Value2D.glsl\n    \n    //\testablish our grid cell and unit position\n    vec2 Pi=floor(P);\n    vec2 Pf=P-Pi;\n    \n    //\tcalculate the hash.\n    vec4 Pt=vec4(Pi.xy,Pi.xy+1.);\n    Pt=Pt-floor(Pt*(1./71.))*71.;\n    Pt+=vec2(26.,161.).xyxy;\n    Pt*=Pt;\n    Pt=Pt.xzxz*Pt.yyww;\n    vec4 hash=fract(Pt*(1./951.135664));\n    \n    //\tblend the results and return\n    vec2 blend=Pf*Pf*Pf*(Pf*(Pf*6.-15.)+10.);\n    vec4 blend2=vec4(blend,vec2(1.-blend));\n    return dot(hash,blend2.zxzx*blend2.wwyy);\n}\nfloat SimplexPerlin2D(vec2 P)\n{\n    //  https://github.com/BrianSharpe/Wombat/blob/master/SimplexPerlin2D.glsl\n    \n    //  simplex math constants\n    const float SKEWFACTOR=.36602540378443864676372317075294;// 0.5*(sqrt(3.0)-1.0)\n    const float UNSKEWFACTOR=.21132486540518711774542560974902;// (3.0-sqrt(3.0))/6.0\n    const float SIMPLEX_TRI_HEIGHT=.70710678118654752440084436210485;// sqrt( 0.5 )\theight of simplex triangle\n    const vec3 SIMPLEX_POINTS=vec3(1.-UNSKEWFACTOR,-UNSKEWFACTOR,1.-2.*UNSKEWFACTOR);//  simplex triangle geo\n    \n    //  establish our grid cell.\n    P*=SIMPLEX_TRI_HEIGHT;// scale space so we can have an approx feature size of 1.0\n    vec2 Pi=floor(P+dot(P,vec2(SKEWFACTOR)));\n    \n    // calculate the hash\n    vec4 Pt=vec4(Pi.xy,Pi.xy+1.);\n    Pt=Pt-floor(Pt*(1./71.))*71.;\n    Pt+=vec2(26.,161.).xyxy;\n    Pt*=Pt;\n    Pt=Pt.xzxz*Pt.yyww;\n    vec4 hash_x=fract(Pt*(1./951.135664));\n    vec4 hash_y=fract(Pt*(1./642.949883));\n    \n    //  establish vectors to the 3 corners of our simplex triangle\n    vec2 v0=Pi-dot(Pi,vec2(UNSKEWFACTOR))-P;\n    vec4 v1pos_v1hash=(v0.x<v0.y)?vec4(SIMPLEX_POINTS.xy,hash_x.y,hash_y.y):vec4(SIMPLEX_POINTS.yx,hash_x.z,hash_y.z);\n    vec4 v12=vec4(v1pos_v1hash.xy,SIMPLEX_POINTS.zz)+v0.xyxy;\n    \n    //  calculate the dotproduct of our 3 corner vectors with 3 random normalized vectors\n    vec3 grad_x=vec3(hash_x.x,v1pos_v1hash.z,hash_x.w)-.49999;\n    vec3 grad_y=vec3(hash_y.x,v1pos_v1hash.w,hash_y.w)-.49999;\n    vec3 grad_results=inversesqrt(grad_x*grad_x+grad_y*grad_y)*(grad_x*vec3(v0.x,v12.xz)+grad_y*vec3(v0.y,v12.yw));\n    \n    //\tNormalization factor to scale the final result to a strict 1.0->-1.0 range\n    //\thttp://briansharpe.wordpress.com/2012/01/13/simplex-noise/#comment-36\n    const float FINAL_NORMALIZATION=99.204334582718712976990005025589;\n    \n    //\tevaluate and return\n    vec3 m=vec3(v0.x,v12.xz)*vec3(v0.x,v12.xz)+vec3(v0.y,v12.yw)*vec3(v0.y,v12.yw);\n    m=max(.5-m,0.);\n    m=m*m;\n    return dot(m*m,grad_results)*FINAL_NORMALIZATION;\n}\n\n//----------\nmat2 rotate (float t) {\n    return mat2(cos(t), sin(t), -sin(t), cos(t));\n}\n\nfloat fBm(vec2 st, float noisetype) {\n\n    float frequency = 1.0;\n    float amplitude = 0.5;\n    float value = 0.0;\n\n    for (float i = 0.; i <6.+7.*sin(iTime*.5)*sin(iTime*.95)+1.; i++) {\n        if (noisetype == 0.0)\n            value += amplitude * Value2D(frequency * st);\n        else\n            value += amplitude * SimplexPerlin2D(frequency * st);\n        frequency *= 2.0;\n        amplitude *= 0.5;\n        st = rotate(0.4) * st;\n\n    }\n\n    return value;\n}\n\nfloat warp (vec2 st, float noise) {\n    // f(p) = f(p + h(p))\n    // h(p): vec2->vec2\n    float r = 0.0;\n    r = fBm(st, noise);\n    vec2 st1 = vec2(0.0);\n\n    st1.x = fBm(st, noise);\n    st1.y = fBm(st + vec2(1.0), noise);\n\n    st1.x = fBm(st + st1 + 0.15 * iTime, noise);\n    st1.y = fBm(st + st1 + 0.125 * iTime + vec2(100.0, 12323.0), noise);\n    return fBm(st + st1, noise);\n\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 st=gl_FragCoord.xy/iResolution.xy;\n    float yf = fract(st.y * 3.0);\n    float xf = st.x;\n\n    float scale = 5.0;\n    st *= scale;\n    float r = 0.0;\n\n    if (st.x < 0.5 * scale) {\n\n        \n            r = warp(st, 0.0);\n            vec3 co=vec3(r);\n            fragColor=vec4(co,1.);\n      \n\n    } else {\n        \n            r = warp(st, 1.0);\n            float t=iTime*.13;\nvec3 eye=vec3(st,-2.5);\nvec3 pos=eye;\nvec3 norm=normalize(pos);//  \nnorm.xy*=rot(t+pos.z);//  сине-красный\nnorm.xz*=rot(t+pos.y);//  зелёно-фиолетовый\nnorm.yz*=rot(t+pos.x);//  желто-синий\nvec4 col=vec4(norm,0.);\nfragColor=col;\n        \n    }\n    \n    r*=smoothstep(0.,.005,abs(xf-.5));\n    \n    vec3 color = vec3(r);\n    fragColor*= vec4(color , 1.0);\n\n}\n","name":"Image","description":"","type":"image"}]}