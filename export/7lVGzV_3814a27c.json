{"ver":"0.1","info":{"id":"7lVGzV","date":"1638032592","viewed":418,"name":"Crystal Cube Collection","username":"Hyeve","description":"something something something cubes! honestly not sure how I ended up here but I like it!","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","transparency","refraction","cubes","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define fft(f) (1-pow(max(1-texture(texFFTSmoothed,pow(64,f)/425).x*0.1,0),sqrt(f)*20))\n\nvec3 glw; //glow\nfloat tt; //time\n\nfloat bx(vec3 p, vec3 s) //box\n{\n  vec3 q=abs(p)-s;\n  return min(max(q.x,max(q.y,q.z)),0.) + length(max(q,0.));\n}\n\nvec2 mp(vec3 p) //scene\n{\n\n\tfloat anim = sin(tt); //swap motion\n \n\tp.y += tt; //whole scene sinking\n    \n\tfloat yid = floor(p.y / 6.); //vertical layer ID\n    \n\tp.x += tt * (mod(yid,2.) == 0. ? 1. : -1.); //move layers horizontally\n    \n\tfloat xid = floor(p.x / 16.) * 5.; //horizontal column ID, per 2 cubes\n\tfloat xidr = floor(p.x / 8.) * 5.; //horizontal column ID, per cube\n    //the reason they are separate is so that I don't have to deal with the nightmare of\n    //cubes crossing the colour boundaries when swapping and instead each pair is just the same color\n\n\tfloat xidoff = floor(tt/3.14+6.49) * 10.; //horizontal column ID offset for.. something\n    \n\tfloat flip = mod(xid,2.) == 0. ? -1. : 1.; //flip rotation directions for every other column\n    \n\tfloat id = xid + yid; //ID for colouring and things\n\tfloat cbdxid = floor(p.x / 16.) - 8.; //bounding box horizontal ID to prevent domain overstepping stuff\n\t\n\tp.x = mod(p.x, 16.) - 8.; //domain repeat horizontally into double-cube-size columns\n\tp.y = mod(p.y, 6.) - 3.; //domain repeat vertically into layers\n\t\n\tfloat cbd = bx(p,vec3(7,2.5,10)); //bounding box for each 2-cube pair\n    \n    //something something something figure out which parts to rotate for each pair\n\tfloat cell = mod(yid + cbdxid + xidoff,7.) == 0. && (mod(xidr + xidoff,10.) == 0. || mod(xidr + xidoff - 5.,10.) == 0.)  ? 1. : 0.;\n\tp.xz *= rot((anim * 1.57 + 1.56) * cell); //swap cube pairs\n\t\n\tp.x += 4.; //shift scene FIRST because for some reason this bounded domain repetition function\n               //does really weird stuff if you shift the horizontal axis after it... i have no idea why tf it does though\n\tp.x = (p.x-8.*clamp(round(p.x/8.),-0.,1.)); //bounded domain repetition to duplicate each sigle cube into a cube pair\n\n\n    float bd = bx(p,vec3(3.5,2.6,3.5)); //bounding box per-cube because they're rotating\n\n\tfloat spin = mod(id, 7.) == 0. ? -0.7 : 0.7; //spin direction adjustment for cubes\n\tp.xz *= rot(tt * spin * flip + id); //spin all cubes\n\t\n\tfloat rd = bx(p,vec3(2)) - 0.2; //the SINGLE original cube\n\t\n\trd = min(rd, abs(cbd)+0.1); //bound distance per-pair\n\trd = min(rd, abs(bd)+0.1); //bound distance per-cube\n    \n    vec3 gc = normalize(p*p);\n    gc.yz *= rot(6.);\n    if(rd < 0.1) glw += 0.01/(0.01+rd*rd) * gc * 0.4; //iridescent look\n    \n    //it's fun to remove the abs() on one or the other and look at the actual bounding box cubes instead!\n\t\n    return vec2(rd,id); //return the final distance and ID\n}\n\nvec3 tr(vec3 ro, vec3 rd, float z) //raymarcher\n{\n  vec3 d=vec3(0); //slightly different to normal raymarcher, this one also tracks step count\n  \n  for(float i=0.;i<512.;i++)\n  {\n    vec2 s=mp(ro+rd*d.x); //we can just inline this\n    s.x*=z;d.x+=s.x;d.y=s.y;d.z=i; //and we also take a z parameter which is used to invert the distance field for transparency\n    if(s.x<0.0001||d.x>128.)break;\n  }\n  \n  return d; //and return it all without resetting the material if it's past the max distance - we check that later instead\n}\n\nvec3 nm(vec3 p) //normal calculation, pretty standard, just inlined\n{\n  vec2 e=vec2(0.0001,0); return normalize(mp(p).x - vec3(mp(p-e.xyy).x,mp(p-e.yxy).x,mp(p-e.yyx).x));\n}\n\nvec4 px(vec4 h, vec3 p, vec3 n, vec3 r) //pixel \"shader\" (..it shades pixels okay)\n{\n  vec4 bg = vec4(0.0,0.2,0.5,0) + length(r*r)*0.3 + texture(iChannel0, r); //background colour\n  if(h.x>128.) return bg+glw.rgbb/h.z; //if max distance - haven't hit anything - return background\n \n  //object colour (including transmission), based on ID\n  vec4 fc = mix(vec4(0.1,mod(h.y,5.)/5. + 0.3,0.8,0.75),vec4(mod(h.y,6.)/6.+ 0.5,0.2,0.9,0.65), mod(h.y*20.5,11.)/11.); \n  \n  vec3 l = vec3(0.8,0.9,0.7); //\"light\".. my lighting is basically simulated tri-planer light mapping.. or something\n \n  float diff = length(n*l); //diffuse - it's based on per-axis brightness\n  float fres = pow(1.-diff,2.)*0.3; //fresnel - just inverse diffuse with a bit of POW!\n  //specular - turns out the cross product of the ray direction and normal make a really nice front-facing specular highlight!\n  float spec = (1.-length(cross(r,n)))*0.2; \n  //decent sub-surface-scattering with just 2 checks, by using the ray direction for the offset\n  float sss = clamp(mp(p - r*l*0.4).x + mp(p + r*l*0.4).x,0.,1.)*0.8;\n  //decent ambient occlusion that works exactly the same but only does 1 check based on the normal instead\n  float ao = min(mp(p + n*0.3).x-0.3,0.3)*0.2;\n\n  fc.rgb*=diff+fres+sss;  //multiply all the diffuse and fres and sss into the base colour\n  fc.rgb+=fres+spec+ao; //add fres and spec and ao (which is negative) for highlight\n\t\n  return fc; //tada, we got a color!\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n  //assign time variable. Past 120 starts having very noticable precision issues, soooo we don't let that happen\n  tt = mod(iTime, 120.); \n\t\n  //uv calculation, just bonzomatic's default centred UV\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  vec3 ro = vec3(0,0,-25. + sin(tt/5.)*10.), rd=normalize(vec3(uv+vec2(sin(tt/2.)/5.,cos(tt/2.3)/3.),1));//camera position and ray direction, inlined\n  vec3 cp,cn,cr; //current position/normal/ray for transparency loop\n  vec4 cc,fc=vec4(1),h=fc; //current colour, final colour + current transmission, hit data + distance inversion variable\n  float io=1.1; //index of refraction for objects\n\t\n  //transparency loop with depth 4 - it's compacted to be 4*2 loops, with each layer taking 2 iterations\n  //instead of one longer loop that iterates just 4 times\n  for(int i=0;i<4*2;i++) \n  {\n     h.xyz=tr(ro,rd,h.a);cp=ro+rd*h.x; //get hit data, calculate current position\n     cn=nm(cp);cr=rd;ro=cp-cn*(0.01*h.a); //calculate current normal, set current ray, set new cam pos\n     rd=refract(cr,cn*h.a,h.a>0.?1./io:io); //refract ray\n     if(dot(rd,rd)==0.)rd=reflect(cr,cn*h.a); //handle total internal refraction if needed\n     cc=px(h,cp,cn,cr);h.a*=-1.; //calculate colour for current hit, invert distance field\n     //if we're in an outside iteration - and not an iteration throught the inside of an object - mix colour into final colour\n     if(h.a<0.)fc.rgb=mix(fc.rgb,cc.rgb,fc.a); \n     fc.a*=cc.a;if(fc.a<=0.||h.x>128.)break; //update transmission, break if transmission <0 or we haven't hit anything\n  }\n \n  fragColor = vec4(fc); //set final colour\n}","name":"Image","description":"","type":"image"}]}