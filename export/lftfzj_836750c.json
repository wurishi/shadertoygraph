{"ver":"0.1","info":{"id":"lftfzj","date":"1733304045","viewed":106,"name":"Cellular 3x3x3","username":"stegu","description":"Demonstration of an updated \"cellular\" function of mine, this one in 3D with the classic 3x3x3 search window. The displacements vectors for the feature points (one in each grid cell) are created with maximum amplitude and a pseudo-random direction.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["voronoi","worley","cellular"],"hasliked":0,"parentid":"4ctBz8","parentname":"Cellular \"noise\" demo (2D)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float aastep(float a, float x) {\n    float fw = 0.7*fwidth(x-a);\n    return smoothstep(-fw, fw, x-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    vec2 F;\n    vec3 P1;\n    float ID1;\n    vec3 col;\n    \n    vec3 uvw;\n    uvw.xy = uv * 1.05;\n    uvw.z = sqrt(max(0.0, 1.0-dot(uvw.xy,uvw.xy)));\n    float spheremask = aastep(1.0, length(uvw.xy));\n    float St = sin(iTime*0.5);\n    float Ct = cos(iTime*0.5);\n    float Sv = sin(0.5);\n    float Cv = cos(0.5);\n    mat2 R = mat2(Ct, -St, St, Ct);\n    mat2 V = mat2(Cv, -Sv, Sv, Cv);\n    uvw.yz = V*uvw.yz;\n    uvw.xz = R*uvw.xz;\n\n    F = cellular(uvw*5.0, 0.5, P1, ID1);\n\n    // The classic \"Voronoi\" pattern, with color\n    col = vec3(min(2.0*sqrt(F.y-F.x), 1.0));\n    col *= vec3((mod(ID1,41.0)+24.0)/64.0, 1.0 - ID1/512.0, 0.0);\n\n    // Blot out the background\n    col = mix(col, vec3(0.0), spheremask);\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Cellular noise (\"Worley noise\") in 3D.\n// Version 2024-12-04, by Stefan Gustavson.\n// Published under the CC-BY-SA 4.0 license:\n// https://creativecommons.org/licenses/by-sa/4.0/\n\n// Cellular noise, returning F1 and F2 in a vec2,\n// the offset from P to the nearest point P1\n// in an \"out\" parameter vec3 P1, and the hashed\n// Voronoi cell ID in an \"out\" parameter float ID1.\n// 3x3x3 search window for good F1 and F2 values.\n//\n// Explicit loops, compact code that's easy to read.\n// Not *quite* as fast as a vectorized version, but\n// on modern platforms the difference is marginal.\n//\nfloat permute289(float x) {\n  return mod((34.0 * x + 10.0) * x, 289.0);\n}\nvec2 cellular(vec3 P, float jitter, out vec3 P1, out float ID1) {\n    jitter = clamp(jitter,0.0,1.0);\n    vec3 P0 = floor(P);\n\tvec3 Pi = mod(P0, 289.0);\n\tvec3 Pf = P0-P; // Vector from P to closest unjittered grid point P0\n\tfloat px, pxy, pxyz;\n\tfloat d, d1, d2;\n\tfloat ox, oy, oz, dx, dy, dz;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n\tfor(float ix = -1.0; ix <=1.0; ix++) {\n\t\tpx = permute289(Pi.x + ix);\n\t\tfor(float iy = -1.0; iy <= 1.0; iy++) {\n\t\t\tpxy = permute289(px + Pi.y + iy);\n            for(float iz = -1.0; iz <= 1.0; iz++) {\n                pxyz = permute289(pxy + Pi.z + iz);\n                // Pick a displacement vector from a Fibonacci sphere\n                float theta = pxyz * 3.883222077; // (sqrt(5)-1)*Pi\n                float gz = pxyz * -0.006920415 + 0.996539792; // N=289\n                float gz_prime = sqrt( 1.0 - gz*gz );\n                ox = cos(theta) * gz_prime;\n                oy = sin(theta) * gz_prime;\n                oz = gz;\n                // Push the vector out to the surface of a cube\n                float sqc = 1.0 / max( max( abs(ox), abs(oy) ), abs(oz) );\n                ox *= sqc;\n                oy *= sqc;\n                oz *= sqc;\n                // Jitter the point with the desired amount\n                dx = Pf.x + ix + jitter*ox + 0.5;\n                dy = Pf.y + iy + jitter*oy + 0.5;\n                dz = Pf.z + iz + jitter*oz + 0.5;\n                d = dx*dx + dy*dy + dz*dz; // Distance from P to Pn, squared\n                // d could replace either d1 or d2, handle both cases\n                d2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n                P1 = (d <= d1 ? vec3(dx,dy,dz) : P1);\n                ID1 = (d <= d1 ? pxy : ID1);\n                d1 = (d <= d1 ? d : d1);\n            }\n        }\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n\n// 2D version for reference (not used)\nvec2 cellular(vec2 P, float jitter, out vec2 P1, out float ID1) {\n    jitter = clamp(jitter,0.0,1.0);\n    vec2 P0 = floor(P);\n\tvec2 Pi = mod(P0, 289.0);\n\tvec2 Pf = P0-P; // Vector from P to closest unjittered grid point P0\n\tfloat px, pxy;\n\tfloat d, d1, d2;\n\tfloat ox, oy, dx, dy;\n\td1 = d2 = 8.0; // Init to distances larger than any actual outcome\n\tfor(float ix = -1.0; ix <=1.0; ix++) {\n\t\tpx = permute289(Pi.x + ix);\n\t\tfor(float iy = -1.0; iy <= 1.0; iy++) {\n\t\t\tpxy = permute289(px + Pi.y + iy);\n\t\t\tox = fract(pxy/7.0) - 0.5;\n\t\t\toy = mod(floor(pxy/7.0), 7.0)/7.0 - 0.5;\n\t\t\tdx = Pf.x + ix + jitter*ox + 0.5;\n\t\t\tdy = Pf.y + iy + jitter*oy + 0.5;\n\t\t\td = dx*dx + dy*dy; // Distance from P to Pn, squared\n            // d could replace either d1 or d2, handle both cases\n\t\t\td2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));\n\t\t\tP1 = (d <= d1 ? vec2(dx,dy) : P1);\n\t\t\tID1 = (d <= d1 ? pxy : ID1);\n\t\t\td1 = (d <= d1 ? d : d1);\n\t\t}\n\t}\n\treturn(sqrt(vec2(d1, d2)));\n}\n","name":"Common","description":"","type":"common"}]}