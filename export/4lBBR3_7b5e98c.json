{"ver":"0.1","info":{"id":"4lBBR3","date":"1516615458","viewed":84,"name":"thick lines w/ halo","username":"jensweh","description":"Parts of the normal rendering pipeline reproduced in the fragment shader.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["thicklines"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"mat4 makePerspectiveProj(in float fovy,  in float aspect,  in float zNear,  in float zFar)\n{\n    float f = 1.0 / tan(fovy / 2.0);\n    float denom = zNear - zFar;\n    return mat4(f / aspect, 0.0, 0.0, 0.0,\n                0.0, f, 0.0, 0.0,\n                0.0, 0.0,  (zFar + zNear) / denom, -1.0,\n                0.0, 0.0, (2.0 * zFar * zNear) / denom, 0.0);\n}\n\n\nmat4 makeRotationMatrix(in float angle, in vec3 axis)\n{\n    // See http://www.songho.ca/opengl/files/gl_matrix04.png\n    float c = cos(angle);\n    float s = sin(angle);\n    float omc = 1.0 - c;\n\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat4(x * x * omc + c, x * y * omc + z * s, x * z * omc - y * s, 0.0,\n                x * y * omc - z * s, y * y * omc + c, y * z * omc + x * s, 0.0,\n                x * z * omc + y * s, y * z * omc - x * s, z * z * omc + c, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n}\n\n\nfloat min_dist_lineseg_pt(vec2 v, vec2 w, vec2 p)\n{\n    // Shamelessly stolen from https://stackoverflow.com/a/1501725\n    vec2 d = w - v;\n    float l2 = dot(d, d);\n    float t = max(0.0, min(1.0, dot(p - v, d) / l2));\n    vec2 proj = v + t * d;\n    return distance(proj, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // make modelview matrix\n    mat4 mv = mat4(1.0);\n\n    float angle = sin(iTime * 0.76 + 2.13) *\n                 (cos(iTime * 1.37 + 0.1) + 0.3) *\n                 2.7;\n    vec3 axis = normalize(vec3(0.2, 0.47, 0.387));\n\n    mv = makeRotationMatrix(angle, axis);\n    mv[3] = vec4(0.0, 0.0, 6.0, 1.0);\n\n    // make projection matrix\n    mat4 proj = makePerspectiveProj(radians(60.0), iResolution.x / iResolution.y, 0.1, 100.0);\n\n    mat4 mvp = proj * mv;\n\n    vec4 final_color = vec4(0.2, 0.2, 0.7, 1.0);\n\n    vec4 vertices_pos[8];\n    vec4 vertices_pos_wc[8];\n\n    vertices_pos[0] = vec4(-1.0, -1.0, -1.0, 1.0);\n    vertices_pos[1] = vec4(+1.0, -1.0, -1.0, 1.0);\n    vertices_pos[2] = vec4(+1.0, +1.0, -1.0, 1.0);\n    vertices_pos[3] = vec4(-1.0, +1.0, -1.0, 1.0);\n    vertices_pos[4] = vec4(-1.0, -1.0, +1.0, 1.0);\n    vertices_pos[5] = vec4(+1.0, -1.0, +1.0, 1.0);\n    vertices_pos[6] = vec4(+1.0, +1.0, +1.0, 1.0);\n    vertices_pos[7] = vec4(-1.0, +1.0, +1.0, 1.0);\n\n    // Transform vertices\n    for (int i = 0; i < 8; ++i) {\n\n        vec4 pos_cc = mvp * vertices_pos[i];\n        vec4 pos_ndc = pos_cc * vec4(1.0 / pos_cc[3]);\n        vertices_pos_wc[i] = vec4(\n            (pos_ndc.xy * vec2(0.5) + vec2(0.5)) * iResolution.xy,\n            (1.0 + pos_ndc[2]) * 0.5,\n            1.0) // wrong, but doesn't matter.\n            ;\n    }\n\n\n#if 1\n\n    // Render lines\n    float line_width = 15.0 + cos(iTime * 2.4) * 14.5;\n    for (int i = 0; i < 12; ++i) {\n\n        vec2 line_pt_a, line_pt_b;\n        if (i == 0)       { line_pt_a = vertices_pos_wc[0].xy; line_pt_b = vertices_pos_wc[1].xy; }\n        else if (i == 1)  { line_pt_a = vertices_pos_wc[1].xy; line_pt_b = vertices_pos_wc[2].xy; }\n        else if (i == 2)  { line_pt_a = vertices_pos_wc[2].xy; line_pt_b = vertices_pos_wc[3].xy; }\n        else if (i == 3)  { line_pt_a = vertices_pos_wc[3].xy; line_pt_b = vertices_pos_wc[0].xy; }\n        else if (i == 4)  { line_pt_a = vertices_pos_wc[4].xy; line_pt_b = vertices_pos_wc[5].xy; }\n        else if (i == 5)  { line_pt_a = vertices_pos_wc[5].xy; line_pt_b = vertices_pos_wc[6].xy; }\n        else if (i == 6)  { line_pt_a = vertices_pos_wc[6].xy; line_pt_b = vertices_pos_wc[7].xy; }\n        else if (i == 7)   { line_pt_a = vertices_pos_wc[7].xy; line_pt_b = vertices_pos_wc[4].xy; }\n        else if (i == 8)   { line_pt_a = vertices_pos_wc[0].xy; line_pt_b = vertices_pos_wc[4].xy; }\n        else if (i == 9)  { line_pt_a = vertices_pos_wc[1].xy; line_pt_b = vertices_pos_wc[5].xy; }\n        else if (i == 10) { line_pt_a = vertices_pos_wc[2].xy; line_pt_b = vertices_pos_wc[6].xy; }\n        else if (i == 11) { line_pt_a = vertices_pos_wc[3].xy; line_pt_b = vertices_pos_wc[7].xy; }\n\n        float min_dist = min_dist_lineseg_pt(line_pt_a, line_pt_b, fragCoord.xy);\n        final_color.rgb += (1.0 - smoothstep(line_width * 0.8, line_width * 1.5, min_dist)) * vec3(0.3, 0.3, 0.3);\n    }\n\n#endif\n\n#if 1\n    // Render points\n    const float radius_squared = 5.0 * 5.0;\n    for (int i = 0; i < 8; ++i) {\n        vec2 dv = fragCoord - vertices_pos_wc[i].xy;\n        float dist_squ = dot(dv, dv);\n        final_color.rgb += (1.0 - smoothstep(9.0, 1000.0, dist_squ)) * vec3(0.0, 0.8, 0.8);\n    }\n#endif\n\n    fragColor = final_color;\n\n}\n","name":"Image","description":"","type":"image"}]}