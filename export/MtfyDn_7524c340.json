{"ver":"0.1","info":{"id":"MtfyDn","date":"1504284596","viewed":99,"name":"MapleLeaf","username":"CodeMaven","description":"Experimenting with procedural shader - draw a Canadian Maple Leaf.  New to shaders..\nUltimately I'm looking to reproduce our MapleScot logo (http://maple.scot)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["procedural","2d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Troy Peterson 2017\n// Experimenting with proedural shader - draw a Canadian Maple Leaf\n// maple.scot\n\n\nprecision lowp float;\n\n#define EPSILON 0.000000001\n\nconst vec4 WHITE = vec4(1,1,1,1);\nconst vec4 RED = vec4(1,0,0,1);\nconst vec4 BLUE = vec4(0.0,0.14,0.49,1);\n\n\nbool inLine(vec2 p, vec2 a, vec2 b) {\n   \n    return ((b.x - a.x) * (p.y - a.y) - (b.y - a.y) * (p.x - a.x) > 0.);\n    \n}\n\nbool inTriangle(vec2 p, vec2 a, vec2 b, vec2 c) {\n    return inLine(p, a,b) &&\n        inLine(p, b,c) &&\n        inLine(p, c,a);\n}\n\nbool inPoints(vec2 p, vec2 points[29]) {\n    for(int i=0;i<29;i++) {\n        if (inTriangle(p, vec2(0.5,0.5),points[i], points[i+1] )) return true;\n    }\n    if (inTriangle(p, vec2(0.5,0.5),points[28], points[0])) return true;\n    return false;\n}\n\n// Determine the orientation of a triangle\n// 0 = colinear, 1 = clockwise, 2=counterclockwise\nint orientation(vec2 a, vec2 b, vec2 c) {\n    float  v =( b.y - a.y) * (c.x - b.x)\n        - (b.x - a.x) * (c.y - b.y);\n    \n    if (v>EPSILON) return 1; \n    if (v<-EPSILON) return 2;\n    return 0; // Colinear\n}\n\n// Determine if two line segments intersect. We can quickly determine this\n// by making four triangles from the points and checking if the orientation \n// of two paris of triangles differs. If it does then they must intersect.\nbool intersect(vec2 a1, vec2 a2, vec2 b1, vec2 b2) {\n    int t1 = orientation(a1, a2, b1);\n    int t2 = orientation(a1, a2, b2);\n    int t3 = orientation(b1, b2, a1);\n    int t4 = orientation(b1, b2, a2);\n    \n    if  (t1 != t2 && t3 != t4) return true;\n    return false;\n    // There are some special cases But they're not possible here so there's no point\n    // testing for them\n}\n\n\n// We can quicktly determine if a point is inside a polygon by drawing a \n// line from that point to one of the edges and counting the number of\n// line segments we cross... if we cross an odd number we must be inside.\nbool pointInPoly(vec2 p, vec2 points[29]) {\n    vec2 p2 = vec2(1.0, p.y);\n    float c = 0.0;\n    for(int i=0;i<28;i++) {\n        if (intersect(p,p2,points[i], points[i+1])) c++;\n    }\n    if (intersect(p,p2,points[28], points[0])) c++;\n    return mod(c, 2.0) >0.0;\n}\n\nbool inScotFlag(vec2 p) {\n  if (inTriangle(p, \n                vec2(0.3818181818,\t0.5),\n\t\t\t\tvec2(0.0,\t0.7272727273),\n\t\t\t\tvec2(0.0, 0.2727272727)\n\t\t\t\t)) return true;\n \n  if (inTriangle(p, \n                vec2(0.1181818182,\t0.2),\n                vec2(0.8772727273,\t0.2),\n                vec2(0.5,\t0.4318181818)\t\t\t\t\n\t\t\t\t)) return true;\n    \n   if (inTriangle(p, \n                 vec2(0.6181818182,\t0.5),\n\t\t\t\t vec2(1,\t0.2681818182),\n\t\t\t\t vec2(1,\t0.7272727273)\n\t\t\t\t )) return true;\n    \n   if (inTriangle(p, \n                 vec2(0.5,\t0.5727272727), \n                 vec2(0.8727272727,\t0.7954545455), \n                 vec2(0.1227272727,\t0.7954545455)\n                )) return true;\n    \n  return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t    vec2 st = fragCoord.xy/iResolution.y;\n    vec3 color = vec3(0.0);\n    \n    vec2 points[29];\n\n\tpoints[0] = vec2(0.5,\t0.9716494845);\n\tpoints[1] = vec2(0.4971644612,\t0.9716494845);\n\tpoints[2] = vec2(0.3913043478,\t0.8032646048);\n\tpoints[3] = vec2(0.286389414,\t0.8479381443);\n\tpoints[4] = vec2(0.3440453686,\t0.5807560137);\n\tpoints[5] = vec2(0.2069943289,\t0.6967353952);\n\tpoints[6] = vec2(0.1710775047,\t0.6357388316);\n\tpoints[7] = vec2(0.0255198488,\t0.6563573883);\n\tpoints[8] = vec2(0.0708884688,\t0.5111683849);\n\tpoints[9] = vec2(0.0056710775,\t0.4703092784);\n\tpoints[10] = vec2(0.2533081285,\t0.2895189003);\n\tpoints[11] = vec2(0.2202268431,\t0.1950171821);\n\tpoints[12] = vec2(0.4754253308,\t0.2379725086);\n\tpoints[13] = vec2(0.4754253308,\t0.0206185567);\n\tpoints[14] = vec2(0.5,\t0.0206185567);\n\tpoints[15] = vec2(0.5245746692,\t0.0206185567);\n\tpoints[16] = vec2(0.5245746692,\t0.2379725086);\n\tpoints[17] = vec2(0.7797731569,\t0.1950171821);\n\tpoints[18] = vec2(0.7466918715,\t0.2895189003);\n\tpoints[19] = vec2(0.9943289225,\t0.4703092784);\n\tpoints[20] = vec2(0.9291115312,\t0.5111683849);\n\tpoints[21] = vec2(0.9744801512,\t0.6563573883);\n\tpoints[22] = vec2(0.8289224953,\t0.6357388316);\n\tpoints[23] = vec2(0.7930056711,\t0.6967353952);\n\tpoints[24] = vec2(0.6559546314,\t0.5807560137);\n\tpoints[25] = vec2(0.713610586,\t0.8479381443);\n\tpoints[26] = vec2(0.6086956522,\t0.8032646048);\n\tpoints[27] = vec2(0.5028355388,\t0.9716494845);\n\tpoints[28] = vec2(0.5,\t0.9716494845);\n    \n    //if (inPoints(st,points)) fragColor = RED;\n    if (pointInPoly(st,points)) fragColor = RED;\n    //if (inPoints(st,points) && inScotFlag(st)) fragColor=BLUE;\n    else fragColor = WHITE;\n\n    \n}","name":"Image","description":"","type":"image"}]}