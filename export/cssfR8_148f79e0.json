{"ver":"0.1","info":{"id":"cssfR8","date":"1688456900","viewed":73,"name":"Insane Equalizer","username":"logic23","description":"very sick very coo","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["equalizer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Mdc3Dn","filepath":"https://soundcloud.com/travis-scott-radio/sdp-interlude-demo","previewfilepath":"https://soundcloud.com/travis-scott-radio/sdp-interlude-demo","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float rand(float x)\n{\n return fract(sin(x) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //for uv2 (0,0) is center\n    vec2 uv2;\n    uv2 = uv - vec2(0.5);\n    \n    float curvature = 0.46;\n    float dist = length(uv2 * vec2(1.0, 0.7)) + curvature;\n    uv2 *= pow(dist, 0.5) * 0.9;\n\n    // Create a copy of the distorted uv coords to calculate signal and TV borders\n    vec2 uv_borders = uv2 + vec2(0.5);\n\n    // apply distorted coordinates to our original uv\n    uv = uv2 + vec2(0.5);\n    \n    float sound = texture(iChannel0, vec2(uv.x, 0.75)).x;\n    float prevSound = texture(iChannel1, vec2(uv.x, 0.75)).x;\n    \n    // Apply smoothing.\n    float smoothedSound = mix(prevSound, sound, 0.5); \n\n    // Normalize the sound to keep it centered.\n    float normSound = 0.5 * (smoothedSound + 0.9);\n\n    vec3 color = vec3(0.);\n    \n    // Draw multiple waves at different y positions.\n    for (int i = 0; i < 1;i++) {\n        float yOffset = float(i) * 0.15 + 0.1;\n        float yScale = 0.14;  \n        float xScale = 1.7;\n\n       // if ((i == 2)|| (i ==4)) yScale = 0.01*float(i); xScale = 0.029;\n\n        color += vec3(0., \n        1.0001 - smoothstep(0., yScale * abs(sin(iTime * xScale + yOffset) * 0.1), abs(normSound - (uv.y + yOffset))),\n        0.);\n    }\n\n    //crt warmp up\n    float warmup_darkness = min(1.0, iTime * 0.2);\n\n    // Calculate borders for the signal\n    float signalborder = 1.0;\n    signalborder = min(signalborder, uv.x * 9.0);\n    signalborder = min(signalborder, uv.y * 6.0);\n    signalborder = min(signalborder, (1.0-uv.x) * 9.0);\n    signalborder = min(signalborder, (1.0-uv.y) *5.0);\n    signalborder = pow(max(signalborder, 0.0),2.0);\n    signalborder *= 1. - pow(dist, 5.0) * 0.2;\n    \n    \n\n    // Apply signal border and warmup darkness\n    color *= signalborder * warmup_darkness;\n    \n        // Create a new vec4 from the color variable\n    vec4 imp = vec4(color, 1.0) * signalborder;\n\n    // Add the traveling lines, flicker, and warmup effects\n    imp *= .8 + pow(sin(uv2.y * 9.0 + iTime * 5.0) * 0.5 + 0.5, 2.0) * 20.4;\n    imp *= rand(iTime * 4.0) * 2.2 + 0.8;\n\n    // Adjust the warmup darkness variable as needed\n    float warmup_darkness_tube = min(1.0, iTime * 0.7);\n    imp *= warmup_darkness;\n    imp += vec4(0.1) * warmup_darkness_tube;\n    imp = clamp(imp, vec4(0.0), vec4(1.0));\n\n    // Define filtervar as needed\n    vec4 filtervar = vec4(1.);\n\n\n    // Set the output color\n    fragColor = imp * filtervar;\n\n\n}\n","name":"Image","description":"","type":"image"}]}