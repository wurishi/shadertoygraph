{"ver":"0.1","info":{"id":"mlfGzN","date":"1671389264","viewed":272,"name":"AI shader","username":"yaremenko8","description":"ai shader","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ai"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n \nfloat velocity() { return 1.0;}\n \nmat2 rot(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n \nvec4 HueShift (in vec3 Color, in float Shift)\n{\n    vec3 P = vec3(0.55735)*dot(vec3(0.55735),Color);\n \n    vec3 U = Color-P;\n \n    vec3 V = cross(vec3(0.55735),U);    \n \n    Color = U*cos(Shift*6.2832) + V*sin(Shift*6.2832) + P;\n \n    return vec4(Color,1.0);\n}\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n \nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n \nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n \nfloat sdCone( in vec3 p, in float r, in float h )\n{\n    vec2 q = vec2(length(p.xz),p.y);\n    float a = atan(r,h);\n    float t = tan(a);\n    float k = q.x * t;\n    return length(vec2(q.x,q.y)) - min(q.y,k);\n}\n \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n \nfloat mat = 0.0;\nfloat ss = 0.5;\n \nfloat map(vec3 p)\n{\n    // Randomly wavy shape\n    p.x += sin(0.9 * p.z * ss);\n    p.y += cos(p.z * ss);\n \n    // Create a sphere\n    float sphere = sdSphere(p, 2.0);\n \n    // Create a cylinder and intersect it with the sphere\n    float cylinder = sdCylinder(p, vec2(1.0, 2.0));\n    float intersection = max(sphere, cylinder);\n \n    // Create a cone and subtract it from the intersection of the sphere and cylinder\n    float cone = sdCone(p, 1.0, 2.0);\n    float difference = max(intersection, -cone);\n \n    // Use the difference as the distance field\n    float d = difference;\n \n    // Determine the material based on the distance field\n    if (d < 0.0) mat = 1.0; // Cylinder\n    else if (d < 0.2) mat = 2.0; // Cone\n    else mat = 0.0; // Sphere\n \n    return d;\n}\n \nvec3 normal(vec3 p)\n{\n\tvec3 o = vec3(0.01, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy) - map(p-o.xyy),\n                          map(p+o.yxy) - map(p-o.yxy),\n                          map(p+o.yyx) - map(p-o.yyx)));\n}\n \nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        t += map(o + r * t) * 0.6;\n    }\n    return t;\n}\n \nvec3 textex(sampler2D channel, vec3 p)\n{\n    vec3 ta = texture(channel, p.xy).xyz;\n    vec3 tb = texture(channel, p.xz).xyz;\n    vec3 tc = texture(channel, p.yz).xyz;\n    return (10.0 * ta + tb + tc) / 12.0;\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n       \tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 ta = normalize(vec3(1.0, 0.5, 0.0));\n    vec3 ww = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 rd = (2.0 * dot(ww, ta) * ta - ww);\n    float t = trace(ro, rd);\n\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    \n    vec3 o = vec3(0.0, 0.0, iTime * 8.0 * velocity());\n    //vec3 o = vec3(0.0, 0.0, position() * 8.0);\n    o.x -= sin(o.z * ss);\n    o.y -= cos(o.z * ss);\n    \n    vec3 r = normalize(vec3(uv, 1.0 - dot(uv, uv) * 0.33));\n\n    r.xy *= rot(sin(o.z * ss * 0.5) * 3.14159 * 0.5);\n    r.xz *= rot(sin(o.z * ss) * 3.14159 * 0.25);\n    r.yz *= rot(cos(o.z * ss) * 3.14159 * 0.25);\n    \n    vec3 w = o + r * t;\n    float fd = map(w);\n    vec3 sn = normal(w);\n    \n        vec3 tex = textex(iChannel0, w);\n    if (mat < 3.0) {\n        tex *= 0.25;\n    }\n    if (t > 1.0) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = normal(pos);\n        float diff = max(dot(nor, rd), 0.0);\n        vec3 ref = reflect(rd, nor);\n        float spec = pow(max(dot(ref, ta), 0.0), 4.0);\n        vec3 col = tex;\n        if (mat == 1.0) col = vec3(1.0, 0.0, 0.0); // Cylinder\n        else if (mat == 2.0) col = vec3(0.0, 1.0, 0.0); // Cone\n        else col = vec3(1.0, 1.0, 1.0); // Sphere\n        fragColor = vec4(col * diff + spec, 1.0);\n    } else {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n \n ","name":"Image","description":"","type":"image"}]}