{"ver":"0.1","info":{"id":"4l2cWG","date":"1528647086","viewed":535,"name":"neon scadrial","username":"raziel","description":"This started as something else entirely and became an area light with random patterns illuminating some fog and terrain. Ray-marching using stuff meant for path-tracing, probably riddled with mistakes, but oh well ... pretty light ^_^","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["reflection","terrain","light","volumetric","fog","scattering","sampling","transmittance","area","bit","integration","density","angular","equi"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- This started as something else entirely and became an area light with random patterns illuminating some fog and terrain. \n// --- Ray-marching using stuff meant for path-tracing, probably riddled with mistakes, but oh well ...\n// --- Thanks to iq for all the ray-marching signed distance fields, noise and terrain rendering resources\n// --- https://iquilezles.org/articles/morenoise\n// --- Thanks to SebH for volumetric rendering resources\n// --- http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n// --- Solid Angle for the cool article on equi-angular sampling and sjb for example implementation\n// ---  https://www.solidangle.com/research/egsr2012_volume.pdf\n// --- Thanks to ferris from logicoma and this amazing intro https://www.youtube.com/watch?v=9r8pxIogxZ0 for inspiration\n\nfloat rand(vec2 p)\n{\n    p = 50.0 * fract(p * 0.3183099);\n    return fract(p.x * p.y * (p.x + p.y));\n}\n\nfloat rand(float p)\n{\n    return fract(sin(p) * 54897.3451289);\n}\n\nvec2 smoothstepd(float e0, float e1, float x)\n{\n    if (x < e0)\n        return vec2(0.0, 0.0);\n    if (x > e1)\n        return vec2(1.0, 0.0);\n    \n    float t = (x - e0) / (e1 - e0);\n    float td = 1.0 / (e1 - e0);\n    return vec2(3.0 * t * t - 2.0 * t * t * t, 6.0 * t * (1.0 - t) * td);\n}\n\nfloat valueNoise(in vec2 p)\n{\n    vec2 X = floor(p);\n    vec2 x = fract(p);\n    \n    vec2 fn = x * x * x * (6.0 * x * x - 15.0 * x + 10.0);\n    float u = fn.x;\n    float v = fn.y;\n    \n    float a = rand(X + vec2(0.0, 0.0));\n    float b = rand(X + vec2(1.0, 0.0));\n    float c = rand(X + vec2(0.0, 1.0));\n    float d = rand(X + vec2(1.0, 1.0));\n    \n    float n = (b - a) * u + (c - a) * v + (a - b - c + d) * u * v + a;\n    return 2.0 * n - 1.0;\n}\n\nvec3 valueNoiseD(in vec2 p)\n{\n    vec2 X = floor(p);\n    vec2 x = fract(p);\n    \n    vec2 fn = x * x * x * (6.0 * x * x - 15.0 * x + 10.0);\n    vec2 dfn = 30.0 * x * x * (x * x - 2.0 * x + 1.0);\n    float u = fn.x;\n    float v = fn.y;\n    float du = dfn.x;\n    float dv = dfn.y;\n    \n    float a = rand(X + vec2(0.0, 0.0));\n    float b = rand(X + vec2(1.0, 0.0));\n    float c = rand(X + vec2(0.0, 1.0));\n    float d = rand(X + vec2(1.0, 1.0));\n    \n    float n = 2.0 * ((b - a) * u + (c - a) * v + (a - b - c + d) * u * v + a) - 1.0;\n    float dnu = 2.0 * du * ((b - a) + (a - b - c + d) * v);\n    float dnv = 2.0 * dv * ((c - a) + (a - b - c + d) * u);\n    return vec3(n, dnu, dnv);\n}\n\nconst mat2 fbmRot2 = mat2(0.8, 0.6,\n                         -0.6, 0.8);\n\nconst mat2 fbmRot2T = mat2(0.8, -0.6,\n                          0.6, 0.8);\n\nvec3 fbm9D(in vec2 x)\n{\n\tfloat freq = 1.98;\n    float noise = 0.0;\n    float ampl = 0.8;\n    float scale = 0.49;\n    vec2 deriv = vec2(0.0);\n    mat2 m = mat2(1.0, 0.0, 0.0, 1.0);\n    for (int i = 0; i < 9; ++i)\n    {\n        vec3 res = valueNoiseD(x);  \n        deriv += ampl * m * res.yz;\n        noise += ampl * res.x / (1.0 + dot(deriv, deriv));\n        ampl *= scale;\n        x = freq * fbmRot2 * x;\n        m = freq * fbmRot2T * m;\n    }\n    return vec3(noise, deriv);\n}\n\nfloat fbm3D(in vec2 x)\n{\n\tfloat freq = 2.15;\n    float noise = 0.0;\n    float ampl = 1.8;\n    float scale = 0.45;\n    for (int i = 0; i < 3; ++i)\n    {\n        float res = valueNoise(x);  \n        noise += ampl * res;\n        ampl *= scale;\n        x = freq * fbmRot2 * x;\n    }\n    return noise;\n}\n    \nstruct SceneData\n{\n    int materialID;\n    float sdf;\n};\n    \nstruct MarchResult\n{\n    float t;\n    int materialID;\n};\n    \nconst vec3 DirectionalLightColor = vec3(1.0, 1.0, 1.0) * 0.9;\nconst vec3 DirectionalLightDirection = normalize(vec3(-2.0, -1.8, -1.0) - vec3(5.0, -5.0, 5.0 * 2.0));\nconst vec3 AreaLightColor = vec3(1.0);//vec3(0.909, 0.65, 0.090);//vec3(0.349, 0.909, 0.729);\nconst vec3 AreaLightPosition = vec3(0.0, 0.55, 2.25);\nconst vec3 AreaLightNormal = vec3(0.0, 0.0, -1.0);\nconst vec3 AreaLightSize = vec3(0.732, 0.705, 0.00);\n    \nSceneData intersectBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    SceneData data;\n    data.sdf = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n    data.materialID = 1;     \n    return data;\n}\n\nvec3 getLightIntensity(in vec3 p)\n{\n    int counter = int((iTime * 5.0)) & 255;\n    int shift = int(p.y * 32.0) & 11 + int(p.x * 32.0) & 7;\n    int on = (counter >> shift) & 1;\n    return vec3(float(on), float(1 - on), 1.0) * 10.0;\n}\n\nmat3 getRotation()\n{\n    float th =(cos(iTime * 2.1)) * 3.14159265 * 0.25; \n    float c = cos(th);\n    float s = sin(th);\n    mat3 roty = mat3(c, 0.0, s, 0.0, 1.0, 0.0, -s, 0.0, c);\n    mat3 rotx = mat3(1.0, 0.0, 0.0, 0.0, 0.8, -0.6, 0.0, 0.6, 0.8);\n    return rotx * roty;\n}\n\nvoid sampleAreaLight(in vec2 uv, out vec3 lightPosition, out vec3 lightIntensity)\n{\n    vec3 normal = transpose(getRotation()) * AreaLightNormal;\n    vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n    vec3 bitangent = normalize(cross(normal, tangent));\n    float u = (0.5 - uv.x) * AreaLightSize.x * 2.0;\n    float v = (uv.y - 0.5) * AreaLightSize.y * 2.0;\n    lightPosition = AreaLightPosition + u * tangent + v * bitangent;\n    lightIntensity = getLightIntensity(lightPosition);  \n}\n\nfloat densityVoumetricFog(in vec3 p)\n{\n    float res = clamp(fbm3D(p.xz * 0.01 - (iTime * 1.5 - 1.54)) * 0.25 - p.y * 0.02, 0.0, 1.0);\n\n    float fog = (res * 0.8 + 0.1);\n    fog = pow(fog, 2.0);\n    return fog * 15.0;\n}\n\nfloat rayMarchToAreaLight(in vec3 ro, in vec3 rd)\n{\n    const float numStep = 4.0;\n    float shadow = 1.0;\n  \tfloat stepDist = length(rd - ro) / numStep;\n    vec3 dir = normalize(rd - ro);\n    for(float i = 0.5; i < numStep; i += 1.0)\n    {\n        vec3 pos = ro + dir * (i / (numStep));\n        shadow *= exp(-densityVoumetricFog(pos * 253.0) * stepDist);\n    }\n    return shadow;\n}\n\nvoid integrateVolumetricFog(in vec3 p, \n                           in vec3 V,\n                           in float density,\n                           in float d,\n                           inout float transmittance, \n                           inout vec3 inscatteredLight,\n                           in vec2 fragCoord)\n{\n    // --- sample a random position on the area light\n    transmittance *= exp(-density * d);\n    float g = 0.2;\n    float u = rand(rand(fragCoord.x * p.x + fragCoord.y + d * 1.5) + 46984.4363);\n    float v = rand(rand(fragCoord.y * p.y + fragCoord.x + d * 2.5) + 3428.532546);\n    vec3 lightPos;\n    vec3 lightCol;\n    sampleAreaLight(vec2(u, v), lightPos, lightCol);\n    vec3 L = (lightPos - p);\n    float G = (dot(normalize(L), transpose(getRotation()) * AreaLightNormal)) / dot(L, L);\n    float areaPdf = 1.0 / (AreaLightSize.x * AreaLightSize.y);\n    float shadow = rayMarchToAreaLight(p, lightPos);\n    float phaseHG = (1.0 / (4.0 * 3.14)) * ((1.0 - g * g) / (pow((1.0 + g * g - 2.0 * g * max(dot(normalize(L), V), 0.0)), 3.0 / 2.0)));\n    inscatteredLight += density * transmittance * lightCol * G * phaseHG * d * (1.0 / areaPdf) * shadow;\n}\n\nvoid integrateVolumetricFogFromSampledPosition(in vec3 p, \n                           in vec3 V,\n                           in float density,\n                           in float d,\n                           inout vec3 inscatteredLight,\n                           in vec3 lightPos,\n                           in vec3 lightCol,\n                           in float xPdf)\n{\n    // same integration as above, but position on the ray is given by equi-angular sampling\n    float trans = exp(-density * d);\n    float g = 0.2;\n    vec3 L = (lightPos - p);\n    float G = (dot(normalize(L), transpose(getRotation()) * AreaLightNormal)) / dot(L, L);\n    float areaPdf = 1.0 / (AreaLightSize.x * AreaLightSize.y);\n    float shadow = rayMarchToAreaLight(p, lightPos);\n    float phaseHG = (1.0 / (4.0 * 3.14)) * ((1.0 - g * g) / (pow((1.0 + g * g - 2.0 * g * max(dot(normalize(L), V), 0.0)), 3.0 / 2.0)));\n    inscatteredLight += density * trans * lightCol * G * phaseHG  * (1.0 / areaPdf) * (1.0 / xPdf) * shadow;\n}\n\nSceneData intersectTerrain(in vec2 p)\n{\n    p *= 0.4;\n    vec3 res = fbm9D(p);\n    res.x *= 0.8;\n    res.x = res.x + smoothstep(-0.112, 0.1, res.x) * 0.8;\n    res.x *= 0.4;\n    SceneData data;\n    data.sdf = res.x;\n    data.materialID = 0;\n    return data;\n}\n\nvec4 normalTerrain(in vec2 p)\n{\n   \tp *= 0.4;\n    vec3 res = fbm9D(p);\n    res *= 0.8;\n    vec2 mdf = smoothstepd(-0.112, 0.1, res.x);\n    res.x = res.x + mdf.x * 0.8;\n    res.yz = res.yz + mdf.y * 0.8 * res.yz;\n    res.x *= 0.4;\n    res.yz *= 0.4;\n    \n    return vec4(res.x, normalize(vec3(-res.y, 1.0, -res.z)));\n}\n\nSceneData unite(SceneData sd0, SceneData sd1)\n{\n    if (sd0.sdf < sd1.sdf)\n        return sd0;\n    else\n        return sd1;\n}\n\nMarchResult raymarchScene(in vec3 ro, in vec3 rd, out vec4 scattering, in vec2 fragCoord)\n{\n    float tmin = 0.0;\n    float tmax = 50.0;\n    float t = tmin;\n    float prevt = t;\n    float d = 0.0, eps = 0.0;\n    float prevd = d;\n    float density = 0.0;\n    float transmittance = 1.0;\n    float stp = 0.0;\n    vec3 inscatteredLight = vec3(0.0);\n    vec3 inscatteredLightFromEquiAngularSampling = vec3(0.0);\n    MarchResult result;\n    int stepsEquiAngularSampling = 0;\n    \n    for (int i = 0; i < 300; ++i)\n    {\n        eps = t * 0.001;\n        vec3 p = ro + t * rd;    \n          \n        density = (densityVoumetricFog(p * 253.0));\n        integrateVolumetricFog(p, rd, density, stp, transmittance, inscatteredLight, fragCoord);\n        if (stepsEquiAngularSampling < 32)\n        {\n            float u = rand(rand(fragCoord.x * iResolution.y + fragCoord.y + d * 1.5) + iTime + 1234.32598);\n            float v = rand(rand(fragCoord.y * iResolution.x + fragCoord.x + d * 2.5) + iTime * 2.0 + 6234.32598);\n            vec3 lightPos;\n            vec3 lightCol;\n            sampleAreaLight(vec2(u, v), lightPos, lightCol);\n\n            float x0 = rand(rand(fragCoord.y * iResolution.y + fragCoord.x + d * 3.5 + iTime) + 236526.436346);\n            // --- equi-angular sampling\n            float DT = dot(lightPos - ro, rd);\n            float D = length(ro + DT * rd - lightPos);\n            float tha = atan(0.0 - DT, D);\n            float thb = atan(length(tmax - ro) - DT, D);\n            float tsampled = D * tan(mix(tha, thb, x0));\n            float pdf = D / ((thb - tha) * (D * D + tsampled * tsampled));\n            float x = DT + tsampled;\n            vec3 sampledPos = ro + x * rd;\n            \n        \tfloat densityFromSampledPos = (densityVoumetricFog(sampledPos * 253.0));\n        \tintegrateVolumetricFogFromSampledPosition(sampledPos, rd, densityFromSampledPos, x, inscatteredLightFromEquiAngularSampling, lightPos, lightCol, pdf); \n        \tstepsEquiAngularSampling++;        \n        }\n        \n        SceneData res = intersectTerrain(p.xz);\n        float h = res.sdf;\n        d = p.y - h;\n        \n        vec3 prot = getRotation() * (p - AreaLightPosition);\n        SceneData lightPlane = intersectBox(prot, AreaLightSize);\n        SceneData terrain;\n        terrain.sdf = d;\n        terrain.materialID = res.materialID;\n        SceneData scene = unite(terrain, lightPlane);\n        d = scene.sdf;\n        result.materialID = scene.materialID;\n        if (d < eps)\n            break;        \n        \n        stp = d * 0.32;\n        prevt = t;\n        prevd = d;\n        t += stp;\n        if (t > tmax)\n            break;\n    }\n    if (t > tmax)\n        t = -1.0;\n    else\n        t = mix(prevt, t, d/prevd);\n    \n    inscatteredLightFromEquiAngularSampling *= 1.0 / float(stepsEquiAngularSampling); \n    scattering = vec4(inscatteredLight + inscatteredLightFromEquiAngularSampling, transmittance);\n    result.t = t;\n    return result;\n}\n\nvec4 renderScene(in vec3 ro, in vec3 rd, in vec2 fragCoord)\n{\n    vec4 res = vec4(0.0);\n    vec4 scattering = vec4(0.0);\n    MarchResult m = raymarchScene(ro, rd, scattering, fragCoord);\n    if (m.t > 0.0)\n    {\n        vec3 p = ro + m.t * rd;\n        vec3 N = normalTerrain(p.xz).yzw;\n        \n        if (m.materialID == 0)\n        {\n            int numSteps = 256;\n            int actualSteps = 0;\n            vec3 normal = transpose(getRotation()) * AreaLightNormal;\n            vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));\n            vec3 bitangent = normalize(cross(normal, tangent));\n            for (int i = 0; i < numSteps; ++i)\n            {\n                vec3 R = reflect(rd, N);\n                float x0 = rand(rand(fragCoord.y * iResolution.y + p.x * p.y * 6543623.22355) +  float(i) * 3428.532546);\n                float x1 = rand(rand(fragCoord.x * iResolution.y +  p.z * p.y * 2124435.5346) + float(i) * 9067.214721);\n                float x2 = rand(rand(fragCoord.x * iResolution.x +  p.z * p.x * 352445.3466) + float(i) * 6797.745721);\n                R = normalize(R + vec3(x0, x1, x2));\n                if (dot(R, N) > 0.0)\n                {\n                \tfloat it = -dot(p - AreaLightPosition, normal) / dot(R, normal);\n                \tif (it > 0. && it < AreaLightPosition.z)\n                \t{\n\t                    vec3 hit = p + it * R;\n\t                    float x = dot(hit, tangent);\n\t                    float y = -dot(hit, bitangent);\n                    \tif (AreaLightPosition.x - AreaLightSize.x < x && x < AreaLightPosition.x + AreaLightSize.x\n                            && AreaLightPosition.y - AreaLightSize.y < y && y < AreaLightPosition.y + AreaLightSize.y)\n                        {\n                            vec3 lightPosition = AreaLightPosition + x * tangent + y * bitangent;\n\t                        res.xyz += (getLightIntensity(lightPosition)) * (1.0 / float(numSteps));\n                \t    }\n                \t}\t\n                }\n            }     \n        }\n        else if (m.materialID == 1)\n        {\n            res.xyz = getLightIntensity(p);\n        }\n        \n        res.xyz = res.xyz * scattering.w + scattering.rgb;\n        res.w = 1.0;\n    }\n    else\n        res = vec4(scattering.xyz, 1.0);\n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 fragCoord)\n{        \n    vec4 scene = renderScene(ro, rd, fragCoord);\n    vec3 color = scene.rgb;\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xi[5];\n    xi[0] = vec2(0.0, 0.0);\n    xi[1] = vec2(0.25, 0.0);\n    xi[2] = vec2(-0.25, 0.0);\n    xi[3] = vec2(0.0, 0.25);\n    xi[4] = vec2(0.0, -0.25);\n    \n    vec2 mo = iMouse.xy / iResolution.xy;\n    vec3 cp = vec3(0.0, 0.5, 6.0);\n    vec3 cu = normalize(vec3(0.0, 0.8, -0.2));\n    vec3 cr = vec3(1.0, 0.0, 0.0);\n    vec3 cf = normalize(cross(cu, cr));\n    float fl = 2.1;\n    \n    vec3 color = vec3(0.0);\n    const int nx = 1;\n    for (int i = 0; i < nx; ++i)\n    {\n        vec2 c_ss = (fragCoord.xy + xi[i]) / iResolution.xy;\n        vec2 c_cs = 2.0 * c_ss - 1.0;\n        c_cs.x *= iResolution.x / iResolution.y;\n        \n        vec3 rd = normalize(cf * fl + cr * c_cs.x + cu * c_cs.y);\n        color += render(cp, rd, fragCoord);\n    }\n    color /= float(nx);\n    color = pow(color, vec3(1.25, 1.0, 1.0));\n   \tcolor = color / (color + 1.0);\n    color = pow(color, vec3(0.4545));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}