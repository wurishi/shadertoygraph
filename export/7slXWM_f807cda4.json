{"ver":"0.1","info":{"id":"7slXWM","date":"1618713784","viewed":120,"name":"a.kaz_321_v5v0 ","username":"alexey_kaz","description":"Rings of Fire in D20\nGot some space theme vibes while doing this, hence the soundcloud track\n","likes":0,"published":1,"flags":96,"usePreview":0,"tags":["homework"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MtfXRS","filepath":"https://soundcloud.com/peaceofmindstudio/oh-the-joy-ascension-sleep","previewfilepath":"https://soundcloud.com/peaceofmindstudio/oh-the-joy-ascension-sleep","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define tile   0.850\n#define speed  0.000025\n\n#define brightness 0.003\n#define fading 0.780\n\n#define on_off false //turn stars on (true) and off (false)\n\nvec4 stars(vec2 uv){\n    vec3 dir = vec3(uv * 0.1, 1.0);\n\tfloat time = iTime * speed;\n\tfloat a1 = 0.5;\n\tvec3 from = vec3(0.0,0.0,0.0);\n\tfrom += vec3(time, time - 1.0, time - 2.0);\n\tfloat s = 0.1, fade=1.0;\n\tvec3 v=vec3(0.0);\n\tfor (int r=0; r<10; r++) {\n\t\tvec3 p=from + s * dir * 0.5;\n\t\tp = abs(vec3(tile) - mod(p, vec3(tile * 2.0)));\n\t\tfloat pa, a = pa = 0.0;\n\t\tfor (int i=0; i < 20; i++) { \n\t\t\tp = abs(p)/dot(p,p) - 0.9;\n\t\t\ta += abs(length(p) - pa);\n\t\t\tpa = length(p);\n\t\t}\n\t\ta *= a * a;\n\t\tv += fade;\n\t\tv += vec3(s) * a * brightness * fade;\n\t\tfade *= fading;\n\t\ts += 0.05;\n\t}\n    return vec4(v*.01,1.)/4.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv)/float(iFrame + 1) + float(on_off)*stars(uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e15;\nconst float AIR_N = 1.0;\nconst float GLASS_N = 1.5;\nconst vec3 CAMERA_POS = vec3(-6, 1, 2);\nconst vec3 CAMERA_POS1 = vec3(4, 1, 2);\nconst vec3 CAMERA_POS2 = vec3(4, 2.8, -2);\n\nconst vec3 Light1_pos = vec3(-0.5, 0.8, 0.9);\nconst float Light1_r = 0.25;\nconst vec3 Light1_col = vec3(1,1,1);\nconst float Light1_int = 20.0;\n\nconst vec3 Light2_pos = vec3(-1.5,1.0,-0.8);\nconst float Light2_r = 0.15;\nconst vec3 Light2_col = vec3(1,1,0.4);\nconst float Light2_int = 24.0;\n\nconst vec3 Light3_pos = vec3(0,1.0, 1);\nconst float Light3_r = 0.15;\nconst vec3 Light3_col = vec3(0.8,0.2,0);\nconst float Light3_int = 24.0;\n\nint MAX_STEPS = 50;\nvec3 FIRE_COLOR = vec3(1, 0.35, 0);\nfloat ABSORPTION = -12.0;\n\nconst float k = 0.1;\nvec3 blue_tint = vec3(0.3, 0.3, 0.5);\nvec3 randDir;\nconst float PHI = 0.809;\nconst float x = 0.5;\n\n\nfloat powf(float x, int a) {\n    float q = x;\n    int i = a;\n    while (i-- > 1) q *= x;\n    return a == 0 ? 0.0 : q;\n}\n\nfloat rand(float frame) {\n    return fract(sin(dot(vec3(frame), vec3(12.9898, 78.233, 45.5432)))*43758.5453);\n}\n\nstruct Material {\n    float emission;\n    float diffusion;\n    float reflection;\n    float refraction;\n    float n;\n    vec3 col;\n};\n\nstruct Sphere {\n    vec3 pos;\n    float radius;\n    Material m;\n};\n\nstruct Light {\n    Sphere sphere;\n    float intensity;\n};\n\nstruct Cylinder {\n    vec3 pos;\n    float radius;\n    Material m;\n};\n\nstruct Triangle {\n    vec3 vertecies[3];\n};\n\nstruct Ico {\n    vec3 vertecies[12];\n    Material m;\n};\n\nstruct Scene {\n    Light[3] lights;\n    Ico ico;\n    Cylinder cyl;\n} scene;\n\nconst Material emissive = Material(1.0, 0.0, 0.0, 0.0, AIR_N, vec3(0));\nconst Material diffusive = Material(0.0, 1.0, 0.0, 0.0, AIR_N, vec3(0));\nconst Material reflective = Material(0.0, 0.0, 1.0, 0.0, AIR_N, vec3(0));\nconst Material refractive = Material(0.0, 0.0, 0.0, 1.0, GLASS_N, vec3(0));\nconst Material glass = Material(0.0, 0.4, 1.0, 1.0, GLASS_N, vec3(0.5));\n\nconst Ico ico = Ico(\nvec3[12](vec3(-x,  PHI, 0),\n         vec3( x,  PHI, 0),\n         vec3(-x, -PHI, 0),\n         vec3( x, -PHI, 0),\n         vec3(0, -x,  PHI),\n         vec3(0,  x,  PHI),\n         vec3(0, -x, -PHI),\n         vec3(0,  x, -PHI),    \n         vec3( PHI, 0, -x),\n         vec3( PHI, 0,  x),\n         vec3(-PHI, 0, -x),\n         vec3(-PHI, 0,  x)),  glass);\n\nfloat tracePlane(vec3 camPos, vec3 dir, out vec3 N) {\n    float t = (-1.0 - camPos.y)/ dir.y;\n    vec3 worldPos = t * dir + camPos;\n    if (t < 0.0 || dot(worldPos.xz, worldPos.xz) > 20.0) return INF;\n    N = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceTriangle(vec3 pos, vec3 dir, Triangle tr, out vec3 N)\n{\n    const float EPSILON = 0.1;\n    vec3 vertex0 = tr.vertecies[0];\n    vec3 vertex1 = tr.vertecies[1];  \n    vec3 vertex2 = tr.vertecies[2];\n    vec3 edge1 = vertex1 - vertex0;\n    vec3 edge2 = vertex2 - vertex0;\n    vec3 h = cross(dir, edge2);\n    float a = dot(edge1, h);\n    if (a > -EPSILON && a < EPSILON) return INF;\n    float f = 1.0/a;\n    vec3 s = pos - vertex0;\n    float u = f * dot(s, h);\n    if (u < 0.0 || u > 1.0) return INF;\n    vec3 q = cross(s, edge1);\n    float v = f * dot(dir, q);\n    if (v < 0.0 || u + v > 1.0) return INF;\n    float t = f * dot(edge2, q);\n    if (t < EPSILON) return INF;\n    vec3 v1 = vertex2 - vertex0;\n    vec3 v2 = vertex1 - vertex0;\n    N = normalize(cross(v1,v2));\n    if (t <= 0.0) {\n        return INF;\n    }\n    return t;\n}\n\nfloat traceIco(vec3 pos, vec3 dir, Ico i, out vec3 N) {\n    Triangle tr[20];\n    tr[0] = Triangle(vec3[3](i.vertecies[5], i.vertecies[11], i.vertecies[0])); \n    tr[1] = Triangle(vec3[3](i.vertecies[1], i.vertecies[5], i.vertecies[0]));\n    tr[2] = Triangle(vec3[3](i.vertecies[7], i.vertecies[1], i.vertecies[0])); \n    tr[3] = Triangle(vec3[3](i.vertecies[10], i.vertecies[7], i.vertecies[0]));\n    tr[4] = Triangle(vec3[3](i.vertecies[11], i.vertecies[10], i.vertecies[0]));\n\n    tr[5] = Triangle(vec3[3](i.vertecies[9], i.vertecies[5], i.vertecies[1])); \n    tr[6] = Triangle(vec3[3](i.vertecies[4], i.vertecies[11], i.vertecies[5]));\n    tr[7] = Triangle(vec3[3](i.vertecies[2], i.vertecies[10], i.vertecies[11]));\n    tr[8] = Triangle(vec3[3](i.vertecies[6], i.vertecies[7], i.vertecies[10]));\n    tr[9] = Triangle(vec3[3](i.vertecies[8], i.vertecies[1], i.vertecies[7])); \n\n    tr[10] = Triangle(vec3[3](i.vertecies[4], i.vertecies[9], i.vertecies[3]));   \n    tr[11] = Triangle(vec3[3](i.vertecies[2], i.vertecies[4], i.vertecies[3])); \n    tr[12] = Triangle(vec3[3](i.vertecies[6], i.vertecies[2], i.vertecies[3]));\n    tr[13] = Triangle(vec3[3](i.vertecies[8], i.vertecies[6], i.vertecies[3]));\n    tr[14] = Triangle(vec3[3](i.vertecies[9], i.vertecies[8], i.vertecies[3]));\n\n    tr[15] = Triangle(vec3[3](i.vertecies[5], i.vertecies[9], i.vertecies[4])); \n    tr[16] = Triangle(vec3[3](i.vertecies[11], i.vertecies[4], i.vertecies[2])); \n    tr[17] = Triangle(vec3[3](i.vertecies[10], i.vertecies[2], i.vertecies[6]));\n    tr[18] = Triangle(vec3[3](i.vertecies[7], i.vertecies[6], i.vertecies[8]));\n    tr[19] = Triangle(vec3[3](i.vertecies[1], i.vertecies[8], i.vertecies[9]));\n    vec3 tmpN;\n    float t = INF;\n    for (int i = 0; i < tr.length(); i++) {\n        float triangleT = traceTriangle(pos, dir, tr[i], tmpN);\n        if (triangleT < t) {\n            t = triangleT;\n            N = tmpN;\n        }\n    }\n    return t;\n}\n\nfloat traceCylinder(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    const float h = -0.8; // height modifier to touch icosahedron\n    float t = (h - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = pos + t * dir;\n    if (dot(worldPos.xz, worldPos.xz) < r * r) {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float b = dot(pos.xz, dir.xz);\n    float D = b * b - (dot(pos.xz, pos.xz) - r * r) * dot(dir.xz, dir.xz);\n    if (D < 0.0) {\n        return INF;\n    }\n    t = (-b - sqrt(D)) / dot(dir.xz, dir.xz);\n    worldPos = pos + t * dir;\n    if (worldPos.y < h && worldPos.y >= -2.0) {\n        if (t >= 0.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    return INF;\n}\n\nfloat traceSphere(vec3 camPos, vec3 dir, Sphere s, out vec3 N) {\n    vec3 pos = camPos - s.pos;\n    float b = dot(pos, dir);\n    float D = b * b - dot(pos, pos) + s.radius * s.radius;\n    if (D < 0.0) return INF;\n    float t = -b - sqrt(D);\n    t = t < 0.0 ? -b + sqrt(D) : t;\n    if (t < 0.0) return INF;\n    N = normalize(pos + t * dir);\n    return t;\n}\n\nbool isOccluded(vec3 pos, Light light) {\n    vec3 dir = light.sphere.pos - pos + randDir * light.sphere.radius;\n    float dist = length(dir);\n    dir /= dist;\n    vec3 tmpN;\n    Material tmpM;\n    vec3 icoNorm;\n    float icoT = traceIco(pos, dir, ico, icoNorm);\n    return icoT < dist;\n}\n\nvec3 computeLight(vec3 pos, vec3 dir, vec3 N, Material m) {\n    vec3 lightPower = vec3(0);\n    vec3 spectralLight = vec3(0);\n    for (int i = 0; i < scene.lights.length(); i++) {\n        vec3 toLight = scene.lights[i].sphere.pos - pos;\n        float distSq = dot(toLight, toLight);\n        float att = isOccluded(pos, scene.lights[i]) ? 0.5 : scene.lights[i].intensity / distSq;\n        lightPower += max(0.0, dot(N, normalize(toLight))) * att * scene.lights[i].sphere.m.col;\n    }\n    lightPower += texture(iChannel1, N).rgb * 0.1;\n    return m.col * lightPower;\n}\n\nvec3 refraction(vec3 v, vec3 N, float n1, float n2) {\n    if (dot(v,N) < 0.0) N = -N;\n    float cosA = dot(v, N);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tg = normalize(v - cosA*N);\n    float sinB = sinA/n2 * n1;\n    if (sinB > 1.0)\n        return reflect(v,N);\n    float cosB = sqrt(1.0 - sinB*sinB);\n    return sinB * tg + cosB * N;\n}\n\nfloat fireSdf(vec3 pos, float r) {\n    return length(pos) - r/4.0;\n}\n\nfloat BeerLambert(float absorptionCoefficient, float distanceTraveled)\n{\n    return exp(-absorptionCoefficient * distanceTraveled);\n}\n\nvec4 sampleFire(vec3 pos, vec3 dir, float r){\n\n    float t = fireSdf(pos, r);\n    const float MARCH_SIZE = 0.01;\n    float opacity = 1.0;\n    float totalAbs = 0.0;\n    for (int i = 0; i < 50; ++i) {\n        vec3 curPos = pos + (float(i) * MARCH_SIZE + t) * dir;\n        float sdf = fireSdf(curPos, r);\n        if (sdf < -0.05 && sdf > -0.3) {\n            float prevOpacity = opacity;\n            opacity *= BeerLambert(ABSORPTION * (\n            texture(iChannel2, curPos).r +\n            texture(iChannel2, curPos *  3.0).r\n            )/2.0 * abs(sdf), MARCH_SIZE);\n            float absorptionLastStep = prevOpacity - opacity;\n            totalAbs += absorptionLastStep;\n        }\n    }\n    return vec4(FIRE_COLOR * 2.5 * totalAbs, 1.0 - opacity);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    //init\n    vec3 randV = vec3(rand(float(iFrame)), rand(float(iFrame +5)), rand(float(iFrame + 15)));\n    randDir = normalize(randV - 0.5);\n    Material light1_m = emissive;\n    light1_m.col = Light1_col;\n    Material light2_m = emissive;\n    light2_m.col = Light2_col;\n    Material light3_m = emissive;\n    light3_m.col = Light3_col;\n    Light light1 = Light(Sphere(Light1_pos, Light1_r, light1_m), Light1_int);\n    Light light2 = Light(Sphere(Light2_pos, Light2_r, light2_m), Light2_int);\n    Light light3 = Light(Sphere(Light3_pos, Light3_r, light3_m), Light3_int);\n    Light lights[3] = Light[3](light1, light2, light3);\n         \n    scene.lights = lights;\n    scene.ico = ico;\n    scene.cyl = Cylinder(vec3(0,0,0), 0.75, diffusive);\n    \n    //calculate coord and viewVec\n    vec2 uv = (fragCoord - iResolution.xy * 0.5 + (randV.xy - 0.5) * 2.0)/iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0,1,0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right * uv.x + up* uv.y);\n    \n    //trace\n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    float n1 = AIR_N;\n        float n2 = AIR_N;\n    vec3 col = vec3(0);\n    bool b = false;\n    \n    for (int j = 0; j < 10; j++) {\n        float t = INF;\n        bool intersect;\n        vec3 N;\n        vec3 tmpN;\n        \n        Material material;\n        \n        //lights\n        for (int i = 0; i < lights.length(); i++) {\n            float lightT = traceSphere(curPos, curDir, lights[i].sphere, tmpN);\n            if (lightT < t) {\n                t = lightT;\n                N = tmpN;\n                material = lights[i].sphere.m;\n                col = lights[i].sphere.m.col;\n            }\n        }\n        \n        //trace icosahedron\n        float icoT = traceIco(curPos + randV*0.01, curDir, scene.ico, tmpN);\n        if (icoT < t) {\n            t = icoT;\n            N = tmpN;\n            if (randV.x < 0.45) material = reflective;\n              else material = scene.ico.m;\n            //material = scene.ico.m;\n        }\n        \n        //trace cylinder\n        vec3 worldPos = t * curDir + curPos;\n        float cylT = traceCylinder(curPos, curDir, scene.cyl.radius, tmpN);\n        if (cylT < t) {\n            t = cylT;\n            N = tmpN;\n            worldPos = t * curDir + curPos;\n            material = scene.cyl.m;\n            material.col = texture(iChannel3, worldPos.xz).rgb * blue_tint;\n        }\n        \n        //trace plane\n        float planeT = tracePlane((curPos) + randV*0.02, curDir, tmpN);\n        if (planeT < t) {\n            t = planeT;\n            N = tmpN;\n            worldPos = t * curDir + curPos;\n            material = diffusive;\n            material.col = texture(iChannel0, worldPos.xz * 0.1).rgb * blue_tint;\n        }\n        \n        //color\n        bool isEmissive = bool(material.emission);\n        bool isDiffusive = bool(material.diffusion);\n        bool isReflective = bool(material.reflection);\n        bool isRefractive = bool(material.refraction);\n        if (isReflective) {\n            n1 = n2;\n            n2 = material.n;\n        }\n        float R = powf((n1-n2)/(n1+n2), 2);\n        bool reflAndRefr = isReflective && isRefractive;\n        isReflective = (randV.x < R) || (!isRefractive && isReflective);\n        isRefractive = (reflAndRefr && !isReflective) || (!reflAndRefr && isRefractive);\n        \n        if (isEmissive) {\n            col +=  material.col * material.emission * k;\n        }\n        else if (isDiffusive) {\n            col += computeLight(worldPos, curDir, N, material) * material.diffusion * k;\n        }\n        if (isReflective) {\n            curDir = reflect(curDir,N);\n            curPos = worldPos + curDir / INF;\n        }\n        if (isRefractive) {\n            curDir = refraction(curDir, N, n1, n2);\n            curPos = worldPos + curDir / INF;\n            if (b == false) {\n                float mult = 2.0;\n                    vec4 fog = sampleFire(curPos, curDir, 2.8);\n                    col += fog.rgb * fog.a * mult;\n                    fog = sampleFire(curPos, curDir, 1.4);\n                    col += fog.rgb * fog.a * mult;\n                    mult *= 1.0 + fog.a;\n                    \n                    float tmp = n1;\n                    n1 = n2;\n                    n2 = tmp;\n                    b = true;\n            }\n        }\n\n        if (t == INF) {\n            col += k * 2.0 * texture(iChannel1, curDir).rgb * blue_tint;\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n             \n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}