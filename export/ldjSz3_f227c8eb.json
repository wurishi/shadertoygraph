{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"const float PI=3.14159265;\n\n// ==== Brick flooring parameters ==============================\n// The width and height of a brick/mortar in [0,1] image space\n#define BRICKWIDTH 2.0\n#define BRICKHEIGHT 1.28\n#define MORTARTHICKNESS 0.16\n\n// Describes the width and height of a single brick 'feature' in image space.\n// A 'brick feature' is define as rectangle following:\n//    - Horizontally: mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKWIDTH + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKWIDTH + 0.5 * MORTARTHICKNESS, BRICKWIDTH + MORTARTHICKNESS]\n//    - Vertically  : mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKHEIGHT + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKHEIGHT + 0.5 * MORTARTHICKNESS, BRICKHEIGHT + MORTARTHICKNESS]\n#define BMWIDTH (BRICKWIDTH + MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT + MORTARTHICKNESS)\n\n// Describes the relative mortar boundary in normalized 'break feature' space [0,1]\n#define MWF (MORTARTHICKNESS * 0.5 / BMWIDTH)\n#define MHF (MORTARTHICKNESS * 0.5 / BMHEIGHT)\n// ============================================================\n\n// ==== Star on box parameters ================================\nconst vec3 starColor = vec3(1.0, 0.78, 0.05);\nconst vec3 starBG = vec3(0.0, 0.0, 1.0);\n\nconst float RMIN = 0.2; // Inner radius of the star, in uv space.\nconst float RMAX = 0.4; // Outer radius of the star, in uv space.\nconst float NUMBER_OF_STARTPOINTS = 5.0; // Number of star points; Should be integer!\n\n// Angle between 2 star points, in [rad]:\nconst float STAR_ANGLE = 2.0*PI / NUMBER_OF_STARTPOINTS; \nconst float HALF_STAR_ANGLE = 0.5 * STAR_ANGLE;\n\nconst vec2 starCentre = vec2(0.5,0.5); // @middle of the screen\nconst vec3 starCentre3D = vec3(starCentre, 0.0);\n\n// Real world size, dimensions and location of the box with the procedurally\n// generated star texture:\nconst float starImageSize = 2.0; \nconst vec3 boxDimensions = vec3(starImageSize, starImageSize, starImageSize);\nconst vec3 boxLocation = vec3(-25.0, -3.0, 0.0);\n// =============================================================\n\n// ==== Marble sphere parameters ===============================\nconst float MARBLE_SPLINE_SIZE = 13.0;\nconst vec3 PALE_BLUE = vec3(0.25, 0.25, 0.35);\nconst vec3 MEDIUM_BLUE = vec3(0.10, 0.10, 0.30);\nconst vec3 DARK_BLUE = vec3(0.05, 0.05, 0.26);\nconst vec3 DARKER_BLUE = vec3(0.03, 0.03, 0.20);\n\n// Real world size, dimensions and location of the blue marble sphere:\nconst float sphereSize = 3.0;\nconst vec3 sphereLocation = vec3(-10.0, -2.0, 5.0);\n\n// =============================================================\n\n/**\n * Lookup table for marble colors. Workaround as GLSL does not support arrays.\n * @param i: Array index; Should be integer.\n * @return The color at the given index.\n */\nvec3 GetMarbleColor(float i){\n\tif(i == 0.0 || i == 1.0){\n\t\treturn PALE_BLUE;\n\t}\n    else if(i == 2.0 || i == 2.0 || i == 3.0){\n\t\treturn MEDIUM_BLUE;\n\t}\n\telse if(i == 4.0 || i == 5.0){\n\t\treturn PALE_BLUE;\n\t}\n\telse if(i == 6.0 || i == 7.0){\n\t\treturn DARK_BLUE;\n    }\n\telse if(i == 8.0 || i == 9.0){\n\t\treturn DARKER_BLUE;\n\t}\n\telse if (i == 10.0){\n        return PALE_BLUE;\n\t}\n\telse if (i == 11.0){\n\t\treturn DARKER_BLUE;\n\t}\n\n\treturn vec3(1.0, 1.0, 1.0); // should never get here.\n}\n\n/**\n * Perform Catmull-Rom spline interpolation between support points v1 and v2.\n * @param x: Interpolation factor between v1 and v2; Range[0.0,1.0]\n * @param v0: left most control point.\n * @param v1: left support point.\n * @param v2: right support point.\n * @param v3: right most control point.\n * @return The interpolated value.\n */\nvec3 CatmullRomSpline(float x, vec3 v0, vec3 v1, vec3 v2, vec3 v3) \n{\n    // Note: this spline will go through it's support points.\n\tvec3 c2 = -.5 * v0\t\t\t\t+ 0.5 *v2;\n\tvec3 c3 = \t\tv0\t+ -2.5*v1 \t+ 2.0 *v2 + -.5*v3;\n\tvec3 c4 = -.5 * v0\t+ 1.5 *v1 \t+ -1.5*v2 + 0.5*v3;\n\treturn(((c4 * x + c3) * x + c2) * x + v1);\n}\n\n/**\n * Evaluates the rainbox texture in UV-space using a Catmull-Rom spline.\n */\nvec3 EvaluateMarbleSpline(float x){\n    // x must be made in range [0.0,MARBLE_SPLINE_SIZE]\n    float scaledX = clamp(x, 0.0, 1.0) * MARBLE_SPLINE_SIZE;\n    \n    // Determine which 'rainbox segment' we are evluating:\n    float segmentIndex = floor(scaledX);\n    \n    // Note that you evaluate between v1 and v2, using v0 and v3 as control points:\n    vec3 v0 = GetMarbleColor(segmentIndex-1.0);\n    vec3 v1 = GetMarbleColor(segmentIndex+0.0);\n    vec3 v2 = GetMarbleColor(segmentIndex+1.0);\n    vec3 v3 = GetMarbleColor(segmentIndex+2.0);\n    \n    return CatmullRomSpline(fract(scaledX), v0,v1,v2,v3);\n}\n\n/**\n * Creates a hashkey based on a 3D variable.\n * Note: Using haskeys directly as noise function gives non-coherent noise.\n * @return: Haskey in range [0.0, 1.0)\n */\nfloat hash(in vec3 p){\n    // Transform 3D parameter into a 1D value:\n    // Note: higher value means 'higher frequency' when plugging uv coordinates.\n    float h = dot(p, vec3(123.45, 678.91, 234.56));\n    \n    // Use a sinusoid function to create both positive and negative numbers.\n    // Multiply by a big enough number and then taking only the fractional part creates a pseudo-random value.\n    return fract(cos(h)*12345.6789);\n}\n\n/**\n * Create a coherent noise using the perline noise algorithm. Haskeys are\n * used to remove the need of an array of random values.\n * @return: noise value in the range[0.0, 1.0)\n */\nfloat perlinNoise( in vec3 p )\n{\n    // see: http://webstaff.itn.liu.se/~stegu/TNM022-2005/perlinnoiselinks/perlin-noise-math-faq.html#whatsnoise\n    vec3 i = floor(p); // Use hashing with this to fake a gridbased value noise.\n    vec3 f = fract(p);\n\t\n    // Using this 'ease curve' generates more visually pleasing noise then without.\n    // Function describes a function similar to a smoothstep.\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    float dx1 = mix(hash(i + vec3(0.0,0.0,0.0)), \n                    hash(i + vec3(1.0,0.0,0.0)), u.x);\n    float dx2 = mix(hash(i + vec3(0.0,1.0,0.0)), \n                    hash(i + vec3(1.0,1.0,0.0)), u.x);\n    float dy1 = mix(dx1, dx2, u.y);\n    \n    float dx3 = mix(hash(i + vec3(0.0,0.0,1.0)), \n                    hash(i + vec3(1.0,0.0,1.0)), u.x);\n    float dx4 = mix(hash(i + vec3(0.0,1.0,1.0)), \n                    hash(i + vec3(1.0,1.0,1.0)), u.x);\n    float dy2 = mix(dx3, dx4, u.y);\n    \n    return mix(dy1, dy2, u.z);\n}\n\n/**\n * Performs a fractal sum of the same noise function for different 'frequencies'.\n * @return: noise value in the range [0.0, ~1.94/2)\n */\nfloat fractalSumNoise(in vec3 p){\n    float value = 0.0;\n    \n    float f = 1.0;\n    \n    // Experimentation yielded 5 itterations gave optimal results. Less itterations gave too\n    // blotchy result, and more itterations did no longer have any significant visual impact.\n    for (int i = 0; i < 5; i++){\n        value += perlinNoise(p * f)/f;\n        f = f * 2.0;\n    }\n    \n    return value/2.0;\n}\n\n/**\n * Generate a signed variant of fractalSumNoise.\n * @return: noise value in the range [-1.0, ~0.94)\n */\nfloat signedFractalSumNoise(in vec3 p){\n    return 2.0 * fractalSumNoise(p) - 1.0;\n}\n\n/**\n * Distance function for a box.\n * @param p: worldspace position vector [x,y,z]\n * @param dimensions: worldspace dimensions of the box from its centre.\n * @return: The worldspace distance from the box\n * REMARKS: This function does not properly deal with distance inside a box!\n */\nfloat udBox(vec3 p, vec3 dimensions )\n{\n  return length(max(abs(p)-dimensions,0.0));\n}\n\n/**\n * Distance function for a sphere.\n * @param p: worldspace position vector [x,y,z]\n * @param s: worldspace size of the sphere\n * @return The worldspace distance from the sphere\n */\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n/**\n * Distance function for the marble sphere.\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 obj_sphere(in vec3 p){\n\tvec3 displacedP = p - sphereLocation;\n\treturn vec2(sdSphere(displacedP, sphereSize), 2);\n}\n\n/**\n * Distance function for the star-box.\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 obj_box(in vec3 p){\n    vec3 displacedP = p - boxLocation;\n    return vec2(udBox(displacedP, boxDimensions), 1);\n}\n\n/**\n * Distance function for the floor at y == -5 (World space).\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 obj_floor(in vec3 p)\n{\n  return vec2(p.y+5.0,0);\n}\n\n/**\n * Performs a union of two distance functions with material index information.\n * @param obj0: Return result of some distance function that follows the pattern\n *              [distance, material definition index]\n * @param obj1: Return results of a different distance function that also follows\n *              the pattern [distance, material definition index]\n * @return: The union of these two results (basically returning the nearest result)\n * REMARK: This method does not properly deal with transparent objects!\n */\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  if (obj0.x < obj1.x)\n  \treturn obj0;\n  else\n  \treturn obj1;\n}\n\n/**\n * General distance function used in the shader.\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 distance_to_obj(in vec3 p)\n{\n    return obj_union(obj_union(obj_floor(p), obj_box(p)), obj_sphere(p));\n}\n\n/**\n * Map the given location to the 'brick feature' space of the floor.\n * @param p: worldspace position vector [x,y,z]\n * @return: Return the feature space coordinates, range [0,1].\n */\nvec2 getBrickFeatureCoordinate(in vec3 p){\n    vec2 textureCoordinates = p.xz / vec2(BMWIDTH, BMHEIGHT);\n    \n    if (mod(textureCoordinates.y * 0.5, 1.0) > 0.5)\n    {\n        textureCoordinates.x += 0.5;\n    }\n    \n    float xBrick = floor(textureCoordinates.x);\n    textureCoordinates.x -= xBrick;\n    float yBrick = floor(textureCoordinates.y);\n    textureCoordinates.y -= yBrick;\n    \n    return textureCoordinates;\n}\n\n/**\n * Determine the color of the brick floor.\n * @param p: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 floor_color(in vec3 p)\n{\n    // Material color information:\n    vec4 brickColor = vec4(0.5, 0.15, 0.14, 1.0); // RGBA\n    vec4 mortarColor = vec4(0.5, 0.5, 0.5, 1.0); // RGBA\n    \n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    // Step functions describing when inside brick and when inside mortar:\n    float widthIndex = step(MWF, textureCoordinates.x) - step(1.0-MWF, textureCoordinates.x);\n    float heightIndex = step(MHF, textureCoordinates.y) - step(1.0-MHF, textureCoordinates.y);\n    \n    // Decide color for mortar or brick.\n    // widthIndex * heightIndex is basically AND-ing if inside width/height of a brick.\n    return mix(mortarColor.rgb, brickColor.rgb, widthIndex*heightIndex);\n}\n\n/**\n * Creates a 3D texture coordinate with respect to the centre of the star\n * in the XY plane z==0.0\n * @param r: Radius in texture coordinate space\n * @param angle: Angle in [rad], with respect to the top of the star.\n * @return: A 3D texture coordinate point\n */\nvec3 Get3DStarPointFromAngular(float r, float angle){\n    return starCentre3D + r * vec3(sin(angle), \n\t                               cos(angle), \n\t\t\t\t\t\t\t\t   0.0);\n}\n\n/**\n * Returns the color for the given location for the Cube with a star.\n * @param p: worldspace position vector [x,y,z]\n * @return: RGB color at that point\n */\nvec3 cube_color(in vec3 p)\n{\n    // Cube plane in YZ plane in range [boxLocation.ZY - starImageSize, boxLocation.ZY + starImageSize].\n    // Z is horizontal axis, Y is vertical axis.\n    // Map this range to [0, 1]:\n    vec2 uv = clamp((p.zy - boxLocation.zy + starImageSize)/ (2.0 * starImageSize), 0.0, 1.0);\n\n    // p0: Top of the star.\n    // p1: First clockwise notch of the star.\n    vec3 p0 = Get3DStarPointFromAngular(RMAX, 0.0);\n    vec3 p1 = Get3DStarPointFromAngular(RMIN, HALF_STAR_ANGLE);\n\t\n    vec3 edgeP0P1 = p1-p0; // Vector p0->p1\n    \n\t// Because the star is a rotational symmetric shape, mapping the uv \n\t// texture coordinates to polar coordinate system makes it easier\n\t// to define a feature space that makes up a star point.\n\t// \n    // Get angle and radius of uv point:\n    // Note: Angle is w.r.t edge starCentre->p0\n    vec2 uvWithRespectTostarCentre = uv - starCentre;\n\t// Angle w.r.t. edge starCentre->p0, in [rad: -PI, PI]\n    float angle = atan(uvWithRespectTostarCentre.x, uvWithRespectTostarCentre.y);\n    float r = length(uvWithRespectTostarCentre);\n    \n    // Map angle to feature space of 0 to STAR_ANGLE * 0.5, using mirroring \n\t// as it's a symmetric triangle around HALF_STAR_ANGLE.\n    float a = mod(angle, STAR_ANGLE);\n    if(a >= HALF_STAR_ANGLE){\n        a = STAR_ANGLE - a; // mirror\n    }\n    // a now in range [0, 0.5] * STAR_ANGLE\n    \n\t// uv mapped into the feature space as pUV\n\tvec3 pUV = Get3DStarPointFromAngular(r, a);\n    vec3 edgep0pUV = pUV - p0; // Vector p0->pUV\n    \n    // Determine if puv is inside the star or not, using corss product.\n    // Cross product yields negative z when inside star and positive z when outside star.\n    float in_out = step(0.0, cross(edgeP0P1, edgep0pUV).z);\n    return mix(starColor, starBG, in_out);\n}\n\n/**\n * Returns the color for the given location for the marble sphere.\n * @param p: worldspace position vector [x,y,z]\n * @return: RGB color at that point\n */\nvec3 sphere_color(in vec3 p){\n\tfloat noiseValue = signedFractalSumNoise(p) + 0.22; // Personally I like this configuration :)\n    //float noiseValue = 1.2*fractalSumNoise(p) - 0.40;\n\treturn EvaluateMarbleSpline(noiseValue);\n}\n\n/**\n * Determine the base surface color for the given location and material id.\n * @param materialIndex: The material identifier.\n * @param position: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 GetMaterialColor(float materialIndex, in vec3 position){\n\tif (materialIndex == 0.0){\n\t\treturn floor_color(position);\n\t}\n    else if (materialIndex == 1.0){\n        return cube_color(position);\n    }\n\telse if (materialIndex == 2.0){\n\t\treturn sphere_color(position);\n\t}\n\treturn vec3(0,0,0);\n}\n\n/**\n * Calculated the bump height at the given location for the brick surface.\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The bump height at the given location, in range [0,1]\n */\nfloat calculateBumpHeight(in vec3 p){\n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    float hu, hv;\n    \n    hu = smoothstep(0.0, MWF, textureCoordinates.x) - smoothstep(1.0-MWF, 1.0, textureCoordinates.x);\n    hv = smoothstep(0.0, MWF, textureCoordinates.y) - smoothstep(1.0-MWF, 1.0, textureCoordinates.y);\n    \n    return hu*hv;\n}\n\n/**\n * Determine normal using dFdx and dFdy, as presented in \"Texturing & Modelling: A Procedural Approach 3rd ed.\"\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 calculateNormal(in vec3 p){\n    // Note: You could use facefoward instead of having to multiply dFdy with -1.0.\n    //       This however does increase the required parameters for this method.\n    \n    // Accuracy note: Estimate derivative by comparing to value calculated in a neighboring pixel.\n    //                This can lead to a more coarse estimation than doing a custom derivative instead.\n \treturn cross(dFdx(p), -1.0*dFdy(p));   \n}\n\n/**\n * Performs bump mapping for the floor (Material index == 0).\n * @param p: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(p)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 floor_bumpmap(in vec3 p, in vec3 globalNormalVector, bool useCustomDerivative){\n    float heightScaling = 0.01;\n    float heightIncrement = calculateBumpHeight(p);\n    \n    if(useCustomDerivative)\n    {\n        float dhdx = heightScaling * (calculateBumpHeight(vec3(p.x + 0.02, p.y, p.z)) - heightIncrement);\n        float dhdz = heightScaling * (calculateBumpHeight(vec3(p.x, p.y, p.z + 0.02)) - heightIncrement);\n\n        vec3 vector_dhdx = vec3(0.02, dhdx, 0.0);\n        vec3 vector_dhdz = vec3(0.0, dhdz, -0.02);\n    \n    \treturn normalize(cross(vector_dhdx, vector_dhdz));\n    }\n    else\n    {\n        return normalize(calculateNormal(p + globalNormalVector * (heightIncrement*heightScaling)));\n    }\n}\n\n/**\n * Calculate the surface normal for the Box with the Star.\n * @param p: worldspace position vector [x,y,z]\n * @param globalNormalVector: Estimated normal vector prior bumpmapping\n * @return: The normal vector at the given location taking bumpmapping into account.\n */\nvec3 starBox_bumpmap(in vec3 p, in vec3 globalNormalVector){\n    // Cube plane in YZ plane in range [boxLocation.ZY - starImageSize, boxLocation.ZY + starImageSize].\n    // Z is horizontal axis, Y is vertical axis.\n    // Map this range to [0, 1]:\n    vec2 uv = clamp((p.zy - boxLocation.zy + starImageSize)/ (2.0 * starImageSize), 0.0, 1.0);\n\n    // p0: Top of the star.\n    // p1: First clockwise notch of the star.\n    vec3 p0 = Get3DStarPointFromAngular(RMAX, 0.0);\n    vec3 p1 = Get3DStarPointFromAngular(RMIN, HALF_STAR_ANGLE);\n\t\n    vec3 edgeP0P1 = p1-p0; // Vector p0->p1\n    \n\t// Because the star is a rotational symmetric shape, mapping the uv \n\t// texture coordinates to polar coordinate system makes it easier\n\t// to define a feature space that makes up a star point.\n\t// \n    // Get angle and radius of uv point:\n    // Note: Angle is w.r.t edge starCentre->p0\n    vec2 uvWithRespectTostarCentre = uv - starCentre;\n\t// Angle w.r.t. edge starCentre->p0, in [rad: -PI, PI]\n    float angle = atan(uvWithRespectTostarCentre.x, uvWithRespectTostarCentre.y);\n    float r = length(uvWithRespectTostarCentre);\n    \n    // Map angle to feature space of 0 to STAR_ANGLE * 0.5, using mirroring \n\t// as it's a symmetric triangle around HALF_STAR_ANGLE.\n    float a = mod(angle, STAR_ANGLE);\n    if(a >= HALF_STAR_ANGLE){\n        a = STAR_ANGLE - a; // mirror\n    }\n    // a now in range [0, 0.5] * STAR_ANGLE\n    \n\t// uv mapped into the feature space as pUV\n\tvec3 pUV = Get3DStarPointFromAngular(r, a);\n    vec3 edgep0pUV = pUV - p0; // Vector p0->pUV\n    \n    // Determine if puv is inside the star or not, using corss product.\n    // Cross product yields negative z when inside star and positive z when outside star.\n    float in_out = step(0.0, cross(edgeP0P1, edgep0pUV).z);\n    \n    // Bump normal map:\n    float orientationAngle = angle;\n    if(orientationAngle < 0.0){\n        orientationAngle += 2.0*PI;\n    }\n    float starSectionIndex = floor(orientationAngle / HALF_STAR_ANGLE);\n\t\n    float rPn1, rPn2;\n    if (1.0 == mod(starSectionIndex, 2.0)){\n        // odd section (first clockwise is odd)\n        rPn1 = RMIN;\n        rPn2 = RMAX;\n    }\n    else {\n        // even section (second clockwise is even)\n        rPn1 = RMAX;\n        rPn2 = RMIN;\n    }\n\t\n\t// The section's face is described by the following three vertices in order:\n\tvec3 pnsc = vec3(starCentre, 0.8);\n\tvec3 pn1 = Get3DStarPointFromAngular(rPn1, (starSectionIndex + 1.0) * HALF_STAR_ANGLE);\n\tvec3 pn2 = Get3DStarPointFromAngular(rPn2, starSectionIndex * HALF_STAR_ANGLE);\n    \n\t// Find the normal using the normalized cross-product of the edge vectors.\n\t// See: http://www.opengl.org/wiki/Calculating_a_Surface_Normal\n    // Swizzle coordinates to map them back into real world:\n    vec3 vPnscPn1 = pn1.zyx - pnsc.zyx;\n    vec3 vPnscPn2 = pn2.zyx - pnsc.zyx;\n    \n    vec3 normalVector = normalize(globalNormalVector + cross(vPnscPn1, vPnscPn2));\n    \n    return mix(normalVector, globalNormalVector, in_out);\n}\n\n/**\n * Checks for bump map modifications to the given normal vector at the given location.\n * @param materialIndex: Index of the material (Produced by distance_to_obj)\n * @param position: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(position)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal, taking bump mapping into account.\n */\nvec3 EvaluateBumpMap(float materialIndex, in vec3 position, in vec3 globalNormalVector, bool useCustomDerivative){\n    if (materialIndex == 0.0){\n        return floor_bumpmap(position, globalNormalVector, useCustomDerivative);\n    }\n    if (materialIndex == 1.0){\n        return starBox_bumpmap(position, globalNormalVector);\n    }\n    return globalNormalVector;\n}\n\n/**\n * Estimates the surface normal of the distance field at a given position.\n * @param position: Final raymarched position.\n * @param originalDistance: distance from 'position' to the nearest object.\n * @return The unit normal vector.\n */\nvec3 EsitmateDistanceFieldNormal(in vec3 position, float originalDistance){\n\t// Note: Parameter 'originalDistance' can be removed be calling internally at loss of performance:\n\t//       float originalDistance = distance_to_obj(position);\n\t\n\t// Quick trick for generating small permutation of 'position'\n\tconst float derivativeDelta = 0.02;\n\tconst vec2 e = vec2(derivativeDelta,0); \n\t\n\t// Perform a discrete forward derivative:\n\tvec3 n = vec3(originalDistance - distance_to_obj(position - e.xyy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yxy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yyx).x);\n\t// Note: discrete central derivative could be used instead for more accuracy at cost of performace.\n\t\n\treturn normalize(n); // Normalization helps saving 3 divisions by 'derivativeDelta'\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized fragment coordinate in range [-0.5, 0.5]\n    vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n    \n    if(abs(vPos.x) < 0.001){\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n        return;\n    }\n\n\t// See the following URL for naming definitions:\n\t//   http://uploads.gamedev.net/monthly_03_2013/ccs-191720-0-04862100-1363766190.png\n    // Camera up vector, using positive y as 'up':\n    vec3 cameraUpVector = vec3(0,1,0);\n  \n    // Point where the camera is looking at:\n    vec3 cameraTarget = vec3(0,0,0);\n\n    // Map current clicked mouse position on radians [0, 2*PI] horizontally and [0, 0.5*PI) vertically:\n    // Note: 0.5 gives rendering problems if iMouse.Y == iResolution.y\n\t//       This is due to cameraViewDirection and cameraUpVector align perfectly, which causes the\n\t//       cross-product to yield 0. This prevents spanning the horizontal and vertical axis of the\n\t//       camera.\n    float mx = iMouse.x/iResolution.x * 2.0*PI;\n    float my = iMouse.y/iResolution.y * 0.49*PI; \n    \n    vec3 eyeWorldPosition = vec3(cos(my)*cos(mx),\n\t\t\t\t\t\t\t\t sin(my),\n\t\t\t\t\t\t\t\t cos(my)*sin(mx)) * 6.0;\n\n    // Camera setup.\n\t// 1. Get the unit vector for the central viewing direction of the camera:\n    vec3 cameraViewDirection = normalize(cameraTarget - eyeWorldPosition);\n\t\n\t// 2. Spanning the horizontal (u) and veritcal (v) unit vectors describing the camera view-plane axis:\n    vec3 u = normalize(cross(cameraUpVector, cameraViewDirection));\n    vec3 v = normalize(cross(cameraViewDirection, u));\n\t\n\t// 3. Determine the 'projection window' coordinate\n\t// 3.1 Determine the 'project window' center / the camera position:\n    vec3 cameraPosition = eyeWorldPosition + cameraViewDirection;\n\t// 3.2 Map vPos onto the 'project window', taking aspect ratio into account:\n    vec3 evaluatedCoordinate = cameraPosition +\n\t\t\t\t\t\t\t   vPos.x * u * iResolution.x/iResolution.y + // horizontal component\n\t\t\t\t\t\t\t   vPos.y * v; // vertical component\n    vec3 rayCastDirection = normalize(evaluatedCoordinate-eyeWorldPosition);\n\n    // Distance-aided ray marching\n    const float maxd = 100.0; //Max drawing distance from camera center\n    const float inverseMax = 1.0 / maxd;\n    \n    vec2 d = vec2(0.0, 0.0);\n    vec3 colorRGB, rayPosition, normal;\n\n    float rayDistanceTraveled = 1.0;\n    for(int i = 0; i < 256; i++) // maximum value affects horizon mapping/warping\n    {\n    \trayDistanceTraveled += d.x;\n    \trayPosition = eyeWorldPosition + rayCastDirection * rayDistanceTraveled;\n    \td = distance_to_obj(rayPosition);\n        \n        if ((abs(d.x) < .001) || (rayDistanceTraveled > maxd)) \n    \t\tbreak;\n  \t}\n  \n  \tif (rayDistanceTraveled < maxd)\n  \t{\n    \t// y is used to manage materials.\n\t\tcolorRGB = GetMaterialColor(d.y, rayPosition);\n    \n    \tnormal = EsitmateDistanceFieldNormal(rayPosition, d.x);\n      \n    \tnormal = EvaluateBumpMap(d.y, rayPosition, normal, vPos.x > 0.0);\n      \n\t\t// Rotating point light around [0,10,0]:\n\t\tconst float lightRadius = 20.0;\n\t\tvec3 lightPosition = vec3(sin(iTime)*lightRadius, 10.0, cos(iTime)*lightRadius);\n\t\t\n\t\t// Do simple phong lighting:\n    \tfloat b = clamp(dot(normal, normalize(eyeWorldPosition - rayPosition + lightPosition)),0.0,1.0);    \t\n    \tfragColor=vec4((b*colorRGB + pow(b,16.0)) * (1.0 - rayDistanceTraveled * inverseMax), 1.0);\n  \t}\n  \telse \n    \tfragColor=vec4(0,0,0,1); //background color\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ldjSz3","date":"1414530187","viewed":220,"name":"Floor, star-box and marble","username":"xilconic","description":"Continuation from https://www.shadertoy.com/view/ld2Szm by adding a sphere made out of marble. Uses spline logic from https://www.shadertoy.com/view/MdBXzG and noise patterns from https://www.shadertoy.com/view/ls2SRK.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching"],"hasliked":0,"parentid":"","parentname":""}}