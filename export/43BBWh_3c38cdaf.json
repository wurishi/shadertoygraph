{"ver":"0.1","info":{"id":"43BBWh","date":"1729356889","viewed":144,"name":"Voronoi - Shadetober24 #19","username":"franke333","description":"Day 19 of shadetober\n\nMight add some colors later on. But for now this is my todays entry.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["shadetober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    uv = uv - 0.5;\n    float size = 3./(sin(0.33*iTime)*0.5+1.0);\n    float thickness = .05;\n    float sizeMult = 1.8;\n    // Time varying pixel color\n    float dist = 1.;\n    vec3 color = vec3(1.);\n    while(thickness/size > 0.001){\n        vec3 dxy = voronoiDistance(uv*size);\n        dist = min(float(dxy.x > thickness),dist);\n        vec2 hashedCellOffset = hash(dxy.yz+17.5);\n        \n        thickness = thickness/sizeMult;\n        uv = (uv+hashedCellOffset)*sizeMult;\n        \n        float angle = atan(-uv.y,uv.x)+0.517*iTime;\n         \n        color = mix(vec3(cos(angle),sin(angle),1.0)*0.5+0.5,color,1./sizeMult);\n    }\n    \n    \n    // Output to screen\n    fragColor = vec4(vec3(dist)*color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"vec2 hash(vec2 p) {\n  return fract(\n      sin(vec2(dot(p, vec2(1.0, 57.0)), dot(p, vec2(53.0, 113.0)))));\n}\n\n// big thanks to https://iquilezles.org/articles/voronoilines/ for this lovely solution <3\nvec3 voronoiDistance( in vec2 x )\n{\n    vec2 p = vec2(floor( x ));\n    vec2 f = fract( x );\n\n    vec2 mb;\n    vec2 mr;\n    vec2 closest;\n\n    float res = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2(i, j);\n        vec2  r = vec2(b) + hash(p+b)-f;\n        float d = dot(r,r);\n\n        if( d < res )\n        {\n            res = d;\n            mr = r;\n            mb = b;\n            closest = hash(p+b)+b+x-f;\n        }\n    }\n\n    res = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 b = mb + vec2(i, j);\n        vec2  r = vec2(b) + hash(p+b) - f;\n        float d = dot(0.5*(mr+r), normalize(r-mr));\n        // fix by @shadertoyjiang\n        if(!((i==0)&&(j==0)))\n            res = min( res, d );\n    }\n\n    return vec3(res,closest);\n}","name":"Common","description":"","type":"common"}]}