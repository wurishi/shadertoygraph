{"ver":"0.1","info":{"id":"3ljfzd","date":"1655198340","viewed":128,"name":"manon pt","username":"manon_graphics_witch","description":"I wrote a simple path tracer that uses NEE, MIS, and Importance Sampling.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["pathtracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GAMMA_CORRECTION 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 color = texture(iChannel0, uv);\n    \n    \n    color.rgb /= color.a;\n    \n#if GAMMA_CORRECTION\n    float pwr = 1.0/2.2;\n    color.rgb = vec3(pow(color.r, pwr), pow(color.g, pwr), pow(color.b, pwr));\n#endif\n    \n    fragColor = vec4(color.rgb, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159264\n#define TAU (PI*2.)\n\n\n//http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/\nint genSeed(int seed) {\n\tseed = (seed ^ 61) ^ (seed >> 16);\n    seed *= 9;\n    seed = seed ^ (seed >> 4);\n    seed *= 0x27d4eb2d;\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\nfloat rand(inout int seed) {\n\tseed ^= (seed << 13);\n\tseed ^= (seed >> 17);\n\tseed ^= (seed << 5);\n    return float(uint(seed)) * 2.3283064370807974e-10;\n}\nvec2 rand2(inout int seed) {\n    float x = rand(seed);\n    float y = rand(seed);\n    return vec2(x, y);\n}\nmat4 rotY(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat4(\n        vec4(c,0,s,1),\n        vec4(0,1,0,1),\n        vec4(-s,0,c,1),\n        vec4(0,0,0,1)\n    );\n}\nmat4 rotX(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat4(\n        vec4(1,0,0,0),\n        vec4(0,c,-s,0),\n        vec4(0,s,c,0),\n        vec4(0,0,0,1)\n    );\n}\nmat4 rotZ(float r)\n{\n    float c = cos(r);\n    float s = sin(r);\n    return mat4(\n        vec4(c,s,0,0),\n        vec4(-s,c,0,0),\n        vec4(0,0,1,0),\n        vec4(0,0,0,1)\n    );\n}\nuint reverseuint(uint bits) {\n    bits = (bits << 16) | (bits >> 16);\n    bits = ((bits & 0x00ff00ffu) << 8) | ((bits & 0xff00ff00u) >> 8);\n    bits = ((bits & 0x0f0f0f0fu) << 4) | ((bits & 0xf0f0f0f0u) >> 4);\n    bits = ((bits & 0x33333333u) << 2) | ((bits & 0xccccccccu) >> 2);\n    bits = ((bits & 0x55555555u) << 1) | ((bits & 0xaaaaaaaau) >> 1);\n    return bits;   \n}\n\n//random direction cosine weighted\nvec3 randomDirectionCW(vec3 normal, vec2 rand)\n{\n  float xt = rand.x * 2.0 * PI;\n  float yt = sqrt(1.0 - rand.y);\n\n  float xs = cos(xt) * yt;\n  float ys = sqrt(rand.y);\n  float zs = sin(xt) * yt;\n\n  vec3 y = normal;\n  vec3 h = normal;\n\n  float ahx = abs(h.x);\n  float ahy = abs(h.y);\n  float ahz = abs(h.z);\n\n  if (ahx <= ahy && ahx <= ahz)\n    h.x = 1.0;\n  else if (ahy <= ahx && ahy <= ahz)\n    h.y = 1.0;\n  else\n    h.z = 1.0;\n\n  vec3 x = normalize(cross(h, y));\n  vec3 z = normalize(cross(x, y));\n\n  return (xs * x) + (ys * y) + (zs * z);\n}\nvec3 randomDirection(vec3 normal, vec2 rand)\n{\n  float xt = rand.x * 2.0 * PI;\n  float yt = sqrt(1.0 - rand.y * rand.y);\n\n  float xs = cos(xt) * yt;\n  float ys = rand.y;\n  float zs = sin(xt) * yt;\n\n  vec3 y = normal;\n  vec3 h = normal;\n\n  float ahx = abs(h.x);\n  float ahy = abs(h.y);\n  float ahz = abs(h.z);\n\n  if (ahx <= ahy && ahx <= ahz)\n    h.x = 1.0;\n  else if (ahy <= ahx && ahy <= ahz)\n    h.y = 1.0;\n  else\n    h.z = 1.0;\n\n  vec3 x = normalize(cross(h, y));\n  vec3 z = normalize(cross(x, y));\n\n  return (xs * x) + (ys * y) + (zs * z);\n}\n\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define VERY_SMOL 0.00001\n#define MAX_DIST 1000.0\n#define MOUSE_CONTROLS 0\n#define CONVERGE 1\n#define SPP 1\n#define MAX_DEPTH 32\n\n#define RAY_MARCH_STEPS 384\n\nconst float ray_march_step_mul = 0.9;\n\n#define PRIM_TYPE_UNDEFINED 0\n#define PRIM_TYPE_PLANE     1\n#define PRIM_TYPE_LIGHT     2\n#define PRIM_TYPE_SDF       3\n#define PRIM_TYPE_SPHERE    4\n\n#define USE_SEGMENT_TRACING 0\n#define USE_NEE 1\n#define USE_IMPORTANCE_SAMPLING 1\n#define USE_MOTION_BLUR 0\n\n\n#define GLOBAL_K 1.25\n#define LIPSCHITZ_GRID_SIZE 0.4\n\n#define PLANE_COUNT 6\nconst vec4 planes[PLANE_COUNT] = vec4[](\n    vec4(0, 1, 0, -2),    // bottom\n    vec4(0, -1, 0, -10),  // top\n    vec4(1, 0, 0, -10),   // left\n    vec4(-1, 0, 0, -10),  // right\n    vec4(0, 0, 1, -10),   // back\n    vec4(0, 0, -1, -10)   // from\n);\nconst vec3 plane_albedo[6] = vec3[](\n\tvec3(1.00, 1.00, 1.00),\n\tvec3(1.00, 1.00, 1.00),\n\tvec3(247, 168, 184) / 255.0,\n\tvec3(85, 205, 252) / 255.0,\n\tvec3(1.00, 1.00, 1.00),\n\tvec3(1.00, 1.00, 1.00)\n);\n\n\nstruct Light {\n    vec3 v0, v1, v2;\n    vec3 color;\n};\n#define LIGHT_COUNT 1\nLight lights[LIGHT_COUNT];\n\nconst float center_sphere_size = 0.8;\n\n\n\n//Tracing\n\n\nconst vec3 sdf_pos = vec3(0, 0, 0);\nconst vec3 aabb_min = vec3(-2.4) + sdf_pos;\nconst vec3 aabb_max = vec3(2.4) + sdf_pos;\nbool inside_sdf = false;\nfloat scene_time = 0.0;\n\nfloat small_sphere(vec3 p)\n{\n    vec3 c = vec3(0.25);\n    \n    vec3 q = mod(p + 0.5*c, c) - 0.5 * c;\n    return length(q) - 0.03;\n}\n\nfloat sdf(vec3 p)\n{\n  //vec3 q = abs(p) - vec3(1.);\n  //return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),0.);\n  //float s1 = length(p - vec3(0.0, 0.0f, -2.0)) - 1.0;\n  //float s2 = length(p - vec3(0.0, 0.0f, 2.0)) - 1.0;\n  //return min(s1, s2);\n    \n//  return length(p - vec3(0,1,0)) - 2.0;\n    \n\t\n  \n  \tvec3 q = (p - sdf_pos) * 0.5;\n  \tfloat d= 2.;\n  \tfloat time = scene_time * 2.0;\n  \tfloat dist = length(q) - 1.0 + (sin(d*q.x+time)*sin(d*q.y+time)*sin(d*q.z+time)) * 0.2;\n    \n    dist = max(-small_sphere(q), dist);\n    \n    if (inside_sdf) {\n        dist = -dist;\n    }\n    return dist;\n}\nvec3 calcGradient(vec3 pos)\n{\n    const vec3 v0 = vec3(1, 0, 0);\n    const vec3 v1 = vec3(0, 1, 0);\n    const vec3 v2 = vec3(0, 0, 1);\n    \n    vec3 a = vec3(\n        sdf(pos + v0 * VERY_SMOL),\n        sdf(pos + v1 * VERY_SMOL),\n        sdf(pos + v2 * VERY_SMOL));\n    vec3 b = vec3(\n        sdf(pos - v0 * VERY_SMOL),\n        sdf(pos - v1 * VERY_SMOL),\n        sdf(pos - v2 * VERY_SMOL));\n    return (a - b) / (2.0 * VERY_SMOL);    \n}\nvec2 sdfk(vec3 start, vec3 end, vec3 dir)\n{\n \tfloat dist = sdf(start);\n    vec3 gradient_start = calcGradient(start);\n    vec3 gradient_end = calcGradient(end);\n    \n    float fd_start = abs(dot(gradient_start, dir));\n    float fd_end = abs(dot(gradient_end, dir));\n    float lam = max(fd_start, fd_end);\n    \n    return vec2(lam, dist);\n}\nbool rayAABBIntersect(vec3 amin, vec3 amax, vec3 ro, vec3 rd, inout float io_t)\n{\n    \n    vec3 inv_d = 1.0 / rd;\n    vec3 t0s = (amin - ro) * inv_d;\n    vec3 t1s = (amax - ro) * inv_d;\n    \n    vec3 tsmaller = min(t0s, t1s);\n    vec3 tbigger  = max(t0s, t1s);\n    \n    float tmin = max(tsmaller.x, max(tsmaller.y, tsmaller.z));\n    float tmax = min(tbigger.x, min(tbigger.y, tbigger.z));\n    \n    bool hit = (tmin < tmax) && tmin < io_t;\n    if (hit) {\n        io_t = tmin;\n    }\n    return hit;\n}\n\nbool raySphereIntersect(vec3 ro, vec3 rd, vec3 so, float sr, inout float io_t)\n{\n    float a = dot(rd, rd);\n    vec3 diff = ro - so;\n    float b = 2.0 * dot(rd, diff);\n    float c = dot(diff, diff) - (sr * sr);\n    float d = b*b - 4.0*a*c;\n    if (d < 0.0)\n    {\n        return false;\n    }\n    float t = (-b - sqrt(d)) / (2.0 * a);\n               \n    if (t >= 0.0 && t < io_t)\n    {\n        io_t = t;\n        return true;\n    }\n    return false;\n}\nbool rayPlaneIntersect(vec4 plane, vec3 ro, vec3 rd, inout float io_t)\n{\n \tfloat denom = dot(plane.xyz, rd);\n    if (denom > -VERY_SMOL) return false;\n    \n    vec3 ray_to_plane = plane.xyz * plane.w - ro;\n    \n    float t = dot(ray_to_plane, plane.xyz) / denom;\n    \n    if (t < 0.0 || t >= io_t) return false;\n    \n    io_t = t;\n    return true;\n}\nbool rayTriangleIntersect(vec3 v0, vec3 v1, vec3 v2, vec3 ro, vec3 rd, inout float io_t)\n{\n    vec3 e0 = v1 - v0;\n    vec3 e1 = v2 - v0;\n    vec3 pvec = cross(rd, e1);\n    float det = dot(e0, pvec);\n    // ray and triangle are parallel if det is close to 0\n    //if (abs(det) < 0.0001) return false;\n\tif (det < VERY_SMOL) return false;\n    \n    float inv_det = 1.0f / det;\n\n    vec3 tvec = ro - v0;\n    float u = dot(tvec, pvec) * inv_det;\n    if (u < 0.0 || u > 1.0) return false;\n\n    vec3 qvec = cross(tvec, e0);\n    float v = dot(rd, qvec) * inv_det;\n    if (v < 0.0 || u + v > 1.0) return false;\n\n    float t = dot(e1, qvec) * inv_det;\n    if (t < 0.0 || t >= io_t) return false;\n\n    io_t = t;\n    return true;\n}\n#if !USE_SEGMENT_TRACING\nfloat rayMarch(vec3 ro, vec3 rd, float start, float max_dist)\n{\n    float aabb_io_t = max_dist;\n    if (!rayAABBIntersect(aabb_min, aabb_max, ro, rd, aabb_io_t))\n    {\n        return max_dist;\n    }\n    \n    float t = start;\n    for (int i = 0; i < RAY_MARCH_STEPS; ++i)\n    {\n        float d = sdf(ro + rd * t);\n        if (d < VERY_SMOL)\n            return t;\n        t += d * ray_march_step_mul;\n        if (t >= max_dist) return max_dist;\n    }\n    return -t;\n}\n#else\nfloat rayMarch(vec3 ro, vec3 rd, float start, float max_dist) {\n    float aabb_io_t = max_dist;\n    if (!rayAABBIntersect(aabb_min, aabb_max, ro, rd, aabb_io_t))\n    {\n        return max_dist;\n    }\n    \n    \n    float t = start;\n    float c = 1.5;\n    float ts = (max_dist - start);\n    ts = min(ts, LIPSCHITZ_GRID_SIZE);\n    for (int i = 0; i < RAY_MARCH_STEPS; ++i)\n    {\n        vec3 pt = ro + rd * t;\n        vec3 pts = ro + rd * (t + ts);\n        vec2 data = sdfk(pt, pts, rd);\n        float dist = data.y;\n        if (dist < VERY_SMOL)\n        {\n            return t;\n        }\n        \n        float k = data.x;\n        float tk = abs(dist) / max(k, 0.01);\n        tk = max(abs(dist) / GLOBAL_K, min(tk, ts));\n        ts = tk;\n        if (tk >= 0.0)\n        {\n            t += max(tk, VERY_SMOL);\n        }\n        ts = tk * c;\n        ts = min(ts, LIPSCHITZ_GRID_SIZE);\n        if (t > max_dist)\n        {\n         \tbreak;   \n        }\n    }\n    //return max_dist;\n    return -1.0;\n}\n#endif\nvec3 getRayMarchNorm(vec3 p) {\n    return normalize(vec3(\n    \tsdf(vec3(p.x + VERY_SMOL, p.y, p.z)) - sdf(vec3(p.x - VERY_SMOL, p.y, p.z)),\n    \tsdf(vec3(p.x, p.y + VERY_SMOL, p.z)) - sdf(vec3(p.x, p.y - VERY_SMOL, p.z)),\n    \tsdf(vec3(p.x, p.y, p.z + VERY_SMOL)) - sdf(vec3(p.x, p.y, p.z - VERY_SMOL))\n    ));\n}\n\nbool raySceneIntersect(\n    vec3 ro,\n    vec3 rd,\n    inout float io_t,\n    out vec3 norm,\n\tout vec3 albedo,\n\tout int type)\n{\n\tbool hit = false;\n    \n    if (!inside_sdf)\n    {\n        for (int i = 0; i < LIGHT_COUNT; ++i)\n        {\n            vec3 v0 = lights[i].v0;\n            vec3 v1 = lights[i].v1;\n            vec3 v2 = lights[i].v2;\n            if (rayTriangleIntersect(v0, v1, v2, ro, rd, io_t))\n            {\n                norm = normalize(cross(v1-v0, v2-v0));\n                albedo = lights[i].color;\n                hit = true;\n                type = PRIM_TYPE_LIGHT;\n            }\n        }\n\n        for (int i = 0; i < PLANE_COUNT; ++i)\n        {\n            if (rayPlaneIntersect(planes[i], ro, rd, io_t))\n            {\n                norm = planes[i].xyz;\n                albedo = plane_albedo[i];\n                hit = true;\n                type = PRIM_TYPE_PLANE;\n            }\n        }\n    }\n    else\n    {\n\t\tif (raySphereIntersect(ro, rd, sdf_pos, center_sphere_size, io_t))\n        {\n            vec3 ip = ro + rd * io_t;\n            norm = normalize(ip - sdf_pos);\n            albedo = vec3(1, 1, 0.3);\n            hit = true;\n            type = PRIM_TYPE_SPHERE;\n        }\n    }\n    \n    \n    float rmt = rayMarch(ro, rd, 0.0f, io_t);\n    if (rmt < io_t && rmt >= 0.0)\n    {\n        io_t = rmt;\n        vec3 ip = ro + rd * io_t;\n        norm = getRayMarchNorm(ip);\n        albedo = vec3(1, 0.5, 1);\n        hit = true;\n        type = PRIM_TYPE_SDF;\n    }\n\n    \n    return hit;\n}\n\n\nbool shadowRaySceneIntersect(\n    vec3 ro,\n    vec3 rd,\n    float max_dist)\n{    \n    float io_t = max_dist;\n    \n    if (!inside_sdf)\n    {\n        for (int i = 0; i < LIGHT_COUNT; ++i)\n        {\n            vec3 v0 = lights[0].v0;\n            vec3 v1 = lights[0].v1;\n            vec3 v2 = lights[0].v2;\n            if (rayTriangleIntersect(v0, v1, v2, ro, rd, io_t))\n            {\n                return true;\n            }\n        }\n\n        for (int i = 0; i < PLANE_COUNT; ++i)\n        {\n            if (rayPlaneIntersect(planes[i], ro, rd, io_t))\n            {\n                return true;\n            }\n        }\n    }\n    else\n    {\n        if (raySphereIntersect(ro, rd, sdf_pos, center_sphere_size, io_t))\n        {\n            return true;\n        }\n    }\n    \n    float rmt = rayMarch(ro, rd, 0.0f, io_t);\n    if (rmt < io_t && rmt >= 0.0)\n    {\n        return true;\n    }\n    \n\n    \n    return false;\n}\nfloat schlick(float n1, float n2, vec3 surface_normal, vec3 view_normal)\n{\n  float r0 = (n1 - n2) / (n1 + n2);\n  r0 = r0 * r0;\n\n  float fresnel = r0 + (1.0 - r0) * pow(1.0 - dot(surface_normal, view_normal), 5.0);\n  return clamp(fresnel, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 scrpos = uv * 2. - 1.;\n    float aspect_ratio = iResolution.x / iResolution.y;\n\n      #if CONVERGE\n    float base_time = 0.0;\n  #else\n    float base_time = iTime;\n  #endif\n    \n    \n//    roughness = iMouse.x / iResolution.x;    \n  #if MOUSE_CONTROLS\n    mat4 view_mat =  rotY(-iMouse.x / iResolution.x * 2. * TAU) * rotX((iMouse.y / iResolution.y - PI) * 2. * TAU);\n  #else\n    mat4 view_mat =  rotY(base_time*.1 * TAU) * rotX(-.1 * TAU);  \n  #endif\n    \n    int seed = genSeed(int(fragCoord.x + fragCoord.y * iResolution.x) + genSeed(int(iTime * 1000.0)));\n    vec3 cam_pos = (view_mat * vec4(0.0, 0.0, -5.0, 1.0)).xyz;\n    \n    \n    \n\n    float t = 0.0;\n    mat4 ry = rotY(t);\n    vec3 lp = vec3(sin(t*2.0*PI), 0, cos(t*2.0*PI)) * 3.0;\n    lights[0].v0 =  lp + (ry * vec4(-2, 10, -2, 1)).xyz;\n    lights[0].v1 =  lp + (ry * vec4(2, 10, -2, 1)).xyz;\n    lights[0].v2 =  lp + (ry * vec4(0, 9, 2, 1)).xyz;\n    lights[0].color = vec3(8);\n    \n    \n    vec3 color = vec3(0.0);\n    for (int spp = 0; spp < SPP; ++spp)\n    {\n      #if USE_MOTION_BLUR\n        #if CONVERGE\n        \tfloat blur_factor = 0.166666;\n        #else\n        \tfloat blur_factor = iTimeDelta;        \n        #endif\n        float motion_blur = rand(seed) * blur_factor;\n      #else\n        float motion_blur = 0.0f;\n      #endif\n        \n        scene_time = base_time + motion_blur;\n        vec2 camera_random = rand2(seed) * 2.0 - vec2(1.0);\n        vec3 ro = cam_pos;        \n        vec3 rd = (view_mat * vec4(normalize(vec3(\n            scrpos.x * aspect_ratio + (camera_random.x / iResolution.x),\n            scrpos.y + (camera_random.x / iResolution.y),\n            1.0)), 0.0)).xyz;\n        vec3 throughput = vec3(1.0);\n\t\tbool last_specular = true;\n        inside_sdf = false;\n        \n        for (int depth = 0; depth < MAX_DEPTH; ++depth)\n        {\n            float t = MAX_DIST;\n            vec3 n, albedo;\n            int prim_type;\n            bool hit = raySceneIntersect(ro, rd, t, n, albedo, prim_type);\n            vec3 ip = ro + rd * t;\n            \n            if (!hit) //miss\n            {\n                break;\n            }\n            else if (prim_type == PRIM_TYPE_LIGHT)\n            {\n              #if USE_NEE\n                if (last_specular)\n              #endif\n                {\n                \tcolor += throughput * albedo;\n                }\n                break;\n            }\n            else if (prim_type == PRIM_TYPE_SDF) {\n              \tbool going_in = dot(n, rd) < 0.0;\n                if (!going_in) n = -n;\n                \n              \tfloat n1 = 1.0;\n              \tfloat n2 = 1.51;\n                if (!going_in) {\n                    float t = n1;\n                    n1 = n2;\n                    n2 = t;\n                }\n\n\t            float fresnel = schlick(n1, n2, n, -rd);\n\n              \tfloat random = rand(seed);\n              \tif (random < fresnel)\n              \t{\n                    // refl\n\t                rd = normalize(reflect(rd, n));\n    \t            ro = ip + n * VERY_SMOL;\n              \t}\n                \n              \telse\n              \t{\n                \t// refr\n                \trd = refract(rd, n, going_in ? (n1 / n2) : (n2 / n1));\n                \tro = ip - n * VERY_SMOL*5.0;\n                \tinside_sdf = !inside_sdf;\n              \t}\n                last_specular = true;\n            }\n            else if (prim_type == PRIM_TYPE_SPHERE)\n            {\n                \n                \n                float random = rand(seed);\n                if (random < 0.75)\n                {\n                \t// diffuse\n                  #if USE_IMPORTANCE_SAMPLING\n                    vec3 wi = normalize(randomDirectionCW(n, rand2(seed)));\n                    float n_dot_wi = dot(n, wi);\n                    float pdf = n_dot_wi / PI;\n                  #else\n                    vec3 wi = normalize(randomDirection(n, rand2(seed)));\n                    float n_dot_wi = dot(n, wi);\n                    float pdf = 1.0 / (2.0 * PI);                  \n                  #endif\n\n                    throughput *= (albedo / PI) * (n_dot_wi / pdf); \n\n                    rd = wi;\n                    ro = ip + normalize(n) * VERY_SMOL * 100.0;\n                \tlast_specular = false;\n                }\n                else \n                {\n                \t// refl\n                \tthroughput *= albedo;\n                \trd = normalize(reflect(rd, n));\n                \tro = ip + n * VERY_SMOL;\n                \tlast_specular = true;\n                }\n            }\n            else\n            {\n               \tvec3 brdf = albedo / PI;\n                \n              #if USE_NEE\n                last_specular = false;\n                \n                vec3 e0 = lights[0].v1 - lights[0].v0;\n                vec3 e1 = lights[0].v2 - lights[0].v0;\n                vec2 r = rand2(seed);\n                if (r.x + r.y >= 1.0) { r.x = 1.0 - r.x; r.y = 1.0 - r.y; };\n                vec3 random_pos = lights[0].v0 + e0 * r.x + e1 * r.y;\n                \n                vec3 light_n = cross(e0, e1);\n                float light_n_len = length(light_n);\n                float area = light_n_len * 0.5;\n                light_n /= light_n_len;\n                \n                vec3 wi = random_pos - ip;\n                float dist2 = dot(wi, wi);\n                float dist = sqrt(dist2);\n                wi /= dist;\n                \n                float n_dot_wi = dot(n, wi);\n                float ln_dot_wi = -dot(light_n, wi);\n                \n                if (n_dot_wi > 0.0 && ln_dot_wi > 0.0)\n                {\n                 \tvec3 shadow_rd = wi;\n                    vec3 shadow_ro = ip + n * VERY_SMOL * 5.0;\n                    if (!shadowRaySceneIntersect(shadow_ro, shadow_rd, dist - (VERY_SMOL*10.0)))\n                    {\n                        float solid_angle = ln_dot_wi * area / dist2;\n                        float pdf = 1.0 / (solid_angle * float(LIGHT_COUNT));\n                        color += throughput * lights[0].color * brdf * (n_dot_wi / pdf);\n                    }\n                }\n                \n              #endif\n                \n                \n                {\n                  #if USE_IMPORTANCE_SAMPLING\n                    vec3 wi = normalize(randomDirectionCW(n, rand2(seed)));\n                    float n_dot_wi = dot(n, wi);\n                    float pdf = n_dot_wi / PI;\n                  #else\n                    vec3 wi = normalize(randomDirection(n, rand2(seed)));\n                    float n_dot_wi = dot(n, wi);\n                    float pdf = 1.0 / (2.0 * PI);                  \n                  #endif\n\n                    throughput *= brdf * (n_dot_wi / pdf); \n\n                    rd = wi;\n                    ro = ip + normalize(n) * VERY_SMOL * 100.0;\n                }\n            }\n        }\n    }\n    \n    color /= float(SPP);\n    \n    vec4 old_color = vec4(0);\n  #if CONVERGE\n    if (iMouse.z <= 0.0) {\n        old_color = texture(iChannel0, uv);\n    }\n  #endif\n    \n    if (!isnan(color.x) && !isnan(color.y) && !isnan(color.z)) {\n    \t// Output to screen\n    \tfragColor = vec4(old_color.xyz + color, old_color.w + 1.0);\n    }\n        \n}\n\n","name":"Buffer B","description":"","type":"buffer"}]}