{"ver":"0.1","info":{"id":"ttKBWz","date":"1614207852","viewed":79,"name":"Ray marching PBR","username":"GrumpyPants","description":"Ray marching PBR ","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pbr","raymarcing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MARCH_STEP 250\n#define MIN_DIST 0.0\n#define MAX_DIST 200.0\n#define EPSILON 0.0001\n#define ligh_number 1\n\nvec3 eye = vec3(0.0,0.0,2.0);\n\nconst float PI = 3.14159265359;\n  \nvec3  albedo = vec3(1.0,0.96,0.258);\nfloat metallic = 0.1;\nfloat roughness = 0.73;\nfloat ao = 0.0; \n\nconst vec3 lightPositions[ligh_number] = vec3[ligh_number](vec3(5.0, 5.0, 3.0));\nconst vec3 lightColors[ligh_number] = vec3[ligh_number](vec3(300.0, 300.0, 300.0));\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n} \n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}   \n\n\nfloat sdSphere( vec3 p, float r ){\n  return length(p)-r;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  \n  return dot(p,n) + h;\n}\n\nfloat sceneSDF(vec3 p){\n\nreturn sdSphere(p, 1.0);\n\n}\n\nvec3 CalcNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 direction(vec2 size, vec2 coord) {\n\nvec2 xy = coord - size / 2.0;\nfloat z = size.y / 2.0;\n\nreturn normalize(vec3(xy, -z));\n\n}\n\nfloat raymarch(vec3 p, vec3 dir, float start, float maximum){\n\n float depth = start;\n\n for (int i = 1; i <= MARCH_STEP; i++){\n\n float dist = sceneSDF(p + depth * dir);\n\n if (dist >= maximum){\n\n return maximum;\n\n }\n\n depth += dist;\n\n if (dist <= EPSILON){ \n\n return depth;\n\n }\n }\n\n return maximum;\n\n\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nvec3 gamma_correction(vec3 color){\n\n    color = color / (color + vec3(1.0));\n    return  pow(color, vec3(1.0/2.2));  \n    \n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n   \n    vec3 col = vec3(1.0,0.0,0.0);\n    \n    \n    vec3 dir = direction(iResolution.xy, fragCoord);\n    float dist = raymarch(eye, dir, MIN_DIST, MAX_DIST);\n    \n    vec3 p = eye + dir * dist;\n    \n    \n    \n    vec3 N = CalcNormal(p);\n    vec3 V = normalize(eye);\n\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, albedo, metallic);\n    vec3 Lo = vec3(0.0);\n    \n    for(int i = 0; i < ligh_number; ++i) \n    {\n        \n         \n        vec3 L = normalize(lightPositions[i]);\n        vec3 H = normalize(V + L);\n        float distance    = length(lightPositions[i]);\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance     = lightColors[i] * attenuation;        \n        \n    \n    \n        float NDF = DistributionGGX(N, H, roughness);        \n        float G   = GeometrySmith(N, V, L, roughness);      \n        vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n        \n        vec3 kS = F;\n        vec3 kD = vec3(1.0) - kS;\n        kD *= 1.0 - metallic;\t  \n        \n        vec3 numerator    = NDF * G * F;\n        float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n        vec3 specular     = numerator / max(denominator, 0.001);  \n        \n        \n        float NdotL = max(dot(N, L), 0.0);                \n        Lo += (kD * albedo / PI + specular) * radiance * NdotL; \n\n    }  \n    \n    \n    vec3 ambient = vec3(0.03) * albedo * ao;\n    col = ambient + Lo;\n\t\n    col =  aces_tonemap(col);\n    //col =  gamma_correction(col);\n    \n    \n   \n    if (dist >= MAX_DIST){\n    \n    col = vec3(1.0);\n    \n    }\n    \n    \n    fragColor = vec4(col,1.0);\n   \n  }     ","name":"Image","description":"","type":"image"}]}