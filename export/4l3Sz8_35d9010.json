{"ver":"0.1","info":{"id":"4l3Sz8","date":"1477961323","viewed":123,"name":"Metaballs with Soundcloud","username":"hopskotchrainbow","description":"Now THAT is how you raytrace metaballs together.","likes":0,"published":1,"flags":96,"usePreview":0,"tags":["raycast","raytrace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MdB3WR","filepath":"https://soundcloud.com/zer0_gravity_gam3r/swirl-by-waterflame89","previewfilepath":"https://soundcloud.com/zer0_gravity_gam3r/swirl-by-waterflame89","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define maxSize 9\n\nvec3 vPoints[maxSize];\nfloat vSizes[maxSize];\n\nvoid projection(in vec2 uv, out vec3 xpoint, inout vec3 xnormal, out bool hit) {\n    vec3 udir = normalize(vec3(uv*2.0-1.0,2.6));\n    float z = 0.0;\n    float dfactor = 0.002;\n    hit = false;\n    for (int i=0; i<256; i+=1) {\n        xpoint = udir*z;\n        float tof = 0.0;\n        xnormal = vec3(0.0);\n    \tint cest = 0;\n        for (int x=0; x<maxSize; x+=1) {\n            vec3 dest = vPoints[x];\n            float rad = vSizes[x];\n            float dist = distance(xpoint, dest);\n            float mv = pow(max(0.0,1.0-dist/rad),2.0);\n            tof += mv;\n            xnormal += normalize(xpoint-dest)*mv;\n            ++cest;\n        }\n        if (tof >= 0.43) {\n            if (cest > 0 && dfactor <= 0.01) {\n                xnormal /= float(cest);\n                hit = true;\n                return;\n            }\n        }\n        z = z + dfactor;\n    }\n    xnormal = vec3(0.0,0.0,1.0);\n}\n\nfloat MDNormal(vec3 xnormal, vec3 xlight) {\n    vec3 xn = normalize(xnormal-xlight);\n    vec3 yn = normalize(xnormal);\n    return dot(xn, yn)/4.0+1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vPoints[0] = vec3(0.1,0.15,0.5);\n\tvSizes[0] = texture(iChannel0,vec2(96./256.,0.0)).r*0.21+0.1;\n\tvPoints[1] = vec3(-0.1,0.15,0.5);\n\tvSizes[1] = texture(iChannel0,vec2(96./256.,0.25)).r*0.21+0.1;\n    vPoints[2] = vec3(0.0,0.0,0.43);\n    vSizes[2] = 0.24;\n    vPoints[3] = vec3(-0.15,-0.15,0.5);\n    vSizes[3] = 0.25;\n    vPoints[4] = vec3(0.15,-0.15,0.5);\n    vSizes[4] = 0.25;\n    vPoints[5] = vec3(0.07,0.28,0.5);\n    vSizes[5] = 0.16;\n    vPoints[6] = vec3(-0.07,0.28,0.5);\n    vSizes[6] = 0.16;\n    vPoints[7] = vec3(0.15,-0.357,0.43);\n    vSizes[7] = 0.275;\n    vPoints[8] = vec3(-0.35,-0.157,0.43);\n    vSizes[8] = 0.275;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 normal;\n    vec3 point;\n    bool hit;\n    projection(uv,point,normal,hit);\n    vec4 cube = texture(iChannel1,point.xy-1.);\n    float nd = MDNormal(normal, vec3(0.7,0.5,0.4));\n    vec3 color = texture(iChannel2,uv).rgb;\n    if (hit) {\n        color = cube.rgb*nd;\n    }\n\tfragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.7,0.27,0.4,1.0);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.95,0.5,0.6,1.0);\n}","name":"Buf B","description":"","type":"buffer"}]}