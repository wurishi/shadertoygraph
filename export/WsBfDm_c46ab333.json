{"ver":"0.1","info":{"id":"WsBfDm","date":"1590138434","viewed":270,"name":"Procedural Mandala Pattern","username":"Emil","description":"Taken from this video by Anastasia Opara\nhttps://www.youtube.com/watch?v=uA6BDOUzWnM\n\nI just thought it would be a fun exercise and an opportunity to see those pattern being created on the fly (instead of waiting for the loop to finish)","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["procedural","2d","pattern","mandala"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Idea more or less copied from Anastasia Opara in this video:\n// https://www.youtube.com/watch?v=uA6BDOUzWnM\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0,uv);\n}\n\n// Magic happens in Buffer A","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Play around with the following three values for some interesting patterns\n#define lookup_distance 6.0\n#define max_neighs 2.2\n#define div 1.0\n\n#define FrameRateDelay 2\n#define emit_radius 80\n#define max_iterations 27\n\n\nvec4 get_pixel(float x_offset, float y_offset)\n{\n    // Function to easily get neighbouring pixels\n\treturn texture(iChannel0, (gl_FragCoord.xy / iResolution.xy) + (vec2(x_offset, y_offset) / iResolution.xy));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float state = 0.0; // \n    \n    //------- Init Scene -------//\n    #define center_compare_x int(fragCoord.x) == int(iResolution.x/2.0)\n    #define center_compare_y int(fragCoord.y) == int(iResolution.y/2.0)\n    if (iFrame==0)\n    {\n        // Four pixel in center:\n        int emitRadius = emit_radius;\n        // 1\n        if (center_compare_x+emitRadius){\n            if (center_compare_y){\n                state = 1.0;\n            }\n        }\n        // 2\n        if (center_compare_x-emitRadius){\n            if (center_compare_y){\n                state = 1.0;\n            }\n        }\n        // 3\n        if (center_compare_x){\n            if (center_compare_y+emitRadius){\n                state = 1.0;\n            }\n        }\n        // 4\n        if (center_compare_x){\n            if (center_compare_y-emitRadius){\n                state = 1.0;\n            }\n        }\n    }\n    \n    //------- Mouse input -------//\n    /*\n    if(iMouse.z > 0.0) // if mouseclick\n    {\n        if(length(fragCoord.xy - iMouse.xy)<1.0)\n        {\n            state += 1.0;\n        }\n    }*/\n    \n    //-------- Feedback --------//\n    float radius = lookup_distance;\n    float accummulate = 0.0;\n    for (float x = -radius; x<radius; x+= 1.0){\n        for (float y = -radius; y<radius; y+= 1.0){\n            if (length(vec2(x,y))<radius){\n            \taccummulate += get_pixel(x,y).r;\n            }\n    \t}\n    }\n    accummulate /= div;\n    if (accummulate<max_neighs && (iFrame < max_iterations*FrameRateDelay)){\n        if (iFrame%FrameRateDelay == 1){\n\t\t\tstate += clamp(accummulate, 0.0 ,1.0);\n        }\n        \n    } else {\n        \n        state = get_pixel(0.0, 0.0).r;\n        \n    }\n    \n    fragColor = vec4(state);\n}","name":"Buffer A","description":"","type":"buffer"}]}