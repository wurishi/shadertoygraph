{"ver":"0.1","info":{"id":"XX2Bz1","date":"1729216175","viewed":39,"name":"Dragon Library V2","username":"m1o9n6s8t8e3r","description":"Adapted @MisterSirCode's julia set library code to the Littlewood polynomial root fractal","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","mandelbrot"],"hasliked":0,"parentid":"XcjSDV","parentname":"Dragon Library V1"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MZ(z) mat2(z, -z.y, z)\n#define GONEXT if ( !limithit )                             \\\n                  for (float i = -1.; i < 2.; i += 2.) {    \\\n                      l++;                                  \\\n                      vec2 z = (z+vec2(i,0)) * cinv;        \\\n                      if ( length(z) > r ) limithit = true; \\\n                        else               maxl = max(l, maxl); \n\n#define ENDNEXT       limithit = false; l --;               \\\n                  }\n\nstruct complex {\n    float re;\n    float im;\n};\n\nfloat squareabs(complex c) {\n    return c.re*c.re+c.im*c.im;\n}\n\ncomplex mult(complex c1, complex c2) {\n    complex c3;\n    c3.re = c1.re * c2.re - c1.im * c2.im;\n    c3.im = c1.re * c2.im + c1.im * c2.re;\n    return c3;\n}\n\n\n\nvec3 mandelbrot(vec2 z, vec2 c) {\n    float l = 0.0;\n    for (l = 0.0; l < 100.0; l += 1.0) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if(dot(z, z) > 65536.0) break;\n    }\n    l = l - log2(log2(dot(z,z))) + 4.0;\n    return vec3(l, z);\n}\n\n\n\n\nvec3 littlewood2(vec2 z, vec2 c) {\n    vec2 origz = z;\n    int l,maxl;\n    float c2 = dot(c,c), r = 1./(1.-length(c));\n    if (c2 > 1.)  return vec3(0., origz);\n    mat2 cinv = MZ(c) / c2;\n    bool limithit = false;\n    GONEXT\n        GONEXT\n            GONEXT\n                GONEXT\n                    GONEXT\n                        GONEXT\n                            GONEXT\n                                GONEXT\n                                    GONEXT\n                                    ENDNEXT\n                                ENDNEXT\n                            ENDNEXT\n                        ENDNEXT\n                    ENDNEXT\n                ENDNEXT\n            ENDNEXT\n        ENDNEXT\n    ENDNEXT\n    float maxl_float = float(maxl);\n    return vec3(maxl_float / 10.5, origz);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((fragCoord) / iResolution.y) / 1.7;\n    float res = 8.0 * (1.5+cos(iTime));\n    vec2 puv = floor(uv * res) / res;\n    float c2 = dot(puv,puv);\n    if (c2 > 1.) {\n        puv = vec2(-puv.y, puv.x) / c2;\n    }\n    float scale = 2./(1.-length(puv));\n    vec2 muv = mod(uv, 1.0 / res) * res * scale - (scale / 2.0);\n    \n    vec2 nuv = fragCoord / iResolution.xy;\n    vec3 f;\n    if (nuv.x + nuv.y > 1.0) {\n        f = littlewood2(muv, puv);\n    } else {\n        float c3 = dot(uv,uv);\n        if (c3 > 1.) {\n            uv = vec2(-uv.y, uv.x) / c3;\n        }\n        f = littlewood2(vec2(0.,0.), uv);\n    }\n    float l = f.x;\n    vec2 z = f.yz;\n    fragColor = vec4(vec3(l) * vec3(0.4, 0.7, 1.), 1.0);\n    //fragColor = vec4(ref);\n}","name":"Image","description":"","type":"image"}]}