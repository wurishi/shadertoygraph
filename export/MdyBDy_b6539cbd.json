{"ver":"0.1","info":{"id":"MdyBDy","date":"1530225462","viewed":432,"name":"Chaotic Blossom","username":"Flopine","description":"Still experimenting with more \"organic\" movements and shapes.","likes":21,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","colors","flower","repetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Code by Flopine\n// Thanks to wsmind, leon, lsdlive, lamogui, XT95 and Coyhot for teaching me <3\n// cookie collective rulz!\n\n#define ITER (64.)\n#define PI (3.141592)\n#define time (iTime*0.5)\n\n\nmat2 rot(float a)\n{return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nvec2 moda (vec2 p, float per)\n{\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    a = mod(a-per/2.,per)-per/2.;\n    return vec2(cos(a),sin(a))*l;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat stmin(float a, float b, float k, float n)\n{\n    float st = k/n;\n    float u = b-k;\n    return min(min(a,b), 0.5 *(u+a+abs(mod(u-a+st,2.*st)-st)));\n}\n\nvec3 palette (float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{return a+b*cos(2.*PI*(c*t+d));}\n\nfloat odile (vec3 p, float d)\n{return dot(p, normalize(sign(p)))-d;}\n\nfloat torus (vec3 p, vec2 d)\n{\n    vec2 q = vec2(length(p.xz)-d.x,p.y);\n  \treturn length(q)-d.y;\n}\n\nfloat prim1 (vec3 p)\n{\n    float steps = 3.;\n\tfloat t1 = torus(p, vec2(1.5,.15));\n    float od = odile(p,.8);\n    p.yz *= rot(PI/2.);\n    float t2 = torus(p,vec2(1.6,0.15));\n    return stmin(od,stmin(t1,t2, 0.5, steps),0.5,steps);\n}\n\nfloat fractal(vec3 p)\n{\n    float prim = prim1(p);\n    float prout = .3;\n    for (int i = 0; i<5; i++)\n    {\n        prout += .4;\n        p.xz *= rot(sin(iTime*prout));\n        p.xy = moda(p.xy, 2.*PI/5.);\n        p.x -= 4.;\n      \tprim = smin(prim, prim1(vec3(p.x, p.yz*rot(PI/4.))), 2.);  \n    }\n    return prim;\n}\n\n\nvec4 SDF(vec3 p)\n{\n  \tp.xz *= rot(time);\n    p.yz *= rot(time);\n    p.y += sin(p.x+iTime*3.)*length(p)*0.1;\n    float d = fractal(p);\n    return vec4(d, p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.*(fragCoord/iResolution.xy)-1.;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.001,0.001,-15.); vec3 p = ro;\n    vec3 dir = normalize(vec3(uv,1));\n    \n    float shad = 0.;\n    float t = 0.;\n    float tmax = 100.;\n    vec3 c = vec3(0.);\n    \n    for (float i = 0.; i<ITER; i++)\n    {\n        float d = SDF(p).x;\n        t += d;\n        if (d<0.001 || t>tmax)\n        {\n            shad = i/ITER;\n            break;\n        }\n        p+= d*dir*0.8;\n    }                 \n    vec3 pal = palette (length(SDF(p).yzw),\n                        vec3(0.2,0.6,0.3),\n                        vec3(0.5,0.1,0.5),\n                        vec3(.08),\n                        vec3(0.,0.5,0.1));\n    if (t<tmax) c = vec3(1.-shad)*pal*1.5;\n\tc = mix(c, vec3(0.5,0.4,0.2)*0.35, 1.-(exp(-.002*t*t)));\n    \n    // Output to screen\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"}]}