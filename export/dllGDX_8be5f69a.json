{"ver":"0.1","info":{"id":"dllGDX","date":"1672598280","viewed":119,"name":"Smooth Mirroring","username":"myth0genesis","description":"Just needed a way to smooth the point/plane about which a function mirrors. iq kindly pointed me to some literature on it. I originally just used a smooth min to achieve a similar result. Contains overloaded versions for 1 to 3 dimensions.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","ray","raymarch","marching","folding","mirror","smooth","march","fold","mirroring"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int maxstps = 100;\nconst float maxdst = 100.0;\nconst float mindst = 0.001;\nconst float pi = 3.1415927410125732421875;\nconst float tau = 6.283185482025146484375;\n\nmat2 rot2D(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s,\n                s,  c);\n}\n\n// Much thanks to iq for supplying this method! https://iquilezles.org/articles/functions/\nfloat smoothabs(float x, float k) {\n    return sqrt(x * x + k);\n}\n\nvec2 smoothabs(vec2 x, float k) {\n    return sqrt(x * x + k);\n}\n\nvec3 smoothabs(vec3 x, float k) {\n    return sqrt(x * x + k);\n}\n\nfloat smthMirrNaive(float a, float k) {\n    float b = -a;\n    float h = max(0.0, min(1.0, (b - a) / k + 0.5));\n    float m = h * (1.0 - h) * k;\n    return h * a  + (1.0 - h) * b - 0.5 * m;\n}\n\nvec2 smthMirrNaive(vec2 a, float k) {\n    vec2 b = -a;\n    vec2 h = max(vec2(0.0), min(vec2(1.0), (b - a) / k + 0.5));\n    vec2 m = h * (1.0 - h) * k;\n    return h * a  + (1.0 - h) * b - 0.5 * m;\n}\n\n\nvec3 smthMirrNaive(vec3 a, float k) {\n    vec3 b = -a;\n    vec3 h = max(vec3(0.0), min(vec3(1.0), (b - a) / k + 0.5));\n    vec3 m = h * (1.0 - h) * k;\n    return h * a  + (1.0 - h) * b - 0.5 * m;\n}\n\nfloat sdVertCaps(vec3 p,float h,float r) {\n    p.y -= clamp(p.y, 0.0, h);\n    return length(p) - r;\n}\n\nfloat map(vec3 pos) {\n    float h = 3.0;\n    // switch this to 0 to see the naive implementation.\n    #if 1\n        pos = smoothabs(pos, 0.03);\n        pos.xz *= rot2D(-pi * 0.25);\n        pos.xy *= rot2D(pi * 0.25);\n    #else\n        pos = smthMirrNaive(pos, 1.0);\n        pos.xz *= rot2D(-pi * 0.25);\n        pos.xy *= rot2D(pi * 0.25);\n    #endif\n    pos.y = pos.y + h * 0.5;\n    float d = sdVertCaps(pos, h, 0.1);\n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.0;\n    \n    for(int i = 0; i < maxstps; i++) {\n    \tvec3 p = ro + rd * dO;\n        float dS = map(p);\n        dO += dS;\n        if(dO > maxdst || abs(dS) < mindst) break;\n    }\n    \n    return dO;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0.0);\n    vec3 n = map(p) - \n        vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 getRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l - p),\n        r = normalize(cross(vec3(0.0, 1.0, 0.0), f)),\n        u = cross(f, r),\n        c = f * z,\n        i = c + uv.x * r + uv.y * u;\n    return normalize(i);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\tvec2 m = vec2(0.5);\n    \n    m = (dot(iMouse.xy, iMouse.xy) > 0.0) ? (-iMouse.xy / iResolution.xy) : vec2(0.5);\n\n    vec3 ro = vec3(0.0, 3.0, -7.0);\n    mat2 rmxz = rot2D(m.x * tau);\n    mat2 rmyz = rot2D(m.y * tau + pi);\n    ro.yz *= rmyz;\n    ro.xz *= rmxz;\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    rd.yz *= rot2D(0.4);\n    rd.yz *= rmyz;\n    rd.xz *= rmxz;\n    vec3 col = vec3(0.0);\n   \n    float d = rayMarch(ro, rd);\n\n    if(d < maxdst) {\n        vec3 p = ro + rd * d;\n        vec3 n = getNormal(p);\n\n        float dif = dot(n, normalize(vec3(1.0, 2.0, 3.0))) * 0.5 + 0.5;\n        col = vec3(dif);\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}