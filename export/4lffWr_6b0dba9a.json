{"ver":"0.1","info":{"id":"4lffWr","date":"1511564364","viewed":220,"name":"Wood Growth Ring Texture","username":"nr4","description":"This shader generates a procedural wood cut texture. It uses 1D Perlin noise and 2D signed distance fields.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["procedural","sdf","texture","perlin","wood"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/** Wood growth ring texture shader\n    Copyright (C) 2017  Alexander Kraus <nr4@z10.info>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n#define N 150.\n#define S(a,a0) (length(a)-(a0))\n#define A(a,a0) min(-(a),-(a0))\n#define R(a) fract(sin(dot((a).xy,vec2(12.9898,78.233)))*43758.5453)\n#define g(a,a0) (-1.+2.*R(vec2(a,a0)))\n#define b(a) ( (a)*(a)*(a)* ( 10. + (a)*( -15. + 6.*(a) ) ) )\n#define I(a,a0,a1) ((1.-b(a))*(a0)+b(a)*(a1))\n#define p(a,a0) (I(fract(a),g(floor(a),a0)* fract(a),g(floor(a)+1.,a0)*(fract(a)-1.)))\n\nfloat mfperlin1d(float x, float seed, float fmin, float fmax, float phi)\n{\n    float sum = 0.;\n    float a = 1.;\n    \n    for(float f = fmin; f<fmax; f *= 2.)\n    {\n        sum += a*p(f*x, seed);\n        a *= phi;\n    }\n    \n    return sum;\n}\n\nfloat s(vec2 x)\n{\n    float a=0.;\n    vec2 d = (x-vec2(.5));\n    float phi = asin(d.y/length(d));\n    float p=mfperlin1d(phi,1.,1.,1.e3,.5);\n    for(float i=0.;i<=N;i+=1.)\n    {\n        float a0 = i/N+2.e-2*R(vec2(i));\n        a0 += i/N*(4.e-1)*p;\n        a=A(a,S(x-vec2(.5),a0));\n    }\n    return a;\n}\n\n#define DX 1.e-5\n#define n(a) vec2(s(a+vec2(DX,0.))-s(a-vec2(DX,0.)),s(a+vec2(0.,DX))-s(a-vec2(0.,DX)))/2./DX\n\nvoid mainImage(out vec4 a,in vec2 a0)\n{\n\tvec2 uv=a0.xy/iResolution.xy;\n    float c=1.e-3*length(n(uv))/length(s(uv));\n    \n\ta=mix(vec4(235./255.,183./255.,123./255.,1.), vec4(156./255.,50./255.,17./255.,1.),c);\n}","name":"Image","description":"","type":"image"}]}