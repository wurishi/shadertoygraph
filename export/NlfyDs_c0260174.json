{"ver":"0.1","info":{"id":"NlfyDs","date":"1648886243","viewed":54,"name":"Shader 学习 003 - 条状进度条分段","username":"Liuary","description":"如题，现在条状进度条可以分段了","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // 得到 UV\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // 通过对时间使用正弦函数，得到一个变化的值，处理后这个值处于[0.f, 1.f]\n    float val = (sin(iTime) + 1.f) / 2.f;\n    \n    // 将进度值与反向的 UV.x 叠加，并向下取整，使得小于值的部分为 0.f，而值的部分为 1.f\n    float ans = floor(val + 1.f - uv.x);\n\n    // 分成32段，但是好像显示的分段比这个少\n    float pieces = floor(32.f);\n\n    // 用 sin 函数来分段\n    // 不理解为什么显示的段数不对\n    float piecColor = ceil(sin(uv.x * pieces * 6.f));\n\n    // 输出值和分段的积\n    fragColor = vec4(vec3(ans * piecColor), 1.f);\n}","name":"Image","description":"","type":"image"}]}