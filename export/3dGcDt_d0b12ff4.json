{"ver":"0.1","info":{"id":"3dGcDt","date":"1603969345","viewed":127,"name":"fractapollonian","username":"Kaeylos","description":"#7 Fractal\nmade during the Ink-MAC-tober 2020","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["fractal","apollonian","imac"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ----- Ray marching options ----- //\n#define AA_SAMPLES 1 // antialisaing\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 70\n#else\n    #define MAX_STEPS 150\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.001\n#define NORMAL_DELTA 0.0001\n\n#define FBM_MAX_ITER 10\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\nfloat gauss(float t, float s) { return exp(-(t*t)/(2.*s*s)); }\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float t, float a, float b) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat map(float t, float a, float b, float c, float d) { return c + (t - a) * (d - c) / (b - a); }\nfloat mult(vec2 v) { return v.x*v.y; }\nfloat mult(vec3 v) { return v.x*v.y*v.z; }\nfloat sum(vec2 v) { return v.x+v.y; }\nfloat sum(vec3 v) { return v.x+v.y+v.z; }\n#define saturate(v) clamp(v, 0., 1.)\n\n\n// ----- distance functions modifiers ----- //\n// source: https://iquilezles.org/articles/smin\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*0.25;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polysmin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat Cubic( float a, float b, float k ) {\n    float h = max( k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*h*k*(1.0/6.0);\n}\n\nfloat boxSDF(vec3 p, vec3 boxDim) {\n    vec3 q = abs(p) - boxDim;\n    return length(max(q, 0.0)) + min(maxComp(q), 0.0);\n}\n\nfloat subOp( float d1, float d2) { return max(-d1, d2); }\n\nfloat planeSDF(vec3 p, vec4 plane) { return dot(p - plane.w, plane.xyz); }\n\nvec3 arrayOp(vec3 p, vec3 offset) {\n    return mod(p + 0.5 * offset, offset) - 0.5 * offset;\n}\n\nvec4 orb = vec4(0.);\n\n//Apollonian Fractal Distance\nfloat apollonian(vec3 p, float radius) {\n\tfloat scale = 1.0;\n\tp.xy = p.yx; // flip axis\n\torb = vec4(1e20);\n\tfor( int i=0; i<10;i++ ) {\n\t\tp = -1. + 2.0*fract(0.5*p+0.5);\n\t\tfloat r2 = dot(p,p)*1.;\n\t\tfloat k = radius/r2;\n\t\torb = min( orb, vec4(abs(p),r2) );\n\t\tp     *= k;\n\t\tscale *= k;\n\t}\n\t\n\treturn 0.25*abs(p.x)/scale;\n\t\n}\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0, 1], including hue.\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0, 1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat scene(vec3 p) {\n\t// return sphereSDF(p, 1.0);\n\tfloat d = MAX_DIST;\n\t\n\td= min(d, apollonian(p, 1. + 0.72+ sin(2.*PI*iTime/20.)*0.3));\n\t\n\tvec3 q = p;\n\tq.x = fract(-abs(q.x-1.));\n\tq.yz = mod(q.yz, 2.);\n\tfloat planeGrid = boxSDF(q-vec3(0.,1.,1.), vec3(0.02, 1., 1.));\n\t// d = subOp(planeGrid*100., d);\n\t\n\treturn d;\n}\n\n// Iq's technique\n// source: https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++) {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = scene(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// source: https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 p) {\n    const float h = NORMAL_DELTA;\n\tconst vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * scene(p + k.xyy*h) + \n                      k.yyx * scene(p + k.yyx*h) + \n                      k.yxy * scene(p + k.yxy*h) + \n                      k.xxx * scene(p + k.xxx*h) );\n}\n\n// return dist, marchingCount\nvec2 rayMarching(vec3 O, vec3 D) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 p = O + D * t;\n        float d = scene(p);\n        \n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n        t += d * 1.; // precision handling\n        ++marchingCount;\n    }\n    if(t > MAX_DIST) t=-1.0;\n    return vec2(t, marchingCount);\n}\n\nvec3 blendColor(float t, vec3 a, vec3 b) {\n\treturn sqrt((1. - t) * pow(a, vec3(2.)) + t * pow(b, vec3(2.)));\n}\n    \nvec3 render(vec3 O, vec3 D) { // ray origin and dir\n\t\n\tvec3 blue = vec3(2.,43.,58.)/255.0;\n\tvec3 orange = vec3(255.,160.,60.)/255.0;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 rm = rayMarching(O, D);\n    float mc = rm.y;\n    float d = rm.x;\n    if( d > 0. ) {\n\t    vec3 p = O + D * d;\n\t    vec3 normal = getNormal(p);\n\n\t\t// lighting\n        vec3  backLight = vec3(  0.577, 0.577, -0.577 );\n        vec3  keyLigh = vec3( -0.707, 0.000,  0.707 );\n        float key = saturate(dot(keyLigh, normal));\n        float bac = saturate(dot(backLight, normal));\n        float amb = (0.7+0.3*normal.y);\n\t\tfloat ao = calcOcclusion(p, normal);\n\t\tao = mix(ao, pow( saturate(orb.w*2.0), 1.2 ), 0.1);\n\t\t\n        vec3 brdf  = 3.*vec3(0.2)*amb*ao;\n        brdf += 0.5*vec3(1., 1., 0.8)*key*ao;\n        brdf += 0.5*vec3(1., 1., 0.8)*bac*ao;\n\t\t// brdf *= 2.5;\n\t\t\n        // material\t\t\n        vec3 rgb = vec3(0.2);\n        rgb = blendColor(clamp(2.0*orb.y,0.0,1.0), rgb, orange);\n        rgb = mix(rgb, blue, pow(clamp(1.0-2.0*orb.z,0.0,1.0),2.0) );\n        // color // brdf\n        col = blendColor(0.5,rgb, brdf)*exp(-0.2*d);\n        col = rgb*brdf*exp(-0.2*d);\n        // col = vec3(orb.x*orb.x);\n        col += blue* pow(mc, 0.8)/100.;\n    } else {\n    \tcol = blue;\n    }\n    \n\treturn vec3(saturate(col));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.5; // zoom\n\n\tvec3 O = vec3(0.5*cos(iTime/5.)+1., 1. + sin(iTime/2.)*0.3, 0.5*sin(iTime/10.)); // origin\n\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.0; i < AA_SAMPLES; i++) {\n    \tfor (float j = 0.0; j < AA_SAMPLES; j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), O + vec3(cos(iTime/4.), 0.2*cos(iTime/3.), sin (iTime/4.))); // dir\n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    \n    // gamma corection\n    finalColor = pow(finalColor, vec3(1./2.2));\n    \n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.x += -0.01;\n    hsv.y *= 1.8; // saturate\n    hsv.z *= 1.3;\n    finalColor = hsv2rgb(saturate(hsv));\n    \n    // color grading\n    finalColor *= vec3(1.07 ,0.92, 0.95);\n    \n\tfragColor = vec4(finalColor,1.);\n}","name":"Image","description":"","type":"image"}]}