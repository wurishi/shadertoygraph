{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"#define M_PI 3.141592653\n\nmat3 AddRotateX(mat3 m,float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\tmat3 mr = mat3(1.0,  0.0,  0.0,\n\t\t\t\t   0.0,  cosa, sina,\n\t\t\t\t   0.0,  -sina,cosa);\n\treturn m * mr;\n}\nmat3 AddRotateY(mat3 m,float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\tmat3 mr = mat3(cosa,  0.0, sina,\n\t\t\t\t   0.0,   1.0, 0.0,\n\t\t\t\t   -sina, 0.0, cosa);\n\treturn m * mr;\n}\nmat3 AddRotateZ(mat3 m, float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\tmat3 mr = mat3(cosa, sina, 0.0,\n\t\t\t\t   -sina,cosa, 0.0,\n\t\t\t\t   0.0,  0.0,  1.0);\n\treturn m * mr;\n}\n\nmat3 Euler2Matrix(vec3 euler)//y:heading, x:pitch, z:bank\n{\n\tmat3 m = mat3(1.0,0.0,0.0,\n\t\t   0.0,1.0,0.0,\n\t\t   0.0,0.0,1.0);\n\treturn AddRotateZ(AddRotateX(AddRotateY(m, euler.y), euler.x), euler.z);\n}\n\nvec2 DoRotate(vec2 pos, float angle)\n{\n\tfloat cosa = cos(angle);\n\tfloat sina = sin(angle);\n\treturn vec2(pos.x*cosa - pos.y*sina, pos.x*sina + pos.y*cosa);\n}\n\n\nvec3 Transform(vec3 xyz, vec3 euler_rotate, float scale)\n{\n\tmat3 r = Euler2Matrix(euler_rotate);\n\treturn r * xyz * scale; \n}\n\n\nbool HitC(vec3 xyz, float depth, float r1, float r2)\n{\n\tif (abs(xyz.z) < depth && xyz.x < 0.0)\n\t{\n\t\tfloat rr = xyz.x * xyz.x + xyz.y * xyz.y + xyz.z * xyz.z;\n\t\tif (rr < r1*r1 && rr> r2 * r2)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool HitY(vec3 xyz, float depth, float bold, float len)\n{\n\tif (abs(xyz.z) < depth)\n\t{\n\t\tvec2 pos = xyz.xy;\n\t\tif (xyz.y>=0.0)\n\t\t{\n\t\t\tif (xyz.x>0.0)\n\t\t\t{\n\t\t\t\tpos = DoRotate(xyz.xy, 0.25 * M_PI);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpos = DoRotate(xyz.xy, -0.25 * M_PI);\n\t\t\t}\n\t\t\tif (abs(pos.x)<bold && pos.y<len)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (abs(pos.x)<bold && pos.y<0.0 && pos.y>-len)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nbool HitUnitCircle(vec3 xyz)\n{\n\tif( xyz.x*xyz.x + xyz.y*xyz.y + xyz.z*xyz.z < 1.0)\n\t\treturn true;\n\treturn false;\n}\n\nfloat RayMarching(vec2 screen_pos, float near, float far)\n{\n\tconst int steps = 128;\n\tfloat delta = 1.0/float(steps);\n\t\n\t\n\tfor (int i=0; i<steps; ++i)\n\t{\n\t\tvec3 pos = vec3(screen_pos, float(i)*delta);\n\t\t\n\t\t//ortho inv trans\n\t\tpos += vec3(0.0, 0.0, near/(far-near));//obj pos\n\t\tpos.z *= (far-near);\n\t\t\n\t\t//view inv trans\n\t\t//pass\n\t\t\n\t\t\n\t\t\n\t\t//world inv trans\n\t\tvec3 pos1 = pos - vec3(-0.5, 0, 1.0);\n\t\tfloat scale = 0.4;\n\t\tpos1 = Transform(pos1, vec3(iTime, iTime*0.2, iTime*0.1), 1.0/scale);\n\t\tif (HitC(pos1, 0.5, 1.0,0.9))\n\t\t//if (HitUnitCircle(pos))\n\t\t{\n\t\t\treturn 1.0-float(i)*delta;\n\t\t}\n\t\t\n\t\t\n\t\t//world inv trans\n\t\tvec3 pos2 = pos - vec3(0.5, 0, 1.0);\n\t\tfloat scale2 = 0.4;\n\t\tpos2 = Transform(pos2, vec3(0.0, iTime*0.5, 0.0), 1.0/scale);\n\t\tif (HitY(pos2, 0.5, 0.2, 1.0))\n\t\t{\n\t\t\treturn 1.0-float(i)*delta;\n\t\t}\n\t}\n\treturn -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//view port inv transform\n\tvec2 pos = (fragCoord.xy -iResolution.xy*0.5) / iResolution.xy * 2.0;\n\t\n\t\n\tfloat d = RayMarching(pos, 0.0, 2.0);\n\t\n\tif (d>=0.0)\n\t{\n\t\tfragColor = vec4(d, 0.0,0.0,1.0);\n\t}\n\telse\n\t{\n\t\tfragColor = vec4(0.0,0.0,0.0,1.0);\n\t}\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"Xdf3WN","date":"1369754928","viewed":218,"name":"first demo","username":"jedi_cy","description":"first demo","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["beginner"],"hasliked":0,"parentid":"","parentname":""}}