{"ver":"0.1","info":{"id":"X32cDh","date":"1727254880","viewed":98,"name":"Planet Temple","username":"fishe","description":".","likes":9,"published":1,"flags":0,"usePreview":1,"tags":["sdf","architecture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float infinity = 999.9; // 1.0 / 0.0;\nconst float pi = atan(1.0, 1.0) * 4.0;\nconst float epsilon = 0.001;\n\n//#define ORTHO\n//#define SLICE\n\nmat2 rot(float r){\n    float c = cos(r), s = sin(r);\n    return mat2(c, -s, s, c);\n}\n\nfloat column(vec3 p){\n    float t = infinity;\n    float h = 0.75;\n    float r = 0.12;\n    t = min(t, cylinder(p, r, h));\n    if(t > 0.1) return t;\n    p.y = abs(p.y);\n    t = smin(t, torus(p + vec3(0.0, -(h - 0.04), 0.0), 0.13, 0.04), 0.02);\n    t = smin(t, torus(p + vec3(0.0, -(h - 0.09), 0.0), 0.13, 0.02), 0.01);\n    float R = pi * 2.0 / 16.0;\n    p.xz = rot(round(atan(p.z, p.x) / R) * R) * p.xz;\n    p.x -= r + 0.02;\n    t = max(t, -(cylinder(p, 0.0, h - 0.18) - 0.03));\n    return t;\n}\n\nfloat octave(vec3 p){\n    float n = 0.0;\n    n += noise(p * 2.0) * 2.0;\n    n += noise(p * 4.0) * 1.0;\n    n += noise(p * 8.0) * 0.5;\n    n += noise(p * 16.0) * 0.25;\n    n += noise(p * 32.0) * 0.125;\n    return n / 3.875;\n}\n\nfloat steps(vec3 p, float d, float h){\n\n    float N = length(vec2(d, h))*2.0;\n    float n = N*2.0;\n    float r = pi/2.0 - atan(d, h);\n    mat2 R = rot(r);\n\n    p.zy = p.zy * R;\n\n    float k1, k2;\n    vec3 q1 = p;\n    vec3 q2 = p;\n    q1.z -= round(q1.z / n) * n;\n    q2.z = q2.z + N - round((q2.z + N) / n) * n;\n    q1.zy = R * q1.zy;\n    q2.zy = R * q2.zy;\n    vec2 Q1 = abs(q1.zy) - vec2(d, h);\n    vec2 Q2 = abs(q2.zy) - vec2(d, h);\n    float t1 = length(max(Q1, 0.0)) + min(max(Q1.x, Q1.y), 0.0);\n    float t2 = length(max(Q2, 0.0)) + min(max(Q2.x, Q2.y), 0.0); \n    return min(dot(p, vec3(0.0, 1.0, 0.0)), min(t1, t2));    \n\n}\n\n#define tmin(a, b) ((a).x < (b).x ? (a) : (b))\n\nvec2 map(vec3 p){\n\n    vec2 r = vec2(infinity, 0.0);\n\n    {\n    float k = box(p + vec3(0.0, 1.5, -2.0), vec3(0.35, 0.5, 0.9));\n    vec3 q = p;\n    float s = 0.5;\n    q.z += 0.32;\n    q.y -= 0.352;\n    k = max(k, steps(q, 0.03, 0.025));\n    r = tmin(r, vec2(k, 0.0));\n    }\n    \n    {\n    float k = sphere(p, 2.0) * 0.9;\n    if(k < 0.2){\n        float n = max(0.0, octave(p) - 0.55) * 0.2;\n        k -= n;\n        r = tmin(r, vec2(k, (n > 0.0 && k < r.x) ? 1.0 : 0.0));\n    }else r = tmin(r, vec2(k, 0.0));\n    }\n\n    {\n    float k = infinity; \n    k = min(k, cylinder(p + vec3(0.0, 0.0, 0.0), 2.1, 0.03));\n    k = min(k, cylinder(p + vec3(0.0, 0.2, 0.0), 2.05, 0.2));\n    k = min(k, cylinder(p + vec3(0.0, 0.4, 0.0), 2.2, 0.1));\n    k = min(k, cylinder(p + vec3(0.0, 0.3, 0.0), 2.25, 0.03));\n    k = min(k, cylinder(p + vec3(0.0, 2.05, 0.0), 3.05, 0.05));\n    k = min(k, cylinder(p + vec3(0.0, 2.2, 0.0), 3.0, 0.2));\n    k = min(k, cylinder(p + vec3(0.0, 2.4, 0.0), 3.2, 0.1));\n    k = min(k, cylinder(p + vec3(0.0, 2.6, 0.0), 3.4, 0.1));\n    k = min(k, max(-torus(p + vec3(0.0, 1.0, 0.0), 2.0, 1.0), cylinder(p + vec3(0.0, 1.5, 0.0), 2.0, 0.5)));\n    r = tmin(r, vec2(k, 0.0));\n    }\n\n    {\n    float k = cylinder(p.xzy + vec3(0.0, -2.0, 1.85), 2.0, 2.0);\n    k = max(k, box(p + vec3(0.0, -1.0 + 0.5, 0.0), vec3(0.7, 1.0, 4.0)));\n    k = max(k, cylinder(p, 2.85, 2.0));\n    k = min(k, max(cylinder(p + vec3(0.0, -0.2 + 0.5, 0.0), 2.9, 0.03), box(p + vec3(0.0, 0.0, -2.0), vec3(0.75, 1.0, 4.0))));\n    k = min(k, box(p + vec3(0.0, 1.0, -1.0), vec3(0.4, 1.0, 1.0)));\n    r = tmin(r, vec2(k, 0.0));\n    }\n\n    r.x = max(r.x, -box(p + vec3(0.0, 1.0, -2.0), vec3(0.35, 0.5, 2.0)));\n    if(r.x < infinity) r.x -= 0.01;\n\n    {\n    vec3 q = p;\n    q.xz = rot(-pi/16.0) * q.xz;\n    float R = pi * 2.0 / 16.0;\n    q.xz = rot(round(atan(q.z, q.x) / R) * R) * q.xz;\n    float k = min(\n        box(q + vec3(-1.0, 1.0, 0.0), vec3(1.0, 1.0, 0.07)),\n        column(q + vec3(-2.05, 1.25, 0.0))\n    );\n    r = tmin(r, vec2(k, 1.0));\n    }\n    \n    {\n    vec3 q = p;\n    q.x = abs(q.x);\n    float k = column(q + vec3(-0.5, 1.25, -2.6));\n    r = tmin(r, vec2(k, 1.0));\n    }\n    \n    r.x = max(r.x, -sphere(p, 1.8));\n\n#ifdef SLICE\n    r.x = max(r.x, dot(p, vec3(1.0, 0.0, 0.0)));\n#endif\n\n    if(r.x < 0.1) r.x -= (octave(p) * 2.0 - 1.0) * 0.02;\n\n    return r;\n\n}\n\nvec3 nor(vec3 p){\n    float e = 0.001;\n    return normalize(\n        map(p).x - vec3(map(p - vec3(e, 0.0, 0.0)).x,\n                        map(p - vec3(0.0, e, 0.0)).x,\n                        map(p - vec3(0.0, 0.0, e)).x)\n    );\n}\n\nvec4 surface(sampler2D t, vec3 p, vec3 n){\n    vec4 cx = texture(t, p.yz);\n    vec4 cy = texture(t, p.xz);\n    vec4 cz = texture(t, p.xy);\n    vec3 m = n * n;\n    return (cx * m.x + cy * m.y + cz * m.z) / (m.x + m.y + m.z);\n}\n\nvec2 march(vec3 origin, vec3 direction){\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        if(t > 20.0) return vec2(infinity, 0.0);\n        vec2 d = map(origin + direction * t);\n        if(d.x < epsilon) return vec2(t, d.y);\n        t += d.x;\n    }\n    return vec2(-1.0, 0.0);\n}\n\nvec3 background(vec3 direction){\n    vec3 a = vec3(0.9, 0.9, 0.9);\n    vec3 b = vec3(0.6, 0.8, 1.0);\n    return mix(a, b, direction.y * 0.5 + 0.5);\n}\n\nvec3 gen(vec2 p, float fov, vec3 from, vec3 to){\n    p = p / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 n = normalize(vec3(p, -1.0 / tan(fov / 2.0))); \n    vec3 z = normalize(from-to);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    vec3 y = cross(z, x);\n    return x * n.x + y * n.y + z * n.z;\n}\n\nvec3 iso(vec2 p, float height, inout vec3 from, vec3 to){\n    // @pyBlob\n    p = p / iResolution.xy * 2.0 - 1.0;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 z = normalize(from-to);\n    vec3 x = normalize(cross(vec3(0.0, 1.0, 0.0), z));\n    vec3 y = cross(z, x);\n    vec3 n = vec3(p, 0) * height;\n    from = from + mat3(x, y, z) * n;\n    return -z;\n}\n\nvoid mainImage(out vec4 c, in vec2 p){\n\n    float theta, phi;\n    if(iMouse.z > 0.0){\n        theta = iMouse.x/iResolution.x * 2.0 * pi;\n        phi = iMouse.y/iResolution.y * pi;\n    }else{\n        theta = -iTime/16.0 + pi/1.4;\n        phi = 1.45;\n    }\n\n    vec3 origin  = vec3(\n        cos(theta) * sin(phi),\n        cos(phi),\n        sin(theta) * sin(phi)\n    ) * 7.0;\n\n#ifdef ORTHO\n    vec3 direction = iso(p, 3.0, origin, vec3(0.0));\n    origin.y -= 0.5;    \n#else\n    vec3 direction = gen(p, 1.0, origin, vec3(0.0));\n    origin.y -= 1.0;    \n#endif\n\n    vec2 h = march(origin, direction);\n    \n    if(h.x < 0.0) c = vec4(0.0, 0.0, 0.0, 1.0);\n\n    else if(h.x < infinity){\n    \n        vec3 light1 = normalize(vec3(-1.0, 0.9, 0.7));\n        vec3 light1_col = vec3(1.0, 0.9, 0.8);\n        vec3 light2 = normalize(vec3(-0.5, 1.0, -0.8));\n        vec3 light2_col = vec3(0.3, 0.4, 0.5);\n        vec3 light3 = normalize(vec3(1.0, -0.4, -0.2));\n        vec3 light3_col = vec3(0.4, 0.4, 0.5);\n\n        vec3 p = origin + direction * h.x;\n        vec3 normal = nor(p);\n        vec3 colour = h.y == 0.0 ? surface(iChannel0, p, normal).rgb\n                                 : surface(iChannel1, p, normal).rgb;\n        \n        float s = march(origin + direction * (h.x - 0.05), light1).x < infinity ? 0.0 : 1.0;\n        c.rgb = colour * max(0.0, dot(normal, light1)) * s * light1_col;\n        c.rgb += colour * max(0.0, dot(normal, light2)) * light2_col;\n        c.rgb += colour * max(0.0, dot(normal, light3)) * light3_col;\n        c.a = 1.0;\n        \n    }else c = vec4(background(direction), 1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://iquilezles.org/articles/distfunctions/\n\nfloat sphere(vec3 p, float r){\n    return length(p) - r;\n}\n\nfloat cylinder(vec3 p, float r, float h){\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat box(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat torus(vec3 p, float x, float y){\n    vec2 q = vec2(length(p.xz)-x,p.y);\n    return length(q)-y;\n}\n\nfloat smin(float d1, float d2, float k){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// https://www.shadertoy.com/view/4sfGzS\n\nfloat hash( ivec3 p )    // this hash is not production ready, please\n{                        // replace this by something better\n\n    // 3D -> 1D\n    int n = p.x*3 + p.y*113 + p.z*311;\n\n    // 1D hash by Hugo Elias\n\tn = (n << 13) ^ n;\n    n = n * (n * n * 15731 + 789221) + 1376312589;\n    return float( n & ivec3(0x0fffffff))/float(0x0fffffff);\n}\n\nfloat noise( in vec3 x )\n{\n    ivec3 i = ivec3(floor(x));\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+ivec3(0,0,0)), \n                        hash(i+ivec3(1,0,0)),f.x),\n                   mix( hash(i+ivec3(0,1,0)), \n                        hash(i+ivec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+ivec3(0,0,1)), \n                        hash(i+ivec3(1,0,1)),f.x),\n                   mix( hash(i+ivec3(0,1,1)), \n                        hash(i+ivec3(1,1,1)),f.x),f.y),f.z);\n}","name":"Common","description":"","type":"common"}]}