{"ver":"0.1","info":{"id":"ddcyDl","date":"1699575524","viewed":18,"name":"TP IGI - 1","username":"MiraXdara","description":"Miradji Daraini","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Structure pour une boîte\nstruct Box {\n    vec3 minPoint;\n    vec3 maxPoint;\n};\n\n// Structure pour un cylindre\nstruct Cylinder {\n    vec3 position;\n    float radius;\n    float height;\n};\n\n// Structure pour une sphère\nstruct Sphere {\n    vec3 c;      // Center\n    float r;     // Radius\n    int i;       // Texture Id\n    vec3 color;  // Couleur\n};\n\n// Structure pour un plan\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\n// Structure pour les informations d'intersection\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    int i;// Texture Id\n};\n\n// Structure pour un rayon\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\n// Structure pour un matériau\nstruct Material\n{\n    vec3 d; // Diffuse\n    vec3 s; // Specular (réflexion spéculaire)\n    vec3 reflection; // Réflexion\n};\n\n\n\nbool IntersectBox(vec3 rayOrigin, vec3 rayDirection, Box box, out Hit x)\n{\n    // Transformer le rayon en espace local de la boîte\n    vec3 localRayOrigin = (rayOrigin - box.minPoint) / (box.maxPoint - box.minPoint);\n    vec3 localRayDirection = rayDirection / (box.maxPoint - box.minPoint);\n\n    // Coordonnées minimales et maximales de la boîte\n    vec3 tMin = vec3(0.0);\n    vec3 tMax = vec3(1.0);\n\n    for (int i = 0; i < 3; ++i) {\n        float tNear = max(tMin[i], localRayOrigin[i]);\n        float tFar = min(tMax[i], localRayOrigin[i] + localRayDirection[i]);\n\n        // Vérifier s'il y a intersection\n        if (tNear > tFar || tFar < 0.0) {\n            x = Hit(-1.0, vec3(0), -1);\n            return false;\n        }\n\n        tMin[i] = tNear;\n        tMax[i] = tFar;\n    }\n\n    float tN = max(max(tMin.x, tMin.y), tMin.z);\n    float tF = min(min(tMax.x, tMax.y), tMax.z);\n\n    \n    x = Hit(tN, vec3(0), 0);\n\n    // no intersection\n    if (tN > tF || tF < 0.0) {\n        x = Hit(-1.0, vec3(0), -1);\n        return false;\n    }\n\n    return true;\n}\n\n\n// Fonction pour le motif en damier\nfloat Checkers(in vec2 p)\n{\n    // Filtre de noyau\n    vec2 w = fwidth(p) + 0.01;\n    // Filtre de boîte\n    vec2 i = 20. * (abs(fract((p - 0.03 * w) * 0.03) - 0.03) - abs(fract((p + 0.03 * w) * 0.03) - 0.03)) / w;\n    // Motif xor\n    return 0.7 - 0.7 * i.x * i.y;\n}\n\n// Fonction pour calculer le point sur le rayon\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n// Fonction pour calculer la couleur\n// i : Index de texture\n// p : Point\nMaterial Texture(vec3 p, int i)\n{\n    if (i == 1)\n    {\n        return Material(vec3(1.2, .3, .6), vec3(1.0), vec3(0.0));\n    }\n    else if (i == 0)\n    {\n        // Calculer le damier\n        float f = Checkers(.3 * p.xy);\n        vec3 col = vec3(1.2, 1.4, 1.8) + f * vec3(0.1);\n        return Material(col, vec3(9.6), vec3(3.0));\n    }\n    return Material(vec3(0.4), vec3(0.), vec3(0.8));\n}\n\n\n\n\n// Intersection avec une sphère\n// ray : Le rayon\n// x : Informations d'intersection\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        float t=-b-sqrt(d);\n        if(t>0.)\n        {\n            vec3 p=Point(ray,t);\n            x=Hit(t,normalize(p-sph.c),sph.i);\n            \n            return true;\n        }\n    }\n    return false;\n}\n\n// Intersection avec un plan\n// ray : Le rayon\n// x : Informations d'intersection\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    float t=-dot(ray.o-pl.p,pl.n)/dot(ray.d,pl.n);\n    if(t>0.)\n       {\n            x=Hit(t,vec3(5,3,3),5);\n        return true;\n    }\n    return false;\n}\n\n// Intersection avec tous les objets de la scène\n// ray : Le rayon\n// x : Informations d'intersection\nbool Intersect(Ray ray, out Hit x)\n{\n    // Sphères\n   \n    const Sphere sph1 = Sphere(vec3(1., 0., 1.), 1., 1, vec3(0.5));\n    const Sphere sph2 = Sphere(vec3(3., 6., 1.), 1., 1, vec3(2.5));\n \n\n\n    // Boites\n        const Box box1 = Box(vec3(5., 0., 1.), vec3(0., 0., 0.));\n\n    \n    \n    x = Hit(100., vec3(0), -1);\n    Hit current;\n    bool ret = false;\n\n\n    // Plan\n    const Plane pl = Plane(vec3(2., 0., 6.), vec3(0., 0., 0.), 0);\n\n\n\n\n    if (IntersectSphere(ray, sph1, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    if (IntersectSphere(ray, sph2, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n\n   if (IntersectBox(ray.o, ray.d, box1, current) && current.t < x.t) {\n    x = current;\n    ret = true;\n   }\n    \n\n    if (IntersectPlane(ray, pl, current) && current.t < x.t) {\n        x = current;\n        ret = true;\n    }\n\n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.9, .7, .8), vec3(0.2, 0.4, 0.8), rd.z);\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta)\n{\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0, 0, 1);\n    vec3 cu = -normalize(cross(cw, cp));\n    vec3 cv = -normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\n\nvec3 Color(Material m, vec3 n, vec3 lightDir, vec3 viewDir, vec3 rayDir, vec3 p)\n{\n    vec3 light = normalize(vec3(1, 2, 8));\n\n    // Diffuse\n    float diff = clamp(dot(n, light), 0., 0.4);\n    vec3 diffuse = m.d * diff;\n\n    // Specular\n    vec3 reflectDir = reflect(-lightDir, n);\n    float spec = pow(clamp(dot(reflectDir, viewDir), 0.0, 1.0), 2.0);\n    vec3 specular = m.s * spec;\n\n   \n\n    // Combinaison de diffuse, specular \n    vec3 col = diffuse + specular + vec3(0.3, 0.2, .2);\n    \n    return col;\n}\n\n\nvec3 Shade(Ray ray, inout Hit x)\n{\n    bool idx = Intersect(ray, x);\n\n    if (idx) {\n        vec3 p = Point(ray, x.t);\n        Material mat = Texture(p, x.i);\n\n        // Utiliser tN et tF pour spécifier l'opacité\n        float tN = x.t - 0.1;  // ajustez si nécessaire\n        float tF = x.t + 0.1;  // ajustez si nécessaire\n\n        // Utiliser tN et tF pour spécifier l'opacité\n        float opacity = smoothstep(tN, tF, x.t);\n\n        // Mélanger la couleur diffuse avec la couleur de fond\n        vec3 finalColor = mix(Color(mat, x.n, ray.d, normalize(ray.o - p), ray.d, p), Background(ray.d), opacity);\n\n        // Ajouter la contribution de la lumière diffuse\n        vec3 lightDir = normalize(vec3(3, 3, 3));\n        float diff = clamp(dot(x.n, lightDir), 0., 0.1);\n        \n        // Vérifie si le point d'intersection est proche du sol\n        if (abs(p.y) < 0.01) {\n            // Calcule l'ombre projetée par les sphères sur le sol\n            vec3 shadowOrigin = p + 0.01 * x.n; // Décale le point légèrement le long de la normale pour éviter la détection d'auto-intersection\n            Hit shadowHit;\n            Ray shadowRay = Ray(shadowOrigin, -lightDir);\n            bool isShadowed = Intersect(shadowRay, shadowHit) && shadowHit.t < 1.0; // Vérifie s'il y a une intersection entre le point et la source lumineuse\n\n            // Si l'ombre est détectée, atténue la contribution de la lumière diffuse\n            if (isShadowed) {\n                diff *= 0.2; // Atténuation arbitraire, ajuste selon les besoins\n            }\n        }\n\n        finalColor += 0.11 * diff * vec3(0.01, 0.01, 0.01);\n\n        return finalColor;\n    } else {\n        // Fond avec opacité totale\n        return Background(ray.d);\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (-iResolution.xy + 2. * fragCoord.xy) / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n\n    vec3 ro = 13. * normalize(vec3(sin(2. * 3.14 * mouse.x), cos(2. * 3.14 * mouse.x), 1.4 * (mouse.y - .1)));\n    vec3 ta = vec3(6., 0., 2);\n    mat3 ca = setCamera(ro, ta);\n\n    vec3 rd = ca * normalize(vec3(uv.xy * tan(radians(22.0)), 1.));\n\n\n    vec3 lightDir = normalize(vec3(9,9, 9));\n    vec3 viewDir = normalize(-rd); // \n    vec3 rayDir = rd;\n    \n    Hit x;\n    bool idx = Intersect(Ray(ro, rd), x);\n\n   \n\n    if (idx) {\n        vec3 p = Point(Ray(ro, rd), x.t);\n        Material mat = Texture(p, x.i);\n\n        // Utiliser tN et tF pour spécifier l'opacité\n        float tN = x.t - 0.05;  // ajustez si nécessaire\n        float tF = x.t + 0.3;  // ajustez si nécessaire\n\n        // Utiliser tN et tF pour spécifier l'opacité\n        float opacity = smoothstep(tN, tF, x.t);\n\n        // Mélanger la couleur diffuse avec la couleur de fond\n        vec3 finalColor = mix(Color(mat, x.n, lightDir, viewDir, rd, p), Background(rd), opacity);\n\n        // Ajouter la contribution de la lumière diffuse\n       \n       float diff = clamp(dot(x.n, lightDir), -0.3, 1.5);\n       finalColor += 0.25 * diff * vec3(0.6, 0.3, 0.7);\n\n        fragColor = vec4(finalColor, .7);\n    } else {\n        // Fond avec opacité totale\n        fragColor = vec4(Background(rd), 7.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}