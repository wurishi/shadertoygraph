{"ver":"0.1","info":{"id":"McBSWD","date":"1706321725","viewed":76,"name":"dragon skin raymarch","username":"soggymongoose","description":"raymarch","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 random22(vec2 uv) {\n    return fract(sin(vec2(dot(uv,vec2(127.1,311.7)),dot(uv,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat random21 (vec2 uv) {\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43858.5453123);\n}\n\nvec2 Rot2D(vec2 p, float theta) {\n    return vec2(p.x * cos(theta) - p.y * sin(theta),p.x * sin(theta) + p.y * cos(theta));\n}\n\n\nfloat map(vec3 p) {\n    float map;\n    \n    vec3 tileUV = fract(.0*iTime + p*5.);\n    vec3 tileID = floor(.0*iTime + p*5.);\n    tileUV = abs(tileUV - .5);\n    vec3 mat = vec3(length(min(tileUV.x,tileUV.z)));\n    mat = (pow(mat,vec3(3.)));\n    \n    float flip = mod(tileID.x+tileID.z,2.) * 2. - 1.;\n    \n    map = p.y - .6*mat.x;// * flip;\n    \n    map += dot(sin(.3*iTime+p.xzz*1.86),cos(.3*iTime+p.zxz*.52)) * .1;\n    map += dot(sin(.0*iTime+p.zxz*2.32),cos(.0*iTime+p.xxx*3.42)) * .03;\n    map += dot(sin(.0*iTime+p.xzz*7.22),cos(.0*iTime+p.zxx*9.42)) * .015;\n    map += dot(sin(.0*iTime+p.xz*15.42),cos(.0*iTime+p.zx*18.42)) * .010;\n    map += dot(sin(.5*iTime+p.xzz*43.42),cos(.5*iTime+p.zxz*57.42)) * .005;\n    //map += dot(sin(.5*iTime+p.zxzy*120.32),cos(.5*iTime+p.xxzy*170.53)) * .0003;\n    \n    //map = p.y;\n    \n    return map;\n}\n\n/*\nfloat map(vec3 q) {\n    vec3 p = iTime + q*5.;\n    p.xz -= 1.7 * vec2(1,-1) * p.y;\n    vec3 tileUV = fract(p);\n    vec3 tileID = floor(p);\n    tileUV = abs(tileUV - .5);\n    float mat = min(tileUV.x,tileUV.z) * 2.;\n    return q.y - .1 * pow(mat, 3.);\n}\n*/\n\nvec3 Calc_Norm(vec3 p) {\n    vec2 e = vec2(.001,.0);\n        \n    float dx = map(p+e.xyy) - map(p-e.xyy);\n    float dy = map(p+e.yxy) - map(p-e.yxy);\n    float dz = map(p+e.yyx) - map(p-e.yyx);\n        \n    return normalize(vec3(dx,dy,dz));\n}\n\nvec3 spec(vec3 rd, vec3 nor, vec3 l_pos, vec3 l_col, float n, float k, float c) {\n    return k * pow(clamp(dot(reflect(normalize(l_pos),nor),rd),0.,1.),n) * l_col + c;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n    float t = 0.;\n    for (int i = 0; i < 300; i++) {\n        vec3 p = ro + rd * t; // position along the ray \n    \n        float d = map(p); // distance from scene\n    \n        t += d * .2; // march the ray - lowering d to fix artifacts\n        \n        if ((d < .001) || (t > 100.0)) break; // break loop early\n        }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(0.,1.5,-3.);\n    vec3 rd = normalize(vec3(uv,1.));\n    \n    ro.xz += vec2(iTime*.3);\n    \n    rd.yzx = vec3(Rot2D(rd.yz,.9),rd.x);\n    rd.xzy = vec3(Rot2D(rd.xz,.2),rd.y);\n    rd.xyz = vec3(Rot2D(rd.xy,.2),rd.z);\n    \n    float d = rayMarch(ro,rd);\n    if (d < 100.) {\n    vec3 p = ro + rd * d;\n    vec3 nor = Calc_Norm(p);\n    \n    // Materials\n    vec3 tileUV = fract(.0*iTime + p*5.);\n    vec3 tileID = floor(.0*iTime + p*5.);\n    //tileUV = abs(tileUV - .5);\n    \n    float flip = mod(tileID.x+tileID.z,2.) * 2. - 1.;\n \n    vec3 mat = nor * .5 + .5;\n    \n    float minDist = 1.; //declared early to save during for loop\n    vec2 minPoint = vec2(0.);\n    \n    //get closest dist with neighbor checking\n    for (float y = -1.; y <= 1.; y++) {\n        for (float x = -1.; x <= 1.; x++) {\n            //calc neighbor \n            vec2 neighbor = vec2(x,y);\n            \n            //calc neighbor point\n            vec2 point = random22(tileID.xz + neighbor); \n            \n            //calc dist between neighbor point and current\n            vec2 diff = (neighbor + point) - tileUV.xz; //length(neighbor offset + pos in neighbor - home tile UV)\n            float dist = length(diff); \n            \n            //save smallest dist\n            if (dist < minDist) {\n                minDist = dist;\n                minPoint = point;\n            }\n                \n        }\n    }\n    \n    mat *= mix(vec3(.8,.8,.8),vec3(1.,1.,.8),smoothstep(.2,.8,random21(minPoint))); \n    \n    // Lighting\n    vec3 ilu = vec3(0.);\n    \n    float ambi = .6;\n    vec3 ambi_col = vec3(.9,.8,.8);\n    \n    vec3 top_pos = vec3(2.,2.,1.);\n    vec3 top_col = vec3(.2);\n    float top = clamp(dot(nor,normalize(top_pos)),0.,1.)* (4./length(p-top_pos));\n    \n    // Apply lighting\n    ilu += ambi * ambi_col;\n    ilu += top * top_col;\n    \n    ilu += spec(rd,nor,top_pos,top_col,32.,1.,.0)* (2./length(p-top_pos));\n    \n    // fres\n    float fres = pow(smoothstep(1.,0.,abs(dot(rd,nor))),5.); \n    ilu += fres * ilu * .5;\n    \n    col = ilu * mat;\n    \n    }\n    \n    col = pow( col, vec3(1.0/2.2) ); // gamma correction\n    //col = 1.0 - pow( col, vec3(1.0/2.2) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}