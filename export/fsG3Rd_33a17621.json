{"ver":"0.1","info":{"id":"fsG3Rd","date":"1631913167","viewed":58,"name":"shaderbook8","username":"danielgandolfi","description":"exercise in https://thebookofshaders.com/08/: copy https://www.shadertoy.com/view/4s2SRt","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["shaderbook"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define HALF_PI PI/2.0\n#define QUARTER_PI PI/4.0\n#define blue vec3(0.3,0.3,0.8)\n#define lightblue vec3(0.8,0.8,1.0)\n#define white vec3(1.0,1.0,1.0)\n\nmat2 createScaleMat(float scaleFac) {\nreturn mat2(scaleFac,0.0,0.0,scaleFac);\n}\n\nvec3 drawCrossAxes(\n    const vec2 uv,\n    const vec2 center,\n    const vec3 color,\n    const float maxAxisLength\n) {\n    vec2 uvCentered = uv - center;\n    vec2 viewQuartered = abs(uvCentered);\n    float areEqual = step(distance(viewQuartered.x, viewQuartered.y), 0.0015);\n    float isBeyondMaxLength = step(length(viewQuartered), maxAxisLength);\n    \n    return areEqual * \n        isBeyondMaxLength * \n        \n        color;\n}\n\nmat2 createRotationMatrix(float angle) {\n    return  mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nvec2 squarifyUv(\n    const vec2 uv,\n    const vec2 iRes\n) {\n    vec2 uvCentered = uv - vec2(0.5);\n    return vec2(\n        uvCentered.x*iRes.x/iRes.y,\n        uvCentered.y\n    ) + vec2(0.5);\n}\n\nvec3 drawRotatingLine(\n    vec2 uv,\n    vec3 color,\n    float lineLength\n) {\n    uv -= 0.5;\n    float fromCenter = dot(uv,uv);\n    if (fromCenter < lineLength) {\n        float isPixelOnLine = step(0.994,1.0-distance(uv.y,uv.x));\n        float isXGreaterThan0 = min(sign(uv.x),0.0);\n        float isYGreaterThan0 = min(sign(uv.y),0.0);\n        return isPixelOnLine * \n            isXGreaterThan0 * \n            isYGreaterThan0 * \n            color;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec3 drawLineTrail(\n    vec2 uv,\n    vec3 color,\n    float lineLength\n){\n    uv -= 0.5;\n    float fromCenter = dot(uv,uv);\n    if (fromCenter < lineLength) {\n        float angle = atan(uv.y,uv.x);\n        float distanceFromDesiredAngle = distance(angle,-3.0*PI/4.0);\n        float isAngleAfterLine = step(-3.0*PI/4.0, angle);\n        float angleMul = max(\n            0.0,\n            (1.0 - distanceFromDesiredAngle) * isAngleAfterLine\n        );\n        return angleMul * color;\n    } else {\n        return vec3(0.0);\n    }\n}\n\nvec3 drawCircleLine(\n    const vec2 uv,\n    const vec2 center,\n    const vec3 color,\n    const float radius\n) {\n    \n    float distanceFromCircleCenter = distance(\n        center,\n        uv\n    );\n    float tolerance = 0.0031* distanceFromCircleCenter ;\n    return vec3(\n        step(radius-tolerance, distanceFromCircleCenter *distanceFromCircleCenter)* \n        step(distanceFromCircleCenter *distanceFromCircleCenter, radius+tolerance)\n    ) * color;\n}\n\nvec3 drawArc(\n    vec2 uv,\n    vec2 center,\n    float arcRadianStart,\n    float arcRadianEnd,\n    float distanceFromCenter,\n    vec3 color\n) {\n    uv -= center;\n    float angle = atan(uv.y,uv.x);\n    float fromCenter = length(uv);\n    float tolerance = 0.005;\n    float distanceFromCenterLimiter = step(\n        fromCenter,\n        distanceFromCenter+tolerance\n    );\n    \n    return\n        step(arcRadianStart, angle) *\n        step(angle, arcRadianEnd) * \n        smoothstep(\n            distanceFromCenter-tolerance,\n            distanceFromCenter+tolerance,\n            fromCenter\n        ) * distanceFromCenterLimiter *\n        color;\n}\n\nvec3 drawExternalArcs(\n    vec2 uv,\n    vec2 center,\n    float distanceFromCenter\n) {\n    float spaceBetween = 0.01*PI;\n    vec2 uvAbs = abs(uv - center) + center;\n    float startRadians = spaceBetween;\n    float endRadians = QUARTER_PI - spaceBetween;\n    \n    vec3 lowerArcs = drawArc(\n     uvAbs,\n     center,\n     startRadians,\n     endRadians,\n     distanceFromCenter,\n     blue\n    );\n    \n    vec3 higherArcs = drawArc(\n     uvAbs,\n     center,\n     QUARTER_PI + spaceBetween,\n     HALF_PI - spaceBetween,\n     distanceFromCenter,\n     vec3(0.7,0.7,0.8)\n    );\n    return lowerArcs + higherArcs;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 crossAxisColor = vec3(0.2,0.2,0.2);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = squarifyUv(fragCoord/iResolution.xy, iResolution.xy);\n    \n\n    // Output to screen\n    float rotationAngle = mod(iTime, 2.0*PI);\n    mat2 lineRotationMat = createRotationMatrix(rotationAngle);\n    fragColor = vec4(\n        drawCrossAxes(uv,vec2(0.5), crossAxisColor,0.4) +\n        drawCircleLine(uv, vec2(0.5), white, 0.15) +\n        drawCircleLine(uv, vec2(0.5), blue, 0.075) +\n        drawCircleLine(uv, vec2(0.5), blue, 0.025) +\n        drawCircleLine(uv, vec2(0.5), blue, 0.00015) +\n        drawRotatingLine(\n           ((uv -0.5)* lineRotationMat)+0.5,\n            lightblue,\n            0.15\n        )+\n        drawLineTrail(\n            ((uv -0.5)* lineRotationMat)+0.5,\n            lightblue,\n            0.15\n        )+ \n        drawArc(\n            uv,\n            vec2(0.5),\n            -3.0*PI/4.0 + - (abs(sin(iTime/2.0))* PI/8.0),\n            -PI/4.0 + (abs(sin(iTime/2.0))* PI/8.0),\n            0.45,\n            blue\n        )+ \n        drawArc(\n            uv,\n            vec2(0.5),\n            PI/4.0 - (abs(sin(iTime/2.0))* PI/8.0),\n            3.0*PI/4.0 + (abs(sin(iTime/2.0))* PI/8.0),\n            0.45,\n            blue\n            \n        ) + drawExternalArcs(uv,vec2(0.5), 0.48)\n    ,1.0);\n}","name":"Image","description":"","type":"image"}]}