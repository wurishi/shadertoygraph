{"ver":"0.1","info":{"id":"ttsXW8","date":"1562781065","viewed":204,"name":"cook torrance + POM","username":"mrExalight","description":"texture","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["texture"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","previewfilepath":"/media/ap/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n#define height_coef 1.\n\n\n\nvec4 getNormal(vec2 uv){\n     //https://stackoverflow.com/questions/5281261/generating-a-normal-map-from-a-height-map\n    const vec2 size = vec2(2.0,0.0);\n\tconst ivec3 off = ivec3(-1,0,1);\n\n    vec4 wave = texture(iChannel0, uv);\n    float s11 = wave.x;\n    float s01 = textureOffset(iChannel0, uv, off.xy).x;\n    float s21 = textureOffset(iChannel0, uv, off.zy).x;\n    float s10 = textureOffset(iChannel0, uv, off.yx).x;\n    float s12 = textureOffset(iChannel0, uv, off.yz).x;\n    vec3 va = normalize(vec3(size.xy,s21-s01));\n    vec3 vb = normalize(vec3(size.yx,s12-s10));\n    vec4 bump = vec4( cross(va,vb), s11 );\n    \n   return bump;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 NPlan = vec3(0,0,1.);\n    vec2 uv = (fragCoord/iResolution.xy)-.5;\n    vec3 cam = vec3(0,0,10.);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n   \n    float height;\n   \tfloat nb_layers = 100.;\n\tfloat pas = height_coef / nb_layers;\n    \n    vec3 camDir = normalize(cam - vec3(uv,.0));\n    /*\n    \n    float t = dot(NPlan,cam)/(pow(NPlan.x,2.)+pow(NPlan.y,2.)+pow(NPlan.z,2.));\n    vec3 camOnPlane = cam + NPlan * t; \n    \n    vec3 camOnPlaneDir = normalize(camOnPlane - vec3(uv,.0));\n    \n    float Alpha = acos(dot(camOnPlaneDir,camDir));\n\n    float A = 1. / tan(Alpha);\n    \n    vec3 new_point = vec3(uv,.0) + camOnPlaneDir * A;\n    \n    float tmp_height = getNormal(new_point.xy).a*height_coef;\n\n    float i;\n                                 \n    for(i = 1.-pas; i > 0.; i-=pas){\n    \tA = i / tan(Alpha);\n    \n    \tnew_point = vec3(uv,height) + camOnPlaneDir * A;\n    \n    \ttmp_height = getNormal(new_point.xy).a*height_coef;\n        if(i < tmp_height)\n            break;\n    }\n    \n    if(i>0.){\n        height = tmp_height;\n    \tuv = new_point.xy;\n    }*/\n   \n    vec4 bump = getNormal(uv);\n\n    vec3 normal = bump.xyz;\n   // float height = bump.a * height_coef;\n    \n    \n    vec3 lum = vec3(iMouse.xy/iResolution.xy-.5,1.);\n    /*\n    if(lum.z < bump.a){\n        fragColor = vec4(.0);\n    \treturn;\n    }\n*/\n    //vec3 lum = vec3(cos(iTime/2.)/3.+.5,sin(iTime/2.)/3.+.5,.4);\n    vec3 LightDir = normalize(lum - vec3(uv,height));\n    \n    vec3 LightColor = vec3(1.);\n\tvec3 ObjectColor = texture(iChannel0,uv).xyz ;\n\n\t// ROUGHNESS\n\tfloat m = .01;\n\n\t// INDICES DE REFRACTION\n\tfloat ni = 1.55;\n\t\n\n\tvec3 N = normalize(normal);\n\tvec3 L = normalize(LightDir);\n\tvec3 E = normalize(cam); // we are in Eye Coordinates, so EyePos is (0,0,0)\n\tvec3 H = normalize(L + E);\n\n\tfloat NdotH = max(dot(N, H),0.0);\n\tfloat NdotV = max(dot(N, E),0.0);\n\tfloat VdotH = max(dot(E, H),0.0);\n\n\tfloat c = abs(dot(L,H));\n\tfloat g = sqrt(pow(ni,2.0)+pow(c,2.0)-1.0);\n\n\tfloat F = 0.5*(pow(g-c,2.0)/pow(g+c,2.0))*\n\t(1.0+(\n\t\tpow(c*(g+c)-1.0,2.0)/\n\t\tpow(c*(g-c)-1.0,2.0)\n\t\t));\n\n\tfloat cosAlpha = dot(N,H);\n\n\tfloat tangenteCarre = (1.0 - pow(cosAlpha,2.0))/(pow(cosAlpha,2.0)*2.0*pow(m,2.0));\n\n\tfloat D = exp(-tangenteCarre)/(PI*pow(m,2.0)*pow(cosAlpha,4.0));\n\n\tfloat G = min(\n\t\tmin(\n\t\t\t(2.0*NdotH*NdotV)/VdotH,\n\t\t\t(2.0*NdotH*dot(L,N))/VdotH\n\t\t\t),\n\t\t1.0);\n\n\tfloat ks = (D*F*G) / (4.0*NdotV*dot(L,N));\n\t\n\tvec3 specular = LightColor * ks;\n\tvec3 diffus = ObjectColor * LightColor;\n   /* \n    float t_lum = dot(NPlan,lum)/(pow(NPlan.x,2.)+pow(NPlan.y,2.)+pow(NPlan.z,2.));\n    vec3 lumOnPlane = lum + NPlan * t_lum; \n    \n    vec3 lumOnPlaneDir = normalize(lumOnPlane - vec3(uv,height));\n    \n    float Alpha_lum = acos(dot(lumOnPlaneDir,L));\n\n    float A_lum = 1. / tan(Alpha_lum);\n    \n    vec3 new_point_lum = vec3(uv,height) + lumOnPlaneDir * A_lum;\n    \n    float tmp_height_lum = getNormal(new_point_lum.xy).a*height_coef;\n    \n    float i_lum;\n                                 \n    for(i_lum = 1.-pas; i_lum > 0.; i_lum-=pas){\n    \tA_lum = i_lum / tan(Alpha_lum);\n    \n    \tnew_point_lum = vec3(uv,height) + lumOnPlaneDir * A_lum;\n    \n    \ttmp_height_lum = getNormal(new_point_lum.xy).a*height_coef;\n        if(i_lum < tmp_height_lum)\n            break;\n \n    }\n    \n    if(i_lum>height){\n    \tfragColor = vec4((diffus) * dot(N,L)*0.1,1.0);\n    }else{\n   \t\tfragColor = vec4((diffus + specular) * dot(N,L),1.0);\n    }\n    */\n    fragColor = vec4((diffus + specular) * dot(N,L),1.0);\n}","name":"Image","description":"","type":"image"}]}