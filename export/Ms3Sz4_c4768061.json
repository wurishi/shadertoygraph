{"ver":"0.1","info":{"id":"Ms3Sz4","date":"1457911532","viewed":992,"name":"Channel color lookup","username":"TambakoJaguar","description":"This simple shader colorizes the input on Channel1 (for example webcam) with the color information on the channel0. More information on the code.","likes":8,"published":1,"flags":2,"usePreview":0,"tags":["colors","color","palette","webcam","lookup","colorize","similar","matching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Matching color lookup\" by Emmanuel Keller aka Tambako - March 2016\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n\nThis shader samples nbpoints pixels from the reference picture on Channel 0 and retains\nthe pixel which is the closest to the current pixel on the Channel1. This way, it kind of\ncolorizes the picture on the Channel 1 with the picture on the Channel 0\n*/\n\nconst int nbpoints = 600;\n\n// From https://www.shadertoy.com/view/4djSRW\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec3 refcol = texture(iChannel1, uv).rgb;\n    vec3 acol;\n    float mindist = 10.;\n    \n    for (int i = 0; i < nbpoints; ++i)\n    {\n        //vec2 uvr = vec2(1., iResolution.y/iResolution.x)*hash22(vec2(45.98*uv.x + 12.63*iTime + 32.58*float(i), 72.48*uv.y - 17.12*iTime + 48.14*float(i)));\n        vec2 uvr = vec2(1., iResolution.y/iResolution.x)*hash21(3295.98*uv.x + 2182.48*uv.y + 435.12*iTime + 252.58*float(i));\n        vec3 scol = texture(iChannel0, uvr).rgb;\n        if (i==0)\n            acol = scol;\n        else\n        {\n           \tfloat dist = distance(refcol, scol);\n        \tif (dist<mindist)\n        \t{\n\t            acol = scol;\n    \t        mindist = dist;\n        \t}\n        }\n    }\n    fragColor = vec4(acol, 1.);\n}","name":"Image","description":"","type":"image"}]}