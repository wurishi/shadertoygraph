{"ver":"0.1","info":{"id":"lXSGDt","date":"1709221782","viewed":140,"name":"Bingle's SDF Raymarcher","username":"Bingle","description":"A simple experiment with SDF-based raymarching. Scuffed in many ways. I'm mostly self taught and very new to glsl (and relatively new to rendering stuff in general although I wrote a raytracer in Java once), so it's got quite a couple of rough spots.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Outputting buffer B to the screen.\n\nfloat gamma = 1.8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = pow(texture(iChannel0,uv).rgb,vec3(1.0/gamma));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//Common functions and handy stuff\n\n//Camera pos\nvec3 iRayOrigin = vec3(0,0,5.0);\n\n//Camera dir\nvec3 iRayDir = vec3(0.0,0.0,-1.0);\n\n//Camera up\nvec3 iRayUp = vec3(0,1,0);\n\n//Viewplane Distance\nfloat iPlaneDist = 1.5;\n\n//Pathtracing material for appearance\nstruct material{\n    vec3 col;\n    float roughness;\n    bool emissive;\n};\n\n//SDF test results\nstruct SDFtest{\n    float dist;\n    material mat;\n};\n\n//Ray hit\nstruct hit{\n    bool hit;\n    int steps;\n    vec3 incoming;\n    vec3 pos;\n    vec3 norm;\n    vec3 outgoing;\n    material mat;\n};\n\nvec4 hash44(vec4 p4){ //https://www.shadertoy.com/view/4djSRW\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//Generate a random (sort of evenly distributed-ish) point on a sphere, based on a 4d vector (xyz and time in this case)\nvec3 randVec(vec4 seed){\n    return normalize(hash44(seed).xyz-vec3(0.5));\n}\n\n//Make sure the up direction is correct and that all the vectors are the right length\nvoid resolveCamera(){\n    iRayUp = normalize(cross(iRayDir,cross(iRayUp,iRayDir)));\n    iRayDir = normalize(iRayDir);\n}\n\n//Get the direction of a ray from a screen space coordinate and the resolution\nvec3 getRayDir(vec2 texCoord,vec2 iResolution){\n    vec3 camSide = normalize(cross(iRayDir,iRayUp));\n    vec2 p = 2.0 * texCoord - 1.0;\n    \n    p.x*=iResolution.x/iResolution.y;\n    \n    return normalize(p.x*camSide+p.y*iRayUp+iPlaneDist*iRayDir);\n}\n\n//wraps coordinates (no way it's that thing everybody does with SDF tracers!!)\nvec3 wrap(vec3 pos,float size){\n    return pos-round(pos/size)*size;\n}\n\n//Bunch of SDF shapes (praise be to our lord and savior mr. Quilez lol)\nSDFtest sphere(vec3 pos,float r,material mat){\n    float d = length(pos)-r;\n    return SDFtest(d,mat);\n}\n\nSDFtest cube(vec3 pos,vec3 size,material mat){\n    float d = max(abs(pos.x)-0.5*size.x,max(abs(pos.y)-0.5*size.y,abs(pos.z)-0.5*size.z));\n    return SDFtest(d,mat);\n}\n\nSDFtest cylinder(vec3 pos,float r,float h,material mat){\n    vec2 d = abs(vec2(length(pos.xz),pos.y)) - vec2(r,h);\n    float dist =  min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    return SDFtest(dist,mat);\n}\n\n//Z plane at given height\nSDFtest plane(vec3 pos,float height,material mat){\n    return SDFtest(pos.y-height,mat);\n}\n\n//CSG operators\nSDFtest SDFinvert(SDFtest a){\n    return SDFtest(-a.dist,a.mat);\n}\n\nSDFtest SDFunion(SDFtest a, SDFtest b){ //It's named union now! Pretty neat.\n    if (a.dist<b.dist){\n        return a;\n    }else{\n        return b;\n    }\n}\n\nSDFtest SDFintersection(SDFtest a, SDFtest b){\n    if (a.dist>b.dist){\n        return a;\n    }else{\n        return b;\n    }\n}\n\nSDFtest SDFsubtract(SDFtest a, SDFtest b){\n    if (a.dist>-b.dist){\n        return a;\n    }else{\n        return SDFinvert(b);\n    }\n}\n\n\n//THIS FUNCTION DEFINES THE ENTIRE SCENE\nSDFtest SDF(vec3 pos){\n    return SDFunion(\n        SDFunion(\n            SDFunion(//walls\n                cube(pos-vec3(2.55,0.0,0.0),vec3(0.1,5.0,5.0),material(vec3(0.0,1.0,0.0),1.0,false)),\n                cube(pos+vec3(2.55,0.0,0.0),vec3(0.1,5.0,5.0),material(vec3(1.0,0.0,0.0),1.0,false))\n            ),\n            SDFunion(//floor and ceiling\n                cube(pos-vec3(0.0,2.55,0.0),vec3(5.0,0.1,5.0),material(vec3(1.0),1.0,false)),\n                cube(pos+vec3(0.0,2.55,0.0),vec3(5.0,0.1,5.0),material(vec3(1.0),1.0,false))\n            )\n        ),\n        SDFunion(\n            SDFunion(//back wall and light\n                cube(pos+vec3(0.0,0.0,2.55),vec3(5.0,5.0,0.1),material(vec3(1.0),1.0,false)),\n                cube(pos-vec3(0.0,2.5,0.0),vec3(1.5,0.1,1.5),material(5.0*vec3(1.0,0.95,0.8),0.0,true))\n            ),\n            SDFunion(//props and stuff\n                cylinder(pos+vec3(1.5,1.5,1.0),0.5,1.0,material(vec3(1.0),0.25,false)),\n                sphere(pos+vec3(-1.0,1.5,0.0),1.0,material(vec3(1.0),1.0,false))\n            )\n        )\n    );\n}\n\n//Get the normal at some coordinates\nvec3 normal(vec3 pos){\n    float e = 0.0001;\n    vec2 h = vec2(e,0);\n    \n    vec3 delta = vec3(SDF(pos+h.xyy).dist-SDF(pos-h.xyy).dist,SDF(pos+h.yxy).dist-SDF(pos-h.yxy).dist,SDF(pos+h.yyx).dist-SDF(pos-h.yyx).dist);\n    \n    return normalize(delta);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//All the actual rendering code\n\nfloat minDist = 0.001; // Intersection distance\nfloat bounceRayDist = 0.002; // Offset for casted rays so they dont instantly collide\nint refDepth = 4; // Reflection depth\nint maxStep = 250; // Maximum number of raymarching steps\n\nfloat skyBrightness = 1.0;\n\n//Currently unused, returns a nice grid pattern\n//I was using boolean XOR before (^^), but I realized that's functionally equivalent to ==, so I changed it out\nvec3 color(vec3 pos){\n    pos*=2.0;\n    vec3 col = vec3(1.0);\n    if (mod(pos.x,1.0)<0.5 == mod(pos.y,1.0)<0.5 == mod(pos.z,1.0)<0.5){\n        col-=vec3(0.125);\n    }\n    \n    pos*=0.25;\n    if (mod(pos.x,1.0)<0.5 == mod(pos.y,1.0)<0.5 == mod(pos.z,1.0)<0.5){\n        col-=vec3(0.4);\n    }\n    \n    return col;\n}\n\n//Cast a ray into the scene and see what it hits\nhit raymarch(vec3 pos, vec3 dir){\n    int rayStep = 0;\n    SDFtest test = SDF(pos);\n    \n    while (test.dist>minDist && rayStep<maxStep){ // Raymarching!! wow!! this is pretty cool\n        pos = pos + dir*test.dist;\n        test = SDF(pos);\n        rayStep++;\n    }\n    \n    vec3 norm = normal(pos);\n    vec3 ref = dir+dot(norm,dir)*norm*-2.0;\n    \n    return hit(rayStep<maxStep,rayStep,dir,pos,norm,ref,test.mat);\n}\n\n//Get the final color for a camera ray at a position and direction\nvec3 render(vec3 pos,vec3 dir){\n    vec3 col = vec3(1.0);\n    for (int i=0;i<=refDepth;i++){ // I really would have loved to do this using recursion but I had to unroll it into a loop instead.\n        hit collision = raymarch(pos,dir);\n        //return vec3(float(collision.steps)/float(maxStep));\n        if (collision.hit){\n            if (collision.mat.emissive){\n                return collision.mat.col*col;\n            }else{\n                pos = collision.pos+collision.norm*bounceRayDist;\n                dir = collision.outgoing+collision.mat.roughness*randVec(vec4(10.0*collision.pos,float(iFrame)));\n                //col = mix(collision.mat.col,col,float(i)/float(refDepth));\n                col*=collision.mat.col;//This isn't correct color mixing but I tried the above line and it also didn't look right so man idk\n            }\n            \n        }else{\n            return texture(iChannel0,dir).rgb*col*skyBrightness;\n        }\n        \n    }\n    \n    return vec3(0.0); //Never reached the skybox so must be dark\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    resolveCamera(); //So I can adjust camera parameters easily without things getting all wonky\n    \n    // Normalized pixel coordinates (from 0 to 1) (thanks default shadertoy comments)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = render(iRayOrigin,getRayDir(uv,iResolution.xy));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Mixing in buffer A with previous frames to reduce noise in the final image\n//Please dont go into fullscreen it just doesn't work right now and I don't want to fix it\n//Reset the time to restart drawing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0,uv).rgb;\n    vec3 frame = texture(iChannel1,uv).rgb;\n    \n    col = (col*float(iFrame-1)+frame)/float(iFrame);\n    \n    if (iFrame<1){\n        col = vec3(0.0);\n    }\n    \n    fragColor = vec4(col.rgb,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}