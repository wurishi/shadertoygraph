{"ver":"0.1","info":{"id":"4llXDM","date":"1437146585","viewed":218,"name":"CravoCircles Optimized","username":"104","description":"Attempt at size-optimizing \"CravoCircles\" by cravo @ https://www.shadertoy.com/view/4llSDM","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["short","tweet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"// Attempt at size-optimizing \"CravoCircles\" by cravo @ https://www.shadertoy.com/view/4llSDM\n\n\n// 182ch\n// full optimizations\n// visually identical to original\nvoid mainImage(out vec4 o, vec2 p)\n{\n    o.b=.8;\n    vec2 c=iResolution.xy*.5,z=o.br;\n    float r=c.y,a=2.;\n    for(float i=1.;i<6.;++i)\n        abs(length(p-c)-r)<2.?o++:o,\n        c+=(r*=.5)*sin(z+z-iDate.w*i*(a=-a));\n}\n\n\n\n\n\n\n\n\n\n\n/* TRASH:\n\n//        o+=vec4(abs(length(p-c)-r)<2.),// same as o+=step(abs(length(p-c)-r),2.),\n\n*/\n\n\n/*\n// 265ch\n// basic optimizations, same basic structure (var names etc)\nvoid mainImage( out vec4 o, vec2 p)\n{\n    // default background colour\n    o = vec4(0,0,.7,1);\n    \n    // start with a circle in the middle of the screen\n    vec2 c = iResolution.xy * .5;\n    float a = iDate.w * 2.,\n\t\tr = iResolution.y * .5,\n        s = 1., // which way round the circle is going\n        //w = 4.,\n            d; // how thick the lines are\n    \n    for(float i = 1.; i < 6.; ++i)\n    {\n        d = length(p.xy - c);\n\n        if ( d < r && d > r - 4.)\n            o = o.wwww;\n        \n        // Halve the radius and compute next circle's centre point\n        r *= .5;\n        c.x += r * sin(a*s * i);\n        c.y += r * cos(a*s * i);\n        \n        // Flip the direction of travel\n        s = -s;\n    }\n}\n\n*/\n\n\n/*\n// unoptimized: 453ch\nvoid mainImage( out vec4 o, vec2 p)\n{\n    // default background colour\n    o = vec4(0.0,0.0,0.7,1.0);\n    \n    // start with a circle in the middle of the screen\n    vec2 circleCentre = vec2(iResolution.xy) * 0.5;\n    float angle = iTime * 2.0;   \n    float radius = iResolution.y * 0.5;\n    float angleSign = 1.0; // which way round the circle is going\n    float width = 4.0; // how thick the lines are\n    \n    for(float i = 0.0; i < 5.0; ++i)\n    {\n        float dist = length(p.xy - circleCentre);\n\n        if ( dist < radius && dist > radius - width)\n        {     \n            o = vec4(1.0);\n        }\n        \n        // Halve the radius and compute next circle's centre point\n        radius *= 0.5;\n        circleCentre.x += radius * sin((angle*angleSign) * (i + 1.0));\n        circleCentre.y += radius * cos((angle*angleSign) * (i + 1.0));\n        \n        // Flip the direction of travel\n        angleSign = -angleSign;\n    }\n}\n\n*/","name":"","description":"","type":"image"}]}