{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"/////////////////////////////////////////////////////////////////////////////////////////////\n//\n// Musgrave's noise functions for terrain rendering \n// https://engineering.purdue.edu/~ebertd/texture/1stEdition/musgrave/musgrave.c\n// Originaly published in \"Texturing & Modeling: A Procedural Approach\"\n// by David S. Ebert, F. Kenton Musgrave, Darwyn Peachey, Ken Perlin, Steven Worley\n//\n// Another Musgrave Paper\n// http://www.classes.cs.uchicago.edu/archive/2014/winter/23700-1/project_4_and_5/MusgraveTerrain00.pdf\n//\n// Use Ashima Simplex noise Implementation\n// https://github.com/ashima/webgl-noise\n//\n// License: Distributed under the MIT License.\n//\n// Include Ashima port of Musgrave code:\n// - fBmA(),\n// - multifractalA(),\n// - heteroTerrainA()\n//\n// Ashima port of multifractalA() and heteroTerrainA() differs from original code.\n// It corrects some bugs, adds a new parameter for lacunarity and handles lacunarity\n// differently than Musgrave (in a more standard way IMHO).\n// I kept this modification in my personal port of the original code. Although I tried\n// to be closer to the original.\n//\n// My port of Musgrave code:\n// - fBm(),\n// - multifractal(),\n// - heteroTerrain(),\n// - hybridMultiFractal(),\n// - ridgedMultifractal()\n//\n// Displays from left to right:\n// - fBm()\n// - multifractal()\n// - heteroTerrain()\n// - hybridMultiFractal()\n// - ridgedMultifractal()\n//\n// Top line: function result scaled to 0..1 for grayscale output\n// Bottom line: function result map to Yellow for positive values and Cyan for negative values.\n//\t\t\t\t(black means noise == 0. at this point)\n//\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n// Ashima Simplex Noise\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// K.Musgrave Procedural Noises Collections\n// Ashima Port\n//\n\n/*\n * Procedural fBm evaluated at â€œpointâ€.\n * \n * Parameters:\n * â€œHâ€ is the fractal increment parameter\n * â€œlacunarityâ€ is the gap between successive frequencies\n * â€œoctavesâ€ is the number of frequencies in the fBm\n *\n * Ebert, D., F. K. Musgrave, D. Peachey, K. Perlin, and S. Worley. 2003. Texturing and modeling: A procedural approach, 437. Third Edition. San Francisco: Morgan Kaufmann.\n*/\nfloat fBmA(vec2 point, float H, float lacunarity, float frequency, float octaves) {\n  float value = 0.0;\n  float remainder = 0.0;\n  float pwrHL = pow(lacunarity, -H);\n  float pwr = 1.0; \n\n  /* inner loop of fractal construction */\n  for (int i=0; i<65535; i++) {\n    value += snoise(point * frequency) * pwr;\n    pwr *= pwrHL;\n    point *= lacunarity;\n\n    if (i==int(octaves)-1) break;\n  }\n\n  remainder = octaves - floor(octaves);\n  if (remainder != 0.0) {\n    value += remainder * snoise(point * frequency) * pwr;\n  }\n\n  return value;\n}\n\n/*\n * Procedural multifractal evaluated at â€œpoint.â€\n * \n * Parameters:\n * â€œHâ€ determines the fractal dimension of the roughest areas \n * â€œlacunarityâ€ is the gap between successive frequencies \n * â€œoctavesâ€ is the number of frequencies in the fBm\n * â€œoffsetâ€ is the zero offset, which determines multifractality\n *\n * Ebert, D., F. K. Musgrave, D. Peachey, K. Perlin, and S. Worley. 2003. Texturing and modeling: A procedural approach, 440. Third Edition. San Francisco: Morgan Kaufmann.\n*/\nfloat multifractalA(vec2 point, float H, float lacunarity, float frequency, float octaves, float offset) {\n  float value = 1.0;\n  float rmd = 0.0;\n  float pwHL = pow(lacunarity, -H);\n  float pwr = 1.0;\n  \n  /* inner loop of fractal construction */\n  for (int i=0; i<65535; i++) {\n    value *= pwr * snoise(point*frequency) + offset;\n    pwr *= pwHL;\n    point *= lacunarity;\n\n    if (i==int(octaves)-1) break;\n  }\n\n  rmd = octaves - floor(octaves);\n  if (rmd != 0.0) value += (rmd * snoise(point*frequency) * pwr);\n\n  return value;\n}\n\n/*\n * Heterogeneous procedural terrain function: stats by altitude method. \n * Evaluated at â€œpointâ€; returns value stored in â€œvalueâ€.\n * \n * Parameters:\n * â€œHâ€ determines the fractal dimension of the roughest areas \n * â€œlacunarityâ€ is the gap between successive frequencies \n * â€œoctavesâ€ is the number of frequencies in the fBm\n * â€œoffsetâ€ raises the terrain from â€œsea levelâ€\n *\n * Ebert, D., F. K. Musgrave, D. Peachey, K. Perlin, and S. Worley. 2003. Texturing and modeling: A procedural approach, 500. Third Edition. San Francisco: Morgan Kaufmann.\n*/\nfloat heteroTerrainA(vec2 point, float H, float lacunarity, float frequency, float octaves, float offset) {\n float value, increment, remainder;\n  float pwrHL = pow(lacunarity, -H);\n  float pwr = pwrHL; /* starts with i=1 instead of 0 */\n\n  value = offset + snoise(point * frequency);      \n  point *= lacunarity;\n\n  for (int i=1; i<65535; i++) {\n    increment = (snoise(point * frequency) + offset) * pwr * value;\n    // frequency *= lacunarity;\n    value += increment;\n    point *= lacunarity;\n\n    if (i==int(octaves)) break;\n  }\n\n  /* take care of remainder in 'octaves'  */\n  remainder = mod(octaves, floor(octaves));\n\n  if (remainder != 0.0) {\n    increment = (snoise(point * frequency) + offset) * pwr * value;\n    value += remainder * increment;\n  }\n\n  return value;  \n}\n\n///////////////////////////////////////////////////////////////////////////////////////////\n// K.Musgrave Procedural Noises Collections\n// XBE Port\n//\n\n/*\n * Procedural fBm evaluated at â€œpointâ€.\n * \n * Parameters:\n * â€œHâ€ is the fractal increment parameter\n * â€œlacunarityâ€ is the gap between successive frequencies\n * â€œoctavesâ€ is the number of frequencies in the fBm\n *\n * Ebert, D., F. K. Musgrave, D. Peachey, K. Perlin, and S. Worley. 2003. Texturing and modeling: A procedural approach, 437. Third Edition. San Francisco: Morgan Kaufmann.\n*/\nfloat fBm(vec2 point, float H, float lacunarity, float frequency, float octaves)\n{\n\tfloat value = 0.0;\n\tfloat rmd = 0.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL; \n\n\tfor (int i=0; i<65535; i++)\n\t{\n\t\tvalue += snoise(point * frequency) * pwr;\n\t\tpoint *= lacunarity;\n\t\tpwr *= pwHL;\n\t\tif (i==int(octaves)-1) break;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0) value += rmd * snoise(point * frequency) * pwr;\n\n\treturn value;\n}\n\n/*\n * Procedural multifractal evaluated at â€œpoint.â€\n * \n * Parameters:\n * â€œHâ€ determines the fractal dimension of the roughest areas \n * â€œlacunarityâ€ is the gap between successive frequencies \n * â€œoctavesâ€ is the number of frequencies in the fBm\n * â€œoffsetâ€ is the zero offset, which determines multifractality\n *\n * Ebert, D., F. K. Musgrave, D. Peachey, K. Perlin, and S. Worley. 2003. Texturing and modeling: A procedural approach, 440. Third Edition. San Francisco: Morgan Kaufmann.\n*/\nfloat multifractal(vec2 point, float H, float lacunarity, float frequency, float octaves, float offset)\n{\n\tfloat value = 1.0;\n\tfloat rmd = 0.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\n\tfor (int i=0; i<65535; i++)\n\t{\n\t\tvalue *= pwr*snoise(point*frequency) + offset;\n\t\tpoint *= lacunarity;\n\t\tpwr *= pwHL;\n\t\tif (i==int(octaves)-1) break;\n\t}\n\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0) value += (rmd * snoise(point*frequency) * pwr);\n\n\treturn value;\n}\n\n/*\n * Heterogeneous procedural terrain function: stats by altitude method. \n * Evaluated at â€œpointâ€; returns value stored in â€œvalueâ€.\n * \n * Parameters:\n * â€œHâ€ determines the fractal dimension of the roughest areas \n * â€œlacunarityâ€ is the gap between successive frequencies \n * â€œoctavesâ€ is the number of frequencies in the fBm\n * â€œoffsetâ€ raises the terrain from â€œsea levelâ€\n *\n * Ebert, D., F. K. Musgrave, D. Peachey, K. Perlin, and S. Worley. 2003. Texturing and modeling: A procedural approach, 500. Third Edition. San Francisco: Morgan Kaufmann.\n*/\nfloat heteroTerrain(vec2 point, float H, float lacunarity, float frequency, float octaves, float offset)\n{\n\tfloat value = 1.;\n\tfloat increment = 0.;\n\tfloat rmd = 0.;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\n\tvalue = pwr*(offset + snoise(point * frequency));\n\tpoint *= lacunarity;\n\tpwr *= pwHL;\n\n\tfor (int i=1; i<65535; i++)\n\t{\n\t\tincrement = (snoise(point * frequency) + offset) * pwr * value;\n\t\tvalue += increment;\n\t\tpoint *= lacunarity;\n\t\tpwr *= pwHL;\n\t\tif (i==int(octaves)) break;\n\t}\n\n\trmd = mod(octaves, floor(octaves));\n\tif (rmd != 0.0) value += rmd * ((snoise(point * frequency) + offset) * pwr * value);\n\n\treturn value;  \n}\n\n/* Hybrid additive/multiplicative multifractal terrain model.\n *\n * Copyright 1994 F. Kenton Musgrave \n *\n * Some good parameter values to start with:\n *\n *      H:           0.25\n *      offset:      0.7\n */\nfloat hybridMultiFractal(vec2 point, float H, float lacunarity, float frequency, float octaves, float offset)\n{\n\tfloat value = 1.0;\n\tfloat signal = 0.0;\n\tfloat rmd = 0.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tfloat weight = 0.;\n\n\t/* get first octave of function */\n\tvalue = pwr*(snoise(point * frequency)+offset);\n\tweight = value;\n\tpoint *= lacunarity;\n\tpwr *= pwHL;\n\n\t/* spectral construction inner loop, where the fractal is built */\n\tfor (int i=1; i<65535; i++)\n\t{\n\t\tweight = weight>1. ? 1. : weight;\n\t\tsignal = pwr * (snoise(point*frequency) + offset);\n\t\tvalue += weight*signal;\n\t\tweight *= signal;\n\t\tpwr *= pwHL;\n\t\tpoint *= lacunarity;\n\t\tif (i==int(octaves)-1) break;\n\t}\n\n\t/* take care of remainder in ``octaves''  */\n\trmd = octaves - floor(octaves);\n\tif (rmd != 0.0) value += (rmd * snoise(point*frequency) * pwr);\n\n\treturn value;\n}\n\n/* Ridged multifractal terrain model.\n *\n * Copyright 1994 F. Kenton Musgrave \n *\n * Some good parameter values to start with:\n *\n *      H:           1.0\n *      offset:      1.0\n *      gain:        2.0\n */\nfloat ridgedMultiFractal(vec2 point, float H, float lacunarity, float frequency, float octaves, float offset, float gain)\n{\n\tfloat value = 1.0;\n\tfloat signal = 0.0;\n\tfloat pwHL = pow(lacunarity, -H);\n\tfloat pwr = pwHL;\n\tfloat weight = 0.;\n\n\t/* get first octave of function */\n\tsignal = snoise(point * frequency);\n\tsignal = offset-abs(signal);\n\tsignal *= signal;\n\tvalue = signal * pwr;\n\tweight = 1.0;\n\tpwr *= pwHL;\n\n\t/* spectral construction inner loop, where the fractal is built */\n\tfor (int i=1; i<65535; i++)\n\t{\n\t\tpoint *= lacunarity;\n\t\tweight = clamp(signal*gain, 0.,1.);\n\t\tsignal = snoise(point * frequency);\n\t\tsignal = offset-abs(signal);\n\t\tsignal *= signal;\n\t\tsignal *= weight;\n\t\tvalue += signal * pwr;\n\t\tpwr *= pwHL;\n\t\tif (i==int(octaves)-1) break;\n\t}\n\n\treturn value;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\n//\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = 2.*uv-1.;\n\tq.y = q.y<0.?1.+q.y:q.y;\n\tq *= 2.;\n\t// Noise functions\n\tfloat n = -9.;\n\tif (uv.x < 0.198)\n\t\tn = fBm(q, 0.5, 2., 2., 6.);\n\tif ((uv.x > 0.2) && ( uv.x < 0.398 ))\n\t{\n\t\tfloat o = 0.65;\n\t\tn = multifractal(q, 0.5, 2., 2., 6., o)/o;\n\t}\n\tif ((uv.x > 0.4) && ( uv.x < 0.598 ))\n\t\tn = heteroTerrain(q, 0.5, 2., 2., 6., 0.05);\n\tif ((uv.x > 0.6) && ( uv.x < 0.798 ))\n\t\tn = hybridMultiFractal(q, 0.25, 3., 2., 6., 0.05);\n\tif (uv.x>0.8)\n\t\tn = ridgedMultiFractal(q, 0.25, 2., 2., 6., .9, 1.5);\n\t// Display\n\tif (n<-8.9)\n\t\tdiscard;\n\tvec3 col = vec3(0.0);\n\tif (uv.y>0.502)\n\t{\n\t\tn = 0.5+0.5*n;\n\t\tcol = vec3(clamp(n,0.,1.));\n\t}\n\telse if (uv.y < 0.5)\n\t{\n\t\tcol = vec3(clamp(n,0.,1.), clamp(n,0.,1.)+clamp(-n,0.,1.), clamp(-n,0.,1.) );\n\t\tcol = sqrt(col);\n\t}\n\tfragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4sXXW2","date":"1406742462","viewed":1603,"name":"Musgrave's Noises Collection","username":"xbe","description":"Musgrave's noises functions from book \"Texturing & Modeling: A Procedural Approach\" for terrain rendering.\nUse Ashima Simplex noise Implementation. See Shader comments for more informartions.\nCode is not optimized for clarity.\n\n","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","musgrave"],"hasliked":0,"parentid":"","parentname":""}}