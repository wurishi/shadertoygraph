{"ver":"0.1","info":{"id":"7tXGzl","date":"1622604342","viewed":76,"name":"Perlin Noise 2D __","username":"Envy24","description":"perlin, noise, random","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["noise","perlin","random"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* playlist: https://www.shadertoy.com/playlist/sXfSDS */\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * enthropy2 + x;\n    uint value1 = x * enthropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += enthropy1; value0 *= 445593459u; value0 ^= enthropy0;\n    value1 += enthropy1; value1 *= 445593459u; value1 ^= enthropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\nfloat PerlinNoise(float u, float v)\n{\n    // Fractial part.\n    float fractU = u - floor(u);\n    float fractV = v - floor(v);\n\n    // Integer part.\n    u = floor(u);\n    v = floor(v);\n\n    // Smoothstep.\n    float tU = fractU * fractU * (3.0f - 2.0f * fractU);\n    float tV = fractV * fractV * (3.0f - 2.0f * fractV);\n\n    // Random gradient vectors.\n    vec2 gradient0 = vector2HashUI32(uint(u),        uint(v));\n    vec2 gradient1 = vector2HashUI32(uint(u + 1.0f), uint(v));\n    vec2 gradient2 = vector2HashUI32(uint(u),        uint(v + 1.0f));\n    vec2 gradient3 = vector2HashUI32(uint(u + 1.0f), uint(v + 1.0f));\n\n    // Distance vectors.\n    vec2 distance0 = vec2(fractU,        fractV);\n    vec2 distance1 = vec2(fractU - 1.0f, fractV);\n    vec2 distance2 = vec2(fractU,        fractV - 1.0f);\n    vec2 distance3 = vec2(fractU - 1.0f, fractV - 1.0f);\n\n    // Dot products.\n    float dotProduct0 = gradient0.x * distance0.x + gradient0.y * distance0.y;\n    float dotProduct1 = gradient1.x * distance1.x + gradient1.y * distance1.y;\n    float dotProduct2 = gradient2.x * distance2.x + gradient2.y * distance2.y;\n    float dotProduct3 = gradient3.x * distance3.x + gradient3.y * distance3.y;\n\n    // Bilinear filter.\n    return\n        dotProduct0 * (1.0f - tU) * (1.0f - tV) +\n        dotProduct1 * tU          * (1.0f - tV) +\n        dotProduct2 * (1.0f - tU) * tV +\n        dotProduct3 * tU          * tV;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv;\n    \n    if (fragCoord.x < iResolution.x * 0.5) { uv = fragCoord/iResolution.xy * 6.0f; }\n    else { uv = fragCoord/iResolution.xy * 18.0f; }\n\n    float _u = uv.x + iMouse.x * 0.1f + iTime * 0.1f;\n    float _v = uv.y + iMouse.y * 0.1f + iTime * 0.2f;\n\n    float gray = PerlinNoise(_u,     _v)           * 8.3f;\n    gray += PerlinNoise(_u * 1.1f,   _v * 2.84f)   * 2.42f;\n    gray += PerlinNoise(_u * 4.32f,  _v * 4.32f)   * 1.37f;\n    gray += PerlinNoise(_u * 8.672f, _v * 7.672f)  * 3.47f;\n    gray += PerlinNoise(_u * 16.62f, _v * 17.72f)  * 1.58f;\n    gray += PerlinNoise(_u * 37.72f, _v * 35.72f)  * 1.37f;\n    gray += PerlinNoise(_u * 64.72f, _v * 66.72f)  * 2.37f;\n    gray += 1.777f;\n    gray *= 0.14f;\n   \n\n    // Output to screen\n    fragColor = vec4(vec3(gray),1.0);\n}","name":"Image","description":"","type":"image"}]}