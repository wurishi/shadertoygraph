{"ver":"0.1","info":{"id":"fsGGzV","date":"1631794367","viewed":159,"name":"Transforming mandelbulb","username":"Haper","description":"Glowing cloured mandelbulb with increasing power of formula","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fractal","mandelbulb","marching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":" #define MAX_STEPS 200\n#define MAX_DIST 130.   \nfloat SURF_DIST =.001;\nvec3 r0;\nfloat Power = 1.0;\nint steps=0;\nint S;\nvec3 color;\nvoid rot(inout vec2 p, float a){  \n \tfloat c,s;vec2 q=p;  \n  \tc = cos(a); s = sin(a);  \n  \tp.x = c * q.x + s * q.y;  \n  \tp.y = -s * q.x + c * q.y; \n } \nstruct complex\n{\n   float x;\n   float y;\n   float z;\n};\ncomplex plus(complex a, complex b)\n{\n    complex c;\n    c.x = a.x+b.x;\n    c.y = a.y+b.y;\n    c.z = a.z+b.z;\n    return c;\n}\ncomplex mult(complex a, complex b)\n{\n     complex c;\n     c.x = a.x*b.x - a.y*b.y + a.y*b.z + a.z*b.y - a.z*b.z;\n     c.y = a.x*b.y+a.y*b.x;\n     c.z = a.x*b.z + a.z*b.x;\n     return c;\n}\nfloat smin(float a,float b,float k)\n{\n     float h=clamp(0.5+0.5*(b-a)/k,.0,1.);\n     return mix(b,a,h)-k*h*(1.-h);\n}\nfloat mand(vec3 pos)\n{\n    pos/=2.0;\n    complex Z;\n    Z.x = pos.x;\n    Z.y = pos.y;\n    Z.z = pos.z;\n    \n    float dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 40 ; i++)\n    {\n         r = sqrt(Z.x*Z.x+Z.y*Z.y+Z.z*Z.z);\n         if(r>2.0) break;\n         Z = mult(Z,Z);\n         Z.x+=pos.x;\n         Z.y+=pos.y;\n         Z.z+=pos.z;\n         complex g;\n         g.x = Z.x*2.0*dr;\n         g.y = Z.y*2.0*dr;\n         g.z = Z.z*2.0*dr;\n         \n         dr = 1.0+sqrt(g.x*g.x+g.y*g.y+g.z*g.z);\n    }\n    return 0.5*log(r)*r/dr;\n}\nfloat SDF(vec3 pos) {\n\tvec3 z = pos;\n    z.x=pos.x;\n    z.y=pos.y;\n    z.z=pos.z;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 40 ; i++) {\n\t\tr = length(z);\n        \n\t\tif (r>4.0) break;\n\t\t\n\t\t\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n        \n\t}\n\n\treturn 0.5*log(r)*r/dr;\n}\nfloat sphere(vec4 s,vec3 p)\n{\n   return length(p-s.xyz)-s.w;\n}\nfloat GetDist(vec3 p)\n{\nrot(p.xz,sin(iTime/11.0+1.0)*3.14);\nrot(p.yz,cos(iTime/14.0)*3.14);\nfloat l = SDF(p);\nfloat l2 = sphere(vec4(0.0,0.0,0.0,2.0),p);\n\nif(l2>1.0)\nreturn min(l,l2);\nelse\nreturn l;\n}\nfloat RayMarch(vec3 ro,vec3 rd)\n{\n    float dO=0.0;\n    for(int i=0; i<MAX_STEPS; i++)\n    { \n        steps = i;\n        vec3 p=ro+rd*dO;\n        float ds=GetDist(p);\n        SURF_DIST = length(p-r0)*0.0006;\n        dO+=ds;\n        if(MAX_DIST<dO || ds<SURF_DIST)\n        break;\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(SURF_DIST,0);\n\n    vec3 n = d-vec3(\n       GetDist(p-e.xyy),\n       GetDist(p-e.yxy),\n       GetDist(p-e.yyx));\n     \n     return normalize(n);\n}\nfloat GetLight(vec3 p)\n{\n    vec3 pos = vec3(5.*sin(iTime),5,-6.*cos(iTime)+6.);\n    vec3 l=vec3(1.,2.,-2.);\n    l = normalize(l);\n    vec3 n = GetNormal(p);\n    float dif = mix(0.2,1.,dot(n,l));\n    \n    float d=RayMarch(p+n*0.01,l);\n    if(d<MAX_DIST)\n    dif/=3.0;\n    \n    return dif;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Power = 1.0+iTime/5.0;\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n     r0 = vec3(0.15,0.0,-3.2) ;\n    vec3 rd = normalize(vec3(uv.xy,1.0));\n    SURF_DIST = GetDist(r0)*0.002;\n    float d = RayMarch(r0,rd);\n    S=steps;\n    vec3 p=r0+rd*d;\n    \n    float dif = GetLight(p);\n    \n    color = mix(vec3(0.0,0.0,0.7),vec3(0.0,1.0,0.0),length(p)/2.0);\n    if(d<MAX_DIST && steps<MAX_STEPS)\n    col=vec3(dif)*color;\n\n    float k = float(S)/float(MAX_STEPS);\n    \n    fragColor = vec4(col+mix(vec3(1.0,0.0,0.0),vec3(0.4,0.0,0.8),k)*k*1.5,1.0);\n}","name":"Image","description":"","type":"image"}]}