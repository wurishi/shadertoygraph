{"ver":"0.1","info":{"id":"tlKXD1","date":"1582654665","viewed":148,"name":"Realistic Spheres","username":"RaySoldier","description":"A realistic renderer for spheres.\nThis shader uses the Phong Lighting System with ambient occlusion, dof, and reflections.\nIf you have any suggestions for improvements or optimizations, I would really appreciate it if you told me in the comments.","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["phong","ray","lighting","dof","shadows","reflections","occlusion","ambient","marcher"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n# define BLUR_DETAIL 5.\n\n# define APER 0.004\n# define FOC 0.024\n\nvec3 dof(sampler2D tex, vec2 uv, float strength){\n    \n    float f = texture(tex, vec2(0.5)).w;\n    float d = texture(tex, uv).w;\n    \n    float b = abs(APER * FOC * (f - d))/(f * (f - FOC))*strength;\n    \n    float blur = min(b, 0.005) / BLUR_DETAIL;\n    \n    vec4 t = texture(tex, uv);\n    \n    for(int n = 1; n <= int(BLUR_DETAIL) + 1; n++){\n        \n        t += texture(tex, uv + float(n) * blur * vec2(1, 0));\n        t += texture(tex, uv + float(n) * blur * vec2(-1, 0));\n        t += texture(tex, uv + float(n) * blur * vec2(0, 1));\n        t += texture(tex, uv + float(n) * blur * vec2(0, -1));\n        \n        t += texture(tex, uv + float(n) * blur * vec2(0.7, 0.7));\n        t += texture(tex, uv + float(n) * blur * vec2(-0.7, 0.7));\n        t += texture(tex, uv + float(n) * blur * vec2(0.7, -0.7));\n        t += texture(tex, uv + float(n) * blur * vec2(-0.7, -0.7));\n    }\n    \n    return t.xyz / (1. + 8. * BLUR_DETAIL);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = dof(iChannel0, uv, 50.);\n    \n    // Vignette\n    col *= 1.0 - clamp(1.2 * length(uv - vec2(0.5)), 0.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n// Effects (comment out to disable)\n\n# define AO\n# define FOG\n# define SHADOWS\n# define SPECULAR_HIGHLIGHTS\n\n\n// Effect Parameters\n\n# define AO_STRENGTH 0.02\n# define FOG_STRENGTH 0.01\n# define SUPER_SAMPLING 2\n\n# define MATERIAL_SMOOTHNESS 100.0\n# define HIGHLIGHT_BRIGHTNESS 3.0\n# define SPECULAR_BRIGHTNESS 0.3\n\n# define REFLECTION_COUNT 5\n\n// Lighting\n\n# define AMBIENT_LIGHT vec3(0.527, 0.804, 0.917) * 0.2\n# define DIRECT_LIGHT vec3(1.0, 0.95, 0.8) * 0.2\n\n// Renderer Settings\n\n# define MAX_STEPS 1500\n# define SURF_DIST 0.0001\n# define MAX_DIST 1000.0\n\nfloat smoothmin(float a, float b, float k){\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return (1.0-h)*b + h*a - k*h*(1.0-h);\n}\n\nfloat smoothmax(float a, float b, float k){\n    return -smoothmin(-a, -b, k);\n}\n\nfloat sdScene(vec3 p){\n    \n    float d = p.y + 1.0;\n    \n    d = min(d, length(p) - 1.0);\n    d = min(d, length(p - vec3(10, 0, 6)) - 1.0);\n    d = smoothmin(d, length(p - vec3(5, 0, -3)) - 1.5, 1.0);\n    d = min(d, length(p - vec3(5, 0, 5)) - 1.0);\n    d = min(d, length(p - vec3(25, 0, -15)) - 20.0);\n    d = min(d, length(p - vec3(35, 0, 25)) - 20.0);\n    \n    return d;\n    \n    \n}\n\nvec3 nScene(vec3 p){\n    vec2 e = vec2(0, 0.0001);\n    vec3 nrml = normalize(vec3(sdScene(p + e.yxx),\n                               sdScene(p + e.xyx),\n                               sdScene(p + e.xxy)) - \n                         vec3(sdScene(p)));\n    return nrml;\n}\n\n// Returns the albedo of the closest point in the scene\nvec3 albedoScene(vec3 p){\n    return vec3(1.0);\n}\n\n// Returns the specular color of the closesgt point in the scene\nvec3 specularScene(vec3 p){\n    return albedoScene(p);\n}\n\nfloat rm(vec3 rO, vec3 rD, float minD, float maxD, out int n){\n    \n    float d = minD;\n    \n    n = MAX_STEPS;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n        \n        vec3 p = rO + d * rD;\n        float t = sdScene(p);\n        d += t;\n        if(d > maxD || t < SURF_DIST){\n            n = i;\n            break;\n        }\n    }\n    \n    return d;\n}\n\nfloat softShadow(vec3 rO, vec3 rD, float minD, float maxD, float w){\n    \n    float d = minD;\n    \n    float soft = 1.0;\n    \n    for(int n = 0; n < MAX_STEPS; n++){\n        \n        vec3 p = rO + d * rD;\n        \n        float stp = sdScene(p);\n        \n        soft = min(soft, 0.5+0.5*stp/(w*d));\n        \n        d += stp;\n        \n        if(d > maxD || stp < SURF_DIST) break;\n    }\n    \n    soft = soft * soft * (3.0 - 2.0*soft);\n    \n    return soft * 2. - 1.;\n}\n\nvec3 cSky(vec3 d){\n    \n    return vec3(0.527, 0.804, 0.917);\n}\n\nvoid normalizeUV(inout vec2 uv){\n    uv = (uv * 2.0 - iResolution.xy)/iResolution.y;\n}\n\nvec3 calcFrust(vec2 uv, vec3 u, vec3 f, float fov){\n    \n    vec3 r = normalize(cross(f, u));\n    u = normalize(cross(r, f));\n    \n    return normalize(normalize(f)/fov + uv.x * r + uv.y * u);\n}\n\nvec4 sampleRay(vec2 uv){\n    \n    vec3 rD = calcFrust(uv, vec3(0, 1, 0), vec3(1, -0.3, 0), 1.0);\n    vec3 rO = vec3(-3, 1, 0);\n    \n    vec3 reflectionTint = vec3(1.0);\n    vec3 totalColor = vec3(0.0);\n    float iDist;\n    float tDist = 0.0;\n    \n    for(int i = 0; i < REFLECTION_COUNT + 1; i++){\n        \n        int ao;\n    \tfloat dist = rm(rO, rD, 0.0, MAX_DIST, ao);\n        tDist += dist;\n        if(i == 0) iDist = dist;\n        vec3 color;\n        if(dist > MAX_DIST){\n        \ttotalColor += cSky(rD)*reflectionTint;\n            break;\n        }else{\n    \t\t\n    \t\tvec3 p = rO + dist * rD;\n    \t\tvec3 n = nScene(p);\n    \t\tvec3 sunD = normalize(vec3(cos(iTime), 1, sin(iTime)));\n    \t\tvec3 ambientLight = AMBIENT_LIGHT;\n    \t\tvec3 directLight = DIRECT_LIGHT;\n    \t\tvec3 refD = rD - 2.0 * dot(n, rD) * n;\n#ifdef AO\n    \t\tambientLight *= pow(1.0 - AO_STRENGTH, float(ao));\n#endif\n#ifdef SHADOWS\n    \t\tint x;\n    \t\tfloat shadow = softShadow(p, sunD, SURF_DIST * 50.0, MAX_DIST, 0.1);\n    \t\tdirectLight *= shadow * clamp(dot(n, sunD), 0.0, 1.0);\n#ifdef SPECULAR_HIGHLIGHTS\n    \t\tvec3 highlight = DIRECT_LIGHT * specularScene(p) * shadow * pow(clamp(dot(refD, sunD), 0.0, 1.0), MATERIAL_SMOOTHNESS) * HIGHLIGHT_BRIGHTNESS;\n#endif\n#endif\n    \t\tvec3 color = albedoScene(p) * (ambientLight + directLight);\n#ifdef SHADOWS\n#ifdef SPECULAR_HIGHLIGHTS\n    \t\tcolor += highlight;\n#endif\n#endif\n#ifdef FOG\n   \t\t\tcolor = mix(cSky(rD), color, pow(1.0 - FOG_STRENGTH, max(tDist, 0.0)));\n#endif\n        \ttotalColor += color*reflectionTint;\n        \treflectionTint *= specularScene(p);\n            reflectionTint *= SPECULAR_BRIGHTNESS;\n            rD = refD;\n            rO = p + rD * SURF_DIST * 50.0;\n        }\n    }\n    \n    return vec4(totalColor, iDist);\n}\n\nvec4 render(vec2 uv){\n    \n    vec4 t = vec4(0.0);\n    \n    vec2 d = vec2(1.0, 0.0) / (iResolution.y * float(SUPER_SAMPLING));\n    \n    for(int x = 0; x < SUPER_SAMPLING; x++){\n        for(int y = 0; y < SUPER_SAMPLING; y++){\n        \tvec2 newUV = uv + float(x)*d.xy + float(y)*d.yx;\n            t += sampleRay(newUV);\n    \t}\n    }\n    \n    t /= float(SUPER_SAMPLING*SUPER_SAMPLING);\n    return t;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    normalizeUV(fragCoord);\n    fragColor = render(fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"}]}