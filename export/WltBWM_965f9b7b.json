{"ver":"0.1","info":{"id":"WltBWM","date":"1612861331","viewed":154,"name":"Bandfiltered step","username":"huwb","description":"Approximate demo - i have not spent tons of time dialing it in to minimize error. Use the mouse to control how many frequency components to add. Source in comments.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["filtering","step"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// From Ottosson, section 4.5:\n\n// https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1070.6498&rep=rep1&type=pdf\n\n// This models the residual error in a step function after filtering with a Gaussian. If drag to\n// the left, no correction is done, this is the filtered step. Drag towards the right and correction\n// functions are added one at a time, with successive higher frequencies.\n\n// For general rendering this behaviour can much better approximated with a simple smoothstep. My interest is\n// in a problem domain where I will make use of the individual correction terms that add together gracefully.\n// We will use this these correction functions in Crest Ocean System to drive multi-resolution\n// dynamic wave interactions forces. We use the red functions as the force falloff and pick the one\n// that matches the current simulation resolution.\n\n// There is a lot of ringing and it can easily be smoothed by adjusting the scale relationships by setting\n// OCTAVE_MULTIPLIER to 1.5 below. For Crest we have power of 2 octaves and we don't mind the ringing (yet).\n\n#define OCTAVE_MULTIPLIER 2.0\n\n// use these to turn off a function\n#define NO_FN\ty = 0.;col=vec4(0.); return false;\n#define NO_FN_P\tx = y = mint = maxt = 0.; col = vec4(0.); return false;\n\n// simple macros to pull mouse position in [0,1]\n#define MOUSEX\tiMouse.x/iResolution.x\n#define MOUSEY\tiMouse.y/iResolution.y\n\n#define PI 3.1415927\n#define PARAMETRIC_STEPS 100\n\nvec3 errorColour( float err, float maxerror );\n\n// the functions. return true means 'plot me'\n\nfloat bandfilteredStep(float a, float x)\n{\n    float ax = a * x;\n    float ax2 = ax * ax;\n    float ax4 = ax2 * ax2;\n    float ax6 = ax2 * ax4;\n    \n    return ax / (1.0 + ax6);\n}\n\n// cosine - dashed line\nbool fn1( float x, out float y, out vec4 col )\n{\n    y = 0.;// clamp(x, -1.5, 1.5);\n    float count = floor(8. * MOUSEX);\n\n    for(float i = 0.; i < count; i++)\n    {\n        float range = 1.67;\n        float a = pow(OCTAVE_MULTIPLIER, i) / range;\n        y += .65*bandfilteredStep(a, x);\n    }\n\tcol = vec4(1.,0.7,0.,1.);\n\t\n    {\n        float gx = x - 3.4;\n        y+= 2.*(gx > 0. ? 1.0 : exp(-.06*gx*gx));\n    }\n    return true;\n}\n\n// smoothstep - solid blue\nbool fn2( float x, out float y, out vec4 col )\n{\n\tcol = .7*vec4(1.,0.,0.,1.);\n\t\n    y = bandfilteredStep(0.6, x);\n\t\n\treturn true;\n}\n\nbool fn3( float x, out float y, out vec4 col )\n{\n\tcol = .7*vec4(1.,0.,0.,1.);\n\t\n    y = bandfilteredStep(1.2, x);\n\t\n\treturn true;\n}\n\n// algorithmic function. finds height of trochoids using fixed point iteration.\n// i presented this in a gdc talk: http://www.huwbowles.com/fpi-gdc-2016/\n// compared to the talk, this is a slightly different formulation - it computes\n// the \"error\" as the current x minus the desired x, and uses this to update t.\n// if you write this down and expand it out, it will boil down to exactly the\n// same thing.\nbool fn4( float x, out float y, out vec4 col )\n{\n\tcol = .7*vec4(1.,0.,0.,1.);\n\t\n    y = bandfilteredStep(2.4, x);\n    \n    return true;\n}\n\n// unused\nbool fn5( float x, out float y, out vec4 col )\n{\n\tcol = .7*vec4(1.,0.,0.,1.);\n\t\n    y = bandfilteredStep(4.8, x);\n    \n    return true;\n}\n\n// parametric curve - trochoids/gerstner waves\nbool pfn1( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n\tNO_FN_P;\n}\n// define a body here and then uncomment the 2nd parametric plotting code\nbool pfn2( float t, out float x, out float y, out vec4 col, out float mint, out float maxt )\n{\n\tNO_FN_P;\n}\n\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords );\n\n// p is in [0,1]. \nvec4 graph( vec2 p, float xmin, float xmax, float ymin, float ymax, float width )\n{\n\tvec4 result = vec4(0.1);\n\t\n\tfloat thisx = xmin + (xmax-xmin)*p.x;\n\tfloat thisy = ymin + (ymax-ymin)*p.y;\n\t\n\t// compute gradient between this pixel and next (seems reasonable)\n\tfloat eps = dFdx(thisx);\n\n\tfloat alpha;\n\t\n\tvec4 axisCol = vec4(vec3(.3),1.);\n\t\n\t// axes\n\t// x\n\talpha = abs( thisy - 0. ); alpha = smoothstep( width, width/4., alpha );\n\tresult = (1.-alpha)*result + alpha*axisCol;\n\t// y\n\talpha = abs( thisx - 0. ); alpha = smoothstep( width, width/4., alpha );\n\tresult = (1.-alpha)*result + alpha*axisCol;\n\t\n\t/*\n\t// show white bars to illustrate mouse position\n\tvec4 mouseBarCol = vec4(1.);\n\talpha = abs( ymin - thisy ); alpha = smoothstep( width, width/4., alpha );\n\talpha *= 1.-step(MOUSEX,p.x);\n\tresult = (1.-alpha)*result + alpha*mouseBarCol;\n\talpha = abs( xmin - thisx ); alpha = smoothstep( width, width/4., alpha );\n\talpha *= 1.-step(MOUSEY,p.y);\n\tresult = (1.-alpha)*result + alpha*mouseBarCol;\n\t*/\n\t\n\t// uses iq's awesome distance to implicit https://iquilezles.org/articles/distance\n\tfloat f;\n\tvec4 fcol;\n\tif( fn5( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn5( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn4( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn4( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn3( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn3( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn2( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn2( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\tif( fn1( thisx, f, fcol ) )\n\t{\n\t\tfloat f_1; fn1( thisx + eps, f_1, fcol ); float f_prime = (f_1 - f) / eps;\n\t\talpha = abs(thisy - f)/sqrt(1.+f_prime*f_prime); alpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t}\n\t\n\t// parametric curves. todo - join the dots!\n\tfloat x, mint, maxt;\n\tif( pfn1( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn1( t, x, f, fcol, mint, maxt );\n\t\t\talpha = length(vec2(x,f)-vec2(thisx,thisy));\n\t\t\talpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t// uncomment to add a second parametric plot\n\t/*\n\tif( pfn2( 0., x, f, fcol, mint, maxt ) )\n\t{\n\t\tfloat dt = (maxt-mint)/float(PARAMETRIC_STEPS);\n\t\tfloat t = mint;\n\t\tfor( int i = 0; i <= PARAMETRIC_STEPS; i++ )\n\t\t{\n\t\t\tpfn2( t, x, f, fcol, mint, maxt );\n\t\t\talpha = length(vec2(x,f)-vec2(thisx,thisy));\n\t\t\talpha = smoothstep( width, width/4., alpha ); alpha *= fcol.a;\n\t\t\tresult = (1.-alpha)*result + alpha*fcol;\n\t\t\tt += dt;\n\t\t}\n\t}\n\t*/\n\t\n\tresult += vec4(drawNumber(xmin, vec2(0.,0.)+vec2(1.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(xmax, vec2(1.,0.)+vec2(-26.,1.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(ymax, vec2(0.,1.)+vec2(1.,-7.)/iResolution.xy, p ));\n\tresult += vec4(drawNumber(ymin, vec2(0.,0.)+vec2(1.,10.)/iResolution.xy, p ));\n\t\n\treturn result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n \n\tfragColor = graph( uv, -5.0, 5.0, -3., 3., .01 );\n\n\treturn;\n}\n\n\n// digits based on the nice ascii shader by movAX13h\n\nfloat drawDig( vec2 pos, vec2 pixel_coords, float bitfield )\n{\n\t// offset relative to \n\tvec2 ic = pixel_coords - pos ;\n\tic = floor(ic*iResolution.xy);\n\t// test if overlap letter\n\tif( clamp(ic.x, 0., 2.) == ic.x && clamp(ic.y, 0., 4.) == ic.y )\n\t{\n\t\t// compute 1d bitindex from 2d pos\n\t\tfloat bitIndex = ic.y*3.+ic.x;\n\t\t// isolate the bit\n\t\treturn floor( mod( bitfield / exp2( floor(bitIndex) ), 2. ) );\n\t}\n\treturn 0.;\n}\n// decimal point\nfloat drawDecPt( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 1. );\n}\n// minus sign\nfloat drawMinus( vec2 center, vec2 pixel_coords )\n{\n\treturn drawDig( center, pixel_coords, 448. );\n}\n// digits 0 to 9\nfloat drawDigit( float dig, vec2 pos, vec2 pixel_coords )\n{\n\tif( dig == 1. )\n\t\treturn drawDig( pos, pixel_coords, 18724. );\n\tif( dig == 2. )\n\t\treturn drawDig( pos, pixel_coords, 31183. );\n\tif( dig == 3. )\n\t\treturn drawDig( pos, pixel_coords, 31207. );\n\tif( dig == 4. )\n\t\treturn drawDig( pos, pixel_coords, 23524. );\n\tif( dig == 5. )\n\t\treturn drawDig( pos, pixel_coords, 29671. );\n\tif( dig == 6. )\n\t\treturn drawDig( pos, pixel_coords, 29679. );\n\tif( dig == 7. )\n\t\treturn drawDig( pos, pixel_coords, 31012. );\n\tif( dig == 8. )\n\t\treturn drawDig( pos, pixel_coords, 31727. );\n\tif( dig == 9. )\n\t\treturn drawDig( pos, pixel_coords, 31719. );\n\t// 0\n\treturn drawDig( pos, pixel_coords, 31599. );\n}\n\n// max num width is 26px (minus, 3 nums, dec pt, 2 nums)\n// max height is 6px\nfloat drawNumber( float num, vec2 pos, vec2 pixel_coords )\n{\n\tfloat result = 0.;\n\tbool on = false;\n\tfloat d;\n\t\n\t// minus sign\n\tif( num < 0. )\n\t{\n\t\tresult += drawMinus( pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\tnum = -num;\n\t}\n\t// hundreds\n\td = floor(mod(num/100.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// tens\n\td = floor(mod(num/10.,10.));\n\tif( on || d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t\ton = true;\n\t}\n\t// ones\n\td = floor(mod(num,10.));\n\tresult += drawDigit( d, pos, pixel_coords );\n\tpos.x += 4. / iResolution.x;\n\t// dec pt\n\tresult += drawDecPt( pos, pixel_coords );\n\tpos.x += 2. / iResolution.x;\n\t// tenths\n\td = floor(mod(num/.1,10.));\n\tif( true )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t// hundredths\n\td = floor(.5+mod(num/.01,10.));\n\tif( d > 0. )\n\t{\n\t\tresult += drawDigit( d, pos, pixel_coords );\n\t\tpos.x += 4. / iResolution.x;\n\t}\n\t\n\treturn clamp(result,0.,1.);\n}\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\nvec3 errorColour( float err, float maxerror )\n{\n\terr = 1. - err / maxerror;\n\terr *= 2. / 3.;\n\treturn hsv2rgb( vec3(err, 1., 1.) );\n}\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n","name":"Image","description":"","type":"image"}]}