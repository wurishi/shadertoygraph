{"ver":"0.1","info":{"id":"stSGzm","date":"1623560369","viewed":99,"name":"a pixelation","username":"yunhai","description":"ha","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["pixelation","pass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst float MaxWidth=10.;\nvec3 pixelation(vec2 coord,float t,vec2 resolution,int mode)\n{\n    //rate fix\n    vec2 R=resolution;\n    coord.x+=(R.y*iR.x/iR.y-R.x)*.5;//cut left/right side\n    coord.x*=R.x/R.y/(iR.x/iR.y);\n    \n    float w=floor(min(sin(t*2.)*MaxWidth+MaxWidth\n    ,MaxWidth)+1.);\n    vec2 dcoord = floor(coord/w)*w;\n    vec3 col=vec3(0);\n    \n    switch(mode)\n    {\n        case(0)://get average\n            for(float i=0.;i<w-.1;i++)\n            for(float j=0.;j<w-.1;j++)\n            col+=texture(iChannel0,(dcoord+vec2(i,j))/resolution).xyz;\n            col/=w*w;\n            break;\n        case(1)://get part average\n            float k=0.;\n            for(float i=0.;i<w*.3-.1;i++)\n            for(float j=0.;j<w*.3-.1;j++)\n            {\n                col+=texture(iChannel0,(dcoord+vec2(i,j))/resolution).xyz;\n                k++;\n            }\n            col/=k;\n            break;\n        case(2)://center represent\n            col=texture(iChannel0,(dcoord+vec2(1)*w*.5)/resolution).xyz;  \n            break;\n        case(3)://random pos sampling\n            col=texture(iChannel0,(dcoord+floor(hash22(dcoord)*w))/resolution).xyz;  \n            break;\n        case(4)://normal\n            col=texture(iChannel0,coord/resolution).xyz;  \n            break;\n\n    }\n    return col;\n}\nbool Equals(float a,float b)\n{\n    return abs(a-b)<1e-2;\n}\n\nvoid mainImage( out vec4 O, in vec2 C )\n{  \n    \n\n    float T=iTime;\n    vec2 R = iR.xy/vec2(3.,2.),//cell resolution\n    ID=floor(C/R);\n    C=(C-ID*R);\n\n    /*\n    if(C.x<R.x*.5)\n        if(C.y>R.y*.5)\n            O.rgb=pixelation(C+vec2(R.x/4.,R.y),T,0);\n        else\n        {\n        }\n    else\n        O.rgb=pixelation(C-vec2(R.x/4.,0),T,1);*/\n    O*=0.;\n    if(Equals(ID.x,0.) && Equals(ID.y,1.))\n        O.rgb=pixelation(C,T,R,0);\n    if(Equals(ID.x,1.) && Equals(ID.y,1.))\n        O.rgb=pixelation(C,T,R,1);\n    if(Equals(ID.x,0.) && Equals(ID.y,0.))\n        O.rgb=pixelation(C,T,R,2);\n    if(Equals(ID.x,1.) && Equals(ID.y,0.))\n        O.rgb=pixelation(C,T,R,3);\n    if(Equals(ID.x,2.) && Equals(ID.y,1.))\n        O.rgb=pixelation(C,T,R,4);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//based on the BigWing's smiley tutorial\nvec3 mix(vec3 a,vec3 b, float t)\n{\n    if(t<0.)\n        return a;\n    if(t>1.)\n        return b;\n    return a*(1.-t)+b*t;//lerp(a,b,t);\n}\nfloat sat(float a)\n{\n    return clamp(a,0.,1.);\n}\nfloat remap(float a,float b,float c,float d,float t)\n{\n    t=(t-a)/(b-a);\n    return sat(t*(d-c)+c);\n}\nvec2 within(vec2 uv,vec4 rect)//x0,y0,x1,y1\n{\n    return (uv-rect.xy)/(rect.zw-rect.xy);\n}\n#define SS(a,b,t) smoothstep(a,b,t)\n\nvoid mainImage( out vec4 fragColor, in vec2 C )\n{\n    vec2 uv=(C-.5*iResolution.xy)/iResolution.y;\n    vec2 buv=uv;//backup\n    vec3 col=vec3(0.);\n    float t=iTime;\n    \n    //face\n    float d=length(uv); \n    float faceMusk=SS(.30,.29,d);\n    col= faceMusk*vec3(.9,.65,.1);\n    \n    //face edge\n    vec3 yellow=vec3(.8,.45,.1);\n    col=mix(col,yellow,pow((SS(.15,.30,d) ),2.)*faceMusk);\n        // Output to screen\n\n    //face outline\n    col=mix(col,vec3(.67,.20,.1),SS(.28,.29,d)*faceMusk);\n    \n\n    //face highlight\n    float highlight=SS(.26,.258,d);\n    highlight*=remap(0.,.26,0.,.70,uv.y);\n    col=mix(col,vec3(1.),highlight);\n    \n\n    \n    //mirror mode\n    float side=sign(uv.x);\n    uv.x=side*uv.x;\n    //cheek\n    d=length(uv-vec2(0.19,-0.1));\n    col=mix(col,vec3(.9,0,0),SS(.12,.01,d)*0.4);\n    \n    //eye\n    float eyeD=0.2;\n    vec4 eyeRect;\n    eyeRect.xy=vec2(0.02,-0.05);\n    eyeRect.zw=eyeRect.xy+eyeD;\n    uv=within(uv,eyeRect);\n    uv-=.5;\n    d=length(uv);\n    float eyeMusk=SS(.5,.49,d);\n    vec3 blue=vec3(.5,.6,.8);\n    //eye outline shadow\n    col=mix(col,vec3(.8,.35,0),SS(.51,.50,length(uv-vec2(0.01,0.01))));\n    vec3 eye=mix(vec3(1.),blue,0.35*(pow(2.*d,3.)));\n    //eye inner outline Shadow\n    eye*=1.-SS(.45,.5,d)*(uv.y+0.5);\n    //blue out iris\n    eye=mix(vec3(0.),eye,SS(0.3,0.31,d));\n    //inner iris\n    vec3 irisColor=mix(vec3(.15,.15,.6),blue,SS(.29,.1,d)*(d+1.)*(d+1.));//(1+SS(.29,.02,d)*0.5));\n    eye=mix(eye,irisColor,SS(.28,.24,d));\n    //pupil\n    float eyeWave=0.02*sin(t)+0.02;\n    eye=mix(eye,vec3(0.),SS(.18+eyeWave,.17+eyeWave,d));\n    //eye highlight\n    uv.x*=side;\n    vec2 offset=0.03*vec2(sin(t+uv.y*7.),sin(t+uv.x*7.+1.));\n    uv+=offset;\n    d=length(uv-vec2(-0.16,0.16));\n    highlight=SS(0.13,0.12,d);\n    d=length(uv-vec2(0.1,-0.13));\n    highlight+=SS(0.11,0.1,d);\n    eye+=highlight;\n    col=mix(col,eye,eyeMusk);\n    \n    \n    //mouth\n    float hl=.18;\n    float hh=hl/3.5;\n    uv=within(buv,vec4(-hl,-hh-.15,hl,hh-.15))-.5;\n    //mouthShape\n    float mouthWave=sin(t);\n    uv.y-=pow(uv.x,2.)*(mouthWave*0.5+2.);\n    uv.x*=mix(1.7,1.3,mouthWave*0.5+0.5);\n    d=length(uv);\n    float mouthMusk=SS(.5,.49,d);\n    vec3 mouth=yellow*0.3;\n    //teeth \n    d=length(uv-vec2(0.,0.6));\n    mouth=mix(mouth,vec3(2.62-uv.y*4.5),SS(0.4,0.38,d));//teeth with shadow\n    //touge\n    d=length(uv+vec2(0,0.4));\n    mouth=mix(mouth,vec3(.9,.5,.5),SS(0.4,0.1,d));\n    col=mix(col,mouth,mouthMusk);\n    \n    \n    //drip\n    //tri\n    uv=buv;\n    vec2 pos=vec2(.2,.15+sin(t)*.015);\n    uv-=pos;\n    float dripmusk;\n    float h=.07;\n    dripmusk=SS(-h-0.01,-h,uv.y);\n    uv.y/=1.732;\n    dripmusk*=SS(0.001,0.,uv.x+uv.y);\n    dripmusk*=SS(0.001,0.,-uv.x+uv.y);       \n    //round     \n    float r=h*2./3.;\n    uv=buv-pos+vec2(0.,h*4./3.);\n    uv.y+=0.0008*(sin(t*9.+uv.x*190.)+0.8)*sqrt(length(remap(0.,r,0.,1.,sat(-uv.y))));//wave the bottom of round \n    dripmusk+=SS(r+0.001,r,length(uv));\n    dripmusk=sat(dripmusk);\n    vec3 skyblue=vec3(.4,.5,1.);\n    vec3 drip=dripmusk*skyblue;\n    drip=mix(drip,vec3(0.),SS(r-0.015,r-0.001,length(uv))*(10.*(uv.x-uv.y)));\n    //light\n    float dripWave=sin(t*3.)*0.2+0.2;\n    drip=mix(drip, vec3(.8),SS(dripWave,dripWave+0.1,length(uv-vec2(.1,-.1)))*SS(dripWave+0.1,dripWave,length(uv-vec2(.1,-.1))));\n    \n    col=mix(col,drip,dripmusk);\n    \n    // Output to screen\n    fragColor = vec4(col,faceMusk);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define iR iResolution\nfloat hash21(vec2 uv)\n{\n    return fract(fract(sin(uv.x*115.)*919.)+fract(cos(uv.y*23.)*241.));\n}\nvec2 hash22(vec2 uv)\n{\n    float t=hash21(uv);\n    return vec2(t,hash21(vec2(t,t)));\n}\n","name":"Common","description":"","type":"common"}]}