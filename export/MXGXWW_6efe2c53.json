{"ver":"0.1","info":{"id":"MXGXWW","date":"1719938305","viewed":215,"name":"Refractive","username":"chronos","description":"A brute force numerical integration of light paths refracted through a disc.\nOnly refraction in this one, no reflection or other effects.","likes":21,"published":1,"flags":0,"usePreview":1,"tags":["2d","simple","refraction","numerical","path","integration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n    Refractive by chronos\n    ----------------------------------------------------------------------------\n    \n    A brute force numerical integration of light paths refracted through a disc.\n    Only refraction in this one, no reflection or other effects.\n    \n    Thanks to @fad for help with getting the correct refraction :)\n    (At least I *think* they are correct!)\n    \n    self link: https://www.shadertoy.com/view/MXGXWW\n    \n    ----------------------------------------------------------------------------\n*/\n\nconst float PI = 3.14159265;\nconst float num_rays = 2000.;\nconst float num_bounces = 3.;\n\nconst float index_of_refraction = 1.52;\n\nfloat sRGBencode(float C_linear) { return C_linear > 0.0031308 ? (1.055 * pow(C_linear, 1./2.4) - 0.055) : (12.92 * C_linear); }\nvec3 sRGBencode(vec3 C_linear) { C_linear = clamp(C_linear, 0., 1.); return vec3(sRGBencode(C_linear.x), sRGBencode(C_linear.y), sRGBencode(C_linear.z)); }\n    \nfloat seg(vec2 a, vec2 b, vec2 p)\n{\n    b-=a; p-=a;\n    return length(clamp(dot(p, b)/dot(b,b), 0., 1.) * b - p);\n}\n\n// Returns two intersections as ray parameter values rd*t+ro, or negative values for no interseciton.\n// Entering intersection in first component, exiting intersection in second component.\nvec2 ray_circle_intersect(vec2 ro, vec2 rd, vec2 center, float radius)\n{\n    // translate to ray origin as origin.\n    // ro -= ro;\n    center -= ro;\n    \n    // project center onto ray:\n    \n    float scalar_proj = dot(center, rd)/dot(rd,rd);\n    \n    vec2 proj = scalar_proj * rd;\n    vec2 rej = center - proj;\n    \n    float y2 = dot(rej, rej); // squared length of rejection vector (center to center projection)\n    \n    float x2 = radius * radius - y2; // distance squared from the projection to the circle along the ray.\n    \n    if(x2 < 0.) return vec2(-1);\n    \n    return scalar_proj + sqrt(x2) * vec2(-1,1); \n}\n\nfloat get_closest_hit(vec2 hitresults)\n{\n    return hitresults.x > 0. ? hitresults.x : hitresults.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2. * iMouse.xy-iResolution.xy)/iResolution.y;\n\n    if(length(iMouse.xy) < 10.) mouse = vec2(.5*cos(iTime)-1., .5*sin(iTime));\n\n    float ps = 2. / iResolution.y;\n    vec3 col = vec3(0);\n        \n    vec2 center = vec2(.25,.0);\n    float radius = 0.5;\n    \n    vec2 light_pos = mouse;\n    float light_radius = 0.1;\n    \n    #if 1\n    // Draw circle outline\n    col = mix(col, vec3(1,1,1), .125*smoothstep(2. *ps, .5*ps, abs(length(center-uv)-radius)));\n    #endif\n        \n    for(float i = 0.; i < num_rays; i++)\n    {\n        float angle = 2. * PI * (i/num_rays);\n        \n        vec2 ro = uv;\n        \n        #if 1\n        // Suggestion by @fad to jitter starting position within the pixel\n        ro += ps * (-.5 + texture(iChannel0, fract(fragCoord/1024. + i/num_rays))).rg; \n        #endif\n        \n        vec2 rd = vec2(cos(angle), sin(angle));\n        \n        bool inside = length(ro-center) < radius;\n    \n        for(float j = 0.; j < num_bounces; j++)\n        {\n            // Cast ray\n            \n            // If intersects light, add light contribution and terminate ray\n            vec2 light_result = ray_circle_intersect(ro, rd, light_pos, light_radius);\n            float light_t = get_closest_hit(light_result);\n            \n            // If intersects sphere, keep bouncing:\n            vec2 circle_result = ray_circle_intersect(ro, rd, center, radius);\n            float circle_t = circle_result[int(inside)];\n            \n            // If we neither hit the circle nor the light, we didn't hit anything with this ray, so we try the next one.\n            if((circle_t <= 0.) && (light_t <= 0.)) break;\n            \n            // We hit something, so check which we hit first\n            if(circle_t > 0. && (circle_t < light_t || light_t <= 0.))\n            {\n                // Hit the circle first, refract\n                inside = !inside;\n                ro += rd * circle_t;\n                vec2 N = (inside ? 1. : -1.) * normalize(ro - center);\n                rd = refract(rd, N, inside?1./index_of_refraction:index_of_refraction);\n                \n                // Handle the case of total internal reflection. \n                // Refract can return vec2(0), which can cause NaNs later if rd is set to that value, so we break instead.\n                // Thanks to @elenzil for reporting the issue, and @pyBlob for finding the cause :)\n                if (rd == vec2(0)) break;\n            } \n            else // We hit the light\n            {\n                col += (2. * PI)/num_rays;\n                break;\n            }\n        }\n    }\n    \n    #if 1\n    col = tanh(col);\n    #endif\n    \n    #if 1\n    col = sRGBencode(col); \n    #else\n    col = pow(color, vec3(1./2.2));\n    #endif\n    \n    #if 1\n    col += 1./255. * (-1. + 2.  * texture(iChannel0, fragCoord/1024.)[iFrame%4]);\n    #endif\n    \n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}