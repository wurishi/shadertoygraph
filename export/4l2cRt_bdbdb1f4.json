{"ver":"0.1","info":{"id":"4l2cRt","date":"1509785607","viewed":949,"name":"MacSearlas erosion","username":"FlorentTournade","description":"Raymarched version here: https://www.shadertoy.com/view/XlBcDG\n\n//Adapted from cpu by Florent Tournade\n//original algorithm by \"YankeeMinstrel\" ( https://www.reddit.com/r/proceduralgeneration/comments/797fgw/iterative_pseudoerosion/ )","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["fractal","erosion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//THIS IS WIP, DOESN'T FULLY WORK YET !!! (Feel free to contribute)\n//there's an issue when wsPos is negative (comment #define NEGATIVE_POS_BUG_WORKAROUND to see)\n//and at grid boundaries\n\n//Adapted from cpu by Florent Tournade\n//original algorithm by \"YankeeMinstrel\" ( https://www.reddit.com/r/proceduralgeneration/comments/797fgw/iterative_pseudoerosion/ )\n//cpu re-implementation by \"smcameron\" ( https://github.com/smcameron/pseudo-erosion )\n//uses bicubic filtered noise from https://www.shadertoy.com/view/4df3Dn\n\n//TODO: -try adding some distortion\n\n#define BICUBIC //how the baseheighmap samplesthe noise texture\n#define EROSION_OCTAVE_MODE 3 //0: only base map / 1: one erosion octave / 2: fbm style / 3: MacSearlas style \n#define NEGATIVE_POS_BUG_WORKAROUND\n#define GRIDSIZE 100.0\n#define BASE_HEIGHT 0.9\n#define EROSION_HEIGHT 0.6\n\n// w0, w1, w2, and w3 are the four cubic B-spline basis functions\nfloat w0(float a)\n{\n    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0);\n}\n\nfloat w1(float a)\n{\n    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0);\n}\n\nfloat w2(float a)\n{\n    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0);\n}\n\nfloat w3(float a)\n{\n    return (1.0/6.0)*(a*a*a);\n}\n\n// g0 and g1 are the two amplitude functions\nfloat g0(float a)\n{\n    return w0(a) + w1(a);\n}\n\nfloat g1(float a)\n{\n    return w2(a) + w3(a);\n}\n\n// h0 and h1 are the two offset functions\nfloat h0(float a)\n{\n    return -1.0 + w1(a) / (w0(a) + w1(a));\n}\n\nfloat h1(float a)\n{\n    return 1.0 + w3(a) / (w2(a) + w3(a));\n}\n\nvec4 texture_bicubic(sampler2D tex, vec2 uv, vec4 texelSize)\n{\n\tuv = uv*texelSize.zw + 0.5;\n\tvec2 iuv = floor( uv );\n\tvec2 fuv = fract( uv );\n\n    float g0x = g0(fuv.x);\n    float g1x = g1(fuv.x);\n    float h0x = h0(fuv.x);\n    float h1x = h1(fuv.x);\n    float h0y = h0(fuv.y);\n    float h1y = h1(fuv.y);\n\n\tvec2 p0 = (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p1 = (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy;\n\tvec2 p2 = (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\tvec2 p3 = (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy;\n\t\n    return g0(fuv.y) * (g0x * texture(tex, p0)  +\n                        g1x * texture(tex, p1)) +\n           g1(fuv.y) * (g0x * texture(tex, p2)  +\n                        g1x * texture(tex, p3));\n}\n\nfloat BaseHeightmap( vec2 uv )\n{\n    uv *= 0.00001;\n        \n#ifdef BICUBIC\n    vec4 texelSize = vec4( 1.0 / iChannelResolution[0].xy,  iChannelResolution[0].xy); \n\tfloat noise = texture_bicubic( iChannel0, uv, texelSize ).x;\n#else\n    float noise = texture( iChannel0, uv ).x;\n#endif\n    return noise;\n}\n\nfloat sqr( float x ) { return x * x; }\n\nvec2 hash2( ivec2 p ) { return fract(sin( float(p.x) + float(p.y) * vec2(793.34,934.78) ) * vec2(12345.0,5432.0))-0.5; }\n\nfloat sdLine( vec2 p, vec2 a, vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h );\n}\n\nfloat PseudoErosion( vec2 pos, float gridSize )\n{\n    ivec2 pi = ivec2(0.5 + pos/gridSize);\n\n    float minh = 1e20;\n    \n    float dm = 0.0;\n    for( int j=-1; j<=1 ; j++ )\n    for( int i=-1; i<=1 ; i++ )\n    {\n        ivec2 pa = pi + ivec2(i,j);\n        \n        vec2  p1 = (vec2(pa) + hash2(pa)) * gridSize;\n\n        vec2 p2;\n        float lowestNeighbor = 1e20;\n\n        for( int n=-1 ; n<=1 ; n++ )\n        for( int m=-1 ; m<=1 ; m++ )\n        {\n            ivec2 pb = pa + ivec2(m,n);\n            vec2 candidate = (vec2(pb) + hash2(pb)) * gridSize;\n\n            float height = BaseHeightmap( candidate );\n            if( height < lowestNeighbor )\n            {\n                p2 = candidate;\n                lowestNeighbor = height;\n            }\n        }\n\n        float h = sdLine( pos, p1, p2 );\n        minh = min(h,minh);\n    }\n\n    minh = minh/gridSize;\n    return minh;\n}\n\nfloat PseudoErosionFractal( vec2 wsPos )\n{\n\tfloat baseHeight = BaseHeightmap( wsPos );\n\n#if (EROSION_OCTAVE_MODE == 0)\n\tfloat erosion = 0.0;\n    \n#elif (EROSION_OCTAVE_MODE == 1)\n\t//1 erosion octave\n    float erosion = PseudoErosion( wsPos, GRIDSIZE );\n    \n#elif (EROSION_OCTAVE_MODE == 2)\n    //fbm style\n\n    float erosion = 0.0;\n    \n    const int numOctaves = 4;\n    \n    float scale = 1.0f;\n    float gridSize = GRIDSIZE;\n    \n    for( int i=0 ; i < numOctaves ; ++i )\n    {\n\t    erosion += PseudoErosion( wsPos, gridSize ) * scale;\n        scale *= 0.5;\n        gridSize *= 0.5;\n    }\n\n#elif (EROSION_OCTAVE_MODE == 3)\n    //MacSearlas  style\n \n    float r1 = PseudoErosion( wsPos, GRIDSIZE );\n\tfloat erosion = sqr(r1);\n    \n    float r2 = PseudoErosion( wsPos, GRIDSIZE / 2.0 );\n    erosion += r1 * r2 / 2.0;\n    \n    float r3 = PseudoErosion( wsPos, GRIDSIZE / 4.0 );\n\terosion += sqrt(r1*r2)*r3 / 3.0;\n\n#endif\n    return baseHeight * BASE_HEIGHT + erosion * EROSION_HEIGHT;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy) / iResolution.xy;\n    vec2 wsPos = (p - 0.5) * 4000.0 * ( sin( iTime * 0.3 ) + 1.0 );\n\n#ifdef NEGATIVE_POS_BUG_WORKAROUND\n    wsPos += 8000.0f;\n#endif\n    \n    float map = PseudoErosionFractal( wsPos );\n    \n    fragColor = vec4( map, map, map, 1.0 );\n}","name":"Image","description":"","type":"image"}]}