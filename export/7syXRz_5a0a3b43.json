{"ver":"0.1","info":{"id":"7syXRz","date":"1634240823","viewed":85,"name":"SDF Jack Skellington","username":"AlexXIIs","description":"Jack Skellington model made using SDFs","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Common\n\n\n// Hashing function\n// Returns a random number in [-1,1]\nfloat Hash(float seed)\n{\n  return fract(sin(seed)*43758.5453);\n}\n\n// Cosine direction\nvec3 Cosine(in float seed,in vec3 nor)\n{\n  float u=Hash(78.233+seed);\n  float v=Hash(10.873+seed);\n  \n  // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html\n  float a=6.2831853*v;\n  u=2.*u-1.;\n  return normalize(nor+vec3(sqrt(1.-u*u)*vec2(cos(a),sin(a)),u));\n}\n\n// Rotation matrix around z axis\n// a : Angle\nmat3 rotate_z(float a)\n{\n  float sa=sin(a);float ca=cos(a);\n  return mat3(ca,sa,0.,-sa,ca,0.,0.,0.,1.);\n}\n\n// Compute the ray\n// m : Mouse position\n// p : Pixel\n// ro, rd : Ray origin and direction\nvoid Ray(in vec2 m,in vec2 p,out vec3 ro,out vec3 rd)\n{\n  float a=3.*3.14*m.x;\n  float le=5.;\n \n  ro=vec3(40.,0.,-1.);\n  ro*=rotate_z(3.*3.14*m.x);\n  \n  vec3 ta=vec3(0.,0.,1.);\n  vec3 ww=normalize(ta-ro);\n  vec3 uu=normalize(cross(ww,vec3(0.,0.,1.)));\n  vec3 vv=normalize(cross(uu,ww));\n  rd=normalize(p.x*uu+p.y*vv+le*ww);\n  rd.z -= 0.1;\n}\n\n// Main\n\nconst int Steps=1000;\nconst float Epsilon=.005;// Marching epsilon\nconst float T=.5;\n\nconst float rA=10.;// Maximum and minimum ray marching or sphere tracing distance from origin\nconst float rB=40.;\n\n// Transforms\nvec3 rotateX(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(p.x,ca*p.y-sa*p.z,sa*p.y+ca*p.z);\n}\n\nvec3 rotateY(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.z,p.y,-sa*p.x+ca*p.z);\n}\n\nvec3 rotateZ(vec3 p,float a)\n{\n  float sa=sin(a);\n  float ca=cos(a);\n  return vec3(ca*p.x+sa*p.y,-sa*p.x+ca*p.y,p.z);\n}\n\nvec3 translateX(vec3 p,float a)\n{\n  return vec3(p.x+a,p.y,p.z);\n}\n\nvec3 translateY(vec3 p,float a)\n{\n  return vec3(p.x,p.y+a,p.z);\n}\n\nvec3 translateZ(vec3 p,float a)\n{\n  return vec3(p.x,p.y,p.z+a);\n}\n\n// Smooth cubic falloff function\n// x : distance\n// R : radius\nfloat falloff(float x,float R)\n{\n  float u=clamp(x/R,0.,1.);\n  float v=(1.-u*u);\n  return v*v*v;\n}\n\n// Primitives\n\n// Point skeleton\n// p : point\n// c : center of skeleton\n// e : energy associated to skeleton\n// R : radius\nfloat point(vec3 p,vec3 c,float e,float R)\n{\n  return e*falloff(length(p-c),R);\n}\n\n// Operators\n\n// Blending\n// a,b : field function of the sub-trees\nvec4 ColorBlend(vec4 a,vec4 b)\n{\n  return vec4(a.x+b.x, ((a.yzw*a.x+b.yzw*b.x)/(a.x+b.x)));\n}\n\n// Union\n// a : field function of left sub-tree\nvec4 ColorIntersection(vec4 a,vec4 b)\n{\n  vec3 color;\n  if(a.x<b.x)\n  {\n    color = a.yzw;\n  }\n  else\n  {\n    color = b.yzw;\n  }\n  return vec4(max(a.x,b.x), color);\n}\n\n\nvec4 ColorSubstraction(vec4 a,vec4 b)\n{\n  vec3 color;\n  if(a.x>-b.x)\n  {\n    color = a.yzw;\n  }\n  else\n  {\n    color = b.yzw;\n  }\n  return vec4(max(a.x,-b.x), color);\n}\n\nvec4 ColorUnion(vec4 a,vec4 b)\n{\n  vec3 color;\n  if(a.x<b.x)\n  {\n    color = a.yzw;\n  }\n  else\n  {\n    color = b.yzw;\n  }\n  return vec4(min(a.x,b.x), color);\n}\n\n\nvec3 turbulence(in vec3 p)\n{\n    return vec3(0.01*sin(p.x*60.), 0.1*cos(p.y*20.)*sin(p.x*60.), 0.1*sin(p.z*5.));\n}\n\n\n//////////////////////////////\n// PRIMITIVES //\n//////////////////////////////\n\n// https://iquilezles.org/articles/distfunctions\n\nvec4 SDFSphere( vec3 p, vec3 c, float s, vec3 color)\n{\n  return vec4(length(p-c)-s, color);\n}\n\nvec4 SDFEllipsoid(vec3 p, vec3 c, vec3 r, vec3 color)\n{\n  float k0 = length((p-c)/r);\n  float k1 = length((p-c)/(r*r));\n  return vec4(k0*(k0-1.0)/k1, color);\n}\n\nvec4 SDFTorus(vec3 p, vec2 t, vec3 c, vec3 color)\n{\n  vec2 q = vec2(length(p.xz-c.xz)-t.x,p.y-c.y);\n  return vec4(length(q)-t.y, color);\n}\n\nvec4 SDFSegment(vec3 p, vec3 a, vec3 b, float r, vec3 color)\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return vec4(length( pa - ba*h ) - r, color);\n}\n\nvec4 SDFBox(vec3 p, vec3 b, vec3 color)\n{\n  vec3 q = abs(p) - b;\n  return vec4(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0), color);\n}\n\n\nvec4 SDFCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb, vec3 color)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n    float x = sqrt( papa - paba*paba*baba );\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    return vec4(s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) ), color);\n}\n\nvec4 SDFPlane( vec3 p, vec3 n, float h, vec3 color)\n{\n  return vec4(dot(p,n) + h, color);\n}\n\n// Potential field of the object\n// p : point\nvec4 Object(vec3 p)\n{\n  vec3 floorP = translateZ(p, 8.5);\n\n  p = rotateY(p, -.2);\n\n  // Tete\n  vec3 headCenter = vec3(0.,0.,0.);\n  vec3 headP = translateX(p, -0.5);\n  headP = rotateY(headP, -0.2);\n  headP = rotateX(headP, 0.1);\n  headP = rotateZ(headP, 0.2);\n  vec3 eyesP = headP;\n  headP = rotateZ(headP, -1.5);\n  vec4 head = SDFSphere(headP, headCenter, 0.6, vec3(.9,.9,.9));\n  \n  // Bouche\n  vec3 mouthP = rotateX(headP, -0.5);\n  vec3 mouthCenter = vec3(0.01, 0.3, 0.5);\n  vec4 mouth = SDFTorus(mouthP - turbulence(mouthP), vec2(0.95,0.13), mouthCenter, vec3(0.,0.,0.));\n  \n  //Nez\n  vec4 leftNose = SDFSegment(p, vec3(1.1, 0.1, -0.15), vec3(1.1, 0.1, -0.1), 0.03, vec3(0.,0.,0.));\n  vec4 rightNose = SDFSegment(p, vec3(1.1, 0.15, -0.15), vec3(1.1, 0.15, -0.1), 0.04, vec3(0.,0.,0.));\n  \n  vec4 nose = ColorUnion(leftNose, rightNose);\n  head = ColorSubstraction(head, nose);\n  \n  head = ColorSubstraction(head, mouth);\n  \n  // Transfo pour yeux\n  vec3 leftEyeP = translateZ(eyesP, -0.25);\n  leftEyeP = translateX(leftEyeP, -0.5);\n  leftEyeP = translateY(leftEyeP, 0.2);\n  leftEyeP = rotateX(leftEyeP, 0.4);\n  leftEyeP = rotateZ(leftEyeP, -0.4);\n  leftEyeP = rotateY(leftEyeP, 0.);\n  \n  vec3 rightEyeP = translateZ(eyesP, -0.3);\n  rightEyeP = translateX(rightEyeP, -0.5);\n  rightEyeP = translateY(rightEyeP, -0.2);\n  rightEyeP = rotateX(rightEyeP, -0.4);\n  rightEyeP = rotateZ(rightEyeP, 0.4);\n  rightEyeP = rotateY(rightEyeP, 0.);\n  \n  // Yeux\n  vec4 halfeye1 = SDFEllipsoid(leftEyeP, vec3(0,0,0.05), vec3(0.1,0.2,0.25), vec3(0.,0.,0.));\n  vec4 halfeye2 = SDFEllipsoid(leftEyeP, vec3(0,0,0.2), vec3(0.3,0.2,0.15), vec3(1.,1.,1.));\n  vec4 halfeye3 = SDFEllipsoid(rightEyeP, vec3(0,0,0), vec3(0.1,0.2,0.25), vec3(0.,0.,0.));\n  vec4 halfeye4 = SDFEllipsoid(rightEyeP, vec3(0,0,0.1), vec3(0.3,0.2,0.15), vec3(1.,1.,1.));\n  vec4 eye1 = ColorSubstraction(halfeye1, halfeye2);\n  vec4 eye2 = ColorSubstraction(halfeye3, halfeye4);\n  vec4 eyes = ColorUnion(eye1, eye2);\n  head = ColorSubstraction(head, eyes);\n  \n  // Corps\n  vec4 neck = SDFSegment(p, vec3(0.5,0.,0.), vec3(0.,0.,-1.5), 0.1, vec3(1.,1.,1.));\n  head = ColorUnion(head, neck);\n  \n  vec4 torso = SDFCappedCone(p, vec3(0.,0.,-1.), vec3(0.,0.,-3.), 1., 0.4, vec3(0.,0.,0.));\n  \n  torso = ColorSubstraction(torso, SDFPlane(p, vec3(-0.9,0.,0.1), 0.45, vec3(0.,0.,0.)));\n  torso = ColorSubstraction(torso, SDFPlane(p, vec3(0.9,0.,0.1), 0.45, vec3(0.,0.,0.)));\n  \n  vec4 collar = SDFCappedCone(p, vec3(0.,0.,-1.1), vec3(0.,0.,-2.), 0.7, 0.4, vec3(1., 1., 1.));\n  collar = ColorSubstraction(collar, SDFPlane(p, vec3(-0.9,0.,0.1), 0.45, vec3(1.,1.,1.)));\n  collar = ColorSubstraction(collar, SDFPlane(p, vec3(0.9,0.,0.1), 0.45, vec3(0.,0.,0.)));\n  \n  torso = ColorUnion(torso, collar);\n  \n  vec3 waistCenter = translateZ(p, 3.3);\n  waistCenter = translateX(waistCenter, -0.1);\n  waistCenter = rotateY(waistCenter, 0.3);\n  vec4 waist = SDFBox(waistCenter, vec3(0.2,0.4,0.4), vec3(0.,0.,0.));\n  \n  vec4 body = ColorUnion(torso, waist);\n  \n  vec4 Jack = ColorUnion(head, body);\n  \n  // Membres\n  vec4 leftArm = SDFSegment(p, vec3(0., .5, -1.), vec3(0., 3., -1.3), 0.1, vec3(0.,0.,0.));\n  leftArm = ColorUnion(leftArm, SDFSegment(p, vec3(0., 3., -1.3), vec3(1., 4.0, 1.), 0.1, vec3(0.,0.,0.)));\n  vec4 rightArm = SDFSegment(p, vec3(0., -.5, -1.), vec3(0.2, -3., -1.4), 0.1, vec3(0.,0.,0.));\n  rightArm = ColorUnion(rightArm, SDFSegment(p, vec3(0.2, -3., -1.4), vec3(1.5, -4.5, 1.), 0.1, vec3(0.,0.,0.)));\n  \n  vec4 arms = ColorUnion(leftArm, rightArm);\n  \n  vec4 leftLeg = SDFSegment(p, vec3(0.2, 0.2, -3.6), vec3(2., 2., -1.7), 0.1, vec3(0., 0., 0.));\n  leftLeg = ColorUnion(leftLeg, SDFSegment(p, vec3(2.,2.,-1.7), vec3(0.,1.,-5.), 0.1, vec3(0.,0.,0.)));\n  vec4 rightLeg = SDFSegment(p, vec3(0.2, -0.2, -3.6), vec3(2., -2., -1.7), 0.1, vec3(0., 0., 0.));\n  rightLeg = ColorUnion(rightLeg, SDFSegment(p, vec3(2., -2., -1.7), vec3(0.,-1.5,-5.), 0.1, vec3(0.,0.,0.)));\n  \n  vec4 legs = ColorUnion(leftLeg, rightLeg);\n  Jack = ColorUnion(Jack, legs);\n  \n  vec4 leftShoe = SDFSegment(p, vec3(0.,1.,-5.), vec3(0.2,1.2,-5.1), 0.15, vec3(0.,0.,0.));\n  vec4 rightShoe = SDFSegment(p, vec3(0.,-1.5,-5.), vec3(0.2,-1.7,-5.1), 0.15, vec3(0.,0.,0.));\n  \n  vec4 shoes = ColorUnion(leftShoe, rightShoe);\n  legs = ColorUnion(legs, shoes);\n  \n  vec3 leftHandP = translateY(p, -4.);\n  leftHandP = translateX(leftHandP, -1.);\n  leftHandP = translateZ(leftHandP, -1.1);\n  vec4 leftHand = SDFBox(leftHandP, vec3(0.05,0.1,0.1), vec3(1.,1.,1.));\n  \n  vec4 leftFinger1 = SDFSegment(p, vec3(1.,4.1,1.15), vec3(1.,4.4,1.2), 0.05, vec3(1.,1.,1.));\n  leftFinger1 = ColorUnion(leftFinger1, SDFSegment(p, vec3(1.,4.4,1.2), vec3(1.5,4.4,1.35), 0.05, vec3(1.,1.,1.)));\n  leftFinger1 = ColorUnion(leftFinger1, SDFSegment(p, vec3(1.5,4.4,1.35), vec3(1.6,4.2,1.4), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFinger2 = SDFSegment(p, vec3(1.,4.1,1.15), vec3(1.,4.3,1.55), 0.05, vec3(1.,1.,1.));\n  leftFinger2 = ColorUnion(leftFinger2, SDFSegment(p, vec3(1.,4.3,1.55), vec3(1.4,4.1,1.8), 0.05, vec3(1.,1.,1.)));\n  leftFinger2 = ColorUnion(leftFinger2, SDFSegment(p, vec3(1.4,4.1,1.8), vec3(1.5,3.9,1.6), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFinger3 = SDFSegment(p, vec3(1.,4.,1.15), vec3(0.9,4.,1.7), 0.05, vec3(1.,1.,1.));\n  leftFinger3 = ColorUnion(leftFinger3, SDFSegment(p, vec3(0.9,4.,1.7), vec3(1.3,3.7,2.), 0.05, vec3(1.,1.,1.)));\n  leftFinger3 = ColorUnion(leftFinger3, SDFSegment(p, vec3(1.3,3.7,2.), vec3(1.4,3.6,1.8), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFinger4 = SDFSegment(p, vec3(1.,3.9,1.15), vec3(1.05,3.6,1.35), 0.05, vec3(1.,1.,1.));\n  leftFinger4 = ColorUnion(leftFinger4, SDFSegment(p, vec3(1.05,3.6,1.35), vec3(1.2,3.3,1.6), 0.05, vec3(1.,1.,1.)));\n  leftFinger4 = ColorUnion(leftFinger4, SDFSegment(p, vec3(1.2,3.3,1.6), vec3(1.35,3.55,1.5), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 leftFingers = ColorUnion(leftFinger1, leftFinger2);\n  leftFingers = ColorUnion(leftFingers, leftFinger3);\n  leftFingers = ColorUnion(leftFingers, leftFinger4);\n  \n  leftHand = ColorUnion(leftHand, leftFingers);\n  \n  vec3 rightHandP = translateY(p, 4.5);\n  rightHandP = translateX(rightHandP, -1.5);\n  rightHandP = translateZ(rightHandP, -1.1);\n  vec4 rightHand = SDFBox(rightHandP, vec3(0.05,0.1,0.1), vec3(1.,1.,1.));\n  \n  vec4 rightFinger1 = SDFSegment(p, vec3(1.5,-4.4,1.15), vec3(1.4,-4.1,1.4), 0.05, vec3(1.,1.,1.));\n  rightFinger1 = ColorUnion(rightFinger1, SDFSegment(p, vec3(1.4,-4.1,1.4), vec3(1.8,-3.9,1.6), 0.05, vec3(1.,1.,1.)));\n  rightFinger1 = ColorUnion(rightFinger1, SDFSegment(p, vec3(1.8,-3.9,1.6), vec3(2.,-4.,1.55), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFinger2 = SDFSegment(p, vec3(1.5,-4.45,1.15), vec3(1.5,-4.45,1.55), 0.05, vec3(1.,1.,1.));\n  rightFinger2 = ColorUnion(rightFinger2, SDFSegment(p, vec3(1.5,-4.45,1.55), vec3(1.6,-4.35,1.8), 0.05, vec3(1.,1.,1.)));\n  rightFinger2 = ColorUnion(rightFinger2, SDFSegment(p, vec3(1.6,-4.35,1.8), vec3(1.8,-4.3,1.6), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFinger3 = SDFSegment(p, vec3(1.5,-4.55,1.15), vec3(1.6,-4.7,1.6), 0.05, vec3(1.,1.,1.));\n  rightFinger3 = ColorUnion(rightFinger3, SDFSegment(p, vec3(1.6,-4.7,1.6), vec3(1.8,-4.6,1.8), 0.05, vec3(1.,1.,1.)));\n  rightFinger3 = ColorUnion(rightFinger3, SDFSegment(p, vec3(1.8,-4.6,1.8), vec3(2.,-4.5,1.6), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFinger4 = SDFSegment(p, vec3(1.5,-4.55,1.15), vec3(1.5,-5.,1.25), 0.05, vec3(1.,1.,1.));\n  rightFinger4 = ColorUnion(rightFinger4, SDFSegment(p, vec3(1.5,-5.,1.25), vec3(1.9,-4.85,1.45), 0.05, vec3(1.,1.,1.)));\n  rightFinger4 = ColorUnion(rightFinger4, SDFSegment(p, vec3(1.9,-4.85,1.45), vec3(2.,-4.55,1.35), 0.05, vec3(1.,1.,1.)));\n  \n  vec4 rightFingers = ColorUnion(rightFinger1, rightFinger2);\n  rightFingers = ColorUnion(rightFingers, rightFinger3);\n  rightFingers = ColorUnion(rightFingers, rightFinger4);\n  \n  rightHand = ColorUnion(rightHand, rightFingers);\n  \n  vec4 hands = ColorUnion(leftHand, rightHand);\n  \n  arms = ColorUnion(arms, hands);\n  \n  vec4 Members = ColorUnion(arms, legs);\n  \n  Jack = ColorUnion(Jack, Members);\n  \n  // Decor\n  vec4 Moon = SDFSphere(p, vec3(-15.,-10.+5.*sin(iTime*0.05),5.-10.*sin(iTime*0.05)), 3., vec3(0.7, 0.7, 0.5)); \n  \n  vec3 tombP = translateZ(p, 7.);\n  tombP = translateX(tombP, -0.5);\n  tombP = translateY(tombP, 0.2);\n  tombP = rotateY(tombP, 0.2);\n  vec4 tomb = SDFBox(tombP, vec3(0.5,2.,2.), vec3(1.,1.,1.));\n  vec3 topP = rotateZ(p, 1.5);\n  vec4 tombTop = SDFTorus(topP, vec2(5.,1.9), vec3(-0.2,0.2,-8.1), vec3(1.,1.,1.));\n  vec4 tombLeft = SDFSphere(p, vec3(0.7,7.,-8.), 6., vec3(1.,1.,1.));\n  vec3 rightP = translateY(p, 2.1);\n  rightP = rotateX(rightP, -0.2);\n  vec4 tombRight = SDFPlane(rightP, vec3(0., 1., 0.) , 1., vec3(1.,1.,1.));\n  \n  tomb = ColorSubstraction(tomb, tombTop);\n  tomb = ColorSubstraction(tomb, tombLeft);\n  tomb = ColorSubstraction(tomb, tombRight);\n  \n  vec4 ground = SDFPlane(floorP, vec3(0., 0., 1.), 1., vec3(0.7, 0.6, 0.5));\n  vec4 mound = SDFSphere(p, vec3(2.5, 0., -17.5), 9., vec3(0.5,0.3,0.5));\n  \n  vec4 env = ColorUnion(tomb, ground);\n  env = ColorUnion(env, mound);\n  env = ColorUnion(env, Moon);\n  \n  Jack = ColorUnion(Jack, env);\n  \n  return Jack;\n}\n\n// Calculate object normal\n// p : point\nvec3 ObjectNormal(in vec3 p,out vec3 obj_color)\n{\n  float eps=.0001;\n  vec3 n;\n  vec4 V=Object(p);\n  float v = V.x;\n  obj_color = V.yzw;\n  n.x=Object(vec3(p.x+eps,p.y,p.z)).x-v;\n  n.y=Object(vec3(p.x,p.y+eps,p.z)).x-v;\n  n.z=Object(vec3(p.x,p.y,p.z+eps)).x-v;\n  return normalize(n);\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat Trace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).x;\n    // Hit object\n    if(v>0.)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=Epsilon;\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTrace(vec3 o,vec3 u,float rB,out bool h,out int s)\n{\n  h=false;\n  \n  // Don't start at the origin, instead move a little bit forward\n  float t=rA;\n  \n  for(int i=0;i<Steps;i++)\n  {\n    s=i;\n    vec3 p=o+t*u;\n    float v=Object(p).x;\n    // Hit object\n    if(v<0.001)\n    {\n      s=i;\n      h=true;\n      break;\n    }\n    // Move along ray\n    t+=max(Epsilon,abs(v)/4.);\n    // Escape marched far away\n    if(t>rB)\n    {\n      break;\n    }\n  }\n  return t;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// a : Number of smaples\nfloat AmbientOcclusion(vec3 p,vec3 n,int a)\n{\n  if(a==0){return 1.;}\n  \n  float ao=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    \n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){ao+=1.;}\n    else if(t>5.)\n    {\n      ao+=1.;\n    }\n  }\n  \n  ao/=float(a);\n  return ao;\n}\n\n// Background color\nvec3 background(vec3 rd)\n{\n  return mix(vec3(.14,.11,.55),vec3(.13,.20,.18),rd.z*.5+.5);\n}\n\nfloat Light(vec3 p,vec3 n)\n{\n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  // Not even Phong shading, use weighted cosine instead for smooth transitions\n  float diff=pow(.5*(1.+dot(n,l)),2.);\n  \n  bool h;\n  int s;\n  float t=SphereTrace(p+.1*n,l,100.,h,s);\n  if(!h)\n  {\n    return diff;\n  }\n  return 0.;\n}\n\nfloat SmoothLight(vec3 p,vec3 n,int a)\n{\n  if(a==0)\n  return 1.;\n  \n  // point light\n  const vec3 lp=vec3(5.,10.,25.);\n  \n  vec3 l=normalize(lp-p);\n  \n  float lo=0.;\n  \n  for(int i=0;i<a;i++)\n  {\n    vec3 d=Cosine(581.123*float(i),n);\n    d=normalize(l+d*.15);\n    int s;\n    bool h;\n    float t=SphereTrace(p,d,10.,h,s);\n    if(!h){lo+=1.;}\n    else if(t>100.)\n    {\n      lo+=1.;\n    }\n  }\n  \n  lo/=float(a);\n  return lo;\n  \n}\n\n// Shading and lighting\n// p : point,\n// n : normal at point\nvec3 Shade(vec3 p,vec3 n)\n{\n  vec3 c=.25+.25*background(n);\n  c+=.15*AmbientOcclusion(p+.1*n,n,0)*vec3(1.,1.,1.);\n  c+=.35*Light(p,n);\n  return c;\n}\n\n// Shading with number of steps\nvec3 ShadeSteps(int n)\n{\n  float t=float(n)/(float(Steps-1));\n  return .5+mix(vec3(.05,.05,.5),vec3(.65,.39,.65),t);\n}\n\n// Picture in picture\n// pixel : Pixel\n// pip : Boolean, true if pixel was in sub-picture zone\nvec2 Pip(in vec2 pixel,out bool pip)\n{\n  // Pixel coordinates\n  vec2 p=(-iResolution.xy+2.*pixel)/iResolution.y;\n  if(pip==true)\n  {\n    const float fraction=1./4.;\n    // Recompute pixel coordinates in sub-picture\n    if((pixel.x<iResolution.x*fraction)&&(pixel.y<iResolution.y*fraction))\n    {\n      p=(-iResolution.xy*fraction+2.*pixel)/(iResolution.y*fraction);\n      pip=true;\n    }\n    else\n    {\n      pip=false;\n    }\n  }\n  return p;\n}\n\n// Image\nvoid mainImage(out vec4 color,in vec2 pxy)\n{\n  // Picture in picture on\n  bool pip=true;\n  \n  // Pixel\n  vec2 pixel=Pip(pxy,pip);\n  \n  // Mouse\n  vec2 m=iMouse.xy/iResolution.xy;\n  \n  // Camera\n  vec3 ro,rd;\n  Ray(m,pixel,ro,rd);\n  \n  // Trace ray\n  \n  // Hit and number of steps\n  bool hit;\n  int s;\n  \n  float t=SphereTrace(ro,rd,100.,hit,s);\n  \n  // Position\n  vec3 pt=ro+t*rd;\n  \n  // Shade background\n  vec3 rgb=background(rd);\n    \n  if(hit)\n  {\n    // Compute normal\n    vec3 obj_color;\n    vec3 n=ObjectNormal(pt, obj_color);\n    \n    // Shade object with light\n    rgb=Shade(pt,n) * obj_color;\n  }\n  \n  // Uncomment this line to shade image with false colors representing the number of steps\n  if(pip==true)\n  {\n    rgb=ShadeSteps(s);\n  }\n  \n  color=vec4(rgb,1.);\n}\n\n","name":"Image","description":"","type":"image"}]}