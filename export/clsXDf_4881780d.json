{"ver":"0.1","info":{"id":"clsXDf","date":"1675437227","viewed":57,"name":"GLSL Partiel Partie 2","username":"Decnox","description":"creation d'un atome avec rotation et parentage des Ã©lements","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["rotationparentage"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 opRep(vec3 p, vec3 c)\n{\n    return mod(p+0.5*c, c) - 0.5 * c;\n}\n\nvec2 rot(vec2 st, float a)\n{\n    return st * mat2(cos(a), -sin(a),\n                    sin(a), cos(a));\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    \n  return length(p)-s;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  //p.xz = rot(p.yz,90.0);\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  //p.xz = rot(p.xz, iTime);\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat map(vec3 pos) {\n    float v = 0.0;\n    \n    vec3 posLien = pos + vec3(1.5,0.0,0.0);\n    posLien.xz = rot(posLien.xz + vec2(-1.5,0.0), iTime);\n    vec3 posLien2 = posLien + vec3(-1.5,0.0,0.0);\n    posLien2.yz = rot(posLien2.yz, iTime);\n    float lien = sdCapsule(posLien,vec3(6.0,0.0,0.0),vec3(-3.0,0.0,0.0) , 0.5);\n    float lien2 = sdVerticalCapsule(posLien2 + vec3(0.0,1.5,0.0),3.0,0.5);\n    float sphere = sdSphere(posLien2 + vec3(0.0,4.0,0.0), 2.0);\n    float sphere2 = sdSphere(posLien2 + vec3(0.0,-4.0,0.0), 2.0);\n    float sphere3 = sdSphere(posLien + vec3(-6.0, 0.0, 0.0), 2.0);\n    float sphere4 = sdSphere(posLien + vec3(3.5, 0.0, 0.0), 2.0);\n    \n    //float cube1 = sdBox(pos + vec3(2.0,0.0,0.0), vec3(1.0,1.0,1.0));\n    //float cube2 = sdBox(pos + vec3(-0.5 ,0.5,0.0), vec3(3.0,0.5,0.2));\n    \n    v = sphere;\n    v = opSmoothUnion(v , lien, 0.5);\n    v = opSmoothUnion(v , sphere2, 0.5);\n    v = opSmoothUnion(v , sphere3,0.5);\n    v = opSmoothUnion(v , sphere4,0.5);\n    v = opSmoothUnion(v, lien2, 0.5);\n    return v;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 eps = vec2(0.001,0.);\n    return normalize(map(p)-vec3(\n    map(p-eps.xyy),\n    map(p-eps.yxy),\n    map(p-eps.yyx)));\n}\n\n\nfloat CastRay(vec3 ro, vec3 rd)  \n{\n    float contact = 0.0;\n    \n    for(int i=0; i<64; i++)\n    {\n        float ray = map(ro + rd * contact); // TODO\n        \n        if(ray < (0.0001*contact))\n        {\n            return contact;\n            //return float(i)/32.;\n        }\n        \n        contact += ray;\n    }\n    \n    return -1.0;\n}\n\nvec3 render(vec3 ro, vec3 rd) \n{\n    float contact = CastRay(ro, rd);\n    \n    vec3 col = vec3(0.0);\n    \n    if(contact == -1.0)\n    {\n        col = vec3(0.0);\n    }\n    else // s'il y a contact\n    {\n        vec3 lightPos = vec3(sin(iTime) * 10.0, cos(iTime) * -10.0 + -7.0, -10.0);\n        vec3 lightTar = vec3(0.0, 0.0, 0.0);\n        vec3 lightDir = normalize(lightTar - lightPos);\n        \n        vec3 nor = getNormal(ro + rd * contact);\n        \n        float lambert = clamp(dot(nor, lightDir),0.6,1.0);\n        float toon = step(lambert, 0.5);\n        float stoon = smoothstep(lambert, 0.4, 0.6);\n        //float blinn = pow(clamp(lambert, 0.0, 1.0), 64.0);\n        //float fresnel = pow((dot(nor, rd) + 1.0) * .5, 1.0) * 1.5;\n        float fresnel = pow(dot(nor, rd)+0.8,3.0);\n        \n        col = vec3(0.5,0.0,0.0) * (lambert) + pow(lambert,64.) + (fresnel); //Blinn (normalement)\n        //col += fresnel; // Fresnel\n        \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 cameraPos = vec3(0.0, 5.0, 10.0);\n    vec3 cameraTar = vec3(0.0, 0.0, 0.0);\n    //cameraPos.xz = rot(cameraPos.xz, iTime);\n    \n    vec3 forward = normalize(cameraTar - cameraPos);\n    vec3 right = normalize(cross(vec3(0.0, -1.0, 0.0), forward));\n    vec3 up = normalize(cross(right, forward));\n    vec3 viewDir = normalize(uv.x * right + uv.y * up + 2.0 * forward);\n    \n\n    vec3 col = render(cameraPos, viewDir);\n    \n    //col = palette(col.x, vec3(0.5), vec3(0.5), vec3(2.0, 1.0, 0.0), vec3(0.5, 0.2, 0.25));//LA COULEUR\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}