{"ver":"0.1","info":{"id":"WtBBDK","date":"1599900945","viewed":139,"name":"embrace","username":"tono","description":"meat!","likes":9,"published":1,"flags":64,"usePreview":0,"tags":["terarria"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MtBGWV","filepath":"https://soundcloud.com/tonoshake/ambient","previewfilepath":"https://soundcloud.com/tonoshake/ambient","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float depth = 0.;\nfloat cycles = 0.;\n\nint mat = 0;\n\n#define OHKYU 1\n#define LIGHTBALL 2\n#define MEAT 3\n#define EYE 4\n#define S smoothstep \n#define KANTERA normalize(vec3(252.,207.,3.))\n#define SAT(x) clamp(x,0.,1.)\n\n#define MAXSTEP 256\n\n#define AA 3\n\nfloat TIME;\nfloat fallenEye = 0.;\nfloat roof = 0.;\nfloat MOZI = 1.;\nfloat Eyeroof = 0.;\n\nconst float pi = acos(-1.);\nvec3 PointLightPosition = vec3(0.);\n\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nfloat smoothMin(float d1, float d2, float k){\n    float h = exp(-k * d1) + exp(-k * d2);\n    return -log(h) / k;\n}\nfloat rand(vec2 p){return fract(sin(dot(p,vec2(127.1,317.2))));}\n\n////http://gamedev.stackexchange.com/questions/59797/glsl-shader-change-hue-saturation-brightness\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 RotMat(vec3 p,vec3 axis, float angle)\n{\n    // http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return p * mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c          );\n}\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise2 (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    // Initial values\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise2(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nvec2 random2(vec2 st){return -1.0 + 2.0*fract(sin( vec2( dot(st,vec2(127.1,311.7)),dot(st,vec2(269.5,183.3)) ))*43758.5453123);}\n\nfloat noise(vec2 st) \n{\n    vec2 p = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 v00 = random2(p+vec2(0,0));\n    vec2 v10 = random2(p+vec2(1,0));\n    vec2 v01 = random2(p+vec2(0,1));\n    vec2 v11 = random2(p+vec2(1,1));\n    return mix( mix( dot( vec2(v00), f - vec2(0,0) ), dot( vec2(v10), f - vec2(1,0) ), u.x ),\n                 mix( dot( vec2(v01), f - vec2(0,1) ), dot( vec2(v11), f - vec2(1,1) ), u.x ), \n                 u.y)+0.5;\n}\n\nfloat c(float x, float f)\n{\n    return x - (x - x * x) * -f;\n}\nvec2 c(vec2 x, float f)\n{\n    return x - (x - x * x) * -f;\n}\n\nvec2 Polar(vec2 i)\n{\n    vec2 pl = vec2(0.);\n    pl.y = sqrt(i.x*i.x+i.y*i.y)*2.+1.;\n    pl.x = atan(i.y,i.x)/acos(-1.);\n    return pl;\n}\n\nvec2 min2(vec2 p1,vec2 p2)\n{\n    if(p1.x < p2.x){return p1;}\n    return p2;\n}\n\nvec2 smin2(vec2 p1,vec2 p2)\n{\n    float p = smoothMin(p1.x,p2.x,2.);\n    if(p1.x < p2.x){return vec2(p,p1.y);}\n    return vec2(p,p2.y);\n}\n\n#define ITERATIONS 6\nfloat deMandelbulb(vec3 p, float power , float offset) {\n    vec3 z = p;\n    float dr = 1.0;\n    float r;\n    for (int i = 0; i < ITERATIONS; i++) {\n        r = length(z);\n        if (r > 10.0) break;\n        float theta = acos(z.y / r);\n        float phi = atan(z.z, z.x);\n        dr = pow(r - .2 * sin(TIME *7.5 + offset), power - 1.0) * power * dr + 1.0;\n\n        float zr = pow(r, power);\n        theta = theta * power;\n        phi = phi * power;\n\n        z = zr * vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n        z += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nvec2 ohkyu(vec3 p)\n{\n    p.xz = sin(p.xz) * 2.01;\n\n    vec3 s =vec3(2.35,1.,2.35);\n    s.xz -= c(sin(vec2(p.y)),-1.)/2.;\n    float boo = sdRoundBox(p,s,.0);\n    float o = boo;\n\n    if(o < 1.0)\n    {\n        o -= noise(p.xz*10.)/100.;\n        p.xy *= rot(0.1);\n        o -= noise(p.xz * 15.) / 100.;\n    }\n    return vec2(o ,OHKYU);\n}\n\nfloat Piller(vec3 p)\n{   \n    p -= vec3(0.,5.,9.5);\n    vec2 id = floor(p.xz /12.);\n    p.xz = mod(p.xz , 12.) - 6.;\n    \n    vec3 bp = p;\n    bp.y += 4.;\n    vec3 bsize = vec3(1.3,1.5,1.3);\n    bsize .xz += smoothstep(1.,0.,bp.y);\n    vec2 pol = Polar(bp.xz);\n    bsize.y -= c(sin(pol.y + rand(id)* 16. ), .7 )/10.;\n    float base = sdRoundBox(bp,bsize,.4);\n    \n    p.xz *= rot(sin(p.y * 1.) + p.y);\n    float ra = .8 - (sin(p.z*10.+ p.x * 6. ) - .5)/27.;\n    float rb = 34.18;\n    float h = 5.1 + (rand(id) - .1 ) * 8.;\n    p.y += c(sin((p.x + p.y + rand(id))*4. )/6.,1.);\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    float pile = min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n    float o = min(pile,base);\n\n    if(o < 1.0)\n    {\n        o -= noise(p.xz*10.)/100.;\n        p.xy *= rot(0.1);\n        o -= noise(p.xz * 20.) / 100.;\n    }\n    return o;\n}\n\nvec2 lightBall(vec3 p)\n{\n    p -= PointLightPosition;\n    float o = length(p) - (c(cos(TIME)+ 1.,1.) + 1.8)/10.;\n    return vec2(o,LIGHTBALL);\n}\n\nvec2 meatkun(vec3 p)\n{\n    p.y -= roof;\n    float offset = length(p);\n    p.x += 16.;\n    vec2 pos = p.xz;\n    p.xz = sin(p.xz);\n    p.xz *= rot(length(p.xz) + noise(pos.xy) * 1.);\n    \n    p -= vec3(0.,10.,1.);\n    float o = deMandelbulb(p, 8.0 , offset);\n    for(int i = 0; i < 3 ; i++)\n    {\n        p = abs(p) - 0.7;\n        p.xz *= rot(0.3);\n        p.xz *= rot(p.y * 1.);\n        o = smoothMin(deMandelbulb(p,2.0,offset + float(i) + noise(p.xz) * 35. ),o,3.);\n    }\n    return vec2(o,MEAT);\n}\n\nvec2 meatkunEye(vec3 p)\n{   \n    p.y -= roof;\n    vec2 id = floor(p.xz / 3.);\n    vec2 fid = fract(p.xz /3.);\n    \n    float t = TIME / 14. + rand(id) * 16.;\n    float Kokunoise = (noise(id + t) +noise(id + t) +noise(id + t ) +noise(id +t) +noise(id + t))/5.;\n    float angleA = (Kokunoise - .5) * 2. * pi;\n    \n    p.xz = mod(p.xz,3.) -1.5;\n    \n    p.y -= Eyeroof;\n    p = RotMat(p,normalize(vec3(0.,1.,0.)),angleA);\n    p.y += tan(rand(id) * 15. + (TIME )/2. * fallenEye); \n    \n    p.y -= 6.9;\n    float o = length(p) - 0.4;\n    \n    p.z = abs(p.z);\n    p -= vec3(0.,0.,.3);\n    float o2 = length(p) - .2;\n    o = min(o,o2);\n    return vec2(o,EYE);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 o = ohkyu(p);\n    o.x = min(Piller(p),o.x);\n    o = smin2(meatkun(p),o);\n    o = smin2(meatkunEye(p),o);\n    \n    o = min2(lightBall(p),o);\n    o.x *= 0.9;\n    return o;\n}\n\nvec2 march(vec3 cp , vec3 rd)\n{\n    depth = 0.;\n    float id = 0.;\n    for(int i = 0 ; i < MAXSTEP ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        vec2 d = map(rp);\n        if(abs(d.x) < .001)\n        {\n            depth *= -1.;\n            id = d.y;\n            break;\n        }\n        if(depth > 150.){break;}\n        depth += d.x;\n        cycles += 1.;\n    }\n    depth *= -1.;\n    return vec2(depth,id);\n}\n\nfloat getPlight(vec3 pos,vec3 N,vec3 lpos,float brightness)\n{\n    vec3 pl2surf = lpos - pos;\n    float point = clamp( dot(normalize(pl2surf),N),0.,1.) * (brightness/pow(length(pl2surf),1.7));\n    return point;\n}\n\nfloat ndfGGX(float nh, float roughness)\n{\n    nh = nh * nh;\n    roughness *= roughness;\n    return exp((nh - 1.) / (roughness * nh))/ (pi * roughness * nh * nh);\n}\n\nfloat C(float nl, float nv, float nh, float vh)\n{\n    return min(1. ,min(2. * nh * nv / vh,2. * nh * nl  / vh ));\n}\n\nfloat fresnelSchlick(float nv, float fresnel)\n{\n    return max(0.,fresnel + (1. - fresnel) * pow(1. - nv, 5.));\n}\n\nfloat lighting(vec3 rd, vec3 light,vec3 N, vec2 param)\n{\n    vec3 view = rd;\n    vec3 hlf = normalize(light + view);\n    float nl = dot(N,light);\n    float nv = dot(N,view);\n    float nh = dot(N,hlf);\n    float vh = dot(view,hlf);\n    \n    float fresnel = .4;\n    float roughness = .3;\n    //vec2(fresnel,roughness)\n    vec2 para = param;\n    \n    float dte = ndfGGX(nh , para.y);\n    float gte = C(nl,nv,nh,vh);\n    float fte = fresnelSchlick(nv,para.x);\n\n    float sp = max(0.,dte * gte * fte / (nl * nv * 4.) * nl);\n\n    return sp;\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nfloat mozi(vec2 p)\n{\n    p*= 1.12;\n    float ratio = iResolution.x / iResolution.y;\n    p += vec2( ratio,ratio/2.);\n    float o = step(.09,length(p - vec2(0.,0.01)));\n    o *= step(0.01,sdHorseshoe(p * rot(pi/1.95) + vec2(0.02,0.2),vec2(pi),.05,vec2(.005)));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.16,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.20,-0.03)) ,vec2(.055),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,0.07)) * rot(pi/4.),vec2(.11),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,0.065)) * rot(-pi/4.),vec2(.06),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,-0.01)) * rot(-pi/4.),vec2(.055),vec2(0.),.01));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.31,-0.09)) * rot(-pi/4.),vec2(.06),vec2(0.),.01));\n    o *= step(0.01,sdHorseshoe((p + vec2(-0.51,-0.01))* rot(-pi/2.) ,vec2(pi),.075,vec2(.005)));\n    return o;\n}\n\nfloat mozi2(vec2 p)\n{\n    p*= 1.1;\n    float ratio = iResolution.x / iResolution.y;\n    p += vec2( ratio,-ratio/2.);\n    float o = step(0.01,sdOrientedBox((p  + vec2(-0.16,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.05));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.25,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.05));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.34,0.06)) * rot(pi/4.),vec2(.11),vec2(0.),.05));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.37,0.015)) * rot(pi/4.),vec2(.05),vec2(0.),.05));\n    return o;\n}\n\nfloat frame(vec2 p)\n{\n    p*= 1.001;\n    float ratio = iResolution.x / iResolution.y;\n    p += vec2( ratio,-ratio/2.);\n    float o = step(0.01,sdOrientedBox((p  + vec2(-0.08,0.57)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.076,-0.065))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    \n    o *= step(0.01,sdOrientedBox((p  + vec2(-3.45,0.57)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-2.6,-0.065))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    \n    o *= step(0.01,sdOrientedBox((p  + vec2(-3.45,1.8)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-2.6,1.8))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    \n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.08,1.8)) * rot(pi/4.),vec2(.45),vec2(0.),.003));\n    o *= step(0.01,sdOrientedBox((p  + vec2(-0.076,1.8))* rot(-pi/4.) ,vec2(.6),vec2(0.),.003));\n    return o;\n}\n\nvec3 cp,cu,cs,cd,target,forward;\nfloat fov;\nfloat EFFECT = 0.;\n#define Scene1 8.\n#define Scene2 24.\n#define Scene3 34.\n#define Scene4 41.\n#define Scene5 46.\n#define Scene6 70.\n#define Scene7 75.\nvec2 cameraControl(vec2 p)\n{\n    float t = TIME ;\n    forward = vec3(0.);\n    cp = vec3(0.);\n    target = vec3(0.,5.,3.) + forward;\n    fallenEye = 1.5;\n    cd = normalize(target - cp);\n    cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    cu = normalize(cross(cd,cs));\n    float Kokunoise1 = 5. * noise(vec2(TIME + pi))/5.;\n    float Kokunoise2 = 5. * noise(vec2(TIME/10.))/5.;\n\n    vec2 Tspeed = vec2(t/6.);\n    vec3 tebure = 6. * (vec3(fbm((Tspeed) * 5.)/5.,(fbm(Tspeed + vec2(pi)))*5./5.,(fbm(Tspeed + vec2(pi * 2.43 ) )) * 5. /5. ) - vec3(.3) );\n    if(TIME < Scene1)\n    {//TPS\n        t -= 0.;\n        MOZI = 1.;\n        roof = 36.;\n        Eyeroof = 0.;\n        fallenEye = 0.;\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10.;\n        forward.z += TIME * 3.5;\n        PointLightPosition = vec3(0.,5.,-7.) + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.) + forward;\n        \n        target = PointLightPosition;\n        cp += vec3(1.3,35.,-0.5) ;\n    }\n    else if(TIME < Scene2)\n    {//FPS\n        t-= Scene1;\n        MOZI = 0.;\n        roof = 46.;\n        fallenEye = .001;\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10. + (S(0.,1.,(t * 1.4) - 9.) ) * 1.3;\n        forward.z += TIME * 3.5;\n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        cp.y ,target.y+= abs(sin(TIME*5.))/8. + Kokunoise1/6.;\n        p *= rot((Kokunoise1 - .5)/10.);\n        \n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n        \n    }else if(TIME < Scene3){\n        //FPS\n        t -= Scene2;\n        MOZI = 0.;\n        roof = 46.;\n        fallenEye = 0.;\n        forward = vec3(0.);\n        fov = 2.  - dot(p,p)/10. + (S(0.,1.,(t * 1.6) - 1.) ) +  S(1.,0.,(t * 1.3) - 5.) * 1.3;\n        forward.z += TIME * 3.5;\n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        cp.y ,target.y+= abs(sin(TIME*5.))/8. + Kokunoise1/6.;\n        float left = ( S(0.,1.,t/2.) * S(1.,0.,t/2. - 1.3) )/ 1.9;\n        float right =(-S(0.,1.,t/2.4- 1.8) * S(1.,0.,t/2.4 - 3.) )/ 1.8;\n        target.xz *= rot(left + right);\n        p *= rot((Kokunoise1 - .5)/10.);\n\n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n    }else if(TIME < Scene4){      \n            //TPS\n            t -= Scene3;\n            MOZI = 1.;\n            roof = 36.;\n            fallenEye = 0.;\n            forward = vec3(0.);\n            fov = 2. - dot(p,p)/10.;\n            forward.z += TIME * 3.5;\n            PointLightPosition = vec3(0.,5.,-7.) + vec3(sin(TIME - 8.),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.) + forward - vec3(0.,0.,18.);\n            \n            target = PointLightPosition;\n            cp += vec3(9.,15.,30.*3.5) ;\n\n    }else if (TIME < Scene5)\n    {//FPS\n        t-= Scene4;\n        MOZI = 0.;\n        roof = 46.;\n        fallenEye = .001;\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10. + (S(0.,1.,(t * 1.4) - 9.) ) * 1.3;\n        forward.z += TIME * 3.5;\n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        cp.y ,target.y+= abs(sin(TIME*5.))/8. + Kokunoise1/6.;\n        p *= rot((Kokunoise1 - .5)/10.);\n        \n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n    }else if(TIME < Scene7)\n    {//FPS\n        t-= Scene5;\n        MOZI = 0.;\n        roof =  S(1.,0.,(t/2. - 2. )) * 10.  - 6. + S(1.,0.,t/3. -6.) * 13. ;\n        fallenEye = mix(0.,.7,SAT(t/2. - 5.));\n        forward = vec3(0.);\n        fov = 2. - dot(p,p)/10.;\n        forward.z = mix(TIME * 3.5,3.5 * (Scene5 + 0.),SAT(t/5. + 1.)); \n        cp += vec3(0.,5.,-7.) + forward;\n        target = vec3(0.,5.,3.) + forward + tebure;\n        target.y += mix(0.,10.,SAT(t/5. - 0.1));\n        cp.y ,target.y+= (abs(sin(TIME*5.))/9. + Kokunoise1/6. )* mix(1.,0.,SAT(t/5.));\n    //    target.y -= 2.5;\n        p *= rot((Kokunoise1 - .5)/10.);\n        cp.y +=mix(0.,.4,SAT(t/5. - 0.1)) ;\n        \n        PointLightPosition = cp + vec3(sin(TIME),-1. + Kokunoise1 ,6.+Kokunoise2 * 3.);\n        PointLightPosition.y +=  mix(0.,15.,SAT(t/5.)); \n    }\n    \n    cd = normalize(target - cp);\n    cs = normalize(cross(cd , vec3(0.,1.,0.)));\n    cu = normalize(cross(cd,cs));\n    \n    return p;\n}\n\nvec3 scene(vec2 p)\n{\n    \n    fov = 2. - dot(p,p)/10.;\n    p = cameraControl(p);\n\n    vec3 rd = normalize(vec3(p.x * cs + p.y * cu + cd * fov));\n    // if(EFFECT < .5)\n    // {\n    //    // rd += (vec3(-0.5) + vec3(fbm(p * 13.),fbm(p * 18.) , fbm(p * 22.)) ) * SAT( length(p) - (sin(TIME) +1. ) /2.);\n    //     rd = normalize(rd);\n    // }else{\n    //     float bb = 11.;\n    //     rd += (vec3(-0.5) + vec3(rand(p * 13.),rand(p * 18.) , rand(p * 22.)) ) * (SAT( step(0.2,abs(p.x) - 16./bb) + step(0.2,abs(p.y) - 16./bb)) * (length(p) - 16./bb) );\n    //     rd = normalize(rd);\n    // }\n    \n    vec2 d = march(cp,rd);\n    \n    vec3 sun = -normalize(vec3(2.,1.,8.));\n    vec3 sky = vec3(0.,0.,0.);\n    vec3 col = sky;\n    \n    vec3 ocol = sky;\n    if(d.x > 0.)\n    {\n        col = vec3(0.);\n        vec2 e = vec2(0.0001,0.0);\n        vec3 pos = depth * rd + cp;\n        vec3 N = -normalize(vec3(map(pos).x - vec3(map(pos - e.xxy).x,map(pos - e.xyx).x,map(pos - e.yxx).x)));\n        vec3 pointLightPos = PointLightPosition; \n        vec3 PL2Surf = (pointLightPos - pos);\n        \n        if(true)\n        {\n            float Kokunoise = (noise(vec2(TIME))*5.) / 5.0;\n            col = vec3(.9,0.3,0.5);\n            float brightness = 28. * Kokunoise;\n            float point = getPlight(pos,N,pointLightPos,brightness);\n            float diff = max(0.,dot(sun,N)) * .5 + .5;\n            float shadowStrength = 1.;\n                \n            if(int(d.y) == LIGHTBALL)\n            {\n                col = vec3(1.,1.,1.) * Kokunoise * 2.;\n            }else if(int(d.y) == MEAT)\n            {\n                vec3 mCol = vec3(.9,0.01,0.);\n                vec3 Meat = SAT(mCol/6. + mCol * mix(noise(pos.xz * 10. + TIME),1.,.2));\n                float sp = lighting(rd,normalize(pointLightPos - pos),N,vec2(1.4,0.1));\n                float sss = S(0.,1.,map(pos + normalize(pointLightPos - pos) * .4).x/.8);\n                point += sss;\n                col = point * Meat + sp * Meat * point;\n            }else if(int(d.y) == EYE)\n            {\n                pos.y -= roof;\n                vec2 id = floor(pos.xz / 3.);\n                float t = TIME / 14. + rand(id) * 16.;\n                float Kokunoise = (noise(id + t) +noise(id + t) +noise(id + t ) +noise(id +t) +noise(id + t))/5.;\n                float angleA = (Kokunoise - .5) * 2. * pi;\n    \n                pos.xz = mod(pos.xz,3.) -1.5;\n                //p.xz -= id + fid;\n                pos = RotMat(pos,normalize(vec3(0.,1.,0.)),angleA);\n                //pos.y += rand(id) * 15.; \n                pos.y -= Eyeroof;\n                pos.y += tan(rand(id) * 15. + (TIME)/2. * fallenEye);\n                pos.y -= 6.9;\n                vec2 pol = Polar(pos.xy);\n                float whiteEye = 1. - noise(pol.xx * 1000.) * noise(pol * 10.) ;\n                col = (vec3(.6,.3,.5) + vec3(whiteEye,0.,0.)) * step(0.2,length(pos.xy));\n                col += S(noise(pol.xx * 100.), (sin(pol.x * 40.) + 1.) / 2.,.3) * vec3(1.,0.,0.) * step(length(pos.xy),0.17);\n                col = col * step(0.1,length(pos.xy)) + step(length(pos.xy),0.03);\n                float sp = lighting(rd,normalize(pointLightPos - pos),N,vec2(30.4,0.1));\n                float sss = S(0.,1.,map(pos + normalize(pointLightPos - pos) * .4).x/.2);\n                point += sss;\n                col = point * col + sp * col * point;       \n            }\n            else{\n                float sp = lighting(rd,normalize(pointLightPos - pos),N,vec2(1.,30.));\n                col =   point * vec3(0.5,0.5,0.8) + sp * vec3(.3,.7,0.2) * point ;\n            }\n            \n        }\n        ocol = mix(col,sky,1.-exp(-0.00007 * d.x * d.x * d.x));\n    }\n\n    return ocol;\n}\n\nvec3 blur(vec2 f)\n{\n    vec2 resolution = iResolution.xy;\n    vec3 ocolor = vec3(0.);\n    for(int i = 0;i < 3;i++ )\n    {\n        for(int j = 0; j < AA;j++)\n        {\n            vec2 d = vec2(float(i),float(j)) - vec2(float(i),float(j))/2.;\n            d /= float(AA);\n            vec2 p = ((f + d) * 2.0 - resolution.xy)/min(resolution.x,resolution.y);\n            vec2 rough = resolution.xy/6.;\n            p = floor(p * rough) /rough;\n            ocolor += scene(p);\n        }\n    }\n    ocolor /= float(AA * AA);\n    return ocolor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy)/min(iResolution.x,iResolution.y);\n    \n    p.y*= -1.;\n    \n    float addtime =Scene3 + 1.;\n    \n   TIME = mod(iTime,Scene7);\n    EFFECT = 0.0;\n    if(TIME < Scene1)\n    {\n        EFFECT = 0.;\n    }\n    else if(TIME < Scene2)\n    {//FPS\n        EFFECT = 1.;\n    }else if(TIME < Scene3)\n    {//FPS\n        EFFECT = 1.;\n    }else if(TIME < Scene4){\n        //TPS\n        EFFECT = 0.0;\n    }else if(TIME < Scene5){\n        //FPS\n        EFFECT = 1.0;\n    }else if(TIME < Scene6){\n        //FPS\n        EFFECT = 1.0;\n    }else if(TIME < Scene7)\n    {\n        EFFECT = 1.0;\n        p.x += rand(p.yy + sin(iTime )) * 10.;\n    }\n    \n    vec3 col = vec3(0.);\n    col = scene(p);\n    \n    if(EFFECT > 0.)\n    {\n        vec3 hsv = rgb2hsv(col);\n        hsv.y = SAT(hsv.y /0.9);\n        hsv.z = SAT(hsv.z * 1.1 + 0.01);\n       // col = hsv;\n        col = hsv2rgb(hsv);\n        vec3 rgb = mix(vec3(1.),vec3(0.), vec3(fbm(p * 200.) ,fbm(p * 300.) ,fbm(p * 296.)  ) * noise(p*670.));\n        col =  (col * rgb) + rgb/30.;\n        col = SAT(vec3(.7,.7,1.5) * col );\n        \n    }else{\n        vec3 hsv = rgb2hsv(col);\n      //  hsv.x = SAT(hsv.x /2.5);\n        hsv.y = SAT(hsv.y );\n        hsv.z = SAT(hsv.z * 1.3 + 0.001);\n        col = hsv;\n        col = hsv2rgb(hsv);\n\n        col = SAT(vec3(.7,.7,1.5) * col );\n    }\n\n    col = mix(vec3(1.,0.,0.),col ,clamp(0.,1.,mozi(p) + MOZI));\n    col = mix(vec3(1.,1.,1.),col,clamp(0.,1.,mozi2(p) + MOZI));\n    col = mix(vec3(1.,1.,1.),col,clamp(0.,1.,frame(p) + MOZI));\n    col = pow(col,vec3(.4545 ) );\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}