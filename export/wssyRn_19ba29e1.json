{"ver":"0.1","info":{"id":"wssyRn","date":"1584032553","viewed":235,"name":"Help 101, beginner","username":"xXpro_campr_pro_scopeXx","description":"Hey everyone, I'm looking for some help. Trying to solve this since long. read below for my question. Thank you in any case! m","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["question"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// This helper function returns 1.0 if the current pixel is on a grid line, 0.0 otherwise\nfloat IsGridLine(vec2 st)\n{\n\t// Define the size we want each grid square in pixels\n\tvec2 vPixelsPerGridSquare = vec2(20.0, 20.0);\n\t\n\t// fragCoord is an input to the shader, it defines the pixel co-ordinate of the current pixel\n\tvec2 vScreenPixelCoordinate = st.xy;\n\t\n\t// Get a value in the range 0->1 based on where we are in each grid square\n\t// fract() returns the fractional part of the value and throws away the whole number part\n\t// This helpfully wraps numbers around in the 0->1 range\n\tvec2 vGridSquareCoords = fract(vScreenPixelCoordinate / vPixelsPerGridSquare);\n\t\n\t// Convert the 0->1 co-ordinates of where we are within the grid square\n\t// back into pixel co-ordinates within the grid square \n\tvec2 vGridSquarePixelCoords = vGridSquareCoords * vPixelsPerGridSquare;\n\n\t// step() returns 0.0 if the second parmeter is less than the first, 1.0 otherwise\n\t// so we get 1.0 if we are on a grid line, 0.0 otherwise\n\tvec2 vIsGridLine = step(vGridSquarePixelCoords, vec2(1.0));\n\t\n\t// Combine the x and y gridlines by taking the maximum of the two values\n\tfloat fIsGridLine = max(vIsGridLine.x, vIsGridLine.y);\n\n\t// return the result\n\treturn fIsGridLine;\n}\n\n// FUNKTIONEN FÃœR POSITIONEN\nvec2 f_blocks(vec2 st)\n{   \n    // final return value\n    vec2 gen_pos = vec2(0.,0.);\n\n    // each pixel knows which square its located at\n    vec2 sq_pos = vec2(floor(st.x / 10.),floor(st.y / 10.)); // Amount squares along x-Axis\n\n    // Points of each\n    float sq_fn = pow(length(sq_pos),2.);\n\n    if (st.x == sq_fn )\n    {\n        gen_pos = vec2(st.x *10., 10.);\n    }\n\n    return gen_pos;\n}\n\n// main is the entry point to the shader. \n// Our shader code starts here.\n// This code is run for each pixel to determine its colour\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\t// We are goung to put our final colour here\n\t// initially we set all the elements to 0 \n\tvec4 background = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3 vResult = vec3(0.0, 0.0, 0.0);\n    vec2 pos = vec2(0.,0.);\n    vec3 sq_col = vec3(0.0, 0.0, 0.0);\n\n    vec2 st = fragCoord.xy;\n\n\t// We set the rgb color of the result based on the IsGridLine() function\n\tvResult = vec3(IsGridLine(st));\n    \n\t// HIER WERDEN QUADRAT POSITION GENERIERT\n    pos = f_blocks(fragCoord.xy);    \n\n    vec2 size = vec2(20.,20.); // in pixel\n    //pos = vec2(20.,0.); // in pixel\n\n    vec2 transform_size_bottom_left = vec2(pos.x, pos.y);\n    vec2 transform_size_top_right = vec2(iResolution.x - pos.x - size.x,iResolution.y - pos.y - size.y);\n\n    vec2 bl = step(transform_size_bottom_left.xy,fragCoord.xy);              // bottom-left\n    vec2 tr = step(transform_size_top_right.xy,iResolution.xy-fragCoord.xy); // top-right\n    sq_col += vec3(bl.x * bl.y * tr.x * tr.y);\n\n\tbackground += vec4(vResult, 1.0);\n\tbackground += vec4(sq_col, 1.0);\n\n\t// The output to the shader is gl_FragColor. \n\t// This is the colour we write to the screen for this pixel\n\n\tfragColor = background;\n}","name":"Image","description":"","type":"image"}]}