{"ver":"0.1","info":{"id":"3lBfWc","date":"1599959426","viewed":91,"name":"Rainbow Keys (Super DnB Remix)","username":"HappyBubbleRider","description":"This is the shader background that I'm working on. It looks like the background of the level I made for the song. The only differences.","likes":1,"published":1,"flags":64,"usePreview":0,"tags":["fun","shader","games","rhythm","gaming"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"MlS3WV","filepath":"https://soundcloud.com/user-856896052/colorful-keys-super-dnb","previewfilepath":"https://soundcloud.com/user-856896052/colorful-keys-super-dnb","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Untitled Rhythm Game 1.3 Exclusive Shader\n// Available whenever SoundCloud is\n\n// Aliases to use in compatibility with Untitled Rhythm Game 1.3\n#define cd iChannel1\n#define chipster iChannel0\n#define procedural_noise iChannel3\n#define backbuffer iChannel2\n\n// Unlike in the game's original shader, this one requires a bit more\n// creativity and adaptation, hence, the noise channel (iChannel3).\n// This may only work if using the primary (Image) shader.\nvec4 noisernd(vec3 pos, int iterations)\n{\n        vec4 nd;\n        float nc;\n        float epthd = 1.0;\n        for (int i=0;i<iterations;++i) {\n                nc += 1.0;\n                nd += texture(iChannel3, (pos*epthd)/256.0);\n                epthd /= 2.0;\n        }\n        return nd/nc;\n}\n\n\n// Here is Shadertoy's function. It seems VR isn't supported, so...\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 centered = fragCoord - iResolution.xy / 2.0;\n    centered /= min(iResolution.x, iResolution.y) / 2.0;\n    \n    // Uhhh, originally, Untitled Rhythm Game uses vertically flipped coordinates.\n    // Let's fix that.\n    centered.y = -centered.y;\n    \n    // Initialize color variable\n    vec3 color;\n    \n    float gradient = abs(centered.y);\n    color = mix(vec3(0.1, 0.14, 0.6), vec3(0.0, 0.1, 0.4), gradient);\n    \n    // This part would be displayed in the level\n    if (centered.y > 0.0) {\n        // Planear projection\n        vec2 planear = vec2(centered.x, 1.0) / centered.y;\n        float depth = planear.y;\n        \n        // Now shift by 6 on account that game_Position does not exist in Shadertoy\n        planear.y += zscale(iChannelTime[1]);\n        \n        // Now locate the nearest tile position\n        vec2 tile = floor(planear);\n        \n        // Tile rendering layers\n        float al = tile_alpha(planear);\n        vec3 dma = tile_color(tile, noisernd(vec3(tile, iChannelTime[1]), 4), iTime);\n        color = dma.rgb * al;\n    }\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"//\n\n// Aliases for shader primary colors.\n// Feel free to configure them.\nconst vec3 game_Primary = vec3(1.0, 0.1, 0.1);\nconst vec3 game_Secondary = vec3(1.0, 0.8, 0.2);\nconst vec3 game_Teritary = vec3(0.0, 1.0, 1.0);\n\n\n// -->> PARTS TO USE IN SHADER <<--\n\nconst float intro1 = 12.7221;\nconst float intro1b = 25.5771;\n\nconst float main1 = 51.2412;\nconst float main2 = 63.9593;\nconst float main3 = 76.8836;\nconst float main4 = 89.3519;\nconst float main5 = 102.2762;\n\nconst float break1 = 115.1355;\nconst float ref1 = 127.9748;\nconst float ref2 = 140.5763;\n\nconst float main6 = 153.3882;\nconst float main7 = 191.8216;\n\nconst float break2 = 204.1010;\nconst float main8 = 217.3966;\nconst float main9 = 230.0814;\nconst float ending1 = 255.7502;\n\n// -->> CODE FUNCTIONS <<--\n\nvec3 colorwheel(float x)\n{\n    float n = mod(x, 6.0);\n    vec3 result;\n    if (n <= 1.0) {\n        result = vec3(1.0, smoothstep(0.0, 1.0, n), 0.0);\n    } else if (n <= 2.0) {\n        result = vec3(smoothstep(2.0, 1.0, n), 1.0, 0.0);\n    } else if (n <= 3.0) {\n        result = vec3(0.0, 1.0, smoothstep(2.0, 3.0, n));\n    } else if (n <= 4.0) {\n        result = vec3(0.0, smoothstep(4.0, 3.0, n), 1.0);\n    } else if (n <= 5.0) {\n        result = vec3(smoothstep(4.0, 5.0, n), 0.0, 1.0);\n    } else {\n        result = vec3(1.0, 0.0, smoothstep(6.0, 5.0, n));\n    }\n    return result;\n}\n\nfloat zscale(float gtime)\n{\n    return gtime*6.0;\n}\n\nfloat tile_alpha(vec2 surface)\n{\n    vec2 atab = abs(fract(surface)-0.5)*2.0;\n    float mapdist = max(atab.x, atab.y);\n    float e = 1.0 - mapdist;\n    e = 1.0-pow(1.0-e, 9.0);\n    return e;\n}\n\nvec3 tile_color(vec2 tile, vec4 noisedata, float gpos)\n{\n    vec3 result = vec3(0.1);\n    if (gpos >= intro1) {\n        float xent = tile.x / 4.0;\n        result = colorwheel(xent);\n    }\n    if (gpos >= intro1b) {\n        result = game_Primary;\n        vec2 pchk = tile / 4.0;\n        bool bchk = ((fract(pchk.x) >= 0.5) != (fract(pchk.y) >= 0.5));\n        if (bchk != (fract(gpos/0.45)>=0.5)) {\n            result = game_Secondary;\n        }\n    }\n    if (gpos >= main1) {\n        result = game_Primary;\n        float chk = tile.y / 16.0 + tile.y;\n        if (chk > 0.5) {\n            result = game_Secondary;\n        }\n    }\n    if (gpos >= main2) {\n        result = game_Teritary;\n        float sm = smoothstep(main3-2.4, main3, gpos);\n        result = mix(result, vec3(1.0), sm);\n    }\n    if (gpos >= main3) {\n        result = game_Primary;\n        float eslant = smoothstep(main3, main4, gpos);\n        float saw = abs(fract(tile.x/12.0)-0.5)*2.0;\n        saw = saw * 2.0 - 1.0;\n        float base = tile.y + saw;\n        base = abs(fract(base/30.0)-0.5)*2.0;\n        result = mix(result, game_Secondary, base);\n    }\n    \n    if (gpos >= main4) {\n        result = vec3(0.1, 0.12, 0.8);\n        float fade1 = smoothstep(main4, main4+1.5, gpos);\n        result = mix(vec3(1.0), result, fade1);\n    }\n    if (gpos >= main5) {\n        result = vec3(0.3, 0.4, 1.0);\n        float basicset = noisedata.x * noisedata.z;\n        result = mix(result, vec3(0.9, 0.5, 0.4), basicset);\n    }\n    if (gpos >= break1) {\n        result = vec3(0.1);\n        float fade1 = smoothstep(break1+1.4, break1, gpos);\n        result = mix(result, vec3(1.0), fade1);\n    }\n    if (gpos >= ref1) {\n        result = vec3(0.4, 0.7, 0.8);\n        if (gpos >= ref2) {\n            result = vec3(0.9, 0.45, 0.32);\n            float pi = radians(180.0);\n            float yp = tile.x / 5.0;\n            float fti = atan(pi*sin(pi*yp));\n            float fxp = fract(tile.y / 3.0 + yp);\n            if (fxp > 0.5) {\n                result = vec3(0.378, 0.8, 0.215);\n            }\n        }\n    }\n    if (gpos >= break2) {\n        result = vec3(0.1);\n        if (tile.y >= zscale(main8)) {\n            result = vec3(0.6, 0.3, 1.0);\n            if (fract(tile.x/14.0) > 0.5) {\n                result = game_Primary;\n            }\n            if (fract(gpos*15.0) > 0.5 && tile.y >= zscale(main9)) {\n                result = 1.0 - result;\n            }\n        }\n    }\n    \n    return result;\n}","name":"Common","description":"","type":"common"}]}