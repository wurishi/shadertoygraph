{"ver":"0.1","info":{"id":"lfjcDD","date":"1722800282","viewed":63,"name":"Sample Terrain Lighting","username":"Langwedocjusz","description":"Exploration of how heightfield rendering can be improved by using bounce lighting approximation, without doing a full on ray tracing. Currently computes one bounce over multiple frames. Will try to use single frame with some smart filtering in the future.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Comment/uncomment defines below to see\n//how corresponding elements contribute to overall lighting.\n\n//BOUNCE is an actual raymarched bounce lighting\n//and FAKE_BOUNCE is just a secondary direct light\n//of lower intensity oriented opposite to the sun.\n\n#define ADD_SKYLIGHTING\n#define ADD_BOUNCE\n//#define ADD_FAKE_BOUNCE\n\nbool RaymarchHeightfield(vec3 org, vec3 dir, inout float dist)\n{\n    const int max_steps = 128;\n    const float max_dist = 2.0;\n    const float min_dist = 1e-3;\n    \n    dist = 0.0;\n    \n    for (int i=0; i<max_steps; i++)\n    {\n        vec3 p = org + dist*dir;\n        vec2 uv = p.xz;\n        \n        float h = InRegion(uv) ? texture(iChannel0, uv).a : 0.0;\n        \n        if (abs(h-p.y) < min_dist) \n            return true;\n            \n        if (dist > max_dist)\n            break;\n            \n        dist -= 0.33*(h-p.y);\n    }\n    \n    return false;\n}\n\nvec3 getNormal(vec2 p)\n{\n    return InRegion(p) ? texture(iChannel0, p).rgb : vec3(0,1,0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 ts = fragCoord/iResolution.xy;\n    \n    vec2 uv = 2.0 * ts - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float phi = 0.125*iTime;\n    float c = cos(phi), s = sin(phi);\n    \n    \n    vec3 org = vec3(0.5,0.8,0.5) + 0.5*vec3(c,0,s);\n    vec3 dir = normalize(vec3(uv, 1.0));\n    \n    dir.xz *= mat2(s, -c, -c, -s);\n    \n    float dist = 0.0;\n    vec3 col = GetSkyColor(dir);\n    \n    if (RaymarchHeightfield(org, dir, dist))\n    {\n        vec3 p = org + dist*dir;\n        \n        if (InRegion(p.xz))\n        {\n            vec3 norm = getNormal(p.xz);\n            vec3 ldir = GetSunDir();\n            \n            float shadow = texture(iChannel1, p.xz).r;\n            vec3 direct = shadow * GetDirectLighting(norm, ldir, dir);\n    \n            col = direct;\n            \n            #ifdef ADD_SKYLIGHTING\n            float ao = texture(iChannel1, p.xz).a;\n            vec3 sky = ao * GetSkyDiffuse(norm);\n            \n            col += sky; \n            #endif\n            \n            #ifdef ADD_FAKE_BOUNCE\n            vec3 fake_bounce = 0.1 * sat(dot(norm, -ldir)) * GetSunCol();\n            col += fake_bounce;\n            #endif\n            \n            #ifdef ADD_BOUNCE\n            vec3 bounce = 0.3 * texture(iChannel2, p.xz).rgb;\n            col += bounce;\n            #endif\n        }\n    }\n    \n    //Color correction\n    col = pow(col, vec3(1.0/2.2));\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//Buffer A - base heightmap and normal generation\n\n//rgb - normal\n//a   - heightfield\n\nfloat noise(vec2 p)\n{\n    vec2 u = floor(p);\n\n    float a = hash12(u+vec2(0,0));\n    float b = hash12(u+vec2(1,0));\n    float c = hash12(u+vec2(0,1));\n    float d = hash12(u+vec2(1,1));\n    \n    vec2 f = fract(p);\n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n    \n    return mix(mix(a, b, f.x), mix(c, d, f.x) ,f.y);\n}\n\nfloat fbm(vec2 p)\n{\n    const int num_octaves = 8;\n    \n    float normalization = 0.0;\n    \n    float res = 0.0;\n    \n    float A = 1.0, a = 1.0;\n    \n    for (int i=0; i<num_octaves; i++)\n    {\n        res += A * noise(a*p);\n        normalization += A;\n    \n        A *= 0.5;\n        a *= 2.0;\n    }\n    \n    return res/normalization;\n}\n\nfloat Map(vec2 p)\n{\n    return fbm(2.0*p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    if (iFrame == 0)\n    {\n        float h = Map(uv);\n    \n        float dx = Map((fragCoord + vec2(0,1))/iResolution.xy) - h; \n        float dy = Map((fragCoord + vec2(1,0))/iResolution.xy) - h;\n             \n        vec2 d = 1.0/iResolution.xy;\n             \n        vec3 norm = normalize(vec3(dx/d.x, 1.0, dy/d.y));\n\n        fragColor = vec4(norm,h);\n    }\n    \n    else\n    {\n        fragColor = texture(iChannel0, uv);\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const float PI = 3.1415926535;\nconst float GOLDEN_RATIO = 1.6180339887;\n\nfloat sat(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nbool InRegion(vec2 p)\n{\n    return (0.0 <= p.x && p.x <= 1.0) && (0.0 <= p.y && p.y <= 1.0);\n}\n\nbool InRegion(ivec2 p, vec2 res)\n{\n    return (0 <= p.x && p.x < int(res.x)) && (0 <= p.y && p.y < int(res.y));\n}\n\nvec3 GetSunDir()\n{\n    return normalize(vec3(1,1,-1));\n}\n\nvec3 GetSunCol()\n{\n    return vec3(1.0, 1.0, 0.9);\n}\n\nvec3 GetDirectLighting(vec3 norm, vec3 ldir, vec3 dir)\n{\n    //Basic Phong lighting, should be replaced with pbr.\n    float dif = sat(dot(norm, ldir));\n            \n    const float shininess = 16.0;\n    vec3 reflect_dir = reflect(ldir, norm);\n    float spec = pow(max(dot(dir, reflect_dir), 0.0), shininess);\n    \n    return (dif + spec) * GetSunCol();\n}\n\nvec3 GetSkyColor(vec3 dir)\n{\n    //Ad-hoc blend of 2 colors, should be replaced with pbr sky.\n    float t = sat(dot(dir, GetSunDir()));\n    return t * vec3(0.05, 0.1, 0.8) + (1.0 - t) * vec3(0.2, 0.5, 0.8);\n}\n\nvec3 GetSkyDiffuse(vec3 dir)\n{\n    //Just Sky Color, should also do a convolution.\n    return 0.4 * GetSkyColor(dir);\n}\n\n//High quality hash functions by nojima from:\n//https://www.shadertoy.com/view/ttc3zr\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 1 output, 2 inputs\nfloat hash12(vec2 src) {\n    uint h = murmurHash12(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec3 murmurHash32(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 2 inputs\nvec3 hash32(vec2 src) {\n    uvec3 h = murmurHash32(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\nuvec3 murmurHash33(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec3 h = uvec3(1190494759u, 2147483647u, 3559788179u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\n// 3 outputs, 3 inputs\nvec3 hash33(vec3 src) {\n    uvec3 h = murmurHash33(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//Buffer B - ambient occlusion and shadows\n\n//r - shadowmap\n//a - ao\n\nfloat getHeight(vec2 p)\n{\n    return InRegion(p) ? texture(iChannel0, p).a : 0.0;\n}\n\nfloat getShadow(vec2 p)\n{\n    float h = texture(iChannel0, p).a;\n    \n    vec3 org = vec3(p.x, h, p.y);\n    vec3 dir = GetSunDir();\n    \n    float shadow = 1.0;\n    \n    const int num_steps = 256;\n    const float k = 4.0;\n    \n    float t = 0.0;\n    float dt = 1.0/max(iResolution.x, iResolution.y);\n    \n    for (int i=0; i<num_steps; i++)\n    {\n        vec3 p = org + t*dir;\n        \n        float h = p.y - getHeight(p.xz);\n        \n        if (h < 0.0)\n        {\n            shadow = 0.0;\n            break;\n        }\n        \n        //Soft shadows approximation by Inigo Quilez:\n        //https://iquilezles.org/articles/rmshadows/\n        shadow = min(shadow, k*h/t);\n        t += dt;\n    }\n    \n    return shadow;\n}\n\nfloat getAO(vec2 p) {\n    //Sky hemisphere visibility estimation\n    \n    const int num_samples = 32;\n    const float ao_r = 0.01;\n    \n    const float dt = 1.0/float(num_samples);\n    const float A = 2.0*PI*float(num_samples)/GOLDEN_RATIO;\n    \n    float h_0 = getHeight(p);\n    \n    float res = 0.0;\n\n    for (float t=0.0; t<1.0; t+=dt) {\n        float radius = ao_r*sqrt(t);\n        if (radius <= 0.0f) continue;\n\n        vec2 q = p + radius*vec2(sin(A*t), cos(A*t));\n\n        float h = getHeight(q);\n        float rel_h = max(h-h_0, 0.0);\n        float theta = 0.5*PI - atan(rel_h/radius);\n        float dres = 1.0 - cos(theta);\n        \n        res += dres;\n    }\n\n    res = res/float(num_samples);\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iFrame == 0)\n    {\n        float ao = getAO(uv);\n        float shadow = getShadow(uv);\n\n        fragColor = vec4(shadow,0,0,ao);\n    }\n    else\n    {\n        fragColor = texture(iChannel1, uv);\n    }\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"//Buffer C - indirect illumination\n\n//Doing one bounce of light via ray tracing,\n//treating the directly lit portion of geometry as emissive.\n\n//Currently accumulates over multipla frames to produce smooth output.\n\n//To-do: investigate using joint bilateral filter (with height as\n//guide input) instead of more samples.\n\n#define USE_SHADOWS\n\nfloat getHeight(vec2 p)\n{\n    return InRegion(p) ? texture(iChannel0, p).a : 0.0;\n}\n\nvec3 getNorm(vec2 p)\n{\n    return InRegion(p) ? texture(iChannel0, p).rgb : vec3(0,1,0);\n}\n\nvec3 CastRay(vec2 p)\n{\n    float h = getHeight(p);\n    vec3 org = vec3(p.x, h + 1e-3, p.y);\n\n    //Generate normal direction\n    vec3 norm = getNorm(p);\n    vec3 rand = 2.0 * hash33(vec3(p, iTime)) - 1.0;\n    \n    vec3 dir = normalize(norm + rand);\n    \n    //Raymarch\n    const int max_steps = 64;\n    \n    float t = 0.0;\n    float dt = 4.0/max(iResolution.x, iResolution.y);\n    \n    for (int i=0; i<max_steps; i++)\n    {\n        vec3 p = org + t*dir;\n        \n        float h = p.y - getHeight(p.xz);\n        \n        if (h < 0.0)\n        {\n            vec3 ldir = GetSunDir();\n            vec3 norm = getNorm(p.xz);\n            \n            float dif = sat(dot(ldir, norm));\n            \n            #ifdef USE_SHADOWS\n            float shadow = InRegion(p.xz) ? texture(iChannel1, p.xz).r : 1.0;\n            #else\n            float shadow = 1.0;\n            #endif\n            \n            vec3 lcol = dif * shadow * GetSunDir();\n            \n            return lcol;\n        }\n    \n        t += dt;\n    }\n    \n    return vec3(0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int num_frames = 60;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    if (iFrame < num_frames)\n    {\n        vec3 new_col = CastRay(uv);\n        vec3 prev_col = texture(iChannel2, uv).rgb;\n    \n        vec3 col = mix(prev_col, new_col, 1.0/float(iFrame+1));\n        \n        fragColor = vec4(col, 1.0);\n    }\n    \n    else\n    {\n        fragColor = texture(iChannel2, uv);\n    }\n}","name":"Buffer C","description":"","type":"buffer"}]}