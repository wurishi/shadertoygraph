{"ver":"0.1","info":{"id":"ltVfzK","date":"1546313968","viewed":236,"name":"Dense Nebula","username":"WB","description":"Raymarched volumetric nebula made with some scattering approximations and an analytic integration scheme.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 256\n#define STEP_SIZE 0.06\n#define _FoV 45.0\n#define _Quality 5\n\n#define JITTER\n\n#define ROTATE\n\nconst vec3 _Absorption = vec3(0.7,0.6,0.5);\nconst vec3 _Ambient = vec3(0.4,0.15,0.2);\nconst vec3 _Light = vec3(1.0,0.3,0.2);\nconst vec3 _LightPos = vec3(0.0, 0.0, 0.0);\nconst float _LightIntensity = 2.0;\nconst float _Density = 15.0;\nconst float _Radius = 1.0;\nconst float _Mie = 0.4;\nconst float _G = 0.7;\n\n//Improved Heyney-Greenstein phase function\nfloat cornetteShanksPhase(float mu, float g)\n{\n\tfloat g2 = g * g;\n\treturn (3.0 * (1.0 - g2) * (1.0 + mu * mu)) / (2.0 * (2.0 + g2) * pow(1.0 + g2 - 2.0 * g * mu, 1.5));\n}\n\n//Ray-sphere intersection\nbool raycastSphere(vec3 ro, vec3 rd, out vec3 p0, out vec3 p1, vec3 center, float r)\n{\n    float A = 1.0; //dot(rd, rd);\n    float B = 2.0 * (rd.x * (ro.x - center.x) + rd.y * (ro.y - center.y) + rd.z * (ro.z - center.z));\n    float C = dot(ro - center, ro - center) - (r * r);\n\n    float D = B * B - 4.0 * A * C;\n    if (D < 0.0)\n    {\n        return false;\n    }\n    else\n    {\n        float t0 = (-B - D)/(2.0 * A);\n        float t1 = (-B + D)/(2.0 * A);\n        p0 = ro + rd * t0;\n        p1 = ro + rd * t1;\n        return true;\n    }\n}\n\n//Y-axis rotation matrix\nvec3 rotateY(vec3 p, float t)\n{\n    float cosTheta = cos(t);\n    float sinTheta = sin(t);\n    mat3 rot = mat3(cosTheta, 0.0, sinTheta,\n        \t\t\t0.0, 1.0, 0.0,\n    \t\t\t    -sinTheta, 0.0, cosTheta);\n    \n    return rot * p;\n}\n\n//iq's gradient noise\nvec3 hash( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat fbm(vec3 seed, int octaves, float freq, float lac)\n{\n    float val;\n    float j = 1.0;\n    for (int i = 0; i < octaves; i++, j+=1.0)\n    {\n        val += noise(seed * freq * j) / pow(j, lac);\n    }\n\n    return val;\n}\n\nfloat sampleVolume(vec3 pos)\n{\n    float r = length(pos);\n    float f = exp(-r);\n    float p = f * _Density;\n    \n    if (p <= 0.5)\n        return p;\n    \n    pos = rotateY(pos, pos.y * noise(16.0+pos) * 4.0);\n    p *= fbm(pos, _Quality, 2.0, 0.5)*8.0*f;\n    p -= abs(noise(150.0+pos * 0.4))*100.0*f;\n    p += pow(f,8.0)*33.33333*_Density;\n        \n    p = max(0.0,p);\n                \n    return p;\n}\n\nvec4 raymarch(vec3 pos, vec3 dir, float ds, int s)\n{\n    vec4 result = vec4(0.,0.0,0.0,1.0);\n    int steps = min(s, MAX_STEPS);\n    for (int i = 0; i < steps; i++)\n    {\n        float p = sampleVolume(pos);\n        if (p > 0.0)\n        {\n            vec3 r = _LightPos - pos;\n            float atten = _LightIntensity/dot(r, r);\n            vec3 ext = max(vec3(0.000001), (_Absorption * p) + vec3(_Mie * p));\n            vec3 trans = exp(-ext * ds);\n            vec3 lightDir = normalize(r);\n            float mu = dot(lightDir, -dir);\n            float phase = cornetteShanksPhase(mu, _G);\n            vec3 lum = _Ambient + _Light * phase * (1.0-_Absorption) * _Mie * p * atten;\n            vec3 integral = (lum - (lum*trans))/ext;\n            \n            result.rgb += integral * result.a;\n            vec3 div = vec3(0.3333333);\n            result.a *= dot(trans, div);\n            \n            if (result.a <= 0.05)\n                return result;\n        }\n            \n        pos += dir * ds;\n    }\n    \n    result = clamp(result, 0.0, 1.0);\n    \n    return result;\n}\n\n//4x4 Bayer matrix for ordered dithering\nconst mat4 _Bayer4x4 = mat4(vec4(0,0.5,0.125,0.625),\n                        vec4(0.75,0.25,0.875,.375), \n                        vec4(0.1875,0.6875,0.0625,0.5625), \n                        vec4(0.9375,0.4375,0.8125,0.3125));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = iMouse.y/iResolution.y;\n    vec3 rayOrigin = vec3(0.0, 0.0, -5.0 + (5.0 * zoom));\n    //Compute eye vector from field of view\n    vec2 uv = fragCoord/iResolution.xy;\n    float ar = iResolution.x/iResolution.y;\n    float d = ar/tan(radians(_FoV/2.0));    \n    vec3 rayDir = normalize(vec3((-1.0 + 2.0 * uv) * vec2(ar, 1.0), d));\n    \n    #ifdef ROTATE\n    float t = iTime * 0.1;\n    rayDir = rotateY(rayDir, t);\n\trayOrigin = rotateY(rayOrigin, t);\n    #endif\n    \n    vec4 col = vec4(0.0,0.0,0.0,1.0);\n    col.rgb += smoothstep(0.5, 0.8, abs(noise(rotateY(rayDir, iTime * 0.1) * 256.0)));\n    \n    vec3 p0, p1;\n    if (raycastSphere(rayOrigin, rayDir, p0, p1, vec3(0.0), _Radius))\n    {        \n        #ifdef JITTER\n        //Bayer matrix ordered depth jittering\n        float width = (uv.x * iResolution.x);\n        float height = (uv.y * iResolution.y);\n        width = mod(width, 4.0);\n        height = mod(height, 4.0);\n        float offset = _Bayer4x4[int(width)][int(height)];\n        p0 -= rayDir * offset * STEP_SIZE*2.0;\n        #endif\n        \n        float dist = length(p1 - p0);\n        int s = int(dist/STEP_SIZE) + 1;\n        \n        vec4 integral = raymarch(p0, rayDir, STEP_SIZE, s);\n                \n        col.rgb = mix(integral.rgb, col.rgb, integral.a);\n    }\t\n       \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}