{"ver":"0.1","info":{"id":"7tsyWf","date":"1648841486","viewed":284,"name":"Optical flow tryout","username":"0xAA55","description":"Trying to implement some 2D interpolation that can interpolate between frames. It looks not working well though, maybe I should blur the optical flow UV texture.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["2d","interpolate","opticalflow"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final composition\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfloat max_score = float(texel_count) * 2.0;\n\tvec4 uv_bump = vec4(0.0, 0.0, max_score, 0.0);\n\n    // Finish the optical flow work by iterating through all blocks from Buffer D\n\tfor(int i = 0; i < bcount; i++)\n\t{\n\t\tvec4 bump = texture(iChannel3, uv_to_block(uv, i));\n\t\tif (bump.z < uv_bump.z) uv_bump = bump;\n\t}\n\n\tfloat interpolation = float(iFrame & intmask) / float(intmask);\n    fragColor = texture(iChannel1, mix(uv, uv_bump.xy, interpolation * 2.0)); // Add more motion for the optical flow to be noticeable\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Modify the macros here to tune the shader.\n#define BLOCK_DIV 3\n#define UPDATE_INTERVAL 4\n\n// Some constants\n#define BLOCK_SIZE (1 << BLOCK_DIV)\n#define BLOCK_COUNT (BLOCK_SIZE * BLOCK_SIZE)\n#define INTERVAL_FRAMES (1 << UPDATE_INTERVAL)\n#define INTERVAL_MASK (INTERVAL_FRAMES - 1)\n#define DETECT_RANGE 10\n#define DETECT_SCALE 1.0\n#define DETECTION_RADIUS 3\n#define DETECTION_HALF (DETECTION_RADIUS / 2)\n#define DETECTION_TEXELS (DETECTION_HALF * DETECTION_HALF)\nint bshift = BLOCK_DIV;\nint bsize = BLOCK_SIZE;\nint bmask = BLOCK_SIZE - 1;\nint bcount = BLOCK_COUNT;\nint bcmask = BLOCK_COUNT - 1;\nint intframes = INTERVAL_FRAMES;\nint intmask = INTERVAL_MASK;\nfloat detect_scale = DETECT_SCALE;\nint halfdr = DETECT_RANGE / 2;\nint halfm = DETECTION_HALF;\nint texel_count = DETECTION_TEXELS;\n\n// Get integer block uv by a given id\nivec2 get_buv(int bid)\n{\n\treturn ivec2(bid & bmask, bid >> bshift);\n}\n\n// Get integer block uv by an uv ranged in [0, 1)\nivec2 get_buv(vec2 uv)\n{\n\treturn ivec2(uv * vec2(bsize));\n}\n\n// Get integer block id by a buv\nint get_bid(ivec2 buv)\n{\n\treturn buv.x + buv.y * bsize;\n}\n\n// Get integer block id by an uv ranged in [0, 1)\nint get_bid(vec2 uv)\n{\n\treturn get_bid(get_buv(uv));\n}\n\n// Transform an uv ranged in [0, 1) into an uv ranged in the specific block\nvec2 uv_to_block(vec2 uv, int bid)\n{\n\treturn (uv + vec2(get_buv(bid))) / vec2(bsize);\n}\n\n// Transform an uv ranged in the specific block to an uv ranged in [0, 1)\nvec2 uv_of_block(vec2 uv, int bid)\n{\n\treturn uv * vec2(bsize) - vec2(get_buv(bid));\n}\n\nvec2 get_min_uv_of_block(ivec2 buv)\n{\n\treturn vec2(buv) / vec2(bsize);\n}\n\nvec2 get_min_uv_of_block(int bid)\n{\n\treturn get_min_uv_of_block(get_buv(bid));\n}\n\nvec2 get_min_uv_of_block(vec2 uv)\n{\n\treturn get_min_uv_of_block(get_buv(uv));\n}\n\nvec2 get_max_uv_of_block(ivec2 buv)\n{\n\treturn vec2(buv + 1) / vec2(bsize);\n}\n\nvec2 get_max_uv_of_block(int bid)\n{\n\treturn get_max_uv_of_block(get_buv(bid));\n}\n\nvec2 get_max_uv_of_block(vec2 uv)\n{\n\treturn get_max_uv_of_block(get_buv(uv));\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by inigo quilez - iq/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Copied from https://www.shadertoy.com/view/4lX3Rf\n// Thanks to inigo quilez\n\n// Buffer A: The source video (should contain a rather complex scene and movements for the optical flow to work)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t\n\t// background\n\tvec3 col = texture( iChannel1, p ).xyz;\n\n\t\n\t// foreground\n\tvec3 fg = texture( iChannel0, p ).xyz;\n\tfloat maxrb = max( fg.r, fg.b );\n\tfloat k = clamp( (fg.g-maxrb)*3.0, 0.0, 1.0 );\n\tfloat dg = fg.g; \n\tfg.g = min( fg.g, maxrb*0.8 ); \n\tfg += dg - fg.g;\n\tcol = mix(fg, col, k);\n\n\t\n\tfragColor = vec4( col, 1.0 );\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Buffer B: reduce the framerate from the source video, and reserve the image quality.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n\n    if ((iFrame & intmask) == 0) fragColor = texture(iChannel0, uv);\n    else fragColor = texture(iChannel1, uv);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Buffer C: preserve history frames, reduce frame resolution.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\t\n\t// Only update when the framerate is low enough, prevent dupe frames\n\tif ((iFrame & intmask) == 0)\n\t{\n\t\tint bid = get_bid(uv);\n\t\tvec2 uv_block = uv_of_block(uv, bid);\n\n\t\t// Split the frame buffer into blocks, every block contains an image.\n\t\t// If the block index is 0, copy the image from the source video.\n\t\tif (bid == 0) fragColor = texture(iChannel0, uv_block);\n\n\t\t// Otherwise, copy the image from the previous index block.\n\t\t// Then the history frames were able to be preserved.\n\t\telse fragColor = texture(iChannel1, uv_to_block(uv_block, bid - 1));\n\t}\n\telse fragColor = texture(iChannel1, uv);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"// Buffer D: Do optical flow to detect the motion of the pixels in a range.\n// The low-resolution images from Buffer C were used here.\n// Use the low-res images to do optical flow.\n// Still, this buffer splits it into blocks, every block does a piece of optical flow work.\n// In the final composition, all pieces of work be joined together.\n// This is what called `the optical flow UV texture`\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 max_res = iResolution.xy;\n    vec2 texel_size = vec2(1) / iResolution.xy;\n\tvec2 uv = fragCoord / max_res;\n\tif ((iFrame & intmask) != 0)\n\t{\n        fragColor = texture(iChannel1, uv);\n\t\treturn;\n\t}\n\n    // The current block index\n\tint bid = get_bid(uv);\n\tint next_bid = (bid + 1) & bcount;\n\tivec2 buv = get_buv(uv);\n\n    // Use `offset` to split jobs into pieces\n    vec2 offset = vec2(buv - bsize / 2) + 0.5;\n    offset *= float(halfm * 2 + 1);\n\tvec2 uv_block = uv_of_block(uv, bid);\n\n    // Start optical flow calculation\n\tivec2 most_dt = ivec2(0);\n\tfloat max_score = float(texel_count) * 2.0;\n\tfloat most_score = max_score;\n\tvec2 pre_base_uv = uv_to_block(uv_block, 1);\n\tvec2 cur_base_uv = uv_to_block(uv_block, 0);\n\n    // Iterate every direction\n\tfor(int dv_y = -halfdr; dv_y <= halfdr; dv_y++)\n\t{\n\t\tfor(int dv_x = -halfdr; dv_x <= halfdr; dv_x++)\n\t\t{\n\t\t\tivec2 dv_xy = ivec2(dv_x, dv_y);\n\t\t\tfloat score = 0.0;\n\n            // In every direction, iterate through the pixels of a matrix.\n            // The iteration here is just one piece of the total optical flow work. it will be joined in the final composition.\n\t\t\tvec2 pre_detection_uv = pre_base_uv;\n\t\t\tvec2 cur_detection_uv = cur_base_uv + vec2(dv_xy) * texel_size * detect_scale;\n\t\t\tfor(int y = -halfm; y <= halfm; y++)\n\t\t\t{\n\t\t\t\tfor(int x = -halfm; x <= halfm; x++)\n\t\t\t\t{\n\t\t\t\t\tvec2 matrix_uv = (offset + vec2(x, y)) * texel_size;\n\t\t\t\t\tvec4 pre = texture(iChannel0, pre_detection_uv + matrix_uv);\n\t\t\t\t\tvec4 cur = texture(iChannel0, cur_detection_uv + matrix_uv);\n\t\t\t\t\tscore += length(cur - pre);\n\t\t\t\t}\n\t\t\t}\n\t\t\tscore /= float(texel_count);\n\t\t\tif (score < most_score)\n\t\t\t{\n\t\t\t\tmost_score = score;\n\t\t\t\tmost_dt = dv_xy;\n\t\t\t}\n\t\t}\n\t}\n\tvec2 uv_bump = vec2(most_dt) * texel_size * detect_scale;\n\n    // The score is used in the next stage to finish the total optical flow work.\n\tfragColor = vec4(fract(max(uv_of_block(uv, bid) + uv_bump, 0.0)), most_score / max_score, 1.0);\n}\n","name":"Buffer D","description":"","type":"buffer"}]}