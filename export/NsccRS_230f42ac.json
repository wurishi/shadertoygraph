{"ver":"0.1","info":{"id":"NsccRS","date":"1653582329","viewed":71,"name":"Ring for Nika","username":"ptemoche","description":"Gift for Nika. TK","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","refraction","ring","metalic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define MIN_DIST 0.01\n#define AA 4\n#define eAA 0.001\n#define wAA 1.0\n#define PI 3.14159265359\n\n\nstruct Material{\n \n    vec3 color;\n    float shininess;\n    float kd;\n    float ks;\n    float ka;\n    float kf;\n    float nd;\n};\n    \nMaterial mats[1];\n    \nMaterial i_material(vec3 color,float ka, float kd, float ks, float shininess, float kf, float nd){\n\t\n    Material m;\n    m.color = color;\n    m.shininess = shininess;\n    m.kd = kd;\n    m.ks = ks;\n    m.ka = ka;\n    m.kf = kf;\n    m.nd = nd;\n    return m;\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nmat2 Rot2(float angle){\n \n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    \n}\n\nmat3 RotY(float angle){\n \n    return mat3(cos(angle), 0.0,sin(angle),\n                0.0,       1.0,0.0       ,\n                -sin(angle),0.0,cos(angle));\n    \n}\n\nmat3 RotX(float angle){\n \n    return mat3(1.0,0.0,0.0,\n                0.0,cos(angle),sin(angle) ,\n                0.0,-sin(angle),cos(angle));\n    \n}\n\nfloat hash21(vec2 st){\n \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n    \n}\n\nvec3 hash33(vec3 p){\n \n    return vec3(hash21(p.xy),hash21(p.yz),hash21(p.xz));\n}\n\nvec2 min_v2(vec2 a, vec2 b){\n \treturn(a.x<b.x)?a:b;   \n}\nvec2 max_v2(vec2 a, vec2 b){\n \treturn(a.x>b.x)?a:b;   \n}\n\nfloat sd_sphere(vec3 p, vec4 s){\n    return length(p-s.xyz)-s.w;\n}\n\nfloat sd_torus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat d_cube(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat GetDist(vec3 p) {\n\n    p.xz *= Rot(iTime*.1);\n    \n    float d = d_cube(p, vec3(1));\n    \n    float c = cos(3.1415/5.), s=sqrt(0.75-c*c);\n    vec3 n = vec3(-0.5, -c, s);\n    \n    p = abs(p);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    p.xy = abs(p.xy);\n    p -= 2.*min(0., dot(p, n))*n;\n    \n    d = p.z-1.;\n    return d;\n}\n\nfloat sd_ellipsoid( vec3 p, vec3 r )\n{\n  \n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\n\nvec2 map(vec3 pos){\n\n    vec2 d = vec2(0,0);\n    pos=RotX(PI*0.25)*RotY(0.5)*pos;\n    d.x=sd_torus(pos,vec2(1.75,0.25));\n    d.x = max(d.x,sd_torus(pos,vec2(2.2,0.5)));\n    d.y = 0.0f;\n    \n    pos.z-=2.5f;\n    pos*=2.;\n    //d.x = min(d.x,GetDist(pos));\n    vec2 d2 = vec2(GetDist(pos),1.0); \n    d = min_v2(d,d2);\n    return d;\n}\n\nvec2 raymarching(vec3 o, vec3 dir,float side){\n    \n    float d = 0.0;\n    vec2 t = vec2(0);\n    \n    for(int i = 0; i<MAX_STEPS;++i){\n     \tvec3 pos = o+dir*d;\n        t = map(pos)*side;\n        d+=t.x;\n        \n        if(abs(t.x)<MIN_DIST || d>MAX_DIST)\n            break;\n    }\n    \n    t.x = d;\n    return t;\n    \n}\n\nvec3 getNormal(vec3 pos,float normal_desv){\n \n    vec2 e = vec2(0.01,0.0);\n    \n    return normalize(map(pos).x-vec3(\n    \t\t\t\t\t\tmap(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos-e.yyx).x\n    \t\t\t\t\t\t)+sin(hash33(pos)*PI)*normal_desv);\n    \n}\n\nfloat getLigth(vec3 pos,int index){\n \n    Material m = mats[index];\n    \n    vec3 ligth  = vec3(1,1,-1);\n    vec3 l = normalize(-ligth);\n    vec3 N = getNormal(pos,m.nd);\n    float dif = m.kd*clamp(dot(N,-l),0.0,1.0);\n    float spec = m.ks*pow(clamp(dot(-l,reflect(normalize(pos),N)),0.0,1.0),m.shininess);\n    float amb = m.ka*clamp(dot(N,normalize(vec3(0.0,0.0,-1.0))),0.0,1.0);\n    float fresnel = m.kf*(1.0-clamp(dot(N,normalize(-pos)),0.0,1.0));\n    float l_d = dif+spec+amb+fresnel;\n    \n    float fog = exp(-0.0025*pos.z*pos.z);\n    \n\treturn l_d*fog;    \n}\n\nvec3 getColor(vec3 origin, vec3 dir){\n \n    vec3 col = vec3(0.0);\n    \n    \n    vec2 r_pos = raymarching(origin,dir,1.0);\n    \n    if(r_pos.x<100.0f){\n        vec3 p = origin+dir*r_pos.x;\n        int mat_index = int(r_pos.y);\n        vec3 n = getNormal(p,0.0f);\n        col = mats[mat_index].color*getLigth(p,mat_index);\n        if(mat_index==0){\n            col = pow(col,vec3(6));\n            vec3 n = getNormal(p,0.0f);\n            vec3 refl = reflect(dir,n);\n            col = mix(col,texture(iChannel0,n).rgb,0.4);\n        }\n        if(mat_index==1){\n            float IOR = 1.45;\n            vec3 r = reflect(dir, n);\n            vec3 refOutside = texture(iChannel0, r).rgb;\n            vec3 rdIn = refract(dir, n, 1./IOR); // ray dir when entering\n        \n            vec3 pEnter = p - n*MIN_DIST*3.;\n            float dIn = raymarching(pEnter, rdIn, -1.).x; // inside the object\n\n            vec3 pExit = pEnter + rdIn * dIn; // 3d position of exit\n            vec3 nExit = -getNormal(pExit,0.0f); \n\n            vec3 reflTex = vec3(0);\n\n            vec3 rdOut = vec3(0);\n\n            float abb = .01;\n\n            // red\n            rdOut = refract(rdIn, nExit, IOR-abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.r = texture(iChannel0, rdOut).r;\n\n            // green\n            rdOut = refract(rdIn, nExit, IOR);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.g = texture(iChannel0, rdOut).g;\n\n            // blue\n            rdOut = refract(rdIn, nExit, IOR+abb);\n            if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n            reflTex.b = texture(iChannel0, rdOut).b;\n\n            float dens = .1;\n            float optDist = exp(-dIn*dens);\n\n            reflTex = reflTex*optDist;//*vec3(1., .05,.2);\n\n            float fresnel = pow(1.+dot(dir, n), 5.);\n\n            col = mix(reflTex, refOutside, fresnel);\n\n        \n        }\n    }else{\n        col = texture(iChannel0,dir).rgb;\n        \n    }\n    \n       \n    \n    return col;\n    \n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n  \n    \n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 origin = vec3(0, 1, -1)*7.0;\n    origin.yz *= Rot(-m.y*3.14+1.);\n    origin.xz *= Rot(-m.x*6.2831);\n    \n    vec3 dir = GetRayDir(uv, origin, vec3(0,0.,0), 1.);\n    \n    /*********************\n\t*       MATERIALS    *\n\t*********************/\n    \n    mats[0] = i_material(vec3(0.89,0.78,0.015),0.2,0.75,0.75,50.0,0.5,0.0001); \n    \n    \n    \n    \n\tcol = (getColor(origin, dir)*wAA)/(float(AA)+wAA);\n    \n    vec3 e = vec3(eAA,-eAA,0.0);\n    vec3 e2 = vec3(eAA,-eAA,0.0)*0.7071;\n    vec3 sampling[8];\n    sampling[0]=e.xzz;\n    sampling[1]=e.zyz;\n    sampling[2]=e.yzz;\n    sampling[3]=e.zxz;\n    sampling[4]=e2.xxz;\n    sampling[5]=e2.yxz;\n    sampling[6]=e2.xyz;\n    sampling[7]=e2.yyz;\n    \n    for(int i = 0; i<AA;++i){\n     \n        \n        vec3 dir = normalize(dir+sampling[i]);\n\n        col += getColor(origin,dir)/(float(AA)+wAA);\n        \n    }\n   \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}