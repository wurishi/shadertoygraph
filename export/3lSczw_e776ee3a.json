{"ver":"0.1","info":{"id":"3lSczw","date":"1594890651","viewed":350,"name":"Atmosphere Scattering Rendering","username":"a451107390","description":"atmosphere sacttering","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["atmospherescattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// create time : 2020-07-05\n// author : samuelfu\n// email : 451107390@qq.com\n\nconst float PI = 3.1415926;\nconst float TWOPI = 6.2831852;\nconst float INF = 1e10;\nconst vec3 InnerCenter = vec3(0);\nconst float InnerRadius = 6.36e6; //Earth Radius\nconst vec3 OutterCenter = vec3(0);\nconst float OutterRadius = 6.42e6 ; // Atmosphere Radius\nconst vec3 SunColor = vec3(13.61839144264511);\nvec3 SunDirection = normalize(vec3(0.0, 1.0, 1.0));\nconst vec3 ScatterCoeffRayleigh = vec3(3.8e-6, 13.5e-6, 33.1e-6);\nconst vec3 ScatterCoeffMie = vec3(0.000021);\nconst float Hr = 6994.0;\nconst float Hm = 4994.0;\n\nvec3 toWorld(vec3 u, vec3 n, vec3 w, vec3 v)\n{\n \treturn v.x * u + v.y * n + v.z * w;   \n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      8pi * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phaseMie(float g, float c)\n{\n    float g2 = g*g;\n    float c2 = c*c;\n    \n    float a = (1.0 - g2)*(1.0 + c2);\n    float b = 1.0 + g2 - 2.0*g*c;\n    b *= sqrt(b);\n    b *= 2.0 + g2;\n    \n    return 3.0 / (8.0 * PI) * a / b;\n}\n\n// Rayleigh\n// g : 0\n// F = 3/16PI * ( 1 + c^2 )\nfloat phaseRayleigh(float c)\n{\n \treturn 3.0 / (16.0 * PI) * (1.0 + c * c);\n}\n\nbool intersectWithSphere(vec3 rayOrig, vec3 rayDir, vec3 sphereCenter, float sphereRadius, inout float t)\n{\n    vec3 op = rayOrig - sphereCenter;\n\n\t//float A = dot(rayDir, rayDir); //rayDir is normalized\n\tfloat B = dot(op, rayDir);\n\tfloat C = dot(op, op) - sphereRadius*sphereRadius;\n\n\tfloat delta = B*B - C;\n\tif (delta < 0.f)\n\t\treturn false;\n\n\tfloat sqrDelta = sqrt(delta);\n\tfloat t1 = -B - sqrDelta;\n\tfloat t2 = -B + sqrDelta;\n\tif(t1 > t2)\n    {\n        float tt = t1;\n        t1 = t2;\n        t2 = tt;\n    }\n    \n    if(t1 < 0.0001)\n    {\n        if(t2 < 0.0001) return false;\n     \tt1 = t2;   \n    }\n    \n\tif(t1 > t) return false;\n    t = t1;\n    \n    return true;\n}\n\nvec3 render(vec3 rayOrig, vec3 rayDir)\n{\n    const int nStep = 16;\n    float t1 = INF, t2 = INF;\n#if 0\n    if(intersectWithSphere(rayOrig, rayDir, InnerCenter, InnerRadius, t1))\n    {\n        return vec3(0.0);\n    }\n#endif\n    \n    if(!intersectWithSphere(rayOrig, rayDir, OutterCenter, OutterRadius, t2))\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    float c = dot(rayDir, SunDirection);\n    \n    vec3 sumR = vec3(0);\n    vec3 sumM = vec3(0);\n    vec3 opticalDepthR = vec3(0);\n    vec3 opticalDepthM = vec3(0);\n    float seg = t2 / float(nStep);\n    for(int i = 0; i < nStep; ++i)\n    {\n        float alpha = (float(i) + 0.5) / float(nStep) * t2;\n     \tvec3 nextOrig = rayOrig + rayDir * alpha;\n        vec3 densityR = vec3(exp(-(length(nextOrig) - InnerRadius) / Hr)) * ScatterCoeffRayleigh * seg;\n        vec3 densityM = vec3(exp(-(length(nextOrig) - InnerRadius) / Hm)) * ScatterCoeffMie * seg;\n        opticalDepthR += densityR;\n        opticalDepthM += densityM;\n        \n        float t = INF;\n        intersectWithSphere(nextOrig, SunDirection, OutterCenter, OutterRadius, t);\n        \n        vec3 opticalLightDepthR = vec3(0);\n        vec3 opticalLightDepthM = vec3(0);\n        float delta = t / float(nStep);\n        for(int j = 0; j < nStep; ++j)\n        {\n         \tfloat beta = (float(j) + 0.5) / float(nStep) * t;\n            vec3 p = nextOrig + SunDirection * beta;\n            opticalLightDepthR += vec3(exp(-(length(p) - InnerRadius) / Hr)) * ScatterCoeffRayleigh;\n            opticalLightDepthM += vec3(exp(-(length(p) - InnerRadius) / Hm)) * ScatterCoeffMie;\n        }\n        \n        vec3 att = (opticalDepthR + opticalLightDepthR * delta)\n            + (opticalDepthM + opticalLightDepthM * delta);\n        sumR += exp(-att) * densityR;\n        sumM += exp(-att) * densityM;\n    }\n    \n    vec3 final = phaseRayleigh(c) * sumR * SunColor +\n         phaseMie(-0.8, c) * sumM * SunColor;\n\n \treturn final;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float angle = (iTime / 4.0)* PI;\n    \n    SunDirection = normalize(vec3(0, cos(angle) , sin(angle)));\n    \n    // View Matrix\n//    vec2 offset = (iMouse.xy / iResolution.xy - 0.5) * 3.0;\n    vec3 eye = vec3(0.0, InnerRadius + 1000.0, 6.8);\n    vec3 center = vec3(0, InnerRadius + 1000.0, 0);\n    vec3 up = vec3(0, 1, 0);\n    vec3 forward = normalize(eye - center);\n    vec3 right = normalize(cross(up, forward));\n    up = cross(forward, right);\n\n    // Projection Matrix\n    float fov = 45.0, near = 0.1, far = 100.0, aspect = 1.7777777778;\n    float height = tan(fov * 0.5 * 0.0174532925198889) * near;\n    float width = height * aspect;\n    mat4 proj = mat4(vec4(near / width, 0, 0, 0),\n        vec4(0, near / height, 0, 0),\n        vec4(0, 0, -(far + near) / (far - near), -2.0 * far * near / (far - near)),\n        vec4(0, 0, -1, 0));\n    mat4 invProj = inverse(transpose(proj));\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = 2.0 * fragCoord / iResolution.xy - vec2(1.0);\n    \n    vec3 rayOrig = eye;\n    vec3 rayDir = normalize((invProj * vec4(uv, -1.0, 1.0)).xyz);\n    rayDir = toWorld(right, up, forward, rayDir);\n\n#if 1 \n//  environment camera\n    float theta = PI * (1.0 - fragCoord.y / iResolution.y);\n    float phi = TWOPI * (1.0 - fragCoord.x / iResolution.x);\n    rayDir = vec3(sin(theta) * cos(phi), cos(theta), sin(theta) * sin(phi));\n //   rayDir = toWorld(right, up, forward, rayDir);\n#endif\n    \n    vec3 col = render(rayOrig, rayDir);\n    \n    // Tonemap\n    vec3 c = col - vec3(0.004);\n    c = max(col, vec3(0.0));\n    c = (c * (6.2 * c + 0.5)) / (c * (6.2 * c + 1.7) + 0.06);\n    col = c;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}