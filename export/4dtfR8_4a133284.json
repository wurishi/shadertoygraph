{"ver":"0.1","info":{"id":"4dtfR8","date":"1524054871","viewed":180,"name":"Iso Shockwave 2","username":"Carandiru","description":"trying to build a isometric shockwave that can be rendered cheaply with software rendering in the end result. Would like it to skip as many pixels as possible with a simple test per pixel.\nuse mouse to ","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["shockwave","dispersion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nvec3 camera(vec2 uv, float depth)\n{\n    vec3 v = vec3(uv, depth);\n    \n    // isometry\n    vec3 iso;\n    iso.x =  v.x - v.y - v.z;\n    iso.y = -v.x - v.y - v.z;\n    iso.z =        v.y - v.z;\n    \n    return iso;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 I = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\tvec2 uv = camera(I, 2.0).xy * 0.25;\t\t\n\t\n    uv.x += 1.00f;\n    uv.y += 1.00f;\n    vec3 color = vec3(0);\n    if(max(uv.x,uv.y) <= 1.0) {\n        color = texture(iChannel0, uv).xyz;\n    \tfragColor = vec4(color,1.0);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float timeShock = 5.0;\nconst float invtimeShock = 1.0/timeShock;\nconst vec3 shockParam = vec3(15.0, 2.8, 20.0); // Amplitude Effect, Refraction, width\nconst float speed = 50.0;\n\nvec2 to_iso(vec2 v)\n{  \n    // isometry\n    vec2 iso;\n    iso.x =  v.x - v.y;\n    iso.y = -v.x - v.y;\n    \n    return iso;\n}\n\nfloat comb(float v)\n{\n    return 4.5f - 0.05f / pow(0.5 + 0.5 * cos(v * 2.0 * 3.14), 10.0);\n}\n\nvec3 texGrid(vec2 v)\n{\n    v = fract(v * 8.0);\n\n    float q = 0.0;\n    q = max(q, comb(v.x));\n    q = max(q, comb(v.y));\n    return vec3(q);\n}\n\nvec3 texHeight(vec3 v)\n{\n    v = 0.5 + 0.5 * clamp(v, -1.0, 1.0);\n    return vec3(0.0, v.z, 1.0 - v.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //float dis = distance(iMouse.xy, fragCoord.xy);\n    float dis = length(fragCoord - iMouse.xy);\n    //dis *= dis;\n        \n    //current Radius of Shockwave x - y * floor(x/y).\n    float low = iTime - timeShock * floor(iTime*invtimeShock);\n    float currentRadius = low * speed;\n \t//currentRadius *= currentRadius;\n    \n    float color;\n    if(dis <= currentRadius + shockParam.z && dis >= currentRadius - shockParam.z)\n    {\n        float diff = (dis - currentRadius) / shockParam.z; //from -1.0 to 1.0\n        \n        float diffPow = 1.0 - pow(abs(diff), shockParam.y);\n        \n        //caculate current direction of pixel\n        vec2 dir = (fragCoord.xy - iMouse.xy);\n        dir = normalize(dir);\n        \n        \n        float diffFinal = diff * diffPow;\n        \n        uv = (fragCoord.xy + dir * diffFinal * shockParam.x).xy / iResolution.xy;\n    \n        color = length(dir * diffPow)  ;\n    \t//color = texture(iChannel0, uv).x;\n    }\n    else {\n        color = 0.0f;\n    }\n\t\n   // color = texture(iChannel0, uv).x;\n    uv = 2.0 * uv.xy - 1.0; \n    fragColor = vec4(texGrid(uv) + texHeight( vec3(uv,color) ),1.0);\n}\n\n//vec2 I = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n\n//vec2 uv = vec2(-I.x-I.y, I.x-I.y);","name":"Buffer A","description":"","type":"buffer"}]}