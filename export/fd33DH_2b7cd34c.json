{"ver":"0.1","info":{"id":"fd33DH","date":"1629650375","viewed":128,"name":"lost in cels","username":"snflwrfld","description":"1st shot at raymarching, experimenting with shadings other that phong, looks cool\n\nmaybe next time i'll try to have a different material for the ring and add shadow of an object to another\n\ninspirations : \"Planetarium\" by Daniel Linssen and Outer Wilds","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","celshading"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_DIST 0.\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n#define EPSILON 0.0001\n\n\n// UTILITIES\nfloat norm1(vec3 p){return abs(p.x)+abs(p.y)+abs(p.z);}\nfloat norminf(vec3 p) {return max(abs(p.x),max(abs(p.y),abs(p.z)));}\nfloat random(vec3 p){\n    return fract(sin(dot(p,vec3(24.5825,92.4585,134.4876))+27.66+iTime*.0001));\n}\n\nfloat intersectSDF(float distA, float distB) {\n    return max(distA, distB);\n}\n\nfloat unionSDF(float distA, float distB) {\n    return min(distA, distB);\n}\n\nfloat differenceSDF(float distA, float distB) {\n    return max(distA, -distB);\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n//PRIMITIVES\nfloat cubeSDF(vec3 p,vec3 center, float size) {\n    return norminf(p-center) -size;\n}\nfloat diamondSDF(vec3 p) {\n    return norm1(p) - 1.;\n}\nfloat sphereSDF(vec3 p,vec3 center,float size) {\n    return length(p-center)-size;\n}\nfloat torusSDF(vec3 p, vec3 center,float radius, float width){\n    vec2 q = vec2(length((p-center).xz)-radius,(p-center).y);\n    return length(q)-width;\n}\n\n\n// SCENE AND TRACING\nfloat SDF(vec3 p) {\n    float t =iTime;\n    float SDF = sphereSDF(p,vec3(0.),.5);\n    SDF = unionSDF(SDF,sphereSDF(p,1.5*vec3(cos(t),0.,sin(t)),.3));\n    SDF = unionSDF(SDF,differenceSDF(torusSDF(p,vec3(0.),1.5,.0075),sphereSDF(p,1.5*vec3(cos(t),0.,sin(t)),.5)));\n    return SDF;\n}\n\nfloat trace(vec3 cam,vec3 dir,float start,float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float dist = SDF(cam + depth*dir);\n        if (dist < EPSILON){\n            return depth;\n        }\n        depth += dist;\n        if (dist >= end){\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SDF(vec3(p.x + EPSILON, p.y, p.z)) - SDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SDF(vec3(p.x, p.y + EPSILON, p.z)) - SDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SDF(vec3(p.x, p.y, p.z  + EPSILON)) - SDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n//CEL SHADING \nvec3 cel_single(vec3 colorMat,vec3 colorSpec,float alphaSpec,float slices, vec3 p, vec3 cam, vec3 lightPos, vec3 lightInt){\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos-p);\n    vec3 V = normalize(cam - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    if (dot(L,N)<0.) {\n        return vec3(0.0);\n    } else if (dot(R,V)<0.) {\n        return lightInt*colorMat*dot(L,N);\n    } else {\n        return lightInt*(colorMat*dot(L,N) + colorSpec*pow(dot(R,V),alphaSpec));\n    }\n}\nvec3 cel_scene(vec3 colorAmb,vec3 colorMat,vec3 colorSpec,float alphaSpec, float slices, vec3 p, vec3 cam, float t) {\n    vec3 color = colorAmb*colorMat;\n    vec3 illu = vec3(0.);\n  \n    t = t*.5 + .5;\n    vec3 light2pos = 6.*vec3(cos(t),.3,sin(t));\n    vec3 light2int = vec3(0.525,0.525,0.525);\n    illu = max(illu,cel_single(colorMat,colorSpec,alphaSpec,slices,p,cam,light2pos,light2int));\n    \n    //color += sqrt(illu*floor(slices*norminf(illu))/slices);\n    color += floor(slices*norminf(illu))/slices;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy/iResolution.xy;\n    st = st*2.-1.;\n    st.x *= iResolution.x/iResolution.y;\n    \n    float bitCrushFactor = 90.;\n    st = floor(st*bitCrushFactor)/bitCrushFactor;\n    \n    float t = iTime;\n    \n    \n    \n    //ray casting\n    vec3 cam = vec3(2.,2.,-2.);\n    vec3 dir = normalize(vec3(st,-2.));\n    mat4 view = viewMatrix(cam,vec3(0.),vec3(0.,1.,0.));\n    dir = (view*vec4(dir,0.)).xyz;\n    \n    float dist = trace(cam,dir,MIN_DIST,MAX_DIST);\n    vec3 p = cam+dist*dir;\n    \n    \n    \n    //background\n    vec3 backgroundColor = vec3(0.123,0.145,0.104);\n    vec3 starColor = vec3(0.765,0.765,0.367);\n    vec2 ipos = floor(st*250.);\n    \n    float lit = smoothstep(.99996,.99999,random(vec3(ipos,.0)));\n    backgroundColor = backgroundColor*(1.-lit)+starColor*lit ;\n    \n    \n    \n    //shading\n    vec3 color;\n    if (dist > MAX_DIST-EPSILON){\n        color = backgroundColor;\n    } else {\n        vec3 colorAmb = vec3(0.225,0.225,0.225);\n        vec3 colorMat = vec3(1.000,0.648,0.851);\n        vec3 colorSpec = vec3(0.110,0.110,0.110);\n        float alpha = 2.;\n        \n        color = cel_scene(colorAmb,colorMat,colorSpec,alpha,7.,p,cam,t);\n    }\n\n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}