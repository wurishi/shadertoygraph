{"ver":"0.1","info":{"id":"XsycWw","date":"1524820990","viewed":272,"name":"KeyTesterV2","username":"gPlatl","description":"Visualize keyboard input image to see how it is organized.\nShow Shift-, Ctrl-, Alt- keys when pressed.\nUse mouse to check key values. Move blue cursor with cursor keys.\nunsolved: clear all key input states (reset keyboard image)? ResetTime do it NOT!","likes":7,"published":1,"flags":48,"usePreview":0,"tags":["key","image","code","input","visualize","toogle","keypressed","lastkey"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//----------------------------------------------------------\n// KeyTesterV2_Image.glsl    by Gerd Platl\n//\n// Visualize 'keyboard input image' to see how it is organized:\n//   x-direction:       0 .. 255  is key value\n//   upper image bar:   toggled key state\n//   middle image bar:  on if key is just pressed down \n//   lower image bar:   on if key is down \n//\n// channel usage:\n//   iChannel2  bufferC - info text, values & cursor\n//   iChannel3  keyboard input image\n//\n// v1.0  2017-01-06   initial release\n// v1.1  2017-01-22   moveable cursor added\n// v2.0  2018-03-27   Version 2 uses Common Tab now!\n//       2018-04-27   working on... \n//----------------------------------------------------------\n// get keycodes at   http://keycode.info/\n//   https://css-tricks.com/snippets/javascript/javascript-keycodes/\n//----------------------------------------------------------\n// see also: 'View Shader Data 2'\n//   https://www.shadertoy.com/view/XsycWw\n//----------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 mo = iMouse.xy / iResolution.xy;\n    \n  // gray 3-part background color \n  vec4 col = 0.2 + 0.2*vec4(abs(floor(uv.y*3.0-1.0)));\n  \n  // add key state image  \n  col += texture(iChannel3, uv);  \n    \n  // draw horizontal mouse position as green line\n  float delta = iResolution.x / 512.;\n  if ((iMouse.x >= fragCoord.x-delta)\n    &&(iMouse.x <= fragCoord.x+delta))\n    col += vec4(mouseColor, 1.0);\n    \n  // display text, values and blue cursor\n  col += texture(iChannel2, uv);\n    \n  fragColor = col; \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"\n//----------------------------------------------------------\n// KeyTesterV2_BufC.glsl     by Gerd Platl\n//\n// Draw info text, values and cursor to buffer C.\n// Show example of how to use keyboard input.\n//\n// channel usage:\n//   iChannel2  bufferC - global values\n//   iChannel3  keyboard input\n//\n// v1.0  2018-03-27   initial release\n//       2018-03-29   working on... \n//----------------------------------------------------------\n\n//==========================================================\n//  draw info values\n//==========================================================\nvoid FrameText()     // only for testing\n{\n    _pos(xt, 130.0);\n    _integer(iFrame); \n    _char(ch_col);\n    _ _integer(int(iFrameRate));\n    _ _f _p _s\n}\n\nvoid MouseButtonValue()\n{\n    _pos(xt, 110.0);\n    _i _M _o _u _s _e _char(ch_per); _z _ _char(ch_equ); _ \n    _integer(int (iMouse.z));\n    _nl _nl\n}\n\nvoid ShiftKeyText()\n{\n    _pos(xt, 50.0);\n    _S _h _i _f _t\n}\n\nvoid CtrlKeyText()\n{\n    _pos(xt, 60.0);\n    _C _t _r _l \n}\n\nvoid AltKeyText()\n{\n    _pos(xt, 70.0);\n    _A _l _t\n}\n\nvoid KeyDownText(int keyValue)\n{\n    if (keyValue < 0) return;\n    _pos(xt, 10.0);\n    _K _e _y\n    _char(ch_equ);\n    _integer(keyValue);\n}\nvoid LastKeyText(int keyValue)  // draw last pressed key value\n{\n    if (keyValue < 0) return;\n    _pos(xt, 20.0);\n    _L _a _s _t\n    _char(ch_equ);\n    _integer(keyValue); \n}\n\nvoid MousePosText()    // draw mouse.x position 0..255\n{\n  _pos (xt, 80.);\n  _integer(int(256.0 * iMouse.x / iResolution.x));\n  _nl\n}\n\nvoid CursorText(vec2 pos)  // draw cursor: x/y\n{\n  _pos(xt, 30.0);\n  _C _u _r _s _o _r        \n  _char(ch_col);\n  _integer(int(pos.x));\n  _char(ch_lsl);\n  _integer(int(pos.y));\n  _nl;\n\n  _pos(xt-60., 40.0);\n  _m _o _v _e _ _b _l _u _e _ _d _o _t _  \n  _w _i _t _h _ _c _u _r _s _o _r _ _k _e _y _s\n\n}    \n\n//==========================================================\n//  drawing primitives\n//==========================================================\n\n//---------------------------------------------------------\nfloat sdDisk(in vec2 pos, in float radius)\n{\n  return clamp (radius - length(uv-pos), 0.0, 1.0);\n}\n\n//==========================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  InitGlobals (iFrame, iTime, iResolution.xy);\n\n  xt = iResolution.x / 4.0;  // x position text\n  print_pos = vec2(xt,yt);   // character position \n\n  uv = fragCoord;\n  uvc = fragCoord / CHAR_SCALE;\n  vec3 col = vec3(0.0);\n\n  MouseButtonValue();\n  FrameText();\n  KeyDownText(KeyDown(keyChannel));\n  LastKeyText(LastKey(keyChannel));\n    \n  //if (ReadKey(KEY_SHIFT, false)) ShiftKeyText();\n  if (KeyPressed(KEY_SHIFT)) ShiftKeyText();\n  if (KeyPressed(KEY_CTRL))  CtrlKeyText();\n  if (KeyPressed(KEY_ALT))   AltKeyText();\n\n  col = mix(col, textColor, pixel);   // add info text\n  pixel = 0.;\n\n  MousePosText();\n  col = mix(col, mouseColor, pixel);   // add info text\n    \n  if (frame == 0)\n    cursorPosition.xy = vec2 (iMouse.x, 0.5*resolution.y);  \n  else\n    MoveCursor2d(keyChannel, valueChannel);   // move cursor\n    \n  CursorText(cursorPosition.xy);      // draw cursor text\n  col = mix(col, cursorColor, sdDisk(cursorPosition.xy,6.)); // draw cursor position\n  col = mix(col, cursorColor, pixel); // add cursor text\n\n  fragColor = vec4(col, 1.0);\n  writeVariables(fragCoord, fragColor);\n}\n","name":"Buffer C","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n//----------------------------------------------------------\n// KeyTesterV2_Common.glsl      by Gerd Platl\n//\n// global font and values functions  \n//\n// channel usage:\n//   iChannel2  bufferC - global values\n//   iChannel3  keyboard input\n//\n// v1.0  2018-03-27   initial release\n// v1.1  2018-03-29   improvements\n//----------------------------------------------------------\n\n#define valueChannel iChannel2\n#define keyChannel   iChannel3\n\nint frame = 0;\nfloat time = 0.;\nvec2 resolution = vec2(640,480); \nvec4 cursorPosition = vec4(111,77,0,256);\n\nvoid InitGlobals (int _frame, float _time, vec2 _resolution)\n{\n  frame = _frame;  \n  time = _time;\n  resolution = _resolution;\n  cursorPosition = vec4(16.0+float(frame), resolution.y/2., 0., 0.);  \n}\n\n//==========================================================\n//  Font handling\n//==========================================================\n\n#define CHAR_X 6.0\n#define CHAR_Y 12.0\nfloat CHAR_SCALE = 2.0;\n\n#define STRWIDTH(c) (c * CHAR_X)\n#define STRHEIGHT(c) (c * CHAR_Y)\n\nconst vec3 textColor   = vec3(0.9, 0.9, 0.2);  // yellow\nconst vec3 cursorColor = vec3(0.1, 0.2, 0.6);  // blue\nconst vec3 mouseColor  = vec3(0.2, 0.4, 0.0);  // green\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n\n ███    011100\n█   █   100010\n█   █   100010\n█   █   100010\n█████   111110\n█   █   100010\n█   █   100010\n\n011100 (upper 21 bits)\n100010 -> 011100 100010 100010 100 -> 935188\n100010  \n100\n   010 (lower 21 bits)\n111110 -> 010 111110 100010 100010 -> 780450\n100010\n100010\n\nvec2(935188.0,780450.0)\n*/\n\n//Automatically generated from the sprite sheet here: \n// http://uzebox.org/wiki/index.php?title=File:Font6x8.png\nvec2 ch_spc = vec2(0.0,0.0);       // space\nvec2 ch_exc = vec2(276705.0,32776.0);  // !\nvec2 ch_quo = vec2(1797408.0,0.0);     // \"\nvec2 ch_hsh = vec2(10738.0,1134484.0); // #\nvec2 ch_dol = vec2(538883.0,19976.0);  // $\nvec2 ch_pct = vec2(1664033.0,68006.0); // %\nvec2 ch_amp = vec2(545090.0,174362.0); // &\nvec2 ch_apo = vec2(798848.0,0.0);      // '\nvec2 ch_lbr = vec2(270466.0,66568.0);  // (\nvec2 ch_rbr = vec2(528449.0,33296.0);  // )\nvec2 ch_ast = vec2(10471.0,1688832.0); // *\nvec2 ch_crs = vec2(4167.0,1606144.0);  // +\nvec2 ch_per = vec2(0.0,1560.0);        // .\nvec2 ch_dsh = vec2(7.0,1572864.0);     // -\nvec2 ch_com = vec2(0.0,1544.0);        // ,\nvec2 ch_lsl = vec2(1057.0,67584.0);    // /\nvec2 ch_0 = vec2(935221.0,731292.0);\nvec2 ch_1 = vec2(274497.0,33308.0);\nvec2 ch_2 = vec2(934929.0,1116222.0);\nvec2 ch_3 = vec2(934931.0,1058972.0);\nvec2 ch_4 = vec2(137380.0,1302788.0);\nvec2 ch_5 = vec2(2048263.0,1058972.0);\nvec2 ch_6 = vec2(401671.0,1190044.0);\nvec2 ch_7 = vec2(2032673.0,66576.0);\nvec2 ch_8 = vec2(935187.0,1190044.0);\nvec2 ch_9 = vec2(935187.0,1581336.0);\nvec2 ch_col = vec2(195.0,1560.0);       // :\nvec2 ch_scl = vec2(195.0,1544.0);       // ;\nvec2 ch_les = vec2(135300.0,66052.0);   // <\nvec2 ch_equ = vec2(496.0,3968.0);       // =\nvec2 ch_grt = vec2(528416.0,541200.0);  // >\nvec2 ch_que = vec2(934929.0,1081352.0); // ?\nvec2 ch_ats = vec2(935285.0,714780.0);  // @\n\n//vec2 ch_A = vec2(935188.0,780450.0);\n//vec2 ch_B = vec2(1983767.0,1190076.0);\n//vec2 ch_C = vec2(935172.0,133276.0);\nvec2 ch_D = vec2(1983764.0,665788.0);\nvec2 ch_E = vec2(2048263.0,1181758.0);\nvec2 ch_F = vec2(2048263.0,1181728.0);\nvec2 ch_G = vec2(935173.0,1714334.0);\nvec2 ch_H = vec2(1131799.0,1714338.0);\nvec2 ch_I = vec2(921665.0,33308.0);\nvec2 ch_J = vec2(66576.0,665756.0);\nvec2 ch_K = vec2(1132870.0,166178.0);\nvec2 ch_L = vec2(1065220.0,133182.0);\nvec2 ch_M = vec2(1142100.0,665762.0);\nvec2 ch_N = vec2(1140052.0,1714338.0);\nvec2 ch_O = vec2(935188.0,665756.0);\nvec2 ch_P = vec2(1983767.0,1181728.0);\nvec2 ch_Q = vec2(935188.0,698650.0);\nvec2 ch_R = vec2(1983767.0,1198242.0);\nvec2 ch_S = vec2(935171.0,1058972.0);\nvec2 ch_T = vec2(2035777.0,33288.0);\nvec2 ch_U = vec2(1131796.0,665756.0);\nvec2 ch_V = vec2(1131796.0,664840.0);\nvec2 ch_W = vec2(1131861.0,699028.0);\nvec2 ch_X = vec2(1131681.0,84130.0);\nvec2 ch_Y = vec2(1131794.0,1081864.0);\nvec2 ch_Z = vec2(1968194.0,133180.0);\nvec2 ch_lsb = vec2(925826.0,66588.0);   // [\nvec2 ch_rsl = vec2(16513.0,16512.0);    // \\\nvec2 ch_rsb = vec2(919584.0,1065244.0); // ]\nvec2 ch_pow = vec2(272656.0,0.0);       // ^\nvec2 ch_usc = vec2(0.0,62.0);           // _\nvec2 ch_a = vec2(224.0,649374.0);\nvec2 ch_b = vec2(1065444.0,665788.0);\nvec2 ch_c = vec2(228.0,657564.0);\nvec2 ch_d = vec2(66804.0,665758.0);\nvec2 ch_e = vec2(228.0,772124.0);\nvec2 ch_f = vec2(401543.0,1115152.0);\nvec2 ch_g = vec2(244.0,665474.0);\nvec2 ch_h = vec2(1065444.0,665762.0);\nvec2 ch_i = vec2(262209.0,33292.0);\nvec2 ch_j = vec2(131168.0,1066252.0);\nvec2 ch_k = vec2(1065253.0,199204.0);\nvec2 ch_l = vec2(266305.0,33292.0);\nvec2 ch_m = vec2(421.0,698530.0);\nvec2 ch_n = vec2(452.0,1198372.0);\nvec2 ch_o = vec2(228.0,665756.0);\nvec2 ch_p = vec2(484.0,667424.0);\nvec2 ch_q = vec2(244.0,665474.0);\nvec2 ch_r = vec2(354.0,590904.0);\nvec2 ch_s = vec2(228.0,114844.0);\nvec2 ch_t = vec2(8674.0,66824.0);\nvec2 ch_u = vec2(292.0,1198868.0);\nvec2 ch_v = vec2(276.0,664840.0);\nvec2 ch_w = vec2(276.0,700308.0);\nvec2 ch_x = vec2(292.0,1149220.0);\nvec2 ch_y = vec2(292.0,1163824.0);\nvec2 ch_z = vec2(480.0,1148988.0);\nvec2 ch_lpa = vec2(401542.0,66572.0);   // {\nvec2 ch_bar = vec2(266304.0,33288.0);   // |\nvec2 ch_rpa = vec2(788512.0,1589528.0); // }\nvec2 ch_tid = vec2(675840.0,0.0);       // ~\nvec2 ch_lar = vec2(8387.0,1147904.0);   // >\n\nfloat xt = 4.0;         // x position text\nfloat yt = 8.0;         // y position text \nvec2 print_pos = vec2(4., 8.);   // character position \nfloat pixel = 0.0;      // current pixel position of character\n\nvec2 uv = vec2(0.0);    // pixel position 0.0 .. 1.0\nvec2 uvc = vec2(0.0);   // pixel position char 0.0 .. 1.0\n\n#define _A _char(vec2(935188.0,780450.0));\n#define _B _char(vec2(1983767.0,1190076.0));\n#define _C _char(vec2(935172.0,133276.0));\n#define _D _char(ch_D);\n#define _E _char(ch_E);\n#define _F _char(ch_F);\n#define _G _char(ch_G);\n#define _H _char(ch_H);\n#define _I _char(ch_I);\n#define _J _char(ch_J);\n#define _K _char(ch_K);\n#define _L _char(ch_L);\n#define _M _char(ch_M);\n#define _N _char(ch_N);\n#define _O _char(ch_O);\n#define _P _char(ch_P);\n#define _Q _char(ch_Q);\n#define _R _char(ch_R);\n#define _S _char(ch_S);\n#define _T _char(ch_T);\n#define _U _char(ch_U);\n#define _V _char(ch_V);\n#define _W _char(ch_W);\n#define _X _char(ch_X);\n#define _Y _char(ch_Y);\n#define _Z _char(ch_Z);\n\n#define _a _char(ch_a);\n#define _b _char(ch_b);\n#define _c _char(ch_c);\n#define _d _char(ch_d);\n#define _e _char(ch_e);\n#define _f _char(ch_f);\n#define _g _char(ch_g);\n#define _h _char(ch_h);\n#define _i _char(ch_i);\n#define _j _char(ch_j);\n#define _k _char(ch_k);\n#define _l _char(ch_l);\n#define _m _char(ch_m);\n#define _n _char(ch_n);\n#define _o _char(ch_o);\n#define _p _char(ch_p);\n#define _q _char(ch_q);\n#define _r _char(ch_r);\n#define _s _char(ch_s);\n#define _t _char(ch_t);\n#define _u _char(ch_u);\n#define _v _char(ch_v);\n#define _w _char(ch_w);\n#define _x _char(ch_x);\n#define _y _char(ch_y);\n#define _z _char(ch_z);\n\n#define _nl  newLine();\n#define _   _char(vec2(0.0));\n\n// extracts bit b from the given number.\n// shifts bits right (num / 2^bit) then ANDs the result with 1 (mod(result,2.0)).\nfloat extract_bit(float n, float b)\n{\n\tb = clamp(b,-1.0,22.0); //Fixes small artefacts on my nexus 7\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n// returns the pixel at position p in the given bit-packed sprite.\nfloat sprite(vec2 spr, vec2 p)\n{\n\tvec2 size = vec2(6,9); \n\tp = floor(p);\n\t// calculate the bit to extract (x + y * width) (flipped on x-axis)\n\tfloat bit = (size.x -p.x -1.0) + p.y * size.x;\n    \n\t// clipping bound to remove garbage outside the sprite's boundaries.\n\tbool bounds = all(greaterThanEqual(p, vec2(0)));\n\tbounds = bounds && all(lessThan(p, size));\n    \n\treturn bounds ? extract_bit(spr.x, bit - 21.0)+extract_bit(spr.y, bit) : 0.0;\n}\n\n// print a character and moves the print position forward by 1 character width.\nvoid _char(vec2 ch)\n{\n    float px = sprite(ch, uvc - print_pos);\n    print_pos.x += CHAR_X;\n    pixel += px;\n}\n\nvoid _pos(float x, float y) \n{\n    print_pos = vec2(x,y);\n}\n\n// returns the digit sprite for the given number.\nvec2 get_digit(float d)\n{\n    d = floor(d);   \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return ch_que;\n}\n\n// print given integer starting at pos.\nvoid _integer(int value)\n{\n    float number = float(value);\n    float result = 0.0;\n    if (number < 0.0)   // negativ number ?\n    {\n      result = sprite(ch_dsh, uvc - print_pos);\n      print_pos.x += CHAR_X;\n      number = -number;\n    }\n\tfor(int i=8; i>=0; i--)\n    {\n        float clip = float(abs(number) > pow(9.9999, float(i)) || i == 0); // ignore leading zeros.\n        float digit = mod(number / pow(10.0, float(i)), 10.0);\n        result += sprite(get_digit(digit), uvc - print_pos) * clip;\n        print_pos.x += CHAR_X * clip;\n    }\n    pixel += result;\n}\n\n// set text position to next line\nvoid newLine()\n{\n    print_pos = vec2(xt, print_pos.y + CHAR_Y);\n}\n\n//==========================================================\n//  k e y    handling\n//==========================================================\n\nconst int KEY_BACK  =  8;\nconst int KEY_TAB   =  9;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_ALT   = 18;\nconst int KEY_SPACE = 32;\n\nconst int KEY_PAGEUP   = 33;\nconst int KEY_PAGEDOWN = 34;\nconst int KEY_END      = 35;\nconst int KEY_POS      = 36;\nconst int KEY_LEFT   = 37;\nconst int KEY_UP     = 38;\nconst int KEY_RIGHT  = 39;\nconst int KEY_DOWN   = 40;\nconst int KEY_INSERT = 45;\nconst int KEY_DELETE = 46;\n\nconst int KEY_0  = 48;\nconst int KEY_1  = 49;\nconst int KEY_2  = 50;\nconst int KEY_3  = 51;\nconst int KEY_4  = 52;\nconst int KEY_5  = 53;\nconst int KEY_6  = 54;\nconst int KEY_7  = 55;\nconst int KEY_8  = 56;\nconst int KEY_9  = 57;\n\nconst int KEY_A = 65;\nconst int KEY_B = 66;\nconst int KEY_C = 67;\nconst int KEY_D = 68;\nconst int KEY_E = 69;\nconst int KEY_F = 70;\nconst int KEY_G = 71;\nconst int KEY_H = 72;\nconst int KEY_I = 73;\nconst int KEY_J = 74;\nconst int KEY_K = 75;\nconst int KEY_L = 76;\nconst int KEY_M = 77;\nconst int KEY_N = 78;\nconst int KEY_O = 79;\nconst int KEY_P = 80;\nconst int KEY_Q = 81;\nconst int KEY_R = 82;\nconst int KEY_S = 83;\nconst int KEY_T = 84;\nconst int KEY_U = 85;\nconst int KEY_V = 86;\nconst int KEY_W = 87;\nconst int KEY_X = 88;\nconst int KEY_Y = 89;\nconst int KEY_Z = 90;\n\nconst int KEY_PLUS  = 107;\nconst int KEY_MINUS = 109;\n\nconst int KEY_F1 = 112;\nconst int KEY_F2 = 113;\nconst int KEY_F3 = 114;\nconst int KEY_F4 = 115;\nconst int KEY_F5 = 116;\nconst int KEY_F6 = 115;\nconst int KEY_F7 = 118;\nconst int KEY_F8 = 119;\n\n#define KeyPressed(key) _keyPressed(keyChannel, key)\n\n//----------------------------------------------------------\n// get javascript keycode: http://keycode.info/\n//----------------------------------------------------------\nbool ReadKey(sampler2D keyChannel, int key, bool toggle)\n{\n  return 0.5 < texture(keyChannel\n    ,vec2((float(key)+0.5) / 256.0, toggle ? 0.75 : 0.25)).x;\n}\n//----------------------------------------------------------\n// return true if given key is pressed\n//----------------------------------------------------------\nbool _keyPressed(sampler2D keyChannel, int key)\n{\n  //return 0.5 < texture(keyChannel, vec2(key,0.25) / 256.0).x;\n  return texelFetch(keyChannel, ivec2(key,0), 0).x > 0.0;\n}\n//----------------------------------------------------------\n// return last pressed key value\n//----------------------------------------------------------\nint LastKey (sampler2D keyChannel)   \n{\n//  for (int i = 0; i < 256; i++)\n//    if (0.5 < texture(keyChannel, vec2(float(i) / 256., 0.5)).x) return int(i);\n    \n  for(int i = 0; i < 256; i++)\n    if (texelFetch(keyChannel, ivec2(i,1), 0).x > 0.0) return int(i);\n\n  return -1;\n}\n//----------------------------------------------------------\n// return currently pressed key\n//----------------------------------------------------------\nint KeyDown(sampler2D keyChannel)   \n{\n  //for (int i = 0; i < 256; i++)\n  //  if (0.5 < texture(keyChannel, vec2(float(i) / 256.0, 0.25)).x) return i;\n\n  for(int i = 0; i < 256; i++)\n    if (texelFetch(keyChannel, ivec2(i,0), 0).x > 0.0) return int(i);\n\n  return -1;\n}\n\n\n//==========================================================\n//  g l o b a l    v a l u e s\n//==========================================================\n\nconst vec2 vpos1 = vec2(4,4);  // global value position 1 \n\n//---------------------------------------------------------\n// write global values as color bar to valueChannel\n//---------------------------------------------------------\nbool writeMemory(in vec2 fragCoords, in vec2 vpos)\n{\n  return (fragCoords.x < (vpos.x + 1.0)) \n      && (fragCoords.x > (vpos.x - 1.0))\n      && (fragCoords.y < (vpos.y + 1.0))\n      && (fragCoords.y > (vpos.y - 1.0)); \n}\n//---------------------------------------------------------\nvoid setGlobalVec4(in vec2 vpos, in vec4 value, in vec2 fragCoord, out vec4 fragColor )\n{\n  if (writeMemory(fragCoord.xy, vpos)) fragColor = value;\n  else if ((fragCoord.y < 8.0) && (fragCoord.x < 8.0)) discard;\n}\n//---------------------------------------------------------\nvoid writeVariables(inout vec2 fragCoord, out vec4 fragColor )\n{\n  setGlobalVec4(vpos1, cursorPosition, fragCoord, fragColor);  \n}\n//----------------------------------------------------------\n// get global vec4 value from bufferC\n//----------------------------------------------------------\nvec4 getGlobalVec4 (sampler2D valueChannel, in vec2 vpos)\n{\n  vec2 pos = vpos / resolution.xy;   // 0..1  \n  return texture(valueChannel, pos);\n}\n//----------------------------------------------------------\nvoid MoveCursor2d(sampler2D keyChannel, sampler2D valueChannel)\n{\n  cursorPosition = getGlobalVec4(valueChannel,vpos1);\n  cursorPosition.x = clamp (cursorPosition.x, 7.0, resolution.x-7.0);\n  cursorPosition.y = clamp (cursorPosition.y, 7.0, resolution.y-7.0);   \n  if (KeyPressed(KEY_LEFT))     cursorPosition.x += -2.;\n  if (KeyPressed(KEY_RIGHT))    cursorPosition.x += +2.;\n  if (KeyPressed(KEY_UP))       cursorPosition.y += +2.;\n  if (KeyPressed(KEY_DOWN))     cursorPosition.y += -2.;\n  if (KeyPressed(KEY_INSERT))   cursorPosition.y = resolution.y;\n  if (KeyPressed(KEY_DELETE))   cursorPosition.y = 0.;\n  if (KeyPressed(KEY_PAGEUP))   cursorPosition.y += 10.;\n  if (KeyPressed(KEY_PAGEDOWN)) cursorPosition.y -= 10.;\n  if (KeyPressed(KEY_POS))      cursorPosition.x = 0.;\n  if (KeyPressed(KEY_END))      cursorPosition.x = 9999.;\n}\n","name":"Common","description":"","type":"common"}]}