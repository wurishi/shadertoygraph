{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"\n\nstruct Ray\n{\n\tvec3 origin;\n    vec3 dir;\n};\n\nstruct Sphere\n{\n    float \tradius;\n    vec3 \tposition;\n    vec4 \tcolor;\n};\n\nstruct Light\n{\n\n    float specular;\n    vec3 position;\n    float diffuse;\n};\n\nstruct Plane\n{\n\tvec3 p;\n    vec3 n;\n};\n    \nbool intersectPlane(in Ray r, in Plane p, out vec3 c)\n{\n\tfloat dotP=dot(r.dir, p.n);\n\tif(abs(dotP)<0.001)\n\t\treturn false;\n\tfloat t=-(dot(r.origin,p.n)-dot(p.p,p.n))/dotP;\n\tc=r.origin+t*r.dir;\n\tif(t>0.0)\n        return true;\n\treturn false;\n}\n    \nbool intersect(in Ray r, in Sphere s , out vec3 c, out vec3 n)\n{\n   \n    //imnotgonnacheckthisbecauseiftherdiris0youareacompletejerk\n    float A = dot(r.dir,r.dir);   \n    vec3 sTor = r.origin -   s.position;\n    float B = 2.0 * dot(r.dir , sTor);\n    float C = dot((sTor),(sTor)) - s.radius * s.radius;\n    float discr = 4.0 * A* C;\n    if(discr < 0.0)\n        return false;\n    \n    float sqrt2b4ac = sqrt(B * B - discr);\n    float t = (-B + sqrt2b4ac) / (2.0 * A);\n\t\n    \n    //get the smallest of both ts that is bigger than 0\n    if(t < 0.0)\n     \treturn false;\n   \t\n    c = t * r.dir + r.origin;\n    n = (c - s.position)/s.radius;\n\n    \n    return true;\n    \n}\n#define MAX_SPHERES 16\n#define SPHERES_PER_ROW 4.0\nfloat noise(vec2 uv)\n{\n \treturn texture(iChannel0, uv).r;   \n}\n\nfloat fbm(vec2 p)\n{\n \tfloat f = 0.0;   \n    f += 0.5    * noise(p); p *= 2.07;\n    f += 0.250  * noise(p);\tp *= 2.03;\n    f += 0.125  * noise(p);\tp *= 2.05;\n    f += 0.0625 * noise(p);\tp *= 2.08;\n    f /= 0.9375;\n    return f;\n}\n\nmat4 rotateY(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( cosa, 0.0, -sena, 0.0,\n               0.0  , 1.0, 0.0, 0.0,\n               sena , 0.0, cosa , 0.0\t,\n               0.0  , 0.0, 0.0 , 1.0\t);\n}\n\nmat4 rotateX(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( 1.0, 0.0, 0.0, 0.0,\n             0.0,\tcosa , sena, 0.0,\n             0.0, -sena , cosa , 0.0,\n             0.0  , 0.0, 0.0 , 1.0\t);\n}\n\nmat4 rotateZ(in float a)\n{\n   float cosa = cos(a);\n   float sena = sin(a);\n   return mat4( cosa ,sena , 0.0,  0.0,\n                -sena, cosa, 0.0,   0.0,\n             \t0.0\t ,0.0  , 1.0,  0.0,\n             \t0.0  ,0.0  , 0.0,  1.0\t);\n}\n\n\n\nvec3 camera(in vec3 dir)\n{\n    vec3 cam =  dir;\n   \n        \n    vec2 m = iMouse.xy;\n    m /= iResolution.xy;\n    float cosa = cos(m.x * 2.0 - 1.0);\n    float sena = sin(m.x * 2.0 - 1.0);\n    float cosb = cos(m.y * 2.0 - 1.0);\n    float senb = sin(m.y * 2.0 - 1.0);\n    mat4 rotY = rotateY(-(m.x * 2.0 - 1.0));\n    mat4 rotX = rotateX(m.y * 2.0 - 1.0);\n\n\n    cam = normalize(vec3(rotY *rotX *  vec4(cam, 0.0))); \n    \n   return cam;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0.0,0.0,0.0,1.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n   \n    vec2 ss = uv * 2.0 - vec2(1.0);//from 1.0 to -1.0\n\t ss.y*= iResolution.y / iResolution.x;//aspect ratio\n    Sphere spheres[MAX_SPHERES];\n    float fMaxSpheres = float(MAX_SPHERES) / 8.0;\n    mat4 rotZ = rotateZ(iTime * 0.8);\n    for(int i = 0; i < MAX_SPHERES; ++i)\n    {\n        float x = mod(float(i)\t, SPHERES_PER_ROW)  / fMaxSpheres;\n        float y =( float(i) - x) / SPHERES_PER_ROW  / fMaxSpheres;\n   \n        spheres[i].radius = 1.5;\n        spheres[i].position = vec3( 10.0 * x - 20.0/fMaxSpheres , 10.0 * y - 3.0, -4.0);\n        //rotate spheres based on time\n        \n        spheres[i].position = vec3(rotZ * vec4(spheres[i].position, 1.0));\n        spheres[i].color = vec4(0.3, 0.7 * spheres[i].position.y / 4.0 , 0.3, 1.0);\n    }\n    \n    \n    \n    Light l;\n    l.position = vec3(23.0 * sin(0.004 * iTime), 3.0, 8.0 * cos(iTime) - 4.0);\n    l.diffuse = 0.7;\n    l.specular = 0.0;\n    \n   \tPlane f;\n    f.p = vec3(0.0, -5.0, -4.0);\n    f.n = vec3(0.0, 1.0, 0.0);\n    \n    Ray cam;\n    cam.origin = vec3(0.0,4.0,20.0);\n    cam.dir = normalize(vec3(ss.x, ss.y, -1.0));\n    cam.dir = camera(cam.dir);\n    bool col = false;\n    for(int i = 0; i < MAX_SPHERES; ++i)\n    {\n        Sphere s = spheres[i];\n        vec3 ip = vec3(0.0);\n        vec3 n \t= vec3(0.0);\n        //get intersection of the camera with the sphere\n        if(intersect(cam, s, ip, n))\n        {\n            bool oclude = false;\n            for(int j = 0; j < MAX_SPHERES; ++j)\n            {\n                Ray r;\n                //see if the ray from this to the light intersects something\n                r.origin = ip + n *0.001;\n                r.dir = normalize(l.position - r.origin);\n                vec3 bIp;\n                vec3 nn;\n                Sphere s = spheres[j];\n                \n                if( intersect(r, s, bIp, nn))\n                {\n                    oclude = true;\n                    break;\n                }\n            }\n            if(!oclude)\n            {\n              \t\t//lets phong shading model\n                    vec3 lv = normalize(l.position - ip);\n\n                    float d = max(0.3, dot(lv, n));\n                    color += s.color * l.diffuse * d  ;  \n                \t\n            }\n            else\n            {\n                color += s.color * 0.2;                \n            }\n            col = true;\n            break;\n            \n        }\n    }\n    \n    //check intersection with the floor\n    vec3 ip;\n    if(!col && intersectPlane(cam, f, ip))\n   \t{\n        col = true;\n        bool oclude = false;\n        for(int j = 0; j < MAX_SPHERES; ++j)\n        {\n            Ray r;\n            //see if the ray from this to the light intersects something\n            r.origin = ip + f.n *0.001;\n            r.dir = normalize(l.position - r.origin);\n            vec3 bIp;\n            vec3 nn;\n            Sphere s = spheres[j];\n\n            if( intersect(r, s, bIp, nn))\n            {\n                oclude = true;\n                \n                break;\n            }\n        }\n        if(!oclude)\n        {\n            //lets phong shading model\n            vec3 lv = normalize(l.position - ip);\n\n            float d = max(0.3, dot(lv, f.n));\n            color += vec4(0.8, 0.0, 0.0, 1.0)* l.diffuse * d ;  \n\n        }\n        else\n        {\n            color = vec4(0.8, 0.0, 0.0, 1.0)* 0.2;                \n        }\n        \n    }\n    if(!col)\n    {\n     \t//skybox\n        \n        \n        color =\tmix(vec4(0.1, 0.3, 0.8, 1.0) , vec4(1.0), fbm((uv + cam.dir.xy * 5.0 + vec2(0.0, -1.0) * iTime) * 0.025));\n    }\n    \n\t\n\tfragColor = color;\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSXRV","date":"1413610886","viewed":229,"name":"RayMarchingTest","username":"bolt304","description":"I did from 0 without previous knowledge of raymarching (i took the intersection functions from one of my game engines, but didnt read anything else). Camera is awful and there is no depth (1st intersection).Any suggestions of interesting things to insert?","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test","raymarch","begginer"],"hasliked":0,"parentid":"","parentname":""}}