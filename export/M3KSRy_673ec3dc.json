{"ver":"0.1","info":{"id":"M3KSRy","date":"1720132702","viewed":39,"name":"Naive reflection experiments","username":"TomCarbon","description":"Naive reflection try-outs from scratch...","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int kMaxSteps = 255;\nconst float kMinSurface = 0.001;\nconst float kPi = 3.14159265358979323;\nconst int kSampleCount = 8;\n\nconst vec3 light = vec3(0.5, 4, 0.5);\n\nconst vec4 sphere1 = vec4(-1.5, 1.0, -1.5, 1.0);\nconst vec3 color1 = vec3(1.0, 0.0, 0.0);\nconst vec4 sphere2 = vec4(1.5, 1.0, -1.5, 1.0);\nconst vec3 color2 = vec3(0.0, 1.0, 0.0);\nconst vec4 sphere3 = vec4(-1.5, 1.0, 1.5, 1.0);\nconst vec3 color3 = vec3(0.0, 0.0, 1.0);\n\nfloat sdSphere(vec3 p, vec4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat sdScene(vec3 p)\n{\n    float d = p.y;\n    \n    d = min(d, sdSphere(p, sphere1));\n    d = min(d, sdSphere(p, sphere2));\n    d = min(d, sdSphere(p, sphere3));\n    \n    return d;\n}\n\nvec3 sceneColor(vec3 p)\n{\n    if (sdSphere(p, sphere1) <= kMinSurface)\n        return color1;\n\n    if (sdSphere(p, sphere2) <= kMinSurface)\n        return color2;\n\n    if (sdSphere(p, sphere3) <= kMinSurface)\n        return color3;\n\n    return vec3(0.3, 0.3, 0.3);\n}\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0, 0.001);\n\n    vec3 n = sdScene(p) - vec3(sdScene(p - e.yxx),\n                               sdScene(p - e.xyx),\n                               sdScene(p - e.xxy));\n                \n    return normalize(n);\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float min, float max)\n{\n    float d = min;\n\n    for (int i = 0; i < kMaxSteps; ++i)\n    {\n        vec3 p = ro + d * rd;\n\n        float sd = sdScene(p);\n        if (sd < kMinSurface)\n        {\n            return d;\n        }\n\n        d += sd;\n\n        if (d > max)\n        {\n            return max;\n        }\n    }\n\n    return d;\n}\n\nvec3 computeReflection(vec3 ro, vec3 rd, float min, float maxd)\n{\n    float d = min;\n\n    for (int i = 0; i < kMaxSteps; ++i)\n    {\n        vec3 p = ro + d * rd;\n\n        float sd = sdScene(p);\n        if (sd < kMinSurface)\n        {\n            vec3 n = getNormal(p);\n\n            vec3 lightDir = normalize(light - p);\n            vec3 color = sceneColor(p) * max(0.0, dot(n, lightDir));\n            \n            float lightDistance = length(light - p);\n            float shd = rayMarch(p + n * kMinSurface, lightDir, 0.0, lightDistance);\n            if (shd < lightDistance)\n                color *= 0.6;\n\n            return color;\n        }\n\n        d += sd;\n        if (d > maxd)\n        {\n            break;\n        }\n    }\n\n    return vec3(0.0);\n}\n\nfloat getDiffuse(vec3 p, vec3 n)\n{\n    vec3 l = normalize(light - p);\n    return clamp(dot(n, l), 0.0, 1.0);\n}\n\nvec3 getPixel(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.1);\n\n    float dist = rayMarch(ro, rd, 0.0, 100.0);\n    if (dist < 100.0)\n    {\n        vec3 p = ro + rd * dist;\n        vec3 n = getNormal(p);\n \n        color = sceneColor(p) * getDiffuse(p, n);\n        \n        vec3 lightDir = normalize(light - p);\n        float lightDistance = length(light - p);\n\n        float shd = rayMarch(p + n * kMinSurface, lightDir, 0.0, lightDistance);\n        if (shd < lightDistance)\n            color *= 0.3;\n\n        vec3 reflectionDir = reflect(rd, n);\n        vec3 reflection = computeReflection(p + n * kMinSurface, reflectionDir, 0.0, 100.0);\n\n        color += (1.0 - clamp(length(color), 0.0, 1.0)) * reflection;\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0, 1.5, 0);\n    vec3 lookAt = (sphere1.xyz + sphere2.xyz + sphere3.xyz) * 0.333 - vec3(0,0.5,0);\n\n    float radius = 4.0;\n    float angle = iTime * 0.6;\n    if (iMouse.z > 0.5)\n        angle = iMouse.x / iResolution.x * 2.0 * kPi;\n    ro.xz = radius * vec2(sin(angle), cos(angle));\n\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n\n    vec3 rd = normalize(forward + uv.x * right + uv.y * up);\n\n    vec3 color = getPixel(ro, rd);\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}