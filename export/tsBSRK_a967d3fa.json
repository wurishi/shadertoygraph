{"ver":"0.1","info":{"id":"tsBSRK","date":"1554324920","viewed":245,"name":"Tetrad Blackhole raymarch","username":"magician0809","description":"Tetrad Blackhole raymarch","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","blackhole","4","tetrad"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n//see more details at https://www.shadertoy.com/view/WsSXzy\n\n//physics constants\n#define _c 1.0\n#define _c2 1.0\n#define _G 1.0\n\n//power\n#define P0 _G * 1.0\n#define P1 P0\n#define P2 P0\n#define P3 P0\n\n//normal\n#define SHAPE 0\n//tetrad\n#if (SHAPE==0)\n#define N0 vec3(0., 1., 0.)\n#define N1 vec3(0., -1./3., 2.*sqrt(2.)/3.)\n#define N2 vec3(sqrt(6.)/3., -1./3., -sqrt(2.)/3.)\n#define N3 vec3(-sqrt(6.)/3., -1./3., -sqrt(2.)/3.)\n//----\n#elif (SHAPE==1)\n#define N0 vec3(-1.5, 0., 0.)\n#define N1 vec3(-0.5, 0., 0.)\n#define N2 vec3(0.5, 0., 0.)\n#define N3 vec3(1.5, 0., 0.)\n//_|_\n#elif (SHAPE==2)\n#define N0 vec3(0., -0.5, 0.)\n#define N1 vec3(-1., -0.5, 0.)\n#define N2 vec3(1., -0.5, 0.)\n#define N3 vec3(0., 0.5, 0.)\n//_|~\n#elif (SHAPE==3)\n#define N0 vec3(-1., -0.5, 0.)\n#define N1 vec3(0., -0.5, 0.)\n#define N2 vec3(0., 0.5, 0.)\n#define N3 vec3(1., 0.5, 0.)\n//L\n#elif (SHAPE==4)\n#define N0 vec3(1.5, -0.5, 0.)\n#define N1 vec3(0.5, -0.5, 0.)\n#define N2 vec3(-0.5, -0.5, 0.)\n#define N3 vec3(-0.5, 0.5, 0.)\n//#\n#else\n#define N0 vec3(0.5, 0.5, 0.)\n#define N1 vec3(-0.5, 0.5, 0.)\n#define N2 vec3(-0.5, -0.5, 0.)\n#define N3 vec3(0.5, -0.5, 0.)\n#endif\n\n//position\n#define R 10.0\n#define C0 R * N0\n#define C1 R * N1\n#define C2 R * N2\n#define C3 R * N3\n\n#define DIST 30.0\n\n#define ADISK 0.2\n#define ITER 64\n\n#define Time (iTime * 0.1)\n\nCamera GetCamera()\n{\n    Camera cam;\n    cam.target = vec3(0);\n    cam.dist = DIST;\n    cam.near = 0.0001;\n    cam.far = 10000.0;\n    cam.fov = 60.0;\n    cam.aspect = iResolution.x/iResolution.y;\n    vec2 eulers = 6.283185 / iResolution.y * vec2(-iMouse.y, iMouse.x);\n    eulers.x += 1.0;\n    eulers.y += 0.1 * iTime;\n    cam.rot = QuatEA(eulers);\n    return cam;\n}\n\nfloat EventsHorizon(float p)\n{\n    //return 2.0 * p / _c2;\n    return p / _c2;\n}\n\nvec3 AccretionDisk(float p, vec3 n, vec3 ro, vec3 rd)\n{\n    float t = -dot(ro, n) / dot(rd, n);\n    vec3 cp = ro + t * rd;\n    float l = length(cp);\n    if (l < EventsHorizon(p)) return vec3(0.0);\n    float v2 = p / l / _c2;\n    vec3 vd = normalize(cross(cp, n));\n    float f = sqrt(1.0 - v2) / (1.0 - sqrt(v2) * dot(vd, rd));\n    float val = smoothstep(ADISK, 0.0, abs(ADISK - pow(v2, 2.0)));\n    return vec3(f * val);\n}\nvec3 RenderAccretionDisk(float p, vec3 n, vec3 ro, vec3 rd)\n{\n    float t = -dot(ro, n) / dot(rd, n);\n    vec3 cp = ro + t * rd;\n    float l = length(cp);\n    if (l < EventsHorizon(p)) return vec3(0.0);\n    float v2 = p / l / _c2;\n    float v = sqrt(v2);\n    vec3 vd = normalize(cross(cp, n));\n    float f = sqrt(1.0 - v2) / (1.0 - v * dot(vd, rd));\n    float val = f * smoothstep(ADISK, 0.0, abs(ADISK - pow(v2, 2.0)));\n    //texture\n    vec3 ss = normalize(cross(n, vec3(0.,0.,1.)));\n    vec3 tt = cross(n, ss);\n    vec2 uv = vec2(dot(cp, ss), dot(cp, tt));\n    uv.x = atan(uv.y, uv.x) / PI - v * 10.0;\n    uv.y = 1.0 / v + Time;\n    vec3 col = textureLod(iChannel0, uv, 3.0).rgb * 2.0;\n    return val * mix(col, vec3(1.0), 0.2);\n}\n\nvec3[4] Lens4(inout vec3 ro, inout vec3 rd)\n{\n    const float dpl = (4.0 * DIST) / float(ITER);\n    const float dt = (sqrt(_c2 + 4.0 * dpl) - _c) * 0.5;\n    \n    float eh0 = EventsHorizon(P0);\n    float eh1 = EventsHorizon(P1);\n    float eh2 = EventsHorizon(P2);\n    float eh3 = EventsHorizon(P3);\n    \n    vec3[4] halo;\n    rd = normalize(rd);\n    for (int i=0; i<ITER; i++)\n    {\n        vec3 r0 = ro - C0;\n        vec3 r1 = ro - C1;\n        vec3 r2 = ro - C2;\n        vec3 r3 = ro - C3;\n        float l0 = length(r0);\n        float l1 = length(r1);\n        float l2 = length(r2);\n        float l3 = length(r3);\n        if (l0 < eh0 || l1 < eh1 || l2 < eh2 || l3 < eh3) break;\n        vec3 a0 = -P0 / (l0*l0*l0) * r0;\n        vec3 a1 = -P1 / (l1*l1*l1) * r1;\n        vec3 a2 = -P2 / (l2*l2*l2) * r2;\n        vec3 a3 = -P3 / (l3*l3*l3) * r3;\n        vec3 a = a0 + a1 + a2 + a3;\n        rd = _c * rd + a * dt;\n        rd = normalize(rd);\n        vec3 dp = _c * rd * dt;\n        float d0 = dot(r0, N0);\n        float d1 = dot(r1, N1);\n        float d2 = dot(r2, N2);\n        float d3 = dot(r3, N3);\n        d0 *= d0 + dot(dp, N0);\n        d1 *= d1 + dot(dp, N1);\n        d2 *= d2 + dot(dp, N2);\n        d3 *= d3 + dot(dp, N3);\n        if (d0 <= 0.0) {halo[0] += RenderAccretionDisk(P0, N0, r0, rd);}\n        if (d1 <= 0.0) {halo[1] += RenderAccretionDisk(P1, N1, r1, rd);}\n        if (d2 <= 0.0) {halo[2] += RenderAccretionDisk(P2, N2, r2, rd);}\n        if (d3 <= 0.0) {halo[3] += RenderAccretionDisk(P3, N3, r3, rd);}\n        ro += dp;\n    }\n    return halo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    Camera cam = GetCamera();\n    vec3 ro, rd;\n    ScreenRay(uv, cam, ro, rd);\n    \n    vec3[4] halo = Lens4(ro, rd);\n    \n    vec3 col = vec3(1.,1.,1.);\n    vec3 c0 = halo[0] * col;\n    vec3 c1 = halo[1] * col;\n    vec3 c2 = halo[2] * col;\n    vec3 c3 = halo[3] * col;\n    col = c0 + c1 + c2 + c3;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.14159265359\n\n//----------------------------------------------Quaternion 四元数算法\n\n//from euler angles 欧拉角四元数\nvec4 QuatEA(vec2 eulers)\n{\n    vec2 eh = eulers * 0.5;\n    float c1 = cos(eh.x), c2 = cos(eh.y);\n    float s1 = sin(eh.x), s2 = sin(eh.y);\n    vec4 nq;\n    nq.x = s1 * c2;\n    nq.y = c1 * s2;\n    nq.z = -s1 * s2;\n    nq.w = c1 * c2;\n    return nq;\n}\n\n//quaternion multiply 四元数乘法\nvec3 QuatMul(vec4 lhs, vec3 rhs)\n{\n    float x1 = lhs.x, y1 = lhs.y, z1 = lhs.z, w1 = lhs.w;\n    float x2 = rhs.x, y2 = rhs.y, z2 = rhs.z;\n    float nx = w1 * x2 + y1 * z2 - z1 * y2;\n    float ny = w1 * y2 - x1 * z2 + z1 * x2;\n    float nz = w1 * z2 + x1 * y2 - y1 * x2;\n    float nw = x1 * x2 + y1 * y2 + z1 * z2;\n    vec3 nv;\n    nv.x = nw * x1 + nx * w1 - ny * z1 + nz * y1;\n    nv.y = nw * y1 + nx * z1 + ny * w1 - nz * x1;\n    nv.z = nw * z1 - nx * y1 + ny * x1 + nz * w1;\n    return nv;\n}\n\nvec3 RotateFWD(vec4 q)\n{\n    vec3 nv;\n    nv.x = 2.0 * (q.x * q.z + q.y * q.w);\n    nv.y = 2.0 * (q.y * q.z - q.x * q.w);\n    nv.z = 1.0 - 2.0 * (q.x * q.x + q.y * q.y);\n    return nv;\n}\n\n\n//---------------------------------------------------Camera 摄像机\nstruct Camera\n{\n    vec3 target; //target position 相机目标位置\n    float dist; //target distance 相机目标距离\n    vec4 rot; //rotation 相机朝向\n    float near; //near clip plane 相机近裁面\n    float far; //far clip plane 相机远裁面\n    float fov; //field of view 视野角度\n    float aspect; //screen w/h 屏幕宽高比\n};\n\nvec3 ScreenToCamera(vec2 uv, float ld, Camera cam)\n{\n    vec3 pos;\n    pos.z = mix(cam.near, cam.far, ld);\n    pos.xy = (uv - 0.5) * 2.0;\n    pos.x *= cam.aspect;\n    float t = tan(radians(cam.fov * 0.5));\n    pos.xy *= pos.z * t;\n    return pos;\n}\nvoid ScreenRay(vec2 uv, Camera cam, out vec3 ro, out vec3 rd)\n{\n    vec3 far = ScreenToCamera(uv, 1.0, cam);\n    vec3 near = cam.near / cam.far * far;\n    vec3 cpos = cam.target - cam.dist * RotateFWD(cam.rot);\n    ro = QuatMul(cam.rot, near) + cpos;\n    rd = QuatMul(cam.rot, far);\n}\n","name":"Common","description":"","type":"common"}]}