{"ver":"0.1","info":{"id":"3tcfWN","date":"1613323488","viewed":238,"name":"Infinite structures travel","username":"TambakoJaguar","description":"After a long time away, I came with a new idea!\nJust let yourself guided on a travel through infinite and surprising structures... Enjoy this fantastic (and psychedelic?) trip!\nIt was fun implementing cool things!\nUse the mouse to look all around you!","likes":9,"published":1,"flags":16,"usePreview":0,"tags":["fast","colorful","modulo","metal","infinite","beams","repetitive","rollercoaster","progressive","metallic","structure","plates","screws"],"hasliked":0,"parentid":"3st3zr","parentname":"Basic 3D scene"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\"Infinite mod structures\" by Emmanuel Keller aka Tambako - February 2021\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tamby@tambako.ch\n\nToDo:\n* Distortion X/Y axes\n  * Camdir\n  * Tilt scene when turning\n    - tilt depends on spedfac (pow 2?)\n* Sometimes intersections missing for a longer time or colors different (every nth)\n  * Or sometimes only along path\n* Crazy lights visible\n* Correct bug screws\n* Ambient occlusion\n* speed variations\n* Fog at times\n  * Vary between blue gray and brown gray\n  * Color also depends on the crazy lights colors (use showCrazyLights)\n* Sometimes jump to the parallel lanes\n* Rusty parts\n* 180° tilt at a few times (smoothstep iTtime + mod)\n* Tunnel at times\n* More variations tiles\n* Speed indicator at bottom of screen (gradient)\n* Reflections (use different coefficients depending on object)\n- Improve shadows?\n- Improve abocc\n* Add comments\n- Try https://www.shadertoy.com/view/ws3Bzf\n\n*/\n\n#define pi 3.14159265359\n\n// Switches, you can play with them!\n#define specular              // Enables specular highlights of light sources on the surfaces\n//#define shadow              // Enables shadows. Doesn't really look good :P\n//#define ambocc              // Enables ambient occlusion. Doesn't really look good :P\n#define plates                // Enables random colored plates\n#define obliques              // Enables random oblique beams\n#define intersections         // Enables the cubes and spheres at the beam's intersections\n#define textures              // Enables the textures on the beams and plates\n#define crazylights           // Enables two lights \"dancing\" in front of the camera and changing its color\n#define showcrazylights       // Enables the display of the crazy lights as \"orbs\"\n#define bumps                 // Enables the screws on the beams and other details as bumps (only for normal)\n#define distortion            // Enables the distortion of the beams in the x and y axes, which is visible at times\n#define fog                   // Enables the fog, visible at times\n#define fognoise              // Enables noise in the fog, making it look like clouds\n#define rust                  // Enables the rust on the beams, visible at times\n#define tunnel                // Enables tunnels, visible at times\n#define varspeed              // Enables variable speed of the camera\n#define tilt                  // Enables tilting of the camera in curves, which is stonger when travelling faster\n#define tilt180               // Enables the tilting of the view to 180° (upside down) at times\n#define sidejumps             // Enables the jumping to parallel \"lanes\" on every 4 direction, at times\n#define shaking               // Enables the shaking of the camera occuring at high speeds\n#define speedindic            // Enables the speed indicator on the bottom of the screen\n//#define keys                // Enables the key function: modification of the zoom factor and retrn in time\n#define spy                   // Enables the appearance of the spy (UFO-like) at times\n//#define spyglitches         // Enables the glitches on the appearance of the spy\n//#define reflections         // Enables the reflections of the beams and spy\n\n// Antialias. Change from 1 to 2 or more AT YOUR OWN RISK! It may CRASH your browser while compiling!\n//#define antialias\nconst float aawidth = 0.65;\nconst int aasamples = 2;\n\n// Ambient light\nconst vec3 ambientColor = vec3(1.);\nconst float ambientint = 0.0;\n\n// Specular options\nconst float specint = 0.55;\nconst float specshin = 55.;\n\n// Shadow options\nconst float shi = 0.5;\nconst float aoint = 0.5;\n\n// Tracing options\nconst float normdelta = 0.0012;\nconst float maxdist = 100.;\n\n// Color options\nconst float gamma = 1.4;\nconst vec3 structure_color1 = vec3(0.8, 0.8, 0.88);\nconst vec3 structure_color2 = vec3(0.78, 0.61, 0.45);\nconst vec3 tunnel_color1 = vec3(0.38, 0.57, 0.49);\nconst vec3 tunnel_color2 = vec3(0.28, 0.51, 0.38);\nconst vec3 tunnel_colord = vec3(0.39, 0.25, 0.21);\n#ifdef reflections\nconst vec3 spy_color = vec3(0.88, 0.77, 0.72);\n#else\nconst vec3 spy_color = vec3(0.64, 0.68, 0.75);\n#endif\n\n// Geometry options\nconst float ssize = 2.8;\nconst float structure_s1 = 0.12;\nconst float ws = 0.83;\nconst float ws2 = 0.05;\nconst float intscale = 0.85;\nconst float bumpheight = 0.004;\nconst float plth = 0.1;\nconst float spysize = 2.8;\n\n// Fog\nconst vec3 fogColor1 = vec3(0.54, 0.63, 0.71);\nconst vec3 fogColor2 = vec3(0.71, 0.59, 0.51);\nvec3 fogColor;\nconst float fogdens0 = 0.18;\nfloat fogdensf;\nfloat fogd;\n\n// Campera options\nvec3 campos = vec3(0., 0., 0.);\nvec3 camtarget = vec3(0., 0., 0.);\nvec3 camdir = vec3(0., 0., 0.);\nfloat fov = 2.2;\nfloat camspeed = 13.;\nfloat camposdist = 1.8;\nfloat camposint = 0.3;\nfloat camtiltf = -0.58;\nfloat camtilt;\nconst float shakeint = 0.0012;\nconst float axm = 2.*pi;\nconst float aym = 0.8;\nfloat camtilt2;\n\nfloat spindh = 0.027;\n\nstruct Lamp\n{\n  \tvec3 position;\n  \tvec3 color;\n  \tfloat intensity;\n  \tfloat attenuation;\n};\n\nstruct RenderData\n{\n  \tvec3 col;\n  \tvec3 pos;\n  \tvec3 norm;\n    float dist;\n};\n   \n#ifdef crazylights\nLamp lamps[3];\n#else\nLamp lamps[1];\n#endif\n\n// Misc variables definition\nvec3 colors[9];\nint aai;\nint aaj;\nfloat time2;\nfloat speedfact;\nfloat mainLampInt;\nbool getSpy = true;\nbool isSpy;\nfloat spyBump;\nfloat refFactor;\nfloat tunnelse;\n\n#ifdef keys\n// Detects if keys are pressed\nconst float KEY_Z = 90.5/256.0;\nconst float KEY_U = 85.5/256.0;\nconst float KEY_H = 72.5/256.0;\nconst float KEY_J = 74.5/256.0;\nconst float KEY_N = 78.5/256.0;\nconst float KEY_M = 77.5/256.0;\nconst float KEY_1 = 49.5/256.0;\nconst float KEY_2 = 50.5/256.0;\nconst float KEY_3 = 51.5/256.0;\nconst float KEY_4 = 52.5/256.0;\nconst float KEY_5 = 53.5/256.0;\nconst float KEY_6 = 54.5/256.0;\nconst float KEY_7 = 55.5/256.0;\nconst float KEY_8 = 56.5/256.0;\nconst float KEY_9 = 57.5/256.0;\nbool isKeyPressed(float key)\n{\n\treturn texture(iChannel3, vec2(key, 0.25) ).x > .0;\n}\n#endif\n\n// Gets the virtual time, which enables a variable speed\nfloat getTime(float time)\n{\n    //time2 = camspeed*(iTime + 158.);\n    float time2 = camspeed*time;\n    \n    #ifdef keys\n    // When pressing numeric keys, you can go back a different distance\n    if (isKeyPressed(KEY_1)) time2-= 2.;\n    if (isKeyPressed(KEY_2)) time2-= 5.;\n    if (isKeyPressed(KEY_3)) time2-= 10.;\n    if (isKeyPressed(KEY_4)) time2-= 20.;\n    if (isKeyPressed(KEY_5)) time2-= 50.;\n    if (isKeyPressed(KEY_6)) time2-= 100.;\n    if (isKeyPressed(KEY_7)) time2-= 200.;\n    if (isKeyPressed(KEY_8)) time2-= 500.;\n    if (isKeyPressed(KEY_9)) time2-= 1000.;\n    #endif\n    \n    #ifdef varspeed\n    time2-= 58.*sin(time/9.) + 25.*cos(time/17.) - 12.*cos(time/5.7);\n    #endif\n    \n    return time2;\n}\n\n// Initializes different things\nvoid init()\n{    \n    // Lamps init\n    lamps[0] = Lamp(vec3(0.5, 0., 0.), vec3(1., 1., 1.), 1.6, 0.03);\n    #ifdef crazylights\n    lamps[1] = Lamp(vec3(0.5, 0., 0.), vec3(1., 0., 0.), 2.8, 0.25);\n    lamps[2] = Lamp(vec3(0.5, 0., 0.), vec3(1., 0., 0.), 2.8, 0.25);\n    #endif\n    \n    // Colors of the plates\n    colors[0] = vec3 (1., 0., 0.);\n    colors[1] = vec3 (1., 1., 0.);\n    colors[2] = vec3 (0., 1., 0.);\n    colors[3] = vec3 (0., 1., 1.);\n    colors[4] = vec3 (0., 0., 1.);\n    colors[5] = vec3 (1., 0., 1.);\n    colors[6] = vec3 (1., 0.65, 0.);\n    colors[7] = vec3 (0.33);\n    colors[8] = vec3 (0.67);\n    \n    // Gets the virtual time and calculates the travel speed\n    time2 = getTime(iTime);\n    speedfact = getTime(iTime+0.1) - getTime(iTime);\n    \n}\n\n// RGB to HSV color conversion\nvec3 hsv2rgb(vec3 c)\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\trgb = rgb*rgb*(3.0-2.0*rgb);\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// HSV to RGB color conversion\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// 2D vector rotation\nvec2 rotateVec(vec2 vect, float angle)\n{\n    vec2 rv;\n    rv.x = vect.x*cos(angle) - vect.y*sin(angle);\n    rv.y = vect.x*sin(angle) + vect.y*cos(angle);\n    return rv;\n}\n\n// 1D hash function\nfloat hash(vec3 p)\n{\n    //p  = 17.0*fract(p*0.3183099+.1);\n\t//return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\n\n    p  = 442.0*fract(p*0.3183099+.131249);\n    return fract(dot(p.xyz, p.zxy));\n    \n\t/*p  = fract(p * .1031);\n    p += dot(p, p.zyx + 31.32);\n    return fract((p.x + p.y) * p.z);  */\n}\n\n#ifdef fognoise\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip.xyz,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\n// From https://www.shadertoy.com/view/4sfGzS\nfloat noise2(vec3 pos)\n{\n    vec3 q = 8.0*pos;\n    float f  = 0.5000*noise(q) ; q = m*q*2.01;\n    f+= 0.2500*noise(q); q = m*q*2.02;\n    f+= 0.1250*noise(q); q = m*q*2.03;\n    f+= 0.0625*noise(q); q = m*q*2.01;\n    return f;\n}\n#endif\n\n// Distorts the whole structure with waves along the x and y axes for a cool effect!\nvec3 distort(vec3 pos)\n{\n    #ifdef distortion\n    float zfac = 0.85;\n    float time3 = mod(time2, 1900.);\n    float dint = 1.2*smoothstep(135., 370., time3)*smoothstep(790., 610., time3);\n    dint+= 2.2*smoothstep(1050., 1290., time3)*smoothstep(1780., 1650., time3);\n    if (dint>0.02)\n    {\n        pos.x+= 1.05*dint*(cos(zfac*pos.z*0.05) + 0.5*sin(zfac*pos.z*0.12) + 0.22*sin(zfac*pos.z*0.19) + 0.07*sin(zfac*pos.z*0.35));\n        pos.y+= 0.85*dint*(sin(zfac*pos.z*0.05) + 0.5*cos(zfac*pos.z*0.14) + 0.18*sin(zfac*pos.z*0.18) + 0.09*sin(zfac*pos.z*0.32));\n    }\n    #endif\n    return pos;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Gets the bump (actually screws) which are only applied on the normal, not during the raymarching, for better speed\n#ifdef bumps\nfloat getNormalBump(vec3 pos)\n{\n    if (isSpy)\n        return 0.;\n\n    pos = distort(pos);\n\n    float bump = 0.;\n    vec3 pos2 = mod(pos, ssize);\n    \n    // Avoids to put screws on intersections!\n    #ifdef intersections\n    vec3 n = floor(pos/ssize);\n    float ns = n.x+n.y+n.z;    \n    float ints;\n    float intprob = 0.77*(0.5 + 0.5*sin(-2.3 + n.z/73.)) + 0.17*(0.5 + 0.5*sin(0.84 + n.z/23.)) + 0.06*(0.5 + 0.5*sin(n.z/11.5));\n    if ((intprob<0.85 || (intprob<0.92 && (n.x==-1. || n.x==0.) && (n.y==-1. || n.y==0.))) && hash(n*571.6518)>0.026)\n    {    \n        if (mod(ns, 2.)==1.)\n           ints = length(pos2-vec3(0.5*ssize))-structure_s1*2.*intscale;\n        else\n           ints = max(max(abs(pos2.x-0.5*ssize)-structure_s1*1.5*intscale, abs(pos2.y-0.5*ssize)-structure_s1*1.5*intscale), abs(pos2.z-0.5*ssize)-structure_s1*1.5*intscale);\n        if (ints<bumpheight)\n            return 0.;\n    }\n    #endif\n    \n    // Avoids to put screws on plates!\n    vec3 n2;\n    vec3 n3;\n    #ifdef plates\n    n2 = floor(pos/ssize-vec3(0., 0.5, 0.5));\n    n3 = floor(pos/ssize-vec3(0.5, 0., 0.5));\n    float platesprob = 0.3*(1.-cos(n2.z/75.)) + 0.07*(1.-cos(n2.z/16.));\n    float wx = max(abs(pos2.x-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.y-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    float wy = max(abs(pos2.y-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    if (hash(n2*752.56258)<platesprob && wx<bumpheight)\n       return 1.8*texture(iChannel1, 0.25*pos.yz).r;\n    if (hash(n3*842.84329)<platesprob && wy<bumpheight)\n       return 1.8*texture(iChannel1, 0.25*pos.xz).r;       \n    #endif\n\n    float tx = abs(pos2.x-0.5*ssize)-structure_s1*0.5;\n    float ty = abs(pos2.y-0.5*ssize)-structure_s1*0.5;\n    float tz = abs(pos2.z-0.5*ssize)-structure_s1*0.5;\n    \n    float bz = max(tx, ty);\n    float by = max(tx, tz);\n    float bx = max(ty, tz);\n    \n    vec3 posb = mod(100.*pos2/ssize, 1.);\n    n3 = 100.*pos2/ssize;\n    \n    float scs = 15.;\n    \n    // Screws on perpendicular beams\n    if (bz<=bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.5, 2.) - scs*pow(posb.z - 0.5, 2.), 0., 1.))):0.;\n    }\n    if (bx<=bumpheight)\n    {\n        bump = (int(n3.z)==51 || int(n3.z)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.y - 0.5, 2.), 0., 1.))):0.;\n    } \n    if (by<=bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(posb.y - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.z)==51 || int(n3.z)==48)?(-sqrt(clamp(1. - scs*pow(posb.z - 0.5, 2.) - scs*pow(posb.y - 0.5, 2.), 0., 1.))):0.;\n    }\n    \n    // Screws on oblique beams\n    #ifdef obliques\n    vec3 pos3 = mod(pos+ssize*(0., 0.5, 0.5), ssize);\n    vec3 pos4 = mod(pos+ssize*(0.5, 0., 0.5), ssize);\n    float tyz2 = abs(pos3.y+pos3.z-ssize)-structure_s1*0.5;\n    float tyz3 = abs(pos3.y-pos3.z)-structure_s1*0.5;     \n    float txz2 = abs(pos4.x+pos4.z-ssize)-structure_s1*0.5;\n    float txz3 = abs(pos4.x-pos4.z)-structure_s1*0.5;     \n    float bz2 = max(tx, tyz2);\n    float bz3 = max(tx, tyz3);\n    float by2 = max(ty, txz2);\n    float by3 = max(ty, txz3); \n    \n    if (by2<=bumpheight && by3>bumpheight)\n    {\n        bump = (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.x+n3.z)==98 || int(n3.x+n3.z)==101)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.25, 2.) - scs*pow(posb.z- 0.25, 2.), 0., 1.))):0.;\n    } \n    else if (by3<=bumpheight && by2>bumpheight)\n    {\n        bump = (int(n3.y)==51 || int(n3.y)==48)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(-n3.x+n3.z)==1 || int(-n3.x+n3.z)==-1)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.75, 2.) - scs*pow(posb.z - 0.35, 2.), 0., 1.))):0.;\n    }\n    else if (bz2<=bumpheight && bz3>bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(n3.y+n3.z)==98 || int(n3.y+n3.z)==101)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.25, 2.) - scs*pow(posb.z- 0.25, 2.), 0., 1.))):0.;\n    } \n    else if (bz3<=bumpheight && bz2>bumpheight)\n    {\n        bump = (int(n3.x)==51 || int(n3.x)==48)?(-sqrt(clamp(1. - scs*pow(posb.x - 0.5, 2.) - scs*pow(1.414*posb.z - 0.5, 2.), 0., 1.))):0.;\n        bump+= (int(-n3.y+n3.z)==1 || int(-n3.y+n3.z)==-1)?(-sqrt(clamp(1. - scs*pow(posb.y - 0.75, 2.) - scs*pow(posb.z- 0.35, 2.), 0., 1.))):0.;\n    }     \n    #endif    \n        \n    return bump;\n}\n#endif\n\n// Maps the spy\n#ifdef spy\nvec3 spypos;\nfloat map_spy(vec3 pos)\n{\n    float zpos = -1000.*(smoothstep(85., 65., mod(iTime, 280.)) - smoothstep(120., 140., mod(iTime, 280.)));\n    //float zpos = -700.*(smoothstep(15., -5., mod(iTime, 280.)) - smoothstep(120., 140., mod(iTime, 280.)));\n    if (abs(zpos)>maxdist)\n        return maxdist;\n    \n    pos.z-= -time2 -7.8 - zpos;\n    pos.x+= 0.09*sin(time2*0.17 + 1.);\n    pos.y+= 0.13*sin(iTime*2.5);\n    pos.z+= 1.2*sin(time2*1.34/camspeed) + 0.52*sin(time2*0.58/camspeed);\n    pos.y*= 1.27;\n    \n    spypos = pos;\n    spypos.x+= 0.09*sin(time2*0.07 + 1.);\n    spypos.y+= 0.13*sin(iTime*2.5);\n    spypos.z+= 0.2*sin(iTime*1.23);  \n    \n    float spyo = length(pos) - 0.26*spysize;\n    \n    // Adds a torus\n    spyo = smin(spyo, sdTorus(pos, spysize*vec2(0.25, 0.05)), spysize*0.02);\n    \n    // Adds a structure\n    float a = atan(pos.x, pos.z) + iTime*0.5;\n    spyBump = .0037*smoothstep(0.88, 0.72, sin(a*24.))*smoothstep(0.15*spysize, 0.145*spysize, abs(pos.y));\n    spyBump-= 0.0037*smoothstep(0.165*spysize, 0.160*spysize, abs(pos.y));\n    spyo+= spyBump;\n    \n    return spyo;\n}\n#endif\n\n// Maps the tunnel on sometimes travels through\n#ifdef tunnel\nfloat map_tunnel(vec3 pos)\n{   \n    float tunnelo = length(pos.xy) - ssize*0.46;\n    float posz = -mod(-pos.z, 3300.);\n    \n    vec3 pos2 = pos;\n    pos2.z = mod(posz, ssize) - ssize*0.3;\n    \n    // Side openings\n    float tunnelf = -length(pos2.yz) + ssize*0.2;\n    tunnelo = max(tunnelo, tunnelf);    \n    \n    // Inside with waves\n    tunnelo = max(tunnelo, -length(pos.xy) + ssize*0.447 + 0.008*abs(sin(posz*15.))*smoothstep(-0.032, -0.042, tunnelf));\n    \n    // Where there is the tunnel, where not\n    // Already calculated in map()\n    //float tunnelse = smoothstep(-604., -602., posz) + smoothstep(-830., -832., posz) - 0.002;\n    //tunnelse*= smoothstep(-2053., -2051., posz) + smoothstep(-2260.5, -2262.5, posz) - 0.002;\n    //tunnelse*= smoothstep(-2932.2, -2930.2, posz) + smoothstep(-2979.7, -2981.7, posz) - 0.002;\n    tunnelo = max(tunnelo, tunnelse);\n    \n    return tunnelo;\n}\n#endif\n\n// Main mapping function\nfloat map(vec3 pos)\n{\n    pos = distort(pos);\n\n    #ifdef spy\n    float spyo;\n    if (getSpy)\n        spyo = map_spy(pos);\n    #endif\n    \n    // The perpendicular beams\n    vec3 pos2 = mod(pos, ssize);\n    \n    float tx = abs(pos2.x-0.5*ssize)-structure_s1*0.5;\n    float ty = abs(pos2.y-0.5*ssize)-structure_s1*0.5;\n    float tz = abs(pos2.z-0.5*ssize)-structure_s1*0.5;\n    \n    float bz = max(tx, ty);\n    float by = max(tx, tz);\n    float bx = max(ty, tz);\n    \n    float str = min(bx, min(by, bz));  \n    \n    // The intersections (alternatively spheres and cubes)\n    #ifdef intersections\n    vec3 n = floor(pos/ssize);\n    float intprob = 0.77*(0.5 + 0.5*sin(-2.3 + n.z/73.)) + 0.17*(0.5 + 0.5*sin(0.84 + n.z/23.)) + 0.06*(0.5 + 0.5*sin(n.z/11.5));\n    if ((intprob<0.85 || (intprob<0.92 && (n.x==-1. || n.x==0.) && (n.y==-1. || n.y==0.))) && hash(n*571.6518)>0.026)\n    {\n        float ns = n.x+n.y+n.z;\n        if (mod(ns, 2.)==1.)\n           str = min(str, length(pos2-vec3(0.5*ssize))-structure_s1*2.*intscale);\n        else\n           str = min(str, max(max(abs(pos2.x-0.5*ssize)-structure_s1*1.5*intscale, abs(pos2.y-0.5*ssize)-structure_s1*1.5*intscale), abs(pos2.z-0.5*ssize)-structure_s1*1.5*intscale));\n    }\n    #endif\n    \n    // The colored plates!\n    #ifdef plates\n    vec3 n2 = floor(pos/ssize-vec3(0., 0.5, 0.5));\n    vec3 n3 = floor(pos/ssize-vec3(0.5, 0., 0.5));\n    \n    // How often the plates should come, depends on the travel path\n    float platesprob = 0.3*(1.-cos(n2.z/75.)) + 0.07*(1.-cos(n2.z/16.));\n    \n    // Adds the plates\n    if (hash(n2*752.56258)<platesprob)\n    {\n        // Vertical\n        float wx = max(abs(pos2.x-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.y-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    \n        // Sometimes there are 4 square holes in the plate (vertical plates)\n        if (hash(n2*829.7685)<0.15)\n        {\n            float wxh = max(abs(pos2.x-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(mod(2.*pos2.y+0.8, ssize))+0.65, 1.-abs(mod(2.*pos2.z+0.8, ssize))+0.65));\n            wx = max(wx, -wxh);\n        }\n        // Or only one bigger square hole...\n        else if (hash(n3*843.4276)<0.032)\n        {\n            float wxh2 = max(abs(pos2.x-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(pos2.x-0.5*ssize)-ws*0.23, 1.-abs(pos2.z-0.5*ssize)-ws*0.23));\n            wx = max(wx, -wxh2);    \n        }      \n    \n        str = min(str, wx);\n    }\n    else\n    {\n    #endif\n    #ifdef obliques\n        // Adds oblique beams, but not when there are plates\n        vec3 pos3 = mod(pos+ssize*(0., 0.5, 0.5), ssize);\n        float bz2prob = 0.45*(1.-0.7*cos((n2.z+5.)/85.)-0.3*cos((n2.z-4.)/40.));\n        float bz3prob = 0.45*(1.-0.7*cos((n2.z+8.)/65.)-0.3*cos((n2.z+5.)/125.));\n        if (hash(n2*462.14823)<bz2prob)\n        {\n            float tyz2 = abs(pos3.y+pos3.z-ssize)-structure_s1*0.5;\n            float bz2 = max(tx, tyz2);\n            str = min(str, bz2);\n        }\n        if (hash(n2*576.17496)<bz3prob)\n        {\n            float tyz3 = abs(pos3.y-pos3.z)-structure_s1*0.5; \n            float bz3 = max(tx, tyz3);\n            str = min(str, bz3);\n         }\n    #endif\n    #ifdef plates\n    }\n    if (hash(n3*842.84329)<platesprob)\n    {\n        // Horizontal\n        float wy = max(abs(pos2.y-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));    \n    \n        // Sometimes there are 4 square holes in the plate (horizontal plates)\n        if (hash(n3*134.7126)<0.15)\n        {\n            float wyh = max(abs(pos2.y-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(mod(2.*pos2.x+0.8, ssize))+0.65, 1.-abs(mod(2.*pos2.z+0.8, ssize))+0.65));\n            wy = max(wy, -wyh);\n        }\n        // Or only one bigger square hole...\n        else if (hash(n3*843.4276)<0.028)\n        {\n            float wyh2 = max(abs(pos2.y-0.5*ssize)-structure_s1*(plth+0.02), max(1.-abs(pos2.x-0.5*ssize)-ws*0.23, 1.-abs(pos2.z-0.5*ssize)-ws*0.23));\n            wy = max(wy, -wyh2);    \n        }      \n        str = min(str, wy);\n    }\n    else\n    {\n    #endif\n    #ifdef obliques\n        // Adds oblique beams, but not when there are plates\n        vec3 pos4 = mod(pos+ssize*(0.5, 0., 0.5), ssize);\n        float by2prob = 0.45*(1.-0.7*cos((n3.z+12.)/80.)-0.3*cos((n3.z-7.)/65.));\n        float by3prob = 0.45*(1.-0.7*cos((n3.z+15.)/35.)-0.3*cos((n3.z-12.)/105.));        \n        if (hash(n3*127.6359)<by2prob)\n        {\n            float txz2 = abs(pos4.x+pos4.z-ssize)-structure_s1*0.5;\n            float by2 = max(ty, txz2);\n            str = min(str, by2);\n        }\n        if (hash(n3*319.5628)<by3prob)\n        {\n            float txz3 = abs(pos4.x-pos4.z)-structure_s1*0.5; \n            float by3 = max(ty, txz3);\n            str = min(str, by3);\n        }\n    #endif\n    #ifdef plates\n    }\n    \n    // Adds the facing plates with holes, but not in the tunnel\n    float posz = -mod(-pos.z, 3300.);\n    tunnelse = smoothstep(-605., -603., posz) + smoothstep(-830., -832., posz) - 0.002;\n    tunnelse*= smoothstep(-2053., -2051., posz) + smoothstep(-2260.5, -2262.5, posz) - 0.002;\n    tunnelse*= smoothstep(-2932.2, -2930.2, posz) + smoothstep(-2979.7, -2981.7, posz) - 0.002;    \n    \n    vec3 n4 = floor(pos/ssize-vec3(0.5, 0.5, 0.5));\n    if (hash(n4*184.567)<platesprob*0.1 && n4.x==-1. && n4.y==-1. && tunnelse>0.)\n    {\n        // Plates on the path facing the camera, with a hole in it\n        float wz = max(abs(pos2.z-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.y-0.5*ssize)-ws));\n        wz = max(wz, -length(pos.xy) + ssize*0.34);    \n    \n        str = min(str, wz);    \n    }\n    #endif\n    \n    // Adds the spy\n    #ifdef spy\n    if (getSpy)\n        str = min(str, spyo);\n    #endif    \n    \n    // Adds the tunnel\n    #ifdef tunnel\n    if (tunnelse<0.4)\n    {\n        float tunnelo = map_tunnel(pos);\n        str = min(str, tunnelo);\n    }\n    #endif\n    \n    return str;\n}\n\n// Main tracing function\nfloat trace(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 0.1;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 145; ++i)\n    {\n    \tpos = ray*t + cam;\n        dist = map(pos);\n        if (t>maxdist || abs(dist)<0.0002)\n            break;\n        t+= dist*0.86;\n  \t}\n  \treturn t;\n}\n\n// Simpler tracing function for crazy lights\n#ifdef showcrazylights\nfloat tracel(vec3 cam, vec3 ray, float maxdist) \n{\n    float t = 1.2;\n    float objnr = 0.;\n    vec3 pos;\n    float dist;\n    \n  \tfor (int i = 0; i < 25; ++i)\n    {\n    \tpos = ray*t + cam;\n        dist = map(pos);\n        if (t>maxdist || abs(dist)<0.0002)\n            break;\n        t+= dist*1.2;\n  \t}\n  \treturn t;\n}\n#endif\n\n// Gets the normal\nvec3 getNormal(vec3 pos, float e)\n{  \n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e2 = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        // Adds the bumps (screws)\n        #ifdef bumps\n        n += e2*(map(pos + e*e2)+bumpheight*getNormalBump(pos + e*e2));\n        #else\n        n += e2*(map(pos + e*e2));\n        #endif\n    }\n    return normalize(n);\n}\n\n// Calculates a soft shadow\n#ifdef shadow\nfloat calcSoftshadow(in vec3 ro, in vec3 rd)\n{\n    float res = 1.0;\n    float tmax = 12.0;  \n    \n    float t = 0.02;\n    for( int i=0; i<40; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n        res = min( res, 24.0*h/t );\n        t += clamp( h, 0.0, 0.80 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n#endif\n\n// Combines the colors\nvec3 getColor(vec3 norm, vec3 pos, vec3 ray)\n{ \n    vec3 pos0 = pos;\n    pos = distort(pos);\n    refFactor = 0.;\n    \n    // Spy coplor\n    isSpy = false;\n    #ifdef spy\n    if (map_spy(pos)<0.002)\n    {\n        isSpy = true;\n        refFactor = 0.71;\n        return mix(spy_color, 1.4*spy_color*texture(iChannel0, 0.8*(pos.xy+spypos.xy)/spysize).rgb, 0.6)*smoothstep(-0.015, 0., spyBump)*mix(vec3(0.98, 0.72, 0.65), vec3(1.), smoothstep(0., 0.24*spysize, abs(pos.y+spypos.y)));\n    }\n    #endif    \n    \n    // Tunnel color\n    #ifdef tunnel\n    if (map_tunnel(pos)<0.001)\n    {\n        float tl = -length(pos.xy) + ssize*0.417;\n        vec3 tcol = mix(tunnel_color1, tunnel_color2, smoothstep(0., -0.008, tl));\n        \n        // Changes the color a bit over the path\n        vec3 tcolhsv = rgb2hsv(tcol);\n        tcolhsv.x = mod(tcolhsv.x - pos.z*.00012 - 0.08, 1.);\n        tcol = hsv2rgb(tcolhsv);\n        \n        // Adds dirt\n        float td1 = texture(iChannel1, 0.3*rotateVec(pos.xz, 1.)).r;\n        float td2 = texture(iChannel1, 0.6*rotateVec(pos.xz, 1.4)).g;\n        float td3 = texture(iChannel1, 1.3*rotateVec(pos.xz, 2.25)).b;\n        float td = 0.45*td1 + 0.35*td2 + 0.2*td3;\n        float dpos = smoothstep(-ssize*0.47, 0., pos.y + 0.07*cos(pos.z*0.8));\n        tcol = mix(tcol, tunnel_colord*smoothstep(dpos + 0.95, dpos + 0.47, td), 0.8*smoothstep(dpos, dpos + 0.62, td));\n        \n        return tcol;\n    }\n    #endif\n\n    vec3 pos2 = mod(pos, ssize);\n\n    vec3 n = floor(pos/ssize);\n    float ns = n.x+n.y+n.z;    \n    vec3 n2 = floor(pos/ssize-vec3(0., 0.5, 0.5));\n    vec3 n3 = floor(pos/ssize-vec3(0.5, 0., 0.5));\n    \n    float scolorprob = 0.7*(0.5+0.5*sin(0.35 + n.z/50.)) + 0.16*(0.5+0.5*sin(n.z/16.)) + 0.14*(0.5+0.5*sin(n.z/4.67));\n    \n    // Colorizes the intersections\n    #ifdef intersections\n    float intprob = 0.77*(0.5 + 0.5*sin(-2.3 + n.z/73.)) + 0.17*(0.5 + 0.5*sin(0.84 + n.z/23.)) + 0.06*(0.5 + 0.5*sin(n.z/11.5));\n    if ((intprob<0.85 || (intprob<0.92 && (n.x==-1. || n.x==0.) && (n.y==-1. || n.y==0.))) && hash(n*571.6518)>0.026)\n    {    \n        if (mod(ns, 2.)==1.)\n        {\n           if (length(pos2-vec3(0.5*ssize))-structure_s1*2.*intscale<0.0008)\n               return scolorprob<0.21?0.8*structure_color1:(hash(n*2.8436)>0.986?vec3(1., 0.03, 0.23):vec3(0.8, 0.65, 0.4));\n        }\n        else\n        {\n            if (max(max(abs(pos2.x-0.5*ssize)-structure_s1*1.5*intscale, abs(pos2.y-0.5*ssize)-structure_s1*1.5*intscale), abs(pos2.z-0.5*ssize)-structure_s1*1.5*intscale)<0.0008)\n                return vec3(0.5, 0.6, 0.7);\n        }\n    }\n    #endif\n    \n    // Colorizes the plates using one of the 6 predefined colors\n    #ifdef plates\n    // Vertical\n    float wx = max(abs(pos2.x-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.y-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    // Horizontal\n    float wy = max(abs(pos2.y-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.z-0.5*ssize)-ws));\n    // Plates on the path facing the camera, with a hole in it\n    float wz = max(abs(pos2.z-0.5*ssize)-structure_s1*plth, max(1.-abs(pos2.x-0.5*ssize)-ws, 1.-abs(pos2.y-0.5*ssize)-ws));\n    float platesprob = 0.3*(1.-cos(n2.z/75.)) + 0.07*(1.-cos(n2.z/16.));\n    \n    // Vertical\n    if (wx<0.01 && hash(n2*752.56258)<platesprob)\n    {\n        vec3 col = colors[int(7.*hash(n2*54.251))];\n        float h = hash(n2*42.519);\n        if (h<0.04)\n            col = colors[7];\n        if (h>0.96)\n            col = colors[8];        \n        #ifdef textures\n        float mc = texture(iChannel1, 0.3*vec2(pos.y, pos.z)).r;\n        return col*(0.7+0.3*mc);\n        #else\n        return col;\n        #endif\n        \n    }\n    // Horizontal\n    else if (wy<0.01 && hash(n3*842.84329)<platesprob)\n    {\n        vec3 col = colors[int(7.*hash(n3*71.849))];\n        float h = hash(n3*39.758);\n        if (h<0.04)\n            col = colors[7];\n        if (h>0.96)\n            col = colors[8];            \n        #ifdef textures\n        float mc = texture(iChannel1, 0.3*vec2(pos.x, pos.z)).r;\n        return col*(0.7+0.3*mc);\n        #else\n        return col;\n        #endif        \n    }\n    // Plates on the path facing the camera, with a hole in it\n    else if (wz<0.01)\n    {\n        vec3 n4 = floor(pos/ssize-vec3(0.5, 0.5, 0.5));\n        if (hash(n4*184.567)<platesprob*0.1 && n4.x==-1. && n4.y==-1.)\n        {\n            vec3 col = colors[int(7.*hash(n4*71.849))];\n            #ifdef textures\n            float mc = texture(iChannel1, 0.3*vec2(pos.x, pos.y)).r;\n            return col*(0.7+0.3*mc);\n            #else\n            return col;\n            #endif             \n        }\n    }\n    else\n    {\n    #endif\n        // Sometimes the structure has a different color\n        vec3 scolor = scolorprob<0.21?structure_color2:structure_color1;\n        \n        // Makes the screws darker and browner\n        #ifdef bumps\n        float bmp = getNormalBump(pos0);\n        if (bmp<0.)\n            scolor = mix(vec3(0.5, 0.32, 0.23), scolor, 0.45);\n        #endif\n        \n        // So that the textures are correct on the different angles of the beams\n        #ifdef textures\n        vec2 tpos;\n        if (abs(norm.x)>0.9 && abs(norm.y)<0.1 && abs(norm.z)<0.1)\n            tpos = vec2(pos.y, pos.z + 1.2);\n        if (abs(norm.x)<0.1 && abs(norm.y)>0.9 && abs(norm.z)<0.1)\n            tpos = vec2(pos.x, pos.z);\n        if (abs(norm.x)<0.1 && abs(norm.y)<0.1 && abs(norm.z)>0.9)\n            tpos = vec2(pos.x+ 0.6, pos.y);\n        if (abs(norm.x)<0.1 && abs(norm.y)>0.45 && abs(norm.z)>0.45)\n            tpos = vec2(pos.x, 1.41*pos.y);\n        if (abs(norm.x)>0.45 && abs(norm.y)<0.1 && abs(norm.z)>0.45)\n            tpos = vec2(1.41*pos.z, pos.y);              \n        vec3 mc = texture(iChannel0, 0.2*tpos).rgb;\n        scolor = mix(scolor, mc, 0.34);\n        \n        refFactor = 0.18;\n        \n        // At some portions of the path, the beams are rusty!\n        #ifdef rust\n        float rustpos = (0.39 + smoothstep(40., 30., iTime) + clamp(0.48*sin(pos.z*0.054) + 0.09*sin(pos.z*0.0298) + 0.1*sin(pos.z*0.0527) + 0.635, 0., 0.6));\n        if (rustpos<0.9)\n        {\n            vec3 n4 = floor(pos/ssize-vec3(0.5 + structure_s1*0.6, 0.5 + structure_s1*0.6, 0.5 + structure_s1*0.6));\n            float rustsize = 0.4 + 1.7*hash(n4*174.1796);\n            float rustrot = 2.*pi*hash(n4*749.5723);\n            vec2 rustoffset = 94.74*vec2(hash(n4*857.236), hash(n4*457.128));\n            tpos = rotateVec(tpos, rustrot)+ rustoffset;\n            vec3 mcr = texture(iChannel0, rustsize*1.1*tpos).rgb;\n            vec3 mcr2 = texture(iChannel1, rustsize*2.1*tpos).rgb;\n            vec3 rustcolor = (0.8 + 0.2*smoothstep(rustpos + 0.02, rustpos + 0.04, 0.6*mcr.r + 0.4*mcr))*mix(vec3(0.43, 0.27, 0.12), vec3(0.84, 0.49, 0.12), 0.5*clamp(6.*mcr2.r - 2.5, 0., 1.) + 0.5*smoothstep(rustpos + 0.02, rustpos + 0.4*(1. - rustpos), mcr.r));\n            float rustFactor = smoothstep(rustpos, rustpos + 0.02, mcr.r);\n            scolor = mix(scolor, rustcolor, rustFactor);\n            refFactor*= 1. - rustFactor;\n        }\n        #endif\n        #endif\n        \n        return scolor;        \n    #ifdef plates\n    }\n    #endif\n}\n\n// Shading of the objects pro lamp\nvec3 lampShading(Lamp lamp, vec3 norm, vec3 pos, vec3 ocol, int lampnr)\n{   \n    float lampint = lamp.intensity;\n    vec3 lampcolor = lamp.color;\n    #ifdef crazylights\n    float lint = smoothstep(30., 180., time2);\n    if (lampnr==0)\n    {\n        // Changes the intensity of the main (camera) lamp with time\n        mainLampInt = 1. -lint + lint*clamp(0.25 + (1. + 1.15*sin(time2*0.018) + 0.215*sin(time2*0.104) + 0.033*sin(time2*0.248)), 0., 1.);\n        lampint*= mainLampInt;\n        lamps[0].intensity = lampint;\n    }\n    if (lampnr==1)\n    {\n        // Changes the intensity and color of the first crazy lamp with time\n        lampint*= lint*(1. + 0.33*sin(time2*0.035));\n        lampcolor = hsv2rgb(vec3(0.5+0.5*cos(time2*0.015), 1., 1.));\n        lamps[1].intensity = lampint;\n        lamps[1].color = lampcolor;\n    }\n    if (lampnr==2)\n    {\n        // Changes the intensity and color of the first crazy lamp with time\n        lampint*= lint*(1. + 0.33*sin(time2*0.043));\n        lampcolor = hsv2rgb(vec3(1.+0.5*cos(time2*0.015), 1., 1.));\n        lamps[2].intensity = lampint;\n        lamps[2].color = lampcolor;       \n    }\n    #else\n    mainLampInt = 1.;\n    #endif\n\n    vec3 lamppos;\n    if (lampnr==0)\n        // Sets the position of the main (camera) lamp\n        lamppos = campos - vec3(pos.x*0.15, pos.y*0.6 - 0.6, 0.8);\n    #ifdef crazylights\n    if (lampnr==1)\n    {\n        // The position variation of the first crazy lamp with time\n        float lpx = 5.5*sin(time2*0.15) + 1.5*sin(time2*0.65) + 0.71*sin(time2*1.05);\n        float lpy = 4.2*sin(time2*0.11) + 1.2*sin(time2*0.55) + 0.65*sin(time2*0.95);\n        float lpz = 5.8*sin(time2*0.18) + 1.9*sin(time2*0.45) + 0.92*sin(time2*1.35) + 8.5;\n        lamppos = campos - vec3(lpx, lpy, lpz);\n        lamps[1].position = lamppos;\n    }\n    if (lampnr==2)\n    {\n        // The position variation of the second crazy lamp with time\n        float lpx = 3.8*sin(time2*0.09 + 3.) + 1.3*sin(time2*0.48) + 0.48*sin(time2*1.12);\n        float lpy = 4.7*sin(time2*0.13 + 2.) + 1.6*sin(time2*0.59) + 0.71*sin(time2*1.03);\n        float lpz = 6.2*sin(time2*0.20 + 1.) + 1.8*sin(time2*0.38) + 0.88*sin(time2*1.28) + 8.5;\n        lamppos = campos - vec3(lpx, lpy, lpz);\n        lamps[2].position = lamppos;\n    }\n    #endif\n    vec3 pl = normalize(lamppos - pos);\n    float dlp = distance(lamppos, pos);\n    float dnp = (0.2+0.8*dot(norm, pl))/pow(1. + lamp.attenuation*dlp, 2.);\n      \n    // Diffuse shading\n    vec3 col = ocol*lampcolor*lampint*smoothstep(-0.1, 1., dnp); //clamp(dnp, 0., 1.);\n    \n    // Specular shading\n    #ifdef specular\n    if (dot(norm, lamppos - pos) > 0.0)\n        col+= lampcolor*lampint*specint*pow(max(0.0, dot(reflect(pl, norm), normalize(pos - lamppos))), specshin)/pow(1. + lamp.attenuation*dlp, 2.);\n    #endif\n    \n    // Softshadow\n    #ifdef shadow\n    col*= shi*calcSoftshadow(pos, pl) + 1. - shi;\n    #endif\n    \n    return col;\n}\n\n// Shading of the objects over all lamps\nvec3 lampsShading(vec3 norm, vec3 pos, vec3 ocol)\n{\n    vec3 col = vec3(0.);\n    for (int l=0; l<lamps.length(); l++)\n        col+= lampShading(lamps[l], norm, pos, ocol, l);\n    \n    return col;\n}\n\n#ifdef showcrazylights\n// This functions shows the crazy lamps as a kind of orb (using specular like dot function)\nvec3 showCrazyLights(vec3 camPos, vec3 ray, vec3 lampPos, float lampInt, vec3 lampCol)\n{\n    float ld = distance(lampPos, camPos);\n    float lvint = (0.7 + 0.7/ld)*lampInt*pow(clamp(dot(normalize(lampPos - camPos), ray), 0., 1.), ld*3000.);\n    if (lvint>0.06)\n    {\n        // Doesn't show the lamps when they are hidden behind an object\n        float tx = tracel(camPos, ray, ld+0.1);\n        if (ld<tx)\n        {\n            return mix(lampCol, vec3(1.), 0.37)*lvint;\n        }\n        else\n            return vec3(0.);\n    }\n    else\n        return vec3(0.);    \n}\n#endif\n\n// Gets the color of the fog depending on the position and ray direction\nvec3 getFogColor(vec3 camPos, vec3 ray)\n{\n    // Varies over time between two defined fog colors\n    float fcfac = 0.5 + 0.32*sin(time2*0.015) + 0.13*sin(time2*0.037) + 0.05*sin(time2*0.066);\n    vec3 fogcol = mix(fogColor1, fogColor2, fcfac)*(0.15 + 0.85*fogdensf);\n    \n    // This changes the color of the fog accordingly to the crazy lights, for a... crazy effect!\n    #ifdef crazylights\n    float ld1 = distance(lamps[1].position, camPos);\n    float ld2 = distance(lamps[2].position, camPos);\n    float lvint1 = (1. - 0.8*mainLampInt)*(0.7 + 0.7/ld1*ld1)*lamps[1].intensity*pow(clamp(dot(normalize(lamps[1].position - camPos), ray), 0., 1.), 6.6/pow(fogdensf, 2.));    \n    float lvint2 = (1. - 0.8*mainLampInt)*(0.7 + 0.7/ld2*ld2)*lamps[2].intensity*pow(clamp(dot(normalize(lamps[2].position - camPos), ray), 0., 1.), 6.6/pow(fogdensf, 2.));\n    \n    fogcol+= 0.1*mix(lamps[1].color, vec3(1.), 0.37)*lvint1;\n    fogcol+= 0.1*mix(lamps[2].color, vec3(1.), 0.37)*lvint2;\n    #endif\n    \n    return fogcol;\n}\n\n// Ambient occlusion\n// From https://www.shadertoy.com/view/Xds3zN\n#ifdef ambocc\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i=0; i<9; i++)\n    {\n        float hr = 0.012 + 0.045*float(i);\n        vec3 aopos =  nor*hr + pos;\n        float dd = map(aopos);\n        occ+= clamp(-(dd - hr)*sca, 0.007, 0.2);\n        sca*= 0.55;\n    }\n    occ = 2.*smoothstep(0.06, 0.5, occ);\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n#endif\n\n// From https://www.shadertoy.com/view/lsSXzD, modified\nvec3 GetCameraRayDir(vec2 vWindow, vec3 vCameraDir, float fov)\n{\n\tvec3 vForward = normalize(vCameraDir);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fov);\n\n\treturn vDir;\n}\n\n// Sets the position of the camera with the mouse and calculates its direction\nvoid setCamera()\n{\n    // Travel position\n    campos.z = -time2;\n    campos = distort(campos);\n    campos.xy*= -1.;\n    \n    // At high speeds, the camera is shaking!\n    #ifdef shaking\n    campos.y+= pow(speedfact, 3.)*shakeint*(sin(time2*2.87) + 0.85*sin(time2*4.23) + 0.65*sin(time2*7.02) + 0.35*sin(time2*11.12) + 0.1*sin(time2*15.62));\n    #endif\n\n    // Changes the camera direction accordingly to the mouse position, so that you can look around!\n   \tvec2 iMouse2;\n   \tif (iMouse.x==0. && iMouse.y==0.)\n      \tiMouse2 = iResolution.xy*vec2(0.5, 0.5);\n   \telse\n      \tiMouse2 = iMouse.xy; \n   \n    float camAngleX = -2.*pi*(iMouse2.x/iResolution.x - 0.5);\n    float camAngleY = pi*(iMouse2.y/iResolution.y - 0.5);\n    if (abs(camAngleX)>pi*0.5)\n       camdir = vec3(-tan(camAngleX), tan(camAngleY), 1.);\n    else\n       camdir = vec3(tan(camAngleX), tan(camAngleY), -1.);\n       \n    // At some times, the camera suddenly tilts to 180°!\n    #ifdef tilt180\n    float t2cs = 0.4;\n    float time3 = mod(iTime, 212.);       \n    camtilt2 = smoothstep(82., 82. + t2cs, time3);\n    camtilt2-= smoothstep(137., 137. + t2cs, time3);\n    camtilt2+= smoothstep(193., 193. + t2cs, time3);\n    camtilt2-= smoothstep(211., 211. + t2cs, time3);\n    #else\n    camtilt2 = 0.;\n    #endif\n    camdir.xy*= 1. - 2.*camtilt2;\n       \n    // Calculates the horizontal bending of the distorded curve and then tilts the camera accordingly, but more at higher speeds\n    vec3 campos2 = vec3(0., 0., -time2 - camposdist);\n    campos2 = distort(campos2);\n    campos2.xy*= -1.;\n    #ifdef tilt\n    camdir+= camposint*vec3(campos2.x - campos.x, campos2.y - campos.y, 0.);\n    camtilt = campos2.x - campos.x;\n    camtilt*= 0.07 + 0.41*pow(speedfact, 2.);\n    #else\n    camtilt = 0.;\n    #endif\n    \n    // Sometimes jump to the parallel lanes\n    #ifdef sidejumps\n    float smxv = 0.81*sin(time2*0.0038) + 0.13*sin(time2*0.0138) + 0.06*sin(time2*0.0267);\n    campos.x+= ssize*smoothstep(0.79, 0.813, smxv);\n    campos.x-= ssize*smoothstep(-0.87, -0.893, smxv);\n    float smyv = 0.82*sin((time2 - 695.)*0.0044 + 0.2) + 0.15*sin((time2 - 695.)*0.0127) + 0.03*sin((time2 - 695.)*0.0312);\n    smyv*= smoothstep(25., 30., iTime);\n    campos.y+= ssize*smoothstep(0.77, 0.793, smyv);\n    campos.y-= ssize*smoothstep(-0.70, -0.723, smyv);\n    #endif\n    \n    #ifdef keys\n    // Pressing some keys change the field of view\n    if (isKeyPressed(KEY_Z)) fov*= 1.4;\n    if (isKeyPressed(KEY_U)) fov/= 1.4;\n    if (isKeyPressed(KEY_H)) fov*= 2.;\n    if (isKeyPressed(KEY_J)) fov/= 2.;\n    if (isKeyPressed(KEY_N)) fov*= 4.;\n    if (isKeyPressed(KEY_M)) fov/= 4.;\n    #endif\n}\n\n// Tracing and rendering a ray\nRenderData trace0(vec3 tpos, vec3 ray, float maxdist)\n{\n    float tx = trace(tpos, ray, maxdist);\n    vec3 col;\n    vec3 pos = tpos + tx*ray;\n    vec3 norm;\n    \n    norm = getNormal(pos, normdelta);\n    col = getColor(norm, pos, ray);\n\n    // Shading\n    col = col*ambientColor*ambientint + lampsShading(norm, pos, col);\n\n    // Ambient occlusion\n    #ifdef ambocc\n    col*= 1. - aoint + aoint*vec3(calcAO(pos, norm));\n    #endif\n\n    // Fog\n    fogd = 1.;\n    #ifdef fog\n    //fogdensf = 1.;\n    fogdensf = clamp(-0.15 + 1.03*sin(campos.z/218.) + 0.27*sin(campos.z/66.) + 0.11*sin(campos.z/18.) , 0., 1.);\n    if (fogdensf>0.)\n    {\n        #ifdef fognoise\n        vec3 fogpos = 0.38*ray.xyz;\n        fogpos.z+= 0.012*campos.z;\n        float fni = (0.8 + 0.15*fogdensf)*(0.5 + 0.3*sin(campos.z/27.5) + 0.15*sin(campos.z/11.2));\n        fogdensf*= ((1. - fni) + fni*noise2(fogpos));\n        #endif\n        float fogdens = fogdensf*fogdens0;\n        fogColor = getFogColor(tpos, ray);\n        fogd = clamp(exp(-pow(fogdens*tx, 2.)), 0., 1.);\n    }\n    col = mix (fogColor*(0.28 + 0.72*mainLampInt), col, fogd);\n    #endif  \n\n    return RenderData(col, pos, norm, tx);\n}\n\n// Main render function\nvec4 render(vec2 fragCoord)\n{   \n  \tvec2 uv0 = fragCoord.xy / iResolution.xy; \n  \tvec2 uv = uv0*2.0 - 1.0;\n  \tuv.x*= iResolution.x / iResolution.y;\n    \n    // Tilts the uv vector\n    #ifdef tilt180\n    camtilt*= 1. - 2.*camtilt2;\n    uv = rotateVec(uv, -camtilt*camtiltf + pi*camtilt2);\n    #endif\n\n    // Main tracing\n  \tvec3 ray = GetCameraRayDir(uv, camdir, fov);\n  \tRenderData traceinf = trace0(campos, ray, maxdist);\n  \tvec3 col = traceinf.col;\n    \n    float fogd1 = fogd;\n    \n    // Reflections\n    #ifdef reflections\n    bool isSpy0 = isSpy;\n    if (refFactor>0.)\n    {\n        float rf2;\n        rf2 = refFactor*fogd;\n        vec3 refray = reflect(ray, traceinf.norm);\n        traceinf = trace0(traceinf.pos, refray, maxdist*0.5);\n        col = mix(col, traceinf.col, rf2);    \n    }\n    isSpy = isSpy0;\n    #endif    \n    \n    #ifdef spyglitches\n    if (isSpy)\n    {\n        getSpy = false;\n        RenderData traceinf2 = trace0(campos, ray, maxdist);\n        float glitchint = 0.7*smoothstep(0.73, 1.02, sin(iTime*1.6) + 0.5*sin(iTime*2.9) + 0.3*sin(iTime*5.8));\n        col*= 1. + 0.6*glitchint*sin(310.*uv.y - 5.*iTime);\n        col+= 0.55*glitchint*vec3(hash(vec3(uv.y + 0.04*uv.x)*542.15), hash(vec3(uv.y + 0.05*uv.x)*742.56), hash(vec3(uv.y + 0.06*uv.x)*246.35))*(1. + 0.5*sin(55.*uv.y + 5.*uv.x - 32.*iTime))*(1. + 0.5*sin(315.*uv.y + 17.*iTime));\n        col = mix(col, traceinf2.col, 0.5*glitchint*(1. + sin(80.*uv.y + 15.*iTime)));\n    }\n    #endif\n    \n    // Shows the crazy lights\n    #ifdef crazylights\n    #ifdef showcrazylights\n    col+= fogd1*showCrazyLights(campos, ray, lamps[1].position, lamps[1].intensity, lamps[1].color);\n    col+= fogd1*showCrazyLights(campos, ray, lamps[2].position, lamps[2].intensity, lamps[2].color);\n    #endif\n    #endif\n    \n    // Displays a speed indicator at the bottom of the screen\n    #ifdef speedindic\n    if  (uv0.y<spindh)\n    {\n        float spind = smoothstep(speedfact*0.3 + 0.03, speedfact*0.3 - 0.03, uv0.x);\n        vec3 spindcol = vec3(smoothstep(0.0, 0.33, uv0.x), smoothstep(0.75, 0.33, uv0.x), 0.45*pow(smoothstep(0., spindh*0.5, uv0.y)*smoothstep(spindh, spindh*0.5, uv0.y), 10.));\n        spindcol*= 0.75 + 0.25*smoothstep(0., spindh*0.5, uv0.y)*smoothstep(spindh, spindh*0.5, uv0.y);\n        // (0.75 + 0.25*smoothstep(0., spindh*0.25, uv0.y)*smoothstep(spindh, spindh*0.75, uv0.y))*        \n        col = mix(col, spindcol, spind*0.75) + 0.12*spindcol*spind;\n    }\n    #endif\n    \n    //col = vec3(hash(574.56*vec3(uv.x, uv.y, 1.)));\n    \n  \treturn vec4(pow(col, vec3(gamma)), 1.0);\n}\n\n// Main image function, with antialiasing\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    init();\n    setCamera();\n    \n    // Antialiasing\n    #ifdef antialias\n    vec4 vs = vec4(0.);\n    for (aaj=0;aaj<aasamples ;aaj++)\n    {\n       float oy = float(aaj)*aawidth/max(float(aasamples-1), 1.);\n       for (aai=0;aai<aasamples ;aai++)\n       {\n          float ox = float(aai)*aawidth/max(float(aasamples-1), 1.);\n          vs+= render(fragCoord + vec2(ox, oy));\n       }\n    }\n    fragColor = vs/vec4(aasamples*aasamples);\n    #else\n    fragColor = vec4(render(fragCoord));\n    #endif   \n}","name":"Image","description":"","type":"image"}]}