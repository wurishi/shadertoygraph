{"ver":"0.1","info":{"id":"Ndy3zy","date":"1632106455","viewed":196,"name":"OKHSL Hue Wheel","username":"leonzh","description":"OKHSL test","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["picker","oklab","okhsv"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision highp float;\n#endif\n\n\nvec4 ring(vec2 pos, float radius, float thick, vec4 color, float s) {\n    s = clamp(s, -1., 1.);\n    thick = 1.-thick;\n    thick = radius*thick;\n    vec2 uv = gl_FragCoord.xy;\n    float alpha = clamp(1.-s*(length(pos-uv)-radius), 0.0, 1.0);\n    float alpha2 = clamp(s*(length(pos-uv)-thick), 0.0, 1.0);\n    alpha = 1.-abs(alpha-alpha2);\n    return mix(color*vec4(alpha), color, alpha);\n}\n\nvec4 ring(vec2 pos, float radius, float thick, vec4 color) {\n    float s = 0.5; // edge smooth ratio by default\n    return ring(pos, radius, thick, color, s);\n}\n\nvec2 pointAround(vec2 o, float s, float rad) {\n    vec2 p = o;\n    o *= s;\n    return vec2(\n        cos(rad)*(o.x-p.x) + p.x,\n        sin(rad)*(o.x-p.x) + p.y\n    );\n}\n\n\nvec2 mouseFragCoord() {\n    return vec2(iMouse.x, iMouse.y);\n}\n\nfloat mouseRadianToPoint(vec2 p) {\n    p = p-mouseFragCoord();\n    return atan(p.y, p.x);\n}\n\nvec4 blendLayer(vec4 layer1, vec4 layer2) {\n    return layer2*layer2.a + layer1*(layer1.a-layer2.a);\n}\n\nvec3 overlay(vec3 dst, vec3 src) {\n    return mix(\n        (2.0*dst)*src,\n        (1.0-(1.0-2.0*(dst-0.5))*(1.0-src)),\n        step(dst, vec3(0.5))\n    );\n}\n\nvec4 hueRingColor() {\n    vec2 center = 0.5*iResolution.xy;\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec2 toCenter = vec2(0.5)-st;\n    float angle = atan(toCenter.y,toCenter.x)/TWO_PI;\n    vec3 color1 = okhsl_to_srgb(vec3(angle, 1.0, 0.415));\n    vec3 color2 = okhsl_to_srgb(vec3(angle, 1.0, 0.575));\n    // apply overlay mode to get better display of blue hue's sharp edge\n    vec3 color = overlay(color1,color2);        \n    vec4 hueRing = ring(\n        center,\n        0.4925*min(iResolution.x, iResolution.y),\n        0.13,\n        vec4(color, 1.0)\n    );\n    return hueRing;\n}\n\n\nvec4 colorSqure(float hue) {\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec4 color = vec4(\n        okhsl_to_srgb(hue, st.x, st.y), 1.0);\n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\n    vec2 st = gl_FragCoord.xy/iResolution.xy;\n    vec2 mu = mouseFragCoord()/iResolution.xy;\n    vec2 center = 0.5*iResolution.xy;\n\n    vec4 ringColor = hueRingColor();\n    float hue = mouseRadianToPoint(center)/TWO_PI;\n    vec4 squreColor = colorSqure(hue);\n    vec4 color = blendLayer(squreColor, ringColor);\n\n    vec4 marker = ring(\n        pointAround(center,0.48,mouseRadianToPoint(center)),\n        iResolution.y*0.029,\n        0.2,\n        vec4(1.)\n    );\n\n\n    fragColor = blendLayer(color, marker);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define M_PI 3.1415926535897932384626433832795\n#define PI M_PI\n#define TWO_PI 6.28318530717958647693\n\n\nfloat cbrt( float x ) {\n    return sign(x)*pow(abs(x),1.0/3.0);\n}\n\nfloat srgb_transfer_function(float a) {\n    return .0031308 >= a ? 12.92 * a : 1.055 * pow(a, .4166666666666667) - .055;\n}\n\nfloat srgb_transfer_function_inv(float a) {\n    return .04045 < a ? pow((a + .055) / 1.055, 2.4) : a / 12.92;\n}\n\nvec3 linear_srgb_to_oklab(vec3 c) {\n    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n    float m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n    float s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,\n        1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,\n        0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_\n    );\n}\n\nvec3 oklab_to_linear_srgb(vec3 c) {\n    float l_ = c.x + 0.3963377774 * c.y + 0.2158037573 * c.z;\n    float m_ = c.x - 0.1055613458 * c.y - 0.0638541728 * c.z;\n    float s_ = c.x - 0.0894841775 * c.y - 1.2914855480 * c.z;\n\n    float l = l_ * l_ * l_;\n    float m = m_ * m_ * m_;\n    float s = s_ * s_ * s_;\n\n    return vec3(\n        +4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,\n        -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,\n        -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s\n    );\n}\n\n// Finds the maximum saturation possible for a given hue that fits in sRGB\n// Saturation here is defined as S = C/L\n// a and b must be normalized so a^2 + b^2 == 1\nfloat compute_max_saturation(float a, float b) {\n    // Max saturation will be when one of r, g or b goes below zero.\n\n    // Select different coefficients depending on which component goes below zero first\n    float k0, k1, k2, k3, k4, wl, wm, ws;\n\n    if (-1.88170328 * a - 0.80936493 * b > 1.0) {\n        // Red component\n        k0 = +1.19086277; k1 = +1.76576728; k2 = +0.59662641; k3 = +0.75515197; k4 = +0.56771245;\n        wl = +4.0767416621; wm = -3.3077115913; ws = +0.2309699292;\n    } else if (1.81444104 * a - 1.19445276 * b > 1.0) {\n        // Green component\n        k0 = +0.73956515; k1 = -0.45954404; k2 = +0.08285427; k3 = +0.12541070; k4 = +0.14503204;\n        wl = -1.2684380046; wm = +2.6097574011; ws = -0.3413193965;\n    } else {\n        // Blue component\n        k0 = +1.35733652; k1 = -0.00915799; k2 = -1.15130210; k3 = -0.50559606; k4 = +0.00692167;\n        wl = -0.0041960863; wm = -0.7034186147; ws = +1.7076147010;\n    }\n\n    // Approximate max saturation using a polynomial:\n    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;\n\n    // Do one step Halley's method to get closer\n    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite\n    // this should be sufficient for most applications, otherwise do two/three steps \n\n    float k_l = +0.3963377774 * a + 0.2158037573 * b;\n    float k_m = -0.1055613458 * a - 0.0638541728 * b;\n    float k_s = -0.0894841775 * a - 1.2914855480 * b;\n\n    {\n        float l_ = 1.0 + S * k_l;\n        float m_ = 1.0 + S * k_m;\n        float s_ = 1.0 + S * k_s;\n\n        float l = l_ * l_ * l_;\n        float m = m_ * m_ * m_;\n        float s = s_ * s_ * s_;\n\n        float l_dS = 3.0 * k_l * l_ * l_;\n        float m_dS = 3.0 * k_m * m_ * m_;\n        float s_dS = 3.0 * k_s * s_ * s_;\n\n        float l_dS2 = 6.0 * k_l * k_l * l_;\n        float m_dS2 = 6.0 * k_m * k_m * m_;\n        float s_dS2 = 6.0 * k_s * k_s * s_;\n\n        float f = wl * l + wm * m + ws * s;\n        float f1 = wl * l_dS + wm * m_dS + ws * s_dS;\n        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;\n\n        S = S - f * f1 / (f1 * f1 - 0.5 * f * f2);\n    }\n\n    return S;\n}\n\n// finds L_cusp and C_cusp for a given hue\n// a and b must be normalized so a^2 + b^2 == 1\nvec2 find_cusp(float a, float b) {\n    // First, find the maximum saturation (saturation S = C/L)\n    float S_cusp = compute_max_saturation(a, b);\n\n    // Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:\n    vec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));\n    float L_cusp = cbrt(1.0 / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));\n    float C_cusp = L_cusp * S_cusp;\n\n    return vec2(L_cusp , C_cusp);\n}\n\n// Finds intersection of the line defined by \n// L = L0 * (1 - t) + t * L1;\n// C = t * C1;\n// a and b must be normalized so a^2 + b^2 == 1\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp) {\n    // Find the intersection for upper and lower half seprately\n    float t;\n    if (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.0) {\n        // Lower half\n\n        t = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));\n    } else {\n        // Upper half\n\n        // First intersect with triangle\n        t = cusp.y * (L0 - 1.0) / (C1 * (cusp.x - 1.0) + cusp.y * (L0 - L1));\n\n        // Then one step Halley's method\n        {\n            float dL = L1 - L0;\n            float dC = C1;\n\n            float k_l = +0.3963377774 * a + 0.2158037573 * b;\n            float k_m = -0.1055613458 * a - 0.0638541728 * b;\n            float k_s = -0.0894841775 * a - 1.2914855480 * b;\n\n            float l_dt = dL + dC * k_l;\n            float m_dt = dL + dC * k_m;\n            float s_dt = dL + dC * k_s;\n\n\n            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:\n            {\n                float L = L0 * (1.0 - t) + t * L1;\n                float C = t * C1;\n\n                float l_ = L + C * k_l;\n                float m_ = L + C * k_m;\n                float s_ = L + C * k_s;\n\n                float l = l_ * l_ * l_;\n                float m = m_ * m_ * m_;\n                float s = s_ * s_ * s_;\n\n                float ldt = 3.0 * l_dt * l_ * l_;\n                float mdt = 3.0 * m_dt * m_ * m_;\n                float sdt = 3.0 * s_dt * s_ * s_;\n\n                float ldt2 = 6.0 * l_dt * l_dt * l_;\n                float mdt2 = 6.0 * m_dt * m_dt * m_;\n                float sdt2 = 6.0 * s_dt * s_dt * s_;\n\n                float r = 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s - 1.0;\n                float r1 = 4.0767416621 * ldt - 3.3077115913 * mdt + 0.2309699292 * sdt;\n                float r2 = 4.0767416621 * ldt2 - 3.3077115913 * mdt2 + 0.2309699292 * sdt2;\n\n                float u_r = r1 / (r1 * r1 - 0.5 * r * r2);\n                float t_r = -r * u_r;\n\n                float g = -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s - 1.0;\n                float g1 = -1.2684380046 * ldt + 2.6097574011 * mdt - 0.3413193965 * sdt;\n                float g2 = -1.2684380046 * ldt2 + 2.6097574011 * mdt2 - 0.3413193965 * sdt2;\n\n                float u_g = g1 / (g1 * g1 - 0.5 * g * g2);\n                float t_g = -g * u_g;\n\n                float b = -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s - 1.0;\n                float b1 = -0.0041960863 * ldt - 0.7034186147 * mdt + 1.7076147010 * sdt;\n                float b2 = -0.0041960863 * ldt2 - 0.7034186147 * mdt2 + 1.7076147010 * sdt2;\n\n                float u_b = b1 / (b1 * b1 - 0.5 * b * b2);\n                float t_b = -b * u_b;\n\n                t_r = u_r >= 0.0 ? t_r : 10000.0;\n                t_g = u_g >= 0.0 ? t_g : 10000.0;\n                t_b = u_b >= 0.0 ? t_b : 10000.0;\n\n                t += min(t_r, min(t_g, t_b));\n            }\n        }\n    }\n\n    return t;\n}\n\nfloat find_gamut_intersection(float a, float b, float L1, float C1, float L0) {\n    // Find the cusp of the gamut triangle\n    vec2 cusp = find_cusp(a, b);\n\n    return find_gamut_intersection(a, b, L1, C1, L0, cusp);\n}\n\nvec3 gamut_clip_preserve_chroma(vec3 rgb) {\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linear_srgb_to_oklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = clamp(L, 0.0, 1.0);\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_0_5(vec3 rgb) {\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linear_srgb_to_oklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L0 = 0.5;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_project_to_L_cusp(vec3 rgb) {\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linear_srgb_to_oklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n\n    float L0 = cusp.x;\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha) {\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linear_srgb_to_oklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float Ld = L - 0.5;\n    float e1 = 0.5 + abs(Ld) + alpha * C;\n    float L0 = 0.5 * (1.0 + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.0 * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nvec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha) {\n    if (rgb.r < 1.0 && rgb.g < 1.0 && rgb.b < 1.0 && rgb.r > 0.0 && rgb.g > 0.0 && rgb.b > 0.0)\n        return rgb;\n\n    vec3 lab = linear_srgb_to_oklab(rgb);\n\n    float L = lab.x;\n    float eps = 0.00001;\n    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    // The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.\n    vec2 cusp = find_cusp(a_, b_);\n\n    float Ld = L - cusp.x;\n    float k = 2.0 * (Ld > 0.0 ? 1.0 - cusp.x : cusp.x);\n\n    float e1 = 0.5 * k + abs(Ld) + alpha * C / k;\n    float L0 = cusp.x + 0.5 * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.0 * k * abs(Ld))));\n\n    float t = find_gamut_intersection(a_, b_, L, C, L0);\n    float L_clipped = L0 * (1.0 - t) + t * L;\n    float C_clipped = t * C;\n\n    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));\n}\n\nfloat toe(float x) {\n    float k_1 = 0.206;\n    float k_2 = 0.03;\n    float k_3 = (1.0 + k_1) / (1.0 + k_2);\n    return 0.5 * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.0 * k_2 * k_3 * x));\n}\n\nfloat toe_inv(float x) {\n    float k_1 = 0.206;\n    float k_2 = 0.03;\n    float k_3 = (1.0 + k_1) / (1.0 + k_2);\n    return (x * x + k_1 * x) / (k_3 * (x + k_2));\n}\n\nvec2 to_ST(vec2 cusp) {\n    float L = cusp.x;\n    float C = cusp.y;\n    return vec2( C / L, C / (1.0 - L) );\n}\n\n// Returns a smooth approximation of the location of the cusp\n// This polynomial was created by an optimization process\n// It has been designed so that S_mid < S_max and T_mid < T_max\nvec2 get_ST_mid(float a_, float b_) {\n    float S = 0.11516993 + 1.0 / (\n        +7.44778970 + 4.15901240 * b_\n        + a_ * (-2.19557347 + 1.75198401 * b_\n            + a_ * (-2.13704948 - 10.02301043 * b_\n                + a_ * (-4.24894561 + 5.38770819 * b_ + 4.69891013 * a_\n                    )))\n        );\n\n    float T = 0.11239642 + 1.0 / (\n        +1.61320320 - 0.68124379 * b_\n        + a_ * (+0.40370612 + 0.90148123 * b_\n            + a_ * (-0.27087943 + 0.61223990 * b_\n                + a_ * (+0.00299215 - 0.45399568 * b_ - 0.14661872 * a_\n                    )))\n        );\n\n    return vec2(S, T);\n}\n\nvec3 get_Cs(float L, float a_, float b_) {\n    vec2 cusp = find_cusp(a_, b_);\n\n    float C_max = find_gamut_intersection(a_, b_, L, 1.0, L, cusp);\n    vec2 ST_max = to_ST(cusp);\n\n    // Scale factor to compensate for the curved part of gamut shape:\n    float k = C_max / min((L * ST_max.x), (1.0 - L) * ST_max.y);\n\n    float C_mid;\n    {\n        vec2 ST_mid = get_ST_mid(a_, b_);\n\n        // Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n        float C_a = L * ST_mid.x;\n        float C_b = (1.0 - L) * ST_mid.y;\n        C_mid = 0.9 * k * sqrt(sqrt(1.0 / (1.0 / (C_a * C_a * C_a * C_a) + 1.0 / (C_b * C_b * C_b * C_b))));\n    }\n\n    float C_0;\n    {\n        // for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.\n        float C_a = L * 0.4;\n        float C_b = (1.0 - L) * 0.8;\n\n        // Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.\n        C_0 = sqrt(1.0 / (1.0 / (C_a * C_a) + 1.0 / (C_b * C_b)));\n    }\n\n    return vec3( C_0, C_mid, C_max );\n}\n\nvec3 okhsl_to_srgb(vec3 hsl) {\n    float h = hsl.x;\n    float s = hsl.y;\n    float l = hsl.z;\n\n    if (l == 1.0){\n        return vec3( 1.0, 1.0, 1.0 );\n    } else if (l == 0.0) {\n        return vec3( 0.0, 0.0, 0.0 );\n    }\n\n    float a_ = cos(2.0 * M_PI * h);\n    float b_ = sin(2.0 * M_PI * h);\n    float L = toe_inv(l);\n\n    vec3 cs = get_Cs(L, a_, b_);\n    float C_0 = cs.x;\n    float C_mid = cs.y;\n    float C_max = cs.z;\n\n    float mid = 0.8;\n    float mid_inv = 1.25;\n\n    float C, t, k_0, k_1, k_2;\n\n    if (s < mid) {\n        t = mid_inv * s;\n        k_1 = mid * C_0;\n        k_2 = (1.0 - k_1 / C_mid);\n        C = t * k_1 / (1.0 - k_2 * t);\n    } else {\n        t = (s - mid)/ (1.0 - mid);\n        k_0 = C_mid;\n        k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n        k_2 = (1.0 - (k_1) / (C_max - C_mid));\n        C = k_0 + t * k_1 / (1.0 - k_2 * t);\n    }\n\n    vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n    return vec3(\n        srgb_transfer_function(rgb.r),\n        srgb_transfer_function(rgb.g),\n        srgb_transfer_function(rgb.b)\n    );\n}\n\nvec3 srgb_to_okhsl(vec3 rgb) {\n    vec3 lab = linear_srgb_to_oklab(vec3(\n        srgb_transfer_function_inv(rgb.r),\n        srgb_transfer_function_inv(rgb.g),\n        srgb_transfer_function_inv(rgb.b)\n    ));\n\n    float C = sqrt(lab.y * lab.y + lab.z * lab.z);\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L = lab.x;\n    float h = 0.5 + 0.5 * atan(-lab.z, -lab.y) / M_PI;\n\n    vec3 cs = get_Cs(L, a_, b_);\n    float C_0 = cs.x;\n    float C_mid = cs.y;\n    float C_max = cs.z;\n\n    // Inverse of the interpolation in okhsl_to_srgb:\n\n    float mid = 0.8;\n    float mid_inv = 1.25;\n\n    float s;\n    if (C < C_mid) {\n        float k_1 = mid * C_0;\n        float k_2 = (1.0 - k_1 / C_mid);\n\n        float t = C / (k_1 + k_2 * C);\n        s = t * mid;\n    } else {\n        float k_0 = C_mid;\n        float k_1 = (1.0 - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;\n        float k_2 = (1.0 - (k_1) / (C_max - C_mid));\n\n        float t = (C - k_0) / (k_1 + k_2 * (C - k_0));\n        s = mid + (1.0 - mid) * t;\n    }\n\n    float l = toe(L);\n    return vec3( h, s, l );\n}\n\n\nvec3 okhsv_to_srgb(vec3 hsv) {\n    float h = hsv.x;\n    float s = hsv.y;\n    float v = hsv.z;\n\n    float a_ = cos(2.0 * M_PI * h);\n    float b_ = sin(2.0 * M_PI * h);\n\n    vec2 cusp = find_cusp(a_, b_);\n    vec2 ST_max = to_ST(cusp);\n    float S_max = ST_max.x;\n    float T_max = ST_max.y;\n    float S_0 = 0.5;\n    float k = 1.0- S_0 / S_max;\n\n    // first we compute L and V as if the gamut is a perfect triangle:\n\n    // L, C when v==1:\n    float L_v = 1.0   - s * S_0 / (S_0 + T_max - T_max * k * s);\n    float C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);\n\n    float L = v * L_v;\n    float C = v * C_v;\n\n    // then we compensate for both toe and the curved top part of the triangle:\n    float L_vt = toe_inv(L_v);\n    float C_vt = C_v * L_vt / L_v;\n\n    float L_new = toe_inv(L);\n    C = C * L_new / L;\n    L = L_new;\n\n    vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n    float scale_L = cbrt(1.0 / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.0)));\n\n    L = L * scale_L;\n    C = C * scale_L;\n\n    vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));\n    return vec3(\n        srgb_transfer_function(rgb.r),\n        srgb_transfer_function(rgb.g),\n        srgb_transfer_function(rgb.b)\n    );\n}\n\nvec3 srgb_to_okhsv(vec3 rgb) {\n    vec3 lab = linear_srgb_to_oklab(vec3(\n        srgb_transfer_function_inv(rgb.r),\n        srgb_transfer_function_inv(rgb.g),\n        srgb_transfer_function_inv(rgb.b)\n    ));\n\n    float C = sqrt(lab.y * lab.y + lab.z * lab.z);\n    float a_ = lab.y / C;\n    float b_ = lab.z / C;\n\n    float L = lab.x;\n    float h = 0.5 + 0.5 * atan(-lab.z, -lab.y) / M_PI;\n\n    vec2 cusp = find_cusp(a_, b_);\n    vec2 ST_max = to_ST(cusp);\n    float S_max = ST_max.x;\n    float T_max = ST_max.y;\n    float S_0 = 0.5;\n    float k = 1.0 - S_0 / S_max;\n\n    // first we find L_v, C_v, L_vt and C_vt\n\n    float t = T_max / (C + L * T_max);\n    float L_v = t * L;\n    float C_v = t * C;\n\n    float L_vt = toe_inv(L_v);\n    float C_vt = C_v * L_vt / L_v;\n\n    // we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:\n    vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));\n    float scale_L = cbrt(1.0 / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.0)));\n\n    L = L / scale_L;\n    C = C / scale_L;\n\n    C = C * toe(L) / L;\n    L = toe(L);\n\n    // we can now compute v and s:\n\n    float v = L / L_v;\n    float s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);\n\n    return vec3 (h, s, v );\n}\n\nvec3 okhsl_to_srgb(float h, float s, float l) {\n    return okhsl_to_srgb(vec3(h, s, l));\n}\nvec3 okhsv_to_srgb(float h, float s, float v) {\n    return okhsv_to_srgb(vec3(h, s, v));\n}\nvec3 srgb_to_okhsl(float r, float g, float b) {\n    return srgb_to_okhsl(vec3(r, g, b));\n}\nvec3 srgb_to_okhsv(float r, float g, float b) {\n    return srgb_to_okhsv(vec3(r, g, b));\n}\n","name":"Common","description":"","type":"common"}]}