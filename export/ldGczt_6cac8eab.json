{"ver":"0.1","info":{"id":"ldGczt","date":"1662331588","viewed":190,"name":"â™« Phobos (pls w8 when compiling)","username":"patu","description":"Phobos, looks bit different on young GPUs.\nhttps://www.pouet.net/prod.php?which=69739\n\nmusic: https://soundcloud.com/super_noise/supernoise-phobos-size-2165-bytes","likes":14,"published":1,"flags":96,"usePreview":1,"tags":["intro","demoscene","8kb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XlSSDR","filepath":"https://soundcloud.com/super_noise/supernoise-phobos-size-2165-bytes","previewfilepath":"https://soundcloud.com/super_noise/supernoise-phobos-size-2165-bytes","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define B0 iChannel0\n\nvec2 uu, vv, a, u;\nvec4\n    bm = vec4(0),\n    br = vec4(0),\n    c = vec4(0),\n    o,\n    C0 = vec4(0);\n\nfloat \n    g = 2.399, \n    r = 3., \n    bc = 1.,\n    d = 96.,\n    cr = 1.1,\n    s = 0.;\n\nmat2 t = mat2(cos(2.399),sin(2.399),-sin(2.399),cos(2.399));\nvec3 i = vec3(.001*6./8.,.001, 0) * .6;\n\nvoid zb() {\n    vec4 y = vec4(0);        \n\n    for (int i = 0; i < 99; ++i){\n        vec2 uv = uu ;//+ .5;\n        s = cr;\n        uv *= s;\n        uv -= (s/2.)-.5;\n        y += texture(B0, uv) / 1499.;\n        cr -= .01;\n    }\n    C0 += pow(abs(y) * 3., vec4(2.)) * 0.6;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    u = fragCoord/iResolution.xy;\n\n         \n        uu = u;\n        vv = u;\n        a = vec2(0, 0.4);\n\n    //vec2 p = v * .2;\n    if (iTime > 160.) d+=d;\n    //vv.y += .5;\n    \n    float h = .85;\n\n    c += (texture(B0, vv) \n        + texture(B0, vv + i.xz * 2.) \n        + texture(B0, vv + i.zx * 4.)\n        + texture(B0, vv - i.xz * 4.) \n        + texture(B0, vv - i.zx * 2.) \n    ) / 5.;\n\n    if (iTime > 64. && iTime < 109.) {\n        h = .6;\n        r = 1.;\n        d = 196.;\n    }\n    \n    for (int j=0;j<96;j++)\n    {  \n        a *= t;\n        \n        o = texture(B0, u + i.xy * ((r += 1. / r) - .5) * a);\n        if (dot(o.rgb, vec3(.2126, .7152, .0722)) > h) {\n            bm += pow(o, vec4(5.3)); \n        }\n        \n        br += o;\n    }\n\n    C0 = mix(\n        c, \n        br / 64.,\n        texelFetch(B0, ivec2(fragCoord.xy), 0).a\n    );\n\n    C0 = mix(\n        C0 + bm / d, \n        (br / 64.).gbba,\n        clamp(\n            pow(length(vv - .5), 2.) * .9,\n            0.,\n            1.\n        )\n    );\n     \n    if (iTime > 193.5) {\n        C0 *= 0.; \n        return;\n    }\n    if (iTime > 122. && iTime < 131.5) \n        C0 *= 1.-(iTime - 122.) / 9.5;\n    \n    C0 = pow(C0, vec4(1.4)) * 1.4 * min(1., iTime / 3.);\n    \n    if (iTime > 162.6)\n        zb();\n    \n    \n    // Output to screen\n    fragColor = C0;\n    //fragColor = texelFetch(B0, ivec2(fragCoord.xy), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 ouv;\n\nvoid mainImage( out vec4 C, in vec2 fragCoord )\n{\n     ouv = fragCoord.xy/iResolution.xy * 2. - 1.;\n     C = vec4(\n        nL(vec3(ouv, 1.) * 2.),\n        nFF(ouv * tan(radians(50.) / 2.) * 4.4),\n        fbm(vec3(ouv.y + 32. + ouv.xy * 1.1, 0.)),// -\n        0\n    );\n    \n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//layout (location=0) uniform vec4 fpar[4];\n\n//layout (binding=0) uniform sampler2D B0;\n//layout (binding=1) uniform sampler2D B1;\n\n#define B1 iChannel0\n\nvec4 C0 = vec4(0.0);\nvec2 ouv;\n\n/* ----------------------------------- part 1 ------------------*/\n\n/* ----------------------------------- part 2 ------------------*/\n\nvec3 \n    lp = vec3(0.0),\n    lightColour = normalize(vec3(1.0, 1.0, 1.)); \n\nvec3 fromRGB(int r, int g, int b) {\n    return vec3(float(r), float(g), float(b)) / 255.;   \n}\n\nvec3 Sky(in vec3 rd, bool showSun, vec3 lightDir)\n{\n   \n   float sunSize = .4;\n   float sunAmount = max(dot(rd, lightDir), .4);\n   float v = pow(1.2 - max(rd.y, 0.0), 3.);\n   vec3 sky = mix(fromRGB(255,136,154), vec3(1., .5, .3) * 1., v);\n   if (showSun == false) sunSize = .1;\n   sky += lightColour * sunAmount * sunAmount * 1. + lightColour * min(pow(sunAmount, 111.0)* sunSize, 1. * sunSize);\n   return clamp(sky, 0.0, 1.0);\n}\n\nfloat\n    PI = 3.14159265,\n    pt = 7.74,\n    ot,\n    oot,\n    t,\n    pn,\n    pp,\n    s,\n    d,\n    domes,\n    al = 0.,\n    dr = 1.,\n    b2size = 1.,\n    nA = 0.01,\n    st = 0.;\n\nbool tu2 = false,\n     ends = false;\n\nvec3 domeo,\n    C = vec3(.8),\n    tun = vec3(1.);\n\nint sc = 0;\n\nvec2 ou(vec2 a, vec2 b) {\n    if (a.x < b.x) return a;\n    return b;\n}\n\nvec2 oi(vec2 a, vec2 b) {\n    if (a.x > b.x) return a;\n    return b;\n}\n\nvec2 os(vec2 a, vec2 b) {\n    if (-b.x > a.x) {\n        return vec2(-b.x, b.y);\n    }\n    return a;\n}\n\nfloat osf(float a, float b) { return max(-b, a); }\nfloat ouf(float a, float b) { return min(a, b); }\n\nfloat smin( float a, float b, float k ) {    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;    \n}\n\n\n\n\n\n\nfloat saturate(float a) { return clamp(a, 0., 1.); }\n\nvoid pR(inout vec2 p, float a) { p = cos(a)*p + sin(a)*vec2(p.y, -p.x); }\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n    vec2 c = floor((p + size*0.5)/size);\n    p = mod(p + size*0.5,size) - size*0.5;\n    return c;\n}\nvec3 pMod3(inout vec3 p, vec3 s) {\n    vec3 c = floor((p + s*.5)/s);\n    p = mod(p + s*.5, s) - s*.5;\n    return c;\n}\n\nvoid pModPolar(inout vec2 p, float r) {\n    float n = 2. * PI / r, a = atan(p.y, p.x) + n / 2., l = length(p);//, c = floor(a/n);\n    a = mod(a, n) - n/2.; p = vec2(cos(a), sin(a)) * l;\n   // return abs(c) >= (r/2.) ? abs(c) : c;\n}\n\nvec3 opRep( vec3 p, vec3 c ) {\n    return mod(p,c)-.5*c;\n}\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec2 v) {\n    return max(v.x, v.y);\n}\n\nvec2 sgn(vec2 v) {\n    return vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\nfloat fbc(vec2 p, vec2 b) {\n    return vmax(abs(p)-b);\n}\n\nfloat fB(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fC(vec3 p, vec3 s) {\n    return min(min(fB(p, s), fB(p, s.zxy)), fB(p, s.yzx));\n}\n\nvec2 fM(vec3 p) {\n    vec2 obj;\n    vec3 p2 = p, p3 = p;\n  \n    pR(p.xz, texture(B1, p.xz * .01).r * .3);        \n\n    float n = pow(texture(B1, p.xz / 128.).r * 11., 1.5);\t\n    p2.y -= n;\n    \n    \n    obj = ou(\n        vec2(fbc(p2.xy, vec2(1e32, 3.)), 2.), \n        vec2(fbc(p.zy, vec2(1e9, 7.)), 1.)\n    );\n\n    if (ends) {\n        p3 -= domeo;\n        \n        vec3 hh = pMod3(p3, vec3(3., 50., 3.));\n        float hr = hash12(hh.xz + 10.) * 2.;\n        \n        p3.y -= 4. * hr - 2. + (oot - 180.) * (.5 + hr * .2);\n        pR(p3.xz, 9. * hr + ot * .4);\n        pR(p3.yx, -8.* -hr + ot * .6);\n        vec2 obj3 = vec2(fB(p3, vec3(.1, .9, .2) / 2.), 4);\n        //obj.x = smin(obj.x, obj3.x, .9);//vec2(fB(p3, vec3(.4)), 1.);\n        //obj3.x -=.02;\n        //obj3.y = oot > 193.5 ? 5 : 2.;\n        obj = ou(obj, obj3);\n    }\n    return obj;\n}\n\nvec2 fD(vec3 p) {\n    p -= domeo;    \n    float \n        s = min(16., max(1., t - 15.)) / 16.,\n        d = mix(\n            length(p) - smoothstep(0., 1., s) * 15.,\n            fB(p, vec3(2., 4.5 ,.5)), \n            smoothstep(0., 1., min(1., max(0., t - 34.) / 10.))\n        );\n\n    if (ot > 120. && ot < 148.) {\n        //s = 1.;\n\n        if (ot < 123.8) {\n            pR(p.xz, -ot );\n            pR(p.xy, ot);\n        }\n\n        if (ot > 137.) \n            pR(p.zy, 3. * texture(B1, vec2(fract(ot * .2))).r);\n        \n\n        float m = max(0., min((ot-120.) / 6. * (fract(p.y * 1.) + 1. + texture(B1, p.zx * .1).r) * 4., 1.)) ;\n        d = mix(d, fB(p, vec3(s)), m);        \n    }\n    domes = s;\n    return vec2(d, 5.);\n}\n\nvec2 mirror (vec2 u) {\n    return vec2(\n        mod(u.x, 2.) < 1. ? u.x : 1. - u.x,\n        mod(u.y, 2.) < 1. ? u.y : 1. - u.y\n    );\n}\n\nvec2 fT(vec3 p) {\n    vec2 \n        obj = vec2(100, -1.0),\n        obj2 = obj,\n        obj3 = obj;\n    \n    vec3 orgP = p,\n         orgP0 = p,\n         orgP1 = p,\n         orgP2,\n         orgP3 = orgP,\n         pp,\n         size;\n\n    orgP3 = p;\n    \n    pp = pMod3(orgP3, vec3(2.4));\n    p = orgP3;\n    \n    obj = vec2(\n        fB(p, vec3(1)), \n        8.\n    );\n    \n    orgP2 = orgP;\n    pR(orgP.zy, pp.x / 12.);\n\n    size = vec3(.725 , 1.2 + pp.x * .1, 1.275) * 1. + pow(max(0., t - 93.) * .4, 1.1) * .1;\n    p.x += sin(ot);\n    p = opRep(orgP, vec3(.35, .1, .4) + size.x + size.y + size.z);\n        \n    obj = os(\n        obj, \n        vec2(                \n            fC(p, size), \n            0\n        )\n    );\n    \n    size *= 1.2;\n    p = opRep(orgP, vec3(.35, .5, .1) / tun + size.x + size.x + size.z);\n    \n    obj = os(\n        obj, \n        vec2(                \n            fC(p, size), \n            0.0\n        )\n    );    \n    \n    p = orgP2;\n\n    pModPolar(p.yz, max(3., 6. + ceil(sin(pp.x * 434.34) * 9.)));        \n    \n    pR(orgP1.yz, orgP1.x * 2. + ot);   \n    orgP1.x -= t * 2.3 + 2.; \n    orgP1.z += 2. + texture(B1, mirror(orgP0.xz * .05)).r * 2.3;// + sin(orgP0.x * .1) * 2.;\n\n    obj3 = vec2(fB(orgP1, vec3(1e32, .3, .3)), 4);\n    //p = orgP;\n    obj = os(obj, vec2(fB(p, vec3(1e32, .6, .6)), 9)); \n    p = orgP2;\n    //pModPolar(p.yz, max(3., 6. + ceil(sin(pp.x * 434.34) * 9.)));\n    p.z = mod(p.z - 2., 4.) - 2.;\n    p.z += 2.;\n    p.y += 3.;\n    p.x += ot * 2.;\n    p.x = mod(p.x + 2., 4.) - 2.;\n    obj2 = vec2(fB(p, vec3(9.,2.,4.) / 8.), 3.);\n    \n    return ou(ou(obj,obj2), obj3);\n}\n\nvec2 fT2(vec3 p) {\n    //p.yz -= (ot - 169.) * 0.1;\n    vec3 op = p;\n    pR(p.yz, p.x * 0.2 + ot * .2);\n    pMod2(p.xz, vec2(40.));\n\n    vec2 obj, obj2;\n    obj.x = 9.;\n    obj2.x = 9.;\n    const float scale = 2.1;\n    const float offset = 1.;\n    const int FRACTALITERATIONS = 5;\n    vec3 modifier = vec3(1.1 ,1.0, .1);// vec3(sin(t), sin(t / 2.), 0.);\n    //if (length(p) > 12. && op.x > 20.) {\n        for(int n=0; n< FRACTALITERATIONS; n++)\n        {        \n            p = abs(p);\n        \n            //p.xy = (p.x - p.y < 0.0) ? p.yx : p.xy;\n            //p.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n            p.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n\n            pR(p.xy, .95121915);\n        \n            //p.yz = -p.zy * vec2(1., -1.);\n            p.x -= 19.;\n        \n         //p.zy = (p.z+p.y < 0.0) ? -p.yz : p.zy;\n        \n            //pModPolar(p.xy, 4.);\n            //pR(p.xy, -.25);\n          pR(p.zy, .345 + p.x * .1 + ot * .1);\n        \n            //if (p.z > 0.5 * scale - 1.) p.z -= scale - 3.;\n        \n            p.xyz = scale* p.xyz - offset*(scale*.6) * modifier.xyz;\n        \n        }\n        p.x += sin(p.z * .1) * 10. + p.y * 3.;\n        obj.x = fB(p, vec3(10, .1, 1)) * (pow(scale, -float(FRACTALITERATIONS))) - .2; \n        obj.y = 9.;\n   // }\n\n   // p += ceil(H(p.xz) * 10.) / 5.;\n    \n\n    p = op;\n    p.x -= 125.;\n    \n    if (length(p) < 14.) {\n    //obj2.x = fB(p, vec3(.5, 4.5, 2.));\n        pR(p.xy, ot * 2. + ceil(ot / pt * 8.));\n        pR(p.zy, -ot);\n        \n\n        //p += texture2D(B1, (op.xz * op.yx) * .001).r;\n        obj2.x = fB(p, vec3(7.));\n        \n\n        obj2.y = 6.;\n\n        \n        //obj2.x = smin(obj.x, obj2.x, .90);\n    \n        obj = ou(obj, obj2);    \n    }\n\n    return obj;\n\n}\n\nvec2 endsc(vec3 p) {\n    p-=domeo;\n    vec3 op = p;\n\n    pR(p.xy, ot * 2. + ceil(ot / pt * 8.));\n    pR(p.zy, -ot);\n    return ou(\n        vec2(fB(p, vec3(1.6)), 5),\n        oi(\n            fT2(op.yzx * 2.) - .2, \n            vec2((1. + texture(B1, op.xy * 2.).r) * length(op * vec3(2., 5., 2.)) - 27. - ot, 2.)\n        )\n    );\n}\n\nvec2 map1(vec3 p) {\n\n    return (sc == 2) \n        ? (!tu2 ? fT(p) : (fT2(p)))\n        : ou(\n            ends ? endsc(p) : fD(p), fM(p)\n        );\n}\n\nvec2 trace1(in vec3 ro, in vec3 rd, int j)\n{\n    float de = ends ? .15 : .25, d = 0.;\n    vec2 r;\n    \n    for (int i = 0; i < 220; i++)\n    {\n        r = map1(ro + rd * d);\n        d += r.x*de;\n        if (abs(r.x) < .001 || d > 199.) break;    \n        if (i > j) break;    \n    }\n    r.x = d;\n    \n    return r;\n}\n\nvec2 traceR1(vec3 ro, inout vec3 rd, inout vec3 sn) {\n    rd = reflect(rd, sn);\n    vec2 tr = trace1(ro + rd * .2, rd, 30);\t\n\n    return tr;\n}\n\nfloat ss(vec3 o, vec3 p, float k, float m) {\n    vec3 r = (p - o); // Unnormalized direction ray.\n\n    float s = 1.,\n          d = 2.,\n          e = max(length(r), .1),\n          sd = e / 18.,\n          h;\n\n    r /= e;\n    for (int i = 0; i < 18; i++) {\n        h = map1(o + r * d).x;\n        s = min(s, smoothstep(0., 1., k * h / d));\n        d += min(h, sd * 2.);\n        if (h < 0.001 || d > e) break;\n    }\n    return min(max(s, m), 1.);\n}\n\nfloat getAO(vec3 h, vec3 n, float d) {\n    return clamp(map1(h + n * d).x / d, .1, 1.);\n}\n\nvec3 n(vec3 p, vec3 rd) {\n    float d=map1(p).x;\n    vec3 n = normalize(\n        vec3(\n            map1(p+vec3(nA,0,0)).x-d,\n            map1(p+vec3(0,nA,0)).x-d,\n            map1(p+vec3(0,0,nA)).x-d\n        )\n    );\n\n    \n    n -= max(.1, dot(n, rd)) * rd;\n\n    return normalize(n);\n    \n}\n \n\nvec4 oc(vec3 p, vec3 n, float m) {\n    vec4 c = vec4(0);\n    if (m == 0.) c = vec4(.3, .2, .1, 0) + (fract(-ot / pt * 4.) * ( 1. +pow(texture(B1, vec2(p.x, length(p.yz)) * .5).b * 1.3, 4.) * (p.z * sin(ot))));//hash12(ceil(p.xz * 8.)/ 8.) * 2.; \n    if (m == 1.) c = vec4(1, .7, .9, 0.);\n    if (m == 2.) {\n        c.rgb = (vec3(1.7, .2, 0.) + texture(B1, -p.xz / p.y).r * 5.) * 4.;                 \n    }     \n    \n    if (m == 3.) c = vec4(1., .5, .2, 1) * 12. * max(.5, fract(t));    \n    if (m == 4.) c = vec4(1);\n    if (m == 5.) {\n        c = vec4(6.) - min(6., t - 39.); \t\n    }\n    \n    if (m == 6.) c = vec4(1);\n\n    if (m == 8.) { \n        c = vec4(1, .5, 0, 0);        \n    }\n    if (m == 7.) c = vec4(1, .7, .4, 0);\n\n    if (m == 9.) c = vec4(2, 1, .4, 0);\n    if (m == 13.) c = vec4(10, 10, 10, 0);\n    return c;\n}\n\n// 5 -dome\n// 1, 2 mountains\n// 0, 8 tunnel \n\nvec4 dc( in vec3 h, in vec3 r, in vec3 n, in vec3 l, float m) {\n    s = .4;\n    d = .5;\n    if (m == 0.) { s = 1.; d = 2.;}\n    if (m == 1.) { s = .4; d = 5.;}\n    if (m == 2.) { s = .6; d = 1.;}\n    if (m == 3.) { s = 1.1; d = 13.; }\n    if (m == 4.) { s = .1; d = 13.; }\n    if (m == 5.) { s = 1.1; d = 10.; }\n    if (m == 6.) { s = 1.1; d = 10.; }\t\n    if (m == 7.) { s = 1.; d = 9.; }\n    if (m == 8.) { s = .4; d = 2.5; }\n    if (m == 9.) { s = .2; d = 1.5; }\n    if (m == 13.) { s = .1; d = 1.5; }\n\n    vec3 ld = l;\n    l += h;\n    //float lDist = ; \n    ld /= max(length(ld / 2.), .001); \n\n    vec4 c = oc(h, n, m);\n    return vec4(c.rgb * ((max(dot(n, ld), .9) * d) + .15) * pow(max(dot(reflect(-ld, n), -r), .5), .1) * .1 * s, c.a);\n}\n\nvec3 fg( vec3  c, float di, vec3 o, vec3 d, vec3 f, float dy, float b) {\n    o.y += 220.;\n    b = .0075;\n    return mix( c, f, saturate(.5 * exp(-o.y * b) * (1.-exp( -di*d.y*b*10. ))/d.y) );\n}\n\nvoid part1() { \n    t = ot;\n    domeo = vec3(160., max(7., 70. - t * 4.) + max(0., min(-35. + t, 7.1)), 70.);\n    if (t > 31.) domeo.y -= 3.;\n\n    if (t > 108.5) t = 108.5 - t + 62.;\n    if (t > 31.) sc = 1;\n    if (t > 62.) sc = 2;\n        \n    if (ends) {\n        domeo = vec3(160, 9, 70);\n    }\n    vec2 uv = ouv;\n    vec3 \n        lp = vec3(100, 40, -100),\n        vuv = vec3(0, 1, 0), // up\n        ro = vec3(t + 120., 30. + t * .3, 80. + t * .3),\n        vrp = domeo;\n    //if (ends) ro = vec3(t + 120. 22.;\n    float        \n        sh,\n        ao,\n        fog,\n        fov = 50.;\n\n    if (!ends)\n        vrp.y = 0.;\n\n    if (sc == 1) {\n        ro = domeo - vec3(32., -2.1, -35.) * vec2(1. - t * .016, 1.).xyx;\n        ro.y = 7.6;\n        vrp.y = 21. - t / 4.9;\n        fov += 33. - max(33., t / 2.);\n    }\n\n    if (sc == 2) {\n        nA = .1;\n        ro = vec3(t * 1.3, -fract((pp + 4. / 64.)* 8.) / 4. + .25, 0); \n        vuv.x = sin(t);\n       // ro.x += sin(length(ouv * .1) * PI) * 3.;\n        vrp = ro + vec3(10, sin(t) * .3, cos(t)) * tun;\n        lp = vec3(100, 0, 0);\n        fov = 110.;        \n        C = vec3(0.);\n    }\n    \n    if (sc == 3) {\n        ro.y = 17.6;\n        vrp = domeo;\n    }\n\n    uv *= tan(radians(fov) / 2.) * 1.1;\n\n    vec3\n        vpn = normalize(vrp - ro),\n        uc = normalize(cross(vuv, vpn)),\n        rd = normalize((ro + vpn + uv.x * uc * iResolution.x / iResolution.y + uv.y * cross(vpn, uc)) - ro);\n\n    vec2 tr = trace1(ro, rd, 300), otr;\n  \n    vec3 od = domeo;    \n    \n    vec3 \n        hit = ro + rd * tr.x,\n        sn = n(hit, rd);\n        domeo += 1e2;\n\n    if (tr.x < 99.) {\n    if (tr.y == 2. && ends && length(hit.xz - od.xz) * .5 < (oot - 184. + fbm(hit.xxz * .1) * 12.)) tr.y = 9.;\n        C = dc( hit, rd, sn, lp, tr.y).rgb ;        \n        \n        if (tr.y != 5. && sc != 2) {                              \n            C *= ss(hit, ro + lp, 13., .6) * \n                getAO(hit, sn, 5.1);\n                \n            C = fg(C, tr.x * 1., hit, rd, vec3(.4, .3, .2), 100., 0.000175);                \n                \n            \n    \n        }\n\n        if (sc == 2) {\t  \n            //lp.x -= 1000.;\n            C = pow(C, vec3(.8));\n            otr = tr;\n            tr = traceR1(hit + rd * .1, rd, sn);\n            hit += rd * tr.x;\n            C += (dc(hit, rd, sn, lp, tr.y).rgb * 2.) * 2.2 / tr.x;// + 1. -pp / 3.);\n            C = fg(C, otr.x * 18., ro, rd, vec3(.1, 0, 0), 130., .00185);//C *= smoothstep(6., 0., otr.x /2.);\n            //if (!tu2) C = mix(C, C.gbr, length(hit.yz) * .1);\n            //C += pp * pow(length(hit.yz) / 8., 4.);\n            if (tr.y == 4.) C/=2.;\n            al = max(otr.x, tr.x) / 18.;\n        }\n        od.y += domes * 2.;\n        C += (1. - saturate(length(od - hit) / (24. + domes * 4.))) * dc( hit, rd, sn, lp, 5.).rgb * ss(hit, od, 22., 0.1) * .1 * domes;\n    } else {\n        //C = mix(vec3(1., .6, 1.), vec3(1, .5, 0.), pow(nL(rd) * 1.4, 3.));   \n        C  = Sky(rd, true, normalize(vec3(10., 30., 10.)));//    mix(vec3(1., 0.4, 0.), vec3(1., .4, .0), rd.y);\n    }\n    //if (ends) C*= 0.;\n    if (ends) {\n        C = mix(C, Sky(rd, true, normalize(vec3(-10., 50., -10.))), tr.x/ 240.);\n    }\n\n    if (oot > 31.) return;\n\n    float den1 = 0., f, distC = -5.;\n \n    for (float i = 0.; i <= 4.; i++) {\n        \n        bool end = false;\n        if (distC > tr.x - 10.) {\n            end = true;\n           // distC = tr.x - 10.;\n                \n        }\n\n        vec3 r = ro + rd * distC;// + steamColor2;\n            r *= 0.5;\n        //r.x += t * 1.;\n        f = fbm(r * .1);\n        f *= 1.35;\n            \n        den1 += pow(f, 9.) * .3;\n        if (den1 > .7 || end == true) break;      \ndistC += 5.;      \n            \n    }\n    den1 = min(den1, .7);\n    C.rgb = mix(C.rgb, vec3(1.), vec3(den1)) ;\n\n}\n\n/* -------------------------------------------------------------------------*/\n\n#define FOV 100.0\n#define FOG .06\n#define FAR 570.\n\nfloat noi(vec3 p) {\n    float noise = \n        2. * texture(B1, mirror(-vec2(p.yx * 0.3) - vec2(ot * 1.2, 1.2))).b;       \n    \n    noise *= \n        texture(B1, mirror(-vec2(p.xz * .02) - vec2(-ot * .4, 9.))).b;        \n    \n    noise -= texture(B1, mirror(vec2((noise), p.xy * .1))).b * 2.;\n      \n    \n    return noise;\n}\n\nvec2 map2(vec3 p) {\n    \n    vec3 bp = p;\n    \n    vec2 obj2, obj, cap;\n    \n    p = bp;\n    \n    float noise = noi(p);\n   \n\n    cap.x = length(p.zy) - 1.4 - noise; \n    cap.y = 2.;\n\n    obj.y = 2.;\n    bp.y += 2.5;\n\n    bp.y += texture(B1, mirror(p.xz * .8 + vec2(0., max(0., st - 15.5) * 2.))).b * 0.15;\n    obj.x = fbc(bp.xy, vec2(1e32, 1.));\n    \n    bp += vec3(0., -6., 16.);\n    \n    vec3 b2s = vec3(0.);    \n        \n    if (st > 15.5) {\n        pR(bp.xy, ot);   \n        pR(bp.xz, ot); \n        b2s = (vec3(9.) + sin(ot * .5) * 2.);\n    } else {\n        bp.y -= 2.;          \n        b2s = vec3(10);\n    \n       bp.y += 14.5 - st;\n       pR(bp.xy, 1.);   \n       pR(bp.xz, 2. + ot * .1); \n       obj2.x = fB(bp, b2size * b2s);\n\n       obj.x = smin(obj.x, obj2.x, texture(B1, mirror(p.xz * .1)).r *.4 + .3);\n       return ou(obj, obj2);\n\n    }\n    obj2.x = fB(bp, b2size * b2s);\n    if (obj.x > 18.) return obj2;\n    cap.x = smin(obj2.x, cap.x, .15);\n    obj2.y = 2.;\n    \n    //p.z -= 6.;\n    //p.x -= 2.;\n    //p.y += 1.5 + sin(ot) * noi(p.zzz / 90.) * .2;\n\n    cap = ou(cap, obj2);\n    return ou(obj, cap);\n}\n\n\nvec2 trace2(in vec3 ro, in vec3 rd, int j)\n{\n    vec2 r;\n    float d = 0.;\n    for (int i = 0; i < 140; i++)\n    {\n        r = map2(ro + rd * d);\n        d += r.x;\n        if (abs(r.x) < .1 || d > FAR || i > j) break;    \n           \n    }\n    r.x = d;\n    return r;\n}\n/*\nvec2 traceR2(inout vec3 ro, inout vec3 rd, inout vec3 sn) {\n    rd = reflect(rd, sn);\n    vec2 tr = trace2(ro + rd * .2, rd, 30);\t\n    ro += rd * tr.x;\n    return tr;\n}*/\n\n#define EP .001\nvec3 getNormal(vec3 pos)\n{\n    float d=map2(pos).x;\n    return normalize(\n        vec3(\n            map2(\n                pos+vec3(EP,0,0)).x-d,\n                map2(pos+vec3(0,EP,0)).x-d,\n                map2(pos+vec3(0,0,EP)).x-d \n            )\n        );\n}\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 12;\n    vec3 rd = (lp - ro); \n\n    float shade = .5;\n    float dist = 1.;\n    float end = max(length(rd), .001);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map2(ro + rd * dist).x;\n        shade = min(shade, smoothstep(0., 1., k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < .001 || dist > end) break;\n    }\n    return min(max(shade, .2), 1.);\n}\n\n\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir ) {  // camera to point vector\n    \n    float c = .3;\n    float b = .2;\n    float fogAmount = c * exp(-rayOri.y * b) * (1.-exp( -distance*rayDir.y*b ))/rayDir.y;    \n    return mix( rgb, vec3(1, .6, .3), min(1.2, fogAmount) );\n}\n\nvec4 getObjectColor(vec3 p, vec3 n, vec2 obj) {\n    vec4 col = vec4(0);\n    col.rgb = vec3(1, .6, .4) * 14.;\n    return col;\n}\n\nvec4 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, vec2 obj) {\n    vec4 sceneCol = vec4(.8);\n    lp = sp + lp;\n    vec3 ld = lp - sp;\n    float lDist = max(length(ld / 2.), .001);\n    ld /= lDist; \n\n   \n    //float atten = 3 / (1. + lDist * .025 + lDist * lDist * .2); \n    //float spec = ;\n\n\n    vec4 objCol = getObjectColor(sp, sn, obj);\n    sceneCol.rgb += (objCol.rgb * (max(dot(sn, ld), 1.) + .15) * pow(max(dot(reflect(-ld, sn), -rd), 1.), .1) * .1);\n    \n    return sceneCol;\n}\n\nvoid part2() {    \n    vec2 uv = ouv;\n    \n    lp = vec3(10, 30, -10);        \n        \n    vec3 \n        vuv = vec3(0, 1, 0),\n        ro = vec3(0, -1, 10),\n    \n        vrp =  vec3(0, 1.4, 0);\n        \n    if (st < 15.5) {\n        pn = ceil(ot / pt * 2.);\n        float x = hash12(vec2(pn));\n        ro = vec3(sin(st * .1 + x * 3.) * 14., 4., 6.);\n        vrp =  vec3(0., 1.4, -16);\n    }\n\n    vec3    \n        vpn = normalize(vrp - ro),\n        u = normalize(cross(vuv, vpn)),\n        v = cross(vpn, u),\n        vcv = (ro + vpn),\n        scrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n        rd = normalize(scrCoord - ro);\n    \n    vec3 sceneColor = vec3(0.);\n    \n\n    \n    vec2 tr = trace2(ro, rd, 100);\n    \n    float fog = smoothstep(FAR * FOG, 0., tr.x / 6.);\n    vec3 hit = ro + rd * tr.x;\n    \n    vec3 sn = getNormal(hit);\t\n    \n    float sh = softShadow(hit, ro + lp, 2.);\n    \n    float \n        ao = getAO(hit, sn, 1.6);\t\n\n    vec3 sky = Sky(rd, true, normalize(lp));\n    vec3 skyNoSun = Sky(rd, false, normalize(lp));    \n\n    float alpha = 0.;\n    if (tr.x < FAR) { \n        \n        vec4 col = doColor(hit, rd, sn, lp, tr);\n        //alpha = pow(tr.dist / FAR * 3.6, 6.);\n        sceneColor = col.rgb;\n        \n        sceneColor *= ao * sh; \n        sceneColor *= 1. + length(\n            max(0.,\n                1. * max(\n                    0.,\n                    length(normalize(lp.xy) * max(vec2(0), sn.xy))\n                )\n             * 3.\n        ));\n        sceneColor = mix(sceneColor, skyNoSun, (1. - fog) * .6);  \n        sceneColor = mix(sceneColor, skyNoSun, saturate(tr.x * 1.1 / FAR));\n        //sceneColor += fbm(vec3(ro.xy * .02, ot * .1)) * 3. * clamp((hit.y + 1.7) / 3., 0., .4);\n        //vec2 tr2 = trace2(hit, rd, 50);\n        //sn = getNormal(hit);\n        //sceneColor += doColor(hit, rd, sn, light, tr2).rgb * .2;\n    } else {\n        sceneColor = sky;\n        tr.x = FAR;\n    }\n    \n    sceneColor = applyFog(sceneColor, tr.x, ro, rd) + .1 * texture(B1, mirror(hit.xy * .2 + vec2(-ot * .1, 0.))).g;   \n    C = clamp(sceneColor * (1. - length(uv) / 2.5), 0., 1.);\n    C = pow(C, vec3(1.3));\n        \n    \n\n    //C = vec3(noi(rd) * 20.);\n}\n\n/* -------------------------------------------------------------------------*/\n\n\n\nvoid main2() { \n    \n    \n    if (ot > 178.) {\n        st = ot - 178.;\n        ot = abs(178. - ot);\n        ends = true;\n        part1();\n        return;\n    }\n    \n    if (ot > 162.5) {\n        tu2 = true;            \n        ot = 250. - ot;            \n        //tun = vec3(2.07, 15., 2.1);\n        part1();\n        dr = .3;\n        return;\n    }\n\n    if (ot < 131.3) {\n        part1();\n        return;\n    }\n    if (ot > 131.3) { \n        st = ot - 131.5;\n        part2();\n        return;\n    }\n          \n\n   \n\n    \n}\nvoid init() {    \n    pn = ceil(ot / pt);\n    pp = fract(ot / pt);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    C *= 0.;\n    ouv = fragCoord.xy/iResolution.xy - .5;\n    if (abs(ouv.y) < .8) {\n        ot = iTime;\n        oot = ot;\n    \n        init();\n        main2();\n\n        C0 = vec4(C, al * dr);\n    }\n    fragColor = C0;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float hash( uint n ) \n{\n    n = (n << 13U) ^ n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.;\n}\n\nfloat hash12(vec2 p) {\n    uint h = uint(dot(p,vec2(127.1,311.7)));\t\n    return fract(hash(h));\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n    vec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n    float b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n    float d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n    b = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n    d = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n\nfloat fbm(vec3 x)\n{\n    float r = 0.0;\n    float w = 1.0, s = 1.0;\n    for (int i=0; i<5; i++)\n    {\n        w *= 0.5;\n        s *= 2.0;\n        r += w * noise_3(s * x);\n    }\n    return r;\n}\n\n// 3D Voronoi: Obviously, this is just a rehash of IQ's original.\nfloat v(vec3 p){\n    vec3 b, r, g = floor(p);\n    float d = 1.;\n\n    for(int j = -1; j <= 1; j++) \n        for(int i = -1; i <= 1; i++) \n            for(int k = -1; k <= 1; k++) {\n                b = vec3(i, j, k);\n                r = b - fract(p) + fract(vec3(2097152, 262144, 32768)*sin(dot(g+b, vec3(7, 157, 113)))); \n                d = min(d, dot(r,r));\n            }    \n\n    return d; // Range: [0, 1]\n}\n\nfloat nL(in vec3 p) {\n    float b = 0., s = 0., a = 1.;\n\n    for (int i = 0; i < 9; i++) {\n        b += v(p) * a; p *= 2.; s += a; a /= 2.; \n    }\n\n    return b / s; // Range: [0, 1].\n}\n\n#define H(p) fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123)\n#define M mix(\nfloat nF(in vec2 p) {\n    vec2\n        i = floor( p ), f = fract( p ), u = f * f * (3. -2. * f);\n\n    #define G1 H(i+vec2(\n    return M M G1 0,0)),G1 1,0)), u.x),M G1 0,1)),G1 1,1)), u.x), u.y);\n}\n\nfloat nFF(vec2 u) {\n  #define Z(x) x*nF(u);u*= mat2(1.6, 1.2, -1.2, 1.6);f+=\n  float f = Z(.5)Z(.25)Z(.125)Z(.0625)0.;\n  return f;\n}","name":"Common","description":"","type":"common"}]}