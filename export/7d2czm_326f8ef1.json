{"ver":"0.1","info":{"id":"7d2czm","date":"1643302398","viewed":466,"name":"Implicit cubic Béziér curve","username":"stegu","description":"Rational parametric curves (x(t)/w(t), y(t)/w(t)), where x, y and w are polynomials of degree N, have an implicit form F(x,y) where F is a polynomial in (x,y) of degree N and points on the curve for any t are exactly the points where F(x,y)=0.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["bezier","distance","implicit","polynomial","signed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Always show the square [-1, 1], with correct aspect ratio\n    vec2 p = -1.0 + 2.0*fragCoord/min(iResolution.x, iResolution.y);\n\n    // Control points for a cubic Bezier segment\n    vec4 xc = vec4(-0.2, 0.3, 0.7, 1.2);\n    vec4 yc = vec4(-0.2, 0.2, 0.2, -0.2);\n    \n    // Animate the control points to show off\n    // (and to show the problems with folding and sign flips)\n    xc.y = 0.3+0.2*sin(iTime/sqrt(3.0));\n    yc.y = 0.2+0.2*sin(iTime/sqrt(5.0));\n    xc.z = 0.7+0.2*sin(iTime/sqrt(7.0));\n    yc.z = 0.4+0.2*sin(iTime/sqrt(11.0));\n    \n    // Convert to canonical parametric form\n    vec4 a, b;\n    bezierpolynomial(xc, yc, a, b);\n    // Implicitize (this is a lot of work, and unbelievably stupid to do once\n    // per *fragment*, but this is Shadertoy, and it's a demo, not a time\n    // critical application, so we let the GPU do a ton of unnecessary work.\n    float[10] c;\n    implicitizebezier(a, b, c);\n\n    // Now, let's evaluate our newly constructed implicit function.\n    float F = evalimplicitcubic(c, p);\n\n    // And then, render a nice visualisation of it.\n    float levels = abs(mod(F*2.0, 1.0)-0.5);\n    float r = 0.05;\n    float linewidth = 0.01;\n    float dpoints = min(min(\n            circled(vec2(xc.x, yc.x), r, p),\n            circled(vec2(xc.y, yc.y), r, p)),\n        min(circled(vec2(xc.z, yc.z), r, p),\n            circled(vec2(xc.w, yc.w), r, p)) );\n    float dlines = min(min(\n            lined(vec2(xc.x, yc.x), vec2(xc.y, yc.y), p),\n            lined(vec2(xc.y, yc.y), vec2(xc.z, yc.z), p)),\n            lined(vec2(xc.z, yc.z), vec2(xc.w, yc.w), p));\n    float points = 1.0-aastep(linewidth, dpoints);\n    float lines = 1.0-aastep(linewidth, dlines);\n    vec3 pointcolor = vec3(1.0,0.5,0.0);\n    vec3 linecolor = vec3(1.0,1.0,0.0);\n\n    vec3 pluscolor = vec3(0.0,1.0,0.5)*levels;\n    vec3 minuscolor = vec3(0.0,0.5,1.0)*levels;\n    vec3 mixcolor = mix(minuscolor, pluscolor, aastep(0.0, F));\n    mixcolor = mix(mixcolor, linecolor, lines);\n    mixcolor = mix(mixcolor, pointcolor, points);\n\n    fragColor = vec4(mixcolor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n// Compute the shortest distance from p to a line segment from p1 to p2.\nfloat lined(vec2 p1, vec2 p2, vec2 p) {\n    vec2 p1p2 = p2 - p1;\n    vec2 v = normalize(p1p2);\n    vec2 s = p - p1;\n    float t = dot(v, s);\n    if (t<0.0) return length(s);\n    if (t>length(p1p2)) return length(p - p2);\n    return length(s - t*v);\n}\n\n// Compute the shortest distance from p to a circle\n// with center at c and radius r.\nfloat circled(vec2 c, float r, vec2 p) {\n    return abs(length(p - c) - r);\n}\n\n// Compute polynomial coefficients for a\n// cubic Bezier curve, from:\n//\n// x = x0*B0(t)+x1*B1(t)+x2*B2(t)+x3*B3(t),\n// y = y0*B0(t)+y1*B1(t)+y2*B2(t)+y3*B3(t),\n//\n// where (x0,y0), (x1,y1), (x2,y2) and (x3,y3)\n// are the control points and\n// B0(t)=(1-t)^3, B1(t)=3*t*(1-t)^2,\n// B2(t)=3*t^2*(1-t), B3(t)=t^3\n//\n// to:\n//\n// x = A(t), y = B(t),\n// where A(t) = a0+a1*t+a2*t^2+a3*t^3,\n// B(t) = b0+b1*t+b2*t^2+b3*t^3\n//\nvoid bezierpolynomial(vec4 x, vec4 y, out vec4 a, out vec4 b) {\n// Let's use the alternative array index notation instead of .xyzw\n// (This is a linear transformation, i.e. it could be written as\n// two matrix multiplications M*x, M*y instead.)\n    a[0] = x[0];\n    a[1] = -3.0*x[0] + 3.0*x[1];\n    a[2] = 3.0*x[0] - 6.0*x[1] + 3.0*x[2];\n    a[3] = -x[0] + 3.0*x[1] - 3.0*x[2] + x[3];\n    b[0] = y[0];\n    b[1] = -3.0*y[0] + 3.0*y[1];\n    b[2] = 3.0*y[0] - 6.0*y[1] + 3.0*y[2];\n    b[3] = -y[0] + 3.0*y[1] - 3.0*y[2] + y[3];\n}\n\n// Implicitization of a general parametric cubic curve\n// from x=A(t), y=B(t) to C(x,y)=0\n// where A(t) = a0+a1*t+a2*t^2+a3*t^3, B(t)=b0+b1*t+b2*t^2+b3*t^3 and\n// C(x,y)=C1+Cx*x+Cy*y+Cx2*x^2+Cxy*x*y+Cy2*y^2+Cx3*x^3+Cx2y*x^2*y+Cxy2*x*y^2+Cy3*y^3\n//\n// The a, b coefficients are stored in one vec4 each, \n// and the C coefficients are stored in an array:\n// vec4 a = vec4(a0, a1, a2, a3)\n// vec4 b = vec4(b0, b1, b2, b3)\n// c[10] = float[](C1, Cx, Cy, Cx2, Cxy, Cy2, Cx3, Cx2y, Cxy2, Cy3)\n//\nvoid implicitizebezier(vec4 a, vec4 b, out float[10]c) {\n    // The array c[10] is not a natural fit for GLSL. Packing the ten\n    // coefficients into three vec4 variables or a matrix could be a\n    // better option for speed. A float RGB texture could store the\n    // coefficients in four texels. There are many options.\n\n    // This is barely-ported Matlab/Maple code from 2006.\n    // Hopefully, the compiler can sink its optimization teeth into it,\n    // but I should write this on a form better suited for numerical\n    // computation, to make sure there are no unnecessary operations\n    // and possibly improve accuracy and numerical stability.\n    vec4 a2 = a*a;\n    vec4 a3 = a2*a;\n    vec4 b2 = b*b;\n    vec4 b3 = b2*b;\n    vec4 ab = a*b;\n\n    // C1\n    c[0] = ab.x*ab.w*a.y*b.z - 3.0*a2.x*ab.w*b.z*b.y - a3.x*b3.w\n        + 3.0*a.w*b.x*a2.x*b2.w + 2.0*a2.x*b2.w*a.z*b.y + a3.w*b3.x\n        - ab.w*ab.x*a.z*b.y + 3.0*a2.w*ab.x*b.z*b.y + 3.0*ab.w*b2.x*a.z*a.y\n        + a.y*b2.w*a2.x*b.z - 2.0*ab.w*b.y*a2.y*b.x + 2.0*ab.w*b2.y*a.y*a.x\n        - a2.w*b3.y*a.x + a3.y*b2.w*b.x + a2.w*b2.y*a.y*b.x - 3.0*ab.x*b2.w*a.z*a.y\n        + a.w*b.z*a2.z*b2.x + a.w*b2.z*a2.y*b.x - a2.w*b.y*a.z*b2.x\n        - a2.y*b2.w*b.y*a.x + a.w*b3.z*a2.x - 2.0*a.w*b2.z*a.z*ab.x\n        - 3.0*a2.w*b2.x*a.x*b.w - 2.0*a2.w*b2.x*a.y*b.z - ab.z*b.w*a2.y*b.x\n        + a2.z*b.w*ab.y*b.x + ab.z*b.w*ab.y*a.x + 2.0*a2.z*b.w*ab.x*b.z\n        - a.z*b.w*a2.x*b2.z - a2.z*b.w*b2.y*a.x + a.w*ab.z*b2.y*a.x\n        - a.w*b2.z*ab.y*a.x - a.w*ab.z*ab.y*b.x - a3.z*b.w*b2.x;\n \n    // Cx\n    c[1] = - 2.0*a.y*b2.w*b.z*a.x - 3.0*a2.w*b.x*b.z*b.y - ab.w*a.y*b.z*b.x + 3.0*b3.w*a2.x\n        - 2.0*ab.w*b2.y*a.y + 6.0*ab.w*a.x*b.z*b.y + a2.y*b2.w*b.y + a2.w*b3.y\n        + 3.0*a2.w*b2.x*b.w + 2.0*a.w*b2.z*a.z*b.x - a.w*ab.z*b2.y + a2.z*b.w*b2.y\n        + a.w*b2.z*ab.y - 2.0*a2.z*b.w*b.x*b.z - 4.0*b2.w*a.z*b.y*a.x\n        - ab.z*b.w*ab.y + 2.0*a.z*b.w*b2.z*a.x - 2.0*a.w*b3.z*a.x - 6.0*a.w*b.x*b2.w*a.x\n        + ab.w*b.x*a.z*b.y + 3.0*b2.w*a.z*b.x*a.y;\n    \n    // Cy\n    c[2] = 6.0*a2.w*ab.x*b.w - 3.0*a2.w*a.x*b.z*b.y + 2.0*a.w*b2.z*a.z*a.x - 3.0*a3.w*b2.x\n        - 2.0*a.w*b.z*a2.z*b.x + 2.0*ab.w*b.y*a2.y + ab.w*a.z*b.y*a.x\n        + 3.0*a.x*b2.w*a.z*a.y + 2.0*a3.z*b.w*b.x - a2.w*b2.y*a.y - a.x*ab.w*a.y*b.z\n        - 3.0*a.w*a2.x*b2.w - a2.z*b.w*ab.y + ab.z*b.w*a2.y - 2.0*a2.z*b.w*a.x*b.z\n        - 6.0*ab.w*a.z*b.x*a.y + 4.0*a2.w*a.y*b.z*b.x - a3.y*b2.w - a.w*b2.z*a2.y\n        + 2.0*a2.w*b.y*a.z*b.x + a.w*ab.z*ab.y;\n    \n    // Cx2\n    c[3] = - 3.0*b3.w*a.x - a.z*b.w*b2.z + 2.0*b2.w*a.z*b.y + 3.0*a.w*b.x*b2.w\n        - 3.0*ab.w*b.z*b.y + a.w*b3.z + a.y*b2.w*b.z;\n    \n    // Cxy\n    c[4] = - 2.0*a.w*b2.z*a.z + 2.0*a2.z*b.w*b.z - 6.0*a2.w*b.x*b.w + 6.0*a.w*b2.w*a.x\n        + 3.0*a2.w*b.z*b.y - ab.w*a.z*b.y + ab.w*a.y*b.z - 3.0*b2.w*a.z*a.y;\n    \n    // Cy2\n    c[5] = - a2.w*b.y*a.z + 3.0*ab.w*a.z*a.y + a.w*b.z*a2.z + 3.0*a3.w*b.x\n        - 2.0*a2.w*a.y*b.z - 3.0*a2.w*a.x*b.w - a3.z*b.w;\n    \n    // Cx3\n    c[6] = b3.w;\n    \n    // Cx2y\n    c[7] = -3.0*a.w*b2.w;\n    \n    // Cxy2\n    c[8] = 3.0*a2.w*b.w;\n    \n    // Cy3\n    c[9] = -a3.w;\n}\n\n// Evaluate an implicit cubic polynomial F(x,y) in 2-D, where\n// c = [C1, Cx, Cy, Cx2, Cxy, Cy2, Cx3, Cx2y, Cxy2, Cy3] and\n// F(x,y) = C1+Cx*x+Cy*y+Cx2*x^2+Cxy*x*y+Cy2*y^2+Cx3*x^3+Cx2y*x^2*y+Cxy2*x*y^2+Cy3*y^3\n//\nfloat evalimplicitcubic(float c[10], vec2 p) {\n// Temp vars for more readable code (will be optimized away as aliases)\nfloat C1 = c[0];\nfloat Cx = c[1];\nfloat Cy = c[2];\nfloat Cx2 = c[3];\nfloat Cxy = c[4];\nfloat Cy2 = c[5];\nfloat Cx3 = c[6];\nfloat Cx2y = c[7];\nfloat Cxy2 = c[8];\nfloat Cy3 = c[9];\n// Rewrite this for speed and accuracy to reuse intermediate results\n// (split to monomials, \"Horner's rule\")\nreturn C1 + Cx*p.x + Cy*p.y + Cx2*(p.x*p.x) + Cxy*p.x*p.y + Cy2*p.y*p.y\n    + Cx3*p.x*p.x*p.x + Cx2y*p.x*p.x*p.y + Cxy2*p.x*p.y*p.y + Cy3*p.y*p.y*p.y;\n}\n","name":"Common","description":"","type":"common"}]}