{"ver":"0.1","info":{"id":"MfcyRS","date":"1731209937","viewed":57,"name":"Pendulum Multi-Joint Physics v0","username":"8InfinityTaco8","description":"After days of banging my head against the wall, I finally got the multi-joint pendulum to reach vertical stability, with each segment able to stand on its unstable equilibrium. This implementations similar to my single joint accounting for precision error","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["education","physics","pendulum","multipass","multijoint"],"hasliked":0,"parentid":"4c3yWH","parentname":"Pendulum Multi-Joint Test"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Use the mouse to control and swing each joint\n//(WIP)\n\n/* After days of trial and error, I finally got the multi-joint pendulum to reach vertical stability, \n   with each segment able to stand on its unstable equilibrium\n   accountign for the precision errors with dampening.\n   \n   There are still some bugs such as bing able to grab multiple joints and the  grab radius being off a bit \n   As well as the abitity to grab multiple joints at the same time by sliding the mouse over the joing \n   while the button is being held down. \n   \n   . . . As well as the physics of how the links intereact with eachother\n*/\n\nbool isOnLineSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float d = dot(ab, ap) / dot(ab, ab);\n    return d >= 0.0 && d <= 1.0;\n}\n\nvec2 calculateJointPos(vec2 prevJoint, float angle, float length) {\n    return prevJoint + vec2(length * sin(angle), -length * cos(angle));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 center = vec2(0.0, 0.58);\n    vec2 mousePos = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    \n    // Pendulum parameters\n    float pendulumLength1 = 0.5;\n    float pendulumLength2 = 0.5;\n    float pendulumLength3 = 0.5;\n    \n    // Get states from Buffer A\n    vec4 state1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 state2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 state3 = texelFetch(iChannel0, ivec2(2, 0), 0);\n    \n    // Calculate joint positions\n    float verticalOffset = 0.1;\n    vec2 joint1 = center + vec2(0.0, verticalOffset);\n    vec2 joint2 = calculateJointPos(joint1, state1.x, pendulumLength1);\n    vec2 joint3 = calculateJointPos(joint2, state2.x, pendulumLength2);\n    vec2 joint4 = calculateJointPos(joint3, state3.x, pendulumLength3);\n    \n    // Start with black background\n    vec3 color = vec3(0.0);\n    \n    // Drawing parameters\n    float radius = 0.02;\n    float lineThickness = 0.01;\n    vec3 lineColor = vec3(0.8, 0.1, 0.1);\n    vec3 draggedColor = vec3(1.0, 0.5, 0.0); // Orange for dragged joints\n    \n    // Draw lines between joints\n    vec2[4] points = vec2[4](joint1, joint2, joint3, joint4);\n    for(int i = 0; i < 3; i++) {\n        vec2 start = points[i];\n        vec2 end = points[i + 1];\n        float dist = abs((uv - start).y * (end - start).x - (uv - start).x * (end - start).y) / length(end - start);\n        if (dist < lineThickness && isOnLineSegment(uv, start, end)) {\n            color = lineColor;\n        }\n    }\n    \n    // Draw joints with different colors and highlight if being dragged\n    vec3[4] jointColors = vec3[4](\n        vec3(0.1, 0.1, 0.8),  // Blue for joint 1\n        vec3(0.1, 0.8, 0.1),  // Green for joint 2\n        vec3(0.8, 0.8, 0.1),  // Yellow for joint 3\n        vec3(0.8, 0.1, 0.8)   // Purple for joint 4\n    );\n    \n    // Draw interactive radius around joints when mouse is near\n    float grabRadius = 0.05;\n    if (iMouse.z > 0.0) {\n        for(int i = 1; i < 4; i++) {\n            float mouseJointDist = length(mousePos - points[i]);\n            if (mouseJointDist < grabRadius) {\n                float glowIntensity = 1.0 - mouseJointDist / grabRadius;\n                float glowRadius = radius * 2.0;\n                float dist = length(uv - points[i]);\n                if (dist < glowRadius) {\n                    float glow = smoothstep(glowRadius, radius, dist);\n                    color = mix(color, vec3(1.0), glow * glowIntensity * 0.5);\n                }\n            }\n        }\n    }\n    \n    // Draw joints\n    for(int i = 0; i < 4; i++) {\n        float dist = length(uv - points[i]);\n        if (dist < radius) {\n            // Check if joint is being dragged\n            bool isDragged = false;\n            if (i == 1) isDragged = state1.z > 0.5;\n            else if (i == 2) isDragged = state2.z > 0.5;\n            else if (i == 3) isDragged = state3.z > 0.5;\n            \n            color = isDragged ? draggedColor : jointColors[i];\n        }\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Function to calculate angle between two points\nfloat calculateTargetAngle(vec2 from, vec2 to) {\n    vec2 diff = to - from;\n    return atan(diff.x, -diff.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 pixel = ivec2(fragCoord);\n    \n    if (pixel.y >= 1 || pixel.x >= 3) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec4 state1 = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 state2 = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 state3 = texelFetch(iChannel0, ivec2(2, 0), 0);\n    \n    vec2 center = vec2(0.0, 0.58);\n    float pendulumLength = 0.5;\n    float g = 9.81;\n    float dampening = 0.995;\n    float dt = 0.016;\n    float grabRadius = 0.05;\n    \n    if (iFrame == 0) {\n        state1 = vec4(0.1, 0.0, 0.0, 0.0);\n        state2 = vec4(0.0, 0.0, 0.0, 0.0);\n        state3 = vec4(-0.1, 0.0, 0.0, 0.0);\n    }\n    \n    vec2 mouse = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    bool isMouseHeld = iMouse.z > 0.0;\n    \n    float verticalOffset = 0.1;\n    vec2 basePos = center + vec2(0.0, verticalOffset);\n    vec2 joint1Pos = basePos + vec2(pendulumLength * sin(state1.x), -pendulumLength * cos(state1.x));\n    vec2 joint2Pos = joint1Pos + vec2(pendulumLength * sin(state2.x), -pendulumLength * cos(state2.x));\n    vec2 joint3Pos = joint2Pos + vec2(pendulumLength * sin(state3.x), -pendulumLength * cos(state3.x));\n    \n    if (pixel.x == 0) {\n        float angle = state1.x;\n        float angularVelocity = state1.y;\n        float wasMouseHeld = state1.z;\n        float mouseDist = length(mouse - joint1Pos);\n        \n        if (isMouseHeld && (mouseDist < grabRadius || wasMouseHeld > 0.5)) {\n            float targetAngle = calculateTargetAngle(basePos, mouse);\n            \n            if (wasMouseHeld > 0.5) {\n                float angleDiff = targetAngle - angle;\n                angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n                angularVelocity = angleDiff / dt;\n            } else {\n                angularVelocity = 0.0;\n            }\n            angle = targetAngle;\n        } else {\n            float angularAccel = -(g/pendulumLength) * sin(angle);\n            angularVelocity += angularAccel * dt;\n            angularVelocity *= dampening;\n            angle += angularVelocity * dt;\n        }\n        \n        fragColor = vec4(angle, angularVelocity, \n                        isMouseHeld && (mouseDist < grabRadius || wasMouseHeld > 0.5) ? 1.0 : 0.0, 0.0);\n    }\n    else if (pixel.x == 1) {\n        float angle = state2.x;\n        float angularVelocity = state2.y;\n        float wasMouseHeld = state2.z;\n        float mouseDist = length(mouse - joint2Pos);\n        \n        if (isMouseHeld && (mouseDist < grabRadius || wasMouseHeld > 0.5) && state1.z < 0.5) {\n            float targetAngle = calculateTargetAngle(joint1Pos, mouse);\n            \n            if (wasMouseHeld > 0.5) {\n                float angleDiff = targetAngle - angle;\n                angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n                angularVelocity = angleDiff / dt;\n            } else {\n                angularVelocity = 0.0;\n            }\n            angle = targetAngle;\n        } else {\n            float angularAccel = -(g/pendulumLength) * sin(angle);\n            angularVelocity += angularAccel * dt;\n            angularVelocity *= dampening;\n            angle += angularVelocity * dt;\n        }\n        \n        fragColor = vec4(angle, angularVelocity, \n                        isMouseHeld && (mouseDist < grabRadius || wasMouseHeld > 0.5) && state1.z < 0.5 ? 1.0 : 0.0, 0.0);\n    }\n    else if (pixel.x == 2) {\n        float angle = state3.x;\n        float angularVelocity = state3.y;\n        float wasMouseHeld = state3.z;\n        float mouseDist = length(mouse - joint3Pos);\n        \n        if (isMouseHeld && (mouseDist < grabRadius || wasMouseHeld > 0.5) && state1.z < 0.5 && state2.z < 0.5) {\n            float targetAngle = calculateTargetAngle(joint2Pos, mouse);\n            \n            if (wasMouseHeld > 0.5) {\n                float angleDiff = targetAngle - angle;\n                angleDiff = mod(angleDiff + 3.14159, 6.28318) - 3.14159;\n                angularVelocity = angleDiff / dt;\n            } else {\n                angularVelocity = 0.0;\n            }\n            angle = targetAngle;\n        } else {\n            float angularAccel = -(g/pendulumLength) * sin(angle);\n            angularVelocity += angularAccel * dt;\n            angularVelocity *= dampening;\n            angle += angularVelocity * dt;\n        }\n        \n        fragColor = vec4(angle, angularVelocity, \n                        isMouseHeld && (mouseDist < grabRadius || wasMouseHeld > 0.5) && state1.z < 0.5 && state2.z < 0.5 ? 1.0 : 0.0, 0.0);\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}