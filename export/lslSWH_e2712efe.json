{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//#define SUPERSAMP\n\nstruct quaternion\n{\n\tvec4 d;\n};\n\n\nquaternion qtimes(in quaternion a, in quaternion b){\n    float y0 = dot(a.d.xyzw, b.d.xyzw * vec4(1., -1., -1., -1.));\n    float y1 = dot(a.d.xyzw, b.d.yxwz * vec4(1.,  1.,  1., -1.));\n    float y2 = dot(a.d.xyzw, b.d.zwxy * vec4(1., -1.,  1.,  1.));\n    float y3 = dot(a.d.xyzw, b.d.wzyx * vec4(1.,  1., -1.,  1.));\n\n    quaternion q;\n    q.d = vec4(y0, y1, y2, y3);\n\n    return q;\n}\n\nquaternion qtimes(in float f, in quaternion a){\n\tquaternion q;\n\tq.d = vec4(f) * a.d;\n\treturn q;\n}\n\nquaternion qplus(in quaternion a, in quaternion b){\n\tquaternion q;\n\tq.d = a.d + b.d;\n\n\treturn q;\n}\n\nfloat qabsq(in quaternion q){\n\treturn dot(q.d, q.d);\n}\n\nfloat calcDistance(quaternion z, quaternion c){\n\tquaternion dz;\n\tdz.d = vec4(1., 0., 0., 0.);\n\n\tfloat m2 = 0.;\n\tfloat keep_going = 1.;\n\n\n\tfor(float i = 0.; i < 12.; i++){\n\t\tif(keep_going > 0.){\n\t\t\tdz = qtimes(2., qtimes(dz,z));\n\t\t\tz = qplus(qtimes(z,z), c);\n\t\t\tm2 = qabsq(z);\n\t\t\tif(m2 > 100.){\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sqrt(m2/qabsq(dz)) * 0.5 * log(sqrt(m2));\n}\n\nfloat calcDistance_atDelta(in vec3 surf_center, in quaternion c, in vec3 delta){\n\tvec3 z_pos = surf_center + delta;\n\tquaternion z;\n\tz.d = vec4(z_pos.x, z_pos.y, z_pos.z, 0.);\n\n\treturn calcDistance(z, c);\n}\n\nvec3 make_abs(in vec3 v){\n\treturn vec3(abs(v.x), abs(v.y), abs(v.z));\n}\n\nfloat cam_slow = 25.;\nvec4 do_everything(in vec3 e,\n\t\t\t\t   in vec3 w,\n\t\t\t\t   in vec3 u,\n\t\t\t\t   in vec3 v,\n\t\t\t\t   in quaternion c,\n\t\t\t\t   in float l,\n\t\t\t\t   in float r,\n\t\t\t\t   in float t,\n\t\t\t\t   in float b,\n\t\t\t\t   in float d,\n\t\t\t\t   in float dx,\n\t\t\t\t   in float dy,\n                  in vec2 fragCoord){\n\tfloat rad = 2.;\n\tfloat U = l + (r - l) * (fragCoord.x + dx) / (iResolution.x);\n\tfloat V = b + (t - b) * (fragCoord.y + dy) / (iResolution.y);\n\n\tvec3 ray_dir = normalize(w*vec3(-d) + u * vec3(U) + v * vec3(V));\n\tvec3 ray_e = e;\n\tfloat MAX_DIST = 2. * length(e);\n\n\n\tquaternion z0;\n\tz0.d = vec4(ray_e, 0.);\n\n\tfloat init_dist = calcDistance(z0, c);\n\n\tfloat dist = init_dist;\n\n\tconst float max_iters = 64.;\n\tfloat marched_iters = 0.;\n\tfloat keep_going = 1.;\n\n\tconst float alpha = 0.0001;\n\tconst float clarity = 0.;\n\n\tfor(float iters = 0.; iters < max_iters; iters++){\n\t\tif(keep_going > 0.){\n\t\t\tvec3 z2_pos = ray_e + ray_dir * vec3(dist);\n\n\t\t\tquaternion z2;\n\t\t\tz2.d = vec4(z2_pos, 0.);\n\n\t\t\tfloat newdist = calcDistance(z2, c);\n\t\t\tif(abs(dist) > MAX_DIST || abs(newdist) > MAX_DIST || (keep_going > 0. && dist == 0.)){\n\t\t\t\tdist = 0.;\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tif(newdist < alpha * pow(dist, clarity)){\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tdist += newdist * keep_going;\n\t\t\tmarched_iters = marched_iters + keep_going;\n\t\t}\n\t}\n\n\tif(dist == 0.){\n\t\treturn vec4(0.);\n\t} else {\n\t\tfloat AO_VEC = max(1. - marched_iters / max_iters, .05);\n\t\tvec3 grad_center = ray_e + ray_dir * vec3(dist);\n\t\t//float grad_delta = 0.0001;\n\t\tfloat grad_delta = alpha * pow(dist, clarity);\n\t\t// calculate gradiant!\n\t\tfloat dist_left  = calcDistance_atDelta(grad_center, c, vec3(grad_delta) * u);\n\t\tfloat dist_right = calcDistance_atDelta(grad_center, c, vec3(-grad_delta) * u);\n\t\tfloat dist_up    = calcDistance_atDelta(grad_center, c, vec3(-grad_delta) * v);\n\t\tfloat dist_down  = calcDistance_atDelta(grad_center, c, vec3(grad_delta) * v);\n\t\tfloat dist_for    = calcDistance_atDelta(grad_center, c, vec3(-grad_delta) * ray_dir);\n\t\tfloat dist_bak  = calcDistance_atDelta(grad_center, c, vec3(grad_delta) * ray_dir);\n\t\tvec3 GRAD_VEC = normalize(make_abs(vec3((dist_left - dist_right) / (2. * grad_delta),\n\t\t\t                                    (dist_up   - dist_down)  / (2. * grad_delta),\n\t\t\t                                    (dist_for  - dist_bak)   / (2. * grad_delta))));\n\t\t\n\t\t// done with gradiant\n\n\n\t\tvec3 light_pos = vec3(rad * sin(iTime / cam_slow), rad * cos(iTime / cam_slow), rad);\n\t\t\n\t\tvec3 ray_light_e = ray_e + ray_dir * vec3(dist * .99);\n\t\tvec3 ray_light_dir = normalize(light_pos - ray_light_e);\n\t\t\n\t\tfloat dist_to_light = abs(distance(light_pos, ray_light_e));\n\n\t\tkeep_going = 1.;\n\t\tmarched_iters = 0.;\n\t\tdist = 0.;\n\t\tconst float max_iters_l = max_iters;\n\t\tfor(float iters = 0.; iters < max_iters_l; iters++){\n\t\t\tvec3 z2_pos = ray_light_e + ray_light_dir * vec3(dist);\n\n\t\t\tquaternion z2;\n\t\t\tz2.d = vec4(z2_pos.x, z2_pos.y, z2_pos.z, 0.);\n\n\t\t\tfloat newdist = calcDistance(z2, c);\n\t\t\tif(abs(dist) > MAX_DIST || abs(newdist) > MAX_DIST || (keep_going == 0. && dist == 0.)){\n\t\t\t\tdist = 0.;\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tif(newdist < alpha * pow(dist, clarity)){\n\t\t\t\tkeep_going = 0.;\n\t\t\t}\n\n\t\t\tdist += newdist * keep_going;\n\t\t\tmarched_iters = marched_iters + keep_going;\n\t\t}\n\n\t\tfloat LIGHT_VEC = 1.;\n\t\tif(dist == 0. || dist > dist_to_light){\n\t\t\tLIGHT_VEC = 1.;\n\t\t} else {\n\t\t\tLIGHT_VEC = .5;\n\t\t}\n\n\t\tvec3 COL_VEC = LIGHT_VEC * AO_VEC * GRAD_VEC;\n\t\treturn vec4(COL_VEC, 1.);\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat bandIntensity0 = texture(iChannel0, vec2(0.25, 0.15)).x;\n\tfloat bandIntensity1 = texture(iChannel0, vec2(0.35, 0.0)).x;\n\tfloat bandIntensity2 = texture(iChannel0, vec2(0.65, 0.45)).x;\n\tfloat bandIntensity3 = texture(iChannel0, vec2(0.15, 0.0)).x;\n\n\t// ray generation\n\tfloat rad = 2.;\n\tfloat e_x = rad * sin(iTime / cam_slow);\n\tfloat e_y = rad * cos(iTime / cam_slow);\n\tfloat e_z = 0.;\n\n\t#ifdef SUPERSAMP\n\tfloat SS = 2.;\n\t#else\n\tfloat SS = 1.;\n\t#endif\n\t\n\tfloat l = -iResolution.x * SS;\n\tfloat r =  iResolution.x * SS;\n\tfloat t =  iResolution.y * SS;\n\tfloat b = -iResolution.y * SS;\n\tfloat d =  iResolution.y * SS;\n\n\tvec3 e = vec3(e_x, e_y, e_z);\n\tvec3 lookpoint = vec3(0.,0.,0.);\n\tvec3 upnorm = vec3(0.,0.,1.);\n\n\n\tvec3 lookdir = lookpoint - e;\n\n\tvec4 TOTAL_COLOR = vec4(0.);\n\n\tvec3 w = normalize(lookdir) * vec3(-1., -1., -1.);\n\tvec3 u = normalize(cross(upnorm, w));\n\tvec3 v = normalize(cross(w, u));\n\n\tquaternion c;\n\tc.d.x = (iMouse.x > 0. ? iMouse.x / iResolution.x * 2. - 1. : -1.0);\n\tc.d.z = (iMouse.x > 0. ? iMouse.y / iResolution.y * 2. - 1. :  0.0);\n\tc.d.y = bandIntensity2/1.5;\n\tc.d.w = bandIntensity3/1.5;\n\t\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 0., 0., fragCoord);\n\t#ifdef SUPERSAMP\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 1./SS, 0., fragCoord);\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 1./SS, 1./SS, fragCoord);\n\tTOTAL_COLOR += do_everything(e, w, u, v, c, l, r, t, b, d, 0., 1./SS, fragCoord);\n\t#endif\n\n\tfragColor = TOTAL_COLOR / vec4(SS*SS);\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"lslSWH","date":"1400430093","viewed":692,"name":"Dancing Quaternion Julia Set","username":"ariagolliver","description":"click and drag mouse to change two components of the system.\nthe other two components are modulated by iChannel0","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["julia","ray","raymarch","quaternion","equalizer","march"],"hasliked":0,"parentid":"","parentname":""}}