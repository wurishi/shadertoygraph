{"ver":"0.1","info":{"id":"Mcj3Dw","date":"1704309671","viewed":79,"name":"Ατέρμονη Ροή Πληροφορίας","username":"GraphXDoses","description":"GR: Ατέρμονη Ροή Πληροφορίας\nEN: Endless Information Stream","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["procedural","tunnel","endless"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Heavily influenced by several Shane's stunning shaders, i created this\n// to be the first shader of the year. Also took inspiration from the\n// leaflet of a MSc program at my university called \"Law and Informatics\".\n//\n// Leaflet         : https://www.uom.gr/14911-prokhryksh-eisagoghs-h-kykloy-dpms-dikaio-plhroforikh-paratash-eos-16-ianoyarioy-2024\n// Shane's Profile : https://www.shadertoy.com/user/Shane\n\n\n#define PI  3.14159265\n#define FAR 112.\n#define CSZ 96 \n\n#define rot2(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat march_d;\nvec3  Nvec;\n\nvec2 path(in float z)\n{\n    float a = sin(z * .05), b = cos(z * .02);\n    return vec2(a*4. -b*1.5, b*1.7 + a*1.5);\n}\n\nfloat tunnelMap(vec3 p)\n{    \n     // Offset the tunnel about the XY plane as we traverse Z.\n     p.xy -= path(p.z);\n    \n     // Standard tunnel.\n     float n = 4. - length(p.xy);\n     return n;\n}\n\n// Ray Marching macro. Intended to support multiple \"map\" functions.\n#define march(ro, rd, fnc) \\\n{ float t = 0., h; for(int i = 0; i < 64; i++){ h = fnc(ro+rd*t); \\\nif(abs(h)<0.001*(t*.125 + 1.) || t>FAR) break; t += h*.8; } \\\nmarch_d = min(t, FAR); }\n\n// Surface normal calculating macro. Intended to support multiple \"map\" functions.\n#define calcNvec(p, fnc) \\\n{ vec2 e = vec2(0.0025, -0.0025); Nvec = normalize(e.xyy * fnc(p + e.xyy) + \\\ne.yyx * fnc(p + e.yyx) + e.yxy * fnc(p + e.yxy) + e.xxx * fnc(p + e.xxx)); }\n\n// SDF function of a '0' glyph.\nfloat sdZero(vec2 p)\n{\n    return abs(length(max(p=abs(p)-vec2(.15,.05),0.0)) +\n    min(max(p.x,p.y),0.0)-.15)-.05;\n}\n\n// SDF function of a '1' glyph.\nfloat sdOne(vec2 q)\n{\n    float d = abs(dot(q, vec2(0,1)))-.05;\n    d = min(d, max((abs(dot(q-vec2(.25,0), vec2(1,0)))-.1), abs(dot(q-vec2(-.1,.5), vec2(1)))-.05));\n    return max(d, (abs(dot(q, vec2(1,0)))-.35));\n}\n\n#define ss(v) smoothstep(1e-3*sf, -1e-3*sf, v)\n///////////////////////////////////////////////\n// Created by James_Harnett\n// https://www.shadertoy.com/view/MdcfDj\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n\nfloat hash( uvec2 q )\n{\n    q *= uvec2(M1, M2); \n    \n    uint n = (q.x ^ q.y) * M1;\n    \n    return float(n) * (1./float(0xffffffffU));\n}\n///////////////////////////////////////////////\n\n#define XOR(a,b) mix(a, step(.5, 1.-a), b)\n\nvec3 binMap(vec2 p)\n{\n    // Divide tubeUV (aka p, here) to cells. Make sure we get some id reference.\n    vec2  q  = fract(p*vec2(-CSZ,CSZ))-.5;\n    ivec2 id = ivec2(floor(p*vec2(CSZ)));\n    \n    // flipBit tries to emulate an XOR operation taking place. Travels opposite to camera.\n    float flipBit   = 1.-step(20., float(id+ivec2(CSZ))*hash(uvec2(id+ivec2(3, iTime*10.)))),\n          bitState  = step(.5, hash(uvec2(id))), // Standard random bit in a cell.\n          cellShade = -(abs(dot(q, vec2(1,0)))-.47),\n          glyph     = mix(sdZero(q), sdOne(q), XOR(bitState, flipBit)), // Get the glyph right, based on bitState.\n          sf        = mix(0., 250., clamp(march_d/FAR, 0., 1.)); // Smooth factor for glyphs.\n    \n    vec3  outColor = mix(vec3(0,.25,.2), vec3(0,1.5,1.125), flipBit)*cellShade*ss(glyph); // Apply colors.\n\n    //return(outColor); // Without inter-row contour line separator.\n    return(mix(outColor, vec3(0,.0625,.05), ss(cellShade)));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = (U - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 camPos = vec3(0, .5, iTime*4.);     // Camera position, doubling as the ray origin.\n\tvec3 lookAt = camPos + vec3(0, 0, .25);  // \"Look At\" position.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.5; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*U.x*right + FOV*U.y*up);\n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/8. )*rd.xy;\n    \n    // Standard ray marching routine.\n    march(camPos, rd, tunnelMap)\n    float t = march_d;\n\t\n    // The final scene color.\n\tvec3 sceneCol = vec3(0,1,.75);\n    \n    if(t < FAR)\n    {\n    \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n        calcNvec(sp, tunnelMap)\n        \n        // Calculate uv space inside the tube.\n        vec2 tubeUV = vec2(atan(-Nvec.y, Nvec.x)/(PI*2.) + .5, sp.z/30.);\n        \n        // Apply mist and colors.\n        sceneCol = mix(sceneCol, binMap(tubeUV), 1.05-t/FAR);\n        \n    }\n    \n    O = vec4(sceneCol,1);\n}","name":"Image","description":"","type":"image"}]}