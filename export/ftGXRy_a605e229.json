{"ver":"0.1","info":{"id":"ftGXRy","date":"1640874834","viewed":100,"name":"Global Illumination Ray-tracing","username":"Pro_Coder","description":"This Ray-tracer was developed for a paper about global Illumination in real-time ray-tracing.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raytracing","gi","globalillumination"],"hasliked":0,"parentid":"sss3WN","parentname":"Ray Marching walk around"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//defines the GI ray amount. Set to 4, 8, 12, 16, 20, 24, 28, 32\n//This also increases compile time greatly! 32 took me 82.5 seconds to compile\n#define AMOUNT_W 8\n#define AMOUNT_H 2\n#define MAX_INDEX (AMOUNT_W*AMOUNT_H)\n\n\n\n#define SHOW_FPS\n//#define EXTRA_BOXES\n//#define SHOW_NORMALS\n#define RENDER_DISTANCE 40.\n#define MAX_STEPS 1000\n#define MIN_DISTANCE 0.00001\n\n//Objects\n#define NO_HIT_MATERIAL Material(vec3(0.0, 0.0, 1.0), 0.0, 0.0, false, 0.0)\n#define NO_HIT_ID 0\n#define UNKNOWN_ID -1\n\n#define SPHERE_LIGHT Sphere(vec3(0.0, 4., 0.0), 0.0)\n#define BOX_2        Box(vec3(1.0, -3.5, -2.), vec3(2., 2., 2.))\n\n#define GROUND Box(vec3(0.0, 5.0, 0.0), vec3(10., 1., 10.))\n#define GREY_WALL Box(vec3(0., 0., 5.), vec3(10., 10., 1.))\n#define RED_WALL Box(vec3(5., 0., 0.), vec3(1., 10., 10.))\n#define GREEN_WALL Box(vec3(-5., 0., 0.), vec3(1., 10., 10.))\n\n\n#define SPHERE_LIGHT_MATERIAL Material(vec3(1.0),           0.0, 0.0, true, 1.0)\n#define BOX_2_MATERIAL        Material(vec3(0.0, 0.0, 1.0), 0.0, 0.0, false, 0.0)\n#define GROUND_MATERIAL       Material(vec3(.5), 0.0, 0.0, false, 0.0)\n#define RED_WALL_MATERIAL     Material(vec3(1., 0., 0.), 0.0, 0.0, false, 0.0)\n#define GREEN_WALL_MATERIAL   Material(vec3(0., 1., 0.), 0.0, 0.0, false, 0.0)\n\nstruct Sphere\n{\n    vec3 position;\n    float radius;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n};\n\nstruct Material\n{\n    vec3 color;\n    float reflectiveness;\n    float roughness;\n    bool lightSource;\n    float light;\n};\n\n//world information and current frame information\nstruct World\n{\n    vec4 camPosition; // cam pos (xyz) and distanceToScreen (w)\n    vec3 viewDirection;\n    vec3 rayDirection;\n} world;\n\nconst Material materials[] = Material[12](\n                              NO_HIT_MATERIAL,      //0\n                              Material(vec3(0.7, 0.1, 0.66), 0.0, 0.0, false, 0.0),      //1\n                              SPHERE_LIGHT_MATERIAL,//2\n                              Material(vec3(250./255., 179./255., 27./255.), 0.0, 0.0, false, 0.0),      //3\n                              GROUND_MATERIAL ,     //4\n                              GROUND_MATERIAL,      //5\n                              GROUND_MATERIAL,      //6\n                              BOX_2_MATERIAL,       //7\n                              GROUND_MATERIAL,      //8\n                              GROUND_MATERIAL,      //9\n                              RED_WALL_MATERIAL,    //10\n                              GREEN_WALL_MATERIAL   //11\n                            );\n\nmat3 rotAroundYAxis(float angle){\n   return mat3( cos(angle) , 0.,  sin(angle),\n                0.         , 1.,  0.        ,\n                -sin(angle), 0.,  cos(angle)); \n}\n\nmat3 rotAroundZAxis(float angle){\n   return mat3( cos(angle) , -sin(angle), 0,\n                sin(angle) , cos(angle) , 0.,\n                0.         , 0.         , 1.); \n}\n\n\n// normal - normal vector of surface, must be normalized\n// index - between 0 and MAX_INDEX\n//\n// returns new ray direction\nvec3 getNextGIRayDirection(vec3 normal, int index){\n    mat3 rotateBack;\n    \n    if(abs(normal.y) < 0.99){\n        float angleBetweenXZ = acos(dot(normalize(normal.xz), vec2(1., 0.))) * sign(normal.z == 0.0 ? 1.0 : normal.z);\n        float angleBetweenXY = acos(dot(normal, vec3(0., 1., 0.))); //both must be normalized\n\n        //This matrix can transform the vector (0, 1, 0) into the given normal vector\n        //Note: this doesn't work if the normal vector already is (0, 1, 0)!\n        rotateBack =  rotAroundZAxis(-angleBetweenXY)*rotAroundYAxis(-angleBetweenXZ);\n    }\n    \n    vec3 n = vec3(0., 1., 0.);\n    \n    if(index != AMOUNT_H*AMOUNT_W){    \n        int indexH = index % AMOUNT_H;\n        float xy = float(indexH+1) * (PI / float(AMOUNT_H*2+1)) ;\n        float xz = float(index / AMOUNT_H) * ((PI*2.) / float(AMOUNT_W));\n        n *= rotAroundZAxis(xy);\n        n *= rotAroundYAxis(xz);\n    }\n    \n    //rotate back. If normal.y is 1, we do not need to rotate back. Sometimes we have precision issues\n    //so check against 0.99 instead\n    if(abs(normal.y) < 0.99) n*=rotateBack;\n    else n.y *= normal.y;\n    \n    return n;\n}\n                         \n\n//functions\nfloat vmax(vec3 a){\n    return max(a.z, max(a.x, a.y));\n}\n\n\nfloat sdfSphere(vec3 pos, Sphere s){\n    return length(pos - s.position) - s.radius;\n}\n\nfloat sdfBox(vec3 p, Box box){\n    p -= box.center;\n    vec3 d = abs(p) - box.size*.5;\n    float m = (vmax(d));\n    return max(length(min(sign(d) + vec3(1.), 1.) * d), abs(m)) * sign(m);\n}\n\n\n\nfloat rotTestSDF(vec3 p){\n    vec3 c = normalize(vec3(-0.01, 1., -0.001));\n    \n    float angleBetweenXZ = acos(dot(normalize(c.xz), vec2(1., 0.))) * sign(c.z == 0.0 ? 1.0 : c.z);\n    //angleBetweenXZ = atan(c.x, c.z);\n    float angleBetweenXY = acos(dot(c, vec3(0., 1., 0.))); //both must be normalized\n    \n    mat3 rot = rotAroundYAxis(angleBetweenXZ)* rotAroundZAxis(angleBetweenXY);\n    rot = rotAroundZAxis(-angleBetweenXY)*rotAroundYAxis(-angleBetweenXZ);\n    \n    vec3 n = vec3(0., 1., 0.);\n    \n    float xy = PI/8.;\n    n *= rotAroundZAxis(xy);\n    n *= rotAroundYAxis(sin(iTime)*PI);\n    if(abs(c.y) != 1.) n *= rot;\n    else n.y *= c.y;\n    \n    //n = getNextGIRayDirection(c, int(iTime*2.)%9);\n    \n    float dis = length(p - n) - .3;     \n    \n    return min(min(dis, length(p - vec3(0.)) - 0.1), length(p - c) - 0.2);\n}\n\n\nint getDistance(vec3 pos, out float dis){\n    dis = RENDER_DISTANCE * 2.;\n    float sphereLight = 100.;\n    float box2 = 100.;\n    float ground = 100.;\n    float greyWall = 100.;\n    float redWall = 100.;\n    float greenWall = 100.;\n    \n    #ifdef SPHERE_LIGHT\n        sphereLight = sdfSphere(pos, SPHERE_LIGHT);\n        dis = min(dis, sphereLight);\n    #endif\n    \n    #ifdef BOX_2\n        box2 = sdfBox(pos, BOX_2);\n        //box2 = min(box2, rotTest(pos));\n        dis = min(dis, box2);\n    #endif\n    \n    \n    #ifdef GROUND\n        //dublicate the Ground from the ceiling to the ground\n        ground = sdfBox(vec3(pos.x, abs(pos.y), pos.z), GROUND);\n        dis = min(dis, ground);\n    #endif\n    \n    #ifdef GREY_WALL\n        greyWall = sdfBox(vec3(pos.x, pos.y, abs(pos.z)), GREY_WALL);\n        dis = min(dis, greyWall);\n    #endif\n    \n    #ifdef RED_WALL\n        redWall = sdfBox(pos, RED_WALL);\n        dis = min(dis, redWall);\n    #endif\n    \n    #ifdef GREEN_WALL\n        greenWall = sdfBox(pos, GREEN_WALL);\n        dis = min(dis, greenWall);\n    #endif\n    \n    #ifdef EXTRA_BOXES\n    float b1 = sdfBox(pos - vec3(1.5, 3.5, 1.5), BOX_2);\n    dis = min(dis, b1);\n    \n    float b2 = sdfBox(pos - vec3(-2., 3., -1.), BOX_2);\n    dis = min(dis, b2);\n    #endif\n         \n    if(dis <= MIN_DISTANCE){\n        if(dis == sphereLight){\n            return 2;\n        }else if(dis == box2){\n            return 7;\n        }else if(dis == ground || dis == greyWall){\n            return 9;\n        }else if(dis == redWall){\n            return 10;\n        }else if(dis == greenWall){\n            return 11;\n        }\n        #ifdef EXTRA_BOXES\n        else if(dis == b1){\n            return 1;\n        }else if(dis == b2){\n            return 3;\n        }\n        #endif\n    }else if(dis > MIN_DISTANCE){\n        return NO_HIT_ID;\n    }\n\n    return UNKNOWN_ID;\n}\n\nfloat getDistance(vec3 pos){\n    float d;\n    getDistance(pos, d);\n    return d;\n}\n\nvec3 getNormal(vec3 p){\n \tfloat d = getDistance(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(getDistance(p - e.xyy), getDistance(p - e.yxy), getDistance(p - e.yyx));\n    return normalize(n);\n}\n\nint rayMarch(inout vec3 pos, vec3 rd, float fact, out float dis){\n    \n    int outId;\n    dis = MIN_DISTANCE*90.;\n    float cDis = RENDER_DISTANCE*2.;\n    \n    pos = pos + rd * dis;\n    \n    for(int i = 0; i < MAX_STEPS; i++){\n       outId = getDistance(pos, cDis);\n       cDis *= fact;\n       \n       \n       if(cDis <= MIN_DISTANCE){\n           return outId;\n           \n       }else if(dis > RENDER_DISTANCE){\n           return NO_HIT_ID;\n           \n       }\n       \n       dis += cDis;\n       pos = pos + rd * cDis;\n       \n    }\n    \n    return UNKNOWN_ID;\n}\n\n\n\nstruct State\n{\n    bool isSky;\n    vec3 newPos;\n    vec3 normal;\n    Material mat;\n    vec3 lightPos;\n    vec3 light;\n    float dis;\n    float lightDis;\n};\n\nState stateMarch(vec3 pos, inout vec3 rd){\n    vec3 p = pos;\n    float dis;\n    \n    //hit\n    int hitId = max(0, rayMarch(p, rd, 1., dis)); \n    Material mat = materials[hitId];\n    vec3 normal = getNormal(p);\n    \n    if(hitId == 0){\n        return State(true, p, vec3(0.), mat, vec3(0.), vec3(mat.light), dis, 0.0);\n    }\n           \n    //light\n    vec3 lightDirection = normalize(SPHERE_LIGHT.position - p);\n    vec3 posL = p;\n    float lightDis;\n    int hitIdL = (rayMarch(posL, lightDirection, 1., lightDis));\n    Material matL = materials[hitIdL];\n    vec3 light = vec3(matL.light);\n    \n    return State(false, p, normal, mat, posL, light, dis, lightDis); \n}\n\n\n#ifdef SHOW_FPS\n//-----------------------------------------------------------------\n// Digit drawing function by P_Malin (https://www.shadertoy.com/view/4sf3RN)\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\t\t\n\tif(vUV.x  < 0.0) return 0.0;\n\tif(vUV.y  < 0.0) return 0.0;\n\tif(vUV.x >= 1.0) return 0.0;\n\tif(vUV.y >= 1.0) return 0.0;\n\t\n\tfloat data = 0.0;\n\t\n\t     if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n\telse if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n\telse if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n\telse if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n\telse if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\telse if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n\t\n\tvec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n\tfloat fIndex = vPixel.x + (vPixel.y * 4.0);\n\t\n\treturn mod(floor(data / pow(2.0, fIndex)), 2.0);\n}\n\n\n//Int drawing function by iq (https://www.shadertoy.com/view/lsKGWV)\nfloat PrintInt(const in vec2 uv, const in float value )\n{\n\tfloat res = 0.0;\n\tfloat maxDigits = 1.0+ceil(log2(value)/log2(10.0));\n\tfloat digitID = floor(uv.x);\n\tif( digitID>0.0 && digitID<maxDigits )\n\t{\n        float digitVa = mod( floor( value/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n\t}\n\n\treturn res;\t\n}\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Screen coordinates from -1 to 1.\n    vec2 uv = (fragCoord - iResolution.xy*.5)*2. / iResolution.y;\n    //output color\n    vec3 col = vec3(0.0);\n    \n    #ifdef SHOW_FPS\n    col = vec3(PrintInt( (uv-vec2(0.9,0.9))*10.0, iFrameRate ));\n    if(col.r == 0.0){\n    #endif\n\n    world.camPosition = GET(iChannel1, CAM_POS_TEXEL);\n    world.viewDirection = GET(iChannel1, VIEW_DIR_TEXEL).xyz;\n    float distanceToScreen = world.camPosition.w;\n    \n    //Virtual Screen\n    float screenSizeFactor = 1.0 M; //The actual screen size depends on the uv\n    vec3 screenNormal = world.viewDirection; //The screen is always perpendicular to the viewDirection\n    vec3 screenTangent = normalize(WORLD_NORMAL + (dot(WORLD_NORMAL, screenNormal) * -screenNormal)); //vector in the direction of the height of the screen\n    vec3 screenBiTangent = normalize(cross(screenNormal, screenTangent)); //vector in direction of the width of the screen\n    \n    //World-position of the pixel\n    vec3 pixelPos = world.camPosition.xyz\n    + (world.viewDirection * distanceToScreen)\n    + (uv.y * screenTangent * screenSizeFactor)\n    + (uv.x * screenBiTangent * screenSizeFactor);\n    \n    vec3 rayDirection = normalize(pixelPos - world.camPosition.xyz);\n    world.rayDirection = rayDirection;\n    \n    \n    \n    \n    \n    //Ray Marching\n    State state = stateMarch(world.camPosition.xyz, rayDirection);\n    \n    col = state.mat.color;\n\n    //Global Illumination\n    vec3 rayDirectionGI;\n    State stateGI;\n    for(int i = 0; i < MAX_INDEX; i++){\n        rayDirectionGI = getNextGIRayDirection(state.normal, i);\n        stateGI = stateMarch(state.newPos, rayDirectionGI);\n        //col += stateGI.mat.color * min(0.1, 1./(stateGI.dis*10.));\n        col = mix(stateGI.mat.color, col, 1. - min((1./float(MAX_INDEX*2)), 1./(stateGI.dis*10.)));\n        //col = vec3(stateGI.dis *0.5);\n    }\n\n\n    col = col * max(0.5, state.light.r);  \n    \n    \n    #ifdef SHOW_NORMALS\n        col = abs(state.normal);\n    #endif\n    \n    #ifdef SHOW_FPS\n    }\n    #endif\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\n\n\n//example isKey(KEY_A, IS_PRESSED)\nbool isKey(float checkKey, float type){\n    return texture( iChannel0, vec2(checkKey, type)).r > 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,0.0,1.0);\n     \n    if(iFrame > 0) {\n        if(DO_SAVE(CAM_POS_TEXEL)){\n            vec4 pos = GET(iChannel1, CAM_POS_TEXEL);\n            vec4 vdir = GET(iChannel1, VIEW_DIR_TEXEL);\n            vec3 tdir = cross(WORLD_NORMAL, vdir.xyz);\n            float speed = MOVE_SPEAD;\n            \n            //move cam\n            if(isKey(KEY_W, IS_PRESSED)){//forward\n                pos.xyz += vdir.xyz * speed;\n            }\n            if(isKey(KEY_S, IS_PRESSED)){//backward\n                pos.xyz -= vdir.xyz * speed;\n            }\n            if(isKey(KEY_A, IS_PRESSED)){//left\n                pos.xyz += tdir * speed;\n            }\n            if(isKey(KEY_D, IS_PRESSED)){//right\n                pos.xyz -= tdir * speed;\n            }\n            if(isKey(KEY_SHIFT, IS_PRESSED)){\n                pos.y -= 1.0 * speed;\n            }\n            if(isKey(KEY_SPACE, IS_PRESSED)){\n                pos.y += 1.0 * speed;\n            }\n            \n            //Zoom\n            if(isKey(KEY_C, IS_PRESSED)){\n                pos.w *= 1.052631578947368;\n            }\n            if(isKey(KEY_X, IS_PRESSED)){\n                pos.w *= 0.95;\n            }\n            \n            fragColor = pos;\n            return;\n            \n        }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec4 viewDirection = GET(iChannel1, VIEW_DIR_TEXEL);\n            \n            if(iMouse.z > 0.0){\n                float angleXZ = atan(viewDirection.x, viewDirection.z);\n                angleXZ -= ((iMouse.x-iResolution.x*.5)/iResolution.x)*PI*0.05; \n                viewDirection.xyz = normalize(vec3(sin(angleXZ), viewDirection.y, cos(angleXZ)));\n            }\n            fragColor = viewDirection;\n            return;    \n        }\n         \n    }else{\n         //initial values\n         if(DO_SAVE(CAM_POS_TEXEL)){\n            fragColor = vec4(CAM_START_POS, CAM_DIS_TO_SCREEN);\n\n         }else if(DO_SAVE(VIEW_DIR_TEXEL)){\n            vec3 viewDirection = normalize(LOOK_AT_POSITION - CAM_START_POS);\n            fragColor = vec4(viewDirection, 1.0);\n\n         }    \n    }\n    \n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n#define PI 3.1415926\n\n//World stuff\n#define LOOK_AT_POSITION vec3(0.0, 1., 0.0)\n\n#define CAM_START_POS vec3(0., 1., 4.)\n#define CAM_DIS_TO_SCREEN 1.0\n#define WORLD_NORMAL vec3(0.0, 1.0, 0.0)\n#define M\n#define MOVE_SPEAD 0.1\n\n//Saving variables\n#define DO_SAVE(texel) (ivec2(fragCoord) == texel)\n#define GET(buffer, texel) (texelFetch(buffer, texel, 0))\n\n#define CAM_POS_TEXEL   ivec2(0, 0)\n#define VIEW_DIR_TEXEL  ivec2(0, 1)\n\n\n\n//Keyboard\n#define NUMBER_OF_KEYS 256.\n#define IS_PRESSED 0.0\n#define ON_PRESS 0.5\n#define BUFFFER_PRESS 1.0\n\n#define KEY_TAB 10./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ENTER 14./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SHIFT 17./NUMBER_OF_KEYS - 1./512.\n#define KEY_CTRL 18./NUMBER_OF_KEYS - 1./512.\n#define KEY_ALT 19./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SPACE 33./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_ARROW_LEFT 38./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_UP 39./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_RIGHT 40./NUMBER_OF_KEYS - 1./512.\n#define KEY_ARROW_DOWN 41./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_0 49./NUMBER_OF_KEYS - 1./512.\n#define KEY_1 50./NUMBER_OF_KEYS - 1./512.\n#define KEY_2 51./NUMBER_OF_KEYS - 1./512.\n#define KEY_3 52./NUMBER_OF_KEYS - 1./512.\n#define KEY_4 53./NUMBER_OF_KEYS - 1./512.\n#define KEY_5 54./NUMBER_OF_KEYS - 1./512.\n#define KEY_6 55./NUMBER_OF_KEYS - 1./512.\n#define KEY_7 56./NUMBER_OF_KEYS - 1./512.\n#define KEY_8 57./NUMBER_OF_KEYS - 1./512.\n#define KEY_9 58./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_NUMPAD_0 97./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_1 98./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_2 99./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_3 100./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_4 101./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_5 102./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_6 103./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_7 104./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_8 105./NUMBER_OF_KEYS - 1./512.\n#define KEY_NUMPAD_9 106./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_GREATER 61./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_SS 64./NUMBER_OF_KEYS - 1./512.\n\n#define KEY_A 66./NUMBER_OF_KEYS - 1./512.\n#define KEY_B 67./NUMBER_OF_KEYS - 1./512.\n#define KEY_C 68./NUMBER_OF_KEYS - 1./512.\n#define KEY_D 69./NUMBER_OF_KEYS - 1./512.\n#define KEY_E 70./NUMBER_OF_KEYS - 1./512.\n#define KEY_F 71./NUMBER_OF_KEYS - 1./512.\n#define KEY_G 72./NUMBER_OF_KEYS - 1./512.\n#define KEY_H 73./NUMBER_OF_KEYS - 1./512.\n#define KEY_I 74./NUMBER_OF_KEYS - 1./512.\n#define KEY_J 75./NUMBER_OF_KEYS - 1./512.\n#define KEY_K 76./NUMBER_OF_KEYS - 1./512.\n#define KEY_L 77./NUMBER_OF_KEYS - 1./512.\n#define KEY_M 78./NUMBER_OF_KEYS - 1./512.\n#define KEY_N 79./NUMBER_OF_KEYS - 1./512.\n#define KEY_O 80./NUMBER_OF_KEYS - 1./512.\n#define KEY_P 81./NUMBER_OF_KEYS - 1./512.\n#define KEY_Q 82./NUMBER_OF_KEYS - 1./512.\n#define KEY_R 83./NUMBER_OF_KEYS - 1./512.\n#define KEY_S 84./NUMBER_OF_KEYS - 1./512.\n#define KEY_T 85./NUMBER_OF_KEYS - 1./512.\n#define KEY_U 86./NUMBER_OF_KEYS - 1./512.\n#define KEY_V 87./NUMBER_OF_KEYS - 1./512.\n#define KEY_W 88./NUMBER_OF_KEYS - 1./512.\n#define KEY_X 89./NUMBER_OF_KEYS - 1./512.\n#define KEY_Y 90./NUMBER_OF_KEYS - 1./512.\n#define KEY_Z 91./NUMBER_OF_KEYS - 1./512.\n","name":"Common","description":"","type":"common"}]}