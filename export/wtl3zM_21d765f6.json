{"ver":"0.1","info":{"id":"wtl3zM","date":"1556641645","viewed":424,"name":"190501_noodle","username":"omeometo","description":"test","likes":19,"published":1,"flags":1,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 rand3(vec3 p){\n    vec3 q=vec3(\n        p.x*41.839+p.y*91.793+p.z*23.418,\n        p.x*54.941+p.y*73.694+p.z*48.932,\n        p.x*14.023+p.y*10.089+p.z*83.573\n    );\n\treturn fract(sin(q+0.25)*2434.2434)*2.0-1.0;\n}\n\nvec3 smth3(vec3 f){\n\treturn f*f*f*(10.+f*(-15.+f*6.));\n}\nvec3 dsmth3(vec3 f){\n\treturn 30.*(f*f*(1.+f*(-2.+f)));\n}\n/*\nfloat noise(vec3 p){\n\tvec3 i=floor(p);\n    vec3 f=fract(p);\n    vec3 u=smth3(f);\n    vec3 du=dsmth3(f);\n    \n    vec3 g000=rand3(i+vec3(0.0, 0.0, 0.0));\n    vec3 g001=rand3(i+vec3(0.0, 0.0, 1.0));\n    vec3 g010=rand3(i+vec3(0.0, 1.0, 0.0));\n    vec3 g011=rand3(i+vec3(0.0, 1.0, 1.0));\n    vec3 g100=rand3(i+vec3(1.0, 0.0, 0.0));\n    vec3 g101=rand3(i+vec3(1.0, 0.0, 1.0));\n    vec3 g110=rand3(i+vec3(1.0, 1.0, 0.0));\n    vec3 g111=rand3(i+vec3(1.0, 1.0, 1.0));\n    float a000=dot(g000, f-vec3(0.0, 0.0, 0.0));\n    float a001=dot(g001, f-vec3(0.0, 0.0, 1.0));\n    float a010=dot(g010, f-vec3(0.0, 1.0, 0.0));\n    float a011=dot(g011, f-vec3(0.0, 1.0, 1.0));\n    float a100=dot(g100, f-vec3(1.0, 0.0, 0.0));\n    float a101=dot(g101, f-vec3(1.0, 0.0, 1.0));\n    float a110=dot(g110, f-vec3(1.0, 1.0, 0.0));\n    float a111=dot(g111, f-vec3(1.0, 1.0, 1.0));\n   \n    return mix(\n        mix(mix(a000, a001, u.z), mix(a010, a011, u.z), u.y), \n        mix(mix(a100, a101, u.z), mix(a110, a111, u.z), u.y), u.x); \n}\n*/\n\nvoid noisewithgrad3(out float val, out vec3 grad, in vec3 p){\n\tvec3 i=floor(p);\n    vec3 f=fract(p);\n    vec3 u=smth3(f);\n    vec3 du=dsmth3(f);\n    \n    vec3 g000=rand3(i+vec3(0.0, 0.0, 0.0));\n    vec3 g001=rand3(i+vec3(0.0, 0.0, 1.0));\n    vec3 g010=rand3(i+vec3(0.0, 1.0, 0.0));\n    vec3 g011=rand3(i+vec3(0.0, 1.0, 1.0));\n    vec3 g100=rand3(i+vec3(1.0, 0.0, 0.0));\n    vec3 g101=rand3(i+vec3(1.0, 0.0, 1.0));\n    vec3 g110=rand3(i+vec3(1.0, 1.0, 0.0));\n    vec3 g111=rand3(i+vec3(1.0, 1.0, 1.0));\n    float a000=dot(g000, f-vec3(0.0, 0.0, 0.0));\n    float a001=dot(g001, f-vec3(0.0, 0.0, 1.0));\n    float a010=dot(g010, f-vec3(0.0, 1.0, 0.0));\n    float a011=dot(g011, f-vec3(0.0, 1.0, 1.0));\n    float a100=dot(g100, f-vec3(1.0, 0.0, 0.0));\n    float a101=dot(g101, f-vec3(1.0, 0.0, 1.0));\n    float a110=dot(g110, f-vec3(1.0, 1.0, 0.0));\n    float a111=dot(g111, f-vec3(1.0, 1.0, 1.0));\n   \n    val = mix(\n        mix(mix(a000, a001, u.z), mix(a010, a011, u.z), u.y), \n        mix(mix(a100, a101, u.z), mix(a110, a111, u.z), u.y), u.x); \n    grad = mix(\n        mix(mix(g000, g001, u.z), mix(g010, g011, u.z), u.y), \n        mix(mix(g100, g101, u.z), mix(g110, g111, u.z), u.y), u.x); \n    grad += du * vec3(\n    \tmix(mix(a100-a000, a101-a001, u.z), mix(a110-a010, a111-a011, u.z), u.y),\n    \tmix(mix(a010-a000, a011-a001, u.z), mix(a110-a100, a111-a101, u.z), u.x),\n    \tmix(mix(a001-a000, a011-a010, u.y), mix(a101-a100, a111-a110, u.y), u.x)\n    );\n}\n\n\nfloat dist(out vec3 grad, in vec3 p){\n\t//float val1=sqrt(dot(p,p))-1.0;\n    //vec3 g1=normalize(p);\n    float val1, val2;\n    vec3 g1, g2;\n    float r=2.0;\n    noisewithgrad3(val1, g1, p*r+iTime*vec3(0.0, 1.0, 0.0));\n    noisewithgrad3(val2, g2, p*r-iTime*vec3(0.0, 1.0, 0.0)-0.5);\n    g1*=r;\n    g2*=r;\n    \n\tfloat a=dot(g1,g1), b=dot(g1,g2);\n    float c=dot(g2,g1), d=dot(g2,g2);\n    float det=a*d-b*c;\n    float x=(d*val1-b*val2)/det;\n    float y=(-c*val1+a*val2)/det;\n    vec3 g=g1*x+g2*y;\n    grad=normalize(g);\n    return min(0.1, sqrt(dot(g,g))-0.01)*0.5;\n\t//return sqrt(val1*val1+val2*val2)*0.5-0.007;\n}\n\n\nvoid getColor(out vec4 fragColor, in vec3 pos, in vec3 ray){\n\tfloat col = 0.0;\n    float col_cur = 1.0;\n    for(int i=0;i<64;i++){\n        vec3 grad;\n    \tfloat d = dist(grad, pos);\n        if(d<1e-3){\n        \tfloat eps=1e-2;\n            /*\n            vec3 normal=vec3(\n            \tdist(pos + vec3(eps, 0.0, 0.0)) - dist(pos - vec3(eps, 0.0, 0.0)),\n            \tdist(pos + vec3(0.0, eps, 0.0)) - dist(pos - vec3(0.0, eps, 0.0)),\n            \tdist(pos + vec3(0.0, 0.0, eps)) - dist(pos - vec3(0.0, 0.0, eps))\n            );\n            normal = normalize(normal);\n            */\n            vec3 normal=grad;\n\t\t\tvec3 op_ray_dir = -normalize(ray);\n\t\t\tcol=col_cur * max(dot(normal, op_ray_dir), 0.5);\n            //col=col_cur;\n            break;\n        }\n        pos += d * ray;\n        col_cur -=1./64.;\n    }\n    fragColor = vec4(vec3(col), 1.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = ( fragCoord*2.-iResolution.xy ) / iResolution.y;\n\n\n    vec3 pos = vec3(0.0, 0.0, 2.0); //vec3(cos(iTime)*3.0, 0.0, sin(iTime)*3.0);\n    vec3 eye = vec3(0.0, 0.0, -1.0); //-normalize(pos);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(eye, up);\n    float angle = 0.5;\n    vec3 ray = eye + (right * uv.x + up * uv.y) * angle;\n    ray = normalize(ray);\n    \n\tgetColor(fragColor, pos, ray);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir )\n{\n\tgetColor(fragColor, fragRayOri, fragRayDir);\n}\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/","name":"Image","description":"","type":"image"}]}