{"ver":"0.1","info":{"id":"ttsGRs","date":"1557368179","viewed":155,"name":"Raymarching Dice","username":"WillKillU","description":"raymarching practice creating a dice","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","dice","spheremarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define time iTime\n#define resolution iResolution\n\nfloat box(vec3 p, vec3 c)\n{\n    //p = mod(p, 2.5) - 2.5 * 0.5;\n    vec3 q = abs(p)-c;\n    return min(0.0, max(q.x, max(q.y, q.z))) + length(max(q,0.0));\n}\n\nfloat map(vec3 p)\n{\n\t//p.x = mod(p.x, 2.5) - 2.5 * 0.5;\n\tfloat cube = box(p, vec3(0.6));\n\t\n\tfloat one = length(p + vec3(0.,-0.6,.0)) - 0.1;\n\tfloat two = min(length(p + vec3(0.6,-0.3,0.3)) - 0.1, \n\t\t\tlength(p + vec3(0.6,0.3,-0.3)) - 0.1);\n\tfloat three = min(length(p + vec3(0.0, 0.0,0.6)) - 0.1,\n\t\t\t  min(length(p + vec3(0.3, 0.3,0.6)) - 0.1,\n\t\t\t      length(p + vec3(-0.3, -0.3,0.6)) - 0.1));\n\tfloat four = min(length(p + vec3(0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,0.3,-0.6)) - 0.1,\n\t\t\t     length(p + vec3(0.3,0.3,-0.6)) - 0.1)));\n\t\n\tfloat five = min(length(p + vec3(-0.6,-0.3,0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,-0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,0.3)) - 0.1,\n\t\t\t     length(p + vec3(-0.6,0.0,0.0)) - 0.1))));\n\t\n\tfloat finalNumbers = min(one, min(two, min(three, min(four, five))));\n\t\n\treturn max((length(p) - 1.0), max(-finalNumbers, cube));\n}\n\nvec3 minVec4(vec4 a, vec4 b) \n{\n    return (a.a < b.a) ? a.rgb : b.rgb;\n}\n\nvec3 mapColor(vec3 p)\n{\n    //p.x = mod(p.x, 2.5) - 2.5 * 0.5;\n\tfloat cube = box(p, vec3(0.6));\n\t\n\tfloat one = length(p + vec3(0.,-0.6,.0)) - 0.1;\n\tfloat two = min(length(p + vec3(0.6,-0.3,0.3)) - 0.1, \n\t\t\tlength(p + vec3(0.6,0.3,-0.3)) - 0.1);\n\tfloat three = min(length(p + vec3(0.0, 0.0,0.6)) - 0.1,\n\t\t\t  min(length(p + vec3(0.3, 0.3,0.6)) - 0.1,\n\t\t\t      length(p + vec3(-0.3, -0.3,0.6)) - 0.1));\n\tfloat four = min(length(p + vec3(0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,-0.3,-0.6)) - 0.1,\n\t\t\t min(length(p + vec3(-0.3,0.3,-0.6)) - 0.1,\n\t\t\t     length(p + vec3(0.3,0.3,-0.6)) - 0.1)));\n\tfloat five = min(length(p + vec3(-0.6,-0.3,0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,-0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,-0.3)) - 0.1,\n\t\t\t min(length(p + vec3(-0.6,0.3,0.3)) - 0.1,\n\t\t\t     length(p + vec3(-0.6,0.0,0.0)) - 0.1))));\n\t\n\tfloat finalNumbers = min(one, min(two, min(three, min(four, five))));\n\t\n\treturn minVec4(\n\t\tvec4(vec3(0.0,0.0,0.0), finalNumbers),\n\t\tvec4(vec3(0.8,0.8,0.8), max((length(p) - 1.0), max(-finalNumbers, cube))));\n}\n\nvec3 normal(vec3 p)\n{\n\tvec2 eps = vec2(0.001, 0);\n\treturn normalize(vec3(\n\t\t             map(p + eps.xyy) - map(p - eps.xyy),\n\t\t\t     map(p + eps.yxy) - map(p - eps.yxy),\n\t\t\t     map(p + eps.yyx) - map(p - eps.yyx)\n\t\t\t     )\n\t\t\t);\n}\n\nfloat light(vec3 n, vec3 l)\n{\n\treturn dot(n,normalize(l)) * 0.5 + 0.5;\n}\n\nvec2 rotate(vec2 a, float b)\n{\n\tfloat c = cos(b);\n\tfloat s = sin(b);\n\t\n\treturn vec2(\n\t\t\ta.x * c - a.y *s,\n\t\t\ta.x * s + a.y *c\n\t\t   );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\tvec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y/iResolution.x, 1.0);\n\t\n\tvec3 ro = vec3(0.0, 4.0, -8.0);\n    //ro = vec3(0.0,0.0,-5.0);\n\tvec3 p = ro;\n\tvec3 rd = normalize(vec3(uv, 2.0) + vec3(0.0,-1.0,0.0));\n    //rd = normalize(vec3(uv,2.0));\n\t\n\tro.xz = rotate(ro.xz,iTime * 0.1);\n\tp.xz = rotate(p.xz, iTime * 0.1);\n\trd.xz = rotate(rd.xz, iTime * 0.1);\n\t\n\tfloat hit = 0.0;\n\t\n\tfor(float i = 0.; i < 50.0; ++i)\n\t{\n\t\tfloat df = map(p);\n\t\t\n\t\tif(df < 0.001)\n\t\t{\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tp += df * rd;\n\t}\n\tvec3 n = normal(p);\n\tvec3 l = vec3(1.0,2.0,1.0);\n\tl.xz = rotate(l.xz, iTime);\n\t\n\tvec3 finalColor = mix(vec3(0.0,0.0,0.0), mapColor(p), vec3(light(n,l)));\n\t\n\tfloat fresnel = pow(1.-dot(n,-rd), 2.0);\n\t\n\tvec3 fresnelColor = vec3(1.0,1.0,1.0);\n\t\n\tfinalColor = mix(finalColor, fresnelColor, fresnel);\n    \n\t\n\tfragColor = vec4(finalColor, 1.0);\n}","name":"Image","description":"","type":"image"}]}