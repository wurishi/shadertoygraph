{"ver":"0.1","info":{"id":"mdfGR8","date":"1665624806","viewed":58,"name":"10.12.2022:SpiceLatte","username":"g___r___e___g","description":"Two and a half weeks to figure out your costume.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["fragtober"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.2832\n\nvec2 rotate(vec2 p, float a) {\n  float s = sin(a), c = cos(a);\n  return mat2(c, -s, s, c) * p;\n}\n\n// interpretation of BigWing's raymarch starting point\nvec3 lookAt(vec2 uv, vec3 origin, vec3 target, float zoom) {\n  vec3 forward = normalize(target - origin);\n  vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = forward * zoom;\n  return normalize(center + uv.x * right + uv.y * up);\n}\n\nfloat sdLineSegment(vec3 p, vec3 a, vec3 b, float r) {\n  float h = dot(p-a, b-a) / dot(b-a, b-a);\n  h = clamp(h, 0., 1.);\n  return distance(p, mix(a, b, h)) - r;\n}\n\nfloat sdPumpkinFlesh(vec3 p) {\n  float a = atan(p.z, p.x);\n  float r = 0.75;\n  r += sin(a * 17.) * 0.010 * pow(length(p.xz), 1.4);\n  p.y *= 1.15;\n  p.y *= 1./(length(p.xz) + .45);\n  float d = length(p) - r;\n  return d;\n}\n\nfloat sdPumpkinStem(vec3 p) {\n  p.xy = rotate(p.xy, pow(p.y + 0.3, 3.) * 0.2);\n  float a = atan(p.z, p.x);\n  float r = 0.067;\n  r += sin(a * 15.) * 0.0010;\n  float d = sdLineSegment(\n    p,\n    vec3(0, 0.35, 0),\n    vec3(0, 0.65, 0),\n    r\n  );\n  return d * .5;\n}\n\nvec2 scene(vec3 p) {\n  float dFlesh = sdPumpkinFlesh(p);\n  float dStem = sdPumpkinStem(p);\n  return vec2(min(dFlesh, dStem), dFlesh < dStem ? 0. : 1.);\n}\n\nvec3 sceneNormal(vec3 p) {\n  vec2 e = vec2(1e-4, 0);\n  return normalize(vec3(\n    scene(p + e.xyy).x - scene(p - e.xyy).x,\n    scene(p + e.yxy).x - scene(p - e.yxy).x,\n    scene(p + e.yyx).x - scene(p - e.yyx).x\n  ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float sf = 1. / min(iResolution.x, iResolution.y);\n  vec2 uv = sf * (2.*fragCoord - iResolution.xy);\n  vec2 mouse = iMouse.xy / iResolution.xy;\n  vec3 color = vec3(0);\n\n  vec3 ro = vec3(0, 1.5, 3.5);\n  ro.yz = rotate(ro.yz, -mouse.y * TAU / 2.);\n  ro.xz = rotate(ro.xz, -mouse.x * TAU + 0.15 * iTime);\n\n  vec3 rd = lookAt(uv, ro, vec3(0), 3.);\n\n  float d = 0.;\n  bool hit = false;\n  for (int i = 0; i < 100; i++) {\n    vec3 p = ro + rd * d;\n    float dS = scene(p).x;\n    if (dS < 1e-5) { hit = true; break; }\n    d += dS;\n    if (d > 10.) break;\n  }\n\n  if (hit) {\n    vec3 lightDir = normalize(vec3(1, 1, -1));\n    vec3 p = ro + rd * d;\n    vec3 n = sceneNormal(p);\n    vec3 c = scene(p).y == 0.\n      ? vec3(.62,.27, .2) \n      : vec3(0.34, .22, .05);\n    color = c * clamp(dot(n, lightDir)*.7 + 0.3, 0., 1.);\n    color += vec3(0.05, 0.20, 0.025) * .6 * max(0., -n.y);\n  }\n\n  fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}]}