{"ver":"0.1","info":{"id":"Mc3Sz2","date":"1714436602","viewed":96,"name":"Fork cool fpn r Cesium_137 476","username":"Cesium_137","description":"Ray tracing with 3D fractal perlin noise with high fov and just a few stepps for each pixel. The final color is bright if the last step is close to a volume. Because the stepps are not constant the image looks funny when the cammera is close to a volume","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["3d","fractal","noise","perlin","black","fractalperlinnoise"],"hasliked":0,"parentid":"lc3SR2","parentname":"cool fpn ray tracing effect"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//http://dev.thi.ng/gradients/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    float z = iTime /2.;\n    vec2 xy = iMouse.xy / 50.;\n    vec3 camPos = vec3(xy, z);\n    vec3 screenCenterPos = vec3(xy, z + .5);\n    vec3 pixelPos = vec3(screenCenterPos.xy + (uv * 1.), screenCenterPos.z);\n    \n    vec3 dir = normalize(pixelPos - camPos);\n    vec3 currentPos = camPos;\n    float threshold = 0.66;\n    float maxIterations = 15.;\n    \n    for (float i = 0.; i < maxIterations; i++)\n    {\n        float fpn = fractalPerlinNoise(currentPos, numOctaves);\n        float minDist = threshold - fpn;\n        fragColor = vec4(palette(minDist * 2.), 0.);\n        if (fpn > threshold - 0.001)\n        {\n            break;\n        }\n        currentPos += dir * minDist * 1.01;\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define twoPi 6.28318530718\n#define numOctaves 5.\n\nvec3 palette( float t ) {\n    vec3 a = vec3(0.03, 0.24, 0.5);\n    vec3 b = vec3(0.96, 0.75, 0.5);\n    vec3 c = vec3(1.25, 0.95, 0.64);\n    vec3 d = vec3(0.0, 1.3, 0.5);\n    float e = 12.;\n    return smoothstep(0.,1.,e*t) * (a + b*cos(6.28318*(c*t+d)));\n}\n\nuvec2 murmurHash23(uvec3 src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y; h *= M; h ^= src.z;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\n\nvec2 hash23(vec3 src) {\n    uvec2 h = murmurHash23(floatBitsToUint(src));\n    return uintBitsToFloat(h & 0x007fffffu | 0x3f800000u) - 1.0;\n}\n\n\nvec3 randomVec3(vec3 p)\n{       \n    vec2 u = hash23(p);  \n    float phi = acos(2. * u.x - 1.) - twoPi * 0.25;\n    float lambda = twoPi * u.y;\n    return vec3(cos(phi) * cos(lambda), cos(phi) * sin(lambda), sin(phi));\n}\n\nfloat interpolate(float a, float b, float f) {\n\n    return (b - a) * ((f * (f * 6.0 - 15.0) + 10.0) * f * f * f) + a;\n}\n\nfloat perlinNoise(vec3 p)\n{\n    float xi = floor(p.x);\n    float yi = floor(p.y);\n    float zi = floor(p.z);\n    float xf = fract(p.x);\n    float yf = fract(p.y);\n    float zf = fract(p.z);\n    \n    float btr = dot(vec3(xf-1.0, yf-1.0, zf-1.0), randomVec3(vec3(xi+1.0, yi+1.0, zi+1.0)));\n    float btl = dot(vec3(xf, yf-1.0, zf-1.)    , randomVec3(vec3(xi, yi+1.0, zi+1.)));\n    float bbr = dot(vec3(xf-1.0, yf, zf-1.)    , randomVec3(vec3(xi+1.0, yi, zi+1.)));\n    float bbl = dot(vec3(xf, yf, zf-1.)        , randomVec3(vec3(xi, yi, zi+1.0)));\n    float ftr = dot(vec3(xf-1.0, yf-1.0, zf), randomVec3(vec3(xi+1.0, yi+1.0, zi)));\n    float ftl = dot(vec3(xf, yf-1.0, zf)    , randomVec3(vec3(xi, yi+1.0, zi)));\n    float fbr = dot(vec3(xf-1.0, yf, zf)    , randomVec3(vec3(xi+1.0, yi, zi)));\n    float fbl = dot(vec3(xf, yf, zf)        , randomVec3(vec3(xi, yi, zi)));\n    \n    return interpolate(interpolate(interpolate(fbl, fbr, xf), interpolate(ftl, ftr, xf), yf), \n                       interpolate(interpolate(bbl, bbr, xf), interpolate(btl, btr, xf), yf), zf);\n}\n\nfloat fractalPerlinNoise(vec3 pos, float octaves)\n{\n    float res = 0.;\n    for (float i = 0.; i < numOctaves; i++)\n    {\n        float zoom = i + 1.;\n        float weight = 1. / zoom;\n        res += weight * perlinNoise(vec3(pos * zoom));\n    }\n    return (res + 1.) / 2.;\n}\n","name":"Common","description":"","type":"common"}]}