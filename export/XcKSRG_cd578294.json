{"ver":"0.1","info":{"id":"XcKSRG","date":"1715351996","viewed":120,"name":"Neon Integral","username":"timgo","description":"This uses an analytical integral of light over arcs and lines.\n\nStyle inspired by [url]https://www.shadertoy.com/view/WdK3Dz[/url] (but very different shader)","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["2d","heart","glow","integral","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Integral for line and arc derived using CAS\n * Explanation: https://timgott.github.io/neon/\n */\n\nfloat pointLight(vec3 p, vec3 light) {\n    // translation of the formula above in vector form\n    // p: sample point\n    // light: light position\n    vec3 d = p - light;\n    return 1.0/dot(d, d);\n}\n\n// Gamma correction\nvec3 gammaCorrect(vec3 x, float gamma) {\n    return pow(x, vec3(1.0 / gamma));\n}\n\n// Exponential exposure\nvec3 exposure(vec3 x) {\n    return 1.0 - exp(-x);\n}\n\n// Combined tone mapping\nvec3 tonemap(vec3 x, float gamma) {\n    return gammaCorrect(exposure(x), gamma);\n}\n\n\nstruct Line {\n    vec2 start;\n    vec2 end;\n    float z;\n};\n\nfloat lineNeon(vec2 p, Line line) {\n    // move start to origin\n    p = p - line.start;\n    vec2 q = line.end - line.start;\n    float z = line.z;\n\n    // made from manual simplification of Wolfram Alpha integral\n    float a = dot(q, q); // u^2 + v^2\n    float b = dot(q, p); // u*x + v*y\n    float c = q.y*p.x - q.x*p.y; // v*x - u*y\n    float r = 1.0/sqrt(z*z*a + c*c);\n    float len = sqrt(a); // additional correction for line length\n    float F1 = atan((a - b)*r); // t=1\n    float F0 = atan(-b*r); // t=0\n    return (F1 - F0)*r * len;\n}\n\n#define M_PI 3.14159265359\n\n// Antiderivative of light from arc received at p\n// t is angle in radians\nfloat arcNeon_F(vec3 p, float t) {\n    vec3 psqr = p*p;\n    float v1 = psqr.x + psqr.y + 1.0;\n    float v2 = psqr.x + psqr.y - 1.0;\n    float v3 = tan(0.5*t)*(v1 + psqr.z + 2.0*p.y) - 2.0*p.x;\n    float r = 1.0/sqrt(2.0*psqr.z * v1 + v2*v2 + psqr.z*psqr.z);\n    return 2.0*(atan(v3*r) + M_PI*floor(0.5*(t/M_PI + 1.0)))*r;\n}\n\n// Interface to draw arcs:\n\nstruct Arc {\n    vec3 center;\n    float radius;\n    float start;\n    float end;\n};\n\nfloat arcNeon(\n    vec2 uvpos,\n    Arc arc\n) {\n    // coordinates scaled by radius\n    vec3 p = (vec3(uvpos, 0.0) - arc.center) / arc.radius;\n\n    // integral\n    float F1 = arcNeon_F(p, arc.end);\n    float F0 = arcNeon_F(p, arc.start);\n    float integral = F1 - F0;\n\n    // compensated for scaled coordinates (divide by radius^2)\n    // and for arc length (multiply result by radius)\n    return integral / arc.radius;\n}\n\nfloat lineNeonAnimated(vec2 p, Line line, float t, float trail) {\n    float t0 = clamp(t - trail, 0.0, 1.0);\n    float t1 = clamp(t, 0.0, 1.0);\n    vec2 p0 = mix(line.start, line.end, t0);\n    vec2 p1 = mix(line.start, line.end, t1);\n    if (t0 == t1) {\n        return 0.0;\n    }\n    return lineNeon(p, Line(p0, p1, line.z));\n}\n\nfloat arcNeonAnimated(vec2 p, Arc arc, float t, float trail) {\n    float t0 = clamp(t - trail, 0.0, 1.0);\n    float t1 = clamp(t, 0.0, 1.0);\n    if (t0 == t1) {\n        return 0.0;\n    }\n    float a0 = mix(arc.start, arc.end, t0);\n    float a1 = mix(arc.start, arc.end, t1);\n    float s = arc.end > arc.start ? 1.0 : -1.0; // allow both directions\n    return s*arcNeon(p, Arc(arc.center, arc.radius, a0, a1));\n}\n\nfloat heartAnimated(vec2 uvpos, float z, float l, float t) {\n    const float period = 4.0;\n    float t1 = mod(t - 0.0, period);\n    float t2 = mod(t - 1.0, period);\n    float t3 = mod(t - 2.0, period);\n    float t4 = mod(t - 3.0, period);\n    float v;\n    float quarter = M_PI * 0.5;\n    float radius = sqrt(0.5*0.5 + 0.5*0.5);\n\n    Line lineR = Line(vec2(0.0, -1.0), vec2(1.0, 0.0), z);\n    Line lineL = Line(vec2(-1.0, 0.0), vec2(0.0, -1.0), z);\n    Arc arcR = Arc(vec3(0.5, 0.5, z), radius, M_PI*(3.0/4.0), M_PI*(3.0/4.0-1.0));\n    Arc arcL = Arc(vec3(-0.5, 0.5, z), radius, M_PI*(1.0/4.0), M_PI*(1.0/4.0-1.0));\n\n    v += lineNeonAnimated(uvpos, lineR, t1, l);\n    //v += arcNeonAnimated(uvpos, vec3(0.5, 0.5, z), radius, M_PI*(3.0/4.0)-t2*M_PI, M_PI*(3.0/4.0)-s2*M_PI);\n    v += arcNeonAnimated(uvpos, arcR, t2, l);\n    //v += arcNeon(uvpos, arcR);\n    //v += arcNeon(uvpos, arcL);\n    v += arcNeonAnimated(uvpos, arcL, t3, l);\n    v += lineNeonAnimated(uvpos, lineL, t4, l);\n    return v;\n}\n\nfloat heartbeat(float t) {\n    float speed = M_PI;\n    t *= speed;\n    return -pow((sin(t+1.2)+1.0)*0.5, 70.0) * 0.6 + pow((sin(t+0.3)+1.0)*0.5, 20.0) * 0.3 - pow((sin(t+2.8)+1.0)*0.5, 10.0)*0.2;\n}\n\nvec4 demoBeatingHeart(vec2 uvpos) {\n    float time = iTime + 21.0;\n    float bpmFactor = 100.0/60.0;\n    float beat = heartbeat(time*bpmFactor);\n    float phasing = (sin(time*1.3)+1.0)*0.5;\n    float intensity = 0.3+0.2*beat;\n    float z = 0.02 + 0.02 * beat;\n    vec3 pink = vec3(0.9,0.2,1.0);\n    vec3 red = vec3(0.8,0.1,0.3)*1.5; // perceived brightness multiplier\n    vec3 blue = vec3(0.1,0.3,0.9);\n    vec3 yellow = vec3(1.0,0.2,0.1);\n    vec2 center = iResolution.xy * 0.5;\n    float s = 100.0 + beat*10.0;\n    uvpos /= s;\n    vec3 c;\n    c += red * intensity * heartAnimated(uvpos, z, 1.5, time * bpmFactor * 1.0 + 0.0);\n    c += blue * 0.1 * heartAnimated(uvpos, z, 2.0, time*0.3+1.0);\n    c += pink * 1.0 * pointLight(vec3(uvpos, z), vec3(0.0, 0.2, 0.5+beat*0.2));\n    return vec4(tonemap(c, 1.3), 1.0);\n}\n\nvoid mainImage(out vec4 out_color, in vec2 uvpos) {\n    uvpos = uvpos - iResolution.xy * 0.5;\n    uvpos = uvpos * 500.0 / iResolution.y;\n    out_color = demoBeatingHeart(uvpos);\n    //out_color = demo_pulsing(uvpos);\n}","name":"Image","description":"","type":"image"}]}