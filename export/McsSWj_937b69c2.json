{"ver":"0.1","info":{"id":"McsSWj","date":"1705847187","viewed":60,"name":"Ray Marching - Play test","username":"EnderSpace","description":"Basic ray marching test.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float magicDist(vec3 so, float r, vec3 pos) {\n    // sphere origin, sphere radius, position\n    pos = mod(pos, 5.) - 2.5; // space repetition\n    return distance(pos, so) - r;\n}\n\n\nvec2 rot(vec2 p, float a) {\n    // rot must be normalized (to avoid scaling)\n    vec2 r = vec2(cos(a), sin(a));\n    return vec2(p.x * r.x - p.y * r.y, p.x * r.y + p.y * r.x);\n}\n\n\nvec3 fullRot(vec3 p, vec3 r) { // point, rotation\n    // rot contains the angle od rotation of each axis\n    p = vec3(rot(p.xy, r.z), p.z);\n    p = vec3(p.x, rot(p.yz, r.x));\n    vec2 pxz = rot(p.xz, r.y);\n    p = vec3(pxz.x, p.y, pxz.y);\n    return p;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n\n    // spheres data\n    \n    const vec4 s1 = vec4(0., 0., 0., 1.); // sphere 1 pos x, y, z, radius\n\n    // ray marching\n    \n    vec3 ro = vec3(0., 0., -3. + 5. * iTime);  // ray origin\n    vec3 rd = normalize(vec3(uv, 2.));         // ray direction\n    rd = fullRot(rd, vec3(sin(iTime * .1) * .3, sin(iTime * .015) * .3, iTime * .1));  // rot\n                                               // canvas in at -1z in 3D world\n    \n    float d = 0.;                              // distance travelled\n    \n    for (int i = 0; i < 100; i++) {\n    \n        vec3 p = ro + rd * d;                  // position\n        p += vec3(sin(d * .15), sin(iTime + d * .12), 0.); // transforming the position\n        //p = vec3(rot(p.xy, d * .04 * pow(cos(iTime * .1), 5.) + sin(iTime * .4)), p.z);\n        //p = vec3(rot(p.xy, normalize(vec2(cos(d * .01 + sin(iTime * .4)), sin(d * .01 + cos(iTime * .4))))), p.z);\n    \n        float sd = magicDist(s1.xyz, s1.w, p); // distance to the scene (nearest obj)\n    \n        d += sd;                               // 'travel'\n        \n        if (sd < .001 || sd > 1000.) break;    // break if distance to scene too far away or too smol\n    }\n    \n    col = vec3(d * .01);\n    col += vec3(0., (1000. - d) / 1900., (1000. - d) / 1800.);\n\n\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}