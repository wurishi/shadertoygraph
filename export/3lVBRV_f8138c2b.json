{"ver":"0.1","info":{"id":"3lVBRV","date":"1614694679","viewed":850,"name":"edge glow rainbow","username":"bboettcher3","description":"credit to @jmk for original shader, this works off it their shader here: https://www.shadertoy.com/view/Mdf3zr","likes":7,"published":1,"flags":2,"usePreview":1,"tags":["sobel","glow","edge","rainbow","neon"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3zn","filepath":"/presets/webcam.png","previewfilepath":"/presets/webcam.png","type":"webcam","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Returns rgb vec from input 0-1 */\nvec3 getRainbowColor(in float val) {\n    /*convert to rainbow RGB*/\n    float a = (1.0 - val) * 6.0;\n    int X = int(floor(a));\n    float Y = a - float(X);\n    float r = 0.;\n    float g = 0.;\n    float b = 0.;\n    if (X == 0) {\n        r = 1.; g = Y; b = 0.;\n    } else if (X == 1) {\n        r = 1. - Y; g = 1.; b = 0.;\n    } else if (X == 2) {\n        r = 0.; g = 1.; b = Y;\n    } else if (X == 3) {\n        r = 0.; g = 1. - Y; b = 1.;\n    } else if (X == 4) {\n        r = Y; g = 0.; b = 1.;\n    } else if (X == 5) {\n        r = 1.; g = 0.; b = 1. - Y;\n    } else {\n        r = 0.; g = 0.; b = 0.;\n    }\n    return vec3(r, g, b);\n}\n\nfloat d;\n\nfloat lookup(vec2 p, float dx, float dy, float edgeIntensity)\n{\n    vec2 uv = (p.xy + vec2(dx * edgeIntensity, dy * edgeIntensity)) / iResolution.xy;\n    vec4 c = texture(iChannel0, uv.xy);\n\t\n\t// return as luma\n    return 0.2126*c.r + 0.7152*c.g + 0.0722*c.b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float timeNorm = mod(iTime, 5.) / 5.;\n    vec3 glowCol = getRainbowColor(timeNorm);\n    float edgeIntensity = 1.;\n    if (timeNorm < .5) { edgeIntensity += (4. * timeNorm);}\n    else { edgeIntensity += -4. * (timeNorm - 1.); }\n    vec2 p = fragCoord.xy;\n    \n\t// simple sobel edge detection\n    float gx = 0.0;\n    gx += -1.0 * lookup(p, -1.0, -1.0, edgeIntensity);\n    gx += -2.0 * lookup(p, -1.0,  0.0, edgeIntensity);\n    gx += -1.0 * lookup(p, -1.0,  1.0, edgeIntensity);\n    gx +=  1.0 * lookup(p,  1.0, -1.0, edgeIntensity);\n    gx +=  2.0 * lookup(p,  1.0,  0.0, edgeIntensity);\n    gx +=  1.0 * lookup(p,  1.0,  1.0, edgeIntensity);\n    \n    float gy = 0.0;\n    gy += -1.0 * lookup(p, -1.0, -1.0, edgeIntensity);\n    gy += -2.0 * lookup(p,  0.0, -1.0, edgeIntensity);\n    gy += -1.0 * lookup(p,  1.0, -1.0, edgeIntensity);\n    gy +=  1.0 * lookup(p, -1.0,  1.0, edgeIntensity);\n    gy +=  2.0 * lookup(p,  0.0,  1.0, edgeIntensity);\n    gy +=  1.0 * lookup(p,  1.0,  1.0, edgeIntensity);\n    \n\t// hack: use g^2 to conceal noise in the video\n    float g = gx*gx + gy*gy;\n    \n    vec4 col = texture(iChannel0, p / iResolution.xy);\n    col += vec4(g * glowCol, 1.0);\n    \n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}