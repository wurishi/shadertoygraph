{"ver":"0.1","info":{"id":"7tGGD3","date":"1703184037","viewed":112,"name":"fires of automata","username":"Carandiru","description":"advanced cellular automata simulation using a spectrum of visible to near-infrared light.\n\n*keyboard arrows* control bit selection [left, right] and toggling [up, down]\nglobal state is then changed in  - each states impact on change varies\n","likes":5,"published":3,"flags":48,"usePreview":0,"tags":["random","sampling","automata","cellular","state","deterministic","ca"],"hasliked":0,"parentid":"slK3Wy","parentname":"contradiction"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":2,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// fires of automata by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// advanced cellular automata simulation using a spectrum of visible to near-infrared light.\n//\n// *keyboard arrows* control bit selection [left, right] and toggling [up, down]\n// global state is then changed in realtime - each states impact on change varies\n// *the 8th bit\" (thats the first one on the left) can reset the sim if set momentarily\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2\n#endif\n\n// https://www.shadertoy.com/view/wl2SDt\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float bn = textureLod(iChannel2, fragCoord.xy/1024.0f, 0.0f).r;\n\n    vec3 tot = vec3(0.0f);\n#if AA>1\n    for( int m=0; m<AA; ++m )\n    for( int n=0; n<AA; ++n )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5f;\n        vec2 uv = (fragCoord+o)/iResolution.xy;\n#else    \n        vec2 uv = fragCoord/iResolution.xy;\n#endif\n\n        const float mip = 0.0f;\n        \n        vec4 t0 = textureLodOffset(iChannel0, uv, mip, ivec2( 1, 0));\n        vec4 t1 = textureLodOffset(iChannel0, uv, mip, ivec2(-1, 0));\n        vec4 t2 = textureLodOffset(iChannel0, uv, mip, ivec2(0, 1));\n        vec4 t3 = textureLodOffset(iChannel0, uv, mip, ivec2(0,-1));\n   \n        t0.xyz = iphi*normalize(t0.xyz * 2.0f - 1.0f);\n        t1.xyz = iphi*normalize(t1.xyz * 2.0f - 1.0f);\n        t2.xyz = iphi*normalize(t2.xyz * 2.0f - 1.0f);\n        t3.xyz = iphi*normalize(t3.xyz * 2.0f - 1.0f);\n\n        vec4 cc = textureLod(iChannel0, uv, mip);\n\n        vec3 color = vec3(0);\n\n        color = spectrum_infrared(cc.w + length(cc.xyz) + 1000.0f * abs(abs(t0.w-t2.w) - abs(t1.w-t3.w)));\n\n        float lumi = dot(color, luma);\n        vec3 original = color;\n       \n        vec3 signals = normalize(cross(normalize(t0.xyz*t0.w - t2.xyz*t2.w), normalize(t1.xyz*t1.w - t3.xyz*t3.w)));\n         \n        vec3 glow = spectrum_infrared(abs(dot(signals * 0.5f + 0.5f, color.xyz)));\n        \n        float shadow = clamp(abs(dot(1.0f - glow, color)), 0.0f, 1.0f);\n        shadow = smoothstep(0.0f, 0.5f, shadow*(1.0f-cc.w));\n        \n        color = color * mix(vec3(shadow), glow, glow);\n        \n        color = original + color*mix(color, color*(1.0f - shadow) * glow, lumi - max(0.0f, lumi - 0.5f));\n        \n        float overlay = textureLod(iChannel1, uv, 0.0f).r;\n\n        color += overlay;\n\n        // to gamma space\n        tot += pow(color, vec3(1.0f/2.2f));\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    tot = mix(ACESFilm(tot*tot), tot, dot(tot, luma));\n    \n    // dither\n    float n = bn * 11.0f/255.0f;\n    \n    tot = mix(tot + n*tot, tot - n*tot, (1.0f - bn)*(1.0f - iphi) + tot*iphi);\n    \n\tfragColor = vec4( tot, 1.0f );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":1,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// fires of automata by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// advanced cellular automata simulation using a spectrum of visible to near-infrared light.\n//\n// *keyboard arrows* control bit selection [left, right] and toggling [up, down]\n// global state is then changed in realtime - each states impact on change varies\n// *the 8th bit\" (thats the first one on the left) can reset the sim if set momentarily\n\nvec2 rotate( in vec2 p, in float angle )\n{\n    #define fma(a,b,c) (a*b+c)\n    \n\t#define c_ x\n\t#define s_ y\n\tvec2 cossin = vec2(cos(angle), sin(angle));\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\n\n\nvoid unpack_rule(out float rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = float(bool(r & (1u << 7u)));\n    rule[1] = float(bool(r & (1u << 6u)));\n    rule[2] = float(bool(r & (1u << 5u)));\n    rule[3] = float(bool(r & (1u << 4u)));\n    rule[4] = float(bool(r & (1u << 3u)));\n    rule[5] = float(bool(r & (1u << 2u)));\n    rule[6] = float(bool(r & (1u << 1u)));\n    rule[7] = float(bool(r & (1u << 0u)));\n}\n\nfloat state(in float rule[directions], in float p, in float c, in float n)\n{\n    uint d = 0u;\n    \n    d |= uint(bool(p)) << 2u;\n    d |= uint(bool(c)) << 1u;\n    d |= uint(bool(n)) << 0u;\n    \n    return rule[7u - d];\n}\n\nvoid sampleDimension(uint index, in float rule[directions], inout vec4 auto, in vec2 uv, in float bn)\n{\n    float c = textureLod(iChannel0, uv, 0.0f).r;\n    \n    vec2 change = vec2(0);\n    \n    float xp = textureLodOffset(iChannel0, uv, 0.0f, ivec2( 1, 0))[index];\n    float xn = textureLodOffset(iChannel0, uv, 0.0f, ivec2(-1, 0))[index];\n\n    change.x = state(rule, xp, c, xn);\n   \n    float yp = textureLodOffset(iChannel0, uv, 0.0f, ivec2(0, 1))[index];\n    float yn = textureLodOffset(iChannel0, uv, 0.0f, ivec2(0,-1))[index];\n\n    change.y = state(rule, yp, c, yn);\n    \n    float t = bn*length(change) + 1.0f;\n    \n    vec2 duv = pow(uv, vec2(1.0f));\n    \n    vec4 ii_iv;\n    ii_iv.y = mix(xp, change.x, iphi*(duv.x*duv.x + t / iResolution.x));\n    ii_iv.x = mix(yp, change.y, iphi*(duv.y*duv.y + t / iResolution.y));\n    ii_iv.w = mix(xn, change.x, (1.0f - iphi)*(duv.x*duv.x + t / iResolution.x));\n    ii_iv.z = mix(yn, change.y, (1.0f - iphi)*(duv.y*duv.y + t / iResolution.y));\n    \n    change.x = max(ii_iv.x, ii_iv.z);\n    change.y = min(ii_iv.y, ii_iv.w);\n    \n    vec2 states;\n    states = vec2(abs(change.x - abs(change.x-change.y)), abs(change.y - abs(change.x-change.y)));\n    \n    bn = bn * (17.0f/255.0f);\n    \n    float nw = (1.0f-iphi) + iphi * ((change.y*(1.0f - iphi) + change.x*(iphi)) * iphi + bn*length(change)*(1.0f - iphi));\n    \n    auto[index] += mix( nw * ((states.x*cos(states.x)) ), (states.x), iphi);\n    auto[(index + 1u)] += mix( nw * ((states.y*sin(states.y)) ), (states.y), iphi);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 auto = vec4(0);\n    \n    uint frame = uint(iFrame);\n    \n    float last_resolution = texelFetch(iChannel2, ivec2(0), 0).b;\n    bool changed_resolution = bool(floor(sign(last_resolution) * 0.5f + 0.5f));\n    last_resolution = float(floatBitsToUint(abs(last_resolution)));\n    uv = mix(uv, uv * length(iResolution.xy) / last_resolution + vec2(0.5f), bvec2(changed_resolution));\n    frame = changed_resolution ? 0u : frame;\n    \n    float state = textureLod(iChannel2, uv, 0.0f).a;\n    \n    float rule[directions];\n    unpack_rule(rule, state);\n        \n    vec4 bn = textureLod(iChannel1, (fragCoord.xy)/1024.0f, 0.0f);\n    \n    if (frame < 4u || changed_resolution) {\n    \n        uvec2 uuv = uvec2(fragCoord.xy);\n        \n        auto.xy = vec2(rule[uuv.x & (bits - 1u)], rule[uuv.y & (bits - 1u)]);\n        auto.zw = vec2(rule[uuv.x & (bits - 1u)], rule[uuv.y & (bits - 1u)]);  \n \n        auto += bn * (17.0f/255.0f);\n    }\n    else {\n       \n        auto.xyz = textureLod(iChannel0, uv, 0.0f).xyz;\n    }\n    \n    float ll = length(auto.xyz);\n\n    mat3 space;\n    \n    space = mat3( ((auto.xyz)) ,\n                  ((auto.yzx)) , \n                  ((auto.zxy)) );  \n    \n    auto.xyz = space * auto.xyz * iTimeDelta;\n\n    sampleDimension(3u, rule, auto, uv, bn.w);\n    sampleDimension(2u, rule, auto, uv, bn.z);\n    sampleDimension(1u, rule, auto, uv, bn.y);\n    sampleDimension(0u, rule, auto, uv, bn.x);\n        \n    fragColor = vec4(abs(auto));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// fires of automata by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// advanced cellular automata simulation using a spectrum of visible to near-infrared light.\n//\n// *keyboard arrows* control bit selection [left, right] and toggling [up, down]\n// global state is then changed in realtime - each states impact on change varies\n// *the 8th bit\" (thats the first one on the left) can reset the sim if set momentarily\n\n#define bits 8u\n#define pi 3.14159265358979323846\n#define GOLDEN_RATIO (1.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243) // 1618033988\n#define GOLDEN_RATIO_ZERO (0.618033988749894848204586834365638117720309179805762862135448622705260462818902449707207204189391137484754088075386891752126633862223536931793180060766726354433389086595939582905638322661319928290267880675208766892501711696207032221043216269548626296313614438149758701220340805887954454749246185695364864449241044320771344947049565846788509874339442212544877066057189033788811218482216986198774837979833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080980526767303517699677977504091090378155646968210243)\n#define GOLDEN_ANGLE ( 2.0f * pi * (1.0f/(GOLDEN_RATIO*GOLDEN_RATIO)) )\n#define phi GOLDEN_RATIO \n#define iphi GOLDEN_RATIO_ZERO\n#define gangle GOLDEN_ANGLE\n#define luma vec3(0.2126f, 0.7152f, 0.0722f)\n#define directions (8)\n\n#define fma(a,b,c) (a*b+c)\n\nvec2 rotate( in vec2 p, in vec2 cossin )\n{\n\t#define c_ x\n\t#define s_ y\n\n\treturn( vec2(fma(p.x, cossin.c_, p.y * cossin.s_), fma(p.x, -cossin.s_, p.y * cossin.c_)) );\n\n\t#undef c_\n\t#undef s_\n}\n\nfloat bellcurve(float x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(pi / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}\nvec4 bellcurve(vec4 x) // 0..1 input to 0..1 output\n{\n    // mu is 0.0 (centered), sigma is 0.5\n    const float c = float(pi / -1.25331414f); // optimized magic value - bellcurve perfect match (to six digits of precision) - removes sqrt\n                                            // https://www.desmos.com/calculator/xxwdiqa4sk\n    x = 2.0f * (2.0f * x - 1.0f);  // converts input range\n\n    return(exp(x * x * c));\n}\n// https://www.shadertoy.com/view/WlfXRN\nvec3 inferno(float t) {\n\n    const vec3 c0 = vec3(0.0002189403691192265, 0.001651004631001012, -0.01948089843709184);\n    const vec3 c1 = vec3(0.1065134194856116, 0.5639564367884091, 3.932712388889277);\n    const vec3 c2 = vec3(11.60249308247187, -3.972853965665698, -15.9423941062914);\n    const vec3 c3 = vec3(-41.70399613139459, 17.43639888205313, 44.35414519872813);\n    const vec3 c4 = vec3(77.162935699427, -33.40235894210092, -81.80730925738993);\n    const vec3 c5 = vec3(-71.31942824499214, 32.62606426397723, 73.20951985803202);\n    const vec3 c6 = vec3(25.13112622477341, -12.24266895238567, -23.07032500287172);\n\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n\n}\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.), max(vec3(0.),x));\n}\n\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n\n// RED - NEAR INFRARED SPECTRUM\nvec3 spectrum_infrared(float w)\n{\n    // w   : [0.0, 1.0]\n    const float range = 1119.;\n    float offset = 1.;\n\n    w = smoothstep(0.0f, range*0.25f, sqrt(w));\n    \n    vec3 c = spectral_zucconi(offset + range * pow((pow(w, exp(-2.95f)) + pow(w, exp(-3.05f))) * 0.5f, 1.0f - exp(-3.0f)));\n    \n    return c;\n}\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// fires of automata by Jason Tully is licensed under a Creative Commons Attribution-ShareAlike 4.0 International License.\n// Based on a work at https://www.shadertoy.com/view/slK3Wy\n// Permissions beyond the scope of this license may be available at http://bit.ly/supersinfulsilicon\n\n\n// advanced cellular automata simulation using a spectrum of visible to near-infrared light.\n//\n// *keyboard arrows* control bit selection [left, right] and toggling [up, down]\n// global state is then changed in realtime - each states impact on change varies\n// *the 8th bit\" (thats the first one on the left) can reset the sim if set momentarily\n\nint rule[directions] = int[directions]( 0, 1, 1, 0, 1, 1, 1, 0 );\n// 0001 0111\n// 0110 1111\n// 0110 1110\n\nfloat pack_rule()\n{\n    int r = 0;\n    r = (rule[0] << 7) | \n        (rule[1] << 6) |\n        (rule[2] << 5) |\n        (rule[3] << 4) |\n        (rule[4] << 3) |\n        (rule[5] << 2) |\n        (rule[6] << 1) |\n        (rule[7] << 0);\n        \n    return(float(uint(r)) / 255.0f);\n\n}\n\nvoid unpack_rule(out int rule[directions], in float packed)\n{\n    uint r = uint(packed * 255.0f);\n    \n    rule[0] = int(bool(r & (1u << 7u)));\n    rule[1] = int(bool(r & (1u << 6u)));\n    rule[2] = int(bool(r & (1u << 5u)));\n    rule[3] = int(bool(r & (1u << 4u)));\n    rule[4] = int(bool(r & (1u << 3u)));\n    rule[5] = int(bool(r & (1u << 2u)));\n    rule[6] = int(bool(r & (1u << 1u)));\n    rule[7] = int(bool(r & (1u << 0u)));\n}\n\n// Original text shader taken from https://www.shadertoy.com/view/MstBzN by Rafbeam\nconst int CHARS[41] = int[](\n    0x00000000, \n    0x00E8FE31, \n    0x01E8FA3E, \n    0x00F8420F, \n    0x01E8C63E,\n    \n    0x01F87A1F, \n    0x01F87A10, \n    0x00F84E2F, \n    0x0118FE31, \n    0x00421084,\n    \n    0x01F0862F, \n    0x01197251, \n    0x0108421F, \n    0x01BAD6B1, \n    0x011CD671,\n    \n    0x00E8C62E, \n    0x01E8FA10, \n    0x00E8D66E, \n    0x01E8FA31,\n    0x00F8383E,\n    \n    0x0000001F, \n    0x0118C62E, \n    0x0118C544, \n    0x0118C6AA, \n    0x01151151,\n    \n    0x0118A884, \n    0x01F9113F, \n    0x00ECD66E, \n    0x0046509F, \n    0x00E8991F, \n    \n    0x00E89A2E, \n    0x00232BE2, \n    0x01F8383E, \n    0x00F87E3E, \n    0x01F11108, \n    \n    0x00E8BA2E, \n    0x00F8FC3E, \n    0x00000004, \n    0x00000088, \n    0x00421004, \n    0x00E11004\n);\n\nfloat character(float color, float background, int character, vec2 position, float size, vec2 uv)\n{\n    if((uv.x > position.x && uv.x < position.x + size) && (uv.y > position.y && uv.y < position.y + size))\n    {\n        ivec2 pixel = ivec2(ceil((uv.x-position.x)/size*5.0)-1.0, ceil((1.0-(uv.y-position.y)/size)*5.0)-1.0);\n        int bit_index = pixel.y*5 + pixel.x;\n        int bit = (CHARS[character] >> (24 - bit_index))&1;\n        if(bit > 0)\n            return color;\n    }\n    return background;\n}\n\n#define EOL 0\n#define _ 0,\n#define A 1,\n#define B 2,\n#define C 3,\n#define D 4,\n#define E 5,\n#define F 6,\n#define G 7,\n#define H 8,\n#define I 9,\n#define J 10,\n#define K 11,\n#define L 12,\n#define M 13,\n#define N 14,\n#define O 15,\n#define P 16,\n#define Q 17,\n#define R 18,\n#define S 19,\n#define T 20,\n#define U 21,\n#define V 22,\n#define W 23,\n#define X 24,\n#define Y 25,\n#define Z 26,\n\n#define DOT 37,\n#define COMMA 38,\n#define BANG 39,\n#define QUESTION 40,\n\n#define EOL1 0\n#define EOL2 EOL1,EOL1\n#define EOL3 EOL2,EOL1\n#define EOL4 EOL3,EOL1\n#define EOL5 EOL4,EOL1\n#define EOL6 EOL5,EOL1\n#define EOL7 EOL6,EOL1\n#define EOL8 EOL7,EOL1\n#define EOL9 EOL8,EOL1\n#define EOL10 EOL9,EOL1\n#define EOL11 EOL10,EOL1\n#define EOL12 EOL11,EOL1\n#define EOL13 EOL12,EOL1\n#define EOL14 EOL13,EOL1\n#define EOL15 EOL14,EOL1\n#define EOL16 EOL15,EOL1\n#define EOL17 EOL16,EOL1\n#define EOL18 EOL17,EOL1\n#define EOL19 EOL18,EOL1\n#define EOL20 EOL19,EOL1\n#define EOL21 EOL20,EOL1\n#define EOL22 EOL21,EOL1\n#define EOL23 EOL22,EOL1\n#define EOL24 EOL23,EOL1\n#define EOL25 EOL24,EOL1\n#define EOL26 EOL25,EOL1\n#define EOL27 EOL26,EOL1\n#define EOL28 EOL27,EOL1\n#define EOL29 EOL28,EOL1\n#define EOL30 EOL29,EOL1\n\n#define LEN0 EOL30\n#define LEN1 EOL29\n#define LEN2 EOL28\n#define LEN3 EOL27\n#define LEN4 EOL26\n#define LEN5 EOL25\n#define LEN6 EOL24\n#define LEN7 EOL23\n#define LEN8 EOL22\n#define LEN9 EOL21\n#define LEN10 EOL20\n#define LEN11 EOL19\n#define LEN12 EOL18\n#define LEN13 EOL17\n#define LEN14 EOL16\n#define LEN15 EOL15\n#define LEN16 EOL14\n#define LEN17 EOL13\n#define LEN18 EOL12\n#define LEN19 EOL11\n#define LEN20 EOL10\n#define LEN21 EOL9\n#define LEN22 EOL8\n#define LEN23 EOL7\n#define LEN24 EOL6\n#define LEN25 EOL5\n#define LEN26 EOL4\n#define LEN27 EOL3\n#define LEN28 EOL2\n#define LEN29 EOL1\n#define LEN30 EOL0\n\nvec2 uv = vec2(0);\nfloat text_color = float(0.0);\nconst float TEXT_COLOR = float(0.95);\nconst float TEXT_SIZE = 0.03;\nconst float TEXT_SIZE2 = 0.03 + 0.04/5.0;\nvec2 TEXT_POSITION = vec2(0.0);\n\nvoid text(int LINE[directions*2]) {\n \tfor(int i = 0; i < (directions*2); i++)\n        text_color = character(TEXT_COLOR, text_color, LINE[i], vec2(0,1) + TEXT_POSITION*vec2(1,-1) + vec2(TEXT_SIZE2 * float(i), 0.), TEXT_SIZE, uv);\n}\n\n#define TEXT(x,y) text(int[](x y));\n#define TEXT2(x) text(x);\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 10) {\n        fragColor = vec4(0.0f, 1.0f/7.0f /*iniial selected bit*/, 0.0f, pack_rule());\n        return;\n    }\n    \n    uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 last = textureLod(iChannel0, uv, 0.0f).gb;\n  \n    int bit = int( last.x * 7.0f );\n    \n    bit = max(0, bit - int(texelFetch( iChannel1, ivec2(KEY_LEFT,1),0 ).x)); // press\n    bit = min(directions - 1, bit + int(texelFetch( iChannel1, ivec2(KEY_RIGHT,1),0 ).x)); // press\n    \n    // selector\n    TEXT_POSITION = vec2(0.195f, 0.9925f);\n    {\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        binary[bit * 2] = 20;\n\n        TEXT2(binary);\n        \n        text_color *= 1.0f - max(sin(iTime * 9.0f), 0.0f);\n    }\n    \n    // digits\n    TEXT_POSITION = vec2(0.195f, 0.97f);\n    {\n        float r = textureLod(iChannel0, uv, 0.0f).a;\n        unpack_rule(rule, r);\n        \n        int dir = 1;\n        dir = int(texelFetch( iChannel1, ivec2(KEY_UP,1),0 ).x);\n        rule[bit] |= dir;\n                \n        dir = int(texelFetch( iChannel1, ivec2(KEY_DOWN,1),0 ).x);\n        rule[bit] &= ~dir;\n        \n        const int select[2] = int[2]( 15, 9 );\n        int binary[directions * 2] = int[directions * 2](0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n\n        for (int n = 0 ; n < directions ; ++n) {\n            binary[n+n] = select[rule[n]];\n        }\n\n        TEXT2(binary);\n    }\n    \n        \n    uint last_resolution = floatBitsToUint(texelFetch(iChannel0, ivec2(0), 0).b);\n    uint current_resolution = uint(floor(length(iResolution.xy)));\n    \n    bool sgn = (current_resolution != last_resolution);\n    \n    float resolution_out = mix(-uintBitsToFloat(current_resolution), uintBitsToFloat(last_resolution), sgn);\n    \n    fragColor = vec4(text_color, float(bit) / 7.0f, resolution_out,\n                     pack_rule());\n}","name":"Buffer B","description":"","type":"buffer"}]}