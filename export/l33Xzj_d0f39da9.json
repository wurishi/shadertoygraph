{"ver":"0.1","info":{"id":"l33Xzj","date":"1719264395","viewed":365,"name":"Orange?","username":"bgolus","description":"Which labelled color matches the center orange?\n\nDoes your answer change when you hold down left mouse button and the outline is hidden?","likes":5,"published":1,"flags":0,"usePreview":1,"tags":["illusion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////////////////\n//                                                                        //\n//              ##      ##    ######    ##########  ########              //\n//              ####    ##  ##      ##      ##      ##                    //\n//              ##  ##  ##  ##      ##      ##      ####                  //\n//              ##    ####  ##      ##      ##      ##                    //\n//              ##      ##    ######        ##      ########              //\n//                                                                        //\n////////////////////////////////////////////////////////////////////////////\n//                                                                        //\n//   This shader is intentionally misleading about what it's testing.     //\n//                                                                        //\n////////////////////////////////////////////////////////////////////////////\n//                                                                        //\n// This is a recreation of a science museum exhibit I saw years ago was   //\n// testing color perception.                                              //\n//                                                                        //\n// In the original exhibit, there was a center orange light that had a    //\n// single wavelength (probably a sodium lamp) surrounded by a ring of     //\n// circles that were different mixes of two different wavelength lights,  //\n// one more red and one more yellow. The viewer was supposed to point at  //\n// which outer circle most closely matched the color of the center light. //\n// If you were by yourself, this wasn't terribly interesting. But if      //\n// there were multiple people around you'd find almost everyone pointed   //\n// to different circles!                                                  //\n//                                                                        //\n// This can't work the same way as that exhibit, but different people can //\n// still end up seeing a different circle as matching the center color    //\n// that others would.                                                     //\n//                                                                        //\n////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// \n// This shader is mostly testing what gamma your display uses\n//\n\nvec4 char(vec2 p, int c)\n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nfloat circle(vec2 p, float r)\n{\n    float d = length(p);\n    float f = length(vec2(dFdx(d), dFdy(d))) * 0.75;\n    \n    return smoothstep(r + f, r - f, d);\n}\n\nvec3 encodeSRGB(vec3 linearRGB)\n{\n    vec3 a = 12.92 * linearRGB;\n    vec3 b = 1.055 * pow(linearRGB, vec3(1.0 / 2.4)) - 0.055;\n    vec3 c = step(vec3(0.0031308), linearRGB);\n    return mix(a, b, c);\n}\n\n#define PI 3.14159265359\n#define TAU 6.28318530718\n\n#define CENTERRADIUS (minHalfDim*0.6)\n#define OUTERRADIUS (minHalfDim*0.153)\n#define OUTEROFFSET (minHalfDim*0.58)\n#define TEXTOFFSET (minHalfDim*0.72)\n#define FONTSIZE (minHalfDim*0.2)\n\n#define DITHER float((int(fragCoord.x) ^ int(fragCoord.y)) & 1)\n\n#define ORANGE vec4(0.75, 0.35, 0.0, 1.0)\n#define A1 vec4(1.0, 1.0, 0.0, 1.0)\n#define A2 vec4(0.5, 0.5, 0.0, 1.0)\n#define B1 vec4(0.5, 0.05, 0.0, 1.0)\n#define B2 vec4(1.0, -0.05, 0.0, 1.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfRes = iResolution.xy/2.0;\n    vec2 uv = fragCoord - halfRes;\n    \n    float minHalfDim = halfRes.x < halfRes.y ? halfRes.x : halfRes.y;\n    \n    fragColor = vec4(0);\n    \n    for (int index=1; index<12; index++)\n    {\n        float i = float(9 - index);\n        float angle = (TAU * (30.0/360.0)) * i;\n        float s = sin(angle);\n        float c = cos(angle);\n        \n        float t = float(index - 1) / 10.0;\n        \n        vec4 A = mix(A1, A2, t);\n        vec4 B = mix(B1, B2, t);\n        \n        vec4 col = mix(A, B, DITHER);\n        \n        mat2 rot = mat2(s, c, -c, s);\n    \n        fragColor += circle(rot * uv - vec2(0.0, OUTEROFFSET), OUTERRADIUS) * clamp(col, 0.0, 1.0);\n        \n        vec2 position = vec2(-FONTSIZE*0.5, TEXTOFFSET + .5);\n        vec2 U = ( rot * uv - position)*1.0/FONTSIZE;\n        vec4 letter = char(U, 64 + index);\n        fragColor += clamp((letter.x - 0.5) / max(fwidth(letter.x), 0.0001) + 0.5, 0.0, 1.0);\n    }\n    \n    float lineWidth = iMouse.z > 0.0 ? 0.0 : 1.5;\n    \n    float centerLine = circle(uv, CENTERRADIUS + lineWidth);\n    fragColor *= 1.0 - centerLine;\n    \n    float centerCircle = circle(uv, CENTERRADIUS - lineWidth);\n    fragColor += centerCircle * ORANGE;\n    \n    fragColor.xyz = encodeSRGB(fragColor.xyz);\n}","name":"Image","description":"","type":"image"}]}