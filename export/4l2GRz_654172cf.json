{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"//\n// Description : *Noise Factor*\n//      Author : lithozine (R.C.Hoetzlein, www.rchoetzlein.com)\n//     Lastmod : 2015-03-17\n//     License : Copyright (C) 2015 Creative Common Share Alike\n//   Attribute : Parts based on \"Array and textureless 3D noise\", by Ian McEwan, MIT License\n\n#define PERMUTE(x)  mod(((x*34.0)+1.0)*x, 289.0)\n\nfloat noise (in vec3 v)\n{   \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );  \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  i = mod(i, 289.0 ); \n  vec4 p = PERMUTE( PERMUTE( PERMUTE( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );  \n  vec4 s0 = floor(b0)*2.0 + 1.0;  \n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;  \n  vec3 p0 = vec3(a0.xy,h.x);\n  \n  return p0.y;\n}\n \n\nvec3 map( in vec3 p, float scale, vec3 trans )\n{\n\tfloat f = noise( (p-trans) * scale );    \n    float v1 = clamp( -p.x + f, 0.0, 1.0 );\t\t\t// half space\n    float v2 = clamp(  p.x -3.0 - f, 0.0, 1.0 );\t// ..the other half\n    return vec3(v1,v2,0);\n}\n\nvec4 integrate( in vec4 sum, in float dens, in vec3 pos, in float t, float side )\n{\n    // simple alpha blend\n    float a = 0.8;\n    vec4 clr;\n    clr = vec4(dens, dens, dens, 1.0);        \n    clr.rgb *= a;    \n    return sum + clr*(1.0-a);\n}\n\n// need lots of steps due to high freq\n#define STEPS 2000\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, float scale, vec3 trans )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.3;\n    for(int i=0; i<STEPS; i++) {\n        vec3 pos = ro + t*rd;\n        if ( sum.a > 0.99 ) break;\n        vec3 dens = map( pos, scale, trans );                 \n        if( dens.x > 0.0001 ) sum = integrate( sum, dens.x, pos, t,  1.0 );                 \n        if( dens.y > 0.0001 ) sum = integrate( sum, dens.y, pos, t, -1.0 );\n        t += max(0.005,0.005*t);    // small stepping due to high freq\n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float scale, vec3 trans )\n{\n    vec3 clr;\n    clr = raymarch( ro, rd, clr, scale, trans ).xyz;        \n    return clr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;  // no mouse interaction\n    \n    float time = float(iTime);\n    float t = (time*1.25) / 8.0;\n    float t2 = t*t;\t\t// time accelerates\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/ iResolution.y;    \n    \n    // camera\n    m.x  = 0.5 + sin ( t2*0.30 ) * (0.3 + time*0.002) ;\n    m.y  = 0.5 + cos ( t2*0.73 ) * 0.6;    \n    vec3 ro = 2.0*normalize(vec3(sin(3.0*m.x), 2.0*m.y-1.0, cos(3.0*m.x) ));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    // ray\n    vec3 rd = ca * normalize( vec3(p.xy,1.5));\n    \n    // scale & translate animation\n    float s = (cos (t2*0.2 )+1.0 )*200.0  + 5.0;\n    vec3 tr =  vec3( -ro.x, t, 0);\n    \n    float v = pow( render( ro, rd, s, tr ).x*5.0, 1.6);  // gamma & brightness correction\n    v = ( time > 55.0) ? v * (60.0-time)/5.0 : v;   // fade out\n    \n    fragColor = vec4(  v,v,v, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"outputs":[],"inputs":[],"code":"//\n// Description : *Noise Factor*\n//      Author : lithozine (R.C.Hoetzlein)\n//     Lastmod : 2015-03-17\n//     License : Copyright (C) 2015 Creative Common Share Alike\n//   Attribute : Parts based on \"Array and texturelss 3D noise\", by Ian McEwan, MIT License\n//\n\n#define PERMUTE(x)  mod(((x*34.0)+1.0)*x, 289.0)\n\nfloat noise(in vec3 v)\n{   \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );  \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  i = mod(i, 289.0 ); \n  vec4 p = PERMUTE( PERMUTE( PERMUTE( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n  vec4 b0 = vec4( x.xy, y.xy );  \n  vec4 s0 = floor(b0)*2.0 + 1.0;  \n  vec4 sh = -step(h, vec4(0.0));\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;  \n  vec3 p0 = vec3(a0.xy,h.x);\n  \n  return p0.y;\n}\n\n\nvec3 map( in vec3 p, float scale, vec3 trans )\n{\n\tfloat f = noise( (p-trans) * scale );\n    //float v = clamp( -p.x - 1.0 + 1.75*f, 0.0, 1.0 );\n    //float v = clamp( p.x + -scale*0.5 + f, 0.0, 1.0 );    \n    float v1 = clamp( -p.x + f, 0.0, 1.0 );\n    float v2 = clamp(  p.x -3.0 - f, 0.0, 1.0 );\n    return vec3(v1,v2,0);\n}\n\nvec4 integrate( in vec4 sum, in float dens, in vec3 pos, in float t, float side )\n{\n    float a = 0.8;\n    vec4 clr;\n    clr = vec4(dens, dens, dens, 1.0);        \n    clr.rgb *= a;      \n    float d = sqrt(pos.y*pos.y+pos.z*pos.z) / 10.0;\n    //clr.rgb *= 0.8 + 0.2/d;\n    return sum + clr*(1.0-a);\n}\n\n#define STEPS 2000\n\nvec4 raymarch( in vec3 ro, in vec3 rd, in vec3 bgcol, float scale, vec3 trans )\n{\n\tvec4 sum = vec4(0.0);\n\n\tfloat t = 0.3;\n    for(int i=0; i<STEPS; i++) {\n        vec3 pos = ro + t*rd;\n        if ( sum.a > 0.99 ) break;\n        vec3 dens = map( pos, scale, trans );                 \n        if( dens.x > 0.0001 ) sum = integrate( sum, dens.x, pos, t,  1.0 );                 \n        if( dens.y > 0.0001 ) sum = integrate( sum, dens.y, pos, t, -1.0 );\n        t += max(0.005,0.005*t); \n    }\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 render( in vec3 ro, in vec3 rd, float scale, vec3 trans )\n{\n    vec3 clr;\n    clr = raymarch( ro, rd, clr, scale, trans ).xyz;        \n    return clr;\n}\n\nvec3 pow3 ( vec3 v, float p )\n{    \n   return vec3( pow(v.x,p), pow(v.y,p), pow(v.z,p) );\n}\n\nvec2 mainSound ( in int samp, float time )\n{  \n    float t = float( time*1.25 ) / 8.0;\n    float t2 = t*t;    \n        \n    // camera\n    vec2 m;\n    m.x  = 0.5 + sin ( t2*0.30 ) * (0.3 + time*0.002) ;\n    m.y  = 0.5 + cos ( t2*0.73 ) * 0.6;    \n    vec3 ro = 2.0*normalize(vec3(sin(3.0*m.x), 2.0*m.y-1.0, cos(3.0*m.x) ));    \n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    // ray left & right - scan sound synthesis    \n    vec3 rdleft = ca * normalize( vec3(time*2200.0, 0.4, 1.5));\n    vec3 rdrght = ca * normalize( vec3(time*2200.0, 0.6, 1.5));\n    \n    // scale & translate animation\n    float s = (cos (t2*0.2 )+1.0 )*200.0  + 5.0;    \n    vec3 tr =  vec3( -ro.x, t, 0);\n    \n    float left = render( ro, rdleft, s, tr ).x;\n    float right = render( ro, rdrght, s, tr ).x;\n    left = ( time > 55.0) ? left * (60.0-time)/5.0 : left;\n    right = ( time > 55.0) ? right * (60.0-time)/5.0 : right;\n    \n\treturn vec2(left, right);\n}\n","name":"Sound","description":"","type":"sound"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":true,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4l2GRz","date":"1426658910","viewed":220,"name":"[NV15] Noise Factor","username":"lithozine","description":"..Noise Factor.. by lithozine.\nGTC 2015, Shadertoy Hackathon.. Enjoy.\n\nOnly request.. extend the internal sound time limit beyond 60 sec :)\n2014-Aug-1, \"..the play time is limited to 60 seconds for now. It's not a bug, but a feature.\" -iq\n","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["noise","blackwhite","nv15"],"hasliked":0,"parentid":"","parentname":""}}