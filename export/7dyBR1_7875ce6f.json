{"ver":"0.1","info":{"id":"7dyBR1","date":"1657658135","viewed":152,"name":"Mandelbox Wall Tattoos","username":"pb","description":"Tunnelling (or rather bubbling) through the good old mbox, coloring as we go.  Watch for the death star at the beginning.  Gotta love \"sphere  folds\"","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["3d","fractal","colorful","mandelbox"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n   \n   \n    fragColor = total_color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//philip.bertani@gmail.com\n\nvec3  ro, ifs_color, light_direction;\nfloat max_iter, normal_expand;\nfloat params[9] = float[9] (0.66,0.,0.,2.6,0.,0.,0.,0.,0.);\n\nmat3 rot_xz_yz(float a1, float a2) {\n    //rotation matrices - can't live with'em, can't live without'em\n    float c1=cos(a1),c2=cos(a2),s1=sin(a1),s2=sin(a2);\n    return mat3(    c1, 0.,    -s1,\n                -s2*s1, c2, -s2*c1,\n                 c2*s1, s2,  c2*c1 );\n}\n\n\nfloat mbox (vec3 p)\n{\n    ifs_color = vec3(0.);\n    vec4 offset=vec4(p,1.), v=offset;\n  \n    float n=0.;\n    for (; n<200.;n++) {\n\n        v.xyz = clamp (v.xyz, -1.-params[0], 1.+params[0]) * (2.+params[1]) \n                - (1.+params[2])*v.xyz;\n\n\n        v = v * params[3] / clamp (dot (v.xyz, v.xyz), (.2+params[4])-params[5], 1.+params[5]) + offset;\n   \n        if (v.x*v.y > 0. ) ifs_color.x ++;\n        if (v.y*v.z > 0. ) ifs_color.y ++;\n        if (v.z*v.x > 0. ) ifs_color.z ++;  \n\n        if ( n > max_iter ) break;   //allow for variable # of iterations\n    }\n\n    ifs_color /= n;\n  \n    return length (v.xyz) / v.w ;\n}\n\nfloat all_objects(vec3 p) {\n    //the second part of the max keeps us inside a hollow sphere so we can see stuff\n    //when we are buried inside with no clear path\n    return max( mbox(p), -(length(p-ro)-.3)  );\n}\n\nvec3 gradient(vec3 p) {\n\n    float normal_dist_expand = 0.; //function of distance, not used yet\n    vec2 dpn = vec2(1.,-1.);\n    vec2 dp  = (.001 + normal_expand + normal_dist_expand) * dpn; \n\n    vec3 df = dpn.xxx * all_objects(p+dp.xxx) +\n              dpn.yyx * all_objects(p+dp.yyx) +\n              dpn.xyy * all_objects(p+dp.xyy) +\n              dpn.yxy * all_objects(p+dp.yxy);\n\n    return normalize(df); \n\n}\n\n\nvec3 color(vec3 p, vec3 rd, float dist, float totdist) {\n\n    vec3 nv = gradient(p);\n\n    vec3 color = vec3(  ifs_color.x*cos(ifs_color.x*params[6]),\n                        ifs_color.y*cos(ifs_color.y*params[7]),\n                        ifs_color.z*cos(ifs_color.z*params[8]) );\n                        \n                               \n    color = 1.25*normalize(color);\n\n    color = 1.  - exp(-color*color);\n\n    color = color *  1.2* max (0., dot (nv, -light_direction))  \n            + .4*pow ( max (0., dot (-light_direction, reflect (rd, nv))), 8. );\n\n\n    color *= exp(-totdist*totdist/20.);\n    return color;\n}\n\nvoid mainImage( out vec4 rgba, in vec2 xy )\n{\n\n    float tt = 5. + mod(iTime,30.);\n    \n    xy = (2.*xy - iResolution.xy)/iResolution.y;\n    \n    ro = vec3(.2,.3,6.);\n    max_iter = 7.;\n    normal_expand = 0.;\n    \n    mat3 rot = rot_xz_yz(tt/70.,tt/90.);\n    vec3 rd = rot* normalize(vec3(xy,-2.));\n    \n    ro -= rot[2] * tt/7.;\n    light_direction = normalize(-rot[2]+vec3(0.,.5,0.));  //3rd column is the new \"z\" axis\n    \n    vec3  p=ro;\n    float dist,totdist;\n    float eps = 3e-4, hit_threshold=eps;\n\n    float distfac = 30.;\n    vec3  rgb = vec3(0.);\n    \n    for (float f=0.; f<100.; f++) {\n    \n        dist = all_objects(p);\n        \n        if ( dist < hit_threshold ) { rgb = color(p, rd, dist, totdist); break; }\n        \n        float stepsize = dist*(.5 + .01*totdist);\n        p += rd*stepsize;\n        \n        totdist += stepsize;\n        \n        hit_threshold = eps*(1.+totdist*distfac);\n    \n    }\n    \n    rgba = vec4( rgb,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}