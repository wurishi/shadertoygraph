{"ver":"0.1","info":{"id":"ddtGz8","date":"1677236934","viewed":207,"name":"colormaps switching","username":"HaleyHalcyon","description":"colormap() maps values from 0 to 1 to a cyclic color map that was created based on Viridis and Magma from Matplotlib. c() folds the “brightness” value between 0 and 0.5, then applies an offset to switch between halves of the colormap based on time.","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["sasasa"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// set to 0 to make colors buttery-smooth\n// set to 1 to dither colors (for GIF export)\n#define DITHER 1\n\n// generate an ordered dithered pattern based on pixel coordinates\n#if DITHER == 1\nfloat crosshatch(vec2 xyf) {\n    ivec2 xy = ivec2(xyf) & 3;\n    return (float(\n        + ((xy.y >> 1) & 1)\n        + ((xy.x & 2) ^ (xy.y & 2))\n        + ((xy.y & 1) << 2)\n        + ((((xy.x) & 1) ^ (xy.y & 1)) << 3)\n    ) + 0.5) / 16.;\n}\n#endif\n\nconst float TURN = acos(-1.) * 2.;\n// rotation matrix\n#define ROT(x) mat2x2(cos(TURN * (x + vec4(0, 0.25, -0.25, 0))))\n// converts colors from hex code to vec3\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n// “zigzag” value between 0 and 1\n#define ZIG(x) (1. - abs(1. - fract(x) * 2.))\n\n// convert float in range [0, 1) to a color based on a colormap\nvec3 colormap(float x){\n    const int colorCount = 16;\n    vec3[] c = vec3[](\n        HEX(0xfaf875),\n        HEX(0xfcfc26),\n        HEX(0xbcde26),\n        HEX(0x5CC863),\n        \n        HEX(0x1FA088),\n        HEX(0x33638D),\n        HEX(0x3D4285),\n        HEX(0x1F0269),\n        \n        HEX(0x25024D),\n        HEX(0x430787),\n        HEX(0x6F00A8),\n        HEX(0x9814A0),\n        \n        HEX(0xC23C81),\n        HEX(0xF07F4F),\n        HEX(0xFDB22F),\n        HEX(0xFAEB20)\n    );\n    x *= float(colorCount);\n    int lo = int(floor(x));\n    \n    return mix(\n        c[lo],\n        c[(lo + 1) % colorCount],\n        fract(x)\n        //smoothstep(0.0, 1., fract(x))\n    );\n}\n\n/*\n// spectrum for testing\nvec3 spec(float x) {\n    x *= 3.;\n    return vec3(\n        smoothstep(0., 0.5, x) - smoothstep(1.5, 2., x),\n        smoothstep(1., 1.5, x) - smoothstep(2.5, 3., x),\n        smoothstep(2., 2.5, x) + smoothstep(1., 0.5, x)\n    );\n}\n*/\n\n// generate the color based on\n// the 2D vector, dithering threshold, and time\nvec3 c(vec2 ab, float thres, float t) {\n    float x = fract(atan(ab.x, ab.y) / TURN);\n    // time offset\n    x = fract(((\n        1. + 6. * ZIG(x) + 8. * (\n            smoothstep(0.0,0.25,t)+\n            smoothstep(0.5,0.75,t)\n        )) / 16.)\n    );\n#if DITHER == 1\n    const float STEPS = 16.;\n    x = fract((\n        floor(x * STEPS) +\n        step(thres, fract(x * STEPS))\n    ) / STEPS);\n#endif\n    return colormap(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = fract(iTime / 4.);\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float r = log(length(uv));\n    float theta = atan(uv.y, uv.x) / TURN;\n\n    // calculate temporary “colors” as 2D vectors\n    // then use its angle from center to map to a colormap\n    \n    // first calculate the angle from the center\n    float z = (\n        -0.4 * r +\n        0.8 * sin(\n            1.5 * r +\n            1. * t * TURN\n        ) +\n        5. * theta +\n        1. * t\n    ) * TURN;\n    \n    // double pendulum kinda thing\n    // go 0.45 to the right, rotate a 0.4 unit arm by z\n    // then rotate the whole thing\n    vec2 ab = vec2(\n        0.45 + 0.4 * cos(z),\n        0.0 + 0.4 * sin(z)\n    ) * ROT(\n        0.9 * r + \n        -1. * theta +\n        -1. * t\n    );\n    \n#if DITHER == 1\n    float thres = crosshatch(fragCoord);\n#else\n    float thres = -1.;\n#endif\n    vec3 col = c(ab, thres, fract(t + 0.45));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}