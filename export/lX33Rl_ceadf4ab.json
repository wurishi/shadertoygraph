{"ver":"0.1","info":{"id":"lX33Rl","date":"1716895472","viewed":92,"name":"Miller's 2D wave diffraction","username":"Urbanowicz","description":"Intensity of steady-state monochromatic wave going from point source (not visible) through narrow slit.\nBlue pixels are negative numbers (integration error).\nMade after ideas from \"Huygen's wave propagation principle corrected\" (David A. B. Miller).","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["wavediffraction"],"hasliked":0,"parentid":"XXd3zX","parentname":"Exact spatio-temporal dipole wav"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 fromLinear(vec3 linearRgb) {\n    bvec3 cutoff = lessThan(linearRgb, vec3(0.0031308));\n    vec3 higher = vec3(1.055) * pow(linearRgb, vec3(1.0 / 2.4)) - vec3(0.055);\n    vec3 lower = linearRgb * vec3(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvec3 colorize(float u) {\n    return clamp(vec3(u, 0, -u), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 u = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0);\n    fragColor = vec4(fromLinear(colorize(u.r / u.a)), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void rnd_init() {\n    rnd_seed = hash2(uvec3(gl_FragCoord.xy, iFrame));\n}\n\nvec3 s(vec2 p, vec2 c, vec2 xy) {\n    xy -= c;\n    float r2 = dot(xy, xy);\n    float r = sqrt(r2);\n    float att = 1.0 / sqrt(r); // wave propagates in 2D space only, so its power (amplitude squared) should be 1/r\n    float u = sin(p.x*(r + p.y)) * att;\n    return vec3(isnan(u) ? 0.0 : u, isnan(att) || isinf(att) ? 0.0 : att, r);\n}\n\nconst float freq = 4e3;\n\nfloat itg(vec2 xy, float time) {\n    float slitSize = 1e-1;\n    vec2 slit = vec2(0, (rnd_uniform() - 0.5) * slitSize + 0.5);\n    vec3 source = s(vec2(freq, time), vec2(-0.5, 0.5), slit);\n    return source.y * (\n        s(vec2(freq, source.z), slit, xy).r\n        - s(vec2(freq, source.z + 1e-5), slit - 1e-5 * normalize(slit - vec2(-0.5, 0.5)), xy).r // dipole source correction\n    ) * slitSize * 2e2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    rnd_init();\n    vec4 prev = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0);\n\n    for (int i = 0; i < 10; i++) {\n        vec2 xy = (gl_FragCoord.xy + rnd_normal()) / iResolution.y;\n        xy.x -= 0.1 * iResolution.x / iResolution.y;\n        float time = rnd_uniform();\n\n        prev.r += itg(xy, time) * itg(xy, time); // unbaisedly estimating wave energy at given point over time\n        prev.a += 1.0;\n    }\n\n    fragColor = prev;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// http://www.burtleburtle.net/bob/c/lookup3.c\n#define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))\n\n#define final(a,b,c) \\\n{ \\\n    c ^= b; c -= rot(b,14); \\\n    a ^= c; a -= rot(c,11); \\\n    b ^= a; b -= rot(a,25); \\\n    c ^= b; c -= rot(b,16); \\\n    a ^= c; a -= rot(c,4);  \\\n    b ^= a; b -= rot(a,14); \\\n    c ^= b; c -= rot(b,24); \\\n}\n\nuint hash2(uvec3 v) {\n    uvec3 i = uvec3(0xdeadbeefu + (2u<<2u) + v.z);\n\n    i.xy += v.xy;\n    final(i.x, i.y, i.z);\n    return i.z;\n}\nuint hash0(uint initval) {\n    uvec3 i = uvec3(0xdeadbeefu + (0u<<2u) + initval);\n\n    final(i.x, i.y, i.z);\n    return i.z;\n}\n// http://www.burtleburtle.net/bob/c/lookup3.c\n\n// Construct a float with half-open range [0:1] using low 23 bits.\n// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\nfloat floatConstruct( uint m ) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat( m );       // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nuint rnd_seed;\n\nfloat rnd_uniform() {\n    rnd_seed = hash0(rnd_seed);\n    return floatConstruct(rnd_seed);\n}\n#define PI 3.1415926535897932384626433\nvec2 rnd_normal() {\n    float phi = 2.0 * PI * rnd_uniform();\n    return sqrt(-2.0 * log(rnd_uniform())) * vec2(cos(phi), sin(phi));\n}\n","name":"Common","description":"","type":"common"}]}