{"ver":"0.1","info":{"id":"wsXSWj","date":"1552230839","viewed":103,"name":"Ray marching. Apocalypse.","username":"kirillserious","description":"First task of computer graphic course on CS MSU.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"///////////////////////////////////////////////////////////////\n///                                                         ///\n///                   Важные константы                      ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Константы */\nfloat EPS        = 0.01;                  // Эпслилон пересечений\nfloat MAX_VIEW   = 500.;                  // Максимальный обзор\nvec3  STD_BRIGHT = vec3(0.1, 0.1, 0.1);   // Яркость дневного цвета\nfloat SHADOW     = 10.;                   // Твёрдость тени\nfloat MIN_STEP   = 0.01;                  // Минимальный шаг\n\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                Фигура. Работа с фигурами.               ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\nconst int FIGURE_NUMBER = 5; // Количество фигур\n\n/* Определение класса фигуры и массива figures */\nconst int FIG_SPHERE     = 1;\nconst int FIG_UDROUNDBOX = 2;\nconst int FIG_PLANE      = 3;\nconst int FIG_ELLIPSE    = 4;\nconst int FIG_TORUS      = 5;\n\nstruct Figure {\n    int  type;  // Тип фигуры\n    vec3 point; // Точка фигуры\n    vec3 color; // Цвет фигуры\n    \n    // koeffs.x - specular reflection constant\n    // koeffs.y - diffuse reflection constant\n    // koeffs.z - ambient reflection constant\n    // koeffs.w - shininess constant\n    // Считаем, что коэффициенты для R, G и В равны, потому что лень придумывать случаи, когда это не так.\n    // И что у всей фигуры эи коэффициенты постоянны -- поэтому же.\n    vec4 koeffs;\n    float reflection; // Коэффициент отражения \n};\nFigure[FIGURE_NUMBER] figures;\n\n/* Цвет фигуры */\nvec3\ngetFigureColor(vec3 point,\n               int  fig)\n{\n    Figure figure = figures[fig];\n    switch (figure.type) {\n    case FIG_SPHERE:\n    case FIG_UDROUNDBOX:\n    case FIG_ELLIPSE:\n    case FIG_TORUS:\n        return figure.color;\n    case FIG_PLANE:\n        float x = mod(point.x, 20.);\n        float z = mod(point.z, 20.);\n        if ((x > 10. && z > 10.) || (x < 10. && z < 10.)) {\n        \treturn figure.color;\n        } else {\n        \treturn 0.8 * figure.color;\n        }\n    }\n}\n\n/* Расстояние до фигуры */\nfloat\ngetDist (int  fig,\n         vec3 point)\n{\n    Figure figure = figures[fig];\n\tvec3 p = figure.point - point;\n    \n    switch (figure.type) {\n   \tcase FIG_SPHERE:\n    \tfloat radius = 5.;\n    \n    \treturn length(p) - radius;\n    \n    case FIG_UDROUNDBOX:\n        vec3 b = vec3(3., 3.*sin(iTime) + 4., 3.);\n    \tfloat r = 1.;\n  \t\n    \treturn length(max(abs(p)-b,0.0))-r;\n        \n    case FIG_PLANE:\n  \t\tvec3 bb = vec3(500., 1., 500.);\n        \n        vec3 d = abs(p) - bb;\n  \t\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\n    case FIG_ELLIPSE:\n        vec3 rr = vec3(10., 15., 20.);\n        vec3 cc = vec3(1., 3., 8.);\n        float ellipse = (length( p/rr ) - 1.0) * min(min(rr.x,rr.y),rr.z);\n    \tfloat cilindr = length(p.xz-cc.xy)-cc.z;\n        return max(-cilindr, ellipse);\n    \n    case FIG_TORUS:\n        vec2 tt = vec2(15., 2.);\n        vec2 q = vec2(length(p.xz)-tt.x,p.y);\n  \t\tfloat torus = length(q)-tt.y;\n        float problem = sin(100.*p.x)*sin(100.*p.y)*sin(100.*p.z);\n        return torus + problem;\n    }\n}\n\n/* Нормаль фигуры в точке */\nvec3\ngetNormal (int  fig,\n           vec3 point)\n{\n\tvec3 z1 = point + vec3(EPS, 0, 0);\n \tvec3 z2 = point - vec3(EPS, 0, 0);\n \tvec3 z3 = point + vec3(0, EPS, 0);\n \tvec3 z4 = point - vec3(0, EPS, 0);\n \tvec3 z5 = point + vec3(0, 0, EPS);\n \tvec3 z6 = point - vec3(0, 0, EPS);\n \tfloat dx = getDist(fig, z1) - getDist(fig, z2);\n \tfloat dy = getDist(fig, z3) - getDist(fig, z4);\n \tfloat dz = getDist(fig, z5) - getDist(fig, z6);\n \treturn normalize(vec3(dx, dy, dz));\n}\n\n/* Самая близкая фигура и расстояие до неё */\nstruct Dist \n{\n\tfloat dist;\n    int   fig;\n};\nDist\ngetMinDist (vec3 point)\n{\n\tfloat min_dist = getDist(0, point);\n    int   fig      = 0;\n    for (int cur_fig = 1; cur_fig < FIGURE_NUMBER; ++cur_fig) {\n        float dist = getDist(cur_fig, point);\n        if (dist < min_dist) {\n         \tmin_dist = dist;\n            fig      = cur_fig; \n        }\n    }\n    Dist result;\n    result.dist = min_dist;\n    result.fig  = fig;\n    return result;\n}\n    \n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                    Источник света.                      ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\nconst int LIGHT_NUMBER = 3;\n\n/* Определение класса источника света и массива lights */\nstruct Light {\n    vec3 point;\n    vec3 bright;\n};\nLight[LIGHT_NUMBER] lights;\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                 Пересечение с фигурой.                  ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n\n/* Структура пересечения */\nstruct Hit\n{\n    bool  is_hit;  // Было ли попадание в фигуру\n\tvec3  point;   // Точка попадания\n    int   fig;     // Фигура, в которую попали\n    float dist;    // Расстояние до фигуры\n};\n\n/* Поиск пересечения */\nHit\ngetHit (vec3 ray_point,\n        vec3 ray_dir)\n{\n    Hit result;\n    while (true) {\n        Dist  dist     = getMinDist(ray_point);\n        float min_dist = dist.dist;\n        int   fig      = dist.fig;\n    \t\n        /* Слишком далеко ушли */\n        if (length(ray_point) > MAX_VIEW) {\n         \tresult.is_hit = false;\n            result.point = ray_point;\n            return result;\n        }\n            \n        /* Попали в фигуру */\n        if (min_dist < EPS) {\n         \tresult.is_hit = true;\n            result.point  = ray_point;\n            result.fig    = fig;\n            result.dist   = min_dist;\n            return result;\n        }\n        /* Увеличиваем луч */\n        if (min_dist < MIN_STEP) {\n        \tray_point = ray_point + MIN_STEP * ray_dir;\n        }\n        ray_point = ray_point + min_dist * ray_dir;        \n    }\n}\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                  Освещение фигуры.                      ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Интенсивность света в точке по модели Фонга */\nvec3\ngetPhong (vec3 point,\n          vec3 light_point,\n          vec3 eye_point,\n          vec3 bright,\n          int  fig)\n{\n\tFigure figure = figures[fig];\n    \n    vec3 normal_dir  = getNormal(fig, point);\n    vec3 light_dir   = normalize(light_point - point);\n    vec3 eye_dir     = normalize(eye_point - point);\n    vec3 reflect_dir = normalize(reflect(-light_dir, normal_dir));\n    \n    float dotLN = dot(light_dir,  normal_dir);\n    float dotRE = dot(reflect_dir, eye_dir);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }     \n    if (dotRE < 0.0) {\n        return bright * (figure.koeffs.y * dotLN);\n    }\n    return bright * (figure.koeffs.y * dotLN + figure.koeffs.x * pow(dotRE, figure.koeffs.w));\n\n}\n\n/* Коэффициент тени */\nfloat\ngetShadow (vec3 point,\n           vec3 light_point)\n{\n    vec3  light_dir = normalize(light_point - point);    \n    float maxt      = length(light_point - point) + 10.*EPS;\n    float t         = 100. * EPS;\n    float phi       = EPS;\n    \n    float result = 1.0;\n    while (t < maxt)\n    {\n        vec3 cur_point = point + t*light_dir;\n    \tDist dist = getMinDist(cur_point);\n        float min_dist = dist.dist;\n        \n        if (min_dist < EPS) {\n        \treturn 0.;\n        }\n        \n        float y = min_dist*min_dist/(2.0*phi);\n        float d = sqrt(min_dist*min_dist - y*y);\n        result  = min(result, SHADOW*d/max(0., t - y));\n        \n        phi = min_dist;\n        t  += (min_dist < MIN_STEP)? MIN_STEP : min_dist;\n        \n    }\n    return result;\n}\n\n/* Цвет точки */\nvec3\ngetColor (vec3 point, \n          vec3 eye_point, \n          vec3 color, \n          int  fig)\n{\n    Figure figure = figures[fig];\n    \n    vec3 result = figure.koeffs.x * STD_BRIGHT;\n    \n    for (int i = 0; i < LIGHT_NUMBER; ++i) {\n        Light light = lights[i];\n        float shadow = getShadow(point, light.point);\n        vec3 phong  = getPhong(point, light.point, eye_point, light.bright, fig);\n        result += shadow * phong / (length(point - light.point) / 80.);    \n    } \n    return result * color;\n}\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                     Цвет фона.                          ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Белый шум из Интернета */\nfloat rand2D(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n/* Белый шум из Интернета для звёзд */\nfloat dotNoise2D(in float x, in float y, in float fractionalMaxDotSize, in float dDensity)\n{\n    float integer_x = x - fract(x);\n    float fractional_x = x - integer_x;\n\n    float integer_y = y - fract(y);\n    float fractional_y = y - integer_y;\n\n   \tif (rand2D(vec2(integer_x+1.0, integer_y +1.0)) > dDensity)\n      \t{return 0.0;}\n\n    float xoffset = (rand2D(vec2(integer_x, integer_y)) -0.5);\n    float yoffset = (rand2D(vec2(integer_x+1.0, integer_y)) - 0.5);\n    float dotSize = 0.5 * fractionalMaxDotSize * max(0.25,rand2D(vec2(integer_x, integer_y+1.0)));\n\n   \tvec2 truePos = vec2 (0.5 + xoffset * (1.0 - 2.0 * dotSize) , 0.5 + yoffset * (1.0 -2.0 * dotSize));\n\n   \tfloat distance = length(truePos - vec2(fractional_x, fractional_y));\n\n   \treturn 1.0 - smoothstep (0.3 * dotSize, 1.0* dotSize, distance);\n\n}\n\n/* Цвет фона. Белый шум + подходящие параметры. */\nfloat getBackgroundColor(vec2 coord)\n{\n    float wavelength = 0.003;\n    float fractionalMaxDotSize = 100.;\n    float dDensity = 0.01;\n    return dotNoise2D(coord.x/wavelength, coord.y/wavelength, fractionalMaxDotSize, dDensity);\n}\n\n\n///////////////////////////////////////////////////////////////\n///                                                         ///\n///                Начальные точки и векторы.               ///\n///                                                         ///\n///////////////////////////////////////////////////////////////\n\n/* Матрицы поворота */\nstruct Rotate\n{\n\tmat3 x;\n    mat3 y;\n};\n\nRotate\ngetRotate (float x, float y, float eye_dist)\n{\n\tfloat y_hypotenuse = sqrt(x*x + eye_dist*eye_dist);\n    float y_cos = eye_dist / y_hypotenuse;;\n    float y_sin = - x / y_hypotenuse;\n    mat3  y_mat = mat3(1.);\n    y_mat[0][0] =  y_cos;\n    y_mat[0][2] =  y_sin;\n    y_mat[2][0] = -y_sin;\n    y_mat[2][2] =  y_cos;\n    \n    float x_hypotenuse = sqrt(y*y + eye_dist*eye_dist);\n    float x_cos = eye_dist / x_hypotenuse;;\n    float x_sin = y / x_hypotenuse;\n    mat3  x_mat = mat3(1.);\n    x_mat[1][1] =  x_cos;\n    x_mat[2][1] =  x_sin;\n    x_mat[1][2] = -x_sin;\n    x_mat[2][2] =  x_cos;\n    \n    Rotate result;\n    result.x = x_mat;\n    result.y = y_mat;\n    return result;\n}\n\n/* Направление первых лучей */\nstruct StartRays\n{\n\tvec3 point;\n    vec3 dir;\n    vec3 eye_point;\n};\n    \nStartRays\ngetStart (float x,\n          float y,\n          float screen_width,\n          float screen_height)\n{\n\tStartRays start;\n    \n    /* Будем считать оси из центра экрана */\n    float screen_x = x - screen_width / 2.0;\n    float screen_y = y - screen_height / 2.0;\n    \n    /* Задали начальный луч */\n    start.point = vec3(10.* screen_x/screen_width,\n                            10.* screen_y/screen_width,\n                            10.);\n    start.dir   = normalize(start.point);\n    \n    /* Меняем направление, в зависимости от мышки */\n    float mouse_x = iMouse.x - screen_width / 2.0;\n    float mouse_y = iMouse.y - screen_height / 2.0;\n    \n    Rotate rotate = getRotate (mouse_x, mouse_y, screen_width);\n    \n    start.point = rotate.x * rotate.y * start.point;\n    start.dir   = rotate.x * rotate.y * start.dir;\n    \n    start.eye_point  = vec3(0., 0., 0.);\n    \n    return start;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ////////////////////////////////////////////////////////////\n\t///                                                      ///\n\t///            Положение фигур и источников света.       ///\n\t///                                                      ///\n\t////////////////////////////////////////////////////////////\n    \n    figures[0].type   = FIG_SPHERE;\n    float v0z  = 2.;\n    float v0x  = -1.;\n    float v0y  = 20.;\n    float g    = 9.8;\n    float time = mod(iTime, 2.*v0y/g);\n    figures[0].point  = vec3(15. + v0x * iTime,-4. - g * time*time/2. + v0y*time, 30. + v0z*iTime);\n    figures[0].color  = vec3(1., 0., 0.);\n    figures[0].koeffs = vec4(0.4, 0.8, 0.5, 3);\n    figures[0].reflection = 0.;\n    \n    figures[1].type   = FIG_UDROUNDBOX;\n    figures[1].point  = vec3(-30., 0., 80.);\n    figures[1].color  = vec3(1., 1., 1.);\n    figures[1].koeffs = vec4(0.2, 0.6, 0.3, 1);\n    figures[1].reflection = 0.;\n    \n    figures[2].type   = FIG_PLANE;\n    figures[2].point  = vec3(0., -10., 100.);\n    figures[2].color  = vec3(0., 1., 0.);\n    figures[2].koeffs = vec4(0.4, 0.3, 0.3, 6);\n    figures[2].reflection = 0.1;\n    \n    figures[3].type   = FIG_ELLIPSE;\n    figures[3].point  = vec3(30., 20., 60.);\n    figures[3].color  = vec3(0., 1., 1.);\n    figures[3].koeffs = vec4(0.4, 0.5, 0.3, 0.5);\n    figures[3].reflection = 0.3;\n    \n    figures[4].type   = FIG_TORUS;\n    figures[4].point  = vec3(-50., 20., 60.);\n    figures[4].color  = vec3(1., 0., 1.);\n    figures[4].koeffs = vec4(0.4, 0.5, 0.3, 0.5);\n    figures[4].reflection = 0.;\n    \n    lights[0].point  = vec3(30., 100., 40.*sin(iTime));\n    lights[0].bright = vec3(0.9, 0.9, 0.9);\n    \n    lights[1].point  = vec3(-10.*sin(iTime), 25. + 10.*sin(iTime), 90.*sin(iTime));\n    lights[1].bright = vec3(0.5, 0.5, 0.5);\n    \n    lights[2].point  = vec3(-10., 10., 2.);\n    lights[2].bright = vec3(0.9, 0.9, 0.9) * abs(sin(1. + 0.25*iTime));\n\n    \n    ////////////////////////////////////////////////////////////\n\t///                                                      ///\n\t///                     Алгоритм.                        ///\n\t///                                                      ///\n\t////////////////////////////////////////////////////////////\n    \n    StartRays start = getStart(fragCoord.x, fragCoord.y, iResolution.x, iResolution.y);\n    vec3 ray_point = start.point;\n    vec3 ray_dir   = start.dir;\n    vec3 eye_point = start.eye_point;\n    \n    /* Первый луч */\n    Hit hit    = getHit(ray_point, ray_dir);    \n    if (!hit.is_hit) {\n    \tfragColor = vec4(getBackgroundColor(hit.point.xz) * vec3(1.), 1.);\n        return;\n    }\n    \n    /* Отражение */\n    int  fig    = hit.fig;\n    vec3 point  = hit.point;\n    vec3 color = getFigureColor(point, fig);\n    Figure figure = figures[fig];\n    \n    if (figure.reflection < EPS) {\n    \tcolor = getColor(point, eye_point, color, fig);\n        fragColor = vec4(color, 1.);\n        return;\n    }\n        \n    vec3 normal      = getNormal(fig, point);\n    vec3 reflect_dir = normalize(reflect(ray_dir, normal));\n    \n    hit = getHit(hit.point+10.*EPS*reflect_dir, reflect_dir);\n    if (!hit.is_hit) {\n    \tcolor = figure.reflection * getBackgroundColor(hit.point.xz) * vec3(1.) +\n            (1. - figure.reflection) * color;\n    } else {\n    \tcolor = figure.reflection * getColor(hit.point, eye_point, getFigureColor(hit.point, hit.fig), hit.fig)       +      (1. - figure.reflection) * color;\n    }\n    \n    color = getColor(point, eye_point, color, fig);\n    \n    fragColor = vec4(color, 1.);\n       \n}","name":"Image","description":"","type":"image"}]}