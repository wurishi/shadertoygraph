{"ver":"0.1","info":{"id":"ddX3Wj","date":"1666795029","viewed":98,"name":"Raytracing - Diffuse","username":"bittermandel","description":"Raytracing with diffuse material","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_FLOAT 1e5\n#define SAMPLES_PER_PIXEL 100.\n#define MAX_RECURSION 6\n\n\nbool raycast(const in Ray r, inout Hit h, inout Sphere[2] spheres)\n{\n    bool didHit = false;\n    float t_max = MAX_FLOAT;\n    \n    didHit = hit(r, spheres[1], 0.001, t_max, h) || didHit;\n    if (didHit)\n    {\n        float t_max = h.t;\n    }\n    didHit = hit(r, spheres[0], 0.001, t_max, h) || didHit;\n    \n    return didHit;\n}\n\nvec3 rayColor(Ray r, inout Sphere[2] spheres, vec2 seed)\n{\n    Hit rec;    \n    vec3 col = vec3(1.0);\n    vec3 rand = randomInUnitSphere(seed);\n\n    for(int i=0; i < MAX_RECURSION; i++){\n        bool didHit = raycast(r, rec, spheres);\n        seed += float(i);\n        if (didHit)\n        {\n            vec3 target = rec.point + rec.normal + rand;\n            r.origin = rec.point;\n            r.direction = normalize(target - rec.point);\n            col *= 0.5;\n        }\n        else\n        {\n            vec3 unitDirection = normalize(r.direction);\n            float t = 0.5 * (unitDirection.y + 1.0);\n            col *= mix(vec3(1.0), vec3(0.5,0.7,1.0), t);\n            return col;\n        }\n    }\n\n    return col;\n}\n\nbool raycastIndex(const in Ray r, out int index, inout Hit h, inout Sphere[2] spheres)\n{\n    bool didHit = false;\n    float t_max = MAX_FLOAT;\n    \n    bool sphere2Hit = hit(r, spheres[1], 0.00001, t_max, h) || didHit;\n    if (sphere2Hit)\n    {\n        float t_max = h.t;\n        index = 1;\n        didHit = true;\n    }\n    bool sphere1Hit = hit(r, spheres[0], 0.00001, t_max, h);\n    if (sphere1Hit)\n    {\n        float t_max = h.t;\n        index = 0;\n        didHit = true;\n    }\n    \n    return didHit;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 m = iMouse.xy/iResolution.xy;\n \n\n    Camera camera = makeCamera(iResolution);\n\n    vec3 col;\n    \n    Sphere spheres[] = Sphere[](\n        Sphere(vec3(0.0, 0.0, -1.0), 0.5, vec3(1.0, 0.0, 0.0)),\n        Sphere(vec3(0.0, -100.5, -1.0), 100.0, vec3(0.0, 1.0, 0.0))\n    );\n    \n    if (iMouse.z>0.0)\n    {\n   \n        Ray r = Ray(camera.origin, normalize(camera.lowerLeftCorner + m.x * camera.horizontal + m.y * camera.vertical - camera.origin));\n        Hit h;\n        \n        int index;\n        bool didHit = raycastIndex(r, index, h, spheres);\n\n        // Output to screen\n        if (didHit)\n        {\n            spheres[index].color = vec3(1);\n        }\n    }\n\n    for (float s = 0.0; s < SAMPLES_PER_PIXEL; ++s)\n    {\n        vec2 seed = hash22(gl_FragCoord.xy + s * (mod(iTime, 100.)));\n    \n        Ray r = Ray(camera.origin, normalize(camera.lowerLeftCorner + uv.x * camera.horizontal + uv.y * camera.vertical - camera.origin));\n        col += rayColor(r, spheres, seed);\n    }\n    \n    float scale = 1.0 / SAMPLES_PER_PIXEL;\n    col = col * scale;\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159\n\n// UTILS\nfloat hash12(vec2 p) {\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nvec2 hash22(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\nvec3 hash32(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 randomInUnitSphere(vec2 p) {\n    vec3 rand = hash32(p);\n    float phi = 2.0 * PI * rand.x;\n    float cosTheta = 2.0 * rand.y - 1.0;\n    float u = rand.z;\n\n    float theta = acos(cosTheta);\n    float r = pow(u, 1.0 / 3.0);\n\n    float x = r * sin(theta) * cos(phi);\n    float y = r * sin(theta) * sin(phi);\n    float z = r * cos(theta);\n\n    return vec3(x, y, z);\n}\n\nvec3 randomUnitVector(vec2 p) {\n    return normalize(randomInUnitSphere(p));\n}\n\n\n// RAY\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nvec3 rayAt(Ray ray, float t)\n{\n    return ray.origin + t*ray.direction;\n}\n\n// CAMERA\n\nstruct Camera {\n    vec3 origin, lowerLeftCorner, horizontal, vertical;\n};\n\nCamera makeCamera(vec3 iResolution)\n{\n    float h = 2.0;\n    float aspectRatio = iResolution.x / iResolution.y;\n    float w = h * aspectRatio;\n\n    vec3 origin = vec3(0);    \n    \n    vec3 horizontal = vec3(w, 0, 0);\n    vec3 vertical = vec3(0, h, 0);\n    \n    vec3 lowerLeftCorner = origin - horizontal/2.0 - vertical/2.0 - vec3(0.0, 0.0, 1.0);\n\n    return Camera(origin, lowerLeftCorner, horizontal, vertical);\n}\n\n// GEOMETRY\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\n// INTERSECTIONS\n\nstruct Hit\n{\n    float t;\n    vec3 point;\n    vec3 normal;\n    bool frontFace;\n    vec3 color;\n};\n\nbool hit(Ray r, Sphere sphere, float t_min, float t_max, inout Hit rec)\n{\n    vec3 oc = r.origin - sphere.center;\n\n    float halfB = dot(oc, r.direction);\n    float c = dot(oc, oc) - sphere.radius*sphere.radius;\n\n    float discriminant = halfB*halfB - c;\n    \n    if (discriminant < 0.0)\n    {\n        return false;\n    }\n\n    float sqrtd = sqrt(discriminant);\n    \n    float t1 = -halfB - sqrtd;\n    float t2 = -halfB + sqrtd;\n    \n    float t = t1 < 0.001 ? t2 : t1;\n    if (t < t_min || t > t_max)\n    {\n        return false;\n    }\n\n    vec3 p = rayAt(r, t);\n        \n    vec3 normal = p - sphere.center;\n\n    bool frontFace = dot(r.direction, normal) > 0.0;\n\n    normal = frontFace ? -normal : normal;\n    normal /= sphere.radius;\n    \n    rec = Hit(t, p, normal, frontFace, sphere.color);\n    \n    return true;\n}\n","name":"Common","description":"","type":"common"}]}