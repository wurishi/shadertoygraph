{"ver":"0.1","info":{"id":"4s2fWw","date":"1500761085","viewed":147,"name":"Synth Test","username":"Gumgo","description":"Messing around with DSP, played around with some \"fake\" FM synthesis (frequency not modulated but sampling is offset by another signal).","likes":9,"published":1,"flags":8,"usePreview":0,"tags":["synth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// --- access to the image of ascii code c\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.))\n//#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureLod( iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), \\\n//                                                                               log2(length(fwidth(U/16.*iResolution.xy))) )\n  #define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): textureGrad(iChannel3, U/16. + fract( vec2(c, 15-c/16) / 16.), dFdx(U/16.),dFdy(U/16.) )\n#define initMsg vec4 T = vec4(0)\n#define endMsg  return length(T.yz)==0. ? 0. : T.x\n\nfloat message(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0);   // or: initMsg;\n    C(83);C(111);C(117);C(110);C(100); // message \"Sound\"\n    return length(T.yz)==0. ? -1. : T.x; // or: endMsg;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //  if (iResolution.y<200.) to display only in the icon \n    if (iResolution.y<2000.) {float c=message((fragCoord/iResolution.y-vec2(.1,.2))*8.);if(c>=0.){fragColor=vec4(c);return;}}\n\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float k_tau = 6.28318530718f;\nconst float k_e = 2.71828182846f;\n\n#define NOTE(beat, beats, offset) note = beat >= beats ? offset : note\n\nfloat rand(float n){\n    return fract(cos(n*89.42)*343.42);\n}\n\nfloat sharp_env(float t, float length, float falloff) {\n    return max(1.0f - pow(t/length, falloff), 0.0f);\n}\n\nfloat note_to_freq(float note) {\n    return 440.0f * pow(2.0f, (note-69.0f)/12.0f);\n}\n\nfloat kick(float t) {\n    const float k_slowdown = 25.0f;\n    const float k_freq = 100.0f;\n\tfloat signal = sin(k_tau * k_slowdown * (1.0f - 1.0f / (t * (k_freq / k_slowdown) + 1.0f)));\n    return signal * sharp_env(t, 0.4f, 3.0f);\n}\n\nfloat hihat(float t) {\n    return rand(t) * sharp_env(t, 0.1f, 0.1f);\n}\n\nfloat fm_saw(float t, float freq, float fm_freq, float fm_depth) {\n    float wavelength = 1.0f/freq;\n    float fm_offset = sin(t * k_tau * fm_freq) * fm_depth*wavelength;\n\n    t = t + fm_offset;\n    float signal = 0.0f;\n    signal += sin(t * k_tau * freq);\n    signal += sin(t * k_tau * freq * 2.0f)/2.0f;\n    signal += sin(t * k_tau * freq * 3.0f)/3.0f;\n    signal += sin(t * k_tau * freq * 4.0f)/4.0f;\n    signal += sin(t * k_tau * freq * 5.0f)/5.0f;\n    signal += sin(t * k_tau * freq * 6.0f)/6.0f;\n    return signal * 0.25f;\n}\n\nfloat multi_saw(float t, float note, float fm_factor, float fm_falloff) {\n    float fm_depth = 1.0f / exp(t * fm_falloff);\n\n    float freq_a = note_to_freq(note);\n    float freq_b = note_to_freq(note + 0.02);\n    float freq_c = note_to_freq(note - 0.03);\n    float freq_d = note_to_freq(note + 0.05);\n    float signal =\n        fm_saw(t, freq_a, freq_a * fm_factor, fm_depth) +\n        fm_saw(t, freq_b, freq_b * fm_factor, fm_depth) +\n        fm_saw(t, freq_c, freq_c * fm_factor, fm_depth) +\n        fm_saw(t, freq_d, freq_d * fm_factor, fm_depth);\n    return signal * 0.25f;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    float beat_time = 0.5f;\n    float beat = mod(time / beat_time, 16.0f);\n\n    float note = 0.0f;\n    NOTE(beat, 0.0f, 0.0f);\n    NOTE(beat, 4.0f, -3.0f);\n    NOTE(beat, 8.0f, -4.0f);\n    NOTE(beat, 12.0f, -8.0f);\n    NOTE(beat, 13.0f, -7.0f);\n    NOTE(beat, 14.0f, -4.0f);\n    NOTE(beat, 15.0f, -5.0f);\n\n   \tfloat kick_signal = 0.5f * kick(mod(time, beat_time));\n    float hihat_signal =\n        0.5f * hihat(mod(time - beat_time*0.5f, beat_time)) +\n    \t0.5f * hihat(mod(time - beat_time*0.75f, beat_time));\n\n    float note_time = mod(time, beat_time);\n    float note_index = floor(time * 4.0f / beat_time);\n    float oct_offset = floor(rand(note_index) * 3.0f);\n    float final_note = (oct_offset - 1.0f) * 12.0f + note;\n    float lead_high = multi_saw(note_time, 69.0f + final_note, 2.0f, 5.0f);\n    float lead_low = multi_saw(note_time, 69.0f + final_note - 12.0f, 2.0f, 5.0f);\n\n    note = 0.0f;\n    NOTE(beat, 0.0f, -24.0f);\n    NOTE(beat, 4.0f, -24.0f - 3.0f);\n    NOTE(beat, 8.0f, -24.0f - 4.0f);\n    NOTE(beat, 12.0f, -24.0f - 8.0f);\n    NOTE(beat, 14.0f, -24.0f - 5.0f);\n\n    float bass_note_time = beat >= 14.0f ? mod(time + beat_time * 2.0f, beat_time * 4.0f) : mod(time, beat_time * 4.0f);\n    float bass_a = 0.75 * multi_saw(bass_note_time, 69.0f + note, 8.0f, 2.0f);\n    float bass_b = 0.75 * multi_saw(bass_note_time, 69.0f - 12.0f + note, 8.0f, 2.0f);\n\n    float signal = kick_signal + hihat_signal + lead_high + lead_low + bass_a + bass_b;\n    return vec2(signal);\n}","name":"Sound","description":"","type":"sound"}]}