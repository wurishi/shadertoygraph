{"ver":"0.1","info":{"id":"4fKyzK","date":"1732099616","viewed":19,"name":"The other 3D ball","username":"OSH82","description":"w3","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["study"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nLight[] lights = Light[]( Light(vec3(-15,10,10), vec3(1,1,1)));\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n\nvec3 ray_at(in Ray r, in float t) {\n    return r.origin + r.dir*t;\n}\n\n bool sphere_intersect(in Sphere s, in Ray ray, out vec3 point, out vec3 normal)\n {\n        float t0, t1; // Solutions for t if the ray intersects the sphere\n        float t; // The entry collision point\n        // Geometric solution\n        vec3 L = s.center - ray.origin;\n        float tca = dot(L,ray.dir);\n        \n        float d2 = dot(L,L) - tca * tca;\n        if (d2 > s.radius * s.radius) return false;\n        float thc = sqrt(s.radius * s.radius - d2);\n        t0 = tca - thc;\n        t1 = tca + thc;\n        if (t0 > t1) {\n            float t = t0;\n            t0 = t1;\n            t1 = t;\n        }\n        if (t0 < 0.) {\n            t0 = t1; // If t0 is negative, let's use t1 instead.\n            if (t0 < 0.) return false; // Both t0 and t1 are negative.\n        }\n        t = t0;\n        \n        point = ray_at(ray,t);\n        normal = normalize(point-s.center);\n        return true;\n}\n\nvec3 cast_ray(in Ray ray) {\n    vec3 p, n;\n    if(sphere_intersect(Sphere(vec3(0.), .25), ray, p, n)) {\n        vec3 diffuse = vec3(0.,0.,0.);\n        for(int i = 0; i < lights.length(); i++) {\n            vec3 light_dir = normalize(lights[i].position - p);\n            diffuse += lights[i].color * max(0., dot(light_dir, n));\n        }\n        return vec3(0.2, 0.7, 0.8)*(diffuse);\n    }\n    \n    return texture(iChannel0, ray.dir).xyz;\n}\n\n\n\n\n\n vec3 rotateCamera(in vec3 orig, in vec3 dir, in vec3 target) {\n     vec3 zAxis = normalize(orig - target);\n     vec3 xAxis = normalize(cross(vec3(0., 1., 0.), zAxis));\n     vec3 yAxis = normalize(cross(zAxis, xAxis));\n     mat4 transform = mat4(vec4(xAxis, 0.), vec4(yAxis, 0.), vec4(zAxis, 0.), vec4(orig, 1.));\n     return (transform * vec4(dir, 0.)).xyz;\n }\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float fov = 3.1416 / 4.; // pi / 4\n    vec2 uv = (fragCoord/iResolution.xy*2. - 1.)*tan(fov/2.); // ratio of x from center\n    uv.x *= iResolution.x/iResolution.y; // scaling back according to screen resolution\n    \n    vec3 orig =  vec3(-sin(iTime/4.), 0., cos(iTime/4.)); // our camera origin\n    vec3 dir = normalize(vec3(uv, -1)); // facing the -z axis, towards our uv coordinate\n    dir = rotateCamera(orig, dir, vec3(0.));\n    \n    \n    vec3 col = cast_ray(Ray(orig, dir));\n    \n    \n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}