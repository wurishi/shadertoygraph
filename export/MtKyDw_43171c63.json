{"ver":"0.1","info":{"id":"MtKyDw","date":"1536651568","viewed":107,"name":"Cube Life","username":"Nerv3","description":":)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["cubes","endless","spheretracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGzn","filepath":"/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","previewfilepath":"/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 camPos;\nfloat PI = 3.14159;\nfloat gap = 1.55 ;\nfloat l =0.5;//* (sin(iTime) * 0.5 + 0.5)\nvec3 cubeID;\n\n\nvec2 path(in float z){\n    float s = sin(z/24.)*cos(z/16.); \n    return vec2(0., s*20.);\n}\n\n\nfloat fBox(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, 0.0)) + min(max(max(d.x, d.y), d.z), 0.0);\n}\n\nfloat sdCross( in vec3 p, vec3 b )\n{\n  float da = fBox(p.xyz,vec3(999999.,b.y,b.z));\n  float db = fBox(p.yzx,vec3(b.x,999999.,b.z));\n  float dc = fBox(p.zxy,vec3(b.x,b.y,999999.));\n  return min(da,min(db,dc));\n}\n\n\nmat3 rotX(float a) {\n\treturn mat3 (1.0, 0.0, 0.0, 0.0, cos(a), -sin(a), 0.0, sin(a), cos(a));\n}\n\nmat3 rotY(float a) {\n\treturn mat3 (cos(a), 0.0, sin(a), 0.0, 1.0, 0.0, -sin(a), 0.0, cos(a));\n}\n\nmat3 rotZ(float a) {\n\treturn mat3 (cos(a), -sin(a), 0.0, sin(a), cos(a), 0.0, 0.0, 0.0, 1.0);\n}\n \n\nvoid repeatCartesianX(inout vec3 p, float size) {\n\tp.x = mod(p.x + size*0.5, size) - size*0.5;\n}\nvoid repeatCartesianXY(inout vec3 p, float size) {\n\tp.xy = mod(p.xy + size*0.5, size) - size*0.5;\n}\nvoid repeatCartesianY(inout vec3 p, float size) {\n\tp.y = mod(p.y + size*0.5, size) - size*0.5;\n}\n\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\nvec3 pMod3C(in vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\treturn c;\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec4 hash(vec4 h) {\n    return fract(sin(h) * 43758.5);\n}\n\nfloat flyingBoxes(vec3 p){\n    vec3 p2 = p - vec3(l + gap*0.5,0,0 );\n\n    vec3 ret2 = pMod3C(p2.xyz,vec3(l*2. + gap));\n\n    float fft  = texture( iChannel0, vec2(0,0)).x; \n\n    float t = (iTime + rand(ret2.z * 5153.))*0.2 + rand(ret2.z);\n\n    p2.x += (floor(t) + smoothstep(0.,1.,fract(t) * 4.)) * (l*2. + gap);\n    p2.y += (floor(t) + smoothstep(0.,1.,fract(t-0.5) * 4.)) * (l*2. + gap);\n\n    \n    pMod3(p2.xyz,vec3(l*2. + gap));\n    \n    pR(p2.xy,3.0*PI * (floor(t) + clamp(fract(t-0.5) * 4., 0., 1.)));\n\n\n    float flyingBox = fBox(p2,vec3(0.15) *fft);\n    return flyingBox;\n}\n\n\nvec2 fScene(vec3 p){\n       \n\tfloat obj = (-9999999.0);\n\t\n\tfloat scene = 999999.;\n\n    vec3 p1 = p - vec3(l + gap*0.5,0,0 );\n    float thickness = 0.15;\n    vec3 p3 = p  - vec3(l + gap*0.5,0,0 );\n\n    vec3 ret = pMod3(p1.xyz,vec3(l*2. + gap));\n\n    cubeID = ret;\n  \n\t//pR(p1.xy, sin(ret.x*100.0) + rand(ret.x)  + rand(ret.y * 33.)  + rand(ret.z*231.));\n\t//pR(p1.xy, rand(ret.x + ret.y*515. + ret.z *12123.));\n    \n    float t = (iTime + rand(ret.z * 5153.))*0.2 + rand(ret.z);\n\n    \n    \n    float t2 = (floor(t) + smoothstep(0.,1.,fract(t) * 4.)) ;\n    float t3 =  (floor(t) + smoothstep(0.,1.,fract(t-0.5) * 4.));\n    \n\t//pR(p1.yz, mod (PI * t2 * .5, PI));\n\t//pR(p1.xz, mod (PI * t3 * .5, PI));\n\n     float dbox = fBox(p1,vec3(l, l, l) );\n\n    \n    float dbox2 = sdCross(p1,vec3(l)*0.7 );\n\n\n    \n    dbox = max(dbox,-dbox2);\n    \n    \n    pMod3(p3.xyz,vec3(l*2. + gap));\n\n\n    float dbox3 = fBox(p3,vec3(l *thickness, l *thickness, 2.*l));\n    \n    \n    scene = max(-scene,dbox);\n\n    float flyingBox = flyingBoxes(p);\n\n    scene = min(scene, flyingBox);\n\n\tif (abs(scene-dbox)<0.1) obj= 1.0;\n\tif (abs(scene-flyingBox)<0.1) obj= 2.0;\n\n\treturn vec2(scene,obj);\n}\n\n\n\nfloat shadows( in vec3 ro, in vec3 rd, float maxt)\n{\n    float k = 1.0;\n    float res = 1.0;\n    float ph = 1e20;\n    float t=0.01;\n    for( int i = 0;i < 1000; ++i)\n    {\n        float h = fScene(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n        if (t > maxt)\n            break;\n    }\n    return res;\n}\n\nvec3 sphereTrace( in vec3 ro, in vec3 rd)\n{\n    vec3 res = vec3(-2.0);\n    \n    float t = 0.5;\n\tconst float maxdist = 1000.;\n\tconst int maxIters = 100;\n\n    for( int i = 0; i<maxIters;i++ )\n    {\n        vec3 p = ro + t*rd;\n        vec2 r = fScene( p );\n        res = vec3(t,r.y, i);\n        \n        if (t > maxdist){\n             res.y = -9999.0;\n\t\t\tbreak;\n        }\n\n\n        if( r.x<(0.01) ||  t>maxdist ) break;\n        \n        t += r.x * 1.;\n\n\n\t\t\n    }\n\n\treturn res;\n}\n\n\nvec3 getNormal(vec3 p) {\n\tfloat epsilon = 0.01;\n\tvec2 h = vec2(1.0, 0.0) * epsilon;\n\tvec3 n = vec3(\n\t\tfScene(p + h.xyy).x - fScene(p - h.xyy).x,\n\t\tfScene(p + h.yxy).x - fScene(p - h.yxy).x,\n\t\tfScene(p + h.yyx).x - fScene(p - h.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n\nvec3 calcNormal( in vec3  p )\n{\n    const float h = 0.01;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*fScene( p + k.xyy*h ).x + \n                      k.yyx*fScene( p + k.yyx*h ).x + \n                      k.yxy*fScene( p + k.yxy*h ).x + \n                      k.xxx*fScene( p + k.xxx*h ).x );\n}\n\n\nvec3 getNormalBoxes(vec3 p) {\n\tfloat epsilon = 0.01;\n\tvec2 h = vec2(1.0, 0.0) * epsilon;\n\tvec3 n = vec3(\n\t\tflyingBoxes(p + h.xyy) - flyingBoxes(p - h.xyy),\n\t\tflyingBoxes(p + h.yxy) - flyingBoxes(p - h.yxy),\n\t\tflyingBoxes(p + h.yyx) - flyingBoxes(p - h.yyx)\n\t);\n\t\n\treturn normalize(n);\n}\n\nvec3 shading(vec3 p, vec3 normal, vec3 l, vec3 rd, vec3 diffuseColor) {\n\t\n\tvec3 lig = normalize(l);\n\tvec3 ref = reflect(lig, normal);\n\t\n\tfloat amb = 0.1;\n\tfloat dif = clamp(dot(normal, lig), 0.0, 1.0);\n\tfloat spe = pow(clamp(dot(ref, rd), 0.0, 1.0), 10.0);\n\t\n\tvec3 lin = vec3(0);\n\t\n\t//lin += amb;\n\tlin += dif*diffuseColor;\n\t\n\t//lin += spe*vec3(1, 1, 1);\n    \n    \n    \n    float distToBoxes = flyingBoxes(p);\n    \n    \n    float boxDist =flyingBoxes(p);\n    \n    vec3 shadowRay = getNormalBoxes(p);\n    float shadow = shadows(p, normalize(shadowRay), boxDist);\n    \n    \n\tfloat sFactor = mix (exp(-distToBoxes*5.), 0., shadow );\n    \n\n    lin += 4.0*sFactor + exp(-distToBoxes*8.)  ;\n\n\treturn lin;\n}\n\n\nvec3 render(vec3 pos, vec3 raydir){\n\t\t\n\tvec3 color;\n\t\t\n\tvec3 ret = sphereTrace(pos, raydir);\n\tfloat dist = ret.x;\n\tfloat obj = ret.y;\n\tfloat iters = ret.z;\n\t\t \n\tvec3 worldPos = pos + raydir*dist;\n\tvec3 normal = calcNormal(worldPos);\n\n\n\tvec3 lightPos = camPos;\n\t\t\n    vec3 fog = vec3(1.);\n    \n    \n\n    if (obj < 0.0 ){\n         color =fog;\n    }\n    else\n    {\n\n        vec3 diffuseColor = vec3(.3, .27, .25);\n        diffuseColor = vec3(sin(cubeID.z/10.),cos(cubeID.z/5.),sin(cubeID.z/8. + PI/4.0));\n\n        if (obj == 2.0){\n            diffuseColor = vec3(1);\n        }\n\n        color = shading(worldPos, normal, lightPos-worldPos, raydir, diffuseColor);\n    }\n    \n    \n    float fft  = texture( iChannel0, vec2(511,0)).x; \n    fog = vec3(1.0,0.5,0.5) ;\n    color = mix (fog*fft * 0.3, color, exp(-dist * dist * 0.004) );\n\treturn vec3(color);\n}\n\nmat3 setCamera( in vec3 pos, in vec3 target)\n{\n\tvec3 lookdir = normalize(target-pos);\n\n\tvec3 roll = vec3(0.0, 1.0,0.0);\n     roll =  rotZ(-iTime*0.1) * roll;\n\n\tvec3 right = normalize( cross(lookdir,roll) );\n\tvec3 up = normalize( cross(right,lookdir) );\n    return mat3( right, up, -lookdir );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat aspect = iResolution.x/iResolution.y;\n\n    \n    vec3 pos = vec3(0,0,-5.1);\n   \tvec3 pos2 = pos;\n    pos.z += 2.*iTime;\n\tpos2.z = pos.z + 0.1;\n    \n    pos.xy += path(pos.z);\n    pos2.xy += path(pos2.z);\n    \n\n    camPos = pos;\n\n    vec3 lookdir = normalize(vec3(0,0,1));\n\n    lookdir = normalize(pos2 - pos);\n\n\n    \n    mat3  ca = setCamera( pos, pos + lookdir);\n    //ca =  rotY(iMouse.x/iResolution.x * PI * 2.0 + PI) * ca;\n    //ca =  rotZ(-iTime*0.1) * ca;\n\n    const float FOV = 60.0;\n    \n    vec2 t = uv*( 1.0 - uv.yx); \n\n\n    \n    uv = uv * 2.0 - 1.0;\n\tuv.x *= aspect;\n\n    vec3  raydir = normalize( ca * vec3(uv,-1.0/tan(FOV*3.14159/360.0)) );\n    \n\tvec3 renderResult = render(pos, raydir);\n    \n\t//vignette\n    float vig = t.x*t.y * 15.0; \n    vig = pow(vig, 0.25);\n    renderResult = mix(renderResult, vec3(0), 1.-vig);\n    fragColor = vec4(renderResult,1.0);\n}","name":"Image","description":"","type":"image"}]}