{"ver":"0.1","info":{"id":"4ljcRW","date":"1507653240","viewed":330,"name":"Worming","username":"duvengar","description":"Having fun with another variation on the Truchet Theme. Inspired and derived from [url=https://www.shadertoy.com/view/llfyWX]Simple_animated_Truchet[/url] by @Shane\nMouse control the flow direction.","likes":15,"published":1,"flags":0,"usePreview":0,"tags":["2d","truchet","flow","polar","worm"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Worming by julien Vergnaud @duvengar-2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// ====================================================================\n\n// Derived from Simple_animated_Truchet by @Shane\n// [url]https://www.shadertoy.com/view/llfyWX[/url]\n\n// Mouse control direction\n\n\n#define PI     3.14159265359\n#define TWO_PI (PI*2.)\n\n// vec2 to float hash function taken from @Shane - Based on IQ's original.\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.213, 289.867)))*43758.5453); }\n\n// Standard 2D rotation formula.\n\nmat2 rot(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// polynomial smooth min\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5 + 0.5 * (b - a) / k, 0.0, 1.0 );\n    return mix( b, a, h ) - k * h * (1.0 - h);\n}\n\n//distance field circle\n\nfloat df_circle(vec2 pos, float rad){\n\n    return (length(pos)-rad);  \n}\n\n\n\n\n\nvoid mainImage( out vec4 c, in vec2 uv )\n{\n    \n    // I   //  Screen coordinates is formated to go from -1. to 1.\n    \n\tvec2 p = -1.+ 2.* uv / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n    \n      \n   \n    // II  //  Moove & Rescale screen space\n    \n    p *= 1. + dot(p, p)*.05;        // fish eye\n    p += vec2(.0, iTime/12.);       // moove along Y axis\n    p *= .7*floor(iResolution.x/200.); // rescale space\n \n    \n \t// III //  Make truchet lines\n           //  store tile id & Divide screen into grid \n    \t   //  & store direction in a checkerboard way.\n\t\n    vec2 id = floor(p);\n    \n           // replacing Shane's float dir = sign(mod(id.x + id.y, 2.) - .5);\n           // The sign() seems to be dispensable\n    \n    float dir = mod(id.x + id.y, 2.)-.5;  \n    p = fract(p) - .5;  // or // p -= id + .5; \n        \n           //  Truchet tiles orientation randomisation\n    \n\tp.y *= hash21(id) > .5 ? 1. : -1.;\n    \n           //  Applying symetry on diagonal axis to avoid drawing two arcs\n           //  Tricks form @shane\n    \n    p *= sign(p.x + p.y);\n      \n           //  Drawing the two arc's strokes directly with a tickness of t\n           //  The tricks to draw a contour was taken from a @FabriceNeyret2 \n           //  comment in this shader https://www.shadertoy.com/view/MtXyWX\n    \n    p              -= .5; \n    float t         = .12; \n    float t2        = .05;    \n    float line      = abs(length(p ) - .5) - t *1.5 ;\n    float line_str  = abs(length(p ) - .5) - t2 * .3;\n    float line_out  = max(line, -line -.01);\n    float line_glow = abs(length(p ) - .5) - t2 * 2.;\n      \n           //  Adjusting the arcs clarity (I don't know how to call that)\n    \n    line     = 1. - smoothstep(.01,.1, sqrt(line));\n    line_str = 1. - smoothstep(.01,.3, sqrt(line_str));\n    line_glow = 1. - smoothstep(.01,.5, sqrt(line_glow));\n  \n    // IV  //  RENDER CHAIN\n    \n            //  Animate flow\n     \n    vec2 pos = p ;\n    \n    if(iMouse.z > 0.){\n    \tfloat m = smoothstep(.0,-1. + 2. * iResolution.x, -1. + 2. * iMouse.x);\n        m*= 20.;\n    \tpos *= rot(m*dir);\n    }else{\n        pos *= rot(iTime*dir);\n    }\n\n            //  Part into cells  & convert into polar coordinates\n     \n    const float num = 16.;                       // partitions number\n    float ang = atan(pos.y, pos.x);              // Pixel angle.               \n    float ctr = floor(ang / TWO_PI * num ) + .5; // the cell center.\n\n    pos  = rot(ctr  *(PI*2.) / num) *pos;        // Converting to polar coordinates\n \t \n    pos.x -= .5;                                 // p.x = radius, p.y = angle.\n                                                 // Translate coordinates\n    \n            //  render the objects in each slices\n      \n              \n    float ring2 = smoothstep(0.0, .01, df_circle(pos, .165)); \n    \n        \n    \n    ///////////////////////////////////////////////////////////////////////////////\n    \n   \n    \n    // V  //   Coloring\n    \n    float tex = .7 * sin(2. * cos(3. * uv.x + uv.y) - hash21(uv));     \n \n\n  \n    c = vec4(.0);\n \n    c = .1*vec4(tex-.5);                                              // small amout off texture\n    \n    c += vec4(line -smoothstep(.0,.08,line_out*cos(sin(ang*45.))));   // base shape \n    \n    c += mix(vec4(.2, .9, .8, 1.),c, .2);                             //base color\n    c += mix(vec4(.2, .9, .8, 1.),c, .2); \n     \n    c += .45*vec4(cos(sin(ang)));                                     // base lighting based on angle  \n    c *= .45*vec4(cos(sin(ang))); //\n    \n    c *= mix(c,vec4(cos(sin(ang*5.)),cos(sin(ang*5.)),1.,1.),.5);     // more color based angle\n                   \n    c += line * vec4(cos(sin(ang*2.)), .0, 0., 0.);                   // angle*2 is red\n    c *= 1.-ring2+(line_str*cos(sin(ang*10.)));\n    c *= .5 + vec4(.2,.9,.7,.0);                                      // color balance\n    \n    c+= (smoothstep(-.1,.7,tex*line_out));                            // backgground texture\n    c -= .4*mix(c,vec4(-.1*cos(sin(ang*3.)),.1,-.1*cos(sin(ang*3.)),1.),.5); \n     vec2 uu  = 1. - 2. * uv / iResolution.xy;                        // vigneting\n    float v  = 1. - smoothstep(.7, 1.4, length(uu*uu*uu)) * 2.;\n    c *= vec4(v);   \n    c = mix(c,vec4(.0,.0,.1,1.),.3);\n    c += .4*vec4(smoothstep(.0,.9,line_glow*ring2));                  // a bit of glow\n    c /= .7/pow(c,c);                                                 // lighten more\n\n}","name":"Image","description":"","type":"image"}]}