{"ver":"0.1","info":{"id":"fdGyzh","date":"1654366933","viewed":99,"name":"Lights and Materials","username":"alinachadwick","description":"Colored Art Room","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["light","material","art"],"hasliked":0,"parentid":"NsKcRR","parentname":" Art Room C avidixit27"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Final project for Dartmouth CS 77 Course\n// Charlie Baker, Alina Chadwick, Avi Dixit\n// Based on implementation of https://raytracing.github.io/books/RayTracingTheNextWeek.html\n// with the addition of light sources and objects in the field\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    fragColor = vec4(sqrt(data.rgb/data.w),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Ray tracing in one weekend basecode for Dartmouth CS 77/177 \n// by Wojciech Jarosz, 2019\n\n#define EPSILON 1e-3 \n#define MAX_FLOAT 1e5\n#define MAX_RECURSION 5\n\n#define LAMBERTIAN 0\n#define METAL 1\n#define DIFFUSE_LIGHT 3\n\n#define SPHERE 0\n#define BOX 2\n#define SOLID 0\n\n//\n// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n//\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvoid init_rand(in vec2 frag_coord, in float time) {\n    g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+time;\n}\n\n\nfloat rand1(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 rand2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 rand3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = rand2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = rand3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\n\n// Inspired by simple raytracer\n// https://www.shadertoy.com/view/tsjfDt\nvec3 random_cos_weighted_hemisphere_direction( const vec3 n, inout float seed ) {\n  \tvec2 r = rand2(seed);\n\tvec3  uu = normalize(cross(n, abs(n.y) > .5 ? vec3(1.,0.,0.) : vec3(0.,1.,0.)));\n\tvec3  vv = cross(uu, n);\n\tfloat ra = sqrt(r.y);\n\tfloat rx = ra*cos(6.28318530718*r.x); \n\tfloat ry = ra*sin(6.28318530718*r.x);\n\tfloat rz = sqrt(1.-r.y);\n\tvec3  rr = vec3(rx*uu + ry*vv + rz*n);\n    return normalize(rr);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//general structs below:\nstruct ray {\n    vec3 o;\n    vec3 d;\n    float t;\n};\n\nstruct textures {\n    int type;\n    vec3 v;\n};\n\nstruct material {\n    int type;\n    textures color;\n    textures emit;\n    float v;\n};\n\nstruct hit_record {\n    float t;\n    vec3 point;\n    vec3 normal;\n    material mat;\n};\n\n// returns true if refracted\nbool refraction(const in vec3 v, const in vec3 n, const in float f, out vec3 refracted) {\n    float dt = dot(v, n);\n    float discriminant = 1. - f*f*(1.-dt*dt);\n    float sqrt_disc = sqrt(discriminant);\n    if (discriminant > 0.) {\n        refracted = f*(v - n*dt) - n*sqrt_disc;\n        return true;\n    } else { \n        return false;\n    }\n}\n\n//returns true if scattered\nbool scatter(const in ray r_in, const in hit_record rec, out vec3 attenuation, out ray scattered) {\n    if(rec.mat.type == LAMBERTIAN) {\n        scattered = ray(rec.point, random_cos_weighted_hemisphere_direction(rec.normal, g_seed), r_in.t);\n        attenuation = rec.mat.color.v;\n        return true;\n    } else if(rec.mat.type == METAL) {\n        vec3 rd = reflect(r_in.d, rec.normal);\n        scattered = ray(rec.point, normalize(rd + rec.mat.v*random_in_unit_sphere(g_seed)), r_in.t);\n        attenuation = rec.mat.color.v;\n        return true;\n    } \n    return false;\n}\n\n//returns emitted material vector\nvec3 material_emitted(const in hit_record rec) {\n    if (rec.mat.type == DIFFUSE_LIGHT) {\n        return rec.mat.emit.v;\n    } else {\n        return vec3(0);\n    }\n}\n\n//inspired by sdSphere function and programming assignment 6\n// https://iquilezles.org/articles/spherefunctions/\nbool sphere_intersect(const in ray r, const in float t_min, const in float t_max, const in vec3 center, const in float rad, inout float dist) {\n\tvec3 oc = r.o - center;\n    float b = dot(oc, r.d);\n    float c = dot(oc, oc) - rad * rad;\n    float discriminant = b * b - c;\n    if (discriminant < 0.0) return false;\n\n\tfloat sqr = sqrt(discriminant);\n\tfloat t0 = -b - sqr;\n\tfloat tf = -b + sqr;\n\t\n\tfloat t = t0 < t_min ? tf : t0;\n    if (t < t_max && t > t_min) {\n        dist = t;\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\n// inspired by sdBox function \n// https://iquilezles.org/articles/boxfunctions\nbool box_intersect(const in ray r, const in float t_min, const in float t_max, const in vec3 center, const in vec3 rad, out vec3 norm, inout float dist) {\n     vec3 m = 1./r.d;\n    vec3 n = m*(r.o - center);\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.) return false;\n    \n    float t = tN < t_min ? tF : tN;\n    if (t < t_max && t > t_min) {\n        dist = t;\n\t\tnorm = -sign(r.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\t    return true;\n    } else {\n        return false;\n    }\n}\n\n// hitable and hitable_hit implementations inspired by http://roar11.com/2019/10/gpu-ray-tracing-in-an-afternoon/\nstruct hitable {\n    int type;\n    vec3 center;\n    vec3 v3; \n    float rad;         \n};\n     \nbool hitable_hit(const in hitable hb, const in ray r, const in float t_min, \n                 const in float t_max, inout hit_record rec) {\n    \n    if(hb.type == SPHERE ) {\n        vec3 center = hb.type == SPHERE ? hb.center : hb.center + r.t * hb.v3;\n        float radius = hb.rad;\n        float dist;\n        if (sphere_intersect(r, t_min, t_max, center, radius, dist)) {\n            rec.t = dist;\n            rec.point = r.o + dist*r.d;\n            rec.normal = (rec.point - center) / hb.rad;\n            return true;\n        } else {\n            return false;\n        }\n    } else { \n        float dist;\n        vec3 normal;\n        if (box_intersect(r, t_min, t_max, hb.center, hb.v3, normal, dist)) {\n            rec.t = dist;\n            rec.point = r.o + dist*r.d;\n            rec.normal = normal;\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n//camera\n//inspired by programming assignment 6 and chapter 2\n\nstruct camera {\n    vec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 u;\n    vec3 v;\n    vec3 w;\n    float time0;\n    float time1;\n    float lens_radius;\n};\n\ncamera camera_constructor(const in vec3 lookfrom, const in vec3 lookat, const in vec3 vup, \n                    const in float vfov, const in float aspect, const in float aperture, \n                    const in float focus_dist, const in float time0, const in float time1) {\n    camera cam;    \n    cam.lens_radius = aperture / 2.;  // chapter 2 addition\n    float theta = vfov*3.14159265359/180.;\n    float half_height = tan(theta/2.);\n    float half_width = aspect * half_height;\n    cam.origin = lookfrom;\n    cam.w = normalize(lookfrom - lookat);\n    cam.u = normalize(cross(vup, cam.w));\n    cam.v = cross(cam.w, cam.u);\n    cam.lower_left_corner = cam.origin  - half_width*focus_dist*cam.u -half_height*focus_dist*cam.v - focus_dist*cam.w;\n    cam.horizontal = 2.*half_width*focus_dist*cam.u;\n    cam.vertical = 2.*half_height*focus_dist*cam.v;\n    cam.time0 = time0;  // chapter 2 addition\n    cam.time1 = time1;  //chapter 2 addition\n    return cam;\n}\n\n\nray camera_get_ray(camera c, vec2 uv) {\n    vec2 rd = c.lens_radius*random_in_unit_disk(g_seed);\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return ray(c.origin + offset, \n               normalize(c.lower_left_corner + uv.x*c.horizontal + uv.y*c.vertical - c.origin - offset),\n               mix(c.time0, c.time1, rand1(g_seed)));\n}\n\n// inspired by Chapter 7 Cornell Box\nbool world_hit(const in ray r, const in float t_min, const in float t_max, out hit_record rec) {\n    rec.t = t_max;\n    bool hit = false;\n\n    const material blue = material(LAMBERTIAN, textures(SOLID,vec3(0.1, 0.1, 0.45)),textures(SOLID,vec3(0)),0.);\n    const material white = material(LAMBERTIAN, textures(SOLID,vec3(.73)), textures(SOLID,vec3(0)),0.);\n    const material lblue = material(LAMBERTIAN, textures(SOLID,vec3(.1,.1,.7)), textures(SOLID,vec3(0)),0.);\n    const material black = material(METAL, textures(SOLID, vec3(0.35, 0.35, 0.35)), textures (SOLID, vec3(0)), 0.);\n    const material light = material(DIFFUSE_LIGHT, textures(SOLID,vec3(0)), textures(SOLID,vec3(7)),0.);\n    const material yellow = material(LAMBERTIAN, textures(SOLID, vec3(.7, .7, .1)), textures(SOLID, vec3(0)), 0.);      \n  \tconst material maroon = material(LAMBERTIAN, textures(SOLID, vec3(.7, .2, .2)), textures(SOLID, vec3(0)), 0.);\n    \n    if (hitable_hit(hitable(BOX, vec3(556,277.5,277.5), vec3(1,277.5,277.5), 0.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=lblue;\n        \n    if (hitable_hit(hitable(BOX, vec3(-1,277.5,277.5), vec3(1,277.5,277.5), 0.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=blue;\n   \n    if (hitable_hit(hitable(BOX, vec3(277.5,556,277.5), vec3(277.5,1,277.5), 0.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=white;\n        \n    if (hitable_hit(hitable(BOX, vec3(277.5,-1,277.5), vec3(277.5,1,277.5), 0.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=black;\n        \n    if (hitable_hit(hitable(BOX, vec3(277.5,277.5,556), vec3(277.5,277.5,1), 0.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=black;\n    \n    if (hitable_hit(hitable(BOX, vec3(278,555,279.5), vec3(115,1,157.5), 0.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=light;\n        \n     if (hitable_hit(hitable(SPHERE, vec3(100,400,50), vec3(0., 0., 0.), 27.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=light;\n        \n     if (hitable_hit(hitable(SPHERE, vec3(400,175,100), vec3(0., 0., 0.), 50.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=light; \n        \n    if (hitable_hit(hitable(BOX, vec3(175,175,300), vec3(115,90,157.5), 20.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=yellow; \n        \n    if (hitable_hit(hitable(SPHERE, vec3(175,300,300), vec3(0., 0., 0.), 40.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=lblue; \n        \n    if (hitable_hit(hitable(BOX, vec3(400,400,300), vec3(50,50,50), 0.),r,t_min,rec.t,rec)) \n        hit=true, rec.mat=maroon; \n    return hit;\n}\n\n//inspired by programming assignment 6\nvec3 color(in ray r) {\n    vec3 col = vec3(0);\n    vec3 emitted = vec3(0);\n\thit_record rec;\n    \n    for (int i=0; i<MAX_RECURSION; i++) {\n    \tif (world_hit(r, EPSILON, MAX_FLOAT, rec)) {\n            ray scattered;\n            vec3 attenuation;\n            vec3 emit = material_emitted(rec);\n            emitted += i == 0 ? emit : col * emit;\n            \n            if (scatter(r, rec, attenuation, scattered)) {\n                col = i == 0 ? attenuation : col * attenuation;\n                r = scattered;\n            } else {\n                return emitted;\n            }\n\t    } else {\n            return emitted;\n    \t}\n    }\n    return emitted;\n}\n\nvoid mainImage( out vec4 frag_color, in vec2 frag_coord ) {\n    if (ivec2(frag_coord) == ivec2(0)) {\n        frag_color = iResolution.xyxy;\n    } else {\n        // fizzle in, inspired by Chapter 8\n        g_seed = float(base_hash(floatBitsToUint(frag_coord)))/float(0xffffffffU)+iTime;\n        \n        camera cam = camera_constructor( vec3(278, 278, -800), vec3(278,278,0), vec3(0,1,0), 40., iResolution.x/iResolution.y, .0, 10., 0., 1.);\n        ray r = camera_get_ray(cam, (frag_coord + rand2(g_seed))/iResolution.xy);\n        vec3 col = color(r);\n        \n        if (texelFetch(iChannel0, ivec2(0),0).xy == iResolution.xy) {        \n\t        frag_color = vec4(col,1) + texelFetch(iChannel0, ivec2(frag_coord), 0);\n        } else {        \n\t        frag_color = vec4(col,1);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}