{"ver":"0.1","info":{"id":"tdKSRc","date":"1575148624","viewed":180,"name":"Rotating shapes and lines","username":"Maddig","description":"Using conversions between Polar and Cartesian coordinates to rotate boundaries and using those boundaries to form shapes and lines","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","shapes","rotating","polar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// use conversion between polar and cartesian coordinates to generate rotated boundaries\nfloat drawBoundary(vec2 pos, vec2 fragPos, int iAngle, float radius)\n{   \n    // add 0.001 to avoid 0 division on tan(90) & tan(270)\n    float angle = float(iAngle % 360) + 0.001;\n    \n    // tan(angle) == y / x\n    float gradient = tan(radians(angle));\n    \n    // y = mx + c => c = mx - y\n    float fragEquation = (fragPos.x * gradient) - fragPos.y;\n    \n    // rotate around pos from a radius distance\n    float radx = radius * cos(radians(angle));\n    float rady = radius * sin(radians(angle));\n    \n    // antialiasing\n    float aax = .8 * cos(radians(angle));\n    float aay = .8 * sin(radians(angle));\n    \n    float boundaryPos1 = ((pos.x - rady - aay) * gradient) - (pos.y + radx + aax);\n    float boundaryPos2 = ((pos.x - rady + aay) * gradient) - (pos.y + radx - aax);\n    \n    \n    float inBounds = smoothstep(boundaryPos1, boundaryPos2, fragEquation);\n    return inBounds;\n}\n\n\nfloat drawLine(vec2 pos, vec2 fragPos, int iAngle, float radius, float thickness)\n{\n    thickness /= 2.;\n    float inBounds = drawBoundary(pos, fragPos, iAngle,       thickness + radius) *\n                     drawBoundary(pos, fragPos, iAngle + 180, thickness - radius);\n    \n    return inBounds;\n}\n\n\nfloat drawShape(vec2 pos, vec2 fragPos, int iAngle, float size, float sides)\n{\n    float inBounds = 1.;\n    float sideAngle = 360. / sides;\n    \n    for (float i = 0.; i <= 360.; i += sideAngle)\n    {\n        inBounds *= drawBoundary(pos, fragPos, iAngle + int(i), size);\n    }\n    \n    return inBounds;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 lineCoord = vec2(0.5) * iResolution.xy;\n    vec2 polyCoord = vec2(0.25, 0.75) * iResolution.xy;\n    \n    // iFrame probably isn't a great angle metric for time consistency but it works\n    \n    float b1 = drawBoundary(lineCoord, fragCoord, iFrame + 180, -0.25 * iResolution.y);\n    \n    float l1 = drawLine(lineCoord, fragCoord, 2 * iFrame,                 0.00, 2.);\n    float l2 = drawLine(lineCoord, fragCoord,     iFrame, iResolution.y * 0.25, 1.);\n    \n    float s1 = drawShape(lineCoord, fragCoord, iFrame, 0.16 * iResolution.y, 4.0);\n    float s2 = drawShape(polyCoord, fragCoord, iFrame, 0.1  * iResolution.y, 7.0);\n    \n    // max is the equivilant of drawing both shapes, would have liked to use binary | though\n    vec3 col = vec3(max(s1, s2), max(l1, l2), max(l1, b1));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}