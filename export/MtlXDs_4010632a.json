{"ver":"0.1","info":{"id":"MtlXDs","date":"1440777642","viewed":212,"name":"black goo","username":"stef_levesque","description":"based on \"Deformed\" by xbe","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["procedural","3d","raymarching","noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/////////////////////////////////\n// XBE\n// Deformed\n// Sphere + Plane + Noise\n//\n\nvec4 spect;\n\n// Value Noise by IQ\n#define USE_PROCEDURAL\n#ifdef USE_PROCEDURAL\nfloat hash( float n ) { return fract(sin(n)*43758.5453123); }\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n#else\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel1, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n#endif\n\nfloat fbm(vec3 uv)\n{\n\tfloat f;\n\tmat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n\tf  = 0.5000*noise( uv ); uv = m*uv*2.01;\n\tf += 0.2500*noise( uv ); uv = m*uv*2.02;\n\tf += 0.1250*noise( uv ); uv = m*uv*2.03;\n\tf += 0.0625*noise( uv ); uv = m*uv*2.01;\n//\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\n// Distance Functions for Raymarching\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat opU( float d1, float d2 )\n{\n\treturn (d1<d2) ? d1 : d2;\n}\n\nfloat map( in vec3 pos )\n{\n\tfloat deform = spect.x*fbm( pos + spect.y*fbm((spect.z+5.)*pos));\n\tfloat d = opU( sdPlane(pos+vec3(0.,0.5,0.)) + 3.14*deform,\n\t\tsdSphere( pos, 0.35 ) - deform);\n    return d;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3(0.001,0.0,0.0);\n\treturn normalize( vec3(\n\t\tmap(pos+eps.xyy) - map(pos-eps.xyy),\n\t\tmap(pos+eps.yxy) - map(pos-eps.yxy),\n\t\tmap(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\n// Raymarching\nbool raymarch(vec3 origin, vec3 dir, out float dist, out vec3 norm)\n{\n\tfloat epsilon = 0.003;\n\tfloat maxdist = 10.0;\n\tfloat marched = 0.0;\n\tfloat delta = 2.*epsilon;\n\tdist = -1.0;\n\tfor (int steps=0; steps < 60; steps++)\n\t{\n\t\tif ( ( abs(delta) < epsilon ) || (marched > maxdist) ) continue;\n\t\tmarched += delta;\n\t\tdelta = map(origin + marched * dir);\n\t}\n\tbool res = false;\n\tif (marched < maxdist)\n\t{\n\t\tnorm = calcNormal(origin + marched * dir);\n\t\tdist = marched;\n\t\tres = true;\n\t}\n\treturn res;\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat totao = 0.0;\n    float sca = 1.0;\n    for( int aoi=0; aoi<5; aoi++ )\n    {\n        float hr = 0.01 + 0.05*float(aoi);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        totao += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp( 1.0 - 4.0*totao, 0.0, 1.0 );\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.0);\n\tfloat dist = 0.;\n\tvec3 nor = vec3(0.,0.,0.);\n\t//\n\tvec3 lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\tvec3 sky = vec3(0.32,0.36,0.4) - rd.y*0.4;\n\tfloat sun = clamp( dot(rd,lig), 0.0, 1.0 );\n\tsky += vec3(1.0,0.8,0.4)*0.5*pow( sun, 10.0 );\n\tsky *= 0.9;\n\t//\n    if ( raymarch(ro, rd, dist, nor) )\n    {\n        vec3 pos = ro + dist*rd;\n\n\t\tcol = vec3(0.0);\n\t\t\n        float ao = calcAO( pos, nor );\n\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\n\t\tvec3 brdf = vec3(0.0);\n//\t\tbrdf += 2.20*amb*vec3(0.20,0.22,0.26)*ao;\n\t\tbrdf += 1.20*amb*vec3(0.20,0.22,0.26)*ao;\n        brdf += 0.20*bac*vec3(0.15,0.15,0.15)*ao;\n        brdf += 1.00*dif*vec3(1.00,0.90,0.70);\n\n\t\tfloat pp = clamp( dot( reflect(rd,nor), lig ), 0.0, 1.0 );\n\t\tfloat spe = pow(pp,16.0);\n\t\tfloat fre = ao*pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\n\t\tcol = col*brdf + vec3(0.8)*vec3(1.00,0.70,0.60)*spe + 0.2*fre*(0.5+0.5*col);\n\t\tcol = mix( col, sky, 1.0-exp(-0.0025*dist*dist*dist) );\n\t}\n\telse\n\t{\n\t\tcol = sky;\n\t}\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float dt = iTime * 0.015;\n    vec2 uv = vec2(0.0+dt,0.75+dt);\n    spect = 1.5*(texture(iChannel1, uv));\n    spect.w = texture(iChannel1, vec2(0.5+dt,0.75+dt)).x;\n\t//spect.x = 1.5*(texture(iChannel1, vec2(0.0+dt,.0)).x+texture(iChannel1, vec2(0.1,.0)).x+texture(iChannel1, vec2(0.2,.0)).x)/3.0;\n\t//spect.y = 1.*texture(iChannel1, vec2(0.5+dt,.0+dt)).x;\n\t//spect.z = 1.5*texture(iChannel1, vec2(0.75+dt,.0)).x;\n\t//spect.w = texture(iChannel1, vec2(0.5+dt,.0)).x;\n\n\tfloat Time = 0.45*(15.0 + iTime)/* - 2.*spect.w*/;\n    \n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n\t\t \n\t// camera\t\n\tvec3 ro = vec3( 4.0*cos(Time+45.), 0.5, 2.0*sin(Time) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n\n    vec3 col = render( ro, rd );\n    //col = vec3(1) - col;\n\tcol = sqrt(col);\n\t\n\tfragColor=vec4( clamp(col,0.,1.), 1.0 );\n}","name":"Image","description":"","type":"image"}]}