{"ver":"0.1","info":{"id":"llccWS","date":"1533839965","viewed":297,"name":"Concave shape SDF","username":"TLC123","description":"Concave 2d shape","likes":5,"published":1,"flags":64,"usePreview":0,"tags":["convex"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"MsSSWV","filepath":"https://soundcloud.com/yennyskev/100-wet","previewfilepath":"https://soundcloud.com/yennyskev/100-wet","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------- \n\n\n//   A little experiment with Concave shape SDFs \n\n//   The motivation was to draw fonts as SDFs, inner loops was a requirement.\n\n//   shape must be closed non intersecting loops \n    \n//   defined as a list of edges vec4(x1,y1,x2,y2)\n\n//    for each calculationg a pair of unsigned distance and one inside/outside number \n    \n//        v=v1.x<=v.x?v1:v;\n    \n//    basically the closest edge segment get first shot to call inside/outside\n   \n//        but there are some edgecases that requires extra bits\n     \n//        some logic v=  abs(v1.x-v.x)<0.001? (v1.y>v.y?v1:v):     v1.x<=v.x?v1:v; \n\n//   Generally sound sdf but some GLSL issue.  \n     \n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n// music credit to https://soundcloud.com/yennyskev/100-wet\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n\n\nvec2 shapeedge ( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n     float side = -1.*((p.x-a.x)*(b.y-a.y)-(p.y-a.y)*(b.x-a.x));\n    return vec2(dot2( pa - ba*h ) - r, sign(side)) ;\n}\n\n    // this is the hackish fudge. \n       // Ovelappig condition shold be exactly v1.x==v.x \n       // bu computer says no\n       // \n\nvec2 distlogic(vec2 v,vec2 v1){\nreturn \n    \n \n    \n    abs(v1.r-v.r)< // if distances are\n             0.00001  // closer than some fugde factor\n             *max(max(v1.r,v.r),.1)\n    // that gets a little larger further out but never below 1\n             ? (v1.g<=0. && v.g<=0.)? (v1.g<v.g?v1:v) : (v1.g>v.g?v1:v) :\n    \n            //select most positive side\n    \t\tv1.r<=v.r?v1:v; // or the common case;\n}\n\n//So hereÂ´s the problem sdshape passing arrays in GLSL must be of defined length (46)\n\nfloat sdshape(vec2 p,vec4[46] shape){\nfloat t=clamp(sin(iTime*0.5)*6.28+1.56,0.,6.28-1.56) ; \np= vec2(p.x*cos(t)-p.y*sin(t ),p.y*cos(t )+p.x*sin(t )) ;\n     vec2 v=vec2(100000000000000.0,0);\n     vec2 v1; \n     \n     \n     for( int i=0; i<shape.length() ; i++ ) {\n vec2 a = vec2(shape[i].x,shape[i].y)*clamp(sin(iTime)+1.5,-0.4,2.2) ;\n vec2 b = vec2(shape[i].z,shape[i].w)*clamp(sin(iTime)+1.5,-0.4,2.2) ;\n float r =  0.;     \n       v1=  shapeedge(   p,   a,   b,   r );\n   \n         v= distlogic(v,v1);\n     //  v= abs(v1.r-v.r)<(0.00001)*max(max(v1.r,v.r),1.)?( v1.g> 0.?v1:v): v1.r<=v.r?v1:v; \n     //   v= abs(v1.r-v.r)<0.00001?(v1.g<v.g?v:v1): v1.r<=v.r?v1:v;  \n     }\n        \n     return   sqrt(v.x)   *sign(v.y) ;    \n}\n                          \n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n\n\n \n float map(vec2 p){\n             vec4[] shape =vec4[](vec4(0.399, 0.173, 0.269, 0.173), vec4(0.269, 0.173, 0.216, 0.08), vec4(0.216, 0.08, 0.216, 0.124), vec4(0.216, 0.124, 0, 0.249), vec4(0, 0.249, -0.207, 0.129), vec4(-0.207, 0.129, -0.324, 0.129), vec4(-0.324, 0.129, -0.399, 0), vec4(-0.399, 0, -0.324, -0.129), vec4(-0.324, -0.129, -0.208, -0.129), vec4(-0.208, -0.129, 0, -0.249), vec4(0, -0.249, 0.216, -0.124), vec4(0.216, -0.124, 0.216, -0.08), vec4(0.216, -0.08, 0.269, -0.173), vec4(0.269, -0.173, 0.399, -0.173), vec4(0.399, -0.173, 0.249, -0.432), vec4(0.249, -0.432, -0.249, -0.432), vec4(-0.249, -0.432, -0.499, 0), vec4(-0.499, 0, -0.249, 0.432), vec4(-0.249, 0.432, 0.249, 0.432), vec4(0.249, 0.432, 0.399, 0.173), vec4(0.083, -0.262, 0.108, -0.377), vec4(0.108, -0.377, 0.224, -0.389), vec4(0.224, -0.389, 0.272, -0.282), vec4(0.272, -0.282, 0.185, -0.203), vec4(0.185, -0.203, 0.083, -0.262), vec4(-0.224, -0.216, -0.274, -0.303), vec4(-0.274, -0.303, -0.224, -0.389), vec4(-0.224, -0.389, -0.124, -0.389), vec4(-0.124, -0.389, -0.074, -0.303), vec4(-0.074, -0.303, -0.124, -0.216), vec4(-0.124, -0.216, -0.224, -0.216), vec4(-0.224, 0.389, -0.273, 0.318), vec4(-0.273, 0.318, -0.248, 0.235), vec4(-0.248, 0.235, -0.167, 0.203), vec4(-0.167, 0.203, -0.092, 0.246), vec4(-0.092, 0.246, -0.079, 0.332), vec4(-0.079, 0.332, -0.138, 0.396), vec4(-0.138, 0.396, -0.224, 0.389), vec4(0.088, 0.353, 0.078, 0.277), vec4(0.078, 0.277, 0.124, 0.216), vec4(0.124, 0.216, 0.2, 0.206), vec4(0.2, 0.206, 0.261, 0.253), vec4(0.261, 0.253, 0.271, 0.328), vec4(0.271, 0.328, 0.224, 0.389), vec4(0.224, 0.389, 0.149, 0.399), vec4(0.149, 0.399, 0.088, 0.353));\nreturn min(sdshape(p,shape),\n          min( length (p-vec2(1.,0.))-0.2, max(abs(p.x+1.0),abs(p.y))-0.2)\n          );       \n                          }\n                          \n \n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------                        \n                          \n                          \nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\nuv*=3.+sin(iTime+2.)*2.4;\n \n    \n    float d = map (uv);\n        //distanceToBiCapsule(uv, v0, v1, r0, r1);\n    //float d = distance(p, uv);\n    \n    float stripe = smoothstep(0.4, 0.6, abs(fract(d * 10.0) * 2.0 - 1.0));\n    fragColor = vec4((vec3(stripe) * 0.4 + 0.8) * vec3(d * 0.1, 1.0 - d * 0.5, d * 0.2), 1.0);\n    \n    //fragColor.rgb -= smoothstep(0.9, 1.0, min(distance(uv, v0) / r0, distance(uv, v1) / r1)) * 0.25;\n    \n    fragColor.rgb *= mix(0.3, 1.0, smoothstep(0.0, 0.01, d));\n}","name":"Image","description":"","type":"image"}]}