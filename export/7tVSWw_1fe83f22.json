{"ver":"0.1","info":{"id":"7tVSWw","date":"1640830114","viewed":135,"name":"Live coding","username":"ObstacleOnion","description":"Followed along this video https://www.youtube.com/watch?v=GAhu4ngQa48 All credit to him!","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["fun"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRr","filepath":"/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","previewfilepath":"/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define S(a, b, t) smoothstep(a, b, t)\n\n// distance to a line segment, by projecting your point onto the line\nfloat DistLine( vec2 p, vec2 a, vec2 b ) {\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot( pa, ba ) / dot(ba, ba), 0.0, 1.0 );\n    \n    return length( pa - ba * t );\n}\n\n// 2-to-1 hash\nfloat N21( vec2 p ) {\n    p = fract( p * vec2( 233.34, 851.73 ) );\n    p += dot( p, p + 23.45 );\n    return fract( p.x * p.y );\n}\n\n// 2-to-2 hash\nvec2 N22( vec2 p ){\n    float n = N21( p );\n    return vec2( n, N21( p + n ) );\n}\n\n// get the position for a given grid id, and offset for the neighbor cells\nvec2 GetPos( vec2 id, vec2 offset ){\n    vec2 n = N22( id + offset )*iTime;\n    return offset + vec2( sin( n.x ), cos( n.y ) ) * 0.4; \n}\n\n// distance to a line, but with the mapping applied\nfloat Line( vec2 p, vec2 a, vec2 b ){\n    float d = DistLine( p, a, b );\n    \n    float m = S( 0.03, 0.01, d );\n    \n    float d2 = length(a-b);\n    \n    m *= S(1.2, 0.8, d2)*0.5 + S(0.05, 0.03, abs(d2 - 0.75));\n    return m;\n}\n\nfloat Layer(vec2 uv) {\n\n    float m = 0.0;\n // creating grid cells across the screen\n    vec2 gv = fract( uv ) - 0.5; // position within the grid cell\n    vec2 id = floor( uv );      // the id of the grid cell\n    \n    vec2 p[ 9 ]; // randomly moving points, for the neighboring cells\n    \n    int i = 0; // loop across these neighbors\n    for(float y = -1.0; y <= 1.0; y++ )\n        for(float x = -1.0; x <= 1.0; x++ )\n            p[ i++ ] = GetPos( id, vec2( x, y ) ); // get the random position for all neigbhors\n\n    float t = iTime * 10.0;\n\n    for( int j = 0; j < 9; j++ ){\n        m += Line( gv, p[ 4 ], p[ j ] ); // evaluate lines between current cell position and neighbors\n        \n        vec2 a = (p[j] - gv) * 20.;\n        float sparkle = 1. / dot(a,a);\n        \n        m += sparkle * (sin(t + fract(p[j].x) * 10.) * 0.5 + 0.5);\n        \n    }\n      \n     m += Line(gv, p[1], p[3]);\n     m += Line(gv, p[1], p[5]);\n     m += Line(gv, p[7], p[3]);\n     m += Line(gv, p[7], p[5]);\n     \n     return m;\n  }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // mapped point on the screen\n    vec2 uv = ( fragCoord - 0.5 * iResolution.xy ) / iResolution.y;\n    //uv *= 5.0; // rescale this to have more range on the screen\n    \n    vec2 mouse = (iMouse.xy / iResolution.xy) - 0.5;\n    \n    float gradient = uv.y;\n    \n    //float m = Layer(uv * 10.0); // initial value of mapped distance\n    float m = 0.0;\n    \n    float t = iTime * 0.1;\n    \n    float s = sin(t);\n    float c = cos(t);\n    \n    //mat2 rot = mat2(c, -s, s, c);\n    mat2 rot =mat2(1.,0.,1.,0.);\n    uv *= rot;\n    mouse *= rot;\n    \n    for (float i = 0.0; i < 1.0; i+= 1./4.) {\n        float z = fract(i + t);\n        float size = mix(10.0, 0.5, z); \n        \n        \n        float fade = S(0.0, 0.5, z) * S(1.0, 0.8, z);\n        \n        m += Layer(uv * size + (i*20.0) - mouse) * fade;\n        \n    }\n    \n    vec3 base = sin(t * 5.0 *vec3(0.345, 0.456, 0.657)) * 0.4 + 0.6;\n    \n      \n    // color is mapped distance to line\n    vec3 col = m * base;\n    \n    float fft = texelFetch( iChannel0, ivec2(0,0), 0).x;\n    \n    gradient *= fft;\n    \n    col -= gradient * base;\n\n    // draw outlines between grid cells \n    //if( gv.x > 0.48 || gv.y > 0.48 )\n      // col = vec3( 1.0, 0.0, 0.0 ); // color red on the boundary\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}