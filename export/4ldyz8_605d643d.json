{"ver":"0.1","info":{"id":"4ldyz8","date":"1531529885","viewed":571,"name":"Abstract shapes with SDF","username":"JohanFlod","description":" For learning purposes I comment a lot. I am grateful for any feedback I get :)  Thanks to Shane for helping me out. \n\n","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","distancefield","sdf","modelling","intersect","boolean","difference","union"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\nAn excersise in making unions/intersections/difference \nwith signed distance function (SDF) primitives. A little bit of domain manipulation as well.    \n\nWithout these resources it would not have been possible :) \n\nhttps://thebookofshaders.com/\n\ndistance functions for primitives\n\nhttps://iquilezles.org/articles/distfunctions\n\nDomain manipulation operators and even more primitives \n\nhttp://mercury.sexy/hg_sdf/\n\n*/\n\n#define FAR 15.\n#define PI 3.14159265\n#define HALF_PI 1.57079632679\n\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat map(vec3 p)\n{\n    \n    \n    float c_z= floor((p.z + 1.0)/2.0);\n    \n    // Domain manipulation. Duplicate indefinately in xz direction\n    p.xz = mod(p.xz,2.) -1.;\n    \n    // Domain manipulation. Duplicate indefinately in xz direction\n    p.y = mod(p.y,.7) -.35;\n    \n    // Domain manipulation. Duplicate objects around a point\n    float c = pModPolar(p.xz,4.); p -= vec3(.6,0,0);\n   \n    // Create a number of spheres\n    float sphere1 = length(p)-.42;\n    float sphere4 = length(p)-.32;\n    float sphere5 = length(p)-.32;\n    \n    // Create a cube\n    float cube1 = length(max(abs(p)-.32,0.0));\n   \n    // Intersect \n    p -= vec3(0.,0.,0.);\n    \n    // Rotate 45 degrees in y towards x \n    pR(p.yx,(HALF_PI));\n    \n    // Make Cylinder\n    float cylinder = fCylinder(p,.20,2.2);\n    // Rotate cylinder by 45 degrees in y towards x  \n    pR(p.yx,(HALF_PI));\n    float cylinder2 = fCylinder(p,.20,2.2);\n    pR(p.yz,(HALF_PI));\n    float cylinder3 = fCylinder(p,.20,2.2);\n    \n    // Here comes some booleans expressions \n    // Calculate intersection with cube and sphere\n    float intersect = max(cube1,sphere1);\n    \n    // Calculate difference \n    float difference2 = max(intersect,-cylinder);\n    float difference3 = max(difference2,-cylinder2);\n    float difference4 = max(difference3,-cylinder3);\n    float difference5 = max(difference4,-sphere4); \n    \n    return difference5;\n}\n\n\n\n\nfloat trace(vec3 o, vec3 r)\n{\n    // start with zero distance\n\tfloat t = 0.0;\n    // i is number of samples along the ray\n    for (int i = 0; i < 128; ++i) {\n        \n        // Current distance to nearest point in the scene\n    \tfloat d = map(o + r * t);\n        \n        /* If the ray comes within .001 units of the surface consider it a hit, and break. Also break if the \n\t\treay overshoots the maximum distance set, FAR\n\t\t*/\n        if ( d<.001 || t>FAR) break;\n        \n        // advance the ray\n        t += d;\n    }\n    \n    // cap distance to the maximum\n    \n    return min(t, FAR);\n\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // coordinate system from -1 to +1\n    // correct aspect ratio\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n\n    // ray/camera where third coordinate is Field of View\n   \tvec3 r = normalize(vec3(uv, .9));\n    \n    // rotate the ray/camera\n    \n    float the = 0.1*iTime;\n    r.xz *= mat2(cos(the), -sin(the), sin(the), cos(the));\n    \n    // camera position\n    vec3 o = vec3(0.0, -0.2*iTime, -0.4*iTime);\n    \n    float t = trace(o,r);\n    \n    // things further away gets darker\n    // fog based on camera to surface distance. \n    \n    vec3 intersection = o + r * t;\n    \n    float fog = 1.0 / (1.0 + t * t * 0.4);\n    \n    vec3 fc = vec3(fog);\n   \n   \n    fragColor = vec4(fc,1.0);\n    \n    vec3 p = o + r*t;\n    float diff = max(map(p + .5773*.001) - map(p),0.)/.001*.5773;\n    fragColor = ((diff + .5))*vec4(fog);\n    \n    fragColor = sqrt(max(fragColor,0.));\n\t\n}","name":"Image","description":"","type":"image"}]}