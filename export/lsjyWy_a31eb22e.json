{"ver":"0.1","info":{"id":"lsjyWy","date":"1493683780","viewed":412,"name":"Tetrahedron Environment Mapping","username":"ggtsu","description":"Maps 2D UV space into an 3D using a tetrahedron projection transformation. Was looking for a simple way to project an environment map onto a 2D plane with minimal number of projection planes with an even 2d distribution and utilization.","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["tetrahedron","cubemapping","environmentmapping","sphereprojection","envmapping"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MOD3 vec3(443.8975,397.2973, 491.1871)\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\n\n\nvec3 map_tetrahedron(vec2 uv) {\n \tvec3 uvw;\n    \n    //y is simple\n \tuvw.y = uv.y*2.0 - 1.0;\n    \n    //z could probably be simpler...\n    uvw.z = 2.0*abs(1.0 - abs(1.0 - (uv.x*2.0 - 1.0*uv.y))) - 1.0;\n    \n    \n    //x is inverted for the back of the tetrahedron projection\n    if (uv.x < 0.5) { //map to front\n        uvw.x = uv.x*4.0 - 1.0;\n    } else { //map to back\n        uvw.x = (1.0 - uv.x)*4.0 - 1.0;\n\n    }\n    return uvw;\n    \n}\n\nvec2 unmap_tetrahedron(vec3 uvw) {\n \tvec2 uv;\n    float d = 0.5*dot(uvw.xyz, uvw.xyz);\n    \n    //calc distance to planes\n    float d0 = dot(uvw.xyz, 0.5*vec3( 1,  1,  1))/d;\n    float d1 = dot(uvw.xyz, 0.5*vec3(-1, -1,  1))/d;\n    float d2 = dot(uvw.xyz, 0.5*vec3( 1, -1, -1))/d;\n    float d3 = dot(uvw.xyz, 0.5*vec3(-1,  1, -1))/d;\n    \n    //project onto tetrahedron planes\n    uvw /= max(d0, max(d1, max(d2, d3)));\n    \n    //y is easy\n\tuv.y = uvw.y*0.5 + 0.5;\n    \n    //x is harder as we determine if we are on the back or front tetrahedron faces\n    if (  ( uvw.x + uvw.y > 0.0 && uvw.y + uvw.z > 0.0 && -uvw.z - uvw.x < 0.0)\n       || ( uvw.x + uvw.y < 0.0 &&-uvw.y + uvw.z > 0.0 &&  uvw.z - uvw.x > 0.0)) {\n        uv.x = 0.5 - 0.25*uvw.x + 0.25;\n    }  else {\n        uv.x = 0.25*uvw.x + 0.25;\n    }\n\n\n    return uv;\n    \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 tetracoords = map_tetrahedron(uv);\n    \n    float t = 0.25*iTime;\n    mat3 rot= mat3( cos(t), 0, sin(t),\n                    0     , 1, 0     ,\n                   -sin(t), 0, cos(t));\n                   \n    tetracoords = rot*tetracoords;\n    \n    //test unmapping by projecting onto a sphere reflection\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3((-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0), 1.0));\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tfloat t2 = sphere(ro, rd, p, 1.5);\n\tvec3 nml = normalize(p - (ro+rd*t2));\n\trd = reflect(rd, nml);\n    \n    vec2 unmapped_tetracoords = unmap_tetrahedron(rd);\n    \n    vec4 blur_avg = vec4(0);\n    vec3 rand = hash32(uv);\n    \n    //can apply blur environment map in 2d space!\n    for (float i = -4.0; i <= 4.0; i++) {\n        for (float j = -4.0; j <= 4.0; j++) {\n            float weight = 1.0/(1.0 + sqrt(i*i + j*j));\n            vec2 offset = vec2(rand.x + i, (rand.y + j)*2.0)*0.005;\n            vec3 tetracoords2 = map_tetrahedron(unmapped_tetracoords + offset);\n            tetracoords2 = rot*tetracoords2;\n            vec3 s = texture(iChannel0, tetracoords2).xyz;\n            blur_avg.xyz += weight*s*s;\n            blur_avg.w += weight;\n        }\n    }\n    blur_avg.xyz /= blur_avg.w;\n    blur_avg.xyz = sqrt(blur_avg.xyz);\n   \n    \n\tfragColor = mix(texture(iChannel0, tetracoords), blur_avg, step(0.0, t2));//;//texture(iChannel0, uvw);\n}","name":"Image","description":"","type":"image"}]}