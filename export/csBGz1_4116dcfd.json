{"ver":"0.1","info":{"id":"csBGz1","date":"1667670028","viewed":171,"name":"Path Tracing with Halton (QMC)","username":"UUNagato","description":"Quasi-Monte Carlo, with multiple importance sampling and halton sampler.\nBorrowed codes from Path tracing cornellbox with MIS (https://www.shadertoy.com/view/4lfcDr)\nWish there's no bug :-)","likes":11,"published":1,"flags":0,"usePreview":1,"tags":["pathtracingquasimontecarlo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Codes adopted from https://www.shadertoy.com/view/4lfcDr\n#define INFINITY 9999999.0\n#define PI 3.141592653589\n#define PIOVER2 1.5707963268\n#define PIOVER4 0.7853981634\n#define NUM_SAMPLES 32\n#define NUM_BOUNCES 3\n\n#define BxDF_LAMBERTIAN 0u\n#define BxDF_SPECULAR 1u\n#define BxDF_REFRACTION 2u\n\n// make sure the resolution x and y is smaller than the value below.\n// we spread halton first two dimensions on a every 128x128 pixels.\n// we don't directly spread to real resolution due to float-point precision and longer computation time.\n#define kMaxResolution 128\n#define XSCALE 128  // 2^7\n#define XEXP 7\n#define YSCALE 243  // 3^5\n#define YEXP 5\n\nfloat light_size;\nfloat light_area;\n//vec3 light_position = vec3(0, 0.97, 0);\nvec3 light_position;\nvec3 light_normal;\nint seed;\nvec4 light_albedo;\nint flat_idx;\n\n\n// concentric disk sampling because we used QMC, it better keeps stratification property.\nvec2\nsample_disk(vec2 uv)\n{\n    vec2 uvOffset = uv * 2.0 - 1.0;\n    if (uvOffset.x == 0.0 || uvOffset.y == 0.0)\n        return vec2(0, 0);\n\tfloat theta, r;\n    if (abs(uvOffset.x) > abs(uvOffset.y)) {\n        r = uvOffset.x;\n        theta = PIOVER4 * (uvOffset.y / uvOffset.x);\n    } else {\n        r = uvOffset.y;\n        theta = PIOVER2 - PIOVER4 * (uvOffset.x / uvOffset.y);\n    }\n    return r * vec2(cos(theta), sin(theta));\n}\n\nvec3\nsample_cos_hemisphere(vec2 uv)\n{\n\tvec2 disk = sample_disk(uv);\n\treturn vec3(disk.x, sqrt(max(0.0, 1.0 - dot(disk, disk))), disk.y);\n}\n\nmat3\nconstruct_ONB_frisvad(vec3 normal)\n{\n\tmat3 ret;\n\tret[1] = normal;\n\tif(normal.z < -0.999805696) {\n\t\tret[0] = vec3(0.0, -1.0, 0.0);\n\t\tret[2] = vec3(-1.0, 0.0, 0.0);\n\t}\n\telse {\n\t\tfloat a = 1.0 / (1.0 + normal.z);\n\t\tfloat b = -normal.x * normal.y * a;\n\t\tret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);\n\t\tret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);\n\t}\n\treturn ret;\n}\n\n// ===========================================================================\n// Halton Sampler\nfloat prims_list[16] = float[]( 2., 3., 5., 7., 11., 13., 17., 19., 23., 29., 31., 37., 41., 43., 47., 53. );\n// Scramble list, prime 2 and 3 are used for pixel coordinate sample and inverse radical inverse, so they\n// are not permutated.\nfloat perms[381] = float[] (0.,1.,0.,1.,2.,4.,3.,1.,2.,0.,1.,4.,6.,0.,2.,5.,3.,2.,9.,8.,10.,0.,6.,7.,3.,1.,\n4.,5.,1.,8.,11.,6.,12.,2.,7.,5.,10.,0.,9.,3.,4.,8.,2.,15.,0.,1.,12.,11.,13.,14.,7.,9.,10.,4.,6.,5.,3.,16.,\n12.,3.,10.,17.,11.,13.,6.,18.,14.,15.,5.,4.,8.,7.,2.,1.,0.,16.,9.,17.,15.,11.,1.,21.,5.,2.,3.,10.,4.,13.,\n14.,22.,20.,16.,6.,12.,19.,7.,8.,0.,9.,18.,2.,18.,26.,25.,12.,22.,24.,28.,10.,17.,3.,0.,11.,5.,8.,16.,6.,\n1.,14.,27.,19.,23.,4.,9.,7.,20.,15.,21.,13.,20.,15.,26.,4.,11.,25.,27.,12.,3.,30.,18.,21.,1.,9.,29.,23.,\n10.,0.,16.,7.,19.,8.,24.,14.,2.,13.,17.,5.,22.,28.,6.,8.,1.,9.,17.,11.,30.,6.,3.,7.,16.,36.,25.,10.,18.,\n28.,2.,23.,20.,0.,19.,4.,32.,26.,14.,33.,15.,21.,31.,5.,27.,12.,34.,22.,24.,13.,35.,29.,0.,32.,31.,17.,\n1.,40.,3.,6.,8.,9.,35.,26.,22.,14.,13.,25.,39.,12.,23.,33.,27.,5.,30.,36.,38.,24.,4.,7.,28.,19.,21.,10.,\n11.,2.,18.,34.,20.,37.,16.,15.,29.,4.,27.,28.,8.,29.,14.,2.,3.,9.,11.,19.,21.,25.,0.,16.,40.,23.,42.,38.,\n36.,7.,26.,41.,10.,17.,24.,33.,12.,22.,6.,13.,37.,15.,31.,32.,1.,30.,35.,39.,18.,5.,34.,20.,32.,13.,7.,8.,\n36.,6.,2.,39.,0.,34.,1.,4.,23.,18.,19.,41.,5.,30.,26.,42.,25.,10.,29.,27.,44.,43.,31.,46.,15.,3.,21.,37.,\n9.,35.,11.,12.,16.,38.,17.,28.,45.,22.,40.,24.,20.,33.,14.,17.,6.,16.,29.,46.,31.,25.,47.,14.,48.,41.,10.,\n45.,32.,21.,26.,33.,28.,3.,52.,36.,35.,4.,2.,42.,22.,19.,18.,5.,0.,34.,38.,24.,37.,7.,30.,11.,27.,12.,8.,\n13.,20.,23.,50.,44.,39.,49.,9.,43.,1.,15.,40.,51.);\nint permindex[16] = int[] (0, 2, 5, 10, 17, 28, 41, 58, 77, 100, 129, 160, 197, 238, 281, 328);\n\nint dim_index = 0;\nint seq_index = 0;\nvec2 multInverse = vec2(59, 131);\n\n// scramble is just a random shuffle of digits (although I have fixed the permutation).\n// It's because for higher base number, halton shows an obvious regular pattern.\nvec2 scramble(vec2 number)\n{\n    int index1 = permindex[dim_index] + int(number.x);\n    int index2 = permindex[dim_index + 1] + int(number.y);\n    vec2 ret = vec2(perms[index1], perms[index2]);\n    return ret;\n}\n\nvec2 halton(vec2 prims, vec2 a)\n{\n    vec4 tmp = vec4(1, 1, 0, 0);\n    while (a.x > 0. || a.y > 0.)\n    {\n        tmp.xy /= prims;\n        // non-scramble version\n        // tmp.zw += tmp.xy * mod(a.xy, prims);\n        // scramble version\n        tmp.zw += tmp.xy * scramble(mod(a.xy, prims));\n        a = floor(a / prims);\n    }\n    return tmp.zw;\n}\n\nvec2 inverseRadicalInverse(vec2 a)\n{\n    vec2 tmp = vec2(0, 0);\n    vec2 prims = vec2(prims_list[0], prims_list[1]);\n    // it almost always holds unless you have vertical screen.\n    // so I just assume XEXP > YEXP\n    int common_stop = YEXP;\n    int left_loop = XEXP - YEXP;\n    for (int i = 0; i < common_stop; ++i)\n    {\n        vec2 digit = mod(a.xy, prims);\n        a = floor(a / prims);\n        tmp = tmp * prims + digit;\n    }\n    for (int i = 0; i < left_loop; ++i)\n    {\n        float digit = mod(a.x, prims.x);\n        a.x = floor(a.x / prims.x);\n        tmp.x = tmp.x * prims.x + digit;\n    }\n    return tmp;\n}\n\nvec2 get_random()\n{\n    vec2 dimprim = vec2(prims_list[dim_index], prims_list[dim_index + 1]);\n    vec2 ret = halton(dimprim, vec2(seq_index, seq_index));\n    dim_index += 2;\n    return ret;\n}\n\nvec2 get_camera_random()\n{\n    // it's special because some digits for base 2 and 3 are used to determine pixel coordiantes.\n    // so we need to skip them to compute frational part.\n    vec2 index = vec2(seq_index >> XEXP, seq_index / YSCALE);\n    vec2 dimprim = vec2(prims_list[dim_index], prims_list[dim_index + 1]);\n    vec2 ret = halton(dimprim, index);\n    dim_index += 2;\n    return ret;\n}\n\n// compute an offset for current pixel.\n// Halton sequence will sample the same pixel every XSCALE x YSCALE samples.\n// so we need to find the offset index for the first sample.\n// it's actually trying to find an integer i that:\n// dimOffset.x = i mod 2^7\n// dimOffset.y = i mod 3^5\n// The solution is from Enumerating Quasi-Monte Carlo Point Sequences in Elementary Intervals\nint get_pixel_offset(vec2 fragCoord, ivec2 resolution)\n{\n    int stride = XSCALE * YSCALE;  // every stride samples back to this pixel\n    vec2 points = mod(fragCoord, vec2(kMaxResolution, kMaxResolution));\n    vec2 dimOffset = inverseRadicalInverse(points);\n    vec2 offsetForCurrentPixel = dimOffset * vec2(YSCALE, XSCALE) * multInverse;\n    int ret = int(mod(offsetForCurrentPixel.x * offsetForCurrentPixel.y, float(stride)));\n    return ret;\n}\n\nint get_pixel_index(int i, int pixelOffset)\n{\n    int stride = XSCALE * YSCALE;\n    return pixelOffset + i * stride;\n}\n\n// ===========================================================================\n\n/*\nvoid\nencrypt_tea(inout uvec2 arg)\n{\n\tuvec4 key = uvec4(0xa341316c, 0xc8013ea4, 0xad90777d, 0x7e95761e);\n\tuint v0 = arg[0], v1 = arg[1];\n\tuint sum = 0u;\n\tuint delta = 0x9e3779b9u;\n\n\tfor(int i = 0; i < 32; i++) {\n\t\tsum += delta;\n\t\tv0 += ((v1 << 4) + key[0]) ^ (v1 + sum) ^ ((v1 >> 5) + key[1]);\n\t\tv1 += ((v0 << 4) + key[2]) ^ (v0 + sum) ^ ((v0 >> 5) + key[3]);\n\t}\n\targ[0] = v0;\n\targ[1] = v1;\n}\n\nvec2\nget_random()\n{\n  \tuvec2 arg = uvec2(flat_idx, seed++);\n  \tencrypt_tea(arg);\n  \treturn fract(vec2(arg) / vec2(0xffffffffu));\n}\n*/\n\nstruct Ray\n{\n\tvec3 origin, dir;\n};\n\nstruct AABB\n{\n\tvec3 min_, max_;\n};\n\nmat4\nrotate_y(float a)\n{\n\tmat4 ret = mat4(1.0);\n\tret[0][0] = ret[2][2] = cos(a);\n\tret[0][2] = sin(a);\n\tret[2][0] = -ret[0][2];\n\treturn ret;\n}\n\nvec3\nsample_light(vec2 rng)\n{\n\treturn light_position + vec3(rng.x - 0.5, 0, rng.y - 0.5) * light_size;\n}\n\nbool\nintersect_aabb(in Ray ray, in AABB aabb, inout float t_min, inout float t_max)\n{\n\tvec3 div = 1.0 / ray.dir;\n\tvec3 t_1 = (aabb.min_ - ray.origin) * div;\n\tvec3 t_2 = (aabb.max_ - ray.origin) * div;\n\n\tvec3 t_min2 = min(t_1, t_2);\n\tvec3 t_max2 = max(t_1, t_2);\n\n\tt_min = max(max(t_min2.x, t_min2.y), max(t_min2.z, t_min));\n\tt_max = min(min(t_max2.x, t_max2.y), min(t_max2.z, t_max));\n\n\treturn t_min < t_max;\n}\n\nvec3\nray_at(in Ray ray, float t)\n{\n\treturn ray.origin + t * ray.dir;\n}\n\nfloat\nintersect_plane(\n\tRay ray,\n    vec3 center,\n    vec3 normal)\n{\n    float denom = dot(ray.dir, normal);\n    float t = dot(center - ray.origin, normal) / denom;\n\treturn t > 0.0 ? t : INFINITY;\n}\n\nfloat\nintersect_box(Ray ray, out vec3 normal, vec3 size)\n{\n\tfloat t_min = 0.0;\n\tfloat t_max = 999999999.0;\n\tif(intersect_aabb(ray, AABB(-size, size), t_min, t_max)) {\n\t\tvec3 p = ray_at(ray, t_min);\n\t\tp /= size;\n\t\tif(abs(p.x) > abs(p.y)) {\n\t\t\tif(abs(p.x) > abs(p.z)) {\n\t\t\t\tnormal = vec3(p.x > 0.0 ? 1.0 : -1.0, 0, 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t\t}\n\t\t}\n\t\telse if(abs(p.y) > abs(p.z)) {\n\t\t\tnormal = vec3(0, p.y > 0.0 ? 1.0 : -1.0, 0);\n\t\t}\n\t\telse {\n\t\t\tnormal = vec3(0, 0, p.z > 0.0 ? 1.0 : -1.0);\n\t\t}\n\n\t\treturn t_min;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect_sphere(Ray ray, vec3 center, float radius)\n{\n    vec3 op = center - ray.origin;\n    float t, eps = 1e-4f, b = dot(op, ray.dir), det = b * b - dot(op, op) + radius * radius;\n    if (det < 0.)\n        return INFINITY;\n    else\n        det = sqrt(det);\n    \n    return (t = b - det) > eps ? t : ((t = b + det) > eps ? t : INFINITY);\n}\n\nfloat\nintersect_light(Ray ray)\n{\n\tfloat t = intersect_plane(ray, light_position, light_normal);\n\n\tvec3 p = ray_at(ray, t);\n\tif(all(lessThan(abs(light_position - p).xz, vec2(light_size * 0.5)))) {\n\t\treturn t;\n\t}\n\n\treturn INFINITY;\n}\n\nfloat\nintersect(Ray ray, inout vec3 p, inout vec3 normal, out vec4 albedo, out uint bxdf)\n{\n\tfloat t_min = INFINITY;\n\n\talbedo = vec4(0.0);\n\n\t{\n\t\tfloat t = intersect_light(ray);\n\t\tif(t < t_min) {\n\t\t\t//albedo = vec3(100);\n\t\t\talbedo = light_albedo;\n\t\t\t//albedo = vec3(dot(ray.dir, light_normal) < 0.0 ? 1.0 : 0.0);\n\t\t\tnormal = light_normal;\n\t\t\tt_min  = t;\n            bxdf = BxDF_LAMBERTIAN;\n\t\t\tp = ray_at(ray, t);\n\t\t}\n\t}\n\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\t//mat4 r = rotate_y(scene_time);\n\t\tmat4 r = rotate_y(0.3);\n\t\tray_tmp.origin -= vec3(-0.35, -0.5, -0.35);\n\t\tray_tmp.dir = vec3(r * vec4(ray_tmp.dir, 0));\n\t\tray_tmp.origin = vec3(r * vec4(ray_tmp.origin, 1.0));\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.5, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tnormal = vec3(transpose(r) * vec4(normal_tmp, 0.0));\n            bxdf = BxDF_LAMBERTIAN;\n\t\t}\n\t}\n\n\t{\n\t\tvec3 normal_tmp;\n\t\tRay ray_tmp = ray;\n\t\tray_tmp.origin -= vec3(0.5, -0.75, 0.35);\n\t\tfloat t = intersect_box(ray_tmp, normal_tmp, vec3(0.25, 0.25, 0.25));\n\t\tif(t < t_min) {\n\t\t\tt_min = t;\n\t\t\tp = ray_at(ray, t);\n\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n\t\t\tnormal = normal_tmp;\n            bxdf = BxDF_LAMBERTIAN;\n\t\t}\n\t}\n\n    // specular sphere\n    {\n        float t= intersect_sphere(ray, vec3(-0.35, -0.75, 0.35), 0.25);\n        if(t < t_min) {\n            t_min = t;\n            p = ray_at(ray, t);\n            albedo = vec4(0.95, 0.95, 1.0, 0);\n            normal = normalize(p - vec3(-0.35, -0.75, 0.35));\n            bxdf = BxDF_SPECULAR;\n        }\n    }\n/*    \n    // refraction sphere, not done yet.\n    {\n        float t= intersect_sphere(ray, vec3(0.5, -0.75, 0.15), 0.25);\n        if(t < t_min) {\n            t_min = t;\n            p = ray_at(ray, t);\n            albedo = vec4(0.95, 0.95, 1.0, 0);\n            normal = normalize(p - vec3(-0.35, -0.75, 0.35));\n            bxdf = BxDF_REFRACTION;\n        }\n    }\n*/\n\t// left\n\t{\n\t\tvec3 n = vec3(1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(-1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tt_min = t;\n                bxdf = BxDF_LAMBERTIAN;\n\t\t\t\talbedo = vec4(0.9, 0.1, 0.1, 0);\n\t\t\t}\n\t\t}\n\t}\n\t// right\n\t{\n\t\tvec3 n = vec3(-1, 0, 0);\n\t\tfloat t = intersect_plane(ray, vec3(1, 0, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThanEqual(p_tmp.yz, vec2(1))) && all(greaterThanEqual(p_tmp.yz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\tt_min = t;\n                bxdf = BxDF_LAMBERTIAN;\n\t\t\t\talbedo = vec4(0.1, 0.9, 0.1, 0);\n\t\t\t}\n\t\t}\n\t}\n\t// floor\n\t{\n\t\tvec3 n = vec3(0, 1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, -1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n                bxdf = BxDF_LAMBERTIAN;\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t// ceiling\n\t{\n\t\tvec3 n = vec3(0, -1, 0);\n\t\tfloat t = intersect_plane(ray, vec3(0, 1, 0), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xz, vec2(1))) && all(greaterThan(p_tmp.xz,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n                bxdf = BxDF_LAMBERTIAN;\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\t// back wall\n\t{\n\t\tvec3 n = vec3(0, 0, 1);\n\t\tfloat t = intersect_plane(ray, vec3(0, 0, -1), n);\n\t\tif(t < t_min) {\n\t\t\tvec3 p_tmp = ray_at(ray, t);\n\t\t\tif(all(lessThan(p_tmp.xy, vec2(1))) && all(greaterThan(p_tmp.xy,\n\t\t\t\t\t\t\tvec2(-1))))\n\t\t\t{\n\t\t\t\tnormal = n;\n\t\t\t\tp = p_tmp;\n\t\t\t\talbedo = vec4(0.7, 0.7, 0.7, 0);\n                bxdf = BxDF_LAMBERTIAN;\n\t\t\t\tt_min = t;\n\t\t\t}\n\t\t}\n\t}\n\n\n\tnormal = normalize(normal);\n\n\treturn t_min;\n}\n\nbool\ntest_visibility(vec3 p1, vec3 p2)\n{\n\tconst float eps = 1e-5;\n\n\tRay r = Ray(p1, normalize(p2 - p1));\n\tr.origin += eps * r.dir;\n\n\tvec3 n, p;\n\tvec4 a; // ignored\n    uint b; // ignored\n\tfloat t_shadow = intersect(r, p, n, a, b);\n\n\treturn t_shadow > distance(p1, p2) - 2.0 * eps;\n}\n\nvec3\npt_mis(Ray ray)\n{\n\tvec3 contrib = vec3(0);\n\tvec3 tp = vec3(1.0);\n\n\tvec3 position, normal;\n\tvec4 albedo;\n    uint bxdf;\n\tfloat t = intersect(ray, position, normal, albedo, bxdf);\n\n\tif(t == INFINITY)\n\t\treturn vec3(0.0);\n\n\tif(albedo.a > 0.0) { /* hight light source */\n\t\treturn albedo.rgb * albedo.a;\n\t}\n\n\tfor(int i = 0; i < NUM_BOUNCES; i++) {\n\t\tmat3 onb = construct_ONB_frisvad(normal);\n        \n        if (bxdf == BxDF_LAMBERTIAN)\n        {\n            { /* NEE */\n                vec3 pos_ls = sample_light(get_random());\n                vec3 l_nee = pos_ls - position;\n                float rr_nee = dot(l_nee, l_nee);\n                l_nee /= sqrt(rr_nee);\n                float G = max(0.0, dot(normal, l_nee)) * max(0.0, -dot(l_nee, light_normal)) / rr_nee;\n\n                if(G > 0.0) {\n                    float light_pdf = 1.0 / (light_area * G);\n                    float brdf_pdf = 1.0 / PI;\n\n                    float w = light_pdf / (light_pdf + brdf_pdf);\n\n                    vec3 brdf = albedo.rgb / PI;\n\n                    if(test_visibility(position, pos_ls)) {\n                        vec3 Le = light_albedo.rgb * light_albedo.a;\n                        contrib += tp * (Le * w * brdf) / light_pdf;\n                    }\n                }\n            }\n\n            { /* brdf */\n                vec3 dir = normalize(onb * sample_cos_hemisphere(get_random()));\n\n                vec3 brdf = albedo.rgb / PI;\n\n                Ray ray_next = Ray(position, dir);\n                ray_next.origin += ray_next.dir * 1e-5;\n\n                vec3 position_next, normal_next;\n                vec4 albedo_next;\n                uint bxdf_next;\n                float t = intersect(ray_next, position_next, normal_next, albedo_next, bxdf_next);\n\n                if(t == INFINITY)\n                    break;\n\n                float brdf_pdf = 1.0 / PI;\n\n                if(albedo_next.a > 0.0) { /* hit light_source */\n                    float G = max(0.0, dot(ray_next.dir, normal)) * max(0.0, -dot(ray_next.dir, normal_next)) / (t * t);\n                    if(G <= 0.0) /* hit back side of light source */\n                        break;\n\n                    float light_pdf = 1.0 / (light_area * G);\n\n                    float w = brdf_pdf / (light_pdf + brdf_pdf);\n\n                    vec3 Le = light_albedo.rgb * light_albedo.a;\n                    contrib += tp * (Le * w * brdf) / brdf_pdf;\n\n                    break;\n                }\n\n                tp *= brdf / brdf_pdf;\n\n                position = position_next;\n                normal = normal_next;\n                albedo = albedo_next;\n                bxdf = bxdf_next;\n            }\n        }\n        else if (bxdf == BxDF_SPECULAR)\n        {\n            // perfect specular is a dirac function, so no need to sample light source since it's definitely 0 brdf.\n            vec3 dir = normalize(reflect(ray.dir, normal));\n            Ray ray_next = Ray(position, dir);\n            ray_next.origin += ray_next.dir * 1e-5;\n            vec3 position_next, normal_next;\n            vec4 albedo_next;\n            uint bxdf_next;\n            float t = intersect(ray_next, position_next, normal_next, albedo_next, bxdf_next);\n            if(t == INFINITY)\n                break;\n            \n            tp *= albedo.rgb;\n            position = position_next;\n            normal = normal_next;\n            albedo = albedo_next;\n            bxdf = bxdf_next;\n        }\n        else\n        {\n            return contrib;\n        }\n\t}\n\n\treturn contrib;\n}\n\nvoid\nmainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tlight_size = 0.5;\n\tlight_area = light_size * light_size;\n\tlight_position = vec3(0.5 * sin(iTime), 0.90, 0.5 * cos(iTime));\n\tlight_normal = vec3(0, -1, 0);\n\tseed = 0;\n\tlight_albedo = vec4(1, 1, 1, 2.0 / (light_size * light_size));\n\tflat_idx = int(dot(gl_FragCoord.xy, vec2(1, 4096)));\n\n\n\tvec2 p = fragCoord.xy / vec2(iResolution) - vec2(0.5);\n\tfloat a = float(iResolution.x) / float(iResolution.y);\n\tif(a < 1.0)\n\t\tp.y /= a;\n\telse\n\t\tp.x *= a;\n\n\tvec3 cam_center = vec3(0, 0, 3.125);\n\n\tvec3 s = vec3(0);\n    int poffset = get_pixel_offset(fragCoord.xy, ivec2(iResolution.x, iResolution.y));\n\tfor(int i = 0; i < NUM_SAMPLES; i++) {\n        dim_index = 0;\n        seq_index = get_pixel_index(i, poffset);\n\t\tRay ray;\n\t\tray.origin = cam_center;\n\t\tvec2 r = get_camera_random();\n\t\tvec3 ray_dir = normalize(vec3(p + r.x * dFdx(p) + r.y * dFdy(p), -1));\n\t\tray.dir = ray_dir;\n\t\tvec3 c = pt_mis(ray);\n\t\ts += c;\n\t}\n    \n    // HDR and Gamma Correlation\n    \n\tfragColor = vec4(pow(s / float(NUM_SAMPLES), vec3(1.0 / 2.2)), 1.0);\n}","name":"Image","description":"","type":"image"}]}