{"ver":"0.1","info":{"id":"lsScDz","date":"1491584639","viewed":121,"name":"Jontte","username":"Jontte","description":"testing","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["demo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat unioni(float d1, float d2) {\n\treturn min(d1, d2);\n}\nfloat diff( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n\nvec3 g_color;\nfloat g_distance;\nvoid merge(float test_distance, vec3 test_color)\n{\n    if (test_distance < g_distance) {\n    \tg_distance = test_distance;\n        g_color = test_color;\n    } \n}\n\nfloat rand(vec3 co)\n{\n    return fract(sin(dot(co, vec3(59.319, 61.30, 67))) * 103.0);\n}\n\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n\treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec3 n4 = vec3(0.577,0.577,0.577);\nvec3 n5 = vec3(-0.577,0.577,0.577);\nvec3 n6 = vec3(0.577,-0.577,0.577);\nvec3 n7 = vec3(0.577,0.577,-0.577);\n\n// p as usual, e exponent (p in the paper), r radius or something like that\nfloat octahedral(vec3 p, float e, float r) {\n\tfloat s = pow(abs(dot(p,n4)),e);\n\ts += pow(abs(dot(p,n5)),e);\n\ts += pow(abs(dot(p,n6)),e);\n\ts += pow(abs(dot(p,n7)),e);\n\treturn pow(s, 1./e)-r;\n}\n\nmat2 rota(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n// exponential smooth min (k = 32);\n/*float smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}*/\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n// power smooth min (k = 8);\n/*float smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}*/\n\nfloat scene(vec3 p)\n{\n    g_distance = 1e9;\n    g_color = vec3(0.2);\n    \n    float t = iTime;\n    \n\n    vec3 d = p-vec3(0,0,10);\n    \n    d.xz *= rota(t);\n    d.xy *= rota(t);\n\n    float oct1 = octahedral(d, 16.0, 1.0);\n    //float oct = abs(d.x) + abs(d.y) + abs(d.z);\n    //oct *= 1.0;\n    //oct = oct - 1.0;\n    \n    d = p-vec3(0,0,10);\n    d.xz *= rota(-t*0.931);\n    d.yz *= rota(t*1.216);\n    d.xy *= rota(-t*0.123);\n\n    float oct2 = octahedral(d, 16.0, 1.0);\n    \n    float oct = smin(oct1, oct2, 0.5);\n    //oct = diff(oct1, oct+0.5);\n    \n    merge(oct, vec3(1, 0.01, 0.01));\n    \n    // maa\n    float h = -4.0;\n    merge(p.y-h, vec3(1, 0.01, 0.01));\n    \n    \n    \n    /*\n    //merge(box(p-vec3(0,0,4), vec3(1.0)), vec3(0.1, 1, 0.1));\n  \n    float cell = 4.0;\n    p += cell/2.0;\n    p.z += iTime * 1.0;\n    p = mod(p + cell/2.0, cell) - cell/2.0;\n    //merge(box(p, vec3(1.0)), vec3(1,0.01,0.01));\n   \n    merge(box(p-vec3(0,0,0), vec3(1.0)), vec3(1,0.01,0.01));\n    */\n    \n    //merge(sphere(p -vec3(0,0,5), 1.0), vec3(1,0,0));\n    \n    \n    /*\n    float r = 5.0;\n    float t = iTime / 1.0;\n    \n//    merge(sphere(p - vec3(r*sin(t), r*cos(t), 10), 3.0), vec3(0.01,1,0.01));\n//    merge(sphere(p - vec3(3, 0, 10), 1.0), vec3(0.01,0.01,1));\n  \n    \n    float cell = 4.0;\n   \t\n    //p.z += iTime*5.0;\n    //p.x += sin(iTime)*1.0;\n    */\n    \n    \n\treturn g_distance;\n}\nvec3 normal(vec3 p) {\n    float d = scene(p);\n    vec3 eps = vec3(0.01, 0.0, 0.0);\n\treturn normalize(vec3(\n    \tscene(p + eps - d),\n    \tscene(p + eps.yxy - d),\n    \tscene(p + eps.yyx - d)\n    ));\n}\n\n\nvec3 trace(vec2 coord) {\n\n\tvec3 ray = normalize(vec3(coord*0.5, 1));\n    \n    ray.xz *= rota(sin(iTime)*0.1);\n    ray.yz *= rota(sin(iTime*0.3)*0.1);\n    \n    //float a = -0.3;\n    //ray.yz = ray.yz * mat2(cos(a), sin(a), -sin(a), cos(a));\n    //a = iTime*0.12;\n    //ray.xz = ray.xz * mat2(cos(a), sin(a), -sin(a), cos(a));\n    \n    vec3 pos = vec3(0);\n    float d = 0.0;\n    bool hit = false;\n    float dist = 0.0;\n    for(int i=0; i<50; ++i){\n        \n    \tdist = scene(pos);\n        if (abs(dist) < 1e-4) {\n        \thit = true;\n            break;\n        }\n        pos += ray * dist * 1.0;\n        d += dist;\n    }\n    \n    // make a correcting jump\n    // assumes flat plane\n    float d1 = dist;\n    float s = 0.0001;\n    float d2 = scene(pos + ray * s);\n    pos += ray * (s * d1) / (d1 -d2);\n    \n    \n   \tvec3 lights = vec3(0.1); // ambient\n    \n    if (hit) {\n    \t\n\t\tvec3 n = normal(pos);\n        \n        vec3 lightdir = vec3(-1,1,-1);\n        \n        lights += max(dot(n, normalize(lightdir)), 0.0) * vec3(1.0, 10.0, 1.0); // directional\n        \n        vec3 halfvec = normalize(-ray + lightdir);\n        \n        lights += pow(max(dot(n, normalize(halfvec)), 0.0),32.0) * vec3(10000); // specular    \n        \n    }\n    \n    // fog\n    \n    return mix(vec3(0.005), g_color * lights, exp(-d*0.1));\n}\n\nvec3 vignette(vec3 color, vec2 coord) {\n    return color * smoothstep(1.0, 0.0, max(length(coord)-1.5,0.0)*2.0);\n}\n\nvec3 gamma(vec3 c) {\n\treturn pow(c, vec3(1.0/2.2));\n}\n\nvec3 filmicToneMapping(vec3 color)\n{\n\tcolor = max(vec3(0.), color - vec3(0.004));\n\tcolor = (color * (6.2 * color + .5)) / (color * (6.2 * color + 1.7) + 0.06);\n\treturn color;\n}\n\nvec3 tonemap(vec3 c) {\n    // more tonemappers: https://www.shadertoy.com/view/lslGzl\n    return filmicToneMapping(c);\n\t//return c / (c + 1.0);\n    //return c;\n}\n\n\nvec3 stack(vec2 coord) {\n    \n    vec3 color = trace(coord);\n    \n    color = tonemap(color);\n    color = vignette(color, coord);\n    color = gamma(color);\n\t\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n\tfragColor = vec4(stack(uv * 2.0),1.0);\n}","name":"Image","description":"","type":"image"}]}