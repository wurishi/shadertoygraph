{"ver":"0.1","info":{"id":"Dt2BDG","date":"1694709386","viewed":87,"name":"juliabulb shenanigans","username":"pb","description":"chains of rotating glowing juliabulbs","likes":8,"published":1,"flags":32,"usePreview":0,"tags":["raymarch","glow","juliabulb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//philip.bertani@gmail.com\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy/iResolution.xy;\n\n    //size of one texel in iChannel0\n    vec2 texel = 1./iResolution.xy;\n\n    vec4 total_color;\n    //see 5x5 gaussian weights in Common \n    for (int i=0;i<5;i++){\n        float fi = float(i)-2.;\n        for (int j=0;j<5;j++){ \n            float fj = float(j)-2.;\n            vec4 color = texture(iChannel0, \n                uv + vec2( texel.x*fi,texel.y*fj )  );\n            total_color += color * gk1s[i*5 + j];\n        }\n    }\n    \n    fragColor = total_color;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float[] params =  float[](\n3.,\n7.,\n.7,\n.0,\n.9,\n.0,\n.0,\n.0,\n.0,\n.0,\n.0,\n.0,\n.0,\n2.,\n.0,\n.0,\n.0,\n.0,\n.0,\n.0,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.\n);\n\n\n\n//gaussian_kernel_one_stdev\nfloat[] gk1s = float[] (\n        0.003765,0.015019,0.023792,0.015019,0.003765,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.023792,0.094907,0.150342,0.094907,0.023792,\n        0.015019,0.059912,0.094907,0.059912,0.015019,\n        0.003765,0.015019,0.023792,0.015019,0.003765 );\n        \n                \n/*       \nfloat[] params =  float[](\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n.1,\n0.,\n0.,\n0.,\n9.,\n0.,\n4.,\n1.,\n-2.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.\n);\n*/\n\n/*        \nfloat[] params =  float[](\n1.4,\n-.58,\n-.12,\n0.,\n0.,\n.4,\n0.6,\n.0,\n-.3,\n0.,\n17.,\n0.,\n20.,\n0.01,\n-3.,\n1.5,\n-.2,\n.0,\n.0,\n.0,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.,\n0.\n);\n*/","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\nvec3  ifs_color, ro;\nconst float maxDist=10.;\n\n\nmat2 rot2(float an) {\n    float cc=cos(an),ss=sin(an);\n    return mat2(cc,-ss,ss,cc);\n}\n\nfloat juliabulb(vec3 p) {\n\n  float power = 2. + params[1];\n\n  vec3 z = p;\n \n  float nn = 1.1;\n  z = mod(z-nn,2.*nn)-nn;\n\n  z.xy *= rot2(iTime/3. );\n\n  float iv = .8 - .6;\n  float tt = mod(iTime ,10.);\n  float pp = tt * iv / 5.; \n  if (tt>5.) pp = (10. - tt) *iv/5.;\n  vec3 julia = vec3(params[2],params[3]+ .5*sin(iTime), .8 - pp );\n  \n  float r, theta, phi=0., dr = 1.0;\n\n  for(float i = 0.; i < params[0]; ++i) {\n\n    r = length(z);\n\n    if(r > 2.0) break;\n\n    theta = atan(z.y, z.x);\n    dr = pow(r, power - 1.0) * dr * power + 1.0;\n    r = pow(r, power);\n    theta = theta * power;\n    //phi = phi * power;  //not using phi\n    \n    //difference between mandelbulb and juliabulb is the same\n    //as regular mbrot vs julia, adding a constant for julia\n    z = r * vec3(cos(theta)*cos(phi), sin(theta)*cos(phi), sin(phi)) + julia;\n    \n    //colors\n    if (z.x*z.y > 0. ) ifs_color.x ++;\n    if (z.y*z.z > 0. ) ifs_color.y ++;\n    if (z.z*z.x > 0. ) ifs_color.z ++;  \n  }\n  \n   return 0.5 * log(r) * r / dr ;\n  \n}\n\nfloat scene(vec3 p)\n{\n  //tunnelling through\n  return max( juliabulb(p), -(length(p - ro) - params[13] ) );\n}\n\n\nvec3 ifsColor(vec3 ifs_color) {\n  //go ahead and change the vec3 colors here to have some fun\n  return ifs_color.x*vec3(1.,.5,0.) + ifs_color.y*vec3(1.,1.,0.) + ifs_color.z*vec3(.2,0.,1.);\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n  vec3 col=vec3(0.), normal, pos=ro;\n\n  const int maxSteps = 90;\n  float totdist=0., d=0., glow=0.;\n  for (int j = 0; j < maxSteps; j ++) {\n    d = scene(pos);\n    pos += d*rd;\n    totdist += d*.7;\n    glow += exp(-max(1.-d,0.));\n    if (d < 1e-4*(1.+totdist*20.*(1.+params[25])) || totdist > maxDist) break;\n  }\n\n\n  ifs_color = normalize(vec3( ifs_color.x*cos( params[17]*ifs_color.x ),\n                              ifs_color.y*cos( params[18]*ifs_color.y ),\n                              ifs_color.z*cos( params[19]*ifs_color.z) ) );\n \n  \n  vec3 ifsC = .5*ifsColor(ifs_color);\n  \n  col = 6e-2*pow(1.+glow/4.,6.)*ifsC*ifsC*ifsC*ifsC*ifsC*ifsC * exp(-totdist*1.7 );\n\n  return 1.-exp( -clamp (col, 0., 1.) );\n  \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y*4.;\n    ro = vec3(iTime/5.,iTime/7.,-iTime); \n    vec3 rd = normalize( vec3( uv, -5.) );\n \n    rd.yz *= rot2(-.4);\n    rd.xz *= rot2(-.4);\n       \n    vec3 color =  sqrt( render(ro,rd) );\n    \n    fragColor = vec4( (color), 0.);\n}","name":"Buffer B","description":"","type":"buffer"}]}