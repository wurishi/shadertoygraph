{"ver":"0.1","info":{"id":"NtdcDH","date":"1659728294","viewed":145,"name":"JSB Evil Plant","username":"Legonzaur","description":"Code is ugly but I'm still learning","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["beginner","jsb","justshapesandbeats"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec2 leftEye = vec2(-0.01875,-0.0375);\nconst vec2 leftEyeStart = vec2(-0.080,-0.020);\n\nconst vec2 rightEye = vec2(0.01875,-0.0375);\nconst vec2 rightEyeStart = vec2(0.080,-0.020);\n\nconst vec2 mouth = vec2(0.000,-0.090);\n\n#define PI 3.14159265359\n\nfloat cstep(float t, float v){\n    float pixelWidth = 1./iResolution.y;\n    return smoothstep(t,t+pixelWidth,v);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat drawEyes(vec2 uv, vec2 l, vec2 r, vec2 headPos){\n    uv -= headPos;\n    uv = rotate2d( (abs(fract(PI*2.+(PI/2.)*iTime/PI)*2.-1.)-.5)/2.) * uv;\n    uv += headPos;\n    float e = step(-0.,dot(uv-l, leftEye))*cstep(1.-length(leftEye),1.-distance(uv,l));\n    e+= step(-0.,dot(uv-r, rightEye))*cstep(1.-length(rightEye),1.-distance(uv,r));\n    return 1.-e;\n}\n\nfloat teeth(vec2 uv, vec2 pos, float scale){\n  float d;\n  uv -= pos;\n  uv = uv *2./scale;\n  // Number of sides of your shape\n  int N = 3;\n  // Angle and radius from the current pixel\n  float a = atan(uv.x,uv.y)+PI;\n  float r = 2.*PI/float(N);\n  // Shaping function that modulate the distance\n  d = cos(floor(0.500+a/r)*r-a)*length(uv);\n    return d;\n}\n\nfloat drawMouth(vec2 uv, vec2 pos, vec2 headPos){\n    uv -= headPos;\n    uv = rotate2d( (abs(fract(PI*2.+(PI/2.)*iTime/PI)*2.-1.)-.5)/2.) * uv;\n    uv += headPos;\n    float e = step(-0.,dot(uv-pos, mouth))*cstep(1.-length(mouth),1.-(distance(uv,pos)-dot(uv-pos, (abs(fract(PI*1.1352+(PI/2.)*2.*(iTime+.72)/PI)*2.-1.)-.5)/2.*mouth*7.)));\n    e -= cstep(.4, 1.-teeth(uv, vec2(-0.050,-0.080)+headPos, -0.072));\n    e -= cstep(.4, 1.-teeth(uv, vec2(0.050,-0.080)+headPos, -0.072));\n    e -= cstep(.4, 1.-teeth(uv, headPos+vec2(0.00,-0.2+(abs(fract(PI*1.1352+(PI/2.)*2.*(iTime-.78)/PI)*2.-1.)-.5)/30.), 0.072));\n    return 1.-e;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius){\n\tfloat pct = 0.0;\n\tpct = distance(uv, center);\n\tpct = 1.-cstep(radius, pct);\n  return pct;\n}\n\nfloat cog(vec2 uv, vec2 pos, float size, float speed){\n    \n    uv -= vec2(pos);\n    uv = rotate2d( -iTime*PI/8.) * uv;\n    uv += vec2(pos);\n    \n\tpos -= uv;\n    float r = length(pos)*(1./size);\n    float a = atan(pos.x, pos.y);\n    float f = fract((a/(PI*2.))*8.);\n    float an = abs(f*2.-1.);\n    an = cstep(.4,an)*(an-.4);\n    return 1.-cstep(.8,(r-an*(sqrt(size)*.7)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = gl_FragCoord.xy / min(iResolution.x, iResolution.y);\n\tuv *=2.;\n\tuv += vec2(-0.5,0.);\n\tfloat e = cog(uv,vec2(.5,.1),.1,1.);\n    vec2 headPos = vec2(.5+cos((iTime*PI)+1.5)*.1,1.15+(cos((iTime*PI*2.)+PI+1.8*2.)+2.4)/20.);\n\te += cog(uv,vec2(.5+cos((iTime*PI)+.5)*.05,.35+(cos((iTime*PI*2.)+PI+.5*2.)+2.)/60.),.15,1.);\n\te += cog(uv,vec2(.5+cos((iTime*PI)+1.)*.08,.70+(cos((iTime*PI*2.)+PI+1.*2.)+2.)/40.),.2,1.);\n\te += cog(uv,vec2(.5+cos((iTime*PI)+1.5)*.1,1.15+(cos((iTime*PI*2.)+PI+1.5*2.)+2.)/20.),.25,1.);\n\te += circle(uv, vec2(-.1+cos((iTime*PI)+2.)*.15,1.2+sin((iTime*PI*2.+PI)+2.)*.075),.075);\n\te += circle(uv, vec2(1.1+cos((iTime*PI)+2.)*.15,1.2+sin((iTime*PI*2.+PI)+2.)*.075),.075);\n\te *= drawEyes(uv, leftEyeStart+headPos, rightEyeStart+headPos, headPos);\n    e *= drawMouth(uv, headPos+vec2(0.000,-0.090), headPos);\n\tfragColor = vec4(clamp(e,0.,1.)*vec3(1.000,0.021,0.579), 1.);\n}","name":"Image","description":"","type":"image"}]}