{"ver":"0.1","info":{"id":"XtXXR7","date":"1435132017","viewed":5702,"name":"Raymarching - Diffuse Reflection","username":"Lallis","description":"Adjust max diffuse angle with MouseY. Adjust reflection sample size and disable shadows / direct lighting from code.\nAs always, suggestions are welcome. :)","likes":32,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","reflection","phong","diffuse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[],"code":"#define time iTime\n\n/* Adjust reflection sample size */\n#define RSAMPLES 32\n\n/* Enable softShadow / direct lighting */\n#define SHADOWS\n\nfloat noise3D(vec3 p)\n{\n\treturn fract(sin(dot(p ,vec3(12.9898,78.233,126.7378))) * 43758.5453)*2.0-1.0;\n}\n\nmat3 rot(vec3 ang)\n{\n\tmat3 x = mat3(1.0,0.0,0.0,0.0,cos(ang.x),-sin(ang.x),0.0,sin(ang.x),cos(ang.x));\n\tmat3 y = mat3(cos(ang.y),0.0,sin(ang.y),0.0,1.0,0.0,-sin(ang.y),0.0,cos(ang.y));\n\tmat3 z = mat3(cos(ang.z),-sin(ang.z),0.0,sin(ang.z),cos(ang.z),0.0,0.0,0.0,1.0);\n\treturn x*y*z;\n}\n\nfloat sphere(vec3 rp, vec3 c, float r)\n{\n\treturn distance(rp,c)-r;\n}\n\nfloat cube( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec4 map(vec3 rp)\n{\n\tvec4 d;\n\tvec4 sp = vec4( vec3(0.68, 0.9, 0.40), sphere(rp, vec3(1.0,0.0,0.0), 1.0) );\n    vec4 sp2 = vec4( vec3(0.68, 0.1, 0.40), sphere(rp, vec3(1.0,2.0,0.0), 1.0) );\n    vec4 cb = vec4( vec3(0.17,0.46,1.0), cube(rp+vec3(2.1,-1.0,0.0), vec3(2.0), 0.0) );\n\tvec4 py = vec4( vec3(0.7,0.35,0.1), rp.y+1.0 );\n\td = (sp.a < py.a) ? sp : py;\n    d = (d.a < sp2.a) ? d : sp2;\n    d = (d.a < cb.a) ? d : cb;\n\treturn d;\n}\n\nvec3 normal(vec3 rp)\n{\n    vec3 eps = vec3( 0.002 ,0.0,0.0);\n\treturn normalize( vec3(\n           map(rp+eps.xyy).a - map(rp-eps.xyy).a,\n           map(rp+eps.yxy).a - map(rp-eps.yxy).a,   //shamelessly stolen from iq :(\n           map(rp+eps.yyx).a - map(rp-eps.yyx).a ) );\n\n}\n\nfloat softShadow(vec3 ro, vec3 lp)\n{\n\tvec3 rd = normalize(lp-ro);\n\tfloat tmax = distance(lp,ro);\n\tfloat res = 1.0;\n    float t = 0.1;\n\tfor(int i = 0; i<256; i++ )\n\t{\n        if(t>=tmax) break;\n\t\tfloat d = map(ro+rd*t).a;\n\t\tif(d < 0.001) return 0.0;\n\t\tres = min(res, 8.0*d);\n\t\tt += d;\n\t}\n\treturn res;\n}\n\nfloat ao(vec3 ro, vec3 norm, float k)\n{\n    float res = 0.0;\n    float f = 0.1;\n    for(int i = 1; i<6; i++)\n    {\n        vec3 rp = ro + f*float(i)*norm;\n     \tres+=(1.0/pow(2.0,float(i)))*(f*float(i)-map(rp).a);    \n    }\n\treturn 1.0-k*res;\n}\n\n\nvec3 lp(void){\n    return vec3(1.0,5.0,3.0)*rot(vec3(0.0,time*0.5,0.0));\n}\n\nvec3 reflection(vec3 rro, vec3 rd, vec3 n, vec3 ro, float x)\n{\n    float my = iMouse.y > 0.0 ? iMouse.y/iResolution.y : 0.5;\n    vec3 ang = vec3(noise3D(rro*1.1*x), noise3D(rro*1.2*x), noise3D(rro*1.3*x))*my;\n\trd = normalize(reflect(rd,n)*rot(ang));\n\tvec3 res = vec3(1.0,1.0,0.8);\n\tfloat tmax = 10.0;\n    float t = 0.1;\n    vec3 rp = rro;\n    vec4 d = vec4(res, 1.0);\n\tfor(int i = 0; i<256; i++ )\n\t{\n        if(t>=tmax) break;\n\t\trp = rro+rd*t;\n\t\td = map(rp);\n\t\tif(d.a < 0.001) \n\t\t{\t\t\n\t\t\tbreak;\n\t\t}\n\t\tt+=d.a;\n\t}\n    if(d.a < 0.001) \n\t{\t\t\n    \tfloat ks = 0.5;\n\t\tfloat kd = 0.5;\t\t\n\t\tfloat ka = 0.2;\n        float a = 3.0;\n\t\tfloat aof = 5.0;\n        float ss = 1.0;\n\t\t\t\n\t\tvec3 l = normalize(lp()-rp);          \n\t\tvec3 n = normal(rp);\t\t\t\t\n\t\tvec3 v = normalize(ro-rp);\n        vec3 h = normalize(l+v);\t\t\n\t\t\t\n\t\tfloat illumination  = ka*ao(rp,n, aof) \t\t\t\t\n\t\t\t\t\t\t\t+ max(kd*dot(l,n),0.0)\n                            + max(ks*pow(dot(n,h),a),0.0);\n        \n        #ifdef SHADOWS\n        \tillumination += ss*softShadow(rp, lp());\n        #endif\n        \n\t\tres = d.rgb*illumination;\n\t}\n\treturn res;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord/iResolution.xy;\n\tvec2 p = uv*2.0-1.0;\n\tp.x*=iResolution.x/iResolution.y;\t\n\tfloat f = -7.0;    \n\tvec3 col = vec3(0.7,0.35,0.1)*0.55*vec3(1.0,1.0,0.8);\n    #ifndef SHADOWS\n    \tcol = vec3(0.7,0.35,0.1)*0.45*vec3(1.0,1.0,0.8);\n    #endif\n    float mx = iMouse.x > 0.0 ? iMouse.x/iResolution.x : 0.59;\n\tvec3 ang = vec3(3.14/8.0,mx*3.14*3.0,0.0);\n\tvec3 ro = vec3(0.0,0.0,f-2.0);\n\tvec3 rd = normalize(vec3(p,f)-ro);\n\tro*=rot(ang);\n\trd*=rot(ang);\n\tvec3 rp;\n\tfloat tmax = 60.0;\n\tfloat t = 0.0;\n    vec4 d = vec4(col, 1.0);\n\tfor(int i = 0; i<256; i++)\n\t{\n        if(t >= tmax) break;\n\t\trp = ro+rd*t;\n\t\td = map(rp);\n\t\tif(d.a < 0.0001)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tt += d.a;\n\t}\n\tif(d.a < 0.0001)\n    {\n   \t\tfloat ks = 0.5;\t\t//specular reflection constant\n\t\tfloat kd = 0.5;\t\t//diffuse reflection constant\n\t\tfloat ka = 0.4;\t\t//ambient reflection constant\n\t\tfloat a = 5.0;\t\t//shininess constant\n\t\tfloat aof = 5.0;\t//ambient occlusion amount\n\t\tfloat rf = 1.0;\t\t//reflection amount\n        float ss = 1.0;\n\t\t\t\n\t\tvec3 l = normalize(lp()-rp);          //surface to light vector\n\t\tvec3 n = normal(rp);\t\t\t\t//surface normal vector\n\t\tvec3 v = normalize(ro-rp);\t\t\t//surface to camera vector\n        vec3 h = normalize(l+v);\t\t\t//the \"half way vector\"\n\t\t\t\n\t\tfloat illumination  = ka*ao(rp,n, aof) \t\t\t\t//add ambient light\n\t\t\t\t\t\t\t+ max(kd*dot(l,n),0.0) \t\t\t//add diffuse light\n\t\t\t\t\t\t\t+ max(ks*pow(dot(n,h),a),0.0);\t//add specular light\n        \n        #ifdef SHADOWS\n        \tillumination += ss*softShadow(rp, lp());\t\t//add direct light + shadows\n        #endif\n\t\t\t\t\t\t\n        vec3 ref = vec3(0.0);\n        \n        for(int j = 1; j<RSAMPLES+1; j++)\n        {\n            ref+=reflection(rp,rd,n,ro,float(j));\n        }\n        ref/=float(RSAMPLES);\n\t\tcol = d.rgb*(illumination+ref);\n    }\n\n\tfragColor = vec4(col,1.0);\t\n}","name":"","description":"","type":"image"}]}