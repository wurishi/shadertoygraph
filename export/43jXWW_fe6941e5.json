{"ver":"0.1","info":{"id":"43jXWW","date":"1710626655","viewed":84,"name":"Paprika","username":"mrEscen","description":"Just for fun... Paprika","likes":18,"published":1,"flags":0,"usePreview":0,"tags":["pepper","paprika","bellpepper"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////\n// Edwin de Jong 2024\n////////////////////////////////////////////////////////////////\n// References\n// Distance functions & structure based on Inigo Quilez's (iq) shaders & functions https://iquilezles.org/\n// Ray marcher inspired by iq's work and The Art of Code's work (https://www.shadertoy.com/view/XlGBW3)\n\n// Ray marching constants\n#define MAX_STEPS 350\n#define SURF_DIST 0.0001\n#define MAX_DIST 100.0\n#define PI 3.141592653592\n#define TAU 6.283185307185\n#define LIPSCHITZ 0.5\n#define DTR PI/180.0\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n////////////////////////////////////////////////////////////////\n// Signed Distance Functions\n////////////////////////////////////////////////////////////////\n// Main reference: https://iquilezles.org/articles/distfunctions/\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdCappedTorus( vec3 p, vec2 sc, float ra, float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  // sampling independent computations (only depend on shape)\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n\n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  float k = dot(q,vec2(-b,a));\n  if( k<0.0 ) return length(q) - r1;\n  if( k>a*h ) return length(q-vec2(0.0,h)) - r2;\n  return dot(q, vec2(a,b) ) - r1;\n}\n////////////////////////////////////////////////////////////////\n// SDF Operations\n////////////////////////////////////////////////////////////////\n\nfloat opUnion(float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction(float d1, float d2) {\n    //NOTE: Flipped order because it makes more sense to me\n    return max(-d2, d1);\n}\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\nfloat opSmoothUnion(float d1, float d2, float k) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\nfloat opSmoothSubtraction(float d1, float d2, float k) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d1, -d2, h ) + k*h*(1.0-h);\n}\nfloat opSmoothIntersection(float d1, float d2, float k){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n// from https://mercury.sexy/hg_sdf/\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n////////////////////////////////////////////////////////////////\n// Rotations\n////////////////////////////////////////////////////////////////\n\nvec3 rotX(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        1., 0., 0.,\n        0., c, -s,\n        0., s, c\n        );\n    return m * p;\n}\n\nvec3 rotY(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, 0., s,\n        0., 1., 0.,\n        -s, 0., c\n        );\n    return m * p;\n}\n\nvec3 rotZ(vec3 p, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat3 m = mat3(\n        c, -s, 0.,\n        s, c, 0.,\n        0., 0., 1.\n        );\n    return m * p;\n}\n\nvec3 orbitControls(vec3 po) {\n    vec2 m = (vec2(iMouse.x, iMouse.y) / iResolution.xy) + 0.5;\n    vec3 p = po;\n    p = rotY(po, -m.x*TAU);\n    p = rotX(p, m.y*PI + PI);\n    return p;\n}\n\n////////////////////////////////////////////////////////////////\n// Ray Marching Functions\n////////////////////////////////////////////////////////////////\n\nvec2 map(vec3 po) { \n    vec3 p;\n    if (iMouse.z > 0.) {\n        p = orbitControls(po);\n    }else{\n        p = rotY(po, .25 * sin(1.25*iTime));\n    }\n\n    vec2 res; \n\n    float radius = 0.4; //0.3-0.4\n    float topR = 0.42;\n    float botR = 0.35;\n    float height = 0.9;\n    float angle = 15.;\n    float cyl1 = sdRoundCone(rotX(p-vec3(0.25,-0.4,radius),angle*DTR), botR,topR,height);\n    float cyl2 = sdRoundCone(rotX(p-vec3(-0.25,-0.4,radius),angle*DTR), botR,topR,height);\n    \n    float cyl3 = sdRoundCone(rotZ(p-vec3(radius,-0.4,0.25),-angle*DTR), botR,topR,height-0.05);\n    float cyl4 = sdRoundCone(rotZ(p-vec3(radius,-0.4,-0.25),-angle*DTR), botR,topR,height);\n    \n    float cyl5 = sdRoundCone(rotZ(p-vec3(-radius,-0.4,0.25),angle*DTR), botR,topR,height);\n    float cyl6 = sdRoundCone(rotZ(p-vec3(-radius,-0.4,-0.25),angle*DTR), botR,topR,height+0.05);\n    \n    float cyl7 = sdRoundCone(rotX(p-vec3(0.25,-0.52,-radius),-angle*DTR), botR-0.02,topR,height+0.05);\n    float cyl8 = sdRoundCone(rotX(p-vec3(-0.25,-0.4,-radius),-angle*DTR), botR,topR,height);\n    \n    if (cyl8 < res.x) {res.y = 2.;};\n    \n    res.x = cyl1;\n    res.x = opSmoothUnion(res.x, cyl2, 0.15);\n    res.x = opSmoothUnion(res.x, cyl3, 0.25);\n    res.x = opSmoothUnion(res.x, cyl4, 0.15);\n    res.x = opSmoothUnion(res.x, cyl5, 0.25);\n    res.x = opSmoothUnion(res.x, cyl6, 0.15);\n    res.x = opSmoothUnion(res.x, cyl7, 0.25);\n    res.x = opSmoothUnion(res.x, cyl8, 0.15); \n    \n    vec2 g = vec2(0.5,0.5);\n    g = g-.1/dot(g/200. + sin(atan(p.x,p.z)*6.)*.001,g);\n    float crown = sdRoundedCylinder(p-vec3(0.0,height-0.3,0.0),0.15,0.015,0.2)+ (g.x/900.);\n    \n    float an = 1.2;\n    vec2 c = vec2(sin(an),cos(an));\n    float stem = sdCappedTorus(rotZ(p-vec3(-0.5,height-0.1,0.0),-35.*DTR), c, 0.5, 0.1 );\n    float stemTip = sdCappedCone(rotZ(p-vec3(-0.9,height+0.3,0.0),110.*DTR), 0.03, 0.08,0.10);\n    if (stem < res.x) res.y = 2.0;\n    if (crown < res.x) res.y = 2.0;\n    res.x = opSmoothUnion(res.x, stem,0.35);\n    res.x = opSmoothUnion(res.x, crown,0.05);\n    res.x = opSmoothUnion(res.x, stemTip,0.20);\n    \n    return res;\n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    float d = 0.0;\n    float mat = 1.0;\n    float minDist = MAX_DIST;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        if (i >= MAX_STEPS ) break;\n        vec3 p = ro + rd * d;\n        vec2 ds = map(p);\n        d += LIPSCHITZ * ds.x;\n        mat = ds.y;\n        minDist = min(minDist, ds.x);\n        if (d >= MAX_DIST || ds.x < SURF_DIST) break;\n    }\n    return vec3(d, mat, minDist);\n}\n\nvec3 gradient(vec3 p) {\n    float epsilon = 0.0001;\n    vec3 dx = vec3(epsilon, 0., 0.0);\n    vec3 dy = vec3(0., epsilon, 0.0);\n    vec3 dz = vec3(0., 0.0, epsilon);\n\n    float ddx = map(p + dx).x - map(p - dx).x;\n    float ddy = map(p + dy).x - map(p - dy).x;\n    float ddz = map(p + dz).x - map(p - dz).x;\n    \n    return normalize(vec3(ddx, ddy, ddz));\n}\n\nvec3 rayDirection(vec2 p, vec3 ro, vec3 rt) {\n\n    // screen orientation\n    vec3 vup = vec3(0., 1.0, 0.0);\n    float aspectRatio = iResolution.x / iResolution.y;\n\n    vec3 vw = normalize(ro - rt);\n    vec3 vu = normalize(cross(vup, vw));\n    vec3 vv = cross(vw, vu);\n    float theta = radians(35.); // half FOV\n    float viewport_height = 2. * tan(theta);\n    float viewport_width = aspectRatio * viewport_height;\n    vec3 horizontal = -viewport_width * vu;\n    vec3 vertical = viewport_height * vv;\n    float focus_dist = length(ro - rt);\n    vec3 center = ro - vw * focus_dist;\n    vec3 rd = center + p.x * horizontal + p.y * vertical - ro;\n    return normalize(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord / iResolution.xy - 0.5) * 2.0); // normalizing\n\n    // Ray Marching\n    vec3 rt = vec3(0., 0.2, 0.);\n    vec3 ro = vec3(5., 3., -10.0);\n\n    vec3 rd = rayDirection(uv, ro, rt);\n    vec3 d = rayMarch(ro, rd);\n    \n    // Trace from cursor\n    vec2 m = (2.*iMouse.xy - iResolution.xy) / iResolution.xy;\n    vec3 rdm = rayDirection(m, ro, rt);\n    vec3 dm = rayMarch(ro, rdm);\n    \n    // Background\n    float v = length(uv) * .75;\n    fragColor = vec4(0.1,0.7,1.,1.);\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.y)));\n    fragColor += vec4(mix(0.2, 0.4, smoothstep(0.0, 1.0, uv.x)));\n    \n    vec3 color;\n    float id = d.y;\n    \n    if (d.x <= 100.0) {\n        vec3 p = ro + rd * d.x;\n        vec3 N = gradient(p);\n        float light1 = dot(N, normalize(vec3(1, 1,-1)))*.5+.5;\n        float light2 = dot(N, normalize(vec3(-1, 1,-1)))*.5+.5;\n        vec3 illumination = 0.5 * vec3(light1) + 0.5 * vec3(light2);\n\n        color = vec3(217., 105., 0.) / 255.;\n        vec3 colormat = color * vec3(1.5,1.5,1.);\n        vec3 colormat1 =  vec3(0.38,0.48,0.0);\n        float specm = 0.25;\n        if (id == -1.0) color = vec3(0., 0., 0.);\n        if (id == 2.0 ){ color = colormat1;specm = 0.001;};\n\n        color *= illumination; \n\n        // Specular highlights\n        vec3 R = reflect(normalize(vec3(1.,0.,0.)), N);\n        vec3 specular = vec3(1.0) * pow(max(dot(R, rd), 0.0), 30.);\n        color += specular * specm;\n        \n        // fake fresnel\n        float nDotV = dot(N, rd) + 1.;\n        color += nDotV * nDotV * 0.45;\n        \n        fragColor = vec4(color, 1.0);\n    }\n \n}","name":"Image","description":"","type":"image"}]}