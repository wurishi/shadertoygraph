{"ver":"0.1","info":{"id":"dlXczs","date":"1691229099","viewed":39,"name":"Learning RayTracing FoCG","username":"Kainslow","description":"(WIP)\nInformation in common.\n\nAny suggestions, advices,etc are welcome","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","learning"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define INFINITY float(990)\n#define SPHERECOUNT 5\n#define PLIGHTSCOUNT 3\n#define BOUNCES 5\n#define PI float(3.14159265359)\n\n#define ALIGHTSCOUNT 3\n//#define TRYSOFTSHADOWS\n\nstruct Ray{\n    vec3 o; //origin \n    vec3 d; //direction\n};\n\nstruct PointLight{\n\n    vec3 c; //color\n    vec3 p; //point in space\n};\n\nstruct AreaLight{\n\n    vec3 c;\n    vec3 p;\n    float r;\n\n};\n\n\nstruct Sphere{\n\n    vec3 c; // centre\n    float r; // radius\n};\n\nstruct Triangle{ //TODO\n    vec3 a,b,c;\n};\n\n\n//reference: https://www.shadertoy.com/view/MtcXWr\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n};\n\nfloat intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return INFINITY;\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return t;\n}\n/////////////////////////////////////////////////\n\nconst Sphere spheres[5]= Sphere[5](\n    Sphere(vec3( 0.0, .5,  3.0),0.135),\n    Sphere(vec3( 1.75, 0.0, 3.0),0.5), \n    Sphere(vec3(-1.5, 0.0,  3.0),.75),\n    Sphere(vec3(.0, -.5, 1.), 0.25),\n    Sphere(vec3(.0, -.5, 1.), 0.25)\n);\n\n\nconst PointLight lights[3] = PointLight[3]\n(\n    PointLight(vec3(0.9, 0.0, 0.2)*.5, //color\n               vec3(0., 7., 0.) ),           \n                                           \n    PointLight(vec3(1.0, 0.3,0.0)*.9,\n               vec3(0., 7., 80.) ),\n               \n    PointLight(vec3(0.0, 0.8, 1.9)*.5,\n               vec3(0., 7., 40.) )\n);\n\nconst AreaLight aLights[3] = AreaLight[3](\n\n    AreaLight(vec3(0.15, 0.15, 0.545), vec3(1000., 500. , -100.), 0.5),\n    AreaLight(vec3(0.35, 0.25, 0.545), vec3(-1000., 500. , 100.), 0.5),\n    AreaLight(vec3(0.15, 0.35, 0.545), vec3(0., 5000. , -1.), 0.5)\n\n);\n\n\nstruct HitRecord{\n    \n    float t;  // distance of hit along the ray\n    vec3 n;   // surface normal at the hit point\n};\n\nvec3 P(float t, Ray ray){//Returns a point P that lays in the distance t distance along the ray direction. \n    return ray.o + t * (ray.d);\n}\n\n\nfloat SphRayInt(Ray r, Sphere sp) // Sphere-Ray Intersection\n{\n    vec3 r0_spC = r.o - sp.c; // direction from ray origin to sphere center\n\n    //using the quadratic formula:\n    \n    float a = dot(r.d, r.d); \n    float b = 2.0 * dot(r.d, r0_spC);\n    float c = dot(r0_spC, r0_spC) - (sp.r * sp.r);\n    \n    float d = (b*b) - 4.0 * a * c;   //discriminant to know if the eq has solutions\n    \n    if(d < 0.0){\n        return INFINITY;\n    }\n    \n    //Final calculation\n    //Most of the time, the only solution that we care about is the lowest one (first hit), \n    //so we will forget about the other one.\n    \n    return (-b - sqrt(d))/(2.*a);\n}\n\n\n\nbool TriRayInt(Ray r, Triangle tri){\n    \n    //TODO: Compute t,g,b\n    \n    float t;\n    \n    if(t < .0 || t >= INFINITY) return false;\n    \n    float g;\n    \n    if(g < 0. || g >= 1.) return false;\n    \n    float b;\n    \n    if(b < 0. || b > 1. - g) return  false;\n    \n    return true;\n}\n\nHitRecord RayTest(Ray ray){ // find the closest ray hit with the spheres per window/screen pixel\n\n    HitRecord hR;\n    hR.t = INFINITY;   // default t value (max vision range / far plane)\n    \n    for(int i = 0; i < SPHERECOUNT; i++){ //loop through our spheres to find the closest hit\n    \n        Sphere s = Sphere(spheres[i].c, spheres[i].r);\n        \n        //Simple animation\n        if(i == 0) s.c = vec3(s.c.x,s.c.y,s.c.z + cos(iTime)*5.);\n        else if(i == 1)  s.c = vec3(s.c.x,s.c.y + sin(iTime)*.25,s.c.z);\n        \n        if(i == 3) s.c = vec3(s.c.x + cos(iTime)*.25, s.c.y + -sin(iTime)*.25,s.c.z);\n        else if(i == 4) s.c = vec3(s.c.x + -cos(iTime)*.25, s.c.y + sin(iTime)*.25,s.c.z);\n        else if(i != 2)\n        s.c = vec3(s.c.x +cos(iTime)*.2, s.c.y + sin(iTime)*.2, s.c.z);\n        \n        ///////////////////\n        \n        ray.o += ray.d * .0001;\n        \n        float t = SphRayInt(ray, s); //calculate hit distance\n        \n        \n        if(t < hR.t && t > .0001) //if is less than our current one, replace\n        {\n            hR.t = t;\n            vec3 hitPoint = P(t, ray);\n            hR.n = (hitPoint - s.c)/s.r;\n        }\n    }\n    \n    Plane pl = Plane(1., vec3(0.,1.,0.));\n    float pT = intersectPlane(pl, ray);\n    \n    if(pT < hR.t){\n    \n        hR.t = pT;\n        hR.n = pl.n;\n    }\n    \n    return hR;\n}\n\nvec3 Illuminate(PointLight light, Ray ray, HitRecord hrec){\n\n    vec3 x = P(hrec.t, ray); //shading point \n    float r = length(light.p - x); //distance from light to shading point\n    vec3 l = (light.p - x)/r; // unit light direction, from light point to shading point\n    \n    HitRecord hR = RayTest(Ray(x,l));\n    \n    if(hR.t >= INFINITY){ //if the ray doesnt hit anything, proceed with normal light\n    \n        vec3 n = hrec.n; //unit normal vector\n        vec3 e = max(.0, dot(n,l) ) * (light.c/r*r); // calculate color\n\n        // dot(n,l) returns positive values when vectors aim in similar directions,\n        // and negative values when they are opposite \n        // then multiply the value by the normalized light color\n\n        return e;\n    \n    }// else we are in shadow, so return black\n    \n    return vec3(0.);\n\n}\n\nmat3x3 angleAxis3x3(float angle, vec3 axis){\n    \n    float s = sin(angle);\n    float c = cos(angle);\n\n    float t = 1. - c;\n    float x = axis.x;\n    float y = axis.y;\n    float z = axis.z;\n\n    return mat3x3(\n        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,\n        t * x * y + s * z,  t * y * y + c,      t * y * z - s * x,\n        t * x * z - s * y,  t * y * z + s * x,  t * z * z + c\n    );\n\n}\n\nfloat rand(inout float co) { return fract(sin(co*(91.3458)) * 47453.5453); co*=iTime;}\n\nvec3 GetConeSample(inout float randSeed, vec3 direction, float coneAngle){\n\n    float cosAngle = cos(coneAngle);\n    \n    float z = rand(randSeed) * (1.0f - cosAngle) + cosAngle;\n    \n    float phi = rand(randSeed) * 2.0f * PI;\n    \n    float x = sqrt(1.0 - z * z) * cos(phi);\n    float y = sqrt(1.0 - z * z) * sin(phi);\n    \n    vec3 north = vec3(0.f,0.f,-1.f);\n    \n    vec3 axis = normalize(cross(north, normalize(direction)));\n    float angle = acos(dot(normalize(direction), north));\n    \n    mat3x3 R = angleAxis3x3(angle, axis);\n    \n    return R * vec3(x,y,z);\n}\n\nvec3 IlluminateSoft(AreaLight light, Ray ray, HitRecord hrec, inout float seed){\n\n    vec3 x = P(hrec.t, ray);\n    \n    float r = length(light.p - x);\n    \n    vec3 toLight = normalize(light.p - x);\n    \n    vec3 perpL = cross(toLight, vec3(0.,1.,0.));\n    \n    vec3 toLightEdge = normalize((light.p + perpL * light.r) - x);\n    \n    float coneAngle = acos(dot(toLight, toLightEdge)) * 2.0;\n    \n    vec3 dir = GetConeSample(seed, toLightEdge, coneAngle);\n    \n    HitRecord hR = RayTest(Ray(x, dir));\n    \n    if(hR.t >= INFINITY){ \n    \n        vec3 n = hrec.n; //surface normal vector\n        vec3 e = max(.0, dot(n, dir)) * (light.c)/r*r; // calculate color\n\n        return  e;\n    \n    }// else we are in shadow, so return black\n    \n    return vec3(.0);\n\n}\n\nvec4 ShadeRay(Ray camera){\n\n    vec3 color = vec3(0.);\n    float lightPower = 1.0;\n    Ray ray = Ray(camera.o, camera.d);\n    HitRecord hR;\n    hR.t = INFINITY;\n    \n    for(int i = 0; i < BOUNCES; i++){\n        \n        ray.o = ray.o + ray.d * .0001;\n        \n        hR = RayTest(ray);\n        \n        if(hR.t >= INFINITY) break;\n        \n        \n        for(int i = 0; i < PLIGHTSCOUNT; i++){\n\n            PointLight l = lights[i];\n\n            l.p = vec3(l.p.x, l.p.y + sin(iTime) * 7., cos(iTime) *10.+l.p.z); // moving the lights a little bit :)\n\n            color += (Illuminate(l, ray, hR)) * lightPower ;\n        }\n        \n        lightPower *= .6;\n\n        ray.o = P(hR.t,ray);\n\n        //Both ray.d work, wich is better? idk\n        //ray.d = (ray.d - 2. * dot(ray.d, hR.n)*hR.n) ;\n        ray.d = normalize(reflect(ray.d, hR.n));\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvec4 ShadeRaySoft(Ray camera){\n\n    vec3 color = vec3(0.);\n    float lightPower = 1.0;\n    Ray ray = Ray(camera.o, camera.d);\n    HitRecord hR;\n    hR.t = INFINITY;\n    \n    float seed = 1000.;\n    \n    for(int i = 0; i < BOUNCES; i++)\n    {\n        ray.o = ray.o + ray.d * .0001;\n        \n        hR = RayTest(ray);\n        \n        if(hR.t >= INFINITY) break;\n        \n        \n        for(int i = 0; i < ALIGHTSCOUNT; i++){\n            \n            color+= IlluminateSoft(aLights[i],ray,hR, seed)*lightPower;\n        }\n        color/=float(ALIGHTSCOUNT);\n        \n        lightPower *= .6;\n\n        ray.o = P(hR.t,ray);\n\n        ray.d = normalize(reflect(ray.d, hR.n));\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    uv = uv * 2.0 - 1.0;//transform from [0,1] to [-1,1]\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    Ray cam; // our camera ray\n    vec3 wnd = vec3(uv, -1.); // window/screen position in 3D space\n\n    cam.o = vec3(0., iMouse.y*3./iResolution.x, -10. - iMouse.x*2./iResolution.x); // camera position in 3D space\n    //cam.o = vec3(.0, .65, -10.);\n    \n    cam.d = normalize(wnd - cam.o); // camera direction (look through the window)\n        \n    vec3 color = vec3(.0);\n    \n        \n        //not working\n    #ifdef TRYSOFTSHADOWS \n    color += ShadeRaySoft(cam).rgb;\n    #else\n    color += ShadeRay(cam).rgb;\n    #endif\n    \n    //some ambient color\n    \n    color += vec3(.015,.0, .075);\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/*\n\nREFERENCES: \n    \n    I did most of the shader following the explanation in the book,\n    but whenever i had problems i looked into these shaders.\n    \n    Fundamentals of Computer Graphics (Chapter 4: Ray Tracing):\n    https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390\n    \n    -GLSL ray tracing test:\n    https://www.shadertoy.com/view/3sc3z4\n    \n    -Ray tracing a cone:\n    https://www.shadertoy.com/view/MtcXWr\n\n\nNotes:\n\n    Im still figuring things out.\n    \n    The reason the reflections are perfect is because the spheres have no material,\n    so the light is preserved with each ray reflection (may change this later).\n    \n    The scene has 3 point lights and some ambient color\n    (may add a directional light later).\n    \n    If you have better learning resources/references please let me know.\n    \n    May add triangles later.\n    \n    Any advice/optimization is welcome.\n\n\nBasics:\n\n    basis vectors\n    u/x = (1., .0, .0);  // left/right\n    v/y = (.0, 1., 0.);  // up\n    w/z = (.0, .0, 1.); // dept\n    \n    window/screen dimensions\n    l and r are the positions of the left and right edges\n    of the image,\n    b and t are the positions of the bottom and top edges\n    of the image:\n\n           u = l                u = r \n    v          ___________________\n    |    rd   |     _             | v = t       /¯¯\\ (sphere)\n    w—e——————————————|s̲|-- --  --   |--    -- -|p|  |--\n     \\        |                   |             \\__/\n      u       |___________________| v = b\n\n    e is the view point (camera origin)\n    s is the intersection point between \n    our camera ray and the window/screen \n\n    rd is the ray direction (camera direction/ray)\n    rd = s - e;\n\n    Generally:\n\n    l < 0 < r and b < 0 < t\n\n    in this particular case\n\n    l = -1, r = 1\n    b = -0.5, t = 0.5\n\n    Before calculating Intersections, we need to be able to get a point at any given travel distance\n    along the ray direction of our camera, to do that, we will simply use the following function:\n\n    P(t) = e + t*(rd);\n\n    this function returns a point in 3D space that lays in 't' distance from 'e' along the ray direction 'rd'.\n    in this case, 't' is the travel distance along the ray direction.\n    remember not to be confuse it with our other variable 't'(top of the window)\n    \n\n    Intersection with Sphere:\n      \n        in order to compute the intersection with a sphere, we need a point uvw (xyz)\n        and a sphere with center:\n\n        c = (xc, yc, zc) \n        and radius R \n\n        wich can be represented by the\n        implicit equation:\n\n        ((x-xc)^2) + ((y - yc)^2) + ((z - zc)^2) - ((R)^2) = 0\n\n        written in vector form:\n\n        dot((p - c), (p - c)) - ((R)^2) = 0 \n\n        substituting p by our P function:\n\n        dot( (e + (t * (rd-c)) ), (e + (t * (rd-c))) ) - ((R)^2) = 0\n\n        rearranging and solving for t yields:\n\n        (( dot(rd, rd) )*(t)^2) + (2*( dot(rd, e - c) )*t) + dot(e-c, e-c) - ((R)^2) = 0\n\n        which is a classic quadratic eq. meaning it has the form:\n\n        (A*(t)^2) + (B * t) + C = 0\n\n        thus we can solve for t with the quadratic formula\n\n        (-B +-sqrt((B*B) - 4*A*C))/ 2*A\n\n        so, given a sphere(center and radius) we now can find at wich t(travel distance) our ray direction collides\n        with it.\n\n        Remember to always compute the discriminant first. \n\n        If the discriminant is negative,\n        its square root is imaginary and the line and sphere do not intersect. If the dis-\n        criminant is positive, there are two solutions: one solution where the ray enters\n        the sphere and one where it leaves. If the discriminant is zero, the ray grazes\n        the sphere, touching it at exactly one point.\n        \n    Intersection with Plane:\n    //TODO:\n    \n    Intersection with Triangle:\n    //TODO:\n      \n    Lighting the scene:\n      \n        In order to shade the scene we need 4 vectors:\n\n        The shading point 'x': \n        Wich can be computed evaluating the viewing ray at the 't' value of the sphere intersection.\n\n        The surface normal 'n':\n        The normal vector at the point where a ray intersects it, depends on surface.\n\n        The light direction 'l':\n        Can be computed from the point of the current light source to the current intersection point\n\n        The viewing direction 'v':\n        is simply the opposite direction of the viewing ray (v = −rd/‖rd‖).\n       \n       //TODO:\n*/","name":"Common","description":"","type":"common"}]}