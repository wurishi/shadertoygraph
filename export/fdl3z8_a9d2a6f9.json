{"ver":"0.1","info":{"id":"fdl3z8","date":"1615497568","viewed":416,"name":"IQ_TUT: Greek Holiday 2021","username":"MaxGraph","description":"Still learning to understand shading. Amazed by those incredible shadertoy shaders. I took the \"masters\" one (https://www.shadertoy.com/view/ldScDh) to give it a kind of more natural look. Hope that will not be seen as majesty's insult ;)","likes":5,"published":3,"flags":64,"usePreview":0,"tags":["sdf","sphere","box","pillar"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4lXXD4","filepath":"https://soundcloud.com/youssef-ali-6/zorba-the-greek","previewfilepath":"https://soundcloud.com/youssef-ali-6/zorba-the-greek","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//#define STATICCAM\n\n//#define AA\n#define STEP 14\n#define CAMERA_OSC_SPEED 0.1\n#define CAMERA_OSC_RANGE 0.85\n\n#define PILLAR_HEIGHT 6.0\n#define PILLAR_RAD_BASE 0.75\n#define PILLAR_RAD_DEC 0.05\n#define NB_RIPPLES 24.0\n#define PILLAR_BLOCK_OFFSET 0.3\n#define PILLAR_BLOCK_TILING 3.0\n#define PILLAR_DIST 4.0\n#define PILLAR_OFFSET_X 2.0\n#define PILLAR_BASE_ROUNDING 0.1\n// copy matrix is 1 original pillar + 4*X + 4*-X\n// same principle for z \n#define PILLAR_REPETITIONS_XZ vec2(4.0,2.0)\n#define PILLAR_CLIPPING_BOX vec3(14.0,6.0,6.0)\n#define FLOOR_TILES vec3(2.0,0.4,2.0)\n#define FLOOR_TILES2 vec3(2.0,1.3,2.0)\n#define TILES_GAP_XYZ vec3(0.05,0.0,0.05)\n#define TILES_OFFSET_Y 5.7\n#define TILES_OFFSET_Y2 6.4\n#define TILES_OFFSET_Y3 8.1\n#define TILES_ROUNDING 0.1\n#define SPIKES 2.0\n#define ROTTEN 0.65\n\n// lights\n// all keylight shadows will be filled by ambient light\n//keylight 5-10 times stronger than ambient light\n\n// keylights are NEVER modelled by occlusion!\n\n#define LIGHT_POWER 1.2\n\n#define SUN vec3(0.8,0.2,0.4)\n#define SUN_POWER 1.0\n#define KEYLIGHT_COLOR vec3(0.90,0.55,0.35)\n#define KEYLIGHT_POWER 4.0\n#define AMBIENT_COLOR vec3(0.25,0.25,0.35)\n#define AMBIENT_POWER 0.65\n// backlight is bounced keylight\n#define BACKLIGHT_COLOR vec3(0.10,0.09,0.11)\n#define BACKLIGHT_POWER 1.6\n#define BOUNCELIGHT_POWER 0.6\n#define BOUNCELIGHT_COLOR vec3(1.0,0.4,0.005)\n#define OVEREXPOSE 6.0\n#define OVEREXPOSE_COLOR vec3(1.0,0.7,0.4)\n#define OVEREXPOSE_POWER 0.25\n\n// horizon\n#define SKYBASE_COLOR vec3(0.2,0.3,0.4)\n#define SKYBASE_POWER 0.25\n\n// #define SKYBLUE_COLOR vec3(0.2,0.25,0.30)\n// horizon line\n#define SKYBLUE_COLOR vec3(0.3,0.35,0.50)\n#define SKYBLUE_POWER 0.75\n\n#define CLOUDS vec2(0.35,0.9)\n//#define SKYRED_COLOR vec3(0.3,0.2,0.1)\n#define CLOUDSRED_COLOR vec3(0.7,0.5,0.3)\n#define SKYGRAY_COLOR vec3(0.2,0.25,0.30)\n#define SKYGRAY_POWER 0.4\n\n#define SKYRED_COLOR vec3(1.5,0.30,0.05)\n#define SKYRED_POWER 0.8\n\n// vec3(0.1,0.125,0.15)\n\n// landscape distance fog\n#define FOG_COLOR vec3(0.22,0.25,0.30)\n#define FOG_POWER 0.42\n#define FOG_EXPONENT 0.0016\n\n#define FAKE_OCCLUSION_FACTOR 0.9\n\n#define FLOOR_DARKENING_FACTOR 0.5\n\n#define SHADOW_Y_DEPTH 0.6\n\n#define WETLINE_DARKEN 0.35\n\n#define OCEAN_BASE_COLOR vec3(0.05,0.11,0.15)\n#define OCEAN_BASE_POWER 0.35\n#define OCEAN_COAST_COLOR vec3(0.01,0.03,0.03)\n#define OCEAN_COAST_POWER 2.5\n\nfloat hash1( vec2 p )\n{\n    p  = 50.0*fract( p*0.3183099 );\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat hash( uint n ) \n{\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nvec2 hash2( float n ) { return fract(sin(vec2(n,n+1.0))*vec2(43758.5453123,22578.1459123)); }\n\nfloat noise( in vec2 x )\n{\n    ivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tivec2 uv = p.xy;\n\tfloat rgA = texelFetch( iChannel1, (uv+ivec2(0,0))&255, 0 ).x;\n    float rgB = texelFetch( iChannel1, (uv+ivec2(1,0))&255, 0 ).x;\n    float rgC = texelFetch( iChannel1, (uv+ivec2(0,1))&255, 0 ).x;\n    float rgD = texelFetch( iChannel1, (uv+ivec2(1,1))&255, 0 ).x;\n    return mix( mix( rgA, rgB, f.x ),\n                mix( rgC, rgD, f.x ), f.y );\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel1, (uv+0.5)/256.0, 0.0).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat fbm4( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.000*noise( p*1.0 );\n    n += 0.500*noise( p*2.0 );\n    n += 0.250*noise( p*4.0 );\n    n += 0.125*noise( p*8.0 );\n    return n;\n}\n\nfloat fbm6( in vec3 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm6( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    n += 0.06250*noise( p*16.0 );\n    n += 0.03125*noise( p*32.0 );\n    return n;\n}\n\nfloat fbm4( in vec2 p )\n{\n    float n = 0.0;\n    n += 1.00000*noise( p*1.0 );\n    n += 0.50000*noise( p*2.0 );\n    n += 0.25000*noise( p*4.0 );\n    n += 0.12500*noise( p*8.0 );\n    return n;\n}\n\n\nvec4 textureGood( sampler2D sam, in vec2 uv )\n{\n    uv = uv*1024.0 - 0.5;\n    vec2 iuv = floor(uv);\n    vec2 f = fract(uv);\n    f = f*f*(3.0-2.0*f);\n\tvec4 rg1 = textureLod( sam, (iuv+ vec2(0.5,0.5))/1024.0, 0.0 );\n\tvec4 rg2 = textureLod( sam, (iuv+ vec2(1.5,0.5))/1024.0, 0.0 );\n\tvec4 rg3 = textureLod( sam, (iuv+ vec2(0.5,1.5))/1024.0, 0.0 );\n\tvec4 rg4 = textureLod( sam, (iuv+ vec2(1.5,1.5))/1024.0, 0.0 );\n\treturn mix( mix(rg1,rg2,f.x), mix(rg3,rg4,f.x), f.y );\n}\n\n#define ZERO (min(iFrame,0))\n\n//------------\nconst float ocean = -25.0;\n\nfloat terrain( in vec2 p )\n{\n    #if (STEP >= 1)\n    float h = 90.0*textureGood( iChannel2, p.yx*0.0001 + 0.35 + vec2(0.02,0.05) ).x - 70.0 + 5.0;\n    #else\n    float h = 90.0*texture( iChannel2, p.yx*0.0001 + 0.35 + vec2(0.02,0.05) ).x - 70.0 + 5.0;\n    #endif\n    #if  (STEP >= 2)\n    h = mix( h, -7.2, 1.0-smoothstep(16.0,60.0,length(p)));\n        #if (STEP >= 3)\n        h -= 7.0*textureGood( iChannel2, p*0.002 ).x;\n            #if (STEP >= 4)\n            float d = textureLod( iChannel0, p*0.02, 0.0 ).x;\n            #if (STEP >= 5)\n            h -= 1.0*d*d*d*d;\n            #else\n            h -= 1.0*d;\n            #endif\n            #endif\n        #endif\n    #endif\n    return h;\n}\n\nvec3 temple( in vec3 p )\n{\n    vec3 op = p;    \n    vec3 res = vec3(-1.0,-1.0,0.5);\n\n    p.y += 2.0;\n\n    // bounding box\n    float bbox = usdBox(p,vec3(15.0,12.0,15.0)*1.5 );\n    if( bbox>5.0 ) return vec3(bbox+1.0,-1.0,0.5);\n    \n    vec3 q = p;\n    \n    q.xz = opRepLim(q.xz,PILLAR_DIST,PILLAR_REPETITIONS_XZ);\n    \n    // pillars\n    vec2 id = floor((p.xz+2.0)/4.0);\n    float rad = PILLAR_RAD_BASE;\n    float d = length(q) - rad;\n\n    d = length(q.xz) - rad;\n    float dyn_rad = rad; // base size\n    dyn_rad -= PILLAR_RAD_DEC*q.y; // shape thinner on top\n    // atan wraps around unit circle\n    dyn_rad += 0.075*pow(0.5 + 0.5*sin(NB_RIPPLES*atan(q.x,q.z)),SPIKES);\n    dyn_rad += 0.2*pow(0.5 + 0.5*sin((q.y+PILLAR_BLOCK_OFFSET)*PILLAR_BLOCK_TILING),0.05)-0.15;\n    res.z = hash1( id + 11.0*floor(0.25 + (q.y*3.0+0.6)/6.2831) );\n    d = length(q.xz) - dyn_rad;\n    float d2 = p.y-PILLAR_HEIGHT;\n    d = max(d,d2);\n    // -p.y because of plane normal flip\n    d = max(d,-p.y-5.0);\n    d*=0.7;\n    float d3 = 0.0;\n    vec3 qq = vec3(q.x,q.y,q.z);;\n    float off_y_mirror_plane = 0.3;\n    qq = vec3(q.x,abs(q.y-off_y_mirror_plane)-5.5,q.z);\n    d3 = sdBox(qq,vec3(1.4,0.2,1.4)-PILLAR_BASE_ROUNDING)-PILLAR_BASE_ROUNDING;\n    d = min(d,d3);\n    \n    d = max(d,-sdBox(p, PILLAR_CLIPPING_BOX));\n    \n    float ra = 0.0;\n    ra = 0.25 * hash1(id+vec2(1.0,3.0));\n    \n    // floor\n    {\n    q = p;\n    q.y += TILES_OFFSET_Y;\n    // repetition function\n    q.xz = opRepLim(p.xz,PILLAR_DIST,PILLAR_REPETITIONS_XZ);\n    //rounded TILES\n    vec3 floor_distribution = vec3(FLOOR_TILES.x,FLOOR_TILES.y-ra,FLOOR_TILES.z);\n    d = min(d,sdBox(q, floor_distribution-TILES_GAP_XYZ-TILES_ROUNDING)-TILES_ROUNDING);\n    }\n    {\n    q = p;\n    q.z -= PILLAR_DIST/2.0;\n    q.x += PILLAR_DIST/2.0;\n    q.y += TILES_OFFSET_Y2;\n    id = floor((q.xz+2.0)/4.0);\n    ra = 0.3 * hash1(id+vec2(2.0,3.0)+23.1);\n    q.xz = opRepLim(q.xz,PILLAR_DIST,vec2(4.0,3.0),vec2(5.0,2.0));\n    vec3 floor_distribution = vec3(FLOOR_TILES.x,FLOOR_TILES.y-ra,FLOOR_TILES.z);\n    d = min(d,sdBox(q, floor_distribution-TILES_GAP_XYZ-TILES_ROUNDING)-TILES_ROUNDING);\n    }\n    {\n    q = p;\n    q.y += TILES_OFFSET_Y3;\n    q.xz = opRepLim(q.xz,PILLAR_DIST,vec2(5.0,3.0),vec2(5.0,3.0));\n    id = floor((q.xz+2.0)/4.0);\n    ra = 0.3 * hash1(id+vec2(1.0,3.0)+37.7);\n    vec3 floor_distribution = vec3(FLOOR_TILES2.x,FLOOR_TILES2.y-ra,FLOOR_TILES2.z);\n    d = min(d,sdBox(q, floor_distribution-TILES_GAP_XYZ-TILES_ROUNDING)-TILES_ROUNDING);\n    d*=ROTTEN;\n    } \n    \n    // roof\n    float b = 0.0;\n    b = sdRhombus( p.yz-vec2(8.2,0.0), vec2(3.0,11.0), 0.05 ) ;\n    //q = vec3( mod(p.x+1.0,2.0)-1.0, p.y, mod(p.z+1.0,2.0)-1.0 );\n    b = max( b, -sdBox( vec3( abs(p.x)-20.0,p.y,q.z)-vec3(0.0,8.0,0.0), vec3(2.0,5.0,0.1) )-0.02 );\n    b = max( b, -p.y+8.2 );\n    b = max( b, usdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,12.0,11.0)) );\n    float c = sdRhombus( p.yz-vec2(8.3,0.0), vec2(2.25,8.5), 0.05 );\n    c = max( c, sdBox(abs(p.x)-19.0,2.0) );\n    b = max( b, -c );\n    d = min( d, b );\n    q = vec3( mod(p.x+0.5,1.0)-0.5, p.y, mod(p.z+0.5,1.0)-0.5 );\n    b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.5,0.45)-0.02 )-0.02;\n    b = max( b, sdBox(p-vec3(0.0,8.0,0.0),vec3(19.0,0.2,11.0)) );\n    q = p+vec3(0.0,0.0,-0.5); q.xz = opRepLim( q.xz, 1.0, vec2(19.0,10.0) );\n    b = sdBox( q-vec3(0.0,8.0,0.0), vec3(0.45,0.2,0.45)-0.02 )-0.02;\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+0.5)/1.0) + 7.8 ); }\n    q = vec3( mod(p.x+2.0,4.0)-2.0, p.y, mod(p.z+0.0,4.0)-2.0 );\n    b = sdBox( q-vec3(0.0,7.0,0.0), vec3(1.95,1.0,1.95)-0.15 )-0.15;\n    b = max( b, sdBox(p-vec3(0.0,7.0,0.0),vec3(18.0,1.0,10.0)-TILES_ROUNDING)-TILES_ROUNDING);\n    if( b<d ) { d = b; res.z = hash1( floor((p.xz+vec2(2.0,0.0))/4.0) + 31.1 ); }\n    d = min( d, b );\n    d = max( d,-sdBox(p-vec3(0.0,9.5,0.0),vec3(15.0,4.0,9.0)) );\n    d -= 0.04*smoothstep(0.5,1.0,fbm4( p.zxy ));\n    d -= 0.03*smoothstep(0.4,0.8,fbm4( op*3.0 ));\n    d += 0.005;\n\n    res = vec3( d, 1.0, res.z );\n\n    return res;\n}\n\nvec3 map( in vec3 p )\n{\n    vec3 res = temple(p); \n    // floor\n    float m = p.y + 15.5;\n    {\n        float h = terrain( p.xz );\n        float m = p.y - h;\n        m *= 0.35;\n        if( m<res.x ) res = vec3( m, 2.0, 0.0 );\n    }\n    {\n        float w = p.y + 25.0;\n        if( w<res.x ) res = vec3(w,3.0, 0.0 );\n    }\n    return res;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 p, in float t )\n{\n#if 0    \n    float e = 0.001*t;\n\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n#else    \n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*0.001*t).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 ma = vec2(0.0);\n\n    vec3 res = vec3(-1.0);\n    \n    float tmax = 1000.0;\n\n    float tp = (ocean-ro.y)/rd.y;\n    if( tp>0.0 )\n    {\n        tmax = tp;\n        res = vec3( tp, 3.0, 0.0 );\n    }\n        \n    float t = 10.0;\n    for( int i=0; i<256; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 h = map( pos );\n        if( h.x<(0.0001*t) || t>tmax ) break;\n        t += h.x;\n\n        ma = h.yz;\n    }\n\n    if( t<tmax )\n    {\n    \tres = vec3(t, ma);\n    }\n\n    return res;\n}\n\nvec4 textureBox( in sampler2D tex, in vec3 pos, in vec3 nor )\n{\n    vec4 cx = texture( tex, pos.yz );\n    vec4 cy = texture( tex, pos.xz );\n    vec4 cz = texture( tex, pos.xy );\n    vec3 m = nor*nor;\n    return (cx*m.x + cy*m.y + cz*m.z)/(m.x+m.y+m.z);\n}\n\nfloat calcShadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = .60;\n    //float res = 1.0;\n    \n    float t = 0.01;\n    for( int i=0; i<130; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float h = map( pos ).x;\n        //res = min( res, k*max(h,0.0)/t );\n        res = min( res, k*max(h*0.3,0.0)/t );\n        if( res<0.0001 ) break;\n        t += clamp(h,0.01,0.7);\n    }\n\n    return res;\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor, float ra )\n{\n    float occ = 0.0;\n    for( int i=ZERO; i<32; i++ )\n    {\n        float h = 0.01 + 4.0*pow(float(i)/31.0,2.0);\n        vec2 an = hash2( ra + float(i)*13.1 )*vec2( 3.14159, 6.2831 );\n        vec3 dir = vec3( sin(an.x)*sin(an.y), sin(an.x)*cos(an.y), cos(an.x) );\n        dir *= sign( dot(dir,nor) );\n        occ += clamp( 5.0*map( pos + h*dir ).x/h, -1.0, 1.0);\n    }\n    return clamp( occ/32.0, 0.0, 1.0 );\n}\n\n\nvec3 sunLig = normalize(SUN);\n\nvec3 skyColor( in vec3 ro, in vec3 rd )\n{\n    vec3 col = SKYBASE_COLOR*SKYBASE_POWER- 0.3*rd.y;\n\n    float t = (1000.0-ro.y)/rd.y;\n    if( t>0.0 )\n    {\n        vec2 uv = (ro+t*rd).xz;\n        float cl = texture( iChannel0, .000003*uv.yx ).x;\n        vec2 cl_smooth = CLOUDS;\n        cl = smoothstep(cl_smooth.x,cl_smooth.y,cl);\n        col = mix( col, CLOUDSRED_COLOR, 0.1*cl );\n    }\n\n    col = mix( col, SKYGRAY_COLOR*SKYGRAY_POWER, exp(-30.0*rd.y) ) ;\n    float sd = pow( clamp( 0.25 + 0.75*dot(sunLig,rd), 0.0, 1.0 ), 4.0 );\n    col = mix( col, SKYRED_COLOR*SKYRED_POWER, sd*exp(-abs((60.0-50.0*sd)*rd.y))*0.75 ) ;\n\n    return col;\n}\n\nvec3 doBumpMap( in vec3 pos, in vec3 nor )\n{\n    float e = 0.002;\n    float b = 0.015;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    vec3 gra = -b*vec3( fbm6(4.0*vec3(pos.x+e, pos.y, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y+e, pos.z))-ref,\n                        fbm6(4.0*vec3(pos.x, pos.y, pos.z+e))-ref )/e;\n\t\n\tvec3 tgrad = gra - nor * dot ( nor , gra );\n    return normalize( nor - tgrad );\n}\n\nvec3 doBumpMapGrass( in vec2 pos, in vec3 nor, out float hei )\n{\n    float e = 0.002;\n    float b = 0.03;\n    \n\tfloat ref = fbm6( 4.0*pos );\n    hei = ref;\n    \n    vec3 gra = -b*vec3( fbm6(4.0*vec2(pos.x+e, pos.y))-ref,\n                        e,\n                        fbm6(4.0*vec2(pos.x, pos.y+e))-ref )/e;\n\t\n\tvec3 tgrad = gra - nor*dot( nor, gra );\n    return normalize( nor - tgrad );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float isThumbnail = step(iResolution.x,499.0);\n    vec2 o = (1.0-isThumbnail)*(hash2( float(iFrame) ) - 0.5);\n    \n\tvec2 p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    \n    uvec2 px = uvec2(fragCoord);\n    float ran = hash( px.x + 1920U*px.y + (1920U*1080U)*uint(iFrame*0) );    \n    \n    #ifdef STATICCAM\n    float an = -0.96;\n    #else\n    // oscillating camera\n    float offset = 0.0;\n    offset = 3.141592/8.0;\n    float an = sin(iTime*CAMERA_OSC_SPEED)*CAMERA_OSC_RANGE;\n    an = -0.96 + sin(iTime*CAMERA_OSC_SPEED)*CAMERA_OSC_RANGE+0.75-offset;\n    // camera distance\n    float ra = 25.0;\n    ra = 50.0;\n    #endif\n    float fl = 3.0;\n    vec3 ta = vec3(0.0,-2.0,0.0);\n    ra = 75.0;\n    ta = vec3(0.0,-3.0,-23.0);\n    vec3 ro = ta + vec3(ra*sin(an),6.0,ra*cos(an));\n    ro = ta + vec3(ra*sin(an),10.0,ra*cos(an));\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    vec3 rd = ca * normalize( vec3(p.xy,fl));\n    \n    vec3 col = vec3(0.0);\n    \n    col = skyColor( ro, rd );\n    float resT = 10000.0;\n    vec3 res = intersect( ro, rd );\n    if( res.y>0.0 )\n    {\n\n        float t = res.x;\n        resT = t;\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos, t );\n        \n        float fre = pow( clamp( 1.0+dot(nor,rd), 0.0, 1.0), 5.0 );\n\t\tfloat foc = 1.0;\n        \n        vec3 mate = vec3(0.2);\n        vec2 mspe = vec2(0.0);\n        float mbou = 0.0;\n        float mter = 0.0;\n        if( res.y<1.5 )\n        {\n            vec3 te = textureBox( iChannel0, pos*0.05, nor ).xyz;\n            //mate = vec3(0.12,0.08,0.05) + 0.15*te;\n            mate = vec3(0.14,0.10,0.07) + 0.1*te;\n            mate *= 0.8 + 0.4*res.z;\n            mate *= 1.15;            \n            mspe = vec2(1.0,8.0);\n            mbou = 1.0;\n            \n            nor = doBumpMap( pos, nor );\n            \n            foc = 0.7 + 0.3*smoothstep(0.4,0.7,fbm4( 3.0*pos ));\n\n            float ho = 1.0;\n            if( pos.y>-7.5 ) ho *= smoothstep( 0.0, 5.0, (pos.y+7.5)  );\n            // horizontal occlusion in xz - something like negative lightsource -> darken areas inside\n            // measure angle of surface normal and ray to center of temple\n            ho = mix( 0.1+ho*0.3, 1.0, clamp( 0.6 + 0.4*dot( normalize(nor.xz*vec2(0.5,1.0)), normalize(pos.xz*vec2(0.5,1.0)) ) + 1.0*nor.y*nor.y, 0.0, 1.0 ) );\n            foc *= ho;\n            // ellipsoid 2 times x 4 times y for darkening floor\n            foc *= 0.4 + FLOOR_DARKENING_FACTOR*smoothstep( 2.0, 15.0, length(pos*vec3(1.0/2.0,1.0/4.0,1.0)) );\n            float rdis = clamp( -0.15*max(sdRhombus( pos.yz-vec2(8.3,0.0)+vec2(2.0,0.0), vec2(2.25,8.5), 0.05 ),-(pos.y-8.3+2.0)), 0.0, 1.0 );\n            if( rdis>0.0001 ) foc = 0.1 + sqrt(rdis);\n            // vertical gradients\n            // \"painting\" shadows on pillars and beneath ceiling  \n\t\t\tif( pos.y<5.8 ) foc *= 0.6 + SHADOW_Y_DEPTH*smoothstep( 0.0, 1.5, -(pos.y-5.8) );\n            if( pos.y<3.4 ) foc *= 0.6 + SHADOW_Y_DEPTH*smoothstep( 0.0, 5.5, -(pos.y-3.4)  );\n            foc *= 0.8;\n        }\n        else if( res.y<2.5 )\n        {\n            float h;\n            \n            {\n                #if (STEP != 6)\n                    // iChannel0 texture only for brown color variation\n                    mate = vec3(0.95,0.9,0.85) * 0.4*texture( iChannel0, pos.xz*0.015 ).xyz;\n                    #if (STEP >= 8)\n                        // wet \"shoreline\"\n                        mate *= WETLINE_DARKEN + 0.75*smoothstep( -25.0, -24.0, pos.y );\n                    #endif\n                #else\n                    mate = vec3(0.95,0.9,0.85) * 0.4;\n                #endif\n                mate *= 0.32;\n                #if (STEP != 6) && (STEP != 7) && (STEP != 8)\n                vec3 mor = doBumpMapGrass( pos.xz, nor, h );\n                mspe = vec2(2.5,4.0);\n                float is_grass = smoothstep( 0.9,0.95,mor.y);\n\n                #if (STEP != 9)\n                    mate = mix( mate, vec3(0.15,0.1,0.0)*0.8*0.7 + h*h*h*vec3(0.12,0.1,0.05)*0.15, is_grass );\n                    // remove specular lightning\n                    mspe = mix( mspe, vec2(0.5,4.0), is_grass );\n                #endif\n                nor = mor;\n                #endif\n                mter = 1.0;\n            }\n        }\n        else\n        {\n            // ocean\n            mate = OCEAN_BASE_COLOR*OCEAN_BASE_POWER;\n            #if (STEP!=11)\n                mate += OCEAN_COAST_COLOR*OCEAN_COAST_POWER*(1.0-smoothstep(0.0,10.0,pos.y-terrain(pos.xz)));\n                mate *= 0.4;\n                #if (STEP>12)\n                    float foam = (1.0-smoothstep(0.0,1.0,pos.y*1.01-terrain(pos.xz)));\n                    foam *= smoothstep( 0.2,0.6,texture(iChannel0,pos.xz*0.017).x );\n                    mate += vec3(0.05)*foam*0.85;\n                    #if (STEP>13)\n                        mspe = vec2(0.5,8.0);\n                        vec2 e = vec2(0.01,0.0);\n                        float ho = fbm4( (pos.xz     )*vec2(2.0,0.5) );\n                        float hx = fbm4( (pos.xz+e.xy)*vec2(2.0,0.5) );\n                        float hy = fbm4( (pos.xz+e.yx)*vec2(2.0,0.5) );\n                        float sm = (1.0-smoothstep(0.0,4.0,pos.y-terrain(pos.xz)));\n                        sm *= 0.02 + 0.03*foam;\n                        ho *= sm;\n                        hx *= sm;\n                        hy *= sm;\n\n                        nor = normalize( vec3(ho-hx,e.x,ho-hy) );\n                    #endif\n                #endif\n            #endif\n        }\n\n        float occ = 0.33 + 0.5*nor.y;\n        occ = calcOcclusion(pos,nor,ran) * foc * FAKE_OCCLUSION_FACTOR;\n        \n        vec3 lig = vec3(0);\n        float sm = 1.0-smoothstep(30.0,80.0, length(pos.xz));\n        lig = normalize(vec3(sunLig.x,sunLig.y+0.2*sm,sunLig.z))*SUN_POWER;\n        vec3 ligbak = normalize(vec3(-lig.x,0.0,-lig.z));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float sha = calcShadow( pos+nor*0.001, lig, 48.0 );\n              dif *= sha;\n        float amb = (0.8 + 0.2*nor.y);\n              amb = mix( amb, amb*(0.5+0.5*smoothstep( -8.0,-1.0,pos.y)), mbou );\n\n        float bou = 1.0;\n        bou = smoothstep(3.0, 1.0, length((pos.xz-vec2(5,-5)))*0.15);\n        bou *= clamp(0.5-0.5*nor.x,0.0,1.0);\n        vec3 qos = pos/1.5 - vec3(0.0,1.0,0.0);\n\n        float bak = clamp( 0.4+0.6*dot( nor, ligbak ), 0.0, 1.0 );\n              bak *= 0.6 + 0.4*smoothstep( -8.0,-1.0,qos.y);\n        \n        vec3 hal = normalize( lig -rd );\n        float spe = pow( clamp( dot(nor,hal), 0.0, 1.0), mspe.y )*(0.1+0.9*fre)*sha*(0.5+0.5*occ);\n\n        col = vec3(0.0);\n\n        col += amb*AMBIENT_POWER*AMBIENT_COLOR*occ*(1.0+mter);\n        col += dif*KEYLIGHT_POWER*KEYLIGHT_COLOR;\n        col += bak*BACKLIGHT_POWER*BACKLIGHT_COLOR*occ*mbou;\n        col += spe*8.0*mspe.x*occ;\n        // to lighten the inside of the temple add another bounce light\n        col += bou*BOUNCELIGHT_POWER*BOUNCELIGHT_COLOR*occ;\n        \n        col *= mate;\n        \n        //vec3 fogcol = FOG_COLOR*FOG_POWER;\n        // t = res.x\n        //float fog = 1.0 - exp(-FOG_EXPONENT*t);\n        //col *= 1.0-0.1*fog;\n        //col = mix( col, fogcol, fog );\n        vec3 fogcol = FOG_COLOR*FOG_POWER;\n        float sd = pow( clamp( 0.25 + 0.75*dot(lig,rd), 0.0, 1.0 ), 4.0 );\n\t    fogcol = mix( fogcol, vec3(1.0,0.25,0.042), sd*exp(-abs((60.0-50.0*sd)*abs(rd.y))) ) ;\n\n        float fog = 1.0 - exp(-FOG_EXPONENT*t);\n        col *= 1.0-0.5*fog;\n        col = mix( col, fogcol, fog*0.9 );\n    }\n\n    col = max( col, 0.0 );\n    \n    //col = LIGHT_POWER*col/(1.0+col*4.5);\n\n    col += OVEREXPOSE_POWER*OVEREXPOSE_COLOR*pow(clamp(dot(sunLig, rd),0.0,1.0),OVEREXPOSE);\n    col = 1.4*col/(1.0+col*4.5);\n    col = sqrt( col );\n    \n    col = clamp( 1.6*col-0.1, 0.0, 1.0 );\n    col = col*0.1 + 0.9*col*col*(3.0-2.0*col);\n    col = pow( col, vec3(0.96,0.98,1.0) );  \n\n    #ifdef STATICCAM\n        vec3 ocol = texelFetch( iChannel3, ivec2(fragCoord-0.5), 0 ).xyz;\n        if( iFrame==0 ) ocol = col;\n        col = mix( ocol, col, 0.05 );\n        fragColor = vec4( col, 1.0 );\n    #else\n        #ifdef AA\n            mat4 oldCam = mat4( texelFetch(iChannel3,ivec2(0,0),0),\n                                texelFetch(iChannel3,ivec2(1,0),0),\n                                texelFetch(iChannel3,ivec2(2,0),0),\n                                0.0, 0.0, 0.0, 1.0 );\n\n            // world space\n            vec4 wpos = vec4(ro + rd*resT,1.0);\n            // camera space\n            vec3 cpos = (wpos*oldCam).xyz; // note inverse multiply\n            // ndc space\n            vec2 npos = fl * cpos.xy / cpos.z;\n            // screen space\n            vec2 spos = 0.5 + 0.5*npos*vec2(iResolution.y/iResolution.x,1.0);\n            // undo dither\n            spos -= o/iResolution.xy;\n            // raster space\n            vec2 rpos = spos * iResolution.xy;\n\n            if( (rpos.y<1.0 && rpos.x<3.0) || (isThumbnail>0.5)  )\n            {\n            }\n            else\n            {\n                vec4 data = textureLod( iChannel3, spos, 0.0 );\n                vec3 ocol = data.xyz;\n                float dt = abs(data.w - resT)/resT;\n                if( iFrame==0 ) ocol = col;\n                col = mix( ocol, col, 0.1 + 0.5*smoothstep(0.1,0.2,dt) );\n            }\n\n            if( fragCoord.y<1.0 && fragCoord.x<3.0 )\n            {\n                if( abs(fragCoord.x-2.5)<0.5 ) fragColor = vec4( ca[2], -dot(ca[2],ro) );\n                if( abs(fragCoord.x-1.5)<0.5 ) fragColor = vec4( ca[1], -dot(ca[1],ro) );\n                if( abs(fragCoord.x-0.5)<0.5 ) fragColor = vec4( ca[0], -dot(ca[0],ro) );\n            }\n            else\n            {\n                fragColor = vec4( col*1.85, resT );\n            }\n        #else\n             col = pow(col, vec3(0.7));\t// gamma correction\n             fragColor = vec4( col*1.0, 1);\n        #endif\n    #endif\n    //fragColor = vec4( col, 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdRhombus( in vec2 p, in vec2 b, in float r ) \n{\n    vec2 q = abs(p);\n    float h = clamp( (-2.0*ndot(q,b) + ndot(b,b) )/dot(b,b), -1.0, 1.0 );\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    d *= sign( q.x*b.y + q.y*b.x - b.x*b.y );\n\treturn d - r;\n}\n\nfloat usdBox( in vec3 p, in vec3 b )\n{\n    return length( max(abs(p)-b,0.0 ) );\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( float p, float b )\n{\n  return abs(p) - b;\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 lim )\n{\n    return p-s*clamp(round(p/s),-lim,lim);\n}\n\nvec2 opRepLim( in vec2 p, in float s, in vec2 limmin, in vec2 limmax )\n{\n    return p-s*clamp(round(p/s),-limmin,limmax);\n}\n","name":"Common","description":"","type":"common"}]}