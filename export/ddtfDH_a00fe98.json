{"ver":"0.1","info":{"id":"ddtfDH","date":"1697158695","viewed":103,"name":"Depth Volume","username":"TwentySeven","description":"Literally depth-based volumes.\n(you may have to turn around to see anything)\nUse the mouse to look and use WASD to move.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["volumetric","depth"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define TAU 6.28318530718\n#define steps 8\n\n#define STORE_DE\nvec3 CSize;\nvec4 eStack[2];\nvec4 dStack[2];\nvec2 fcoord;\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec3 loadValue3( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re ){\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).xy;\n}\nmat3 RotationMatrix(vec3 axis, float angle){\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 fcoord = fragCoord;\n\tfloat m = (iMouse.x/iResolution.x)*20.0;\n\tfloat gTime = ((iTime+26.)*.2+m);\n    vec3 xy = vec3(fragCoord.xy,0.)/4.;\n\tvec3 uv = xy-(iResolution.xyx/8.);\n\n vec3 cameraPos= (loadValue3(camStore).xyz)*vec3(1,1,-1);\n    vec2 mou = loadValue2(rotationStore);\n\n    mou*= TAU;\n    mat3 mZ = RotationMatrix(vec3(.0, .0, 1.0), 0.);\n    mat3 mX = RotationMatrix(vec3(1.0, 0.0, .0), mou.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), -mou.x);\n\n    vec3 dir = vec3(uv.x, uv.y, 0.);\n\n    dir = mX * normalize(dir);\n\n\n    // Normalized pixel coordinates (from 0 to 1)\n    uv = uv*mX*mY;\n\n\n    vec3 wv = vec3(uv+cameraPos);\n    ivec3 jv = ivec3(0);\n    ivec3 kv = ivec3(0);\n    vec3 col = vec3(0);\n    float ran1 = 0.;\n\n    int scl=164;\n    float sle = 134.;\nfragColor = vec4(0);\n\n           for(int i=-steps;i<-1;++i){\n//random number generator because I can\n          \n             ran1 += \n             mix(0.1,1.,hash(vec3(uv.z+(iTime/4096.)+float(i),uv.x,uv.y)));\n\n                float RAN = ran1;\n\n//transforms the camera\n\n    wv =((wv-cameraPos)*\nabs(((1.)-(1./(float(i)*RAN))))\n+cameraPos);\n\n//intagers the float\n      jv = ivec3(wv)/64;\n      kv = ivec3(mod(wv,512.));\n    // The thingy\n\n\nint cubx = int(kv.x<scl)*int(kv.y<scl)*int(kv.z<scl);\nint cuby = int(kv.x>0)*int(kv.y>0)*int(kv.z>0);\nivec3 imsosmart = ivec3(textr[((jv.x)%3)+((jv.y*3)%9)+((jv.z*9)%27)]);\n \n col = clamp(vec3(imsosmart),0.,1.);\n\n \n    // Output to scree\n\n    fragColor +=(vec4(vec3(col),0));\n\n\n}\nfragColor /=float(steps);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec2 clickStore\t= vec2(4.,  0.);\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\n\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue1( in vec2 re, float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n\n\tfragColour = vec4(0);\n    float click = 0.0;\n    float oldClick = loadValue1(clickStore);\n    if (iFrame == 0) oldClick = 0.0;\n        \n    if (iMouse.z > 0.0)\n   \t{\n      if (oldClick == .0)\n        click = 1.0;\n    }\n  \n\tstoreValue1(clickStore, click,  fragColour, fragCoord);\n\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3Rr","filepath":"/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","previewfilepath":"/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin","type":"volume","channel":3,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Flying camera code...\n// by David Hoskins\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TAU 6.28318530718\n\n\nconst float KEY_W\t\t= 87.5/256.0;\nconst float KEY_A\t\t= 65.5/256.0;\nconst float KEY_S\t\t= 83.5/256.0;\nconst float KEY_D\t\t= 68.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\n\nconst float KEY_SPACE\t= 32.5/256.0;\nconst float KEY_SHIFT\t= 16.5/256.0;\n\n\nvec2 clickStoreA = vec2(4.0,  0.0);\nvec2 camStore = vec2(0.0,  0.0);\nvec2 rotationStore\t= vec2(1.,  0.);\nvec2 mouseStore = vec2(2.,  0.);\nvec2 startStore\t\t= vec2(3.,  0.);\nvec2 timeStore = vec2(6.0,  0.0);\n\n\nbool isKeyPressed(float key)\n{\n\treturn texture( iChannel2, vec2(key, 0.25) ).x > .0;\n}\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nvec4 loadValue4( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 );\n}\nvec3 loadValue3( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xyz;\n}\nvec2 loadValue2( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[1].xy, -100.0 ).xy;\n}\nfloat loadValue1( in vec2 re )\n{\n    return texture( iChannel1, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\nfloat loadValueA1( in vec2 re )\n{\n    return texture( iChannel0, (0.5+re) / iChannelResolution[0].xy, -100.0 ).x;\n}\n\nvoid storeValue4( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue3( in vec2 re, in vec3 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, 0.0) : fragColor;\n}\n\nvoid storeValue2( in vec2 re, in vec2 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0) : fragColor;\n}\nvoid storeValue1( in vec2 re, in float va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord, re) > 0.0 ) ? vec4(va, .0, .0, .0) : fragColor;\n}\nvec2 rot2D(inout vec2 p, float a)\n{\n    return cos(a)*p - sin(a) * vec2(p.y, -p.x);\n}\n\nmat3 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n   \tfragColour = vec4(0);\n    \n    \n\tvec2 tempStart \t= loadValue2(startStore);\n\tfloat click \t= loadValueA1(clickStoreA);\n    float time \t\t= loadValue1(timeStore);\n    \n    vec3 camPos;\n    vec2 rot;\n    if (iFrame == 0)\n    {\n        camPos = vec3(0.5,0.5,0.5);\n        rot = vec2(.0, 0.);\n    }else\n    {\n        camPos = loadValue3(camStore);\n        rot \t\t= loadValue2(rotationStore);\n    }\n\n\n    vec4 mouse = iMouse /iResolution.xyxy;\n    \n    if (click > 0.0)\n    {\n    \ttempStart = mouse.xy;// First clicked\n    }\n    if (mouse.z > 0.0)\n    \trot += mouse.xy - tempStart;\n    \n    \n\tstoreValue2(startStore, tempStart,  fragColour, fragCoord);\n\tstoreValue2(rotationStore, rot,  fragColour, fragCoord);\n    \n    rot*= TAU;\n    mat3 mX = RotationMatrix(vec3(1.0, .0, .0), rot.y);\n    mat3 mY = RotationMatrix(vec3(.0, 1.0, 0.0), -rot.x);\n    mX = mY * mX;\n    \n       \n    \n \n\t\n    time = iTime - time;\n    float speed = time*256.;\n    if (isKeyPressed(KEY_SPACE) || isKeyPressed(KEY_SHIFT)) speed*=4.0;\n    if (isKeyPressed(KEY_W) || isKeyPressed(KEY_UP))\n\t{\n\t\tcamPos += mX * vec3(0,0,1)* speed;\n\t}\n    if (isKeyPressed(KEY_S) || isKeyPressed(KEY_DOWN))\n\t{\n\t\tcamPos += mX * vec3(0,0,-1)* speed;\n    }\n  \tif (isKeyPressed(KEY_D) || isKeyPressed(KEY_RIGHT))\n\t{\n\t\tcamPos += mX * vec3(1,0,0)* speed;\n\t}\n\tif (isKeyPressed(KEY_A) || isKeyPressed(KEY_LEFT))\n\t{\n\t\tcamPos += mX * vec3(-1,0,0) * speed;\n\t}\n    storeValue3(camStore, camPos,  fragColour, fragCoord);\n    storeValue1(timeStore, iTime,  fragColour, fragCoord);\n            \n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\n\n\nfloat hash(vec3 p3)\n{\n\tp3  = fract(p3 * .10311);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\nint[27] textr = int[27](\n0,0,0,\n1,1,1,\n0,0,0,\n\n0,1,0,\n0,1,0,\n0,1,0,\n\n0,0,0,\n0,0,1,\n0,0,0\n\n);\nint[27] textg = int[27](\n0,0,0,\n0,1,0,\n0,0,0,\n\n0,0,0,\n0,1,0,\n0,0,0,\n\n0,0,0,\n0,1,0,\n0,0,0\n\n);\nint[27] textb = int[27](\n0,0,0,\n0,0,0,\n0,0,0,\n\n0,0,0,\n1,1,1,\n0,0,0,\n\n0,0,0,\n0,0,0,\n0,0,0\n\n);","name":"Common","description":"","type":"common"}]}