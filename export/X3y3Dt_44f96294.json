{"ver":"0.1","info":{"id":"X3y3Dt","date":"1718367484","viewed":64,"name":"Grey experiments...","username":"TomCarbon","description":"Grey experimentations, starting from scratch... and adding stuff step by step!\nUse mouse to zoom, space to move camera around..\n","likes":3,"published":1,"flags":16,"usePreview":0,"tags":["raymarch","zoom","antialias","specular","gamma"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Some experimentations with ShaderToy\n// 2024 - Tom Carbon\n//\n\n#define KEY_SPACE   32\n#define KEY_N       78\n\n\nconst int kAntiAlias = 3;\n\nconst float lensSize = 0.7;\nconst float lensBorder = 0.01;\nconst float lensZoom = 3.2;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n\n    // camera\n    vec3 ro = vec3(0.0, 1.5, 6.0);\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n\n    // zoom\n    bool zoom = t < 0.1;\n    vec2 lensPosition = -vec2(0.76, 0.3);\n\n    // light\n    vec3 lightPosition = vec3(0.0, 6.0, 0.0);\n    float lightAngle = t * 0.5;\n    lightPosition.xz = 6.0 * vec2(cos(lightAngle), sin(lightAngle));\n\n\n    // input\n    if (texelFetch(iChannel0, ivec2(KEY_SPACE, 0), 0).x > 0.0)\n        ro.xz = 8.0 * vec2(cos(t), sin(t));\n\n    vec3 ww = normalize(lookAt - ro);\n    vec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));\n    vec3 vv = normalize(cross(uu, ww));\n\n    if (iMouse.z > 0.5)\n    {\n        zoom = true;\n        lensPosition = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    }\n\n    if (t < 14.0)\n    {\n        zoom = true;\n    }\n    \n    // render\n    vec3 pixel;\n    for(int aa = 0; aa < kAntiAlias * kAntiAlias; ++aa)\n    {\n        vec2 aad = vec2(float(aa % kAntiAlias), float(aa / kAntiAlias)) / float(kAntiAlias);\n        vec2 uv = (2.0 * fragCoord + aad - iResolution.xy) / iResolution.y;\n\n        float d = length(uv - lensPosition);\n        bool zoomed = zoom ? d < lensSize - lensBorder : false;\n\n        vec3 rd = normalize(uv.x * uu + uv.y * vv + (zoomed ? lensZoom : 1.5) * ww);\n\n        vec3 color = zoom ? (length(d - lensSize) < lensBorder ? vec3(0.3) :\n            mix(getColor(ro, rd, lightPosition, zoomed), vec3(0), zoomed ? 0.2 : 0.8)) : \n                getColor(ro, rd, lightPosition, zoomed);\n\n        pixel += color;\n    }\n\n    // antialias + gamma\n    pixel = pow(pixel / float(kAntiAlias * kAntiAlias), vec3(1.0 / 2.2));\n\n    fragColor = vec4(pixel, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const int kMaxSteps = 254;\nconst float kSurfaceDist = 0.001;\n\nstruct Quaternion {\n    float w;\n    vec3 xyz;\n};\n\nQuaternion quatMultiply(Quaternion q1, Quaternion q2)\n{\n    Quaternion result;\n\n    result.w = q1.w * q2.w - dot(q1.xyz, q2.xyz);\n    result.xyz = q1.w * q2.xyz + q2.w * q1.xyz + cross(q1.xyz, q2.xyz);\n\n    return result;\n}\n\nQuaternion quatConjugate(Quaternion q)\n{\n    Quaternion result;\n\n    result.w = q.w;\n    result.xyz = -q.xyz;\n\n    return result;\n}\n\nQuaternion quaternion(float angle, vec3 axis)\n{\n    Quaternion q;\n    angle *= 0.5;\n    q.w = cos(angle);\n    q.xyz = axis * sin(angle);\n    return q;\n}\n    \n\nvec3 rotateVectorByQuaternion(vec3 v, Quaternion q)\n{\n    Quaternion q_v;\n    q_v.w = 0.0;\n    q_v.xyz = v;\n\n    Quaternion q_conjugate = quatConjugate(q);\n\n    Quaternion q_result = quatMultiply(quatMultiply(q, q_v), q_conjugate);\n\n    return q_result.xyz;\n}\n\n\nfloat sdSphere(vec3 p, vec4 sphere)\n{\n    return length(p - sphere.xyz) - sphere.w;\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdRoundedBox(vec3 p, vec3 offset, vec3 size, float r)\n{\n    vec3 d = abs(p - offset) - size + r;\n    return length(max(d, 0.0)) + min(0.0, max(d.x, max(d.y, d.z))) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\n\nfloat sdScene(vec3 p, bool shadows)\n{\n    float d = p.y + 0.01;\n\n    d = min(d, sdTorus(p - vec3(0, 3, 0), vec2(3.0, 0.06)));\n    d = min(d, sdTorus(p - vec3(0, .01, 0), vec2(3.6, 0.2)));\n\n    if (sdBox(p - vec3(0,2.0,0), vec3(2.0, 1.0, 2.5)) < 1.0)\n    {\n        d = min(d, sdSphere(p, vec4(0.0, 1.0, 0.0, 1.0)));\n        d = min(d, sdSphere(p, vec4(-1.0, 0.75, 1.75, 0.75)));\n        d = min(d, sdSphere(p, vec4(0.75, 0.5, 1.25, 0.5)));\n    }\n\n    vec3 rp = rotateVectorByQuaternion(p, quaternion(radians(-23.0), vec3(1.0, 0.0, 0.0)));\n    d = min(d, sdRoundedBox(rp, vec3(-2.75, 2.25, 1.25), vec3(0.75), 0.5));\n   \n    rp = rotateVectorByQuaternion(p, quaternion(radians(-23.0), vec3(0.0, 1.0, 0.0)));\n    d = min(d, sdRoundedBox(rp, vec3(3.0, 1.5, -1.5), vec3(0.5), 0.1));\n\n    rp = rotateVectorByQuaternion(p, quaternion(radians(-23.0), normalize(vec3(2.0, 1.0, 1.0))));\n    d = min(d, sdBox(rp - vec3(3.0, 2.8, 0), vec3(0.4)));\n\n    return d;\n}\n\nfloat rayMarch(vec3 ro, vec3 rd, float min, float max, bool shadows)\n{\n    float d = min;\n    \n    for (int i = 0; i < kMaxSteps; ++i)\n    {\n        vec3 p = ro + d * rd;\n\n        float sd = sdScene(p, shadows);\n        if (sd < 0.0f) return -1.0;\n\n        d += sd;\n\n        if (sd < kSurfaceDist || d > max)\n            break;\n    }\n    \n    return d;\n}\n\n\nvec3 getNormal(vec3 p)\n{\n    vec2 e = vec2(0.0, 0.001);\n    \n    vec3 n = sdScene(p, false) - vec3(\n              sdScene(p - e.yxx, false),\n              sdScene(p - e.xyx, false),\n              sdScene(p - e.xxy, false));\n        \n    return normalize(n);\n}\n\nfloat getLighting(vec3 p, vec3 viewDirection, vec3 lightPosition)\n{\n    vec3 n = getNormal(p);\n    vec3 lightDirection = normalize(lightPosition - p);\n    float ld = length(lightPosition - p);\n\n    float lighting = clamp(dot(n, lightDirection), 0.0, 1.0);\n\n    float shininess = 160.0;\n    vec3 reflectionDirection = reflect(-lightDirection, n);\n    float specularStrength = pow(max(dot(viewDirection, reflectionDirection), 0.0), shininess);\n \n    float d = rayMarch(p + n * 2.0 * kSurfaceDist, lightDirection, 0.0, ld, true);\n    if (d > 0.0 && d < ld)\n        lighting *= 0.1;\n\n    return clamp(0.8 * lighting + specularStrength, 0.0, 1.0);\n}\n\nvec3 getColor(vec3 ro, vec3 rd, vec3 lightPosition, bool showNormals)\n{\n    vec3 color = vec3(0.23);\n\n    float d = rayMarch(ro, rd, 0.0, 100.0, false);\n    if (d < 0.0) return vec3(1,0,0); // bounding box debugging\n\n    if (d < 100.0)\n    {\n        vec3 p = ro + d * rd;\n\n        float ambient = 0.1;\n        float diffuse = getLighting(p, normalize(ro), lightPosition);\n        if (diffuse < 0.0)\n            return vec3(1,0,0);\n        color = vec3(clamp(ambient + diffuse, 0.0, 1.0));\n        if (showNormals)\n            color *= clamp(getNormal(p), 0.0, 1.0);\n    }\n\n    return color;\n}","name":"Common","description":"","type":"common"}]}