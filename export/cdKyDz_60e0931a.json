{"ver":"0.1","info":{"id":"cdKyDz","date":"1695993564","viewed":123,"name":"Spectrum of Sunlight","username":"MartyMcFly","description":"Actual spectral intensities in sunlight after converting to RGB. Not the same as wavelength->RGB using CIE colorspace math or color matching fit.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["spectrum","rgb","wavelength"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Most plotted visualizations of the _actual_ rainbow are false. \n//Common fits for visible spectrum like Zucchoni6 assume equal intensity across the spectrum\n\n//This however is not the case in sunlight and thus for e.g. simulating chromatic aberration\n//the actual density values for the illuminant have to be taken. This is a numerical fit on pure sunlight\n\n//Source data and numerical fit from https://stackoverflow.com/questions/3407942/rgb-values-of-visible-spectrum\n\n\nvoid mainImage( out vec4 o, in vec2 p )\n{\n\n    float lambdas[9] = float[](350.0,397.0,423.0,464.0,514.0,565.0,606.0,646.0,750.0);\n    \n    vec3 spline_weights[8*3] = vec3[]\n    (   \n            \n        //350,\n            vec3(3.08919e-5,-2.16243e-2, 3.78425e+0),\n            vec3(0.00000e+0, 0.00000e+0, 0.00000e+0),\n            vec3(4.33926e-5,-3.03748e-2, 5.31559e+0),\n        //397,\n            vec3(-5.53952e-5, 4.68877e-2,-9.81537e+0),\n            vec3(6.13203e-5,-4.86883e-2, 9.66463e+0),\n            vec3(4.41410e-4,-3.46401e-1, 6.80468e+1),\n        //423,\n            vec3(-3.09111e-5, 2.61741e-2,-5.43445e+0),\n            vec3(1.85633e-4,-1.53857e-1, 3.19077e+1),\n            vec3(-4.58520e-4, 4.14940e-1,-9.29768e+1),\n        //464,\n            vec3(2.86786e-5,-2.91252e-2, 7.39499e+0),\n            vec3(-1.66581e-4, 1.72997e-1,-4.39224e+1),\n            vec3(4.37994e-7,-1.09728e-2, 5.83495e+0),\n        //514,\n            vec3(2.06226e-4,-2.11644e-1, 5.43024e+1),\n            vec3(-6.65652e-5, 7.01815e-2,-1.74987e+1),\n            vec3(9.41471e-5,-1.07306e-1, 3.05925e+1),\n        //565,\n            vec3(-2.78514e-4, 3.36113e-1,-1.00439e+2),\n            vec3(-1.79851e-4, 1.98194e-1,-5.36623e+1),\n            vec3(1.12142e-5,-1.35916e-2, 4.11826e+0),\n        //606,\n            vec3(-1.44403e-4, 1.73570e-1,-5.11884e+1),\n            vec3(2.47312e-4,-3.19527e-1, 1.03207e+2),\n            vec3(0.00000e+0, 0.00000e+0, 0.00000e+0),\n        //646,\n            vec3(6.24947e-5,-9.37420e-2, 3.51532e+1),\n            vec3(0.00000e+0, 0.00000e+0, 0.00000e+0),\n            vec3(0.00000e+0, 0.00000e+0, 0.00000e+0)\n    );\n    \n    vec2 uv = p/iResolution.xy;    \n    vec3 col = vec3(0);\n    \n    float lambda = mix(350.0, 750.0, uv.x);\n    \n    for(int j = 0; j < 8; j++)\n    {\n        if(lambda > lambdas[j] && lambda <= lambdas[j+1])\n        {\n            vec3 monomials = vec3(lambda * lambda, lambda, 1.0);\n            col.r += dot(spline_weights[j * 3 + 0], monomials);\n            col.g += dot(spline_weights[j * 3 + 1], monomials);\n            col.b += dot(spline_weights[j * 3 + 2], monomials);\n            break;\n        }   \n    }   \n    \n    vec3 curve = uv.y - col;    \n    curve /= sqrt(dFdy(curve)*dFdy(curve) + dFdx(curve)*dFdx(curve));\n    \n    #define max3(v) max(max(v.x, v.y), v.z)\n    \n    vec3 curve_outer = smoothstep(3.0, 0.0, abs(curve));\n    curve = smoothstep(3.0, 0.0, abs(curve));\n    \n    //plot intensities with some darker outline to ensure the graph is visible against background\n    float is_curve_outline = max3(curve_outer);\n    float is_curve = max3(curve);\n    col = mix(col, vec3(0), vec3(is_curve_outline));\n    col = mix(col, curve, vec3(is_curve));  \n    \n    //source data is linear RGB, so apply sRGB conversion\n    #define from_linear(x)  (1.14374*(-0.126893*(x)+sqrt((x))))\n\n    o = vec4(from_linear(col),1.0);\n}","name":"Image","description":"","type":"image"}]}