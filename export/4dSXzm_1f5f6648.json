{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"float performance = 0.15; // 0-1, smaller for better accuracy\n\nmat3 rot;\n\nfloat distanceFrom(in vec3 p) {\n    p = mod(p+2.0,4.0)-2.0; // repeat every 2m\n    float s = 0.8;\n    \n    p *= rot; // rotate\n    vec3 mountains = sin(p*10.) * sin(iTime*0.3) * 0.8;\n    \n    return length(max(abs(p)+length(mountains)-s,0.0));\n}\n\n// calculate approximate normal vector\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(0.001,0);\n    return normalize(\n        vec3(distanceFrom(p+e.xyy) - distanceFrom(p-e.xyy),\n             distanceFrom(p+e.yxy) - distanceFrom(p-e.yxy),\n             distanceFrom(p+e.yyx) - distanceFrom(p-e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1. + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    \n    float r = iTime;\n    rot = mat3(\n    \t1,      0,       0,\n    \t0, cos(r), -sin(r),\n   \t\t0, sin(r),  cos(r));\n    vec3 rayOrigin = vec3(0,0,2);\n    vec3 rayDirection = normalize(vec3(p, -1.0));\n    \n    \n    float nearestDistance = 1.0;\n    float traveled = 0.0;\n    float maxTravel = min(iTime,60.);\n    for(int i=0;i<10000;i++) {\n        if(nearestDistance < 0.0001 || traveled > maxTravel) break;\n        nearestDistance = distanceFrom(rayOrigin + traveled*rayDirection);\n        traveled += nearestDistance*performance;\n    }\n    \n    vec3 lightingDirection = normalize(vec3(1));\n    vec3 color = vec3(0,0,0);\n    \n    if(traveled < maxTravel) {\n        vec3 pos = rayOrigin + traveled*rayDirection;\n        vec3 nor = calcNormal(pos);\n        // lighting\n        color += vec3(1,0.8,0.5) * clamp(dot(nor,lightingDirection),0.0,1.0);\n        color += vec3(0.2,0.3,0.4) * clamp(nor.y,0.0,1.0);\n        color += 0.1;\n    }\n        \n    \n    fragColor = vec4(color, 1);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dSXzm","date":"1410128168","viewed":318,"name":"Distance Field Cubes","username":"phiresky","description":"just testing distance field ray marching with a simple deformation","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefield"],"hasliked":0,"parentid":"","parentname":""}}