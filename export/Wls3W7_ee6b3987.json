{"ver":"0.1","info":{"id":"Wls3W7","date":"1556541607","viewed":76,"name":"baseStudy","username":"zhangyuntao","description":"base components","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["base"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nvec4 blur(vec2 p, float blurRadius, float sampleNum )\n{\n    if ( p.x<0.33 && blurRadius > 0.0 && sampleNum > 1.0)\n    {\n        vec4 col = vec4(0);\n        vec2 unit = 1.0 / iResolution.xy;\n        \n        float r = blurRadius;\n        float sampleStep = r / sampleNum;\n        \n        float count = 0.0;\n        \n        for(float x = -r; x < r; x += sampleStep)\n        {\n            for(float y = -r; y < r; y += sampleStep)\n            {\n                float weight = (r - abs(x)) * (r - abs(y));\n                col += texture(iChannel0, p + vec2(x * unit.x, y * unit.y)) * weight;\n                count += weight;\n            }\n        }\n        \n        return col / count;\n    }else if(p.x >0.66){\n        vec4 c = texture(iChannel0, p);\n    \treturn vec4(0.7126*c.r + 0.0152*c.g + 0.2722*c.b);\n    }\n    \n    return texture(iChannel0, p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // viewport resolution (in pixels)\n    vec3 resolution = iResolution;    \n\t\n    // shader playback time (in seconds)\n    float time = iTime;                 \n    \n    vec2 center = resolution.xy / 2.0;    \n    \n    /*\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    \n    float sign = circle(fragCoord,center,20.0,2.0);\n    \n    vec3 vColour = vec3(0.0);\n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(8.0, 15.0);\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue(fragCoord, vec2(0.0, 5.0), vFontSize, resolution.x, 4.0, 0.0));\n\t\n    fragColor = vec4(sign+col+vColour,1.0);    \n    \n    fragColor = vec4(fragCoord.y > 10.0 && fragCoord.y < 20.0 ? 1 : 0, 0,0,1);\n \t*/\n        \n    vec4 col = blur(uv, 20.0, 6.0); //* v_fragmentColor.rgb;\n    fragColor = vec4(col); //* v_fragmentColor;\n    \n    //vec4 c = texture(iChannel0, uv);\n    //fragColor = vec4(0.7126*c.r + 0.0152*c.g + 0.2722*c.b);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n//填充一个圆的数学模型是 判断点是否在圆内\n//params: \n// p： 当前屏幕的uv坐标\n// center : 圆的中心点\n// radius:圆的半径\n// blur: 圆的边缘平滑度\nfloat circle(vec2 p,vec2 center,float radius,float blur)\n{\n    //计算坐标点与中心点的长度\n    float len = length(p-center);\n    //如果长度比半径小，则判断在圆内；反之则在圆外\n    //这里用到smoothstep 用来处理边界平滑度，既如果半径在len-blur和len之间时执行平滑埃尔米特差值\n    float sign = smoothstep(len-blur,len,radius);\n    return sign;\n}\n","name":"Common","description":"","type":"common"}]}