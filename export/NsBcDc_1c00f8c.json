{"ver":"0.1","info":{"id":"NsBcDc","date":"1644191443","viewed":119,"name":"by StanislavPetrov","username":"jorge2017a2","description":"by StanislavPetrov ...mouse","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["bystanislavpetrov"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//by  StanislavPetrovV\n//https://github.com/StanislavPetrovV/Advanced_RayMarching\n//https://www.youtube.com/watch?v=2fcO9RUOGg4\n vec2 u_resolution;\n vec2 u_mouse;\n float u_time;\n float u_scroll;\nconst float FOV = 1.0;\nconst int MAX_STEPS = 128;\nconst float MAX_DIST = 500.;\nconst float EPSILON = 0.01;\n\n// choose antialising - 1 2 3 4\nconst int AA = 1;  \n\nfloat cubeSize = 6.0;\n\nfloat cubeScale ;\nfloat roofScale = 0.15;\nfloat pedestalScale = 0.3;\nfloat floorScale = 0.15;\nfloat sphereScale = 0.2;\nfloat wallScale = 0.12;\n\nfloat roofBumpFactor = 0.31;\nfloat sphereBumpFactor = 0.21;\nfloat wallBumpFactor = 0.06;\n\n\nvoid translateSphere(inout vec3 p) {\n    p.y -= 4.4;\n}\n\nvoid rotateSphere(inout vec3 p) {\n    pR(p.xz, 0.3 * u_time);\n}\n\nvoid translateCube(inout vec3 p) {\n    p.y -= 2.5;\n    p.xz += 1.5;\n}\n\nvoid rotateCube(inout vec3 p) {\n    pR(p.yz, PI / 4.0);\n    pR(p.xz, u_time);\n}\n\n\nvec3 triPlanar(sampler2D tex, vec3 p, vec3 normal) {\n    normal = abs(normal);\n    normal = pow(normal, vec3(5.0));\n    normal /= normal.x + normal.y + normal.z;\n    return (texture(tex, p.xy * 0.5 + 0.5) * normal.z +\n            texture(tex, p.xz * 0.5 + 0.5) * normal.y +\n            texture(tex, p.yz * 0.5 + 0.5) * normal.x).rgb;\n}\n\n\nfloat bumpMapping(sampler2D tex, vec3 p, vec3 n, float dist, float factor, float scale) {\n    float bump = 0.0;\n    if (dist < 0.1) {\n        vec3 normal = normalize(n);\n        bump += factor * triPlanar(tex, (p * scale), normal).r;\n    }\n    return bump;\n}\n\n\nvec2 fOpUnionID(vec2 res1, vec2 res2) {\n    return (res1.x < res2.x) ? res1 : res2;\n}\n\nvec2 fOpDifferenceID(vec2 res1, vec2 res2) {\n    return (res1.x > -res2.x) ? res1 : vec2(-res2.x, res2.y);\n}\n\nvec2 fOpDifferenceColumnsID(vec2 res1, vec2 res2, float r, float n) {\n    float dist = fOpDifferenceColumns(res1.x, res2.x, r, n);\n    return (res1.x > -res2.x) ? vec2(dist, res1.y) : vec2(dist, res2.y);\n}\n\nvec2 fOpUnionStairsID(vec2 res1, vec2 res2, float r, float n) {\n    float dist = fOpUnionStairs(res1.x, res2.x, r, n);\n    return (res1.x < res2.x) ? vec2(dist, res1.y) : vec2(dist, res2.y);\n}\n\nvec2 fOpUnionChamferID(vec2 res1, vec2 res2, float r) {\n    float dist = fOpUnionChamfer(res1.x, res2.x, r);\n    return (res1.x < res2.x) ? vec2(dist, res1.y) : vec2(dist, res2.y);\n}\n\n/*\n/*-- map, getMaterial functions --*/\n\n\nvec2 getPedestal(vec3 p) {\n    float ID = 9.0;\n    float resDist;\n    // box 1\n    p.y += 13.8;\n    float box1 = fBoxCheap(p, vec3(8, 0.4, 8));\n    // box 2\n    p.y -= 6.4;\n    float box2 = fBoxCheap(p, vec3(7, 6, 7));\n    // box 3\n    pMirrorOctant(p.zx, vec2(7.5, 7.5));\n    float box3 = fBoxCheap(p, vec3(5, 4, 1));\n    // res\n    resDist = box1;\n    resDist = min(resDist, box2);\n    resDist = fOpDifferenceColumns(resDist, box3, 1.9, 10.0);\n    return vec2(resDist, ID);\n}\n\nvec2 map(vec3 p)\n{\n    vec3 tmp, op = p;\n    // plane\n    float planeDist = fPlane(p, vec3(0, 1, 0), 14.0);\n    float planeID = 6.0;\n    vec2 plane = vec2(planeDist, planeID);\n\n    // cube\n//    vec3 pb = p;\n//    translateCube(pb);\n//    rotateCube(pb);\n//    float cubeDist = fBoxCheap(pb, vec3(cubeSize));\n//    float cubeID = 5.0;\n//    vec2 cube = vec2(cubeDist, cubeID);\n\n    // pedestal\n    vec2 pedestal = getPedestal(p);\n\n    // sphere\n    vec3 ps = p;\n    translateSphere(ps);\n    rotateSphere(ps);\n    float sphereDist = fSphere(ps, 6.0);\n    sphereDist += bumpMapping(iChannel3, ps, ps + sphereBumpFactor,\n                              sphereDist, sphereBumpFactor, sphereScale);\n    sphereDist += sphereBumpFactor;\n    float sphereID = 10.0;\n    vec2 sphere = vec2(sphereDist, sphereID);\n\n    // manipulation operators\n    pMirrorOctant(p.xz, vec2(50., 50.));\n    p.x = -abs(p.x) + 20.;\n    pMod1(p.z, 15.);\n\n    // roof\n    vec3 pr = p;\n    pr.y -= 15.7;\n    pR(pr.xy, 0.6);\n    pr.x -= 18.0;\n    float roofDist = fBox2Cheap(pr.xy, vec2(20, 0.5));\n    roofDist -= bumpMapping(iChannel3, p, p - roofBumpFactor, roofDist, roofBumpFactor, roofScale);\n    roofDist += roofBumpFactor;\n    float roofID = 8.0;\n    vec2 roof = vec2(roofDist, roofID);\n\n    // box\n    float boxDist = fBoxCheap(p, vec3(3,9,4));\n    float boxID = 7.0;\n    vec2 box = vec2(boxDist, boxID);\n\n    // cylinder\n    vec3 pc = p;\n    pc.y -= 9.0;\n    float cylinderDist = fCylinder(pc.yxz, 4., 3.);\n    float cylinderID = 7.0;\n    vec2 cylinder = vec2(cylinderDist, cylinderID);\n\n    // wall\n    float wallDist = fBox2Cheap(p.xy, vec2(1, 15));\n    wallDist -= bumpMapping(iChannel2, op, op + wallBumpFactor, wallDist, wallBumpFactor, wallScale);\n    wallDist += wallBumpFactor;\n    float wallID = 7.0;\n    vec2 wall = vec2(wallDist, wallID);\n\n    // result\n    vec2 res;\n    res = fOpUnionID(box, cylinder);\n    res = fOpDifferenceColumnsID(wall, res, 0.6, 3.0);\n    res = fOpUnionChamferID(res, roof, 0.6);\n    res = fOpUnionStairsID(res, plane, 4.0, 5.0);\n    res = fOpUnionID(res, sphere);\n    res = fOpUnionID(res, pedestal);\n//    res = fOpUnionID(res, cube);\n    res = res;\n    return res;\n}\n\nvec3 getMaterial(vec3 p, float id, vec3 normal) {\n    vec3 m;\n    switch (int(id)) {\n        case 1:\n        m = vec3(0.9, 0.0, 0.0); break;\n\n        case 2:\n        m = vec3(0.2 + 0.4 * mod(floor(p.x) + floor(p.z), 2.0)); break;\n\n        case 3:\n        m = vec3(0.7, 0.8, 0.9); break;\n\n        case 4:\n        vec2 i = step(fract(0.5 * p.xz), vec2(1.0 / 10.0));\n        m = ((1.0 - i.x) * (1.0 - i.y)) * vec3(0.37, 0.12, 0.0); break;\n\n        // cube\n        case 5:\n//        translateCube(p);\n//        rotateCube(p);\n//        rotateCube(normal);\n        m = triPlanar(iChannel0, p * cubeScale, normal); break;\n\n        // floor\n        case 6:\n        m = triPlanar(iChannel1, p * floorScale, normal); break;\n\n        // walls\n        case 7:\n        m = triPlanar(iChannel2, p * wallScale, normal); break;\n\n        // roof\n        case 8:\n        m = triPlanar(iChannel3, p * roofScale, normal); break;\n\n        // pedestal\n        case 9:\n        m = triPlanar(iChannel0, p * pedestalScale, normal); break;\n\n        // sphere\n        case 10:\n        translateSphere(p);\n        rotateSphere(p);\n        rotateSphere(normal);\n        m = triPlanar(iChannel1, p * sphereScale, normal); break;\n\n        // roof bump\n        case 11:\n        m = triPlanar(iChannel2, p * roofScale, normal); break;\n\n        default:\n        m = vec3(0.4); break;\n    }\n    return m;\n}\n\n\n\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n    vec2 hit, object;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + object.x * rd;\n        hit = map(p);\n        object.x += hit.x;\n        object.y = hit.y;\n        if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }\n    return object;\n}\n\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(EPSILON, 0.0);\n    vec3 n = vec3(map(p).x) - vec3(map(p - e.xyy).x, map(p - e.yxy).x, map(p - e.yyx).x);\n    return normalize(n);\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 1.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        float hit = map(p + lightPos * dist).x;\n        res = min(res, hit / (dist * lightSize));\n        dist += hit;\n        if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nfloat getAmbientOcclusion(vec3 p, vec3 normal) {\n    float occ = 0.0;\n    float weight = 1.0;\n    for (int i = 0; i < 8; i++) {\n        float len = 0.01 + 0.02 * float(i * i);\n        float dist = map(p + normal * len).x;\n        occ += (len - dist) * weight;\n        weight *= 0.85;\n    }\n    return 1.0 - clamp(0.6 * occ, 0.0, 1.0);\n}\n\n\nvec3 getLight(vec3 p, vec3 rd, float id) {\n    vec3 lightPos = vec3(20.0, 55.0, -25.0);\n    vec3 L = normalize(lightPos - p);\n    vec3 N = getNormal(p);\n    vec3 V = -rd;\n    vec3 R = reflect(-L, N);\n\n    vec3 color = getMaterial(p, id, N);\n\n    vec3 specColor = vec3(0.6, 0.5, 0.4);\n    vec3 specular = 1.3 * specColor * pow(clamp(dot(R, V), 0.0, 1.0), 10.0);\n    vec3 diffuse = 0.9 * color * clamp(dot(L, N), 0.0, 1.0);\n    vec3 ambient = 0.05 * color;\n    vec3 fresnel = 0.15 * color * pow(1.0 + dot(rd, N), 3.0);\n\n    // shadows\n    float shadow = getSoftShadow(p + N * 0.02, normalize(lightPos));\n    // occ\n    float occ = getAmbientOcclusion(p, N);\n    // back\n    vec3 back = 0.05 * color * clamp(dot(N, -L), 0.0, 1.0);\n\n    //return  (back + ambient + fresnel) * occ + (specular * occ + diffuse) * shadow;\n    return  (back+ambient + fresnel) * occ + (specular * occ + diffuse) * shadow;\n//    return back;\n}\n\n\nmat3 getCam(vec3 ro, vec3 lookAt) {\n    vec3 camF = normalize(vec3(lookAt - ro));\n    vec3 camR = normalize(cross(vec3(0, 1, 0), camF));\n    vec3 camU = cross(camF, camR);\n    return mat3(camR, camU, camF);\n}\n\n\nvoid mouseControl(inout vec3 ro) {\n    vec2 m = iMouse.xy / iResolution.xy;\n    pR(ro.yz, m.y * PI * 0.39 - 0.39);\n    pR(ro.xz, m.x * TAU);\n}\n\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\n\n\nvec3 render(vec2 uv) {\n    vec3 col = vec3(0);\n    vec3 background = vec3(0.5, 0.8, 0.9);\n\n    //vec3 ro = vec3(36.0, 19.0, -36.0) / u_scroll;\n    \n    float t1=mod(iTime,3.0);\n    float t2=mod(iTime,6.0);\n    vec3 ro,rd;\n    if (t1<t2)\n    {\n     ro = vec3(36.0, 19.0, -36.0); \n     mouseControl(ro);\n\n        vec3 lookAt = vec3(0, 1, 0);\n        rd = getCam(ro, lookAt) * normalize(vec3(uv, FOV));\n    }\n    else\n    {\n       ro=vec3(0.0,7.0,-20.0);\n       //ro= getMouse(ro);\n       mouseControl(ro);\n        rd=normalize( vec3(uv.x,uv.y,1.0));\n        rd= rotate_y(rd, radians(180.0));\n    }\n    \n    vec2 object = rayMarch(ro, rd);\n\n    if (object.x < MAX_DIST) {\n        vec3 p = ro + object.x * rd;\n        col += getLight(p, rd, object.y);\n        // fog\n        col = mix(col, background, 1.0 - exp(-1e-7 * object.x * object.x * object.x));\n    } else {\n        col += background - max(0.9 * rd.y, 0.0);\n    }\n    return col;\n}\n\n\nvec2 getUV(vec2 offset) \n{\n    return (2.0 * (gl_FragCoord.xy + offset) - iResolution.xy) / iResolution.y;\n}\n\nvec2 getUV(vec2 offset, vec2 frag) \n{\n    return (2.0 * (gl_FragCoord.xy + offset) - iResolution.xy) / iResolution.y;\n}\n\n\n\nvec3 renderAAx1() {\n    return render(getUV(vec2(0)));\n}\n\n\nvec3 renderAAx2() {\n    float bxy = (gl_FragCoord.x + gl_FragCoord.y) ;\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.33 * nbxy, 0.))) + render(getUV(vec2(0.33 * bxy, 0.66))));\n    return colAA / 2.0;\n}\n\n\nvec3 renderAAx3() {\n    float bxy = (gl_FragCoord.x + gl_FragCoord.y);\n    float nbxy = 1. - bxy;\n    vec3 colAA = (render(getUV(vec2(0.66 * nbxy, 0.))) +\n                  render(getUV(vec2(0.66 * bxy, 0.66))) +\n                  render(getUV(vec2(0.33, 0.33))));\n    return colAA / 3.0;\n}\n\n\nvec3 renderAAx4() {\n    vec4 e = vec4(0.125, -0.125, 0.375, -0.375);\n    vec3 colAA = render(getUV(e.xz)) + render(getUV(e.yw)) + render(getUV(e.wx)) + render(getUV(e.zy));\n    return colAA /= 4.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cubeScale = 1.0 / cubeSize;\n    u_scroll=1.0;\n    //vec3 color = (AA == 1) ? renderAAx1() : (AA == 2) ? renderAAx2() : (AA == 3) ? renderAAx3(): renderAAx4();\n    vec3 color= render( getUV(vec2(0.0), fragCoord)  );  \n    \n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5.)*0.5 + 0.5)\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n// Blobby ball object. You've probably seen it somewhere. This is not a correct distance bound, beware.\nfloat fBlob(vec3 p) {\n\tp = abs(p);\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tif (p.x < max(p.y, p.z)) p = p.yzx;\n\tfloat b = max(max(max(\n\t\tdot(p, normalize(vec3(1., 1., 1.))),\n\t\tdot(p.xz, normalize(vec2(PHI+1., 1.)))),\n\t\tdot(p.yx, normalize(vec2(1., PHI)))),\n\t\tdot(p.xz, normalize(vec2(1., PHI))));\n\tfloat l = length(p);\n\treturn l - 1.5 - 0.2 * (1.5 / 2.)* cos(min(sqrt(1.01 - b / l)*(PI / 0.25), PI));\n}\n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = clamp((dot(p - a, ab) / dot(ab, ab)), 0.0, 1.0);\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r\nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.0)) {\n\t\td = max(d, length(tip));\n\t}\n\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n//\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n//\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n//\n\nconst vec3 GDFVectors[19] = vec3[](\n\tnormalize(vec3(1, 0, 0)),\n\tnormalize(vec3(0, 1, 0)),\n\tnormalize(vec3(0, 0, 1)),\n\n\tnormalize(vec3(1, 1, 1 )),\n\tnormalize(vec3(-1, 1, 1)),\n\tnormalize(vec3(1, -1, 1)),\n\tnormalize(vec3(1, 1, -1)),\n\n\tnormalize(vec3(0., 1., PHI+1.)),\n\tnormalize(vec3(0., -1., PHI+1.)),\n\tnormalize(vec3(PHI+1., 0., 1.)),\n\tnormalize(vec3(-PHI-1., 0., 1.)),\n\tnormalize(vec3(1., PHI+1., 0.)),\n\tnormalize(vec3(-1., PHI+1., 0.0)),\n\n\tnormalize(vec3(0., PHI, 1.)),\n\tnormalize(vec3(0., -PHI, 1)),\n\tnormalize(vec3(1., 0., PHI)),\n\tnormalize(vec3(-1., 0., PHI)),\n\tnormalize(vec3(PHI, 1., 0.)),\n\tnormalize(vec3(-PHI, 1., 0.))\n);\n\n// Version with variable exponent.\n// This is slow and does not produce correct distances, but allows for bulging of objects.\nfloat fGDF(vec3 p, float r, float e, int begin, int end) {\n\tfloat d = 0.0;\n\tfor (int i = begin; i <= end; ++i)\n\t\td += pow(abs(dot(p, GDFVectors[i])), e);\n\treturn pow(d, 1./e) - r;\n}\n\n// Version with without exponent, creates objects with sharp edges and flat faces\nfloat fGDF(vec3 p, float r, int begin, int end) {\n\tfloat d = 0.;\n\tfor (int i = begin; i <= end; ++i)\n\t\td = max(d, abs(dot(p, GDFVectors[i])));\n\treturn d - r;\n}\n\n// Primitives follow:\n\nfloat fOctahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 3, 6);\n}\n\nfloat fDodecahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 13, 18);\n}\n\nfloat fIcosahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 3, 12);\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 0, 6);\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r, float e) {\n\treturn fGDF(p, r, e, 3, 18);\n}\n\nfloat fOctahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 6);\n}\n\nfloat fDodecahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 13, 18);\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 12);\n}\n\nfloat fTruncatedOctahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 0, 6);\n}\n\nfloat fTruncatedIcosahedron(vec3 p, float r) {\n\treturn fGDF(p, r, 3, 18);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2.))*2. - vec2(1.);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.0) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}","name":"Common","description":"","type":"common"}]}