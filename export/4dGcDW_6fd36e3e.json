{"ver":"0.1","info":{"id":"4dGcDW","date":"1521944035","viewed":208,"name":"Polygon Infinity","username":"smiarx","description":"Yet another album cover inspired shader. This time King Gizzard's Nonagon Infinity. Ref http://nonagoninfinity.com/","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["geometry","polygon","cover"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define RADIUS 0.9\n#define COLOR vec4(0.45, 0.1, 0.1, 1.) \n\nconst float twopi = 6.283185307179586;\n\n// utility functions\nfloat rand(in float x)\n{\n    return fract(sin(x)*398442.32);\n}\n\nfloat noise(in float x)\n{\n    float i = floor(x);\n    float f = fract(x);\n    //f = f*f*(3. - 2.*f);\n    return mix(rand(i), rand(i+1.), f);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x)*2. - 1.); \n}\n\nmat2 rotmat(in float theta)\n{\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat2(c, -s, s, c);\n}\n\n// evil goat mask\n// thanks to FabriceNeyret2\n// https://www.shadertoy.com/view/lsGyWW\n#define S(v,e) smoothstep(3./iResolution.y,0.,abs(v)-(e))\nfloat goatmask( in vec2 uv )\n{\n    uv.y += 0.06;\n    uv = 1.8*uv; \n    float x = abs(uv.x), y=uv.y,z = abs(y-.2)+.05;;\n    return clamp(\n        1.\n         - S(y-x+cos(6.*x)/6.,.72*exp(-3.*x)-.02*x)\n         - S(x*x/6.+z*z*4.,.1)\n         //- S(x*x+y*y/3.,.1);   // try also without this one\n        , 0.,1.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    float val = 0.;\n    \n    // space transformation\n    uv.x += (2. * rand(uv.y+iTime*3.32) - 1.) * (4./iResolution.x);\n    vec2 uvOrig = uv;\n    uv *= rotmat(iTime * 0.3);\n     \n    // number of vertex\n    int N = 7 + 2*int((tri(iTime*0.3)) * 5.99);\n    int segpervert = N/2;\n    \n    //linewith\n    float linewidth = mix(0.005, 0.025, noise(iTime*15.));\n    \n    //rotation matrix\n    float theta = twopi / float(N);\n    mat2 rot = rotmat(theta);\n\n    float theta2 = theta * .5;\n    mat2 rot2 = rotmat(theta2);\n    \n    \n    // precompute length of segments\n    float seglength[10];\n    for(int i=0; i<segpervert; i++)\n        seglength[i] = 2.* sin(theta2 * float((i+1))) * RADIUS;\n    \n    // Polygon plotting\n    for(int i=0; i<N; i++){\n        \n        // transform space to plot lines at a given vertex\n        vec2 vertuv = uv;\n        vertuv.y -= RADIUS;\n        \n        vertuv *= rot2;\n        for(int j=0; j < segpervert; j++){ \n            \n            // distance function of horizontal line\n        \tfloat y = abs(vertuv.y);\n            // only plot corresponding segment length\n            y += smoothstep(0., -0.1, vertuv.x) + smoothstep(0., 0.1, vertuv.x-seglength[j]);\n        \t\n            // horizontal line and rotate\n       \t\tval += 1.-smoothstep(0.,linewidth,y);\n            vertuv *= rot2;\n        } \n        uv *= rot;  \n    }\n    \n    //val = clamp(val, 0., 1.);\n\n    // Output to screen\n    fragColor = COLOR*val*(1. + 2.7*(1.-goatmask(uvOrig)));\n}","name":"Image","description":"","type":"image"}]}