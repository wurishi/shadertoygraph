{"ver":"0.1","info":{"id":"XsVGRV","date":"1455389301","viewed":1230,"name":"The Butterfly Effect","username":"BigWIngs","description":"And endless plane of random butterflies. Maybe in the future I'll add a way to click on one, and turn all the others into variations of the one clicked. First time I added music. I tried to synchronize to it. Crank the music, put fullscreen and enjoy! ","likes":36,"published":1,"flags":64,"usePreview":0,"tags":["butterflies","butterfly","fouriersynthesis"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGDN","filepath":"https://soundcloud.com/cubicolor/falling-feat-tim-digby-bell-short-version","previewfilepath":"https://soundcloud.com/cubicolor/falling-feat-tim-digby-bell-short-version","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"The Butterfly Effect\" by Martijn Steinrucken aka BigWings - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n\n#define PI 3.141592653589793238\n#define TWOPI 6.283185307179586\n#define S01(x, offset, frequency) (sin((x+offset)*frequency*TWOPI)*.5+.5)\n#define S(x, offset, frequency) sin((x+offset)*frequency*TWOPI)\n#define B(x,y,z) S(x, x+fwidth(z), z)*S(y+fwidth(z), y, z)\n#define saturate(x) clamp(x,0.,1.)\nfloat dist2(vec2 P0, vec2 P1) { vec2 D=P1-P0; return dot(D,D); }\n\nfloat SHAPESHIFT=0.;\n\nfloat hash(vec2 seed) {\n\tseed *= 213234598766.2345768238784;\n    return fract(sin(seed.x)*1234765.876 + cos(seed.y)*8764238764.98787687);\n}\n\nfloat smooth90(float x, float power) {\n    // like smoothstep, only 90 degrees rotated\n\t\n    return (1.-x)*pow(x, power) + x * (1.-pow(1.-x, power));\n}\n\nvec2 hash2( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\nvec4 hash4(float seed) {\n\tvec2 n1 = hash2(vec2(seed, sin(seed*123432.2345)));\n    vec2 n2 = hash2(n1);\n    \n    return vec4(n1, n2);\n}\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( float j=-1.; j<=1.; j++ )\t\t// iterate cell neighbors\n    for( float i=-1.; i<=1.; i++ )\n    {\n        vec2  g = vec2( i, j );\t\t\t// vector holding offset to current cell\n        vec2  o = hash2( n + g );\t\t// unique random offset per cell\n      \to.y*=.1;\n        vec2  r = g - f + o;\t\t\t// current pixel pos in local coords\n\t   \n\t\tfloat d = dot( r, r );\t\t\t// squared dist from center of local coord system\n        \n        if( d<m.x )\t\t\t\t\t\t// if dist is smallest...\n            m = vec3( d, o );\t\t\t// .. save new smallest dist and offset\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nfloat skewcirc(vec2 uv, vec2 p, float size, float skew, float blur) {\n\tuv -= p;\n    \n    uv.x *= 1.+uv.y*skew;\n    \n    float c = length(uv);\n    c = smoothstep(size+blur, size-blur, c);\n    return c;\n}\n\nfloat curve(float x, vec4 offs, vec4 amp, vec4 pulse) {\n    // returns a fourier-synthesied signal followed by a band-filter\n\tx *= 3. * pulse.w;\n    \n    vec4 c = vec4(\tS(x, offs.x, 1.),\n                  \tS(x, offs.y, 2.),\n                 \tS(x, offs.z, 4.),\n                 \tS(x, offs.w, 8.));\n\n    float v = dot(c, amp*vec4(1., .5, .25, .125));\n    \n    pulse.y/=2.;\n    \n    v *= smoothstep(pulse.x-pulse.y-pulse.z, pulse.x-pulse.y, x);\n    v *= smoothstep(pulse.x+pulse.y+pulse.z, pulse.x+pulse.y, x); \n    return v;\n}\n\nvec4 Wing(vec2 st, vec2 id, float radius, vec2 center, vec4 misc, vec4 offs, vec4 amp, vec4 pattern1, vec4 global, vec4 detail) {\n\t// returns a wings shape in the lower right quadrant (.5<st.x<1)\n    // we do this by drawing a circle... (white if st.y<radius, black otherwise)\n    // ...and scaling the radius based on st.x \n    // when st.x<.5 or st.x>1 radius will be 0, inside of the interval it will be \n    // an upside down parabola with a maximum of 1\n    \n    vec2 o=vec2(0.);\n    \n    vec2 colId = hash2(id);\n    \n    colId.x *= mix( 1., floor(cos(iTime*.125)+.5)+.00015, SHAPESHIFT);\n    colId.y *= mix(1., floor(cos(iTime*.25)+.5)+.0001, SHAPESHIFT);\n    \n    // use upsidedown parabola 1-((x - center)*4)^2\n    float b = mix(center.x, center.y, st.x);\t// change the center based on the angle to further control the wings shape\n    float a = (st.x-b)*4.;\t\t\t// *4 so curve crosses 0 at .5 and 1.\n    a *= a;\n    a = 1.-a;\t\t\t\t\t\t// flip curve upside down\n    float f = max(0., a);\t\t\t// make curve 0 outside of interval\n    \n    f = pow(f, mix(.5, 3., misc.x));\n    \n    o.x = st.x;\n    \n    float r = 0.;\n    float x = st.x*2.;\n    \n    vec2 vor = voronoi(vec2(st.x, st.y*.1)*40.*detail.z);\n    \n    r = curve(x-b, offs, amp,vec4(global.x, global.y, max(.1, global.z), .333));\n\n    r = (radius + r*.1)*f;\n    \n    float edge = 0.01;//max(.001, fwidth(r))*4.;\n    \n    o.x = smoothstep(r, r-edge, st.y);\n    o.y=r;\n    \n    float t = floor(iTime*2.)*SHAPESHIFT;\n    \n    \n    vec3 edgeCol = hash4(colId.x+t).rgb;\n    vec3 mainCol = hash4(colId.y+t).rgb;\n    vec3 detailCol = cross(edgeCol, mainCol);\n    \n    vec3 col = mainCol;\n    \n    misc = pow(misc, vec4(10.));\n    \n    r -= misc.y*curve(x-b, amp, offs, vec4(offs.xw, amp.wz));\n    \n    float edgeBand =  smoothstep(r-edge*3.*misc.w, r, st.y);\n    col = mix(col, edgeCol, edgeBand);\n    r = st.y-r;\n    \n    float clockValue = curve(r*.5+.5, pattern1, offs, amp)*global.x;\n    \n    float distValue = curve(length(st-offs.yx), pattern1.wzyx, amp, global);\n    \n    col += (clockValue+pow(distValue,3.))*detail.z;\n    \n    \n    float d= distance(st, fract(st*20.*detail.x*detail.x));\n    col += st.y*st.y*smoothstep(.1, .0, d)*detail.w*5.*curve(st.x,pattern1, offs, amp);\n    \n    col *= mix(1., st.y*st.y*(1.-vor.x*vor.x)*15., detail.x*detail.w);\n    \n    return vec4(col, o.x);\n}\n\nvec4 body(vec2 uv, vec4 n) {\n\t\n    float eyes = skewcirc(uv, vec2(.005, .06), .01, 0., 0.001);\n    \n    uv.x+=.01;\n    uv.x *= 3.;\n    \n    vec2 p = vec2(-.0, 0.);\n    float size = .08;\n    float skew = 2.1;\n    float blur = .005;\n    \n    float v = skewcirc(uv, p, size, skew, blur);\n    \n    p.y -= .1;\n    uv.x *= mix(.5, 1.5, n.x);\n    v += skewcirc(uv, p, size, skew, blur);\n    \n    vec4 col = n.w*.1+ vec4(.1)* saturate(1.-uv.x*10.)*mix(.1, .6, S01(uv.y, 0., mix(20., 40., n.y)));\n    col +=.1;\n    col.a = saturate(v);\n    \n    \n    col = mix(col, n*n, eyes);\n    \n    return col;\n}\n\nfloat BlockWave(float x, float b, float c) {\n\t// expects 0<x<1\n    // returns a block wave where b is the high part and c is the transition width\n    \n    return smoothstep(b-c, b, x)*smoothstep(1., 1.-c, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    float songLength=268.3;\n    \n    float loopNum = floor(iTime/songLength);\n    float t=fract(iTime/songLength)*songLength;\n    \n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec2 uv = p;\n    \n    SHAPESHIFT = floor(fract(t/40.)+.5);\t\t// turns the overall shapeshifting on or off\n    \n    p -=.5;\t // origin to center\n    \n     float camT = PI*t/16.;\n    float camDive = 1.-(cos(camT)*.5+.5);\t\t// up and down camera motion\n    \n   \n    p =vec2(p.x*1.777, mix(p.y, smooth90(p.y+.5, .7)-.5, camDive));\t\t\t// aspect ratio fix + a barrel distortion\t\t\t\t\t\t\n\n   p*=mix(.85, 5., camDive);\n    \n    p.y += floor(p.x+.5)*.5+.05;\t\t\t\t\t// brick pattern = offset every other column\n    \n    p.y -= 8.*(camT+sin(camT+PI))/TWOPI;\t\t// stop-go camera  motion\n    \n    vec2 id = floor(p+.5);\t\t\t\t\t\t// tile-id\n    p=fract(p+.5)-.5;\t\t\t\t\t\t\t// p in tile-space\n    \n    p.x = abs(p.x);\t\t\t\t\t\t\t\t// mirror wings\n\n    float shapeShifter = floor(t/8.+.5)*floor(t/2.+.5)*SHAPESHIFT;\t\t\t// only shapeshift when zoomed in\n    shapeShifter += loopNum;\n    \n    float it = hash2(id+shapeShifter).x*10.+.25; // the only seed that will feed the entire thing\n    \n    vec4 pattern1 = hash4(it+.345);\t\t\t// get a whole bunch of random numbers \n    vec4 n1 = hash4(it);\n    vec4 n2 = hash4(it+.3);\n    vec4 n3 = hash4(n1.x);\n    vec4 global = hash4(it*12.);\n    vec4 detail = hash4(it*-12.);\n    vec4 nBody = hash4(it*.1425);\n    \n     p.x-=.01*n1.x;\t\t\t\t\t\t\t// distance between wings\n    \n    vec4 col = vec4(1.);\n\tvec4 bodyCol = body(p, nBody);\n    \n    float wingFlap = pow(S01(t+hash2(id.xy).x*20., 10., .05), 60.)*camDive; \n    \n     p.x *= mix(1.,20., wingFlap);\n    \n    vec2 st = vec2(atan(p.x, p.y), length(p));\n   st.x /= PI;\n   \n    \n    vec4 top = vec4(0.);\n    if(st.x<.6)\n    \ttop = Wing(st, id, .5, vec2(.25, .4), n1, n2, n3, pattern1, global, detail);\n    vec4 bottom = vec4(0.);\n    if(st.x>.4)\n    \tbottom = Wing(st, id, .4, vec2(.5, .75), n2, n3, n1, pattern1, global, detail); \n    \n    wingFlap = (1.-wingFlap*.9);\n    \n    vec4 wings = mix(bottom, top, top.a);\n    wings.rgb *= wingFlap;\t\t\t\t\t\t\t// darken wings when they are back-to-back\n    \n  \tcol = mix(bodyCol*bodyCol.a, wings, wings.a);\t// composite wings and body\n    \n    col *= smoothstep(0., 3., t)*smoothstep(268., 250., t);\t\t// fade in at the start\n   \n    fragColor = vec4( col );\n}\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}