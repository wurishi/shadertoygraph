{"ver":"0.1","info":{"id":"ml2yWD","date":"1691804550","viewed":33,"name":"Raymarching and LineSDF","username":"Leslie","description":"感觉自己越来越牛B了！！！","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","linesdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nRaymarching is so cool!!!\nYou can also put explicit models in implicit bounding volumes to facilitate the use of raymarching in complex model environments.\nThe best part is implicit bounding volumes can rotate along with explicit models it contains.\n*/\n\n#define MAX_STEPS 100 // Max march steps\n#define MAX_DIST 100. // Max distance\n#define MIN_SURFACE_DIST 0.001 // Min surface distance\n#define INF 1./0. // PostiveInfinit float value\n\nvec3 nrml = vec3(0.,0.,0.); // initial normal line, if not find intersection, nrml remain vec3(0., 0., 0.)\nvec3 p; // save intersection point if raymarching find intersection\nvec3 h; // save normal line if raymarching find intersection\n\n\nfloat getDist(vec3 p){ // get 3d line's SD\n    float an=iTime;\n    mat3 m = mat3(\n        cos(an), 0., -sin(an),\n        0., 1., 0.,\n        sin(an), 0., cos(an)\n        );\n    vec3 a = vec3(-7., -5., 30.);\n    vec3 b = vec3(7., -5., 30.);\n    vec3 c = (a+b)/2.;\n    a = m*(a-c)+c;\n    b = m*(b-c)+c;\n    float r = 1.;\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    float k = clamp(dot(ap, ab)/dot(ab, ab), 0., 1.);\n    h = ap-k*ab;\n\n    return length(h) -r;\n}\n\n\nfloat rayMarch(inout vec3 ro, in vec3 rd){\n    float dist = 0.;\n    float d = 0.;\n    int steps = 0;\n\n    do\n    {\n        dist += d;\n        p = ro+dist*rd;\n        d = getDist(p);\n        if(steps>MAX_STEPS || dist>MAX_DIST){return INF; } // if steped too many times or distance is too far, set return INF\n    }while(d>MIN_SURFACE_DIST);\n    nrml = normalize(h); // if find intersection, set nrml to normalize(h)\n    return dist;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = min(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord-iResolution.xy*0.5)/scale;\n    vec3 ro = vec3(0., 0., 0.);\n    vec3 rd = normalize(vec3(uv, 2.));\n    float dist = rayMarch(ro, rd);\n\n\n    vec3 lit = vec3(5., 20., 5.);\n    vec3 ld = normalize(lit-p);\n    vec3 hd = normalize(ld-rd);\n    \n    \n    float smth = smoothstep(0., 75./scale, dot(-rd, nrml));\n    float dc = max(0., dot(ld,nrml));\n    float sc = max(0., dot(hd,nrml));\n    fragColor = vec4(mix(vec3(0), vec3(0.5*dc+0.5*sc), smth),1.0);\n}\n","name":"Image","description":"","type":"image"}]}