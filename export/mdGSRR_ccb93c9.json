{"ver":"0.1","info":{"id":"mdGSRR","date":"1680725269","viewed":70,"name":"Path tracing experiment 2023","username":"jonny_townend","description":"A path tracing experiment. Currently just messing around and trying to put something together that works - even if it's super inefficient!","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["experiment","tracing","path"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float c_pi = 3.14159265359f;\nconst float c_twopi = 2.0f * c_pi;\n\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nvec3 RandomUnitVector(float state)\n{\n    float z = rand(state) * 2.0f - 1.0f;\n    float a = rand(state) * c_twopi;\n    float r = sqrt(1.0f - z * z);\n    float x = r * cos(a);\n    float y = r * sin(a);\n    return vec3(x, y, z);\n}\n\nvec3 randVec(float seed) {\n    float x = rand(seed) - 0.5;\n    float y = rand(seed + 1234.) - 0.5;\n    float z = rand(seed + 2344.) - 0.5;\n    return normalize(vec3(x, y, z));\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_ITERS 500\n#define MIN_DIST 0.001\n#define MAX_DIST 500.\n\n// Types\nstruct SurfMat {\n    float d;\n    int mat;\n};\n\n// SDFs\nfloat sSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sPlane(vec3 p) {\n    return p.y;\n}\n\nSurfMat sScene(vec3 p) {\n    float light = sSphere(p - vec3(-0.7, 0.5, 0.1), 0.1);\n    float sphere1 = sSphere(p - vec3(-0.3, 0., 1.), 0.5);\n    float sphere2 = sSphere(p - vec3(0.1, -0.3, 0.4), 0.2);\n    float plane = sPlane(p - vec3(0., -0.5, 0.));\n    float d = min(light, sphere1);\n    d = min(d, sphere2);\n    d = min(d, plane);\n    \n    if (d == light) {\n        return SurfMat(d, 0);\n    } else if (d == sphere1) {\n        return SurfMat(d, 1);\n    } else if (d == sphere2) {\n        return SurfMat(d, 2);\n    } else {\n        return SurfMat(d, 3);\n    }\n}\n\nvec3 getSurface(vec3 ro, vec3 rd) {\n    float d = 0.;\n    vec3 p = ro;\n    for(int i=0; i<MAX_ITERS; i++) {\n        p += d * rd;\n        d = sScene(p).d;\n        if (d < MIN_DIST) {\n            return p;\n        }\n    }\n    return 2. * rd * MAX_DIST;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0.01, 0.);\n    vec3 val = vec3(\n        sScene(p + e.xyy).d - sScene(p - e.xyy).d,\n        sScene(p + e.yxy).d - sScene(p - e.yxy).d,\n        sScene(p + e.yyx).d - sScene(p - e.yyx).d\n    );\n    return normalize(val);\n}\n\nint getMat(vec3 p) {\n    return sScene(p).mat;\n}\n\n// Lighting\nvec3 getCol(vec3 p) {\n    int mat = getMat(p);\n    if (mat == 0) {\n        return vec3(1.);\n    } else if (mat == 1) {\n        return vec3(0.6, 0.1, 0.1);\n    } else if (mat == 2) {\n        return vec3(0.1, 0.6, 0.1);\n    } else {\n        return vec3(0.3, 0.3, 0.3);\n    }\n}\n\nvec3 getColorForSample(vec3 ro, vec3 rd, int s) {\n    // Start firing a ray\n    vec3 p;\n    vec3 col = vec3(1.);\n    vec3 light = vec3(0.);\n    int N = 50;\n    int mat;\n    for (int i=0; i<N; i++) {\n        p = getSurface(ro, rd);\n        vec3 n = getNormal(p);\n        vec3 r = reflect(rd, n);\n        if (length(p) > MAX_DIST - 0.01) {\n            col *= texture(iChannel1, rd).xyz;\n            float emission = i == 0 ? 1. : 5.;\n            light = emission * col;\n            return light;\n        }\n        mat = getMat(p);\n        col *= getCol(p);\n        ro = p + (0.01 * n);\n        rd = randVec((1234. * length(p)) + iTime + (234. * float(s)));\n        float d = dot(rd, n);\n        rd *= d;\n        \n        // roughness\n        rd = mix(rd, r, 0.8);\n        \n        if (mat == 0) {\n            light = 50. * col;\n            return light;\n        }\n    }\n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0., 0., -1);\n    vec3 rd = normalize(vec3(uv, 0.) - ro);\n    \n    // Jitter for AA\n    vec3 jitter = 0.001 * randVec(iTime);\n    ro += jitter;\n    \n    int N = 1;\n    vec3 light = vec3(0.);\n    for (int i=0; i<N; i++) {\n        light += getColorForSample(ro, rd, i);\n    }\n    light /= float(N);\n    \n    // Blend frames\n    // taken from https://www.shadertoy.com/view/WsBBR3\n    vec4 lastFrameColor = texture(iChannel0, fragCoord/iResolution.xy);\n    float blend = (lastFrameColor.a == 0.0f) ? 1.0f : 1.0f / (1.0f + (1.0f / lastFrameColor.a));\n    light = mix(lastFrameColor.rgb, light, blend);\n\n    fragColor = vec4(light, blend);\n}","name":"Buffer A","description":"","type":"buffer"}]}