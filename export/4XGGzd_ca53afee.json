{"ver":"0.1","info":{"id":"4XGGzd","date":"1718047003","viewed":61,"name":"Dimond pattern shader","username":"Dimitar","description":"A shader inspired by the example in \"The Book of shaders\" chapter:\"patterns\". Here is the link to the original one https://thebookofshaders.com/edit.php#09/diamondtiles.frag","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["pattern","diamondpattern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\n/* The easiest way to create this diamond-like shape is to use the function y = x for its \n* linear curvature (or no curvature at all in this case). \n* So we need to find a way to first flip the curve, offset it by 'radius,' and do this\n* for every quadrant. After some testing, I found a way to represent the shape I want\n* using a single function: radius = abs(st.x) + abs(st.y). \n* How did I get here? Here are the steps I took:\n\n* 1) The function y = x is oriented in the wrong direction, so I wanted to fix that. Hence, we use y = -x\n* or x = -y (if we multiply both sides by -1).\n\n* 2) I realized that because of the symmetry of the shape, it doesn't really matter which quadrant we are\n* working with, so to make use of that, I use abs(p.x). But here is the important part:\n* instead of making the function abs(y) = abs(x), I kept the minus sign: -abs(y) = abs(x).\n* So far, this function will be true for one value that is 0, but we still need to use the radius.\n\n* 3) To offset a function to the right, it is enough to subtract the offset you want, in this case the radius,\n* from the right side of the function (or more specifically where x is). We get \n* -abs(y) = abs(x) - radius. Now, rearranging the expression: radius = abs(x) + abs(y).\n* The function tells us that it will be true for the sum of x and y that is equal to the radius.\n* At 2) -abs(y) = abs(x) the function works the same way only thing is true for only 1 value that beeing 0.\n*/\n\n//One tip that i used as a beginer to make my testings more easy I used https://www.desmos.com/calculator\n//to graph the functions. I know there are differend functions graphers but I prefer this one and it really\n//helped.\n\n\n//Updated: Using this video:'https://www.youtube.com/watch?v=h9OWnuarYuc&t=854s&ab_channel=RedBeanieMaths'\n//made it so you can now rotate it(Basicly it rotates the graph by an angle but since the graph is our\n// shape it have the effect of rotating the shape.)\n\n#define S(v) smoothstep( 3./iResolution.y, 0., v )\n#define PI 3.14159265359\n\nmat2 GetRotationMatrix(float angle)\n{\n    return mat2(cos(angle),sin(angle),\n                -sin(angle),cos(angle));\n}\nfloat drawDimondPatter(vec2 st,float OunterRadius,float InnerRadius,float angle,vec2 power)\n{\n    vec2 dimond =  pow(vec2(abs(GetRotationMatrix(angle)*st)),power);\n             \n    st =abs(st);\n    float lineThickness = .03,    \n         rotatedSquare = S( dimond.y + dimond.x - OunterRadius); \n         \n    vec2  AxieLines = S( st - lineThickness );\n    \n    return min(max(rotatedSquare,max(AxieLines.x,AxieLines.y)),\n            S( InnerRadius - dimond.y - dimond.x ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Normalizing the coordinates and making them in range [-1,1].\n    vec2 uv =  ( 2.* fragCoord - iResolution.xy ) / iResolution.y;\n   \n    //Using the fract to split the scene into more peaces and then make them again in range [-1,1].\n    uv = fract(uv*2. + iTime)*2. - 1.;\n    /*Some cool effects i found by playing with it.*/\n    \n    /*vec3 col =vec3(1)*(1. - drawDimondPatter(uv,.5,.4,iTime*2., \n    vec2(abs(sin(iTime*2.)),abs(cos(iTime*2.)))));*/\n\n\n    /*vec3 col =vec3(1)*(1. - drawDimondPatter(uv,.5,.4,0., \n    vec2(abs(sin(iTime)*2.),abs(cos(iTime))*2.)));*/\n    \n     vec3 col =vec3(1)*(1. - drawDimondPatter(uv,.5,.4,iTime, \n    vec2(abs(sin(iTime + PI/2.)*2.),abs(sin(iTime +PI/2.))*2.)));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}