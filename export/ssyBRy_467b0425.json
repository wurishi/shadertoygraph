{"ver":"0.1","info":{"id":"ssyBRy","date":"1658425688","viewed":326,"name":"Grinding Gears","username":"panna_pudi","description":"https://twitter.com/archillect/status/1528663146029891584","likes":31,"published":1,"flags":0,"usePreview":0,"tags":["3d","gears","retro","blur","reconstruction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xdf3zn","filepath":"/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","previewfilepath":"/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec4 rg = textureLod(iChannel0, (uv+0.5) / 256.0, 0.0 );\n\treturn mix(rg.yw, rg.xz, f.z);\n}\n\nHit dgear(vec3 p, float t) {\n    Hit hit = default_hit();\n    \n    float n = 8., angle = TAU / n;\n    //float spin = ceil(t) + smooth_floor(mod(t, 1.), 40.);\n    float spin = ceil(t+.5) + clamp((fract(t+.5)-.5)*10.,-.5,.5)+.5;\n    p.xy *= rot(-spin * angle + angle / 2.);\n\n    vec3 rp = p;\n    rp.xy = polar_fold(rp.xy, n);\n\n    float base_radius = 1.0, base_height = 0.23, roundness = 0.03;\n    float base = sd_cylinder(p.xzy, base_radius, base_height) - roundness;\n    base = max(base, -(abs(rp.y - 0.1) - 0.005));\n\n    float teeth = sd_box(rp - vec3(0., 1.0, 0.), vec3(0.125, base_height, 0.3)) - 0.025;\n    vec3 adjp = p;\n    adjp.xy *= rot(angle / 2.);\n    adjp.xy = polar_fold(adjp.xy, n);\n    float dimple = length(adjp.xy - vec2(0., 1.93)) - 1.;\n    teeth = smin(teeth, dimple, 0.05);\n\n    base = smax(base, -teeth, 0.02);\n    \n    float tor_r = 0.015;\n    p.z += base_height - tor_r / 2. + roundness;\n    float tor = sd_torus(p.xzy, vec2(0.65, tor_r)) - 0.01;\n    base = smax(base, -tor, 0.02);\n    tor = sd_torus(p.xzy, vec2(0.25, tor_r));\n    base = smax(base, -tor, 0.01)-0.0001;\n    \n    hit = Hit(p, base, 4.);\n    float belt = sd_torus(p.xzy, vec2(0.65, tor_r / 1.9)) - 0.01;\n    // base = smin(base, tor, 0.014);\n    //hit = _min(hit, Hit(p, belt, 2.));\n\n    return hit;\n}\n\nHit ugear(vec3 p, float t) {\n    Hit hit = default_hit();\n    \n    vec3 qq = p;\n    p.xy *= rot(t * TAU);\n    float base_radius = 1.0, base_height = 0.23, roundness = 0.03;\n    float base = sd_cylinder(p.xzy, base_radius, base_height) - roundness;\n    float width = 0.125;\n    base = min(base, sd_box(p - vec3(0., -base_radius, 0.), vec3(width, 0.15, 0.3 - 0.040)));\n    vec3 q = p;\n    float r = 0.13;\n    q.x = abs(q.x);\n    q -= vec3(r + width, -base_radius - 0.05, 0.);\n    float cut = length(q.xy) - r;\n    base = smax(base, -cut, .04);\n\n    float tor_r = 0.015;\n    p.z += base_height - tor_r / 2. + roundness;\n    float tor = sd_torus(p.xzy, vec2(0.8, tor_r)) - 0.0;\n    base = smax(base, -tor, 0.04) -  0.01;\n    \n    hit = Hit(p, base, 1.);\n    float belt = sd_torus(p.xzy, vec2(0.8, tor_r / 1.1)) - 0.0;\n    // base = smin(base, tor, 0.014);\n    //hit = _min(hit, Hit(p, belt, 2.));\n\n    return hit;\n}\n\nHit map(vec3 p, float time) {\n    Hit top = ugear(p - vec3(0., 1., 0.), time);\n    Hit bottom = dgear(p - vec3(0., -0.975, 0.), time);\n    Hit res = _min(top, bottom);\n    res = _min(res, Hit(p, -p.z, 3.));\n    return res;\n}\n\nvec3 get_norm(vec3 p, float time) {\n    mat3 k = mat3 (p, p, p) - mat3(0.001);\n    return normalize(vec3(map(p, time).dist) -\n            vec3(map(k[0], time).dist, map(k[1], time).dist, map(k[2], time).dist));\n}\n\nHit trace(vec3 ro, vec3 rd, float time) {\n    float t = 0., hit = -1.;\n    for (int i = 0; i < 150; i++) {\n        vec3 pos = ro + rd * t;\n\n        Hit d = map(pos, time);\n        if (d.dist < 0.001) return Hit(d.pos, t, d.mat_id);\n        t += d.dist;\n        if (t > 10.) break;\n    }\n    return default_hit();\n}\n\nvec3 metal_brushes(vec3 p) {\n    vec2 uv = p.xy;\n    float g = 0., l=0.;\n    const float N = 16.;\n    for (float i=0.; i < N; i++) {\n        vec2 uv = vec2(atan(uv.y, uv.x) + 1.8, length(uv) + 29.55);\n        vec2 p = uv * vec2(.06, 4.18) + \n                  i * vec2((7. + 1. / N) / 256.);\n        g += sqrt(1. / N) * (texture(iChannel0, p).x - 0.5);\n    }\n    g = exp(1.2 * g - 1.5);\n//    float v = 1.3 * g + .4 * l + 1. * g * l;\n\n    return vec3(g * 1.2);\n}\n\nvec3 metal_highlights(vec3 p) {\n    vec2 uv = p.xy;\n    float g = 0., l=0.;\n    const float N = 16.;\n    for (float i=0.; i < N; i++) {\n        vec2 uv = vec2(atan(uv.y, uv.x) + .2, length(uv) + 29.55);\n        vec2 p = vec2(0., .5) + \n             uv * vec2(.02, 0.004) + i * vec2((10. + 1. / N) / 256.);\n        l += sqrt(1. / N) * (texture(iChannel0, p).x - 0.5);\n    }\n    l = exp(1.5 * l - 1.5);\n//    float v = 1.3 * g + .4 * l + 1. * g * l;\n\n    return vec3(l);\n}\n\nvec3 render(vec3 ro, vec3 rd, float time) {\n    Hit hit = trace(ro, rd, time);\n    vec3 col = vec3(0.);\n    if (hit.dist < 10.) {\n        vec3 pos = ro + rd * hit.dist;\n        vec3 norm = get_norm(pos, time);\n        float shade = dot(norm * 0.5 + 0.5, normalize(vec3(1.)));\n        vec3 normal = erot(norm, normalize(vec3(0, -1, 1)), .96);\n        shade += 0.5*dot(max(normal, 0.), vec3(.7));\n        shade -= length(sin(norm*2.)*.5+.5)/sqrt(3.)*smoothstep(-1.,1.,norm.y);\n        \n        vec3 albedo = vec3(1.);\n        if (hit.mat_id == 2.) albedo = vec3(.5);\n        if (hit.mat_id == 3.) albedo = texture(iChannel1, hit.pos.xy).rgb;\n        \n        vec3 te = 0.5 * texture(iChannel1, hit.pos.xy * 2.0 ).rgb +\n                  0.5 * texture(iChannel1, hit.pos.yz * 1.0 ).rgb;\n        vec3 brushes = metal_brushes(hit.pos);\n        brushes *= dot(norm, normalize(vec3(0., -1., -1.))) * 0.7 + 0.3;\n        vec3 p = pos - vec3(0., 1., 0.);\n        if (hit.mat_id == 4.) p = pos + vec3(0., 1., 0.);\n        vec3 highlights = metal_highlights(p);\n        vec3 v = 1.3 * brushes + .4 * highlights + 2. * brushes * highlights;\n        te = mix(te, v, 0.85);\n\n        col = albedo * shade * te;\n    }\n    return col;\n}\n\nfloat bayer8(ivec2 uv) {   \n    uv %= 8;\n\treturn texelFetch(iChannel2, uv, 0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float gtime = iTime * 0.7;\n\n    vec3 ro = vec3(0., -0.1, -3.);\n    vec3 rd = normalize(vec3(uv, 1.5));\n    vec3 col = vec3(0.);\n\n    vec2 disp = 0.0025 * (hash12(floor(iTime * 9.)) - 0.5);\n    ro.xy += disp;\n    rd.xy += disp;\n\n    const int steps = 3;\n    for (int i = 0; i < steps; ++i) {\n        float subsample = bayer8(ivec2(fragCoord));\n        float time = gtime + \n            0.8 * ((float(i) + subsample) / float(steps) - .5) * iTimeDelta;\n        col += render(ro, rd, time);\n    }\n    col /= float(steps);\n    \n    float t = floor(iTime * 100.0);\n\tvec2 tex = mix(noise(vec3(uv * 10.0, t)).xy, uv + t, .8);\n\tfloat grains = texture(iChannel3, tex).r;\n    grains = smoothstep(.1, -.0, grains);\n\tcol *= vec3(1.0) + 0.2 * grains * grains;\n    \n    col = mix(col, vec3(0.), AAstep(0., sd_square(uv, vec2(0.45)) - 0.025));\n\n    //col = 1.2 * col / (1.0 + col);\n    col = min(col,1.0);\n    col = col*col*(3.0-2.0*col);\n    //col = pow(col, vec3(1. / 2.2));\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = acos(-1.);\nconst float TAU = 2. * PI;\n\n#define AAstep(x0, x) clamp(((x) - (x0)) / (2. * 2. / iResolution.y), 0., 1.)\n\nvec3 erot(vec3 p, vec3 ax, float a) {\n    return mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nvec2 hash12(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfloat hash31(vec3 p) {\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(262144. * n);\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat smooth_floor(float x, float c) {\n    float a = fract(x);\n    float b = floor(x);\n    return ((pow(a, c) - pow(1. - a, c)) / 2.) + b;\n}\n\nfloat sd_sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sd_box(vec3 p, vec3 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, max(p.y, p.z)));\n}\n\nfloat sd_square(vec2 p, vec2 h) {\n    p = abs(p) - h;\n    return length(max(p, 0.)) + min(0., max(p.x, p.y));\n}\n\nfloat sd_cylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nvec2 polar_fold(vec2 p, float n) {\n    n *= 0.5;\n    float a = asin(sin(atan(p.x, p.y) * n)) / n;\n    return vec2(sin(a), cos(a)) * length(p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * (1.0 / 4.0);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return max(a, b) + h * h * k * (1. / 4.);\n}\n\nfloat sd_torus (vec3 p, vec2 t) {\n    float s = length(p.xz) - t.x;\n    return length(vec2(s, p.y)) - t.y;\n}\n\nmat3 get_cam(vec3 eye, vec3 target) {\n    vec3 zaxis = normalize(target - eye);\n    vec3 xaxis = normalize(cross(vec3(0., 1., 0.), zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nstruct Hit {\n    vec3 pos;\n    float dist;\n    float mat_id;\n};\n\nHit default_hit() {\n    return Hit(vec3(0.), 1e9, -1.);\n}\n\nHit _min(Hit a, Hit b) {\n    if (a.dist < b.dist) return a;\n    return b;\n}","name":"Common","description":"","type":"common"}]}