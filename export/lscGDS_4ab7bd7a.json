{"ver":"0.1","info":{"id":"lscGDS","date":"1451965721","viewed":214,"name":"Gaussian Process","username":"davidar","description":"Fast 2D Gaussian process simulation via spectral approximation.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["2d","stochasticprocess"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// 2016 David A Roberts <https://davidar.io>\nconst float T = 15.0; // cycle length\nconst int M = 17; // number of frequencies\n\nconst float pi = 3.141592653589793;\nfloat length2(in vec2 x) { return dot(x,x); }\n\n// Smooth HSV to RGB conversion <https://www.shadertoy.com/view/MsS3Wc>\nvec3 hsv2rgb_smooth(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n    return c.z * mix(vec3(1.0), rgb, c.y); }\n\nfloat hash_uniform(in vec2 p) {\n    vec4 c = texture(iChannel0, p/256.0);\n    return c.x + c.y/256.0; }\n\nfloat hash_normal(in vec2 p) {\n    float u = hash_uniform(p), v = hash_uniform(p+u);\n    return sqrt(-2.0 * log(u)) * cos(2.0 * pi * v); }\n\nfloat normpdf(vec2 x, vec2 m, float s) {\n    return exp(-0.5*length2((x-m)/s)) / (sqrt(2.0*pi) * s); }\n\nfloat a(int m) {\n    int t = int(floor(iTime/5.0));\n    float f = fract(iTime/5.0);\n    return mix(hash_normal(vec2(m,2*t)),   hash_normal(vec2(m,2*t+2)), f*f*(3.0-2.0*f)); }\n\nfloat b(int m) {\n    int t = int(floor(iTime/5.0));\n    float f = fract(iTime/5.0);\n    return mix(hash_normal(vec2(m,2*t-1)), hash_normal(vec2(m,2*t+1)), f*f*(3.0-2.0*f)); }\n\nvoid mainImage(out vec4 r, in vec2 p) {\n    float unit = iResolution.x / (0.5*T);\n    float x = p.x / unit + 0.25*T, y = p.y / unit + 0.25*T;\n    float u =  sqrt(normpdf(vec2(0), vec2(0), T/pi)) * a(0);\n    for(int m = 1; m <= M; m++) for(int n = 1; n <= M; n++) {\n        float w = float(m) * x + float(n) * y;\n        u += 2.0 * sqrt(normpdf(vec2(m,n), vec2(0), T/pi))\n              * (a(m+M*n) * cos(pi*w/T) +\n                 b(m+M*n) * sin(pi*w/T)); }\n    u = (u + 5.0) / 10.0;\n    r = vec4(hsv2rgb_smooth(vec3(u,1.0,1.0)),1.0); }\n","name":"","description":"","type":"image"}]}