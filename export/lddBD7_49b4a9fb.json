{"ver":"0.1","info":{"id":"lddBD7","date":"1525542737","viewed":534,"name":"Tiling of 3D hyperbolic space","username":"henryseg","description":"Recreation of Vladimir Bulatov's slices through the tiling of three-dimensional hyperbolic space by regular ideal tetrahedra - see http://bulatov.org/math/180110/index_web.html#(55). Joint work with Dave Bachman.","likes":14,"published":1,"flags":0,"usePreview":0,"tags":["tiling","hyperbolic"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Recreation of Vladimir Bulatov's slices through the tiling of \n// three-dimensional hyperbolic space by regular ideal tetrahedra.\n// See http://bulatov.org/math/180110/index_web.html#(55). \n// Joint work with Dave Bachman.\n\nvec4 c2q(in vec2 a){\n    return vec4(a, 0.0, 0.0);\n}\nvec4 qonj(in vec4 q){\n    return vec4(q.x, -q.yzw);\n}\nvec4 qinv(in vec4 q){\n \treturn qonj(q) / dot(q,q);\n}\nvec4 qmul(in vec4 p, in vec4 q){\n    return vec4(p.x*q.x - p.y*q.y - p.z*q.z - p.w*q.w,\n                p.x*q.y + p.y*q.x + p.z*q.w - p.w*q.z,\n                p.x*q.z - p.y*q.w + p.z*q.x + p.w*q.y,\n                p.x*q.w + p.y*q.z - p.z*q.y + p.w*q.x);\n}\nvec4 qdiv(in vec4 p, in vec4 q){\n    return qmul(p, qinv(q));\n}\nvec4 qmob(in vec2[4] M, in vec4 z){ // see Ahlfors 1981 Mob tsfms p14\n    vec4 a = c2q(M[0]);\n    vec4 b = c2q(M[1]);\n    vec4 c = c2q(M[2]);\n    vec4 d = c2q(M[3]);\n    return qdiv( qmul(a,z)+b, qmul(c,z)+d ); // if z.w = 0 then result.w = 0\n}\n\nconst float sqrt3 = sqrt(3.0);\nconst vec2 w = vec2(0.5, 0.5*sqrt3);\nconst vec2 winv = vec2(0.5, -0.5*sqrt3);\nconst vec2 c0 = vec2(0.0,0.0);\nconst vec2 c1 = vec2(1.0,0.0);\nconst vec2 ci = vec2(0.0,1.0);\n\nbool needt1(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 1\n\treturn q.x*(-0.5*sqrt3) + q.y*0.5 > 0.0;}\nbool needt1inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 1\n    vec4 center = c2q((c1 + winv)/3.0);\n    vec4 qmc = q - center;\n    return qmc.x*qmc.x + qmc.y*qmc.y + qmc.z*qmc.z < 1.0/3.0;}\nbool needt2(in vec4 q){  // q is wrong side of face of fund domain corresponding to transformation 2\n\treturn q.x*(-0.5*sqrt3) + q.y*(-0.5) > 0.0;}\nbool needt2inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 2\n\treturn (q.x-1.0)*(0.5*sqrt3) + q.y*(0.5) > 0.0;}\nbool needt3(in vec4 q){ // q is wrong side of face of fund domain corresponding to transformation 3\n    return (q.x-1.0)*(0.5*sqrt3) + q.y*(-0.5) > 0.0; }\nbool needt3inv(in vec4 q){  // q is wrong side of face of fund domain corresponding to inv transformation 3\n    vec4 center = c2q((c1 + w)/3.0);\n\tvec4 qmc = q - center;\n    return dot(qmc.xyz, qmc.xyz) < 1.0/3.0;}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 t1[4];\n\tt1[0] = c1;\n\tt1[1] = -w;\n\tt1[2] = c1;\n\tt1[3] = winv;  // is this really the only way to assign values to the array??\n    vec2 t1inv[4];\n    t1inv[0] = winv;\n    t1inv[1] = w;\n    t1inv[2] = -c1;\n    t1inv[3] = c1;\n    vec2 t2[4];\n    t2[0] = c1;\n    t2[1] = w;\n    t2[2] = c0;\n    t2[3] = c1;\n    vec2 t2inv[4];\n    t2inv[0] = c1;\n    t2inv[1] = -w;\n    t2inv[2] = -c0;\n    t2inv[3] = c1;\n    vec2 t3[4];\n    t3[0] = -winv;\n    t3[1] = -w;\n    t3[2] = w;\n    t3[3] = -w - c1;\n    vec2 t3inv[4];\n    t3inv[0] = -w - c1;\n    t3inv[1] = w;\n    t3inv[2] = -w;\n    t3inv[3] = -winv; //all these should have det 1 now\n    \n    vec2 p = vec2(0.0,0.001) + 1.05*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n    vec4 q = vec4(p, 0.01+0.3+0.3*cos(iTime), 0.0);\n\n    bool inside_fund_dom = false;\n    for(int i=0;i<128;i++){\n        if (needt1(q)) q = qmob(t1, q);\n        else if (needt2(q)) q = qmob(t2, q);\n        else if (needt3(q)) q = qmob(t3, q);\n        else if (needt2inv(q)) q = qmob(t2inv, q);\n        else if (needt1inv(q)) q = qmob(t1inv, q);\n        else if (needt3inv(q)) q = qmob(t3inv, q);\n        else{\n            inside_fund_dom = true;\n            break;\n        }\n    }\n    vec3 col;\n    if (inside_fund_dom){\n        if (q.y > 0.0)  col = vec3(1.0,q.w,0.0);\n        else col = vec3(0.0,q.w,1.0); // q.w should always be zero, this is a sanity check\n    }\n    else col = vec3(0.0,q.w,0.0);\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}