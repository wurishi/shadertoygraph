{"ver":"0.1","info":{"id":"wtlSR7","date":"1562511893","viewed":162,"name":"perspective-whirlpools","username":"hodapp","description":"Playing around with composed functions. Starts with infinite 2D grid, makes it shift and rotate slowly, puts this all through a whirlpool, tiles the whirlpool infinitely, adds some non-uniform rotation, renders this all in perspective with some fog.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["psychedelic","perspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// (c) 2018, Chris Hodapp\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\nvec2 grid(in vec2 pt) {\n    const float t = 0.3;\n    vec2 f = fract(pt);\n    return smoothstep(0.0, t, f) - smoothstep(t, t*2.0, f);\n}\n\nvec2 rotate_2d(in vec2 pt, float ang) {\n\tfloat ca = cos(ang), sa = sin(ang);\n    return vec2(pt.x*ca - pt.y*sa,\n                pt.x*sa + pt.y*ca);\n}\n\nvec2 rotate_2d(in vec2 pt, float ang, in vec2 around) {\n\tfloat ca = cos(ang), sa = sin(ang);\n    vec2 pt2 = pt - around;\n    vec2 pt_rot = vec2(pt2.x*ca - pt2.y*sa,\n                       pt2.x*sa + pt2.y*ca);\n    return pt_rot + around;\n}\n\nvec2 rect2polar(in vec2 p) {\n    return vec2(sqrt(p.x*p.x + p.y*p.y), atan(p.y, p.x));\n}\n\nvec2 polar2rect(in vec2 p) {\n    return vec2(p.s * cos(p.t), p.s * sin(p.t));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 px = fragCoord.xy/iResolution.xy;\n    vec2 pn = vec2((px.x - 0.5) * iResolution.x/iResolution.y,\n               \t   px.y - 0.5);\n    //pn.x -= 0.7;\n    pn *= 15.0;\n    \n    vec2 st = pn; //vec2(pn.x + 0.03*pn.x*pn.x, 0.1 * pn.y * (2.0 + pn.x));\n    vec2 st2 = st; // = rotate_2d(st, angle, vec2(0.0, 0.0));\n    \n    // Perspective transform:\n    const float d = 7.8;\n    st2.x = 1.0 * st.x / max(0.0, d - st.y);\n    st2.y = d / max(0.0, d - st.y);\n    // not sure why it needs this form...\n    \n    // Non-uniform rotation:\n    float angle = sin(st2.y - iTime) * 0.1 + sin(st2.y - iTime*0.5) * 0.1;\n    vec2 st3 = rotate_2d(st2, angle/*, vec2(0.0, 0.0)*/);\n    \n    // to tile infinitely across the plane:\n    st3 = mod(st3, 1.0);\n    \n    // Whirlpool(?)\n    const vec2 p = vec2(0.5, 0.5);\n    vec2 st4 = st3 - p;\n    vec2 pol = rect2polar(st4);\n    pol.t += cos(iTime * 0.1) / (pol.s + 0.05);\n    vec2 st5 = polar2rect(pol) + p;\n\n    // Rotate, just because:\n    st5 = rotate_2d(st5, iTime*0.11);\n    // Flow a little:\n\tst5.y -= 0.51*iTime;\n\tst5.x -= 0.43*iTime;\n\n    // Finally, draw grid on the very tangled space 'underneath':\n    vec2 a = grid(st5);\n    vec3 color = vec3(a.yy, a.x);\n    \n    // Add a little fog:\n    float d2 = pow(max(0.0,st.y), 3.0);\n    color = mix(vec3(0.2, 0.2, 0.5), color, 1.0 / (d2/80.0 + 1.0));\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}