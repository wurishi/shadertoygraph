{"ver":"0.1","info":{"id":"3dsfzX","date":"1588758186","viewed":126,"name":"Metaball Effect","username":"MartinRGB","description":"Metaball,this method is inspired from Photoshop & After Effect tricks","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["metaball"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\nvec3 brightnessContrast(in vec3 value, in float brightness,in float contrast)\n{\n    value = ( value - 0.5 ) * contrast + 0.5 + brightness;\n\n    return value;\n}\n\nfloat circle(in vec2 _st, in float _radius,in vec2 offset){\n    vec2 dist = _st - offset;\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\n\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\t//if (fragCoord.x < iMouse.x)\n\t//{\n\t//\tfragColor = vec4(c, 1.0);\t\n\t//} else {\n\t\t\n\t\t//declare stuff\n\t\tconst int mSize = 51;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 7.0;\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec2 st = fragCoord.xy/iResolution.xx;\n        vec3 mColor = final_colour/(Z*Z);\n        //mColor = brightnessContrast(mColor,0.,5.5);\n    \n    \t\n        if(st.x > 0.486 && st.x < 0.5 &&(st.y<0.8*360./640. && st.y>0.2*360./640.))\n    \t{\n \t\t\t\n        \tfragColor.a = 0.;\n    \t}\n    \telse{\n        \tfragColor = vec4(mColor, 1.0);\n    \t}\n    \n    \t//fragColor = vec4(mColor, 1.0);\n    \tfragColor.rgb = brightnessContrast(fragColor.rgb,0.,10.5);\n    \t\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"float circle(in vec2 _st, in float _radius,in vec2 offset){\n    vec2 dist = _st - offset;\n\treturn 1.-smoothstep(_radius-(_radius*0.01),\n                         _radius+(_radius*0.01),\n                         dot(dist,dist)*4.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xx;\n    //st.x *= iResolution.x/iResolution.y;\n\n    bool mousePressed = iMouse.z > 0.0;\n    vec2 pos;\n    if(mousePressed)\n    {\n        pos = iMouse.xy;\n    }\n    else{\n        pos = vec2(iResolution.x*((0.33+(sin(iTime)+1.)/2.*0.33)),iResolution.y*(0.5));\n    }\n    \n\tvec3 color = vec3(circle(st,0.02,vec2(pos.x/iResolution.x,pos.y/iResolution.y*360./640.)));\n\n    //color *= vec3(1.,0.,0.);\n    //color += vec3(circle(st,0.02,vec2(0.5,0.5*360./640.)));\n    \n    if(st.x > 0.486 && st.x < 0.5 &&(st.y<0.8*360./640. && st.y>0.2*360./640.) )\n    {\n \t\tcolor = vec3(1.,1.,1.);\n        fragColor.a = 0.;\n    }\n    \n\tfragColor = vec4(color,1.);\n}","name":"Buffer A","description":"","type":"buffer"}]}