{"ver":"0.1","info":{"id":"DdGXzh","date":"1680690231","viewed":46,"name":"Spaceship crash","username":"fpotier","description":"Spaceship crash","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["space"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\nfloat sdMoon(vec2 p, float d, float ra, float rb )\n{\n    p.y = abs(p.y);\n    float a = (ra*ra - rb*rb + d*d)/(2.0*d);\n    float b = sqrt(max(ra*ra-a*a,0.0));\n    if( d*(p.x*b-p.y*a) > d*d*max(b-p.y,0.0) )\n          return length(p-vec2(a,b));\n    return max( (length(p          )-ra),\n               -(length(p-vec2(d,0))-rb));\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nvec3 randomColor(vec2 p)\n{\n    return vec3(fract(sin(dot(vec2(p.x, p.y + iTime), vec2(12.9898, 78.233))) * 43758.5453),\n                      fract(sin(dot(vec2(p.x + iTime, p.y), vec2(12.9898, 78.233))) * 43758.5453),\n                      fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453));\n}\n\nvec2 rotate(vec2 v, float a)\n{\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nconst vec3 yellow = vec3(1., 1., 0.5);\nconst vec3 black = vec3(0.);\nconst vec3 red = vec3(1., 0., 0.);\nconst vec3 planetInsideColor = vec3(0.8, 0.5, 0.2);\nconst vec3 planetOutColor = planetInsideColor * 0.4;\nconst vec3 moonColor = vec3(0.9, 0.9, 0.9);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float timeMod = mod(iTime, 8.0);\n    float t = timeMod / 8.0;\n    vec2 c = vec2(0.3, 0.5);\n    vec2 q = mod(p + 0.5 *c, c) - 0.5 * c;\n    \n    // star\n    float n = 4.0;  // n, number of sides\n    float a = 0.80; // angle factor\n    float w = 2.0 + a * a;// * (n - 2.0); // angle divisor, between 2 and n\n    \n    // moon\n    float di = 0.9 * 0.45;\n    float ra = 0.8 * 0.45;\n    float rb = 1. * 0.45;\n    \n    // sdf\n    float d = sdStar(q, 0.02, int(n), w);\n    float d2 = sdMoon(rotate(p + vec2(1.2, -0.4), -0.3 * 3. * t), di * t * 0.8, ra * t * 0.8, rb * t * 0.8);\n    float d3 = sdCircle(p, 0.002 * exp(timeMod));\n    float d4 = sdCircle(p, 0.0018 * exp(timeMod));\n    \n    // colorize\n    vec3 col = black;\n    if (d < 0.)\n        col = yellow;\n    if (d2 < 0.)\n        col = moonColor;\n    if (d3 < 0.)\n        col = planetOutColor;\n    if (d4 < 0.)\n        col = planetInsideColor;\n    \n    if (timeMod > 7. && timeMod < 8.)\n    {\n        vec3 bgColor = black;\n        vec3 waveColor = randomColor(p);\n        float amplitude = 0.05;\n        float frequency = 8.0;\n        float phase = t * frequency;\n        float offset = amplitude * sin(2.0 * 3.14159 * (p.x - phase)) + 1.;\n    \n        col = mix(bgColor, waveColor, p.y + offset);\n    }\n    \n\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}