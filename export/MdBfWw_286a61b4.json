{"ver":"0.1","info":{"id":"MdBfWw","date":"1500611947","viewed":407,"name":"Simple line segment and line","username":"etale_cohomology","description":"Fork of https://www.shadertoy.com/view/lsBSDz\n\nUse the mouse to choose the second point of the line!","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["2d","simple","math","tutorial","line","antialias","vignette","vector","aa","segment","linearalgebra","vectorspace"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Fork of https://www.shadertoy.com/view/lsBSDz\n// A very pretty line segment primitive, with vignette\n\n// This is an awesome, robust, scalable, beautiful way of adjusting thickness\n#define LINE_THICKNESS .001\n\nfloat clamp01(float value){\n    return clamp(value, .0, 1.);\n}\n\n// The vector-projection of vec_a to vec_b is always a scalar multiple of vec_b\n// (namely, a vector in the direction of vec_b, or, equivalently,\n// a vector in the 1-dimensional subspace spanned by vec_b).\n// This function computes that scalar multiple!\nfloat vector_projection_scalar(vec2 vec_a, vec2 vec_b){\n\treturn dot(vec_a, vec_b) / dot(vec_b, vec_b);\n}\n\n// To specify a line segment, we give 2 vertices vert0 and vert1 (you could also easily\n// give a vertex and a displacement vector, since we will compute that displacement vector\n// anyway, but I feel 2 vertices is more intuitive).\n// A vertex is the same as a position vector and also the same as a \"point\".\n// The difference of 2 vertices (aka. position vectors, aka. points)\n// is a displacement vector (aka. affine vector).\n// Here we try to make the distinction very explicit, since vector spaces are already\n// confusing enough, what with all the closely related (some equivalent, some not) notions of\n// vector, position vector, displacement vector, point, vertex, affine vector, co-vector,\n// dual vector, 1-form, linear functional, row vector, column vector, basis vector,\n// covariant vector, contravariant vector, pseudovector, paravector, multivector, 1-vector, 2-vector,\n// blade, 1-blade, 2-blade, tensor, (p,q)-tensor, bra-vector, ket-vector,\n// tangent vector, cotangent vector, etc.\n// For example, the cross product of 2 vectors is not a (proper) vector, but a pseudovector!\n// And the exterior product of 2 vectors is not a vector, but a 2-vector, which is Hodge-dual\n// (in 3D space) to the cross product.\n// Understanding all this jargon in necessary to gain a deep understanding of vector spaces,\n// which, I'm learning, are not so simple and innocent as one would think! They ARE sexy, though\nfloat df_segment(vec2 uv, vec2 vert0, vec2 vert1){\n    vec2 dvec_0p = uv - vert0;  // Displacement vector from vert0 to current point\n    vec2 dvec_01 = vert1 - vert0;  // Displacement vector from vert0 to vert1\n    float vproj_scalar_0p_01 = clamp01(vector_projection_scalar(dvec_0p, dvec_01));  // Without clamp, we'd get a line!\n    vec2 vproj_0p_01 = vproj_scalar_0p_01 * dvec_01;  // As promised, a scalar multiple of dvec_01\n    float dist_segment = distance(dvec_0p, vproj_0p_01) - LINE_THICKNESS;  // Distance field! This is IT!\n    return smoothstep(.0, 5. / iResolution.y, dist_segment);  // Now we just smoothen the field\n}\n\n// To specify a line, we give 2 vertices vert0 and vert1 (you could also easily\n// give a vertex and a displacement vector, since we will compute that displacement vector\n// anyway, but I feel 2 vertices is more intuitive).\nfloat df_line(vec2 uv, vec2 vec_a, vec2 vec_b){\n    vec2 dvec_ap =    uv - vec_a;  // Displacement vector from vec_a to current pixel\n    vec2 dvec_ab = vec_b - vec_a;  // Displacement vector from vec_a to vec_b\n    vec2 vproj_ap_ab = dvec_ab * vector_projection_scalar(dvec_ap, dvec_ab);  // Standard linear algebra vector projection!\n    float line = distance(dvec_ap, vproj_ap_ab) - LINE_THICKNESS;\n    return smoothstep(0., 5. / iResolution.y, line);\n}\n\n// @uv must be in the 2-box [0;1] x [0;1]\nfloat draw_vignette(vec2 uv){\n    return 0.5 + 1.5 * pow(uv.x * uv.y * (1. - uv.x) * (1. - uv.y), .3);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv0 = fragCoord / iResolution.xy;  // Map pixel coordinates to [0;1] x [0;1]\n    float vignette = draw_vignette(uv0);  // Vignette requires [0;1] coordinates\n\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;  // Map pixel y-coordinates to [-1;1]\n\n    float segment0 = df_segment(uv, vec2(.0, .0), vec2(.4, .4));\n    float segment1 = df_segment(uv, vec2(.1, .0), vec2(.5, .4));\n    float line0 = df_line(uv, vec2(-.2, .0), 2.*iMouse.xy/iResolution.xy - 1.);\n\n    float geometry = segment0;\n    geometry = min(geometry, segment1);\n    geometry = min(geometry, line0);\n\n    float rgb = geometry * vignette;\n    rgb = pow(rgb, .4);  // Gamma correction?\n\tfragColor.rgb = vec3(rgb);\n}\n","name":"Image","description":"","type":"image"}]}