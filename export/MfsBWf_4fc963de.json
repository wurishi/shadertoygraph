{"ver":"0.1","info":{"id":"MfsBWf","date":"1725304698","viewed":33,"name":"Inspect Pixel Value (debug tool)","username":"ytt","description":"This is part of a shader viewer tool I'm working on, if you're interested, you can checkout it out at https://github.com/ytt0/shaderlens","likes":6,"published":1,"flags":32,"usePreview":0,"tags":["debug"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// MIT License\n\n// A simple debug tool for inspecting buffers pixel values\n\n// How to use:\n// 1. Replace the image pass with the code below, move the image pass to a different buffer.\n// 2. Set the Channel0 binding to the previous image pass buffer (or any other intermediate buffer or texture).\n// 3. Select one of the following modes:\n\n//#define MODE 1 // Click to set origin, drag to scale.\n//#define MODE 2 // Click to scale and set origin, drag to pan.\n//#define MODE 3 // Click to scale, drag to set origin.\n\n#define MODE 1\n\n\n// Enable thumbnail preview, this can be removed\n#define ENABLE_PREVIEW\n\n\nconst float ClickScale = 100.0;\n\nconst float GridVisibleScale = 6.0;\nconst float ValueVisibleScale = 8.0;\nconst float FontScale = 2.0;\n\nconst float MaskContrastThreshold = 0.5;\n\n// 4x6 bit masks\nconst int GlyphWidth = 4;\nconst int GlyphHeight = 6;\nconst int[] DigitGlyphs = int[] (6920598, 2499111, 6885967, 6889878, 1268209, 16310678, 6875542, 15803460, 6908310, 6919958);\nconst int PointGlyph = 2;\nconst int MinusGlyph = 3840;\n\nconst int MaxCharacters = 9;\nconst int CharacterSpacing = 1;\nconst int LineWidth = MaxCharacters * (GlyphWidth + CharacterSpacing) - CharacterSpacing;\n\nconst vec2 CellPadding = vec2(2.0, 4.0);\nconst int RowSpacing = 5;\nconst int RowsCount = 4;\nconst int RowsHeight = RowsCount * (GlyphHeight + RowSpacing) - RowSpacing;\nconst float MinValueScale = 1.0 / max(float(LineWidth) + 2.0 * CellPadding.x, float(RowsHeight) + 2.0 * CellPadding.y);\n\nconst float[] Pow10 = float[] ( 0.0000000001, 0.000000001, 0.00000001, 0.0000001, 0.000001, 0.00001, 0.0001, 0.001, 0.01, 0.1, 1.0, 10.0, 100.0, 10.0 * ClickScale, 10000.0, 100000.0, 1000000.0, 10000000.0, 100000000.0, 1000000000.0, 10000000000.0 );\n\nfloat grayscale(vec3 color)\n{\n    return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nvec3 mixColorMask(vec3 color, float mask)\n{\n    return mask > 0.01 ? mix(color, vec3(step(grayscale(color), MaskContrastThreshold)), mask) : color;\n}\n\nint getGlyphMask(ivec2 pos, int glyph)\n{\n    if (pos.x >= 0 && pos.x < GlyphWidth && pos.y >= 0 && pos.y < GlyphHeight)\n    {\n        glyph >>= GlyphWidth * (GlyphHeight - 1 - pos.y) + GlyphWidth - 1 - pos.x;\n        return glyph & 1;\n    }\n\n    return 0;\n}\n\nint getGlyph(int index, float n)\n{\n    if (n < 0.0)\n    {\n        if (index == 0)\n        {\n            return MinusGlyph;\n        }\n\n        n = -n;\n        index--; // skip minus position\n    }\n\n    if (n < 1.0)\n    {\n        index++; // skip leading zero\n    }\n\n    if (n < Pow10[0])\n    {\n        return index == 1 ? PointGlyph : DigitGlyphs[0];\n    }\n\n    //int scale = max(0, int(floor(log(n) / log(10.0))));\n    int scale = 0;\n    while (scale < 10 && n >= Pow10[scale + 11])\n    {\n        scale++;\n    }\n\n    if (index == scale + 1)\n    {\n        return PointGlyph;\n    }\n\n    if (index > scale)\n    {\n        index--; // skip decimal point position\n        n = fract(n);\n    }\n\n    //int digit = int(n * pow(10.0, float(index - scale))) % 10;\n    int digit = int(n * Pow10[clamp(index - scale + 10, 0, 20)]) % 10;\n\n    return DigitGlyphs[digit];\n}\n\nint getNumberMask(ivec2 pos, float n)\n{\n    if (pos.x < 0 || pos.x >= LineWidth || pos.y < 0 || pos.y >= GlyphHeight)\n    {\n        return 0;\n    }\n\n    int index = pos.x / (GlyphWidth + CharacterSpacing);\n    pos.x -= index * (GlyphWidth + CharacterSpacing);\n\n    int glyph = getGlyph(index, n);\n\n    return getGlyphMask(pos, glyph);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n#ifdef ENABLE_PREVIEW\n    bool preview = dot(iMouse, iMouse) < 0.1;\n#else\n    bool preview = false;\n#endif\n\n    if (iMouse.z <= 0.0 && !preview)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n        return;\n    }\n\n    vec2 mouse = iMouse.xy + 0.5;\n    vec2 origin = abs(iMouse.zw) + 0.5;\n\n#ifdef ENABLE_PREVIEW\n    if (preview)\n    {\n        origin = floor(iResolution.xy * 0.5) + 0.5;\n        mouse = origin;\n        mouse.y += (iResolution.y * (iResolution.y / 1.5 - 1.0) / (10.0 * ClickScale)) * (0.5 - 0.5 * cos(iTime * 0.3));\n    }\n#endif\n\n#if MODE == 1\n    float scale = 10.0 * ClickScale * length(origin - mouse) / min(iResolution.x, iResolution.y) + 1.0;\n    vec2 offset = -origin * (scale - 1.0);\n\n    vec2 bounds = min(vec2(0.0), origin - scale / 2.0) + max(vec2(0.0), origin + scale / 2.0 - iResolution.xy);\n    offset -= bounds;\n    origin -= bounds;\n\n    float originMask = step(abs(max(abs(fragCoord.x - origin.x + 0.5), abs(fragCoord.y - origin.y + 0.5)) - 0.5 * scale), 1.5);\n#endif\n\n#if MODE == 2\n    float scale = ClickScale;\n    vec2 offset = mouse - origin * scale;\n    float originMask = 0.0f;\n    offset = clamp(offset, -(iChannelResolution[0].xy + 1.0) * scale + iResolution.xy, vec2(scale));\n#endif\n\n#if MODE == 3\n    float scale = ClickScale;\n    vec2 offset = -(mouse - 0.5) * scale;\n    origin = vec2(0.0);\n    float originMask = 0.0f;\n    offset = clamp(offset, origin - (iChannelResolution[0].xy + 1.0) * scale + iResolution.xy, origin + 1.0 * scale);\n#endif\n\n    vec2 position = (fragCoord.xy - offset) / scale;\n    if (position.x < 0.0 || position.x > iChannelResolution[0].x || position.y < 0.0 || position.y > iChannelResolution[0].y)\n    {\n        float grid = mod(floor(fragCoord.x / 15.0) + floor(fragCoord.y / 15.0), 2.0);\n        fragColor = vec4(vec3(clamp(0.2 * (1.0 + grid * 0.1), 0.0, 1.0)), 1.0);\n        return;\n    }\n\n    vec4 value = texelFetch(iChannel0, ivec2(floor(position)), 0);\n\n    float gridMask = 0.0;\n    float valueMask = 0.0;\n\n    if (scale > GridVisibleScale)\n    {\n        vec2 diff = floor(position + vec2(1.0 / scale)) - floor(position);\n\n        gridMask = min(1.0, diff.x + diff.y);\n        gridMask *= smoothstep(GridVisibleScale, 10.0 * GridVisibleScale, scale);\n    }\n\n    if (scale > ValueVisibleScale)\n    {\n        vec2 cellPosition = fract(position);\n        cellPosition.y = 1.0 - cellPosition.y;\n\n        float valueScale = max(FontScale / scale, MinValueScale);\n\n        if (cellPosition.x < 1.0 - CellPadding.x * valueScale &&\n            cellPosition.y < 1.0 - CellPadding.y * valueScale)\n        {\n            vec2 valuePosition = vec2(cellPosition / valueScale);\n\n            valuePosition -= vec2(CellPadding);\n            int valueIndex = clamp(int(floor(valuePosition.y)) / (GlyphHeight + RowSpacing), 0, 3);\n            valuePosition.y -= float(valueIndex * (GlyphHeight + RowSpacing));\n\n            valueMask = float(getNumberMask(ivec2(floor(valuePosition)), value[valueIndex]));\n            valueMask *= smoothstep(ValueVisibleScale, 10.0 * ValueVisibleScale, scale);\n        }\n    }\n\n    fragColor = vec4(mixColorMask(clamp(value.rgb, 0.0, 1.0), min(originMask + gridMask + valueMask, 1.0)), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4)+3.0);\n\n    // Mark margin\n    vec2 margin = min(fragCoord, iResolution.xy - fragCoord) - 0.5;\n    if (margin.x < 2.0 || margin.y < 2.0)\n    {\n        col += 0.4 * (2.0 - min(margin.x, margin.y));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}