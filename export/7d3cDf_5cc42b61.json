{"ver":"0.1","info":{"id":"7d3cDf","date":"1654156984","viewed":106,"name":"vhs test 4spaces","username":"route616","description":"Test exercise","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["vhs"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"precision highp float;\n\nconst float effectWidth = 0.02;             // Setup relative width.\nconst float effectPower = 0.04;             // Setup relative offset of noise.\nconst float shaderPlaybackTime = 10.0;      //\n\n// MARK: - Randomizer\n\n// A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.\nuint hash(uint x) {\n    x += (x << 10u);\n    x ^= (x >>  6u);\n    x += (x <<  3u);\n    x ^= (x >> 11u);\n    x += (x << 15u);\n    return x;\n}\n\nfloat floatConstruct(uint m) {\n    const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n    const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n\n    m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n    m |= ieeeOne;                          // Add fractional part to 1.0\n\n    float  f = uintBitsToFloat(m);         // Range [1:2]\n    return f - 1.0;                        // Range [0:1]\n}\n\nfloat random(float x) {\n    return floatConstruct(hash(floatBitsToUint(x)));\n}\n\n// MARK: - Bar\n\nfloat plot(float uvY, float width) {\n    return step(uvY, iTime / shaderPlaybackTime) * step(iTime / shaderPlaybackTime, uvY + width);\n}\n\n// MARK: - Entry point\n\n// void main(void) {\n//     vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n//     float y = plot(1.0 - uv.y, effectWidth);\n//     uv.x += (random(uv.y * y * iTime) - 0.5 * y) * effectPower;\n\n//     gl_FragColor = texture(iChannel0, uv);\n// }\n\n// For shadertoy.com\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    float y = plot(1.0 - uv.y, effectWidth);\n    uv.x += (random(uv.y * y * iTime) - 0.5 * y) * effectPower;\n\n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"}]}