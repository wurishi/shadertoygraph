{"ver":"0.1","info":{"id":"4dVcW3","date":"1523558402","viewed":81,"name":"Ray Tracer and some noise fixed","username":"Zeukkari","description":"https://www.shadertoy.com/view/lsS3RW","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fixed"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","previewfilepath":"/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct LightingData \n{\n\tvec3 L;\n\tvec3 N;\n\tvec3 H;\n    vec3 I;\n    vec3 GI;\t\n\tfloat roughness;\n};\n\t\n\t\n\nvec3 Noise(in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord / iResolution.xy*2.-1.;\n\tvec2 uv2=uv;\n\tuv2.y *= iResolution.y / 360.0;\n\tuv*=1.+pow(length(uv2*uv2*uv2*uv2),4.)*.07;\n\treturn pow(texture(iChannel3,uv2+iTime*7.25468).rgb,vec3(1.5));\n}\n\t\n\t\n\t\n//Ray are thrown from \n//d is normalized\nbool RaySphereIntersect(in vec3 rd, in vec3 sphereCenter, in float radius, out vec3 position)\n{\n\tfloat s = dot(sphereCenter, rd);\n\tfloat r2 = radius*radius;\n\tfloat l2 = dot(sphereCenter,sphereCenter);\n\tif (s<0. && l2>r2) \n\t{\n\t\treturn false;\n\t}\n\tfloat m2 = l2 - s*s;\n\tif (m2>r2)\n\t{\n\t\treturn false;\n\t}\n\t\n\tfloat q = sqrt(r2-m2);\n\tfloat t=0.;\n\tif (l2>r2)\n\t{\n\t\tt=s-q;\n\t}\n\telse\n\t{\n\t\tt=s+q;\n\t}\n\tposition=t*rd;\n\treturn true;\n}\n\nconst float PI = 3.14159265359;\nconst float INV_PI = 0.5 * 0.31830988618;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat stime = sin(1.5*iTime); \n    float ctime = cos(1.5*iTime);\n\tfloat head=iTime; float pitch= 0., roll=iTime;\n\tfloat ch=cos(head); float cp=cos(pitch); float cr=cos(roll); \n\tfloat sh=sin(head); float sp=sin(pitch); float sr=sin(roll); \n\tmat3 rot;\n\trot[0] = vec3(cr*ch-sr*sp*sh,sr*ch+cr*sp*sh,-cp*sh);\n\trot[1] = vec3(-sr*cp,cr*cp,sp);\n\trot[2] = vec3(cr*sh+sr*sp*ch,sr*sh-cr*sp*ch,cp*ch);\n\t\n\t// camera\n\tvec2 q = fragCoord / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    //I apply a rotation to the looking direction of the camera\n\tvec3 ro = rot*vec3(1.0,0.0,0.);\n\tvec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + (1.4+1.4*stime)*ww); //ray direction in world space\n\n\tvec3 sphereCenter = 10.*ww; \n\tfloat radius = 4.;\n\t\n\tvec3 finalColor = vec3(0.0,0.0,0.0); \n\tvec3 lightPosition, position;\n\tvec2 mo = iMouse.xy/iResolution.xy;\n\tmo = PI*(mo-0.5);\n\t\n\tfloat theta = PI/2.-mo.y;float stheta = sin(theta); float ctheta = cos(theta);\n\tfloat phi = mo.x;float sphi = sin(phi);float cphi = cos(phi);\n\t//spherical coordinates in direct frame (-ww,uu,vv)\n    float xl = stheta*cphi; float yl = stheta*sphi; float zl = ctheta;\n\t\n\tlightPosition = sphereCenter + 4.*radius*(-xl*ww+ yl*uu+zl*vv);\n\t\n\n\t//lightPosition = sphereCenter - 4.*radius*ww;;\n\t\n\t\n\tif (RaySphereIntersect(rd, sphereCenter,  radius, position))\n\t{\n\t\t//Rendering equation\t\t\n\t\tLightingData data;\n\t\tdata.L = normalize(vec3(lightPosition-position));\n\t\tdata.N = normalize(position-sphereCenter);\n\t\tdata.I = vec3(2000.)/pow(length(lightPosition-position),2.);\n\t\tdata.GI = (texture(iChannel1,data.N)).xyz;\n\t\tdata.roughness = 50.;\n\t\tvec3 V = normalize(-position);\n\t\tdata.H = normalize(data.L+V);\t\t\n\t\tvec3 reflected = reflect(rd,data.N);\n\t\t\n\t\tvec2 uv = vec2(asin(data.N.x)*INV_PI + 0.5,asin(data.N.y)*INV_PI+0.5); \n\t\tvec3 albedo = (texture(iChannel2, uv)).xyz;\t\n\t\tvec3 specularColor = (texture(iChannel0,reflected)).xyz;\n\t\t\n\t\tvec3 diffuseContrib = data.I*albedo*INV_PI*max(0.0,dot(data.N,data.L));\n\t\tvec3 specularContrib = data.I*specularColor*pow(max(0.0,dot(data.N,data.H)),data.roughness);\t\t\n\t\t\n\t\tfloat N2 = dot(data.N,data.N);\n\t\tvec3 GIdiffuseContrib = data.GI*albedo*INV_PI*N2;\n\t\tvec3 GIspecularContrib = data.GI*specularColor*pow(N2,data.roughness);\t\t\n\t\t\n\t\tfinalColor = diffuseContrib + specularContrib + 0.25*(GIdiffuseContrib + GIspecularContrib);\t\t\t\n\t}\n\telse\n\t{\n        finalColor=texture(iChannel0,rd).xyz;\n\t}\n\n\t\n\tvec3 britney = Noise(fragCoord); \n\tfinalColor = mix(britney, finalColor, 0.5+0.25*(1.+stime));\n\n\n\t\n\n\tfragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}]}