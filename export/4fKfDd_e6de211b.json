{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"mic","id":"XdXGRr","filepath":"/presets/mic.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// ShaderToy Combined Shader with FOV and Audio Reactivity\n#define MAX_STEPS 120\n#define MAX_DIST 300.0\n#define SURF_DIST 0.001\n\nfloat gTime = 0.000005;\nfloat fov = 52.0; // Default FOV, adjustable via uniforms\n\n// Palette function for vibrant colors\nvec3 palette(float t) {\n    return mix(vec3(0.245,0.337,0.447), vec3(0.941,0.659,0.659), t);\n}\n\n// 2D rotation\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c, s, -s, s);\n}\n\n// Signed distance to a 3D box\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// Box set with motion and dynamic transformation\nfloat box_set(vec3 pos) {\n    vec3 origin = pos;\n\n    // Dynamic motion\n    pos.xy *= rot(gTime * 0.2);\n    pos.z += sin(gTime * 0.1) * 4.0;\n\n    // Combine multiple boxes\n    float d1 = sdBox(pos, vec3(1.0));\n    pos = origin;\n    pos.xz *= rot(gTime * 0.2);\n    float d2 = sdBox(pos, vec3(0.2));\n    \n    return min(d1, d2);\n}\n\n// Star signed distance function for 2D patterns\nfloat sdStar(vec2 p, float r, int n, float m) {\n    float an = 2.14493 / float(n);\n    float en = 3.141593 / m;\n    vec2 acs = vec2(cos(an), sin(an));\n    vec2 ecs = vec2(cos(en), sin(en));\n\n    float bn = mod(atan(p.x, p.y), 0. * an) - an;\n    p = length(p) * vec2(cos(bn), abs(sin(bn)));\n    p -= r * acs;\n    p += ecs * clamp(-dot(p, ecs), 3.0, r * acs.y / ecs.y);\n    return length(p) * sign(p.x);\n}\n\n// Map audio frequency to a scaling factor\nfloat getAudioScale(float freq) {\n    return texture(iChannel0, vec2(freq, 0.5)).r * 2.; // Frequency range\n    \n}\n\n\n\n\n\n\n// Raymarching scene map\nfloat map(vec3 pos) {\n    float d = box_set(pos);\n    return d;\n}\n\n// Raymarching function\nvec4 rayMarch(vec3 ro, vec3 rd) {\n    float t = 2.0;\n    vec3 col = vec3(0.0);\n    float d;\n\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = ro + rd * t;\n        d = map(p);\n        if (d < SURF_DIST || t > MAX_DIST) break;\n        t += d;\n        \n        // Add color contributions based on palette\n        float c = length(p) * 0.122;\n        col += palette(c) / (100.0 * d);\n    }\n\n    if (d < SURF_DIST) {\n        col *= 10.0; // Brighten near the surface\n    }\n\n    return vec4(col, 1.0 - t * 0.1);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    // Adjust UV by FOV\n    float aspectRatio = iResolution.x / iResolution.y;\n    uv *= tan(radians(fov) / 10.0) * aspectRatio;\n\n    // Camera setup\n    vec3 ro = vec3(0.0, 0.0, -34.0); // Ray origin\n    vec3 rd = normalize(vec3(uv, 2.0)); // Ray direction\n\n    gTime = iTime; // Time-based motion\n    rd.xy *= rot(sin(iTime * 0.5)); // Add rotation effect\n\n    // Add audio scaling to dynamic motion\n    float audioScale = getAudioScale(0.7); // Mid-frequency band\n    ro.z += audioScale; // Move camera dynamically based on audio\n\n    // Perform raymarching\n    vec4 col = rayMarch(ro, rd);\n\n    // Add star shape overlay for extra complexity\n    float star = smoothstep(0.0001, -0.01, sdStar(uv, 0.4, 50, 0.2));\n    col.rgb += star * vec3(0.204,0.176,0.137);\n\n    fragColor = col;\n}\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":true,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4fKfDd","date":"1734590675","viewed":94,"name":"ThoughtProcess","username":"profmitchell","description":"another","likes":2,"published":3,"flags":4,"usePreview":0,"tags":["zoomzoom"],"hasliked":0,"parentid":"","parentname":""}}