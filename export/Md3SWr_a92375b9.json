{"ver":"0.1","info":{"id":"Md3SWr","date":"1467575327","viewed":199,"name":"Morphing Orb and Cube","username":"piratehurrdurr","description":"Morphing two shapes into each other.\nUploading some older shaders I made for a school assignment.\nclick to move the camera","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","example","morphingobjects"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define IT 64\n#define MAX 32.0\n#define EP 1e-3\n#define EPN 1e-3\n#define CS .xzy\n\n#define E 2.71828182845904523536028747135266249775724709369995\n#define PI 3.14159254\n\n//#define MS\n\nvec3 amb(vec3 dir, vec3 sun) {\n    vec3 c = vec3(0.3,0.54,0.75);\n    c+=vec3(0.06,0.12,0.07)*dot(dir, vec3(0.0,0.0,1.0));\n    c+=vec3(0.10,0.02,0.17)*dot(dir, vec3(0.0,1.0,0.0));\n    c+=vec3(0.04,0.05,0.03)*dot(dir, vec3(1.0,0.0,0.0));\n    return c;\n}\n\nfloat sphere(vec3 pos, float radius)\n{\n    return length(pos) - radius;\n}\n\nfloat box(vec3 pos, vec3 size)\n{\n    return length(max(abs(pos) - size, 0.0));\n}\n\n\nfloat dist(vec3 pos) {\n    return mix(sphere(pos, 0.5), box(pos, vec3(0.3)), (1.0+sin(iTime))/2.0);\n}\n\nvec3 scan(vec3 pos, vec3 dir, out float totalDistance) {\n    totalDistance=0.0;\n    for (int i=0; i<IT; i++) {\n        float rayDist = dist(pos);\n        totalDistance+=rayDist;\n        if (abs(rayDist)<EP) {\n           return pos;\n        }\n        if (totalDistance>=MAX) {\n            totalDistance = MAX;\n            return pos;\n        }\n        pos+=dir*(rayDist);\n    }\n    \n    totalDistance = MAX;\n    return pos;\n}\n\nvec3 render(vec3 pos, vec3 dir) {\n    float d;\n    vec3 sp = scan(pos, dir, d);\n    \n\tvec3 sunVector = normalize(vec3(1.0,1.0,1.0));\n    \n    if (d>=MAX) {\n        return amb(dir, sunVector);\n    }\n    \n    vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(sp + eps.yxx) - dist(sp - eps.yxx),\n    \t\tdist(sp + eps.xyx) - dist(sp - eps.xyx),\n    \t\tdist(sp + eps.xxy) - dist(sp - eps.xxy)));\n    \n    \n    \n    float sunAtten = dot(sunVector,normal);\n    if (sunAtten>0.0) {\n            } else {\n                sunAtten = 0.0;\n            }\n    \n    \n    \n        vec3 value = amb(normal, sunVector)*vec3(0.96,0.67,0.60);\n    value+= amb(reflect(dir, normal), sunVector)/4.0;\n    \n    \n    return value;\n    \n    /*\n    #ifdef AMBONLY\n            return vec3(AO(pos));\n            #endif\n            \n            if (pos.z<0.0) {\n            //return amb(reflect(dir, vec3(0.0,0.0,1.0)));\n            }\n            \n            vec2 eps = vec2(0.0, EPN);\n\t\t\tvec3 normal = normalize(vec3(\n    \t\tdist(pos + eps.yxx) - dist(pos - eps.yxx),\n    \t\tdist(pos + eps.xyx) - dist(pos - eps.xyx),\n    \t\tdist(pos + eps.xxy) - dist(pos - eps.xxy)));\n            \n            \n            \n            \n            \n            vec3 ambientColor = vec3(0.6,0.8,1.0);\n            float ambientAtten = AO(pos);\n            \n            vec3 reflDir = reflect(dir, normal);\n            sunAtten+=pow(max(dot(reflDir, sunVector),0.0),16.0)*ambientAtten;\n            \n            //return vec3(ambientAtten);\n            \n            vec4 fog = vec4(0.6, 0.8, 0.9,1.0-1.0/pow(E,totalDistance*0.05));\n            \n            vec3 light = sunColor*sunAtten + ambientColor*ambientAtten;\n            vec3 world = mix(texture(iChannel1, pos.xy/7.0).rgb,texture(iChannel1,pos.xy).rgb,0.5)*light;\n            \n            vec3 finalColor = mix(world, fog.rgb,fog.a);\n            \n            finalColor\n            \n            return finalColor ;//*texture(iChannel2, normal).rgb;\n    */\n    \n}\n\nvoid mainImage(out vec4 fragColor,in vec2 uv){\n    uv = (uv-iResolution.xy/2.0)/iResolution.y;\n    float a = iTime*0.125;\n    \n    \n\n    \n    //vec3 pos = vec3(cos(a/4.0+sin(a/2.0)),cos(a*0.2),sin(a*0.31)/4.5+1.0)*3.0;\n    \n    vec2 mouse;\n    mouse.x = iMouse.x/64.0;\n    mouse.y = iMouse.y/iResolution.y + 0.00001;\n    \n    vec3 pos = vec3(cos(mouse.x),sin(mouse.x),1.0);\n    pos*=sin(mouse.y);\n    pos.z = cos(mouse.y);\n    vec3 on = vec3(1.0,uv.x,uv.y);\n    vec3 n = pos;\n\n    //n = normalize(pos + (0.1*vec3(cos(a*2.3),cos(a*2.61),cos(a*1.62))));\n    vec3 crossRight = normalize( cross(n,vec3(0.0,0.0,1.0)));\n\tvec3 crossUp = normalize(cross(n, crossRight));\n    #ifdef MS\n    vec2 fragSize = vec2(1.0/iResolution.x, 1.0/iResolution.y)/4.0;\n    \n\tn = pos*0.5 + crossRight*(uv.x-fragSize.x) + crossUp*(uv.y-fragSize.y);\n    fragColor.rgb = render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*(uv.x+fragSize.x) + crossUp*(uv.y-fragSize.y);\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*(uv.x-fragSize.x) + crossUp*(uv.y+fragSize.y);\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*(uv.x+fragSize.x) + crossUp*(uv.y+fragSize.y);\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    n = pos*0.5 + crossRight*uv.x+ crossUp*uv.y;\n    fragColor.rgb += render(pos, -normalize(n)).rgb;\n    fragColor/=5.0;\n    \n    #else\n    n = n*0.5 + crossRight*uv.x + crossUp*uv.y;\n    fragColor.rgb = render(pos,-normalize(n)).rgb;\n    #endif\n}","name":"Image","description":"","type":"image"}]}