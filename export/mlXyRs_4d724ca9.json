{"ver":"0.1","info":{"id":"mlXyRs","date":"1708708227","viewed":115,"name":"[zznewclear13] MS IBL","username":"zznewclear13","description":"Multiple-scattering image based lighting. Computes DFG texture and SH on the fly.\nBufferA and BufferB can be pre-computed in practice.\nFurnace test mode can be enabled in Common tab.","likes":4,"published":1,"flags":32,"usePreview":0,"tags":["brdfs","ibl","furnace","multiplescattering"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// [zznewclear13] Multiple-Scattering Image-Based Lighting\n// https://www.shadertoy.com/view/mlXyRs\n// Multiple-scattering image based lighting. Computes DFG texture and SH on the fly.\n// BufferA and BufferB can be pre-computed in practice.\n// Furnace test mode can be enabled in Common tab.\n// Top: multiple-scattering; Bottom: single-scattering; Left: conductor; Right: dielectric.\n// The random walk approach should be more accurate?\n\n// Multple-Scattering References\n// A Multiple-Scattering Microfacet Model for Real-Time Image-based Lighting, Carmelo J. Fdez-Aguera\n// https://jcgt.org/published/0008/01/03/\n// https://google.github.io/filament/Filament.html#materialsystem/improvingthebrdfs\n\n// IBL References:\n// https://google.github.io/filament/Filament.html#lighting/imagebasedlights\n// https://bruop.github.io/ibl/\n\n// Post-processing.\n// Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\nvec3 Tonemap_ACES(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel2, uv).rgb;\n\n    color = Tonemap_ACES(color);\n    color = pow(color, vec3(0.4545));\n    \n    // vec3 bufferA = texture(iChannel0, uv).rgb;\n    // vec3 bufferB = texture(iChannel1, uv).rgb;\n\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Commenting/Uncommenting this line requires rewinding to reset buffers.\n// #define FURNACE_TEST\n#define FURNACE_COLOR vec3(0.5f)\n\n#define MULTIPLE_SCATTERING\n\n#define GAMMA 2.2f\n#define PI 3.14159265359\n#define INV_PI 0.31830988618\n#define SQRT2_2 0.70710678118\n\n#define DIELETRIC_REFLECTANCE 0.04\n\n/////////////////////////////////////////\n//              Structs                //\n/////////////////////////////////////////\n\nstruct SurfaceInput\n{\n    vec3 positionWS;\n    vec3 normalWS;\n    vec3 viewWS;\n    vec3 lightWS;\n    vec3 halfVec;\n    vec3 reflWS;\n    \n    float NoV;\n    float NoL;\n    float NoH;\n    float LoV;\n    float LoH;\n};\n\nstruct MaterialInput\n{\n    vec3 diffuse;\n    float alpha;\n    vec3 specular;\n    float perceptualRoughness;\n    float roughness;\n    float metallic;\n    float occlusion;\n    float f90;\n};\n\nfloat F90(vec3 f0)\n{\n\t// return clamp(dot(f0, 50.0 * 0.33), 0.0, 1.0);\n\treturn clamp(50.0 * f0.g, 0.0, 1.0);\n}\n\nSurfaceInput InitSurfaceInput(vec3 positionWS, vec3 normalWS, vec3 viewWS, vec3 lightWS)\n{\n\tSurfaceInput surfaceInput;\n\tsurfaceInput.positionWS = positionWS;\n\tsurfaceInput.normalWS = normalWS;\n\tsurfaceInput.viewWS = viewWS;\n\tsurfaceInput.lightWS = lightWS;\n    surfaceInput.halfVec = normalize(viewWS + lightWS);\n\tsurfaceInput.reflWS = reflect(-viewWS, normalWS);\n\n\t// PBR Diffuse Lighting for GGX+Smith Microsurfaces, Earl Hammon, Jr.\n\t// surfaceInput.NoV = dot(normalWS, viewWS);\n\t// surfaceInput.NoL = dot(normalWS, lightWS);\n\t// surfaceInput.LoV = dot(lightWS, viewWS);\n\t// float lenSqLV = 2.0f + 2.0f * surfaceInput.LoV;\n\t// float rcpLenLV = inversesqrt(lenSqLV);\n\t// surfaceInput.NoH = (surfaceInput.NoL + surfaceInput.NoV) * rcpLenLV;\n    // \n\t// surfaceInput.LoH = rcpLenLV + rcpLenLV * surfaceInput.LoV;\n    surfaceInput.NoV = abs(dot(normalWS, viewWS)) + 1e-5f;\n    surfaceInput.NoL = max(dot(normalWS, lightWS), 1e-5f);\n    surfaceInput.NoH = dot(normalWS, surfaceInput.halfVec);\n    surfaceInput.LoV = dot(lightWS, viewWS);\n    surfaceInput.LoH = dot(lightWS, surfaceInput.halfVec);\n\n\treturn surfaceInput;\n}\n\nMaterialInput InitMaterialInput(vec4 albedoAlpha, vec3 rmo)\n{\n\tMaterialInput materialInput;\n\tmaterialInput.perceptualRoughness = rmo.x;\n\tmaterialInput.roughness = rmo.x * rmo.x;\n\tmaterialInput.metallic = rmo.y;\n\tmaterialInput.occlusion = rmo.z;\n\n\t// https://google.github.io/filament/Filament.html#materialsystem/parameterization\n\tmaterialInput.diffuse = albedoAlpha.rgb * (1.0f - materialInput.metallic);\n\tmaterialInput.specular = mix(vec3(DIELETRIC_REFLECTANCE), albedoAlpha.rgb, materialInput.metallic);\n\tmaterialInput.f90 = F90(materialInput.specular);\n\n\tmaterialInput.alpha = albedoAlpha.a;\n\treturn materialInput;\n}\n\n/////////////////////////////////////////\n//                BRDF                 //\n/////////////////////////////////////////\n\n// Bruce Walter et al. 2007. Microfacet Models for Refraction through Rough Surfaces. Proceedings of the Eurographics Symposium on Rendering.\nfloat D_GGX(float NoH, float roughness) {\n    float a = NoH * roughness;\n    float k = roughness / (1.0 - NoH * NoH + a * a);\n    return k * k * INV_PI;\n}\n\n// Eric Heitz. 2014. Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs. Journal of Computer Graphics Techniques, 3 (2).\nfloat V_SmithGGXCorrelated(float NoV, float NoL, float roughness) {\n    float a2 = roughness * roughness;\n    float GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);\n    float GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\n// Christophe Schlick. 1994. An Inexpensive BRDF Model for Physically-Based Rendering. Computer Graphics Forum, 13 (3), 233â€“246.\nfloat F_Schlick(float LoH, float f0, float f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0, vec3 f90) {\n    return f0 + (f90 - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F_Schlick(float LoH, vec3 f0) {\n    return f0 + (vec3(1.0) - f0) * pow(1.0 - LoH, 5.0);\n}\n\nvec3 F0(vec3 baseColor, float metallic) {\n    return DIELETRIC_REFLECTANCE * (1.0 - metallic) + baseColor * metallic;\n}\n\n// GGX Specular\nvec3 Fr_GGX(float NoV, float NoL, float NoH, float LoH, float roughness, vec3 f0) {\n    float D = D_GGX(NoH, roughness);\n    vec3 F = F_Schlick(LoH, f0);\n    float V = V_SmithGGXCorrelated(NoV, NoL, roughness);\n    return D * F * V;\n}   \n\n// Lambert Diffuse\nfloat Fd_Lambert() {\n    return INV_PI;\n}\n\n// Burley Diffuse\n// Brent Burley. 2012. Physically Based Shading at Disney. Physically Based Shading in Film and Game Production, ACM SIGGRAPH 2012 Courses.\nfloat Fd_Burley(float NoV, float NoL, float LoH, float roughness) {\n    float f90 = 0.5 + 2.0 * roughness * LoH * LoH;\n    float lightScatter = F_Schlick(NoL, 1.0, f90);\n    float viewScatter = F_Schlick(NoV, 1.0, f90);\n    return lightScatter * viewScatter * INV_PI;\n}\n\n/////////////////////////////////////////\n//        Importance Sampling          //\n/////////////////////////////////////////\n\n//Random functions\nfloat seed;\nfloat GetRandom(){return fract(sin(seed++)*43758.5453123);}\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 Eval_GGX(SurfaceInput si, MaterialInput mi)\n{\n    float D = D_GGX(si.NoH, mi.roughness);\n    vec3 F = F_Schlick(si.LoH, mi.specular);\n    float V = V_SmithGGXCorrelated(si.NoV, si.NoL, mi.roughness);\n    return D * F * V;\n}\n\nfloat PDF_GGX(SurfaceInput si, MaterialInput mi)\n{\n    float D = D_GGX(si.NoH, mi.roughness);\n    return D * si.NoH / (4.0f * si.LoH);\n}\n\nvec3 SampleHemiSphereGGX(float roughness)\n{\n    float randomA = GetRandom();\n    float randomB = GetRandom();\n    \n    // Add 1e-5 to solve some mysterious bug on Metal\n    float theta = acos(sqrt((1.0 - randomA) / ((roughness * roughness - 1.0) * randomA + 1.0 + 1e-5)));\n    float phi = 2.0 * PI * randomB;\n    float sinTheta = sin(theta);\n    \n    return vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cos(theta));\n}\n\nSurfaceInput Sample_GGX(vec3 normalWS, vec3 viewWS, MaterialInput mi)\n{\n    float randomValue = GetRandom();\n    vec3 w = normalWS;\n    vec3 s, u, v;\n    s = SampleHemiSphereGGX(mi.roughness);\n    s.z = abs(s.z);\n    if(abs(dot(normalWS, vec3(0.0, 1.0, 0.0))) <= SQRT2_2)\n    {\n        u = normalize(cross(vec3(0.0, 1.0, 0.0), w));\n        v = cross(w, u);\n    }\n    else\n    {\n        v = normalize(cross(w, vec3(1.0, 0.0, 0.0)));\n        u = cross(v, w);\n    }\n    vec3 halfVec = s.x * u + s.y * v + s.z * w;\n    vec3 lightWS = reflect(-viewWS, halfVec);\n    SurfaceInput si = InitSurfaceInput(vec3(0.0f, 0.0f, 0.0f), normalWS, viewWS, lightWS);\n    return si;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Generates DFG lut.\n\n#define SAMPLE_COUNT 1.0f\n\n// Importance sampling ggx brdf\n// Fr / P * NoL\n//\n// = (Fr/F) / P * NoL * F\n//\n// = (D * G / (4.0f * NoV * NoL)) / (D * NoH / (4.0f * LoH)) * NoL * F\n//   +----------Fr/F------------+   +-----------P----------+\n//\n// = (G / (4.0f * NoV * NoL)) * (4.0f * LoH * NoL / NoH) * F\n//   +----------V-----------+\n//\n// = 4.0f * V * LoH * NoL / NoH * F\n//   +-------Eval_GGX_E-------+\nfloat Eval_GGX_E(SurfaceInput si, MaterialInput mi)\n{\n    float a2 = mi.roughness * mi.roughness;\n    float GGXL = si.NoV * sqrt((-si.NoL * a2 + si.NoL) * si.NoL + a2);\n    float GGXV = si.NoL * sqrt((-si.NoV * a2 + si.NoV) * si.NoV + a2);\n    return (2.0f * si.NoL * si.LoH / si.NoH) / (GGXV + GGXL);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0f);\n    if(iFrame == 0)\n    {\n        fragColor = color; return;\n    }\n\n    vec2 uv = fragCoord / iResolution.xy;\n    seed = hash12(fragCoord) + iTime;  \n    MaterialInput mi = InitMaterialInput(vec4(1.0f, 1.0f, 1.0f, 1.0f), vec3(uv.y, 1.0f, 1.0f));\n    vec3 normalWS = vec3(0.0f, 1.0f, 0.0f);\n    vec3 viewWS = vec3(sqrt(1.0f - uv.x * uv.x), uv.x, 0.0f);\n    \n    vec2 sum = vec2(0.0f);\n    for(float i=0.0f; i<SAMPLE_COUNT; ++i)\n    {\n        SurfaceInput si = Sample_GGX(normalWS, viewWS, mi);\n        float Gv = Eval_GGX_E(si, mi);\n        float Fc = pow(1.0f - si.LoH, 5.0f);\n        \n        // F = F0 + (F90-F0) * Fc\n        // F = F0 * (F90 - Fc) + F90 * Fc, F90 â‰ˆ 1.0f\n        sum += Gv * vec2(1.0f - Fc, Fc);\n    }\n    sum /= SAMPLE_COUNT;\n    \n    vec4 bufferA = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    bufferA.a += 1.0f;\n    color.rg = mix(bufferA.rg, sum, 1.0f / bufferA.a);\n    fragColor = vec4(color.rgb, bufferA.a);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Generates SH.\n// An Efficient Representation for Irradiance Environment Maps, Ravi Ramamoorthi, Pat Hanrahan\n// https://cseweb.ucsd.edu/~ravir/papers/envmap/envmap.pdf\n\n#define SAMPLE_COUNT 32.0f\n\nfloat Evaluate(vec3 normal, int index)\n{\n    switch(index)\n    {\n        case 0:\n            return 0.2820947917f;\n        case 1:\n            return 0.4886025119f * normal.y;\n        case 2:\n            return 0.4886025119f * normal.z;\n        case 3:\n            return 0.4886025119f * normal.x;\n        case 4:\n            return 1.0925484306f * normal.x * normal.y;\n        case 5:\n            return 1.0925484306f * normal.y * normal.z;\n        case 6:\n            return 0.3153915652f * (3.0f * normal.z * normal.z - 1.0f);\n        case 7:\n            return 1.0925484306f * normal.x * normal.z;\n        case 8:\n            return 0.5462742153f * (normal.x * normal.x - normal.y * normal.y);\n        default:\n            return 0.2820947917f;\n    }\n    return 0.0f;\n}\n\nvec3 SampleSphere(vec2 rv)\n{\n    float theta = rv.x * PI * 2.0f;\n    float u = rv.y * 2.0f - 1.0f;\n    float v = sqrt(1.0f - u * u);\n    return vec3(v * cos(theta), v * sin(theta), u);\n}\n\nvec3 sampleBackgroundLod(samplerCube channel, vec3 rd, float lod, float gamma)\n{\n#if defined(FURNACE_TEST)\n    return FURNACE_COLOR;\n#else\n    return pow(textureLod(channel, normalize(rd), lod).rgb, vec3(gamma));\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0f);\n    ivec2 iFragCoord = ivec2(fragCoord);\n    if (iFrame == 0 || any(greaterThanEqual(iFragCoord, ivec2(9, 1))))\n    {\n        fragColor = vec4(col, 0.0f);\n        return;\n    }\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    seed = hash12(fragCoord) + iTime;\n    int shIndex = iFragCoord.x % 9;\n    \n    for (float i=0.0f; i<SAMPLE_COUNT; ++i)\n    {\n        vec3 normal = normalize(SampleSphere(vec2(GetRandom(), GetRandom())));\n        float shVal = Evaluate(normal, shIndex);\n        vec3 color = sampleBackgroundLod(iChannel0, normal, 0.0f, GAMMA);\n        col += shVal * color;\n    }\n    col /= SAMPLE_COUNT;\n    col *= 4.0f; // No idea why, maybe sphere surface area / projectd hemisphere area (4pi/pi)?\n    \n    vec4 bufferB = texelFetch(iChannel1, iFragCoord, 0);\n    bufferB.a += 1.0f;\n    col = mix(bufferB.rgb, col, 1.0f / bufferB.a);\n    fragColor = vec4(col, bufferB.a);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// Calculates multiple-scattering image-based lighting.\n\nconst float tmin = 1e-3;\nconst float tmax = 1e3;\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n// Special case: sphere with radius of 1.0 at (0.0, 0.0, 0.0)\nbool raySphereIntersect(vec3 o, vec3 d, out vec3 p)\n{\n    bool hasIntersection = false;\n    float a = dot(d, d);\n    float b = dot(o, d);\n    float c = dot(o, o) - 1.0f;\n    float det = b * b - a * c;    \n    if(det < 0.0f) return false;\n    \n    float sqrtVal = sqrt(det);\n    float t1 = (-b - sqrtVal) / a;\n    float t2 = (-b + sqrtVal) / a;\n    if(t2 <= tmin) return false;\n    \n    float t = (t1 <= tmin) ? t2 : t1;  \n    if(t > tmax) return false;\n    \n    p = normalize(o + t * d);\n    return true;\n}\n\nvec3 sampleBackground(samplerCube channel, vec3 rd, float gamma)\n{\n#if defined(FURNACE_TEST)\n    return FURNACE_COLOR;\n#else\n    return pow(texture(channel, normalize(rd)).rgb, vec3(gamma));\n#endif\n}\n\nvec3 sampleBackgroundLod(samplerCube channel, vec3 rd, float lod, float gamma)\n{\n#if defined(FURNACE_TEST)\n    return FURNACE_COLOR;\n#else\n    return pow(textureLod(channel, normalize(rd), lod).rgb, vec3(gamma));\n#endif\n}\n\nvec3 CalcIrradiance(vec3 nor) { \n    float c1 = 0.429043;\n    float c2 = 0.511664;\n    float c3 = 0.743125;\n    float c4 = 0.886227;\n    float c5 = 0.247708;\n    \n    vec3 coeffs0 = texelFetch(iChannel2, ivec2(0, 0), 0).rgb;\n    vec3 coeffs1 = texelFetch(iChannel2, ivec2(1, 0), 0).rgb;\n    vec3 coeffs2 = texelFetch(iChannel2, ivec2(2, 0), 0).rgb;\n    vec3 coeffs3 = texelFetch(iChannel2, ivec2(3, 0), 0).rgb;\n    vec3 coeffs4 = texelFetch(iChannel2, ivec2(4, 0), 0).rgb;\n    vec3 coeffs5 = texelFetch(iChannel2, ivec2(5, 0), 0).rgb;\n    vec3 coeffs6 = texelFetch(iChannel2, ivec2(6, 0), 0).rgb;\n    vec3 coeffs7 = texelFetch(iChannel2, ivec2(7, 0), 0).rgb;\n    vec3 coeffs8 = texelFetch(iChannel2, ivec2(8, 0), 0).rgb;\n    \n    return (\n        c1 * coeffs8 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * coeffs6 * nor.z * nor.z +\n        c4 * coeffs0 -\n        c5 * coeffs6 +\n        2.0f * c1 * coeffs4 * nor.x * nor.y +\n        2.0f * c1 * coeffs7 * nor.x * nor.z +\n        2.0f * c1 * coeffs5 * nor.y * nor.z +\n        2.0f * c2 * coeffs3 * nor.x +\n        2.0f * c2 * coeffs1 * nor.y +\n        2.0f * c2 * coeffs2 * nor.z\n        );\n}\n\nvec3 render(vec3 ro, vec3 rd)\n{\n    vec3 p = vec3(0.0f, 1.0f, 0.0f);\n    bool hit = raySphereIntersect(ro, rd, p);\n    vec3 tBackground = sampleBackground(iChannel0, rd, GAMMA);\n    if(!hit) return tBackground;\n    \n    vec3 positionWS = p;\n    vec3 normalWS = normalize(p);\n    vec3 viewWS = -normalize(rd);\n    vec3 lightWS = normalize(vec3(0.5f, 2.0f, 0.2f));\n    SurfaceInput si = InitSurfaceInput(positionWS, normalWS, viewWS, lightWS);\n    \n    float time = abs(fract(iTime * 0.2f) - 0.5f) * 2.0f;\n    // gold\n    vec3 albedo1 = vec3(0.944f, 0.76f, 0.373f);\n    float roughness1 = mix(0.3f, 1.0f, time);\n    float metallic1 = 0.95f;\n    // plastic\n    vec3 albedo2 = vec3(0.95f, 0.3f, 0.2f);\n    float roughness2 = mix(0.7f, 0.0f, time);\n    float metallic2 = 0.0f;\n    float weightz = step(0.0f, si.positionWS.z);\n    float weighty = step(0.0f, si.positionWS.y + 0.25f);\n    \n#if defined(FURNACE_TEST)\n    vec3 albedo = vec3(1.0f, 1.0f, 1.0f);\n    // Energy loss when material is \"semi-conductor\".\n    float metallic = 1.0f - step(0.5f, weightz);\n#else\n    vec3 albedo = mix(albedo1, albedo2, vec3(weightz)); \n    float metallic = mix(metallic1, metallic2, weightz);\n#endif\n    float roughness = mix(roughness1, roughness2, weightz);\n    \n    MaterialInput mi = InitMaterialInput(vec4(albedo, 1.0f), vec3(roughness, metallic, 1.0f));\n\n    vec2 dfg = texture(iChannel1, vec2(si.NoV, mi.perceptualRoughness)).xy;\n    vec3 envDiffuse = CalcIrradiance(si.normalWS);\n    float lod = mi.perceptualRoughness * 8.0f;\n    // Should sample a prefiltered background image.\n    vec3 envSpecular = sampleBackgroundLod(iChannel0, si.reflWS, lod, GAMMA);\n    \n    vec3 envFd;\n    vec3 envFr;\n#if defined(MULTIPLE_SCATTERING)\n    // Multiple scattering image-based lighting\n    // Slightly energy loss in lambertian diffuse part.\n    if (weighty >= 0.5f)\n    {\n#if 1   \n        vec3 Fr = max(vec3(1.0f - mi.perceptualRoughness), mi.specular) - mi.specular;\n        vec3 kS = mi.specular + Fr * pow(1.0f - si.NoV, 5.0f); \n        vec3 FssEss = kS * dfg.xxx + dfg.yyy;\n        float Ess = dfg.x + dfg.y;\n        float Ems = 1.0f - Ess;\n        vec3 Favg = mi.specular + (1.0f - mi.specular) / 21.0f;\n        \n        // Not so sure...\n        vec3 Fms = FssEss * Favg / (1.0f - (1.0f - Ess) * Favg);\n        // vec3 Fms = FssEss * Favg * mi.specular / (1.0f - (1.0f - Ess) * Favg * mi.specular);\n\n        vec3 Edss = 1.0f - (FssEss + Fms * Ems);\n        vec3 kD = mi.diffuse * Edss;\n\n        envFd = (Fms * Ems + kD) * envDiffuse; \n        envFr = FssEss * envSpecular;\n#else\n        // From unreal engine (if I made it right)\n        vec3 FssEss = mi.specular * dfg.xxx + dfg.yyy;\n        float Ess = dfg.x + dfg.y;\n        vec3 energyCompensation = 1.0f + mi.specular * (1.0f / Ess - 1.0f);\n        float energyConservation = 1.0f - dot(vec3(0.299f, 0.587f, 0.114f), FssEss * energyCompensation);\n        envFd = mi.diffuse * energyConservation * envDiffuse;\n        envFr = FssEss * energyCompensation * envSpecular;\n#endif\n    }\n    else\n    {\n        vec3 FssEss = mi.specular * dfg.xxx + dfg.yyy;\n        envFd = mi.diffuse * envDiffuse * (1.0f - FssEss);\n        envFr = FssEss * envSpecular;\n    }\n#else\n    vec3 FssEss = mi.specular * dfg.xxx + dfg.yyy;\n    envFd = mi.diffuse * envDiffuse * (1.0f - FssEss);\n    envFr = FssEss * envSpecular;\n#endif\n    \n    return envFd + envFr;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 ta = vec3(0.0f);\n    float phi = PI;\n    float theta = 0.5f * PI;\n    if (iMouse.z > 0.0f)\n    {\n        phi = 2.0f * PI * (iMouse.x / iResolution.x);\n        theta = PI * (iMouse.y / iResolution.y);\n    }\n    \n    vec3 ro = 3.0f * vec3(cos(phi) * sin(theta), cos(theta), sin(phi) * sin(theta));\n    mat3 ca = setCamera(ro, ta, 0.0f);\n    \n    vec2 p = (2.0f * fragCoord - vec2(1.0f, 1.0f) * iResolution.xy) / iResolution.y;\n    float fl = 2.5f;\n    vec3 rd = ca * normalize(vec3(p, fl));\n    vec3 col = render(ro, rd);\n    \n    fragColor = vec4(col, 1.0f);\n}","name":"Buffer C","description":"","type":"buffer"}]}