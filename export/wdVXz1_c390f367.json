{"ver":"0.1","info":{"id":"wdVXz1","date":"1574495122","viewed":204,"name":"CDA_qAZ_Live04_SkyPath.glsl","username":"Cephalopodium","description":"From Antoine Zanuttini  Live Session 04 Tutorial, SkyPath like a misty Chinese bridge journey.\n","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["test","tutorial","fromyt","azlive04"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Name: CDA_AZ_Live04_SkyPath.glsl\n// Tags: Test, AZ_Live04, Tutorial, from YT\n// Desc: From Antoine Zanuttini  Live Session 04 Tutorial, \n// SkyPath like a misty Chinese bridge journey.\n// Last update 19/11/19 09:10\n// Tut time 01:20:00 of 01:22:05\n// #version 410 core (Shadertoy Throws err.. must occur 1st, except comments!  \n\n/* \nfloat rnd(vec2 uv) {\n   return fract(sin(dot(uv,vec2(127.478,36.874))) * 77894.6214 + 0.395);}\nfloat rnd(vec3 uvw) {\n   return fract(sin(dot(uvw,vec3(127.478,36.874,423.879)))*77894.6214+0.395);}\nvec2 rnd2(vec2 uv) {\n   vec2 tmp = vec2(dot(uv,vec2(127.478,36.874)),\n                   dot(uv,vec2(745.195,9413.6845)));\n   return fract(sin(tmp) *vec2(77894.6214,96843.1243)+vec2(0.395,0.745));}\nvec3 cdaCol(int a) {\n     vec3 tmp = vec3(0);\n     tmp = vec3(\n        abs(sin(cos(iTime+3.)*2.*1.+iTime)),\n        abs(cos(sin(iTime+2.)*3.*1.+iTime)),\n        abs(cos(sin(iTime+5.)*7.*1.+iTime))); // 0.5);\n     if (a==0) {\n        return tmp;\n     } else {\n        return vec3(1.-tmp.x,1.-tmp.y,1.-tmp.z);\n     }}\nfloat sph(vec3 p, float r) {\n    return length(p)-r;}\nfloat plane(vec3 p,vec3 n, float d) {\n    return dot(p,n)-d;}\nfloat vmax(vec3 p) {\n    return max(max(p.x,p.y),p.z);}\nvec3 rep(vec3 p,vec3 s) {\n    return (fract((p)/s)-0.5)*s;}\nvec3 clamp3(vec3 v,vec3 m1, vec3 m2) {\n    return vec3(clamp(v.x,m1.x,m2.x), \n                clamp(v.y,m1.y,m2.y),\n                clamp(v.z,m1.z,m2.z));}\nfloat smin(float a,float b,float c) {\n    float h = clamp(0.5+0.5*(b-a)/c,0.,1.);\n    return mix(b,a,h) - h*c*(1.-h);}\nfloat sdf(vec3 p) {\n    float s1a = sph(p + vec3(0,-1,0),2.0);\n    float s1b = sph(p + vec3(0,-2.8,2),2.4);\n    float s1c = sph(p + vec3(0,-0.1,0.6),1.8);\n    float s1 = max(-s1c,max(s1a,-s1b));\n\n    float p1 = plane(p,vec3(0,1,0),-1.0);\n    float b1 = box(p+vec3(0,.3,0),vec3(2.5,1.0,2.5)); // was ..vec3(1,0,0)...\n    vec3 mm = clamp3(p,vec3(-8,-1,-8),vec3(8,1,8));\n    float dec = 1.5;\n    float ss = 0.9;\n    float s2=sph(rep(mm-vec3(0.0,0.8,0.0),vec3(3)),ss);\n    float s3=sph(rep(mm-vec3(dec,0.8,0.0),vec3(3)),ss);\n    float s4=sph(rep(mm-vec3(0.0,0.8,dec),vec3(3)),ss);\n    float s5=sph(rep(mm-vec3(dec,0.8,dec),vec3(3)),ss);\n    float md = 0.5;    // sharpness of ground spheres, try .01\n    float smallSpheres = smin(smin(s2,s3,md),smin(s4,s5,md),md);\n\n    float m1 = smin(s1,p1,0.4);\n    float m2 = smin(m1,b1,0.4);\n    float m3 = smin(m2,smallSpheres,0.2);\n    return m3;}  */\n\nint lvl=1;\nfloat PI = acos(-1.);\n\nfloat sph(vec3 p, float r) {\n    return length(p)-r;}\n\nfloat box(vec3 p, vec3 s) {\n    vec3 ap=abs(p)-s;\n    return length(max(vec3(0.),ap))+min(0.,max(ap.x,max(ap.y,ap.z)));\n}\n\nmat2 rot(float a) {\n    float ca=cos(a);\n    float sa=sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec3 tunnel(vec3 p) {\n    vec3 off=vec3(0);\n    off.x += sin(p.z*.6)*.7;  // horizontal wiggle\n    off.x += sin(p.z*.017)*1.5;\n    off.y += cos(p.z*.27)*.5;  // vertical wiggle\n    off.y += cos(p.z*.34)*.25;\n   return off;\n}\n\nfloat stair(vec3 p,float s1,float s2) {\n    p.z = (fract(p.z/s1-0.5)-0.5)*s1; // creates infinite line of boxes\n    p.yz *= rot(PI*0.25);  // box turned on its side \n    float b = box(p,vec3(s2,s1,s1)); // was (s1) makes stair x-axis wider\n    return b;\n}\n\nfloat map(vec3 p) {\n    float rep = 10.;                    // stair-bridge repeat val\n    p.y -= max(0.,abs(p.x)-10.)*0.3;    // height of stair bridges \n    p.x = (fract(p.x/rep-0.5)-0.5)*rep; // duplicate stair bridges \n    p += tunnel(p);       // Adds horiz. & vertical wiggle to stairs \n    vec3 rp = p;\n    float tar= 0.0;\n    float at = 0.0;         // chase this light ?\n    float boxrep = 10.0;                             // stilt repeat rate \n    rp.z = (fract(rp.z/boxrep-0.5)-0.5)*boxrep;\n    vec3 rp2 = p;\n    float boxrep2 = 1.0;                             // HR stake repeat rate  \n    rp2.x = abs(rp2.x)-0.4;                          // doubles handrail fence\n    rp2.z = (fract(rp2.z/boxrep2-0.5)-0.5)*boxrep2;\n/*\n    vec3 rp3 = p;\n    float boxrep3 = 2.0;                             // HR stake hole repeat rate \n    rp3.x = abs(rp3.x)-0.4;                          // @doubles stake hole\n    rp3.z = ((fract(rp3.z/boxrep3-0.5)-0.5)*boxrep3);    // -1. offsets stake holes to avoid stilts\n*/\n    float b = box(rp+vec3(0.,-9.,0.),vec3(.6,10.5,.6)); // box like stilt, boxsize\n    vec3 rp3=rp+vec3(0.,1.5,0.);          // define stilt roof\n    rp3.xy*=rot(PI*.3); // *iTime);  // turn it round z axis\n    rp3.yz*=rot(PI*.3); // *iTime);  // turn it round x axis \n//    rp3.xz*=rot(PI*.3); // *iTime);  // CDA turn it round y axis \n    float b2 = box(rp3,vec3(0.7));    // .7 roof size\n    b2 = max(b2,p.y+1.5);             // 1.5 cutoff for bottom of roof\n    b  = min(b,b2);                   // add it to stilt\n\n    float st = stair(p,0.1,0.4);                     // was box(p,vec3(0.5))\n    float st2 = stair(p + vec3(0.,.7,0.),0.6,0.4);   // stilt hole, ceil & floor\n    b = max(b, -st2);      // removes hole from stilt\n\n    float c=box(rp2+vec3(-.05,.3,0),vec3(.05,.3,.2)); // HR stake,path pos., boxsize \n          // CDA fix - prevents showing HRs in \"caves\" path x-offset=-.05\n    rp2.y = abs(rp2.y+0.43)-0.1;       // doubles HR, rail height & separation\n    rp2.x = abs(rp2.x-0.05);           // CDA fix offset into HR \"stake\"\n\n    c = min(c,box(rp2,vec3(.01,.01,1.))); // HR height,HR dim.Was +v3(0,.5,0),was .03\n/* \n    float e = sph(rp3+vec3(-.05,.3,0.),.2);  // define stake holes \n //   rp3.x = abs(rp3.x-0.)+.0;                 // CDA fix offset into HR \"stake\"\n    e = max(st2,sph(rp3+vec3(-.05,.3,0.),.13));       // removes hole from stake\n    c = min(c, e)*1.01; //                            // combines hole with handrails\n*/\n//    return(max(c,e)); // min(st,min(c,b)));  \n    return min(c,min(b,st));      // Combines handrails, with stilt with stair \n    // length(p)-0.5;  // AZ debug\n}\n\nvec3 norm(vec3 p) {\n   vec2 off = vec2(0.01,0.0);\n   return normalize(map(p)-vec3(map(p-off.xyy), \n                    map(p-off.yxy),\n                    map(p-off.yyx)));\n}\n \nfloat rnd(vec2 uv) {\n   return fract(sin(dot(uv,vec2(127.478,36.874))) * 77894.6214 + 0.395);\n}\n\nfloat rnd(float t) {\n   return fract(sin(t*435.232)*7412.223);\n}\n\nfloat curve(float t,float d) {\n   float g=t/d;\n   return mix(rnd(floor(g)),rnd(floor(g)+1.),pow(smoothstep(0.,1.,fract(g)),10.));\n}\n\nfloat curve2(float t,float d) {\n   float g=t/d;\n   float ig= floor(g);\n   float fg= fract(g);\n   fg = pow(fg,rnd(ig)*2.+.5);\n   fg = smoothstep(0.,1.,fg);\n   return (ig+fg)*d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = vec2(fragCoord.x/ iResolution.x, \n                   fragCoord.y/ iResolution.y);     // AZ\n    uv -= 0.5;                                      // AZ\n    uv /= vec2(iResolution.y / iResolution.x,1);    // AZ \n    float rand=rnd(uv);\n    float dither = 0.8+0.1*rand;\n\n    vec3 s = vec3(0.,-1,0); // was vec3(0.,-1.+sin(iTime)-1.,-3.); \n                            // Skews stair angle,was (0,0,-3)\n                                // +sin(iTime) rotates stairs around y axis \n    vec3 t = vec3(0,-0.3,3);    // was vec3(0), -.3 lowers horizon\n    vec3 tar = vec3(0,-0.7,3);    // was vec3(0), -.7 raises Follow Light\n// @\n    int cda = 0;                 // var to control CDA mode when >0\n    float ttt = iTime;\n\n    bool done=false;\n    float tSplit = 30.0;        // number of seconds to split\n    // display split 50/50 by time\n    if (ttt/tSplit-float(int(ttt/tSplit))>.5) {\n //   if (int(ttt/tSplit*2.0)%2==0) {\n        if (!done) {\n      //    cda=int(rnd(ttt)*6.);\n       //   cda++;\n          cda=(cda%6)+1;\n        }    \n        done=true;   \n    } \n    // @\n    float motion = 0.0;\n    if (cda!=0) {\n       ttt*=0.42;      // CDA slow it down\n//       motion=ttt;     // CDA disable seasickness from adding curve above  \n    }\n    motion=curve2(ttt*1.5,0.8)*3.0; // slides viewpoint back & forth on path\n    \n    s.z += motion;            // moves camera\n    t.z += motion;\n    float offset= 15.0;\n    tar.z += (curve2(ttt*1.5-offset, 1.1)+offset)*3.0+pow(curve(ttt,.9),3.)*5.;\n  //  tar.z += ttt *1.5*3.0; // +pow(curve(ttt,.7),2.)*5.;\n  //  tar.z += ttt + pow(curve(ttt,.7),2.)*5.; // slides FL back and forth on path\n\n    s-=tunnel(s);             // camera follows along stair path \n    vec3 offt=tunnel(t);      // \n    t-=offt;\n    tar-=tunnel(tar); \n    if (cda!=0) {\n       if (cda>=4) {  \n          s.yz *= rot(ttt*0.25);     // s.yz=dolphin t*=.2\n       } else {\n         if (cda>=3) {       \n            s.xy *= rot(ttt*0.0125); // s.xy=petFly  t*=.0125\n         } else {\n           if (cda>=2) { \n              s.xz *= rot(ttt*0.5);  // Spins on y axis, s.xz=Copter t*=.5\n           }\n         }\n       }  \n    }\n    vec3 cz=normalize(t-s);\n    vec3 cx=normalize(cross(cz,vec3(0,1,0)-offt*0.2));\n    vec3 cy=normalize(cross(cz,cx));\n    vec3 r=normalize(cx*uv.x+cy*uv.y + cz*(.7+sin(ttt*2.)*.4));  \n    // normalize(-uv,.8); .8=zoom  , cz(sin()) gives FOV Distortions\n    vec3 col = vec3(0);\n    vec3 back = vec3(0);\n    vec3 back2 = vec3(0);\n\n    vec3 ln = normalize(vec3(-.7,-1.,-0.5)); //s y-spin only sways, was v3(-1)\n    if (cda==0) {   \n       back = mix(vec3(.1,.3,1.)*.1,vec3(1.,.3,.5)*.5, \n                    pow(r.y*.5+.5,2.)); // Controls Blue to Maroon \n    } else {\n//     back2 = mix(vec3(.1,.3,1.)*.1,vec3(1.,.3,.5)*.5, \n//                     1.-pow(r.y*.5+.5,2.)); // for at2 but unused \n//     back = mix(vec3(.5,.5,.5)*.1,vec3(1.,.5,.4)*.5, \n//                      pow(r.y*.5+.5,1.9)); // CDA Controls Grey to Orange \n       back = mix(vec3(1.-cos(ttt/3.),.65,.5)*.1,vec3(0.4,.5,sin(ttt/5.))*.5, \n                      pow(r.y*.5+.5,2.)); // CDA Time varying colour controls\n    }\n    vec3 p=s;\n    float dd = 0.;\n    int i=0;\n    float at = 0.0;         // chase this light ?\n    float at2 =0.0; \n\n    for (i=0;i<100;++i) {\n        float d = map(p)*0.9; // .9 const controls details\n        if (d<0.001) {\n           vec3 n = norm(p);\n   //        dd = length(p-s);\n           float fog = clamp(10.-dd*.018,0.,1.);  // .018 is fog strength\n           float bot = pow(clamp(-(p.y-10.)*.1,0.,1.),2.)*fog;\n//           fog *= clamp(-p.y+10.,0.,1.);\n           float aodist=.3;                   // ambient occlusion distance\n           float ao=clamp(map(p+n*aodist)/aodist,0.,1.); // ambient occlusion value\n           ao=mix(ao,1.0,0.3);\n           float f = pow(1.-dot(n,-r),2.);\n           col += vec3(.3,.4,.7)*max(0.,dot(n,ln))*bot*ao; // abs(n)*.5; AZ debug RGB\n           col += 4.*f*back*2.*(-n.y*.5+.5)*bot*ao; // blue Light, back was v3(.5,.6,1.)\n//           col += mix(col,vec3(.1,.3,1.),bot); // *0.05*exp(dd*0.04);\n           dd = mix(100.,d,bot);\n           break;\n        }\n        if (dd>100.) { \n           dd= 100.;\n           break;\n        }\n        p  += d*r;\n        dd += d;\n        if (cda==0) {\n            at+=exp(-length(tar-p)*7.);  // 7. Follow Light brightness, higher is dimmer\n            at2+=exp(-d*.1)*.05;         // \n        } else {\n            at+=exp(-length(tar-p)*6.);  // 7. Follow Light brightness, higher is dimmer\n            at2+=exp(-d*.05)*.075;          // brighter\n        }\n    }\n    if (i>99) dd=100.;\n    if (cda==0) {\n      col += vec3(1.,.3,.5) * at * 3.3;     // Follow Light colour fringe, 3.3 is  size\n      col += vec3(1.,.3,.5) * at2 * 0.2;\n      col += back*0.05*exp(dd*0.05); // ++blue thru fog, exp(dd*light[0..1]) , \n                                         // back was vec3(.1,.3,1.)\n    } else {\n      col += vec3(1.,.93,.5) * at * 3.3;     // Follow Light colour fringe, 3.3 is  size\n      col += vec3(1.,.3,.5) * at2 * 0.2;\n      col += back*0.025*exp(dd*0.04635); // ++blue thru fog, exp(dd*light[0..1]) , \n                                         // back was vec3(.1,.3,1.)\n    }\n    /*\n    if (int(ttt)>10) { \n       if (lvl%5==0) {\n           lvl=0;           \n       } else {\n           lvl++;\n       } \n       cda+=1; // lvl%5;\n//       col=vec3(float(lvl)/5.); // vec3(lvl,cda,int(iTime)%15);\n    } */\n    // Output to screen\n\n    fragColor = vec4(col,1.0); \n}\n","name":"Image","description":"","type":"image"}]}