{"ver":"0.1","info":{"id":"fsffDl","date":"1645535901","viewed":279,"name":"Patched Fibonacci sphere mapping","username":"stegu","description":"Modified version of the inverse Fibonacci sphere mapping by Keinert et al (2015). Returns at least three correct nearest neighbors close to all edges -- four where two 3-junctions are close. Useful for sparse convolution and advanced Voronoi patterns.","likes":17,"published":1,"flags":0,"usePreview":0,"tags":["sphere","barycentric","inverse","fibonacci","chamfer"],"hasliked":0,"parentid":"fsSyD3","parentname":"Iris on eyeball (sketch)"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float sphere_size = 1.0; // Unit sphere\n    // The number of facets can be anything from 8 to around 2e6 (!),\n    // but for very large N the facets won't be noticeable.\n    const float FibonacciN = 43.0;\n\n    const vec3 bgcolor = vec3(0.1, 0.2, 0.1);\n    const vec3 spherecolor = vec3(1.0, 0.5, 0.0);\n    const vec3 dotcolor = vec3(0.7,0.7,0.5);\n\n    // Default view: fit unit circle in viewport\n    vec3 uvw;\n    uvw.xy = (2.0*fragCoord- iResolution.xy)/min(iResolution.x, iResolution.y);\n\n    // Adjust scale by mouse drags (down-drag zooms out, up-drag zooms in)\n    float zoom = 1.1*pow(0.98,iMouse.y-abs(iMouse.w));\n    uvw.xy = zoom*uvw.xy;\n    // uvw is scaled but not rotated\n    float sphere_mask = 1.0 - aastep(sphere_size, length(uvw.xy));\n    // Early exit outside object - big saving in distant views\n    if(sphere_mask == 0.0) {\n        fragColor = vec4(bgcolor, 1.0);\n        return;\n    }\n\n    // Fake sphere z in unit circle\n    uvw.z = sqrt(max(0.0, sphere_size*sphere_size-dot(uvw.xy,uvw.xy)));\n\n    // Spin vertically (rotate only the texcoords)\n    float el = 3.5*sin(iTime*0.1*sqrt(3.0));\n    float Se = sin(el);\n    float Ce = cos(el);\n    // Spin horizontally\n    float az = 7.0*sin(iTime*0.1*sqrt(2.0));\n    float Sa = sin(az);\n    float Ca = cos(az);\n    mat3 R = mat3(1.0,0.0,0.0, 0.0,Ce,-Se, 0.0,Se,Ce);\n    R *= mat3(Ca,0.0,Sa, 0.0,1.0,0.0, -Sa,0.0,Ca);\n    mat3 Ri = transpose(R); // orthonormal, hence inverse = tranpose\n\n    vec3 v = normalize(R*uvw); // Rescale coords to unit sphere\n\n\t// These feature sizes scale with N\n\tfloat edgewidth = 0.5/sqrt(FibonacciN); // Linear distances here\n\tfloat spotsize = 0.3/sqrt(FibonacciN); // Remember to use sqrt(d.x)\n\n\t// Find the three closest N-fib-sphere points to v\n    vec4 d;\n    vec4 p0, p1, p2, p3;\n\tinverseSF(v, FibonacciN, p0, p1, p2, p3, d);\n    patchpoles(v, FibonacciN, p0, p1, p2, p3, d);\n    sortp0p1(p0, p1, p2, p3, d);\n    float d0 = length(v-p0.xyz); // <-- Worley would call this \"F1\"\n\tfloat d1 = length(v-p1.xyz); // These are \"F2\" to \"F4\",\n\tfloat d2 = length(v-p2.xyz); // but we don't know which is\n    float d3 = length(v-p3.xyz); // which (p1 to p3 are not sorted)\n\n#define AA\n// If your auto-derivatives dFdx() and dFdy() are wonky, #undef AA\n#ifdef AA\n\tfloat dots = 1.0-aastep(spotsize, sqrt(d.x));\n#else\n\tfloat dots = 1.0-step(spotsize, sqrt(d.x)); // AA disabled\n#endif\n\n    // Barycentric coordinates for chamfered normals\n\tfloat b0 = smoothstep(-edgewidth, edgewidth, (d1-d0));\n\tfloat b1 = smoothstep(-edgewidth, edgewidth, (d0-d1));\n\tfloat b2 = smoothstep(-edgewidth, edgewidth, (d0-d2));\n\tfloat b3 = smoothstep(-edgewidth, edgewidth, (d0-d3));\n    // In most cases, b2 or b3 has no influence, but we don't\n    // know which one. Let's be lazy and include both.\n\t// Note that we renormalize, so we don't need \"/bn\"\n\t// float bn = b0 + b1 + b2 + b3;\n\tvec3 facetN = normalize(p0.xyz*b0 + p1.xyz*b1\n        + p2.xyz*b2 + p3.xyz*b3); // \"Chamfered facets\"\n\n    // Simple lighting\n\tfacetN = Ri*facetN;\n\tvec3 Lpos = vec3(3.0); // Local light source\n\tvec3 L = normalize(Lpos-Ri*v);\n\tfloat kd = 0.2 + 0.5*max(dot(L, facetN), 0.0);\n\tfloat ks = (1.0-step(kd,0.2))*pow(max(reflect(-L, facetN).z, 0.0),15.0);\n\tvec3 white = vec3(1.0);\n\tvec3 mixcolor = kd*spherecolor + ks*white;\n\tmixcolor = mix(mixcolor, dotcolor, dots);\n#ifdef AA\n    mixcolor = mix(bgcolor, mixcolor, sphere_mask); // AA of the outline\n#endif\n\n    fragColor = vec4(mixcolor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// A convenient anti-aliased step() using auto derivatives\nfloat aastep(float threshold, float value) {\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n}\n\n#if 0\n#define m1 0.618033988749895\nfloat fracmodphi(float k) {\n\t// (Pray that this maps to an FMA instruction)\n\treturn k * m1 - floor(k * m1);\n}\n#else\nfloat fracmodphi(float k) {\n    // Thanks to @mla for this more predictable version,\n    // invoking the angelic powers of integer arithmetic.\n    // 1) Realize that fract(n*p/q) = ((n*p)%q)/q = (((n%q)*p)%q)/q\n    // 2) Use F23/F24 as a rational approximation of (sqrt(5)-1)/2\n    uint p = 28657u, q = 46368u;\n    uint n = uint(k);\n    return float(n%q*p%q)/float(q);\n}\n#endif\n\n#define PI 3.141592653589793\n#define PHI 1.618033988749895\n\n// Compute point k on N-point fibsphere (helper for other functions)\n//\nvec3 evalSFpoint(float k, float N) {\n\tfloat phi = 2.0*PI*fracmodphi(k);\n\tfloat cosTheta = 1.0 - (2.0*k + 1.0)*(1.0/N);\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\treturn vec3(cos(phi)*sinTheta, sin(phi)*sinTheta,cosTheta);\n}\n\n// Compute neighbors in the local Cartesian map, and their distances.\nfloat evalNearest(float N, vec2 B, vec2 i, vec2 c, vec3 v, out vec4 p) {\n    float cosTheta = dot(B, i + c) + (1.0-1.0/N);\n    // The expression below is a hardware-friendly way (?) of saying\n    // \"if(abs(cosTheta)>1.0) cosTheta = 1.0-abs(cosTheta);\"\n\tcosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n\tp.w = floor(N*0.5 - cosTheta*N*0.5);\n\tp.xyz = evalSFpoint(p.w, N);\n\treturn dot(v-p.xyz, v-p.xyz);\n}\n\n//\n// Find the 3-4 nearest neighbors on an N-point Fibonacci sphere.\n// Evolved version of an algorithm from the article \"Spherical\n// Fibonacci Mapping\" by Keinert et al, ACM Trans. on Graphics\n// 34 (2015), 6, 193.\n//\n// Return four neighbors, with points, indices and distances.\n// p0.xyz is the location of neighbor 0, p0.w is its index.\n// Similarly for p1, p2, p3.\n// d contains the squared distances from v to each of the neighbors\n// in the order p0, p1, p2, p3.\n// p0 is the closest point. The other three are not sorted, and\n// there are errors and duplicates, most notably around the poles.\n// See the function patchpoles() below for a remedy.\n//\n// This function is Copyright 2022 by Stefan Gustavson.\n// It is released under the terms of the MIT license:\n// https://opensource.org/licenses/MIT\n// (\"Use freely for any purpose, but keep the attribution\")\n//\nvoid inverseSF(vec3 v, float N, out vec4 p0, out vec4 p1,\n                   out vec4 p2, out vec4 p3, out vec4 d) {\n\tfloat phi = min(atan(v.y, v.x), PI); // min() to dodge NaN\n\tfloat cosTheta = v.z;\n\tfloat k = max(2.0, floor(\n\t\tlog(N * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))\n\t\t/ log(PHI*PHI)));\n\tfloat Fk = pow(PHI, k)/sqrt(5.0);\n\tfloat F0 = floor(Fk + 0.5);\n\tfloat F1 = floor(Fk * PHI + 0.5);\n\tmat2 B = mat2(\n\t\t2.0*PI*fracmodphi(F0+1.0) - 2.0*PI*(PHI-1.0), -2.0*F0/N,\n\t\t2.0*PI*fracmodphi(F1+1.0) - 2.0*PI*(PHI-1.0), -2.0*F1/N);\n\tmat2 invB = inverse(B);\n\tvec2 c = floor(invB * vec2(phi, cosTheta - (1.0-1.0/N)));\n\n\tvec2 Bvec = vec2(B[0][1],B[1][1]);\n\t// Compute all four neighbors first, *then* find closest point\n\t// (Sorting is more efficient with all values available)\n    d.x = evalNearest(N, Bvec, vec2(0.0, 0.0), c, v, p0);\n    d.y = evalNearest(N, Bvec, vec2(1.0, 0.0), c, v, p1);\n    d.z = evalNearest(N, Bvec, vec2(0.0, 1.0), c, v, p2);\n    d.w = evalNearest(N, Bvec, vec2(1.0, 1.0), c, v, p3);\n\n\t// Incomplete sort: Just make sure p0 is closest\n   \tvec4 ptemp;\n\tbvec3 smaller = lessThan(d.yzw, d.xxx);\n\tif(any(smaller)) {\n\t\tbvec3 smallest = lessThan(d.yyz, d.zww);\n\t\tif(all(smallest.xy)) { // d.y smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p1;\n\t\t\tp1 = ptemp;\n\t\t\td.xy = d.yx;\n\t\t}\n\t\telse if(!any(smallest.yz)) { // d.w smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p3;\n\t\t\tp3 = ptemp;\n\t\t\td.xw = d.wx;\n\t\t}\n\t\telse { // d.z smallest\n\t\t\tptemp = p0;\n\t\t\tp0 = p2;\n\t\t\tp2 = ptemp;\n\t\t\td.xz = d.zx;\n\t\t}\n\t}\n}\n\n// Patch up errors around the sphere's +z and -z poles.\n// Several errors remain, but this fixes the relevant ones\n// for our purposes: after patching, all neighbors are\n// correct within the minimum radius required to cover the\n// entire sphere with equal-sized disks around each point,\n// which is the distance from points 1, 2 and 4 to the\n// centroid of the triangle spanned by those points,\n// with the first point being point 0.\n\n// A (dest,src) array to specify which patches to apply, and where:\n// \"For cell x, try adding neighbor y if it wasn't found already\".\n// The entries must be sorted on destination (x) in ascending order.\n//\n// This set of patches makes the algorithm work from N=8 and up.\n// If you don't need low N values, several of them can be omitted:\n// (2,0) is needed only for N=8,9\n// (5,3) is needed only for N=9\n// (4,1) is needed only for N=10,11\n// (3,6) is needed only for N<=11\n// (6,0) is needed only for N=11\n// (9,4) is needed only for N=20\n// (10,13) is needed only for N=21\n// If trashed duplicates (negative k) are tolerated for distant p3 (they\n// cause errors in the current code), some others could be omitted as well.\nconst vec2 polepatch[29] = vec2[](vec2(0.0, 3.0), vec2(0.0, 5.0), vec2(1.0, 3.0),\n\tvec2(1.0, 4.0),\tvec2(1.0, 6.0), vec2(2.0, 0.0), vec2(2.0, 5.0), vec2(2.0, 7.0),\n\tvec2(2.0, 10.0), vec2(3.0, 0.0), vec2(3.0, 6.0), vec2(3.0, 11.0), vec2(4.0,1.0),\n\tvec2(4.0, 9.0),\tvec2(5.0, 3.0), vec2(5.0, 8.0),\tvec2(5.0, 10.0), vec2(6.0, 0.0),\n\tvec2(6.0, 3.0),\tvec2(6.0, 11.0), vec2(7.0, 2.0), vec2(8.0, 5.0), vec2(8.0, 21.0),\n\tvec2(9.0, 4.0),\tvec2(9.0, 22.0), vec2(10.0, 13.0), vec2(10.0, 15.0), vec2(13.0, 21.0),\n\tvec2(14.0, 22.0));\n\n// The patching function. Only a few iterations of the \"for\" loop will amount\n// to any real amount of work, and there are early exits to speed it up further.\n// A modern GPU with \"peer-aware\" branches and loops will execute this efficiently.\n//\nvoid patchpoles(vec3 v, float N, inout vec4 p0, inout vec4 p1,\n                    inout vec4 p2, inout vec4 p3, inout vec4 d) {\n\n\tfloat k0 = p0.w;\n\n\t// If we are not near either pole, no patches are needed\n\tif((k0 > 15.0) && (k0 < N - 16.0)) return;\n\t// Trash duplicate neighbors for the patching to work\n\tvec4 ki = vec4(p0.w, p1.w, p2.w, p3.w);\n\t// p0 is correct, but not always unique\n\tbvec3 duplicates = equal(ki.xxx, ki.yzw);\n\tif(duplicates.x) { // trash p1\n\t\tp1 = vec4(0.0, 0.0, 0.0, -1.0); // Set invalid k\n\t\tki.y = -1.0;\n\t\td.y = 12.0; // More than the sphere diameter squared\n\t}\n\tif(duplicates.y) { // trash p2\n\t\tp2 = vec4(0.0, 0.0, 0.0, -2.0);\n\t\tki.z = -2.0;\n\t\td.z = 11.0;\n\t}\n\tif(duplicates.z) { // trash p3\n\t\tp3 = vec4(0.0, 0.0, 0.0, -3.0);\n\t\tki.w = -3.0;\n\t\td.w = 10.0;\n\t}\n\t// p1, p2 or p3 might be duplicates of each other\n\tduplicates = equal(ki.yyz, ki.zww);\n\tif(any(duplicates.yz)) { // p3 dup of p1 or p2, trash p3\n\t\tp3 = vec4(0.0, 0.0, 0.0, -3.0);\n\t\td.w = 10.0;\n\t}\n\tif(duplicates.x) { // p2 dup of p1, trash p2\n\t\tp2 = vec4(0.0, 0.0, 0.0, -2.0);\n\t\td.z = 11.0;\n\t}\n\n\t// Mirror indices from opposite pole for the patch loop\n\tbool kflip = (k0 > N*0.5 - 0.5);\n\tif(kflip) k0 = N - 1.0 - k0;\n\n\tfor(int i = 0; i < 29; i++) {\n\t\t// \"Patch cell x by including neighbor y\"\n\t\tvec2 dstsrc = polepatch[i];\n\t\t// A \"break\" has the rather unexpected side effect of\n        // preventing the GLSL compiler from unrolling the loop,\n        // which is an advantage in this case. The unrolled\n        // version of this loop has a huge instruction count\n        // and takes a long time to compile.\n\t\tif(k0 < dstsrc.x) break; // No more relevant patches\n\t\tif(dstsrc.x >= N*0.5) break; // No more relevant patches\n\t\tif(dstsrc.y >= N) continue; // This patch is not relevant\n\t\tif(k0 == dstsrc.x) { // This patch is relevant here\n\t\t\tvec3 k123 = vec3(p1.w, p2.w, p3.w);\n\t\t\tif(kflip) k123 = N - 1.0 - k123;\n\t\t\t// If this neighbor was already found, move on\n\t\t\tif(any(equal(k123, vec3(dstsrc.y)))) continue;\n\t\t\t// Evaluate the suggested neighbor, at the correct pole\n\t\t\tfloat knew = kflip ? N - 1.0 - dstsrc.y : dstsrc.y;\n\t\t\tvec3 pnew = evalSFpoint(knew, N);\n\t\t\tfloat dnew = dot(v-pnew, v-pnew);\n\t\t\tif(any(lessThan(vec3(dnew), d.yzw))) {\n\t\t\t\tbvec3 largest = greaterThan(d.yyz, d.zww);\n\t\t\t\tif(all(largest.xy)) { // d.y largest\n\t\t\t\t\tp1 = vec4(pnew, knew); // replace p1\n\t\t\t\t\td.y = dnew;\n\t\t\t\t}\n\t\t\t\telse if(!any(largest.yz)) { // d.w largest\n\t\t\t\t\tp3 = vec4(pnew, knew);\n\t\t\t\t\td.w = dnew;\n\t\t\t\t}\n\t\t\t\telse { // d.z largest\n\t\t\t\t\tp2 = vec4(pnew, knew);\n\t\t\t\t\td.z = dnew;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// Sort all points p1 to p3 on distance\n// (not always needed, see \"sortp0p1\" below)\nvoid sortpoints(inout vec4 p0, inout vec4 p1,\n                inout vec4 p2, inout vec4 p3, inout vec4 d) {\n    vec4 ptemp;\n    if((d.y <= d.z) && (d.z <= d.w))\n        return; // Already sorted\n    if(d.z < d.y) { // Swap 1,2\n        d.yz = d.zy;\n        ptemp = p1;\n        p1 = p2;\n        p2 = ptemp;\n    }\n    if(d.w < d.y) { // Swap 1,3\n        d.yw = d.wy;\n        ptemp = p1;\n        p1 = p3;\n        p3 = ptemp;\n    }\n    if(d.w < d.z) { // Swap 2,3\n        d.zw = d.wz;\n        ptemp = p2;\n        p2 = p3;\n        p3 = ptemp;\n    }\n}\n\n// Sort to make p0, p1 the two closest points\n// (Leave p2, p3 unsorted)\nvoid sortp0p1(inout vec4 p0, inout vec4 p1,\n              inout vec4 p2, inout vec4 p3, inout vec4 d) {\n    vec4 ptemp;\n    if((d.y <= d.z) && (d.z <= d.w))\n        return; // Already sorted\n    if((d.z < d.y) && (d.z < d.w)){ // Swap 1,2\n        d.yz = d.zy;\n        ptemp = p1;\n        p1 = p2;\n        p2 = ptemp;\n    } else if(d.w < d.y) { // Swap 1,3\n        d.yw = d.wy;\n        ptemp = p1;\n        p1 = p3;\n        p3 = ptemp;\n    }\n}\n","name":"Common","description":"","type":"common"}]}