{"ver":"0.1","info":{"id":"ldScDc","date":"1494090899","viewed":212,"name":"Raytracer with Reflections","username":"Assossa","description":"Credits in the comments\n\nhttps://github.com/AssossaGPB/Shadertoy-Raytracers","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raytracer","reflections","prototype"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nBase raytracer: http://fhtr.blogspot.com/2013/12/opus-2-glsl-ray-tracing-tutorial.html\nCube intersection function: https://tavianator.com/fast-branchless-raybounding-box-intersections/\nCube normal function: http://ray-tracing-conept.blogspot.com/2015/01/ray-box-intersection-and-normal.html\nImplemented suggestions from: iapafoto, abje, KylBlz\n*/\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius) {\n    vec3 rc = ray - center;\n    float c = dot(rc, rc) - (radius * radius);\n    float b = dot(dir, rc);\n    float d = b * b - c;\n    float t = -b - sqrt(abs(d));\n    float st = step(0.0, min(t, d));\n    return mix(-1.0, t, st);\n}\n\nfloat cube(vec3 ray, vec3 dir, vec3 bmin, vec3 bmax) {\n    vec3 ddir = 1.0 / dir;\n    vec3 t1 = (bmin - ray) * ddir;\n    vec3 t2 = (bmax - ray) * ddir;\n    vec3 tmin = vec3(min(t1.x, t2.x), min(t1.y, t2.y), min(t1.z, t2.z));\n    vec3 tmax = vec3(max(t1.x, t2.x), max(t1.y, t2.y), max(t1.z, t2.z));\n    float tmin_max = max(tmin.x, max(tmin.y, tmin.z));\n    float tmax_min = min(tmax.x, min(tmax.y, tmax.z));\n    return tmax_min >= tmin_max ? tmin_max : -1.0;\n}\n\nvec3 cubeNml(vec3 i, vec3 bmin, vec3 bmax) {\n    float epsilon = 0.01;\n    vec3 c = abs(i-bmin);\n    vec3 f = abs(i-bmax);\n    return normalize(step(c, vec3(epsilon)) - step(f, vec3(epsilon)));\n}\n\nvec3 background(float t, vec3 rd) {\n    vec3 light = normalize(vec3(sin(t), 0.2, cos(t)));\n    float sun = max(0.0, dot(rd, light));\n    float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n    float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n    return (pow(sun, 256.0) + 0.2 * pow(sun, 2.0)) * vec3(2.0, 1.6, 1.0) +\n        pow(ground, 0.5) * vec3(0.4, 0.3, 0.2) +\n        pow(sky, 1.0) * vec3(0.5, 0.6, 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy) * vec2(iResolution.x / iResolution.y, 1.0);\n    vec3 ro = 1.5 * vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 2.0));\n\n    vec3 transmit = vec3(1.0);\n    vec3 light = vec3(0.0);\n\n    float epsilon = 0.001;\n    int bounce_count = 8;\n\n    // Cube\n    vec3 cmin;\n    vec3 cmax;\n    {\n        vec3 size = vec3(0.25);\n        float orbit_radius = 2.25;\n        float orbit_speed = 1.334;\n        vec3 center = vec3(sin(iTime * orbit_speed) * orbit_radius, 0.0, cos(iTime * orbit_speed) * orbit_radius);\n        cmin = center - size;\n        cmax = center + size;\n    }\n    float cmat = 0.8;\n\n    // Sphere\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    float radius = 1.75;\n    float smat = 0.9;\n\n    for (int i = 0; i < bounce_count; i++) {\n        float c = cube(ro, rd, cmin, cmax);\n        float s = sphere(ro, rd, p, radius);\n\n        if (c > 0.0 && (s <= 0.0 || (s > 0.0 && s > c))) { // Ray hit the cube\n            ro += rd * c;\n            vec3 nml = cubeNml(ro, cmin, cmax);\n            transmit *= cmat;\n            rd = reflect(rd, nml);\n            ro += rd * epsilon;\n        } else if (s > 0.0 && (c <= 0.0 || (c > 0.0 && c > s))) { // Ray hit the sphere\n            ro += rd * s;\n            vec3 nml = normalize(p - ro);\n            transmit *= smat;\n            rd = reflect(rd, nml);\n            ro += rd * epsilon;\n        } else {\n            light += transmit * background(iTime, rd);\n            break;\n        }\n    }\n\n\tfragColor = vec4(light, 1.0);\n}","name":"Image","description":"","type":"image"}]}