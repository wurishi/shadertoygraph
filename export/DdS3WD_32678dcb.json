{"ver":"0.1","info":{"id":"DdS3WD","date":"1667579016","viewed":52,"name":"Star explore 2d","username":"gavroche","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["stars"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358979323846\n\n\n\nfloat circle(in vec2 uv, in vec2 center, in float radius, in float prec){\n    \n    return 1.-smoothstep(0., prec, length(uv-center)-radius);\n}\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\n\n\nfloat contour_triangle(in vec2 uv, float angle, float size, vec2 center){\n    //angle = mod(angle,PI+0.1);\n    uv.x-=center.x;\n    uv.y-=center.y;\n    if (angle<0.){\n        angle = -angle;\n    }\n\n    if (abs(angle)>PI){\n        uv = uv*rotate2d(PI);\n        angle = -angle;\n    }\n    return smoothstep(uv.x, uv.x+0.01,tan(angle/2.)*uv.y)*smoothstep(-uv.x, -uv.x+0.01,tan(angle/2.)*uv.y)-\n    smoothstep(uv.x, uv.x+0.01,tan((angle-size)/2.)*uv.y)*smoothstep(-uv.x, -uv.x+0.01,tan((angle-size)/2.)*uv.y);;\n}\n\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ( 2.*fragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec2 st  = uv;\n    vec2 center = vec2(0.);\n\n    vec3 col = vec3(0.);\n\n    float vitesse = 0.1;\n    uv = uv*rotate2d(PI*vitesse*iTime);\n    \n    int nb_stars = 100;\n    float f_stars = float(nb_stars);\n    \n    for(int i = 0; i<nb_stars; i++){\n        vec2 pos = vec2(max(fract(sin(float(i)*4843.)),0.1), max(fract(cos(float(i)*357.)),0.1));\n        pos = normalize(pos)*10.;\n        vec2 pos_lessx = vec2(max(fract(sin(float(i)*424.)),0.1), max(fract(cos(float(i)*614.)),0.1));\n        pos_lessx = normalize(pos_lessx)*vec2(-10.,10.);\n        vec2 pos_lessy = vec2(max(fract(sin(float(i)*105.)),0.1), max(fract(cos(float(i)*47.)),0.1));\n        pos_lessy = normalize(pos_lessy)*vec2(10.,-10.);\n        vec2 pos_lessxy = vec2(max(fract(sin(float(i)*734.)),0.1), max(fract(cos(float(i)*3242.)),0.1));\n        pos_lessxy = normalize(pos_lessxy)*vec2(-10.,-10.);\n        \n        \n    \n        float moving = fract(fract(pos.y*pos.x)+iTime*vitesse);\n        col+= circle(uv, mix(vec2(0.), pos, moving), mix(0.,0.05, moving), 0.001);\n        col+= circle(uv, mix(vec2(0.), pos_lessx, fract(fract(pos.x*pos.y)+iTime*vitesse)), mix(0.,0.05, fract(fract(pos.x*pos.y)+iTime*vitesse)),0.001);\n        col+= circle(uv, mix(vec2(0.), pos_lessy, fract(fract(pos.y*pos.y)+iTime*vitesse)), mix(0.,0.05, fract(fract(pos.y*pos.y)+iTime*vitesse)), 0.001);\n        col+= circle(uv, mix(vec2(0.), pos_lessxy, fract(fract(pos.x*pos.x)+iTime*vitesse)), mix(0.,0.05, fract(fract(pos.x*pos.x)+iTime*vitesse)),0.001);\n    \n    }\n\n\n    \n    int nb_rayons = 4;\n    float f_rayons = float(nb_rayons);\n    vec2 center_ray = vec2(0.6,0.3);\n    for (int i =0; i<nb_rayons; i++){\n        float f_i = float(i)/f_rayons*PI;\n        float moving_ray = (3.*PI*sin(iTime*1.)+f_i)/2.;\n        //float moving_ray = -PI;\n        col+= contour_triangle(st, moving_ray, 0.05, center_ray)*hsb2rgb(vec3(fract(iTime*vitesse), 1.,1.))*\n                        (2.-distance(st, center_ray))*vec3(abs(2.*PI-moving_ray)/(2.*PI));\n        \n        col+= contour_triangle(st, moving_ray, 0.05, center_ray*vec2(-1.,1.))*hsb2rgb(vec3(fract(iTime*vitesse), 1.,1.))*\n                        (2.-distance(st, center_ray*vec2(-1.,1.)))*vec3(abs(2.*PI-moving_ray)/(2.*PI));\n        col+= contour_triangle(st*rotate2d(PI), moving_ray, 0.05, center_ray)*hsb2rgb(vec3(fract(iTime*vitesse), 1.,1.))*\n                        (2.-distance(st*rotate2d(PI), center_ray))*vec3(abs(2.*PI-moving_ray)/(2.*PI));\n        col+= contour_triangle(st*rotate2d(PI), moving_ray, 0.05, center_ray*vec2(-1.,1.))*hsb2rgb(vec3(fract(iTime*vitesse), 1.,1.))*\n                        (2.-distance(st*rotate2d(PI), center_ray*vec2(-1.,1.)))*vec3(abs(2.*PI-moving_ray)/(2.*PI));\n        \n    }\n    \n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}