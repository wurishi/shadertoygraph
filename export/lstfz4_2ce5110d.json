{"ver":"0.1","info":{"id":"lstfz4","date":"1524776416","viewed":227,"name":"GSV","username":"shau","description":"Not sure if I should post as it's slow and bloated but runs ok on my quicker machines. Anyways \"The Mistake Not\" again. This time with a General Systems Vehicle from Hydrogen Sonata by Iain M Banks","likes":9,"published":1,"flags":32,"usePreview":0,"tags":["3d"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define BRIDGE_CORE 1.0\n#define BRIDGE_BOX 2.0\n#define BRIDGE_LIGHT 3.0\n#define GIRDER 4.0\n#define WALL 5.0\n#define BODY 6.0\n#define WINDOW 7.0\n#define CHROME 8.0\n#define ENGINE 9.0\n#define MANIPULATOR 10.0\n#define LANDING_LIGHT 11.0\n#define ACCESS_TUNNEL 12.0\n\n#define WALL_REFLECTION 1\n#define FAR 1000.0\n#define EPS 0.005 \n  \nstruct Scene {\n    float t;\n    float id;\n    vec3 n;\n};\n    \nvec3 shipPosition() {return texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy).xyz;}    \n    \n//girder texture\nfloat tex(vec3 rp, vec3 n) {\n    rp.xy = abs(n.y) > abs(n.z) ? rp.xz : rp.xy; \n    rp.x = mod(rp.x, 4.0) - 2.0;\n    if (abs(rp.y) > 0.9 || abs(rp.x) > 1.9) return 1.0;\n    if (rp.x / rp.y > 1.8 && rp.x / rp.y < 2.2) return 1.0;\n    return 0.0;\n}\n\n//IQ antialiasing\n//see https://www.shadertoy.com/view/MtffWs\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy) {\n    const float N = 40.0; // grid ratio\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5 * w;                        \n    vec2 b = p - 0.5 * w;           \n    vec2 i = (floor(a) + min(fract(a) * N, 1.0)-\n              floor(b) - min(fract(b) * N, 1.0)) / (N * w);\n    return (1.0 - i.x) * (1.0 - i.y);\n}\n\n/* SHIP MODEL */\n\nvec2 dfGun(vec3 rp) {\n    float grey = fCylinder(rp.xzy - vec3(0.0, -4.2, 0.0), 0.15, 2.6);\n    rp.z = abs(rp.z);\n    grey = min(grey, fCylinder(rp.xzy - vec3(0.0, 2.2, 0.0), 1.2, 0.3));   \n    pModPolar(rp.yx, 3.0);\n    float body = fCylinder(rp.xzy - vec3(0.0, 2.8, 0.6), 0.4, 0.4);\n    body = max(body, -fCylinder(rp.xzy - vec3(0.0, 2.8, 0.6), 0.1, 0.6));\n    return nearest(vec2(body, BODY), vec2(grey, CHROME));\n}\n\nvec2 dfManipulator(vec3 rp, float ma) {\n    rp.yz *= rot(ma);\n    vec3 j5b = vec3(0.6, 0.0, 0.0);\n    vec3 j5a = j5b + vec3(0.0, 0.0, 1.0) * 1.0;\n    vec3 j5c = j5b + vec3(0.0, 0.0, -1.0) * 1.0;\n    vec3 j5d = vec3(0.0, j5c.yz);    \n    float body = fCylinder(rp.xzy - j5d.xzy, 0.8, 0.3);\n    float manipulator = sdConeSection(rp.xzy - vec3(0.0, -5.0, 0.0), 4.0, 0.05, 0.4);\n    rp.x = abs(rp.x);\n    body = min(body, fCylinder(rp.zxy - j5b.zxy, 0.4, 0.3));\n    float chrome = sdCapsule(rp, j5a, j5c, 0.2);\n    vec2 near = nearest(vec2(body, BODY), vec2(chrome, CHROME));\n    return nearest(near, vec2(manipulator, MANIPULATOR));\n}\n\n//la - lower arm angle, ua - upper arm angle, ma - manipulator angle \nvec2 dfArm(vec3 rp, float la, float ua, float ma) {\n    //calculate joint positions\n    vec3 lad = vec3(0.0, 1.0, 0.0);\n    lad.yz *= rot(la);\n    //lower arm\n    vec3 j1a = vec3(0.7, 0.0, -1.5);\n    vec3 j1b = j1a + lad * 7.0;\n    vec3 j1c = j1a + lad * 11.0;\n    vec3 j1d = j1a + lad * 14.0;\n    //lower arm piston\n    vec3 j2a = vec3(0.0, 0.0, 1.5);\n    vec3 j2b = vec3(0.0, j1b.yz);  \n    vec3 lad2 = normalize(j2b - j2a);\n    float adt = length(j2b - j2a);\n    vec3 j2c = j2a + lad2 * (adt - 2.0);\n    //upper arm\n    vec3 uad = vec3(0.0, 0.0, -1.0);\n    vec3 uad2 = vec3(0.0, 0.0, 1.0);\n    uad.yz *= rot(ua);\n    uad2.yz *= rot(ua);\n    vec3 j3b = vec3(0.0, j1c.yz);\n    vec3 j3a = j3b + uad2 * 1.6;\n    vec3 j3c = j3b + uad * 9.0;\n    vec3 j3d = j3b + uad * 19.0;\n    //upper arm piston\n    vec3 j4a = vec3(0.0, j1d.yz);\n    vec3 ud3 = normalize(j3c - j4a);\n    float udt = length(j3c - j4a);\n    vec3 j4b = j4a + ud3 * 4.0;\n    vec3 j4c = j4a + ud3 * 5.0;\n    vec3 j4d = vec3(0.6, j4c.yz);\n    vec3 j4e = vec3(0.6, j3c.yz);\n    //lower arm piston\n    float body = fCylinder(rp.zxy - j2a.zxy, 0.6, 0.4);\n    body = min(body, fCylinder(rp.zxy - j2b.zxy, 0.6, 0.3));\n    float chrome = sdCapsule(rp, j2a, j2b, 0.25);\n    body = min(body, sdCapsule(rp, j2a, j2c, 0.4));\n    //upper arm\n    chrome = min(chrome, sdCapsule(rp, j3a, j3d, 0.2));\n    body = min(body, fCylinder(rp.zxy - j3b.zxy, 0.6, 0.3));\n    body = min(body, fCylinder(rp.zxy - j3c.zxy, 0.6, 0.3));\n    body = min(body, fCylinder(rp.zxy - j3d.zxy, 0.6, 0.3));\n    //upper arm piston top\n    body = min(body, fCylinder(rp.zxy - j4a.zxy, 0.6, 0.3));\n    body = min(body, sdCapsule(rp, j4a, j4b, 0.3));\n    chrome = min(chrome, sdCapsule(rp, j4a, j4c, 0.2));\n    //manipulator\n    vec2 manipulator = dfManipulator(rp - j3d, ma);\n    //lower arm\n    rp.x = abs(rp.x);\n    body = min(body, fCylinder(rp.zxy - j1a.zxy, 0.5, 0.4));    \n    chrome = min(chrome, sdCapsule(rp, j1a, j1d, 0.2));\n    body = min(body, fCylinder(rp.zxy - j1b.zxy, 0.5, 0.3));\n    body = min(body, fCylinder(rp.zxy - j1c.zxy, 0.5, 0.3));\n    body = min(body, fCylinder(rp.zxy - j1d.zxy, 0.5, 0.3));\n    //upper arm piston   \n    chrome = min(chrome, sdCapsule(rp, j4c, j4d, 0.2));\n    chrome = min(chrome, sdCapsule(rp, j4d, j4e, 0.2));\n    body = min(body, fCylinder(rp.zxy - j4e.zxy, 0.4, 0.3));    \n    vec2 near = nearest(vec2(body, BODY), vec2(chrome, CHROME));\n    return nearest(near, manipulator);\n}\n\nvec2 dfShip(vec3 rp) {\n    vec4 animation = texture(iChannel0, vec2(2.5, 0.5) / iResolution.xy);    \n    float gla = animation.y;\n    float gua = animation.z;\n    float gma = animation.w;\n    rp.xy *= rot(animation.x);\n    //ship body\n    float body = sdEllipsoid(rp, vec3(2.0, 2.0, 14.0));\n    body = max(body, rp.z - 0.0);\n    body = min(body, sdSphere(rp, 2.0));\n    float bodycut =  fCylinder(rp.xzy - vec3(0.0, 0.0, 0.0), 1.1, 4.0);\n    body = max(body, - bodycut);\n    //window\n    float window = sdEllipsoid(rp, vec3(1.5, 1.5, 13.0));\n    window = max(window, rp.z - 0.0);\n    float windowring = sdTorus(rp - vec3(0.0, 0.0, -10.0), vec2(1.1, 0.1));\n    //docking thing\n    float dock = fCylinder(rp - vec3(0.0, 1.0, -8.0), 0.4, 1.0);    \n    dock = max(dock, -fCylinder(rp - vec3(0.0, 1.0, -8.0), 0.3, 1.2));    \n    body = smin(body, dock, 0.1);\n    //engine\n    float enginecowl = sdConeSection(rp.xzy - vec3(0.0, 1.0, 0.0), 1.0, 1.85, 1.2);\n    float cowlcut =  fCylinder(rp.xzy - vec3(0.0, 0.0, 0.0), 1.0, 4.0);\n    enginecowl = max(enginecowl, -cowlcut);\n    float enginecore = sdSphere(rp -vec3(0.0, 0.0, 0.6), 1.0);\n    vec3 q = rp;\n    pModPolar(q.yx, 3.0); //arm platforms\n    body = smin(body, sdBox(q - vec3(0.0, 1.0, -3.0), vec3(0.8, 1.2, 3.0)), 0.4);\n    //armature mounts\n    float amount1 = fCylinder(q.zxy - vec3(-4.0, 0.0, 1.0), 3.2, 0.1);\n    amount1 = max(amount1, -q.z - 5.0);\n    amount1 = max(amount1, -q.y);\n    body = min(body, amount1);\n    //arms\n    vec2 arm = dfArm(q - vec3(0.0, 3.5, -3.0), gla, gua, gma);\n    //armature mounts\n    q.x = abs(q.x);\n    float amount2 = fCylinder(q.zxy - vec3(-2.0, 0.5, 1.0), 3.2, 0.1);\n    amount2 = max(amount2, q.z + 1.0);\n    amount2 = max(amount2, -q.y);\n    body = min(body, amount2);\n    //windows\n    q = rp;\n    q.xy *= rot(PI / 3.0);\n    pModPolar(q.yx, 3.0);\n    body = max(body, -sdEllipsoid(q - vec3(0.0, 1.5, -11.0), vec3(0.8, 1.2, 4.0)));\n    body = min(body, windowring);\n    //gun mounts\n    body = smin(body, sdBox(q - vec3(0.0, 2.0, -3.0), vec3(0.2, 3.0, 1.4)), 0.4);\n    body = min(body, fCylinder(q.xzy - vec3(0.0, -3.0, 5.0), 0.6, 2.0));\n    //gun\n    vec2 gun = dfGun(q - vec3(0.0, 5.0, -3.0));\n    vec2 near = vec2(body, BODY);\n    near = nearest(near, vec2(window, WINDOW));\n    near = nearest(near, vec2(enginecowl, CHROME));\n    near = nearest(near, vec2(enginecore, ENGINE));\n    near = nearest(near, gun);\n    return nearest(near, arm);\n}\n//*/\n\n/* BRIDGE MODEL */\n\nvec2 dfBridge(vec3 rp) {\n    float mount = sdBox(rp, vec3(2.0, 7.0, 10.0));\n    mount = min(mount, sdBox(rp, vec3(7.0, 2.0, 10.0)));\n    float accessTunnel = sdCapsule(rp, vec3(0.0, 3.0, -10.0), vec3(0.0, 3.0, -27.0), 0.4);\n    accessTunnel = min(accessTunnel, sdCapsule(rp, vec3(0.0, 3.0, -27.0), vec3(5.0, 3.0, -27.0), 0.4));\n    accessTunnel = min(accessTunnel, fCylinder(rp - vec3(5.0, 2.8, -27.0), 1.0, 0.2));\n    float landingLight = sdSphere(rp - vec3(0.0, 0.0, -10.0), 1.0);\n    float core = sdBox(rp, vec3(200.0, 8.0, 8.0));\n    rp.x = mod(rp.x, 22.0) - 11.0;    \n    rp = abs(rp);\n    float boxes = sdBox(rp - vec3(5.0), vec3(4.6));\n    float lt = max(sdBox(rp, vec3(9.0)), -boxes);\n    vec2 near = nearest(vec2(boxes, BRIDGE_BOX), vec2(lt, BRIDGE_LIGHT));\n    near = nearest(near, vec2(mount, BRIDGE_CORE));\n    near = nearest(near, vec2(landingLight, LANDING_LIGHT));\n    near = nearest(near, vec2(accessTunnel, ACCESS_TUNNEL));\n    return nearest(near, vec2(core, BRIDGE_CORE));\n}\n\n/* DRAWING ROUTINES */\n\nvec2 map(vec3 rp, vec3 sp) {\n\tvec2 near = nearest(dfBridge(rp), dfBridge(rp - vec3(0.0, 0.0, 500.0)));\n    near = nearest(near, dfBridge(rp  - vec3(0.0, 0.0, -500.0)));\n    near = nearest(near, dfShip(rp  - sp));\n    return near;\n}\n\n// Tetrahedral normal IQ\nvec3 tnormal(vec3 p, vec3 sp) {  \n    vec2 e = vec2(-1., 1.) * EPS;   \n\treturn normalize(e.yxx * map(p + e.yxx, sp).x + e.xxy * map(p + e.xxy, sp).x + \n\t\t\t\t\t e.xyx * map(p + e.xyx, sp).x + e.yyy * map(p + e.yyy, sp).x);   \n}\n\nvec2 marchScene(vec3 ro, vec3 rd, vec3 sp) {\n    float t = 0.0, id = 0.0;\n    for (int i = 0; i < 96; i++) {\n        vec2 ns = map(ro + rd * t, sp);\n        if (ns.x < EPS || t > FAR) {\n            id = ns.y;\n            break;\n        }\n        t += ns.x;\n    }    \n    return vec2(t, id);\n}\n\nvec4 drawGirder(vec3 ro, vec3 rd, vec3 girder, vec3 girderPosition) {\n    float mint = 0.0;\n    vec3 minn = vec3(0.0);\n    CubeIntersection ci = cubeIntersection(ro - girderPosition, rd, girder);\n    if (ci.tN > 0.0) {\n        //near face\n        vec3 rp = ro + rd * ci.tN;\n        float gt = tex(rp - girderPosition, ci.nN);\n        if (gt > 0.0) {\n            mint = ci.tN;\n            minn = ci.nN;\n        } else {\n            //far face\n            rp = ro + rd * ci.tF;\n            gt = tex(rp - girderPosition, ci.nF);\n            if (gt > 0.0) {\n                mint = ci.tF;\n                minn = ci.nF;\n            }\n        }\n    }\n    return vec4(minn, mint);\n}\n\nScene drawGirders(vec3 ro, vec3 rd) {    \n    float mint = FAR;\n    float id = 0.0;\n    vec3 minn = vec3(0.0);\n    /* Near Bridge */\n    //top girder\n    vec4 girder1 = drawGirder(ro, rd, vec3(FAR, 1.0, 1.0), vec3(0.0, 5.0, -40.0));\n    if (girder1.w > 0.0 && girder1.w < mint) {\n        mint = girder1.w;\n        id = GIRDER;\n        minn = girder1.xyz;\n    }\n    //another girder\n    vec4 girder7 = drawGirder(ro, rd, vec3(FAR, 1.0, 1.0), vec3(0.0, -10.0, 14.0));\n    if (girder7.w > 0.0 && girder7.w < mint) {\n        mint = girder7.w;\n        id = GIRDER;\n        minn = girder7.xyz;\n    }\n    //bottom girder\n    vec4 girder2 = drawGirder(ro, rd, vec3(FAR, 1.0, 1.0), vec3(0.0, -16.0, -8.0));\n    if (girder2.w > 0.0 && girder2.w < mint) {\n        mint = girder2.w;\n        id = GIRDER;\n        minn = girder2.xyz;\n    }\n    //short girder\n    vec4 girder3 = drawGirder(ro.zyx, rd.zyx, vec3(15.0, 1.0, 1.0), vec3(-24.0, 5.0, 0.0));\n    if (girder3.w > 0.0 && girder3.w < mint) {\n        mint = girder3.w;\n        id = GIRDER;\n        minn = girder3.xyz;\n    }\n    /* Far Bridges */\n    //bottom girder\n    vec4 girder5 = drawGirder(ro, rd, vec3(FAR, 1.0, 1.0), vec3(0.0, -16.0, 492.0));\n    if (girder5.w > 0.0 && girder5.w < mint) {\n        mint = girder5.w;\n        id = GIRDER;\n        minn = girder5.xyz;\n    }\n    //bottom girder\n    vec4 girder8 = drawGirder(ro, rd, vec3(FAR, 1.0, 1.0), vec3(0.0, -16.0, -508.0));\n    if (girder8.w > 0.0 && girder8.w < mint) {\n        mint = girder8.w;\n        id = GIRDER;\n        minn = girder8.xyz;\n    }\n    //vertical girder\n    vec4 girder6 = drawGirder(ro.yxz, rd.yxz, vec3(FAR, 1.0, 1.0), vec3(0.0, -100.0, -16.0));\n    if (girder6.w > 0.0 && girder6.w < mint) {\n        mint = girder6.w;\n        id = GIRDER;\n        minn = girder6.xyz;\n    }\n    return Scene(mint, id, minn);\n}\n\nScene drawScene(vec3 ro, vec3 rd) {\n    \n    float mint = FAR;\n    float id = 0.0;\n    vec3 minn = vec3(0.0);\n    vec3 sp = shipPosition();\n    vec3 boundsPosition = sp + vec3(0.0, 2.0, -12.0);\n    \n    //ship and bridges with bounds check\n    CubeIntersection ciShip = cubeIntersection(ro - boundsPosition, rd, vec3(17.0, 17.0, 18.0));\n    CubeIntersection ciNearBridge = cubeIntersection(ro - vec3(0.0, 0.0, -10.0), rd, vec3(FAR, 12.0, 22.0));\n    CubeIntersection ciFarBridge1 = cubeIntersection(ro - vec3(0.0, 0.0, 490.0), rd, vec3(FAR, 12.0, 22.0));\n    CubeIntersection ciFarBridge2 = cubeIntersection(ro - vec3(0.0, 0.0, -510.0), rd, vec3(FAR, 12.0, 22.0));\n    if (ciShip.tN > 0.0 ||\n        ciNearBridge.tN > 0.0 || ciNearBridge.tF > 0.0 ||\n        ciFarBridge1.tN > 0.0 || ciFarBridge1.tF > 0.0 ||\n        ciFarBridge2.tN > 0.0 || ciFarBridge2.tF > 0.0) {\n        \n        float stepForward = min(ciShip.tN, min(ciNearBridge.tN, min(ciFarBridge1.tN, ciFarBridge2.tN)));\n        stepForward = max(0.0, stepForward - 1.);\n        vec2 bridge = marchScene(ro + rd, rd, sp);\n        if (bridge.x > 0.0 && bridge.x < mint) {\n            vec3 rp = ro + rd * bridge.x;\n            mint = bridge.x;\n            id = bridge.y;\n            minn = tnormal(rp, sp);\n        }\n    }\n    \n    //wall\n    vec3 wn = vec3(1.0, 0.0, 0.0);\n    float wt = planeIntersection(ro, rd, wn, vec3(-111.0, 0.0, 0.0));\n    if (wt > 0.0 && wt < mint) {\n        mint = wt;\n        id = WALL;\n        minn = wn;\n    }   \n    \n    //girders\n    Scene girders = drawGirders(ro, rd);\n    if (girders.t < mint) return girders;\n\n    return Scene(mint, id, minn);\n}\n\n//adapted from one of Shanes shaders\nvec3 sky(in vec3 ro, in vec3 rd, vec3 lp){\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.0);\n    vec3 col = mix(vec3(.2, .1, 0.06), vec3(.1, .08, 0.8), rd.y * .5 + .5);\n    col += 0.25*vec3(.4, .7, 1.0) * pow(sun, 8.0);\n\tcol += 0.25*vec3(.6, .8, 1.0) * pow(sun, 64.0);\n\tcol += 0.15*vec3(.7, .9, 1.0) * max(pow(sun, 512.0), .25);\n    return col;\n}\n\n// Based on original by IQ.\n// https://iquilezles.org/articles/raymarchingdf\nfloat AO(vec3 rp, vec3 n) {\n    float r = 0.0;\n    float w = 1.0;\n    float d = 0.0;\n    vec3 sp = shipPosition();\n    for (float i = 1.0; i < 5.0; i += 1.0){\n        d = i / 5.0;\n        //r += w * (d - dfShip((rp - sp) + n * d).x);\n        w *= 0.5;\n    }\n    return 1.0 - clamp(r, 0.0, 1.0);\n}\n\n//hard shadow\nfloat shadow(vec3 rp, vec3 ld, float maxt) {\n    float sh = 1.0, mint = FAR;\n    Scene girders = drawGirders(rp, ld); \n    if (girders.t > 0.0 && girders.t < FAR) {\n        mint = girders.t;\n    }\n    CubeIntersection ciBridge = cubeIntersection(rp, ld, vec3(1000.0, 10.0, 10.0));\n    if ((ciBridge.tN > 0.0 && ciBridge.tN < mint) || \n        (ciBridge.tF > 0.0 && ciBridge.tF < mint)) {\n        mint = ciBridge.tN;        \n    }\n    ciBridge = cubeIntersection(rp - vec3(0.0, 0.0, 500.0), ld, vec3(1000.0, 10.0, 10.0));\n    if ((ciBridge.tN > 0.0 && ciBridge.tN < mint) ||\n        (ciBridge.tF > 0.0 && ciBridge.tF < mint)) {\n        mint = ciBridge.tN;        \n    }\n    ciBridge = cubeIntersection(rp - vec3(0.0, 0.0, -500.0), ld, vec3(1000.0, 10.0, 10.0));\n    if ((ciBridge.tN > 0.0 && ciBridge.tN < mint) ||\n        (ciBridge.tF > 0.0 && ciBridge.tF < mint)) {\n        mint = ciBridge.tN;        \n    }\n    if (mint < FAR) sh = 1.0 - (1.0 / (1.0 + mint * mint * 0.004));\n    return sh;\n}\n\nvec4 colourScene(vec3 ro, \n                 vec3 rd, \n                 Scene scene) {\n    \n    float refl = 0.0;\n\n    vec3 pc = vec3(0.0);\n    vec3 sunPosition = vec3(200.0, 150.0, 1001.0);\n    vec3 lightPosition = vec3(200.0, 20.0, 1001.0);\n    \n    vec3 skyColour = sky(ro, rd, sunPosition);\n    vec3 landingLightColour = texture(iChannel0, vec2(3.5, 0.5) / iResolution.xy).xyz;\n    \n    if (scene.t > 0.0 && scene.t < FAR) {\n        \n        vec3 rp = ro + rd * scene.t;;\n        vec3 ld = normalize(lightPosition - rp);\n        float lt = length(lightPosition - rp);\n        \n        float diff = min(dot(ld, scene.n), 0.5);\n        float spec = pow(max(dot(reflect(-ld, scene.n), -rd), 0.0), 64.0);\n    \tfloat fres = pow(clamp(dot(scene.n, rd) + 1.0, 0.0, 1.0), 16.0);\n        float ao = AO(rp, scene.n);\n        \n\t\tfloat sh = shadow(rp - (rd * EPS), ld, lt);\n        vec3 reflectedSkyColour = sky(rp, reflect(rd, scene.n), sunPosition);\n        \n        if (scene.id == BRIDGE_LIGHT) {\n            pc = vec3(1.0) * ao;\n        } else if (scene.id == BRIDGE_BOX) {\n            pc = reflectedSkyColour * diff * ao * 0.4;\n            refl = 0.4;\n        } else if (scene.id == BRIDGE_CORE) {\n            pc = vec3(0.2) * diff * ao;\n        } else if (scene.id == ACCESS_TUNNEL) {\n            pc = vec3(1.0) * diff * ao * sh;\n            refl = 0.3;\n        } else if (scene.id == LANDING_LIGHT) {\n            pc = landingLightColour;\n        } else if (scene.id == BODY) {\n            pc = vec3(0.02) * diff;\n            pc += reflectedSkyColour * spec * sh;\n            refl = 0.3;\n        } else if (scene.id == CHROME) {\n            pc = reflectedSkyColour * spec * sh;\n            refl = 0.9;\n        } else if (scene.id == ENGINE) {\n            pc = vec3(0.0, 1.0, 0.0) * ao;\n        } else if (scene.id == WINDOW) {\n            pc = vec3(1.0, 0.2, 0.0) * max(ao, 0.6);\n            refl = 0.2;\n        } else if (scene.id == MANIPULATOR) {\n            pc = vec3(0.0, 0.0, 1.0) * ao;\n            refl = 0.4;\n        } else if (scene.id == WALL) {\n            float edge = step(0.01, fract(rp.yz * 0.006).x) \n                       * step(0.01, fract(rp.yz * 0.006).y);\n            pc = reflectedSkyColour * diff * max(0.6, sh) * edge;\n            refl = edge;\n        } else if (scene.id == GIRDER) {\n            pc = vec3(1.0) * diff * sh;\n        }\n    }\n    \n    //glow around landing light\n    float si = sphIntersect(ro, rd, vec4(0.0, 0.0, -10.0, 3.0));\n    if (si > 0.0 && si < scene.t) {\n        float li = sphDensity(ro, rd, vec4(0.0, 0.0, -10.0, 3.0), FAR);\n        pc += landingLightColour * li * li * 0.8;\n    }\n    \n    pc =  mix(pc, skyColour, scene.t / FAR); //fog\n    return vec4(pc, refl);\n}\n\nvoid setupCamera(vec2 fragCoord, inout vec3 ro, inout vec3 rd) {\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 lookAt = texture(iChannel0, vec2(1.5, 0.5) / iResolution.xy).xyz;\n    ro = texture(iChannel0, vec2(0.5, 0.5) / iResolution.xy).xyz;\n    float FOV = PI / 3.0;\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0.0, -forward.x)); \n    vec3 up = cross(forward, right);\n    rd = normalize(forward + FOV * uv.x * right + FOV * uv.y * up);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    float mint = FAR;\n\tvec3 pc, ro, rd;\n    vec3 sunPosition = vec3(200.0, 150.0, 1001.0);\n    \n    setupCamera(fragCoord, ro, rd);\n    \n    vec3 skyColour = sky(ro, rd, sunPosition);\n\n    float refl = 1.0, tt = 0.0, las = 1.0, a = 1.0;\n\n    for (int i = 0; i < 2; i++) {\n    \n        Scene scene = drawScene(ro, rd);\n        \n        if (i == 0 && scene.t > 0.0) mint = scene.t;\n       \n        vec4 sc = colourScene(ro, rd, scene);\n        \n        pc = mix(pc, sc.xyz * max(dot(rd, scene.n), 0.6), las * refl);\n        \n        refl = sc.w;\n        tt += scene.t;\n        las = scene.id == 0.0 ? 1.0 : 1.0 / (1.0 + scene.t * scene.t * 0.0004);\n        if (scene.t == 0.0 || refl == 0.0) break;\n\n        ro = ro + rd * (scene.t - EPS);\n        rd = reflect(rd, scene.n);\n    }\n    \n    pc =  mix(pc, skyColour, mint / FAR); //fog\n    pc *= sin(((fragCoord.xy / iResolution.xy).y + T * 0.05) * 800.0) * 0.2 + 0.8;\n    \n    fragColor = vec4(pc*3.0, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define LOOP_LENGTH 60.0\n#define T mod(iTime, LOOP_LENGTH)\n#define PI 3.141592\n\nstruct CubeIntersection {\n    float tN;\n    float tF;\n    vec3 nN;\n    vec3 nF;\n};\n    \nmat2 rot(float x) {return mat2(cos(x), sin(x), -sin(x), cos(x));}   \n\n//neat trick from Shane\nvec2 nearest(vec2 a, vec2 b){ \n    float s = step(a.x, b.x);\n    return s * a + (1. - s) * b;\n}\n\n//IQ Distance functions\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n  return length(p) - s;\n}\n\nfloat sdConeSection(vec3 p, float h, float r1, float r2) {\n    float d1 = -p.y - h;\n    float q = p.y - h;\n    float si = 0.5 * (r1 - r2) / h;\n    float d2 = max(sqrt(dot(p.xz, p.xz) * (1.0 - si * si)) + q * si - r2, q);\n    return length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xy) - t.x, p.z);\n    return length(q) - t.y;\n}\n\n//mercury sdf\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat smin(float a, float b, float k) {\n\t//float k = 32.0;\n\t//float res = exp( -k*a ) + exp( -k*b );\n    //return -log( res )/k;\n    //float k = 0.1;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// see mercury sdf functions\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.0 * PI / repetitions;\n    float a = atan(p.y, p.x) + angle / 2.0;\n    float r = length(p);\n    float c = floor(a / angle);\n    a = mod(a, angle) - angle / 2.0;\n    p = vec2(cos(a), sin(a)) * r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions / 2.0)) c = abs(c);\n    return c;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa,ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\n//Sphere and Box functions from IQ\nfloat planeIntersection(vec3 ro, vec3 rd, vec3 n, vec3 o) {\n    return dot(o - ro, n) / dot(rd, n);\n}\n\nCubeIntersection cubeIntersection(vec3 ro, vec3 rd, vec3 boxSize) {\n    \n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs(m) * boxSize;\n\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n\n    //miss\n    if (tN > tF || tF < 0.0) return CubeIntersection(0.0, 0.0, vec3(0.0), vec3(0.0));\n\n    vec3 nN = -sign(rd) * step(t1.yzx, t1.xyz) * step(t1.zxy, t1.xyz);\n    vec3 nF = -sign(rd) * step(t2.xyz, t2.yzx) * step(t2.xyz, t2.zxy); \n\n    return CubeIntersection(tN, tF, nN, nF);\n} \n\nfloat sphIntersect(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    return -b - sqrt(h);\n}\n\nfloat sphDensity(vec3 ro, vec3 rd, vec4 sph, float dbuffer) {\n    float ndbuffer = dbuffer / sph.w;\n    vec3  rc = (ro - sph.xyz) / sph.w;\n    float b = dot(rd, rc);\n    float c = dot(rc, rc) - 1.0;\n    float h = b * b - c;\n    if (h < 0.0) return 0.0;\n    h = sqrt(h);\n    float t1 = -b - h;\n    float t2 = -b + h;\n    if (t2 < 0.0 || t1 > ndbuffer) return 0.0;\n    t1 = max(t1, 0.0);\n    t2 = min(t2, ndbuffer);\n    float i1 = -(c * t1 + b * t1 * t1 + t1 * t1 * t1 / 3.0);\n    float i2 = -(c * t2 + b * t2 * t2 + t2 * t2 * t2 / 3.0);\n    return (i2 - i1) * (3.0 / 4.0);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Created by SHAU - 2017\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------------------------\n\n#define N_PATH_POINTS 63\n\n/* CAMERA */\n\n//Dave Hoskins - Pylon \n//https://www.shadertoy.com/view/XltSRf\n//Catmull-rom spline\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t) {    \n    vec3 c2 = -0.5 * p0\t+  0.5 * p2;\n\tvec3 c3 =        p0\t+ -2.5 * p1 +  2.0 * p2 + -0.5 * p3;\n    vec3 c4 = -0.5 * p0\t+  1.5 * p1 + -1.5 * p2 +  0.5 * p3;\n    return(((c4 * t + c3) * t + c2) * t + p1);\n}\n\nvoid positionsAtTime(inout vec3 cameraPosition, \n                     inout vec3 lookAtPosition) {\n    \n    //initialise camera arrays\n    //number of positions must be +3 number of seconds that loop plays\n    vec3 cameraPath[N_PATH_POINTS];\n    cameraPath[0]  = vec3(  100.0, -40.0, -150.0);\n    cameraPath[1]  = vec3(  95.0,  -38.0, -140.0);\n    cameraPath[2]  = vec3(  90.0,  -36.0, -130.0);\n    cameraPath[3]  = vec3(  85.0,  -34.0, -120.0);\n    cameraPath[4]  = vec3(  80.0,  -32.0, -110.0);\n    cameraPath[5]  = vec3(  75.0,  -30.0, -100.0);\n    cameraPath[6]  = vec3(  70.0,  -28.0, -90.0);\n    cameraPath[7]  = vec3(  65.0,  -26.0, -80.0);\n    cameraPath[8]  = vec3(  60.0,  -24.0, -70.0);\n    cameraPath[9]  = vec3(  55.0,  -22.0, -60.0);\n    cameraPath[10] = vec3(  50.0,  -21.0, -50.0);\n    cameraPath[11] = vec3(  45.0,  -20.0, -40.0);\n    cameraPath[12] = vec3(  40.0,  -20.0, -30.0);\n    cameraPath[13] = vec3(  35.0,  -20.0, -20.0);\n    cameraPath[14] = vec3(  30.0,  -20.0, -10.0);\n    cameraPath[15] = vec3(  25.0,  -20.0,  0.0);\n    cameraPath[16] = vec3(  20.0,  -21.0,  10.0);\n    cameraPath[17] = vec3(  15.0,  -22.0,  20.0);\n    cameraPath[18] = vec3(  10.0,  -24.0,  30.0);\n    cameraPath[19] = vec3(  0.0,   -27.0,  40.0);\n    cameraPath[20] = vec3( -10.0,  -31.0,  50.0);\n    cameraPath[21] = vec3( -20.0,  -36.0,  50.0);\n    cameraPath[22] = vec3( -30.0,  -41.0,  50.0);\n    cameraPath[23] = vec3( -40.0,  -47.0,  45.0);\n    cameraPath[24] = vec3( -40.0,  -52.0,  40.0);\n    cameraPath[25] = vec3( -30.0,  -57.0,  30.0);\n    cameraPath[26] = vec3( -20.0,  -62.0,  20.0);\n    cameraPath[27] = vec3( -10.0,  -67.0,  10.0);\n    cameraPath[28] = vec3(  0.0,   -72.0,  0.0);\n    cameraPath[29] = vec3(  10.0,  -76.0, -10.0);\n    cameraPath[30] = vec3(  20.0,  -78.0, -20.0);\n    cameraPath[31] = vec3(  30.0,  -80.0, -30.0);\n    cameraPath[32] = vec3(  35.0,  -79.0, -40.0);\n    cameraPath[33] = vec3(  30.0,  -78.0, -50.0);\n    cameraPath[34] = vec3(  25.0,  -76.0, -55.0);\n    cameraPath[35] = vec3(  20.0,  -74.0, -58.0);\n    cameraPath[36] = vec3(  15.0,  -70.0, -60.0);\n    cameraPath[37] = vec3(  10.0,  -66.0, -60.0);\n    cameraPath[38] = vec3(  5.0,   -62.0, -60.0);\n    cameraPath[39] = vec3(  0.0,   -58.0, -60.0);\n    cameraPath[40] = vec3( -5.0,   -54.0, -60.0);\n    cameraPath[41] = vec3( -10.0,  -50.0, -60.0);\n    cameraPath[42] = vec3( -15.0,  -45.0, -60.0);\n    cameraPath[43] = vec3( -18.0,  -40.0, -60.0);\n    cameraPath[44] = vec3( -20.0,  -35.0, -60.0);\n    cameraPath[45] = vec3( -18.0,  -30.0, -60.0);\n    cameraPath[46] = vec3( -16.0,  -25.0, -60.0);\n    cameraPath[47] = vec3( -12.0,  -20.0, -60.0);\n    cameraPath[48] = vec3( -8.0,   -15.0, -60.0);\n    cameraPath[49] = vec3( -4.0,   -10.0, -60.0);\n    cameraPath[50] = vec3(  0.0,   -9.0,  -60.0);\n    cameraPath[51] = vec3(  5.0,   -8.0,  -60.0);\n    cameraPath[52] = vec3(  10.0,  -7.0,  -60.0);\n    cameraPath[53] = vec3(  15.0,  -6.0,  -60.0);\n    cameraPath[54] = vec3(  20.0,  -5.0,  -60.0);\n    cameraPath[55] = vec3(  25.0,  -4.0,  -59.0);\n    cameraPath[56] = vec3(  30.0,  -3.0,  -58.0);\n    cameraPath[57] = vec3(  35.0,  -2.0,  -56.0);\n    cameraPath[58] = vec3(  40.0,  -1.0,  -52.0);\n    cameraPath[59] = vec3(  40.0,   0.0,  -48.0);\n\n    cameraPath[60] = vec3(  40.0,   0.0,  -44.0);\n    cameraPath[61] = vec3(  40.0,   0.0,  -42.0);\n    cameraPath[62] = vec3(  40.0,   0.0,  -40.0);\n    \n    vec3 lookAtPath[N_PATH_POINTS];\n    lookAtPath[0]  = vec3(  10.0,  -50.0,  2000.0);\n    lookAtPath[1]  = vec3(  10.0,  -50.0,  1900.0);\n    lookAtPath[2]  = vec3(  10.0,  -50.0,  1800.0);\n    lookAtPath[3]  = vec3(  10.0,  -50.0,  1700.0);\n    lookAtPath[4]  = vec3(  10.0,  -50.0,  1600.0);\n    lookAtPath[5]  = vec3(  10.0,  -50.0,  1500.0);\n    lookAtPath[6]  = vec3(  10.0,  -50.0,  1400.0);\n    lookAtPath[7]  = vec3(  10.0,  -50.0,  1300.0);\n    lookAtPath[8]  = vec3(  10.0,  -50.0,  1200.0);\n    lookAtPath[9]  = vec3(  10.0,  -50.0,  1100.0);\n    lookAtPath[10] = vec3(  10.0,  -50.0,  1000.0);\n    lookAtPath[11] = vec3(  10.0,  -50.0,  900.0);\n    lookAtPath[12] = vec3(  10.0,  -50.0,  800.0);\n    lookAtPath[13] = vec3(  10.0,  -50.0,  700.0);\n    lookAtPath[14] = vec3(  10.0,  -50.0,  600.0);\n    lookAtPath[15] = vec3(  10.0,  -50.0,  500.0);\n    lookAtPath[16] = vec3(  10.0,  -50.0,  450.0);\n    lookAtPath[17] = vec3(  10.0,  -50.0,  400.0);\n    lookAtPath[18] = vec3(  10.0,  -50.0,  350.0);\n    lookAtPath[19] = vec3(  10.0,  -50.0,  300.0);\n    lookAtPath[20] = vec3(  10.0,  -50.0,  250.0);\n    lookAtPath[21] = vec3(  10.0,  -50.0,  200.0);\n    lookAtPath[22] = vec3(  10.0,  -50.0,  150.0);\n    lookAtPath[23] = vec3(  10.0,  -50.0,  100.0);\n    lookAtPath[24] = vec3(  10.0,  -50.0,  50.0);\n    lookAtPath[25] = vec3(  10.0,  -50.0,  0.0);\n    lookAtPath[26] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[27] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[28] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[29] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[30] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[31] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[32] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[33] = vec3(  10.0,  -50.0, -20.0);\n    lookAtPath[34] = vec3(  10.0,  -49.0, -20.0);\n    lookAtPath[35] = vec3(  10.0,  -48.0, -20.0);\n    lookAtPath[36] = vec3(  10.0,  -47.0, -20.0);\n    lookAtPath[37] = vec3(  10.0,  -45.0, -20.0);\n    lookAtPath[38] = vec3(  10.0,  -43.0, -20.0);\n    lookAtPath[39] = vec3(  10.0,  -41.0, -20.0);\n    lookAtPath[40] = vec3(  10.0,  -39.0, -20.0);\n    lookAtPath[41] = vec3(  10.0,  -37.0, -20.0);\n    lookAtPath[42] = vec3(  10.0,  -35.0, -20.0);\n    lookAtPath[43] = vec3(  10.0,  -33.0, -20.0);\n    lookAtPath[44] = vec3(  10.0,  -31.0, -20.0);\n    lookAtPath[45] = vec3(  10.0,  -29.0, -20.0);\n    lookAtPath[46] = vec3(  10.0,  -27.0, -20.0);\n    lookAtPath[47] = vec3(  10.0,  -25.0, -20.0);\n    lookAtPath[48] = vec3(  10.0,  -23.0, -20.0);\n    lookAtPath[49] = vec3(  10.0,  -21.0, -20.0);\n    lookAtPath[50] = vec3(  10.0,  -19.0, -20.0);\n    lookAtPath[51] = vec3(  10.0,  -17.0, -20.0);\n    lookAtPath[52] = vec3(  10.0,  -15.0, -20.0);\n    lookAtPath[53] = vec3(   9.0,  -13.0, -20.0);\n    lookAtPath[54] = vec3(   8.0,  -11.0, -20.0);\n    lookAtPath[55] = vec3(   7.0,  -9.0,  -20.0);\n    lookAtPath[56] = vec3(   6.0,  -7.0,  -20.0);\n    lookAtPath[57] = vec3(   5.0,  -6.0,  -20.0);\n    lookAtPath[58] = vec3(   5.0,  -5.0,  -20.0);\n    lookAtPath[59] = vec3(   5.0,  -5.0,  -20.0);\n\n    lookAtPath[60] = vec3(   5.0,  -5.0,  -20.0);\n    lookAtPath[61] = vec3(   5.0,  -5.0,  -20.0);\n    lookAtPath[62] = vec3(   5.0,  -5.0,  -20.0);\n        \n    int nt = int(T);\n    float ft = fract(T);\n    \n    vec3 p0 = cameraPath[nt];\n    vec3 p1 = cameraPath[nt + 1];\n    vec3 p2 = cameraPath[nt + 2];\n    vec3 p3 = cameraPath[nt + 3];\n    \n    cameraPosition = spline(p0, p1, p2, p3, ft);\n    \n    p0 = lookAtPath[nt];\n    p1 = lookAtPath[nt + 1];\n    p2 = lookAtPath[nt + 2];\n    p3 = lookAtPath[nt + 3];\n\n    lookAtPosition = spline(p0, p1, p2, p3, ft);    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    fragColor = vec4(0.0, 0.0, 1.0, 1.0);\n    \n    vec3 lightColour = vec3(1.0, 0.0, 0.0);\n    if (T > 4.0) lightColour = vec3(1.0, 0.5, 0.0);\n    if (T > 34.0) lightColour = vec3(0.0, 1.0, 0.0);\n    \n    float shipRotation = T * step(T, PI * 10.0);\n    shipRotation += step(38.0, T) * step(T, 38.0 + PI * 3.0) * sin(T - 38.0) * 0.08;\n    shipRotation += sin(T * 0.5) * 0.06;\n    float gla = step(20.0, T) * -min((T - 20.0) * 0.1, 0.5);\n    float gua = step(25.0, T) * min((T - 25.0) * 0.05, 0.5);\n    gua -= step(48.0, T) * min((T - 48.0) * 0.05, 0.16);\n    \n    gua -= step(33.0, T) * step(T, 33.0 + PI * 2.0) * max(sin(T - 33.0) * 0.3, 0.0);\n    float gma = step(33.0, T) * step(T, 33.0 + PI * 2.0) * sin(T - 33.0) * 0.5;\n    \n    vec3 cameraPosition, lookAtPosition;\n    positionsAtTime(cameraPosition, lookAtPosition);\n    \n    if (int(fragCoord.y) == 0) {\n        if (int(fragCoord.x) == 0) {\n            fragColor = vec4(cameraPosition, 1.0);\n        } else if (int(fragCoord.x) == 1) {\n            fragColor = vec4(lookAtPosition, 1.0);\n        } else if (int(fragCoord.x) == 2) {\n            fragColor = vec4(shipRotation, gla, gua, gma);\n        } else if (int(fragCoord.x) == 3) {\n            fragColor = vec4(lightColour, 1.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"}]}