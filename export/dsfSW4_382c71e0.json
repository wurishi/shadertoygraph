{"ver":"0.1","info":{"id":"dsfSW4","date":"1668964125","viewed":173,"name":"Shiny Blue Tunnel","username":"onlinerocker","description":"IDK what this is but looks cool","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","tunnel","sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Set cheap to 1 to use Torus for rings, which will run much faster.\n#define CHEAP 1\n#define PI 3.14159265359\n\n// polynomial smooth min from IQ\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n//fog from IQ\nvec3 applyFog( in vec3  rgb,\n               in float d )\n{\n    float fogAmount = 1.0 - exp( -d*0.02 );\n    vec3  fogColor  = vec3(0.5,0.6,0.7);\n    return mix( rgb, fogColor, fogAmount );\n}\n\n//Modfied torus (to make size not uniform)\nfloat sdTorus( vec3 p, vec2 t )\n{\n    float a = atan(p.y/p.x);\n    vec2 q = vec2((length(p.xy))-t.x,p.z);\n    return length(q)-(t.y - 0.25*sin(a*10.));\n}\n\nvec2 rot( vec2 p, float a )\n{\n    float co = cos(a);\n    float si = sin(a);\n    return mat2(co,-si,si,co) * p;\n}\n\nvec4 map(vec3 pos, out int id)\n{\n    vec3 realPos = pos;\n    vec3 col = vec3(0.0);\n    float rad = 1.0;\n    float mind = 100.0;\n    \n    mind = -abs(pos.x) + 10.0*textureLod(iChannel0, vec2(iTime/500.0,0) + realPos.yz/100.0, 0.).x - -25.0;\n    if(abs(mind) < 0.01)\n    {\n        col = vec3(0.1,0,1);\n        col *= 0.5;\n        id = 0;\n    }\n    \n    float x = cos(floor((pos.z) / 20.0))*14.0;\n    float y = sin(floor((pos.z) / 20.0))*10.0;\n    float zang = cos(floor((pos.z) / 20.0))*10.0;\n    pos.x -= x;\n    pos.y -= y;\n    pos.z = -10.0 + mod(pos.z, 20.0);\n\n    float realZ = realPos.z - 10.0;\n    realPos.z = mod(realPos.z, 1.0);\n    realPos.x -= cos(realZ / 20.0)*14.0;\n    realPos.y -= sin(realZ / 20.0)*10.0;\n    realPos.xy = abs(realPos.xy);\n    vec3 v = realPos - vec3(5.0, 3.0, 0.5);\n    float dPipes = sminCubic(mind, length(v) - 0.5, 1.0); //distance to sphere pipes\n    realPos.z /= 10.0;\n    v = realPos - vec3(2, 4.0, 0.05);\n    dPipes = sminCubic(dPipes, length(v) - 0.1, 1.0); //thin pipes\n    if(dPipes < mind)\n    {\n        mind = dPipes;\n        col = vec3(0,1,3)* (1.5 + 0.5*sin(realZ/5.0 + 5.0*iTime));\n        id = 1;\n    }\n\n    pos.yz = rot(pos.yz, -(PI/8.0) * sign(zang));\n    pos.xz = rot(pos.xz, (PI/8.0) * sign(y));\n    pos.xy = rot(pos.xy, PI/10.0 * iTime);\n    \n#if CHEAP>0\n    mind = sminCubic(mind, sdTorus(pos, vec2(5., 1.0)), 3.5);\n#else\n    for(int i = 0; i < 10; ++i)\n    {\n            \n        vec3 p = vec3(5.0, 0, 0.0);\n        vec3 v = pos - p;\n        float dRing = sminCubic(mind, length(v) - rad, 3.5); //distance to rings\n        if(dRing < mind)\n        {\n          mind = dRing;\n          col = vec3(0,1,3)* (1.5 + 0.5*sin(realZ/5.0 + 5.0*iTime));\n          id = 2;\n        }\n            \n        pos.xy = rot(pos.xy, PI/5.0);\n    }\n#endif\n\n    return vec4(mind, col);\n}\n\nvec3 moveCam(out vec3 fwd)\n{\n    float z = 10.0+(-iTime) * 10.0;\n    float x = cos((z - 10.0) / 20.0)*14.0;\n    float y = sin((z - 10.0) / 20.0)*10.0;\n    \n    vec3 pos = vec3(x, y, z);\n    fwd = normalize(vec3(cos((z + 10.0) / 20.0)*14.0, sin((z + 10.0) / 20.0)*10.0, z + 20.0) - pos);\n   \n    return pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.0 - iResolution.xy) / iResolution.y;\n    vec3 fwd = vec3(0);\n    vec3 camPos = moveCam(fwd);\n    vec3 r = normalize(cross(fwd, vec3(0,1,0)));\n    vec3 u = normalize(cross(r, fwd));\n    vec3 dir = normalize((r * uv.x) + (u * uv.y) + vec3(0,0,-1));\n    vec3 col = vec3(0, 0, 0.2);\n    vec3 pos = camPos;\n    vec3 n   = vec3(0);\n    bool hit = false;\n    float rad = 1.0;\n    int id = -1;\n    \n    \n    for(int i = 0; i < 128; ++i)\n    {\n        vec4 dc = map(pos, id);\n        float d = dc.x;\n        \n        if(abs(d) <= 0.01)\n        {\n            col = dc.yzw;\n            int dummy = 0;\n            float h = 0.01;\n            vec2 hv = vec2(h, 0);\n            n = normalize(vec3(map(pos + hv.xyy, dummy).x - d, map(pos + hv.yxy, dummy).x - d, map(pos + hv.yyx, dummy).x - d));\n            hit = true;\n            break;\n        }\n          \n        pos += dir * d * 0.9;\n    }\n\n    // Output to screen\n    col = hit && id != 0 ? col * texture(iChannel1, reflect(n, dir)).rgb : n*col;\n    col = applyFog(col, length(pos- camPos));\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}