{"ver":"0.1","info":{"id":"4sfyzN","date":"1487186596","viewed":787,"name":"Residual Background Radiation?","username":"marquizzo","description":"Learned how to make my own cellular noise function, thanks to The Book of Shaders. \nAlso a fan of Contact, so I made this in honor of Ellie Arroway. \nClick and drag for parallax effect.","likes":24,"published":1,"flags":0,"usePreview":0,"tags":["2d","noise","random","cell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define HASHSCALE3 vec3(443.897, 441.423, 437.195)\n#define PI 3.14159265\n#define OCTAVES 4.0\n\n// Color transform from HSB to RGB\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n// rotate position around axis\nvec2 rotate(vec2 p, float a){\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n// Hash without sine from:\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// Cell noise learned from:\n// https://thebookofshaders.com/12/\nfloat cell(vec2 x, float t){\n\tvec2 iPos = floor(x); // Cell integer position\n\tvec2 fPos = fract(x); // Cell fraction position\n\tfloat minDist1 = 2.0; // Stores minimum distance\n\n\t// Calculate neighboring cells\n\tfor(int y = -1; y <= 1; y ++){\n\t\tfor(int x = -1; x <= 1; x ++){\n\t\t\tvec2 neighborCell = vec2(x, y);\n\t\t\tvec2 randPoint = hash22(iPos + neighborCell);\n\t\t\t\n\t\t\t// Animate point\n\t\t\trandPoint = 0.5 + sin(t + randPoint * 2.0 * PI) * 0.5;\n\n\t\t\tvec2 fPosToPoint = neighborCell + randPoint - fPos;\n\n\t\t\t// Pick distance algorithm\n\t\t\tfloat dist = length(fPosToPoint);\t// Euclidean\n\t\t\t// float dist = max(abs(fPosToPoint.x), abs(fPosToPoint.y));\t// Chebyshev\n\t\t\t// float dist = abs(fPosToPoint.x) + abs(fPosToPoint.y);\t\t// Manhattan\n\t\t\t\n\t\t\t// Keep smallest distance\n\t\t\tminDist1 = min(dist, minDist1);\n\t\t}\n\t}\n\n\treturn minDist1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t// Screen position\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\t// Mouse position\n\tvec2 m = 1.0 - vec2(iMouse.xy / iResolution.xy);\n\n\t// Adjust view ratio + rotation\n\tvec2 pos = vec2(p.x * iResolution.x / iResolution.y, p.y);\n\tpos = rotate(pos, (m.x + m.y) * 0.1);\n\n\t// Store cell noise in brighness\n\tfloat brightness = 0.0;\n    \n    // Calculate cell noise\n\tfor(float i = 1.0; i <= OCTAVES; i++){\n\t\tbrightness += cell(pos - (m * 8.0), iTime * 0.5 * i) / i;\n\t\tpos *= OCTAVES;\n\t}\n\n\t// Square for contrast\n\tbrightness *= brightness;\n\t\n\tfloat hue = distance(p, m) * 0.2 + 0.5;\n\tfragColor = vec4(hsb2rgb(vec3(hue, 0.5, brightness)), 1.0);\n}","name":"Image","description":"","type":"image"}]}