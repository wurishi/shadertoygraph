{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"\n\n// Helpers.\n\nfloat square(float x) {\n\treturn x * x;\n}\n\n\n// Distance field tools.\n\nfloat sdSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n\treturn dot(p, n.xyz) + n.w;\n}\n\nfloat join(float a, float b) { return min(a, b); }\nfloat carve(float a, float b) { return max(a, -b); }\nfloat intersection(float a, float b) { return max(a, b); }\n\n\n\n// Scene definition.\n\nfloat distanceField(vec3 p) {\n\tfloat sphere1 = sdSphere(p - vec3( 1.50, -1.0, 1.20), 1.8);\n    float sphere2 = sdSphere(p - vec3(-1.00,  0.0, 0.80), 1.8);\n    float sphere3 = sdSphere(p - vec3(0.50,  0.5, 0.80), 0.8);\n\tfloat box = sdBox(p - vec3(0.0, 0.0, 0.0), vec3(3.5, 2.0, 1.0));\n\tfloat plane = sdPlane(p, vec4(0.0, 1.0, 0.0, 1.0));\n\treturn join(carve(carve(carve(box, sphere1), sphere2), sphere3), plane);\n}\n\n\n\n\n// Raymarching tools.\n\nvec3 getRayDir(vec3 cameraDir, vec2 screenPos) {\n\tvec3 planeU = vec3(1.0, 0.0, 0.0);\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n\treturn normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n}\n\nfloat getDistance(vec3 rayPos, vec3 rayDir) {\n\tfloat rayDist = 0.0;\n\tfloat totalDist = 0.0;\n\tfor (int i = 0; i < 64; i++) {\n\t\trayDist = distanceField(rayPos);\n\t\tif (rayDist < 0.01) break;\n\t\trayPos += rayDist * rayDir;\n\t\ttotalDist += rayDist;\n\t}\n\treturn totalDist;\n}\n\nvec3 getNormal(vec3 hitPos) {\n\tconst float derivDist = 0.00001;\n\tconst float derivDist2 = 2.0 * derivDist;\n\tfloat x = hitPos.x;\n\tfloat y = hitPos.y;\n\tfloat z = hitPos.z;\n\tvec3 surfaceNormal;\n\tsurfaceNormal.x = distanceField(vec3(x + derivDist, y, z)) \n\t\t\t\t\t- distanceField(vec3(x - derivDist, y, z));\n\tsurfaceNormal.y = distanceField(vec3(x, y + derivDist, z)) \n\t\t\t\t\t- distanceField(vec3(x, y - derivDist, z));\n\tsurfaceNormal.z = distanceField(vec3(x, y, z + derivDist)) \n\t\t\t\t\t- distanceField(vec3(x, y, z - derivDist));\n\tsurfaceNormal = normalize(surfaceNormal / derivDist2);\n\treturn surfaceNormal;\n}\n\n\n\n// lighting\n\nfloat positionalLight(vec4 light, vec3 hitPos) {\n\treturn light.w * inversesqrt (0.001 + length(light.xyz - hitPos));\n}\n\nfloat directionalLight(vec4 light, vec3 normal) {\n\tvec3 lightDir = normalize(light.xyz);\n\treturn light.w * dot(lightDir, normal);\n}\n\nfloat allLight(vec4 light, vec3 hitPos, vec3 normal) {\n\treturn 1.0 * positionalLight(light, hitPos) + 0.0 * directionalLight(light, normal);\n}\n\nvec3 tonemap(vec3 linear, float scale) {\n\tvec3 x = linear * scale;\n\tx = max(vec3(0), x - 0.004);\n\tvec3 pre_gamma = (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n    vec3 post_gamma = pow(pre_gamma, vec3(1.0/2.2));\n\treturn post_gamma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = 0.25 * iTime;\n\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraPos = vec3(0.0, 2.0, 4.0);\n\n    cameraPos += vec3(0.0, 0.0, 1.0) * sin(3.0 * time);\n    cameraPos += vec3(0.0, 1.9, 0.0) * cos(2.0 * time);\n    cameraPos += vec3(5.0, 0.0, 0.0) * cos(1.0 * time);\n\t\n\tvec3 cameraTgt = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraDir = -normalize(cameraPos - cameraTgt);\n    vec3 rayDir = getRayDir(cameraDir, screenPos);\n\n\tfloat hitDist = getDistance(cameraPos, rayDir);\n\tvec3 hitPos = cameraPos + hitDist * rayDir;\n\t\n\tvec2 baseUV = vec2(hitPos.xy + hitPos.yz);\n\tvec2 albedoUV = 0.05 * baseUV;\n    vec2 normalMapUV = 0.55 * baseUV;\n\n\t\n    vec3 albedo = 0.2 * texture(iChannel0, albedoUV).xyz;\n\tvec3 normal = getNormal(hitPos);\n    normal += texture(iChannel1, normalMapUV).xyz;\n\n\tvec4 light1 = vec4( -200.00,   100.00,     50.00,  1.0);\n\tvec4 light2 = vec4( -250.00, 10000.00, 100000.00,  10.0);\n\n\tvec3 ambient = 0.0 * vec3(0.001, 0.001, 0.002);\n\n\tfloat diffuse = 0.0;\n\tfloat specular = 0.0;\n\tdiffuse += allLight(light1, hitPos, normal);\n\tdiffuse += allLight(light2, hitPos, normal);\n\n    vec3 final_linear = ambient + albedo * diffuse + vec3(specular);\t\n\tvec3 post_gamma = tonemap(final_linear, 1.0);\n\n\tfragColor = vec4(post_gamma,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"ld23RV","date":"1391354957","viewed":274,"name":"My first filmic rendering","username":"winden","description":"Trying to make a scene with realistic light flow, by using linear-scale lighting then tonemapping back to screen. Is missing specular right now, tho.\n\nMany parts of the scaffolding code are from https://www.shadertoy.com/view/XslGRS -- thanks!\n","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","filmic"],"hasliked":0,"parentid":"","parentname":""}}