{"ver":"0.1","info":{"id":"Mfs3W2","date":"1703580068","viewed":23,"name":"Raymarching with Proximal Planes","username":"atelesfor","description":"Quick proof of concept of fast(er) raymarching convex SDFs.\nIf the object is convex, we can march the ray all the way to the intersection with a proximal plane, \ni.e. any plane that separates us from the object at its nearest point to us.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct Camera {\n    vec3 pos;\n    vec3 center;\n    vec3 up;\n    vec3 left;\n};\n\nstruct Ray {\n    vec3 pos;\n    vec3 dir;\n};\n\nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec3 col;\n};\n\nstruct Plane {\n    vec3 center;\n    vec3 normal;\n    vec3 col;\n};\n\nfloat sdf(const Sphere S, Ray ray) {\n    return distance(S.center,ray.pos) - S.radius;\n}\n\n// (Distance to) Proximal Plane function / Sphere\nfloat ppf(const Sphere S, Ray ray) {\n    const float min_dot = .01;\n    float dist = sdf(S,ray);\n    float dirgrad = dot(normalize(ray.pos-S.center), ray.dir);\n    return dist/clamp(-dirgrad, min_dot, 1.);\n}\n\nfloat sdf(const Plane P, Ray ray) {\n    return dot(ray.pos - P.center, P.normal);\n}\n\n// (Distance to) Proximal Plane function / Plane\nfloat ppf(const Plane P, Ray ray) {\n    const float min_dot = .01;\n    float dist = sdf(P,ray);\n    float dirgrad = dot(P.normal, ray.dir);\n    return dist/clamp(-dirgrad, min_dot, 1.);\n}\n\nconst int no_spheres = 3;\nconst Sphere spheres[no_spheres] = Sphere[no_spheres](\n    Sphere(vec3(5.,0.,0.), 2., vec3(1.,0.,0.)),\n    Sphere(vec3(8.,2.,0.), 4., vec3(0.,1.,0.)),\n    Sphere(vec3(9.,-6.5,0.), 2., vec3(0.,0.,1.))\n    );\n    \nconst Plane backg = Plane(vec3(20.,0.,0.), vec3(-1.,0.,0.), vec3(1.,1.,1.));\n   \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = 2.*fragCoord/iResolution.xy - 1.;\n    \n\n    // Raymarch with sdf/ppf\n    const Camera camera = Camera(\n        vec3(0.,0.,0.),\n        vec3(1.,0.,0.),\n        vec3(0.,2.,0.),\n        vec3(0.,0.,4.)\n    );\n    vec3 pos = camera.center + uv.x*camera.left + uv.y*camera.up;\n    Ray ray = Ray(pos,normalize(pos-camera.pos));\n    //Ray ray = Ray(pos,vec3(1.,0.,0.));\n    \n    const float fps = 2.;\n    const int max_iters = 50;\n    for (int iter=0; iter<int(fps*iTime)%max_iters; iter++) {\n        float L = ppf(backg, ray);\n        for (int i=0; i<no_spheres; i++) {\n            float L_sph;\n            if (uv.x<0.) {\n                L_sph = ppf(spheres[i], ray);\n            } else {\n                L_sph = sdf(spheres[i], ray);\n            }\n            L = min(L,L_sph);\n        }\n        \n        ray.pos += ray.dir * L;\n    }\n    \n    \n    // Render with softmin\n    const float render_h = .1;\n    float L = sdf(backg, ray);\n    float F = exp(-L/render_h);\n    float F_tot = F;\n    vec3 col = F*backg.col;\n    for (int i=0; i<no_spheres; i++) {\n        L = sdf(spheres[i], ray);\n        F = exp(-L/render_h);\n        F_tot += F;\n        col += F*spheres[i].col;\n    }\n    col /= F_tot;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}