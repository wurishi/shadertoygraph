{"ver":"0.1","info":{"id":"Wljfzt","date":"1599629719","viewed":69,"name":"Pixel Locator","username":"AltusCreates","description":"(EPILEPSY WARNING)\nThis is intended for use with point capture camera modules, such as monitor calibration or LDAT devices, to ascertain the exact pixels visible to the camera.","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["utility"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n/*\n\nA tool for determining the visible pixels of a point light capture device on a digital display\n\nThis is intended for use with point capture camera modules,\nsuch as monitor calibration or LDAT devices,\nto ascertain the exact pixels visible to the camera.\n\nInspired by GamersNexus\nhttps://www.youtube.com/watch?v=0SZ7ZCac38A\n\nThe locator functions are spread across three ideas\n\n   1. It is possible to identify the position of any pixel purely by their output, \n\t  in as few frames as the number of bits in the smallest binary integer capable of representing the resolution of both axis\n\t  (24 for 4k, 26 for 8k)\n\n   2. If the sensor sees many pixels and cannot tell them apart,\n      it is possible to get slightly better resolution by inverting the test pattern and contrasting the two images\n\n   3. Pixels are often made up of three or four sub pixels,\n      being able to identify which exact sub-pixels the sensor is picking up may be useful \n\nBy running this animation into the sensor,\nthe resulting data-log should have all the data necessary to compute\nthe precise coordinates of the sensor relative to the edges of the screen\n\nIf the algorithms used to calculate the location of the sensor\nare aware of the size and optical characteristics of the sensor,\nit should also be able to calculate the exact dimensions of the screen\n\nThis can be used to generate and overlay for video captured of the source,\nsuch that an audience can see the exact pixels and sub-pixels the sensor is picking up on\n\nIt may even be run multiple times to validate that the sensor did not move from the \nbegining to the end of what ever other testing it was used in.\n\nThe pattern is dictated by code in mainimage\n\nOverview:\n\t\n\tMedium Blank\n\n\tBright Blank\n\n\tHorizontal binary integer blinking\n\n\tBright Blank\n\n\tVertical binary integer blinking\n\n\tBright Blank\n\t\n\tWhite pixel visibility sweep\n\n\tBright Blank\n\n\tRed sub-pixel visibility sweep\n\n\tBright Blank\n\n\tGreen sub-pixel visibility sweep\n\n\tBright Blank\n\n\tBlue sub-pixel visibility sweep\n\n\tBright Blank\n\t\n\tMedium Blank\n\n\nPixel visibility sweep:\n\n\t\n\tThis is a test based on representing the pixels visible to the camera as a function of time.\n\n\tThe time spent waiting for the camera to detect a pixel, relative to the total length of the test,\n\trepresents its position relative to the left or top of the screen\n\n\tThe time spent waiting for the camera to stop detecting a pixel from the time it started, relative to the total length of the test,\n\trepresents the percentage of the pixels visible to the camera.\n\n\tThe time spent waiting for the test to end, relative to when the camera stopped detecting input,\n\trepresents the position relative to the right or bottom of the screen\n\n\tIf black frames are used, it's also possible to count the total number of pixels visible to the camera\n\n\nBinary integer blinking:\n\n\tThis is a test based on representing numbers as flashes of light.\n\n\tEach flash denotes a successive bit in the integer representation of that pixels position,\n\tstarting with the most significant\n\n\tEach flash is followed by an \"inverted\" flash of that same bit.\n\tThis is done so the camera can identify how much \n\tof each representation it is detecting when multiple pixels are visible\n\n\tBy contrasting the values of the normal relative to the inverted,\n\tit can be roughly determined how many pixels are visible to the camera.\n\t\n\tWhen middle (grey) value contrasts are detected in the more significant bit flashes,\n\tthe contrast can be used to identify the edges of large overlapping regions that the camera is capturing\n\n\tAs the bit significance decreases, if the contrasts picked up shift toward undetectable (0.5 vs 0.5),\n\tthat indicates the sensors detection area is roughly the size of that number of pixels. \n\t(2 to the power of the remaining number of bits)\n\n\nConversion of binary flashs to integer numbers\n\n    The camera will pick up on one to two blinks per bit.\n\n    The bits should be ordered from left to right, \n    most significant to least significant, \n    as the following comma seperated values \n    1,    2,    3,    4,   5,   6,   7,  8,  9,  10  11, 12, 13\n\n    The value of each bit is 2 to the power of its position relative to the end of the series,\n    a group of fourteen bits would then be valued as \n    4096, 2048, 1024, 512, 256, 128, 64, 32, 16, 8,  4,  2,  1\n\n    By adding together the values of the bits that the camera saw a blink for, \n    the resulting sum represents the value of that pixel from the top or left of the screen\n\n    Each bit is represented by two blinks, this is done to determine how many pixels the camera is detecting at once\n\n    For those cases where the camera picked up both blinks at different levels, \n    it is possible to use those contrasts to determine the placement of the visual area relative to those visable pixels\n\n    If some of the bits blinks are indistinguishable from eachother, \n    the camera receives aproximately the same amount of light for both flashes,\n    this indicates that the camera is able to perceive multiple pixels of a number somewhere between\n    the values of 2 to the power of the indistiguishable bit count, \n    to 2 to the power off the indistinguishable bit count minus 1\n\n    An example signal processing\n\n    Time    : 1   , 2   , 3   , 4   , 5   , 6   , 7   , 8   , 9   , 10  , 11  , 12  , 13\n\n    Blink 1 : 0.90, 0.05, 0.04, 0.04, 0.03, 0.02, 0.01, 0.01, 0.47, 0.50, 0.50, 0.50, 0.50\n\n    Blink 2 : 0.10, 0.95, 0.96, 0.96, 0.97, 0.98, 0.99, 0.99, 0.53, 0.50, 0.50, 0.50, 0.50\n\n    Binary 1: 1   , 0   , 0   , 0   , 0   , 0   , 0   , 0   , 0.47, -   , -   , -   , - \n\n    Binary 2: 0   , 1   , 1   , 1   , 1   , 1   , 1   , 1   , 0.53, -   , -   , -   , -\n\n    Integer 1: 4096 + ( (0.5 - 0.47) x 16) = 4096.48\n\n    Integer 2: 2048 + 1024 + 512 + 256 + 128 + 64 + 32 + ( (0.5 - 0.53) x 16) = 4063.52\n\n    I believe the example would indicate the camera is detecting input from the above range of pixels,\n    given that output, the camera would be roughly to the right of center of a 8k display\n\nResources for learning to convert integers to binary and back\n\n\thttps://www.ntu.edu.sg/home/ehchua/programming/java/datarepresentation.html\n\thttps://www.exploringbinary.com/binary-converter/\n\n*/\n\n\n// ASCII Gen by http://patorjk.com/software/taag/\n\n\n// ██████╗ ██████╗ ███╗   ██╗███████╗██╗ ██████╗ \n//██╔════╝██╔═══██╗████╗  ██║██╔════╝██║██╔════╝ \n//██║     ██║   ██║██╔██╗ ██║█████╗  ██║██║  ███╗\n//██║     ██║   ██║██║╚██╗██║██╔══╝  ██║██║   ██║\n//╚██████╗╚██████╔╝██║ ╚████║██║     ██║╚██████╔╝\n// ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═╝     ╚═╝ ╚═════╝ \n       \n\n\n\n#define InitialDelayInFrames 300\n\n// Bright blank\n\n#define BrightFrames 45\n\n#define BlankFrameBeforeBright 10\n\n#define BlankFrameAfterBright 10\n\n// Binary flashes\n//\n// Default values are high so humans can see it\n\n#define HoldFrames 30\n\n#define InvertFrames 10\n\n#define BlackFrames 20\n\n// Pixel sweeps\n\n#define SweepHoldFrames 1\n\n#define SweepBlackFrames 1\n\n// Colours\n                         \n\nconst vec3 colour_FULL = vec3(1.0);\nconst vec3 colour_HALF = vec3(0.5);\nconst vec3 colour_OFF = vec3(0.0);\nconst vec3 colour_SubPixel1 = vec3(1.0,0.0,0.0);\nconst vec3 colour_SubPixel2 = vec3(0.0,1.0,0.0);\nconst vec3 colour_SubPixel3 = vec3(0.0,0.0,1.0);\n\nconst vec3 colour_END = vec3(0.25,0.25,0.25);\n\nconst vec3 colour_UNSET = vec3(-1.0,-1.0,-1.0);\n    \n\n//\n//███████╗██╗   ██╗██████╗ ██████╗  ██████╗ ██╗   ██╗████████╗██╗███╗   ██╗███████╗███████╗\n//██╔════╝██║   ██║██╔══██╗██╔══██╗██╔═══██╗██║   ██║╚══██╔══╝██║████╗  ██║██╔════╝██╔════╝\n//███████╗██║   ██║██████╔╝██████╔╝██║   ██║██║   ██║   ██║   ██║██╔██╗ ██║█████╗  ███████╗\n//╚════██║██║   ██║██╔══██╗██╔══██╗██║   ██║██║   ██║   ██║   ██║██║╚██╗██║██╔══╝  ╚════██║\n//███████║╚██████╔╝██████╔╝██║  ██║╚██████╔╝╚██████╔╝   ██║   ██║██║ ╚████║███████╗███████║\n//╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝  ╚═════╝    ╚═╝   ╚═╝╚═╝  ╚═══╝╚══════╝╚══════╝\n                                                                                         \n\nint headerAnimation(in int frame, inout vec3 colour, in ivec2 resBits, in ivec2 pos, vec3 on, vec3 off){\n    int len = BrightFrames;\n    \n    if (frame < len)\n        if (frame < BlankFrameBeforeBright) {\n            colour = off;\n        }\n        else if (frame < BlankFrameBeforeBright + BrightFrames) {\n            colour = on;\n        }\n        else if (frame < BlankFrameBeforeBright + BrightFrames + BlankFrameAfterBright) { // black frame\n            colour = off;\n        }\n    \n\treturn len;\n}\n\nint powi2(int x) {\n\treturn 1 << x;\n}\n\nvec3 BinaryDecide(int currentBit, int x, int BitLength, vec3 on, vec3 off){\n    \n    int stage = powi2(BitLength-currentBit);\n    \n    int stagepos = x % (stage * 2);\n    \n    if (stagepos < stage) \n        return off;\n    \n    return on;\n}\n\nint Binary(in int frame, inout vec3 colour, int resBits, in int x, vec3 on, vec3 inverted, vec3 off){\n    \n    const int BinaryAnimFrameLength = HoldFrames + BlackFrames + InvertFrames + BlackFrames; // duration of each frame pattern\n    \n    int BinaryAnimLength = BinaryAnimFrameLength * resBits;\n\n    \n    if (frame < BinaryAnimLength) {\n        \n        int loopFrame = frame % BinaryAnimFrameLength;\n\n        int currentBit = ((frame - loopFrame) / BinaryAnimFrameLength) + 1;\n        \n        if (loopFrame < HoldFrames) { // hold pattern\n            colour = BinaryDecide(currentBit, x, resBits, on, off);\n        }\n        else if (loopFrame < HoldFrames + BlackFrames) { // black frame\n            colour = off;\n        }\n        else if (loopFrame < HoldFrames + BlackFrames + InvertFrames) { // inverse pattern\n            colour = BinaryDecide(currentBit, x, resBits, off, inverted);\n        }\n        else if (loopFrame < HoldFrames + BlackFrames + InvertFrames + BlackFrames) { // black frame\n            colour = off;\n        }\n    }\n    \n    return BinaryAnimLength;\n}\n\nint Sweep(int frame, out vec3 colour, int resolution, int x, vec3 on, vec3 off){\n    \n    const int SweepAnimFrameLength = SweepHoldFrames + SweepBlackFrames; // duration of each frame pattern\n    \n    int SweepAnimLength = resolution * SweepAnimFrameLength;\n\n    \n    if (frame < SweepAnimLength) {\n        \n        int loopFrame = frame % SweepAnimFrameLength;\n        \n        int position = (frame - loopFrame) / SweepAnimFrameLength;\n        \n        if (loopFrame < SweepHoldFrames) { // hold pattern\n            colour = (position == x) ? on : off;\n        }\n        else if (loopFrame < SweepHoldFrames + SweepBlackFrames) { // black frame\n            colour = off;\n        }\n\n        \n    }\n    \n    return SweepAnimLength;\n}\n\n//\n//███╗   ███╗ █████╗ ██╗███╗   ██╗\n//████╗ ████║██╔══██╗██║████╗  ██║\n//██╔████╔██║███████║██║██╔██╗ ██║\n//██║╚██╔╝██║██╔══██║██║██║╚██╗██║\n//██║ ╚═╝ ██║██║  ██║██║██║ ╚████║\n//╚═╝     ╚═╝╚═╝  ╚═╝╚═╝╚═╝  ╚═══╝\n                                \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    \n\t// Store nearest power of 2, as large or larger than each dimension of the viewport\n\tivec2 resBits;\n    \n    resBits.x = int(ceil(log2(iResolution.x)));\n    resBits.y = int(ceil(log2(iResolution.y)));\n    \n    ivec2 pos = ivec2(fragCoord.xy);\n    pos.y = int(iResolution.y - fragCoord.y);\n    \n    vec3 colour = colour_UNSET;\n    \n    int eFOCA = 0; // EndFrameOfCurrentAnimation\n    \n    eFOCA += InitialDelayInFrames; // adding to this makes a gap in the animation counted in frames\n    \n    //  ██████╗ ██╗███╗   ██╗ █████╗ ██████╗ ██╗   ██╗\n    //  ██╔══██╗██║████╗  ██║██╔══██╗██╔══██╗╚██╗ ██╔╝\n    //  ██████╔╝██║██╔██╗ ██║███████║██████╔╝ ╚████╔╝ \n    //  ██╔══██╗██║██║╚██╗██║██╔══██║██╔══██╗  ╚██╔╝  \n    //  ██████╔╝██║██║ ╚████║██║  ██║██║  ██║   ██║   \n    //  ╚═════╝ ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝  ╚═╝   ╚═╝   \n    //                                                \n    // BINARY\n    \n\t// blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // horizontal white/black black/white binary pattern\n    if(iFrame >= eFOCA)\n        eFOCA +=  Binary(iFrame-eFOCA, colour, resBits.x, pos.x, colour_FULL, colour_FULL, colour_OFF);\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // vertical white/black black/white binary pattern\n    if(iFrame >= eFOCA)\n        eFOCA +=  Binary(iFrame-eFOCA, colour, resBits.y, pos.y, colour_FULL, colour_FULL, colour_OFF);\n    \n    //  ███████╗██╗    ██╗███████╗███████╗██████╗ ███████╗\n    //  ██╔════╝██║    ██║██╔════╝██╔════╝██╔══██╗██╔════╝\n    //  ███████╗██║ █╗ ██║█████╗  █████╗  ██████╔╝███████╗\n    //  ╚════██║██║███╗██║██╔══╝  ██╔══╝  ██╔═══╝ ╚════██║\n    //  ███████║╚███╔███╔╝███████╗███████╗██║     ███████║\n    //  ╚══════╝ ╚══╝╚══╝ ╚══════╝╚══════╝╚═╝     ╚══════╝\n    //                                                    \n    // SWEEPS\n    \n    // White pixel/sub-pixel sweeps\n    \n    // bright blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // horizontal sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.x), pos.x, colour_FULL, colour_OFF);\n    \n    // medium blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // vertical sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.y), pos.y, colour_FULL, colour_OFF);\n    \n    \n    \n    // colourour Sub-pixel sweeps\n    \n    \n    // Sub-Pixel 1 : RED\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // vertical sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.y), pos.y, colour_SubPixel1, colour_OFF);\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // horizontal sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.x), pos.x, colour_SubPixel1, colour_OFF);\n    \n    \n    // Sub-Pixel 2 : GREEN\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // vertical sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.y), pos.y, colour_SubPixel2, colour_OFF);\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // horizontal sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.x), pos.x, colour_SubPixel2, colour_OFF);\n    \n    \n    // Sub-Pixel 3 : BLUE\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // vertical sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.y), pos.y, colour_SubPixel3, colour_OFF);\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    // horizontal sweep pattern\n    if(iFrame >= eFOCA)\n        eFOCA += Sweep(iFrame-eFOCA, colour, int(iResolution.x), pos.x, colour_SubPixel3, colour_OFF);\n    \n    // blank\n    if(iFrame >= eFOCA)\n        eFOCA += headerAnimation(iFrame-eFOCA, colour, resBits, pos, colour_FULL, colour_OFF);\n    \n    \n    // End\n    \n    if (colour == colour_UNSET)\n        colour = colour_END;\n    \n    fragColor.rgb = colour;\n}","name":"Image","description":"","type":"image"}]}