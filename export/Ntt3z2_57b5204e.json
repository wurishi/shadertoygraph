{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\n\n\tInspired by Coding Train coding challenge #102 Water Ripple\n\t\n*/\n\n/*\n\tKeep mousebutton pressed and move around...\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t/*\n\t\tBecause we intend to read from a texture and map to the entire window,\n\t\twe need to scale both our coordinates to map from the range [0 to 1]\n\t*/\n    vec2 uv = fragCoord.xy / iResolution.xy ;\n    \n    /*\n\t\tHere we read the data from Buffer A through iChannel0.\n\t\tThe first parameter of texture is the texture,\n\t\tthe second parameter is where in the texture we sample from.\n\t*/\n    vec4 color = texture(iChannel0, uv);\n        \n    \n    /*\n\t\tAnd here the final color is returned!\n\t\tCheck out the 'Buffer A' tab for the rest of the code.\n\t*/\n\tfragColor = vec4(color.xyz, 1.0);\n    \n}\n\n\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"/*\n\tThis is where the results of the rules are computed.\n\tThe reason it is computed here and not in the Image-tab\n\tis because we need to access the previous state of the simulation.\n\tThis is exactly what we can do by taking the output of the buffer\n\tas a texture input. Therefore, when we read from render buffer A \n\tin iChannel0, we can look up the state of any pixel/cell from the \n    previous frame.\n*/\n/************************************/\n//Try DAMPENING = 0.999 or 0.999 for cool patterns\nconst float DAMPENING = 0.99;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*\n\t\tAgain, we need to access the texture using coordinates in the range [0, 1]\n\t*/\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    /*\n\t\tRead the values from the neighbors\n\t\t _ _ _\n\t\t| |#| |             , [0, -1], \n\t\t|#|X|#|  =  [-1,  0], current, [1,  0],\n\t\t|_|#|_|             , [0,  1], \n\n\t\t\n\t*/ \n    /*\n\t\tUsing a temporary variable for the output value for clarity.\n\t\tit is just passed to fragColor at the end of the function.\n\t*/\n    float waveValue = 0.0;\n    \n    /* The values from the last image (or buffer) are stored in the x-component*/\n        \n    /* Look north */\n    float i = 0.0;\n    float j = -1.0;\n    vec2 offset = vec2(i,j) / iResolution.xy;\n    vec4 lookup = texture(iChannel0, uv + offset);\n    waveValue += lookup.x;\n    \n    /* Look south */\n    j = 1.0;\n    offset = vec2(i,j) / iResolution.xy;\n    lookup = texture(iChannel0, uv + offset);\n    waveValue += lookup.x;\n          \n    /* Look left */\n    j = 0.0;\n    i = -1.0;\n    offset = vec2(i,j) / iResolution.xy;\n    lookup = texture(iChannel0, uv + offset);\n    waveValue += lookup.x;\n    \n    /* Look right */\n    i = 1.0;\n    offset = vec2(i,j) / iResolution.xy;\n    lookup = texture(iChannel0, uv + offset);\n    waveValue += lookup.x;\n\n    //Reduce impact from neighbors, divide by 2.\n    waveValue = waveValue / 2.0;\n    \n    /* Instead of using two buffers,\n       I use the y-component to store the really old value*/    \n    lookup = texture(iChannel0, uv);\n    float oldValue = lookup.y;\n    float currValue = lookup.x;\n    waveValue -= oldValue;\n    \n    waveValue *= DAMPENING;\n    \n    vec3 color = vec3(0.0);\n\n    //Let the mouse position create new waves. \n    vec2 m = iMouse.xy;\n    if (length(m.xy-fragCoord.xy) < 4.0){\n        color += vec3(1.0);\n    }\n    else{\n        color = vec3(waveValue);\n    }\n    //Save the current x-value to y-component\n    color.y = currValue;\n    //This also creates a cool color-effect.\n    \n    /* Experiment with start image, not that cool\n    if (iTime < 0.5){\n        color = texture(iChannel1,uv).xyz;\n    }\n    */\n    fragColor = vec4(color,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"Ntt3z2","date":"1636379693","viewed":180,"name":"Jonix buffer water ripple","username":"Hultsborn10","description":"A water ripple effect created with buffers. Inspired by Coding Train: Coding Challenge #102\nKlick with mouse or hold mousebutton and move mouse on the canvas.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["waterrippleeffectbuffer"],"hasliked":0,"parentid":"","parentname":""}}