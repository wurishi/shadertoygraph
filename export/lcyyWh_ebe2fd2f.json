{"ver":"0.1","info":{"id":"lcyyWh","date":"1731865968","viewed":120,"name":"SDF 3D tanchiki","username":"donerfornothing","description":"Yo wtf","likes":8,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarching","sdf","playable"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define epsilon 0.001\n\n//Important: the author is a computer graphics student and not an especially bright one. For my fellow dummies out there\n// i will be adding comments to this code. The experienced guys can also read them for fun or to have a look into the mind \n// of a noob. \n\n// CONTROLS: WASD - move the gun; SPACE shoots the gun. You can only shoot once you see a yellow circle in the corner. \n//           ARROWS move the tank; C - enter the scope mode;\n\nfloat opSU( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat circ2d( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat get_scope(in vec2 p)\n{\n    float c1 = - circ2d(p, 0.9f);\n    float c2 = circ2d(p, 0.03f);\n    float c = min(c1, c2);\n    float d = sdBox(p, vec2(0.9, 0.01));\n    return min(c, d);\n}\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nmat2 r2d(float t)\n{\n    float sn = sin(t);\n    float cs = cos(t);\n    return mat2(cs, -sn, sn, cs);\n}\n\nfloat sd_sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat sd_box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sd_rbox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b + r;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sd_cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat get_floor(in vec3 p)\n{\n    float plain = p.y + 2.0;\n    return plain;\n}\n\nfloat sd_tanktower(in vec3 p, in vec3 tankpos, bool playable)\n{   \n    float plat = sd_cyl(p - vec3(.0, 0.9, 0.0), 0.4, 0.8);\n    \n    float k = texelFetch(iChannel0, ivec2(0, 0), 0).y;\n    if (playable)\n    {\n        p.yz *= r2d(k);\n    }\n    float gun = sd_box(p - vec3(0.0, 1.0, 1.0), vec3(0.3, 0.2, 0.9));\n\n    return min(plat, gun);\n}\n\nfloat sd_tank(in vec3 p)\n{\n    vec3 tankpos_a = texelFetch(iChannel0, ivec2(8, 0), 0).xyz;\n    float move_angle = texelFetch(iChannel0, ivec2(7, 0), 0).x;\n    \n    vec3 tank_offc = vec3(1.0, -1.45, 0.0);\n    vec3 tankpos = p - tankpos_a;\n    tankpos.xz *= r2d(move_angle);\n    float tankass = sd_box(tankpos, vec3(1.0, 0.5, 2.0));\n    float cat1 = sd_rbox(tankpos - vec3(0.9, -0.02, 0.), vec3(0.3, 0.7, 2.1), 0.2);\n    float cat2 = sd_rbox(tankpos - vec3(-0.9, -0.02, 0.), vec3(0.3, 0.7, 2.1), 0.2);\n    \n    float tankbody = min(tankass, min(cat1, cat2));\n    \n    float t = texelFetch(iChannel0, ivec2(0, 0), 0).x;\n    vec3 ptt = p;\n    \n    ptt -= tankpos_a;\n    ptt.xz *= r2d(t); //ROTATE THE GUN AROUND Y AXIS\n    float tanktower = sd_tanktower(ptt, tankpos, true);\n    \n    \n    return min(tanktower, tankbody);\n}\n\nfloat sd_tank_npc(in vec3 p)\n{\n    vec3 tank_offc = vec3(1.9, -1.45, 9.0);\n    vec3 tankpos = p - tank_offc;\n    tankpos.xz *= r2d(0.7);\n    float tankass = sd_box(tankpos, vec3(1.0, 0.5, 2.0));\n    float cat1 = sd_rbox(tankpos - vec3(0.9, -0.02, 0.), vec3(0.3, 0.7, 2.1), 0.2);\n    float cat2 = sd_rbox(tankpos - vec3(-0.9, -0.02, 0.), vec3(0.3, 0.7, 2.1), 0.2);\n    \n    float tankbody = min(tankass, min(cat1, cat2));\n    \n    p -= tank_offc;\n    p.xz *= r2d(3.4);\n    float tanktower = sd_tanktower(p, tankpos, false);\n    \n    return min(tanktower, tankbody);\n}\n\nfloat SCENE(in vec3 pos)\n{\n    \n    vec3 bullet_vec = texelFetch(iChannel0, ivec2(1, 0), 0).xyz;\n    vec3 bullet_pos = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\n    \n    float bullet = sd_sphere(pos - bullet_pos, 0.2);\n    float fl = get_floor(pos) + noise(pos.xz) / 14.;\n    \n   \n    \n    float tank = sd_tank(pos);\n    float enemy_tank = sd_tank_npc(pos); \n    vec3 crater_pos = texelFetch(iChannel0, ivec2(5, 0), 0).xyz;\n\n    float crater = sd_sphere(pos - crater_pos, 1.9) -  noise(pos.xz) / 2.;\n    \n    return min(bullet, min(max(fl, -crater), min(tank, enemy_tank)));\n}\n\nvec3 enorm(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    float r = 1.; // radius of sphere\n    return normalize(\n      e.xyy * SCENE(p + e.xyy) +\n      e.yyx * SCENE(p + e.yyx) +\n      e.yxy * SCENE(p + e.yxy) +\n      e.xxx * SCENE(p + e.xxx));\n}\n\nvec3 get_color(in vec3 pos, in float d)\n{\n    vec3 bullet_pos = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\n    \n    vec3 floor_color = vec3(0.75,0.64,0.29);\n    vec3 sphere_color = vec3(1, 0.58, 0.29);\n    vec3 tank_color = vec3(0.43,0.55,0.19);\n    vec3 npctank_color = vec3(0.32,0.55,0.62);\n    \n    vec3 final_color;\n    if (d == sd_sphere(pos - bullet_pos, 0.2))\n    {\n        final_color = sphere_color;\n    }\n    else if(d >= get_floor(pos) + noise(pos.xz) / 14.)\n    {\n        final_color = floor_color;\n    }\n    else if (d == sd_tank(pos))\n    {\n        final_color = tank_color;\n    }\n    else if (d == sd_tank_npc(pos))\n    {\n        final_color = npctank_color;\n    }\n    return final_color;\n}\nfloat get_shadow(in vec3 p, in vec3 lp)\n{\n    vec3 ld = normalize(lp - p);\n    vec3 sp;\n    float dist = 0.0; \n    float d = 0.01;\n    for(int i = 0; i <= 100; i++)\n    {\n        dist += d;\n        sp = p + ld * dist;\n        d = SCENE(sp);\n        \n        \n        if(d < epsilon)\n        {\n            return 0.7;\n        }\n        else if (d >= 60.)\n        {\n            return 1.;\n        }       \n    }\n    return 1.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // MOVEMENT\n    float move_angle = texelFetch(iChannel0, ivec2(7, 0), 0).x;\n    vec2 aim_angle = texelFetch(iChannel0, ivec2(0, 0), 0).xy;\n    vec3 tankpos = texelFetch(iChannel0, ivec2(8, 0), 0).xyz;\n    vec3 tank_offc = vec4(1.0, -1.45, 0.0, 0.).xyz - tankpos;\n\n\n    //COLORS\n    vec3 backgr_color = vec3(0.77,0.90,0.89);\n    vec3 light_color  = vec3(1.00,0.95,0.67);\n    \n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = (2.0f * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 bp = texelFetch(iChannel0, ivec2(2, 0), 0).xyz;\n    bool shell_it = (bp == vec3(-1.0, -4.0, 0.3));\n    \n    //2D BULLET INDICATOR\n    float bullet = circ2d(uv - vec2(1.3, -0.8), 0.1);\n    \n    \n    //IMPORTANT THINGS\n    vec3 color; \n    vec3 ray_s = vec3(0.0, 0.0, -4.0); // FROM HERE THE RAYS GO\n    \n    vec3 ray_dir = normalize(vec3(uv, 1.0)); // SO THAT OUR RAYS GO THROUGH EACH PIXEL\n    vec3 l_pos = vec3(5.0, 9.0, -5.0); // LIGHT POS\n    float dist = 0.0; // DISTANCE TRAVELLED BY A RAY\n    float max_dist = 100.0;\n    \n    //MOUSE CONTROL \n    vec2 mouse = (2.0f * iMouse.xy - iResolution.xy) / iResolution.y;\n    if (texelFetch(iChannel1, ivec2(67, 0), 0).x != 0.f)\n    {\n        vec3 ofc = vec3(1., -0.3, 6.8);  \n        \n        ray_s += ofc;\n        ofc.xz *= r2d(-aim_angle.x);\n        ray_s.yz *= r2d(-aim_angle.y);\n        ray_dir.yz *= r2d(-aim_angle.y);      \n        ray_s.xz *= r2d(-aim_angle.x);\n        ray_dir.xz *= r2d(-aim_angle.x);\n            \n\n    }\n    else\n    {\n    //y axis\n    ray_s.yz *= r2d(-mouse.y);\n    ray_dir.yz *= r2d(-mouse.y);\n    //x axis\n    ray_s.xz *= r2d(-mouse.x);\n    ray_dir.xz *= r2d(-mouse.x);\n    }\n    ray_s.xz -= tank_offc.xz;\n\n    // RAY MARCHING BEGINS\n    vec3 pos;\n    float d;\n    float occl;\n    for (int i = 0; i <= 150; i++)\n    {\n        pos = ray_s + ray_dir * dist; // AT WHICH POINT OF 3D SPACE ARE WE NOW?\n        \n        d = SCENE(pos); // JUST A GOOD OL' SDF\n       \n        dist += d;\n             \n        if(d < epsilon || dist >= 100.0)\n        {\n            occl = smoothstep(1.0, 800.0, float(i));\n            break;\n        }\n    }\n    \n    // RAY MARCHING HAS ENDED. WHAT NOW?\n   \n    if (dist > max_dist)\n    {\n        color = backgr_color;\n    }\n    else\n    {\n        vec3 norm = enorm(pos);\n        vec3 l_dir = normalize(l_pos - pos); // LIGHT DIRECTION\n        vec3 color_a = get_color(pos, d) ;     \n        float dif = clamp(dot(norm, l_dir), 0.2, 1.0);\n        \n        color = (dif * color_a * light_color + backgr_color * 0.2) * 1.2 + backgr_color * (get_shadow(pos, l_pos) - 1.) / light_color ;\n      \n    }\n    // Output to screen\n    fragColor = vec4(color,1.0);\n    float scope = get_scope(uv);\n    if (texelFetch(iChannel1, ivec2(67, 0), 0).x != 0.f)\n    {\n        ray_s -= vec3(1.);\n        if(scope <= 0.)\n        {\n            fragColor = vec4( 0.);\n        }\n\n    }\n    \n    if(shell_it && bullet <= 0.)\n    {\n        fragColor = vec4(vec3(0.68,0.59,0.04), 0.);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat2 r2d(float t)\n{\n    float sn = sin(t);\n    float cs = cos(t);\n    return mat2(cs, -sn, sn, cs);\n}\n\nvoid save_at_ivec(in ivec2 desired_pos, in vec4 data, inout vec4 fragColor, in ivec2 current_pos)\n{\n    fragColor = (desired_pos.x==current_pos.x && desired_pos.y==current_pos.y ) ? data : fragColor;\n}\n\n//Hell no, I'm not gonna create a struct, let's just fire the same sphere over an over again and then return it back under the sand\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int a_key = 65;\n    const int d_key = 68;\n    const int w_key = 87;\n    const int s_key = 83;\n    const int space_key = 32;\n    \n    const int up = 38;\n    const int down = 40;\n    const int left = 37;\n    const int right = 39;\n    \n    const float move_speed = 0.01f;\n    vec4 just_shot = texelFetch(iChannel0, ivec2(4, 0), 0);\n    vec4 is_flying = texelFetch(iChannel0, ivec2(3, 0), 0);\n    vec4 gravity = vec4(0., -3.1, 0., 0.);\n    vec4 prev_time = texelFetch(iChannel0, ivec2(0, 2), 0);\n    vec4 flytime = texelFetch(iChannel0, ivec2(0, 3), 0);\n    //\n    vec4 forward = texelFetch(iChannel0, ivec2(6, 0), 0);\n    vec4 move_angle = texelFetch(iChannel0, ivec2(7, 0), 0);\n    vec4 tankpos = texelFetch(iChannel0, ivec2(8, 0), 0);\n    vec4 speed = texelFetch(iChannel0, ivec2(0, 1), 0);\n    const float acc = 0.0001;\n    const float max_speed = 0.028;\n    const float fricc = 0.0002;\n    const float ts = 0.004;\n    \n    //\n    vec4 angle = texelFetch(iChannel0, ivec2(0, 0), 0);\n    vec4 bullet_vec = texelFetch(iChannel0, ivec2(1, 0), 0);\n    vec4 bullet_pos = texelFetch(iChannel0, ivec2(2, 0), 0);\n    vec4 crater_pos = texelFetch(iChannel0, ivec2(5, 0), 0);\n\n    if(iFrame == 1)\n    {\n        bullet_vec = vec4(0., 0., 1., 0.);\n        bullet_pos = vec4(-1.0, -4.0, 0.3, 0.0);\n        forward = vec4(0., 0., 1., 0.);\n        tankpos = vec4(1.0, -1.45, 0.0, 0.);\n        move_angle.x = 0.;\n        \n        just_shot.x = 0.0;\n        is_flying.x = 0.0;\n        flytime.x = 0.;\n\n        \n    } \n\n    if(texelFetch(iChannel1, ivec2(d_key, 0), 0).x != 0.f)\n    {\n        angle.x += move_speed;\n    }\n    else if (texelFetch(iChannel1, ivec2(a_key, 0), 0).x != 0.f)\n    {\n        angle.x -= move_speed;\n    }\n    if(texelFetch(iChannel1, ivec2(w_key, 0), 0).x != 0.f && angle.y < 0.3)\n    {\n        angle.y += move_speed;\n    }\n    else if (texelFetch(iChannel1, ivec2(s_key, 0), 0).x != 0.f && angle.y > 0.)\n    {\n        angle.y -= move_speed;\n    }\n    if (texelFetch(iChannel1, ivec2(space_key, 0), 0).x != 0.f && bullet_pos == vec4(-1.0, -4.0, 0.3, 0.0))\n    {\n        just_shot.x = 1.0;\n        \n        bullet_vec.yz = vec4(0., 0., 1., 0.).yz * r2d(-angle.y);\n        bullet_vec.xz = vec4(0., 0., 1., 0.).xz * r2d(-angle.x);\n    }\n    \n    // TANK MOVEMENT\n    if(texelFetch(iChannel1, ivec2(up, 0), 0).x != 0.f)\n    {\n        if (speed.x < max_speed)\n        {\n            speed.x += acc;\n        }\n        \n    }\n    else if (texelFetch(iChannel1, ivec2(down, 0), 0).x != 0.f)\n    {\n        if (speed.x > -max_speed)\n        {\n            speed.x -= acc;\n        }\n    }\n    else\n    {\n        if (speed.x > 0.)\n        {\n            speed.x -= fricc;\n        }\n        if(speed.x < 0.)\n        {\n            speed.x += fricc;\n        }\n    }\n    tankpos += forward * speed.x;\n    if(texelFetch(iChannel1, ivec2(left, 0), 0).x != 0.f)\n    {\n        move_angle.x -= ts;\n    }\n    else if (texelFetch(iChannel1, ivec2(right, 0), 0).x != 0.f)\n    {\n        move_angle.x += ts;\n    }\n    forward.xz = vec4(0., 0., 1., 0.).xz * r2d(-move_angle.x);\n//\n    if(is_flying.x == 1.0)\n    {\n        // This is how you can do it recurrently:\n        // 1. vel = ...\n        // 2. vel += grav.dt\n        // 3. pos += vel * dt\n        // \n        flytime.x += iTimeDelta;\n        bullet_pos += bullet_vec * 0.3 + 0.5 * gravity * flytime.x * flytime.x; // but I just used a formula\n        \n        if (bullet_pos.y <= -2.0)\n        {\n            flytime.x = 0.;\n            crater_pos = bullet_pos;\n            is_flying.x = 0.f;\n            bullet_pos = vec4(-1.0, -4.0, 0.3, 0.0);\n        }\n        \n        if(length(bullet_pos) >= 100.)\n        {\n            flytime.x = 0.;\n            is_flying.x = 0.f;\n            bullet_pos = vec4(-1.0, -4.0, 0.3, 0.0);    \n        }\n        \n    }\n    \n    if(just_shot.x == 1.0)\n    {\n        vec3 to = tankpos.xyz ;\n       \n        bullet_pos = vec4(0.0 + to.x, -0.5, 0.0 + to.z, 0.0) ;\n        is_flying.x = 1.0;\n        just_shot.x = 0.0;\n    }\n    \n\n \n    ivec2 int_fc = ivec2(fragCoord);\n    save_at_ivec(ivec2(0, 0), angle, fragColor, int_fc);\n    save_at_ivec(ivec2(1, 0), bullet_vec, fragColor, int_fc);\n    save_at_ivec(ivec2(2, 0), bullet_pos, fragColor, int_fc);\n    save_at_ivec(ivec2(3, 0), is_flying, fragColor, int_fc);\n    save_at_ivec(ivec2(4, 0), just_shot, fragColor, int_fc);\n    save_at_ivec(ivec2(5, 0), crater_pos, fragColor, int_fc);\n    save_at_ivec(ivec2(6, 0), forward, fragColor, int_fc);\n    save_at_ivec(ivec2(7, 0), move_angle, fragColor, int_fc);\n    save_at_ivec(ivec2(8, 0), tankpos, fragColor, int_fc);\n    save_at_ivec(ivec2(0, 1), speed, fragColor, int_fc);\n    save_at_ivec(ivec2(0, 2), prev_time, fragColor, int_fc);\n    save_at_ivec(ivec2(0, 3), flytime, fragColor, int_fc);\n}","name":"Buffer A","description":"","type":"buffer"}]}