{"ver":"0.1","info":{"id":"mtyyWt","date":"1724961807","viewed":16,"name":"Raymarch 3.0","username":"zmcbeth","description":"test","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["test"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nfloat SDSphere(in vec3 worldCoordinate, in vec3 center, in float radius) {\n\n    return distance(worldCoordinate, center) - radius;\n\n}\n\nfloat SDPlane(in vec3 worldCoordinate, in float planeHeight, in vec3 rayDirection) {\n\n    return (worldCoordinate.y - planeHeight)/abs(rayDirection.y);\n\n}\n\nfloat SDOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\n\nfloat SDScene(in vec3 worldCoordinate, in vec3 rayDirection) {\n\n    float sphereOne = SDSphere(worldCoordinate, vec3(0.0, 0.0, 0.0), 0.5);\n    //float sphereTwo = SDSphere(worldCoordinate, vec3(cos(iTime/3.0), -0.3, sin(iTime/5.0)), 0.2);\n    //float sphereThree = SDSphere(worldCoordinate, vec3(sin(iTime/5.0), 0.3, cos(iTime/5.0)), 0.2);\n    float orbital = SDOctahedron(worldCoordinate - vec3(cos(iTime/2.0), -0.15, sin(iTime/2.0)), 0.2);\n    \n    float groundPlane = SDPlane(worldCoordinate, -0.5, rayDirection);\n\n    return min(min(sphereOne, orbital), groundPlane);\n\n}\n\n\n# define EPSILON 0.001\n\nvec3 estimateNormal(in vec3 worldCoordinate) {\n\n    if (worldCoordinate.y < -0.49) return vec3(0.0, 1.0, 0.0);\n\n    float partialX = SDScene(worldCoordinate + vec3(EPSILON, 0.0, 0.0), vec3(0.0, 0.0, 1.0)) - SDScene(worldCoordinate - vec3(EPSILON, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    float partialY = SDScene(worldCoordinate + vec3(0.0, EPSILON, 0.0), vec3(0.0, 0.0, 1.0)) - SDScene(worldCoordinate - vec3(0.0, EPSILON, 0.0), vec3(0.0, 0.0, 1.0));\n    float partialZ = SDScene(worldCoordinate + vec3(0.0, 0.0, EPSILON), vec3(0.0, 0.0, 1.0)) - SDScene(worldCoordinate - vec3(0.0, 0.0, EPSILON), vec3(0.0, 0.0, 1.0));\n    \n    return normalize(vec3(partialX, partialY, partialZ));\n\n}\n\n\n# define MAX_STEPS 105\n\nvec3 rayMarch(in vec3 rayOrigin, in vec3 rayDirection) {\n\n    vec3 ray = rayOrigin;\n\n    for (int index = 0; index < MAX_STEPS; index++) {\n   \n        float distanceToScene = SDScene(ray, rayDirection);\n        \n        if (distanceToScene < EPSILON) return ray;\n        \n        ray += distanceToScene * rayDirection;\n    \n    }\n    \n    return vec3(0.0, 0.0, 0.0);\n\n}\n\n\nvoid mainImage(out vec4 pixelColor, in vec2 pixelCoordinate) {\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    vec2 uv = pixelCoordinate/iResolution.xy;\n    \n    uv -= vec2(0.5, 0.5);\n    uv *= 2.0 * vec2(aspect, 1.0);\n    \n    vec3 observerPosition = vec3(0.0, 0.0, -5.0);\n    \n    vec3 cameraBox = observerPosition + vec3(uv, 5.0);\n    \n    vec3 rayDirection = normalize(cameraBox - observerPosition);\n    vec3 worldCoordinate = rayMarch(observerPosition, rayDirection);\n    \n    float renderable = length(worldCoordinate) > 0.0 ? 1.0 : 0.0;\n    \n    vec3 surfaceNormal = estimateNormal(worldCoordinate);\n    float fresnel = 0.9 + dot(surfaceNormal, rayDirection);\n    \n    vec3 lightSource = vec3(7.0 * cos(iTime), 5.0, 7.0 * sin(iTime));\n    \n    vec3 photonDirection = normalize(worldCoordinate - lightSource);\n    vec3 photonPosition = rayMarch(lightSource, photonDirection);\n    \n    float directLight = 1.2 - step(0.01, distance(photonPosition, worldCoordinate));\n    \n    float diffuseLight = 0.25 * smoothstep(0.0, 1.0, directLight * dot(surfaceNormal, -photonDirection));\n    \n    float ambientLight = 0.7;\n\n    float specularLight = 0.1 * smoothstep(0.0, 1.0, dot(reflect(photonDirection, surfaceNormal), normalize(observerPosition - worldCoordinate)));\n\n    float scatterFactor = 1.0 / sqrt(distance(worldCoordinate, lightSource)/5.0);\n\n    pixelColor = renderable * (diffuseLight + ambientLight + specularLight) * scatterFactor * vec4(1.0, 1.0, 1.0, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}