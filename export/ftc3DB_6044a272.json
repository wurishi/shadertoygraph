{"ver":"0.1","info":{"id":"ftc3DB","date":"1636604297","viewed":66,"name":"Just Another Ellipse Test ","username":"jmp","description":"Ellipse with thickness","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["ellipse"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"////////////////////////////////////////////////////////////////\n// https://iquilezles.org/articles/ellipsoids\n////////////////////////////////////////////////////////////////\nfloat sdbEllipsoidV1( in vec2 p, in vec2 r )\n{\n    float k1 = length(p/r);\n    return (k1-1.0)*min(r.x,r.y);\n}\n\nfloat sdbEllipsoidV2( in vec2 p, in vec2 r )\n{\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\n\n\n////////////////////////////////////////////////////////////////\n// https://dai.fmph.uniba.sk/upload/0/01/Ellipse.pdf\n////////////////////////////////////////////////////////////////\nfloat sdbEllipsoidV3( in vec2 p, in vec2 r )\n{\n    return min(1.0,(r.y*r.y * p.x*p.x) + (r.x*r.x * p.y*p.y) - (r.y*r.y * r.x*r.x));\n}\n\n////////////////////////////////////////////////////////////////\n// https://www.shadertoy.com/view/4sKXRV\n////////////////////////////////////////////////////////////////\n#define PI 3.1415927\nvec2 ClosestPointOnEllipse(vec2 p, vec2 ab)\n{\n\t//focal point of ellipse - either on x axis if a>b or y otherwise\n\tfloat c = ab.x > ab.y ? sqrt(ab.x*ab.x - ab.y*ab.y) : sqrt(ab.y*ab.y - ab.x*ab.x);\n\n\tfloat t = 0.;\n\tif (ab.y < ab.x && abs(p.x) < c)\n\t{\n\t\tt = p.y > 0. ? 0. * PI : -0.5 * PI;\n\t}\n\telse if (ab.x < ab.y && abs(p.y) < c)\n\t{\n\t\tt = p.x > 0. ? 0. : -PI;\n\t}\n\telse\n\t{\n\t\tt = atan(ab.x*p.y,ab.y*p.x);\n\t}\n\n\tfloat aa_bb = ab.x * ab.x - ab.y * ab.y;\n\tvec2 pab = p*ab;\n\tfor (int i=0; i<4; i++)\n\t{\n\t\tfloat sint = sin(t);\n\t\tfloat cost = cos(t);\n\t\tfloat ft = aa_bb * cost * sint - pab.x * sint + pab.y * cost;\n\t\tfloat dft = aa_bb * (cost * cost - sint * sint) - pab.x * cost - pab.y * sint;\n\n\t\tt = t - ft/dft;\n\t}\n\n\treturn vec2(cos(t),sin(t))*ab;\n}\n\nfloat sdEllipse(vec2 p, vec2 ab)\n{\n\tab = abs(ab);\n    p = -abs(p);\n\tvec2 closest = ClosestPointOnEllipse(p, ab);\n\n\tfloat dist = length(closest-p);\n\n\tvec2 poverab = p/ab;\n\tfloat inouttest = dot(poverab,poverab);\n\n\tif (inouttest < 1.) dist = -dist;\n\treturn dist;\n}\n\n\n\n////////////////////////////////////////////////////////////////\n// MAIN\n////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 r = vec2(iResolution.x,iResolution.y);\n    \n    vec3 input_color = vec3(1.0,0.0,1.0);\n    float thickness = 0.1;\n    float fade = 0.003;\n    \n    float aspect = r.x / r.y;\n    vec2 uv = fragCoord/r.xy * 2.0 - 1.0;\n    uv.x *= aspect;\n\n    float outer = sdbEllipsoidV2(vec2(uv), vec2(aspect, 1.0));\n    float inner = sdbEllipsoidV2(vec2(uv), vec2(aspect - thickness, 1.0 - thickness));\n    \n    float smooth_outer = smoothstep(-fade, fade, outer);\n    float smooth_inner = smoothstep(-fade, fade, inner);\n    \n    float ellipse_mask = smooth_inner - smooth_outer;    \n    \n    //fragColor = vec4(vec3(ellipse_mask), 1.0);\n    fragColor = vec4(vec3(ellipse_mask) * input_color, 1.0);\n    //fragColor = vec4(input_color, ellipse_mask); // Does not work!\n}\n","name":"Image","description":"","type":"image"}]}