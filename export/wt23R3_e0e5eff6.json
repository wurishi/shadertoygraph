{"ver":"0.1","info":{"id":"wt23R3","date":"1560560151","viewed":1053,"name":"Breakthrough","username":"dubu","description":"This scene was inspired by the intro to the music video Breakthrough by TWICE:\nhttps://www.youtube.com/watch?v=ZdKYi5ekshM\n\nEdit 2022-12-09: Updated colors and added AA\nEdit 2023-04-12: Removed AA","likes":39,"published":3,"flags":32,"usePreview":0,"tags":["raymarching","reflection","chromaticaberration","dof","ball","depthoffield","pbr","room","physicallybasedrendering","twice","breakthrough"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGR8","filepath":"/media/previz/buffer03.png","previewfilepath":"/media/previz/buffer03.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define DISPLAY_GAMMA 1.8\n#define USE_CHROMATIC_ABBERATION\n\nvec2 uvsToUv(vec2 uvs){\n    return uvs*vec2(iResolution.y/iResolution.x,1.0)+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (fragCoord.xy-iResolution.xy*.5)/iResolution.y;\n    \n    #ifdef USE_CHROMATIC_ABBERATION\n    vec3 color = vec3(0,0,0);\n   \tfloat ca = 0.003+0.0003*sin(t*1717.3)*cos(t);\n    color.x += texture(iChannel0, uvsToUv(uvs)).x*.66;\n    color.xy += texture(iChannel0, uvsToUv(uvs*(1.-1.*ca))).xy*.33;\n    color.y += texture(iChannel0, uvsToUv(uvs*(1.-2.*ca))).y*.33;\n    color.yz += texture(iChannel0, uvsToUv(uvs*(1.-3.*ca))).yz*.33;\n    color.z += texture(iChannel0, uvsToUv(uvs*(1.-4.*ca))).z*.66;\n    #else\n    vec3 color = texture(iChannel0, uvsToUv(uvs)).rgb;\n    #endif\n    \n    color = vec3(2.3,1.9,2.1)*color/(1.0+color);\n    \n  \tcolor *= 0.2 + 0.8 * saturate(pow(128. * uv.x * uv.y * (1.-uv.x) * (1.-uv.y), 0.2));\n    \n\tfragColor = vec4(pow(color,vec3((1.0)/(DISPLAY_GAMMA))),1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define t iTime\n\n#define PI 3.14159265\n#define TAU (2.*PI)\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n#define DOF_STRENGTH (0.1)\n#define DOF_THRESHOLD 0.5\n#define DOF_NUM_ITERATIONS 10.0\n\n// sane functions\nfloat saturate(float x){\n    return clamp(x,0.0,1.0);\n}\nfloat map(float value, float low1, float high1, float low2, float high2){\n\treturn low2 + (value - low1) * (high2 - low2) / (high1 - low1);\n}\n\n// Triplanar mapping\nvec3 BlendNormal(vec3 normal){\n\tvec3 blending = abs(normal);\n\tblending = normalize(max(blending, 0.00001));\n\tblending /= vec3(blending.x + blending.y + blending.z);\n\treturn blending;\n}\nvec3 TriplanarMapping (sampler2D tex, vec3 normal, vec3 position) {\n\tvec3 normalBlend = BlendNormal(normal);\n\tvec3 xColor = texture(tex, position.yz).rgb;\n\tvec3 yColor = texture(tex, position.xz).rgb;\n\tvec3 zColor = texture(tex, position.xy).rgb;\n\n  \treturn (xColor * normalBlend.x + yColor * normalBlend.y + zColor * normalBlend.z);\n}\n\n\n// SDF\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n#if 1\nfloat fBoxCheap(vec3 p, vec3 b) {\n\treturn vmax(abs(p) - b);\n}\n#else\nfloat fBoxCheap(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n#endif\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nstruct Hit{\n \tfloat d;\n    int ID;\n} _Hit;\n\nHit OpUnionHit(Hit a, Hit b){\n    if(a.d < b.d)return a;\n    return b;\n}\n\n\n// PBR\n#define PBR_EPSILON 1e-4\n\nstruct Material{\n    vec3 albedo;\n    vec3 metallic;\n    float roughness;\n} _Material;\n    \nstruct GeometricContext{\n    vec3 position;\n    vec3 normal;\n    vec3 viewDir;\n} _GeometricContext;\n\nstruct IncidentLight{\n\tvec3 direction;\n    vec3 color;\n    bool visible;\n} _IncidentLight;\n\nstruct PointLight{\n    vec3 position;\n    vec3 color;\n    float visibleDistance;\n    float decay;\n} _PointLight;\n\nstruct ReflectedLight{\n    vec3 directDiffuse;\n    vec3 directSpecular;\n    vec3 indirectDiffuse;\n    vec3 indirectSpecular;\n} _ReflectedLight;\n\n\nbool TestLightInRange(const in float lightDistance, const in float cutoffDistance){\n    return any(bvec2(cutoffDistance == 0.0, lightDistance < cutoffDistance));\n}\nfloat punctualLightIntensityToIrradianceFactor(const in float lightDistance,\n                                               const in float cutoffDistance,\n                                               const in float decayExponent){\n    if(decayExponent > 0.0){\n     \treturn pow(saturate(-lightDistance / cutoffDistance + 1.0), decayExponent);   \n    }\n    \n    return 1.0;\n}\nvoid GetPointDirectLightIrradiance( const in PointLight pointLight,\n                                    const in vec3 geometryPosition,\n                                    out IncidentLight directLight){\n    vec3 L = pointLight.position - geometryPosition;\n    directLight.direction = normalize(L);\n    \n    float lightDistance = length(L);\n    if(TestLightInRange(lightDistance, pointLight.visibleDistance)){\n        directLight.color = pointLight.color;\n        directLight.color *= punctualLightIntensityToIrradianceFactor(lightDistance, pointLight.visibleDistance, pointLight.decay);\n        directLight.visible = true;\n    }else{\n        directLight.color = vec3(0.0);\n        directLight.visible = false;\n    }\n}\n\nvec3 DiffuseColor(vec3 albedo, vec3 metallic){\n    return mix(albedo, vec3(0.0), metallic);\n}\nvec3 SpecularColor(vec3 albedo, vec3 metallic){\n    return mix(vec3(0.04), albedo, metallic);\n}\nvec3 DiffuseBRDF(vec3 diffuseColor){\n    return diffuseColor / PI;\n}\n\nvec3 F_Schlick(vec3 specularColor, vec3 V, vec3 H){\n    return (specularColor + (1.0 - specularColor) * pow(1.0 - saturate(dot(V,H)), 5.0));\n}\nfloat D_GGX(float a, float dotNH){\n \tfloat a2 = a*a;\n    float dotNH2 = dotNH*dotNH;\n    float d = dotNH2 * (a2 - 1.0) + 1.0;\n    return a2 / (PI*d*d);\n}\nfloat G_SmithSchlickGGX(float a, float dotNV, float dotNL){\n    float k = a*a*0.5 + PBR_EPSILON;\n    float gl = dotNL / (dotNL * (1.0 - k) + k);\n    float gv = dotNV / (dotNV * (1.0 - k) + k);\n    return gl*gv;\n}\n\nvec3 SpecularBRDF(const in IncidentLight directLight,\n                  const in GeometricContext geometry,\n                  vec3 specularColor,\n                  float roughnessFactor){\n    vec3 N = geometry.normal;\n    vec3 V = geometry.viewDir;\n    vec3 L = directLight.direction;\n    \n    float dotNL = saturate(dot(N, L));\n    float dotNV = saturate(dot(N, V));\n    vec3 H = normalize(L+V);\n    float dotNH = saturate(dot(N, H));\n    float dotVH = saturate(dot(V, H));\n    float dotLV = saturate(dot(L, V));\n    float a = roughnessFactor * roughnessFactor;\n    \n    vec3 F = F_Schlick(specularColor, V, H);\n    float D = D_GGX(a, dotNH);\n    float G = G_SmithSchlickGGX(a, dotNV, dotNL);\n    \n    return (F*(G*D)) / (4.0 * dotNL * dotNV + PBR_EPSILON);\n}\n\nvoid RE_Direct(const in IncidentLight directLight,\n               const in GeometricContext geometry,\n               const in Material material,\n               inout ReflectedLight reflectedLight){\n\tfloat dotNL = saturate(dot(geometry.normal, directLight.direction));\n    vec3 irradiance = dotNL * directLight.color;\n    \n    irradiance *= PI;\n    \n    vec3 diffuse = DiffuseColor(material.albedo, material.metallic);\n    vec3 specular = SpecularColor(material.albedo, material.metallic);\n    \n    reflectedLight.directDiffuse += irradiance * DiffuseBRDF(diffuse);\n    \n    float roughness = map(material.roughness, 0., 1., 0.025, 1.);\n    reflectedLight.directSpecular += irradiance * SpecularBRDF(directLight, geometry, specular, roughness);\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define FOV 0.46\n#define NUM_BOUNCES 3\n#define SKY_COLOR vec3(249., 249., 243.)/255.\n\n#define MAX_STEPS 512\n#define SURFACE_DIST 1e-3\n#define MAX_DIST 100.0\n#define NUM_AO_STEPS 8.\n#define NUM_SHADOW_STEPS 32\n\n#define DOOR_HANDLE 1.20\n#define DOOR_HEIGHT 2.10\n#define ROOM_HEIGHT 2.60\n#define ROOM_WIDTH 2.5\n#define SMYGEN 0.06\n\n#define MAT_WALL 1\n#define MAT_FLOOR 2\n#define MAT_CEILING 3\n#define MAT_DOOR 4\n#define MAT_WINDOW 5\n\nconst int NUM_LIGHTS = 5;\nPointLight pointLights[NUM_LIGHTS];\n\n\nfloat WallWithOffset(vec3 p, vec3 offset){\n    vec3 q = p - offset;\n    \n    float closeWall = fBoxCheap(q - vec3(0,0,0), vec3(SMYGEN, ROOM_HEIGHT, 2.8));\n    float farWall = fBoxCheap(q - vec3(0,0,4.6), vec3(SMYGEN, ROOM_HEIGHT, 1.2));\n    float topWall = fBoxCheap(q - vec3(0,ROOM_HEIGHT,0), vec3(SMYGEN, ROOM_HEIGHT-DOOR_HEIGHT, 5.2));\n    \n    return min(min(closeWall, farWall), topWall);\n}\nfloat LeftWall(vec3 p){\n\treturn WallWithOffset(p, vec3(-(ROOM_WIDTH)/2.0,0,0));\n}\nfloat RightWall(vec3 p){\n    return WallWithOffset(p, vec3(ROOM_WIDTH/2.0,0,0));\n}\nfloat BackCorridorWalls(vec3 p){\n    float sideSize = 0.2;\n    float depthSize = 1.5;\n    \n    float dRightBack = fBoxCheap(\n        p - vec3(ROOM_WIDTH/2.+sideSize-SMYGEN, 0., 5.8),\n        vec3(sideSize, ROOM_HEIGHT, SMYGEN)\n    );\n    float dLeftBack = fBoxCheap(\n        p - vec3(-ROOM_WIDTH/2.-sideSize+SMYGEN, 0., 5.8),\n        vec3(sideSize, ROOM_HEIGHT, SMYGEN)\n    );\n    float dBackWalls = min(dLeftBack, dRightBack);\n    \n    float dFront = min(\n        fBoxCheap(\n            p - vec3(0., 0., 5.8+depthSize),\n            vec3(ROOM_WIDTH + sideSize, ROOM_HEIGHT, SMYGEN)\n        ),\n        fCylinder(p.xzy - vec3(0., 5.8+depthSize, DOOR_HANDLE), 0.35, SMYGEN*1.1)\n    );\n    \n    dFront = max(dFront, -fCylinder(p.xzy - vec3(0., 5.8+depthSize, DOOR_HANDLE), 0.3, SMYGEN*1.5));\n   \n    dFront = min(dFront, fBoxCheap(p - vec3(0., DOOR_HANDLE, 5.8+depthSize), vec3(0.03, 0.3, SMYGEN*1.1)));\n    \n    return min(dBackWalls, dFront);\n}\nHit Walls(vec3 p){\n    float dLeftWall = LeftWall(p);\n    float dRightWall = RightWall(p);\n    float back = fBoxCheap(\n        p - vec3(0,ROOM_HEIGHT,5.8-(SMYGEN/2.)),\n        vec3(ROOM_WIDTH/2.,ROOM_HEIGHT-DOOR_HEIGHT+0.1,SMYGEN/2.)\n    );\n    float behind = fBoxCheap(\n        p - vec3(0,ROOM_HEIGHT,-1.),\n        vec3(ROOM_WIDTH/2.,ROOM_HEIGHT-DOOR_HEIGHT+DOOR_HEIGHT,SMYGEN)\n    );\n    \n    float dBackCorridorWalls = BackCorridorWalls(p);\n    \n    return Hit(\n        min(min(\n            min(dLeftWall, dRightWall),\n            min(back, behind)\n        ), dBackCorridorWalls),\n        MAT_WALL\n    );\n}\n\nfloat Door(vec3 p, float r){\n    pR(p.xz, r);\n    float offset = 0.0;\n    vec3 q = p - vec3(0,DOOR_HEIGHT/2.0 + offset,0);\n    float door = fBoxCheap(q, vec3(0.3, DOOR_HEIGHT/2.0 - offset, 0.01));\n    float cutout = fSphere(p - vec3(0.3,DOOR_HANDLE,0), 0.25);\n    \n    float barWidth = 0.01;\n    float bar = fBoxCheap(p - vec3(0.3-barWidth,DOOR_HANDLE,0), vec3(barWidth, 0.3, 0.01));\n    \n    return min(max(door, -cutout), bar);\n}\nHit SideDoors(vec3 p){\n    float leftDoor = Door(p - vec3(-(ROOM_WIDTH)/2.0-SMYGEN,0,3.1), PI/2.0);\n    float rightDoor = Door(p - vec3((ROOM_WIDTH)/2.0+SMYGEN,0,3.1), PI/2.0);\n\n\treturn Hit(\n       \tmin(leftDoor, rightDoor),\n        MAT_DOOR\n    );\n}\n\nHit Ceiling(vec3 p){\n    float h = 2.0;\n    \n    float extension = 1.9;\n    \n    float part0 = fBoxCheap(p - vec3(0,ROOM_HEIGHT+h,5.5), vec3(ROOM_WIDTH/2.0, h, 0.3));\n\tfloat part1 = fBoxCheap(p - vec3(0,ROOM_HEIGHT+h,4.3), vec3(ROOM_WIDTH/2.0, h, 0.3));\n    float part2 = fBoxCheap(p - vec3(0,ROOM_HEIGHT+h,3.1-extension), vec3(ROOM_WIDTH/2.0, h, 0.3+extension));\n    float part3 = fBoxCheap(p - vec3(0,4.7,9.), vec3(ROOM_WIDTH*2., 0.1, 4.0));\n    \n    return Hit(\n        min(\n            min(part0, part1),\n            min(part2, part3)\n        ),\n        MAT_CEILING\n    );\n}\n\nHit Floor(vec3 p){\n \treturn Hit(\n        fBoxCheap(p - vec3(0., -1., 0.), vec3(ROOM_WIDTH*1.1,1.0,8.0)),\n        MAT_FLOOR\n    );\n}\n\nHit Window(vec3 p){\n    return Hit(\n    \tfCylinder(p.xzy - vec3(0., 7.3, DOOR_HANDLE), 0.3, SMYGEN),\n        MAT_WINDOW\n    );\n}\n\nHit GetDist(vec3 p){\n    Hit dWalls = Walls(p);\n    Hit dSideDoors = SideDoors(p);\n    Hit dFloor = Floor(p);\n    Hit dCeiling = Ceiling(p);\n    Hit dWindow = Window(p);\n    \n    float ball = fSphere(p - vec3(0.65, 0.5, 4.0), 0.5);\n    Hit dBalls = Hit(\n        ball,\n        99\n    );\n    \n    return OpUnionHit(\n        OpUnionHit(\n            OpUnionHit(dWalls, dSideDoors),\n            OpUnionHit(dCeiling, dFloor)\n        ),\n        OpUnionHit(dWindow, dBalls)\n    );\n}\n\nHit RayMarch(vec3 ro, vec3 rd, int bounce){\n\tfloat dO = 0.;\n    Hit hit;\n    \n    int steps = MAX_STEPS;\n    \n    if(bounce > 0){\n        steps /= bounce*4;\n    }\n    \n    for(int i = 0; i < steps; i++){\n        vec3 p = dO*rd+ro;\n        hit = GetDist(p);\n        dO += hit.d;\n        if(hit.d < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return Hit(dO, hit.ID);\n}\n\nMaterial GetMaterial(in vec3 p, in vec3 n, in Hit hit){\n    Material mat;\n    \n    if(hit.ID == MAT_WALL || hit.ID == MAT_CEILING){\n        vec3 left = vec3(245.,22.,92.) / 255.;\n        vec3 right = vec3(252.,200.,155.) / 255.;\n\n        vec3 res = mix(\n            left,\n            right,\n            smoothstep(-1.0, 1.0, p.x/(0.02))\n        );\n        \n        float percent = 0.6+hit.d*0.05;\n        res *= (1.-TriplanarMapping(iChannel0, n, p*vec3(0.4, 0.4, 1.2)).b) * percent + (1.-percent);\n        \n        mat.albedo = res;\n        mat.metallic = vec3(0.0);\n        mat.roughness = 1.0;\n    }else if(hit.ID == MAT_FLOOR){\n        float tileSize = (ROOM_WIDTH-SMYGEN)/8.;\n        float tileX = smoothstep(0.0, 0.02+hit.d*0.005, abs(fract(p.x/tileSize-0.5)-0.5));\n        float tileZ = smoothstep(0.0, 0.02+hit.d*0.03, abs(fract(p.z/tileSize-0.5)-0.5));\n        float tile = min(tileX, tileZ);\n        \n        vec3 res = vec3(tile)*0.5;\n        \n        float percent = 0.6;\n        float erode = (1.-TriplanarMapping(iChannel1, n, p*vec3(0.4, 0.4, 1.2)).b) * percent + (1.-percent);\n\n        res *= erode;\n        \n        mat.albedo = res;\n        mat.metallic = vec3(0.0);\n        mat.roughness = saturate(0.3*tile-(erode*0.45));\n    }else if(hit.ID == MAT_DOOR){\n        mat.albedo = vec3(232., 240., 255.)/255.*(2.5+1.*sign(p.x));\n        mat.metallic = vec3(0.0);\n        mat.roughness = 0.95;\n    }else if(hit.ID == MAT_WINDOW){\n        vec3 left = vec3(245.,97.,27.) / 255.;\n        vec3 right = vec3(15.,7.,221.) / 255.;\n        \n        vec3 res = mix(\n            left,\n            right,\n            smoothstep(-1.0, 1.0, p.x/(0.02))\n        );\n        \n        float percent = 0.9;\n        res *= (1.-TriplanarMapping(iChannel0, n, p*vec3(3.)).b) * percent + (1.-percent);\n        \n        mat.albedo = res;\n        mat.metallic = vec3(0.0);\n        mat.roughness = 1.0;\n    }else{\n        float rough = pow(TriplanarMapping(iChannel1, n, p*vec3(2., 4., 4.)).r*1.25, 6.);\n        mat.albedo = vec3(0.95);\n        mat.metallic = vec3(1.0);\n        mat.roughness = saturate(rough);\n    }\n    \n    return mat;\n}\n\nvec3 GetNormal(vec3 pos){\n \tvec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*GetDist( pos + e.xyy ).d + \n\t\t\t\t\t  e.yyx*GetDist( pos + e.yyx ).d + \n\t\t\t\t\t  e.yxy*GetDist( pos + e.yxy ).d + \n\t\t\t\t\t  e.xxx*GetDist( pos + e.xxx ).d );\n}\n\nfloat CalcAO(vec3 ro, vec3 rd){\n    float k = 1.0;\n    float occ = 0.0;\n    for(float i = 0.0; i < NUM_AO_STEPS; ++i){\n        float len = 0.15 * i + 0.15;\n        float dist = GetDist(rd * len + ro).d;\n        occ += k * (len - dist);\n        k *= 0.5;\n    }\n    return saturate(1.0-occ);\n}\n\nfloat CalcShadow(in vec3 ro, in vec3 rd, in float maxT){\n    float res = 1.0;\n    float t = 0.01;\n    float ph = 1e10;\n    \n    for(int i = 0; i < NUM_SHADOW_STEPS; ++i){\n        float h = GetDist(rd * t + ro).d;\n        \n        if(h < SURFACE_DIST)return 0.;\n        \n        float y = h*h/(2.*ph);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 5.*d/max(0.,t-y));\n        ph = h;\n        \n        t += h*0.95;\n        \n        if(res < SURFACE_DIST || t >= maxT) break;\n    }\n    \n    return saturate(res);\n}\n\nvec4 GetColor(vec3 ro, vec3 rd){\n    int bounce = 0;\n    float depth = 0.;\n    \n    vec3 res = vec3(0.0);\n    \n    vec3 carry = vec3(1.0);\n    \n    for(int bounce = 0; bounce <= NUM_BOUNCES; ++bounce){\n        Hit hit = RayMarch(ro, rd, bounce);\n        if(bounce == 0)depth = hit.d;\n\n        if(hit.d >= MAX_DIST){\n            res += SKY_COLOR;\n            continue;\n        }\n\n        vec3 p = rd * hit.d + ro;\n        vec3 n = GetNormal(p);\n        vec3 v = normalize(ro-p);\n        \n        GeometricContext geometry;\n        geometry.position = p;\n        geometry.normal = n;\n        geometry.viewDir = v;\n\n        Material material = GetMaterial(p, n, hit);\n        \n        \n        ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));\n        IncidentLight directLight;\n        \n        vec3 s = vec3(0.0);\n        for(int lightIndex = 0; lightIndex < NUM_LIGHTS; ++lightIndex){\n            GetPointDirectLightIrradiance(pointLights[lightIndex], geometry.position, directLight);\n            \n            if(directLight.visible){\n                vec3 L = pointLights[lightIndex].position - geometry.position;\n            \tfloat shadow = CalcShadow(p, normalize(L), length(L));\n            \n                directLight.color *= shadow;\n                \n                RE_Direct(directLight, geometry, material, reflectedLight);\n            }\n        }\n        \n        vec3 specular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n        vec3 diffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n        \n        vec3 col = vec3(0.0);\n        col += specular;\n        col += diffuse;\n        \n        col += vec3(0.02) * material.albedo;\n        \n        float ao = CalcAO(p, n);\n        col *= ao*ao;\n        \n        res += col * carry;\n        \n        carry = material.albedo * carry * (1.0 - material.roughness);\n        \n        if(length(carry) < 0.05){break;}\n\n        // bounce ray\n        rd = rd - 2.0*dot(rd, n)*n;\n        ro = p + rd*0.01;\n    }\n    \n    return vec4(res, depth);\n}\n\nvoid InitLights(){\n    pointLights[0].color = vec3(1.0, 0.78, 0.6) * 3.;\n    pointLights[0].position = vec3(0.0, 3.7, 3.7);\n    pointLights[0].visibleDistance = 6.0;\n    pointLights[0].decay = 1.0;\n    \n    pointLights[1].color = vec3(1.0, 0.78, 0.6)*3.;\n    pointLights[1].position = vec3(0., 3.7, 4.9);\n    pointLights[1].visibleDistance = 6.0;\n    pointLights[1].decay = 1.0;\n    \n    pointLights[2].color = vec3(1.5, 0.9, 1.2)*50.;\n    pointLights[2].position = vec3(0., 3.9, 6.5);\n    pointLights[2].visibleDistance = 5.0;\n    pointLights[2].decay = 2.0;\n    \n    pointLights[3].color = vec3(1.0, 1.0, 0.2)*50.;\n    pointLights[3].position = vec3(-ROOM_WIDTH/2. - 0.2, DOOR_HANDLE, 3.3);\n    pointLights[3].visibleDistance = 1.;\n    pointLights[3].decay = 1.0;\n    \n    pointLights[4].color = vec3(1.2, 0.8, 1.0)*1.;\n    pointLights[4].position = vec3(0., 0.6, 3.);\n    pointLights[4].visibleDistance = 12.5;\n    pointLights[4].decay = 10.0;\n}\n\nconst mat2 m2 = mat2(1.6,-1.2,1.2,1.6);\nfloat noi( in vec2 p )\n{\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n}\nfloat smoothNoise( vec2 p )\n{\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ )\n\t{\n        t += s*noi( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*m2*p + (t-0.5)*0.2;\n\t}\n\treturn t;\n}\n\nvoid getCamera(in vec2 frag, out vec3 ro, out vec3 rd){\n    vec2 uvs = frag/iResolution.xy;\n    vec2 uv = uvs * 2.0 - 1.0;\n    uv *= 1.+0.05*dot(uv,uv);\n\tuv.x *= iResolution.x/iResolution.y;\n    \n\tfloat fbm1 = smoothNoise(vec2(t*100.))*0.1;\n    float fbm2 = smoothNoise(vec2(t*90.+100.))*0.1;\n    float fbm3 = smoothNoise(vec2(t*80.+200.))*0.1;\n    float fbm4 = smoothNoise(vec2(t*70.+300.))*0.1;\n    \n    float zpos = 0.;\n    \n    vec3 lookAt = vec3(0.0, DOOR_HANDLE+fbm1, 4.0+zpos);\n    vec3 cameraPosition = vec3(0.+fbm2, DOOR_HANDLE+fbm3, 0.+fbm4+zpos);\n    \n    vec3 forward = normalize(lookAt-cameraPosition);\n    vec3 right = normalize(vec3(forward.z, fbm2*0.1, -forward.x ));\n    vec3 up = normalize(cross(forward,right));\n\n    ro = cameraPosition; \n    rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    InitLights();\n    \n    vec2 uvs = fragCoord/iResolution.xy;\n    vec2 uv = uvs * 2.0 - 1.0;\n    \n    vec3 ro;\n    vec3 rd;\n    getCamera(fragCoord, ro, rd);\n    vec4 tot = GetColor(ro, rd);\n\n    vec3 color = tot.rgb;\n    float depth = tot.a;\n    \n    float fbmDof = smoothNoise(vec2(t*50.));\n    float focusPoint = 5.0 + fbmDof*2.;\n    float focusField = 100.;\n    \n    float focus = mix(0., 1., abs(depth - focusPoint)/focusField);\n    focus = saturate(focus);\n    \n    vec4 final = vec4(color, focus);\n    vec4 previousFinal = texture(iChannel2, uvs);\n    fragColor = mix(final, previousFinal, pow(0.1, 19.0*iTimeDelta));\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define DIRECTION vec2(1., 1.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (-iResolution.xy + 2.*fragCoord.xy) / iResolution.y;\n    \n    float focus = texture(iChannel0, uv).a;\n    float totalWeight = 0.0;\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = -DOF_NUM_ITERATIONS; i <= DOF_NUM_ITERATIONS; ++i){\n        float f = i/DOF_NUM_ITERATIONS;\n        vec2 p = uv + DIRECTION * DOF_STRENGTH * f * focus;\n        \n        float w = 1.0 - f*f*f*f;\n        \n        vec4 col = texture(iChannel0, p);\n        if(focus > col.a){\n            w *= max(0.0, 1.0-(focus-col.a)/DOF_THRESHOLD);\n        }\n        color += col.rgb * w;\n        totalWeight += w;\n    }\n    \n    color /= totalWeight;\n    fragColor = vec4(color, focus);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"#define DIRECTION vec2(1., -1.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (-iResolution.xy + 2.*fragCoord.xy) / iResolution.y;\n    \n    float focus = texture(iChannel0, uv).a;\n    float totalWeight = 0.0;\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = -DOF_NUM_ITERATIONS; i <= DOF_NUM_ITERATIONS; ++i){\n        float f = i/DOF_NUM_ITERATIONS;\n        vec2 p = uv + DIRECTION * DOF_STRENGTH * f * focus;\n        \n        float w = 1.0 - f*f*f*f;\n        \n        vec4 col = texture(iChannel0, p);\n        if(focus > col.a){\n            w *= max(0.0, 1.0-(focus-col.a)/DOF_THRESHOLD);\n        }\n        color += col.rgb * w;\n        totalWeight += w;\n    }\n    \n    color /= totalWeight;\n    fragColor = vec4(color, focus);\n}","name":"Buffer C","description":"","type":"buffer"},{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XdfGR8","channel":0}],"code":"#define DIRECTION vec2(0., 2.)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 uvs = (-iResolution.xy + 2.*fragCoord.xy) / iResolution.y;\n    \n    float focus = texture(iChannel0, uv).a;\n    float totalWeight = 0.0;\n    \n    vec3 color = vec3(0.0);\n    \n    for(float i = -DOF_NUM_ITERATIONS; i <= DOF_NUM_ITERATIONS; ++i){\n        float f = i/DOF_NUM_ITERATIONS;\n        vec2 p = uv + DIRECTION * DOF_STRENGTH * f * focus;\n        \n        float w = 1.0 - f*f*f*f;\n        \n        vec4 col = texture(iChannel0, p);\n        if(focus > col.a){\n            w *= max(0.0, 1.0-(focus-col.a)/DOF_THRESHOLD);\n        }\n        color += col.rgb * w;\n        totalWeight += w;\n    }\n    \n    color /= totalWeight;\n    fragColor = vec4(color, focus);\n}","name":"Buffer D","description":"","type":"buffer"}]}