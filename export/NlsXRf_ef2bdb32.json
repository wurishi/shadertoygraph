{"ver":"0.1","info":{"id":"NlsXRf","date":"1626199860","viewed":358,"name":"Perspective camera with DOF","username":"Envy24","description":"This camera described in book \"Ray Tracing In One Weekend\".\n\nUse mouse to change focus.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["camera","depthoffield","depthoffieldperspective"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n     Orthographic camera: https://www.shadertoy.com/view/flXXWn\n     Perspective camera : https://www.shadertoy.com/view/NtsXz4\n*/\n\n#define TAU 6.2831853071795862 // 2*PI\n#define TO_RAD 0.017453292519943295\n#define TO_DEG 57.295779513082323\n#define R iResolution\n\n\nvec4 sceneDOF(vec2 uv, vec2 P)\n{\n    float MY = iMouse.z > 0.0 ? 0.1 + (iMouse.y / R.y) * 179.8 : 39.6; // varies from 0.1 to 179.9\n    float MX = iMouse.z > 0.0 ? 1.0 - (iMouse.x / R.x) * 2.0 : 0.0;    // varies from -1.0 to 1.0\n\n\n    /* Perspective camera with depth of field (initialization). */\n    vec3 focusTarget = vec3(0.0, 0.0, MX); \n    vec3 camera = vec3(cos(iTime), sin(iTime), 5.0);\n    float aperture = 1.0 / 2.0; // aperture < 1.0  ==> larger DOF, and aperture > 1.0 ==> shallow DOF\n    float fovx = 39.6; //MY;\n    \n    float focalDistance = length(focusTarget - camera);\n    float lensRadius = aperture * 0.5;   \n\n    vec3 f = normalize(focusTarget - camera);          // forward\n    vec3 r = normalize(cross(f, vec3(0.0, 1.0, 0.0))); // right\n    vec3 u = normalize(cross(r, f));                   // up     \n     \n    float aspectRatio = R.x / R.y;\n    float vpWidth = 2.0 * tan(fovx * TO_RAD * 0.5) * focalDistance;\n    float vpHeight = vpWidth / aspectRatio;\n           \n    uv.x = (uv.x * vpWidth) - vpWidth * 0.5;\n    uv.y = (uv.y * vpHeight) - vpHeight * 0.5;\n    \n    // See line 73 for ray generation.\n    \n    /* Perspective camera with depth of field (initialization). */\n    \n  \n    /* Scene stuff */\n  \n    float d = 0.5;\n    vec3 c[9];\n    c[0] = vec3(0.0, 0.0, 0.0); // central\n    \n    c[1] = vec3(d, d, -d);\n    c[2] = vec3(-d, d, -d);\n    c[3] = vec3(d, -d, -d);\n    c[4] = vec3(-d, -d, -d);\n    \n    c[5] = vec3(d, d, d);   \n    c[6] = vec3(-d, d, d);   \n    c[7] = vec3(d, -d, d);   \n    c[8] = vec3(-d, -d, d);\n       \n    float radius = 0.2;\n    \n    float t = 99999.0;\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec4 sum = vec4(0.0, 0.0, 0.0, 0.0);\n    uint numOfSamples = 8u;\n\n    for (uint s = 0u; s < numOfSamples; ++s)\n    {\n    \n    \n    \n        /* Perspective camera with depth of field (calculate ray). */\n        uint x = uint(P.x) + s * 2342u;\n        uint y = uint(P.y * R.x) + s * 80210u;\n        vec3 offset = vec3(lensRadius * sampleUnitDiscSqrt(x, y), 0.0);\n        offset = offset.x * r + offset.y * u;\n\n        vec3 ray = camera + offset;\n        vec3 rayDir = normalize(uv.x * r + uv.y * u + f * focalDistance - offset);\n        /* Perspective camera with depth of field (calculate ray). */\n    \n    \n    \n    \n        for (int i = 0; i < 9; ++i)\n        {\n            float tmp = shootRayInSphere(ray, rayDir, c[i], radius);       \n\n            if (tmp > 0.0 && tmp < t) // hit\n            {\n                t = min(t, tmp);\n\n                normal = (ray + rayDir * t) - c[i];\n            }\n        }\n        \n        /**\n        float tmp = shootRayInPlane(ray, rayDir, vec3(0.0, 0.0, 0.0), normalize(vec3(1.0, 1.0, 1.0)));       \n\n        if (tmp > 0.0 && tmp < t) // hit\n        {\n            t = min(t, tmp);\n\n            normal = normalize(vec3(0.0, 1.0, 1.0));\n        }\n        /**/\n        \n        if (t > 1000.0) \n        { \n            sum += vec4(normalize(1.0 - rayDir), 1.0); // Background color.\n            continue;\n        } \n    \n        float exposureTime = 1.0;\n\n        sum += vec4(vec3((1.0 + normalize(normal)) * 0.5) * exposureTime, 1.0);\n    }\n    \n    return sum / float(numOfSamples);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/R.xy;\n \n    // Output to screen\n    fragColor = sceneDOF(uv, fragCoord);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define T_NEAR 0.0001\n\nfloat shootRayInPlane(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 plane,\n    vec3 planeNormal)\n{\n\n    float t = dot(plane - ray, planeNormal) / dot(rayDir, planeNormal);\n    \n    return \n        t >= T_NEAR ?\n        t:\n        -1.0;\n}\n\nfloat shootRayInSphere(\n    vec3 ray,\n    vec3 rayDir,\n    vec3 sphereCenter,\n    float sphereRadius)\n{\n    vec3 tmp = ray - sphereCenter;\n    \n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(tmp, rayDir);\n    float c = dot(tmp, tmp) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    \n    if (discriminant < 0.0) { return -1.0; }\n      \n    float e = sqrt(discriminant);\n\n    float t = (-b - e) / (2.0 * a);\n\n    if (t >= T_NEAR)\n    {\n       return t;\n    }\n\n    t = (-b + e) / (2.0 * a);\n\n    if (t >= T_NEAR)\n    {\n       return t;\n    }\n    \n    return -1.0;\n}\n\nvec3 rotateAroundX(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x,\n        p.y * c + p.z * s,\n        p.z * c - p.y * s);\n}\n\nvec3 rotateAroundY(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.z * s,\n        p.y,\n        p.z * c - p.x * s);\n}\n\nvec3 rotateAroundZ(vec3 p, float a)\n{\n    float s = sin(-a);\n    float c = cos(-a);\n\n    return vec3(\n        p.x * c + p.y * s,\n        p.y * c - p.x * s,\n        p.z);\n}\n\n/* \n    Returns random vec2([-1.0; 1.0], [-1.0; 1.0]).\n*/\nvec2 vector2HashUI32(\n    const uint x,\n    const uint y)\n{\n    // Pick some enthropy source values.\n    // Try different values.\n    const uint enthropy0 = 123u;\n    const uint enthropy1 = 456u;\n    const uint enthropy2 = 789u;\n\n    // Use linear offset method to mix coordinates.\n    uint value0 = y * enthropy2 + x;\n    uint value1 = x * enthropy2 + y;\n\n    // Calculate hash.\n\tvalue0 += enthropy1; value0 *= 445593459u; value0 ^= enthropy0;\n    value1 += enthropy1; value1 *= 445593459u; value1 ^= enthropy0;\n    \n    // 2.0f / 4294967295.0f = 4.6566128730773926e-10\n\n    return \n        vec2(\n            float(value0 * value0 * value0) * 4.6566128730773926e-10f - 1.0f,\n            float(value1 * value1 * value1) * 4.6566128730773926e-10f - 1.0f);\n}\n\n// source: https://www.youtube.com/watch?v=4y_nmpv-9lI\nvec2 sampleUnitDiscSqrt(\n    const uint x,\n    const uint y)\n{\n    vec2 rand = vector2HashUI32(x, y);\n    \n    // applying inverse of CDF.\n    rand.x = sqrt((rand.x + 1.0f) * 0.5f);\n    \n    // map from [-1.0; 1.0] to [-PI; PI].\n    rand.y *= 3.14159274f;\n    \n    return vec2(\n        rand.x * cos(rand.y),\n        rand.x * sin(rand.y));\n}","name":"Common","description":"","type":"common"}]}