{"ver":"0.1","info":{"id":"wlBfWt","date":"1603272601","viewed":169,"name":"mandelbox playground","username":"fu5ha","description":"WASD, Shift, Space, Drag Mouse to move. Hold P to draw Debug text (camera x,y,z position and camera yaw, pitch in radians).","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["fractal","playground","wideangle"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// SEE COMMON FOR DEFAULT VALUES\n\n// adapted originally from https://www.shadertoy.com/view/XdlSD4\n// camera movement adapted from https://www.shadertoy.com/view/lttGzr\n// text drawing utilities from https://www.shadertoy.com/view/llySRh\n\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \nvec4 char(vec2 p, int c) {\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\n // if ( p.x>.25&& p.x<.75 && p.y>.0&& p.y<1. )  // normal char box\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) // thighly y-clamped to allow dense text\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\n    return vec4(0);\n}\nvec4 draw_char() {\n    int c = char_id; vec2 p = char_pos;\n    return c < 0 \n        ? vec4(0,0,0,1e5)\n        : textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), \n                       dfdx, dfdy );\n}\n\n\n// --- display int4\n#if 0\nvec4 pInt(vec2 p, float n) {  // webGL2 variant with dynamic size\n    vec4 v = vec4(0);\n    for (int i = int(n); i>0; i/=10, p.x += .5 )\n        v += char(p, 48+ i%10 );\n    return v;\n}\n#else\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n#endif\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    v += pInt(p,floor(n)); p.x -= 2.;\n    v += char(p, 46);      p.x -= .5;\n    v += pInt(p,fract(n)*1e4);\n    return v;\n}\n\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc O+= char(U,64+CAPS+c);\n\n\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    vec4 buf = texture(iChannel1,fragCoord.xy / iResolution.xy);\n    \n    vec3 col = buf.xyz/buf.w;\n    \n    col = vec3(1.0) - exp(-col * exposure);\n    col = pow(col,vec3(1./2.2)); \n\tvec4 O = vec4(0.0);\n\n\t/// DEBUG TEXT\n\t/// COLUMN 1: Camera X, Y, Z\n\t/// COLUMN 2: Camera Yaw, Pitch\n    if keyDown(80) { // P key\n        vec3 cameraPosition = texelFetch(iChannel2,ivec2(0,0),0).rgb;\n        vec2 yaw_pitch\t\t= texelFetch(iChannel2,ivec2(5,0),0).rg;\n        vec2 R = iResolution.xy;\n        vec2 U;\n        vec2 uv = fragCoord / R.y;    \n        int lod = int(mod(iTime,10.));\n\n        U = ( uv - vec2(.1,.9) ) * 16.;        // --- column 1\n        O += pFloat(U, cameraPosition.x);         U.y += .8;\n        O += pFloat(U, cameraPosition.y);         U.y += .8;\n        O += pFloat(U, cameraPosition.z);         U.y += .8;\n        U = ( uv - vec2(.5,.9) ) * 16.;        // --- column 2\n        O += pFloat(U, yaw_pitch.x);         U.y += .8;\n        O += pFloat(U, yaw_pitch.y);         U.y += .8;\n\n        O += draw_char().xxxx;\n    }\n    \n\tfragColor = vec4(col, 1.) + O;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// original created by EvilRyu\n// This buffer actually draws the image\n\n\nfloat softshadow(vec3 ro, vec3 rd, float k ){ \n     float akuma=1.0,h=0.0; \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         h=f(ro+rd*t); \n         if(h<0.001)return 0.02; \n         akuma=min(akuma, k*h/t); \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return akuma; \n} \n\nfloat hardshadow(vec3 ro, vec3 rd, float k ){ \n\t float t = 0.01;\n     for(int i=0; i < 50; ++i){ \n         float h=f(ro+rd*t); \n         if(h<0.001)return 0.02;  \n \t\t t+=clamp(h,0.01,2.0); \n     } \n     return 1.0; \n} \n\n\nfloat intersect(vec3 ro, vec3 rd)\n{\n    float res;\n    float t = 0.01;\n    for(int i = 0; i < MAX_MARCHES; ++i)\n    {\n        vec3 p = ro + rd * t;\n        res = f(p);\n        if(res < HIT_THRESHOLD * max(t, 0.05) || res > 20.)\n            break;\n        t += res;\n    }\n    \n    if(res > 20.) t = -1.;\n    return t;\n}\n\nuvec2 pcg2d(uvec2 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\n\nvec3 getNormal(vec3 p, float t) {\n    vec3 e=vec3(0.001 * t,0.0,0.0); \n\treturn normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n \t\t\t\t\t\t  f(p+e.yxy)-f(p-e.yxy), \n \t\t\t\t\t\t  f(p+e.yyx)-f(p-e.yyx)));\n}\n\nvec3 post(vec3 col, vec2 q) {\n\t // post\n    //col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.5);  // satuation\n    col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n\treturn col;\n}\n\n\nvec3 get_background_color(vec2 uv, vec3 ro, vec3 rd) {\n\n\treturn bg;\n}\n\nvec3 pathmarcher(vec3 ro, vec3 rd, inout uint seed){\n    vec3 throughput = vec3(1);\n    vec3 direct    = vec3(0);\n \n    for(int depth=0;depth<MAX_DEPTH;depth++){\n        \n        float t = intersect(ro, rd);\n        vec3 hitPos = ro + rd*t;\n            \n        if(t > 0.0){\n\t\t\tvec3 col = mtl; \n            vec3 hitNormal = getNormal(hitPos,t);\n            \n            throughput *= col;\n\t\t\t\n\t\t\tvec3 add_direct = vec3(0.0);\n\n            float ndl = dot(hitNormal,l1_dir);\n            if(ndl>0.){\n                float t = intersect(hitPos + hitNormal*t*0.001, l1_dir);\n                if (t < -0.5){\n                    add_direct = throughput*l1_col*ndl;\n                }\n            }\n\n        \tadd_direct = mix(add_direct, throughput * bg, 1.0-exp(-0.01*t*t));\n            \n\t\t\tdirect += add_direct;\n\n            rd = getCosWeightedHemiSphereSample(hitNormal,seed++);\n\n        }else {\n            \n        \treturn direct + throughput*bg; \n            \n        }\n        \n        ro = hitPos;   \n    }\n\n    return direct;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{ \n \tstime=sin(iTime*0.1); \n \tctime=cos(iTime*0.1); \n    time=iTime*0.1;\n\n    vec2 q=fragCoord.xy/iResolution.xy; \n \tvec2 uv = -1.0 + 2.0*q; \n \tuv.x*=iResolution.x/iResolution.y;\n\n\tvec2 aa_samp = vec2(pcg2d(uvec2(fragCoord.xy) + uvec2(iResolution.xy) * uint(iFrame))) * (1.0/float(0xffffffffu));\n\tuv = uv + aa_samp / iResolution.xy * 2.0;\n\t\n\t// camera\n    vec3 ro = texelFetch(iChannel1,ivec2(0,0),0).rgb;\n\n  \tvec3 cf  = texelFetch(iChannel1,ivec2(1,0),0).rgb;\n\n    vec3 cr    = texelFetch(iChannel1,ivec2(2,0),0).rgb;\n\n    vec3 cu   = texelFetch(iChannel1,ivec2(3,0),0).rgb;\n\n\n   \tfloat focal_length = 1.;\n        \n    float theta = length(uv) / focal_length;\n \t//uv = uv * tan(theta) / theta; // \"equidistance\" / equiangular projection\n\n    vec3 rd = normalize(uv.x*cr + uv.y*cu + focal_length*cf);  // transform from view to world\n\t\n\t// actually trace\n    uvec2 up = uvec2(fragCoord);\n    uint seed =  up.x + 2560U*up.y + (2560U*1440U)*uint(iFrame);\n    vec3 col = pathmarcher(ro, rd, seed);\n\n   \tcol=post(col, q);\n\n    //Final\n    fragColor = vec4(col,1.0);\n    \n    if(!(texelFetch(iChannel1,ivec2(0),0).w>.0)){//No movement detected so keep previous frames\n    \tfragColor += texelFetch(iChannel0,ivec2(fragCoord),0);\n    }\n }","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"//This buffer handles the Camera\n// original https://www.shadertoy.com/view/lttGzr\n//if ANY movement is done fragColor.w becomes 1 for ALL pixels\n\nvoid rot(inout vec3 a, inout vec3 b, float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    a =  c*a + s*b;\n    b = -s*a + c*b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    ivec2 p = ivec2(fragCoord);\n    \n    if(p.x>6 || p.y > 0) return;\n    \n    vec3 cameraPosition = texelFetch(iChannel0,ivec2(0,0),0).rgb;\n  \tvec3 cameraForward  = texelFetch(iChannel0,ivec2(1,0),0).rgb;\n    vec3 cameraRight    = texelFetch(iChannel0,ivec2(2,0),0).rgb;\n    vec3 cameraUp   \t= texelFetch(iChannel0,ivec2(3,0),0).rgb;\n    vec3 mouseOld       = texelFetch(iChannel0,ivec2(4,0),0).rgb;\n\tvec2 yaw_pitch\t\t= texelFetch(iChannel0,ivec2(5,0),0).rg;\n   \tvec2 yaw_pitch_old\t= texelFetch(iChannel0,ivec2(6,0),0).rg;\n\n    if(iFrame==0){\n        cameraPosition  = CAMERA_POSITION;\n        cameraForward   = vec3(0.0, 0.0, 1.0);\n        cameraRight     = vec3(1.0, 0.0, 0.0);\n        cameraUp    \t= vec3(0.0, 1.0, 0.0);\n        mouseOld        = vec3(iMouse.xy, 0);\n\t\tyaw_pitch\t\t= CAMERA_YAW_PITCH;\n    } \t\t\n    \n    bool forward     = texelFetch(iChannel1,ivec2(87,0),0).x + texelFetch(iChannel1,ivec2(38,0),0).x >0.;\n    bool left        = texelFetch(iChannel1,ivec2(65,0),0).x + texelFetch(iChannel1,ivec2(37,0),0).x >0.;\n    bool backward    = texelFetch(iChannel1,ivec2(83,0),0).x + texelFetch(iChannel1,ivec2(40,0),0).x >0.;\n    bool right       = texelFetch(iChannel1,ivec2(68,0),0).x + texelFetch(iChannel1,ivec2(39,0),0).x >0.;\n    bool down        = texelFetch(iChannel1,ivec2(16,0),0).x + texelFetch(iChannel1,ivec2(34,0),0).x > 0.;\n    bool up          = texelFetch(iChannel1,ivec2(32,0),0).x + texelFetch(iChannel1,ivec2(33,0),0).x > 0.;\n    bool mouseLeft   = iMouse.z>0.;\n    bool interaction = forward||left||backward||right||down||up||mouseLeft;\n    \n    float stepSize = clamp(\n        f(cameraPosition)*MOVEMENT_SPEED,\n        MIN_SPEED,\n        MAX_SPEED\n    )*iTimeDelta;\n    \n    cameraPosition += (cameraForward*(float(forward) - float(backward)) +\n        \t\t       cameraRight  *(float(right)   - float(left)    ) +\n        \t           cameraUp *(float(up)      - float(down)    )\n                      )*stepSize;\n    \n    if(mouseLeft){\n        if(mouseOld.z==0.){\n            mouseOld.xy = iMouse.zw;\n            mouseOld.z = 1.;\n        }\n\t\tvec2 s = iMouse.xy-mouseOld.xy;\n        s.x *= -1.0;\n        yaw_pitch = s * CAMERA_SENSITIVITY + yaw_pitch_old;\n\t\tclamp(yaw_pitch.y, -PI_TWO + 0.001, PI_TWO - 0.001);\n    }else{\n    \tmouseOld.z = 0.;\n\t\tyaw_pitch_old = yaw_pitch;   \n    }\n\t\n\tfloat ys = sin(yaw_pitch.x);\n\tfloat yc = cos(yaw_pitch.x);\n\tfloat ps = sin(yaw_pitch.y);\n\tfloat pc = cos(yaw_pitch.y);\n\tcameraForward = vec3(ys * pc, ps, yc * pc);\n\tcameraRight = normalize(cross(cameraForward, vec3(0.0, 1.0, 0.0)));\n\tcameraUp = normalize(cross(cameraRight, cameraForward));\n    \n    if(p.x==0){\n    \tfragColor.rgb = cameraPosition;\n    }else if(p.x==1){\n        fragColor.rgb = cameraForward;\n    }else if(p.x==2){\n        fragColor.rgb = cameraRight;\n    }else if(p.x==3){\n        fragColor.rgb = cameraUp;\n    }else if(p.x==4){\n        fragColor.rgb = mouseOld;\n    }else if(p.x==5){\n        fragColor.rgb = vec3(yaw_pitch, 0.0);\n    }else if(p.x==6){\n        fragColor.rgb = vec3(yaw_pitch_old, 0.0);\n    }\n    \n    fragColor.w = float(interaction);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/// Global configuration of ray marching\n#define HIT_THRESHOLD \t0.0001\n#define MAX_MARCHES \t400\n#define MAX_DEPTH\t\t2\n\n/// MANDELBOX PROPERTIES, PLAY WITH THEM :)\n#define ITERS \t\t\t26\t\nfloat fixed_radius2 \t= 2.8;\nfloat min_radius2 \t\t= 0.0;\nfloat folding_limit\t\t= 1.1;\nfloat scale \t\t\t= 1.5;\n\nvec3 mtl \t\t\t\t= vec3(0.9, 0.825, 0.85);\n\n/// LIGHT PROPERTIES\nconst vec3 l1_dir = normalize(vec3(0.49, 0.5, 0.25)); \nconst vec3 l1_col = vec3(1.2, 1.1, 1.) * 2.0;\n\nconst vec3 bg = vec3(0.7, 0.8, 1.05); \n\n/// Other params\n#define MOVEMENT_SPEED  \t10.\n#define MAX_SPEED       \t8.\n#define MIN_SPEED       \t1e-3\n#define CAMERA_POSITION \tvec3(7.5029, 8.6004, 7.4755)\n#define CAMERA_YAW_PITCH \tvec2(7.5180, 0.2310)\n#define CAMERA_SENSITIVITY \t0.003\n\nconst float exposure = 1.;\n\n/// ------------ END CONFIG --------- ///\n\n\nfloat stime, ctime, time;\n\n#define PI 3.14159265\n#define PI_TWO 1.5707963\n#define TAU 6.28318\n\n\nvoid sphere_fold(inout vec3 z, inout float dz) {\n    float r2 = dot(z, z);\n    if(r2 < min_radius2) {\n        float temp = (fixed_radius2 / min_radius2);\n        z *= temp;\n        dz *= temp;\n    }else if(r2 < fixed_radius2) {\n        float temp = (fixed_radius2 / r2);\n        z *= temp;\n        dz *= temp;\n    }\n}\n\nvoid box_fold(inout vec3 z, inout float dz) {\n    z = clamp(z, -folding_limit, folding_limit) * 2.0 - z;\n}\n\nfloat mb(vec3 z) {\n    vec3 offset = z;\n    float dr = 1.0;\n    for(int n = 0; n < ITERS; ++n) {\n        box_fold(z, dr);\n        sphere_fold(z, dr);\n\n        z = scale * z + offset;\n        dr = dr * abs(scale) + 0.1;\n    }\n    float r = length(z);\n    return r / abs(dr);\n}\n\nfloat f(vec3 p){ \n    return mb(p); \n} \n\n\n\n\n//makes sure that three 3 dimensional vectors are orthonormal\nvoid GramSchmidt33(inout vec3 a, inout vec3 b, inout vec3 c){\n    a = normalize(a);\n    b = b - dot(b,a)*a;\n    b = normalize(b);\n    c = c - dot(c,a)*a - dot(c,b)*b;\n    c = normalize(c);\n}\n\n//hashing noise by IQ\nfloat hash( uint n ) {\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n//random cos-weighted hemi-sphere sample\nvec3 getCosWeightedHemiSphereSample(vec3 n, uint seed) {\n  \tvec2  r  = vec2(hash(seed++),hash(seed++));;\n    \n\tvec3  uu = normalize(cross(n,vec3(0,1,1)));\n\tvec3  vv = cross( uu, n );\n\t\n\tfloat ra = sqrt(r.y);\n\tfloat rx = cos(TAU*r.x); \n\tfloat ry = sin(TAU*r.x);\n\tfloat rz = sqrt( 1.-r.y );\n    \n    return normalize( ra*(rx*uu + ry*vv) + rz*n );\n}\n","name":"Common","description":"","type":"common"}]}