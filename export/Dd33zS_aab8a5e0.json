{"ver":"0.1","info":{"id":"Dd33zS","date":"1677422615","viewed":186,"name":"Buffer as Distance Field","username":"SnoopethDuckDuck","description":"Press:\nWASD to move\nSpace to draw\nR to reset\n\nClick to see boundaries\n\nSometimes clipping occurs when the point moves too fast past boundaries, maybe could be avoided by using multiple steps","likes":14,"published":3,"flags":48,"usePreview":0,"tags":["distancefield","game","interactive","buffer"],"hasliked":0,"parentid":"dscGWH","parentname":"Test Walker (WIP)"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 px )\n{\n    vec4 txP = cell(ch0, ivec2(0,0)); \n    vec4 txB = cell(ch2, ivec2(px));\n    \n    // Distances for point and lines\n    vec2 n = norm(ch2, ivec2(txP.xy));\n    float d = length(px - txP.xy);       \n    float d2 = seg(px, txP.xy, txP.xy + 40. * n);\n    float d3 = seg(px, txP.xy, txP.xy + 40. * vec2(-n.y, n.x));\n    \n    // Step distances\n    float s  = smoothstep(-1.,1., br - d);\n    float s2 = smoothstep(-1.,1., 3. - d2);\n    float s3 = smoothstep(-1.,1., 3. - d3);\n    float sd = smoothstep(-1.,1., 2. - txB.r);\n    \n    // Boundary detection (not perfect)\n    float bnd = 0.;\n    for (float i = -1.; i <= 1.; i++)\n    for (float j = -1.; j <= 1.; j++) {\n        vec2 n2 = cell(ch2, ivec2(px+4.*vec2(i,j))).gb;\n        bnd += dot(n2, txB.gb);\n    }\n    bnd /= 9.;\n    \n    // Draw stuff\n    vec3 col = (1.-txB.r/iResolution.y) * vec3(1, 0.5+0.5*txB.gb);\n    col = mix(col, vec3(1), sd);\n    col = mix(col, vec3(1,1,0.5), 0.8 * s2);\n    col = mix(col, vec3(1,0.5,1), 0.8 * s3);\n    col = mix(col, vec3(1), s);\n    \n    if (iMouse.z > 0.)\n        col *= vec3(bnd);\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define KEYBOARD iChannel1\n\n// This buffer stores point information\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txP = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txA = cell(ch0, ipx);         \n    vec4 txB = cell(ch2, ipx);\n    \n    // Initialize point on reset\n    if (iFrame < 1 || key_down(KEY_RESET)) {\n        if (ipx == ivec2(0,0) || ipx == ivec2(0,1))        \n            txA = vec4(floor(0.5 * res), 0, 0);      \n    }\n    \n    float spd = 0.5;\n    if (ipx == ivec2(0, 0)) {\n        // Update velocity\n        txA.z += spd * (key_val(KEY_D) - key_val(KEY_A));\n        txA.w += spd * (key_val(KEY_W) - key_val(KEY_S));\n        txA.zw *= 0.95;\n        \n        // Old/New distance to buffer\n        float d0 = cell(ch2, ivec2(txA.xy)).r;          \n        float d1 = cell(ch2, ivec2(txA.xy + txA.zw)).r; \n        \n        // Normal\n        vec2 n = norm(ch2, ivec2(txA.xy));\n        \n        // If crossed boundary then push back\n        // (could use (-n.y,n.x) to slide along distances instead)\n        if (d0 > br && d1 < br) \n            txA.zw = -n * length(txA.zw);\n        \n        // Update position\n        txA.xy += txA.zw;               \n    } \n    // Save old position\n    else if (ipx == ivec2(0, 1)) \n        txA = txP;\n   \n   fragColor = txA;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define res iResolution.xy\n\n// Ball radius\n#define br 14.\n\n#define key_val(key) texelFetch(KEYBOARD, ivec2(key, 0), 0).x\n#define key_down(key) int(key_val(key)) == 1\n#define KEY_RESET 82\n#define KEY_SPACE 32\n#define KEY_A 65\n#define KEY_W 87\n#define KEY_D 68\n#define KEY_S 83\n\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n\nvec4 cell(in sampler2D ch, in ivec2 p) {\n    ivec2 r = ivec2(textureSize(ch, 0));\n    p = (p+r) % r;\n    return texelFetch(ch, p, 0);\n}\n\n// Taken from stb's shader:\n// https://www.shadertoy.com/view/3tfcDM\nvec2 norm(in sampler2D ch, in ivec2 p) {\n    ivec3 e = ivec3(0, -1, 1);\n    return normalize(vec2(cell(ch, p-e.zx).r - cell(ch, p-e.yx).r,\n                          cell(ch, p-e.xz).r - cell(ch, p-e.xy).r));\n}\n\nfloat seg(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define KEYBOARD iChannel1\n\n// This buffer stores distances\n\nvoid mainImage( out vec4 fragColor, in vec2 px )\n{\n    ivec2 ipx = ivec2(px);\n    \n    vec4 txP  = cell(ch0, ivec2(0, 0)); // Point\n    vec4 txP0 = cell(ch0, ivec2(0, 1)); // Previous point\n    vec4 txB  = cell(ch2, ipx);\n    \n    // Initialize distances on reset\n    // (maybe res.x is more appropriate?)\n    if (iFrame < 1 || key_down(KEY_RESET)) \n        txB = vec4(res.y ,0,0,0);   \n    \n    // Draw distances if space pressed\n    if (key_down(KEY_SPACE)) {\n        float d = seg(px, txP.xy, txP0.xy);\n        //d = mix(d, res.y, 0.5 + 0.5 * thc(20., 25. * iTime));\n        txB.r = min(txB.r, d);\n        vec2 n = norm(ch2, ivec2(px));\n        txB.gb = n;\n    }\n    \n    fragColor = txB;\n}","name":"Buffer B","description":"","type":"buffer"}]}