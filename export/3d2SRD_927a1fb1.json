{"ver":"0.1","info":{"id":"3d2SRD","date":"1553101687","viewed":300,"name":"Rainbow Crocs","username":"bignobody","description":"Second Gyroid raymarch experiment. Closed up the gyroid a little more, tinted the colours and punched some holes.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","gyroid"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 64\n#define EPSILON 0.02\n#define MAX_DIST 500.0\n\nfloat gyroidSDF(vec3 p , float s)\n{\n//\tfloat g = cos(p.x) * sin(p.y) + cos(p.y) * sin(p.z) + cos(p.z) * sin(p.x);\n    float g = dot(cos(p),sin(p.yzx));\t// shorthand suggested by Shane\n    return length(normalize(p) * g * s);\n\n}\n\nfloat sphereSDF(vec3 p, float r)\n{\n \treturn length(p)-r;   \n}\n\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSub( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opInter( float d1, float d2 ) { return max(d1,d2); }\n\n\nfloat opRep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sphereSDF(q, 0.11);\n}\n\nfloat sceneSDF(vec3 p)\n{\n\n    return opSub(opRep(p,vec3(0.33,0.33,0.33)), gyroidSDF(p, 0.314159 ));\n}\n\n\nfloat distToSurface( vec3 eye, vec3 dir, float startDist, float endDist )\n{\n\tfloat depth = startDist;\n\tfor (int i = 0; i < MAX_STEPS; i++) \n    {\n    \tfloat dist = sceneSDF(eye + depth * dir);\n    \tif (dist < EPSILON) \n        {\n        // We're inside the scene surface!\n        return depth;\n    \t}\n    \t// Move along the view ray\n    \tdepth += dist;\n\n    \tif (depth >= MAX_DIST) \n        {\n        \t// Gone too far; give up\n        \treturn endDist;\n    \t}\n    }\n    return endDist;\n}\n\nvec3 estimateNormal(vec3 p) \n{\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // pixel coordinates (from -1 to 1)\n    vec2 uv = (fragCoord/iResolution.xy)* 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\n    // camera setup and ray cast\n    float zoom = 0.45;\n    float ext = iTime * 0.6;\n    vec3 lookAt = vec3(cos(ext)*4.0,0.0,ext);\n    vec3 camOrigin = vec3(0.0,1.0,-10.0 + ext);\n\tvec3 forwardVec = normalize(lookAt - camOrigin);\n    vec3 rightVec = normalize(cross(vec3(0.0,1.0,0.0),forwardVec));\n    vec3 upVec = cross(forwardVec,rightVec);\n    \n    vec3 centerVec = camOrigin + forwardVec * zoom;\n    vec3 intersectVec = centerVec + uv.x * rightVec + uv.y * upVec;\n    vec3 rayDirection = normalize(intersectVec - camOrigin);\n\n    float d = distToSurface(camOrigin,rayDirection, 0.0,MAX_DIST);\n\tvec3 g = estimateNormal(camOrigin + rayDirection * d);\n    d = d/length(g);\n  \tvec3 p = camOrigin + rayDirection * d;\n  \n   \t\n    if (d > MAX_DIST-EPSILON)\n    {\n     \t// no hit\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n        return;\n    }\n\tvec3 bc = vec3(-0.1+g.y,-0.9+g.y,1.0-g.x);\n    vec3 col = vec3(clamp(d,0.0,0.99))*(bc+g);\n\n    fragColor = vec4(col,1.0);\n}\n\n","name":"Image","description":"","type":"image"}]}