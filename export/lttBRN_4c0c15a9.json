{"ver":"0.1","info":{"id":"lttBRN","date":"1538888637","viewed":136,"name":"My First Ray Tracer","username":"CliqCity","description":"Following along with Ray Tracing in One Weekend by Peter Shirley","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float amp = 43758.5453123;\n\nconst vec2 seed2 = vec2(12.9898,78.233);\n\nconst vec3 seed3 = vec3(12.9898,78.233, 101.5423324);\n\nfloat pi = 3.14159265359;\n\nstruct camera\n{\n \tvec3 origin;\n    vec3 lower_left_corner;\n    vec3 horizontal;\n    vec3 vertical;\n    vec3 f;\n    vec3 s;\n    vec3 u;\n    float lens_radius;\n};\n    \nstruct sphere\n{\n  \tvec3 center;\n    float radius;\n    int material;\n};\n    \nstruct material\n{\n    vec3 color;\n    int scatter;\n    float fuzz;\n    float refr;\n};\n\nstruct ray\n{\n    vec3 p;\n    vec3 v;\n};\n\nstruct hit\n{\n  \tvec3 p;\t// point of hit\n    vec3 n;\t// surface normal\n    vec3 s; // scattered ray\n    vec3 a;\t// albedo\n    float t;\n};\n\nfloat random(float val) \n{\n    return fract(sin(val) * amp);\n}\n\nfloat random(vec2 val)\n{\n \treturn fract(sin(dot(val, seed2)) * amp);\n}\n\nfloat random(vec3 val)\n{\n \treturn fract(sin(dot(val, seed3)) * amp);\n}\n\nfloat safe_random(float val)\n{\n    highp float c = 43758.5453;\n    highp float sn= mod(val,3.14);\n    return fract(sin(sn) * c);\n}\n\nfloat safe_random(vec2 val)\n{\n \thighp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(val.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\n\nvec3 random_in_unit_cube(vec3 n)\n{\n \tfloat x = random(n.x) - 0.5;\n \tfloat y = random(n.y) - 0.5;   \n \tfloat z = random(n.z) - 0.5;   \n\treturn vec3(x,y,z);\n}\n\nvec3 random_in_unit_sphere(vec3 n)\n{\n\n    float twopi = 2.0 * pi;\n    float piover2 = pi * 0.1;\n \tfloat phi = random(n.x) * twopi;\n    float theta = random(n.y) * pi;\n    float r = random(n.z);\n    float x = r*sin(theta) * cos(phi);\n    float y = r*sin(theta) * sin(phi);\n    float z = r*cos(theta);\n    return vec3(x, y, z);\n}\n\nvec3 random_in_unit_disk(float a, float n)\n{\t\n    float theta = random(a) * 2.0 * pi;\n    float r = random(n);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    return vec3(x,y,0);\n}\n\nfloat schlick(float cosine, float iRef)\n{\n \tfloat r0 = (1.0 - iRef) / (1.0 + iRef);\n    r0 = r0*r0;\n    return r0 + (1.0 - r0) * pow((1.0 - cosine), 5.0);\n}\n\ncamera make_camera(vec3 origin, vec3 target, vec3 up, float fov, float aspect, float aperture, float focus)\n{\n    float theta = fov * (pi/180.0);\n    float hh = tan(theta* 0.5);\n    float hw = aspect * hh;\n    \n    vec3 w = normalize(origin - target);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = cross(w, u);\n    \n \tcamera c;\n    c.lower_left_corner = origin-hw*focus*u-hh*focus*v-focus*w;\n    c.horizontal = 2.0*hw*focus*u;\n    c.vertical = 2.0*hh*focus*v;\n    c.origin = origin;\n    c.lens_radius = aperture * 0.5;\n    c.s = u;\n    c.u = v;\n    c.f = w;\n    return c;\n}\n\nray make_ray(camera c, float u, float v)\n{\n    vec3 d = c.lens_radius*random_in_unit_disk(u, v);\n    vec3 o = c.s*d.x + c.u*d.y;\n    \n\tray r;\n    r.p = c.origin + o;\n    r.v = c.lower_left_corner+u*c.horizontal+v*c.vertical-c.origin-o;\n    return r;\n}\n\nvoid scatter(int s, ray r, material m, out hit h)\n{\n \tif (s == 0)\n    {\n    \th.s =  h.p + h.n + random_in_unit_sphere(h.p) - h.p;  \n    }\n    else if (s==1)\n    {\n    \th.s = reflect(normalize(r.v), h.n) + random_in_unit_sphere(h.n) * m.fuzz;\n    \tif (dot(r.v, h.n) > 0.0)\n      \t{\n      \t\th.a = vec3(0,0,0);\n      \t}\n    }\n    else\n    {\n        vec3 on;\n        float ni_over_nt;\n        float cosine;\n        vec3 rn = normalize(r.v);\n        if (dot(r.v, h.n) > 0.0)\n      \t{\n\t\t\ton = -h.n;\n            ni_over_nt = m.refr;\n            cosine = m.refr * dot(rn, h.n);\n        }\n        else\n        {\n         \ton = h.n;\n            ni_over_nt = 1.0f / m.refr;\n            cosine = -dot(rn, h.n);\n        }\n        \n        float p;\n        float d = dot(rn, h.n);\n        float disc = 1.0 - ni_over_nt*ni_over_nt*(1.0-d*d);\n \t\t\n        if (disc > 0.0)\n        {\n            p = schlick(cosine, m.refr);\n        }\n        else\n        {\n            p = 0.9;\n        }\n        \n\t\tif (random(h.n) < p)\n        {\n            h.s = reflect(r.v, h.n);\n        }\n        else\n        {\n            h.s = refract(rn, on, ni_over_nt);\n        }\n        \n        h.a = vec3(1,1,1);\n    }\n}\n    \nbool hit_sphere(ray r, sphere s, material m, out hit h)\n{\n    vec3 n = r.v;\n    vec3 o = r.p - s.center;\n    float a = dot(n,n);\n    float b = dot(o,n);\n    float c = dot(o,o) - s.radius * s.radius;\n    float d = b*b - a*c;\n   \t\n    if (d > 0.0)\n    {\n    \tfloat t = (-b - sqrt(b*b - a*c))/a;\n        if (t > 0.001)\n        {\n            vec3 n = r.v;\n        \th.p = r.p + n*t;\n        \th.n = (h.p - s.center) / s.radius;\n            h.a = m.color;\n            h.t = t;\n            scatter(m.scatter, r, m, h);\n        \treturn true;\n        }\n        \n        t = (-b + sqrt(b*b - a*c))/a;\n        if (t > 0.001)\n        {\n            vec3 n = r.v;\n        \th.p = r.p + n*t;\n        \th.n = (r.p - s.center) / s.radius;\n            h.a = m.color;\n            h.t = t;\n            scatter(m.scatter, r, m, h);\n        \treturn true;\n        }\n    }\n    \n    return false;\n}\n\nvec3 rayCast(ray r)\n{\n    const int nSpheres = 5;\n    sphere s[5];\n    s[0].center = vec3(0,0,-1);\n    s[1].center = vec3(0,-100.5,-1);\n    s[2].center = vec3(1,0,-1);\n    s[3].center = vec3(-1,0,-1);\n    s[4].center = vec3(-1,0,-1);\n\n    s[0].radius = 0.5;\n    s[1].radius = 100.0;\n    s[2].radius = 0.5;\n    s[3].radius = 0.5;\n    s[4].radius = -0.45;\n\n    s[0].material = 0;\n    s[1].material = 1;\n    s[2].material = 2;\n    s[3].material = 3;\n    s[4].material = 3;\n\n    const int nMaterials = 4;\n    material m[nMaterials];\n    m[0].color = vec3(0.1,0.2,0.5);\n    m[1].color = vec3(0.8,0.8,0.0);\n    m[2].color = vec3(0.8,0.6,0.2);\n    m[3].color = vec3(0.8,0.8,0.8);\n    \n    m[0].scatter = 0;\n    m[1].scatter = 0;\n    m[2].scatter = 1;\n    m[3].scatter = 2;\n    \n    m[0].fuzz = 0.0;\n    m[1].fuzz = 0.0;\n    m[2].fuzz = 0.3;\n    m[3].fuzz = 0.8;\n    \n    m[0].refr = 0.0;\n    m[1].refr = 0.0;\n    m[2].refr = 0.0;\n    m[3].refr = 1.5;\n\n\n    vec3 d = normalize(r.v);\n\tvec3 color = vec3(1,1,1);\n    float attenuation = 0.9;\n    const int nBounces = 5;\n    int nb = 0;\n    float t = 10000.0;\n    for (int j=0;j<nBounces;++j)\n    {\n        hit final;\n        final.t = t;\n        \n        for (int i = 0; i < nSpheres; ++i)\n    \t{\n\t\t\thit h;\n            if (hit_sphere(r, s[i], m[s[i].material], h)) \n    \t\t{\n                if (h.t < final.t)\n                {\n                 \tfinal = h;\n                }\n\t\t\t\t              \n            }\n    \t}\n        \n        if (final.t < t)\n        {\n         \t    nb++;\n                color *= final.a;\n                r.p = final.p;\n                r.v = final.s; \n        }\n    }\n    \n    t = d.y * 0.5 + 1.0;\n  \tcolor *= (1.0-t)*vec3(1.0,1.0,1.0) + vec3(0.5,0.7,1.0) * t;\n\n    return color;\n}\n\nint SAMPLES = 50;\nfloat INV_SAMPLES = 1.0 / 50.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 color = vec3(0.0,0.0,0.0);\n    \n    float theta = iTime * 0.1;\n    float x = sqrt(8.0) *cos(theta);\n    float z = sqrt(8.0) * sin(theta);\n    vec3 p = vec3(x, 1,z);\n    \n    vec3 up = vec3(0,1,0);\n    vec3 origin =  vec3(-0.5,1,0.5);\n    vec3 direct = vec3(0,0,-1);\n    vec3 target = vec3(0,0,-1);\n   \tfloat fov = 90.0;\n    float aspect = iResolution.x / iResolution.y;\n    float focus  = length(origin - target);\n    float aperture = 0.01;\n    \n    camera c = make_camera(origin, target, up, fov, aspect, aperture, focus);\n    \n    for (int i = 0; i < SAMPLES; ++i)\n    {\n        vec2 o;\n        o.x = random(fragCoord.xy * float(i)) - 0.25;\n\t\to.y = random(fragCoord.yx * float(i)) - 0.25;\n        \n    \tvec2 uv = (fragCoord + o)/iResolution.xy;        \n        ray r = make_ray(c, uv.x, uv.y);\n        color += rayCast(r);\n    }\n    \n    color *= INV_SAMPLES;    \n    color = sqrt(color);\n    \n    fragColor = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"}]}