{"ver":"0.1","info":{"id":"3l3BRl","date":"1613215103","viewed":233,"name":"Simple Heart SDF","username":"lumic","description":"Simple Heart from two semi-circles + mirroring","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["sdf","heart"],"hasliked":0,"parentid":"Wt3BWN","parentname":"Deadmau5 SDF shader"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float PI = 3.14159265359;\n\nvec2 squareFrame(vec2 screenSize, vec2 coord) {\n  vec2 position = 2.0 * (coord.xy / screenSize.xy) - 1.0;\n  position.x *= screenSize.x / screenSize.y;\n  return position;\n}\n\nfloat sdCircle(vec2 p, vec2 center, float r)\n{\n    return length(p - center) - r;\n}\n\nfloat sdBox(vec2 p, vec2 bottomLeft, vec2 topRight)\n{\n    vec2 center = 0.5 * (bottomLeft + topRight);\n    vec2 extents = 0.5 * (topRight - bottomLeft);\n    vec2 d = abs(p -  center) - extents;\n    return length(max(d, vec2(0, 0))) + min(max(d.x, d.y), 0.0);\n}\n\nvec2 rotate(vec2 p, float deg) {\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    float radians = angle + deg / 360.0 * (2.0 * PI);\n    return vec2(r * cos(radians), r * sin(radians));\n}\n\nfloat combine( float d1, float d2 ) { return min(d1,d2); }\nfloat difference( float d1, float d2 ) { return max(d1,-d2); }\nfloat intersect( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smoothIntersect( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat mixer() {\n    return (sin(iTime * 1.5) + 1.0) * 0.5;\n}\n\n\nfloat heart(vec2 p) {\n    // Mirror -x half plane into +x\n    p.x =  -abs(p.x);\n\n\n    float upperRadius = 0.2;\n    float lowerRadius = 0.55;\n    \n    float upperHalf =  sdCircle(p, vec2(-upperRadius,0), upperRadius);\n    \n    // Slightly increased extents for subtractive box to avoid small artifacts\n    upperHalf = difference(upperHalf, sdBox(p, vec2(-upperRadius * 2.1, -upperRadius * 1.1), vec2(0.1, 0)));\n    \n    float lowerHalf = sdCircle(p, vec2(-upperRadius * 2.0 + lowerRadius, 0), lowerRadius);\n    lowerHalf = difference(lowerHalf, sdBox(p, vec2(-upperRadius * 2.1, 0), vec2(lowerRadius, lowerRadius * 1.1)));\n    \n    float combined = combine(upperHalf, lowerHalf);\n    \n    return combined;\n}\n\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  float t = 0.0f;\n  vec2 uv = squareFrame(iResolution.xy, fragCoord);\n  float d;\n  vec3 col;\n  vec2 ro = vec2(iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n  ro.x *= squareFrame(iResolution.xy, iResolution.xy).x;\n\n  vec2 rd = normalize(-ro);\n\n  vec2 p = uv - vec2(0, 0.15);\n\n  d = heart(p);\n\n  col = vec3(draw_solid(d));\n\n  fragColor.rgb = col;\n  fragColor.a   = 1.0;\n}","name":"Image","description":"","type":"image"}]}