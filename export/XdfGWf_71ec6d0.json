{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"cubemap","id":"4dX3zn","filepath":"/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}}],"code":"//#define AMIGA_VERSION\nconst float PI = 3.14159265359;\nconst float INV_PI = 0.5 * 0.31830988618;\n\nstruct LightingData \n{\n\tvec3 L;\n\tvec3 N;\n\tvec3 H;\n    vec3 I;\n    vec3 GI;\t\n\tfloat roughness;\n};\n\t\n\t\n//Ray are thrown from the origin\n//d is normalized\nbool RaySphereIntersect(in vec3 rd, in vec3 sphereCenter, in float radius, out vec3 position)\n{\n\tfloat s = dot(sphereCenter, rd);\n\tfloat r2 = radius*radius;\n\tfloat l2 = dot(sphereCenter,sphereCenter);\n\tif (s<0. && l2>r2) \n\t{\n\t\treturn false;\n\t}\n\tfloat m2 = l2 - s*s;\n\tif (m2>r2)\n\t{\n\t\treturn false;\n\t}\n\t\n\tfloat q = sqrt(r2-m2);\n\tfloat t=0.;\n\tif (l2>r2)\n\t{\n\t\tt=s-q;\n\t}\n\telse\n\t{\n\t\tt=s+q;\n\t}\n\tposition=t*rd;\n\treturn true;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat head=iTime*0.5; float pitch= 0., roll = 0.;roll=iTime*0.5;\n\tfloat ch=cos(head); float cp=cos(pitch); float cr=cos(roll); \n\tfloat sh=sin(head); float sp=sin(pitch); float sr=sin(roll); \n\tmat3 rot;\n\trot[0] = vec3(cr*ch-sr*sp*sh,sr*ch+cr*sp*sh,-cp*sh);\n\trot[1] = vec3(-sr*cp,cr*cp,sp);\n\trot[2] = vec3(cr*sh+sr*sp*ch,sr*sh-cr*sp*ch,cp*ch);\n\t\n\t// camera\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;    \n\tvec3 ro = rot*vec3(1.0,0.0,0.);\n\tvec3 ww = normalize(vec3(0.0,0.0,0.0) - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.4*ww); //ray direction in world space\n\n\tvec3 sphereCenter = 10.*ww; \n\tfloat radius = 4.;\n\t\n\tvec3 finalColor = vec3(0.0,0.0,0.0); \n\tvec3 lightPosition, position;\n\tvec2 mo = iMouse.xy/iResolution.xy;\n\tmo = PI*(mo-0.5);\n\t\n\tfloat theta = PI/2.-mo.y;float stheta = sin(theta); float ctheta = cos(theta);\n\tfloat phi = mo.x;float sphi = sin(phi);float cphi = cos(phi);\n\t//spherical coordinates in direct frame (-ww,uu,vv)\n    float xl = stheta*cphi; float yl = stheta*sphi; float zl = ctheta;\n\t\n\tlightPosition = sphereCenter + 6.*radius*(-xl*ww+ yl*uu+zl*vv);\t\t\t\t\n\tif (RaySphereIntersect(rd, sphereCenter,  radius, position))\n\t{\n\t\t//Rendering equation\t\t\n\t\tLightingData data;\n\t\tdata.L = normalize(vec3(lightPosition-position));\n\t\tdata.N = normalize(position-sphereCenter);\n\t\tdata.I = vec3(2000.)/pow(length(lightPosition-position),2.);\n\t\tdata.GI = (texture(iChannel1,data.N)).xyz;\n\t\tdata.roughness = 50.;\n\t\tvec3 V = normalize(-position);\n\t\tdata.H = normalize(data.L+V);\t\t\n\t\tvec3 reflected = reflect(rd,data.N);\n\t\tvec3 albedo;\n\t\t\n#ifndef AMIGA_VERSION\n\t\tvec2 uv = vec2(asin(data.N.x)*INV_PI + 0.5,asin(data.N.y)*INV_PI+0.5); \t\t\n\t\talbedo = (texture(iChannel2, uv)).xyz;\t\n#else\n\t\tvec3 p = normalize(position-sphereCenter);\n\t\tvec2 coords = (vec2(acos(p.y),atan(p.x/p.z)));\n     \tcoords = INV_PI*vec2(coords.x,PI*0.5+coords.y);\t\t//coords is now between 0 and 1\n       \tcoords = floor(20.*coords);\t\t\n\t\tif ((coords.x+coords.y != floor((coords.x+coords.y)/2.)*2.))\n\t\t\talbedo = vec3(1.,0.,0.0);\n\t\telse\n\t\t\talbedo = vec3(1.,1.,1.0);\t\t\n#endif\n\t\t\n\t\tvec3 specularColor = (texture(iChannel0,reflected)).xyz;\n\t\t\n\t\tvec3 diffuseContrib = data.I*albedo*INV_PI*max(0.0,dot(data.N,data.L));\n\t\tvec3 specularContrib = data.I*specularColor*pow(max(0.0,dot(data.N,data.H)),data.roughness);\t\t\n\t\t\n\t\tfloat N2 = dot(data.N,data.N);\n\t\tvec3 GIdiffuseContrib = data.GI*albedo*INV_PI*N2;\n\t\tvec3 GIspecularContrib = data.GI*specularColor*pow(N2,data.roughness);\t\t\n\t\t\n\t\tfinalColor = diffuseContrib + specularContrib + 0.25*(GIdiffuseContrib + GIspecularContrib);\t\t\t\n\n\n\n\t}\n\telse\n\t{\n        finalColor=texture( iChannel0, rd ).xyz;\n\t}\n\t\n\n\tfragColor = vec4(finalColor,1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"XdfGWf","date":"1380235410","viewed":1008,"name":"Simple Sphere2","username":"benito_luna","description":"Simple Ray-traced sphere lit with specular and diffuse Blinn Phong BRDF\n- Use the mouse to move the light\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["sphere"],"hasliked":0,"parentid":"","parentname":""}}