{"ver":"0.1","info":{"id":"ssGBWW","date":"1658334580","viewed":130,"name":"CHAINS","username":"rooby","description":"Trying out domain repetition to animate moving chains.","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["domainrepetition","chains"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 50.\n#define MIN_DIST 0.0001\n\n#define PI 3.14159\n\nconst vec3 SUN_DIR = normalize(vec3(2., 0.5, 3.));\n\nconst vec3 SUN_COL = vec3(1.64, 1.27, 0.99);\nconst vec3 SKY_COL = vec3(0.16, 0.20, 0.28);\nconst vec3 IND_COL = vec3(0.40, 0.28, 0.20);\n\nconst vec3 FOG_COL = vec3(0.5, 0.6, 0.7);\n\n// Return 2D rotation matrix of angle a\nmat2 rot(float a)\n{\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec2 edge(vec2 p) \n{\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0.);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\n// Signed distance to a link, thanks to https://iquilezles.org/articles/distfunctions/\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n\nfloat sdChain(vec3 pos)\n{  \n    float d=1000.;\n\n    for (int i=-1; i<2; i++)\n    {\n        vec3 center = vec3(0, 0, (floor((pos.z+1.)/1.5) + float(i))*1.5);\n\n        vec3 p = pos - center;\n        p = vec3(rot(PI*center.z/4.)*p.xy, p.z);\n        p = p.xzy;\n        \n        d = min(d, sdLink(p, .5, .37, .15));\n    }\n    \n    return d;\n}\n\n// Compute signed distance to scene\nvec2 sdScene(vec3 pos)\n{\n   float d;\n   \n   float rep = 1.2;\n   \n   vec2 center = (floor(pos.xy/rep)+.5)*rep;\n   vec2 neighbour = center.xy + rep*edge(pos.xy - center); \n    \n   float height = center.x*center.y + (1.+2.*sin(center.x+center.y))*iTime;\n    \n   float me = sdChain(pos - vec3(center, height));\n   float next = length(pos.xy - neighbour) - 0.52;\n   \n   d = min(me, next);\n   \n   return vec2(d, 0.);\n}\n\n// Get normal vector at pos\nvec3 getNormal(vec3 pos)\n{\n    vec2 u = vec2(0.001, 0);\n\n    return normalize(vec3(sdScene(pos + u.xyy).x - sdScene(pos - u.xyy).x,\n                    sdScene(pos + u.yxy).x - sdScene(pos - u.yxy).x,\n                    sdScene(pos + u.yyx).x - sdScene(pos - u.yyx).x));\n}\n\n// Standard raymarching function, with soft shadows\nvec3 rayMarch(vec3 rayOrigin, vec3 rayDir)\n{\n    float depth = 0.;\n    float shadow = 1.;\n    float ph = 1e20;\n    int mat_type = 0;\n    \n    for (int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = rayOrigin + depth * rayDir;\n        vec2 dist = sdScene(pos);\n        \n        depth += dist.x;\n        mat_type = int(dist.y);\n        \n        float y = dist.x*dist.x/(2.0*ph);\n        float d = sqrt(dist.x*dist.x-y*y);\n        shadow = min(shadow, 8.*d/max(0.0,depth-y) );\n        \n        if (abs(dist.x) < MIN_DIST) return vec3(depth, mat_type, shadow);\n        if (depth > MAX_DIST) return vec3(-1, 0, shadow);\n    }\n\n    return vec3(depth, mat_type, shadow);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates \n    vec2 uv = 2.*(fragCoord - .5*iResolution.xy) / iResolution.y;\n\n    // Camera ray origin and direction\n    vec3 rayOrigin = vec3(0., 0., 0);\n    vec3 rayDir = vec3(uv.x, .5, uv.y);\n    rayDir = vec3(rayDir.xy*rot(.3*iTime), rayDir.z);\n\n    // Do raymarching\n    vec3 u = rayMarch(rayOrigin, rayDir);\n    float depth = u.x;\n    vec3 pos = rayOrigin + depth*rayDir;\n    int mat_type = int(u.y); \n        \n    // Compute color of the pixel at fragCoord\n    float t = sqrt(1.2+uv.y);\n    vec3 col = t*vec3(0.05, 0.63, 1.);\n    if (depth > 0.)\n    {\n        vec3 mat = vec3(0.3);\n        vec3 normal = getNormal(pos);\n        \n        // Intensity of sun light\n        float sun_int = clamp(dot(normal, SUN_DIR), 0., 1.);\n        \n        // Compute shadows\n        vec3 u = rayMarch(pos + 0.1*normal, SUN_DIR);\n        float shadow = u.z;\n        \n        // Apply lighting to material\n        vec3 lighting = shadow*sun_int*SUN_COL;\n        col = lighting * mat;\n    }\n\n    // Apply fog\n    float fog_int = 1. - exp(-depth*0.02);\n    col = mix(col, FOG_COL, fog_int);\n    \n    // Gamma correction\n    col = pow(col, vec3(1./2.2));\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}","name":"Image","description":"","type":"image"}]}