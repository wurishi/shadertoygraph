{"ver":"0.1","info":{"id":"XldBzs","date":"1540733929","viewed":99,"name":"controled_mandelbrot","username":"JSingh64","description":"FRACTAL CONTROLS:\n    WASD - movement;\n    Q - zoom in;\n    E - zoom out;\n   \n    G - change type (Mandelbrot/GCD);\n    H - aliasing None/x4/x8;\n    0, 1, 2, 3, 4, 5, 6 - color scheme;\n   \n    R - restore;","likes":0,"published":1,"flags":48,"usePreview":0,"tags":["fractal","mandelbrot","aliasing","keyboard","gcd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// ========= COLOR FUNCTIONS FOR M. SET ==========\nvec4    black_white_fill    (vec2 complex);\nvec4    colorized_sin       (vec2 complex);\nvec4    colorized_fill      (vec2 comples);\n\n// CHANGING COLOR WORKS ONLY FOR SIN COLORING\nbool  CHANGING_COLOR = false; \nfloat COLOR_FUNCTION = 1.0;\n// =========== END OF COLOR FUNCTUIONS ===========\n\nconst float LEFT_BORDER     = -2.0;\nconst float RIGHT_BORDER    =  1.0; \nconst float TOP_BORDER      =  1.2;\nconst float BOTTOM_BORDER   = -1.2;\n\nconst float SPEED           =  0.8;\n\nconst vec2  MAIN_SHIFT      =  vec2(-0.25, 0.0);\n\nconst int   MAX_ITERS       =  128;\nconst float BAIL_OUT        =  4.0;\n\nconst float AA_SHIFT        =  0.3;\n\n\n// program units\nvec2    transform_coords    (vec2 fragCoord, vec2 center, float zoom);\nvec2    complex_multiply    (vec2 v, vec2 u);\n\n\n// antialiasing function\nvec4    count_point_color   (out float success, in vec2 fragCoord);\nvec4    simple_render       (vec2 fragCoord);\nvec4    antialiasing_x4     (vec2 fragCoord);\nvec4    antialiasing_x8     (vec2 fragCoord);\n\n\n// color scheme\nvec3  generate_color(void);\nconst vec3 RED_COLOR        = vec3(0.8, 0.1, 0.0);\nconst vec3 BLUE_COLOR       = vec3(0.2, 0.1, 0.8);\nconst vec3 GREEN_COLOR      = vec3(0.1, 0.8, 0.2);\nconst vec3 PURPLE_COLOR     = vec3(0.5, 0.0, 0.6);\nconst vec3 CLASSIC_COLOR    = vec3(0.0, 0.6, 1.0);\n      vec3 CURRENT_COLOR    = CLASSIC_COLOR;\n\n\n// another fractal\nvec4    build_gcd (vec2 fragCoord);\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 config = texture(iChannel1, fragCoord);\n    float color_scheme   = config.x;\n    float aliasing_level = config.y;\n    float fractal_type   = config.z;\n    \n    if (color_scheme == 0.0) {\n        CURRENT_COLOR = CLASSIC_COLOR;\n        COLOR_FUNCTION = 0.0;\n    } else if (color_scheme == 1.0) {\n        COLOR_FUNCTION = 1.0;\n    } else if (color_scheme == 2.0) {\n        CHANGING_COLOR = false;\n        CURRENT_COLOR = RED_COLOR;\n        COLOR_FUNCTION = 2.0;\n    } else if (color_scheme == 3.0) {\n        CHANGING_COLOR = false;\n        CURRENT_COLOR = BLUE_COLOR;\n        COLOR_FUNCTION = 2.0;\n    } else if (color_scheme == 4.0) {\n        CHANGING_COLOR = false;\n        CURRENT_COLOR = GREEN_COLOR;\n        COLOR_FUNCTION = 2.0;\n    } else if (color_scheme == 5.0) {\n        CHANGING_COLOR = false;\n        CURRENT_COLOR = PURPLE_COLOR;\n        COLOR_FUNCTION = 2.0;\n    } else if (color_scheme == 6.0) {\n        CHANGING_COLOR = true;\n        COLOR_FUNCTION = 2.0;\n    }\n    \n    if (fractal_type == 0.0) {\n        if (aliasing_level == 1.0) {\n    \t\tfragColor = simple_render(fragCoord);\n        } else if (aliasing_level == 2.0) {\n            fragColor = antialiasing_x4(fragCoord);\n        } else {\n        \tfragColor = antialiasing_x8(fragCoord);\n        }\n    } else {\n    \tfragColor = build_gcd(fragCoord);\n    }\n}\n\n\nbool is_prime(int n) \n{\n    int border = int(sqrt(float(n)));\n    for (int i = 2; i <= border; ++i) {\n        if ((n % i) == 0) {\n        \treturn false;\n        }\n    }\n    return true;\n}\n\n\nvec4 build_gcd(vec2 fragCoord)\n{\n    vec4 config      = texture(iChannel1, fragCoord);\n    float operation  = config.y;\n    \n    vec4 move_config = texture(iChannel0, fragCoord);\n    vec2 center      = move_config.xy;\n\tfloat zoom \t     = move_config.z; \n    \n    fragCoord *= (zoom + 1.0);\n    fragCoord += (-center + 1.0) * 200.0;\n    \n    int x = int(fragCoord.x + iMouse.x * 5.0);\n    int y = int(fragCoord.y + iMouse.y * 5.0);\n    \n    int temp;\n    if (operation == 0.0) {\n        temp = x ^ y;\n    } else if (operation == 1.0) {\n        temp = x | y; \n    } else {\n        temp = x & y;\n    }\n\n    if (is_prime(temp)) {\n    \treturn vec4(CURRENT_COLOR, 1.0);\n    } else {\n        return vec4(0.0);\n    }\n}\n\n\nvec4 count_point_color(out float success, in vec2 fragCoord)\n{\n    float x_coord = fragCoord.x;\n    float y_coord = fragCoord.y;\n    \n    bool check  =    (x_coord >= 0.0) && (x_coord < iResolution.x);\n    check = check && (y_coord >= 0.0) && (y_coord < iResolution.y);\n    \n    if (check) {\n        \n        vec4  pos_config = texture(iChannel0, fragCoord);\n        vec2  center     = pos_config.xy; \n        float zoom       = pos_config.z;\n        \n        vec2 p_coords = transform_coords(vec2(x_coord, y_coord), center, zoom);\n        //p_coords += MAIN_SHIFT;\n\n        success = 1.0;\n        if (COLOR_FUNCTION == 1.0) {\n        \treturn colorized_fill(p_coords);\n        } else if (COLOR_FUNCTION == 2.0) {\n            return colorized_sin(p_coords);\n        } else {\n            return black_white_fill(p_coords);\n        }\n        \n    }\n}\n\n\nvec4 simple_render(vec2 fragCoord)\n{\n    // without antialiasing\n    float success; \n    return count_point_color(success, fragCoord);\n}\n\n\nvec4 antialiasing_x4(vec2 fragCoord)\n{\n    vec4  result_color = vec4(0.0);\n    float iterations   = 0.0;\n\n    vec2 biases[5];\n    biases[0] = vec2(0, 0);\n    biases[1] = vec2(-AA_SHIFT, 0);\n    biases[2] = vec2( AA_SHIFT, 0);\n    biases[3] = vec2(0, -AA_SHIFT);\n    biases[4] = vec2(0,  AA_SHIFT);\n\n    for (int i = 0; i < 5; ++i) {\n        float success = 0.0; \n        result_color += count_point_color(success, fragCoord + vec2(biases[i]));\n        iterations += success;\n    }\n\n    result_color /= iterations;\n    return result_color;\n}\n\n\nvec4 antialiasing_x8(vec2 fragCoord)\n{\n    vec4  result_color = vec4(0.0);\n    float iterations   = 0.0;\n\n    for (float i = -AA_SHIFT; i <= AA_SHIFT ; i += AA_SHIFT) {\n        for (float j = -AA_SHIFT; j <= AA_SHIFT; j += AA_SHIFT) {\n            float success = 0.0; \n            result_color += count_point_color(success, fragCoord + vec2(i, j));\n            iterations += success;\n        }\n    }\n\n    result_color /= iterations;\n    return result_color;\n    return vec4(0.0);\n}\n\n\nvec2 transform_coords(vec2 fragCoord, vec2 center, float zoom)\n{\n    /*  takes (x, y) coords; normalize it; \n        transform to the new coordinate system */\n  \n    vec2 n_coords = fragCoord/iResolution.xy; \n    \n    // stretch the coordinate system\n    float stretch = iResolution.y / iResolution.x;\n    \n    // full fractal can be out of the screen\n    float x_len = RIGHT_BORDER - LEFT_BORDER;\n    float y_len = TOP_BORDER - BOTTOM_BORDER;\n    \n    float tmp = y_len / stretch;\n    x_len = tmp;\n    \n    n_coords.x = n_coords.x * x_len - x_len / 2.0;\n    n_coords.y =  n_coords.y * y_len - y_len / 2.0;\n    \n    n_coords = n_coords * (1.0 + zoom) - center;\n    return n_coords;\n}\n\n\nvec2 complex_multiply(vec2 v, vec2 u)\n{\n    /* multiply two complex numbers */\n    float a = v.x;\n    float b = v.y;\n    float c = u.x;\n    float d = u.y;\n    \n    return vec2(a*c - b*d, a*d + b*c);   \n}\n\n\nvec3 generate_color(float t)\n{\n    const float THRESHOLD = 0.1;\n    vec3 rgb;\n\n    // calculate current color\n    rgb  = vec3(1.0, 0.0, 0.0) * cos(iTime * SPEED);\n    rgb += vec3(0.0, 1.0, 0.0) * cos(iTime * SPEED + 1.4);\n    rgb += vec3(0.0, 0.0, 1.0) * cos(iTime * SPEED + 2.8);\n    rgb = 0.3 + 0.2 * sin(t + 0.2) + rgb / 3.0;\n    \n    // normalize current color\n    if (rgb.r <= 0.0) {\n        rgb.r = THRESHOLD;\n    }\n    if (rgb.g <= 0.0) {\n        rgb.g = THRESHOLD;\n    }\n    if (rgb.b <= 0.0) {\n        rgb.b = THRESHOLD;\n    }\n\n    return rgb;\n}\n\n\nvec4 black_white_fill(vec2 complex)\n{\n    // start inits\n    vec2 z = vec2(0.0, 0.0);\n    vec2 C  = complex;\n    int cur_iter;\n    \n    bool in_set = true;\n    for (cur_iter = 0; cur_iter < MAX_ITERS; ++cur_iter) {\n        z = complex_multiply(z, z) + C;\n        if (dot(z, z) > BAIL_OUT) {\n            in_set = false;\n            break;\n        }\n    }\n    \n    if (in_set) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        float intens = 1.0 - float(cur_iter) / float(MAX_ITERS);\n        intens = smoothstep(0.0, 1.0, intens);\n        return vec4(intens, intens, intens, 1.0);   \n    }\n}\n\n\nvec4 colorized_sin(vec2 complex)\n{   \n    // start inits\n    vec2 z = vec2(0.0, 0.0);\n    vec2 C  = complex;\n    int cur_iter;\n    \n    bool in_set = true;\n    for (cur_iter = 0; cur_iter < MAX_ITERS; ++cur_iter) {\n        z = complex_multiply(z, z) + C;\n        if (dot(z, z) > BAIL_OUT) {\n            in_set = false;\n            break;\n        }\n    }\n\n    if (in_set) {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    } else {\n        float t = length(z);  \n        vec3 rgb;\n\n        if (CHANGING_COLOR) {\n            rgb = generate_color(t);\n        } else {\n            const vec3 SIN_SHIFTS = vec3(0.24, 0.24, 0.24);\n            rgb = SIN_SHIFTS * sin(t) + CURRENT_COLOR; \n        }\n\n        return vec4(rgb, 1.0);\n    }\n}\n\n\nvec4 colorized_fill(vec2 complex)\n{\n    // start inits\n    vec2 z = vec2(0.0, 0.0);\n    vec2 C  = complex;\n    int cur_iter;\n    \n    bool in_set = true;\n    for (cur_iter = 0; cur_iter < MAX_ITERS; ++cur_iter) {\n        z = complex_multiply(z, z) + C;\n        if (dot(z, z) > BAIL_OUT) {\n            in_set = false;\n            break;\n        }\n    }\n    \n    if (in_set) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    } else {        \n        vec3    init_color  = CURRENT_COLOR;\n        float   init_bright = 3.1;\n        float   iter_coef   = 0.12;\n        \n        float   after_bright = 0.4;\n        float   after_coef   = 0.6;\n\n        float sl = pow(float(cur_iter), 1.0) - log2(pow(length(z), 0.74)) + 4.0;     \n        float al = smoothstep(-0.01, 0.0, 0.0);\n        float  l = mix(float(cur_iter), sl, al);\n        \n        vec3 deep_col3 = cos(init_bright + l*iter_coef + init_color);\n        deep_col3 = deep_col3 * after_coef + after_bright;\n        vec4 deep_col = vec4(deep_col3, 1); \n        \n        vec4 soft_col = cos(vec4(3, 4, 11, 0) + .05*(float(cur_iter) - log2(log2(dot(z,z)))));\n        soft_col = 0.5 + 0.5 * soft_col;\n        \n        return mix(deep_col, soft_col, 0.7);\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// MOVEMENT\n\nconst float MAX_ZOOM   =  1.0;\nconst float MIN_ZOOM   = -0.9999;\nconst float ZOOM_STEP  =  0.005;\nconst float MOVE_SHIFT =  0.015;\n\nconst int KEY_R     = 82;\n\nconst int KEY_W = 87;\nconst int KEY_A = 65;\nconst int KEY_D = 68;\nconst int KEY_S = 83;\n\nconst int KEY_Q = 81;\nconst int KEY_E = 69;\n\n\nbool read_key(int key)\n{\n    return texelFetch(iChannel2, ivec2(key, 0), 0).x > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec4 sum = texture(iChannel0, fragCoord);\n    vec4 con = texture(iChannel1, fragCoord); \n    \n    vec2 center = sum.xy;\n    float zoom  = sum.z; \n        \n\n    // current zoom\n    if (read_key(KEY_Q)) {\n        zoom -= ZOOM_STEP * (zoom + 1.0);\n        if (zoom <= MIN_ZOOM) {\n            zoom = MIN_ZOOM;\n        }\n    }\n    if (read_key(KEY_E)) {\n        zoom += ZOOM_STEP * (zoom + 1.0);\n        if (zoom >= MAX_ZOOM) {\n            zoom = MAX_ZOOM;\n        }\n    }\n    \n    \n    // current center\n    float move_coef = zoom + 1.0;\n    if (read_key(KEY_W)) {\n        center.y -= MOVE_SHIFT * move_coef;\n    }\n    if (read_key(KEY_S)) {\n\t\tcenter.y += MOVE_SHIFT * move_coef;\n    }\n    if (read_key(KEY_A)) {\n        center.x += MOVE_SHIFT * move_coef;\n    }\n    if (read_key(KEY_D)) {\n\t\tcenter.x -= MOVE_SHIFT * move_coef;\n    }\n    \n    \n    // restore size and position\n    if (read_key(KEY_R)) {\n        zoom   = 0.0;\n        center.x = 0.0;\n        center.y = 0.0;\n    }\n\n    fragColor = vec4(center, zoom, 0.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// COLORING OPTIONS\n\nconst int KEY_0 = 48;\nconst int KEY_1 = 49;\nconst int KEY_2 = 50;\nconst int KEY_3 = 51;\nconst int KEY_4 = 52;\nconst int KEY_5 = 53;\nconst int KEY_6 = 54;\n\n\nconst int KEY_G = 71;\nconst int KEY_H = 72;\n\n\nbool read_key(int key)\n{\n    return texelFetch(iChannel1, ivec2(key, 0), 0).x > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 config = texture(iChannel0, fragCoord);\n    \n    float color_scheme   = config.x;\n    float aliasing_level = config.y;\n    float fractal_type   = config.z;\n    \n    \n    // choose color scheme\n    if (read_key(KEY_0)) {\n        color_scheme = 0.0;\n    }\n    if (read_key(KEY_1)) {\n        color_scheme = 1.0;\n    }\n    if (read_key(KEY_2)) {\n        color_scheme = 2.0;\n    }\n    if (read_key(KEY_3)) {\n        color_scheme = 3.0;\n    }\n    if (read_key(KEY_4)) {\n        color_scheme = 4.0;\n    }\n    if (read_key(KEY_5)) {\n        color_scheme = 5.0;\n    }\n    if (read_key(KEY_6)) {\n        color_scheme = 6.0;\n    }\n    \n    // choose aliasing level\n    if (read_key(KEY_H)) {\n    \taliasing_level += 1.0;\n        if (aliasing_level >= 3.0) {\n            aliasing_level = 0.0;\n        }\n    }\n    \n    \n   \t// choose fractal type\n    if (read_key(KEY_G)) {\n    \tfractal_type += 1.0;\n        if (fractal_type >= 2.0) {\n            fractal_type = 0.0;\n        }\n    } \n    \n    fragColor = vec4(color_scheme, aliasing_level, fractal_type, 0.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}