{"ver":"0.1","info":{"id":"3dBGRy","date":"1549505802","viewed":111,"name":"DJANG - Ray Tracing","username":"d_matrix","description":"ray tracing","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec2 seed;\n\nvoid init_seed(in vec2 s) {\n    seed = s;\n}\n\n#define SEED_INCREMENT 72.291839\n\nfloat rand() {\n    return fract(sin(dot(seed += SEED_INCREMENT, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n#define LAMBERT 0\n#define METAL 1\n#define DIELEC 2\n\nstruct material {\n    int t;   // type\n    vec3 a;  // albedo\n    float f; // fuzz\n    float i; // refract index\n};\n\nstruct hit_info {\n    float t; // time\n    vec3 p;  // position\n    vec3 n;  // normal\n    material m;\n};\n    \nstruct ray {\n    vec3 o; // origin\n    vec3 d; // direction\n};\n    \nvec3 ray_point_at_t(in ray r, in float t) {\n    return r.o + r.d * t;\n}\n\nstruct sphere {\n    vec3 c;  // center\n    float r; // radius\n    material m;\n};\n\nbool sphere_hit(in sphere s, in ray r, float t_min, float t_max, inout hit_info i) {\n    float t = dot(s.c - r.o, r.d);\n    float y = distance(s.c, ray_point_at_t(r, t));\n    \n    if (y <= s.r) {\n        float x = sqrt(pow(s.r, 2.0) - pow(y, 2.0));\n        \n        float t1 = t - x;\n                        \n        if (t_min < t1 && t1 < t_max) {\n            i.t = t1;\n            i.p = ray_point_at_t(r, t1);\n            i.n = normalize(i.p - s.c);\n            i.m = s.m;\n            return true;\n        }\n        \n        float t2 = t + x;\n        \n        if (t_min < t2 && t2 < t_max) {\n            i.t = t2;\n            i.p = ray_point_at_t(r, t2);\n            i.n = normalize(i.p - s.c);\n            i.m = s.m;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n#define SPHERE_COUNT 8 + 4\n\nstruct world {\n    sphere list[SPHERE_COUNT];\n};\n    \nvoid world_init(inout world w) {\n    material m0;\n    m0.t = LAMBERT;\n    m0.a = vec3(0.5, 0.5, 0.5);\n    \n    w.list[0] = sphere(vec3(0.0, -1000.0, -1.0), 1000.0, m0);\n    \n    material m1;\n    m1.t = DIELEC;\n    m1.i = 1.5;\n    \n    w.list[1] = sphere(vec3(0.0, 1.0, 0.0), 1.0, m1);\n    \n    material m2;\n    m2.t = LAMBERT;\n    m2.a = vec3(0.4, 0.2, 0.1);\n    \n    w.list[2] = sphere(vec3(-2.5, 1.0, 0.0), 1.0, m2);\n    \n    material m3;\n    m3.t = METAL;\n    m3.a = vec3(0.7, 0.6, 0.5);\n    m3.f = 0.0;\n    \n    w.list[3] = sphere(vec3(2.5, 1.0, 0.0), 1.0, m3);\n    \n    material m4;\n    m4.t = LAMBERT;\n    m4.a = vec3(0.9, 0.1, 0.1);\n    \n    w.list[4] = sphere(vec3(1.0, 0.2, 2.0), 0.2, m4);\n    \n    material m5;\n    m5.t = LAMBERT;\n    m5.a = vec3(0.1, 0.9, 0.1);\n    \n    w.list[5] = sphere(vec3(-1.3, 0.2, 1.5), 0.2, m5);\n    \n    material m6;\n    m6.t = LAMBERT;\n    m6.a = vec3(0.1, 0.1, 0.9);\n    \n    w.list[6] = sphere(vec3(2.3, 0.2, 0.9), 0.2, m6);\n    \n    material m7;\n    m7.t = LAMBERT;\n    m7.a = vec3(0.1, 0.75, 0.75);\n    \n    w.list[7] = sphere(vec3(4.0, 0.2, -1.3), 0.2, m7);\n    \n    material m8;\n    m8.t = METAL;\n    m8.a = vec3(0.75, 0.2, 0.75);\n    m8.f = 0.0;\n    \n    w.list[8] = sphere(vec3(3.4, 0.2, 0.4), 0.2, m8);\n    \n    material m9;\n    m9.t = METAL;\n    m9.a = vec3(0.8, 0.8, 0.8);\n    m9.f = 0.2;\n    \n    w.list[9] = sphere(vec3(0.9, 0.2, 1.0), 0.2, m9);\n    \n    material m10;\n    m10.t = METAL;\n    m10.a = vec3(0.6, 0.25, 0.25);\n    m10.f = 0.25;\n    \n    w.list[10] = sphere(vec3(-0.9, 0.2, 3.0), 0.2, m10);\n    \n    material m11;\n    m11.t = DIELEC;\n    m11.i = 1.5;\n\n    w.list[11] = sphere(vec3(2.5, 0.2, 1.5), 0.2, m11);\n}\n\nbool world_hit(in world w, in ray r, float t_min, float t_max, inout hit_info info) {\n    bool is_hit = false;\n    float new_t_max = t_max;\n    \n    for (int i = 0; i != SPHERE_COUNT; ++i) {\n        if (sphere_hit(w.list[i], r, t_min, new_t_max, info)) {\n            is_hit = true;\n            new_t_max = info.t;\n        }\n    }\n    \n    return is_hit;\n}\n\nvec3 rand_in_unit_sphere() {\n\tvec3 p;\n\n    do {\n        p = (vec3(rand(), rand(), rand()) * 2.0) - 1.0;\n    } while (length(p) > 1.0);\n    \n    return p;\n}\n\nfloat schlick(float c, float i) {\n    float r0 = (1.0 - i) / (1.0 + i);\n    r0 *= r0;\n    return r0 + (1.0 - r0) * pow(1.0 - c, 5.0);\n}\n\nbool scatter(in ray r, in hit_info i, out vec3 a, out ray s) {\n    material m = i.m;\n    \n    if (LAMBERT == m.t) {\n        vec3 target = i.p + i.n + rand_in_unit_sphere();\n        \n        a = m.a;\n        s = ray(i.p, normalize(target - r.o));\n        \n        return true;\n    }\n    else if (METAL == m.t) {\n        a = m.a;\n        s = ray(i.p, normalize(reflect(r.d, i.n) + m.f * rand_in_unit_sphere()));\n        \n        return dot(s.d, i.n) > 0.0;\n    }\n    else if (DIELEC == m.t) {\n        a = vec3(1.0);\n        \n        vec3 n;\n        float e;\n        float c;\n        \n        if (dot(r.d, i.n) > 0.0) {\n            n = -i.n;\n            e = m.i;\n            c = m.i * dot(r.d, i.n);\n        }\n        else {\n            n = i.n;\n            e = 1.0 / m.i;\n            c = -dot(r.d, i.n);\n        }\n        \n        vec3 o = refract(r.d, n, e);\n        \n        float p = (0.0 == length(o)) ? 1.0 : schlick(c, m.i);\n        \n        if (rand() < p)\n            o = reflect(r.d, i.n);\n        \n        s = ray(i.p, o);\n        \n        return true;\n    }\n    \n\treturn false;\n}\n\n#define FLOAT_MIN 0000000.0001\n#define FLOAT_MAX 9999999.9999\n#define DEPTH_MAX 64\n\nvec3 world_color(in world w, in ray r) {\n    hit_info info;\n    vec3 color = vec3(1.0);\n    \n    for (int i = 0; i != DEPTH_MAX; ++i) {\n        if (world_hit(w, r, FLOAT_MIN, FLOAT_MAX, info)) {\n            vec3 a;\n            ray s;\n            \n            if (scatter(r, info, a, s)) {\n                r = s;\n                color *= a;\n            }\n            else {\n                color = vec3(0.0);\n                break;\n            }\n        }\n        else {\n            float t = 0.5 * (r.d.y + 1.0);\n            color *= ((1.0 - t) * vec3(1.0) + t * vec3(0.5, 0.7, 1.0));\n            break;\n    \t}\n    }\n    \n    return color;\n}\n\nstruct camera {\n    vec3 p; // position\n    vec3 o; // offset\n    vec3 v; // vertical\n    vec3 h; // horizontal\n};\n    \n#define M_PI 3.141529\n    \nvoid camera_init(inout camera c, in vec3 from, in vec3 to, in vec3 up, float v_fov) {\n    c.p = from;\n    \n    float theta = v_fov * (M_PI / 180.0);\n    float height = tan(theta / 2.0) * 2.0;\n    float aspect = iResolution.x / iResolution.y;\n    float width = height * aspect;\n    \n    vec3 w = normalize(from - to);\n    vec3 u = normalize(cross(up, w));\n    vec3 v = normalize(cross(w, u));\n    \n    c.o = from + (-width / 2.0) * u + (-height / 2.0) * v - w;\n    c.h = width * u;\n    c.v = height * v;\n}\n\nray camera_ray(in camera c, in vec2 uv) {\n    return ray(c.p, normalize(c.o + uv.x * c.h + uv.y * c.v - c.p));\n}\n\nvec3 gamma_correction(in vec3 v) {\n    return pow(v, vec3(1.0 / 1.5));\n}\n\n#define SAMPLE_COUNT 4\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    init_seed(fragCoord);\n    \n    world w;\n    world_init(w);\n    \n    camera cam;\n    camera_init(cam, vec3(3.5, 1.5, 1.75), vec3(0.0, 0.0, -1.0), vec3(0.0, 1.0, 0.0), 90.0);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i != SAMPLE_COUNT; ++i) {\n        ray cam_ray = camera_ray(cam, uv + (vec2(rand(), rand()) / iResolution.xy));\n        \n        color += world_color(w, cam_ray);\n    }\n    \n    color /= vec3(SAMPLE_COUNT);\n    color = gamma_correction(color);\n   \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}