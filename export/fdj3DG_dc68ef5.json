{"ver":"0.1","info":{"id":"fdj3DG","date":"1618668129","viewed":62,"name":"CG_2021 313_Tverskoy_v1v2","username":"sqrt4","description":"2 задание по курсу 'Компьютерная графика' ВМК МГУ : \"Ведьмин Шар\"\nВыполнил: Тверской А.Е. (313гр.)\nРЕАЛИЗОВАНО:\n- Базовая часть (v1v2)\n- Мягкие тени\n- Анти-алиасинг\n- Окружение в виде текстурированной плоскости (стол)  И куб-мапы","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","cube","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    // Output to screen\n    fragColor = texture(iChannel0,uv) / float(iFrame + 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"const float INF = 1e10;\nconst vec3 CAMERA_POS = vec3(3.5,2.5,-7.5); //3.5 2.5 -7.5\nvec3 randDir;\n\n//structs\n\nstruct Colors{\n    vec3 vertBox;\n    vec3 horBox;\n    vec3 mainCube;\n    vec3 sphere;\n};\n\nconst Colors colors = Colors(\n                             /*vertBox:*/   vec3(1,   0.7, 1),\n                             /*horBox:*/    vec3(0.7, 0.7, 1),\n                             /*mainCube:*/  vec3(1 , 1, 1),\n                             /*sphere*:*/   vec3(1, 1, 1)\n                            );\n\nstruct Sphere{\n    vec3 center;\n    float radius;\n    vec3 color;\n    float rk;\n};\n\nstruct Box{\n    vec3 center;\n    vec3 side;\n    vec3 color;\n    float rk;\n};\n\n//Light sources\n\nconst int LIGHTS_AMMOUNT = 3;\n\nSphere[LIGHTS_AMMOUNT] Lights = \n                Sphere[]( Sphere(vec3(-4, 2.5, 4),  0.35,vec3(0, 1.1, 1.1), 20.0),\n                          Sphere(vec3(-1, 0.65, -2), 0.2, vec3(1.1, 0, 1.6), 4.0),\n                          Sphere(vec3(0.3, 2, 1.0), 0.15, vec3(1.5, 1.5, 1.5), 5.0)\n                       );\n                       \n                                                        \n//Main cube\n\nBox mainCube = Box(vec3(0, 0, 0), vec3(1, 1, 1) ,colors.mainCube, 1.5);\n\n//Other figures\n\nBox anotherCube = Box(vec3(2,0, 4), vec3(1.0, 1.5, 0.5) ,colors.mainCube, 100.0);\nSphere anotherSphere = Sphere(vec3(2, -1, 1), 0.5, vec3(1, 1, 1), 3.0);\n\n//Inside cube\n\nconst int BOXES_AMMOUNT = 18;\nconst int SPHERES_AMMOUNT = 4;\n\nBox[BOXES_AMMOUNT] Boxes = \n               Box[]( \n                      //Горизонтальные\n                      Box(vec3(0,   0.6, 0.3), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      Box(vec3(0,   0.0, 0.3), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      Box(vec3(0,  -0.6, 0.3), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      \n                      Box(vec3(0,   0.6, 0.8), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      Box(vec3(0,   0.0, 0.8), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      Box(vec3(0,  -0.6, 0.8), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      \n                      Box(vec3(0,   0.6, -0.3), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      Box(vec3(0,   0.0, -0.3), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      Box(vec3(0,  -0.6, -0.3), vec3 (1.0, 0.04, 0.04), colors.horBox, 1.0),\n                      \n                      //Вертикальные\n                      Box(vec3(0.6,   0, 0.0), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      Box(vec3(0.0,   0, 0.0), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      Box(vec3(-0.6,  0, 0.0), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      \n                      Box(vec3(0.6,   0, 0.5), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      Box(vec3(0.0,   0, 0.5), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      Box(vec3(-0.6,  0, 0.5), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      \n                      Box(vec3(0.6,   0, -0.5), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      Box(vec3(0.0,   0, -0.5), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0),\n                      Box(vec3(-0.6,  0, -0.5), vec3 (0.04, 1.0, 0.04), colors.vertBox, 1.0)\n                       \n                     );\n                     \nSphere[SPHERES_AMMOUNT] Spheres = \n                  Sphere[]( \n                            Sphere(vec3(0.3,   0.3 , 0), 0.1, colors.sphere, 0.),\n                            Sphere(vec3(-0.3,  0.3 , 0), 0.1, colors.sphere, 0.),\n                            Sphere(vec3(0.3,  -0.3 , 0), 0.1, colors.sphere, 0.),\n                            Sphere(vec3(-0.3, -0.3 , 0), 0.1, colors.sphere, 0.)                     \n                         );\n                     \n                    \n                              \n\n//Refractive indices\nconst float GLASS_N = 1.5;\nconst float AIR_N = 1.0;\nconst float DIAMOND_N = 2.5;\n\n\n//FUNCTIONS\n\nfloat pow2(float x){\n    return x*x;\n}\n\nvec3 refraction(vec3 v, vec3 normal, float n1, float n2) {\n    if (dot(v, normal) < 0.0) {\n        normal = -normal;\n    }\n    float cosA = dot(v, normal);\n    float sinA = sqrt(1.0 - cosA * cosA);\n    vec3 tang = normalize(v - cosA * normal);\n    float sinB = sinA / n2 * n1;\n    if (sinB > 1.0)\n        return reflect(v, normal);\n        float cosB = sqrt(1.0 - sinB * sinB);\n    return sinB * tang + cosB * normal;\n}//refraction\n\n\nfloat tracePlane(vec3 pos, vec3 dir, out vec3 normal){\n    float t = (-1.5 - pos.y) / dir.y; // y = -1\n   \n    if (t <= 0.0)\n        return INF;\n    \n    vec3 worldPos = t*dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) >= 100.0)\n      return INF;\n    \n    normal = vec3(0, 1, 0);\n    return t;\n       \n            \n}//tracePlane\n\nfloat traceSphere(vec3 pos, vec3 dir, Sphere sphere, out vec3 normal){\n    pos -= sphere.center;\n    float b = dot(pos, dir);\n    float D = b*b - dot(pos, pos) + pow2(sphere.radius);\n    \n    if (D < 0.0)\n        return INF;\n        \n    float t = -b - sqrt(D);\n    if (t > 0.0){ \n        normal = normalize(pos + t*dir);\n        return t;\n    }\n    t = -b + sqrt(D);\n    if (t < 0.0){\n        return INF;\n    }\n    \n    normal = normalize(pos + t*dir);\n    return t;\n        \n}//traceSphere\n\n\nfloat traceBoxF(vec3 pos, vec3 dir, Box box, out vec3 normal){\n    float t = (-box.side.z - pos.z) / dir.z;\n    vec3 worldPos = t * dir + pos;\n\n    if ((t <= 0.0) || (worldPos.x < -box.side.x) || (worldPos.x > box.side.x)\n         || (worldPos.y < -box.side.y) || (worldPos.y > box.side.y))\n    {\n        return INF;\n    }\n    \n    normal = vec3(0, 0, -1);\n    return t;\n}\n\nfloat traceBoxB(vec3 pos, vec3 dir, Box box, out vec3 normal){\n    float t = (box.side.z - pos.z) / dir.z;\n    vec3 worldPos = t * dir + pos;\n\n    if ((t <= 0.0) || (worldPos.x < -box.side.x) || (worldPos.x > box.side.x)\n         || (worldPos.y < -box.side.y) || (worldPos.y > box.side.y))\n    {\n        return INF;\n    }\n    \n    normal = vec3(0, 0, 1);\n    return t;\n}\n\nfloat traceBoxL(vec3 pos, vec3 dir, Box box, out vec3 normal){\n    float t = (box.side.x - pos.x) / dir.x;\n    vec3 worldPos = t * dir + pos;\n\n    if ((t <= 0.0) || (worldPos.z < -box.side.z) || (worldPos.z > box.side.z)\n         || (worldPos.y < -box.side.y) || (worldPos.y > box.side.y))\n    {\n        return INF;\n    }\n    \n    normal = vec3(1, 0, 0);\n    return t;\n}\n\nfloat traceBoxR(vec3 pos, vec3 dir, Box box, out vec3 normal){\n    float t = (-box.side.x - pos.x) / dir.x;\n    vec3 worldPos = t * dir + pos;\n\n    if ((t <= 0.0) || (worldPos.z < -box.side.z) || (worldPos.z > box.side.z)\n         || (worldPos.y < -box.side.y) || (worldPos.y > box.side.y))\n    {\n        return INF;\n    }\n    \n    normal = vec3(-1, 0, 0);\n    return t;\n}\n\nfloat traceBoxU(vec3 pos, vec3 dir, Box box, out vec3 normal){\n    float t = (box.side.y - pos.y) / dir.y;\n    vec3 worldPos = t * dir + pos;\n\n    if ((t <= 0.0) || (worldPos.x < -box.side.x) || (worldPos.x > box.side.x)\n         || (worldPos.z < -box.side.z) || (worldPos.z > box.side.z))\n    {\n        return INF;\n    }\n    \n    normal = vec3(0, 1, 0);\n    return t;\n}\n\nfloat traceBoxD(vec3 pos, vec3 dir, Box box, out vec3 normal){\n    float t = (-box.side.y - pos.y) / dir.y;\n    vec3 worldPos = t * dir + pos;\n\n    if ((t <= 0.0) || (worldPos.x < -box.side.x) || (worldPos.x > box.side.x)\n         || (worldPos.z < -box.side.z) || (worldPos.z > box.side.z))\n    {\n        return INF;\n    }\n    \n    normal = vec3(0, -1, 0);\n    return t;\n}\n\nfloat traceBox(vec3 pos, vec3 dir,Box box, float t, out vec3 normal){\n\n        pos -= box.center;\n        \n        vec3 boxNormal;\n\n        float cFT = traceBoxF(pos, dir, box, boxNormal);\n        if (cFT < t){\n            t = cFT;\n            normal = boxNormal;\n        }\n        float cBT = traceBoxB(pos, dir, box, boxNormal);\n        if (cBT < t){\n            t = cBT;\n            normal = boxNormal;\n        }     \n            \n        float cLT = traceBoxL(pos, dir, box, boxNormal);\n        if (cLT < t){\n            t = cLT;\n            normal = boxNormal;\n        }\n        \n        float cRT = traceBoxR(pos, dir, box, boxNormal);\n        if (cRT < t){\n            t = cRT;\n            normal = boxNormal;\n        }\n        \n        float cUT = traceBoxU(pos, dir, box, boxNormal);\n        if (cUT < t){\n            t = cUT;\n            normal = boxNormal;\n        }\n        \n        float cDT = traceBoxD(pos, dir, box, boxNormal);\n        if (cDT < t){\n            t = cDT;\n            normal = boxNormal;\n        }\n        \n     return t;   \n} //traceBox\n\n\nfloat traceCylinder(vec3 pos, vec3 dir, float r, out vec3 normal) {\n    float t = (-1.0 - pos.y) / dir.y;\n    if (t <= 0.0) {\n        return INF;\n    }\n    vec3 worldPos = t * dir + pos;\n    if (dot(worldPos.xz, worldPos.xz) < r)\n    {\n        normal = vec3(0, 1, 0);\n        return t;\n    }\n    \n    float a = dot(dir.xz, dir.xz);\n    float b = dot(pos.xz, dir.xz);\n    float c = dot(pos.xz, pos.xz) - r;\n    float D = b * b - a * c;\n    if (D < 0.0) \n        return INF;\n    \n    t = (-b - sqrt(D)) / a;\n    if (t > 0.0) {\n        worldPos = t * dir + pos;\n        if (worldPos.y <= -1.0) {\n            normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n            return t;\n        }\n    }\n    t = (-b + sqrt(D)) / a;\n    if (t < 0.0) \n        return INF;\n        \n    worldPos = t * dir + pos;\n    if (worldPos.y <= -1.0) {\n        normal = normalize(vec3(worldPos.x, 0, worldPos.z));\n        return t;\n    }\n    return INF;\n}//traceCylinder\n\n\n\nbool isOccluded(vec3 pos, vec3 target){\n    vec3 dir  = target - pos;\n    float dist = length(dir);\n    dir /= dist;\n    \n    vec3 cubeNorm;\n    float t = INF;\n    \n   float cubeT = traceBox(pos, dir, mainCube, t, cubeNorm);\n    if (cubeT < dist)\n        return true;\n   \n    vec3 cylNorm;\n    float cylT = traceCylinder(pos, dir, 0.5, cylNorm);\n    if (cylT < dist)\n        return true;\n    \n    cubeT = traceBox(pos, dir, anotherCube, t, cubeNorm);\n    if (cubeT < dist)\n        return true;\n             \n    vec3 sphereNorm;        \n    float sphereT  = traceSphere(pos, dir, anotherSphere, sphereNorm);\n        if (sphereT < dist)\n            return true;     \n        \n        for (int i = 0; i < BOXES_AMMOUNT; i++){\n            cubeT  = traceBox(pos, dir , Boxes[i], t , cubeNorm);\n            if (cubeT < dist)\n                return true;\n        }\n        \n        \n        for (int i = 0; i < SPHERES_AMMOUNT; i++){\n            sphereT  = traceSphere(pos, dir, Spheres[i], sphereNorm);\n            if (sphereT < dist)\n                return true; \n       }\n       \n       \n        \n    return false;     \n        \n}//isOccluded\n\n\nvec3 computeLight(vec3 pos, Sphere[LIGHTS_AMMOUNT] Lights, vec3 color, vec3 normal){\n    vec3 res;\n\n    for (int i = 0; i < LIGHTS_AMMOUNT; i++)\n    {\n        vec3 toLight = Lights[i].center - pos;\n        float distSq = dot(toLight, toLight);\n        \n        float att = (isOccluded(pos, Lights[i].center + randDir*Lights[i].radius)) ? 0.08 : Lights[i].rk/distSq;\n        \n        res += max(0.0,dot(normal, normalize(toLight)))*att*Lights[i].color;\n    }    \n      \n    res += texture(iChannel1, normal).rgb*0.2;\n    \n    return color * res;\n}//computeLight\n\n\nfloat rand(float frame){\n    return fract(sin( dot(vec3(frame), vec3(12.9898,78.233,45.5432) )) * 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 randVals = vec3(rand(float(iFrame)), rand(float(iFrame + 5)), rand(float(iFrame + 15)));\n    vec3 colorMult = vec3(1, 1, 1);\n    vec3 randDir = normalize(randVals - 0.5);\n    \n    //материалы объектов\n    const int EMISSION = 0;\n    const int DIFFUSE = 1;\n    const int REFLECTION = 2;\n    const int REFRACTION = 3;\n    \n    float GLASS_R = pow2(AIR_N - GLASS_N) / pow2(AIR_N + GLASS_N);\n    float DIAMOND_R = pow2(DIAMOND_N - GLASS_N) / pow2(DIAMOND_N + GLASS_N);\n    \n    vec2 uv = (fragCoord - iResolution.xy*0.5 + (randVals.xy - 0.5)*2.0) / iResolution.x;\n    vec3 front = normalize(-CAMERA_POS);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = normalize(cross(front, up));\n    up = normalize(cross(right, front));\n    vec3 viewVec = normalize(front + right*uv.x + up*uv.y);\n    \n    float n1 = AIR_N; \n    float nEnter = AIR_N;\n    \n    vec3 curPos = CAMERA_POS;\n    vec3 curDir = viewVec;\n    \n    for (int i=0; i<10; i++){\n    \n        float t = INF;\n        vec3 worldPos = t*curDir + curPos;\n        vec3 normal;\n        vec3 color;\n        int material;\n        \n        \n        vec3 planeNorm;\n        float planeT = tracePlane(curPos, curDir, planeNorm);\n        if (planeT < t){ \n            t = planeT;\n            worldPos = t*curDir + curPos;\n            material = DIFFUSE;\n            color = texture(iChannel0, worldPos.xz*0.1).rgb;\n            normal = planeNorm;\n        }\n        \n        \n        vec3 lightNorm;\n        float lightT;\n        for (int i = 0; i < LIGHTS_AMMOUNT; i++)\n        {\n            lightT = traceSphere(curPos, curDir, Lights[i], lightNorm);\n            if (lightT < t){ \n                t = lightT;\n                material = EMISSION;\n                color = Lights[i].color;\n                normal = lightNorm;\n            }\n        }//for\n              \n        \n        vec3 cylNorm;\n        float cylT = traceCylinder(curPos, curDir, 2.4, cylNorm);\n            if (cylT < t){\n                t = cylT;\n                color = texture(iChannel2, worldPos.xz*worldPos.y*0.5).rgb;\n                normal = cylNorm;\n                if (randVals.x < 0.1) {\n                    material = REFLECTION;\n                } else {\n                    material = DIFFUSE;\n                  }\n                \n            }\n            \n           \n        vec3 cubeNorm;\n        float cubeT = traceBox(curPos, curDir, mainCube, t, cubeNorm);\n        if (cubeT < t){\n            t = cubeT;\n            normal = cubeNorm;\n            if (randVals.x < GLASS_R*mainCube.rk) {\n                    material = REFLECTION;\n                } else {\n                    colorMult *= mainCube.color;\n                    material = REFRACTION;\n                    if (dot(curDir, normal) > 0.0)\n                        nEnter = AIR_N;\n                    else \n                        nEnter = GLASS_N;\n                  }\n        }\n        \n        cubeT = traceBox(curPos, curDir, anotherCube, t, cubeNorm);\n        if (cubeT < t){\n            t = cubeT;\n            normal = cubeNorm;\n            material = REFLECTION;\n        }         \n        \n        for (int i = 0; i < BOXES_AMMOUNT; i++){\n            cubeT  = traceBox(curPos, curDir , Boxes[i], t , cubeNorm);\n            if (cubeT < t){\n                t = cubeT;\n                normal = cubeNorm;\n                if (randVals.x < DIAMOND_R*Boxes[i].rk) {\n                    material = REFLECTION;\n                } else {\n                    colorMult *= Boxes[i].color;\n                    material = REFRACTION;\n                    if (dot(curDir, normal) > 0.0)\n                        nEnter = GLASS_N;\n                    else \n                        nEnter = DIAMOND_N;\n                  }\n            \n            \n            }\n        }//for\n        \n        vec3 sphereNorm;\n        for (int i = 0; i < SPHERES_AMMOUNT; i++){\n            float sphereT  = traceSphere(curPos, curDir, Spheres[i], sphereNorm);\n            if (sphereT < t){\n                t = sphereT;\n                normal = sphereNorm;\n                if (randVals.x < DIAMOND_R*Spheres[i].rk) {\n                    material = REFLECTION;\n                } else {\n                    colorMult *= Spheres[i].color;\n                    material = REFRACTION;\n                    if (dot(curDir, normal) > 0.0)\n                        nEnter = GLASS_N;\n                    else \n                        nEnter = AIR_N;\n                  }\n             }\n       }//for   \n       \n       float sphereT = traceSphere(curPos, curDir, anotherSphere, sphereNorm);\n       if (sphereT < t){\n                t = sphereT;\n                normal = sphereNorm;\n                if (randVals.x < DIAMOND_R*anotherSphere.rk) {\n                    material = REFLECTION;\n                } else {\n                    colorMult *= anotherSphere.color;\n                    material = REFRACTION;\n                    if (dot(curDir, normal) > 0.0)\n                        nEnter = AIR_N;\n                    else \n                        nEnter = GLASS_N;\n                  }\n       }           \n        \n          \n        \n        if (t != INF) {\n            worldPos = t*curDir + curPos;\n            fragColor = texture(iChannel0, worldPos.xz);\n            \n            if (material == EMISSION) {\n                fragColor.rgb = color * colorMult;\n                break;\n                \n            } else if (material == DIFFUSE) {\n                fragColor.rgb = computeLight(worldPos, Lights, color, normal) * colorMult;\n                break;\n                \n            } else if (material == REFLECTION) {\n                curDir = reflect(curDir, normal);\n                curPos = worldPos + curDir * 1e-2;\n                \n            } else if (material == REFRACTION){\n                curDir = refraction(curDir, normal, n1, nEnter);\n                curPos = worldPos + curDir * 1e-2;\n                n1 = nEnter;\n            }\n            \n        } else {\n            fragColor.rgb = texture(iChannel1, curDir).rgb * colorMult ;\n        }\n    } //for\n\n} //end","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv) + texture(iChannel1, uv);\n}","name":"Buffer B","description":"","type":"buffer"}]}