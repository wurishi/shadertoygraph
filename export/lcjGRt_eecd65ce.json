{"ver":"0.1","info":{"id":"lcjGRt","date":"1704543034","viewed":42,"name":"Enclosing Sphere for Raymarching","username":"Lomei","description":"Demonstrate imvisable enclosing sphere to speed up raymarching of many objects ","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// A raymarching scene with many boxes.\n// They are enclosed by an invisible enclosing sphere to speed up rendering.\n// Comment to\n// // #define ENCLOSING to see a huge drawback in performance.\n\n#define ENCLOSING\n\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat smin( float a,float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1.);\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nbool get_red_box = false;\nbool is_red_box = false;\n\nfloat dBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat GetDist(vec3 p) {\n   float d;\n   \n   d = p.y;\n\n#if 1\n{\n    // render time indicator\n    vec4 s1 = vec4(-3, 1.+iTimeDelta*3., 4, 0.1);\n    float sphere1Dist = length(p-s1.xyz)-s1.w;\n    d = min(d, sphere1Dist);\n}\n#endif\n     \n    // boxes\n    float min_on_red_box = 999.;\n \n    // enclosing sphere\n#ifdef ENCLOSING\n    vec4 enclosing = vec4(-2.7, 5, 17, 8);\n    float enclosingDist = length(p-enclosing.xyz)-enclosing.w;\n    if (enclosingDist < d && enclosingDist < SURF_DIST) {\n#endif\n\n    for (int i = 0; i < 10; i++) {\n        for (int j = 0; j < 4; j++) {\n        for (int k = 0; k < 10; k++) {\n            if (i % 2 == j % 2 && j % 2 == k % 2) {\n                vec3 boxpos = vec3(i-6,k, j+15);\n                boxpos = p - boxpos;\n                if (0 == k % 2) {\n                    boxpos.xz *= Rot(iTime*2.);\t\t// rotation\n                } else {\n                    boxpos.xz *= Rot(-iTime*2.);\t\t// rotation\n                }\n                float d_box = dBox(boxpos, vec3(.5));\n                if (d_box < d) {\n                    d = d_box;\n                    if (get_red_box) {\n                        if (i == 7 && j == 1 && k ==7) {\n                           min_on_red_box = d;\n                        } else {\n                            min_on_red_box = 999.;\n                        }\n                    }\n                }\n            }\n        }\n        }\n     }\n\n\n#ifdef ENCLOSING\n    } else {\n        float d2 = enclosingDist+SURF_DIST;\n        d = min(d2,d);\n    }\n#endif\n  \n    if (get_red_box && d == min_on_red_box) {\n        is_red_box = true;\n    }\n    \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 2, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    get_red_box = true;\n    is_red_box = false;\n    float d = RayMarch(ro, rd);\n    get_red_box = false;\n\n    vec3 p = ro + rd * d;\n    \n    float dif = GetLight(p);\n    col = vec3(dif);\n    \n    if (is_red_box) {\n        col = col + vec3(.4545, 0, 0);\n    }\n\n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}