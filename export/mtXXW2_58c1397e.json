{"ver":"0.1","info":{"id":"mtXXW2","date":"1675432991","viewed":62,"name":"Clouds with lights","username":"Infant","description":"Space clouds with two types of lights.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["2d","clouds","simplex","lights"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n    Lighting based off \n    https://learnopengl.com/PBR/Lighting\n    https://learnopengl.com/Lighting/Light-casters\n    \n    Kind of similar to this one: https://www.shadertoy.com/view/MdyGzR but not used as a reference.\n*/\n\n//Coordinates by which me sample the noise uv\nfloat dx = 0.0;\nfloat dy = 0.0;\n\n//SimplexNoise settings\nfloat octaves = 16.0;\nfloat scale = 4.0;\nfloat persistence = 0.6;\n\nstruct Light{\n    int     shadow;     \n    vec3    position;   //Position if it's a point light, direction if its the sun    \n    vec3    direction;  //If the light is a spotlight\n    vec3    color;\n    float   brightness;\n    float   cos_angle;    //If light is a spotlight\n    bool    spotlight;\n};\n\nint num_active_lights; //Can be changed dynamically.\nLight light[8]; //Array needs to be as bit as the max number of lights we intend to use\n\n//Some hash function\nvec3 hash33(vec3 p3){\n\tp3 = fract(p3 * vec3(0.1031, 0.11369, 0.13787));\n    p3 += dot(p3, p3.yxz + 19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n// From https://www.shadertoy.com/view/MslBzf -> \n//    Raw simplex implementation by candycat\n//    Source: https://www.shadertoy.com/view/4sc3z2\nfloat SimplexNoiseRaw(vec3 pos)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n\n    vec3 i = floor(pos + (pos.x + pos.y + pos.z) * K1);\n    vec3 d0 = pos - (i - (i.x + i.y + i.z) * K2);\n\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n\n    float d = dot(vec4(31.316), n);\n    //Dot product will go to large negative values\n    d = max(-0.150,d);\n    return d;\n}\n\nfloat SimplexNoise(vec3  pos, float _octaves, float _scale, float _persistence){\n    float final        = 0.0;\n    float amplitude    = 1.0;\n    float maxAmplitude = 0.0;\n\n    for(float i = 0.0; i < _octaves; ++i){\n        final        += SimplexNoiseRaw(pos * _scale) * amplitude;\n        _scale        *= 2.0;\n        maxAmplitude += amplitude;\n        amplitude    *= _persistence;\n    }\n    return (final / maxAmplitude);\n}\n\n\n//Would normally pass scene info in via uniforms\nvoid setup_scene(){\n    num_active_lights = 3;\n    light[0].color = vec3(1,0,0);\n    light[0].position = vec3(0.5,0.5,0) + vec3(0.1*sin(iTime*1.2),0.1*cos(iTime),0);\n    light[0].brightness = 0.01;\n    light[1].color = vec3(0,1,0);\n    light[1].position = vec3(0.7,0.5,0) + vec3(0.1*sin(iTime),0.1*cos(iTime*1.1),0);\n    light[1].brightness = 0.01;\n    \n    \n    light[2].color = vec3(0,0.2,1);\n    light[2].position = vec3(1.5,0.5,0);\n    light[2].direction = vec3(-1.0,0.0,0);\n    light[2].spotlight = true;\n    light[2].cos_angle = 0.95;\n    light[2].brightness = 0.45;\n    \n    //Mouse control\n    vec2 mo = iMouse.xy/iResolution.xy;\n    mo.x *= iResolution.x / iResolution.y;\n    \n    light[2].direction.xy = mo - light[2].position.xy ;\n    \n    \n    dx = iTime*0.01;\n    dy = sin(iTime*0.01);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //Secene\n    setup_scene();\n    \n    \n    \n    //Setup coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    vec2 uvin  = uv.xy + vec2(dx,dy)*3.0;\n    \n    //Generate clouds from simplexnoise\n    vec3 val = vec3(0.15);\n    val += vec3(SimplexNoise(vec3(uvin,iTime/100.0),octaves, scale, persistence));    \n    val += val; //Intensity\n    val += vec3(SimplexNoise(vec3(uvin*2.0,iTime/50.0),octaves/4.0, scale*0.1, persistence));  \n    \n    val /= 2.0;\n    \n    vec3 vposition = vec3(uv,0.0);\n    \n    //Calculate lights\n    vec3 Lo = vec3(0.0); //Lo -> Light output\n    for(int i = 0; i < num_active_lights; i++){\n        float distance    = length(light[i].position - vposition);\n        if (distance > 10.0 ){\n            continue;\n        }\n        float intensity = 1.0;\n        if (light[i].spotlight == true){\n            //Light direction\n            vec3 L = normalize(light[i].position - vposition);\n            float theta = dot(L, normalize(-light[i].direction));\n            if(theta < light[i].cos_angle){\n                continue;\n            }\n            float epsilon = 0.15;\n            intensity = clamp((theta - light[i].cos_angle) / epsilon, 0.0, 1.0);\n        }\n\n        float attenuation = 1.0 / (distance * distance);\n        vec3 radiance     = light[i].color * light[i].brightness * attenuation * intensity;         \n         //Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n        Lo += radiance;\n        \n        \n    }\n    \n    Lo = min(vec3(10.0,10.0,10.0),Lo);\n    fragColor = vec4((val*Lo)+val,1.0);\n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}