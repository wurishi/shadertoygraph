{"ver":"0.1","info":{"id":"Xcf3RS","date":"1703168753","viewed":18,"name":"High line and sin curve","username":"karakure178","description":"High line and sin curve.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sketch"],"hasliked":0,"parentid":"Mcs3D7","parentname":"Fork Sketch #11 karakure17 777"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265358\n#define X .211324865405187\n#define Y .36602540378443\n#define Z -.577350269189626\n#define W .024390243902439\n\n// 参考：https://github.com/Makio64/monkeyNewYear/blob/master/src/glsl/chunks/snoise2D.glsl\n// 参考：https://twigl.app/?ol=true&ss=-NZYlGH1E6hmmM2tcnXe\n// 参考：https://www.shadertoy.com/view/dtXfWX\nvec3 permute(vec3 x) { return mod( x*x*34.+x, 289.); }\nfloat snoise(vec2 v) {\n\tvec2 i = floor(v + (v.x+v.y)*Y),\n\t  x0 = v -   i + (i.x+i.y)*X,\n\t   j = step(x0.yx, x0),\n\t  x1 = x0+X-j,\n\t  x3 = x0+Z;\n\t  i = mod(i,289.);\n\t  vec3 p = permute( permute( i.y + vec3(0, j.y, 1 ))\n\t\t\t\t\t\t\t\t  + i.x + vec3(0, j.x, 1 )   ),\n\t   m = max( .5 - vec3(dot(x0,x0), dot(x1,x1), dot(x3,x3)), 0.),\n\t   x = 2. * fract(p * W) - 1.,\n\t   h = abs(x) - .5,\n\t  a0 = x - floor(x + .5),\n\t   g = a0 * vec3(x0.x,x1.x,x3.x)\n\t\t  + h * vec3(x0.y,x1.y,x3.y);\n\tm = m*m*m*m* ( 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h ) );\n\treturn .5 + 65. * dot(m, g);\n}\n\nfloat smoothmix(float a, float b, float x)\n{\n    return (1.0-smoothstep(0.0, 1.0, x))*a + smoothstep(0.0, 1.0, x)*b;\n}\n\nmat2 rotate2D(float angle)\n{\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\n\nmat2 scale2D(float scalar)\n{\n    return mat2(scalar, 0.0,\n                0.0, scalar);\n}\n\nfloat grid(in vec2 uv,in float size)\n{\n\n    const float wavesize = 0.9;\n    uv  += wavesize * sin(uv.x * PI* 2.0 + iTime);\n    uv = rotate2D( PI/3.0 ) * uv;\n    \n    // 高等線を描く\n    vec2 p = uv;    \n    float l=.2;\n    float f=5.;\n    float n=snoise(p*5.)*.5+.5;\n    float c=float(fract(n*f)<l);\n    \n    uv *= vec2(c,c);// 高等線とサインカーブを合成している\n    \n    uv = fract(uv);\n    return smoothstep(0.0, size*0.05, uv.y);\n}\n\n\nfloat random(float x)\n{\n    return fract(439029.0*sin(x));\n}\n\nfloat random(vec2 uv)\n{\n    return fract(439029.0*sin(dot(uv, vec2(85.3876, 9.38532))));\n}\n\nvec2 randomGradientVec(vec2 uv)\n{\n    float angle = 2.0*PI*random(uv);\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat noise(in vec2 uv, in float sampleNum)\n{\n    /*\n        Creates gradients at sample points\n        \n        Quadrants 1, 2, 3, 4 correspond to letters d, c, a, b\n    */\n    vec2 uv_i = floor(uv*sampleNum);\n    vec2 uv_f = fract(uv*sampleNum);\n    float time_i = floor(iTime);\n    float time_f = fract(iTime);\n    \n    vec2 gradA = randomGradientVec(uv_i);\n    vec2 gradB = randomGradientVec(uv_i + vec2(1.0, 0.0));\n    vec2 gradC = randomGradientVec(uv_i + vec2(0.0, 1.0));\n    vec2 gradD = randomGradientVec(uv_i + vec2(1.0, 1.0));\n    \n    /*\n        Dot product and interpolation to get noise value at each pixel\n    */\n    float valA = dot(uv_f, gradA);\n    float valB = dot(uv_f - vec2(1.0, 0.0), gradB);\n    float valC = dot(uv_f - vec2(0.0, 1.0), gradC);\n    float valD = dot(uv_f - vec2(1.0, 1.0), gradD);\n    float valAB = smoothmix(valA, valB, uv_f.x);\n    float valBC = smoothmix(valC, valD, uv_f.x);\n    float val = 0.8*smoothmix(valAB, valBC, uv_f.y) + 0.5;\n    \n    return val;\n}\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\n\n// ------------------------------------------------------------------\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    /*\n        Warps the uv coordinates and draws grid\n    */\n    uv *= 10.0;\n    float noise = noise(uv + vec2(2.0)*iTime, 0.2);\n    uv *= 1.0 - 0.2*noise;\n    float warpedGrid = grid(uv, 30.0);\n    \n    /*\n        Coloring\n    */\n    \n    vec3 HSV = vec3(0.0, 0.0, 0.0);\n    HSV[0] = 0.0;\n    HSV[1] = 0.4;\n    HSV[2] = step(0.3,  warpedGrid);// 二値化している\n    vec3 color = hsv2rgb(HSV);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}