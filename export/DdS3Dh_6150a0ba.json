{"ver":"0.1","info":{"id":"DdS3Dh","date":"1667507610","viewed":131,"name":"Geometric Series Cube Tiling SDF","username":"jt","description":"Using [url=https://en.wikipedia.org/wiki/Geometric_series]Geometric Series[/url] to calculate a loopless exact euclidean SDF tesselating space with cubes of increasing size.\nAn intersection (ray-cast instead of ray-marching) visualizes the interior.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["sdf","cube","distance","honeycomb","tiling","infinite","euclidean","geometric","loopless","series","exact","sum","telescoping"],"hasliked":0,"parentid":"ddjGzW","parentname":"Geom. Series Square Tiling SDF"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/DdS3Dh Geometric Series Cube Tiling SDF 2022-11-03 by Jakob Thomsen\n// based on https://www.shadertoy.com/view/ddjGzW Geometric Series Square Tiling SDF\n// based on https://www.shadertoy.com/view/dd2GRW Geometric Series Square Tiling\n// based on https://www.shadertoy.com/view/Ds23zD Textured Geometric Series Coords\n// based on https://www.shadertoy.com/view/fd2czy Textured Geometric Series\n// based on https://www.shadertoy.com/view/7dScRG 1/4+1/16+1/64+1/256+...\n\n// tags: sdf, cube, distance, honeycomb, tiling, infinite, euclidean, geometric, loopless, series, exact, sum, telescoping\n\n// Using Geometric Series to calculate a loopless exact euclidean SDF tesselating space with cubes of increasing size.\n// An intersection (ray-cast instead of ray-marching) visualizes the interior.\n\n// see https://en.wikipedia.org/wiki/Geometric_series\nfloat geometric_series_cube_tiling(vec3 p, float n) // should be exact euclidean\n{\n    p = abs(p);\n\n    float n1 = n - 1.0;\n    float b = n / n1;\n    vec3 s = floor(log2(p)/log2(b));\n    float m = max(max(s.x, s.y), s.z);\n    p = fract(p/pow(b, m)*n1);\n\n    p = 0.5-abs(p-0.5);\n    float d = min(min(p.x, p.y),p.z);\n    return d*pow(b, m)*b/n;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) // iq's https://iquilezles.org/articles/distfunctions/\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat map(vec3 p)\n{\n    float n = 4.0;\n    //return max(geometric_series_cube_tiling(p, n), length(p) - 1.0); // this intersection is NOT exact\n    //return max(geometric_series_cube_tiling(p, n), sdTorus(p, vec2(1.0, 0.5))); // this intersection is NOT exact\n    return geometric_series_cube_tiling(p, n) - 0.01;\n}\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal( vec3 p )\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) +\n                      k.yyx*map( p + k.yyx*h ) +\n                      k.yxy*map( p + k.yxy*h ) +\n                      k.xxx*map( p + k.xxx*h ) );\n}\n\n// Limit iterations to make sure not to crash GPU (in case steps get very small).\n#define MAX_ITERATIONS 1000u\n\nfloat trace(vec3 ro, vec3 rd, float t0, float t1)\n{\n    uint iteration;\n    float t;\n    for(t = t0, iteration = 0u; t < t1 && iteration < MAX_ITERATIONS; iteration++)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return t1;\n}\n/*\nfloat trace(vec3 ro, vec3 rd, float t0, float t1)\n{\n    if(t0 < 1.0)\n    {\n        for(float t = t0; t < 1.0;)\n        {\n            float h = map(ro + rd * t);\n            if(h < EPSILON)\n                return t;\n            t += h;\n        }\n        t0 = 1.0;\n    }\n\n    for(float t = t0; t < t1;)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON * t) // optimization: coarser epsilon in the distance\n            return t;\n        t += h;\n    }\n\n    return t1;\n}\n*/\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    uint iteration;\n    float t;\n    for(t = mint, iteration = 0u; t < maxt && iteration < MAX_ITERATIONS; iteration++)\n    {\n        float h = map(ro + rd*t);\n        if( h<EPSILON )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    uint iteration;\n    float t;\n    for(t = mint, iteration = 0u; t < maxt && iteration < MAX_ITERATIONS; iteration++)\n    {\n        float h = map(ro + rd*t);\n        if( h < EPSILON )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\nfloat torIntersect( in vec3 ro, in vec3 rd, in vec2 tor ) // https://iquilezles.org/articles/intersectors/\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        return t;\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n}\n\nfloat dot2(vec3 v)\n{\n    return dot(v, v);\n}\n\nfloat coneIntersect( in vec3  ro, in vec3  rd, in vec3  pa, in vec3  pb, in float ra, in float rb ) // https://iquilezles.org/articles/intersectors/\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n    vec3  ob = ro - pb;\n    float m0 = dot(ba,ba);\n    float m1 = dot(oa,ba);\n    float m2 = dot(rd,ba);\n    float m3 = dot(rd,oa);\n    float m5 = dot(oa,oa);\n    float m9 = dot(ob,ba); \n    \n    // caps\n    if( m1<0.0 )\n    {\n        if( dot2(oa*m2-rd*m1)<(ra*ra*m2*m2) ) // delayed division\n            return -m1/m2;\n    }\n    else if( m9>0.0 )\n    {\n    \tfloat t = -m9/m2;                     // NOT delayed division\n        if( dot2(ob+rd*t)<(rb*rb) )\n            return t;\n    }\n    \n    // body\n    float rr = ra - rb;\n    float hy = m0 + rr*rr;\n    float k2 = m0*m0    - m2*m2*hy;\n    float k1 = m0*m0*m3 - m1*m2*hy + m0*ra*(rr*m2*1.0        );\n    float k0 = m0*m0*m5 - m1*m1*hy + m0*ra*(rr*m1*2.0 - m0*ra);\n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return DIST_MAX; //no intersection\n    float t = (-k1-sqrt(h))/k2;\n    float y = m1 + t*m2;\n    if( y<0.0 || y>m0 ) return DIST_MAX; //no intersection\n    return t;\n}\n\n#define pi 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n    float my =  pi * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * fract(iTime * 0.025);\n    my = (iMouse.y > 10.0) ? my : pi / 2.0;\n\n    mat2 Yaw = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    vec3 ro = vec3(0.0, 0.0,-2.5);\n    mat2 Pitch = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    ro.yz = Pitch * ro.yz;\n    ro.xy = Yaw * ro.xy;\n\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz = Pitch * rd.yz;\n    rd.xy = Yaw * rd.xy;\n\n    vec3 color = vec3(0);\n\n    float bound =\n          fract(iTime / 10.0) < 0.5\n        ? torIntersect(ro.xzy, rd.xzy, vec2(1.0, 0.45)) \n        : min(coneIntersect(ro, rd, vec3(0), vec3(0,0,-10), 0.0, 10.0), coneIntersect(ro, rd, vec3(0), vec3(0,0,+10), 0.0, 10.0));\n    if(bound >= 0.0 && bound < DIST_MAX)\n    {\n        vec3 surf = ro + rd * bound;\n        float dist = trace(ro, rd, bound, DIST_MAX);\n        if(dist < DIST_MAX)\n        {\n            vec3 dst = ro + rd * dist;\n            vec3 n = normal(dst);\n            //color = n*0.5+0.5;\n\n            vec3 lightdir = normalize(vec3(1,1,1));\n            float lightlength = max(dot(lightdir, surf - dst), 0.0);\n            vec3 ambient = vec3(0.01);\n            float brightness = max(dot(lightdir, n), 0.0);\n            if(brightness > 0.0)\n                brightness *= shadow(dst + n * 0.01, lightdir, 0.0, lightlength);\n                //brightness *= softshadow(dst + n * 0.01, lightdir, 0.0, lightdist, 50.0);\n            color = vec3(1);\n            color = (ambient * calcAO(dst, n) + brightness) * color;\n            //color = (ambient + calcAO(dst, n) * brightness) * color;\n\n            //color *= brightness;\n        }\n    }\n\n    //color = mix(vec3(color), vec3(0.0), smoothstep(DIST_MAX - 2.0, DIST_MAX, dist));\n    color = sqrt(color); // approximate gamma\n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}