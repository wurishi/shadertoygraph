{"ver":"0.1","info":{"id":"XtsSzr","date":"1434234722","viewed":1048,"name":"2DBloom","username":"FatumR","description":"Shader shows 4 simple 2d effects, they are switching after every playback. Shader can be heavily optimized to reach needed fps.","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["2d","blur","bloom","edge","tone"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Created by fatumR\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Color conversion related functions\nvec3 rgb2hsv(vec3 color) {\n    vec3 HSV = vec3(0.); // x -> H, y -> S, z -> V\n    float Max = max(color.r, max(color.g, color.b));\n    float Min = min(color.r, min(color.g, color.b));\n    float chroma = Max - Min;\n    \n    HSV.z = Max;\n    \n    if (chroma > 0.) {\n        vec3 components = vec3(0.);\n        if (Max == color.r) {\n            components.xy = color.gb;\n        } else if (Max == color.g) {\n            components.xy = color.br;\n            components.z = 2.;\n        } else {\n            components.xy = color.rg;\n            components.z = 4.;\n        }\n        \n        HSV.x = fract(((components.x - components.y)/chroma + components.z) / 6.);\n\n        // Saturation\n        if (Max > 0.) {\n        \tHSV.y = chroma / Max;\n        } else {\n            HSV.y = 0.;\n        }\n    }\n    \n    return HSV;\n}\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Blur generation related functions\nvec4 boxBlur(vec2 uv, float scale) {\n    // Simple box blurring\n    const int numSteps = 15;\n    \n    uv = ((uv * 2. - 1.) *scale) * .5 + .5;\n    \n    vec4 acc = texture(iChannel0, uv);\n    vec2 stepI = 1./iResolution.xy;\n    stepI *= scale;\n    vec2 offsetU = vec2(0.0);\n    vec2 offsetD = vec2(0.0);\n    \n    for (int j = 0; j < numSteps; j++) {\n        offsetU.y += stepI.y;\n        offsetU.x = 0.;\n        for (int i = 0; i < numSteps; i++) {\n            acc += pow(texture(iChannel0, uv + offsetU), vec4(2.2));\n            acc += pow(texture(iChannel0, uv - offsetU), vec4(2.2));\n            offsetU.x += stepI.x;\n        }\n    \n        offsetD.y -= stepI.y;\n        offsetD.x = 0.;\n        for (int i = 0; i < numSteps; i++) {\n            acc += pow(texture(iChannel0, uv + offsetD), vec4(2.2));\n            acc += pow(texture(iChannel0, uv - offsetD), vec4(2.2));\n            offsetD.x += stepI.x;\n        }\n    }\n    \n    // Gamma correction is added, as it's done by iq here: https://www.shadertoy.com/view/XtsSzH\n    return pow(acc / (float(numSteps * numSteps * 4) + 1.), vec4(1. / 2.2));\n    \n}\n\n// Kind of Guass blur approximation\nvec4 gaussBlurApprox(vec2 uv, float scale) {\n    const int numSteps = 15;\n    // Strange but const declaration gets an error, \n    // but there is an official way to declare const arrays.\n    float gaussCoeff[15]; // 1D gauss kernel, normalized\n    gaussCoeff[0] = 0.053917;\n    gaussCoeff[1] = 0.053551;\n    gaussCoeff[2] = 0.052469;\n    gaussCoeff[3] = 0.050713;\n    gaussCoeff[4] = 0.048354;\n    gaussCoeff[5] = 0.045481;\n    gaussCoeff[6] = 0.042201;\n    gaussCoeff[7] = 0.038628;\n    gaussCoeff[8] = 0.034879;\n    gaussCoeff[9] = 0.031068;\n    gaussCoeff[10] = 0.027300;\n    gaussCoeff[11] = 0.023664;\n    gaussCoeff[12] = 0.020235;\n    gaussCoeff[13] = 0.017070;\n    gaussCoeff[14] = 0.014204;\n   \n    uv = ((uv * 2. - 1.) *scale) * .5 + .5; // central scaling\n    \n    vec4 acc = texture(iChannel0, uv) * gaussCoeff[0];\n    vec2 stepI = 1./iResolution.xy;\n    stepI *= scale;\n    vec2 offsetU = vec2(0.0);\n    vec2 offsetD = vec2(0.0);\n    \n    for (int j = 0; j < numSteps; j++) {\n        offsetU.y += stepI.y;\n        offsetU.x = 0.;\n        for (int i = 0; i < numSteps; i++) {\n            acc += pow(texture(iChannel0, uv + offsetU), vec4(2.2)) * gaussCoeff[1 + i] * gaussCoeff[1 + j];\n            acc += pow(texture(iChannel0, uv - offsetU), vec4(2.2)) * gaussCoeff[1 + i] * gaussCoeff[1 + j];\n            offsetU.x += stepI.x;\n        }\n   \n        offsetD.y -= stepI.y;\n        offsetD.x = 0.;\n        for (int i = 0; i < numSteps; i++) {\n            acc += pow(texture(iChannel0, uv + offsetD), vec4(2.2)) * gaussCoeff[1 + i] * gaussCoeff[1 + j];\n            acc += pow(texture(iChannel0, uv - offsetD), vec4(2.2)) * gaussCoeff[1 + i] * gaussCoeff[1 + j];\n            offsetD.x += stepI.x;\n        }\n    }\n    // Gamma correction is added, as it's done by iq here: https://www.shadertoy.com/view/XtsSzH\n    return pow(acc, 1. / vec4(2.2));\n    \n}\n\n// Edge detection related functions\nvec4 detectEdgesSimple(vec2 uv) {\n    // Simple central diff detector\n    vec4 offset = vec4(1./iResolution.xy, -1./iResolution.xy);\n    vec4 hill = texture(iChannel0, uv);\n    \n    vec4 acc = (hill - texture(iChannel0, uv + offset.x)) / offset.x;\n    acc += (hill - texture(iChannel0, uv - offset.x)) / offset.x;\n    acc += (hill - texture(iChannel0, uv + offset.y)) / offset.y;\n    acc += (hill - texture(iChannel0, uv - offset.y)) / offset.y;\n    acc += (hill - texture(iChannel0, uv + offset.xy)) / (.5 * (offset.x + offset.y));\n    acc += (hill - texture(iChannel0, uv - offset.xy)) / (.5 * (offset.x + offset.y));\n    acc += (hill - texture(iChannel0, uv + offset.zy)) / (.5 * (offset.x + offset.y));\n\tacc += (hill - texture(iChannel0, uv - offset.xw)) / (.5 * (offset.x + offset.y));\n\n\treturn abs(acc * .003); // Changing the multiplier we can control the number o edges\n}\n\nfloat detectEdgesSobel(vec2 uv) {\n    // Edge detection based on Sobel kernel\n    vec4 offset = vec4(1./iResolution.xy, -1./iResolution.xy);\n    \n    float gx = 0.0;\n    float gy = 0.0;\n    \n    vec4 clr = texture(iChannel0, uv - offset.xy);\n    gx += -1. * dot(clr, clr);\n    gy += -1. * dot(clr, clr);\n    \n    clr = texture(iChannel0, uv - offset.x);\n    gx += -2. * dot(clr, clr);\n    \n    clr = texture(iChannel0, uv + offset.zy);\n    gx += -1. * dot(clr, clr);\n    gy +=  1. * dot(clr, clr);\n    \n    clr = texture(iChannel0, uv + offset.xw);\n    gx +=  1. * dot(clr, clr);\n    gy += -1. * dot(clr, clr);\n    \n    clr = texture(iChannel0, uv + offset.x);\n    gx += 2. * dot(clr, clr);\n    \n    clr = texture(iChannel0, uv + offset.xy);\n    gx += 1. * dot(clr, clr);\n    gy += 1. * dot(clr, clr);\n    \n    clr = texture(iChannel0, uv - offset.y);\n    gy += -2. * dot(clr, clr);\n    \n    clr = texture(iChannel0, uv + offset.y);\n    gy += 2. * dot(clr, clr);\n    \n\treturn gx*gx + gy*gy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    int effectType = int(mod(floor(iTime / 34.), 4.));\n\n    vec3 blurredClr;\n    float edge;\n    if (effectType == 1 || effectType == 3) {\n        blurredClr = clamp(gaussBlurApprox(uv, 1.), 0., 1.).rgb;\n        edge = detectEdgesSobel(uv);\n    } else if (effectType == 0 || effectType == 2) {\n        blurredClr = clamp(boxBlur(uv, 1.), 0., 1.).rgb;\n        edge = length(detectEdgesSimple(uv));\n    }\n    vec3 origClr = texture(iChannel0, uv, 0.).rgb;\n    vec3 hsv = rgb2hsv(origClr.rgb);\n    hsv.y = min(hsv.y * 2., 1.);\n    hsv.z = min(hsv.z * 1.75, 1.);\n    \n    vec3 rgb;\n    if (effectType == 0 || effectType == 1) {\n    \trgb = hsv2rgb(hsv) * 0.5;\n    } else {\n        rgb = hsv2rgb(hsv);\n    }\n    origClr = mix(blurredClr, rgb, clamp(edge, 0., 1.));\n    \n\tfragColor = vec4(origClr,1.0);\n}","name":"Image","description":"","type":"image"}]}