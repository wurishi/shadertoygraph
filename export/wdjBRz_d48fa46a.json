{"ver":"0.1","info":{"id":"wdjBRz","date":"1589405371","viewed":113,"name":"Ride thru the city at night","username":"lovelyH","description":"City with light.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["city"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define E 0.001\n#define INF 10000.0\n#define MAX_DIS 430.0\n\n\nvec2 rot( vec2 p, float l ){\n\treturn vec2(\n\t\tp.x*cos(l) - p.y*sin(l),\n\t\tp.x*sin(l) + p.y*cos(l)\n\t);\n}\n\n\nfloat dfCube( vec3 p, vec3 size ){\n\tp= abs(p) - size;\n\t// return max( max( p.x, p.y), p.z );\n\treturn length( vec3(\n\t\tmax( 0.0, p.x),\n\t\tmax( 0.0, p.y),\n\t\tmax( 0.0, p.z)\n\t));\n}\n\n\n\nint matId= 0;\nvec3 lightDis= vec3(INF);\n\n\nfloat map(vec3 p){\n\tfloat rc= p.z;\n\tfloat r= rc;\n\tfloat h;\n\tmatId= 0;\n\tlightDis= vec3(INF);\n\tvec3 ph, ph2;\n\n\t/// lamps\n\tph= p;\n\tph.x= abs(ph.x) - 6.2;\n\tph.y = mod( ph.y, 4.0 ) - 2.0;\n\trc= length(ph.xy)-0.1;\n\tph.z -= 3.0;\n\trc= max( rc, ph.z );\n\trc= min( rc, length(ph)-0.2 );\n\tlightDis= min( lightDis, vec3(length(ph)-0.1));\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 1;\n\t}\n\n\t/// pavement\n\tph= p;\n\tph.x= abs(ph.x) - 6.0;\n\tph.z -= 0.2;\n\trc= length( vec2(\n\t\tmax( 0.0, -ph.x),\n\t\tmax( 0.0, ph.z)\n\t));\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 1;\n\t}\n\n\t/// building\n\tph= p;\n\tfloat seed= floor( p.y / 30.0 ) * sign(p.x);\n\tph.x= abs(ph.x) - 20.0;\n\tph.y= mod( ph.y, 30.0 ) - 15.0;\n\trc= dfCube( ph, vec3(12.0) );\n\tfloat buildingHeight= 6.0 + 3.0 * floor( 3.0*( 0.5 + 0.5 * sin(10.*seed) ) );\n\trc= max( rc, p.z - buildingHeight );\n\trc= min( rc,  max( 1.0, max( ph.x-12.0, ph.y-12.0 ) ) );\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 10 + int( floor( mod( seed, 6.999 ) ) );\n\t}\n\t/// door\n\tph2= ph;\n\tph2.x += 12.0;\n\tph2.y += 11.0*sin( 7.0*seed );\n\trc= dfCube( ph2, vec3(0.1, 0.7, 2.5) );\n\tif( mod(seed,5.0) < 3.0 ){\n\t\tfloat doory= ph2.y;\n\t\t/// window\n\t\tph2= ph;\n\t\tph2.x += 12.0;\n\t\tph2.y += mod( 11.0*sin( 7.0*seed ) + 11.0 + 11.0, 22.0 ) - 11.0;\n\t\tph2.z -= 2.0;\n\t\trc= min( rc, dfCube( ph2, vec3(0.1, 0.7, 0.8) ) );\n\t\tif( mod(17.0*seed,23.0) < 15.0 )\n\t\t{\n\t\t\tph2.z = mod( p.z, 3.0 )-1.5;\n\t\t\tph2.z = max( ph2.z, p.z + 1.5 - buildingHeight );\n\t\t\trc= min( rc, dfCube( ph2, vec3(0.1, 0.7, 0.8) ) );\n\t\t\tph2.y = doory;\n\t\t\trc= min( rc, dfCube( ph2, vec3(0.1, 0.7, 0.8) ) );\n\t\t}\n\t}\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 3;\n\t}\n\n\t/// extra stone elements\n\trc= INF;\n\t/// corner\n\th= mod(27.0*seed,29.0);\n\tif( h < 10.0 ){\n\t\tph2= ph;\n\t\tph2.x= abs(ph2.x)-12.0;\n\t\tph2.y= abs(ph2.y)-12.0;\n\t\tph2.z = mod( ph2.z, 0.8 ) - 0.4;\n\t\trc= min( rc, dfCube( ph2+vec3(.2,.2,.0), vec3(.3,.3,.25) ) );\n\t}else if( h < 20.0 ){\n\t\t\n\t\tph2= ph;\n\t\tph2.x= abs(ph2.x)-12.0;\n\t\tph2.y= abs(ph2.y)-12.0;\n\t\t\n\t\t// ph2.z -= 4.0;\n\t\tph2.z = mod( ph2.z, 3.0 ) - 1.0;\n\n\t\tph2.x += 0.1;\n\t\tph2.y += 0.1;\n\t\trc= min( rc, dfCube( ph2, vec3(.15,.15,.12) ) - 0.03 );\n\t\t\n\t\tph2.x += 0.05;\n\t\tph2.y += 0.05;\n\t\tph2.z -= 0.5;\n\t\trc= min( rc, dfCube( ph2, vec3(.19,.19,.14) ) - 0.03 );\n\n\t\tph2.x += 0.7;\n\t\tph2.y += 0.15;\n\t\tph2.z += 0.1;\n\t\trc= min( rc, dfCube( ph2-vec3(.15,.15,.0), vec3(.19,.19,.12) ) - 0.03 );\n\n\t\tph2.x -= 0.7;\n\t\tph2.y += 0.5;\n\t\tph2.z += 0.1;\n\t\trc= min( rc, dfCube( ph2, vec3(.19,.19,.17) ) - 0.03 );\n\n\t}\n\t/// roof\n\tif( mod(13.0*seed,17.0) < 12.0 ){\n\t\tph2= ph;\n\t\tph2.z -= buildingHeight;\n\t\tif( mod(13.0*seed,17.0) < 5.0 ){\n\t\t\tph2.z = mod( ph2.z+1.5, 3.0 )-1.5;\n\t\t}\n\t\trc= min( rc, dfCube( ph2, vec3( 12.1, 12.1, 0.1 ) ) );\n\t}\n\t/// cut above building height\n\trc= max( rc, p.z - buildingHeight );\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= 2;\n\t}\n\n\treturn r;\n}\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\tvec3 p= sp;\n\tfloat dis= map(p);\n\tfloat t= 0.0;\n\tbool isHit= false;\n\tvec3 lightDisFromRay= vec3(INF);\n\tfor( int a=0;a<0x200;a++){\n\t\tt += dis;\n\t\tp= sp + t*dir;\n\t\tdis= map(p);\n\t\tlightDisFromRay= min( lightDisFromRay, lightDis );\n\t\tif( dis < E || MAX_DIS < t ){\n\t\t\tisHit= true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tint hitMatId= matId;\n\tvec3 light= lightDis;\n\n\tvec3 r;\n\tif( t < MAX_DIS ){\n\n\t\t//vec3 nor= normalize(vec3(\n\t\t//\tmap(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n\t\t//\tmap(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n\t\t//\tmap(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n\t\t//));\n  \t\tvec3 nor= vec3( 0 );\n\t\tfor( int i=min( iFrame, 0 ); i<4; i++){\n\t\t\tvec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n\t\t\tnor += e * map( p + e*E );\n\t\t}\n        nor= normalize( nor );\n\n\n\t\tfloat ao= 1.0;\n\t\tfor( float a=0.1; a>0.01; a*=0.5 ){\n\t\t\tao= min( ao, map(p+nor*a) / a );\n\t\t}\n\t\tao= clamp( ao, 0.0, 1.0 );\n\n\t\tvec3 baseColor;\n\t\tswitch(hitMatId){\n\t\t\t/// street\n\t\t\tcase 0: {\n\t\t\t\tbaseColor= vec3(.5,.5,.7); \n\t\t\t\tif( abs( p.x ) < 0.05 && mod(p.y,4.0) < 2.0 ){\n\t\t\t\t\tbaseColor= vec3(.9); \n\t\t\t\t}\n\t\t\t} break;\n\t\t\t/// pavement\n\t\t\tcase 1: baseColor= vec3(.5); break;\n\t\t\t/// stone (roof etc)\n\t\t\tcase 2: baseColor= vec3(.65); break;\n\t\t\t/// doors\n\t\t\tcase 3: baseColor= vec3(.55,.6,.1); break;\n\t\t\t/// buildings\n\t\t\tcase 10: baseColor= vec3(.9,.9,.6); break;\n\t\t\tcase 11: baseColor= vec3(.6,.6,.6); break;\n\t\t\tcase 12: baseColor= vec3(.7,.9,.6); break;\n\t\t\tcase 13: baseColor= vec3(.8,.7,.6); break;\n\t\t\tcase 14: baseColor= vec3(.2,.3,.4); break;\n\t\t\tcase 15: baseColor= vec3(.6,.6,.1); break;\n\t\t\tcase 16: baseColor= vec3(.3,.3,.1); break;\n\t\t\tcase 17: baseColor= vec3(.1,.1,.8); break;\n\t\t\t/// other\n\t\t\tdefault: baseColor= vec3(1,0,0); break;\n\t\t}\n\n\t\tr= baseColor *\n\t\t\t( \n\t\t\t\t(1.0 / (1.0 + 1.0 * light) )\n\t\t\t\t+ 1.0\n\t\t\t\t* ( 0.5 + 0.5*dot(nor,vec3(0,0,1)) )\n\t\t\t\t* ( 0.5 + 0.5*dot(nor,-dir) )\n\t\t\t\t* ( 0.5 + 0.5*ao )\n\t\t\t\t* ( 1.0 / (1.0 + 0.0001*t*t) )\n\t\t\t)\n\t\t;\n\n\t}else{\n\t\t/// sky\n\t\tr= vec3(0);\n\t}\n\n\t/// add light\n\tr += vec3(1) / (1.0+2.0*lightDisFromRay);\n\treturn r;\n}\n\nconst float iCamRX= 3.14/2.0;\nconst float iCamRZ= 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 dir= normalize( vec3( uv.x, uv.y, -4.0 ) );\n\tdir.yz= rot( dir.yz, iCamRX );\n\tdir.xy= rot( dir.xy, -iCamRZ );\n\t\n\tfragColor.xyz = sqrt( render( vec3(0,40.0*(mod(iTime,120.0)-60.0),2.0), dir ) );\n}\n","name":"Image","description":"","type":"image"}]}