{"ver":"0.1","info":{"id":"tsSyWD","date":"1586650552","viewed":419,"name":"Matheads","username":"luk77","description":"This shader is an effect of my experiments with the character animation and signed distance fields.\nThe characters are controlled by keyboard:\nCharacter 1: WASD, Q, E\nCharacter 2: Arrow keys, Ctrl, Shift\n","likes":39,"published":1,"flags":48,"usePreview":0,"tags":["raymarching","game","interactive","sdf","music","cartoon","animation","funny","character"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-------------------------------------------------------------------------------\n// Matheads\n//-------------------------------------------------------------------------------\n// Copyright © 2020 Lukasz Lesicki\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//-------------------------------------------------------------------------------\n\n//-------------------------------------------------------------------------------\nvec4 g_posVel1\t\t\t\t= vec4(0.0);\nvec4 g_posVel2\t\t\t\t= vec4(0.0);\nvec4 g_data1\t\t\t\t= vec4(0.0);\nvec4 g_data2\t\t\t\t= vec4(0.0);\nvec4 g_special1\t\t\t\t= vec4(0.0);\nvec4 g_special2\t\t\t\t= vec4(0.0);\n//-------------------------------------------------------------------------------\n\n//-------------------------------------------------------------------------------\n// utils\n//-------------------------------------------------------------------------------\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nvec2 opSmoothUnionV2( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    float d = mix( d2.x, d1.x, h ) - k*h*(1.0-h); \n    return vec2( d, ( h < 0.5 ) ? d2.y : d1.y);\n}\n\nvec2 opSmoothSubtractionV2( vec2 d1, vec2 d2, float k )\n{\n    float h = clamp( 0.5 - 0.5*(d2.x+d1.x)/k, 0.0, 1.0 );\n    float d = mix( d2.x, -d1.x, h ) + k*h*(1.0-h);\n    return vec2( d, ( h < 0.5 ) ? d2.y : d1.y);\n}\n\nmat3 rotX(float a)\n{\n    return mat3(1,0,0, 0,cos(a),-sin(a), 0,sin(a),cos(a));\n}\n\nmat3 rotY(float a)\n{\n    return mat3(cos(a),0,sin(a), 0,1,0, -sin(a),0,cos(a));\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(cos(a),-sin(a),0, sin(a),cos(a),0, 0,0,1);\n}\n\nvec3 attachToParent(vec3 parentPos, vec3 translation, mat3 rotation)\n{\n    vec3 pos = parentPos;\n    pos -= translation;\n    pos *= rotation;\n    \n    return pos;\n}\n\n\n//-------------------------------------------------------------------------------\n// main code\n//-------------------------------------------------------------------------------\nvec2 buildCharacter(vec3 p, vec3 posOffset, vec3 posOffset2, vec4 special, float headOffset, float inputWalk, float breathSpeed, float headMix01, float matBody, float matEyes, float matEyesSockets)\n{\n    inputWalk += 0.5 * PI;\n    \n    headOffset *= 0.5 + 0.5 * (1.0 - special.x);\n    \n    // rotations\n    mat3 rotEyes \t\t= rotX(0.05 * PI * sin(2.3 * iTime)) * rotY(0.2 * PI * sin(iTime));\n    mat3 rotHandL \t\t= rotZ( 0.125 * PI) * rotX(0.06 * PI * sin(5.0 * iTime));\n    mat3 rotHandR \t\t= rotZ(-0.125 * PI) * rotX(0.06 * PI * sin(0.5 * PI + 5.0 * iTime));\n    mat3 rotWalk  \t\t= rotY(0.3 * PI * sin(inputWalk));\n    mat3 rotWalkHead  \t= rotY(0.1 * PI * sin(inputWalk)) * rotZ(0.25 * sin((0.4 * PI + inputWalk)));\n    mat3 rotHole  \t\t= rotX(0.5 * PI );\n    \n\tfloat angleHands = 0.25 * PI;\n    vec2 cHands = vec2(sin(angleHands),cos(angleHands));    \n    \n    // transformations\n    vec3 posRoot \t\t= p - posOffset;\n    vec3 posRoot2 \t\t= p - posOffset - posOffset2;\n    vec3 posBody \t\t= attachToParent(posRoot\t, vec3(0.0, 0.3, 0.0)\t\t\t, rotWalk);\n    vec3 posHead \t\t= attachToParent(posRoot2\t, vec3(0.0, headOffset + 0.08 * sin(PI + iTime * breathSpeed), -0.2)\t, rotWalkHead);\n    vec3 posHandL\t\t= attachToParent(posHead\t, vec3( 1.0, -0.6, -0.2)\t\t, rotHandL);\n    vec3 posHandR\t\t= attachToParent(posHead\t, vec3(-1.0, -0.6, -0.2)\t\t, rotHandR);\n    vec3 posEyeL \t\t= attachToParent(posHead\t, vec3( 0.5, 0.4, -0.7)\t\t\t, rotEyes);\n    vec3 posEyeR \t\t= attachToParent(posHead\t, vec3(-0.5, 0.4, -1.0)\t\t\t, rotEyes);\n    vec3 posEyePupilL \t= attachToParent(posEyeL\t, vec3( 0.0, 0.0, -EYE_RADIUS_L), MX_ID);\n    vec3 posEyePupilR \t= attachToParent(posEyeR\t, vec3( 0.0, 0.0, -EYE_RADIUS_R), MX_ID);\n    vec3 posHole \t\t= attachToParent(posHead\t, vec3( 0.3 * sin(0.5 * breathSpeed * iTime), -0.5,-0.6 )\t\t, rotHole);\n\n    // shapes\n    //float fLegs \t\t= sdCappedTorus\t\t(posBody, vec2(sin(LEGS_ANGLE),cos(LEGS_ANGLE)), 1.2, 0.1); \n    float fLegs \t\t= sdCappedTorus\t\t(posBody, vec2(sin(LEGS_ANGLE),cos(LEGS_ANGLE)), 0.8, 0.1); \n    float fHeadV1 \t\t= sdSphere\t\t\t(posHead, 1.0 + 0.05 * sin(iTime * breathSpeed));\n    float fHeadV2 \t\t= sdRoundBox\t\t(posHead, vec3(0.6 + 0.05 * sin(iTime * breathSpeed), 1.1, 0.7), 0.1);\n    float fHead\t\t\t= mix(fHeadV1, fHeadV2, headMix01);\n    float fHandL \t\t= sdCappedTorus\t\t(posHandL, cHands, 0.6, 0.2 );\n    float fHandR \t\t= sdCappedTorus\t\t(posHandR, cHands, 0.6, 0.2 );\n    float fEyeSocketL \t= sdSphere\t\t\t(posEyeL, 1.2 * EYE_RADIUS_L);\n    float fEyeSocketR \t= sdSphere\t\t\t(posEyeR, 1.2 * EYE_RADIUS_R);\n    float fEyeL \t\t= sdSphere\t\t\t(posEyeL, EYE_RADIUS_L);\n    float fEyeR \t\t= sdSphere\t\t\t(posEyeR, EYE_RADIUS_R);\n    float fEyePupilL \t= sdSphere\t\t\t(posEyePupilL, 0.1);\n    float fEyePupilR \t= sdSphere\t\t\t(posEyePupilR, 0.06);\n    float fHole \t\t= sdVerticalCapsule\t(posHole, 1.0, -0.02 + special.y * (0.3 + 0.03 * sin(4.0 * breathSpeed * iTime)));\n    \n    // distances + materials\n    vec2 dLegs \t\t\t= vec2(fLegs\t\t, matBody);\n    vec2 dHead \t\t\t= vec2(fHead\t\t, matBody);\n    vec2 dHandL\t\t\t= vec2(fHandL\t\t, matBody);\n    vec2 dHandR\t\t\t= vec2(fHandR\t\t, matBody);\n    vec2 dEyeSocketL \t= vec2(fEyeSocketL\t, matEyesSockets);\n    vec2 dEyeSocketR \t= vec2(fEyeSocketR\t, matEyesSockets);\n    vec2 dEyeL \t\t\t= vec2(fEyeL\t\t, matEyes);\n    vec2 dEyeR \t\t\t= vec2(fEyeR\t\t, matEyes);\n    vec2 dEyePupilL \t= vec2(fEyePupilL\t, MAT_EYES_DOTS);\n    vec2 dEyePupilR \t= vec2(fEyePupilR\t, MAT_EYES_DOTS);\n    vec2 dHole \t\t\t= vec2(fHole\t\t, matEyesSockets);\n    \n    // build character\n    vec2 dCharacter = opSmoothUnionV2\t\t(dLegs\t\t\t, dHead\t\t\t, 1.8);\n    dCharacter \t\t= opSmoothUnionV2\t\t(dHandL\t\t\t, dCharacter\t, 0.15);\n    dCharacter \t\t= opSmoothUnionV2\t\t(dHandR\t\t\t, dCharacter\t, 0.15);\n    dCharacter \t\t= opSmoothSubtractionV2\t(dEyeSocketL\t, dCharacter\t, 0.05);\n    dCharacter \t\t= opSmoothSubtractionV2\t(dEyeSocketR\t, dCharacter\t, 0.05);\n    dCharacter \t\t= opSmoothUnionV2\t\t(dEyeL\t\t\t, dCharacter\t, 0.05);\n    dCharacter \t\t= opSmoothUnionV2\t\t(dEyeR\t\t\t, dCharacter\t, 0.05);\n    dCharacter \t\t= opSmoothUnionV2\t\t(dEyePupilL\t\t, dCharacter\t, 0.0);\n    dCharacter \t\t= opSmoothUnionV2\t\t(dEyePupilR\t\t, dCharacter\t, 0.0);\n    dCharacter \t\t= opSmoothSubtractionV2\t(dHole\t\t\t, dCharacter\t, 0.05);\n\n    vec2 dFloorCutoff = vec2(p.y - 0.01, MAT_FLOOR);\n    dCharacter \t\t= opSmoothSubtractionV2\t(dFloorCutoff\t, dCharacter\t, 0.05);\n    \n    return dCharacter;\n}\n\n//-------------------------------------------------------------------------------\nvec2 getDist(vec3 p)\n{\n    // input data\n    vec3 pos1 = vec3(0.0);\n    vec3 pos2 = vec3(0.0);\n    pos1.xz = g_posVel1.xy;\n    pos2.xz = g_posVel2.xy;\n\n    vec3 posDelayed1 = vec3(0.0);\n    vec3 posDelayed2 = vec3(0.0);\n    posDelayed1.xz = g_data1.xy;\n    posDelayed2.xz = g_data2.xy;\n\n    // build characters\n    vec2 dCharacter1 = buildCharacter(p, pos1 + START_POS_PL_1, \n                                      posDelayed1.xyz - pos1.xyz,\n                                      g_special1,\n                                      2.3,\n                                      g_data1.w,\n                                      BREATH_SPEED, \n                                      0.0, MAT_BODY_1, MAT_EYES_1, MAT_EYES_SOCKETS_1);\n\n    vec2 dCharacter2 = buildCharacter(p, pos2 + START_POS_PL_2, \n                                      posDelayed2.xyz - pos2.xyz,\n                                      g_special2,\n                                      2.1,\n                                      g_data2.w, \n                                      1.2 * BREATH_SPEED, \n                                      0.8, MAT_BODY_2, MAT_EYES_2, MAT_EYES_SOCKETS_2);\n    \n    // build scene\n    vec2 dFinal = vec2(100000.0);\n    dFinal = opSmoothUnionV2(dFinal, dCharacter1, 0.3);\n    dFinal = opSmoothUnionV2(dFinal, dCharacter2, 0.3);\n    \n    vec2 dFloor = vec2(p.y, MAT_FLOOR);\n    dFinal = opSmoothUnionV2(dFinal, dFloor, 0.0);//0.3);\n    \n    return dFinal;\n}\n\n//-------------------------------------------------------------------------------\nvec2 rayMarch(vec3 ro, vec3 rd)\n{\n    vec2 dist \t= vec2(0.0);\n    vec2 d \t\t= vec2(0.0);\n    vec3 pos \t= vec3(0.0);\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        pos = ro + dist.x * rd;\n        d = getDist(pos);\n\t\tdist.x += d.x;\n        dist.y = d.y;\n\t\tif (dist.x<MIN_DIST)\n            break;\n        \n        if (dist.x>MAX_DIST)\n            return vec2(0.0, 0.0);\n    }\n    \n    return dist;\n}\n\n//-------------------------------------------------------------------------------\nfloat shadowMarch(vec3 ro, vec3 rd, vec3 lightPos)\n{\n    float dist = 0.0;\n    \n    \n    float res = 1.0;\n    \n    float power = 2.0;\n    \n    for(int i=0; i<MAX_STEPS; i++)\n    {\n        vec3 pos = ro + dist * rd;\n        float d = getDist(pos).x;\n        if (d < 0.01)\n            return 0.0;\n        \n\t\tdist += d;\n        \n        res = min(res, power * d / dist);\n        \n\t\tif (dist<MIN_DIST || dist>MAX_DIST)\n            break;\n    }\n\n    return res;\n}\n\n//-------------------------------------------------------------------------------\nvec3 getNormal(vec3 p)\n{\n    float d = getDist(p).x;\n    \n    vec2 e = vec2(0.001, 0.0);\n    //vec2 e = vec2(0.1, 0.0);\n    \n    vec3 n = d - vec3(getDist(p - e.xyy).x,\n                  \t  getDist(p - e.yxy).x,\n                      getDist(p - e.yyx).x);\n    \n    return normalize(n);\n}\n\n\n//-------------------------------------------------------------------------------\n// From:\n// Physically-based SDF by romainguy\n// https://www.shadertoy.com/view/XlKSDR\n//-------------------------------------------------------------------------------\nvec3 Tonemap_ACES(const vec3 x)\n{\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n//-------------------------------------------------------------------------------\nvec3 OECF_sRGBFast(const vec3 linear)\n{\n    return pow(linear, vec3(1.0 / 2.2));\n}\n//-------------------------------------------------------------------------------\n\n\n//-------------------------------------------------------------------------------\n// Lighting taken from:\n// Ray Marching: Part 2 by jlfwong\n// https://www.shadertoy.com/view/lt33z7\n//-------------------------------------------------------------------------------\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 N, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    float shadow = shadowMarch(p + N * 0.1, L, lightPos);\n    dotLN *= shadow;\n    \n    if (dotLN < 0.0)\n    {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0)\n    {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    vec3 col =  lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n    \n    return col;\n}\n\n//-------------------------------------------------------------------------------\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 N, vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye)\n{\n    const vec3 ambientLight = GLIGHT_MUL * 0.1 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          5.0,\n                          0.0 * cos(iTime));\n    vec3 light1Intensity = GLIGHT_MUL * 1.3 * vec3(1.0, 0.9, 0.8);\n    //vec3 light1Intensity = vec3(0.);\n    \n    color += phongContribForLight(N, k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(4.0 * sin(0.37 * iTime),\n                          7.0 + 2.0 * cos(0.37 * iTime),\n                          -1.0);\n    vec3 light2Intensity = GLIGHT_MUL * 1.3 * vec3(0.6, 0.7, 1.0);\n    //vec3 light2Intensity = vec3(0.);\n    \n    color += phongContribForLight(N, k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    \n    return color;\n}\n//-------------------------------------------------------------------------------\n\n\n\n//-------------------------------------------------------------------------------\n// shade\n//-------------------------------------------------------------------------------\nvec3 shade(vec3 ro, vec3 p, vec3 normal, float mat, float bgAnimSpeed, vec3 fogColor, float dist)\n{\n    vec3 col = vec3(0.0);\n\n\t// material parameters\n\tvec3 colAmbient \t= vec3(0.2, 0.2, 0.2);\n\tvec3 colDiffuse \t= 0.6 * vec3(1.0, 0.85, 0.8);\n\tvec3 colSpecular \t= vec3(1.0, 1.0, 1.0);\n\tfloat shininess \t= 100.0;\n\tfloat rimStrength \t= 0.4;\n\tfloat rimWidth \t\t= 0.8;\n\tvec3 rimColor \t\t= vec3 ((0.7 + 0.2 * sin(0.3 + 1.86 * iTime * bgAnimSpeed)), \n\t\t\t\t\t\t\t\t(0.8 + 0.2 * sin(0.6 + 1.92 * iTime * bgAnimSpeed)), \n\t\t\t\t\t\t\t\t(1.0 + 0.2 * sin(0.2 + 1.64 * iTime * bgAnimSpeed)));\n\t\n\t// floor\n\tif ( abs(mat - MAT_FLOOR) < 0.1)\n\t{\n\t\tcolDiffuse = 0.5 * vec3(1.0, 0.85, 0.8);\n\t\t//float param = clamp(pow(sin(3.0*p.x + 3.0*p.z), 6.0), 0.0, 1.0);\n\t\t//float param = clamp(pow(sin(0.07*dot(p, p + sin(10.0 * iTime) * vec3(1.0, 2.3, 0.3))), 6.0), 0.0, 1.0);\n\t\t//colDiffuse = vec3(0.6, 0.5, 0.1 + 0.4 * param);\n\t\t\n\t\trimStrength = 0.5;\n\t}\n\t// body 1\n\telse if ( abs(mat - MAT_BODY_1) < 0.1)\n\t{\n\t\tvec3 pos = p;\n\t\tpos.xz -= g_posVel1.xy;\n\t\tpos.y -= 0.8 * (1.0 - g_special1.x);\n\t\tfloat colorVal = 3.0 * sin(15.0*pos.y + 10.0*pos.x);\n\t\t//float colorVal = 3.0 * sin(15.0*cos(pos.y) + 30.0*sin(pos.x));\n\t\tcolDiffuse = vec3(0.8, 0.5 * clamp(0.1 + colorVal, 0.0, 1.0), 0.4);\n\t\t\n\t\t//shininess = 2.0;\n\t\t//colSpecular *= 0.12;\n\t}\n\t// body 2\n\telse if ( abs(mat - MAT_BODY_2) < 0.1)\n\t{\n\t\tvec3 pos = p;\n\t\tpos.xz -= g_posVel2.xy;\n\t\tpos.y -= 0.8 * (1.0 - g_special2.x);\n\t\t\n\t\tfloat colorVal = 3.0 * sin(15.0*pos.y + 10.0*pos.x);\n\t\t//float colorVal = 3.0 * sin(15.0*cos(pos.y) + 30.0*sin(pos.x));\n\t\tcolDiffuse = vec3(clamp(0.5 + colorVal, 0.0, 1.0), 0.5, 0.3);\n\t\t\n\t\t//shininess = 2.0;\n\t\t//colSpecular *= 0.12;\n\t}\n\t// eyes 1\n\telse if( abs(mat - MAT_EYES_1) < 0.1)\n\t{\n\t\tcolDiffuse = vec3(1.0, 0.9, 0.8);\n\t\trimStrength = 0.1;\n\t}\n\t// eyes 2\n\telse if( abs(mat - MAT_EYES_2) < 0.1)\n\t{\n\t\tcolDiffuse = vec3(0.9, 1.0, 0.6);\n\t\trimStrength = 0.1;\n\t}\n\t// eyes pupils\n\telse if( abs(mat - MAT_EYES_DOTS) < 0.1)\n\t{\n\t\tcolDiffuse = vec3(0.0, 0.0, 0.0);\n\t\trimStrength = 0.0;\n\t}\n\t// eyes sockets 1\n\telse if ( abs(mat - MAT_EYES_SOCKETS_1) < 0.1)\n\t{\n\t\tcolAmbient = vec3(0.0, 0.0, 0.0);\n\t\tcolDiffuse = vec3(0.0, 0.0, 0.0);\n\t\tcolSpecular = vec3(0.0, 0.0, 0.0);\n\t\t\n\t\trimColor = 0.7 * vec3(0.9, 0.1, 0.5);\n\t\trimWidth = 0.7;\n\t\trimStrength = 1.4;\n\t}\n\t// eyes sockets 2\n\telse if ( abs(mat - MAT_EYES_SOCKETS_2) < 0.1)\n\t{\n\t\tcolAmbient = vec3(0.0, 0.0, 0.0);\n\t\tcolDiffuse = vec3(0.0, 0.0, 0.0);\n\t\tcolSpecular = vec3(0.0, 0.0, 0.0);\n\t\t\n\t\trimColor = 0.7 * vec3(0.1, 0.7, 0.4);\n\t\trimWidth = 0.7;\n\t\trimStrength = 0.8;\n\t}\n\t\n\t// lighting\n\tcol = phongIllumination(normal, colAmbient, colDiffuse, colSpecular, shininess, p, ro);\n\t\n\t// rim light\n#if USE_RIM_LIGHT\n\tvec3 viewDir = normalize( ro - p);\n\tfloat vDotN = dot(normal, viewDir);\n\tfloat rim = smoothstep(1.0 - rimWidth, 1.0, 1.0 - vDotN);\n\tcol += 0.6 * rim * rimStrength * rimColor;\n#endif\n    \n    // fog\n    col = mix(col, fogColor, 1.0 - exp2(-0.0001 * dist * dist * dist));\n\n\t// debug - materials\n    //col = 0.1 * vec3(mat);\n        \n    // debug - rim\n    //col = vec3(rim);\n        \n    // debug - normals\n    //col = normal;\n    \n    return col;\n    \n}\n\n//-------------------------------------------------------------------------------\n// main\n//-------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // camera pos\n    vec3 ro = vec3(0,1.7,0);\n\n    // ray direction\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n\n    // read input\n    g_posVel1\t= loadValue( txPosVel1  );\n    g_posVel2\t= loadValue( txPosVel2  );\n    g_data1\t\t= loadValue( txData1  \t);\n    g_data2\t\t= loadValue( txData2  \t);\n    g_special1\t= loadValue( txSpecial1 );\n    g_special2\t= loadValue( txSpecial2\t);\n\n    // distance to the scene\n    vec2 result = rayMarch(ro, rd);\n    float d = result.x;\n    float mat = result.y;\n    \n    float bgAnimSpeed = 0.3;\n    \n    vec3 fogColor = vec3((0.7 + 0.1 * sin(0.3 + 1.36 * iTime * bgAnimSpeed)), \n                         (0.8 + 0.1 * sin(0.6 + 1.22 * iTime * bgAnimSpeed)), \n                         (0.7 + 0.1 * sin(0.2 + 1.54 * iTime * bgAnimSpeed)));\n\n    fogColor.x -= 0.7 * uv.y;\n    \n    fogColor *= GLIGHT_MUL;\n    \n    if (d <= 0.01f)\n    {\n        col = fogColor;\n    }\n    else\n    {\n        vec3 p = ro + rd * d;\n\n\t    vec3 normal = getNormal(p);\n        \n        col = shade(ro, p, normal, mat, bgAnimSpeed, fogColor, d);\n    }\n\n    // contrast\n    col *= 0.9;\n    col = pow(col, vec3(1.3));\n    \n#if USE_TONE_MAPPING\n    // tone mapping\n    col = Tonemap_ACES(col);\n#endif\n    \n    // gamma compression\n    col = OECF_sRGBFast(col);\n\n    // vignette\n    col *= 1.0 - dot(uv,uv)*0.4;\n    \n    // output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//-------------------------------------------------------------------------------\n// Matheads\n//-------------------------------------------------------------------------------\n// Copyright © 2020 Lukasz Lesicki\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//-------------------------------------------------------------------------------\n\nvec4 loadValue( in ivec2 re )\n{\n    return texelFetch( iChannel0, re, 0 );\n}\n\nvoid storeValue( in ivec2 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = (p==re) ? va : fragColor;\n}\n\nvoid storeValue( in ivec4 re, in vec4 va, inout vec4 fragColor, in ivec2 p )\n{\n    fragColor = ( p.x>=re.x && p.y>=re.y && p.x<=re.z && p.y<=re.w ) ? va : fragColor;\n}\n\nvoid handlePlayerInput(inout vec4 posVel, inout vec4 data, inout vec4 special, int keyL, int keyR, int keyF, int keyB, int keySpecial1, int keySpecial2)\n{\n    // unpack data\n    vec2 pos = posVel.xy;\n    vec2 vel = posVel.zw;\n    \n    vec2 deltaTemp \t= vec2(0.0);\n    \n    float moveRight \t= texelFetch( iChannel1, ivec2(keyR\t\t\t, 0), 0 ).x;\n    float moveLeft  \t= texelFetch( iChannel1, ivec2(keyL\t\t\t, 0), 0 ).x;\n    float moveForw  \t= texelFetch( iChannel1, ivec2(keyF\t\t\t, 0), 0 ).x;\n    float moveBack  \t= texelFetch( iChannel1, ivec2(keyB\t\t\t, 0), 0 ).x;\n    float inputSpecial1\t= texelFetch( iChannel1, ivec2(keySpecial1\t, 0), 0 ).x;\n    float inputSpecial2\t= texelFetch( iChannel1, ivec2(keySpecial2\t, 0), 0 ).x;\n\n    float inputSum = 0.0;\n    inputSum += moveRight;\n    inputSum += moveLeft;\n    inputSum += moveForw;\n    inputSum += moveBack;\n    float wasInput = abs(inputSum);\n    \n    \n    deltaTemp.x = steeringStrength * (moveRight - moveLeft);\n    deltaTemp.y = steeringStrength * (moveForw  - moveBack);\n    \n    \n    if (AUTO_DANCE)\n    {\n        if (DANCE_ALL_THE_TIME || (special.w > AUTO_DANCE_TIMER * 75.0))\n        {\n            // dancing\n            deltaTemp.xy += 0.03 * vec2(cos(2.3 * iTime), sin(3.9 * iTime));\n            deltaTemp = clamp(deltaTemp, vec2(-1.0), vec2(1.0));\n        }\n    }    \n    \n    vel = mix(vel, deltaTemp, vec2(0.05));\n    \n    pos += vel;\n    \n    data.xy = mix(data.xy, pos, vec2(0.08));\n\n    float lenVel = length(vel);\n\n    // anim timer\n    data.z += 1.8 * lenVel;\n    \n    // anim timer (smooth)\n    data.w = mix(data.w, data.z, 0.1);\n\n    // crouch\n    special.x = mix(special.x, inputSpecial1, 0.03);\n    \n    // sing\n    special.y = mix(special.y, inputSpecial2, 0.12);\n    \n    // timer without input\n    if (wasInput > 0.01)\n    {\n    \tspecial.w = 0.0;\n    }\n    else\n    {\n    \tspecial.w += 1.0;\n    }\n    \n    // debug\n    //special.y = (special.w > AUTO_DANCE_TIMER * 75.0) ? 1.0 : 0.0;\n    \n    \n    // pack data\n    posVel.xy = pos;\n    posVel.zw = vel;\n}\n\nvoid snapToCenter(inout vec2 pos, inout vec2 vel)\n{\n    vec2 center = vec2(0.0, 15.0);\n\n    vec2 vToCenter = center - pos;\n    float distFromCenter = length(vToCenter);\n    vec2 vDirToCenter = normalize(vToCenter);\n    \n    float wallVal = 0.005 * pow(max(distFromCenter-11.0, 0.0), 4.0);\n    vel += wallVal * vDirToCenter;\n    \n}\n\nvoid resolveCollision(inout vec4 posVel1, inout vec4 posVel2)\n{\n    // unpack data\n    vec2 pos1 = posVel1.xy;\n    vec2 vel1 = posVel1.zw;\n    vec2 pos2 = posVel2.xy;\n    vec2 vel2 = posVel2.zw;\n    \n    pos1 += START_POS_PL_1.xz;\n    pos2 += START_POS_PL_2.xz;\n    \n    \n    vec2 vBetween = pos2 - pos1;\n    float dist = abs(length(vBetween));\n    \n    vec2 vDir = normalize(vBetween);\n    \n    float minDist = 2.8;\n    \n    if (dist < minDist)\n    {\n        float correction = 0.5 * (dist - minDist);\n        vel2 += 0.008 * vDir;\n        vel1 -= 0.008 * vDir;\n    }\n    \n    snapToCenter(pos1, vel1);\n    snapToCenter(pos2, vel2);\n    \n    pos1 -= START_POS_PL_1.xz;\n    pos2 -= START_POS_PL_2.xz;\n    \n    // pack data\n    posVel1.xy = pos1;\n    posVel1.zw = vel1;\n    posVel2.xy = pos2;\n    posVel2.zw = vel2;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // don't compute outside of the data area\n    if( fragCoord.x > 7.0 || fragCoord.y > 1.0 )\n        discard;\n    \n    ivec2 ipx = ivec2(fragCoord-0.5);\n    \n    \n    vec4 posVel1\t= loadValue( txPosVel1  );\n    vec4 posVel2\t= loadValue( txPosVel2  );\n    vec4 data1\t\t= loadValue( txData1  \t);\n    vec4 data2\t\t= loadValue( txData2  \t);\n    vec4 special1\t= loadValue( txSpecial1 );\n    vec4 special2\t= loadValue( txSpecial2 );\n\n    \n    handlePlayerInput(posVel1, data1, special1, \n                                KEY_1_LEFT, \n                                KEY_1_RIGHT, \n                                KEY_1_FORW,\n                                KEY_1_BACK,\n                     \t\t\tKEY_1_SPEC_A,\n                     \t\t\tKEY_1_SPEC_B);\n\n    handlePlayerInput(posVel2, data2, special2,\n                                KEY_2_LEFT, \n                                KEY_2_RIGHT, \n                                KEY_2_FORW,\n                                KEY_2_BACK,\n                     \t\t\tKEY_2_SPEC_A,\n                     \t\t\tKEY_2_SPEC_B);\n    \n    resolveCollision(posVel1, posVel2);\n    \n    fragColor = vec4(0.);\n    \n    storeValue( txPosVel1, \tposVel1,   \tfragColor, ipx );\n    storeValue( txPosVel2, \tposVel2,\tfragColor, ipx );\n    storeValue( txData1, \tdata1,   \tfragColor, ipx );\n    storeValue( txData2, \tdata2,   \tfragColor, ipx );\n    storeValue( txSpecial1, special1,  \tfragColor, ipx );\n    storeValue( txSpecial2, special2,  \tfragColor, ipx );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"//-------------------------------------------------------------------------------\n// Matheads\n//-------------------------------------------------------------------------------\n// Copyright © 2020 Lukasz Lesicki\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//-------------------------------------------------------------------------------\n\n//-------------------------------------------------------------------------------\n#define MAX_STEPS \t\t\t\t100\n#define MIN_DIST\t    \t\t0.01\n#define MAX_DIST    \t\t\t50.0\n#define PI \t\t\t\t\t\t3.14159265\n#define MX_ID \t\t\t\t\t(mat3(1.0))\n#define USE_TONE_MAPPING\t\t0\n#define USE_RIM_LIGHT\t\t\t1\n#define GLIGHT_MUL\t\t\t\t(1.0)\n//-------------------------------------------------------------------------------\n#define MAT_FLOOR \t\t\t\t0.0\n#define MAT_BODY_1\t\t\t\t1.0\n#define MAT_BODY_2\t\t\t\t2.0\n#define MAT_EYES_1\t\t\t\t3.0\n#define MAT_EYES_2\t\t\t\t4.0\n#define MAT_EYES_DOTS\t\t\t5.0\n#define MAT_EYES_SOCKETS_1\t\t6.0\n#define MAT_EYES_SOCKETS_2\t\t7.0\n//-------------------------------------------------------------------------------\n#define START_POS_PL_1\t\t\tvec3(-2.0, 0.0, 7.0)\n#define START_POS_PL_2\t\t\tvec3(2.0, 0.0, 7.0)\n#define LEGS_ANGLE\t\t\t\t(0.6 * PI)\n#define BREATH_SPEED \t\t\t(3.0)\n#define EYE_RADIUS_L \t\t\t(0.5)\n#define EYE_RADIUS_R \t\t\t(0.3)\n//-------------------------------------------------------------------------------\n#define DANCE_ALL_THE_TIME\t\t(false)\n#define AUTO_DANCE\t\t\t\t(true)\t\t// auto dance on character which does not move for some time\n#define AUTO_DANCE_TIMER\t\t(4.0)\t\t// in [s]\n//-------------------------------------------------------------------------------\n\n// WASD, QE\nconst int KEY_1_LEFT  \t= 65;\nconst int KEY_1_RIGHT \t= 68;\nconst int KEY_1_FORW  \t= 87;\nconst int KEY_1_BACK  \t= 83;\nconst int KEY_1_SPEC_A  = 81;\nconst int KEY_1_SPEC_B  = 69;\n\n// ARROWS, CTRL, SHIFT\nconst int KEY_2_LEFT  \t= 37;\nconst int KEY_2_RIGHT \t= 39;\nconst int KEY_2_FORW  \t= 38;\nconst int KEY_2_BACK  \t= 40;\nconst int KEY_2_SPEC_A  = 17;\nconst int KEY_2_SPEC_B  = 16;\n\n// IJKL, UO\n//const int KEY_2_LEFT  \t= 74;\n//const int KEY_2_RIGHT \t= 76;\n//const int KEY_2_FORW  \t= 73;\n//const int KEY_2_BACK  \t= 75;\n//const int KEY_2_SPEC_A  = 79;\n//const int KEY_2_SPEC_B  = 85;\n\n//-------------------------------------------------------------------------------\nconst ivec2 txPosVel1 \t= ivec2(1,0);\nconst ivec2 txPosVel2 \t= ivec2(2,0);\nconst ivec2 txData1 \t= ivec2(3,0);\nconst ivec2 txData2 \t= ivec2(4,0);\nconst ivec2 txSpecial1 \t= ivec2(5,0);\nconst ivec2 txSpecial2 \t= ivec2(6,0);\n//-------------------------------------------------------------------------------\nconst float steeringStrength = 0.07;\n//-------------------------------------------------------------------------------\n","name":"Common","description":"","type":"common"}]}