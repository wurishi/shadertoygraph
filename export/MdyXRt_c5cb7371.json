{"ver":"0.1","info":{"id":"MdyXRt","date":"1465958061","viewed":2994,"name":"denoising with Kuwahara filter","username":"vladkvit","description":"some denoising tests. Kuwahara filter. Buf A takes an image and adds noise. Buf B calculates the median and deviation on some square kernel (default width 3). \"Image\" denoises using the Kuwahara filter.","likes":25,"published":1,"flags":32,"usePreview":0,"tags":["signalprocessing","denoising"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 denoise0( in sampler2D tex, in vec2 pix )\n{\n    vec2 uv = pix / iResolution.xy;\n\treturn( texture( tex, uv ) );   \n}\n\nvec4 denoise1( in sampler2D tex, in vec2 pix )\n{\n    //not bothering with 2-pass separable approach\n    mat3 avg_sampler;\n    avg_sampler[0] = vec3( 1.0, 2.0, 1.0 );\n    avg_sampler[2] = avg_sampler[0];\n    avg_sampler[1] = avg_sampler[0] * 2.0;\n    avg_sampler /= 16.0;\n    \n    vec4 accum = vec4(0.0);\n    for( int i = 0; i < 3; i++ )\n    {\n        for( int j = 0; j < 3; j++ )\n        {\n\t\t\tvec2 uv = pix;\n            uv += vec2( i,j);\n            uv += vec2( -1.0, -1.0 );\n            uv /= iResolution.xy;\n            accum += texture( tex, uv ) * avg_sampler[i][j];\n        }\n    }\n    \n    return accum;\n}\n\nvec4 denoise2( in sampler2D tex, in vec2 pix )\n{\n    const float size = 1.0;\n    \n    vec2 offsets[4];\n    offsets[0] = vec2( -1.0, -1.0) * size;\n    offsets[1] = vec2( 1.0, -1.0) * size;\n    offsets[2] = vec2( -1.0, 1.0) * size;\n    offsets[3] = vec2( 1.0, 1.0) * size;\n    \n    float cur_dev = 9999999999.0;\n    vec4 result = vec4(0.5);\n    result.a = 1.0;\n    \n    for( int quad = 0; quad < 4; quad++)\n    {\n\t\tvec2 sp = pix + offsets[quad];\n        vec2 uv = sp / iResolution.xy;\n        vec4 smpl = texture( iChannel1, uv );\n        float deviation = smpl.a;\n        if( deviation < cur_dev )\n        {\n            cur_dev = deviation;\n            result.rgb = smpl.rgb;\n        }\n    }\n    \n    \n    \n    return result;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = denoise2( iChannel0, fragCoord.xy );\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    //fragColor = texture( iChannel1, uv );\n\t//fragColor = texture( iChannel0, uv );\n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"vec4 gradient( in vec2 uv )\n{\n    return vec4(uv,1.0,1.0);\n}\n\nvec3 addnoise( in vec2 uv )\n{\n    vec3 x = texture( iChannel0, uv*3.0 ).rgb;\n    return (x - 0.5);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t//fragColor = gradient( uv );\n    fragColor = texture( iChannel1, uv );\n    fragColor.rgb += addnoise( uv ) * 0.3;\n}\n\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"float vec3_float_flat( in vec3 t )\n{\n    const vec3 coeffs = vec3( 1.0/3.0, 1.0/3.0, 1.0/3.0 );\n    t *= coeffs;\n    return t.r + t.g + t.b;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int kernel_size = 3;\n    const float kernel_sq = float( kernel_size * kernel_size);\n    \n    fragColor = vec4(0.0,0.0,1.0,1.0);\n    \n    vec3 means = vec3(0.0);\n    vec3 deviations = vec3(0.0);\n\n    for( int i = 0; i < kernel_size; i++ )\n    {\n        for( int j = 0; j < kernel_size; j++ )\n        {\n            vec2 uv = fragCoord;\n            uv += vec2( i,j);\n            uv += vec2( -1.0, -1.0 );\n            uv /= iResolution.xy;\n            vec3 smpl = texture( iChannel0, uv ).rgb;\n            means += smpl / kernel_sq;\n\n            deviations += smpl*smpl / kernel_sq;\n        }\n    }\n    deviations -= ( means * means);\n\n    \n    \n    float deviation = vec3_float_flat( deviations );\n    fragColor.a = deviation;\n    \n    fragColor.rgb = means;\n    //deviations *= 10.0;\n    //fragColor.rgb = deviations;\n\n}","name":"Buf B","description":"","type":"buffer"}]}