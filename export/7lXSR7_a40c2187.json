{"ver":"0.1","info":{"id":"7lXSR7","date":"1625335305","viewed":117,"name":"spectral renderer attempt","username":"incription","description":"i didnt really research anything for this but you can see my approach I tried, im not sure how to do it properly, if anyone can provide some pointers that would be great","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raytracing","spectral"],"hasliked":0,"parentid":"WlyyRz","parentname":"4D Manifold"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 100.\n#define W_Min 1e-6\n#define W_Max 4e-6\n#define W_Count 10.\n#define slices 10.0\n\nfloat SURF_DIST;\n\n//From https://www.shadertoy.com/view/WddczH, thx\nvec3 nm_xyz(int i)\n{\n    switch(i)\n    {\n     \tcase 0:\n        \treturn vec3(0.001368, \t0.000039,\t0.00645);\t//380nm\n        case 1:\n        \treturn vec3(0.13438,\t0.004,\t\t0.6456); \t//420\n        case 2:\n        \treturn vec3(0.2908,\t\t0.06,\t\t1.6692); \t//460\n        case 3:\n        \treturn vec3(0.0049,\t\t0.323,\t\t0.272); \t//500\n        case 4:\n        \treturn vec3(0.2904,\t\t0.954,\t\t0.0203); \t//540\n        case 5:\n        \treturn vec3(0.9163,\t\t0.87,\t\t0.00165); \t//580\n        case 6:\n        \treturn vec3(0.85445,\t0.381,\t\t0.00019); \t//620\n        case 7:\n        \treturn vec3(0.1649,\t\t0.061,\t\t0); \t\t//660\n        case 8:\n        \treturn vec3(0.002899,\t0.001047,\t0); \t\t//720\n        case 9:\n        \treturn vec3(0.000166,\t0.00006,\t0); \t\t//760\n        default:\n        \treturn vec3(0.0);\n    }\n}\n\nvec3 xyz_to_sRGB(vec3 xyz)\n{\n    //assuming xyz coded relative to D65\n\n    //XYZ-to-sRGB conversion matrix (taken from another site)\n    mat3x3 conv_matrix = mat3x3(\t3.2404542f, -1.5371385f, -0.4985314f,\n     \t\t\t\t\t\t\t\t-0.9692660f, 1.8760108f, 0.0415560f,\n     \t\t\t\t\t\t\t\t0.0556434f,  - 0.2040259f, 1.0572252f);\n\n    vec3 ret = xyz * conv_matrix;\n\n    //companding for gamma?\n    //nah\n\n    //companding..? for sRGB\n    ret.x = ret.x <= 0.0031308f ? (12.92f * ret.x) : (1.055f * pow(ret.x, 1.0f / 2.4f) - 0.055f);\n    ret.y = ret.y <= 0.0031308f ? (12.92f * ret.y) : (1.055f * pow(ret.y, 1.0f / 2.4f) - 0.055f);\n    ret.z = ret.z <= 0.0031308f ? (12.92f * ret.z) : (1.055f * pow(ret.z, 1.0f / 2.4f) - 0.055f);\n    //\n\n    ret.x = clamp(ret.x,0.0,1.0);\n    ret.y = clamp(ret.y,0.0,1.0);\n    ret.z = clamp(ret.z,0.0,1.0);\n\n    return ret;\n}\n\nvec3 xyz_to_srgb_lerped(float nm)\n{\n    int i = int(floor((nm - 380.0) / (400.0 / slices)));\n    \n    return mix(xyz_to_sRGB(nm_xyz(i)), xyz_to_sRGB(nm_xyz(i+1)), mod(nm-380.0,(400.0 / slices)) /40.0);\n}\n\nvec3 wToRgb(float w) {\n    return xyz_to_srgb_lerped(w * 2e8);\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec3 opTwist(vec3 p )\n{\n    float k = iTime; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}\n\nfloat GetDist(vec3 p) {\n\tvec3 s = vec3(0, 1, 6);\n    \n    float objDist = sdBox(opTwist(p - s), vec3(1.));\n    float planeDist = p.y;\n    \n    float d = min(objDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) { //ri: tet index, ro: position on tet, rd: direction on tet\n\tfloat dO=0.;\n    float surfDist = min(W_Max, SURF_DIST);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(SURF_DIST / 2., 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p) {\n    vec3 lightPos = vec3(5, 5, -6);\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d<length(lightPos-p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    float j;\n    for(j = 0.; j < W_Count; j++)\n    {\n        //SURF_DIST = (W_Min + (W_Max - W_Min) * float(j)) * 1.;\n        SURF_DIST = mix(W_Max, W_Min, j / W_Count) / 2.;\n        float d = RayMarch(ro, rd);\n        vec3 p = ro + rd * d;\n        ro += rd * (d - SURF_DIST);\n       \n        col += 1. * (wToRgb(SURF_DIST * 2.) * GetLight(p));\n    }\n    \n    col = pow(col / float(j), vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}