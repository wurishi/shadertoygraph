{"ver":"0.1","info":{"id":"lf2SWy","date":"1706784916","viewed":84,"name":"Simple Grid Dot Pattern","username":"chronos","description":"simple, grid, dot, pattern","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["simple","grid","basic","animated","pattern","dot"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Simple Grid Dot Pattern by chronos\n    \n        maybe useful for someone, idk :)\n\n*/\n\nconst float grid_dim = 5.;\n\nfloat dot_grid_pattern(vec2 p)\n{\n    vec2 cell_idx = floor(p);\n    \n    // can just remove these if you want a static pattern\n    float animation_offset = hash(vec3(cell_idx, 0.));\n    float animation = floor(iTime*.125 + animation_offset); \n    \n    float rnd = hash(vec3(cell_idx, animation));\n    vec2 q = .5 + .5*cos(2.*PI * p - PI);\n    return (q.x * q.y) * float(rnd > 0.5); // Last factor is the binary thresholded noise that is used as a mask\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n    vec2 mouse = (2.*iMouse.xy-iResolution.xy)/iResolution.y;\n    \n    if(length(iMouse.xy) < 10.) mouse.xy = vec2(0, max(sin(iTime), 0.));\n\n    float zoom = 1. + mouse.y;\n\n    vec3 color = vec3(0);\n    \n    vec2 p = grid_dim * (zoom * uv + iTime*.25); // animated grid coordinates\n    \n    color += dot_grid_pattern(p);\n    \n    color = pow(color, vec3(1./2.2));\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265;\n\nfloat hash(vec3 uv)\n{\n    uint x = floatBitsToUint(uv.x) | 1u; // 0 is a fixed point so we remove it. although this introduces duplicate 1\n    uint y = floatBitsToUint(uv.y);\n    uint z = floatBitsToUint(uv.z);\n    \n    y ^= y >> 13;\n    y ^= y << 17;\n    y ^= y >> 5;\n    y *= 0x2545F491u;\n\n    x ^= y;\n    x ^= x >> 13;\n    x ^= x << 17;\n    x ^= x >> 5;\n    x *= 0x4F6CDD1Du;\n    \n    z ^= x;\n    z ^= z >> 13;\n    z ^= z << 17;\n    z ^= z >> 5;\n    z *= 0x1D6C45F4u;\n    \n    // Shift down by 9 to use top 23 bits in mantissa\n    // Use exponent and sign bits from 0.5\n    // floatBitsToUint(.5) is a constant so that part can be pre-computed. (0x3f000000)\n    // Since the top 23 bits are shifted right, the rest (top bits) are zero and do not need to be masked out\n    // uint w = ((z>>9) & 0x007FFFFFu) | (0xFF800000u & floatBitsToUint(.5));\n    \n    uint w = (z>>9) | 0x3f000000u; // simplified version of the above commented out line\n    \n    // re-normalize from [0.5, 1) to [0, 1)\n    // This probably loses some bits, but should still be ok\n    return 2. * uintBitsToFloat(w) - 1.;\n}\n","name":"Common","description":"","type":"common"}]}