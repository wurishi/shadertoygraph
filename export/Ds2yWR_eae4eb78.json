{"ver":"0.1","info":{"id":"Ds2yWR","date":"1687586119","viewed":71,"name":"raymarching quaternion rot","username":"calc","description":"rotate raymarch object using quaternion","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","quaternion"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 quatMlt(vec4 q1, vec4 q2) {\n    vec3 u1 = vec3(q1.x, q1.y, q1.z);\n    vec3 u2 = vec3(q2.x, q2.y, q2.z);\n    float s1 = q1.w;\n    float s2 = q2.w;\n\n    vec3 v = cross(u1, u2) + s1 * u2 + s2 * u1;\n    float s = s1 * s2 - dot(u1, u2);\n\n    return vec4(v, s);\n}\n\nvec4 quaternionConjugate(vec4 q) {\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}// 四元数の共役を計算. 単位ベクトルなのでq^-1 = q^* となる.\n//ref :https://itandcfd.com/quaternion/1883/\n// https://zenn.dev/mebiusbox/books/132b654aa02124/viewer/2966c7\n// https://techblog.sega.jp/entry/2021/06/15/100000 \n\nvec4 axisAngleToQuaternion(vec3 axis, float angle) {\n    axis = normalize(axis);\n    float halfAngle = angle * 0.5;\n    float s = sin(halfAngle);\n\n    return vec4( axis * s, cos(halfAngle));\n}\n\nvec3 rotateWithQuaternion(vec3 p, vec4 q) {\n    vec4 p_quaternion = vec4(p, 0.0);\n    vec4 q_conjugate = quaternionConjugate(q);\n    vec4 p_prime = quatMlt(quatMlt(q, p_quaternion), q_conjugate);\n    return vec3(p_prime.x, p_prime.y, p_prime.z);\n}\n/*\n\n*/\n\n  const int MAX_MARCHING_STEPS = 255;\n  const float MIN_DIST = 0.0;\n  const float MAX_DIST = 100.0;\n  const float PRECISION = 0.001;\n  const vec3 BACKGROUND_COLOR = vec3(0.0, 0.0, 0.0);\n\n\n\n  float sdSphere(vec3 p, float r )\n  {\n    vec3 offset = vec3(0, 0, -2);\n    return length(p - offset) - r;\n  }\n  float sdRoundBox( vec3 p, vec3 b, float r )\n  {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n  }\n\n  float map(vec3 p) {\n    //vec3 center = vec3(0, -2, 0); //回転の基点を変更。（これなしだとBoxの重心を中心に回る）\n    vec3 b = vec3(.3,.8, .2); // radius of sphere\n    float d = sdRoundBox(p , b, .2);\n    return d;\n  }\n\n  vec3 calcNormal(vec3 p) {\n      vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n      vec3 b = vec3(.3,.8, .2); // radius of box\n      return normalize(\n        e.xyy * sdRoundBox(p + e.xyy, b, .2) +\n        e.yyx * sdRoundBox(p + e.yyx, b, .2) +\n        e.yxy * sdRoundBox(p + e.yxy, b, .2) +\n        e.xxx * sdRoundBox(p + e.xxx, b, .2));\n  }\n\n  vec3 ApplyGammaCorrection(vec3 color){\n      float gamma =2.2;\n      return pow(color, vec3(1. / gamma));\n  }\n\n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n  {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 0, -3); // ray origin that represents **camera position**\n    vec3 camera_dir = normalize(vec3(0 , 0 , 1.0)); // ray direction\n    vec3 camera_up = vec3(0, 1, 0); // ray up vector\n    vec3 camera_side = cross(camera_dir,camera_up ); // ray side vector\n\n    vec3 rd = normalize(camera_dir + uv.x * camera_side + uv.y * camera_up); // ray direction\n\n    // ### // \n    vec3 axis = normalize( vec3(1.0, 1.0, 0.0) ); \n    float angle= mod(iTime, 360.);  \n\n    // 回転ベクトルを定義します\n    vec3 v = vec3(1.0, 0.0, 0.0); // x軸上の点を\n\n    // 四元数を計算します\n    vec4 q = axisAngleToQuaternion(axis, angle);\n    vec4 q_conjugate = quaternionConjugate(q);\n    // ### // \n\n\n\n\n\n\n    // ray marching\n    float d = 0.0;\n    vec3 p = ro; // p is now pos\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n      d = map(\n        rotateWithQuaternion(p, q)\n      ); //! ###\n      p += d * rd;\n    }\n      // light\n    vec3 li_pos = vec3(2, 3, -4);\n    vec3 li_dir = normalize(li_pos - p);\n\n\n\n\n\n    if (d > MAX_DIST) {\n      col = vec3(BACKGROUND_COLOR); // ray didn't hit anything\n    } else {\n      vec3 normal = calcNormal(\n        rotateWithQuaternion(p, q)\n      ); //! ###\n\n      // Calculate diffuse reflection by taking the dot product of \n      // the normal and the light direction.\n      float dif = dot(normal, li_dir);\n\n      col = ApplyGammaCorrection( vec3(dif) );\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n  }","name":"Image","description":"","type":"image"}]}