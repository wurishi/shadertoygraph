{"ver":"0.1","info":{"id":"DlycWw","date":"1700254004","viewed":77,"name":"caterpillar union","username":"siers","description":"caterpillar from unified sphere surfaces","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","sdf","sphere","union"],"hasliked":0,"parentid":"DltcW8","parentname":"triangles around a sphere"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float radian = 2. * 3.14159265;\n\n// at the time of writing, I can't rewrite it from memory, but I can imagine why this fn works\nfloat opSmoothUnion( float d1, float d2, float k ) {\n  float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n  return mix(d2, d1, h) - k * h * (1.0 - h);\n}\n\nfloat sdSphere(vec3 p, vec3 offset, float radius) {\n  return length(offset - p) - radius;\n}\n\nvec3 sphereCenter = vec3(0, 0, 5);\nfloat sphereCount = 5.;\n\nvec3 sphereShift(int i, float n) {\n  float p = float(i) / n, c = 1.5;\n  float d = p * (n * 0.05); // * 1.0 to make them equidistant\n  float t = (iTime / 4. + d * c) / c * radian;\n  return vec3(cos(t) * 2., sin(t * 2.), 0);\n}\n\nfloat sdf(vec3 uv) {\n  float sdf = 1000., n = 5., r = 0.4;\n\n  for (int i; float(i) < n; i++) {\n    vec3 center = sphereCenter + sphereShift(i, n);\n    vec3 center_ = sphereCenter + sphereShift(i - 1, n);\n    sdf = opSmoothUnion(sdf, sdSphere(uv, center, r), (length(center - center_) - r + 0.1));\n  }\n\n  return sdf;\n}\n\nfloat sdfDiff(vec3 uv, vec3 diff) {\n  return sdf(uv + diff) - sdf(uv - diff);\n}\n\nfloat sdfLight(vec3 uv, vec3 light, float eps) {\n  vec3 normal = vec3(sdfDiff(uv, vec3(eps, 0, 0)), sdfDiff(uv, vec3(0, eps, 0)), sdfDiff(uv, vec3(0, 0, eps)));\n  float angle = dot(normalize(light - uv), normalize(normal));\n  angle = pow((angle + 1.) / 2., 3.) * 2. - 1.;\n  return angle;\n}\n\nvec4 color(vec3 uv, vec3 light) {\n  vec4 red = vec4(0.92, 0.13, 0.07, 0);\n  vec4 white = vec4(250, 222, 255, 0) / 255.;\n  vec4 dark = vec4(112, 30, 71, 0) / 255.;\n\n  float angle = sdfLight(uv, light, 0.01);\n  vec4 color = angle >= 0. ? mix(red, white, angle) : mix(dark, red, 1. + angle);\n\n  return color;\n}\n\nvec4 checkerboard(vec3 uv1) {\n  vec2 uv = fract(normalize(uv1).xy * 4.) * 2.;\n  int bit = (int(uv.x) + int(uv.y)) % 2;\n  return mix(vec4(0.2), vec4(0.3), float(bit));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 uv = normalize(vec3(2.0 * (fragCoord.xy - iResolution.xy / 2.) / iResolution.y, 3.));\n  vec3 uvNormal = uv;\n  vec3 light = sphereCenter - vec3(0, 0, 0.5) + sphereShift(int(sphereCount) + 2, sphereCount);\n\n  if (iMouse.z > 0.) light = vec3(2.0 * (iMouse.xy - iResolution.xy / 2.) / iResolution.y, 4);\n\n  float i, d, most = 50., esc = 10.;\n  for (i = 0.; i < most && (d = sdf(uv)) <= esc; i++) uv += uvNormal * d;\n\n  vec4 background = checkerboard(uv);\n  fragColor = i < most ? background : color(uv, light);\n}\n","name":"Image","description":"","type":"image"}]}