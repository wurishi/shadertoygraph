{"ver":"0.1","info":{"id":"MtVXz1","date":"1483048266","viewed":127,"name":"gui-scale","username":"Barteks2x","description":"Scaling code for gui. If you randomly found this shader, ignore it","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["gui"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define ONEV2 vec2(1, 1)\n\n// if this is defined, then the code will work as if top-left corner was (0, 0)\n#define REVERSE_Y\n\n//#define TEST_EXACT_SIZE\n//#define TEST_MIN_MAX_UV\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n#ifdef REVERSE_Y\n    uv.y = 1.-uv.y;\n#endif\n\n#ifndef TEST_EXACT_SIZE\n    // actually what is needed is borderRenderedSizePixels/renderSizePixels and renderSizePixels/textureSizePixels\n    // uploading these instead means uploading 2 floats less\n    vec2 textureSizePixels = vec2(256, 256); // total size of the texture in pixels\n    vec2 renderSizePixels = iResolution.xy; // total component size in pixels\n    vec2 borderRenderedSizePixels = vec2(16, 16); // border size in pixels, specifies how many pixels on screen will be used for border\n#else\n    vec2 textureSizePixels = vec2(16, 16);\n    vec2 renderSizePixels = vec2(40, 40);// 16*2+4*2\n    vec2 borderRenderedSizePixels = vec2(4, 4);\n#endif\n#ifndef TEST_MIN_MAX_UV\n    vec2 minTextureUV = vec2(0, 0); // min/max texture UV coordinates for that component\n\tvec2 maxTextureUV = vec2(1, 1);\n#else\n    vec2 minTextureUV = vec2(0.5, 0.5); \n\tvec2 maxTextureUV = vec2(1, 1);\n#endif\n\tvec2 borderTextureUV = vec2(1./4.0, 1./4.0); // size of border in texture UV coordinates, specifies which parts of textures aree used as border\n\t\n    vec2 pos = uv; // fragment position, between 0 and 1\n    \n    // inputs - end\n    \n    vec2 borderScreenUVSize = borderRenderedSizePixels/renderSizePixels;\n    vec2 renderSizeToTextureSizeRatio = renderSizePixels/textureSizePixels;\n    \n    // scale the uv coordinates to tile the center texture\n    vec2 uvOut = (pos-borderScreenUVSize) * renderSizeToTextureSizeRatio;\n    // and tile the texture\n    uvOut = mod(uvOut, vec2(1.0, 1.0));\n   \t// use the tiled uv that is between 0 and 1 to interpolate between \n    // minTextureUV + borderTextureUV and maxTextureUV - borderTextureUV\n    uvOut = mix(minTextureUV + borderTextureUV, maxTextureUV - borderTextureUV, uvOut);\n    \n    // texture coordinates  that would be used if it was border\n    vec2 minBorderOut = mix(minTextureUV, minTextureUV+borderTextureUV, pos/borderScreenUVSize);\n    vec2 maxBorderOut = mix(maxTextureUV, maxTextureUV-borderTextureUV, (ONEV2 - pos)/borderScreenUVSize);\n    // set texture coordinates to border coordinates if it's actually in borders\n    if(pos.x < borderScreenUVSize.x) {\n        uvOut.x = minBorderOut.x;\n    }\n    \n    if(pos.x > 1.0 - borderScreenUVSize.x) {\n        uvOut.x = maxBorderOut.x;\n    }\n    \n    if(pos.y < borderScreenUVSize.y) {\n        uvOut.y = minBorderOut.y;\n    }\n    \n    if(pos.y > 1.0 - borderScreenUVSize.y) {\n        uvOut.y = maxBorderOut.y;\n    }\n#ifdef REVERSE_Y\n    uvOut.y = 1.0-uvOut.y;\n#endif\n\tfragColor = texture(iChannel0, uvOut);\n}","name":"Image","description":"","type":"image"}]}