{"ver":"0.1","info":{"id":"4ftBzS","date":"1733407710","viewed":496,"name":"Mobius Spiral Metaball Field","username":"Shane","description":"Applying a log polar Mobius spiral transformation to a metaball field","likes":70,"published":3,"flags":0,"usePreview":0,"tags":["spiral","metaball","mobius","complex","polar","log"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n\n    Mobius Spiral Metaball Field\n    ----------------------------\n    \n    Applying a log polar Mobius spiral transformation to a metaball field.\n    I've mentioned a few times that the humble metaball effect is one of \n    my oldschool favorites. As metaball examples go, I'd imagine this \n    variation doesn't come up often. :)\n    \n    I'm sure a lot people know that you can take a particle or more and \n    render some field lines around it. This just takes it a few steps\n    further by applying some common complex arithmetic functions.\n    \n    Anyway, I've explained things briefly. At some stage, I intend to post\n    a few other examples along these lines.\n    \n    \n    \n    Other examples:\n    \n    // Beautiful example. MLA is really good at applying less \n    // commonly applied complex analysis related material to the \n    // canvas.\n    Complex Atanh Made Simple - mla\n    https://www.shadertoy.com/view/WtjczR\n    \n    // The following unlisted example should explain how to \n    // put together a simple Mobius spiral.\n    Logarithmic Mobius Transform - Shane\n    https://www.shadertoy.com/view/4dcSWs\n    \n*/\n\n// The complex coordinate transformations. When all three are commented\n// out, the repeat image will appear. Not that exciting, but helpful in\n// understanding how things work. :)\n//\n// The spiral transform on its own will simply shift the original texture\n// lines across, which will make it look rotated. \n\n// Mobius transform.\n#define MOBIUS\n// Log polar transform.\n#define LOG_POLAR\n// Spiral transform.\n#define SPIRAL\n\n\n///////////////////////////\n// PI and 2PI.\n#define PI 3.14159265358979\n#define TAU 6.283185307179\n\n// Real and imaginary vectors. Handy to have.\n#define R vec2(1, 0)\n//#define I vec2(0, 1)\n\n// Common complex arithmetic functions. Most are self explanatory...\n// provided you know a little bit about complex analysis. If you don't,\n// it's not difficult to learn.\nvec2 conj(vec2 a){ return vec2(a.x, -a.y); }\nvec2 cmul(vec2 a, vec2 b){ return mat2(a, -a.y, a.x)*b; }\nvec2 cinv(vec2 a){ return vec2(a.x, -a.y)/dot(a, a); }\nvec2 cdiv(vec2 a, vec2 b){ return cmul(a, cinv(b)); }\nvec2 clog(in vec2 z){ return vec2(log(length(z)), atan(z.y, z.x)); }\n\n\n// The Mobius function.\nvec2 mobius(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d){\n\n    return cdiv(cmul(z, a) + b, cmul(z, c) + d);\n}\n\n\n//////////////////////\n \n// The complex metaball transformation function.\nvec2 transf(in vec2 z){\n\n\n    // Function coordinates.\n    vec2 fz = vec2(0);\n    \n    // Two metaball movement time variables.\n    float time = iTime/4.;\n    \n    float time2 = time + 3.;\n    \n    int pNum = 5;\n    // Set the particle's position, calculated it's field strength contribution, then\n    // add it to the total field strength value.\n\tfor(int i = 0; i<pNum; i++){\t\n        \n        float fi = float(i);\n        // Random sinusoidal motion for each particle. Made up on the spot, so could \n        // definitely be improved upon.\n        float rnd = fi*(PI*2. + .5453); //(hash(i)*.5 + .5)*PI*2.;\n\t\tvec2 pos = vec2(sin(time*.97 + rnd*3.11)*.5, \n                        cos(time*1.03 + rnd*5.73)*.4);\n\t\tpos *= vec2(sin(time*1.05 + fi*(fi + 1.)*PI/9.11), \n                    cos(time*.95 + fi*(fi - 1.)*PI/7.73))*1.25;\n        \n        // Modulating the radius from zero to maximum to give the impression that the \n        // particles are attracted to the center. \n        //pos *= abs(sin(time*1.5 + i*3.14159/pNum))*1.2; // Bounce.\n        // Smoother motion.\n        if((i%2) == 1) pos *= (cos(time*3. + fi*3.14159/float(pNum))*.5 + .5); \n        \n        \n \t    vec2 pos2 = vec2(sin(time2*.97 + rnd*3.11)*.5, \n                        cos(time2*1.03 + rnd*5.73)*.4);\n\t\tpos *= vec2(sin(time2*1.05 + fi*(fi + 1.)*PI/9.11), \n                    cos(time2*.95 + fi*(fi - 1.)*PI/7.73))*1.25;\n        \n        // Modulating the radius from zero to maximum to give the impression that the \n        // particles are attracted to the center. \n        //pos *= abs(sin(time*1.5 + i*3.14159/pNum))*1.2; // Bounce\n        if((i%2) == 1) pos2 *= (cos(time2*3. + fi*3.14159/float(pNum))*.5 + .5); // Smoother motion.\n        \n        \n        // The complex transformation portion. Without any of these, this would\n        // just be a regular metaball demonstration.\n        \n        #ifdef MOBIUS\n        // I can't recall ever seeing the usage of this function explained in simple \n        // terms, so I'll do it here. Put two negative real vectors (R = vec2(1, 0)) \n        // in the positions shown, then place the anchor points in the remaining spots \n        // (pos and pos2), and that's it... Whether this is \"technically\" correct, I'm \n        // not sure. However, if you're a democoder, etc, who just wants to render a \n        // double spiral with moving anchor points, this will get you there.\n        vec2 zi = mobius(z, -R, pos, -R, pos2); \n        #else\n        // Just the repeat texture.\n        vec2 zi = z - pos;\n        #endif \n        \n        #ifdef LOG_POLAR\n        // A Mobius transform differs aesthetically from a log polar Mobius \n        // transform, although we often imply a log polar Mobius transfomm.\n        // Anyway, this is a log polar transform, which is just a regular polar\n        // transform with the natural logarithm applied to the radial portion.\n        //\n        zi = clog(zi);\n        // Including the other particles when not using a Mobius transform.\n        // I find it a little busy.\n        //#ifndef MOBIUS\n        //zi += clog(z - pos2);\n        //#endif\n        #endif\n        \n        #ifdef SPIRAL\n        // Spirals are created by arranging for concentric rings to move out \n        // along the radial direction by one or more rings per revolution --\n        // As an aside, for things like hexagon or bridck patterns, it might\n        // be half a radial cell. Anyway, this can be effected by complex \n        // multiplication of the angular component in the order of a cell width \n        // (half, or whatever) divided by a full revolution, TAU. In this case, \n        // we're moving out by 2 cell units in order for the colors to match \n        // up -- which has something to do with the custom cell subdivision I \n        // wanted to perform.\n        vec2 e = vec2(1, 2./TAU);\n        zi = cmul(zi, e); \n        #endif\n         \n        // Scaling.\n        //if((i%2) == 0) \n        zi = zi/2.; // Or: cmul(vec2(.5, 0), zi); // Just a.x*b;\n    \n        \n        fz += zi;\n \n     }\n     \n     \n     // Return the transformed coordinates.\n     return fz;\n\n}\n\n\nvec2 dP;\nvec3 distField(vec2 p){\n\n    // The transformation function itself.\n    p = transf(p);\n    \n    // Coordinat copy.e\n    vec2 op = p;\n    \n    // A bit of animation.\n    //p -= vec2(1, 4)*iTime/8.;\n    //p.y *= op.y<0.? 1. : -1.;\n    \n    vec2 sc = vec2(1, 1)/4.;\n    sc.y *= 6.2831853/6.; // Lining things up.\n    \n    //if(mod(floor(p.y/sc.y), 2.)<.5) p.x += sc.x/2.;\n    //if(mod(floor(p.x/sc.x), 2.)<.5) p.y += sc.y/2.;\n    //if(mod(floor(p.x/sc.x), 2.)<.5) p.y += mod(iTime/2., 6.2831853/6.*1.);\n    \n    //float dir = mod(floor(p.y/sc.y), 2.)<.5? -1. : 1.;\n    //p.x += mod(dir*iTime/4., 1.);\n    \n    // Sliding in opposite directions.\n    float dir = mod(floor(p.x/sc.x), 2.)<.5? -1. : 1.;\n    p.y += mod(dir*iTime/4., 6.2831853/6.*1.);\n\n    // Cell ID and local coordinates.\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    \n    \n    \n    // ip.x += mod(floor(ip.x), 4.);\n  \n    //\n    // Wrap the radial coordinates in sync.\n    ip.y = mod(ip.y, 4.);\n    ip.x = mod(ip.x, 4.);\n    \n    \n    // Render a box.\n    float d = sBoxS(p, sc/2., sc.x*.1);\n    \n    // Rivots.\n    //vec2 q = abs(p) - sc/2.*.6;\n    //d = max(d, -(length(q) - sc.x*.025));\n    //if(mod(ip.x, 2.)<.5) d = max(d, -(length(p) - sc.x*.025));\n    //if(mod(ip.x, 2.)<.5) d = abs(d + sc.x*.22) - sc.x*.22;\n    //d = max(d, -(abs(p.x) - sc.x*.0));\n    \n   \n    // Global coordinate copy, for debugging.\n    dP = p;\n    \n    // Return the distance value and cell ID.\n    return vec3(d, ip);\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n \n \n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc/iResolution.y;\n\n    \n    // Scaling and translation.\n    vec2 p = sc*uv;\n    \n    \n    // The function differential. If you want nice clean lines then \n    // you'll have to differentiate the transformation function and\n    // apply that to the distance field. In this case the angle \n    // remains constant, so you only need to apply it to the distorted\n    // radial component.\n    float px = 1e-2/iResolution.y;\n    vec2 dtX = (transf(uv + vec2(px, 0)) - transf(uv))/px;\n    //vec2 dtY = (transf(uv + vec2(0, px)) - transf(uv))/px;\n    //float dt = (length(dtX) + length(dtY))/2.;\n    float dt = length(dtX);\n    \n    // Faster but leaves artifacts, which is why you need\n    // to do it by hand.\n    //float dt = length(dFdx(transf(uv)))*iResolution.y;\n  \n     \n    // Scene object.\n    vec3 d3 = distField(p);\n  \n    // Distance and ID.\n    float d = d3.x;\n    vec2 id = d3.yz;\n    \n    // Bump mapping samples.\n    //vec3 d3X = distField(p + vec2(px, 0)); \n    vec3 d3Y = distField(p + vec2(0, px));\n    float dB = d3Y.x;\n    \n    vec2 pp = dP;\n    \n    // Random values.\n    float rnd4 = hash21(id + .14);\n    float rnd = hash21(floor(id/vec2(1, 4)) + .23) + rnd4*.2 - .05;\n    \n    // Color. I experimented with a few combinations. I'll tidy it up later.\n    //vec3 sCol = .5 + .45*cos(TAU*rnd4/1. + vec3(0, 1, 2)*1.6);\n    vec3 sCol = .5 + .45*cos(TAU*(id.x + abs(id.y - 2.)/4.)/4. + vec3(0, 1, 2)*1.6);\n    //sCol = vec3(1)*sCol.y;//dot(sCol, vec3(.299, .587, .114));\n   \n    //vec3 sCol = .5 + .45*cos(TAU*rnd/6. + vec3(0, 1, 2)*1.1);\n    //if(hash21(id + .02)<.5) sCol = sCol.zyx;\n    //if(hash21(floor(id/vec2(1, 4)) + .02)<.5) sCol = sCol.zyx;\n    //else sCol = min(sCol*sCol*1.6 + .03, 1.);\n     \n    \n    //if(hash21(floor(id/vec2(1, 4)) + .03)<.5) sCol = vec3(.2)*dot(sCol, vec3(.299, .587, .114));\n    //else sCol = min(sCol*sCol*2. + .03, 1.);\n    \n    \n    // Flat bump mapping.\n    float b = (max(dB, -.025) - max(d, -.025))/px;//.0125\n    //b += (dB - d)/px/8.;\n    b = max(.5 + b, 0.);\n    sCol *= .5 + b;\n    \n      \n    // Rough noise texture to even things out a little.\n    vec3 tx = texture(iChannel0, dP/dt).xyz; tx *= tx;\n    sCol *= tx + .75;\n    \n    // Field lines.\n    //float fL = (abs(fract(d*30. - .5) - .5) - .1)/30.;\n    //sCol *= smoothstep(0., sf, fL)*.9 + .2;\n  \n    \n    d /= dt; // Divide by the derivative, after the bump calculations.\n\n    \n      \n    // Scene color.\n    //pp = abs(pp);\n    vec3 col = vec3(0);//vec3(1, 2, 4)*max(1. - length(mUV)/dt, 0.);\n    \n    // Rendering onto the background.\n    //\n    //col = mix(col, sCol*0., 1. - smoothstep(0., sf, (d + .002))); // Top layer.\n    \n    float thF = sqrt(450./iResolution.y); // Thickness factor.\n    col = mix(col, sCol, 1. - smoothstep(0., sf, d + .005*thF)); // Top layer.\n    \n\n    \n    // Phone screen border.\n/*    \n    //col *= step(abs(uv.y - .5) - .49, 0.);\n    //col *= step(abs(uv.x - .5) - .495, 0.);\n    vec2 scDim = vec2(iResolution.x/iResolution.y, 1);\n    float fr = sBoxS(uv, scDim/2., .05);\n    vec3 svCol = col;\n    col = mix(vec3(0), svCol*1.5, 1. - smoothstep(0., sf*4., fr + .0175));\n    col = mix(col, svCol, 1. - smoothstep(0., sf, fr + .0175 + .0025));\n*/   \n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./32.)*1.05;\n\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n    //f = mod(f + 16384., 16384.); // Annoying GPU hash related hack.\n    uvec2 p = floatBitsToUint(f + 1024.);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\n// IQ's box formula, wich rounding.\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n}\n\n","name":"Common","description":"","type":"common"}]}