{"ver":"0.1","info":{"id":"4lKyzR","date":"1534930349","viewed":163,"name":"Touchy feely textures","username":"rs_creative","description":"Fun with textures and colours","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","colorful","audio","shapes","frequency"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGzn","filepath":"/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","previewfilepath":"/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3","type":"music","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float sphere(vec3 pos, float radius)\n{\n\treturn length(pos) - radius;\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n\nvec3 mapP( vec3 p, float fft, float wave)\n{\n   //iMouse.x = sin(iTime * 0.1);\n    \n    float simMouseX = iMouse.x * 0.002;\n    float simMouseY = iMouse.y * 0.002;\n    \n    simMouseX += sin(fft - 1.8 * 1.8);\n    simMouseY += sin(fft - 0.8 * 0.8);\n    \n    p.xyz += 1.000*sin(  1.0*p.yzx ) * (exponentialOut(fft)) * (fft * 0.1);\n    //p.xyz += 0.500*sin(  4.0*p.yzx )* (wave) * 0.5;\n    p.xyz += 0.250*sin(  8.0*p.yzx )*(simMouseY);\n    p.xyz += (fft * 0.05 * length(p)) *sin( 26.0*p.yzx )*(exponentialOut(iTime * 1.1) * 3.0) * simMouseX;\n    return p;\n}\n\nvec2 rotate(vec2 pos, float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n\n    return mat2(c, s, -s, c) * pos;\n}\n\nfloat map(vec3 pos)\n{\n    \n    float fft  = texture( iChannel2, vec2(pos.x,1.25) ).x;\n    float wave  = texture( iChannel2, vec2(pos.y,0.25) ).x;\n    \n    vec3 sp1 = pos;\n    vec3 sp2 = pos;\n    \n    sp1.xy = rotate(sp1.xy, fft);\n    \n    \n   \tfloat sphere1 =  sphere(mapP(sp1, fft, wave), 1.0);\n    float sphere2 =  sphere(mapP(sp2, fft, wave), 1.2);\n\tfloat d = min(sphere1, sphere2);\n    \n    return d;\n\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 computeNormal(vec3 pos)\n{\n    vec2 eps = vec2(0.01, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - map(pos - eps.xyy),\n        map(pos + eps.yxy) - map(pos - eps.yxy),\n        map(pos + eps.yyx) - map(pos - eps.yyx)\n        ));\n}\n\nvec3 rgb(vec3 color)\n{\n\treturn vec3(color.r / 255., color.g / 255., color.b / 255.);\n}\n\nvec3 albedo() {\n\treturn rgb(vec3(255.,108.,101.));\n}\n\nfloat diffuse(vec3 normal, vec3 lightDir) {\n    return max(dot(normal, lightDir), 0.0);\n}\n\nvec3 envLight(vec3 normal, vec3 dir) {\n\tvec3 eye = -dir;\n\tvec3 r = reflect( eye, normal );\n    float m = 1. * sqrt( pow( r.x, 2. ) + pow( r.y, 2. ) + pow( r.z + 1., 2. ) );\n    vec3 color = texture( iChannel0, r ).rgb;\n\tfloat power = 0.05;\n\tcolor.r     = pow(color.r, power);\n\tcolor       = color.rrr;\n   \t\n    color.r *= 1.8;\n    //color.g *= 1.2;\n    //color.b *= 1.2;\n    \n    return color;\n}\n\n\n\nfloat specular(vec3 normal, vec3 dir) \n{\n    vec3 h = normalize(normal - dir);\n    return pow(max(dot(h, normal), 0.0), 30.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<4; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nfloat calcSoftshadow( in vec3 _lo, in float _k, vec3 lightDir )\n{\n    float _res = 1.0;\n    float _t = 0.0;\n                float _h = 1.0;\n   \n    for( int _i=0; _i<16; _i++ )\n    {\n        _h = map(_lo + lightDir * _t);\n        _res = min( _res, _k *_h / _t );\n                                _t += clamp( _h, 0.01, 1.0 );\n                               \n        if( _h<0.001 ) break;\n    }\n   \n    return clamp(_res,0.0,1.0);\n}\n\nvec3 createColour(vec3 pos, vec3 dir, vec3 normal, vec3 lightDir, float lightDistance)\n{\t\n    float diff = diffuse(normal, lightDir);\n    vec3 alb = albedo();\n    float spec = specular(normal, lightDir);\n    vec3 env = envLight(normal, dir);    \n    float occ = calcOcclusion(pos, normal);   \t\n    float atten = dot(normal, lightDir);\n    \n    vec3 refrRay = normalize(refract(dir, normal, 0.98));\n    vec3 refrPos = pos + refrRay * 0.001;\n    \n    float shadow = calcSoftshadow(pos + normal * 0.1, 8.0, lightDir);\n    \n    vec3 col = (diff + spec + env) / lightDistance * alb;\n    \n    //col *= atten * 0.5 + 0.5;\n    //col *= shadow * 0.5 + 0.5;\n    col *= occ;\n    \n    col += max(spec * shadow * vec3(1.0) * 2.0, 0.0);\n    \n    col *= 0.8 + col * 0.5;\n    \n    return col;    \n}\n\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv = -1.0 + uv * 2.0;  \n    \n    uv.x *= (iResolution.x / iResolution.y);\n\n    vec4 col = vec4(0.0);\n    vec3 ta = vec3(0.0);\n    bool hit = false;\n  \tvec3 pos = vec3(0.0, 0.0, -2.0);   \t\n    mat3 cam = setCamera(pos, ta, 0.0);    \n    vec3 dir = cam * normalize(vec3(uv, 1.0));    \n    vec3 col1 = rgb(vec3(132.,250.,176.));\n    vec3 col2 = rgb(vec3(143.,211.,244.));\n    col = vec4(mix(col1, col2, length(uv * 0.55)), 1.0);\n    \n    vec3 lightDir = normalize(vec3(-1.0, 3.0, 0.0));\n    \t\n    for (int i = 0; i < 128; i++)\n    {\n        float d = map(pos);\n        \n        if (d < pow(0.1, 5.0)) \n        {\n        \thit = true;        \t\n        }\n        \n    \tpos += d * dir;\n    }\n    \n    if (hit == true)\n    {\n    \tfloat lightDistance = sphere(vec3(0.0, -0.8, -0.9), 0.0);\n        vec3 normal = computeNormal(pos);\n        col = vec4(createColour(pos, dir, normal, lightDir, lightDistance), 1.0);\n    }\n    \n   \t  \n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"}]}