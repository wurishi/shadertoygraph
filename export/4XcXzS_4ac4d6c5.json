{"ver":"0.1","info":{"id":"4XcXzS","date":"1719186206","viewed":68,"name":"Torus3D","username":"lucasfturos","description":"Donut/Torus in 3D\nBasic ray tracing and shadow generation","likes":2,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","torus"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    fragColor = texelFetch(iChannel0, ivec2(gl_FragCoord.xy), 0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define EPS 1.0e-6\n\n#define slices 20\n#define stacks 10\n#define innerRadius 0.3\n#define outterRadius 0.5\n\n#define ambientStrength 0.2\n#define diffuseStrength 2.0\n\nvoid rotateVertex(inout vec3 vertex, float angle) {\n    float cosA = cos(angle);\n    float sinA = sin(angle);\n\n    float tmpZ = vertex.z;\n    vertex.z = tmpZ * cosA + vertex.y * sinA;\n    vertex.y = -tmpZ * sinA + vertex.y * cosA;\n\n    float tmpY = vertex.y;\n    vertex.y = tmpY * cosA + vertex.z * sinA * -1.0;\n    vertex.z = tmpY * sinA + vertex.z * cosA;\n\n    float tmpX = vertex.x;\n    vertex.x = cosA * tmpX + sinA * vertex.z;\n    vertex.z = -sinA * tmpX + cosA * vertex.z;\n}\n\nvec3 torusVertex(int i, int j, float angle) {\n    float u = float(i) / float(slices) * PI2;\n    float v = float(j) / float(stacks) * PI2;\n\n    float radiusSum = (outterRadius + innerRadius * cos(v));\n    float x = radiusSum * cos(u);\n    float y = radiusSum * sin(u);\n    float z = innerRadius * sin(v);\n\n    vec3 vertex = vec3(x, y, z);\n    rotateVertex(vertex, angle);\n    return vertex;\n}\n\nvec3 torusNormal(int i, int j, float angle) {\n    float u = float(i) / float(slices) * PI2;\n    float v = float(j) / float(stacks) * PI2;\n\n    float x = cos(v) * cos(u);\n    float y = cos(v) * sin(u);\n    float z = sin(v);\n\n    vec3 normal = vec3(x, y, z);\n    rotateVertex(normal, angle);\n    return normalize(normal);\n}\n\nvec3 rayDirection(float fov, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - (size / 2.0);\n    float z = size.y / tan(radians(fov) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nbool hitTriangle(vec3 rayOrigin, vec3 rayDir, vec3 v0, vec3 v1, vec3 v2,\n                 vec3 n0, vec3 n1, vec3 n2, float tMin, float tMax, out float t,\n                 out vec3 normal, out bool front_face) {\n    vec3 edge1 = v1 - v0;\n    vec3 edge2 = v2 - v0;\n\n    vec3 h = cross(rayDir, edge2);\n    float a = dot(edge1, h);\n    if (abs(a) < EPS) return false;\n\n    float f = 1.0 / a;\n    vec3 s = rayOrigin - v0;\n    float u = f * dot(s, h);\n    if (u < 0.0 || u > 1.0) return false;\n\n    vec3 q = cross(s, edge1);\n    float v = f * dot(rayDir, q);\n    if (v < 0.0 || u + v > 1.0) return false;\n\n    t = f * dot(edge2, q);\n\n    if (t < tMin || t > tMax) return false;\n\n    normal = normalize(n0 * (1.0 - u - v) + n1 * u + n2 * v);\n    front_face = dot(rayDir, normal) < 0.0;\n    if (!front_face) normal = -normal;\n\n    return true;\n}\n\nvec3 calculateLighting(vec3 normal, vec3 lightDir, bool inShadow) {\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    return vec3(0.7) * (ambientStrength + diffuseStrength * diffuse) *\n           (inShadow ? ambientStrength : 1.0);\n}\n\nvoid updateColorHit(vec3 rayOrigin, vec3 rayDir, vec3 v0, vec3 v1, vec3 v2,\n                    vec3 n0, vec3 n1, vec3 n2, float tMin, inout float minDist,\n                    inout vec3 color, vec3 colorTorus, vec3 lightDir,\n                    bool inShadow) {\n    vec3 normal;\n    bool front_face;\n    float t;\n\n    if (hitTriangle(rayOrigin, rayDir, v0, v1, v2, n0, n1, n2, tMin, minDist, t,\n                    normal, front_face) &&\n        t < minDist) {\n        minDist = t;\n        vec3 finalColor = colorTorus;\n        finalColor *= calculateLighting(normal, lightDir, inShadow);\n        color = finalColor;\n    }\n}\n\nvec3 getTorusColor(vec3 rayOrigin, vec3 rayDir, vec3 lightDir, bool inShadow,\n                   float angle, out float minDist) {\n    vec3 colorTorus = vec3(0.2, 0.3, 0.8);\n    vec3 color = vec3(0.0);\n\n    minDist = 6.0;\n    float tMin = 0.001;\n\n    for (int i = 0; i < slices; ++i) {\n        for (int j = 0; j < stacks; ++j) {\n            vec3 v0 = torusVertex(i, j, angle);\n            vec3 v1 = torusVertex(i + 1, j, angle);\n            vec3 v2 = torusVertex(i, j + 1, angle);\n            vec3 v3 = torusVertex(i + 1, j + 1, angle);\n\n            vec3 n0 = torusNormal(i, j, angle);\n            vec3 n1 = torusNormal(i + 1, j, angle);\n            vec3 n2 = torusNormal(i, j + 1, angle);\n            vec3 n3 = torusNormal(i + 1, j + 1, angle);\n\n            updateColorHit(rayOrigin, rayDir, v0, v1, v2, n0, n1, n2, tMin,\n                           minDist, color, colorTorus, lightDir, inShadow);\n            updateColorHit(rayOrigin, rayDir, v2, v1, v3, n2, n1, n3, tMin,\n                           minDist, color, colorTorus, lightDir, inShadow);\n        }\n    }\n\n    return color;\n}\n","name":"Common","description":"","type":"common"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 cameraPos = vec3(0.0, 0.0, 4.2);\n    vec3 rayOrigin = cameraPos;\n    vec3 rayDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    vec3 lightPos = vec3(-10.0, -10.0, 10.0);\n    vec3 lightDir = normalize(lightPos - cameraPos);\n\n    bool inShadow = false;\n\n    float angle = iTime;\n    vec2 mousePos = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    angle += mousePos.x * 0.5;\n    angle += mousePos.y * 0.5;\n\n    float minDist;\n    vec3 color =\n        getTorusColor(rayOrigin, rayDir, lightDir, inShadow, angle, minDist);\n\n    float gamma = 1.2;\n    color = pow(color, vec3(1.0 / gamma));\n\n    fragColor.rgb = color;\n}\n","name":"Buffer A","description":"","type":"buffer"}]}