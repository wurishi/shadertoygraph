{"ver":"0.1","info":{"id":"MXsfzX","date":"1728730931","viewed":62,"name":"fractalic N","username":"nayk","description":"originals  fractal 99 by gaz and fractal from glslsandbox","likes":1,"published":3,"flags":0,"usePreview":0,"tags":["fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n\nprecision mediump float;\n\n\n\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\n\n\n\nconst int N = 10;\nconst float S = 2.8;\nconst float R = 0.5;\nconst float F = 1.0;\nconst float R2 = R * R;\nconst float F2 = F * F;\n#define r2(a)  mat2(cos(a), sin(a), -sin(a), cos(a))\n#define time iTime\n#define resolution iResolution.xy\n\n#define n1Q(p) p *= 2.*ri(round(atan(p.x, p.y) * 4.) / 4.)\n#define ri(a) mat2(cos(a + asin(vec4(0,1,-1,0))))\nfloat mandelbox(vec3 c)\n{\n\tvec3 v = c;\n\nc.xy*=r2(iTime);\n            c.xz*=r2(iTime);\n            \tc.zy*=r2(iTime);\n\tfloat r = 1.0;\n\t\n\tfor (int n = 0; n < N; ++n)\n\t{\n\t\tv = 2.0 * clamp(v, -1.0, 1.0) - v;\nc.xy*=r2(iTime);\n            c.xz*=r2(iTime);\n            \tc.zy*=r2(iTime);\n\t\tfloat r2 = dot(v, v);\n\t\t\tc.xy*=r2(iTime);\n            c.xz*=r2(iTime);\n            \tc.zy*=r2(iTime);\n\t\tif (r2 < R2)\n\t\t{\n\n\t\t\tv /= R2;\n\t\t\tr /= R2;\n\t\t}\n\t\telse if (r2 < 1.0)\n\t\t{\n\t\t\tv /= r2;\n\t\t\tr /= r2;\n\t\t}\n        \n\t\n\t\tv = v * S + c;\n\t\tr = r * abs(S) + 1.0;\n\t}\n\t\n\treturn length(v) / abs(r);\n}\n\n\n\nconst float PI = 3.141592653589;\n\nconst int MAX_STEPS = 100;\nconst float MAX_DISTANCE = 100.0;\nconst float MIN_DISTANCE = 0.01;\nconst float NORMAL_EPSILON = 0.0001;\nconst float SHADOW_FACTOR = 0.5;\n\n\n\nfloat getDistance(vec3 position)\n{\n\treturn mandelbox(position);\n}\n\nvec3 getNormal(vec3 position)\n{\n\n\tvec3 near = vec3(getDistance(position - vec3(NORMAL_EPSILON, 0.0, 0.0)),\n\t                 getDistance(position - vec3(0.0, NORMAL_EPSILON, 0.0)),\n\t                 getDistance(position - vec3(0.0, 0.0, NORMAL_EPSILON)));\n\t\n\tvec3 direction = getDistance(position) - near;\n\n\treturn normalize(direction);\n}\n\nfloat getRaymarch(vec3 point, vec3 direction)\n{\n\tfloat result = 0.0;\n\t\n\tfor (int i = 0; i < MAX_STEPS; ++i)\n\t{\n\t\tfloat distance = getDistance(point);\n\t\t\n\t\tresult += distance;\n\t\tpoint += distance * direction;\n\t\t\n\t\tif (distance < MIN_DISTANCE ||\n\t\t    result > MAX_DISTANCE) break;\n\t}\n\t\n\treturn result;\n}\n\nfloat getLight(vec3 position, vec3 absoluteLightPosition)\n{\n\tvec3 normal = getNormal(position);\n\tvec3 lightPosition = absoluteLightPosition - position;\n\tvec3 lightDiretion = normalize(lightPosition);\n\tfloat lightDistance = length(lightPosition);\n\n\tfloat result = clamp(dot(normal, lightDiretion), 0.0, 1.0);\n\n\t//float lightRaymarch = getRaymarch(position + normal * MIN_DISTANCE * 2.0, lightDiretion);\n\t//if (lightRaymarch < lightDistance) result *= SHADOW_FACTOR;\n\n\treturn result;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pixel = 2.0 * gl_FragCoord.xy / resolution.xy - 1.0;\n\tpixel.y *= resolution.y / resolution.x;\n\tpixel.xy*=r2(iTime);\n                  \n\tvec2 angle = PI * (mouse - 0.5);\nn1Q(angle.xy); \n\tvec3 lightPosition = vec3(0.0, 0.0, -10.0);\n\tvec3 cameraPosition = vec3(0.0, 0.0, -10.0);\n\tvec3 cameraDirection = normalize(vec3(pixel, 1.0));\n\n\tfloat cosAngleX = cos(angle.x);\n\tfloat cosAngleY = cos(angle.y);\n\tfloat sinAngleX = sin(angle.x);\n\tfloat sinAngleY = sin(angle.y);\n\n\tmat2 rotationY = mat2(cosAngleX, sinAngleX,\n\t                     -sinAngleX, cosAngleX);\n\tmat2 rotationX = mat2(cosAngleY, sinAngleY,\n\t                     -sinAngleY, cosAngleY);\n\n\tlightPosition.yz *= rotationX;\n\tlightPosition.xz *= rotationY;\n\n\tcameraPosition.yz *= rotationX;\n\tcameraPosition.xz *= rotationY;\n\n\tcameraDirection.yz *= rotationX;\n\tcameraDirection.xz *= rotationY;\n\t\n\tfloat pointDistance = getRaymarch(cameraPosition, cameraDirection);\n\t\n\tvec3 point = cameraPosition + cameraDirection * pointDistance;\n\n\tvec3 color = vec3(1.0) * 20.0 * getLight(point, lightPosition) / max(1.0, pointDistance * pointDistance);\n\n\tfragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}