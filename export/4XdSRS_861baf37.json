{"ver":"0.1","info":{"id":"4XdSRS","date":"1719222911","viewed":46,"name":"sdf rigidbody physics","username":"0x177","description":"UPDATE: spalmer suggested orthonormalizing new_r has fixed the distortion.\n\nthis becomes very distorted after a bit for some reason (multiply RB_L in line 38 by 100 to see it quickly)","likes":1,"published":1,"flags":32,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"l3XGRl","parentname":"raymarching startingpoint"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 250.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\nconst float globalAmbient = 0.4; // how strong is the ambient lightning\nconst float globalDiffuse = 0.8; // how strong is the diffuse lightning\nconst float globalSpecular = 1.0; // how strong is the specular lightning\nconst float globalSpecularExponent = 32.0; // how focused is the shiny spot\nconst vec3 lightPos = vec3(0.0, 1.0, -0.5); // position of the light source\nconst vec3 lightColor = vec3(0.9, 0.9, 0.68); // color of the light source\nconst vec3 ambientColor = vec3(1.0, 1.0, 1.0); // ambient color\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat box(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 GetDist(vec3 p) {    \n    float d = 99.0;\n    float mat = 0.0;\n    \n    vec3 rb_rmx = texelFetch(iChannel0,RB_RMX,0).xyz;\n    vec3 rb_rmy = texelFetch(iChannel0,RB_RMY,0).xyz;\n    vec3 rb_rmz = texelFetch(iChannel0,RB_RMZ,0).xyz;\n    \n    mat3x3 rb_rm = mat3x3(rb_rmx,rb_rmy,rb_rmz);\n    \n    p = rb_rm * p;\n    \n    vec3 rb_pos = texelFetch(iChannel0,RB_POS,0).xyz;\n    vec3 rb_sdl = texelFetch(iChannel0,RB_SDL,0).xyz;\n    \n    d = box(p-rb_pos,rb_sdl);\n    \n    return vec2(d,mat);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float mat;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 dS = GetDist(p);\n        dO += dS.x;\n        mat = dS.y;\n        \n        if(dO>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,mat);\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nfloat ambientOcclusion(vec3 p, vec3 n){\n    const int steps = 1;\n    const float delta = 0.5;\n\n    float a = 0.0;\n    float weight = 0.75;\n    float m;\n    for(int i=1; i<=steps; i++) {\n        float d = (float(i) / float(steps)) * delta;\n        a += weight*(d - GetDist(p + n*d).x);\n        weight *= 0.5;\n    }\n    return clamp(1.0 - a, 0.0, 1.0);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<100; i++ )\n    {\n\t\tfloat h = GetDist( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.1, 1. );\n}\n\n\nvec3 shade(  vec3 position,\n                           vec3 lightPosition,\n                           vec3 ambientCol,\n                           vec3 lightCol,\n                           float ambientCoeff,\n                           float diffuseCoeff,\n                           float specularCoeff,\n                           float specularExponent,\n                           vec3 camera_pos,\n                           vec3 ray_direction\n)\n{\n      vec3 normal = GetNormal(position);\n      vec3 toEye = normalize(camera_pos - position);\n      vec3 toLight = normalize(lightPosition - position);\n      vec3 reflection = reflect(-toLight, normal);\n\n      vec3 ambientFactor = ambientCol * ambientCoeff;\n      vec3 diffuseFactor = diffuseCoeff * lightCol * max(0.0, dot(normal, toLight));\n      vec3 specularFactor = lightCol * pow(max(0.0, dot(toEye, reflection)), specularExponent)\n                     * specularCoeff;\n                     \n      float bac = clamp( dot( normal, normalize(vec3(-lightPosition.x,0.0,-lightPosition.z))), 0.0, 1.0 )*clamp( 1.0-position.y,0.0,1.0);\n      float fre = pow( clamp(1.0+dot(normal,ray_direction),0.0,1.0), 2.0 );\n\n      float ao = ambientOcclusion(position+normal*0.1,normal);\n      float ss= softshadow(position,lightPos,0.1,10.0);\n       \n    diffuseFactor *= ss;\n    diffuseFactor *= ao;\n    return ambientFactor + diffuseFactor + specularFactor + 0.30 * bac + 0.20 * fre;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 0.5);\n    vec3 bg = mix(vec3(1.,0.557,0.561),vec3(1.,0.992,0.796),rd.y);\n    vec3 col = bg;\n   \n    vec2 rm = RayMarch(ro, rd);\n    float d = rm.x;\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        if (rm.y == 0.0) {\n            col = vec3(0.882,0.471,0.773);\n        } else {\n            col = vec3(1.,0.557,0.561);\n        }\n        col *= shade(p,lightPos,ambientColor,lightColor,globalAmbient,globalDiffuse,globalSpecular,globalSpecularExponent,ro,rd);\n        col = mix(col,bg,1.0 - exp(-0.0004*d*d));\n    }\n    \n    float c = 1.1;\n    float b = 0.0;\n    col = c * (col-0.5) + 0.5 + b;\n    vec3 greyscale = vec3(dot(col,vec3(0.299,0.587,0.114)));\n    col = mix(greyscale,col,1.3);\n    col = clamp(col,vec3(0.0),vec3(1.0));\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat3x3 cnew_r() {\n            vec3 rb_rmx = texelFetch(iChannel0,RB_RMX,0).xyz;\n            vec3 rb_rmy = texelFetch(iChannel0,RB_RMY,0).xyz;\n            vec3 rb_rmz = texelFetch(iChannel0,RB_RMZ,0).xyz;\n            vec3 rb_iiz = texelFetch(iChannel0,RB_IIZ,0).xyz;\n    \n            mat3x3 rb_rm = mat3x3(rb_rmx,rb_rmy,rb_rmz);\n            mat3x3 inv_i_0 = mat3x3(rb_iiz.x,0.0,0.0,\n                                  0.0,rb_iiz.y,0.0,\n                                  0.0,0.0,rb_iiz.z\n            );\n            \n            vec3 rb_L = texelFetch(iChannel0,RB_L,0).xyz;\n            \n            vec3 omega = rb_rm*inv_i_0*transpose(rb_rm)*rb_L;\n            mat3x3 new_r = iTimeDelta * cross_matrix(omega) * rb_rm;\n            \n            return new_r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0) {\n        fragColor = vec4(0.0);\n        if (ivec2(fragCoord) == RB_POS) {\n            fragColor = vec4(0.0);\n        } else if (ivec2(fragCoord) == RB_VEL) {\n            fragColor = vec4(0.0);\n        } else if (ivec2(fragCoord) == RB_SDL) {\n            fragColor = vec4(RB_SDL3,0.0);\n        } else if (ivec2(fragCoord) == RB_RMX) {\n            fragColor = vec4(1.0,0.0,0.0,0.0);\n        } else if (ivec2(fragCoord) == RB_RMY) {\n            fragColor = vec4(0.0,1.0,0.0,0.0);\n        } else if (ivec2(fragCoord) == RB_RMZ) {\n            fragColor = vec4(0.0,0.0,1.0,0.0);\n        } else if (ivec2(fragCoord) == RB_L) {\n            fragColor = vec4(1.0,1.0,0.0,0.0)*100.0;\n        } else if (ivec2(fragCoord) == RB_IIZ) {\n            fragColor = vec4(1.0/inertia_density_rectprism(RB_SDL3),0.0);\n        }\n        \n    } else {\n        ivec2 iuv = ivec2(fragCoord);\n        fragColor = texelFetch(iChannel0,iuv,0);\n        if (iuv == RB_POS) {\n            vec3 v = texelFetch(iChannel0,RB_VEL,0).xyz;\n            fragColor.xyz = fragColor.xyz + v * iTimeDelta;\n        } else if (iuv == RB_RMX) {\n            vec3 rb_rmx = texelFetch(iChannel0,RB_RMX,0).xyz;\n            vec3 rb_rmy = texelFetch(iChannel0,RB_RMY,0).xyz;\n            vec3 rb_rmz = texelFetch(iChannel0,RB_RMZ,0).xyz;\n            vec3 rb_iiz = texelFetch(iChannel0,RB_IIZ,0).xyz;\n    \n            mat3x3 rb_rm = mat3x3(rb_rmx,rb_rmy,rb_rmz);\n            mat3x3 new_r = rb_rm+cnew_r()*iTimeDelta;\n            new_r = orthonormalize(new_r);\n            \n            fragColor = vec4(new_r[0],0.0);\n        } else if (iuv == RB_RMY) {\n            vec3 rb_rmx = texelFetch(iChannel0,RB_RMX,0).xyz;\n            vec3 rb_rmy = texelFetch(iChannel0,RB_RMY,0).xyz;\n            vec3 rb_rmz = texelFetch(iChannel0,RB_RMZ,0).xyz;\n            vec3 rb_iiz = texelFetch(iChannel0,RB_IIZ,0).xyz;\n    \n            mat3x3 rb_rm = mat3x3(rb_rmx,rb_rmy,rb_rmz);\n            mat3x3 new_r = rb_rm+cnew_r()*iTimeDelta;\n            new_r = orthonormalize(new_r);\n            \n            fragColor = vec4(new_r[1],0.0);\n        } else if (iuv == RB_RMZ) {\n            vec3 rb_rmx = texelFetch(iChannel0,RB_RMX,0).xyz;\n            vec3 rb_rmy = texelFetch(iChannel0,RB_RMY,0).xyz;\n            vec3 rb_rmz = texelFetch(iChannel0,RB_RMZ,0).xyz;\n            vec3 rb_iiz = texelFetch(iChannel0,RB_IIZ,0).xyz;\n    \n            mat3x3 rb_rm = mat3x3(rb_rmx,rb_rmy,rb_rmz);\n            mat3x3 new_r = rb_rm+cnew_r()*iTimeDelta;\n            new_r = orthonormalize(new_r);\n            \n            fragColor = vec4(new_r[2],0.0);\n        }\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"const ivec2 RB_POS = ivec2(0,0);\nconst ivec2 RB_VEL = ivec2(1,0);\nconst ivec2 RB_SDL = ivec2(2,0);\nconst vec3 RB_SDL3 = vec3(1.0,1.5,1.0);\n\n// https://en.wikipedia.org/wiki/Center_of_mass\n// R = 1/M ∫∫∫q p(r)rdv\n// this rectangular prism has a constant mass of 2 and a constant density of 1,\n// so the center of mass is vec3(0.0,0.0,0.0) \n\nconst float RB_MASS = 2.0;\nconst float RB_DENSITY = 1.0;\n\n//rotation matrix\n\nconst ivec2 RB_RMX = ivec2(3,0);\nconst ivec2 RB_RMY = ivec2(4,0);\nconst ivec2 RB_RMZ = ivec2(5,0);\n\n// ω = RI0^-1R^TL \n// basically this is the direction the rigidbody wants to roatate around\nconst ivec2 RB_L = ivec2(6,0);\n\n// iverse of the initial inertia tensor\nconst ivec2 RB_IIZ = ivec2(7,0);\n\nvec3 inertia_density_rectprism(vec3 sdl) {\n    float v = sdl.x*sdl.y*sdl.z;\n    return v*vec3(sdl.y*sdl.y + sdl.z*sdl.z,sdl.x*sdl.x + sdl.z*sdl.z,sdl.x*sdl.x + sdl.y*sdl.y)/12.0;\n}\n\nmat3 cross_matrix(vec3 x) {\n    return mat3(\n        0.0,-x.z,x.y,\n        x.z,0.0,-x.x,\n        -x.y,x.x,0.0\n    );\n}\n\n// https://www.shadertoy.com/view/wtByD3\nvec3 project(vec3 a, vec3 b){\n\treturn dot(a,b)/dot(b,b)*(b);\n}\n\n// https://www.shadertoy.com/view/wtByD3\nmat3x3 orthonormalize(mat3x3 m) {\n    vec3 A = m[0];\n    vec3 B = m[1];\n    vec3 C = m[2];\n    \n    vec3 Ao;\n    vec3 Bo;\n    vec3 Co;\n    \n    Ao = A;\n    \n    Bo = B - project(B,A);\n    \n    Co = C - project(C,Bo) - project(C,Ao);\n    \n    Ao = normalize(Ao);\n    Bo = normalize(Bo);\n    Co = normalize(Co);\n    \n    return mat3(Ao,Bo,Co);\n}\n\n\n\n\n\n\n","name":"Common","description":"","type":"common"}]}