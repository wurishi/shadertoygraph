{"ver":"0.1","info":{"id":"XfdcRM","date":"1730401622","viewed":115,"name":"stars way","username":"nayk","description":"source https://www.shadertoy.com/view/MXfcDS https://www.shadertoy.com/view/mttXRM https://www.shadertoy.com/view/lc3cRN","likes":2,"published":3,"flags":0,"usePreview":0,"tags":["galaxy","stars","universe"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float palette( in float a, in float b, in float c, in float d, in float x ) {\n    return a + b * cos(6.28318 * (c * x + d));\n}\n\nfloat Star(vec2 uv) {\n    float distaceToCenter = length(uv);\n    float circle = 0.065 / distaceToCenter; // control the star size, e.g. 0.002\n    circle = clamp(circle, 0.03, 5.0); // avoid flickering in tiny stars\n    circle *= smoothstep(1.0, 0.2, distaceToCenter); // cut off the glow\n    return circle;\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p * vec2(sin(3.44) * 0.132, 6.91201 * cos(1.305)));\n    p += dot(p, p + 5.32);\n    return fract(p.x * p.y);\n}\n#define rotation(angle) mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n\nfloat TAU = 2.*3.14159;\n\n// Thanks IQ\nfloat eqTri( in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n#define NUM_LAYERS 6.\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n\n}\n\nfloat Star(vec2 uv, float flare) {\n    float d = length(uv);\n    \n    float m = 0.06/d; // the middle cirle of the star\n    \n    float rays = max(0.,1.-abs(uv.x * uv.y*888.));\n    m += rays * flare;\n    uv *= Rot(3.1415/4.);\n    rays = max(0.,1.-abs(uv.x * uv.y*888.));\n    m += rays * .3 * flare;\n    \n    m *= smoothstep(.8, .1, d);\n    return m;\n}\n\nfloat Hash212(vec2 p) {\n    p = fract(p*vec2(123.34, 456.21));\n    p += dot(p, p+45.32);\n    return fract(p.x * p.y);\n}\n\nvec3 StarLayer2(vec2 uv) {\n    vec3 col = vec3(0);\n    \n    vec2 gv = fract(uv)-0.5; // fractional component\n    vec2 id = floor(uv); // integer component\n    \n    for(int y=-1; y<=1; y++) {\n        for(int x=-1; x<=1; x++) {\n            vec2 offs = vec2(x,y); //add contribution of all negighboring stars\n            \n            float n = Hash21(id+offs); //random btw 0 and 1 for each grid \n            float size = fract(n*456.78)*1.2;\n            float flare = smoothstep(.3, .9, size);//for ray only\n            flare *= abs(sin(iTime*2.)); \n            float star = Star(gv-offs-vec2(n,fract(n*68.))+.5, flare);\n            vec3 tint1 = vec3(0.6+size*0.35,.9,.9);\n            vec3 tint2 = vec3(0.7+size*0.25,.75,.75);\n            vec3 color = mix(tint1, tint2,abs(cos(iTime))+n);\n            color *= fract(n*1234.5);\n            \n            star *= sin(iTime*3.+n*6.2821)*.5+.5;\n            col += star*size*color;\n        }\n    }\n    return col;\n}\n\nvec3 StarLayer(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    vec2 gv = fract(uv.xy); // grid uv\n    \n    // a value to identify each box\n    vec2 id = floor(uv.xy) - 0.5;\n    \n    vec3 pal; // change the blue star color; achieved my color of choice randomly\n    pal.r = palette(1.5, -1.081592653589793, 0.798407346410207, 0.0, 1.0);\n    pal.g = palette(0.6, 0.658407346410207, 0.908407346410207, 0.268407346410207, 1.0); // prev - 0.5\n    pal.b = palette(0.3, -0.201592653589793, 0.318407346410207, -0.001592653589793, 1.0); // prev - 0.25\n    \n    float brightness = 3.6; // apparently, lower gives more monochrome (pale) color; reference value is 3.7\n\n    // yellowish stars\n     pal.r = palette(1.3, -1.081592653589793, 0.798407346410207, 0.0, 1.0);\n     pal.g = palette(0.5, 0.658407346410207, 0.908407346410207, 0.268407346410207, 1.0);\n     pal.b = palette(0.25, -0.201592653589793, 0.318407346410207, -0.001592653589793, 1.0);\n\n    // float brightness = 3.7;\n\n     // uv.x -= 0.2 * iTime;\n \n    // Iterate through the 3x3 neighborhood of each box\n    for (int y = -1; y <= 1; y++) {\n      for (int x = -1; x <= 1; x++) {\n        vec2 contribution = vec2(x, y);\n      \n        float num = Hash21(id + contribution); // random between 0 and 1\n        vec2 offset = vec2(num, fract(num * 34.610961)); // offset on x and y; middle is the origin\n    \n        float star = Star(gv - contribution - offset);\n        float size = fract(num * 345.32 * 0.111345);\n\n        vec3 starColor = sin(pal * fract(num * 2.2) * brightness) * 2.5 + 0.5;\n        \n        starColor = starColor * vec3(0.8, 0.8, 1.0);\n        star *= sin(iTime * 1.2 + num  * 6.2831) * 0.5 + 1.0;\n\n        color += star * size * starColor;\n      }\n    }\n    \n    return color;\n}\n// Function to generate pseudorandom noise\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n// Noise function for creating scattered particle effect\nfloat noise(vec2 p){\n    vec2 ip = floor(p);\n    vec2 u = fract(p);\n    u = u*u*(3.0-2.0*u);\n\n    float res = mix(\n        mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n        mix(rand(ip+vec2(5.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n    return res*res;\n}\nfloat happy_star(vec2 uv, float anim)\n{\n    uv = abs(uv);\n    vec2 pos = min(uv.xy/uv.yx, anim);\n    float p = (2.0 - pos.x - pos.y);\n    return (2.0+p*(p*p-1.5)) / (uv.x+uv.y);      \n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n   vec2 uv = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n      vec2 uv3 = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n   uv3*=fract(iTime);\n    vec2 uv2 = ( fragCoord - .5 * iResolution.xy ) / iResolution.y;\n    uv2*=50.;\n       float t3 = -iTime*.05;\n       uv2 *= rotation(3. * TAU * (.3 - clamp(length(uv),0.,.3)));\n\n    vec3 col3 = vec3(0);\n    \n    for(float i=0.; i<1.; i+=1./NUM_LAYERS) {\n        float depth = fract(i+t3);\n        float scale = mix(10.,.5,depth);\n        float fade = depth*smoothstep(1.,.9,depth);\n        col3 += StarLayer(uv*scale+i*45.45)*fade;\n        \n    }\n      vec2 n = noise(uv * iResolution.x) * vec2(3.14, 0.0);\n      uv2+=n;\n   vec3 col = vec3(0.);\n  float t = fract(.1 * iTime);\n   uv3 *= rotation(3. * TAU * (.3 - clamp(length(uv+n),0.,.3)));\n   float s = -1.;\n   for(float i = 0.; i < 3.; i++){\n     float rad = .4 / pow(2.,i) * (.9 - .2 * i);\n     uv3 *= rotation(-2. * s * (i + 1.) * TAU * t);\n     float tri = eqTri(uv3, rad);\n     s *= -1.;\n     col += .004 / abs(tri);\n   }\n        \n   vec3 color = vec3(0);\n   \n    color += StarLayer(uv2+col.xy);\n\n    // Output to screen\n    fragColor = vec4(color*mod(fragCoord.y,3.)*mod(fragCoord.x,3.)+col3.xyz, 1.0);\n    uv *= 2.0 * ( cos(iTime * 2.0) -2.5); // scale\n    float anim = sin(iTime * 12.0) * 0.1 + 1.0;  // anim between 0.9 - 1.1 \n    fragColor*= vec4(happy_star(uv, anim) * vec3(0.5,0.5,0.5)*1., 1.0);\n}","name":"Image","description":"","type":"image"}]}