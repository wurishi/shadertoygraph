{"ver":"0.1","info":{"id":"ssG3Wy","date":"1634582234","viewed":33,"name":"Bonk Bonk","username":"kp1197","description":"Can you hear this shader?","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["perlin"],"hasliked":0,"parentid":"7syGR3","parentname":"tree plane"},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float pi = 3.14159;\n\nconst mat3 noise_3d_rotator = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\n                    \nmat2 noise2d_rotator = mat2(-0.8, 0.6, 0.6, 0.8);\n\nvec2 random2f( vec2 p ) {\n    return fract(\n        sin(\n            vec2(\n                dot(p,vec2(127.1,311.7)),\n                dot(p,vec2(269.5,183.3)))\n        )*(43758.5453)\n    );\n}\n\nstruct Char {\n    vec2 char;\n    vec2 pos;\n    vec2 dims;\n};\n\nconst float eps = 1e-6;\nconst float CHAR_WIDTH = 1./5.;\nconst vec2 TEXT_DIMS   = vec2(0.19);\n\nconst Char b = Char(vec2(2,9)  / 16.,   vec2(1. * CHAR_WIDTH, 0.45), TEXT_DIMS);\nconst Char o = Char(vec2(15,9) / 16.,   vec2(2. * CHAR_WIDTH, 0.45), TEXT_DIMS);\nconst Char n = Char(vec2(14,9)  / 16.,   vec2(3. * CHAR_WIDTH, 0.45), TEXT_DIMS);\nconst Char k = Char(vec2(11,9)  / 16.,   vec2(4. * CHAR_WIDTH, 0.45), TEXT_DIMS);\n\n\n\n\nvec3 hash3( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn (-1.0 + 2.0*fract(sin(p)*43758.5453123));\n}\n\nfloat noise3_octave( in vec3 p, float intensity )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( intensity*hash3( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( intensity*hash3( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( intensity*hash3( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( intensity*hash3( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( intensity*hash3( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( intensity*hash3( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( intensity*hash3( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( intensity*hash3( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\n\n\n\nfloat noise3(in vec3 p, int octaves, float intensity)\n{\n    float f = 0.;\n    for (int i = 0; i < octaves; i++) {\n        float coef = pow(2., -float(i + 1));\n        f += coef*noise3_octave(p,intensity); \n        p = p*noise_3d_rotator*2.01;\n    }\n    return f;\n}\n\n\n// from IQ @ https://www.shadertoy.com/view/XdXGW8\nvec2 grad2( ivec2 z )  // replace this anything that returns a random vector\n{\n    // 2D to 1D  (feel free to replace by some other)\n    int n = z.x+z.y*11111;\n\n    // Hugo Elias hash (feel free to replace by another one)\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n\n    // Perlin style vectors\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;                             \n}\n\nfloat noise2_octave(in vec2 p, float intensity) \n{\n     ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( mix( dot( intensity*grad2( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( intensity*grad2( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( intensity*grad2( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( intensity*grad2( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\n\n\n// from IQ @ https://www.shadertoy.com/view/XdXGW8\nfloat noise2( in vec2 p, int octaves, float intensity )\n{\n    float f = 0.;\n    for (int i = 0; i < octaves; i++) {\n        float coef = pow(2., -float(i + 1));\n        f += coef*noise2_octave(p,intensity); \n        p = p*noise2d_rotator*2.01;\n    }\n    //f = 0.5 + 0.5*f;\n    return f;\n}\n\nfloat grad1(float z) {\n    // a never-repeating function inspired by user9144436 at https://stackoverflow.com/questions/8798771/perlin-noise-for-1d\n    // ^--- inspiration\n    z = 100.*z;\n    return fract(sin (2. * z) + sin(pi * z));\n}\n\nfloat noise1_octave(in float p, float intensity)\n{\n    float i = float(floor( p ));\n    float f =       fract( p );\n\t\n\tfloat u = f*f*(3.0-2.0*f); // feel free to replace by a quintic smoothstep instead\n\n    return mix( ( intensity*grad1( i+0. )*(f-0.) ), \n                ( intensity*grad1( i+1. )*(f-1.) ), u);\n}\n\nfloat noise1(in float p, int octaves, float intensity) \n{\n    float f = 0.;\n    for (int i = 0; i < octaves; i++) {\n        float coef = pow(2., -float(i + 1));\n        f += coef*noise1_octave(p,intensity); \n        p = p*2.01;\n    }\n    //f = 0.5 + 0.5*f;\n    return f;\n}\n\nfloat fbm1( in float x, int octaves, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise1(f*x, 1, 1.);\n        f *= 2.01;\n        a *= G;\n    }\n    return t;\n}\n\nfloat fbm2( in vec2 x, int octaves, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise2(f*x, 1, 1.);\n        f *= 2.01;\n        a *= G;\n    }\n    return t;\n}\n\nfloat fbm3( in vec3 x, int octaves, in float H )\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<octaves; i++ )\n    {\n        t += a*noise3(f*x, 3, 1.);\n        f *= 2.01;\n        a *= G;\n    }\n    return t;\n}\n\nfloat cart1_to_polar1(in float x)\n{\n    return x;\n}\n\nvec2 cart2_to_polar2(in vec2 x)\n{\n    vec2 normed = normalize(x);\n    return vec2(length(x), atan(normed.x, normed.y));   \n}\n\nvec2 scaled_cart2_to_polar2(in vec2 x)\n{\n    return (vec2(0.,pi) + cart2_to_polar2(x))/vec2(1.,2.*pi);\n}\n\nvec3 cart3_to_polar3(in vec3 u)\n{\n    // todo: is this correct\n    float r = length(u);\n    \n    float theta = atan(length(u.xy), r);\n    float phi = atan(u.x, u.y);\n    return vec3(length(u), theta, phi);\n}\n\nvec3 scaled_cart3_to_polar3(in vec3 u)\n{\n    return (vec3(0.,pi, pi) + cart3_to_polar3(u))/vec3(1.,2.*pi,2.*pi);\n}\n\nfloat center1(in float x)\n{\n    return x - 0.5;\n}\n\nvec2 center2(in vec2 u)\n{\n    return u - vec2(0.5);\n}\n\nvec3 center3(in vec3 u)\n{\n    return u - vec3(0.5);\n}\n\nfloat center1_scale(in float x, in float scale)\n{\n    return (scale*(x - 0.5)) + 0.5;\n}\n\nvec2 center2_scale(in vec2 x, in vec2 scale)\n{\n    return (scale*(x-0.5))+0.5;\n}\n\nvec3 center3_scale(in vec3 x, in vec3 scale)\n{\n    return (scale*(x-0.5))+0.5;\n}\n\nfloat bands1(in float u, in float bands)\n{\n    return floor(mod(u,1.) * bands) / bands;\n}\n\nvec2 bands2(in vec2 u, in vec2 bands)\n{\n    return floor(mod(u,1.) * bands) / bands;\n}\n\nvec3 bands3(in vec3 u, in vec3 bands)\n{\n    return floor(mod(u,1.) / bands) / bands;\n}\n\nfloat random_bands1(in float u, in float bands)\n{\n    float b = bands1(u, bands);\n    return grad1(b);\n}\n\nvec2 random_bands2(in vec2 u, in vec2 bands)\n{\n    vec2 b = bands2(u, bands);\n    return random2f(b);\n}\n\nvec3 random_bands3(in vec3 u, in vec3 bands)\n{\n    vec3 b = bands3(u, bands);\n    return hash3(b);\n}\n\n\n\nfloat veronoi_metric( in vec2 r, float exponent, float angle ) {\n    // manhattan\n    //return dot(abs(r), vec2(1.));\n    // euclidean\n    //return dot(r,r);\n    return dot(pow(abs(r),vec2(exponent)), vec2(1.));\n}\n\n/*\notherwise, lifted from iq @ https://iquilezles.org/articles/smoothvoronoi\n*/\n\nfloat smoothVoronoi_f1_height( in vec2 x, float randomness, float power, float angle )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2 point = randomness * random2f( p + b );\n        vec2  r = vec2( b ) - f + point;\n        float d = veronoi_metric( r, power, angle );\n\n        res += 1.0/pow( d, 8.0 );\n    }\n    return pow( 1.0/res, 1.0/16.0 );\n}\n\nvec4 voronoi_f1_colors( in vec2 x, float randomness, float power, float angle )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res = 8.0;\n    vec3 res_col = vec3(0.);\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2 point = random2f( vec2(p + b) );\n        vec2  r = vec2( b ) - f + randomness*point;\n        float d = veronoi_metric( r, power, angle);\n        vec3 col = vec3(point,1.);\n\n        res_col = (d < res) ? col : res_col;\n        res = min( res, d );\n    }\n    return vec4(res_col, sqrt( res ));\n}\n\n\nvec4 voronoi_f2_colors( in vec2 x, float randomness, float power,float angle )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    float res2   = 8.0, res1   = 8.0;\n    float t_res2 = 8.0, t_res1 = 8.0;\n    vec3 res2_col = vec3(0.), res1_col = vec3(0.);\n    \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2( i, j );\n        vec2 point = random2f( vec2(p + b) );\n        vec2  r = vec2( b ) - f + randomness*point;\n        float d = veronoi_metric( r, power, angle );\n        vec3 col = vec3(point,1.);\n        \n        \n        // https://stackoverflow.com/questions/1582356/fastest-way-of-finding-the-middle-value-of-a-triple\n        t_res1 = min(min(res1,res2), d);\n        t_res2 = max(min(res1,res2), min(max(res1,res2),d));\n        \n        res1_col = (t_res1 == res1) ? res1_col : ((t_res1 == res2) ? res2_col : col);\n        res2_col = (t_res2 == res1) ? res1_col : ((t_res2 == res2) ? res2_col : col);\n        \n        res1 = t_res1;\n        res2 = t_res2;\n\n        \n    }\n    return vec4(res2_col, sqrt( res2 ));\n}\n\nvec3 voronoi2_and_noise2(in vec2 uv, float randomness, float exponent, vec3 grout_col, vec3 brick_col)\n{\n    float edge = pow(0.5,exponent/1.7);\n    vec4 v_f1 = voronoi_f1_colors(uv, randomness, exponent, 0.);\n    float mask = step(edge,v_f1.w);\n    return mix(grout_col, brick_col, mask);\n}\n\n// https://iquilezles.org/articles/warp\nvec2 distort2(in vec2 u, int iters, float scale, float intensity, float time) {\n    vec2 p = vec2(u);\n    p = vec2(\n            fbm2(u+vec2(0.0,0.0),1,1.),\n            fbm2(u+vec2(5.2,1.3),1,1.));\n    for (int i = 0; i < iters-1; i++) \n    {\n        p = vec2(\n            fbm2(u + scale*p+vec2(1.7,9.2),1,1.),\n            fbm2(u + scale*p+vec2(8.3,2.8),1,1.));\n            \n        p += vec2(time);\n    }\n    return u+intensity*p;\n}\n\nvec3 ramp(float l) {\n    return vec3(1.,l,1.);\n}\n\nvec3 func1(vec2 fragCoord, float time) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*vec2(10.,10.);\n    vec2 uv2 = distort2(uv, 3, 1.0, 1.0, time);\n    float h = pow(fbm2(uv2, 5, 1.),1.);\n    vec3 col = ramp(h);\n    return col;\n}\n\nvec3 func2(vec2 fragCoord, float time) \n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = uv*vec2(10.,10.);\n    vec2 uv2 = distort2(uv, 3, 1.0, 1.0, time);\n    float h = pow(fbm2(uv2, 2, 1.),1.);\n    vec3 col = ramp(h);\n    return col;\n}\n\nconst float LOOP_TIME = 5.;\n\n\n\n// ty to jjxtra at https://stackoverflow.com/questions/12751080/glsl-point-inside-box-test/37426532\nvec2 inBox(vec2 v, vec2 bottomLeft, vec2 topRight) {\n    vec2 s = step(bottomLeft, v) - step(topRight, v);\n    return v * (s.x * s.y);   \n}\n\nfloat renderChar(vec2 uv, Char char, float time) {\n    vec2 scale   = vec2(1.)/char.dims;\n    vec2 font_uv = inBox(scale * (uv - char.pos) + char.pos, vec2(0.), vec2(1.));\n    vec2 font_coord = font_uv / vec2(16.) + char.char;\n    vec4 sdf = textureLod(iChannel3, font_coord, 0.2);\n    \n    \n    float sdf_w = (sdf.w - 127. / 255.);\n    \n    float smoothed1 = smoothstep(-.09, 0.19, sdf_w);\n    float smoothed2 = smoothstep(-.09, 0.15,  sdf_w);\n    \n    float mask = smoothed2 > 0.5 ? 0. : 1.;\n    //return 1.-smoothed1;\n    return max(mask, 1.- mix(smoothed1, smoothed2, sin(2.*pi*time/LOOP_TIME)));\n}\n\nvec3 textSDF(vec2 uv, float time)\n{\n    float mask = max( renderChar(uv, b, time), max( renderChar(uv, o, time), max( renderChar(uv, n, time), renderChar(uv, k, time) ) ) );\n    \n    return vec3(mask);\n    \n    return vec3(mask);\n\n}\n\n\nvec2 getJitter(float iTime)\n{\n    return 0.3*(distort2(vec2(iTime), 5, 1., 1., 0.) - vec2(iTime)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 jitter1 = getJitter(mod(iTime,LOOP_TIME));\n    vec2 jitter2 =  getJitter(mod(iTime,LOOP_TIME) - LOOP_TIME);  \n    vec2 jitter = mix(jitter1, jitter2, mod(iTime/LOOP_TIME,1.));\n    \n    vec3 col1 = func1(fragCoord, mod(iTime,LOOP_TIME) );\n    vec3 col2 = func1(fragCoord, mod(iTime,LOOP_TIME) - LOOP_TIME);    \n    vec3 col = mix(col1, col2, mod(iTime/LOOP_TIME,1.));    \n    \n    vec2 uvText = (0.7)*(fragCoord/iResolution.xy-0.5)+0.5;\n    float textMask = textSDF(uvText+jitter,iTime).x;\n\n    fragColor = (vec4(col,1.) + 0.5)*textMask;\n    \n}","name":"Image","description":"","type":"image"}]}