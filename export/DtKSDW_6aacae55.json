{"ver":"0.1","info":{"id":"DtKSDW","date":"1686108933","viewed":104,"name":"Zoneplate","username":"Quazi","description":"Zone plate for a point source. Move source used to generate holographic film with mouse.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float freq = 12.0;\nconst float amp = 1.0;\nconst float ang = PI*0.00;\nconst vec2 dir= vec2(cos(ang), sin(ang));\n\nvec2 ref_beam( vec2 uv, float t)\n{\n    return plane_wave(uv, t, freq, amp, 0.0, dir);\n}\n\nvec2 hologram( vec2 uv, float t, vec2 pos)\n{   \n    vec2 wave = vec2(0.0, 0.0);\n    wave += ref_beam(uv, t);\n    wave += point_wave(uv, t, freq, amp, iTime, pos);\n    return wave;\n}\n\nfloat hologram_exposure(vec2 hologram){\n    // simulate exposing the holographic film and the non-linear effects it can have.\n    // exposure is ultimately what modulates incoming wave.\n    // there's a sweet spot for mapping the hologram to an exposure to maximize the spike\n    float exposure = 0.5*float(length(hologram)>1.00);\n    return exposure;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n    float t = iTime*0.1;\n    \n    // Hologram consts\n    float holo_thickness = 0.005;\n    float holo_height = iResolution.y/iResolution.x;\n    vec2 holo_pos = vec2(0.5, holo_height*0.5);\n    \n    vec2 mouse_uv = iMouse.xy/iResolution.x;\n    if(length(iMouse.zw - vec2(0.0,0.0))<4.0){\n        float ang = iTime;\n        mouse_uv = vec2(0.25,holo_height*0.5)+vec2(cos(ang*3.0), sin(ang*1.1)*1.5)*0.1;\n    }\n\n\n    \n    // Time varying pixel color\n    vec4 col = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    vec2 wave = vec2(0.0, 0.0);\n    \n    // Draw a the hologram film\n    vec2 holo = hologram(uv, t, mouse_uv);\n    float holo_mag = length(hologram(uv, t, mouse_uv));\n    // we may want ref beam too\n    vec2 ref_wave = ref_beam(uv, t);\n    \n    if(uv.x < holo_pos.x){\n        // draw the left hand side (reference beam)\n        wave += holo;\n    }else{\n        // draw the right hand side (interference from hologram film)\n        const int N = 1000;\n        float E_chunk = (S * holo_height * amp) / float(N);\n        vec2 wave_chunk = vec2(0.0 ,0.0);\n        for (int i = 0; i < N; i++) {\n            // need total energy of the wavefront???\n            // Scale factor is important.\n\n            vec2 integral_uv = vec2(holo_pos.x, ((float(i)+0.5)/float(N))*holo_height);\n            //float integral_holo_mag = length(hologram_exposure(hologram(integral_uv, t, mouse_uv)));\n            float integral_holo_mag = hologram_exposure(hologram(integral_uv, t, mouse_uv));\n            float integral_phase = dot(integral_uv, dir) * S * freq + integral_holo_mag;\n            wave_chunk += point_wave(uv, t, freq, 1.0, integral_phase, integral_uv);\n        }\n        wave += wave_chunk * E_chunk;\n    }\n        \n    vec2 cancel_wave = wave;\n    float mag_disp = length(cancel_wave);\n    col.r = log(10.0*mag_disp);\n    col.g = log(1.5*mag_disp);\n    col.b = log(0.25*mag_disp);\n    if(mag_disp < 0.1){\n       col.b =+ 1.0-exp(-10.0*(0.1-mag_disp));\n    }\n    //col.b = holo_mag;\n    if(abs(uv.x-holo_pos.x) < holo_thickness){ \n        col.rgb = mix(vec3(0.,0.,0.), vec3(1.,1.,1.), pow(1.0-holo_mag,0.1));\n    }\n    \n    // Output to screen\n    fragColor = col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PI = 3.14159265358979323846264338327950288;\nconst float S =50.0; //scale factor (what does 1 unit equal (e.g. 100 pixels = 1 unit -> S=100.0))\n\nvec2 plane_wave( vec2 uv, float time, float freq, float amp, float phase, vec2 dir )\n{\n    float w= dot(uv, dir) * S;\n    float t=((w - time) * freq + phase) * 2.0 * PI;\n    return amp*vec2(sin(t), cos(t));\n}\n\nvec2 point_wave( vec2 uv, float time, float freq, float amp, float phase, vec2 pos )\n{\n    //this represents a column into Z rather than a point, hence like field around wire.\n    float w = length(uv-pos) * S;\n    float r_sqd = w;\n    float t=((w - time) * freq + phase )* 2.0 * PI;\n    return amp*vec2(amp*sin(t),amp*cos(t))/r_sqd;\n}","name":"Common","description":"","type":"common"}]}