{"ver":"0.1","info":{"id":"wdsSWj","date":"1552245636","viewed":96,"name":"testing ayayayayay","username":"Derzo","description":"raymarching","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MIN_STEP_DIST 0.0001\n#define MIN_SHADOW_DIST 0.01\n\nconst vec3 Red = vec3(0.9, 0.95, 0.95);\nconst vec3 Green = vec3(0, 1, 0);\nconst vec3 Blue = vec3(0.1, 0.2, 0.9);\nconst vec3 White = vec3(1, 1, 1);\n\n\nstruct Obj\n{\n    int Type;\n    int Index;\n\tvec3 Location;\n    vec3 Color;\n};\n    \nstruct Sphere\n{\n    Obj Object;\n    float Radius;\n};\n    \nstruct Box\n{\n    Obj Object;\n    vec3 Extent;\n};\n\nSphere Spheres[] = Sphere[](\n    Sphere(Obj(0, 0, vec3(5, 0, 0), Red), 2.),\n    Sphere(Obj(0, 1, vec3(5, 3, 0), Blue), 1.5)\n);\n/*\nBox Boxes[] = Box[](\n    Box(Obj(vec3(2, 2, 0), Red), vec3(2, 1, 2)),\n    Box(Obj(vec3(2, -2, 1), Green), vec3(1))\n);*/\n\nfloat sceneSDF(in vec3 p, out Obj obj)\n{\n    float d = 10000.;\n\tfor (int i=0; i<Spheres.length(); i++)\n    {\n        float nd = sdSphere(\n            p-Spheres[i].Object.Location,\n                            Spheres[i].Radius);\n        if (nd < d)\n        {\n            obj = Spheres[i].Object;\n            d = nd;\n        }\n    }\n\n    return d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float EPSILON = 0.0001;\n    Obj Obj;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z), Obj) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z), Obj),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z), Obj) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z), Obj),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON), Obj) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON), Obj)\n    ));\n}\n\nfloat March(in vec3 ro, in vec3 rd, in float maxt)\n{\n\tfloat t=0.;\n    while (t<maxt)\n    {\n        Obj obj;\n        float d = sceneSDF(ro+rd*t, obj);\n        if (d<0.001) { break; }\n        t += d;\n    }\n    return t;\n}\n\nvec3 Light(in vec3 p, in vec3 n, in vec4 l)\n{\n\n    vec3 pToLight = l.xyz-p;\n    vec3 ln = normalize(pToLight+n);\n\n\tObj obj;\n\tsceneSDF(p, obj);\n    \n    float A = 0.;\n    vec3 SurfColor = obj.Color;\n    vec3 IndirectColor = vec3(0);\n    float StepDelta = 0.01;\n    for (int i=0; i<8; i++)\n    {\n        StepDelta *= 2.;\n        A += sceneSDF(p+ln*StepDelta*float(i), obj);\n        IndirectColor += obj.Color/max(A*0.1, 1.);\n    }\n    IndirectColor /= 8.;\n    A = clamp((A-15.)*0.055, 0., 1.);\n    vec3 Color = (SurfColor+IndirectColor)/2.;\n    float Dot = 0.5+0.5*dot(ln, n);\n    return vec3(A);//*l.w/length(pToLight);\n\n}\n\nvec3 Checker(in vec3 p, in float scale)\n{\n    bool white = (sin(p.x/scale)+sin(p.y/scale)) > 0.;\n    if (white)\n    {\n        return vec3(0.9, 0.9, 0.9);\n    }\n    return vec3(1., 1., 1.);\n}\n\nvec3 vlerp(in vec3 a, in vec3 b, in float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    return alpha*b + (1.-alpha)*a;\n}\n\nfloat smoothCeil(in float alpha)\n{\n    alpha = clamp(alpha, 0., 1.);\n    return clamp(-2.*alpha*alpha*alpha+3.*alpha*alpha, 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 CamLoc = vec3(-10,cos(iTime)*2., sin(iTime)*2.);\n    mat3 CamMat = LookAt(vec3(0), CamLoc);\n    vec3 CamF = CamMat[0];\n    vec3 CamR = CamMat[1];\n        \n    vec3 PixelPos = ScreenPixelWS(CamLoc, CamF, CamR, uv, iResolution.xy);\n    vec3 DirVec = normalize(PixelPos-CamLoc);\n\n    vec3 DebugPlaneNormal = normalize(vec3(sin(iTime), 0, cos(iTime)));\n    vec3 DebugPlanePoint = vec3(0, 0, 0);\n\n    float dd = LinePlaneIntr(DebugPlanePoint, PixelPos, DirVec, DebugPlaneNormal);\n    vec3 dp = PixelPos + dd*DirVec;\n    \n    float SurfDist = March(PixelPos+DirVec*8., DirVec, 1000.); \n    vec3 SurfPoint = PixelPos+DirVec*8. + DirVec*SurfDist;\n    vec3 Normal = estimateNormal(SurfPoint);\n    \n    vec4 Light1 = vec4(vec3(5, -1, iTime), 5.);\n    vec3 Lightness = Light(SurfPoint, Normal, Light1);\n    \n    vec3 Color = Lightness*Checker(SurfPoint, 0.25);\n\n    float FogStart = 5.;\n    float FogDensity = 0.001;\n    float q = (SurfDist-FogStart)/(FogStart+1./FogDensity);\n    Color = vlerp(Color, vec3(.9, 0.95, .95), smoothCeil(q));\n    \n    fragColor = vec4(Color, 1.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float PlayerRadius = 0.15;\n    \nfloat LinePlaneIntr(in vec3 p0, in vec3 l0, in vec3 l, in vec3 n)\n{\n    return dot((p0-l0), n) / dot(l, n);\n}\n\nfloat smin( float a, float b, float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat3 LookAt(in vec3 p, in vec3 cam)\n{\n    vec3 f = normalize(p-cam);\n    vec3 r = normalize(cross(vec3(0, 0, 1), f));\n    return mat3(\n        f,\n        r,\n        cross(f, r)\n    );\n}\n\nvec3 Reflect(in vec3 d, in vec3 n)\n{\n    return d - 2.0*dot(d, n)*n;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\tvec3 pa = p - a, ba = b - a;\n \tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n \treturn length( pa - ba*h ) - r;\n}\n\nfloat sdPlane(in vec3 p, in vec3 n)\n{\n    return dot(p, n);\n}\n\nfloat sdSphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec3 ScreenPixelWS(in vec3 CamLoc, in vec3 CamF, in vec3 CamR, in vec2 uv, in vec2 res)\n{\n    float AspRatio = res.y/res.x;\n\n    float x = uv.x - 0.5;\n    float z = uv.y*AspRatio - AspRatio/2.0;\n    return CamLoc + x*CamR + z*cross(CamF, CamR) + CamF;\n}","name":"Common","description":"","type":"common"}]}