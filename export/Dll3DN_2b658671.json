{"ver":"0.1","info":{"id":"Dll3DN","date":"1676207632","viewed":190,"name":"Seraph","username":"altaha","description":"My first Raymarching Art. Inspired from winged angels.\nLearnt SDFs from Inigo's Articles and other blog posts.\nThank You!","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","wings","room","creature","flying","eyeball","angel"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsX3zn","filepath":"/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","previewfilepath":"/media/ap/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.1415926538  \n\nsurface eyeBall(vec3 p){\n    float t = iTime*3.0;\n    p = rotate3d(p, vec3(1,0,0), cos(t)*0.1);\n    vec3 irisCol = vec3(20., 196., 146.)/255.;\n    surface sclera = sdSphere( p, 0.40, vec3(0.0,0.1,0.45), vec3(1.5, 1.0, 1.0), vec4(1.0,0.0,0.0,1.0));\n    surface iris = sdSphere( p, 0.20, vec3(0.0,0.1,0.75), irisCol, vec4(1.0,0.0,0.0,1.0));\n    surface pupil = sdSphere( p, 0.10, vec3(0.0,0.1,0.9), vec3(0.0), vec4(1.0,0.0,0.0,1.0));\n    surface finalScene = opSmoothUnion(sclera, iris, 0.05);\n    finalScene = opSmoothUnion(finalScene, pupil, 0.05);\n    return finalScene;\n}\n\nsurface body( vec3 p){\n    float t = iTime*3.0;\n    vec4 matParams = vec4(1.0,1.0,0.0,1.);\n    surface innerSphere = sdSphere(p, 0.75, vec3(0.0), vec3(0.25,0.25,0.25), matParams);\n    float noise = sin(5.0*p.x+t)*sin(10.0*p.y+t)*sin(15.0*p.z+t);\n    innerSphere.s += noise*0.1;\n    surface torus = sdCappedTorus(p, vec2(cos(2.*PI*fract(t*0.2)),sin(2.*PI*fract(t*0.2))), 1.25, 0.1, vec3(0.0), vec3(0.5), matParams);\n    torus.s += noise*0.1;\n    surface eye = eyeBall(p);\n    surface finalScene = opSmoothUnion(innerSphere,torus,0.70);\n    finalScene = opSmoothUnion(finalScene,eye,0.10);\n    return finalScene;\n}\n\nsurface wingLayer(vec3 p){\n    vec4 matParams = vec4(1.0,0.9,0.1,1.0);\n    vec3 col = vec3(252., 88., 127.)/255.;\n    surface c1 = sdCapsule(p, vec3(0.0), vec3(0.75,0.75,0.0), 0.2, vec3(0.0), col, matParams);\n    surface c2 = sdCapsule(p, vec3(0.75,0.75,0.0), vec3(1.5,1.5,0.0), 0.2, vec3(0.0), col, matParams);\n    surface c3 = sdCapsule(p, vec3(1.5,1.5,0.0), vec3(2.5,2.0,0.0), 0.2, vec3(0.0), col, matParams);\n    surface finalScene = opSmoothUnion(c1,c2,0.15);\n    finalScene = opSmoothUnion(finalScene, c3, 0.15);\n    return finalScene;\n}\n\nsurface wings( vec3 p, float depth, float phase ){\n    float t = iTime*3.0;\n    float noise = sin(5.0*p.x+t)*sin(10.0*p.y+t)*sin(15.0*p.z+t);\n    p.y -= -0.4;\n    p.xy = abs(p.xy);\n    p.z -= depth;\n    vec3 p1 = rotate3d(p, vec3(0.0,0.0,1.0), mix(0.07,0.4,cos(t-phase-0.22)));\n    vec3 p2 = rotate3d(p, vec3(0.0,0.0,1.0), mix(0.05,0.4,cos(t-phase-0.11)));\n    vec3 p3 = rotate3d(p, vec3(0.0,0.0,1.0), mix(0.03,0.4,cos(t-phase)));\n    surface w1 = wingLayer(p1);\n    surface w2 = wingLayer(p2*1.1 - vec3(0.,-0.5,0.0));\n    surface w3 = wingLayer(p3*1.2 - vec3(0.,-1.1,0.0));\n    surface finalScene = opSmoothUnion(w1,w2,0.5);\n    finalScene = opSmoothUnion(finalScene, w3, 0.5);\n    finalScene.s += noise*0.05;\n    return finalScene;\n}\n\nsurface sdScene( vec3 p){\n    vec2 mouse = (iMouse.xy/iResolution.xy)*PI*2.0;\n    float rot = mouse.x;\n    p = rotate3d(p, vec3(0,1,0), mouse.x);\n    surface body = body(p);\n    surface finalScene = body;\n    surface wings1 = wings(p, -1.0, 0.0);\n    surface wings2 = wings(p, -1.1, PI);\n    finalScene = opUnion(wings1,body);\n    finalScene = opUnion(wings2,finalScene);\n    return finalScene;\n}\n\nvec3 getNormals(vec3 p){\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).s +\n      e.yyx * sdScene(p + e.yyx).s +\n      e.yxy * sdScene(p + e.yxy).s +\n      e.xxx * sdScene(p + e.xxx).s);\n}\n\nsurface rayMarch(vec3 origin, vec3 direction){\n\n    int STEPS = 100;\n    float MIN_TRAVEL_DISTANCE = 0.001;\n    float MAX_TRAVEL_DISTANCE = 100.0;\n    surface closestSurface;\n    float distanceTravelled = 0.0;\n    \n    for(int i=0; i<STEPS; i++){\n        \n        vec3 currPos = origin + direction * distanceTravelled;\n        closestSurface = sdScene(currPos);\n        distanceTravelled += closestSurface.s;\n        \n        if(closestSurface.s <=MIN_TRAVEL_DISTANCE || distanceTravelled >=MAX_TRAVEL_DISTANCE){\n            break;\n        }\n     }\n        closestSurface.s = distanceTravelled;\n        return closestSurface;\n}\n\nvec3 rgbShift(vec2 uv, vec3 refraction){\n    float t = cos(iTime);\n    float c1 = texture(iChannel1, uv+(refraction.xy)*0.1).r;\n    float c2 = texture(iChannel1, uv+(refraction.xy)*0.2).g;\n    float c3 = texture(iChannel1, uv+(refraction.xy)*0.3).b;\n    vec3 col = vec3(c1,c2,c3);\n    return col;\n}\n\n\nfloat getDiffuse(vec3 lightPos, vec3 normals, vec3 p, vec3 direction){\n    vec3 lightDir = normalize(p - lightPos);\n    vec3 reflectedRay = reflect(lightDir,normals);\n    float specular = clamp(pow(dot(direction,reflectedRay),50.0),0.0,1.0);\n    float diffuse = clamp(dot(lightDir,normals),0.0,1.0);\n    return diffuse+specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 uvScreen = fragCoord/iResolution.xy;\n    \n    vec3 cameraPos = vec3(0.0,1.0,5.5);\n    vec3 direction = normalize(vec3(uv,-1.0));\n    direction = (rotation3d(vec3(1.0,0.0,0.0),0.2)*vec4(direction,1.0)).xyz;\n    \n    surface rr = rayMarch(cameraPos, direction);\n    vec3 col = texture(iChannel1, uvScreen).rgb;\n    if(rr.s>=100.0){\n        col = col;\n    }else{\n        vec3 p = cameraPos + direction * rr.s;\n        vec3 normals = getNormals(p);\n        vec3 lightPos1 = vec3(5.0,5.0,-4.0);\n        vec3 lightPos2 = vec3(-5.0,-5.0,-4.0);\n        float light1 = getDiffuse(lightPos1,normals,p,direction);\n        float light2 = getDiffuse(lightPos2,normals,p,direction);\n        vec3 refraction = refract(vec3(0.,0.,-1.0),normals,1.5);\n        float rim = 1.0 - dot(normals,vec3(0.0,0.0,1.0));\n        vec3 reflectedRays = normalize(reflect(direction, normals));\n        vec3 cubemap = texture(iChannel0, reflectedRays).rgb;\n        vec3 refr = rgbShift(uvScreen,refraction);\n        col = mix(rr.color,refr,rr.params.y);\n        col = col*(light1+light2);\n        col = mix(col,col*cubemap,rr.params.z);\n        col +=rim*cubemap*rr.params.x;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"struct surface{\n    float s;\n    vec3 color;\n    vec4 params; // r: rim, g: refraction, b: env\n};  \n\nfloat czm_luminance(vec3 rgb)\n{\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n\n\nmat4 rotation3d(vec3 axis, float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n    0.0,                                0.0,                                0.0,                                1.0\n  );\n}\n\nvec3 rotate3d(vec3 p, vec3 axis, float angle){\n    mat4 mat = rotation3d(axis, angle);\n    p = (mat * vec4(p,1.0)).xyz;\n    return p;\n}\n\nsurface opUnion( surface d1, surface d2 ) {\n    float s = min(d1.s,d2.s);\n    float t = (s - d1.s)/(d2.s - d1.s);\n    vec3 col = mix(d1.color,d2.color,t);\n    vec4 params = mix(d1.params, d2.params, t);\n    return surface(s,col,params); \n}\n\nsurface opSmoothUnion( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.s-d1.s)/k, 0.0, 1.0 );\n    float s = mix( d2.s, d1.s, h ) - k*h*(1.0-h); \n    vec3 color = mix(d2.color,d1.color,h);\n    vec4 params = mix(d2.params,d1.params,h);\n    return surface(s,color,params);\n}\n\nsurface sdBox( vec3 p, vec3 b, vec3 position, vec3 color, vec4 params)\n{\n  p -= position;\n  vec3 q = abs(p) - b;\n  return surface(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0),color,params);\n}\n\nsurface sdCapsule( vec3 p, vec3 a, vec3 b, float r, vec3 position, vec3 color, vec4 params )\n{\n  p -= position;\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return surface(length( pa - ba*h ) - r,color,params);\n}\n\nsurface sdSphere( vec3 p, float s, vec3 position, vec3 color, vec4 params )\n{\n  p -= position;\n  return surface(length(p)-s,color, params);\n}\n\nsurface sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb, vec3 position, vec3 color, vec4 params)\n{\n  p -= position;\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  float s = sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n  return surface(s,color,params);\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGzn","filepath":"/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","previewfilepath":"/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4df3Rr","filepath":"/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","previewfilepath":"/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define PI 3.1415926538  \n\nsurface room(vec3 p, vec3 size){\n    float t = abs(cos(iTime));\n    vec3 uv = (p+vec3(5.0,5.0,4.0))/vec3(10.0,8.0,8.0);\n    vec3 floorBot = mix( texture(iChannel1, uv.xz).rgb, vec3(1.0), 0.8);\n    vec3 wallsLR = mix( texture(iChannel1, uv.yz).rgb, vec3(1.0), 0.8);\n    vec3 wallBack = mix( texture(iChannel1, uv.xy).rgb , vec3(1.0), 0.8);\n    mat4 rotate90y = rotation3d(vec3(0.0,1.0,0.0), PI/2.0);\n    mat4 rotate90x = rotation3d(vec3(1.0,0.0,0.0), PI/2.0);\n    vec4 wallParams = vec4(1.0,0.0,0.15*(uv.y),0.0);\n    surface backWall =  sdBox(p,                           vec3(size.xy,0.01), vec3(0.0,0.0,-size.z),    wallBack, wallParams);\n    surface leftWall =  sdBox((rotate90y*vec4(p,1.0)).xyz, vec3(size.xy,0.02), vec3(size.z,0.0,size.x),  wallsLR, wallParams);\n    surface rightWall = sdBox((rotate90y*vec4(p,1.0)).xyz, vec3(size.xy,0.02), vec3(size.z,0.0,-size.x), wallsLR, wallParams);\n    surface botWall =   sdBox((rotate90x*vec4(p,1.0)).xyz, vec3(size.xy,0.02), vec3(0.0,-size.z/2.0,size.y), floorBot, wallParams);\n    \n    surface finalScene = opUnion(rightWall,leftWall);\n    finalScene = opUnion(finalScene,backWall);\n    finalScene = opUnion(finalScene,botWall);\n    \n    return finalScene;\n}\n\nsurface sdScene( vec3 p){\n    float t = iTime*3.0;\n    surface innerSphere = sdSphere(p, 0.75, vec3(0.0), vec3(0.25,0.25,0.25), vec4(1.0,1.0,vec2(0.)));\n    float noise = sin(5.0*p.x+t)*sin(10.0*p.y+t)*sin(15.0*p.z+t);\n    innerSphere.s += noise*0.1;\n\n    surface room = room(p-vec3(0.0,2.0,0.0), vec3(6.0,4.0,1.0));\n    surface finalScene = room;\n    return finalScene;\n}\n\nvec3 getNormals(vec3 p){\n    vec2 e = vec2(1.0, -1.0) * 0.0005; // epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).s +\n      e.yyx * sdScene(p + e.yyx).s +\n      e.yxy * sdScene(p + e.yxy).s +\n      e.xxx * sdScene(p + e.xxx).s);\n}\n\nsurface rayMarch(vec3 origin, vec3 direction){\n\n    int STEPS = 100;\n    float MIN_TRAVEL_DISTANCE = 0.001;\n    float MAX_TRAVEL_DISTANCE = 100.0;\n    surface closestSurface;\n    float distanceTravelled = 0.0;\n    \n    for(int i=0; i<STEPS; i++){\n        \n        vec3 currPos = origin + direction * distanceTravelled;\n        closestSurface = sdScene(currPos);\n        distanceTravelled += closestSurface.s;\n        \n        if(closestSurface.s <=MIN_TRAVEL_DISTANCE || distanceTravelled >=MAX_TRAVEL_DISTANCE){\n            break;\n        }\n     }\n        closestSurface.s = distanceTravelled;\n        return closestSurface;\n}\n\nvec3 getDirectionalDiffuse(vec3 lightPos, vec3 normals, vec3 p, vec3 lightDir, vec3 color){\n    vec3 lightPosDir = normalize(p - lightPos);\n    float dist = distance(p, lightPos);\n    float diffuse = clamp(dot(lightPosDir, lightDir),0.0,1.0);\n    return diffuse*color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec2 uvScreen = fragCoord/iResolution.xy;\n    float t = iTime;\n    vec3 cameraPos = vec3(0.0,0.0,7.0);\n    vec3 direction = normalize(vec3(uv,-1.0));\n    direction = (rotation3d(vec3(1.0,0.0,0.0), 0.0)*vec4(direction,1.0)).xyz;\n    \n    surface rr = rayMarch(cameraPos, direction);\n    vec3 col = mix(vec3(1.0),vec3(0.25),smoothstep(0.0,1.0,abs(uv.x*uv.y)));\n    if(rr.s>=100.0){\n        col = col;\n    }else{\n        vec3 p = cameraPos + direction * rr.s;\n        vec3 normals = getNormals(p);\n        vec3 lightPos1 = vec3( 0.0, 0, 5.0);\n        vec3 lightPos2 = vec3(0.0,1.0,0.0);\n        vec3 lightPos3 = vec3( -1.0,  1.0, 0.0);\n        vec3 lightPos4 = vec3(  1.0,  1.0, 0.0);\n        vec3 light1 = getDirectionalDiffuse(lightPos2,normals,p, normalize(vec3(0, -1.0, 1.0)), vec3(252., 106., 140.)/255.);\n        vec3 light2 = getDirectionalDiffuse(lightPos2,normals,p, normalize(vec3(0, 0.0,-1.0)), vec3(252., 106., 184.)/255.);\n        vec3 light3 = getDirectionalDiffuse(lightPos3,normals,p, normalize(vec3(1.0, 1.0,0.0)), vec3(133., 75., 250.)/255.);\n        vec3 light4 = getDirectionalDiffuse(lightPos4,normals,p, normalize(vec3(-1,-1.0,0.0)), vec3(106., 111., 252.)/255.);\n        vec3 refraction = refract(vec3(0.,0.,-1.0),normals,1.5);\n        float rim = 1.0 - dot(normals,vec3(0.0,0.0,1.0));\n        vec3 reflectedRays = normalize(reflect(direction, normals));\n        vec3 cubemap = texture(iChannel0, reflectedRays).rgb;\n        vec3 mixT = getDirectionalDiffuse(lightPos4,normals,p, normalize(vec3(-1.0,-1.0,0.0)), vec3(1.));\n        col = rr.color;\n        col = col*(light1+light2+light3+light4);\n        col = mix(col,col*cubemap,rr.params.z);\n        col +=rim*cubemap*rr.params.x;\n    }\n\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}