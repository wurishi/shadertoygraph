{"ver":"0.1","info":{"id":"lfXfWH","date":"1723701045","viewed":51,"name":"Millitext","username":"Lokno","description":"Display a sub-pixel font with 5x2 pixel characters designed by Matt Sarnoff\n\nRender const strings encoded as ascii decimals \nRender dynamic floats in a fixed format\n\nhttp://www.msarnoff.org/millitext/\n\nMagnification code by spalmer","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["text","debug","eyepain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\nconst uint msgMaxLength = 64u;\n\nconst uint describLengthMsg = 25u;\nconst int describMsg[msgMaxLength] = int[](77,73,76,76,73,84,69,88,84,32,66,89,32,77,65,84,84,32,83,65,82,78,79,70,70,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32);\n\nconst uint describLengthMsg2 = 37u;\nconst int describMsg2[msgMaxLength] = int[](65,32,83,85,66,45,80,73,88,69,76,32,50,88,53,32,70,79,78,84,32,70,79,82,32,76,69,68,32,77,79,78,73,84,79,82,83,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32);\n\nconst uint lengthCowboyMsg = 20u;\nconst int cowboyMessage[msgMaxLength] = int[](83,69,69,32,89,79,85,32,83,80,65,67,69,32,67,79,87,66,79,89,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32);\n\nconst uint lengthElaspedMsg = 14u;\nconst int elapsedMessage[msgMaxLength] = int[](69,76,65,80,83,69,68,32,84,73,77,69,58,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32);\n\n// \"\"\" !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~\"\"\"\"\nconst uint millitext_ascii[95] = uint[]( 0u,4169u,1179666u,647638714u,579039979u,269567044u,339753187u,9u,537002568u,8778u,42474217u,12587977u,8704u,12583360u,4096u,1131584u,576339299u,536883801u,814381255u,579498183u,617742820u,579039719u,578959843u,9114119u,579483875u,583676131u,520u,8712u,537002632u,102239800u,8397322u,1052771u,819607907u,315247075u,579500519u,805517603u,575306023u,813922791u,8604135u,851655011u,315181540u,537014859u,575223808u,336677348u,805337380u,307841396u,373901684u,575289635u,9062887u,340408611u,311052775u,579039459u,201295u,575224100u,71898404u,373902692u,336675924u,1118804u,806581319u,537006665u,335544404u,12875u,5243153u,805335040u,1048577u,315247075u,579500519u,805517603u,575306023u,813922791u,8604135u,851655011u,315181540u,537014859u,575223808u,336677348u,805337380u,307841396u,373901684u,575289635u,9062887u,340408611u,311052775u,579039459u,201295u,575224100u,71898404u,373902692u,336675924u,1118804u,806581319u,537006729u,4681u,8401419u,71303504u );\n\n// \"\"\"0123456789.- \"\"\"\nconst uint millitext_digits[13] = uint[]( 576339299u,536883801u,814381255u,579498183u,617742820u,579039719u,578959843u,9114119u,579483875u,583676131u,4096u,12583360u,0u );\n\nint getDigit(float x, int position, int sign, int integer_length, int decimal_length) {\n\n    const int ASCII_ZERO = 0;    // '0'\n    const int ASCII_PERIOD = 10; // '.'\n    const int ASCII_SPACE = 12;  // ' '\n    const int ASCII_DASH = 11;   // '-'\n    \n    float absX = abs(x);\n    int actualIntLength = max(1, int(log(absX) / log(10.0)) + 1);\n    int totalLength = max(integer_length, actualIntLength) + (decimal_length > 0 ? (1 + decimal_length) : 0);\n    \n    if (sign == 1) {\n        totalLength += 1;\n    }\n    \n    if (position < 0 || position >= totalLength) {\n        return ASCII_SPACE;\n    }\n    \n    if (sign == 1 && position == 0) {\n        return (x < 0.0) ? ASCII_DASH : ASCII_SPACE;\n    }\n    \n    if (sign == 1) {\n        position -= 1;\n    }\n    \n    int offset = max(0, actualIntLength - integer_length);\n    int paddedPosition = position - max(0, integer_length - actualIntLength);\n\n    if (paddedPosition < 0) {\n        return ASCII_SPACE;\n    }\n\n    if (paddedPosition < actualIntLength) {\n        int intPos = actualIntLength - 1 - paddedPosition - offset;\n        int digit = int(mod(floor(absX / pow(10.0, float(intPos))), 10.0));\n        return digit + ASCII_ZERO;\n    }\n\n    if (paddedPosition == actualIntLength && decimal_length > 0) {\n        return ASCII_PERIOD;\n    }\n\n    int fracPos = paddedPosition - actualIntLength - 1;\n    if (fracPos >= 0 && fracPos < decimal_length) {\n        float fracPart = absX - floor(absX);\n        fracPart *= pow(10.0, float(fracPos + 1));\n        int digit = int(mod(floor(fracPart), 10.0));\n        return digit + ASCII_ZERO;\n    }\n\n    return ASCII_SPACE;\n}\n\nvec3 getMilliTextColorAt(uint c, uint x, uint y) {\n    uint bitPos = (x * 5u + (4u-y)) * 3u;\n    const uint mask = 7u;\n    uint bitCol = (c >> bitPos) & mask;\n    return vec3(float(bitCol >> 2u & 1u), float(bitCol >> 1u & 1u), float(bitCol & 1u));\n}\n\n// Display a const string encoded as ascii table indices \nvec3 displayMessage( const int msg[msgMaxLength], vec2 bottomLeft, vec2 uv, uint lengthMsg )\n{\n    vec3 color = vec3(0,0,0);\n    vec2 subPos = uv - bottomLeft;\n    vec2 upperRight = vec2( float(2u * lengthMsg), 5.0 );\n    \n    if( all(greaterThanEqual(subPos, vec2(0.0))) && all(lessThanEqual(subPos, upperRight)) )\n    {\n        subPos.x = subPos.x / 2.0; \n        subPos.y = subPos.y / 5.0; \n        \n        uint p = uint(floor(subPos.x)) % lengthMsg;\n        \n        uint character = millitext_ascii[msg[p]-32];\n        \n        uint subX = uint(fract(subPos.x) * 2.0);\n        uint subY = uint(fract(subPos.y) * 5.0);\n    \n        color = getMilliTextColorAt(character, subX, subY);\n    }\n    \n    return color;\n}\n\n// Display any float within a fixed display format ([sign]integer_length[.decimal_length])\nvec3 displayFloat( vec2 bottomLeft, vec2 uv, float value, int sign, int integer_length, int decimal_length )\n{\n    int lengthNum = int(integer_length + decimal_length + (decimal_length > 0 ? (1 + decimal_length) : 0));\n    vec3 color = vec3(0,0,0);\n    vec2 subPos = uv - bottomLeft;\n    vec2 upperRight = vec2( float(2 * lengthNum), 5.0 );\n    \n    if( all(greaterThanEqual(subPos, vec2(0.0))) && all(lessThanEqual(subPos, upperRight)) )\n    {\n        subPos.x = subPos.x / 2.0; \n        subPos.y = subPos.y / 5.0; \n        \n        int p = int(floor(subPos.x)) % lengthNum;\n        \n        uint character = millitext_digits[getDigit(value,p,sign,integer_length,decimal_length)];\n        \n        uint subX = uint(fract(subPos.x) * 2.0);\n        uint subY = uint(fract(subPos.y) * 5.0);\n    \n        color = getMilliTextColorAt(character, subX, subY);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy * vec2(0.5,0.5);\n\n    // MILLITEXT BY MATT SARNOFF\n    // A SUB-PIXEL 2X5 FONT FOR LED MONITORS\n    vec3 color = displayMessage( describMsg, vec2( 10.0, 31.0), fragCoord, describLengthMsg );\n    color += displayMessage( describMsg2, vec2( 10.0, 24.0), fragCoord, describLengthMsg2 );\n    \n    // ELAPSED TIME: \n    color += displayMessage( elapsedMessage, vec2(10.0, 17.0), fragCoord, lengthElaspedMsg );\n    color += displayFloat( vec2(10.0 + float(lengthElaspedMsg) * 2.0, 17.0), fragCoord, iTime, 0, 7, 2 );\n    \n    // NUMBER\n    float number = -123456.7890;\n    color += displayFloat( vec2(10.0, 10.0), fragCoord, number, 1, 6, 4 );\n    \n    // SEE YOU SPACE COWBOY\n    color += displayMessage( cowboyMessage, vec2(iResolution.x - 20.0 - float(lengthCowboyMsg) * 2.0, 10.0), fragCoord, lengthCowboyMsg );\n    \n    // Magnified Text (by spalmer)\n    \n    vec3 magCol = vec3(0,0,0);\n    vec2 scaledCoord = fragCoord / 8.0;\n    \n    magCol += displayMessage( describMsg, vec2( 10.0, 31.0), scaledCoord, describLengthMsg );\n    magCol += displayMessage( describMsg2, vec2( 10.0, 24.0), scaledCoord, describLengthMsg2 );\n    \n    // ELAPSED TIME: \n    magCol += displayMessage( elapsedMessage, vec2(10.0, 17.0), scaledCoord, lengthElaspedMsg );\n    magCol += displayFloat( vec2(10.0 + float(lengthElaspedMsg) * 2.0, 17.0), scaledCoord, iTime, 0, 6, 2 );\n    \n    // NUMBER\n    magCol += displayFloat( vec2(10.0, 10.0), scaledCoord, number, 1, 6, 4 );\n    \n\n    // Toggle magnified text between unfiltered Millitext and scaled subpixel elements\n    if( int(iTime / 5.0 ) % 2 == 0 ) color += magCol[int(scaledCoord * 3.) % 3];\n    else color += magCol;\n    \n\n    fragColor = vec4(color, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}