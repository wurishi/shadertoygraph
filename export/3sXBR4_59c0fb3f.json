{"ver":"0.1","info":{"id":"3sXBR4","date":"1587728937","viewed":188,"name":"Fourteen Speheres","username":"dagelf","description":"Minor tweaks to https://www.shadertoy.com/view/tsScWR\n\nTodo: make the balls transparent, and render refractions behind and in front of them... ","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sphere","glow","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const vec3 CAMERA_LOOK_AT = vec3( 0, 0, -9.0 );\nconst float CAMERA_DIST = 25.0;\nconst float CAMERA_ZOOM = 2.6;\nconst float PI = 3.14159;\nconst float TWOPI = 2.0 * PI;\n\nconst float CAM_PITCH_MIN = -PI * 0.34;\nconst float CAM_PITCH_MAX = PI * 0.45;\n\nconst float GROUND_PLANE_HEIGHT = -10.0;\nconst float CAMERA_CLIP_HEIGHT = GROUND_PLANE_HEIGHT + 0.1;\nconst float HALLWAY_HALF_WIDTH = 60.0;\nconst float HALLWAY_LENGTH_NEG = -700.0;\nconst float HALLWAY_LENGTH_POS = 350.0;\nconst float CEILING_HEIGHT = 180.0;\nconst vec3 BG_BOX_CENTER = vec3( 0.0, (HALLWAY_LENGTH_NEG + HALLWAY_LENGTH_POS) * 0.5, (GROUND_PLANE_HEIGHT + CEILING_HEIGHT) * 0.5 );\nconst vec3 BG_BOX_SCALE = vec3( HALLWAY_HALF_WIDTH, (HALLWAY_LENGTH_POS - HALLWAY_LENGTH_NEG) * 0.5, (CEILING_HEIGHT - GROUND_PLANE_HEIGHT) * 0.5 );\n\nstruct CameraInfo\n{\n    vec3 origin;\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    vec3 bottomLeft;\n};\n\nvoid GetCameraInfo( in vec2 mousePos, in vec2 resolution, out CameraInfo cam )\n{\n    float aspectRatio = resolution.x / resolution.y;\n\n    float camYaw;\n    float camPitch;\n    if ( mousePos.x == 0.0 )\n    {\n        // no click yet\n        camYaw = 0.01;\n        camPitch = 0.3;\n    }\n    else\n    {\n        vec2 mousePos = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n        mousePos = -mousePos;\n\n        camYaw = mousePos.x * 2.0 * PI;\n        camPitch = mousePos.y;\n    }\n    \n    float cosCamOffsetPitch = cos( camPitch );\n    vec3 camOffset = CAMERA_DIST * vec3( cos( camYaw ) * cosCamOffsetPitch, sin( camYaw ) * cosCamOffsetPitch, sin( camPitch ) );\n    \n    float offsetScale = 1.0;\n    if ( CAMERA_LOOK_AT.z + camOffset.z < CAMERA_CLIP_HEIGHT )\n        offsetScale = (CAMERA_CLIP_HEIGHT - CAMERA_LOOK_AT.z) / camOffset.z;\n    camOffset *= offsetScale;\n\n    cam.origin = CAMERA_LOOK_AT + camOffset;\n    cam.forward = normalize( -camOffset );\n    cam.right = normalize( vec3( cam.forward.y, -cam.forward.x, 0.0 ) ); // cross( camForward, (0,0,1) )\n    cam.up = cross( cam.right, cam.forward );\n    \n    cam.forward *= CAMERA_ZOOM * (0.5 + 0.5 * offsetScale);\n    \n    cam.bottomLeft = cam.forward - cam.right * aspectRatio - cam.up;\n    \n    cam.right *= 2.0 * aspectRatio;\n    cam.up *= 2.0;\n}\n\nconst float SPHERE_REFLECT = 1.0;\nconst float SPHERE_REFRACT = 1.0;\n\nconst vec3 SKY_COLOR_0 = vec3( 0.5, 0.5, 0.5 );// * 0.5;\nconst vec3 SKY_COLOR_1 = vec3( 0.3, 0.3, 1.0 );\n\nconst float IOR = 0.75; // index of refraction\n\nconst int SPHERE_COUNT = 14;\n\nconst float C0 = 0.2;\nconst float C1 = 1.0;\nconst float Avg = (C0 + C1) * 0.5;\n\nconst vec3[SPHERE_COUNT] SPHERE_COLORS = vec3[SPHERE_COUNT](\n    vec3( C1, C0, C1 ),\n    vec3( C0, C0, C1 ),\n    vec3( C0, C1, C1 ),\n    vec3( C0, C1, C0 ),\n    vec3( C1, C1, C0 ),\n    vec3( C1, Avg, C0 ),\n    vec3( C1, C0, C0 ) ,\n        vec3( C1, C0, C1 ),\n    vec3( C0, C0, C1 ),\n    vec3( C0, C1, C1 ),\n    vec3( C0, C1, C0 ),\n    vec3( C1, C1, C0 ),\n    vec3( C1, Avg, C0 ),\n    vec3( C1, C0, C0 )\n);\n\nconst float SPHERE_HEIGHT = -8.0;\nconst float SPHERE_CIRCLE_RADIUS = 10.0;\n\nconst float SPHERE_RADIUS = 2.0;\nconst float SPHERE_RADIUS_SQR = SPHERE_RADIUS * SPHERE_RADIUS;\n\nconst float DIST_PER_SPHERE = 2.2;\n\nbool TestSphere( in vec3 relStart, in vec3 dir, out float t, out vec3 normal )\n{\n\tfloat a = dot( dir, dir );\n    float b = dot( relStart, dir );\n    float c = dot( relStart, relStart ) - SPHERE_RADIUS_SQR;\n    \n    float discriminant = b * b - a * c;\n    if ( discriminant <= 0.0f )\n        return false; // ray missed sphere\n    \n    float sqrtDiscriminant = sqrt( discriminant );\n    t = (-b - sqrtDiscriminant);\n    \n    if ( t < 0.0 )\n        return false;\n\n    t /= a;\n\n    vec3 relHitPos = relStart + t * dir;\n    normal = relHitPos / SPHERE_RADIUS;\n\n    return true;\n}\n\nvec3 GetSpherePos( int i )\n{\n    //float sphereIndexFrac = float( i ) / float( SPHERE_COUNT );\n    //  + 0.02 * sin( sphereIndexFrac * 4.0 * PI + iTime * 10.0 )\n    float theta = (float( i ) ) * (2.0 * PI / float( SPHERE_COUNT ));\n    theta += iTime * 0.05;\n\n    //float dist = float( i - SPHERE_COUNT / 2 ) * DIST_PER_SPHERE;\n    //float theta\n    vec3 spherePos = vec3( cos( theta ) * SPHERE_CIRCLE_RADIUS, sin( theta ) * SPHERE_CIRCLE_RADIUS, SPHERE_HEIGHT );\n\n    return spherePos;\n}\n\nfloat GetSphereGlow( int i )\n{\n    float frac = float( i ) / float( SPHERE_COUNT );\n    frac -= iTime * 0.05;\n    frac = abs( fract( frac ) - 0.5 ) * 2.0;\n    return 1.0 / (1.0 + frac * frac * 30.0);\n}\n\nvec3 GetSphereSurfaceColor( int sphereIndex, vec3 pos, vec3 dir, vec3 normal )\n{\n    float glow = GetSphereGlow( sphereIndex );\n    glow = glow * mix( 0.1, 1.0, pow( -dot( dir, normal ), 10.0 ) );\n    vec3 baseColor = SPHERE_COLORS[sphereIndex] * glow;\n    return tanh( baseColor * 6.0 ); // scale up but only reach 1.0 asymptotically\n}\n\nvec3 BackgroundColorForRay( vec3 start, vec3 dir, bool secondaryRay )\n{\n    // intersect with background box\n    vec3 bgBoxRelStart = start - BG_BOX_CENTER;\n    bvec3 dirPositive = greaterThan( dir, vec3( 0 ) );\n    vec3 bounds = mix( vec3( -BG_BOX_SCALE ), vec3( BG_BOX_SCALE ), dirPositive );\n    vec3 t3 = (bounds - bgBoxRelStart) / dir;\n\n    float t = min( min( t3.x, t3.y ), t3.z );\n    vec3 bgPos = start + dir * t;\n\n    vec3 bgColor;\n    \n    bgColor = textureLod( iChannel0, bgPos.yzx, 0.0 ).xyz;\n    \n    vec3 bgLight = vec3( 0.0 );\n    float bgOverheadLight = 1.0;\n\n    if ( dir.z < 0.0 && t == t3.z )\n    {\n        // hit floor.\n        \n        //float rotate = 2.0 / (1.0 + dot( bgPos.xy, bgPos.xy ) * 0.02);\n        //vec2 sincos = vec2( cos( rotate ), sin( rotate ) );\n        //bgPos.xy = bgPos.xx * sincos + bgPos.yy * vec2( -sincos.y, sincos.x );\n        \n        for ( int i = 0; i < SPHERE_COUNT; i++ )\n        {\n            vec3 spherePos = GetSpherePos( i );\n            vec2 offset = bgPos.xy - spherePos.xy;\n            \n            float colorDist = dot( offset, offset ) / SPHERE_RADIUS_SQR;\n            float colorFrac = 1.0 / (1.0 + colorDist);\n            //colorFrac = pow( colorFrac, 1.0 );\n            \n            /*offset.y *= 0.25;\n            \n            float dist = dot( offset, offset ) / SPHERE_RADIUS_SQR;\n            float lightFrac = 1.0 - 1.0 / (1.0 + dist);\n            lightFrac = pow( lightFrac, 0.5 );\n            \n            float unshadowedAmount = min( lightFrac, 1.0 );*/\n\n            float glow = GetSphereGlow( i );\n            bgLight += SPHERE_COLORS[i] * colorFrac * glow * 2.0;\n            //bgOverheadLight *= unshadowedAmount;\n        }\n    }\n    \n    if ( secondaryRay )\n    {\n        bgColor = pow( bgColor * 1.3, vec3( 3.0 ) );\n\t    bgOverheadLight *= smoothstep( GROUND_PLANE_HEIGHT, 100.0, bgPos.z );\n    }\n    else\n    {\n        bgOverheadLight = 0.0;\n    }\n\n    bgColor *= vec3( bgOverheadLight ) + bgLight;\n    \n    return bgColor;\n}\n\nvoid TestSpheres( vec3 start, vec3 dir, out int hitIndex, out float t, out vec3 normal )\n{\n    hitIndex = -1;\n\n    t = 999999999.0;\n\n    for ( int i = 0; i < SPHERE_COUNT; i++ )\n    {\n        float spheret;\n        vec3 sphereNormal;\n\n        vec3 spherePos = GetSpherePos( i );\n        vec3 relStart = start - spherePos;\n        if ( !TestSphere( relStart, dir, spheret, sphereNormal ) )\n            continue;\n\n        if ( spheret > t )\n            continue;\n\n        t = spheret;\n        normal = sphereNormal;\n        hitIndex = i;\n    }\n}\n\nvoid GetSphereRefractRay( inout vec3 start, inout vec3 dir, vec3 spherePos, vec3 normal )\n{\n    // 'start' should be the hit pos on the sphere\n    \n    dir = refract( dir, normal, IOR );\n    // continue through sphere\n    vec3 centerOffset = spherePos - start;\n    start += dir * dot( dir, centerOffset ) * 2.0;\n    normal = (spherePos - start) / SPHERE_RADIUS;\n    dir = refract( dir, normal, 1.0 / IOR );\n}\n\nfloat ReflectAmount( vec3 dir, vec3 normal )\n{\n    return 1.0; // pow( 1.0 + dot( dir, normal ), 2.0 ) * 2.0;\n}\n\nvec3 ColorForSecondaryRay( vec3 start, vec3 dir )\n{\n    int hitIndex;\n    float t;\n    vec3 normal;\n    TestSpheres( start, dir, hitIndex, t, normal );\n\n    if ( hitIndex < 0 )\n        return BackgroundColorForRay( start, dir, true );\n    \n    start += dir * t;\n\n    vec3 surfaceColor = GetSphereSurfaceColor( hitIndex, start, dir, normal );\n\n    vec3 spherePos = GetSpherePos( hitIndex );\n\n    vec3 reflectDir = reflect( dir, normal );\n    vec3 reflectColor = BackgroundColorForRay( start, reflectDir, true );\n    reflectColor *= SPHERE_REFLECT * SPHERE_COLORS[hitIndex] * ReflectAmount( dir, normal );\n    \n    GetSphereRefractRay( start, dir, spherePos, normal );\n    vec3 refractColor = BackgroundColorForRay( start, reflectDir, true );\n    refractColor *= SPHERE_REFRACT * SPHERE_COLORS[hitIndex];\n    \n    return surfaceColor + reflectColor + refractColor;\n}\n\nvec3 ColorForInitialRay( vec3 start, vec3 dir )\n{\n    int hitIndex;\n    float t;\n    vec3 normal;\n    TestSpheres( start, dir, hitIndex, t, normal );\n\n    if ( hitIndex < 0 )\n    \treturn BackgroundColorForRay( start, dir, false );\n\n    start += dir * t;\n\n    vec3 surfaceColor = GetSphereSurfaceColor( hitIndex, start, dir, normal );\n    \n    vec3 spherePos = GetSpherePos( hitIndex );\n\n    vec3 reflectDir = reflect( dir, normal );\n    vec3 reflectColor = ColorForSecondaryRay( start, reflectDir );\n    reflectColor *= SPHERE_REFLECT * SPHERE_COLORS[hitIndex] * ReflectAmount( dir, normal );\n    \n    GetSphereRefractRay( start, dir, spherePos, normal );\n    vec3 refractColor = ColorForSecondaryRay( start, dir );\n    refractColor *= SPHERE_REFRACT * SPHERE_COLORS[hitIndex];\n    \n    return surfaceColor + reflectColor + refractColor;\n}\n\n/* 5 queens AA sampling:\n_____________\n|       .   |\n| .         |\n|     .     |\n|         . |\n|   .       |\n|___________|\n*/\nconst int AA_SAMPLE_COUNT = 5;\nconst vec2[AA_SAMPLE_COUNT] AA_SAMPLE_OFFSETS = vec2[AA_SAMPLE_COUNT] (\n    vec2( -0.4,  0.2 ),\n    vec2( -0.2, -0.4 ),\n    vec2(  0.0,  0.0 ),\n    vec2(  0.2,  0.4 ),\n    vec2(  0.4, -0.2 )\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    CameraInfo cam;\n    GetCameraInfo( iMouse.xy, iResolution.xy, cam );\n    \n    vec3 pixelColor = vec3( 0, 0, 0 );\n    for ( int aa = 0; aa < AA_SAMPLE_COUNT; aa++ )\n    {\n        vec2 uv = (fragCoord + AA_SAMPLE_OFFSETS[aa]) / iResolution.xy;\n        vec3 dir = normalize( cam.bottomLeft + cam.right * uv.x + cam.up * uv.y );\n\n        vec3 sampleColor = ColorForInitialRay( cam.origin, dir );\n        pixelColor += min( sampleColor, 1.0 );\n    }\n    \n    pixelColor /= float( AA_SAMPLE_COUNT );\n    \n    // Output to screen\n    fragColor = vec4(pixelColor,1.0);\n}\n","name":"Image","description":"","type":"image"}]}