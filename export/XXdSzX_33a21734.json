{"ver":"0.1","info":{"id":"XXdSzX","date":"1719734022","viewed":33,"name":"3D Julia Set - Quaternions","username":"Plastic","description":"Julia set computed using quaternion math and rendered with raymarching, use the mouse to change the offset.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["adasdasdasd"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"struct ray\n{\n    vec3 ro;\n    vec3 rd;\n};\n\nconst float pi = 3.141519;\n\nfloat cube(vec3 p, vec3 o, float l)\n{\n    return length(max(abs(p-o)-l, .0));\n}\n\nfloat plane(vec3 p, float a)\n{   \n    return p.y - a;\n}\n\nmat3 rot(float r, float t, float s)\n{\n    mat3 roty = mat3(\n        cos(r), .0, sin(r),\n        .0, 1., .0,\n        -sin(r), .0, cos(r)\n    );\n\n    mat3 rotx = mat3(\n        1., .0, .0,\n        .0, cos(t), sin(t),\n        .0, -sin(t), cos(t)\n    );\n    \n    mat3 rotz = mat3(\n        cos(s), sin(s), .0,\n        -sin(s), cos(s), .0,\n        .0, .0, 1.\n    );\n    \n    return rotx*roty*rotz;\n}\n\nvec4 complexSquare(vec4 q)\n{\n    return vec4(q.x*q.x-q.y*q.y-q.z*q.z-q.w*q.w,\n                2.*q.x*q.y,\n                2.*q.x*q.z,\n                2.*q.x*q.w);\n}\n\nvec4 complexAdd(vec4 qa, vec4 qb)\n{\n   return vec4(qa.x+qb.x, qa.y+qb.y, qa.z+qb.z, qa.w+qb.w); \n}\n\nvec4 complexConj(vec4 q)\n{\n    return vec4(-q.x, -q.y, -q.z, q.w);\n}\n\nvec4 complexMult(vec4 a, vec4 b)\n{\n    return vec4(\n        a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z, \n        a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y, \n        a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x, \n        a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w\n    );\n}\n\nvec3 symetric(vec3 p, vec3 n)\n{\n    float choice = sign(dot(p, n));\n    vec3 sym = p + ((-(dot(n, p)))/(length(n)*length(n))) * n;\n    return choice > .0 ? 2.*sym-p : p;\n\n}\n\nvec2 toRender(vec3 p)\n{\n    vec2 off = iMouse.xy/iResolution.xy;\n    //vec3 temp = vec3(0.4+off.x, 0.3, 0.2+off.y);\n    vec3 temp = vec3(off.x, off.y, 0.1);\n    int iterations = 20;\n    \n    vec3 Q = p;\n    float dz = 1.0;\n    float dist = 1.0;\n    \n    for(int n = 0; n<iterations; n++)\n    {\n        \n        vec4 ident = vec4(vec3(Q), 1.);\n        dz = 2.0 * length(Q) * dz;\n        \n        Q = complexAdd(complexSquare(ident), vec4(vec3(temp), 1.)).xyz;\n        \n        float lengthSq = dot(Q, Q);\n       \n        if(lengthSq > 4.)\n        {\n            dist = 0.5 * lengthSq * log(lengthSq) / dz;\n            break;\n        }\n        \n    }\n    \n    return vec2(dist, .0);\n}\n\nvec3 calcNormal(vec3 p)\n{\n    vec2 ep = vec2(0.01, .0);\n    vec3 n = normalize(vec3(\n        toRender(p + ep.xyy).x - toRender(p - ep.xyy).x,\n        toRender(p + ep.yxy).x - toRender(p - ep.yxy).x,\n        toRender(p + ep.yyx).x - toRender(p - ep.yyx).x\n    ));\n    \n    return n;\n}\n\nvec3 rayMarch(ray r)\n{\n    const int iter = 500;\n    const float maxdist = 4.;\n    float travel = .0;\n    float hist = 2e10;\n    \n    vec3 light = normalize(vec3(2., 2., 2.));\n    \n    for(int i = 0; i < iter; i++)\n    {\n        vec3 currentpos = r.ro + r.rd * travel;\n        \n        vec2 scene = toRender(currentpos);\n        \n        if(scene.x < 0.02)\n        {\n            vec3 n = calcNormal(currentpos);\n            vec3 na = max(n,0.1);\n            vec3 viewdir = r.rd;\n            vec3 col = vec3(0.616,0.725,0.725)*na.x + vec3(0.392,0.286,0.671)*na.y + vec3(0.345,0.055,0.333)*na.z;\n            vec3 halfway = (light-reflect(viewdir, n))/length(light-reflect(viewdir, n));\n         \n            //float ao = (float(i)/float(iter));\n            \n            return (col)*texture(iChannel0, reflect(r.rd, n)).rgb*max(dot(n, light), 0.4)+pow(max(dot(halfway, light), 0.2), 50.)*0.3;\n            \n            \n            //return calcNormal(currentpos);\n            //return vec3(1.)*scene.y;\n        }\n        if(travel > maxdist)\n        {\n            break;\n        }\n        \n        if(scene.x < hist)\n        {\n            hist = scene.x;\n        }\n        \n        travel += scene.x/40.;\n        //travel += 0.01;\n    }\n    \n    return texture(iChannel0, r.rd).rgb;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy) * 2. - 1.;\\\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float circ = 1.8;\n    \n    ray camera;\n    camera.ro = vec3(cos(iTime*0.7)*circ, 0.7, sin(iTime*0.7)*circ);\n    //camera.ro = vec3(.0, 1.5, -6.);\n    camera.rd = normalize(vec3(uv.x, uv.y, 1.))*rot(-iTime*0.7-pi/2., -0.4, .0);\n    \n    vec3 final = rayMarch(camera);\n\n    // Output to screen\n    fragColor = vec4(final,1.0);\n}","name":"Image","description":"","type":"image"}]}