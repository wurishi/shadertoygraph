{"ver":"0.1","info":{"id":"7s33Rn","date":"1675459492","viewed":62,"name":"Noise+Rays","username":"SteelFlame","description":"1","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["1"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dstToSurface(vec3 point, float noiseAtPoint) {\n    float noise = noiseAtPoint;\n    noise += 1.;\n    noise /= 2.;\n    return point.y+noise;\n}\nfloat dstToSphere(vec3 point, vec3 sphPos) {\n    return length(sphPos-point);\n}\n\n// NOISE\n\nint otavesCount = 2;\nfloat frequency = 2., persistance = 1.;\n\n// Worlds Params\n\nvec3 sunDir = vec3(0.,1.,0.2);\nvec3 camPos = vec3(0.,0.,0.);\nfloat maxStep = .02, maxError = 0.1;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sunDir = normalize(sunDir);\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    uv *= 2.;\n    camPos.x += iTime * .5;\n        \n    vec3 viewDir = normalize(vec3(uv.xy,1.));\n    \n    vec3 point = camPos;\n    for (int i = 0; i < 128*2; i++) {\n        point += viewDir * maxStep;\n        point = multOnMatrix3d(point,vec3[3](vec3(1.,0.,0.),vec3(0.,1.,0.),vec3(0.,0.,1.)));\n        float noise = fbm(point.xz,frequency,1.,otavesCount,persistance);\n        float dst = dstToSurface(point, noise);\n        if (dst < maxError) {\n            float noiseX = fbm(point.xz-vec2(0.01,0.),frequency,1.,otavesCount,persistance); // For shadows\n            float noiseY = fbm(point.xz-vec2(0.,0.01),frequency,1.,otavesCount,persistance); // For shadows\n            \n            vec3 normal = normalize(vec3(noise-noiseX, .1, noise-noiseY));\n            vec3 dir = reflect((point-camPos), normal);\n            \n            fragColor = vec4(1./(float(i)*maxStep)*dot(dir,sunDir)); // \n            //fragColor = vec4(1./(float(i)*maxStep)*normal.y);\n            return;\n        }\n    }\n\n    fragColor = vec4(0.);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"float smoothh(float x) {\n    return x*x*x*(x*(x*6.0-15.0)+10.0);\n    return -2.0*x*x*x+3.0*x*x;\n}\nfloat lerp1d(float a, float b, float t) {\n    return a+(b-a)*t;\n}\nvec2 lerp(vec2 a, vec2 b, float t) {\n    return a+(b-a)*t;\n}\nfloat clamp01(float x) {\n    if (x>1.0) return 1.0;\n    if (x<0.0) return 0.0;\n    return x;\n}\nfloat frac(float x) {\n    return x-floor(x);\n}\nfloat random(vec2 uv) {\n    return frac(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\nvec2 getVector(vec2 x) {\n    return normalize(vec2(-1.0+random(x)*2.0,-1.0+random(x*100.0)*2.0));\n    int index = int(round(random(x)*3.0));\n    switch (index) {\n        case 0:\n            return vec2(1,0);\n        case 1:\n            return vec2(0,1);\n        case 2:\n            return vec2(-1,0);\n        case 3:\n            return vec2(0,-1);\n    }\n}\nfloat noise(vec2 x) {\n    vec2 xInEdge = floor(x);\n    vec2 localX = vec2(frac(x.x),frac(x.y));\n    \n    vec2 leftTopSide = vec2(xInEdge+vec2(0,0));\n    vec2 rightTopSide = vec2(xInEdge+vec2(1,0));\n    vec2 leftBottomSide = vec2(xInEdge+vec2(0,1));\n    vec2 rightBottomSide = vec2(xInEdge+vec2(1,1));\n    \n    vec2 leftTopVector = getVector(leftTopSide);\n    vec2 rightTopVector = getVector(rightTopSide);\n    vec2 leftBottomVector = getVector(leftBottomSide);\n    vec2 rightBottomVector = getVector(rightBottomSide);\n    \n    vec2 dirToLeftTop = x-leftTopSide;\n    vec2 dirToRightTop = x-rightTopSide;\n    vec2 dirToLeftBottom = x-leftBottomSide;\n    vec2 dirToRightBottom = x-rightBottomSide;\n    \n    float dot1 = dot(dirToLeftTop,(leftTopVector));\n    float dot2 = dot(dirToRightTop,(rightTopVector));\n    float dot3 = dot(dirToLeftBottom,(leftBottomVector));\n    float dot4 = dot(dirToRightBottom,(rightBottomVector));\n    \n    localX.x = smoothh(localX.x);\n    localX.y = smoothh(localX.y);\n    \n    return lerp1d(lerp1d(dot1,dot2,localX.x),lerp1d(dot3,dot4,localX.x),localX.y);\n}\n\nfloat fbm(vec2 uv, float startFrequency, float startIntensity, int octavesCount, float persistance) {\n    float freq = startFrequency;\n    float intens = startIntensity;\n    float v = 0.;\n    for (int i = 0; i < octavesCount; i++) {\n        v += noise(uv*freq)*intens;\n        freq *= 2.;\n        intens *= persistance;\n    }\n    return v/float(octavesCount);\n}\n\nvec2 multOnMatrix2d(vec2 v, vec2 m[2]) {\n    return v.x*m[0]+v.y*m[1];\n}\n// i j k\nvec3 multOnMatrix3d(vec3 v, vec3 m[3]) {\n    return v.x*m[0]+v.y*m[1]+v.z*m[2];\n}","name":"Common","description":"","type":"common"}]}