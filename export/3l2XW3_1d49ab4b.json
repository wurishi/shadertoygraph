{"ver":"0.1","info":{"id":"3l2XW3","date":"1585840967","viewed":85,"name":"template: raymarching","username":"takumifukasawa","description":"[Frequently updated]\n- directional light, point light, ambient light\n- AO\n- distance fog\n- softshadow","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["template"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define EPS .0001\n#define NORMAL_EPS .0001\n#define PI 3.14159265359\n#define PI2 PI * 2.\n\n#define MAT_SPHERE 1.\n#define MAT_BOX 2.\n#define MAT_FLOOR 3.\n\n#define saturate(a) clamp(a, 0., 1.)\n#define repeat(a, b) mod(a, b) - b * .5 \n\nprecision highp float;\n\nstruct Light {\n\tvec3 position;\n  \tfloat intensity;\n  \tvec3 color;\n  \tvec3 diffuse;\n  \tvec3 specular;\n  \tfloat attenuation;\n};\n    \nstruct Surface {\n  \tfloat depth;\n  \tvec3 position;\n  \tvec3 baseColor;\n    vec3 specularColor;\n    float specularPower;\n  \tvec3 normal;\n  \tvec3 emissiveColor;\n  \tfloat material;\n};\n\nconst float stopThreshold = .001;\nconst int maxShadowIterations = 32;\n\nvec3 glow = vec3(0.);\n\n//---------------------------------------------------------------------------------------------\n// utils\n//---------------------------------------------------------------------------------------------\n\n// ref: https://www.shadertoy.com/view/ldlcRf\nvec2 minMat(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nbool checkMat(float material, float check) {\n\treturn material < (check + .5);\n}\n\nmat3 camera(vec3 o, vec3 t) {\n\tvec3 forward = normalize(t - o);\n    vec3 right = cross(forward, vec3(0., 1., 0.));\n    vec3 up = cross(right, forward);\n    return mat3(right, up, forward);\n}\n\nmat2 rot2(float t) {\n    return mat2(cos(t), -sin(t), sin(t), cos(t));\n}\n\n//---------------------------------------------------------------------------------------------\n// sdf\n//---------------------------------------------------------------------------------------------\n\n// ra: radius\n// rb: round\n// h: height\nfloat sdRoundedCylinder(vec3 p, float ra, float rb, float h) {\n    vec2 d = vec2(length(p.xz) - 2. * ra + rb, abs(p.y) - h);\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rb;\n}\n\n// a: begin pos\n// b: begin thin\n// ra: end pos\n// rb: end thin\nfloat sdStick(in vec3 p, vec3 a, vec3 b, float ra, float rb) {\n\tvec3 ba = b - a;\n    vec3 pa = p - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    float r = mix(ra, rb, h);\n\treturn length(pa - h * ba) - r;\n}\n\nfloat sdElipsoid(in vec3 pos, vec3 rad) {\n\tfloat k0 = length(pos / rad);\n\tfloat k1 = length(pos / rad / rad);\n\treturn k0 * (k0 - 1.) / k1;\n}\n\nfloat sdPlane(vec3 p, vec4 n) {\n  return dot(p, n.xyz) + n.w;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 d = abs(p) - b;\n  return min(max(d.x, max(d.y, d.z)), 0.) + length(max(d, 0.));\n}\n\nfloat smin(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn min(a, b) - h * h / (k * 4.);\n}\n\nfloat smax(in float a, in float b, float k) {\n    float h = max(k - abs(a - b), 0.);\n\treturn max(a, b) + h * h / (k * 4.);\n}\n\n//---------------------------------------------------------------------------------------------\n// raymarch\n//---------------------------------------------------------------------------------------------\n\nvec2 scene(vec3 p) {\n    // dummy float max and min\n    vec2 res = vec2(10000., -10000.);\n    float d = 0.;\n\n    {\n\t\tfloat pl = sdPlane(p - vec3(0., 2., 0.), vec4(0., 1., 0., 2.));\n        res = minMat(res, vec2(pl, MAT_FLOOR));\n    }\n    {\n\t    float s1 = sdElipsoid(p - vec3(0., .8, 0.), vec3(.5));        \n        res = minMat(res, vec2(s1, MAT_SPHERE));\n    }\n    {\n\t\tfloat b1 = sdBox(p - vec3(1., .25, 0.), vec3(.2, .5, .2));\n        res = minMat(res, vec2(b1, MAT_BOX));\n    }\n    {\n\t\tfloat b2 = sdBox(p - vec3(-1., .25, 0.), vec3(.2, .5, .2));\n        res = minMat(res, vec2(b2, MAT_BOX));\n    }\n\n    return res;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(NORMAL_EPS, 0);\n    return normalize(\n    \tvec3(\n            scene(p + e.xyy).x - scene(p - e.xyy).x,\n            scene(p + e.yxy).x - scene(p - e.yxy).x,\n            scene(p + e.yyx).x - scene(p - e.yyx).x\n        )\n    );\n}\n\nvec2 raymarch(vec3 ro, vec3 rd) {\n\tfloat tmin = .01;\n    float tmax = 80.;\n    float m = -1.;\n    float t = tmin;\n    for(int i = 0; i < 99; i++) {\n\t\tvec3 pos = ro + rd * t;\n        vec2 h = scene(pos);\n        m = h.y;\n        if(abs(h.x) < (stopThreshold * t)) break;\n        t += h.x;\n        if(t > tmax) break;\n    }\n    if(t > tmax) m = -1.;\n    return vec2(t, m);\n}\n\n//---------------------------------------------------------------------------------------------\n// shading\n//---------------------------------------------------------------------------------------------\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax, float power) {\n  float res = 1.;\n  float t = mint;\n  float ph = 1e10;\n  for(int i = 0; i < maxShadowIterations; i++) {\n    float h = scene(ro + rd * t).x;\n\n    // pattern 1\n    // res = min(res, power * h / t);\n\n    // pattern 2\n    float y = h * h / (2. * ph);\n    float d = sqrt(h * h - y * y);\n    res = min(res, power * d / max(0., t - y));\n    ph = h;\n\n    t += h;\n\n    float e = EPS;\n    if(res < e || t > tmax) break;\n  }\n  return clamp(res, 0., 1.);\n}\n \n\nfloat getSpecular(Surface surface, vec3 lightDir, float diffuse, vec3 cameraPos) {\n  \t//vec3 lightDir = light.position - surface.position;\n  \tvec3 ref = reflect(-normalize(lightDir), surface.normal);\n  \tfloat specular = 0.;\n  \tif(diffuse > 0.) {\n    \tspecular = max(0., dot(ref, normalize(cameraPos - surface.normal)));\n    \tfloat specularPower = surface.specularPower;\n    \tspecular = pow(specular, specularPower);\n  \t}\n  \treturn specular;\n}\n\nvoid calcDirectionalLight(inout Light light, Surface surface, vec3 cameraPos) {\n    light.position = normalize(light.position);\n    light.attenuation = 1.;\n    \n    // diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, normalize(light.position)));\n  \tvec3 diffuse = diffuseCoef * light.attenuation * light.color * light.intensity;\n  \t// specular\n  \tfloat specularCoef = getSpecular(\n        //light,\n        surface,\n        light.position,\n        diffuseCoef,\n        cameraPos\n    );\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity);  \n\n  \tlight.diffuse = diffuse * softShadow(surface.position, normalize(light.position), .1, 10., 10.);\n    light.specular = specular;\n}\n\nvoid calcPointLight(inout Light light, Surface surface, vec3 cameraPos) {\n  \tfloat d = distance(light.position, surface.position);\n  \tvec3 k = vec3(.06, .08, .09);\n  \tlight.attenuation = 1. / (k.x + (k.y * d) + (k.z * d * d));\n\n  \t// point light\n  \tvec3 lightDir = normalize(light.position - surface.position);\n  \t// diffuse\n  \tfloat diffuseCoef = max(0., dot(surface.normal, lightDir));\n  \tvec3 diffuse = diffuseCoef * light.color * light.intensity * light.attenuation;\n  \t// specular\n  \tfloat specularCoef = getSpecular(\n        surface,\n        lightDir,\n        diffuseCoef,\n        cameraPos\n    );\n  \tvec3 specular = vec3(specularCoef * light.attenuation * light.color * light.intensity); \n    \n  \tlight.diffuse = diffuse * softShadow(surface.position, normalize(light.position), .1, 10., 10.);\n  \tlight.specular = specular;\n}\n\nfloat ambientOcculusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.;\n    float sca = 1.;\n    for(int i = 0; i < 5; i++) {\n    \tfloat h = .01 + .11 * float(i) / 4.;\n        vec3 opos = pos + h * nor;\n        float d = scene(opos).x;\n        occ += (h - d) * sca;\n        sca *= .95;\n    }\n    return clamp(1. - 2. * occ, 0., 1.);\n}\n\nvec3 fog(vec3 color, float dist, vec3 fogColor, float b) {\n  float fogAmount = 1. - exp(-dist * b);\n  return mix(color, fogColor, fogAmount);\n}\n\nvec3 lighting(Surface surface, vec3 cameraPos, vec3 cameraDir) {\n  \tvec3 position = surface.position;\n\n  \tvec3 color = vec3(0.);\n  \tvec3 normal = surface.normal;\n\n  \tLight directionalLight;\n  \tdirectionalLight.position = vec3(.5, 1., .5);\n  \tdirectionalLight.intensity = .7;\n  \tdirectionalLight.color = vec3(1., 1., 1.);\n  \tcalcDirectionalLight(directionalLight, surface, cameraPos);\n    \n  \tLight pointLight;\n  \tpointLight.position = vec3(sin(iTime) * 2., 2., 1.);\n  \tpointLight.intensity = .3;\n  \tpointLight.color = vec3(1., 1., 1.);\n  \tcalcPointLight(pointLight, surface, cameraPos);\n    \n  \tvec3 diffuse = directionalLight.diffuse + pointLight.diffuse;\n  \tvec3 specular = directionalLight.specular + pointLight.specular;\n    \n    // calc ambient\n\tfloat occ = ambientOcculusion(surface.position, surface.normal);\n  \tfloat amb = clamp(.5 + .5 * surface.normal.y, 0., 1.);\n  \tvec3 ambient = surface.baseColor * amb * occ * vec3(0., .08, .1);  \n    \n  \tcolor =\n        surface.emissiveColor +\n        surface.baseColor * diffuse +\n        surface.specularColor * specular +\n        ambient;  \n  \n  \treturn color;\n}\n\n//---------------------------------------------------------------------------------------------\n// main\n//---------------------------------------------------------------------------------------------\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = (fragCoord.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n\tvec2 mouse = (iMouse.xy - iResolution.xy * .5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(mouse * 3., 4.)  + vec3(0., 3., 0.);\n    vec3 target = vec3(0., .5, 0.);\n    float fov = 1.5;\n    \n    vec3 rd = camera(ro, target) * normalize(vec3(uv, fov));\n    \n\tvec2 result = raymarch(ro, rd);\n\tvec3 color = vec3(0.);\n    \n    if(result.y > 0.) {\n\t    float depth = result.x;\n    \tfloat material = result.y;    \n   \n    \tvec3 position = ro + rd * depth;\n    \tvec3 normal = getNormal(position);\n\n\t    Surface surface;\n    \tsurface.depth = depth;\n    \tsurface.position = position;\n    \tsurface.normal = normal;\n    \tsurface.material = result.y;       \n        \n    \tvec3 objColor = vec3(0.);\n\n        if(checkMat(material, MAT_SPHERE)) {\n        \tsurface.baseColor = vec3(1., .1, .1);\n            surface.specularColor = vec3(1.);\n        \tsurface.specularPower = 16.;\n        } else if(checkMat(material, MAT_BOX)) {\n        \tsurface.baseColor = vec3(.1, .1, 1.);\n            surface.specularColor = vec3(1.);\n        \tsurface.specularPower = 32.;\n        } else if(checkMat(material, MAT_FLOOR)) {\n        \tsurface.baseColor = vec3(.1, 1., .1);\n            surface.specularColor = vec3(1.);\n        \tsurface.specularPower = 64.;\n        }\n        \n\t\tcolor = lighting(surface, ro, rd);\n    }\n\n    // fog\n    color = fog(color, result.x, vec3(.02, .02, .04), .08);    \n\n    // gamma\n    color = pow(saturate(color), vec3(.4545));\n    \n    \n    fragColor = vec4(color, 1.);\n}","name":"Image","description":"","type":"image"}]}