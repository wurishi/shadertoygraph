{"ver":"0.1","info":{"id":"ds3BzH","date":"1696851668","viewed":44,"name":"Polygon(s)","username":"crewce","description":"filled polygon(s)","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["polygon","wire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265\n\n// https://www.shadertoy.com/view/4ljfRD\nfloat drawLine(vec2 p1, vec2 p2, vec2 uv, float thickness)\n{\n    float r = 0.;\n    float thickness_px = thickness / iResolution.x; //not really one px\n    \n    // get dist between points\n    float d = distance(p1, p2);\n    \n    // get dist between current pixel and p1\n    float duv = distance(p1, uv);\n\n    //if point is on line, according to dist, it should match current uv \n   \n    vec2 p12 = mix(p1, p2, clamp(duv/d, 0.0, 1.0));\n    r = 1.-floor(1. - thickness_px + distance(p12, uv));    \n    \n    return r;\n}\n\nfloat drawLine2(vec2 p1, vec2 p2, vec2 uv, float thickness) {\n    float thickness_px = thickness / iResolution.x;\n    vec2 pa = uv - p1;\n\tvec2 ba = p2 - p1;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n\treturn 1.0 - step(thickness_px, length(pa - ba*h));\n}\n\nvec2 vector(vec2 origin, float part, float size) {\n    float angle = part * 2.0 * PI + PI * 0.5;\n    return origin + vec2(cos(angle), sin(angle)) * size;\n}\n\n// https://stackoverflow.com/questions/3838329/how-can-i-check-if-two-segments-intersect\nbool ccw(vec2 A, vec2 B, vec2 C) {\n    return (C.y-A.y) * (B.x-A.x) > (B.y-A.y) * (C.x-A.x);\n}\n\n// Return true if line segments AB and CD (where D is right of C) intersect\nbool intersect(vec2 A, vec2 B, vec2 C) {\n    vec2 D = vec2(10.0, C.y);    \n    return ccw(C,D,A) != ccw(C,D,B) && ccw(A,B,C) != ccw(A,B,D);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const float size = 0.35;\n    const float rows = 3.0;\n    \n    vec2 uv = fragCoord.xy / iResolution.y;\n    vec2 center = vec2(0.0, 0.0);\n    \n    float xval = iResolution.x/iResolution.y * rows;\n    float cells = floor(xval);\n    uv *= rows;\n    uv.x = max(min(uv.x - fract(xval) * 0.5, cells), 0.0); // u.x should go from [0, some_integer] and centered\n    \n    vec2 idv = floor(uv);\n    float id = idv.x + idv.y * cells;\n    int n = int(id) + 3;\n    uv = fract(uv) - vec2(0.5);\n    \n    float t = iTime*0.3*min(id + 0.5, 8.0);\n    // uv += vec2(cos(t), sin(t)) * 0.1;\n    uv = uv * mat2(cos(t), sin(t), -sin(t), cos(t));\n    \n    \n    int cntIntersections = 0; // point is inside polygon if there is only one intersection    \n    vec2 initPos = vector(center, 0.0, size); \n    vec2 prev = initPos;\n    float color = 0.0;\n    \n    for (int i = 1; i < n; i++) {\n        vec2 next = vector(center, float(i) / float(n), size);        \n        color += drawLine2(prev, next, uv, min(6.0 + id, 60.0));\n        cntIntersections += int(intersect(prev, next, uv));\n        prev = next;\n    }\n    \n    color += drawLine2(prev, initPos, uv, min(6.0 + id, 60.0)); // from the last point to the first point\n    \n    cntIntersections += int(intersect(prev, initPos, uv));\n    float fillColor = float(cntIntersections & 1) * 1.0;\n    \n    fragColor = vec4(fillColor, 0.0, color, 1.);\n}","name":"Image","description":"","type":"image"}]}