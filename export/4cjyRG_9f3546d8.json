{"ver":"0.1","info":{"id":"4cjyRG","date":"1722513854","viewed":57,"name":"TTEH","username":"CuriosityWang","description":"TTEH","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Author: Wang Xin\n// Email: lightwxz@foxmail.com\n\n#define MAXSTEP 100\n#define MAXDISTSNCE 100.\n#define MINDISTSNCE .01\n#define PRESION .002\nconst float EPSILON = 0.005;\n\n\nfloat random(in vec3 _st) {\n    return fract(sin(dot(_st.xyz, vec3(12.9898, 78.233, 37.719))) * 43758.5453123);\n}\n\nfloat noise(in vec3 _st) {\n    vec3 i = floor(_st);\n    vec3 f = fract(_st);\n\n    float a = random(i);\n    float b = random(i + vec3(1.0, 0.0, 0.0));\n    float c = random(i + vec3(0.0, 1.0, 0.0));\n    float d = random(i + vec3(1.0, 1.0, 0.0));\n    float e = random(i + vec3(0.0, 0.0, 1.0));\n    float f1 = random(i + vec3(1.0, 0.0, 1.0));\n    float g = random(i + vec3(0.0, 1.0, 1.0));\n    float h = random(i + vec3(1.0, 1.0, 1.0));\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n           (c - a) * u.y * (1.0 - u.x) +\n           (d - b) * u.x * u.y +\n           (e - a) * u.z * (1.0 - u.x) * (1.0 - u.y) +\n           (f1 - b) * u.z * u.x * (1.0 - u.y) +\n           (g - c) * u.z * u.y * (1.0 - u.x) +\n           (h - d) * u.z * u.x * u.y;\n}\n\n#define NUM_OCTAVES 5\n\nfloat fbm(in vec3 _st) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100.0);\n    mat3 rot = mat3(cos(0.5), sin(0.5), -sin(0.5),\n                    -sin(0.5), cos(0.5), 0.5,\n                    0.5, -0.5, cos(0.5));\n\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * noise(_st);\n        _st = rot * _st * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\nvec2 rotate(vec2 coord, float angle) {\n    float cosAngle = cos(angle);\n    float sinAngle = sin(angle);\n    vec2 rotated;\n    rotated.x = cosAngle * coord.x - sinAngle * coord.y;\n    rotated.y = sinAngle * coord.x + cosAngle * coord.y;\n    return rotated;\n}\n\n\nfloat sdBox(vec3 p, vec3 b){\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n}\n\n\nfloat SDFScene(vec3 p){\n\n    float noiseValue = fbm(p * 8. + iTime * .3)*.1;\n    p.xz = rotate(p.xz, -10.);\n    float sdPlane = p.y + 3.;\n\n    float sdBox0 = sdBox(p, vec3(1, 1, 1)); \n\n    p.y -= 0.8;\n    float width = 0.382;\n    float sdBox1 = sdBox(p, vec3(width, width, 1.2));\n    float sdBox2 = sdBox(p, vec3(1.2, width, width));\n\n    float tens = min(sdBox1, sdBox2);\n    return  max(sdBox0, -tens) + noiseValue;\n}\n\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1, 0) * EPSILON;\n    vec3 normal = SDFScene(p) - vec3(\n        SDFScene(p - e.xyy),\n        SDFScene(p - e.yxy),\n        SDFScene(p - e.yyx)\n    );\n\n    return normalize(normal);\n}\n\nfloat RayMarching(vec3 ro, vec3 rd){\n    \n    // RayMarching\n    float distance = 0.;\n    for(int i = 0; i < MAXSTEP; i++){\n        \n        vec3 p = ro + rd * distance;\n\n        float d = SDFScene(p);\n        distance += d;\n        \n        if(d < MINDISTSNCE || distance > MAXDISTSNCE){\n            break;\n        }\n    }\n    return distance;\n}\n\nvec3 calColor(vec3 p){\n\n    vec3 rayOrgin = vec3(0, 0, -5);\n    vec3 groundColo = vec3(.4, .85, .47);\n\n    vec3 leftBottom = vec3(-0.5, -0.5, -0.5);\n    vec3 rightTop = vec3(0.5, 0.5, 0.5);\n    vec3 green = vec3(0.78, 0.895, 0.282);\n    vec3 blue = vec3(0.164, 0.38, 0.92);\n\n    vec3 lightPos = vec3(9, 8, 2);\n    lightPos.xz = rotate(lightPos.xz, sin(iTime / 200.) * 180.);\n    vec3 lightDirection = normalize(lightPos - p);\n    vec3 normal = calcNormal(p);\n    vec3 viewDir = normalize(rayOrgin - p);\n    vec3 reflectDir = normalize(reflect(-lightDirection, normal));\n    float dif = clamp(dot(normal, lightDirection), 0., 1.);\n    float speclar = pow(max(dot(reflectDir, viewDir), 0.), 10.);\n\n    vec3 newRayOrigin = p + normal * PRESION;\n\n    vec3 col;\n    if(p.y < -1.){\n        // 漫反射加环境光 \n        col = .2 * groundColo + dif * groundColo;\n    }\n    else{\n        col = mix(green, blue, smoothstep(0., 1.7 , dot(p, leftBottom - rightTop)));\n        col += speclar * col;\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragcoord){\n\n    vec3 backgroundColor = vec3(0.835, 1, 1);\n\n    vec2 uv = (fragcoord * 2. - iResolution.xy) / iResolution.y;\n    vec2  m = (iMouse.xy * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialize Light\n    vec3 rayOrgin = vec3(0, 0, -2.3);\n    vec3 rayDirection = normalize(vec3(uv, 1));  // 可以修改UV范围实现修改fov角度\n    \n    // 根据鼠标x值的大小，绕着y轴旋转\n    rayOrgin.xz = rotate(rayOrgin.xz, -m.x);\n    rayDirection.xz = rotate(rayDirection.xz, -m.x);\n\n    rayOrgin.yz = rotate(rayOrgin.yz, -m.y);\n    rayDirection.yz = rotate(rayDirection.yz, -m.y);\n\n    float distance = RayMarching(rayOrgin, rayDirection);\n\n    vec3 p = rayOrgin + distance * rayDirection;\n\n    vec3 col;\n    if(distance > MAXDISTSNCE){\n    col = backgroundColor;\n    }\n    else{\n       col = calColor(p);\n    }\n\n    fragColor = vec4(col, 1);\n}","name":"Image","description":"","type":"image"}]}