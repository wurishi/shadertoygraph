{"ver":"0.1","info":{"id":"3tyfWc","date":"1615188351","viewed":97,"name":"NKoin","username":"inear_sthlm","description":"Coin test","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["basic"],"hasliked":0,"parentid":"ttVfWK","parentname":"coin"},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// The dX and dY when differentiating height values.\n#define diff .002\n// How fast the light moves.\n#define timeScale 1.5\n// The radius of the light's path.\n#define lightPathRadius .55\n// The center of the light's path.\n#define lightPathCenter vec3(.5, .5, .025)\n// Color of the light.\n#define lightColor vec4(vec3(0.3), 1.0)\n// Light strength multiplier.\n#define lightStrength 2.0\n// The implied Z position of the lit surface.\n#define surfaceZDepth -0.08\n// The light's ambient term.\n#define ambientColor vec4(0.0, 0.0, 0.0, 1.0)\n// The falloff factor of the specular lighting term.\n#define specularFactor 8.0\n// The coefficient to the specular factor when negotiating\n// the brightness of distant, but satisfactorily oriented bumps.\n#define specularRatio 0.25\n// The coefficient of the values given by the specular map.\n#define specularMapRatio 4.0\n// Whether or not to use a texture as the base value.\n// #define useBaseImage\n#define PI 3.1415926538\n#define PI_2 1.57079632679489661923\n#define PI_4 0.785398163397448309616\n\nvec3 opTx( vec3 p, mat4 m )\n{\n    vec3 q = (inverse(m) * vec4(p, 1.0)).xyz;\n    return q;\n}\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n\nmat4 translation(vec3 pos) {\n\treturn mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, pos.x, pos.y, pos.z, 1.0);\n}\n\nmat4 rotationZ(float ang) {\n\tmat4 m = mat4(1.0);\n\tm[0][0] = cos(ang);\n\tm[1][0] = -sin(ang);\n\tm[0][1] = sin(ang);\n\tm[1][1] = cos(ang);\n\treturn m;\n}\n\nmat4 rotationY(float ang) {\n\tmat4 m = mat4(1.0);\n\tm[0][0] = cos(ang);\n\tm[2][0] = sin(ang);\n\tm[0][2] = -sin(ang);\n\tm[2][2] = cos(ang);\n\treturn m;\n}\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nvec4 opElongate( in vec3 p, in vec3 h )\n{\n    //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box\n    \n    vec3 q = abs(p)-h;\n    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nvec2 rotateUV(vec2 uv, float rotation, float mid)\n{\n    return vec2(\n      cos(rotation) * (uv.x - mid) + sin(rotation) * (uv.y - mid) + mid,\n      cos(rotation) * (uv.y - mid) - sin(rotation) * (uv.x - mid) + mid\n    );\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\nfloat sdStar(vec2 p, float r, int n, float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return smoothstep(0.0,0.01,length(p)*sign(p.x));\n}\n\n\nfloat thinCircle(vec2 p, float radius, float smoothEdge, float edgeDist){\n    float dist = sdCircle( p, radius );\n    return smoothstep(smoothEdge-edgeDist*0.25,smoothEdge+edgeDist*0.25,dist)-smoothstep(smoothEdge+edgeDist*0.5,smoothEdge+edgeDist,dist);\n}\n\nfloat logo(vec2 p) {\n    // inner\n    vec3 pos = vec3(p.x,p.y,0.15);\n    float d = 1e10;\n    {\n    vec3 q = pos;\n    \n    vec4 w = opElongate( opTx(q, rotationX(PI_2)), vec3(0.0,0.0,0.45) );\n    \n    d = min( d, w.w+sdCappedCylinder( w.xyz, vec2(0.24,0.16) ) );\n    }\n    \n    //outer arc\n    {\n    vec3 q = pos - vec3(-0.26 - 0.04,0.002,0.0);\n    vec4 w = opElongate( opTx(q, rotationX(PI_2)), vec3(0.0,0.0,0.45) );\n   \td = opSubtraction(d, w.w+sdCappedCylinder( w.xyz, vec2(0.25,0.15) ));\n    }\n    \n    {\n    //subtract from arc\n   \td = opSubtraction( sdBox(pos + vec3(0.0,1.2,0.0), vec3(1.0)), d);\n    }\n    \n    {\n    //bridge between center and arc\n    d = opUnion( sdBox(pos + vec3(0.1,-0.7+0.06,0.0), vec3(0.15,0.06,0.15)), d);\n    }\n    \n    //long center column\n   \td = opUnion( sdBox(pos + vec3(-0.1,0.10,0.0), vec3(0.15,0.8,0.15)), d);\n    //remove bottom corner\n    {\n    vec3 q = pos + vec3(-0.29,1.1,0.0);\n    d = opSubtraction(sdBox(opTx(q, rotationZ(PI_2*0.5)),vec3(0.3)), d);\n    }\n    \n    {\n    //k center\n    d = opUnion( d, sdBox(pos + vec3(-0.41,-0.21,0.0), vec3(0.37,0.07,0.15)));\n    //k top\n    d = opUnion( d, sdBox(pos + vec3(-0.5,-0.37,0.0), vec3(0.07,0.17,0.15)));\n    //k bottom\n    d = opUnion( d, sdBox(pos + vec3(-0.63,-0.05,0.0), vec3(0.15,0.24,0.15)));\n    }\n    return d;\n}\n   \n\nvec3 getPattern(vec2 p) {\n\n    float starMask = sdStar(p, 0.8, 5,3.2);\n    \n    vec3 col = vec3(0.0);\n    float offsetCenter = 0.5;\n    float rings1 = 40.0;\n    for(float i=0.0;i<rings1;++i)\n    {\n        float fade = 1.0;//sin(PI*2.0/float(rings1)*float(i*5));\n        col += fade * vec3(thinCircle(p + vec2(sin(PI*2.0/rings1*i)*offsetCenter,cos(PI*2.0/rings1*i)*offsetCenter), -0.4, 0.7,0.01)); \n    }\n    \n    col *= 1.7*starMask;\n    \n    float rings2 = 10.0;\n    offsetCenter = 0.35;\n    for(float i=0.0;i<rings2;++i)\n    {\n        float pattern = thinCircle(p + vec2(sin(PI*2.0/rings2*i)*offsetCenter,cos(PI*2.0/rings2*i)*offsetCenter), 0.1, 0.3,0.1);\n        pattern = smoothstep(0.6,1.0,pattern);\n        \n        col *= 1.0 - vec3(pattern); \n        \n        col += 0.5 * vec3(pattern);\n    }\n    \n    \n    col = clamp(col, 0.2,0.8 + starMask);\n    \n    //big star pattern\n    float rings3 = 140.0;\n    float offsetCenter2 = 0.6;\n    for(float i=0.0;i<rings3;++i)\n    {\n        float fade = 1.0;//sin(PI*2.0/float(rings1)*float(i*5));\n        col += (1.0-starMask) * vec3(thinCircle(p + vec2(sin(PI*2.0/rings3*i)*offsetCenter2,cos(PI*2.0/rings3*i)*offsetCenter2), -0.1, 0.3,0.01)); \n    }\n    \n    //small stars\n    float stars3 = 10.0;\n    float offsetCenter3 = 0.92;\n    for(float i=0.0;i<stars3;++i)\n    {\n        vec2 starP = p + vec2(sin(PI*2.0/stars3*i)*offsetCenter3,cos(PI*2.0/float(stars3)*float(i))*offsetCenter3);\n        col += vec3(sdStar(rotateUV(starP,PI*2.0/stars3*i,0.0), 0.07, 5,3.2)); \n    }\n    \n    //col = clamp(col, 0.0,1.0);\n    \n    col *= 1.0 - thinCircle(p, 0.4, 0.4,0.02);    \n    col *= 1.0 - thinCircle(p, 0.93, 0.1,0.02)*0.3;\n    \n    col -= smoothstep(0.2,0.31,sdCircle(p, 0.16)); \n    \n    col *= vec3(smoothstep(0.0,0.01,logo(p*vec2(3.0,3.0)+vec2(0.1,0.0))))*1.0;\n    \n    //col *= 12.0;\n    return col;\n}\n\n/*\n\tGet a false height value of a material.\n*/\nfloat getHeightValue(vec2 coord)\n{\n\treturn getPattern(coord).r;\n}\n\n/*\n\tReturns the local height difference of a bump map in both the X and Y directions.\n*/\nvec2 getLocalDiff(vec2 coord)\n{\n\t// Get the local difference of height along the X axis.\n\tfloat diffX = getHeightValue(vec2(coord.x+diff, coord.y) )\n\t\t-getHeightValue(vec2(coord.x-diff, coord.y) );\n\t\n\t// Do the same along the Y axis.\n\tfloat diffY = getHeightValue(vec2(coord.x, coord.y+diff) )\n\t\t-getHeightValue(vec2(coord.x, coord.y-diff) );\n\t\n\t// Return the two values as a 2D vector.\n\treturn vec2(diffX, diffY);\n}\n\n/*\n\tReturns the surface normal of a height map at a given point.\n*/\nvec3 getSurfaceNormal(vec2 coord)\n{\n\t// Get the local difference in height about the coordinate given.\n\tvec2 localDiff = getLocalDiff(coord);\n\t\n\t// Remember that the surface normal is a negative reciprocal of\n\t// the surface tangent (which is what the local difference really is).\n\t// This step does half that job, negating the local difference.\n\tlocalDiff *= -1.0;\n\t\n\t// Remember that this is to be stored in a pixel, so we have to\n\t// fit it to the range [0..1].\n\tlocalDiff = (localDiff/2.0)+.5;\n\t\n\t// In order to reciprocate the local difference in height--the difference\n\t// in essentially the Z direction of the material--we consider the localDiff\n\t// to be the horizontal terms of the normal vector. This leaves one thing\n\t// left to do.\n\t// We have to scale the Z term based on the magnitude of the height difference.\n\t// To do this we consider the normal vector to be the hypotenuse of a triangle,\n\t// with unit length 1. One side of the triangle is constrained to the XY plane,\n\t// and is the local height difference. This leaves the Z term easy to solve with\n\t// the pytheagorean theorem.\n\tfloat localDiffMag = length(localDiff);\n\tfloat z = sqrt(1.0-pow(localDiffMag, 2.0));\n\t\n\treturn vec3(localDiff, z);\n}\n\n/*\n\tReturns a hypothetical specular value from an existing texture,\n\tsince we don't have access to an actual specular map. (Similar\n\tto our height map values.)\n*/\nfloat getSpecularity(sampler2D tex, vec2 coords)\n{\n\treturn texture(tex, coords).b*.5;\n}\n\n/*\n\tReturns the position of our light, based on the global time.\n*/\nvec3 genLightCoords()\n{\n\t// Use simple trig to rotate the light position around a point.\n\tvec3 lightCoords = vec3(lightPathCenter.x + (sin(iTime*timeScale)*lightPathRadius), \n\t\t\t\tlightPathCenter.y + (cos(iTime*timeScale)*lightPathRadius),\n\t\t\t\tlightPathCenter.z);\n\treturn lightCoords;\n}\n\n/*\n\tReturns the vector of incidence between a light position and a surface position.\n*/\nvec3 getIncidence(vec3 lightPos, vec2 coord)\n{\n\t// To get the incidence vector we subtract the final position from the original\n\t// position. This gives us a vector pointing into the surface.\n\treturn lightPos - vec3(coord, surfaceZDepth);\n}\n\n/*\n\tReturns the cosine of the angle of incidence of our light and the *flat* surface.\n*/\nfloat getAngle(vec3 lightIncidence, vec3 normal)\n{\n\t// We have to unpack the normal vector.\n\tnormal.xy -= .5;\n\tnormal.xy *= 2.0;\n\t\n\t// Normalize the two participating vectors so we don't get\n\t// strange results.\n\tnormal = normalize(normal);\n\tlightIncidence = normalize(lightIncidence);\n\t\n\t// Return the dot product of the two, which represents the cosine of the angle\n\t// between the two vectors.\n\treturn dot(lightIncidence, normal);\n}\n\n/*\n\tReturns the distance between the light and a given texel.\n*/\nfloat getDist(vec3 light, vec2 coord)\n{\n\treturn distance(light, vec3(coord, 0.0));\n}\n\n/*\n\tReturns the brightness and color of the texel after lighting.\n*/\nvec4 getLighting(vec2 coord)\n{\n\t// Get the current light position.\n\tvec3 lightPos = genLightCoords();\n\t\n\t// Get the vector of incidence the light has with the curren texel.\n\tvec3 lightIncidence = getIncidence(lightPos, coord);\n\t\n\t// Also get the surface normal of the current texel.\n\tvec3 surfaceNormal = getSurfaceNormal(coord);\n\t\n\t// Determine the cosine of the angle between the incident and normal vectors.\n\tfloat cosine = getAngle(lightIncidence, surfaceNormal);\n\t\n\t// Also get the distance from the light to the current texel, for\n\t// distance falloff.\n\tfloat dist = getDist(lightPos, coord);\n\t\n\t// Here's where a bit of wiki comes in. Now we create the three elements of the\n\t// Phong rendering equation: The ambient term, the diffuse term, and the \n\t// specular term.\n\t\n\t// Create the base ambient light term.\n\tvec4 ambient = ambientColor;\n\t\n\t// Create a linear-falloff diffuse light term.\n\tvec4 diffuse = vec4(1.0);\n\tdiffuse *= lightStrength;\n\tdiffuse *=  (1.0-dist);\n\tdiffuse *= cosine;\n\tdiffuse *= lightColor;\n\t\n\t// Get the local specularity (shininess of the material.\n\tfloat spec = getSpecularity(iChannel0, coord);\n\t\n\t// Create a powered-falloff specular term.\n\tvec4 specular = vec4(1.0);\n\tspecular *= lightStrength;\n\t//specular *=  pow((1.0-dist), specularFactor);\n\tspecular *= pow(cosine, specularFactor*specularRatio);\n\tspecular *= lightColor;\n\tspecular *= spec*specularMapRatio;\n\t\n\treturn ambient+diffuse+specular+spec*0.5;\n}\n\n/*\n\tThe main function of the shader.\n*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Get the normalized screen coordinates of the current texel.\n\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y*1.1;\n\t\n\t// Get the brightness due to lighting.\n\tvec4 lighting = getLighting(p) * (1.0-step(0.55,sdCircle(p,0.49)));\n\t\n    lighting.rgb += mix(vec3(0.3,0.3,0.0), vec3(0.2), smoothstep(0.31,0.32,sdCircle(p,0.5)));\n\n\t// Finally we send the texel out for use.\n\tfragColor = lighting;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","name":"Image","description":"","type":"image"}]}