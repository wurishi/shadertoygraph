{"ver":"0.1","info":{"id":"Nsf3Dn","date":"1615753848","viewed":163,"name":"Fyrecean Ray Marching #2","username":"Fyrecean","description":"Making scenes with a ray marching renderer","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const int maxSteps = 80;\nconst float hitThreshold = .002;\nconst float maxDistance = 800.;\nconst float specExp = 8.;\nconst float AA = 2.;\n\nstruct Sphere\n{\n    vec3 center;\n    float radius;\n    vec3 color;\n};\n\nstruct Box\n{\n    vec3 center;\n    vec3 size;\n    vec3 color;\n};\n\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Light\n{\n    vec3 point;\n    float intensity;\n    vec3 color;\n    float sharpness;\n};\n\nstruct Hit\n{\n    float t;\n    vec3 color;\n};\n\n\nvec3 rayToPos(Ray ray, float t)\n{\n    return ray.origin + ray.dir * t;\n}\n\nmat3 rotMat3(vec3 u, float t)\n{\n    u = normalize(u);\n    float c = cos(t);\n    float nc = 1. - cos(t);\n    float s = sin(t);\n    float xy = u.x*u.y;\n    float yz = u.y*u.z;\n    float xz = u.x*u.z;\n    return mat3(\n        c+u.x*u.x*nc, xy*nc+u.z*s, xz*nc-u.y*s,\n        xy*nc-u.z*s, c+u.y*u.y*nc, yz*nc+u.x*s,\n        xz*nc+u.y*s, yz*nc-u.x*s,  c+u.z*u.z*nc\n    );\n}\n\nmat2 rotMat2(float t)\n{\n    float c = cos(t);\n    float s = sin(t);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nHit sphereSDF(vec3 p, Sphere s)\n{\n    return Hit(length(p - s.center) - s.radius, s.color);\n}\n\nHit boxSDF( vec3 p, Box b )\n{\n  vec3 q = abs(p - b.center) - (b.size);\n  float radius = 0.02;\n  return Hit(length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - radius, b.color);\n}\n\n// Signed distance functions for different shapes\n\nHit mandelbulbSDF(vec3 p)\n{\n    float power = 8.;\n    vec3 z = p;\n    float dr = 1.;\n    float r;\n    vec3 c1 = vec3(1., 1., 1.);\n    vec3 c2 = vec3(1., 0., 0.) * .02;\n    \n    for (int i = 0; i < 15; i++)\n    {\n        r = length(z);\n        if (r > 2.)\n        {\n            break;\n        }\n        float theta = acos(z.z / r) * power + iTime;\n        float phi = atan(z.y/z.x) * power + iTime;\n        float zr = pow(r, power);\n        dr = pow(r, power - 1.) * power * dr + 1.;\n        z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));\n        z += p;\n        c2 += c2;\n    }\n    return Hit(0.5 * log(r) * r / dr, c1 - c2);\n}\n\nHit linesSDF(vec3 _p)\n{\n    vec2 p = _p.xz;\n    int iter = 4;\n    float q = 10.8 + .2*_p.y;\n    float scale = 2.2;\n    float s = .5;\n    p *= s;\n    float r = (1.1+sin(iTime))/3.;\n    vec3 color = vec3(0.);\n    int i = 0;\n    p = p*rotMat2(-0.4*q);\n    for (; i < iter; i++)\n    {\n        if (p.x < 0.)\n        {\n            p.x = -p.x;\n            color.r += 1.;\n        }\n        p = rotMat2(.9 * q) * p;\n        if (p.y < 0.)\n        {\n            p.y = -p.y;\n            color.g += 1.;\n        }\n        p = rotMat2(q) * p;\n        if (p.x - p.y < 0.)\n        {\n            p.xy = p.yx;\n            color.b += 1.;\n        }\n        p *= scale;\n        p -= 2.;\n        p = rotMat2(iTime) * p;\n    }\n    float d = .6 * (length(p)-r) * pow(scale, float(-i))/s;\n    return Hit(d, color/float(iter));\n}\n\n// Smooth min to cause shapes to morph into eachother\nfloat smin( float a, float b, float k )\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nHit hitMin(Hit a, Hit b)\n{\n    if (a.t < b.t)\n    {\n        return a;\n    } else {\n        return b;\n    }\n}\n\nHit hitSMin(Hit a, Hit b, float k)\n{\n    float h = clamp(0.5+0.5*(b.t-a.t)/k, 0.0, 1.0 );\n    float f = mix(b.t, a.t, h) - k*h*(1.0-h);\n    vec3 c = mix(b.color, a.color, h) - k*h*(1.0-h);\n    return Hit(f, c);\n}\n\n// Define the objects in the scene and their relations to eachother\nHit map(vec3 p)\n{\n    mat3 rot = rotMat3(vec3(1., 0., -0.5), 1.2);\n    return linesSDF(rot * p);\n}\n\n// Calculate the gradient of the world at a point\nvec3 calcNormal(vec3 p)\n{\n    const vec3 eps = vec3(0.001, 0., 0.);\n    \n    float deltaX = map(p + eps.xyy).t - map(p - eps.xyy).t;\n    float deltaY = map(p + eps.yxy).t - map(p - eps.yxy).t;\n    float deltaZ = map(p + eps.yyx).t - map(p - eps.yyx).t;\n    \n    return normalize(vec3(deltaX, deltaY, deltaZ));\n}\n\n// Convert a ray into a shadow scalar\nfloat calcShadow(Ray ray, float maxT, float k)\n{\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for (float t = hitThreshold * 50.; t < maxT; )\n    {\n        float h = map(rayToPos(ray, t)).t;\n        if (h < hitThreshold)\n        {\n            return 0.;\n        }\n        float hsqr = pow(h, 2.);\n        float y = hsqr/(2. * ph);\n        float d = sqrt(hsqr - pow(y, 2.));\n        res = min(res, k * d / max(0., t - y));\n        ph += h;\n        t += h;\n        i += 3;\n        if (i > maxSteps)\n        {\n            break;\n        }\n    }\n    return res;\n}\n\n// Combine all the lights in the scene to color objects\nvec3 calcLight(vec3 p, vec3 v, vec3 n)\n{\n    const int lCount = 3;\n    Light[lCount] lights = Light[lCount](\n        Light(vec3(5., 0., -6.), 50., vec3(1., .2, 0.), 8.),\n        Light(vec3(0., 5., 5.), 25., vec3(1., .5, .1), 8.),\n        Light(vec3(0., 0., 0.), 25., vec3(1., 0.5, 1.), 1.)\n    );\n    vec3 ambient = vec3(1.) * .2;\n    \n    vec3 color = vec3(0.);\n    for (int i = 0; i < lCount; i++)\n    {\n        vec3 ldir = lights[i].point - p;\n        float lmag = length(ldir); \n        ldir /= lmag;\n        \n        vec3 h = normalize(ldir - v);\n        float spec = max(0., pow(dot(n, h), specExp));\n        \n        float diff = max(0., dot(ldir, n));\n\n        float shadow = calcShadow(Ray(p, ldir), lmag, lights[i].sharpness) * 4.;\n        \n        float strength = shadow * lights[i].intensity * (1./pow(lmag, 2.));\n        color += strength * (lights[i].color * diff + vec3(1.) * spec);\n    }\n    \n    return ambient + color;\n}\n\n// Convert Pixel Rays to Colors\nvec3 raymarch(Ray ray)\n{\n    vec3 glowBase = vec3(1., .5, 1.) * .001;\n    vec3 glow = vec3(0.);\n    float t = 0.;\n    for (int i = 0; i < maxSteps && t <= maxDistance; i++)\n    {\n        vec3 currentPos = rayToPos(ray, t);\n        Hit closestHit = map(currentPos);\n        \n        if (closestHit.t < hitThreshold)\n        {\n            vec3 normal = calcNormal(currentPos);\n            vec3 color = closestHit.color * calcLight(currentPos, ray.dir, normal);\n            return color;\n        }\n        t += closestHit.t;\n        glow += glowBase;\n    }\n\n    return vec3(0.01, 0.02, 0.03) + glow;\n}\n\nvec4 render(in vec3 e, in mat4 view, in vec2 uv) {\n    // Create viewing rays and get colors from them\n    vec3 p = (view * vec4(uv, -1., 1.)).xyz;\n    Ray viewRay = Ray(e, normalize(p - e));\n    return vec4(raymarch(viewRay), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Define Camera\n    vec3 viewpoint = vec3(0., 0., 0.);\n    mat3 rot = rotMat3(vec3(0.), 0.);\n    vec3 e = vec3(0., 0., 10.);\n    \n    // Construct camera Matrix\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 w = -normalize(viewpoint - e);\n    vec3 u = cross(w, up);\n    vec3 v = normalize(cross(u, w));\n    \n    mat4 view = mat4(\n        u, 0.0,\n        v, 0.0,\n        w, 0.0,\n        e, 1.0\n    );\n    \n        // Convert pixel coordinates to uv coordinates\n    if (AA > 1.) {\n      vec4 average = vec4(0.0);\n      for (float s = 0.; s < AA; s++) {\n        for (float t = 0.; t < AA; t++) {\n            vec2 offset = (vec2(s, t) / AA) - 0.5;\n\n            vec2 uv = (fragCoord + offset)/iResolution.xy * 2. - 1.;\n            uv.y *= iResolution.y/iResolution.x;\n\n            average += render(e, view, uv);\n        }\n      }  \n      average /= AA*AA;\n      fragColor = average;\n    } else {\n      vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n      uv.y *= iResolution.y/iResolution.x;\n\n      fragColor = render(e, view, uv);\n    }\n}","name":"Image","description":"","type":"image"}]}