{"ver":"0.1","info":{"id":"slGGRR","date":"1637040689","viewed":79,"name":"Blackhole Raymarch Demo","username":"Ludicrous","description":"A simple raymarch demonstration I put together as a little mini-project. Enjoy!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","physics","graphics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 PixeltoWorldSpace(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5)/iResolution.y * 1.5;\n    float xRot = 3.1415 + iMouse.x / iResolution.x * -6.28;\n    return normalize(vec3(uv.x * cos(xRot) - sin(xRot), uv.y, cos(xRot) + uv.x * sin(xRot)));\n}\n\nvec3 pcg3d(uvec3 v) {\n\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return vec3(v) / 4294967296.0;\n}\n\nvec3 ProceduralStars(vec3 rayDir)\n{\n    vec3 r = (rayDir + vec3(1,1,1)) * 330.;\n    float probability = pcg3d(uvec3(r)).y - abs(rayDir.y) * 0.001;\n    if (probability < 0.999)\n        return vec3(0,0,0);\n    if (probability < 0.9996)\n        return vec3(1,.7,.59);\n    return vec3(1,.96,.9);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 rayDir = PixeltoWorldSpace(fragCoord);\n    vec3 rayPos = vec3(sin(iTime * 0.758334) * .2, cos(iTime * 0.5548334) * .1,1.) * (exp(iMouse.y / iResolution.y * 3. - 1.) * -4.0 + 3.5); // Position of camera\n    \n    vec3 col = vec3(0,0,0);\n    float transparency = 1.0; // Fog, amount of light that could pass through to reach current pixel\n    bool crossedHorizon = false; float elapsedDist = 0.0;\n    for (int i = 0; i < 60; i++)\n    {\n        float distFromBH = length(rayPos);\n        float GravStr = 1.0 / (distFromBH * distFromBH * distFromBH);\n        \n        if (GravStr > 50.0) // Definitely within horizon\n        {\n           crossedHorizon = true;\n           i = 70;\n           continue;\n        }\n        if (elapsedDist > 150.0) // Outisde range\n        {\n           i = 70;\n           continue;\n        }\n        \n        rayPos += rayDir * distFromBH * 0.2; // Step ray forwards\n        rayDir = normalize(rayDir - normalize(rayPos) * GravStr * distFromBH * 0.2); // Apply gravity numerical integration\n        elapsedDist += distFromBH * 0.2; // track total distance\n        \n        float opacityFog = 1. - exp(-.25 * distFromBH / (rayPos.y * rayPos.y + 32.)); //Equatorial Fog for nice effect\n        col += vec3(.3, .4, .6) * transparency * opacityFog;\n        transparency *= 1. - opacityFog;\n    }\n\n    if (!crossedHorizon)\n        col += ProceduralStars(rayDir) * transparency; // Add stars\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}