{"ver":"0.1","info":{"id":"XXsSR2","date":"1709764349","viewed":55,"name":"Raymarching 4D Mandelbrot","username":"dipwr","description":"Raymarching 3d slices of the 4D set created from the relationship between the Mandelbrot set and its Julia sets.\nHuge inspiration from Inigo Quilez's work:\nhttps://iquilezles.org/articles/distancefractals/\nhttps://iquilezles.org/articles/juliasets3d/","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","mandelbrot","juliaset","4d","complexdynamics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float minDist = 0.01;\nconst int maxSteps = 100;\nconst float maxDist = 10.0;\n\nconst int iterations = 100;\nconst int subSteps = 3;\n  \nconst vec3 cam = vec3(0,0,-1);\nconst vec3 dir = vec3(0,0,1);\nconst float focalLength = float(1);\n\nconst float speed = 0.5;\n\nconst int shapesNum = 1;\n\nconst float saturation = 1.0;\n\nconst vec3 sky = vec3(0.529, 0.808, 0.922);\n\nstruct fractal {\n  vec3 color;\n  vec3 pos;\n};\n\nvec2 cMul(vec2 a, vec2 b){\n return vec2((a.x*b.x-a.y*b.y),(a.x*b.y+a.y*b.x));\n}\n\nfloat fractalD(vec2 z0, vec2 c){\n  vec2 z = z0;\n  vec2 dz = vec2(0.0,0.0);\n  float di = 1.0;\n  float m2 = 0.0;\n  for (int i = 0; i < iterations; i++){\n    dz = 2.0*cMul(z, dz)+vec2(1.0,0.0);\n    z = cMul(z,z) + c;\n    m2 = dot(z,z);\n    if(m2 > 1024.0){ di =0.0; break;}\n  }\n  float d = sqrt(m2/dot(dz,dz))*0.5*log(m2);\n  if(di > 0.5){d = 0.0;}\n  if(d > 1.0){d = 1.0;}\n\n  return d;\n}\n\nvec2 coordXY(vec2 fragCoord) {\n  vec2 uv = (fragCoord.xy / iResolution.xy)-0.5;\n  \n  float aspectRatio = iResolution.x / iResolution.y;\n\n  uv.x *= aspectRatio;\n\n  return uv;\n}\n\nvec4 getDist(vec3 p){\n  fractal mandelbrot = fractal(vec3(0,1,0), vec3(0,1,5));\n  \n  float dist = fractalD((p-mandelbrot.pos).xz, vec2((p-mandelbrot.pos).y, 2.0*sin(iTime*speed)));\n  vec4 shape = vec4(dist, mandelbrot.color);\n  \n  return vec4(shape.x, shape.yzw);\n}\n\nvec3 rayMarch(vec3 cam, vec3 dir){\n  float tDist = 0.0;\n  \n  for (int i = 0; i < maxSteps; i++){\n    vec3 p = cam + dir * tDist;\n    \n    vec4 dist = getDist(p);\n    tDist += dist.x;\n    \n    vec3 col = dist.yzw;\n    if (dist.x < minDist){\n      return vec3(col*(1.0-(tDist/maxDist)));\n    }else if (tDist > maxDist){\n      break;\n    }\n  }\n  return vec3(sky/saturation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec3 resultAcc = vec3(0.0);\n  for (int i = 0; i < subSteps*subSteps; i++){ \n    float subSize = 1.0/float(subSteps);\n    float subXSize = subSize * float(i % subSteps);\n    float subYSize = subSize * floor(float(i) / float(subSteps));\n    \n    vec2 subCoord = vec2(fragCoord.x + subXSize, fragCoord.y + subYSize);\n    \n    vec2 coordinate = coordXY(subCoord);\n    \n    resultAcc += rayMarch(cam, dir+vec3(coordinate/focalLength,0) )*saturation;\n  }\n    fragColor = vec4(resultAcc/float(subSteps*subSteps), 1.0);  \n}","name":"Image","description":"","type":"image"}]}