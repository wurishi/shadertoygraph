{"ver":"0.1","info":{"id":"dtSBDy","date":"1695040014","viewed":38,"name":"Distance to polygon","username":"Combifightet","description":"calculates the distance to the polygon defined by an array of vertecies","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["sdf"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    #define PI 3.1415926538\n\n\tvec3 INSIDE = vec3(1.0, 0.184313725, 0.125490196);\n\tvec3 OUTSIDE = vec3(0.11372549, 0.474509804, 0.874509804);\n\tvec3 BORDER = vec3(1.0, 1.0, 1.0);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/min(iResolution.x, iResolution.y);\n\n    float aspectRatio = iResolution.x/iResolution.y;\n\n    vec2 points[3];\n    points[0] = vec2(0.25, 0.25);\n    points[1] = vec2(0.25, 0.75);\n    points[2] = vec2(1.5, 0.6);\n    \n    int pointsLength = points.length();\n    \n    float distance = 1000.0;\n    \n    if (iMouse.z > 0.5) {\n        points[2] = iMouse.xy/min(iResolution.x, iResolution.y);\n    }\n    \n    for (int i=0; i<pointsLength; ++i) {\n        vec2 a = points[i];\n        vec2 b = points[clamp(i+1, 0, pointsLength-1)];\n        if (i == pointsLength-1) {\n            b = points[0]; \n        }\n        vec2 aVec = uv-a;\n        vec2 bVec = uv-b;\n        vec2 abVec = a-b;\n        \n        if (dot(aVec, abVec)*dot(bVec, abVec) < 0.0) {\n            // distance to line\n            float newDist = abs((b.x-a.x)*(a.y-uv.y)-(a.x-uv.x)*(b.y-a.y))/sqrt(pow((b.x-a.x), 2.0)+pow((b.y-a.y), 2.0));\n            distance = min(distance, newDist);\n        } else {\n            // distance to vertecies\n            float newDist = sqrt(pow((a.x-uv.x), 2.0)+pow((a.y-uv.y), 2.0));\n            newDist = min(newDist, sqrt(pow((b.x-uv.x), 2.0)+pow((b.y-uv.y), 2.0)));\n            distance = min(distance, newDist);\n        }\n        \n    }\n    \n    bool inside = false;\n    \n    for (int i=0; i<3; ++i) {\n        vec2 a = points[i];\n        vec2 b = points[clamp(i+1, 0, 2)];\n        if (i == 2) {\n            b = points[0]; \n        }\n        \n        if ((uv.y-a.y)*(uv.y-b.y) <= 0.0) {\n            if (a.x-(a.x-b.x)*(a.y-uv.y)/(a.y-b.y) >= uv.x) {\n                inside = !inside;\n            }\n        }\n    }\n    \n    vec3 color = vec3(distance, distance, distance);\n    \n    if (inside) {\n        color *= INSIDE;\n    } else {\n        color *= OUTSIDE;\n    };\n    \n    float bandWidth = 0.02;\n\n    if (abs(distance) < bandWidth/2.0) {\n        color = BORDER;\n    } else {\n        color += floor(sin(PI*distance/bandWidth))*-0.05;\n    }\n        \n    bool lines = sin(distance*PI/bandWidth)>0.;\n    \n\n    // Output to screen\n    fragColor = vec4(uv, 0.0, 1.0);\n    fragColor = vec4(uv, 0.0, 1.0);\n    fragColor = vec4(inside, distance, distance, iMouse.z*0.8);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}