{"ver":"0.1","info":{"id":"3lGyDW","date":"1611012071","viewed":183,"name":"SineNoise","username":"ZiMMaBuE","description":"Top: heightMap. Bottom: derivatives (i don't know if they are right)\nLeft: random angle factor = 1.\nRigth: random angle factor = 0.","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["noise","wave","derivatives"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//-------------------------------------\n/*\n\n    Sine Noise\n    \n    it's similar to value noise\n    it interpolates cells of randomly rotated\n    and shifted sine intead of values.\n    \n    you can control the direction, animation speed\n    and tiling.\n    \n    inspired from:\n    https://www.shadertoy.com/view/tldSRj by iq\n    https://www.shadertoy.com/view/wttSRj by robobo1221\n\n*/\n//-------------------------------------\n\n\n\n#define PI acos(-1.0)\n\nuvec3 pcg3d(uvec3 v)\n{\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nvec3 hash33(vec3 p)\n{\n    uvec3 u = uvec3(p);\n    return vec3(pcg3d(u)) * (1.0/float(0xffffffffu));\n}\n\nvec3 NoiseCore(vec2 i, vec2 f, float tiling, float randomFactor, float angle, float animationSpeed, int seed)\n{\n    const float k = 2.0;\n    i = mod(i, tiling);\n\n    vec3 hv = hash33(vec3(i,seed));\n    hv.x *= randomFactor * PI;\n    hv.x += angle * PI;\n\n    vec2 g0 = vec2(cos(hv.x), sin(hv.x));\n    vec2 g1 = f + (hv.yz*2.0-1.0) * k - iTime * animationSpeed * g0;\n    float p = dot(g0, g1) * PI * k;\n\n    float value = sin(p);\n    float derivative = cos(p);\n\n    return vec3( value, vec2(derivative * g0) );\n}\n\nvec3 SineNoise(vec2 p, float tiling, float randomFactor, float angle, float animationSpeed, int seed)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    vec3 a = NoiseCore(i + vec2(0,0), f - vec2(0,0), tiling, randomFactor, angle, animationSpeed, seed);\n    vec3 b = NoiseCore(i + vec2(1,0), f - vec2(1,0), tiling, randomFactor, angle, animationSpeed, seed);\n    vec3 c = NoiseCore(i + vec2(0,1), f - vec2(0,1), tiling, randomFactor, angle, animationSpeed, seed);\n    vec3 d = NoiseCore(i + vec2(1,1), f - vec2(1,1), tiling, randomFactor, angle, animationSpeed, seed);\n    \n    f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(a,b,f.x),mix(c,d,f.x),f.y);\n}\n\nvec2 uv0;\nvec3 noise(vec2 p, float t)\n{\n    if(uv0.x < 0.5)\n        return SineNoise(p, t, 1.0, 0.0, 0.3, 200);\n        \n    return SineNoise(p, t, 0.0, sin(iTime * .1), 0.6, 200);\n}\n\nvec3 fbm(vec2 p, float t)\n{\n    float f = 1.0;\n    float a = 1.0;\n    float r = 0.0;\n    float s = 0.0;\n    \n    vec2 dsum = vec2(0);\n    vec2 offset = vec2(2.45,3.77);\n\n    for(int i=0; i<6; i++)\n    {\n        vec3 n = noise((p + offset)*f, t*f);\n        r += n.x*a;\n        dsum += n.yz*a*f;\n        f *= 2.0;\n        s += a;\n        a *= 0.5;\n        offset *= 2.0;\n    }\n    \n    return vec3(r,dsum)/s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x;\n    uv0 = fragCoord/iResolution.xy;\n    uv *= 10.0;\n\n    vec3 n = fbm(uv, 10.0);\n    \n    vec3 col = vec3(0);\n    if(uv0.y < 0.5)\n        col.rg += n.yz;\n    else\n        col += n.x*0.5+0.5;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}