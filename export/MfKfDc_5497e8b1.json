{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":2,"type":"texture","id":"4sf3Rr","filepath":"/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\n// The FOV is in degrees, need to convert to radians later!\nconst float FOV = 90.0; \n\nconst float PI = 3.14159265;\n\nconst float STEPSIZE = 0.0066f;\nconst int MAXSTEPS = 128;\nconst float CEILINGHEIGHT = 0.1;\nconst float THRESHOLD = 0.575;\n\nvec2 angleToVector(float angle)\n{\n    return vec2(cos(angle), sin(angle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize fragment coordinates to UV space [0,1]\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Retrieve the current position and angle\n    vec4 positionAngle = texture(iChannel1, vec2(0.5,0.5));\n\n    // Create a ray for this fragment\n    float fovRadians = radians(FOV);\n    float angleRadians = positionAngle.z * PI * 2.0;\n\n    angleRadians -= fovRadians * 0.5;\n    angleRadians += fovRadians * uv.x;\n\n    vec2 ray = normalize(angleToVector(angleRadians));\n\n    // Step through the ray until hit or max length\n    vec2 position = positionAngle.xy;\n    \n    int steps = MAXSTEPS;\n    \n\tfor(int i = 0; i < MAXSTEPS; i++)\n    {\n        float test = texture( iChannel2, vec2(position.xy)).x;\n        \n        // Compute the height of the ray and break if it hit the ceiling\n        if (abs(float(i) * ((uv.y-0.5)/float(MAXSTEPS))) > CEILINGHEIGHT)\n        {\n            steps = MAXSTEPS;\n            break;\n        }\n\n\n        // Since we don't have cool textures, we need to threshold a shitty one\n        if (test > THRESHOLD)\n        {\n            steps = i;\n            break;\n        }\n        \n        position += ray * STEPSIZE;\n    }\n    \n    float depth = 1.0 - (float(steps)/float(MAXSTEPS));\n    \n    fragColor = vec4(depth, depth, depth, 1.0);\n}","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"keyboard","id":"4dXGRr","filepath":"/presets/tex00.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"channel":1,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// All this crap is just for getting the keyboard arrows as input\n// and storeing and updating a position and angle in a texture.\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst float PI = 3.14159265;\n\nconst float ROTATIONSPEED = 0.003;\nconst float TRANSLATIONSPEED = 0.002;\n\nvec2 angleToVector(float angle)\n{\n    return vec2(cos(angle), sin(angle));\n}\n\nfloat vectorToAngle(vec2 v)\n{\n    return atan(v.y, v.x);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Normalize fragment coordinates to UV space [0,1]\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Retrieve previous frame's position and angle (if exists)\n    vec4 previousFrame = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    // Decode the previous angle and update it based on keyboard input\n    float angle = previousFrame.z;\n\n    angle -= ROTATIONSPEED * texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x;\n    angle += ROTATIONSPEED * texelFetch( iChannel0, ivec2(KEY_RIGHT,0), 0 ).x;\n\n    // Keep angle between 0 and 1.\n    angle = fract(angle);\n\n    // Compute the directional 2d vector for the angle \n    vec2 direction = angleToVector(angle * PI * 2.0);\n\n    // Decode the previous angle and update it based on keyboard input    \n    vec2 position = previousFrame.xy;\n\n    float forwardAutomatic = TRANSLATIONSPEED/15.0;\n    float forward = TRANSLATIONSPEED * texelFetch( iChannel0, ivec2(KEY_UP,0), 0 ).x;\n    float backward = TRANSLATIONSPEED * texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0 ).x;\n\n    position += direction * forwardAutomatic;\n    position += direction * forward;\n    position -= direction * backward;\n\n    // Keep position between 0 and 1\n    position = fract(position);\n\n    // Encode the position back into RGBA\n    fragColor = vec4(position.x, position.y, angle, 1.0);\n}","name":"Buffer A","description":"","type":"buffer"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":true,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"MfKfDc","date":"1734549580","viewed":51,"name":"My 2D Raycaster","username":"alexijohansen","description":"Use the arrow keys to look around.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["raycasting","keyboard"],"hasliked":0,"parentid":"","parentname":""}}