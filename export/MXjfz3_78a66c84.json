{"ver":"0.1","info":{"id":"MXjfz3","date":"1729785650","viewed":130,"name":"boiling surface","username":"Orm","description":"old fork of a nusan shader","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["3d","reflection","refraction"],"hasliked":0,"parentid":"tls3zX","parentname":"[twitch] Jewel Surface"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nShader coded live on twitch (https://www.twitch.tv/nusan_fx)\nYou can lower the MARCH_STEPS if too slow\nYou can also try the color and shape options\nThe shader was made using Bonzomatic.\nYou can find the original shader here: http://lezanu.fr/LiveCode/JewelSurface.glsl\nInspired by https://www.shadertoy.com/view/ttl3R2\n*/\n#define background sky(-r,vec3(1.,0.89,0.1))*prod\n#ifndef background\n#define background (room(r)*prod)*.2\n#endif\n\n//#define smoothabs vec3(sqrt(abs(p*p)+0.001))\n\n//#define powabs pow(abs(p),vec3(.8))\n//#define powabs pow(abs(p),vec3(1.02))-.09\n\n#define MARCH_STEPS 50\n\n#define COLOR_GEM 1\n#define RED_GEM 0\n#define CHROMATIC 0\n\n#define SHAPE sphere\n//#define SHAPE box\n//#define SHAPE diamon\n//#define SHAPE cylinder\n\n#define time (iTime*0.1+33.)\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat rnd1(float t) {\n  return fract(sin(t*724.355)*685.655);\n}\n\nfloat bx(vec3 p) {\n  p=abs(p);\n  return max(p.x,max(p.y,p.z));\n}\n\nfloat smin(float a, float b, float h) {\n  float k=clamp((a-b)/h*.5+.5,0.,1.);\n  return mix(a,b,k)-k*(1.-k)*h;\n}\n\nfloat mat=0.;\nfloat id=0.;\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  float s=5.;\n  float mm=10000.;\n  id=0.;\nfor(int i=0; i<13; ++i) {\n    \n    float t=rnd1(float(i)+12.7)*75.842 + 1022.845-iTime*.03;\n    //t += time*(.1+i*.05);\n    \n    p.xy *= rot(t);\n    p.yz *= rot(t*.7);\n\n    id += dot(sign(p), vec3(1.72,3.84,12.94)*(float(i)+1.));\n    \n    \n    #ifdef smoothabs\n    p = smoothabs;\n    #endif\n    #ifdef powabs\n    p = powabs;\n    #else\n    p = abs(p);\n    #endif\n    \n    \n    float mp=min(p.x, min(p.y,p.z));\n    \n    mm=min(mm,mp);\n        \n    p-=s;\n    \n    s*=.7;\n  }\n    \n  \n  float d = mm;\n  float dist=.76;\n  vec3 rp=(fract(p/dist-.45)-.5)*dist;\n  float d3 = length(rp)-0.05-sin(iTime*.0435)*.1;\n  \n  float sphere = length(bp)-20.;\n  float box = bx(bp)-14.;\n  float diamon = box;\n  bp.xy *= rot(3.141592*.25);\n  bp.xz *= rot(3.141592*.25);\n  diamon = max(diamon, bx(bp)-12.);\n  \n  float cylinder = max(length(bp.xz)-14., length(bp.xy)-18.);\n  //shape = smin(length(bp+7 * sin(time*.5))-12, length(bp-7)-12, 12);\n  \n  float shape = SHAPE;\n    \n  float d4 = length(vec2(d, shape));\n  d = d4-0.17;\n  \n  d3 = length(vec2(d3, shape))-.439;\n  \n  \n  \n  d = min(d,d3);\n  \n  \n  float d2 = abs(shape) - min(mm-.2, 1.0) * .7;\n  d= min(d,shape);\n  \n  \n  //mat=(d<d3)?1.:0.;\n\n  //d=min(d, d2);\n  \n  //d*=0.7;\n  \n  return d;\n}\n\nfloat curve(float t, float d) {\n  float g=t/d;\n  return mix(rnd1(floor(g)), rnd1(floor(g)+1.), pow(smoothstep(0.,1.,fract(g)), 10.));\n}\n\nvoid cam(inout vec3 p) {\n  float t=time*.15 + curve(time+97.4, 2.5*4.)*2.;\n  p.yz *= rot(sin(t)*.5);\n  p.xz *= rot(sin(t*1.3)*.9);\n}\n\nvec3 rnd(float t) {\n  return fract(sin(t*vec3(423.745,384.912,542.877))*725.945);\n}\n\n\nvec3 room(vec3 r) {\n  \n  vec3 col=vec3(0.3);\n  \n  float dist=0.3;\n  vec2 amask=abs(fract(r.yz/dist-.5)-.5)*dist;\n  float mask=clamp(((1.3-(max(amask.x,amask.y))*10.))*2.,0.,1.);\n  \n  col = mix(col, vec3(7), pow(max(0.,-r.y),12.))*vec3(0.7,0.6,0.5);\n  col = mix(col, vec3(7), pow(max(0.,-r.z),12.))*vec3(0.973,0.878,0.671);\n  col = mix(col, mask * vec3(10), pow(abs(r.x),10.))*vec3(0.557,0.753,0.992);\n  \n  return col * 1.7;\n}\n\t\nvec3 sky(vec3 rd, vec3 light) {\n\tfloat sun = max(0.01, pow(dot(light, rd), 1.3)) * 0.25 +\n\tmax(0.0001, pow(dot(light, rd), 15.0))*.01+\n\tsmoothstep(0.5,.5005,length(light +rd)-1.842)*400.;\n\tvec3 sky = max(vec3(0.0001), mix(vec3(0.561,0.702,0.871), vec3(0.169,0.384,0.835), rd.y)) + sun;\n    vec2 r = rd.xz;\n\tfloat singr = 0.;//((sin(r.x/ rd.y) + sin(r.y/ rd.y)));\n    for(float i = 0.; i<5.;i+=1.){\n        r += .6*i*r.xy*rot(i*.6);\n        singr +=((sin(r.x/ rd.y) + sin(r.y / rd.y)))/(i+1.)*.65;\n    }\n\tvec3 ground =\n\tmix(\n\t\tvec3(0.0745, 0.051, 0.0431),\n\t\tvec3(0.1882, 0.1373, 0.1098),\n\t\tclamp(singr*.25+0.5, 0.0, 1.0));\n\t\t\n\t\treturn vec3(mix(ground, sky, clamp(pow(rd.y + 1.0, 50.0), 0.0001, 1.0)));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  #if CHROMATIC\n  float fsize=1.0;\n  float fringe = fract(floor(gl_FragCoord.y/fsize)*fsize/3.);\n  vec3 fcol = (1.-abs(fringe*3.-vec3(0,1,2)))*3.;\n  #else\n  float fringe = 0.;\n  vec3 fcol = vec3(1.);\n  #endif\n  \n  //uv *= 2.0/(1.0+length(uv));\n    vec2 m = (iMouse.xy/iResolution.xy);\n    float delay=2.5;\n    float zoom=curve(time, delay);\n\n    vec3 s=vec3((curve(time+12.75, delay)-.5)*13., (curve(time+37.15, delay)-.5)*12.+(m.y-0.5)*20.,-27.-zoom*10.);\n    \n  \n    vec3 r=normalize(vec3(-uv,.9 - zoom * 0.4-(dot(uv,uv)*2.-2.0)*(cos(iTime*.3)*.5+.5)));\n    //-max((length(uv)*3.-4.),-1.);\n  \n\n  cam(s);\n  cam(r);\n  //r.y +=(m.y-0.5)*20.;\n  \n  r.xz *= rot((-m.x)*7.);\n  s.xz *= rot((-m.x)*7.);\n\n  vec3 col=vec3(0);\n  vec2 off=vec2(0.01,0);\n  \n  vec3 p=s;\n  float side=1.;\n  vec3 prevhit=s;\n  vec3 prod=vec3(1);\n  for(int i=0; i<MARCH_STEPS; ++i) {\n    float d=map(p)*side;\n    if((d)<.01) {\n      \n      float curmat=mat;\n      float curid=id;\n      \n      vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx))) * side;\n              \n      vec3 rn = reflect(r,n);\n      \n      float fre=pow(1.-abs(dot(n,r)), 2.);\n      \n      if(curmat<0.5) {\n         r=rn;\n        prod*=vec3(0.835,0.827,0.906);\n        prod *= pow(fre,.5)+.02;\n        //prod *= pow(1-fre,10);\n        //prod *= 0.0;\n        p+=n*.4;\n        //break;\n      } else {\n        r=rn;\n        prod*=vec3(0.980,0.855,0.796);\n        prod *= pow(fre,.35);\n        //prod *= pow(1-fre,10);\n        //prod *= 0.0;\n        p+=n*.1;\n        //break;\n      }\n      \n      d = 0.01;\n      prevhit = p;\n      //break;\n    }\n    if(d>50.) break;\n    p+=r*d;\n  }\n  \n  //col += sky(r)*prod;\n  col += background;\n  //col = vec3(length(uv)*10.-5.);\n  col = pow(col, vec3(0.6));\n    \n  fragColor = vec4(col, 1);\n}\n","name":"Image","description":"","type":"image"}]}