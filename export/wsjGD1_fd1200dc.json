{"ver":"0.1","info":{"id":"wsjGD1","date":"1548783955","viewed":538,"name":"Four-pass printing CMYK halftone","username":"wagyx","description":"Largely inspired  from http://webstaff.itn.liu.se/~stegu76/webglshadertutorial/shadertutorial.html\nCredits to this person, I have not implemented everything though.\nBut I am using the true CMYK functions.\nSet frequency to 200.\n","likes":8,"published":1,"flags":0,"usePreview":0,"tags":["halftone","cmyk","print"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xdf3Rn","filepath":"/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","previewfilepath":"/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//########################################\n// This work has been largely inspired/copied from\n// http://webstaff.itn.liu.se/~stegu76/webglshadertutorial/shadertutorial.html\n// Credits to Stefan Gustavson - http://webstaff.itn.liu.se/~stegu76\n//########################################\n\n\n#define ORIGIN (0.5 * iResolution.xy)\n\nbool cmyk_flag= true;\n\nfloat frequency = 50.0; //inverse of dot size\n\nfloat aastep(float threshold, float value) {\n    float afwidth = frequency * (1.0/500.0);\n    float minval= threshold-afwidth;\n    minval = max(minval,0.);\n    float maxval= threshold+afwidth;\n    maxval = min(maxval,1.);\n  return smoothstep(minval, minval, value);\n}\n\n\nvec2 rotate2D(vec2 v, float angdegree)\n{\n    float c=cos(radians(angdegree));\n    float s=sin(radians(angdegree));\n    return mat2(c,-s,s,c) * v;\n}\n\nvec4 rgb2cmyki(in vec3 c)\n{\n\tfloat w = max(max(c.r, c.g), c.b); //w is 1-k\n\treturn vec4((w-c.rgb) / w, 1.-w);\n}\n\nvec3 cmyki2rgb(in vec4 c)\n{\n\treturn (1.-c.rgb) * (1.-c.a);\n}\n\nfloat halftoneratio(vec2 st, float col, float frequency, float angdegree)\n{\n    // Distance to nearest point in a grid of\n    // (frequency x frequency) points over the unit square\n    st*= vec2(1.0,iResolution.y/iResolution.x); //corrects image ratio\n    vec2 st2 = frequency*rotate2D(st,angdegree);\n\tvec2 uv = 2.0*fract(st2)-1.0;\n    uv*=0.9; //magic number, controls the contrast\n\tfloat newcol = aastep(0., sqrt(col)-length(uv));\n    return newcol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    \n    float n=0.1;\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    vec3 texcolor = texture(iChannel0, uv).xyz; // Unrotated coords\n    //texcolor= vec3(0.0,0.0,0.0);\n    //texcolor= pow(texcolor, vec3(2.2));\n\n    vec3 rgbscreen;\n    if(cmyk_flag) {\n        vec4 cmyk;\n        //old cmyk method\n        //cmyk.xyz = 1.0 - texcolor;\n        //cmyk.w = min(cmyk.x, min(cmyk.y, cmyk.z)); // Create K\n        //cmyk.xyz -= cmyk.w; // Subtract K equivalent from CMY\n        cmyk= rgb2cmyki(texcolor);\n\n        float k = halftoneratio(uv, cmyk.w, frequency, 45.);\n        float c = halftoneratio(uv, cmyk.x, frequency, 15.);\n        float m = halftoneratio(uv, cmyk.y, frequency, 75.);\n        float y = halftoneratio(uv, cmyk.z, frequency, 0.);\n\n        //rgbscreen = mix(1.0 - vec3(c,m,y), black, 1.0*k); //old cmyk method\n    \trgbscreen= cmyki2rgb(vec4(c,m,y,k));\n    }\n    else {\n        vec3 texcol2= (1.0-texcolor);\n        float r = halftoneratio(uv, texcol2.r, frequency, 15.);\n        float g = halftoneratio(uv, texcol2.g, frequency, 45.);\n        float b = halftoneratio(uv, texcol2.b, frequency, 0.);\n        rgbscreen= 1.0-vec3(r,g,b);\n    }\n    \n    //rgbscreen= pow(rgbscreen, vec3(1./2.2));\n\n    // Output to screen\n    fragColor = vec4(rgbscreen,1.0);\n}","name":"Image","description":"","type":"image"}]}