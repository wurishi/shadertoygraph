{"ver":"0.1","info":{"id":"3lVcDd","date":"1611998256","viewed":291,"name":"tuto: progressiv sampling vs GPU","username":"FabriceNeyret2","description":"every 4 seconds :\n- reference FPS for full rendering\n- FPS for p% of pixels rendered at random:  no gain at all, because of warp SIMD (see comments in code)\n- FPS for p% of warps rendered at random: gain.\nCrucial for progressive sampling (e.g. path tracin","likes":4,"published":3,"flags":0,"usePreview":0,"tags":["warp","tuto","gpu"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* Progressive sampling + cumulate in buffA (e.g. for path tracing), or dithered calculus, are ways to improve FPS.\n   But one has to take care of the structure of parallelism on GPUs:\n   On nVIDIA, warps of 4*8 pixels are evaluated in SIMD, so rendering 1 single pixel in a block \n   costs exactly the same that rendering the full 32  (if the computation story\n   is quite the same in all pixels) : sampling that way is innefficient.\n   â†’ better to samples along warps.\n*/\n\n\n#define hash(p)  fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\n#define p    1./16.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O;\n    int t = int(iTime/4.) % 3;\n    vec2 R = iResolution.xy;\n    float v = max(0., 10.-length(U-R.y*vec2(.05,.15+float(t)/3.) )); // mode indicator\n    O += v;\n    \n    if (t==1 && hash(U+iTime) > p )                  return;         // eval only proprotion p of pixels\n    if (t==2 && hash(floor(U/vec2(4,8))+iTime) > p ) return;         // eval only proprotion p of warps\n    \n    for (float i=0.; i < 2e4; i++ )                                  // some costly computation\n        O = (.8+.2*cos(O+vec4(U*.1,U.y,0))) * texture(iChannel0, U/R);\n        \n    O += v;\n}","name":"Image","description":"","type":"image"}]}