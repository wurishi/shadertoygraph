{"ver":"0.1","info":{"id":"ctKfzc","date":"1702337978","viewed":96,"name":"Redondo Game Shader (final)","username":"rubixcom","description":"The shader used for upcoming board games at https://redondo.web.app\n\nTry choosing different boards in Common shader.\n\nEarlier version: https://www.shadertoy.com/view/DsdfDs\n\nMostly based on the work of IQ.\nhttps://iquilezles.org/articles/raymarchingdf/","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["game","board"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float A = 2.0, s = 1./A, x, y;\n    vec3 myOutputColor = vec3(0.0);\n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) myOutputColor += min ( texture(iChannel0,(vec2(x,y)+fragCoord.xy) / (iResolution.xy)).xyz / (A*A), 1.0);\n    fragColor = vec4(myOutputColor.xyz, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Experiment at creating a circular board game based on techiques described here: \n// https://iquilezles.org/articles/raymarchingdf/\n// https://iquilezles.org/articles/rmshadows/\n// https://iquilezles.org/articles/distfunctions/\n\n#ifdef CHESS\n    #define RINGS 8\n    #define SECTORS 8\n    #define SQUARE_BOARD\n    #define PIECE_ENABLED_PAWN\n    #define PIECE_ENABLED_QUEEN\n    #define PIECE_ENABLED_BISHOP\n    #define PIECE_ENABLED_ROOK\n    #define PIECE_ENABLED_KNIGHT\n    #define PIECE_ENABLED_KING\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](5,2,3,9,6,3,2,5,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1001,1001,1001,1001,1001,1001,1001,1001,1005,1002,1003,1009,1006,1003,1002,1005);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25);\n    int selectedPiece = 11;\n#endif\n\n#ifdef CHECKERS\n    #define RINGS 8\n    #define SECTORS 8\n    #define SQUARE_BOARD\n    #define PIECE_ENABLED_TOKEN\n    #define PIECE_ENABLED_TOKEN_QUEEN\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](7,0,7,0,7,0,7,0,0,7,0,7,0,7,0,7,7,0,7,0,7,0,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1007,0,1007,0,1007,0,1007,1007,0,1007,0,1007,0,1007,0,0,1007,0,1007,0,1007,0,1007);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,0,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25);\n    int selectedPiece = 20;\n#endif    \n\n#ifdef HEXAGON\n    #define RINGS 9\n    #define SECTORS 9\n    #define HEX_BOARD\n    #define PIECE_ENABLED_TOKEN\n    #define PIECE_ENABLED_TOKEN_QUEEN\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](100,100,100,100,1007,100,100,100,100,100,100,0,0,0,0,0,100,100,7,0,0,0,0,0,0,0,7,0,0,0,0,0,0,0,0,0,0,0,0,100,0,100,0,0,0,0,0,0,0,100,0,0,0,0,1007,0,0,0,0,0,0,0,1007,100,0,0,0,0,0,0,0,100,100,100,100,0,7,0,100,100,100);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,-1,0,0,0,-1,-1,-1,-1,-1,-1,-1,0,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222,0.2222222222222222);\n    int selectedPiece = 26;\n#endif    \n\n\n#ifdef REDONDO\n    #define RINGS 4\n    #define SECTORS 16 \n    #define PIECE_ENABLED_PAWN\n    #define PIECE_ENABLED_BISHOP\n\n    int pieces[RINGS*SECTORS] = int[RINGS*SECTORS](3,3,3,3,3,3,3,3,1003,1003,1003,1003,1003,1003,1003,1003,1,1,1,1,1,0,1,1,1001,0,1001,1001,1001,1001,1001,1001,0,0,0,0,0,1,0,0,0,1001,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    int highlighted[RINGS*SECTORS] = int[RINGS*SECTORS](-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1); \n    float piecesHeights[RINGS*SECTORS] = float[RINGS*SECTORS](0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25);\n    int selectedPiece = 6;\n#endif\n\n\n    #if MOBILE\n\t    precision mediump float;\n    \tprecision mediump int;\n        #define maxSteps 65\n        #define shadowSteps 20 // can be 10 to increase frame rate\n        #define reflectionSteps 20 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 10\n        #define MARCH_OVERSTEP_MAX_LIMIT .08\n//       #define CIRCLE_HIGHLIGHT\n        #define SQUARE_HIGHLIGHT \n        #define GLOW_LIMIT 1.0 // Have no idea why this needs to be there on mobiles\n    #else\n        precision highp float;\n        precision highp int;\n        #define REFLECTIONS_OF_REFLECTIONS\n        #define maxSteps 65\n        #define shadowSteps 20 // can be 10 to increase frame rate\n        #define reflectionSteps 30 // can be 10 to increase frame rate\n        #define secondaryReflectionSteps 10\n        #define MARCH_OVERSTEP_MAX_LIMIT .08\n        #define DYNAMIC_MARCH_STEPS_LIMIT\n        #define SQUARE_HIGHLIGHT \n        #ifndef SQUARE_BOARD \n            #ifndef HEX_BOARD \n                #define ROTATE_PIECES_ON_BOARD\n            #endif\n        #endif\n        #define WOOD\n        #define GLOW_LIMIT 10.0\n        // #define SQUARE_HIGHLIGHT_ENTIRE_SQUARE\n    #endif\n\n    #define LIGHTS 1\n    #define REFLECTIONS \n    #define BOARD_GLOW\n    #define SHADOWS\n    // #define STRIPES\n  //      #define DONT_RENDER_IF_NO_MATCH\n    \n    #define M_PI 3.1415926535897932384626433832795\n    #ifdef SQUARE_BOARD\n        #define SHAPE_SIZE (2.0 / float(RINGS))\n    #endif\n    #ifdef HEX_BOARD\n        #define SHAPE_SIZE (2.0 / float(RINGS))\n    #endif\n    #ifndef SQUARE_BOARD\n        #ifndef HEX_BOARD\n            #define SHAPE_SIZE (1.0 / float(RINGS))\n        #endif\n    #endif\n    #define DIST_SCALE (0.375 * float(RINGS))\n    #define DIST_SCALE_R (0.15 * float(RINGS))\n    #define DIST_SCALE_S (0.15 * float(SECTORS))\n    #define OFFSET_R 3.3\n    #define OFFSET_S 3.3\n    #define ROUNDED_CORNER_SIZE 0.425\n    #define GLOW_INC 0.1\n    //#define TEXTURED\n    //#define WOOD\n    \n    #define pawn 1\n    #define knight 2\n    #define bishop 3\n    #define rook 5\n    #define queen 9\n    #define king 6\n    #define token 7\n    #define tokenQueen 8\n    #define capturedToken 9\n    #define noSquare 100\n\n    float animationTimePos = 0.;\n    vec3 animationPiecePos = vec3(0.);\n    int animationPieceType = 0;\n    int animationPiecePlayer = 0;\n    int dynamicMarchLimit = 0;\n\n    float boardRotation = 0.0;\n    float zoom = 1.0;\n\n    vec3 ambientColor = vec3(5.);\n    vec3 lightPositions[LIGHTS] = vec3[](vec3(26.,40.,26.));//,vec3(3.,4.,0.),vec3(-3.,4.,0.));\n    vec3 lightColors[LIGHTS] = vec3[](vec3(50.25,50.25,50.25));//, vec3(0.0,5.0,3.0), vec3(3.25,0.0,5.0));\n\n    vec4 emptyBoardColor = vec4(0.2, 0.2, 0.2, 0.4);\n    vec4 emptySurfaceColor = vec4(vec3(0.0), 0.6);\n    // 4th parameter of the colour is reflectivity\n    vec4 boardColors[2] = vec4[](vec4(vec3(.702,0.553,0.459)*1.1,.4), vec4(vec3(0.314,0.255,0.235)*.4,.4));\n    vec4 playerColors[2] = vec4[](vec4(1.0,0.75,0.5,.5), vec4(1.0,0.1,0.1,.5));\n    float roundedCornerSize = 0.425;\n\n#ifdef TEXTURED\n    uniform sampler2D woodTexture;\n#endif\n\n    // Prevent negative 0 becoming positive zero on int conversion\n    #define intC(f) int(f < 0.0 ? -1.0 : f)\n\n    float n21(vec2 p) {\n        const vec3 s = vec3(7, 157, 0);\n        vec2 h,\n            ip = floor(p);\n        p = fract(p);\n        p = p * p * (3. - 2. * p);\n        h = s.zy + dot(ip, s.xy);\n        h = mix(fract(sin(h) * 23.5453), fract(sin(h + s.x) * 23.5453), p.x);\n        return mix(h.x, h.y, p.y);\n    }\n\n    float n11(float p) {\n        float ip = floor(p);\n        p = fract(p);\n        vec2 h = fract(sin(vec2(ip, ip + 1.) * 12.3456) * 43.5453);\n        return mix(h.x, h.y, p * p * (3. - 2. * p));\n    }\n    \n    // https://www.shadertoy.com/view/wl3czM\n    vec3 wood(vec2 p) {\n        p.x *= 20.;\n        p.y *= 1.9;\n        float l = .7 + .3 * n11(n21(p) * 5.);\n        return vec3(.702 * l,0.553 * l,0.459 * l);\n    }\n\n    vec3 rayVector(in vec3 position, in vec3 target, in vec2 fragCoord)\n    {\n        vec3 eye = normalize(target - position);\n        vec3 up = vec3(0., 1., 0.);\n        vec3 right = cross(eye, up);\n        up = cross(eye,right);\n    \n        mat3 cameraMatrix = mat3(right.x, up.x, eye.x,\n                                 right.y, up.y, eye.y,\n                                 right.z, up.z, eye.z);\n    \n        vec2 uv = fragCoord.xy / iResolution.xy - vec2(.5);\n        uv.x = uv.x * iResolution.x/iResolution.y;\n        uv.y = -uv.y;\n\t\tfloat focalDistance = zoom * (iResolution.x > iResolution.y ? 2.4-(position.y/21.) : 1.3 * iResolution.x / iResolution.y);\n\n        return (normalize(vec3(uv.x,uv.y,focalDistance)) * cameraMatrix) * .5;\n    }\n    \n    vec3 shade(in vec3 pos, in vec3 normal, in vec3 cameraVector, in vec3 lightPos, in vec3 lightColor, in vec4 surface)\n    {\n        vec3 diff = lightPos - pos;\n        float dist = length(diff);\n        vec3 light = diff / dist;\n        float dotlight = dot(normal, light);\n    \n        vec3 cameraReflected = normalize(reflect(cameraVector, normal));\n        float spec = 0.0;\n        if (dot(cameraReflected, light) < 0.0)\n            spec = min(1.0, pow(dot(cameraReflected,light), 2.0));\n        return (surface.xyz * ambientColor // ambient\n            + vec3(0.2+dotlight) * lightColor * surface.xyz // surface\n            + vec3(spec) * lightColor) / dist; // spec\n    }\n    \n    float sdSphere( vec3 p, float s )\n    {\n        return length(p)-s;\n    }\n    \n    float sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n    {\n        vec2 q = vec2( length(p.xz), p.y );\n    \n        vec2 k1 = vec2(r2,h);\n        vec2 k2 = vec2(r2-r1,2.0*h);\n        vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n        vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2,k2), 0.0, 1.0 );\n        float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n        return s*sqrt( min(dot(ca,ca),dot(cb,cb)) );\n    }\n\n    float sdChecker( in vec3 p, in float h, in float r1 )\n    {\n        float l = length(p.xz);\n        return max(max(l - r1, -(p.y + h)), p.y + 0.6 * h - cos(l * 70.) * .005);\n        // p.x *= r1; p.z *= r1; p.y = p.y + .15;\n        // float l = length(p.xz);\n        // p.y -= cos(l * 300.) * .005;\n        // vec2 d = vec2(l,p.y) - h;\n        // return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    float sdCheckerQueen( in vec3 p, in float h, in float r1 )\n    {\n        float l = length(p.xz);\n        return max(max(l - r1, -(p.y + h)), p.y + 0.6 * h);\n        // p.x *= r1; p.z *= r1; p.y = p.y + .15;\n        // float l = length(p.xz);\n        // vec2 d = abs(vec2(l,p.y)) - h;\n        // return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    }\n\n    float sdOctahedron(vec3 p, float s)\n    {\n        p = abs(p);\n        float m = p.x + p.y + p.z - s;\n        return m*0.57735027;\n    }\n\n    // c is the sin/cos of the desired cone angle\n    float sdSolidAngle(vec3 pos, vec2 c, float ra)\n    {\n        vec2 p = vec2( length(pos.xz), pos.y );\n        float l = length(p) - ra;\n        float m = length(p - c*clamp(dot(p,c),0.0,ra) );\n        return max(l,m*sign(c.y*p.x-c.x*p.y));\n    }\n\n    float dot2( in vec2 v ) { return dot(v,v); }\n    float dot2( in vec3 v ) { return dot(v,v); }\n\n    float sdBox( vec3 p, vec3 b )\n    {\n        vec3 d = abs(p) - b;\n        return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n    }\n\n    float sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n    {\n        // sampling independent computations (only depend on shape)\n        vec3  ba = b - a;\n        float l2 = dot(ba,ba);\n        float rr = r1 - r2;\n        float a2 = l2 - rr*rr;\n        float il2 = 1.0/l2;\n        \n        // sampling dependant computations\n        vec3 pa = p - a;\n        float y = dot(pa,ba);\n        float z = y - l2;\n        float x2 = dot2( pa*l2 - ba*y );\n        float y2 = y*y*l2;\n        float z2 = z*z*l2;\n\n        // single square root!\n        float k = sign(rr)*rr*rr*x2;\n        if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n        if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                                return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n    }\n    \n    vec4 map( in vec3 pos)\n    {\n    \n#ifdef SQUARE_BOARD\n        float ang = pos.z + OFFSET_R;\n        float dist = pos.x + OFFSET_S;\n        int ii = intC(ang * DIST_SCALE_R);\n        int jj = intC(dist * DIST_SCALE_S);\n\n        int dd = ii+jj*(SECTORS);\n        float ang2 = (float(ii) + .5) / DIST_SCALE_R - OFFSET_R;\n        float dist2 = (float(jj) + .5) / DIST_SCALE_S - OFFSET_S;\n\n        vec3 posC = vec3(dist2, piecesHeights[dd], ang2);\n#endif\n\n#ifdef HEX_BOARD\n        float ang = pos.z + OFFSET_R;\n        float dist = pos.x + OFFSET_S;\n        int ii = intC(ang * DIST_SCALE_R);\n        float shift = mod(float(ii), 2.0) == 1.0 ? -0.5 : 0.0;\n        int jj = intC(dist * DIST_SCALE_S - shift);\n\n        int dd = ii+jj*(SECTORS);\n        float ang2 = (float(ii) + .5) / DIST_SCALE_R - OFFSET_R;\n        float dist2 = (float(jj) + shift + .5) / DIST_SCALE_S - OFFSET_S;\n\n        vec3 posC = vec3(dist2, piecesHeights[dd], ang2);\n#endif\n\n#ifndef SQUARE_BOARD\n    #ifndef HEX_BOARD\n        float ang = M_PI + atan(pos.x,pos.z);\n        float dist = length(pos.xz);\n        int ii = intC(float(SECTORS/2) * ang / M_PI);\n        int jj = RINGS - intC(dist * DIST_SCALE);\n\n        int dd = ii+jj*(SECTORS);\n        float ang2 = (float(ii) + .5) * M_PI / float(SECTORS/2);\n        float dist2 = (float(jj - RINGS) - .5) / DIST_SCALE;\n\n        vec3 posC = vec3(dist2*sin(ang2), piecesHeights[dd], dist2*cos(ang2));\n    #endif\n#endif\n\n        vec3 diff = (pos-posC)\n#ifdef ROTATE_PIECES_ON_BOARD\n            * mat3(cos(-ang), 0., sin(-ang),\n                            0., 1., 0.,\n                            -sin(-ang), 0., cos(-ang))\n#endif            \n            ;\n        #ifdef STRIPES\n            float stripe = .8 + .2*step(M_PI / 2.0, mod((M_PI+atan(diff.x, diff.z)+40.0*diff.y), M_PI));\n        #else\n            float stripe = 1.0;\n        #endif\n    \n        float v = pos.y;\n        float tt = (1.0 + float(1 + pieces[dd] / 1000));\n        bool inBoard = false;\n\n        if (ii >= 0 && jj >= 0 && ii < SECTORS && jj < RINGS) {\n            \n            inBoard = true;\n            int piece = pieces[dd] % 1000;\n\n\n#ifdef PIECE_ENABLED_TOKEN\n            if (piece == token) {\n                v = sdChecker( diff, SHAPE_SIZE, SHAPE_SIZE );\n            } else \n#endif\n#ifdef PIECE_ENABLED_TOKEN_QUEEN\n            if (piece == tokenQueen) {\n                v = sdCheckerQueen( diff, SHAPE_SIZE, SHAPE_SIZE );\n            } else \n#endif\n#ifdef PIECE_ENABLED_PAWN\n            if (piece == pawn) {\n                v = sdSphere( diff, SHAPE_SIZE );\n            } else \n#endif\n#ifdef PIECE_ENABLED_BISHOP\n            if (piece == bishop) {\n                v = sdCappedCone( diff, SHAPE_SIZE, SHAPE_SIZE * .75, SHAPE_SIZE * .4 );\n            } else \n#endif\n#ifdef PIECE_ENABLED_ROOK\n            if (piece == rook) {\n                v = sdBox( diff, vec3(SHAPE_SIZE * .65, SHAPE_SIZE, SHAPE_SIZE * .65) );\n            } else \n#endif\n#ifdef PIECE_ENABLED_KNIGHT\n            if (piece == knight) {\n                v = sdRoundCone( diff, vec3(0.0,0.0,0.0), vec3(0.1,0.15,0.1), SHAPE_SIZE * .75, SHAPE_SIZE * .4 );\n            } else \n#endif\n#ifdef PIECE_ENABLED_QUEEN\n            if (piece == queen) {\n                v = sdSolidAngle( diff - vec3(0,-SHAPE_SIZE,0),  vec2(3,4)/5.0, SHAPE_SIZE * 1.7 );\n            } else \n#endif\n#ifdef PIECE_ENABLED_KING\n            if (piece == king) {\n                v = sdOctahedron( diff, SHAPE_SIZE * .8 );\n            } else\n#endif\n            {}\n        }\n\n        if (animationPieceType != 0) {\n#ifdef SQUARE_BOARD\n            float ang3 = (animationPiecePos.y + .5) / DIST_SCALE_R - OFFSET_R;\n            float dist3 = (animationPiecePos.x + .5) / DIST_SCALE_S - OFFSET_S;\n            vec3 posC3 = vec3(dist3, SHAPE_SIZE * animationPiecePos.z, ang3);\n#endif\n#ifdef HEX_BOARD\n        float m =  mod(animationPiecePos.y, 2.0);\n        float shift =  (m <= 1.0 ? m : 2.0 - m) * -0.5;\n        float ang3 = (animationPiecePos.y + .5) / DIST_SCALE_R - OFFSET_R;\n        float dist3 = (animationPiecePos.x + shift + .5) / DIST_SCALE_S - OFFSET_S;\n        vec3 posC3 = vec3(dist3, SHAPE_SIZE * animationPiecePos.z, ang3);\n#endif\n#ifndef SQUARE_BOARD\n    #ifndef HEX_BOARD\n            float ang3 = (animationPiecePos.y + .5) * M_PI / float(SECTORS/2);\n            float dist3 = (animationPiecePos.x-float(RINGS) - .5) / DIST_SCALE;\n            vec3 posC3 = vec3(dist3*sin(ang3), SHAPE_SIZE * animationPiecePos.z, dist3*cos(ang3));\n    #endif\n#endif\n            vec3 diff3 = (pos-posC3)\n#ifdef ROTATE_PIECES_ON_BOARD\n                        * mat3(cos(-ang3), 0., sin(-ang3),\n                            0., 1., 0.,\n                            -sin(-ang3), 0., cos(-ang3))\n#endif\n                ;\n            float pv = v;\n#ifdef PIECE_ENABLED_TOKEN            \n            if (animationPieceType == token) {\n                v = min(v, sdChecker( diff3, SHAPE_SIZE, SHAPE_SIZE ));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_TOKEN_QUEEN\n            if (animationPieceType == tokenQueen) {\n                v = min(v, sdCheckerQueen( diff3, SHAPE_SIZE, SHAPE_SIZE));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_PAWN\n            if (animationPieceType == pawn) {\n                v = min(v, sdSphere( diff3, SHAPE_SIZE ));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_BISHOP\n            if (animationPieceType == bishop) {\n                v = min(v, sdCappedCone( diff3, SHAPE_SIZE, SHAPE_SIZE * .75, SHAPE_SIZE * .4 ));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_ROOK\n            if (animationPieceType == rook) {\n                v = min(v, sdBox( diff3, vec3(SHAPE_SIZE * .65, SHAPE_SIZE, SHAPE_SIZE * .65) ));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_KNIGHT\n            if (animationPieceType == knight) {\n                v = min(v, sdRoundCone( diff3, vec3(0.0,0.0,0.0), vec3(0.1,0.15,0.1), SHAPE_SIZE * .75,  SHAPE_SIZE * .4 ));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_QUEEN\n            if (animationPieceType == queen) {\n                v = min(v, sdSolidAngle( diff3 - vec3(0,-SHAPE_SIZE,0),  vec2(3,4)/5.0, SHAPE_SIZE * 1.7 ));\n            } else \n#endif            \n#ifdef PIECE_ENABLED_KING\n            if (animationPieceType == king) {\n                v = min(v, sdOctahedron( diff3, SHAPE_SIZE * .8 ));\n            } else\n#endif            \n            {}\n            if (pv != v) {\n                #ifdef STRIPES\n                    stripe = .8 + .2*step(M_PI / 2.0, mod((M_PI+atan(diff3.x, diff3.z)+40.0*diff3.y), M_PI));\n                #endif\n                tt = float(animationPiecePlayer) + 2.0;\n            }\n        }\n\n        // Floor\n        if (v >= pos.y) {\n            v = pos.y;\n            tt = 1.0;\n        }\n\n        return vec4(v, tt, stripe, inBoard? float(dd+1) : 255.0); // 255.0 is needed here because value of 0.0 in the alpha channel causes the pixel not to render on some GPUs\n    }\n\n    vec4 boardColor( in vec2 p)\n    {\n#ifdef SQUARE_BOARD\n        float ang = (p.y + OFFSET_S) * DIST_SCALE_S;\n        float dist = (p.x + OFFSET_R) * DIST_SCALE_R;\n        int ii = intC(ang);\n        int jj = intC(dist);\n\n        vec2 pp = abs(vec2(abs(fract(dist) - .5), abs(fract(ang) - .5)));\n        float ll = length(pp/2.);\n#endif\n#ifdef HEX_BOARD\n        float ang = (p.y + OFFSET_S) * DIST_SCALE_S;\n        float dist = (p.x + OFFSET_R) * DIST_SCALE_R;\n\n        int ii = intC(ang);\n        float shift = mod(float(ii), 2.0) == 1.0 ? 0.5 : 0.0;\n        int jj = intC(dist + shift);\n        \n        float px = abs(fract(dist + shift) - .5);\n        float py = abs(fract(ang) - .5);\n\n        py += -0.1 + abs(px/2.);\n        vec2 pp = abs(vec2(px, py));\n        float ll = length(pp/2.);\n#endif\n#ifndef HEX_BOARD\n    #ifndef SQUARE_BOARD\n        float ang = M_PI + atan(p.x,p.y);\n        float dist = length(p.xy) * DIST_SCALE;\n        int ii = intC(float(SECTORS/2) * ang / M_PI);\n        int jj = RINGS - intC(dist);\n\n        float ang2 = (float(ii) + .5) * M_PI / float(SECTORS/2);\n        float dist2 = (float(jj - RINGS) - .5) / DIST_SCALE;\n\n        vec2 pp = abs(vec2(abs(fract(dist) - .5), abs(ang2 - ang) / (M_PI * 2. / float(SECTORS))));\n        float ll = length(pp/2.);\n    #endif\n#endif\n\n        int dd = ii+jj*(SECTORS);\n        if (!(jj >= 0 && jj < RINGS && ii >= 0 && ii < SECTORS\n            && pieces[dd] != noSquare)) {\n            return emptySurfaceColor;\n        }\n\n        vec4 playerColor = (highlighted[dd] != -1  \n        #ifdef SQUARE_HIGHLIGHT\n                && (pp.x >.3 || pp.y >.3 || ll > .2)  \n        #endif                \n        #ifdef CIRCLE_HIGHLIGHT\n                && (ll < .125)  \n        #endif                \n            ? vec4(playerColors[highlighted[dd]].xyz *.8, -.2) : vec4(0.0)); // make the highlighted squares less reflective\n\n        return (\n        #ifdef ROUNDED_CORNER_SIZE\n            (\n            #ifdef SQUARE_HIGHLIGHT_ENTIRE_SQUARE\n                    highlighted[dd] != -1 ||\n            #endif\n            ((pp.x < roundedCornerSize && pp.y < roundedCornerSize && ll < float(roundedCornerSize / 1.5)))\n        #endif\n            ? \n            playerColor + \n#ifndef HEX_BOARD\n            (mod(float(ii+jj), 2.0) == 1.0 ? boardColors[0] : boardColors[1])\n#else\n            boardColors[0]\n#endif                \n            : \n#ifndef HEX_BOARD\n                emptyBoardColor\n#else\n                emptySurfaceColor\n#endif                \n            ));\n    }\n\n    vec4 textured(in vec3 p, int t, float stripe)\n    {\n        if (t == 1) // board\n        {\n            //return boardColor( p.xz)*texture(woodTexture, abs(p.xz / 10.0));//boardColor( p.xz);\n            return boardColor( p.xz);\n        }\n        else if (t > 1) // player 0 piece\n        {\n            return playerColors[t-2] \n            #ifdef STRIPES\n                * stripe\n            #endif\n                ;\n        }\n        return vec4(0.0);\n    }\n    \n    float shadow(in vec3 ro, in vec3 rd, in vec3 lightPos)\n    {\n        float res = 1.0;\n        float t = 0.1;\n        for(int i = 1; i < shadowSteps; ++i)\n        {\n            vec3 p = ro + rd * t;\n            vec4 h = map(p);\n            if ( h.x < 0.001)\n                return 0.001;\n            \n            res = min( res, 4. * h.x / t);\n            t += clamp(h.x, 0.0, 0.05);\n        }\n        \n        return res;\n    }\n        \n    vec3 normal( in vec3 pos )\n    {\n        vec2 e = vec2(0.005, -0.005);\n        return normalize( e.xyy*map( pos + e.xyy ).x + \n                          e.yyx*map( pos + e.yyx ).x + \n                          e.yxy*map( pos + e.yxy ).x + \n                          e.xxx*map( pos + e.xxx ).x );\n    }\n\n    vec3 secondaryReflection(in vec3 ro, in vec3 rd)\n    {\n        float t = 0.1;\n        for(int i = 0; i < secondaryReflectionSteps; ++i)\n        {\n            vec3 p = ro + rd * t;\n            \n            vec4 d = map(p);\n            if(d.x < 0.01\n                || i == maxSteps - 1\n            )\n            {\n                vec3 normal = normal(p); vec4 texc = textured(p, int(d.y), d.z);\n    \n                vec3 color = vec3(0.0);\n#if LIGHTS==1\n                {\n                    int j = 0;\n#else\n                for (int j = 0; j < LIGHTS; j++) {\n#endif                    \n                    color += shade(p, normal, -rd, lightPositions[j], lightColors[j], texc);\n                }\n                return color\n                #if LIGHTS != 1\n                    / float(LIGHTS)\n                #endif\n                ;\n            }\n    \n            t += d.x;\n        }\n    \n        return vec3(0.0);\n    }\n    \n    vec3 reflection(in vec3 ro, in vec3 rd)\n    {\n        float t = 0.1;\n        float boardSideDepth = 0.0;\n        for(int i = 0; i < reflectionSteps; ++i)\n        {\n            vec3 p = ro + rd * t;\n            \n            vec4 d = map(p);\n            #ifdef BOARD_GLOW\n            if (selectedPiece != - 1 && d.w == float(selectedPiece+1) && p.y < SHAPE_SIZE * 2.0) {\n                boardSideDepth += GLOW_INC;\n            }\n            #endif\n            if(d.x < 0.001\n                || i == maxSteps - 1\n            )\n            {\n                vec3 normal = normal(p); vec4 texc = textured(p, int(d.y), d.z);\n\n                vec3 color = vec3(0.0);\n#if LIGHTS==1\n                {\n                    int j = 0;\n#else\n                for (int j = 0; j < LIGHTS; j++) {\n#endif                    \n                    color += shade(p, normal, -rd, lightPositions[j], lightColors[j], texc);\n                }\n\n                #ifdef REFLECTIONS_OF_REFLECTIONS\n                    vec3 cameraReflected = normalize(reflect(rd, -normal));\n                    vec3 r = secondaryReflection(p, cameraReflected);\n                    color += (texc.xyz*r + r*.1)*texc.w;\n                #endif\n\n                #ifdef BOARD_GLOW\n                    if (boardSideDepth != 0.0)\n                    {\n                        color += vec3(min(boardSideDepth * boardSideDepth, GLOW_LIMIT) * playerColors[int(d.y)-1]);\n                    }\n                #endif\n\n                return color \n#ifdef TEXTURED\n                        * (d.y == 1.0 ? texture(woodTexture, abs(p.xz * .5)).xyz : vec3(1.0))\n#else\n            #ifdef WOOD\n                        * (d.y == 1.0 ? wood(p.xz) : vec3(1.0))\n            #else                        \n                        * .8\n            #endif\n#endif\n\n#if LIGHTS != 1\n                    / float(LIGHTS)\n#endif\n                ;\n            }\n    \n            t += clamp(d.x, 0.0, .06) ; // Reduced overstep\n        }\n    \n        return vec3(0.0);\n    }\n\n    vec4 march(in vec3 ro, in vec3 rd)\n    {\n        float t = ((SHAPE_SIZE*2.2) - ro.y) / rd.y; // Start on top of shape\n        float boardSideDepth = 0.0;\n        for(int i = 0; i < maxSteps; ++i)\n        {\n            vec3 p = ro + rd * t;\n    \n            vec4 d = map(p);\n            #ifdef BOARD_GLOW\n            if (selectedPiece != - 1 && d.w == float(selectedPiece+1) && p.y < SHAPE_SIZE * 2.0) {\n                boardSideDepth += GLOW_INC;\n            }\n            #endif\n            if (d.x <= 0.001 \n            #ifndef DONT_RENDER_IF_NO_MATCH            \n                || i == maxSteps - 1\n            #ifdef DYNAMIC_MARCH_STEPS_LIMIT\n                || (dynamicMarchLimit != 0 && i == dynamicMarchLimit)\n            #endif\n            #endif            \n            ) // if max steps reached go with nearest shape, produces interesting merging\n            {\n                vec3 normal = normal(p); vec4 texc = textured(p, int(d.y), d.z);\n\n                vec3 color = vec3(0.0);\n#if LIGHTS==1\n                {\n                    int j = 0;\n#else\n                for (int j = 0; j < LIGHTS; j++) {\n#endif                    \n                    color += \n                        shade(p, normal, -rd, lightPositions[j], lightColors[j], texc)\n                        #ifdef SHADOWS\n                            * shadow(p, normalize(lightPositions[j]-p), lightPositions[j])\n                        #endif \n                        ;\n                }\n                color = color \n#ifdef TEXTURED\n                     * (d.y == 1.0 ? texture(woodTexture, abs(p.xz * .5)).xyz : vec3(1.0))\n#else \n            #ifdef WOOD\n                     * (d.y == 1.0 ? wood(p.xz) : vec3(1.0))\n            #else                        \n                    * .8\n            #endif\n#endif                     \n\n#if LIGHTS != 1\n                    / float(LIGHTS)\n#endif\n                ;\n\n                #ifdef REFLECTIONS\n                    vec3 cameraReflected = normalize(reflect(rd, -normal));\n                    vec3 r = reflection(p, cameraReflected);\n                    color += texc.w*(texc.xyz*r + r*.3);\n                #endif\n\n                #ifdef BOARD_GLOW\n                if (boardSideDepth != 0.0)\n                {\n                    color += vec3(min(boardSideDepth * boardSideDepth, GLOW_LIMIT) * .1 * playerColors[int(d.y)-1]);\n                }\n                #endif\n\n                return vec4(color, (d.w) / 255.0);\n            }\n    \n            t += clamp(d.x, 0.0, MARCH_OVERSTEP_MAX_LIMIT) ; // Reduced overstep\n        }\n        return vec4(0.0);\n    }\n    \n    void mainImage( out vec4 fragColor, in vec2 fragCoord )\n    {\n        vec3 cameraTarget = vec3(0.0);\n\n        mat3 br = mat3(cos(boardRotation+iTime*.2), 0.0, sin(boardRotation+iTime*.2),\n                  0.0, 1.0, 0.0,\n                 -sin(boardRotation+iTime*.2), 0.0, cos(boardRotation+iTime*.2));\n\n        vec2 cl = vec2(iMouse.x, iMouse.y) / iResolution.xy;\n        vec2 planePos = normalize(vec2(-cl.x, 1.0));\n        vec3 cameraLoc = br*10.*vec3( -planePos.y, clamp(cl.y, .4, 16.5), planePos.x);\n\n        vec3 ro = cameraLoc;\n        vec3 rd = rayVector(cameraLoc, cameraTarget, fragCoord);\n\n        fragColor = march(ro, rd);\n    }\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Experiment at creating a circular board game based on techiques described here: \n// https://iquilezles.org/articles/raymarchingdf/\n// https://iquilezles.org/articles/rmshadows/\n// https://iquilezles.org/articles/distfunctions/\n\n// Select 1 for mobile version and 0 for desktop\n#define MOBILE 0\n\n// Uncomment one of the 4 supported boards\n#define REDONDO\n//#define CHESS\n//#define CHECKERS\n//#define HEXAGON\n","name":"Common","description":"","type":"common"}]}