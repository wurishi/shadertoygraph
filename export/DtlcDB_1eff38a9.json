{"ver":"0.1","info":{"id":"DtlcDB","date":"1691132749","viewed":146,"name":"CrystalDiceX","username":"float1987","description":"Bending Light With Ray-tracing","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["dice","crystal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define COUNT 16.\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n#define S smoothstep\n#define T iTime * .4\n\nvec2 N(float angle) {\n    return vec2(sin(angle),cos(angle));\n}\n\nfloat smax( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat2 Rot(float a){\n    float s = sin(a),c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nvec2 sdSphere(vec3 p, float r) {\n    float d = length(p) - r;\n    return vec2(d,-2.*step(0.,d));\n}\n\n\nfloat sdBox(vec3 p, vec3 s){\n    p = abs(p)-s;\n    float e = length(max(p,0.));\n    float i = min(max(p.x, max(p.y, p.z)), 0.);\n    return e + i;\n\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r){\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    vec3 c = a + t*ab;\n    float x = length(p-c)- r;\n    float y = (abs(t-.5) - .5) * length(ab);\n    float e = length(max(vec2(x,y),0.));\n    float i = min(max(x,y), 0.);\n    \n    return e+i;\n}\n\nvec2 MixSphereInfo(vec2 dInfo,vec3 p, float r,int index ) {\n    vec2 s = sdSphere(p,r);\n    vec2 sInfo = max(dInfo,-s);\n    if(sInfo.x != dInfo.x) {\n        float v = 1.;\n        if(index == 1) v = -1.;\n        return vec2(sInfo.x, v);\n    }\n    return vec2(sInfo.x,dInfo.y );\n}\n\n\nvec2 GetDist(vec3 p) {\n\n    //Cube\n    float d1 = sdBox(p,vec3(.42));\n    float d2 = sdCylinder(p,vec3(0,.6,0),vec3(0,-.6,0),.55);\n    float d3 = sdCylinder(p,vec3(.6,0,0),vec3(-.6,0,0),.55);\n    float d4 = sdCylinder(p,vec3(0,0,.6),vec3(0,0,-.6),.55);\n    float d5 = sdBox(p,vec3(.42));\n    float k =  1.;\n    float d = smax(d4,smax(d3,smax(d1,d2,k),k),k);\n    vec2 dInfo = vec2(mix(d5,d,.3),0);\n    \n    //Hole\n    dInfo = MixSphereInfo(dInfo,p - vec3(0,.6,0),.2,1);\n    \n    dInfo = MixSphereInfo(dInfo,p - vec3(.2,-.6,.2),.12,2);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.2,-.6,-.2),.12,2);\n    \n    dInfo = MixSphereInfo(dInfo,p - vec3(0, 0,-.6),.1,3);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.25, .25,-.6),.1,3);\n    dInfo = MixSphereInfo(dInfo,p - vec3(.25, -.25,-.6),.1,3);\n    \n    dInfo = MixSphereInfo(dInfo,p - vec3(.2, .2,.6),.1,4);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.2, .2,.6),.1,4);\n    dInfo = MixSphereInfo(dInfo,p - vec3(.2, -.2,.6),.1,4);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.2, -.2,.6),.1,4);\n    \n    dInfo = MixSphereInfo(dInfo,p - vec3(.6, 0,0),.1,5);\n    dInfo = MixSphereInfo(dInfo,p - vec3(.6, .25,.25),.1,5);\n    dInfo = MixSphereInfo(dInfo,p - vec3(.6, -.25,.25),.1,5);\n    dInfo = MixSphereInfo(dInfo,p - vec3(.6, .25,-.25),.1,5);\n    dInfo = MixSphereInfo(dInfo,p - vec3(.6, -.25,-.25),.1,5);\n    \n    dInfo = MixSphereInfo(dInfo,p - vec3(-.6,.3,.2),.1,6);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.6,.3,-.2),.1,6);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.6,0,.2),.1,6);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.6,0,-.2),.1,6);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.6,-.3,.2),.1,6);\n    dInfo = MixSphereInfo(dInfo,p - vec3(-.6,-.3,-.2),.1,6);\n\n    return dInfo;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side) {\n\tvec2 dO= vec2(0.,1.);\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO.x;\n        vec2 dInfo = GetDist(p);\n        float dS = dInfo.x * side;\n        dO.x += dS;\n        dO.y = dInfo.y;\n        if(dO.x>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return  dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDist(p).x - \n        vec3(GetDist(p-e.xyy).x, GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nvec3 RandomRotate(vec3 ro,float t) {\n    vec3 r = ro;\n    r.yz *= Rot(sin(t*3.434)*PI+1.);\n    r.xz *= Rot(-cos(t* 432.434)*TAU);\n    r.xy *= Rot(sin(t* 432.434)*TAU);\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 * iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    vec3 ro = vec3(0, 3, -3);\n    \n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    \n    vec3 col =  texture(iChannel0,rd).rgb;\n\n    vec2 dInfo = RayMarch(ro, rd,1.);\n    float d = dInfo.x;\n    float IOR = 1.45;  // index of refraction\n     \n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        vec3 refOutSide = texture(iChannel0, r).rgb;\n        \n        vec3 rdIn = refract(rd, n, 1./IOR); // ray dir when entering\n        \n        vec3 pEnter = p - n * SURF_DIST * 3.;\n        vec2 dIn = RayMarch(pEnter, rdIn, -1.); // inside the object\n        \n        vec3 pExit = pEnter + rdIn * dIn.x; // 3d hit of exit\n        vec3 nExit = -GetNormal(pExit); //normal of surface.. orientation\n        \n        vec3 relTex = vec3(0);\n        vec3 rdOut  = vec3(0);\n        \n        float abb = .01;\n         \n        // red \n        rdOut = refract(rdIn, nExit, IOR-abb);\n        if(length(rdOut) == 0.) rdOut = reflect(rdIn,nExit);\n        relTex.r = texture(iChannel0,rdOut).r;\n        \n        // green\n        rdOut = refract(rdIn, nExit, IOR);\n        if(length(rdOut) == 0.) rdOut = reflect(rdIn,nExit);\n        relTex.g = texture(iChannel0,rdOut).g;\n        \n        //blue\n        rdOut = refract(rdIn, nExit, IOR+abb);\n        if(length(rdOut) == 0.) rdOut = reflect(rdIn,nExit);\n        relTex.b = texture(iChannel0,rdOut).b;\n        \n        float dens = .1;\n        float optDist = exp(-dIn.x * dens); \n        \n        relTex = relTex * optDist;// * vec3(1., .05, .2);\n        \n        float fresnel = pow(1. + dot(rd,n), 5.);\n        \n        col = mix(relTex, refOutSide, fresnel);\n        \n        float blackMask = step(.5,dInfo.y);\n        float redMask = step(dInfo.y, -.5);\n        \n        col -= vec3(blackMask,blackMask,blackMask) * .7;\n        col -= vec3(0,redMask,redMask);\n        \n        blackMask = step(.5,dIn.y);\n        redMask = step(dIn.y, -.5);\n        \n        col -= vec3(blackMask,blackMask,blackMask) * .2;\n        col -= vec3(0,redMask,redMask) * .2;\n        \n        \n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}