{"ver":"0.1","info":{"id":"3l3XR7","date":"1580585432","viewed":749,"name":"Temporal Wavelet upscaling","username":"stduhpf","description":"A Wavelet based method to have efficient temporal upscaling. You can't upscale any image like that, You need to know the jittered position of each pixel of the original image to get that result. (the jitter can also be only temporal)","likes":16,"published":1,"flags":32,"usePreview":0,"tags":["temporal","taa","upscaling"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv;\n\n    vec3 c =(fragCoord.x<iResolution.x*(.5-.5*sin(iTime)))?\n        texture(iChannel1,RENDERSCALE*fragCoord/iResolution.xy).rgb:\n        texture(iChannel0,fragCoord/iResolution.xy).rgb;\n\n    fragColor = vec4(c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"nearest","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"//warning: iChannel0 must be either linear or nearest, NOT mipmap, mipmap breaks it\n\nvoid mainImage( out vec4 O, vec2 I )\n{\n     O = vec4(0);\n    if(I.x<iResolution.x*RENDERSCALE && I.y<iResolution.y*RENDERSCALE){\n\n    vec2 h = fract(bayer16(I)+float(iFrame)/vec2(phi2sq,phi2));\n    \n    vec2 off = h;\n        I=floor(I)+off;\n        \n    O = texture(iChannel0,I/(iResolution.xy*RENDERSCALE));\n\t}\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"#define dot2( a) dot(a,a)\n#define sinc(x) (sin(x)/x)\n\nfloat lacnzos(float x,float s){\n    float xpi = acos(-1.)*x;\n    float xpis = s*xpi;\n    return x==0.?1.:sinc(xpi)*sinc(xpis);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 I2 = RENDERSCALE*I;\n    \n    //sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n\n    \n    //filters parameters :\n    const float k = 80.; //wavelet with parameter (it's a gaussian bell curve)\n    const int kernell = 1;  //it can be usefull to have kernell size above 1 for low value of k\n    //kernell = 0 can work (kind of) but i don't recommand\n    float s = min(acos(-1.)/k*float(iFrame),15.); //importance of the temporal component\n    //s initialized at 0 means no temporal componnent,\n    //but high values can induce ghosting on moving images, especially with high values of k\n    \n    O=texture(iChannel1,I/iResolution.xy)*s; //data from previous frame\n    if(iFrame==0)O-=O;\n    \n    for(int x=-kernell; x<=kernell; x++){\n        for(int y=-kernell; y<=kernell; y++){\n            vec2 c = vec2(x,y);\n            vec2 off = fract(bayer16(I2+c)+float(iFrame)/vec2(phi2sq,phi2))+c;\n            //the offset is recalculated in this case but can also be passed through a texture\n            //and being read here\n            \t#if 1\n            \t//larger kernell if no temporal data to avoid dark spots\n            float w = exp2(-(iFrame==0?.25/RENDERSCALE:k)*dot2(off-fract(I2)));\n            \t#else \n            \t\t//sinc-based variant\n                float w = lacnzos(k*length(off-fract(I2)),float(kernell+1));\n            #endif\n            vec4 t = texture(iChannel0,(I2+c)/iResolution.xy);\n            \n            O+=t*w;\n            s+=w;\n    \t}\n    }\n    O=O/s;\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"float bayer2(vec2 a){\n    a = floor(a);\n    return fract( dot(a, vec2(.5, a.y * .75)) );\n}\n#define bayer4(a)   (bayer2( .5*(a))*.25+bayer2(a))\n#define bayer8(a)   (bayer4( .5*(a))*.25+bayer2(a))\n#define bayer16(a)  (bayer8( .5*(a))*.25+bayer2(a))\n#define RENDERSCALE (1./64.)\n\n//sequence from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nconst float phi2=1.32471795724474602596090885447809734; //root of X^3-X-1=0.\nconst float phi2sq=phi2*phi2;","name":"Common","description":"","type":"common"}]}