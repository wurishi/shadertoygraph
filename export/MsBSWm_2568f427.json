{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// Inspired by https://www.shadertoy.com/view/ldfSDN and by IÃ±igo Quilez's work on raymarcher shaders.\n\n#define second 0\n\n#define BUBBLE_COLOR \tvec3(0.0, 0.4, 1.0)\n#define COLOR_INTENSITY 0.2\n#define BUBBLE_ALPHA \t0.2\n#define NB_BUBBLE\t\t10.0\n\n#define MAXSTEP \t\t10.0\n\n\nvec3 wind;\nint seed = 42;\n\nfloat sphere(vec3 p, vec3 center, float r)\n{\n    return length(p - center) - r;\n}\n\n// A sphere with a distortion effect (as if wind deforms it).\nfloat bubble(vec3 p, vec3 center, float r)\n{\n    return sphere(p, center, r) + 0.15*sin(8.0*p.x+iTime)* 0.15*sin(8.0*p.y);\n}\n\nvec2 rand(float i)\n{\n    return vec2(sin(i), cos(i));\n}\n\nfloat map(vec3 p)\n{\n    float res = 1.0;\n    for (float i = 0.0; i < NB_BUBBLE; i++)\n    {\n        float d = bubble(p, vec3(0.04*sin(8.0*iTime/2.5 + i)+ cos(iTime/2.5+i), 0.04*cos(4.0*iTime/2.5 - i)+ cos(3.6*iTime/2.5+i), mod(iTime + i * (4.0 / NB_BUBBLE), 4.0) - 3.0) + wind, 0.2);\n        res = min(res, d);\n    }\n    return res;\n}\n\nvec3 normal(vec3 p)\n{\n    vec2 e = vec2(0.0001, 0.0);\n    return normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n                     \t  map(p + e.yxy) - map(p - e.yxy),\n                     \t  map(p + e.yyx) - map(p - e.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // bg\n    vec2 bg = p.xy;\n    \n    // wind\n    wind = vec3(0.0);//vec3(0.04*sin(8.0*iTime/2.5)+ cos(iTime/2.5), mod(iTime/2.5, 2.5) + 1.25, 0.0);\n    \n    // ray origin\n    vec3 ro = vec3(0.0, 0.0, 1.0);\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    // ray direction\n    vec3 cf = normalize(ta - ro);\n    vec3 cr = normalize(cross(cf, vec3(0.0,1.0,0.0)));\n    vec3 cu = normalize(cross(cr, cf));\n\tvec3 rd = normalize(p.x*cr + p.y*cu + 2.5*cf);\n    \n    float t = 0.0;\n    float h = 1.0;\n    for (int i = 0; i < 100; i++)\n    {\n        if (h < 0.00001 || t > MAXSTEP)\n            break;\n        h = map(ro + t * rd);\n        t += h;\n    }\n    \n    vec3 light = vec3(0.57735);\n    \n    // intersect a sphere\n    if (t <= MAXSTEP)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = normal(pos);\n        // Point light\n        vec3 col = vec3(0.8) * clamp(dot(n, light), 0.0, 1.0);\n        // Directional ligth\n        col += vec3(0.2, 0.3, 0.4) * clamp(pos.z, 0.0, 1.0);\n        // Ambiant ligth\n        col += vec3(0.1);\n        \n        // Color\n        col = mix(col, BUBBLE_COLOR, COLOR_INTENSITY);\n        \n        // Refraction\n        float idx = 1.4;\n        vec3 diff = refract(rd, n, 1./idx);\n        diff *= tan(acos(dot(diff, vec3(0.,0.,-1.0))))*(pos.z+diff.z);\n    \tcol = mix(texture(iChannel0, bg + diff.xy).rgb, col, BUBBLE_ALPHA).rgb;\n        \n        // Reflection\n        vec3 ref = reflect(rd, n);\n        \n        // Specular\n        float spec = pow(clamp(dot(light, ref), 0.0, 1.0), 16.0);\n        col += 1.0 * spec;\n        \n        fragColor = vec4(col, 1.0);\n    }\n    else\n    {\n        fragColor = texture(iChannel0, bg);\n    }\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsBSWm","date":"1412893551","viewed":623,"name":"3D bubble over 2D surface","username":"Kido_SoraKi","description":"It's the first shader i made, I'm trying to learn how things works.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["refraction","lens","water","bubble"],"hasliked":0,"parentid":"","parentname":""}}