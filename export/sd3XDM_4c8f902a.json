{"ver":"0.1","info":{"id":"sd3XDM","date":"1633296643","viewed":85,"name":"it is cool","username":"dog9789","description":"it is a circle that moves around","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["yo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// -- wobble2 by pdkl95 (2015) --\n\n#define TAU 6.283185307179586\n#define TAU_3 (TAU / 3.0)\n#define TAU_4 (TAU / 4.0)\n#define TAU_6 (TAU / 6.0)\n#define TAU_8 (TAU / 8.0)\n#define TAU_16 (TAU / 16.0)\n#define TAU_32 (TAU / 32.0)\n#define TAU_64 (TAU / 64.0)\n\n#define LAST_TIME_DELTA   (1.0/50.0)\n#define TS_MAG             3.4\n#define RV_MAG             0.0666\n#define RING_RADIUS        0.28\n#define RING_WIDTH         0.1\n#define RING_BORDER_WIDTH  0.01\n#define RIPPLE_MAG        85.0\n#define WOBBLE_MAG         0.02\n#define HUE_CYCLE_TIME     4.0\n\nvec3 rgb2hsv(in vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n    vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(in vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec2 rotate(in vec2 point, in float rads) {\n\tfloat cs = cos(rads);\n\tfloat sn = sin(rads);\n\treturn point * mat2(cs, -sn, sn, cs);\n}\t\n\nfloat rectify(in float x) {\n    return ((x + 1.0) * 0.5);\n}\n\nfloat crectify(in float c) {\n    return 1.0 - clamp(c, 0.0, 1.0);\n}\n\nfloat mkring(in float width, in float ringwidth, in vec2 obj_pos, in vec2 pos, in vec2 dir) {\n    float d = distance(obj_pos, pos);\n    float rnear = width - ringwidth;\n    float rfar = width + ringwidth;\n    if (d <= (rfar - RING_BORDER_WIDTH)) {\n        float cyl_fade =  ((sin(iTime * 0.1) + 1.0) / 2.0) * 0.7 + 0.05;\n        vec3 cyl_normal = vec3(vec2(obj_pos - pos), d);\n\n        vec3 cyl_light_normal = vec3(-1.0, -1.0, -1.0);\n\n        float cyl = (dot(cyl_normal, vec3(dir, -0.9)) * 0.12) +\n            (dot(cyl_normal, cyl_light_normal) * 0.09);\n\n        return cyl * (cyl_fade);\n    }\n    if (abs(d - rfar) < RING_BORDER_WIDTH) {\n        return 1.0;\n    }\n    float rfar2 = 2.0 * rfar;\n    if (d < rfar2) {\n        return (rfar2 - d /rfar2);\n        float rf2 = clamp(((d/4.0)/rfar2), 0.0, 1.0) / 8.0;\n        return rf2;\n    } else {\n        return 0.0;\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 position = (uv * 2.0) - 1.0;\n    position.y *= iResolution.y/iResolution.x;\n\n    float time_prev = iTime - LAST_TIME_DELTA;\n\n    float ts        = TS_MAG * iTime;\n    float ts_prev   = TS_MAG * time_prev;\n\n    vec2 spot_freq      = vec2(0.7, 0.4);\n    vec2 spot_amplitude = vec2(0.5, 0.3);\n\n    vec2 sfreq      = spot_freq + (sin(100.0 + ts)      * WOBBLE_MAG) / ts;\n    vec2 sfreq_prev = spot_freq + (sin(100.0 + ts_prev) * WOBBLE_MAG) / ts_prev;\n    vec2  spot      = vec2(spot_amplitude.x * sin(sfreq.x * ts),\n                           spot_amplitude.y * cos(sfreq.y * ts));\n    vec2  spot_prev = vec2(spot_amplitude.x * sin(sfreq_prev.x * ts_prev),\n                           spot_amplitude.y * cos(sfreq_prev.y * ts_prev));\n\n    float ring_radius = RING_RADIUS;\n    float ring_width  = RING_WIDTH;\n\n    vec2 mouse = iMouse.xy;\n    vec2 cmouse = (mouse * 2.0) - 1.;\n\n    float mwarp = ring_radius * 12.0;\n    float mdist = distance(spot, cmouse) + mwarp / 8.0;\n    float mfract = 1.01 - cos(TAU_64 - TAU_6 * ((mwarp - mdist) / mwarp));\n    float mforce = mix(0.0, mfract, step(mdist, mwarp));\n\n    vec2 mp = cmouse - position;\n    vec2 nmp = normalize(mp);\n    float dmp = distance(mouse, position);\n\n    vec2 mvec = mforce * (mwarp / 7.0) * nmp;\n\n    ring_radius = mix(ring_radius, ring_radius * 1.2,  mforce);\n    ring_width  = mix(ring_width,  ring_width  * 0.8,  mforce);\n    spot        = mix(spot,        spot        + (1.2 * mvec), mforce);\n    spot_prev   = mix(spot_prev,   spot_prev   + (2.2 * mvec), mforce);\n\n    vec2 pos = position;\n    pos -= mvec;\n\n    float mpd = 48.0 * (dmp/2.0 + 0.125);\n    \n    vec2 mpdvec = nmp / (mpd * mpd);\n    pos = pos - mpdvec;\n    \n    vec2 dir        = spot - spot_prev;\n\n    float d         = distance(spot,      pos);\n    float d_prev    = distance(spot_prev, pos);\n\n    float delta_d   = d - d_prev;\n\n    float ripple    = sin(ts + (delta_d * RIPPLE_MAG));\n    float rv        = RV_MAG * ripple;\n    float ringv = mkring(ring_radius + rv, ring_width, spot, pos, dir);\n\n    float tc = iTime * 5.0;\n\n    float hue_cycle = HUE_CYCLE_TIME;\n    float hue_time  = mod(iTime, hue_cycle);\n    float hue_fract = hue_time / hue_cycle;\n\n    vec3 top_color = mix(vec3(1.0, 1.0, 1.0), vec3(0.0, 0.0, 1.0), uv.x);\n    vec3 bot_color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), uv.x);\n    vec3 basecolor = mix(bot_color, top_color, uv.y);\n\t\n    vec3 hsvcolor = rgb2hsv(basecolor.rgb);\n    hsvcolor.x = fract(hsvcolor.x + hue_fract);\n    vec3 rcolor = hsv2rgb(hsvcolor);\n\n    vec3 c = vec3( crectify(sin(1.5 * tc)) * rcolor.r,\n                   crectify(cos(2.1 * tc)) * rcolor.g,\n                   crectify(sin(3.7 * tc)) * rcolor.b );\n\n    vec3 cmix = mix(c, rcolor, 1.0 - (ringv / 4.0));\n    vec3 outc = cmix * ringv;\n    float a = ringv + 0.185;\n\n    fragColor = vec4(outc, clamp(a, 0.0, 1.0));\n}\n\n","name":"Image","description":"","type":"image"}]}