{"ver":"0.1","info":{"id":"ldVczt","date":"1523012664","viewed":774,"name":"Dirty lens","username":"csterea","description":"Imitates a grid of dirty convergent lenses. Not physically accurate.\niChannel0 = the image which will be distorted\niChannel1 = noise texture used for glass unevenness\niChannel2 = dirt image","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["lens","effect","dirty"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","previewfilepath":"/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzn","filepath":"/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","previewfilepath":"/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GRID_SIZE\t\t\t0.4\n#define NOISE_AMOUNT\t\t0.01\n#define DIRT_AMOUNT\t\t\t0.3\n\n#define GRID_HALF_SIZE\t(GRID_SIZE * 0.5)\n\n#define M_PI 3.1415926535897932384626433832795\n\nvec2 ProjectCoordsSphere(vec2 normCoords)\n{\n    const float SPHERE_RADIUS_SQ = 1.0;\n    //z^2 = R^2 - (x^2 + y^2).\n    float z2 = SPHERE_RADIUS_SQ - dot(normCoords, normCoords);\n    if(z2 <= 0.0)\n        return normCoords;\n\n    //Project the 3D point(normCoords.x, normCoords.y, sqrt(z2)) onto the screen\n    //to emulate the sphere-like refraction.\n    vec2 outProjectedCoords = normCoords / sqrt(z2);\n\n    //Add an antialiasing step to avoid jagged edges on the lens.\n    const float AA_EDGE = 0.2;\n    if(z2 < AA_EDGE)\n    {\n        //Smooth transition of the squared z from 0 to AA_EDGE.\n        //Normalize this transition factor to the [0,1] interval.\n        float aaFactor = smoothstep(0.0, 1.0, z2 / AA_EDGE);\n        \n        //Perform another smooth transition between the projected coordinates and the original ones.\n        //When z is very small, the projected coordinates are very big and tend to opint to the same position,\n        //thus giving the edge of the lens a jagged appearance.\n        outProjectedCoords = mix(\n            normCoords, \n            outProjectedCoords,\n        \taaFactor);\n    }\n    \n    return outProjectedCoords;\n}\n\nvec2 ProjectCoordsWave(vec2 normCoords)\n{\n\tconst float MAX_RADIUS = 1.0;\n    float rad = sqrt(dot(normCoords, normCoords));\n    if(rad > MAX_RADIUS)\n        return normCoords;\n    \n    const float MIN_DEPTH = 0.4;\n    const float WAVE_INV_FREQ = 20.0;\n    const float WAVE_VEL = -10.0;\n    float z = MIN_DEPTH + \n        (MAX_RADIUS - MIN_DEPTH) \n        * 0.5 * (1.0 + sin(WAVE_INV_FREQ * rad + iTime * WAVE_VEL));\n//    if(z > 0.2)\n//        return normCoords;\n    return normCoords / z;\n}\n\nvec2 ProjectCoordsLogLens(vec2 normCoords)\n{\n    float z = -log(dot(normCoords, normCoords));\n    if(z <= 0.0)\n        return normCoords;\n\n    //Project the 3D point(normCoords.x, normCoords.y, sqrt(z2)) onto the screen\n    //to emulate the sphere-like refraction.\n    vec2 outProjectedCoords = normCoords / z;\n\n    //Add an antialiasing step to avoid jagged edges on the lens.\n    const float AA_EDGE = 0.2;\n    if(z < AA_EDGE)\n    {\n        //Smooth transition of the squared z from 0 to AA_EDGE.\n        //Normalize this transition factor to the [0,1] interval.\n        float aaFactor = smoothstep(0.0, 1.0, z / AA_EDGE);\n        \n        //Perform another smooth transition between the projected coordinates and the original ones.\n        //When z is very small, the projected coordinates are very big and tend to opint to the same position,\n        //thus giving the edge of the lens a jagged appearance.\n        outProjectedCoords = mix(\n            normCoords, \n            outProjectedCoords,\n        \taaFactor);\n    }\n    \n    return outProjectedCoords;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Get the oscillation factor.\n    vec2 oscDelta = vec2(\n        cos(iTime),\n        sin(iTime))\n         * sin(iTime * 0.3) * 0.2;\n    //vec2 oscDelta;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy + oscDelta;\n    \n    //Add a bit of noise offset to emulate an uneven glass surface.\n    vec3 noise3 = texture(iChannel1, uv).xyz;   \n    vec2 noiseOfs = (noise3.xy - 0.5) * NOISE_AMOUNT;\n    //vec2 noiseOfs = noise * sin(iTime) * 0.1;\n    \n    //Find the lens cell we're into.\n    vec2 gridCoordsRaw = uv / GRID_SIZE;\n    vec2 cellMiddlePos = (floor(gridCoordsRaw) * GRID_SIZE + GRID_HALF_SIZE) \n        - oscDelta;\n    vec2 cellDelta = (fract(gridCoordsRaw) - 0.5) * 2.0// [-1,1]\n\t    //+ noiseOfs\n        ; \n    \n    //Apply the lens distortion to the cell delta.\n    cellDelta = ProjectCoordsSphere(cellDelta) * GRID_HALF_SIZE;\n    //cellDelta = ProjectCoordsWave(cellDelta) * GRID_HALF_SIZE;\n    //cellDelta = ProjectCoordsLogLens(cellDelta) * GRID_HALF_SIZE;\n    \n    //Get the color from the lens distorted position.\n    vec2 srcTexCoord = cellMiddlePos + cellDelta\n\t\t+ noiseOfs\n        ;\n\n    vec3 texCol = texture(iChannel0, srcTexCoord).xyz;\n    vec3 dirtCol = texture(iChannel2, uv * 4.0).xyz \n        * (0.7 + 0.3 * dot(noise3, noise3))\n        ;\n    \n    vec3 col = mix(texCol, dirtCol, DIRT_AMOUNT);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}