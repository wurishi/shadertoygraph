{"ver":"0.1","info":{"id":"tdyBzK","date":"1607576657","viewed":471,"name":"Endless animation 01","username":"JacobC","description":"I watched this video https://www.youtube.com/watch?v=csLP4Q3XCzs so I wanted to recreated","likes":19,"published":1,"flags":0,"usePreview":0,"tags":["3d","light","animation","ao","reproduction"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define AA 1.\n#define R iResolution.xy\n#define T iTime\n#define Pi 3.141592\n\n//#define BLEED\n\n#define color vec3(.5, .7, 1)\n\nstruct mat\n{\n\tfloat z; // depth\n    vec3 c;  // color\n    float a; // ao\n    vec3 i;  // IL\n};\n\nvec3 camera(in vec2 p, in vec3 o, in vec3 t)\n{\n    vec3 w = normalize(o - t);\n    vec3 u = normalize(cross(vec3(0, 1, 0), w));\n    vec3 v = cross(w, u);\n    return p.x * u + p.y * v - w;\n}\n\nfloat box(in vec3 p, in vec3 s, in float k)\n{\n    p = abs(p) - (s - k);\n    return length(max(vec3(0), p)) - k;\n}\n\nmat2 rotate(in float a)\n{\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nfloat map(in float i , in float c, in float l, in float q)\n{\n    return 1. - 1. / (c + l * i + q * i * i);\n}\n\n// Cheap AO https://www.shadertoy.com/view/ttXfWX\n// Cheap IL 1 bounce fake https://www.shadertoy.com/view/WtSfzh\nmat Uop(in mat a, in mat b)\n{\n    float s = max(a.z, b.z);\n    float ao = map(s, 1., 44.8, 115.2);\n    return mat\n        (\n            min(a.z, b.z),\n            a.z < b.z ? a.c : b.c, \n            clamp(a.a * ao, 0., 1.),\n            a.i * mix(a.z > b.z ? a.c : b.c, vec3(1.), map(s, 1., 22.4, 57.6))\n        );\n}\n\n#define STEPS 99\n#define MIN_S .01\n#define MAX_S 99.\n\nmat scene(in vec3 p)\n{\n\t// Inclined cubes\n\tvec3 q = p;\n    float subSpace = sqrt(2.);\n    float offsetZ = floor(q.x / subSpace) * 1.;\n    q.x = mod(q.x, subSpace) - subSpace * .5;\n    q.xy *= rotate(45. * Pi / 180.);\n    q.z += offsetZ;\n    \n    mat b0 = mat(box(q, vec3(.5), .02), color, 1., vec3(1));\n\n\tq = p;\n    q.x -= sqrt(2.) - .05;\n    q.z -= .1;\n    float offsetZ2 = floor(q.x / subSpace) * 1.;\n    q.x = mod(q.x, subSpace) - subSpace * .5;\n    float bA = box(q - vec3(-sqrt(2.)*.5+.1, -.05, -offsetZ2), vec3(.05, .05, .55), .0);\n    \n    q = p;\n    q.x -= 1.52;\n    float offsetZ3 = floor(q.x / subSpace) * 1.;\n    q.x = mod(q.x, subSpace) - subSpace * .5;\n    float bB = box(q - vec3(0, -.05, -offsetZ3 + sqrt(2.) * .5 - 1.1), vec3(sqrt(2.), .05, .05), .01);\n    \n    mat bAB = mat(min(bA, bB), vec3(1.5), 1., vec3(1));\n    \n    // Cube animation\n    q = p;\n    float time = T;\n    float loop = mod(time, 1.);\n    float rotateBox = pow(loop, 3.) * floor(mod(time + 1., 2.)); \n    float moveBoxX = floor((time + 1.) * .5);\n  \tfloat z = floor(mod(T, 2.)) * loop;\n    float moveBoxZ = floor(T * .5) + pow(z, 4.);\n    float angle = rotateBox * Pi;\n    q.xy -= vec2(sqrt(2.) * moveBoxX - subSpace * .5, sqrt(2.) * .5);\n    q.z -= 1. - moveBoxZ;\n    q.xy *= rotate(-angle);\n    q.x += sqrt(2.) * .5;\n    q.xy *= rotate(45. * Pi / 180.);\n     \n    mat b1 = mat(box(q, vec3(.5), .0), vec3(1.5), 1., vec3(1));\n    \n    // Ground\n    q = p;\n    mat f = mat(q.y + .02, color, 1., vec3(1));\n    \n    mat r = Uop(b0, b1);\n    r = Uop(r, bAB);\n    r = Uop(r, f);\n    \n    // I guess still missing white edges computation for AO and IL\n    // That's why the discontinuity in the white cube\n    if (r.z < MIN_S)\n    {\n    \tq = p;\n        q.x = mod(q.x, subSpace) - subSpace * .5;\n        q.x -= sqrt(2.);\n        q.z += 1.;\n        q.xy *= rotate(45. * Pi / 180.);\n        q.z += offsetZ;\n\n        mat bL = mat(box(q, vec3(.5), .0), color, 1., vec3(1));\n        \n        q = p;\n        q.x = mod(q.x, subSpace) - subSpace * .5;\n        q.x += sqrt(2.);\n        q.z -= 1.;\n        q.xy *= rotate(45. * Pi / 180.);\n        q.z += offsetZ;\n\n        mat bR = mat(box(q, vec3(.5), .0), color, 1., vec3(1));\n        \n        r = Uop(r, bL);\n        r = Uop(r, bR);\n    }\n    \n    return r;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec2 e = vec2(.01, 0);\n    return normalize(scene(p).z - vec3(scene(p - e.xyy).z, scene(p - e.yxy).z, scene(p - e.yyx).z));\n}\n\nmat marcher(in vec3 o, in vec3 d)\n{\n    float t = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        mat s = scene(o + d * t);\n        t += s.z * .9;\n        if (s.z < MIN_S)\n            return mat(t, s.c, s.a, s.i);\n        if (t > MAX_S)\n            return mat(t, vec3(-1), -1., vec3(-1));\n    }\n    return mat(t, vec3(-1), -1., vec3(-1));\n}\n\nvoid mainImage(out vec4 O, in vec2 F)\n{\n\tvec2 st = F;\n    O = vec4(0,0,0,1);\n    for (float y = 0.; y < AA; y++)\n    {\n        for (float x = 0.; x < AA; x++)\n        {\n            vec2 n = vec2(x, y) / AA - .5;\n            vec2 uv = (st + n - R * .5) / R.y;\n\n            float aX = -1. + T * sqrt(2.) * .5;\n            float aZ = 5. - T * .5;\n            vec3 o = vec3(aX, 1.5, aZ);\n            vec3 d = camera(uv * .7, o, vec3(aX, .5, aZ-5.));\n\n            mat m = marcher(o, d);\n            if (m.a != -1.)\n            {\n                vec3 p = o + d * m.z;\n                vec3 n = normal(p);\n\n                vec3 light_pos = vec3(aX, 255., aZ);\n                vec3 light_dir = normalize(light_pos - p);\n\n                float diff = max(dot(n, light_dir), 0.);\n\n                #ifdef BLEED\n                    O.rgb += (diff + m.a * m.i) / 2. * m.c;\n                #else\n                    O.rgb += (diff + m.a) / 2. * m.c;\n                #endif\n            }\n            else\n                O.rgb += color;\n        }\n\t}\n\n    O.rgb = sqrt(O.rgb / (AA * AA));\n}","name":"Image","description":"","type":"image"}]}