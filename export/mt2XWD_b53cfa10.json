{"ver":"0.1","info":{"id":"mt2XWD","date":"1676108855","viewed":282,"name":"\"Origins of Magnetism\"","username":"Amirk","description":"Charge density depends on the frame of reference. Thus the electric field for a moving charge looks different from that of a stationary observer, who would contribute this velocity dependent force to a \"magnetic field\" in his frame of reference.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["relativity","lorentz","electricity","magnetism","retardation"],"hasliked":0,"parentid":"7sKBzz","parentname":"Relativistic Space Drive"},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nAt start there are equal positive and negative planar currents\nmoving in the opposite directions. \n\nPress A to move left.\n-->relative to you \n        positive charges move faster \n            -->their separation is lorentz transformed\n            -->positive charge density is increased\n        negative charges move slower\n            -->their separation is lorentz transformed\n            -->negative charge density is degreased\n\nTherefore the \"electric landscape\" is quite different in this a moving frame. \nIn particular the field outside the current region is no longer\nelectrically neutral.\n\n\nGENERALLY:\n\nIn Classical Electrodynamics\nmagnetism can be seen as a relativistic effect of electricity\n(at least as long as magnetic monopoles are not found). \n\nIn principle, since magnetic forces depend on the particles velocity,\nwe never need to account for any magnetic forces\nif we stay in the intantaneous rest frame of the moving particle.\n\nOf course in practice many things are easier to understand and calculate\nin a lab frame with both the electric and magnetic fields.\n*/\n\n#define MAX_ITER 1000.\n#define MAX_DIST 200.\n#define SURF .0001\n\n\nvec4 fourvel = vec4(0,0,0,1);\nvec4 position =vec4(0);\nvec4 boost=vec4(0,0,0,0);\nvec3 orientation=vec3(1,0,0);\nfloat dO;\n\n\n//retardation effect ON/OFF:\nfloat RETARD = 0.;\n//ray origin in the moving coords.\nvec4 RO, RD;\nvec2 m;\nmat4 TransformMatrix;\n\nvec3 col = vec3(0);\nfloat contractionFactorElectrons,contractionFactorPositrons;\n\nfloat eHalo=0.;float pHalo=0.;\n\nconst float strength =.01;\nconst float SIZE=1.2;\n\nconst vec3 initVel=vec3(0,0,.8);\n\n\n\nvoid updateVel(){\n    // Fetch the fourvelocity from the Buffer A\n    boost= texelFetch( iChannel0, ivec2(5,5), 0);\n    orientation=texelFetch( iChannel0, ivec2(6,6), 0).xyz;\n    fourvel=texelFetch( iChannel0, ivec2(0,0), 0 );\n}\n\nvoid updatePos(){\n    // Fetch the fourposition from the Buffer B\n    \n    position =texelFetch( iChannel1, ivec2(0,0), 0 );\n    vec4 cam=vec4(-20,0,0,0);\n    if(m!=vec2(0)){\n        cam.xy*=rot((m.y-.5)*PI);\n        cam.xz*=rot(-(m.x-.5)*2.*PI);    \n    }\n    position+=TransformMatrix*cam;\n}\n\n\nfloat nonRetardedField(vec4 displ, vec3 v){\n    \n    float beta = length(v)/c;\n    float c = dot(normalize(displ.xyz),normalize(v));\n    float proj = sqrt(1.-c*c);\n    \n    float E=abs(100.*(1.-beta*beta)/pow(1.-proj*proj*beta*beta,1.5)/dot(displ.xyz,displ.xyz));\n    float dd=abs(length(displ.xyz)-E*.1); \n    \n    //eHalo+= 40.*strength/(.1+dd); // *retardedPotential(q,vec3(.5,0,0));\n    \n    return E ;\n}\n\n/*\nfloat retardedField(vec4 rd, vec3 v){\n    \n    vec3 beta= v/c;\n    \n    float gamma=pow(1.-dot(beta,beta),-.5);\n    \n    vec3 n= normalize(rd.xyz);\n    return 100.*length( (1.-dot(beta,beta))*(n-beta)/pow(1.+dot(beta,n),3.)/dot(rd,rd) );\n}\n*/\n\nfloat sdElectrons(vec4 q){\n     vec3 displ=q.xyz-position.xyz;\n     q.xyz-=q.w*initVel;\n     q.xz=fract(q.xz*.2)*5.-2.5;\n     q.y-=2.5;  \n    \n\n    //from the electrons point of view\n    q=Lorentz(initVel)*vec4(q.xyz,0);\n\n    \n    float d=length(q.xyz)-SIZE;\n    eHalo+= 1.*strength/(.1+.1*d*d)/(1.+1.1*length(displ));\n    \n    return  d*.99/contractionFactorElectrons;\n}\n\nfloat sdPositrons(vec4 q){\n     vec3 displ=q.xyz-position.xyz;\n     q.xyz-=-q.w*initVel;\n     q.xz=fract(q.xz*.2)*5.-2.5;\n     q.y+=2.5;  \n \n    \n    //form the electrons point of view\n    q=Lorentz(-initVel)*vec4(q.xyz,0);\n    \n    \n    float d=length(q.xyz)-SIZE;\n    pHalo+= 1.*strength/(.1+.1*d*d)/(1.+1.1*length(displ));\n    \n    return d*.99/contractionFactorPositrons;\n}\n\nfloat sdGrid(vec4 q){\n    q.y+=7.;\n    float b=.5;\n    q.xz=fract(q.xz*.1)*10. -5.; //this creates the grid of reference cubes    \n    return  min(length(q.yz)-b,length(q.xy)-b)/gamma(fourvel.xyz/fourvel.w); //length(p.xyz)-rad; \n}\n\nfloat getDist(vec4 q){\n    float de= sdElectrons(q);\n    float dp =sdPositrons(q);\n    float smoothness=.01;\n    float dist=min(de,dp);   \n     \n     \n    return min(dist, sdGrid(q));\n}\n\n\n\nvec4 getRayDir(vec2 uv, vec4 lookAt, float zoom){\n\n    vec3 f= normalize(lookAt.xyz);\n    vec3 r= normalize(cross(vec3(0,1,0),f));\n    vec3 u= cross(f,r);\n    \n    return vec4(normalize(f*zoom+uv.x*r+uv.y*u),lookAt.w/c);\n\n    //the w-component determines how we look into past/future/present.\n}\n\n\nfloat RayMarch(vec4 ro, vec4 rd, float side){\n    dO=0.;\n    float i=0.;\n   while(i<MAX_ITER){\n      vec4 p= ro+dO*rd; //if rd.w =-c we look back in time as we march further away\n      \n      float dS=side*getDist(p); \n     // halo+= .01*dS/(.1+ dS*dS);\n\n      dO+=dS;\n  \n      if(dO>MAX_DIST||dS<SURF){\n          break;\n      }\n      i++;\n    } \n    \n      return dO;\n}\n\nvec3 getNormal(vec4 p){\n   vec2 e= vec2(0.01,0);\n   float d=getDist(p);\n   vec3 n = d-vec3(getDist(p- e.xyyy),getDist(p- e.yxyy),getDist(p- e.yyxy));\n   \n   return normalize(n);\n}\n\nvoid getMaterial(vec4 q){\n    vec4 qq=q;\n    qq-= position;\n  //  qq=inverse(TransformMatrix)*qq;//vec4(qq.xyz,0);\n    \n    vec4 init4vel=Lorentz(initVel)*vec4(0,0,0,1);\n    vec3 v=init4vel.xyz/init4vel.w;\n    \n    if(sdElectrons(q)<.001){\n        col=vec3(.01,.01,.5); \n        \n        \n        float E=abs(nonRetardedField(qq,v));\n        \n        \n        col*=E*20.;\n        \n        vec4 init4vel=Lorentz(-initVel)*vec4(0,0,0,1);\n        vec4 relative= inverse(TransformMatrix)*init4vel;\n        vec3 vr= relative.xyz/relative.w; //velAdd(initVel,fourvel.xyz/fourvel.w); \n        \n        col*=gamma(vr)*.2;\n        col.rg=clamp(col.rg,0.,.5);\n        \n       \n    }\n    else if(sdPositrons(q)<.001){\n        col=vec3(.5,.01,.01);\n         \n        float E=abs(nonRetardedField(qq,-v));\n        \n        \n        col*=E*20.;\n        \n        vec4 init4vel=Lorentz(initVel)*vec4(0,0,0,1);\n        vec4 relative= inverse(TransformMatrix)*init4vel;\n        vec3 vr= relative.xyz/relative.w; //velAdd(initVel,fourvel.xyz/fourvel.w);  \n        \n        col*=gamma(vr)*.2;\n        col.gb=clamp(col.gb,0.,.5);\n       \n       \n    }\n    else{\n        col= vec3(0,.5,0);\n        col/=(1.+.001*dot(qq,qq));\n    }\n}\n\n\nmat4 getTransform(){\n    mat4 M= mat4(1,0,0,0,\n                 0,1,0,0,\n                 0,0,1,0,\n                 0,0,0,1);\n    if(iFrame>10){\n        for(int i=1; i<=4; i++)\n           for(int j=1; j<=4; j++)\n              M[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n    }\n    return M;\n}\n\n\n#define C(c) U.x-=.5; O+= char(U,c)\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel2, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 text( out vec4 O, vec2 uv )\n{\n    O = vec4(0.0);\n    uv /= iResolution.y;\n    vec2 position = vec2(.0,.9);\n    float FontSize = 6.;\n    vec2 U = ( uv - position)*64.0/FontSize;\n   C(85);C(115);C(101);C(32);C(109);C(111);C(117);C(115);C(101);C(43);\n   \n   C(87);C(65);C(83);C(68);\n   C(32);C(32);C(32);C(32);\n   float beta= length(fourvel.xyz)/c;\n   float gamma = pow(1.-beta*beta,-.5);\n   C(115);C(112);C(101);C(101);C(100);C(32);\n   C(46);C(48+int(floor(10.*length(fourvel.xyz)/fourvel.w/c))); C(99);\n   \n   U=( uv - position)*64.0/FontSize+vec2(0,1);\n   \n   C(83);C(80);C(65);C(67);C(69); \n   C(32);\n   C(84+32);C(79+32);\n   C(32);\n   C(82+32);C(69+32);C(84+32);C(65+32);C(82+32);C(68+32);\n   \n   return O.xxxx;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    \n    RETARD=texelFetch(iChannel3, ivec2(32, 0), 0).x; \n    \n    updateVel();\n    //coordinate transform:  \n    TransformMatrix=getTransform();\n    updatePos();\n    \n    //ray's spacetime origin represented in \"stationary coordinates\":\n    RO=position;\n    float zoom= 1.;\n    \n    //four-direction in our moving coords:\n    vec4 lookAt;\n    if(RETARD>0.) //what we actually see as light reaches our eyes:\n        lookAt = vec4(c, 0, 0, -1);\n    else //the \"instantaneous geometry\" of spacetime/coordinates: \n        lookAt = vec4(c, 0, 0, 0);\n    \n    \n    \n    if(m!=vec2(0)){\n        lookAt.xy*=rot((m.y-.5)*PI);\n        lookAt.xz*=rot(-(m.x-.5)*2.*PI);\n    }\n      \n    //ray in our moving coords:\n    vec4 ray= getRayDir(uv, lookAt, zoom);\n    \n        \n    \n    \n    //ray direction from moving coords to stationary coords:\n    RD= TransformMatrix*ray; \n    \n    \n    contractionFactorElectrons=abs(dot(fourvel,vec4(-initVel, c)*gamma(initVel)))+2.*RETARD;\n    contractionFactorPositrons=abs(dot(fourvel,vec4(initVel, c)*gamma(initVel)))+2.*RETARD;\n   \n    \n    \n    //RAYMARCH IN SPACETIME calculated in stationary coordinates:\n    vec4 p=RO;          \n    \n    float d= RayMarch(p, RD, 1.);\n    \n    \n     if(d<MAX_DIST){ //if we hit an object:\n          p= p+ d*RD;\n          \n          getMaterial(p);\n\n          vec3 n= getNormal(p);\n      \n          float dif= dot(n, normalize(vec3(0,2,0)))*.4+.5;\n         // col=max(col*.5,col/length(d*RD)/.2);\n          col*=dif*dif;    \n       \n                \n    }\n\n    col.xyz+=text(fragColor, fragCoord).xyz;\n\n    fragColor = vec4(col,1.0)+(eHalo-pHalo)*vec4(0,.0,1,1)+(pHalo-eHalo)*vec4(1,.0,0,1);\n       \n}\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"const float frames = 70.;\n\n\n#define t float(iFrame)/frames\n#define PI 3.14159265359\n\nconst float c=1.;//Not sure if everything works if you change c.\n\nfloat beta(vec3 vel){\n     return   length(vel)/c;   \n}\n\nfloat gamma(vec3 vel){\n     float beta= beta(vel);\n     return  pow(1.-beta*beta,-.5);   \n}\n\nmat4 Lorentz(vec3 v){\n     \n     float gamma = gamma(v);\n    \n    float v2=dot(v,v);\n        \n    return mat4(1.+(gamma-1.)*v.x*v.x/v2, (gamma-1.)*v.x*v.y/v2, (gamma-1.)*v.x*v.z/v2, -gamma*v.x/c,\n                 (gamma-1.)*v.y*v.x/v2, 1.+(gamma-1.)*v.y*v.y/v2, (gamma-1.)*v.y*v.z/v2, -gamma*v.y/c,\n                 (gamma-1.)*v.z*v.x/v2, (gamma-1.)*v.z*v.y/v2, 1.+(gamma-1.)*v.z*v.z/v2, -gamma*v.z/c ,\n                 -gamma*v.x/c, -gamma*v.y/c, -gamma*v.z/c,   gamma);                            \n}\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nvec3 velAdd(vec3 v, vec3 u){\n    float beta= length(v)/c;;   \n    float gamma=pow(1.-dot(beta,beta),-.5);\n        \n    \n    return 1./(1.+dot(u,v)/(c*c))*( v-u/gamma+gamma/(c+c*gamma)*dot(u,v)*v );   \n}\n\n\nmat4 F(vec3 E, vec3 B){\n    return mat4(0, -E.x, -E.y,-E.z,\n                E.x,  0, -B.z, B.y,\n                E.y, B.z,   0,-B.x,\n                E.z, -B.y, B.x,  0);\n}\n\n\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A  = 65;\nconst int KEY_W  = 87;\nconst int KEY_D =68;\nconst int KEY_S  = 83;\n\n\nconst float dt = .01;\n\nvec2 m;\n\nvec3 handleKeyboard() {     \n    if(iMouse.xy==vec2(0))\n         m = vec2(.5);\n    else{\n        m = (iMouse.xy-.5)/iResolution.xy;\n    } \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec3 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec3(0, 0,1)\n    +texelFetch(iChannel1, ivec2(KEY_A, 0), 0).x * vec3(0, 0,1);\n    vec3 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec3(1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_W,0), 0).x * vec3(1, 0,0);\n    vec3 right = texelFetch(iChannel1, ivec2(KEY_D, 0), 0).x * vec3(0, 0,-1)\n    + texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec3(0, 0,-1);\n    vec3 down = texelFetch(iChannel1, ivec2(KEY_S, 0), 0).x * vec3(-1, 0,0)\n    +texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec3(-1, 0,0);\n    \n    vec3 acceleration=(left +up + right +down ) ;\n   \n    // steer with mouse\n      //  acceleration.xy*=rot((m.y-.5)*PI);\n      //  acceleration.xz*=rot(-(m.x-.5)*2.*PI);\n    \n    return acceleration*c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //coordinates of the boost are in rockect coordinates\n    vec3  boost=vec3(0,0,0);\n    vec3 orientation=vec3(1,0,0);\n    \n    boost = handleKeyboard();\n    orientation = texelFetch( iChannel0, ivec2(6, 6), 0).rgb;\n    \n    \n    //orientation is for the rockets alignment\n    orientation +=(boost-orientation)*.01;\n    if(ivec2(fragCoord)==ivec2(6,6))\n             fragColor= vec4(orientation,0);\n             \n    //this will transform coordinates from rockets frame to stationary\n    mat4 TransformMat = mat4(1,0,0,0,\n                        0,1,0,0,\n                        0,0,1,0,\n                        0,0,0,1);\n                                           \n    \n    if(boost==vec3(0)){ //if no keys are pressed we just copy from the previous frame\n        \n        fragColor= texelFetch( iChannel0, ivec2(fragCoord), 0);\n        if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(texelFetch( iChannel0, ivec2(5, 5), 0).rgb,0);\n        }\n        if(iFrame<10){\n            if(ivec2(fragCoord)==ivec2(0,0)){\n                 vec4 fourvel = TransformMat*vec4(0,0,0,1); \n                 fragColor= fourvel;          \n            }\n            else if(ivec2(fragCoord)==ivec2(5,5)){\n            fragColor= vec4(boost,0);\n            }else if(ivec2(fragCoord)==ivec2(6,6)){\n            fragColor= vec4(orientation,0);\n            }\n            for(int i=1; i<=4; i++)\n                if(ivec2(fragCoord)==ivec2(i,i))\n                    fragColor.r=1.;\n        }\n    }else{\n        //boost/= texelFetch( iChannel0, ivec2(0, 0), 0).w;\n        //next the boost transform\n        mat4 NextBoost= Lorentz(-boost*dt);\n                        \n        if(iFrame>10){\n            for(int i=1; i<=4; i++)\n                for(int j=1; j<=4; j++){\n                     TransformMat[i-1][j-1]=texelFetch( iChannel0, ivec2(i, j), 0).r;\n                 }  \n        }\n    \n        //how to transform to stationary coords\n         TransformMat=TransformMat*NextBoost;\n\n        vec4 fourvel =TransformMat*vec4(0,0,0,1);\n        \n        if(ivec2(fragCoord)==ivec2(0,0)){\n              \n             fragColor= fourvel;          \n        }else if(ivec2(fragCoord)==ivec2(5,5)){\n             fragColor= vec4(boost,1);\n        }else{\n            //StoreMatrix:\n            for(int i=1; i<=4; i++)\n                for(int j=1; j<=4; j++)\n                    if(ivec2(fragCoord)==ivec2(i,j)){\n                        fragColor.r=TransformMat[i-1][j-1];\n                        }\n        }\n     }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"\n\n//proper time -step:\nconst float dt=.05;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // four position represented in stationary coords:\n    vec4 pos = texelFetch( iChannel1, ivec2(0, 0), 0);\n   \n    // fourvel represented in stationary coords:\n    vec4 fourvel = texelFetch( iChannel0, ivec2(0, 0), 0);\n    \n   // float gamma=fourvel.w/c;\n    \n    \n    \n    //four position represented in stationary coordinates:\n    pos += fourvel*dt;\n\n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = pos;\n}","name":"Buffer B","description":"","type":"buffer"}]}