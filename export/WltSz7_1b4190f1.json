{"ver":"0.1","info":{"id":"WltSz7","date":"1580728339","viewed":1189,"name":"Basic : Voronoi Tracking","username":"Gijs","description":"Working on de-obfusticating the work by FabriceNeyret2 and rory618. It takes about 2 seconds to stabilize. Use your mouse to create some repulsion. The voronoi field propagates with 1 pixel per frame; if particles go way faster than this it breaks.","likes":67,"published":1,"flags":32,"usePreview":0,"tags":["2d","voronoi","simulation","particles"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//returns the ids of the four closest particles from the input\nivec4 getClosest(ivec2 xy){\n    return ivec4(texelFetch(iChannel1, xy, 0));\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 locFromID(int id){\n    int width = int(iResolution.x);\n    return ivec2( id % width, id / width);\n}\n\n//get the particle corresponding to the input id\nvec4 getParticle(int id){\n    return texelFetch(iChannel0, locFromID(id), 0);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0);\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = getClosest(ivec2(fragCoord));\n    \n    //draw the particles\n        for(int i = 0; i < 4; i++){\n            //get the particles position\n            int id = ids[i];\n            vec2 pos = getParticle(id).xy;\n\n            //get the distance to the particle\n            float d = distance(fragCoord,pos);\n\n            //color it\n            fragColor += .3/(d*d);\n        }\n    \n    //draw voronoi outlines\n        //get the position of the closest particle\n    \tvec2  p1 = getParticle(ids.x).xy;\n        //get the position of the second closest particle\n\t\tvec2  p2 = getParticle(ids.y).xy;\n        //get the distance to voronoi edge\n        float r = dot(fragCoord-(p1+p2)/2.,normalize(p2-p1));\n        fragColor += smoothstep(2.,0.,abs(r))*.3;\n    \n    //fragColor += vec4(ids/float(PARTICLES));\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The code is not optimized for speed; it turns out programming with integers can be slow on some GPU's.\n// The reason I still use them is readability of the code.\n\n\n//amount of particles\nconst int PARTICLES = 1000; \n\n//percentage of maximum allowed speed\nconst float SPEED = 1.;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\n\n//returns the ids of the four closest particles from the input\nivec4 getClosest(ivec2 xy){\n    return ivec4(texelFetch(iChannel1, xy, 0));\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 locFromID(int id){\n    int width = int(iResolution.x);\n    return ivec2( id % width, id / width);\n}\n\n//get the particle corresponding to the input id\nvec4 getParticle(int id){\n    return texelFetch(iChannel0, locFromID(id), 0);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int id = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    if(id>=PARTICLES) return;\n    \n    vec4 prev = texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    vec2 pos = prev.xy;\n    vec2 vel = prev.zw;\n     \n    if(iFrame==0){\n       \t//pick a \"random\" starting position\n        float h1 = hash(id);\n        float h2 = hash(int(h1*41343.));\n        pos = vec2(h1,h2)*iResolution.xy;\n    }\n\n    //gather forces\n    vec2 force = vec2(0);\n    \n        //friction\n        force -= vel*0.3;\n\n        //interaction\n        if(iMouse.z > 0.){\n            vec2 delta = pos-iMouse.xy;\n            float dis = length(delta);\n            force += delta/(dis*dis) * 10.;\n        }\n\n        //repulsion from others\n        ivec4 closest = getClosest(ivec2(pos));\n        for(int i = 0; i < 4; i++){\n            int cid = closest[i];\n            if(cid==id) continue;\n            \n            vec2 delta = pos-getParticle(cid).xy;\n            float dis = length(delta);\n            force += delta /(dis*dis*dis) * 30.;\n        }\n    \n    \t//repulsion from walls\n    \tvec2 dis = max(iResolution.xy-pos, vec2(1));\n    \tforce -= 1./(dis*dis) * 10.;\n    \t     dis = max(pos, vec2(1));\n    \tforce += 1./(dis*dis) * 10.;\n\n    //integrate forces\n    vel += force;\n    \n    //cap velocity at max speed\n    float dv = length(vel);\n    if(dv>SPEED) vel *= SPEED/dv;\n    \n    //integrate velocity\n    pos += vel;\n    \n    fragColor = vec4(pos,vel);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\n//returns the ids of the four closest particles from the input\nivec4 getClosest(ivec2 xy){\n    return ivec4(texelFetch(iChannel1, xy, 0));\n}\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 locFromID(int id){\n    int width = int(iResolution.x);\n    return ivec2( id % width, id / width);\n}\n\n//get the particle corresponding to the input id\nvec4 getParticle(int id){\n    return texelFetch(iChannel0, locFromID(id), 0);\n}\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = getParticle(id).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e20);\n    \n    //get all known closest particles from old self and neighbours  \n    ivec4 old   = getClosest( iFragCoord + ivec2( 0, 0) );      \n    ivec4 east  = getClosest( iFragCoord + ivec2( 1, 0) );\n\tivec4 north = getClosest( iFragCoord + ivec2( 0, 1) );\n    ivec4 west  = getClosest( iFragCoord + ivec2(-1, 0) );\n    ivec4 south = getClosest( iFragCoord + ivec2( 0,-1) );\n    \n    //collect them in a array so we can loop over it\n    ivec4[5] candidates = ivec4[5](old, east, north, west, south); \n    \n    for(int i=0; i<5; i++){\n        for(int j=0; j<4; j++){\n            int id = candidates[i][j];\n            float dis2 = distance2Particle(id, fragCoord);\n            insertion_sort( new, dis, id, dis2 );\n        }\n    }\n    \n    for(int k = 0; k < 1; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, fragCoord) );\n    }\n    \n    fragColor = vec4(new); \n    \n}","name":"Buffer B","description":"","type":"buffer"}]}