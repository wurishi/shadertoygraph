{"ver":"0.1","info":{"id":"ftGyDt","date":"1662398540","viewed":68,"name":"Rolling waves of clouds (mouse)","username":"wad1m","description":"Raymarching rolling clouds and waves - use mouse to look around ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["waves","raymarch"],"hasliked":0,"parentid":"fdsXzs","parentname":"Rolling waves of clouds"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 120\n#define MAX_DIST 120.\n#define SURF_DIST .01\n\nfloat GetDistance(vec3 point) {\n\t\n    float texture = sin((iTime + point.x)*.5)*2.7+cos(point.z*2.5+sin(iTime)*5.)*.1+sin(point.x*5.+point.z*10.)*0.03;\n    float planeDist = point.y + texture*.5;\n    \n    float planeDist2 = -point.y + 3. + texture*.5;;\n    \n    return min(planeDist,planeDist2);\n}\n\nvec3 GetNormal(vec3 point) {\n  float distance = GetDistance(point);\n  vec2 e = vec2(.01,0);\n  \n  vec3 normal = distance - vec3(\n      GetDistance(point-e.xyy),\n      GetDistance(point-e.yxy),\n      GetDistance(point-e.yyx));\n  \n  return normalize(normal);\n}\n\nvec2 RayMarch(vec3 rayOrgin, vec3 rayDirection) {\n\tfloat distance=0.;\n    \n    int steps = MAX_STEPS; \n    int i = 0;\n    \n    for(i=0; i<steps; i++) {\n    \tvec3 point = rayOrgin + rayDirection * distance;\n        float surfaceDistance = GetDistance(point);\n        distance += surfaceDistance;\n        // Stop marching if we go too far or we are close enough of surface\n        if(distance>MAX_DIST || surfaceDistance<SURF_DIST) break;\n    }\n    \n    return vec2(distance,i);\n}\n\nfloat GetLight(vec3 point, vec3 normal, vec3 lightPos) {    \n  \n  vec3 direction = normalize(lightPos-point);\n  \n  float dif = clamp(dot(normal, direction), 0., 1.);\n  \n  float d = RayMarch(point+normal*.1, direction).x;\n  if ( d < length(lightPos-point)) dif *= .5;\n  \n  return dif;\n}\n\n// https://stackoverflow.com/a/62329542/2496170\nvec3 slerp(vec3 current, vec3 target, float maxAngle)\n{\n    // Dot product - the cosine of the angle between 2 vectors.\n    float dot = dot(current, target);     \n    // Clamp it to be in the range of Acos()\n    // This may be unnecessary, but floating point\n    // precision can be a fickle mistress.\n    dot = max( min( dot, 1.0 ) , -1.0 );\n    // Acos(dot) returns the angle between start and end,\n    // And multiplying that by percent returns the angle between\n    // start and the final result.\n    float delta = acos(dot);\n    float theta = min(1.0f, maxAngle / delta);\n    vec3 relativeVec = normalize(target - current*dot); // Orthonormal basis\n    vec3 slerped = ((current*cos(theta)) + (relativeVec*sin(theta)));\n    return slerped;\n}\n\n// https://docs.unity3d.com/Packages/com.unity.shadergraph@6.9/manual/Rotate-About-Axis-Node.html\n\nvec3 RotAboutAxis(vec3 In, vec3 Axis, float Degrees )\n{\n    float a = radians(Degrees);\n    float s = sin(a);\n    float c = cos(a);\n    float one_minus_c = 1.0 - c;\n    Axis = normalize(Axis);\n    mat3 rot_mat = mat3\n    (   one_minus_c * Axis.x * Axis.x + c, one_minus_c * Axis.x * Axis.y - Axis.z * s, one_minus_c * Axis.z * Axis.x + Axis.y * s,\n        one_minus_c * Axis.x * Axis.y + Axis.z * s, one_minus_c * Axis.y * Axis.y + c, one_minus_c * Axis.y * Axis.z - Axis.x * s,\n        one_minus_c * Axis.z * Axis.x - Axis.y * s, one_minus_c * Axis.y * Axis.z + Axis.x * s, one_minus_c * Axis.z * Axis.z + c\n    );\n    return (rot_mat * In);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // put 0,0 in the center\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n       \n    // camera   \n    vec3 rayOrgin = vec3(0, 1.5, 0);\n    \n    vec2 mx = ( vec2( iMouse.x , iMouse.y ) - .0 ) / 1000. ; \n    \n    vec3 rayDirection = normalize(vec3(uv.x , uv.y , 1));\n    \n    rayDirection = RotAboutAxis( rayDirection , vec3( 0, 1, 0 ) , iMouse.x );\n    rayDirection = RotAboutAxis( rayDirection , vec3( 1, 0, 0 ) , iMouse.y );\n    \n    vec2 d = RayMarch(rayOrgin, rayDirection);\n    \n    vec3 col = vec3(0.);\n    \n    vec3 lightPos = vec3(1, 1.5, 1);\n    \n    if (d.x < 120.) {\n        vec3 p = rayOrgin + rayDirection * d.x;\n        vec3 n = GetNormal(p);\n        float light = GetLight(p, n, lightPos);\n        // color\n        float dist = d.x/50.;\n        col = vec3(\n            0,\n            light-dist/1.5+(d.y*0.004),\n            light-dist/2.+(d.y*0.005)\n        );\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}