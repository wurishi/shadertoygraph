{"ver":"0.1","info":{"id":"3tXXDj","date":"1564221084","viewed":142,"name":"Mothership","username":"jblanper","description":"I play with the number of iterations of the loop inside the ray marching algorithm to get this \"fluid\" effect.","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raymarching","fractal"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float tt, g;\n\nmat2 rotate(float a) {\n  return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smin( float a, float b, float k ) {\n  float h = max( k-abs(a-b), 0.0 )/k;\n  return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\nfloat sphereSDF (vec3 p, vec3 c, float r) {\n  return length(c - p) - r;\n}\n\nfloat cubeSDF (vec3 p, vec3 c, vec3 dimensions, float borderRoundness) {\n  vec3 pos = abs(c - p) - dimensions;\n  return length(max(pos, 0.)) - borderRoundness + min(max(pos.x, max(pos.y, pos.z)), 0.);\n}\n\nvec2 map (vec3 p) {\n  //fractal\n    \n  float n = sin(tt * 6.) * .05 + .05;\n  for (int i=0; i<2; i++) {\n    p = abs(p) - vec3(4., 3., 5.);\n    //p = abs(p) - vec3(2., 1., 3.);\n\n    p.xz *= rotate(sin(tt - p.y + p.x) * n + .6);\n    p.yz *= rotate(cos(tt + p.x) * (n * .7) + 5.8);\n    p.xy *= rotate(cos(tt + p.z) * (n * 1.2) + 2.);\n    //p += length(p.yx * sin(tt) * .2 + .4) * .5;\n  }\n\n  p *= .7; // to scale fractal\n\n  // primitives\n  \n  float c1 = cubeSDF(abs(p) - vec3(length(p.yz) + .2, .1, .8), vec3(0.), vec3(.5, .2, .8), .05);\n  c1 += sin(p.x * 4.) * cos(p.y * 6. + sin(tt)) * sin(p.z * 3.) * .3;\n  float c2 = cubeSDF(abs(p) - vec3(.5, .3, 2.), vec3(0.), vec3(.3, .1, .6), .01);\n\n  vec2 t = vec2(smin(c1 * .1, c2 * .05, .5), 2.);\n  \n  p += sin(length(p) * 22. + tt * .2) * .04;\n  float c3 = cubeSDF(abs(p) - vec3(.3, .2, .2), vec3(2.), vec3(.2, .4, .3), .03) * .3;  \n  vec2 h = vec2(smin(c3 * .2, c2 * .3, 1.2), .1);\n  t = (t.x < h.x) ? t : h; // merge materials\n\n  return t / .8;\n}\n\nvec2 trace (vec3 ro, vec3 rd) {\n  const float MAX_DEPTH = 50.;\n  vec2 h, t = vec2(.1);\n\n  for (int i = 0; i < 268; i++) {\n    h = map(ro + rd * t.x);\n    if (h.x < .00001 || t.x > MAX_DEPTH) break;\n    t.x += h.x; t.y = h.y;\n  }\n  if (t.x > MAX_DEPTH) t.x = 0.;\n  return t;\n}\n\nvec3 getNormal (vec3 p) {\n  float d = map(p).x;\n  vec2 e = vec2(.01, 0.);\n\n  return normalize(d - vec3(\n    map(p - e.xyy).x,\n    map(p - e.yxy).x,\n    map(p - e.yyx).x));\n}\n\nstruct Material {\n  float ambient;\n  float diffuse;\n  float specular;\n};\n\nfloat getLight (vec3 lightPos, vec3 p, vec3 rd, float lightOcclusion, Material material) {\n  // https://www.shadertoy.com/view/ll2GW1\n  vec3 light = normalize(lightPos - p);\n  vec3 normal = getNormal(p);\n\n  // phong reflection\n  float ambient = clamp(.5 + .5 * normal.y, 0., 1.);\n  float diffuse = clamp(dot(normal, light), 0., 1.);\n  vec3 half_way = normalize(-rd + light);\n  float specular = pow(clamp(dot(half_way, normal), 0.0, 1.0), 16.);\n\n  return (ambient * material.ambient * lightOcclusion) +\n   (diffuse * material.diffuse * lightOcclusion) +\n   (diffuse * specular * material.specular * lightOcclusion);\n}\n\nvec3 getRayDirection (vec2 uv, vec3 rayOrigin, vec3 lookat, float zoom) {\n  // https://www.youtube.com/watch?v=PBxuVlp7nuM\n  vec3 forward = normalize(lookat - rayOrigin);\n  vec3 right = normalize(cross(vec3(0., 1., 0.), forward));\n  vec3 up = cross(forward, right);\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersection = center + uv.x * right + uv.y * up;\n  return normalize(intersection - rayOrigin);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  uv.x *= iResolution.x / iResolution.y;\n  tt = mod(iTime * .1, 100.);\n\n  // camera\n  vec3 ro = vec3(0., 0., 30. + sin(tt * 1.2) * 10.);\n  //vec3 ro = vec3(0., 0., 35.);\n  ro.xz *= rotate(tt * .25);\n  ro.yz *= rotate(tt * .5);\n  vec3 rd = getRayDirection(uv, ro, vec3(0.), 2.);\n\n  // color, fog and light direction\n  //vec3 ld = normalize(vec3(.5, .8, .5));\n  vec3 ld = vec3(5., 8., 3.);\n  vec3 fogColor = vec3(.1, .4, .5);\n  //vec3 fogColor = vec3(.2, .3, .8) * .1;\n  vec3 fog = fogColor * (.5 + (length(uv) - .3));\n  vec3 color = fog;\n\n  // scene\n  vec2 sc = trace(ro, rd);\n  float t = sc.x;\n\n  if (t > 0.) {\n    vec3 p = ro + rd * t;\n    vec3 normal = getNormal(p);\n    vec3 albido = vec3(.2, .3, .8) * 2.;//base color\n\n    if (sc.y > .9) {\n      albido = vec3(.8, .2, .3) * 2.;\n      color = getLight(ld, p, rd, 1.2, Material(0., .8, 1.)) * vec3(.3, .5, .2) * 2.;\n      color *= albido * 2.;\n    } else {\n      color = getLight(ld, p, rd, .5, Material(.7, .3, 4.5)) * vec3(.3, .5, .2) * 2.;\n      color /= albido * 3.;\n    }\n\n    // lightning\n    ld.xz *= rotate(tt * 10.);\n    color = mix(color, getLight(ro, p, rd, .5, Material(0., .7, 5.2)) * albido, .4);\n\n    color = mix(color, fog, 1. - exp(-.00006*t*t*t)); //gradient\n  } \n\n  fragColor = vec4(pow(color, vec3(.45)), 1.);\n}","name":"Image","description":"","type":"image"}]}