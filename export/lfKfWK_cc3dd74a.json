{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"vec3 pal(float t)\n{\n    return 0.5 + 0.5 * cos(vec3(0.0, 1.0, 2.0) + t * 3.14159 * 2.0);\n}\n\nfloat approxSDF(vec2 p)\n{\n    float d = 1e5;\n    for(int i=0; i<N_SPHERES; i++)\n    {\n        vec4 circle = texelFetch(iChannel0, ivec2(i,0), 0);\n        vec2 c = circle.xy;\n        float r = circle.z;\n        float distCircle = length(p - c) - r;\n        d = min(d, distCircle);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord / iResolution.xy)*2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y; \n\n    float dApprox = iFrame == 0 ? 1e5 : approxSDF(uv);\n    float sdf = gtSDF(uv);\n    float div = gtSDC(uv);    \n\n    float contour = smoothstep(0.01, 0.0, abs(fract(sdf*8.0)-0.5)-0.25);\n    vec3 col = mix(pal(sdf * 0.5 + 0.5), vec3(0.33), -0.125) * 0.55 + 0.3 * contour;\n    col = mix(col, col * 0.9 + 0.1, step(0.0, sdf));\n    col = mix(col, col * 0.5 + 0.5,step(0.5, div));   \n    col += smoothstep(0.01, 0.005, abs(sdf));\n    col += smoothstep(0.0075, 0.005, abs(dApprox));\n    \n    \n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"outputs":[{"channel":0,"id":"4dXGR8"}],"inputs":[{"channel":0,"type":"buffer","id":"4dXGR8","filepath":"/media/previz/buffer00.png","sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"code":"// TODO: Cache it in texture\nfloat getAvailableSpaceSDF(vec2 p, int currentIndex) {\n    float shapeSDF = gtSDF(p);\n    \n    for(int i = 0; i < currentIndex; i++) {\n        vec4 circle = texelFetch(iChannel0, ivec2(i, 0), 0);\n        \n        if(circle.z <= 0.0) continue;\n        \n        float currentCircleSDF = length(p - circle.xy) - circle.z;\n        \n        shapeSDF = max(shapeSDF, -currentCircleSDF);\n    }\n    \n    return shapeSDF;\n}\n\nvec2 availableSpaceSDG(vec2 pos, int currentIndex) {\n    float eps = 0.01;\n    vec2 n;\n    float d = getAvailableSpaceSDF(pos, currentIndex);\n    n.x = getAvailableSpaceSDF(vec2(pos.x + eps, pos.y), currentIndex) - d;\n    n.y = getAvailableSpaceSDF(vec2(pos.x, pos.y + eps), currentIndex) - d;\n\n    return n;\n}\n\nvec2 snapToMedialAxis(vec2 candidate, int currentIndex) {\n    vec2 pos = candidate;\n    float s = 0.035;\n    \n    for(int iter = 0; iter < 20; iter++) {\n        vec2 g = availableSpaceSDG(pos, currentIndex);\n        float mg = length(g);\n        if(mg < 1e-4) break; \n        \n        vec2 dir = g / mg;\n        vec2 newPos = pos - s * dir;\n        \n        float newSpaceSDF = getAvailableSpaceSDF(newPos, currentIndex);\n        float oldSpaceSDF = getAvailableSpaceSDF(pos, currentIndex);\n        \n        if(newSpaceSDF > 0.0 || newSpaceSDF > oldSpaceSDF) {\n            s *= 0.5;\n            if(s < 1e-6) break;\n            continue;\n        }\n        \n        pos = newPos;\n    }\n    \n    return pos;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    \n    if(fragCoord.y > 0.5) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    int circleIndex = int(fragCoord.x);\n    \n    if(circleIndex < 0 || circleIndex >= N_SPHERES) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    vec4 oldData = texelFetch(iChannel0, ivec2(circleIndex, 0), 0);\n    vec2 center = oldData.xy;\n    float radius = oldData.z;\n    \n    if(circleIndex > iFrame) {\n        fragColor = oldData;\n        return;\n    }\n    \n    int currentCount = 0;\n    for(int i = 0; i < N_SPHERES; i++) {\n        vec4 circle = texelFetch(iChannel0, ivec2(i, 0), 0);\n        currentCount += circle.z > 0.0 ? 1 : 0;\n    }\n    \n    srand(ivec2(fragCoord), iFrame);\n    if(circleIndex == iFrame && currentCount < N_SPHERES) {\n        float bestScore = -1.0;\n        vec2 bestPos = vec2(0.0);\n        \n        for(int c = 0; c < 32; c++) {\n            vec2 candidate;\n            bool foundValid = false;\n            float spaceSDF = 0.0;\n            \n            for(int tries = 0; tries < 10; tries++) {\n                candidate = vec2(frand(),frand()) * 2.0 - 1.0;\n                \n                spaceSDF = getAvailableSpaceSDF(candidate, circleIndex);\n                \n                if(spaceSDF < 0.0) {\n                    foundValid = true;\n                    break;\n                }\n            }\n            \n            if(!foundValid) continue; \n            \n            // More negative SDF indicates better packing\n            float score = -spaceSDF;\n            \n            // Attempt to snap the candidate to the medial axis\n            vec2 snapped = snapToMedialAxis(candidate, circleIndex);\n            float snappedSpaceSDF = getAvailableSpaceSDF(snapped, circleIndex);\n            float snappedScore = -snappedSpaceSDF;\n            \n            // Check if snapped position is better\n            if(snappedSpaceSDF < 0.0 && snappedScore > score) {\n                candidate = snapped;\n                score = snappedScore;\n            }\n            \n            // Keep the best scoring position\n            if(score > bestScore) {\n                bestScore = score;\n                bestPos = candidate;\n            }\n        }\n        \n        // Place the circle if a valid position is found\n        if(bestScore > MIN_RADIUS) {\n            center = bestPos;\n            radius = max(bestScore, MIN_RADIUS);\n        } else {\n            center = vec2(0.0);\n            radius = 0.0;\n        }\n    }\n    \n    fragColor = vec4(center, radius, 0.0);\n}\n","name":"Buffer A","description":"","type":"buffer"},{"outputs":[],"inputs":[],"code":"#define N_SPHERES       32\n#define MIN_RADIUS      0.02\n#define PI 3.14159265359\n\n\nint seed = 539458;\nint randInt() { seed = seed*0x343fd + 0x269ec3; return (seed>>16)&32767; }\nfloat frand() { return float(randInt())/32767.0; }\n\nvoid srand( ivec2 p, int frame ) {\n    int n = frame;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589; \n    n += p.y;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    n += p.x;\n    n = (n<<13)^n; n = n*(n*n*15731+789221)+1376312589;\n    seed = n;\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(k - abs(a - b), 0.0) / k;\n    return min(a, b) - h * h * k * 0.25;\n}\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdCapsule(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat sdBunny(vec2 p) {\n    p.y += 0.25;\n    \n    // Body\n    float body = sdCircle(p - vec2(0.0, 0.0), 0.35);\n    \n    // Head\n    float head = sdCircle(p - vec2(0.0, 0.45), 0.25);\n    \n    // Ears\n    float ear1 = sdCapsule(p, vec2(-0.15, 0.6), vec2(-0.15, 0.9), 0.08);\n    float ear2 = sdCapsule(p, vec2(0.15, 0.6), vec2(0.15, 0.9), 0.08);\n    \n    // Feet\n    float foot1 = sdCircle(p - vec2(-0.2, -0.3), 0.12);\n    float foot2 = sdCircle(p - vec2(0.2, -0.3), 0.12);\n    \n    // Tail\n    float tail = sdCircle(p - vec2(0.0, -0.275), 0.1);\n    \n    float bunny = smin(body, head, 0.05);\n    bunny = smin(bunny, ear1, 0.05);\n    bunny = smin(bunny, ear2, 0.05);\n    bunny = smin(bunny, foot1, 0.05);\n    bunny = smin(bunny, foot2, 0.05);\n    bunny = smin(bunny, tail, 0.05);\n    \n    return bunny;\n}\n\n\nfloat gtSDF(vec2 p)\n{\n    return sdBunny(p);\n}\n\n\nvec2 gtSDG(vec2 pos) {\n    float eps = 0.01;\n    vec2 n;\n    float d = gtSDF(pos);\n    n.x = gtSDF(vec2(pos.x+eps, pos.y)) - d;\n    n.y = gtSDF(vec2(pos.x, pos.y+eps)) - d;\n\n    return n;\n}\n\nfloat gtSDC(vec2 pos) {\n    float eps = 0.01;\n    \n    vec2 gx1 = gtSDG(vec2(pos.x - eps, pos.y));\n    vec2 gx2 = gtSDG(vec2(pos.x + eps, pos.y));\n    vec2 gy1 = gtSDG(vec2(pos.x, pos.y - eps));\n    vec2 gy2 = gtSDG(vec2(pos.x, pos.y + eps));\n    float invDenom =  50.0; // ((1.0 / eps) / 2.0);\n    \n    float div = ((gx2 - gx1).x + (gy2 - gy1).y) * invDenom;\n    return div;\n}","name":"Common","description":"","type":"common"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":true,"mFlagMusicStream":false},"info":{"id":"lfKfWK","date":"1734480434","viewed":313,"name":"SDF Circle Packing","username":"luckyballa","description":"Not optimized\n\nThis is packing algorithm that places circles within a defined shape by calculating the available space using Signed Distance Fields (SDF) and subtracting existing circles to prevent overlaps.","likes":15,"published":1,"flags":32,"usePreview":0,"tags":["sdf","circle","packing","medialaxis","medial"],"hasliked":0,"parentid":"","parentname":""}}