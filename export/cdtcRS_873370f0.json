{"ver":"0.1","info":{"id":"cdtcRS","date":"1695385576","viewed":64,"name":"The Catacombs - T0SHIII","username":"xXx_T0SHIII_xXx","description":"Something I got inspired to make after finding Inigo Quilez's masterpiece titled: \"Slisesix\". That's really what blew my mind with SDF's and Raymarching and got me very determined to achieve my shader goals.\n\nI appreciate any feedback/tip to improve! ","likes":5,"published":1,"flags":0,"usePreview":0,"tags":["3d","raytracing","noise","sdf","fbm","spooky","dark","inspiration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGRn","filepath":"/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","previewfilepath":"/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MIN_DIST 0.0\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define FOG_DEPTH 20.\n\n#define ZERO min(iFrame,0)\n\nconst vec3 COLOR_BACKGROUND = vec3(0.835, 1, 1);\n\nmat2 Rotate(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat hash( int n )\n{\n\tn = (n << 13) ^ n;\n    n = (n*(n*n*15731+789221)+1376312589)&0x7fffffff;\n    return 1.0 - float(n)*(1.0/1073741824.0);\n}\nfloat noise( vec3 p )\n{\n\tivec3 ip = ivec3(floor(p));\n     vec3 fp = fract(p);\n    vec3 w = fp*fp*(3.0-2.0*fp);\n    int n = ip.x + ip.y*57 + 113*ip.z;\n\treturn mix(mix(mix( hash(n+(0+57*0+113*0)),\n                        hash(n+(1+57*0+113*0)),w.x),\n                   mix( hash(n+(0+57*1+113*0)),\n                        hash(n+(1+57*1+113*0)),w.x),w.y),\n               mix(mix( hash(n+(0+57*0+113*1)),\n                        hash(n+(1+57*0+113*1)),w.x),\n                   mix( hash(n+(0+57*1+113*1)),\n                        hash(n+(1+57*1+113*1)),w.x),w.y),w.z);\n}\n\n// https://iquilezles.org/articles/fbm\nfloat fbm( vec3 p )\n{\n    // equivalent code, but compiles MUCH faster\n    float f = 0.0;\n    float s = 0.5;\n    for( int i=ZERO; i<4; i++ )\n    {\n        f += s*noise( p );\n        s *= 0.5;\n        p *= 2.0;\n    }\n    return f;\n}\n\nfloat PlaneSDF(vec3 p,vec3 rot, float modifier)\n{\n    return dot(p,normalize(rot)) - modifier;\n}\nfloat SphereSDF(vec3 p, float r)\n{\n    return length(p)-r;\n}\nfloat BoxSDF( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat Columns(vec3 p, float scale)\n{\n    vec3 cbPos = vec3(0,.5,0);\n    vec3 cbP = p-cbPos;\n    cbP.xz = mod(cbP.xz,10.)-5.;\n    scale = mix(.7,2.,smoothstep(0.,1.,cbP.y));\n    cbP.xz *= scale;\n    cbP.xz *= Rotate(smoothstep(0.,4.,cbP.y));\n    float b = BoxSDF(cbP, vec3(1.,7.,1.))/scale;\n    return b + 0.3*clamp(fbm(p * 3.), 0., 1.);\n}\nfloat Ceiling(vec3 p, float scale)\n{\n    vec3 sPos = vec3(5.,5.,5.);\n    vec3 sP = p - sPos;\n    sP.xz = mod(sP.xz,10.)-5.;\n    float s = SphereSDF(sP,7.);\n    s = abs(s)-.1;\n    vec3 pP = p - vec3(0,sPos.y+4.,0);   \n    float plane2 = PlaneSDF(pP,vec3(0,1.,0),0.);\n    plane2 = abs(plane2)-4.;\n    return max(s,plane2) - 0.3*clamp(fbm(p), 0., 1.);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n  return (d1.x < d2.x) ? d1 : d2; // the x-component is the signed distance value\n}\nvec2 Map(vec3 p)\n{\n    vec2 map = vec2(0.,0.);\n    float scale = 1.;\n    vec2 plane;\n    vec2 columns;\n    vec2 ceiling;\n    plane = vec2(PlaneSDF(p,vec3(0,1,0),0.),0.5);\n    plane.x -= 0.1*clamp(fbm(p), -.3, 1.);\n//Column Body\n    columns = vec2(Columns(p,scale),2.5);\n//Ceiling\n    ceiling = vec2(Ceiling(p,scale),3.5);\n    \n//Combining the Scene together \n    map = opU(ceiling,columns);\n    map = opU(map,plane);\n    return map;\n}\nvec3 Transform(vec3 p)\n{\n    return p;\n}\nvec2 Raymarch(vec3 ro, vec3 rd) {\n\tfloat Depth = MIN_DIST;\n    vec2 res = vec2(0.0);\n    float id = 0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = Transform(ro + rd*Depth);\n        res = Map(p);\n        Depth += res.x;\n        id = res.y;\n        if(Depth>MAX_DIST || abs(res.x)<SURF_DIST) break;\n    }\n    return vec2(Depth,id);\n}\nvec3 GetNormal(vec3 p) {\n\tvec2 d = Map(p);\n    vec2 e = vec2(.001, 0);\n    vec3 n = d.x - vec3(Map(p-e.xyy).x,Map(p-e.yxy).x,Map(p-e.yyx).x);\n    return normalize(n);\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 3.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.001 + 0.15*float(i)/4.0;\n        vec2 d = Map( pos + h*nor );\n        occ += (h-d.x)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 1.5*occ, 0.0, 1.0 );    \n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<256 && t<maxt; i++ )\n    {\n        vec2 h = Map(ro + rd*t);\n        if( h.x<0.001 )\n            return 0.0;\n        res = min( res, k*h.x/t );\n        t += h.x;\n    }\n    return res;\n}\nfloat GetLight(vec3 p, vec3 lightPosition) {\n    vec3 lightPos = lightPosition;\n    vec3 l = normalize(lightPos-p);\n    vec3 n = GetNormal(p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    dif *= softshadow(p,l,0.01,3.,8.)*1.3;\n    return dif;\n}\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n    r = normalize(cross(vec3(0,1,0), f)),\n    u = cross(f,r),\n    c = p+f*z,\n    i = c + uv.x*r + uv.y*u,\n    d = normalize(i-p);\n    return d;\n}\n\nvec3 render(vec3 ro,vec3 rd)\n{\n    vec3 col = COLOR_BACKGROUND;\n    vec2 res = Raymarch(ro,rd);\n    float id = res.y;\n    vec3 p = Transform(ro + rd * res.x);\n    \n    vec3 lightPos = vec3(sin(iTime)*3.,2,cos(iTime)*3.);\n    vec3 n = GetNormal(p);\n    \n    float AO = calcAO(p,n);\n    float dif = GetLight(p,lightPos);\n    float fog = res.x/40.;\n    vec3 fogCol = vec3(0.);\n    \n    if(id > 3.)\n    {\n        vec3 colXZ = texture(iChannel2, p.xz*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel2, p.yz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel2, p.xy*.5+.5).rgb;\n\n        n = abs(n);\n\n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    } \n    else if(id > 1.)\n    {\n        vec3 colXZ = texture(iChannel0, p.xz*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel0, p.yz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel0, p.xy*.5+.5).rgb;\n\n        n = abs(n);\n\n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n\n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    } \n    else if(id > 0.)\n    {\n        vec3 colXZ = texture(iChannel1, p.xz*.5+.5).rgb;\n        vec3 colYZ = texture(iChannel1, p.yz*.5+.5).rgb;\n        vec3 colXY = texture(iChannel1, p.xy*.5+.5).rgb;\n\n        n = abs(n);\n\n        n *= pow(n, vec3(2));\n        n /= n.x+n.y+n.z;\n        col = colYZ*n.x + colXZ*n.y + colXY*n.z;\n    }\n    col *= dif;\n    \n\n//variable animated fog attempt\n    //fog += clamp(fbm(p * .2 + (iTime * .2)),0.,1.);\n    //fogCol = vec3(.8);\n\n// Courtesy of Theron for using this to help explain how shading is supposed to work lol\n    col = mix(col*AO,fogCol,1.-exp(-fog));\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n// Normalized pixel coordinates (Centered)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n//Init camera\n    vec3 ro = vec3(4.,9.,-7.);\n    ro.yz *= Rotate(-m.y*3.14+1.);\n    ro.xz *= Rotate(-m.x*6.2831);\n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.);\n    vec3 rendered = render(ro,rd);\n// Output to screen\n    fragColor = vec4(rendered,1.0);\n}","name":"Image","description":"","type":"image"}]}