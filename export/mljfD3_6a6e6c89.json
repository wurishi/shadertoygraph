{"ver":"0.1","info":{"id":"mljfD3","date":"1694788027","viewed":151,"name":"On Delayed Perception ","username":"Amirk","description":"A study how finite speed of light makes moving objects appear distorted. Most of the effects are not even relativistic. Interact with mouse. Turn of Lorentz contraction by commenting out LORENTZ in buffer A.","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["light","relativity","lorentz","delay","retardation"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//The eyeball adapted from Inigo Quiles's tutorial and shader: https://www.shadertoy.com/view/lsfGRr\n\n\n\nconst int AA=5;//anti aliasing\n\n\n\n\nvec3 eye( vec2 uv )\n{\n    vec2 m =vec2(0.0001,0);\n    if(iMouse.w!=0.)\n         m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n\n    uv*=rot(-atan(m.y,m.x));\n    uv.y/=1.+.5*length(m);\n     uv*=rot(atan(m.y,m.x));\n    vec2 p=uv+clamp(m,-.5,.5)*.3;\n    \n    \n    \n    float r= sqrt(dot(p,p));\n    float a=atan(p.y,p.x);\n    \n    \n    float ss= .5+.5*sin(4.*iTime);\n    float anim=1.+.1*ss*clamp(1.-r,0.,1.);\n    r*=anim;\n    \n   \n    vec3 col=vec3(0);\n    if(length(uv)<.8){\n               col=vec3(0,.3,.4);\n        float f= fbm(5.*p);\n        col=mix(col, vec3(.2,.5,.4), f);\n        \n        f=1.-smoothstep(.2,.5,r);\n        col=mix( col, vec3(.9,.6,.2), f );\n        \n        a+=.05*fbm(20.*p);\n        \n        f=smoothstep( .3,1.,fbm( vec2(6.*r,20.*a) ) );\n        col=mix(col, vec3(1), f);\n        \n        f=smoothstep( .4,.9,fbm( vec2(10.*r,15.*a) ) );\n        col*=1.-.5*f;\n        \n         f=smoothstep(.6,.65,r);\n        col=mix(col, vec3(.9),f);\n        \n        f=smoothstep(.2,.25,r);\n        col*=f;\n        \n        f=1.-smoothstep(0.,.3,length(p-vec2(.24,.2)));\n        col+=vec3(1.,.9,.8)*f*.9;\n        \n        f=smoothstep(.76,.8,length(uv));\n        col=mix( col, vec3(0),f );\n        \n        \n    }\n    uv*=rot(-atan(m.y,m.x));\n    \n    float blink=1.-pow(cos(iTime*.5)*cos(iTime*.5),100.)-pow(cos((iTime-.8)*.5)*cos((iTime-.8)*.5),100.);\n    float wide=.9;\n    col*=smoothstep(abs(cos(uv.x))*wide*blink,wide*abs(cos(uv.x))*.9*blink,abs(uv.y));\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   float t =iTime*.2;          \n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 m =vec2(0.0001,0);\n    if(iMouse.w!=0.)\n        m=(iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    vec4 col;\n    for(int i=-AA; i<=AA; i++)\n        for(int j=-AA;j<=AA; j++){\n            vec4 tex=texelFetch( iChannel0, ivec2(fragCoord)+ivec2(i,j), 0 );\n            col+=vec4(tex.x,tex.w,tex.z,1); //green channel indicates collisions\n            }\n    col/=float(AA*AA);\n    \n    //time of the last click\n    float signalTime=texelFetch( iChannel0, ivec2(0), 0 ).z;\n    t=min(1.2,t-signalTime); //stop when signal reaches eye\n    \n    if(length(uv-m)<.05) col.rgb+=vec3(.9,.9,.9)*eye(20.*(uv-m));//eyeball\n    else if(texelFetch( iChannel1, ivec2(32,0), 0 ).x>0. ) {col.b=col.g; col.g=0.;}//ad blue by collision\n    else {\n        if(t==1.2){col.g*=0.;}\n        }\n    \n    // Output to screen\n    fragColor = vec4(col);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\nfloat hitDetection=0.;\nfloat t =0.;\n\n//outgoing signal?\n//#define FORWARD\n\n//relativistic contraction?\n#define LORENTZ\n\n\n//objects:\n//#define VERTICAL\n//#define HORIZONTAL\n//#define GRID\n#define ROTATING\n//#define BALL\n\n//box\nfloat object(vec2 p, vec2 e, vec2 h){\n\n    p = abs(p  )-h;\n    vec2 q = abs(p+e)-e;\n\n  return min(\n      length(max(vec2(p.x,q.y),0.0))+min(max(p.x,q.y),0.0),\n      length(max(vec2(q.x,p.y),0.0))+min(max(q.x,p.y),0.0))\n      ;\n}\n\n\n//grid\nfloat object2(vec2 p){\n    p.xy=fract(p.xy*5.);\n    \n    return min(p.x-.05,p.y-.05);\n}\n\nfloat sdSphere(vec2 p, float rad){\n    return length(p)-rad;\n}\n\n//rotating box\nfloat object4(vec2 p, vec2 e, vec2 h){\n    float d1= sdSphere(p,.1);\n    p.xy*=rot(t*2.);\n\n    p = abs(p  )-h;\n    vec2 q = abs(p+e)-e;\n    float d2=min(\n              length(max(vec2(p.x,q.y),0.0))+min(max(p.x,q.y),0.0),\n              length(max(vec2(q.x,p.y),0.0))+min(max(q.x,p.y),0.0));\n              \n  return min(d1,d2);\n}\n\n//ball\nfloat object5(vec2 p, vec2 e, vec2 h){\n  float d1= sdSphere(p,.1);\n   \n  return d1;\n}\n\n\nfloat sdLight(vec2 p, float start){\n    #ifdef FORWARD\n    float dist=abs(length(p)-(t-start)*c);\n    #else\n    float dist=abs(length(p)-(1.2-t+start)*c);\n    #endif\n    return dist;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    t =iTime*.2;\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    bool mouseClicked=sign(iMouse.z)>0.;\n        \n    vec2 m=vec2(0);\n    if(fragCoord==vec2(.5)){\n        \n         m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n        \n        if(mouseClicked){\n           fragColor=vec4(m, t, 0.);\n        }   \n        else\n           fragColor=texelFetch( iChannel0, ivec2(fragCoord), 0 );\n    }else{\n        if(texelFetch( iChannel0, ivec2(fragCoord), 0 ).w>.0 && !mouseClicked){\n            vec4 prevCol=texelFetch( iChannel0, ivec2(fragCoord), 0 );\n            fragColor=prevCol;\n            }\n        else{\n            //mouse pos of the last click\n            vec2  m =texelFetch( iChannel0, ivec2(0), 0 ).xy;\n            //time of the last click\n            float signalTime=texelFetch( iChannel0, ivec2(0), 0 ).z;\n            //signal ring\n            float light=sdLight(uv-m, signalTime);\n            t=min(1.2,t-signalTime); //stop when signal reaches eye\n            \n            vec3 col;\n            uv.x+=speed*t;\n            \n            //signal\n            col+=vec3(1,0,0)*smoothstep(.01,.0,abs(light));\n            \n            //relativistic effect?\n            #ifdef LORENTZ\n            uv.x*=gamma(speed);\n            #endif\n            //objects\n            uv.x=fract(uv.x);\n            uv.x-=.5;\n            \n            #ifdef ROTATING\n            col+=vec3(.0,.0,1.)*smoothstep(.001,.0, object4(uv,vec2(.01),vec2(.2)) );\n            #endif \n            #ifdef HORIZONTAL\n            col+=vec3(.0,.0,1.)*smoothstep(.001,.0, object(uv,vec2(.01),vec2(.2,.05)) );\n            #endif\n            #ifdef  GRID\n            col+=vec3(.0,.0,1.)*smoothstep(.001,.0, object2(uv));\n            #endif\n            #ifdef  VERTICAL\n            col+=vec3(.0,.0,1.)*smoothstep(.001,.0, object(uv,vec2(.01),vec2(.1,.4)));\n            #endif\n            #ifdef  BALL\n            col+=vec3(.0,.0,1.)*smoothstep(.001,.0, object5(uv,vec2(.01),vec2(.1,.4)));\n            #endif\n            \n\n            if(col.r*col.b>0.5){ //lets use colors to indicate intersection\n                //col.r+=1.;\n                hitDetection=1.;\n                }\n            \n            fragColor = vec4(col,hitDetection);\n        }\n    }\n}\n\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\nfloat speed=0.7;\nfloat c=1.;\n\nmat2 rot(float a){ \n    return mat2(cos(a), -sin(a),sin(a),cos(a));\n}\n\nfloat gamma(float beta){\n    float b= beta/c;\n    return pow(abs(1.-b*b),-.5);\n}\n\n\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise(vec2 x){\n    \n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*57.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat fbm(vec2 p){\n    float f=.0;\n    f+=.500*noise(p); p*=2.02;\n    f+=.250*noise(p); p*=2.03;\n    f+=.125*noise(p); p*=2.01;\n    //f+=.0625*noise(p); p*=2.04;\n    f/=.875;\n    \n    return f;\n    \n}","name":"Common","description":"","type":"common"}]}