{"ver":"0.1","info":{"id":"wlGfDG","date":"1615160302","viewed":105,"name":"Jupiter_1","username":"brucesysu","description":"Jupiter Test","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float random (vec2 uv)\n{\n    return fract(sin(dot(uv,vec2(12.9898,78.233)))*43758.5453123);\n}\n\nfloat step(float x, float start, float stop, float max, float min)\n{\n    if (start == stop) return max;\n    if (x >= stop) return max;\n    else if (x <= start) return min;\n    else {\n        return (x - start)/(stop - start) * (max - min) + min;\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n\n{\n    vec2 center = iResolution.xy/2.;\n    float radius = iResolution.x/5.;\n    float distance = distance(fragCoord, center);\n    \n    float speed_scale = (radius - abs(fragCoord.y - center.y)/5.)/radius;\n    \n    vec3 atmosphereColor = vec3(.7, .6, .5);\n\n    // blend two colors\n    \n    if (distance < radius){\n    vec3 color1 = vec3(201.,144.,57.)/255.;\n    vec3 color2 = vec3(227.,220.,203.)/255.;\n    \n    float speed = .9;\n    float scale = .05;\n    vec2 p = fragCoord * scale;\n    p.x = (p.x / iResolution.x) * 1000.;\n    p.y = (1.5-p.y / iResolution.y) * 2300.;\n    \n    for(int i=1; i<5; i++)\n    {\n        float x_cycle = (1. * float(i) * p.y + iTime * speed);\n        p.x += 0.3 * sin(x_cycle) + 0.3 * sin(x_cycle/2.) + 0.5 * sin(x_cycle/4.) + 9. * sin(x_cycle/8.);\n        float y_cycle = .8 * float(i) * p.x + iTime * speed;\n        p.y += 0.3 * cos(y_cycle) + 0.3 * cos(y_cycle/2.) + 0.3 * cos(y_cycle/4.) + .5 * cos(y_cycle/8.);\n    }\n    \n    p.y += speed_scale * .01 * iTime;\n    \n\n    float mask1 = 0.5 * sin(p.y/2.) + 0.5* sin(p.y/1.8 + 2.5);\n    float mask2 = 1. - mask1;\n    \n    vec3 color = color1 * mask2 + color2 * mask1;\n        \n    // calculate day and night lighting\n    float sphere_y = abs(fragCoord.y - center.y);\n    float lat = sqrt(radius*radius - sphere_y*sphere_y);\n    float light_mask_x = step(fragCoord.x, center.x-lat, center.x+lat, .8 * cos(iTime/2.) + .1, .8 * sin(iTime/2.) + .1);\n    float light_mask_y = step(abs(fragCoord.y - center.y), 0., radius, 0.7, .9);\n    \n    \n    float atmosphere_mask = step(fragCoord.x, center.x + lat/1.5, center.x+lat, 0.7, .1) + step(fragCoord.x, center.x - lat, center.x-lat/1.5, 0.1, 0.7);\n    color = mix(color, atmosphereColor, atmosphere_mask);\n\n\n    color *= light_mask_x * light_mask_y;\n    \n    fragColor = vec4(color, 1.0);}\n    \n    \n    else if(distance < (radius + 30. ))\n    {\n        float scale = pow(-distance + radius + 50.,2.)/5000.;\n        atmosphereColor *= scale;\n        fragColor = vec4(atmosphereColor,0.0);\n    }\n    else {\n        \n        fragColor = vec4(0.0, 0.0, 0.0,1.0);\n    }\n}\n","name":"Image","description":"","type":"image"}]}