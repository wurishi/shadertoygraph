{"ver":"0.1","info":{"id":"4f3GDn","date":"1711535882","viewed":62,"name":"circle rotate by last circle","username":"yufengjie","description":"circle rotate by last circle","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["circle","rotate","beginer"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float PI = 3.1415926;\nfloat pix;\n\n// p屏幕坐标,c圆心位置,r半径\nfloat plotCircle(vec2 p, vec2 c, float r) {\n    float circle = abs(distance(p, c) - r);\n    return smoothstep(3.*pix, 0., circle);\n}\n\nfloat plotPoint(vec2 p, vec2 c) {\n    return plotCircle(p, c, 1.*pix);\n}\n\nfloat random(float seed) {\n    //return sin(seed) * 0.5 + 0.5;\n    return noise(seed);\n    //return fract(sin(seed) * 45632.15423);\n}\n\n// 绕o点旋转,a旋转角度\n// 注意坐标变换矩阵是累乘上去的，也就是当前圆已经平移到了“原点”\nmat3 rotate(vec2 o, float a) {\n    mat3 translate = mat3(1.,0.,-o.x,0.,1.,-o.y,0.,0.,1.);\n    mat3 rotate = mat3(cos(a), -sin(a), 0., sin(a), cos(a), 0., 0., 0., 1.);\n    return translate * rotate;\n    \n    // 为什么这么不行，矩阵不是满足乘法结合律吗？\n    // 绕点旋转要先平移，再旋转。先把后面的变换矩阵结合，就不行？\n    // return mat3(cos(a), -sin(a), -o.x, sin(a), cos(a), -o.y, 0., 0., 1.);\n}\n\nfloat getR(float i, float v) {\n    return i < 0. ? 0. : (v * 20. * pix + 10. * pix);\n}\n\nvec2 getPos(float i, float r, float r_pre) {\n    return i <= 0. ? vec2(0.) : vec2(r + r_pre, 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    float ixy = iResolution.x / iResolution.y;\n    uv -= vec2(0.5 * ixy, 0.5);\n    vec3 uv_homo = vec3(uv.x, uv.y, 1.);// 齐次坐标下，坐标格式\n\n    pix = 1. / iResolution.y;\n    vec3 fin_c = vec3(0.);\n    \n    if(false) {\n        // 测试代码\n        vec2 pos1 = vec2(0., 0.);\n        float r1 = 10. * pix;\n        float circle1 = plotCircle(uv, pos1, r1);\n        fin_c += circle1;\n\n        float r2 = 20. * pix;\n        vec2 pos2 = pos1 + vec2(r1 + r2, 0.);\n        vec2 p2 = (uv_homo * rotate(pos1, iTime)).xy;\n        float circle2 = plotCircle(p2, pos2, r2);\n        fin_c += circle2;\n\n        float r3 = 30. * pix;\n        vec2 pos3 = vec2(r2 + r3, 0.);\n        vec2 p3 = (uv_homo * rotate(pos1, iTime) * rotate(pos2, iTime)).xy;\n        float circle3 = plotCircle(p3, pos3, r3);\n        fin_c += circle3;\n    } else {\n    \n        float total = 20.; // 生成圆的个数\n        vec2 center = vec2(0.); // 第一个圆的中心点\n        vec3 p = uv_homo; \n        \n        for(float i=0.;i<total;i+=1.) {\n        \n            float randomVal_pre_2 = random(i-2.);\n            float randomVal_pre = random(i-1.);\n            float randomVal = random(i);\n        \n            float r_pre_2 = getR(i-2., randomVal_pre_2); // 爷爷圆的半径\n            float r_pre = getR(i-1., randomVal_pre); // 爸爸圆的半径\n            float r = getR(i, randomVal); // 当前圆的半径\n            \n            vec2 pos_pre = getPos(i-1., r_pre, r_pre_2); // 上个圆的位置\n            vec2 pos = getPos(i, r, r_pre); // 当前圆的位置\n            \n            float speed = randomVal * 0.3 + .3 / (i + 0.1);\n            //p *= rotate(pos_pre, iTime * speed);\n            p *= rotate(pos_pre, noise(i/total+iTime));\n\n            \n            float circle = plotCircle(p.xy, pos, r);\n            vec3 color = palette(randomVal);\n            \n            fin_c += circle * color;\n        }\n    \n    }\n    \n    \n    \n\n\n    fragColor = vec4(fin_c,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// https://www.shadertoy.com/view/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\nfloat hash(vec2 p) {vec3 p3 = fract(vec3(p.xyx) * 0.13); p3 += dot(p3, p3.yzx + 3.333); return fract((p3.x + p3.y) * p3.z); }\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), u);\n}\nvec3 palette(float t) {\n  vec3 a = vec3(1.000,0.500,0.500);\n  vec3 b = vec3(0.500,0.500,0.500);\n  vec3 c = vec3(0.750,1.000,0.667);\n  vec3 d = vec3(0.800,1.000,0.333);\n  return a + b * cos(6.28318 * (c * t + d));\n}","name":"Common","description":"","type":"common"}]}