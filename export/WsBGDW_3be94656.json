{"ver":"0.1","info":{"id":"WsBGDW","date":"1548807895","viewed":174,"name":"cloud_0002","username":"kuma720","description":"cloud","likes":12,"published":1,"flags":0,"usePreview":0,"tags":["cloud"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float noise(vec3 uv) {\n  return fract( sin( dot( uv ,vec3(123.,65.,44.) ) ) * 4811.424 );\n}\n\nfloat pnoise(vec3 uv,float f) {\n\n  vec3 t = uv * f;\n  vec3 v1 = floor(t);\n  vec3 v2 = fract(t);\n\n  float a0 = noise(v1 + vec3(0.,0.,0.));\n  float b0 = noise(v1 + vec3(1.,0.,0.));\n  float c0 = noise(v1 + vec3(0.,1.,0.));\n  float d0 = noise(v1 + vec3(1.,1.,0.));\n\n  float a1 = noise(v1 + vec3(0.,0.,1.));\n  float b1 = noise(v1 + vec3(1.,0.,1.));\n  float c1 = noise(v1 + vec3(0.,1.,1.));\n  float d1 = noise(v1 + vec3(1.,1.,1.));\n\n  float o1 = mix(a0,b0,v2.x);\n  float o2 = mix(c0,d0,v2.x);\n  float o3 = mix(o1,o2,v2.y);\n\n  float o4 = mix(a1,b1,v2.x);\n  float o5 = mix(c1,d1,v2.x);\n  float o6 = mix(o4,o5,v2.y);\n\n  float o7 = mix(o3,o6,v2.z);\n  \n  return o7;\n}\n\nfloat fbm(vec3 uv , float f ) {\n  float o = 0.;\n  float n = 1.;\n  \n  for ( int i = 0 ; i < 5 ; ++ i ) {\n    o += pnoise( uv , f ) * n;\n    f *= 2.; \n    n *= 0.5;\n  }\n\n  return o;\n}\n\n\nmat4 createVTW(vec3 eye,vec3 center,vec3 up) {\n  vec3 f = normalize( center - eye );\n  vec3 s = normalize( cross(f,up) );\n  vec3 u = cross(s,f);\n  return mat4(\n    vec4(s,0.),\n    vec4(u,0.),\n    vec4(-f,0.),\n    vec4(0.,0.,0.,1)\n  );\n}\n\n\nvec3 rayDirection(float fieldofView,vec2 size,vec2 fragCoord) {\n  vec2 xy = fragCoord - size / 2.0;\n  float z = size.y / tan(radians(fieldofView) / 2.0 );\n  return normalize(vec3(xy,-z));\n}\n\n\nvec2 sdf(vec3 p) {\n\n  vec3 p2 = p + vec3( iTime * .15 , iTime * -.08 , iTime * -.12 );\n\n  //cloud sphere\n  float cloudPlane = dot( p + vec3(0,-0.4,0) , vec3(0.,1.,0.) );\n  float l0 = length( p + vec3(1.7,-0.15,1.0) ) - 0.7;\n  float l1 = length( p + vec3(-0.8,-0.15,-1.0) ) - 0.7;\n  float l2 = min(l0,l1);\n  float cl = max(l2,-cloudPlane);\n\n  //cloud detail\n  float l4 = fbm( p2 , 5.0 ) - 0.8;\n  float l5 = mix ( cl , l4 , .2 );\n\n  //plane\n  float l6 = dot( p , vec3(0.,1.,0.));\n\n  if ( l5 < l6 ) {\n    return vec2(l5,1);\n  } else {\n    return vec2(l6,2);\n  }\n\n}\n\n\nvec3 createnormal(vec3 p) {\n\n  float e = 0.0001;\n\n  return normalize( vec3(\n    sdf( vec3(p.x+e,p.y,p.z) ).x - sdf( vec3(p.x-e,p.y,p.z) ).x ,\n    sdf( vec3(p.x,p.y+e,p.z) ).x - sdf( vec3(p.x,p.y-e,p.z) ).x ,\n    sdf( vec3(p.x,p.y,p.z+e) ).x - sdf( vec3(p.x,p.y,p.z-e) ).x\n  ));\n\n}\n\n\nvec3 lightingMaterial00 ( vec3 lightvec , vec3 p ) {\n\n  vec3 normal = createnormal(p);\n  vec3 s = p + normal * 0.01;\n\n  float result = 0.9;\n  float depth = 0.1;\n  float minlight = 0.1;\n\n  for( int I=0; I< 20 ; ++I ) {\n    \n    vec3 p2 = s + lightvec * depth;\n    float len = sdf(p2).x;\n    result = min( result , (len * 2.6 / depth) + minlight ) ;\n    depth += len ;\n\n    if( len < 0.00001 ) {\n      result = minlight;\n      break;\n    }\n\n  }\n\n  return mix( vec3(0.2,0.1,0.9) , vec3( result ), 0.9 );\n\n}\n\n\n\n\n\nvec3 lightingMaterial01 ( vec3 lightvec , vec3 p ) {\n\n  vec3 normal = createnormal(p);\n  vec3 s = p + normal * 0.01;\n\n  float result = 1.;\n  float depth = 0.;\n  float minlight = .1;\n\n  for( int I=0; I< 15 ; ++I ) {\n    \n    vec3 p2 = s + lightvec * depth;\n    float len = sdf(p2).x;\n    result = min( result , len * 4.6 / depth + minlight );\n    depth += len ;\n\n    if( len < 0.001 ) {\n      result = minlight;\n      break;\n    }\n\n  }\n\n  return mix ( vec3( 0.2 , 0.1 , 0.0 ) , vec3 ( result ) , .5 );\n\n}\n\n\nvec4 render( vec2 fragCoord , vec3 eye , vec3 worldDir , float start , float end ) {\n\n  vec3 lightvec = normalize( vec3( 1.0 ,1.2, -0.8) );\n\n  vec3 sky = vec3(0.25,0.4,0.65);\n  vec3 cloud = vec3(0.,0.,0.);\n  vec3 background = sky;\n  float ratio = 1.0;\n\n  float depth = start;\n  for(int I=0;I<200;++I) {\n\n    vec3 p = eye + worldDir * depth;\n    if ( 17. < depth ) {\n      break;\n    }\n\n    vec2 ss = sdf(p);\n    float len = ss.x;\n    int material = 0;\n\n    if( len < 0.01 ) {\n      \n      material = int(ss.y);\n\n      if ( material == 1 ) {\n        ratio = min( ratio , 0.9 );\n        vec3 l = lightingMaterial00( lightvec , p );\n        cloud = mix(cloud , l , ratio);\n        ratio *= .7;\n        if ( ratio < 0.0001 ) {\n          break;\n        }\n        depth += max(len, 0.001 * noise( worldDir * iTime ) + 0.002 );\n      }\n\n      if ( material == 2 ) {\n        vec3 ground = lightingMaterial01( lightvec , p );\n        background = ground;\n        break;\n      }\n\n    } else {\n      depth += max(len, 0.01 );\n    }\n\n  }\n\n\n  //vec3 o = mix ( background , cloud , ( 1. - ratio ) );\n  vec3 o = background + cloud * .9 ; //* (1.0 - ratio);\n  return vec4( o , 1. );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord * (1.0/iResolution.x) - vec2(0.5, 0.5);\n\n    float t = iTime * .1;\n//    vec3 eye = vec3( sin(t) * 5. , 0.2, cos(t) * 5. );\n\n    vec3 eye = vec3( 5. ,2.5, 4. );\n    vec3 center = vec3(0.,0.,0.);\n    vec3 up = vec3(0.,1.,0.);\n    mat4 vtw = createVTW(eye,center,up);\n\n    vec3 viewDir = rayDirection(45.,iResolution.xy,fragCoord);\n    vec3 worldDir = (vtw * vec4(viewDir,0.)).xyz;\n\n   fragColor = render( fragCoord , eye , worldDir , 0. , 1000. );\n}","name":"Image","description":"","type":"image"}]}