{"ver":"0.1","info":{"id":"4ltGDn","date":"1468754634","viewed":255,"name":"[SH16B] tunel","username":"lovelyH","description":"some code writen on sundown demoparty.","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["sh16b"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/// float iTime;\n/// vec2 iResolution;\n/// sampler2D textures[];\n/// vec3 iCam;\n/// float iCamRZ;\n/// float iCamRX;\n\n#define E 0.01\n\n#define MAT_GRASS\t\t1\n#define MAT_GLASS_RED\t2\n#define MAT_GLASS \t\t3\n#define MAT_ROCK\t\t4\n#define MAT_WATER\t\t5\n\nvec3 rotY(vec3 p, float l ){\n\tfloat sl= sin(l);\n\tfloat cl= cos(l);\n\treturn vec3(\n\t\tp.x*cl - p.z*sl,\n\t\tp.y,\n\t\tp.x*sl + p.z*cl\n\t);\n}\n\nfloat dfBox( vec3 p, vec3 s){\n\tp= abs(p)-s;\n\treturn max( max( p.x, p.y), p.z );\n}\n\nint matId;\nfloat map(vec3 pi){\n\tvec3 p= pi;\n\t/// water floor\n\tfloat r= p.z + 2.0 + sin(iTime*0.1);\n\tmatId= MAT_WATER;\n\tfloat rc;\n\t/// balls\n\tp.y= mod(p.y+mod(8.0*iTime,4.0),4.0) - 2.0;\n\tp.x= abs(p.x);\n\trc= length(p-vec3(2,0,0))-0.5;\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= MAT_GLASS_RED;\n\t}\n\t/// cubes\n\tp= pi;\n\tp.y= p.y+8.0*iTime;\n\tif( mod( p.y, 200.0 ) < 50.0 ){\n\t\tp= rotY( p, floor((p.y)/4.0) );\n\t\tp.y= mod(p.y,4.0) - 2.0;\n\t\tp.x= abs(p.x);\n\t\trc= dfBox(p-vec3(2,0,0), vec3(0.5,0.2,0.2));\n\t\tif( rc < r ){\n\t\t\tr= rc;\n\t\t\tmatId= MAT_ROCK;\n\t\t}\n\t}\n\t/// columns\n\tp= pi;\n\tp.y= mod(p.y+mod(8.0*iTime,80.0),80.0) - 40.0;\n\tp.xy= abs(p.xy) - vec2(2.0);\n\tp.xy= abs(p.xy) - vec2(1.0);\n\trc= length(p.xy) - 0.3;\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= MAT_GLASS;\n\t}\n\t/// cave\n\tp= pi;\n\tp.y= p.y+8.0*iTime;\n\trc= -length(p.xz-vec2(0.0,0.9))+3.0;\n\t/// cut tube tunel\n\tif( mod( p.y, 1000.0 ) < 500.0 )rc= max( rc, p.z - 1.0 );\n\t//if( mod( p.y, 100.0 ) < 50.0 )rc= max( rc, -dfBox( p, vec3() ) );\n\t/// cut holes some wholes\n\tif( mod( p.y, 18.0 ) < 9.0 )\n\t\trc= max( rc, -dfBox( mod(p,0.9)-0.45, vec3(0.4) )  );\n\t/// apply\n\tif( rc < r ){\n\t\tr= rc;\n\t\tmatId= MAT_ROCK;\n\t}\n\t/// reeturn final \n\treturn r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n\t// vec3 lightDir= normalize( vec3( cos(iTime), sin(iTime), 1 ) );\n\tvec3 lightPos= vec3( cos(iTime)*4.0, sin(iTime)*4.0, 4.0 );\n\n\tvec3 r= vec3(0);\n\tfloat powerLeft= 0.666;\n\n\tfor( int pas=0;pas<3;pas++){\n\n\t\tvec3 p= sp;\n\t\tfloat dis= map(p);\n\t\tbool isHit= false;\n\t\tfor( int a=0;a<0x80;a++){\n\t\t\tp += dis*dir;\n\t\t\tdis= map(p);\n\t\t\tif( dis < E ){\n\t\t\t\tisHit= true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif( isHit ){\n\t\t\tvec3 baseColor= vec3( 0.9 );\n\t\t\tfloat reflexPower= 0.0;\n\t\t\tif( matId==MAT_GRASS ){\n\t\t\t\tbaseColor= vec3( 0.5, 0.9, 0.5 );\n\t\t\t}else if( matId==MAT_GLASS_RED ){\n\t\t\t\tbaseColor= vec3( 0.9, 0.2, 0.2 );\n\t\t\t\treflexPower= 0.5;\n\t\t\t}else if( matId==MAT_GLASS ){\n\t\t\t\tbaseColor= vec3( 0.9 );\n\t\t\t\treflexPower= 0.5;\n\t\t\t}else if( matId==MAT_WATER ){\n\t\t\t\tbaseColor= vec3( 0.5, 0.5, 0.9 );\n\t\t\t\treflexPower= 0.5;\n\t\t\t}\n\t\t\tvec3 lightDir= normalize( lightPos - p );\n\t\t\tvec3 nor= normalize( vec3(\n\t\t\t\tmap(p+vec3(E,0,0))-map(p-vec3(E,0,0)),\n\t\t\t\tmap(p+vec3(0,E,0))-map(p-vec3(0,E,0)),\n\t\t\t\tmap(p+vec3(0,0,E))-map(p-vec3(0,0,E))\n\t\t\t) );\n\n\t\t\t/// shadow calculation\n\t\t\tfloat lighting= dot(lightDir,nor);\n\t\t\tfloat disFromLight= length(p-lightPos);\n\t\t\tif( 0.0 < lighting ){\n\t\t\t\tfloat shadowH= 0.1;\n\t\t\t\tfloat shadowDis= 0.0;\n\t\t\t\tvec3 p2=p+shadowH*lightDir;\n\t\t\t\tfloat shadowDisTotal= shadowH;\n\t\t\t\tfor( int i=0;i<0x40;i++){\n\t\t\t\t\tshadowDis= map(p2);\n\t\t\t\t\tshadowDisTotal += shadowDis;\n\t\t\t\t\tif( disFromLight < shadowDisTotal ){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tp2 += shadowDis * lightDir;\n\t\t\t\t\tif( shadowDis < E ){\n\t\t\t\t\t\tshadowDis= 0.0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlighting = min( lighting, shadowDis/shadowH );\n\t\t\t}\n\n\t\t\tr+= powerLeft * baseColor\n\t\t\t\t*clamp( 2.0-disFromLight/8.0, 0.0, 1.0)\n\t\t\t\t*(0.5+0.5*lighting)\n\t\t\t\t*(0.5+0.5*dot(-dir,nor))\n\t\t\t\t*(lighting<=0.0?1.0:(1.0+pow(max( 0.0, dot( reflect( dir, nor ), lightDir )), 16.0 )))\n\t\t\t;\n\n\t\t\tdir= reflect( dir, nor );\n\t\t\tsp= p + 0.5*dir;\n\t\t\tpowerLeft *= reflexPower;\n\t\t\tif( powerLeft < 0.05 )\n\t\t\t\tbreak;\n\t\t}else{\n\t\t\tr+= powerLeft*vec3(0.0);\n\t\t}\n\t}\n\n\treturn r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv= 2.0 * fragCoord / iResolution.xy - vec2(1.0,1.0);\tuv.x *= iResolution.x / iResolution.y;\t\n\tfragColor = vec4( \n\t\trender( \n\t\t\tvec3(0.5*sin(iTime*0.6),-16,0.5*sin(iTime*0.2)), \n\t\t\tnormalize(vec3(uv.x,2.0,uv.y))\n\t\t), 1.0\n\t);\n}\n\n","name":"Image","description":"","type":"image"}]}