{"ver":"0.1","info":{"id":"lfd3RN","date":"1712583656","viewed":361,"name":"simple path traced mandelbulb","username":"sedenion","description":"simple path traced mandelbulb","likes":11,"published":1,"flags":32,"usePreview":0,"tags":["ray","mandelbulb","marching","tracing","path"],"hasliked":0,"parentid":"4cBXDV","parentname":"Mandelbulb classic path traced"},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 color = texture(iChannel0,fragCoord/iResolution.xy);\n    \n    color.xyz = pow(color.xyz/color.w, vec3(1.0/2.2));\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *=  1.0 - uv.yx;\n    float vig = pow(uv.x*uv.y *30.0, 0.07);\n    \n    fragColor = vec4(color.xyz*vig,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","previewfilepath":"/media/ap/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define MAX_STEP 255\n#define MIN_DIST 0.0001\n#define MAX_DIST 100.\n#define MAX_BOUNCE 5\n\nstruct HitRecord{\n    vec3 position;\n    vec3 normal;\n    vec3 color;\n};\n\nstruct Ray{\n    vec3 origin;\n    vec3 direction;\n};\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nfloat sdMandelbulb(vec3 pos, int maxIterations, float bailout, float power, inout float t0) {\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    t0 = 1.0;\n\tfor (int i = 0; i < maxIterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>bailout) break;\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, power-1.0)*power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t\n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n        \n        t0 = min(t0, zr);\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\nfloat sdSphere(vec3 p, float r){\n    float displacement = sin(5.0 * p.x) * sin(5.0 * p.y) * sin(5.0 * p.z) * 0.00;\n    return length(p) - r + displacement;\n}\n\nfloat sdPlane(vec3 p, float h){\n    return p.y-h;\n}\n\nfloat sdScene(vec3 p, inout float t0){\n    int maxIterations = 50;\n    float bailout = 100.0;\n    float power = 8.0;\n    //float h = min(sdSphere(p+vec3(0,0,1), 0.5),sdPlane(p, -0.5));\n    //h = min(h,sdSphere(p+vec3(1,0,1), 0.5));\n    //h = min(h,sdSphere(p+vec3(-1,0,1), 0.5));\n    //return h;\n    return sdMandelbulb(p,  maxIterations, bailout, power, t0);\n    //return min(sdMandelbulb(p,  maxIterations, bailout, power, t0),sdPlane(p, -1.));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.000005;\n    float tmp;\n    return normalize(\n      e.xyy * sdScene(p + e.xyy,tmp) +\n      e.yyx * sdScene(p + e.yyx,tmp) +\n      e.yxy * sdScene(p + e.yxy,tmp) +\n      e.xxx * sdScene(p + e.xxx,tmp));\n}\n\nvec3 getSkyColor(vec3 direction){\n    vec3 dir = normalize(direction);\n    vec3 sunDir = normalize(vec3(1,1,1));\n    float v = max(0.,dot(dir, sunDir));\n    // background\n    vec3 color = mix(vec3(0.4,0.7,1),vec3(0.7,0.9,1), direction.y);\n    // sun bloom\n    color += vec3(v)*0.2;\n    // sun\n    color += pow(v,400.);\n    return color;\n}\n\nbool rayMarch(Ray ray, inout HitRecord hit){\n    float totalDistance = 0.;\n    int i;\n    vec3 p;\n    float t0;\n    for(i=0; i<MAX_STEP; i++){\n        p = ray.origin + totalDistance*ray.direction;\n        float currentDistance = sdScene(p, t0);\n        totalDistance += currentDistance;\n        \n        if(currentDistance < MIN_DIST || totalDistance > MAX_DIST){\n            totalDistance-=MIN_DIST;\n            break;\n        }\n    }\n    \n    if(totalDistance>MAX_DIST){\n        return false;\n    }\n    p = ray.origin + totalDistance*ray.direction;\n    hit.position = ray.origin + 0.99*totalDistance*ray.direction;\n    hit.normal = calcNormal(p);\n    hit.color =  0.5 + 0.5 * sin(5.5 + 2.6 * t0 + vec3(1., 0.0, 1.0));\n    return true;\n}\n\n\n\nvec3 render(Ray ray){\n    Ray currentRay = ray;\n    HitRecord hit;\n    vec3 attenuation  = vec3(1);\n    vec3 color = vec3(0);\n    \n    for(int i = 0; i<MAX_BOUNCE; i++){\n        if(!rayMarch(currentRay, hit)){\n            color+= attenuation*getSkyColor(currentRay.direction); //texture(iChannel0, -currentRay.direction).rgb;\n            break;\n        }\n        //color += attenuation * hit.color * 0.1; //emission\n        currentRay.origin = hit.position;\n        currentRay.direction = hit.normal+random_in_unit_sphere(g_seed);\n        attenuation *= hit.color;\n    }\n    \n    return color;\n}\n\n\nRay getRayDirection(vec2 uv, vec3 origin, vec3 direction){\n    //float focalLength = 1.;\n    float defocusAngle =  3.;\n    float focusDistance = distance(origin, direction)*0.2;\n    \n    float vfov = 90.; //vertical field of view\n    \n    float h = focusDistance * tan(radians(vfov)/2.); // half of vertical sensor size\n    \n    vec3 fixedUp = vec3(0,1,0);\n    vec3 front = normalize(direction - origin);\n    vec3 right = -normalize(cross(front, fixedUp));\n    vec3 up = cross(front, right);  \n    \n    float defocusRadius = focusDistance * tan(radians(defocusAngle/2.));\n    \n    vec2 rd = random_in_unit_disk(g_seed)*defocusRadius;\n    vec3 offset = rd.x * right + rd.y * up;\n         \n    vec3 dir = normalize(h*uv.x*right + h*uv.y*up + front*focusDistance - offset);\n    return Ray(origin+offset, dir);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.*fragCoord/iResolution.xy - 1.;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 mouse = (iMouse.xy / iResolution.xy - 0.5)*5.5;\n    mouse.y*=-1.;\n    g_seed = float(base_hash(floatBitsToUint(fragCoord)))/float(0xffffffffU)+iTime;\n    \n    vec3 col = vec3(0,0,0);\n    \n    vec3 rayOrigin = vec3(sin(mouse.x)*cos(mouse.y),sin(mouse.y+0.5),cos(mouse.x)*cos(mouse.y))*1.5;\n    vec3 lookAtDirection = vec3(0,0,0);\n    \n    Ray ray = getRayDirection(uv, rayOrigin, lookAtDirection);\n    \n    \n    col += render(ray); \n    \n    vec4 lastFrame;\n    if (iMouse.z > 0.0){\n        lastFrame = vec4(0);\n    }else{\n        lastFrame = texture(iChannel1, fragCoord/iResolution.xy);\n    }\n    \n    \n    \n    fragColor = vec4(col,1.0)+lastFrame;\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"// Hash functions by Nimitz:\n// https://www.shadertoy.com/view/Xt3cDn\n\nfloat g_seed = 0.;\n\nuint base_hash(uvec2 p) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nvec2 hash2(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 hash3(inout float seed) {\n    uint n = base_hash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3(rz & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\nvec3 random_in_unit_sphere(inout float seed) {\n    vec3 h = hash3(seed) * vec3(2.,6.28318530718,1.)-vec3(1,0,0);\n    float phi = h.y;\n    float r = pow(h.z, 1./3.);\n\treturn r * vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nvec2 random_in_unit_disk(inout float seed) {\n    vec2 h = hash2(seed) * vec2(1.,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n\treturn r * vec2(sin(phi),cos(phi));\n}","name":"Common","description":"","type":"common"}]}