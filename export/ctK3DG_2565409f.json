{"ver":"0.1","info":{"id":"ctK3DG","date":"1684573475","viewed":65,"name":"Scharr filter test","username":"stauk","description":"Scharr filter test","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["scharrfilter"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4df3zn","filepath":"/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","previewfilepath":"/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv","type":"video","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Max Sills 2016\n// Licensed under the MIT license.\n//\n// http://homepages.inf.ed.ac.uk/rbf/HIPR2/sobel.htm\n// http://homepages.inf.ed.ac.uk/rbf/HIPR2/convolve.htm\n//\n// Using matrixCompMult, component-wise multiplication for convolution.\n// OpenGL is mat[col][row].\n/*\n 0   1    2\n 3   4(C) 5\n 6   7    8\n Pixel 4 is the center\n*/\n// Given an array of pixels, return 3*3 matrix of pixel intensities.\nmat3 intensityMatrix(vec4 n[9]){\n    mat3 o;\n    o[0] = vec3(sqrt(dot(n[0].xyz, n[0].xyz)), sqrt(dot(n[3].xyz, n[3].xyz)), sqrt(dot(n[6].xyz, n[6].xyz)));\n    o[1] = vec3(sqrt(dot(n[1].xyz, n[1].xyz)), sqrt(dot(n[4].xyz, n[4].xyz)), sqrt(dot(n[7].xyz, n[7].xyz)));\n    o[2] = vec3(sqrt(dot(n[2].xyz, n[2].xyz)), sqrt(dot(n[5].xyz, n[5].xyz)), sqrt(dot(n[8].xyz, n[8].xyz)));\n\treturn o;\n}\n\nfloat convolution(mat3 x, mat3 y) {\n return dot(x[0],y[0]) + dot(x[1],y[1]) + dot(x[2],y[2]);\n}\n\n// Given a texture and  a center coordinate\n// neighbors returns an array of the neighbor coordinates.\nvoid neighbors(lowp sampler2D s, vec2 res, vec2 center, out vec4 n[9]) {\n    n[0] = texture( s, (center + vec2(-1.0, 1.0)) / res);\n    n[1] = texture( s, (center + vec2(0, 1.0)) / res);\n    n[2] = texture( s, (center + vec2(1.0, 1.0)) / res);\n    \n    n[3] = texture( s, (center + vec2(-1.0, 0)) / res);\n    n[4] = texture( s, (center) / res);\n    n[5] = texture( s, (center + vec2(1.0, 0)) / res);\n    \n    n[6] = texture( s, (center + vec2(-1.0, -1.0)) / res);\n    n[7] = texture( s, (center + vec2(0, -1.0)) / res);\n    n[8] = texture( s, (center + vec2(1, -1.0)) / res);\n}\n\n/**\nfloat convolve(mat3 m1, mat3 m2){\n    return 0.0;\n}\n**/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 samples[9];\n    neighbors(iChannel0, iResolution.xy, fragCoord, samples);\n    mat3 intensity = intensityMatrix(samples);\n\n    mat3 Gx = mat3(47.0, 162.0,  47.0, // 1. column\n                   0.0, 0.0,  0.0,  // 2. column\n                   -47.0, -162.0,  -47.0); // 3. column\n    \n    mat3 Gy = mat3(-47.0, 0,   47.0,  // 1. column\n                   -162.0, 0.0, 162.0,  // 2. column\n                   -47.0, 0.0, 47.0); // 3. column\n        \n    float gx = convolution(intensity,Gx)/100.;\n    float gy = convolution(intensity,Gy)/100.;\n\tfloat color = sqrt((gx*gx) + (gy*gy));\n    float colg = max(0.,abs(gx));\n    float colb = max(0.,abs(gy));\n    \n    fragColor = vec4(color, colg, colb, 0.0);\n    \n}","name":"Image","description":"","type":"image"}]}