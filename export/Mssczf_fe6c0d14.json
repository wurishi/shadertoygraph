{"ver":"0.1","info":{"id":"Mssczf","date":"1489275071","viewed":123,"name":"RED FANG - No Air","username":"nint22","description":"Clone of the RED FANG music video for \"No Air\", found here: https://youtu.be/attb8PujeFc?t=568","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["redfangmusicvideo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Goal: Clone the visual effect of RED FANGâ€™s music video for No Air, found here: https://youtu.be/attb8PujeFc?t=568\n\n// Constants\nconst float kPI = 3.14159265359;\nconst vec4 kBackgroundColor = vec4( 0.58, 0.47, 0.27, 1.0 );\nconst float kTotalTime = 12.0;\n\n// Equilateral triangle \n// All triangles have these vertex positions relative to a center (0,0)\n// Note the dy: this shift up the triangle to the centroid, so rotations look much better\nconst float dy = 86.0 / 3.0;\nconst vec2 kVertA = vec2( -50.0, 0.0 - dy );\nconst vec2 kVertB = vec2( 50.0, 0.0 - dy );\nconst vec2 kVertC = vec2( 0.0, 100.0 * 0.5 * sqrt(3.0) - dy );\n\n// Rotate a given point\n// Build a 2x2 rotation matrix that you can apply to a vec2 for rotating a point about the origin\nmat2 GetRotationMatrix2D( float theta )\n{\n\t// Simple affine transform matrix\n    return mat2( cos( theta ),-sin( theta ),\n                 sin( theta ), cos( theta ) );\n}\n\n// Geometry functions based on distance-functions: \n// https://iquilezles.org/articles/distfunctions\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdCapsuleAnimated( vec2 p, vec2 a, vec2 b, float r, float t )\n{\n    // Special rule: if t is zero, do nothing\n    if( t <= 0.0 )\n        return 0.0;\n    \n    // Compute moving dest, which is assumed 2nd arg\n    b = a + (b - a) * t;\n    \n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdDashedCapsule( vec2 p, vec2 a, vec2 b, float r, float dashT )\n{\n    // Dash pattern\n    float dist = length( a - ((b - a) * dashT + p) );\n    if( mod( dist, 8.0 ) < 4.0 )\n        return 0.0;\n    \n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdDashedCapsuleAnimated( vec2 p, vec2 a, vec2 b, float r, float t, float dashT )\n{\n    // Special rule: if t is zero, do nothing\n    if( t <= 0.0 )\n        return 0.0;\n    \n    // Dash pattern\n    float dist = length( a - ((b - a) * dashT + p) );\n    if( mod( dist + dashT, 8.0 ) < 4.0 )\n        return 0.0;\n    \n    // Compute moving dest, which is assumed 2nd arg\n    b = a + (b - a) * t;\n    \n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return 1.0 - clamp( length( pa - ba*h ) - r, 0.0, 1.0 );\n}\n\nfloat sdStrokeTriangle( vec2 p, vec2 a, vec2 b, vec2 c, float r )\n{\n    float total = 0.0;\n    \n    total += sdCapsule( p, a, b, r );\n    total += sdCapsule( p, b, c, r );\n    total += sdCapsule( p, c, a, r );\n    \n    return total;\n}\n\nfloat sdStrokeHexagon1( vec2 fragCoord, vec2 centerPoint )\n{\n    float total = 0.0;\n    \n    vec2 a = centerPoint + kVertA * 1.0;\n    vec2 b = centerPoint + kVertB * 1.0;\n    vec2 c = centerPoint + kVertC * 1.0;\n    \n    vec2 d = centerPoint + kVertA * vec2(1, -1);\n    vec2 e = centerPoint + kVertB * vec2(1, -1);\n    vec2 f = centerPoint + kVertC * vec2(1, -1);\n    \n    total += sdCapsule( fragCoord, b, f, 1.0 );\n    total += sdCapsule( fragCoord, f, a, 1.0 );\n    total += sdCapsule( fragCoord, a, d, 1.0 );\n    total += sdCapsule( fragCoord, d, c, 1.0 );\n    total += sdCapsule( fragCoord, c, e, 1.0 );\n    total += sdCapsule( fragCoord, e, b, 1.0 );\n    \n    return total;\n}\n\nfloat sdStrokeAnimatedTriangle( vec2 p, float thickness, vec2 trans, float scale, float theta, float t )\n{\n    float total = 0.0;\n    const float kFloatThirdTime = ( 1.0 / 3.0 );\n    \n    // Scale, rotate, and translate triangle\n    vec2 a = kVertA * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 b = kVertB * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 c = kVertC * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    if( t < kFloatThirdTime  )\n    {\n        total += sdCapsuleAnimated( p, a, b, thickness, t / kFloatThirdTime );\n    }\n    else if( t < (2.0 * kFloatThirdTime) )\n    {\n        total += sdCapsule( p, a, b, thickness );\n        total += sdCapsuleAnimated( p, b, c, thickness, ( t - kFloatThirdTime ) / kFloatThirdTime );\n    }\n    else\n    {\n        total += sdCapsule( p, a, b, thickness );\n        total += sdCapsule( p, b, c, thickness );\n        total += sdCapsuleAnimated( p, c, a, thickness, ( t - 2.0 * kFloatThirdTime ) / kFloatThirdTime );\n    }\n    \n    return total;\n}\n\nfloat sdStrokeAnimatedDashedTriangle( vec2 p, float thickness, vec2 trans, float scale, float theta, float t )\n{\n    float total = 0.0;\n    const float kFloatThirdTime = ( 1.0 / 3.0 );\n    \n    float dashT = -iTime / 5.0;\n    \n    // Scale, rotate, and translate triangle\n    vec2 a = kVertA * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 b = kVertB * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 c = kVertC * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    if( t < kFloatThirdTime  )\n    {\n        total += sdDashedCapsuleAnimated( p, a, b, thickness, t / kFloatThirdTime, dashT );\n    }\n    else if( t < (2.0 * kFloatThirdTime) )\n    {\n        total += sdDashedCapsule( p, a, b, thickness, dashT );\n        total += sdDashedCapsuleAnimated( p, b, c, thickness, ( t - kFloatThirdTime ) / kFloatThirdTime, dashT );\n    }\n    else\n    {\n        total += sdDashedCapsule( p, a, b, thickness, dashT );\n        total += sdDashedCapsule( p, b, c, thickness, dashT );\n        total += sdDashedCapsuleAnimated( p, c, a, thickness, ( t - 2.0 * kFloatThirdTime ) / kFloatThirdTime, dashT );\n    }\n    \n    return total;\n}\n\n\nfloat sdStrokeAnimatedHexagonl( vec2 p, float thickness, vec2 trans, float scale, float theta, float t )\n{\n    float total = 0.0;\n    \n    vec2 a = kVertA * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 b = kVertB * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 c = kVertC * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    vec2 d = kVertA * vec2(1.0, -1.0) * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 e = kVertB * vec2(1.0, -1.0) * scale * GetRotationMatrix2D( theta ) + trans;\n    vec2 f = kVertC * vec2(1.0, -1.0) * scale * GetRotationMatrix2D( theta ) + trans;\n    \n    // Animation trick: take the normalized time, grow it by 6, then offset it\n    // based on which segment we're working on, then re-normalize\n    \n    total += sdCapsuleAnimated( p, b, f, 1.0, clamp( (t * 6.0 - 0.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, f, a, 1.0, clamp( (t * 6.0 - 1.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, a, d, 1.0, clamp( (t * 6.0 - 2.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, d, c, 1.0, clamp( (t * 6.0 - 3.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, c, e, 1.0, clamp( (t * 6.0 - 4.0), 0.0, 1.0 ) );\n    total += sdCapsuleAnimated( p, e, b, 1.0, clamp( (t * 6.0 - 5.0), 0.0, 1.0 ) );\n    \n    return total;\n}\n\n\n// Normalized time generation method: returns 0.0 until iTime hits the desired time interval, which then normalizes it to [0.0, 1.0]\n// Animation loops after the given max time\nfloat AnimationTime( float startTime, float endTime, float initialDelay, float repeatTime )\n{\n    // Mod based on desired repeat time\n    initialDelay = 0.0;\n    float t = mod( max( 0.0, iTime - initialDelay ), repeatTime );\n    return clamp( ( t - startTime ) / ( endTime - startTime ), 0.0, 1.0 );\n}\n\nfloat Triangle1( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    // 1 second delay, starts at about full-screen, zooms in until we start rotating..\n    float thicknessAnimation = 1.0 + 5.0 * ( 1.0 - AnimationTime( 0.0, 3.5, delay, kTotalTime ) );\n    float theta = -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 4.0, 4.8, delay, kTotalTime ) )\n            \t+ -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 0.0, 3.5, delay, kTotalTime );\n    float scaleAnimation = 3.5 - sin( 0.5 * kPI * AnimationTime( 0.0, 3.5, delay, kTotalTime ) * 1.0 )\n            \t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n\n    return sdStrokeAnimatedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Triangle2( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float thicknessAnimation = 0.5;\n    float theta = kPI + -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 4.0, 4.8, delay, kTotalTime ) )\n        \t\t+ -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 3.5, 4.5, delay, kTotalTime );\n    float scaleAnimation = 0.5 * ( 3.5 - sin( 0.5 * kPI * AnimationTime( 0.0, 3.5, delay, kTotalTime ) * 1.0 ) )\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n\n    return sdStrokeAnimatedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Hexagonl1( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float strokeAnimation = sin( 0.5 * kPI * AnimationTime( 5.0, 7.0, 1.0, kTotalTime ) );\n    float theta = -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float scaleAnimation = 2.5\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n\n    return sdStrokeAnimatedHexagonl( fragCoord, 1.0, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Triangle3( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float thicknessAnimation = 0.5\n        \t\t\t\t\t + 2.0 * ( 0.5 + 0.5 * sin( iTime * 8.0 ) ) * sin( 0.5 * kPI * AnimationTime( 7.5, 10.0, 1.0, kTotalTime ) );\n    float theta = -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 5.5, 7.0, delay, kTotalTime );\n    float scaleAnimation = 1.25\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n    \n    return sdStrokeAnimatedDashedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nfloat Triangle4( vec2 fragCoord, vec2 centerPoint )\n{\n    const float delay = 1.0;\n    \n    float thicknessAnimation = 0.5\n        \t\t\t\t\t + 2.0 * ( 0.5 + 0.5 * sin( iTime * 8.0 + 4.0 ) ) * sin( 0.5 * kPI * AnimationTime( 7.5, 10.0, 1.0, kTotalTime ) );\n    float theta = kPI -( 2.0 / 3.0 ) * kPI * sin( 0.5 * kPI * AnimationTime( 7.0, 7.8, delay, kTotalTime ) );\n    float strokeAnimation = AnimationTime( 5.5, 7.0, delay, kTotalTime );\n    float scaleAnimation = 2.5\n        \t\t\t\t + 20.0 * sin( 0.5 * kPI * AnimationTime( 11.0, 14.0, 1.0, kTotalTime ) );\n    \n    return sdStrokeAnimatedDashedTriangle( fragCoord, thicknessAnimation, centerPoint, scaleAnimation, theta, strokeAnimation );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Compute visual center\n    vec2 centerPoint = iResolution.xy / 2.0;\n    \n    // Sum all the animated geometries\n    float color = 0.0;\n    color += Triangle1( fragCoord, centerPoint );\n    color += Triangle2( fragCoord, centerPoint );\n    color += Hexagonl1( fragCoord, centerPoint );\n    color += Triangle3( fragCoord, centerPoint );\n    color += Triangle4( fragCoord, centerPoint );\n    \n    // Apply final coloring rule: 0.0 means black, 1.0 means background color\n    fragColor = ( 1.0 - clamp( color, 0.0, 1.0 ) ) * kBackgroundColor;\n}","name":"Image","description":"","type":"image"}]}