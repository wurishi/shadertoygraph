{"ver":"0.1","info":{"id":"MsKfRR","date":"1527514293","viewed":288,"name":"Ocean-SnowMountain","username":"senzheng","description":"SnowMoutainTest","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["terrain","ocean","snow","mountain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"Xsf3Rr","filepath":"/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","previewfilepath":"/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_RAYMARCHING_COUNT 96\n#define PRECISION 0.00003\n#define FAR 100.\n#define mouse (iMouse.xy / iResolution.xy)\n#define time iTime\n\nconst mat2 m2 = mat2( 0.60, -0.80, 0.80, 0.60 );\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat hash( float n ) { return fract(sin(n)*753.5453123); }\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nvec4 noised( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 w = fract(x);\n\tvec3 u = w*w*(3.0-2.0*w);\n    vec3 du = 6.0*w*(1.0-w);\n    \n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    \n    float a = hash(n+  0.0);\n    float b = hash(n+  1.0);\n    float c = hash(n+157.0);\n    float d = hash(n+158.0);\n    float e = hash(n+113.0);\n\tfloat f = hash(n+114.0);\n    float g = hash(n+270.0);\n    float h = hash(n+271.0);\n\t\n    float k0 =   a;\n    float k1 =   b - a;\n    float k2 =   c - a;\n    float k3 =   e - a;\n    float k4 =   a - b - c + d;\n    float k5 =   a - c - e + g;\n    float k6 =   a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n\n    return vec4( k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z, \n                 du * (vec3(k1,k2,k3) + u.yzx*vec3(k4,k5,k6) + u.zxy*vec3(k6,k4,k5) + k7*u.yzx*u.zxy ));\n}\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\nfloat triNoise3d(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat fogmap(in vec3 p, in float d)\n{\n    p.x += iTime*1.1;\n    p.z += sin(p.x*.5);\n    return triNoise3d(p*2.2/(d+20.),0.2)*(1.-smoothstep(0.,1.8,p.y));\n}\n\nvec3 fog(in vec3 col, in vec3 ro, in vec3 rd, in float mt)\n{\n    float d = .1;\n    for(int i=0; i<30; i++)\n    {\n        vec3  pos = ro + rd*d;\n        float rz = fogmap(pos, d);\n\t\tfloat grd =  clamp((rz - fogmap(pos+.8-float(i)*0.1,d))*3., 0.1, 1. );\n        vec3 col2 = (vec3(1.)*.5 + .5*vec3(1.)*(1.7-grd))*0.55;\n        col = mix(col,col2,clamp(rz*smoothstep(d-0.4,d+2.+d*.75,mt),0.,1.) );\n        d *= 1.5+0.3;\n        if (d>mt)break;\n    }\n    return col;\n}\n\n//------------------------------------------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, 0.001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nmat3 setCamera(vec3 ro, vec3 lookAt) {\n\tvec3 cw = normalize(lookAt-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nfloat sminP(float a, float b , float s){\n    \n    float h = clamp( 0.5 + 0.5*(b-a)/s, 0. , 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\nvec2 map(vec3 p, float concernWater) {\n    float d = 0.0;\n    vec2 q = p.xz*0.02;\n    float h = 0.;\n    float s = 1.0;\n    /*for (int i = 0 ; i < 10 ; i++) {\n        h += s*noise(vec3(q, 1.));\n        q = m2 * q * 2.01;\n        s *= 0.49;\n    }\n    h *= 23.;\n\t*/\n    for (int i = 0 ; i < 9 ; i++) {\n        h += s*noise(vec3(q, 1.));\n        q = m2 * q * 3.01;\n        s *= 0.334;\n    }\n    h *= 25.;\n    \n    if (concernWater == 1.0) {\n        q = m2*p.xz*0.2;\n        float o = 0.;\n        float t = iTime * 0.3;\n        s = 0.3;\n        for (int i = 0 ; i < 5 ; i++) {\n            o += s*noise(vec3(q + t, 1.));\n            q = m2 * q * 1.98;\n            s *= 0.51;\n            t *= 1.5;\n        }\n        o += 4.;\n\n        float d = p.y - max(h, o);\n    \treturn vec2(d, smoothstep(0., abs(noise(p*2.))*1.+0.03, h-o));\n    \t//return vec2(d, step(0.0, h-o));\n    \n    } else {\n    \n        float d = p.y - h;\n        return vec2(d, 1.0);\n    }\n    \n    \n}\n\n\nvec2 rayMarching(vec3 ro, vec3 rd, float concernWater) {\n\t\n\tfloat t = 0.01, told = 0., mid, dn;\n    vec2 res = map(rd*t + ro, concernWater);\n    float d = res.x;\n    float m = res.y;\n    float sgn = sign(d);\n    \n    for (int i = 0 ; i < MAX_RAYMARCHING_COUNT ; i++) {\n    \tif (sign(d) != sgn || d < PRECISION || t > FAR) break;\n        \n        told = t;\n        t += max(d/2.0, t*0.02);\n        res = map(rd*t + ro, concernWater);\n        d = res.x;\n        m = res.y;\n    }\n    \n    if (sign(d) != sgn) {\n        res = map(rd*told + ro, 1.0);\n    \tdn = sign(res.x);\n        vec2 iv = vec2(told, t);\n        \n        for (int j = 0 ; j < 8 ; j++) {\n        \tmid = dot(iv, vec2(.5));\n            res = map(rd*mid + ro, concernWater);\n            d = res.x;\n        \tm = res.y;\n            if (abs(d) < PRECISION) break;\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y),step(0.0, d*dn));\n        }\n        t = mid;\n    }\n    \n    return vec2(min(t, FAR), res.y);\n    \n}\n\n// Tetrahedral normal, courtesy of IQ.\nvec3 calcuNormal(in vec3 p, float concernWater)\n{  \n    vec2 e = vec2(-1., 1.)*0.03;   \n\treturn normalize(e.yxx*map(p + e.yxx, concernWater).x + e.xxy*map(p + e.xxy, concernWater).x + \n\t\t\t\t\t e.xyx*map(p + e.xyx, concernWater).x + e.yyy*map(p + e.yyy, concernWater).x );   \n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, float concernWater)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t , concernWater).x;\n        res = min( res, 0.4*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<PRECISION || t>tmax ) break;\n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos , 1.0).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\nvec3 cloud(in vec3 bgCol, in vec3 ro, in vec3 rd, float spd) {\n    float t = iTime*spd;\n    vec2 sc = ro.xz + rd.xz*(120000.)/rd.y;\n    vec2 p = sc * 0.000007;\n    float f = 0.;\n    float s = 1.;\n    float sum = 0.;\n    for (int i = 0 ; i < 6 ; i++) {\n    \tp += t;\n        t *= 1.5;\n        f += s*abs(noise(vec3(p, 0.)));\n        p = m2 * p * 2.01;\n        sum += s;\n        s *= 0.6;\n    }\n    vec3 col = mix(bgCol, vec3(1.), smoothstep(0.0, 1.0, pow(f/sum, 0.5)) * pow(max(rd.y, 0.), 0.5));\n    //col = vec3(f/sum);\n    return col;\n}\n\nvec3 sun(vec3 lightPos, in vec3 ro, in vec3 rd) {\n\tfloat sunStength = clamp(dot(rd, normalize(lightPos)), 0., 1.);\n    vec3 col = 0.2*vec3(1.0, 0.5, 0.4) * pow(sunStength, 256.0);\n    col += 1.8*vec3(1.0, 0.5, 0.4) * pow(sunStength, 512.0);\n    //col += 0.4*vec3(1.0, 0.7, 0.4) * pow(sunStength, 1024.0);\n    return col;\n}\n/*\nvec3 bgCol1 = vec3(1.0);\nvec3 bgCol2 = vec3(0.9137, 0.9176, 0.898);\nvec3 bgCol3 = vec3(0.9137, 0.9176, 0.898);\n*/\n//vec3 mountainCol = vec3(0.6, 0.49, 0.313)*0.5;\nvec3 bgCol1 = vec3(0.98, 0.95, 0.93);\nvec3 bgCol2 = vec3(0.125, 0.550, 0.60);\nvec3 bgCol3 = vec3(0.0, 0.40, 0.41);\n\nvec3 sky(in vec3 ro, in vec3 rd) {\n\t\n    vec3 skyCol = mix(bgCol2, bgCol3, smoothstep(0., 0.3, rd.y));\n    skyCol = mix(bgCol1, skyCol, smoothstep(-0.3, 0.12, rd.y));\n    skyCol = cloud(skyCol, ro, rd, .3);\n    \n    skyCol += sun(vec3(-0.7, 0.3, 1.0), ro, rd);\n    \n    return skyCol;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n    vec2 res = rayMarching(ro, rd, 1.0);\n    float t = res.x;\n    float m = res.y;\n    vec3 col = vec3(0.);\n    vec3 shdCol = vec3(0.1294, 0.1882, 0.207);\n    \n    vec3 bgCol = sky(ro, rd);\n    \n    if (t < FAR) {\n        vec3 sp = ro + rd*t;\n    \tvec3 nor = calcuNormal(sp, 1.0); \n        \n        vec3 lp =vec3(10.0*sin(time/1.), 7.0, 10.0*cos(time/1.)+time*3.-4.);\n        vec3 ld = normalize(lp - sp);\n        ld = vec3(-1.0, 0.8, -1.0);\n        lp = normalize(ld + sp);   \n\n        //float shd = softShadow(sp, ld, 0.5, FAR, 3.);\n        float shd = calcSoftshadow( sp, ld, 0.5, FAR, 1.0);\n\n        float occ = calcAO( sp, nor );\n\n        vec3 hal = normalize( ld - rd );\n        float amb = clamp( 0.3+ 0.7*nor.y, 0.0, 1.0 );\n        float dif = max( dot( ld, nor ), 0.0); // Diffuse term.\n        //dif += 0.5*max( dot( ld*vec3(-1., 1., -1.), nor ), 0.0); // Diffuse term.\n        float speWater = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 128.0)*dif ; // Specular term.\n        float speMoun = pow( clamp( dot( nor, hal ), 0.0, 1.0 ), 32.0)*dif ; // Specular term.\n        float bac = clamp( dot( nor, normalize(vec3(-lp.x,0.0,-lp.z))), 0.0, 1.0 )*clamp( 1.0-sp.y,0.0,1.0);\n        float fre = clamp(1.0 + dot(rd, nor), 0.0, 1.0); // Fresnel reflection term.\n\n        \n        if(res.y == 0.0) {\n            float fre = clamp(dot(-rd, nor), 0.0, 0.2);\n            fre = smoothstep(0., 0.6, pow(fre, 1.6));\n            fre = fre * 0.7;\n            vec3 reflectCol = sky(sp, reflect(rd, nor));\n            \n        \tcol = mix(reflectCol, vec3(0.2, 0.3, 0.4), fre);\n            \n        \t//col = vec3(lin);\n            \n            vec3 nrd = refract(rd, nor, 1./1.333);\n            vec2 nres = rayMarching(sp, nrd, 0.0);\n            float nt = nres.x;\n            float nm = nres.y;\n            vec3 nsp = sp + nrd*nt;\n            vec3 nnor = calcuNormal(nsp, 0.0);\n            \n        \tfloat nshd = calcSoftshadow( sp, ld, 0.5, FAR, 0.0 );\n            \n            vec3 nhal = normalize( lp - nrd );\n            float namb = clamp( 0.3+ 0.7*nnor.y, 0.0, 1.0 );\n            float ndif = max( dot( ld, nnor ), 0.0); // Diffuse term.\n            float nspeMoun = pow( clamp( dot( nnor, nhal ), 0.0, 1.0 ), 32.0)*ndif ; // Specular term.\n            vec3 ncol = tex3D( iChannel0,sp/10., nnor );\n            \n            vec3 nlin = vec3(1.) * ndif * nshd;\n            nlin += 0.5*namb*bgCol2;\n            nlin += 0.1*nspeMoun*vec3(1.0,1.0,1.0);\n\n            ncol *= nlin;\n            \n            col = mix(ncol, col, smoothstep(0.0, 1., (1.-fre*0.7 )*smoothstep(0.0, 1.7, 0.5+nt)));\n            \n            col += speWater*vec3(1.0,1.0,1.0)*occ;\n            col *= smoothstep(0.0, 0.4, shd);\n            //col = ncol;\n        } else {\n\t\t\tvec3 mountainCol = tex3D( iChannel0, sp/10., nor );\n            col = mountainCol;\n            col = mix(col, vec3(0.9), smoothstep(0.45, 0.6, dot(nor, normalize(vec3(-0.3, 1.0, 0.0))\t)));\n            col = mix(col, mountainCol, 1.-smoothstep(0., 1., m\t));\n\n            vec3 lin = vec3(1.) * dif * shd;\n            lin += 0.5*amb*bgCol2*occ;\n            //lin += 0.3*bac*vec3(0.4)*occ;\n            lin += 0.1*speMoun*vec3(1.0,1.0,1.0)*occ;\n\n            col *= lin;\n\n\n            //col = vec3(shd);\n            //col = vec3(smoothstep(0.4, 0.52, nor.y));\n            //col = vec3(speMoun);\n\n        }\n        \n\n    } else {\n        col = bgCol;\n    }\n    float e = clamp(dot(rd, normalize(vec3(-0.7, 0.3, 1.0))), 0.0, 1.0);\n    vec3 fogCol = mix(bgCol, vec3(1.0, 1.0, 0.9)*1.2, pow(e, 32.));\n    col = mix(col, fogCol, smoothstep(5., FAR, t));\n    \n    col = mix(col, fog(col, ro, rd, t*1.2), 1.);\n    //col = pow(col, vec3(0.9));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    \n    vec3 ro = vec3(0., 12., time*4.);\n    vec3 lookAt = vec3(sin(mouse.x*3.1415926*2.), ro.y, ro.z+cos(mouse.x*3.1415926*2.));\n    mat3 viewMat = setCamera(ro, lookAt);\n    vec3 rd = viewMat * normalize(vec3(p, 1.5));\n    \n    vec3 col = render( ro, rd );\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}