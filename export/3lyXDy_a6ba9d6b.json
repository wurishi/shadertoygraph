{"ver":"0.1","info":{"id":"3lyXDy","date":"1583454825","viewed":162,"name":"trippy spheres","username":"leocaus","description":"trippy spheres in modulo space","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"int MAX_STEPS = 2000;\nfloat SURF_DIST = .05;\nfloat MAX_DIST = 5000.;\nvec3 modv = vec3(3., 6., 6.);\n\n\nvec3 world2modSpace(vec3 p){\n\t\n    \n    if(modv.x > 0.){\n    \tp.x = mod(p.x-modv.x/2., modv.x)-modv.x/2.;\n    }\n    \n    if(modv.y > 0.){\n    \tp.y = mod(p.y-modv.y/2., modv.y)-modv.y/2.;\n    }\n    \n    if(modv.z > 0.){\n    \tp.z = mod(p.z-modv.z/2., modv.z)-modv.z/2.;\n    }\n    \n    \n\treturn p;\n}\n\nvec3 world2cellSpace(vec3 p){\n\t\n    vec3 i = vec3(0);\n    \n    if(modv.x > 0.){\n    \ti.x = floor((p.x+modv.x/2.)/modv.x);\n    }\n    if(modv.y > 0.){\n    \ti.y = floor((p.y+modv.y/2.)/modv.y);\n    }\n    if(modv.z > 0.){\n    \ti.z = floor((p.z+modv.z/2.)/modv.z);\n    }\n    \n    \n\treturn i;\n}\n\nvec3 rotateVec3(vec3 v, float thet, float phi){\n\tvec3 v1 = vec3(v.x*cos(thet)-v.y*sin(thet), v.x*sin(thet)+v.y*cos(thet), v.z);  \n    return vec3(v1.x*cos(phi)-v1.z*sin(phi), v1.y , v1.x*sin(phi)+v1.z*cos(phi));\n}\n\nfloat distToPyramid( vec3 p, float s)\n{\n  \tp = abs(p);\n    if(p.z<0.){\n        float angle = atan(p.y/p.x);\n    \tfloat thet = mod(angle, 3.1415/4.)*sign(sin(angle*4.))+3.1415*(1.-sign(sin(angle*4.)))/8.;\n        float l = s*sqrt(2.)/(2.*cos(thet));\n        if(length(p.xy)<l){\n        \treturn length(p.z);\n        }else{\n        \treturn length(p-sign(p.x)*vec3(l*sin(angle), l*cos(angle), 0.));\n        }\n\t\t\n    }else{\n        p = abs(p);\n    \treturn (p.x+p.y+p.z-s)*0.57735027;\n    }\n    \n}\n\nfloat distToSphere(vec3 p, vec3 sc, float r){\n    vec3 D = p-sc;\n    float L = length(D);   \n    return L-r;\n}\n\nfloat getDist(vec3 p){\n    \n    vec3 modp = world2modSpace(p);\n    float t = iTime;\n    vec3 ip = world2cellSpace(p);\n\t//float dS1 = distToSphere(p, vec3 (0.,0.,0.), 1.);\n\tfloat dS0 = distToSphere(modp, rotateVec3(vec3 (0.,0.,0.), 3.1415/4.*sign(ip.x-0.01)*sign(ip.y-0.01), 0.), abs(0.75*sin(3.*ip.x+iTime)));\n    float dS1 = distToPyramid(rotateVec3(modp, 3.1415/2., -sign(ip.y-0.1)*1.*iTime+length(ip)/17.154), 0.75);\n\t//float dS1 = 100.;\n    float dS2 = distToSphere(modp, vec3 (0.,0.,1.), .25);\n    float dS3 = distToSphere(modp, vec3 (0.,0.,-1.), .25);\n    return dS0;\n    //return min(dS1,min(dS2,dS3));\n}\n\nvec3 getNormal(vec3 p){\n    \n    float d = getDist(p);\n\t\n    vec3 n = vec3(0.);\n    vec2 e = vec2(.01,0.);\n    \n    if(d < 2.*SURF_DIST){\n    \tn = d - vec3(getDist(p-e.xyy),getDist(p-e.yxy),getDist(p-e.yyx));\n        n = normalize(n);\n    }\n    \n    //if(length(p)>= MAX_DIST-SURF_DIST) n = vec3(0.0);\n\treturn n;\n}\n\nfloat RayMarch(vec3 rp, vec3 rd){\n\t\n    float dO = 0.;\n    \n    for(int i = 0; i<MAX_STEPS; i++){\n    \tvec3 p = rp+rd*dO;\n        float d = getDist(p);\n        \n        dO += d;\n        \n        if(dO > MAX_DIST || d < SURF_DIST) break;\n        \n    }\n  \t\n    return dO;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{ \n    float t = iTime;\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/(iResolution.x*0.5);\n    vec3 cp = vec3(t,modv.y/2.,modv.z/2.);\n    vec3 cd = normalize(vec3(1.0, 0.*cos(t/5.), 0.*sin(t/5.)));\n    vec3 cu = normalize(vec3(0.,sin(iTime/15.),cos(iTime/15.)));\n    \n    float fov = 45.*3.1415/360.;\n    float dov = 1./tan(fov);\n    \n    vec3 cx = normalize(cross(cu, cd));\n    vec3 cy = normalize(cross(cd, cx));\n    \n    vec3 rd = normalize(dov*cd+uv.x*cx+uv.y*cy);\n    \n    float d = RayMarch(cp, rd);\n    \n    vec3 n = getNormal(cp+rd*d);\n\t\n    vec3 i = world2cellSpace(cp+rd*d);\n    \n    // Output to screen\n    fragColor = vec4(abs(rotateVec3((1.+n)/2., length(i)/5. +t ,length(i)/5.)),1.);\n    \n}\n","name":"Image","description":"","type":"image"}]}