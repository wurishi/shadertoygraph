{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[{"channel":0,"type":"texture","id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":1,"type":"texture","id":"4sXGRn","filepath":"/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg","sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"channel":2,"type":"cubemap","id":"XdX3zn","filepath":"/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg","sampler":{"filter":"linear","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}}],"code":"struct ray_t\n{\n\tvec3 origin;\n\tvec3 direction;\n};\n\t\nstruct sphere_t\n{\n\tvec3 origin;\n\tfloat radius;\n};\n\t\nstruct plane_t\n{\n\tvec3  normal;\n\tfloat offset;\n\tvec3 orientation;\n};\n\t\nstruct light_t\n{\n\tvec3  direction;\n\tfloat contribution;\n};\n\nstruct surface_t\n{\n\tint  identifier;\n\tvec3 position;\n\tvec3 normal;\n\tvec3 tangent;\n\tvec3 binormal;\n\tvec2 uv;\n};\n\t\nstruct material_t\n{\n\tvec3  color;\n\tfloat roughness;\n};\n\t\nconst int NONE   = 0;\nconst int PLANE  = 1;\nconst int SPHERE = 2;\n\t\nconst float PI = 3.14;\nconst float PI_2 = PI / 2.0;\nconst float PIx2 = PI * 2.0;\nconst float max_distance = 1e5;\n\t\nfloat intersect_sphere( const in sphere_t sphere, const in ray_t ray, out surface_t surface )\n{\n\tmat4 world_to_object = mat4(\n\t\t1.0, 0.0, 0.0, -sphere.origin.x,\n\t\t0.0, 1.0, 0.0, -sphere.origin.y,\n\t\t0.0, 0.0, 1.0, -sphere.origin.z,\n\t\t0.0, 0.0, 0.0, 0.0\n\t);\n\t\n\tvec3 position = vec3( vec4( ray.origin, 1.0 ) * world_to_object );\n\t\n\tconst float a = 1.0;\n\tfloat b = 2.0 * dot( position, ray.direction );\n\tfloat c = dot( position, position ) - pow( sphere.radius, 2.0 );\n\tfloat h = pow( b, 2.0 ) - 4.0 * a * c;\n\t\n\tif( h < 0.0 ) return max_distance; //no intersection\n\t\n\tfloat square_root = sqrt( h );\n\tfloat t1 = (-b + square_root) / ( 2.0 * a );\n\tfloat t2 = (-b - square_root) / ( 2.0 * a );\n\t\n\tif( t1 < t2 )\n\t{\n\t\tsurface.position = ray.origin + ray.direction * t1;\n\t}\n\telse\n\t{\n\t\tsurface.position = ray.origin + ray.direction * t2;\n\t}\n\t\n\tsurface.normal = normalize( ( surface.position - sphere.origin ) / sphere.radius );\n\n\tvec3 local_position = vec3( vec4( surface.position, 1.0 ) * world_to_object );\n\t\n\tfloat rho = sphere.radius;\n\tfloat theta = atan(local_position.x,local_position.z);\n\tfloat phi = acos(local_position.y/rho);\n\t\n\tconst vec3 i = vec3( 0.0, 0.0,-1.0 );\n\tconst vec3 j = vec3( 1.0, 0.0, 0.0 );\n\tconst vec3 k = vec3( 0.0, 1.0, 0.0 );\n\t\n\tsurface.normal   = vec3(sin( theta )*cos(phi), sin(phi), -cos(theta) * cos(phi));\n\tsurface.tangent  = vec3(cos(theta), 0,sin(theta));\n\tsurface.binormal = vec3(-sin(theta)*sin(phi), cos(phi), cos(theta)*sin(phi));\n\t\n\t\n\tsurface.uv = vec2( (theta+PI_2) / PI, phi/PI);\n\tsurface.identifier = SPHERE;\n\treturn min( t1, t2 );\n}\n\nfloat intersect_plane( const in plane_t plane, const in ray_t ray, out surface_t surface )\n{\n\tvec3 c = cos( plane.orientation ), s = sin( plane.orientation );\n\t\n\tmat3 rotation_x = mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, c.x,-s.z,\n\t\t0.0, s.x, c.x\n\t);\n\t\n\tmat3 rotation_y = mat3(\n\t\tc.y, 0.0,  s.y,\n\t\t0.0, 1.0,  0.0,\n\t   -s.y, 0.0,  c.y\n\t);\n\t\n\tmat3 rotation_z = mat3(\n\t\tc.z,-s.z,  0.0,\n\t\ts.z, c.z,  0.0,\n\t    0.0, 0.0,  1.0\n\t);\n\t\n\tvec3 plane_normal = normalize( plane.normal ) * rotation_x * rotation_y * rotation_z;\n\t\n\tvec3 /* normal_by_origin */ no = plane_normal * ray.origin;\n\tvec3 /* normal_by_direction */ nd = plane_normal * ray.direction;\n\tfloat distance_from_origin = ( - no.x - no.y - no.z - plane.offset ) / ( nd.x + nd.y + nd.z );\n\t\n\tsurface.position = ray.origin + ray.direction * distance_from_origin;\n\tsurface.normal   = plane_normal;\n\t\n\tmat3 rotation = rotation_x * rotation_y * rotation_z;\n\t\n\tconst vec3 i = vec3( 0.0, 0.0,-1.0 );\n\tconst vec3 j = vec3( 1.0, 0.0, 0.0 );\n\tconst vec3 k = vec3( 0.0, 1.0, 0.0 );\n\t\n\tsurface.normal   = k * rotation;\n\tsurface.tangent  = j * rotation;\n\tsurface.binormal =-i * rotation;\n\t\n\tvec3 local_position = surface.position*rotation;\n\tsurface.uv = vec2( local_position.x, -local_position.z);\n\t\n\tsurface.identifier = PLANE;\n\treturn distance_from_origin < 0.0 ? max_distance : distance_from_origin;\n}\n\nvoid compute_sinusoidale_normal1( inout surface_t surface )\n{\n\tvec2  gradient = vec2( sin( PIx2 * surface.uv.x ), cos( PIx2 * surface.uv.y));\n\tsurface.normal = normalize(surface.normal + surface.tangent * gradient.x + surface.binormal * gradient.y);\n}\n\nvoid compute_sinusoidale_normal2( inout surface_t surface )\n{\n\tvec2  gradient = vec2( cos( PIx2 * surface.uv.s ), sin( PIx2 * surface.uv.t ));\n\tsurface.normal = normalize(surface.normal + surface.tangent * gradient.x + surface.binormal * gradient.y);\n}\n\nfloat intersect( const in ray_t ray, out surface_t surface, out material_t material, const in int avoid )\n{\n\tvec3 posSphere1 =  vec3( cos( iTime ), 0.0, sin( iTime ) );\n\tsphere_t sphere1 = sphere_t( posSphere1, 1.0);\n\tvec3 posSphere2 =  vec3( -cos( iTime ), 0.0, -sin( iTime ) );\n\tsphere_t sphere2 = sphere_t( posSphere2, 1.0);\n\tconst plane_t  plane   = plane_t( vec3( 0.0, 1.0, 0.0 ), 0.6, vec3( PI / 20.0, 0.0, 0.0 ) );\n\t\n\tsurface_t surface_sphere1, surface_plane, surface_sphere2;\n\tfloat distance_from_sphere1 = intersect_sphere( sphere1, ray, surface_sphere1 );\n\tfloat distance_from_sphere2 = intersect_sphere( sphere2, ray, surface_sphere2 );\n\tfloat distance_from_plane  = intersect_plane( plane, ray, surface_plane );\n\t\n\tif( ( distance_from_sphere1 < distance_from_plane ) && ( distance_from_sphere1 < distance_from_sphere2 ) && ( avoid != SPHERE ) )\n\t{\n\t\tsurface = surface_sphere1;\n\t\tsurface.uv *= 7.0;\n\t\tcompute_sinusoidale_normal1( surface );\n\t\tmaterial.color = texture(iChannel0,surface.uv).rgb;\n\t\tmaterial.roughness = 0.8;\n\t}\n\telse if( ( distance_from_sphere2 < distance_from_plane ) && ( distance_from_sphere2 < distance_from_sphere1 ) && ( avoid != SPHERE ) )\n\t{\n\t\tsurface = surface_sphere2;\n\t\tsurface.uv *= 5.0;\n\t\tcompute_sinusoidale_normal2( surface );\n\t\tmaterial.color = texture(iChannel0,surface.uv).rgb;\n\t\tmaterial.roughness = 0.8;\n\t}\n\telse if( ( distance_from_plane < max_distance ) && ( avoid != PLANE ) )\n\t{\n\t\tsurface = surface_plane;\n\t\tmaterial.color = texture(iChannel1,surface.uv).rgb;\n\t\tmaterial.roughness = 0.1;\n\t}\n\telse\n\t{\n\t\tsurface.identifier = NONE;\n\t\tsurface.position   = vec3( 0.0 );\n\t\tsurface.normal     = vec3( 0.0 );\n\t}\n\t\n\treturn min( min(distance_from_sphere1, distance_from_sphere2), distance_from_plane );\n}\n\nvoid light0_information( const in surface_t surface, out light_t light )\n{\n\tvec3  directional_direction    = vec3( cos( iTime ), 1.0, sin( iTime ) );\n\tconst float directional_contribution = 1.0;\n\t\n\tlight.direction    = normalize( directional_direction );\n\tlight.contribution = directional_contribution;\n}\n\nvoid light1_information( const in surface_t surface, out light_t light )\n{\n\tconst vec3  point_position              = vec3(-5.0, 2.0, 0.0 );\n\tconst float point_contribution_modifier = 1.0;\n\t\n\tlight.direction    = normalize( point_position - surface.position );\n\tlight.contribution = length( light.direction ) * point_contribution_modifier;\n}\n\nvec3 illumination( const in ray_t ray, const in surface_t surface, const material_t material, const in light_t light )\n{\n    float power = mix( 35.0, 50.0, material.roughness );\n    vec3 half_vector = normalize( -ray.direction + light.direction );\n   \n    float diffuse  = max( 0.0, dot( surface.normal, light.direction ) );\n    float specular = pow( max( 0.0, dot( surface.normal, half_vector ) ), power );\n   \n    vec3 contribution_diffuse  = vec3(diffuse * light.contribution * material.color);\n\tvec3 fetch_cubemap = reflect(-ray.direction ,  surface.normal );\n    vec3 contribution_specular = vec3(specular * texture(iChannel2,fetch_cubemap));\n\t\n    float environment = 0.2 * max( 0.0,1.0 - dot(-ray.direction,surface.normal) );\n\tvec3 contribution_environment = environment * texture( iChannel2, fetch_cubemap ).rgb;\n\n    vec3 contribution = contribution_diffuse + contribution_specular + contribution_environment;\n    return contribution;\n}\n\nfloat shadow( const in surface_t surface, const in light_t light )\n{\n\tray_t shadow_ray;\n\tshadow_ray.origin    = surface.position;\n\tshadow_ray.direction = -light.direction;\n\t\n\tsurface_t  hitted_surface;\n\tmaterial_t hitted_material;\n\tfloat distance_from_object = intersect( shadow_ray, hitted_surface, hitted_material, surface.identifier );\n\t\n\treturn ( hitted_surface.identifier == SPHERE ) ? distance_from_object : max_distance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 screen_coordinate          = fragCoord.xy / iResolution.xy;\n\tvec2 screen_coordinate_centered = 2.0 * screen_coordinate - 1.0;\n\t\n\tfloat aspect_ratio = iResolution.x / iResolution.y;\n\tvec2  screen_coordinate_lens_corrected = vec2( aspect_ratio, 1.0 ) * screen_coordinate_centered;\n\t\n\tray_t primary_ray;\n\tprimary_ray.origin    = vec3( 0.0, 0.0, mix( 2.5, 3.0, 0.5 + 1.0 * sin( iTime ) ) );\n\tprimary_ray.direction = normalize( vec3( screen_coordinate_lens_corrected, -1.0 ) );\n\t\n\tsurface_t surface;\n\tmaterial_t material;\n\tfloat distance_from_origin = intersect( primary_ray, surface, material, NONE );\n\t\n\tconst vec3 background_color = vec3( 0.3, 0.3, 0.5 );\n\tif( ( distance_from_origin < max_distance ) && surface.identifier != NONE )\n\t{\n\t\tlight_t light;\n\t\tvec3 illumination_from_light = vec3( 0.0 );\n\t\t\n\t\tlight0_information( surface, light );\n\t\tvec3 illumination_light0 = illumination( primary_ray, surface, material, light ); \n\t\tfloat shadow_cast_light0  = shadow( surface, light );\n\t\t\n\t\tlight1_information( surface, light );\n\t\tvec3 illumination_light1 = illumination( primary_ray, surface, material, light ); \n\t\tfloat shadow_cast_light1  = shadow( surface, light );\n\t\t\n\t\tillumination_from_light += illumination_light0 * clamp( shadow_cast_light0, 0.0, 1.0 );\n\t\tillumination_from_light += illumination_light1 * clamp( shadow_cast_light1, 0.0, 1.0 );\n\t\t\n\t\tfragColor = vec4( vec3( illumination_from_light ), 1.0 );\n\t\t\n\t}\n\telse\n\t{\n\t\tfragColor = vec4( texture( iChannel2, primary_ray.direction ) );\n\t}\n\t\n\t\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4dB3Rt","date":"1392023204","viewed":163,"name":"Best Shader Ever","username":"Souf","description":"Laroy Shader 2","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["shader"],"hasliked":0,"parentid":"","parentname":""}}