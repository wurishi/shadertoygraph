{"ver":"0.1","info":{"id":"WstBRB","date":"1605440427","viewed":54,"name":"Julia set exploration","username":"Atchafalaya","description":"Exploring the Julia set and the convergence of the complex function f(z) = z² + c.\nUse the mouse to follow the iterations of the function.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fractal","julia","exploration"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\nExploring the Julia set and the convergence of the complex function f(z) = z² + c.\nPause and use the mouse to follow the iterations of the function.\nFeel free to change the c parameter as you please to explore other forms of the Julia set\nTry to find the attracting and repelling points or some periodic cycles.\n\nRelated work :\nhttps://www.shadertoy.com/view/Wd3BzB\nhttps://www.shadertoy.com/view/wd3BDM\nhttps://www.shadertoy.com/view/3d3BWH\n*/\n\n\n#define R iResolution\n#define MAX_ITERATION 512\n#define BAILOUT_THRESHOLD 10000.\n#define LINE_WIDTH 0.00005\n\nvec2 cmul(vec2 a, vec2 b)\n{\n    return vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\nvec2 polynome(vec2 z, vec2 c)\n{\n    return cmul(z, z) + c;\n}\n\nfloat juliaDist(vec2 z, vec2 c)\n{\n    int i = 0;\n    float lz2 = 0.;\n    vec2 dz = vec2(1., 0.);\n    while (i < MAX_ITERATION && lz2 < BAILOUT_THRESHOLD)\n    {\n        dz = 2. * cmul(z, dz);\n        z = polynome(z, c);\n        lz2 = dot(z, z);\n        i++;\n    }\n    if (lz2 < BAILOUT_THRESHOLD)\n    {\n        return -1.;\n    }\n    else\n    {\n        return sqrt(lz2) * 0.5 * log(lz2) / length(dz);\n    }    \n}\n\nvec3 palette(float d)\n{\n    if (d < 0.)\n    {\n        return vec3(0., 0.3, 0.8);\n    }\n    else \n    {\n        vec3 col = vec3(0.1, 0.6, 0.95);\n        col *= 1. - (1. / (1. + 25. * d));\n        col = mix(col, vec3(.8), smoothstep(0.02, 0., d));\n        return col;\n    }\n}\n\nvec2[15] computeSeries(vec2 z0, vec2 c)\n{\n    // if you know how to do this better, please comment\n\tvec2 series[15] = vec2[15](vec2(0.), vec2(0.), vec2(0.), vec2(0.), vec2(0.),\n                               vec2(0.), vec2(0.), vec2(0.), vec2(0.), vec2(0.),\n                               vec2(0.), vec2(0.), vec2(0.), vec2(0.), vec2(0.));\n\t\n    series[0] = z0;\n    for (int i = 1; i < 15; i++)\n    {\n        series[i] = polynome(series[i - 1], c);\n    }\n    return series;\n}\n\nvec3 showSeries(vec3 col, vec2 series[15], vec2 uv)\n{\n    for (int i = 0; i < 14; i++)\n    {\n        vec2 dir = series[i + 1] - series[i];\n        float ldir = length(dir);\n        dir /= ldir;\n        float adj = dot(uv - series[i], dir);\n        vec2 proj = (uv - series[i]) - adj * dir;\n        if (adj > 0. && adj < ldir && dot(proj, proj) < LINE_WIDTH)\n        {\n            return vec3(0.9, 0.6, 0.1);\n        }\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R.xy) / R.y;\n    vec2 mouse = (2. * iMouse.xy - R.xy) / R.y;\n\n    float zoom = 1.5;\n    uv *= zoom;\n    mouse *= zoom;\n    \n    float time = 0.2 * iTime + 1.62;\n    vec2 c = 0.7885 * vec2(cos(time), sin(time));\n    vec3 col = palette(juliaDist(uv, c));\n    \n    if (iMouse.z > 0.)\n    {\n    \tvec2 series[15] = computeSeries(mouse, c);\n    \tcol = showSeries(col, series, uv);\n    }\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}