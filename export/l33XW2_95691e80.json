{"ver":"0.1","info":{"id":"l33XW2","date":"1731847795","viewed":54,"name":"Saturn like planet ","username":"Toiture","description":"lol","likes":10,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","planet","bloom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGR8","filepath":"/media/previz/buffer02.png","previewfilepath":"/media/previz/buffer02.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// post process\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    if(customRes) uv = floor(uv * screenRes) / screenRes ;\n    vec3 col = texture(iChannel0, uv).rgb ;\n    \n    // color grading\n    col *= exposure ;\n    \n    float l = dot(col, vec3(0.2,0.5,0.3));\n    col = mix(vec3(l), col, saturation);\n    \n    col = (col - 0.5) * max(contrast, 0.) + 0.5 ;\n    col = max(col + brightness - 1.0,0.) ;\n    \n    col *= vec3(finalR, finalG, finalB);\n    \n    // tonemap\n    col = aces(col);\n    \n    // random effects\n    col = floor(col * colors) / colors ;\n    \n    if(vignette) {\n        float factor = length(uv - vec2(0.5));\n        col *= smoothstep(1.,0.4,factor);\n    }\n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// post process \nconst float saturation = 1. ;\nconst float brightness = 1. ;\nconst float contrast = 1. ;\n\nconst float exposure = 1. ;\nconst float finalR = 1. ;\nconst float finalG = 1. ;\nconst float finalB = 1. ;\n\nconst float colors = 256. ;\nconst bool customRes = false ;\nconst vec2 screenRes = vec2(160.,144.);\n\nconst bool vignette = true ;\n\n// constants\nconst float km = 1e3 ;\nconst float radius = 58232. * km;\n\nconst float PI = 3.141592 ;\n\n#define BLOOM\n\n//#define RO vec3(0.,40000e3,300000e3)\n#define RO normalize(vec3(3.,0.5,6.)) * 170000e3\n#define SUN normalize(vec3(sin(iTime * 0.5) ,0.15,cos(iTime * 0.5)))\n\n// structs\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\nstruct Hit {\n    float d;\n    vec3 albedo;\n    vec3 normal;\n};\nstruct Hit_a {\n    float d;\n    vec3 albedo;\n    vec3 normal;\n    float alpha;\n};\n\n// intersectors \n// thanks to iq https://iquilezles.org/articles/intersectors/\nvec2 sphI(Ray ray, vec4 sph)\n{\n    vec3 oc = ray.o - sph.rgb;\n    float b = dot( oc, ray.d );\n    vec3 qc = oc - b*ray.d;\n    float h = sph.a*sph.a - dot( qc, qc );\n    if( h<0.0 ) return vec2(-1.) ; // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h ); ;\n}\n\nvec3 sphN( in vec3 pos, in vec4 sph ) {\n\treturn normalize((pos - sph.xyz) / sph.w) ;\n}\n\nfloat diskI( in vec3 ro, in vec3 rd, vec3 c, vec3 n, float r )\n{\n    vec3  o = ro - c;\n    float t = -dot(n,o)/dot(rd,n);\n    vec3  q = o + rd*t;\n    return (dot(q,q)<r*r) ? t : -1.0;\n}\n\n// utility\nfloat HG( float g, float sundotrd) {\n\tfloat gg = g * g;\treturn (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);\n}\n\nfloat phase(float f, float b, float costh) {\n    return mix(HG(f, costh),HG(b,costh ),0.5 ); \n} \nmat3 rotAxis(vec3 axis, float a) {\n    float s=sin(a);\n    float c=cos(a);\n    float oc=1.0-c;\n    vec3 as=axis*s;\n    mat3 p=mat3(axis.x*axis,axis.y*axis,axis.z*axis);\n    mat3 q=mat3(c,-as.z,as.y,as.z,c,-as.x,-as.y,as.x,c);\n    return p*oc+q;\n}\n//random number functions I found on internet\nfloat rand(vec3 co, float seed){\n    return fract(sin(dot(co, vec3(12.9898*seed, 78.233,23.1243*seed))) * 43758.5453);\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4sfGRr","filepath":"/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","previewfilepath":"/media/ap/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin","type":"volume","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// main rendering\nfloat fbm(vec3 x, int octaves) {\n    float v = 0.0;\n    float a = 0.5;\n    //x+=vec3(iTime,0.,0.) ;\n    vec3 shift = vec3(100);\n    for (int i = 0; i < octaves; ++i) {\n        v += a * texture(iChannel1, x/40.).r ;\n        x = x * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\nHit_a map_Saturn(Ray ray){\n    float saturn = sphI(ray, vec4(0., 0., 0., radius)).x;\n    \n    if(saturn > 0.){\n        vec3 p = ray.o + ray.d * saturn ;\n        vec3 n = sphN(p, vec4(0.,0.,0.,radius));\n        vec3 albedo = mix(vec3(1.,0.8,0.7),vec3(0.8,0.5,0.), smoothstep(0.2,0.8,fbm(p / vec3(2000e5,3000e3,2000e5), 4)));\n        float alpha = 1. - pow(1. + dot(ray.d, n),15.);\n        return Hit_a(saturn,albedo,n,alpha);\n    }\n    return Hit_a(-1., vec3(0.), vec3(0.),0.);\n}\nHit_a map_Disk(Ray ray){\n    float disk = diskI(ray.o, ray.d, vec3(0.), vec3(0.,1.,0.), radius * 2.5 );\n    \n    if(disk > 0.){\n        vec3 p = ray.o + ray.d * disk ;\n        vec3 cRO = normalize(ray.o);\n        vec3 n = vec3(0.,1.,0.);\n        n *= sign(dot(cRO,n));\n        \n        float d = length(vec3(0.) - p);\n        float noiseVal = fbm(vec3(0.,d,0.) / 3000e3 + 3.,4);\n        float noiseVal2 = fbm(vec3(d,0.,0.) / 3000e3 + 5.,4);\n        \n        float d01 = d / (radius * 2.5);\n        float sm = smoothstep(1.,0.9,d01);\n        sm *= smoothstep(0.55,0.65,d01);\n        \n        vec3 albedo = mix(vec3(0.85,0.8,0.75),vec3(0.6,0.5,0.2),smoothstep(0.2,0.8,noiseVal));\n        float alpha = sm * smoothstep(0.2,0.5,noiseVal2);\n        return Hit_a(disk, albedo, n, alpha);\n    }\n     return Hit_a(-1., vec3(0.), vec3(0.),0.);\n}\nvec4 bsdf_Saturn(Hit_a info, Ray ray){\n    \n    // fresnel to imitate space\n    float fresnel = 1. - pow(1. + dot(ray.d, info.normal),10.);\n    \n    // anistropy\n    float anisoM = clamp(dot(SUN,info.normal) + 0.2,0.,1.2);\n    \n    float mask = info.alpha ;\n    if(info.d < 0.) mask = 0. ;\n    \n    // shadow\n    vec3 p = info.d * ray.d + ray.o ;\n    p += info.normal * 10.;\n    Hit_a disk = map_Disk(Ray(p,SUN));\n    \n    return vec4(info.albedo * (phase(0.7,-0.2,dot(ray.d,SUN)) * anisoM * (1. - disk.alpha) + 0.03) , mask);\n}\nvec4 bsdf_Disk(Hit_a info, Ray ray){\n    float mask = info.alpha ;\n    if(info.d < 0.) mask = 0. ;\n    \n    // diffuse\n    float lambert = clamp(dot(info.normal, SUN) * 0.5 + 0.5,0.,1.);\n    \n    // shadow\n    vec3 p = info.d * ray.d + ray.o ;\n    p += info.normal * 10.;\n    Hit_a sat = map_Saturn(Ray(p,SUN));\n    \n    return vec4(info.albedo * phase(0.7,-0.2,dot(ray.d,SUN)) * (1. - sat.alpha) * lambert, mask);\n}\nvec3 genStars(vec3 rd, float density){\n    //stars \n    //thanks to https://www.youtube.com/watch?v=rvDo9LvfoVE \n    //I only swiched from 2d to 3d\n    vec3 uv = rd*density ;\n    vec3 lv = fract(uv)-0.5 ;\n    vec3 stars = vec3(0.);\n    for(float x =-1.;x<1.;x++){\n        for(float y =-1.;y<1.;y++){\n            for(float z =-1.;z<1.;z++){\n                vec3 offs = vec3(x, y, z) ;\n                vec3 id = floor(uv+offs) ;\n    \n                float pos = rand(id, 262.262);\n                float c = length(lv-offs-vec3(pos,fract(pos*62.5475),fract(pos*253.26)));\n                float circle = 0.005/c ;\n                \n                vec3 col = mix(vec3(1.,0.7,0.5), vec3(0.6,0.8,1.), smoothstep(0.2,0.8,rand(id, 9764.5)));\n                stars += vec3(circle)*max(0.,exp(-c*10.) )*8. * col;\n            } \n        } \n    } \n    return stars ;\n}\nvec3 skyColor(vec3 rd){\n    float sun = smoothstep(0.6,0.4,length(rd - SUN) / 0.02);\n    float sunHaze = 0.02 / length(rd - SUN) ;\n    \n    float l = dot(rd, normalize(vec3(1.,3.,2.))) + fbm(rd * 4. + 40.5,6) * 2. -1.;\n    float milkyWayM = pow(smoothstep(-0.5,0.,l) * smoothstep(0.5,0.,l),1.) * 1.;\n    vec3 milkyWayC = mix(mix(vec3(0.9,0.7,0.5), vec3(0.7,0.0,0.7),smoothstep(0.4,0.8,fbm(rd * 6. + 4.5,2))),vec3(0.2,0.5,0.9) * 0.1,smoothstep(0.,0.5,fbm(rd * 6.,2)));\n    vec3 extraBright = smoothstep(0.5,1.,fbm(rd * 3. + 26.56, 4)) * vec3(1.,0.9,0.8) * 10. ;\n    vec3 milkyWay = (genStars(rd,100.) * 1. + milkyWayC + extraBright) * milkyWayM * 0.5;\n    \n    return (sun + sunHaze) * vec3(1.,0.91,0.81) + genStars(rd, 50.);\n}\nvec3 lensFlare(vec3 rd, vec3 focus){\n    vec3 col = vec3(0.);\n    vec3 sundir = normalize(SUN);\n    \n    float SdotF = dot(focus,sundir);\n    SdotF = SdotF ;\n    float strength = clamp(exp((SdotF-0.5)*10.),0.,1.);\n    \n    vec3 dir = sundir-focus ;\n    float size = min(length(dir),0.7);\n    \n    //define Lens size and step length\n    float lenses = 3. ;\n    float stepL = size*3./lenses ;\n    \n    //sun\n    col +=0.05/length(rd-sundir)*vec3(1.) ;\n    //sun halo\n    col+=0.06/length(sundir-rd)*0.1*vec3(1.,0.8,0.7) ;\n    //firts Lens \n    vec3 pos = sundir+dir*stepL*0.5;\n    vec3 roP = normalize(pos) ;\n    \n    float halo = smoothstep(0.5,0.49,length(rd-roP)/0.35);\n    halo-=smoothstep(0.5,0.4,length(rd-roP)/0.34);\n    col+=max(halo,0.)*0.2*vec3(0.8,0.5,0.);\n    \n    pos +=dir*stepL;\n    roP = normalize(pos) ;\n    col+=smoothstep(0.999,1.,dot(rd,roP))*vec3(1.,0.8,0.7)*0.6;\n    \n    pos+=dir*stepL*2. ;\n    roP = normalize(pos);\n    col+=smoothstep(0.993,1.,dot(rd,roP))*vec3(0.8,0.5,0.)*0.3;\n    \n    //go to other side of the sun\n    pos = sundir ;\n    pos+=-dir*stepL ;\n    roP = normalize(pos);\n    col+=smoothstep(0.6,0.4,length(rd-roP)/0.07) *vec3(1.,0.8,0.7)*0.2;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos);\n    col+=0.02/length(rd-roP)*vec3(0.8,0.5,0.)*0.4 ;\n    \n    pos+=-dir*stepL*0.5;\n    roP = normalize(pos);\n    col+=0.015/length(rd-roP)*vec3(0.8,0.5,0.)*0.6 ;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos);\n    col+=smoothstep(0.6,0.4,length(rd-roP)/0.1)*vec3(1.,0.8,0.7) * 0.5;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos) ;\n    col+=0.007/length(rd-roP)*vec3(0.8,0.5,0.) * 0.6;\n    \n    pos+=-dir*stepL*0.25 ;\n    roP = normalize(pos);\n    col+=smoothstep(0.5,0.45,length(rd-roP)/0.3)*vec3(0.8,0.5,0.)*0.3 ;\n    col-=smoothstep(0.9,.0,length(rd-roP)/0.2)*vec3(0.8,0.5,0.)*0.3 ;\n    \n    pos+=-dir*stepL ;\n    roP = normalize(pos);\n    col+=smoothstep(0.6,0.4,length(rd-roP)/0.2)*vec3(1.,0.8,0.7);\n    \n    pos+=-dir*stepL*0.5 ;\n\n    roP = normalize(pos);\n    col+=0.003/length(rd-roP)*vec3(0.8,0.5,0.)*0.6;\n    \n    pos+=-dir*stepL*1.5 ;\n    roP = normalize(pos);\n    float haloF = smoothstep(0.5,0.49,length(rd-roP)/0.7);\n    haloF-=smoothstep(0.5,0.4,length(rd-roP)/0.69);\n    col+=max(haloF,0.)*0.2*vec3(0.8,0.5,0.);\n    return col*strength ;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 col = vec3(0.);\n    \n    vec3 rd = normalize(vec3(uv + vec2(0.2,0.),-1.)) ;\n    rd *= rotAxis(vec3(0.,0.,1.),-3.14 * 0.1);\n    Ray cam = Ray(RO, rd);\n    \n    Hit_a infoS = map_Saturn(cam);\n    vec4 sat = bsdf_Saturn(infoS, cam) ;\n    \n    Hit_a infoD = map_Disk(cam);\n    vec4 disk = bsdf_Disk(infoD, cam);\n    \n    vec4 obj = vec4(0.);\n    // sky \n    vec3 sky = skyColor(cam.d);\n    \n    // draw objects\n    \n    if(infoD.d > 0. || infoS.d >0.){\n        if(infoD.d > 0. && infoS.d < 0.){\n            col = mix(sky, disk.rgb,disk.a);\n        } else if(infoD.d < 0. && infoS.d > 0.){\n            col = mix(sky, sat.rgb, sat.a);\n        } else if(infoD.d > 0. && infoS.d > 0.){\n            if(infoD.d < infoS.d) {\n                vec3 bkgCol = mix(sky,sat.rgb,sat.a);\n                col = mix(bkgCol, disk.rgb, disk.a);\n            }\n            else {\n                col = vec3(0.,0.,1.);\n                vec3 bkgCol = mix(sky, disk.rgb,disk.a);\n                col = mix(bkgCol, sat.rgb, sat.a);\n            }\n        }\n    } else col = sky;\n    \n    float alphaSun = max(map_Saturn(Ray(RO,SUN)).alpha, map_Disk(Ray(RO,SUN)).alpha);\n    col += lensFlare(cam.d, vec3(0.,0.,-1.)) * 0.2 * (1. - alphaSun);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"// bloom part 1\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb ;\n    \n    float l = dot(col,vec3(0.2,0.5,0.3));\n    if(l < 0.7) col = vec3(0.);\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4sXGR8","channel":0}],"code":"// bloom part 2\nvec3 blur(vec2 uv, sampler2D tex, float kS, int steps, int lv){\n    vec3 result = texture(tex, uv).rgb;\n    float w = 1. ;\n    \n    for(int a = 1 ; a < lv + 1; a++){\n        for(float i = 0. ; i < 2. * PI ; i+= 2. * PI / float(steps)){\n            vec2 offs = vec2(cos(i),sin(i));\n            \n            vec2 p = uv + offs * float(a) * vec2(kS * 0.7, kS) ;\n            \n            float l = length(p - uv);\n            float cW = 1. - l / (kS * float(lv));\n            result += texture(tex, p).rgb * cW;\n            \n            w += cW ;\n        }\n    }\n    \n    return result / w;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = vec3(0.) ;\n    col = blur(uv, iChannel0, 0.1e-2, 8, 2);\n    \n    #ifdef BLOOM\n    col += blur(uv, iChannel1, 0.01, 16, 8);\n    #endif\n    fragColor = vec4(col,1.0);\n}","name":"Buffer C","description":"","type":"buffer"}]}