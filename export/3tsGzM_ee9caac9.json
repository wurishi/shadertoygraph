{"ver":"0.1","info":{"id":"3tsGzM","date":"1555905325","viewed":113,"name":"Hello Sphere!","username":"azon04","description":"Hello World in Shader Toy","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["boilerplate"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Data Structs\n\nstruct Ray\n{\n    vec3 start;\n    vec3 direction;\n};\n\nstruct Plane\n{\n    vec3 normal;\n    vec3 point;\n};\n\nstruct Sphere\n{\n    vec3 pos;\n    float radius;\n};\n\nstruct Cylinder\n{\n    vec3 pos;\n    float height;\n    float radius;\n};\n\n// End of Data Structs\n\nconst vec3 camPosition = vec3(0.0, 5.0, 0.0);\nconst vec3 lightDir = normalize(vec3(0.0, -1.0, 0.3));\nconst float projection = tan(45.0 * 0.5 * acos(-1.0) / 180.0);\n\nvoid shade(inout vec4 color, vec3 pos, vec3 norm)\n{\n    color = vec4((norm + vec3(1.0)) * 0.5, 1.0);\n}\n\nfloat rayCylinder(Ray ray, Cylinder cylinder, inout vec3 normal)\n{\n    ray.start = ray.start - cylinder.pos;\n    float a = ray.direction.x * ray.direction.x + ray.direction.z * ray.direction.z;\n    float b = 2.0 * ray.start.x * ray.direction.x + 2.0 * ray.start.z * ray.direction.z;\n    float c = ray.start.x * ray.start.x + ray.start.z * ray.start.z - cylinder.radius * cylinder.radius;\n    \n    float t0 = (-b + sqrt(b * b - 4.0 * a * c)) / ( 2.0 * a ); \n    float t1 = (-b - sqrt(b * b - 4.0 * a * c)) / ( 2.0 * a );\n    float t = min(t0, t1);\n    t1 = max(t0, t1);\n    t0 = t;\n    \n    float y0 = ray.start.y + t0 * ray.direction.y;\n    float y1 = ray.start.y + t1 * ray.direction.y;\n    \n    if( y0 < 0.0 )\n    {\n        if( y1 > 0.0 ) // Hit the cap\n        {\n            float th = t0 + (t1-t0) * (y0+cylinder.radius) / ( y0 - y1 );  \n            normal = vec3(0.0, -1.0, 0.0);\n            return th;\n        }\n    }\n    else if( y0 > 0.0 && y0 < cylinder.height )\n    {\n        // hit the cylinder bit\n        vec3 hitPosition = ray.start + t0 * ray.direction;\n        normal = normalize( vec3(hitPosition.x , 0.0, hitPosition.z) );\n        \n        return t0;\n    }\n    else\n    {\n        if(y1 < cylinder.height)\n        {\n            float th = t0 + (t1-t0) * (y0+cylinder.radius) / ( y0 - y1 ); \n            normal = vec3(0.0, 1.0, 0.0);\n            return th;\n        }\n    }\n    \n    return -1.0;\n}\n\nfloat rayPlane(Ray ray, Plane plane)\n{\n    float planeDistance = dot(plane.point, plane.normal);\n    float pointDistance = dot(ray.start, plane.normal) - planeDistance;\n    float dotProduct = dot(-1.0 * ray.direction, plane.normal);\n    float t = pointDistance / dotProduct;\n    return t;\n}\n\nfloat raySphere(Ray ray, Sphere sphere)\n{\n    vec3 distVector = ray.start - sphere.pos;\n    float a = dot(ray.direction, ray.direction);\n    float b = 2.0 * dot(ray.direction, distVector);\n    float c = dot(distVector, distVector) - sphere.radius * sphere.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if(discriminant < 0.0)\n    {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nvoid drawCylinder(inout vec4 outColor, Ray ray, Cylinder cylinder)\n{\n    vec3 normal;\n    float t = rayCylinder(ray, cylinder, normal);\n    if(t > 0.0)\n    {\n        vec3 pos = ray.start + t * ray.direction;\n        shade(outColor, pos, normal);\n    }\n}\n\nvoid drawPlane(inout vec4 outColor, Ray ray, Plane plane)\n{\n    float t = rayPlane(ray, plane);\n    if(t > 0.0)\n    {\n       \n        vec3 pos = ray.start + t * ray.direction;\n        outColor = vec4(1.0);\n        shade(outColor, pos, plane.normal); \n    }\n}\n\nvoid drawSphere(inout vec4 outcolor, Ray ray, Sphere sphere)\n{\n    float t = raySphere(ray, sphere);\n    if(t > 0.0)\n    {\n        vec3 pos = ray.start + t * ray.direction;\n        vec3 norm = normalize(pos - sphere.pos);\n        outcolor = vec4(1.0);\n        shade(outcolor, pos, norm);\n    }\n}\n\nvec3 backgroundColor(Ray ray)\n{\n    float t = 0.5 * (ray.direction.y + 1.0);\n    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    Ray ray;\n    ray.start = camPosition;\n    ray.direction = normalize(vec3(uv.x *  iResolution.x / iResolution.y, uv.y, -1.0 / projection ));\n    \n    vec4 color = vec4(backgroundColor(ray), 1.0);\n    \n    drawPlane(color, ray, Plane(vec3(0.0, 1.0, 0.0), vec3(0.0)));\n    drawSphere(color, ray, Sphere(vec3(0.0, 5.0, -24.0), 5.0));\n    \n    fragColor = color;\n}","name":"Image","description":"","type":"image"}]}