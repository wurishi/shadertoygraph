{"ver":"0.1","info":{"id":"DdcyWj","date":"1695462479","viewed":51,"name":"space warping black hole","username":"Borusse29","description":"Reference: https://kelvinvanhoorn.com/2021/04/20/supermassive-black-hole-tutorial/\nUse line 29 instead of line 28 for a little bit more physical accuracy.\nUse line 36 instead of line 35 to make it spin.","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","blackhole","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define stepsize 0.01\n#define maxsteps 1000\n#define focalDist 0.5\n\nfloat disk(vec3 ro, vec3 rd, vec3 center, float r0, float r1, vec3 normal) {\n    float t = dot(center - ro, normal) / dot(rd, normal);\n    vec3 p = ro + t * rd;\n    if (abs(t) < stepsize && distance(center, p) <= r1 && r0 <= distance(center, p)) \n        return -1.0 * length(p.xyz - center.xyz) / r1 + 2.0; // use \"return 1.0\" for same color for all points on the disk\n    return 0.0;\n}\n\nvec3 bgColor(vec3 d) {\n    return clamp(vec3(d.zz, d.z + 0.1), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n\t\tvec2(iResolution.x/iResolution.y, 1.0);\n\n    vec3 col = vec3(0.0);\n    \n    vec3 camPos = vec3(-2.5, 0.0, 0.0);\n    vec3 center = vec3(0.0);\n    float gConst = 0.83 * abs(cos(0.5 * iTime + 1.0));\n    \n    float schwarzschildRadius = 0.3; // nice looking fix value\n    //float schwarzschildRadius = 2.0 * 0.361 * gConst; // physically more correct, beacause the radius changes with a change in mass\n    \n    \n    float diskRadiusInner = 1.6 * schwarzschildRadius;\n    float diskRadiusOuter = 4.0 * schwarzschildRadius;\n    \n    vec3 diskNormal = normalize(vec3(-0.2, 0.5, 1.0)); // static orientation\n    //vec3 diskNormal = normalize(vec3(-0.2 * cos(1.5 * iTime), 0.5 * sin(1.5 * iTime), 1.0)); // make it spin!\n\n    vec3 ro = camPos;\n    vec3 rd = normalize(vec3(focalDist, uv));\n    \n    bool collision = false;\n    \n    for (int i = 0; i < maxsteps; i++) {\n        float disk = disk(ro, rd, center, diskRadiusInner, diskRadiusOuter, diskNormal);\n        if (disk > 0.0) { \n            col = /*(-uv.x + uv.y + 1.25) **/disk * vec3(0.85, 0.45, 0.1);\n            collision = true;\n            break;\n        }\n        \n        float distToCenter = distance(center, ro);\n        if (distToCenter < schwarzschildRadius){\n            collision = true;\n            break;\n        }\n        \n        ro += stepsize * rd;\n        rd = normalize(rd + (center - ro) * stepsize * gConst / (distToCenter * distToCenter));\n        \n        // performance optimization\n        if (dot(rd, center - ro) < -0.95 && distance(center, ro) > 2.5) {\n            break;\n        }\n    }\n    \n    if (!collision)\n        col = bgColor(rd);\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}