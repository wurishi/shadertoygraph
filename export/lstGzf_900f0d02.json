{"ver":"0.1","info":{"id":"lstGzf","date":"1454186674","viewed":370,"name":"Mass Effect - Mass Relay","username":"AxleMike","description":"Messing around with distance fields and creating a volumetric effect.","likes":10,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","distancefield","volume"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3Wl","filepath":"https://soundcloud.com/user3303533/mass-effect-3-earth","previewfilepath":"https://soundcloud.com/user3303533/mass-effect-3-earth","type":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Alexander Lemke, 2016\n\n//////////////////////////////////////////////////\n// Settings\n#define     NUMBER_OF_STEPS         32\n\n//////////////////////////////////////////////////\n// Constants\nconst float     MAX_DISTANCE    = 35.0;\nconst float     EPSILON         = 0.001;\nconst float     PI              = 3.14159265359;\n\n//////////////////////////////////////////////////\n// Helpers\nfloat Saturate(in float f)\n{\n    return clamp(f, 0.0, 1.0);\n}\n\nvec3 Saturate(in vec3 v)\n{\n    return clamp(v, 0.0, 1.0);\n}\n\nfloat Hash(in vec2 p)\n{\n    return -1.0 + 2.0 * fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 Hash2D(in vec2 p)\n{\n    return -1.0 + 2.0 * vec2(fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453), fract(sin(dot(p, vec2(37.271, 377.632))) * 43758.5453));\n}\n\nfloat Noise(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(mix(Hash(n), Hash(n + vec2(1.0, 0.0)), u.x),\n               mix(Hash(n + vec2(0.0, 1.0)), Hash(n + vec2(1.0)), u.x), u.y);\n}\n\n//////////////////////////////////////////////////////\n// 3D noise and Voronio from https://www.shadertoy.com/view/4sfGzS and https://www.shadertoy.com/view/ldl3W8\nfloat Noise(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = texture(iChannel0, (uv+.5) / 256.).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nvec3 Voronoi(in vec2 p)\n{\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n\n    vec2 mg, mr;\n\n    float md = 8.0;\n    for(int j = -1; j <= 1; ++j)\n    {\n        for(int i = -1; i <= 1; ++i)\n        {\n            vec2 g = vec2(float(i), float(j));\n            vec2 o = Hash2D(n + g);\n\n            vec2 r = g + o - f;\n            float d = dot(r, r);\n\n            if(d < md)\n            {\n                md = d;\n                mr = r;\n                mg = g;\n            }\n        }\n    }\n    return vec3(md, mr);\n}\n\n//////////////////////////////////////////////////////\n// smin from https://iquilezles.org/articles/smin\n// polynomial smooth min (k = 0.1);\nfloat smin(in float a, in float b, in float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nmat3 Create3x3RotationMatrix(in vec3 axis, in float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,          oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c,          oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nfloat LengthN(in vec3 v, in float n)\n{\n    float inverseN = 1.0 / n; \n    v = abs(v);\n    return pow(pow(v.x, n) + pow(v.y, n) + pow(v.z, n), inverseN);\n}\n\nfloat LengthN(in vec2 v, in float n)\n{\n    float inverseN = 1.0 / n; \n    v = abs(v);\n    return pow(pow(v.x, n) + pow(v.y, n), inverseN);\n}\n    \n//////////////////////////////////////////////////////\n// Intersection Helpers\nstruct IntersectionData\n{\n    float       mT;\n    float       mMaterialIndex;\n};\n    \nIntersectionData GetClosestIntersection(in IntersectionData a, in IntersectionData b)\n{\n    if(a.mT < b.mT)\n    {\n        return a;\n    }\n    return b;\n}\n\nstruct Ray\n{\n    vec3    mPosition;\n    vec3    mDirection;\n}; \n\n//////////////////////////////////////////////////////\n// Basic Distance Field Tests\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox(in vec3 p, in vec3 boxSize)\n{\n  vec3 d = abs(p) - boxSize;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCylinder(in vec3 p, in vec3 cylinderDimensions)\n{\n  return length(p.xz - cylinderDimensions.xy) - cylinderDimensions.z;\n}\n\nfloat sdSphere(in vec3 p, in float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdPipe(in vec3 p, in vec3 cylinderPosition, in vec2 cylinderDimensions)\n{\n    vec2 d = abs(vec2(length(p.yz + cylinderPosition.yz), p.x + cylinderPosition.x)) - cylinderDimensions;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdVerticalPipe(in vec3 p, in vec3 cylinderPosition, in vec2 cylinderDimensions)\n{\n    vec2 d = abs(vec2(length(p.xz + cylinderPosition.xz), p.y + cylinderPosition.y)) - cylinderDimensions;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(length(p.xy + torusPosition.xy) - torusDimensions.x, p.z + torusPosition.z);\n    return length(q) - torusDimensions.y;\n}\n\nfloat sdTorus82(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(LengthN(p.xy + torusPosition.xy, 2.0) - torusDimensions.x, p.z + torusPosition.z);\n    return LengthN(q, 8.0) - torusDimensions.y;\n}\n\nfloat sdTorus42(in vec3 p, in vec3 torusPosition, in vec2 torusDimensions)\n{\n    vec2 q = vec2(LengthN(p.xy + torusPosition.xy, 2.0) - torusDimensions.x, p.z + torusPosition.z);\n    return LengthN(q, 4.0) - torusDimensions.y;\n}\n\nfloat Capsule(in vec3 p, in vec3 pointA, in vec3 pointB, in float radius)\n{\n    vec3 lineBA = pointB - pointA;\n    vec3 linePA = p - pointA;\n    float rate = min(max(dot(lineBA, linePA), 0.0) / dot(lineBA, lineBA), 1.0);\n    return length(p - (pointA + rate * lineBA)) - radius; \n}\n\n//////////////////////////////////////////////////////\n// Scene Elements\nconst vec3 gMassRelayPosition = vec3(1.0, 3.0, 0.0);\n\nIntersectionData CheckMassRelay(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 1.0);\n    \n    float intersectionT = sdTorus(p, gMassRelayPosition, vec2(4.5, 0.85));\n    intersectionData.mT = intersectionT;\n\n    // Back\n    intersectionT = sdBox(p - vec3(7.5, 0.0, 0.0) + gMassRelayPosition, vec3(2.0, 1.8, 0.65));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 3.5);\n  \n    // rear modifications\n    intersectionT = sdBox(p - vec3(10.0, -0.5, 0.0) + gMassRelayPosition, vec3(1.0, 0.5, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    intersectionT = sdBox(p - vec3(10.0, 1.05, 0.0) + gMassRelayPosition, vec3(1.85, 0.25, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    \n    // top beam\n    intersectionT = sdPipe(p, vec3(11.0, -1.5, 0.0) + gMassRelayPosition, vec2(0.8, 7.0));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);    \n    intersectionT = sdPipe(p, vec3(8.0, -1.8, 0.0) + gMassRelayPosition, vec2(0.8, 3.5));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);    \n    \n    // bottom beam\n    intersectionT = sdPipe(p, vec3(11.0, 1.5, 0.0) + gMassRelayPosition, vec2(0.8, 7.0));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.8);\n        \n    // center hole\n    intersectionT = sdBox(p - vec3(-12.0, 0.0, 0.0) + gMassRelayPosition, vec3(10.0, 1.0, 3.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n       \n    // rail modifications\n    intersectionT = sdBox(p - vec3(-18.0, -2.25, 0.0) + gMassRelayPosition, vec3(1.0, 1.0, 1.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    intersectionT = sdBox(p - vec3(-18.0, 2.25, 0.0) + gMassRelayPosition, vec3(1.0, 1.0, 1.0));\n    intersectionData.mT = max(intersectionData.mT, -intersectionT);\n    \n    return intersectionData;\n}\n\nIntersectionData CheckMassRelayRing(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 2.0);\n    \n    // Ring 1\n    mat3 rotationMatrix0 = Create3x3RotationMatrix(vec3(0.0, 1.0, 0.0), PI * 0.60 * iTime);\n    vec3 q0 = rotationMatrix0 * (p + gMassRelayPosition);\n    float intersectionT = sdTorus42(q0, vec3(0.0), vec2(3.0, 0.2));\n    intersectionData.mT = intersectionT;\n    \n    mat3 rotationMatrix1 = Create3x3RotationMatrix(vec3(0.0, 1.0, 0.0), PI * 0.60 * iTime);\n    mat3 rotationMatrix2 = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), PI * 0.80 * iTime);\n    vec3 q = rotationMatrix2 * (rotationMatrix1 * (p + gMassRelayPosition));\n    intersectionT = sdTorus42(q, vec3(0.0), vec2(2.5, 0.15));\n    intersectionData.mT = min(intersectionData.mT, intersectionT);\n    \n    return intersectionData;\n}\n\nIntersectionData CheckAntennas(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 3.0);\n    \n    // Left Attennas\n    float intersectionT = sdPipe(p, vec3(11.0, -2.4, -0.35) + gMassRelayPosition, vec2(0.07, 2.5));\n    intersectionData.mT = intersectionT;  \n    intersectionT = sdVerticalPipe(p, vec3(1.4, -6.8, 0.0) + gMassRelayPosition, vec2(0.2, 3.1));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n    intersectionT = sdVerticalPipe(p, vec3(1.9, -6.8, 0.0) + gMassRelayPosition, vec2(0.08, 3.6));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(0.9, -6.8, 0.0) + gMassRelayPosition, vec2(0.1, 3.1));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1); \n    intersectionT = sdVerticalPipe(p, vec3(0.6, -6.8, 0.0) + gMassRelayPosition, vec2(0.08, 1.4));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n    \n    // Right Attennas\n    intersectionT = sdVerticalPipe(p, vec3(-1.6, -6.5, 0.0) + gMassRelayPosition, vec2(0.08, 1.4));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1); \n    intersectionT = sdVerticalPipe(p, vec3(-1.6, -5.8, 0.0) + gMassRelayPosition, vec2(0.16, 0.7));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(-2.2, -6.4, 0.0) + gMassRelayPosition, vec2(0.08, 1.5));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);    \n    intersectionT = sdVerticalPipe(p, vec3(-2.2, -5.6, 0.0) + gMassRelayPosition, vec2(0.16, 0.85));\n    intersectionData.mT = smin(intersectionData.mT, intersectionT, 0.1);\n\n    return intersectionData;\n}\n\nIntersectionData CheckBolt(in vec3 p)\n{\n    IntersectionData intersectionData = IntersectionData(MAX_DISTANCE, 4.0);\n      \n    const int NUMBER_OF_BENDS = 5;\n    vec2 maxBoltYValues = vec2(-1.25, 1.25); \n    float maxBoltYRange = abs(maxBoltYValues.x - maxBoltYValues.y); \n    float yIncr = maxBoltYRange / float(NUMBER_OF_BENDS);\n    \n    vec3 q = p + gMassRelayPosition;\n    int index = int(clamp((((q.y - maxBoltYValues.x) / maxBoltYRange) * float(NUMBER_OF_BENDS)), 0.0, float(NUMBER_OF_BENDS)));\n\n    float boltArea = mod(iTime, 15.0);\n    if(boltArea < 13.0)\n    {\n        vec2 currentBoltYValues = vec2((maxBoltYValues.x + float(index) * yIncr), (maxBoltYValues.x + float(index + 1) * yIncr));\n\n        vec3 randomOffsetHigh = (texture(iChannel0, vec2(floor(mod(iTime, 25.0) * 10.0) / 25.0, float(index) / float(NUMBER_OF_BENDS)), -100.0).xyz * 2.0 - 1.0) * vec3(0.25, 0.0, 0.25);\n        if(index >= (NUMBER_OF_BENDS - 1))\n        \trandomOffsetHigh = vec3(0.0);\n      \n        vec3 randomOffsetLow = (texture(iChannel0, vec2(floor(mod(iTime, 25.0) * 10.0) / 25.0, max(0.0, float(index - 1)) / float(NUMBER_OF_BENDS)), -100.0).xyz * 2.0 - 1.0) * vec3(0.25, 0.0, 0.25);\n\n        intersectionData.mT = Capsule(q, vec3(-4.0 - boltArea, currentBoltYValues.x, 0.0) + randomOffsetLow,\n                                      vec3(-4.0 - boltArea, currentBoltYValues.y, 0.0) + randomOffsetHigh, 0.05);\n    }\n    return intersectionData;\n}\n\nIntersectionData CheckSceneForIntersection(in vec3 p)\n{\n    IntersectionData massRelayIntersection = CheckMassRelay(p);\n    IntersectionData antennasIntersection = CheckAntennas(p);    \n    IntersectionData intersectionData = GetClosestIntersection(massRelayIntersection, antennasIntersection);   \n    \n    IntersectionData ringIntersectionData = CheckMassRelayRing(p);\n    intersectionData = GetClosestIntersection(intersectionData, ringIntersectionData); \n    \n    IntersectionData boltIntersectionData = CheckBolt(p);\n    intersectionData = GetClosestIntersection(intersectionData, boltIntersectionData);\n    \n    return intersectionData;\n}\n\nIntersectionData Intersect(in Ray initialRay)\n{    \n    IntersectionData sceneIntersection = IntersectionData(MAX_DISTANCE, -1.0);\n    \n    float t = 0.0;   \n    for(int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        // Break out if our step size is too small or we've gone out of range\n        if(sceneIntersection.mT < EPSILON || t > MAX_DISTANCE) break;\n        \n        Ray currentRay = Ray(initialRay.mPosition + initialRay.mDirection * t, initialRay.mDirection); // Update our ray     \n        sceneIntersection = CheckSceneForIntersection(currentRay.mPosition); // Check the scene for an intersection     \n        t += sceneIntersection.mT; // Step forward\n    }\n    sceneIntersection.mT = t;\n    \n    return sceneIntersection;\n}\n\nvoid RaySphereIntersectionTest(in vec3 rayPosition, in vec3 rayDirection, in vec3 spherePosition, in float sphereRadius,\n                               out vec3 intersectionNear, out vec3 intersectionFar)\n{   \n    float sRadiusSquared = sphereRadius * sphereRadius;\n    vec3 eDistance = rayPosition - spherePosition;\n    \n    float b = dot(eDistance, rayDirection);\n    float c = dot(eDistance, eDistance) - sRadiusSquared;\n    \n    if((c > 0.0 && b > 0.0) == false)\n    {   \n        float discriminant = (b * b) - c;\n        float t0 = max(-b - sqrt(discriminant), 0.0); // clamp t0 to zero incase it started inside the sphere\n        float t1 = max(-b + sqrt(discriminant), 0.0); // clamp t1 to zero incase it started inside the sphere\n           \n        if(discriminant >= EPSILON)\n        {\n            intersectionNear = rayPosition + rayDirection * t0;\n            intersectionFar = rayPosition + rayDirection * t1;\n       }      \n    }\n}\n\n//////////////////////////////////////////////////////\n// Lighting Helpers\nvec3 GetNormal(in vec3 point) \n{\n    IntersectionData d0 = CheckSceneForIntersection(point);\n    IntersectionData dX = CheckSceneForIntersection(point - vec3(EPSILON, 0.0, 0.0));\n    IntersectionData dY = CheckSceneForIntersection(point - vec3(0.0, EPSILON, 0.0));\n    IntersectionData dZ = CheckSceneForIntersection(point - vec3(0.0, 0.0, EPSILON));\n    return normalize(vec3(dX.mT - d0.mT, dY.mT - d0.mT, dZ.mT - d0.mT));\n}\n\nfloat GGXDistribution(in float NdotH, in float m)\n{\n    // Divide by PI is applied later\n    float m2 = m * m;\n    float f = ( NdotH * m2 - NdotH ) * NdotH + 1.0;\n    return m2 / (f * f);\n}\n\nfloat CookTorranceGeometricAttenuation(in float NdotH, in float NdotL, in float VdotH, in float NdotV)\n{\n    return (min(1.0, min((2.0 * NdotH * NdotL) / VdotH, (2.0 * NdotH * NdotV) / VdotH)));\n}\n\nfloat GGXSmithCorrelated(in float NdotL, in float NdotV, in float alphaG)\n{\n    float alphaG2 = alphaG * alphaG;\n    float Lambda_GGXV = NdotL * sqrt((- NdotV * alphaG2 + NdotV) * NdotV + alphaG2);\n    float Lambda_GGXL = NdotV * sqrt((- NdotL * alphaG2 + NdotL) * NdotL + alphaG2);\n    return 0.5 / ( Lambda_GGXV + Lambda_GGXL );\n}\n\nfloat ComputeSchlickFresnel(in float NdotV, in float fresnelReflectionIndex)\n{\n    return fresnelReflectionIndex + (1.0 - fresnelReflectionIndex) * pow((1.0 - NdotV), 5.0);\n}\n\n//////////////////////////////////////////////////////\n// Lighting\nvec3 ApplyPointLight(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, \n                       in float roughness, in float metallic, in float reflectance, in float ambient,\n                       in vec3 lightPosition, in float lightRadius, in vec3 lightColor)\n{       \n    vec3 lightDirection = -(lightPosition - point);\n\n    // Apply lighting\n    float lightDistance = length(lightDirection);\n    lightDirection = normalize(lightDirection);\n    float attenutation = Saturate(1.0 - lightDistance / lightRadius); \n    attenutation *= attenutation;\n    \n    // Determine some values\n    vec3 viewVector = normalize(eye - point);\n    vec3 halfVector = normalize(lightDirection + viewVector);\n\n    float NdotL = Saturate(dot(normal, lightDirection));\n    float NdotH = Saturate(dot(normal, halfVector));\n    float NdotV = Saturate(dot(normal, viewVector));\n    float VdotH = Saturate(dot(viewVector, halfVector));\n    float HdotL = Saturate(dot(halfVector, lightDirection));\n\n    vec3 diffuse = (1.0 - metallic) * albedo;\n\n    // Cook Torence\n    float f0 = 0.16 * (reflectance * reflectance);\n    float fresnel = ComputeSchlickFresnel(NdotV, f0);    \n\n    float Vis = GGXSmithCorrelated(NdotV, NdotL, roughness);\n    float geometricAttenuation = CookTorranceGeometricAttenuation(NdotH, NdotL, VdotH, NdotV);\n    float microfacets = GGXDistribution(NdotH, roughness);\n\n    float specular = (fresnel * microfacets * Vis) / PI;\n\n    return ((NdotL * Saturate(1.5 * ((0.7 * NdotL * diffuse + specular))))) * lightColor * attenutation;         \n}\n\nvec3 CalculateLighting(in vec3 point, in vec3 normal, in vec3 eye, in vec3 albedo, \n                       in float roughness, in float metallic, in float reflectance, in float ambient)\n{       \n    vec3 lighting = ApplyPointLight(point, normal, eye, albedo, roughness, metallic, reflectance,\n                               0.5, -gMassRelayPosition, 60.0, vec3(0.5, 0.5, 1.0));\n    \n    // Apply lighting from moving bolt\n    float boltArea = mod(iTime, 15.0);\n    if(boltArea < 13.0)\n    {\n        lighting += ApplyPointLight(point, normal, eye, albedo, roughness, metallic, reflectance,\n                               0.5, -gMassRelayPosition + vec3(-4.0 - boltArea, 0.0, 0.0), 8.0, vec3(0.5, 0.5, 1.0));\n    }\n    return lighting + (albedo * ambient);\n}\n\n//////////////////////////////////////////////////////\n// Background\nvec3 ApplyFog(in vec3 texCoord)\n{\n    vec3 samplePosition = 8.0 * texCoord.xyz;\n    \n    float fogAmount = Noise(samplePosition);\n    fogAmount += Noise(samplePosition * 3.01) * 0.5;\n    fogAmount += Noise(samplePosition * 3.02) * 0.25;\n    fogAmount += Noise(samplePosition * 3.03) * 0.125;\n    fogAmount += Noise(samplePosition * 3.01) * 0.0625;\n    \n    vec3 fogColor = vec3(texCoord.xyz + vec3(0.5, 0.0, 0.5))  * 0.1;\n    return (fogColor * fogAmount * vec3(0.75));  \n}\n\nvec3 AddStarField(in vec2 p, in float threshold)\n{\n    vec3 starValue = Voronoi(p);\n    if(starValue.x < threshold)\n    {\n        float power = 1.0 - (starValue.x / threshold);\n        return vec3(power * power * 0.5);\n    }\n    return vec3(0.0);\n}\n\n//////////////////////////////////////////////////////\n// Implementation\nvec4 DisplayScene(in vec3 cameraPosition, in vec3 cameraDirection, in float glowThreshold)\n{\n    // Determine our camera info\n    Ray cameraRay = Ray(cameraPosition, cameraDirection);\n    \n    // Gets the intersection point from the camera ray to camera facing plane that the core is on\n    vec3 directionToCore = -normalize(gMassRelayPosition - cameraPosition);\n    vec3 coreIntersectionNear = vec3(MAX_DISTANCE);\n    vec3 coreIntersectionFar = vec3(MAX_DISTANCE);\n    \n    const float coreVolumeRadius = 8.0;\n    const float solidCoreRadius = 1.25;\n    RaySphereIntersectionTest(cameraPosition, cameraDirection, -gMassRelayPosition, coreVolumeRadius, coreIntersectionNear, coreIntersectionFar);\n      \n    vec3 finalColor = vec3(0.0);\n\n    IntersectionData intersection = Intersect(cameraRay);        \n    if(intersection.mT < MAX_DISTANCE)\n    {   \n        vec3 intersectionPoint = (cameraRay.mPosition + cameraRay.mDirection * intersection.mT);\n        vec3 normal = GetNormal(intersectionPoint);\n\n        vec3 diffuse = vec3(1.0);\n        float roughness = 0.9;\n        float metallic = 1.0;\n        float reflectance = 0.2;\n        float ambient = 0.2;\n        \n        if(intersection.mMaterialIndex == 1.0)\n        {\n            // I'm sure theres a better way to do this\n            vec2 texCoords = intersectionPoint.xy;\n            if(abs(dot(normal, vec3(1.0, 0.0, 0.0))) > 0.8)\n                texCoords =  intersectionPoint.zy;  \n            else if(abs(dot(normal, vec3(0.0, 1.0, 0.0))) > 0.8)\n                texCoords =  intersectionPoint.xz;\n\n            vec3 textureColor = texture(iChannel1, texCoords * 0.125).rgb;\n            diffuse = vec3(0.3, 0.3, 0.4);  \n            \n            if(textureColor.r < glowThreshold)\n            {\n                ambient = 1.0;\n                diffuse = vec3(1.0);\n            }  \n        }\n        else if(intersection.mMaterialIndex == 2.0 || intersection.mMaterialIndex == 3.0)  \n            diffuse = vec3(0.5);               \n        else if(intersection.mMaterialIndex == 4.0)\n        {\n            ambient = 10.0;  \n            diffuse = vec3(1.0);\n        }\n\n        finalColor += CalculateLighting(intersectionPoint, normal, cameraPosition, diffuse, roughness, metallic, reflectance, ambient);         \n    }\n    else\n    {   \n        // calculate the uv coords for the skybox\n        vec2 starFieldCoord = vec2(atan(cameraDirection.x, cameraDirection.z) / (2.0 * PI), asin(cameraDirection.y) / PI);       \n        finalColor += AddStarField(starFieldCoord * 80.0, 0.0025);\n        finalColor += AddStarField(starFieldCoord * 65.0, 0.0025);\n        finalColor += AddStarField(starFieldCoord * 50.0, 0.001);       \n        finalColor += ApplyFog(cameraDirection);\n    }\n\n    float lengthToNearVol = min(length(cameraPosition - coreIntersectionNear), intersection.mT);\n    float lengthToFarVol = min(length(cameraPosition - coreIntersectionFar), intersection.mT);\n    float volumeTravelDistance = abs(lengthToNearVol - lengthToFarVol);\n    \n    if(volumeTravelDistance < coreVolumeRadius * 2.0)\n    {\n        vec3 volStartPoint = (cameraRay.mPosition + cameraRay.mDirection * lengthToNearVol);\n        float volumeAmount = 0.0;\n        \n        const int numberOfSteps = 20;\n        float stepSize = max(volumeTravelDistance / float(numberOfSteps), EPSILON);\n\n        for(int i = 0; i < numberOfSteps; ++i)\n        {\n            vec3 currentPoint = volStartPoint + (float(i) * stepSize * cameraDirection);\t   \n            float distanceFromCenterCore = length(currentPoint + gMassRelayPosition);\n\n            float blueTint = Saturate((coreVolumeRadius - distanceFromCenterCore) / coreVolumeRadius) * 2.0;\n            float whiteTint = Saturate((solidCoreRadius - distanceFromCenterCore) / solidCoreRadius) * 200.0;\n\n            if(length(currentPoint) > MAX_DISTANCE)\n            {\n                break;\n            }\n            volumeAmount += blueTint + whiteTint;        \n        }\n        volumeAmount /= float(numberOfSteps);\n        vec3 volumeColor = mix(vec3(0.1, 0.1, 1.0), vec3(1.0), vec3(volumeAmount * 0.5));\n        finalColor = mix(finalColor, volumeColor, vec3(Saturate(volumeAmount)));\n    } \n    return vec4(finalColor, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Adjust UVs for for the resolution so our world goes from [-1,-1] to [1,1]\n    vec2 screenCoord = (fragCoord.xy / iResolution.xy);\n    vec2 aspectRatioAdjustedUVs = vec2((screenCoord.x * 2.0 - 1.0) * (iResolution.x / iResolution.y), (screenCoord.y * 2.0 - 1.0));\n    \n    float xRotationValue = (iMouse.z > 0.0) ? (iMouse.y / iResolution.y - 0.5) * (PI * 0.5) : 0.0;\n    mat3 xRotationMatrix = Create3x3RotationMatrix(vec3(1.0, 0.0, 0.0), xRotationValue);\n    float yRotationValue = (iMouse.z > 0.0) ? (iMouse.x / iResolution.x) * (PI * 2.0) : (iTime * PI) * 0.05; // Multiply by 0.1 to slow down the rotation ;   \n    mat3 yRotationMatrix = Create3x3RotationMatrix(vec3(0.0, -1.0, 0.0), yRotationValue);\n\n    // Determine our camera info\n    const float distanceFromOrigin = 13.0;\n    vec3 cameraPosition = vec3(distanceFromOrigin * sin(yRotationValue) * cos(xRotationValue), distanceFromOrigin * sin(xRotationValue), distanceFromOrigin * cos(yRotationValue) * cos(xRotationValue));\n    vec3 cameraDirection = normalize(yRotationMatrix * xRotationMatrix * normalize(vec3(aspectRatioAdjustedUVs, -1.0)));\n\n    vec4 finalColor = DisplayScene(cameraPosition, cameraDirection, 0.4);\n    finalColor *= pow(16.0 * screenCoord.x * screenCoord.y * (1.0 - screenCoord.x) * (1.0 - screenCoord.y), 0.1); // Vigneting\n\n\tfragColor = finalColor;\n}","name":"Image","description":"","type":"image"}]}