{"ver":"0.1","info":{"id":"4djcDw","date":"1492358676","viewed":131,"name":"raymarching attempts","username":"magbetjke","description":"empty","likes":4,"published":1,"flags":0,"usePreview":0,"tags":["procedural"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\n#define MAX_MARCH_STEPS 256\n#define MAX_DEPTH 70.0\n#define DISTANCE_MIN 0.015\n#define AA 2\n\nconst vec3 cameraPos = vec3(0.0,3.0,0.0);\nconst vec3 lookAt = vec3(0,0.0,0.0);\nconst vec3 lightDir = vec3(1.5,1.5,0.0);\nconst vec3 lightDiffuse = vec3(1.0,1.0,1.0);\nconst vec3 lightAmbient = vec3(1.0);\nconst vec3 lightSpecular = vec3(1.0, 1.0, 1.0);\nconst float lightSpecularHardness = 64.0;\nconst float ambientFactor = 0.05;\n\n\n// primitives\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdGoo( vec3 p )\n{\n    float d1 = sdSphere(p, 0.5);\n    float mult = (sin(iTime * 2.0) + 1.0) * 0.5 * 2.0;\n    float d2 = sin(mult * p.x) * sin(mult * p.y) * sin(mult * p.z);\n    return d1+d2;\n}\n\nfloat opRepGoo( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q , 0.5);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// csg\nfloat opU( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\n// scene\nfloat scene( in vec3 pos )\n{\n    //vec2 res = vec2(sdPlane(pos), 1.0);\n    float obj = opU(sdSphere(pos - vec3(0.0, 0.0, 0.0), 0.2), sdTorus(pos-vec3( 0.0,0.0, 0.0), vec2(0.5,0.05)));\n    return opU(sdPlane(pos - vec3(0.0, -0.0, 0.0)), opRepGoo(pos - vec3(0.5), vec3(2.5, 0.0, 2.5)));\n}\n\n\nvec4 march(vec3 ro, vec3 rd)\n{\n   float t = 0.0;\n   float d = 1.0;\n   for (int i=0; i < MAX_MARCH_STEPS; i++) {\n      vec3 p = ro + rd * t;\n      d = scene(p);\n      if (abs(d) < DISTANCE_MIN) {\n         return vec4(p, t);\n      }\n      t += d;\n      if (t >= MAX_DEPTH) \n        break;\n   }\n   return vec4(0.0, 0.0, 0.0, MAX_DEPTH);\n}\n\nvec3 getNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0,-1.0) * 0.5773 * 0.0005;\n    return normalize( e.xyy * scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx * scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy * scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx * scene( pos + e.xxx ) );\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n\tfloat r = 0.0;\n\tfloat w = 1.0;\n\tfor (float i=1.0; i<=5.0; ++i)\n\t{\n\t\tfloat d0 = (i / 5.0) * 1.25;\n\t\tr += w * (d0 - scene(p + n * d0));\n\t\tw *= 0.5;\n\t}\n\tfloat ao = 1.0 - clamp(r,0.0,1.0);\n\treturn ao;\n}\n\nvec3 getRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\nfloat specular(vec3 normal, vec3 lightDir, vec3 viewDir, float shininess)\n{\n    float spec = 0.0;\n    const float kPi = 3.14159265;\n    {\n       float kEnergyConservation = ( 8.0 + shininess ) / ( 8.0 * kPi );\n       vec3 halfwayDir = normalize(lightDir + viewDir); \n       spec = kEnergyConservation * pow(max(dot(normal, halfwayDir), 0.0), shininess);\n    }\n\n    return spec;\n}\n\nfloat softshadow(vec3 ro, vec3 rd, float mint, float maxt)\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>maxt ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayDir,   // camera to point vector\n               in vec3  sunDir )  // sun light direction\n{\n    const float b = 0.05;\n    float fogAmount = 1.0 - exp( -distance*b );\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), // bluish\n                           vec3(1.0,0.9,0.7), // yellowish\n                           pow(sunAmount,1.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nvec4 shading(vec3 pos, vec3 rd, vec3 normal)\n{\n    float ao = calcAO(pos, normal) * ambientFactor;\n\n\tvec3 view = normalize(-rd);\n\tvec3 diffuse = softshadow(pos, lightDir, 0.02, 2.5) * lightDiffuse * max(0.0, dot(normal, normalize(lightDir))) + ao;\n    vec3 spec = lightSpecular * specular(normal, lightDir, view, lightSpecularHardness);\n    vec3 ambient  = lightAmbient + ao;\n    \n    return vec4(ambient * (diffuse + spec), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 acc = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; ++m )\n    for( int n=0; n<AA; ++n )\n    {\n        vec2 p = (fragCoord.xy + vec2(float(m) * 0.5, float(n) * 0.5)) / iResolution.xy;\n#else \n        vec2 p = fragCoord.xy / iResolution.xy;\n#endif\n        vec3 ro = vec3(cos(iTime * 0.25) * 10.0, 2.0, sin(iTime * 0.25) * 10.0);\n        vec3 rd = normalize(getRay(lookAt - ro, p));\n        vec4 res = march(ro, rd);\n        vec3 color = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n        if (res.a > 0.0) {\n            color = clamp(shading(res.xyz, rd, getNormal(res.xyz)).xyz, 0.0, 1.0);\n        } \n\n        color = applyFog(color, res.a, rd, lightDir);\n        acc += color;\n#if AA>1\n    }\n    acc /= float(AA * AA);\n#endif\n\n    fragColor = vec4(acc, 1.0);\n}","name":"Image","description":"","type":"image"}]}