{"ver":"0.1","info":{"id":"Ws3fRn","date":"1604106123","viewed":171,"name":"Simple planet shader","username":"damyvv","description":"Simple planet shader. Next up is the atmosphere...","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["noise","planet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 200\n#define MAX_DIST 30.\n#define SURF_DIST 0.001\n\nfloat N31(vec3 p) {\n    return fract(cos(p.x*25013.+p.y*3539.+p.z*751.)*39863.);\n}\n\nfloat SmoothNoise3D(vec3 p) {\n    vec3 lv = fract(p);\n    vec3 id = floor(p);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float fbl = N31(id+vec3(0,0,0));\n    float fbr = N31(id+vec3(1,0,0));\n    float fb = mix(fbl, fbr, lv.x);\n    \n    float ftl = N31(id+vec3(0,1,0));\n    float ftr = N31(id+vec3(1,1,0));\n    float ft = mix(ftl, ftr, lv.x);\n    \n    float bbl = N31(id+vec3(0,0,1));\n    float bbr = N31(id+vec3(1,0,1));\n    float bb = mix(bbl, bbr, lv.x);\n    \n    float btl = N31(id+vec3(0,1,1));\n    float btr = N31(id+vec3(1,1,1));\n    float bt = mix(btl, btr, lv.x);\n    \n    float f = mix(fb, ft, lv.y);\n    float b = mix(bb, bt, lv.y);\n    \n    return mix(f,b, lv.z);\n}\n\nfloat SmoothNoise3DDetail(vec3 p) {\n    float c = SmoothNoise3D(p*4.);\n    c += SmoothNoise3D(p*8.)*.5;\n    c += SmoothNoise3D(p*16.)*.25;\n    c += SmoothNoise3D(p*32.)*.125;\n    c += SmoothNoise3D(p*64.)*.0625;\n    c += SmoothNoise3D(p*128.)*.03125;\n    return c/(2.-0.03125);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    \n  float ns = length(p) - r + SmoothNoise3DDetail(p)*0.175*r;\n  float ws = length(p) - r + 0.1 + SmoothNoise3D(p*64.)*.0005 + SmoothNoise3D(p*128.)*.00025;\n  return min(ns, ws);\n}\n\nvec3 spherePos() {\n    return vec3(0,sin(iTime/2.)*.15,0);\n}\n\nfloat GetDist(vec3 p) {\n  float t = iTime/15.;\n  p.xz = vec2(p.x * cos(t) - p.z * sin(t),\n              p.x * sin(t) + p.z * cos(t));\n  float d = sdSphere(spherePos()-p, 1.);\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float d = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro+d*rd;\n    float dS = .9*GetDist(p);\n    d += dS;\n    if (dS < SURF_DIST || d > MAX_DIST) break;\n  }\n\n  return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    float d = GetDist(p);\n    return normalize(d - vec3(\n      GetDist(p-e.xyy),\n      GetDist(p-e.yxy),\n      GetDist(p-e.yyx)));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/3.0;\n        float d = GetDist(pos+h*nor);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    rd = normalize(rd);\n    float mint = 0.1;\n    float maxt = 200.0;\n    \n    float res = 1.0;\n\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min(res, 4.*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec3 GetLight(vec3 rd, vec3 p, vec3 n, vec3 m) {\n    vec3 lo = normalize(vec3(10, 10, -8));\n    \n    float occ = 0.05 + 0.95*calcAO(p,n);\n    float dif = 0.05 + 0.95*smoothstep(-0.2, 0.3, dot(n, lo));\n    float sha = 0.05 + 0.95*shadow(p, lo);\n          sha *= occ;\n    float spe = dot(normalize((lo-p)-2.*dot(lo-p, n)*n), normalize(rd));\n    spe = 1.+5.*smoothstep(0.7, 1.0, spe*smoothstep(0.8, 0.81, m.z));\n    \n    vec3 col = 1.2*vec3(1.0, 0.9, 0.9)*sha*dif*spe;\n    \n    return col;\n}\n\nvec3 materialComponents(vec3 p, vec3 n) {\n    vec2 e = vec2(0, 1);\n    vec3 coreN = normalize(p-spherePos());\n    float steepness = dot(coreN,n);\n    float height = length(p-spherePos());\n    float st = 0.85;\n    float sh = 0.925;\n    float wh = 0.903;\n    vec3 comp = mix(e.yxx, e.xyx, smoothstep(st,st+0.1, steepness));\n          comp = mix(comp, e.yxx, smoothstep(sh, sh+0.01, height));\n          comp = mix(comp, e.xxy, smoothstep(wh, wh-0.002, height));\n    return comp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = vec3(vec3(uv, 1));\n    \n    vec3 col = vec3(0);\n    \n    float d = RayMarch(ro, rd);\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro+d*rd;\n        vec3 n = GetNormal(p);\n        vec3 m = materialComponents(p,n);\n        \n        vec3 l = .95*vec3(0.5, 0.7, 0.7)*GetLight(rd, p, n, m);\n        vec3 grass = vec3(0.5, 0.9, 0.2);\n        vec3 stone = 1.2*vec3(0.8, 0.3, 0.1);\n        vec3 water = vec3(0.2, 0.2, 0.9);\n        \n        col = m.x*stone + m.y*grass + m.z*water;\n        \n        col *= l;\n    } else {\n        col = vec3(smoothstep(0.998, 1., N31(vec3(uv, 0.))));\n    }\n\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}