{"ver":"0.1","info":{"id":"MfjSzD","date":"1706123925","viewed":123,"name":"Fork Fork Exit  ShadedSky 689","username":"ShadedSky","description":"Forked <- Exit the Matrix\n\n\nCircuit fractal applied to a KIFS structure and a transparent cube","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","texture"],"hasliked":0,"parentid":"lfSSRW","parentname":"Fork Exit the M ShadedSky 968"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float det = 0.001, t, boxhit;\nvec3 adv, boxp;\n\nfloat hash(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 path(float t) {\n    vec3 p = vec3(vec2(sin(t * 0.1), cos(t * 0.05)) * 10., t);\n    p.x += smoothstep(0.0, 0.5, abs(0.5 - fract(t * 0.02))) * 10.;\n    return p;\n}\n\nfloat fractal(vec2 p) {\n    p = abs(5.0 - mod(p * 0.2, 10.0)) - 5.0;\n    float ot = 1000.0;\n    for (int i = 0; i < 7; i++) {\n        p = abs(p) / clamp(p.x * p.y, 0.25, 2.0) - 1.0;\n        if (i > 0) ot = min(ot, abs(p.x) + 0.7 * fract(abs(p.y) * 0.05 + t * 0.05 + float(i) * 0.3));\n    }\n    ot = exp(-10.0 * ot);\n    return ot;\n}\n\nvec3 rainbow(float gray, float transitionSpeed) {\n    // Rainbow coloring based on fractal value\n    float tGray = t * transitionSpeed;\n    vec3 tint = vec3(\n        abs(sin(tGray + gray)),\n        abs(sin(tGray + gray + 2.0)),\n        abs(sin(tGray + gray + 4.0))\n    );\n\n    return tint;\n}\n\nfloat cube(vec3 p, vec3 size) {\n    vec3 d = abs(p) - size;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat de(vec3 p) {\n    boxhit = 0.0;\n    vec3 p2 = p - adv;\n    p2.xz *= rot(t * 0.2);\n    p2.xy *= rot(t * 0.1);\n    p2.yz *= rot(t * 0.15);\n    float b = cube(p2, vec3(1.0));\n    p.xy -= path(p.z).xy;\n    float s = sign(p.y);\n    p.y = -abs(p.y) - 3.0;\n    p.z = mod(p.z, 20.0) - 10.0;\n    for (int i = 0; i < 5; i++) {\n        p = abs(p) - 1.0;\n        p.xz *= rot(radians(s * -45.0));\n        p.yz *= rot(radians(90.0));\n    }\n    float f = -cube(p, vec3(5.0, 5.0, 10.0));\n    float d = min(f, b);\n    if (d == b) boxp = p2, boxhit = 1.0;\n    return d * 0.7;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n    vec3 p, n, g = vec3(0.0);\n    float d, td = 0.0;\n    vec3 prevTint = vec3(0.0); // Initialize the previous tint color\n\n    for (int i = 0; i < 80; i++) {\n        p = from + td * dir;\n        d = de(p);\n        if (d < det && boxhit < 0.5) break;\n\n        td += max(det, abs(d));\n\n        float gray = fractal(p.xy) + fractal(p.xz) + fractal(p.yz);\n        vec3 tint = rainbow(gray, 0.1); // Adjust the transition speed as needed\n\n        // Smoothly interpolate between previous tint and current tint\n        float blendFactor = 0.02; // Adjust this value for smooth transitions\n        tint = mix(prevTint, tint, blendFactor);\n\n        g += tint / (3.0 + d * d * 2.0) * exp(-0.0015 * td * td) * step(5.0, td) / 2.0 * (1.0 - boxhit);\n\n        // Update the previous tint for the next iteration\n        prevTint = tint;\n    }\n\n    return g;\n}\n\nmat3 lookat(vec3 dir, vec3 up) {\n    dir = normalize(dir);\n    vec3 rt = normalize(cross(dir, normalize(up)));\n    return mat3(rt, cross(rt, dir), dir);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n    t = iTime * 7.0;\n    vec3 from = path(t);\n    adv = path(t + 6.0 + sin(t * 0.1) * 3.0);\n    vec3 dir = normalize(vec3(uv, 0.7));\n    dir = lookat(adv - from, vec3(0.0, 1.0, 0.0)) * dir;\n    float gray = fractal(from.xy) + fractal(from.xz) + fractal(from.yz);\n    vec3 col = march(from, dir);\n    col *= rainbow(gray, 0.0001); // Adjust the transition speed as needed (0.0001 is just an example)\n    col *= vec3(1.0, 0.9, 0.8);\n    fragColor = vec4(col, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}