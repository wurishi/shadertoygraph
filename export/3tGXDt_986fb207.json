{"ver":"0.1","info":{"id":"3tGXDt","date":"1597226227","viewed":186,"name":"Quick Cloud Test  Using Sin()","username":"Delvar","description":"just a quick test for simple clouds only using sin()","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["test","sun","cloud","sin","sky"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI  3.1415926535897932384626433832795\n\n#define DEBUG_CLOUDS\n\n#define CLOUD_OCCLUSION_STEPS 10.0\n#define CLOUD_OCCLUSION_DISTANCE 2.5\n#define CLOUD_OCCLUSION_SCALE 10.0/CLOUD_OCCLUSION_STEPS\n\n#define CLOUD_LOD_MIN_OCTAVES 4.0\n#define CLOUD_LOD_MAX_OCTAVES 64.0\n\n#define SUN_COLOUR vec3(1.6,1.2,0.8)\n\n#define OCEAN_REFLECTION_BASE vec3(0.06,0.24,0.36)\n\n#define AMBIENT_COLOUR vec3(0.3, 0.49, 0.54)\n\n#define HAZE_BASE_COLOUR vec3(2.85,2.5,2.2)\n#define SKY_BASE_COLOUR vec3(0.29,0.76,1.71)\n#define SKY_UPPER_COLOUR vec3(0.24,0.28,0.72)\n\nvec3 sunDir = normalize(vec3(5.0, 4.0, 5.0));\nconst vec3 sunColour=vec3(0.8,0.6,0.4);\n\nstruct camera {\n    vec3 origin, forward, right, up;\n    mat3 rotationMatrix;\n    float roll, pitch, yaw;\n    float zoom; // Distance from screen\n};\n\nstruct rayMarch {\n    vec3 origin, direction;\n};\n    \nmat3 rotateX(float pitch){\n    float cPitch = cos(pitch), sPitch = sin(pitch);\n    return mat3(\t1.0,\t0.0,\t0.0,\n                0.0,\tcPitch,\tsPitch,\n                0.0,\t-sPitch,\tcPitch);\n}\n\nmat3 rotateY(float yaw){\n    float cYaw = cos(yaw), sYaw = sin(yaw);\n    return mat3(\tcYaw,\t0.0,\tsYaw,\n                0.0,\t1.0,\t0.0,\n                -sYaw,\t0.0,\tcYaw);\n}\n\nmat3 rotateZ(float roll){\n    float cRoll = cos(roll), sRoll = sin(roll);\n    return mat3(\tcRoll,\t-sRoll,\t0.0,\n                sRoll,\tcRoll,\t0.0,\n                0.0,\t0.0,\t1.0);\n}\nmat3 eulerToMatrix(float roll, float pitch, float yaw){\n    //return rotateX(pitch) * rotateY(yaw) * rotateZ(roll);\n    return  rotateZ(roll) * rotateX(pitch) * rotateY(yaw);\n}\n\ncamera getTableCamera(vec3 lookAt, float distance, float roll, float pitch, float yaw, float zoom) {\n    camera camera;\n\n    mat3x3 rotationMatrix = eulerToMatrix( roll, pitch, yaw );\n\n    camera.forward = vec3(0.0,0.0,1.0) * rotationMatrix;\n    camera.right = vec3(1.0,0.0,0.0) * rotationMatrix;\n    camera.up = vec3(0.0,1.0,0.0) * rotationMatrix;\n\n    camera.origin = lookAt + camera.forward*-distance;\n    camera.origin.y = max(camera.origin.y,1.0);\n    camera.rotationMatrix = rotationMatrix;\n    camera.roll = roll;\n    camera.pitch = pitch;\n    camera.yaw = yaw;\n\n    camera.zoom = zoom;\n    return camera;\n}\n\ncamera getCamera(vec2 mouse, in float time) {\n    return getTableCamera(vec3(0.0,2.0,0.0), 2.5, 0.0, -mouse.y*PI, -mouse.x*2.0*PI,  0.5);\n}\n\nfloat map(float value, float min1, float max1, float min2, float max2) {\n    return (value - min1) / (max1 - min1) * (max2 - min2) + min2;\n}\n\n\n//#define VALUE_NOISE_FILTER_SMOOTH\n#define VALUE_NOISE_FILTER_QUINTIC\n\n#define HD 43758.5453123\n\n#define HE 12.989824344\n#define HF 78.233235235\n#define HG 44.230257362\n#define HH 83.597411735\n#define HI 95.501775192\n#define HJ 45.043107817\n#define HK 22.671833926\n#define HL 25.490516071\n\nvec2 valueNoiseFilter(vec2 x) {\n    #if defined(VALUE_NOISE_FILTER_QUINTIC)\n    return x*x*x*(x*(x*6.-15.)+10.);\n    #elif defined(VALUE_NOISE_FILTER_SMOOTH)\n    return smoothstep(0.0,1.0,x);\n    #else\n    return x;\n    #endif\n}\n\nfloat hash21(vec2 st) {\n    #if defined(NOISE_TEXTURE_3D)\n    return texelFetch( NOISE_TEXTURE_3D, ivec3(st*HE,(st.x*st.y)*HE) &31,0).x;\n    #elif defined(NOISE_TEXTURE_2D)\n    return texelFetch( NOISE_TEXTURE_2D, ivec2(st*HE)&255,0).x;\n    # else\n    return fract(sin(dot(st,vec2(HE,HF)))*HD);\n    #endif\n}\nvec4 hash44(vec4 st) {\n    return fract(sin((st+vec4(HE,HF,HG,HH))*vec4(HI,HJ,HK,HL))*HD);\n    //return fract(sin(st*HE)*HD);\n}\nfloat valueNoise2du(vec2 samplePoint) {\n    vec2 pointI = floor(samplePoint);\n    vec2 pointF = fract(samplePoint);\n    vec2 u = valueNoiseFilter(pointF);\n\n    vec2 m = mix(\n        vec2(\n            hash21(pointI), //bl\n            hash21(pointI + vec2(0.0,1.0)) //fl\n        ),\n        vec2(\n            hash21(pointI + vec2(1.0,0.0) ),//br\n            hash21(pointI + vec2(1.0,1.0) ) //fr\n        ),u.x);\n\n    return mix(m.x,m.y,u.y);\n}\n\n//New faster way to geneerate the height using vec math to reduce required instructions.\n// Clouds\n//New faster way to geneerate the height using vec math to reduce required instructions.\n// Clouds\nfloat getCloudNoise(vec2 position, float totalOctaves, float time) {\n    position+=vec2(1000,2000) + vec2(time)*vec2(0.05,0.1);\n\ttime=time*0.08;\n    \n    float maxHeight = 0.0;\n    float height = 0.0;\n    \n    for(float quadOctave = 0.0; quadOctave<totalOctaves; quadOctave+=4.0) {\n        vec4 octaves = vec4(0.0,1.0,2.0,3.0)+quadOctave;\n        //frequencies, PI2*0.03\n        vec4 fs = pow(vec4(1.095),octaves)*0.25;\n        //amplitudes\n        vec4 as = pow(vec4(0.9),octaves);\n \n        //Rotations\n        vec4 angles = (octaves*0.1)+hash44(octaves)*0.2;\n        vec4 cAngles = cos(angles), sAngles = sin(angles);\n        vec4 xs, ys;\n\n        for(int i;i<4;i++) {\n            position=position*mat2(cAngles[i],-sAngles[i], sAngles[i], cAngles[i]);\n            xs[i] = position.x;\n            ys[i] = position.y;\n        }\n\n        vec4 values = (sin(fs*xs+time)+sin(fs*ys));\n\n        //For runs where we dont want exactly multiple of 4 octaves.. to match the old output.\n        float octaivesRemaining = totalOctaves-quadOctave;\n        \n        if(octaivesRemaining<1.0) {\n            as*=vec4(fract(totalOctaves),0.0,0.0,0.0);\n        } else if(octaivesRemaining<2.0) {\n            as*=vec4(1.0,fract(totalOctaves),0.0,0.0);\n        } else if(octaivesRemaining<3.0) {\n            as*=vec4(1.0,1.0,fract(totalOctaves),0.0);\n        } else if(octaivesRemaining<4.0) {\n            as*=vec4(1.0,1.0,1.0,fract(totalOctaves));\n        }\n        \n        values *= as;\n        \n        height+=dot(values,vec4(1));\n        maxHeight+=dot(as,vec4(1));\n    }\n    return height/maxHeight;\n}\n\nvec4 getCloudsColour(vec3 direction, float sunDotProduct, float time) {\n    //Dont draw clouds very low on the horizon or ground.\n    if (direction.y<=0.04) {\n        return vec4(0.0);\n    }\n    vec2 samplePoint = direction.xz;\n    samplePoint *= (4000.0)/direction.y;\n    samplePoint *= 0.001;\n    \n    float occlusion = 0.0;\n    vec2 offsetDelta = (sunDir.xz * CLOUD_OCCLUSION_DISTANCE)/CLOUD_OCCLUSION_STEPS;\n    vec2 offset = vec2(0.0);\n    \n    //Simple LOD based on y direction. // limited to 0.04 above, 1.0/0.04 = 25.0 so dont need to clamp it\n    float t = 1.0/1.0-direction.y;\n    \n    //NOTE: the map values are backwards (1.0 to 0.0) to normal (0.0 to 1.0) because we flipped t to start with.\n\tfloat totalOctaves = map(t, 25.0, 0.0, CLOUD_LOD_MIN_OCTAVES , CLOUD_LOD_MAX_OCTAVES );\n     \n    float c1 = getCloudNoise(samplePoint, totalOctaves, time)*0.5+0.5;\n    \n    if(c1 <= 0.5) {\n\t\treturn vec4(0.0);\n    }\n    \n    for( float i=CLOUD_OCCLUSION_SCALE; i>0.0; i-=(CLOUD_OCCLUSION_SCALE/CLOUD_OCCLUSION_STEPS) )\n    {\n        offset += offsetDelta;\n        offsetDelta *= 1.25;\n        float c2 = getCloudNoise(samplePoint+offset, totalOctaves, time)*0.5+0.5;\n        float d = (c1-c2) * c2;\n        occlusion += d*i;\n    }\n    \n    //occlusion = smoothstep(0.0,1.0,clamp(map(occlusion, -1.0, 1.0, -2.0, 4.0),0.0,1.0));\n    occlusion = clamp(occlusion,0.0,1.0);\n        \n\t//We fake back lighting based off the sub dot product, make the fringes brighter\n    vec3 col=SUN_COLOUR * (mix(occlusion,clamp(5.0*(0.8-c1),0.0,1.0),pow(sunDotProduct,5.0)));\n\tc1 = clamp(map(c1, -1.0, 1.0, -6.0, 2.0),0.0,1.0)*clamp( (direction.y-0.04) * 10.0,0.0,1.0);\n    col *= 2.0;\n    #if defined(AMBIENT_COLOUR)\n\t\tcol += AMBIENT_COLOUR;\n    #endif\n    return vec4(col,c1);\n}\n    \nvec3 getSkybox(vec3 direction, float observerHeight, bool lowerWhite, bool upperSun, float time) {\n    vec3 skybox;\n    if (lowerWhite && upperSun) {\n        direction.y = abs(direction.y);\n    }\n    \n    float sunDotProduct=dot(direction,sunDir)*0.5+0.5;\n        \n    //ensure the skybox lower portion matches the OCEAN base colour with lighting etc.\n    if(direction.y<0.0) {\n        //Fog always has white on the lower side, just think it looks better\n        if (lowerWhite) {\n            #if defined(DEBUG_DISTANCE_FOG)\n            return HAZE_BASE_COLOUR;\n            #else \n            return OCEAN_REFLECTION_BASE;\n            #endif\n        } else {\n            direction.y = abs(direction.y);\n            skybox = OCEAN_REFLECTION_BASE;\n\n            #if defined(DEBUG_LIGHTING)\n            vec3 defuse = SUN_COLOUR * dot(sunDir,vec3(0.0,1.0,0.0));\n                #if defined(AMBIENT_COLOUR)\n                defuse += AMBIENT_COLOUR;\n                #endif\n            skybox*=defuse;\n            #endif\n\n            #if defined(DEBUG_DISTANCE_FOG)\n\t\t\tfloat haze = clamp(observerHeight/direction.y,0.0, RAY_MAX_DISTANCE)/RAY_MAX_DISTANCE;\n            skybox = mix(skybox,HAZE_BASE_COLOUR,haze);\n            \n            //skybox=mix(skybox,HAZE_BASE_COLOUR,smoothstep(0.0,1.0,pow(1.0-direction.y,4.0)));\n            #endif\n            return skybox;\n        }\n    } else {\n\t\tskybox=SKY_BASE_COLOUR;\n        skybox=mix(skybox,SKY_UPPER_COLOUR,smoothstep(0.0,1.0,direction.y));\n        \n        //Fog layer doesnt have the sun spot, jsut looks weird\n        if(upperSun) {\n            //Add Sun and Halo\n            skybox += SUN_COLOUR*((pow(sunDotProduct,1000.0)*20.0)+pow(sunDotProduct,10.0));\n            #if defined(DEBUG_CLOUDS)\n                vec4 clouds = getCloudsColour(direction, sunDotProduct, time);\n                skybox = mix(skybox, clouds.xyz, clamp(clouds.w,0.0,1.0));\n            #endif\n\t\t}\n        //skybox=mix(skybox,HAZE_BASE_COLOUR,smoothstep(0.0,1.0,pow(1.0-direction.y,20.0)));\n        skybox=mix(skybox,HAZE_BASE_COLOUR,pow(1.0-direction.y,20.0));\n        return skybox;\n    }\n}    \n\nrayMarch getRay(vec2 uv, camera camera) {\n    rayMarch ray;\n    ray.origin = camera.origin;\n    vec3 center = ray.origin + camera.forward * camera.zoom;\n    vec3 intersection = center + (uv.x * camera.right) + ( uv.y * camera.up );\n    ray.direction = normalize(intersection - ray.origin);\n    return ray;   \n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    \n    float time = iTime + 45.0;\n   \n    //sunDir = normalize(vec3(sin(time)*5.0, abs(sin(time*0.03333)) * 3.0, cos(time)*5.0));\n    sunDir = normalize(vec3(sin(time*0.1)*5.0, 4.0, cos(time*0.1)*5.0));\n    \n    vec2 mouse = ((iMouse.xy-0.5*iResolution.xy)/iResolution.y);\n    if((iMouse.x <= 1.0 && iMouse.y <= 1.0)) {\n        mouse = vec2(0.0,0.0);\n    }\n    camera camera = getCamera(mouse, time);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\trayMarch ray = getRay(uv, camera);\n    \n    vec3 colour = getSkybox(ray.direction, ray.origin.y, true, true, time);\n  \n    float exposure = 0.5;\n    colour = pow( exposure * colour, vec3(1.0/2.2) );\n    colour = clamp(colour,0.0,1.0); \n    colour = 1.7*colour/(1.0+colour);\n    colour = colour*colour*(3.0-2.0*colour);\n\n    fragColour = vec4(colour,1.0);\n}","name":"Image","description":"","type":"image"}]}