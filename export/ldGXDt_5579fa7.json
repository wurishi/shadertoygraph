{"ver":"0.1","info":{"id":"ldGXDt","date":"1467355073","viewed":222,"name":"Tablet Universe","username":"VoidChicken","description":"If you like tablets, this is your heaven. :D\nUploaded at 11:38 PST PM.","likes":1,"published":1,"flags":48,"usePreview":0,"tags":["3d","raymarch","video","repetition","chicken","repeat","tablet"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":3,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sX3Rn","filepath":"/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","previewfilepath":"/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv","type":"video","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XdXGzr","filepath":"/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","previewfilepath":"/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec4 hash4( vec2 p ) { return fract(sin(vec4( 1.0+dot(p,vec2(37.0,17.0)), \n                                              2.0+dot(p,vec2(11.0,47.0)),\n                                              3.0+dot(p,vec2(41.0,29.0)),\n                                              4.0+dot(p,vec2(23.0,31.0))))*103.0); }\nvec4 textureNoTile( sampler2D samp, in vec2 uv )\n{\n    vec2 iuv = vec2( floor( uv ) );\n     vec2 fuv = fract( uv );\n\n    // generate per-tile transform\n    vec4 ofa = hash4( iuv + vec2(0,0) );\n    vec4 ofb = hash4( iuv + vec2(1,0) );\n    vec4 ofc = hash4( iuv + vec2(0,1) );\n    vec4 ofd = hash4( iuv + vec2(1,1) );\n    \n    vec2 ddx = dFdx( uv );\n    vec2 ddy = dFdy( uv );\n\n    // transform per-tile uvs\n    ofa.zw = sign( ofa.zw-0.5 );\n    ofb.zw = sign( ofb.zw-0.5 );\n    ofc.zw = sign( ofc.zw-0.5 );\n    ofd.zw = sign( ofd.zw-0.5 );\n    \n    // uv's, and derivarives (for correct mipmapping)\n    vec2 uva = uv*ofa.zw + ofa.xy, ddxa = ddx*ofa.zw, ddya = ddy*ofa.zw;\n    vec2 uvb = uv*ofb.zw + ofb.xy, ddxb = ddx*ofb.zw, ddyb = ddy*ofb.zw;\n    vec2 uvc = uv*ofc.zw + ofc.xy, ddxc = ddx*ofc.zw, ddyc = ddy*ofc.zw;\n    vec2 uvd = uv*ofd.zw + ofd.xy, ddxd = ddx*ofd.zw, ddyd = ddy*ofd.zw;\n        \n    // fetch and blend\n    vec2 b = smoothstep( 0.25,0.75, fuv );\n    \n    return mix( mix( textureGrad( samp, uva, ddxa, ddya ), \n                     textureGrad( samp, uvb, ddxb, ddyb ), b.x ), \n                mix( textureGrad( samp, uvc, ddxc, ddyc ),\n                     textureGrad( samp, uvd, ddxd, ddyd ), b.x), b.y );\n}\n\nmat3 Rotate(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c         \n                               );\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec2 screen = 2.*vec2(1.9,1.5);\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nstruct Ray {\n    vec3 Origin, Direction;\n};\nstruct Intersection {\n    Ray Ray;\n    vec3 Position, Normal;\n    float Distance;\n    bool Collision;\n    vec3 Color;\n    float Shininess;\n}; \nfloat Plane(vec3 v, vec4 p) {\n\treturn dot(v,p.xyz)-p.w;\n}\nfloat Paper(vec3 v, vec4 p,vec2 s) {\n    float d = sdBox(vec3(v.x,0,v.z),vec3(s.x,1,s.y));\n    \n    return max(Plane(v,p),d);\n}\nfloat Map(vec3 r, out int n) {\n    vec3 r2 = mod(r,10.)-5.;\n    r2 = vec3(r2.x,r.y,r2.z);\n    r2*=Rotate(vec3(0,1,0),10.*rand(floor(r.xz/10.)*10.-5./100.));\n\tfloat paper = Paper(r2,vec4(0,1,0,1.1),vec2(2,1.6));\n    float scr = Paper(r2,vec4(0,1,0,1.11),vec2(1.9,1.5));\n    paper=min(scr,paper);\n   \tfloat desktop = Plane(r, vec4(0, 1, 0, 1));\n    float ceiling = Plane(r,vec4(0,-1,0,-20));\n    desktop=min(desktop,ceiling);\n    float final = min(paper,desktop);\n    if (paper == final) if (paper==scr) n = 1; else n = 2; else if (desktop==ceiling) n= 3; else n = 0;\n    return final;\n}\nRay CreateRay(vec3 o, vec3 d) {\n    Ray ray;\n    ray.Origin = o;\n    ray.Direction = d;\n    return ray;\n}\nvec3 PointRay(Ray ray, float T) {\n    return ray.Origin+T*ray.Direction;\n}\nvec3 Normal( in vec3 x, in float eps )\n{\n    vec2 e = vec2( eps, 0.0 );\n    int useless = 0;\n    return normalize( vec3( Map(x+e.xyy,useless) - Map(x-e.xyy,useless),\n                            Map(x+e.yxy,useless) - Map(x-e.yxy,useless),\n                            Map(x+e.yyx,useless) - Map(x-e.yyx,useless) ) );\n}\nvec3 Light;\nfloat LightValue(Intersection ios) {\n    vec3 normal = ios.Normal;\n    vec3 lightDir = normalize(Light-ios.Position);\n    float lambertian = max(dot(lightDir,normal),0.0);\n    float specular = 0.0;\n    \n    if (lambertian > 0.0) {\n        vec3 viewDir = -ios.Ray.Direction;\n        \n        vec3 reflectDir = reflect(-lightDir,normal);\n        float specAngle = max(dot(reflectDir, viewDir),0.0);\n        specular = pow(specAngle, ios.Shininess/4.0);\n    }\n    float shading = specular;\n    return ios.Shininess==0.?0.:shading;\n}\nIntersection Trace(Ray ray) {\n    Intersection isct;\n    int n = 0;\n    isct.Ray= ray;\n    for (int i = 0; i < 64; i++) {\n        vec3 p = PointRay(ray, isct.Distance);\n        float df = Map(p, n);\n        if ( df<.001 ) isct.Collision = true;\n        isct.Position = p;\n        isct.Distance+=df;\n          \n    }\n    isct.Normal = Normal(isct.Position, 0.001);\n        vec2 uv = (isct.Position.xz+screen/2.)/screen;\n        vec2 b = mod(vec2(0),10.)-5.;\n        Light = vec3(b.x,2.,b.y);\n        vec2 vu = (mod(isct.Position.xz,10.)-5.+screen/2.)/screen;\n        isct.Color = n==0?(textureNoTile(iChannel0, uv).rgb):(n==1?texture(iChannel1, vu).rgb:(n==2?vec3(.25)*texture(iChannel3, uv).rrr:textureNoTile(iChannel3, uv).rrr));\n        isct.Shininess = n==1||n==2?10.:0.;  \n    \t\n    return isct;\n}\nfloat Fog(Intersection h) {\n        float end = 30.;\n        return (end-h.Distance)/end;\n}\nmat4 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n     vec2 mouse = (iMouse.xy/iResolution.xy*2.-1.);\n    mat4 Mat = RotationMatrix(vec3(0, 1, 0),mouse.x*4.)*RotationMatrix((vec4(1, 0, 0,1)*RotationMatrix(vec3(0, 1, 0),mouse.x*4.)).xyz,-mouse.y*2.);\n    \n    vec3 rd = normalize(vec4(uv*2.-1.,1,1)*Mat).xyz;\n    vec3 ro = vec3(0, 4, -6)+texture(iChannel2,vec2(0.1)).rgb/10.;\n    Ray ray = CreateRay(ro,rd);\n   \n    Intersection hit = Trace(ray);\n    if (hit.Collision)\n    {\n        float fg = Fog(hit);\n        fragColor=vec4(mix(vec3(0),hit.Color+(LightValue(hit)),fg),1);\n        return;\n    }\n\tfragColor = vec4(0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"mat4 RotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}    \nvec3 Position=  vec3(0);\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.) ).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = ceil(isKeyPressed(87.5/256.0));\n    float b = -ceil(isKeyPressed(83.5/256.0));\n    float c = -ceil(isKeyPressed(65.5/256.0));\n    float d = ceil(isKeyPressed(68.5/256.0));\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.-1.);\n\tmat4 Mat = RotationMatrix(vec3(0, 1, 0),mouse.x*4.)*RotationMatrix((vec4(1, 0, 0,1)*RotationMatrix(vec3(0, 1, 0),mouse.x*4.)).xyz,-mouse.y*2.);\n\tvec3 movement = (vec4(c+d,0,a+b,1)*Mat).xyz;\n   \n    \n    fragColor = iFrame==0?vec4(0):vec4((Position=texture(iChannel0, vec2(0.)).rgb)+movement,1.0);\n}","name":"Buf A","description":"","type":"buffer"}]}