{"ver":"0.1","info":{"id":"wsG3R3","date":"1571152858","viewed":285,"name":"Path Tracer: Cornell Box","username":"HAL9000","description":"Path Tracer with direct light sampling.","likes":5,"published":1,"flags":32,"usePreview":0,"tags":["raytracing","ray","intersection","pathtracing","pathtracer","cornell"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GAMMA 0.4\n#define BRIGHTNESS 0.8\nvoid f(inout vec3 c){\n   c = vec3(0.,0.,0.);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    // Time varying pixel color\n    //vec4 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t//f(col);\n    // Output to screen\n    vec4 col = texture(iChannel0, uv);\n    col *= BRIGHTNESS;\n    col = vec4(pow(col.x, GAMMA), pow(col.y, GAMMA), pow(col.z, GAMMA), pow(col.w, GAMMA));\n    fragColor = col * 1.3;\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0){\n    \tfragColor = vec4(0.5,0.5,0.,0.);\n        return;\n    }\n    if (iMouse.z > 0.){\n        fragColor = vec4(iMouse.xy / max(iResolution.x, iResolution.y), float(iFrame), 0.);\n        return;\n    }\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"/*MOVE THE LIGHT WITH THE MOUSE!*/\n\n#define DIFFUSE 1\n#define MIRROR 2\n#define GLASS 3\n#define EMISSION 4\n\n#define SPHERE_COUNT 9\n#define LIGHT_COUNT 1\n\n#define INFINITY 1000000.\n#define M_PI 3.1415926535897932384626433832795\n#define M_E 2.7182818284590452353602874\n\n#define SAMPLES 1\n#define MAX_BOUNCES 8\n\n//#define BRUTE_FORCE\n#define ACCUMULATE\n#define PBRT_CONE_SAMPLING\n\nstruct Sphere{\n    vec3 p; //geometric information pos: g.xyz radius: g.w\n    float r; //radius\n    vec3 c; //color of the sphere\n    float s; //roughness or ior\n    int m; //material\n};\n\nfloat hash1(inout float seed)\n{\n    return fract(sin(seed += 0.1)*43758.5453123);\n}\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nvec2 hash2(inout float seed)\n{\n    return fract(sin(vec2(seed+=0.1,seed+=0.1))*vec2(43758.5453123,22578.1459123));\n}\n\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 uniform_disk_sample(inout float seed) //in polar coordinates theta, r\n{\n    vec2 p = hash2(seed);\n    return vec2(2. * M_PI * p.x, sqrt(p.y));\n}\n\nvec3 cosine_weighted_hemi_sample(inout float seed)\n{\n    vec2 p = uniform_disk_sample(seed);\n    return normalize(vec3(sin(p.x) * p.y, cos(p.x) * p.y, sqrt(1. - p.y * p.y)));\n}\n\n\nSphere spheres[SPHERE_COUNT] = Sphere[SPHERE_COUNT](Sphere(vec3(1., 3.2, -0.5), .5,vec3(1., 1., 1.), 1.45, GLASS),\n                                                    Sphere(vec3(0., 5.2, -0.5), .5,vec3(0.1, 0.5, 0.9), 1.45, DIFFUSE),\n                                                    Sphere(vec3(-1., 4.2, -0.5), .5,vec3(1., 1., 1.), 1.45, MIRROR),\n                                                    Sphere(vec3(0., 4.5, 1.9), .4,vec3(1., 1, 1.) * 3.6, 0., EMISSION),\n                                                    Sphere(vec3(0., 4., -1000), 999.,vec3(1, 1, 1), 0., DIFFUSE),\n                                                    Sphere(vec3(1001., 0., 0.), 999.,vec3(.1, 0.9, 0.1), 0., DIFFUSE),\n                                                    Sphere(vec3(-1001., 0., 0.), 999.,vec3(0.9, .1, 0.1), 0., DIFFUSE),\n                                                    Sphere(vec3(0., 1005.5, 0.5), 999.,vec3(.9, 0.9, 0.9), 0., DIFFUSE),\n                                                    Sphere(vec3(0., 0., 1001.7), 999.,vec3(.9, 0.9, 0.9), 0., DIFFUSE));\nint lights[LIGHT_COUNT] = int[LIGHT_COUNT] (3);//index of the spheres to be directly sampled\n//#endif\n\n\nstruct Ray{\n\tvec3 o;//origin\n    vec3 d;//direction\n};\n\n    \nfloat intersect_sphere(in Ray r, in Sphere s)\n{\n    r.o = r.o - s.p; //translate everything so that the sphere is centered\n    \n    float b = dot(r.o, r.d);\n    float delta = b * b - dot(r.o, r.o) + s.r * s.r;\n    \n   \tif (delta < 0.) return -1.;\n    \n    float sqdelta = sqrt(delta);\n    \n    if (-b - sqdelta > 0.001) return -b - sqdelta; //epsilon to avoid self intersection\n    else if (-b + sqdelta > 0.001) return -b + sqdelta;\n    return -1.;\n}\n\nbool intersect_scene(const in Ray r, out float t, out int idx, out Ray hit, out bool inside)\n{\n\tt = INFINITY;\n    idx = -1;\n    for (int i = 0; i < SPHERE_COUNT; i++){\n        float n_t = intersect_sphere(r, spheres[i]);\n        if (n_t > 0. && n_t < t){\n     \t\tt = n_t;\n            idx = i;\n        }\n    }\n    if  (t == INFINITY){\n        return false;\n    }\n    else{\n\t\thit.o = r.o +  r.d  * t; //this point might be beneath the surface of the sphere\n        hit.d = normalize(hit.o - spheres[idx].p);\n        inside = distance(r.o, spheres[idx].p) <= spheres[idx].r;\n        hit.d *= inside ? -1. : 1.; //flip the normal if inside the sphere\n        //hit.o += hit.d * 0.1; //make sure the point does not go through\n        return true;\n    }\n}\n\nvec3 cone_uniform(in float theta, in vec3 dir, inout float seed)\n{\n    \n    vec3 left = cross(dir, vec3(0., 1., 0.));//error for vertical vectors\n    //vec3 left2 = cross(dir, vec3(0., 0., 1.));\n    //left = length(left) > length(left2) ? normalize(left) : normalize(left2);\n    left = length(left) > 0.1 ? normalize(left) : normalize(cross(dir, vec3(0., 0., 1.)));\n    vec3 up = normalize(cross(dir, left));\n    \n    //cone sampling implementation from pbrt\n    vec2 u = hash2(seed);\n    float cos_theta = (1. - u.x) + u.x * cos(theta);\n    float sin_theta = sqrt(1. - cos_theta * cos_theta);\n    float phi = u.y * 2. * M_PI;    \n    return normalize(\n           left * cos(phi) * sin_theta +\n           up   * sin(phi) * sin_theta +\n           dir  * cos_theta);\n\n}\n\nvec3 sample_light(const in Ray p, in int light_idx, inout float seed, out float inv_prob) //return the radiance already scaled by the pdf\n{\n    Sphere l = spheres[light_idx];\n    vec3 dir = normalize(l.p - p.o);\n    float dist = length(l.p - p.o);\n    float theta = asin(l.r / dist);\n    Ray r = Ray(p.o + p.d * 0.0001, cone_uniform(theta, dir, seed)); //epsilon to make sure it self intersects\n    \n    float t;\n    int idx;\n    Ray hit;\n    inv_prob = (2. * (1. - cos(theta)));\n    bool inside;\n    intersect_scene(r, t, idx, hit, inside);\n    if (idx == light_idx){\n        return l.c.xyz * max(0., dot(r.d, p.d)) * inv_prob;\n    }\n    return vec3(0., 0., 0.);\n}\n\nfloat snell (float sin_theta, float iori, float iort)\n{\n    return iori / iort * sin_theta;\n}\n\nfloat fresnel(float iori, float iort, float cosi, float cost){\n    float rpar = (iort * cosi - iori * cost) / (iort * cosi + iori * cost);\n    float rper = (iori * cosi - iort * cost) / (iori * cosi + iort * cost);\n    rpar *= rpar;\n    rper *= rper;\n    return (rpar + rper) / 2.;\n}\n\n#ifndef BRUTE_FORCE\nvec3 get_radiance(Ray r, inout float seed){\n    vec3 rad = vec3(0.,0.,0.);\n   \tfloat t;\n    int idx;\n    Ray hit;\n    vec3 brdf = vec3(1.,1.,1.);\n    bool delta = true;\n    bool inside = false;\n\n    for (int b = 0; b < MAX_BOUNCES; b++){\n        if(!intersect_scene(r, t, idx, hit, inside)){\n            return rad + brdf * vec3(0.0, 0.0, 0.0); //return sky color;\n        }\n        float prob = 0.;\n        int mat = spheres[idx].m;\n        if (mat == DIFFUSE){\n            delta = false;\n            vec3 tangent = normalize(cross(r.d, hit.d));\n            vec3 bitangent = normalize(cross(hit.d, tangent));\n            vec3 nr = cosine_weighted_hemi_sample(seed);;\n           \tr.d = normalize(tangent * nr.x + bitangent * nr.y + hit.d * nr.z);\n            brdf *= spheres[idx].c.xyz;\n            for (int k = 0; k < LIGHT_COUNT; k++){\n                vec3 acc = brdf * sample_light(hit, lights[k], seed, prob);\n                rad += acc;\n            }\n            \n            //return rad;\n        }\n        else if (mat == MIRROR){\n            delta = true;\n            r.d = reflect(r.d, hit.d);\n            brdf *= spheres[idx].c.xyz;\n        }\n        else if (mat == GLASS){\n            delta = true;\n            float cosi = abs(dot(hit.d, r.d));\n            float sini = sqrt(1. - cosi * cosi);\n            float iort = spheres[idx].s;\n            float iori = 1.;\n            if (inside){\n                iori = iort;\n                iort = 1.;\n            }\n            float sint = snell(sini, iori, iort);\n            float cost = sqrt(1. - sint * sint);\n            float frsn = fresnel(iori, iort, cosi, cost);\n\n            if (hash1(seed) > frsn){//ray transmitted\n                vec3 bitangent = normalize(r.d - dot(hit.d, r.d) * hit.d);\n                r.d = normalize(bitangent * sint - cost * hit.d);\n                brdf *= spheres[idx].c;\n            }\n            else{ //ray reflected\n                r.d = reflect(r.d, hit.d);\n            }\n            \n        }\n        else if (mat == EMISSION){\n            return rad + brdf * (delta ? spheres[idx].c.xyz : vec3(0.,0.,0.));\n        }\n        r.o = hit.o + r.d * 0.001;\n        //if(length(brdf) < 0.1) return rad;// or something like this, also considering lights\n    }\n    return rad;\n    \n}\n#endif\n\nRay ray_from_camera(vec2 uv, float fov, vec3 cam_pos, vec3 look_at, vec3 right_vector)\n{//fov is expressed in radians\n    float fl = 1./tan(fov / 2.); //focal length\n   \treturn Ray(cam_pos, normalize(vec3(uv.x, fl, uv.y)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    spheres[lights[0]].p.xz += (texture(iChannel1, vec2(0., fragCoord/iResolution.xy)).xy - vec2(0.5, 0.5)) * vec2(3.5, 5.);\n    vec2 uv0 = fragCoord/iResolution.xy;\n    \n    vec3 col;\n    for (int s = 0; s < SAMPLES; s++){\n        float seed = hash12(fragCoord.xy + iTime * M_PI + float(s) * 634.2342) + nrand(uv0 * iTime) * 52.2246 + hash2(uv0.x).x; //\n        vec2 uv = (fragCoord + hash2(seed) - 1. - iResolution.xy /2.)/max(iResolution.x, iResolution.y);\n        col += get_radiance(ray_from_camera(uv, M_PI * 0.5, vec3(0., -4., .8), vec3(0.,0.,0.), vec3(0.,0.,0.)), seed);\n\n         \n    }\n    col /= float(SAMPLES);\n#ifdef ACCUMULATE\n    float start = texture(iChannel1, vec2(0., fragCoord/iResolution.xy)).z;\n    float interval = float(iFrame) - start;\n    col = (texture(iChannel0, fragCoord/iResolution.xy).xyz * interval + col) / (interval + 1.);\n#endif\n    fragColor = vec4(col , 0.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}