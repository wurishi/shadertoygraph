{"ver":"0.1","renderpass":[{"outputs":[{"channel":0,"id":"4dfGRr"}],"inputs":[],"code":"/* Hexafield distance field ray-marching demo - by Kevin Roast\n   Uses code by other authors - as credited in method comments.\n   http://www.kevs3d.co.uk/dev/shaders\n*/\n\n\n#define PI 3.14159265\n#define GAMMA 0.8\n#define CONTRAST 1.1\n#define SATURATION 1.2\n#define BRIGHTNESS 1.2\n#define AO_SAMPLES 5\n#define RAY_DEPTH 256\n#define MAX_DEPTH 100.0\n#define SHADOW_RAY_DEPTH 16\n#define DISTANCE_MIN 0.001\n\nconst vec2 delta = vec2(DISTANCE_MIN, 0.);\n\n\nvec3 RotateZ(vec3 p, float a)\n{\n   float c,s;\n   vec3 q=p;\n   c = cos(a);\n   s = sin(a);\n   p.x = c * q.x - s * q.y;\n   p.y = s * q.x + c * q.y;\n   return p;\n}\n\nfloat HexPrism(vec3 p, vec2 h)\n{\n   vec3 q = abs(p);\n   return max(q.y-h.y,max(q.x+q.z*0.57735,q.z*1.1547)-h.x);\n}\n\nfloat Plane(vec3 p, vec3 n)\n{\n   return dot(p, n);\n}\n\nvec3 ReplicateXZ(vec3 p, vec3 c)\n{\n   return vec3(mod(p.x, c.x) - 0.5 * c.x, p.y, mod(p.z, c.z) - 0.5 * c.z);\n}\n\nfloat Dist(vec3 pos)\n{\n   pos = RotateZ(pos, sin(iTime)*0.25);\n   vec3 q1 = ReplicateXZ(pos, vec3(3.5,0.,2.));\n   vec3 q2 = ReplicateXZ(pos + vec3(3.5/2.0,0.,1.), vec3(3.5,0.,2.));\n   return\n      min(\n         // ground plane - offset in the Y axis\n         Plane(pos-vec3(0.,-0.5,0.), vec3(0.,1.,0.)),\n         min(\n            // subtract one hex prism from another to make a hollow shape\n            max(\n               HexPrism(q1, vec2(1.0,0.5)),\n               -HexPrism(q1-vec3(0.,0.35,0.), vec2(0.7,0.4))\n            ),\n            // TODO: animate!!\n            min(\n               HexPrism(q2, vec2(1.0,0.5)),\n               HexPrism(q2-vec3(0.,0.35,0.), vec2(0.7,0.4))\n            )\n         )\n      );\n}\n\n// Based on original by IQ - optimized to remove a divide\nfloat CalcAO(vec3 p, vec3 n)\n{\n   float r = 0.0;\n   float w = 1.0;\n   for (int i=1; i<=AO_SAMPLES; i++)\n   {\n      float d0 = float(i) * 0.2; // 1.0/5.0\n      r += w * (d0 - Dist(p + n * d0));\n      w *= 0.5;\n   }\n   return 1.0 - clamp(r,0.0,1.0);\n}\n\nfloat CalcSSS(vec3 ro, vec3 rd)\n{\n   float total = 0.0;\n   float weight = 0.5;\n   for (int i=1; i<=AO_SAMPLES; i++)\n   {\n      float delta = pow(float(i), 2.5) * DISTANCE_MIN * 64.0;\n      total += -weight * min(0.0, Dist(ro+rd * delta));\n      weight *= 0.5;\n   }\n   return clamp(total, 0.0, 1.0);\n}\n\n// Based on original code by IQ\nfloat SoftShadow(vec3 ro, vec3 rd, float k)\n{\n   float res = 1.0;\n   float t = 0.05;         // min-t see https://iquilezles.org/articles/rmshadows\n   for (int i=0; i<SHADOW_RAY_DEPTH; i++)\n   {\n      float h = Dist(ro + rd * t);\n      res = min(res, k*h/t);\n      t += h;\n      if (t > 10.0) break; // max-t\n   }\n   return clamp(res, 0.0, 1.0);\n}\n\nvec3 GetNormal(vec3 pos)\n{\n   vec3 n;\n   n.x = Dist( pos + delta.xyy ) - Dist( pos - delta.xyy );\n   n.y = Dist( pos + delta.yxy ) - Dist( pos - delta.yxy );\n   n.z = Dist( pos + delta.yyx ) - Dist( pos - delta.yyx );\n   \n   return normalize(n);\n}\n\nconst vec3 lightColour = vec3(0.0, 0.8, 2.0);\nconst vec3 lightDir = vec3(0.845, 0.507, 0.169);\nconst float diffuse = 0.25;\nconst vec3 sssColour = vec3(1.1,1.5,2.2);\nconst float ambientFactor = 0.25;\n\nvec4 Shading(vec3 pos, vec3 rd, vec3 norm)\n{\n   vec3 light = lightColour * max(0.0, dot(norm, lightDir));\n   vec3 heading = normalize(-rd + lightDir);\n   light = (diffuse * light);\n   light *= SoftShadow(pos, lightDir, 16.0);\n   light = mix(light, sssColour, CalcSSS(pos, rd));\n   light += CalcAO(pos, norm) * ambientFactor;\n   return vec4(light, 1.0);\n}\n\n// Original method by David Hoskins\nvec3 PostEffects(vec3 rgb, vec2 xy)\n{\n\trgb = pow(rgb, vec3(GAMMA));\n\trgb = mix(vec3(.5), mix(vec3(dot(vec3(.2125, .7154, .0721), rgb*BRIGHTNESS)), rgb*BRIGHTNESS, SATURATION), CONTRAST);\n\trgb *= .4+0.5*pow(40.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), 0.2 );\t\n\treturn rgb;\n}\n\n// Camera function by TekF\n// Compute ray from camera parameters\nvec3 GetRay(vec3 dir, vec2 pos)\n{\n   pos = pos - 0.5;\n   pos.x *= iResolution.x/iResolution.y;\n   \n   dir = normalize(dir);\n   vec3 right = normalize(cross(vec3(0.,1.,0.),dir));\n   vec3 up = normalize(cross(dir,right));\n   \n   return dir + right*pos.x + up*pos.y;\n}\n\nvec4 March(vec3 ro, vec3 rd)\n{\n   float t = 0.0;\n   float d = 1.0;\n   for (int i=0; i<RAY_DEPTH; i++)\n   {\n      vec3 p = ro + rd * t;\n      d = Dist(p);\n      if (abs(d) < DISTANCE_MIN)\n      {\n         return vec4(p, 1.0);\n      }\n      t += d;\n      if (t >= MAX_DEPTH) break;\n   }\n   return vec4(0.0);\n}\n\nconst vec3 cameraPos = vec3(7.5,10.0,0.0);\nconst vec3 cameraLookAt = vec3(0.0,-100.0,-100.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec3 off = vec3(0.0);\n   off.z -= iTime*5.0;\n   \n   vec4 res = vec4(0.0);\n   vec2 p = fragCoord.xy / iResolution.xy;\n   vec3 ro = cameraPos + off;\n   vec3 rd = normalize(GetRay(cameraLookAt-cameraPos, p));\n   res = March(ro, rd);\n   res.xyz = clamp(Shading(res.xyz, rd, GetNormal(res.xyz)).xyz, 0.0, 1.0);\n   res.xyz = PostEffects(res.xyz, p);\n   \n   fragColor = vec4(res.rgb, 1.0);\n}","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"MsBSWt","date":"1417013569","viewed":869,"name":"Hexafield","username":"kevs3d","description":"Double hex field ray marching shader.\nAO, SSO, shadows etc. Uses code by other authors - as credited in method comments.\nThis and others on my shader page: http://www.kevs3d.co.uk/dev/shaders","likes":22,"published":1,"flags":0,"usePreview":0,"tags":["procedural","ray","marching"],"hasliked":0,"parentid":"","parentname":""}}