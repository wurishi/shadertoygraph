{"ver":"0.1","info":{"id":"cdX3zM","date":"1665826462","viewed":81,"name":"Shaping functions plotter","username":"Envy24","description":"Sources: https://thebookofshaders.com/05/\n             https://thebookofshaders.com/05/kynd.png","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["functions","easing","shaping"],"hasliked":0,"parentid":"stVcDz","parentname":"Minimal Plotter"},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        (  R.x / R.y  )\n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define UNIT                      (  2.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat draw_explicit_func(vec2 NDC, float fx, float dfdx)\n{\n    float signed_dist = NDC.y - fx;\n    return SMAA(abs(signed_dist) / sqrt(1.0 + dfdx * dfdx)); // absolute value / arclenght over unit length interval\n}\n\nfloat linear_remap(\n    float val,\n    float fl,\n    float fr,\n    float tl,\n    float tr)\n{\n    val = (val - fl) / (fr - fl); // inverse linear map from [fl; fr] to [0; 1].\n    return val * (tr - tl) + tl;  // linear map from [0; 1] to [tl; tr].\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R) { return length(C - NDC)-R; }\n\nfloat segmentSDF_L2(in vec2 NDC, in vec2 B, in vec2 E, in float R)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0)) - R;\n}\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    // Map xy from [0.5; R.x-0.5][0.5; R.y-0.5] to [min_x; max_x][0; 1]\n    vec2 NDC = (TO_CENTERED_NDC(SC)+vec2(0,1))/2.;\n    // min_x and max_x need to be calculated on fly, because they depend on viewport resolution.\n    float min_x = ( (TO_CENTERED_NDC(vec2(0.5))+vec2(0,1))/2.).x,\n          max_x = ( (TO_CENTERED_NDC(vec2(R.x-0.5))+vec2(0,1))/2.).x;\n\n    float x, y; vec3 color = vec3(1);\n    /* Gradient and curve. */\n         x = linear_remap(NDC.x, min_x, max_x, mins.x, maxs.x);\n    vec3 curve = vec3(0, draw_explicit_func(NDC, func(x), dfdx(x, 0.01)), 0),\n         gradient = vec3(func(x));\n         color = mix( curve, gradient, 1.-curve.y );\n         \n    /* Moving point and progress bar. */\n    float t = fract(iTime*0.125);\n          x = linear_remap(t, 0., 1., mins.x, maxs.x);\n          y = func(x);\n          color = mix( color, vec3(1,0,1), SMAA(diskSDF_L2(NDC, vec2(linear_remap(y, mins.y, maxs.y, min_x, max_x), y), 3.*UNIT)) );\n\n          x = linear_remap(x, mins.x, maxs.x, min_x, max_x);\n          color = mix( color, vec3(1,0,0), SMAA(segmentSDF_L2(NDC, vec2(min_x, 0.), vec2(x, 0), UNIT)) );\n    /**/\n    \n    O = vec4(color,1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* More functions:\n    https://iquilezles.org/articles/functions/\n    https://www.shadertoy.com/view/stj3zG\n*/\n\n#define PI                          3.1415926535897932\n\n/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\n/*\n    Examples\n*/\n\n/**\nvec2 mins = vec2(0., 0.), maxs = vec2(1., 1.);\n#define func(x)     ( (x) )\n#define dfdx(x, dx) ( 1. )\n/**\nvec2 mins = vec2(0., 0.), maxs = vec2(1., 1.);\n#define func(x)     ( max(step(0.5, x), 0.0023) )\n#define dfdx(x, dx) ( 0. )\n/**\nvec2 mins = vec2(0., 0.), maxs = vec2(1., 1.);\n#define func(x)     ( smoothstep(0., 1., x) )\n#define dfdx(x, dx) ( ( func((x)+(dx)) - func(x) ) / (dx) )\n/*line 1 from: https://thebookofshaders.com/05/kynd.png*\nvec2 mins = vec2(-1., 0.), maxs = vec2(1., 1.);\n#define EXP         ( 0.5 )// ( sinOSC(0.5, 10., iTime) )      \n#define func(x)     ( 1. - pow(abs(x), EXP) )\n#define dfdx(x, dx) ( -EXP*pow(abs(x), EXP)/(x) )\n/*line 2 from: https://thebookofshaders.com/05/kynd.png*/\nvec2 mins = vec2(-1., 0.), maxs = vec2(1., 1.);\n#define EXP         ( 25.0 )// ( sinOSC(0.5, 20., iTime) )      \n#define func(x)     ( pow(cos(PI*x*0.5), EXP) )\n#define dfdx(x, dx) ( -PI*EXP*pow(cos(PI*x*0.5), EXP-1.)*sin(PI*x*0.5)*0.5 )\n/*line 3 from: https://thebookofshaders.com/05/kynd.png*\nvec2 mins = vec2(-1., 0.), maxs = vec2(1., 1.);\n#define EXP         ( 0.5 )//  ( sinOSC(0.5, 20., iTime) )      \n#define func(x)     ( 1.-pow(abs(sin(PI*x*0.5)), EXP) )\n#define dfdx(x, dx) ( ( -PI*EXP*cos(PI*x*0.5)*pow(abs(sin(PI*x*0.5)), EXP) ) / ( 2.*sin(PI*x*0.5) ) )\n/*line 5 from: https://thebookofshaders.com/05/kynd.png*\nfloat derivative_of_min(float x, float dx, float EXP)\n{\n#define F0(x) ( pow(cos(PI*(x)*0.5), EXP) )\n#define F1(x) ( pow(1.-abs(x), EXP) )\n    float f0 = F0(x), f1 = F1(x), f = min(f0, f1);\n    \n    return \n        f == f0 ?\n            ( F0(x+dx) - f0 ) / dx :\n            ( F1(x+dx) - f1 ) / dx;\n}\nvec2 mins = vec2(-1., 0.), maxs = vec2(1., 1.);\n#define EXP         ( 25. )//  ( sinOSC(0.5, 10., iTime) )      \n#define func(x)     ( min(pow(cos(PI*x*0.5), EXP), pow(1.-abs(x), EXP)) )\n#define dfdx(x, dx) ( derivative_of_min(x, 0.001, EXP) )\n/*line 5 from: https://thebookofshaders.com/05/kynd.png*\nfloat derivative_of_max(float x, float dx, float EXP)\n{\n#define F0(x) ( 0.001 )\n#define F1(x) ( pow(2.*abs(x)-1., EXP) )\n    float f0 = F0(x), f1 = F1(x), f = max(f0, f1);\n    \n    return\n        f == f0 ?\n            ( F0(x+dx) - f0 ) / dx :\n            ( F1(x+dx) - f1 ) / dx;\n#undef F0\n#undef F1\n}\nvec2 mins = vec2(-1., 0.), maxs = vec2(1., 1.);\n#define EXP         ( 0.5 )//  ( sinOSC(0.5, 10., iTime) )      \n#define func(x)     ( 1.-pow(max(0.0, 2.*abs(x)-1.), EXP) )\n#define dfdx(x, dx) ( derivative_of_max(x, 0.001, EXP) )\n/**\nvec2 mins = vec2(-1., 0.), maxs = vec2(1., 1.);\n#define FREQ        ( 3.14*0.5 )//  ( sinOSC(0.5, 10., iTime) )      \n#define func(x)     ( (sin(FREQ*(x))+1.)*0.5 )\n#define dfdx(x, dx) ( FREQ*cos(FREQ*(x))*0.5 )\n/**\nvec2 mins = vec2(0., 0.), maxs = vec2(1., 1.);\n#define func(x)     ( 0.5 * (1.0 + sin(4.71239 * (clamp((x), 0.0, 1.0) * 2.0 - 1.0) * (clamp((x), 0.0, 1.0) * 2.0 - 1.0))) )\n#define dfdx(x, dx) ( ( func((x)+(dx)) - func(x) ) / (dx) )\n/*https://iquilezles.org/articles/functions/*\nvec2 mins = vec2(0., 0.), maxs = vec2(1., 1.);\n#define func(x)     ( pcurve(x, 5., 1.) )\n#define dfdx(x, dx) ( ( func((x)+(dx)) - func(x) ) / (dx) )\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b)/(pow(a,a)*pow(b,b));\n    return k*pow(x,a)*pow(1.0-x,b);\n}\n/**/","name":"Common","description":"","type":"common"}]}