{"ver":"0.1","info":{"id":"M32BDw","date":"1729565303","viewed":127,"name":"Linear Combination of Planes","username":"pyBlob","description":"It is well know, that linear combination of two points lie on a line. Yet, the same is true for planes!\nPlanes are just the tip of the iceberg: [url=https://www.youtube.com/watch?v=0i3ocLhbxJ4]A Switft Introduction to Projective Geometric Algebra[/url]","likes":10,"published":3,"flags":32,"usePreview":0,"tags":["plane","pga"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Observe that moving any single slider rotates (or translates) the red plane around a line.\n// This rotation/translation will leave that line fixed.\n//\n// For example:\n//   When moving the *green* slider, the red plane will rotate around the intersection with the *green* plane.\n\nconst vec3 planeColor[] = vec3[](\n    vec3(0,.2,1),\n    vec3(1,.3,0),\n    vec3(0,.5,0),\n    vec3(.8,0,0));\n\nconst vec4 plane[] = vec4[](\n    vec4( 0.90996539, -0.15110143,  0.41114401,  0.70411124),\n    vec4( 0.24724327, -1.170113  , -1.19116371, -0.18343476),\n    vec4( 0.91098718,  1.26544638, -1.12091734, -0.43541908));\nconst vec4 e0 = vec4(0, 0, 0, 1);\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    I = ivec2(O = fragCoord); res = iResolution.xy;\n    initMouse(iMouse);\n    load(iChannel1);\n\n    float a;\n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = normalize(vec3(O * 2. - res.yy, res.y));\n    if (false)\n        ro = vec3((O * 2. - res.yy) * 3., -3. * res.y) / res.y, rd = vec3(0, 0, 1);\n    a = -0.5 + view.y;\n    ro *= R(vec3(1, 0, 0), a);\n    rd *= R(vec3(1, 0, 0), a);\n    a = 0.5 - view.x;\n    ro *= R(vec3(0, 1, 0), a);\n    rd *= R(vec3(0, 1, 0), a);\n\n    float m = 1., dgrid = 1e9, d = 0.;\n    for (int i=0 ; i<10 ; ++i)\n    {\n        float r = 1e9;\n        vec3 x = ro + rd * d;\n        vec3 col = vec3(3);\n        ifmin (r, length(x - vec3(round(clamp(x.x, -2., 2.) * 1.) / 1., 0, clamp(x.z, -2.5 ,2.5))));\n        ifmin (r, length(x - vec3(clamp(x.x, -2.5 ,2.5), 0, round(clamp(x.z, -2., 2.) * 1.) / 1.)));\n        ifmin (r, length(x - vec3(0, clamp(x.y, -2.5, 2.5), 0)));\n        ifmin(m, res.y / 2. / d * r) dgrid = d;\n        d += r;\n    }\n    \n    float d0 = -(dot(ro, plane[0].xyz) + plane[0].w) / dot(rd, plane[0].xyz); vec3 x0 = ro + rd * d0; float m0 =  smoothstep(0., fwidth(length(x0)), 2. - length(x0));\n    float d1 = -(dot(ro, plane[1].xyz) + plane[1].w) / dot(rd, plane[1].xyz); vec3 x1 = ro + rd * d1; float m1 =  smoothstep(0., fwidth(length(x1)), 2. - length(x1));\n    float d2 = -(dot(ro, plane[2].xyz) + plane[2].w) / dot(rd, plane[2].xyz); vec3 x2 = ro + rd * d2; float m2 =  smoothstep(0., fwidth(length(x2)), 2. - length(x2));\n\n    vec4 plane3 = mat4(plane[0], plane[1], plane[2], e0) * planemix;\n    float d3 = -(dot(ro, plane3.xyz) + plane3.w) / dot(rd, plane3.xyz); vec3 x3 = ro + rd * d3; float m3 =  smoothstep(0., fwidth(length(x3)), 2. - length(x3));\n\n    C = vec4(1);\n    float dc = 1e9;\n    for (int i=0 ; i<5 ; i++)\n    {\n        float dfrag = 0.;\n        vec4 frag = vec4(0);\n        ifnext (dc, dfrag, dgrid) frag = vec4(0,0,0,1) * (1. - m);\n        //if (length(x0) < 2.)\n        ifnext (dc, dfrag, d0) frag = vec4(planeColor[0], 1) * .9 * m0;\n        ifnext (dc, dfrag, d1) frag = vec4(planeColor[1], 1) * .9 * m1;\n        ifnext (dc, dfrag, d2) frag = vec4(planeColor[2], 1) * .9 * m2;\n        ifnext (dc, dfrag, d3) frag = vec4(planeColor[3], 1) * .9 * m3;\n        dc = dfrag;\n        blend(frag);\n    }\n    blendSlide(slidePM[0], planemix[0], planeColor[0]);\n    blendSlide(slidePM[1], planemix[1], planeColor[1]);\n    blendSlide(slidePM[2], planemix[2], planeColor[2]);\n    blendSlide(slidePM[3], planemix[3], vec3(0));\n    blendTriSlide(triSlidePM, planemix[0], planemix[1], planemix[2], planeColor[0], planeColor[1], planeColor[2]);\n    fragColor = sqrt(C);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsBSR3","filepath":"/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","previewfilepath":"/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    I = ivec2(O = fragCoord); res = iResolution.xy;\n    initMouse(iMouse);\n\n    if (iFrame != 0)\n    {\n        load(iChannel1);\n        slide(slidePM[0], planemix[0]);\n        slide(slidePM[1], planemix[1]);\n        slide(slidePM[2], planemix[2]);\n        slide(slidePM[3], planemix[3]);\n        triSlide(triSlidePM, planemix[0], planemix[1], planemix[2]);\n        if (hold && inside(mouseRef, viewBox * res.xyxy))\n            view = (mouse * 2. - res.yy) / res.y;\n        float a = .2 + iTime;\n        if (demo)\n            planemix = vec4(cos(a), sin(a), 0, 0);\n    }\n    store();\n    fragColor = C;\n}\n","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"#define R2(a) mat2(cos(a), sin(a), -sin(a), cos(a))\nmat3 R(vec3 v, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    mat3 K = mat3(0, v.z, -v.y, -v.z, 0, v.x, v.y, -v.x, 0);\n    return mat3(1) + s * K + (1. - c) * (K * K);\n}\n\nbool _ifmin(inout float x, float y) { return y < x ? x = y, true : false; }\n#define ifmin(x, y) if (_ifmin(x, y))\n\nbool _ifnext(float dc, inout float dfrag, float d) { return d < dc && d > dfrag ? dfrag = d, true : false; }\n#define ifnext(dc, dfrag, d) if (_ifnext(dc, dfrag, d))\n\nvec4 C; vec2 O, res; ivec2 I;\nvoid blend(vec4 c)\n{\n    C = C * (1. - c.w) + c;\n}\n\nfloat sdCapsule(vec2 p, vec2 a, vec2 b)\n{\n    // https://iquilezles.org/articles/distfunctions\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b)\n{\n    // https://iquilezles.org/articles/distfunctions\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\nvec2 mouse, mouseRef;\nbool hold, down, demo;\nvoid initMouse(vec4 iMouse)\n{\n    demo = iMouse.z == 0.;\n    mouse = abs(iMouse.xy);\n    mouseRef = abs(iMouse.zw);\n    hold = iMouse.z > 0.;\n}\n\nvec4 planemix = vec4(.98, .2, 0, 0);\nvec2 view = vec2(0);\nvoid load(sampler2D bufferA)\n{\n    vec4 c;\n    c = texelFetch(bufferA, ivec2(0, 0), 0);\n    planemix = c.xyzw;\n    c = texelFetch(bufferA, ivec2(1, 0), 0);\n    view = c.xy;\n}\nvoid store()\n{\n    C = vec4(0);\n    if (I == ivec2(0, 0))\n        C = vec4(planemix);\n    if (I == ivec2(1, 0))\n        C = vec4(view, 0, 0);\n}\n\nvec2 map(vec2 uv, vec4 box)\n{\n    return uv * box.zw + box.xy;\n}\nvec2 local(vec2 x, vec4 box)\n{\n    return (x - box.xy) / box.zw;\n}\nbool inside(vec2 x, vec4 box)\n{\n    x = local(x, box);\n    return x.x >= 0. && x.y >= 0. && x.x < 1. && x.y < 1.;\n}\n\nconst vec4 slidePM[] = vec4[](\n    vec4(.6, .0, .4, .1),\n    vec4(.6, .1, .4, .1),\n    vec4(.6, .2, .4, .1),\n    vec4(.6, .3, .4, .1)),\n    viewBox = vec4(0, 0, .6, 1),\n    triSlidePM = vec4(.6, .4, .4, .6),\n    slidePad = vec4(20, 0, -40, 0),\n    triSlidePad = vec4(20, 0, -40, 0);\n\nvoid slide(vec4 slide, inout float v)\n{\n    slide *= res.xyxy;\n    if (hold && inside(mouseRef, slide))\n        v = clamp(local(mouse, slide + slidePad).x, 0., 1.) * 2. - 1.;\n}\nvoid blendSlide(vec4 slide, float v, vec3 color)\n{\n    slide *= res.xyxy;\n    slide += slidePad;\n    blend(vec4(color,1) * clamp(3. - length(O - vec2(clamp(O.x, slide.x, slide.x+slide.z), slide.y+slide.w*.5)), 0., 1.));\n    blend(vec4(1,1,1,1) * clamp(1.5 - length(O - vec2(clamp(O.x, slide.x, slide.x+slide.z), slide.y+slide.w*.5)), 0., 1.));\n    float r = 5.;\n    if (hold && inside(mouseRef, slide))\n        r = 6.;//, v = clamp(local(mouse, slide).x, 0., 1.) * 2. - 1.;\n    blend(vec4(color,1) * clamp(r - length(O - map(vec2((v+1.)/2., .5), slide)), 0., 1.));\n}\n\nconst vec2 oo = vec2(0), a0 = vec2(.8, 0), a1 = a0 * R2(radians(120.)), a2 = a1 * R2(radians(120.));\nmat3x2 triLocal(vec2 x, vec4 slide)\n{\n    slide *= res.xyxy;\n    slide += triSlidePad;\n    x = local(x, slide) * 2. - 1.;\n    return mat3x2(\n        inverse(mat2(a0, a1)) * x,\n        inverse(mat2(a0, a2)) * x,\n        inverse(mat2(a1, a2)) * x);\n}\nvoid triSlide(vec4 slide, inout float v0, inout float v1, inout float v2)\n{\n    mat3x2 mr = triLocal(mouseRef, slide);\n    mat3x2 m  = triLocal(mouse, slide);\n    if (hold && inside(mr[0], vec4(0, 0, 1, 1)))\n        v0 = clamp(m[0].x, 0., 1.) * 2. - 1., v1 = clamp(m[0].y, 0., 1.) * 2. - 1.;\n    if (hold && inside(mr[1], vec4(0, 0, 1, 1)))\n        v0 = clamp(m[1].x, 0., 1.) * 2. - 1., v2 = clamp(m[1].y, 0., 1.) * -2. + 1.;\n    if (hold && inside(mr[2], vec4(0, 0, 1, 1)))\n        v1 = clamp(m[2].x, 0., 1.) * 2. - 1., v2 = clamp(m[2].y, 0., 1.) * -2. + 1.;\n}\nvoid blendTriSlide(vec4 slide, float v0, float v1, float v2, vec3 c0, vec3 c1, vec3 c2)\n{\n    mat3x2 mr = triLocal(mouseRef, slide);\n    slide *= res.xyxy;\n    slide += triSlidePad;\n    float f = length(slide.zw) / 2.;\n    vec3 v = (vec3(v0, v1, -v2) + 1.) / 2.;\n    vec2 uv = local(O, slide) * 2. - 1., p0 = v[0] * a0, p1 = v[1] * a1, p2 = v[2] * a2;\n    float r0 = 0., r1 = 0., r2 = 0.;\n    if (hold && inside(mr[0], vec4(0, 0, 1, 1)))\n        r0 = 1.;\n    if (hold && inside(mr[1], vec4(0, 0, 1, 1)))\n        r1 = 1.;\n    if (hold && inside(mr[2], vec4(0, 0, 1, 1)))\n        r2 = 1.;\n    blend(vec4(0,0,0, 1) * clamp(r0 + 1.4 - sdCapsule(uv, p0+p1, p0+p1+p2) * f, 0., 1.));\n    blend(vec4(0,0,0, 1) * clamp(r1 + 1.4 - sdCapsule(uv, p0+p2, p0+p1+p2) * f, 0., 1.));\n    blend(vec4(0,0,0, 1) * clamp(r2 + 1.4 - sdCapsule(uv, p1+p2, p0+p1+p2) * f, 0., 1.));\n    blend(vec4(c0, 1) * clamp(1.4 - sdCapsule(uv, oo, a0) * f, 0., 1.));\n    blend(vec4(c0, 1) * clamp(1.4 - sdCapsule(uv, a1, a0+a1) * f, 0., 1.));\n    blend(vec4(c0, 1) * clamp(1.4 - sdCapsule(uv, a2, a0+a2) * f, 0., 1.));\n    blend(vec4(c1, 1) * clamp(1.4 - sdCapsule(uv, a0, a1+a0) * f, 0., 1.));\n    blend(vec4(c1, 1) * clamp(1.4 - sdCapsule(uv, oo, a1) * f, 0., 1.));\n    blend(vec4(c1, 1) * clamp(1.4 - sdCapsule(uv, a2, a1+a2) * f, 0., 1.));\n    blend(vec4(c2, 1) * clamp(1.4 - sdCapsule(uv, a0, a2+a0) * f, 0., 1.));\n    blend(vec4(c2, 1) * clamp(1.4 - sdCapsule(uv, a1, a2+a1) * f, 0., 1.));\n    blend(vec4(c2, 1) * clamp(1.4 - sdCapsule(uv, oo, a2) * f, 0., 1.));\n    blend(vec4(0,0,0, 1) * clamp(r0 + 3. - length(uv - p0-p1) * f, 0., 1.));\n    blend(vec4(0,0,0, 1) * clamp(r1 + 3. - length(uv - p0-p2) * f, 0., 1.));\n    blend(vec4(0,0,0, 1) * clamp(r2 + 3. - length(uv - p1-p2) * f, 0., 1.));\n}\n","name":"Common","description":"","type":"common"}]}