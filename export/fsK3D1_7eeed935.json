{"ver":"0.1","info":{"id":"fsK3D1","date":"1631488824","viewed":59,"name":"Purple spaghetti event horizon","username":"wzdd","description":"Follow and play with a tutorial from Flopine\n\nThis has sound: if it doesn't autoplay pressing ‚èÆ might help","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["sdf","learn"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float period = 6.0;\nconst float PI = 3.1415;\nfloat id;\n\nbool multicol = false;\n\nvec3 palette(float idx) {    \n    return vec3(cos(2.1 * PI * idx), cos(2.2 * PI * idx), cos(2. * PI * idx));\n}\n\nfloat SDF_sphere(vec3 point, float intensity)\n{\n    point.z += (intensity * 2.) + sin(iTime) * 0.05;\n    float sphere = length(point) - .8;\n    return sphere;\n}\n\nfloat SDF_cylinder(vec3 point, float intensity)\n{\n    point.x = mod(point.x, period) - (period * 0.5);\n    point.y = abs(point.y) - 8.;\n    \n    point.x += sin(point.z * id * 0.2 + iTime);\n    point.y += sin(point.z * id * 0.1 + iTime);\n    \n    float cylinder = length(point.xy) - 0.6;\n    return cylinder;\n}\n\nfloat SDF(vec3 point, float intensity) {\n    id = floor(point.x / period);\n\n    float sphere = SDF_sphere(point, intensity);\n    float cylinder = SDF_cylinder(point, intensity);\n    \n    if (cylinder < sphere) {\n        multicol = true;\n        return cylinder;\n    } else {\n        multicol = false;\n        return sphere;\n    }\n}\n\nfloat doSound(in vec2 fragCoord)\n{\n    // credit https://www.shadertoy.com/view/Xds3Rr\n    \n    // Fetch sound data\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    int tx = int(uv.x * 512.0);\n    float fft  = texelFetch( iChannel0, ivec2(tx,0), 0 ).x; \n    \n    return fft;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float intensity = doSound(fragCoord);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Normalised pixel coordinates (from -1 to 1, taking into account aspect ratio)\n    vec2 centered_uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    // Background\n    vec3 col = vec3(0., 0., 0.);\n\n    // Camera\n    vec3 ray_origin = vec3(0., 0., -3.);\n    \n    // Frustrum\n    vec3 ray_direction = normalize(vec3(centered_uv, 1.));\n\n    // The point we're at, starting at the camera.\n    vec3 point = ray_origin;\n    \n    // Walk along the ray.\n    for(float i = 0.; i < 64.; i++) {\n        float dist = SDF(point, intensity);\n        \n        if(dist < 0.0001) {\n            // We hit it (or close enough)\n            float shade = 1. - (i / 64.);\n            if(multicol) {\n                col = palette(id) * shade;\n            } else {\n                col = vec3(shade);\n            }\n            break;\n        }\n        \n        point += (dist * ray_direction);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    \n    \n    \n}","name":"Image","description":"","type":"image"}]}