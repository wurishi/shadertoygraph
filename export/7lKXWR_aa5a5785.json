{"ver":"0.1","info":{"id":"7lKXWR","date":"1640530502","viewed":62,"name":"Spirit of fire","username":"satoyuichi","description":"Spirit of fire","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["fire"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define EPS 0.01\n\nvec3 mod289 (vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289 (vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute (vec3 x) { return mod289(((x * 34.0) + 1.0) * x); }\nvec4 permute (vec4 x) { return mod(((x * 34.0) + 1.0) * x, 289.0); }\nvec4 taylorInvSqrt (vec4 x) { return 1.79284291400159 - 0.85373472095314 * x; }\n\nfloat snoise (vec2 v) {\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187, // (3.0 - sqrt(3.0)) / 6.0\n                        0.366025403784439, // 0.5 * (sqrt(3.0) - 1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute(i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0, x0),\n                        dot(x1, x1),\n                        dot(x2, x2)\n                        ), 0.0);\n\n    m = m * m;\n    m = m * m;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(0.0);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x, x2.x) + h.yz * vec2(x1.y, x2.y);\n    return 130.0 * dot(m, g);\n}\n\nmat2 rotate2d(float _angle) {\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat2(c, -s,\n                s, c);\n}\n\n//  Function from IÃ±igo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0),\n                             6.0) - 3.0) - 1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nfloat circle(in vec2 _st, in float _radius, in float _th){\n\treturn 1. - smoothstep( _radius - (_radius * _th),\n                            _radius + (_radius * _th),\n                            dot(_st, _st));\n}\n\nfloat box(in vec2 _st, in vec2 _wh, in float _smooth) {\n    vec2 r = abs(_st);\n    return 1. - max(smoothstep(_wh.x, _wh.x + _smooth, r.x), smoothstep(_wh.y, _wh.y + _smooth, r.y));\n}\n\n/*--------------------------------------------------*/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    /*----------*/\n\tfloat t = iTime;\n    float dt = iTimeDelta;\n    vec3 color = vec3(0.);\n    vec2 st = 2. * fragCoord.xy / iResolution.xy - 1.0; // -1 <> 1\n    vec2 st01 = fragCoord.xy / iResolution.xy; // 0 <> 1\n    vec2 mouse = 2. * iMouse.xy / iResolution.xy - 1.0;\n    vec3 camera = vec3(0., 0., -5.);\n    float near = 2.5;\n    vec3 ray = normalize(vec3(st, near));\n    /*----------*/\n\n    vec2 v;\n    float d;\n\n    v = fract(st01 * 6.);\n    v += vec2(-0.5, -0.5);\n    v = rotate2d(.5 * t * PI) * v;\n    d = box(v, vec2(0.2, 0.2), .2) * .8 ;\n    color = vec3(d);\n\n    vec3 white = vec3(1.0, 1.0, 1.0);\n    vec3 black = vec3(0.0, 0.0, 0.0);\n    float factor = abs(sin(10.0 * t) + 0.5);\n    vec3 grad = mix(black, white, st01.t * st01.t * factor);\n    color = hsb2rgb(vec3(0.6, 1.0, 1.0)) * color;\n\n    float bg = (snoise((vec2(st01.x, st01.y + t * .3) * 1.)* 7.0) + .8);\n    color *= bg;\n\n    v = fract(st01 * 4.);\n    v += vec2(-0.5, -0.5);\n    v = rotate2d(2. * t) * v;\n    v = vec2(abs(v.x), abs(v.y));\n    v += vec2(-0.2, -0.2);\n\n    v = st;\n    float sn = (snoise(vec2(v.x, v.y - t) * 4.) + 2.0);\n    v = st + vec2(0., 0.08 * sin(2. * t));\n    d = 2. * circle(v, .1, 2.5) * sn;\n\n    v = st + vec2(0.01 * cos(t), 0.3 * sin(5. * t) - .07);\n    d += circle(v, .03, 2.) * sn;\n\n    v = st + vec2(.02 + 0.1 * cos(2. * t), 0.2 * sin(5. * t) - .2);\n    d += circle(v, .05, 3.) * sn;\n\n    v = st + vec2(.02 + 0.03 * cos(30. * t), 0.35 * sin(5. * t) - .3);\n    d += circle(v, .01, 4.) * sn;\n\n    color += clamp (vec3(d * .4, d * .3, d), 0., 0.88);\n\n    fragColor = vec4(color,  d * .02);\n}","name":"Image","description":"","type":"image"}]}