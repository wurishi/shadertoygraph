{"ver":"0.1","info":{"id":"X3VSRW","date":"1719888792","viewed":60,"name":"Shape Transformer","username":"Capo","description":"heyÔºÅ","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["2d","distance"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define time iTime\n#define resolution iResolution\n#define mouse (iMouse.xy/iResolution.xy)\n\n#define PI 3.14159\n#define TAU (PI*2.)\n#define repeat(v,r) (mod(v+r/2.,r)-r/2.)\nfloat rng(vec2 seed) { return fract(sin(dot(seed * .1, vec2(324.654, 156.546))) * 46556.24); }\nmat2 rot(float a) { float c = cos(a), s = sin(a); return mat2(c, s, -s, c); }\nfloat sphere(vec3 p, float r) { return length(p) - r; }\nfloat cylinder(vec2 p, float r) { return length(p) - r; }\nfloat disk(vec3 p, float r, float h) { return max(length(p.xy) - r, abs(p.z) - h); }\nfloat amod(inout vec2 p, float c) {\n    float ca = (2. * 3.14159) / c;\n    float a = atan(p.y, p.x) + ca * .5;\n    float index = floor(a / ca);\n    a = mod(a, ca) - ca * .5;\n    p = vec2(cos(a), sin(a)) * length(p);\n    return index;\n}\nvec3 lookAt(vec3 eye, vec3 target, vec2 uv) {\n    vec3 forward = normalize(target - eye);\n    vec3 right = normalize(cross(vec3(0, 1, 0), forward));\n    vec3 up = normalize(cross(forward, right));\n    return normalize(forward * .5 + uv.x * right + uv.y * up);\n}\nvec3 orbit(vec3 eye) {\n    eye.xz *= rot(mouse.x * 2. - 1.);\n    eye.zy *= rot(-(mouse.y * 2. - 1.));\n    return eye;\n}\n\nstruct Shape {\n    float dist, density, friction;\n    vec3 color;\n};\n\nvec3 gradientColor(float position, float time) {\n    float r = sin(position + time) * 0.5 + 0.5;\n    float g = sin(position + time + 2.0) * 0.5 + 0.5;\n    float b = sin(position + time + 4.0) * 0.5 + 0.5;\n    return vec3(r, g, b);\n}\n\nShape map(vec3 pos) {\n    Shape scene;\n    scene.dist = 1000.;\n    scene.color = vec3(1);\n    scene.friction = .2;\n    scene.density = .01;\n    vec3 p, pp;\n    float shape = 1000.;\n    float interval = .6;\n    float polar = 5.;\n    float radius = 2.;\n    float thin = .005;\n    float diskRadius = .4;\n    float diskThin = .01;\n    scene.dist = sphere(pos, radius);\n\n    p = pos;\n    amod(p.xz, polar);\n    p = abs(p);\n    p.yz *= rot(time * .1);\n    p.xz *= rot(time * .2);\n    p.yx *= rot(time * .3);\n    p = repeat(p - time * .5, interval);\n    shape = min(shape, cylinder(p.xz, thin));\n    shape = min(shape, cylinder(p.yz, thin));\n    shape = min(shape, cylinder(p.yx, thin));\n    pp = p;\n    pp.x = repeat(pp.x + time * .2, .1);\n    shape = min(shape, disk(pp.zyx, .02, thin * .5));\n    pp = p;\n    pp.y = repeat(pp.y + time * .2, .1);\n    shape = min(shape, disk(pp.xzy, .02, thin * .5));\n    pp = p;\n    pp.z = repeat(pp.z + time * .2, .1);\n    shape = min(shape, disk(pp, .02, thin * .5));\n    p.yz *= rot(time * .9);\n    p.xz *= rot(time * .6);\n    p.yx *= rot(time * .3);\n    diskRadius *= 1. - clamp(length(pos) * .5, 0., 1.);\n    shape = min(shape, max(disk(p, diskRadius, thin), -disk(p, diskRadius - diskThin, thin * 2.)));\n    shape = min(shape, max(disk(p.xzy, diskRadius, thin), -disk(p.xzy, diskRadius - diskThin, thin * 2.)));\n    shape = min(shape, max(disk(p.zyx, diskRadius, thin), -disk(p.zyx, diskRadius - diskThin, thin * 2.)));\n\n    scene.dist = max(scene.dist, shape);\n    scene.color = gradientColor(length(p), time); // Set gradient color\n\n    return scene;\n}\n\nvec3 raymarch(vec2 coord) {\n    vec2 viewport = (coord.xy - .5 * resolution.xy) / resolution.y;\n    vec3 origin = orbit(vec3(0, 1, -1));\n    vec3 eye = origin;\n    vec3 ray = lookAt(origin, vec3(0), viewport);\n\n    // Apply rotation to the scene\n    mat3 rotation = mat3(\n        cos(time * 0.1), 0, sin(time * 0.1),\n        0, 1, 0,\n        -sin(time * 0.1), 0, cos(time * 0.1)\n    );\n    eye = rotation * eye;\n    ray = rotation * ray;\n\n    float dither = rng(viewport + fract(time));\n    vec3 color = vec3(0.);\n    float volume = 0.;\n    for (float i = 0.; i <= 1.; i += 1. / 100.) {\n        Shape shape = map(eye);\n        if (shape.dist < 0.001) {\n            color += shape.color * shape.friction * mix(1., 1. - i, shape.friction);\n            volume += shape.friction;\n            if (volume >= 1.) {\n                break;\n            }\n        }\n        shape.dist = max(shape.dist, shape.density);\n        shape.dist *= .9 + .1 * dither;\n        eye += ray * shape.dist;\n    }\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = raymarch(fragCoord.xy);\n    fragColor = vec4(color, 1);\n}\n","name":"Image","description":"","type":"image"}]}