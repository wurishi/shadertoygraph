{"ver":"0.1","info":{"id":"3sS3Wc","date":"1550110618","viewed":356,"name":"Falling water drop - experiment","username":"jaszunio15","description":"Experimenting with refraction - trying to create infinite falling water drop.\nCode was abandoned, it doesn't produce exact effect I wanted to make. And source code is quite messy, I was learning. \n\nSong: https://soundcloud.com/thisisklyne/klyne-water-flow","likes":6,"published":1,"flags":64,"usePreview":0,"tags":["raymarching","refraction","water","experiment","drop"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"ltl3D8","filepath":"https://soundcloud.com/thisisklyne/klyne-water-flow","previewfilepath":"https://soundcloud.com/thisisklyne/klyne-water-flow","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"//Shader License: CC BY 3.0\n//Author: Jan MrÃ³z (jaszunio15)\n\n#define RAY_STEPS_COUNT 30\n#define NEAR_PLANE 1.3\n#define DROP_BRIGHTNESS 0.1\n\n#define DROP_RADIUS 1.8\n#define WATER_EFFECT_MULTIPLIER 0.15\n#define REFLECTIONS 0.5\n#define REFRACTIVE_INDEX 1.1\n#define DISTORTION_DENSITY 3.0\n#define EFFECT_SPEED 40.0\n\n#define TIME (iTime * 0.2)\n\n#define CAMERA_ROTATION_SPEED 2.0\n\n#define PI 3.1415926\n#define EPSILON 0.01\n\nfloat hash13(vec3 v)\n{\n    return fract(sin(dot(v, vec3(11.51721, 67.12511, 9.7561))) * 1551.4172);  \n}\n\nvec3 hash33(vec3 v)\n{\n \treturn fract(sin(v * mat3(11.51721, 67.12511, 9.7561,\n                              85.1741, 7.4751, 9.4371,\n                              7.01641, 9.7561, 1.48141)) * 1551.4172);   \n}\n\nvec3 getNoise33(vec3 v)\n{\n\tvec3 rootV = floor(v);\n    vec3 f = smoothstep(0.0, 1.0, fract(v));\n    \n    vec3 n000 = hash33(rootV);\n    vec3 n001 = hash33(rootV + vec3(0,0,1));\n    vec3 n010 = hash33(rootV + vec3(0,1,0));\n    vec3 n011 = hash33(rootV + vec3(0,1,1));\n    vec3 n100 = hash33(rootV + vec3(1,0,0));\n    vec3 n101 = hash33(rootV + vec3(1,0,1));\n    vec3 n110 = hash33(rootV + vec3(1,1,0));\n    vec3 n111 = hash33(rootV + vec3(1,1,1));\n    \n    vec3 n00 = mix(n000, n001, f.z);\n    vec3 n01 = mix(n010, n011, f.z);\n    vec3 n10 = mix(n100, n101, f.z);\n    vec3 n11 = mix(n110, n111, f.z);\n    \n    vec3 n0 = mix(n00, n01, f.y);\n    vec3 n1 = mix(n10, n11, f.y);\n    \n    return mix(n0, n1, f.x);\n}\n\n//sphere -> drop\nvoid dropifyPoint(inout vec3 v)\n{\n    float dropRadius = pow(dot(v.xz, v.xz), 0.25) - (0.6 + sin(TIME * 2.0) * 0.2);\n    float dropY = v.y + 0.0;\n    dropY *= 0.7;\n    dropY += (v.y + 5.0) * dropRadius * 0.3;\n    v.y = mix(v.y, dropY, smoothstep(-1.0, 1.0, v.y));\n    v.xz *= 2.0;\n}\n\n// x)\nfloat dropDistance(vec3 v, float time, float beat)\n{\n    vec3 modifier = getNoise33(v * DISTORTION_DENSITY * (0.9 + beat * 0.1) - time * EFFECT_SPEED * vec3(0, 1, 0) + beat * 0.2);\n    dropifyPoint(v);\n    v += (modifier.rgb - 0.5) * WATER_EFFECT_MULTIPLIER;\n \tfloat dist = sqrt(dot(v, v));\n    dist = -DROP_RADIUS + dist;\n    \n    return dist;\n}\n\nvec3 getDropNormal(vec3 point, float time, float beat)\n{\n \tfloat p000 = dropDistance(point, time, beat);\n    float p001 = dropDistance(point + vec3(0,0,EPSILON), time, beat);\n    float p010 = dropDistance(point + vec3(0,EPSILON,0), time, beat);\n    float p100 = dropDistance(point + vec3(EPSILON,0,0), time, beat);\n    \n    return normalize(vec3(p100 - p000, p010 - p000, p001 - p000));\n}\n  \nfloat dropMarchInside(vec3 rayStart, vec3 rayDirection, float beat, inout vec3 resultPoint, inout vec3 resultNormal)\n{\n    vec3 point = rayStart;\n    float dropDist = 0.0;\n    \n \tfor (int i = 0; i < RAY_STEPS_COUNT * 1 && abs(dropDist) < 50.0; i++)\n    {\n        dropDist = -dropDistance(point, TIME, beat);\n        point += rayDirection * dropDist * 0.3;\n    }\n    \n    resultNormal = -getDropNormal(point, TIME, beat);  \n    resultPoint = point;\n    \n    return dropDist;\n}\n\nfloat dropMarch(vec3 rayStart, vec3 rayDirection, float beat, inout vec3 resultPoint, inout vec3 resultNormal)\n{\n    vec3 point = rayStart;\n    float dropDist = 0.0;\n    \n \tfor (int i = 0; i < RAY_STEPS_COUNT && abs(dropDist) < 50.0; i++)\n    {\n        dropDist = dropDistance(point, TIME, beat);\n        point += rayDirection * dropDist * 0.3;\n    }\n    \n    resultNormal = getDropNormal(point, TIME, beat);  \n    resultPoint = point;\n    \n    return dropDist;\n}\n\n\nfloat getBeat(float offset, float bandStep, float bandsCount)\n{\n \tfloat beat = 0.0;\n    for (float i = 0.0; i < bandsCount; i++)   \n    {\n        float bandCoord = offset + i * bandStep;\n        bandCoord *= bandCoord;\n        beat += texture(iChannel0, vec2(bandCoord, 0)).r;\n    }\n    \n    return beat /= bandsCount;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res = iResolution.xy;\n    vec2 uv = 2.0 * fragCoord - res;\n    uv /= min(res.x, res.y);\n    \n    vec2 mouse;\n    if(length(iMouse.xy) >= 1.0) mouse = (2.0 * iMouse.xy - iResolution.xy) / iResolution.xy;\n    else mouse = vec2(0, 0.2);\n    \n    float time = TIME;\n    float beat = getBeat(0.01, 0.01, 64.0);\n    beat *= beat;\n    beat = smoothstep(0.35, 0.6, beat) * 2.0;\n    \n    float angleY = -mouse.x * 3.0 * PI + sin(time * CAMERA_ROTATION_SPEED * 0.2) * 5.0;\n    float angleX = -mouse.y * PI * 0.3 + PI * 0.5 + cos(time * CAMERA_ROTATION_SPEED * 0.97) * 0.4 - 0.1;\n    float angleZ = PI * 0.5 + sin(time * CAMERA_ROTATION_SPEED * 0.5 * 0.891) * 0.2;\n\n    mat3 rotation =   mat3(sin(angleY),  0, cos(angleY),\n                           0, \t\t\t 1, 0,\n                           -cos(angleY), 0, sin(angleY))\n        \t\t\t* mat3(1, 0, \t\t\t0,\n                           0, sin(angleX),  cos(angleX),\n                           0, -cos(angleX), sin(angleX))\n        \t\t\t* mat3(sin(angleZ),  cos(angleZ), 0,\n                           -cos(angleZ), sin(angleZ), 0,\n                           0, \t\t\t 0, \t\t  1);\n        \t\t\t\n    \n    vec3 cameraCenter = rotation * vec3(sin(time * 0.3) * 1.0, sin(time * 0.6) * 1.0, 5.0 + cos(time * 0.9));\n    vec3 rayDirection = normalize(rotation * vec3(uv.x, uv.y, -NEAR_PLANE + sin(time * 1.0) * 0.2 * (1.0 + beat * 0.15)));\n    \n    float rayOriginShift = max(length(cameraCenter) - DROP_RADIUS * 2.0, 0.0);\n    vec3 rayStart = cameraCenter + rayDirection * rayOriginShift;\n    \n    rayDirection = normalize(rayDirection);\n    \n    vec3 col = vec3(0);\n    \n    //Optimisation - bounding cylinder\n    vec3 toCamera = normalize(vec3(cameraCenter.x, 0.0, cameraCenter.z));\n    vec3 r = cross(toCamera, vec3(0, 1, 0));\n    vec3 f = r * DROP_RADIUS * 0.57;\n    float cosAlpha = dot(-toCamera, normalize(f - vec3(cameraCenter.x, 0.0, cameraCenter.z)));\n    \n    if(dot(-toCamera, normalize(vec3(rayDirection.x, 0, rayDirection.z))) > cosAlpha)\n    {\n        vec3 rayStartDirection = rayDirection;\n        vec3 resultNormal = vec3(0);\n        vec3 resultPoint = vec3(0);\n        \n        //marching to drop\n        float dist = dropMarch(rayStart, rayDirection, beat, resultPoint, resultNormal);\n        \n        //1 - drop hit, 0 - no hit\n        float drop = smoothstep(0.4, 0.0, abs(dist));\n        \n        if (drop > 0.1)\n        {\n            //Environment reflections on surface\n            vec3 reflectVec = reflect(rayDirection, resultNormal);\n            vec3 reflections = texture(iChannel1, reflectVec).rgb * smoothstep(0.4, 0.0, abs(dist)) * REFLECTIONS;\n            reflections = reflections * (1.0 - dot(-rayDirection, resultNormal));\n            col += reflections * drop * (1.0 + beat);\n\n            //Spherical lighting\n            vec3 sphereLight = texture(iChannel1, resultNormal, 4.0).rgb;\n            col += sphereLight * DROP_BRIGHTNESS * drop * (1.0 + beat);\n\n            //refractionVec\n            rayDirection = mix(rayDirection, refract(rayDirection, resultNormal, 1.0 / REFRACTIVE_INDEX), drop);\n\n            //marching inside the drop (I don't know how to make it properly, just experimenting)\n            vec3 offsetVec = rayDirection * EPSILON * 15.0;\n            dist = dropMarchInside(resultPoint + offsetVec, rayDirection, beat, resultPoint, resultNormal);\n\n            rayDirection = mix(rayDirection, refract(rayDirection, resultNormal, REFRACTIVE_INDEX), drop); \n        }\n\n        col += texture(iChannel1, rayDirection).rgb * drop;\n        col += texture(iChannel1, rayStartDirection).rgb * (1.0 - drop);\n    }\n    else col = texture(iChannel1, rayDirection).rgb;// * 0.0;\n    \n    //Some postprocess\n   \tcol = smoothstep(-0.05, 1.1, col);\n    \n    fragColor = vec4(col, 1.0);\n    \n}","name":"Image","description":"","type":"image"}]}