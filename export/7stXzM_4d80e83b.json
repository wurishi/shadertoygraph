{"ver":"0.1","info":{"id":"7stXzM","date":"1632898456","viewed":55,"name":"RayMarch_learning","username":"hail","description":"刚开始学RayMarch，记录一下(","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define Max_Steps 100\n#define Max_Dist 100.0\n\nfloat SphereDis(vec3 p){\n    //定义一个球型,坐标在(0,1,6)\n    vec4 sphere = vec4(1, 1, 4, 1);\n    sphere.x += sin(iTime) * 2.0;\n    //计算点p到球的距离\n    float sphereDis = length(p - sphere.xyz) - sphere.w;\n    return sphereDis;\n}\n//b是box尺寸\nfloat BoxDis(vec3 p, vec3 b){\n    //设定box的坐标\n    p -= vec3(-2, 1, 4);\n    //计算p到box距离\n    vec3 q = abs(p) - b;\n    float boxDis = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n    return boxDis;\n}\n\n//光滑混合\nfloat opSmoothUnion(float d1, float d2, float k){\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat GetDis(vec3 p){\n    float sphereDis = SphereDis(p);\n    float boxDis = BoxDis(p, vec3(1, 1, 1));\n    //融合\n    float combine = opSmoothUnion(sphereDis, boxDis, 0.8);\n\n    float dis = min(combine, p.y);\n    dis = min(dis, boxDis);\n    return dis;\n}\n\nvec3 GetNormal(vec3 p){\n    float d = GetDis(p);\n    //通过偏移量计算normal\n    vec3 n = d - vec3(GetDis(p - vec3(0.01, 0, 0)),\n                      GetDis(p - vec3(0, 0.01, 0)),\n                      GetDis(p - vec3(0, 0, 0.01)));\n    return normalize(n);\n}\n\nfloat RayMarch(vec3 ro, vec3 rDir){\n    float stepDis = 0.0;\n    //Max_Steps是设定的最大步进次数\n    for(int i=0; i<Max_Steps; i++){\n        // p 点为步进后的坐标\n        vec3 p = ro + rDir * stepDis;\n        //GetDis获取离p点最近的物体的距离(稍后实现这个函数)\n        float tempDis = GetDis(p);\n        stepDis += tempDis;\n        if(tempDis < 0.01 || stepDis > Max_Dist)\n            break;\n    }\n    return stepDis;\n}\n\nfloat GetDiff(vec3 p){\n    vec3 lPos = vec3(3, 8, 3);\n    //\n    lPos.xz += vec2(sin(iTime), cos(iTime)) * 3.0;\n\n    vec3 lDir = normalize(lPos - p);  \n    vec3 n = GetNormal(p);\n\n    float diff = clamp(dot(n, lDir), 0.0, 1.0);\n\n    //shadow\n    float p2lDis = RayMarch(p + n * 0.02, lDir);\n    if(p2lDis < length(lPos - p))\n        diff *= 0.1;\n    \n    return diff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    //把uv坐标限制到(-1,1)\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n    //ro是摄像机坐标\n    vec3 ro = vec3(0, 1, 0);\n    //rDir是摄像机到每个像素点的方向向量\n    vec3 rDir = normalize(vec3(uv.x, uv.y, 1));\n    \n    float d = RayMarch(ro, rDir);\n    vec3 p = ro + d * rDir;\n    float diff = GetDiff(p);\n\n    vec3 col = vec3(diff);\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}