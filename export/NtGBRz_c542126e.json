{"ver":"0.1","info":{"id":"NtGBRz","date":"1663883627","viewed":155,"name":"random repetition (slow)","username":"jt","description":"Experimenting with random objects in a grid (no voxels, just repetition SDF), unfortunately very slow.\nSuggestions for improvement are welcome.\n(A test using a voxel grid to accelerate rendering: [url=https://www.shadertoy.com/view/flyfRz]here[/url].)","likes":7,"published":1,"flags":0,"usePreview":0,"tags":["grid","random","repetition"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// https://www.shadertoy.com/view/NtGBRz random repetition (slow) by jt\n\n// Experimenting with random objects in a grid (no voxels, just repetition SDF), unfortunately very slow.\n\n#define EPSILON 0.001\n#define DIST_MAX 50.0\n\nvec3 hash31(float p) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n    vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat hash13(vec3 p3) // https://www.shadertoy.com/view/4djSRW Hash without Sine by Dave_Hoskins\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// https://www.shadertoy.com/view/WttXWX \"Best\" Integer Hash by FabriceNeyret2\n// implementing Chris Wellons https://nullprogram.com/blog/2018/07/31/\nuint triple32(uint x)\n{\n    x ^= x >> 17;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15;\n    x *= 0x31848babU;\n    x ^= x >> 14;\n    return x;\n}\n\nfloat hash(uint x)\n{\n    return float(triple32(x)) / float(0xffffffffU);\n}\n\nuint hashi(uvec2 v)\n{\n    return triple32(v.x + triple32(v.y));\n}\n\nuint hashi(uvec3 v)\n{\n    return triple32(v.x + triple32(v.y + triple32(v.z)));\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBoxFrame( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n// Create multiple copies of an object - https://iquilezles.org/articles/distfunctions\nvec3 opRepLim( in vec3 p, in float c, in vec3 lima, in vec3 limb )\n{\n    return p-c*clamp(round(p/c),lima,limb);\n}\n\n// Create infinite copies of an object -  https://iquilezles.org/articles/distfunctions\nvec3 opRep(in vec3 p)\n{\n    return p - 2.0*round(p/2.0);\n}\n\nivec3 opRepIdx(in vec3 p)\n{\n    return ivec3(floor((p + 1.0) / 2.0));\n}\n\nuint opRepIdxRnd(in vec3 p)\n{\n    //return hashi(uvec3(opRepIdx(p)));\n    return uint(255.0 * hash13(vec3(opRepIdx(p))));\n}\n\nfloat halfspace(vec3 p, float d)\n{\n    return p.z - d;\n}\n\n// testing blackle's approach\n// https://www.youtube.com/watch?v=I8fmkLK1OKg \"Perfect Pistons in Shadertoy\" Blackle Mori\nvec3 face(vec3 p) // face towards nearest neighbor cell\n{\n    vec3 p2 = abs(p);\n    if(p2.x > p2.y && p2.x > p2.z) return vec3(p.x < 0.0 ? -1.0 : +1.0, 0, 0);\n    if(p2.y > p2.z) return vec3(0, sign(p.y < 0.0 ? -1.0 : +1.0), 0);\n    return vec3(0, 0, sign(p.z < 0.0 ? -1.0 : +1.0));\n    //if(p2.x > p2.y && p2.x > p2.z) return vec3(sign(p.x), 0, 0);\n    //if(p2.y > p2.z) return vec3(0, sign(p.y), 0);\n    //return vec3(0, 0, sign(p.z));\n}\n\nvec3 center(vec3 p)\n{\n    // unfortunately the grid definition here differs from blackle's - could be a source of errors\n    return 2.0 * round(p / 2.0);\n}\n\nfloat shape(uint idx, vec3 r)\n{\n    float d = DIST_MAX;\n\n    if((idx & 63u) == 0u)\n        d = min(d, sdBox(r, vec3(1)));\n    else if((idx & 63u) == 1u)\n        d = min(d, sdSphere(r, 1.0));\n    else if((idx & 63u) == 2u)\n        d = min(d, sdBoxFrame(r, vec3(1.0), 0.05));\n    else\n        d = min(d, 1.0); // minimal distance to cross empty cube\n    \n    return d;\n}\n/*\nfloat structure(vec3 p, ivec3 s)\n{\n    vec3 c = center(p);\n    vec3 neighbor = c + face(p - c);\n\n    uint idx = opRepIdxRnd(p);\n    float me = shape(idx, p - c);\n    //float next = sdBox(p - neighbor, vec3(1)); // overestimate sdf to be sure\n    //return min(me, next); // black screen - I'm doing something wrong...\n    //return me;\n    \n}\n*/\n\n//#define TEST\n\n#ifdef TEST\n// Slow-down ray near faces of voxel\n// to prevent overshooting into neighbor.\n// Works, but results in artifacts in AO\n// and WORSE performance due to increased number of steps.\nfloat structure(vec3 p, ivec3 s)\n{\n    //vec3 r = opRepLim(p, 2.0, vec3(-s), vec3(+s)); // TODO\n    vec3 r = opRep(p);\n    uint idx = opRepIdxRnd(p);\n    float d = shape(idx, r);\n    //return d;\n    float guard = -sdBox(r, vec3(1.0+EPSILON)); // overestimate sdf to be sure (slow-down ray near borders of voxel)\n    return min(d, guard); // TODO: omit guard if neighbor voxel is empty.\n}\n#else\nfloat structure(vec3 p, ivec3 s)\n{\n    //vec3 r = opRepLim(p, 2.0, vec3(-s), vec3(+s)); // TODO\n    vec3 r = opRep(p);\n\n    float d = DIST_MAX;\n\n    // naive method: traverse 3x3x3 tiles\n    //for(int w = -1; w <= +1; w++)\n    //{\n    //    for(int v = -1; v <= +1; v++)\n    //    {\n    //        for(int u = -1; u <= +1; u++)\n    //        {\n    // kastorp's optimization: traverse only 2x2x2 tiles (instead of 3x3x3),\n    // chosen depending on where in the tile the current point is located.\n    ivec3 oo = -ivec3(step(vec3(0), r));\n    for(int w = oo.z; w <= oo.z+1; w++)\n    {\n        for(int v = oo.y; v <= oo.y+1; v++)\n        {\n            for(int u = oo.x; u <= oo.x+1; u++)\n            {\n                vec3 o = 2.0 * vec3(u, v, w); // offset\n                uint idx = opRepIdxRnd(p - o);\n                d = min(d, shape(idx, r + o));\n            }\n        }\n    }\n    \n    return d;\n}\n#endif\nfloat map(vec3 p)\n{\n    ivec3 s = ivec3(3, 2, 0);\n    //ivec3 s = ivec3(floor(3.0 * hash31(floor(iTime))));\n    return\n        //min\n        (\n            structure(p + vec3(0,0,-1-2*s.z), s)//,\n            //halfspace(p, 0.0)\n        );\n}\n\n// https://iquilezles.org/articles/normalsSDF tetrahedron normals\nvec3 normal(vec3 p)\n{\n    const float h = EPSILON;\n    const vec2 k = vec2(1,-1);\n    return\n        normalize\n        (\n            k.xyy * map(p + k.xyy*h)\n            +\n            k.yyx * map(p + k.yyx*h)\n            +\n            k.yxy * map(p + k.yxy*h)\n            +\n            k.xxx * map(p + k.xxx*h)\n        );\n}\n\nfloat trace(vec3 ro, vec3 rd)\n{\n    for(float t = 0.0; t < DIST_MAX;)\n    {\n        float h = map(ro + rd * t);\n        if(h < EPSILON)\n            return t;\n        t += h;\n    }\n    return DIST_MAX;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<EPSILON )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\n// https://www.shadertoy.com/view/Xds3zN raymarching primitives\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor );\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) ;\n}\n\n#define pi 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ndc = 2.0 * uv - 1.0;\n    ndc.x *= float(iResolution.x) / float(iResolution.y);\n    float mx = 2.0 * pi * float(iMouse.x) / float(iResolution.x);\n    float my = pi / 2.0 + pi / 2.0 * float(iMouse.y) / float(iResolution.y);\n    mx = (iMouse.x > 10.0) ? mx : 2.0 * pi * (fract(iTime * 0.01) - 0.25);\n    my = (iMouse.y > 10.0) ? my : pi * 2.5 / 4.0;;\n\n    mat2 R = mat2(vec2(cos(mx), sin(mx)), vec2(-sin(mx), cos(mx)));\n    vec3 ro = vec3(0.0, 0.0,-15.0);\n    mat2 S = mat2(vec2(cos(my), sin(my)), vec2(-sin(my), cos(my)));\n    ro.yz=S*ro.yz;\n    ro.xy = R * ro.xy;\n\n    vec3 rd = normalize(vec3(0.5 * ndc.xy, 1.0)); // NOTE: omitting normalization results in clipped edges artifact\n    rd.yz=S*rd.yz;\n    rd.xy = R * rd.xy;\n\n    float dist = trace(ro, rd);\n    vec3 dst = ro + rd * dist;\n    vec3 n = normal(dst);\n\n    vec3 lightdir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 ambient = vec3(0.2);\n    float brightness = max(dot(lightdir, n), 0.0);\n    brightness *= shadow(ro+rd*dist,lightdir, 0.01, DIST_MAX); // XXX artifacts on cylinder XXX\n    vec3 color = vec3(1.0);\n    color *= (n * 0.5 + 0.5);\n    color = (ambient * calcAO(dst, n) + brightness) * color;\n\n    fragColor = mix(vec4(color, 1.0), vec4(0.0), step(DIST_MAX, dist));\n    fragColor = sqrt(fragColor); // approximate gamma\n}\n","name":"Image","description":"","type":"image"}]}