{"ver":"0.1","info":{"id":"4sjfzz","date":"1499245869","viewed":286,"name":"Rough Crystal Ball","username":"Ultraviolet","description":"Continuation of https://www.shadertoy.com/view/4s2BRz\nUse the mouse to change roughness scale and intensity.","likes":11,"published":1,"flags":0,"usePreview":0,"tags":["sphere","glass"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define GAMMA 2.2\n\n#define MAX_DEPTH 5\n\nvec3 spherePosition = vec3(0.0);\nfloat sphereRadius = 1.0;\nvec3 glassColor = vec3(147.0,112.0,219.0)/255.0;\n\n// see: https://en.wikipedia.org/wiki/Fresnel_equations\nfloat fresnel(vec3 i, vec3 r, vec3 n, float eta1, float eta2)\n{\n    float a0 = eta2 * dot(-i, n);\n    float a1 = eta1 * dot(r, -n);\n    float Rs = (a0-a1)/(a0+a1);\n    Rs = Rs*Rs;\n    \n    float b0 = eta2 * dot(r, -n);\n    float b1 = eta1 * dot(-i, n);\n    float Rp = (b0-b1)/(b0+b1);\n    Rp = Rp*Rp;\n    \n    float R = 0.5*(Rs+Rp);\n    \n    //return Rs;\n    return Rp;\n    //return R;\n}\n\n\nbool getRayIntersection(vec3 ro, vec3 rd, out vec3 inter)\n{    \n    float delta = pow(dot(rd, ro) - dot(spherePosition,rd), 2.0) - (dot(spherePosition, spherePosition)+dot(ro,ro)-2.*dot(spherePosition, ro)-sphereRadius*sphereRadius);\n    \n    if(delta < 0.0)\n    \treturn false;\n    delta = sqrt(delta);\n    float t1 = dot(spherePosition, rd) - dot(rd, ro) - delta;\n    float t2 = dot(spherePosition, rd) - dot(rd, ro) + delta;\n    \n    float t = t1 > 0.0 ? t1 : t2;\n    \n    \n    inter = ro + t*rd;\n    \n    return true;\n}\n\n\nvec3 getNormal(vec3 hitPoint)\n{\n    return normalize(hitPoint - spherePosition);\n}\n\nvec3 getRayDirection(vec2 screenPosition, vec3 origin, vec3 lookingAt, vec3 up, float fov)\n{\n    vec3 d = normalize(lookingAt - origin);\n    vec3 right = normalize(cross(d, up));\n    \n    return normalize(screenPosition.x * right + screenPosition.y * up + 1.0 / tan(radians(fov / 2.0)) * d);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n    \n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = texture( iChannel1, (uv+ 0.5)/256.0).yx;\n    \n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\n\nvec3 roughNormal(vec3 n, vec3 p, float coef)\n{\n    vec3 disp = vec3(noise(p), noise(p.yzx), noise(p.zxy));\n    return normalize(n + coef*disp);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float freq = 0.15;\n    vec3 cameraPosition = 2.0 * vec3(cos(iTime*freq), 0.0, sin(iTime*freq));\n    vec3 cameraUp = vec3(0.0, 1.0, 0.0);\n    vec3 cameraLookingAt = vec3(0.0);\n    \n    vec3 color = vec3(0.0);\n    \n    float aa_level = 15.0;\n    float numRays = aa_level*aa_level;\n    \n    \n    float absorbtion = .2;\n    float eta1 = 1.0;\n    float eta2 = 1.9;\n    \n    float roughCoef = iMouse.y/iResolution.y * 0.7;\n    float roughScale = pow(10.0, iMouse.x/iResolution.x*3.5);\n    \n    if(iMouse.y < 1.0)\n        roughCoef = 0.5 + 0.5*sin(iTime);\n    if(iMouse.x < 1.0)\n        roughScale = 1000.0;\n    \n    for (float i = 0.0; i < numRays; i++)\n    {\n        vec2 aa = vec2(i/aa_level, mod(i, aa_level))/aa_level;\n        \n\t\tvec2 position = (2.0 * (fragCoord + aa) - iResolution.xy) / iResolution.y;\n        \n        vec3 rayOrigin = cameraPosition;\n        vec3 rayDirection = getRayDirection(position, cameraPosition, cameraLookingAt, cameraUp, 90.0);\n        \n        vec3 v;\n        \n        vec3 pt;\n        bool inter = getRayIntersection(rayOrigin, rayDirection, pt);\n        if(inter)\n        {\n            vec3 normal = getNormal(pt);\n            normal = roughNormal(normal, pt*roughScale, roughCoef);\n            vec3 reflection = reflect(rayDirection, normal);\n            vec3 refraction = refract(rayDirection, normal, eta1 / eta2);\n            float f = fresnel(rayDirection, refraction, normal, eta1, eta2);\n            //f = 1.0;\n\n        \tvec3 pt2;\n            getRayIntersection(pt + refraction*0.0001, refraction, pt2);\n            \n            vec3 normal2 = getNormal(pt2);\n            normal2 = roughNormal(normal2, pt*roughScale, roughCoef);\n            vec3 refraction2 = refract(refraction, -normal2, eta2 / eta1);\n            \n            \n            v = mix(texture(iChannel0, refraction2).xyz, glassColor, 1.0-exp(-absorbtion * length(pt2-pt)));\n            \n        \tv = mix(v, texture(iChannel0, reflection).xyz, f);\n        }\n        else\n        {\n        \tv = texture(iChannel0, rayDirection).xyz;\n        }\n        \n        color += v / numRays;\n    }\n    \n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}