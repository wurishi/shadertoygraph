{"ver":"0.1","info":{"id":"3slfWH","date":"1588175290","viewed":151,"name":"Cubemap Fake","username":"Smake","description":"Cube mapping/refraction fake, color fake,  nonclamped visibility, DR brightness extent.","likes":1,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","sdf","psychodelic","short","nonclamped"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// it's challenge... )\n// The idea to make the realalistic thihg by min chars :)\n//starting here, thanks to FabriceNeyret2 \n// https://www.shadertoy.com/view/WtVXDW\n/*\nfloat pi = 3.1415926;\nvec3 cmap(float W) {\n    vec3 C;\n    C.x = .5+.5*cos(pi*W);\n    C.y = .5+.5*cos(pi*4.*W);\n    C.z = .5+.5*cos(pi*2.*W);\n    return C;\n  }\n*/\n\nvec3 cmap(float W) {\n    vec3 C = vec3 (W);\n    if (W < .3) C.y=.0; \n    else W < .6 ? C.z=.0 : C.x=.0;\n    return C;\n  }\n\n#define C(q) t = max(t, 2.-length(mod(q.xy+4.,6.)-4.))\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime;\n    mat2  R = mat2( sin(iTime+vec4(0,33,11,0)) );\n    vec3  q = iResolution,\n          D = vec3(.2*(U+U-q.xy)/q.y, -1),     // ray direction\n          p = 5e1/q, a;                        // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .001 ; O-=.0158 )\n        q = p,\n        q.xz *= R, q.yz *= R,                  // rotation\n        t-=t,\n        a = abs(q),  \n        t =  max(max(a.x,a.y),a.z) -4.,// cube \n        \n        q.y -= iTime,\n        C(q.xy),\n        C(q.zy-vec2(0,3)),\n        p += t*D; \n    if (O.x <.02) O-=O;\n    else O =  vec4 ( mod(iTime*cmap(O.x), 1.0), 1.0);\n}\n","name":"Image","description":"","type":"image"}]}