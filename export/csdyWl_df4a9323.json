{"ver":"0.1","info":{"id":"csdyWl","date":"1698661795","viewed":77,"name":"TP Informatique graphique","username":"lea_02010","description":"tp info","likes":2,"published":1,"flags":0,"usePreview":1,"tags":["image"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"# define TAILLE_FILE 3\n\n//------------Définition des structures-----------------//\n\n\nstruct Sphere{\n    vec3 c;// Center\n    float r;// Radius\n    int i;// Texture Id\n};\n\nstruct TN{\n    float t;\n    vec3 n; \n};\n\nstruct Plane{\n    vec3 n;// Normal\n    vec3 p;// Point\n    int i;// Texture Id\n};\n\nstruct Ellipsoide{\n    vec3 center; \n    float a; \n    float b; \n    float c; \n    int i; \n};\n\nstruct CylindreInfini{\n    vec3 a; \n    vec3 dir; \n    float r; \n    int i; \n};\n\nstruct Cylindre{\n    vec3 a; \n    vec3 b;\n    vec3 dir; \n    float r; \n    int i; \n};\n\nstruct Capsule{\n    vec3 a; \n    vec3 b;\n    vec3 dir; \n    float r; \n    int i; \n};\n\nstruct Boite{\n    vec3 a; \n    vec3 b; \n    int i; \n}; \n\nstruct Hit{\n    float t;// Intersection depth\n    vec3 n;// Normal\n    bool inObj; //permet de savoir si on est dans l'objet ou pas\n    int i;// Texture Id\n};\n\nstruct Ray{\n    vec3 o;// Origin\n    vec3 d;// Direction\n};\n\nstruct Material\n{\n    vec3 ca; //couleur ambiant\n    vec3 cd;// Diffuse\n    vec3 cs; //specular\n    float a; //coef ambiant\n    float d; //coef diffus\n    float s; // coef speculaire\n    float e; //la puissance de la fct speculaire\n    float refl; //taux de reflexion du materiel\n    float refr; // taux de réfraction du matériel \n    float trans; // taux de transparence du matériel\n};\n\nstruct File{\n    Ray rayon; // rayon\n    float cd; //couleur encore dispo \n};\n\n\n\n//--------Définition de petites fonction utiles pour la suite --------//\n\n// Calcul de l'équation d'une sphère \n// Renvoie la distance a laquelle se trouve la sphère \n// Renvoie -1 si pas de sol\n// ray : Rayon\n// sph : Sphere \nfloat EquationSphere (in Ray ray, in Sphere sph){\n    vec3 oc=ray.o-sph.c;\n    float b=dot(oc,ray.d);\n    float c=dot(oc,oc)-sph.r*sph.r;\n    float d=b*b-c;\n    if(d>0.)\n    {\n        return -b-sqrt(d);\n    }\n    else return -1.;\n}\n\n// Renvoie la distance entre ray et le plan passant par p et de normal n\n// ray : Rayon\n// p : Point\n// n : Normal\nfloat DistancePlan (in Ray ray, in vec3 p, in vec3 n){\n    return -dot(ray.o-p,n)/dot(ray.d,n);\n}\n\n// Calcul de l'équation d'une demi sphère \n// Renvoie la distance a laquelle se trouve la demi sphère \n// Renvoie -1 si pas de sol\n// ray : Rayon\n// sph : Sphere \n// n : Normal du plan de la demi sphere\nfloat EquationDemiSphere(in Ray ray, in Sphere sph, in vec3 n){\n    float tp=DistancePlan(ray, sph.c, n);\n    \n    float ts=EquationSphere(ray,sph);\n    \n    if (ts>0.){\n        float angle = dot(ray.d,n)/(length(ray.d)*length(n));\n        if (angle > 0.){\n            if (tp<ts){\n                return -1.;\n            }else{\n                return ts;\n            }\n        }\n        else if (angle<0.){\n            if (tp<ts){\n                return ts;\n            }\n        }\n        else{\n            return -1.;\n        }\n    }\n    return -1.;\n}\n\n// Calcul de l'équation d'une ellipse \n// Renvoie la distance a laquelle se trouve l'ellipsoide \n// Renvoie -1 si pas de sol\n// ray : Rayon\n// e : vecteur qui contient les paramètre de l'ellipsoide \nfloat EquationEllipse (in Ray ray, in vec3 e,in vec3 center, out float tmax){\n    vec3 oc=ray.o-center;\n    \n    float a = dot (ray.d/e, ray.d/e);\n    float b = 2.*dot (ray.d/e, oc/e); \n    float c = dot (oc/e, oc/e)-1.; \n    \n    float delta = b*b-4.*a*c;\n    if (delta > 0.){\n        tmax = max((-b-sqrt(delta))/(2.*a), (-b+sqrt(delta))/(2.*a)); \n        return min ((-b-sqrt(delta))/(2.*a), (-b+sqrt(delta))/(2.*a));\n    }\n    else return -1.;\n}\n\n// Calcul de l'équation d'un cylindre Infini \n// Renvoie la distance a laquelle se trouve le cylindre \n// Renvoie -1 si pas de sol\n// ray : Rayon\n// cyl : CylindreInfini \nvoid EquationCylindre (in Ray ray, in CylindreInfini cyl, out float tcmoins, out float tcplus){\n    vec3 oa = ray.o-cyl.a;\n    float a = dot(ray.d,ray.d)-(dot(ray.d, cyl.dir))*(dot(ray.d, cyl.dir));\n    float b = 2.*( dot(oa,ray.d)-dot(oa, cyl.dir)*dot(ray.d,cyl.dir)); \n    float c = dot(oa,oa)-dot(oa, cyl.dir)*dot(oa, cyl.dir)-cyl.r*cyl.r; \n    \n    float delta = b*b-4.*a*c; \n    \n    if (delta > 0.){\n        if ((-b-sqrt(delta))/(2.*a)<(-b+sqrt(delta))/(2.*a)){\n            tcmoins = (-b-sqrt(delta))/(2.*a);\n            tcplus = (-b+sqrt(delta))/(2.*a); \n        }else {\n            tcmoins = (-b+sqrt(delta))/(2.*a); \n            tcplus = (-b-sqrt(delta))/(2.*a); \n        }\n    }\n    else {\n        tcmoins = tcplus = -1.;\n    }\n}\n\n// Permet de renvoyer la distance la plus courte et la normal correspondant au plan d'intersection\n// entre 2 plan parallèle mais avec une normal opposé\n// cette fonction est utilisé pour la définition de la boite \n// ray : Rayon\n// a : point avec les coordonnées minimum de la boite\n// b : point avec les coordonnées maximum de la boite\n// n : normal du plan qu'on va regarder\n// tplus : renvoie la plus grande distance entre l'intersection des 2 plans\nTN DistancePlan (Ray ray, vec3 a, vec3 b,vec3 n, out float tplus){\n    float tmoins;\n    // définition de t- et t+\n    float tb=-dot(ray.o-b,n)/dot(ray.d,n);\n    float ta=-dot(ray.o-a,-n)/dot(ray.d,-n);\n    \n    if (ta < tb){\n        tmoins = ta;\n        tplus = tb;\n        return TN(tmoins, -n); \n    }else {\n        tmoins = tb;\n        tplus = ta;\n        return TN(tmoins, n); \n    }\n}\n\n// Permet de trouver la distance la plus grande entre deux \n// distance et des renvoyer la normale associé\nTN maxi (TN x,TN y){ \n    if (x.t<y.t){\n        return y;\n    }\n    else{\n        return x;\n    }\n}\n\n// Fonction qui permet de renvoyer 0 ou 1 en fonction de la position de p et du paramètre \n// p : Point\n// n : Normal\n// param : Paramètre (utile pour la fonction du damier\nint Checker (in vec3 p, in vec3 n, in float param){\n  // Calcul de p1 en fonction de p de sa normal et du paramètre \n  vec3 p1 = floor(p*(1./param)+n*0.0001);\n  \n  // Calcul des parties entière des coordonnées de p1 puis on fais le modulo pour obtenir \n  // 0 ou 1 en fonction de p\n  return (int(p1.x)+ int(p1.y)+int(p1.z)) % 2;\n}\n\n// détermine la distance du vec(x,y) à l'axe axe z\n// x,y,z : float\nfloat Axial (in float x ,in float y ,in float z ) {\n    float r = sqrt ( x * x + y *y );\n    return 0.5 + 0.5 * cos (3.1415927 * r ) ;\n}\n\n// détermine la distance du vecteur p au point c\n// p : Point\n// c : centre\nfloat Center (in vec3 p, in vec3 c) {\n    vec3 pc = p-c;\n    return sqrt(pc.x*pc.x + pc.y*pc.y + pc.z*pc.z);\n}\n\n// Hashing function\n// Returns a random number in [-1,1]\n// p : Vector in space\n// Fonction récupéré du tp de lifgraphique\nfloat Hash(in vec3 p)  \n{\n    p  = fract( p*0.3199+0.152 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\n// Procedural value noise with cubic interpolation\n// x : Point \n// Fonction de bruit récupéré du tp de lifgraphique\nfloat Noise(in vec3 p)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n  \n    f = f*f*(3.0-2.0*f);\n    // Could use quintic interpolation instead of cubic\n    // f = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    return mix(mix(mix( Hash(i+vec3(0,0,0)), \n                        Hash(i+vec3(1,0,0)),f.x),\n                   mix( Hash(i+vec3(0,1,0)), \n                        Hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( Hash(i+vec3(0,0,1)), \n                        Hash(i+vec3(1,0,1)),f.x),\n                   mix( Hash(i+vec3(0,1,1)), \n                        Hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n \n// Fonction de bruit récupéré du tp de lifgraphique\nvec3 Noise3D (vec3 p)\n{\n    return vec3(Noise (p+vec3(1., 17., 36.)),\n                Noise (p+vec3(78., -4., -26.)),\n                Noise (p+vec3(-0.5, 8., -15.)));\n}\n\n// Fonction de turbulance\n// p : Point\n// octave : + il est grand plus il y a de turbulance\n// a : amplitude de la turbulance\n// l : longueur d'onde de la turbulance\n// r : rotation\nvec3 Turbulance (in vec3 p, in int octave, in float a, in float l, in float r){\n    vec3 t = vec3(0.);\n    for (int k=0; k<octave; k++){\n        float ak = a*(pow(2., float(-k)));\n        float rk = pow (r, float(-k));\n        float lk = l*pow(2.,float(-k));\n        t+= ak*Noise3D((rk*p)/lk);\n    }\n    return t;\n}\n\nfloat Checkers(in vec2 p)\n{\n    // Filter kernel\n    vec2 w=fwidth(p)+.001;\n    // Box box filter\n    vec2 i=2.*(abs(fract((p-.5*w)*.5)-.5)-abs(fract((p+.5*w)*.5)-.5))/w;\n    // xor pattern\n    return.5-.5*i.x*i.y;\n}\n\n// Compute point on ray\nvec3 Point(Ray ray,float t)\n{\n    return ray.o+t*ray.d;\n}\n\n\n\n//---------- Définition des opérateurs de transformations -----------//\n\n\n\n// Translation autour de l'axe définit par t \n// p : Point\n// t : vecteur de translation\nvec3 translation (vec3 p, vec3 t)\n{\n    return vec3(p+t);\n}\n\n// Rotation sur l'axe des x\n// p : Point \n// r : Angle en radian de la rotation\nvec3 rotationX ( vec3 p, float r) \n{\n    mat3 rot = mat3(1.0,  0.0,    0.0,\n                    0.0, cos(r), -sin(r),\n                    0.0, sin(r), cos(r));\n    return rot*p;\n}\n\n// Rotation sur l'axe des z\n// p : Point \n// r : Angle en radian de la rotation\nvec3 rotationZ ( vec3 p, float r) \n{\n    mat3 rot = mat3(cos(r), -sin(r),0.,\n                    sin(r), cos(r), 0.,\n                    0.,0.,1.);\n    return rot*p;\n}\n\nfloat homothetie (float r, float coef){\n    return r*coef; \n}\n\nvec3 homothetie (vec3 dep, vec3 arr, float coef){\n    arr = translation(arr, -dep);\n    arr = arr*coef; \n    arr = translation(arr, dep);\n    return arr;\n}\n\nCapsule homothetie (Capsule c, float coef){\n    c.b = homothetie(c.a, c.b, coef); \n    c.r = homothetie(c.r, coef);\n    return c;\n}\n\nCylindre homothetie (Cylindre c, float coef){\n    c.b = homothetie(c.a, c.b, coef); \n    c.r = homothetie(c.r, coef);\n    return c;\n}\n\nBoite homothetie (Boite b, float coef){\n    b.b = homothetie(b.a, b.b, coef); \n    return b;\n}\n\nEllipsoide homothetie (Ellipsoide e, float coef){\n    e.a = homothetie(e.a, coef);\n    e.b = homothetie(e.b, coef);\n    e.c = homothetie(e.c, coef);\n    return e;\n}\n\nSphere homothetie (Sphere s, float coef){\n    s.r = homothetie(s.r, coef);\n    return s; \n}\n\n\n\n//-------------- Définition des différents Materiel -------------//\n\n\n\n// Création d'un matériel uniforme sans reflet speculaire\n// color : permet de changer la couleur ambiante du matériel\nMaterial uniformColorDiffus(vec3 color){\n    return Material( vec3(0.),\n               color,\n               vec3(1., 0.75, 0.31),\n               0.5, 1., 0.2, 28., 0., 1., 0.);\n}\n\n// Création d'un matériel uniforme avec un fort reflet speculaire\n// color : permet de changer la couleur diffuse du matériel\nMaterial uniformColorSpe(vec3 color){\n    return Material( vec3(0.),\n               color,\n               vec3(1., 0.75, 0.31),\n               0.5, .6, .8, 30., 0.2, 1., 0.3);\n}\n\n// Création d'un matériel transparent et qui permet de voir la refraction\n//On peut l'appliquer que sur le cylindre infini pour qu'elle fonctionne\n//sinon on devrait mettre à jour toute nos intersection de toutes les primitives\n// color : permet de changer la couleur diffuse du matériel\nMaterial refractionCylindre(vec3 color){\n    return Material( vec3(0.),\n               color,\n               vec3(1., 0.75, 0.31),\n               0.5, .6, .8, 30., 0., 1.125, 0.8);\n}\n\n// Création d'un matériel type miroir\nMaterial miroir(){\n    return Material( vec3(0.),\n               vec3(0.6),\n               vec3(1., 0.75, 0.31),\n               0.5, .6, 1., 28., .9, 1., 0.);\n}\n\n// Creation du materiel damier qui alterne entre cases diffuses et spéculaires.\n// p : Point\n// n : Normal\n// param : paramètre de la taille du damier \nMaterial Damier(in vec3 p,in vec3 n, in float param)\n{\n  //Définition des textures du damier \n  Material color1 = Material( \n               vec3(0.),\n               vec3(0.8),\n               vec3(1., 0.75, 0.31),\n               0.5, 1.,0., 28.,0., 1., 0.);\n  Material color2 = Material( \n               vec3(0.),\n               vec3(0.),\n               vec3(1., 0.75, 0.31),\n               0.5, 1., 1., 28.,0., 1., 0.);\n                    \n  int check = Checker (p,n,param); \n  \n  // Sépare l'espace en 2 puis donne une texture différente à chaque espace\n  // On peut faire un damier avec plus de deux couleurs en séparant l'espace \n  // plus que deux fois donc en modifiant le modulo\n  if (check%2 == 0) \n    return color2;  \n             \n  else return color1; \n}\n\n//variations de couleur concentriques selon la distance à un axe\n// p : Point\n// param : Paramètre qui détermine si on veut des rayures serré ou pas\nMaterial Rayure (in vec3 p, in float param){\n\n  vec3 p1 = p*param;\n  \n  if(abs(Axial(p1.y,p1.z,p1.x))>=0.5){\n      return uniformColorDiffus(vec3(0.85,0.70,0.45));\n  }\n  return uniformColorDiffus(vec3(0.94, 0.87, 0.73)); \n}\n\n//variations de couleur concentriques selon la distance\n//d’un point à un centre\n// p : Point\n// c : Centre\n// param : Paramètre qui détermine si on veut des rayures serré ou pas\n// plus param est grand plus les rayures sont serré\nMaterial RayureCirculaire (in vec3 p,in vec3 c, in float param){\n               \n  if(int(Center(p,c)*param)%2 ==0){\n      return uniformColorDiffus(vec3(0.6,0.6,1.));\n  }\n  return uniformColorDiffus(vec3(.9,.9,0.8));  \n}\n\n// Materiel qui déforme les rayures circulaires\n// p : Point\nMaterial Deformation (in vec3 p){\n    vec3 p1 =p+ Turbulance (p, 2, 3., 2., 1.);\n    \n    if(int(Center(p1,vec3(0.))*5.)%4 ==0){\n      return uniformColorDiffus(vec3(0.4));\n    }\n    return uniformColorDiffus(vec3(0.8));\n}\n\n// Compute color\n// i : Texture index\n// p : Point\nMaterial Texture(vec3 p,vec3 n,int i)\n{\n    if(i==1)\n    {\n        return uniformColorDiffus(vec3(0.99, 0.8, 0.8));\n    }\n    if(i==2){\n        return Damier(p,n,0.5);\n    }\n    if(i==3){\n        return Rayure(p, 1.);\n    }\n    if(i==4){\n        return RayureCirculaire(p,vec3(0.),15.);\n    }\n    if(i==5){\n        return Deformation(p); \n    }\n    if(i==6)\n    {\n        return uniformColorSpe(vec3(0.7,0.2, 0.5));\n    }\n    if(i==7)\n    {\n        return uniformColorSpe(vec3(0.4,0.9, 0.2));\n    }\n    if(i==8)\n    {\n        return miroir();\n    }\n    if(i==9)\n    {\n        return uniformColorDiffus(vec3(0.4,0.9, 0.2));\n    }\n    if(i==10){\n        return refractionCylindre(vec3(0.7,0.2, 0.5));\n    }\n    else if(i==0)\n    {\n        // compute checkboard\n        /*float f=Checkers(.5*p.xy);\n        vec3 col=vec3(.4,.5,.7)+f*vec3(.1);\n        return Material(col,\n                        vec3(1., 0.75, 0.31),\n                        vec3(0.7, 0.63, 0.52),1.,0.3,0.,28.);*/\n                        \n        //return Damier(p,n,2.);\n        return Deformation(p); \n    }\n    return Material(vec3(.2,.2,.2), \n                    vec3(0.),\n                    vec3(0.7, 0.63, 0.52),1.,1.,1.,28.,0., 0., 0.);\n}\n\n\n\n//------ Définition des intersection avec les différents objets -----//\n\n\n\n// Sphere intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectSphere(Ray ray,Sphere sph,out Hit x)\n{\n    float t = EquationSphere(ray, sph); \n    if(t>0.)\n    {\n        vec3 p=Point(ray,t);\n        x=Hit(t,normalize(p-sph.c),false, sph.i);\n            \n        return true;\n    }\n    return false;\n    \n}\n\n// Intersection de l'ellipsoide\n// ray : Rayon\n// eli : Ellipsoide\n// x : retourne l'information d'intersection\nbool IntersectEllipsoide(Ray ray,Ellipsoide eli, out Hit x)\n{\n    vec3 e = vec3 (eli.a,eli.b,eli.c); \n    float tmax;\n    float t = EquationEllipse(ray, e, eli.center,tmax);\n    \n    if (t>0.){\n        vec3 p=Point(ray,t);\n        x=Hit(t,normalize((p-eli.c)/e*e),false,eli.i);\n        return true;\n    }\n    else if (tmax>0.){\n        vec3 p=Point(ray,tmax);\n        x=Hit(tmax,normalize((p-eli.c)/e*e),true,eli.i);\n        return true;\n    }\n    return false;\n}\n\n// Intersection du cylindre infini\n// ray : Rayon\n// cyl : Cylindre Infini\n// x : retourne l'information d'intersection\nbool IntersectCylindreInfini(Ray ray, CylindreInfini cyl, out Hit x){\n    float tmin;\n    float tmax;\n    EquationCylindre(ray,cyl, tmin, tmax);\n    \n    if (tmin>0.){\n        vec3 p=Point(ray,tmin);\n        vec3 q = cyl.a + (dot (p-cyl.a, cyl.dir))*cyl.dir;\n        x=Hit(tmin,normalize(p-q), false,cyl.i);\n        return true;\n    }else if (tmax>0.) {\n        vec3 p=Point(ray,tmax);\n        vec3 q = cyl.a + (dot (p-cyl.a, cyl.dir))*cyl.dir;\n        x=Hit(tmax,normalize(p-q),true,cyl.i);\n        return true;\n    }\n    \n    return false;\n}\n\n// Intersection du cylindre\n// ray : Rayon\n// cyl : Cylindre\n// x : retourne l'information d'intersection\nbool IntersectCylindre(Ray ray, Cylindre cyl, out Hit x){\n\n    // Plan passant par le point a\n    float ta=DistancePlan(ray, cyl.a, cyl.dir);\n    \n    //Plan passant par b\n    float tb=DistancePlan(ray, cyl.b, cyl.dir);\n    \n    float tcmoins;\n    float tcplus;\n    CylindreInfini c= CylindreInfini(cyl.a,cyl.dir,cyl.r, cyl.i);\n    EquationCylindre(ray,c, tcmoins, tcplus);\n        \n        // cas ou ta = tpmoins et tb = tpplus\n        if (ta<tb){\n            //J'affiche le cylindre\n            if (ta<tcmoins && tcmoins > 0.&& tcmoins < tb){\n                float t = tcmoins; \n                vec3 p=Point(ray,t);\n                vec3 q = cyl.a + (dot (p-cyl.a, cyl.dir))*cyl.dir;\n                x=Hit(t,normalize(p-q),false,cyl.i);\n            \n                return true; \n            }\n            // J'affiche le plan\n            if (ta>tcmoins && ta > 0.&& ta < tcplus){\n                float t = ta; \n                x=Hit(t,vec3(0,0,1),false,cyl.i);\n                return true; \n            }\n        }\n        // cas ou ta = tpplus et tb = tpmoins\n        else{\n            //J'affiche le cylindre\n            if (tb<tcmoins && tcmoins > 0.&& tcmoins < ta){\n                float t = tcmoins; \n                vec3 p=Point(ray,t);\n                vec3 q = cyl.a + (dot (p-cyl.a, cyl.dir))*cyl.dir;\n                x=Hit(t,normalize(p-q),false,cyl.i);\n            \n                return true; \n            }\n            //J'affiche le plan\n            if (tb>tcmoins && tb > 0.&& tb < tcplus){\n                float t = tb; \n                x=Hit(t,vec3(0,0,1),false,cyl.i);\n                return true; \n            }\n        }\n    return false; \n}\n\n// Intersection du capsule\n// ray : Rayon\n// caps : capsule\n// x : retourne l'information d'intersection\nbool IntersectCapsule(Ray ray, Capsule caps, out Hit x){\n    \n    // demi sphere passant par le point a\n    Sphere sphA = Sphere(caps.a, caps.r, caps.i);\n    float ta=EquationDemiSphere(ray, sphA, caps.dir);\n    \n    //demi sphere passant par b\n    Sphere sphB = Sphere(caps.b, caps.r, caps.i);\n    float tb=EquationDemiSphere(ray, sphB, -caps.dir);\n    \n    // Affichage de la demi sphere passant par a\n    if (ta>0.){\n        vec3 p=Point(ray,ta);\n        x=Hit(ta,normalize(p-caps.a), false,caps.i);\n        return true;\n    }else if (tb>0.){ // Affichage de la demi sphere passant par b\n        vec3 p=Point(ray,tb);\n        x=Hit(tb,normalize(p-caps.b), false,caps.i);\n        return true;\n    }else{ // Affichage du cylindre reliant les deux demi sphere\n        Cylindre cyl = Cylindre(caps.a,caps.b, caps.dir,caps.r, caps.i);\n        return IntersectCylindre(ray, cyl, x);\n    }\n    return false;   \n}\n\n// Intersection de la boite\n// ray : Rayon\n// box : Boite\n// x : retourne l'information d'intersection\nbool IntersectBoite(Ray ray,Boite box,out Hit x){\n\n    \n    // définition de tz- et tz+\n    float tzplus;\n    TN z = DistancePlan(ray,box.a,box.b,vec3(0.,0.,1.),tzplus);\n\n    // définition de ty- et ty+\n    float typlus;\n    TN y = DistancePlan(ray,box.a,box.b,vec3(0.,1.,0.),typlus);\n    \n    // définition de tx- et tx+\n    float txplus;\n    TN xx = DistancePlan(ray,box.a,box.b,vec3(1.,0.,0.),txplus);\n    \n    // définition de t- et t+\n    TN tmoins = maxi(maxi (xx,y), z);\n    float tplus = min(min(txplus, typlus), tzplus);\n    \n    if (tmoins.t < tplus && tmoins.t>0.){\n        vec3 p=Point(ray,tmoins.t);\n        x=Hit(tmoins.t,normalize(tmoins.n), false,box.i);\n        return true;\n    }\n    return false; \n}\n\n// Plane intersection\n// ray : The ray\n//   x : Returned intersection information\nbool IntersectPlane(Ray ray,Plane pl,out Hit x)\n{\n    \n    float t = DistancePlan(ray, pl.p, pl.n);\n    if(t>0.)\n    {\n        x=Hit(t,vec3(0,0,1), false,pl.i);\n        return true;\n    }\n    return false;\n}\n\n// Scene intersection\n// ray : The ray\n//   x : Returned intersection information\nbool Intersect(Ray ray,out Hit x)\n{\n/*\n    // Spheres\n    vec3 trans = vec3(cos(2.*iTime), cos(2.*iTime),3.*cos(2.*iTime));\n    float rot = radians(iTime*100.); \n    float coef = abs(cos(2.*iTime))+1.;\n    //vec3 centerrot = rotationZ(vec3(0.,0.,0.), radians(iTime*100.));\n    vec3 center = vec3(1.,1.,1.);\n    //Sphere sph1=Sphere(centerrot,homothetieRayon(1.,cos(2.*iTime)),1);\n    Sphere sph1=Sphere(center,3.,1);\n    Ellipsoide eli1 = Ellipsoide(vec3 (3.,0.,5.),3.,2.,3., 1);\n    const Sphere sph2=Sphere(vec3(2.,0.,2.),1.,1);\n    //const CylindreInfini cyl=CylindreInfini(vec3(0.,0.,0.), vec3(0.,0.,1.), 2., 1);\n    vec3 a = vec3(1.,1.,4.);\n    vec3 b = vec3(5.,3.,7.); \n    vec3 ab = b-a; \n    vec3 u = ab/(sqrt(ab.x*ab.x+ab.y*ab.y+ab.z*ab.z));\n    CylindreInfini cyl=CylindreInfini(a,normalize(vec3(0.,3.,1.)), 1.,1);\n    Cylindre cylindre=Cylindre(a,b,u,1.,1); \n    Capsule caps=Capsule(a,b,u,2.,1);\n    cylindre = homothetie(cylindre, 2.);\n    Boite box= Boite(vec3(1.), vec3(3.), 1);\n    box = homothetie(box, coef);\n    \n    eli1 = homothetie(eli1, coef);\n    */\n    //paramètre pour le cylindre\n    vec3 a = vec3(8.,0.,2.);\n    vec3 b = vec3(8.,0.,7.); \n    vec3 ab = b-a; \n    vec3 dir = ab/length(ab);\n    \n    //paramètre pour la capsule\n    vec3 c = vec3(-8.,0.,2.);\n    vec3 d = vec3(-10.,-3.,4.); \n    vec3 cd = d-c; \n    vec3 dire = cd/length(cd);\n    \n    //vec3 trans = vec3(0., 0.,3.*cos(iTime));\n    \n    Boite box= Boite(vec3(-10.,-10.,-1.), vec3(10., 10.,0.), 1);\n    Boite box2= Boite(vec3(-10.,-9.,0.), vec3(-9., 10.,10.), 1);\n    Boite box3= Boite(vec3(-3.,-3.,1.), vec3(3., 3.,4.), 1);\n    Sphere sph=Sphere(vec3(-6.,0.,4.),3.,8);\n    Sphere sph2=Sphere(vec3(-3.,0.,4.),2.,1);\n    Sphere sph3=Sphere(vec3(0.,2.,4.),2.,7);\n    Sphere sph4=Sphere(vec3(7.,0.,4.),3.,8);\n    Ellipsoide eli = Ellipsoide(vec3 (-1.,-1.,4.),1.5,3.,2., 9);\n    const CylindreInfini cylInf=CylindreInfini(vec3(4.,-4.,0.), normalize(vec3(-0.,0.,1.)), 2., 10);\n    Cylindre cylindre=Cylindre(a,b,dir,2.,9);\n    Capsule caps=Capsule(c,d,dire,.5,9);\n    //const Plane pl=Plane(vec3(0.,0.,1.),vec3(0.,0.,0.),1);\n    //Sphere sph=Sphere(vec3(0.,-7.,4.),6.,6);\n    //Sphere sph2=Sphere(vec3(5.,0.,4.),2.,7);\n    //Ellipsoide eli = Ellipsoide(vec3 (4.,0.,5.),1.5,1.5,2., 8);\n    //const CylindreInfini cylInf=CylindreInfini(vec3(-7.,0.,0.), normalize(vec3(-7.,-0.8,1.)), 1., 5);\n    //Cylindre cylindre=Cylindre(a,b,dir,2.,7);\n    //Capsule caps=Capsule(c,d,dire,.5,1);\n    //Boite box= Boite(vec3(-2.,-4.,0.), vec3(2., 0.,4.), 6);\n    //Sphere sph3=Sphere(vec3(0.,10.,1.),1.5,8);\n    \n    x=Hit(1000.,vec3(0), false,-1);\n    Hit current;\n    bool ret=false;\n    /*\n    if(IntersectPlane(ray,pl,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }*/\n    //rotation sur le rayon enfaite on peut tout faire dessus\n    if(IntersectSphere(ray,sph,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    /*if(IntersectSphere(ray,homothetie(sph2, 0.5),current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }*/\n    if(IntersectSphere(ray,sph3,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectSphere(ray,sph4,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }/*\n    if(IntersectSphere(ray,sph3,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectEllipsoide(ray,eli,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylindreInfini(ray,cylInf,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCylindre(ray,cylindre,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectCapsule(ray,caps,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }*/\n    if(IntersectBoite(ray,box,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }\n    if(IntersectBoite(ray,box2,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }/*\n    if(IntersectBoite(ray,box3,current)&&current.t<x.t){\n        x=current;\n        ret=true;\n    }*/\n    \n    return ret;\n}\n\nvec3 Background(vec3 rd)\n{\n    return mix(vec3(.3),vec3(.6),-rd.x);\n    //return vec3(0.8);\n}\n\n\n\n//------ Définition des fonctions nécessaire à l'affichage et --------//\n//------------------- au calucul de la lumière ----------------------//\n\n\n\n// Camera rotation matrix\n// ro : Camera origin\n// ta : Target point\nmat3 setCamera(in vec3 ro,in vec3 ta)\n{\n    vec3 cw=normalize(ta-ro);\n    vec3 cp=vec3(0,0,1);\n    vec3 cu=-normalize(cross(cw,cp));\n    vec3 cv=-normalize(cross(cu,cw));\n    return mat3(cu,cv,cw);\n}\n\n// Hemisphere direction\n\nvec3 Hemisphere(int seed,vec3 n)\n{\n    float a=fract(sin(176.19*float(seed)));// Uniform randoms\n    float b=fract(sin(164.19*float(seed)));\n\n    float u=2.*3.1415*a;// Random angle\n    float v=acos(2.*b-1.);// Arcosine distribution to compensate for poles\n\n    vec3 d=vec3(cos(u)*cos(v),sin(u)*cos(v),sin(v));// Direction\n\n    if(dot(d,n)<0.){d=-d;}// Hemishpere\n\n    return d;\n}\n\n// Ambient occlusion\n// p : Point\n// n : Normal\n// N : Number of samples\nfloat AmbientOcclusion(vec3 p,vec3 n,int N, float R)\n{\n    if(N==0){return 1.;}\n    float oa=0.;\n   \n    for(int i=0;i<N;i++)\n    {\n        vec3 d= Hemisphere (i,n); // d dans la demi-sphere\n        Ray ray = Ray(p, d); \n        Hit x;\n        if (!Intersect(ray,x)){\n            //pas d'intersection lumière peut arriver\n            n++;\n        }\n        else {\n            if(x.t>R){\n                n++;\n            }\n        \n        }\n    }\n    oa = float(n)/float(N); \n    return oa;     \n}\n\nvec3 computeLight (Material m, vec3 light,vec3 n, vec3 rd, vec3 p){\n    Hit x;\n    // Ambient color\n    vec3 ambient = m.a*m.ca; // 0.5 = a\n    if (!Intersect (Ray (p+n*0.01,light),x)){\n        // Ambient Occlusion\n        float occ = AmbientOcclusion(p+n*0.001,n,100, 1.);\n    \n        // Phong diffuse\n        vec3 diffuse = m.d  * clamp(dot(n, light),0.0,1.0) * m.cd;\n\n        // Specular\n        vec3 r = reflect(rd,n);\n        vec3 specular = m.cs * m.s * pow(clamp(dot(r,light),0.0,1.0),m.e);\n        vec3 c = ambient + diffuse + specular;\n        return occ*c;\n    }\n    else {\n        return ambient;\n    } \n}\n\nFile[TAILLE_FILE] ajouteRayon (File[TAILLE_FILE] tabRayon, File f){\n    for(int i =0 ; i<TAILLE_FILE; i++){\n        if (tabRayon[i].rayon.d == vec3(0.)){\n            tabRayon[i] = f;\n            return tabRayon;\n        }\n    }\n    return tabRayon;\n}\n\nFile[TAILLE_FILE] suppRayon (File[TAILLE_FILE] tabRayon, File f){\n    for(int i =0 ; i<TAILLE_FILE; i++){\n        if (tabRayon[i] == f){\n            tabRayon[i].rayon.d = vec3(0.);\n            return tabRayon;\n        }\n    }\n    return tabRayon;\n}\n\nFile trouverRayon (File[TAILLE_FILE] tabRayon){\n    for(int i =0 ; i<TAILLE_FILE; i++){\n        if (tabRayon[i].rayon.d != vec3(0.)){\n            return tabRayon[i];\n        }\n    }\n    return File(Ray(vec3(0.), vec3(0.)), 0.);\n}\n\nbool rayonValide (File f){\n    return (f.rayon.d != vec3(0.) && f.cd > 0.);\n}\n\nFile[TAILLE_FILE] initialiserTab (File[TAILLE_FILE] tabRayon){\n    for(int i =0 ; i<TAILLE_FILE; i++){\n        tabRayon[i].rayon = Ray(vec3(0.),vec3(0.));\n        tabRayon[i].cd = 0.;\n    }\n    return tabRayon;\n}\n// Rendering\nvec3 Shade(Ray ray)\n{\n    //lumière ponctuel\n    //vec3 light=normalize(vec3(15,1.,15.)-p);\n    //lumière directionelle\n    \n    float currentRefr = 1.; \n    \n    vec3 finalColor = vec3(0.);\n    \n    // On créer une file de taille TAILLE_FILE dans laquelle on passe les éléments nécessaire pour\n    // construire notre rayon suivant\n    File[TAILLE_FILE] rayonAttente;\n    rayonAttente = initialiserTab(rayonAttente);\n    rayonAttente = ajouteRayon (rayonAttente, File(ray, 1.));\n    \n    //On lance jusqu'à n rayon (ici jusqu'à 10) mais s'il y plus rien à detecter \n    //au bout d'un certain nombre de rayon lancé alors on sort directement de la boucle\n    for(int i=0; i<10; i++){\n    \n        // On récupère un rayon de notre file      \n        File currentRay = trouverRayon(rayonAttente); \n        // Une fois récupérer on le supprime pour ne pas le traiter une deuxième fois\n        rayonAttente = suppRayon(rayonAttente, currentRay);\n        \n        //On vérifie que le rayon est valide sinon on quitte la boucle \n        if (rayonValide(currentRay)){\n            Hit x;\n            // On cherche une intersection avec un objet \n            bool idx=Intersect(currentRay.rayon,x);\n            \n            if(idx && x.t>0.)\n            {\n                float cCol = currentRay.cd;\n                \n                vec3 p=Point(currentRay.rayon,x.t);\n                vec3 light2=normalize(vec3(1., -1., 2.0));\n                Material mat=Texture(p,x.n,x.i);\n                \n                // On calcul les coefficients pour la couleur transmise par reflexion ou transparence\n                float cRefl = currentRay.cd*(mat.refl); \n                float cTrans = currentRay.cd*(mat.trans);\n               \n                vec3 c = computeLight(mat,light2,x.n,currentRay.rayon.d ,p);\n                \n                // calcul du coefficient de la couleur de l'objet \n                cCol = clamp(currentRay.cd*(1. - cRefl -cTrans), 0.,1.);\n                \n                //On calcul le nouveau Rayon refléchi qu'on ajoute à notre file\n                if (mat.refl>0. ){\n                    vec3 r = reflect(currentRay.rayon.d , x.n);\n                    Ray nvRay = Ray(p+x.n*0.001,normalize(r));\n                    rayonAttente = ajouteRayon(rayonAttente, File(nvRay, cRefl));\n                }\n                \n                //fonctionne seulement pour le cylindre infini\n                if (mat.refr!=1.){\n                    vec3 r2;\n                    Ray nvR;\n                    if (x.inObj) {\n                        r2 = refract(currentRay.rayon.d, -x.n, mat.refr);\n                        nvR = Ray(p+x.n*0.001,normalize(r2));\n                    } else {\n                        r2 = refract(currentRay.rayon.d, x.n, 1./mat.refr);\n                        nvR = Ray(p-x.n*0.001,normalize(r2));\n                    }\n                    rayonAttente = ajouteRayon(rayonAttente, File(nvR, cTrans));\n                }\n                //Permet de faire la transparence sans la refraction\n                else if (mat.trans>0.){\n                    Ray nvR;\n                    if (x.inObj) nvR = Ray(p+x.n*0.001,currentRay.rayon.d);\n                    else nvR = Ray(p-x.n*0.001,currentRay.rayon.d);\n                    rayonAttente = ajouteRayon(rayonAttente, File(nvR, cTrans));\n                } \n                finalColor += c*cCol; \n            }\n            else\n            {\n                finalColor += Background(ray.d)*currentRay.cd;\n            }\n        }\n        else {break;}\n    }\n    return finalColor;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    // From uv which are the pixel coordinates in [0,1], change to [-1,1] and apply aspect ratio\n    vec2 uv=(-iResolution.xy+2.*fragCoord.xy)/iResolution.y;\n    \n    // Mouse control\n    vec2 mouse=iMouse.xy/iResolution.xy;\n    \n    // Ray origin\n    vec3 ro=20.*normalize(vec3(sin(2.*3.14*mouse.x),cos(2.*3.14*mouse.x),1.4*(mouse.y-.1)));\n    vec3 ta=vec3(0.,0.,1.5);\n    mat3 ca=setCamera(ro,ta);\n    \n    // Ray\n    vec3 rd=ca*normalize(vec3(uv.xy*tan(radians(22.5)),1.));\n    \n    // Render\n    vec3 col=Shade(Ray(ro,rd));\n    \n    fragColor=vec4(col,1.);\n}","name":"Image","description":"","type":"image"}]}