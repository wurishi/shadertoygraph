{"ver":"0.1","info":{"id":"MfXyRN","date":"1720969863","viewed":51,"name":"Im making a game in shadertoy","username":"26apastor","description":"I'm putting collisions on hold and working on other stuff.\nWHy don't collisions workw\nWASD or Arrow Keys to walk\nSpace to dash","likes":2,"published":1,"flags":48,"usePreview":0,"tags":["game","collision"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzr","filepath":"/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","previewfilepath":"/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    GameState s;\n    loadState(s, iChannel0);\n    \n    Model player = PLAYER_MODEL;\n    Model[MAX_ENEMIES] enemies = Model[MAX_ENEMIES](ENEMY_MODEL, ENEMY_MODEL);\n\n    vec3 pixel_output;\n    \n    pixel_output = BACKGROUND_COLOR;\n    \n    vec2 centerCoord = fragCoord - iResolution.xy * 0.5;\n    vec2 uv = fragCoord / iResolution.y;\n    \n    vec2 perspective_pos = s.player_controller.position;\n    \n    //drawModel(BOX_REPLACEMENT_MODEL, pixel_output, RECT_POS - perspective_pos + s.player_controller.camera.offset, centerCoord, vec2(1, 0));\n    \n    //for (int i = 0; i < MAX_ENEMIES; i++) {\n    //    setModelDirection(enemies[i], s.enemy_directions[i]);\n    //    drawModel(enemies[i], pixel_output, s.enemy_positions[i] - perspective_pos + s.player_controller.camera.offset, centerCoord, vec2(1, 0));\n    //}\n    \n    setModelDirection(player, s.player_controller.direction_forward);\n    drawModel(player, pixel_output, s.player_controller.position - perspective_pos + s.player_controller.camera.offset, centerCoord, vec2(1, 0));\n    \n    pixel_output = mix(pixel_output, _white, numToText(abs(s.player_controller.position.x), TEXT_POSITION1, FONT_SIZE, uv, iChannel1));\n    pixel_output = mix(pixel_output, _white, numToText(abs(s.player_controller.position.y), TEXT_POSITION2, FONT_SIZE, uv, iChannel1));\n    \n    pixel_output = mix(pixel_output, _white, numToText(abs(s.player_controller.direction_forward.x) * 100.0, TEXT_POSITION3, FONT_SIZE, uv, iChannel1));\n    pixel_output = mix(pixel_output, _white, numToText(abs(s.player_controller.direction_forward.y) * 100.0, TEXT_POSITION4, FONT_SIZE, uv, iChannel1));\n    \n    fragColor = vec4(pixel_output, 0.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"void mainImage(out vec4 fragColor, vec2 fragCoord) {\n    \n    GameState s;\n    \n    if (iFrame < 1) {\n        resetState(s, vec2(0), vec2[2](vec2(-100.0, 100.0), vec2(-100.0, 0.0)));\n    } else {\n        loadState(s, iChannel0);\n    }\n    \n    PlayerLocomotion player_locomotion = PlayerLocomotion(\n                                             InputHandler(\n                                                 0.0,\n                                                 0.0,\n                                                 0.0,\n                                                 0.0,\n                                                 0.0,\n                                                 false,\n                                                 0.0\n                                             ),\n                                             0.0,\n                                             s.player_controller.camera.direction_forward\n                                         );\n    \n    update(player_locomotion, s.player_controller, iTimeDelta, iChannel1, iMouse);\n    \n    for (int i = 0; i < MAX_ENEMIES; i++) {\n        vec2 enemy_dir = s.enemy_directions[i];\n        vec2 enemy_pos = s.enemy_positions[i];\n        \n        vec2 enemy_velocity = ENEMY_SPEED * normalize(enemy_dir) * min(1.0, length(enemy_dir)) * iTimeDelta;\n        vec2 enemy_velocity_after_collision_check = collideAndSlideCircle(enemy_velocity, enemy_pos, RECT_POS, RECT_HEIGHT);\n        enemy_pos += enemy_velocity_after_collision_check;\n        vec2 destination = s.player_controller.position + s.player_controller.direction_forward * distance(s.player_controller.position, enemy_pos) / 1.5 / ENEMY_SPEED;\n        enemy_dir += (normalize(destination - enemy_pos) - enemy_dir) * 0.2;\n        \n        s.enemy_directions[i] = enemy_dir;\n        s.enemy_positions[i] = enemy_pos;\n        /*\n        if (i == 0) {\n            s.camera_offset += (s.enemy_dir * CAMERA_MAX_OFFSET_WALK - s.camera_offset) * 0.02;\n        }\n        */\n    }\n    \n    saveState(s, fragColor, fragCoord);\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"/* Constants */\n\n#define SQRT_2 1.41421356237\n#define INVSQRT_2 0.707106781187\n\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_A     = 65;\nconst int KEY_D     = 68;\nconst int KEY_S     = 83;\nconst int KEY_W     = 87;\n\nconst int KEY_SPACE = 32;\n\nconst vec3 BACKGROUND_COLOR = vec3(0.0, 0.0, 0.0);\n\nconst float PLAYER_SIZE  = 15.0;\nconst vec3  PLAYER_COLOR = vec3(0.4, 0.6, 0.8);\nconst float PLAYER_SPEED = 164.9;\nconst float DASH_MULT   = 50.0;\n\nconst float EYE_MULT     = 1.0/3.0;\nconst vec3  EYE_COLOR    = vec3(1.0, 0.95, 0.9);\n\nconst float ENEMY_SIZE   = 20.0;\nconst vec3 ENEMY_COLOR   = vec3(1.0, 0.0, 0.0);\nconst float ENEMY_SPEED  = 164.9;\nconst int MAX_ENEMIES = 2;\nvec2[MAX_ENEMIES] enemies = vec2[MAX_ENEMIES](vec2(0.0), vec2(1.0));\n\nconst vec2  RECT_POS     = vec2(100, 100);\nconst float RECT_WIDTH   = 100.0;\nconst float RECT_HEIGHT  = 70.0;\nconst vec3  RECT_COLOR   = vec3(0.0625, 0.25, 1.0);\n\nconst float CAMERA_MAX_OFFSET_WALK = 20.0;\n\nconst int MAX_RECTANGLES = 4;\nconst int MAX_CIRCLES = 4;\n\nconst int max_bounces = 5;\nconst float skin_width = 0.015;\n\n#define num_points 4\nconst vec2 wall[num_points] = vec2[num_points](RECT_POS, RECT_POS + vec2(0, RECT_HEIGHT), RECT_POS + vec2(RECT_WIDTH, RECT_HEIGHT), RECT_POS + vec2(RECT_WIDTH, 0));\n\nconst vec2  TEXT_POSITION1 = vec2(0.0, 0.0);\nconst vec2  TEXT_POSITION2 = vec2(0.15, 0.0);\nconst vec2  TEXT_POSITION3 = vec2(0.0, 0.1);\nconst vec2  TEXT_POSITION4 = vec2(0.15, 0.1);\nconst float FONT_SIZE = 4.0;\n\n#define _white vec3(1.0, 1.0, 1.0)\n\n#define _A 1\n#define _B 2\n#define _C 3\n#define _D 4\n#define _E 5\n#define _F 6\n#define _G 7\n#define _H 8\n#define _I 9\n#define _J 10\n#define _K 11\n#define _L 12\n#define _M 13\n#define _N 14\n#define _O 15\n#define _P 16\n#define _Q 17\n#define _R 18\n#define _S 19\n#define _T 20\n#define _U 21\n#define _V 22\n#define _W 23\n#define _X 24\n#define _Y 25\n#define _Z 26\n#define _0 -16\n#define _1 -15\n#define _2 -14\n#define _3 -13\n#define _4 -12\n#define _5 -11\n#define _6 -10\n#define _7 -9\n#define _8 -8\n#define _9 -7\n\n/* Math stuff */\n\nvec2 projectAndScale(vec2 vector, vec2 normal) {\n    float len = length(vector);\n    vector = normalize(vector - dot(vector, normal) * normal);\n    return vector * len;\n}\n\nvec2 project(vec2 vector, vec2 normal) {\n    vector = normalize(vector - dot(vector, normal) * normal);\n    return vector;;\n}\n\nvec2 rotateVector(vec2 vector, vec2 direction) {\n    vec2 c = vector * direction.x;\n    vec2 s = vector * direction.y;\n    return vec2(c.x - s.y, s.x + c.y);\n}\n\nvec2 vslerp_spalmer(vec2 a, vec2 b, float i)\n    {\n        // fast domain-warped nlerp approximation to slerp -spalmer\n        // be wary - there's a (likely invalid) 2002 patent on optimizing slerp for quaternions like this. -spalmer\n        float c = dot(a, b) / (length(a) * length(b));\n        if (c >= 1.) return b;\n        float d = c * .5 + .5; // for quaternions, would use abs(c) instead -spalmer (?)\n        float si = ((2. * i - 3.) * i + 2.) * i; //Shrink(i); -spalmer\n        i = mix(si, i, d);\n        return normalize(mix(a, b, i));\n    }\n\n/* Text stuff */\n\nvec4 char(vec2 p, int c, sampler2D channel) \n{\n    if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0) return vec4(0, 0, 0, 1e5);\n\treturn textureGrad(channel, p / 16.0 + fract(vec2(c, 15 - c / 16) / 16.0), dFdx(p / 16.0),dFdy(p / 16.0) );\n}\n\nint digitToChar(int n) {\n    return n - 16;\n}\n\nvec3 numToText(float x, vec2 text_position, float font_size, vec2 uv, sampler2D channel) {\n    vec3 ret;\n    vec2 U = (uv - text_position) * 64.0 / font_size;\n    U.x -= floor(log(x) * 0.434294481903) * 0.5; // num digits - 1\n    while (x >= 1.0) {\n        ret += vec3(char(U, 64 + digitToChar(int(mod(floor(x), 10.0))), channel).x);\n        x /= 10.0;\n        U.x += 0.5;\n    }\n    return ret;\n}\n\n\n/* Drawing stuff */\n\n\n\nstruct Rectangle {\n    vec3 color;\n    float height;\n    float width;\n    vec2 bottomLeft;\n};\n\nconst Rectangle zeroRectangle = Rectangle(vec3(0), 0.0, 0.0, vec2(0));\n\nfloat rectangle(vec2 uv, Rectangle r, vec2 rotation1, vec2 screen_position, vec2 rotation2) {\n\tvec2 p = uv - rotateVector(rotateVector(r.bottomLeft, rotation1) + screen_position, rotation2);\n\treturn (p.x > 0.0 && p.x < r.width && p.y > 0.0 && p.y < r.height) ? 1.0 : 0.0;\n}\n\nstruct Circle {\n    vec3 color;\n    float radius;\n    vec2 center;\n};\n\nconst Circle zeroCircle = Circle(vec3(0), 0.0, vec2(0));\n\nfloat circle(vec2 uv, Circle c, vec2 rotation1, vec2 screen_position, vec2 rotation2) {\n\treturn 1.0 - smoothstep(c.radius-0.005, c.radius+0.005, length(uv - rotateVector(rotateVector(c.center, rotation1) + screen_position, rotation2)));\n}\n\nstruct Model {\n    vec2 direction;\n    Rectangle[MAX_RECTANGLES] rectangles;\n    Circle[MAX_CIRCLES] circles;\n};\n\nvoid setModelDirection(inout Model m, vec2 vector) {\n    m.direction = normalize(vector);\n}\n\nvoid drawModel(Model m, inout vec3 pixel_output, vec2 screen_position, vec2 fragCoord, vec2 rotation) {\n    for (int i; i < MAX_RECTANGLES; i++) {\n    \n        if (m.rectangles[i].height < 0.001) {\n            break;\n        }\n        \n        pixel_output = mix(pixel_output, m.rectangles[i].color, rectangle(fragCoord, m.rectangles[i], m.direction, screen_position, rotation));\n    }\n    \n    for (int i; i < MAX_CIRCLES; i++) {\n        \n        if (m.circles[i].radius < 0.001) {\n            break;\n        }\n        \n        pixel_output = mix(pixel_output, m.circles[i].color, circle(fragCoord, m.circles[i], m.direction, screen_position, rotation));\n    }\n}\n\nconst Model PLAYER_MODEL = Model(\n                        vec2(1.0, 0.0),\n                        Rectangle[MAX_RECTANGLES](zeroRectangle, zeroRectangle, zeroRectangle, zeroRectangle),\n                        Circle[MAX_CIRCLES](\n                            Circle(\n                                vec3(0.4, 0.6, 0.8),\n                                PLAYER_SIZE,\n                                vec2(0.0, 0.0)\n                            ),\n                            Circle(\n                                vec3(1.0, 0.95, 0.9),\n                                PLAYER_SIZE / 3.0,\n                                vec2(INVSQRT_2 * PLAYER_SIZE, INVSQRT_2 * PLAYER_SIZE)\n                            ),\n                            Circle(\n                                vec3(1.0, 0.95, 0.9),\n                                PLAYER_SIZE / 3.0,\n                                vec2(INVSQRT_2 * PLAYER_SIZE, -INVSQRT_2 * PLAYER_SIZE)\n                            ),\n                            zeroCircle\n                        )\n);\n\nconst Model ENEMY_MODEL = Model(\n                        vec2(1.0, 0.0),\n                        Rectangle[MAX_RECTANGLES](zeroRectangle, zeroRectangle, zeroRectangle, zeroRectangle),\n                        Circle[MAX_CIRCLES](\n                            Circle(\n                                vec3(1.0, 0.0, 0.0),\n                                ENEMY_SIZE,\n                                vec2(0.0, 0.0)\n                            ),\n                            Circle(\n                                vec3(0.25, 0.85, 0.95),\n                                ENEMY_SIZE / 4.0,\n                                vec2(INVSQRT_2 * ENEMY_SIZE, INVSQRT_2 * ENEMY_SIZE)\n                            ),\n                            Circle(\n                                vec3(0.25, 0.85, 0.95),\n                                ENEMY_SIZE / 4.0,\n                                vec2(INVSQRT_2 * ENEMY_SIZE, -INVSQRT_2 * ENEMY_SIZE)\n                            ),\n                            zeroCircle\n                        )\n);\n\nconst Model BOX_MODEL = Model(\n                      vec2(1.0, 0.0),\n                      Rectangle[MAX_RECTANGLES](\n                          Rectangle(\n                              vec3(0.0625, 0.25, 1.0),\n                              RECT_HEIGHT,\n                              RECT_WIDTH,\n                              vec2(0.0, 0.0)\n                          ), \n                          zeroRectangle, zeroRectangle, zeroRectangle\n                      ),\n                      Circle[MAX_CIRCLES](zeroCircle, zeroCircle, zeroCircle, zeroCircle)\n);\n\nconst Model BOX_REPLACEMENT_MODEL = Model(\n                      vec2(1.0, 0.0),\n                      Rectangle[MAX_RECTANGLES](zeroRectangle, zeroRectangle, zeroRectangle, zeroRectangle\n                      ),\n                      Circle[MAX_CIRCLES](Circle(\n                                vec3(0.0, 0.0, 1.0),\n                                RECT_HEIGHT,\n                                vec2(0.0, 0.0)\n                            ), \n                            zeroCircle, zeroCircle, zeroCircle\n                      )\n);\n\n//float square(vec2 uv, vec2 bottomLeft, float side) {\n//\tvec2 p = uv - bottomLeft;\n//\treturn (p.x > 0.0 && p.x < side && p.y>0.0 && p.y < side) ? 1.0 : 0.0;\n//}\n\n/* Collision stuff */\n\n// detect if point is inside circle\nbool pointCircle(vec2 point, vec2 circle, float radius) {\n    if (distance(point, circle) <= radius) {\n        return true;\n    } else {\n        return false;\n    }\n    return false;\n}\n\n// detect if point is within 0.1 distance of line\nbool linePoint(vec2 end1, vec2 end2, vec2 point) {\n\n    float addedDistanceFromPointToEnds = distance(end1, point) + distance(end2, point);\n    \n    float lineLen = distance(end1, end2);\n    \n    float buffer = 0.1;\n    \n    if (addedDistanceFromPointToEnds >= lineLen - buffer && addedDistanceFromPointToEnds <= lineLen + buffer) {\n        return true;\n    } else {\n        return false;\n    }\n    return false;\n}\n\n// detect if circle collides with line\n// outputs distance from circle to collision point\nbool lineCircle(vec2 end1, vec2 end2, vec2 circle, float radius, out float hit_distance) {\n    if (pointCircle(end1, circle, radius) || pointCircle(end2, circle, radius)) return true;\n    \n    vec2 displacement_between_line_ends = end1 - end2;\n    float line_length_squared = dot(displacement_between_line_ends, displacement_between_line_ends);\n    \n    vec2 circlePointDisplacement = circle - end1;\n  \n    float dot_product = dot(displacement_between_line_ends, circlePointDisplacement) / line_length_squared;\n  \n    vec2 closest = dot_product * displacement_between_line_ends + end1;\n    \n    bool onSegment = linePoint(end1, end2, closest);\n    if (!onSegment) return false;\n    \n    float dist = distance(circle, closest);\n    \n    if (dist <= radius) {\n        hit_distance = dist;\n        return true;\n    } else {\n        return false;\n    }\n    return false;\n}\n\n// detect if circle and polygon collide\n// outputs normal of colliding side\n// outputs distance from circle to collision point\nbool polygonCircle(vec2[num_points] vertices, vec2 circle, vec2 velocity, float radius, out float hit_distance, out vec2 hit_normal) {\n\n  int next = 0;\n  for (int current = 0; current < num_points; current++) {\n  \n    next = current+1;\n    if (next == num_points) next = 0;\n    \n    vec2 vertex_current = vertices[current];\n    vec2 vertex_next    = vertices[next];\n    \n    bool collision = lineCircle(vertex_current, vertex_next, circle + velocity, radius, hit_distance);\n    \n    \n    if (collision) {\n        hit_distance += length(velocity);\n        hit_normal = normalize(vec2(vertex_current.y - vertex_next.y, vertex_next.x - vertex_current.x));\n        return true;\n    }\n  }\n  \n  return false;\n}\n\nbool circleCircle(vec2 velocity, vec2 circle1, float radius1, vec2 circle2, float radius2, out float hit_distance, out vec2 hit_normal) {\n    vec2 position_after_moving = circle1 + velocity;\n    \n    if (distance(position_after_moving, circle2) <= radius1 + radius2) {\n        hit_normal = normalize(position_after_moving - circle2);\n        hit_distance = distance(circle1, circle2 + hit_normal);\n        return true;\n    } else {\n        return false;\n    }\n    return false;\n}\n\nvec2 collideAndSlideCircle(vec2 velocity, vec2 position, vec2 object, float object_size) {    \n    float hit_distance;\n    vec2 hit_normal;\n    if (\n        circleCircle(normalize(velocity) * (length(velocity) + skin_width), position, PLAYER_SIZE, object, object_size, hit_distance, hit_normal)\n    ) {\n        vec2 snap_to_surface = normalize(velocity) * (hit_distance - PLAYER_SIZE - skin_width);\n        vec2 leftover_velocity = velocity - snap_to_surface;\n        \n        if (length(snap_to_surface) <= skin_width) snap_to_surface *= 0.0;\n        \n        float scale = 1.0 - dot(normalize(hit_normal), normalize(velocity));\n            \n        leftover_velocity = projectAndScale(leftover_velocity, hit_normal) * scale;\n        \n        //leftover_velocity = project(leftover_velocity, hit_normal);\n        \n        return snap_to_surface + leftover_velocity;\n    }\n    \n    return velocity;\n}\n\n// collision response algorithm\nvec2 collideAndSlide(vec2 velocity, vec2 position) {\n    vec2 initial_velocity = velocity;\n\n    vec2 compound_velocity;\n    \n    float dist = length(velocity) + skin_width;\n    \n    float hit_distance;\n    vec2 hit_normal;\n    \n    int bounces;\n    while (\n        polygonCircle(wall, position, normalize(velocity) * dist, PLAYER_SIZE, hit_distance, hit_normal)\n    ) {\n        if (bounces >= max_bounces) break;\n    \n        vec2 snap_to_surface = normalize(velocity) * (hit_distance - skin_width);\n        vec2 leftover_velocity = velocity - snap_to_surface;\n        \n        if (length(snap_to_surface) <= skin_width) snap_to_surface *= 0.0;\n        \n        float scale = 1.0 - dot(normalize(hit_normal), normalize(initial_velocity));\n            \n        leftover_velocity = projectAndScale(leftover_velocity, hit_normal) * scale;\n        \n        //leftover_velocity = project(leftover_velocity, hit_normal);\n        \n        compound_velocity += snap_to_surface;\n        velocity = leftover_velocity;\n        position += snap_to_surface;\n        bounces++;\n    }\n    \n    return compound_velocity + velocity;\n}\n\n/* Player stuff */\n\nstruct Camera {\n    vec2 offset;\n    vec2 direction_forward;\n    vec2 direction_right;\n};\n\nstruct InputHandler {\n    float horizontal_input;\n    float vertical_input;\n    float move_amount;\n    float mouse_x;\n    float mouse_movement;\n    bool mouse_down;\n    float run_dodge_timer;\n};\n\nstruct Scene {\n    int type;\n};\n\n/*#define SCENE_TYPE_WORLD 1\nvoid onSceneChange(InputHandler input_handler, Scene old_scene, Scene new_scene) {\n    if (new_scene.type == SCENE_TYPE_WORLD) {\n        input_handler.enabled = true;\n    } else {\n        input_handler.enabled = false;\n    }\n}*/\n\nconst float WALKING_SPEED = 165.0;\nconst float RUNNING_SPEED = 247.0;\nconst float ROTATION_SPEED = 10.0;\n\nstruct PlayerLocomotion {\n    InputHandler input_handler;\n    float move_amount;\n    vec2 move_direction;\n};\n\nstruct PlayerController {\n    vec2 position;\n    vec2 direction_forward;\n    Camera camera;\n};\n\nvoid handleMovementInput(inout PlayerLocomotion player_locomotion, float delta, in sampler2D keyboardChannel, inout vec4 iMouse) {\n    bool key_up    = texelFetch(keyboardChannel, ivec2(KEY_W,     0), 0).x > 0.0 || texelFetch(keyboardChannel, ivec2(KEY_UP,    0), 0).x > 0.0;\n    bool key_down  = texelFetch(keyboardChannel, ivec2(KEY_S,     0), 0).x > 0.0 || texelFetch(keyboardChannel, ivec2(KEY_DOWN,  0), 0).x > 0.0;\n    bool key_left  = texelFetch(keyboardChannel, ivec2(KEY_A,     0), 0).x > 0.0 || texelFetch(keyboardChannel, ivec2(KEY_LEFT,  0), 0).x > 0.0;\n    bool key_right = texelFetch(keyboardChannel, ivec2(KEY_D,     0), 0).x > 0.0 || texelFetch(keyboardChannel, ivec2(KEY_RIGHT, 0), 0).x > 0.0;\n    bool key_space = texelFetch(keyboardChannel, ivec2(KEY_SPACE, 0), 0).x > 0.0;\n    \n    \n    \n    player_locomotion.input_handler.horizontal_input = float(key_right) - float(key_left);\n    player_locomotion.input_handler.vertical_input   = float(key_up) - float(key_down);\n    player_locomotion.input_handler.move_amount      = clamp(abs(player_locomotion.input_handler.horizontal_input) + abs(player_locomotion.input_handler.vertical_input), 0.0, 1.0);\n    player_locomotion.input_handler.mouse_movement   = (iMouse.x - player_locomotion.input_handler.mouse_x) * delta;\n    player_locomotion.input_handler.mouse_x          = iMouse.x;\n    player_locomotion.input_handler.mouse_down       = iMouse.z < 1.0;\n    \n    player_locomotion.input_handler.move_amount = floor(player_locomotion.input_handler.move_amount + player_locomotion.input_handler.move_amount) * 0.5;\n}\n\nvoid handleMovement(inout PlayerLocomotion player_locomotion, inout PlayerController player_controller, float delta) {\n    \n    player_locomotion.move_direction  = player_controller.camera.direction_forward * player_locomotion.input_handler.vertical_input;\n    player_locomotion.move_direction += player_controller.camera.direction_right * player_locomotion.input_handler.horizontal_input;\n    player_locomotion.move_direction  = normalize(player_locomotion.move_direction);\n    \n    if (player_locomotion.input_handler.move_amount == 1.0) {\n        \n        vec2 velocity_per_frame = collideAndSlideCircle(\n                                 player_locomotion.move_direction * RUNNING_SPEED * delta, \n                                 player_controller.position, \n                                 RECT_POS, RECT_HEIGHT\n        );\n        player_controller.position += velocity_per_frame;\n    \n    } else if (player_locomotion.input_handler.move_amount == 0.5) {\n        \n        vec2 velocity_per_frame = collideAndSlideCircle(\n                                 player_locomotion.move_direction * WALKING_SPEED * delta, \n                                 player_controller.position, \n                                 RECT_POS, RECT_HEIGHT\n        );\n        player_controller.position += velocity_per_frame;\n    \n    }\n}\n\nvoid handleRotation(inout PlayerLocomotion player_locomotion, inout PlayerController player_controller, inout float delta) {\n    vec2 new_direction = vslerp_spalmer(player_controller.direction_forward, player_locomotion.move_direction, ROTATION_SPEED * delta);\n    player_controller.direction_forward = new_direction;\n}\n\n/*\n#define isInteracting 0\nvoid handleRollingAndSprinting(playerLocomotion p_pL) {\n    if (isInteracting) {\n        return;\n    }\n    \n    if (p_pL.input.rollFlag) {\n        p_pL.moveDirection = \n    }\n}\n*/\n\nvoid update(PlayerLocomotion player_locomotion, inout PlayerController player_controller, float delta, in sampler2D keyboard_channel, vec4 iMouse) {\n    handleMovementInput(player_locomotion, delta, keyboard_channel, iMouse);\n    handleMovement(player_locomotion, player_controller, delta);\n    handleRotation(player_locomotion, player_controller, delta);\n}\n\n/* Load/Save stuff */\n\nstruct GameState {\n    PlayerController player_controller;\n    vec2[MAX_ENEMIES] enemy_positions;\n    vec2[MAX_ENEMIES] enemy_directions;\n};\n\nvoid resetState(out GameState s, vec2 starting_pos, vec2[MAX_ENEMIES] starting_enemy_positions) {\n    s.player_controller.position = starting_pos;\n    s.player_controller.direction_forward = vec2(1.0, 0.0);\n    \n    s.player_controller.camera.offset = vec2(0.0, 0.0);\n    s.player_controller.camera.direction_forward = vec2(0.0, 1.0);\n    s.player_controller.camera.direction_right   = vec2(1.0, 0.0);\n    \n    \n    s.enemy_positions  = vec2[MAX_ENEMIES](vec2(-200.0, 50.0), vec2(-100.0, -100.0));\n    \n    s.enemy_directions = vec2[MAX_ENEMIES](vec2(1.0, -1.0), vec2(0.0, -1.0));\n    \n    //14 + 4 floats\n}\n\nvec4 loadValue(int x, int y, sampler2D channel) {\n    return texelFetch(channel, ivec2(x, y), 0);\n}\n\nvoid loadState(out GameState s, sampler2D channel) { \n    vec4 data; \n    \n    data = loadValue(0, 0, channel);\n    s.player_controller.position = data.xy;\n    s.player_controller.direction_forward = data.zw;\n    \n    data = loadValue(1, 0, channel);\n    s.player_controller.camera.offset = data.xy;\n    s.player_controller.camera.direction_forward = data.zw;\n    \n    s.player_controller.camera.direction_right = vec2(data.w, -data.z);\n\n    for (int i = 0; i < MAX_ENEMIES; i++) {\n        data = loadValue(i, 1, channel);\n        s.enemy_positions[i] = data.xy;\n        s.enemy_directions[i] = data.zw;\n    }\n}\n\nvoid storeValue(ivec2 location, vec4 value, inout vec4 fragColor, ivec2 fragCoord) {\n    fragColor = (fragCoord == location) ? value : fragColor;\n}\n\nvoid saveState(GameState s, inout vec4 fragColor, vec2 fragCoord) {\n    storeValue(ivec2(0, 0), vec4(s.player_controller.position, s.player_controller.direction_forward),                      fragColor, ivec2(fragCoord));\n    storeValue(ivec2(1, 0), vec4(s.player_controller.camera.offset, s.player_controller.camera.direction_forward), fragColor, ivec2(fragCoord));\n    \n    for (int i = 0; i < MAX_ENEMIES; i++) {\n        storeValue(ivec2(i, 1), vec4(s.enemy_positions[i], s.enemy_directions[i]), fragColor, ivec2(fragCoord));\n    }\n}","name":"Common","description":"","type":"common"}]}