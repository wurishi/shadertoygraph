{"ver":"0.1","info":{"id":"DsX3RH","date":"1667479718","viewed":252,"name":"Mount Fuji","username":"Haru86_","description":"Mount Fuji","likes":11,"published":1,"flags":64,"usePreview":0,"tags":["raymarching"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4t2SDh","filepath":"https://soundcloud.com/elijahnang/fuji","previewfilepath":"https://soundcloud.com/elijahnang/fuji","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// \"Mountain Peak\" by Alexander Alekseev aka TDM - 2014\n// License: https://www.shadertoy.com/view/llK3WR\n\n//#version 330\n// ShaderToy --> OpenGL/GLSL Convert Preprocessor /////////////////////////////\n#define DRAW_ON_SHADERTOY\n\n#ifdef DRAW_ON_SHADERTOY\n#define _resolution iResolution\n#define gl_FragCoord fragCoord\n#define gl_FragColor fragColor\n#define _time iTime\n#define main() mainImage( out vec4 fragColor, in vec2 fragCoord )\nconst int _RenderingTarget = 1;\nconst float _LeaveStartTime = 1.0;\n#else\nuniform float _time;\nuniform vec2 _resolution;\nuniform float _RenderingTarget;\nuniform vec3 _WorldCameraPos;\nuniform vec3 _WorldCameraCenter;\n\nuniform float _LeaveStartTime;\n\nin vec2 uv;\n#endif\n\n// Shared Preprocessor ////////////////////////////////////////////////////////\n#define pi 3.14159265\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define dmin 0.0003\n#define tmax 100.0\n#define ln 128.0\n#define ldir normalize(vec3(1.0,1.0,-1.0))\n\n// Gloabal Valiable\nvec3 g_CloudP;\nfloat g_CloudT;\n\n// Useful Function ////////////////////////////////////////////////////////////\n\nstruct mapr // MapResult\n{\n   float d; // Distance\n   bool  hit;\n   int   m; // MaterialType\n            // 0: Debug\n            // 1: Mountain\n};\n\nvoid compm(inout mapr mr,float d,int mt,bool IsMin) // CompareMap\n{\n    if(IsMin)\n    {\n        if(d<mr.d) mr = mapr(d,false,mt);\n        if(mr.d<dmin) mr.hit=true; \n    }\n    else\n    {\n        if(d>mr.d) mr = mapr(d,false,mt);\n        if(mr.d<dmin) mr.hit=true; \n    }\n}\n\nvec3 trs(vec3 p,vec3 s,vec3 r,vec3 t)\n{\n    p+=t; \n    p.yz*=rot(s.x);p.xz*=rot(s.y);p.xy*=rot(s.z);\n    p*=s;\n    \n    return p;\n}\n\n// Noise Function /////////////////////////////////////////////////////////////\n\nfloat hash(vec2 p) {\n    uint n = floatBitsToUint(p.x * 122.0 + p.y);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat rand(vec2 p)\n{\n    return fract( sin(dot(p,vec2(12.9898,78.233)))*43758.5453123 );\n}\n\nfloat rand3(vec3 p)\n{\n    return fract( sin(dot(p,vec3(12.9898,78.233,128.852)))*43758.5453123 );\n}\n\nvec3 noise(in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 u = f*f*(3.0-2.0*f);\n    \n    float a = hash(i+vec2(0.0,0.0));\n    float b = hash(i+vec2(1.0,0.0));\n    float c = hash(i+vec2(0.0,1.0));\n    float d = hash(i+vec2(1.0,1.0));\n    float h1 = mix(a,b,u.x);\n    float h2 = mix(c,d,u.x);\n    \n    return vec3(\n        abs(mix(h1,h2,u.y)),\n        6.0*f*(1.0-f)*(vec2(b-a,c-a)+(a-b-c+d)*u.yx)\n    );\n}\n\nfloat hash(vec3 p)\n{\n    p=50.0*fract( p*0.3183099 + vec3(0.71,0.113,0.419));\n    return -1.0+2.0*fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nvec4 noised(in vec3 x)\n{\n    vec3 p=floor(x);\n    vec3 w=fract(x);\n    \n    vec3 u=w*w*w*(w*(w*6.0-15.0)+10.0);\n    vec3 du=30.0*w*w*(w*(w-2.0)+1.0);\n    \n    float a = hash( p+vec3(0,0,0) );\n    float b = hash( p+vec3(1,0,0) );\n    float c = hash( p+vec3(0,1,0) );\n    float d = hash( p+vec3(1,1,0) );\n    float e = hash( p+vec3(0,0,1) );\n    float f = hash( p+vec3(1,0,1) );\n    float g = hash( p+vec3(0,1,1) );\n    float h = hash( p+vec3(1,1,1) );\n    \n    float k0 = a;\n    float k1 = b-a;\n    float k2 = c-a;\n    float k3 = e-a;\n    float k4 = a-b-c+d;\n    float k5 = a-c-e+g;\n    float k6 = a-b-e+f;\n    float k7 =-a+b+c-d+e-f-g+h;\n    \n    return vec4( -1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                 2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z,\n                                 k2 + k5*u.z + k4*u.x + k7*u.z*u.x,\n                                 k3 + k6*u.x + k5*u.y + k7*u.x*u.y ) );\n}\n\nconst mat3 m3  = mat3( 0.00,  0.80,  0.60,\n                      -0.80,  0.36, -0.48,\n                      -0.60, -0.48,  0.64 );\nconst mat3 m3i = mat3( 0.00, -0.80, -0.60,\n                       0.80,  0.36, -0.48,\n                       0.60, -0.48,  0.64 );\n\nvec4 fbm2(in vec3 x,int octaves)\n{\n    float f=1.9;\n    float s=0.55;\n    float a=0.0;\n    float b=0.5;\n    vec3 d=vec3(0.0);\n    mat3 m=mat3(\n        1.0,0.0,0.0,\n        0.0,1.0,0.0,\n        0.0,0.0,1.0\n    );\n    \n    for(int i=0;i<octaves;i++)\n    {\n        vec4 n=noised(x);\n        a+=b*n.x;\n        d+=b*m*n.yzw;\n        b*=s;\n        x=f*m3*x;\n        m=f*m3i*m;\n    }\n    \n    a=a*0.5+0.5;\n    \n    return vec4(a,d);\n}\n\n// Distance Function\nvec3 octave(vec2 uv)\n{\n    vec3 n = noise(uv+vec2(0.5,1.0));\n    return vec3(pow(n.x,1.9),n.y,n.z);\n}\n\nfloat mountain(vec3 p)\n{\n    //p.xz*=0.75; // 山の広がり具合\n    //p.y*=2.5; // 山の高さ\n\n    float frq=0.24,amp=1.0,h=0.0;\n    vec2 uv=p.xz*frq+vec2(13.5,15.0),dsum=vec2(0.0);\n    \n    for(int i=0;i<7;i++)\n    {\n        vec3 n = octave((uv-dsum*0.7)*frq);\n        h+=n.x*amp;\n        dsum+=n.yz*(n.x*2.0-1.0)*amp;\n        frq*=2.5;\n        amp*=0.58;\n        amp*=pow(n.x,0.27);\n    }\n    \n    h*=7.0/(1.0+dot(p.xz,p.xz)*1e-2)+2.0/(1.0+dot(p,p)*1e-3);\n    //h*=30.0/(1.0+dot(p.xz,p.xz)*1e-2)+2.0/(1.0+dot(p,p)*1e-3);\n    // カルデラを作成\n    //h=min(h,17.0);\n    h=min(h,8.5);\n    //h=min(h,35.0);\n    \n    return p.y-h;\n}\n\n// Ray Function ///////////////////////////////////////////////////////////////\nmapr map(vec3 p)\n{\n    mapr mr;\n    mr.d=1000.0;\n    mr.hit=false;\n    mr.m=-1;\n    \n    {compm(mr, mountain(p), 1, true);}\n    \n    return mr;\n}\n\nvec3 gn(vec3 p)\n{\n    vec2 e=vec2(0.001,0.0);\n    return normalize(vec3(\n        map(p+e.xyy).d-map(p-e.xyy).d,\n        map(p+e.yxy).d-map(p-e.yxy).d,\n        map(p+e.yyx).d-map(p-e.yyx).d\n    ));\n}\n\n\nvec2 CloudMap(vec3 p,int num,inout vec3 denGra)\n{\n    float f = fbm2(p*0.5+vec3(-_time*0.25,0.0,0.0),num).x;\n    f=smoothstep(-0.2,0.6,f);\n    \n    float d = p.y - f*0.1;\n    \n    denGra = vec3(0.0, sign(p.y), 0.0);\n    \n    return vec2(d,f);\n}\n\n// Lighting //////////////////////////\nvec3 sky_color(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,3.0);\n    ret.y = pow(1.0-e.y, 1.2);\n    ret.z = 0.8+(1.0-e.y)*0.3;    \n    return ret;\n}\n\n// raytrace ///////////////////////////////////\nvec4 DrawCloud(vec3 ro,vec3 rd,in vec4 col)\n{\n    //col.rgb*=0.1;\n    //col.a=0.0;\n    float d=0.0,t=0.0,i=0.0,h=0.0;\n    vec4 CloudCol = vec4(0.0);\n    \n    for(;++i<ln;i++)\n    {\n        vec3 p = ro+rd*t;\n        vec3 denGra;\n        vec2 re=CloudMap(p, 5, denGra);\n        d=re.x;\n        h=re.y;\n        \n        //if(d<dmin)break;\n        //if(t>50.0)break;\n        //if(t>5000.0)break;\n        \n        //if(d<dmin)\n        if(d>dmin)\n        {\n            // Local Color\n            vec4 lcol = vec4(vec3(mix(0.0,1.0,h)), h*1.2);\n            lcol.a*=0.4;\n            lcol.rgb*=lcol.a;\n\n            //\n             vec3 nor = normalize(denGra);\n            float dif = clamp(dot(nor,ldir), 0.0, 1.0 )/**sha*/;\n            lcol.rgb*=dif;\n            // 雲の高さ調整\n            CloudCol+=lcol*(1.0-CloudCol.a) * clamp(1.3 - p.y * 0.2, 0.0, 1.0);\n            \n           \n        }\n        \n        //t+=d;\n        t+=max(0.05,0.1*d);\n    }\n    \n    /*float rate = 1.0 - clamp(t/100.0, 0.0, 1.0);\n    col.rgb = mix(sky_color(rd),\n        mix(col.rgb, CloudCol.rgb, CloudCol.a),\n    rate); \n    col.rgb = smoothstep(0.0, 1.0, col.rgb);*/\n    \n    //CloudCol.rgb = exp(CloudCol.rgb)*0.35;\n    \n    CloudCol = max(vec4(0.0), CloudCol);\n    //col.rgb *= 1.0 - CloudCol.a;\n    //col += CloudCol;\n    col.rgb = mix(col.rgb, CloudCol.rgb + vec3(0.5), CloudCol.a);\n    //col.rgb = smoothstep(0.0, 0.5, col.rgb);\n\n    float rate = 1.0 - clamp(t/30.0, 0.0, 1.0);\n    col.rgb = mix(sky_color(rd), col.rgb, rate);\n\n    g_CloudT = t;\n    g_CloudP = ro+rd*t;\n    \n    return col;\n}\n\n// Main ///////////////////////////////////////////////////////////////////////\nvoid main()\n{\nif(_RenderingTarget==2) // ZTest\n{\n    gl_FragColor = vec4(vec3(0.0),1.0);\n}\nelse\n{\n#ifdef DRAW_ON_SHADERTOY\n    vec2 st=(gl_FragCoord.xy*2.-_resolution.xy)/min(_resolution.x,_resolution.y);\n    vec3 ro=vec3(0.0,0.0,1.5),ta=vec3(0.0,0.0,0.0);\n    float tStep = 45.5;\n    ro=vec3(27.5*cos(tStep*0.1),3.5,27.5*sin(tStep*0.1));\n#else\n    vec2 st=uv*2.0-1.0;\n    st.x*=(_resolution.x/_resolution.y);\n    vec3 ro=_WorldCameraPos,ta=_WorldCameraCenter;\n#endif\n    vec4 col = vec4(vec3(0.0),1.0);\n    vec3 cdir=normalize(ta-ro),cside=normalize(cross(vec3(0.0,1.0,0.0),cdir)),\n    cup=normalize(cross(cdir,cside)),rd=normalize(st.x*cside+st.y*cup+1.*cdir);\n    float i=0.0,t=0.0; mapr mr;\n    \n    for(;++i<ln;){mr=map(ro+rd*(t+=mr.d));if(mr.d<dmin)break;}\n\n    if(mr.hit)\n    {\n        if(mr.m == 0)\n        {\n            //col.rgb = vec3(1.0)*10.0/i;\n            col = vec4(vec3(exp(-0.1*t)), 1.0);\n        }\n        else if(mr.m == 1)\n        {\n            vec3 p = ro+rd*t;\n            vec3 n = gn(p);\n            \n            float slope = 1.0-dot(n,vec3(0.0,1.0,0.0));\n            float hcval=mix(1.0, slope*slope, clamp((p.y-5.0)/5.0,0.0,1.0));\n            vec3 ret=mix(\n                vec3(1.0,1.0,1.0)*2.2,\n                vec3(0.0,0.0,0.1),\n                smoothstep(0.0, 0.35, hcval)\n            );\n            \n            float diff = max(0.1,dot(ldir,n));\n            \n            col.rgb=ret*vec3(0.5,0.59,0.75)*0.6;\n            col.rgb+=vec3(0.0,0.04,0.15)*hcval;\n            col.rgb+=vec3(1.0,1.0,0.98)*diff * min(1.0, 0.111*exp2(p.y) );\n           \n            // fog\n            vec3 ramda=exp2(-0.0025*t*vec3(1.0,2.0,4.0));\n            col.rgb=mix(vec3(0.5),col.rgb,ramda);\n        }\n    }\n    else\n    {\n        // sky\n        col.rgb=mix(col.rgb, sky_color(rd), step(dmin,mr.d));\n    }\n    \n    // cloud\n    vec4 CloudCol=DrawCloud(ro,rd,col);\n    //col = CloudCol;\n    //col = mix(col,CloudCol,clamp(CloudCol.a, 0.0, 1.0));\n    \n    float DepthM = t;\n    float DepthC = g_CloudT*0.55;\n    //col = (DepthM < DepthC || CloudCol.r<0.1)? col : CloudCol;\n    float rate = clamp((DepthM-DepthC) , 0.0 , 1.0);\n    col = mix(col , CloudCol, rate);\n    \n    gl_FragColor = col;\n}\n\n}","name":"Image","description":"","type":"image"}]}