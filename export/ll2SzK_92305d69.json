{"ver":"0.1","info":{"id":"ll2SzK","date":"1445287540","viewed":165,"name":"Ray Marched Terrain","username":"sanchitgarg","description":"terrain","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["terrain"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGRn","filepath":"/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","previewfilepath":"/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"XsX3Rn","filepath":"/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","previewfilepath":"/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"4sf3Rn","filepath":"/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","previewfilepath":"/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png","type":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"// Reference : https://www.shadertoy.com/view/Xds3zN\n\n#define MAX_DIS 70.0\n#define MAX_STEPS 100\n#define EPSILON 0.001\n#define SCENE_Y 10.0\n\n//Comment SHADOW_SCALE to remove shadow\n//#define SHADOW_SCALE 30.0\n\n//----------------------Color Modes----------------------\n//Uncomment the coloring mode you want to view and comment the rest\n\n#define DEPTH_COLOR\n//#define STEP_COUNT_COLOR\n//#define NORMAL_COLOR\n//#define LAMBERT_COLOR\n#define HEIGHT_COLOR\n\n//-------------------------------------------------------\n\n\n\n//------------------Ray Casting Modes--------------------\n#define NAIVE_RAY_CAST\n//#define SPHERICAL_RAY_CAST\n//-------------------------------------------------------\n\n\n\n//-------------------------------------------------------\n//\t\t\t\t\tDistance Estimators\n//-------------------------------------------------------\n\n\n//Function to create the actual scene\nvec2 disEstimator(vec3 pt, float maxHeight)\n{\n    vec4 color = (SCENE_Y+10.0) * texture( iChannel0, pt.xz / 1024.0 );\n    float h = (pt.y - (color.x + color.y + color.z)/3.0) + SCENE_Y;\n\treturn vec2(h, max(h, maxHeight));\n}\n\n\n//-------------------------------------------------------\n//\t\t\t\tColor calculation functions\n//-------------------------------------------------------\n\n//Function to calculate the normal\nvec3 getNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    disEstimator(pos+eps.xyy, 0.0).x - disEstimator(pos-eps.xyy, 0.0).x,\n\t    disEstimator(pos+eps.yxy, 0.0).x - disEstimator(pos-eps.yxy, 0.0).x,\n\t    disEstimator(pos+eps.yyx, 0.0).x - disEstimator(pos-eps.yyx, 0.0).x);\n\treturn normalize(nor);\n}\n\n#ifdef SHADOW_SCALE\n//Function to calculate the soft shadow\nfloat getSoftShadow(vec3 pt, vec3 lightPos)\n{\n    float t = 2.0;\n    float minT = 2.0;\n    \n    vec3 rd = normalize(lightPos - pt);\n    vec3 ro = pt;\n    float maxT = (lightPos.x - ro.x) / rd.x;\n\tfloat shadow = 1.0;\n    \n\tfor(int i=0; i<MAX_STEPS; ++i )\n    {\n\t\tpt = ro + t * rd;\n\n        float dt = disEstimator(pt);\n        \n        if(dt < EPSILON)\n        {\n\t\t\treturn 0.0;\n        }\n\n        t += dt;\n        shadow = min(shadow, SHADOW_SCALE * (dt / t));\t\t\n        \n        if(t > maxT)\n        {\n          \treturn shadow;\n        }\n    }\n    \n    return clamp(shadow, 0.0, 1.0);\n}\n#endif\n\n//Function to calculate lambert color\nvec3 getLambertColor(vec3 pt, vec3 ro)\n{\n \tvec3 lightPos = vec3(5.0,5.0,0.0);\n    vec3 lightCol = vec3(1.0);\n    vec3 lightVector = normalize(lightPos - pt);\n    \n    vec3 normal = getNormal(pt);\n    \n    #ifdef SHADOW_SCALE\n\t\tfloat shadow = getSoftShadow(pt, lightPos);\n\t\treturn clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol * (shadow) + 0.01;\n    #else\n\t    return clamp(dot(normal, lightVector), 0.0, 1.0) * lightCol + 0.01;\n    #endif\n}\n\n//Function to calculate color based on number of steps\nvec3 getStepCountColor(vec2 steps)\n{\n    float t = (steps.y - steps.x) / steps.y;\n\tvec2 c = vec2(t, 0.0);\n    return vec3(1.0-t, t, 0);\n}\n\nvec3 getHeightColor(vec3 pt, float maxHeight)\n{\n    vec4 color = 0.6 * texture( iChannel1, pt.xz/1024.0 );\n\tfloat h = (pt.y - (color.x + color.y + color.z)/3.0) + SCENE_Y;\n   \n    if(h < 0.0)\n    {\n        h = abs(clamp(h, -0.5, 0.0)) / 0.5;\n        return (vec3(0.15, 0.34, 0.9) * (1.0-h) + h * color.xyz);\n    }\n    \n    return ( h/maxHeight * color.xyz * texture( iChannel2, pt.xz/1.0 ).xyz);\n}\n\n//Function to calculate colors\nvec3 colorCalculation(vec3 pt, vec2 dis, vec3 ro, vec2 steps, float maxHeight)\n{\n    vec3 color = vec3(1.0);\n    #ifdef DEPTH_COLOR\n\t\tcolor *= (abs((dis.y - dis.x) / dis.y));\n    #endif\n    \n    #ifdef STEP_COUNT_COLOR\n\t\treturn getStepCountColor(steps);\n\t#endif\n    \n    #ifdef NORMAL_COLOR\n        return abs(getNormal(pt));\n\t#endif\n    \n    #ifdef LAMBERT_COLOR\n        return getLambertColor(pt, ro);\n\t#endif\n    \n    #ifdef HEIGHT_COLOR\n        color *= getHeightColor(pt, maxHeight);\n\t#endif\n    \n\treturn color;\n}\n\n//-------------------------------------------------------\n//\t\t\t\tRay Cast Functions\n//-------------------------------------------------------\n\nvec3 naiveRayCast(in vec3 ro, in vec3 rd)\n{\n    float maxHeight = 0.0;\n    vec3 pt = ro;\n    float i = 0.0;\n    int maxSteps = 500;\n\tfor(float t = 0.00; t < MAX_DIS; t+=0.01)\n\t{\n        ++i;\n        pt = ro + rd * t;\n        \n        vec2 dis = disEstimator(pt, maxHeight);\n        maxHeight = dis.y;\n            \n     \tif(dis.x < EPSILON)\n        {\n            return colorCalculation(pt, vec2(t, MAX_DIS), ro, vec2(i, maxSteps), maxHeight);\n        }\n\t}\n    \n    return vec3(0.0);\n}\n\n\n//-------------------------------------------------------\n\nvec3 render(in vec3 ro, in vec3 rd)\n{\n    #ifdef NAIVE_RAY_CAST\n\t    return naiveRayCast(ro, rd);\n    #else \n        return sphericalRayCast(ro, rd);\n    #endif\n}\n\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Starter code from iq's Raymarching Primitives\n    // https://www.shadertoy.com/view/Xds3zN\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n\n    // camera\n    vec3 ro = vec3(\n            -0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n            1.0 + 2.0 * mo.y,\n            0.5 + 3.5 * sin(0.1 * time + 6.0 * mo.x));\n    vec3 ta = vec3(-0.5, -0.4, 0.5);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}","name":"","description":"","type":"image"}]}