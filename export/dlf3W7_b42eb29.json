{"ver":"0.1","info":{"id":"dlf3W7","date":"1671872534","viewed":159,"name":"Holiday greetings 2022","username":"Exca","description":"Happy holidays and a merry new year!","likes":13,"published":1,"flags":32,"usePreview":1,"tags":["fireworks","ornament"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGzn","filepath":"/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Cubemap by IQ https://www.shadertoy.com/view/ltl3D8\nvec4 cubemap( sampler2D sam, in vec3 d )\n{\n    vec3 n = abs(d);\n    vec3 s = dFdx(d);\n    vec3 t = dFdy(d);\n    // intersect cube\n         if(n.x>n.y && n.x>n.z) {d=d.xyz;s=s.xyz;t=t.xyz;}\n    else if(n.y>n.x && n.y>n.z) {d=d.yzx;s=s.yzx;t=t.yzx;}\n    else                        {d=d.zxy;s=s.zxy;t=t.zxy;}\n    // project into face\n    vec2 q = d.yz/d.x;\n    // undistort in the edges\n    q *= 1.25 - 0.25*q*q;\n    // sample\n    // TODO: the derivatives below are wrong, apply chain rule thx\n    return textureGrad( sam,  0.5*q + 0.5,\n                              0.5*(s.yz-q*s.x)/d.x,\n                              0.5*(t.yz-q*t.x)/d.x );\n}\n\n\n// Matrix rotations.\nmat3 RotX(float a)\n{\n    return mat3(\n        1.0, 0.0, 0.0, \n        0.0, cos(a), -sin(a), \n        0.0, sin(a), cos(a)\n    );\n}\nmat3 RotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, sin(a), \n        0.0, 1.0, 0.0, \n        -sin(a), 0.0, cos(a)\n    );\n}\nmat3 RotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.0, \n        sin(a), cos(a), 0.0, \n        0.0, 0.0, 1.0\n    );\n}\nmat3 Rot(float x,float y,float z)\n{\n    return RotX(x)*RotY(y)*RotZ(z);\n}\n\nvec3 textureMapN1( vec3 surfacepos, vec3 normal )\n{\n   // material = material < 0.5 ? 0. : 1.;\n        mat3 trimap = mat3(texture(iChannel0, surfacepos.yz).rgb,\n                            texture(iChannel0, surfacepos.xz).rgb,\n                            texture(iChannel0, surfacepos.xy).rgb);\n    \n        return trimap * abs(normal);\n    \n}\nvec3 textureMapN2( vec3 surfacepos, vec3 normal )\n{\n   // material = material < 0.5 ? 0. : 1.;\n        mat3 trimap = mat3(texture(iChannel1, surfacepos.yz).rgb,\n                            texture(iChannel1, surfacepos.xz).rgb,\n                            texture(iChannel1, surfacepos.xy).rgb);\n    \n        return trimap * abs(normal);\n    \n}\nvec3 textureMapFireworks( vec3 surfacepos, vec3 normal )\n{\n   // material = material < 0.5 ? 0. : 1.;\n        mat3 trimap = mat3(texture(iChannel3, surfacepos.yz).rgb,\n                            texture(iChannel3, surfacepos.xz).rgb,\n                            texture(iChannel3, surfacepos.xy).rgb);\n    \n        return trimap * abs(normal);\n    \n}\n\nvec3 getcam( vec3 cam, vec3 target, vec2 uv, float fov)\n{\n  vec3 forward = normalize( target - cam );\n  vec3 right = normalize( cross( vec3(0,1,0), forward));\n  vec3 up = normalize( cross( forward, right));\n  return normalize( forward*fov + right * uv.x + up * uv.y);\n}\n\nfloat sphere( vec3 p, float r)\n{\n    return length(p)-r;\n}\nfloat cylinder(vec3 pos, float radius)\n{\n    return length(pos.xy) - radius;\n}\n\nfloat glow = 0.0;\n\nvec3 map( vec3 p)\n{\n    float s1 = sphere(p, 0.25);\n    \n    glow +=smoothstep(0.1, 0.0, s1);\n    \n    float c1 = cylinder( RotX(3.14*0.5)*p, 0.0035);\n    \n    if(c1 < s1 && p.y > 0.0) return vec3(c1, 2.0, 0.0);\n    \n    return vec3( s1, 1.0, 0.0);\n}\n\nvec3 march( vec3 cam, vec3 rd, out vec3 p, out float travel)\n{\n    for( int i = 0; i < 100; i++)\n    {\n        p = cam + rd*travel;\n        vec3 r = map( p );\n        travel += r.x;\n        if(r.x < 0.001)\n        {\n            return r;\n        }\n        if(travel >= 50.0)\n        {\n            travel = 50.0;\n            return vec3(-1.0);\n        }\n    }\n    return vec3(-1.0);\n}\n\nvec3 normal( vec3 p)\n{\n    vec2 e = vec2( 0.001, 0.0);\n    vec3 c = map(p);\n    return normalize( vec3( \n        map(p +e.xyy).x,\n        map(p +e.yxy).x,\n        map(p +e.yyx).x\n    )-c.x);\n}\n\nfloat diffuse( vec3 p, vec3 l, vec3 n )\n{\n    return max( 0.0, dot( normalize(l-p), n));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 ouv = uv;\n    uv -= 0.5;\n    uv.y *= iResolution.y/iResolution.x;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    vec3 cam = vec3(\n        sin(iTime*0.05)*(14.5+2.0*cos(iTime*.2)),\n        sin(iTime*0.4)*0.05+2.0,\n        cos(iTime*0.05)* (11.5+2.0*cos(iTime*.3))\n    );\n    vec3 target = vec3(0,0,0);\n    float fov = 10.2;\n    vec3 light = vec3(sin(iTime), 4.0, cos(iTime));\n    \n    vec3 rd = getcam( cam, target, uv, fov);\n    vec3 p = cam; float travel = 0.0;\n    vec3 res = march( cam, rd, p, travel);\n\n    \n    if(res.y < 0.5){\n        // bg\n        ouv -= 0.5;\n        ouv *= 0.2;\n        ouv += 0.5;\n        vec3 bgc = texture( iChannel3, ouv).rgb;\n        col = bgc;// texture( iChannel3, ouv).rgb;\n        //col *=1.0+ glow*0.03;\n    }\n    else if(res.y < 1.5) {\n        // sphere\n        vec3 n = normal( p );\n        \n        vec3 p1 = Rot( 0.0, -iTime*0.1, 0.0) * p;\n        vec3 p2 = Rot( 0.0, iTime*0.13,  0.0) * p;\n        \n        float noise = cubemap( iChannel0, p1*1.0).r + cubemap( iChannel1, p2*2.0).r;\n        \n        \n        float noiseHilight = smoothstep( 1.5, 1.7, noise);\n        float noiseBase = smoothstep(0.02, 1.5, noise);\n        \n        float intensity =  diffuse( p, light, n);\n        col = vec3(1.0, 0.5, 0.5) * noiseHilight + vec3( 0.4, 0.1, 0.20) * mix(1.0, noiseBase, 0.3);\n        \n        vec3 refcol = cubemap( iChannel3, Rot( iTime*0.02, iTime*0.03, iTime*0.01)*n).rgb;\n        \n        ouv -= 0.5;\n        ouv *= 0.7;\n        ouv += 0.5;\n        vec3 bgc = texture( iChannel3, ouv).rgb;\n\n        col =  col*0.3+ refcol*1.0 + bgc*0.9;\n    }\n    else if(res.y < 2.5){\n        ouv -= 0.5;\n        ouv *= 0.5;\n        ouv += 0.5;\n        vec3 bgc = texture( iChannel3, ouv).rgb;\n        col = mix(vec3(0.375), bgc, 0.75);// texture( iChannel3, ouv).rgb;\n        \n        \n    }\n\n\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}\n\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// Fireworks inspired by art of code  https://www.youtube.com/watch?v=xDxAnguEOn8\n\nfloat hash21(vec2 p, vec2 uv) \n{\n \treturn fract(sin(dot(p.xy ,uv+vec2(1.898,7.33))) * 4.53);\n}\n\n// P is the coordinate of the firework, uv is the screen coordinate\nvec3 fireworks( vec2 p, vec2 uv, float lifetime, float ind )\n{\n    vec3 c= vec3(0.);\n    // Iterate to generate particles & use hash to get a dir. Fireworks lifetime determines the fade. \n    for(int i = 0; i < 35; i++)\n    {\n        float a = hash21( p + vec2(i),vec2(ind));\n        float partLife = fract(a*147.0)*0.1;\n        vec2 dir = vec2( cos(a*3.14*2.0), sin(a*3.14*2.0)  ) * (0.75+0.5*fract(a*10.));\n        \n        float life = max(lifetime-partLife,0.0);\n        \n        vec2 cp = p + ((1.75*2.0-life)*dir+vec2(0.,-0.75)*life) * life*0.5;\n        \n        c+=0.2/(length(cp-uv)*170.)*max(0.,(1.75-life));\n    }\n    return c;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    float aspect = iResolution.y/iResolution.x;\n    uv.y *= aspect;\n    \n    uv*=20.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    float time = iTime/2.0;\n    \n    for( int i = 0; i < 5; i++)\n    {\n        float t = mod(time*1.15+float(i)*0.347, 2.0);\n        float ti = floor((time*1.15+float(i)*0.347)*0.5);\n        float rng = hash21( vec2( float(i), ti ), vec2(0.0) );\n        float rng2 = rng*6.14;\n        col += 3.0* fireworks( \n            4.* (vec2( rng-0.5, fract(rng*10.0)-0.25)), uv, t, float(i)+ti\n        ) * abs(vec3( sin(rng2), sin(rng2*0.34), sin(rng2*0.77)));\n    }\n    \n    //col += fireworks( vec2(0.0, 0.0), uv, mod(iTime*0.5, 2.0));\n\n    // Output to screen\n    \n    float vign = smoothstep(8.0, 0.0, length( uv));\n    \n    fragColor = vec4(col *vign ,1.0);\n}","name":"Buffer A","description":"","type":"buffer"}]}