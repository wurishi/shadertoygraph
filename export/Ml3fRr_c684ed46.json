{"ver":"0.1","info":{"id":"Ml3fRr","date":"1538764447","viewed":756,"name":"Raymarching and cube map.","username":"edo_m18","description":"CubeMap with reflection.","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["cubemap","reflect"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsfGzn","filepath":"/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","previewfilepath":"/media/ap/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg","type":"cubemap","channel":0,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define EPS 0.0001\n#define OFFSET 0.01\n\nvec3 cameraPos = vec3(0, 0, 0);\nvec3 cameraDir = normalize(vec3(0.0, -0.3, -1.0));\nfloat softShadow = 16.0;\nfloat size = 0.5;\nvec3 lightDir = vec3(1.0);\nvec2 torusSize = vec2(0.5, 0.2);\nvec2 tPos = vec2(0.0, -2.0);\nvec4 planePos = vec4(0.0, 1.0, 0.0, 2.0);\nvec3 spPos = vec3(1.0, -2.0, 0.0);\nvec3 lookat = vec3(0, -1.0, 0);\n\n// sphere's distance function\nfloat distSphere(vec3 pos)\n{\n    vec3 spp = spPos;\n    spp.y *= sin(iTime);\n    return length(pos - spp) - size;\n}\n\n// Plane's distance function\nfloat distPlane(vec3 pos, vec4 n)\n{\n    return dot(pos, n.xyz) + n.w;\n}\n\n// torus's distance function\nfloat distTorus(vec3 p, vec2 t)\n{\n  vec2 tpp = tPos;\n  tpp.y *= sin(iTime * 0.3);\n  vec2 q = vec2(length(p.xy - tpp) - t.x, p.z);\n  return length(q - tPos) - t.y;\n}\n\nfloat distFunc(vec3 pos)\n{\n    float d1 = distSphere(pos);\n    float d2 = distPlane(pos, planePos);\n    float d3 = distTorus(pos, torusSize);\n    return min(d3, min(d1, d2));\n}\n\nvec4 minVec4(vec4 a, vec4 b)\n{\n    return (a.a < b.a) ? a : b;\n}\n\nvec4 sceneColor(vec3 p)\n{\n    return minVec4(\n        vec4(vec3(1, 1, 1), distPlane(p, planePos)),\n        minVec4(\n        \tvec4(vec3(1, 0, 0), distSphere(p)),\n        \tvec4(vec3(0, 0, 1), distTorus(p, torusSize))\n    \t)\n     );\n}\n\nvec3 getNormal(vec3 pos)\n{\n    const float e = EPS;\n    const vec3 dx = vec3(e, 0, 0);\n    const vec3 dy = vec3(0, e, 0);\n    const vec3 dz = vec3(0, 0, e);\n\n    float d = distFunc(pos);\n\n    return normalize(vec3(\n        d - distFunc(vec3(pos - dx)),\n        d - distFunc(vec3(pos - dy)),\n        d - distFunc(vec3(pos - dz))\n    ));\n}\n\n// Calculate shadow\n//\n// Project ray to the light direction then if it is occluded that is shadow.\n// Also, the calculation result will use to soft shadow.\n// +-----------------+--------------------+\n// | ro = Ray Origin | rd = Ray Direction |\n// +-----------------+--------------------+\nfloat genShadow(vec3 ro, vec3 rd)\n{\n    // = distance filed result\n    float h = 0.0;\n\n    // current ray position\n    float c = 0.001;\n\n    // most nearest distance of scene objects\n    float r = 1.0;\n\n    // shadow coef\n    float shadowCoef = 0.5;\n\n    // ray marching for shadow\n    for (float t = 0.0; t < 50.0; t++)\n    {\n        h = distFunc(ro + rd * c);\n\n        if (h < EPS)\n        {\n            return shadowCoef;\n        }\n\n        // 現時点の距離関数の結果と係数を掛けたものを\n        // レイの現時点での位置で割ったものを利用する\n        // 計算結果のうち、もっとも小さいものを採用する\n        r = min(r, h * softShadow / c);\n\n        c += h;\n    }\n\n    return 1.0 - shadowCoef + (r * shadowCoef);\n}\n\n// Calculate fake AO\nfloat AmbientOcclusion(in vec3 pos, in vec3 n)\n{\n    float ao = 0.0;\n    float amp = 0.5;\n    \n    const float step_d = 0.02;\n    float distance = step_d;\n    \n    for (int i = 0; i < 10; i++)\n    {\n        pos = pos + distance * n;\n        ao += amp * clamp(distFunc(pos) / distance, 0.0, 1.0);\n        amp *= 0.5;\n        distance += step_d;\n    }\n    \n    return ao;\n}\n\nvec3 getRayColor(vec3 origin, vec3 ray, out vec3 p, out vec3 normal, out bool hit)\n{\n    vec3 col = vec3(0.0);\n    \n    float dist, depth;\n    depth = 0.0;\n\n    const int maxsteps = 128;\n\n    for (int i = 0; i < maxsteps; i++)\n    {\n        p = origin + ray * depth;\n\n        dist = distFunc(p);\n\n        if (dist < EPS)\n        {\n            break;\n        }\n\n        depth += dist;\n    }\n\n    float shadow = 1.0;\n    \n    if (dist < EPS)\n    {\n        float ao = 1.0;\n        normal = getNormal(p);\n\n        float diff = dot(normal, normalize(lightDir));\n        float spec = pow(clamp(dot(reflect(lightDir, normal), ray), 0.0, 1.0), 10.0);\n\n        shadow = genShadow(p + normal * EPS, lightDir);\n\n        ao = AmbientOcclusion(p + normal * EPS, normal);\n\n        float u = 1.0 - floor(mod(p.x, 2.0));\n        float v = 1.0 - floor(mod(p.z, 2.0));\n        \n        const float width = 0.2;\n        \n        if ((u + width >= 1.0) || (v + width >= 1.0))\n        {\n            diff *= 0.5;\n        }\n        else\n        {\n            diff *= 0.7;\n        }\n        //if ((u == 1.0 && v < 1.0) || (v == 1.0 && u < 1.0))\n        //{\n        //    diff *= 0.7;\n        //}\n\n        col = sceneColor(p).rgb * vec3(diff) + vec3(0.5) * spec;\n        col *= max(0.7, ao);\n        col *= max(0.5, shadow);\n        \n        hit = true;\n    }\n    else\n    {\n        vec4 cube = texture(iChannel0, ray);\n    \tcol = cube.xyz;\n        hit = false;\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec4 m = iMouse / iResolution.xxxx;\n    \n    vec3 col = vec3(0.0);\n\n    vec3 origin = cameraPos;\n    \n    const float cameraDistance = 5.0;\n    const float speed = 0.4;\n    float x = cos(iTime * speed) * cameraDistance;\n    float z = sin(iTime * speed) * cameraDistance;\n    \n    vec3 cPos = origin + vec3(x, 0, z);\n    vec3 cDir = lookat - cPos;// normalize(vec3(m.x * 2.0 - 1.0, m.y, -1.0));\n    cDir.x += m.x * 2.0 - 1.0;\n    cDir.y += m.y * 10.0;\n    cDir = normalize(cDir);\n    vec3 cSide = normalize(cross(cDir, vec3(0, 1, 0)));\n    vec3 cUp = normalize(cross(cSide, cDir));\n    float targetDepth = 1.3;\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir * targetDepth);\n\n    vec3 q, normal;\n    bool hit;\n    float alpha = 1.0;\n    \n    for (int i =0; i < 3; i++)\n    {\n        col += alpha * getRayColor(cPos, ray, q, normal, hit);\n        \n        if (!hit)\n        {\n            break;\n        }\n        \n        alpha *= 0.3;\n        \n        ray = normalize(reflect(ray, normal));\n        \n        cPos = q + normal * OFFSET;\n    }\n\n    fragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}