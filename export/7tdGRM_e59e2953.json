{"ver":"0.1","info":{"id":"7tdGRM","date":"1635894290","viewed":148,"name":"Dither Pattern","username":"MichaelPohoreski","description":"Instructions: Drag the left mouse button:\n Left/right for the different differing types.\n Up/Down for zoom.","likes":3,"published":1,"flags":32,"usePreview":0,"tags":["dither","ordereddither"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/*\n  Ordered Dither (with transparency)\n  \n  A common ordered dither technique is to use a Bayer Matrix.\n  For 4x4 this is:\n  \n    [ 0  8  2 10]    1\n    [12  4 14  6] * --\n    [ 3 11  1  9]   16\n    [15  7 13  5]\n  \n  You can think of the matrix being the pixel order or number of visible pixels-1 when mixing.\n  \n  It has 17 states when the foreground shows through:\n\n    ....  x...  x...  x.x.  x.x.  x.x.  x.x.  x.x.\n    ....  ....  ....  ....  ....  .x..  .x..  .x.x \n    ....  ....  ..x.  ..x.  x.x.  x.x.  x.x.  x.x. \n    ....  ....  ....  ....  ....  ....  ...x  ...x \n    None  (0)   (1)   (2)   (3)   (4)   (5)   (6)  \n  \n    x.x.  xxx.  xxx.  xxxx  xxxx  xxxx  xxxx  xxxx\n    .x.x  .x.x  .x.x  .x.x  .x.x  xx.x  xx.x  xxxx\n    x.x.  x.x.  x.xx  x.xx  xxxx  xxxx  xxxx  xxxx\n    .x.x. .x.x  .x.x  .x.x  .x.x  .x.x. .xxx  .xxx\n    (7)   (8)   (9)   (10)  (11)  (12)  (13)  (14)\n  \n    xxxx\n    xxxx\n    xxxx\n    xxxx\n    (15)\n  \nReferences:\n  * https://en.wikipedia.org/wiki/Ordered_dithering\nDemos:\n  * \"Spectrum Forces\" -- https://youtu.be/8TB6Em2OXwM\n*/\n\n#define MAX_ZOOM 8.0\n#define MIN_ZOOM 1.0/MAX_ZOOM\n\nvoid mainImage( out vec4 c, in vec2 st )\n{\n    float scale = 1.0 / MAX_ZOOM;\n    float ar    = iResolution.y / iResolution.x;\n    if (iMouse.z > 0.5)\n        scale = mix( MIN_ZOOM, ar, floor( MAX_ZOOM * (iMouse.y / iResolution.y)) / MAX_ZOOM );\n\n    vec2 uv = scale * st/iResolution.xy;\n    vec3 tex = texture( iChannel0, uv ).rgb;\n\n    c = vec4( tex, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dfGRn","filepath":"/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","previewfilepath":"/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPS 17.0\n#define SECS_PER_DITHER 2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pq  = vec2( textureSize( iChannel0, 0 ) );\n    vec2 uv  = fragCoord/pq;\n    vec3 tex = texture( iChannel0, uv ).rgb;\n\n    int x  = int( fragCoord.x );\n    int y  = int( fragCoord.y );\n    int mx = x % 4;\n    int my = y % 4;\n    int   threshold = mx + my*4; // linearize\n    int[] THRESHOLD = int[]( 0, 8, 2, 10, 12, 4, 14,  6, 3, 11, 1, 9, 15, 7, 13, 5 );\n\n    float d;\n    if (iMouse.z > 0.5)\n        d = floor( STEPS * iMouse.x / iResolution.x );\n    else // NOTE: Offset with SECS_PER_DITHER so we don't start with a blank screen\n        d = mod( floor( (SECS_PER_DITHER + iTime) / SECS_PER_DITHER), STEPS );\n    int dither = int(d);\n\n    // Dither using a 4x4 pixel pattern\n    //   Order          Position\n    //    0  8  2 10    0 1 2 3 \n    //   12  4 14  6    4 5 6 7\n    //    3 11  1  9 -> 8 9 A B\n    //   15  7 13  5    C D E F    \n    bool fg = dither > THRESHOLD[ threshold ];\n    if( fg )\n        fragColor = vec4(tex,1.0);\n    else\n        fragColor = vec4(vec3(0), 1.0); // For transparency this would be: discard;\n}","name":"Buffer A","description":"","type":"buffer"}]}