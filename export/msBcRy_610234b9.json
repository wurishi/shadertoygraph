{"ver":"0.1","info":{"id":"msBcRy","date":"1687835340","viewed":75,"name":"Molécula","username":"Elsio","description":"estudo do uso do clamp em repetições finitas","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["3d","torus","colors","balls","knot","twist","hsb"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define EPS 0.01\n\n#define PI atan(0., -1.)\n#define rot(a) mat2 (cos(a), sin(a), -sin(a), cos(a))\n#define wmod(x, w) mod(x, w) - w / 2.\n\n#define rotAbs(p, a) length(p) * vec2(sin(a), cos(a))\n#define t(x) cos(iTime * x)\n#define nContas 21.\n#define fatia 2. * PI/nContas\n\nstruct bola{float d; float id;};\nfloat discret (float x, float w){return floor(x / w) * w;}\nfloat radial (vec2 p)          {return atan(p.x, p.y);    }\n\nbola sdContas(vec3 p) {\n    vec3 q = p;\n    float v1 = t(4.);\n    float v2 = t(11.9) * 2.;\n    float v3 = t(3.2) * .5;\n    \n    float sep = .1;\n    float R = .6;\n    float r = .07;\n    float idr, idl, tc;\n    float s = .16;\n    \n    float pz = - v3;\n    float qx = - v3;\n            \n        // linear\n        pz -= p.z;\n        idl = discret(pz + s/2., s);\n        float b = (nContas - 1.)/2.;\n        p.z =  pz - s * clamp(round(pz / s), -b, b);\n        p.yx *= rot(1.5 * idl + v1);\n        p.y = abs(p.y) - sep;\n\n        // radial\n        qx -= radial(q.xy);\n        idr = discret(qx, fatia);   \n        float m = wmod(qx, fatia);\n        q.xy = rotAbs(q.xy, m);\n        q.y -= R;\n        q.yz *= rot(1.5 * idr + v1);\n        q.y = abs(q.y) - sep;\n\n    if(length(p) < length(q)){\n        return bola (length(p) - r, idl/4. + .5);\n    }\n    else{\n        return bola (length(q) - r, idr/PI);\n    }\n    \n}\n\n\nbola map(vec3 st) {\n    float v0 = cos(iTime*.35) * 1.2 - 0.;\n    vec3 pos = vec3(0, 1, 2);\n    \n    vec3 p = st - pos;\n    p.xz *= rot(v0);\n    return sdContas(p);\n}\n\n\n\n\n\n\n\nbola rayMarch(vec3 ro, vec3 rd){\n    float t = 0.;\n    bola B; \n    for(int i = 0; i < MAX_STEPS; i++){\n        B = map(ro + t * rd);\n        float step = B.d;\n        t += step;\n        if(t > MAX_DIST || step < EPS) break;\n    }\n    B.d = t;\n    return B;\n}\n\n\nvec3 normal(vec3 p) {\n\tfloat d = map(p).d;\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = vec3(d) - vec3(\n        map(p-e.xyy).d,\n        map(p-e.yxy).d,\n        map(p-e.yyx).d);\n    \n    return normalize(n);\n}\n\nfloat shadow(vec3 p) {\n    vec3 lightPos = vec3(.54, .84, 0.);\n    vec3 l = normalize(lightPos - p);\n    return dot(normal(p), l);\n}\n\n\n\nvec3 bg(vec2 p){\n    float f = discret((p.x + p.y) * .7, .04);\n    return vec3(pow(f, .7));\n}\n\nvec3 hsb(float h){\n    return abs(\n        mod(\n            h * 6. + vec3(0, 2, 4), 6.\n        ) - 3.\n    ) - .7;\n}\n\n\nvec3 color(float s, float id, vec2 p){\n    return pow(vec3(s) * .1, vec3(.6)) + hsb(id) * .2;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv, 1.));\n    \n    bola B = rayMarch(ro, rd);\n    float s = shadow(ro + rd * B.d);\n\n    \n    vec3 col = color(s, B.id, uv);\n    if (B.d > MAX_DIST) col = bg(uv);\n    \n    fragColor = vec4(col, 1.);\n}\n","name":"Image","description":"","type":"image"}]}