{"ver":"0.1","info":{"id":"Md3XDB","date":"1461238524","viewed":309,"name":"paper lantern","username":"kaswan","description":"paper lantern created with ray marching.\n\nglow effect is actually subsurface scatterring.","likes":10,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","glow","paper","lantern"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGRn","filepath":"/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","previewfilepath":"/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dX3Rn","filepath":"/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","previewfilepath":"/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Paper Lantern created by SeongWan Kim (kaswan / twitter @idgmatrix)\n// Thanks to iq and @kevinroast \n// shadow and glow effect codes from http://www.kevs3d.co.uk/dev/shaders/distancefield6.html\n\n#define EPSILON 0.005\n#define MAX_ITERATION 256\n#define AO_SAMPLES 4\n#define SSS_SAMPLES 5\n#define SHADOW_RAY_DEPTH 16\n\nfloat longitude;\nfloat latitude;\nfloat sphere(vec3 pos)\n{\n    float r = 1.0;\n    \n    vec3 rpos = pos;\n    \n    float time = iTime * 0.5;\n\tfloat s = sin(time);\n    float c = cos(time);\n    \n    rpos.x = pos.x * c + pos.z * s; \n    rpos.z = pos.x * s - pos.z * c; \n    \n    float d = length(rpos);\n    \n    longitude = atan(rpos.z, rpos.x);\n    latitude = asin(rpos.y / d);\n    \n    d += abs(sin(longitude * 3.0) * 0.15) * abs(sin(latitude * 14.0) * 0.15);\n    \n    d -= r;\n    \n    return d;\n}\n\nfloat cylinder(vec3 pos, vec3 c)\n{\n  return length(pos.xz - c.xy) - c.z;\n}\n\nfloat paperLantern(vec3 pos)\n{\n    float d = sphere(pos);\n    return max(d, -cylinder(pos, vec3(0.0, 0.0, 0.45)));\n}\n\nbool isPlane = false;\nfloat plane(vec3 pos, vec4 n)\n{\n \tfloat d = dot(pos, n.xyz) - n.w;\n    \n    if (d < EPSILON) isPlane = true;\n    \n    return d;\n}\n\nfloat scene(vec3 pos)\n{\n    float d;\n    \n    d = paperLantern(pos);\n    d = min(d, plane(pos, vec4(0.0, 1.0, 0.0, -1.2)));\n    d = min(d, plane(pos, vec4(0.0, 0.0, -1.0, -10.0)));\n    d = min(d, plane(pos, vec4(1.0, 0.0, 0.0, -6.0)));\n    d = min(d, plane(pos, vec4(-1.0, 0.0, 0.0, -6.0)));\n    \n    return d;\n}\n\nfloat calcAO(vec3 p, vec3 n)\n{\n   float r = 0.0;\n   float w = 1.0;\n   for (int i = 1; i <= AO_SAMPLES; i++)\n   {\n      float d0 = float(i) * 0.2;\n      r += w * (d0 - scene(p + n * d0));\n      w *= 0.5;\n   }\n   return 1.0 - clamp(r, 0.0, 1.0);\n}\n\nfloat calcSSS(vec3 ro, vec3 rd)\n{\n   float total = 0.0;\n   float weight = 0.5;\n   for (int i = 1; i <= SSS_SAMPLES; i++)\n   {\n      float delta = pow(float(i), 2.5) * EPSILON * 32.0;\n      total += -weight * min(0.0, sphere(ro+rd * delta));\n      weight *= 0.9;\n   }\n   return clamp(total, 0.0, 1.0);\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n\tvec3 p = ro + rd * 0.12;\n    \n\tfor (int i = 0; i < SHADOW_RAY_DEPTH; i++)\n    {\n     \t\n        float d = scene(p);\n        \n        if (d < EPSILON) {\n        \treturn 0.0;\n        }\n        \n        p += rd * d;\n    }\n    \n    return 1.0;\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float k)\n{\n   float res = 1.0;\n   float t = 0.12;         \n   for (int i = 0; i < SHADOW_RAY_DEPTH; i++)\n   {\n      float h = scene(ro + rd * t);\n      res = min(res, k*h/t);\n      t += h;\n      if (t > 5.0) break; \n   }\n   return clamp(res, 0.25, 1.0);\n}\n\nvec3 lightColor = vec3(1.2, 1.0, 0.5);\n//vec3 sssColor = vec3(1.9 + 0.1 * abs(sin(iTime * 6.0)), 1.3, 0.5);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n    uv.x *= aspectRatio;    \n    \n\tvec3 sssColor = vec3(1.9 + 0.1 * abs(sin(iTime * 6.0)), 1.3, 0.5);\n    vec3 d = vec3(uv, -2.0) - vec3(0.0, -0.0, -5.0);;\n    vec3 rd = normalize(d);\n    \n    vec3 lpos = vec3(-2.0*sin(iTime * 0.5), 3.0, -2.0*cos(iTime * 0.5));\n    //vec3 lpos = vec3(-2.0, 3.0, -2.0);\n    \n    vec3 pos = vec3(0.0, 0.0, -5.0);\n    \n    float distance;\n    \n    for (int i = 0; i < MAX_ITERATION; i++) {\n\t    \n        distance = scene(pos);\n        \n        if (distance < EPSILON) {\n\t\t\t\n\t\t\tvec3 eps = vec3(EPSILON, 0.0, 0.0);\n            vec3 normal;\n        \t    \n            normal.x = scene(pos + eps.xyz) - scene(pos - eps.xyz);\n            normal.y = scene(pos + eps.yxz) - scene(pos - eps.yxz);\n            normal.z = scene(pos + eps.zyx) - scene(pos - eps.zyx);\n            \n            vec3 n = normalize(normal);\n            vec3 l = normalize(lpos - pos);\n            \n            vec3 light = max(dot(n,l),0.0) * lightColor * 0.5;\n\n            vec4 tex;\n            if (isPlane) {\n            \tvec4 c;\n\t\t\t\ttex = texture(iChannel0, pos.yz * 0.2) * abs(n.x);\n            \ttex += texture(iChannel0, pos.zx * 0.2) * abs(n.y);\n            \ttex += texture(iChannel0, pos.xy * 0.2) * abs(n.z);\n                \n                light *= tex.xyz * vec3(1.0, 0.45, 0.1);\n            }\n            else{\n                vec2 uv = vec2(longitude, latitude); \n\t\t\t\ttex = texture(iChannel1, uv * 1.0);\n                \n                light += tex.xyz * 0.08;\n            }\n            \n\t\t\tlight *= softShadow(pos, l, 8.0) * 1.5;\n\t\t\tlight = mix(light, sssColor, calcSSS(pos, rd));\n            light += calcAO(pos, n) * 0.3;\n            \n            fragColor = vec4(light, 1.0);\n            \n\t\t\treturn;\n        }\n\n        pos += distance * rd;\n    \n    }\n    \n\tfragColor = vec4(1.0, 0.2, 0.0, 1.0);   \n}","name":"Image","description":"","type":"image"}]}