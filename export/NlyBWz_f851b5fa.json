{"ver":"0.1","info":{"id":"NlyBWz","date":"1664322938","viewed":105,"name":"Spectrum of amplitudes","username":"Envy24","description":"Logarithmic frequency scale on [a, b] for spectrum of amplitudes.","likes":4,"published":1,"flags":64,"usePreview":0,"tags":["spectrum","linear","scale","logarithmic","amplitudes"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XljXDR","filepath":"https://soundcloud.com/malka-tuti/5-sonne-lp-version-die-orangen","previewfilepath":"https://soundcloud.com/malka-tuti/5-sonne-lp-version-die-orangen","type":"musicstream","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":0}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define R                           iResolution\n#define AR                        ( R.x / R.y )       \n#define TO_CENTERED_NDC(SC)       ( ((SC)+(SC)-R.xy) / R.y )         // in range x=[-AR; AR], y=[-1.0; 1.0]\n#define PI                          3.1415926535897932\n#define UNIT                      (  3.0 / R.y  )\n#define SMAA(x)                   ( smoothstep(UNIT, 0., x) )\n\nfloat vertical_line(vec2 NDC, float x0) { return SMAA(abs(NDC.x-x0)); }\n\nfloat log10(float y) { return log(y) / log(10.); }\n\nvoid mainImage( out vec4 O, in vec2 SC )\n{\n    vec2 ndc_center = vec2(AR, 0.);\n    float ndc_width = 2.*AR;\n    vec2 NDC = TO_CENTERED_NDC(SC) + ndc_center; // map x,y from [0;R.x],[0;R.y] to [0;2*AR],[-1;1] \n    vec4 color = vec4(1);\n   \n    /* Logarithmic [a, b] */\n    float a = 20., b = 20000., max_freq = 20000.;\n    // Logarithm argument (powers) is non-linear, thus can't be properly interpolated by linear polynomial,\n    // but logarithm values (exponents) is linear and can be interpolated linearly.\n    float map = (log10(b)-log10(a))/ndc_width * NDC.x + log10(a); // linearly map from [0; 2*AR] to [log10(a); log10(b)]\n          map = pow(10., map) / max_freq;                         // calculate freq on [a; b] and map to [0; 1]\n    float amplitude = 0.995*texture(iChannel0, vec2(map, 0.)).x;  // amp value in range [0; 1]\n          amplitude = 2.*amplitude - 1.0;                         // map from [0; 1] to [-1; 1]\n    color = mix(color, vec4(0.7,0.3,(SC.x/R.x)*0.5,1), SMAA(segmentSDF_L2(NDC, vec2(NDC.x, -1.), vec2(NDC.x, amplitude))));\n\n    float freq[28] = float[28](\n                20.,    30.,    40.,    50.,    60.,    70.,    80.,    90., \n        100.,   200.,   300.,   400.,   500.,   600.,   700.,   800.,   900.,\n        1000.,  2000.,  3000.,  4000.,  5000.,  6000.,  7000.,  8000.,  9000.,\n        10000., 20000.\n    );\n    float m = ndc_width / (log10(b) - log10(a)),\n          k = -log10(a)* m;\n    for (int i = 0; i < 28; ++i) \n    {   \n        // reuse map variable\n        map = m * log10(freq[i]) + k;  // map from [log10(a); log10(b)] to [0; 2*AR]. \n        color = mix(color, vec4(0, 0, 0, 1), vertical_line(NDC, map) * 0.6); \n    }\n    color = mix(color, vec4(0, 1, 0, 1), vertical_line(NDC, m * log10(30.) + k) * 0.6);\n    color = mix(color, vec4(0, 1, 0, 1), vertical_line(NDC, m * log10(10000.) + k) * 0.6);  \n    /* Logarithmic [0, 20000] *\n    float map = (floor(SC.x) / R.x) * log10(20000.); // linearly map from [0; 800] to [0; log10(20000)]\n          map = pow(10., map) / 20000.;              // calculate freq on [0; 20000] and map to [0; 1]\n    float amplitude = 0.995*texture(iChannel0, vec2(map, 0.)).x;        \n          amplitude = 2.0*amplitude - 1.0;                        // linear amp map from [0; 1] to [-1; 1].\n    color = mix(color, vec4(0.7,0.3,(SC.x/R.x)*0.5,1.), SMAA(segmentSDF_L2(NDC, vec2(NDC.x, -1.), vec2(NDC.x, amplitude))));\n\n    float freq[39] = float[39](\n        0.,\n        1.,     2.,     3.,     4.,     5.,     6.,     7.,     8.,     9.,\n        10.,    20.,    30.,    40.,    50.,    60.,    70.,    80.,    90., \n        100.,   200.,   300.,   400.,   500.,   600.,   700.,   800.,   900.,\n        1000.,  2000.,  3000.,  4000.,  5000.,  6000.,  7000.,  8000.,  9000.,\n        10000., 20000.\n    );\n    float inv = ndc_width / log10(20000.);\n    for (int i = 0; i < 39; ++i) \n    { \n        color = mix(color, vec4(0, 0, 0, 1), vertical_line(NDC, log10(freq[i]) * inv) * 0.6); \n    }\n    /* Linear [0, 20000] *\n    float amplitude = 0.995*texture(iChannel0, vec2(SC.x / R.x, 0.)).x;\n          amplitude = 2.0*amplitude - 1.0;\n    color = mix(color, vec4(0.7,0.3,(SC.x/R.x)*0.5,1.), SMAA(segmentSDF_L2(NDC, vec2(NDC.x, -1.), vec2(NDC.x, amplitude))));\n    for (int i = 0; i < 21; ++i) \n    {\n        color = mix(color, vec4(0, 0, 0, 1), vertical_line(NDC, float(i) * ndc_width / 20.));\n    }\n    /**/\n\n    O = color;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"/* Returns sine modulated value in range [min, max]. */\nfloat sinOSC(in float min, in float max, in float T)\n{\n    float v = (sin(T) + 1.0) * 0.5; // map T to [0.0, 1.0];\n    return min + v * (max - min);   // map T to [min, max];\n}\n\nfloat diskSDF_L2(vec2 NDC, vec2 C, float R)\n{\n    return length(C - NDC)-R;\n}\n\nfloat segmentSDF_L2(\n    in vec2 NDC,\n    in vec2 B,   \n    in vec2 E)\n{\n    vec2 BP = NDC - B, BE = E - B;\n    return length(BP - BE * clamp(dot(BP, BE) / dot(BE, BE), 0.0, 1.0));\n}","name":"Common","description":"","type":"common"}]}