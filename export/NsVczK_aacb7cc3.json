{"ver":"0.1","info":{"id":"NsVczK","date":"1655205260","viewed":249,"name":"Cayley graph of S5","username":"TotallyReal","description":"Visualizing the Cayley graph of the group of permutations S5, from its origin in the 5d space to its projection in the 3d space.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["permutations","graphs","groups"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/********************************************************************************************************************\n\n                Cayley graph of the symmetric group S5\n                \nThe Cayley graph of a group G with generators S, is a graph where the vertices are the elements of the group,\nand the edges are of the form g-gs where g in G and h in S.\nIn the group S5 of all permutations of 5 elements, with the generators (1,2) (2,3) (3,4) and (4,5), there are\n5!=120 elements and 120*4/2=240 edges, which is not a simple job to view in 3D. Fortunately for us, we have the \nfollowing trick.\n\nThe group S5 acts on R5 by simply permuting the coordinates. If v in R5 has all distinct coordinates, then its\norbit has exactly |S5|=120 elements which we can identify with the group S5, and so generate the Cayley graph.\nThe problem is that we need 5 dimensions for that ...\nTo avoid this headache we use the interesting fact that the constant vectors (x,x,x,x,x) are invariant under \nthe group action. This means that all the interesting part is happening on the perpendicular space, namely\nall the (x,y,z,w,q) where x+y+z+w+q=0, which is 4-dimensional.\nMore over, permuting the coordinates doesn't change the length of a vector, so if |v|=1, then all the elements \nin its orbit have length 1, so we actually live in the unit sphere in R4, which has dimension 3.\nFinally, use the streographic projection to map the 3-dimensional sphere into the standard 3-dimensional space\nto get a nice presentation of this Cayley group.\n\n\n********************************************************************************************************************/\n\n// comment this SINGLE definition for an animation of graphs inside graphs\n#define SINGLE              \n\n#define PI 3.141592653589793238\n#define T iTime\n// map the segment [fromA, fromB] to [toA, toB] as a smooth step (function is constant outside the segment).\n#define SM(t, fromA, fromB, toA, toB) mix(toA, toB, smoothstep(fromA,fromB,t))\n\n\nconst float EPSILON = 0.0005;     // for normal calculation\nconst float RR = 100.;            // ratio between the graphs\n\nconst vec4 e4 = vec4(0,0,0,1);\nconst vec4 ee = vec4(1);\n\n// ------------------------ Some mathematics of the symmetric group ------------------------\n\n// When considering vector in R5 where the sum of their coordinates is zero, I will use an vec4 object v,\n// under the assumption that the final 5th entry is -<v,(1,1,1,1)> = -dot(v,ee).\n// But because we want to work with the standard R4 space, here is an isometry between these two spaces.\n\n// The map v -> (augM*v, -sum(augM*v)) is an isometry from R4 to vectors in R5 with zero sum.\nconst vec4 mm = vec4(1./sqrt(2.), 1./sqrt(6.), 1./sqrt(12.), 1./sqrt(20.));\nconst mat4 augM = mat4(\n     0,     0,          0, -mm.x, //mm.x,\n     0,     0,   -2.*mm.y,  mm.y, //mm.y,\n     0,    -3.*mm.z, mm.z,  mm.z, //mm.z,\n     -4.*mm.w, mm.w, mm.w,  mm.w  //mm.w\n);\n\nconst mat4 augMinv = inverse(augM);\n\n/**\n * The streographic projection.\n * Given a 4d vector v such that |v|=1 and v!=(0,0,0,1), the line from (0,0,0,1) through v intersect the space (x,y,z,0) \n * at exactly one point. \n * More specifically, the line is (0,0,0,1)+t*[v-(0,0,0,1)], and it intersects that space exactly when t=-1/(v.w-1).\n * Return this point.\n */\nvec3 projection(vec4 v){\n    return mix(e4, v, -1./(v.w-1.)).xyz;\n}\n\n/**\n * This is the inverse for the projection. This time we have some u in R^3 and we look for a point v = (1-t)*e4+t*(u,0)\n * on the line connecting u with e4, such that |v|=1.\n *           1 = |v|^2 = (1-t)^2 + t^2 * |u|^2\n *    =>     0 = (1 + |u|^2)t^2 - 2t = [(1+|u|^2)*t - 2] * t\n * t=0 is when we are at the point e4, so we need t = 2/(1+|u|^2)\n */\nvec4 antiProjection(vec3 u){\n    vec4 uu = vec4(u,0);\n    return mix(e4, uu, 2./(1.+dot(u,u)));\n}\n\n/**\n * Standard distance to the line between a and b.\n */\nfloat distLine(vec3 position, vec3 a, vec3 b){\n    vec3 dir = b-a;\n    position -= a;\n    \n    float distAlongLine = dot(position, dir)/dot(dir, dir);    \n    float h = clamp(distAlongLine, 0., 1.);    \n    return length(position-h*dir);\n}\n\n// When looking for the distance between a point p and the Cayley graph, instead of checking the distances from all the \n// vertices of the graph, we move the point p to the cell x<y<z<w<q and check the distance to the unique vertex there.\n\n// switchIJ(p, b) := switches the i and j coordinate if b==1 and otherwise does nothing.\n#define switch12(p, b) mix(p.yxzw, p.xyzw, b)\n#define switch23(p, b) mix(p.xzyw, p.xyzw, b)\n#define switch34(p, b) mix(p.xywz, p.xyzw, b)\n#define switch45(p, b) mix(vec4(p.xyz,-dot(p,ee)), p.xyzw, b)\n\nvec3 applyPermutation5(\n        float xy4, float yz3, float xy3, float zw2, float yz2, float xy2, \n        float wq1, float zw1, float yz1, float xy1, vec4 v){\n    v = switch12(v, xy4);\n    v = switch23(v, yz3);\n    v = switch12(v, xy3);\n    v = switch34(v, zw2); \n    v = switch23(v, yz2);\n    v = switch12(v, xy2);\n    v = switch45(v, wq1);\n    v = switch34(v, zw1);\n    v = switch23(v, yz1);\n    v = switch12(v, xy1);\n    return projection(augMinv*v);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat distS5(vec3 position, vec4 center4){\n    // lift the position to R5:\n    \n    // From R3 to the sphere in R4\n    vec4 p = antiProjection(position);\n    // Rotate to sum = 0. Think of the vector as xyzwq where q=-(x+y+z+w).\n    p = augM*p;\n    \n    // Find the permutation that sorts the coordinates of p by bubble sort them\n    \n    // move max element to the q cooridnate\n    float xy1 = step(p.x, p.y);\n    p = switch12(p, xy1);\n    \n    float yz1 = step(p.y, p.z);\n    p = switch23(p, yz1);\n    \n    float zw1 = step(p.z, p.w);\n    p = switch34(p, zw1);\n    \n    float wq1 = step(p.w, -dot(p,ee));\n    p = switch45(p, wq1);\n        \n    // move second max element to w cooridnate\n    float xy2 = step(p.x, p.y);\n    p = switch12(p, xy2);\n    \n    float yz2 = step(p.y, p.z);\n    p = switch23(p, yz2);\n    \n    float zw2 = step(p.z, p.w);\n    p = switch34(p, zw2);\n    \n    // move third max element to z cooridnate\n    float xy3 = step(p.x, p.y);\n    p = switch12(p, xy3);\n    \n    float yz3 = step(p.y, p.z);\n    p = switch23(p, yz3);\n    \n    // sort first two elements\n    float xy4 = step(p.x, p.y);\n    p = switch12(p, xy4);\n       \n    \n    // apply the transpositions in reverse order (e.g. inverse permutation) to the element\n    // in the cell x<y<z<w<q, and its neighbors.\n    vec3 v  = applyPermutation5(xy4, yz3, xy3, zw2, yz2, xy2, wq1, zw1, yz1, xy1, center4);\n    vec3 v1 = applyPermutation5(xy4, yz3, xy3, zw2, yz2, xy2, wq1, zw1, yz1, xy1, center4.yxzw);\n    vec3 v2 = applyPermutation5(xy4, yz3, xy3, zw2, yz2, xy2, wq1, zw1, yz1, xy1, center4.xzyw);\n    vec3 v3 = applyPermutation5(xy4, yz3, xy3, zw2, yz2, xy2, wq1, zw1, yz1, xy1, center4.xywz);\n    vec3 v4 = applyPermutation5(xy4, yz3, xy3, zw2, yz2, xy2, wq1, zw1, yz1, xy1, vec4(center4.xyz, -dot(center4,ee)));\n            \n    // vertices\n    float d = distance(position, v)-0.02*length(v); \n    \n    //edges\n    float mid1 = length(mix(v,v1,0.5));\n    d = opSmoothUnion(d, distLine(position, v, v1)-0.01*length(mid1), 0.1);\n    float mid2 = length(mix(v,v2,0.5));\n    d = opSmoothUnion(d, distLine(position, v, v2)-0.01*length(mid2), 0.1);\n    float mid3 = length(mix(v,v3,0.5));\n    d = opSmoothUnion(d, distLine(position, v, v3)-0.01*length(mid3), 0.1);\n    float mid4 = length(mix(v,v4,0.5));\n    d = opSmoothUnion(d, distLine(position, v, v4)-0.01*length(mid4), 0.1);\n        \n    return d;\n    \n}\nconst vec3 fogColor = vec3(0.0);\nconst float maxDist = 150.;\n\n\n// ============================ Scene ============================\n\nvec4 sdfMin(vec4 v, vec4 u){\n    if (v.w < u.w) \n        return v; \n    return u;\n}\n\nvec4 distScene(vec3 position){  \n    # if defined SINGLE\n    \n    vec4 v = vec4(-2,-1.,0.,1./*,2.*/)/sqrt(10.);\n    \n    float d = distS5(position, v);  \n    vec3 color = SM(length(position),0.3,1.,vec3(1.,0.2,0.2),vec3(0.3,0.6,1.));\n    \n    return vec4(color, d);\n    \n    # else\n\n    // One point on the graph, where the other points are the orbit of S5.\n    // The point need to be in R5 (5th coordinate complete the first 4 to zero sum), and has norm 1. \n    vec4 v = vec4(-2,-1.+cos(T)/10.,sin(T)/4.,1.-cos(T)/10.);\n    float vq = -dot(v,ee);\n    v /= sqrt(dot(v,v)+vq*vq);\n\n    // zoom in every 10 seconds\n    float i = floor(T/10.);\n    vec3 color = 0.33+fract(vec3(i+0.1,i+1.1,i+2.1)/3.);    \n    float radius = SM(fract(T/10.),0.3,1.,1.,RR);\n    position/=radius;\n    \n    // --- Consider doing this part by dividing the space according to the distance from the origin\n    // --- and add one Cayley graph per such fat sphere.\n    float outerDist = distS5(position/(RR*radius), v)*radius*RR;    \n    vec4 outer = vec4(color.brg, outerDist);\n    \n    float midDist = distS5(position, v)*radius;    \n    vec4 mid = vec4(color.rgb, midDist);\n    \n    float innerDist = distS5(position*RR, v)*radius/RR;  \n    vec4 inner = vec4(color.gbr, innerDist);\n        \n    return sdfMin(sdfMin(outer, mid),inner);\n    \n    # endif\n}\n\n// ============================ Simple ray march ============================\n\nvec3 calcNormal(vec3 p) {\n  vec2 e = vec2(1.0, -1.0) * EPSILON; // epsilon\n  return normalize(\n    e.xyy * distScene(p + e.xyy).w +\n    e.yyx * distScene(p + e.yyx).w +\n    e.yxy * distScene(p + e.yxy).w +\n    e.xxx * distScene(p + e.xxx).w);\n}\n\nvec4 rayMarch(in vec3 rayOrigin,in vec3 rayDirection)\n{    \n    float t = 0.01;\n    //Material result;\n    vec4 result;\n    for( int i = 0; i<100; i++ )\n    {\n        vec3 position = rayOrigin + rayDirection * t;\n        result = distScene( position );\n        if( result.w < (0.001) || t > maxDist ) break;\n        t += 0.8 * result.w;\n    }\n\n    if( t>maxDist ) t=-1.0;\n    result.w = t;\n    return result;\n}\n\n\n// ============================ Light ============================\n\nconst vec3 lightDir = normalize(vec3(1));\n\nvec3 processLight(vec3 position, vec3 normal, vec3 direction){\t\n    // diffuse\n    float diffuse = pow(clamp(-dot(lightDir, normal), 0., 1.), 0.5);\n    \n    //specular\n    float specular = clamp(dot(-direction, reflect(lightDir, normal)), 0., 1.);\n    \n    //fresnel\n    float dotDN = dot(direction, normal);\n    float fresnel = pow((1.0 - dotDN*dotDN), 2.);\n    \n    return (3.*fresnel + 2.*diffuse + specular)*vec3(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    // center and normalize coordinates\n    vec2 coord = (fragCoord.xy - iResolution.xy/2.) / iResolution.y;\n   \n    float t = T*2.*PI/10.; // full round every 10 seconds\n    \n    float st = sin(t);\n    float ct = cos(t);\n    \n    vec3 origin = vec3(6.*st,0,6.*ct);\n    vec3 target = vec3(0);\n    \n    // rotate camera around the y-axis\n    vec3 forward, right, up;\n    forward = normalize(-origin);\n    right = normalize(cross(vec3(0,1,0), forward));\n    up = cross(forward,right);\n    \n    vec3 rayDirection = normalize(forward + coord.x*right + coord.y*up);\n        \n    vec4 result = rayMarch(origin, rayDirection);\n    float d = result.w;\n    \n    if (d>0.){\n        vec3 position = origin + d * rayDirection;\n        vec3 normal = calcNormal(position);\n        vec3 color = result.rgb;\n        \n        color *= processLight(position, normal, rayDirection)/2.;\n        // add for to far away objects\n        color = SM(d, 5., 160., color, fogColor);\n        \n        fragColor = vec4(color , 1.);\n    } else\n        fragColor = vec4(fogColor, 1.);\n}\n\n","name":"Image","description":"","type":"image"}]}