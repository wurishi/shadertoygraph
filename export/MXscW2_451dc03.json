{"ver":"0.1","info":{"id":"MXscW2","date":"1726686487","viewed":58,"name":"The Halfway Vector Disk BRDF","username":"msuzuki","description":"BRDF model by Edwards et al., \"The Halfway Vector Disk for BRDF Modeling\". The code is from the MDL implementation.\n\n- Drag mouse horizontally changes the light direction\n- Drag mouse vertically changes the roughness","likes":0,"published":1,"flags":0,"usePreview":0,"tags":["brdf","retroreflection"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// switch symmetric correction methods for the top/bottom halves of the sphere\n#define MODEL_TOP_NEUMANN_FIX 0\n#define MODEL_TOP_MDL_FIX     0\n#define MODEL_BOT_NEUMANN_FIX 1\n#define MODEL_BOT_MDL_FIX     1\n\n// shading parameters\n#define LAMBERT_ON              1\n#define LAMBERT_ALBEDO          vec3(0.8, 0.4, 0.2)\n#define RETRO_WEIGHT            0.7\n#define RETRO_ROUGHNESS_SCALE_V 1.0\n\n// 0: eval with rotating directional light\n// 1: furnace test (cosine sampling)\n#define VIEW_MODE 0\n\n\n\nfloat eval_disk_distribution(float x, float y, vec2 exponent)\n{\n    float dx2 = x * x;\n    float dy2 = y * y;\n    float dxy2 = dx2 + dy2;\n    float f = 1.0 - dxy2;\n\n    if (f < 0.0)\n        return 0.0;\n\n    float p = (dxy2 > 1e-8) ? pow(f, (exponent.x * dx2 + exponent.y * dy2) / dxy2) : 1.0;\n\n    return sqrt((exponent.x + 1.0) * (exponent.y + 1.0)) * (1.0 / PI) * p;\n}\n\n\nvec3 BRDF_RetroReflective(vec3 N, vec3 V, vec3 L, float Roughness, int NeumannFix, int MDLFix)\n{\n    float nk1 = dot(L, N);\n    float nk2 = dot(V, N);\n\n    float roughness = clamp(Roughness, 0.0001, 1.0);\n    float roughness_u = roughness;\n    float roughness_v = roughness * RETRO_ROUGHNESS_SCALE_V;\n    vec2 exponent = vec2(2.0 / (roughness_u * roughness_u), 2.0 / (roughness_v * roughness_v));\n\n    vec3 x_axis = vec3(1, 0, 0);\n    vec3 z_axis = vec3(0, 0, 1);\n\n    vec3 h = normalize(L + V);\n    float nh = dot(N, h);\n    float xh = dot(x_axis, h);\n    float zh = dot(z_axis, h);\n\n    float inv_nh = 1.0 / nh;\n    float nk1_nh = nk1 * inv_nh;\n    float nk2_nh = nk2 * inv_nh;\n    float x1 = nk1_nh * xh;\n    float y1 = nk1_nh * zh;\n    float x2 = nk2_nh * xh;\n    float y2 = nk2_nh * zh;\n\n    float xk1 = dot(L, x_axis);\n    float zk1 = dot(L, z_axis);\n    float ph1 = eval_disk_distribution(x1 - xk1, y1 - zk1, exponent) * nk1_nh * nk1_nh * inv_nh;\n\n    float xk2 = dot(V, x_axis);\n    float zk2 = dot(V, z_axis);\n    float ph2 = eval_disk_distribution(x2 - xk2, y2 - zk2, exponent) * nk2_nh * nk2_nh * inv_nh;\n\n    float kh = dot(L, h);\n    float f = (0.25 / kh);\n  \n    // symmetric correction introduced by Neumann et al.\n    // \"Compact Metallic Reï¬‚ectance Models\", 1999, Eq. (3)\n    float nk = (NeumannFix == 0) ? nk2 : max(nk2, nk1);\n\n    // symmetric correction in MDL implementation\n    // Compute ph for both direction and check min to ensure the reciprocity\n    // https://github.com/NVIDIA/MDL-SDK/blob/master/src/mdl/jit/libbsdf/libbsdf.cpp#L2143\n    float ph = (MDLFix == 0) ? ph1 : min(ph1, ph2);\n\n    return vec3(f * ph * nk2 / nk);\n}\n\n\nvec3 BRDF_Lambert(vec3 N, vec3 V, vec3 L, vec3 Albedo)\n{\n    float NdotV = dot(N, V);\n    float NdotL = dot(N, L);\n    if (NdotL <= 0.0)\n        return vec3(0.0); // pointing away from light\n\n    return Albedo * NdotL / PI;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse == vec2(0.0)) ? vec2(0.5) : mouse;\n\n    float LightAngle = PI * mouse.x;\n    float Roughness = mouse.y;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord / iResolution.y;\n    uv = 2.0 * uv - vec2(aspect, 1.0);\n\n    // background color\n    vec3 col = (VIEW_MODE == 0) ? vec3(0.0) : vec3(0.5);\n\n    float r = dot(uv, uv);\n    if (r < 1.0)\n    {\n        float z = sqrt(1.0 - dot(uv, uv));\n        vec3 N = vec3(uv, z);\n        vec3 V = vec3(0.0, 0.0, 1.0); // ortho camera\n        \n        int NeumannFix = uv.y >= 0.0 ? MODEL_TOP_NEUMANN_FIX : MODEL_BOT_NEUMANN_FIX;        \n        int MDLFix = uv.y >= 0.0 ? MODEL_TOP_MDL_FIX: MODEL_BOT_MDL_FIX;        \n\n#if VIEW_MODE == 0\n        // simple BRDF evaluation\n        vec3 Albedo = vec3(0.8, 0.4, 0.2);\n        float LightIntensity = 3.0;\n        vec3 L = vec3(sin(LightAngle), 0.0, cos(LightAngle));\n        col = BRDF_RetroReflective(N, V, L, Roughness, NeumannFix, MDLFix) * LightIntensity;\n\n    #if LAMBERT_ON == 1\n        vec3 lambert = BRDF_Lambert(N, V, L, LAMBERT_ALBEDO) * LightIntensity;\n        col = mix(lambert, col, RETRO_WEIGHT);\n    #endif\n\n#elif VIEW_MODE == 1\n        vec3 Albedo = vec3(1.0);\n        float Ns = 64.0;\n        vec3 Average = vec3(0.0);\n\n        // stratified sampling\n        vec3 jitter = rand(uvec3(fragCoord, iFrame));\n        for (float dy = 0.; dy < Ns; dy++) {\n            for (float dx = 0.; dx < Ns; dx++) {\n                float rx = (dx + jitter.x) / Ns;\n                float ry = (dy + jitter.y) / Ns;\n                float a = 1.0 - 2.0 * rx;\n                float b = sqrt(1.0 - a * a);\n                float phi = 2.0 * PI * ry;            \n                vec3 L = normalize(N + vec3(b * cos(phi), b * sin(phi), a));\n                float Pdf = max(dot(L, N), 0.0) / PI;\n                Average += col * BRDF_RetroReflective(N, V, L, Roughness, NeumannFix, MDLFix) / Pdf;\n            }\n        }\n        col = Average / (Ns * Ns);\n\n#endif\n    }\n    \n    // tone mapping\n    fragColor = vec4(tonemap(col), 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"#define PI 3.14159265358979323846264338327950288\n\n\nvec3 tonemap(vec3 c)\n{\n    // http://filmicworlds.com/blog/filmic-tonemapping-operators/\n    vec3 x = max(vec3(0.0),c-vec3(0.004));\n    return (x*(6.2*x+.5))/(x*(6.2*x+1.7)+0.06);\n}\n\nuvec3 pcg3d(uvec3 v) {\n    // http://www.jcgt.org/published/0009/03/02/\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\n\nvec3 rand(uvec3 seed)\n{\n    return vec3(pcg3d(seed) >> 8) / float(1 << 24);\n}\n","name":"Common","description":"","type":"common"}]}