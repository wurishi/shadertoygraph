{"ver":"0.1","info":{"id":"3sl3Rn","date":"1544801183","viewed":65,"name":"A scene","username":"schme","description":"Started by doing raymarching and sdf's, ended up adding things..","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["raymarch"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdX3Rn","filepath":"/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","previewfilepath":"/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"vec3 saturate(vec3 color)\n{\n    return clamp(color, vec3(0), vec3(1));\n}\n\nmat3 sx = mat3( \n    1.0, 2.0, 1.0, \n    0.0, 0.0, 0.0, \n   -1.0, -2.0, -1.0 \n);\nmat3 sy = mat3( \n    1.0, 0.0, -1.0, \n    2.0, 0.0, -2.0, \n    1.0, 0.0, -1.0 \n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 buffer = texture(iChannel0, uv).xyz;\n\n    mat3 I;\n    for (int i=0; i<3; i++) {\n        for (int j=0; j<3; j++) {\n            vec3 smpl  = texelFetch(iChannel0, ivec2(uv*iChannelResolution[0].xy) + ivec2(i-1,j-1), 0 ).rgb;\n            I[i][j] = length(smpl); \n        }\n    }\n    \n    float gx = dot(sx[0], I[0]) + dot(sx[1], I[1]) + dot(sx[2], I[2]); \n\tfloat gy = dot(sy[0], I[0]) + dot(sy[1], I[1]) + dot(sy[2], I[2]);\n\n    float g = sqrt(pow(gx, 2.0)+pow(gy, 2.0));\n    g = smoothstep(0.2, 0.6, g);\n    vec3 edgeColor = vec3(.9, .9, .5);\n\n    vec4 color = vec4(buffer.xyz, 1.0);\n\n    uv.y += iTime * 0.25;\n    vec4 textureBuf = texture(iChannel1, uv);\n    color += length(buffer.rgb) * textureBuf * 0.3;    \n\n\tvec4 sobelCol = vec4(edgeColor * g, 1.0);\n    color /= 1.0 - fract(sobelCol);\n    \n    color = vec4(saturate(color.xyz), color.w);\n    color.xyz = pow(color.xyz, vec3(1.0 / 2.2));\n    fragColor = vec4(saturate(color.xyz), 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"XdfGRn","filepath":"/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4sXGzn","filepath":"/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","previewfilepath":"/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3","type":"music","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define STEPS 256\n\n#define MIN_DISTANCE 0.01\n#define MAX_DISTANCE 10000.0\n\n#define LIGHT_FALLOFF 30.0\n\nfloat getTime()\n{\n    const float timeAdjustment = 1.0;\n    return 0.01 + iTime * timeAdjustment;\n}\n\nfloat displacement(vec3 p)\n{\n    vec4 audio = texture(iChannel3, vec2(0, 0));\n    return sin(2.0 * p.x * pow(2., audio.x))*cos(10.0*p.y * audio.x)*sin(.03*p.z*audio.x);\n}\n\nfloat displacement2(vec3 p)\n{\n    #define section 6\n    vec4 audio = texture(iChannel3, vec2(0, 0));\n    float dir = int(iTime) % section * 2 < section ? -1.0 : 1.0;\n    float result = (cos(15.0 * p.x + dir * 10.0 * audio.x)*cos(20.0 * p.y + -dir * 20.0 * audio.x)*sin(20.0 * p.z - dir * 55.0 * audio.w));\n    return result * (.0 + 0.3 * abs((audio.x - audio.w)));\n}\n\n\nfloat sdTorus( vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 spherePos, float sphereRad)\n{\n    return length(spherePos) - sphereRad;\n}\n\nfloat sdRepSphere( vec3 p, vec3 c, float r)\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere( q , r);\n}\n\nfloat sdBox( vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n        + min(max(d.x, max(d.y, d.z)), 0.0);\n}\n\nfloat sdPlane(vec3 p, vec4 n)\n{\n    return dot(p, n.xyz) + n.w;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h)\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat sdBlend(float d1, float d2, float a)\n{\n    return a * d1 + (1.0 - a) * d2;\n}\n\nfloat displacePlane(vec3 p, vec4 n)\n{\n    float dist = sdPlane(p, n);\n    float disp = displacement(p);\n    return dist+disp;\n}\n\nfloat displaceTorus(vec3 p, vec2 t)\n{\n    float dist = sdTorus(p, t);\n    float disp = displacement2(p);\n    return dist + disp;\n}\n\nvec2 _fragCoord;\n\n\n#define _color vec3(0.2, 0.2, 0.9)\n#define _color2 vec3(0.1, 0.1, 0.1)\n\n#define _ambient_color vec3(0.01, 0.08, 0.08)\n#define _specular 1.4\n\n\nvec3 lightPos = vec3(-10.0, 5.0, 1.0); \nvec3 lightCol = vec3(0.9, 0.9, 0.9);\nfloat lightSpec = 0.1;\n    \nvec3 calcLighting(vec3 normal, vec3 viewDir, vec3 cPos, bool thing)\n{\n    lightPos.x *= 1.5 * sin(getTime() * 0.5);\n \n    vec3 color = thing ? _color2 : _color;\n    vec3 lightDir = (-lightPos - viewDir);\n    lightDir = normalize(lightDir);\n    \n    float NdotL = max(dot(normal, lightDir),0.0);\n    \n    vec3 reflectDir = reflect(lightDir, normal);\n    float specAngle = dot(reflectDir, viewDir);\n\n    vec3 h = (lightDir - viewDir) / 2.0;\n    vec3 s = specAngle > 0.0 ? pow( specAngle, _specular) * lightCol : vec3(0);\n\n    return _ambient_color * color + color * lightCol * NdotL + color * s * lightSpec;\n}\n\nfloat map( vec3 p)\n{   \n    vec2 uv = _fragCoord / iResolution.xy;\n    vec3 txtr = texture(iChannel1, uv).xyz;\n    txtr *= 5.0 - 5.0 * cos(getTime() * 0.25);\n    if (true)\n\t    return min(min(min(min(min(min(min(\n    \t    displaceTorus(p + vec3(0.0, -1.0 + 0.5 * sin(getTime()), -3.0), vec2(1.5, 0.3)),\n        \tsdBlend(\n\t\t\t\tsdBox( p + vec3(0.0, -1., -3.0), vec3(.9, 1.2, .9)),\n        \t\tsdSphere(p + vec3(-0.0, -1., -3.0), 1.0),\n\t        \ttxtr.g * 0.5 - abs(sin(getTime())))),\n    \t    sdPlane(p + vec3(0.0, -1.0, 0.0), normalize(vec4(0.0, -1.0, -0., 1.0)))),\n        \tdisplacePlane(p + vec3(0.0, 0.0, -10.0), normalize(vec4(0.0, 0.0, -1.0, 1.0)))),\n            sdBox(p + vec3(-2.8, 1.8, -4.0), vec3(1.3, 1.0, 1.0))),\n            sdHexPrism( p + vec3(4.5, 2.5, -6.0), vec2(1.25, 1.0))),\n            sdBlend(\n                sdHexPrism( p + vec3( 4., -.5, -4.0), vec2(.5, .25)),\n                sdBox(p + vec3( 4., -.5, -4.0), vec3(.5, .5, .5)),\n                0.5 - 0.5 * sin(getTime()))),\n            sdBlend(\n                sdTriPrism( p + vec3( -4.5, -.5, -4.0), vec2(0.5, 0.25)),\n                sdSphere( p + vec3( -4.5, -.3, -4.0), 1.),\n                0.5 - 0.5 * sin(getTime() * 2.0))\n\t    );\n}\n\nvec3 normal( vec3 p )\n{\n    #define FLIP 12\n    vec4 audio = texture(iChannel3, vec2(0, 0));\n    bool flip = int(iTime) % FLIP * 2 < FLIP ? false : true;\n    const float eps = 0.01;\n    return flip ?\n    normalize(\n        ( vec3 (\n            map(p + vec3(eps, 0.0, 0.0)) - map(p - vec3( eps, 0.0, 0.0)),\n            map(p + vec3(0.0, eps, 0.0)) - map(p - vec3( 0.0, eps, 0.0)),\n            map(p + vec3(0.0, 0.0, eps)) / map(p - vec3( 0.0, 0.0, eps))\n\t\t)  )\n\t)\n    :\n    normalize(\n        ( vec3 (\n            map(p + vec3(eps, 0.0, 0.0)) - map(p - vec3( eps, 0.0, 0.0)),\n            map(p + vec3(0.0, eps, 0.0)) - map(p - vec3( 0.0, eps, 0.0)),\n            map(p + vec3(0.0, 0.0, eps)) - map(p - vec3( 0.0, 0.0, eps))\n\t\t)  )\n\t);\n}\n\nvec4 render(vec3 p, vec3 cPos)\n{\n    bool thing = false;\n    #define color_change 6\n    if (int(iTime) % color_change * 2 < color_change)\n        thing = !thing;\n    vec3 n = normal(p);\n    return vec4(calcLighting(n, p, cPos, thing), 1.0);\n}\n\nvec4 march(vec3 p, vec3 d)\n{\n    vec3 cPos = p;\n    for (int i = 0; i < STEPS; i++)\n    {\n        float dist = map(p);\n        \n        if (dist < MIN_DISTANCE)\n            return render(p, cPos);\n\n        \n        p += dist * d;\n    }\n    return vec4(vec3(0), 1.0);\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    _fragCoord = fragCoord;\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 cameraPosition = vec3(0.0, 0.0, 0.0);\n    vec2 p = ((iResolution.xy - 2.0*fragCoord.xy)/iResolution.y);\n    vec3 rayDir = normalize(vec3(p, 1.0));\n\n\tvec4 color = march(cameraPosition, rayDir);\n    \n    vec4 audio = texture(iChannel3, vec2(0, 0));\n    vec3 txtr = texture(iChannel1, uv).xyz;\n    float txtrMulti = 2.;\n\n    color.xyz += color.xyz * audio.x * txtr * txtrMulti;\n    color *= pow(0.9 + (audio.x - audio.w), 0.7678);\n\n    // Output\n    fragColor = color;\n}","name":"Buffer A","description":"","type":"buffer"}]}