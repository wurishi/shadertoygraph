{"ver":"0.1","info":{"id":"mlcBWH","date":"1701178784","viewed":15,"name":"Gathers","username":"olesgergun","description":"Example of the luminosity usage","likes":0,"published":1,"flags":32,"usePreview":0,"tags":["luminosity"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Sample the color from Buffer A\n    vec3 baseColor = texture(iChannel0, fragCoord / iResolution.xy).rgb;\n\n    // Define the blend color (#A0A0A0 in your case)\n    vec3 blendColor = vec3(0.62745, 0.62745, 0.62745); // #A0A0A0\n\n    // Calculate the luminance of the blend color\n    float blendLuma = dot(blendColor, vec3(0.299, 0.587, 0.114));\n\n    // Calculate the chroma of the base color\n    vec3 baseChroma = baseColor - dot(baseColor, vec3(0.299, 0.587, 0.114));\n\n    // Combine the chroma of the base color with the luminance of the blend color\n    vec3 finalColor = baseChroma + blendLuma;\n\n    // Output the final color\n    fragColor = vec4(finalColor, 1.0);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define numOfPoints 30\n#define seed (35487457)\n#define a (1103515245)\n#define c (12345)\n#define m (1<<31)\n\nconst vec3 fafafa = vec3(0.9804, 0.9804, 0.9804);\nconst vec3 color69EDAA = vec3(0.4118, 0.9294, 0.6667);\nuniform vec2 u_resolution;\n\nfloat rand(int i) {\n    uint ui = uint(i);\n    uint ua = uint(a);\n    uint uc = uint(c);\n    uint useed = uint(seed);\n    ui += ua + useed;\n    float v = float(ua * ui + uc + useed + useed);\n    if (v == 0.) v = 1.;\n    return abs(float(ui) / v);\n}\n\nfloat rand(float i) {\n    float k = i;\n    if (i == 0.) k = 1.;\n    int i2 = int(i * 2. / k);\n    return (rand(int(i)) + rand(i2)) / 2.0;\n}\n\nvec3 hash23(vec2 src) {\n    vec3 randV = vec3(rand(src.x), rand(src.y), rand(src.x * src.y + src.x + src.y + 8912.2793));\n    randV += dot(randV, randV+vec3(3799.6274,9567.3518,8575.2724));\n    return fract(randV);\n}\n\nvec2 hash32(vec3 src) {\n    vec2 randV = vec2(rand(src.x), rand(src.y)) + vec2(rand(src.z), rand(src.z + 9463.9522));\n    randV += dot(randV, randV+vec2(8183.0119,4912.9833));\n    return fract(randV);\n}\n\nfloat d(vec2 p0, vec2 p1) {\n    return sqrt(pow(p0.x - p1.x, 2.0) + pow(p0.y - p1.y, 2.0));\n}\n\nconst vec3 colors[1] = vec3[1](\nvec3(0.9686, 0.2706, 0.1176)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((fragCoord - .5 * iResolution.xy) / iResolution.y);\n    vec3 col = vec3(0, 0, 0); // Default background color\n    float width = 200.0; \n\n    // Pixelation effect\n    float pixelSize = 1.0; // Adjust this value for more or less pixelation\n    vec2 pixelatedCoord = floor(fragCoord / pixelSize) * pixelSize + pixelSize * 0.5;\n    \n    for(int i = 0; i < numOfPoints; i++) {\n        vec2 pointBase = vec2(float(i) + 100000., float(numOfPoints - i) + 539.2171);\n        float time = iTime / 5.;\n        float t = fract(time);\n        vec2 prev = hash32(vec3(pointBase, floor(time)));\n        vec2 next = hash32(vec3(pointBase, ceil(time)));\n        vec2 point = (prev + ((next - prev) * t)) * iResolution.xy;\n        float dist = d(point, pixelatedCoord);\n        \n        vec3 currentColor = colors[i % 2];\n        \n        if(dist < width) {\n            vec3 blendColor = currentColor * smoothstep(1., 0., dist / width);\n            col = blendColor + col; // Additive blending\n        }\n    \n    }\n    \n    col = clamp(col, 0.0, 1.0); // Ensure the resulting color does not exceed the limits\n\n    fragColor = vec4(col, 1.0);\n}\n\n","name":"Buffer A","description":"","type":"buffer"}]}