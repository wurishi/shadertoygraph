{"ver":"0.1","info":{"id":"4sdXzr","date":"1457398381","viewed":323,"name":"Cracker cars","username":"zackpudil","description":"A universe of cracker cars ~ 1 hrs","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","distancefields"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"float dBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n \nfloat dCylinder(vec3 p, vec2 c) {\n\tvec2 d = abs(vec2(length(p.xz),p.y)) - c;\n\treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n \nvoid rotate(inout vec2 p, float a, float f) {\n\tp = mat2(a*cos(f), a*sin(f), -a*sin(f), a*cos(f))*p;\n}\n \nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n \nvec2 scene(vec3 p, bool db) {\n\trotate(p.zy, 1.0, db ? -iTime : iTime);\n\tp.y = abs(p.y) - 3.15 - 0.02*sin(20.0*p.x)*sin(20.0*p.y)*sin(20.0*p.z);\n\tvec2 d1 = vec2(dBox(p, vec3(0.3, 0.1, 0.5)), 1.0);\n \n\trotate(p.xz, 1.0, 3.14/2.0);\n\trotate(p.zy, 1.0, 3.14/2.0);\n\t\n\tp.x = abs(p.x) - 0.4;\n\tp.y = abs(p.y) - 0.3;\n\t\n\tvec2 d2 = vec2(dCylinder(p, vec2(0.2, 0.03)), 2.0);\n\t\n\treturn opU(d1, d2);\n}\n \nvec2 map(vec3 p) {\n    vec2 chk = mod(p.xz + 4.0, 16.0) - 8.0;\n\tp.xz = mod(p.xz + 4.0, 8.0) - 4.0;\n    bool db = chk.x*chk.y < 0.0;\n\tvec2 w = vec2(length(p) - 3.0 + 0.05*sin(10.0*p.x)*sin(10.0*p.y)*sin(10.0*p.z), 0.0);\n\tvec2 s1 = scene(p, db);\n\tp = p.yzx;\n\tvec2 s2 = scene(p, db);\n\tp = p.yzx;\n\tvec2 s3 = scene(p, db);\n\t\n\tvec2 s = opU(s1, opU(s2, s3));\n\t\n\treturn opU(w, s);\n}\n \nvec2 intersect(vec3 ro, vec3 rd) {\n\tfloat mid = 0.0;\n\tfloat td = 0.0;\n\t\n\tfor(int i = 0; i < 128; i++) {\n\t\tvec2 s = map(ro + rd*td);\n\t\tif(s.x == 0.0) break;\n\t\ttd += s.x;\n\t\tmid = s.y;\n\t}\n\t\n\tif(td > 50.0) mid = -1.0;\n\treturn vec2(td, mid);\n}\n \nvec3 normal(vec3 p) {\n\tvec2 h = vec2(0.01, 0.0);\n\tvec3 n = vec3(\n\t\tmap(p + h.xyy).x - map(p - h.xyy).x,\n\t\tmap(p + h.yxy).x - map(p - h.yxy).x,\n\t\tmap(p + h.yyx).x - map(p - h.yyx).x\n\t);\n\t\n\treturn normalize(n);\n}\n \nfloat shadow(vec3 p, vec3 lig) {\n\tfloat res = 1.0;\n\tfloat td = 0.02;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tfloat h = map(p + lig*td).x;\n\t\ttd += h;\n\t\tres = min(res, 8.0*h/td);\n\t\tif(h == 0.0 || td > 10.0) break;\n\t}\n\t\n\treturn clamp(res, 0.0, 1.0);\n}\n \nvec3 lighting(vec3 p, vec3 l, vec3 rd) {\n\tvec3 lig = normalize(l);\n\tvec3 n = normal(p);\n\tvec3 ref = reflect(n, rd);\n\t\n\tfloat amb = clamp(0.7, 0.0, 1.0);\n\tfloat dif = clamp(dot(n, lig), 0.0, 1.0);\n\tfloat spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 152.0);\n\t\n\tdif *= shadow(p, lig);\n\t\n\tvec3 lin = vec3(0);\n\t\n\tlin += 0.3*amb*vec3(1);\n\tlin += 0.8*dif*vec3(1.0, .97, .85);\n\tlin += spe*vec3(1.0, .97, .56)*dif;\n\t\n\treturn lin;\n}\n \nmat3 camera(vec3 e, vec3 la) {\n\tvec3 roll = vec3(0, 1, 0);\n\tvec3 f = normalize(la - e);\n\tvec3 r = normalize(cross(roll, f));\n\tvec3 u = normalize(cross(f, r));\n\t\n\treturn mat3(r, u, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = -1.0+2.0*(fragCoord/iResolution.xy);\n\tuv.x *= iResolution.x/iResolution.y;\t\n \n\tvec3 la = 4.0*vec3(cos(iTime*0.3), 0, -sin(iTime*0.3));\n\tvec3 ro = 3.0*vec3(1, 3.0, 0);\n\tvec3 rd = camera(ro, la)*normalize(vec3(uv, 2.0));\n \n\tvec3 l = 3.0*vec3(cos(iTime*0.2), 1.0, -sin(iTime));\n    \n    vec3 col = vec3(.34, .54, .89);\n\tcol *= mix(0.6, 1.0, uv.y);\n\tvec2 i = intersect(ro, rd);\n\t\n\tif(i.y > -1.0) {\n\t\tvec3 p = ro + rd*i.x;\n\t\tif(i.y == 0.0) col = vec3(.75, 0, .85);\n\t\tif(i.y == 1.0) col = vec3(.95, .34, 0);\n\t\tif(i.y == 2.0) col = vec3(.7, .4, .5);\n\t\tcol *= lighting(p, l, rd);\n\t}\n\t\n\tfragColor = vec4(col, 1.0);\n}","name":"Image","description":"","type":"image"}]}