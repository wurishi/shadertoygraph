{"ver":"0.1","info":{"id":"wtfcRf","date":"1592602582","viewed":148,"name":"nova 2020 shadershowdown","username":"lovelyH","description":"Shader showdown at nova 2020.","likes":9,"published":1,"flags":0,"usePreview":0,"tags":["livecoding","nova","showdown"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define E 0.01\n#define INF 1000.0\n#define MAXT 200.0\n\nvec2 rot( vec2 p, float l ){\n  return vec2(\n    cos(l)*p.x - sin(l)*p.y,\n    sin(l)*p.x + cos(l)*p.y\n  );\n}\n\n\n\nvec3 mapLight;\n\n\nfloat map(vec3 p){\n  float r=p.z+1.0, rc;\n  vec3 ph;\n  mapLight= vec3(INF);\n  \n  r= min( r, length(p) );\n  \n  ph= p;\n  ph.y= mod( ph.y, 7.0 ) - 3.5;\n  ph.x= mod( ph.x - 0.0, 4.0 ) - 2.0;\n  rc= length(ph.xy) - 0.1;\n  ph.z= mod( ph.z - iTime, 8.0 ) - 4.0;\n\t//rc= min( rc, length(ph)-0.2-0.1*texture( texFFT, 0.01 ).r );\n    rc= min( rc, length(ph)-0.2);\n\tr= min( r, rc );\n  \n  ph= p;\n  ph.y= mod( ph.y, 5.0 ) - 2.5;\n  ph.x= mod( ph.x - 2.0, 4.0 ) - 2.0;\n  \n  rc= length( vec2( ph.y, length(ph.xz)-3.0 ) )-0.1;\n  r= min( r, rc );\n  \n  ph= p;\n  ph.y= mod( ph.y, 4.0 ) - 2.0;\n  ph.xz= rot( ph.xz, 4.0*iTime + 0.1*p.y );\n  ph.z -= 5.0;\n  rc= length(ph);\n  r= min( r, rc );\n  mapLight.x= min( mapLight.x, rc );\n\n  ph= p;\n  ph.y= mod( ph.y, 4.0 ) - 2.0;\n  ph.xz= rot( ph.xz, -4.0*iTime - 0.1*p.y );\n  ph.z -= 5.0;\n  rc= length(ph);\n  r= min( r, rc );\n  mapLight.y= min( mapLight.y, rc );\n  \n  ph= p;\n  ph.y= mod( ph.y, 4.0 ) - 2.0;\n  ph.x -= 7.0 * sin( iTime + 0.1 * p.y );\n\t//ph.z -= 2.0 + 1000.0*texture( texFFT, fract(0.1*p.y) ).r + sin(8.0*iTime+0.1*p.y);\n    ph.z -= 2.0 + sin(8.0*iTime+0.1*p.y);\n  rc= length(ph);\n  r= min( r, rc );\n  mapLight.z= min( mapLight.z, rc );\n  \n  return r;\n}\n\n\n\nvec3 render( vec3 sp, vec3 dir ){\n  vec3 r= vec3(0);\n  vec3 light= vec3(INF);\n  float power = 1.0;\n  \n  for( int i=0;i<2;i++){\n    vec3 p= sp;\n    float dis= map(p);\n    float t= dis;\n    \n    for( int i=0;i<0x100;i++){\n      p= sp + t*dir;\n      dis= map(p);\n      light= min( light, mapLight );\n      t += dis;\n      if( dis < E && MAXT < t ){\n        break;\n      }\n    }\n    \n    vec3 plight= mapLight;\n    vec3 nor;\n    \n    if( t < MAXT ){\n      \n      nor= normalize(vec3(\n        map(vec3(p.x+E,p.y,p.z))-map(vec3(p.x-E,p.y,p.z)),\n        map(vec3(p.x,p.y+E,p.z))-map(vec3(p.x,p.y-E,p.z)),\n        map(vec3(p.x,p.y,p.z+E))-map(vec3(p.x,p.y,p.z-E))\n      ));\n      \n      r= vec3(power)\n        * (0.5+0.5*dot(nor,-dir))\n        * (0.5+0.5*dot(nor,vec3(0,0,1)))\n        * (1.0 / (1.0 + t ) )\n      ;\n      r += power * (1.0 / (1.0 + 2.1*plight ) );\n      \n      \n      dir= reflect( dir, nor );\n      sp= p;\n      power *= 0.1;\n      \n    }else{\n      break;\n    }\n  }\n  \n  return r\n     + ( 1.0 / (1.0 + light ) )\n  ;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - vec2(.5);\n    uv.x *= iResolution.x / iResolution.y;\n     \n\tvec3 dir= normalize( vec3( uv.x, 4.0, uv.y ) );\n  \n    fragColor.xyz= render( vec3( 0, 40.0*iTime, 1 ), dir );\n}","name":"Image","description":"","type":"image"}]}