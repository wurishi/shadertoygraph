{"ver":"0.1","info":{"id":"DddGDl","date":"1678203917","viewed":100,"name":"Collision Detection & Separation","username":"mikolalysenko","description":"Numerical 3D collision detection and separation between arbitrary SDFs.   Sort of works, but has some instability for deep intersections.  I'm still experimenting with various ways to improve this.\n","likes":6,"published":1,"flags":0,"usePreview":0,"tags":["collision","sdf","intersection","separation","contact"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Contact detection code by Mikola Lysenko\n//\n//\n// Rendering code based on \"RayMarching starting point\" https://www.shadertoy.com/view/WtGXDD\n//      Martijn Steinrucken aka The Art of Code/BigWings - 2020\n\n\n#define CONTACT_ITERS 10\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n#define TAU 6.283185\n#define PI 3.141592\n\n// animation state\nfloat offset = 0.;\nbool hit = false;\nvec3 posA = vec3(0., 0., 0.);\nmat3 rotA = mat3(\n    1., 0., 0.,\n    0., 1., 0.,\n    0., 0., 1.);\n\nvec3 posB = vec3(0., 0., 0.);\nmat3 rotB = mat3(\n    1., 0., 0.,\n    0., 1., 0.,\n    0., 0., 1.);\nvec3 qA = vec3(0);\nvec3 qB = vec3(0);\nvec3 ab = vec3(0.);\n\nvec3 minHit = vec3(0.);\n\n\n// standard sdf stuff\nfloat sdSphere( vec3 p, vec3 c, float s ) {\n  return length(p - c)-s;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdPlane (vec3 p) {\n    return p.y;\n}\n\n\n// shape signed distance functions\nfloat sdA (vec3 p) {\n    return sdTorus(rotA * (p - posA), vec2(1.2, 0.35));\n    // return sdPlane(p + 0.5);\n}\nfloat sdB (vec3 p) {\n    return sdTorus(rotB * (p - posB), vec2(1.2, 0.35));\n    // return sdSphere(p, posB, 0.3);\n}\n\n// gradients for shape sdfs\nvec3 gradA (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdA(p) - \n        vec3(sdA(p-e.xyy), sdA(p-e.yxy),sdA(p-e.yyx));    \n    return normalize(n);\n}\nvec3 gradB (vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = sdB(p) - \n        vec3(sdB(p-e.xyy), sdB(p-e.yxy),sdB(p-e.yyx));    \n    return normalize(n);\n}\n\n// helper: project a point p along the direction n to the offset surface within a ball of radius r\nvec3 supA (vec3 n, vec3 p, float r, float offset) {\n    vec3 x = p + n * r;\n    float f = sdA(x) - offset;\n    vec3 df = gradA(x);\n    if (dot(df, n) < 0.) {\n        df = -df;\n    }\n    return x - min(abs(f), r) * df;\n}\nvec3 supB (vec3 n, vec3 p, float r, float offset) {\n    vec3 x = p + n * r;\n    float f = sdB(x) - offset;\n    vec3 df = gradB(x);\n    if (dot(df, n) < 0.) {\n        df = -df;\n    }\n    return x - min(abs(f), r) * df;\n}\n\n\n#define SMOOTH_K 0.05\nfloat smoothedSDF (vec3 p, vec3 shift) {\n    return log(exp(SMOOTH_K * sdA(p)) + exp(SMOOTH_K * sdB(p))) / SMOOTH_K;\n}\n\nvec3 smoothedGrad(vec3 p, vec3 k) {\n    vec2 d = vec2(0.001, 0.0);\n    return normalize(vec3(\n        smoothedSDF(p + d.xyy, k) - smoothedSDF(p - d.xyy, k),\n        smoothedSDF(p + d.yxy, k) - smoothedSDF(p - d.yxy, k),\n        smoothedSDF(p + d.yyx, k) - smoothedSDF(p - d.yyx, k)\n    ));\n}\n\nvec3 findMin(vec3 startPos, vec3 k) {\n    vec3 position = startPos;\n    float minValue = smoothedSDF(position, k);\n    vec3 minPos = startPos;\n    for (int i = 0; i < 25; ++i) {\n        vec3 grad = smoothedGrad(position, k);\n        position -= 0.05 * grad;\n        float currentValue = smoothedSDF(position, k);\n        if (currentValue < minValue) {\n           minPos = position;\n           minValue = currentValue;\n        }\n    }\n\n    return minPos;\n}\n\n//\n// begin actually interesting code\n//\nvoid solveContact () {\n    vec3 shift = vec3(0., 0, 0.);\n\n    for (int outerIter = 0; outerIter < 1; ++outerIter) {\n        qA = posA;\n        qB = posB - shift;\n        \n        // idea is to approximate shapes by some convexish analog of their sdf\n        // do numerical iteration to find antipodes of their localized convex intersection\n        // and progressively sharpen/deconvexify them as we step\n        \n        vec3 x0 = findMin(0.5 * (qA + qB), shift);\n        minHit = x0;\n        vec3 n0 = gradA(x0);\n\n        // start from initially offset shapes and slowly shrink them\n        // offset should be chosen based on geometry, roughly summing with offset should\n        // make shape nearly convex\n        offset = 2.;\n        \n        qA = x0;\n        qB = x0 - shift;\n\n        float fa = sdA(qA) - offset;\n        float fb = sdB(qB + shift) - offset;\n        \n        if (max(fa, fb) < -offset) {\n            hit = true;\n        } else {\n            break;\n        }\n\n        // should iterate until offset is small enough that intersection is resolved\n        for (int iter=0; iter<10; ++iter) {\n\n            offset *= 0.5;\n\n            // estimate radius of local neighborhood to search\n            float rad = (length(qA - qB) + max(abs(fa),  abs(fb)));\n\n            // search point on B farthest from A within ball\n            n0 = gradB(x0 + shift);\n            qB = supA(-n0, x0, rad, offset);\n            fb = sdB(qB + shift) - offset;\n            if (fb > 0.) {\n                qB = qB - fb * gradB(qB + shift);\n            }\n            x0 = qB;\n\n            // search point on A farthest from B within ball\n            n0 = gradA(x0);\n            qA = supB(-n0, x0 + shift, rad, offset) - shift;\n            fa = sdA(qA) - offset;\n            if (fa > 0.) {\n                qA = qA - fa * gradA(qA);\n            }\n            x0 = qA;\n\n        }\n\n        vec3 delta = qA - qB;\n        shift -= delta;\n        if (length(delta) < 0.01) {\n            break;\n        }\n   }\n   \n   ab = shift;\n}\n//\n// end actually interesting code\n//\n\n\n// standard rendering stuff.  do 3 passes for each of the transparent layers, whatever.\nfloat GetDistSolid(vec3 p) {\n    float d = min(sdSphere(p, qA, 0.05), sdSphere(p, qB, 0.005));\n    d = min(d, sdCapsule(p, qA, qB, 0.005));\n    d = min(d, sdSphere(p, minHit, 0.07));\n    return d;\n}\nfloat RayMarchSolid(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistSolid(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalSolid(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistSolid(p) - \n        vec3(GetDistSolid(p-e.xyy), GetDistSolid(p-e.yxy),GetDistSolid(p-e.yyx));    \n    return normalize(n);\n}\n\nfloat GetDistAlphaC(vec3 p) {\n    float d = min(sdA(p), sdB(p + ab));\n    return d;\n}\nfloat RayMarchAlphaC(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlphaC(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalAlphaC(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlphaC(p) - \n        vec3(GetDistAlphaC(p-e.xyy), GetDistAlphaC(p-e.yxy),GetDistAlphaC(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetDistAlpha(vec3 p) {\n    float d = min(sdA(p) - offset, sdB(p) - offset);\n    return d;\n}\nfloat RayMarchAlpha(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDistAlpha(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\nvec3 GetNormalAlpha(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = GetDistAlpha(p) - \n        vec3(GetDistAlpha(p-e.xyy), GetDistAlpha(p-e.yxy),GetDistAlpha(p-e.yyx));\n    \n    return normalize(n);\n}\n\n// camera\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 \n        f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // update animation\n    float tt = 0.1 * iTime;\n    posB = vec3(3. * cos(tt), sin(3.3 * tt), 0.);\n    mat2 rr = Rot(tt * 0.5);\n    rotB = mat3(\n        rr[0].x, rr[0].y, 0.,\n        rr[1].x, rr[1].y, 0.,\n        0., 0., 1.);\n    mat2 qq = Rot(tt * 0.311);\n    rotB = rotB * mat3(\n        qq[0].x, 0., qq[0].y,\n        0., 1., 0.,\n        qq[1].x, 0., qq[1].y);\n\n    // solve for intersections\n    solveContact();\n    \n    // do the usual rendering stuff\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*PI+1.);\n    ro.xz *= Rot(-m.x*TAU);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0,0.,0), 1.);\n    vec3 col = vec3(0);\n    \n    float dSolid = RayMarchSolid(ro, rd);\n    if (dSolid < MAX_DIST) {\n        col = vec3(2., 0., 0.);\n    } else {\n        dSolid = MAX_DIST;\n    }\n    float dAlpha0 = RayMarchAlphaC(ro, rd);\n    if(dAlpha0<dSolid) {\n        vec3 p = ro + rd * dAlpha0;\n        vec3 n = GetNormalAlphaC(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        if (hit) {\n            col = mix(col, dif * vec3(1., 0.5, 0.2), 0.4);\n        } else {\n            col = mix(col, dif * vec3(0., 1., 1.), 0.3);\n        }\n    }\n    float dAlpha1 = RayMarchAlpha(ro, rd);\n    if(dAlpha1<dSolid) {\n        vec3 p = ro + rd * dAlpha1;\n        vec3 n = GetNormalAlpha(p);\n        vec3 r = reflect(rd, n);\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = mix(col, vec3(dif), 0.2);\n    }\n    \n    col = pow(col, vec3(.4545));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}