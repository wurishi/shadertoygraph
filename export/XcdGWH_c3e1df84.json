{"ver":"0.1","info":{"id":"XcdGWH","date":"1711649297","viewed":53,"name":"Gabor + Phasor noise","username":"sgciprian","description":"Textbook implementation of Gabor and Phasor noises\nShows Phasor noise by default, feft click on the screen to switch to Gabor","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["noise"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"// Lewis noise\n// https://dl.acm.org/doi/pdf/10.1145/74334.74360\n\n// Gabor noise\n// https://inria.hal.science/inria-00606821v1/document\n\n// Phasor noise\n// https://hal.science/hal-02118508/file/ProceduralPhasorNoise.pdf\n\n\n#define PI 3.1415926538\n#define UINT_MAX 4294967295u\n\n\n// CONFIGURATION\nfloat KERNEL_BANDWIDTH = 0.01;\nint KERNELS_PER_CELL = 16;\nuint RANDOM_OFFSET = 25565u;\n\nfloat K = 1.0;              // Gaussian magnitude\nfloat F_0 = 0.0625;         // Gaussian frequency\nfloat w_0 = radians(70.0);  // Harmonic orientation\n\n\n// computed constants\nfloat KERNEL_RADIUS;\n\nvoid init() {\n    KERNEL_RADIUS = 1.0 / KERNEL_BANDWIDTH;\n}\n\n\n\n// PRNG\n// multiplier from doi:10.1007/bf01937326\nuint _prng_x;\nvoid prng_seed(uint s) {\n    _prng_x = s;\n}\nuint prng_next() {\n    _prng_x *= 3039177861u;\n    // we get mod 2^32 for free since\n    // \"Operations resulting in overflow ... yield the low-order 32 bits of the result\"\n    return _prng_x;\n}\nfloat prng_01() {\n    return float(prng_next()) / float(UINT_MAX);\n}\nfloat prng_ab(float a, float b) {\n    return a + (b - a) * prng_01();\n}\n\n\n// 2d coordinate to integer (in Morton order) + offset =  non-periodic seed\nuint morton(ivec2 xy) {\n    int x = xy.x; int y = xy.y;\n\n    // http://www-graphics.stanford.edu/~seander/bithacks.html#InterleaveBMN\n    int B[4] = int[](0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF);\n    int S[4] = int[](1, 2, 4, 8);\n\n    int z; // z gets the resulting 32-bit Morton Number.  \n            // x and y must initially be less than 65536.\n\n    x = (x | (x << S[3])) & B[3];\n    x = (x | (x << S[2])) & B[2];\n    x = (x | (x << S[1])) & B[1];\n    x = (x | (x << S[0])) & B[0];\n\n    y = (y | (y << S[3])) & B[3];\n    y = (y | (y << S[2])) & B[2];\n    y = (y | (y << S[1])) & B[1];\n    y = (y | (y << S[0])) & B[0];\n\n    z = x | (y << 1);\n    return uint(z);\n}\n\n\n// gabor noise\n//\n// the viewport is split into a grid of cells\n// each cell has impulses (Gabor kernels) in it\n\n// same notation as in paper\nfloat gabor_kernel(\n    float K,   // magnitude of Gaussian\n    float a,   // width of Gaussian\n    float F_0, // magnitude of harmonic's frequency\n    float w_0, // orientation of harmonic's frequency\n    vec2 d\n) {\n    float sq_a = a * a;\n    float sq_x = d.x * d.x;\n    float sq_y = d.y * d.y;\n    \n    float gaussian = K * exp(-PI * sq_a * (sq_x + sq_y));\n    float harmonic = cos(2.0 * PI * F_0 * (d.x * cos(w_0) + d.y * sin(w_0)));\n    return gaussian * harmonic;\n}\n\nfloat gabor_cell(ivec2 ci, vec2 cp) {\n    uint seed = morton(ci) + RANDOM_OFFSET;\n    prng_seed(seed > 0u ? seed : 1u);\n    \n    float noise = 0.0;\n    for (int k = 0; k < KERNELS_PER_CELL; k++) {\n        // random position within cell and weight\n        float kernel_weight = prng_ab(-1.0, 1.0);\n        vec2 kernel_pos = vec2(prng_01(), prng_01());\n        vec2 d = (cp - kernel_pos) * KERNEL_RADIUS;\n        \n        // use random omega for isotropic noise\n        //noise += kernel_weight * gabor_kernel(K, KERNEL_BANDWIDTH, F_0, prng_ab(0.0, 2.0 * PI), d);\n        noise += kernel_weight * gabor_kernel(K, KERNEL_BANDWIDTH, F_0, w_0, d);\n    }\n    \n    return noise;\n}\n\nfloat gabor(vec2 uv) {\n    vec2 cell_uv = uv / KERNEL_RADIUS;\n    ivec2 cell_idx = ivec2(cell_uv);\n    vec2 cell_pos = cell_uv - vec2(cell_idx);\n    \n    float noise = 0.0;\n    // cell size is equal to kernel radius so we only need to compute\n    // noise for the current cell and direct neighbours\n    for (int di = -1; di <= 1; di++)\n        for (int dj = -1; dj <= 1; dj++)\n            noise += gabor_cell(cell_idx+ivec2(di,dj), cell_pos-vec2(di,dj));\n    \n    return noise;\n}\n\nfloat normalized_gabor(vec2 uv) {\n    float noise = gabor(uv);\n    float variance = (2.0 * sqrt(float(KERNELS_PER_CELL) * 0.25 * exp(-2.0* PI * F_0 * F_0 / (KERNEL_RADIUS * KERNEL_RADIUS))));\n    return noise / variance;\n}\n\n\n// phasor noise\nvec2 phasor_kernel(\n    float F_0,\n    float a,\n    float w_0,\n    float phi,\n    vec2 d\n) {\n    float sq_a = a * a;\n    float sq_x = d.x * d.x;\n    float sq_y = d.y * d.y;\n    \n    float gaussian = K * exp(-PI * sq_a * (sq_x + sq_y));\n    \n    float s = sin(2.0 * PI * F_0  * (d.x * cos(w_0) + d.y * sin(w_0)) + phi);\n    float c = cos(2.0 * PI * F_0  * (d.x * cos(w_0) + d.y * sin(w_0)) + phi);\n    return gaussian * vec2(s, c);\n}\n\nvec2 phasor_cell(ivec2 ci, vec2 cp) {\n    uint seed = morton(ci) + RANDOM_OFFSET;\n    prng_seed(seed > 0u ? seed : 1u);\n    \n    vec2 noise = vec2(0.0);\n    for (int k = 0; k < KERNELS_PER_CELL; k++) {\n        vec2 kernel_pos = vec2(prng_01(), prng_01());\n        vec2 d = (cp - kernel_pos) * KERNEL_RADIUS;\n        float phi = prng_ab(0.0, 2.0 * PI);\n        noise += phasor_kernel(F_0, KERNEL_BANDWIDTH, w_0, phi, d);\n    }\n    \n    return noise;\n}\n\nvec2 phasor(vec2 uv) {\n    vec2 cell_uv = uv / KERNEL_RADIUS;\n    ivec2 cell_idx = ivec2(cell_uv);\n    vec2 cell_pos = cell_uv - vec2(cell_idx);\n    \n    vec2 noise = vec2(0.0);\n    for (int di = -1; di <= 1; di++)\n        for (int dj = -1; dj <= 1; dj++)\n            noise += phasor_cell(cell_idx+ivec2(di,dj), cell_pos-vec2(di,dj));\n    \n    return noise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init();\n    \n    if (iMouse.z > 0.0) {\n        float noise = normalized_gabor(fragCoord);\n        fragColor = vec4(0.5 + 0.5 * noise);\n    }\n    else {\n        vec2 noise = phasor(fragCoord);\n        float phi = atan(noise.y, noise.x);\n        fragColor = vec4(vec3(sin(phi) * 0.5 + 0.5), 0.0);\n    }\n}","name":"Image","description":"","type":"image"}]}