{"ver":"0.1","renderpass":[{"outputs":[],"inputs":[],"code":"// Notes (read first):\n\n// Note 1: LHS is normal raymarch, RHS is Fixed Point Iteration. Intensity is a visualisation\n// of the iteration count. Click to visualise the difference in intersection point distance\n// between raymarch and FPI (red is 1 unit away or more from the real surface).\n\n// Note 2: The rest of the explanation is probably not interesting to a lot of people.\n// To see how this *may* benefit your shaders, look at the difference between the termination\n// mechanisms of raymarchNormal and raymarchFPI. Try the FPI version and see if it gives you\n// an improvement (and let me know :)). In many cases the difference won't be visible, and\n// normal raymarching is a simpler and cheaper choice.\n\n// Full story:\n\n// Fixed Point Iteraion is the little brother of Newton-Raphson iteration.\n// I have applied it in the past to do efficient stereo and temporal reprojection [1,2]\n// and to sample trochoids as a heightmap to find ocean water height [3]. I'm sure\n// others have used it as well, usually when you read about some kind of lookup with a\n// subsequent correction step, it is likely to be a couple of iterations of FPI.\n\n// I wanted to show its usefulness here to compute intersections with a set\n// of sinusoids (which can't be efficiently raytraced directly as the equation to\n// solve is transcendental). Surprisingly, when I posed it as FPI, it was exactly\n// the same iteration as raymarching. I've now come to think of raymarch as using\n// iteration to solve for t, where t is a root of the distance function along the \n// ray (and the first root if we want correct z-order). The only difference between\n// FPI and raymarching is the termination condition - raymarch terminates when it\n// lands on or inside the surface, whereas FPI terminates strictly on the surface.\n\n// I have made a new shader to show the distance values along the ray:\n// https://www.shadertoy.com/view/ldsGWl\n\n// All this doesn't change much - I think the raymarch condition (\"on or inside\") is better\n// suited for real-time graphics where an exact intersection is typically less important\n// than getting a visually plausible result as cheaply as possible.\n\n// However it does allow one to make statements about the properties of raymarching, as\n// the properties of FPI are well understood (see any numerical methods textbook,\n// or [1,2]). This assumes a real distance field. Also it's worth checking out a graph\n// of the distance function along the ray to help add context: https://www.shadertoy.com/view/ldsGWl .\n\n// * The convergence rate is linear in general. The linear constant is proportional\n//   to how close the ray passes nearby geometry.\n// * If the second and subsequent derivatives of the distance field are 0 along the ray,\n//   convergence rate is quadratic (raymarching towards a plane).\n// * If the gradient is constant along the ray, convergence is instantaneous\n//   (think ray marching a sphere, in a direction towards its center - one step is enough)\n// * If the derivative of the distance field is 0 or greater along the ray, it won't converge\n//   (because the distance values won't get smaller - think raymarching in a direction\n//   parallel to, or away from, a plane)\n\n// For pseudo-distance fields (such as using a heightmap as a distance function):\n\n// * If the gradient along the ray of the distance field is <= -2 in the region of an intersection,\n//   it won't converge. This wouldn't happen for a real distance field - when you move\n//   forward 1 unit, the distance value will change by at most 1 unit. But pseudo-distance\n//   fields can change by arbitary amounts along the ray. For the scene used in this shader,\n//   you can see the effect of this steep negative gradient - the iteration slows down on the\n//   front of the sinusoidal \"bumps\" as the gradient becomes more negative, or doesnt converge\n//   at all (keeps iterating forever).\n\n// Notes: In FPI the gradient must be in (-1,1) for convergence. I have shifted this\n// to (-2,0) as the iterated function is distancefield(p) + t, and the +t adds 1.\n// FPI doesn't care about any particular local gradients, it is only concerned\n// about the points where it lands. In particular the gradient conditions apply\n// to the local region around the intersection. The distance field could be very\n// ill-formed at some parts along the ray, but if it is not close to an intersection point\n// it shouldn't affect the iteration (on sharp contrast to Netwon-Raphson!)\n// Luckily the magnitude of the derivative can be reduced by scaling the distance field\n// down, which will therefore improve the convergence at the expense of more computation.\n// This is equivalent to the already known method of scaling down the step size.\n\n// Refs\n// [1] Bowles H., Mitchell K., Sumner R., Moore J. and Gross M., Iterative Image Warping, 2012\n// [2] Yang L., Bowles H. Accelerating Rendering Pipelines Using Bidirectional Iterative Reprojection, 2012\n// [3] Bowles H., Oceans on a Shoestring: Shape Representation, Meshing and Shading, 2013\n\n// Update: I found a way to dramatically strengthen the convergence by adding a\n// correction step at surface crossings: https://www.shadertoy.com/view/Mdj3W3\n\n\n#define ITERCNT 60\n#define STEPMULT 1.\n\nvec3 errorColour( float err, float maxerror );\n\n// the wavy surface\nfloat surfHeight( vec2 xz )\n{\n\treturn 2.*fract((iTime+3.)/10.)* (cos(xz.x) + cos(xz.y));\n}\n\n// evaluate the ray\nvec3 rayPt( vec3 ro, vec3 rd, float t )\n{\n\treturn ro + rd * t;\n}\n\n// the distance field\nfloat distField( vec3 pt )\n{\n\tfloat dSurf = pt.y - surfHeight(pt.xz);\n\treturn dSurf; // comment this out to put a sphere in the scene\n\t\n\tvec4 sph = vec4(0.,1.,0.,1.);\n\tfloat dSph = length(pt.xyz-sph.xyz)-sph.w;\n\treturn min( dSph, dSurf );\n}\n\n// normal raymarch\nfloat raymarchStandard( vec3 ro, vec3 rd, out float cnt )\n{\n\tfloat t = 0.;\n\t\n\tfloat d = 1000.;\n\tcnt = 0.;\n\t\n\tfor( int i = 0; i < ITERCNT; i++ )\n\t{\n\t\t// termination condition - near or underneath surface\n\t\tif( d < 0.001 )\n\t\t\tcontinue;\n\t\t\n\t\tvec3 pt = rayPt(ro,rd,t);\n\t\td = distField( pt );\n\t\tcnt += 1.;\n\t\tt += STEPMULT*d;\n\t}\n\t\n\treturn t;\n}\n\n// raymarch with FPI termination criteria\nfloat raymarchFPI( vec3 ro, vec3 rd, out float cnt )\n{\n\t// FPI solves equations f(x)=x.\n\t// Choose\n\t//\t\tf(t) = distField(ro+rd*t) + t\n\t// and use FPI to iterate on t until\n\t// \t\tf(t) = t\n\t// (Which means distField() == 0)\n\t\n\t// initial guess for t - just pick the start of the ray\n\tfloat t = 0.;\n\t\n\tcnt = 0.;\n\tfloat last_t = 10000.; // something far away from t0\n\tfor( int i = 0; i < ITERCNT; i++ )\n\t{\n\t\t// termination condition - iteration has converged to surface\n\t\tif( abs(last_t - t) < 0.001 )\n\t\t\tcontinue;\n\t\t\n\t\tcnt += 1.;\n\t\t\n\t\tlast_t = t;\n\t\t\n\t\tvec3 pt = rayPt(ro,rd,t);\n\t\tfloat d = distField( pt );\n\t\tt += STEPMULT*d;\n\t}\n\t\n\treturn t;\n}\n\n// this \"works\" but NR is useless most of the time :/. its very sensitive\n// to gradients and can blow up very easily. it would give slightly better results if the\n// step size was compute for the sphere and the waves separately (I think this is exactly what I\n// am doing in https://www.shadertoy.com/view/lds3DB) but this is a work around for the\n// core issue that NR is useless!\nfloat raymarchNewtonRaphson( vec3 ro, vec3 rd, out float cnt )\n{\n\tfloat t = 0.;\n\t\n\tfloat d = 1000.;\n\tcnt = 0.;\n\t\n\tfloat eps = 0.1;\n\t\n\tfor( int i = 0; i < ITERCNT; i++ )\n\t{\n\t\t// termination condition - iteration has converged\n\t\tif( d < 0.01 )\n\t\t\tcontinue;\n\t\t\n\t\tvec3 pt = rayPt(ro,rd,t);\n\t\td = distField( pt );\n\t\t\n\t\tvec3 pt1 = rayPt(ro,rd,t+eps);\n\t\tfloat d1 = distField( pt1 );\n\t\t\n\t\tcnt += 1.;\n\t\t\n\t\tt -= STEPMULT * d / ( (d1-d)/eps );\n\t}\n\t\n\treturn t;\n}\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// yellow bar\n\tif( abs(fragCoord.x - iResolution.x/2.) < 2. /*&& fragCoord.y < iResolution.y/2.*/)\n\t{\n\t\tfragColor.rg = vec2(1.0);\n\t\treturn;\n\t}\n\t\n\t// get aspect corrected normalized pixel coordinate\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 pp = -1.0 + 2.0*q;\n    pp.x *= iResolution.x / iResolution.y;\n    \n\tvec3 ro;\n    vec3 rd = computePixelRay( pp, ro );\n\t\n\tfloat cnt;\n\tfloat t = 0.;\n\t\n\t// pick iteration method based on side of screen\n\tif( pp.x < 0. )\n\t{\n\t\tt = raymarchStandard(ro,rd, cnt);\n\t}\n\telse\n\t{\n\t\tt = raymarchFPI(ro,rd, cnt);\n\t\t//t = raymarchNewtonRaphson(ro,rd, cnt);\n\t}\n\t\n\tvec3 pt = ro + t * rd;\n\t\n\tfloat iters = clamp(cnt/float(ITERCNT),0.,1.);\n\t\n\tfragColor.xyz = vec3( iters );\n\t\n\t// debug vis to show error between iterated location and actual surfaces\n\tif( iMouse.z > 0. )\n\t{\n\t\t// convert dist from surface to colour\n\t\tfloat maxerror = 1.;\n\t\tfragColor.xyz = errorColour( clamp(abs(distField(pt)),0.,maxerror), maxerror );\n\t} \n\t\n\t// leftover debug code\n\t\n\t// vis iter cnt\n\t//fragColor.xyz =vec3(clamp(1.-cnt/50.,0.,1.));\n\n\t// difference in ray distance between two iterations\n\t/*fragColor.xyz = vec3(.3*log(\n\tabs(raymarch(ro,rd, cnt) - intersectSurface(ro,rd, cnt))\n\t));*/\n}\n\n\n\n\n\n\nvec3 computePixelRay( in vec2 p, out vec3 cameraPos )\n{\n    // camera orbits around origin\n\t\n    float camRadius = 3.8;\n\t// use mouse x coord\n\tfloat a = iTime*20.;\n\t//if( iMouse.z > 0. )\n\t//\ta = iMouse.x;\n\tfloat theta = -(a-iResolution.x)/80.;\n    float xoff = camRadius * cos(theta);\n    float zoff = camRadius * sin(theta);\n    cameraPos = vec3(xoff,3.,zoff);\n     \n    // camera target\n    vec3 target = vec3(0.,2.,0.);\n     \n    // camera frame\n    vec3 fo = normalize(target-cameraPos);\n    vec3 ri = normalize(vec3(fo.z, 0., -fo.x ));\n    vec3 up = normalize(cross(fo,ri));\n     \n    // multiplier to emulate a fov control\n    float fov = .5;\n\t\n    // ray direction\n    vec3 rayDir = normalize(fo + fov*p.x*ri + fov*p.y*up);\n\t\n\treturn rayDir;\n}\n\n\n\nvec3 hsv2rgb(vec3 c);\nvec3 rgb2hsv(vec3 c);\n\nvec3 errorColour( float err, float maxerror )\n{\n\terr = 1. - err / maxerror;\n\terr *= 2. / 3.;\n\treturn hsv2rgb( vec3(err, 1., 1.) );\n}\n\n\n//http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n","name":"Image","description":"","type":"image"}],"flags":{"mFlagVR":false,"mFlagWebcam":false,"mFlagSoundInput":false,"mFlagSoundOutput":false,"mFlagKeyboard":false,"mFlagMultipass":false,"mFlagMusicStream":false},"info":{"id":"4ssGWl","date":"1381763183","viewed":628,"name":"Raymarching == FPI","username":"huwb","description":"It seems that ray marching is equivalent to 1D Fixed Point Iteration over the ray param t but with a relaxed termination criteria. Left is normal raymarch, right is FPI. Shading is iteration count. Click to see error (dist from actual surface).","likes":13,"published":1,"flags":0,"usePreview":0,"tags":["raymarch","fpi","convergence","iteration"],"hasliked":0,"parentid":"","parentname":""}}