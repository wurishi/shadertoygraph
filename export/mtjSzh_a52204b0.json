{"ver":"0.1","info":{"id":"mtjSzh","date":"1675696798","viewed":386,"name":"Swirled","username":"Kali","description":"A collection of spheres with a twisted animated texture and experimental shading including a bloom effect. It changes its parameters every 10 seconds using iDate as a seed for the hashes.","likes":55,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","underwater","bloom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float max_rad=.05;\nconst float it=100.;\n\nmat2 rot(float a){\n\tfloat s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat hash(vec2 p)\n{\n    p*=1342.;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec2 uv = fragCoord/iResolution.xy;\n\t     uv.y = 1.-uv.y;\n    vec2 uv2=floor(uv*50.)/50.;\n\tmat2 spin=rot(2.39996);\n    vec2 p=vec2(0.,1.);\n    vec3 res=vec3(0.);\n    float ti=mod(iTime,10.);\n    float rad_step=max_rad/it+hash(uv+ti)*.0003;\n\tfloat rad=0.;\n    vec4 col=texture(iChannel0,uv);\n    for (float i=0.;i<it; i++) {\n        rad+=rad_step;\n        p*=spin;\n        vec4 col=texture(iChannel0,uv+p*rad);\n        res+=smoothstep(.5,1.,max(col.r,max(col.g,col.b)))*col.rgb;\n    };\n    res/=it;\n    col.rgb=mix(length(col.rgb)*vec3(.5),col.rgb,.75);\n    vec4 ff = vec4(col.rgb*.5+res,1.0);\n    ff+=(hash(uv+(ti*20.))-.5)*.05;\n    ff.g=min(ff.r*1.5,ff.g);\n    ff.g=min(ff.b*1.5,ff.g);\n    fragColor = ff;\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define fxrand floor(iDate.w/10.)*.1456512\n#define hash1 rnd(fxrand+.6546)\n#define hash2 rnd(fxrand+1.1123)\n#define hash8 rnd(fxrand+7.1376)\n#define hash9 rnd(fxrand+8.9176)\n#define hash10 rnd(fxrand+10.1076)\n#define hash11 rnd(fxrand+11.1113)\n#define hash12 rnd(fxrand+21.1196)\n#define hash13 rnd(fxrand+41.1276)\n#define hash15 rnd(fxrand+15.8246)\n#define hash16 rnd(fxrand+16.8264)\n#define hash17 rnd(fxrand+17.1824)\n#define hash19 rnd(fxrand+19.2824)\n#define hash20 rnd(fxrand+20.4814)\n\n#define time iTime*.1\n#define resolution iResolution\n\n\nfloat det=.001;\nvec3 pos;\n\n\nfloat rnd(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat fractal(vec3 p) {\n  float depth = smoothstep(0., 6., -p.z + 5.);\n  p *= .3;\n  p = abs(2. - mod(p + vec3(0.4, 0.7, time), 4.));\n  float ls = 0.;\n  float c = 0.;\n  for (int i = 0; i < 6; i++) {\n    p = abs(p) / min(dot(p, p), 1.) - .8;\n    float l = length(p);\n    c += abs(l - ls);\n    ls = l;\n  }\n  return smoothstep(0., 100., c) * 3.;\n}\n\nfloat de(vec3 p) {\n    return length(p)-2.;\n}\n\nvec3 ldir;\n\nvec3 color(vec3 p) {\n    p.xz*=rot((p.y*(3.+hash2*15.)+time*20.)*sign(hash17-.5));\n    float a=.5+hash8*1.;\n    float b=.5+hash9*1.;\n    vec3 col=abs(mix(sin(p*a),cos(p*b),clamp(p.x,-1.5,1.5)));\n    col.rb*=rot(hash10*5.);\n    col.rg*=rot(hash11*5.);\n    col.gb*=rot(hash12*5.);\n    col=abs(col);\n    return col;\n}\n\nvec3 shade(vec3 p, vec3 dir, vec3 n) {\n    float amb=.3;\n    float dif=max(0.,dot(ldir,n))*.8;\n    vec3 col=color(pos)*1.;\n    return (amb+dif)*col;\n    \n}\n\nvec3 march(vec3 from, vec3 dir) {\n    ldir=normalize(vec3(hash19-.5,hash20-.5,-.5));\n    ldir=normalize(vec3(0.,hash20-.5,-.5));\n    float td=0.,d=0.,ref=0.,maxdist=45.;\n    vec3 col=vec3(0.),colref=col,p=from,g=col;\n    float fg = fractal(p + dir*5.) * .55;\n    for(int i=0; i<200; i++){\n        p+=d*dir;\n        d=de(p);\n        if (d<det&&ref>0.||td>maxdist) break;\n        if (d<det&&ref<1.) {\n            ref=1.;\n            vec3 n=normalize(p);\n            colref+=shade(p,dir,n);\n            dir=reflect(dir,n);\n            p+=dir*.1;\n        }\n        g+=.1/(.1+d);\n        td+=d;\n    }\n    vec3 n=normalize(p);\n    if (d>det) {\n        if (ref>.5) maxdist*=.5;\n        td=maxdist;\n        p=dir*maxdist;\n    } else {\n        col=shade(p,dir,n);\n    }\n    p.xy*=rot(hash16*3.);\n    vec3 di=dir;\n    di.xz*=rot(.5);\n    di.xy*=rot(.5);\n    vec3 back=color(di);\n    back=mix(vec3(length(back)*.5),back,.5);\n    back=sqrt(abs(back)*.45);\n    back+=fractal(p*.15)*back;\n    back+=pow(max(0.,dot(dir,ldir)),20.)*.5;\n    float r=.3+hash13*.6;\n    col=back;\n    col+=fg*1.5;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec2 uv2 = fragCoord/iResolution.xy-.5;\n    vec3 from=vec3(.0,.0,-4.-5.*hash15);\n    vec3 dir=normalize(vec3(uv,1.));\n    from.xz*=rot(1.+time*2.+1.);\n    dir.xz*=rot(1.+time*2.+1.);\n    vec3 col = march(from,dir);\n    vec3 buf = texture(iChannel0,fragCoord/iResolution.xy).rgb;\n    col=buf*.75+col*.25;\n    col*=smoothstep(.7,.47,abs(uv2.x));\n    col*=smoothstep(.7,.47,abs(uv2.y));\n \n    fragColor = vec4(col,1.)*step(.5,mod(iDate.w,10.));\n}\n","name":"Buffer A","description":"","type":"buffer"}]}