{"ver":"0.1","info":{"id":"NlfXW8","date":"1625524593","viewed":208,"name":"Stack Memory: Hotel Infinity","username":"sdfgeoff","description":"How can you store a dynamic list in a shader? Say, something where you may want to add and remove items. Here's one possible implementation. Use up/down arrows to push/pop.","likes":5,"published":1,"flags":48,"usePreview":0,"tags":["stack","dynamic","data","memory","list","filo"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"/* \n\n----------------------------- CONTEXT ----------------------------\nI am working on a game in shadertoy, and want the player to be\nable to shoot bullets. Somewhere all the bullets position and\nrotation needs to be stored, and when the player \"shoots\" a bullet\nneeds to be created. The solution? A stack. Each time a shot is fired,\nthe bullet is pushed onto the stack.\n\nThis implementation can only append one item per frame. I need to\nthink a bit more if I want to handle multiple items per frame.\n\n----------------------------- CONTROLS ----------------------------\n - Uparrow: push a random value onto the bottom of the stack\n - Downarrow: pop a value from the bottom of the stack.\n\nThis stack is actually iResolution.x high, I just only draw the first 20 items.\n\n\n--------------------- IMPLEMENTATION DETAILS ----------------------\n\nMost of the \"goodness\" is in Buffer A. This file just contains the UI\n\nThis implementation is inspired by \"Hotel Infinity\"\nhttps://en.wikipedia.org/wiki/Hilbert%27s_paradox_of_the_Grand_Hotel\nThe paradox asks what happens if you have an infinitely large and infinitely\nfull hotel. What happens if a new guest arrives? Every room already has a guest,\nbut you can ask the guests to all move along by one room.\n\nTurns out you can do the same with memory:\nWhen a new value turns up, just chuck it in address zero and ask everything\nelse to move along by one. Any other method would need to store the locations\nof available spaces or the number of current entries etc. etc.\n*/\n\n\n#define BUFFER_STATE iChannel0\n\n\nconst int channels_to_draw = 20;\n\nconst float tower_width = 0.1;\nconst float line_width = 0.005;\n\nconst vec4 border_color = vec4(0.5);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float center = abs(uv.x - 0.5);\n            \n    vec4 out_col = vec4(0.0);\n    \n    if (center - tower_width < 0.0) {\n        float address = uv.y * float(channels_to_draw);\n        int address_i = int(floor(address));\n        \n        if (mod(address, 1.0) < line_width * float(channels_to_draw)) {\n            out_col = border_color;\n            \n        } else {\n            out_col = read_stack(BUFFER_STATE, address_i);\n        }\n    } else if (center - tower_width - line_width * iResolution.y / iResolution.x < 0.0) {\n        out_col = border_color;\n    }\n    fragColor = out_col;\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[],"code":"// The stack starts at this location and extends along x+ axis\nconst ivec2 STACK_START_ADDRESS = ivec2(0,0);\n\n// Controls\nconst int KEY_UP   = 38;\nconst int KEY_DOWN = 40;\n\n\n// Fetch a single pixel from the state buffer buffer\nvec4 read_data(sampler2D buffer, ivec2 address){\n    return texelFetch(buffer, address, 0);\n}\n\n\nvec4 read_stack(sampler2D state_buffer, int address) {\n    return read_data(state_buffer, STACK_START_ADDRESS + ivec2(address,0));\n}","name":"Common","description":"","type":"common"},{"inputs":[{"id":"4dXGRr","filepath":"/presets/tex00.jpg","previewfilepath":"/presets/tex00.jpg","type":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"#define BUFFER_STATE iChannel0\n#define BUFFER_KEYBOARD iChannel1\n\n\n// Return the state of a key. Returns non-zero the first frame a key is touched\nfloat get_key_tap(int key_code) {\n    return texelFetch(BUFFER_KEYBOARD, ivec2(key_code,1), 0).x;\n}\n\n// Generate some random data to store\n// pinched from https://www.shadertoy.com/view/4djSRW\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 mem_address = ivec2(fragCoord);\n    \n    // Check that we are operating on the stack\n    if (mem_address.y == STACK_START_ADDRESS.y) {\n        int stack_address = (mem_address - STACK_START_ADDRESS).x;\n\n        bool push_value = get_key_tap(KEY_UP) != 0.0;\n        bool pop_value = get_key_tap(KEY_DOWN) != 0.0;\n\n\n        // If we need top add a new value, shift all the items along by one\n        if (push_value) {\n            vec3 data_to_store = hash31(iTime);\n            if (stack_address == 0) {\n                // Put our data in address zero\n                fragColor = vec4(data_to_store, 0.0);\n            } else {\n                // grab the data from the \"one lower\" address\n                fragColor = read_stack(BUFFER_STATE, stack_address - 1);\n            }\n        }\n        \n        // To remove a value, shift everything from the \"one higher\" address\n        else if (pop_value) {\n            fragColor = read_stack(BUFFER_STATE, stack_address + 1);\n            \n        // If we aren't pushing or poping, mantain existing value.\n        } else {\n            fragColor = read_stack(BUFFER_STATE, stack_address);\n        }\n        \n    } else {\n        // If you have a game you can plug the rest of your state management in here\n        fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n    }\n    \n    \n    \n}","name":"Buffer A","description":"","type":"buffer"}]}