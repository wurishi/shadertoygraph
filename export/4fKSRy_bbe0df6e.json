{"ver":"0.1","info":{"id":"4fKSRy","date":"1715400544","viewed":139,"name":"Psychedelic Saturn","username":"GarlicGraphix","description":"Decided to get wacky with this one","likes":18,"published":1,"flags":32,"usePreview":0,"tags":["raymarching","noise","space","trippy"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = texture(iChannel0, uv);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"// 2D Perlin noise function\nfloat noise(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = uv; // Scale the coordinates\n    p = atan(p*2.0-1.0+length(uv*2.0-1.0));\n    p = fract(p*1.0+length(uv*2.0-1.0)*5.0);\n    float time = iTime*0.001;\n    // Create a colorful pattern using Perlin noise\n    vec3 col = vec3(\n        noise(p + vec2(time, 0.0)),\n        noise(p + vec2(0.0, time)),\n        noise(p + vec2(time, time))\n    );\n    vec3 targetCol = vec3(\n        sin((length(p*2.0-1.0)+iTime)*20.0),\n        sin((length(p*2.0-1.0)+iTime)*15.0),\n        sin((length(p*2.0-1.0)+iTime)*10.0)\n    );\n    \n    if (length(targetCol-col) < 1.1) {\n        fragColor = vec4(targetCol, 1.0);\n    } else {\n        fragColor = texture(iChannel0, uv)-0.01;\n    }\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[{"id":"4dXGR8","filepath":"/media/previz/buffer00.png","previewfilepath":"/media/previz/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":"XsXGR8","filepath":"/media/previz/buffer01.png","previewfilepath":"/media/previz/buffer01.png","type":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"XsXGR8","channel":0}],"code":"mat2 rot2D(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c, -s, s, c);\n}\n\n#define PI 3.14159\n//sd functions by Inigo Quilez\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  //p.zy *= rot2D(PI/2.0);\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\n//From https://www.shadertoy.com/view/WtGXDD\nfloat getDist(vec3 p) {\n    float s = sdSphere(p , 1.0);\n    float t = sdTorus(p, vec2(1.5, 0.3));\n    t = max(sdPlane(p, normalize(vec3(0.0, 1.0, 0.0)), -0.01), t);\n    t = max(-sdPlane(p, normalize(vec3(0.0, 1.0, 0.0)), 0.01), t);\n    \n    return min(s, t);\n}\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    vec3 n = getDist(p) - \n        vec3(getDist(p-e.xyy), getDist(p-e.yxy),getDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord *2. - iResolution.xy) / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    m = vec2(0.68,0.53);\n    m.x += iTime*-0.1;\n    \n    vec3 origin = vec3(0.7, 0.0, -2.5+sin(iTime*0.4)*0.4);\n    \n    vec3 ray = normalize(vec3(uv, 1.0));\n    \n    origin.xz *= rot2D(-m.x*PI*2.0);\n    origin.yz *= rot2D(m.y*PI+1.);\n    \n    ray.xz *= rot2D(-m.x*PI*2.0);\n    ray.yz *= rot2D(m.y*PI+1.);\n        \n    float totDist = 0.0;\n    \n    for (int i = 0; i < 80; i++) {\n        vec3 pos = origin + ray * totDist;\n        \n        float dist = getDist(pos);\n        \n        totDist += dist;\n        \n        if (dist <= 0.001) {\n            break;\n        } else if (dist >= 100.0 || i == 79 ) {\n            vec2 flowUV = fragCoord/iResolution.xy;\n            fragColor = texture(iChannel1, flowUV*0.99)-0.001;\n            return;\n        }\n    }\n\n    vec3 mask = vec3(totDist* 0.2);\n    vec3 finalRay = origin + ray*totDist;\n    finalRay.xz *= rot2D(iTime*0.4);\n    vec3 normal = getNormal(finalRay);\n    \n    vec3 colXZ = texture(iChannel0, finalRay.xz * 0.25 + 0.5).rgb;\n    vec3 colXY = texture(iChannel0, finalRay.xz * 0.5 + 0.5).rgb;\n    vec3 colYZ = texture(iChannel0, finalRay.xz * 0.5 + 0.5).rgb;\n    \n    finalRay.xz *= rot2D(iTime*-0.4);\n    finalRay.yz *= rot2D(.9);\n    \n    vec3 sunNormal = getNormal(finalRay);\n    \n    vec3 col = colXZ * abs(normal.y) + colXY * abs(normal.z) + colYZ * abs(normal.x);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}","name":"Buffer B","description":"","type":"buffer"}]}